{"sha": "3cb8344bd34b50012b5c43c7d34d01472f41e026", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NiODM0NGJkMzRiNTAwMTJiNWM0M2M3ZDM0ZDAxNDcyZjQxZTAyNg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T17:49:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:49:53Z"}, "message": "a-dispat.ads, [...]: New files.\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\t    Jose Ruiz  <ruiz@adacore.com>\n\n\t* a-dispat.ads, a-diroro.ads, a-diroro.adb: New files.\n\n\t* ali.adb (Get_Name): Properly handle scanning of wide character names\n\tencoded with brackets notation.\n\t(Known_ALI_Lines): Add S lines to this list.\n\t(Scan_ALI): Acquire S (priority specific dispatching) lines.\n\tNew flag Elaborate_All_Desirable in unit table\n\n\t* ali.ads (Priority_Specific_Dispatching): Add this range of\n\tidentifiers to be used for Priority_Specific_Dispatching table entries.\n\t(ALIs_Record): Add First_Specific_Dispatching and\n\tLast_Specific_Dispatching that point to the first and last entries\n\trespectively in the priority specific dispatching table for this unit.\n\t(Specific_Dispatching): Add this table for storing each S (priority\n\tspecific dispatching) line encountered in the input ALI file.\n\tNew flag Elaborate_All_Desirable in unit table\n\n\t* bcheck.adb: (Check_Configuration_Consistency): Add call to\n\tCheck_Consistent_Dispatching_Policy.\n\t(Check_Consistent_Dispatching_Policy): Add this procedure in charge of\n\tverifying that the use of Priority_Specific_Dispatching,\n\tTask_Dispatching_Policy, and Locking_Policy is consistent across the\n\tpartition.\n\n\t* bindgen.adb: (Public_Version_Warning): function removed.\n\t(Set_PSD_Pragma_Table): Add this procedure in charge of getting the\n\trequired information from ALI files in order to initialize the table\n\tcontaining the specific dispatching policy.\n\t(Gen_Adainit_Ada): Generate the variables required for priority specific\n\tdispatching entries (__gl_priority_specific_dispatching and\n\t__gl_num_specific_dispatching).\n\t(Gen_Adainit_C): Generate the variables required for priority specific\n\tdispatching entries (__gl_priority_specific_dispatching and\n\t__gl_num_specific_dispatching).\n\t(Gen_Output_File): Acquire settings for Priority_Specific_Dispatching\n\tpragma entries.\n\t(Gen_Restrictions_String_1, Gen_Restrictions_String_2): Removed.\n\t(Gen_Restrictions_Ada, Gen_Restrictions_C, Set_Boolean): New procedures.\n\t(Tab_To): Removed.\n\t(Gen_Output_File_Ada/_C): Set directly __gl_xxx variables instead of\n\ta call to gnat_set_globals.\n\tGenerate a string containing settings from\n\tPriority_Specific_Dispatching pragma entries.\n\t(Gen_Object_Files_Options): Do not include the runtime libraries when\n\tpragma No_Run_Time is specified.\n\n\t* init.c (__gnat_install_handler, case FreeBSD): Use SA_SIGINFO, for\n\tconsistency with s-intman-posix.adb.\n\t(__gnat_error_handler, case FreeBSD): Account for the fact that the\n\thandler is installed with SA_SIGINFO.\n\t(__gnat_adjust_context_for_raise, FreeBSD case): New function for\n\tFreeBSD ZCX support, copied from Linux version.\n\tAdd MaRTE-specific definitions for the linux target. Redefine sigaction,\n\tsigfillset, and sigemptyset so the routines defined by MaRTE.\n\t(__gl_priority_specific_dispatching): Add this variable that stores the\n\tstring containing priority specific dispatching policies in the\n\tpartition.\n\t(__gl_num_specific_dispatching): Add this variable that indicates the\n\thighest priority for which a priority specific dispatching pragma\n\tapplies.\n\t(__gnat_get_specific_dispatching): Add this routine that returns the\n\tpriority specific dispatching policy, as set by a\n\tPriority_Specific_Dispatching pragma appearing anywhere in the current\n\tpartition. The input argument is the priority number, and the result\n\tis the upper case first character of the policy name.\n\t(__gnat_set_globals): Now a dummy function.\n\t(__gnat_handle_vms_condition): Feed adjust_context_for_raise with\n\tmechargs instead of sigargs, as the latter can be retrieved from the\n\tformer and sigargs is not what we want on ia64.\n\t(__gnat_adjust_context_for_raise, alpha-vms): Fetch sigargs from the\n\tmechargs argument.\n\t(__gnat_adjust_context_for_raise, ia64-vms): New function.\n\t(tasking_error): Remove unused symbol.\n\t(_abort_signal): Move this symbol to the IRIX specific part since this\n\tis the only target that uses this definition.\n\t(Check_Abort_Status): Move this symbol to the IRIX specific part since\n\tthis is the only target that uses this definition.\n\t(Lock_Task): Remove unused symbol.\n\t(Unlock_Task): Remove unused symbol.\n\n\t* lib-writ.adb (Write_ALI): Output new S lines for\n\tPriority_Specific_Dispatching pragmas.\n\tImplement new flag BD for elaborate body desirable\n\n\t* lib-writ.ads: Document S lines for Priority Specific Dispatching.\n\t(Specific_Dispatching): Add this table for storing the entries\n\tcorresponding to Priority_Specific_Dispatching pragmas.\n\tDocument new BD flag for elaborate body desirable\n\n\t* par-prag.adb (Prag): Add Priority_Specific_Dispatching to the list\n\tof known pragmas.\n\nFrom-SVN: r118243", "tree": {"sha": "374a7395bdca27ea31e5e0b8a2dcd982429143b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/374a7395bdca27ea31e5e0b8a2dcd982429143b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cb8344bd34b50012b5c43c7d34d01472f41e026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb8344bd34b50012b5c43c7d34d01472f41e026", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cb8344bd34b50012b5c43c7d34d01472f41e026", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb8344bd34b50012b5c43c7d34d01472f41e026/comments", "author": null, "committer": null, "parents": [{"sha": "9b832db55cf50f7a6739a35ec9f190eccc1d2973", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b832db55cf50f7a6739a35ec9f190eccc1d2973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b832db55cf50f7a6739a35ec9f190eccc1d2973"}], "stats": {"total": 2654, "additions": 1691, "deletions": 963}, "files": [{"sha": "966058e192b898219aa23c040599d28b76a96c24", "filename": "gcc/ada/a-diroro.adb", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fa-diroro.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fa-diroro.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-diroro.adb?ref=3cb8344bd34b50012b5c43c7d34d01472f41e026", "patch": "@@ -0,0 +1,94 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--          A D A . D I S P A T C H I N G . R O U N D _ R O B I N           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Dispatching.Round_Robin is\n+\n+   -----------------\n+   -- Set_Quantum --\n+   -----------------\n+\n+   procedure Set_Quantum\n+     (Pri     : System.Priority;\n+      Quantum : Ada.Real_Time.Time_Span)\n+   is\n+      pragma Unreferenced (Quantum);\n+   begin\n+      if not Is_Round_Robin (Pri) then\n+         raise Dispatching_Policy_Error;\n+      end if;\n+   end Set_Quantum;\n+\n+   -----------------\n+   -- Set_Quantum --\n+   -----------------\n+\n+   procedure Set_Quantum\n+     (Low, High : System.Priority;\n+      Quantum   : Ada.Real_Time.Time_Span)\n+   is\n+      pragma Unreferenced (Quantum);\n+   begin\n+      for Index in Low .. High loop\n+         if not Is_Round_Robin (Index) then\n+            raise Dispatching_Policy_Error;\n+         end if;\n+      end loop;\n+   end Set_Quantum;\n+\n+   --------------------\n+   -- Actual_Quantum --\n+   --------------------\n+\n+   function Actual_Quantum\n+     (Pri : System.Priority) return Ada.Real_Time.Time_Span\n+   is\n+   begin\n+      if Is_Round_Robin (Pri) then\n+         return Default_Quantum;\n+      else\n+         raise Dispatching_Policy_Error;\n+      end if;\n+   end Actual_Quantum;\n+\n+   --------------------\n+   -- Is_Round_Robin --\n+   --------------------\n+\n+   function Is_Round_Robin (Pri : System.Priority) return Boolean is\n+      function Get_Policy (Prio : System.Any_Priority) return Character;\n+      pragma Import (C, Get_Policy, \"__gnat_get_specific_dispatching\");\n+   begin\n+      return Get_Policy (Pri) = 'R';\n+   end Is_Round_Robin;\n+\n+end Ada.Dispatching.Round_Robin;"}, {"sha": "379d0430072cd39f97b084a63078d85db60cf2fc", "filename": "gcc/ada/a-diroro.ads", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fa-diroro.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fa-diroro.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-diroro.ads?ref=3cb8344bd34b50012b5c43c7d34d01472f41e026", "patch": "@@ -0,0 +1,39 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--          A D A . D I S P A T C H I N G . R O U N D _ R O B I N           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System;\n+with Ada.Real_Time;\n+\n+package Ada.Dispatching.Round_Robin is\n+\n+   Default_Quantum : constant Ada.Real_Time.Time_Span :=\n+                       Ada.Real_Time.Milliseconds (10);\n+\n+   procedure Set_Quantum\n+     (Pri     : System.Priority;\n+      Quantum : Ada.Real_Time.Time_Span);\n+\n+   procedure Set_Quantum\n+     (Low, High : System.Priority;\n+      Quantum   : Ada.Real_Time.Time_Span);\n+\n+   function Actual_Quantum\n+     (Pri : System.Priority) return Ada.Real_Time.Time_Span;\n+\n+   function Is_Round_Robin (Pri : System.Priority) return Boolean;\n+\n+end Ada.Dispatching.Round_Robin;"}, {"sha": "5403653cafbd3beae6a68e57755944963c8bac6d", "filename": "gcc/ada/a-dispat.ads", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fa-dispat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fa-dispat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dispat.ads?ref=3cb8344bd34b50012b5c43c7d34d01472f41e026", "patch": "@@ -0,0 +1,22 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       A D A . D I S P A T C H I N G                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.Dispatching is\n+   pragma Pure (Dispatching);\n+\n+   Dispatching_Policy_Error : exception;\n+end Ada.Dispatching;"}, {"sha": "81008c8217494a9828947b00c66358da0a7d543f", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 146, "deletions": 90, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=3cb8344bd34b50012b5c43c7d34d01472f41e026", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,6 +54,7 @@ package body ALI is\n       'E'    => True,   -- external\n       'D'    => True,   -- dependency\n       'X'    => True,   -- xref\n+      'S'    => True,   -- specific dispatching\n       others => False);\n \n    --------------------\n@@ -140,13 +141,6 @@ package body ALI is\n       --  be ignored by Scan_ALI and skipped, and False if the lines\n       --  are to be read and processed.\n \n-      Restrictions_Initial : Rident.Restrictions_Info;\n-      pragma Warnings (Off, Restrictions_Initial);\n-      --  This variable, which should really be a constant (but that's not\n-      --  allowed by the language) is used only for initialization, and the\n-      --  reason we are declaring it is to get the default initialization\n-      --  set for the object.\n-\n       Bad_ALI_Format : exception;\n       --  Exception raised by Fatal_Error if Err is True\n \n@@ -197,7 +191,7 @@ package body ALI is\n       --  white space (when Ignore_Spaces is False) or a typeref bracket or\n       --  an equal sign except for the special case of an operator name\n       --  starting with a double quite which is terminated by another double\n-      --  quote.\n+      --  quote. This function handles wide characters properly.\n \n       function Get_Nat return Nat;\n       --  Skip blanks, then scan out an unsigned integer value in Nat range\n@@ -267,21 +261,6 @@ package body ALI is\n          end if;\n       end Check_At_End_Of_Field;\n \n-      ------------\n-      -- Checkc --\n-      ------------\n-\n-      procedure Checkc (C : Character) is\n-      begin\n-         if Nextc = C then\n-            P := P + 1;\n-         elsif Ignore_Errors then\n-            P := P + 1;\n-         else\n-            Fatal_Error;\n-         end if;\n-      end Checkc;\n-\n       ------------------------\n       -- Check_Unknown_Line --\n       ------------------------\n@@ -308,6 +287,21 @@ package body ALI is\n          end loop;\n       end Check_Unknown_Line;\n \n+      ------------\n+      -- Checkc --\n+      ------------\n+\n+      procedure Checkc (C : Character) is\n+      begin\n+         if Nextc = C then\n+            P := P + 1;\n+         elsif Ignore_Errors then\n+            P := P + 1;\n+         else\n+            Fatal_Error;\n+         end if;\n+      end Checkc;\n+\n       -----------------\n       -- Fatal_Error --\n       -----------------\n@@ -445,12 +439,21 @@ package body ALI is\n                exit when Name_Len > 1 and then Name_Buffer (Name_Len) = '\"';\n \n             else\n-               exit when (At_End_Of_Field and not Ignore_Spaces)\n-                 or else Nextc = '(' or else Nextc = ')'\n+               --  Terminate on parens or angle brackets or equal sign\n+\n+               exit when Nextc = '(' or else Nextc = ')'\n                  or else Nextc = '{' or else Nextc = '}'\n                  or else Nextc = '<' or else Nextc = '>'\n-                 or else Nextc = '[' or else Nextc = ']'\n                  or else Nextc = '=';\n+\n+               --  Terminate if left bracket not part of wide char sequence\n+               --  Note that we only recognize brackets notation so far ???\n+\n+               exit when Nextc = '[' and then T (P + 1) /= '\"';\n+\n+               --  Terminate if right bracket not part of wide char sequence\n+\n+               exit when Nextc = ']' and then T (P - 1) /= '\"';\n             end if;\n          end loop;\n \n@@ -524,29 +527,6 @@ package body ALI is\n          return T;\n       end Get_Stamp;\n \n-      ----------\n-      -- Getc --\n-      ----------\n-\n-      function Getc return Character is\n-      begin\n-         if P = T'Last then\n-            return EOF;\n-         else\n-            P := P + 1;\n-            return T (P - 1);\n-         end if;\n-      end Getc;\n-\n-      -----------\n-      -- Nextc --\n-      -----------\n-\n-      function Nextc return Character is\n-      begin\n-         return T (P);\n-      end Nextc;\n-\n       -----------------\n       -- Get_Typeref --\n       -----------------\n@@ -635,6 +615,29 @@ package body ALI is\n          end if;\n       end Get_Typeref;\n \n+      ----------\n+      -- Getc --\n+      ----------\n+\n+      function Getc return Character is\n+      begin\n+         if P = T'Last then\n+            return EOF;\n+         else\n+            P := P + 1;\n+            return T (P - 1);\n+         end if;\n+      end Getc;\n+\n+      -----------\n+      -- Nextc --\n+      -----------\n+\n+      function Nextc return Character is\n+      begin\n+         return T (P);\n+      end Nextc;\n+\n       --------------\n       -- Skip_Eol --\n       --------------\n@@ -740,10 +743,12 @@ package body ALI is\n         Compile_Errors             => False,\n         First_Interrupt_State      => Interrupt_States.Last + 1,\n         First_Sdep                 => No_Sdep_Id,\n+        First_Specific_Dispatching => Specific_Dispatching.Last + 1,\n         First_Unit                 => No_Unit_Id,\n         Float_Format               => 'I',\n         Last_Interrupt_State       => Interrupt_States.Last,\n         Last_Sdep                  => No_Sdep_Id,\n+        Last_Specific_Dispatching  => Specific_Dispatching.Last,\n         Last_Unit                  => No_Unit_Id,\n         Locking_Policy             => ' ',\n         Main_Priority              => -1,\n@@ -752,7 +757,7 @@ package body ALI is\n         Normalize_Scalars          => False,\n         Ofile_Full_Name            => Full_Object_File_Name,\n         Queuing_Policy             => ' ',\n-        Restrictions               => Restrictions_Initial,\n+        Restrictions               => No_Restrictions,\n         SAL_Interface              => False,\n         Sfile                      => No_Name,\n         Task_Dispatching_Policy    => ' ',\n@@ -1194,7 +1199,7 @@ package body ALI is\n \n                if Ignore_Errors then\n                   Cumulative_Restrictions := Save_R;\n-                  ALIs.Table (Id).Restrictions := Restrictions_Initial;\n+                  ALIs.Table (Id).Restrictions := No_Restrictions;\n                   Skip_Eol;\n \n                --  In normal mode, this is a fatal error\n@@ -1254,6 +1259,47 @@ package body ALI is\n          C := Getc;\n       end loop;\n \n+      --  Acquire 'S' lines if present\n+\n+      Check_Unknown_Line;\n+\n+      while C = 'S' loop\n+         if Ignore ('S') then\n+            Skip_Line;\n+\n+         else\n+            declare\n+               Policy     : Character;\n+               First_Prio : Nat;\n+               Last_Prio  : Nat;\n+               Line_No    : Nat;\n+\n+            begin\n+               Checkc (' ');\n+               Skip_Space;\n+\n+               Policy := Getc;\n+               Skip_Space;\n+               First_Prio := Get_Nat;\n+               Last_Prio := Get_Nat;\n+               Line_No := Get_Nat;\n+\n+               Specific_Dispatching.Append (\n+                 (Dispatching_Policy => Policy,\n+                  First_Priority     => First_Prio,\n+                  Last_Priority      => Last_Prio,\n+                  PSD_Pragma_Line    => Line_No));\n+\n+               ALIs.Table (Id).Last_Specific_Dispatching :=\n+                 Specific_Dispatching.Last;\n+\n+               Skip_Eol;\n+            end;\n+         end if;\n+\n+         C := Getc;\n+      end loop;\n+\n       --  Loop to acquire unit entries\n \n       U_Loop : loop\n@@ -1270,42 +1316,47 @@ package body ALI is\n             ALIs.Table (Id).First_Unit := Units.Last;\n          end if;\n \n-         Units.Table (Units.Last).Uname           := Get_Name;\n-         Units.Table (Units.Last).Predefined      := Is_Predefined_Unit;\n-         Units.Table (Units.Last).Internal        := Is_Internal_Unit;\n-         Units.Table (Units.Last).My_ALI          := Id;\n-         Units.Table (Units.Last).Sfile           := Get_Name (Lower => True);\n-         Units.Table (Units.Last).Pure            := False;\n-         Units.Table (Units.Last).Preelab         := False;\n-         Units.Table (Units.Last).No_Elab         := False;\n-         Units.Table (Units.Last).Shared_Passive  := False;\n-         Units.Table (Units.Last).RCI             := False;\n-         Units.Table (Units.Last).Remote_Types    := False;\n-         Units.Table (Units.Last).Has_RACW        := False;\n-         Units.Table (Units.Last).Init_Scalars    := False;\n-         Units.Table (Units.Last).Is_Generic      := False;\n-         Units.Table (Units.Last).Icasing         := Mixed_Case;\n-         Units.Table (Units.Last).Kcasing         := All_Lower_Case;\n-         Units.Table (Units.Last).Dynamic_Elab    := False;\n-         Units.Table (Units.Last).Elaborate_Body  := False;\n-         Units.Table (Units.Last).Set_Elab_Entity := False;\n-         Units.Table (Units.Last).Version         := \"00000000\";\n-         Units.Table (Units.Last).First_With      := Withs.Last + 1;\n-         Units.Table (Units.Last).First_Arg       := First_Arg;\n-         Units.Table (Units.Last).Elab_Position   := 0;\n-         Units.Table (Units.Last).SAL_Interface   := ALIs.Table (Id).\n-                                                       SAL_Interface;\n-         Units.Table (Units.Last).Body_Needed_For_SAL := False;\n-\n-         if Debug_Flag_U then\n-            Write_Str (\" ----> reading unit \");\n-            Write_Int (Int (Units.Last));\n-            Write_Str (\"  \");\n-            Write_Unit_Name (Units.Table (Units.Last).Uname);\n-            Write_Str (\" from file \");\n-            Write_Name (Units.Table (Units.Last).Sfile);\n-            Write_Eol;\n-         end if;\n+         declare\n+            UL : Unit_Record renames Units.Table (Units.Last);\n+\n+         begin\n+            UL.Uname                    := Get_Name;\n+            UL.Predefined               := Is_Predefined_Unit;\n+            UL.Internal                 := Is_Internal_Unit;\n+            UL.My_ALI                   := Id;\n+            UL.Sfile                    := Get_Name (Lower => True);\n+            UL.Pure                     := False;\n+            UL.Preelab                  := False;\n+            UL.No_Elab                  := False;\n+            UL.Shared_Passive           := False;\n+            UL.RCI                      := False;\n+            UL.Remote_Types             := False;\n+            UL.Has_RACW                 := False;\n+            UL.Init_Scalars             := False;\n+            UL.Is_Generic               := False;\n+            UL.Icasing                  := Mixed_Case;\n+            UL.Kcasing                  := All_Lower_Case;\n+            UL.Dynamic_Elab             := False;\n+            UL.Elaborate_Body           := False;\n+            UL.Set_Elab_Entity          := False;\n+            UL.Version                  := \"00000000\";\n+            UL.First_With               := Withs.Last + 1;\n+            UL.First_Arg                := First_Arg;\n+            UL.Elab_Position            := 0;\n+            UL.SAL_Interface            := ALIs.Table (Id).SAL_Interface;\n+            UL.Body_Needed_For_SAL      := False;\n+            UL.Elaborate_Body_Desirable := False;\n+\n+            if Debug_Flag_U then\n+               Write_Str (\" ----> reading unit \");\n+               Write_Int (Int (Units.Last));\n+               Write_Str (\"  \");\n+               Write_Unit_Name (UL.Uname);\n+               Write_Str (\" from file \");\n+               Write_Name (UL.Sfile);\n+               Write_Eol;\n+            end if;\n+         end;\n \n          --  Check for duplicated unit in different files\n \n@@ -1378,14 +1429,19 @@ package body ALI is\n                   Units.Table (Units.Last).Version (J) := C;\n                end loop;\n \n-            --  BN parameter (Body needed)\n+            --  BD/BN parameters\n \n             elsif C = 'B' then\n                C := Getc;\n \n-               if C = 'N' then\n+               if C = 'D' then\n+                  Check_At_End_Of_Field;\n+                  Units.Table (Units.Last).Elaborate_Body_Desirable := True;\n+\n+               elsif C = 'N' then\n                   Check_At_End_Of_Field;\n                   Units.Table (Units.Last).Body_Needed_For_SAL := True;\n+\n                else\n                   Fatal_Error_Ignore;\n                end if;"}, {"sha": "7d702b7248460eb039b5e53bd45512cc57f8f189", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=3cb8344bd34b50012b5c43c7d34d01472f41e026", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -67,6 +67,9 @@ package ALI is\n    type Interrupt_State_Id is range 6_000_000 .. 6_999_999;\n    --  Id values used for Interrupt_State table entries\n \n+   type Priority_Specific_Dispatching_Id is range 7_000_000 .. 7_999_999;\n+   --  Id values used for Priority_Specific_Dispatching table entries\n+\n    --------------------\n    -- ALI File Table --\n    --------------------\n@@ -196,6 +199,14 @@ package ALI is\n       --  the lower bound of the subtype).\n       --  Not set if 'I' appears in Ignore_Lines\n \n+      First_Specific_Dispatching : Priority_Specific_Dispatching_Id;\n+      Last_Specific_Dispatching  : Priority_Specific_Dispatching_Id'Base;\n+      --  These point to the first and last entries in the priority specific\n+      --  dispatching table for this unit. If there are no entries, then\n+      --  Last_Specific_Dispatching = First_Specific_Dispatching - 1. That\n+      --  is why the 'Base reference is there, it can be one less than the\n+      --  lower bound of the subtype. Not set if 'S' appears in Ignore_Lines.\n+\n    end record;\n \n    No_Main_Priority : constant Int := -1;\n@@ -338,6 +349,14 @@ package ALI is\n       Body_Needed_For_SAL : Boolean;\n       --  Indicates that the source for the body of the unit (subprogram,\n       --  package, or generic unit) must be included in a standalone library.\n+\n+      Elaborate_Body_Desirable : Boolean;\n+      --  Indicates that the front end elaboration circuitry decided that it\n+      --  would be a good idea if this package had Elaborate_Body. The binder\n+      --  will attempt, but does not promise, to place the elaboration call\n+      --  for the body right after the call for the spec, or at least as close\n+      --  together as possible.\n+\n    end record;\n \n    package Units is new Table.Table (\n@@ -376,6 +395,40 @@ package ALI is\n      Table_Increment      => 200,\n      Table_Name           => \"Interrupt_States\");\n \n+   -----------------------------------------\n+   -- Priority Specific Dispatching Table --\n+   -----------------------------------------\n+\n+   --  An entry is made in this table for each S (priority specific\n+   --  dispatching) line encountered in the input ALI file. The\n+   --  First/Last_Specific_Dispatching_Id fields of the ALI file\n+   --  entry show the range of entries defined within a particular\n+   --  ALI file.\n+\n+   type Specific_Dispatching_Record is record\n+      Dispatching_Policy : Character;\n+      --  First character (upper case) of the corresponding policy name\n+\n+      First_Priority     : Nat;\n+      --  Lower bound of the priority range to which the specified dispatching\n+      --  policy applies.\n+\n+      Last_Priority      : Nat;\n+      --  Upper bound of the priority range to which the specified dispatching\n+      --  policy applies.\n+\n+      PSD_Pragma_Line : Nat;\n+      --  Line number of Priority_Specific_Dispatching pragma\n+   end record;\n+\n+   package Specific_Dispatching is new Table.Table (\n+     Table_Component_Type => Specific_Dispatching_Record,\n+     Table_Index_Type     => Priority_Specific_Dispatching_Id'Base,\n+     Table_Low_Bound      => Priority_Specific_Dispatching_Id'First,\n+     Table_Initial        => 100,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Priority_Specific_Dispatching\");\n+\n    --------------\n    -- Switches --\n    --------------\n@@ -418,7 +471,7 @@ package ALI is\n    --  Set to blank by Initialize_ALI. Set to the appropriate queuing policy\n    --  character if an ali file contains a P line setting the queuing policy.\n \n-   Cumulative_Restrictions : Restrictions_Info;\n+   Cumulative_Restrictions : Restrictions_Info := No_Restrictions;\n    --  This variable records the cumulative contributions of R lines in all\n    --  ali files, showing whether a restriction pragma exists anywhere, and\n    --  accumulating the aggregate knowledge of violations."}, {"sha": "a57856e48e510b7cced7c450a04028e37942530b", "filename": "gcc/ada/bcheck.adb", "status": "modified", "additions": 372, "deletions": 182, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fbcheck.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fbcheck.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbcheck.adb?ref=3cb8344bd34b50012b5c43c7d34d01472f41e026", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,6 +46,7 @@ package body Bcheck is\n    --  The following checking subprograms make up the parts of the\n    --  configuration consistency check.\n \n+   procedure Check_Consistent_Dispatching_Policy;\n    procedure Check_Consistent_Dynamic_Elaboration_Checking;\n    procedure Check_Consistent_Floating_Point_Format;\n    procedure Check_Consistent_Interrupt_States;\n@@ -63,9 +64,9 @@ package body Bcheck is\n    --  Used to compare two unit names for No_Dependence checks. U1 is in\n    --  standard unit name format, and U2 is in literal form with periods.\n \n-   ------------------------------------\n-   -- Check_Consistent_Configuration --\n-   ------------------------------------\n+   -------------------------------------\n+   -- Check_Configuration_Consistency --\n+   -------------------------------------\n \n    procedure Check_Configuration_Consistency is\n    begin\n@@ -90,8 +91,352 @@ package body Bcheck is\n \n       Check_Consistent_Restrictions;\n       Check_Consistent_Interrupt_States;\n+      Check_Consistent_Dispatching_Policy;\n    end Check_Configuration_Consistency;\n \n+   -----------------------\n+   -- Check_Consistency --\n+   -----------------------\n+\n+   procedure Check_Consistency is\n+      Src : Source_Id;\n+      --  Source file Id for this Sdep entry\n+\n+      ALI_Path_Id : Name_Id;\n+\n+   begin\n+      --  First, we go through the source table to see if there are any cases\n+      --  in which we should go after source files and compute checksums of\n+      --  the source files. We need to do this for any file for which we have\n+      --  mismatching time stamps and (so far) matching checksums.\n+\n+      for S in Source.First .. Source.Last loop\n+\n+         --  If all time stamps for a file match, then there is nothing to\n+         --  do, since we will not be checking checksums in that case anyway\n+\n+         if Source.Table (S).All_Timestamps_Match then\n+            null;\n+\n+         --  If we did not find the source file, then we can't compute its\n+         --  checksum anyway. Note that when we have a time stamp mismatch,\n+         --  we try to find the source file unconditionally (i.e. if\n+         --  Check_Source_Files is False).\n+\n+         elsif not Source.Table (S).Source_Found then\n+            null;\n+\n+         --  If we already have non-matching or missing checksums, then no\n+         --  need to try going after source file, since we won't trust the\n+         --  checksums in any case.\n+\n+         elsif not Source.Table (S).All_Checksums_Match then\n+            null;\n+\n+         --  Now we have the case where we have time stamp mismatches, and\n+         --  the source file is around, but so far all checksums match. This\n+         --  is the case where we need to compute the checksum from the source\n+         --  file, since otherwise we would ignore the time stamp mismatches,\n+         --  and that is wrong if the checksum of the source does not agree\n+         --  with the checksums in the ALI files.\n+\n+         elsif Check_Source_Files then\n+            if not Checksums_Match\n+              (Source.Table (S).Checksum,\n+               Get_File_Checksum (Source.Table (S).Sfile))\n+            then\n+               Source.Table (S).All_Checksums_Match := False;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  Loop through ALI files\n+\n+      ALIs_Loop : for A in ALIs.First .. ALIs.Last loop\n+\n+         --  Loop through Sdep entries in one ALI file\n+\n+         Sdep_Loop : for D in\n+           ALIs.Table (A).First_Sdep .. ALIs.Table (A).Last_Sdep\n+         loop\n+            if Sdep.Table (D).Dummy_Entry then\n+               goto Continue;\n+            end if;\n+\n+            Src := Source_Id (Get_Name_Table_Info (Sdep.Table (D).Sfile));\n+\n+            --  If the time stamps match, or all checksums match, then we\n+            --  are OK, otherwise we have a definite error.\n+\n+            if Sdep.Table (D).Stamp /= Source.Table (Src).Stamp\n+              and then not Source.Table (Src).All_Checksums_Match\n+            then\n+               Error_Msg_Name_1 := ALIs.Table (A).Sfile;\n+               Error_Msg_Name_2 := Sdep.Table (D).Sfile;\n+\n+               --  Two styles of message, depending on whether or not\n+               --  the updated file is the one that must be recompiled\n+\n+               if Error_Msg_Name_1 = Error_Msg_Name_2 then\n+                  if Tolerate_Consistency_Errors then\n+                     Error_Msg\n+                        (\"?% has been modified and should be recompiled\");\n+                  else\n+                     Error_Msg\n+                       (\"% has been modified and must be recompiled\");\n+                  end if;\n+\n+               else\n+                  ALI_Path_Id :=\n+                    Osint.Find_File ((ALIs.Table (A).Afile), Osint.Library);\n+                  if Osint.Is_Readonly_Library (ALI_Path_Id) then\n+                     if Tolerate_Consistency_Errors then\n+                        Error_Msg (\"?% should be recompiled\");\n+                        Error_Msg_Name_1 := ALI_Path_Id;\n+                        Error_Msg (\"?(% is obsolete and read-only)\");\n+\n+                     else\n+                        Error_Msg (\"% must be compiled\");\n+                        Error_Msg_Name_1 := ALI_Path_Id;\n+                        Error_Msg (\"(% is obsolete and read-only)\");\n+                     end if;\n+\n+                  elsif Tolerate_Consistency_Errors then\n+                     Error_Msg\n+                       (\"?% should be recompiled (% has been modified)\");\n+\n+                  else\n+                     Error_Msg (\"% must be recompiled (% has been modified)\");\n+                  end if;\n+               end if;\n+\n+               if (not Tolerate_Consistency_Errors) and Verbose_Mode then\n+                  declare\n+                     Msg : constant String := \"% time stamp \";\n+                     Buf : String (1 .. Msg'Length + Time_Stamp_Length);\n+\n+                  begin\n+                     Buf (1 .. Msg'Length) := Msg;\n+                     Buf (Msg'Length + 1 .. Buf'Length) :=\n+                       String (Source.Table (Src).Stamp);\n+                     Error_Msg_Name_1 := Sdep.Table (D).Sfile;\n+                     Error_Msg (Buf);\n+                  end;\n+\n+                  declare\n+                     Msg : constant String := \" conflicts with % timestamp \";\n+                     Buf : String (1 .. Msg'Length + Time_Stamp_Length);\n+\n+                  begin\n+                     Buf (1 .. Msg'Length) := Msg;\n+                     Buf (Msg'Length + 1 .. Buf'Length) :=\n+                       String (Sdep.Table (D).Stamp);\n+                     Error_Msg_Name_1 := Sdep.Table (D).Sfile;\n+                     Error_Msg (Buf);\n+                  end;\n+               end if;\n+\n+               --  Exit from the loop through Sdep entries once we find one\n+               --  that does not match.\n+\n+               exit Sdep_Loop;\n+            end if;\n+\n+         <<Continue>>\n+            null;\n+         end loop Sdep_Loop;\n+      end loop ALIs_Loop;\n+   end Check_Consistency;\n+\n+   -----------------------------------------\n+   -- Check_Consistent_Dispatching_Policy --\n+   -----------------------------------------\n+\n+   --  The rule is that all files for which the dispatching policy is\n+   --  significant must meet the following rules:\n+\n+   --    1. All files for which a task dispatching policy is significant must\n+   --    be compiled with the same setting.\n+\n+   --    2. If a partition contains one or more Priority_Specific_Dispatching\n+   --    pragmas it cannot contain a Task_Dispatching_Policy pragma.\n+\n+   --    3. No overlap is allowed in the priority ranges specified in\n+   --    Priority_Specific_Dispatching pragmas within the same partition.\n+\n+   --    4. If a partition contains one or more Priority_Specific_Dispatching\n+   --    pragmas then the Ceiling_Locking policy is the only one allowed for\n+   --    the partition.\n+\n+   procedure Check_Consistent_Dispatching_Policy is\n+      Max_Prio : Nat := 0;\n+      --  Maximum priority value for which a Priority_Specific_Dispatching\n+      --  pragma has been specified.\n+\n+      TDP_Pragma_Afile : ALI_Id := No_ALI_Id;\n+      --  ALI file where a Task_Dispatching_Policy pragma appears\n+\n+   begin\n+      --  Consistency checks in units specifying a Task_Dispatching_Policy\n+\n+      if Task_Dispatching_Policy_Specified /= ' ' then\n+         Find_Policy : for A1 in ALIs.First .. ALIs.Last loop\n+            if ALIs.Table (A1).Task_Dispatching_Policy /= ' ' then\n+\n+               --  Store the place where the first task dispatching pragma\n+               --  appears. We may need this value for issuing consistency\n+               --  errors if Priority_Specific_Dispatching pragmas are used.\n+\n+               TDP_Pragma_Afile := A1;\n+\n+               Check_Policy : declare\n+                  Policy : constant Character :=\n+                             ALIs.Table (A1).Task_Dispatching_Policy;\n+\n+               begin\n+                  for A2 in A1 + 1 .. ALIs.Last loop\n+                     if ALIs.Table (A2).Task_Dispatching_Policy /= ' '\n+                          and then\n+                        ALIs.Table (A2).Task_Dispatching_Policy /= Policy\n+                     then\n+                        Error_Msg_Name_1 := ALIs.Table (A1).Sfile;\n+                        Error_Msg_Name_2 := ALIs.Table (A2).Sfile;\n+\n+                        Consistency_Error_Msg\n+                          (\"% and % compiled with different task\" &\n+                           \" dispatching policies\");\n+                        exit Find_Policy;\n+                     end if;\n+                  end loop;\n+               end Check_Policy;\n+\n+               exit Find_Policy;\n+            end if;\n+         end loop Find_Policy;\n+      end if;\n+\n+      --  If no Priority_Specific_Dispatching entries, nothing else to do\n+\n+      if Specific_Dispatching.Last >= Specific_Dispatching.First then\n+\n+         --  Find out the maximum priority value for which one of the\n+         --  Priority_Specific_Dispatching pragmas applies.\n+\n+         Max_Prio := 0;\n+         for J in Specific_Dispatching.First .. Specific_Dispatching.Last loop\n+            if Specific_Dispatching.Table (J).Last_Priority > Max_Prio then\n+               Max_Prio := Specific_Dispatching.Table (J).Last_Priority;\n+            end if;\n+         end loop;\n+\n+         --  Now establish tables to be used for consistency checking\n+\n+         declare\n+            --  The following record type is used to record locations of the\n+            --  Priority_Specific_Dispatching pragmas applying to the Priority.\n+\n+            type Specific_Dispatching_Entry is record\n+               Dispatching_Policy : Character := ' ';\n+               --  First character (upper case) of corresponding policy name\n+\n+               Afile : ALI_Id := No_ALI_Id;\n+               --  ALI file that generated Priority Specific Dispatching\n+               --  entry for consistency message.\n+\n+               Loc : Nat := 0;\n+               --  Line numbers from Priority_Specific_Dispatching pragma\n+            end record;\n+\n+            PSD_Table  : array (0 .. Max_Prio) of Specific_Dispatching_Entry :=\n+                           (others => Specific_Dispatching_Entry'\n+                              (Dispatching_Policy => ' ',\n+                               Afile              => No_ALI_Id,\n+                               Loc                => 0));\n+            --  Array containing an entry per priority containing the location\n+            --  where there is a Priority_Specific_Dispatching pragma that\n+            --  applies to the priority.\n+\n+         begin\n+            for F in ALIs.First .. ALIs.Last loop\n+               for K in ALIs.Table (F).First_Specific_Dispatching ..\n+                        ALIs.Table (F).Last_Specific_Dispatching\n+               loop\n+                  declare\n+                     DTK : Specific_Dispatching_Record\n+                             renames Specific_Dispatching.Table (K);\n+                  begin\n+                     --  Check whether pragma Task_Dispatching_Policy and\n+                     --  pragma Priority_Specific_Dispatching are used in the\n+                     --  same partition.\n+\n+                     if Task_Dispatching_Policy_Specified /= ' ' then\n+                        Error_Msg_Name_1 := ALIs.Table (F).Sfile;\n+                        Error_Msg_Name_2 :=\n+                          ALIs.Table (TDP_Pragma_Afile).Sfile;\n+\n+                        Error_Msg_Nat_1  := DTK.PSD_Pragma_Line;\n+\n+                        Consistency_Error_Msg\n+                          (\"Priority_Specific_Dispatching at %:#\" &\n+                           \" incompatible with Task_Dispatching_Policy at %\");\n+                     end if;\n+\n+                     --  Ceiling_Locking must also be specified for a partition\n+                     --  with at least one Priority_Specific_Dispatching\n+                     --  pragma.\n+\n+                     if Locking_Policy_Specified /= ' '\n+                       and then Locking_Policy_Specified /= 'C'\n+                     then\n+                        for A in ALIs.First .. ALIs.Last loop\n+                           if ALIs.Table (A).Locking_Policy /= ' '\n+                             and then ALIs.Table (A).Locking_Policy /= 'C'\n+                           then\n+                              Error_Msg_Name_1 := ALIs.Table (F).Sfile;\n+                              Error_Msg_Name_2 := ALIs.Table (A).Sfile;\n+\n+                              Error_Msg_Nat_1  := DTK.PSD_Pragma_Line;\n+\n+                              Consistency_Error_Msg\n+                                (\"Priority_Specific_Dispatching at %:#\" &\n+                                 \" incompatible with Locking_Policy at %\");\n+                           end if;\n+                        end loop;\n+                     end if;\n+\n+                     --  Check overlapping priority ranges\n+\n+                     Find_Overlapping : for Prio in\n+                       DTK.First_Priority .. DTK.Last_Priority\n+                     loop\n+                        if PSD_Table (Prio).Afile = No_ALI_Id then\n+                           PSD_Table (Prio) :=\n+                             (Dispatching_Policy => DTK.Dispatching_Policy,\n+                              Afile => F, Loc => DTK.PSD_Pragma_Line);\n+\n+                        elsif PSD_Table (Prio).Dispatching_Policy /=\n+                              DTK.Dispatching_Policy\n+\n+                        then\n+                           Error_Msg_Name_1 :=\n+                             ALIs.Table (PSD_Table (Prio).Afile).Sfile;\n+                           Error_Msg_Name_2 := ALIs.Table (F).Sfile;\n+                           Error_Msg_Nat_1  := PSD_Table (Prio).Loc;\n+                           Error_Msg_Nat_2  := DTK.PSD_Pragma_Line;\n+\n+                           Consistency_Error_Msg\n+                             (\"overlapping priority ranges at %:# and %:#\");\n+\n+                           exit Find_Overlapping;\n+                        end if;\n+                     end loop Find_Overlapping;\n+                  end;\n+               end loop;\n+            end loop;\n+         end;\n+      end if;\n+   end Check_Consistent_Dispatching_Policy;\n+\n    ---------------------------------------------------\n    -- Check_Consistent_Dynamic_Elaboration_Checking --\n    ---------------------------------------------------\n@@ -579,29 +924,6 @@ package body Bcheck is\n       end loop;\n    end Check_Consistent_Restrictions;\n \n-   ---------------\n-   -- Same_Unit --\n-   ---------------\n-\n-   function Same_Unit (U1 : Name_Id; U2 : Name_Id) return Boolean is\n-   begin\n-      --  Note, the string U1 has a terminating %s or %b, U2 does not\n-\n-      if Length_Of_Name (U1) - 2 = Length_Of_Name (U2) then\n-         Get_Name_String (U1);\n-\n-         declare\n-            U1_Str : constant String := Name_Buffer (1 .. Name_Len - 2);\n-         begin\n-            Get_Name_String (U2);\n-            return U1_Str = Name_Buffer (1 .. Name_Len);\n-         end;\n-\n-      else\n-         return False;\n-      end if;\n-   end Same_Unit;\n-\n    ---------------------------------------------------\n    -- Check_Consistent_Zero_Cost_Exception_Handling --\n    ---------------------------------------------------\n@@ -614,7 +936,6 @@ package body Bcheck is\n       Check_Mechanism : for A1 in ALIs.First + 1 .. ALIs.Last loop\n          if ALIs.Table (A1).Zero_Cost_Exceptions /=\n             ALIs.Table (ALIs.First).Zero_Cost_Exceptions\n-\n          then\n             Error_Msg_Name_1 := ALIs.Table (A1).Sfile;\n             Error_Msg_Name_2 := ALIs.Table (ALIs.First).Sfile;\n@@ -625,160 +946,6 @@ package body Bcheck is\n       end loop Check_Mechanism;\n    end Check_Consistent_Zero_Cost_Exception_Handling;\n \n-   -----------------------\n-   -- Check_Consistency --\n-   -----------------------\n-\n-   procedure Check_Consistency is\n-      Src : Source_Id;\n-      --  Source file Id for this Sdep entry\n-\n-      ALI_Path_Id : Name_Id;\n-\n-   begin\n-      --  First, we go through the source table to see if there are any cases\n-      --  in which we should go after source files and compute checksums of\n-      --  the source files. We need to do this for any file for which we have\n-      --  mismatching time stamps and (so far) matching checksums.\n-\n-      for S in Source.First .. Source.Last loop\n-\n-         --  If all time stamps for a file match, then there is nothing to\n-         --  do, since we will not be checking checksums in that case anyway\n-\n-         if Source.Table (S).All_Timestamps_Match then\n-            null;\n-\n-         --  If we did not find the source file, then we can't compute its\n-         --  checksum anyway. Note that when we have a time stamp mismatch,\n-         --  we try to find the source file unconditionally (i.e. if\n-         --  Check_Source_Files is False).\n-\n-         elsif not Source.Table (S).Source_Found then\n-            null;\n-\n-         --  If we already have non-matching or missing checksums, then no\n-         --  need to try going after source file, since we won't trust the\n-         --  checksums in any case.\n-\n-         elsif not Source.Table (S).All_Checksums_Match then\n-            null;\n-\n-         --  Now we have the case where we have time stamp mismatches, and\n-         --  the source file is around, but so far all checksums match. This\n-         --  is the case where we need to compute the checksum from the source\n-         --  file, since otherwise we would ignore the time stamp mismatches,\n-         --  and that is wrong if the checksum of the source does not agree\n-         --  with the checksums in the ALI files.\n-\n-         elsif Check_Source_Files then\n-            if not Checksums_Match\n-              (Source.Table (S).Checksum,\n-               Get_File_Checksum (Source.Table (S).Sfile))\n-            then\n-               Source.Table (S).All_Checksums_Match := False;\n-            end if;\n-         end if;\n-      end loop;\n-\n-      --  Loop through ALI files\n-\n-      ALIs_Loop : for A in ALIs.First .. ALIs.Last loop\n-\n-         --  Loop through Sdep entries in one ALI file\n-\n-         Sdep_Loop : for D in\n-           ALIs.Table (A).First_Sdep .. ALIs.Table (A).Last_Sdep\n-         loop\n-            if Sdep.Table (D).Dummy_Entry then\n-               goto Continue;\n-            end if;\n-\n-            Src := Source_Id (Get_Name_Table_Info (Sdep.Table (D).Sfile));\n-\n-            --  If the time stamps match, or all checksums match, then we\n-            --  are OK, otherwise we have a definite error.\n-\n-            if Sdep.Table (D).Stamp /= Source.Table (Src).Stamp\n-              and then not Source.Table (Src).All_Checksums_Match\n-            then\n-               Error_Msg_Name_1 := ALIs.Table (A).Sfile;\n-               Error_Msg_Name_2 := Sdep.Table (D).Sfile;\n-\n-               --  Two styles of message, depending on whether or not\n-               --  the updated file is the one that must be recompiled\n-\n-               if Error_Msg_Name_1 = Error_Msg_Name_2 then\n-                  if Tolerate_Consistency_Errors then\n-                     Error_Msg\n-                        (\"?% has been modified and should be recompiled\");\n-                  else\n-                     Error_Msg\n-                       (\"% has been modified and must be recompiled\");\n-                  end if;\n-\n-               else\n-                  ALI_Path_Id :=\n-                    Osint.Find_File ((ALIs.Table (A).Afile), Osint.Library);\n-                  if Osint.Is_Readonly_Library (ALI_Path_Id) then\n-                     if Tolerate_Consistency_Errors then\n-                        Error_Msg (\"?% should be recompiled\");\n-                        Error_Msg_Name_1 := ALI_Path_Id;\n-                        Error_Msg (\"?(% is obsolete and read-only)\");\n-\n-                     else\n-                        Error_Msg (\"% must be compiled\");\n-                        Error_Msg_Name_1 := ALI_Path_Id;\n-                        Error_Msg (\"(% is obsolete and read-only)\");\n-                     end if;\n-\n-                  elsif Tolerate_Consistency_Errors then\n-                     Error_Msg\n-                       (\"?% should be recompiled (% has been modified)\");\n-\n-                  else\n-                     Error_Msg (\"% must be recompiled (% has been modified)\");\n-                  end if;\n-               end if;\n-\n-               if (not Tolerate_Consistency_Errors) and Verbose_Mode then\n-                  declare\n-                     Msg : constant String := \"% time stamp \";\n-                     Buf : String (1 .. Msg'Length + Time_Stamp_Length);\n-\n-                  begin\n-                     Buf (1 .. Msg'Length) := Msg;\n-                     Buf (Msg'Length + 1 .. Buf'Length) :=\n-                       String (Source.Table (Src).Stamp);\n-                     Error_Msg_Name_1 := Sdep.Table (D).Sfile;\n-                     Error_Msg (Buf);\n-                  end;\n-\n-                  declare\n-                     Msg : constant String := \" conflicts with % timestamp \";\n-                     Buf : String (1 .. Msg'Length + Time_Stamp_Length);\n-\n-                  begin\n-                     Buf (1 .. Msg'Length) := Msg;\n-                     Buf (Msg'Length + 1 .. Buf'Length) :=\n-                       String (Sdep.Table (D).Stamp);\n-                     Error_Msg_Name_1 := Sdep.Table (D).Sfile;\n-                     Error_Msg (Buf);\n-                  end;\n-               end if;\n-\n-               --  Exit from the loop through Sdep entries once we find one\n-               --  that does not match.\n-\n-               exit Sdep_Loop;\n-            end if;\n-\n-         <<Continue>>\n-            null;\n-         end loop Sdep_Loop;\n-      end loop ALIs_Loop;\n-   end Check_Consistency;\n-\n    -------------------------------\n    -- Check_Duplicated_Subunits --\n    -------------------------------\n@@ -880,4 +1047,27 @@ package body Bcheck is\n       end if;\n    end Consistency_Error_Msg;\n \n+   ---------------\n+   -- Same_Unit --\n+   ---------------\n+\n+   function Same_Unit (U1 : Name_Id; U2 : Name_Id) return Boolean is\n+   begin\n+      --  Note, the string U1 has a terminating %s or %b, U2 does not\n+\n+      if Length_Of_Name (U1) - 2 = Length_Of_Name (U2) then\n+         Get_Name_String (U1);\n+\n+         declare\n+            U1_Str : constant String := Name_Buffer (1 .. Name_Len - 2);\n+         begin\n+            Get_Name_String (U2);\n+            return U1_Str = Name_Buffer (1 .. Name_Len);\n+         end;\n+\n+      else\n+         return False;\n+      end if;\n+   end Same_Unit;\n+\n end Bcheck;"}, {"sha": "b8718a69756ff6976c5bcc4a6f46e317dc7ac456", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 511, "deletions": 376, "changes": 887, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=3cb8344bd34b50012b5c43c7d34d01472f41e026", "patch": "@@ -24,24 +24,24 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with ALI;         use ALI;\n-with Binde;       use Binde;\n-with Casing;      use Casing;\n-with Fname;       use Fname;\n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n-with Gnatvsn;     use Gnatvsn;\n+with ALI;      use ALI;\n+with Binde;    use Binde;\n+with Casing;   use Casing;\n+with Fname;    use Fname;\n+with Gnatvsn;  use Gnatvsn;\n with Hostparm;\n-with Namet;       use Namet;\n-with Opt;         use Opt;\n-with Osint;       use Osint;\n-with Osint.B;     use Osint.B;\n-with Output;      use Output;\n-with Rident;      use Rident;\n-with Table;       use Table;\n-with Targparm;    use Targparm;\n-with Types;       use Types;\n-\n-with GNAT.Heap_Sort_A;     use GNAT.Heap_Sort_A;\n+with Namet;    use Namet;\n+with Opt;      use Opt;\n+with Osint;    use Osint;\n+with Osint.B;  use Osint.B;\n+with Output;   use Output;\n+with Rident;   use Rident;\n+with Table;    use Table;\n+with Targparm; use Targparm;\n+with Types;    use Types;\n+\n+with GNAT.OS_Lib;      use GNAT.OS_Lib;\n+with GNAT.Heap_Sort_A; use GNAT.Heap_Sort_A;\n \n package body Bindgen is\n \n@@ -79,28 +79,43 @@ package body Bindgen is\n      Table_Increment      => 200,\n      Table_Name           => \"IS_Pragma_Settings\");\n \n+   --  This table assembles the Priority_Specific_Dispatching pragma\n+   --  information from all the units in the partition. Note that Bcheck has\n+   --  already checked that the information is consistent across partitions.\n+   --  The entries in this table are the upper case first character of the\n+   --  policy name, e.g. 'F' for FIFO_Within_Priorities.\n+\n+   package PSD_Pragma_Settings is new Table.Table (\n+     Table_Component_Type => Character,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => 100,\n+     Table_Increment      => 200,\n+     Table_Name           => \"PSD_Pragma_Settings\");\n+\n    ----------------------\n    -- Run-Time Globals --\n    ----------------------\n \n-   --  This section documents the global variables that are passed to the\n-   --  run time from the generated binder file. The call that is made is\n-   --  to the routine Set_Globals, which has the following spec:\n-\n-   --   procedure Set_Globals\n-   --     (Main_Priority            : Integer;\n-   --      Time_Slice_Value         : Integer;\n-   --      WC_Encoding              : Character;\n-   --      Locking_Policy           : Character;\n-   --      Queuing_Policy           : Character;\n-   --      Task_Dispatching_Policy  : Character;\n-   --      Restrictions             : System.Address;\n-   --      Interrupt_States         : System.Address;\n-   --      Num_Interrupt_States     : Integer;\n-   --      Unreserve_All_Interrupts : Integer;\n-   --      Exception_Tracebacks     : Integer;\n-   --      Zero_Cost_Exceptions     : Integer;\n-   --      Detect_Blocking          : Integer);\n+   --  This section documents the global variables that set from the\n+   --  generated binder file.\n+\n+   --     Main_Priority                 : Integer;\n+   --     Time_Slice_Value              : Integer;\n+   --     WC_Encoding                   : Character;\n+   --     Locking_Policy                : Character;\n+   --     Queuing_Policy                : Character;\n+   --     Task_Dispatching_Policy       : Character;\n+   --     Priority_Specific_Dispatching : System.Address;\n+   --     Num_Specific_Dispatching      : Integer;\n+   --     Restrictions                  : System.Address;\n+   --     Interrupt_States              : System.Address;\n+   --     Num_Interrupt_States          : Integer;\n+   --     Unreserve_All_Interrupts      : Integer;\n+   --     Exception_Tracebacks          : Integer;\n+   --     Zero_Cost_Exceptions          : Integer;\n+   --     Detect_Blocking               : Integer;\n+   --     Default_Stack_Size            : Integer;\n \n    --  Main_Priority is the priority value set by pragma Priority in the\n    --  main program. If no such pragma is present, the value is -1.\n@@ -131,6 +146,20 @@ package body Bindgen is\n    --  was specified, the value is the upper case first character of\n    --  the policy name, e.g. 'F' for FIFO_Within_Priorities.\n \n+   --  Priority_Specific_Dispatching is the address of a string used to\n+   --  store the task dispatching policy specified for the different priorities\n+   --  in the partition. The length of this string is determined by the last\n+   --  priority for which such a pragma applies (the string will be a null\n+   --  string if no specific dispatching policies were used). If pragma were\n+   --  present, the entries apply to the priorities in sequence from the first\n+   --  priority. The value stored is the upper case first character of the\n+   --  policy name, or 'F' (for FIFO_Within_Priorities) as the default value\n+   --  for those priority ranges not specified.\n+\n+   --  Num_Specific_Dispatching is the length of the\n+   --  Priority_Specific_Dispatching string. It will be set to zero if no\n+   --  Priority_Specific_Dispatching pragmas are present.\n+\n    --  Restrictions is the address of a null-terminated string specifying the\n    --  restrictions information for the partition. The format is identical to\n    --  that of the parameter string found on R lines in ali files (see Lib.Writ\n@@ -167,6 +196,9 @@ package body Bindgen is\n    --  present, while a value of 1 signals its presence in the\n    --  partition.\n \n+   --  Default_Stack_Size is the default stack size used when creating an\n+   --  Ada task with no explicit Storize_Size clause.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -218,15 +250,11 @@ package body Bindgen is\n    procedure Gen_Output_File_C (Filename : String);\n    --  Generate output file (C code case)\n \n-   procedure Gen_Restrictions_String_1;\n-   --  Generate first restrictions string, which consists of the parameters\n-   --  the first R line, as described in lib-writ.ads, with the restrictions\n-   --  being those for the entire partition (from Cumulative_Restrictions).\n+   procedure Gen_Restrictions_Ada;\n+   --  Generate initialization of restrictions variable (Ada code case)\n \n-   procedure Gen_Restrictions_String_2;\n-   --  Generate first restrictions string, which consists of the parameters\n-   --  the second R line, as described in lib-writ.ads, with the restrictions\n-   --  being those for the entire partition (from Cumulative_Restrictions).\n+   procedure Gen_Restrictions_C;\n+   --  Generate initialization of restrictions variable (C code case)\n \n    procedure Gen_Versions_Ada;\n    --  Output series of definitions for unit versions (Ada code case)\n@@ -256,10 +284,6 @@ package body Bindgen is\n    procedure Move_Linker_Option (From : Natural; To : Natural);\n    --  Move routine for sorting linker options\n \n-   procedure Public_Version_Warning;\n-   --  Emit a warning concerning the use of the Public version under\n-   --  certain circumstances. See details in body.\n-\n    procedure Resolve_Binder_Options;\n    --  Set the value of With_GNARL and With_DECGNAT. The latter only on VMS\n    --  since it tests for a package named \"dec\" which might cause a conflict\n@@ -274,6 +298,10 @@ package body Bindgen is\n    --  starting at the Last + 1 position, and updating Last past the value.\n    --  A minus sign is output for a negative value.\n \n+   procedure Set_Boolean (B : Boolean);\n+   --  Set given boolean value in Statement_Buffer at the Last + 1 position\n+   --  and update Last past the value.\n+\n    procedure Set_IS_Pragma_Table;\n    --  Initializes contents of IS_Pragma_Settings table from ALI table\n \n@@ -285,6 +313,9 @@ package body Bindgen is\n    procedure Set_Name_Buffer;\n    --  Set the value stored in positions 1 .. Name_Len of the Name_Buffer\n \n+   procedure Set_PSD_Pragma_Table;\n+   --  Initializes contents of PSD_Pragma_Settings table from ALI table\n+\n    procedure Set_String (S : String);\n    --  Sets characters of given string in Statement_Buffer, starting at the\n    --  Last + 1 position, and updating last past the string value.\n@@ -299,10 +330,6 @@ package body Bindgen is\n    --  up all output unit numbers nicely as required by the value, and\n    --  by the total number of units.\n \n-   procedure Tab_To (N : Natural);\n-   --  If Last is greater than or equal to N, no effect, otherwise store\n-   --  blanks in Statement_Buffer bumping Last, until Last = N.\n-\n    procedure Write_Info_Ada_C (Ada : String; C : String; Common : String);\n    --  For C code case, write C & Common, for Ada case write Ada & Common\n    --  to current binder output file using Write_Binder_Info.\n@@ -432,7 +459,7 @@ package body Bindgen is\n \n       --  If the standard library is suppressed, then the only global variable\n       --  that might be needed (by the Ravenscar profile) is the priority of\n-      --  the environment. Also no exception tables are needed.\n+      --  the environment.\n \n       if Suppress_Standard_Library_On_Target then\n          if Main_Priority /= No_Main_Priority then\n@@ -454,78 +481,59 @@ package body Bindgen is\n             WBI (\"      null;\");\n          end if;\n \n-      --  Normal case (standard library not suppressed). Global values are\n-      --  assigned using the runtime routine Set_Globals (we have to use\n-      --  the routine call, rather than define the globals in the binder\n-      --  file to deal with cross-library calls in some systems.\n+      --  Normal case (standard library not suppressed). Set all global values\n+      --  used by the run time.\n \n       else\n-         --  Generate restrictions string\n-\n-         Set_String (\"      Restrictions : constant String :=\");\n-         Write_Statement_Buffer;\n-\n-         Set_String (\"        \"\"\");\n-         Gen_Restrictions_String_1;\n-         Set_String (\"\"\" &\");\n-         Write_Statement_Buffer;\n-\n-         Set_String (\"        \"\"\");\n-         Gen_Restrictions_String_2;\n-         Set_String (\"\"\" & ASCII.Nul;\");\n-         Write_Statement_Buffer;\n-         WBI (\"\");\n-\n-         --  Generate Interrupt_State pragma string\n+         WBI (\"      Main_Priority : Integer;\");\n+         WBI (\"      pragma Import (C, Main_Priority, \" &\n+              \"\"\"__gl_main_priority\"\");\");\n+         WBI (\"      Time_Slice_Value : Integer;\");\n+         WBI (\"      pragma Import (C, Time_Slice_Value, \" &\n+              \"\"\"__gl_time_slice_val\"\");\");\n+         WBI (\"      WC_Encoding : Character;\");\n+         WBI (\"      pragma Import (C, WC_Encoding, \"\"__gl_wc_encoding\"\");\");\n+         WBI (\"      Locking_Policy : Character;\");\n+         WBI (\"      pragma Import (C, Locking_Policy, \" &\n+              \"\"\"__gl_locking_policy\"\");\");\n+         WBI (\"      Queuing_Policy : Character;\");\n+         WBI (\"      pragma Import (C, Queuing_Policy, \" &\n+              \"\"\"__gl_queuing_policy\"\");\");\n+         WBI (\"      Task_Dispatching_Policy : Character;\");\n+         WBI (\"      pragma Import (C, Task_Dispatching_Policy, \" &\n+              \"\"\"__gl_task_dispatching_policy\"\");\");\n+         WBI (\"      Priority_Specific_Dispatching : System.Address;\");\n+         WBI (\"      pragma Import (C, Priority_Specific_Dispatching, \" &\n+              \"\"\"__gl_priority_specific_dispatching\"\");\");\n+         WBI (\"      Num_Specific_Dispatching : Integer;\");\n+         WBI (\"      pragma Import (C, Num_Specific_Dispatching, \" &\n+              \"\"\"__gl_num_specific_dispatching\"\");\");\n+\n+         WBI (\"      Interrupt_States : System.Address;\");\n+         WBI (\"      pragma Import (C, Interrupt_States, \" &\n+              \"\"\"__gl_interrupt_states\"\");\");\n+         WBI (\"      Num_Interrupt_States : Integer;\");\n+         WBI (\"      pragma Import (C, Num_Interrupt_States, \" &\n+              \"\"\"__gl_num_interrupt_states\"\");\");\n+         WBI (\"      Unreserve_All_Interrupts : Integer;\");\n+         WBI (\"      pragma Import (C, Unreserve_All_Interrupts, \" &\n+              \"\"\"__gl_unreserve_all_interrupts\"\");\");\n \n-         Set_String (\"      Interrupt_States : constant String :=\");\n-         Write_Statement_Buffer;\n-\n-         declare\n-            Col : Natural;\n-\n-         begin\n-            Set_String (\"        \"\"\");\n-            Col := 9;\n-\n-            for J in 0 .. IS_Pragma_Settings.Last loop\n-               if Col > 72 then\n-                  Set_String (\"\"\" &\");\n-                  Write_Statement_Buffer;\n-                  Set_String (\"        \"\"\");\n-                  Col := 9;\n-\n-               else\n-                  Col := Col + 1;\n-               end if;\n-\n-               Set_Char (IS_Pragma_Settings.Table (J));\n-            end loop;\n-         end;\n-\n-         Set_String (\"\"\";\");\n-         Write_Statement_Buffer;\n-         WBI (\"\");\n+         if Exception_Tracebacks then\n+            WBI (\"      Exception_Tracebacks : Integer;\");\n+            WBI (\"      pragma Import (C, Exception_Tracebacks, \" &\n+                 \"\"\"__gl_exception_tracebacks\"\");\");\n+         end if;\n \n-         --  Generate spec for Set_Globals procedure\n-\n-         WBI (\"      procedure Set_Globals\");\n-         WBI (\"        (Main_Priority            : Integer;\");\n-         WBI (\"         Time_Slice_Value         : Integer;\");\n-         WBI (\"         WC_Encoding              : Character;\");\n-         WBI (\"         Locking_Policy           : Character;\");\n-         WBI (\"         Queuing_Policy           : Character;\");\n-         WBI (\"         Task_Dispatching_Policy  : Character;\");\n-\n-         WBI (\"         Restrictions             : System.Address;\");\n-         WBI (\"         Interrupt_States         : System.Address;\");\n-         WBI (\"         Num_Interrupt_States     : Integer;\");\n-         WBI (\"         Unreserve_All_Interrupts : Integer;\");\n-         WBI (\"         Exception_Tracebacks     : Integer;\");\n-         WBI (\"         Zero_Cost_Exceptions     : Integer;\");\n-         WBI (\"         Detect_Blocking          : Integer;\");\n-         WBI (\"         Default_Stack_Size       : Integer);\");\n-         WBI (\"      pragma Import (C, Set_Globals, \"\"__gnat_set_globals\"\");\");\n+         WBI (\"      Zero_Cost_Exceptions : Integer;\");\n+         WBI (\"      pragma Import (C, Zero_Cost_Exceptions, \" &\n+              \"\"\"__gl_zero_cost_exceptions\"\");\");\n+         WBI (\"      Detect_Blocking : Integer;\");\n+         WBI (\"      pragma Import (C, Detect_Blocking, \" &\n+              \"\"\"__gl_detect_blocking\"\");\");\n+         WBI (\"      Default_Stack_Size : Integer;\");\n+         WBI (\"      pragma Import (C, Default_Stack_Size, \" &\n+              \"\"\"__gl_default_stack_size\"\");\");\n \n          --  Import entry point for elaboration time signal handler\n          --  installation, and indication of if it's been called previously.\n@@ -540,16 +548,12 @@ package body Bindgen is\n               \"\"\"__gnat_handler_installed\"\");\");\n          WBI (\"   begin\");\n \n-         --  Generate the call to Set_Globals\n-\n-         WBI (\"      Set_Globals\");\n-\n-         Set_String (\"        (Main_Priority            => \");\n+         Set_String (\"      Main_Priority := \");\n          Set_Int    (Main_Priority);\n-         Set_Char   (',');\n+         Set_Char   (';');\n          Write_Statement_Buffer;\n \n-         Set_String (\"         Time_Slice_Value         => \");\n+         Set_String (\"      Time_Slice_Value := \");\n \n          if Task_Dispatching_Policy_Specified = 'F'\n            and then ALIs.Table (ALIs.First).Time_Slice_Value = -1\n@@ -559,87 +563,86 @@ package body Bindgen is\n             Set_Int (ALIs.Table (ALIs.First).Time_Slice_Value);\n          end if;\n \n-         Set_Char   (',');\n+         Set_Char   (';');\n          Write_Statement_Buffer;\n \n-         Set_String (\"         WC_Encoding              => '\");\n+         Set_String (\"      WC_Encoding := '\");\n          Set_Char   (ALIs.Table (ALIs.First).WC_Encoding);\n-         Set_String (\"',\");\n+         Set_String (\"';\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"         Locking_Policy           => '\");\n+         Set_String (\"      Locking_Policy := '\");\n          Set_Char   (Locking_Policy_Specified);\n-         Set_String (\"',\");\n+         Set_String (\"';\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"         Queuing_Policy           => '\");\n+         Set_String (\"      Queuing_Policy := '\");\n          Set_Char   (Queuing_Policy_Specified);\n-         Set_String (\"',\");\n+         Set_String (\"';\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"         Task_Dispatching_Policy  => '\");\n+         Set_String (\"      Task_Dispatching_Policy := '\");\n          Set_Char   (Task_Dispatching_Policy_Specified);\n-         Set_String (\"',\");\n+         Set_String (\"';\");\n          Write_Statement_Buffer;\n \n-         WBI (\"         Restrictions             => Restrictions'Address,\");\n+         Gen_Restrictions_Ada;\n+\n+         WBI (\"      Priority_Specific_Dispatching :=\");\n+         WBI (\"        Local_Priority_Specific_Dispatching'Address;\");\n \n-         WBI (\"         Interrupt_States         => \" &\n-                                                 \"Interrupt_States'Address,\");\n+         Set_String (\"      Num_Specific_Dispatching := \");\n+         Set_Int (PSD_Pragma_Settings.Last + 1);\n+         Set_Char (';');\n+         Write_Statement_Buffer;\n \n-         Set_String (\"         Num_Interrupt_States     => \");\n+         WBI (\"      Interrupt_States := Local_Interrupt_States'Address;\");\n+\n+         Set_String (\"      Num_Interrupt_States := \");\n          Set_Int (IS_Pragma_Settings.Last + 1);\n-         Set_Char (',');\n+         Set_Char (';');\n          Write_Statement_Buffer;\n \n-         Set_String (\"         Unreserve_All_Interrupts => \");\n+         Set_String (\"      Unreserve_All_Interrupts := \");\n \n          if Unreserve_All_Interrupts_Specified then\n             Set_String (\"1\");\n          else\n             Set_String (\"0\");\n          end if;\n \n-         Set_Char (',');\n+         Set_Char (';');\n          Write_Statement_Buffer;\n \n-         Set_String (\"         Exception_Tracebacks     => \");\n-\n          if Exception_Tracebacks then\n-            Set_String (\"1\");\n-         else\n-            Set_String (\"0\");\n+            WBI (\"      Exception_Tracebacks := 1;\");\n          end if;\n \n-         Set_String (\",\");\n-         Write_Statement_Buffer;\n-\n-         Set_String (\"         Zero_Cost_Exceptions     => \");\n+         Set_String (\"      Zero_Cost_Exceptions := \");\n \n          if Zero_Cost_Exceptions_Specified then\n             Set_String (\"1\");\n          else\n             Set_String (\"0\");\n          end if;\n \n-         Set_String (\",\");\n+         Set_String (\";\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"         Detect_Blocking          => \");\n+         Set_String (\"      Detect_Blocking := \");\n \n          if Detect_Blocking then\n             Set_Int (1);\n          else\n             Set_Int (0);\n          end if;\n \n-         Set_String (\",\");\n+         Set_String (\";\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"         Default_Stack_Size       => \");\n+         Set_String (\"      Default_Stack_Size := \");\n          Set_Int (Default_Stack_Size);\n-\n-         Set_String (\");\");\n+         Set_String (\";\");\n          Write_Statement_Buffer;\n \n          --  Generate call to Install_Handler\n@@ -734,7 +737,8 @@ package body Bindgen is\n          --  for the Ravenscar profile.\n \n          if Main_Priority /= No_Main_Priority then\n-            Set_String (\"   extern int __gl_main_priority = \");\n+            WBI (\"   extern int __gl_main_priority;\");\n+            Set_String (\"   __gl_main_priority = \");\n             Set_Int    (Main_Priority);\n             Set_Char   (';');\n             Write_Statement_Buffer;\n@@ -743,20 +747,24 @@ package body Bindgen is\n       --  Normal case (standard library not suppressed)\n \n       else\n-         --  Generate definition for restrictions string\n+         --  Generate definition for interrupt states string\n+\n+         Set_String (\"   static const char *local_interrupt_states = \"\"\");\n+\n+         for J in 0 .. IS_Pragma_Settings.Last loop\n+            Set_Char (IS_Pragma_Settings.Table (J));\n+         end loop;\n \n-         Set_String (\"   const char *restrictions = \"\"\");\n-         Gen_Restrictions_String_1;\n-         Gen_Restrictions_String_2;\n          Set_String (\"\"\";\");\n          Write_Statement_Buffer;\n \n-         --  Generate definition for interrupt states string\n+         --  Generate definition for priority specific dispatching string\n \n-         Set_String (\"   const char *interrupt_states = \"\"\");\n+         Set_String\n+           (\"   static const char *local_priority_specific_dispatching = \"\"\");\n \n-         for J in 0 .. IS_Pragma_Settings.Last loop\n-            Set_Char (IS_Pragma_Settings.Table (J));\n+         for J in 0 .. PSD_Pragma_Settings.Last loop\n+            Set_Char (PSD_Pragma_Settings.Table (J));\n          end loop;\n \n          Set_String (\"\"\";\");\n@@ -773,24 +781,17 @@ package body Bindgen is\n \n          --  Code for normal case (standard library not suppressed)\n \n-         --  Generate call to set the runtime global variables defined in\n-         --  init.c. We define the varables in init.c, rather than in\n-         --  the binder generated file itself to avoid undefined externals\n-         --  when the runtime is linked as a shareable image library.\n-\n          --  We call the routine from inside adainit() because this works for\n          --  both programs with and without binder generated \"main\" functions.\n \n-         WBI (\"   __gnat_set_globals (\");\n-\n-         Set_String (\"      \");\n+         WBI (\"   extern int __gl_main_priority;\");\n+         Set_String (\"   __gl_main_priority = \");\n          Set_Int (Main_Priority);\n-         Set_Char (',');\n-         Tab_To (24);\n-         Set_String (\"/* Main_Priority              */\");\n+         Set_Char (';');\n          Write_Statement_Buffer;\n \n-         Set_String (\"      \");\n+         WBI (\"   extern int __gl_time_slice_val;\");\n+         Set_String (\"   __gl_time_slice_val = \");\n \n          if Task_Dispatching_Policy = 'F'\n            and then ALIs.Table (ALIs.First).Time_Slice_Value = -1\n@@ -800,99 +801,89 @@ package body Bindgen is\n             Set_Int (ALIs.Table (ALIs.First).Time_Slice_Value);\n          end if;\n \n-         Set_Char   (',');\n-         Tab_To (24);\n-         Set_String (\"/* Time_Slice_Value           */\");\n+         Set_Char   (';');\n          Write_Statement_Buffer;\n \n-         Set_String (\"      '\");\n+         WBI (\"   extern char __gl_wc_encoding;\");\n+         Set_String (\"   __gl_wc_encoding = '\");\n          Set_Char   (ALIs.Table (ALIs.First).WC_Encoding);\n-         Set_String (\"',\");\n-         Tab_To (24);\n-         Set_String (\"/* WC_Encoding                */\");\n+         Set_String (\"';\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"      '\");\n+         WBI (\"   extern char __gl_locking_policy;\");\n+         Set_String (\"   __gl_locking_policy = '\");\n          Set_Char (Locking_Policy_Specified);\n-         Set_String (\"',\");\n-         Tab_To (24);\n-         Set_String (\"/* Locking_Policy             */\");\n+         Set_String (\"';\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"      '\");\n+         WBI (\"   extern char __gl_queuing_policy;\");\n+         Set_String (\"   __gl_queuing_policy = '\");\n          Set_Char (Queuing_Policy_Specified);\n-         Set_String (\"',\");\n-         Tab_To (24);\n-         Set_String (\"/* Queuing_Policy             */\");\n+         Set_String (\"';\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"      '\");\n+         WBI (\"   extern char __gl_task_dispatching_policy;\");\n+         Set_String (\"   __gl_task_dispatching_policy = '\");\n          Set_Char (Task_Dispatching_Policy_Specified);\n-         Set_String (\"',\");\n-         Tab_To (24);\n-         Set_String (\"/* Tasking_Dispatching_Policy */\");\n+         Set_String (\"';\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"      \");\n-         Set_String (\"restrictions\");\n-         Set_String (\",\");\n-         Tab_To (24);\n-         Set_String (\"/* Restrictions               */\");\n-         Write_Statement_Buffer;\n+         --  Generate definition for restrictions string\n \n-         Set_String (\"      \");\n-         Set_String (\"interrupt_states\");\n-         Set_String (\",\");\n-         Tab_To (24);\n-         Set_String (\"/* Interrupt_States           */\");\n-         Write_Statement_Buffer;\n+         Gen_Restrictions_C;\n+\n+         WBI (\"   extern const void *__gl_interrupt_states;\");\n+         WBI (\"   __gl_interrupt_states = local_interrupt_states;\");\n \n-         Set_String (\"      \");\n+         WBI (\"   extern int __gl_num_interrupt_states;\");\n+         Set_String (\"   __gl_num_interrupt_states = \");\n          Set_Int (IS_Pragma_Settings.Last + 1);\n-         Set_String (\",\");\n-         Tab_To (24);\n-         Set_String (\"/* Num_Interrupt_States       */\");\n+         Set_String (\";\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"      \");\n-         Set_Int    (Boolean'Pos (Unreserve_All_Interrupts_Specified));\n-         Set_String (\",\");\n-         Tab_To (24);\n-         Set_String (\"/* Unreserve_All_Interrupts   */\");\n+         WBI (\"   extern const void *__gl_priority_specific_dispatching;\");\n+         WBI (\"   __gl_priority_specific_dispatching =\" &\n+              \" local_priority_specific_dispatching;\");\n+\n+         WBI (\"   extern int __gl_num_specific_dispatching;\");\n+         Set_String (\"   __gl_num_specific_dispatching = \");\n+         Set_Int (PSD_Pragma_Settings.Last + 1);\n+         Set_String (\";\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"      \");\n-         Set_Int    (Boolean'Pos (Exception_Tracebacks));\n-         Set_String (\",\");\n-         Tab_To (24);\n-         Set_String (\"/* Exception_Tracebacks       */\");\n+         WBI (\"   extern int __gl_unreserve_all_interrupts;\");\n+         Set_String (\"   __gl_unreserve_all_interrupts = \");\n+         Set_Int    (Boolean'Pos (Unreserve_All_Interrupts_Specified));\n+         Set_String (\";\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"      \");\n+         if Exception_Tracebacks then\n+            WBI (\"   extern int __gl_exception_tracebacks;\");\n+            WBI (\"   __gl_exception_tracebacks = 1;\");\n+         end if;\n+\n+         WBI (\"   extern int __gl_zero_cost_exceptions;\");\n+         Set_String (\"   __gl_zero_cost_exceptions = \");\n          Set_Int    (Boolean'Pos (Zero_Cost_Exceptions_Specified));\n-         Set_String (\",\");\n-         Tab_To (24);\n-         Set_String (\"/* Zero_Cost_Exceptions       */\");\n+         Set_String (\";\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"      \");\n+         WBI (\"   extern int __gl_detect_blocking;\");\n+         Set_String (\"   __gl_detect_blocking = \");\n \n          if Detect_Blocking then\n             Set_Int (1);\n          else\n             Set_Int (0);\n          end if;\n \n-         Set_String (\",\");\n-         Tab_To (24);\n-         Set_String (\"/* Detect_Blocking            */\");\n+         Set_String (\";\");\n          Write_Statement_Buffer;\n \n-         Set_String (\"      \");\n+         WBI (\"   extern int __gl_default_stack_size;\");\n+         Set_String (\"   __gl_default_stack_size = \");\n          Set_Int    (Default_Stack_Size);\n-         Set_String (\");\");\n-         Tab_To (24);\n-         Set_String (\"/* Default_Stack_Size     */\");\n+         Set_String (\";\");\n          Write_Statement_Buffer;\n \n          WBI (\"\");\n@@ -1836,7 +1827,12 @@ package body Bindgen is\n       --  files. The reason for this decision is that libraries referenced\n       --  by internal routines may reference these standard library entries.\n \n-      if not Opt.No_Stdlib then\n+      --  Note that we do not insert anything when pragma No_Run_Time has been\n+      --  specified or when the standard libraries are not to be used,\n+      --  otherwise on some platforms, such as VMS, we may get duplicate\n+      --  symbols when linking.\n+\n+      if not (Opt.No_Run_Time_Mode or else Opt.No_Stdlib) then\n          Name_Len := 0;\n \n          if Opt.Shared_Libgnat then\n@@ -1903,14 +1899,15 @@ package body Bindgen is\n    ---------------------\n \n    procedure Gen_Output_File (Filename : String) is\n-      Is_Public_Version : constant Boolean := Get_Gnat_Build_Type = Public;\n-      Is_GAP_Version    : constant Boolean := Get_Gnat_Build_Type = GAP;\n-\n    begin\n       --  Acquire settings for Interrupt_State pragmas\n \n       Set_IS_Pragma_Table;\n \n+      --  Acquire settings for Priority_Specific_Dispatching pragma\n+\n+      Set_PSD_Pragma_Table;\n+\n       --  Override Ada_Bind_File and Bind_Main_Program for Java since\n       --  JGNAT only supports Ada code, and the main program is already\n       --  generated by the compiler.\n@@ -1936,12 +1933,6 @@ package body Bindgen is\n          end if;\n       end loop;\n \n-      --  Get the time stamp of the former bind for public version warning\n-\n-      if Is_Public_Version or Is_GAP_Version then\n-         Record_Time_From_Last_Bind;\n-      end if;\n-\n       --  Generate output file in appropriate language\n \n       if Ada_Bind_File then\n@@ -1950,12 +1941,6 @@ package body Bindgen is\n          Gen_Output_File_C (Filename);\n       end if;\n \n-      --  Periodically issue a warning when the public version is used on\n-      --  big projects\n-\n-      if Is_Public_Version then\n-         Public_Version_Warning;\n-      end if;\n    end Gen_Output_File;\n \n    -------------------------\n@@ -2006,7 +1991,6 @@ package body Bindgen is\n       Resolve_Binder_Options;\n \n       if not Suppress_Standard_Library_On_Target then\n-\n          --  Usually, adafinal is called using a pragma Import C. Since\n          --  Import C doesn't have the same semantics for JGNAT, we use\n          --  standard Ada.\n@@ -2192,6 +2176,14 @@ package body Bindgen is\n            \", Body_File_Name => \"\"\" &\n            Name_Buffer (1 .. Name_Len + 3));\n \n+      --  Generate with of System.Restrictions to initialize\n+      --  Run_Time_Restrictions.\n+\n+      if not Suppress_Standard_Library_On_Target then\n+         WBI (\"\");\n+         WBI (\"with System.Restrictions;\");\n+      end if;\n+\n       WBI (\"\");\n       WBI (\"package body \" & Ada_Main & \" is\");\n       WBI (\"   pragma Warnings (Off);\");\n@@ -2213,6 +2205,33 @@ package body Bindgen is\n          end if;\n       end if;\n \n+      if not Suppress_Standard_Library_On_Target then\n+\n+         --  Generate Priority_Specific_Dispatching pragma string\n+\n+         Set_String\n+           (\"   Local_Priority_Specific_Dispatching : constant String := \"\"\");\n+\n+         for J in 0 .. PSD_Pragma_Settings.Last loop\n+            Set_Char (PSD_Pragma_Settings.Table (J));\n+         end loop;\n+\n+         Set_String (\"\"\";\");\n+         Write_Statement_Buffer;\n+\n+         --  Generate Interrupt_State pragma string\n+\n+         Set_String (\"   Local_Interrupt_States : constant String := \"\"\");\n+\n+         for J in 0 .. IS_Pragma_Settings.Last loop\n+            Set_Char (IS_Pragma_Settings.Table (J));\n+         end loop;\n+\n+         Set_String (\"\"\";\");\n+         Write_Statement_Buffer;\n+         WBI (\"\");\n+      end if;\n+\n       Gen_Adainit_Ada;\n \n       Gen_Adafinal_Ada;\n@@ -2257,11 +2276,6 @@ package body Bindgen is\n \n       Resolve_Binder_Options;\n \n-      WBI (\"extern void __gnat_set_globals\");\n-      WBI (\"  (int, int, char, char, char, char,\");\n-      WBI (\"   const char *, const char *,\");\n-      WBI (\"   int, int, int, int, int, int);\");\n-\n       if Use_Pragma_Linker_Constructor then\n          WBI (\"extern void \" & Ada_Final_Name.all &\n               \" (void) __attribute__((destructor));\");\n@@ -2438,51 +2452,211 @@ package body Bindgen is\n       Close_Binder_Output;\n    end Gen_Output_File_C;\n \n-   -------------------------------\n-   -- Gen_Restrictions_String_1 --\n-   -------------------------------\n+   --------------------------\n+   -- Gen_Restrictions_Ada --\n+   --------------------------\n \n-   procedure Gen_Restrictions_String_1 is\n+   procedure Gen_Restrictions_Ada is\n+      Count : Integer;\n    begin\n-      for R in All_Boolean_Restrictions loop\n-         if Cumulative_Restrictions.Set (R) then\n-            Set_Char ('r');\n-         elsif Cumulative_Restrictions.Violated (R) then\n-            Set_Char ('v');\n-         else\n-            Set_Char ('n');\n+      if Suppress_Standard_Library_On_Target then\n+         return;\n+      end if;\n+\n+      WBI (\"      System.Restrictions.Run_Time_Restrictions :=\");\n+      WBI (\"        (Set =>\");\n+      Set_String      (\"          (\");\n+\n+      Count := 0;\n+\n+      for J in Cumulative_Restrictions.Set'First ..\n+        Restriction_Id'Pred (Cumulative_Restrictions.Set'Last)\n+      loop\n+         Set_Boolean (Cumulative_Restrictions.Set (J));\n+         Set_String (\", \");\n+         Count := Count + 1;\n+\n+         if Count = 8 then\n+            Write_Statement_Buffer;\n+            Set_String (\"           \");\n+            Count := 0;\n          end if;\n       end loop;\n-   end Gen_Restrictions_String_1;\n \n-   -------------------------------\n-   -- Gen_Restrictions_String_2 --\n-   -------------------------------\n+      Set_Boolean\n+        (Cumulative_Restrictions.Set (Cumulative_Restrictions.Set'Last));\n+      Set_String (\"),\");\n+      Write_Statement_Buffer;\n+      Set_String (\"         Value => (\");\n \n-   procedure Gen_Restrictions_String_2 is\n-   begin\n-      for RP in All_Parameter_Restrictions loop\n-         if Cumulative_Restrictions.Set (RP) then\n-            Set_Char ('r');\n-            Set_Int (Int (Cumulative_Restrictions.Value (RP)));\n-         else\n-            Set_Char ('n');\n+      for J in Cumulative_Restrictions.Value'First ..\n+        Restriction_Id'Pred (Cumulative_Restrictions.Value'Last)\n+      loop\n+         Set_Int (Int (Cumulative_Restrictions.Value (J)));\n+         Set_String (\", \");\n+      end loop;\n+\n+      Set_Int (Int (Cumulative_Restrictions.Value\n+        (Cumulative_Restrictions.Value'Last)));\n+      Set_String (\"),\");\n+      Write_Statement_Buffer;\n+      WBI (\"         Violated =>\");\n+      Set_String (\"          (\");\n+      Count := 0;\n+\n+      for J in Cumulative_Restrictions.Violated'First ..\n+        Restriction_Id'Pred (Cumulative_Restrictions.Violated'Last)\n+      loop\n+         Set_Boolean (Cumulative_Restrictions.Violated (J));\n+         Set_String (\", \");\n+         Count := Count + 1;\n+\n+         if Count = 8 then\n+            Write_Statement_Buffer;\n+            Set_String (\"           \");\n+            Count := 0;\n          end if;\n+      end loop;\n \n-         if not Cumulative_Restrictions.Violated (RP)\n-           or else RP not in Checked_Parameter_Restrictions\n-         then\n-            Set_Char ('n');\n-         else\n-            Set_Char ('v');\n-            Set_Int (Int (Cumulative_Restrictions.Count (RP)));\n+      Set_Boolean (Cumulative_Restrictions.Violated\n+        (Cumulative_Restrictions.Violated'Last));\n+      Set_String (\"),\");\n+      Write_Statement_Buffer;\n+      Set_String (\"         Count => (\");\n \n-            if Cumulative_Restrictions.Unknown (RP) then\n-               Set_Char ('+');\n-            end if;\n-         end if;\n+      for J in Cumulative_Restrictions.Count'First ..\n+        Restriction_Id'Pred (Cumulative_Restrictions.Count'Last)\n+      loop\n+         Set_Int (Int (Cumulative_Restrictions.Count (J)));\n+         Set_String (\", \");\n+      end loop;\n+\n+      Set_Int (Int (Cumulative_Restrictions.Count\n+        (Cumulative_Restrictions.Count'Last)));\n+      Set_String (\"),\");\n+      Write_Statement_Buffer;\n+      Set_String (\"         Unknown => (\");\n+\n+      for J in Cumulative_Restrictions.Unknown'First ..\n+        Restriction_Id'Pred (Cumulative_Restrictions.Unknown'Last)\n+      loop\n+         Set_Boolean (Cumulative_Restrictions.Unknown (J));\n+         Set_String (\", \");\n+      end loop;\n+\n+      Set_Boolean\n+        (Cumulative_Restrictions.Unknown\n+          (Cumulative_Restrictions.Unknown'Last));\n+      Set_String (\"));\");\n+      Write_Statement_Buffer;\n+   end Gen_Restrictions_Ada;\n+\n+   ------------------------\n+   -- Gen_Restrictions_C --\n+   ------------------------\n+\n+   procedure Gen_Restrictions_C is\n+   begin\n+      if Suppress_Standard_Library_On_Target then\n+         return;\n+      end if;\n+\n+      WBI (\"   typedef struct {\");\n+      Set_String (\"     char set [\");\n+      Set_Int (Cumulative_Restrictions.Set'Length);\n+      Set_String (\"];\");\n+      Write_Statement_Buffer;\n+\n+      Set_String (\"     int value [\");\n+      Set_Int (Cumulative_Restrictions.Value'Length);\n+      Set_String (\"];\");\n+      Write_Statement_Buffer;\n+\n+      Set_String (\"     char violated [\");\n+      Set_Int (Cumulative_Restrictions.Violated'Length);\n+      Set_String (\"];\");\n+      Write_Statement_Buffer;\n+\n+      Set_String (\"     int count [\");\n+      Set_Int (Cumulative_Restrictions.Count'Length);\n+      Set_String (\"];\");\n+      Write_Statement_Buffer;\n+\n+      Set_String (\"     char unknown [\");\n+      Set_Int (Cumulative_Restrictions.Unknown'Length);\n+      Set_String (\"];\");\n+      Write_Statement_Buffer;\n+      WBI (\"   } restrictions;\");\n+      WBI (\"   extern restrictions \" &\n+           \"system__restrictions__run_time_restrictions;\");\n+      WBI (\"   restrictions r = {\");\n+      Set_String (\"     {\");\n+\n+      for J in Cumulative_Restrictions.Set'First ..\n+        Restriction_Id'Pred (Cumulative_Restrictions.Set'Last)\n+      loop\n+         Set_Int (Boolean'Pos (Cumulative_Restrictions.Set (J)));\n+         Set_String (\", \");\n+      end loop;\n+\n+      Set_Int (Boolean'Pos\n+        (Cumulative_Restrictions.Set (Cumulative_Restrictions.Set'Last)));\n+      Set_String (\"},\");\n+      Write_Statement_Buffer;\n+      Set_String (\"     {\");\n+\n+      for J in Cumulative_Restrictions.Value'First ..\n+        Restriction_Id'Pred (Cumulative_Restrictions.Value'Last)\n+      loop\n+         Set_Int (Int (Cumulative_Restrictions.Value (J)));\n+         Set_String (\", \");\n+      end loop;\n+\n+      Set_Int (Int (Cumulative_Restrictions.Value\n+        (Cumulative_Restrictions.Value'Last)));\n+      Set_String (\"},\");\n+      Write_Statement_Buffer;\n+      Set_String (\"     {\");\n+\n+      for J in Cumulative_Restrictions.Violated'First ..\n+        Restriction_Id'Pred (Cumulative_Restrictions.Violated'Last)\n+      loop\n+         Set_Int (Boolean'Pos (Cumulative_Restrictions.Violated (J)));\n+         Set_String (\", \");\n       end loop;\n-   end Gen_Restrictions_String_2;\n+\n+      Set_Int (Boolean'Pos (Cumulative_Restrictions.Violated\n+        (Cumulative_Restrictions.Violated'Last)));\n+      Set_String (\"},\");\n+      Write_Statement_Buffer;\n+      Set_String (\"     {\");\n+\n+      for J in Cumulative_Restrictions.Count'First ..\n+        Restriction_Id'Pred (Cumulative_Restrictions.Count'Last)\n+      loop\n+         Set_Int (Int (Cumulative_Restrictions.Count (J)));\n+         Set_String (\", \");\n+      end loop;\n+\n+      Set_Int (Int (Cumulative_Restrictions.Count\n+        (Cumulative_Restrictions.Count'Last)));\n+      Set_String (\"},\");\n+      Write_Statement_Buffer;\n+      Set_String (\"     {\");\n+\n+      for J in Cumulative_Restrictions.Unknown'First ..\n+        Restriction_Id'Pred (Cumulative_Restrictions.Unknown'Last)\n+      loop\n+         Set_Int (Boolean'Pos (Cumulative_Restrictions.Unknown (J)));\n+         Set_String (\", \");\n+      end loop;\n+\n+      Set_Int (Boolean'Pos (Cumulative_Restrictions.Unknown\n+          (Cumulative_Restrictions.Unknown'Last)));\n+      Set_String (\"}};\");\n+      Write_Statement_Buffer;\n+      WBI (\"   system__restrictions__run_time_restrictions = r;\");\n+   end Gen_Restrictions_C;\n \n    ----------------------\n    -- Gen_Versions_Ada --\n@@ -2772,78 +2946,6 @@ package body Bindgen is\n       Linker_Options.Table (To) := Linker_Options.Table (From);\n    end Move_Linker_Option;\n \n-   ----------------------------\n-   -- Public_Version_Warning --\n-   ----------------------------\n-\n-   procedure Public_Version_Warning is\n-      Time : constant Int := Time_From_Last_Bind;\n-\n-      --  Constants to help defining periods\n-\n-      Hour : constant := 60;\n-      Day  : constant := 24 * Hour;\n-\n-      Never : constant := Integer'Last;\n-      --  Special value indicating no warnings should be given\n-\n-      --  Constants defining when the warning is issued. Programs with more\n-      --  than Large Units will issue a warning every Period_Large amount of\n-      --  time. Smaller programs will generate a warning every Period_Small\n-      --  amount of time.\n-\n-      Large : constant := 20;\n-      --  Threshold for considering a program small or large\n-\n-      Period_Large : constant := Day;\n-      --  Periodic warning time for large programs\n-\n-      Period_Small : constant := Never;\n-      --  Periodic warning time for small programs\n-\n-      Nb_Unit : Int;\n-\n-   begin\n-      --  Compute the number of units that are not GNAT internal files\n-\n-      Nb_Unit := 0;\n-      for A in ALIs.First .. ALIs.Last loop\n-         if not Is_Internal_File_Name (ALIs.Table (A).Sfile) then\n-            Nb_Unit := Nb_Unit + 1;\n-         end if;\n-      end loop;\n-\n-      --  Do not emit the message if the last message was emitted in the\n-      --  specified period taking into account the number of units.\n-\n-      pragma Warnings (Off);\n-      --  Turn off warning of constant condition, which may happen here\n-      --  depending on the choice of constants in the above declarations.\n-\n-      if Nb_Unit < Large and then Time <= Period_Small then\n-         return;\n-      elsif Time <= Period_Large then\n-         return;\n-      end if;\n-\n-      pragma Warnings (On);\n-\n-      Write_Eol;\n-      Write_Str (\"IMPORTANT NOTICE:\");\n-      Write_Eol;\n-      Write_Str (\"    This version of GNAT is unsupported\"\n-        &                        \" and comes with absolutely no warranty.\");\n-      Write_Eol;\n-      Write_Str (\"    If you intend to evaluate or use GNAT for building \"\n-        &                                       \"commercial applications,\");\n-      Write_Eol;\n-      Write_Str (\"    please consult http://www.gnat.com/ for information\");\n-      Write_Eol;\n-      Write_Str (\"    on the GNAT Professional product line.\");\n-      Write_Eol;\n-      Write_Eol;\n-   end Public_Version_Warning;\n-\n    ----------------------------\n    -- Resolve_Binder_Options --\n    ----------------------------\n@@ -2867,6 +2969,23 @@ package body Bindgen is\n       end loop;\n    end Resolve_Binder_Options;\n \n+   -----------------\n+   -- Set_Boolean --\n+   -----------------\n+\n+   procedure Set_Boolean (B : Boolean) is\n+      True_Str  : constant String := \"True\";\n+      False_Str : constant String := \"False\";\n+   begin\n+      if B then\n+         Statement_Buffer (Last + 1 .. Last + True_Str'Length) := True_Str;\n+         Last := Last + True_Str'Length;\n+      else\n+         Statement_Buffer (Last + 1 .. Last + False_Str'Length) := False_Str;\n+         Last := Last + False_Str'Length;\n+      end if;\n+   end Set_Boolean;\n+\n    --------------\n    -- Set_Char --\n    --------------\n@@ -2960,6 +3079,33 @@ package body Bindgen is\n       end loop;\n    end Set_Name_Buffer;\n \n+   -------------------------\n+   -- Set_PSD_Pragma_Table --\n+   -------------------------\n+\n+   procedure Set_PSD_Pragma_Table is\n+   begin\n+      for F in ALIs.First .. ALIs.Last loop\n+         for K in ALIs.Table (F).First_Specific_Dispatching ..\n+                  ALIs.Table (F).Last_Specific_Dispatching\n+         loop\n+            declare\n+               DTK : Specific_Dispatching_Record\n+                       renames Specific_Dispatching.Table (K);\n+\n+            begin\n+               while PSD_Pragma_Settings.Last < DTK.Last_Priority loop\n+                  PSD_Pragma_Settings.Append ('F');\n+               end loop;\n+\n+               for Prio in DTK.First_Priority .. DTK.Last_Priority loop\n+                  PSD_Pragma_Settings.Table (Prio) := DTK.Dispatching_Policy;\n+               end loop;\n+            end;\n+         end loop;\n+      end loop;\n+   end Set_PSD_Pragma_Table;\n+\n    ----------------\n    -- Set_String --\n    ----------------\n@@ -3005,17 +3151,6 @@ package body Bindgen is\n       Set_Int (Unum);\n    end Set_Unit_Number;\n \n-   ------------\n-   -- Tab_To --\n-   ------------\n-\n-   procedure Tab_To (N : Natural) is\n-   begin\n-      while Last < N loop\n-         Set_Char (' ');\n-      end loop;\n-   end Tab_To;\n-\n    ----------------------\n    -- Write_Info_Ada_C --\n    ----------------------"}, {"sha": "9e3307974531ca3b33ee77de1d50c4b29ad04602", "filename": "gcc/ada/init.c", "status": "modified", "additions": 179, "deletions": 174, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=3cb8344bd34b50012b5c43c7d34d01472f41e026", "patch": "@@ -66,43 +66,41 @@\n \n extern void __gnat_raise_program_error (const char *, int);\n \n-/* Addresses of exception data blocks for predefined exceptions. */\n+/* Addresses of exception data blocks for predefined exceptions. Tasking_Error\n+   is not used in this unit, and the abort signal is only used on IRIX. */\n extern struct Exception_Data constraint_error;\n extern struct Exception_Data numeric_error;\n extern struct Exception_Data program_error;\n extern struct Exception_Data storage_error;\n-extern struct Exception_Data tasking_error;\n-extern struct Exception_Data _abort_signal;\n-\n-#define Lock_Task system__soft_links__lock_task\n-extern void (*Lock_Task) (void);\n-\n-#define Unlock_Task system__soft_links__unlock_task\n-extern void (*Unlock_Task) (void);\n-\n-#define Check_Abort_Status     \\\n-                      system__soft_links__check_abort_status\n-extern int (*Check_Abort_Status) (void);\n \n+/* For the Cert run time we use the regular raise exception routine because\n+   Raise_From_Signal_Handler is not available. */\n+#ifdef CERT\n+#define Raise_From_Signal_Handler \\\n+                      __gnat_raise_exception\n+extern void Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n+#else\n #define Raise_From_Signal_Handler \\\n                       ada__exceptions__raise_from_signal_handler\n extern void Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n+#endif\n \n-/* Copies of global values computed by the binder */\n-int   __gl_main_priority            = -1;\n-int   __gl_time_slice_val           = -1;\n-char  __gl_wc_encoding              = 'n';\n-char  __gl_locking_policy           = ' ';\n-char  __gl_queuing_policy           = ' ';\n-char  __gl_task_dispatching_policy  = ' ';\n-char *__gl_restrictions             = 0;\n-char *__gl_interrupt_states         = 0;\n-int   __gl_num_interrupt_states     = 0;\n-int   __gl_unreserve_all_interrupts = 0;\n-int   __gl_exception_tracebacks     = 0;\n-int   __gl_zero_cost_exceptions     = 0;\n-int   __gl_detect_blocking          = 0;\n-int   __gl_default_stack_size       = -1;\n+/* Global values computed by the binder */\n+int   __gl_main_priority                 = -1;\n+int   __gl_time_slice_val                = -1;\n+char  __gl_wc_encoding                   = 'n';\n+char  __gl_locking_policy                = ' ';\n+char  __gl_queuing_policy                = ' ';\n+char  __gl_task_dispatching_policy       = ' ';\n+char *__gl_priority_specific_dispatching = 0;\n+int   __gl_num_specific_dispatching      = 0;\n+char *__gl_interrupt_states              = 0;\n+int   __gl_num_interrupt_states          = 0;\n+int   __gl_unreserve_all_interrupts      = 0;\n+int   __gl_exception_tracebacks          = 0;\n+int   __gl_zero_cost_exceptions          = 0;\n+int   __gl_detect_blocking               = 0;\n+int   __gl_default_stack_size            = -1;\n \n /* Indication of whether synchronous signal handler has already been\n    installed by a previous call to adainit */\n@@ -144,120 +142,47 @@ __gnat_get_interrupt_state (int intrup)\n     return __gl_interrupt_states [intrup];\n }\n \n-/**********************/\n-/* __gnat_set_globals */\n-/**********************/\n+/***********************************/\n+/* __gnat_get_specific_dispatching */\n+/***********************************/\n \n-/* This routine is called from the binder generated main program.  It copies\n-   the values for global quantities computed by the binder into the following\n-   global locations. The reason that we go through this copy, rather than just\n-   define the global locations in the binder generated file, is that they are\n-   referenced from the runtime, which may be in a shared library, and the\n-   binder file is not in the shared library. Global references across library\n-   boundaries like this are not handled correctly in all systems.  */\n+char __gnat_get_specific_dispatching (int);\n \n-/* For detailed description of the parameters to this routine, see the\n-   section titled Run-Time Globals in package Bindgen (bindgen.adb) */\n+/* This routine is called from the run time as needed to determine the\n+   priority specific dispatching policy, as set by a\n+   Priority_Specific_Dispatching pragma appearing anywhere in the current\n+   partition. The input argument is the priority number, and the result is\n+   the upper case first character of the policy name, e.g. 'F' for\n+   FIFO_Within_Priorities. A space ' ' is returned if no\n+   Priority_Specific_Dispatching pragma is used in the partition. */\n \n-void\n-__gnat_set_globals (int main_priority,\n-                    int time_slice_val,\n-                    char wc_encoding,\n-                    char locking_policy,\n-                    char queuing_policy,\n-                    char task_dispatching_policy,\n-                    char *restrictions,\n-                    char *interrupt_states,\n-                    int num_interrupt_states,\n-                    int unreserve_all_interrupts,\n-                    int exception_tracebacks,\n-                    int zero_cost_exceptions,\n-                    int detect_blocking,\n-                    int default_stack_size)\n+char\n+__gnat_get_specific_dispatching (int priority)\n {\n-  static int already_called = 0;\n-\n-  /* If this procedure has been already called once, check that the\n-     arguments in this call are consistent with the ones in the previous\n-     calls. Otherwise, raise a Program_Error exception.\n-\n-     We do not check for consistency of the wide character encoding\n-     method. This default affects only Wide_Text_IO where no explicit\n-     coding method is given, and there is no particular reason to let\n-     this default be affected by the source representation of a library\n-     in any case.\n-\n-     We do not check either for the consistency of exception tracebacks,\n-     because exception tracebacks are not normally set in Stand-Alone\n-     libraries. If a library or the main program set the exception\n-     tracebacks, then they are never reset afterwards (see below).\n-\n-     The value of main_priority is meaningful only when we are invoked\n-     from the main program elaboration routine of an Ada application.\n-     Checking the consistency of this parameter should therefore not be\n-     done. Since it is assured that the main program elaboration will\n-     always invoke this procedure before any library elaboration\n-     routine, only the value of main_priority during the first call\n-     should be taken into account and all the subsequent ones should be\n-     ignored. Note that the case where the main program is not written\n-     in Ada is also properly handled, since the default value will then\n-     be used for this parameter.\n-\n-     For identical reasons, the consistency of time_slice_val should not\n-     be checked. */\n-\n-  if (already_called)\n-    {\n-      if (__gl_locking_policy\t\t   != locking_policy\n-\t  || __gl_queuing_policy           != queuing_policy\n-\t  || __gl_task_dispatching_policy  != task_dispatching_policy\n-\t  || __gl_unreserve_all_interrupts != unreserve_all_interrupts\n-\t  || __gl_zero_cost_exceptions     != zero_cost_exceptions\n-\t  || __gl_default_stack_size       != default_stack_size)\n-\t__gnat_raise_program_error (__FILE__, __LINE__);\n+  if (__gl_num_specific_dispatching == 0)\n+    return ' ';\n+  else if (priority >= __gl_num_specific_dispatching)\n+    return 'F';\n+  else\n+    return __gl_priority_specific_dispatching [priority];\n+}\n \n-      /* If either a library or the main program set the exception traceback\n-         flag, it is never reset later */\n+#ifndef IN_RTS\n \n-      if (exception_tracebacks != 0)\n-         __gl_exception_tracebacks = exception_tracebacks;\n+/**********************/\n+/* __gnat_set_globals */\n+/**********************/\n \n-      return;\n-    }\n-  already_called = 1;\n-\n-  __gl_main_priority            = main_priority;\n-  __gl_time_slice_val           = time_slice_val;\n-  __gl_wc_encoding              = wc_encoding;\n-  __gl_locking_policy           = locking_policy;\n-  __gl_queuing_policy           = queuing_policy;\n-  __gl_restrictions             = restrictions;\n-  __gl_interrupt_states         = interrupt_states;\n-  __gl_num_interrupt_states     = num_interrupt_states;\n-  __gl_task_dispatching_policy  = task_dispatching_policy;\n-  __gl_unreserve_all_interrupts = unreserve_all_interrupts;\n-  __gl_exception_tracebacks     = exception_tracebacks;\n-  __gl_detect_blocking          = detect_blocking;\n-\n-  /* ??? __gl_zero_cost_exceptions is new in 3.15 and is referenced from\n-     a-except.adb, which is also part of the compiler sources. Since the\n-     compiler is built with an older release of GNAT, the call generated by\n-     the old binder to this function does not provide any value for the\n-     corresponding argument, so the global has to be initialized in some\n-     reasonable other way. This could be removed as soon as the next major\n-     release is out.  */\n-\n-   /* ??? ditto for __gl_default_stack_size, new in 5.04 */\n+/* This routine is kept for boostrapping purposes, since the binder generated\n+   file now sets the __gl_* variables directly. */\n \n-#ifdef IN_RTS\n-  __gl_zero_cost_exceptions = zero_cost_exceptions;\n-  __gl_default_stack_size = default_stack_size;\n-#else\n-  __gl_zero_cost_exceptions = 0;\n-  /* We never build the compiler to run in ZCX mode currently anyway.  */\n-#endif\n+void\n+__gnat_set_globals ()\n+{\n }\n \n+#endif\n+\n /* Notes on the Zero Cost Exceptions scheme and its impact on the signal\n    handlers implemented below :\n \n@@ -647,6 +572,38 @@ __gnat_install_handler (void)\n #define NULL ((void *) 0)\n #endif\n \n+#if defined (MaRTE)\n+\n+/* MaRTE OS provides its own version of sigaction, sigfillset, and\n+   sigemptyset (overriding these symbol names). We want to make sure that\n+   the versions provided by the underlying C library are used here (these\n+   versions are renamed by MaRTE to linux_sigaction, fake_linux_sigfillset,\n+   and fake_linux_sigemptyset, respectively). The MaRTE library will not\n+   always be present (it will not be linked if no tasking constructs are\n+   used), so we use the weak symbol mechanism to point always to the symbols\n+   defined within the C library. */\n+\n+#pragma weak linux_sigaction\n+int linux_sigaction (int signum, const struct sigaction *act,\n+\t\t     struct sigaction *oldact) {\n+  return sigaction (signum, act, oldact);\n+}\n+#define sigaction(signum, act, oldact) linux_sigaction (signum, act, oldact)\n+\n+#pragma weak fake_linux_sigfillset\n+void fake_linux_sigfillset (sigset_t *set) {\n+  sigfillset (set);\n+}\n+#define sigfillset(set) fake_linux_sigfillset (set)\n+\n+#pragma weak fake_linux_sigemptyset\n+void fake_linux_sigemptyset (sigset_t *set) {\n+  sigemptyset (set);\n+}\n+#define sigemptyset(set) fake_linux_sigemptyset (set)\n+\n+#endif\n+\n static void __gnat_error_handler (int, siginfo_t *siginfo, void *ucontext);\n \n /* __gnat_adjust_context_for_raise - see comments along with the default\n@@ -856,6 +813,12 @@ __gnat_install_handler (void)\n #define SIGNAL_STACK_SIZE 4096\n #define SIGNAL_STACK_ALIGNMENT 64\n \n+#define Check_Abort_Status     \\\n+                      system__soft_links__check_abort_status\n+extern int (*Check_Abort_Status) (void);\n+\n+extern struct Exception_Data _abort_signal;\n+\n static void __gnat_error_handler (int, int, sigcontext_t *);\n \n /* We are not setting the SA_SIGINFO bit in the sigaction flags when\n@@ -1186,35 +1149,35 @@ extern Exception_Code Base_Code_In (Exception_Code);\n /* DEC Ada exceptions are not defined in a header file, so they\n    must be declared as external addresses */\n \n-extern int ADA$_PROGRAM_ERROR __attribute__ ((weak));\n-extern int ADA$_LOCK_ERROR __attribute__ ((weak));\n-extern int ADA$_EXISTENCE_ERROR __attribute__ ((weak));\n-extern int ADA$_KEY_ERROR __attribute__ ((weak));\n-extern int ADA$_KEYSIZERR __attribute__ ((weak));\n-extern int ADA$_STAOVF __attribute__ ((weak));\n-extern int ADA$_CONSTRAINT_ERRO __attribute__ ((weak));\n-extern int ADA$_IOSYSFAILED __attribute__ ((weak));\n-extern int ADA$_LAYOUT_ERROR __attribute__ ((weak));\n-extern int ADA$_STORAGE_ERROR __attribute__ ((weak));\n-extern int ADA$_DATA_ERROR __attribute__ ((weak));\n-extern int ADA$_DEVICE_ERROR __attribute__ ((weak));\n-extern int ADA$_END_ERROR __attribute__ ((weak));\n-extern int ADA$_MODE_ERROR __attribute__ ((weak));\n-extern int ADA$_NAME_ERROR __attribute__ ((weak));\n-extern int ADA$_STATUS_ERROR __attribute__ ((weak));\n-extern int ADA$_NOT_OPEN __attribute__ ((weak));\n-extern int ADA$_ALREADY_OPEN __attribute__ ((weak));\n-extern int ADA$_USE_ERROR __attribute__ ((weak));\n-extern int ADA$_UNSUPPORTED __attribute__ ((weak));\n-extern int ADA$_FAC_MODE_MISMAT __attribute__ ((weak));\n-extern int ADA$_ORG_MISMATCH __attribute__ ((weak));\n-extern int ADA$_RFM_MISMATCH __attribute__ ((weak));\n-extern int ADA$_RAT_MISMATCH __attribute__ ((weak));\n-extern int ADA$_MRS_MISMATCH __attribute__ ((weak));\n-extern int ADA$_MRN_MISMATCH __attribute__ ((weak));\n-extern int ADA$_KEY_MISMATCH __attribute__ ((weak));\n-extern int ADA$_MAXLINEXC __attribute__ ((weak));\n-extern int ADA$_LINEXCMRS __attribute__ ((weak));\n+extern int ADA$_PROGRAM_ERROR;\n+extern int ADA$_LOCK_ERROR;\n+extern int ADA$_EXISTENCE_ERROR;\n+extern int ADA$_KEY_ERROR;\n+extern int ADA$_KEYSIZERR;\n+extern int ADA$_STAOVF;\n+extern int ADA$_CONSTRAINT_ERRO;\n+extern int ADA$_IOSYSFAILED;\n+extern int ADA$_LAYOUT_ERROR;\n+extern int ADA$_STORAGE_ERROR;\n+extern int ADA$_DATA_ERROR;\n+extern int ADA$_DEVICE_ERROR;\n+extern int ADA$_END_ERROR;\n+extern int ADA$_MODE_ERROR;\n+extern int ADA$_NAME_ERROR;\n+extern int ADA$_STATUS_ERROR;\n+extern int ADA$_NOT_OPEN;\n+extern int ADA$_ALREADY_OPEN;\n+extern int ADA$_USE_ERROR;\n+extern int ADA$_UNSUPPORTED;\n+extern int ADA$_FAC_MODE_MISMAT;\n+extern int ADA$_ORG_MISMATCH;\n+extern int ADA$_RFM_MISMATCH;\n+extern int ADA$_RAT_MISMATCH;\n+extern int ADA$_MRS_MISMATCH;\n+extern int ADA$_MRN_MISMATCH;\n+extern int ADA$_KEY_MISMATCH;\n+extern int ADA$_MAXLINEXC;\n+extern int ADA$_LINEXCMRS;\n \n /* DEC Ada specific conditions */\n static const struct cond_except dec_ada_cond_except_table [] = {\n@@ -1495,7 +1458,7 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n \tbreak;\n       }\n \n- __gnat_adjust_context_for_raise (0, (void *)sigargs);\n+ __gnat_adjust_context_for_raise (0, (void *)mechargs);\n  Raise_From_Signal_Handler (exception, msg);\n }\n \n@@ -1514,13 +1477,6 @@ __gnat_install_handler (void)\n   SYS$SETEXV (1, __gnat_error_handler, 3, &prvhnd);\n #endif\n \n-#if defined (IN_RTS) && defined (__IA64)\n-  if (getenv (\"DBG$TDBG\"))\n-    printf (\"DBG$TDBG defined, __gnat_error_handler not installed!\\n\");\n-  else\n-    SYS$SETEXV (1, __gnat_error_handler, 3, &prvhnd);\n-#endif\n-\n   /* On alpha-vms, we avoid the global vector annoyance thanks to frame based\n      handlers to turn conditions into exceptions since GCC 3.4.  The global\n      vector is still required for earlier GCC versions.  We're resorting to\n@@ -1555,7 +1511,9 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n   /* Add one to the address of the instruction signaling the condition,\n      located in the sigargs array.  */\n \n-  CHF$SIGNAL_ARRAY * sigargs = (CHF$SIGNAL_ARRAY *) ucontext;\n+  CHF$MECH_ARRAY * mechargs = (CHF$MECH_ARRAY *) ucontext;\n+  CHF$SIGNAL_ARRAY * sigargs\n+    = (CHF$SIGNAL_ARRAY *) mechargs->chf$q_mch_sig_addr;\n \n   int vcount = sigargs->chf$is_sig_args;\n   int * pc_slot = & (&sigargs->chf$l_sig_name)[vcount-2];\n@@ -1565,20 +1523,66 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n \n #endif\n \n+/* __gnat_adjust_context_for_raise for ia64.  */\n+\n+#if defined (IN_RTS) && defined (__IA64)\n+\n+#include <vms/chfctxdef.h>\n+#include <vms/chfdef.h>\n+\n+#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n+\n+typedef unsigned long long u64;\n+\n+void\n+__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n+{\n+  /* Add one to the address of the instruction signaling the condition,\n+     located in the 64bits sigargs array.  */\n+\n+  CHF$MECH_ARRAY * mechargs = (CHF$MECH_ARRAY *) ucontext;\n+\n+  CHF64$SIGNAL_ARRAY *chfsig64\n+    = (CHF64$SIGNAL_ARRAY *) mechargs->chf$ph_mch_sig64_addr;\n+\n+  u64 * post_sigarray\n+    = (u64 *)chfsig64 + 1 + chfsig64->chf64$l_sig_args;\n+\n+  u64 * ih_pc_loc = post_sigarray - 2;\n+\n+  (*ih_pc_loc) ++;\n+}\n+\n+#endif\n+\n /*******************/\n /* FreeBSD Section */\n /*******************/\n \n #elif defined (__FreeBSD__)\n \n #include <signal.h>\n+#include <sys/ucontext.h>\n #include <unistd.h>\n \n-static void __gnat_error_handler (int, int, struct sigcontext *);\n+static void __gnat_error_handler (int, siginfo_t *, ucontext_t *);\n+void __gnat_adjust_context_for_raise (int, void*);\n+\n+/* __gnat_adjust_context_for_raise - see comments along with the default\n+   version later in this file.  */\n+\n+#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n+\n+void\n+__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n+{\n+  mcontext_t *mcontext = &((ucontext_t *) ucontext)->uc_mcontext;\n+  mcontext->mc_eip++;\n+}\n \n static void\n-__gnat_error_handler (int sig, int code __attribute__ ((unused)),\n-\t\t      struct sigcontext *sc __attribute__ ((unused)))\n+__gnat_error_handler (int sig, siginfo_t *info __attribute__ ((unused)),\n+\t\t      ucontext_t *ucontext)\n {\n   struct Exception_Data *exception;\n   const char *msg;\n@@ -1610,6 +1614,7 @@ __gnat_error_handler (int sig, int code __attribute__ ((unused)),\n       msg = \"unhandled signal\";\n     }\n \n+  __gnat_adjust_context_for_raise (sig, ucontext);\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n@@ -1623,7 +1628,7 @@ __gnat_install_handler ()\n      signal that might cause a scheduling event! */\n \n   act.sa_handler = __gnat_error_handler;\n-  act.sa_flags = SA_NODEFER | SA_RESTART;\n+  act.sa_flags = SA_NODEFER | SA_RESTART | SA_SIGINFO;\n   (void) sigemptyset (&act.sa_mask);\n \n   (void) sigaction (SIGILL,  &act, NULL);"}, {"sha": "521e06257342e28653819a63a8b8f2c68c16ff51", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=3cb8344bd34b50012b5c43c7d34d01472f41e026", "patch": "@@ -354,6 +354,16 @@ package body Lib.Writ is\n          Write_Info_Tab (49);\n          Write_Info_Str (Version_Get (Unit_Num));\n \n+         --  Add BD parameter if Elaborate_Body pragma desirable\n+\n+         if Ekind (Uent) = E_Package\n+           and then Elaborate_Body_Desirable (Uent)\n+         then\n+            Write_Info_Str (\" BD\");\n+         end if;\n+\n+         --  Add BN parameter if body needed for SAL\n+\n          if (Is_Subprogram (Uent)\n               or else Ekind (Uent) = E_Package\n               or else Is_Generic_Unit (Uent))\n@@ -1050,6 +1060,23 @@ package body Lib.Writ is\n          Write_Info_EOL;\n       end loop;\n \n+      --  Output priority specific dispatching lines\n+\n+      for J in Specific_Dispatching.First .. Specific_Dispatching.Last loop\n+         Write_Info_Initiate ('S');\n+         Write_Info_Char (' ');\n+         Write_Info_Char (Specific_Dispatching.Table (J).Dispatching_Policy);\n+         Write_Info_Char (' ');\n+         Write_Info_Nat (Specific_Dispatching.Table (J).First_Priority);\n+         Write_Info_Char (' ');\n+         Write_Info_Nat (Specific_Dispatching.Table (J).Last_Priority);\n+         Write_Info_Char (' ');\n+         Write_Info_Nat\n+           (Nat (Get_Logical_Line_Number\n+                   (Specific_Dispatching.Table (J).Pragma_Loc)));\n+         Write_Info_EOL;\n+      end loop;\n+\n       --  Loop through file table to output information for all units for which\n       --  we have generated code, as marked by the Generate_Code flag.\n "}, {"sha": "0d4a160f6042b50d4a4301551c09efd19f70608b", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=3cb8344bd34b50012b5c43c7d34d01472f41e026", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -368,6 +368,26 @@ package Lib.Writ is\n    --      line number of the corresponding Interrupt_State pragma.\n    --      This is used in consistency messages.\n \n+   --  -------------------------------------\n+   --  -- S Priority Specific Dispatching --\n+   --  -------------------------------------\n+\n+   --    S policy_identifier first_priority last_priority line-number\n+\n+   --      This line records information from a Priority_Specific_Dispatching\n+   --      pragma. There is one line for each separate pragma, and if no such\n+   --      pragmas are used, then no S lines are present.\n+\n+   --      The policy_identifier is the first character (upper case) of the\n+   --      corresponding policy name (e.g. 'F' for FIFO_Within_Priorities).\n+\n+   --      The first_priority and last_priority fields define the range of\n+   --      priorities to which the specified dispatching policy apply.\n+\n+   --      The line number is an unsigned decimal integer giving the\n+   --      line number of the corresponding Priority_Specific_Dispatching\n+   --      pragma. This is used in consistency messages.\n+\n    ----------------------------\n    -- Compilation Unit Lines --\n    ----------------------------\n@@ -403,6 +423,14 @@ package Lib.Writ is\n    --      The <<attributes>> are a series of two letter codes indicating\n    --      information about the unit:\n    --\n+   --         BD  Unit does not have pragma Elaborate_Body, but the elaboration\n+   --             circuit has determined that it would be a good idea if this\n+   --             pragma were present, since the body of the package contains\n+   --             elaboration code that modifies one or more variables in the\n+   --             visible part of the package. The binder will try, but does\n+   --             not promise, to keep the elaboration of the body close to\n+   --             the elaboration of the spec.\n+   --\n    --         DE  Dynamic Elaboration. This unit was compiled with the\n    --             dynamic elaboration model, as set by either the -gnatE\n    --             switch or pragma Elaboration_Checks (Dynamic).\n@@ -643,6 +671,36 @@ package Lib.Writ is\n      Table_Increment      => 200,\n      Table_Name           => \"Name_Interrupt_States\");\n \n+   --  The table structure defined here stores one entry for each\n+   --  Priority_Specific_Dispatching pragma encountered either in the main\n+   --  source or in an ancillary with'ed source. Since\n+   --  have to be consistent across all units in a partition, we may\n+   --  as well detect inconsistencies at compile time when we can.\n+\n+   type Specific_Dispatching_Entry is record\n+      Dispatching_Policy : Character;\n+      --  First character (upper case) of the corresponding policy name\n+\n+      First_Priority     : Nat;\n+      --  Lower bound of the priority range to which the specified dispatching\n+      --  policy applies.\n+\n+      Last_Priority      : Nat;\n+      --  Upper bound of the priority range to which the specified dispatching\n+      --  policy applies.\n+\n+      Pragma_Loc         : Source_Ptr;\n+      --  Location of pragma setting this value in place\n+   end record;\n+\n+   package Specific_Dispatching is new Table.Table (\n+     Table_Component_Type => Specific_Dispatching_Entry,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 10,\n+     Table_Increment      => 100,\n+     Table_Name           => \"Name_Priority_Specific_Dispatching\");\n+\n    -----------------\n    -- Subprograms --\n    -----------------"}, {"sha": "eb56fc2566c0912380fdf4f3d832b7a09f4c5d59", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 187, "deletions": 138, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8344bd34b50012b5c43c7d34d01472f41e026/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=3cb8344bd34b50012b5c43c7d34d01472f41e026", "patch": "@@ -39,6 +39,8 @@ with Stylesw;  use Stylesw;\n with Uintp;    use Uintp;\n with Uname;    use Uname;\n \n+with System.WCh_Con; use System.WCh_Con;\n+\n separate (Par)\n \n function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n@@ -903,7 +905,7 @@ begin\n             A := Expression (Arg1);\n \n             if Nkind (A) = N_String_Literal then\n-               S   := Strval (A);\n+               S := Strval (A);\n \n                declare\n                   Slen    : constant Natural := Natural (String_Length (S));\n@@ -969,8 +971,10 @@ begin\n       -- Warnings (GNAT) --\n       ---------------------\n \n-      --  pragma Warnings (On | Off, [LOCAL_NAME])\n+      --  pragma Warnings (On | Off);\n+      --  pragma Warnings (On | Off, LOCAL_NAME);\n       --  pragma Warnings (static_string_EXPRESSION);\n+      --  pragma Warnings (On | Off, static_string_EXPRESSION);\n \n       --  The one argument ON/OFF case is processed by the parser, since it may\n       --  control parser warnings as well as semantic warnings, and in any case\n@@ -994,149 +998,194 @@ begin\n             end;\n          end if;\n \n+      -----------------------------\n+      -- Wide_Character_Encoding --\n+      -----------------------------\n+\n+      --  pragma Wide_Character_Encoding (IDENTIFIER | CHARACTER_LITERAL);\n+\n+      --  This is processed by the parser, since the scanner is affected\n+\n+      when Pragma_Wide_Character_Encoding => Wide_Character_Encoding : declare\n+         A : Node_Id;\n+\n+      begin\n+         Check_Arg_Count (1);\n+         Check_No_Identifier (Arg1);\n+         A := Expression (Arg1);\n+\n+         if Nkind (A) = N_Identifier then\n+            Get_Name_String (Chars (A));\n+            Wide_Character_Encoding_Method :=\n+              Get_WC_Encoding_Method (Name_Buffer (1 .. Name_Len));\n+\n+         elsif Nkind (A) = N_Character_Literal then\n+            declare\n+               R : constant Char_Code :=\n+                     Char_Code (UI_To_Int (Char_Literal_Value (A)));\n+            begin\n+               if In_Character_Range (R) then\n+                  Wide_Character_Encoding_Method :=\n+                    Get_WC_Encoding_Method (Get_Character (R));\n+               else\n+                  raise Constraint_Error;\n+               end if;\n+            end;\n+\n+         else\n+               raise Constraint_Error;\n+         end if;\n+\n+      exception\n+         when Constraint_Error =>\n+            Error_Msg_N (\"invalid argument for pragma%\", Arg1);\n+      end Wide_Character_Encoding;\n+\n       -----------------------\n       -- All Other Pragmas --\n       -----------------------\n \n       --  For all other pragmas, checking and processing is handled\n       --  entirely in Sem_Prag, and no further checking is done by Par.\n \n-      when Pragma_Abort_Defer                  |\n-           Pragma_Assertion_Policy             |\n-           Pragma_AST_Entry                    |\n-           Pragma_All_Calls_Remote             |\n-           Pragma_Annotate                     |\n-           Pragma_Assert                       |\n-           Pragma_Asynchronous                 |\n-           Pragma_Atomic                       |\n-           Pragma_Atomic_Components            |\n-           Pragma_Attach_Handler               |\n-           Pragma_Compile_Time_Warning         |\n-           Pragma_Convention_Identifier        |\n-           Pragma_CPP_Class                    |\n-           Pragma_CPP_Constructor              |\n-           Pragma_CPP_Virtual                  |\n-           Pragma_CPP_Vtable                   |\n-           Pragma_C_Pass_By_Copy               |\n-           Pragma_Comment                      |\n-           Pragma_Common_Object                |\n-           Pragma_Complete_Representation      |\n-           Pragma_Complex_Representation       |\n-           Pragma_Component_Alignment          |\n-           Pragma_Controlled                   |\n-           Pragma_Convention                   |\n-           Pragma_Debug_Policy                 |\n-           Pragma_Detect_Blocking              |\n-           Pragma_Discard_Names                |\n-           Pragma_Eliminate                    |\n-           Pragma_Elaborate                    |\n-           Pragma_Elaborate_All                |\n-           Pragma_Elaborate_Body               |\n-           Pragma_Elaboration_Checks           |\n-           Pragma_Explicit_Overriding          |\n-           Pragma_Export                       |\n-           Pragma_Export_Exception             |\n-           Pragma_Export_Function              |\n-           Pragma_Export_Object                |\n-           Pragma_Export_Procedure             |\n-           Pragma_Export_Value                 |\n-           Pragma_Export_Valued_Procedure      |\n-           Pragma_Extend_System                |\n-           Pragma_External                     |\n-           Pragma_External_Name_Casing         |\n-           Pragma_Finalize_Storage_Only        |\n-           Pragma_Float_Representation         |\n-           Pragma_Ident                        |\n-           Pragma_Import                       |\n-           Pragma_Import_Exception             |\n-           Pragma_Import_Function              |\n-           Pragma_Import_Object                |\n-           Pragma_Import_Procedure             |\n-           Pragma_Import_Valued_Procedure      |\n-           Pragma_Initialize_Scalars           |\n-           Pragma_Inline                       |\n-           Pragma_Inline_Always                |\n-           Pragma_Inline_Generic               |\n-           Pragma_Inspection_Point             |\n-           Pragma_Interface                    |\n-           Pragma_Interface_Name               |\n-           Pragma_Interrupt_Handler            |\n-           Pragma_Interrupt_State              |\n-           Pragma_Interrupt_Priority           |\n-           Pragma_Java_Constructor             |\n-           Pragma_Java_Interface               |\n-           Pragma_Keep_Names                   |\n-           Pragma_License                      |\n-           Pragma_Link_With                    |\n-           Pragma_Linker_Alias                 |\n-           Pragma_Linker_Constructor           |\n-           Pragma_Linker_Destructor            |\n-           Pragma_Linker_Options               |\n-           Pragma_Linker_Section               |\n-           Pragma_Locking_Policy               |\n-           Pragma_Long_Float                   |\n-           Pragma_Machine_Attribute            |\n-           Pragma_Main                         |\n-           Pragma_Main_Storage                 |\n-           Pragma_Memory_Size                  |\n-           Pragma_No_Return                    |\n-           Pragma_Obsolescent                  |\n-           Pragma_No_Run_Time                  |\n-           Pragma_No_Strict_Aliasing           |\n-           Pragma_Normalize_Scalars            |\n-           Pragma_Optimize                     |\n-           Pragma_Optional_Overriding          |\n-           Pragma_Pack                         |\n-           Pragma_Passive                      |\n-           Pragma_Polling                      |\n-           Pragma_Persistent_BSS               |\n-           Pragma_Preelaborate                 |\n-           Pragma_Preelaborate_05              |\n-           Pragma_Priority                     |\n-           Pragma_Profile                      |\n-           Pragma_Profile_Warnings             |\n-           Pragma_Propagate_Exceptions         |\n-           Pragma_Psect_Object                 |\n-           Pragma_Pure                         |\n-           Pragma_Pure_05                      |\n-           Pragma_Pure_Function                |\n-           Pragma_Queuing_Policy               |\n-           Pragma_Remote_Call_Interface        |\n-           Pragma_Remote_Types                 |\n-           Pragma_Restricted_Run_Time          |\n-           Pragma_Ravenscar                    |\n-           Pragma_Reviewable                   |\n-           Pragma_Share_Generic                |\n-           Pragma_Shared                       |\n-           Pragma_Shared_Passive               |\n-           Pragma_Storage_Size                 |\n-           Pragma_Storage_Unit                 |\n-           Pragma_Stream_Convert               |\n-           Pragma_Subtitle                     |\n-           Pragma_Suppress                     |\n-           Pragma_Suppress_All                 |\n-           Pragma_Suppress_Debug_Info          |\n-           Pragma_Suppress_Exception_Locations |\n-           Pragma_Suppress_Initialization      |\n-           Pragma_System_Name                  |\n-           Pragma_Task_Dispatching_Policy      |\n-           Pragma_Task_Info                    |\n-           Pragma_Task_Name                    |\n-           Pragma_Task_Storage                 |\n-           Pragma_Thread_Body                  |\n-           Pragma_Time_Slice                   |\n-           Pragma_Title                        |\n-           Pragma_Unchecked_Union              |\n-           Pragma_Unimplemented_Unit           |\n-           Pragma_Universal_Data               |\n-           Pragma_Unreferenced                 |\n-           Pragma_Unreserve_All_Interrupts     |\n-           Pragma_Unsuppress                   |\n-           Pragma_Use_VADS_Size                |\n-           Pragma_Volatile                     |\n-           Pragma_Volatile_Components          |\n-           Pragma_Weak_External                |\n-           Pragma_Validity_Checks              =>\n+      when Pragma_Abort_Defer                   |\n+           Pragma_Assertion_Policy              |\n+           Pragma_AST_Entry                     |\n+           Pragma_All_Calls_Remote              |\n+           Pragma_Annotate                      |\n+           Pragma_Assert                        |\n+           Pragma_Asynchronous                  |\n+           Pragma_Atomic                        |\n+           Pragma_Atomic_Components             |\n+           Pragma_Attach_Handler                |\n+           Pragma_Compile_Time_Warning          |\n+           Pragma_Convention_Identifier         |\n+           Pragma_CPP_Class                     |\n+           Pragma_CPP_Constructor               |\n+           Pragma_CPP_Virtual                   |\n+           Pragma_CPP_Vtable                    |\n+           Pragma_C_Pass_By_Copy                |\n+           Pragma_Comment                       |\n+           Pragma_Common_Object                 |\n+           Pragma_Complete_Representation       |\n+           Pragma_Complex_Representation        |\n+           Pragma_Component_Alignment           |\n+           Pragma_Controlled                    |\n+           Pragma_Convention                    |\n+           Pragma_Debug_Policy                  |\n+           Pragma_Detect_Blocking               |\n+           Pragma_Discard_Names                 |\n+           Pragma_Eliminate                     |\n+           Pragma_Elaborate                     |\n+           Pragma_Elaborate_All                 |\n+           Pragma_Elaborate_Body                |\n+           Pragma_Elaboration_Checks            |\n+           Pragma_Explicit_Overriding           |\n+           Pragma_Export                        |\n+           Pragma_Export_Exception              |\n+           Pragma_Export_Function               |\n+           Pragma_Export_Object                 |\n+           Pragma_Export_Procedure              |\n+           Pragma_Export_Value                  |\n+           Pragma_Export_Valued_Procedure       |\n+           Pragma_Extend_System                 |\n+           Pragma_External                      |\n+           Pragma_External_Name_Casing          |\n+           Pragma_Finalize_Storage_Only         |\n+           Pragma_Float_Representation          |\n+           Pragma_Ident                         |\n+           Pragma_Import                        |\n+           Pragma_Import_Exception              |\n+           Pragma_Import_Function               |\n+           Pragma_Import_Object                 |\n+           Pragma_Import_Procedure              |\n+           Pragma_Import_Valued_Procedure       |\n+           Pragma_Initialize_Scalars            |\n+           Pragma_Inline                        |\n+           Pragma_Inline_Always                 |\n+           Pragma_Inline_Generic                |\n+           Pragma_Inspection_Point              |\n+           Pragma_Interface                     |\n+           Pragma_Interface_Name                |\n+           Pragma_Interrupt_Handler             |\n+           Pragma_Interrupt_State               |\n+           Pragma_Interrupt_Priority            |\n+           Pragma_Java_Constructor              |\n+           Pragma_Java_Interface                |\n+           Pragma_Keep_Names                    |\n+           Pragma_License                       |\n+           Pragma_Link_With                     |\n+           Pragma_Linker_Alias                  |\n+           Pragma_Linker_Constructor            |\n+           Pragma_Linker_Destructor             |\n+           Pragma_Linker_Options                |\n+           Pragma_Linker_Section                |\n+           Pragma_Locking_Policy                |\n+           Pragma_Long_Float                    |\n+           Pragma_Machine_Attribute             |\n+           Pragma_Main                          |\n+           Pragma_Main_Storage                  |\n+           Pragma_Memory_Size                   |\n+           Pragma_No_Return                     |\n+           Pragma_Obsolescent                   |\n+           Pragma_No_Run_Time                   |\n+           Pragma_No_Strict_Aliasing            |\n+           Pragma_Normalize_Scalars             |\n+           Pragma_Optimize                      |\n+           Pragma_Optional_Overriding           |\n+           Pragma_Pack                          |\n+           Pragma_Passive                       |\n+           Pragma_Preelaborable_Initialization  |\n+           Pragma_Polling                       |\n+           Pragma_Persistent_BSS                |\n+           Pragma_Preelaborate                  |\n+           Pragma_Preelaborate_05               |\n+           Pragma_Priority                      |\n+           Pragma_Priority_Specific_Dispatching |\n+           Pragma_Profile                       |\n+           Pragma_Profile_Warnings              |\n+           Pragma_Propagate_Exceptions          |\n+           Pragma_Psect_Object                  |\n+           Pragma_Pure                          |\n+           Pragma_Pure_05                       |\n+           Pragma_Pure_Function                 |\n+           Pragma_Queuing_Policy                |\n+           Pragma_Remote_Call_Interface         |\n+           Pragma_Remote_Types                  |\n+           Pragma_Restricted_Run_Time           |\n+           Pragma_Ravenscar                     |\n+           Pragma_Reviewable                    |\n+           Pragma_Share_Generic                 |\n+           Pragma_Shared                        |\n+           Pragma_Shared_Passive                |\n+           Pragma_Storage_Size                  |\n+           Pragma_Storage_Unit                  |\n+           Pragma_Stream_Convert                |\n+           Pragma_Subtitle                      |\n+           Pragma_Suppress                      |\n+           Pragma_Suppress_All                  |\n+           Pragma_Suppress_Debug_Info           |\n+           Pragma_Suppress_Exception_Locations  |\n+           Pragma_Suppress_Initialization       |\n+           Pragma_System_Name                   |\n+           Pragma_Task_Dispatching_Policy       |\n+           Pragma_Task_Info                     |\n+           Pragma_Task_Name                     |\n+           Pragma_Task_Storage                  |\n+           Pragma_Thread_Body                   |\n+           Pragma_Time_Slice                    |\n+           Pragma_Title                         |\n+           Pragma_Unchecked_Union               |\n+           Pragma_Unimplemented_Unit            |\n+           Pragma_Universal_Data                |\n+           Pragma_Unreferenced                  |\n+           Pragma_Unreserve_All_Interrupts      |\n+           Pragma_Unsuppress                    |\n+           Pragma_Use_VADS_Size                 |\n+           Pragma_Volatile                      |\n+           Pragma_Volatile_Components           |\n+           Pragma_Weak_External                 |\n+           Pragma_Validity_Checks               =>\n          null;\n \n       --------------------"}]}