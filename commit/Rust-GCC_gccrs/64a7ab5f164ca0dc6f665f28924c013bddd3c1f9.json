{"sha": "64a7ab5f164ca0dc6f665f28924c013bddd3c1f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRhN2FiNWYxNjRjYTBkYzZmNjY1ZjI4OTI0YzAxM2JkZGQzYzFmOQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-07-17T17:09:39Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-07-17T17:09:39Z"}, "message": "tree-chrec.c (avoid_arithmetics_in_type_p): New.\n\n\t* tree-chrec.c (avoid_arithmetics_in_type_p): New.\n\t(convert_affine_scev, chrec_convert_aggressive): Use\n\tavoid_arithmetics_in_type_p.  Do not check for the subtypes\n\tseparately.\n\nFrom-SVN: r115528", "tree": {"sha": "2032ba2e06db5aa8274553edc0cc5c99f9c06659", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2032ba2e06db5aa8274553edc0cc5c99f9c06659"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64a7ab5f164ca0dc6f665f28924c013bddd3c1f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64a7ab5f164ca0dc6f665f28924c013bddd3c1f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64a7ab5f164ca0dc6f665f28924c013bddd3c1f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64a7ab5f164ca0dc6f665f28924c013bddd3c1f9/comments", "author": null, "committer": null, "parents": [{"sha": "9fbe658520a6ee5527f85d0f1e6ff900bf32f988", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fbe658520a6ee5527f85d0f1e6ff900bf32f988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fbe658520a6ee5527f85d0f1e6ff900bf32f988"}], "stats": {"total": 52, "additions": 31, "deletions": 21}, "files": [{"sha": "c9a46c00c0d7bc39dcea6f8d6df6b1c3f12e6e0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64a7ab5f164ca0dc6f665f28924c013bddd3c1f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64a7ab5f164ca0dc6f665f28924c013bddd3c1f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64a7ab5f164ca0dc6f665f28924c013bddd3c1f9", "patch": "@@ -1,3 +1,10 @@\n+2006-07-17  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-chrec.c (avoid_arithmetics_in_type_p): New.\n+\t(convert_affine_scev, chrec_convert_aggressive): Use\n+\tavoid_arithmetics_in_type_p.  Do not check for the subtypes\n+\tseparately.\n+\n 2006-07-17  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR middle-end/28403"}, {"sha": "f9b804e6177487b1194461d4ca61c6a9c0e889ff", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64a7ab5f164ca0dc6f665f28924c013bddd3c1f9/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64a7ab5f164ca0dc6f665f28924c013bddd3c1f9/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=64a7ab5f164ca0dc6f665f28924c013bddd3c1f9", "patch": "@@ -1096,6 +1096,21 @@ nb_vars_in_chrec (tree chrec)\n     }\n }\n \n+/* Returns true if TYPE is a type in that we cannot directly perform\n+   arithmetics, even though it is a scalar type.  */\n+\n+static bool\n+avoid_arithmetics_in_type_p (tree type)\n+{\n+  /* Ada frontend uses subtypes -- an arithmetic cannot be directly performed\n+     in the subtype, but a base type must be used, and the result then can\n+     be casted to the subtype.  */\n+  if (TREE_CODE (type) == INTEGER_TYPE && TREE_TYPE (type) != NULL_TREE)\n+    return true;\n+\n+  return false;\n+}\n+\n static tree chrec_convert_1 (tree, tree, tree, bool);\n \n /* Converts BASE and STEP of affine scev to TYPE.  LOOP is the loop whose iv\n@@ -1116,6 +1131,10 @@ convert_affine_scev (struct loop *loop, tree type,\n   bool must_check_src_overflow, must_check_rslt_overflow;\n   tree new_base, new_step;\n \n+  /* If we cannot perform arithmetic in TYPE, avoid creating an scev.  */\n+  if (avoid_arithmetics_in_type_p (type))\n+    return false;\n+\n   /* In general,\n      (TYPE) (BASE + STEP * i) = (TYPE) BASE + (TYPE -- sign extend) STEP * i,\n      but we must check some assumptions.\n@@ -1305,6 +1324,10 @@ chrec_convert_aggressive (tree type, tree chrec)\n   if (TYPE_PRECISION (type) > TYPE_PRECISION (inner_type))\n     return NULL_TREE;\n \n+  /* If we cannot perform arithmetic in TYPE, avoid creating an scev.  */\n+  if (avoid_arithmetics_in_type_p (type))\n+    return false;\n+\n   left = CHREC_LEFT (chrec);\n   right = CHREC_RIGHT (chrec);\n   lc = chrec_convert_aggressive (type, left);\n@@ -1313,27 +1336,7 @@ chrec_convert_aggressive (tree type, tree chrec)\n   rc = chrec_convert_aggressive (type, right);\n   if (!rc)\n     rc = chrec_convert (type, right, NULL_TREE);\n-\n-  /* Ada creates sub-types where TYPE_MIN_VALUE/TYPE_MAX_VALUE do not\n-     cover the entire range of values allowed by TYPE_PRECISION.\n-\n-     We do not want to optimize away conversions to such types.  Long\n-     term I'd rather see the Ada front-end fixed.  */\n-  if (INTEGRAL_TYPE_P (type))\n-    {\n-      tree t;\n-\n-      t = upper_bound_in_type (type, inner_type);\n-      if (! TYPE_MAX_VALUE (type)\n-\t  || ! operand_equal_p (TYPE_MAX_VALUE (type), t, 0))\n-\treturn NULL_TREE;\n-\n-      t = lower_bound_in_type (type, inner_type);\n-      if (! TYPE_MIN_VALUE (type)\n-\t  || ! operand_equal_p (TYPE_MIN_VALUE (type), t, 0))\n-\treturn NULL_TREE;\n-    }\n-  \n+ \n   return build_polynomial_chrec (CHREC_VARIABLE (chrec), lc, rc);\n }\n "}]}