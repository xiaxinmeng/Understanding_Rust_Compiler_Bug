{"sha": "4005b96a703618d1731aeda11f7cef8bacce2fc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAwNWI5NmE3MDM2MThkMTczMWFlZGExMWY3Y2VmOGJhY2NlMmZjMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-01-21T15:47:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-01-21T15:47:49Z"}, "message": "re PR target/64669 (aarch64-linux profiledbootstrap failure)\n\nPR target/64669\n\n * ccmp.c (used_in_cond_stmt_p): Remove.\n (expand_ccmp_expr): Don't use it.\n\nFrom-SVN: r219951", "tree": {"sha": "62b12d022d86e21d5d3cc6b6d10dd4d31dd8afe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62b12d022d86e21d5d3cc6b6d10dd4d31dd8afe3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4005b96a703618d1731aeda11f7cef8bacce2fc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4005b96a703618d1731aeda11f7cef8bacce2fc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4005b96a703618d1731aeda11f7cef8bacce2fc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4005b96a703618d1731aeda11f7cef8bacce2fc1/comments", "author": null, "committer": null, "parents": [{"sha": "6fdbf71325d6165b75914241eb42c5f647b35723", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fdbf71325d6165b75914241eb42c5f647b35723", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fdbf71325d6165b75914241eb42c5f647b35723"}], "stats": {"total": 110, "additions": 71, "deletions": 39}, "files": [{"sha": "3f1dda4188d891d8360753d71112a4bb06855fd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4005b96a703618d1731aeda11f7cef8bacce2fc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4005b96a703618d1731aeda11f7cef8bacce2fc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4005b96a703618d1731aeda11f7cef8bacce2fc1", "patch": "@@ -1,3 +1,9 @@\n+2015-01-21  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/64669\n+\t* ccmp.c (used_in_cond_stmt_p): Remove.\n+\t(expand_ccmp_expr): Don't use it.\n+\n 2015-01-21  Nick Clifton  <nickc@redhat.com>\n \n \t* config/rl78/rl78.c (rl78_calculate_death_notes): Look inside"}, {"sha": "5d1755402d1cc74313fbada24e7e4821a7ad616c", "filename": "gcc/ccmp.c", "status": "modified", "additions": 2, "deletions": 39, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4005b96a703618d1731aeda11f7cef8bacce2fc1/gcc%2Fccmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4005b96a703618d1731aeda11f7cef8bacce2fc1/gcc%2Fccmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fccmp.c?ref=4005b96a703618d1731aeda11f7cef8bacce2fc1", "patch": "@@ -90,9 +90,8 @@ along with GCC; see the file COPYING3.  If not see\n \t - gen_ccmp_first expands the first compare in CCMP.\n \t - gen_ccmp_next expands the following compares.\n \n-     * If the final result is not used in a COND_EXPR (checked by function\n-       used_in_cond_stmt_p), it calls cstorecc4 pattern to store the CC to a\n-       general register.\n+     * We use cstorecc4 pattern to convert the CCmode intermediate to\n+       the integer mode result that expand_normal is expecting.\n \n    Since the operands of the later compares might clobber CC reg, we do not\n    emit the insns during expand.  We keep the insn sequences in two seq\n@@ -156,31 +155,6 @@ ccmp_candidate_p (gimple g)\n   return false;\n }\n \n-/* Check whether EXP is used in a GIMPLE_COND statement or not.  */\n-static bool\n-used_in_cond_stmt_p (tree exp)\n-{\n-  bool expand_cond = false;\n-  imm_use_iterator ui;\n-  gimple use_stmt;\n-  FOR_EACH_IMM_USE_STMT (use_stmt, ui, exp)\n-    if (gimple_code (use_stmt) == GIMPLE_COND)\n-      {\n-\ttree op1 = gimple_cond_rhs (use_stmt);\n-\tif (integer_zerop (op1))\n-\t  expand_cond = true;\n-\tBREAK_FROM_IMM_USE_STMT (ui);\n-      }\n-    else if (gimple_code (use_stmt) == GIMPLE_ASSIGN\n-\t     && gimple_expr_code (use_stmt) == COND_EXPR)\n-      {\n-\tif (gimple_assign_rhs1 (use_stmt) == exp)\n-\t  expand_cond = true;\n-      }\n-\n-  return expand_cond;\n-}\n-\n /* PREV is the CC flag from precvious compares.  The function expands the\n    next compare based on G which ops previous compare with CODE.\n    PREP_SEQ returns all insns to prepare opearands for compare.\n@@ -301,20 +275,9 @@ expand_ccmp_expr (gimple g)\n       enum machine_mode cc_mode = CCmode;\n       tree lhs = gimple_assign_lhs (g);\n \n-      /* TMP should be CC.  If it is used in a GIMPLE_COND, just return it.\n-\t Note: Target needs to define \"cbranchcc4\".  */\n-      if (used_in_cond_stmt_p (lhs))\n-\t{\n-\t  emit_insn (prep_seq);\n-\t  emit_insn (gen_seq);\n-\t  return tmp;\n-\t}\n-\n #ifdef SELECT_CC_MODE\n       cc_mode = SELECT_CC_MODE (NE, tmp, const0_rtx);\n #endif\n-      /* If TMP is not used in a GIMPLE_COND, store it with a csctorecc4_optab.\n-\t Note: Target needs to define \"cstorecc4\".  */\n       icode = optab_handler (cstore_optab, cc_mode);\n       if (icode != CODE_FOR_nothing)\n \t{"}, {"sha": "b207739e6d387f1dc64369c6ac8b22b1d1bb2b02", "filename": "gcc/testsuite/g++.dg/torture/pr64669.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4005b96a703618d1731aeda11f7cef8bacce2fc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64669.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4005b96a703618d1731aeda11f7cef8bacce2fc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64669.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64669.C?ref=4005b96a703618d1731aeda11f7cef8bacce2fc1", "patch": "@@ -0,0 +1,63 @@\n+typedef unsigned int source_location;\n+typedef source_location location_t;\n+extern void error_at (location_t, const char *, ...)\n+  __attribute__ ((__format__ (__gcc_tdiag__, 2, 3)))\n+  __attribute__ ((__nonnull__ (2)));\n+\n+class Lex\n+{\n+  static int fetch_char (const char *str, unsigned int *value);\n+  location_t location () const;\n+  const char *advance_one_utf8_char (const char *, unsigned int *, bool *);\n+  const char *advance_one_char (const char *, bool, unsigned int *, bool *);\n+  int lineoff_;\n+  int lineno_;\n+};\n+\n+int\n+Lex::fetch_char (const char *p, unsigned int *value)\n+{\n+  unsigned char c = *p;\n+  if (c <= 0x7f)\n+    {\n+      return 1;\n+    }\n+  else if ((c & 0xe0) == 0xc0 && (p[1] & 0xc0) == 0x80)\n+    {\n+      *value = (((c & 0x1f) << 6) + (p[1] & 0x3f));\n+    }\n+  {\n+    *value = (((c & 0xf) << 12) + (p[2] & 0x3f));\n+  }\n+}\n+\n+const char *\n+Lex::advance_one_utf8_char (const char *p, unsigned int *value,\n+\t\t\t    bool * issued_error)\n+{\n+  *issued_error = false;\n+  if (*p == '\\0')\n+    {\n+      *issued_error = true;\n+      return p + 1;\n+    }\n+  int adv = Lex::fetch_char (p, value);\n+  if (*value == 0xfeff && (this->lineno_ != 1 || this->lineoff_ != 0))\n+    {\n+      *issued_error = true;\n+    }\n+  return p + adv;\n+}\n+\n+const char *\n+Lex::advance_one_char (const char *p, bool is_single_quote,\n+\t\t       unsigned int *value, bool * is_character)\n+{\n+  {\n+    bool issued_error;\n+    const char *ret = this->advance_one_utf8_char (p, value, &issued_error);\n+    if (is_single_quote\n+\t&& (*value == '\\'' || *value == '\\n') && !issued_error)\n+      error_at (this->location (), \"invalid character literal\");\n+  }\n+}"}]}