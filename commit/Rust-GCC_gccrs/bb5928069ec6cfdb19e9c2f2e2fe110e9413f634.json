{"sha": "bb5928069ec6cfdb19e9c2f2e2fe110e9413f634", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI1OTI4MDY5ZWM2Y2ZkYjE5ZTljMmYyZTJmZTExMGU5NDEzZjYzNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-07-16T09:00:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-07-16T09:00:09Z"}, "message": "mips.c (get_float_compare_codes): Delete.\n\n\t* config/mips/mips.c (get_float_compare_codes): Delete.\n\t(mips_emit_compare): New function, mostly extracted from\n\tget_float_compare_codes and gen_conditional_branch.\n\t(gen_conditional_branch, gen_conditional_move): Use it.\n\nFrom-SVN: r84813", "tree": {"sha": "308a6bf7c556869c5bd6e3b0dd6b8a1d329a0323", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/308a6bf7c556869c5bd6e3b0dd6b8a1d329a0323"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb5928069ec6cfdb19e9c2f2e2fe110e9413f634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb5928069ec6cfdb19e9c2f2e2fe110e9413f634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb5928069ec6cfdb19e9c2f2e2fe110e9413f634", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb5928069ec6cfdb19e9c2f2e2fe110e9413f634/comments", "author": null, "committer": null, "parents": [{"sha": "3758425f53961334de12516f1ea598d4ee491ed6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3758425f53961334de12516f1ea598d4ee491ed6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3758425f53961334de12516f1ea598d4ee491ed6"}], "stats": {"total": 266, "additions": 102, "deletions": 164}, "files": [{"sha": "80e703f6bc34da59833ab8c635388c174c3edc16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb5928069ec6cfdb19e9c2f2e2fe110e9413f634/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb5928069ec6cfdb19e9c2f2e2fe110e9413f634/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb5928069ec6cfdb19e9c2f2e2fe110e9413f634", "patch": "@@ -1,3 +1,10 @@\n+2004-07-16  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (get_float_compare_codes): Delete.\n+\t(mips_emit_compare): New function, mostly extracted from\n+\tget_float_compare_codes and gen_conditional_branch.\n+\t(gen_conditional_branch, gen_conditional_move): Use it.\n+\n 2004-07-16  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* genautomata.c (add_vect): Speedup by using integers as"}, {"sha": "c3c7fa36b15dd3be38545e622824fe15cf85c02c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 95, "deletions": 164, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb5928069ec6cfdb19e9c2f2e2fe110e9413f634/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb5928069ec6cfdb19e9c2f2e2fe110e9413f634/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=bb5928069ec6cfdb19e9c2f2e2fe110e9413f634", "patch": "@@ -175,8 +175,7 @@ static void mips_legitimize_const_move (enum machine_mode, rtx, rtx);\n static int m16_check_op (rtx, int, int, int);\n static bool mips_rtx_costs (rtx, int, int, int *);\n static int mips_address_cost (rtx);\n-static void get_float_compare_codes (enum rtx_code, enum rtx_code *,\n-\t\t\t\t     enum rtx_code *);\n+static void mips_emit_compare (enum rtx_code *, rtx *, rtx *, bool);\n static void mips_load_call_address (rtx, rtx, int);\n static bool mips_function_ok_for_sibcall (tree, tree);\n static void mips_block_move_straight (rtx, rtx, HOST_WIDE_INT);\n@@ -2784,6 +2783,87 @@ mips_zero_if_equal (rtx cmp0, rtx cmp1)\n \t\t       cmp0, cmp1, 0, 0, OPTAB_DIRECT);\n }\n \n+/* Convert a comparison into something that can be used in a branch or\n+   conditional move.  cmp_operands[0] and cmp_operands[1] are the values\n+   being compared and *CODE is the code used to compare them.\n+\n+   Update *CODE, *OP0 and *OP1 so that they describe the final comparison.\n+   If NEED_EQ_NE_P, then only EQ/NE comparisons against zero are possible,\n+   otherwise any standard branch condition can be used.  The standard branch\n+   conditions are:\n+\n+      - EQ/NE between two registers.\n+      - any comparison between a register and zero.  */\n+\n+static void\n+mips_emit_compare (enum rtx_code *code, rtx *op0, rtx *op1, bool need_eq_ne_p)\n+{\n+  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) == MODE_INT)\n+    {\n+      if (!need_eq_ne_p && cmp_operands[1] == const0_rtx)\n+\t{\n+\t  *op0 = cmp_operands[0];\n+\t  *op1 = cmp_operands[1];\n+\t}\n+      else if (*code == EQ || *code == NE)\n+\t{\n+\t  if (need_eq_ne_p)\n+\t    {\n+\t      *op0 = mips_zero_if_equal (cmp_operands[0], cmp_operands[1]);\n+\t      *op1 = const0_rtx;\n+\t    }\n+\t  else\n+\t    {\n+\t      *op0 = cmp_operands[0];\n+\t      *op1 = force_reg (GET_MODE (*op0), cmp_operands[1]);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* The comparison needs a separate scc instruction.  Store the\n+\t     result of the scc in *OP0 and compare it against zero.  */\n+\t  bool invert = false;\n+\t  *op0 = gen_reg_rtx (GET_MODE (cmp_operands[0]));\n+\t  *op1 = const0_rtx;\n+\t  mips_emit_int_relational (*code, &invert, *op0,\n+\t\t\t\t    cmp_operands[0], cmp_operands[1]);\n+\t  *code = (invert ? EQ : NE);\n+\t}\n+    }\n+  else\n+    {\n+      enum rtx_code cmp_code;\n+\n+      /* Floating-point tests use a separate c.cond.fmt comparison to\n+\t set a condition code register.  The branch or conditional move\n+\t will then compare that register against zero.\n+\n+\t Set CMP_CODE to the code of the comparison instruction and\n+\t *CODE to the code that the branch or move should use.  */\n+      switch (*code)\n+\t{\n+\tcase NE:\n+\tcase UNGE:\n+\tcase UNGT:\n+\tcase LTGT:\n+\tcase ORDERED:\n+\t  cmp_code = reverse_condition_maybe_unordered (*code);\n+\t  *code = EQ;\n+\t  break;\n+\n+\tdefault:\n+\t  cmp_code = *code;\n+\t  *code = NE;\n+\t  break;\n+\t}\n+      *op0 = (ISA_HAS_8CC\n+\t      ? gen_reg_rtx (CCmode)\n+\t      : gen_rtx_REG (CCmode, FPSW_REGNUM));\n+      *op1 = const0_rtx;\n+      mips_emit_binary (cmp_code, *op0, cmp_operands[0], cmp_operands[1]);\n+    }\n+}\n+\f\n /* Try comparing cmp_operands[0] and cmp_operands[1] using rtl code CODE.\n    Store the result in TARGET and return true if successful.\n \n@@ -2806,100 +2886,20 @@ mips_emit_scc (enum rtx_code code, rtx target)\n \t\t\t      cmp_operands[0], cmp_operands[1]);\n   return true;\n }\n-\f\n-/* Work out how to check a floating-point condition.  We need a\n-   separate comparison instruction (C.cond.fmt), followed by a\n-   branch or conditional move.  Given that IN_CODE is the\n-   required condition, set *CMP_CODE to the C.cond.fmt code\n-   and *action_code to the branch or move code.  */\n-\n-static void\n-get_float_compare_codes (enum rtx_code in_code, enum rtx_code *cmp_code,\n-\t\t\t enum rtx_code *action_code)\n-{\n-  switch (in_code)\n-    {\n-    case NE:\n-    case UNGE:\n-    case UNGT:\n-    case LTGT:\n-    case ORDERED:\n-      *cmp_code = reverse_condition_maybe_unordered (in_code);\n-      *action_code = EQ;\n-      break;\n-\n-    default:\n-      *cmp_code = in_code;\n-      *action_code = NE;\n-      break;\n-    }\n-}\n \n /* Emit the common code for doing conditional branches.\n    operand[0] is the label to jump to.\n    The comparison operands are saved away by cmp{si,di,sf,df}.  */\n \n void\n-gen_conditional_branch (rtx *operands, enum rtx_code test_code)\n+gen_conditional_branch (rtx *operands, enum rtx_code code)\n {\n-  rtx cmp0, cmp1, target;\n-  enum machine_mode mode;\n-  enum rtx_code cmp_code;\n-\n-  switch (GET_MODE (cmp_operands[0]))\n-    {\n-    case SImode:\n-    case DImode:\n-      mode = GET_MODE (cmp_operands[0]);\n-      if (!TARGET_MIPS16 && cmp_operands[1] == const0_rtx)\n-\t{\n-\t  cmp0 = cmp_operands[0];\n-\t  cmp1 = cmp_operands[1];\n-\t}\n-      else if (test_code == EQ || test_code == NE)\n-\t{\n-\t  if (TARGET_MIPS16)\n-\t    {\n-\t      cmp0 = mips_zero_if_equal (cmp_operands[0], cmp_operands[1]);\n-\t      cmp1 = const0_rtx;\n-\t    }\n-\t  else\n-\t    {\n-\t      cmp0 = cmp_operands[0];\n-\t      cmp1 = force_reg (mode, cmp_operands[1]);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  bool invert = false;\n-\t  cmp0 = gen_reg_rtx (mode);\n-\t  cmp1 = const0_rtx;\n-\t  mips_emit_int_relational (test_code, &invert, cmp0,\n-\t\t\t\t    cmp_operands[0], cmp_operands[1]);\n-\t  test_code = (invert ? EQ : NE);\n-\t}\n-      break;\n-\n-    case SFmode:\n-    case DFmode:\n-      mode = CCmode;\n-      if (!ISA_HAS_8CC)\n-\tcmp0 = gen_rtx_REG (mode, FPSW_REGNUM);\n-      else\n-\tcmp0 = gen_reg_rtx (mode);\n-      cmp1 = const0_rtx;\n+  rtx op0, op1, target;\n \n-      get_float_compare_codes (test_code, &cmp_code, &test_code);\n-      mips_emit_binary (cmp_code, cmp0, cmp_operands[0], cmp_operands[1]);\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  /* Generate the branch.  */\n+  mips_emit_compare (&code, &op0, &op1, TARGET_MIPS16);\n   target = gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t\t gen_rtx_fmt_ee (test_code, mode, cmp0, cmp1),\n+\t\t\t\t gen_rtx_fmt_ee (code, GET_MODE (op0),\n+\t\t\t\t\t\t op0, op1),\n \t\t\t\t gen_rtx_LABEL_REF (VOIDmode, operands[0]),\n \t\t\t\t pc_rtx);\n   emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, target));\n@@ -2911,84 +2911,15 @@ gen_conditional_branch (rtx *operands, enum rtx_code test_code)\n void\n gen_conditional_move (rtx *operands)\n {\n-  rtx op0 = cmp_operands[0];\n-  rtx op1 = cmp_operands[1];\n-  enum machine_mode mode = GET_MODE (cmp_operands[0]);\n-  enum rtx_code cmp_code = GET_CODE (operands[1]);\n-  enum rtx_code move_code = NE;\n-  enum machine_mode op_mode = GET_MODE (operands[0]);\n-  enum machine_mode cmp_mode;\n-  rtx cmp_reg;\n-\n-  if (GET_MODE_CLASS (mode) != MODE_FLOAT)\n-    {\n-      switch (cmp_code)\n-\t{\n-\tcase EQ:\n-\t  cmp_code = XOR;\n-\t  move_code = EQ;\n-\t  break;\n-\tcase NE:\n-\t  cmp_code = XOR;\n-\t  break;\n-\tcase LT:\n-\t  break;\n-\tcase GE:\n-\t  cmp_code = LT;\n-\t  move_code = EQ;\n-\t  break;\n-\tcase GT:\n-\t  cmp_code = LT;\n-\t  op0 = force_reg (mode, cmp_operands[1]);\n-\t  op1 = cmp_operands[0];\n-\t  break;\n-\tcase LE:\n-\t  cmp_code = LT;\n-\t  op0 = force_reg (mode, cmp_operands[1]);\n-\t  op1 = cmp_operands[0];\n-\t  move_code = EQ;\n-\t  break;\n-\tcase LTU:\n-\t  break;\n-\tcase GEU:\n-\t  cmp_code = LTU;\n-\t  move_code = EQ;\n-\t  break;\n-\tcase GTU:\n-\t  cmp_code = LTU;\n-\t  op0 = force_reg (mode, cmp_operands[1]);\n-\t  op1 = cmp_operands[0];\n-\t  break;\n-\tcase LEU:\n-\t  cmp_code = LTU;\n-\t  op0 = force_reg (mode, cmp_operands[1]);\n-\t  op1 = cmp_operands[0];\n-\t  move_code = EQ;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-  else\n-    get_float_compare_codes (cmp_code, &cmp_code, &move_code);\n-\n-  if (mode == SImode || mode == DImode)\n-    cmp_mode = mode;\n-  else if (mode == SFmode || mode == DFmode)\n-    cmp_mode = CCmode;\n-  else\n-    abort ();\n-\n-  cmp_reg = gen_reg_rtx (cmp_mode);\n-  emit_insn (gen_rtx_SET (cmp_mode, cmp_reg,\n-\t\t\t  gen_rtx_fmt_ee (cmp_code, cmp_mode, op0, op1)));\n+  enum rtx_code code;\n+  rtx op0, op1;\n \n-  emit_insn (gen_rtx_SET (op_mode, operands[0],\n-\t\t\t  gen_rtx_IF_THEN_ELSE (op_mode,\n-\t\t\t\t\t\tgen_rtx_fmt_ee (move_code,\n-\t\t\t\t\t\t\t\tVOIDmode,\n-\t\t\t\t\t\t\t\tcmp_reg,\n-\t\t\t\t\t\t\t\tconst0_rtx),\n+  code = GET_CODE (operands[1]);\n+  mips_emit_compare (&code, &op0, &op1, true);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+\t\t\t\t\t\tgen_rtx_fmt_ee (code, VOIDmode,\n+\t\t\t\t\t\t\t\top0, op1),\n \t\t\t\t\t\toperands[2], operands[3])));\n }\n "}]}