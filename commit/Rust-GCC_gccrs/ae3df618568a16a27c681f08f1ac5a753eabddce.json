{"sha": "ae3df618568a16a27c681f08f1ac5a753eabddce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUzZGY2MTg1NjhhMTZhMjdjNjgxZjA4ZjFhYzVhNzUzZWFiZGRjZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-05-08T21:22:21Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-08T21:22:21Z"}, "message": "PR tree-optimization/14841, tree-optimization/15838\n\ngcc/\n\tPR tree-optimization/14841, tree-optimization/15838\n\t* tree-ssa-ccp.c (fold_const_aggregate_ref): New.\n\t(evaluate_stmt): Call it.\n\ntestsuite/\n\tPR tree-optimization/14841, tree-optimization/15838\n\t* gcc.dg/tree-ssa/pr14841.c: New.\n\nCo-Authored-By: Kazu Hirata <kazu@cs.umass.edu>\n\nFrom-SVN: r99410", "tree": {"sha": "751ebfba0a9f270074f551246f3c4caa2f64e963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/751ebfba0a9f270074f551246f3c4caa2f64e963"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae3df618568a16a27c681f08f1ac5a753eabddce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae3df618568a16a27c681f08f1ac5a753eabddce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae3df618568a16a27c681f08f1ac5a753eabddce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae3df618568a16a27c681f08f1ac5a753eabddce/comments", "author": null, "committer": null, "parents": [{"sha": "0f666d6e50097890fce4c60ca44c8acd2758087c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f666d6e50097890fce4c60ca44c8acd2758087c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f666d6e50097890fce4c60ca44c8acd2758087c"}], "stats": {"total": 169, "additions": 165, "deletions": 4}, "files": [{"sha": "cc33cabace67146781140551d35afa21d8124fbf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae3df618568a16a27c681f08f1ac5a753eabddce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae3df618568a16a27c681f08f1ac5a753eabddce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae3df618568a16a27c681f08f1ac5a753eabddce", "patch": "@@ -1,3 +1,10 @@\n+2005-05-08  Steven Bosscher  <stevenb@suse.de>\n+\t    Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\tPR tree-optimization/14841, tree-optimization/15838\n+\t* tree-ssa-ccp.c (fold_const_aggregate_ref): New.\n+\t(evaluate_stmt): Call it.\n+\n 2005-05-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/ia64/ia64.c (ia64_override_options): Don't set"}, {"sha": "de723704b57d94f25c91dff2df4f67120cf52ccc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae3df618568a16a27c681f08f1ac5a753eabddce/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae3df618568a16a27c681f08f1ac5a753eabddce/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ae3df618568a16a27c681f08f1ac5a753eabddce", "patch": "@@ -2078,7 +2078,7 @@ tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n    $(DIAGNOSTIC_H) errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(BASIC_BLOCK_H) tree-pass.h langhooks.h \\\n-   tree-ssa-propagate.h $(FLAGS_H)\n+   tree-ssa-propagate.h $(FLAGS_H) $(TARGET_H)\n tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) errors.h $(TREE_H) $(RTL_H) \\\n     $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) tree-inline.h \\\n     $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_GIMPLE_H) \\"}, {"sha": "4acc6ce3fc8bf16a97f0a9b3e586160cab149c7e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr14841.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae3df618568a16a27c681f08f1ac5a753eabddce/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14841.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae3df618568a16a27c681f08f1ac5a753eabddce/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14841.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14841.c?ref=ae3df618568a16a27c681f08f1ac5a753eabddce", "patch": "@@ -0,0 +1,29 @@\n+/* PR tree-optimization/14841\n+   Make sure that we can fold a possible nested reference into a\n+   constant aggregate.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-store_ccp-details\" } */\n+\n+struct car {\n+  int speed;\n+  int tire_pressure[4];\n+};\n+\n+const struct car cars[] = {\n+  { 75, { 10, 20, 30, 40 } },\n+  { 35, { 12, 34, 56, 78 } },\n+  { 40, { 19, 28, 37, 46 } }\n+};\n+\n+extern void link_error (void);\n+\n+void\n+foo (void)\n+{\n+  if (cars[1].tire_pressure[2] != 56)\n+    link_error ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"with if \\\\(0\\\\)\" 1 \"store_ccp\"} } */\n+/* { dg-final { cleanup-tree-dump \"store_ccp\" } } */"}, {"sha": "58b8c2c01bef1658c9f45ec4f96c96b1c5f048c5", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 128, "deletions": 3, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae3df618568a16a27c681f08f1ac5a753eabddce/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae3df618568a16a27c681f08f1ac5a753eabddce/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=ae3df618568a16a27c681f08f1ac5a753eabddce", "patch": "@@ -209,6 +209,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-pass.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"langhooks.h\"\n+#include \"target.h\"\n \n \n /* Possible lattice values.  */\n@@ -970,6 +971,127 @@ ccp_fold (tree stmt)\n }\n \n \n+/* Return the tree representing the element referenced by T if T is an\n+   ARRAY_REF or COMPONENT_REF into constant aggregates.  Return\n+   NULL_TREE otherwise.  */\n+\n+static tree\n+fold_const_aggregate_ref (tree t)\n+{\n+  prop_value_t *value;\n+  tree base, ctor, idx, field, elt;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case ARRAY_REF:\n+      /* Get a CONSTRUCTOR.  If BASE is a VAR_DECL, get its\n+\t DECL_INITIAL.  If BASE is a nested reference into another\n+\t ARRAY_REF or COMPONENT_REF, make a recursive call to resolve\n+\t the inner reference.  */\n+      base = TREE_OPERAND (t, 0);\n+      switch (TREE_CODE (base))\n+\t{\n+\tcase VAR_DECL:\n+\t  if (!TREE_READONLY (base)\n+\t      || TREE_CODE (TREE_TYPE (base)) != ARRAY_TYPE\n+\t      || !targetm.binds_local_p (base))\n+\t    return NULL_TREE;\n+\n+\t  ctor = DECL_INITIAL (base);\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase COMPONENT_REF:\n+\t  ctor = fold_const_aggregate_ref (base);\n+\t  break;\n+\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (ctor == NULL_TREE\n+\t  || TREE_CODE (ctor) != CONSTRUCTOR\n+\t  || !TREE_STATIC (ctor))\n+\treturn NULL_TREE;\n+\n+      /* Get the index.  If we have an SSA_NAME, try to resolve it\n+\t with the current lattice value for the SSA_NAME.  */\n+      idx = TREE_OPERAND (t, 1);\n+      switch (TREE_CODE (idx))\n+\t{\n+\tcase SSA_NAME:\n+\t  if ((value = get_value (idx, true))\n+\t      && value->lattice_val == CONSTANT\n+\t      && TREE_CODE (value->value) == INTEGER_CST)\n+\t    idx = value->value;\n+\t  else\n+\t    return NULL_TREE;\n+\t  break;\n+\n+\tcase INTEGER_CST:\n+\t  break;\n+\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+\n+      /* Whoo-hoo!  I'll fold ya baby.  Yeah!  */\n+      for (elt = CONSTRUCTOR_ELTS (ctor);\n+\t   (elt && !tree_int_cst_equal (TREE_PURPOSE (elt), idx));\n+\t   elt = TREE_CHAIN (elt))\n+\t;\n+\n+      if (elt)\n+\treturn TREE_VALUE (elt);\n+      break;\n+\n+    case COMPONENT_REF:\n+      /* Get a CONSTRUCTOR.  If BASE is a VAR_DECL, get its\n+\t DECL_INITIAL.  If BASE is a nested reference into another\n+\t ARRAY_REF or COMPONENT_REF, make a recursive call to resolve\n+\t the inner reference.  */\n+      base = TREE_OPERAND (t, 0);\n+      switch (TREE_CODE (base))\n+\t{\n+\tcase VAR_DECL:\n+\t  if (!TREE_READONLY (base)\n+\t      || TREE_CODE (TREE_TYPE (base)) != RECORD_TYPE\n+\t      || !targetm.binds_local_p (base))\n+\t    return NULL_TREE;\n+\n+\t  ctor = DECL_INITIAL (base);\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase COMPONENT_REF:\n+\t  ctor = fold_const_aggregate_ref (base);\n+\t  break;\n+\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (ctor == NULL_TREE\n+\t  || TREE_CODE (ctor) != CONSTRUCTOR\n+\t  || !TREE_STATIC (ctor))\n+\treturn NULL_TREE;\n+\n+      field = TREE_OPERAND (t, 1);\n+\n+      for (elt = CONSTRUCTOR_ELTS (ctor); elt; elt = TREE_CHAIN (elt))\n+\tif (TREE_PURPOSE (elt) == field\n+\t    /* FIXME: Handle bit-fields.  */\n+\t    && ! DECL_BIT_FIELD (TREE_PURPOSE (elt)))\n+\t  return TREE_VALUE (elt);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+  \n /* Evaluate statement STMT.  */\n \n static prop_value_t\n@@ -989,10 +1111,13 @@ evaluate_stmt (tree stmt)\n      bother folding the statement.  */\n   else if (likelyvalue == VARYING)\n     simplified = get_rhs (stmt);\n-  /* Otherwise the statement is likely to have an UNDEFINED value and\n-     there will be nothing to do.  */\n+  /* If the statement is an ARRAY_REF or COMPONENT_REF into constant\n+     aggregates, extract the referenced constant.  Otherwise the\n+     statement is likely to have an UNDEFINED value, and there will be\n+     nothing to do.  Note that fold_const_aggregate_ref returns\n+     NULL_TREE if the first case does not match.  */\n   else\n-    simplified = NULL_TREE;\n+    simplified = fold_const_aggregate_ref (get_rhs (stmt));\n \n   if (simplified && is_gimple_min_invariant (simplified))\n     {"}]}