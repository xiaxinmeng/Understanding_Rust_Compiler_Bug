{"sha": "3e8ee849e158dffe379771f62ddc0edb094ddf44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U4ZWU4NDllMTU4ZGZmZTM3OTc3MWY2MmRkYzBlZGIwOTRkZGY0NA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-08-14T08:38:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:38:33Z"}, "message": "exp_attr.adb (Expand_N_Attribute_Reference): Handle case of child unit\n\n2007-08-14  Robert Dewar  <dewar@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Handle case of child unit\n\t(Expand_N_Attribute_Reference): Further unify the handling of the\n\tthree forms of access attributes, using common code now for all three\n\tcases. Add a test for the case of applying an access attribute to\n\tan explicit dereference when the context is an access-to-interface\n\ttype. In that case we need to apply the conversion to the prefix\n\tof the explicit dereference rather than the prefix of the attribute.\n\t(Attribute_Version, UET_Address): Set entity as internal to ensure\n\tproper dg output of implicit importation.\n\t(Expand_Access_To_Type): Removed.\n\t(Expand_N_Attribute_Reference): Merge the code from the three cases\n\tof access attributes, since the processing is largely identical for\n\tthese cases. The substantive fix here is to process the case of a\n\ttype name prefix (current instance case) before handling the case\n\tof interface prefixes.\n\nFrom-SVN: r127416", "tree": {"sha": "3e060f4b84844970e977b3f49ac4cba77c22fa42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e060f4b84844970e977b3f49ac4cba77c22fa42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e8ee849e158dffe379771f62ddc0edb094ddf44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e8ee849e158dffe379771f62ddc0edb094ddf44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e8ee849e158dffe379771f62ddc0edb094ddf44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e8ee849e158dffe379771f62ddc0edb094ddf44/comments", "author": null, "committer": null, "parents": [{"sha": "5d37ba92f667fc076287b111dd3166b8d48012b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d37ba92f667fc076287b111dd3166b8d48012b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d37ba92f667fc076287b111dd3166b8d48012b8"}], "stats": {"total": 281, "additions": 134, "deletions": 147}, "files": [{"sha": "0c637b508af5b6dc50deea792aae7dcd95d80fd9", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 134, "deletions": 147, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e8ee849e158dffe379771f62ddc0edb094ddf44/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e8ee849e158dffe379771f62ddc0edb094ddf44/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=3e8ee849e158dffe379771f62ddc0edb094ddf44", "patch": "@@ -130,10 +130,6 @@ package body Exp_Attr is\n    --  Used for Last, Last, and Length, when the prefix is an array type,\n    --  Obtains the corresponding index subtype.\n \n-   procedure Expand_Access_To_Type (N : Node_Id);\n-   --  A reference to a type within its own scope is resolved to a reference\n-   --  to the current instance of the type in its initialization procedure.\n-\n    procedure Find_Fat_Info\n      (T        : Entity_Id;\n       Fat_Type : out Entity_Id;\n@@ -349,72 +345,6 @@ package body Exp_Attr is\n       Set_Etype (N, Typ);\n    end Expand_Access_To_Protected_Op;\n \n-   ---------------------------\n-   -- Expand_Access_To_Type --\n-   ---------------------------\n-\n-   procedure Expand_Access_To_Type (N : Node_Id) is\n-      Loc    : constant Source_Ptr   := Sloc (N);\n-      Typ    : constant Entity_Id    := Etype (N);\n-      Pref   : constant Node_Id      := Prefix (N);\n-      Par    : Node_Id;\n-      Formal : Entity_Id;\n-\n-   begin\n-      if Is_Entity_Name (Pref)\n-        and then Is_Type (Entity (Pref))\n-      then\n-         --  If the current instance name denotes a task type,\n-         --  then the access attribute is rewritten to be the\n-         --  name of the \"_task\" parameter associated with the\n-         --  task type's task body procedure. An unchecked\n-         --  conversion is applied to ensure a type match in\n-         --  cases of expander-generated calls (e.g., init procs).\n-\n-         if Is_Task_Type (Entity (Pref)) then\n-            Formal :=\n-              First_Entity (Get_Task_Body_Procedure (Entity (Pref)));\n-\n-            while Present (Formal) loop\n-               exit when Chars (Formal) = Name_uTask;\n-               Next_Entity (Formal);\n-            end loop;\n-\n-            pragma Assert (Present (Formal));\n-\n-            Rewrite (N,\n-              Unchecked_Convert_To (Typ, New_Occurrence_Of (Formal, Loc)));\n-            Set_Etype (N, Typ);\n-\n-         --  The expression must appear in a default expression,\n-         --  (which in the initialization procedure is the rhs of\n-         --  an assignment), and not in a discriminant constraint.\n-\n-         else\n-            Par := Parent (N);\n-\n-            while Present (Par) loop\n-               exit when Nkind (Par) = N_Assignment_Statement;\n-\n-               if Nkind (Par) = N_Component_Declaration then\n-                  return;\n-               end if;\n-\n-               Par := Parent (Par);\n-            end loop;\n-\n-            if Present (Par) then\n-               Rewrite (N,\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix => Make_Identifier (Loc, Name_uInit),\n-                   Attribute_Name  => Attribute_Name (N)));\n-\n-               Analyze_And_Resolve (N, Typ);\n-            end if;\n-         end if;\n-      end if;\n-   end Expand_Access_To_Type;\n-\n    --------------------------\n    -- Expand_Fpt_Attribute --\n    --------------------------\n@@ -670,12 +600,88 @@ package body Exp_Attr is\n       -- Access --\n       ------------\n \n-      when Attribute_Access =>\n+      when Attribute_Access              |\n+           Attribute_Unchecked_Access    |\n+           Attribute_Unrestricted_Access =>\n \n          if Is_Access_Protected_Subprogram_Type (Btyp) then\n             Expand_Access_To_Protected_Op (N, Pref, Typ);\n \n-         elsif Ekind (Btyp) = E_General_Access_Type then\n+         --  If the prefix is a type name, this is a reference to the current\n+         --  instance of the type, within its initialization procedure.\n+\n+         elsif Is_Entity_Name (Pref)\n+           and then Is_Type (Entity (Pref))\n+         then\n+            declare\n+               Par    : Node_Id;\n+               Formal : Entity_Id;\n+\n+            begin\n+               --  If the current instance name denotes a task type, then the\n+               --  access attribute is rewritten to be the name of the \"_task\"\n+               --  parameter associated with the task type's task procedure.\n+               --  An unchecked conversion is applied to ensure a type match in\n+               --  cases of expander-generated calls (e.g., init procs).\n+\n+               if Is_Task_Type (Entity (Pref)) then\n+                  Formal :=\n+                    First_Entity (Get_Task_Body_Procedure (Entity (Pref)));\n+                  while Present (Formal) loop\n+                     exit when Chars (Formal) = Name_uTask;\n+                     Next_Entity (Formal);\n+                  end loop;\n+\n+                  pragma Assert (Present (Formal));\n+\n+                  Rewrite (N,\n+                    Unchecked_Convert_To\n+                      (Typ, New_Occurrence_Of (Formal, Loc)));\n+                  Set_Etype (N, Typ);\n+\n+                  return;\n+\n+               --  The expression must appear in a default expression, (which\n+               --  in the initialization procedure is the right-hand side of an\n+               --  assignment), and not in a discriminant constraint.\n+\n+               else\n+                  Par := Parent (N);\n+                  while Present (Par) loop\n+                     exit when Nkind (Par) = N_Assignment_Statement;\n+\n+                     if Nkind (Par) = N_Component_Declaration then\n+                        return;\n+                     end if;\n+\n+                     Par := Parent (Par);\n+                  end loop;\n+\n+                  if Present (Par) then\n+                     Rewrite (N,\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => Make_Identifier (Loc, Name_uInit),\n+                         Attribute_Name  => Attribute_Name (N)));\n+\n+                     Analyze_And_Resolve (N, Typ);\n+                  end if;\n+\n+                  return;\n+               end if;\n+            end;\n+\n+         --  The following handles cases involving interfaces and when the\n+         --  prefix of an access attribute is an explicit dereference. In the\n+         --  case where the access attribute is specifically Attribute_Access,\n+         --  we only do this when the context type is E_General_Access_Type,\n+         --  and not for anonymous access types. It seems that this code should\n+         --  be used for anonymous contexts as well, but that causes various\n+         --  regressions, such as on prefix-notation calls to dispatching\n+         --  operations and back-end errors on access type conversions. ???\n+\n+         elsif Id /= Attribute_Access\n+           or else Ekind (Btyp) = E_General_Access_Type\n+         then\n             declare\n                Ref_Object : constant Node_Id := Get_Referenced_Object (Pref);\n                Parm_Ent   : Entity_Id;\n@@ -686,13 +692,23 @@ package body Exp_Attr is\n                --  access parameter (or a renaming of such a dereference) and\n                --  the context is a general access type (but not an anonymous\n                --  access type), then rewrite the attribute as a conversion of\n-               --  the access parameter to the context access type.  This will\n+               --  the access parameter to the context access type. This will\n                --  result in an accessibility check being performed, if needed.\n \n                --    (X.all'Access => Acc_Type (X))\n \n+               --  Note: Limit the expansion of an attribute applied to a\n+               --  dereference of an access parameter so that it's only done\n+               --  for 'Access. This fixes a problem with 'Unrestricted_Access\n+               --  that leads to errors in the case where the attribute\n+               --  type is access-to-variable and the access parameter is\n+               --  access-to-constant. The conversion is only done to get\n+               --  accessibility checks, so it makes sense to limit it to\n+               --  'Access (and consistent with existing comment).\n+\n                if Nkind (Ref_Object) = N_Explicit_Dereference\n                  and then Is_Entity_Name (Prefix (Ref_Object))\n+                 and then Id = Attribute_Access\n                then\n                   Parm_Ent := Entity (Prefix (Ref_Object));\n \n@@ -701,29 +717,45 @@ package body Exp_Attr is\n                     and then Present (Extra_Accessibility (Parm_Ent))\n                   then\n                      Conversion :=\n-                        Convert_To (Typ, New_Copy_Tree (Prefix (Ref_Object)));\n+                       Convert_To (Typ, New_Copy_Tree (Prefix (Ref_Object)));\n \n                      Rewrite (N, Conversion);\n                      Analyze_And_Resolve (N, Typ);\n+\n+                     return;\n                   end if;\n+               end if;\n \n                --  Ada 2005 (AI-251): If the designated type is an interface,\n-               --  then rewrite the referenced object as a conversion to force\n+               --  then rewrite the referenced object as a conversion, to force\n                --  the displacement of the pointer to the secondary dispatch\n                --  table.\n \n-               elsif Is_Interface (Directly_Designated_Type (Btyp)) then\n-                  Conversion := Convert_To (Typ, New_Copy_Tree (Ref_Object));\n+               if Is_Interface (Directly_Designated_Type (Btyp)) then\n+\n+                  --  When the object is an explicit dereference, just convert\n+                  --  the dereference's prefix.\n+\n+                  if Nkind (Ref_Object) = N_Explicit_Dereference then\n+                     Conversion :=\n+                       Convert_To (Typ, New_Copy_Tree (Prefix (Ref_Object)));\n+\n+                  --  It seems rather bizarre that we generate a conversion of\n+                  --  a tagged object to an access type, since such conversions\n+                  --  are not normally permitted, but Expand_N_Type_Conversion\n+                  --  (actually Expand_Interface_Conversion) is designed to\n+                  --  handle them in the interface case. Do we really want to\n+                  --  create such odd conversions???\n+\n+                  else\n+                     Conversion :=\n+                       Convert_To (Typ, New_Copy_Tree (Ref_Object));\n+                  end if;\n+\n                   Rewrite (N, Conversion);\n                   Analyze_And_Resolve (N, Typ);\n                end if;\n             end;\n-\n-         --  If the prefix is a type name, this is a reference to the current\n-         --  instance of the type, within its initialization procedure.\n-\n-         else\n-            Expand_Access_To_Type (N);\n          end if;\n \n       --------------\n@@ -744,10 +776,9 @@ package body Exp_Attr is\n          Task_Proc : Entity_Id;\n \n       begin\n-         --  If the prefix is a task or a task type, the useful address\n-         --  is that of the procedure for the task body, i.e. the actual\n-         --  program unit. We replace the original entity with that of\n-         --  the procedure.\n+         --  If the prefix is a task or a task type, the useful address is that\n+         --  of the procedure for the task body, i.e. the actual program unit.\n+         --  We replace the original entity with that of the procedure.\n \n          if Is_Entity_Name (Pref)\n            and then Is_Task_Type (Entity (Pref))\n@@ -1013,23 +1044,23 @@ package body Exp_Attr is\n       when Attribute_Body_Version | Attribute_Version => Version : declare\n          E    : constant Entity_Id :=\n                   Make_Defining_Identifier (Loc, New_Internal_Name ('V'));\n-         Pent : Entity_Id := Entity (Pref);\n+         Pent : Entity_Id;\n          S    : String_Id;\n \n       begin\n          --  If not library unit, get to containing library unit\n \n+         Pent := Entity (Pref);\n          while Pent /= Standard_Standard\n            and then Scope (Pent) /= Standard_Standard\n+           and then not Is_Child_Unit (Pent)\n          loop\n             Pent := Scope (Pent);\n          end loop;\n \n-         --  Special case Standard\n+         --  Special case Standard and Standard.ASCII\n \n-         if Pent = Standard_Standard\n-           or else Pent = Standard_ASCII\n-         then\n+         if Pent = Standard_Standard or else Pent = Standard_ASCII then\n             Rewrite (N,\n               Make_String_Literal (Loc,\n                 Strval => Verbose_Library_Version));\n@@ -1088,6 +1119,11 @@ package body Exp_Attr is\n             Set_Is_Imported (E);\n             Set_Interface_Name (E, Make_String_Literal (Loc, S));\n \n+            --  Set entity as internal to ensure proper Sprint output of its\n+            --  implicit importation.\n+\n+            Set_Is_Internal (E);\n+\n             --  And now rewrite original reference\n \n             Rewrite (N,\n@@ -4067,32 +4103,6 @@ package body Exp_Attr is\n             Expand_Fpt_Attribute_R (N);\n          end if;\n \n-      ----------------------\n-      -- Unchecked_Access --\n-      ----------------------\n-\n-      when Attribute_Unchecked_Access =>\n-\n-         --  Ada 2005 (AI-251): If the designated type is an interface, then\n-         --  rewrite the referenced object as a conversion to force the\n-         --  displacement of the pointer to the secondary dispatch table.\n-\n-         if Is_Interface (Directly_Designated_Type (Btyp)) then\n-            declare\n-               Ref_Object : constant Node_Id := Get_Referenced_Object (Pref);\n-               Conversion : Node_Id;\n-            begin\n-               Conversion := Convert_To (Typ, New_Copy_Tree (Ref_Object));\n-               Rewrite (N, Conversion);\n-               Analyze_And_Resolve (N, Typ);\n-            end;\n-\n-         --  Otherwise this is like normal Access without a check\n-\n-         else\n-            Expand_Access_To_Type (N);\n-         end if;\n-\n       -----------------\n       -- UET_Address --\n       -----------------\n@@ -4124,6 +4134,11 @@ package body Exp_Attr is\n            Make_String_Literal (Loc,\n              Strval => String_From_Name_Buffer));\n \n+         --  Set entity as internal to ensure proper Sprint output of its\n+         --  implicit importation.\n+\n+         Set_Is_Internal (Ent);\n+\n          Rewrite (N,\n            Make_Attribute_Reference (Loc,\n              Prefix => New_Occurrence_Of (Ent, Loc),\n@@ -4132,35 +4147,6 @@ package body Exp_Attr is\n          Analyze_And_Resolve (N, Typ);\n       end UET_Address;\n \n-      -------------------------\n-      -- Unrestricted_Access --\n-      -------------------------\n-\n-      when Attribute_Unrestricted_Access =>\n-\n-         if Is_Access_Protected_Subprogram_Type (Btyp) then\n-            Expand_Access_To_Protected_Op (N, Pref, Typ);\n-\n-         --  Ada 2005 (AI-251): If the designated type is an interface, then\n-         --  rewrite the referenced object as a conversion to force the\n-         --  displacement of the pointer to the secondary dispatch table.\n-\n-         elsif Is_Interface (Directly_Designated_Type (Btyp)) then\n-            declare\n-               Ref_Object : constant Node_Id := Get_Referenced_Object (Pref);\n-               Conversion : Node_Id;\n-            begin\n-               Conversion := Convert_To (Typ, New_Copy_Tree (Ref_Object));\n-               Rewrite (N, Conversion);\n-               Analyze_And_Resolve (N, Typ);\n-            end;\n-\n-         --  Otherwise this is like Access without a check\n-\n-         else\n-            Expand_Access_To_Type (N);\n-         end if;\n-\n       ---------------\n       -- VADS_Size --\n       ---------------\n@@ -4895,6 +4881,7 @@ package body Exp_Attr is\n            Attribute_Denorm                       |\n            Attribute_Digits                       |\n            Attribute_Emax                         |\n+           Attribute_Enabled                      |\n            Attribute_Epsilon                      |\n            Attribute_Has_Access_Values            |\n            Attribute_Has_Discriminants            |"}]}