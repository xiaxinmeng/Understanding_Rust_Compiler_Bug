{"sha": "e8c87bc07b5c98101b47caaee84650cd8abdfa5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThjODdiYzA3YjVjOTgxMDFiNDdjYWFlZTg0NjUwY2Q4YWJkZmE1Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-02-03T10:38:04Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-02-03T10:38:04Z"}, "message": "Fix regression with partial rep clause on variant record type\n\nIt can yield an incorrect layout when there is a partial representation\nclause on a discriminated record type with a variant part.\n\ngcc/ada/\n\t* gcc-interface/decl.c (components_to_record): If the first component\n\twith rep clause is the _Parent field with variable size, temporarily\n\tset it aside when computing the internal layout of the REP part again.\n\t* gcc-interface/utils.c (finish_record_type): Revert to taking the\n\tmaximum when merging sizes for all record types with rep clause.\n\t(merge_sizes): Put SPECIAL parameter last and adjust recursive calls.", "tree": {"sha": "5badee4ab77820205d39dd2344f571f358af2fe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5badee4ab77820205d39dd2344f571f358af2fe2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8c87bc07b5c98101b47caaee84650cd8abdfa5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8c87bc07b5c98101b47caaee84650cd8abdfa5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8c87bc07b5c98101b47caaee84650cd8abdfa5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8c87bc07b5c98101b47caaee84650cd8abdfa5f/comments", "author": null, "committer": null, "parents": [{"sha": "fc130ab54fd9a254f07426f9c180c367b039d7f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc130ab54fd9a254f07426f9c180c367b039d7f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc130ab54fd9a254f07426f9c180c367b039d7f9"}], "stats": {"total": 116, "additions": 79, "deletions": 37}, "files": [{"sha": "aea191c7ecbf282f78825888783492ba08c70ae5", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 59, "deletions": 18, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c87bc07b5c98101b47caaee84650cd8abdfa5f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c87bc07b5c98101b47caaee84650cd8abdfa5f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=e8c87bc07b5c98101b47caaee84650cd8abdfa5f", "patch": "@@ -8330,12 +8330,12 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n   if (p_gnu_rep_list && gnu_rep_list)\n     *p_gnu_rep_list = chainon (*p_gnu_rep_list, gnu_rep_list);\n \n-  /* Deal with the annoying case of an extension of a record with variable size\n-     and partial rep clause, for which the _Parent field is forced at offset 0\n-     and has variable size, which we do not support below.  Note that we cannot\n-     do it if the field has fixed size because we rely on the presence of the\n-     REP part built below to trigger the reordering of the fields in a derived\n-     record type when all the fields have a fixed position.  */\n+  /* Deal with the case of an extension of a record type with variable size and\n+     partial rep clause, for which the _Parent field is forced at offset 0 and\n+     has variable size.  Note that we cannot do it if the field has fixed size\n+     because we rely on the presence of the REP part built below to trigger the\n+     reordering of the fields in a derived record type when all the fields have\n+     a fixed position.  */\n   else if (gnu_rep_list\n \t   && !DECL_CHAIN (gnu_rep_list)\n \t   && TREE_CODE (DECL_SIZE (gnu_rep_list)) != INTEGER_CST\n@@ -8353,33 +8353,52 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n      record, before the others, if we also have fields without rep clause.  */\n   else if (gnu_rep_list)\n     {\n-      tree gnu_rep_type, gnu_rep_part;\n-      int i, len = list_length (gnu_rep_list);\n-      tree *gnu_arr = XALLOCAVEC (tree, len);\n+      tree gnu_parent, gnu_rep_type;\n \n       /* If all the fields have a rep clause, we can do a flat layout.  */\n       layout_with_rep = !gnu_field_list\n \t\t\t&& (!gnu_variant_part || variants_have_rep);\n+\n+      /* Same as above but the extension itself has a rep clause, in which case\n+\t we need to set aside the _Parent field to lay out the REP part.  */\n+      if (TREE_CODE (DECL_SIZE (gnu_rep_list)) != INTEGER_CST\n+\t  && !layout_with_rep\n+\t  && !variants_have_rep\n+\t  && first_free_pos\n+\t  && integer_zerop (first_free_pos)\n+\t  && integer_zerop (bit_position (gnu_rep_list)))\n+\t{\n+\t  gnu_parent = gnu_rep_list;\n+\t  gnu_rep_list = DECL_CHAIN (gnu_rep_list);\n+\t}\n+      else\n+\tgnu_parent = NULL_TREE;\n+\n       gnu_rep_type\n \t= layout_with_rep ? gnu_record_type : make_node (RECORD_TYPE);\n \n-      for (gnu_field = gnu_rep_list, i = 0;\n-\t   gnu_field;\n-\t   gnu_field = DECL_CHAIN (gnu_field), i++)\n-\tgnu_arr[i] = gnu_field;\n+      /* Sort the fields in order of increasing bit position.  */\n+      const int len = list_length (gnu_rep_list);\n+      tree *gnu_arr = XALLOCAVEC (tree, len);\n+\n+      gnu_field = gnu_rep_list;\n+      for (int i = 0; i < len; i++)\n+\t{\n+\t  gnu_arr[i] = gnu_field;\n+\t  gnu_field = DECL_CHAIN (gnu_field);\n+\t}\n \n       qsort (gnu_arr, len, sizeof (tree), compare_field_bitpos);\n \n-      /* Put the fields in the list in order of increasing position, which\n-\t means we start from the end.  */\n       gnu_rep_list = NULL_TREE;\n-      for (i = len - 1; i >= 0; i--)\n+      for (int i = len - 1; i >= 0; i--)\n \t{\n \t  DECL_CHAIN (gnu_arr[i]) = gnu_rep_list;\n \t  gnu_rep_list = gnu_arr[i];\n \t  DECL_CONTEXT (gnu_arr[i]) = gnu_rep_type;\n \t}\n \n+      /* Do the layout of the REP part, if any.  */\n       if (layout_with_rep)\n \tgnu_field_list = gnu_rep_list;\n       else\n@@ -8388,14 +8407,36 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n \t    = create_concat_name (gnat_record_type, \"REP\");\n \t  TYPE_REVERSE_STORAGE_ORDER (gnu_rep_type)\n \t    = TYPE_REVERSE_STORAGE_ORDER (gnu_record_type);\n-\t  finish_record_type (gnu_rep_type, gnu_rep_list, 1, debug_info);\n+\t  finish_record_type (gnu_rep_type, gnu_rep_list, 1, false);\n \n \t  /* If FIRST_FREE_POS is nonzero, we need to ensure that the fields\n \t     without rep clause are laid out starting from this position.\n \t     Therefore, we force it as a minimal size on the REP part.  */\n-\t  gnu_rep_part\n+\t  tree gnu_rep_part\n \t    = create_rep_part (gnu_rep_type, gnu_record_type, first_free_pos);\n \n+\t  /* If this is an extension, put back the _Parent field as the first\n+\t     field of the REP part at offset 0 and update its layout.  */\n+\t  if (gnu_parent)\n+\t    {\n+\t      const unsigned int align = DECL_ALIGN (gnu_parent);\n+\t      DECL_CHAIN (gnu_parent) = TYPE_FIELDS (gnu_rep_type);\n+\t      TYPE_FIELDS (gnu_rep_type) = gnu_parent;\n+\t      DECL_CONTEXT (gnu_parent) = gnu_rep_type;\n+\t      if (align > TYPE_ALIGN (gnu_rep_type))\n+\t\t{\n+\t\t  SET_TYPE_ALIGN (gnu_rep_type, align);\n+\t\t  TYPE_SIZE (gnu_rep_type)\n+\t\t    = round_up (TYPE_SIZE (gnu_rep_type), align);\n+\t\t  TYPE_SIZE_UNIT (gnu_rep_type)\n+\t\t    = round_up (TYPE_SIZE_UNIT (gnu_rep_type), align);\n+\t\t  SET_DECL_ALIGN (gnu_rep_part, align);\n+\t\t}\n+\t    }\n+\n+\t  if (debug_info)\n+\t    rest_of_record_type_compilation (gnu_rep_type);\n+\n \t  /* Chain the REP part at the beginning of the field list.  */\n \t  DECL_CHAIN (gnu_rep_part) = gnu_field_list;\n \t  gnu_field_list = gnu_rep_part;"}, {"sha": "952f032072b761a0a23062743bb8f871deb7464a", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c87bc07b5c98101b47caaee84650cd8abdfa5f/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c87bc07b5c98101b47caaee84650cd8abdfa5f/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=e8c87bc07b5c98101b47caaee84650cd8abdfa5f", "patch": "@@ -2051,7 +2051,6 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n \tthis_ada_size = this_size;\n \n       const bool variant_part = (TREE_CODE (type) == QUAL_UNION_TYPE);\n-      const bool variant_part_at_zero = variant_part && integer_zerop (pos);\n \n       /* Clear DECL_BIT_FIELD for the cases layout_decl does not handle.  */\n       if (DECL_BIT_FIELD (field)\n@@ -2094,7 +2093,7 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n       /* Clear DECL_BIT_FIELD_TYPE for a variant part at offset 0, it's simply\n \t not supported by the DECL_BIT_FIELD_REPRESENTATIVE machinery because\n \t the variant part is always the last field in the list.  */\n-      if (variant_part_at_zero)\n+      if (variant_part && integer_zerop (pos))\n \tDECL_BIT_FIELD_TYPE (field) = NULL_TREE;\n \n       /* If we still have DECL_BIT_FIELD set at this point, we know that the\n@@ -2129,18 +2128,20 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n \tcase RECORD_TYPE:\n \t  /* Since we know here that all fields are sorted in order of\n \t     increasing bit position, the size of the record is one\n-\t     higher than the ending bit of the last field processed,\n-\t     unless we have a variant part at offset 0, since in this\n-\t     case we might have a field outside the variant part that\n-\t     has a higher ending position; so use a MAX in this case.\n-\t     Also, if this field is a QUAL_UNION_TYPE, we need to take\n-\t     into account the previous size in the case of empty variants.  */\n+\t     higher than the ending bit of the last field processed\n+\t     unless we have a rep clause, because we might be processing\n+\t     the REP part of a record with a variant part for which the\n+\t     variant part has a rep clause but not the fixed part, in\n+\t     which case this REP part may contain overlapping fields\n+\t     and thus needs to be treated like a union tyoe above, so\n+\t     use a MAX in that case.  Also, if this field is a variant\n+\t     part, we need to take into account the previous size in\n+\t     the case of empty variants.  */\n \t  ada_size\n-\t    = merge_sizes (ada_size, pos, this_ada_size, variant_part,\n-\t\t\t   variant_part_at_zero);\n+\t    = merge_sizes (ada_size, pos, this_ada_size, rep_level > 0,\n+\t\t\t   variant_part);\n \t  size\n-\t    = merge_sizes (size, pos, this_size, variant_part,\n-\t\t\t   variant_part_at_zero);\n+\t    = merge_sizes (size, pos, this_size, rep_level > 0, variant_part);\n \t  break;\n \n \tdefault:\n@@ -2432,14 +2433,14 @@ rest_of_record_type_compilation (tree record_type)\n }\n \n /* Utility function of above to merge LAST_SIZE, the previous size of a record\n-   with FIRST_BIT and SIZE that describe a field.  SPECIAL is true if this\n-   represents a QUAL_UNION_TYPE in which case we must look for COND_EXPRs and\n-   replace a value of zero with the old size.  If MAX is true, we take the\n+   with FIRST_BIT and SIZE that describe a field.  If MAX is true, we take the\n    MAX of the end position of this field with LAST_SIZE.  In all other cases,\n-   we use FIRST_BIT plus SIZE.  Return an expression for the size.  */\n+   we use FIRST_BIT plus SIZE.  SPECIAL is true if it's for a QUAL_UNION_TYPE,\n+   in which case we must look for COND_EXPRs and replace a value of zero with\n+   the old size.  Return an expression for the size.  */\n \n static tree\n-merge_sizes (tree last_size, tree first_bit, tree size, bool special, bool max)\n+merge_sizes (tree last_size, tree first_bit, tree size, bool max, bool special)\n {\n   tree type = TREE_TYPE (last_size);\n   tree new_size;\n@@ -2456,11 +2457,11 @@ merge_sizes (tree last_size, tree first_bit, tree size, bool special, bool max)\n \t\t\t    integer_zerop (TREE_OPERAND (size, 1))\n \t\t\t    ? last_size : merge_sizes (last_size, first_bit,\n \t\t\t\t\t\t       TREE_OPERAND (size, 1),\n-\t\t\t\t\t\t       1, max),\n+\t\t\t\t\t\t       max, special),\n \t\t\t    integer_zerop (TREE_OPERAND (size, 2))\n \t\t\t    ? last_size : merge_sizes (last_size, first_bit,\n \t\t\t\t\t\t       TREE_OPERAND (size, 2),\n-\t\t\t\t\t\t       1, max));\n+\t\t\t\t\t\t       max, special));\n \n   /* We don't need any NON_VALUE_EXPRs and they can confuse us (especially\n      when fed through SUBSTITUTE_IN_EXPR) into thinking that a constant"}]}