{"sha": "611a4b873e1fbd6fc2b4a28c05924660a0b5c2af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjExYTRiODczZTFmYmQ2ZmMyYjRhMjhjMDU5MjQ2NjBhMGI1YzJhZg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-06-01T16:04:14Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-06-01T16:04:14Z"}, "message": "re GNATS gcj/129 (Static array length access bug in gcj)\n\n2000-05-02  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * parse.y (resolve_field_access): Call the appropriate <clinit>\n        before accessing the length of a static array. Craft a decl for\n        the field while its time.\n\n(Fixes the PR #129:\n http://sourceware.cygnus.com/ml/java-prs/2000-q1/msg00013.html)\n\nFrom-SVN: r34340", "tree": {"sha": "d6324832e0824ac9082b28a39a44e90b8c742472", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6324832e0824ac9082b28a39a44e90b8c742472"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af/comments", "author": null, "committer": null, "parents": [{"sha": "079b71f5ab1535ac920e4bd4182480f2a89f933d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079b71f5ab1535ac920e4bd4182480f2a89f933d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/079b71f5ab1535ac920e4bd4182480f2a89f933d"}], "stats": {"total": 30, "additions": 30, "deletions": 0}, "files": [{"sha": "fdfc79cf62c8d89f2efe45c1681fe5dc68ea3298", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=611a4b873e1fbd6fc2b4a28c05924660a0b5c2af", "patch": "@@ -34,6 +34,12 @@\n \t`wfl_operator', to maybe_build_primttype_type_ref.\n \tFixes PR gcj/235.\n \n+2000-05-02  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (resolve_field_access): Call the appropriate <clinit>\n+\tbefore accessing the length of a static array. Craft a decl for\n+\tthe field while its time. Fixes PR gcj/129.\n+ \n 2000-05-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (resolve_package): Correctly set `*next' (was off by"}, {"sha": "c7871837132fef209948272fd51f23b472a2f7a2", "filename": "gcc/java/parse.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=611a4b873e1fbd6fc2b4a28c05924660a0b5c2af", "patch": "@@ -11348,6 +11348,18 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n       tree length = build_java_array_length_access (where_found);\n       field_ref =\n \tbuild_java_arraynull_check (type_found, length, int_type_node);\n+\n+      /* In case we're dealing with a static array, we need to\n+\t initialize its class before the array length can be fetched.\n+\t It's also a good time to create a DECL_RTL for the field if\n+\t none already exists, otherwise if the field was declared in a\n+\t class found in an external file and hasn't been (and won't\n+\t be) accessed for its value, none will be created. */\n+      if (TREE_CODE (where_found) == VAR_DECL && FIELD_STATIC (where_found))\n+\t{\n+\t  build_static_field_ref (where_found);\n+\t  field_ref = build_class_init (DECL_CONTEXT (where_found), field_ref);\n+\t}\n     }\n   /* We might have been trying to resolve field.method(). In which\n      case, the resolution is over and decl is the answer */"}, {"sha": "385f913968853881a90ace8103cd81b38f5cd892", "filename": "gcc/java/parse.y", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=611a4b873e1fbd6fc2b4a28c05924660a0b5c2af", "patch": "@@ -8650,6 +8650,18 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n       tree length = build_java_array_length_access (where_found);\n       field_ref =\n \tbuild_java_arraynull_check (type_found, length, int_type_node);\n+\n+      /* In case we're dealing with a static array, we need to\n+\t initialize its class before the array length can be fetched.\n+\t It's also a good time to create a DECL_RTL for the field if\n+\t none already exists, otherwise if the field was declared in a\n+\t class found in an external file and hasn't been (and won't\n+\t be) accessed for its value, none will be created. */\n+      if (TREE_CODE (where_found) == VAR_DECL && FIELD_STATIC (where_found))\n+\t{\n+\t  build_static_field_ref (where_found);\n+\t  field_ref = build_class_init (DECL_CONTEXT (where_found), field_ref);\n+\t}\n     }\n   /* We might have been trying to resolve field.method(). In which\n      case, the resolution is over and decl is the answer */"}]}