{"sha": "2ab8f063e9957882ce55f8585694a140486eae03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFiOGYwNjNlOTk1Nzg4MmNlNTVmODU4NTY5NGExNDA0ODZlYWUwMw==", "commit": {"author": {"name": "Ian Bolton", "email": "ian.bolton@arm.com", "date": "2013-10-03T09:50:21Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2013-10-03T09:50:21Z"}, "message": "[AArch64] Remove un-necessary secondary reload for addition to SP.\n\nFrom-SVN: r203156", "tree": {"sha": "8c0c1ea1f730ced6af571ea1425fb3f1bb590526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c0c1ea1f730ced6af571ea1425fb3f1bb590526"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ab8f063e9957882ce55f8585694a140486eae03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ab8f063e9957882ce55f8585694a140486eae03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ab8f063e9957882ce55f8585694a140486eae03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ab8f063e9957882ce55f8585694a140486eae03/comments", "author": null, "committer": null, "parents": [{"sha": "79221839a3c9c0e8a4cf5ea130bcf24062ee3995", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79221839a3c9c0e8a4cf5ea130bcf24062ee3995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79221839a3c9c0e8a4cf5ea130bcf24062ee3995"}], "stats": {"total": 52, "additions": 6, "deletions": 46}, "files": [{"sha": "002b761a8b3904a31ffead9bc0246ad3bb6702ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab8f063e9957882ce55f8585694a140486eae03/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab8f063e9957882ce55f8585694a140486eae03/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ab8f063e9957882ce55f8585694a140486eae03", "patch": "@@ -1,3 +1,9 @@\n+2013-10-03  Ian Bolton  <ian.bolton@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_secondary_reload): Remove legacy\n+\tcode.\n+\t* config/aarch64/aarch64.md (reload_sp_immediate): Likewise.\n+\n 2013-10-02  Teresa Johnson  <tejohnson@google.com>\n \n \t* predict.c (probably_never_executed): New function."}, {"sha": "f6f587a9122e28cb12693d24856e4b8a854aa73e", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab8f063e9957882ce55f8585694a140486eae03/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab8f063e9957882ce55f8585694a140486eae03/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=2ab8f063e9957882ce55f8585694a140486eae03", "patch": "@@ -4028,20 +4028,6 @@ aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n \t\t\t  enum machine_mode mode,\n \t\t\t  secondary_reload_info *sri)\n {\n-  /* Address expressions of the form PLUS (SP, large_offset) need two\n-     scratch registers, one for the constant, and one for holding a\n-     copy of SP, since SP cannot be used on the RHS of an add-reg\n-     instruction.  */\n-  if (mode == DImode\n-      && GET_CODE (x) == PLUS\n-      && XEXP (x, 0) == stack_pointer_rtx\n-      && CONST_INT_P (XEXP (x, 1))\n-      && !aarch64_uimm12_shift (INTVAL (XEXP (x, 1))))\n-    {\n-      sri->icode = CODE_FOR_reload_sp_immediate;\n-      return NO_REGS;\n-    }\n-\n   /* Without the TARGET_SIMD instructions we cannot move a Q register\n      to a Q register directly.  We need a scratch.  */\n   if (REG_P (x) && (mode == TFmode || mode == TImode) && mode == GET_MODE (x)"}, {"sha": "830bbeec08efd0ed14d4c47feb7322a4d2c86c02", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab8f063e9957882ce55f8585694a140486eae03/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab8f063e9957882ce55f8585694a140486eae03/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=2ab8f063e9957882ce55f8585694a140486eae03", "patch": "@@ -3955,38 +3955,6 @@\n ;; Reload support\n ;; -------------------------------------------------------------------\n \n-;; Reload SP+imm where imm cannot be handled by a single ADD instruction.  \n-;; Must load imm into a scratch register and copy SP to the dest reg before\n-;; adding, since SP cannot be used as a source register in an ADD\n-;; instruction.\n-(define_expand \"reload_sp_immediate\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t\t   (match_operand:DI 1 \"\" \"\"))\n-\t     (clobber (match_operand:TI 2 \"register_operand\" \"=&r\"))])]\n-  \"\"\n-  {\n-    rtx sp = XEXP (operands[1], 0);\n-    rtx val = XEXP (operands[1], 1);\n-    unsigned regno = REGNO (operands[2]);\n-    rtx scratch = operands[1];\n-    gcc_assert (GET_CODE (operands[1]) == PLUS);\n-    gcc_assert (sp == stack_pointer_rtx);\n-    gcc_assert (CONST_INT_P (val));\n-\n-    /* It is possible that one of the registers we got for operands[2]\n-       might coincide with that of operands[0] (which is why we made\n-       it TImode).  Pick the other one to use as our scratch.  */\n-    if (regno == REGNO (operands[0]))\n-      regno++;\n-    scratch = gen_rtx_REG (DImode, regno);\n-\n-    emit_move_insn (scratch, val);\n-    emit_move_insn (operands[0], sp);\n-    emit_insn (gen_adddi3 (operands[0], operands[0], scratch));\n-    DONE;\n-  }\n-)\n-\n (define_expand \"aarch64_reload_mov<mode>\"\n   [(set (match_operand:TX 0 \"register_operand\" \"=w\")\n         (match_operand:TX 1 \"register_operand\" \"w\"))"}]}