{"sha": "97508a6b314c76302a6b71f3ca8c09488a6f2850", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc1MDhhNmIzMTRjNzYzMDJhNmI3MWYzY2E4YzA5NDg4YTZmMjg1MA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-12-28T06:23:06Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-12-28T06:23:06Z"}, "message": "sbitmap.c (BITMAP_DEBUGGING): New macro.\n\n2006-12-27  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* sbitmap.c (BITMAP_DEBUGGING): New macro.\n\t(do_popcount): Ditto.\n\t(sbitmap_verify_popcount): New function.\n\t(sbitmap_alloc): Set popcount to NULL, remove set of bytes\n\tmember.\n\t(sbitmap_alloc_with_popcount): New function.\n\t(sbitmap_resize): Remove uses of bytes member and update\n\tpopcount.\n\t(sbitmap_realloc): Remove uses of bytes member.\n\t(sbitmap_copy): Copy popcount.\n\t(sbitmap_copy_n): New function.\n\t(sbitmap_zero): Update popcount cache.\n\t(sbitmap_ones): Ditto.\n\t(sbitmap_a_and_b): Ditto.\n\t(sbitmap_a_or_b): Ditto.\n\t(sbitmap_a_xor_b): Ditto.\n\t(sbitmap_union_of_diff_cg): Assert non-existence of popcount\n\tcache.\n\t(sbitmap_union_of_diff): Ditto.\n\t(sbitmap_not): Ditto.\n\t(sbitmap_difference): Ditto.\n\t(sbitmap_a_and_b_cg): Ditto.\n\t(sbitmap_a_xor_b_cg): Ditto.\n\t(sbitmap_a_or_b_cg): Ditto.\n\t(sbitmap_a_or_b_and_c_cg): Ditto.\n\t(sbitmap_a_and_b_or_c_cg): Ditto.\n\t(sbitmap_intersection_of_succs): Ditto.\n\t(sbitmap_intersection_of_preds): Ditto.\n\t(sbitmap_union_of_succs): Ditto.\n\t(sbitmap_union_of_preds): Ditto.\n\t(popcount_table): New.\n\t(sbitmap_elt_popcount): New function.\n\t(sbitmap_popcount): Ditto.\n\n\t* sbitmap.h (sbitmap): Remove bytes member.\n\tAdd popcount member.\n\t(SET_BIT): Macro turned into function.\n\t(RESET_BIT): Ditto.\n\t(SBITMAP_SIZE_BYTES): New macro.\n\t(sbitmap_free): Free popcount too.\n\t(sbitmap_alloc_with_popcount): New prototype.\n\t(sbitmap_copy_n): Ditto.\n\t(sbitmap_verify_popcount): Ditto.\n\nFrom-SVN: r120237", "tree": {"sha": "f8f7b8dc9789ae93a359cec4c1921245f436bcd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8f7b8dc9789ae93a359cec4c1921245f436bcd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97508a6b314c76302a6b71f3ca8c09488a6f2850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97508a6b314c76302a6b71f3ca8c09488a6f2850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97508a6b314c76302a6b71f3ca8c09488a6f2850", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97508a6b314c76302a6b71f3ca8c09488a6f2850/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1e47eeb1677e3e888500d3a6274a5bbecababa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1e47eeb1677e3e888500d3a6274a5bbecababa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1e47eeb1677e3e888500d3a6274a5bbecababa8"}], "stats": {"total": 381, "additions": 353, "deletions": 28}, "files": [{"sha": "041f51adbbbbef333337d24971187ec974909673", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97508a6b314c76302a6b71f3ca8c09488a6f2850/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97508a6b314c76302a6b71f3ca8c09488a6f2850/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97508a6b314c76302a6b71f3ca8c09488a6f2850", "patch": "@@ -1,3 +1,49 @@\n+2006-12-27  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* sbitmap.c (BITMAP_DEBUGGING): New macro.\n+\t(do_popcount): Ditto.\n+\t(sbitmap_verify_popcount): New function.\n+\t(sbitmap_alloc): Set popcount to NULL, remove set of bytes\n+\tmember.\n+\t(sbitmap_alloc_with_popcount): New function.\n+\t(sbitmap_resize): Remove uses of bytes member and update\n+\tpopcount.\n+\t(sbitmap_realloc): Remove uses of bytes member.\n+\t(sbitmap_copy): Copy popcount.\n+\t(sbitmap_copy_n): New function.\n+\t(sbitmap_zero): Update popcount cache.\n+\t(sbitmap_ones): Ditto.\n+\t(sbitmap_a_and_b): Ditto.\n+\t(sbitmap_a_or_b): Ditto.\n+\t(sbitmap_a_xor_b): Ditto.\n+\t(sbitmap_union_of_diff_cg): Assert non-existence of popcount\n+\tcache.\n+\t(sbitmap_union_of_diff): Ditto.\n+\t(sbitmap_not): Ditto.\n+\t(sbitmap_difference): Ditto.\n+\t(sbitmap_a_and_b_cg): Ditto.\n+\t(sbitmap_a_xor_b_cg): Ditto.\n+\t(sbitmap_a_or_b_cg): Ditto.\n+\t(sbitmap_a_or_b_and_c_cg): Ditto.\n+\t(sbitmap_a_and_b_or_c_cg): Ditto.\n+\t(sbitmap_intersection_of_succs): Ditto.\n+\t(sbitmap_intersection_of_preds): Ditto.\n+\t(sbitmap_union_of_succs): Ditto.\n+\t(sbitmap_union_of_preds): Ditto.\n+\t(popcount_table): New.\n+\t(sbitmap_elt_popcount): New function.\n+\t(sbitmap_popcount): Ditto.\n+\n+\t* sbitmap.h (sbitmap): Remove bytes member.\n+\tAdd popcount member.\n+\t(SET_BIT): Macro turned into function.\n+\t(RESET_BIT): Ditto.\n+\t(SBITMAP_SIZE_BYTES): New macro.\n+\t(sbitmap_free): Free popcount too.\n+\t(sbitmap_alloc_with_popcount): New prototype.\n+\t(sbitmap_copy_n): Ditto.\n+\t(sbitmap_verify_popcount): Ditto.\n+\n 2006-12-27  Ian Lance Taylor  <iant@google.com>\n \n \tPR debug/26964"}, {"sha": "a32364f0f7e8c423cce920568a51be941c154b88", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 257, "deletions": 17, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97508a6b314c76302a6b71f3ca8c09488a6f2850/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97508a6b314c76302a6b71f3ca8c09488a6f2850/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=97508a6b314c76302a6b71f3ca8c09488a6f2850", "patch": "@@ -28,6 +28,43 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"obstack.h\"\n #include \"basic-block.h\"\n \n+#if GCC_VERSION >= 3400\n+#if HOST_BITS_PER_WIDEST_FAST_INT == HOST_BITS_PER_LONG\n+#define do_popcount(x) __builtin_popcountl(x)\n+#elif HOST_BITS_PER_WIDEST_FAST_INT == HOST_BITS_PER_LONG_LONG\n+#define do_popcount(x) __builtin_popcountll(x)\n+#else\n+#error \"internal error: sbitmap.h and hwint.h are inconsistent\"\n+#endif\n+#else\n+static unsigned long sbitmap_elt_popcount (SBITMAP_ELT_TYPE);\n+#define do_popcount(x) sbitmap_elt_popcount((x))\n+#endif\n+\n+/* This macro controls debugging that is as expensive as the\n+   operations it verifies.  */\n+\n+/* #define BITMAP_DEBUGGING  */\n+#ifdef BITMAP_DEBUGGING\n+\n+/* Verify the population count of sbitmap A matches the cached value,\n+   if there is a cached value. */\n+\n+void\n+sbitmap_verify_popcount (sbitmap a)\n+{\n+  unsigned ix;\n+  unsigned int lastword;\n+  \n+  if (!a->popcount)\n+    return;\n+\n+  lastword = a->size;\n+  for (ix = 0; ix < lastword; ix++)\n+    gcc_assert (a->popcount[ix] == do_popcount (a->elms[ix]));\n+}\n+#endif\n+\n /* Bitmap manipulation routines.  */\n \n /* Allocate a simple bitmap of N_ELMS bits.  */\n@@ -45,7 +82,19 @@ sbitmap_alloc (unsigned int n_elms)\n   bmap = xmalloc (amt);\n   bmap->n_bits = n_elms;\n   bmap->size = size;\n-  bmap->bytes = bytes;\n+  bmap->popcount = NULL;\n+  return bmap;\n+}\n+\n+/* Allocate a simple bitmap of N_ELMS bits, and a popcount array.  */\n+\n+sbitmap\n+sbitmap_alloc_with_popcount (unsigned int n_elms)\n+{\n+  sbitmap bmap;\n+  \n+  bmap = sbitmap_alloc (n_elms);  \n+  bmap->popcount = xmalloc (bmap->size * sizeof (unsigned char));\n   return bmap;\n }\n \n@@ -61,18 +110,22 @@ sbitmap_resize (sbitmap bmap, unsigned int n_elms, int def)\n \n   size = SBITMAP_SET_SIZE (n_elms);\n   bytes = size * sizeof (SBITMAP_ELT_TYPE);\n-  if (bytes > bmap->bytes)\n+  if (bytes > SBITMAP_SIZE_BYTES (bmap))\n     {\n       amt = (sizeof (struct simple_bitmap_def)\n \t    + bytes - sizeof (SBITMAP_ELT_TYPE));\n       bmap = xrealloc (bmap, amt);\n+      if (bmap->popcount)\n+\tbmap->popcount = xrealloc (bmap->popcount,\n+\t\t\t\t   size * sizeof (unsigned char));\n     }\n \n   if (n_elms > bmap->n_bits)\n     {\n       if (def)\n \t{\n-\t  memset (bmap->elms + bmap->size, -1, bytes - bmap->bytes);\n+\t  memset (bmap->elms + bmap->size, -1, \n+\t\t  bytes - SBITMAP_SIZE_BYTES (bmap));\n \n \t  /* Set the new bits if the original last element.  */\n \t  last_bit = bmap->n_bits % SBITMAP_ELT_BITS;\n@@ -87,20 +140,31 @@ sbitmap_resize (sbitmap bmap, unsigned int n_elms, int def)\n \t      &= (SBITMAP_ELT_TYPE)-1 >> (SBITMAP_ELT_BITS - last_bit);\n \t}\n       else\n-\tmemset (bmap->elms + bmap->size, 0, bytes - bmap->bytes);\n+\t{\n+\t  memset (bmap->elms + bmap->size, 0, \n+\t\t  bytes - SBITMAP_SIZE_BYTES (bmap));\n+\t  if (bmap->popcount)\n+\t    memset (bmap->popcount + bmap->size, 0,\n+\t\t    (size * sizeof (unsigned char)) \n+\t\t    - (bmap->size * sizeof (unsigned char)));\n+\t\t    \n+\t}\n     }\n   else if (n_elms < bmap->n_bits)\n     {\n       /* Clear the surplus bits in the last word.  */\n       last_bit = n_elms % SBITMAP_ELT_BITS;\n       if (last_bit)\n-\tbmap->elms[size - 1]\n-\t  &= (SBITMAP_ELT_TYPE)-1 >> (SBITMAP_ELT_BITS - last_bit);\n+\t{\n+\t  bmap->elms[size - 1]\n+\t    &= (SBITMAP_ELT_TYPE)-1 >> (SBITMAP_ELT_BITS - last_bit);\n+\t  if (bmap->popcount)\n+\t    bmap->popcount[size - 1] = do_popcount (bmap->elms[size - 1]);\n+\t}\n     }\n \n   bmap->n_bits = n_elms;\n   bmap->size = size;\n-  bmap->bytes = bytes;\n   return bmap;\n }\n \n@@ -117,7 +181,7 @@ sbitmap_realloc (sbitmap src, unsigned int n_elms)\n   amt = (sizeof (struct simple_bitmap_def)\n \t + bytes - sizeof (SBITMAP_ELT_TYPE));\n \n-  if (src->bytes  >= bytes)\n+  if (SBITMAP_SIZE_BYTES (src)  >= bytes)\n     {\n       src->n_bits = n_elms;\n       return src;\n@@ -126,7 +190,6 @@ sbitmap_realloc (sbitmap src, unsigned int n_elms)\n   bmap = (sbitmap) xrealloc (src, amt);\n   bmap->n_bits = n_elms;\n   bmap->size = size;\n-  bmap->bytes = bytes;\n   return bmap;\n }\n \n@@ -166,7 +229,7 @@ sbitmap_vector_alloc (unsigned int n_vecs, unsigned int n_elms)\n       bitmap_vector[i] = b;\n       b->n_bits = n_elms;\n       b->size = size;\n-      b->bytes = bytes;\n+      b->popcount = NULL;\n     }\n \n   return bitmap_vector;\n@@ -178,6 +241,18 @@ void\n sbitmap_copy (sbitmap dst, sbitmap src)\n {\n   memcpy (dst->elms, src->elms, sizeof (SBITMAP_ELT_TYPE) * dst->size);\n+  if (dst->popcount)\n+    memcpy (dst->popcount, src->popcount, sizeof (unsigned char) * dst->size);\n+}\n+\n+/* Copy the first N elements of sbitmap SRC to DST.  */\n+\n+void\n+sbitmap_copy_n (sbitmap dst, sbitmap src, unsigned int n)\n+{\n+  memcpy (dst->elms, src->elms, sizeof (SBITMAP_ELT_TYPE) * n);  \n+  if (dst->popcount)\n+    memcpy (dst->popcount, src->popcount, sizeof (unsigned char) * n);\n }\n \n /* Determine if a == b.  */\n@@ -192,7 +267,9 @@ sbitmap_equal (sbitmap a, sbitmap b)\n void\n sbitmap_zero (sbitmap bmap)\n {\n-  memset (bmap->elms, 0, bmap->bytes);\n+  memset (bmap->elms, 0, SBITMAP_SIZE_BYTES (bmap));\n+  if (bmap->popcount)\n+    memset (bmap->popcount, 0, bmap->size * sizeof (unsigned char));\n }\n \n /* Set all elements in a bitmap to ones.  */\n@@ -202,12 +279,19 @@ sbitmap_ones (sbitmap bmap)\n {\n   unsigned int last_bit;\n \n-  memset (bmap->elms, -1, bmap->bytes);\n+  memset (bmap->elms, -1, SBITMAP_SIZE_BYTES (bmap));\n+  if (bmap->popcount)\n+    memset (bmap->popcount, -1, bmap->size * sizeof (unsigned char));\n \n   last_bit = bmap->n_bits % SBITMAP_ELT_BITS;\n   if (last_bit)\n-    bmap->elms[bmap->size - 1]\n-      = (SBITMAP_ELT_TYPE)-1 >> (SBITMAP_ELT_BITS - last_bit);\n+    {\n+      bmap->elms[bmap->size - 1]\n+\t= (SBITMAP_ELT_TYPE)-1 >> (SBITMAP_ELT_BITS - last_bit);\n+      if (bmap->popcount)\n+\tbmap->popcount[bmap->size - 1] \n+\t  = do_popcount (bmap->elms[bmap->size - 1]);\n+    }\n }\n \n /* Zero a vector of N_VECS bitmaps.  */\n@@ -246,6 +330,8 @@ sbitmap_union_of_diff_cg (sbitmap dst, sbitmap a, sbitmap b, sbitmap c)\n   sbitmap_ptr cp = c->elms;\n   SBITMAP_ELT_TYPE changed = 0;\n \n+  gcc_assert (!dst->popcount);\n+  \n   for (i = 0; i < n; i++)\n     {\n       SBITMAP_ELT_TYPE tmp = *ap++ | (*bp++ & ~*cp++);\n@@ -265,6 +351,9 @@ sbitmap_union_of_diff (sbitmap dst, sbitmap a, sbitmap b, sbitmap c)\n   sbitmap_ptr bp = b->elms;\n   sbitmap_ptr cp = c->elms;\n \n+  gcc_assert (!dst->popcount && !a->popcount\n+\t      && !b->popcount && !c->popcount);\n+\n   for (i = 0; i < n; i++)\n     *dstp++ = *ap++ | (*bp++ & ~*cp++);\n }\n@@ -279,6 +368,8 @@ sbitmap_not (sbitmap dst, sbitmap src)\n   sbitmap_ptr srcp = src->elms;\n   unsigned int last_bit;\n \n+  gcc_assert (!dst->popcount);  \n+\n   for (i = 0; i < n; i++)\n     *dstp++ = ~*srcp++;\n \n@@ -301,6 +392,8 @@ sbitmap_difference (sbitmap dst, sbitmap a, sbitmap b)\n   sbitmap_ptr ap = a->elms;\n   sbitmap_ptr bp = b->elms;\n \n+  gcc_assert (!dst->popcount);\n+\n   /* A should be at least as large as DEST, to have a defined source.  */\n   gcc_assert (a->size >= dst_size);\n   /* If minuend is smaller, we simply pretend it to be zero bits, i.e.\n@@ -346,6 +439,8 @@ sbitmap_a_and_b_cg (sbitmap dst, sbitmap a, sbitmap b)\n   sbitmap_ptr bp = b->elms;\n   SBITMAP_ELT_TYPE changed = 0;\n \n+  gcc_assert (!dst->popcount);\n+\n   for (i = 0; i < n; i++)\n     {\n       SBITMAP_ELT_TYPE tmp = *ap++ & *bp++;\n@@ -363,9 +458,25 @@ sbitmap_a_and_b (sbitmap dst, sbitmap a, sbitmap b)\n   sbitmap_ptr dstp = dst->elms;\n   sbitmap_ptr ap = a->elms;\n   sbitmap_ptr bp = b->elms;\n+  bool has_popcount = dst->popcount != NULL;\n+  unsigned char *popcountp = dst->popcount;\n \n   for (i = 0; i < n; i++)\n-    *dstp++ = *ap++ & *bp++;\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap++ & *bp++;\n+      if (has_popcount)\n+\t{\n+\t  bool wordchanged = (*dstp ^ tmp) != 0;\n+\t  if (wordchanged)\n+\t    *popcountp = do_popcount (tmp);\n+\t  popcountp++;\n+\t}      \n+      *dstp++ = tmp;\n+    }\n+#ifdef BITMAP_DEBUGGING\n+  if (has_popcount)\n+    sbitmap_verify_popcount (dst);\n+#endif\n }\n \n /* Set DST to be (A xor B)).\n@@ -379,6 +490,8 @@ sbitmap_a_xor_b_cg (sbitmap dst, sbitmap a, sbitmap b)\n   sbitmap_ptr ap = a->elms;\n   sbitmap_ptr bp = b->elms;\n   SBITMAP_ELT_TYPE changed = 0;\n+  \n+  gcc_assert (!dst->popcount);\n \n   for (i = 0; i < n; i++)\n     {\n@@ -397,9 +510,25 @@ sbitmap_a_xor_b (sbitmap dst, sbitmap a, sbitmap b)\n   sbitmap_ptr dstp = dst->elms;\n   sbitmap_ptr ap = a->elms;\n   sbitmap_ptr bp = b->elms;\n+  bool has_popcount = dst->popcount != NULL;\n+  unsigned char *popcountp = dst->popcount;\n \n   for (i = 0; i < n; i++)\n-    *dstp++ = *ap++ ^ *bp++;\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap++ ^ *bp++;\n+      if (has_popcount)\n+\t{\n+\t  bool wordchanged = (*dstp ^ tmp) != 0;\n+\t  if (wordchanged)\n+\t    *popcountp = do_popcount (tmp);\n+\t  popcountp++;\n+\t} \n+      *dstp++ = tmp;\n+    }\n+#ifdef BITMAP_DEBUGGING\n+  if (has_popcount)\n+    sbitmap_verify_popcount (dst);\n+#endif\n }\n \n /* Set DST to be (A or B)).\n@@ -414,6 +543,8 @@ sbitmap_a_or_b_cg (sbitmap dst, sbitmap a, sbitmap b)\n   sbitmap_ptr bp = b->elms;\n   SBITMAP_ELT_TYPE changed = 0;\n \n+  gcc_assert (!dst->popcount);\n+\n   for (i = 0; i < n; i++)\n     {\n       SBITMAP_ELT_TYPE tmp = *ap++ | *bp++;\n@@ -431,9 +562,25 @@ sbitmap_a_or_b (sbitmap dst, sbitmap a, sbitmap b)\n   sbitmap_ptr dstp = dst->elms;\n   sbitmap_ptr ap = a->elms;\n   sbitmap_ptr bp = b->elms;\n+  bool has_popcount = dst->popcount != NULL;\n+  unsigned char *popcountp = dst->popcount;\n \n   for (i = 0; i < n; i++)\n-    *dstp++ = *ap++ | *bp++;\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap++ | *bp++;\n+      if (has_popcount)\n+\t{\n+\t  bool wordchanged = (*dstp ^ tmp) != 0;\n+\t  if (wordchanged)\n+\t    *popcountp = do_popcount (tmp);\n+\t  popcountp++;\n+\t} \n+      *dstp++ = tmp;\n+    }\n+#ifdef BITMAP_DEBUGGING\n+  if (has_popcount)\n+    sbitmap_verify_popcount (dst);\n+#endif\n }\n \n /* Return nonzero if A is a subset of B.  */\n@@ -464,6 +611,8 @@ sbitmap_a_or_b_and_c_cg (sbitmap dst, sbitmap a, sbitmap b, sbitmap c)\n   sbitmap_ptr cp = c->elms;\n   SBITMAP_ELT_TYPE changed = 0;\n \n+  gcc_assert (!dst->popcount);\n+\n   for (i = 0; i < n; i++)\n     {\n       SBITMAP_ELT_TYPE tmp = *ap++ | (*bp++ & *cp++);\n@@ -483,6 +632,8 @@ sbitmap_a_or_b_and_c (sbitmap dst, sbitmap a, sbitmap b, sbitmap c)\n   sbitmap_ptr bp = b->elms;\n   sbitmap_ptr cp = c->elms;\n \n+  gcc_assert (!dst->popcount);\n+\n   for (i = 0; i < n; i++)\n     *dstp++ = *ap++ | (*bp++ & *cp++);\n }\n@@ -500,6 +651,8 @@ sbitmap_a_and_b_or_c_cg (sbitmap dst, sbitmap a, sbitmap b, sbitmap c)\n   sbitmap_ptr cp = c->elms;\n   SBITMAP_ELT_TYPE changed = 0;\n \n+  gcc_assert (!dst->popcount);\n+\n   for (i = 0; i < n; i++)\n     {\n       SBITMAP_ELT_TYPE tmp = *ap++ & (*bp++ | *cp++);\n@@ -535,6 +688,8 @@ sbitmap_intersection_of_succs (sbitmap dst, sbitmap *src, int bb)\n   edge e;\n   unsigned ix;\n \n+  gcc_assert (!dst->popcount);\n+\n   for (e = NULL, ix = 0; ix < EDGE_COUNT (b->succs); ix++)\n     {\n       e = EDGE_SUCC (b, ix);\n@@ -575,6 +730,8 @@ sbitmap_intersection_of_preds (sbitmap dst, sbitmap *src, int bb)\n   edge e;\n   unsigned ix;\n \n+  gcc_assert (!dst->popcount);\n+\n   for (e = NULL, ix = 0; ix < EDGE_COUNT (b->preds); ix++)\n     {\n       e = EDGE_PRED (b, ix);\n@@ -615,6 +772,8 @@ sbitmap_union_of_succs (sbitmap dst, sbitmap *src, int bb)\n   edge e;\n   unsigned ix;\n \n+  gcc_assert (!dst->popcount);\n+\n   for (ix = 0; ix < EDGE_COUNT (b->succs); ix++)\n     {\n       e = EDGE_SUCC (b, ix);\n@@ -655,6 +814,8 @@ sbitmap_union_of_preds (sbitmap dst, sbitmap *src, int bb)\n   edge e;\n   unsigned ix;\n \n+  gcc_assert (!dst->popcount);\n+\n   for (ix = 0; ix < EDGE_COUNT (b->preds); ix++)\n     {\n       e = EDGE_PRED (b, ix);\n@@ -795,3 +956,82 @@ dump_sbitmap_vector (FILE *file, const char *title, const char *subtitle,\n \n   fprintf (file, \"\\n\");\n }\n+\n+#if GCC_VERSION < 3400\n+/* Table of number of set bits in a character, indexed by value of char.  */\n+static unsigned char popcount_table[] =\n+{\n+    0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,\n+    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n+    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n+    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n+    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n+    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n+    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n+    3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8,\n+};\n+\n+/* Count the bits in an SBITMAP element A.  */\n+\n+static unsigned long\n+sbitmap_elt_popcount (SBITMAP_ELT_TYPE a)\n+{\n+  unsigned long ret = 0;\n+  unsigned i;\n+\n+  if (a == 0)\n+    return 0;\n+\n+  /* Just do this the table way for now  */\n+  for (i = 0; i < SBITMAP_ELT_BITS; i += 8)\n+    ret += popcount_table[(a >> i) & 0xff];\n+  return ret;\n+}\n+#endif\n+\n+/* Count the number of bits in SBITMAP a, up to bit MAXBIT.  */\n+\n+unsigned long\n+sbitmap_popcount (sbitmap a, unsigned long maxbit)\n+{\n+  unsigned long count = 0;\n+  unsigned ix;\n+  unsigned int lastword;\n+\n+  if (maxbit == 0)\n+    return 0;\n+  \n+  if (maxbit >= a->n_bits)\n+    maxbit = a->n_bits;\n+\n+  /* Count the bits in the full word.  */\n+  lastword = MIN (a->size, SBITMAP_SET_SIZE (maxbit + 1) - 1);\n+  for (ix = 0; ix < lastword; ix++)\n+    {\n+      if (a->popcount)\n+\t{\n+\t  count += a->popcount[ix];\n+#ifdef BITMAP_DEBUGGING\n+\t  gcc_assert (a->popcount[ix] == do_popcount (a->elms[ix]));\n+#endif\n+\t}\n+      else\n+\tcount += do_popcount (a->elms[ix]);\n+    }\n+\n+  /* Count the remaining bits.  */\n+  if (lastword < a->size)\n+    {\n+      unsigned int bitindex;\n+      SBITMAP_ELT_TYPE theword = a->elms[lastword];\n+\n+      bitindex = maxbit % SBITMAP_ELT_BITS;\n+      if (bitindex != 0)\n+\t{\n+\t  theword &= (SBITMAP_ELT_TYPE)-1 >> (SBITMAP_ELT_BITS - bitindex);\n+\t  count += do_popcount (theword);\n+\t}\n+    }\n+  return count;\n+}\n+"}, {"sha": "aacc665f4e70c2103faa257f9c0ed4fad87634ca", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97508a6b314c76302a6b71f3ca8c09488a6f2850/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97508a6b314c76302a6b71f3ca8c09488a6f2850/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=97508a6b314c76302a6b71f3ca8c09488a6f2850", "patch": "@@ -28,32 +28,67 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define SBITMAP_ELT_BITS ((unsigned) HOST_BITS_PER_WIDEST_FAST_INT)\n #define SBITMAP_ELT_TYPE unsigned HOST_WIDEST_FAST_INT\n \n+/* Can't use SBITMAP_ELT_BITS in this macro because it contains a\n+   cast.  There is no perfect macro in GCC to test against.  This\n+   suffices for roughly 99% of the hosts we run on, and the rest\n+   don't have 256 bit integers.  */\n+#if HOST_BITS_PER_WIDEST_FAST_INT > 255\n+#error Need to increase size of datatype used for popcount\n+#endif\n+\n typedef struct simple_bitmap_def\n {\n+  unsigned char *popcount;      /* Population count.  */\n   unsigned int n_bits;\t\t/* Number of bits.  */\n   unsigned int size;\t\t/* Size in elements.  */\n-  unsigned int bytes;\t\t/* Size in bytes.  */\n   SBITMAP_ELT_TYPE elms[1];\t/* The elements.  */\n } *sbitmap;\n \n typedef SBITMAP_ELT_TYPE *sbitmap_ptr;\n \n /* Return the set size needed for N elements.  */\n #define SBITMAP_SET_SIZE(N) (((N) + SBITMAP_ELT_BITS - 1) / SBITMAP_ELT_BITS)\n-\n-/* Set bit number bitno in the bitmap.  */\n-#define SET_BIT(BITMAP, BITNO)\t\t\t\t\t\\\n-  ((BITMAP)->elms [(BITNO) / SBITMAP_ELT_BITS]\t\t\t\\\n-   |= (SBITMAP_ELT_TYPE) 1 << (BITNO) % SBITMAP_ELT_BITS)\n+#define SBITMAP_SIZE_BYTES(BITMAP) ((BITMAP)->size * sizeof (SBITMAP_ELT_TYPE))\n \n /* Test if bit number bitno in the bitmap is set.  */\n #define TEST_BIT(BITMAP, BITNO) \\\n ((BITMAP)->elms [(BITNO) / SBITMAP_ELT_BITS] >> (BITNO) % SBITMAP_ELT_BITS & 1)\n \n-/* Reset bit number bitno in the bitmap.  */\n-#define RESET_BIT(BITMAP, BITNO)\t\t\t\t\\\n-  ((BITMAP)->elms [(BITNO) / SBITMAP_ELT_BITS]\t\t\t\\\n-   &= ~((SBITMAP_ELT_TYPE) 1 << (BITNO) % SBITMAP_ELT_BITS))\n+/* Set bit number BITNO in the sbitmap MAP.  Updates population count\n+   if this bitmap has one.  */\n+\n+static inline void\n+SET_BIT (sbitmap map, unsigned int bitno)\n+{\n+  if (map->popcount)\n+    {\n+      bool oldbit;\n+      oldbit = TEST_BIT (map, bitno);\n+      if (!oldbit)\n+\tmap->popcount[bitno / SBITMAP_ELT_BITS]++;\n+    }\n+  map->elms[bitno / SBITMAP_ELT_BITS]\n+    |= (SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS;\n+}\n+\n+\n+\n+/* Reset bit number BITNO in the sbitmap MAP.  Updates population\n+   count if this bitmap has one.  */\n+\n+static inline void\n+RESET_BIT (sbitmap map,  unsigned int bitno)\n+{\n+  if (map->popcount)\n+    {\n+      bool oldbit;\n+      oldbit = TEST_BIT (map, bitno);\n+      if (oldbit)\n+\tmap->popcount[bitno / SBITMAP_ELT_BITS]--;\n+    }\n+  map->elms[bitno / SBITMAP_ELT_BITS]\n+    &= ~((SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS);\n+}\n \n /* The iterator for sbitmap.  */\n typedef struct {\n@@ -165,7 +200,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n-#define sbitmap_free(MAP)\t\tfree(MAP)\n+#define sbitmap_free(MAP)\t\t(free((MAP)->popcount), free((MAP)))\n #define sbitmap_vector_free(VEC)\tfree(VEC)\n \n struct int_list;\n@@ -175,9 +210,11 @@ extern void dump_sbitmap_file (FILE *, sbitmap);\n extern void dump_sbitmap_vector (FILE *, const char *, const char *, sbitmap *,\n \t\t\t\t int);\n extern sbitmap sbitmap_alloc (unsigned int);\n+extern sbitmap sbitmap_alloc_with_popcount (unsigned int);\n extern sbitmap *sbitmap_vector_alloc (unsigned int, unsigned int);\n extern sbitmap sbitmap_resize (sbitmap, unsigned int, int);\n extern void sbitmap_copy (sbitmap, sbitmap);\n+extern void sbitmap_copy_n (sbitmap, sbitmap, unsigned int);\n extern int sbitmap_equal (sbitmap, sbitmap);\n extern void sbitmap_zero (sbitmap);\n extern void sbitmap_ones (sbitmap);\n@@ -224,4 +261,6 @@ extern void sbitmap_union_of_preds (sbitmap, sbitmap *, int);\n \n extern void debug_sbitmap (sbitmap);\n extern sbitmap sbitmap_realloc (sbitmap, unsigned int);\n+extern unsigned long sbitmap_popcount(sbitmap, unsigned long);\n+extern void sbitmap_verify_popcount (sbitmap);\n #endif /* ! GCC_SBITMAP_H */"}]}