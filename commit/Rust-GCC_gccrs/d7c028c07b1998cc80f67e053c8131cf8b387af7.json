{"sha": "d7c028c07b1998cc80f67e053c8131cf8b387af7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdjMDI4YzA3YjE5OThjYzgwZjY3ZTA1M2M4MTMxY2Y4YjM4N2FmNw==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2012-11-01T19:23:35Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2012-11-01T19:23:35Z"}, "message": "This patch normalizes more bitmap function names.\n\n  sbitmap.h\n\n    TEST_BIT -> bitmap_bit_p\n    SET_BIT -> bitmap_set_bit\n    SET_BIT_WITH_POPCOUNT -> bitmap_set_bit_with_popcount\n    RESET_BIT -> bitmap_clear_bit\n    RESET_BIT_WITH_POPCOUNT -> bitmap_clear_bit_with_popcount\n\n  basic-block.h\n\n    sbitmap_intersection_of_succs -> bitmap_intersection_of_succs\n    sbitmap_intersection_of_preds -> bitmap_intersection_of_preds\n    sbitmap_union_of_succs -> bitmap_union_of_succs\n    sbitmap_union_of_preds -> bitmap_union_of_preds\n\nThe sbitmap.h functions also needed their numeric paramter changed\nfrom unsigned int to int to match the bitmap functions.\n\nCallers updated to match.\n\nTested on x86-64, config-list.mk testing.\n\n\nIndex: gcc/ChangeLog\n\n2012-11-01  Lawrence Crowl  <crowl@google.com>\n\n\t* sbitmap.h (TEST_BIT): Rename bitmap_bit_p, normalizing parameter\n\ttype. Update callers to match.\n\t(SET_BIT): Rename bitmap_set_bit, normalizing parameter type. Update\n\tcallers to match.\n\t(SET_BIT_WITH_POPCOUNT): Rename bitmap_set_bit_with_popcount,\n\tnormalizing parameter type. Update callers to match.\n\t(RESET_BIT): Rename bitmap_clear_bit, normalizing parameter type.\n\tUpdate callers to match.\n\t(RESET_BIT_WITH_POPCOUNT): Rename bitmap_clear_bit_with_popcount,\n\tnormalizing parameter type. Update callers to match.\n\t* basic-block.h (sbitmap_intersection_of_succs): Rename\n\tbitmap_intersection_of_succs. Update callers to match.\n\t* basic-block.h (sbitmap_intersection_of_preds): Rename\n\tbitmap_intersection_of_preds. Update callers to match.\n\t* basic-block.h (sbitmap_union_of_succs): Rename\n\tbitmap_union_of_succs. Update callers to match.\n\t* basic-block.h (sbitmap_union_of_preds): Rename\n\tbitmap_union_of_preds. Update callers to match.\n\nFrom-SVN: r193066", "tree": {"sha": "5ec5bcd56906f1ff213b4652971a165736d6fda7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ec5bcd56906f1ff213b4652971a165736d6fda7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7c028c07b1998cc80f67e053c8131cf8b387af7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7c028c07b1998cc80f67e053c8131cf8b387af7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7c028c07b1998cc80f67e053c8131cf8b387af7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7c028c07b1998cc80f67e053c8131cf8b387af7/comments", "author": null, "committer": null, "parents": [{"sha": "6cd1dd26753a93d9916335a6f698857915d273c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cd1dd26753a93d9916335a6f698857915d273c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cd1dd26753a93d9916335a6f698857915d273c2"}], "stats": {"total": 951, "additions": 484, "deletions": 467}, "files": [{"sha": "b78d04268cdebd10e65fcac34d2a3f0bc9866542", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -1,3 +1,24 @@\n+2012-11-01  Lawrence Crowl  <crowl@google.com>\n+\n+\t* sbitmap.h (TEST_BIT): Rename bitmap_bit_p, normalizing parameter\n+\ttype. Update callers to match.\n+\t(SET_BIT): Rename bitmap_set_bit, normalizing parameter type. Update\n+\tcallers to match.\n+\t(SET_BIT_WITH_POPCOUNT): Rename bitmap_set_bit_with_popcount,\n+\tnormalizing parameter type. Update callers to match.\n+\t(RESET_BIT): Rename bitmap_clear_bit, normalizing parameter type.\n+\tUpdate callers to match.\n+\t(RESET_BIT_WITH_POPCOUNT): Rename bitmap_clear_bit_with_popcount,\n+\tnormalizing parameter type. Update callers to match.\n+\t* basic-block.h (sbitmap_intersection_of_succs): Rename\n+\tbitmap_intersection_of_succs. Update callers to match.\n+\t* basic-block.h (sbitmap_intersection_of_preds): Rename\n+\tbitmap_intersection_of_preds. Update callers to match.\n+\t* basic-block.h (sbitmap_union_of_succs): Rename\n+\tbitmap_union_of_succs. Update callers to match.\n+\t* basic-block.h (sbitmap_union_of_preds): Rename\n+\tbitmap_union_of_preds. Update callers to match.\n+\n 2012-11-01  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR middle-end/55150"}, {"sha": "b42f9d71db41c8eb0bf94289802f381903b06e9e", "filename": "gcc/alias.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -1245,7 +1245,7 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n     {\n       while (--n >= 0)\n \t{\n-\t  SET_BIT (reg_seen, regno + n);\n+\t  bitmap_set_bit (reg_seen, regno + n);\n \t  new_reg_base_value[regno + n] = 0;\n \t}\n       return;\n@@ -1266,12 +1266,12 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n   else\n     {\n       /* There's a REG_NOALIAS note against DEST.  */\n-      if (TEST_BIT (reg_seen, regno))\n+      if (bitmap_bit_p (reg_seen, regno))\n \t{\n \t  new_reg_base_value[regno] = 0;\n \t  return;\n \t}\n-      SET_BIT (reg_seen, regno);\n+      bitmap_set_bit (reg_seen, regno);\n       new_reg_base_value[regno] = unique_base_value (unique_id++);\n       return;\n     }\n@@ -1327,10 +1327,10 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n       }\n   /* If this is the first set of a register, record the value.  */\n   else if ((regno >= FIRST_PSEUDO_REGISTER || ! fixed_regs[regno])\n-\t   && ! TEST_BIT (reg_seen, regno) && new_reg_base_value[regno] == 0)\n+\t   && ! bitmap_bit_p (reg_seen, regno) && new_reg_base_value[regno] == 0)\n     new_reg_base_value[regno] = find_base_value (src);\n \n-  SET_BIT (reg_seen, regno);\n+  bitmap_set_bit (reg_seen, regno);\n }\n \n /* Return REG_BASE_VALUE for REGNO.  Selective scheduler uses this to avoid\n@@ -1377,7 +1377,7 @@ get_reg_known_equiv_p (unsigned int regno)\n     {\n       regno -= FIRST_PSEUDO_REGISTER;\n       if (regno < VEC_length (rtx, reg_known_value))\n-\treturn TEST_BIT (reg_known_equiv_p, regno);\n+\treturn bitmap_bit_p (reg_known_equiv_p, regno);\n     }\n   return false;\n }\n@@ -1391,9 +1391,9 @@ set_reg_known_equiv_p (unsigned int regno, bool val)\n       if (regno < VEC_length (rtx, reg_known_value))\n \t{\n \t  if (val)\n-\t    SET_BIT (reg_known_equiv_p, regno);\n+\t    bitmap_set_bit (reg_known_equiv_p, regno);\n \t  else\n-\t    RESET_BIT (reg_known_equiv_p, regno);\n+\t    bitmap_clear_bit (reg_known_equiv_p, regno);\n \t}\n     }\n }"}, {"sha": "7d17af5dcfa2aa2372102829d0cb4a65b246556b", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -717,10 +717,10 @@ ei_cond (edge_iterator ei, edge *p)\n #define CLEANUP_CFG_CHANGED\t64      /* The caller changed the CFG.  */\n \n /* In cfganal.c */\n-extern void sbitmap_intersection_of_succs (sbitmap, sbitmap *, basic_block);\n-extern void sbitmap_intersection_of_preds (sbitmap, sbitmap *, basic_block);\n-extern void sbitmap_union_of_succs (sbitmap, sbitmap *, basic_block);\n-extern void sbitmap_union_of_preds (sbitmap, sbitmap *, basic_block);\n+extern void bitmap_intersection_of_succs (sbitmap, sbitmap *, basic_block);\n+extern void bitmap_intersection_of_preds (sbitmap, sbitmap *, basic_block);\n+extern void bitmap_union_of_succs (sbitmap, sbitmap *, basic_block);\n+extern void bitmap_union_of_preds (sbitmap, sbitmap *, basic_block);\n \n /* In lcm.c */\n extern struct edge_list *pre_edge_lcm (int, sbitmap *, sbitmap *,"}, {"sha": "23dc997ca489dd86810e4ecf6917b274ddc883c4", "filename": "gcc/bt-load.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -500,10 +500,10 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n \t\t  SET_HARD_REG_BIT (info.btrs_live_in_block, regno);\n \t\t  bitmap_and_compl (bb_gen[i], bb_gen[i],\n \t\t\t\t      btr_defset[regno - first_btr]);\n-\t\t  SET_BIT (bb_gen[i], insn_uid);\n+\t\t  bitmap_set_bit (bb_gen[i], insn_uid);\n \t\t  def->next_this_bb = defs_this_bb;\n \t\t  defs_this_bb = def;\n-\t\t  SET_BIT (btr_defset[regno - first_btr], insn_uid);\n+\t\t  bitmap_set_bit (btr_defset[regno - first_btr], insn_uid);\n \t\t  note_other_use_this_block (regno, info.users_this_bb);\n \t\t}\n \t      /* Check for the blockage emitted by expand_nl_goto_receiver.  */\n@@ -652,7 +652,7 @@ compute_out (sbitmap *bb_out, sbitmap *bb_gen, sbitmap *bb_kill, int max_uid)\n       changed = 0;\n       for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n \t{\n-\t  sbitmap_union_of_preds (bb_in, bb_out, BASIC_BLOCK (i));\n+\t  bitmap_union_of_preds (bb_in, bb_out, BASIC_BLOCK (i));\n \t  changed |= bitmap_ior_and_compl (bb_out[i], bb_gen[i],\n \t\t\t\t\t       bb_in, bb_kill[i]);\n \t}\n@@ -675,7 +675,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n       rtx insn;\n       rtx last;\n \n-      sbitmap_union_of_preds (reaching_defs, bb_out, BASIC_BLOCK (i));\n+      bitmap_union_of_preds (reaching_defs, bb_out, BASIC_BLOCK (i));\n       for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb));\n \t   insn != last;\n \t   insn = NEXT_INSN (insn))\n@@ -692,7 +692,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t\t     for this one.  */\n \t\t  bitmap_and_compl (reaching_defs, reaching_defs,\n \t\t\t\t      btr_defset[def->btr - first_btr]);\n-\t\t  SET_BIT(reaching_defs, insn_uid);\n+\t\t  bitmap_set_bit(reaching_defs, insn_uid);\n \t\t}\n \n \t      if (user != NULL)"}, {"sha": "18b52487512716735e5bbfecfb133da279773393", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -1846,7 +1846,7 @@ mem_overlaps_already_clobbered_arg_p (rtx addr, unsigned HOST_WIDE_INT size)\n \n       for (k = 0; k < size; k++)\n \tif (i + k < SBITMAP_SIZE (stored_args_map)\n-\t    && TEST_BIT (stored_args_map, i + k))\n+\t    && bitmap_bit_p (stored_args_map, i + k))\n \t  return true;\n     }\n \n@@ -2133,7 +2133,7 @@ check_sibcall_argument_overlap (rtx insn, struct arg_data *arg, int mark_stored_\n #endif\n \n       for (high = low + arg->locate.size.constant; low < high; low++)\n-\tSET_BIT (stored_args_map, low);\n+\tbitmap_set_bit (stored_args_map, low);\n     }\n   return insn != NULL_RTX;\n }"}, {"sha": "ac448d38c2761cde1393fbb47fd2b10275927dc0", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -289,11 +289,11 @@ cached_make_edge (sbitmap edge_cache, basic_block src, basic_block dst, int flag\n     return make_edge (src, dst, flags);\n \n   /* Does the requested edge already exist?  */\n-  if (! TEST_BIT (edge_cache, dst->index))\n+  if (! bitmap_bit_p (edge_cache, dst->index))\n     {\n       /* The edge does not exist.  Create one and update the\n \t cache.  */\n-      SET_BIT (edge_cache, dst->index);\n+      bitmap_set_bit (edge_cache, dst->index);\n       return unchecked_make_edge (src, dst, flags);\n     }\n "}, {"sha": "214e468d46e0b9fb0f8a9ae20caa076e55e5c26c", "filename": "gcc/cfganal.c", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -102,10 +102,10 @@ mark_dfs_back_edges (void)\n       ei_edge (ei)->flags &= ~EDGE_DFS_BACK;\n \n       /* Check if the edge destination has been visited yet.  */\n-      if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n+      if (dest != EXIT_BLOCK_PTR && ! bitmap_bit_p (visited, dest->index))\n \t{\n \t  /* Mark that we have visited the destination.  */\n-\t  SET_BIT (visited, dest->index);\n+\t  bitmap_set_bit (visited, dest->index);\n \n \t  pre[dest->index] = prenum++;\n \t  if (EDGE_COUNT (dest->succs) > 0)\n@@ -518,10 +518,10 @@ post_order_compute (int *post_order, bool include_entry_exit,\n       dest = ei_edge (ei)->dest;\n \n       /* Check if the edge destination has been visited yet.  */\n-      if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n+      if (dest != EXIT_BLOCK_PTR && ! bitmap_bit_p (visited, dest->index))\n \t{\n \t  /* Mark that we have visited the destination.  */\n-\t  SET_BIT (visited, dest->index);\n+\t  bitmap_set_bit (visited, dest->index);\n \n \t  if (EDGE_COUNT (dest->succs) > 0)\n \t    /* Since the DEST node has been visited for the first\n@@ -560,7 +560,7 @@ post_order_compute (int *post_order, bool include_entry_exit,\n \t{\n \t  next_bb = b->next_bb;\n \n-\t  if (!(TEST_BIT (visited, b->index)))\n+\t  if (!(bitmap_bit_p (visited, b->index)))\n \t    delete_basic_block (b);\n \t}\n \n@@ -664,7 +664,7 @@ inverted_post_order_compute (int *post_order)\n         if (EDGE_COUNT (bb->preds) > 0)\n           {\n             stack[sp++] = ei_start (bb->preds);\n-            SET_BIT (visited, bb->index);\n+            bitmap_set_bit (visited, bb->index);\n           }\n       }\n \n@@ -684,10 +684,10 @@ inverted_post_order_compute (int *post_order)\n           pred = ei_edge (ei)->src;\n \n           /* Check if the predecessor has been visited yet.  */\n-          if (! TEST_BIT (visited, pred->index))\n+          if (! bitmap_bit_p (visited, pred->index))\n             {\n               /* Mark that we have visited the destination.  */\n-              SET_BIT (visited, pred->index);\n+              bitmap_set_bit (visited, pred->index);\n \n               if (EDGE_COUNT (pred->preds) > 0)\n                 /* Since the predecessor node has been visited for the first\n@@ -712,7 +712,7 @@ inverted_post_order_compute (int *post_order)\n          Note that this doesn't check EXIT_BLOCK itself\n          since EXIT_BLOCK is always added after the outer do-while loop.  */\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n-        if (!TEST_BIT (visited, bb->index))\n+        if (!bitmap_bit_p (visited, bb->index))\n           {\n             has_unvisited_bb = true;\n \n@@ -725,15 +725,15 @@ inverted_post_order_compute (int *post_order)\n                 /* Find an already visited predecessor.  */\n                 FOR_EACH_EDGE (e, ei, bb->preds)\n                   {\n-                    if (TEST_BIT (visited, e->src->index))\n+                    if (bitmap_bit_p (visited, e->src->index))\n                       visited_pred = e->src;\n                   }\n \n                 if (visited_pred)\n                   {\n                     basic_block be = dfs_find_deadend (bb);\n                     gcc_assert (be != NULL);\n-                    SET_BIT (visited, be->index);\n+                    bitmap_set_bit (visited, be->index);\n                     stack[sp++] = ei_start (be->preds);\n                     break;\n                   }\n@@ -746,7 +746,7 @@ inverted_post_order_compute (int *post_order)\n              Find a dead-end from the ENTRY, and restart the iteration. */\n           basic_block be = dfs_find_deadend (ENTRY_BLOCK_PTR);\n           gcc_assert (be != NULL);\n-          SET_BIT (visited, be->index);\n+          bitmap_set_bit (visited, be->index);\n           stack[sp++] = ei_start (be->preds);\n         }\n \n@@ -820,10 +820,10 @@ pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order,\n       dest = ei_edge (ei)->dest;\n \n       /* Check if the edge destination has been visited yet.  */\n-      if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n+      if (dest != EXIT_BLOCK_PTR && ! bitmap_bit_p (visited, dest->index))\n \t{\n \t  /* Mark that we have visited the destination.  */\n-\t  SET_BIT (visited, dest->index);\n+\t  bitmap_set_bit (visited, dest->index);\n \n \t  if (pre_order)\n \t    pre_order[pre_order_num] = dest->index;\n@@ -929,7 +929,7 @@ static void\n flow_dfs_compute_reverse_add_bb (depth_first_search_ds data, basic_block bb)\n {\n   data->stack[data->sp++] = bb;\n-  SET_BIT (data->visited_blocks, bb->index);\n+  bitmap_set_bit (data->visited_blocks, bb->index);\n }\n \n /* Continue the depth-first search through the reverse graph starting with the\n@@ -951,13 +951,13 @@ flow_dfs_compute_reverse_execute (depth_first_search_ds data,\n \n       /* Perform depth-first search on adjacent vertices.  */\n       FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (!TEST_BIT (data->visited_blocks, e->src->index))\n+\tif (!bitmap_bit_p (data->visited_blocks, e->src->index))\n \t  flow_dfs_compute_reverse_add_bb (data, e->src);\n     }\n \n   /* Determine if there are unvisited basic blocks.  */\n   FOR_BB_BETWEEN (bb, last_unvisited, NULL, prev_bb)\n-    if (!TEST_BIT (data->visited_blocks, bb->index))\n+    if (!bitmap_bit_p (data->visited_blocks, bb->index))\n       return dfs_find_deadend (bb);\n \n   return NULL;\n@@ -993,9 +993,9 @@ dfs_enumerate_from (basic_block bb, int reverse,\n   static sbitmap visited;\n   static unsigned v_size;\n \n-#define MARK_VISITED(BB) (SET_BIT (visited, (BB)->index))\n-#define UNMARK_VISITED(BB) (RESET_BIT (visited, (BB)->index))\n-#define VISITED_P(BB) (TEST_BIT (visited, (BB)->index))\n+#define MARK_VISITED(BB) (bitmap_set_bit (visited, (BB)->index))\n+#define UNMARK_VISITED(BB) (bitmap_clear_bit (visited, (BB)->index))\n+#define VISITED_P(BB) (bitmap_bit_p (visited, (BB)->index))\n \n   /* Resize the VISITED sbitmap if necessary.  */\n   size = last_basic_block;\n@@ -1193,8 +1193,7 @@ compute_idf (bitmap def_blocks, bitmap_head *dfs)\n    basic block B.  */\n \n void\n-sbitmap_intersection_of_succs (sbitmap dst, sbitmap *src,\n-\t\t\t       basic_block b)\n+bitmap_intersection_of_succs (sbitmap dst, sbitmap *src, basic_block b)\n {\n   unsigned int set_size = dst->size;\n   edge e;\n@@ -1235,8 +1234,7 @@ sbitmap_intersection_of_succs (sbitmap dst, sbitmap *src,\n    basic block B.  */\n \n void\n-sbitmap_intersection_of_preds (sbitmap dst, sbitmap *src,\n-\t\t\t       basic_block b)\n+bitmap_intersection_of_preds (sbitmap dst, sbitmap *src, basic_block b)\n {\n   unsigned int set_size = dst->size;\n   edge e;\n@@ -1277,8 +1275,7 @@ sbitmap_intersection_of_preds (sbitmap dst, sbitmap *src,\n    basic block B.  */\n \n void\n-sbitmap_union_of_succs (sbitmap dst, sbitmap *src,\n-\t\t\tbasic_block b)\n+bitmap_union_of_succs (sbitmap dst, sbitmap *src, basic_block b)\n {\n   unsigned int set_size = dst->size;\n   edge e;\n@@ -1319,8 +1316,7 @@ sbitmap_union_of_succs (sbitmap dst, sbitmap *src,\n    basic block B.  */\n \n void\n-sbitmap_union_of_preds (sbitmap dst, sbitmap *src,\n-\t\t\tbasic_block b)\n+bitmap_union_of_preds (sbitmap dst, sbitmap *src, basic_block b)\n {\n   unsigned int set_size = dst->size;\n   edge e;"}, {"sha": "bc06f72d87a4c7d48274a745a53f07b0f294c811", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -241,7 +241,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n \t    {\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\tif (e->dest != EXIT_BLOCK_PTR)\n-\t\t  SET_BIT (edge_cache, e->dest->index);\n+\t\t  bitmap_set_bit (edge_cache, e->dest->index);\n \t    }\n \t}\n \n@@ -605,7 +605,7 @@ find_many_sub_basic_blocks (sbitmap blocks)\n \n   FOR_EACH_BB (bb)\n     SET_STATE (bb,\n-\t       TEST_BIT (blocks, bb->index) ? BLOCK_TO_SPLIT : BLOCK_ORIGINAL);\n+\t       bitmap_bit_p (blocks, bb->index) ? BLOCK_TO_SPLIT : BLOCK_ORIGINAL);\n \n   FOR_EACH_BB (bb)\n     if (STATE (bb) == BLOCK_TO_SPLIT)"}, {"sha": "5ab7c201688eee9b2c6c03bc50fb18e3a6e36067", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -420,7 +420,7 @@ flow_loops_find (struct loops *loops)\n \t      && dominated_by_p (CDI_DOMINATORS, latch, header))\n \t    {\n \t      /* Shared headers should be eliminated by now.  */\n-\t      SET_BIT (headers, header->index);\n+\t      bitmap_set_bit (headers, header->index);\n \t      num_loops++;\n \t    }\n \t}\n@@ -451,7 +451,7 @@ flow_loops_find (struct loops *loops)\n \n \t  /* Search the nodes of the CFG in reverse completion order\n \t     so that we can find outer loops first.  */\n-\t  if (!TEST_BIT (headers, rc_order[b]))\n+\t  if (!bitmap_bit_p (headers, rc_order[b]))\n \t    continue;\n \n \t  header = BASIC_BLOCK (rc_order[b]);\n@@ -1361,9 +1361,9 @@ verify_loop_structure (void)\n \t  bb = bbs[j];\n \n \t  /* Ignore this block if it is in an inner loop.  */\n-\t  if (TEST_BIT (visited, bb->index))\n+\t  if (bitmap_bit_p (visited, bb->index))\n \t    continue;\n-\t  SET_BIT (visited, bb->index);\n+\t  bitmap_set_bit (visited, bb->index);\n \n \t  if (bb->loop_father != loop)\n \t    {\n@@ -1426,9 +1426,9 @@ verify_loop_structure (void)\n \t{\n \t  edge_iterator ei;\n \t  if (bb->flags & BB_IRREDUCIBLE_LOOP)\n-\t    SET_BIT (irreds, bb->index);\n+\t    bitmap_set_bit (irreds, bb->index);\n \t  else\n-\t    RESET_BIT (irreds, bb->index);\n+\t    bitmap_clear_bit (irreds, bb->index);\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n \t      e->flags |= EDGE_ALL_FLAGS + 1;\n@@ -1443,13 +1443,13 @@ verify_loop_structure (void)\n \t  edge_iterator ei;\n \n \t  if ((bb->flags & BB_IRREDUCIBLE_LOOP)\n-\t      && !TEST_BIT (irreds, bb->index))\n+\t      && !bitmap_bit_p (irreds, bb->index))\n \t    {\n \t      error (\"basic block %d should be marked irreducible\", bb->index);\n \t      err = 1;\n \t    }\n \t  else if (!(bb->flags & BB_IRREDUCIBLE_LOOP)\n-\t      && TEST_BIT (irreds, bb->index))\n+\t      && bitmap_bit_p (irreds, bb->index))\n \t    {\n \t      error (\"basic block %d should not be marked irreducible\", bb->index);\n \t      err = 1;"}, {"sha": "e6c6dbf5105b938b66d7add0f7967b371399b6dc", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -191,9 +191,9 @@ fix_bb_placements (basic_block from,\n \n   in_queue = sbitmap_alloc (last_basic_block);\n   bitmap_clear (in_queue);\n-  SET_BIT (in_queue, from->index);\n+  bitmap_set_bit (in_queue, from->index);\n   /* Prevent us from going out of the base_loop.  */\n-  SET_BIT (in_queue, base_loop->header->index);\n+  bitmap_set_bit (in_queue, base_loop->header->index);\n \n   queue = XNEWVEC (basic_block, base_loop->num_nodes + 1);\n   qtop = queue + base_loop->num_nodes + 1;\n@@ -208,7 +208,7 @@ fix_bb_placements (basic_block from,\n       qbeg++;\n       if (qbeg == qtop)\n \tqbeg = queue;\n-      RESET_BIT (in_queue, from->index);\n+      bitmap_clear_bit (in_queue, from->index);\n \n       if (from->loop_father->header == from)\n \t{\n@@ -242,7 +242,7 @@ fix_bb_placements (basic_block from,\n \t  if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n \t    *irred_invalidated = true;\n \n-\t  if (TEST_BIT (in_queue, pred->index))\n+\t  if (bitmap_bit_p (in_queue, pred->index))\n \t    continue;\n \n \t  /* If it is subloop, then it either was not moved, or\n@@ -262,15 +262,15 @@ fix_bb_placements (basic_block from,\n \t      continue;\n \t    }\n \n-\t  if (TEST_BIT (in_queue, pred->index))\n+\t  if (bitmap_bit_p (in_queue, pred->index))\n \t    continue;\n \n \t  /* Schedule the basic block.  */\n \t  *qend = pred;\n \t  qend++;\n \t  if (qend == qtop)\n \t    qend = queue;\n-\t  SET_BIT (in_queue, pred->index);\n+\t  bitmap_set_bit (in_queue, pred->index);\n \t}\n     }\n   free (in_queue);\n@@ -331,19 +331,19 @@ remove_path (edge e)\n \n   /* Find \"border\" hexes -- i.e. those with predecessor in removed path.  */\n   for (i = 0; i < nrem; i++)\n-    SET_BIT (seen, rem_bbs[i]->index);\n+    bitmap_set_bit (seen, rem_bbs[i]->index);\n   if (!irred_invalidated)\n     FOR_EACH_EDGE (ae, ei, e->src->succs)\n-      if (ae != e && ae->dest != EXIT_BLOCK_PTR && !TEST_BIT (seen, ae->dest->index)\n+      if (ae != e && ae->dest != EXIT_BLOCK_PTR && !bitmap_bit_p (seen, ae->dest->index)\n \t  && ae->flags & EDGE_IRREDUCIBLE_LOOP)\n \tirred_invalidated = true;\n   for (i = 0; i < nrem; i++)\n     {\n       bb = rem_bbs[i];\n       FOR_EACH_EDGE (ae, ei, rem_bbs[i]->succs)\n-\tif (ae->dest != EXIT_BLOCK_PTR && !TEST_BIT (seen, ae->dest->index))\n+\tif (ae->dest != EXIT_BLOCK_PTR && !bitmap_bit_p (seen, ae->dest->index))\n \t  {\n-\t    SET_BIT (seen, ae->dest->index);\n+\t    bitmap_set_bit (seen, ae->dest->index);\n \t    bord_bbs[n_bord_bbs++] = ae->dest;\n \n \t    if (ae->flags & EDGE_IRREDUCIBLE_LOOP)\n@@ -371,9 +371,9 @@ remove_path (edge e)\n       basic_block ldom;\n \n       bb = get_immediate_dominator (CDI_DOMINATORS, bord_bbs[i]);\n-      if (TEST_BIT (seen, bb->index))\n+      if (bitmap_bit_p (seen, bb->index))\n \tcontinue;\n-      SET_BIT (seen, bb->index);\n+      bitmap_set_bit (seen, bb->index);\n \n       for (ldom = first_dom_son (CDI_DOMINATORS, bb);\n \t   ldom;\n@@ -598,7 +598,7 @@ update_dominators_in_loop (struct loop *loop)\n   body = get_loop_body (loop);\n \n   for (i = 0; i < loop->num_nodes; i++)\n-    SET_BIT (seen, body[i]->index);\n+    bitmap_set_bit (seen, body[i]->index);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n@@ -607,9 +607,9 @@ update_dominators_in_loop (struct loop *loop)\n       for (ldom = first_dom_son (CDI_DOMINATORS, body[i]);\n \t   ldom;\n \t   ldom = next_dom_son (CDI_DOMINATORS, ldom))\n-\tif (!TEST_BIT (seen, ldom->index))\n+\tif (!bitmap_bit_p (seen, ldom->index))\n \t  {\n-\t    SET_BIT (seen, ldom->index);\n+\t    bitmap_set_bit (seen, ldom->index);\n \t    VEC_safe_push (basic_block, heap, dom_bbs, ldom);\n \t  }\n     }\n@@ -1206,7 +1206,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n       scale_step = XNEWVEC (int, ndupl);\n \n       for (i = 1; i <= ndupl; i++)\n-\tscale_step[i - 1] = TEST_BIT (wont_exit, i)\n+\tscale_step[i - 1] = bitmap_bit_p (wont_exit, i)\n \t\t\t\t? prob_pass_wont_exit\n \t\t\t\t: prob_pass_thru;\n \n@@ -1233,7 +1233,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t}\n       else if (is_latch)\n \t{\n-\t  prob_pass_main = TEST_BIT (wont_exit, 0)\n+\t  prob_pass_main = bitmap_bit_p (wont_exit, 0)\n \t\t\t\t? prob_pass_wont_exit\n \t\t\t\t: prob_pass_thru;\n \t  p = prob_pass_main;\n@@ -1342,7 +1342,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t}\n \n       /* Record exit edge in this copy.  */\n-      if (orig && TEST_BIT (wont_exit, j + 1))\n+      if (orig && bitmap_bit_p (wont_exit, j + 1))\n \t{\n \t  if (to_remove)\n \t    VEC_safe_push (edge, heap, *to_remove, new_spec_edges[SE_ORIG]);\n@@ -1378,7 +1378,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   free (orig_loops);\n \n   /* Record the exit edge in the original loop body, and update the frequencies.  */\n-  if (orig && TEST_BIT (wont_exit, 0))\n+  if (orig && bitmap_bit_p (wont_exit, 0))\n     {\n       if (to_remove)\n \tVEC_safe_push (edge, heap, *to_remove, orig);"}, {"sha": "9156ee8756dd1a9233449ab252ae6534365b6efa", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -3734,7 +3734,7 @@ break_superblocks (void)\n     if (bb->flags & BB_SUPERBLOCK)\n       {\n \tbb->flags &= ~BB_SUPERBLOCK;\n-\tSET_BIT (superblocks, bb->index);\n+\tbitmap_set_bit (superblocks, bb->index);\n \tneed = true;\n       }\n \n@@ -4255,7 +4255,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n   if (! blocks)\n     check_last_block = true;\n   else\n-    check_last_block = TEST_BIT (blocks, EXIT_BLOCK_PTR->prev_bb->index);\n+    check_last_block = bitmap_bit_p (blocks, EXIT_BLOCK_PTR->prev_bb->index);\n \n   /* In the last basic block, before epilogue generation, there will be\n      a fallthru edge to EXIT.  Special care is required if the last insn\n@@ -4305,7 +4305,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n       if (!bb)\n \tcontinue;\n \n-      if (blocks && !TEST_BIT (blocks, i))\n+      if (blocks && !bitmap_bit_p (blocks, i))\n \tcontinue;\n \n       for (insn = BB_END (bb); ; insn = prev_insn)"}, {"sha": "ec0dfcc00ca98919bb114b32c5d3cf0b441762b1", "filename": "gcc/config/epiphany/resolve-sw-modes.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -99,7 +99,7 @@ resolve_sw_modes (void)\n \t    selected_mode = (enum attr_fp_mode) epiphany_normal_fp_rounding;\n \n \t    VEC_quick_push (basic_block, todo, bb);\n-\t    SET_BIT (pushed, bb->index);\n+\t    bitmap_set_bit (pushed, bb->index);\n \t  }\n \tXVECEXP (XEXP (src, 0), 0, 0) = GEN_INT (selected_mode);\n \tSET_SRC (XVECEXP (PATTERN (insn), 0, 1)) = copy_rtx (src);\n@@ -114,8 +114,8 @@ resolve_sw_modes (void)\n       edge e;\n       edge_iterator ei;\n \n-      SET_BIT (pushed, bb->index);\n-      SET_BIT (pushed, bb->index);\n+      bitmap_set_bit (pushed, bb->index);\n+      bitmap_set_bit (pushed, bb->index);\n \n       if (epiphany_normal_fp_rounding == FP_MODE_ROUND_NEAREST)\n \t{\n@@ -139,10 +139,10 @@ resolve_sw_modes (void)\n \t    continue;\n \t  if (REGNO_REG_SET_P (DF_LIVE_IN (succ), selected_reg))\n \t    {\n-\t      if (TEST_BIT (pushed, succ->index))\n+\t      if (bitmap_bit_p (pushed, succ->index))\n \t\tcontinue;\n \t      VEC_quick_push (basic_block, todo, succ);\n-\t      SET_BIT (pushed, bb->index);\n+\t      bitmap_set_bit (pushed, bb->index);\n \t      continue;\n \t    }\n \t  start_sequence ();"}, {"sha": "b389c098adfb92afb43dfe3d6d036b3c8c98ad60", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -407,7 +407,7 @@ move_or_delete_vzeroupper (void)\n   bitmap_ones (in_pending);\n   FOR_EACH_BB (bb)\n     if (BLOCK_INFO (bb)->processed)\n-      RESET_BIT (in_pending, bb->index);\n+      bitmap_clear_bit (in_pending, bb->index);\n     else\n       {\n \tmove_or_delete_vzeroupper_1 (bb, false);\n@@ -433,13 +433,13 @@ move_or_delete_vzeroupper (void)\n       while (!fibheap_empty (worklist))\n \t{\n \t  bb = (basic_block) fibheap_extract_min (worklist);\n-\t  RESET_BIT (in_worklist, bb->index);\n-\t  gcc_assert (!TEST_BIT (visited, bb->index));\n-\t  if (!TEST_BIT (visited, bb->index))\n+\t  bitmap_clear_bit (in_worklist, bb->index);\n+\t  gcc_assert (!bitmap_bit_p (visited, bb->index));\n+\t  if (!bitmap_bit_p (visited, bb->index))\n \t    {\n \t      edge_iterator ei;\n \n-\t      SET_BIT (visited, bb->index);\n+\t      bitmap_set_bit (visited, bb->index);\n \n \t      if (move_or_delete_vzeroupper_1 (bb, false))\n \t\tFOR_EACH_EDGE (e, ei, bb->succs)\n@@ -448,21 +448,21 @@ move_or_delete_vzeroupper (void)\n \t\t\t|| BLOCK_INFO (e->dest)->processed)\n \t\t      continue;\n \n-\t\t    if (TEST_BIT (visited, e->dest->index))\n+\t\t    if (bitmap_bit_p (visited, e->dest->index))\n \t\t      {\n-\t\t\tif (!TEST_BIT (in_pending, e->dest->index))\n+\t\t\tif (!bitmap_bit_p (in_pending, e->dest->index))\n \t\t\t  {\n \t\t\t    /* Send E->DEST to next round.  */\n-\t\t\t    SET_BIT (in_pending, e->dest->index);\n+\t\t\t    bitmap_set_bit (in_pending, e->dest->index);\n \t\t\t    fibheap_insert (pending,\n \t\t\t\t\t    bb_order[e->dest->index],\n \t\t\t\t\t    e->dest);\n \t\t\t  }\n \t\t      }\n-\t\t    else if (!TEST_BIT (in_worklist, e->dest->index))\n+\t\t    else if (!bitmap_bit_p (in_worklist, e->dest->index))\n \t\t      {\n \t\t\t/* Add E->DEST to current round.  */\n-\t\t\tSET_BIT (in_worklist, e->dest->index);\n+\t\t\tbitmap_set_bit (in_worklist, e->dest->index);\n \t\t\tfibheap_insert (worklist, bb_order[e->dest->index],\n \t\t\t\t\te->dest);\n \t\t      }\n@@ -24740,7 +24740,7 @@ core2i7_first_cycle_multipass_filter_ready_try\n \t  ready_try[n_ready] = 1;\n \n \t  if (data->ready_try_change)\n-\t    SET_BIT (data->ready_try_change, n_ready);\n+\t    bitmap_set_bit (data->ready_try_change, n_ready);\n \t}\n     }\n }"}, {"sha": "01f6b6176e1efc9c9ffd7beaf66ccc098686ec3c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -14799,7 +14799,7 @@ r10k_protected_bb_p (basic_block bb, sbitmap protected_bbs)\n \n   FOR_EACH_EDGE (e, ei, bb->preds)\n     if (!single_succ_p (e->src)\n-\t|| !TEST_BIT (protected_bbs, e->src->index)\n+\t|| !bitmap_bit_p (protected_bbs, e->src->index)\n \t|| (e->flags & EDGE_COMPLEX) != 0)\n       return false;\n   return true;\n@@ -14893,7 +14893,7 @@ r10k_insert_cache_barriers (void)\n \n       /* Record whether the end of this block is protected.  */\n       if (unprotected_region == NULL_RTX)\n-\tSET_BIT (protected_bbs, bb->index);\n+\tbitmap_set_bit (protected_bbs, bb->index);\n     }\n   XDELETEVEC (rev_post_order);\n "}, {"sha": "82fb4340cf539009b9f5f381283420cdfec13a0d", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -2102,7 +2102,7 @@ spu_emit_branch_hint (rtx before, rtx branch, rtx target,\n   LABEL_PRESERVE_P (branch_label) = 1;\n   insn = emit_label_before (branch_label, branch);\n   branch_label = gen_rtx_LABEL_REF (VOIDmode, branch_label);\n-  SET_BIT (blocks, BLOCK_FOR_INSN (branch)->index);\n+  bitmap_set_bit (blocks, BLOCK_FOR_INSN (branch)->index);\n \n   hint = emit_insn_before (gen_hbr (branch_label, target), before);\n   recog_memoized (hint);"}, {"sha": "56a4f9285f35065ce11eae9d664f71f11a55eecd", "filename": "gcc/cprop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -617,20 +617,20 @@ compute_local_properties (sbitmap *kill, sbitmap *comp,\n \t     is killed in the block where the definition is.  */\n \t  for (def = DF_REG_DEF_CHAIN (REGNO (expr->dest));\n \t       def; def = DF_REF_NEXT_REG (def))\n-\t    SET_BIT (kill[DF_REF_BB (def)->index], indx);\n+\t    bitmap_set_bit (kill[DF_REF_BB (def)->index], indx);\n \n \t  /* If the source is a pseudo-reg, for each definition of the source,\n \t     the expression is killed in the block where the definition is.  */\n \t  if (REG_P (expr->src))\n \t    for (def = DF_REG_DEF_CHAIN (REGNO (expr->src));\n \t\t def; def = DF_REF_NEXT_REG (def))\n-\t      SET_BIT (kill[DF_REF_BB (def)->index], indx);\n+\t      bitmap_set_bit (kill[DF_REF_BB (def)->index], indx);\n \n \t  /* The occurrences recorded in avail_occr are exactly those that\n \t     are locally available in the block where they are.  */\n \t  for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n \t    {\n-\t      SET_BIT (comp[BLOCK_FOR_INSN (occr->insn)->index], indx);\n+\t      bitmap_set_bit (comp[BLOCK_FOR_INSN (occr->insn)->index], indx);\n \t    }\n \t}\n     }\n@@ -658,7 +658,7 @@ compute_cprop_data (void)\n     {\n       int index = implicit_set_indexes[bb->index];\n       if (index != -1)\n-\tSET_BIT (cprop_avin[bb->index], index);\n+\tbitmap_set_bit (cprop_avin[bb->index], index);\n     }\n }\n \f\n@@ -830,7 +830,7 @@ find_avail_set (int regno, rtx insn)\n \t which contains INSN.  */\n       while (set)\n \t{\n-\t  if (TEST_BIT (cprop_avin[BLOCK_FOR_INSN (insn)->index],\n+\t  if (bitmap_bit_p (cprop_avin[BLOCK_FOR_INSN (insn)->index],\n \t\t\tset->bitmap_index))\n \t    break;\n \t  set = next_set (regno, set);\n@@ -1447,7 +1447,7 @@ find_bypass_set (int regno, int bb)\n \n       while (set)\n \t{\n-\t  if (TEST_BIT (cprop_avout[bb], set->bitmap_index))\n+\t  if (bitmap_bit_p (cprop_avout[bb], set->bitmap_index))\n \t    break;\n \t  set = next_set (regno, set);\n \t}"}, {"sha": "4d1d016dcf2e06f4db5ba1d10911795d3572b2e7", "filename": "gcc/cse.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -6151,7 +6151,7 @@ cse_find_path (basic_block first_bb, struct cse_basic_block_data *data,\n   edge e;\n   int path_size;\n \n-  SET_BIT (cse_visited_basic_blocks, first_bb->index);\n+  bitmap_set_bit (cse_visited_basic_blocks, first_bb->index);\n \n   /* See if there is a previous path.  */\n   path_size = data->path_size;\n@@ -6208,9 +6208,9 @@ cse_find_path (basic_block first_bb, struct cse_basic_block_data *data,\n \n \t\t     We still want to visit each basic block only once, so\n \t\t     halt the path here if we have already visited BB.  */\n-\t\t  && !TEST_BIT (cse_visited_basic_blocks, bb->index))\n+\t\t  && !bitmap_bit_p (cse_visited_basic_blocks, bb->index))\n \t\t{\n-\t\t  SET_BIT (cse_visited_basic_blocks, bb->index);\n+\t\t  bitmap_set_bit (cse_visited_basic_blocks, bb->index);\n \t\t  data->path[path_size++].bb = bb;\n \t\t  break;\n \t\t}\n@@ -6253,10 +6253,10 @@ cse_find_path (basic_block first_bb, struct cse_basic_block_data *data,\n \t      && single_pred_p (e->dest)\n \t      /* Avoid visiting basic blocks twice.  The large comment\n \t\t above explains why this can happen.  */\n-\t      && !TEST_BIT (cse_visited_basic_blocks, e->dest->index))\n+\t      && !bitmap_bit_p (cse_visited_basic_blocks, e->dest->index))\n \t    {\n \t      basic_block bb2 = e->dest;\n-\t      SET_BIT (cse_visited_basic_blocks, bb2->index);\n+\t      bitmap_set_bit (cse_visited_basic_blocks, bb2->index);\n \t      data->path[path_size++].bb = bb2;\n \t      bb = bb2;\n \t    }\n@@ -6468,7 +6468,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t\t  /* If we truncate the path, we must also reset the\n \t\t     visited bit on the remaining blocks in the path,\n \t\t     or we will never visit them at all.  */\n-\t\t  RESET_BIT (cse_visited_basic_blocks,\n+\t\t  bitmap_clear_bit (cse_visited_basic_blocks,\n \t\t\t     ebb_data->path[path_size].bb->index);\n \t\t  ebb_data->path[path_size].bb = NULL;\n \t\t}\n@@ -6560,7 +6560,7 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n \t{\n \t  bb = BASIC_BLOCK (rc_order[i++]);\n \t}\n-      while (TEST_BIT (cse_visited_basic_blocks, bb->index)\n+      while (bitmap_bit_p (cse_visited_basic_blocks, bb->index)\n \t     && i < n_blocks);\n \n       /* Find all paths starting with BB, and process them.  */"}, {"sha": "9a87677dc630d8815a040aef479498ab7ef16f9c", "filename": "gcc/dce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -163,7 +163,7 @@ marked_insn_p (rtx insn)\n   /* Artificial defs are always needed and they do not have an insn.\n      We should never see them here.  */\n   gcc_assert (insn);\n-  return TEST_BIT (marked, INSN_UID (insn));\n+  return bitmap_bit_p (marked, INSN_UID (insn));\n }\n \n \n@@ -177,7 +177,7 @@ mark_insn (rtx insn, bool fast)\n     {\n       if (!fast)\n \tVEC_safe_push (rtx, heap, worklist, insn);\n-      SET_BIT (marked, INSN_UID (insn));\n+      bitmap_set_bit (marked, INSN_UID (insn));\n       if (dump_file)\n \tfprintf (dump_file, \"  Adding insn %d to worklist\\n\", INSN_UID (insn));\n       if (CALL_P (insn)"}, {"sha": "6ad61b6f42d5c78076252b32b187c7dd221604b0", "filename": "gcc/ddg.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -562,7 +562,7 @@ build_intra_loop_deps (ddg_ptr g)\n \t\t{\n \t\t  /* Don't bother calculating inter-loop dep if an intra-loop dep\n \t\t     already exists.  */\n-\t      \t  if (! TEST_BIT (dest_node->successors, j))\n+\t      \t  if (! bitmap_bit_p (dest_node->successors, j))\n \t\t    add_inter_loop_mem_dep (g, dest_node, j_node);\n \t\t  /* If -fmodulo-sched-allow-regmoves\n \t\t     is set certain anti-dep edges are not created.\n@@ -572,7 +572,7 @@ build_intra_loop_deps (ddg_ptr g)\n \t\t     memory dependencies.  Thus we add intra edges between\n \t\t     every two memory instructions in this case.  */\n \t\t  if (flag_modulo_sched_allow_regmoves\n-\t\t      && !TEST_BIT (dest_node->predecessors, j))\n+\t\t      && !bitmap_bit_p (dest_node->predecessors, j))\n \t\t    add_intra_loop_mem_dep (g, j_node, dest_node);\n \t\t}\n             }\n@@ -838,8 +838,8 @@ add_edge_to_ddg (ddg_ptr g ATTRIBUTE_UNUSED, ddg_edge_ptr e)\n   /* Should have allocated the sbitmaps.  */\n   gcc_assert (src->successors && dest->predecessors);\n \n-  SET_BIT (src->successors, dest->cuid);\n-  SET_BIT (dest->predecessors, src->cuid);\n+  bitmap_set_bit (src->successors, dest->cuid);\n+  bitmap_set_bit (dest->predecessors, src->cuid);\n   e->next_in = dest->in;\n   dest->in = e;\n   e->next_out = src->out;\n@@ -899,7 +899,7 @@ create_scc (ddg_ptr g, sbitmap nodes)\n       ddg_node_ptr n = &g->nodes[u];\n \n       for (e = n->out; e; e = e->next_out)\n-\tif (TEST_BIT (nodes, e->dest->cuid))\n+\tif (bitmap_bit_p (nodes, e->dest->cuid))\n \t  {\n \t    e->aux.count = IN_SCC;\n \t    if (e->distance > 0)\n@@ -1079,8 +1079,8 @@ create_ddg_all_sccs (ddg_ptr g)\n       bitmap_clear (scc_nodes);\n       bitmap_clear (from);\n       bitmap_clear (to);\n-      SET_BIT (from, dest->cuid);\n-      SET_BIT (to, src->cuid);\n+      bitmap_set_bit (from, dest->cuid);\n+      bitmap_set_bit (to, src->cuid);\n \n       if (find_nodes_on_paths (scc_nodes, g, from, to))\n \t{\n@@ -1151,10 +1151,10 @@ find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n \t      ddg_node_ptr v_node = e->dest;\n \t      int v = v_node->cuid;\n \n-\t      if (!TEST_BIT (reachable_from, v))\n+\t      if (!bitmap_bit_p (reachable_from, v))\n \t\t{\n-\t\t  SET_BIT (reachable_from, v);\n-\t\t  SET_BIT (tmp, v);\n+\t\t  bitmap_set_bit (reachable_from, v);\n+\t\t  bitmap_set_bit (tmp, v);\n \t\t  change = 1;\n \t\t}\n \t    }\n@@ -1180,10 +1180,10 @@ find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n \t      ddg_node_ptr v_node = e->src;\n \t      int v = v_node->cuid;\n \n-\t      if (!TEST_BIT (reach_to, v))\n+\t      if (!bitmap_bit_p (reach_to, v))\n \t\t{\n-\t\t  SET_BIT (reach_to, v);\n-\t\t  SET_BIT (tmp, v);\n+\t\t  bitmap_set_bit (reach_to, v);\n+\t\t  bitmap_set_bit (tmp, v);\n \t\t  change = 1;\n \t\t}\n \t    }\n@@ -1214,12 +1214,12 @@ update_dist_to_successors (ddg_node_ptr u_node, sbitmap nodes, sbitmap tmp)\n       ddg_node_ptr v_node = e->dest;\n       int v = v_node->cuid;\n \n-      if (TEST_BIT (nodes, v)\n+      if (bitmap_bit_p (nodes, v)\n \t  && (e->distance == 0)\n \t  && (v_node->aux.count < u_node->aux.count + e->latency))\n \t{\n \t  v_node->aux.count = u_node->aux.count + e->latency;\n-\t  SET_BIT (tmp, v);\n+\t  bitmap_set_bit (tmp, v);\n \t  result = 1;\n \t}\n     }\n@@ -1248,7 +1248,7 @@ longest_simple_path (struct ddg * g, int src, int dest, sbitmap nodes)\n   g->nodes[src].aux.count = 0;\n \n   bitmap_clear (tmp);\n-  SET_BIT (tmp, src);\n+  bitmap_set_bit (tmp, src);\n \n   while (change)\n     {"}, {"sha": "2bc3d7f9e2302849fd72b6673ae36ac869c87de4", "filename": "gcc/df-core.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -891,7 +891,7 @@ df_worklist_propagate_forward (struct dataflow *dataflow,\n     FOR_EACH_EDGE (e, ei, bb->preds)\n       {\n         if (age <= BB_LAST_CHANGE_AGE (e->src)\n-\t    && TEST_BIT (considered, e->src->index))\n+\t    && bitmap_bit_p (considered, e->src->index))\n           changed |= dataflow->problem->con_fun_n (e);\n       }\n   else if (dataflow->problem->con_fun_0)\n@@ -906,7 +906,7 @@ df_worklist_propagate_forward (struct dataflow *dataflow,\n         {\n           unsigned ob_index = e->dest->index;\n \n-          if (TEST_BIT (considered, ob_index))\n+          if (bitmap_bit_p (considered, ob_index))\n             bitmap_set_bit (pending, bbindex_to_postorder[ob_index]);\n         }\n       return true;\n@@ -936,7 +936,7 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n     FOR_EACH_EDGE (e, ei, bb->succs)\n       {\n         if (age <= BB_LAST_CHANGE_AGE (e->dest)\n-\t    && TEST_BIT (considered, e->dest->index))\n+\t    && bitmap_bit_p (considered, e->dest->index))\n           changed |= dataflow->problem->con_fun_n (e);\n       }\n   else if (dataflow->problem->con_fun_0)\n@@ -951,7 +951,7 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n         {\n           unsigned ob_index = e->src->index;\n \n-          if (TEST_BIT (considered, ob_index))\n+          if (bitmap_bit_p (considered, ob_index))\n             bitmap_set_bit (pending, bbindex_to_postorder[ob_index]);\n         }\n       return true;\n@@ -1086,7 +1086,7 @@ df_worklist_dataflow (struct dataflow *dataflow,\n   bitmap_clear (considered);\n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_consider, 0, index, bi)\n     {\n-      SET_BIT (considered, index);\n+      bitmap_set_bit (considered, index);\n     }\n \n   /* Initialize the mapping of block index to postorder.  */"}, {"sha": "0051144441440059e760a141db37b1b2206610b1", "filename": "gcc/domwalk.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -146,7 +146,7 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n   int sp = 0;\n   sbitmap visited = sbitmap_alloc (last_basic_block + 1);\n   bitmap_clear (visited);\n-  SET_BIT (visited, ENTRY_BLOCK_PTR->index);\n+  bitmap_set_bit (visited, ENTRY_BLOCK_PTR->index);\n \n   while (true)\n     {\n@@ -187,7 +187,7 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t  if (walk_data->before_dom_children)\n \t    (*walk_data->before_dom_children) (walk_data, bb);\n \n-\t  SET_BIT (visited, bb->index);\n+\t  bitmap_set_bit (visited, bb->index);\n \n \t  /* Mark the current BB to be popped out of the recursion stack\n \t     once children are processed.  */\n@@ -233,7 +233,7 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t\tFOR_EACH_EDGE (e, ei, bb->preds)\n \t\t  {\n \t\t    if (!dominated_by_p (CDI_DOMINATORS, e->src, e->dest)\n-\t\t\t&& !TEST_BIT (visited, e->src->index))\n+\t\t\t&& !bitmap_bit_p (visited, e->src->index))\n \t\t      {\n \t\t\tfound = false;\n \t\t\tbreak;"}, {"sha": "88f817625bc02ce69b9099cb6f5d1b1b51fb3b1b", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -3363,9 +3363,9 @@ mark_reachable_blocks (sbitmap unreachable_blocks, basic_block bb)\n   edge e;\n   edge_iterator ei;\n \n-  if (TEST_BIT (unreachable_blocks, bb->index))\n+  if (bitmap_bit_p (unreachable_blocks, bb->index))\n     {\n-      RESET_BIT (unreachable_blocks, bb->index);\n+      bitmap_clear_bit (unreachable_blocks, bb->index);\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  mark_reachable_blocks (unreachable_blocks, e->src);"}, {"sha": "8f2e9a687f2ab71a5a3c2ab14611858ff6ce8ec3", "filename": "gcc/ebitmap.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Febitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Febitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -227,7 +227,7 @@ bitmap_clear_bit (ebitmap map, unsigned int bit)\n     return;\n \n   if (wordindex >= map->wordmask->n_bits\n-      || !TEST_BIT (map->wordmask, wordindex))\n+      || !bitmap_bit_p (map->wordmask, wordindex))\n     return;\n \n   if (map->cache != NULL && map->cacheindex == wordindex)\n@@ -258,7 +258,7 @@ bitmap_clear_bit (ebitmap map, unsigned int bit)\n             map->cache = map->cache - 1;\n         }\n \n-      RESET_BIT_WITH_POPCOUNT (map->wordmask, wordindex);\n+      bitmap_clear_bit_with_popcount (map->wordmask, wordindex);\n \n       memmove(&map->elts[eltwordindex], &map->elts[eltwordindex + 1],\n \t      sizeof (EBITMAP_ELT_TYPE) * (map->numwords - eltwordindex));\n@@ -288,12 +288,12 @@ bitmap_set_bit (ebitmap map, unsigned int bit)\n \n   /* Allocate a new word in the array and move whatever is in it's\n      place, if necessary. */\n-  if (!TEST_BIT (map->wordmask, wordindex))\n+  if (!bitmap_bit_p (map->wordmask, wordindex))\n     {\n       unsigned long count;\n       unsigned int i;\n \n-      SET_BIT_WITH_POPCOUNT (map->wordmask, wordindex);\n+      bitmap_set_bit_with_popcount (map->wordmask, wordindex);\n       count = sbitmap_popcount (map->wordmask, wordindex);\n       gcc_assert (count <= map->numwords);\n \n@@ -341,7 +341,7 @@ bitmap_bit_p (ebitmap map, unsigned int bit)\n      it's not set in the wordmask, this bit can't exist in our\n      ebitmap.  */\n   if (wordindex >= map->wordmask->n_bits\n-      || !TEST_BIT (map->wordmask, wordindex))\n+      || !bitmap_bit_p (map->wordmask, wordindex))\n     return false;\n \n   /* Find the bit and test it.  */\n@@ -449,7 +449,7 @@ bitmap_and_into (ebitmap dst, ebitmap src)\n \t  *dstplace = tmpword;\n \t}\n       else\n-\tRESET_BIT_WITH_POPCOUNT (dst->wordmask, i);\n+\tbitmap_clear_bit_with_popcount (dst->wordmask, i);\n     }\n #ifdef EBITMAP_DEBUGGING\n   {\n@@ -494,8 +494,8 @@ bitmap_and (ebitmap dst, ebitmap src1, ebitmap src2)\n     {\n       bool src1hasword, src2hasword;\n \n-      src1hasword = TEST_BIT (src1->wordmask, i);\n-      src2hasword = TEST_BIT (src2->wordmask, i);\n+      src1hasword = bitmap_bit_p (src1->wordmask, i);\n+      src2hasword = bitmap_bit_p (src2->wordmask, i);\n \n       if (src1hasword && src2hasword)\n \t{\n@@ -508,7 +508,7 @@ bitmap_and (ebitmap dst, ebitmap src1, ebitmap src2)\n \t      *dstplace = tmpword;\n \t    }\n \t  else\n-\t    RESET_BIT_WITH_POPCOUNT (dst->wordmask, i);\n+\t    bitmap_clear_bit_with_popcount (dst->wordmask, i);\n \t}\n       else if (src1hasword)\n \tsrc1eltindex++;\n@@ -603,9 +603,9 @@ bitmap_ior_into (ebitmap dst, ebitmap src)\n       bool dsthasword, srchasword;\n \n       dsthasword = (i < dst->wordmask->n_bits\n-\t\t    && TEST_BIT (dst->wordmask, i));\n+\t\t    && bitmap_bit_p (dst->wordmask, i));\n       srchasword = (i < src->wordmask->n_bits\n-\t\t    && TEST_BIT (src->wordmask, i));\n+\t\t    && bitmap_bit_p (src->wordmask, i));\n \n       if (dsthasword && srchasword)\n \t{\n@@ -624,7 +624,7 @@ bitmap_ior_into (ebitmap dst, ebitmap src)\n \t{\n \t  newarray [neweltindex++] = ebitmap_array_get (src, srceltindex++);\n \t  gcc_assert (i < dst->wordmask->n_bits);\n-\t  SET_BIT_WITH_POPCOUNT (dst->wordmask, i);\n+\t  bitmap_set_bit_with_popcount (dst->wordmask, i);\n \t  changed |= true;\n \t}\n     }\n@@ -712,9 +712,9 @@ bitmap_ior (ebitmap dst, ebitmap src1, ebitmap src2)\n       bool src1hasword, src2hasword;\n       EBITMAP_ELT_TYPE tmpword;\n       src1hasword = (i < src1->wordmask->n_bits\n-\t\t    && TEST_BIT (src1->wordmask, i));\n+\t\t    && bitmap_bit_p (src1->wordmask, i));\n       src2hasword = (i < src2->wordmask->n_bits\n-\t\t    && TEST_BIT (src2->wordmask, i));\n+\t\t    && bitmap_bit_p (src2->wordmask, i));\n \n       if (src1hasword && src2hasword)\n \t{\n@@ -733,7 +733,7 @@ bitmap_ior (ebitmap dst, ebitmap src1, ebitmap src2)\n \t  newarray [neweltindex++] = tmpword;\n \t}\n \n-      if (i >= dst->wordmask->n_bits || !TEST_BIT (dst->wordmask, i))\n+      if (i >= dst->wordmask->n_bits || !bitmap_bit_p (dst->wordmask, i))\n \t{\n \t  changed = true;\n \t}\n@@ -808,7 +808,7 @@ bitmap_and_compl_into (ebitmap dst, ebitmap src)\n       bool srchasword;\n \n       srchasword = (i < src->wordmask->n_bits\n-\t\t    && TEST_BIT (src->wordmask, i));\n+\t\t    && bitmap_bit_p (src->wordmask, i));\n \n       if (srchasword)\n \t{\n@@ -825,7 +825,7 @@ bitmap_and_compl_into (ebitmap dst, ebitmap src)\n \t      *dstplace = tmpword;\n \t    }\n \t  else\n-\t    RESET_BIT_WITH_POPCOUNT (dst->wordmask, i);\n+\t    bitmap_clear_bit_with_popcount (dst->wordmask, i);\n \t}\n       else\n \t{\n@@ -892,7 +892,7 @@ bitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n       EBITMAP_ELT_TYPE tmpword;\n \n       src2hasword = (i < src2->wordmask->n_bits\n-\t\t     && TEST_BIT (src2->wordmask, i));\n+\t\t     && bitmap_bit_p (src2->wordmask, i));\n \n       if (src2hasword)\n \t{\n@@ -904,7 +904,7 @@ bitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n \t      newarray[neweltindex++] = tmpword;\n \t    }\n \t  else\n-\t    RESET_BIT_WITH_POPCOUNT (tempmask, i);\n+\t    bitmap_clear_bit_with_popcount (tempmask, i);\n \n \t}\n       else\n@@ -914,7 +914,7 @@ bitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n \t  newarray[neweltindex++] = tmpword;\n \t}\n \n-      if (i >= dst->wordmask->n_bits || !TEST_BIT (dst->wordmask, i))\n+      if (i >= dst->wordmask->n_bits || !bitmap_bit_p (dst->wordmask, i))\n \t{\n \t  changed = true;\n \t}"}, {"sha": "6e77d576fb4ab6d9d6faf04518d0e0c344fd5881", "filename": "gcc/ebitmap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Febitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Febitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.h?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -115,7 +115,7 @@ ebitmap_iter_init (ebitmap_iterator *i, ebitmap bmp, unsigned int min)\n     }\n   else\n     {\n-      if (TEST_BIT (bmp->wordmask, min / EBITMAP_ELT_BITS) == 0)\n+      if (bitmap_bit_p (bmp->wordmask, min / EBITMAP_ELT_BITS) == 0)\n \ti->word = 0;\n       else\n \t{"}, {"sha": "6256b8dec4b3e84fdb44cc904797c8dbe342d6e4", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -614,14 +614,14 @@ eh_region_outermost (struct function *ifun, eh_region region_a,\n \n   do\n     {\n-      SET_BIT (b_outer, region_b->index);\n+      bitmap_set_bit (b_outer, region_b->index);\n       region_b = region_b->outer;\n     }\n   while (region_b);\n \n   do\n     {\n-      if (TEST_BIT (b_outer, region_a->index))\n+      if (bitmap_bit_p (b_outer, region_a->index))\n \tbreak;\n       region_a = region_a->outer;\n     }"}, {"sha": "08f0b89c0228d35122b6339be301c7541353bb60", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -6491,8 +6491,8 @@ thread_prologue_and_epilogue_insns (void)\n       /* Look for basic blocks within the prologue insns.  */\n       blocks = sbitmap_alloc (last_basic_block);\n       bitmap_clear (blocks);\n-      SET_BIT (blocks, entry_edge->dest->index);\n-      SET_BIT (blocks, orig_entry_edge->dest->index);\n+      bitmap_set_bit (blocks, entry_edge->dest->index);\n+      bitmap_set_bit (blocks, orig_entry_edge->dest->index);\n       find_many_sub_basic_blocks (blocks);\n       sbitmap_free (blocks);\n "}, {"sha": "b1048feb78e01005169d4bb59406bbc4d7c6f9a7", "filename": "gcc/gcse.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -686,7 +686,7 @@ compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n \t  if (antloc)\n \t    for (occr = expr->antic_occr; occr != NULL; occr = occr->next)\n \t      {\n-\t\tSET_BIT (antloc[BLOCK_FOR_INSN (occr->insn)->index], indx);\n+\t\tbitmap_set_bit (antloc[BLOCK_FOR_INSN (occr->insn)->index], indx);\n \n \t\t/* While we're scanning the table, this is a good place to\n \t\t   initialize this.  */\n@@ -698,7 +698,7 @@ compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n \t  if (comp)\n \t    for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n \t      {\n-\t\tSET_BIT (comp[BLOCK_FOR_INSN (occr->insn)->index], indx);\n+\t\tbitmap_set_bit (comp[BLOCK_FOR_INSN (occr->insn)->index], indx);\n \n \t\t/* While we're scanning the table, this is a good place to\n \t\t   initialize this.  */\n@@ -1662,7 +1662,7 @@ compute_transp (const_rtx x, int indx, sbitmap *bmap)\n \t  for (def = DF_REG_DEF_CHAIN (REGNO (x));\n \t       def;\n \t       def = DF_REF_NEXT_REG (def))\n-\t    RESET_BIT (bmap[DF_REF_BB (def)->index], indx);\n+\t    bitmap_clear_bit (bmap[DF_REF_BB (def)->index], indx);\n \t}\n \n       return;\n@@ -1677,7 +1677,7 @@ compute_transp (const_rtx x, int indx, sbitmap *bmap)\n \t     do any list walking for them.  */\n \t  EXECUTE_IF_SET_IN_BITMAP (blocks_with_calls, 0, bb_index, bi)\n \t    {\n-\t      RESET_BIT (bmap[bb_index], indx);\n+\t      bitmap_clear_bit (bmap[bb_index], indx);\n \t    }\n \n \t    /* Now iterate over the blocks which have memory modifications\n@@ -1698,7 +1698,7 @@ compute_transp (const_rtx x, int indx, sbitmap *bmap)\n \n \t\t    if (canon_true_dependence (dest, GET_MODE (dest),\n \t\t\t\t\t       dest_addr, x, NULL_RTX))\n-\t\t      RESET_BIT (bmap[bb_index], indx);\n+\t\t      bitmap_clear_bit (bmap[bb_index], indx);\n \t          }\n \t      }\n \t}\n@@ -1831,7 +1831,7 @@ prune_expressions (bool pre_p)\n \t  /* Note potentially trapping expressions.  */\n \t  if (may_trap_p (expr->expr))\n \t    {\n-\t      SET_BIT (prune_exprs, expr->bitmap_index);\n+\t      bitmap_set_bit (prune_exprs, expr->bitmap_index);\n \t      continue;\n \t    }\n \n@@ -1857,7 +1857,7 @@ prune_expressions (bool pre_p)\n \t\t analysis to determine if this mem is actually killed\n \t\t by this call.  */\n \n-\t      SET_BIT (prune_exprs, expr->bitmap_index);\n+\t      bitmap_set_bit (prune_exprs, expr->bitmap_index);\n \t    }\n \t}\n     }\n@@ -1949,16 +1949,16 @@ prune_insertions_deletions (int n_elems)\n   for (j = 0; j < (unsigned) n_elems; j++)\n     if (deletions[j]\n \t&& ((unsigned) insertions[j] / deletions[j]) > MAX_GCSE_INSERTION_RATIO)\n-      SET_BIT (prune_exprs, j);\n+      bitmap_set_bit (prune_exprs, j);\n \n   /* Now prune PRE_INSERT_MAP and PRE_DELETE_MAP based on PRUNE_EXPRS.  */\n   EXECUTE_IF_SET_IN_SBITMAP (prune_exprs, 0, j, sbi)\n     {\n       for (i = 0; i < (unsigned) n_edges; i++)\n-\tRESET_BIT (pre_insert_map[i], j);\n+\tbitmap_clear_bit (pre_insert_map[i], j);\n \n       for (i = 0; i < (unsigned) last_basic_block; i++)\n-\tRESET_BIT (pre_delete_map[i], j);\n+\tbitmap_clear_bit (pre_delete_map[i], j);\n     }\n \n   sbitmap_free (prune_exprs);\n@@ -2033,7 +2033,7 @@ pre_expr_reaches_here_p_work (basic_block occr_bb, struct expr *expr,\n \t;/* Nothing to do.  */\n \n       /* Does this predecessor generate this expression?  */\n-      else if (TEST_BIT (comp[pred_bb->index], expr->bitmap_index))\n+      else if (bitmap_bit_p (comp[pred_bb->index], expr->bitmap_index))\n \t{\n \t  /* Is this the occurrence we're looking for?\n \t     Note that there's only one generating occurrence per block\n@@ -2044,7 +2044,7 @@ pre_expr_reaches_here_p_work (basic_block occr_bb, struct expr *expr,\n \t  visited[pred_bb->index] = 1;\n \t}\n       /* Ignore this predecessor if it kills the expression.  */\n-      else if (! TEST_BIT (transp[pred_bb->index], expr->bitmap_index))\n+      else if (! bitmap_bit_p (transp[pred_bb->index], expr->bitmap_index))\n \tvisited[pred_bb->index] = 1;\n \n       /* Neither gen nor kill.  */\n@@ -2262,7 +2262,7 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n \n \t\t    /* Insert this expression on this edge if it would\n \t\t       reach the deleted occurrence in BB.  */\n-\t\t    if (!TEST_BIT (inserted[e], j))\n+\t\t    if (!bitmap_bit_p (inserted[e], j))\n \t\t      {\n \t\t\trtx insn;\n \t\t\tedge eg = INDEX_EDGE (edge_list, e);\n@@ -2292,7 +2292,7 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n \t\t\t  }\n \n \t\t\tupdate_ld_motion_stores (expr);\n-\t\t\tSET_BIT (inserted[e], j);\n+\t\t\tbitmap_set_bit (inserted[e], j);\n \t\t\tdid_insert = 1;\n \t\t\tgcse_create_count++;\n \t\t      }\n@@ -2532,7 +2532,7 @@ pre_delete (void)\n \t    basic_block bb = BLOCK_FOR_INSN (insn);\n \n \t    /* We only delete insns that have a single_set.  */\n-\t    if (TEST_BIT (pre_delete_map[bb->index], indx)\n+\t    if (bitmap_bit_p (pre_delete_map[bb->index], indx)\n \t\t&& (set = single_set (insn)) != 0\n                 && dbg_cnt (pre_insn))\n \t      {\n@@ -2802,8 +2802,8 @@ compute_code_hoist_vbeinout (void)\n \t{\n \t  if (bb->next_bb != EXIT_BLOCK_PTR)\n \t    {\n-\t      sbitmap_intersection_of_succs (hoist_vbeout[bb->index],\n-\t\t\t\t\t     hoist_vbein, bb);\n+\t      bitmap_intersection_of_succs (hoist_vbeout[bb->index],\n+\t\t\t\t\t    hoist_vbein, bb);\n \n \t      /* Include expressions in VBEout that are calculated\n \t\t in BB and available at its end.  */\n@@ -2922,14 +2922,14 @@ should_hoist_expr_to_dom (basic_block expr_bb, struct expr *expr,\n \tbreak;\n       else if (pred_bb == expr_bb)\n \tcontinue;\n-      else if (TEST_BIT (visited, pred_bb->index))\n+      else if (bitmap_bit_p (visited, pred_bb->index))\n \tcontinue;\n-      else if (! TEST_BIT (transp[pred_bb->index], expr->bitmap_index))\n+      else if (! bitmap_bit_p (transp[pred_bb->index], expr->bitmap_index))\n \tbreak;\n       /* Not killed.  */\n       else\n \t{\n-\t  SET_BIT (visited, pred_bb->index);\n+\t  bitmap_set_bit (visited, pred_bb->index);\n \t  if (! should_hoist_expr_to_dom (expr_bb, expr, pred_bb,\n \t\t\t\t\t  visited, distance, bb_size,\n \t\t\t\t\t  pressure_class, nregs, hoisted_bbs))\n@@ -3084,7 +3084,7 @@ hoist_code (void)\n \t block.  These are the potentially hoistable expressions.  */\n       for (i = 0; i < SBITMAP_SIZE (hoist_vbeout[bb->index]); i++)\n \t{\n-\t  if (TEST_BIT (hoist_vbeout[bb->index], i))\n+\t  if (bitmap_bit_p (hoist_vbeout[bb->index], i))\n \t    {\n \t      int nregs = 0;\n \t      enum reg_class pressure_class = NO_REGS;\n@@ -3101,7 +3101,7 @@ hoist_code (void)\n \n \t      /* If an expression is computed in BB and is available at end of\n \t\t BB, hoist all occurrences dominated by BB to BB.  */\n-\t      if (TEST_BIT (comp[bb->index], i))\n+\t      if (bitmap_bit_p (comp[bb->index], i))\n \t\t{\n \t\t  occr = find_occr_in_bb (expr->antic_occr, bb);\n \n@@ -3132,7 +3132,7 @@ hoist_code (void)\n \t\t  /* We've found a dominated block, now see if it computes\n \t\t     the busy expression and whether or not moving that\n \t\t     expression to the \"beginning\" of that block is safe.  */\n-\t\t  if (!TEST_BIT (antloc[dominated->index], i))\n+\t\t  if (!bitmap_bit_p (antloc[dominated->index], i))\n \t\t    continue;\n \n \t\t  occr = find_occr_in_bb (expr->antic_occr, dominated);"}, {"sha": "102e7d2a5a5964e1794ea9b6f8f85f7c118c4f40", "filename": "gcc/genautomata.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -3424,7 +3424,7 @@ finish_alt_states (void)\n \n /* Set bit number bitno in the bit string.  The macro is not side\n    effect proof.  */\n-#define SET_BIT(bitstring, bitno)\t\t\t\t\t  \\\n+#define bitmap_set_bit(bitstring, bitno)\t\t\t\t\t  \\\n   ((bitstring)[(bitno) / (sizeof (*(bitstring)) * CHAR_BIT)] |=\t\t  \\\n \t(HOST_WIDE_INT)1 << (bitno) % (sizeof (*(bitstring)) * CHAR_BIT))\n \n@@ -3434,7 +3434,7 @@ finish_alt_states (void)\n \n /* Test if bit number bitno in the bitstring is set.  The macro is not\n    side effect proof.  */\n-#define TEST_BIT(bitstring, bitno)\t\t\t\t\t  \\\n+#define bitmap_bit_p(bitstring, bitno)\t\t\t\t\t  \\\n   ((bitstring)[(bitno) / (sizeof (*(bitstring)) * CHAR_BIT)] >>\t\t  \\\n \t(bitno) % (sizeof (*(bitstring)) * CHAR_BIT) & 1)\n \n@@ -3563,7 +3563,7 @@ static void\n set_unit_reserv (reserv_sets_t reservs, int cycle_num, int unit_num)\n {\n   gcc_assert (cycle_num < max_cycles_num);\n-  SET_BIT (reservs, cycle_num * els_in_cycle_reserv\n+  bitmap_set_bit (reservs, cycle_num * els_in_cycle_reserv\n            * sizeof (set_el_t) * CHAR_BIT + unit_num);\n }\n \n@@ -3573,7 +3573,7 @@ static int\n test_unit_reserv (reserv_sets_t reservs, int cycle_num, int unit_num)\n {\n   gcc_assert (cycle_num < max_cycles_num);\n-  return TEST_BIT (reservs, cycle_num * els_in_cycle_reserv\n+  return bitmap_bit_p (reservs, cycle_num * els_in_cycle_reserv\n \t\t   * sizeof (set_el_t) * CHAR_BIT + unit_num);\n }\n \n@@ -3677,7 +3677,7 @@ output_cycle_reservs (FILE *f, reserv_sets_t reservs, int start_cycle,\n \n   reserved_units_num = 0;\n   for (unit_num = 0; unit_num < description->units_num; unit_num++)\n-    if (TEST_BIT (reservs, start_cycle * els_in_cycle_reserv\n+    if (bitmap_bit_p (reservs, start_cycle * els_in_cycle_reserv\n                   * sizeof (set_el_t) * CHAR_BIT + unit_num))\n       reserved_units_num++;\n   gcc_assert (repetition_num > 0);\n@@ -3687,7 +3687,7 @@ output_cycle_reservs (FILE *f, reserv_sets_t reservs, int start_cycle,\n   for (unit_num = 0;\n        unit_num < description->units_num;\n        unit_num++)\n-    if (TEST_BIT (reservs, start_cycle * els_in_cycle_reserv\n+    if (bitmap_bit_p (reservs, start_cycle * els_in_cycle_reserv\n \t\t  * sizeof (set_el_t) * CHAR_BIT + unit_num))\n       {\n         if (reserved_units_num != 0)\n@@ -4279,7 +4279,7 @@ initiate_excl_sets (void)\n \t       el != NULL;\n \t       el = el->next_unit_set_el)\n \t    {\n-\t      SET_BIT (unit_excl_set, el->unit_decl->unit_num);\n+\t      bitmap_set_bit (unit_excl_set, el->unit_decl->unit_num);\n \t      el->unit_decl->in_set_p = TRUE;\n \t    }\n           unit_excl_set_table [DECL_UNIT (decl)->unit_num] = unit_excl_set;\n@@ -4344,7 +4344,7 @@ form_reserv_sets_list (pattern_set_el_t pattern_list)\n       curr->next_pattern_reserv = NULL;\n       for (i = 0; i < el->units_num; i++)\n \t{\n-\t  SET_BIT (curr->reserv, el->unit_decls [i]->unit_num);\n+\t  bitmap_set_bit (curr->reserv, el->unit_decls [i]->unit_num);\n \t  el->unit_decls [i]->in_set_p = TRUE;\n \t}\n       if (prev != NULL)"}, {"sha": "1c048702fbc47bea964eaccb7f23452de78ab550", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -321,7 +321,7 @@ all_non_dominated_preds_marked_p (basic_block bb, sbitmap map)\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (!TEST_BIT (map, e->src->index)\n+    if (!bitmap_bit_p (map, e->src->index)\n \t&& !dominated_by_p (CDI_DOMINATORS, e->src, bb))\n \treturn false;\n \n@@ -365,13 +365,13 @@ build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n   VEC (basic_block, heap) *dom;\n   poly_bb_p pbb;\n \n-  if (TEST_BIT (visited, bb->index)\n+  if (bitmap_bit_p (visited, bb->index)\n       || !bb_in_sese_p (bb, region))\n     return;\n \n   pbb = new_poly_bb (scop, try_generate_gimple_bb (scop, bb));\n   VEC_safe_push (poly_bb_p, heap, SCOP_BBS (scop), pbb);\n-  SET_BIT (visited, bb->index);\n+  bitmap_set_bit (visited, bb->index);\n \n   dom = get_dominated_by (CDI_DOMINATORS, bb);\n "}, {"sha": "7de047f7a276a8a6332211bdf2afa6dd30eeed14", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -1471,8 +1471,8 @@ remove_some_program_points_and_update_live_ranges (void)\n     for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n       {\n \tira_assert (r->start <= r->finish);\n-\tSET_BIT (born, r->start);\n-\tSET_BIT (dead, r->finish);\n+\tbitmap_set_bit (born, r->start);\n+\tbitmap_set_bit (dead, r->finish);\n       }\n \n   born_or_dead = sbitmap_alloc (ira_max_point);\n@@ -1482,8 +1482,8 @@ remove_some_program_points_and_update_live_ranges (void)\n   prev_born_p = prev_dead_p = false;\n   EXECUTE_IF_SET_IN_SBITMAP (born_or_dead, 0, i, sbi)\n     {\n-      born_p = TEST_BIT (born, i);\n-      dead_p = TEST_BIT (dead, i);\n+      born_p = bitmap_bit_p (born, i);\n+      dead_p = bitmap_bit_p (dead, i);\n       if ((prev_born_p && ! prev_dead_p && born_p && ! dead_p)\n \t  || (prev_dead_p && ! prev_born_p && dead_p && ! born_p))\n \tmap[i] = n;"}, {"sha": "9caa4cf843cc3d6e91bee143e5fdab63f61efebe", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -3620,7 +3620,7 @@ build_insn_chain (void)\n \n \t\t\t    while (start < last)\n \t\t\t      {\n-\t\t\t\tRESET_BIT (live_subregs[regno], start);\n+\t\t\t\tbitmap_clear_bit (live_subregs[regno], start);\n \t\t\t\tstart++;\n \t\t\t      }\n \n@@ -3706,7 +3706,7 @@ build_insn_chain (void)\n \n \t\t\t    while (start < last)\n \t\t\t      {\n-\t\t\t\tSET_BIT (live_subregs[regno], start);\n+\t\t\t\tbitmap_set_bit (live_subregs[regno], start);\n \t\t\t\tstart++;\n \t\t\t      }\n \t\t\t  }"}, {"sha": "ab920bf0cbf7832016a5d4df4118441f82ef4e90", "filename": "gcc/lcm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -145,7 +145,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n \t  /* Clear the aux field of this block so that it can be added to\n \t     the worklist again if necessary.  */\n \t  bb->aux = NULL;\n-\t  sbitmap_intersection_of_succs (antout[bb->index], antin, bb);\n+\t  bitmap_intersection_of_succs (antout[bb->index], antin, bb);\n \t}\n \n       if (bitmap_or_and (antin[bb->index], antloc[bb->index],\n@@ -526,7 +526,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n \t  /* Clear the aux field of this block so that it can be added to\n \t     the worklist again if necessary.  */\n \t  bb->aux = NULL;\n-\t  sbitmap_intersection_of_preds (avin[bb->index], avout, bb);\n+\t  bitmap_intersection_of_preds (avin[bb->index], avout, bb);\n \t}\n \n       if (bitmap_ior_and_compl (avout[bb->index], avloc[bb->index],"}, {"sha": "5288fd7473432bb1c1895c8397c6a955389cabae", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -466,9 +466,9 @@ peel_loop_completely (struct loop *loop)\n \n       wont_exit = sbitmap_alloc (npeel + 1);\n       bitmap_ones (wont_exit);\n-      RESET_BIT (wont_exit, 0);\n+      bitmap_clear_bit (wont_exit, 0);\n       if (desc->noloop_assumptions)\n-\tRESET_BIT (wont_exit, 1);\n+\tbitmap_clear_bit (wont_exit, 1);\n \n       remove_edges = NULL;\n \n@@ -672,9 +672,9 @@ unroll_loop_constant_iterations (struct loop *loop)\n \tfprintf (dump_file, \";; Condition at beginning of loop.\\n\");\n \n       /* Peel exit_mod iterations.  */\n-      RESET_BIT (wont_exit, 0);\n+      bitmap_clear_bit (wont_exit, 0);\n       if (desc->noloop_assumptions)\n-\tRESET_BIT (wont_exit, 1);\n+\tbitmap_clear_bit (wont_exit, 1);\n \n       if (exit_mod)\n \t{\n@@ -703,7 +703,7 @@ unroll_loop_constant_iterations (struct loop *loop)\n \t    loop->any_estimate = false;\n \t}\n \n-      SET_BIT (wont_exit, 1);\n+      bitmap_set_bit (wont_exit, 1);\n     }\n   else\n     {\n@@ -719,9 +719,9 @@ unroll_loop_constant_iterations (struct loop *loop)\n       if (exit_mod != max_unroll\n \t  || desc->noloop_assumptions)\n \t{\n-\t  RESET_BIT (wont_exit, 0);\n+\t  bitmap_clear_bit (wont_exit, 0);\n \t  if (desc->noloop_assumptions)\n-\t    RESET_BIT (wont_exit, 1);\n+\t    bitmap_clear_bit (wont_exit, 1);\n \n           opt_info_start_duplication (opt_info);\n \t  ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n@@ -747,11 +747,11 @@ unroll_loop_constant_iterations (struct loop *loop)\n \t    loop->any_estimate = false;\n \t  desc->noloop_assumptions = NULL_RTX;\n \n-\t  SET_BIT (wont_exit, 0);\n-\t  SET_BIT (wont_exit, 1);\n+\t  bitmap_set_bit (wont_exit, 0);\n+\t  bitmap_set_bit (wont_exit, 1);\n \t}\n \n-      RESET_BIT (wont_exit, max_unroll);\n+      bitmap_clear_bit (wont_exit, max_unroll);\n     }\n \n   /* Now unroll the loop.  */\n@@ -1069,7 +1069,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   bitmap_clear (wont_exit);\n   if (extra_zero_check\n       && !desc->noloop_assumptions)\n-    SET_BIT (wont_exit, 1);\n+    bitmap_set_bit (wont_exit, 1);\n   ezc_swtch = loop_preheader_edge (loop)->src;\n   ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t      1, wont_exit, desc->out_edge,\n@@ -1085,7 +1085,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       /* Peel the copy.  */\n       bitmap_clear (wont_exit);\n       if (i != n_peel - 1 || !last_may_exit)\n-\tSET_BIT (wont_exit, 1);\n+\tbitmap_set_bit (wont_exit, 1);\n       ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t  1, wont_exit, desc->out_edge,\n \t\t\t\t\t  &remove_edges,\n@@ -1140,7 +1140,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   /* And unroll loop.  */\n \n   bitmap_ones (wont_exit);\n-  RESET_BIT (wont_exit, may_exit_copy);\n+  bitmap_clear_bit (wont_exit, may_exit_copy);\n   opt_info_start_duplication (opt_info);\n \n   ok = duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),"}, {"sha": "1949ec14faaf5de261ff0c1f320f5e6430147228", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -1544,7 +1544,7 @@ decompose_multiword_subregs (bool decompose_copies)\n \t\t\t  extract_insn (insn);\n \n \t\t\t  if (cfi)\n-\t\t\t    SET_BIT (sub_blocks, bb->index);\n+\t\t\t    bitmap_set_bit (sub_blocks, bb->index);\n \t\t\t}\n \t\t    }\n \t\t  else"}, {"sha": "f03e8ef9b7e0baf0ef82f417d753720ab0b15c2c", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -780,8 +780,8 @@ remove_some_program_points_and_update_live_ranges (void)\n       for (r = lra_reg_info[i].live_ranges; r != NULL; r = r->next)\n \t{\n \t  lra_assert (r->start <= r->finish);\n-\t  SET_BIT (born, r->start);\n-\t  SET_BIT (dead, r->finish);\n+\t  bitmap_set_bit (born, r->start);\n+\t  bitmap_set_bit (dead, r->finish);\n \t}\n     }\n   born_or_dead = sbitmap_alloc (lra_live_max_point);\n@@ -791,8 +791,8 @@ remove_some_program_points_and_update_live_ranges (void)\n   prev_born_p = prev_dead_p = false;\n   EXECUTE_IF_SET_IN_SBITMAP (born_or_dead, 0, i, sbi)\n     {\n-      born_p = TEST_BIT (born, i);\n-      dead_p = TEST_BIT (dead, i);\n+      born_p = bitmap_bit_p (born, i);\n+      dead_p = bitmap_bit_p (dead, i);\n       if ((prev_born_p && ! prev_dead_p && born_p && ! dead_p)\n \t  || (prev_dead_p && ! prev_born_p && dead_p && ! born_p))\n \t{"}, {"sha": "890af2201bf97e996c9e734b8a8df1e50c4804a7", "filename": "gcc/lra.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -1751,9 +1751,9 @@ lra_push_insn_1 (rtx insn, bool always_update)\n   if (uid >= SBITMAP_SIZE (lra_constraint_insn_stack_bitmap))\n     lra_constraint_insn_stack_bitmap =\n       sbitmap_resize (lra_constraint_insn_stack_bitmap, 3 * uid / 2, 0);\n-  if (TEST_BIT (lra_constraint_insn_stack_bitmap, uid))\n+  if (bitmap_bit_p (lra_constraint_insn_stack_bitmap, uid))\n     return;\n-  SET_BIT (lra_constraint_insn_stack_bitmap, uid);\n+  bitmap_set_bit (lra_constraint_insn_stack_bitmap, uid);\n   if (! always_update)\n     lra_update_insn_regno_info (insn);\n   VEC_safe_push (rtx, heap, lra_constraint_insn_stack, insn);\n@@ -1785,7 +1785,7 @@ rtx\n lra_pop_insn (void)\n {\n   rtx insn = VEC_pop (rtx, lra_constraint_insn_stack);\n-  RESET_BIT (lra_constraint_insn_stack_bitmap, INSN_UID (insn));\n+  bitmap_clear_bit (lra_constraint_insn_stack_bitmap, INSN_UID (insn));\n   return insn;\n }\n "}, {"sha": "d9f83ca2a3b772362e536eb7d5d85e5e70dfb7fa", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -148,10 +148,10 @@ make_preds_opaque (basic_block b, int j)\n     {\n       basic_block pb = e->src;\n \n-      if (e->aux || ! TEST_BIT (transp[pb->index], j))\n+      if (e->aux || ! bitmap_bit_p (transp[pb->index], j))\n \tcontinue;\n \n-      RESET_BIT (transp[pb->index], j);\n+      bitmap_clear_bit (transp[pb->index], j);\n       make_preds_opaque (pb, j);\n     }\n }\n@@ -513,7 +513,7 @@ optimize_mode_switching (void)\n \t      {\n \t\tptr = new_seginfo (no_mode, BB_HEAD (bb), bb->index, live_now);\n \t\tadd_seginfo (info + bb->index, ptr);\n-\t\tRESET_BIT (transp[bb->index], j);\n+\t\tbitmap_clear_bit (transp[bb->index], j);\n \t      }\n \t  }\n \n@@ -530,7 +530,7 @@ optimize_mode_switching (void)\n \t\t      last_mode = mode;\n \t\t      ptr = new_seginfo (mode, insn, bb->index, live_now);\n \t\t      add_seginfo (info + bb->index, ptr);\n-\t\t      RESET_BIT (transp[bb->index], j);\n+\t\t      bitmap_clear_bit (transp[bb->index], j);\n \t\t    }\n #ifdef MODE_AFTER\n \t\t  last_mode = MODE_AFTER (e, last_mode, insn);\n@@ -569,7 +569,7 @@ optimize_mode_switching (void)\n \t       an extra check in make_preds_opaque.  We also\n \t       need this to avoid confusing pre_edge_lcm when\n \t       antic is cleared but transp and comp are set.  */\n-\t    RESET_BIT (transp[bb->index], j);\n+\t    bitmap_clear_bit (transp[bb->index], j);\n \n \t    /* Insert a fake computing definition of MODE into entry\n \t       blocks which compute no mode. This represents the mode on\n@@ -601,10 +601,10 @@ optimize_mode_switching (void)\n \t  FOR_EACH_BB (bb)\n \t    {\n \t      if (info[bb->index].seginfo->mode == m)\n-\t\tSET_BIT (antic[bb->index], j);\n+\t\tbitmap_set_bit (antic[bb->index], j);\n \n \t      if (info[bb->index].computing == m)\n-\t\tSET_BIT (comp[bb->index], j);\n+\t\tbitmap_set_bit (comp[bb->index], j);\n \t    }\n \t}\n \n@@ -638,7 +638,7 @@ optimize_mode_switching (void)\n \n \t      eg->aux = 0;\n \n-\t      if (! TEST_BIT (insert[e], j))\n+\t      if (! bitmap_bit_p (insert[e], j))\n \t\tcontinue;\n \n \t      eg->aux = (void *)1;\n@@ -665,7 +665,7 @@ optimize_mode_switching (void)\n \t    }\n \n \t  FOR_EACH_BB_REVERSE (bb)\n-\t    if (TEST_BIT (del[bb->index], j))\n+\t    if (bitmap_bit_p (del[bb->index], j))\n \t      {\n \t\tmake_preds_opaque (bb, j);\n \t\t/* Cancel the 'deleted' mode set.  */"}, {"sha": "b9e6d983132cbd81a11875e90df4e1b35dc0c11c", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -619,7 +619,7 @@ schedule_reg_move (partial_schedule_ptr ps, int i_reg_move,\n     {\n       this_insn = ps_rtl_insn (ps, u);\n       this_latency = insn_latency (move->insn, this_insn);\n-      if (distance1_uses && !TEST_BIT (distance1_uses, u))\n+      if (distance1_uses && !bitmap_bit_p (distance1_uses, u))\n \tthis_distance = -1;\n       else\n \tthis_distance = 0;\n@@ -644,7 +644,7 @@ schedule_reg_move (partial_schedule_ptr ps, int i_reg_move,\n     }\n \n   bitmap_clear (must_follow);\n-  SET_BIT (must_follow, move->def);\n+  bitmap_set_bit (must_follow, move->def);\n \n   start = MAX (start, end - (ii - 1));\n   for (c = end; c >= start; c--)\n@@ -796,9 +796,9 @@ schedule_reg_moves (partial_schedule_ptr ps)\n \t\tps_reg_move_info *move;\n \n \t\tmove = ps_reg_move (ps, first_move + dest_copy - 1);\n-\t\tSET_BIT (move->uses, e->dest->cuid);\n+\t\tbitmap_set_bit (move->uses, e->dest->cuid);\n \t\tif (e->distance == 1)\n-\t\t  SET_BIT (distance1_uses, e->dest->cuid);\n+\t\t  bitmap_set_bit (distance1_uses, e->dest->cuid);\n \t      }\n \t  }\n \n@@ -1911,7 +1911,7 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n       {\n \tint v = e->src->cuid;\n \n-\tif (TEST_BIT (sched_nodes, v))\n+\tif (bitmap_bit_p (sched_nodes, v))\n \t  {\n \t    int p_st = SCHED_TIME (v);\n \t    int earliest = p_st + e->latency - (e->distance * ii);\n@@ -1939,7 +1939,7 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n       {\n \tint v = e->dest->cuid;\n \n-\tif (TEST_BIT (sched_nodes, v))\n+\tif (bitmap_bit_p (sched_nodes, v))\n \t  {\n \t    int s_st = SCHED_TIME (v);\n \t    int earliest = (e->data_type == MEM_DEP ? s_st - ii + 1 : INT_MIN);\n@@ -2068,14 +2068,14 @@ calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n      and check only if\n       SCHED_TIME (e->src) - (e->distance * ii) == first_cycle_in_window  */\n   for (e = u_node->in; e != 0; e = e->next_in)\n-    if (TEST_BIT (sched_nodes, e->src->cuid)\n+    if (bitmap_bit_p (sched_nodes, e->src->cuid)\n \t&& ((SCHED_TIME (e->src->cuid) - (e->distance * ii)) ==\n              first_cycle_in_window))\n       {\n \tif (dump_file)\n \t  fprintf (dump_file, \"%d \", e->src->cuid);\n \n-\tSET_BIT (must_precede, e->src->cuid);\n+\tbitmap_set_bit (must_precede, e->src->cuid);\n       }\n \n   if (dump_file)\n@@ -2093,14 +2093,14 @@ calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n      and check only if\n       SCHED_TIME (e->dest) + (e->distance * ii) == last_cycle_in_window  */\n   for (e = u_node->out; e != 0; e = e->next_out)\n-    if (TEST_BIT (sched_nodes, e->dest->cuid)\n+    if (bitmap_bit_p (sched_nodes, e->dest->cuid)\n \t&& ((SCHED_TIME (e->dest->cuid) + (e->distance * ii)) ==\n              last_cycle_in_window))\n       {\n \tif (dump_file)\n \t  fprintf (dump_file, \"%d \", e->dest->cuid);\n \n-\tSET_BIT (must_follow, e->dest->cuid);\n+\tbitmap_set_bit (must_follow, e->dest->cuid);\n       }\n \n   if (dump_file)\n@@ -2131,7 +2131,7 @@ try_scheduling_node_in_cycle (partial_schedule_ptr ps,\n   if (psi)\n     {\n       SCHED_TIME (u) = cycle;\n-      SET_BIT (sched_nodes, u);\n+      bitmap_set_bit (sched_nodes, u);\n       success = 1;\n       *num_splits = 0;\n       if (dump_file)\n@@ -2178,11 +2178,11 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n \n \t  if (!NONDEBUG_INSN_P (insn))\n \t    {\n-\t      RESET_BIT (tobe_scheduled, u);\n+\t      bitmap_clear_bit (tobe_scheduled, u);\n \t      continue;\n \t    }\n \n-\t  if (TEST_BIT (sched_nodes, u))\n+\t  if (bitmap_bit_p (sched_nodes, u))\n \t    continue;\n \n \t  /* Try to get non-empty scheduling window.  */\n@@ -2379,7 +2379,7 @@ compute_split_row (sbitmap sched_nodes, int low, int up, int ii,\n     {\n       int v = e->src->cuid;\n \n-      if (TEST_BIT (sched_nodes, v)\n+      if (bitmap_bit_p (sched_nodes, v)\n \t  && (low == SCHED_TIME (v) + e->latency - (e->distance * ii)))\n \tif (SCHED_TIME (v) > lower)\n \t  {\n@@ -2398,7 +2398,7 @@ compute_split_row (sbitmap sched_nodes, int low, int up, int ii,\n     {\n       int v = e->dest->cuid;\n \n-      if (TEST_BIT (sched_nodes, v)\n+      if (bitmap_bit_p (sched_nodes, v)\n \t  && (up == SCHED_TIME (v) - e->latency + (e->distance * ii)))\n \tif (SCHED_TIME (v) < upper)\n \t  {\n@@ -2434,7 +2434,7 @@ verify_partial_schedule (partial_schedule_ptr ps, sbitmap sched_nodes)\n \t  int u = crr_insn->id;\n \t  \n \t  length++;\n-\t  gcc_assert (TEST_BIT (sched_nodes, u));\n+\t  gcc_assert (bitmap_bit_p (sched_nodes, u));\n \t  /* ??? Test also that all nodes of sched_nodes are in ps, perhaps by\n \t     popcount (sched_nodes) == number of insns in ps.  */\n \t  gcc_assert (SCHED_TIME (u) >= ps->min_cycle);\n@@ -2493,9 +2493,9 @@ check_nodes_order (int *node_order, int num_nodes)\n \n       if (dump_file)\n         fprintf (dump_file, \"%d \", u);\n-      gcc_assert (u < num_nodes && u >= 0 && !TEST_BIT (tmp, u));\n+      gcc_assert (u < num_nodes && u >= 0 && !bitmap_bit_p (tmp, u));\n \n-      SET_BIT (tmp, u);\n+      bitmap_set_bit (tmp, u);\n     }\n \n   if (dump_file)\n@@ -2774,7 +2774,7 @@ order_nodes_in_scc (ddg_ptr g, sbitmap nodes_ordered, sbitmap scc,\n \n       bitmap_clear (workset);\n       if ((u = find_max_asap (g, scc)) >= 0)\n-\tSET_BIT (workset, u);\n+\tbitmap_set_bit (workset, u);\n       dir = BOTTOMUP;\n     }\n \n@@ -2799,8 +2799,8 @@ order_nodes_in_scc (ddg_ptr g, sbitmap nodes_ordered, sbitmap scc,\n \t      /* Don't consider the already ordered successors again.  */\n \t      bitmap_and_compl (tmp, tmp, nodes_ordered);\n \t      bitmap_ior (workset, workset, tmp);\n-\t      RESET_BIT (workset, v);\n-\t      SET_BIT (nodes_ordered, v);\n+\t      bitmap_clear_bit (workset, v);\n+\t      bitmap_set_bit (nodes_ordered, v);\n \t    }\n \t  dir = BOTTOMUP;\n \t  bitmap_clear (predecessors);\n@@ -2820,8 +2820,8 @@ order_nodes_in_scc (ddg_ptr g, sbitmap nodes_ordered, sbitmap scc,\n \t      /* Don't consider the already ordered predecessors again.  */\n \t      bitmap_and_compl (tmp, tmp, nodes_ordered);\n \t      bitmap_ior (workset, workset, tmp);\n-\t      RESET_BIT (workset, v);\n-\t      SET_BIT (nodes_ordered, v);\n+\t      bitmap_clear_bit (workset, v);\n+\t      bitmap_set_bit (nodes_ordered, v);\n \t    }\n \t  dir = TOPDOWN;\n \t  bitmap_clear (successors);\n@@ -3019,10 +3019,10 @@ ps_insn_find_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n        next_ps_i = next_ps_i->next_in_row)\n     {\n       if (must_follow\n-\t  && TEST_BIT (must_follow, next_ps_i->id)\n+\t  && bitmap_bit_p (must_follow, next_ps_i->id)\n \t  && ! first_must_follow)\n         first_must_follow = next_ps_i;\n-      if (must_precede && TEST_BIT (must_precede, next_ps_i->id))\n+      if (must_precede && bitmap_bit_p (must_precede, next_ps_i->id))\n         {\n           /* If we have already met a node that must follow, then\n \t     there is no possible column.  */\n@@ -3033,7 +3033,7 @@ ps_insn_find_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n         }\n       /* The closing branch must be the last in the row.  */\n       if (must_precede \n-\t  && TEST_BIT (must_precede, next_ps_i->id)\n+\t  && bitmap_bit_p (must_precede, next_ps_i->id)\n \t  && JUMP_P (ps_rtl_insn (ps, next_ps_i->id)))\n \treturn false;\n              \n@@ -3105,7 +3105,7 @@ ps_insn_advance_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n \n   /* Check if next_in_row is dependent on ps_i, both having same sched\n      times (typically ANTI_DEP).  If so, ps_i cannot skip over it.  */\n-  if (must_follow && TEST_BIT (must_follow, ps_i->next_in_row->id))\n+  if (must_follow && bitmap_bit_p (must_follow, ps_i->next_in_row->id))\n     return false;\n \n   /* Advance PS_I over its next_in_row in the doubly linked list.  */"}, {"sha": "751133f4a6552f8b2d428ffd439db4d70fb2e6d6", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -2910,7 +2910,7 @@ split_all_insns (void)\n \t\t{\n \t\t  if (split_insn (insn))\n \t\t    {\n-\t\t      SET_BIT (blocks, bb->index);\n+\t\t      bitmap_set_bit (blocks, bb->index);\n \t\t      changed = true;\n \t\t    }\n \t\t}"}, {"sha": "cd1af6be24ac0fce0934411771cba98230e2f0d4", "filename": "gcc/regcprop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -1054,14 +1054,14 @@ copyprop_hardreg_forward (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      SET_BIT (visited, bb->index);\n+      bitmap_set_bit (visited, bb->index);\n \n       /* If a block has a single predecessor, that we've already\n \t processed, begin with the value data that was live at\n \t the end of the predecessor block.  */\n       /* ??? Ought to use more intelligent queuing of blocks.  */\n       if (single_pred_p (bb)\n-\t  && TEST_BIT (visited, single_pred (bb)->index)\n+\t  && bitmap_bit_p (visited, single_pred (bb)->index)\n \t  && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n \t{\n \t  all_vd[bb->index] = all_vd[single_pred (bb)->index];\n@@ -1089,7 +1089,7 @@ copyprop_hardreg_forward (void)\n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n       FOR_EACH_BB (bb)\n-\tif (TEST_BIT (visited, bb->index)\n+\tif (bitmap_bit_p (visited, bb->index)\n \t    && all_vd[bb->index].n_debug_insn_changes)\n \t  {\n \t    unsigned int regno;"}, {"sha": "757d7501b32486af33525fb3f09141dd5b106826", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -722,7 +722,7 @@ dump_bitmap_file (FILE *file, const_sbitmap bmap)\n   fprintf (file, \"n_bits = %d, set = {\", bmap->n_bits);\n \n   for (pos = 30, i = 0; i < bmap->n_bits; i++)\n-    if (TEST_BIT (bmap, i))\n+    if (bitmap_bit_p (bmap, i))\n       {\n \tif (pos > 70)\n \t  {"}, {"sha": "02e3c8147c8e24f082856f5346be72aea23d6829", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -34,9 +34,9 @@ along with GCC; see the file COPYING3.  If not see\n    The following operations can be performed in O(1) time:\n \n      * set_size\t\t\t: SBITMAP_SIZE\n-     * member_p\t\t\t: TEST_BIT\n-     * add_member\t\t: SET_BIT\n-     * remove_member\t\t: RESET_BIT\n+     * member_p\t\t\t: bitmap_bit_p\n+     * add_member\t\t: bitmap_set_bit\n+     * remove_member\t\t: bitmap_clear_bit\n \n    Most other operations on this set representation are O(U) where U is\n    the size of the set universe:\n@@ -100,7 +100,7 @@ struct simple_bitmap_def\n \n /* Test if bit number bitno in the bitmap is set.  */\n static inline SBITMAP_ELT_TYPE\n-TEST_BIT (const_sbitmap map, unsigned int bitno)\n+bitmap_bit_p (const_sbitmap map, int bitno)\n {\n   size_t i = bitno / SBITMAP_ELT_BITS;\n   unsigned int s = bitno % SBITMAP_ELT_BITS;\n@@ -110,21 +110,21 @@ TEST_BIT (const_sbitmap map, unsigned int bitno)\n /* Set bit number BITNO in the sbitmap MAP.  */\n \n static inline void\n-SET_BIT (sbitmap map, unsigned int bitno)\n+bitmap_set_bit (sbitmap map, int bitno)\n {\n   gcc_checking_assert (! map->popcount);\n   map->elms[bitno / SBITMAP_ELT_BITS]\n     |= (SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS;\n }\n \n-/* Like SET_BIT, but updates population count.  */\n+/* Like bitmap_set_bit, but updates population count.  */\n \n static inline void\n-SET_BIT_WITH_POPCOUNT (sbitmap map, unsigned int bitno)\n+bitmap_set_bit_with_popcount (sbitmap map, int bitno)\n {\n   bool oldbit;\n   gcc_checking_assert (map->popcount);\n-  oldbit = TEST_BIT (map, bitno);\n+  oldbit = bitmap_bit_p (map, bitno);\n   if (!oldbit)\n     map->popcount[bitno / SBITMAP_ELT_BITS]++;\n   map->elms[bitno / SBITMAP_ELT_BITS]\n@@ -134,21 +134,21 @@ SET_BIT_WITH_POPCOUNT (sbitmap map, unsigned int bitno)\n /* Reset bit number BITNO in the sbitmap MAP.  */\n \n static inline void\n-RESET_BIT (sbitmap map,  unsigned int bitno)\n+bitmap_clear_bit (sbitmap map, int bitno)\n {\n   gcc_checking_assert (! map->popcount);\n   map->elms[bitno / SBITMAP_ELT_BITS]\n     &= ~((SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS);\n }\n \n-/* Like RESET_BIT, but updates population count.  */\n+/* Like bitmap_clear_bit, but updates population count.  */\n \n static inline void\n-RESET_BIT_WITH_POPCOUNT (sbitmap map,  unsigned int bitno)\n+bitmap_clear_bit_with_popcount (sbitmap map, int bitno)\n {\n   bool oldbit;\n   gcc_checking_assert (map->popcount);\n-  oldbit = TEST_BIT (map, bitno);\n+  oldbit = bitmap_bit_p (map, bitno);\n   if (oldbit)\n     map->popcount[bitno / SBITMAP_ELT_BITS]--;\n   map->elms[bitno / SBITMAP_ELT_BITS]"}, {"sha": "4334a62908fbda9e972fa5dcb97bc802053d5b45", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -188,7 +188,7 @@ static sbitmap *dom;\n \n /* Is bb_src dominated by bb_trg.  */\n #define IS_DOMINATED(bb_src, bb_trg)                                 \\\n-( TEST_BIT (dom[bb_src], bb_trg) )\n+( bitmap_bit_p (dom[bb_src], bb_trg) )\n \n /* Probability: Prob[i] is an int in [0, REG_BR_PROB_BASE] which is\n    the probability of bb i relative to the region entry.  */\n@@ -566,10 +566,10 @@ too_large (int block, int *num_bbs, int *num_insns)\n   if (max_hdr[blk] == -1)\t\t\t\\\n     max_hdr[blk] = hdr;\t\t\t\t\\\n   else if (dfs_nr[max_hdr[blk]] > dfs_nr[hdr])\t\\\n-    RESET_BIT (inner, hdr);\t\t\t\\\n+    bitmap_clear_bit (inner, hdr);\t\t\t\\\n   else if (dfs_nr[max_hdr[blk]] < dfs_nr[hdr])\t\\\n     {\t\t\t\t\t\t\\\n-      RESET_BIT (inner,max_hdr[blk]);\t\t\\\n+      bitmap_clear_bit (inner,max_hdr[blk]);\t\t\\\n       max_hdr[blk] = hdr;\t\t\t\\\n     }\t\t\t\t\t\t\\\n }\n@@ -681,8 +681,8 @@ haifa_find_rgns (void)\n \t      gcc_assert (node != ENTRY_BLOCK);\n \t      child = ei_edge (current_edge)->dest->index;\n \t      gcc_assert (child != EXIT_BLOCK);\n-\t      RESET_BIT (in_stack, child);\n-\t      if (max_hdr[child] >= 0 && TEST_BIT (in_stack, max_hdr[child]))\n+\t      bitmap_clear_bit (in_stack, child);\n+\t      if (max_hdr[child] >= 0 && bitmap_bit_p (in_stack, max_hdr[child]))\n \t\tUPDATE_LOOP_RELATIONS (node, max_hdr[child]);\n \t      ei_next (&current_edge);\n \t    }\n@@ -698,7 +698,7 @@ haifa_find_rgns (void)\n       /* Process a node.  */\n       node = ei_edge (current_edge)->src->index;\n       gcc_assert (node != ENTRY_BLOCK);\n-      SET_BIT (in_stack, node);\n+      bitmap_set_bit (in_stack, node);\n       dfs_nr[node] = ++count;\n \n       /* We don't traverse to the exit block.  */\n@@ -713,10 +713,10 @@ haifa_find_rgns (void)\n       /* If the successor is in the stack, then we've found a loop.\n \t Mark the loop, if it is not a natural loop, then it will\n \t be rejected during the second traversal.  */\n-      if (TEST_BIT (in_stack, child))\n+      if (bitmap_bit_p (in_stack, child))\n \t{\n \t  no_loops = 0;\n-\t  SET_BIT (header, child);\n+\t  bitmap_set_bit (header, child);\n \t  UPDATE_LOOP_RELATIONS (node, child);\n \t  SET_EDGE_PASSED (current_edge);\n \t  ei_next (&current_edge);\n@@ -728,7 +728,7 @@ haifa_find_rgns (void)\n \t with a new edge.  */\n       if (dfs_nr[child])\n \t{\n-\t  if (max_hdr[child] >= 0 && TEST_BIT (in_stack, max_hdr[child]))\n+\t  if (max_hdr[child] >= 0 && bitmap_bit_p (in_stack, max_hdr[child]))\n \t    UPDATE_LOOP_RELATIONS (node, max_hdr[child]);\n \t  SET_EDGE_PASSED (current_edge);\n \t  ei_next (&current_edge);\n@@ -786,7 +786,7 @@ haifa_find_rgns (void)\n       bool extend_regions_p;\n \n       if (no_loops)\n-\tSET_BIT (header, 0);\n+\tbitmap_set_bit (header, 0);\n \n       /* Second traversal:find reducible inner loops and topologically sort\n \t block of each region.  */\n@@ -805,7 +805,7 @@ haifa_find_rgns (void)\n \t loops to consider at this point.  */\n       FOR_EACH_BB (bb)\n \t{\n-\t  if (TEST_BIT (header, bb->index) && TEST_BIT (inner, bb->index))\n+\t  if (bitmap_bit_p (header, bb->index) && bitmap_bit_p (inner, bb->index))\n \t    {\n \t      edge e;\n \t      edge_iterator ei;\n@@ -876,7 +876,7 @@ haifa_find_rgns (void)\n \t\t\t&& single_succ (jbb) == EXIT_BLOCK_PTR)\n \t\t      {\n \t\t\tqueue[++tail] = jbb->index;\n-\t\t\tSET_BIT (in_queue, jbb->index);\n+\t\t\tbitmap_set_bit (in_queue, jbb->index);\n \n \t\t\tif (too_large (jbb->index, &num_bbs, &num_insns))\n \t\t\t  {\n@@ -900,7 +900,7 @@ haifa_find_rgns (void)\n \t\t\t{\n \t\t\t  /* This is a loop latch.  */\n \t\t\t  queue[++tail] = node;\n-\t\t\t  SET_BIT (in_queue, node);\n+\t\t\t  bitmap_set_bit (in_queue, node);\n \n \t\t\t  if (too_large (node, &num_bbs, &num_insns))\n \t\t\t    {\n@@ -958,10 +958,10 @@ haifa_find_rgns (void)\n \t\t\t  tail = -1;\n \t\t\t  break;\n \t\t\t}\n-\t\t      else if (!TEST_BIT (in_queue, node) && node != bb->index)\n+\t\t      else if (!bitmap_bit_p (in_queue, node) && node != bb->index)\n \t\t\t{\n \t\t\t  queue[++tail] = node;\n-\t\t\t  SET_BIT (in_queue, node);\n+\t\t\t  bitmap_set_bit (in_queue, node);\n \n \t\t\t  if (too_large (node, &num_bbs, &num_insns))\n \t\t\t    {\n@@ -1025,7 +1025,7 @@ haifa_find_rgns (void)\n \t\t     of one too_large region.  */\n                   FOR_EACH_EDGE (e, ei, bb->succs)\n                     if (e->dest != EXIT_BLOCK_PTR)\n-                      SET_BIT (extended_rgn_header, e->dest->index);\n+                      bitmap_set_bit (extended_rgn_header, e->dest->index);\n                 }\n \t    }\n \t}\n@@ -1194,7 +1194,7 @@ extend_rgns (int *degree, int *idxp, sbitmap header, int *loop_hdr)\n \t  edge_iterator ei;\n \t  int bbn = order[i];\n \n-\t  if (max_hdr[bbn] != -1 && !TEST_BIT (header, bbn))\n+\t  if (max_hdr[bbn] != -1 && !bitmap_bit_p (header, bbn))\n \t    {\n \t      int hdr = -1;\n \n@@ -1233,7 +1233,7 @@ extend_rgns (int *degree, int *idxp, sbitmap header, int *loop_hdr)\n \t\t{\n \t\t  /* If BB start its own region,\n \t\t     update set of headers with BB.  */\n-\t\t  SET_BIT (header, bbn);\n+\t\t  bitmap_set_bit (header, bbn);\n \t\t  rescan = 1;\n \t\t}\n \t      else\n@@ -1408,7 +1408,7 @@ compute_dom_prob_ps (int bb)\n \n   if (IS_RGN_ENTRY (bb))\n     {\n-      SET_BIT (dom[bb], 0);\n+      bitmap_set_bit (dom[bb], 0);\n       prob[bb] = REG_BR_PROB_BASE;\n       return;\n     }\n@@ -1432,17 +1432,17 @@ compute_dom_prob_ps (int bb)\n       bitmap_ior (ancestor_edges[bb],\n \t\t      ancestor_edges[bb], ancestor_edges[pred_bb]);\n \n-      SET_BIT (ancestor_edges[bb], EDGE_TO_BIT (in_edge));\n+      bitmap_set_bit (ancestor_edges[bb], EDGE_TO_BIT (in_edge));\n \n       bitmap_ior (pot_split[bb], pot_split[bb], pot_split[pred_bb]);\n \n       FOR_EACH_EDGE (out_edge, out_ei, in_edge->src->succs)\n-\tSET_BIT (pot_split[bb], EDGE_TO_BIT (out_edge));\n+\tbitmap_set_bit (pot_split[bb], EDGE_TO_BIT (out_edge));\n \n       prob[bb] += ((prob[pred_bb] * in_edge->probability) / REG_BR_PROB_BASE);\n     }\n \n-  SET_BIT (dom[bb], bb);\n+  bitmap_set_bit (dom[bb], bb);\n   bitmap_and_compl (pot_split[bb], pot_split[bb], ancestor_edges[bb]);\n \n   if (sched_verbose >= 2)\n@@ -1548,7 +1548,7 @@ compute_trg_info (int trg)\n \t      block = el.first_member[j]->src;\n \t      FOR_EACH_EDGE (e, ei, block->succs)\n \t\t{\n-\t\t  if (!TEST_BIT (visited, e->dest->index))\n+\t\t  if (!bitmap_bit_p (visited, e->dest->index))\n \t\t    {\n \t\t      for (k = 0; k < el.nr_members; k++)\n \t\t\tif (e == el.first_member[k])\n@@ -1557,7 +1557,7 @@ compute_trg_info (int trg)\n \t\t      if (k >= el.nr_members)\n \t\t\t{\n \t\t\t  bblst_table[bblst_last++] = e->dest;\n-\t\t\t  SET_BIT (visited, e->dest->index);\n+\t\t\t  bitmap_set_bit (visited, e->dest->index);\n \t\t\t  update_idx++;\n \t\t\t}\n \t\t    }\n@@ -1829,7 +1829,7 @@ update_live (rtx insn, int src)\n #define IS_REACHABLE(bb_from, bb_to)\t\t\t\t\t\\\n   (bb_from == bb_to\t\t\t\t\t\t\t\\\n    || IS_RGN_ENTRY (bb_from)\t\t\t\t\t\t\\\n-   || (TEST_BIT (ancestor_edges[bb_to],\t\t\t\t\t\\\n+   || (bitmap_bit_p (ancestor_edges[bb_to],\t\t\t\t\t\\\n \t EDGE_TO_BIT (single_pred_edge (BASIC_BLOCK (BB_TO_BLOCK (bb_from)))))))\n \n /* Turns on the fed_by_spec_load flag for insns fed by load_insn.  */\n@@ -2466,7 +2466,7 @@ add_branch_dependences (rtx head, rtx tail)\n \t    {\n \t      if (! sched_insns_conditions_mutex_p (last, insn))\n \t\tadd_dependence (last, insn, REG_DEP_ANTI);\n-\t      SET_BIT (insn_referenced, INSN_LUID (insn));\n+\t      bitmap_set_bit (insn_referenced, INSN_LUID (insn));\n \t    }\n \n \t  CANT_MOVE (insn) = 1;\n@@ -2490,7 +2490,7 @@ add_branch_dependences (rtx head, rtx tail)\n       {\n \tinsn = prev_nonnote_insn (insn);\n \n-\tif (TEST_BIT (insn_referenced, INSN_LUID (insn))\n+\tif (bitmap_bit_p (insn_referenced, INSN_LUID (insn))\n \t    || DEBUG_INSN_P (insn))\n \t  continue;\n "}, {"sha": "7b0f51242cf4a3afce8151a215a4e1c626c5a14c", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -6007,7 +6007,7 @@ make_region_from_loop (struct loop *loop)\n   new_rgn_number = sel_create_new_region ();\n \n   sel_add_block_to_region (preheader_block, &bb_ord_index, new_rgn_number);\n-  SET_BIT (bbs_in_loop_rgns, preheader_block->index);\n+  bitmap_set_bit (bbs_in_loop_rgns, preheader_block->index);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n@@ -6018,11 +6018,11 @@ make_region_from_loop (struct loop *loop)\n \n       gcc_assert (new_rgn_number >= 0);\n \n-      if (! TEST_BIT (bbs_in_loop_rgns, loop_blocks[i]->index))\n+      if (! bitmap_bit_p (bbs_in_loop_rgns, loop_blocks[i]->index))\n \t{\n \t  sel_add_block_to_region (loop_blocks[i], &bb_ord_index,\n                                    new_rgn_number);\n-\t  SET_BIT (bbs_in_loop_rgns, loop_blocks[i]->index);\n+\t  bitmap_set_bit (bbs_in_loop_rgns, loop_blocks[i]->index);\n \t}\n     }\n \n@@ -6068,7 +6068,7 @@ make_regions_from_loop_nest (struct loop *loop)\n \n   /* Traverse all inner nodes of the loop.  */\n   for (cur_loop = loop->inner; cur_loop; cur_loop = cur_loop->next)\n-    if (! TEST_BIT (bbs_in_loop_rgns, cur_loop->header->index))\n+    if (! bitmap_bit_p (bbs_in_loop_rgns, cur_loop->header->index))\n       return false;\n \n   /* At this moment all regular inner loops should have been pipelined.\n@@ -6182,10 +6182,10 @@ make_regions_from_the_rest (void)\n     {\n       degree[bb->index] = 0;\n \n-      if (!TEST_BIT (bbs_in_loop_rgns, bb->index))\n+      if (!bitmap_bit_p (bbs_in_loop_rgns, bb->index))\n \t{\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    if (!TEST_BIT (bbs_in_loop_rgns, e->src->index))\n+\t    if (!bitmap_bit_p (bbs_in_loop_rgns, e->src->index))\n \t      degree[bb->index]++;\n \t}\n       else"}, {"sha": "fd018242288b6548dd9318118086360bb17a3168", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -6732,7 +6732,7 @@ init_seqno_1 (basic_block bb, sbitmap visited_bbs, bitmap blocks_to_reschedule)\n   insn_t succ_insn;\n   succ_iterator si;\n \n-  SET_BIT (visited_bbs, bbi);\n+  bitmap_set_bit (visited_bbs, bbi);\n   if (blocks_to_reschedule)\n     bitmap_clear_bit (blocks_to_reschedule, bb->index);\n \n@@ -6744,7 +6744,7 @@ init_seqno_1 (basic_block bb, sbitmap visited_bbs, bitmap blocks_to_reschedule)\n \n       gcc_assert (in_current_region_p (succ));\n \n-      if (!TEST_BIT (visited_bbs, succ_bbi))\n+      if (!bitmap_bit_p (visited_bbs, succ_bbi))\n \t{\n \t  gcc_assert (succ_bbi > bbi);\n \n@@ -6779,7 +6779,7 @@ init_seqno (bitmap blocks_to_reschedule, basic_block from)\n       EXECUTE_IF_SET_IN_BITMAP (blocks_to_reschedule, 0, bbi, bi)\n         {\n \t  gcc_assert (BLOCK_TO_BB (bbi) < current_nr_blocks);\n-          RESET_BIT (visited_bbs, BLOCK_TO_BB (bbi));\n+          bitmap_clear_bit (visited_bbs, BLOCK_TO_BB (bbi));\n \t}\n     }\n   else"}, {"sha": "1cf883297f541e59c8f515bb1ccc0266e861a98a", "filename": "gcc/store-motion.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -796,7 +796,7 @@ insert_store (struct st_expr * expr, edge e)\n \tint index = EDGE_INDEX (edge_list, tmp->src, tmp->dest);\n \n \tgcc_assert (index != EDGE_INDEX_NO_EDGE);\n-\tif (! TEST_BIT (st_insert_map[index], expr->index))\n+\tif (! bitmap_bit_p (st_insert_map[index], expr->index))\n \t  break;\n       }\n \n@@ -807,7 +807,7 @@ insert_store (struct st_expr * expr, edge e)\n       FOR_EACH_EDGE (tmp, ei, e->dest->preds)\n \t{\n \t  int index = EDGE_INDEX (edge_list, tmp->src, tmp->dest);\n-\t  RESET_BIT (st_insert_map[index], expr->index);\n+\t  bitmap_clear_bit (st_insert_map[index], expr->index);\n \t}\n       insert_insn_start_basic_block (insn, bb);\n       return 0;\n@@ -867,16 +867,16 @@ remove_reachable_equiv_notes (basic_block bb, struct st_expr *smexpr)\n       bb = act->dest;\n \n       if (bb == EXIT_BLOCK_PTR\n-\t  || TEST_BIT (visited, bb->index))\n+\t  || bitmap_bit_p (visited, bb->index))\n \t{\n \t  if (!ei_end_p (ei))\n \t      ei_next (&ei);\n \t  act = (! ei_end_p (ei)) ? ei_edge (ei) : NULL;\n \t  continue;\n \t}\n-      SET_BIT (visited, bb->index);\n+      bitmap_set_bit (visited, bb->index);\n \n-      if (TEST_BIT (st_antloc[bb->index], smexpr->index))\n+      if (bitmap_bit_p (st_antloc[bb->index], smexpr->index))\n \t{\n \t  for (last = smexpr->antic_stores;\n \t       BLOCK_FOR_INSN (XEXP (last, 0)) != bb;\n@@ -1030,22 +1030,22 @@ build_store_vectors (void)\n \t     we can delete this one (It occurs earlier in the block). We'll\n \t     copy the SRC expression to an unused register in case there\n \t     are any side effects.  */\n-\t  if (TEST_BIT (st_avloc[bb->index], ptr->index))\n+\t  if (bitmap_bit_p (st_avloc[bb->index], ptr->index))\n \t    {\n \t      rtx r = gen_reg_rtx_and_attrs (ptr->pattern);\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Removing redundant store:\\n\");\n \t      replace_store_insn (r, XEXP (st, 0), bb, ptr);\n \t      continue;\n \t    }\n-\t  SET_BIT (st_avloc[bb->index], ptr->index);\n+\t  bitmap_set_bit (st_avloc[bb->index], ptr->index);\n \t}\n \n       for (st = ptr->antic_stores; st != NULL; st = XEXP (st, 1))\n \t{\n \t  insn = XEXP (st, 0);\n \t  bb = BLOCK_FOR_INSN (insn);\n-\t  SET_BIT (st_antloc[bb->index], ptr->index);\n+\t  bitmap_set_bit (st_antloc[bb->index], ptr->index);\n \t}\n     }\n \n@@ -1079,12 +1079,12 @@ build_store_vectors (void)\n \t    {\n \t      /* It should not be necessary to consider the expression\n \t\t killed if it is both anticipatable and available.  */\n-\t      if (!TEST_BIT (st_antloc[bb->index], ptr->index)\n-\t\t  || !TEST_BIT (st_avloc[bb->index], ptr->index))\n-\t\tSET_BIT (st_kill[bb->index], ptr->index);\n+\t      if (!bitmap_bit_p (st_antloc[bb->index], ptr->index)\n+\t\t  || !bitmap_bit_p (st_avloc[bb->index], ptr->index))\n+\t\tbitmap_set_bit (st_kill[bb->index], ptr->index);\n \t    }\n \t  else\n-\t    SET_BIT (st_transp[bb->index], ptr->index);\n+\t    bitmap_set_bit (st_transp[bb->index], ptr->index);\n \t}\n     }\n \n@@ -1164,7 +1164,7 @@ one_store_motion_pass (void)\n       /* If any of the edges we have above are abnormal, we can't move this\n \t store.  */\n       for (x = NUM_EDGES (edge_list) - 1; x >= 0; x--)\n-\tif (TEST_BIT (st_insert_map[x], ptr->index)\n+\tif (bitmap_bit_p (st_insert_map[x], ptr->index)\n \t    && (INDEX_EDGE (edge_list, x)->flags & EDGE_ABNORMAL))\n \t  break;\n \n@@ -1181,14 +1181,14 @@ one_store_motion_pass (void)\n       /* Now we want to insert the new stores which are going to be needed.  */\n \n       FOR_EACH_BB (bb)\n-\tif (TEST_BIT (st_delete_map[bb->index], ptr->index))\n+\tif (bitmap_bit_p (st_delete_map[bb->index], ptr->index))\n \t  {\n \t    delete_store (ptr, bb);\n \t    n_stores_deleted++;\n \t  }\n \n       for (x = 0; x < NUM_EDGES (edge_list); x++)\n-\tif (TEST_BIT (st_insert_map[x], ptr->index))\n+\tif (bitmap_bit_p (st_insert_map[x], ptr->index))\n \t  {\n \t    did_edge_inserts |= insert_store (ptr, INDEX_EDGE (edge_list, x));\n \t    n_stores_created++;"}, {"sha": "b13e3a1b03f6042b42f32ede3fa73726f0184080", "filename": "gcc/tracer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -74,13 +74,13 @@ mark_bb_seen (basic_block bb)\n   if ((unsigned int)bb->index >= size)\n     bb_seen = sbitmap_resize (bb_seen, size * 2, 0);\n \n-  SET_BIT (bb_seen, bb->index);\n+  bitmap_set_bit (bb_seen, bb->index);\n }\n \n static inline bool\n bb_seen_p (basic_block bb)\n {\n-  return TEST_BIT (bb_seen, bb->index);\n+  return bitmap_bit_p (bb_seen, bb->index);\n }\n \n /* Return true if we should ignore the basic block for purposes of tracing.  */"}, {"sha": "183b9b9f338fd99175dbcf2e00e7f5f87ec933dc", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -7174,7 +7174,7 @@ gimple_flow_call_edges_add (sbitmap blocks)\n   if (! blocks)\n     check_last_block = true;\n   else\n-    check_last_block = TEST_BIT (blocks, EXIT_BLOCK_PTR->prev_bb->index);\n+    check_last_block = bitmap_bit_p (blocks, EXIT_BLOCK_PTR->prev_bb->index);\n \n   /* In the last basic block, before epilogue generation, there will be\n      a fallthru edge to EXIT.  Special care is required if the last insn\n@@ -7222,7 +7222,7 @@ gimple_flow_call_edges_add (sbitmap blocks)\n       if (!bb)\n \tcontinue;\n \n-      if (blocks && !TEST_BIT (blocks, i))\n+      if (blocks && !bitmap_bit_p (blocks, i))\n \tcontinue;\n \n       gsi = gsi_last_nondebug_bb (bb);"}, {"sha": "9056243cd4bd424386ddfd79a9bef35c5d4da693", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -3551,25 +3551,25 @@ remove_unreachable_handlers (void)\n \t  /* Negative LP numbers are MUST_NOT_THROW regions which\n \t     are not considered BB enders.  */\n \t  if (lp_nr < 0)\n-\t    SET_BIT (r_reachable, -lp_nr);\n+\t    bitmap_set_bit (r_reachable, -lp_nr);\n \n \t  /* Positive LP numbers are real landing pads, are are BB enders.  */\n \t  else if (lp_nr > 0)\n \t    {\n \t      gcc_assert (gsi_one_before_end_p (gsi));\n \t      region = get_eh_region_from_lp_number (lp_nr);\n-\t      SET_BIT (r_reachable, region->index);\n-\t      SET_BIT (lp_reachable, lp_nr);\n+\t      bitmap_set_bit (r_reachable, region->index);\n+\t      bitmap_set_bit (lp_reachable, lp_nr);\n \t    }\n \n \t  /* Avoid removing regions referenced from RESX/EH_DISPATCH.  */\n \t  switch (gimple_code (stmt))\n \t    {\n \t    case GIMPLE_RESX:\n-\t      SET_BIT (r_reachable, gimple_resx_region (stmt));\n+\t      bitmap_set_bit (r_reachable, gimple_resx_region (stmt));\n \t      break;\n \t    case GIMPLE_EH_DISPATCH:\n-\t      SET_BIT (r_reachable, gimple_eh_dispatch_region (stmt));\n+\t      bitmap_set_bit (r_reachable, gimple_eh_dispatch_region (stmt));\n \t      break;\n \t    default:\n \t      break;\n@@ -3589,7 +3589,7 @@ remove_unreachable_handlers (void)\n \n   for (r_nr = 1;\n        VEC_iterate (eh_region, cfun->eh->region_array, r_nr, region); ++r_nr)\n-    if (region && !TEST_BIT (r_reachable, r_nr))\n+    if (region && !bitmap_bit_p (r_reachable, r_nr))\n       {\n \tif (dump_file)\n \t  fprintf (dump_file, \"Removing unreachable region %d\\n\", r_nr);\n@@ -3598,7 +3598,7 @@ remove_unreachable_handlers (void)\n \n   for (lp_nr = 1;\n        VEC_iterate (eh_landing_pad, cfun->eh->lp_array, lp_nr, lp); ++lp_nr)\n-    if (lp && !TEST_BIT (lp_reachable, lp_nr))\n+    if (lp && !bitmap_bit_p (lp_reachable, lp_nr))\n       {\n \tif (dump_file)\n \t  fprintf (dump_file, \"Removing unreachable landing pad %d\\n\", lp_nr);\n@@ -3666,10 +3666,10 @@ remove_unreachable_handlers_no_lp (void)\n \tswitch (gimple_code (stmt))\n \t  {\n \t  case GIMPLE_RESX:\n-\t    SET_BIT (r_reachable, gimple_resx_region (stmt));\n+\t    bitmap_set_bit (r_reachable, gimple_resx_region (stmt));\n \t    break;\n \t  case GIMPLE_EH_DISPATCH:\n-\t    SET_BIT (r_reachable, gimple_eh_dispatch_region (stmt));\n+\t    bitmap_set_bit (r_reachable, gimple_eh_dispatch_region (stmt));\n \t    break;\n \t  default:\n \t    break;\n@@ -3678,7 +3678,7 @@ remove_unreachable_handlers_no_lp (void)\n \n   for (i = 1; VEC_iterate (eh_region, cfun->eh->region_array, i, r); ++i)\n     if (r && r->landing_pads == NULL && r->type != ERT_MUST_NOT_THROW\n-\t&& !TEST_BIT (r_reachable, i))\n+\t&& !bitmap_bit_p (r_reachable, i))\n       {\n \tif (dump_file)\n \t  fprintf (dump_file, \"Removing unreachable region %d\\n\", i);"}, {"sha": "3098e1f1ffcb064af413a634788b37b1937e3c53", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -541,7 +541,7 @@ is_old_name (tree name)\n   if (!new_ssa_names)\n     return false;\n   return (ver < SBITMAP_SIZE (new_ssa_names)\n-\t  && TEST_BIT (old_ssa_names, ver));\n+\t  && bitmap_bit_p (old_ssa_names, ver));\n }\n \n \n@@ -554,7 +554,7 @@ is_new_name (tree name)\n   if (!new_ssa_names)\n     return false;\n   return (ver < SBITMAP_SIZE (new_ssa_names)\n-\t  && TEST_BIT (new_ssa_names, ver));\n+\t  && bitmap_bit_p (new_ssa_names, ver));\n }\n \n \n@@ -610,8 +610,8 @@ add_new_name_mapping (tree new_tree, tree old)\n \n   /* Register NEW_TREE and OLD in NEW_SSA_NAMES and OLD_SSA_NAMES,\n      respectively.  */\n-  SET_BIT (new_ssa_names, SSA_NAME_VERSION (new_tree));\n-  SET_BIT (old_ssa_names, SSA_NAME_VERSION (old));\n+  bitmap_set_bit (new_ssa_names, SSA_NAME_VERSION (new_tree));\n+  bitmap_set_bit (old_ssa_names, SSA_NAME_VERSION (old));\n }\n \n \n@@ -653,7 +653,7 @@ mark_def_sites (basic_block bb, gimple stmt, bitmap kills)\n \t  set_rewrite_uses (stmt, true);\n \t}\n       if (rewrite_uses_p (stmt))\n-\tSET_BIT (interesting_blocks, bb->index);\n+\tbitmap_set_bit (interesting_blocks, bb->index);\n       return;\n     }\n \n@@ -681,7 +681,7 @@ mark_def_sites (basic_block bb, gimple stmt, bitmap kills)\n   /* If we found the statement interesting then also mark the block BB\n      as interesting.  */\n   if (rewrite_uses_p (stmt) || register_defs_p (stmt))\n-    SET_BIT (interesting_blocks, bb->index);\n+    bitmap_set_bit (interesting_blocks, bb->index);\n }\n \n /* Structure used by prune_unused_phi_nodes to record bounds of the intervals\n@@ -1402,7 +1402,7 @@ rewrite_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   /* Step 2.  Rewrite every variable used in each statement in the block\n      with its immediate reaching definitions.  Update the current definition\n      of a variable when a new real or virtual definition is found.  */\n-  if (TEST_BIT (interesting_blocks, bb->index))\n+  if (bitmap_bit_p (interesting_blocks, bb->index))\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       rewrite_stmt (&gsi);\n \n@@ -2114,7 +2114,7 @@ rewrite_update_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     }\n \n   /* Step 2.  Rewrite every variable used in each statement in the block.  */\n-  if (TEST_BIT (interesting_blocks, bb->index))\n+  if (bitmap_bit_p (interesting_blocks, bb->index))\n     {\n       gcc_checking_assert (bitmap_bit_p (blocks_to_update, bb->index));\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -2668,7 +2668,7 @@ prepare_names_to_update (bool insert_phi_p)\n      want to replace existing instances.  */\n   if (names_to_release)\n     EXECUTE_IF_SET_IN_BITMAP (names_to_release, 0, i, bi)\n-      RESET_BIT (new_ssa_names, i);\n+      bitmap_clear_bit (new_ssa_names, i);\n \n   /* First process names in NEW_SSA_NAMES.  Otherwise, uses of old\n      names may be considered to be live-in on blocks that contain\n@@ -3276,7 +3276,7 @@ update_ssa (unsigned update_flags)\n   interesting_blocks = sbitmap_alloc (last_basic_block);\n   bitmap_clear (interesting_blocks);\n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_update, 0, i, bi)\n-    SET_BIT (interesting_blocks, i);\n+    bitmap_set_bit (interesting_blocks, i);\n \n   rewrite_blocks (start_bb, REWRITE_UPDATE);\n "}, {"sha": "444ea329790e4cefebf8cfc0f10ae4261c5768ec", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -550,10 +550,10 @@ elim_forward (elim_graph g, int T)\n   int S;\n   source_location locus;\n \n-  SET_BIT (g->visited, T);\n+  bitmap_set_bit (g->visited, T);\n   FOR_EACH_ELIM_GRAPH_SUCC (g, T, S, locus,\n     {\n-      if (!TEST_BIT (g->visited, S))\n+      if (!bitmap_bit_p (g->visited, S))\n         elim_forward (g, S);\n     });\n   VEC_safe_push (int, heap, g->stack, T);\n@@ -570,7 +570,7 @@ elim_unvisited_predecessor (elim_graph g, int T)\n \n   FOR_EACH_ELIM_GRAPH_PRED (g, T, P, locus,\n     {\n-      if (!TEST_BIT (g->visited, P))\n+      if (!bitmap_bit_p (g->visited, P))\n         return 1;\n     });\n   return 0;\n@@ -584,10 +584,10 @@ elim_backward (elim_graph g, int T)\n   int P;\n   source_location locus;\n \n-  SET_BIT (g->visited, T);\n+  bitmap_set_bit (g->visited, T);\n   FOR_EACH_ELIM_GRAPH_PRED (g, T, P, locus,\n     {\n-      if (!TEST_BIT (g->visited, P))\n+      if (!bitmap_bit_p (g->visited, P))\n         {\n \t  elim_backward (g, P);\n \t  insert_partition_copy_on_edge (g->e, P, T, locus);\n@@ -629,7 +629,7 @@ elim_create (elim_graph g, int T)\n       insert_part_to_rtx_on_edge (g->e, U, T, UNKNOWN_LOCATION);\n       FOR_EACH_ELIM_GRAPH_PRED (g, T, P, locus,\n \t{\n-\t  if (!TEST_BIT (g->visited, P))\n+\t  if (!bitmap_bit_p (g->visited, P))\n \t    {\n \t      elim_backward (g, P);\n \t      insert_rtx_to_part_on_edge (g->e, P, U, unsignedsrcp, locus);\n@@ -641,7 +641,7 @@ elim_create (elim_graph g, int T)\n       S = elim_graph_remove_succ_edge (g, T, &locus);\n       if (S != -1)\n \t{\n-\t  SET_BIT (g->visited, T);\n+\t  bitmap_set_bit (g->visited, T);\n \t  insert_partition_copy_on_edge (g->e, T, S, locus);\n \t}\n     }\n@@ -675,15 +675,15 @@ eliminate_phi (edge e, elim_graph g)\n \n       FOR_EACH_VEC_ELT (int, g->nodes, x, part)\n         {\n-\t  if (!TEST_BIT (g->visited, part))\n+\t  if (!bitmap_bit_p (g->visited, part))\n \t    elim_forward (g, part);\n \t}\n \n       bitmap_clear (g->visited);\n       while (VEC_length (int, g->stack) > 0)\n \t{\n \t  x = VEC_pop (int, g->stack);\n-\t  if (!TEST_BIT (g->visited, x))\n+\t  if (!bitmap_bit_p (g->visited, x))\n \t    elim_create (g, x);\n \t}\n     }"}, {"sha": "af4c387c23e64fb98afdb33f96d53332cef4bca5", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -214,7 +214,7 @@ mark_stmt_necessary (gimple stmt, bool add_to_worklist)\n   if (add_to_worklist)\n     VEC_safe_push (gimple, heap, worklist, stmt);\n   if (bb_contains_live_stmts && !is_gimple_debug (stmt))\n-    SET_BIT (bb_contains_live_stmts, gimple_bb (stmt)->index);\n+    bitmap_set_bit (bb_contains_live_stmts, gimple_bb (stmt)->index);\n }\n \n \n@@ -229,14 +229,14 @@ mark_operand_necessary (tree op)\n   gcc_assert (op);\n \n   ver = SSA_NAME_VERSION (op);\n-  if (TEST_BIT (processed, ver))\n+  if (bitmap_bit_p (processed, ver))\n     {\n       stmt = SSA_NAME_DEF_STMT (op);\n       gcc_assert (gimple_nop_p (stmt)\n \t\t  || gimple_plf (stmt, STMT_NECESSARY));\n       return;\n     }\n-  SET_BIT (processed, ver);\n+  bitmap_set_bit (processed, ver);\n \n   stmt = SSA_NAME_DEF_STMT (op);\n   gcc_assert (stmt);\n@@ -254,7 +254,7 @@ mark_operand_necessary (tree op)\n \n   gimple_set_plf (stmt, STMT_NECESSARY, true);\n   if (bb_contains_live_stmts)\n-    SET_BIT (bb_contains_live_stmts, gimple_bb (stmt)->index);\n+    bitmap_set_bit (bb_contains_live_stmts, gimple_bb (stmt)->index);\n   VEC_safe_push (gimple, heap, worklist, stmt);\n }\n \n@@ -386,8 +386,8 @@ mark_last_stmt_necessary (basic_block bb)\n {\n   gimple stmt = last_stmt (bb);\n \n-  SET_BIT (last_stmt_necessary, bb->index);\n-  SET_BIT (bb_contains_live_stmts, bb->index);\n+  bitmap_set_bit (last_stmt_necessary, bb->index);\n+  bitmap_set_bit (bb_contains_live_stmts, bb->index);\n \n   /* We actually mark the statement only if it is a control statement.  */\n   if (stmt && is_ctrl_stmt (stmt))\n@@ -423,12 +423,12 @@ mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el,\n \t  continue;\n \t}\n \n-      if (!TEST_BIT (last_stmt_necessary, cd_bb->index))\n+      if (!bitmap_bit_p (last_stmt_necessary, cd_bb->index))\n \tmark_last_stmt_necessary (cd_bb);\n     }\n \n   if (!skipped)\n-    SET_BIT (visited_control_parents, bb->index);\n+    bitmap_set_bit (visited_control_parents, bb->index);\n }\n \n \n@@ -617,7 +617,7 @@ mark_all_reaching_defs_necessary_1 (ao_ref *ref ATTRIBUTE_UNUSED,\n   /* We have to skip already visited (and thus necessary) statements\n      to make the chaining work after we dropped back to simple mode.  */\n   if (chain_ovfl\n-      && TEST_BIT (processed, SSA_NAME_VERSION (vdef)))\n+      && bitmap_bit_p (processed, SSA_NAME_VERSION (vdef)))\n     {\n       gcc_assert (gimple_nop_p (def_stmt)\n \t\t  || gimple_plf (def_stmt, STMT_NECESSARY));\n@@ -713,7 +713,7 @@ propagate_necessity (struct edge_list *el)\n \t     already done so.  */\n \t  basic_block bb = gimple_bb (stmt);\n \t  if (bb != ENTRY_BLOCK_PTR\n-\t      && !TEST_BIT (visited_control_parents, bb->index))\n+\t      && !bitmap_bit_p (visited_control_parents, bb->index))\n \t    mark_control_dependent_edges_necessary (bb, el, false);\n \t}\n \n@@ -815,11 +815,11 @@ propagate_necessity (struct edge_list *el)\n \t\t  if (gimple_bb (stmt)\n \t\t      != get_immediate_dominator (CDI_POST_DOMINATORS, arg_bb))\n \t\t    {\n-\t\t      if (!TEST_BIT (last_stmt_necessary, arg_bb->index))\n+\t\t      if (!bitmap_bit_p (last_stmt_necessary, arg_bb->index))\n \t\t\tmark_last_stmt_necessary (arg_bb);\n \t\t    }\n \t\t  else if (arg_bb != ENTRY_BLOCK_PTR\n-\t\t           && !TEST_BIT (visited_control_parents,\n+\t\t           && !bitmap_bit_p (visited_control_parents,\n \t\t\t\t\t arg_bb->index))\n \t\t    mark_control_dependent_edges_necessary (arg_bb, el, true);\n \t\t}\n@@ -1342,7 +1342,7 @@ eliminate_unnecessary_stmts (void)\n \t\t call (); saving one operand.  */\n \t      if (name\n \t\t  && TREE_CODE (name) == SSA_NAME\n-\t\t  && !TEST_BIT (processed, SSA_NAME_VERSION (name))\n+\t\t  && !bitmap_bit_p (processed, SSA_NAME_VERSION (name))\n \t\t  /* Avoid doing so for allocation calls which we\n \t\t     did not mark as necessary, it will confuse the\n \t\t     special logic we apply to malloc/free pair removal.  */\n@@ -1387,7 +1387,7 @@ eliminate_unnecessary_stmts (void)\n \t{\n \t  prev_bb = bb->prev_bb;\n \n-\t  if (!TEST_BIT (bb_contains_live_stmts, bb->index)\n+\t  if (!bitmap_bit_p (bb_contains_live_stmts, bb->index)\n \t      || !(bb->flags & BB_REACHABLE))\n \t    {\n \t      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))"}, {"sha": "157f2db221f8e70c529ae9cfce4a1f9d8e4ef5e3", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -968,9 +968,9 @@ loe_visit_block (tree_live_info_p live, basic_block bb, sbitmap visited,\n   edge_iterator ei;\n   basic_block pred_bb;\n   bitmap loe;\n-  gcc_assert (!TEST_BIT (visited, bb->index));\n+  gcc_assert (!bitmap_bit_p (visited, bb->index));\n \n-  SET_BIT (visited, bb->index);\n+  bitmap_set_bit (visited, bb->index);\n   loe = live_on_entry (live, bb);\n \n   FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -988,9 +988,9 @@ loe_visit_block (tree_live_info_p live, basic_block bb, sbitmap visited,\n \t changes, and pred_bb has been visited already, add it to the\n \t revisit stack.  */\n       change = bitmap_ior_into (live_on_entry (live, pred_bb), tmp);\n-      if (TEST_BIT (visited, pred_bb->index) && change)\n+      if (bitmap_bit_p (visited, pred_bb->index) && change)\n \t{\n-\t  RESET_BIT (visited, pred_bb->index);\n+\t  bitmap_clear_bit (visited, pred_bb->index);\n \t  *(live->stack_top)++ = pred_bb->index;\n \t}\n     }"}, {"sha": "4274457d4dc351625b54cca0a3d732e48e3c03f4", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -2523,7 +2523,7 @@ fill_always_executed_in (struct loop *loop, sbitmap contains_call)\n \t  if (dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n \t    last = bb;\n \n-\t  if (TEST_BIT (contains_call, bb->index))\n+\t  if (bitmap_bit_p (contains_call, bb->index))\n \t    break;\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -2588,7 +2588,7 @@ tree_ssa_lim_initialize (void)\n \t}\n \n       if (!gsi_end_p (bsi))\n-\tSET_BIT (contains_call, bb->index);\n+\tbitmap_set_bit (contains_call, bb->index);\n     }\n \n   for (loop = current_loops->tree_root->inner; loop; loop = loop->next)"}, {"sha": "6f37f37cbaaf52ac5c45e8ccb61d3d9b8ab23387", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -521,7 +521,7 @@ try_unroll_loop_completely (struct loop *loop,\n       initialize_original_copy_tables ();\n       wont_exit = sbitmap_alloc (n_unroll + 1);\n       bitmap_ones (wont_exit);\n-      RESET_BIT (wont_exit, 0);\n+      bitmap_clear_bit (wont_exit, 0);\n \n       if (!gimple_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t\t n_unroll, wont_exit,"}, {"sha": "e43d40c43ce1fde28f9dbbcc240063e6b2a8e350", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -3082,14 +3082,14 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode,\n \t{\n \t  XEXP (addr, 1) = gen_int_mode (i, address_mode);\n \t  if (memory_address_addr_space_p (mode, addr, as))\n-\t    SET_BIT (valid_mult, i + MAX_RATIO);\n+\t    bitmap_set_bit (valid_mult, i + MAX_RATIO);\n \t}\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"  allowed multipliers:\");\n \t  for (i = -MAX_RATIO; i <= MAX_RATIO; i++)\n-\t    if (TEST_BIT (valid_mult, i + MAX_RATIO))\n+\t    if (bitmap_bit_p (valid_mult, i + MAX_RATIO))\n \t      fprintf (dump_file, \" %d\", (int) i);\n \t  fprintf (dump_file, \"\\n\");\n \t  fprintf (dump_file, \"\\n\");\n@@ -3101,7 +3101,7 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode,\n   if (ratio > MAX_RATIO || ratio < -MAX_RATIO)\n     return false;\n \n-  return TEST_BIT (valid_mult, ratio + MAX_RATIO);\n+  return bitmap_bit_p (valid_mult, ratio + MAX_RATIO);\n }\n \n /* Returns cost of address in shape symbol + var + OFFSET + RATIO * index."}, {"sha": "d80b91cc31de8454b6f064299865895b421cca11", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -1173,7 +1173,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n      last one.  */\n   wont_exit = sbitmap_alloc (factor);\n   bitmap_ones (wont_exit);\n-  RESET_BIT (wont_exit, factor - 1);\n+  bitmap_clear_bit (wont_exit, factor - 1);\n \n   ok = gimple_duplicate_loop_to_header_edge\n \t  (loop, loop_latch_edge (loop), factor - 1,"}, {"sha": "3856b92ac0d5460096399393a608f00db597ee78", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -479,8 +479,8 @@ blocks_in_phiopt_order (void)\n   unsigned np, i;\n   sbitmap visited = sbitmap_alloc (last_basic_block);\n \n-#define MARK_VISITED(BB) (SET_BIT (visited, (BB)->index))\n-#define VISITED_P(BB) (TEST_BIT (visited, (BB)->index))\n+#define MARK_VISITED(BB) (bitmap_set_bit (visited, (BB)->index))\n+#define VISITED_P(BB) (bitmap_bit_p (visited, (BB)->index))\n \n   bitmap_clear (visited);\n "}, {"sha": "191de51b75d2636804cac2ee1905dec39e043a5e", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -2119,7 +2119,7 @@ defer_or_phi_translate_block (bitmap_set_t dest, bitmap_set_t source,\n {\n   if (!BB_VISITED (phiblock))\n     {\n-      SET_BIT (changed_blocks, block->index);\n+      bitmap_set_bit (changed_blocks, block->index);\n       BB_VISITED (block) = 0;\n       BB_DEFERRED (block) = 1;\n       return false;\n@@ -2215,7 +2215,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n       /* Of multiple successors we have to have visited one already.  */\n       if (!first)\n \t{\n-\t  SET_BIT (changed_blocks, block->index);\n+\t  bitmap_set_bit (changed_blocks, block->index);\n \t  BB_VISITED (block) = 0;\n \t  BB_DEFERRED (block) = 1;\n \t  changed = true;\n@@ -2265,12 +2265,12 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n   if (!bitmap_set_equal (old, ANTIC_IN (block)))\n     {\n       changed = true;\n-      SET_BIT (changed_blocks, block->index);\n+      bitmap_set_bit (changed_blocks, block->index);\n       FOR_EACH_EDGE (e, ei, block->preds)\n-\tSET_BIT (changed_blocks, e->src->index);\n+\tbitmap_set_bit (changed_blocks, e->src->index);\n     }\n   else\n-    RESET_BIT (changed_blocks, block->index);\n+    bitmap_clear_bit (changed_blocks, block->index);\n \n  maybe_dump_sets:\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2422,12 +2422,12 @@ compute_partial_antic_aux (basic_block block,\n   if (!bitmap_set_equal (old_PA_IN, PA_IN (block)))\n     {\n       changed = true;\n-      SET_BIT (changed_blocks, block->index);\n+      bitmap_set_bit (changed_blocks, block->index);\n       FOR_EACH_EDGE (e, ei, block->preds)\n-\tSET_BIT (changed_blocks, e->src->index);\n+\tbitmap_set_bit (changed_blocks, e->src->index);\n     }\n   else\n-    RESET_BIT (changed_blocks, block->index);\n+    bitmap_clear_bit (changed_blocks, block->index);\n \n  maybe_dump_sets:\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2469,7 +2469,7 @@ compute_antic (void)\n \t  e->flags &= ~EDGE_DFS_BACK;\n \t  if (e->flags & EDGE_ABNORMAL)\n \t    {\n-\t      SET_BIT (has_abnormal_preds, block->index);\n+\t      bitmap_set_bit (has_abnormal_preds, block->index);\n \t      break;\n \t    }\n \t}\n@@ -2499,11 +2499,11 @@ compute_antic (void)\n       changed = false;\n       for (i = postorder_num - 1; i >= 0; i--)\n \t{\n-\t  if (TEST_BIT (changed_blocks, postorder[i]))\n+\t  if (bitmap_bit_p (changed_blocks, postorder[i]))\n \t    {\n \t      basic_block block = BASIC_BLOCK (postorder[i]);\n \t      changed |= compute_antic_aux (block,\n-\t\t\t\t\t    TEST_BIT (has_abnormal_preds,\n+\t\t\t\t\t    bitmap_bit_p (has_abnormal_preds,\n \t\t\t\t\t\t      block->index));\n \t    }\n \t}\n@@ -2528,12 +2528,12 @@ compute_antic (void)\n \t  changed = false;\n \t  for (i = postorder_num - 1 ; i >= 0; i--)\n \t    {\n-\t      if (TEST_BIT (changed_blocks, postorder[i]))\n+\t      if (bitmap_bit_p (changed_blocks, postorder[i]))\n \t\t{\n \t\t  basic_block block = BASIC_BLOCK (postorder[i]);\n \t\t  changed\n \t\t    |= compute_partial_antic_aux (block,\n-\t\t\t\t\t\t  TEST_BIT (has_abnormal_preds,\n+\t\t\t\t\t\t  bitmap_bit_p (has_abnormal_preds,\n \t\t\t\t\t\t\t    block->index));\n \t\t}\n \t    }"}, {"sha": "ca6fc3366181416bbc7f4ddf44fd8cd250c90d2a", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -177,7 +177,7 @@ cfg_blocks_add (basic_block bb)\n   bool head = false;\n \n   gcc_assert (bb != ENTRY_BLOCK_PTR && bb != EXIT_BLOCK_PTR);\n-  gcc_assert (!TEST_BIT (bb_in_list, bb->index));\n+  gcc_assert (!bitmap_bit_p (bb_in_list, bb->index));\n \n   if (cfg_blocks_empty_p ())\n     {\n@@ -218,7 +218,7 @@ cfg_blocks_add (basic_block bb)\n   VEC_replace (basic_block, cfg_blocks,\n \t       head ? cfg_blocks_head : cfg_blocks_tail,\n \t       bb);\n-  SET_BIT (bb_in_list, bb->index);\n+  bitmap_set_bit (bb_in_list, bb->index);\n }\n \n \n@@ -237,7 +237,7 @@ cfg_blocks_get (void)\n   cfg_blocks_head = ((cfg_blocks_head + 1)\n \t\t     % VEC_length (basic_block, cfg_blocks));\n   --cfg_blocks_num;\n-  RESET_BIT (bb_in_list, bb->index);\n+  bitmap_clear_bit (bb_in_list, bb->index);\n \n   return bb;\n }\n@@ -286,7 +286,7 @@ add_control_edge (edge e)\n   e->flags |= EDGE_EXECUTABLE;\n \n   /* If the block is already in the list, we're done.  */\n-  if (TEST_BIT (bb_in_list, bb->index))\n+  if (bitmap_bit_p (bb_in_list, bb->index))\n     return;\n \n   cfg_blocks_add (bb);\n@@ -390,7 +390,7 @@ process_ssa_edge_worklist (VEC(gimple,gc) **worklist)\n \t the destination block is executable.  Otherwise, visit the\n \t statement only if its block is marked executable.  */\n       if (gimple_code (stmt) == GIMPLE_PHI\n-\t  || TEST_BIT (executable_blocks, bb->index))\n+\t  || bitmap_bit_p (executable_blocks, bb->index))\n \tsimulate_stmt (stmt);\n     }\n }\n@@ -418,15 +418,15 @@ simulate_block (basic_block block)\n \n   /* If this is the first time we've simulated this block, then we\n      must simulate each of its statements.  */\n-  if (!TEST_BIT (executable_blocks, block->index))\n+  if (!bitmap_bit_p (executable_blocks, block->index))\n     {\n       gimple_stmt_iterator j;\n       unsigned int normal_edge_count;\n       edge e, normal_edge;\n       edge_iterator ei;\n \n       /* Note that we have simulated this block.  */\n-      SET_BIT (executable_blocks, block->index);\n+      bitmap_set_bit (executable_blocks, block->index);\n \n       for (j = gsi_start_bb (block); !gsi_end_p (j); gsi_next (&j))\n \t{"}, {"sha": "3be33ed4a7b659a8dc576a109f3a66781104ff33", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -1300,7 +1300,7 @@ undistribute_ops_list (enum tree_code opcode,\n \t  || !is_reassociable_op (oe1def, dcode, loop))\n \tcontinue;\n \n-      SET_BIT (candidates, i);\n+      bitmap_set_bit (candidates, i);\n       nr_candidates++;\n     }\n \n@@ -1410,7 +1410,7 @@ undistribute_ops_list (enum tree_code opcode,\n \t    {\n \t      if (oe1->op == c->op)\n \t\t{\n-\t\t  SET_BIT (candidates2, i);\n+\t\t  bitmap_set_bit (candidates2, i);\n \t\t  ++nr_candidates2;\n \t\t  break;\n \t\t}"}, {"sha": "e3fdeb6972cba9a27ee4be063075920ad0e0c2b8", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -1208,7 +1208,7 @@ build_pred_graph (void)\n   for (j = 0; j < FIRST_REF_NODE; j++)\n     {\n       if (!get_varinfo (j)->is_special_var)\n-\tSET_BIT (graph->direct_nodes, j);\n+\tbitmap_set_bit (graph->direct_nodes, j);\n     }\n \n   for (j = 0; j < graph->size; j++)\n@@ -1236,7 +1236,7 @@ build_pred_graph (void)\n \t  if (rhs.offset == 0 && lhs.offset == 0 && lhs.type == SCALAR)\n \t    add_pred_graph_edge (graph, lhsvar, FIRST_REF_NODE + rhsvar);\n \t  else\n-\t    RESET_BIT (graph->direct_nodes, lhsvar);\n+\t    bitmap_clear_bit (graph->direct_nodes, lhsvar);\n \t}\n       else if (rhs.type == ADDRESSOF)\n \t{\n@@ -1255,14 +1255,14 @@ build_pred_graph (void)\n \t  add_implicit_graph_edge (graph, FIRST_REF_NODE + lhsvar, rhsvar);\n \n \t  /* All related variables are no longer direct nodes.  */\n-\t  RESET_BIT (graph->direct_nodes, rhsvar);\n+\t  bitmap_clear_bit (graph->direct_nodes, rhsvar);\n           v = get_varinfo (rhsvar);\n           if (!v->is_full_var)\n             {\n               v = lookup_vi_for_tree (v->decl);\n               do\n                 {\n-                  RESET_BIT (graph->direct_nodes, v->id);\n+                  bitmap_clear_bit (graph->direct_nodes, v->id);\n                   v = v->next;\n                 }\n               while (v != NULL);\n@@ -1281,9 +1281,9 @@ build_pred_graph (void)\n       else if (lhs.offset != 0 || rhs.offset != 0)\n \t{\n \t  if (rhs.offset != 0)\n-\t    RESET_BIT (graph->direct_nodes, lhs.var);\n+\t    bitmap_clear_bit (graph->direct_nodes, lhs.var);\n \t  else if (lhs.offset != 0)\n-\t    RESET_BIT (graph->direct_nodes, rhs.var);\n+\t    bitmap_clear_bit (graph->direct_nodes, rhs.var);\n \t}\n     }\n }\n@@ -1339,7 +1339,7 @@ build_succ_graph (void)\n   t = find (storedanything_id);\n   for (i = integer_id + 1; i < FIRST_REF_NODE; ++i)\n     {\n-      if (!TEST_BIT (graph->direct_nodes, i)\n+      if (!bitmap_bit_p (graph->direct_nodes, i)\n \t  && get_varinfo (i)->may_have_pointers)\n \tadd_graph_edge (graph, find (i), t);\n     }\n@@ -1383,7 +1383,7 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n   bitmap_iterator bi;\n   unsigned int my_dfs;\n \n-  SET_BIT (si->visited, n);\n+  bitmap_set_bit (si->visited, n);\n   si->dfs[n] = si->current_index ++;\n   my_dfs = si->dfs[n];\n \n@@ -1396,10 +1396,10 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \tbreak;\n \n       w = find (i);\n-      if (TEST_BIT (si->deleted, w))\n+      if (bitmap_bit_p (si->deleted, w))\n \tcontinue;\n \n-      if (!TEST_BIT (si->visited, w))\n+      if (!bitmap_bit_p (si->visited, w))\n \tscc_visit (graph, si, w);\n       {\n \tunsigned int t = find (w);\n@@ -1450,7 +1450,7 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \t\t}\n \t    }\n \t}\n-      SET_BIT (si->deleted, n);\n+      bitmap_set_bit (si->deleted, n);\n     }\n   else\n     VEC_safe_push (unsigned, heap, si->scc_stack, n);\n@@ -1559,12 +1559,12 @@ topo_visit (constraint_graph_t graph, struct topo_info *ti,\n   bitmap_iterator bi;\n   unsigned int j;\n \n-  SET_BIT (ti->visited, n);\n+  bitmap_set_bit (ti->visited, n);\n \n   if (graph->succs[n])\n     EXECUTE_IF_SET_IN_BITMAP (graph->succs[n], 0, j, bi)\n       {\n-\tif (!TEST_BIT (ti->visited, j))\n+\tif (!bitmap_bit_p (ti->visited, j))\n \t  topo_visit (graph, ti, j);\n       }\n \n@@ -1853,7 +1853,7 @@ find_indirect_cycles (constraint_graph_t graph)\n   struct scc_info *si = init_scc_info (size);\n \n   for (i = 0; i < MIN (LAST_REF_NODE, size); i ++ )\n-    if (!TEST_BIT (si->visited, i) && find (i) == i)\n+    if (!bitmap_bit_p (si->visited, i) && find (i) == i)\n       scc_visit (graph, si, i);\n \n   free_scc_info (si);\n@@ -1870,7 +1870,7 @@ compute_topo_order (constraint_graph_t graph,\n   unsigned int size = graph->size;\n \n   for (i = 0; i != size; ++i)\n-    if (!TEST_BIT (ti->visited, i) && find (i) == i)\n+    if (!bitmap_bit_p (ti->visited, i) && find (i) == i)\n       topo_visit (graph, ti, i);\n }\n \n@@ -2014,7 +2014,7 @@ condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n   unsigned int my_dfs;\n \n   gcc_assert (si->node_mapping[n] == n);\n-  SET_BIT (si->visited, n);\n+  bitmap_set_bit (si->visited, n);\n   si->dfs[n] = si->current_index ++;\n   my_dfs = si->dfs[n];\n \n@@ -2023,10 +2023,10 @@ condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n     {\n       unsigned int w = si->node_mapping[i];\n \n-      if (TEST_BIT (si->deleted, w))\n+      if (bitmap_bit_p (si->deleted, w))\n \tcontinue;\n \n-      if (!TEST_BIT (si->visited, w))\n+      if (!bitmap_bit_p (si->visited, w))\n \tcondense_visit (graph, si, w);\n       {\n \tunsigned int t = si->node_mapping[w];\n@@ -2043,10 +2043,10 @@ condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n     {\n       unsigned int w = si->node_mapping[i];\n \n-      if (TEST_BIT (si->deleted, w))\n+      if (bitmap_bit_p (si->deleted, w))\n \tcontinue;\n \n-      if (!TEST_BIT (si->visited, w))\n+      if (!bitmap_bit_p (si->visited, w))\n \tcondense_visit (graph, si, w);\n       {\n \tunsigned int t = si->node_mapping[w];\n@@ -2067,8 +2067,8 @@ condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \t  unsigned int w = VEC_pop (unsigned, si->scc_stack);\n \t  si->node_mapping[w] = n;\n \n-\t  if (!TEST_BIT (graph->direct_nodes, w))\n-\t    RESET_BIT (graph->direct_nodes, n);\n+\t  if (!bitmap_bit_p (graph->direct_nodes, w))\n+\t    bitmap_clear_bit (graph->direct_nodes, n);\n \n \t  /* Unify our nodes.  */\n \t  if (graph->preds[w])\n@@ -2092,7 +2092,7 @@ condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \t\t\t       graph->points_to[w]);\n \t    }\n \t}\n-      SET_BIT (si->deleted, n);\n+      bitmap_set_bit (si->deleted, n);\n     }\n   else\n     VEC_safe_push (unsigned, heap, si->scc_stack, n);\n@@ -2105,7 +2105,7 @@ label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n-  SET_BIT (si->visited, n);\n+  bitmap_set_bit (si->visited, n);\n \n   if (!graph->points_to[n])\n     graph->points_to[n] = BITMAP_ALLOC (&predbitmap_obstack);\n@@ -2114,7 +2114,7 @@ label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n   EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[n], 0, i, bi)\n     {\n       unsigned int w = si->node_mapping[i];\n-      if (!TEST_BIT (si->visited, w))\n+      if (!bitmap_bit_p (si->visited, w))\n \tlabel_visit (graph, si, w);\n \n       /* Skip unused edges  */\n@@ -2125,7 +2125,7 @@ label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \tbitmap_ior_into(graph->points_to[n], graph->points_to[w]);\n     }\n   /* Indirect nodes get fresh variables.  */\n-  if (!TEST_BIT (graph->direct_nodes, n))\n+  if (!bitmap_bit_p (graph->direct_nodes, n))\n     bitmap_set_bit (graph->points_to[n], FIRST_REF_NODE + n);\n \n   if (!bitmap_empty_p (graph->points_to[n]))\n@@ -2163,13 +2163,13 @@ perform_var_substitution (constraint_graph_t graph)\n   /* Condense the nodes, which means to find SCC's, count incoming\n      predecessors, and unite nodes in SCC's.  */\n   for (i = 0; i < FIRST_REF_NODE; i++)\n-    if (!TEST_BIT (si->visited, si->node_mapping[i]))\n+    if (!bitmap_bit_p (si->visited, si->node_mapping[i]))\n       condense_visit (graph, si, si->node_mapping[i]);\n \n   bitmap_clear (si->visited);\n   /* Actually the label the nodes for pointer equivalences  */\n   for (i = 0; i < FIRST_REF_NODE; i++)\n-    if (!TEST_BIT (si->visited, si->node_mapping[i]))\n+    if (!bitmap_bit_p (si->visited, si->node_mapping[i]))\n       label_visit (graph, si, si->node_mapping[i]);\n \n   /* Calculate location equivalence labels.  */\n@@ -2218,7 +2218,7 @@ perform_var_substitution (constraint_graph_t graph)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     for (i = 0; i < FIRST_REF_NODE; i++)\n       {\n-\tbool direct_node = TEST_BIT (graph->direct_nodes, i);\n+\tbool direct_node = bitmap_bit_p (graph->direct_nodes, i);\n \tfprintf (dump_file,\n \t\t \"Equivalence classes for %s node id %d:%s are pointer: %d\"\n \t\t \", location:%d\\n\","}, {"sha": "87818026cb6473998e0cdf3a067833df128a732c", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -91,9 +91,9 @@ reachable_at_most_once (basic_block va_arg_bb, basic_block va_start_bb)\n \n       gcc_assert (src != ENTRY_BLOCK_PTR);\n \n-      if (! TEST_BIT (visited, src->index))\n+      if (! bitmap_bit_p (visited, src->index))\n \t{\n-\t  SET_BIT (visited, src->index);\n+\t  bitmap_set_bit (visited, src->index);\n \t  FOR_EACH_EDGE (e, ei, src->preds)\n \t    VEC_safe_push (edge, heap, stack, e);\n \t}"}, {"sha": "7dd5e93ba1553802af79f420797b529aec9dcc4b", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -1293,18 +1293,18 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n           for (k = 0; k < group_size; k++)\n             {\n               first_group_load_index = VEC_index (int, load_permutation, k);\n-              if (TEST_BIT (load_index, first_group_load_index))\n+              if (bitmap_bit_p (load_index, first_group_load_index))\n                 {\n                   bad_permutation = true;\n                   break;\n                 }\n \n-              SET_BIT (load_index, first_group_load_index);\n+              bitmap_set_bit (load_index, first_group_load_index);\n             }\n \n           if (!bad_permutation)\n             for (k = 0; k < group_size; k++)\n-              if (!TEST_BIT (load_index, k))\n+              if (!bitmap_bit_p (load_index, k))\n                 {\n                   bad_permutation = true;\n                   break;\n@@ -1423,17 +1423,17 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n          prev = next;\n        }\n \n-      if (TEST_BIT (load_index, prev))\n+      if (bitmap_bit_p (load_index, prev))\n         {\n           supported = false;\n           break;\n         }\n \n-      SET_BIT (load_index, prev);\n+      bitmap_set_bit (load_index, prev);\n     }\n  \n   for (j = 0; j < group_size; j++)\n-    if (!TEST_BIT (load_index, j))\n+    if (!bitmap_bit_p (load_index, j))\n       return false;\n \n   sbitmap_free (load_index);"}, {"sha": "213c15851a4a710725778ad5fac431de975206d5", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -86,7 +86,7 @@ static bool\n live_on_edge (edge e, tree name)\n {\n   return (live[e->dest->index]\n-\t  && TEST_BIT (live[e->dest->index], SSA_NAME_VERSION (name)));\n+\t  && bitmap_bit_p (live[e->dest->index], SSA_NAME_VERSION (name)));\n }\n \n /* Local functions.  */\n@@ -5556,7 +5556,7 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n \n \t  /* If op is not live beyond this stmt, do not bother to insert\n \t     asserts for it.  */\n-\t  if (!TEST_BIT (live, SSA_NAME_VERSION (op)))\n+\t  if (!bitmap_bit_p (live, SSA_NAME_VERSION (op)))\n \t    continue;\n \n \t  /* If OP is used in such a way that we can infer a value\n@@ -5604,9 +5604,9 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n \n       /* Update live.  */\n       FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n-\tSET_BIT (live, SSA_NAME_VERSION (op));\n+\tbitmap_set_bit (live, SSA_NAME_VERSION (op));\n       FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_DEF)\n-\tRESET_BIT (live, SSA_NAME_VERSION (op));\n+\tbitmap_clear_bit (live, SSA_NAME_VERSION (op));\n     }\n \n   /* Traverse all PHI nodes in BB, updating live.  */\n@@ -5624,10 +5624,10 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n \t{\n \t  tree arg = USE_FROM_PTR (arg_p);\n \t  if (TREE_CODE (arg) == SSA_NAME)\n-\t    SET_BIT (live, SSA_NAME_VERSION (arg));\n+\t    bitmap_set_bit (live, SSA_NAME_VERSION (arg));\n \t}\n \n-      RESET_BIT (live, SSA_NAME_VERSION (res));\n+      bitmap_clear_bit (live, SSA_NAME_VERSION (res));\n     }\n \n   return need_assert;"}, {"sha": "e0daa830cf3a43ba98455debbcacde041f49118a", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c028c07b1998cc80f67e053c8131cf8b387af7/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=d7c028c07b1998cc80f67e053c8131cf8b387af7", "patch": "@@ -6768,15 +6768,15 @@ vt_find_locations (void)\n       while (!fibheap_empty (worklist))\n \t{\n \t  bb = (basic_block) fibheap_extract_min (worklist);\n-\t  RESET_BIT (in_worklist, bb->index);\n-\t  gcc_assert (!TEST_BIT (visited, bb->index));\n-\t  if (!TEST_BIT (visited, bb->index))\n+\t  bitmap_clear_bit (in_worklist, bb->index);\n+\t  gcc_assert (!bitmap_bit_p (visited, bb->index));\n+\t  if (!bitmap_bit_p (visited, bb->index))\n \t    {\n \t      bool changed;\n \t      edge_iterator ei;\n \t      int oldinsz, oldoutsz;\n \n-\t      SET_BIT (visited, bb->index);\n+\t      bitmap_set_bit (visited, bb->index);\n \n \t      if (VTI (bb)->in.vars)\n \t\t{\n@@ -6869,21 +6869,21 @@ vt_find_locations (void)\n \t\t      if (e->dest == EXIT_BLOCK_PTR)\n \t\t\tcontinue;\n \n-\t\t      if (TEST_BIT (visited, e->dest->index))\n+\t\t      if (bitmap_bit_p (visited, e->dest->index))\n \t\t\t{\n-\t\t\t  if (!TEST_BIT (in_pending, e->dest->index))\n+\t\t\t  if (!bitmap_bit_p (in_pending, e->dest->index))\n \t\t\t    {\n \t\t\t      /* Send E->DEST to next round.  */\n-\t\t\t      SET_BIT (in_pending, e->dest->index);\n+\t\t\t      bitmap_set_bit (in_pending, e->dest->index);\n \t\t\t      fibheap_insert (pending,\n \t\t\t\t\t      bb_order[e->dest->index],\n \t\t\t\t\t      e->dest);\n \t\t\t    }\n \t\t\t}\n-\t\t      else if (!TEST_BIT (in_worklist, e->dest->index))\n+\t\t      else if (!bitmap_bit_p (in_worklist, e->dest->index))\n \t\t\t{\n \t\t\t  /* Add E->DEST to current round.  */\n-\t\t\t  SET_BIT (in_worklist, e->dest->index);\n+\t\t\t  bitmap_set_bit (in_worklist, e->dest->index);\n \t\t\t  fibheap_insert (worklist, bb_order[e->dest->index],\n \t\t\t\t\t  e->dest);\n \t\t\t}"}]}