{"sha": "8653a1eda8c17ed13c49bdcadec52705e93a9432", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY1M2ExZWRhOGMxN2VkMTNjNDliZGNhZGVjNTI3MDVlOTNhOTQzMg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-11-24T14:14:11Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-11-24T14:14:11Z"}, "message": "genattrtab.c (simplify_cond): Update indices correctly.\n\n\t* genattrtab.c (simplify_cond): Update indices correctly.\n\t(attr_alt_subset_p, attr_alt_subset_of_compl_p, attr_alt_intersection,\n\tattr_alt_union, attr_alt_complement, attr_alt_bit_p, mk_attr_alt): New.\n\t(check_attr_test, encode_units_mask, compute_alternative_mask,\n\tmake_alternative_compare, simplify_and_tree,\n\tattr_rtx_cost, simplify_test_exp, gen_attr,\n\twrite_test_expr, walk_attr_value): Handle EQ_ATTR_ALT.\n\t* rtl.def (EQ_ATTR_ALT): New.\n\nFrom-SVN: r73873", "tree": {"sha": "60133921b6a62ce60c67348ea462f7f7f9c1c9dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60133921b6a62ce60c67348ea462f7f7f9c1c9dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8653a1eda8c17ed13c49bdcadec52705e93a9432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8653a1eda8c17ed13c49bdcadec52705e93a9432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8653a1eda8c17ed13c49bdcadec52705e93a9432", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8653a1eda8c17ed13c49bdcadec52705e93a9432/comments", "author": null, "committer": null, "parents": [{"sha": "0ba646fe67702e7e2c4e34ae57d2c135c66be2bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ba646fe67702e7e2c4e34ae57d2c135c66be2bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ba646fe67702e7e2c4e34ae57d2c135c66be2bd"}], "stats": {"total": 365, "additions": 327, "deletions": 38}, "files": [{"sha": "cc4f19c71cc4626a408baefc87860528cdc001ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8653a1eda8c17ed13c49bdcadec52705e93a9432/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8653a1eda8c17ed13c49bdcadec52705e93a9432/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8653a1eda8c17ed13c49bdcadec52705e93a9432", "patch": "@@ -1,3 +1,14 @@\n+2003-11-24  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* genattrtab.c (simplify_cond): Update indices correctly.\n+\t(attr_alt_subset_p, attr_alt_subset_of_compl_p, attr_alt_intersection,\n+\tattr_alt_union, attr_alt_complement, attr_alt_bit_p, mk_attr_alt): New.\n+\t(check_attr_test, encode_units_mask, compute_alternative_mask,\n+\tmake_alternative_compare, simplify_and_tree,\n+\tattr_rtx_cost, simplify_test_exp, gen_attr,\n+\twrite_test_expr, walk_attr_value): Handle EQ_ATTR_ALT.\n+\t* rtl.def (EQ_ATTR_ALT): New.\n+\n 2003-11-23  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* genattrtab.c (strcmp_check, DEF_ATTR_STRING): New macros."}, {"sha": "ccf82c68a2a1212a2bd9e947e116f26728478cdf", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 312, "deletions": 38, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8653a1eda8c17ed13c49bdcadec52705e93a9432/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8653a1eda8c17ed13c49bdcadec52705e93a9432/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=8653a1eda8c17ed13c49bdcadec52705e93a9432", "patch": "@@ -100,7 +100,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define ATTR_PERMANENT_P(RTX) (RTX_FLAG((RTX), integrated))\n #define ATTR_EQ_ATTR_P(RTX) (RTX_FLAG((RTX), volatil))\n \n-#if 1\n+#if 0\n #define strcmp_check(S1, S2) ((S1) == (S2)\t\t\\\n \t\t\t      ? 0\t\t\t\\\n \t\t\t      : (strcmp ((S1), (S2))\t\\\n@@ -474,6 +474,13 @@ static const char *attr_numeral\t(int);\n static int attr_equal_p\t\t(rtx, rtx);\n static rtx attr_copy_rtx\t(rtx);\n static int attr_rtx_cost\t(rtx);\n+static bool attr_alt_subset_p (rtx, rtx);\n+static bool attr_alt_subset_of_compl_p (rtx, rtx);\n+static rtx attr_alt_intersection (rtx, rtx);\n+static rtx attr_alt_union (rtx, rtx);\n+static rtx attr_alt_complement (rtx);\n+static bool attr_alt_bit_p (rtx, int);\n+static rtx mk_attr_alt (int);\n \n #define oballoc(size) obstack_alloc (hash_obstack, size)\n \n@@ -933,12 +940,7 @@ check_attr_test (rtx exp, int is_const, int lineno)\n \t  if (attr == NULL)\n \t    {\n \t      if (! strcmp (XSTR (exp, 0), \"alternative\"))\n-\t\t{\n-\t\t  XSTR (exp, 0) = alternative_name;\n-\t\t  /* This can't be simplified any further.  */\n-\t\t  ATTR_IND_SIMPLIFIED_P (exp) = 1;\n-\t\t  return exp;\n-\t\t}\n+\t\treturn mk_attr_alt (1 << atoi (XSTR (exp, 1)));\n \t      else\n \t\tfatal (\"unknown attribute `%s' in EQ_ATTR\", XSTR (exp, 0));\n \t    }\n@@ -978,16 +980,29 @@ check_attr_test (rtx exp, int is_const, int lineno)\n \t}\n       else\n \t{\n-\t  /* Make an IOR tree of the possible values.  */\n-\t  orexp = false_rtx;\n-\t  name_ptr = XSTR (exp, 1);\n-\t  while ((p = next_comma_elt (&name_ptr)) != NULL)\n+\t  if (! strcmp (XSTR (exp, 0), \"alternative\"))\n \t    {\n-\t      newexp = attr_eq (XSTR (exp, 0), p);\n-\t      orexp = insert_right_side (IOR, orexp, newexp, -2, -2);\n+\t      int set = 0;\n+\n+\t      name_ptr = XSTR (exp, 1);\n+\t      while ((p = next_comma_elt (&name_ptr)) != NULL)\n+\t\tset |= 1 << atoi (p);\n+\n+\t      return mk_attr_alt (set);\n \t    }\n+\t  else\n+\t    {\n+\t      /* Make an IOR tree of the possible values.  */\n+\t      orexp = false_rtx;\n+\t      name_ptr = XSTR (exp, 1);\n+\t      while ((p = next_comma_elt (&name_ptr)) != NULL)\n+\t\t{\n+\t\t  newexp = attr_eq (XSTR (exp, 0), p);\n+\t\t  orexp = insert_right_side (IOR, orexp, newexp, -2, -2);\n+\t\t}\n \n-\t  return check_attr_test (orexp, is_const, lineno);\n+\t      return check_attr_test (orexp, is_const, lineno);\n+\t    }\n \t}\n       break;\n \n@@ -2212,6 +2227,7 @@ encode_units_mask (rtx x)\n     case PC:\n     case CC0:\n     case EQ_ATTR:\n+    case EQ_ATTR_ALT:\n       return x;\n \n     default:\n@@ -2525,6 +2541,7 @@ simplify_cond (rtx exp, int insn_code, int insn_index)\n \t  /* If test is false, discard it and its value.  */\n \t  for (j = i; j < len - 2; j++)\n \t    tests[j] = tests[j + 2];\n+\t  i -= 2;\n \t  len -= 2;\n \t}\n \n@@ -2541,6 +2558,7 @@ simplify_cond (rtx exp, int insn_code, int insn_index)\n \t  for (j = i; j < len - 2; j++)\n \t    tests[j] = tests[j + 2];\n \t  len -= 2;\n+\t  i -= 2;\n \t}\n \n       else\n@@ -2711,6 +2729,16 @@ compute_alternative_mask (rtx exp, enum rtx_code code)\n \t   && XSTR (exp, 0) == alternative_name)\n     string = XSTR (exp, 1);\n \n+  else if (GET_CODE (exp) == EQ_ATTR_ALT)\n+    {\n+      if (code == AND && XINT (exp, 1))\n+\treturn XINT (exp, 0);\n+\n+      if (code == IOR && !XINT (exp, 1))\n+\treturn XINT (exp, 0);\n+\n+      return 0;\n+    }\n   else\n     return 0;\n \n@@ -2725,17 +2753,7 @@ compute_alternative_mask (rtx exp, enum rtx_code code)\n static rtx\n make_alternative_compare (int mask)\n {\n-  rtx newexp;\n-  int i;\n-\n-  /* Find the bit.  */\n-  for (i = 0; (mask & (1 << i)) == 0; i++)\n-    ;\n-\n-  newexp = attr_rtx (EQ_ATTR, alternative_name, attr_numeral (i));\n-  ATTR_IND_SIMPLIFIED_P (newexp) = 1;\n-\n-  return newexp;\n+  return mk_attr_alt (mask);\n }\n \n /* If we are processing an (eq_attr \"attr\" \"value\") test, we find the value\n@@ -2882,7 +2900,7 @@ simplify_and_tree (rtx exp, rtx *pterm, int insn_code, int insn_index)\n       right = simplify_and_tree (XEXP (exp, 1), pterm, insn_code, insn_index);\n       if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n \t{\n-\t  newexp = attr_rtx (GET_CODE (exp), left, right);\n+\t  newexp = attr_rtx (AND, left, right);\n \n \t  exp = simplify_test_exp_in_temp (newexp, insn_code, insn_index);\n \t}\n@@ -2905,7 +2923,7 @@ simplify_and_tree (rtx exp, rtx *pterm, int insn_code, int insn_index)\n \n       if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n \t{\n-\t  newexp = attr_rtx (GET_CODE (exp), left, right);\n+\t  newexp = attr_rtx (IOR, left, right);\n \n \t  exp = simplify_test_exp_in_temp (newexp, insn_code, insn_index);\n \t}\n@@ -2923,6 +2941,20 @@ simplify_and_tree (rtx exp, rtx *pterm, int insn_code, int insn_index)\n   else if (GET_CODE (*pterm) == NOT && exp == XEXP (*pterm, 0))\n     return false_rtx;\n \n+  else if (GET_CODE (exp) == EQ_ATTR_ALT && GET_CODE (*pterm) == EQ_ATTR_ALT)\n+    {\n+      if (attr_alt_subset_p (*pterm, exp))\n+\treturn true_rtx;\n+\n+      if (attr_alt_subset_of_compl_p (*pterm, exp))\n+\treturn false_rtx;\n+\n+      if (attr_alt_subset_p (exp, *pterm))\n+\t*pterm = true_rtx;\n+\t\n+      return exp;\n+    }\n+\n   else if (GET_CODE (exp) == EQ_ATTR && GET_CODE (*pterm) == EQ_ATTR)\n     {\n       if (XSTR (exp, 0) != XSTR (*pterm, 0))\n@@ -3067,6 +3099,9 @@ attr_rtx_cost (rtx x)\n       else\n \treturn 0;\n \n+    case EQ_ATTR_ALT:\n+      return 0;\n+\n     case EQ_ATTR:\n       /* Alternatives don't result into function call.  */\n       if (!strcmp_check (XSTR (x, 0), alternative_name))\n@@ -3117,6 +3152,146 @@ simplify_test_exp_in_temp (rtx exp, int insn_code, int insn_index)\n   return attr_copy_rtx (x);\n }\n \n+/* Returns true if S1 is a subset of S2.  */\n+\n+static bool\n+attr_alt_subset_p (rtx s1, rtx s2)\n+{\n+  switch ((XINT (s1, 1) << 1) | XINT (s2, 1))\n+    {\n+    case (0 << 1) | 0:\n+      return !(XINT (s1, 0) &~ XINT (s2, 0));\n+\n+    case (0 << 1) | 1:\n+      return !(XINT (s1, 0) & XINT (s2, 0));\n+\n+    case (1 << 1) | 0:\n+      return false;\n+\n+    case (1 << 1) | 1:\n+      return !(XINT (s2, 0) &~ XINT (s1, 0));\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Returns true if S1 is a subset of complement of S2.  */\n+\n+static bool attr_alt_subset_of_compl_p (rtx s1, rtx s2)\n+{\n+  switch ((XINT (s1, 1) << 1) | XINT (s2, 1))\n+    {\n+    case (0 << 1) | 0:\n+      return !(XINT (s1, 0) & XINT (s2, 0));\n+\n+    case (0 << 1) | 1:\n+      return !(XINT (s1, 0) & ~XINT (s2, 0));\n+\n+    case (1 << 1) | 0:\n+      return !(XINT (s2, 0) &~ XINT (s1, 0));\n+\n+    case (1 << 1) | 1:\n+      return false;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Return EQ_ATTR_ALT expression representing intersection of S1 and S2.  */\n+\n+static rtx\n+attr_alt_intersection (rtx s1, rtx s2)\n+{\n+  rtx result = rtx_alloc (EQ_ATTR_ALT);\n+\n+  switch ((XINT (s1, 1) << 1) | XINT (s2, 1))\n+    {\n+    case (0 << 1) | 0:\n+      XINT (result, 0) = XINT (s1, 0) & XINT (s2, 0);\n+      break;\n+    case (0 << 1) | 1:\n+      XINT (result, 0) = XINT (s1, 0) & ~XINT (s2, 0);\n+      break;\n+    case (1 << 1) | 0:\n+      XINT (result, 0) = XINT (s2, 0) & ~XINT (s1, 0);\n+      break;\n+    case (1 << 1) | 1:\n+      XINT (result, 0) = XINT (s1, 0) | XINT (s2, 0);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  XINT (result, 1) = XINT (s1, 1) & XINT (s2, 1);\n+\n+  return result;\n+}\n+\n+/* Return EQ_ATTR_ALT expression representing union of S1 and S2.  */\n+\n+static rtx\n+attr_alt_union (rtx s1, rtx s2)\n+{\n+  rtx result = rtx_alloc (EQ_ATTR_ALT);\n+\n+  switch ((XINT (s1, 1) << 1) | XINT (s2, 1))\n+    {\n+    case (0 << 1) | 0:\n+      XINT (result, 0) = XINT (s1, 0) | XINT (s2, 0);\n+      break;\n+    case (0 << 1) | 1:\n+      XINT (result, 0) = XINT (s2, 0) & ~XINT (s1, 0);\n+      break;\n+    case (1 << 1) | 0:\n+      XINT (result, 0) = XINT (s1, 0) & ~XINT (s2, 0);\n+      break;\n+    case (1 << 1) | 1:\n+      XINT (result, 0) = XINT (s1, 0) & XINT (s2, 0);\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  XINT (result, 1) = XINT (s1, 1) | XINT (s2, 1);\n+  return result;\n+}\n+\n+/* Return EQ_ATTR_ALT expression representing complement of S.  */\n+\n+static rtx\n+attr_alt_complement (rtx s)\n+{\n+  rtx result = rtx_alloc (EQ_ATTR_ALT);\n+\n+  XINT (result, 0) = XINT (s, 0);\n+  XINT (result, 1) = 1 - XINT (s, 1);\n+\n+  return result;\n+}\n+\n+/* Tests whether a bit B belongs to the set represented by S.  */\n+\n+static bool\n+attr_alt_bit_p (rtx s, int b)\n+{\n+  return XINT (s, 1) ^ ((XINT (s, 0) >> b) & 1);\n+}\n+\n+/* Return EQ_ATTR_ALT expression representing set containing elements set\n+   in E.  */\n+\n+static rtx\n+mk_attr_alt (int e)\n+{\n+  rtx result = rtx_alloc (EQ_ATTR_ALT);\n+\n+  XINT (result, 0) = e;\n+  XINT (result, 1) = 0;\n+\n+  return result;\n+}\n+\n /* Given an expression, see if it can be simplified for a particular insn\n    code based on the values of other attributes being tested.  This can\n    eliminate nested get_attr_... calls.\n@@ -3135,6 +3310,7 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n   struct insn_ent *ie;\n   int i;\n   rtx newexp = exp;\n+  bool left_alt, right_alt;\n \n   /* Don't re-simplify something we already simplified.  */\n   if (ATTR_IND_SIMPLIFIED_P (exp) || ATTR_CURR_SIMPLIFIED_P (exp))\n@@ -3152,6 +3328,13 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n       if (left == false_rtx)\n \treturn false_rtx;\n \n+      if (GET_CODE (left) == EQ_ATTR_ALT\n+\t  && GET_CODE (right) == EQ_ATTR_ALT)\n+\t{\n+\t  exp = attr_alt_intersection (left, right);\n+\t  return simplify_test_exp (exp, insn_code, insn_index);\n+\t}\n+\n       /* If either side is an IOR and we have (eq_attr \"alternative\" ..\")\n \t present on both sides, apply the distributive law since this will\n \t yield simplifications.  */\n@@ -3191,15 +3374,25 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n       /* See if all or all but one of the insn's alternatives are specified\n \t in this tree.  Optimize if so.  */\n \n-      else if (insn_code >= 0\n-\t       && (GET_CODE (left) == AND\n-\t\t   || (GET_CODE (left) == NOT\n-\t\t       && GET_CODE (XEXP (left, 0)) == EQ_ATTR\n-\t\t       && XSTR (XEXP (left, 0), 0) == alternative_name)\n-\t\t   || GET_CODE (right) == AND\n-\t\t   || (GET_CODE (right) == NOT\n-\t\t       && GET_CODE (XEXP (right, 0)) == EQ_ATTR\n-\t\t       && XSTR (XEXP (right, 0), 0) == alternative_name)))\n+      if (GET_CODE (left) == NOT)\n+\tleft_alt = (GET_CODE (XEXP (left, 0)) == EQ_ATTR\n+\t\t    && XSTR (XEXP (left, 0), 0) == alternative_name);\n+      else\n+\tleft_alt = (GET_CODE (left) == EQ_ATTR_ALT\n+\t\t    && XINT (left, 1));\n+\n+      if (GET_CODE (right) == NOT)\n+\tright_alt = (GET_CODE (XEXP (right, 0)) == EQ_ATTR\n+\t\t     && XSTR (XEXP (right, 0), 0) == alternative_name);\n+      else\n+\tright_alt = (GET_CODE (right) == EQ_ATTR_ALT\n+\t\t     && XINT (right, 1));\n+\n+      if (insn_code >= 0\n+\t  && (GET_CODE (left) == AND\n+\t      || left_alt\n+\t      || GET_CODE (right) == AND\n+\t      || right_alt))\n \t{\n \t  i = compute_alternative_mask (exp, AND);\n \t  if (i & ~insn_alternatives[insn_code])\n@@ -3241,6 +3434,13 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n       if (right == true_rtx)\n \treturn true_rtx;\n \n+      if (GET_CODE (left) == EQ_ATTR_ALT\n+\t  && GET_CODE (right) == EQ_ATTR_ALT)\n+\t{\n+\t  exp = attr_alt_union (left, right);\n+\t  return simplify_test_exp (exp, insn_code, insn_index);\n+\t}\n+\n       right = simplify_or_tree (right, &left, insn_code, insn_index);\n       if (left == XEXP (exp, 0) && right == XEXP (exp, 1))\n \tleft = simplify_or_tree (left, &right, insn_code, insn_index);\n@@ -3279,9 +3479,13 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n \n       else if (insn_code >= 0\n \t       && (GET_CODE (left) == IOR\n+\t\t   || (GET_CODE (left) == EQ_ATTR_ALT\n+\t\t       && !XINT (left, 1))\n \t\t   || (GET_CODE (left) == EQ_ATTR\n \t\t       && XSTR (left, 0) == alternative_name)\n \t\t   || GET_CODE (right) == IOR\n+\t\t   || (GET_CODE (right) == EQ_ATTR_ALT\n+\t\t       && !XINT (right, 1))\n \t\t   || (GET_CODE (right) == EQ_ATTR\n \t\t       && XSTR (right, 0) == alternative_name)))\n \t{\n@@ -3331,11 +3535,17 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n \n       if (left == false_rtx)\n \treturn true_rtx;\n-      else if (left == true_rtx)\n+      if (left == true_rtx)\n \treturn false_rtx;\n \n+      if (GET_CODE (left) == EQ_ATTR_ALT)\n+\t{\n+\t  exp = attr_alt_complement (left);\n+\t  return simplify_test_exp (exp, insn_code, insn_index);\n+\t}\n+\n       /* Try to apply De`Morgan's laws.  */\n-      else if (GET_CODE (left) == IOR)\n+      if (GET_CODE (left) == IOR)\n \t{\n \t  newexp = attr_rtx (AND,\n \t\t\t     attr_rtx (NOT, XEXP (left, 0)),\n@@ -3357,11 +3567,25 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n \t}\n       break;\n \n+    case EQ_ATTR_ALT:\n+      if (current_alternative_string)\n+\treturn attr_alt_bit_p (exp, atoi (current_alternative_string)) ? true_rtx : false_rtx;\n+\n+      if (!XINT (exp, 0))\n+\treturn XINT (exp, 1) ? true_rtx : false_rtx;\n+      break;\n+\n     case EQ_ATTR:\n       if (current_alternative_string && XSTR (exp, 0) == alternative_name)\n \treturn (XSTR (exp, 1) == current_alternative_string\n \t\t? true_rtx : false_rtx);\n \n+      if (XSTR (exp, 0) == alternative_name)\n+\t{\n+\t  newexp = mk_attr_alt (1 << atoi (XSTR (exp, 1)));\n+\t  break;\n+\t}\n+\n       /* Look at the value for this insn code in the specified attribute.\n \t We normally can replace this comparison with the condition that\n \t would give this insn the values being tested for.  */\n@@ -4466,6 +4690,52 @@ write_test_expr (rtx exp, int flags)\n       write_test_expr (XEXP (exp, 0), flags);\n       break;\n \n+    case EQ_ATTR_ALT:\n+\t{\n+\t  int set = XINT (exp, 0), bit = 0;\n+\n+\t  if (flags & 1)\n+\t    fatal (\"EQ_ATTR_ALT not valid inside comparison\");\n+\n+\t  if (!set)\n+\t    fatal (\"Empty EQ_ATTR_ALT should be optimized out\");\n+\n+\t  if (!(set & (set - 1)))\n+\t    {\n+\t      if (!(set & 0xffff))\n+\t\t{\n+\t\t  bit += 16;\n+\t\t  set >>= 16;\n+\t\t}\n+\t      if (!(set & 0xff))\n+\t\t{\n+\t\t  bit += 8;\n+\t\t  set >>= 8;\n+\t\t}\n+\t      if (!(set & 0xf))\n+\t\t{\n+\t\t  bit += 4;\n+\t\t  set >>= 4;\n+\t\t}\n+\t      if (!(set & 0x3))\n+\t\t{\n+\t\t  bit += 2;\n+\t\t  set >>= 2;\n+\t\t}\n+\t      if (!(set & 1))\n+\t\tbit++;\n+\n+\t      printf (\"which_alternative %s= %d\",\n+\t\t      XINT (exp, 1) ? \"!\" : \"=\", bit);\n+\t    }\n+\t  else\n+\t    {\n+\t      printf (\"%s((1 << which_alternative) & 0x%x)\",\n+\t\t      XINT (exp, 1) ? \"!\" : \"\", set);\n+\t    }\n+\t}\n+      break;\n+\n     /* Comparison test of an attribute with a value.  Most of these will\n        have been removed by optimization.   Handle \"alternative\"\n        specially and give error if EQ_ATTR present inside a comparison.  */\n@@ -4686,6 +4956,10 @@ walk_attr_value (rtx exp)\n       must_extract = 1;\n       return;\n \n+    case EQ_ATTR_ALT:\n+      must_extract = must_constrain = 1;\n+      break;\n+\n     case EQ_ATTR:\n       if (XSTR (exp, 0) == alternative_name)\n \tmust_extract = must_constrain = 1;"}, {"sha": "60c3f6bebd0210478c010d8b7f2d31d9f8009aec", "filename": "gcc/rtl.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8653a1eda8c17ed13c49bdcadec52705e93a9432/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8653a1eda8c17ed13c49bdcadec52705e93a9432/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=8653a1eda8c17ed13c49bdcadec52705e93a9432", "patch": "@@ -582,6 +582,10 @@ DEF_RTL_EXPR(SET_ATTR_ALTERNATIVE, \"set_attr_alternative\", \"sE\", 'x')\n    attribute name and the second is the comparison value.  */\n DEF_RTL_EXPR(EQ_ATTR, \"eq_attr\", \"ss\", 'x')\n \n+/* A special case of the above representing a set of alternatives.  The first\n+   operand is bitmap of the set, the second one is the default value.  */\n+DEF_RTL_EXPR(EQ_ATTR_ALT, \"eq_attr_alt\", \"ii\", 'x')\n+\n /* A conditional expression which is true if the specified flag is\n    true for the insn being scheduled in reorg.\n "}]}