{"sha": "b0ccd3922f5ee31b682e7844d97e5180c33fa8ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBjY2QzOTIyZjVlZTMxYjY4MmU3ODQ0ZDk3ZTUxODBjMzNmYThlYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-01-05T02:37:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-01-15T01:28:37Z"}, "message": "compiler: add support for reading embedcfg files\n\nThis is the code that parses an embedcfg file, which is a JSON file\ncreated by the go command when it sees go:embed directives.  This code\nis not yet called, and does not yet do anything.  It's being sent as a\nseparate CL to isolate just the JSON parsing code.\n\n\t* Make-lang.in (GO_OBJS): Add go/embed.o.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/281532", "tree": {"sha": "20188b00a9f985a0e9adf08ff8704e68ae84d2ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20188b00a9f985a0e9adf08ff8704e68ae84d2ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fff80fd79c36a1a940b331d20905061d61ee5e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fff80fd79c36a1a940b331d20905061d61ee5e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fff80fd79c36a1a940b331d20905061d61ee5e6"}], "stats": {"total": 635, "additions": 634, "deletions": 1}, "files": [{"sha": "4bdc8f6ea5ac944134f8f29bfe5bd57eea7dfa0d", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=b0ccd3922f5ee31b682e7844d97e5180c33fa8ea", "patch": "@@ -51,6 +51,7 @@ go-warn = $(STRICT_WARN)\n \n GO_OBJS = \\\n \tgo/ast-dump.o \\\n+\tgo/embed.o \\\n \tgo/escape.o \\\n \tgo/export.o \\\n \tgo/expressions.o \\"}, {"sha": "82f43f5f21fb442f2911a333be7ba4246edf2b5a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=b0ccd3922f5ee31b682e7844d97e5180c33fa8ea", "patch": "@@ -1,4 +1,4 @@\n-fd5396b1af389a55d1e3612702cfdad6755084e9\n+22ce16e28220d446c4557f47129024e3561f3d77\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "19c6930d0c3e5d9e35a939fbd2bb6ca109c2a095", "filename": "gcc/go/gofrontend/embed.cc", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea/gcc%2Fgo%2Fgofrontend%2Fembed.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea/gcc%2Fgo%2Fgofrontend%2Fembed.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fembed.cc?ref=b0ccd3922f5ee31b682e7844d97e5180c33fa8ea", "patch": "@@ -0,0 +1,628 @@\n+// embed.cc -- Go frontend go:embed handling.\n+\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"operator.h\"\n+#include \"go-diagnostics.h\"\n+#include \"lex.h\"\n+#include \"gogo.h\"\n+\n+#ifndef O_BINARY\n+#define O_BINARY 0\n+#endif\n+\n+// Read a file into *DATA.  Returns false on error.\n+\n+static bool\n+read_file(const char* filename, Location loc, std::string* data)\n+{\n+  int fd = open(filename, O_RDONLY | O_BINARY);\n+  if (fd < 0)\n+    {\n+      go_error_at(loc, \"%s: %m\", filename);\n+      return false;\n+    }\n+\n+  struct stat st;\n+  if (fstat(fd, &st) < 0)\n+    {\n+      go_error_at(loc, \"%s: %m\", filename);\n+      return false;\n+    }\n+  off_t want = st.st_size;\n+\n+  // Most files read here are going to be incorporated into the object file\n+  // and then the executable.  Set a limit on the size we will accept.\n+  if (want > 2000000000)\n+    {\n+      go_error_at(loc, \"%s: file too large\", filename);\n+      return false;\n+    }\n+\n+  data->resize(want);\n+  off_t got = 0;\n+  while (want > 0)\n+    {\n+      // C++11 requires that std::string use contiguous bytes, so this\n+      // is safe.\n+      ssize_t n = read(fd, &(*data)[got], want);\n+      if (n < 0)\n+\t{\n+\t  close(fd);\n+\t  go_error_at(loc, \"%s: %m\", filename);\n+\t  return false;\n+\t}\n+      if (n == 0)\n+\t{\n+\t  data->resize(got);\n+\t  break;\n+\t}\n+      got += n;\n+      want -= n;\n+    }\n+\n+  close(fd);\n+  return true;\n+}\n+\n+// A JSON value as read from an embedcfg file.  For our purposes a\n+// JSON value is a string, or a list of strings, or a mapping from\n+// strings to values.  We don't expect any numbers.  We also don't\n+// expect an array of anything other than strings; that is, we don't\n+// accept an array of general JSON values.\n+\n+class Json_value\n+{\n+ public:\n+  // The types of values.\n+  enum Json_value_classification\n+    {\n+      JSON_VALUE_UNKNOWN,\n+      JSON_VALUE_STRING,\n+      JSON_VALUE_ARRAY,\n+      JSON_VALUE_MAP\n+    };\n+\n+  Json_value()\n+    : classification_(JSON_VALUE_UNKNOWN), string_(), array_(), map_()\n+  { }\n+\n+  ~Json_value();\n+\n+  Json_value_classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Set to a string value.\n+  void\n+  set_string(const std::string& str)\n+  {\n+    go_assert(this->classification_ == JSON_VALUE_UNKNOWN);\n+    this->classification_ = JSON_VALUE_STRING;\n+    this->string_ = str;\n+  }\n+\n+  // Start an array value.\n+  void\n+  start_array()\n+  {\n+    go_assert(this->classification_ == JSON_VALUE_UNKNOWN);\n+    this->classification_ = JSON_VALUE_ARRAY;\n+  }\n+\n+  // Add an array entry.\n+  void\n+  add_array_entry(const std::string& s)\n+  {\n+    go_assert(this->classification_ == JSON_VALUE_ARRAY);\n+    this->array_.push_back(s);\n+  }\n+\n+  // Start a map value.\n+  void\n+  start_map()\n+  {\n+    go_assert(this->classification_ == JSON_VALUE_UNKNOWN);\n+    this->classification_ = JSON_VALUE_MAP;\n+  }\n+\n+  // Add a map entry.\n+  void\n+  add_map_entry(const std::string& key, Json_value* val)\n+  {\n+    go_assert(this->classification_ == JSON_VALUE_MAP);\n+    this->map_[key] = val;\n+  }\n+\n+  // Return the strings from a string value.\n+  const std::string&\n+  to_string() const\n+  {\n+    go_assert(this->classification_ == JSON_VALUE_STRING);\n+    return this->string_;\n+  }\n+\n+  // Fetch a vector of strings, and drop them from the JSON value.\n+  void\n+  get_and_clear_array(std::vector<std::string>* v)\n+  {\n+    go_assert(this->classification_ == JSON_VALUE_ARRAY);\n+    std::swap(*v, this->array_);\n+  }\n+\n+  // Look up a map entry.  Returns NULL if not found.\n+  Json_value*\n+  lookup_map_entry(const std::string& key);\n+\n+  // Iterate over a map.\n+  typedef Unordered_map(std::string, Json_value*)::iterator map_iterator;\n+\n+  map_iterator\n+  map_begin()\n+  {\n+    go_assert(this->classification_ == JSON_VALUE_MAP);\n+    return this->map_.begin();\n+  }\n+\n+  map_iterator\n+  map_end()\n+  { return this->map_.end(); }\n+\n+ private:\n+  // Classification.\n+  Json_value_classification classification_;\n+  // A string, for JSON_VALUE_STRING.\n+  std::string string_;\n+  // Array, for JSON_VALUE_ARRAY.\n+  std::vector<std::string> array_;\n+  // Mapping, for JSON_VALUE_MAP.\n+  Unordered_map(std::string, Json_value*) map_;\n+};\n+\n+// Delete a JSON value.\n+\n+Json_value::~Json_value()\n+{\n+  if (this->classification_ == JSON_VALUE_MAP)\n+    {\n+      for (map_iterator p = this->map_begin();\n+\t   p != this->map_end();\n+\t   ++p)\n+\tdelete p->second;\n+    }\n+}\n+\n+// Look up a map entry in a JSON value.\n+\n+Json_value*\n+Json_value::lookup_map_entry(const std::string& key)\n+{\n+  go_assert(this->classification_ == JSON_VALUE_MAP);\n+  Unordered_map(std::string, Json_value*)::iterator p = this->map_.find(key);\n+  if (p == this->map_.end())\n+    return NULL;\n+  return p->second;\n+}\n+\n+// Manage reading the embedcfg file.\n+\n+class Embedcfg_reader\n+{\n+ public:\n+  Embedcfg_reader(const char* filename)\n+    : filename_(filename), data_(), p_(NULL), pend_(NULL)\n+  {}\n+\n+  // Read the contents of FILENAME.  Return whether it succeeded.\n+  bool\n+  initialize_from_file();\n+\n+  // Read a JSON object.\n+  bool\n+  read_object(Json_value*);\n+\n+  // Report an error if not at EOF.\n+  void\n+  check_eof();\n+\n+  // Report an error for the embedcfg file.\n+  void\n+  error(const char* msg);\n+\n+ private:\n+  bool\n+  read_value(Json_value*);\n+\n+  bool\n+  read_array(Json_value*);\n+\n+  bool\n+  read_string(std::string*);\n+\n+  bool\n+  skip_whitespace(bool eof_ok);\n+\n+  // File name.\n+  const char* filename_;\n+  // File contents.\n+  std::string data_;\n+  // Next character to process.\n+  const char *p_;\n+  // End of data.\n+  const char *pend_;\n+};\n+\n+// Read the embedcfg file.\n+\n+void\n+Gogo::read_embedcfg(const char *filename)\n+{\n+  class Embedcfg_reader r(filename);\n+  if (!r.initialize_from_file())\n+    return;\n+\n+  Json_value val;\n+  if (!r.read_object(&val))\n+    return;\n+\n+  r.check_eof();\n+\n+  if (val.classification() != Json_value::JSON_VALUE_MAP)\n+    {\n+      r.error(\"invalid embedcfg: not a JSON object\");\n+      return;\n+    }\n+\n+  Json_value* patterns = val.lookup_map_entry(\"Patterns\");\n+  if (patterns == NULL)\n+    {\n+      r.error(\"invalid embedcfg: missing Patterns\");\n+      return;\n+    }\n+  if (patterns->classification() != Json_value::JSON_VALUE_MAP)\n+    {\n+      r.error(\"invalid embedcfg: Patterns is not a JSON object\");\n+      return;\n+    }\n+\n+  Json_value* files = val.lookup_map_entry(\"Files\");\n+  if (files == NULL)\n+    {\n+      r.error(\"invalid embedcfg: missing Files\");\n+      return;\n+    }\n+  if (files->classification() != Json_value::JSON_VALUE_MAP)\n+    {\n+      r.error(\"invalid embedcfg: Files is not a JSON object\");\n+      return;\n+    }\n+\n+  // TODO: Actually do something with patterns and files.\n+}\n+\n+// Read the contents of FILENAME into this->data_.  Returns whether it\n+// succeeded.\n+\n+bool\n+Embedcfg_reader::initialize_from_file()\n+{\n+  if (!read_file(this->filename_, Linemap::unknown_location(), &this->data_))\n+    return false;\n+  if (this->data_.empty())\n+    {\n+      this->error(\"empty file\");\n+      return false;\n+    }\n+  this->p_ = this->data_.data();\n+  this->pend_ = this->p_ + this->data_.size();\n+  return true;\n+}\n+\n+// Read a JSON object into VAL.  Return whether it succeeded.\n+\n+bool\n+Embedcfg_reader::read_object(Json_value* val)\n+{\n+  if (!this->skip_whitespace(false))\n+    return false;\n+  if (*this->p_ != '{')\n+    {\n+      this->error(\"expected %<{%>\");\n+      return false;\n+    }\n+  ++this->p_;\n+\n+  val->start_map();\n+\n+  if (!this->skip_whitespace(false))\n+    return false;\n+  if (*this->p_ == '}')\n+    {\n+      ++this->p_;\n+      return true;\n+    }\n+\n+  while (true)\n+    {\n+      if (!this->skip_whitespace(false))\n+\treturn false;\n+      if (*this->p_ != '\"')\n+\t{\n+\t  this->error(\"expected %<\\\"%>\");\n+\t  return false;\n+\t}\n+\n+      std::string key;\n+      if (!this->read_string(&key))\n+\treturn false;\n+\n+      if (!this->skip_whitespace(false))\n+\treturn false;\n+      if (*this->p_ != ':')\n+\t{\n+\t  this->error(\"expected %<:%>\");\n+\t  return false;\n+\t}\n+      ++this->p_;\n+\n+      Json_value* subval = new Json_value();\n+      if (!this->read_value(subval))\n+\treturn false;\n+\n+      val->add_map_entry(key, subval);\n+\n+      if (!this->skip_whitespace(false))\n+\treturn false;\n+      if (*this->p_ == '}')\n+\t{\n+\t  ++this->p_;\n+\t  return true;\n+\t}\n+      if (*this->p_ != ',')\n+\t{\n+\t  this->error(\"expected %<,%> or %<}%>\");\n+\t  return false;\n+\t}\n+      ++this->p_;\n+    }\n+}\n+\n+// Read a JSON array into VAL.  Return whether it succeeded.\n+\n+bool\n+Embedcfg_reader::read_array(Json_value* val)\n+{\n+  if (!this->skip_whitespace(false))\n+    return false;\n+  if (*this->p_ != '[')\n+    {\n+      this->error(\"expected %<[%>\");\n+      return false;\n+    }\n+  ++this->p_;\n+\n+  val->start_array();\n+\n+  if (!this->skip_whitespace(false))\n+    return false;\n+  if (*this->p_ == ']')\n+    {\n+      ++this->p_;\n+      return true;\n+    }\n+\n+  while (true)\n+    {\n+      // If we were parsing full JSON we would call read_value here,\n+      // not read_string.\n+\n+      std::string s;\n+      if (!this->read_string(&s))\n+\treturn false;\n+\n+      val->add_array_entry(s);\n+\n+      if (!this->skip_whitespace(false))\n+\treturn false;\n+      if (*this->p_ == ']')\n+\t{\n+\t  ++this->p_;\n+\t  return true;\n+\t}\n+      if (*this->p_ != ',')\n+\t{\n+\t  this->error(\"expected %<,%> or %<]%>\");\n+\t  return false;\n+\t}\n+      ++this->p_;\n+    }\n+}\n+\n+// Read a JSON value into VAL.  Return whether it succeeded.\n+\n+bool\n+Embedcfg_reader::read_value(Json_value* val)\n+{\n+  if (!this->skip_whitespace(false))\n+    return false;\n+  switch (*this->p_)\n+    {\n+    case '\"':\n+      {\n+\tstd::string s;\n+\tif (!this->read_string(&s))\n+\t  return false;\n+\tval->set_string(s);\n+\treturn true;\n+      }\n+\n+    case '{':\n+      return this->read_object(val);\n+\n+    case '[':\n+      return this->read_array(val);\n+\n+    default:\n+      this->error(\"invalid JSON syntax\");\n+      return false;\n+    }\n+}\n+\n+// Read a JSON string.  Return whether it succeeded.\n+\n+bool\n+Embedcfg_reader::read_string(std::string* str)\n+{\n+  if (!this->skip_whitespace(false))\n+    return false;\n+  if (*this->p_ != '\"')\n+    {\n+      this->error(\"expected %<\\\"%>\");\n+      return false;\n+    }\n+  ++this->p_;\n+\n+  str->clear();\n+  while (this->p_ < this->pend_ && *this->p_ != '\"')\n+    {\n+      if (*this->p_ != '\\\\')\n+\t{\n+\t  str->push_back(*this->p_);\n+\t  ++this->p_;\n+\t  continue;\n+\t}\n+\n+      ++this->p_;\n+      if (this->p_ >= this->pend_)\n+\t{\n+\t  this->error(\"unterminated string\");\n+\t  return false;\n+\t}\n+      switch (*this->p_)\n+\t{\n+\tcase '\"': case '\\\\': case '/':\n+\t  str->push_back(*this->p_);\n+\t  ++this->p_;\n+\t  break;\n+\n+\tcase 'b':\n+\t  str->push_back('\\b');\n+\t  ++this->p_;\n+\t  break;\n+\n+\tcase 'f':\n+\t  str->push_back('\\f');\n+\t  ++this->p_;\n+\t  break;\n+\n+\tcase 'n':\n+\t  str->push_back('\\n');\n+\t  ++this->p_;\n+\t  break;\n+\n+\tcase 'r':\n+\t  str->push_back('\\r');\n+\t  ++this->p_;\n+\t  break;\n+\n+\tcase 't':\n+\t  str->push_back('\\t');\n+\t  ++this->p_;\n+\t  break;\n+\n+\tcase 'u':\n+\t  {\n+\t    ++this->p_;\n+\t    unsigned int rune = 0;\n+\t    for (int i = 0; i < 4; i++)\n+\t      {\n+\t\tif (this->p_ >= this->pend_)\n+\t\t  {\n+\t\t    this->error(\"unterminated string\");\n+\t\t    return false;\n+\t\t  }\n+\t\tunsigned char c = *this->p_;\n+\t\t++this->p_;\n+\t\trune <<= 4;\n+\t\tif (c >= '0' && c <= '9')\n+\t\t  rune += c - '0';\n+\t\telse if (c >= 'A' && c <= 'F')\n+\t\t  rune += c - 'A' + 10;\n+\t\telse if (c >= 'a' && c <= 'f')\n+\t\t  rune += c - 'a' + 10;\n+\t\telse\n+\t\t  {\n+\t\t    this->error(\"invalid hex digit\");\n+\t\t    return false;\n+\t\t  }\n+\t      }\n+\t    Lex::append_char(rune, false, str, Linemap::unknown_location());\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  this->error(\"unrecognized string escape\");\n+\t  return false;\n+\t}\n+    }\n+\n+  if (*this->p_ == '\"')\n+    {\n+      ++this->p_;\n+      return true;\n+    }\n+\n+  this->error(\"unterminated string\");\n+  return false;\n+}\n+\n+// Report an error if not at EOF.\n+\n+void\n+Embedcfg_reader::check_eof()\n+{\n+  if (this->skip_whitespace(true))\n+    this->error(\"extraneous data at end of file\");\n+}\n+\n+// Skip whitespace.  Return whether there is more to read.\n+\n+bool\n+Embedcfg_reader::skip_whitespace(bool eof_ok)\n+{\n+  while (this->p_ < this->pend_)\n+    {\n+      switch (*this->p_)\n+\t{\n+\tcase ' ': case '\\t': case '\\n': case '\\r':\n+\t  ++this->p_;\n+\t  break;\n+\tdefault:\n+\t  return true;\n+\t}\n+    }\n+  if (!eof_ok)\n+    this->error(\"unexpected EOF\");\n+  return false;\n+}\n+\n+// Report an error.\n+\n+void\n+Embedcfg_reader::error(const char* msg)\n+{\n+  if (!this->data_.empty() && this->p_ != NULL)\n+    go_error_at(Linemap::unknown_location(),\n+\t\t\"%<-fgo-embedcfg%>: %s: %lu: %s\",\n+\t\tthis->filename_,\n+\t\tstatic_cast<unsigned long>(this->p_ - this->data_.data()),\n+\t\tmsg);\n+  else\n+    go_error_at(Linemap::unknown_location(),\n+\t\t\"%<-fgo-embedcfg%>: %s: %s\",\n+\t\tthis->filename_, msg);\n+}"}, {"sha": "0d80bdeda4ff3b06a740af1329764dad9844e529", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ccd3922f5ee31b682e7844d97e5180c33fa8ea/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=b0ccd3922f5ee31b682e7844d97e5180c33fa8ea", "patch": "@@ -393,6 +393,10 @@ class Gogo\n   set_c_header(const std::string& s)\n   { this->c_header_ = s; }\n \n+  // Read an embedcfg file.\n+  void\n+  read_embedcfg(const char* filename);\n+\n   // Return whether to check for division by zero in binary operations.\n   bool\n   check_divide_by_zero() const"}]}