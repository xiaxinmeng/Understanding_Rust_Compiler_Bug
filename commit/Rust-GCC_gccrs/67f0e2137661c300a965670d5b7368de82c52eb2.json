{"sha": "67f0e2137661c300a965670d5b7368de82c52eb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdmMGUyMTM3NjYxYzMwMGE5NjU2NzBkNWI3MzY4ZGU4MmM1MmViMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-14T10:49:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-14T10:49:58Z"}, "message": "(init_regset_vector): Make global; don't take basic block times # of pseduos as argument.\n\n(init_regset_vector): Make global; don't take basic block times # of pseduos\nas argument.\n(life_analysis): Change all init_regset_vector calls.\nUse free_regset_vector to release arrays only flow uses at end.\n(allocate_for_life_analysis): Change init_regset_vector call.\nDon't set regset_{size,bytes}.\n(free_regset_vector): Call FREE_REG_SET to release any memory allocated\nby each vector.\n(propagate_block): Call FREE_REG_SET on dead/live.\n(mark_used_regs): Don't use REGSET_ELT_TYPE anymore.\n\nFrom-SVN: r14422", "tree": {"sha": "9d32bdfc8b35614727e8b51fb81f3f0d02daf40b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d32bdfc8b35614727e8b51fb81f3f0d02daf40b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67f0e2137661c300a965670d5b7368de82c52eb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f0e2137661c300a965670d5b7368de82c52eb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f0e2137661c300a965670d5b7368de82c52eb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f0e2137661c300a965670d5b7368de82c52eb2/comments", "author": null, "committer": null, "parents": [{"sha": "19d181423f031bfff7a4bed1d4190fbd8d1bffd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d181423f031bfff7a4bed1d4190fbd8d1bffd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19d181423f031bfff7a4bed1d4190fbd8d1bffd4"}], "stats": {"total": 65, "additions": 43, "deletions": 22}, "files": [{"sha": "87eecbcfc5bf8d63ca101efb53763dff333ee70d", "filename": "gcc/flow.c", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f0e2137661c300a965670d5b7368de82c52eb2/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f0e2137661c300a965670d5b7368de82c52eb2/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=67f0e2137661c300a965670d5b7368de82c52eb2", "patch": "@@ -253,7 +253,8 @@ static int jmp_uses_reg_or_mem\t\tPROTO((rtx));\n static void mark_label_ref\t\tPROTO((rtx, rtx, int));\n static void life_analysis\t\tPROTO((rtx, int));\n void allocate_for_life_analysis\t\tPROTO((void));\n-static void init_regset_vector\t\tPROTO((regset *, int, int, struct obstack *));\n+void init_regset_vector\t\t\tPROTO((regset *, int, struct obstack *));\n+void free_regset_vector\t\t\tPROTO((regset *, int));\n static void propagate_block\t\tPROTO((regset, rtx, rtx, int, \n \t\t\t\t\t       regset, int));\n static rtx flow_delete_insn\t\tPROTO((rtx));\n@@ -951,18 +952,16 @@ life_analysis (f, nregs)\n      if there isn't enough space.\n      Don't use oballoc since we may need to allocate other things during\n      this function on the temporary obstack.  */\n-  init_regset_vector (basic_block_live_at_end, n_basic_blocks, regset_bytes,\n-\t\t      &flow_obstack);\n+  init_regset_vector (basic_block_live_at_end, n_basic_blocks, &flow_obstack);\n \n   basic_block_new_live_at_end\n     = (regset *) alloca (n_basic_blocks * sizeof (regset));\n-  init_regset_vector (basic_block_new_live_at_end, n_basic_blocks, regset_bytes,\n+  init_regset_vector (basic_block_new_live_at_end, n_basic_blocks,\n \t\t      &flow_obstack);\n \n   basic_block_significant\n     = (regset *) alloca (n_basic_blocks * sizeof (regset));\n-  init_regset_vector (basic_block_significant, n_basic_blocks, regset_bytes,\n-\t\t      &flow_obstack);\n+  init_regset_vector (basic_block_significant, n_basic_blocks, &flow_obstack);\n \n   /* Record which insns refer to any volatile memory\n      or for any reason can't be deleted just because they are dead stores.\n@@ -1286,6 +1285,14 @@ life_analysis (f, nregs)\n \t\t\t\t }\n \t\t\t     });\n \n+\n+  free_regset_vector (basic_block_live_at_end, n_basic_blocks);\n+  free_regset_vector (basic_block_new_live_at_end, n_basic_blocks);\n+  free_regset_vector (basic_block_significant, n_basic_blocks);\n+  basic_block_live_at_end = (regset *)0;\n+  basic_block_new_live_at_end = (regset *)0;\n+  basic_block_significant = (regset *)0;\n+\n   obstack_free (&flow_obstack, NULL_PTR);\n }\n \f\n@@ -1299,37 +1306,34 @@ allocate_for_life_analysis ()\n {\n   register int i;\n \n-  regset_size = ((max_regno + REGSET_ELT_BITS - 1) / REGSET_ELT_BITS);\n-  regset_bytes = regset_size * sizeof (*(regset) 0);\n+  /* Recalculate the register space, in case it has grown.  Old style\n+     vector oriented regsets would set regset_{size,bytes} here also.  */\n+  allocate_reg_info (max_regno, FALSE, FALSE);\n \n   /* Because both reg_scan and flow_analysis want to set up the REG_N_SETS\n      information, explicitly reset it here.  The allocation should have\n      already happened on the previous reg_scan pass.  Make sure in case\n      some more registers were allocated.  */\n-  allocate_reg_info (max_regno, FALSE, FALSE);\n-\n   for (i = 0; i < max_regno; i++)\n     REG_N_SETS (i) = 0;\n \n   basic_block_live_at_start\n     = (regset *) oballoc (n_basic_blocks * sizeof (regset));\n-  init_regset_vector (basic_block_live_at_start, n_basic_blocks, regset_bytes,\n+  init_regset_vector (basic_block_live_at_start, n_basic_blocks,\n \t\t      function_obstack);\n \n   regs_live_at_setjmp = OBSTACK_ALLOC_REG_SET (function_obstack);\n   CLEAR_REG_SET (regs_live_at_setjmp);\n }\n \n-/* Make each element of VECTOR point at a regset,\n-   taking the space for all those regsets from SPACE.\n-   SPACE is of type regset, but it is really as long as NELTS regsets.\n-   BYTES_PER_ELT is the number of bytes in one regset.  */\n+/* Make each element of VECTOR point at a regset.  The vector has\n+   NELTS elements, and space is allocated from the ALLOC_OBSTACK\n+   obstack.  */\n \n-static void\n-init_regset_vector (vector, nelts, bytes_per_elt, alloc_obstack)\n+void\n+init_regset_vector (vector, nelts, alloc_obstack)\n      regset *vector;\n      int nelts;\n-     int bytes_per_elt;\n      struct obstack *alloc_obstack;\n {\n   register int i;\n@@ -1341,6 +1345,20 @@ init_regset_vector (vector, nelts, bytes_per_elt, alloc_obstack)\n     }\n }\n \n+/* Release any additional space allocated for each element of VECTOR point\n+   other than the regset header itself.  The vector has NELTS elements.  */\n+\n+void\n+free_regset_vector (vector, nelts)\n+     regset *vector;\n+     int nelts;\n+{\n+  register int i;\n+\n+  for (i = 0; i < nelts; i++)\n+    FREE_REG_SET (vector[i]);\n+}\n+\n /* Compute the registers live at the beginning of a basic block\n    from those live at the end.\n \n@@ -1663,6 +1681,11 @@ propagate_block (old, first, last, final, significant, bnum)\n \tbreak;\n     }\n \n+  FREE_REG_SET (dead);\n+  FREE_REG_SET (live);\n+  if (final)\n+    FREE_REG_SET (maxlive);\n+\n   if (num_scratch > max_scratch)\n     max_scratch = num_scratch;\n }\n@@ -2335,15 +2358,13 @@ mark_used_regs (needed, live, x, final, insn)\n       return;\n \n     case MEM:\n-      /* CYGNUS LOCAL dje/8176 */\n       /* Invalidate the data for the last MEM stored, but only if MEM is\n \t something that can be stored into.  */\n       if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n \t  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n \t; /* needn't clear last_mem_set */\n       else\n \tlast_mem_set = 0;\n-      /* END CYGNUS LOCAL */\n \n #ifdef AUTO_INC_DEC\n       if (final)\n@@ -2376,8 +2397,8 @@ mark_used_regs (needed, live, x, final, insn)\n \n       regno = REGNO (x);\n       {\n-\tREGSET_ELT_TYPE some_needed = REGNO_REG_SET_P (needed, regno);\n-\tREGSET_ELT_TYPE some_not_needed = ! some_needed;\n+\tint some_needed = REGNO_REG_SET_P (needed, regno);\n+\tint some_not_needed = ! some_needed;\n \n \tSET_REGNO_REG_SET (live, regno);\n "}]}