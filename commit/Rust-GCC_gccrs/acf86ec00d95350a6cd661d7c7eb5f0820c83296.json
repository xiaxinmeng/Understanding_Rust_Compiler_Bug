{"sha": "acf86ec00d95350a6cd661d7c7eb5f0820c83296", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNmODZlYzAwZDk1MzUwYTZjZDY2MWQ3YzdlYjVmMDgyMGM4MzI5Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-08-13T22:19:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-08-13T22:19:45Z"}, "message": "Initial revision\n\nFrom-SVN: r10214", "tree": {"sha": "2c437371c6b80c5d4ba6e097bfbf56363167cc70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c437371c6b80c5d4ba6e097bfbf56363167cc70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acf86ec00d95350a6cd661d7c7eb5f0820c83296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acf86ec00d95350a6cd661d7c7eb5f0820c83296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acf86ec00d95350a6cd661d7c7eb5f0820c83296", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acf86ec00d95350a6cd661d7c7eb5f0820c83296/comments", "author": null, "committer": null, "parents": [{"sha": "0c125e915295a70d4c88c93ea1a2f1eb1b437bfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c125e915295a70d4c88c93ea1a2f1eb1b437bfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c125e915295a70d4c88c93ea1a2f1eb1b437bfb"}], "stats": {"total": 131, "additions": 131, "deletions": 0}, "files": [{"sha": "972ae4a77799eaf34485c742871edc7055b96b37", "filename": "gcc/ginclude/va-ppc.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf86ec00d95350a6cd661d7c7eb5f0820c83296/gcc%2Fginclude%2Fva-ppc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf86ec00d95350a6cd661d7c7eb5f0820c83296/gcc%2Fginclude%2Fva-ppc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-ppc.h?ref=acf86ec00d95350a6cd661d7c7eb5f0820c83296", "patch": "@@ -0,0 +1,131 @@\n+/* GNU C varargs support for the PowerPC with V.4 calling sequence */\n+\n+/* Define __gnuc_va_list.  */\n+\n+#ifndef __GNUC_VA_LIST\n+#define __GNUC_VA_LIST\n+\n+typedef struct {\n+  char gpr;\t\t\t/* index into the array of 8 GPRs stored in the\n+\t\t\t\t   register save area gpr=0 corresponds to r3,\n+\t\t\t\t   gpr=1 to r4, etc. */\n+  char fpr;\t\t\t/* index into the array of 8 FPRs stored in the\n+\t\t\t\t   register save area fpr=0 corresponds to f1,\n+\t\t\t\t   fpr=1 to f2, etc. */\n+  char *overflow_arg_area;\t/* location on stack that holds the next\n+\t\t\t\t   overflow argument */\n+  char *reg_save_area;\t\t/* where r3:r10 and f1:f8, if saved are stored */\n+} __gnuc_va_list[1];\n+#endif /* not __GNUC_VA_LIST */\n+\n+/* If this is for internal libc use, don't define anything but\n+   __gnuc_va_list.  */\n+#if defined (_STDARG_H) || defined (_VARARGS_H)\n+\n+/* Register save area located below the frame pointer */\n+typedef struct {\n+  long   __gp_save[8];\t\t/* save area for GP registers */\n+  double __fp_save[8];\t\t/* save area for FP registers */\n+} __va_regsave_t;\n+\n+/* Macros to access the register save area */\n+/* We cast to void * and then to TYPE * because this avoids\n+   a warning about increasing the alignment requirement.  */\n+#define __VA_FP_REGSAVE(AP,TYPE)\t\t\t\t\t\\\n+  ((TYPE *) (void *) (&(((__va_regsave_t *)\t\t\t\t\\\n+\t\t\t (AP)->reg_save_area)->__fp_save[(int)(AP)->fpr])))\n+\n+#define __VA_GP_REGSAVE(AP,TYPE)\t\t\t\t\t\\\n+  ((TYPE *) (void *) (&(((__va_regsave_t *)\t\t\t\t\\\n+\t\t\t (AP)->reg_save_area)->__gp_save[(int)(AP)->gpr])))\n+\n+/* Common code for va_start for both varargs and stdarg.  This depends\n+   on the format of rs6000_args in rs6000.h.  The fields used are:\n+\n+   #0\tWORDS\t\t\t# words used for GP regs/stack values\n+   #1\tFREGNO\t\t\tnext available FP register\n+   #2\tNARGS_PROTOTYPE\t\t# args left in the current prototype\n+   #3\tORIG_NARGS\t\toriginal value of NARGS_PROTOTYPE\n+   #4\tVARARGS_OFFSET\t\toffset from frame pointer of varargs area */\n+\n+#define __va_words\t\t__builtin_args_info (0)\n+#define __va_fregno\t\t__builtin_args_info (1)\n+#define\t__va_nargs\t\t__builtin_args_info (2)\n+#define __va_orig_nargs\t\t__builtin_args_info (3)\n+#define __va_varargs_offset\t__builtin_args_info (4)\n+\n+#define __va_start_common(AP, FAKE)\t\t\t\t\t\\\n+__extension__ ({\t\t\t\t\t\t\t\\\n+   register int __words = __va_words - FAKE;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+   (AP)->gpr = (__words < 8) ? __words : 8;\t\t\t\t\\\n+   (AP)->fpr = __va_fregno - 33;\t\t\t\t\t\\\n+   (AP)->reg_save_area = (((char *) __builtin_frame_address (0))\t\\\n+\t\t\t  + __va_varargs_offset);\t\t\t\\\n+   (AP)->overflow_arg_area = ((char *)__builtin_saveregs ()\t\t\\\n+\t\t\t      + (((__words >= 8) ? __words - 8 : 0)\t\\\n+\t\t\t\t * sizeof (long)));\t\t\t\\\n+   (void)0;\t\t\t\t\t\t\t\t\\\n+})\n+\n+#ifdef _STDARG_H /* stdarg.h support */\n+\n+#define va_start(AP,LASTARG) __va_start_common (AP, 0)\n+\n+#else /* varargs.h support */\n+\n+#define va_start(AP) __va_start_common (AP, 1)\n+#define va_alist __va_1st_arg\n+#define va_dcl register int va_alist; ...\n+\n+#endif /* _STDARG_H */\n+\n+#ifdef _SOFT_FLOAT\n+#define __va_float_p(TYPE)\t0\n+#else\n+#define __va_float_p(TYPE)\t(__builtin_classify_type(*(TYPE *)0) == 8)\n+#endif\n+\n+#define __va_aggregate_p(TYPE)\t(__builtin_classify_type(*(TYPE *)0) >= 12)\n+#define __va_size(TYPE)\t\t((sizeof(TYPE) + sizeof (long) - 1) / sizeof (long))\n+\n+#define va_arg(AP,TYPE)\t\t\t\t\t\t\t\\\n+__extension__ ({\t\t\t\t\t\t\t\\\n+  register TYPE *__ptr;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (__va_float_p (TYPE) && (AP)->fpr < 8)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      __ptr = __VA_FP_REGSAVE (AP, TYPE);\t\t\t\t\\\n+      (AP)->fpr++;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else if (__va_aggregate_p (TYPE) && (AP)->gpr < 8)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      __ptr = * __VA_GP_REGSAVE (AP, TYPE *);\t\t\t\t\\\n+      (AP)->gpr++;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else if (!__va_float_p (TYPE) && !__va_aggregate_p (TYPE)\t\t\\\n+\t   && (AP)->gpr + __va_size(TYPE) <= 8)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      __ptr = __VA_GP_REGSAVE (AP, TYPE);\t\t\t\t\\\n+      (AP)->gpr += __va_size (TYPE);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else if (__va_aggregate_p (TYPE))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      __ptr = * (TYPE **) (void *) ((AP)->overflow_arg_area);\t\t\\\n+      (AP)->overflow_arg_area += sizeof (TYPE *);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      __ptr = (TYPE *) (void *) ((AP)->overflow_arg_area);\t\t\\\n+      (AP)->overflow_arg_area += __va_size (TYPE) * sizeof (long);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  *__ptr;\t\t\t\t\t\t\t\t\\\n+})\n+\n+#define va_end(AP)\t((void)0)\n+\n+#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}]}