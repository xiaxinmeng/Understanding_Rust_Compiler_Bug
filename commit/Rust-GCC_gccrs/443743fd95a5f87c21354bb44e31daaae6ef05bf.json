{"sha": "443743fd95a5f87c21354bb44e31daaae6ef05bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQzNzQzZmQ5NWE1Zjg3YzIxMzU0YmI0NGUzMWRhYWFlNmVmMDViZg==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2014-12-09T22:44:16Z"}, "committer": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2014-12-09T22:44:16Z"}, "message": "lto-wrapper.c (compile_offload_image): Start processing in_argv from 0 instead of 1.\n\ngcc/\n\t* lto-wrapper.c (compile_offload_image): Start processing in_argv\n\tfrom 0 instead of 1.\n\t(run_gcc): Put offload objects into offload_argv, put LTO objects and\n\tpossible preceding arguments into lto_argv.\n\tPass offload_argv to compile_images_for_offload_targets instead of argv.\n\tUse lto_argv for LTO recompilation instead of argv.\nlto-plugin/\n\t* lto-plugin.c (offload_files, num_offload_files): New static variables.\n\t(free_1): Use arguments instead of global variables.\n\t(free_2): Free offload_files.\n\t(all_symbols_read_handler): Add names from offload_files to lto-wrapper\n\targuments.\n\t(claim_file_handler): Do not add file to claimed_files if it contains\n\toffload sections without LTO sections.  Add it to offload_files instead.\n\nFrom-SVN: r218543", "tree": {"sha": "c794771581c3a03e67a31e87a7be71285b56b08d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c794771581c3a03e67a31e87a7be71285b56b08d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/443743fd95a5f87c21354bb44e31daaae6ef05bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/443743fd95a5f87c21354bb44e31daaae6ef05bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/443743fd95a5f87c21354bb44e31daaae6ef05bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/443743fd95a5f87c21354bb44e31daaae6ef05bf/comments", "author": null, "committer": null, "parents": [{"sha": "3f6ad8df42fcf4b9afa29ca9170e075e7482be3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f6ad8df42fcf4b9afa29ca9170e075e7482be3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f6ad8df42fcf4b9afa29ca9170e075e7482be3d"}], "stats": {"total": 132, "additions": 104, "deletions": 28}, "files": [{"sha": "cbef2f2693a073e829b9626f64df7552a8d829cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/443743fd95a5f87c21354bb44e31daaae6ef05bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/443743fd95a5f87c21354bb44e31daaae6ef05bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=443743fd95a5f87c21354bb44e31daaae6ef05bf", "patch": "@@ -1,3 +1,12 @@\n+2014-12-09  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* lto-wrapper.c (compile_offload_image): Start processing in_argv\n+\tfrom 0 instead of 1.\n+\t(run_gcc): Put offload objects into offload_argv, put LTO objects and\n+\tpossible preceding arguments into lto_argv.\n+\tPass offload_argv to compile_images_for_offload_targets instead of argv.\n+\tUse lto_argv for LTO recompilation instead of argv.\n+\n 2014-12-09  Michael Haubenwallner <michael.haubenwallner@ssi-schaefer.com>\n \n \t* doc/install.texi: Describe --with-aix-soname option."}, {"sha": "f75c0dc43789e93ac46b6556603e3a4d732ca56c", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/443743fd95a5f87c21354bb44e31daaae6ef05bf/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/443743fd95a5f87c21354bb44e31daaae6ef05bf/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=443743fd95a5f87c21354bb44e31daaae6ef05bf", "patch": "@@ -669,7 +669,7 @@ compile_offload_image (const char *target, const char *compiler_path,\n       obstack_ptr_grow (&argv_obstack, filename);\n \n       /* Append names of input object files.  */\n-      for (unsigned i = 1; i < in_argc; i++)\n+      for (unsigned i = 0; i < in_argc; i++)\n \tobstack_ptr_grow (&argv_obstack, in_argv[i]);\n \n       /* Append options from offload_lto sections.  */\n@@ -883,6 +883,8 @@ run_gcc (unsigned argc, char *argv[])\n   int new_head_argc;\n   bool have_lto = false;\n   bool have_offload = false;\n+  unsigned lto_argc = 0, offload_argc = 0;\n+  char **lto_argv, **offload_argv;\n \n   /* Get the driver and options.  */\n   collect_gcc = getenv (\"COLLECT_GCC\");\n@@ -896,6 +898,11 @@ run_gcc (unsigned argc, char *argv[])\n \t\t\t\t\t&decoded_options,\n \t\t\t\t\t&decoded_options_count);\n \n+  /* Allocate arrays for input object files with LTO or offload IL,\n+     and for possible preceding arguments.  */\n+  lto_argv = XNEWVEC (char *, argc);\n+  offload_argv = XNEWVEC (char *, argc);\n+\n   /* Look at saved options in the IL files.  */\n   for (i = 1; i < argc; ++i)\n     {\n@@ -918,17 +925,27 @@ run_gcc (unsigned argc, char *argv[])\n \t}\n       fd = open (argv[i], O_RDONLY);\n       if (fd == -1)\n-\tcontinue;\n+\t{\n+\t  lto_argv[lto_argc++] = argv[i];\n+\t  continue;\n+\t}\n+\n+      if (find_and_merge_options (fd, file_offset, LTO_SECTION_NAME_PREFIX,\n+\t\t\t\t  &fdecoded_options, &fdecoded_options_count,\n+\t\t\t\t  collect_gcc))\n+\t{\n+\t  have_lto = true;\n+\t  lto_argv[lto_argc++] = argv[i];\n+\t}\n+\n+      if (find_and_merge_options (fd, file_offset, OFFLOAD_SECTION_NAME_PREFIX,\n+\t\t\t\t  &offload_fdecoded_options,\n+\t\t\t\t  &offload_fdecoded_options_count, collect_gcc))\n+\t{\n+\t  have_offload = true;\n+\t  offload_argv[offload_argc++] = argv[i];\n+\t}\n \n-      have_lto\n-\t|= find_and_merge_options (fd, file_offset, LTO_SECTION_NAME_PREFIX,\n-\t\t\t\t   &fdecoded_options, &fdecoded_options_count,\n-\t\t\t\t   collect_gcc);\n-      have_offload\n-\t|= find_and_merge_options (fd, file_offset, OFFLOAD_SECTION_NAME_PREFIX,\n-\t\t\t\t   &offload_fdecoded_options,\n-\t\t\t\t   &offload_fdecoded_options_count,\n-\t\t\t\t   collect_gcc);\n       close (fd);\n     }\n \n@@ -1027,7 +1044,8 @@ run_gcc (unsigned argc, char *argv[])\n \n   if (have_offload)\n     {\n-      compile_images_for_offload_targets (argc, argv, offload_fdecoded_options,\n+      compile_images_for_offload_targets (offload_argc, offload_argv,\n+\t\t\t\t\t  offload_fdecoded_options,\n \t\t\t\t\t  offload_fdecoded_options_count,\n \t\t\t\t\t  decoded_options,\n \t\t\t\t\t  decoded_options_count);\n@@ -1119,8 +1137,8 @@ run_gcc (unsigned argc, char *argv[])\n     }\n \n   /* Append the input objects and possible preceding arguments.  */\n-  for (i = 1; i < argc; ++i)\n-    obstack_ptr_grow (&argv_obstack, argv[i]);\n+  for (i = 0; i < lto_argc; ++i)\n+    obstack_ptr_grow (&argv_obstack, lto_argv[i]);\n   obstack_ptr_grow (&argv_obstack, NULL);\n \n   new_argv = XOBFINISH (&argv_obstack, const char **);\n@@ -1295,6 +1313,8 @@ run_gcc (unsigned argc, char *argv[])\n   if (offloadend)\n     printf (\"%s\\n\", offloadend);\n \n+  XDELETE (lto_argv);\n+  XDELETE (offload_argv);\n   obstack_free (&argv_obstack, NULL);\n }\n "}, {"sha": "e8ec05b404110dca06b50a16f3905e8644cc2ad8", "filename": "lto-plugin/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/443743fd95a5f87c21354bb44e31daaae6ef05bf/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/443743fd95a5f87c21354bb44e31daaae6ef05bf/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=443743fd95a5f87c21354bb44e31daaae6ef05bf", "patch": "@@ -1,3 +1,13 @@\n+2014-12-09  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* lto-plugin.c (offload_files, num_offload_files): New static variables.\n+\t(free_1): Use arguments instead of global variables.\n+\t(free_2): Free offload_files.\n+\t(all_symbols_read_handler): Add names from offload_files to lto-wrapper\n+\targuments.\n+\t(claim_file_handler): Do not add file to claimed_files if it contains\n+\toffload sections without LTO sections.  Add it to offload_files instead.\n+\n 2014-11-21  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR bootstrap/63784"}, {"sha": "8d957402ba666922c466679c53af2f4b3d46eff7", "filename": "lto-plugin/lto-plugin.c", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/443743fd95a5f87c21354bb44e31daaae6ef05bf/lto-plugin%2Flto-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/443743fd95a5f87c21354bb44e31daaae6ef05bf/lto-plugin%2Flto-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin.c?ref=443743fd95a5f87c21354bb44e31daaae6ef05bf", "patch": "@@ -152,6 +152,9 @@ static ld_plugin_add_symbols add_symbols;\n static struct plugin_file_info *claimed_files = NULL;\n static unsigned int num_claimed_files = 0;\n \n+static struct plugin_file_info *offload_files = NULL;\n+static unsigned int num_offload_files = 0;\n+\n static char **output_files = NULL;\n static unsigned int num_output_files = 0;\n \n@@ -313,12 +316,12 @@ translate (char *data, char *end, struct plugin_symtab *out)\n    resolution. */\n \n static void\n-free_1 (void)\n+free_1 (struct plugin_file_info *files, unsigned num_files)\n {\n   unsigned int i;\n-  for (i = 0; i < num_claimed_files; i++)\n+  for (i = 0; i < num_files; i++)\n     {\n-      struct plugin_file_info *info = &claimed_files[i];\n+      struct plugin_file_info *info = &files[i];\n       struct plugin_symtab *symtab = &info->symtab;\n       unsigned int j;\n       for (j = 0; j < symtab->nsyms; j++)\n@@ -346,6 +349,14 @@ free_2 (void)\n       free (info->name);\n     }\n \n+  for (i = 0; i < num_offload_files; i++)\n+    {\n+      struct plugin_file_info *info = &offload_files[i];\n+      struct plugin_symtab *symtab = &info->symtab;\n+      free (symtab->aux);\n+      free (info->name);\n+    }\n+\n   for (i = 0; i < num_output_files; i++)\n     free (output_files[i]);\n   free (output_files);\n@@ -354,6 +365,10 @@ free_2 (void)\n   claimed_files = NULL;\n   num_claimed_files = 0;\n \n+  free (offload_files);\n+  offload_files = NULL;\n+  num_offload_files = 0;\n+\n   free (arguments_file_name);\n   arguments_file_name = NULL;\n }\n@@ -608,10 +623,11 @@ static enum ld_plugin_status\n all_symbols_read_handler (void)\n {\n   unsigned i;\n-  unsigned num_lto_args = num_claimed_files + lto_wrapper_num_args + 1;\n+  unsigned num_lto_args\n+    = num_claimed_files + num_offload_files + lto_wrapper_num_args + 1;\n   char **lto_argv;\n   const char **lto_arg_ptr;\n-  if (num_claimed_files == 0)\n+  if (num_claimed_files + num_offload_files == 0)\n     return LDPS_OK;\n \n   if (nop)\n@@ -626,7 +642,8 @@ all_symbols_read_handler (void)\n \n   write_resolution ();\n \n-  free_1 ();\n+  free_1 (claimed_files, num_claimed_files);\n+  free_1 (offload_files, num_offload_files);\n \n   for (i = 0; i < lto_wrapper_num_args; i++)\n     *lto_arg_ptr++ = lto_wrapper_argv[i];\n@@ -638,6 +655,13 @@ all_symbols_read_handler (void)\n       *lto_arg_ptr++ = info->name;\n     }\n \n+  for (i = 0; i < num_offload_files; i++)\n+    {\n+      struct plugin_file_info *info = &offload_files[i];\n+\n+      *lto_arg_ptr++ = info->name;\n+    }\n+\n   *lto_arg_ptr++ = NULL;\n   exec_lto_wrapper (lto_argv);\n \n@@ -949,16 +973,29 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n   if (obj.found > 1)\n     resolve_conflicts (&lto_file.symtab, &lto_file.conflicts);\n \n-  status = add_symbols (file->handle, lto_file.symtab.nsyms,\n-\t\t\tlto_file.symtab.syms);\n-  check (status == LDPS_OK, LDPL_FATAL, \"could not add symbols\");\n+  if (obj.found > 0)\n+    {\n+      status = add_symbols (file->handle, lto_file.symtab.nsyms,\n+\t\t\t    lto_file.symtab.syms);\n+      check (status == LDPS_OK, LDPL_FATAL, \"could not add symbols\");\n+\n+      num_claimed_files++;\n+      claimed_files =\n+\txrealloc (claimed_files,\n+\t\t  num_claimed_files * sizeof (struct plugin_file_info));\n+      claimed_files[num_claimed_files - 1] = lto_file;\n+    }\n+\n+  if (obj.found == 0 && obj.offload == 1)\n+    {\n+      num_offload_files++;\n+      offload_files =\n+\txrealloc (offload_files,\n+\t\t  num_offload_files * sizeof (struct plugin_file_info));\n+      offload_files[num_offload_files - 1] = lto_file;\n+    }\n \n   *claimed = 1;\n-  num_claimed_files++;\n-  claimed_files =\n-    xrealloc (claimed_files,\n-\t      num_claimed_files * sizeof (struct plugin_file_info));\n-  claimed_files[num_claimed_files - 1] = lto_file;\n \n   goto cleanup;\n "}]}