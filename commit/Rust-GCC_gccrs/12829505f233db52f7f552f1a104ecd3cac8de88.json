{"sha": "12829505f233db52f7f552f1a104ecd3cac8de88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI4Mjk1MDVmMjMzZGI1MmY3ZjU1MmYxYTEwNGVjZDNjYWM4ZGU4OA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-11-21T18:03:09Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-11-21T18:03:09Z"}, "message": "re PR target/63965 (ICE: in extract_constrain_insn, at recog.c:2230 on ppc64)\n\n2014-11-21  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/63965\n\t* config/rs6000/rs6000.c (rs6000_setup_reg_addr_masks): Do not set\n\tAltivec & -16 mask if the type is not valid for Altivec registers.\n\t(rs6000_secondary_reload_memory): Add support for ((reg + const) +\n\treg) that occurs during push_reload processing.\n\n\t* config/rs6000/altivec.md (altivec_mov<mode>): Add instruction\n\talternative for moving constant vectors which are easy altivec\n\tconstants to GPRs.  Set the length attribute each of the\n\talternatives.\n\nFrom-SVN: r217940", "tree": {"sha": "70b8a30963ad8464a26784df401831fc1adef5bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70b8a30963ad8464a26784df401831fc1adef5bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12829505f233db52f7f552f1a104ecd3cac8de88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12829505f233db52f7f552f1a104ecd3cac8de88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12829505f233db52f7f552f1a104ecd3cac8de88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12829505f233db52f7f552f1a104ecd3cac8de88/comments", "author": null, "committer": null, "parents": [{"sha": "a871c139f07730f14985620e3c05c4ddc6e2be0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a871c139f07730f14985620e3c05c4ddc6e2be0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a871c139f07730f14985620e3c05c4ddc6e2be0c"}], "stats": {"total": 29, "additions": 18, "deletions": 11}, "files": [{"sha": "9fb7f7a6ad8c62b29e9878e68243d210586b760d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12829505f233db52f7f552f1a104ecd3cac8de88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12829505f233db52f7f552f1a104ecd3cac8de88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12829505f233db52f7f552f1a104ecd3cac8de88", "patch": "@@ -1,3 +1,16 @@\n+2014-11-21  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/63965\n+\t* config/rs6000/rs6000.c (rs6000_setup_reg_addr_masks): Do not set\n+\tAltivec & -16 mask if the type is not valid for Altivec registers.\n+\t(rs6000_secondary_reload_memory): Add support for ((reg + const) +\n+\treg) that occurs during push_reload processing.\n+\n+\t* config/rs6000/altivec.md (altivec_mov<mode>): Add instruction\n+\talternative for moving constant vectors which are easy altivec\n+\tconstants to GPRs.  Set the length attribute each of the\n+\talternatives.\n+\n 2014-11-21  Matthew Fortune  <matthew.fortune@imgtec.com>\n \n \t* configure.ac: When checking for MIPS .module support ensure that"}, {"sha": "7bd5891d13c7ac41ac49c74ee2ea68150238101a", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12829505f233db52f7f552f1a104ecd3cac8de88/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12829505f233db52f7f552f1a104ecd3cac8de88/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=12829505f233db52f7f552f1a104ecd3cac8de88", "patch": "@@ -38,14 +38,14 @@\n \n   /* For ISA 2.06, don't add ISEL, since in general it isn't a win, but\n      altivec is a win so enable it.  */\n-  /* OPTION_MASK_VSX_TIMODE should be set, but disable it for now until\n-     PR 58587 is fixed.  */\n #define ISA_2_6_MASKS_EMBEDDED\t(ISA_2_5_MASKS_EMBEDDED | OPTION_MASK_POPCNTD)\n #define ISA_2_6_MASKS_SERVER\t(ISA_2_5_MASKS_SERVER\t\t\t\\\n \t\t\t\t | OPTION_MASK_POPCNTD\t\t\t\\\n \t\t\t\t | OPTION_MASK_ALTIVEC\t\t\t\\\n \t\t\t\t | OPTION_MASK_VSX\t\t\t\\\n-\t\t\t\t | OPTION_MASK_UPPER_REGS_DF)\n+\t\t\t\t | OPTION_MASK_UPPER_REGS_DF\t\t\\\n+\t\t\t\t | OPTION_MASK_VSX_TIMODE)\n+\n \n /* For now, don't provide an embedded version of ISA 2.07.  */\n #define ISA_2_7_MASKS_SERVER\t(ISA_2_6_MASKS_SERVER\t\t\t\\\n@@ -188,7 +188,8 @@ RS6000_CPU (\"power6x\", PROCESSOR_POWER6, MASK_POWERPC64 | MASK_PPC_GPOPT\n RS6000_CPU (\"power7\", PROCESSOR_POWER7,   /* Don't add MASK_ISEL by default */\n \t    POWERPC_7400_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_MFCRF\n \t    | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP | MASK_POPCNTD\n-\t    | MASK_VSX | MASK_RECIP_PRECISION | OPTION_MASK_UPPER_REGS_DF)\n+\t    | MASK_VSX | MASK_RECIP_PRECISION | OPTION_MASK_UPPER_REGS_DF\n+\t    | OPTION_MASK_VSX_TIMODE)\n RS6000_CPU (\"power8\", PROCESSOR_POWER8, MASK_POWERPC64 | ISA_2_7_MASKS_SERVER)\n RS6000_CPU (\"powerpc\", PROCESSOR_POWERPC, 0)\n RS6000_CPU (\"powerpc64\", PROCESSOR_POWERPC64, MASK_PPC_GFXOPT | MASK_POWERPC64)"}, {"sha": "6d128c17408e6d013bcbc3a49c957a5886bab864", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12829505f233db52f7f552f1a104ecd3cac8de88/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12829505f233db52f7f552f1a104ecd3cac8de88/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=12829505f233db52f7f552f1a104ecd3cac8de88", "patch": "@@ -7730,13 +7730,6 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n       && legitimate_constant_pool_address_p (x, mode,\n \t\t\t\t\t     reg_ok_strict || lra_in_progress))\n     return 1;\n-  /* For TImode, if we have load/store quad and TImode in VSX registers, only\n-     allow register indirect addresses.  This will allow the values to go in\n-     either GPRs or VSX registers without reloading.  The vector types would\n-     tend to go into VSX registers, so we allow REG+REG, while TImode seems\n-     somewhat split, in that some uses are GPR based, and some VSX based.  */\n-  if (mode == TImode && TARGET_QUAD_MEMORY && TARGET_VSX_TIMODE)\n-    return 0;\n   /* If not REG_OK_STRICT (before reload) let pass any stack offset.  */\n   if (! reg_ok_strict\n       && reg_offset_p"}]}