{"sha": "d0dd5209d981a9705ea87c5e86211e8f0709bb7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBkZDUyMDlkOTgxYTk3MDVlYTg3YzVlODYyMTFlOGYwNzA5YmI3Yw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-06-06T10:20:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:20:45Z"}, "message": "a-tags.ads, a-tags.adb (Tag_Size): This constant is now internal to the package.\n\n2007-04-20  Javier Miranda  <miranda@adacore.com>\n\n\t* a-tags.ads, a-tags.adb (Tag_Size): This constant is now internal to\n\tthe package.\n\t(Object_Specific_Data_Array): This is now internal to the package.\n\t(Object_Specific_Data): This is now internal to the package.\n\t(Select_Specific_Data_Element): This is now internal to the package.\n\t(Select_Specific_Data_Array): This is now internal to the package.\n\t(Select_Specific_Data): This is now internal to the package.\n\t(Offset_To_Top_Function_Ptr): This is now public.\n\t(To_Offset_To_Top_Function_Ptr): Removed.\n\t(Storage_Offset_Ptr,To_Storage_Offset_Ptr): These declarations are now\n\t local to subprogram Offset_To_Top.\n\t(Predefined_DT): Removed.\n\t(Typeinfo_Ptr): Removed.\n\t(OSD): This function is now internal to this package.\n\t(SSD): This function is now internal to this package.\n\t(DT): New function that displaces the pointer to the table of primitives\n\t to get access to the enclosing wrapper record.\n\t(IW_Membership): Code cleanup.\n\t(Offset_To_Top): Code cleanup.\n\t(Predefined_DT): Removed.\n\t(Register_Interface_Tag): Removed.\n\t(Set_Interface_Table): Removed.\n\t(Set_Offset_Index): Removed.\n\t(Set_Offset_To_Top): Code cleanup.\n\t(Set_OSD): Removed.\n\t(Set_Signature): Removed.\n\t(Set_SSD): Removed.\n\t(Set_Tagged_Kind): Removed.\n\t(Typeinfo_Ptr): Removed.\n\t(TSD): Removed.\n\t(Displace): Add missing check on null actual.\n\n\t* exp_disp.ads, exp_disp.adb\n\t(Select_Expansion_Utilities): Removed.\n\t(Build_Common_Dispatching_Select_Statements): Moved to exp_atags.\n\t(Expand_Dispatching_Call): Update calls to Get_Prim_Op_Address because\n\tthe interface requires a new parameter.\n\t(Make_Disp_Asynchronous_Select_Spec, Make_Disp_Conditional_Select_Spec,\n\tMake_Disp_Get_Prim_Op_Kind_Spec, Make_Disp_Timed_Select_Spec): Replace\n\tcalls to subprograms Build_T, Build_S, etc. by the corresponding code.\n\tDone to remove package Select_Expansion_Utilities.\n\t(Make_DT): New implementation for statically allocated dispatch tables.\n\t(Make_Secondary_DT): Moved to the scope of Make_DT.\n\t(Register_Primitive): Code cleanup plus incoporate the use of the new\n\tfunction DT_Address_Attribute.\n\t(Expand_Interface_Thunk): The profile of this subprogram has been\n\tchanged to return the Thunk_Id and the corresponding code.\n\t(Fill_DT_Entry): Removed. Its functionality is now provided by\n\tsubprogram Register_Primitive.\n\t(Fill_Secondary_DT_Entry): Removed. Its functionality is now provided by\n\tsubprogram Register_Primitive.\n\t(Register_Primitive): New subprogram that incorporates the previous\n\tfunctionalities of Fill_DT_Entry and Fill_Secondary_DT_Entry.\n\t(Build_Common_Dispatching_Select_Statements): Remove formal Typ. This\n\twas only required to call Make_DT_Access_Action, which is now removed.\n\t(Ada_Actions): Removed\n\t(Action_Is_Proc): Removed\n\t(Action_Nb_Arg): Removed\n\tReplace all the calls to Make_DT_Access_Action by direct calls to\n\tMake_Procedure_Call_Statement or Make_Function_Call.\n\t(Set_DTC_Entity_Value): New subprogram.\n\t(Set_All_DT_Position): Add call to new subprogram Set_DTC_Entity_Value.\n\t(Expand_Interface_Thunk): Add missing support for primitives that are\n\tfunctions with a controlling result (case in which there is no need\n\tto generate the thunk).\n\n\t* exp_atag.ads, exp_atag.adb\n\t(Build_DT): New subprogram that displaces the pointer to reference the\n\tbase of the wrapper record.\n\t(Build_Typeinfo_Offset): Removed.\n\t(RTE_Tag_Node): Removed.\n\t(Build_Common_Dispatching_Select_Statements): Moved here from exp_disp\n\t(Build_Get_RC_Offset): Removed.\n\t(Build_Inherit_Predefined_Prims): Removed.\n\t(Build_Inherit_TSD: Removed.\n\t(Build_New_TSD): Removed.\n\t(Build_Set_External_Tag): Removed.\n\t(Build_Set_Predefined_Prim_Op_Address): Add documentation.\n\t(Build_Set_Prim_Op_Address): Add documentation.\n\t(Build_Set_TSD): Removed.\n\n\t* rtsfind.ads, rtsfind.adb\n\t(Load_Fail): If load fails and we are not in configurable run-time\n\tmode, then raise Unrecoverable_Error.\n\t(Text_IO_Kludge): Generate an error message if a run-time library is\n\tnot available in a given run-time (ie. zfp run-time).\n\t(RTE_Record_Component): Add code to check that the component we search\n\tfor is not found in two records in the given run-time package.\n\t(RE_DT_Offset_To_Top_Size, RE_DT_Predef_Prims_Size): Removed\n\t(RE_DT_Predef_Prims_Offset): New entity\n\t(RE_Static_Offset_To_Top): New entity\n\t(RE_HT_Link): New entity.\n\t(System_Address_Image): Addition of this run-time package.\n\t(RE_Address_Image): New entity.\n\t(RE_Abstract_Interface): Removed.\n\t(RE_Default_Prim_Op_Count): Removed.\n\t(RE_DT_Entry_Size): Removed.\n\t(RE_DT_Min_Prologue_Size): Removed.\n\t(RE_DT_Prologue_Size): Removed.\n\t(RE_Ifaces_Table_Ptr): Removed.\n\t(RE_Interface_Data_Ptr): Removed.\n\t(RE_Type_Specific_Data): Removed.\n\t(RE_Primary_DT): Removed.\n\t(RE_Register_Interface_Tag): Removed.\n\t(RE_Set_Offset_Index): Removed.\n\t(RE_Set_OSD): Removed.\n\t(RE_Set_SSD): Removed.\n\t(RE_Set_Signature): Removed.\n\t(RE_Set_Tagged_Kind): Removed.\n\t(RE_Address_Array): New entity.\n\t(RE_DT): New entity.\n\t(RE_Iface_Tag): New entity.\n\t(RE_Interfaces_Table): New entity.\n\t(RE_No_Dispatch_Table): New entity.\n\t(RE_NDT_Prims_Ptr): New entity.\n\t(RE_NDT_TSD): New entity.\n\t(RE_Num_Prims): New entity.\n\t(RE_Offset_To_Top_Function_Ptr): New entity.\n\t(RE_OSD_Table): New entity.\n\t(RE_OSD_Num_Prims): New entity.\n\t(RE_Predef_Prims): New entity\n\t(RE_Predef_Prims_Table_Ptr): New entity.\n\t(RE_Primary_DT): New entity.\n\t(RE_Signature): New entity.\n\t(RE_SSD): New entity.\n\t(RE_TSD): New entity.\n\t(RE_Type_Specific_Data): New entity.\n\t(RE_Tag_Kind): New entity.\n\nFrom-SVN: r125379", "tree": {"sha": "8fbe6b35707fff66b60ba8cb0ee58cc612b2f5af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fbe6b35707fff66b60ba8cb0ee58cc612b2f5af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0dd5209d981a9705ea87c5e86211e8f0709bb7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0dd5209d981a9705ea87c5e86211e8f0709bb7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0dd5209d981a9705ea87c5e86211e8f0709bb7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc1f64ac929a1518ac202c4059a0eea45b0c442f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc1f64ac929a1518ac202c4059a0eea45b0c442f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc1f64ac929a1518ac202c4059a0eea45b0c442f"}], "stats": {"total": 6663, "additions": 3593, "deletions": 3070}, "files": [{"sha": "622087a08ad04dc89b15e9496674331d847e6e70", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 318, "deletions": 335, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=d0dd5209d981a9705ea87c5e86211e8f0709bb7c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,32 +41,40 @@ pragma Elaborate_All (System.HTable);\n \n package body Ada.Tags is\n \n-   --  Object specific data types (see description in a-tags.ads)\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean;\n+   --  Given the tag of an object and the tag associated to a type, return\n+   --  true if Obj is in Typ'Class.\n \n-   type Object_Specific_Data_Array is array (Positive range <>) of Positive;\n+   function Get_External_Tag (T : Tag) return System.Address;\n+   --  Returns address of a null terminated string containing the external name\n \n-   type Object_Specific_Data (Nb_Prim : Positive) is record\n-      OSD_Table : Object_Specific_Data_Array (1 .. Nb_Prim);\n-      --  Table used in secondary DT to reference their counterpart in the\n-      --  select specific data (in the TSD of the primary DT). This construct\n-      --  is used in the handling of dispatching triggers in select statements.\n-      --  Nb_Prim is the number of non-predefined primitive operations.\n-   end record;\n+   function Is_Primary_DT (T : Tag) return Boolean;\n+   --  Given a tag returns True if it has the signature of a primary dispatch\n+   --  table.  This is Inline_Always since it is called from other Inline_\n+   --  Always subprograms where we want no out of line code to be generated.\n \n-   --  Select specific data types\n+   function Length (Str : Cstring_Ptr) return Natural;\n+   --  Length of string represented by the given pointer (treating the string\n+   --  as a C-style string, which is Nul terminated).\n \n-   type Select_Specific_Data_Element is record\n-      Index : Positive;\n-      Kind  : Prim_Op_Kind;\n-   end record;\n+   function OSD (T : Tag) return Object_Specific_Data_Ptr;\n+   --  Ada 2005 (AI-251): Given a pointer T to a secondary dispatch table,\n+   --  retrieve the address of the record containing the Object Specific\n+   --  Data table.\n \n-   type Select_Specific_Data_Array is\n-     array (Positive range <>) of Select_Specific_Data_Element;\n+   function SSD (T : Tag) return Select_Specific_Data_Ptr;\n+   --  Ada 2005 (AI-251): Given a pointer T to a dispatch Table, retrieves the\n+   --  address of the record containing the Select Specific Data in T's TSD.\n \n-   type Select_Specific_Data (Nb_Prim : Positive) is record\n-      SSD_Table : Select_Specific_Data_Array (1 .. Nb_Prim);\n-      --  NOTE: Nb_Prim is the number of non-predefined primitive operations\n-   end record;\n+   pragma Inline_Always (CW_Membership);\n+   pragma Inline_Always (Get_External_Tag);\n+   pragma Inline_Always (Is_Primary_DT);\n+   pragma Inline_Always (OSD);\n+   pragma Inline_Always (SSD);\n \n    ---------------------------------------------\n    -- Unchecked Conversions for String Fields --\n@@ -78,6 +86,17 @@ package body Ada.Tags is\n    function To_Cstring_Ptr is\n      new Unchecked_Conversion (System.Address, Cstring_Ptr);\n \n+   --  Disable warnings on possible aliasing problem because we only use\n+   --  use this function to convert tags found in the External_Tag of\n+   --  locally defined tagged types.\n+\n+   pragma Warnings (off);\n+\n+   function To_Tag is\n+     new Unchecked_Conversion (Integer_Address, Tag);\n+\n+   pragma Warnings (on);\n+\n    ------------------------------------------------\n    -- Unchecked Conversions for other components --\n    ------------------------------------------------\n@@ -88,47 +107,93 @@ package body Ada.Tags is\n    function To_Acc_Size is new Unchecked_Conversion (System.Address, Acc_Size);\n    --  The profile of the implicitly defined _size primitive\n \n-   type Offset_To_Top_Function_Ptr is\n-      access function (This : System.Address)\n-               return System.Storage_Elements.Storage_Offset;\n-   --  Type definition used to call the function that is generated by the\n-   --  expander in case of tagged types with discriminants that have secondary\n-   --  dispatch tables. This function provides the Offset_To_Top value in this\n-   --  specific case.\n+   -------------------------------\n+   -- Inline_Always Subprograms --\n+   -------------------------------\n \n-   function To_Offset_To_Top_Function_Ptr is\n-      new Unchecked_Conversion (System.Address, Offset_To_Top_Function_Ptr);\n+   --  Inline_always subprograms must be placed before their first call to\n+   --  avoid defeating the frontend inlining mechanism and thus ensure the\n+   --  generation of their correct debug info.\n \n-   type Storage_Offset_Ptr is access System.Storage_Elements.Storage_Offset;\n+   -------------------\n+   -- CW_Membership --\n+   -------------------\n \n-   function To_Storage_Offset_Ptr is\n-     new Unchecked_Conversion (System.Address, Storage_Offset_Ptr);\n+   --  Canonical implementation of Classwide Membership corresponding to:\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n+   --     Obj in Typ'Class\n \n-   function Is_Primary_DT (T : Tag) return Boolean;\n-   pragma Inline_Always (Is_Primary_DT);\n-   --  Given a tag returns True if it has the signature of a primary dispatch\n-   --  table.  This is Inline_Always since it is called from other Inline_\n-   --  Always subprograms where we want no out of line code to be generated.\n+   --  Each dispatch table contains a reference to a table of ancestors (stored\n+   --  in the first part of the Tags_Table) and a count of the level of\n+   --  inheritance \"Idepth\".\n \n-   function Length (Str : Cstring_Ptr) return Natural;\n-   --  Length of string represented by the given pointer (treating the string\n-   --  as a C-style string, which is Nul terminated).\n+   --  Obj is in Typ'Class if Typ'Tag is in the table of ancestors that are\n+   --  contained in the dispatch table referenced by Obj'Tag . Knowing the\n+   --  level of inheritance of both types, this can be computed in constant\n+   --  time by the formula:\n+\n+   --   TSD (Obj'tag).Tags_Table (TSD (Obj'tag).Idepth - TSD (Typ'tag).Idepth)\n+   --     = Typ'tag\n+\n+   function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean is\n+      Obj_TSD_Ptr : constant Addr_Ptr :=\n+                     To_Addr_Ptr (To_Address (Obj_Tag) - DT_Typeinfo_Ptr_Size);\n+      Typ_TSD_Ptr : constant Addr_Ptr :=\n+                     To_Addr_Ptr (To_Address (Typ_Tag) - DT_Typeinfo_Ptr_Size);\n+      Obj_TSD     : constant Type_Specific_Data_Ptr :=\n+                     To_Type_Specific_Data_Ptr (Obj_TSD_Ptr.all);\n+      Typ_TSD     : constant Type_Specific_Data_Ptr :=\n+                     To_Type_Specific_Data_Ptr (Typ_TSD_Ptr.all);\n+      Pos         : constant Integer := Obj_TSD.Idepth - Typ_TSD.Idepth;\n+   begin\n+      return Pos >= 0 and then Obj_TSD.Tags_Table (Pos) = Typ_Tag;\n+   end CW_Membership;\n+\n+   ----------------------\n+   -- Get_External_Tag --\n+   ----------------------\n \n-   function Predefined_DT (T : Tag) return Tag;\n-   pragma Inline_Always (Predefined_DT);\n-   --  Displace the Tag to reference the dispatch table containing the\n-   --  predefined primitives.\n+   function Get_External_Tag (T : Tag) return System.Address is\n+      TSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      TSD     : constant Type_Specific_Data_Ptr :=\n+                  To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+   begin\n+      return To_Address (TSD.External_Tag);\n+   end Get_External_Tag;\n \n-   function Typeinfo_Ptr (T : Tag) return System.Address;\n-   --  Returns the current value of the typeinfo_ptr component available in\n-   --  the prologue of the dispatch table.\n+   -------------------\n+   -- Is_Primary_DT --\n+   -------------------\n \n-   pragma Unreferenced (Typeinfo_Ptr);\n-   --  These functions will be used for full compatibility with the C++ ABI\n+   function Is_Primary_DT (T : Tag) return Boolean is\n+   begin\n+      return DT (T).Signature = Primary_DT;\n+   end Is_Primary_DT;\n+\n+   ---------\n+   -- OSD --\n+   ---------\n+\n+   function OSD (T : Tag) return Object_Specific_Data_Ptr is\n+      OSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+   begin\n+      return To_Object_Specific_Data_Ptr (OSD_Ptr.all);\n+   end OSD;\n+\n+   ---------\n+   -- SSD --\n+   ---------\n+\n+   function SSD (T : Tag) return Select_Specific_Data_Ptr is\n+      TSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      TSD     : constant Type_Specific_Data_Ptr :=\n+                  To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+   begin\n+      return TSD.SSD;\n+   end SSD;\n \n    -------------------------\n    -- External_Tag_HTable --\n@@ -192,8 +257,12 @@ package body Ada.Tags is\n       -----------------\n \n       function Get_HT_Link (T : Tag) return Tag is\n+         TSD_Ptr : constant Addr_Ptr :=\n+                     To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+         TSD     : constant Type_Specific_Data_Ptr :=\n+                     To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n       begin\n-         return TSD (T).HT_Link;\n+         return TSD.HT_Link;\n       end Get_HT_Link;\n \n       ----------\n@@ -213,39 +282,16 @@ package body Ada.Tags is\n       -----------------\n \n       procedure Set_HT_Link (T : Tag; Next : Tag) is\n+         TSD_Ptr : constant Addr_Ptr :=\n+                     To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+         TSD     : constant Type_Specific_Data_Ptr :=\n+                     To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n       begin\n-         TSD (T).HT_Link := Next;\n+         TSD.HT_Link := Next;\n       end Set_HT_Link;\n \n    end HTable_Subprograms;\n \n-   -------------------\n-   -- CW_Membership --\n-   -------------------\n-\n-   --  Canonical implementation of Classwide Membership corresponding to:\n-\n-   --     Obj in Typ'Class\n-\n-   --  Each dispatch table contains a reference to a table of ancestors (stored\n-   --  in the first part of the Tags_Table) and a count of the level of\n-   --  inheritance \"Idepth\".\n-\n-   --  Obj is in Typ'Class if Typ'Tag is in the table of ancestors that are\n-   --  contained in the dispatch table referenced by Obj'Tag . Knowing the\n-   --  level of inheritance of both types, this can be computed in constant\n-   --  time by the formula:\n-\n-   --   TSD (Obj'tag).Tags_Table (TSD (Obj'tag).Idepth - TSD (Typ'tag).Idepth)\n-   --     = Typ'tag\n-\n-   function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean is\n-      Pos : Integer;\n-   begin\n-      Pos := TSD (Obj_Tag).Idepth - TSD (Typ_Tag).Idepth;\n-      return Pos >= 0 and then TSD (Obj_Tag).Tags_Table (Pos) = Typ_Tag;\n-   end CW_Membership;\n-\n    ------------------\n    -- Base_Address --\n    ------------------\n@@ -265,14 +311,18 @@ package body Ada.Tags is\n    is\n       Iface_Table : Interface_Data_Ptr;\n       Obj_Base    : System.Address;\n-      Obj_DT      : Tag;\n-      Obj_TSD     : Type_Specific_Data_Ptr;\n+      Obj_DT      : Dispatch_Table_Ptr;\n+      Obj_DT_Tag  : Tag;\n \n    begin\n-      Obj_Base    := This - Offset_To_Top (This);\n-      Obj_DT      := To_Tag_Ptr (Obj_Base).all;\n-      Obj_TSD     := TSD (Obj_DT);\n-      Iface_Table := To_Interface_Data_Ptr (Obj_TSD.Ifaces_Table_Ptr);\n+      if System.\"=\" (This, System.Null_Address) then\n+         return System.Null_Address;\n+      end if;\n+\n+      Obj_Base    := Base_Address (This);\n+      Obj_DT_Tag  := To_Tag_Ptr (Obj_Base).all;\n+      Obj_DT      := DT (To_Tag_Ptr (Obj_Base).all);\n+      Iface_Table := To_Type_Specific_Data_Ptr (Obj_DT.TSD).Interfaces_Table;\n \n       if Iface_Table /= null then\n          for Id in 1 .. Iface_Table.Nb_Ifaces loop\n@@ -288,14 +338,11 @@ package body Ada.Tags is\n                --  to provide us with this value\n \n                else\n-                  Obj_Base :=\n-                    Obj_Base +\n-                      To_Offset_To_Top_Function_Ptr\n-                        (Iface_Table.Ifaces_Table (Id).Offset_To_Top_Func).all\n-                          (Obj_Base);\n+                  Obj_Base := Obj_Base +\n+                    Iface_Table.Ifaces_Table (Id).Offset_To_Top_Func.all\n+                      (Obj_Base);\n                end if;\n \n-               Obj_DT := To_Tag_Ptr (Obj_Base).all;\n                return Obj_Base;\n             end if;\n          end loop;\n@@ -304,7 +351,7 @@ package body Ada.Tags is\n       --  Check if T is an immediate ancestor. This is required to handle\n       --  conversion of class-wide interfaces to tagged types.\n \n-      if CW_Membership (Obj_DT, T) then\n+      if CW_Membership (Obj_DT_Tag, T) then\n          return Obj_Base;\n       end if;\n \n@@ -313,6 +360,17 @@ package body Ada.Tags is\n       raise Constraint_Error;\n    end Displace;\n \n+   --------\n+   -- DT --\n+   --------\n+\n+   function DT (T : Tag) return Dispatch_Table_Ptr is\n+      Offset : constant SSE.Storage_Offset :=\n+                 To_Dispatch_Table_Ptr (T).Prims_Ptr'Position;\n+   begin\n+      return To_Dispatch_Table_Ptr (To_Address (T) - Offset);\n+   end DT;\n+\n    -------------------\n    -- IW_Membership --\n    -------------------\n@@ -329,20 +387,15 @@ package body Ada.Tags is\n \n    function IW_Membership (This : System.Address; T : Tag) return Boolean is\n       Iface_Table : Interface_Data_Ptr;\n-      Last_Id     : Natural;\n       Obj_Base    : System.Address;\n-      Obj_DT      : Tag;\n+      Obj_DT      : Dispatch_Table_Ptr;\n       Obj_TSD     : Type_Specific_Data_Ptr;\n \n    begin\n-      Obj_Base := This - Offset_To_Top (This);\n-      Obj_DT   := To_Tag_Ptr (Obj_Base).all;\n-      Obj_TSD  := TSD (Obj_DT);\n-      Last_Id  := Obj_TSD.Idepth;\n-\n-      --  Look for the tag in the table of interfaces\n-\n-      Iface_Table := To_Interface_Data_Ptr (Obj_TSD.Ifaces_Table_Ptr);\n+      Obj_Base    := Base_Address (This);\n+      Obj_DT      := DT (To_Tag_Ptr (Obj_Base).all);\n+      Obj_TSD     := To_Type_Specific_Data_Ptr (Obj_DT.TSD);\n+      Iface_Table := Obj_TSD.Interfaces_Table;\n \n       if Iface_Table /= null then\n          for Id in 1 .. Iface_Table.Nb_Ifaces loop\n@@ -355,7 +408,7 @@ package body Ada.Tags is\n       --  Look for the tag in the ancestor tags table. This is required for:\n       --     Iface_CW in Typ'Class\n \n-      for Id in 0 .. Last_Id loop\n+      for Id in 0 .. Obj_TSD.Idepth loop\n          if Obj_TSD.Tags_Table (Id) = T then\n             return True;\n          end if;\n@@ -384,14 +437,18 @@ package body Ada.Tags is\n    -------------------\n \n    function Expanded_Name (T : Tag) return String is\n-      Result : Cstring_Ptr;\n+      Result  : Cstring_Ptr;\n+      TSD_Ptr : Addr_Ptr;\n+      TSD     : Type_Specific_Data_Ptr;\n \n    begin\n       if T = No_Tag then\n          raise Tag_Error;\n       end if;\n \n-      Result := TSD (T).Expanded_Name;\n+      TSD_Ptr := To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      TSD     := To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+      Result  := TSD.Expanded_Name;\n       return Result (1 .. Length (Result));\n    end Expanded_Name;\n \n@@ -400,14 +457,18 @@ package body Ada.Tags is\n    ------------------\n \n    function External_Tag (T : Tag) return String is\n-      Result : Cstring_Ptr;\n+      Result  : Cstring_Ptr;\n+      TSD_Ptr : Addr_Ptr;\n+      TSD     : Type_Specific_Data_Ptr;\n \n    begin\n       if T = No_Tag then\n          raise Tag_Error;\n       end if;\n \n-      Result := TSD (T).External_Tag;\n+      TSD_Ptr := To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      TSD     := To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+      Result  := TSD.External_Tag;\n       return Result (1 .. Length (Result));\n    end External_Tag;\n \n@@ -420,15 +481,6 @@ package body Ada.Tags is\n       return SSD (T).SSD_Table (Position).Index;\n    end Get_Entry_Index;\n \n-   ----------------------\n-   -- Get_External_Tag --\n-   ----------------------\n-\n-   function Get_External_Tag (T : Tag) return System.Address is\n-   begin\n-      return To_Address (TSD (T).External_Tag);\n-   end Get_External_Tag;\n-\n    ----------------------\n    -- Get_Prim_Op_Kind --\n    ----------------------\n@@ -462,31 +514,35 @@ package body Ada.Tags is\n    -------------------\n \n    function Get_RC_Offset (T : Tag) return SSE.Storage_Offset is\n+      TSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      TSD     : constant Type_Specific_Data_Ptr :=\n+                  To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n    begin\n-      return TSD (T).RC_Offset;\n+      return TSD.RC_Offset;\n    end Get_RC_Offset;\n \n    ---------------------\n    -- Get_Tagged_Kind --\n    ---------------------\n \n    function Get_Tagged_Kind (T : Tag) return Tagged_Kind is\n-      Tagged_Kind_Ptr : constant System.Address :=\n-                          To_Address (T) - K_Tagged_Kind;\n    begin\n-      return To_Tagged_Kind_Ptr (Tagged_Kind_Ptr).all;\n+      return DT (T).Tag_Kind;\n    end Get_Tagged_Kind;\n \n    -----------------------------\n    -- Interface_Ancestor_Tags --\n    -----------------------------\n \n    function Interface_Ancestor_Tags (T : Tag) return Tag_Array is\n-      Iface_Table : Interface_Data_Ptr;\n+      TSD_Ptr     : constant Addr_Ptr :=\n+                      To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      TSD         : constant Type_Specific_Data_Ptr :=\n+                      To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+      Iface_Table : constant Interface_Data_Ptr := TSD.Interfaces_Table;\n \n    begin\n-      Iface_Table := To_Interface_Data_Ptr (TSD (T).Ifaces_Table_Ptr);\n-\n       if Iface_Table = null then\n          declare\n             Table : Tag_Array (1 .. 0);\n@@ -510,17 +566,67 @@ package body Ada.Tags is\n    -- Internal_Tag --\n    ------------------\n \n+   --  Internal tags have the following format:\n+   --    \"Internal tag at 16#ADDRESS#: <full-name-of-tagged-type>\"\n+\n+   Internal_Tag_Header : constant String    := \"Internal tag at \";\n+   Header_Separator    : constant Character := '#';\n+\n    function Internal_Tag (External : String) return Tag is\n       Ext_Copy : aliased String (External'First .. External'Last + 1);\n-      Res      : Tag;\n+      Res      : Tag := null;\n \n    begin\n-      --  Make a copy of the string representing the external tag with\n-      --  a null at the end.\n+      --  Handle locally defined tagged types\n+\n+      if External'Length > Internal_Tag_Header'Length\n+        and then\n+         External (External'First ..\n+                     External'First + Internal_Tag_Header'Length - 1)\n+           = Internal_Tag_Header\n+      then\n+         declare\n+            Addr_First : constant Natural :=\n+                           External'First + Internal_Tag_Header'Length;\n+            Addr_Last  : Natural;\n+            Addr       : Integer_Address;\n+\n+         begin\n+            --  Search the second separator (#) to identify the address\n+\n+            Addr_Last := Addr_First;\n+\n+            for J in 1 .. 2 loop\n+               while Addr_Last <= External'Last\n+                 and then External (Addr_Last) /= Header_Separator\n+               loop\n+                  Addr_Last := Addr_Last + 1;\n+               end loop;\n+\n+               --  Skip the first separator\n+\n+               if J = 1 then\n+                  Addr_Last := Addr_Last + 1;\n+               end if;\n+            end loop;\n+\n+            if Addr_Last <= External'Last then\n+               Addr :=\n+                 Integer_Address'Value (External (Addr_First .. Addr_Last));\n+               return To_Tag (Addr);\n+            end if;\n+         end;\n+\n+      --  Handle library-level tagged types\n+\n+      else\n+         --  Make a copy of the string representing the external tag with\n+         --  a null at the end.\n \n-      Ext_Copy (External'Range) := External;\n-      Ext_Copy (Ext_Copy'Last) := ASCII.NUL;\n-      Res := External_Tag_HTable.Get (Ext_Copy'Address);\n+         Ext_Copy (External'Range) := External;\n+         Ext_Copy (Ext_Copy'Last) := ASCII.NUL;\n+         Res := External_Tag_HTable.Get (Ext_Copy'Address);\n+      end if;\n \n       if Res = null then\n          declare\n@@ -546,32 +652,30 @@ package body Ada.Tags is\n      (Descendant : Tag;\n       Ancestor   : Tag) return Boolean\n    is\n+      D_TSD_Ptr : constant Addr_Ptr :=\n+                    To_Addr_Ptr (To_Address (Descendant)\n+                                   - DT_Typeinfo_Ptr_Size);\n+      A_TSD_Ptr : constant Addr_Ptr :=\n+                    To_Addr_Ptr (To_Address (Ancestor) - DT_Typeinfo_Ptr_Size);\n+      D_TSD     : constant Type_Specific_Data_Ptr :=\n+                    To_Type_Specific_Data_Ptr (D_TSD_Ptr.all);\n+      A_TSD     : constant Type_Specific_Data_Ptr :=\n+                    To_Type_Specific_Data_Ptr (A_TSD_Ptr.all);\n+\n    begin\n       return CW_Membership (Descendant, Ancestor)\n-        and then TSD (Descendant).Access_Level = TSD (Ancestor).Access_Level;\n+        and then D_TSD.Access_Level = A_TSD.Access_Level;\n    end Is_Descendant_At_Same_Level;\n \n-   -------------------\n-   -- Is_Primary_DT --\n-   -------------------\n-\n-   function Is_Primary_DT (T : Tag) return Boolean is\n-      Signature  : constant Storage_Offset_Ptr :=\n-                     To_Storage_Offset_Ptr (To_Address (T) - K_Signature);\n-      Sig_Values : constant Signature_Values :=\n-                     To_Signature_Values (Signature.all);\n-   begin\n-      return Sig_Values (2) = Primary_DT;\n-   end Is_Primary_DT;\n-\n    ------------\n    -- Length --\n    ------------\n \n    function Length (Str : Cstring_Ptr) return Natural is\n-      Len : Integer := 1;\n+      Len : Integer;\n \n    begin\n+      Len := 1;\n       while Str (Len) /= ASCII.Nul loop\n          Len := Len + 1;\n       end loop;\n@@ -584,31 +688,26 @@ package body Ada.Tags is\n    -------------------\n \n    function Offset_To_Top\n-     (This : System.Address) return System.Storage_Elements.Storage_Offset\n+     (This : System.Address) return SSE.Storage_Offset\n    is\n-      Curr_DT       : constant Tag := To_Tag_Ptr (This).all;\n-      Offset_To_Top : Storage_Offset_Ptr;\n-   begin\n-      Offset_To_Top := To_Storage_Offset_Ptr\n-                         (To_Address (Curr_DT) - K_Offset_To_Top);\n-\n-      if Offset_To_Top.all = SSE.Storage_Offset'Last then\n-         Offset_To_Top := To_Storage_Offset_Ptr (This + Tag_Size);\n-      end if;\n+      Tag_Size : constant SSE.Storage_Count :=\n+        SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n \n-      return Offset_To_Top.all;\n-   end Offset_To_Top;\n+      type Storage_Offset_Ptr is access SSE.Storage_Offset;\n+      function To_Storage_Offset_Ptr is\n+        new Unchecked_Conversion (System.Address, Storage_Offset_Ptr);\n \n-   ---------\n-   -- OSD --\n-   ---------\n+      Curr_DT : Dispatch_Table_Ptr;\n \n-   function OSD (T : Tag) return Object_Specific_Data_Ptr is\n-      OSD_Ptr : constant Addr_Ptr :=\n-                  To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n    begin\n-      return To_Object_Specific_Data_Ptr (OSD_Ptr.all);\n-   end OSD;\n+      Curr_DT := DT (To_Tag_Ptr (This).all);\n+\n+      if Curr_DT.Offset_To_Top = SSE.Storage_Offset'Last then\n+         return To_Storage_Offset_Ptr (This + Tag_Size).all;\n+      else\n+         return Curr_DT.Offset_To_Top;\n+      end if;\n+   end Offset_To_Top;\n \n    -----------------\n    -- Parent_Size --\n@@ -626,16 +725,28 @@ package body Ada.Tags is\n       --  The pointer to the _size primitive is always in the first slot of\n       --  the dispatch table.\n \n-      Parent_Tag : Tag;\n-      --  The tag of the parent type through the dispatch table\n-\n-      F : Acc_Size;\n+      TSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      TSD     : constant Type_Specific_Data_Ptr :=\n+                  To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+      --  Pointer to the TSD\n+\n+      Parent_Tag              : constant Tag := TSD.Tags_Table (Parent_Slot);\n+      Parent_Predef_Prims_Ptr : constant Addr_Ptr :=\n+                                  To_Addr_Ptr (To_Address (Parent_Tag)\n+                                                - DT_Predef_Prims_Offset);\n+      Parent_Predef_Prims     : constant Predef_Prims_Table_Ptr :=\n+                                  To_Predef_Prims_Table_Ptr\n+                                    (Parent_Predef_Prims_Ptr.all);\n+\n+      --  The tag of the parent type through the dispatch table and its\n+      --  Predef_Prims field.\n+\n+      F : constant Acc_Size :=\n+            To_Acc_Size (Parent_Predef_Prims (Size_Slot));\n       --  Access to the _size primitive of the parent\n \n    begin\n-      Parent_Tag := TSD (T).Tags_Table (Parent_Slot);\n-      F := To_Acc_Size (Predefined_DT (Parent_Tag).Prims_Ptr (Size_Slot));\n-\n       --  Here we compute the size of the _parent field of the object\n \n       return SSE.Storage_Count (F.all (Obj));\n@@ -646,50 +757,29 @@ package body Ada.Tags is\n    ----------------\n \n    function Parent_Tag (T : Tag) return Tag is\n+      TSD_Ptr : Addr_Ptr;\n+      TSD     : Type_Specific_Data_Ptr;\n+\n    begin\n       if T = No_Tag then\n          raise Tag_Error;\n       end if;\n \n+      TSD_Ptr := To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      TSD     := To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+\n       --  The Parent_Tag of a root-level tagged type is defined to be No_Tag.\n       --  The first entry in the Ancestors_Tags array will be null for such\n       --  a type, but it's better to be explicit about returning No_Tag in\n       --  this case.\n \n-      if TSD (T).Idepth = 0 then\n+      if TSD.Idepth = 0 then\n          return No_Tag;\n       else\n-         return TSD (T).Tags_Table (1);\n+         return TSD.Tags_Table (1);\n       end if;\n    end Parent_Tag;\n \n-   -------------------\n-   -- Predefined_DT --\n-   -------------------\n-\n-   function Predefined_DT (T : Tag) return Tag is\n-   begin\n-      return To_Tag (To_Address (T) - DT_Prologue_Size);\n-   end Predefined_DT;\n-\n-   ----------------------------\n-   -- Register_Interface_Tag --\n-   ----------------------------\n-\n-   procedure Register_Interface_Tag\n-     (T           : Tag;\n-      Interface_T : Tag;\n-      Position    : Positive)\n-   is\n-      New_T_TSD   : Type_Specific_Data_Ptr;\n-      Iface_Table : Interface_Data_Ptr;\n-\n-   begin\n-      New_T_TSD   := TSD (T);\n-      Iface_Table := To_Interface_Data_Ptr (New_T_TSD.Ifaces_Table_Ptr);\n-      Iface_Table.Ifaces_Table (Position).Iface_Tag := Interface_T;\n-   end Register_Interface_Tag;\n-\n    ------------------\n    -- Register_Tag --\n    ------------------\n@@ -712,86 +802,54 @@ package body Ada.Tags is\n       SSD (T).SSD_Table (Position).Index := Value;\n    end Set_Entry_Index;\n \n-   -------------------------\n-   -- Set_Interface_Table --\n-   -------------------------\n-\n-   procedure Set_Interface_Table (T : Tag; Value : System.Address) is\n-   begin\n-      TSD (T).Ifaces_Table_Ptr := Value;\n-   end Set_Interface_Table;\n-\n-   ----------------------\n-   -- Set_Offset_Index --\n-   ----------------------\n-\n-   procedure Set_Offset_Index\n-     (T        : Tag;\n-      Position : Positive;\n-      Value    : Positive)\n-   is\n-   begin\n-      OSD (T).OSD_Table (Position) := Value;\n-   end Set_Offset_Index;\n-\n    -----------------------\n    -- Set_Offset_To_Top --\n    -----------------------\n \n    procedure Set_Offset_To_Top\n-     (This          : System.Address;\n-      Interface_T   : Tag;\n-      Is_Static     : Boolean;\n-      Offset_Value  : System.Storage_Elements.Storage_Offset;\n-      Offset_Func   : System.Address)\n+     (This         : System.Address;\n+      Interface_T  : Tag;\n+      Is_Static    : Boolean;\n+      Offset_Value : SSE.Storage_Offset;\n+      Offset_Func  : Offset_To_Top_Function_Ptr)\n    is\n-      Prim_DT       : Tag;\n-      Sec_Base      : System.Address;\n-      Sec_DT        : Tag;\n-      Offset_To_Top : Storage_Offset_Ptr;\n-      Iface_Table   : Interface_Data_Ptr;\n-      Obj_TSD       : Type_Specific_Data_Ptr;\n-   begin\n-      if System.\"=\" (This, System.Null_Address) then\n-         Offset_To_Top :=\n-           To_Storage_Offset_Ptr (To_Address (Interface_T) - K_Offset_To_Top);\n-         Offset_To_Top.all := Offset_Value;\n-         return;\n-      end if;\n-\n-      --  \"This\" points to the primary DT and we must save Offset_Value in the\n-      --  Offset_To_Top field of the corresponding secondary dispatch table.\n-\n-      Prim_DT  := To_Tag_Ptr (This).all;\n+      Prim_DT     : Dispatch_Table_Ptr;\n+      Sec_Base    : System.Address;\n+      Sec_DT      : Dispatch_Table_Ptr;\n+      Iface_Table : Interface_Data_Ptr;\n \n-      --  Save the offset to top field in the secondary dispatch table.\n+   begin\n+      --  Save the offset to top field in the secondary dispatch table\n \n       if Offset_Value /= 0 then\n          Sec_Base := This + Offset_Value;\n-         Sec_DT   := To_Tag_Ptr (Sec_Base).all;\n-         Offset_To_Top :=\n-           To_Storage_Offset_Ptr (To_Address (Sec_DT) - K_Offset_To_Top);\n+         Sec_DT   := DT (To_Tag_Ptr (Sec_Base).all);\n \n          if Is_Static then\n-            Offset_To_Top.all := Offset_Value;\n+            Sec_DT.Offset_To_Top := Offset_Value;\n          else\n-            Offset_To_Top.all := SSE.Storage_Offset'Last;\n+            Sec_DT.Offset_To_Top := SSE.Storage_Offset'Last;\n          end if;\n       end if;\n \n-      --  Save Offset_Value in the table of interfaces of the primary DT. This\n-      --  data will be used by the subprogram \"Displace\" to give support to\n-      --  backward abstract interface type conversions.\n+      --  \"This\" points to the primary DT and we must save Offset_Value in\n+      --  the Offset_To_Top field of the corresponding secondary dispatch\n+      --  table.\n+\n+      Prim_DT     := DT (To_Tag_Ptr (This).all);\n+      Iface_Table := To_Type_Specific_Data_Ptr (Prim_DT.TSD).Interfaces_Table;\n \n-      Obj_TSD     := TSD (Prim_DT);\n-      Iface_Table := To_Interface_Data_Ptr (Obj_TSD.Ifaces_Table_Ptr);\n+      --  Save Offset_Value in the table of interfaces of the primary DT.\n+      --  This data will be used by the subprogram \"Displace\" to give support\n+      --  to backward abstract interface type conversions.\n \n       --  Register the offset in the table of interfaces\n \n       if Iface_Table /= null then\n          for Id in 1 .. Iface_Table.Nb_Ifaces loop\n             if Iface_Table.Ifaces_Table (Id).Iface_Tag = Interface_T then\n-               Iface_Table.Ifaces_Table (Id).Static_Offset_To_Top := Is_Static;\n+               Iface_Table.Ifaces_Table (Id).Static_Offset_To_Top :=\n+                 Is_Static;\n \n                if Is_Static then\n                   Iface_Table.Ifaces_Table (Id).Offset_To_Top_Value\n@@ -811,17 +869,6 @@ package body Ada.Tags is\n       raise Program_Error;\n    end Set_Offset_To_Top;\n \n-   -------------\n-   -- Set_OSD --\n-   -------------\n-\n-   procedure Set_OSD (T : Tag; Value : System.Address) is\n-      OSD_Ptr : constant Addr_Ptr :=\n-                  To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n-   begin\n-      OSD_Ptr.all := Value;\n-   end Set_OSD;\n-\n    ----------------------\n    -- Set_Prim_Op_Kind --\n    ----------------------\n@@ -835,70 +882,6 @@ package body Ada.Tags is\n       SSD (T).SSD_Table (Position).Kind := Value;\n    end Set_Prim_Op_Kind;\n \n-   -------------------\n-   -- Set_Signature --\n-   -------------------\n-\n-   procedure Set_Signature (T : Tag; Value : Signature_Kind) is\n-      Signature : constant System.Address := To_Address (T) - K_Signature;\n-      Sig_Ptr   : constant Signature_Values_Ptr :=\n-                    To_Signature_Values_Ptr (Signature);\n-   begin\n-      Sig_Ptr.all (1) := Valid_Signature;\n-      Sig_Ptr.all (2) := Value;\n-   end Set_Signature;\n-\n-   -------------\n-   -- Set_SSD --\n-   -------------\n-\n-   procedure Set_SSD (T : Tag; Value : System.Address) is\n-   begin\n-      TSD (T).SSD_Ptr := Value;\n-   end Set_SSD;\n-\n-   ---------------------\n-   -- Set_Tagged_Kind --\n-   ---------------------\n-\n-   procedure Set_Tagged_Kind (T : Tag; Value : Tagged_Kind) is\n-      Tagged_Kind_Ptr : constant System.Address :=\n-                          To_Address (T) - K_Tagged_Kind;\n-   begin\n-      To_Tagged_Kind_Ptr (Tagged_Kind_Ptr).all := Value;\n-   end Set_Tagged_Kind;\n-\n-   ---------\n-   -- SSD --\n-   ---------\n-\n-   function SSD (T : Tag) return Select_Specific_Data_Ptr is\n-   begin\n-      return To_Select_Specific_Data_Ptr (TSD (T).SSD_Ptr);\n-   end SSD;\n-\n-   ------------------\n-   -- Typeinfo_Ptr --\n-   ------------------\n-\n-   function Typeinfo_Ptr (T : Tag) return System.Address is\n-      TSD_Ptr : constant Addr_Ptr :=\n-                  To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n-   begin\n-      return TSD_Ptr.all;\n-   end Typeinfo_Ptr;\n-\n-   ---------\n-   -- TSD --\n-   ---------\n-\n-   function TSD (T : Tag) return Type_Specific_Data_Ptr is\n-      TSD_Ptr : constant Addr_Ptr :=\n-                  To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n-   begin\n-      return To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n-   end TSD;\n-\n    ------------------------\n    -- Wide_Expanded_Name --\n    ------------------------"}, {"sha": "538c3e97af265a3db7b0390c523bd8777fdf4e54", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 208, "deletions": 309, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=d0dd5209d981a9705ea87c5e86211e8f0709bb7c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -37,7 +37,7 @@\n \n with System;\n with System.Storage_Elements;\n-with Unchecked_Conversion;\n+with Ada.Unchecked_Conversion;\n \n package Ada.Tags is\n    pragma Preelaborate_05;\n@@ -83,18 +83,16 @@ package Ada.Tags is\n private\n    --  Structure of the GNAT Primary Dispatch Table\n \n-   --           +--------------------+\n-   --           |      table of      |\n-   --           :predefined primitive:\n-   --           |    ops pointers    |\n    --           +--------------------+\n    --           |      Signature     |\n    --           +--------------------+\n    --           |     Tagged_Kind    |\n-   --           +--------------------+\n-   --           |    Offset_To_Top   |\n-   --           +--------------------+\n-   --           |Typeinfo_Ptr/TSD_Ptr---> Type Specific Data\n+   --           +--------------------+                            Predef Prims\n+   --           |    Predef_Prims -----------------------------> +------------+\n+   --           +--------------------+                           |  table of  |\n+   --           |    Offset_To_Top   |                           | predefined |\n+   --           +--------------------+                           | primitives |\n+   --           |Typeinfo_Ptr/TSD_Ptr---> Type Specific Data     +------------+\n    --  Tag ---> +--------------------+   +-------------------+\n    --           |      table of      |   | inheritance depth |\n    --           :   primitive ops    :   +-------------------+\n@@ -110,16 +108,14 @@ private\n    --                                    +-------------------+\n    --                                    | rec ctrler offset |\n    --                                    +-------------------+\n-   --                                    |   num prim ops    |\n-   --                                    +-------------------+\n-   --                                    |  Ifaces_Table_Ptr --> Interface Data\n+   --                                    |   Ifaces_Table   ---> Interface Data\n    --                                    +-------------------+   +------------+\n-   --         Select Specific Data  <----     SSD_Ptr        |   |  table     |\n-   --         +------------------+       +-------------------+   :    of      :\n-   --         |table of primitive|       | table of          |   | interfaces |\n-   --         :   operation      :       :    ancestor       :   +------------+\n-   --         |      kinds       |       |       tags        |\n-   --         +------------------+       +-------------------+\n+   --         Select Specific Data  <----        SSD         |   |  Nb_Ifaces |\n+   --         +------------------+       +-------------------+   +------------+\n+   --         |table of primitive|       | table of          |   |  table     |\n+   --         :   operation      :       :    ancestor       :   :    of      :\n+   --         |      kinds       |       |       tags        |   | interfaces |\n+   --         +------------------+       +-------------------+   +------------+\n    --         |table of          |\n    --         :   entry          :\n    --         |      indices     |\n@@ -148,77 +144,88 @@ private\n    --                                          +---------------+\n \n    --  The runtime information kept for each tagged type is separated into two\n-   --  objects: the Dispatch Table and the Type Specific Data record. These\n-   --  two objects are allocated statically using the constants:\n-\n-   --      DT Size  = DT_Prologue_Size  + Nb_Prim * DT_Entry_Size\n-\n-   --  where Nb_prim is the number of primitive operations of the given\n-   --  type and Idepth its inheritance depth.\n-\n-   type Address_Array is array (Natural range <>) of System.Address;\n-   pragma Suppress (Index_Check, On => Address_Array);\n-   --  The reason we suppress index checks is that in the dispatch table,\n-   --  the component of this type is declared with a dummy size of 1, the\n-   --  actual size depending on the number of primitive operations.\n-\n-   type Dispatch_Table is record\n-\n-      --  According to the C++ ABI the components Offset_To_Top and\n-      --  Typeinfo_Ptr are stored just \"before\" the dispatch table (that is,\n-      --  the Prims_Ptr table), and they are referenced with negative offsets\n-      --  referring to the base of the dispatch table. The _Tag (or the\n-      --  VTable_Ptr in C++ terminology) must point to the base of the virtual\n-      --  table, just after these components, to point to the Prims_Ptr table.\n-      --  For this purpose the expander generates a Prims_Ptr table that has\n-      --  enough space for these additional components, and generates code that\n-      --  displaces the _Tag to point after these components.\n-\n-      --  Signature     : Signature_Kind;\n-      --  Tagged_Kind   : Tagged_Kind;\n-      --  Offset_To_Top : Natural;\n-      --  Typeinfo_Ptr  : System.Address;\n-\n-      Prims_Ptr : Address_Array (1 .. 1);\n-      --  The size of the Prims_Ptr array actually depends on the tagged type\n-      --  to which it applies. For each tagged type, the expander computes the\n-      --  actual array size, allocates the Dispatch_Table record accordingly,\n-      --  and generates code that displaces the base of the record after the\n-      --  Typeinfo_Ptr component. For this reason the first two components have\n-      --  been commented in the previous declaration. The access to these\n-      --  components is done by means of local functions.\n-      --\n-      --  To avoid the use of discriminants to define the actual size of the\n-      --  dispatch table, we used to declare the tag as a pointer to a record\n-      --  that contains an arbitrary array of addresses, using Positive as its\n-      --  index. This ensures that there are never range checks when accessing\n-      --  the dispatch table, but it prevents GDB from displaying tagged types\n-      --  properly. A better approach is to declare this record type as holding\n-      --  small number of addresses, and to explicitly suppress checks on it.\n-      --\n-      --  Note that in both cases, this type is never allocated, and serves\n-      --  only to declare the corresponding access type.\n-   end record;\n+   --  objects: the Dispatch Table and the Type Specific Data record.\n+\n+   package SSE renames System.Storage_Elements;\n \n    subtype Cstring is String (Positive);\n    type Cstring_Ptr is access all Cstring;\n    pragma No_Strict_Aliasing (Cstring_Ptr);\n \n-   --  We suppress index checks because the declared size in the record below\n-   --  is a dummy size of one (see below).\n+   --  Declarations for the table of interfaces\n \n-   type Tag_Table is array (Natural range <>) of Tag;\n-   pragma Suppress_Initialization (Tag_Table);\n-   pragma Suppress (Index_Check, On => Tag_Table);\n+   type Offset_To_Top_Function_Ptr is\n+     access function (This : System.Address) return SSE.Storage_Offset;\n+   --  Type definition used to call the function that is generated by the\n+   --  expander in case of tagged types with discriminants that have secondary\n+   --  dispatch tables. This function provides the Offset_To_Top value in this\n+   --  specific case.\n \n-   package SSE renames System.Storage_Elements;\n+   type Interface_Data_Element is record\n+      Iface_Tag            : Tag;\n+      Static_Offset_To_Top : Boolean;\n+      Offset_To_Top_Value  : SSE.Storage_Offset;\n+      Offset_To_Top_Func   : Offset_To_Top_Function_Ptr;\n+   end record;\n+   --  If some ancestor of the tagged type has discriminants the field\n+   --  Static_Offset_To_Top is False and the field Offset_To_Top_Func\n+   --  is used to store the access to the function generated by the\n+   --  expander which provides this value; otherwise Static_Offset_To_Top\n+   --  is True and such value is stored in the Offset_To_Top_Value field.\n \n-   --  Type specific data types\n+   type Interfaces_Array is array (Natural range <>) of Interface_Data_Element;\n+\n+   type Interface_Data (Nb_Ifaces : Positive) is record\n+      Ifaces_Table : Interfaces_Array (1 .. Nb_Ifaces);\n+   end record;\n+\n+   type Interface_Data_Ptr is access all Interface_Data;\n+   --  Table of abstract interfaces used to give support to backward interface\n+   --  conversions and also to IW_Membership.\n+\n+   --  Primitive operation kinds. These values differentiate the kinds of\n+   --  callable entities stored in the dispatch table. Certain kinds may\n+   --  not be used, but are added for completeness.\n+\n+   type Prim_Op_Kind is\n+     (POK_Function,\n+      POK_Procedure,\n+      POK_Protected_Entry,\n+      POK_Protected_Function,\n+      POK_Protected_Procedure,\n+      POK_Task_Entry,\n+      POK_Task_Function,\n+      POK_Task_Procedure);\n+\n+   --  Select specific data types\n+\n+   type Select_Specific_Data_Element is record\n+      Index : Positive;\n+      Kind  : Prim_Op_Kind;\n+   end record;\n+\n+   type Select_Specific_Data_Array is\n+     array (Positive range <>) of Select_Specific_Data_Element;\n+\n+   type Select_Specific_Data (Nb_Prim : Positive) is record\n+      SSD_Table : Select_Specific_Data_Array (1 .. Nb_Prim);\n+      --  NOTE: Nb_Prim is the number of non-predefined primitive operations\n+   end record;\n+\n+   type Select_Specific_Data_Ptr is access all Select_Specific_Data;\n+   --  A table used to store the primitive operation kind and entry index of\n+   --  primitive subprograms of a type that implements a limited interface.\n+   --  The Select Specific Data table resides in the Type Specific Data of a\n+   --  type. This construct is used in the handling of dispatching triggers\n+   --  in select statements.\n+\n+   type Tag_Table is array (Natural range <>) of Tag;\n \n    type Type_Specific_Data (Idepth : Natural) is record\n-      --  Inheritance Depth Level: Used to implement the membership test\n-      --  associated with single inheritance of tagged types in constant-time.\n-      --  It also indicates the size of the Tags_Table component.\n+   --  The discriminant Idepth is the Inheritance Depth Level: Used to\n+   --  implement the membership test associated with single inheritance of\n+   --  tagged types in constant-time. It also indicates the size of the\n+   --  Tags_Table component.\n \n       Access_Level : Natural;\n       --  Accessibility level required to give support to Ada 2005 nested type\n@@ -232,22 +239,29 @@ private\n       Expanded_Name : Cstring_Ptr;\n       External_Tag  : Cstring_Ptr;\n       HT_Link       : Tag;\n-      --  Components used to support to the Ada.Tags subprograms in RM 3.9.\n-      --  Note: Expanded_Name is referenced by GDB ???\n+      --  Components used to support to the Ada.Tags subprograms in RM 3.9\n+\n+      --  Note: Expanded_Name is referenced by GDB to determine the actual name\n+      --  of the tagged type. Its requirements are: 1) it must have this exact\n+      --  name, and 2) its contents must point to a C-style Nul terminated\n+      --  string containing its expanded name. GDB has no requirement on a\n+      --  given position inside the record.\n \n-      Remotely_Callable : Boolean;\n-      --  Used to check ARM E.4 (18)\n+      Transportable : Boolean;\n+      --  Used to check RM E.4(18), set for types that satisfy the requirements\n+      --  for being used in remote calls as actuals for classwide formals or as\n+      --  return values for classwide functions.\n \n       RC_Offset : SSE.Storage_Offset;\n       --  Controller Offset: Used to give support to tagged controlled objects\n       --  (see Get_Deep_Controller at s-finimp)\n \n-      Ifaces_Table_Ptr : System.Address;\n+      Interfaces_Table : Interface_Data_Ptr;\n       --  Pointer to the table of interface tags. It is used to implement the\n       --  membership test associated with interfaces and also for backward\n       --  abstract interface type conversions (Ada 2005:AI-251)\n \n-      SSD_Ptr : System.Address;\n+      SSD : Select_Specific_Data_Ptr;\n       --  Pointer to a table of records used in dispatching selects. This\n       --  field has a meaningful value for all tagged types that implement\n       --  a limited, protected, synchronized or task interfaces and have\n@@ -258,66 +272,14 @@ private\n       --  depth level of the tagged type.\n    end record;\n \n-   --  Declarations for the table of interfaces\n-\n-   type Interface_Data_Element is record\n-      Iface_Tag            : Tag;\n-      Static_Offset_To_Top : Boolean;\n-      Offset_To_Top_Value  : System.Storage_Elements.Storage_Offset;\n-      Offset_To_Top_Func   : System.Address;\n-   end record;\n-   --  If some ancestor of the tagged type has discriminants the field\n-   --  Static_Offset_To_Top is False and the field Offset_To_Top_Func\n-   --  is used to store the address of the function generated by the\n-   --  expander which provides this value; otherwise Static_Offset_To_Top\n-   --  is True and such value is stored in the Offset_To_Top_Value field.\n-\n-   type Interfaces_Array is\n-     array (Natural range <>) of Interface_Data_Element;\n-\n-   type Interface_Data (Nb_Ifaces : Positive) is record\n-      Ifaces_Table : Interfaces_Array (1 .. Nb_Ifaces);\n-   end record;\n-\n-   --  Declaration of tag types\n-\n-   type Tag is access all Dispatch_Table;\n-   type Tag_Ptr is access Tag;\n-   type Interface_Tag is access all Dispatch_Table;\n    type Type_Specific_Data_Ptr is access all Type_Specific_Data;\n \n-   No_Tag : constant Tag := null;\n+   --  Declarations for the dispatch table record\n \n-   type Interface_Data_Ptr is access all Interface_Data;\n-   --  Table of abstract interfaces used to give support to backward interface\n-   --  conversions and also to IW_Membership.\n-\n-   type Object_Specific_Data (Nb_Prim : Positive);\n-   type Object_Specific_Data_Ptr is access all Object_Specific_Data;\n-   --  Information associated with the secondary dispatch table of tagged-type\n-   --  objects implementing abstract interfaces.\n-\n-   type Select_Specific_Data (Nb_Prim : Positive);\n-   type Select_Specific_Data_Ptr is access all Select_Specific_Data;\n-   --  A table used to store the primitive operation kind and entry index of\n-   --  primitive subprograms of a type that implements a limited interface.\n-   --  The Select Specific Data table resides in the Type Specific Data of a\n-   --  type. This construct is used in the handling of dispatching triggers\n-   --  in select statements.\n-\n-   --  Primitive operation kinds. These values differentiate the kinds of\n-   --  callable entities stored in the dispatch table. Certain kinds may\n-   --  not be used, but are added for completeness.\n-\n-   type Prim_Op_Kind is\n-     (POK_Function,\n-      POK_Procedure,\n-      POK_Protected_Entry,\n-      POK_Protected_Function,\n-      POK_Protected_Procedure,\n-      POK_Task_Entry,\n-      POK_Task_Function,\n-      POK_Task_Procedure);\n+   type Signature_Kind is\n+      (Unknown,\n+       Primary_DT,\n+       Secondary_DT);\n \n    --  Tagged type kinds with respect to concurrency and limitedness\n \n@@ -329,53 +291,66 @@ private\n       TK_Tagged,\n       TK_Task);\n \n-   type Tagged_Kind_Ptr is access all Tagged_Kind;\n+   type Address_Array is array (Positive range <>) of System.Address;\n+\n+   type Dispatch_Table_Wrapper (Num_Prims : Natural) is record\n+      Signature     : Signature_Kind;\n+      Tag_Kind      : Tagged_Kind;\n+      Predef_Prims  : System.Address;\n+      --  Pointer to the dispatch table of predefined Ada primitives\n+\n+      --  According to the C++ ABI the components Offset_To_Top and TSD are\n+      --  stored just \"before\" the dispatch table, and they are referenced with\n+      --  negative offsets referring to the base of the dispatch table. The\n+      --   _Tag (or the VTable_Ptr in C++ terminology) must point to the base\n+      --  of the virtual table, just after these components, to point to the\n+      --  Prims_Ptr table.\n+\n+      Offset_To_Top : SSE.Storage_Offset;\n+      TSD           : System.Address;\n+\n+      Prims_Ptr : aliased Address_Array (1 .. Num_Prims);\n+      --  The size of the Prims_Ptr array actually depends on the tagged type\n+      --  to which it applies. For each tagged type, the expander computes the\n+      --  actual array size, allocates the Dispatch_Table record accordingly.\n+   end record;\n+\n+   subtype Dispatch_Table is Address_Array (1 .. 1);\n+   --  Used by GDB to identify the _tags and traverse the run-time structure\n+   --  associated with tagged types. For compatibility with older versions of\n+   --  gdb, its name must not be changed.\n+\n+   type Tag is access all Dispatch_Table;\n+   type Interface_Tag is access all Dispatch_Table;\n+\n+   No_Tag : constant Tag := null;\n+\n+   --  The expander ensures that Tag objects reference the Prims_Ptr component\n+   --  of the wrapper.\n+\n+   type Tag_Ptr is access all Tag;\n+   type Dispatch_Table_Ptr is access all Dispatch_Table_Wrapper;\n+\n+   --  The following type declaration is used by the compiler when the program\n+   --  is compiled with restriction No_Dispatching_Calls. It is also used with\n+   --  interface types to generate the tag and run-time information associated\n+   --  with them.\n+\n+   type No_Dispatch_Table_Wrapper is record\n+      NDT_TSD       : System.Address;\n+      NDT_Prims_Ptr : Natural;\n+   end record;\n \n    Default_Prim_Op_Count : constant Positive := 15;\n-   --  Maximum number of predefined primitive operations of a tagged type.\n+   --  Number of predefined ada primitives: Size, Alignment, Read, Write,\n+   --  Input, Output, \"=\", assignment, deep adjust, deep finalize, async\n+   --  select, conditional select, prim_op kind, task_id, and timed select.\n \n-   type Signature_Kind is\n-      (Unknown,\n-       Valid_Signature,\n-       Primary_DT,\n-       Secondary_DT,\n-       Abstract_Interface);\n-   for Signature_Kind'Size use 8;\n-   --  Kind of signature found in the header of the dispatch table. These\n-   --  signatures are generated by the frontend and are used by the Check_XXX\n-   --  routines to ensure that the kind of dispatch table managed by each of\n-   --  the routines in this package is correct. This additional check is only\n-   --  performed with this run-time package is compiled with assertions enabled\n-\n-   --  The signature is a sequence of two bytes. The first byte must have the\n-   --  value Valid_Signature, and the second byte must have a value in the\n-   --  range Primary_DT .. Abstract_Interface. The Unknown value is used by\n-   --  the Check_XXX routines to indicate that the signature is wrong.\n-\n-   DT_Min_Prologue_Size : constant SSE.Storage_Count :=\n+   DT_Predef_Prims_Size : constant SSE.Storage_Count :=\n                             SSE.Storage_Count\n-                              (2 * (Standard'Address_Size /\n+                              (1 * (Standard'Address_Size /\n                                       System.Storage_Unit));\n-   --  Size of the hidden part of the dispatch table used when the program\n-   --  is compiled under restriction No_Dispatching_Calls. It contains the\n-   --  pointer to the TSD record plus a dummy entry whose address is used\n-   --  at run-time as the Tag.\n-\n-   DT_Prologue_Size : constant SSE.Storage_Count :=\n-                        SSE.Storage_Count\n-                          ((Default_Prim_Op_Count + 4) *\n-                            (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of the hidden part of the dispatch table. It contains the table of\n-   --  predefined primitive operations plus the C++ ABI header.\n-\n-   DT_Signature_Size : constant SSE.Storage_Count :=\n-                         SSE.Storage_Count\n-                           (1 * (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of the Signature field of the dispatch table\n-\n-   DT_Tagged_Kind_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of the Tagged_Type_Kind field of the dispatch table\n+   --  Size of the Predef_Prims field of the Dispatch_Table\n \n    DT_Offset_To_Top_Size : constant SSE.Storage_Count :=\n                              SSE.Storage_Count\n@@ -389,28 +364,27 @@ private\n                                       System.Storage_Unit));\n    --  Size of the Typeinfo_Ptr field of the Dispatch Table\n \n-   DT_Entry_Size : constant SSE.Storage_Count :=\n-                     SSE.Storage_Count\n-                       (1 * (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of each primitive operation entry in the Dispatch Table\n-\n-   Tag_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of each tag\n-\n-   --  Constants used by the code generated by the frontend to get access\n-   --  to the header of the dispatch table.\n-\n-   K_Typeinfo      : constant SSE.Storage_Count := DT_Typeinfo_Ptr_Size;\n-   K_Offset_To_Top : constant SSE.Storage_Count :=\n-                       System.Storage_Elements.\"+\"\n-                         (K_Typeinfo, DT_Offset_To_Top_Size);\n-   K_Tagged_Kind   : constant SSE.Storage_Count :=\n-                       System.Storage_Elements.\"+\"\n-                         (K_Offset_To_Top, DT_Tagged_Kind_Size);\n-   K_Signature     : constant SSE.Storage_Count :=\n-                       System.Storage_Elements.\"+\"\n-                         (K_Tagged_Kind, DT_Signature_Size);\n+   use type System.Storage_Elements.Storage_Offset;\n+\n+   DT_Predef_Prims_Offset : constant SSE.Storage_Count :=\n+                              DT_Typeinfo_Ptr_Size\n+                                + DT_Offset_To_Top_Size\n+                                + DT_Predef_Prims_Size;\n+   --  Offset from Prims_Ptr to Predef_Prims component\n+\n+   --  Object Specific Data record of secondary dispatch tables\n+\n+   type Object_Specific_Data_Array is array (Positive range <>) of Positive;\n+\n+   type Object_Specific_Data (OSD_Num_Prims : Positive) is record\n+      OSD_Table : Object_Specific_Data_Array (1 .. OSD_Num_Prims);\n+      --  Table used in secondary DT to reference their counterpart in the\n+      --  select specific data (in the TSD of the primary DT). This construct\n+      --  is used in the handling of dispatching triggers in select statements.\n+      --  Nb_Prim is the number of non-predefined primitive operations.\n+   end record;\n+\n+   type Object_Specific_Data_Ptr is access all Object_Specific_Data;\n \n    --  The following subprogram specifications are placed here instead of\n    --  the package body to see them from the frontend through rtsfind.\n@@ -419,21 +393,17 @@ private\n    --  Ada 2005 (AI-251): Displace \"This\" to point to the base address of\n    --  the object (that is, the address of the primary tag of the object).\n \n-   function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean;\n-   --  Given the tag of an object and the tag associated to a type, return\n-   --  true if Obj is in Typ'Class.\n-\n    function Displace (This : System.Address; T : Tag) return System.Address;\n    --  Ada 2005 (AI-251): Displace \"This\" to point to the secondary dispatch\n    --  table of T.\n \n+   function DT (T : Tag) return Dispatch_Table_Ptr;\n+   --  Return the pointer to the TSD record associated with T\n+\n    function Get_Entry_Index (T : Tag; Position : Positive) return Positive;\n    --  Ada 2005 (AI-251): Return a primitive operation's entry index (if entry)\n    --  given a dispatch table T and a position of a primitive operation in T.\n \n-   function Get_External_Tag (T : Tag) return System.Address;\n-   --  Returns address of a null terminated string containing the external name\n-\n    function Get_Offset_Index\n      (T        : Tag;\n       Position : Positive) return Positive;\n@@ -450,7 +420,7 @@ private\n \n    function Get_RC_Offset (T : Tag) return SSE.Storage_Offset;\n    --  Return the Offset of the implicit record controller when the object\n-   --  has controlled components. O otherwise.\n+   --  has controlled components, returns zero if no controlled components.\n \n    pragma Export (Ada, Get_RC_Offset, \"ada__tags__get_rc_offset\");\n    --  This procedure is used in s-finimp to compute the deep routines\n@@ -477,17 +447,12 @@ private\n    --      end Test;\n \n    function Offset_To_Top\n-     (This : System.Address) return System.Storage_Elements.Storage_Offset;\n+     (This : System.Address) return SSE.Storage_Offset;\n    --  Ada 2005 (AI-251): Returns the current value of the offset_to_top\n    --  component available in the prologue of the dispatch table. If the parent\n    --  of the tagged type has discriminants this value is stored in a record\n    --  component just immediately after the tag component.\n \n-   function OSD (T : Tag) return Object_Specific_Data_Ptr;\n-   --  Ada 2005 (AI-251): Given a pointer T to a secondary dispatch table,\n-   --  retrieve the address of the record containing the Object Specific\n-   --  Data table.\n-\n    function Parent_Size\n      (Obj : System.Address;\n       T   : Tag) return SSE.Storage_Count;\n@@ -499,14 +464,6 @@ private\n    pragma Export (Ada, Parent_Size, \"ada__tags__parent_size\");\n    --  This procedure is used in s-finimp and is thus exported manually\n \n-   procedure Register_Interface_Tag\n-     (T           : Tag;\n-      Interface_T : Tag;\n-      Position    : Positive);\n-   --  Ada 2005 (AI-251): Used to initialize the table of interfaces\n-   --  implemented by a type. Required to give support to backward interface\n-   --  conversions and also to IW_Membership.\n-\n    procedure Register_Tag (T : Tag);\n    --  Insert the Tag and its associated external_tag in a table for the\n    --  sake of Internal_Tag\n@@ -515,23 +472,12 @@ private\n    --  Ada 2005 (AI-345): Set the entry index of a primitive operation in T's\n    --  TSD table indexed by Position.\n \n-   procedure Set_Interface_Table (T : Tag; Value : System.Address);\n-   --  Ada 2005 (AI-251): Given a pointer T to a dispatch Table, stores the\n-   --  pointer to the table of interfaces.\n-\n-   procedure Set_Offset_Index\n-     (T        : Tag;\n-      Position : Positive;\n-      Value    : Positive);\n-   --  Ada 2005 (AI-345): Set the offset value of a primitive operation in a\n-   --  secondary dispatch table denoted by T, indexed by Position.\n-\n    procedure Set_Offset_To_Top\n      (This         : System.Address;\n       Interface_T  : Tag;\n       Is_Static    : Boolean;\n-      Offset_Value : System.Storage_Elements.Storage_Offset;\n-      Offset_Func  : System.Address);\n+      Offset_Value : SSE.Storage_Offset;\n+      Offset_Func  : Offset_To_Top_Function_Ptr);\n    --  Ada 2005 (AI-251): Initialize the Offset_To_Top field in the prologue of\n    --  the dispatch table. In primary dispatch tables the value of \"This\" is\n    --  not required (and the compiler passes always the Null_Address value) and\n@@ -541,106 +487,59 @@ private\n    --  distance from \"This\" to the object component containing the tag of the\n    --  secondary dispatch table.\n \n-   procedure Set_OSD (T : Tag; Value : System.Address);\n-   --  Ada 2005 (AI-251): Given a pointer T to a secondary dispatch table,\n-   --  store the pointer to the record containing the Object Specific Data\n-   --  generated by GNAT.\n-\n    procedure Set_Prim_Op_Kind\n      (T        : Tag;\n       Position : Positive;\n       Value    : Prim_Op_Kind);\n    --  Ada 2005 (AI-251): Set the kind of a primitive operation in T's TSD\n    --  table indexed by Position.\n \n-   procedure Set_Signature (T : Tag; Value : Signature_Kind);\n-   --  Given a pointer T to a dispatch table, store the signature id\n-\n-   procedure Set_SSD (T : Tag; Value : System.Address);\n-   --  Ada 2005 (AI-345): Given a pointer T to a dispatch Table, stores the\n-   --  pointer to the record containing the Select Specific Data generated by\n-   --  GNAT.\n-\n-   procedure Set_Tagged_Kind (T : Tag; Value : Tagged_Kind);\n-   --  Ada 2005 (AI-345): Set the tagged kind of a type in either a primary or\n-   --  a secondary dispatch table denoted by T.\n-\n-   function SSD (T : Tag) return Select_Specific_Data_Ptr;\n-   --  Ada 2005 (AI-251): Given a pointer T to a dispatch Table, retrieves the\n-   --  address of the record containing the Select Specific Data in T's TSD.\n-\n-   function TSD (T : Tag) return Type_Specific_Data_Ptr;\n-   --  Given a pointer T to a dispatch Table, retrieves the address of the\n-   --  record containing the Type Specific Data generated by GNAT.\n-\n    --  Unchecked Conversions\n \n-   type Addr_Ptr is access System.Address;\n+   Max_Predef_Prims : constant Natural := 16;\n+   --  Compiler should check this constant is OK ???\n \n-   type Signature_Values is\n-      array (1 .. DT_Signature_Size) of Signature_Kind;\n-   --  Type used to see the signature as a sequence of Signature_Kind values\n+   subtype Predef_Prims_Table  is Address_Array (1 .. Max_Predef_Prims);\n+   type Predef_Prims_Table_Ptr is access Predef_Prims_Table;\n \n-   type Signature_Values_Ptr is access all Signature_Values;\n+   type Addr_Ptr is access System.Address;\n \n    function To_Addr_Ptr is\n-      new Unchecked_Conversion (System.Address, Addr_Ptr);\n-\n-   function To_Type_Specific_Data_Ptr is\n-     new Unchecked_Conversion (System.Address, Type_Specific_Data_Ptr);\n+      new Ada.Unchecked_Conversion (System.Address, Addr_Ptr);\n \n    function To_Address is\n-     new Unchecked_Conversion (Tag, System.Address);\n+     new Ada.Unchecked_Conversion (Tag, System.Address);\n \n-   function To_Interface_Data_Ptr is\n-     new Unchecked_Conversion (System.Address, Interface_Data_Ptr);\n+   function To_Dispatch_Table_Ptr is\n+      new Ada.Unchecked_Conversion (Tag, Dispatch_Table_Ptr);\n \n-   function To_Object_Specific_Data_Ptr is\n-     new Unchecked_Conversion (System.Address, Object_Specific_Data_Ptr);\n-\n-   function To_Select_Specific_Data_Ptr is\n-     new Unchecked_Conversion (System.Address, Select_Specific_Data_Ptr);\n-\n-   function To_Signature_Values is\n-     new Unchecked_Conversion (System.Storage_Elements.Storage_Offset,\n-                               Signature_Values);\n+   function To_Dispatch_Table_Ptr is\n+      new Ada.Unchecked_Conversion (System.Address, Dispatch_Table_Ptr);\n \n-   function To_Signature_Values_Ptr is\n-     new Unchecked_Conversion (System.Address,\n-                               Signature_Values_Ptr);\n+   function To_Object_Specific_Data_Ptr is\n+     new Ada.Unchecked_Conversion (System.Address, Object_Specific_Data_Ptr);\n \n-   function To_Tag is\n-     new Unchecked_Conversion (System.Address, Tag);\n+   function To_Predef_Prims_Table_Ptr is\n+      new Ada.Unchecked_Conversion (System.Address, Predef_Prims_Table_Ptr);\n \n    function To_Tag_Ptr is\n-     new Unchecked_Conversion (System.Address, Tag_Ptr);\n+     new Ada.Unchecked_Conversion (System.Address, Tag_Ptr);\n \n-   function To_Tagged_Kind_Ptr is\n-     new Unchecked_Conversion (System.Address, Tagged_Kind_Ptr);\n+   function To_Type_Specific_Data_Ptr is\n+     new Ada.Unchecked_Conversion (System.Address, Type_Specific_Data_Ptr);\n \n-   --  Primitive dispatching operations are always inlined, to facilitate\n-   --  use in a minimal/no run-time environment for high integrity use.\n+   --  Primitive dispatching operations are always inlined, to facilitate use\n+   --  in a minimal/no run-time environment for high integrity use.\n \n-   pragma Inline_Always (CW_Membership);\n    pragma Inline_Always (Displace);\n    pragma Inline_Always (IW_Membership);\n    pragma Inline_Always (Get_Entry_Index);\n    pragma Inline_Always (Get_Offset_Index);\n    pragma Inline_Always (Get_Prim_Op_Kind);\n    pragma Inline_Always (Get_Tagged_Kind);\n-   pragma Inline_Always (OSD);\n-   pragma Inline_Always (Register_Interface_Tag);\n    pragma Inline_Always (Register_Tag);\n    pragma Inline_Always (Set_Entry_Index);\n-   pragma Inline_Always (Set_Interface_Table);\n-   pragma Inline_Always (Set_Offset_Index);\n    pragma Inline_Always (Set_Offset_To_Top);\n    pragma Inline_Always (Set_Prim_Op_Kind);\n-   pragma Inline_Always (Set_Signature);\n-   pragma Inline_Always (Set_OSD);\n-   pragma Inline_Always (Set_SSD);\n-   pragma Inline_Always (Set_Tagged_Kind);\n-   pragma Inline_Always (SSD);\n-   pragma Inline_Always (TSD);\n \n end Ada.Tags;"}, {"sha": "54bf33fb02f522e3e1cbb5d2bdfa0735ef209fe2", "filename": "gcc/ada/exp_atag.adb", "status": "modified", "additions": 262, "deletions": 476, "changes": 738, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fexp_atag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fexp_atag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.adb?ref=d0dd5209d981a9705ea87c5e86211e8f0709bb7c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2006-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,50 +24,123 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Atree;    use Atree;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Exp_Util; use Exp_Util;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Rtsfind;  use Rtsfind;\n-with Sinfo;    use Sinfo;\n+with Stand;    use Stand;\n with Snames;   use Snames;\n with Tbuild;   use Tbuild;\n-with Uintp;    use Uintp;\n \n package body Exp_Atag is\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   function Build_Predefined_DT\n+   function Build_DT\n      (Loc      : Source_Ptr;\n       Tag_Node : Node_Id) return Node_Id;\n-   --  Build code that displaces the Tag to reference the dispatch table\n-   --  containing the predefined primitives.\n+   --  Build code that displaces the Tag to reference the base of the wrapper\n+   --  record\n    --\n-   --  Generates: To_Tag (To_Address (Tag_Node) - DT_Prologue_Size);\n-   pragma Inline (Build_Predefined_DT);\n-\n-   function Build_Typeinfo_Offset (Loc : Source_Ptr) return Node_Id;\n-   --  Build code that gives access to the distance from the tag to the\n-   --  Typeinfo component of the dispatch table.\n-   --\n-   --  Generates: DT_Typeinfo_Ptr_Size\n-   pragma Inline (Build_Typeinfo_Offset);\n+   --  Generates:\n+   --    To_Dispatch_Table_Ptr\n+   --      (To_Address (Tag_Node) - Tag_Node.Prims_Ptr'Position);\n \n    function Build_TSD (Loc : Source_Ptr; Tag_Node : Node_Id) return Node_Id;\n    --  Build code that retrieves the address of the record containing the Type\n    --  Specific Data generated by GNAT.\n    --\n    --  Generate: To_Type_Specific_Data_Ptr\n-   --              (To_Address_Ptr (To_Address (Tag) - Typeinfo_Offset).all);\n-   pragma Inline (Build_TSD);\n+   --              (To_Addr_Ptr (To_Address (Tag) - Typeinfo_Offset).all);\n+\n+   function Build_Predef_Prims\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id) return Node_Id;\n+   --  Build code that retrieves the address of the dispatch table containing\n+   --  the predefined Ada primitives:\n+   --\n+   --  Generate: To_Predef_Prims_Table_Ptr\n+   --              (To_Addr_Ptr (To_Address (Tag) - Predef_Prims_Offset).all);\n+\n+   ------------------------------------------------\n+   -- Build_Common_Dispatching_Select_Statements --\n+   ------------------------------------------------\n \n-   function RTE_Tag_Node return Entity_Id;\n-   --  Returns the entity associated with Ada.Tags.Tag\n-   pragma Inline (RTE_Tag_Node);\n+   procedure Build_Common_Dispatching_Select_Statements\n+     (Loc    : Source_Ptr;\n+      DT_Ptr : Entity_Id;\n+      Stmts  : List_Id)\n+   is\n+   begin\n+      --  Generate:\n+      --    C := get_prim_op_kind (tag! (<type>VP), S);\n+\n+      --  where C is the out parameter capturing the call kind and S is the\n+      --  dispatch table slot number.\n+\n+      Append_To (Stmts,\n+        Make_Assignment_Statement (Loc,\n+          Name =>\n+            Make_Identifier (Loc, Name_uC),\n+          Expression =>\n+            Make_Function_Call (Loc,\n+              Name => New_Occurrence_Of (RTE (RE_Get_Prim_Op_Kind), Loc),\n+              Parameter_Associations => New_List (\n+                Unchecked_Convert_To (RTE (RE_Tag),\n+                  New_Reference_To (DT_Ptr, Loc)),\n+                Make_Identifier (Loc, Name_uS)))));\n+\n+      --  Generate:\n+\n+      --    if C = POK_Procedure\n+      --      or else C = POK_Protected_Procedure\n+      --      or else C = POK_Task_Procedure;\n+      --    then\n+      --       F := True;\n+      --       return;\n+\n+      --  where F is the out parameter capturing the status of a potential\n+      --  entry call.\n+\n+      Append_To (Stmts,\n+        Make_If_Statement (Loc,\n+\n+          Condition =>\n+            Make_Or_Else (Loc,\n+              Left_Opnd =>\n+                Make_Op_Eq (Loc,\n+                  Left_Opnd =>\n+                    Make_Identifier (Loc, Name_uC),\n+                  Right_Opnd =>\n+                    New_Reference_To (RTE (RE_POK_Procedure), Loc)),\n+              Right_Opnd =>\n+                Make_Or_Else (Loc,\n+                  Left_Opnd =>\n+                    Make_Op_Eq (Loc,\n+                      Left_Opnd =>\n+                        Make_Identifier (Loc, Name_uC),\n+                      Right_Opnd =>\n+                        New_Reference_To (RTE (\n+                          RE_POK_Protected_Procedure), Loc)),\n+                  Right_Opnd =>\n+                    Make_Op_Eq (Loc,\n+                      Left_Opnd =>\n+                        Make_Identifier (Loc, Name_uC),\n+                      Right_Opnd =>\n+                        New_Reference_To (RTE (\n+                          RE_POK_Task_Procedure), Loc)))),\n+\n+          Then_Statements =>\n+            New_List (\n+              Make_Assignment_Statement (Loc,\n+                Name       => Make_Identifier (Loc, Name_uF),\n+                Expression => New_Reference_To (Standard_True, Loc)),\n+              Make_Return_Statement (Loc))));\n+   end Build_Common_Dispatching_Select_Statements;\n \n    -------------------------\n    -- Build_CW_Membership --\n@@ -103,27 +176,42 @@ package body Exp_Atag is\n    begin\n       return\n         Make_And_Then (Loc,\n-           Left_Opnd =>\n-             Make_Op_Ge (Loc,\n-               Left_Opnd  => Build_Pos,\n-               Right_Opnd => Make_Integer_Literal (Loc, Uint_0)),\n-\n-           Right_Opnd =>\n-             Make_Op_Eq (Loc,\n-               Left_Opnd =>\n-                 Make_Indexed_Component (Loc,\n-                   Prefix =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix => Build_TSD (Loc, Obj_Tag_Node),\n-                       Selector_Name =>\n-                         New_Reference_To\n-                           (RTE_Record_Component (RE_Tags_Table), Loc)),\n-                   Expressions =>\n-                     New_List (Build_Pos)),\n-\n-               Right_Opnd => Typ_Tag_Node));\n+          Left_Opnd =>\n+            Make_Op_Ge (Loc,\n+              Left_Opnd  => Build_Pos,\n+              Right_Opnd => Make_Integer_Literal (Loc, Uint_0)),\n+\n+          Right_Opnd =>\n+            Make_Op_Eq (Loc,\n+              Left_Opnd =>\n+                Make_Indexed_Component (Loc,\n+                  Prefix =>\n+                    Make_Selected_Component (Loc,\n+                      Prefix => Build_TSD (Loc, Obj_Tag_Node),\n+                      Selector_Name =>\n+                        New_Reference_To\n+                          (RTE_Record_Component (RE_Tags_Table), Loc)),\n+                  Expressions =>\n+                    New_List (Build_Pos)),\n+\n+              Right_Opnd => Typ_Tag_Node));\n    end Build_CW_Membership;\n \n+   --------------\n+   -- Build_DT --\n+   --------------\n+\n+   function Build_DT\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id) return Node_Id is\n+   begin\n+      return\n+        Make_Function_Call (Loc,\n+          Name => New_Reference_To (RTE (RE_DT), Loc),\n+          Parameter_Associations => New_List (\n+            Unchecked_Convert_To (RTE (RE_Tag), Tag_Node)));\n+   end Build_DT;\n+\n    ----------------------------\n    -- Build_Get_Access_Level --\n    ----------------------------\n@@ -146,125 +234,18 @@ package body Exp_Atag is\n    ------------------------------------------\n \n    function Build_Get_Predefined_Prim_Op_Address\n-     (Loc           : Source_Ptr;\n-      Tag_Node      : Node_Id;\n-      Position_Node : Node_Id) return Node_Id\n-   is\n-   begin\n-      return\n-         Make_Indexed_Component (Loc,\n-           Prefix =>\n-             Make_Selected_Component (Loc,\n-               Prefix =>\n-                 Build_Predefined_DT (Loc, Tag_Node),\n-\n-               Selector_Name =>\n-                 New_Reference_To\n-                   (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n-\n-           Expressions =>\n-             New_List (Position_Node));\n-   end Build_Get_Predefined_Prim_Op_Address;\n-\n-   -------------------------------\n-   -- Build_Get_Prim_Op_Address --\n-   -------------------------------\n-\n-   function Build_Get_Prim_Op_Address\n-     (Loc           : Source_Ptr;\n-      Tag_Node      : Node_Id;\n-      Position_Node : Node_Id) return Node_Id\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id;\n+      Position : Uint) return Node_Id\n    is\n    begin\n       return\n         Make_Indexed_Component (Loc,\n           Prefix =>\n-            Make_Selected_Component (Loc,\n-              Prefix =>\n-                Unchecked_Convert_To\n-                  (RTE_Tag_Node, Tag_Node),\n-              Selector_Name =>\n-                New_Reference_To\n-                  (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n-\n-          Expressions => New_List (Position_Node));\n-   end Build_Get_Prim_Op_Address;\n-\n-   -------------------------\n-   -- Build_Get_RC_Offset --\n-   -------------------------\n-\n-   function Build_Get_RC_Offset\n-     (Loc      : Source_Ptr;\n-      Tag_Node : Node_Id) return Node_Id\n-   is\n-   begin\n-      return\n-        Make_Selected_Component (Loc,\n-          Prefix => Build_TSD (Loc, Tag_Node),\n-          Selector_Name =>\n-            New_Reference_To\n-              (RTE_Record_Component (RE_RC_Offset), Loc));\n-   end Build_Get_RC_Offset;\n-\n-   ---------------------------------\n-   -- Build_Get_Remotely_Callable --\n-   ---------------------------------\n-\n-   function Build_Get_Remotely_Callable\n-     (Loc      : Source_Ptr;\n-      Tag_Node : Node_Id) return Node_Id\n-   is\n-   begin\n-      return\n-        Make_Selected_Component (Loc,\n-          Prefix => Build_TSD (Loc, Tag_Node),\n-          Selector_Name =>\n-            New_Reference_To\n-              (RTE_Record_Component (RE_Remotely_Callable), Loc));\n-   end Build_Get_Remotely_Callable;\n-\n-   ------------------------------------\n-   -- Build_Inherit_Predefined_Prims --\n-   ------------------------------------\n-\n-   function Build_Inherit_Predefined_Prims\n-     (Loc          : Source_Ptr;\n-      Old_Tag_Node : Node_Id;\n-      New_Tag_Node : Node_Id) return Node_Id\n-   is\n-   begin\n-      return\n-        Make_Assignment_Statement (Loc,\n-          Name =>\n-            Make_Slice (Loc,\n-              Prefix =>\n-                Make_Selected_Component (Loc,\n-                  Prefix =>\n-                    Build_Predefined_DT (Loc, New_Tag_Node),\n-                  Selector_Name =>\n-                    New_Reference_To\n-                      (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n-\n-              Discrete_Range => Make_Range (Loc,\n-                Make_Integer_Literal (Loc, Uint_1),\n-                New_Reference_To (RTE (RE_Default_Prim_Op_Count), Loc))),\n-\n-          Expression =>\n-            Make_Slice (Loc,\n-              Prefix =>\n-                Make_Selected_Component (Loc,\n-                  Prefix        => Build_Predefined_DT (Loc, Old_Tag_Node),\n-                  Selector_Name =>\n-                    New_Reference_To\n-                      (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n-              Discrete_Range =>\n-                Make_Range (Loc,\n-                  Low_Bound  => Make_Integer_Literal (Loc, 1),\n-                  High_Bound =>\n-                    New_Reference_To (RTE (RE_Default_Prim_Op_Count), Loc))));\n-\n-   end Build_Inherit_Predefined_Prims;\n+            Build_Predef_Prims (Loc, Tag_Node),\n+          Expressions =>\n+            New_List (Make_Integer_Literal (Loc, Position)));\n+   end Build_Get_Predefined_Prim_Op_Address;\n \n    -------------------------\n    -- Build_Inherit_Prims --\n@@ -284,7 +265,7 @@ package body Exp_Atag is\n               Prefix =>\n                 Make_Selected_Component (Loc,\n                   Prefix =>\n-                    Unchecked_Convert_To (RTE_Tag_Node, New_Tag_Node),\n+                    Build_DT (Loc, New_Tag_Node),\n                   Selector_Name =>\n                     New_Reference_To\n                       (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n@@ -298,7 +279,7 @@ package body Exp_Atag is\n               Prefix =>\n                 Make_Selected_Component (Loc,\n                   Prefix =>\n-                    Unchecked_Convert_To (RTE_Tag_Node, Old_Tag_Node),\n+                    Build_DT (Loc, Old_Tag_Node),\n                   Selector_Name =>\n                     New_Reference_To\n                       (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n@@ -308,281 +289,139 @@ package body Exp_Atag is\n                 High_Bound => Make_Integer_Literal (Loc, Num_Prims))));\n    end Build_Inherit_Prims;\n \n-   -------------------\n-   -- Build_New_TSD --\n-   -------------------\n+   -------------------------------\n+   -- Build_Get_Prim_Op_Address --\n+   -------------------------------\n \n-   function Build_New_TSD\n-     (Loc          : Source_Ptr;\n-      New_Tag_Node : Node_Id) return List_Id\n+   function Build_Get_Prim_Op_Address\n+     (Loc      : Source_Ptr;\n+      Typ      : Entity_Id;\n+      Tag_Node : Node_Id;\n+      Position : Uint) return Node_Id\n    is\n    begin\n-      return New_List (\n-         Make_Assignment_Statement (Loc,\n-           Name =>\n-             Make_Indexed_Component (Loc,\n-               Prefix =>\n-                 Make_Selected_Component (Loc,\n-                   Prefix => Build_TSD (Loc, Duplicate_Subexpr (New_Tag_Node)),\n-                   Selector_Name =>\n-                     New_Reference_To\n-                       (RTE_Record_Component (RE_Tags_Table), Loc)),\n-               Expressions => New_List (Make_Integer_Literal (Loc, Uint_0))),\n-\n-           Expression => New_Tag_Node));\n-   end Build_New_TSD;\n+      pragma Assert\n+        (Position <= DT_Entry_Count (First_Tag_Component (Typ)));\n \n-   -----------------------\n-   -- Build_Inherit_TSD --\n-   -----------------------\n-\n-   function Build_Inherit_TSD\n-     (Loc               : Source_Ptr;\n-      Old_Tag_Node      : Node_Id;\n-      New_Tag_Node      : Node_Id;\n-      I_Depth           : Nat;\n-      Parent_Num_Ifaces : Nat) return Node_Id\n-   is\n-      function Build_Iface_Table_Ptr (Tag_Node : Node_Id) return Node_Id;\n-      --  Generates: Interface_Data_Ptr! (TSD (Tag).Ifaces_Table_Ptr).all\n+      --  At the end of the Access_Disp_Table list we have the type\n+      --  declaration required to convert the tag into a pointer to\n+      --  the prims_ptr table (see Freeze_Record_Type).\n \n-      ----------------------------\n-      --  Build_Iface_Table_Ptr --\n-      ----------------------------\n-\n-      function Build_Iface_Table_Ptr (Tag_Node : Node_Id) return Node_Id is\n-      begin\n-         return\n-            Unchecked_Convert_To (RTE (RE_Interface_Data_Ptr),\n-              Make_Selected_Component (Loc,\n-                Prefix => Tag_Node,\n-                Selector_Name =>\n-                  New_Reference_To\n-                    (RTE_Record_Component (RE_Ifaces_Table_Ptr), Loc)));\n-      end Build_Iface_Table_Ptr;\n-\n-      --  Local variables\n-\n-      L       : constant List_Id := New_List;\n-      Old_TSD : Node_Id;\n-      New_TSD : Node_Id;\n+      return\n+        Make_Indexed_Component (Loc,\n+          Prefix =>\n+            Unchecked_Convert_To\n+              (Node (Last_Elmt (Access_Disp_Table (Typ))), Tag_Node),\n+          Expressions => New_List (Make_Integer_Literal (Loc, Position)));\n+   end Build_Get_Prim_Op_Address;\n \n-   --  Start of processing for Build_Inherit_TSD\n+   -----------------------------\n+   -- Build_Get_Transportable --\n+   -----------------------------\n \n+   function Build_Get_Transportable\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id) return Node_Id\n+   is\n    begin\n-      Old_TSD :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier =>\n-            Make_Defining_Identifier (Loc, New_Internal_Name ('T')),\n-          Object_Definition =>\n-            New_Reference_To (RTE (RE_Type_Specific_Data_Ptr), Loc),\n-          Expression =>\n-            Build_TSD (Loc, Duplicate_Subexpr (Old_Tag_Node)));\n-\n-      New_TSD :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier =>\n-            Make_Defining_Identifier (Loc, New_Internal_Name ('T')),\n-          Object_Definition =>\n-            New_Reference_To (RTE (RE_Type_Specific_Data_Ptr), Loc),\n-          Expression =>\n-            Build_TSD (Loc, Duplicate_Subexpr (New_Tag_Node)));\n-\n-      Append_List_To (L, New_List (\n+      return\n+        Make_Selected_Component (Loc,\n+          Prefix => Build_TSD (Loc, Tag_Node),\n+          Selector_Name =>\n+            New_Reference_To\n+              (RTE_Record_Component (RE_Transportable), Loc));\n+   end Build_Get_Transportable;\n \n-         --  Copy the table of ancestors of the parent\n-         --    TSD (New_Tag).Tags_Table (1 .. I_Depth) :=\n-         --      TSD (Old_Tag).Tags_Table (0 .. I_Depth - 1);\n+   ------------------------------------\n+   -- Build_Inherit_Predefined_Prims --\n+   ------------------------------------\n \n-         Make_Assignment_Statement (Loc,\n-           Name =>\n-             Make_Slice (Loc,\n-               Prefix =>\n-                 Make_Selected_Component (Loc,\n-                   Prefix =>\n-                     Make_Explicit_Dereference (Loc,\n-                       New_Reference_To (Defining_Identifier (New_TSD), Loc)),\n-                   Selector_Name =>\n-                     New_Reference_To\n-                       (RTE_Record_Component (RE_Tags_Table), Loc)),\n-               Discrete_Range => Make_Range (Loc,\n-                 Make_Integer_Literal (Loc, Uint_1),\n-                 Make_Integer_Literal (Loc, I_Depth))),\n-\n-           Expression =>\n-             Make_Slice (Loc,\n-               Prefix =>\n-                 Make_Selected_Component (Loc,\n-                   Prefix =>\n-                     Make_Explicit_Dereference (Loc,\n-                       New_Reference_To (Defining_Identifier (Old_TSD), Loc)),\n-                   Selector_Name =>\n-                     New_Reference_To\n-                       (RTE_Record_Component (RE_Tags_Table), Loc)),\n-               Discrete_Range => Make_Range (Loc,\n-                 Make_Integer_Literal (Loc, Uint_0),\n-                 Make_Integer_Literal (Loc, I_Depth - 1))))));\n-\n-         --  Copy the table of interfaces of the parent\n-\n-         --  if not System.\"=\" (TSD (Old_Tag).Ifaces_Table_Ptr,\n-         --                       System.Null_Address)\n-         --  then\n-         --     New_Iface_Table_Ptr.Table (1 .. Parent_Num_Ifaces):=\n-         --       Old_Iface_Table_Ptr.Table (1 .. Parent_Num_Ifaces);\n-         --  end if;\n-\n-         --  The table of interfaces is not available under certified run-time\n-\n-         if RTE_Record_Component_Available (RE_Nb_Ifaces) then\n-            Append_To (L,\n-              Make_If_Statement (Loc,\n-                Condition =>\n-                  Make_Op_Not (Loc,\n-                    Right_Opnd =>\n-                      Make_Op_Eq (Loc,\n-                        Left_Opnd =>\n-                          Make_Selected_Component (Loc,\n-                            Prefix =>\n-                              Make_Explicit_Dereference (Loc,\n-                                New_Reference_To\n-                                  (Defining_Identifier (Old_TSD), Loc)),\n-                            Selector_Name =>\n-                              New_Reference_To\n-                                (RTE_Record_Component (RE_Ifaces_Table_Ptr),\n-                                 Loc)),\n-                        Right_Opnd =>\n-                          New_Reference_To (RTE (RE_Null_Address), Loc))),\n-\n-                Then_Statements => New_List (\n-                  Make_Assignment_Statement (Loc,\n-                    Name =>\n-                      Make_Slice (Loc,\n-                        Prefix =>\n-                          Make_Selected_Component (Loc,\n-                            Prefix =>\n-                              Build_Iface_Table_Ptr\n-                                (New_Reference_To\n-                                  (Defining_Identifier (New_TSD), Loc)),\n-                            Selector_Name =>\n-                              New_Reference_To\n-                                (RTE_Record_Component (RE_Ifaces_Table), Loc)),\n-\n-                        Discrete_Range => Make_Range (Loc,\n-                          Make_Integer_Literal (Loc, Uint_1),\n-                          Make_Integer_Literal (Loc, Parent_Num_Ifaces))),\n-\n-                    Expression =>\n-                      Make_Slice (Loc,\n-                        Prefix =>\n-                          Make_Selected_Component (Loc,\n-                            Prefix =>\n-                              Build_Iface_Table_Ptr\n-                                (New_Reference_To\n-                                  (Defining_Identifier (Old_TSD), Loc)),\n-                            Selector_Name =>\n-                              New_Reference_To\n-                                (RTE_Record_Component (RE_Ifaces_Table), Loc)),\n-\n-                        Discrete_Range => Make_Range (Loc,\n-                          Make_Integer_Literal (Loc, Uint_1),\n-                          Make_Integer_Literal (Loc, Parent_Num_Ifaces)))))));\n-         end if;\n-\n-         --  TSD (New_Tag).Tags_Table (0) := New_Tag;\n-\n-         Append_To (L,\n-            Make_Assignment_Statement (Loc,\n-              Name =>\n-                Make_Indexed_Component (Loc,\n-                  Prefix =>\n+   function Build_Inherit_Predefined_Prims\n+     (Loc          : Source_Ptr;\n+      Old_Tag_Node : Node_Id;\n+      New_Tag_Node : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+        Make_Assignment_Statement (Loc,\n+          Name =>\n+            Make_Slice (Loc,\n+              Prefix =>\n+                Make_Explicit_Dereference (Loc,\n+                  Unchecked_Convert_To (RTE (RE_Predef_Prims_Table_Ptr),\n                     Make_Selected_Component (Loc,\n                       Prefix =>\n-                        Make_Explicit_Dereference (Loc,\n-                          New_Reference_To\n-                            (Defining_Identifier (New_TSD), Loc)),\n+                        Build_DT (Loc, New_Tag_Node),\n                       Selector_Name =>\n                         New_Reference_To\n-                          (RTE_Record_Component (RE_Tags_Table), Loc)),\n-                  Expressions =>\n-                    New_List (Make_Integer_Literal (Loc, Uint_0))),\n-\n-              Expression => New_Tag_Node));\n-\n-      return\n-        Make_Block_Statement (Loc,\n-          Declarations => New_List (\n-            Old_TSD,\n-            New_TSD),\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc, L));\n+                          (RTE_Record_Component (RE_Predef_Prims), Loc)))),\n+              Discrete_Range => Make_Range (Loc,\n+                Make_Integer_Literal (Loc, Uint_1),\n+                New_Reference_To (RTE (RE_Default_Prim_Op_Count), Loc))),\n \n-   end Build_Inherit_TSD;\n+          Expression =>\n+            Make_Slice (Loc,\n+              Prefix =>\n+                Make_Explicit_Dereference (Loc,\n+                  Unchecked_Convert_To (RTE (RE_Predef_Prims_Table_Ptr),\n+                    Make_Selected_Component (Loc,\n+                      Prefix =>\n+                        Build_DT (Loc, Old_Tag_Node),\n+                      Selector_Name =>\n+                        New_Reference_To\n+                          (RTE_Record_Component (RE_Predef_Prims), Loc)))),\n+              Discrete_Range =>\n+                Make_Range (Loc,\n+                  Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                  High_Bound =>\n+                    New_Reference_To (RTE (RE_Default_Prim_Op_Count), Loc))));\n+   end Build_Inherit_Predefined_Prims;\n \n-   -------------------------\n-   -- Build_Predefined_DT --\n-   -------------------------\n+   ------------------------\n+   -- Build_Predef_Prims --\n+   ------------------------\n \n-   function Build_Predefined_DT\n+   function Build_Predef_Prims\n      (Loc      : Source_Ptr;\n       Tag_Node : Node_Id) return Node_Id\n    is\n    begin\n       return\n-        Unchecked_Convert_To (RTE_Tag_Node,\n-          Make_Function_Call (Loc,\n-            Name =>\n-              Make_Expanded_Name (Loc,\n-                Chars         => Name_Op_Subtract,\n-                Prefix        =>\n-                  New_Reference_To (RTU_Entity (System_Storage_Elements), Loc),\n-                Selector_Name =>\n-                  Make_Identifier (Loc,\n-                    Chars => Name_Op_Subtract)),\n-\n-            Parameter_Associations => New_List (\n-              Unchecked_Convert_To (RTE (RE_Address), Tag_Node),\n-              New_Reference_To (RTE (RE_DT_Prologue_Size), Loc))));\n-   end Build_Predefined_DT;\n-\n-   ----------------------------\n-   -- Build_Set_External_Tag --\n-   ----------------------------\n-\n-   function Build_Set_External_Tag\n-     (Loc        : Source_Ptr;\n-      Tag_Node   : Node_Id;\n-      Value_Node : Node_Id) return Node_Id\n-   is\n-   begin\n-      return\n-         Make_Assignment_Statement (Loc,\n-           Name =>\n-             Make_Selected_Component (Loc,\n-               Prefix => Build_TSD (Loc, Tag_Node),\n-               Selector_Name =>\n-                 New_Reference_To\n-                   (RTE_Record_Component (RO_TA_External_Tag), Loc)),\n-\n-           Expression =>\n-             Unchecked_Convert_To (RTE (RE_Cstring_Ptr), Value_Node));\n-   end Build_Set_External_Tag;\n+        Unchecked_Convert_To (RTE (RE_Predef_Prims_Table_Ptr),\n+          Make_Explicit_Dereference (Loc,\n+            Unchecked_Convert_To (RTE (RE_Addr_Ptr),\n+              Make_Function_Call (Loc,\n+                Name =>\n+                  Make_Expanded_Name (Loc,\n+                    Chars => Name_Op_Subtract,\n+                    Prefix =>\n+                      New_Reference_To\n+                        (RTU_Entity (System_Storage_Elements), Loc),\n+                    Selector_Name =>\n+                      Make_Identifier (Loc,\n+                        Chars => Name_Op_Subtract)),\n+\n+                Parameter_Associations => New_List (\n+                  Unchecked_Convert_To (RTE (RE_Address), Tag_Node),\n+                  New_Reference_To (RTE (RE_DT_Predef_Prims_Offset),\n+                                    Loc))))));\n+   end Build_Predef_Prims;\n \n    ------------------------------------------\n    -- Build_Set_Predefined_Prim_Op_Address --\n    ------------------------------------------\n \n    function Build_Set_Predefined_Prim_Op_Address\n-     (Loc           : Source_Ptr;\n-      Tag_Node      : Node_Id;\n-      Position_Node : Node_Id;\n-      Address_Node  : Node_Id) return Node_Id\n+     (Loc          : Source_Ptr;\n+      Tag_Node     : Node_Id;\n+      Position     : Uint;\n+      Address_Node : Node_Id) return Node_Id\n    is\n    begin\n       return\n          Make_Assignment_Statement (Loc,\n-           Name       => Build_Get_Predefined_Prim_Op_Address\n-                          (Loc, Tag_Node, Position_Node),\n+           Name       => Build_Get_Predefined_Prim_Op_Address (Loc,\n+                           Tag_Node, Position),\n            Expression => Address_Node);\n    end Build_Set_Predefined_Prim_Op_Address;\n \n@@ -591,52 +430,20 @@ package body Exp_Atag is\n    -------------------------------\n \n    function Build_Set_Prim_Op_Address\n-     (Loc           : Source_Ptr;\n-      Tag_Node      : Node_Id;\n-      Position_Node : Node_Id;\n-      Address_Node  : Node_Id) return Node_Id\n+     (Loc          : Source_Ptr;\n+      Typ          : Entity_Id;\n+      Tag_Node     : Node_Id;\n+      Position     : Uint;\n+      Address_Node : Node_Id) return Node_Id\n    is\n    begin\n       return\n-         Make_Assignment_Statement (Loc,\n-           Name       => Build_Get_Prim_Op_Address (Loc,\n-                           Tag_Node, Position_Node),\n-           Expression => Address_Node);\n+        Make_Assignment_Statement (Loc,\n+          Name       => Build_Get_Prim_Op_Address\n+                          (Loc, Typ, Tag_Node, Position),\n+          Expression => Address_Node);\n    end Build_Set_Prim_Op_Address;\n \n-   -------------------\n-   -- Build_Set_TSD --\n-   -------------------\n-\n-   function Build_Set_TSD\n-     (Loc        : Source_Ptr;\n-      Tag_Node   : Node_Id;\n-      Value_Node : Node_Id) return Node_Id\n-   is\n-   begin\n-      return\n-         Make_Assignment_Statement (Loc,\n-           Name =>\n-             Make_Explicit_Dereference (Loc,\n-               Prefix => Unchecked_Convert_To (RTE (RE_Addr_Ptr),\n-                   Make_Function_Call (Loc,\n-                     Name =>\n-                       Make_Expanded_Name (Loc,\n-                         Chars => Name_Op_Subtract,\n-                         Prefix =>\n-                           New_Reference_To\n-                             (RTU_Entity (System_Storage_Elements), Loc),\n-                         Selector_Name =>\n-                           Make_Identifier (Loc,\n-                             Chars => Name_Op_Subtract)),\n-\n-                     Parameter_Associations => New_List (\n-                       Unchecked_Convert_To (RTE (RE_Address), Tag_Node),\n-                       Build_Typeinfo_Offset (Loc))))),\n-\n-           Expression => Value_Node);\n-   end Build_Set_TSD;\n-\n    ---------------\n    -- Build_TSD --\n    ---------------\n@@ -647,42 +454,21 @@ package body Exp_Atag is\n         Unchecked_Convert_To (RTE (RE_Type_Specific_Data_Ptr),\n           Make_Explicit_Dereference (Loc,\n             Prefix => Unchecked_Convert_To (RTE (RE_Addr_Ptr),\n-                Make_Function_Call (Loc,\n-                  Name =>\n-                    Make_Expanded_Name (Loc,\n-                      Chars => Name_Op_Subtract,\n-                      Prefix =>\n-                        New_Reference_To\n-                          (RTU_Entity (System_Storage_Elements), Loc),\n-                      Selector_Name =>\n-                        Make_Identifier (Loc,\n-                          Chars => Name_Op_Subtract)),\n-\n-                  Parameter_Associations => New_List (\n-                    Unchecked_Convert_To (RTE (RE_Address), Tag_Node),\n-                    Build_Typeinfo_Offset (Loc))))));\n+              Make_Function_Call (Loc,\n+                Name =>\n+                  Make_Expanded_Name (Loc,\n+                    Chars => Name_Op_Subtract,\n+                    Prefix =>\n+                      New_Reference_To\n+                        (RTU_Entity (System_Storage_Elements), Loc),\n+                    Selector_Name =>\n+                      Make_Identifier (Loc,\n+                        Chars => Name_Op_Subtract)),\n+\n+                Parameter_Associations => New_List (\n+                  Unchecked_Convert_To (RTE (RE_Address), Tag_Node),\n+                    New_Reference_To\n+                      (RTE (RE_DT_Typeinfo_Ptr_Size), Loc))))));\n    end Build_TSD;\n \n-   ---------------------------\n-   -- Build_Typeinfo_Offset --\n-   ---------------------------\n-\n-   function Build_Typeinfo_Offset (Loc : Source_Ptr) return Node_Id is\n-   begin\n-      return New_Reference_To (RTE (RE_DT_Typeinfo_Ptr_Size), Loc);\n-   end Build_Typeinfo_Offset;\n-\n-   ---------------\n-   --  Tag_Node --\n-   ---------------\n-\n-   function RTE_Tag_Node return Entity_Id is\n-      E : constant Entity_Id := RTE (RE_Tag);\n-   begin\n-      if Atree.Present (Full_View (E)) then\n-         return Full_View (E);\n-      else\n-         return E;\n-      end if;\n-   end RTE_Tag_Node;\n end Exp_Atag;"}, {"sha": "6b0fce75c9efcace887e7c8ee4160cf2d3080935", "filename": "gcc/ada/exp_atag.ads", "status": "modified", "additions": 46, "deletions": 86, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fexp_atag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fexp_atag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.ads?ref=d0dd5209d981a9705ea87c5e86211e8f0709bb7c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2006-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,18 +28,24 @@\n --  subprograms of package Ada.Tags\n \n with Types; use Types;\n+with Uintp; use Uintp;\n \n package Exp_Atag is\n \n+   procedure Build_Common_Dispatching_Select_Statements\n+     (Loc    : Source_Ptr;\n+      DT_Ptr : Entity_Id;\n+      Stmts  : List_Id);\n+   --  Ada 2005 (AI-345): Generate statements that are common between timed,\n+   --  asynchronous, and conditional select expansion.\n+\n    function Build_CW_Membership\n      (Loc          : Source_Ptr;\n       Obj_Tag_Node : Node_Id;\n       Typ_Tag_Node : Node_Id) return Node_Id;\n-   --  Build code that returns true if Obj_Tag is in Typ_Tag'Class. Each\n-   --  dispatch table contains a reference to a table of ancestors (stored\n-   --  in the first part of the Tags_Table) and a count of the level of\n-   --  inheritance \"Idepth\". Obj is in Typ'Class if Typ'Tag is in the table\n-   --  of ancestors that are contained in the dispatch table referenced by\n+   --  Build code that returns true if Obj_Tag is in Typ_Tag'Class. Each DT\n+   --  has a table of ancestors and its inheritance level (Idepth). Obj is in\n+   --  Typ'Class if Typ'Tag is found in the table of ancestors referenced by\n    --  Obj'Tag. Knowing the level of inheritance of both types, this can be\n    --  computed in constant time by the formula:\n    --\n@@ -54,39 +60,32 @@ package Exp_Atag is\n    --  Generates: TSD (Tag).Access_Level\n \n    function Build_Get_Predefined_Prim_Op_Address\n-     (Loc           : Source_Ptr;\n-      Tag_Node      : Node_Id;\n-      Position_Node : Node_Id) return Node_Id;\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id;\n+      Position : Uint) return Node_Id;\n    --  Given a pointer to a dispatch table (T) and a position in the DT, build\n    --  code that gets the address of the predefined virtual function stored in\n    --  it (used for dispatching calls).\n    --\n    --  Generates: Predefined_DT (Tag).D (Position);\n \n    function Build_Get_Prim_Op_Address\n-     (Loc           : Source_Ptr;\n-      Tag_Node      : Node_Id;\n-      Position_Node : Node_Id) return Node_Id;\n+     (Loc      : Source_Ptr;\n+      Typ      : Entity_Id;\n+      Tag_Node : Node_Id;\n+      Position : Uint) return Node_Id;\n    --  Build code that retrieves the address of the virtual function stored in\n    --  a given position of the dispatch table (used for dispatching calls).\n    --\n    --  Generates: To_Tag (Tag).D (Position);\n \n-   function Build_Get_RC_Offset\n-     (Loc        : Source_Ptr;\n-      Tag_Node   : Node_Id) return Node_Id;\n-   --  Build code that retrieves the Offset of the implicit record controller\n-   --  when the object has controlled components. O otherwise.\n-   --\n-   --  Generates: TSD (T).RC_Offset;\n-\n-   function Build_Get_Remotely_Callable\n-     (Loc        : Source_Ptr;\n-      Tag_Node   : Node_Id) return Node_Id;\n-   --  Build code that retrieves the value previously saved by Set_Remotely\n-   --  Callable\n+   function Build_Get_Transportable\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id) return Node_Id;\n+   --  Build code that retrieves the value of the Transportable flag for\n+   --  the given Tag.\n    --\n-   --  Generates: TSD (Tag).Remotely_Callable\n+   --  Generates: TSD (Tag).Transportable;\n \n    function Build_Inherit_Predefined_Prims\n      (Loc              : Source_Ptr;\n@@ -96,87 +95,48 @@ package Exp_Atag is\n    --\n    --  Generates: Predefined_DT (New_T).D (All_Predefined_Prims) :=\n    --               Predefined_DT (Old_T).D (All_Predefined_Prims);\n+   --\n+   --  Required to build the dispatch tables with the 3.4 backend.\n \n    function Build_Inherit_Prims\n      (Loc          : Source_Ptr;\n       Old_Tag_Node : Node_Id;\n       New_Tag_Node : Node_Id;\n       Num_Prims    : Nat) return Node_Id;\n    --  Build code that inherits Num_Prims user-defined primitives from the\n-   --  dispatch table of the parent type.\n+   --  dispatch table of the parent type. It is used to copy the dispatch\n+   --  table of the parent in case of derivations of CPP_Class types.\n    --\n    --  Generates:\n    --    New_Tag.Prims_Ptr (1 .. Num_Prims) :=\n    --      Old_Tag.Prims_Ptr (1 .. Num_Prims);\n \n-   function Build_Inherit_TSD\n-     (Loc               : Source_Ptr;\n-      Old_Tag_Node      : Node_Id;\n-      New_Tag_Node      : Node_Id;\n-      I_Depth           : Nat;\n-      Parent_Num_Ifaces : Nat) return Node_Id;\n-   --  Generates code that initializes the TSD of a type knowing the tag,\n-   --  inheritance depth, and number of interface types of the parent type.\n-   --\n-   --  Generates:\n-   --     --  Copy the table of ancestors of the parent\n-   --\n-   --     TSD (New_Tag).Tags_Table (1 .. I_Depth) :=\n-   --       TSD (Old_Tag).Tags_Table (0 .. I_Depth - 1);\n-   --\n-   --     --  Copy the table of interfaces of the parent\n-   --\n-   --     if TSD (Old_Tag).Ifaces_Table_Ptr /= null then\n-   --        New_Iface_Table_Ptr.Table (1 .. Parent_Num_Ifaces):=\n-   --          Old_Iface_Table_Ptr.Table (1 .. Parent_Num_Ifaces);\n-   --     end if;\n-   --\n-   --     TSD (New_Tag).Tags_Table (0) := New_Tag;\n-\n-   function Build_New_TSD\n-     (Loc          : Source_Ptr;\n-      New_Tag_Node : Node_Id) return List_Id;\n-   --  Build code that initializes the TSD of a root type.\n-   --  Generates: TSD (New_Tag).Tags_Table (0) := New_Tag;\n-\n-   function Build_Set_External_Tag\n-     (Loc        : Source_Ptr;\n-      Tag_Node   : Node_Id;\n-      Value_Node : Node_Id) return Node_Id;\n-   --  Build code that saves the address of the string containing the external\n-   --  tag in the dispatch table.\n-   --\n-   --  Generates: TSD (Tag).External_Tag := Cstring_Ptr! (Value);\n-\n    function Build_Set_Predefined_Prim_Op_Address\n-     (Loc           : Source_Ptr;\n-      Tag_Node      : Node_Id;\n-      Position_Node : Node_Id;\n-      Address_Node  : Node_Id) return Node_Id;\n+     (Loc          : Source_Ptr;\n+      Tag_Node     : Node_Id;\n+      Position     : Uint;\n+      Address_Node : Node_Id) return Node_Id;\n    --  Build code that saves the address of a virtual function in a given\n    --  Position of the portion of the dispatch table associated with the\n-   --  predefined primitives of Tag (used for overriding).\n+   --  predefined primitives of Tag. Called from Exp_Disp.Fill_DT_Entry\n+   --  and Exp_Disp.Fill_Secondary_DT_Entry. It is used for:\n+   --   1) Filling the dispatch table of CPP_Class types.\n+   --   2) Late overriding (see Check_Dispatching_Operation).\n    --\n    --  Generates: Predefined_DT (Tag).D (Position) := Value\n \n    function Build_Set_Prim_Op_Address\n-     (Loc           : Source_Ptr;\n-      Tag_Node      : Node_Id;\n-      Position_Node : Node_Id;\n-      Address_Node  : Node_Id) return Node_Id;\n+     (Loc          : Source_Ptr;\n+      Typ          : Entity_Id;\n+      Tag_Node     : Node_Id;\n+      Position     : Uint;\n+      Address_Node : Node_Id) return Node_Id;\n    --  Build code that saves the address of a virtual function in a given\n-   --  Position of the dispatch table associated with the Tag (used for\n-   --  overriding).\n+   --  Position of the dispatch table associated with the Tag. Called from\n+   --  Exp_Disp.Fill_DT_Entry and Exp_Disp.Fill_Secondary_DT_Entry. Used for:\n+   --   1) Filling the dispatch table of CPP_Class types.\n+   --   2) Late overriding (see Check_Dispatching_Operation).\n    --\n    --  Generates: Tag.D (Position) := Value\n \n-   function Build_Set_TSD\n-     (Loc        : Source_Ptr;\n-      Tag_Node   : Node_Id;\n-      Value_Node : Node_Id) return Node_Id;\n-   --  Build code that saves the address of the record containing the Type\n-   --  Specific Data generated by GNAT.\n-   --\n-   --  Generates: To_Addr_Ptr (To_Address (Tag) - K_Typeinfo).all := Value\n-\n end Exp_Atag;"}, {"sha": "1c079893d5dd2bc7168e33194b24e59466360f4b", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 2602, "deletions": 1714, "changes": 4316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=d0dd5209d981a9705ea87c5e86211e8f0709bb7c"}, {"sha": "32cde2f630298bdae947931527760f44f17f1aa7", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 35, "deletions": 66, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=d0dd5209d981a9705ea87c5e86211e8f0709bb7c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -111,7 +111,7 @@ package Exp_Disp is\n    --      interfaces, not generated for the rest of the cases. See Expand_N_\n    --      Timed_Entry_Call for more information.\n \n-   --  Lifecycle of predefined primitive operations\n+   --  Life cycle of predefined primitive operations\n \n    --      The specifications and bodies of the PPOs are created by\n    --      Make_Predefined_Primitive_Specs and Predefined_Primitive_Bodies\n@@ -122,16 +122,14 @@ package Exp_Disp is\n    --      PPOs are collected and added to the Primitive_Operations list of\n    --      a type by the regular analysis mechanism.\n \n-   --      PPOs are frozen in Predefined_Primitive_Freeze in Exp_Ch3.\n+   --      PPOs are frozen by Exp_Ch3.Predefined_Primitive_Freeze.\n \n-   --      Thunks for PPOs are created in Freeze_Subprogram in Exp_Ch6, by a\n-   --      call to Register_Predefined_DT_Entry, also in Exp_Ch6.\n+   --      Thunks for PPOs are created by Make_DT.\n \n-   --      Dispatch table positions of PPOs are set in Set_All_DT_Position in\n-   --      Exp_Disp.\n+   --      Dispatch table positions of PPOs are set by Set_All_DT_Position.\n \n-   --      Calls to PPOs procede as regular dispatching calls. If the PPO\n-   --      has a thunk, a call procedes as a regular dispatching call with\n+   --      Calls to PPOs proceed as regular dispatching calls. If the PPO\n+   --      has a thunk, a call proceeds as a regular dispatching call with\n    --      a thunk.\n \n    --  Guidelines for addition of new predefined primitive operations\n@@ -167,21 +165,6 @@ package Exp_Disp is\n    --    Exp_Disp.Default_Prim_Op_Position - indirect use\n    --    Exp_Disp.Set_All_DT_Position      - direct   use\n \n-   type DT_Access_Action is\n-      (IW_Membership,\n-       Get_Entry_Index,\n-       Get_Prim_Op_Kind,\n-       Get_Tagged_Kind,\n-       Register_Interface_Tag,\n-       Register_Tag,\n-       Set_Entry_Index,\n-       Set_Offset_Index,\n-       Set_OSD,\n-       Set_Prim_Op_Kind,\n-       Set_Signature,\n-       Set_SSD,\n-       Set_Tagged_Kind);\n-\n    procedure Expand_Dispatching_Call (Call_Node : Node_Id);\n    --  Expand the call to the operation through the dispatch table and perform\n    --  the required tag checks when appropriate. For CPP types tag checks are\n@@ -198,41 +181,22 @@ package Exp_Disp is\n    --  the object to give access to the interface tag associated with the\n    --  secondary dispatch table.\n \n-   function Expand_Interface_Thunk\n+   procedure Expand_Interface_Thunk\n      (N           : Node_Id;\n       Thunk_Alias : Node_Id;\n-      Thunk_Id    : Entity_Id) return Node_Id;\n+      Thunk_Id    : out Entity_Id;\n+      Thunk_Code  : out Node_Id);\n    --  Ada 2005 (AI-251): When a tagged type implements abstract interfaces we\n    --  generate additional subprograms (thunks) to have a layout compatible\n    --  with the C++ ABI. The thunk modifies the value of the first actual of\n    --  the call (that is, the pointer to the object) before transferring\n    --  control to the target function.\n-\n-   function Fill_DT_Entry\n-     (Loc          : Source_Ptr;\n-      Prim         : Entity_Id) return Node_Id;\n-   --  Generate the code necessary to fill the appropriate entry of the\n-   --  dispatch table of Prim's controlling type with Prim's address.\n-\n-   function Fill_Secondary_DT_Entry\n-     (Loc          : Source_Ptr;\n-      Prim         : Entity_Id;\n-      Thunk_Id     : Entity_Id;\n-      Iface_DT_Ptr : Entity_Id) return Node_Id;\n-   --  (Ada 2005): Generate the code necessary to fill the appropriate entry of\n-   --  the secondary dispatch table of Prim's controlling type with Thunk_Id's\n-   --  address.\n-\n-   function Make_DT_Access_Action\n-     (Typ    : Entity_Id;\n-      Action : DT_Access_Action;\n-      Args   : List_Id) return Node_Id;\n-   --  Generate a call to one of the Dispatch Table Access Subprograms defined\n-   --  in Ada.Tags or in Interfaces.Cpp\n+   --\n+   --  Required in 3.4 case, why ??? giant comment needed for any gcc\n+   --  specific code ???\n \n    function Make_DT (Typ : Entity_Id) return List_Id;\n-   --  Expand the declarations for the Dispatch Table (or the Vtable in\n-   --  the case of type whose ancestor is a CPP_Class)\n+   --  Expand the declarations for the Dispatch Table.\n \n    function Make_Disp_Asynchronous_Select_Body\n      (Typ : Entity_Id) return Node_Id;\n@@ -284,8 +248,8 @@ package Exp_Disp is\n    function Make_Disp_Timed_Select_Body\n      (Typ : Entity_Id) return Node_Id;\n    --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n-   --  Typ used for dispatching in timed selects. Generate a null body if Nul\n-   --  is an interface type.\n+   --  Typ used for dispatching in timed selects. Generates a body containing\n+   --  a single null-statement if Typ is an interface type.\n \n    function Make_Disp_Timed_Select_Spec\n      (Typ : Entity_Id) return Node_Id;\n@@ -299,20 +263,19 @@ package Exp_Disp is\n    --  selects. Generate code to set the primitive operation kinds and entry\n    --  indices of primitive operations and primitive wrappers.\n \n-   procedure Make_Secondary_DT\n-     (Typ             : Entity_Id;\n-      Ancestor_Typ    : Entity_Id;\n-      Suffix_Index    : Nat;\n-      Iface           : Entity_Id;\n-      AI_Tag          : Entity_Id;\n-      Acc_Disp_Tables : in out Elist_Id;\n-      Result          : out List_Id);\n-   --  Ada 2005 (AI-251): Expand the declarations for the Secondary Dispatch\n-   --  Table of Typ associated with Iface (each abstract interface implemented\n-   --  by Typ has a secondary dispatch table). The arguments Typ, Ancestor_Typ\n-   --  and Suffix_Index are used to generate an unique external name which\n-   --  is added at the end of Acc_Disp_Tables; this external name will be\n-   --  used later by the subprogram Exp_Ch3.Build_Init_Procedure.\n+   procedure Register_Primitive\n+     (Loc     : Source_Ptr;\n+      Prim    : Entity_Id;\n+      Ins_Nod : Node_Id);\n+   --  Register Prim in the corresponding primary or secondary dispatch table.\n+   --  If Prim is associated with a secondary dispatch table then generate also\n+   --  its thunk and register it in the associated secondary dispatch table.\n+   --  In general the dispatch tables are always generated by Make_DT and\n+   --  Make_Secondary_DT; this routine is only used in two corner cases:\n+   --    1) To construct the dispatch table of a tagged type whose parent\n+   --       is a CPP_Class (see Build_Init_Procedure).\n+   --    2) To handle late overriding of dispatching operations (see\n+   --       Check_Dispatching_Operation).\n \n    procedure Set_All_DT_Position (Typ : Entity_Id);\n    --  Set the DT_Position field for each primitive operation. In the CPP\n@@ -324,6 +287,12 @@ package Exp_Disp is\n    --  be the default constructor (i.e. the function returning this type,\n    --  having a pragma CPP_Constructor and no parameter)\n \n+   procedure Set_DTC_Entity_Value\n+     (Tagged_Type : Entity_Id;\n+      Prim        : Entity_Id);\n+   --  Set the definite value of the DTC_Entity value associated with a given\n+   --  primitive of a tagged type.\n+\n    procedure Write_DT (Typ : Entity_Id);\n    pragma Export (Ada, Write_DT);\n    --  Debugging procedure (to be called within gdb)"}, {"sha": "af2163d3ff6d62ec6b989985fffb0fa72c379a58", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=d0dd5209d981a9705ea87c5e86211e8f0709bb7c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -541,7 +541,15 @@ package body Rtsfind is\n          Output_Entity_Name (Id, \"not available\");\n       end if;\n \n-      raise RE_Not_Available;\n+      --  In configurable run time mode, we raise RE_Not_Available, and we hope\n+      --  the caller deals gracefully with this. If we are in normal full run\n+      --  time mode, a load failure is considered fatal and unrecoverable.\n+\n+      if Configurable_Run_Time_Mode then\n+         raise RE_Not_Available;\n+      else\n+         raise Unrecoverable_Error;\n+      end if;\n    end Load_Fail;\n \n    --------------\n@@ -683,12 +691,24 @@ package body Rtsfind is\n          Set_Analyzed (Cunit (Current_Sem_Unit), True);\n \n          if not Analyzed (Cunit (U.Unum)) then\n-            Save_Private_Visibility;\n-            Semantics (Cunit (U.Unum));\n-            Restore_Private_Visibility;\n \n-            if Fatal_Error (U.Unum) then\n-               Load_Fail (\"had semantic errors\", U_Id, Id);\n+            --  If the unit is already loaded through a limited_with clauses,\n+            --  the relevant entities must already be available. We do not\n+            --  want to load and analyze the unit because this would create\n+            --  a real semantic dependence when the purpose of the limited_with\n+            --  is precisely to avoid such.\n+\n+            if From_With_Type (Cunit_Entity (U.Unum)) then\n+               null;\n+\n+            else\n+               Save_Private_Visibility;\n+               Semantics (Cunit (U.Unum));\n+               Restore_Private_Visibility;\n+\n+               if Fatal_Error (U.Unum) then\n+                  Load_Fail (\"had semantic errors\", U_Id, Id);\n+               end if;\n             end if;\n          end if;\n \n@@ -891,7 +911,8 @@ package body Rtsfind is\n       -----------------------\n \n       function Find_Local_Entity (E : RE_Id) return Entity_Id is\n-         RE_Str : String renames RE_Id'Image (E);\n+         RE_Str : constant String := RE_Id'Image (E);\n+         Nam    : Name_Id;\n          Ent    : Entity_Id;\n \n          Save_Nam : constant String := Name_Buffer (1 .. Name_Len);\n@@ -902,7 +923,8 @@ package body Rtsfind is\n          Name_Buffer (1 .. Name_Len) :=\n            RE_Str (RE_Str'First + 3 .. RE_Str'Last);\n \n-         Ent := Entity_Id (Get_Name_Table_Info (Name_Find));\n+         Nam := Name_Find;\n+         Ent := Entity_Id (Get_Name_Table_Info (Nam));\n \n          Name_Len := Save_Nam'Length;\n          Name_Buffer (1 .. Name_Len) := Save_Nam;\n@@ -956,9 +978,16 @@ package body Rtsfind is\n             pragma Assert (Nkind (Lib_Unit) = N_Package_Declaration);\n             Ename := RE_Chars (E);\n \n-            --  First we search the package entity chain\n+            --  First we search the package entity chain. If the package\n+            --  only has a limited view, scan the corresponding list of\n+            --  incomplete types.\n+\n+            if From_With_Type (U.Entity) then\n+               Pkg_Ent := First_Entity (Limited_View (U.Entity));\n+            else\n+               Pkg_Ent := First_Entity (U.Entity);\n+            end if;\n \n-            Pkg_Ent := First_Entity (U.Entity);\n             while Present (Pkg_Ent) loop\n                if Ename = Chars (Pkg_Ent) then\n                   RE_Table (E) := Pkg_Ent;\n@@ -1067,6 +1096,7 @@ package body Rtsfind is\n       U        : RT_Unit_Table_Record renames RT_Unit_Table (U_Id);\n       E1       : Entity_Id;\n       Ename    : Name_Id;\n+      Found_E  : Entity_Id;\n       Lib_Unit : Node_Id;\n       Pkg_Ent  : Entity_Id;\n \n@@ -1103,13 +1133,15 @@ package body Rtsfind is\n       --  Search the entity in the components of record type declarations\n       --  found in the package entity chain.\n \n+      Found_E := Empty;\n       Pkg_Ent := First_Entity (U.Entity);\n       Search : while Present (Pkg_Ent) loop\n          if Is_Record_Type (Pkg_Ent) then\n             E1 := First_Entity (Pkg_Ent);\n             while Present (E1) loop\n                if Ename = Chars (E1) then\n-                  exit Search;\n+                  pragma Assert (not Present (Found_E));\n+                  Found_E := E1;\n                end if;\n \n                Next_Entity (E1);\n@@ -1157,7 +1189,7 @@ package body Rtsfind is\n       end if;\n \n       Front_End_Inlining := Save_Front_End_Inlining;\n-      return Check_CRT (E, E1);\n+      return Check_CRT (E, Found_E);\n    end RTE_Record_Component;\n \n    ------------------------------------\n@@ -1366,6 +1398,12 @@ package body Rtsfind is\n             end if;\n          end loop;\n       end if;\n+\n+   exception\n+      --  Generate error message if run-time unit not available\n+\n+      when RE_Not_Available =>\n+         Error_Msg_N (\"& not available\", Nam);\n    end Text_IO_Kludge;\n \n end Rtsfind;"}, {"sha": "cb59e71cc87be55492c5315b0e757ff7990a0dd2", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0dd5209d981a9705ea87c5e86211e8f0709bb7c/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=d0dd5209d981a9705ea87c5e86211e8f0709bb7c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -184,6 +184,7 @@ package Rtsfind is\n \n       --  Children of System\n \n+      System_Address_Image,\n       System_Arith_64,\n       System_AST_Handling,\n       System_Assertions,\n@@ -201,6 +202,7 @@ package Rtsfind is\n       System_Compare_Array_Unsigned_8,\n       System_DSA_Services,\n       System_Exception_Table,\n+      System_Exceptions,\n       System_Exn_Int,\n       System_Exn_LLF,\n       System_Exn_LLI,\n@@ -399,7 +401,7 @@ package Rtsfind is\n    --  Range of values for children of Interfaces\n \n    subtype System_Child is RTU_Id\n-     range System_Arith_64 .. System_Tasking_Stages;\n+     range System_Address_Image .. System_Tasking_Stages;\n    --  Range of values for children or grandchildren of System\n \n    subtype System_Tasking_Child is System_Child\n@@ -456,11 +458,11 @@ package Rtsfind is\n      RE_Exception_Message,               -- Ada.Exceptions\n      RE_Exception_Name_Simple,           -- Ada.Exceptions\n      RE_Exception_Occurrence,            -- Ada.Exceptions\n-     RE_Local_Raise,                     -- Ada.Exceptions\n      RE_Null_Occurrence,                 -- Ada.Exceptions\n      RE_Poll,                            -- Ada.Exceptions\n      RE_Raise_Exception,                 -- Ada.Exceptions\n      RE_Raise_Exception_Always,          -- Ada.Exceptions\n+     RE_Raise_From_Controlled_Operation, -- Ada.Exceptions\n      RE_Reraise_Occurrence,              -- Ada.Exceptions\n      RE_Reraise_Occurrence_Always,       -- Ada.Exceptions\n      RE_Reraise_Occurrence_No_Defer,     -- Ada.Exceptions\n@@ -485,42 +487,45 @@ package Rtsfind is\n \n      RE_Stream_Access,                   -- Ada.Streams.Stream_IO\n \n-     RE_Abstract_Interface,              -- Ada.Tags\n      RE_Access_Level,                    -- Ada.Tags\n+     RE_Address_Array,                   -- Ada.Tags\n      RE_Addr_Ptr,                        -- Ada.Tags\n      RE_Base_Address,                    -- Ada.Tags\n      RE_Cstring_Ptr,                     -- Ada.Tags\n      RE_Default_Prim_Op_Count,           -- Ada.Tags\n      RE_Descendant_Tag,                  -- Ada.Tags\n      RE_Dispatch_Table,                  -- Ada.Tags\n+     RE_Dispatch_Table_Wrapper,          -- Ada.Tags\n      RE_Displace,                        -- Ada.Tags\n-     RE_DT_Entry_Size,                   -- Ada.Tags\n-     RE_DT_Min_Prologue_Size,            -- Ada.Tags\n-     RE_DT_Prologue_Size,                -- Ada.Tags\n+     RE_DT,                              -- Ada.Tags\n+     RE_DT_Predef_Prims_Offset,          -- Ada.Tags\n      RE_DT_Typeinfo_Ptr_Size,            -- Ada.Tags\n      RE_Expanded_Name,                   -- Ada.Tags\n      RE_External_Tag,                    -- Ada.Tags\n+     RE_HT_Link,                         -- Ada.Tags\n      RO_TA_External_Tag,                 -- Ada.Tags\n      RE_Get_Access_Level,                -- Ada.Tags\n      RE_Get_Entry_Index,                 -- Ada.Tags\n      RE_Get_Offset_Index,                -- Ada.Tags\n-     RE_Get_Predefined_Prim_Op_Address,  -- Ada.Tags\n-     RE_Get_Prim_Op_Address,             -- Ada.Tags\n      RE_Get_Prim_Op_Kind,                -- Ada.Tags\n-     RE_Get_RC_Offset,                   -- Ada.Tags\n-     RE_Get_Remotely_Callable,           -- Ada.Tags\n      RE_Get_Tagged_Kind,                 -- Ada.Tags\n      RE_Idepth,                          -- Ada.Tags\n+     RE_Iface_Tag,                       -- Ada.Tags\n      RE_Ifaces_Table,                    -- Ada.Tags\n-     RE_Ifaces_Table_Ptr,                -- Ada.Tags\n+     RE_Interfaces_Table,                -- Ada.Tags\n      RE_Interface_Data,                  -- Ada.Tags\n-     RE_Interface_Data_Ptr,              -- Ada.Tags\n      RE_Interface_Tag,                   -- Ada.Tags\n      RE_IW_Membership,                   -- Ada.Tags\n      RE_Nb_Ifaces,                       -- Ada.Tags\n+     RE_No_Dispatch_Table_Wrapper,       -- Ada.Tags\n+     RE_NDT_Prims_Ptr,                   -- Ada.Tags\n+     RE_NDT_TSD,                         -- Ada.Tags\n+     RE_Num_Prims,                       -- Ada.Tags\n      RE_Object_Specific_Data,            -- Ada.Tags\n      RE_Offset_To_Top,                   -- Ada.Tags\n-     RE_Type_Specific_Data,              -- Ada.Tags\n+     RE_Offset_To_Top_Function_Ptr,      -- Ada.Tags\n+     RE_OSD_Table,                       -- Ada.Tags\n+     RE_OSD_Num_Prims,                   -- Ada.Tags\n      RE_POK_Function,                    -- Ada.Tags\n      RE_POK_Procedure,                   -- Ada.Tags\n      RE_POK_Protected_Entry,             -- Ada.Tags\n@@ -529,34 +534,29 @@ package Rtsfind is\n      RE_POK_Task_Entry,                  -- Ada.Tags\n      RE_POK_Task_Function,               -- Ada.Tags\n      RE_POK_Task_Procedure,              -- Ada.Tags\n+     RE_Predef_Prims,                    -- Ada.Tags\n+     RE_Predef_Prims_Table_Ptr,          -- Ada.Tags\n      RE_Prim_Op_Kind,                    -- Ada.Tags\n-     RE_Primary_DT,                      -- Ada.Tags\n      RE_Prims_Ptr,                       -- Ada.Tags\n-     RE_Register_Interface_Tag,          -- Ada.Tags\n+     RE_Primary_DT,                      -- Ada.Tags\n+     RE_Signature,                       -- Ada.Tags\n+     RE_SSD,                             -- Ada.Tags\n+     RE_TSD,                             -- Ada.Tags\n+     RE_Type_Specific_Data,              -- Ada.Tags\n      RE_Register_Tag,                    -- Ada.Tags\n-     RE_Remotely_Callable,               -- Ada.Tags\n+     RE_Transportable,                   -- Ada.Tags\n      RE_RC_Offset,                       -- Ada.Tags\n      RE_Secondary_DT,                    -- Ada.Tags\n      RE_Select_Specific_Data,            -- Ada.Tags\n-     RE_Set_Access_Level,                -- Ada.Tags\n      RE_Set_Entry_Index,                 -- Ada.Tags\n-     RE_Set_Expanded_Name,               -- Ada.Tags\n-     RE_Set_Num_Prim_Ops,                -- Ada.Tags\n-     RE_Set_Offset_Index,                -- Ada.Tags\n      RE_Set_Offset_To_Top,               -- Ada.Tags\n-     RE_Set_OSD,                         -- Ada.Tags\n-     RE_Set_Predefined_Prim_Op_Address,  -- Ada.Tags\n-     RE_Set_Prim_Op_Address,             -- Ada.Tags\n      RE_Set_Prim_Op_Kind,                -- Ada.Tags\n-     RE_Set_RC_Offset,                   -- Ada.Tags\n-     RE_Set_Remotely_Callable,           -- Ada.Tags\n-     RE_Set_SSD,                         -- Ada.Tags\n-     RE_Set_Signature,                   -- Ada.Tags\n-     RE_Set_Tagged_Kind,                 -- Ada.Tags\n-     RE_Set_TSD,                         -- Ada.Tags\n+     RE_Static_Offset_To_Top,            -- Ada.Tags\n      RE_Tag,                             -- Ada.Tags\n      RE_Tag_Error,                       -- Ada.Tags\n+     RE_Tag_Kind,                        -- Ada.Tags\n      RE_Tag_Ptr,                         -- Ada.Tags\n+     RE_Tag_Table,                       -- Ada.Tags\n      RE_Tags_Table,                      -- Ada.Tags\n      RE_Tagged_Kind,                     -- Ada.Tags\n      RE_Type_Specific_Data_Ptr,          -- Ada.Tags\n@@ -599,6 +599,8 @@ package Rtsfind is\n      RE_Null_Address,                    -- System\n      RE_Priority,                        -- System\n \n+     RE_Address_Image,                   -- System.Address_Image\n+\n      RE_Add_With_Ovflo_Check,            -- System.Arith_64\n      RE_Double_Divide,                   -- System.Arith_64\n      RE_Multiply_With_Ovflo_Check,       -- System.Arith_64\n@@ -607,6 +609,7 @@ package Rtsfind is\n \n      RE_Create_AST_Handler,              -- System.AST_Handling\n \n+     RE_Assert_Failure,                  -- System.Assertions\n      RE_Raise_Assert_Failure,            -- System.Assertions\n \n      RE_AST_Handler,                     -- System.Aux_DEC\n@@ -663,6 +666,8 @@ package Rtsfind is\n \n      RE_Register_Exception,              -- System.Exception_Table\n \n+     RE_Local_Raise,                     -- System.Exceptions\n+\n      RE_Exn_Integer,                     -- System.Exn_Int\n \n      RE_Exn_Long_Long_Float,             -- System.Exn_LLF\n@@ -1231,6 +1236,7 @@ package Rtsfind is\n      RE_Storage_Offset,                  -- System.Storage_Elements\n      RE_Storage_Array,                   -- System.Storage_Elements\n      RE_To_Address,                      -- System.Storage_Elements\n+     RE_Dummy_Communication_Block,       -- System.Storage_Elements\n \n      RE_Root_Storage_Pool,               -- System.Storage_Pools\n      RE_Allocate_Any,                    -- System_Storage_Pools,\n@@ -1333,11 +1339,6 @@ package Rtsfind is\n      RE_Get_GNAT_Exception,              -- System.Soft_Links\n      RE_Update_Exception,                -- System.Soft_Links\n \n-     RE_ATSD,                            -- System.Threads\n-     RE_Thread_Body_Enter,               -- System.Threads\n-     RE_Thread_Body_Exceptional_Exit,    -- System.Threads\n-     RE_Thread_Body_Leave,               -- System.Threads\n-\n      RE_Bits_1,                          -- System.Unsigned_Types\n      RE_Bits_2,                          -- System.Unsigned_Types\n      RE_Bits_4,                          -- System.Unsigned_Types\n@@ -1563,11 +1564,11 @@ package Rtsfind is\n      RE_Exception_Message                => Ada_Exceptions,\n      RE_Exception_Name_Simple            => Ada_Exceptions,\n      RE_Exception_Occurrence             => Ada_Exceptions,\n-     RE_Local_Raise                      => Ada_Exceptions,\n      RE_Null_Occurrence                  => Ada_Exceptions,\n      RE_Poll                             => Ada_Exceptions,\n      RE_Raise_Exception                  => Ada_Exceptions,\n      RE_Raise_Exception_Always           => Ada_Exceptions,\n+     RE_Raise_From_Controlled_Operation  => Ada_Exceptions,\n      RE_Reraise_Occurrence               => Ada_Exceptions,\n      RE_Reraise_Occurrence_Always        => Ada_Exceptions,\n      RE_Reraise_Occurrence_No_Defer      => Ada_Exceptions,\n@@ -1592,42 +1593,45 @@ package Rtsfind is\n \n      RE_Stream_Access                    => Ada_Streams_Stream_IO,\n \n-     RE_Abstract_Interface               => Ada_Tags,\n      RE_Access_Level                     => Ada_Tags,\n+     RE_Address_Array                    => Ada_Tags,\n      RE_Addr_Ptr                         => Ada_Tags,\n      RE_Base_Address                     => Ada_Tags,\n      RE_Cstring_Ptr                      => Ada_Tags,\n      RE_Default_Prim_Op_Count            => Ada_Tags,\n      RE_Descendant_Tag                   => Ada_Tags,\n      RE_Dispatch_Table                   => Ada_Tags,\n+     RE_Dispatch_Table_Wrapper           => Ada_Tags,\n      RE_Displace                         => Ada_Tags,\n-     RE_DT_Entry_Size                    => Ada_Tags,\n-     RE_DT_Min_Prologue_Size             => Ada_Tags,\n-     RE_DT_Prologue_Size                 => Ada_Tags,\n+     RE_DT                               => Ada_Tags,\n+     RE_DT_Predef_Prims_Offset           => Ada_Tags,\n      RE_DT_Typeinfo_Ptr_Size             => Ada_Tags,\n      RE_Expanded_Name                    => Ada_Tags,\n      RE_External_Tag                     => Ada_Tags,\n+     RE_HT_Link                          => Ada_Tags,\n      RO_TA_External_Tag                  => Ada_Tags,\n      RE_Get_Access_Level                 => Ada_Tags,\n      RE_Get_Entry_Index                  => Ada_Tags,\n      RE_Get_Offset_Index                 => Ada_Tags,\n-     RE_Get_Predefined_Prim_Op_Address   => Ada_Tags,\n-     RE_Get_Prim_Op_Address              => Ada_Tags,\n      RE_Get_Prim_Op_Kind                 => Ada_Tags,\n-     RE_Get_RC_Offset                    => Ada_Tags,\n-     RE_Get_Remotely_Callable            => Ada_Tags,\n      RE_Get_Tagged_Kind                  => Ada_Tags,\n      RE_Idepth                           => Ada_Tags,\n+     RE_Iface_Tag                        => Ada_Tags,\n      RE_Ifaces_Table                     => Ada_Tags,\n-     RE_Ifaces_Table_Ptr                 => Ada_Tags,\n+     RE_Interfaces_Table                 => Ada_Tags,\n      RE_Interface_Data                   => Ada_Tags,\n-     RE_Interface_Data_Ptr               => Ada_Tags,\n      RE_Interface_Tag                    => Ada_Tags,\n      RE_IW_Membership                    => Ada_Tags,\n      RE_Nb_Ifaces                        => Ada_Tags,\n+     RE_No_Dispatch_Table_Wrapper        => Ada_Tags,\n+     RE_NDT_Prims_Ptr                    => Ada_Tags,\n+     RE_NDT_TSD                          => Ada_Tags,\n+     RE_Num_Prims                        => Ada_Tags,\n      RE_Object_Specific_Data             => Ada_Tags,\n      RE_Offset_To_Top                    => Ada_Tags,\n-     RE_Type_Specific_Data               => Ada_Tags,\n+     RE_Offset_To_Top_Function_Ptr       => Ada_Tags,\n+     RE_OSD_Table                        => Ada_Tags,\n+     RE_OSD_Num_Prims                    => Ada_Tags,\n      RE_POK_Function                     => Ada_Tags,\n      RE_POK_Procedure                    => Ada_Tags,\n      RE_POK_Protected_Entry              => Ada_Tags,\n@@ -1636,34 +1640,29 @@ package Rtsfind is\n      RE_POK_Task_Entry                   => Ada_Tags,\n      RE_POK_Task_Function                => Ada_Tags,\n      RE_POK_Task_Procedure               => Ada_Tags,\n+     RE_Predef_Prims                     => Ada_Tags,\n+     RE_Predef_Prims_Table_Ptr           => Ada_Tags,\n      RE_Prim_Op_Kind                     => Ada_Tags,\n-     RE_Primary_DT                       => Ada_Tags,\n      RE_Prims_Ptr                        => Ada_Tags,\n-     RE_Register_Interface_Tag           => Ada_Tags,\n+     RE_Primary_DT                       => Ada_Tags,\n+     RE_Signature                        => Ada_Tags,\n+     RE_SSD                              => Ada_Tags,\n+     RE_TSD                              => Ada_Tags,\n+     RE_Type_Specific_Data               => Ada_Tags,\n      RE_Register_Tag                     => Ada_Tags,\n-     RE_Remotely_Callable                => Ada_Tags,\n+     RE_Transportable                    => Ada_Tags,\n      RE_RC_Offset                        => Ada_Tags,\n      RE_Secondary_DT                     => Ada_Tags,\n      RE_Select_Specific_Data             => Ada_Tags,\n-     RE_Set_Access_Level                 => Ada_Tags,\n      RE_Set_Entry_Index                  => Ada_Tags,\n-     RE_Set_Expanded_Name                => Ada_Tags,\n-     RE_Set_Num_Prim_Ops                 => Ada_Tags,\n-     RE_Set_Offset_Index                 => Ada_Tags,\n      RE_Set_Offset_To_Top                => Ada_Tags,\n-     RE_Set_OSD                          => Ada_Tags,\n-     RE_Set_Predefined_Prim_Op_Address   => Ada_Tags,\n-     RE_Set_Prim_Op_Address              => Ada_Tags,\n      RE_Set_Prim_Op_Kind                 => Ada_Tags,\n-     RE_Set_RC_Offset                    => Ada_Tags,\n-     RE_Set_Remotely_Callable            => Ada_Tags,\n-     RE_Set_SSD                          => Ada_Tags,\n-     RE_Set_Signature                    => Ada_Tags,\n-     RE_Set_Tagged_Kind                  => Ada_Tags,\n-     RE_Set_TSD                          => Ada_Tags,\n+     RE_Static_Offset_To_Top             => Ada_Tags,\n      RE_Tag                              => Ada_Tags,\n      RE_Tag_Error                        => Ada_Tags,\n+     RE_Tag_Kind                         => Ada_Tags,\n      RE_Tag_Ptr                          => Ada_Tags,\n+     RE_Tag_Table                        => Ada_Tags,\n      RE_Tags_Table                       => Ada_Tags,\n      RE_Tagged_Kind                      => Ada_Tags,\n      RE_Type_Specific_Data_Ptr           => Ada_Tags,\n@@ -1704,6 +1703,8 @@ package Rtsfind is\n      RE_Null_Address                     => System,\n      RE_Priority                         => System,\n \n+     RE_Address_Image                    => System_Address_Image,\n+\n      RE_Add_With_Ovflo_Check             => System_Arith_64,\n      RE_Double_Divide                    => System_Arith_64,\n      RE_Multiply_With_Ovflo_Check        => System_Arith_64,\n@@ -1712,6 +1713,7 @@ package Rtsfind is\n \n      RE_Create_AST_Handler               => System_AST_Handling,\n \n+     RE_Assert_Failure                   => System_Assertions,\n      RE_Raise_Assert_Failure             => System_Assertions,\n \n      RE_AST_Handler                      => System_Aux_DEC,\n@@ -1768,6 +1770,8 @@ package Rtsfind is\n \n      RE_Register_Exception               => System_Exception_Table,\n \n+     RE_Local_Raise                      => System_Exceptions,\n+\n      RE_Exn_Integer                      => System_Exn_Int,\n \n      RE_Exn_Long_Long_Float              => System_Exn_LLF,\n@@ -2336,6 +2340,7 @@ package Rtsfind is\n      RE_Storage_Offset                   => System_Storage_Elements,\n      RE_Storage_Array                    => System_Storage_Elements,\n      RE_To_Address                       => System_Storage_Elements,\n+     RE_Dummy_Communication_Block        => System_Storage_Elements,\n \n      RE_Root_Storage_Pool                => System_Storage_Pools,\n      RE_Allocate_Any                     => System_Storage_Pools,\n@@ -2438,11 +2443,6 @@ package Rtsfind is\n      RE_Get_GNAT_Exception               => System_Soft_Links,\n      RE_Update_Exception                 => System_Soft_Links,\n \n-     RE_ATSD                             => System_Threads,\n-     RE_Thread_Body_Enter                => System_Threads,\n-     RE_Thread_Body_Exceptional_Exit     => System_Threads,\n-     RE_Thread_Body_Leave                => System_Threads,\n-\n      RE_Bits_1                           => System_Unsigned_Types,\n      RE_Bits_2                           => System_Unsigned_Types,\n      RE_Bits_4                           => System_Unsigned_Types,\n@@ -2808,9 +2808,9 @@ package Rtsfind is\n    --  construct.\n \n    function RTE_Available (E : RE_Id) return Boolean;\n-   --  Returns true if a call to RTE will succeed without raising an\n-   --  exception and without generating an error message, i.e. if the\n-   --  call will obtain the desired entity without any problems.\n+   --  Returns true if a call to RTE will succeed without raising an exception\n+   --  and without generating an error message, i.e. if the call will obtain\n+   --  the desired entity without any problems.\n \n    function RTE_Record_Component (E : RE_Id) return Entity_Id;\n    --  Given the entity defined in the above tables, as identified by the"}]}