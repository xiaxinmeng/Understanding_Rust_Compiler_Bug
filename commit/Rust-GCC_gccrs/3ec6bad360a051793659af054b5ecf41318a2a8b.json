{"sha": "3ec6bad360a051793659af054b5ecf41318a2a8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VjNmJhZDM2MGEwNTE3OTM2NTlhZjA1NGI1ZWNmNDEzMThhMmE4Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-05-25T23:27:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-05-25T23:27:18Z"}, "message": "Finish implementation of VTTs.\n\n\t* cp-tree.h (cp_tree_index): Add CPTI_VTT_PARM_TYPE and\n\tCPTI_VTT_PARM_IDENTIFIER.\n\t(vtt_parm_identifier): New macro.\n\t(vtt_parm_type): Likewise.\n\t(BINFO_SUBVTT_INDEX): Likewise.\n\t(BINFO_VPTR_INDEX): Likewise.\n\t(struct lang_decl): Add vtt_parm.\n\t(DECL_VTT_PARM): New macro.\n\t(DECL_USE_VTT_PARM): Likewise.\n\t(DECL_NEEDS_VTT_PARM_P): Likewise.\n\t(get_vtt_name): Declare.\n\t(build_artifical_parm): Likewise.\n\t(fixup_all_virtual_upcast_offsets): Likewise.\n\t(expand_indirect_vtbls_init): Remove.\n\t* call.c (build_new_method_call): Pass the vtt to subobject\n\tconstructors and destructors.\n\t* class.c (get_vtt_name): Give it external linkage.\n\t(build_clone): Handle the magic VTT parameters for clones.\n\t(clone_function_decl): Fix typo in comment.\n\t(build_vtt): Keep track of the indices in the VTTs where various\n\tentities are stored.\n\t(build_vtt_inits): Likewise.\n\t(dfs_build_vtt_inits): Likewise.\n\t(build_ctor_vtbl_group): Tweak type of construction vtables.\n\t(dfs_accumulate_vtbl_inits): Build vtables for all bases, even\n\tprimary bases, when building construction vtables.\n\t* decl.c (duplicate_decls): Handle DECL_VTT_PARM.\n\t(initialize_predefined_identifiers): Add vtt_parm_identifier.\n\t(init_decl_processing): Initialize vtt_parm_type.\n\t(grokfndecl): Use DECL_OVERLOADED_OPERATOR_P.\n\t(lang_mark_tree): Make vtt_parm.\n\t* decl2.c (build_artificial_parm): New function.\n\t(maybe_retrofit_in_chrg): Use it.  Add VTT parameters.\n\t(grokclassfn): Use build_artificial_parm.\n\t* init.c (initialize_vtbl_ptrs): Call\n\tfixup_all_virtual_upcast_offsets directly.\n\t(perform_member_init): Use the complete subobject destructor for\n\tmember cleanups.\n\t(build_vtbl_address): New function.\n\t(expand_virtual_init): Handle VTTs.\n\t* optimize (maybe_clone_body): Likewise.\n\t* search.c (fixup_all_virtual_upcast_offsets): Give it external\n\tlinkage.\n\t(expand_indirect_vtbls_init): Remove.\n\t* semantics.c (setup_vtbl_ptr): Fix typos in comment.\n\t* tree.c (make_binfo): Make them bigger.\n\nFrom-SVN: r34177", "tree": {"sha": "db2ec4264a1fd32d8fe39dfd89a501b714b874ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db2ec4264a1fd32d8fe39dfd89a501b714b874ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ec6bad360a051793659af054b5ecf41318a2a8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec6bad360a051793659af054b5ecf41318a2a8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ec6bad360a051793659af054b5ecf41318a2a8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec6bad360a051793659af054b5ecf41318a2a8b/comments", "author": null, "committer": null, "parents": [{"sha": "a0ee3b83359ace5b2fb7cd0d400d99472e5738c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ee3b83359ace5b2fb7cd0d400d99472e5738c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ee3b83359ace5b2fb7cd0d400d99472e5738c3"}], "stats": {"total": 473, "additions": 403, "deletions": 70}, "files": [{"sha": "33d02bed58446b3966044d290075dbafa8f3dc42", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -1,3 +1,53 @@\n+2000-05-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tFinish implementation of VTTs.\n+\t* cp-tree.h (cp_tree_index): Add CPTI_VTT_PARM_TYPE and\n+\tCPTI_VTT_PARM_IDENTIFIER.\n+\t(vtt_parm_identifier): New macro.\n+\t(vtt_parm_type): Likewise.\n+\t(BINFO_SUBVTT_INDEX): Likewise.\n+\t(BINFO_VPTR_INDEX): Likewise.\n+\t(struct lang_decl): Add vtt_parm.\n+\t(DECL_VTT_PARM): New macro.\n+\t(DECL_USE_VTT_PARM): Likewise.\n+\t(DECL_NEEDS_VTT_PARM_P): Likewise.\n+\t(get_vtt_name): Declare.\n+\t(build_artifical_parm): Likewise.\n+\t(fixup_all_virtual_upcast_offsets): Likewise.\n+\t(expand_indirect_vtbls_init): Remove.\n+\t* call.c (build_new_method_call): Pass the vtt to subobject\n+\tconstructors and destructors.\n+\t* class.c (get_vtt_name): Give it external linkage.\n+\t(build_clone): Handle the magic VTT parameters for clones.\n+\t(clone_function_decl): Fix typo in comment.\n+\t(build_vtt): Keep track of the indices in the VTTs where various\n+\tentities are stored.\n+\t(build_vtt_inits): Likewise.\n+\t(dfs_build_vtt_inits): Likewise.\n+\t(build_ctor_vtbl_group): Tweak type of construction vtables.\n+\t(dfs_accumulate_vtbl_inits): Build vtables for all bases, even\n+\tprimary bases, when building construction vtables.\n+\t* decl.c (duplicate_decls): Handle DECL_VTT_PARM.\n+\t(initialize_predefined_identifiers): Add vtt_parm_identifier.\n+\t(init_decl_processing): Initialize vtt_parm_type.\n+\t(grokfndecl): Use DECL_OVERLOADED_OPERATOR_P.\n+\t(lang_mark_tree): Make vtt_parm.\n+\t* decl2.c (build_artificial_parm): New function.\n+\t(maybe_retrofit_in_chrg): Use it.  Add VTT parameters.\n+\t(grokclassfn): Use build_artificial_parm.\n+\t* init.c (initialize_vtbl_ptrs): Call\n+\tfixup_all_virtual_upcast_offsets directly.\n+\t(perform_member_init): Use the complete subobject destructor for\n+\tmember cleanups.\n+\t(build_vtbl_address): New function.\n+\t(expand_virtual_init): Handle VTTs.\n+\t* optimize (maybe_clone_body): Likewise.\n+\t* search.c (fixup_all_virtual_upcast_offsets): Give it external\n+\tlinkage.\n+\t(expand_indirect_vtbls_init): Remove.\n+\t* semantics.c (setup_vtbl_ptr): Fix typos in comment.\n+\t* tree.c (make_binfo): Make them bigger.\n+\t\n 2000-05-25  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* inc/cxxabi.h (__pbase_type_info): Define, based on"}, {"sha": "a034f5292a64031ae0ced5416dff40463f68e17f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -4321,6 +4321,32 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t     old ABI.  */\n \t  name = constructor_p ? ctor_identifier : dtor_identifier;\n \t}\n+      /* If we're call a subobject constructor or destructor for a\n+\t subobject that uses virtual base classes, then we need to\n+\t pass down a pointer to a VTT for the subobject.  */\n+      else if ((name == base_ctor_identifier\n+\t\t|| name == base_dtor_identifier)\n+\t       && TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n+\t{\n+\t  tree vtt;\n+\t  tree sub_vtt;\n+\n+\t  /* If the current function is a complete object constructor\n+\t     or destructor, then we fetch the VTT directly.\n+\t     Otherwise, we look it up using the VTT we were given.  */\n+\t  vtt = IDENTIFIER_GLOBAL_VALUE (get_vtt_name (current_class_type));\n+\t  vtt = build_unary_op (ADDR_EXPR, vtt, /*noconvert=*/1);\n+\t  vtt = build (COND_EXPR, TREE_TYPE (vtt), \n+\t\t       DECL_USE_VTT_PARM (current_function_decl),\n+\t\t       DECL_VTT_PARM (current_function_decl),\n+\t\t       vtt);\n+\n+\t  sub_vtt = build (PLUS_EXPR, TREE_TYPE (vtt), vtt,\n+\t\t\t   BINFO_SUBVTT_INDEX (basetype_path));\n+\t  sub_vtt = build_indirect_ref (sub_vtt, NULL);\n+\n+\t  args = tree_cons (NULL_TREE, sub_vtt, args);\n+\t}\n     }\n   else\n     pretty_name = name;"}, {"sha": "d865fba5f9912282742545b1c210231c66c4990e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -181,7 +181,7 @@ static void update_vtable_entry_for_fn PARAMS ((tree, tree, tree, tree *));\n static tree copy_virtuals PARAMS ((tree));\n static void build_ctor_vtbl_group PARAMS ((tree, tree));\n static void build_vtt PARAMS ((tree));\n-static tree *build_vtt_inits PARAMS ((tree, tree, tree *));\n+static tree *build_vtt_inits PARAMS ((tree, tree, tree *, tree *));\n static tree dfs_build_vtt_inits PARAMS ((tree, void *));\n static tree dfs_fixup_binfo_vtbls PARAMS ((tree, void *));\n \n@@ -635,7 +635,7 @@ get_vtable_name (type)\n /* Return an IDENTIFIER_NODE for the name of the virtual table table\n    for TYPE.  */\n \n-static tree\n+tree\n get_vtt_name (type)\n      tree type;\n {\n@@ -3957,6 +3957,8 @@ build_clone (fn, name)\n   DECL_PENDING_INLINE_P (clone) = 0;\n   /* And it hasn't yet been deferred.  */\n   DECL_DEFERRED_FN (clone) = 0;\n+  /* There's no magic VTT parameter in the clone.  */\n+  DECL_VTT_PARM (clone) = NULL_TREE;\n \n   /* The base-class destructor is not virtual.  */\n   if (name == base_dtor_identifier)\n@@ -3981,6 +3983,10 @@ build_clone (fn, name)\n       parmtypes = TREE_CHAIN (parmtypes);\n       /* Skip the in-charge parameter.  */\n       parmtypes = TREE_CHAIN (parmtypes);\n+       /* If this is subobject constructor or destructor, add the vtt\n+\t parameter.  */\n+      if (DECL_NEEDS_VTT_PARM_P (clone))\n+\tparmtypes = hash_tree_chain (vtt_parm_type, parmtypes);\n       TREE_TYPE (clone) \n \t= build_cplus_method_type (basetype,\n \t\t\t\t   TREE_TYPE (TREE_TYPE (clone)),\n@@ -4002,6 +4008,18 @@ build_clone (fn, name)\n \t    = TREE_CHAIN (TREE_CHAIN (DECL_ARGUMENTS (clone)));\n \t  DECL_HAS_IN_CHARGE_PARM_P (clone) = 0;\n \t}\n+\n+      /* Add the VTT parameter.  */\n+      if (DECL_NEEDS_VTT_PARM_P (clone))\n+\t{\n+\t  tree parm;\n+\n+\t  parm = build_artificial_parm (vtt_parm_identifier,\n+\t\t\t\t\tvtt_parm_type);\n+\t  TREE_CHAIN (parm) = TREE_CHAIN (DECL_ARGUMENTS (clone));\n+\t  TREE_CHAIN (DECL_ARGUMENTS (clone)) = parm;\n+\t}\n+\n       for (parms = DECL_ARGUMENTS (clone); parms; parms = TREE_CHAIN (parms))\n \t{\n \t  DECL_CONTEXT (parms) = clone;\n@@ -4063,7 +4081,7 @@ clone_function_decl (fn, update_method_vec_p)\n     {\n       my_friendly_assert (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn), 20000411);\n \n-      /* For each destructor, we need two variants: an in-charge\n+      /* For each destructor, we need three variants: an in-charge\n \t version, a not-in-charge version, and an in-charge deleting\n \t version.  We clone the deleting version first because that\n \t means it will go second on the TYPE_METHODS list -- and that\n@@ -6474,14 +6492,16 @@ build_vtt (t)\n   tree inits;\n   tree type;\n   tree vtt;\n+  tree index;\n \n   /* Under the old ABI, we don't use VTTs.  */\n   if (!flag_new_abi)\n     return;\n \n   /* Build up the initializers for the VTT.  */\n   inits = NULL_TREE;\n-  build_vtt_inits (TYPE_BINFO (t), t, &inits);\n+  index = size_zero_node;\n+  build_vtt_inits (TYPE_BINFO (t), t, &inits, &index);\n \n   /* If we didn't need a VTT, we're done.  */\n   if (!inits)\n@@ -6499,13 +6519,15 @@ build_vtt (t)\n \n /* Recursively build the VTT-initializer for BINFO (which is in the\n    hierarchy dominated by T).  INITS points to the end of the\n-   initializer list to date.  */\n+   initializer list to date.  INDEX is the VTT index where the next\n+   element will be placed.  */\n \n static tree *\n-build_vtt_inits (binfo, t, inits)\n+build_vtt_inits (binfo, t, inits, index)\n      tree binfo;\n      tree t;\n      tree *inits;\n+     tree *index;\n {\n   int i;\n   tree b;\n@@ -6521,35 +6543,45 @@ build_vtt_inits (binfo, t, inits)\n      VTT.  */\n   ctor_vtbl_p = !same_type_p (TREE_TYPE (binfo), t);\n   if (ctor_vtbl_p)\n-    build_ctor_vtbl_group (binfo, t);\n+    {\n+      build_ctor_vtbl_group (binfo, t);\n+\n+      /* Record the offset in the VTT where this sub-VTT can be found.  */\n+      BINFO_SUBVTT_INDEX (binfo) = *index;\n+    }\n \n   /* Add the address of the primary vtable for the complete object.  */\n   init = BINFO_VTABLE (binfo);\n   if (TREE_CODE (init) == TREE_LIST)\n     init = TREE_PURPOSE (init);\n   *inits = build_tree_list (NULL_TREE, init);\n   inits = &TREE_CHAIN (*inits);\n-\n+  BINFO_VPTR_INDEX (binfo) = *index;\n+  *index = size_binop (PLUS_EXPR, *index, TYPE_SIZE_UNIT (ptr_type_node));\n+\t\t       \n   /* Recursively add the secondary VTTs for non-virtual bases.  */\n   for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n     {\n       b = BINFO_BASETYPE (binfo, i);\n       if (!TREE_VIA_VIRTUAL (b))\n-\tinits = build_vtt_inits (BINFO_BASETYPE (binfo, i), t, inits);\n+\tinits = build_vtt_inits (BINFO_BASETYPE (binfo, i), t, inits,\n+\t\t\t\t index);\n     }\n-\n+      \n   /* Add secondary virtual pointers for all subobjects of BINFO with\n      either virtual bases or virtual functions overridden along a\n      virtual path between the declaration and D, except subobjects\n      that are non-virtual primary bases.  */\n   secondary_vptrs = build_tree_list (BINFO_TYPE (binfo), NULL_TREE);\n+  TREE_TYPE (secondary_vptrs) = *index;\n   dfs_walk_real (binfo,\n \t\t dfs_build_vtt_inits,\n \t\t NULL,\n \t\t dfs_unmarked_real_bases_queue_p,\n \t\t secondary_vptrs);\n   dfs_walk (binfo, dfs_fixup_binfo_vtbls, dfs_marked_real_bases_queue_p,\n \t    BINFO_TYPE (binfo));\n+  *index = TREE_TYPE (secondary_vptrs);\n \n   /* The secondary vptrs come back in reverse order.  After we reverse\n      them, and add the INITS, the last init will be the first element\n@@ -6571,7 +6603,7 @@ build_vtt_inits (binfo, t, inits)\n \tcontinue;\n \n       vbase = binfo_for_vbase (BINFO_TYPE (b), t);\n-      inits = build_vtt_inits (vbase, t, inits);\n+      inits = build_vtt_inits (vbase, t, inits, index);\n     }\n \n   return inits;\n@@ -6587,6 +6619,7 @@ dfs_build_vtt_inits (binfo, data)\n   tree l; \n   tree t;\n   tree init;\n+  tree index;\n \n   l = (tree) data;\n   t = TREE_PURPOSE (l);\n@@ -6612,13 +6645,18 @@ dfs_build_vtt_inits (binfo, data)\n     /* FIXME: Implement this.  */\n     ;\n \n-  /* Add the initializer for this secondary vptr.  */\n+  /* Record the index where this secondary vptr can be found.  */\n+  index = TREE_TYPE (l);\n+  BINFO_VPTR_INDEX (binfo) = index;\n+  TREE_TYPE (l) = size_binop (PLUS_EXPR, index, \n+\t\t\t      TYPE_SIZE_UNIT (ptr_type_node));\n+\n+  /* Add the initializer for the secondary vptr itself.  */\n   init = BINFO_VTABLE (binfo);\n   if (TREE_CODE (init) == TREE_LIST)\n     init = TREE_PURPOSE (init);\n-\n   TREE_VALUE (l) = tree_cons (NULL_TREE, init, TREE_VALUE (l));\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -6665,7 +6703,7 @@ build_ctor_vtbl_group (binfo, t)\n   /* Build a version of VTBL (with the wrong type) for use in\n      constructing the addresses of secondary vtables in the\n      construction vtable group.  */\n-  vtbl = build_vtable (BINFO_TYPE (binfo), id, vtable_entry_type);\n+  vtbl = build_vtable (BINFO_TYPE (binfo), id, ptr_type_node);\n   list = build_tree_list (vtbl, NULL_TREE);\n   accumulate_vtbl_inits (binfo, TYPE_BINFO (TREE_TYPE (binfo)),\n \t\t\t binfo, t, list);\n@@ -6762,7 +6800,7 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n   if (BINFO_NEW_VTABLE_MARKED (binfo, t)\n       /* We need a new vtable, even for a primary base, when we're\n \t building a construction vtable.  */\n-      || (ctor_vtbl_p && orig_binfo == rtti_binfo))\n+      || (ctor_vtbl_p && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))))\n     {\n       tree vtbl;\n       tree index;"}, {"sha": "d935c351c93814e94576d876b01389866d658dc4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -530,6 +530,7 @@ enum cp_tree_index\n     CPTI_DELTA_TYPE,\n     CPTI_VTABLE_INDEX_TYPE,\n     CPTI_CLEANUP_TYPE,\n+    CPTI_VTT_PARM_TYPE,\n \n     CPTI_TI_DESC_TYPE,\n     CPTI_BLTN_DESC_TYPE,\n@@ -578,6 +579,7 @@ enum cp_tree_index\n     CPTI_DELTA2_IDENTIFIER,\n     CPTI_DELTA_IDENTIFIER,\n     CPTI_IN_CHARGE_IDENTIFIER,\n+    CPTI_VTT_PARM_IDENTIFIER,\n     CPTI_INDEX_IDENTIFIER,\n     CPTI_NELTS_IDENTIFIER,\n     CPTI_THIS_IDENTIFIER,\n@@ -690,6 +692,11 @@ extern tree cp_global_trees[CPTI_MAX];\n #define delta2_identifier               cp_global_trees[CPTI_DELTA2_IDENTIFIER]\n #define delta_identifier                cp_global_trees[CPTI_DELTA_IDENTIFIER]\n #define in_charge_identifier            cp_global_trees[CPTI_IN_CHARGE_IDENTIFIER]\n+\n+/* The name of the parameter that contains a pointer to the VTT to use\n+   for this subobject constructor or destructor.  */\n+#define vtt_parm_identifier             cp_global_trees[CPTI_VTT_PARM_IDENTIFIER]\n+\n #define index_identifier                cp_global_trees[CPTI_INDEX_IDENTIFIER]\n #define nelts_identifier                cp_global_trees[CPTI_NELTS_IDENTIFIER]\n #define this_identifier                 cp_global_trees[CPTI_THIS_IDENTIFIER]\n@@ -731,6 +738,10 @@ extern tree cp_global_trees[CPTI_MAX];\n /* The type of a destructor.  */\n #define cleanup_type                    cp_global_trees[CPTI_CLEANUP_TYPE]\n \n+/* The type of the vtt parameter passed to subobject constructors and\n+   destructors.  */\n+#define vtt_parm_type                   cp_global_trees[CPTI_VTT_PARM_TYPE]\n+\n /* Global state.  */\n \n struct stmt_tree {\n@@ -1755,6 +1766,14 @@ struct lang_type\n    is primary *somewhere* in the hierarchy.  */\n #define BINFO_VBASE_PRIMARY_P(NODE) TREE_LANG_FLAG_6 (NODE)\n \n+/* The index in the VTT where this subobject's sub-VTT can be found.\n+   NULL_TREE if there is no sub-VTT.  */\n+#define BINFO_SUBVTT_INDEX(NODE) TREE_VEC_ELT ((NODE), 8)\n+\n+/* The index in the VTT where the vptr for this subobject can be\n+   found.  NULL_TREE if there is no secondary vptr in the VTT.  */\n+#define BINFO_VPTR_INDEX(NODE) TREE_VEC_ELT ((NODE), 9)\n+\n /* Used by various search routines.  */\n #define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)\n \f\n@@ -1884,6 +1903,9 @@ struct lang_decl\n   /* In a FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n   tree cloned_function;\n \n+  /* In a FUNCTION_DECL, this is VTT_PARM.  */\n+  tree vtt_parm;\n+\n   union\n   {\n     tree sorted_fields;\n@@ -1972,6 +1994,25 @@ struct lang_decl\n #define DECL_CLONED_FUNCTION(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->cloned_function)\n \n+/* In a maybe-in-charge constructor or destructor, this is the VTT\n+   parameter.  It's not actually on the DECL_ARGUMENTS list.  */\n+#define DECL_VTT_PARM(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->vtt_parm)\n+\n+/* If there's a DECL_VTT_PARM, this is a magic variable that indicates\n+   whether or not the VTT parm should be used.  In a subobject\n+   constructor, `true' is substituted for this value; in a complete\n+   object constructor, `false' is substituted instead.  */\n+#define DECL_USE_VTT_PARM(NODE) \\\n+  (TREE_CHAIN (DECL_VTT_PARM (NODE)))\n+\n+/* Non-zero if NODE is a FUNCTION_DECL for which a VTT parameter is\n+   required.  */\n+#define DECL_NEEDS_VTT_PARM_P(NODE)\t\t\t\\\n+  (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (NODE))\t\\\n+   && (DECL_BASE_CONSTRUCTOR_P (NODE)\t\t\t\\\n+       || DECL_BASE_DESTRUCTOR_P (NODE)))\n+\n /* Non-zero if NODE is a user-defined conversion operator.  */\n #define DECL_CONV_FN_P(NODE) \\\n   (IDENTIFIER_TYPENAME_P (DECL_NAME (NODE)))\n@@ -3820,6 +3861,7 @@ extern void maybe_note_name_used_in_class       PARAMS ((tree, tree));\n extern void note_name_declared_in_class         PARAMS ((tree, tree));\n extern tree get_vtbl_decl_for_binfo             PARAMS ((tree));\n extern tree in_charge_arg_for_name              PARAMS ((tree));\n+extern tree get_vtt_name                        PARAMS ((tree));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPARAMS ((tree, tree, int, int, tree));\n@@ -4054,6 +4096,7 @@ extern void mark_used\t\t\t\tPARAMS ((tree));\n extern tree handle_class_head\t\t\tPARAMS ((tree, tree, tree));\n extern tree lookup_arg_dependent                PARAMS ((tree, tree, tree));\n extern void finish_static_data_member_decl      PARAMS ((tree, tree, tree, int));\n+extern tree build_artificial_parm               PARAMS ((tree, tree));\n \n /* in parse.y */\n extern void cp_parse_init\t\t\tPARAMS ((void));\n@@ -4303,7 +4346,6 @@ extern tree lookup_nested_tag\t\t\tPARAMS ((tree, tree));\n extern tree get_matching_virtual\t\tPARAMS ((tree, tree, int));\n extern void get_pure_virtuals\t\t        PARAMS ((tree));\n extern tree init_vbase_pointers\t\t\tPARAMS ((tree, tree));\n-extern void expand_indirect_vtbls_init\t\tPARAMS ((tree));\n extern void get_vbase_types\t\t\tPARAMS ((tree));\n extern void maybe_suppress_debug_info\t\tPARAMS ((tree));\n extern void note_debug_info_needed\t\tPARAMS ((tree));\n@@ -4340,6 +4382,7 @@ extern tree unmarked_vtable_pathp               PARAMS ((tree, void *));\n extern tree convert_pointer_to_vbase            PARAMS ((tree, tree));\n extern tree find_vbase_instance                 PARAMS ((tree, tree));\n extern tree binfo_for_vbase                     PARAMS ((tree, tree));\n+extern void fixup_all_virtual_upcast_offsets    PARAMS ((tree));\n \n /* in semantics.c */\n extern void finish_expr_stmt                    PARAMS ((tree));"}, {"sha": "5704a17217050a9e95dbc07b34cf1080a1864769", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -3369,6 +3369,7 @@ duplicate_decls (newdecl, olddecl)\n       DECL_VIRTUAL_P (newdecl) |= DECL_VIRTUAL_P (olddecl);\n       DECL_NEEDS_FINAL_OVERRIDER_P (newdecl) |= DECL_NEEDS_FINAL_OVERRIDER_P (olddecl);\n       DECL_THIS_STATIC (newdecl) |= DECL_THIS_STATIC (olddecl);\n+      DECL_VTT_PARM (newdecl) = DECL_VTT_PARM (olddecl);\n       new_defines_function = DECL_INITIAL (newdecl) != NULL_TREE;\n \n       /* Optionally warn about more than one declaration for the same\n@@ -6074,6 +6075,7 @@ initialize_predefined_identifiers ()\n     { \"__pfn_or_delta2\", &pfn_or_delta2_identifier, 0 },\n     { \"_vptr\", &vptr_identifier, 0 },\n     { \"__cp_push_exception\", &cp_push_exception_identifier, 0 },\n+    { \"__vtt_parm\", &vtt_parm_identifier, 0 },\n     { NULL, NULL, 0 }\n   };\n \n@@ -6325,6 +6327,7 @@ init_decl_processing ()\n   const_ptr_type_node\n     = build_pointer_type (build_qualified_type (void_type_node,\n \t\t\t\t\t\tTYPE_QUAL_CONST));\n+  vtt_parm_type = build_pointer_type (const_ptr_type_node);\n   c_common_nodes_and_builtins (1, flag_no_builtin, flag_no_nonansi_builtin);\n   lang_type_promotes_to = convert_type_from_ellipsis;\n \n@@ -8740,7 +8743,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n       quals = NULL_TREE;\n     }\n \n-  if (IDENTIFIER_OPNAME_P (DECL_NAME (decl)))\n+  if (DECL_OVERLOADED_OPERATOR_P (decl))\n     grok_op_properties (decl, virtualp, check < 0);\n \n   if (ctype && decl_function_context (decl))\n@@ -14744,6 +14747,7 @@ lang_mark_tree (t)\n \t      ggc_mark_tree (ld->befriending_classes);\n \t      ggc_mark_tree (ld->saved_tree);\n \t      ggc_mark_tree (ld->cloned_function);\n+\t      ggc_mark_tree (ld->vtt_parm);\n \t      if (TREE_CODE (t) == TYPE_DECL)\n \t\tggc_mark_tree (ld->u.sorted_fields);\n \t      else if (TREE_CODE (t) == FUNCTION_DECL"}, {"sha": "315e3c86e7b43018b425e4e030ee86c1701f1176", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -924,6 +924,22 @@ grok_x_components (specs)\n       break;\n }\n \n+/* Returns a PARM_DECL for a parameter of the indicated TYPE, with the\n+   indicated NAME.  */\n+\n+tree\n+build_artificial_parm (name, type)\n+     tree name;\n+     tree type;\n+{\n+  tree parm;\n+\n+  parm = build_decl (PARM_DECL, name, type);\n+  SET_DECL_ARTIFICIAL (parm);\n+  DECL_ARG_TYPE (parm) = type;\n+  return parm;\n+}\n+\n /* Constructors for types with virtual baseclasses need an \"in-charge\" flag\n    saying whether this constructor is responsible for initialization of\n    virtual baseclasses or not.  All destructors also need this \"in-charge\"\n@@ -956,10 +972,7 @@ maybe_retrofit_in_chrg (fn)\n     return;\n \n   /* First add it to DECL_ARGUMENTS...  */\n-  parm = build_decl (PARM_DECL, in_charge_identifier, integer_type_node);\n-  /* Mark the artificial `__in_chrg' parameter as \"artificial\".  */\n-  SET_DECL_ARTIFICIAL (parm);\n-  DECL_ARG_TYPE (parm) = integer_type_node;\n+  parm = build_artificial_parm (in_charge_identifier, integer_type_node);\n   TREE_READONLY (parm) = 1;\n   parms = DECL_ARGUMENTS (fn);\n   TREE_CHAIN (parm) = TREE_CHAIN (parms);\n@@ -978,6 +991,18 @@ maybe_retrofit_in_chrg (fn)\n \n   /* Now we've got the in-charge parameter.  */\n   DECL_HAS_IN_CHARGE_PARM_P (fn) = 1;\n+\n+  /* If this is a subobject constructor or destructor, our caller will\n+     pass us a pointer to our VTT.  */\n+  if (flag_new_abi && TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n+    {\n+      DECL_VTT_PARM (fn) = build_artificial_parm (vtt_parm_identifier, \n+\t\t\t\t\t\t  vtt_parm_type);\n+      DECL_CONTEXT (DECL_VTT_PARM (fn)) = fn;\n+      DECL_USE_VTT_PARM (fn) = build_artificial_parm (NULL_TREE,\n+\t\t\t\t\t\t      boolean_type_node);\n+      DECL_CONTEXT (DECL_USE_VTT_PARM (fn)) = fn;\n+    }\n }\n \n /* Classes overload their constituent function names automatically.\n@@ -1032,12 +1057,9 @@ grokclassfn (ctype, function, flags, quals)\n \t assigned to.  */\n       this_quals |= TYPE_QUAL_CONST;\n       qual_type = cp_build_qualified_type (type, this_quals);\n-      parm = build_decl (PARM_DECL, this_identifier, qual_type);\n+      parm = build_artificial_parm (this_identifier, qual_type);\n       c_apply_type_quals_to_decl (this_quals, parm);\n \n-      /* Mark the artificial `this' parameter as \"artificial\".  */\n-      SET_DECL_ARTIFICIAL (parm);\n-      DECL_ARG_TYPE (parm) = type;\n       /* We can make this a register, so long as we don't\n \t accidentally complain if someone tries to take its address.  */\n       DECL_REGISTER (parm) = 1;"}, {"sha": "cc5be91c79efe887db4d33898e7112d955127bb5", "filename": "gcc/cp/init.c", "status": "modified", "additions": 66, "deletions": 15, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -53,6 +53,7 @@ static tree build_new_1\tPARAMS ((tree));\n static tree get_cookie_size PARAMS ((tree));\n static tree build_dtor_call PARAMS ((tree, special_function_kind, int));\n static tree build_field_list PARAMS ((tree, tree, int *));\n+static tree build_vtbl_address PARAMS ((tree));\n \n /* Set up local variable for this file.  MUST BE CALLED AFTER\n    INIT_DECL_PROCESSING.  */\n@@ -172,7 +173,14 @@ initialize_vtbl_ptrs (addr)\n \t\t NULL, dfs_unmarked_real_bases_queue_p, list);\n   dfs_walk (TYPE_BINFO (type), dfs_unmark,\n \t    dfs_marked_real_bases_queue_p, type);\n-  expand_indirect_vtbls_init (addr);\n+\n+  /* If we're not using thunks, we may need to adjust the deltas in\n+     the vtable to handle virtual base classes correctly.  When we are\n+     using thunks, we either use construction vtables (which are\n+     preloaded with the right answers) or nothing (in which case\n+     vitual function calls sometimes don't work right.)  */\n+  if (TYPE_USES_VIRTUAL_BASECLASSES (type) && !flag_vtable_thunks)\n+    fixup_all_virtual_upcast_offsets (addr);\n }\n \n /* Subroutine of emit_base_init.  */\n@@ -276,7 +284,7 @@ perform_member_init (member, init, explicit)\n \n       expr = build_component_ref (current_class_ref, member, NULL_TREE,\n \t\t\t\t  explicit);\n-      expr = build_delete (type, expr, sfk_base_destructor,\n+      expr = build_delete (type, expr, sfk_complete_destructor,\n \t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n \n       if (expr != error_mark_node)\n@@ -726,6 +734,32 @@ emit_base_init ()\n     }\n }\n \n+/* Returns the address of the vtable (i.e., the value that should be\n+   assigned to the vptr) for BINFO.  */\n+\n+static tree\n+build_vtbl_address (binfo)\n+     tree binfo;\n+{\n+  tree vtbl;\n+\n+  /* Figure out what vtable BINFO's vtable is based on, and mark it as\n+     used.  */\n+  vtbl = get_vtbl_decl_for_binfo (binfo);\n+  assemble_external (vtbl);\n+  TREE_USED (vtbl) = 1;\n+\n+  /* Now compute the address to use when initializing the vptr.  */\n+  vtbl = BINFO_VTABLE (binfo);\n+  if (TREE_CODE (vtbl) == VAR_DECL)\n+    {\n+      vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n+      TREE_CONSTANT (vtbl) = 1;\n+    }\n+\n+  return vtbl;\n+}\n+\n /* This code sets up the virtual function tables appropriate for\n    the pointer DECL.  It is a one-ply initialization.\n \n@@ -739,23 +773,40 @@ expand_virtual_init (binfo, decl)\n   tree type = BINFO_TYPE (binfo);\n   tree vtbl, vtbl_ptr;\n   tree vtype, vtype_binfo;\n-  tree b;\n+  tree vtt_index;\n \n   /* Compute the location of the vtable.  */\n   vtype = DECL_CONTEXT (TYPE_VFIELD (type));\n   vtype_binfo = get_binfo (vtype, TREE_TYPE (TREE_TYPE (decl)), 0);\n-  b = binfo_value (DECL_FIELD_CONTEXT (TYPE_VFIELD (type)), binfo);\n-\n-  /* Figure out what vtable BINFO's vtable is based on, and mark it as\n-     used.  */\n-  vtbl = get_vtbl_decl_for_binfo (b);\n-  assemble_external (vtbl);\n-  TREE_USED (vtbl) = 1;\n-\n-  /* Now compute the address to use when initializing the vptr.  */\n-  vtbl = BINFO_VTABLE (b);\n-  if (TREE_CODE (vtbl) == VAR_DECL)\n-    vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n+  \n+  /* Compute the initializer for vptr.  */\n+  vtbl = build_vtbl_address (binfo);\n+\n+  /* Under the new ABI, we may get this vptr from a VTT, if this is a\n+     subobject constructor or subobject destructor.  */\n+  vtt_index = BINFO_VPTR_INDEX (binfo);\n+  if (vtt_index)\n+    {\n+      tree vtbl2;\n+      tree vtt_parm;\n+\n+      /* Compute the value to use, when there's a VTT.  */\n+      vtt_parm = DECL_VTT_PARM (current_function_decl);\n+      vtbl2 = build (PLUS_EXPR, \n+\t\t     TREE_TYPE (vtt_parm), \n+\t\t     vtt_parm,\n+\t\t     vtt_index);\n+      vtbl2 = build1 (INDIRECT_REF, TREE_TYPE (vtbl), vtbl2);\n+\n+      /* The actual initializer is the VTT value only in the subobject\n+\t constructor.  In maybe_clone_body we'll substitute NULL for\n+\t the vtt_parm in the case of the non-subobject constructor.  */\n+      vtbl = build (COND_EXPR, \n+\t\t    TREE_TYPE (vtbl), \n+\t\t    DECL_USE_VTT_PARM (current_function_decl),\n+\t\t    vtbl2, \n+\t\t    vtbl);\n+    }\n \n   /* Compute the location of the vtpr.  */\n   decl = convert_pointer_to_real (vtype_binfo, decl);"}, {"sha": "52292ffbcf1929a426f9c62fe8607508b576e5f2", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -902,6 +902,10 @@ maybe_clone_body (fn)\n       DECL_SOURCE_LINE (clone) = DECL_SOURCE_LINE (fn);\n       DECL_INLINE (clone) = DECL_INLINE (fn);\n       DECL_THIS_INLINE (clone) = DECL_THIS_INLINE (fn);\n+      DECL_COMDAT (clone) = DECL_COMDAT (fn);\n+      DECL_WEAK (clone) = DECL_WEAK (fn);\n+      DECL_ONE_ONLY (clone) = DECL_ONE_ONLY (fn);\n+      DECL_SECTION_NAME (clone) = DECL_SECTION_NAME (fn);\n \n       /* Start processing the function.  */\n       push_to_top_level ();\n@@ -934,7 +938,31 @@ maybe_clone_body (fn)\n \t      in_charge = in_charge_arg_for_name (DECL_NAME (clone));\n \t      splay_tree_insert (id.decl_map,\n \t\t\t\t (splay_tree_key) parm,\n-\t\t\t\t (splay_tree_key) in_charge);\n+\t\t\t\t (splay_tree_value) in_charge);\n+\n+\t      /* For a subobject constructor or destructor, the next\n+\t\t argument is the VTT parameter.  Remap the VTT_PARM\n+\t\t from the CLONE to this parameter.  */\n+\t      if (DECL_NEEDS_VTT_PARM_P (clone))\n+\t\t{\n+\t\t  splay_tree_insert (id.decl_map,\n+\t\t\t\t     (splay_tree_key) DECL_VTT_PARM (fn),\n+\t\t\t\t     (splay_tree_value) clone_parm);\n+\t\t  splay_tree_insert (id.decl_map,\n+\t\t\t\t     (splay_tree_key) DECL_USE_VTT_PARM (fn),\n+\t\t\t\t     (splay_tree_value) boolean_true_node);\n+\t\t  clone_parm = TREE_CHAIN (clone_parm);\n+\t\t}\n+\t      /* Otherwise, map the VTT parameter to `NULL'.  */\n+\t      else if (DECL_VTT_PARM (fn))\n+\t\t{\n+\t\t  splay_tree_insert (id.decl_map,\n+\t\t\t\t     (splay_tree_key) DECL_VTT_PARM (fn),\n+\t\t\t\t     (splay_tree_value) null_pointer_node);\n+\t\t  splay_tree_insert (id.decl_map,\n+\t\t\t\t     (splay_tree_key) DECL_USE_VTT_PARM (fn),\n+\t\t\t\t     (splay_tree_value) boolean_false_node);\n+\t\t}\n \t    }\n \t  /* Map other parameters to their equivalents in the cloned\n \t     function.  */"}, {"sha": "1160cd4b6a0a0d3f6a5f7cccc4b8d506e81c4e4b", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -144,7 +144,6 @@ static int protected_accessible_p PARAMS ((tree, tree, tree));\n static int friend_accessible_p PARAMS ((tree, tree, tree));\n static void setup_class_bindings PARAMS ((tree, int));\n static int template_self_reference_p PARAMS ((tree, tree));\n-static void fixup_all_virtual_upcast_offsets PARAMS ((tree, tree));\n static tree get_shared_vbase_if_not_primary PARAMS ((tree, void *));\n static tree dfs_find_vbase_instance PARAMS ((tree, void *));\n static tree dfs_get_pure_virtuals PARAMS ((tree, void *));\n@@ -2770,14 +2769,14 @@ fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, ori\n /* Fixup all the virtual upcast offsets for TYPE.  DECL_PTR is the\n    address of the sub-object being initialized.  */\n \n-static void\n-fixup_all_virtual_upcast_offsets (type, decl_ptr)\n-     tree type;\n+void\n+fixup_all_virtual_upcast_offsets (decl_ptr)\n      tree decl_ptr;\n {\n   tree if_stmt;\n   tree in_charge_node;\n   tree vbases;\n+  tree type;\n \n   /* Only tweak the vtables if we're in charge.  */\n   in_charge_node = current_in_charge_parm;\n@@ -2791,6 +2790,7 @@ fixup_all_virtual_upcast_offsets (type, decl_ptr)\n   \n   /* Iterate through the virtual bases, fixing up the upcast offset\n      for each one.  */\n+  type = TREE_TYPE (TREE_TYPE (decl_ptr));\n   for (vbases = CLASSTYPE_VBASECLASSES (type);\n        vbases;\n        vbases = TREE_CHAIN (vbases))\n@@ -2820,22 +2820,6 @@ fixup_all_virtual_upcast_offsets (type, decl_ptr)\n   finish_if_stmt ();\n }\n \n-/* Generate the code needed to initialize all the virtual function\n-   table slots of all the virtual baseclasses.  ADDR points to the\n-   address of the complete object we are initializing.  */\n-\n-void\n-expand_indirect_vtbls_init (addr)\n-     tree addr;\n-{\n-  tree type;\n-\n-  type = TREE_TYPE (TREE_TYPE (addr));\n-\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n-    fixup_all_virtual_upcast_offsets (type, addr);\n-}\n-\n /* get virtual base class types.\n    This adds type to the vbase_types list in reverse dfs order.\n    Ordering is very important, so don't change it.  */"}, {"sha": "77728ba40c7a519d2e0a61391954f46d6b2091b6", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -1257,15 +1257,15 @@ setup_vtbl_ptr ()\n       tree compound_stmt;\n       int saved_cfnd;\n \n-      /* If the dtor is empty, and we know there is not possible way we\n-\t could use any vtable entries, before they are possibly set by\n-\t a base class dtor, we don't have to setup the vtables, as we\n-\t know that any base class dtoring will set up any vtables it\n-\t needs.  We avoid MI, because one base class dtor can do a\n+      /* If the dtor is empty, and we know there is not any possible\n+\t way we could use any vtable entries, before they are possibly\n+\t set by a base class dtor, we don't have to setup the vtables,\n+\t as we know that any base class dtor will set up any vtables\n+\t it needs.  We avoid MI, because one base class dtor can do a\n \t virtual dispatch to an overridden function that would need to\n \t have a non-related vtable set up, we cannot avoid setting up\n-\t vtables in that case.  We could change this to see if there is\n-\t just one vtable.  */\n+\t vtables in that case.  We could change this to see if there\n+\t is just one vtable.  */\n       if_stmt = begin_if_stmt ();\n \n       /* If it is not safe to avoid setting up the vtables, then"}, {"sha": "646a892fe79bc76cf4d3a228741bcdb7cab294df", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -847,7 +847,7 @@ make_binfo (offset, binfo, vtable, virtuals)\n      tree offset, binfo;\n      tree vtable, virtuals;\n {\n-  tree new_binfo = make_tree_vec (8);\n+  tree new_binfo = make_tree_vec (10);\n   tree type;\n \n   if (TREE_CODE (binfo) == TREE_VEC)"}, {"sha": "99a38674e4701bb46badd17c1f8b1c5bdf898847", "filename": "gcc/testsuite/g++.old-deja/g++.other/vbase1.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvbase1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvbase1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvbase1.C?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -0,0 +1,51 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+// Special g++ Options: -w\n+\n+int result;\n+\n+struct A {\n+  A ();\n+\n+  int i;\n+};\n+\n+A* ap;\n+\n+A::A ()\n+{\n+  ap = this;\n+}\n+\n+struct B : virtual public A\n+{\n+  B ();\n+  ~B ();\n+\n+  int j;\n+};\n+\n+B::B () {\n+  if ((A*) this != ap)\n+    result = 1;\n+}\n+\n+B::~B () {\n+  if ((A*) this != ap)\n+    result = 1;\n+}\n+\n+struct C : public B {\n+};\n+\n+struct D : public C, public B\n+{\n+};\n+\n+int main ()\n+{\n+  {\n+    D d;\n+  }\n+\n+  return result;\n+}"}, {"sha": "2f15249b41815cae257ac296e64dc68c8ddc6c6e", "filename": "gcc/testsuite/g++.old-deja/g++.other/vbase2.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvbase2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec6bad360a051793659af054b5ecf41318a2a8b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvbase2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvbase2.C?ref=3ec6bad360a051793659af054b5ecf41318a2a8b", "patch": "@@ -0,0 +1,36 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+int i;\n+\n+struct A\n+{\n+  ~A ();\n+};\n+\n+A::~A () {\n+  i = 1;\n+}\n+\n+struct B : virtual public A {\n+};\n+\n+struct C {\n+  C ();\n+\n+  B b;\n+};\n+\n+C::C () {\n+  throw 3;\n+}\n+\n+int main () \n+{\n+  try { \n+    C c;\n+  } catch (...) {\n+  }\n+\n+  if (i != 1)\n+    return 1;\n+}"}]}