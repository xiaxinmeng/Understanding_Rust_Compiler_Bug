{"sha": "6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI2ZDhmMzhmN2IzYmQ4YTJmNGU0ZGJlYjMwMTRiYTEzMzlhZmE4OQ==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2017-12-21T16:39:43Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2017-12-21T16:39:43Z"}, "message": "[patch AArch64] Do not perform a vector splat for vector initialisation if it is not useful\n\nOur current vector initialisation code will first duplicate\nthe first element to both lanes, then overwrite the top lane with a new\nvalue.\n\nThis duplication can be clunky and wasteful.\n\nBetter would be to simply use the fact that we will always be overwriting\nthe remaining bits, and simply move the first element to the corrcet place\n(implicitly zeroing all other bits).\n\nWe also need a new pattern in simplify-rtx.c:simplify_ternary_operation ,\nto ensure we can still simplify:\n\n  (vec_merge:OUTER\n     (vec_duplicate:OUTER x:INNER)\n     (subreg:OUTER y:INNER 0)\n     (const_int N))\n\nTo:\n\n  (vec_concat:OUTER x:INNER y:INNER) or (vec_concat y x)\n\n\n---\ngcc/\n\n\t* config/aarch64/aarch64.c (aarch64_expand_vector_init): Modify code\n\tgeneration for cases where splatting a value is not useful.\n\t* simplify-rtx.c (simplify_ternary_operation): Simplify vec_merge\n\tacross a vec_duplicate and a paradoxical subreg forming a vector\n\tmode to a vec_concat.\n\ngcc/testsuite/\n\n\t* gcc.target/aarch64/vect-slp-dup.c: New.\n\nFrom-SVN: r255946", "tree": {"sha": "a26bfcca0fadf5099804a4c2887409b687957d8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a26bfcca0fadf5099804a4c2887409b687957d8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c587c0a9c8cbe80a64461fe9cab0a23d3ff35211", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c587c0a9c8cbe80a64461fe9cab0a23d3ff35211", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c587c0a9c8cbe80a64461fe9cab0a23d3ff35211"}], "stats": {"total": 131, "additions": 128, "deletions": 3}, "files": [{"sha": "d3c4063a5ce784992492f7b2ac7e3f6ad7afb44b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89", "patch": "@@ -1,3 +1,11 @@\n+2017-12-21  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_expand_vector_init): Modify code\n+\tgeneration for cases where splatting a value is not useful.\n+\t* simplify-rtx.c (simplify_ternary_operation): Simplify vec_merge\n+\tacross a vec_duplicate and a paradoxical subreg forming a vector\n+\tmode to a vec_concat.\n+\n 2017-12-21  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* combine.c (simplify_set): Do not transform subregs to zero_extends"}, {"sha": "1da313f57e0eed4df36dbd15aecbae9fd73f7388", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89", "patch": "@@ -12107,9 +12107,51 @@ aarch64_expand_vector_init (rtx target, rtx vals)\n \t    maxv = matches[i][1];\n \t  }\n \n-      /* Create a duplicate of the most common element.  */\n-      rtx x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, maxelement));\n-      aarch64_emit_move (target, gen_vec_duplicate (mode, x));\n+      /* Create a duplicate of the most common element, unless all elements\n+\t are equally useless to us, in which case just immediately set the\n+\t vector register using the first element.  */\n+\n+      if (maxv == 1)\n+\t{\n+\t  /* For vectors of two 64-bit elements, we can do even better.  */\n+\t  if (n_elts == 2\n+\t      && (inner_mode == E_DImode\n+\t\t  || inner_mode == E_DFmode))\n+\n+\t    {\n+\t      rtx x0 = XVECEXP (vals, 0, 0);\n+\t      rtx x1 = XVECEXP (vals, 0, 1);\n+\t      /* Combine can pick up this case, but handling it directly\n+\t\t here leaves clearer RTL.\n+\n+\t\t This is load_pair_lanes<mode>, and also gives us a clean-up\n+\t\t for store_pair_lanes<mode>.  */\n+\t      if (memory_operand (x0, inner_mode)\n+\t\t  && memory_operand (x1, inner_mode)\n+\t\t  && !STRICT_ALIGNMENT\n+\t\t  && rtx_equal_p (XEXP (x1, 0),\n+\t\t\t\t  plus_constant (Pmode,\n+\t\t\t\t\t\t XEXP (x0, 0),\n+\t\t\t\t\t\t GET_MODE_SIZE (inner_mode))))\n+\t\t{\n+\t\t  rtx t;\n+\t\t  if (inner_mode == DFmode)\n+\t\t    t = gen_load_pair_lanesdf (target, x0, x1);\n+\t\t  else\n+\t\t    t = gen_load_pair_lanesdi (target, x0, x1);\n+\t\t  emit_insn (t);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  rtx x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));\n+\t  aarch64_emit_move (target, lowpart_subreg (mode, x, inner_mode));\n+\t  maxelement = 0;\n+\t}\n+      else\n+\t{\n+\t  rtx x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, maxelement));\n+\t  aarch64_emit_move (target, gen_vec_duplicate (mode, x));\n+\t}\n \n       /* Insert the rest.  */\n       for (int i = 0; i < n_elts; i++)"}, {"sha": "6b163f9169960dd09de73bcc780e096487fc1eab", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89", "patch": "@@ -5860,6 +5860,57 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t\treturn simplify_gen_binary (VEC_CONCAT, mode, newop0, newop1);\n \t    }\n \n+\t  /* Replace:\n+\n+\t      (vec_merge:outer (vec_duplicate:outer x:inner)\n+\t\t\t       (subreg:outer y:inner 0)\n+\t\t\t       (const_int N))\n+\n+\t     with (vec_concat:outer x:inner y:inner) if N == 1,\n+\t     or (vec_concat:outer y:inner x:inner) if N == 2.\n+\t     We assume that degenrate cases (N == 0 or N == 3), which\n+\t     represent taking all elements from either input, are handled\n+\t     elsewhere.\n+\n+\t     Implicitly, this means we have a paradoxical subreg, but such\n+\t     a check is cheap, so make it anyway.\n+\n+\t     Only applies for vectors of two elements.  */\n+\n+\t  if ((GET_CODE (op0) == VEC_DUPLICATE\n+\t       || GET_CODE (op1) == VEC_DUPLICATE)\n+\t      && GET_MODE (op0) == GET_MODE (op1)\n+\t      && GET_MODE_NUNITS (GET_MODE (op0)) == 2\n+\t      && GET_MODE_NUNITS (GET_MODE (op1)) == 2\n+\t      && IN_RANGE (sel, 1, 2))\n+\t    {\n+\t      rtx newop0 = op0, newop1 = op1;\n+\n+\t      /* Canonicalize locally such that the VEC_DUPLICATE is always\n+\t\t the first operand.  */\n+\t      if (GET_CODE (newop1) == VEC_DUPLICATE)\n+\t\t{\n+\t\t  std::swap (newop0, newop1);\n+\t\t  /* If we swap the operand order, we also need to swap\n+\t\t     the selector mask.  */\n+\t\t  sel = sel == 1 ? 2 : 1;\n+\t\t}\n+\n+\t      if (GET_CODE (newop1) == SUBREG\n+\t\t  && paradoxical_subreg_p (newop1)\n+\t\t  && subreg_lowpart_p (newop1)\n+\t\t  && GET_MODE (SUBREG_REG (newop1))\n+\t\t      == GET_MODE (XEXP (newop0, 0)))\n+\t\t{\n+\t\t  newop0 = XEXP (newop0, 0);\n+\t\t  newop1 = SUBREG_REG (newop1);\n+\t\t  if (sel == 2)\n+\t\t    std::swap (newop0, newop1);\n+\t\t  return simplify_gen_binary (VEC_CONCAT, mode,\n+\t\t\t\t\t      newop0, newop1);\n+\t\t}\n+\t    }\n+\n \t  /* Replace (vec_merge (vec_duplicate x) (vec_duplicate y)\n \t\t\t\t (const_int n))\n \t     with (vec_concat x y) or (vec_concat y x) depending on value"}, {"sha": "7171973d9699180c5b29326fd010dbd63a1b8bf9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89", "patch": "@@ -1,3 +1,7 @@\n+2017-12-21  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* gcc.target/aarch64/vect-slp-dup.c: New.\n+\n 2017-12-21  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-c++-common/pr82872.c: New test."}, {"sha": "0541e480d1f8561dbd9b2a56926c8df60d667a54", "filename": "gcc/testsuite/gcc.target/aarch64/vect-slp-dup.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-slp-dup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-slp-dup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-slp-dup.c?ref=6b6d8f38f7b3bd8a2f4e4dbeb3014ba1339afa89", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+/* { dg-options \"-O3 -ftree-vectorize -fno-vect-cost-model\" } */\n+\n+void bar (double);\n+\n+void\n+foo (double *restrict in, double *restrict in2,\n+     double *restrict out1, double *restrict out2)\n+{\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      out1[i] = in[i] + 2.0 * in[i+128];\n+      out1[i+1] = in[i+1] + 2.0 * in2[i];\n+      bar (in[i]);\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not \"dup\\tv\\[0-9\\]+.2d, v\\[0-9\\]+\" } } */\n+"}]}