{"sha": "ded9bf77e35ce9a22468a1f56595df0741e2f22a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVkOWJmNzdlMzVjZTlhMjI0NjhhMWY1NjU5NWRmMDc0MWUyZjIyYQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2003-06-03T11:14:07Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2003-06-03T11:14:07Z"}, "message": "function.c (assign_parms): Split complex arguments.\n\n2003-06-03  Aldy Hernandez  <aldyh@redhat.com>\n\n        * function.c (assign_parms): Split complex arguments.\n\n        * doc/tm.texi (SPLIT_COMPLEX_ARGS): Document.\n\n        * expr.h (SPLIT_COMPLEX_ARGS): Define.\n        (split_complex_types): Protoize.\n        (split_complex_values): Protoize.\n\n        * calls.c (expand_call): Split complex arguments on architectures\n        that require it.\n        (split_complex_values): New.\n        (split_complex_types): New.\n\n        * config/rs6000/rs6000.c (rs6000_libcall_value): New.\n        (rs6000_function_value): Handle complex values on AIX.\n        (rs6000_complex_function_value): New.\n\n        * config/rs6000/rs6000-protos.h (rs6000_libcall_value): Protoize.\n\n        * config/rs6000/rs6000.h (LIBCALL_VALUE): Call function.\n        (SPLIT_COMPLEX_ARGS): New.\n\nFrom-SVN: r67367", "tree": {"sha": "20dae8c49de7b0cfdf57e381abee0961ed2ef0d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20dae8c49de7b0cfdf57e381abee0961ed2ef0d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ded9bf77e35ce9a22468a1f56595df0741e2f22a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ded9bf77e35ce9a22468a1f56595df0741e2f22a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ded9bf77e35ce9a22468a1f56595df0741e2f22a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ded9bf77e35ce9a22468a1f56595df0741e2f22a/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "24a4dd31f80136aadf69774545916675b50836d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24a4dd31f80136aadf69774545916675b50836d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24a4dd31f80136aadf69774545916675b50836d6"}], "stats": {"total": 267, "additions": 259, "deletions": 8}, "files": [{"sha": "28fad05757acf945edf3a65709eaf96c1d33a63e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ded9bf77e35ce9a22468a1f56595df0741e2f22a", "patch": "@@ -1,3 +1,27 @@\n+2003-06-03  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * function.c (assign_parms): Split complex arguments.\n+\n+        * doc/tm.texi (SPLIT_COMPLEX_ARGS): Document.\n+\n+        * expr.h (SPLIT_COMPLEX_ARGS): Define.\n+        (split_complex_types): Protoize.\n+        (split_complex_values): Protoize.\n+\n+        * calls.c (expand_call): Split complex arguments on architectures\n+        that require it.\n+        (split_complex_values): New.\n+        (split_complex_types): New.\n+\n+        * config/rs6000/rs6000.c (rs6000_libcall_value): New.\n+        (rs6000_function_value): Handle complex values on AIX.\n+        (rs6000_complex_function_value): New.\n+\n+        * config/rs6000/rs6000-protos.h (rs6000_libcall_value): Protoize.\n+\n+        * config/rs6000/rs6000.h (LIBCALL_VALUE): Call function.\n+        (SPLIT_COMPLEX_ARGS): New.\n+\n 2003-06-03  Jakub Jelinek  <jakub@redhat.com>\n \n \t* configure.in (HAVE_LD_PIE): Check for ld -pie."}, {"sha": "4e95735376c671b8e1b341ce7b33aa9213542170", "filename": "gcc/calls.c", "status": "modified", "additions": 89, "deletions": 2, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ded9bf77e35ce9a22468a1f56595df0741e2f22a", "patch": "@@ -2071,6 +2071,7 @@ expand_call (exp, target, ignore)\n   rtx tail_call_insns = NULL_RTX;\n   /* Data type of the function.  */\n   tree funtype;\n+  tree type_arg_types;\n   /* Declaration of the function being called,\n      or 0 if the function is computed (not known by name).  */\n   tree fndecl = 0;\n@@ -2306,6 +2307,16 @@ expand_call (exp, target, ignore)\n     abort ();\n   funtype = TREE_TYPE (funtype);\n \n+  /* Munge the tree to split complex arguments into their imaginary\n+     and real parts.  */\n+  if (SPLIT_COMPLEX_ARGS)\n+    {\n+      type_arg_types = split_complex_types (TYPE_ARG_TYPES (funtype));\n+      actparms = split_complex_values (actparms);\n+    }\n+  else\n+    type_arg_types = TYPE_ARG_TYPES (funtype);\n+\n   /* See if this is a call to a function that can return more than once\n      or a call to longjmp or malloc.  */\n   flags |= special_function_p (fndecl, flags);\n@@ -2359,9 +2370,9 @@ expand_call (exp, target, ignore)\n \n   if ((STRICT_ARGUMENT_NAMING\n        || ! PRETEND_OUTGOING_VARARGS_NAMED)\n-      && TYPE_ARG_TYPES (funtype) != 0)\n+      && type_arg_types != 0)\n     n_named_args\n-      = (list_length (TYPE_ARG_TYPES (funtype))\n+      = (list_length (type_arg_types)\n \t /* Don't include the last named arg.  */\n \t - (STRICT_ARGUMENT_NAMING ? 0 : 1)\n \t /* Count the struct value address, if it is passed as a parm.  */\n@@ -3447,6 +3458,82 @@ expand_call (exp, target, ignore)\n \n   return target;\n }\n+\n+/* Traverse an argument list in VALUES and expand all complex\n+   arguments into their components.  */\n+tree\n+split_complex_values (tree values)\n+{\n+  tree p;\n+\n+  values = copy_list (values);\n+\n+  for (p = values; p; p = TREE_CHAIN (p))\n+    {\n+      tree complex_value = TREE_VALUE (p);\n+      tree complex_type;\n+\n+      complex_type = TREE_TYPE (complex_value);\n+      if (!complex_type)\n+\tcontinue;\n+\n+      if (TREE_CODE (complex_type) == COMPLEX_TYPE)\n+\t{\n+\t  tree subtype;\n+\t  tree real, imag, next;\n+\n+\t  subtype = TREE_TYPE (complex_type);\n+\t  complex_value = save_expr (complex_value);\n+\t  real = build1 (REALPART_EXPR, subtype, complex_value);\n+\t  imag = build1 (IMAGPART_EXPR, subtype, complex_value);\n+\n+\t  TREE_VALUE (p) = real;\n+\t  next = TREE_CHAIN (p);\n+\t  imag = build_tree_list (NULL_TREE, imag);\n+\t  TREE_CHAIN (p) = imag;\n+\t  TREE_CHAIN (imag) = next;\n+\n+\t  /* Skip the newly created node.  */\n+\t  p = TREE_CHAIN (p);\n+\t}\n+    }\n+\n+  return values;\n+}\n+\n+/* Traverse a list of TYPES and expand all complex types into their\n+   components.  */\n+tree\n+split_complex_types (tree types)\n+{\n+  tree p;\n+\n+  types = copy_list (types);\n+\n+  for (p = types; p; p = TREE_CHAIN (p))\n+    {\n+      tree complex_type = TREE_VALUE (p);\n+\n+      if (TREE_CODE (complex_type) == COMPLEX_TYPE)\n+\t{\n+\t  tree next, imag;\n+\n+\t  /* Rewrite complex type with component type.  */\n+\t  TREE_VALUE (p) = TREE_TYPE (complex_type);\n+\t  next = TREE_CHAIN (p);\n+\n+\t  /* Add another component type for the imaginary part.  */\n+\t  imag = build_tree_list (NULL_TREE, TREE_VALUE (p));\n+\t  TREE_CHAIN (p) = imag;\n+\t  TREE_CHAIN (imag) = next;\n+\n+\t  /* Skip the newly created node.  */\n+\t  p = TREE_CHAIN (p);\n+\t}\n+    }\n+\n+  return types;\n+}\n \f\n /* Output a library call to function FUN (a SYMBOL_REF rtx).\n    The RETVAL parameter specifies whether return value needs to be saved, other"}, {"sha": "f088a045858b5689c4e49ebbf050a4db6fa56a01", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=ded9bf77e35ce9a22468a1f56595df0741e2f22a", "patch": "@@ -153,6 +153,7 @@ extern void setup_incoming_varargs PARAMS ((CUMULATIVE_ARGS *,\n \t\t\t\t\t    enum machine_mode, tree,\n \t\t\t\t\t    int *, int));\n extern rtx rs6000_function_value (tree, tree);\n+extern rtx rs6000_libcall_value (enum machine_mode);\n extern struct rtx_def *rs6000_va_arg PARAMS ((tree, tree));\n extern int function_ok_for_sibcall PARAMS ((tree));\n #ifdef ARGS_SIZE_RTX"}, {"sha": "2b9a76124e3f3b571831972ea38d47e39cb5ecc7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ded9bf77e35ce9a22468a1f56595df0741e2f22a", "patch": "@@ -312,6 +312,7 @@ static rtx rs6000_got_sym PARAMS ((void));\n static inline int rs6000_tls_symbol_ref_1 PARAMS ((rtx *, void *));\n static const char *rs6000_get_some_local_dynamic_name PARAMS ((void));\n static int rs6000_get_some_local_dynamic_name_1 PARAMS ((rtx *, void *));\n+static rtx rs6000_complex_function_value (enum machine_mode);\n \n /* Hash table stuff for keeping track of TOC entries.  */\n \n@@ -14361,6 +14362,33 @@ rs6000_memory_move_cost (mode, class, in)\n     return 4 + rs6000_register_move_cost (mode, class, GENERAL_REGS);\n }\n \n+/* Return an RTX representing where to find the function value of a\n+   function returning MODE.  */\n+static rtx\n+rs6000_complex_function_value (enum machine_mode mode)\n+{\n+  unsigned int regno;\n+  rtx r1, r2;\n+  enum machine_mode inner = GET_MODE_INNER (mode);\n+\n+  if (FLOAT_MODE_P (mode))\n+    regno = FP_ARG_RETURN;\n+  else\n+    {\n+      regno = GP_ARG_RETURN;\n+\n+      /* 32-bit is OK since it'll go in r3/r4.  */\n+      if (TARGET_32BIT)\n+\treturn gen_rtx_REG (mode, regno);\n+    }\n+\n+  r1 = gen_rtx_EXPR_LIST (inner, gen_rtx_REG (inner, regno),\n+\t\t\t  const0_rtx);\n+  r2 = gen_rtx_EXPR_LIST (inner, gen_rtx_REG (inner, regno + 1),\n+\t\t\t  GEN_INT (GET_MODE_UNIT_SIZE (inner)));\n+  return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r2));\n+}\n+\n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n@@ -14386,6 +14414,10 @@ rs6000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n \n   if (TREE_CODE (valtype) == REAL_TYPE && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;\n+  else if (TREE_CODE (valtype) == COMPLEX_TYPE\n+\t   && TARGET_HARD_FLOAT\n+\t   && SPLIT_COMPLEX_ARGS)\n+    return rs6000_complex_function_value (mode);\n   else if (TREE_CODE (valtype) == VECTOR_TYPE && TARGET_ALTIVEC)\n     regno = ALTIVEC_ARG_RETURN;\n   else\n@@ -14394,6 +14426,26 @@ rs6000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n   return gen_rtx_REG (mode, regno);\n }\n \n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+rtx\n+rs6000_libcall_value (enum machine_mode mode)\n+{\n+  unsigned int regno;\n+\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t   && TARGET_HARD_FLOAT && TARGET_FPRS)\n+    regno = FP_ARG_RETURN;\n+  else if (ALTIVEC_VECTOR_MODE (mode))\n+    regno = ALTIVEC_ARG_RETURN;\n+  else if (COMPLEX_MODE_P (mode) && SPLIT_COMPLEX_ARGS)\n+    return rs6000_complex_function_value (mode);\n+  else\n+    regno = GP_ARG_RETURN;\n+\n+  return gen_rtx_REG (mode, regno);\n+}\n+\n /* Return true if TYPE is of type __ev64_opaque__.  */\n \n static bool"}, {"sha": "3edf959a511a4b51a747e75d4f80eea062fea118", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=ded9bf77e35ce9a22468a1f56595df0741e2f22a", "patch": "@@ -1583,11 +1583,7 @@ typedef struct rs6000_stack {\n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n-  gen_rtx_REG (MODE, ALTIVEC_VECTOR_MODE (MODE) ? ALTIVEC_ARG_RETURN\t\\\n-\t\t     : GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\\\n-\t\t     && TARGET_HARD_FLOAT && TARGET_FPRS\t\t\\\n-\t\t     ? FP_ARG_RETURN : GP_ARG_RETURN)\n+#define LIBCALL_VALUE(MODE) rs6000_libcall_value ((MODE))\n \n /* The AIX ABI for the RS/6000 specifies that all structures are\n    returned in memory.  The Darwin ABI does the same.  The SVR4 ABI\n@@ -1815,6 +1811,13 @@ typedef struct rs6000_args\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n   function_arg_boundary (MODE, TYPE)\n \n+/* Define to nonzero if complex arguments should be split into their\n+   corresponding components.\n+\n+   This should be set for Linux and Darwin as well, but we can't break\n+   the ABIs at the moment.  For now, only AIX gets fixed.  */\n+#define SPLIT_COMPLEX_ARGS (DEFAULT_ABI == ABI_AIX)\n+\n /* Perform any needed actions needed for a function that is receiving a\n    variable number of arguments.\n "}, {"sha": "7215705eb808430d64d3b8b64d62a963dd964585", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ded9bf77e35ce9a22468a1f56595df0741e2f22a", "patch": "@@ -3782,6 +3782,17 @@ the structure-value address.  On many machines, no registers can be\n used for this purpose since all function arguments are pushed on the\n stack.\n \n+@findex SPLIT_COMPLEX_ARGS\n+@item SPLIT_COMPLEX_ARGS\n+\n+Define this macro to a nonzero value if complex function arguments\n+should be split into their corresponding components.  By default, GCC\n+will attempt to pack complex arguments into the target's word size.\n+Some ABIs require complex arguments to be split and treated as their\n+individual components.  For example, on AIX64, complex floats should\n+be passed in a pair of floating point registers, even though a complex\n+float would fit in one 64-bit floating point register.\n+\n @findex LOAD_ARGS_REVERSED\n @item LOAD_ARGS_REVERSED\n If defined, the order in which arguments are loaded into their"}, {"sha": "594df73a0d28b2c53b46b9b39e7a5dd423d9d8e6", "filename": "gcc/expr.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ded9bf77e35ce9a22468a1f56595df0741e2f22a", "patch": "@@ -158,6 +158,14 @@ do {\t\t\t\t\t\t\t\\\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\tPARM_BOUNDARY\n #endif\n \n+/* Define to nonzero if complex arguments should be split into their\n+   corresponding components.  */\n+#ifndef SPLIT_COMPLEX_ARGS\n+#define SPLIT_COMPLEX_ARGS 0\n+#endif\n+tree split_complex_types (tree);\n+tree split_complex_values (tree);\n+\n /* Provide a default value for STRICT_ARGUMENT_NAMING.  */\n #ifndef STRICT_ARGUMENT_NAMING\n #define STRICT_ARGUMENT_NAMING 0"}, {"sha": "c090d4aa869dac8b3f39caf4e63fb95719b5d790", "filename": "gcc/function.c", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded9bf77e35ce9a22468a1f56595df0741e2f22a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ded9bf77e35ce9a22468a1f56595df0741e2f22a", "patch": "@@ -296,6 +296,7 @@ static void prepare_function_start PARAMS ((void));\n static void do_clobber_return_reg PARAMS ((rtx, void *));\n static void do_use_return_reg PARAMS ((rtx, void *));\n static void instantiate_virtual_regs_lossage PARAMS ((rtx));\n+static tree split_complex_args (tree);\n \f\n /* Pointer to chain of `struct function' for containing functions.  */\n static GTY(()) struct function *outer_function_chain;\n@@ -4346,7 +4347,7 @@ assign_parms (fndecl)\n      given as a constant and a tree-expression.  */\n   struct args_size stack_args_size;\n   tree fntype = TREE_TYPE (fndecl);\n-  tree fnargs = DECL_ARGUMENTS (fndecl);\n+  tree fnargs = DECL_ARGUMENTS (fndecl), orig_fnargs;\n   /* This is used for the arg pointer when referring to stack args.  */\n   rtx internal_arg_pointer;\n   /* This is a dummy PARM_DECL that we used for the function result if\n@@ -4400,9 +4401,14 @@ assign_parms (fndecl)\n       fnargs = function_result_decl;\n     }\n \n+  orig_fnargs = fnargs;\n+\n   max_parm_reg = LAST_VIRTUAL_REGISTER + 1;\n   parm_reg_stack_loc = (rtx *) ggc_alloc_cleared (max_parm_reg * sizeof (rtx));\n \n+  if (SPLIT_COMPLEX_ARGS)\n+    fnargs = split_complex_args (fnargs);\n+\n #ifdef REG_PARM_STACK_SPACE\n #ifdef MAYBE_REG_PARM_STACK_SPACE\n   reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n@@ -5189,6 +5195,35 @@ assign_parms (fndecl)\n \t}\n     }\n \n+  if (SPLIT_COMPLEX_ARGS)\n+    {\n+      parm = orig_fnargs;\n+\n+      for (; parm; parm = TREE_CHAIN (parm))\n+\t{\n+\t  tree type = TREE_TYPE (parm);\n+\t  \n+\t  if (TREE_CODE (type) == COMPLEX_TYPE)\n+\t    {\n+\t      SET_DECL_RTL (parm,\n+\t\t\t    gen_rtx_CONCAT (DECL_MODE (parm),\n+\t\t\t\t\t    DECL_RTL (fnargs),\n+\t\t\t\t\t    DECL_RTL (TREE_CHAIN (fnargs))));\n+\t      DECL_INCOMING_RTL (parm)\n+\t\t= gen_rtx_CONCAT (DECL_MODE (parm),\n+\t\t\t\t  DECL_INCOMING_RTL (fnargs),\n+\t\t\t\t  DECL_INCOMING_RTL (TREE_CHAIN (fnargs)));\n+\t      fnargs = TREE_CHAIN (fnargs);\n+\t    }\n+\t  else\n+\t    {\n+\t      SET_DECL_RTL (parm, DECL_RTL (fnargs));\n+\t      DECL_INCOMING_RTL (parm) = DECL_INCOMING_RTL (fnargs);\n+\t    }\n+\t  fnargs = TREE_CHAIN (fnargs);\n+\t}\n+    }\n+\n   /* Output all parameter conversion instructions (possibly including calls)\n      now that all parameters have been copied out of hard registers.  */\n   emit_insn (conversion_insns);\n@@ -5292,6 +5327,36 @@ assign_parms (fndecl)\n \t}\n     }\n }\n+\n+static tree\n+split_complex_args (tree args)\n+{\n+  tree p;\n+\n+  args = copy_list (args);\n+\n+  for (p = args; p; p = TREE_CHAIN (p))\n+    {\n+      tree complex_type = TREE_TYPE (p);\n+\n+      if (TREE_CODE (complex_type) == COMPLEX_TYPE)\n+\t{\n+\t  tree decl;\n+\t  tree subtype = TREE_TYPE (complex_type);\n+\n+\t  /* Rewrite the PARM_DECL's type with its component.  */\n+\t  TREE_TYPE (p) = subtype;\n+\t  DECL_ARG_TYPE (p) = TREE_TYPE (DECL_ARG_TYPE (p));\n+\n+\t  decl = build_decl (PARM_DECL, NULL_TREE, subtype);\n+\t  DECL_ARG_TYPE (decl) = DECL_ARG_TYPE (p);\n+\t  TREE_CHAIN (decl) = TREE_CHAIN (p);\n+\t  TREE_CHAIN (p) = decl;\n+\t}\n+    }\n+\n+  return args;\n+}\n \f\n /* Indicate whether REGNO is an incoming argument to the current function\n    that was promoted to a wider mode.  If so, return the RTX for the"}]}