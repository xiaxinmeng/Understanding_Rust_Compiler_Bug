{"sha": "a358e188450fe839855b1b10e3f0410bf8e54929", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM1OGUxODg0NTBmZTgzOTg1NWIxYjEwZTNmMDQxMGJmOGU1NDkyOQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2011-04-12T09:27:18Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2011-04-12T09:27:18Z"}, "message": "cgraph.h (cgraph_node): Remove function declaration.\n\n2011-04-12  Martin Jambor  <mjambor@suse.cz>\n\n\t* cgraph.h (cgraph_node): Remove function declaration.\n\t(cgraph_create_node): Declare.\n\t(cgraph_get_create_node): Likewise.\n\t* cgraph.c (cgraph_create_node): Renamed to cgraph_create_node_1.\n\tUpdated all callers.\n\t(cgraph_node): Renamed to cgraph_create_node, assert that a node for\n\tthe decl does not already exist.  Call cgraph_get_create_node instead\n\tof cgraph_node.\n\t(cgraph_get_create_node): New function.\n\t(cgraph_same_body_alias): Update comment.\n\t(cgraph_set_call_stmt): Call cgraph_get_node instead of cgraph_node,\n\tassert it does not return NULL.\n\t(cgraph_update_edges_for_call_stmt): Likewise.\n\t(cgraph_clone_edge): Likewise.\n\t(cgraph_create_virtual_clone): Likewise.\n\t(cgraph_update_edges_for_call_stmt_node): Call cgraph_get_create_node\n\tinstead of cgraph_node.\n\t(cgraph_add_new_function): Call cgraph_create_node or\n\tcgraph_get_create_node instead of cgraph_node.\n\t* cgraphbuild.c (record_reference): Call cgraph_get_create_node\n\tinstead of cgraph_node.\n\t(record_eh_tables): Likewise.\n\t(mark_address): Likewise.\n\t(mark_load): Likewise.\n\t(build_cgraph_edges): Call cgraph_get_create_node instead\n\tof cgraph_node.\n\t(rebuild_cgraph_edges): Likewise.\n\t* cgraphunit.c (cgraph_finalize_function): Call cgraph_get_create_node\n\tinstead of cgraph_node.\n\t(cgraph_copy_node_for_versioning): Call cgraph_create_node instead of\n\tcgraph_node.\n\t* lto-symtab.c (lto_symtab_merge_cgraph_nodes_1): Call\n\tcgraph_create_node instead of cgraph_node.\n\t* c-decl.c (finish_function): Call cgraph_get_create_node instead\n\tof cgraph_node.\n\t* lto-cgraph.c (input_node): Likewise.\n\t* lto-streamer-in.c (input_function): Likewise.\n\t* varasm.c (mark_decl_referenced): Likewise.\n\t(assemble_alias): Likewise.\n\ngcc/c-family/\n\t* c-gimplify.c (c_genericize): Call cgraph_get_create_node instead\n\tof cgraph_node.\n\ngcc/cp/\n\t* cp/class.c (cp_fold_obj_type_ref): Call cgraph_get_create_node\n\tinstead of cgraph_node.\n\t* cp/decl2.c (cxx_callgraph_analyze_expr): Likewise.\n\t(cp_write_global_declarations): Likewise.\n\t* cp/optimize.c (maybe_clone_body): Likewise.\n\t* cp/semantics.c (maybe_add_lambda_conv_op): Likewise.\n\t* cp/mangle.c (mangle_decl): Likewise.\n\t* cp/method.c (make_alias_for_thunk): Likewise.\n\t(use_thunk): Likewise.\n\ngcc/ada/\n\t* gcc-interface/utils.c (end_subprog_body): Call\n\tcgraph_get_create_node instead of cgraph_node.\n\ngcc/fortran/\n\t* trans-decl.c (gfc_generate_function_code): Call\n\tcgraph_get_create_node instead of cgraph_node.\n\ngcc/objc/\n\t* objc-act.c (mark_referenced_methods): Call cgraph_get_create_node\n\tinstead of cgraph_node.\n\nFrom-SVN: r172307", "tree": {"sha": "2900c2e60111189ed0a91ca9e536453bdc1ea540", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2900c2e60111189ed0a91ca9e536453bdc1ea540"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a358e188450fe839855b1b10e3f0410bf8e54929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a358e188450fe839855b1b10e3f0410bf8e54929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a358e188450fe839855b1b10e3f0410bf8e54929", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a358e188450fe839855b1b10e3f0410bf8e54929/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fe660d7bfe8ae31c03f500af99c1a614438d0198", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe660d7bfe8ae31c03f500af99c1a614438d0198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe660d7bfe8ae31c03f500af99c1a614438d0198"}], "stats": {"total": 229, "additions": 161, "deletions": 68}, "files": [{"sha": "c438014b8904a2848a5c3275ca95ec6f958cf226", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -1,3 +1,45 @@\n+2011-04-12  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* cgraph.h (cgraph_node): Remove function declaration.\n+\t(cgraph_create_node): Declare.\n+\t(cgraph_get_create_node): Likewise.\n+\t* cgraph.c (cgraph_create_node): Renamed to cgraph_create_node_1.\n+\tUpdated all callers.\n+\t(cgraph_node): Renamed to cgraph_create_node, assert that a node for\n+\tthe decl does not already exist.  Call cgraph_get_create_node instead\n+\tof cgraph_node.\n+\t(cgraph_get_create_node): New function.\n+\t(cgraph_same_body_alias): Update comment.\n+\t(cgraph_set_call_stmt): Call cgraph_get_node instead of cgraph_node,\n+\tassert it does not return NULL.\n+\t(cgraph_update_edges_for_call_stmt): Likewise.\n+\t(cgraph_clone_edge): Likewise.\n+\t(cgraph_create_virtual_clone): Likewise.\n+\t(cgraph_update_edges_for_call_stmt_node): Call cgraph_get_create_node\n+\tinstead of cgraph_node.\n+\t(cgraph_add_new_function): Call cgraph_create_node or\n+\tcgraph_get_create_node instead of cgraph_node.\n+\t* cgraphbuild.c (record_reference): Call cgraph_get_create_node\n+\tinstead of cgraph_node.\n+\t(record_eh_tables): Likewise.\n+\t(mark_address): Likewise.\n+\t(mark_load): Likewise.\n+\t(build_cgraph_edges): Call cgraph_get_create_node instead\n+\tof cgraph_node.\n+\t(rebuild_cgraph_edges): Likewise.\n+\t* cgraphunit.c (cgraph_finalize_function): Call cgraph_get_create_node\n+\tinstead of cgraph_node.\n+\t(cgraph_copy_node_for_versioning): Call cgraph_create_node instead of\n+\tcgraph_node.\n+\t* lto-symtab.c (lto_symtab_merge_cgraph_nodes_1): Call\n+\tcgraph_create_node instead of cgraph_node.\n+\t* c-decl.c (finish_function): Call cgraph_get_create_node instead\n+\tof cgraph_node.\n+\t* lto-cgraph.c (input_node): Likewise.\n+\t* lto-streamer-in.c (input_function): Likewise.\n+\t* varasm.c (mark_decl_referenced): Likewise.\n+\t(assemble_alias): Likewise.\n+\n 2011-04-12  Martin Jambor  <mjambor@suse.cz>\n \n \t* tree-inline.c (tree_function_versioning): Call cgraph_get_node"}, {"sha": "285d61d5648ea0d6d2779614f7172f0beb96b60a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -1,3 +1,8 @@\n+2011-04-12  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc-interface/utils.c (end_subprog_body): Call\n+\tcgraph_get_create_node instead of cgraph_node.\n+\n 2011-04-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Procedure>: Set minimum"}, {"sha": "3ecea18bc6759fae7836208791d25c19eb1e7c53", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -2003,7 +2003,7 @@ end_subprog_body (tree body)\n   else\n     /* Register this function with cgraph just far enough to get it\n        added to our parent's nested function list.  */\n-    (void) cgraph_node (fndecl);\n+    (void) cgraph_get_create_node (fndecl);\n }\n \n tree"}, {"sha": "5d32a9aa6eb1cd6b38b832328f099e805aa084f8", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -8345,7 +8345,7 @@ finish_function (void)\n \t  /* Register this function with cgraph just far enough to get it\n \t    added to our parent's nested function list.  Handy, since the\n \t    C front end doesn't have such a list.  */\n-\t  (void) cgraph_node (fndecl);\n+\t  (void) cgraph_get_create_node (fndecl);\n \t}\n     }\n "}, {"sha": "5fd1f206420342a1d748b5cf156bf356f369905e", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -1,3 +1,8 @@\n+2011-04-12  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* c-gimplify.c (c_genericize): Call cgraph_get_create_node instead\n+\tof cgraph_node.\n+\n 2011-04-11  Richard Guenther  <rguenther@suse.de>\n \n \t* c-common.c (complete_array_type): Build a range type of"}, {"sha": "f45650bb1d8633fe406c88b76d7254c3f55dc4ab", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -98,7 +98,7 @@ c_genericize (tree fndecl)\n     }\n \n   /* Dump all nested functions now.  */\n-  cgn = cgraph_node (fndecl);\n+  cgn = cgraph_get_create_node (fndecl);\n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n     c_genericize (cgn->decl);\n }"}, {"sha": "22098e54955d848fc620c9c885220968c6cf1a99", "filename": "gcc/cgraph.c", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -466,7 +466,7 @@ cgraph_allocate_node (void)\n /* Allocate new callgraph node and insert it into basic data structures.  */\n \n static struct cgraph_node *\n-cgraph_create_node (void)\n+cgraph_create_node_1 (void)\n {\n   struct cgraph_node *node = cgraph_allocate_node ();\n \n@@ -488,7 +488,7 @@ cgraph_create_node (void)\n /* Return cgraph node assigned to DECL.  Create new one when needed.  */\n \n struct cgraph_node *\n-cgraph_node (tree decl)\n+cgraph_create_node (tree decl)\n {\n   struct cgraph_node key, *node, **slot;\n \n@@ -498,23 +498,15 @@ cgraph_node (tree decl)\n     cgraph_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n \n   key.decl = decl;\n-\n   slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key, INSERT);\n+  gcc_assert (!*slot);\n \n-  if (*slot)\n-    {\n-      node = *slot;\n-      if (node->same_body_alias)\n-\tnode = node->same_body;\n-      return node;\n-    }\n-\n-  node = cgraph_create_node ();\n+  node = cgraph_create_node_1 ();\n   node->decl = decl;\n   *slot = node;\n   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n     {\n-      node->origin = cgraph_node (DECL_CONTEXT (decl));\n+      node->origin = cgraph_get_create_node (DECL_CONTEXT (decl));\n       node->next_nested = node->origin->nested;\n       node->origin->nested = node;\n     }\n@@ -536,6 +528,21 @@ cgraph_node (tree decl)\n   return node;\n }\n \n+/* Try to find a call graph node for declaration DECL and if it does not exist,\n+   create it.  */\n+\n+struct cgraph_node *\n+cgraph_get_create_node (tree decl)\n+{\n+  struct cgraph_node *node;\n+\n+  node = cgraph_get_node (decl);\n+  if (node)\n+    return node;\n+\n+  return cgraph_create_node (decl);\n+}\n+\n /* Mark ALIAS as an alias to DECL.  DECL_NODE is cgraph node representing\n    the function body is associated with (not neccesarily cgraph_node (DECL).  */\n \n@@ -570,9 +577,9 @@ cgraph_same_body_alias_1 (struct cgraph_node *decl_node, tree alias, tree decl)\n }\n \n /* Attempt to mark ALIAS as an alias to DECL.  Return alias node if successful\n-   and NULL otherwise. \n+   and NULL otherwise.\n    Same body aliases are output whenever the body of DECL is output,\n-   and cgraph_node (ALIAS) transparently returns cgraph_node (DECL).   */\n+   and cgraph_get_node (ALIAS) transparently returns cgraph_get_node (DECL).  */\n \n struct cgraph_node *\n cgraph_same_body_alias (struct cgraph_node *decl_node, tree alias, tree decl)\n@@ -859,8 +866,9 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n     {\n       /* Constant propagation (and possibly also inlining?) can turn an\n \t indirect call into a direct one.  */\n-      struct cgraph_node *new_callee = cgraph_node (decl);\n+      struct cgraph_node *new_callee = cgraph_get_node (decl);\n \n+      gcc_checking_assert (new_callee);\n       cgraph_make_edge_direct (e, new_callee, 0);\n     }\n \n@@ -1301,7 +1309,7 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n \n       if (new_call)\n \t{\n-\t  ne = cgraph_create_edge (node, cgraph_node (new_call),\n+\t  ne = cgraph_create_edge (node, cgraph_get_create_node (new_call),\n \t\t\t\t   new_stmt, count, frequency,\n \t\t\t\t   loop_nest);\n \t  gcc_assert (ne->inline_failed);\n@@ -1319,9 +1327,10 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n void\n cgraph_update_edges_for_call_stmt (gimple old_stmt, tree old_decl, gimple new_stmt)\n {\n-  struct cgraph_node *orig = cgraph_node (cfun->decl);\n+  struct cgraph_node *orig = cgraph_get_node (cfun->decl);\n   struct cgraph_node *node;\n \n+  gcc_checking_assert (orig);\n   cgraph_update_edges_for_call_stmt_node (orig, old_stmt, old_decl, new_stmt);\n   if (orig->clones)\n     for (node = orig->clones; node != orig;)\n@@ -2123,7 +2132,8 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \n       if (call_stmt && (decl = gimple_call_fndecl (call_stmt)))\n \t{\n-\t  struct cgraph_node *callee = cgraph_node (decl);\n+\t  struct cgraph_node *callee = cgraph_get_node (decl);\n+\t  gcc_checking_assert (callee);\n \t  new_edge = cgraph_create_edge (n, callee, call_stmt, count, freq,\n \t\t\t\t\t e->loop_nest + loop_nest);\n \t}\n@@ -2179,7 +2189,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n \t\t   int loop_nest, bool update_original,\n \t\t   VEC(cgraph_edge_p,heap) *redirect_callers)\n {\n-  struct cgraph_node *new_node = cgraph_create_node ();\n+  struct cgraph_node *new_node = cgraph_create_node_1 ();\n   struct cgraph_edge *e;\n   gcov_type count_scale;\n   unsigned i;\n@@ -2355,8 +2365,12 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n       /* Record references of the future statement initializing the constant\n \t argument.  */\n       if (TREE_CODE (var) == FUNCTION_DECL)\n-\tipa_record_reference (new_node, NULL, cgraph_node (var),\n-\t\t\t      NULL, IPA_REF_ADDR, NULL);\n+\t{\n+\t  struct cgraph_node *ref_node = cgraph_get_node (var);\n+\t  gcc_checking_assert (ref_node);\n+\t  ipa_record_reference (new_node, NULL, ref_node, NULL, IPA_REF_ADDR,\n+\t\t\t\tNULL);\n+\t}\n       else if (TREE_CODE (var) == VAR_DECL)\n \tipa_record_reference (new_node, NULL, NULL, varpool_node (var),\n \t\t\t      IPA_REF_ADDR, NULL);\n@@ -2464,7 +2478,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n     {\n       case CGRAPH_STATE_CONSTRUCTION:\n \t/* Just enqueue function to be processed at nearest occurrence.  */\n-\tnode = cgraph_node (fndecl);\n+\tnode = cgraph_create_node (fndecl);\n \tnode->next_needed = cgraph_new_nodes;\n \tif (lowered)\n \t  node->lowered = true;\n@@ -2476,7 +2490,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n       case CGRAPH_STATE_EXPANSION:\n \t/* Bring the function into finalized state and enqueue for later\n \t   analyzing and compilation.  */\n-\tnode = cgraph_node (fndecl);\n+\tnode = cgraph_get_create_node (fndecl);\n \tnode->local.local = false;\n \tnode->local.finalized = true;\n \tnode->reachable = node->needed = true;\n@@ -2504,7 +2518,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n       case CGRAPH_STATE_FINISHED:\n \t/* At the very end of compilation we have to do all the work up\n \t   to expansion.  */\n-\tnode = cgraph_node (fndecl);\n+\tnode = cgraph_create_node (fndecl);\n \tif (lowered)\n \t  node->lowered = true;\n \tcgraph_analyze_function (node);"}, {"sha": "135164205ce9ead1df13b17634bbed1a8dc75530", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -561,7 +561,8 @@ struct cgraph_edge *cgraph_create_indirect_edge (struct cgraph_node *, gimple,\n struct cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n struct cgraph_node * cgraph_get_node (const_tree);\n struct cgraph_node * cgraph_get_node_or_alias (const_tree);\n-struct cgraph_node * cgraph_node (tree);\n+struct cgraph_node * cgraph_create_node (tree);\n+struct cgraph_node * cgraph_get_create_node (tree);\n struct cgraph_node * cgraph_same_body_alias (struct cgraph_node *, tree, tree);\n struct cgraph_node * cgraph_add_thunk (struct cgraph_node *, tree, tree, bool, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, tree, tree);"}, {"sha": "935462eda83f995dd0ab3558d4cb6fcadee5f8a9", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -73,10 +73,10 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n       decl = get_base_var (*tp);\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t{\n+\t  struct cgraph_node *node = cgraph_get_create_node (decl);\n \t  if (!ctx->only_vars)\n-\t  cgraph_mark_address_taken_node (cgraph_node (decl));\n-\t  ipa_record_reference (NULL, ctx->varpool_node,\n-\t\t\t        cgraph_node (decl), NULL,\n+\t    cgraph_mark_address_taken_node (node);\n+\t  ipa_record_reference (NULL, ctx->varpool_node, node, NULL,\n \t\t\t        IPA_REF_ADDR, NULL);\n \t}\n \n@@ -149,8 +149,8 @@ record_eh_tables (struct cgraph_node *node, struct function *fun)\n \n   if (DECL_FUNCTION_PERSONALITY (node->decl))\n     ipa_record_reference (node, NULL,\n-\t\t\t  cgraph_node (DECL_FUNCTION_PERSONALITY (node->decl)),\n-\t\t\t  NULL, IPA_REF_ADDR, NULL);\n+\t       cgraph_get_create_node (DECL_FUNCTION_PERSONALITY (node->decl)),\n+\t       NULL, IPA_REF_ADDR, NULL);\n \n   i = fun->eh->region_tree;\n   if (!i)\n@@ -250,7 +250,7 @@ mark_address (gimple stmt, tree addr, void *data)\n   addr = get_base_address (addr);\n   if (TREE_CODE (addr) == FUNCTION_DECL)\n     {\n-      struct cgraph_node *node = cgraph_node (addr);\n+      struct cgraph_node *node = cgraph_get_create_node (addr);\n       cgraph_mark_address_taken_node (node);\n       ipa_record_reference ((struct cgraph_node *)data, NULL,\n \t\t\t    node, NULL,\n@@ -285,7 +285,7 @@ mark_load (gimple stmt, tree t, void *data)\n     {\n       /* ??? This can happen on platforms with descriptors when these are\n \t directly manipulated in the code.  Pretend that it's an address.  */\n-      struct cgraph_node *node = cgraph_node (t);\n+      struct cgraph_node *node = cgraph_get_create_node (t);\n       cgraph_mark_address_taken_node (node);\n       ipa_record_reference ((struct cgraph_node *)data, NULL,\n \t\t\t    node, NULL,\n@@ -361,9 +361,8 @@ build_cgraph_edges (void)\n \t\t\t\t\t\t\t bb);\n \t      decl = gimple_call_fndecl (stmt);\n \t      if (decl)\n-\t\tcgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t\t    bb->count, freq,\n-\t\t\t\t    bb->loop_depth);\n+\t\tcgraph_create_edge (node, cgraph_get_create_node (decl),\n+\t\t\t\t    stmt, bb->count, freq, bb->loop_depth);\n \t      else\n \t\tcgraph_create_indirect_edge (node, stmt,\n \t\t\t\t\t     gimple_call_flags (stmt),\n@@ -376,18 +375,18 @@ build_cgraph_edges (void)\n \t      && gimple_omp_parallel_child_fn (stmt))\n \t    {\n \t      tree fn = gimple_omp_parallel_child_fn (stmt);\n-\t      ipa_record_reference (node, NULL, cgraph_node (fn),\n+\t      ipa_record_reference (node, NULL, cgraph_get_create_node (fn),\n \t\t\t\t    NULL, IPA_REF_ADDR, stmt);\n \t    }\n \t  if (gimple_code (stmt) == GIMPLE_OMP_TASK)\n \t    {\n \t      tree fn = gimple_omp_task_child_fn (stmt);\n \t      if (fn)\n-\t\tipa_record_reference (node, NULL, cgraph_node (fn),\n+\t\tipa_record_reference (node, NULL, cgraph_get_create_node (fn),\n \t\t\t\t      NULL, IPA_REF_ADDR, stmt);\n \t      fn = gimple_omp_task_copy_fn (stmt);\n \t      if (fn)\n-\t\tipa_record_reference (node, NULL, cgraph_node (fn),\n+\t\tipa_record_reference (node, NULL, cgraph_get_create_node (fn),\n \t\t\t\t      NULL, IPA_REF_ADDR, stmt);\n \t    }\n \t}\n@@ -472,9 +471,8 @@ rebuild_cgraph_edges (void)\n \t\t\t\t\t\t\t bb);\n \t      decl = gimple_call_fndecl (stmt);\n \t      if (decl)\n-\t\tcgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t\t    bb->count, freq,\n-\t\t\t\t    bb->loop_depth);\n+\t\tcgraph_create_edge (node, cgraph_get_create_node (decl), stmt,\n+\t\t\t\t    bb->count, freq, bb->loop_depth);\n \t      else\n \t\tcgraph_create_indirect_edge (node, stmt,\n \t\t\t\t\t     gimple_call_flags (stmt),"}, {"sha": "539dbf98244dfc5a4e70273f4fa67352fb87f345", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -343,7 +343,7 @@ cgraph_lower_function (struct cgraph_node *node)\n void\n cgraph_finalize_function (tree decl, bool nested)\n {\n-  struct cgraph_node *node = cgraph_node (decl);\n+  struct cgraph_node *node = cgraph_get_create_node (decl);\n \n   if (node->local.finalized)\n     cgraph_reset_node (node);\n@@ -1990,7 +1990,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \n    gcc_assert (old_version);\n \n-   new_version = cgraph_node (new_decl);\n+   new_version = cgraph_create_node (new_decl);\n \n    new_version->analyzed = true;\n    new_version->local = old_version->local;"}, {"sha": "f9c0fb2a2e0e6a4d2f889e1fe935b0c5b80fb14a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -1,3 +1,15 @@\n+2011-04-12  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* class.c (cp_fold_obj_type_ref): Call cgraph_get_create_node\n+\tinstead of cgraph_node.\n+\t* decl2.c (cxx_callgraph_analyze_expr): Likewise.\n+\t(cp_write_global_declarations): Likewise.\n+\t* optimize.c (maybe_clone_body): Likewise.\n+\t* semantics.c (maybe_add_lambda_conv_op): Likewise.\n+\t* mangle.c (mangle_decl): Likewise.\n+\t* method.c (make_alias_for_thunk): Likewise.\n+\t(use_thunk): Likewise.\n+\n 2011-04-11  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/48535"}, {"sha": "634b2bf4a498ac4487646033c55774988aa6f90f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -8401,7 +8401,7 @@ cp_fold_obj_type_ref (tree ref, tree known_type)\n \t\t\t\t  DECL_VINDEX (fndecl)));\n #endif\n \n-  cgraph_node (fndecl)->local.vtable_method = true;\n+  cgraph_get_create_node (fndecl)->local.vtable_method = true;\n \n   return build_address (fndecl);\n }"}, {"sha": "9e63c871dafd3a0a69b04f546f02e9a48ba82188", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -3374,11 +3374,13 @@ cxx_callgraph_analyze_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED)\n     {\n     case PTRMEM_CST:\n       if (TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n-\tcgraph_mark_address_taken_node (cgraph_node (PTRMEM_CST_MEMBER (t)));\n+\tcgraph_mark_address_taken_node (\n+\t\t\t      cgraph_get_create_node (PTRMEM_CST_MEMBER (t)));\n       break;\n     case BASELINK:\n       if (TREE_CODE (BASELINK_FUNCTIONS (t)) == FUNCTION_DECL)\n-\tcgraph_mark_address_taken_node (cgraph_node (BASELINK_FUNCTIONS (t)));\n+\tcgraph_mark_address_taken_node (\n+\t\t\t      cgraph_get_create_node (BASELINK_FUNCTIONS (t)));\n       break;\n     case VAR_DECL:\n       if (DECL_CONTEXT (t)\n@@ -3891,7 +3893,7 @@ cp_write_global_declarations (void)\n \t  if (!DECL_EXTERNAL (decl)\n \t      && decl_needed_p (decl)\n \t      && !TREE_ASM_WRITTEN (decl)\n-\t      && !cgraph_node (decl)->local.finalized)\n+\t      && !cgraph_get_create_node (decl)->local.finalized)\n \t    {\n \t      /* We will output the function; no longer consider it in this\n \t\t loop.  */"}, {"sha": "b33f31723c7e64af2dbf883253210759b7697161", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -3170,7 +3170,7 @@ mangle_decl (const tree decl)\n       if (vague_linkage_p (decl))\n \tDECL_WEAK (alias) = 1;\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tcgraph_same_body_alias (cgraph_node (decl), alias, decl);\n+\tcgraph_same_body_alias (cgraph_get_create_node (decl), alias, decl);\n       else\n \tvarpool_extra_name_alias (alias, decl);\n #endif"}, {"sha": "e18143e2b9e6d670add3e278425fa1c8f28e641c", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -259,8 +259,9 @@ make_alias_for_thunk (tree function)\n \n   if (!flag_syntax_only)\n     {\n-      struct cgraph_node *aliasn = cgraph_same_body_alias (cgraph_node (function),\n-\t\t\t\t\t\t\t   alias, function);\n+      struct cgraph_node *aliasn;\n+      aliasn = cgraph_same_body_alias (cgraph_get_create_node (function),\n+\t\t\t\t       alias, function);\n       DECL_ASSEMBLER_NAME (function);\n       gcc_assert (aliasn != NULL);\n     }\n@@ -378,7 +379,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n   a = nreverse (t);\n   DECL_ARGUMENTS (thunk_fndecl) = a;\n   TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n-  cgraph_add_thunk (cgraph_node (function), thunk_fndecl, function,\n+  cgraph_add_thunk (cgraph_get_create_node (function), thunk_fndecl, function,\n \t\t    this_adjusting, fixed_offset, virtual_value,\n \t\t    virtual_offset, alias);\n "}, {"sha": "2110779a04b0b4824bed37bae734982aed0cac8f", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -309,7 +309,8 @@ maybe_clone_body (tree fn)\n \t  && (!DECL_ONE_ONLY (fns[0])\n \t      || (HAVE_COMDAT_GROUP\n \t\t  && DECL_WEAK (fns[0])))\n-\t  && cgraph_same_body_alias (cgraph_node (fns[0]), clone, fns[0]))\n+\t  && cgraph_same_body_alias (cgraph_get_create_node (fns[0]), clone,\n+\t\t\t\t     fns[0]))\n \t{\n \t  alias = true;\n \t  if (DECL_ONE_ONLY (fns[0]))\n@@ -423,8 +424,8 @@ maybe_clone_body (tree fn)\n \t  /* If *[CD][12]* dtors go into the *[CD]5* comdat group and dtor is\n \t     virtual, it goes into the same comdat group as well.  */\n \t  DECL_COMDAT_GROUP (fns[2]) = comdat_group;\n-\t  base_dtor_node = cgraph_node (fns[0]);\n-\t  deleting_dtor_node = cgraph_node (fns[2]);\n+\t  base_dtor_node = cgraph_get_create_node (fns[0]);\n+\t  deleting_dtor_node = cgraph_get_create_node (fns[2]);\n \t  gcc_assert (base_dtor_node->same_comdat_group == NULL);\n \t  gcc_assert (deleting_dtor_node->same_comdat_group == NULL);\n \t  base_dtor_node->same_comdat_group = deleting_dtor_node;"}, {"sha": "8752f3712c31fcfae7963d9cab188984186e9946", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -8458,8 +8458,8 @@ maybe_add_lambda_conv_op (tree type)\n       /* Put the thunk in the same comdat group as the call op.  */\n       struct cgraph_node *callop_node, *thunk_node;\n       DECL_COMDAT_GROUP (statfn) = DECL_COMDAT_GROUP (callop);\n-      callop_node = cgraph_node (callop);\n-      thunk_node = cgraph_node (statfn);\n+      callop_node = cgraph_get_create_node (callop);\n+      thunk_node = cgraph_get_create_node (statfn);\n       gcc_assert (callop_node->same_comdat_group == NULL);\n       gcc_assert (thunk_node->same_comdat_group == NULL);\n       callop_node->same_comdat_group = thunk_node;"}, {"sha": "3b23770f126c74c7f7bdad0f5a1d1daebd7e69a4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -1,3 +1,8 @@\n+2011-04-12  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* trans-decl.c (gfc_generate_function_code): Call\n+\tcgraph_get_create_node instead of cgraph_node.\n+\n 2011-04-11  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "784dfc85a653301765ea2ace77c408966150f08b", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -5064,7 +5064,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n   if (decl_function_context (fndecl))\n     /* Register this function with cgraph just far enough to get it\n        added to our parent's nested function list.  */\n-    (void) cgraph_node (fndecl);\n+    (void) cgraph_get_create_node (fndecl);\n   else\n     cgraph_finalize_function (fndecl, true);\n "}, {"sha": "63680d3cb75f7071a10cf551117b8856e78c6aec", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -1045,7 +1045,7 @@ input_node (struct lto_file_decl_data *file_data,\n \t\t\t\t0, CGRAPH_FREQ_BASE, 0, false, NULL);\n     }\n   else\n-    node = cgraph_node (fn_decl);\n+    node = cgraph_get_create_node (fn_decl);\n \n   node->count = lto_input_sleb128 (ib);\n   node->count_materialization_scale = lto_input_sleb128 (ib);"}, {"sha": "ddc0cae5328cac5eac1ef1f109ef061f1ccf2ea9", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -1301,7 +1301,7 @@ input_function (tree fn_decl, struct data_in *data_in,\n   DECL_INITIAL (fn_decl) = lto_input_tree (ib, data_in);\n   gcc_assert (DECL_INITIAL (fn_decl));\n   DECL_SAVED_TREE (fn_decl) = NULL_TREE;\n-  node = cgraph_node (fn_decl);\n+  node = cgraph_get_create_node (fn_decl);\n \n   /* Read all the basic blocks.  */\n   tag = input_record_start (ib);"}, {"sha": "28a3d8b7bb877eafc76a6fd620a7d7e2b7293d6a", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -799,7 +799,7 @@ lto_symtab_merge_cgraph_nodes_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n \t     previously unused.  Create the node.  */\n \t  if (!prevailing->node)\n \t    {\n-\t      prevailing->node = cgraph_node (prevailing->decl);\n+\t      prevailing->node = cgraph_create_node (prevailing->decl);\n \t      prevailing->node->alias = true;\n \t    }\n \t  lto_cgraph_replace_node (e->node, prevailing->node);"}, {"sha": "d91ca29a0260c20791cb82404f46133a2bcf6451", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -1,3 +1,8 @@\n+2011-04-12  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* objc-act.c (mark_referenced_methods): Call cgraph_get_create_node\n+\tinstead of cgraph_node.\n+\n 2011-04-06  Joseph Myers  <joseph@codesourcery.com>\n \n \t* objc-act.c: Include c-target.h instead of target.h."}, {"sha": "513da2fe560fc4707a2554898409f78fab4f04d1", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -4519,14 +4519,16 @@ mark_referenced_methods (void)\n       chain = CLASS_CLS_METHODS (impent->imp_context);\n       while (chain)\n \t{\n-\t  cgraph_mark_needed_node (cgraph_node (METHOD_DEFINITION (chain)));\n+\t  cgraph_mark_needed_node (\n+\t\t\t   cgraph_get_create_node (METHOD_DEFINITION (chain)));\n \t  chain = DECL_CHAIN (chain);\n \t}\n \n       chain = CLASS_NST_METHODS (impent->imp_context);\n       while (chain)\n \t{\n-\t  cgraph_mark_needed_node (cgraph_node (METHOD_DEFINITION (chain)));\n+\t  cgraph_mark_needed_node (\n+\t\t\t   cgraph_get_create_node (METHOD_DEFINITION (chain)));\n \t  chain = DECL_CHAIN (chain);\n \t}\n     }"}, {"sha": "40a38f57bc933c81af2d8e9e529579f83a0c9b14", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a358e188450fe839855b1b10e3f0410bf8e54929/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=a358e188450fe839855b1b10e3f0410bf8e54929", "patch": "@@ -2199,7 +2199,7 @@ mark_decl_referenced (tree decl)\n \t If we know a method will be emitted in other TU and no new\n \t functions can be marked reachable, just use the external\n \t definition.  */\n-      struct cgraph_node *node = cgraph_node (decl);\n+      struct cgraph_node *node = cgraph_get_create_node (decl);\n       if (!DECL_EXTERNAL (decl)\n \t  && (!node->local.vtable_method || !cgraph_global_info_ready\n \t      || !node->local.finalized))\n@@ -5807,7 +5807,7 @@ assemble_alias (tree decl, tree target)\n \n   /* Allow aliases to aliases.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n-    cgraph_node (decl)->alias = true;\n+    cgraph_get_create_node (decl)->alias = true;\n   else\n     varpool_node (decl)->alias = true;\n "}]}