{"sha": "bf3ce6f84a7a994a0fc87419b383b9ce4efed442", "node_id": "C_kwDOANBUbNoAKGJmM2NlNmY4NGE3YTk5NGEwZmM4NzQxOWIzODNiOWNlNGVmZWQ0NDI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-12-15T08:26:44Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-12-15T08:26:44Z"}, "message": "into-ssa: Fix emitting debug stmts after asm goto [PR108095]\n\nThe following testcase ICEs, because ccp1 replaced\n  s.0_1 = &s;\n  __asm__ goto(\"\" : \"=r\" MEM[(T *)s.0_1] :  :  : \"lab\" lab);\nwith\n  __asm__ goto(\"\" : \"=r\" s :  :  : \"lab\" lab);\nand because s is no longer addressable, we are rewriting it into\nssa and want\n  __asm__ goto(\"\" : \"=r\" s_7 :  :  : \"lab\" lab);\nplus debug stmt\n  # DEBUG s => s_7\nThe code assumes that there is at most one non-EH edge in that\ncase, but with the addition of outputs to asm goto that is no longer the\ncase, we can have many outgoing edges.\n\nThe patch keeps the checking assertion that there is at most one such\nedge for everything but asm goto, but moves the addition of the debug\nstmt into the loop, so that it can be added on all edges where it is\npossible, not just one of them.\n\nFurthermore, looking at gsi_insert_on_edge_immediate\n-> gimple_find_edge_insert_loc, the conditions to insert stmt there\nto the destination block are\n  if (single_pred_p (dest)\n      && gimple_seq_empty_p (phi_nodes (dest))\n      && dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n(plus there is code to insert it in the previous block but that is\nnever true when the pred is known to be stmt_ends_bb_p), while\nmayube_register_def was just checking\n                 if (ef && single_pred_p (ef->dest)\n                     && ef->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\nso if for whatever reason ef->dest had any PHIs, we'd split the\nedge for -g and not for -g0, something we must avoid for -fcompare-debug\nstability.  So, I've added the no phi_nodes check too.\n\n2022-12-15  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/108095\n\t* tree-into-ssa.cc (maybe_register_def): Insert debug stmt\n\ton all non-EH edges from asm goto if they have a single\n\tpredecessor rather than asserting there is at most one such edge.\n\tTest whether there are no PHI nodes next to the single predecessor\n\ttest.\n\n\t* gcc.dg/pr108095.c: New test.", "tree": {"sha": "1d8449fbadb1588277d4176177959ad5da8de6a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d8449fbadb1588277d4176177959ad5da8de6a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf3ce6f84a7a994a0fc87419b383b9ce4efed442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf3ce6f84a7a994a0fc87419b383b9ce4efed442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf3ce6f84a7a994a0fc87419b383b9ce4efed442", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf3ce6f84a7a994a0fc87419b383b9ce4efed442/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ef521bbc63f8a3883d507a8b6c1f95f442df3fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ef521bbc63f8a3883d507a8b6c1f95f442df3fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ef521bbc63f8a3883d507a8b6c1f95f442df3fe"}], "stats": {"total": 79, "additions": 53, "deletions": 26}, "files": [{"sha": "fb76caae72e20f7a539d618cf2161050118848d7", "filename": "gcc/testsuite/gcc.dg/pr108095.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf3ce6f84a7a994a0fc87419b383b9ce4efed442/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108095.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf3ce6f84a7a994a0fc87419b383b9ce4efed442/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108095.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108095.c?ref=bf3ce6f84a7a994a0fc87419b383b9ce4efed442", "patch": "@@ -0,0 +1,15 @@\n+/* PR tree-optimization/108095 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -g\" } */\n+\n+int v;\n+typedef unsigned T;\n+\n+void\n+foo (void)\n+{\n+  unsigned s;\n+  asm goto (\"\" : \"=r\" (*(T *) &s) : : : lab);\n+  v = 0;\n+lab:\n+}"}, {"sha": "ebe7e6992774c1399bc06ff660ee8b9de5a85a9c", "filename": "gcc/tree-into-ssa.cc", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf3ce6f84a7a994a0fc87419b383b9ce4efed442/gcc%2Ftree-into-ssa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf3ce6f84a7a994a0fc87419b383b9ce4efed442/gcc%2Ftree-into-ssa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.cc?ref=bf3ce6f84a7a994a0fc87419b383b9ce4efed442", "patch": "@@ -1934,9 +1934,8 @@ maybe_register_def (def_operand_p def_p, gimple *stmt,\n \t  tree tracked_var = target_for_debug_bind (sym);\n \t  if (tracked_var)\n \t    {\n-\t      gimple *note = gimple_build_debug_bind (tracked_var, def, stmt);\n-\t      /* If stmt ends the bb, insert the debug stmt on the single\n-\t\t non-EH edge from the stmt.  */\n+\t      /* If stmt ends the bb, insert the debug stmt on the non-EH\n+\t\t edge(s) from the stmt.  */\n \t      if (gsi_one_before_end_p (gsi) && stmt_ends_bb_p (stmt))\n \t\t{\n \t\t  basic_block bb = gsi_bb (gsi);\n@@ -1945,33 +1944,46 @@ maybe_register_def (def_operand_p def_p, gimple *stmt,\n \t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t    if (!(e->flags & EDGE_EH))\n \t\t      {\n-\t\t\tgcc_checking_assert (!ef);\n+\t\t\t/* asm goto can have multiple non-EH edges from the\n+\t\t\t   stmt.  Insert on all of them where it is\n+\t\t\t   possible.  */\n+\t\t\tgcc_checking_assert (!ef || (gimple_code (stmt)\n+\t\t\t\t\t\t     == GIMPLE_ASM));\n \t\t\tef = e;\n+\t\t\t/* If there are other predecessors to ef->dest, then\n+\t\t\t   there must be PHI nodes for the modified\n+\t\t\t   variable, and therefore there will be debug bind\n+\t\t\t   stmts after the PHI nodes.  The debug bind notes\n+\t\t\t   we'd insert would force the creation of a new\n+\t\t\t   block (diverging codegen) and be redundant with\n+\t\t\t   the post-PHI bind stmts, so don't add them.\n+\n+\t\t\t   As for the exit edge, there wouldn't be redundant\n+\t\t\t   bind stmts, but there wouldn't be a PC to bind\n+\t\t\t   them to either, so avoid diverging the CFG.  */\n+\t\t\tif (e\n+\t\t\t    && single_pred_p (e->dest)\n+\t\t\t    && gimple_seq_empty_p (phi_nodes (e->dest))\n+\t\t\t    && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t\t\t  {\n+\t\t\t    /* If there were PHI nodes in the node, we'd\n+\t\t\t       have to make sure the value we're binding\n+\t\t\t       doesn't need rewriting.  But there shouldn't\n+\t\t\t       be PHI nodes in a single-predecessor block,\n+\t\t\t       so we just add the note.  */\n+\t\t\t    gimple *note\n+\t\t\t      = gimple_build_debug_bind (tracked_var, def,\n+\t\t\t\t\t\t\t stmt);\n+\t\t\t    gsi_insert_on_edge_immediate (ef, note);\n+\t\t\t  }\n \t\t      }\n-\t\t  /* If there are other predecessors to ef->dest, then\n-\t\t     there must be PHI nodes for the modified\n-\t\t     variable, and therefore there will be debug bind\n-\t\t     stmts after the PHI nodes.  The debug bind notes\n-\t\t     we'd insert would force the creation of a new\n-\t\t     block (diverging codegen) and be redundant with\n-\t\t     the post-PHI bind stmts, so don't add them.\n-\n-\t\t     As for the exit edge, there wouldn't be redundant\n-\t\t     bind stmts, but there wouldn't be a PC to bind\n-\t\t     them to either, so avoid diverging the CFG.  */\n-\t\t  if (ef && single_pred_p (ef->dest)\n-\t\t      && ef->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t\t    {\n-\t\t      /* If there were PHI nodes in the node, we'd\n-\t\t\t have to make sure the value we're binding\n-\t\t\t doesn't need rewriting.  But there shouldn't\n-\t\t\t be PHI nodes in a single-predecessor block,\n-\t\t\t so we just add the note.  */\n-\t\t      gsi_insert_on_edge_immediate (ef, note);\n-\t\t    }\n \t\t}\n \t      else\n-\t\tgsi_insert_after (&gsi, note, GSI_SAME_STMT);\n+\t\t{\n+\t\t  gimple *note\n+\t\t    = gimple_build_debug_bind (tracked_var, def, stmt);\n+\t\t  gsi_insert_after (&gsi, note, GSI_SAME_STMT);\n+\t\t}\n \t    }\n \t}\n "}]}