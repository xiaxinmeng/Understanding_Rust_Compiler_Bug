{"sha": "870628131ce6ff529817509e256c7ee035d37bfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcwNjI4MTMxY2U2ZmY1Mjk4MTc1MDllMjU2YzdlZTAzNWQzN2JmZA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-10-20T09:00:53Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-10-20T09:00:53Z"}, "message": "cpplex.c (handle_newline, [...]): Update to do more stepping back.\n\n\t* cpplex.c (handle_newline, skip_escaped_newlines,\n\tget_effective_char, skip_block_comment, skip_line_comment,\n\tparse_identifier_slow, parse_number, parse_string,\n\t_cpp_lex_direct): Update to do more stepping back.\n\t(trigraph_ok): Similarly.  Rename trigraph_p.\n\t(SAVE_STATE, RESTORE_STATE): Remove.\n\t(BUFF_SIZE_UPPER_BOUND): Tweak.  Add sanity check.\n\n\t* cpplib.c (destringize): Rename destringize_and_run, and\n\tcall run_directive directly.\n\t(_cpp_do__Pragma): Simplify.\n\nFrom-SVN: r46373", "tree": {"sha": "f6d06251cda814a30b50a23cf4acd25227570f5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6d06251cda814a30b50a23cf4acd25227570f5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/870628131ce6ff529817509e256c7ee035d37bfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870628131ce6ff529817509e256c7ee035d37bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/870628131ce6ff529817509e256c7ee035d37bfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870628131ce6ff529817509e256c7ee035d37bfd/comments", "author": null, "committer": null, "parents": [{"sha": "3c1ef3c102885904709f853f9bef00fee86699e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c1ef3c102885904709f853f9bef00fee86699e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c1ef3c102885904709f853f9bef00fee86699e5"}], "stats": {"total": 321, "additions": 148, "deletions": 173}, "files": [{"sha": "834268dd8fc6987ce367809ad74dff46cb76c259", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870628131ce6ff529817509e256c7ee035d37bfd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870628131ce6ff529817509e256c7ee035d37bfd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=870628131ce6ff529817509e256c7ee035d37bfd", "patch": "@@ -1,3 +1,17 @@\n+2001-10-20  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpplex.c (handle_newline, skip_escaped_newlines,\n+\tget_effective_char, skip_block_comment, skip_line_comment,\n+\tparse_identifier_slow, parse_number, parse_string,\n+\t_cpp_lex_direct): Update to do more stepping back.\n+\t(trigraph_ok): Similarly.  Rename trigraph_p.\n+\t(SAVE_STATE, RESTORE_STATE): Remove.\n+\t(BUFF_SIZE_UPPER_BOUND): Tweak.  Add sanity check.\n+\n+\t* cpplib.c (destringize): Rename destringize_and_run, and\n+\tcall run_directive directly.\n+\t(_cpp_do__Pragma): Simplify.\n+\n 2001-10-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* pe.c (arm_pe_unique_section): Const-ify."}, {"sha": "814996e6be29dc009117a0578b1ec34a072f62d6", "filename": "gcc/cpplex.c", "status": "modified", "additions": 123, "deletions": 157, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870628131ce6ff529817509e256c7ee035d37bfd/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870628131ce6ff529817509e256c7ee035d37bfd/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=870628131ce6ff529817509e256c7ee035d37bfd", "patch": "@@ -20,20 +20,6 @@ You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n-/* This lexer works with a single pass of the file.  Recently I\n-   re-wrote it to minimize the places where we step backwards in the\n-   input stream, to make future changes to support multi-byte\n-   character sets fairly straight-forward.\n-\n-   There is now only one routine where we do step backwards:\n-   skip_escaped_newlines.  This routine could probably also be changed\n-   so that it doesn't need to step back.  One possibility is to use a\n-   trick similar to that used in lex_period and lex_percent.  Two\n-   extra characters might be needed, but skip_escaped_newlines itself\n-   would probably be the only place that needs to be aware of that,\n-   and changes to the remaining routines would probably only be needed\n-   if they process a backslash.  */\n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"cpplib.h\"\n@@ -81,8 +67,8 @@ static const struct token_spelling token_spellings[N_TTYPES] = { TTYPE_TABLE };\n #define TOKEN_SPELL(token) (token_spellings[(token)->type].category)\n #define TOKEN_NAME(token) (token_spellings[(token)->type].name)\n \n-static cppchar_t handle_newline PARAMS ((cpp_reader *, cppchar_t));\n-static cppchar_t skip_escaped_newlines PARAMS ((cpp_reader *, cppchar_t));\n+static void handle_newline PARAMS ((cpp_reader *));\n+static cppchar_t skip_escaped_newlines PARAMS ((cpp_reader *));\n static cppchar_t get_effective_char PARAMS ((cpp_reader *));\n \n static int skip_block_comment PARAMS ((cpp_reader *));\n@@ -96,7 +82,7 @@ static void parse_number PARAMS ((cpp_reader *, cpp_string *, cppchar_t, int));\n static int unescaped_terminator_p PARAMS ((cpp_reader *, const U_CHAR *));\n static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n static void unterminated PARAMS ((cpp_reader *, int));\n-static int trigraph_ok PARAMS ((cpp_reader *, cppchar_t));\n+static bool trigraph_p PARAMS ((cpp_reader *));\n static void save_comment PARAMS ((cpp_reader *, cpp_token *, const U_CHAR *));\n static void lex_percent PARAMS ((cpp_reader *, cpp_token *));\n static void lex_dot PARAMS ((cpp_reader *, cpp_token *));\n@@ -124,66 +110,61 @@ cpp_ideq (token, string)\n   return !ustrcmp (NODE_NAME (token->val.node), (const U_CHAR *) string);\n }\n \n-/* Call when meeting a newline.  Returns the character after the newline\n-   (or carriage-return newline combination), or EOF.  */\n-static cppchar_t\n-handle_newline (pfile, newline_char)\n+/* Call when meeting a newline, assumed to be in buffer->cur[-1].\n+   Returns with buffer->cur pointing to the character immediately\n+   following the newline (combination).  */\n+static void\n+handle_newline (pfile)\n      cpp_reader *pfile;\n-     cppchar_t newline_char;\n {\n-  cpp_buffer *buffer;\n-  cppchar_t next = EOF;\n+  cpp_buffer *buffer = pfile->buffer;\n \n-  pfile->line++;\n-  buffer = pfile->buffer;\n-  buffer->col_adjust = 0;\n-  buffer->line_base = buffer->cur;\n+  /* Handle CR-LF and LF-CR.  Most other implementations (e.g. java)\n+     only accept CR-LF; maybe we should fall back to that behaviour?\n \n-  /* Handle CR-LF and LF-CR combinations, get the next character.  */\n-  if (buffer->cur < buffer->rlimit)\n-    {\n-      next = *buffer->cur++;\n-      if (next + newline_char == '\\r' + '\\n')\n-\t{\n-\t  buffer->line_base = buffer->cur;\n-\t  if (buffer->cur < buffer->rlimit)\n-\t    next = *buffer->cur++;\n-\t  else\n-\t    next = EOF;\n-\t}\n-    }\n+     NOTE: the EOF case in _cpp_lex_direct currently requires the\n+     buffer->cur != buffer->rlimit test here for 0-length files.  */\n+  if (buffer->cur != buffer->rlimit\n+      && buffer->cur[-1] + buffer->cur[0] == '\\r' + '\\n')\n+    buffer->cur++;\n \n-  buffer->read_ahead = next;\n-  return next;\n+  buffer->line_base = buffer->cur;\n+  buffer->col_adjust = 0;\n+  pfile->line++;\n }\n \n-/* Subroutine of skip_escaped_newlines; called when a trigraph is\n-   encountered.  It warns if necessary, and returns true if the\n-   trigraph should be honoured.  FROM_CHAR is the third character of a\n-   trigraph, and presumed to be the previous character for position\n-   reporting.  */\n-static int\n-trigraph_ok (pfile, from_char)\n+/* Subroutine of skip_escaped_newlines; called when a 3-character\n+   sequence beginning with \"??\" is encountered.  buffer->cur points to\n+   the second '?'.\n+\n+   Warn if necessary, and returns true if the sequence forms a\n+   trigraph and the trigraph should be honoured.  */\n+static bool\n+trigraph_p (pfile)\n      cpp_reader *pfile;\n-     cppchar_t from_char;\n {\n-  int accept = CPP_OPTION (pfile, trigraphs);\n-  \n+  cpp_buffer *buffer = pfile->buffer;\n+  cppchar_t from_char = buffer->cur[1];\n+  bool accept;\n+\n+  if (!_cpp_trigraph_map[from_char])\n+    return false;\n+\n+  accept = CPP_OPTION (pfile, trigraphs);\n+\n   /* Don't warn about trigraphs in comments.  */\n   if (CPP_OPTION (pfile, warn_trigraphs) && !pfile->state.lexing_comment)\n     {\n-      cpp_buffer *buffer = pfile->buffer;\n-\n       if (accept)\n-\tcpp_warning_with_line (pfile, pfile->line, CPP_BUF_COL (buffer) - 2,\n+\tcpp_warning_with_line (pfile, pfile->line, CPP_BUF_COL (buffer) - 1,\n \t\t\t       \"trigraph ??%c converted to %c\",\n \t\t\t       (int) from_char,\n \t\t\t       (int) _cpp_trigraph_map[from_char]);\n       else if (buffer->cur != buffer->last_Wtrigraphs)\n \t{\n \t  buffer->last_Wtrigraphs = buffer->cur;\n \t  cpp_warning_with_line (pfile, pfile->line,\n-\t\t\t\t CPP_BUF_COL (buffer) - 2,\n+\t\t\t\t CPP_BUF_COL (buffer) - 1,\n \t\t\t\t \"trigraph ??%c ignored\", (int) from_char);\n \t}\n     }\n@@ -195,96 +176,79 @@ trigraph_ok (pfile, from_char)\n #define ACCEPT_CHAR(t) \\\n   do { result->type = t; buffer->read_ahead = EOF; } while (0)\n \n-/* When we move to multibyte character sets, add to these something\n-   that saves and restores the state of the multibyte conversion\n-   library.  This probably involves saving and restoring a \"cookie\".\n-   In the case of glibc it is an 8-byte structure, so is not a high\n-   overhead operation.  In any case, it's out of the fast path.  */\n-#define SAVE_STATE() do { saved_cur = buffer->cur; } while (0)\n-#define RESTORE_STATE() do { buffer->cur = saved_cur; } while (0)\n-\n-/* Skips any escaped newlines introduced by NEXT, which is either a\n-   '?' or a '\\\\'.  Returns the next character, which will also have\n-   been placed in buffer->read_ahead.  This routine performs\n-   preprocessing stages 1 and 2 of the ISO C standard.  */\n+/* Skips any escaped newlines introduced by '?' or a '\\\\', assumed to\n+   lie in buffer->cur[-1].  Returns the next character, which will\n+   then be in buffer->cur[-1].  This routine performs preprocessing\n+   stages 1 and 2 of the ISO C standard.  */\n static cppchar_t\n-skip_escaped_newlines (pfile, next)\n+skip_escaped_newlines (pfile)\n      cpp_reader *pfile;\n-     cppchar_t next;\n {\n   cpp_buffer *buffer = pfile->buffer;\n+  cppchar_t next = buffer->cur[-1];\n \n   /* Only do this if we apply stages 1 and 2.  */\n   if (!buffer->from_stage3)\n     {\n-      cppchar_t next1;\n       const unsigned char *saved_cur;\n-      int space;\n+      cppchar_t next1;\n \n       do\n \t{\n \t  if (buffer->cur == buffer->rlimit)\n \t    break;\n       \n-\t  SAVE_STATE ();\n \t  if (next == '?')\n \t    {\n-\t      next1 = *buffer->cur++;\n-\t      if (next1 != '?' || buffer->cur == buffer->rlimit)\n-\t\t{\n-\t\t  RESTORE_STATE ();\n-\t\t  break;\n-\t\t}\n+\t      if (buffer->cur[0] != '?' || buffer->cur + 1 == buffer->rlimit)\n+\t\tbreak;\n \n-\t      next1 = *buffer->cur++;\n-\t      if (!_cpp_trigraph_map[next1]\n-\t\t  || !trigraph_ok (pfile, next1))\n-\t\t{\n-\t\t  RESTORE_STATE ();\n-\t\t  break;\n-\t\t}\n+\t      if (!trigraph_p (pfile))\n+\t\tbreak;\n \n-\t      /* We have a full trigraph here.  */\n-\t      next = _cpp_trigraph_map[next1];\n+\t      /* Translate the trigraph.  */\n+\t      next = _cpp_trigraph_map[buffer->cur[1]];\n+\t      buffer->cur += 2;\n \t      if (next != '\\\\' || buffer->cur == buffer->rlimit)\n \t\tbreak;\n-\t      SAVE_STATE ();\n \t    }\n \n-\t  /* We have a backslash, and room for at least one more character.  */\n-\t  space = 0;\n+\t  /* We have a backslash, and room for at least one more\n+\t     character.  Skip horizontal whitespace.  */\n+\t  saved_cur = buffer->cur;\n \t  do\n-\t    {\n-\t      next1 = *buffer->cur++;\n-\t      if (!is_nvspace (next1))\n-\t\tbreak;\n-\t      space = 1;\n-\t    }\n-\t  while (buffer->cur < buffer->rlimit);\n+\t    next1 = *buffer->cur++;\n+\t  while (is_nvspace (next1) && buffer->cur < buffer->rlimit);\n \n \t  if (!is_vspace (next1))\n \t    {\n-\t      RESTORE_STATE ();\n+\t      buffer->cur = saved_cur;\n \t      break;\n \t    }\n \n-\t  if (space && !pfile->state.lexing_comment)\n+\t  if (saved_cur != buffer->cur - 1\n+\t      && !pfile->state.lexing_comment)\n \t    cpp_warning (pfile, \"backslash and newline separated by space\");\n \n-\t  next = handle_newline (pfile, next1);\n-\t  if (next == EOF)\n-\t    cpp_pedwarn (pfile, \"backslash-newline at end of file\");\n+\t  handle_newline (pfile);\n+\t  if (buffer->cur == buffer->rlimit)\n+\t    {\n+\t      cpp_pedwarn (pfile, \"backslash-newline at end of file\");\n+\t      next = EOF;\n+\t    }\n+\t  else\n+\t    next = *buffer->cur++;\n \t}\n       while (next == '\\\\' || next == '?');\n     }\n \n-  buffer->read_ahead = next;\n   return next;\n }\n \n /* Obtain the next character, after trigraph conversion and skipping\n-   an arbitrary string of escaped newlines.  The common case of no\n-   trigraphs or escaped newlines falls through quickly.  */\n+   an arbitrarily long string of escaped newlines.  The common case of\n+   no trigraphs or escaped newlines falls through quickly.  On return,\n+   buffer->cur points after the returned character.  */\n static cppchar_t\n get_effective_char (pfile)\n      cpp_reader *pfile;\n@@ -301,7 +265,7 @@ get_effective_char (pfile)\n \t UCNs, which, depending upon lexer state, we will handle in\n \t the future.  */\n       if (next == '?' || next == '\\\\')\n-\tnext = skip_escaped_newlines (pfile, next);\n+\tnext = skip_escaped_newlines (pfile);\n     }\n \n   buffer->read_ahead = next;\n@@ -323,11 +287,10 @@ skip_block_comment (pfile)\n     {\n       prevc = c, c = *buffer->cur++;\n \n-    next_char:\n       /* FIXME: For speed, create a new character class of characters\n \t of interest inside block comments.  */\n       if (c == '?' || c == '\\\\')\n-\tc = skip_escaped_newlines (pfile, c);\n+\tc = skip_escaped_newlines (pfile);\n \n       /* People like decorating comments with '*', so check for '/'\n \t instead for efficiency.  */\n@@ -340,25 +303,14 @@ skip_block_comment (pfile)\n \t     comes immediately before the true comment delimeter.\n \t     Don't bother to get it right across escaped newlines.  */\n \t  if (CPP_OPTION (pfile, warn_comments)\n-\t      && buffer->cur != buffer->rlimit)\n-\t    {\n-\t      prevc = c, c = *buffer->cur++;\n-\t      if (c == '*' && buffer->cur != buffer->rlimit)\n-\t\t{\n-\t\t  prevc = c, c = *buffer->cur++;\n-\t\t  if (c != '/') \n-\t\t    cpp_warning_with_line (pfile, pfile->line,\n-\t\t\t\t\t   CPP_BUF_COL (buffer) - 2,\n-\t\t\t\t\t   \"\\\"/*\\\" within comment\");\n-\t\t}\n-\t      goto next_char;\n-\t    }\n+\t      && buffer->cur + 1 < buffer->rlimit\n+\t      && buffer->cur[0] == '*' && buffer->cur[1] != '/')\n+\t    cpp_warning_with_line (pfile,\n+\t\t\t\t   pfile->line, CPP_BUF_COL (buffer),\n+\t\t\t\t   \"\\\"/*\\\" within comment\");\n \t}\n       else if (is_vspace (c))\n-\t{\n-\t  prevc = c, c = handle_newline (pfile, c);\n-\t  goto next_char;\n-\t}\n+\thandle_newline (pfile);\n       else if (c == '\\t')\n \tadjust_column (pfile);\n     }\n@@ -388,7 +340,7 @@ skip_line_comment (pfile)\n \n       c = *buffer->cur++;\n       if (c == '?' || c == '\\\\')\n-\tc = skip_escaped_newlines (pfile, c);\n+\tc = skip_escaped_newlines (pfile);\n     }\n   while (!is_vspace (c));\n \n@@ -568,7 +520,7 @@ parse_identifier_slow (pfile, cur)\n       /* Potential escaped newline?  */\n       if (c != '?' && c != '\\\\')\n         break;\n-      c = skip_escaped_newlines (pfile, c);\n+      c = skip_escaped_newlines (pfile);\n     }\n   while (is_idchar (c));\n \n@@ -640,7 +592,7 @@ parse_number (pfile, number, c, leading_period)\n       /* Potential escaped newline?  */\n       if (c != '?' && c != '\\\\')\n \tbreak;\n-      c = skip_escaped_newlines (pfile, c);\n+      c = skip_escaped_newlines (pfile);\n     }\n   while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));\n \n@@ -697,8 +649,10 @@ unescaped_terminator_p (pfile, dest)\n    name.  Handles embedded trigraphs and escaped newlines.  The stored\n    string is guaranteed NUL-terminated, but it is not guaranteed that\n    this is the first NUL since embedded NULs are preserved.\n+   Multi-line strings are allowed, but they are deprecated.\n \n-   Multi-line strings are allowed, but they are deprecated.  */\n+   When this function returns, buffer->cur points to the next\n+   character to be processed.  */\n static void\n parse_string (pfile, token, terminator)\n      cpp_reader *pfile;\n@@ -715,13 +669,7 @@ parse_string (pfile, token, terminator)\n \n   for (;;)\n     {\n-      if (buffer->cur == buffer->rlimit)\n-\tc = EOF;\n-      else\n-\tc = *buffer->cur++;\n-\n-    have_char:\n-      /* We need space for the terminating NUL.  */\n+      /* We need room for another char, possibly the terminating NUL.  */\n       if ((size_t) (limit - dest) < 1)\n \t{\n \t  size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n@@ -730,28 +678,32 @@ parse_string (pfile, token, terminator)\n \t  limit = BUFF_LIMIT (pfile->u_buff);\n \t}\n \n-      if (c == EOF)\n+      if (buffer->cur == buffer->rlimit)\n \t{\n \t  unterminated (pfile, terminator);\n \t  break;\n \t}\n \n       /* Handle trigraphs, escaped newlines etc.  */\n+      c = *buffer->cur++;\n       if (c == '?' || c == '\\\\')\n-\tc = skip_escaped_newlines (pfile, c);\n+\tc = skip_escaped_newlines (pfile);\n \n-      if (c == terminator && unescaped_terminator_p (pfile, dest))\n+      if (c == terminator)\n \t{\n-\t  c = EOF;\n-\t  break;\n+\t  if (unescaped_terminator_p (pfile, dest))\n+\t    break;\n \t}\n       else if (is_vspace (c))\n \t{\n \t  /* In assembly language, silently terminate string and\n \t     character literals at end of line.  This is a kludge\n \t     around not knowing where comments are.  */\n \t  if (CPP_OPTION (pfile, lang) == CLK_ASM && terminator != '>')\n-\t    break;\n+\t    {\n+\t      buffer->cur--;\n+\t      break;\n+\t    }\n \n \t  /* Character constants and header names may not extend over\n \t     multiple lines.  In Standard C, neither may strings.\n@@ -760,6 +712,7 @@ parse_string (pfile, token, terminator)\n \t  if (terminator != '\"' || pfile->state.angled_headers)\n \t    {\n \t      unterminated (pfile, terminator);\n+\t      buffer->cur--;\n \t      break;\n \t    }\n \n@@ -775,9 +728,8 @@ parse_string (pfile, token, terminator)\n \t      pfile->mls_col = token->col;\n \t    }\n \t      \n-\t  c = handle_newline (pfile, c);\n-\t  *dest++ = '\\n';\n-\t  goto have_char;\n+\t  handle_newline (pfile);\n+\t  c = '\\n';\n \t}\n       else if (c == '\\0' && !warned_nulls)\n \t{\n@@ -788,8 +740,7 @@ parse_string (pfile, token, terminator)\n       *dest++ = c;\n     }\n \n-  /* Remember the next character.  */\n-  buffer->read_ahead = c;\n+  buffer->read_ahead = EOF;\n   *dest = '\\0';\n \n   token->val.str.text = BUFF_FRONT (pfile->u_buff);\n@@ -1066,7 +1017,7 @@ _cpp_lex_direct (pfile)\n \t\t for command line and _Pragma buffers.  */\n \t      if (!buffer->from_stage3)\n \t\tcpp_pedwarn (pfile, \"no newline at end of file\");\n-\t      handle_newline (pfile, '\\n');\n+\t      handle_newline (pfile);\n \t    }\n \n \t  /* Don't pop the last buffer.  */\n@@ -1088,7 +1039,7 @@ _cpp_lex_direct (pfile)\n       goto skipped_white;\n \n     case '\\n': case '\\r':\n-      handle_newline (pfile, c);\n+      handle_newline (pfile);\n       buffer->saved_flags = BOL;\n       if (! pfile->state.in_directive)\n \t{\n@@ -1112,12 +1063,14 @@ _cpp_lex_direct (pfile)\n       {\n \tunsigned int line = pfile->line;\n \n-\tc = skip_escaped_newlines (pfile, c);\n+\tc = skip_escaped_newlines (pfile);\n \tif (line != pfile->line)\n-\t  /* We had at least one escaped newline of some sort, and the\n-\t     next character is in buffer->read_ahead.  Update the\n-\t     token's line and column.  */\n+\t  {\n+\t    buffer->read_ahead = c;\n+\t    /* We had at least one escaped newline of some sort.\n+\t       Update the token's line and column.  */\n \t    goto update_tokens_line;\n+\t  }\n \n \t/* We are either the original '?' or '\\\\', or a trigraph.  */\n \tresult->type = CPP_QUERY;\n@@ -2045,10 +1998,14 @@ cpp_interpret_charconst (pfile, token, warn_multi, traditional, pchars_seen)\n    expansion.  Also check the change in peak memory usage (NJAMD is a\n    good tool for this).  */\n #define MIN_BUFF_SIZE 8000\n-#define BUFF_SIZE_UPPER_BOUND(MIN_SIZE) (8000 + (MIN_SIZE) * 3 / 2)\n+#define BUFF_SIZE_UPPER_BOUND(MIN_SIZE) (MIN_BUFF_SIZE + (MIN_SIZE) * 3 / 2)\n #define EXTENDED_BUFF_SIZE(BUFF, MIN_EXTRA) \\\n \t(MIN_EXTRA + ((BUFF)->limit - (BUFF)->cur) * 2)\n \n+#if MIN_BUFF_SIZE > BUFF_SIZE_UPPER_BOUND (0)\n+  #error BUFF_SIZE_UPPER_BOUND must be at least as large as MIN_BUFF_SIZE!\n+#endif\n+\n struct dummy\n {\n   char c;\n@@ -2199,7 +2156,16 @@ _cpp_unaligned_alloc (pfile, len)\n   return result;\n }\n \n-/* Allocate permanent, unaligned storage of length LEN.  */\n+/* Allocate permanent, unaligned storage of length LEN from a_buff.\n+   That buffer is used for growing allocations when saving macro\n+   replacement lists in a #define, and when parsing an answer to an\n+   assertion in #assert, #unassert or #if (and therefore possibly\n+   whilst expanding macros).  It therefore must not be used by any\n+   code that they might call: specifically the lexer and the guts of\n+   the macro expander.\n+\n+   All existing other uses clearly fit this restriction: storing\n+   registered pragmas during initialization.  */\n unsigned char *\n _cpp_aligned_alloc (pfile, len)\n      cpp_reader *pfile;"}, {"sha": "11c3b6c4aff4a2b30a1f63fdc37685bd28621da2", "filename": "gcc/cpplib.c", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870628131ce6ff529817509e256c7ee035d37bfd/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870628131ce6ff529817509e256c7ee035d37bfd/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=870628131ce6ff529817509e256c7ee035d37bfd", "patch": "@@ -120,8 +120,7 @@ static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n static void do_pragma_dependency\tPARAMS ((cpp_reader *));\n static const cpp_token *get_token_no_padding PARAMS ((cpp_reader *));\n static const cpp_token *get__Pragma_string PARAMS ((cpp_reader *));\n-static unsigned char *destringize\tPARAMS ((const cpp_string *,\n-\t\t\t\t\t\t unsigned int *));\n+static void destringize_and_run PARAMS ((cpp_reader *, const cpp_string *));\n static int parse_answer PARAMS ((cpp_reader *, struct answer **, int));\n static cpp_hashnode *parse_assertion PARAMS ((cpp_reader *, struct answer **,\n \t\t\t\t\t      int));\n@@ -1149,17 +1148,17 @@ get__Pragma_string (pfile)\n   return string;\n }\n \n-/* Returns a malloced buffer containing a destringized cpp_string by\n-   removing the first \\ of \\\" and \\\\ sequences.  */\n-static unsigned char *\n-destringize (in, len)\n+/* Destringize IN into a temporary buffer, by removing the first \\ of\n+   \\\" and \\\\ sequences, and process the result as a #pragma directive.  */\n+static void\n+destringize_and_run (pfile, in)\n+     cpp_reader *pfile;\n      const cpp_string *in;\n-     unsigned int *len;\n {\n   const unsigned char *src, *limit;\n-  unsigned char *dest, *result;\n+  char *dest, *result;\n \n-  dest = result = (unsigned char *) xmalloc (in->len);\n+  dest = result = alloca (in->len);\n   for (src = in->text, limit = src + in->len; src < limit;)\n     {\n       /* We know there is a character following the backslash.  */\n@@ -1168,17 +1167,15 @@ destringize (in, len)\n       *dest++ = *src++;\n     }\n \n-  *len = dest - result;\n-  return result;\n+  run_directive (pfile, T_PRAGMA, result, dest - result);\n }\n \n+/* Handle the _Pragma operator.  */\n void\n _cpp_do__Pragma (pfile)\n      cpp_reader *pfile;\n {\n   const cpp_token *string = get__Pragma_string (pfile);\n-  unsigned char *buffer;\n-  unsigned int len;\n \n   if (!string)\n     cpp_error (pfile, \"_Pragma takes a parenthesized string literal\");\n@@ -1195,9 +1192,7 @@ _cpp_do__Pragma (pfile)\n \t Getting these correct line markers is a little tricky.  */\n \n       unsigned int orig_line = pfile->line;\n-      buffer = destringize (&string->val.str, &len);\n-      run_directive (pfile, T_PRAGMA, (char *) buffer, len);\n-      free ((PTR) buffer);\n+      destringize_and_run (pfile, &string->val.str);\n       pfile->line = orig_line;\n       pfile->buffer->saved_flags = BOL;\n     }"}]}