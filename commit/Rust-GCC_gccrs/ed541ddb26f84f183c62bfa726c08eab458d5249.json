{"sha": "ed541ddb26f84f183c62bfa726c08eab458d5249", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ1NDFkZGIyNmY4NGYxODNjNjJiZmE3MjZjMDhlYWI0NThkNTI0OQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-05-01T20:46:22Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-05-01T20:46:22Z"}, "message": "re PR rtl-optimization/27291 (verify_flow_info failed: too many outgoing branch edges from bb 4)\n\n\tPR rtl-optimization/27291\n\t* loop-doloop.c (add_test, doloop_modify): Handle the case condition is\n\tfolded to a constant.\n\n\t* g++.dg/tree-ssa/pr27291.C: New test.\n\nFrom-SVN: r113430", "tree": {"sha": "15358e023210ce73c6110372729737d308f371bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15358e023210ce73c6110372729737d308f371bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed541ddb26f84f183c62bfa726c08eab458d5249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed541ddb26f84f183c62bfa726c08eab458d5249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed541ddb26f84f183c62bfa726c08eab458d5249", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed541ddb26f84f183c62bfa726c08eab458d5249/comments", "author": null, "committer": null, "parents": [{"sha": "dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df"}], "stats": {"total": 484, "additions": 447, "deletions": 37}, "files": [{"sha": "cc84960161732b3e66ebcb0948ed9b30a2272bb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed541ddb26f84f183c62bfa726c08eab458d5249/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed541ddb26f84f183c62bfa726c08eab458d5249/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed541ddb26f84f183c62bfa726c08eab458d5249", "patch": "@@ -1,3 +1,9 @@\n+2006-05-01  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR rtl-optimization/27291\n+\t* loop-doloop.c (add_test, doloop_modify): Handle the case condition is\n+\tfolded to a constant.\n+\n 2006-05-01  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/27283"}, {"sha": "f63e3426a47d8675125be0932640a88c662df27a", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 73, "deletions": 37, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed541ddb26f84f183c62bfa726c08eab458d5249/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed541ddb26f84f183c62bfa726c08eab458d5249/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=ed541ddb26f84f183c62bfa726c08eab458d5249", "patch": "@@ -223,15 +223,19 @@ doloop_valid_p (struct loop *loop, struct niter_desc *desc)\n   return result;\n }\n \n-/* Adds test of COND jumping to DEST to the end of BB.  */\n+/* Adds test of COND jumping to DEST on edge *E and set *E to the new fallthru\n+   edge.  If the condition is always false, do not do anything.  If it is always\n+   true, redirect E to DEST and return false.  In all other cases, true is\n+   returned.  */\n \n-static void\n-add_test (rtx cond, basic_block bb, basic_block dest)\n+static bool\n+add_test (rtx cond, edge *e, basic_block dest)\n {\n   rtx seq, jump, label;\n   enum machine_mode mode;\n   rtx op0 = XEXP (cond, 0), op1 = XEXP (cond, 1);\n   enum rtx_code code = GET_CODE (cond);\n+  basic_block bb;\n \n   mode = GET_MODE (XEXP (cond, 0));\n   if (mode == VOIDmode)\n@@ -244,22 +248,36 @@ add_test (rtx cond, basic_block bb, basic_block dest)\n   do_compare_rtx_and_jump (op0, op1, code, 0, mode, NULL_RTX, NULL_RTX, label);\n \n   jump = get_last_insn ();\n-  /* It is possible for the jump to be optimized out.  */\n-  if (JUMP_P (jump))\n+  if (!JUMP_P (jump))\n     {\n-      JUMP_LABEL (jump) = label;\n-\n-       /* The jump is supposed to handle an unlikely special case.  */\n-      REG_NOTES (jump)\n-\t= gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t     const0_rtx, REG_NOTES (jump));\n-\n-      LABEL_NUSES (label)++;\n+      /* The condition is always false and the jump was optimized out.  */\n+      end_sequence ();\n+      return true;\n     }\n \n   seq = get_insns ();\n   end_sequence ();\n-  emit_insn_after (seq, BB_END (bb));\n+  bb = loop_split_edge_with (*e, seq);\n+  *e = single_succ_edge (bb);\n+\n+  if (any_uncondjump_p (jump))\n+    {\n+      /* The condition is always true.  */\n+      delete_insn (jump);\n+      redirect_edge_and_branch_force (*e, dest);\n+      return false;\n+    }\n+      \n+  JUMP_LABEL (jump) = label;\n+\n+  /* The jump is supposed to handle an unlikely special case.  */\n+  REG_NOTES (jump)\n+\t  = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t       const0_rtx, REG_NOTES (jump));\n+  LABEL_NUSES (label)++;\n+\n+  make_edge (bb, dest, (*e)->flags & ~EDGE_FALLTHRU);\n+  return true;\n }\n \n /* Modify the loop to use the low-overhead looping insn where LOOP\n@@ -277,7 +295,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n   rtx sequence;\n   rtx jump_insn;\n   rtx jump_label;\n-  int nonneg = 0, irr;\n+  int nonneg = 0;\n   bool increment_count;\n   basic_block loop_end = desc->out_edge->src;\n   enum machine_mode mode;\n@@ -357,39 +375,57 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n \t      = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n       basic_block new_preheader\n \t      = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n-      basic_block bb;\n       edge te;\n-      gcov_type cnt;\n \n       /* Expand the condition testing the assumptions and if it does not pass,\n \t reset the count register to 0.  */\n-      add_test (XEXP (ass, 0), preheader, set_zero);\n-      single_succ_edge (preheader)->flags &= ~EDGE_FALLTHRU;\n-      cnt = single_succ_edge (preheader)->count;\n-      single_succ_edge (preheader)->probability = 0;\n-      single_succ_edge (preheader)->count = 0;\n-      irr = single_succ_edge (preheader)->flags & EDGE_IRREDUCIBLE_LOOP;\n-      te = make_edge (preheader, new_preheader, EDGE_FALLTHRU | irr);\n-      te->probability = REG_BR_PROB_BASE;\n-      te->count = cnt;\n+      redirect_edge_and_branch_force (single_succ_edge (preheader), new_preheader);\n       set_immediate_dominator (CDI_DOMINATORS, new_preheader, preheader);\n \n       set_zero->count = 0;\n       set_zero->frequency = 0;\n \n-      for (ass = XEXP (ass, 1); ass; ass = XEXP (ass, 1))\n+      te = single_succ_edge (preheader);\n+      for (; ass; ass = XEXP (ass, 1))\n+\tif (!add_test (XEXP (ass, 0), &te, set_zero))\n+\t  break;\n+\n+      if (ass)\n \t{\n-\t  bb = loop_split_edge_with (te, NULL_RTX);\n-\t  te = single_succ_edge (bb);\n-\t  add_test (XEXP (ass, 0), bb, set_zero);\n-\t  make_edge (bb, set_zero, irr);\n+\t  /* We reached a condition that is always true.  This is very hard to\n+\t     reproduce (such a loop does not roll, and thus it would most\n+\t     likely get optimized out by some of the preceding optimizations).\n+\t     In fact, I do not have any testcase for it.  However, it would\n+\t     also be very hard to show that it is impossible, so we must\n+\t     handle this case.  */\n+\t  set_zero->count = preheader->count;\n+\t  set_zero->frequency = preheader->frequency;\n \t}\n-  \n-      start_sequence ();\n-      convert_move (counter_reg, noloop, 0);\n-      sequence = get_insns ();\n-      end_sequence ();\n-      emit_insn_after (sequence, BB_END (set_zero));\n+ \n+      if (EDGE_COUNT (set_zero->preds) == 0)\n+\t{\n+\t  /* All the conditions were simplified to false, remove the\n+\t     unreachable set_zero block.  */\n+\t  remove_bb_from_loops (set_zero);\n+\t  delete_basic_block (set_zero);\n+\t}\n+      else\n+\t{\n+\t  /* Reset the counter to zero in the set_zero block.  */\n+\t  start_sequence ();\n+\t  convert_move (counter_reg, noloop, 0);\n+\t  sequence = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insn_after (sequence, BB_END (set_zero));\n+      \n+\t  set_immediate_dominator (CDI_DOMINATORS, set_zero,\n+\t\t\t\t   recount_dominator (CDI_DOMINATORS,\n+\t\t\t\t\t\t      set_zero));\n+\t}\n+\n+      set_immediate_dominator (CDI_DOMINATORS, new_preheader,\n+\t\t\t       recount_dominator (CDI_DOMINATORS,\n+\t\t\t\t\t\t  new_preheader));\n     }\n \n   /* Some targets (eg, C4x) need to initialize special looping"}, {"sha": "ad32581b5120f119a8bd44d7e97896a373aabffb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed541ddb26f84f183c62bfa726c08eab458d5249/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed541ddb26f84f183c62bfa726c08eab458d5249/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ed541ddb26f84f183c62bfa726c08eab458d5249", "patch": "@@ -1,3 +1,8 @@\n+2006-05-01  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/27291\n+\t* g++.dg/tree-ssa/pr27291.C: New test.\n+\n 2006-05-01  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/27283"}, {"sha": "b8b5e136a4645c5a1fdc111fdb56d8b1a3913942", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr27291.C", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed541ddb26f84f183c62bfa726c08eab458d5249/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr27291.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed541ddb26f84f183c62bfa726c08eab458d5249/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr27291.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr27291.C?ref=ed541ddb26f84f183c62bfa726c08eab458d5249", "patch": "@@ -0,0 +1,363 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+namespace std\n+{\n+  template < class _T1, class _T2 > struct pair\n+  {\n+  };\n+}\n+extern \"C\"\n+{\n+  extern \"C\"\n+  {\n+    typedef int int32_t __attribute__ ((__mode__ (__SI__)));\n+    struct _pthread_fastlock\n+    {\n+    }\n+    pthread_mutexattr_t;\n+  }\n+}\n+namespace std\n+{\n+  struct __numeric_limits_base\n+  {\n+  };\n+    template < typename _Tp >\n+    struct numeric_limits:public __numeric_limits_base\n+  {\n+    static const bool is_integer = true;\n+  };\n+};\n+typedef unsigned int uint32_t;\n+namespace std\n+{\n+  template < typename _Alloc > class allocator;\n+  template < class _CharT > struct char_traits;\n+    template < typename _CharT, typename _Traits =\n+    char_traits < _CharT >, typename _Alloc =\n+    allocator < _CharT > >class basic_string;\n+  typedef basic_string < char >string;\n+}\n+namespace __gnu_cxx\n+{\n+  template < typename _Tp > class new_allocator\n+  {\n+  };\n+}\n+namespace std\n+{\n+  template < typename _Tp > class allocator:public __gnu_cxx::new_allocator <\n+    _Tp >\n+  {\n+  };\n+  template < typename _CharT, typename _Traits,\n+    typename _Alloc > class basic_string\n+  {\n+  public:inline basic_string ();\n+    basic_string (const _CharT * __s, const _Alloc & __a = _Alloc ());\n+  };\n+}\n+namespace boost\n+{\n+  template < class T > class integer_traits:public std::numeric_limits < T >\n+  {\n+  };\n+  namespace detail\n+  {\n+    template < class T, T min_val, T max_val > class integer_traits_base\n+    {\n+    };\n+  }\n+  template <> class integer_traits < int >:public std::numeric_limits < int >,\n+    public detail::integer_traits_base < int, (-2147483647 - 1), 2147483647 >\n+  {\n+  };\n+  namespace random\n+  {\n+    template < class IntType, IntType m > class const_mod\n+    {\n+    public:static IntType add (IntType x, IntType c)\n+      {\n+      }\n+      static IntType mult (IntType a, IntType x)\n+      {\n+\treturn mult_schrage (a, x);\n+      }\n+      static IntType mult_add (IntType a, IntType x, IntType c)\n+      {\n+\treturn add (mult (a, x), c);\n+      }\n+      static IntType mult_schrage (IntType a, IntType value)\n+      {\n+\tfor (;;)\n+\t  {\n+\t    if (value > 0)\n+\t      break;\n+\t    value += m;\n+\t  }\n+      }\n+    };\n+    template < class IntType, IntType a, IntType c, IntType m,\n+      IntType val > class linear_congruential\n+    {\n+    public:typedef IntType result_type;\n+      static const IntType modulus = m;\n+    explicit linear_congruential (IntType x0 = 1):_modulus (modulus),\n+\t_x (_modulus ? (x0 % _modulus) :\n+\t    x0)\n+      {\n+      }\n+      IntType operator    () ()\n+      {\n+\t_x = const_mod < IntType, m >::mult_add (a, _x, c);\n+      }\n+    private:IntType _modulus;\n+      IntType _x;\n+    };\n+  }\n+  typedef random::linear_congruential < int32_t, 16807, 0, 2147483647,\n+    1043618065 > minstd_rand0;\n+  namespace random\n+  {\n+    namespace detail\n+    {\n+      template < class T > struct ptr_helper\n+      {\n+\ttypedef T value_type;\n+\ttypedef T & reference_type;\n+\ttypedef const T & rvalue_type;\n+\tstatic reference_type ref (T & r)\n+\t{\n+\t}\n+      };\n+        template < class T > struct ptr_helper <T & >\n+      {\n+\ttypedef T value_type;\n+\ttypedef T & rvalue_type;\n+      };\n+    }\n+  }\n+  template < class UniformRandomNumberGenerator, class RealType =\n+    double >class uniform_01\n+  {\n+  public:typedef UniformRandomNumberGenerator base_type;\n+    typedef RealType result_type;\n+    explicit uniform_01 (base_type rng):_rng (rng),\n+      _factor (result_type (1) /\n+\t       (result_type ((_rng.max) () - (_rng.min) ()) +\n+\t\tresult_type (std::numeric_limits <\n+\t\t\t     base_result >::is_integer ? 1 : 0)))\n+    {\n+    }\n+    result_type operator    () ()\n+    {\n+      return result_type (_rng () - (_rng.min) ()) * _factor;\n+    }\n+  private:typedef typename base_type::result_type base_result;\n+    base_type _rng;\n+    result_type _factor;\n+  };\n+  namespace random\n+  {\n+    namespace detail\n+    {\n+      template < class UniformRandomNumberGenerator >\n+\tclass pass_through_engine\n+      {\n+      private:typedef ptr_helper < UniformRandomNumberGenerator >\n+\t  helper_type;\n+      public:typedef typename helper_type::value_type base_type;\n+\ttypedef typename base_type::result_type result_type;\n+\texplicit pass_through_engine (UniformRandomNumberGenerator\n+\t\t\t\t      rng):_rng (static_cast <\n+\t\t\t\t\t\t typename helper_type::\n+\t\t\t\t\t\t rvalue_type > (rng))\n+\t{\n+\t}\n+\tresult_type min () const\n+\t{\n+\t}\n+\tresult_type max () const\n+\t{\n+\t}\n+\tbase_type & base ()\n+\t{\n+\t}\n+\tresult_type operator    () ()\n+\t{\n+\t  return base ()();\n+\t}\n+      private:UniformRandomNumberGenerator _rng;\n+      };\n+    }\n+    template < class RealType, int w, unsigned int p,\n+      unsigned int q > class lagged_fibonacci_01\n+    {\n+    public:typedef RealType result_type;\n+      static const unsigned int long_lag = p;\n+        lagged_fibonacci_01 ()\n+      {\n+\tseed ();\n+      }\n+    public:void seed (uint32_t value = 331u)\n+      {\n+\tminstd_rand0 intgen (value);\n+\tseed (intgen);\n+      }\n+      template < class Generator > void seed (Generator & gen)\n+      {\n+\ttypedef detail::pass_through_engine < Generator & >ref_gen;\n+\tuniform_01 < ref_gen, RealType > gen01 =\n+\t  uniform_01 < ref_gen, RealType > (ref_gen (gen));\n+\tfor (unsigned int j = 0; j < long_lag; ++j)\n+\t  x[j] = gen01 ();\n+      }\n+      RealType x[long_lag];\n+    };\n+  }\n+  typedef random::lagged_fibonacci_01 < double, 48, 607,\n+    273 > lagged_fibonacci607;\n+  namespace random\n+  {\n+    namespace detail\n+    {\n+      template < bool have_int, bool want_int > struct engine_helper;\n+        template <> struct engine_helper <true, true >\n+      {\n+\ttemplate < class Engine, class DistInputType > struct impl\n+\t{\n+\t  typedef pass_through_engine < Engine > type;\n+\t};\n+      };\n+    }\n+  }\n+  template < class Engine, class Distribution > class variate_generator\n+  {\n+  private:typedef random::detail::pass_through_engine < Engine >\n+      decorated_engine;\n+  public:typedef typename decorated_engine::base_type engine_value_type;\n+    typedef Distribution distribution_type;\n+  variate_generator (Engine e, Distribution d):_eng (decorated_engine (e)),\n+      _dist (d)\n+    {\n+    }\n+  private:enum\n+    {\n+      have_int =\n+\tstd::numeric_limits <\n+\ttypename decorated_engine::result_type >::is_integer, want_int =\n+\tstd::numeric_limits < typename Distribution::input_type >::is_integer\n+    };\n+    typedef typename random::detail::engine_helper < have_int,\n+      want_int >::template impl < decorated_engine,\n+      typename Distribution::input_type >::type internal_engine_type;\n+    internal_engine_type _eng;\n+    distribution_type _dist;\n+  };\n+  template < class RealType = double >class uniform_real\n+  {\n+  public:typedef RealType input_type;\n+  };\n+}\n+namespace alps\n+{\n+  class BufferedRandomNumberGeneratorBase\n+  {\n+  };\n+    template < class RNG >\n+    class BufferedRandomNumberGenerator:public\n+    BufferedRandomNumberGeneratorBase\n+  {\n+  public: BufferedRandomNumberGenerator ():rng_ (), gen_ (rng_,\n+\t\t   boost::\n+\t\t   uniform_real <> ())\n+    {\n+    }\n+  protected:  RNG rng_;\n+    boost::variate_generator < RNG &, boost::uniform_real <> >gen_;\n+  };\n+}\n+namespace boost\n+{\n+  namespace detail\n+  {\n+    class sp_counted_base\n+    {\n+    };\n+    class shared_count\n+    {\n+    private:sp_counted_base * pi_;\n+    public:shared_count ():pi_ (0)\n+      {\n+      }\n+      template < class Y > explicit shared_count (Y * p):pi_ (0)\n+      {\n+      }\n+    };\n+  }\n+  template < class T > class shared_ptr\n+  {\n+  public:typedef T element_type;\n+  template < class Y > explicit shared_ptr (Y * p):px (p), pn (p)\n+    {\n+    }\n+    T *px;\n+    detail::shared_count pn;\n+  };\n+}\n+namespace std\n+{\n+  template < typename _Key, typename _Tp, typename _Compare =\n+    std::allocator < std::pair < const _Key, _Tp > > > class map\n+  {\n+  public:typedef _Key key_type;\n+    typedef _Tp mapped_type;\n+      mapped_type & operator[] (const key_type & __k)\n+    {\n+    }\n+  };\n+}\n+namespace alps\n+{\n+  namespace detail\n+  {\n+    template < class BASE > class abstract_creator\n+    {\n+    public:typedef BASE base_type;\n+      virtual base_type *create () const = 0;\n+    };\n+      template < class BASE,\n+      class T > class creator:public abstract_creator < BASE >\n+    {\n+    public:typedef BASE base_type;\n+      base_type *create () const\n+      {\n+\treturn new T ();\n+      }\n+    };\n+  }\n+  template < class KEY, class BASE > class factory\n+  {\n+  public:typedef BASE base_type;\n+    typedef KEY key_type;\n+    typedef boost::shared_ptr < detail::abstract_creator < base_type >\n+      >pointer_type;\n+    template < class T > bool register_type (key_type k)\n+    {\n+      creators_[k] = pointer_type (new detail::creator < BASE, T > ());\n+    }\n+  private:typedef std::map < key_type, pointer_type > map_type;\n+    map_type creators_;\n+  };\n+  class RNGFactory:public factory < std::string,\n+    BufferedRandomNumberGeneratorBase >\n+  {\n+  public:RNGFactory ();\n+  };\n+}\n+alps::RNGFactory::RNGFactory ()\n+{\n+  register_type < BufferedRandomNumberGenerator < boost::lagged_fibonacci607 >\n+    >(\"lagged_fibonacci607\");\n+}"}]}