{"sha": "0005550b5832aa6f0a3d7f343319c6b5b327dde8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAwNTU1MGI1ODMyYWE2ZjBhM2Q3ZjM0MzMxOWM2YjViMzI3ZGRlOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-23T14:08:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-23T14:08:12Z"}, "message": "basic-block.h (find_sub_basic_block): Declare.\n\n\t* basic-block.h (find_sub_basic_block): Declare.\n\t* flow.c (make_edges): New arguments MIN and MAX;\n\t(find_sub_basic_blocks): Revamp to use make_edges\n\tand purge_dead_edges.\n\t(find_basic_blocks): Update call of find_sub_basic_block.\n\n\t* recog.c (split_all_insns): Always expect CFG to be consistent;\n\tcall find_sub_basic_blocks in case something has changed.\n\t* toplev.c (rest_of_compilation): Always call split_all_insns once CFG\n\thas been built.\n\n\t* basic-block.h (delete_noop_moves): Declare.\n\t* combine.c (combine_instructions): Call it.\n\t(recog_for_combine): Tolerate noop moves\n\t(distribute_notes): Force refresh when register dies at noop move.\n\t* flow.c (delete_noop_moves): Use BB structure; delete JUMP insns\n\ttoo.\n\t(life_analysis): Update delete_noop_moves call.\n\t(set_noop_p): Move too ...\n\t* rtlanal.c (noop_move_p): ... here.\n\t* rtl.h (noop_move_p): Declare.\n\n\t* basic-block.h (purge_all_dead_edges, purge_dead_edges): New functions.\n\t* toplev.c (rest_of_compilation): Conditionally call purge_all_dead_edges\n\tafter combine.\n\t* gcse.c (cprop_cc0_jump, cprop_insn): New argument \"basic_block\".\n\t(cprop_jump): Likewise; call purge_dead_edges if substitution suceeded.\n\nFrom-SVN: r44267", "tree": {"sha": "3dbb57e04c149a6d0f4908ed9c0351fc46670790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dbb57e04c149a6d0f4908ed9c0351fc46670790"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0005550b5832aa6f0a3d7f343319c6b5b327dde8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0005550b5832aa6f0a3d7f343319c6b5b327dde8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0005550b5832aa6f0a3d7f343319c6b5b327dde8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0005550b5832aa6f0a3d7f343319c6b5b327dde8/comments", "author": null, "committer": null, "parents": [{"sha": "4edc91ae51a40b656c11d7dffbe74692be8d755e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4edc91ae51a40b656c11d7dffbe74692be8d755e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4edc91ae51a40b656c11d7dffbe74692be8d755e"}], "stats": {"total": 390, "additions": 247, "deletions": 143}, "files": [{"sha": "5de1093c0698bc5ed2ab79374e3b51ef86213794", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0005550b5832aa6f0a3d7f343319c6b5b327dde8", "patch": "@@ -1,3 +1,33 @@\n+Mon Jul 23 16:03:19 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (find_sub_basic_block): Declare.\n+\t* flow.c (make_edges): New arguments MIN and MAX;\n+\t(find_sub_basic_blocks): Revamp to use make_edges\n+\tand purge_dead_edges.\n+\t(find_basic_blocks): Update call of find_sub_basic_block.\n+\n+\t* recog.c (split_all_insns): Always expect CFG to be consistent;\n+\tcall find_sub_basic_blocks in case something has changed.\n+\t* toplev.c (rest_of_compilation): Always call split_all_insns once CFG\n+\thas been built.\n+\n+\t* basic-block.h (delete_noop_moves): Declare.\n+\t* combine.c (combine_instructions): Call it.\n+\t(recog_for_combine): Tolerate noop moves\n+\t(distribute_notes): Force refresh when register dies at noop move.\n+\t* flow.c (delete_noop_moves): Use BB structure; delete JUMP insns\n+\ttoo.\n+\t(life_analysis): Update delete_noop_moves call.\n+\t(set_noop_p): Move too ...\n+\t* rtlanal.c (noop_move_p): ... here.\n+\t* rtl.h (noop_move_p): Declare.\n+\n+\t* basic-block.h (purge_all_dead_edges, purge_dead_edges): New functions.\n+\t* toplev.c (rest_of_compilation): Conditionally call purge_all_dead_edges\n+\tafter combine.\n+\t* gcse.c (cprop_cc0_jump, cprop_insn): New argument \"basic_block\".\n+\t(cprop_jump): Likewise; call purge_dead_edges if substitution suceeded.\n+\n 2001-07-23  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* reload.c (push_reload): Fix typo in comment."}, {"sha": "b6e8c11a16be90ed01a5a13ca0840f3e2020900d", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=0005550b5832aa6f0a3d7f343319c6b5b327dde8", "patch": "@@ -597,10 +597,14 @@ extern void debug_regset\t\tPARAMS ((regset));\n extern void allocate_reg_life_data      PARAMS ((void));\n extern void allocate_bb_life_data\tPARAMS ((void));\n extern void find_unreachable_blocks\tPARAMS ((void));\n+extern void delete_noop_moves\t\tPARAMS ((rtx));\n extern basic_block redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n extern bool redirect_edge_and_branch\tPARAMS ((edge, basic_block));\n extern rtx block_label\t\t\tPARAMS ((basic_block));\n extern bool forwarder_block_p\t\tPARAMS ((basic_block));\n+extern void purge_all_dead_edges\tPARAMS ((void));\n+extern void purge_dead_edges\t\tPARAMS ((basic_block));\n+extern void find_sub_basic_blocks\tPARAMS ((basic_block));\n \n \n /* This function is always defined so it can be called from the"}, {"sha": "633d0acfd70036d508d219bc6e8a2d113ea45102", "filename": "gcc/combine.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0005550b5832aa6f0a3d7f343319c6b5b327dde8", "patch": "@@ -713,6 +713,8 @@ combine_instructions (f, nregs)\n \t}\n     }\n \n+  delete_noop_moves (f);\n+\n   if (need_refresh)\n     {\n       compute_bb_for_insn (get_max_uid ());\n@@ -9598,8 +9600,12 @@ recog_for_combine (pnewpat, insn, pnotes)\n   old_notes = REG_NOTES (insn);\n   REG_NOTES (insn) = 0;\n \n-  /* Is the result of combination a valid instruction?  */\n-  insn_code_number = recog (pat, insn, &num_clobbers_to_add);\n+  /* Is the result of combination a valid instruction?\n+     Recognize all noop sets, these will be killed by followup pass.  */\n+  if (GET_CODE (pat) == SET && set_noop_p (pat))\n+    insn_code_number = INT_MAX;\n+  else\n+    insn_code_number = recog (pat, insn, &num_clobbers_to_add);\n \n   /* If it isn't, there is the possibility that we previously had an insn\n      that clobbered some register as a side effect, but the combined\n@@ -9624,7 +9630,11 @@ recog_for_combine (pnewpat, insn, pnotes)\n       if (pos == 1)\n \tpat = XVECEXP (pat, 0, 0);\n \n-      insn_code_number = recog (pat, insn, &num_clobbers_to_add);\n+      /* Recognize all noop sets, these will be killed by followup pass.  */\n+      if (GET_CODE (pat) == SET && set_noop_p (pat))\n+\tinsn_code_number = INT_MAX;\n+      else\n+        insn_code_number = recog (pat, insn, &num_clobbers_to_add);\n     }\n \n   REG_NOTES (insn) = old_notes;\n@@ -12325,10 +12335,16 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t is still a REG_DEAD note, but we have hit the beginning\n \t\t of the block.  If the existing life info says the reg\n \t\t was dead, there's nothing left to do.  Otherwise, we'll\n-\t\t need to do a global life update after combine.  */\n-\t      if (REG_NOTE_KIND (note) == REG_DEAD && place == 0\n-\t\t  && REGNO_REG_SET_P (bb->global_live_at_start,\n-\t\t\t\t      REGNO (XEXP (note, 0))))\n+\t\t need to do a global life update after combine.  \n+\t       \n+\t\t Similary we need to update in case insn is an dead set\n+\t\t we are about to remove soon.\n+\t       */\n+\t      if (REG_NOTE_KIND (note) == REG_DEAD\n+\t\t  && ((place && noop_move_p (place))\n+\t\t      || (place == 0\n+\t\t\t  && REGNO_REG_SET_P (bb->global_live_at_start,\n+\t\t\t\t\t       REGNO (XEXP (note, 0))))))\n \t\t{\n \t\t  SET_BIT (refresh_blocks, this_basic_block);\n \t\t  need_refresh = 1;"}, {"sha": "ac5cee53eed7a08a35ea3c712dba238fa3f0f4f5", "filename": "gcc/flow.c", "status": "modified", "additions": 121, "deletions": 99, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=0005550b5832aa6f0a3d7f343319c6b5b327dde8", "patch": "@@ -374,7 +374,7 @@ static int flow_find_cross_jump\t\tPARAMS ((int, basic_block, basic_block,\n static int count_basic_blocks\t\tPARAMS ((rtx));\n static void find_basic_blocks_1\t\tPARAMS ((rtx));\n static rtx find_label_refs\t\tPARAMS ((rtx, rtx));\n-static void make_edges\t\t\tPARAMS ((rtx));\n+static void make_edges\t\t\tPARAMS ((rtx, int, int));\n static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n \t\t\t\t\t\t rtx, int));\n static void make_eh_edge\t\tPARAMS ((sbitmap *, basic_block, rtx));\n@@ -401,8 +401,6 @@ static void tidy_fallthru_edges\t\tPARAMS ((void));\n static int verify_wide_reg_1\t\tPARAMS ((rtx *, void *));\n static void verify_wide_reg\t\tPARAMS ((int, rtx, rtx));\n static void verify_local_live_at_start\tPARAMS ((regset, basic_block));\n-static int noop_move_p\t\t\tPARAMS ((rtx));\n-static void delete_noop_moves\t\tPARAMS ((rtx));\n static void notice_stack_pointer_modification_1 PARAMS ((rtx, rtx, void *));\n static void notice_stack_pointer_modification PARAMS ((rtx));\n static void mark_reg\t\t\tPARAMS ((rtx, void *));\n@@ -483,7 +481,6 @@ static void flow_loop_tree_node_add\tPARAMS ((struct loop *, struct loop *));\n static void flow_loops_tree_build\tPARAMS ((struct loops *));\n static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n-static void find_sub_basic_blocks\tPARAMS ((basic_block));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -543,7 +540,7 @@ find_basic_blocks (f, nregs, file)\n   compute_bb_for_insn (max_uid);\n \n   /* Discover the edges of our cfg.  */\n-  make_edges (label_value_list);\n+  make_edges (label_value_list, 0, n_basic_blocks - 1);\n \n   /* Do very simple cleanup now, for the benefit of code that runs between\n      here and cleanup_cfg, e.g. thread_prologue_and_epilogue_insns.  */\n@@ -705,39 +702,30 @@ find_label_refs (f, lvl)\n \n /* Assume that someone emitted code with control flow instructions to the\n    basic block.  Update the data structure.  */\n-static void\n+void\n find_sub_basic_blocks (bb)\n      basic_block bb;\n {\n-  rtx first_insn = bb->head, insn;\n+  rtx insn = bb->head;\n   rtx end = bb->end;\n-  edge succ_list = bb->succ;\n   rtx jump_insn = NULL_RTX;\n   int created = 0;\n   int barrier = 0;\n   edge falltru = 0;\n-  basic_block first_bb = bb, last_bb;\n-  int i;\n+  basic_block first_bb = bb;\n+\n+  if (insn == bb->end)\n+    return;\n \n-  if (GET_CODE (first_insn) == LABEL_REF)\n-    first_insn = NEXT_INSN (first_insn);\n-  first_insn = NEXT_INSN (first_insn);\n-  bb->succ = NULL;\n+  if (GET_CODE (insn) == CODE_LABEL)\n+    insn = NEXT_INSN (insn);\n \n-  insn = first_insn;\n   /* Scan insn chain and try to find new basic block boundaries.  */\n-  while (insn != end)\n+  while (1)\n     {\n       enum rtx_code code = GET_CODE (insn);\n       switch (code)\n \t{\n-\tcase JUMP_INSN:\n-\t  /* We need some special care for those expressions.  */\n-\t  if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n-\t    abort();\n-\t  jump_insn = insn;\n-\t  break;\n \tcase BARRIER:\n \t  if (!jump_insn)\n \t    abort ();\n@@ -749,58 +737,55 @@ find_sub_basic_blocks (bb)\n \t  if (jump_insn)\n \t    bb->end = jump_insn;\n \t  bb = falltru->dest;\n-\t  if (barrier)\n-\t    remove_edge (falltru);\n+\t  remove_edge (falltru);\n \t  barrier = 0;\n \t  jump_insn = 0;\n \t  created = 1;\n \t  if (LABEL_ALTERNATE_NAME (insn))\n \t    make_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);\n \t  break;\n \tcase INSN:\n+\tcase JUMP_INSN:\n \t  /* In case we've previously split insn on the JUMP_INSN, move the\n \t     block header to proper place.  */\n \t  if (jump_insn)\n \t    {\n \t      falltru = split_block (bb, PREV_INSN (insn));\n \t      bb->end = jump_insn;\n \t      bb = falltru->dest;\n-\t      if (barrier)\n-\t\tabort ();\n+\t      remove_edge (falltru);\n \t      jump_insn = 0;\n \t    }\n+\t  /* We need some special care for those expressions.  */\n+\t  if (GET_CODE (insn) == JUMP_INSN)\n+\t    {\n+\t      if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n+\t\tabort();\n+\t      jump_insn = insn;\n+\t    }\n+\t  break;\n \tdefault:\n \t  break;\n \t}\n+      if (insn == end)\n+\tbreak;\n       insn = NEXT_INSN (insn);\n     }\n-  /* Last basic block must end in the original BB end.  */\n-  if (jump_insn)\n-    abort ();\n \n-  /* Wire in the original edges for last basic block.  */\n-  if (created)\n-    {\n-      bb->succ = succ_list;\n-      while (succ_list)\n-\tsucc_list->src = bb, succ_list = succ_list->succ_next;\n-    }\n-  else\n-    bb->succ = succ_list;\n+  /* In case we've got barrier at the end of new insn stream, put it\n+     outside basic block.  */\n+  if (GET_CODE (bb->end) == BARRIER)\n+    bb->end = PREV_INSN (bb->end);\n+\n+  /* We've possibly replaced the conditional jump by conditional jump\n+     followed by cleanup at fallthru edge, so the outgoing edges may\n+     be dead.  */\n+  purge_dead_edges (bb);\n \n   /* Now re-scan and wire in all edges.  This expect simple (conditional)\n      jumps at the end of each new basic blocks.  */\n-  last_bb = bb;\n-  for (i = first_bb->index; i < last_bb->index; i++)\n-    {\n-      bb = BASIC_BLOCK (i);\n-      if (GET_CODE (bb->end) == JUMP_INSN)\n-\t{\n-\t  mark_jump_label (PATTERN (bb->end), bb->end, 0);\n-\t  make_label_edge (NULL, bb, JUMP_LABEL (bb->end), 0);\n-\t}\n-      insn = NEXT_INSN (insn);\n-    }\n+  make_edges (NULL, first_bb->index, bb->index - 1);\n }\n \n /* Find all basic blocks of the function whose first insn is F.\n@@ -1166,7 +1151,7 @@ clear_edges ()\n   n_edges = 0;\n }\n \n-/* Identify the edges between basic blocks.\n+/* Identify the edges between basic blocks MIN to MAX.\n \n    NONLOCAL_LABEL_LIST is a list of non-local labels in the function.  Blocks\n    that are otherwise unreachable may be reachable with a non-local goto.\n@@ -1175,8 +1160,9 @@ clear_edges ()\n    the list of exception regions active at the end of the basic block.  */\n \n static void\n-make_edges (label_value_list)\n+make_edges (label_value_list, min, max)\n      rtx label_value_list;\n+     int min, max;\n {\n   int i;\n   sbitmap *edge_cache = NULL;\n@@ -1196,7 +1182,7 @@ make_edges (label_value_list)\n   /* By nature of the way these get numbered, block 0 is always the entry.  */\n   make_edge (edge_cache, ENTRY_BLOCK_PTR, BASIC_BLOCK (0), EDGE_FALLTHRU);\n \n-  for (i = 0; i < n_basic_blocks; ++i)\n+  for (i = min; i <= max; ++i)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n       rtx insn, x;\n@@ -4317,58 +4303,28 @@ free_basic_block_vars (keep_head_end_p)\n     }\n }\n \n-/* Return nonzero if an insn consists only of SETs, each of which only sets a\n-   value to itself.  */\n-\n-static int\n-noop_move_p (insn)\n-     rtx insn;\n-{\n-  rtx pat = PATTERN (insn);\n-\n-  /* Insns carrying these notes are useful later on.  */\n-  if (find_reg_note (insn, REG_EQUAL, NULL_RTX))\n-    return 0;\n-\n-  if (GET_CODE (pat) == SET && set_noop_p (pat))\n-    return 1;\n-\n-  if (GET_CODE (pat) == PARALLEL)\n-    {\n-      int i;\n-      /* If nothing but SETs of registers to themselves,\n-\t this insn can also be deleted.  */\n-      for (i = 0; i < XVECLEN (pat, 0); i++)\n-\t{\n-\t  rtx tem = XVECEXP (pat, 0, i);\n-\n-\t  if (GET_CODE (tem) == USE\n-\t      || GET_CODE (tem) == CLOBBER)\n-\t    continue;\n-\n-\t  if (GET_CODE (tem) != SET || ! set_noop_p (tem))\n-\t    return 0;\n-\t}\n-\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n /* Delete any insns that copy a register to itself.  */\n \n-static void\n+void\n delete_noop_moves (f)\n-     rtx f;\n+     rtx f ATTRIBUTE_UNUSED;\n {\n-  rtx insn;\n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n+  int i;\n+  rtx insn, next;\n+  basic_block bb;\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n     {\n-      if (GET_CODE (insn) == INSN && noop_move_p (insn))\n+      bb = BASIC_BLOCK (i);\n+      for (insn = bb->head; insn != NEXT_INSN (bb->end); insn = next)\n \t{\n-\t  PUT_CODE (insn, NOTE);\n-\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t  next = NEXT_INSN (insn);\n+\t  if (INSN_P (insn) && noop_move_p (insn))\n+\t    {\n+\t      if (insn == bb->end)\n+\t\tbb->end = PREV_INSN (insn);\n+\t      flow_delete_insn (insn);\n+\t    }\n \t}\n     }\n }\n@@ -9814,3 +9770,69 @@ init_flow ()\n       flow_firstobj = (char *) obstack_alloc (&flow_obstack, 0);\n     }\n }\n+\n+/* Assume that the preceeding pass has possibly eliminated jump instructions\n+   or converted the unconditional jumps.  Eliminate the edges from CFG.  */\n+\n+void\n+purge_dead_edges (bb)\n+     basic_block bb;\n+{\n+  edge e, next;\n+  rtx insn = bb->end;\n+  if (GET_CODE (insn) == JUMP_INSN && !simplejump_p (insn))\n+    return;\n+  if (GET_CODE (insn) == JUMP_INSN)\n+    {\n+      for (e = bb->succ; e; e = next)\n+\t{\n+\t  next = e->succ_next;\n+\t  if (e->dest == EXIT_BLOCK_PTR || e->dest->head != JUMP_LABEL (insn))\n+\t    remove_edge (e);\n+\t}\n+      if (bb->succ && bb->succ->succ_next)\n+\tabort ();\n+      if (!bb->succ)\n+\treturn;\n+      bb->succ->probability = REG_BR_PROB_BASE;\n+      bb->succ->count = bb->count;\n+\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Purged edges from bb %i\\n\", bb->index);\n+      return;\n+    }\n+  /* If we don't see a jump insn, we don't know exactly why the block would\n+     have been broken at this point.  Look for a simple, non-fallthru edge,\n+     as these are only created by conditional branches.  If we find such an\n+     edge we know that there used to be a jump here and can then safely\n+     remove all non-fallthru edges.  */\n+  for (e = bb->succ; e && (e->flags & (EDGE_COMPLEX | EDGE_FALLTHRU));\n+       e = e->succ_next);\n+  if (!e)\n+    return;\n+  for (e = bb->succ; e; e = next)\n+    {\n+      next = e->succ_next;\n+      if (!(e->flags & EDGE_FALLTHRU))\n+\tremove_edge (e);\n+    }\n+  if (!bb->succ || bb->succ->succ_next)\n+    abort ();\n+  bb->succ->probability = REG_BR_PROB_BASE;\n+  bb->succ->count = bb->count;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Purged non-fallthru edges from bb %i\\n\",\n+\t     bb->index);\n+  return;\n+}\n+\n+/* Search all basic blocks for potentionally dead edges and purge them.  */\n+\n+void\n+purge_all_dead_edges ()\n+{\n+  int i;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    purge_dead_edges (BASIC_BLOCK (i));\n+}"}, {"sha": "7592204c11fbe2250e6ecb64269599f38284ddbc", "filename": "gcc/gcse.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=0005550b5832aa6f0a3d7f343319c6b5b327dde8", "patch": "@@ -605,14 +605,14 @@ static void compute_cprop_data\tPARAMS ((void));\n static void find_used_regs\tPARAMS ((rtx *, void *));\n static int try_replace_reg\tPARAMS ((rtx, rtx, rtx));\n static struct expr *find_avail_set PARAMS ((int, rtx));\n-static int cprop_jump\t\tPARAMS ((rtx, rtx, rtx));\n+static int cprop_jump\t\tPARAMS ((basic_block, rtx, rtx, rtx));\n #ifdef HAVE_cc0\n-static int cprop_cc0_jump\tPARAMS ((rtx, struct reg_use *, rtx));\n+static int cprop_cc0_jump\tPARAMS ((basic_block, rtx, struct reg_use *, rtx));\n #endif\n static void mems_conflict_for_gcse_p PARAMS ((rtx, rtx, void *));\n static int load_killed_in_block_p    PARAMS ((basic_block, int, rtx, int));\n static void canon_list_insert        PARAMS ((rtx, rtx, void *));\n-static int cprop_insn\t\tPARAMS ((rtx, int));\n+static int cprop_insn\t\tPARAMS ((basic_block, rtx, int));\n static int cprop\t\tPARAMS ((int));\n static int one_cprop_pass\tPARAMS ((int, int));\n static void alloc_pre_mem\tPARAMS ((int, int));\n@@ -4015,10 +4015,11 @@ find_avail_set (regno, insn)\n    nonzero if a change was made.  We know INSN has just a SET.  */\n \n static int\n-cprop_jump (insn, from, src)\n+cprop_jump (bb, insn, from, src)\n      rtx insn;\n      rtx from;\n      rtx src;\n+     basic_block bb;\n {\n   rtx set = PATTERN (insn);\n   rtx new = simplify_replace_rtx (SET_SRC (set), from, src);\n@@ -4059,6 +4060,7 @@ cprop_jump (insn, from, src)\n       print_rtl (gcse_file, src);\n       fprintf (gcse_file, \"\\n\");\n     }\n+  purge_dead_edges (bb);\n \n   return 1;\n }\n@@ -4072,7 +4074,8 @@ cprop_jump (insn, from, src)\n    Returns nonzero if a change was made.  */\n \n static int\n-cprop_cc0_jump (insn, reg_used, src)\n+cprop_cc0_jump (bb, insn, reg_used, src)\n+     basic_block bb;\n      rtx insn;\n      struct reg_use *reg_used;\n      rtx src;\n@@ -4083,7 +4086,7 @@ cprop_cc0_jump (insn, reg_used, src)\n   rtx new_src = simplify_replace_rtx (SET_SRC (PATTERN (insn)),\n \t\t\t\t      reg_used->reg_rtx, src);\n \n-  if (! cprop_jump (jump, cc0_rtx, new_src))\n+  if (! cprop_jump (bb, jump, cc0_rtx, new_src))\n     return 0;\n \n   /* If we succeeded, delete the cc0 setter.  */\n@@ -4099,7 +4102,8 @@ cprop_cc0_jump (insn, reg_used, src)\n    The result is non-zero if a change was made.  */\n \n static int\n-cprop_insn (insn, alter_jumps)\n+cprop_insn (bb, insn, alter_jumps)\n+     basic_block bb;\n      rtx insn;\n      int alter_jumps;\n {\n@@ -4183,7 +4187,7 @@ cprop_insn (insn, alter_jumps)\n \t\t   && GET_CODE (insn) == JUMP_INSN\n \t\t   && condjump_p (insn)\n \t\t   && ! simplejump_p (insn))\n-\t    changed |= cprop_jump (insn, reg_used->reg_rtx, src);\n+\t    changed |= cprop_jump (bb, insn, reg_used->reg_rtx, src);\n \n #ifdef HAVE_cc0\n \t  /* Similar code for machines that use a pair of CC0 setter and\n@@ -4252,7 +4256,7 @@ cprop (alter_jumps)\n \t   insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n \t  {\n-\t    changed |= cprop_insn (insn, alter_jumps);\n+\t    changed |= cprop_insn (BASIC_BLOCK (bb), insn, alter_jumps);\n \n \t    /* Keep track of everything modified by this insn.  */\n \t    /* ??? Need to be careful w.r.t. mods done to INSN.  Don't"}, {"sha": "b4b9b9d5bc2d827b8dab5498260bf0d413c7f983", "filename": "gcc/recog.c", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0005550b5832aa6f0a3d7f343319c6b5b327dde8", "patch": "@@ -2725,22 +2725,6 @@ split_all_insns (upd_life)\n   int changed;\n   int i;\n \n-  if (!upd_life)\n-    {\n-      rtx next, insn;\n-\n-      for (insn = get_insns (); insn ; insn = next)\n-\t{\n-\t  rtx last;\n-\n-\t  /* Can't use `next_real_insn' because that might go across\n-\t     CODE_LABELS and short-out basic blocks.  */\n-\t  next = NEXT_INSN (insn);\n-\t  last = split_insn (insn);\n-\t}\n-      return;\n-    }\n-\n   blocks = sbitmap_alloc (n_basic_blocks);\n   sbitmap_zero (blocks);\n   changed = 0;\n@@ -2775,12 +2759,21 @@ split_all_insns (upd_life)\n \tabort ();\n     }\n \n-  if (changed && upd_life)\n+  if (changed)\n     {\n       compute_bb_for_insn (get_max_uid ());\n+      for (i = 0; i < n_basic_blocks; i++)\n+\tfind_sub_basic_blocks (BASIC_BLOCK (i));\n+    }\n+\n+  if (changed && upd_life)\n+    {\n       count_or_remove_death_notes (blocks, 1);\n       update_life_info (blocks, UPDATE_LIFE_LOCAL, PROP_DEATH_NOTES);\n     }\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n \n   sbitmap_free (blocks);\n }"}, {"sha": "278e9d0697665fa0e0c2045dabcd94de7f5ae262", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0005550b5832aa6f0a3d7f343319c6b5b327dde8", "patch": "@@ -1387,6 +1387,7 @@ extern int reg_set_p\t\t\tPARAMS ((rtx, rtx));\n extern rtx single_set_2\t\t\tPARAMS ((rtx, rtx));\n extern int multiple_sets\t\tPARAMS ((rtx));\n extern int set_noop_p\t\t\tPARAMS ((rtx));\n+extern int noop_move_p\t\t\tPARAMS ((rtx));\n extern rtx find_last_value\t\tPARAMS ((rtx, rtx *, rtx, int));\n extern int refers_to_regno_p\t\tPARAMS ((unsigned int, unsigned int,\n \t\t\t\t\t\t rtx, rtx *));"}, {"sha": "c9152ab0f8e80af3a43fe988edd4208eebebf571", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=0005550b5832aa6f0a3d7f343319c6b5b327dde8", "patch": "@@ -1020,6 +1020,45 @@ set_noop_p (set)\n   return (GET_CODE (src) == REG && GET_CODE (dst) == REG\n \t  && REGNO (src) == REGNO (dst));\n }\n+\f\n+/* Return nonzero if an insn consists only of SETs, each of which only sets a\n+   value to itself.  */\n+\n+int\n+noop_move_p (insn)\n+     rtx insn;\n+{\n+  rtx pat = PATTERN (insn);\n+\n+  /* Insns carrying these notes are useful later on.  */\n+  if (find_reg_note (insn, REG_EQUAL, NULL_RTX))\n+    return 0;\n+\n+  if (GET_CODE (pat) == SET && set_noop_p (pat))\n+    return 1;\n+\n+  if (GET_CODE (pat) == PARALLEL)\n+    {\n+      int i;\n+      /* If nothing but SETs of registers to themselves,\n+\t this insn can also be deleted.  */\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t{\n+\t  rtx tem = XVECEXP (pat, 0, i);\n+\n+\t  if (GET_CODE (tem) == USE\n+\t      || GET_CODE (tem) == CLOBBER)\n+\t    continue;\n+\n+\t  if (GET_CODE (tem) != SET || ! set_noop_p (tem))\n+\t    return 0;\n+\t}\n+\n+      return 1;\n+    }\n+  return 0;\n+}\n+\f\n \n /* Return the last thing that X was assigned from before *PINSN.  If VALID_TO\n    is not NULL_RTX then verify that the object is not modified up to VALID_TO."}, {"sha": "613ef0da17a0fb0c4a26cdd3bb31062cf329bf93", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0005550b5832aa6f0a3d7f343319c6b5b327dde8/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0005550b5832aa6f0a3d7f343319c6b5b327dde8", "patch": "@@ -3265,7 +3265,7 @@ rest_of_compilation (decl)\n \t  timevar_pop (TV_JUMP);\n \n \t  timevar_push (TV_FLOW);\n-\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t  purge_all_dead_edges ();\n \t  cleanup_cfg (CLEANUP_EXPENSIVE);\n \n \t  /* Blimey.  We've got to have the CFG up to date for the call to\n@@ -3441,16 +3441,6 @@ rest_of_compilation (decl)\n       timevar_pop (TV_RELOAD_CSE_REGS);\n     }\n \n-  /* If optimizing, then go ahead and split insns now since we are about\n-     to recompute flow information anyway.  */\n-  if (optimize > 0)\n-    {\n-      int old_labelnum = max_label_num ();\n-\n-      split_all_insns (0);\n-      rebuild_label_notes_after_reload |= old_labelnum != max_label_num ();\n-    }\n-\n   /* Register allocation and reloading may have turned an indirect jump into\n      a direct jump.  If so, we must rebuild the JUMP_LABEL fields of\n      jumping instructions.  */\n@@ -3470,6 +3460,11 @@ rest_of_compilation (decl)\n   open_dump_file (DFI_flow2, decl);\n \n   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\n+  /* If optimizing, then go ahead and split insns now.  */\n+  if (optimize > 0)\n+    split_all_insns (0);\n+\n   cleanup_cfg (0);\n \n   /* On some machines, the prologue and epilogue code, or parts thereof,"}]}