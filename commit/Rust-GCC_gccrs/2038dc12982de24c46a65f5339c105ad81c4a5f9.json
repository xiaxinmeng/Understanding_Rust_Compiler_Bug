{"sha": "2038dc12982de24c46a65f5339c105ad81c4a5f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAzOGRjMTI5ODJkZTI0YzQ2YTY1ZjUzMzljMTA1YWQ4MWM0YTVmOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-08T19:40:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-08T19:40:45Z"}, "message": "Initial revision\n\nFrom-SVN: r11675", "tree": {"sha": "3f8200a951e4b4f00933a566dd82449412873323", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f8200a951e4b4f00933a566dd82449412873323"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2038dc12982de24c46a65f5339c105ad81c4a5f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2038dc12982de24c46a65f5339c105ad81c4a5f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2038dc12982de24c46a65f5339c105ad81c4a5f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2038dc12982de24c46a65f5339c105ad81c4a5f9/comments", "author": null, "committer": null, "parents": [{"sha": "cd4aafd57bca02af58e42a8a59bfd571780b28fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd4aafd57bca02af58e42a8a59bfd571780b28fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd4aafd57bca02af58e42a8a59bfd571780b28fc"}], "stats": {"total": 191, "additions": 191, "deletions": 0}, "files": [{"sha": "48ff1f5815424e80dd168b5861f4bdcc83186749", "filename": "gcc/config/i386/freebsd-elf.h", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2038dc12982de24c46a65f5339c105ad81c4a5f9/gcc%2Fconfig%2Fi386%2Ffreebsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2038dc12982de24c46a65f5339c105ad81c4a5f9/gcc%2Fconfig%2Fi386%2Ffreebsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ffreebsd-elf.h?ref=2038dc12982de24c46a65f5339c105ad81c4a5f9", "patch": "@@ -0,0 +1,191 @@\n+/* Definitions for Intel 386 running FreeBSD with ELF format\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Eric Youngdale.\n+   Modified for stabs-in-ELF by H.J. Lu.\n+   Adapted from Linux version by John Polstra.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (i386 FreeBSD/ELF)\");\n+\n+/* The svr4 ABI for the i386 says that records and unions are returned\n+   in memory.  */\n+#undef DEFAULT_PCC_STRUCT_RETURN\n+#define DEFAULT_PCC_STRUCT_RETURN 1\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   This is only used for PIC code.  See comments by the `casesi' insn in\n+   i386.md for an explanation of the expression this outputs. */\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+  fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n+\n+/* Indicate that jump tables go in the text section.  This is\n+   necessary when compiling PIC code.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION\n+\n+/* Copy this from the svr4 specifications... */\n+/* Define the register numbers to be used in Dwarf debugging information.\n+   The SVR4 reference port C compiler uses the following register numbers\n+   in its Dwarf output code:\n+\t0 for %eax (gnu regno = 0)\n+\t1 for %ecx (gnu regno = 2)\n+\t2 for %edx (gnu regno = 1)\n+\t3 for %ebx (gnu regno = 3)\n+\t4 for %esp (gnu regno = 7)\n+\t5 for %ebp (gnu regno = 6)\n+\t6 for %esi (gnu regno = 4)\n+\t7 for %edi (gnu regno = 5)\n+   The following three DWARF register numbers are never generated by\n+   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n+   believes these numbers have these meanings.\n+\t8  for %eip    (no gnu equivalent)\n+\t9  for %eflags (no gnu equivalent)\n+\t10 for %trapno (no gnu equivalent)\n+   It is not at all clear how we should number the FP stack registers\n+   for the x86 architecture.  If the version of SDB on x86/svr4 were\n+   a bit less brain dead with respect to floating-point then we would\n+   have a precedent to follow with respect to DWARF register numbers\n+   for x86 FP registers, but the SDB on x86/svr4 is so completely\n+   broken with respect to FP registers that it is hardly worth thinking\n+   of it as something to strive for compatibility with.\n+   The version of x86/svr4 SDB I have at the moment does (partially)\n+   seem to believe that DWARF register number 11 is associated with\n+   the x86 register %st(0), but that's about all.  Higher DWARF\n+   register numbers don't seem to be associated with anything in\n+   particular, and even for DWARF regno 11, SDB only seems to under-\n+   stand that it should say that a variable lives in %st(0) (when\n+   asked via an `=' command) if we said it was in DWARF regno 11,\n+   but SDB still prints garbage when asked for the value of the\n+   variable in question (via a `/' command).\n+   (Also note that the labels SDB prints for various FP stack regs\n+   when doing an `x' command are all wrong.)\n+   Note that these problems generally don't affect the native SVR4\n+   C compiler because it doesn't allow the use of -O with -g and\n+   because when it is *not* optimizing, it allocates a memory\n+   location for each floating-point variable, and the memory\n+   location is what gets described in the DWARF AT_location\n+   attribute for the variable in question.\n+   Regardless of the severe mental illness of the x86/svr4 SDB, we\n+   do something sensible here and we use the following DWARF\n+   register numbers.  Note that these are all stack-top-relative\n+   numbers.\n+\t11 for %st(0) (gnu regno = 8)\n+\t12 for %st(1) (gnu regno = 9)\n+\t13 for %st(2) (gnu regno = 10)\n+\t14 for %st(3) (gnu regno = 11)\n+\t15 for %st(4) (gnu regno = 12)\n+\t16 for %st(5) (gnu regno = 13)\n+\t17 for %st(6) (gnu regno = 14)\n+\t18 for %st(7) (gnu regno = 15)\n+*/\n+#undef DBX_REGISTER_NUMBER\n+#define DBX_REGISTER_NUMBER(n) \\\n+((n) == 0 ? 0 \\\n+ : (n) == 1 ? 2 \\\n+ : (n) == 2 ? 1 \\\n+ : (n) == 3 ? 3 \\\n+ : (n) == 4 ? 6 \\\n+ : (n) == 5 ? 7 \\\n+ : (n) == 6 ? 5 \\\n+ : (n) == 7 ? 4 \\\n+ : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \\\n+ : (-1))\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\t\\\n+\t       LPREFIX, (LABELNO));\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tcall *mcount@GOT(%%ebx)\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", LPREFIX, (LABELNO));\t\\\n+      fprintf (FILE, \"\\tcall mcount\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+ \n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+  \n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+   \n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+    \n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Dunix -Di386 -D__ELF__ -D__FreeBSD__=2 -Asystem(unix) -Asystem(FreeBSD) -Acpu(i386) -Amachine(i386)\"\n+\n+#undef CPP_SPEC\n+#if TARGET_CPU_DEFAULT == 2\n+#define CPP_SPEC \"%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{!m386:-D__i486__} %{posix:-D_POSIX_SOURCE}\"\n+#else\n+#define CPP_SPEC \"%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{m486:-D__i486__} %{posix:-D_POSIX_SOURCE}\"\n+#endif\n+\n+#undef\tLIB_SPEC\n+#if 1\n+/* We no longer link with libc_p.a or libg.a by default. If you\n+ * want to profile or debug the C library, please add\n+ * -lc_p or -ggdb to LDFLAGS at the link time, respectively.\n+ */\n+#define LIB_SPEC \\\n+  \"%{!shared: %{mieee-fp:-lieee} %{p:-lgmon} %{pg:-lgmon} \\\n+     %{!ggdb:-lc} %{ggdb:-lg}}\"\n+#else\n+#define LIB_SPEC \\\n+  \"%{!shared: \\\n+     %{mieee-fp:-lieee} %{p:-lgmon -lc_p} %{pg:-lgmon -lc_p} \\\n+       %{!p:%{!pg:%{!g*:-lc} %{g*:-lg}}}}\"\n+#endif\n+\n+/* Provide a LINK_SPEC appropriate for FreeBSD.  Here we provide support\n+   for the special GCC options -static and -shared, which allow us to\n+   link things in one of these three modes by applying the appropriate\n+   combinations of options at link-time. We like to support here for\n+   as many of the other GNU linker options as possible. But I don't\n+   have the time to search for those flags. I am sure how to add\n+   support for -soname shared_object_name. H.J.\n+\n+   I took out %{v:%{!V:-V}}. It is too much :-(. They can use\n+   -Wl,-V.\n+\n+   When the -shared link option is used a final link is not being\n+   done.  */\n+\n+#undef\tLINK_SPEC\n+#define LINK_SPEC \"-m elf_i386 %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!ibcs: \\\n+      %{!static: \\\n+\t%{rdynamic:-export-dynamic} \\\n+\t%{!dynamic-linker:-dynamic-linker /usr/libexec/ld-elf.so.1}} \\\n+\t%{static:-static}}}\"\n+\n+/* Get perform_* macros to build libgcc.a.  */"}]}