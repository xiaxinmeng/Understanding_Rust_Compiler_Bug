{"sha": "498ad738690b3c464f901d63dcd4d0f49a50dd00", "node_id": "C_kwDOANBUbNoAKDQ5OGFkNzM4NjkwYjNjNDY0ZjkwMWQ2M2RjZDRkMGY0OWE1MGRkMDA", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-10-10T03:31:48Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-10-11T09:22:38Z"}, "message": "Add define_insn_and_split to support general version of \"kxnor\".\n\nFor genereal_reg_operand, it will be splitted into xor + not.\nFor mask_reg_operand, it will be splitted with UNSPEC_MASK_OP just\nlike what we did for other logic operations.\n\nThe patch will optimize xor+not to kxnor when possible.\n\ngcc/ChangeLog:\n\n\tPR target/107093\n\t* config/i386/i386.md (*notxor<mode>_1): New post_reload\n\tdefine_insn_and_split.\n\t(*notxorqi_1): Ditto.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/pr107093.c: New test.", "tree": {"sha": "bd1dc1dc6a1d40408c55298ca28ddbc4a7638d90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd1dc1dc6a1d40408c55298ca28ddbc4a7638d90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/498ad738690b3c464f901d63dcd4d0f49a50dd00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498ad738690b3c464f901d63dcd4d0f49a50dd00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498ad738690b3c464f901d63dcd4d0f49a50dd00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498ad738690b3c464f901d63dcd4d0f49a50dd00/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4d15dddf6b9eacb36f535807ad2ee364af46e04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4d15dddf6b9eacb36f535807ad2ee364af46e04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4d15dddf6b9eacb36f535807ad2ee364af46e04"}], "stats": {"total": 109, "additions": 109, "deletions": 0}, "files": [{"sha": "9390dd5be88ef0c278c96b475ed994c2935b63b1", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498ad738690b3c464f901d63dcd4d0f49a50dd00/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498ad738690b3c464f901d63dcd4d0f49a50dd00/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=498ad738690b3c464f901d63dcd4d0f49a50dd00", "patch": "@@ -10826,6 +10826,39 @@\n    (set_attr \"type\" \"alu, alu, msklog\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn_and_split \"*notxor<mode>_1\"\n+  [(set (match_operand:SWI248 0 \"nonimmediate_operand\" \"=rm,r,?k\")\n+\t(not:SWI248\n+\t  (xor:SWI248\n+\t    (match_operand:SWI248 1 \"nonimmediate_operand\" \"%0,0,k\")\n+\t    (match_operand:SWI248 2 \"<general_operand>\" \"r<i>,<m>,k\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"ix86_binary_operator_ok (XOR, <MODE>mode, operands)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+    [(set (match_dup 0)\n+\t  (xor:SWI248 (match_dup 1) (match_dup 2)))\n+     (clobber (reg:CC FLAGS_REG))])\n+   (set (match_dup 0)\n+\t(not:SWI248 (match_dup 0)))]\n+{\n+  if (MASK_REGNO_P (REGNO (operands[0])))\n+    {\n+      emit_insn (gen_kxnor<mode> (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\n+  [(set (attr \"isa\")\n+\t(cond [(eq_attr \"alternative\" \"2\")\n+\t\t (if_then_else (eq_attr \"mode\" \"SI,DI\")\n+\t\t   (const_string \"avx512bw\")\n+\t\t   (const_string \"avx512f\"))\n+\t      ]\n+\t      (const_string \"*\")))\n+   (set_attr \"type\" \"alu, alu, msklog\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (define_insn_and_split \"*iordi_1_bts\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n \t(ior:DI\n@@ -10959,6 +10992,44 @@\n \t      (symbol_ref \"!TARGET_PARTIAL_REG_STALL\")]\n \t   (symbol_ref \"true\")))])\n \n+(define_insn_and_split \"*notxorqi_1\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,r,?k\")\n+\t(not:QI\n+\t  (xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0,k\")\n+\t\t  (match_operand:QI 2 \"general_operand\" \"qn,m,rn,k\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"ix86_binary_operator_ok (XOR, QImode, operands)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+    [(set (match_dup 0)\n+\t  (xor:QI (match_dup 1) (match_dup 2)))\n+     (clobber (reg:CC FLAGS_REG))])\n+   (set (match_dup 0)\n+\t(not:QI (match_dup 0)))]\n+{\n+  if (mask_reg_operand (operands[0], QImode))\n+    {\n+      emit_insn (gen_kxnorqi (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\n+  [(set_attr \"isa\" \"*,*,*,avx512f\")\n+   (set_attr \"type\" \"alu,alu,alu,msklog\")\n+   (set (attr \"mode\")\n+\t(cond [(eq_attr \"alternative\" \"2\")\n+\t\t (const_string \"SI\")\n+\t\t(and (eq_attr \"alternative\" \"3\")\n+\t\t     (match_test \"!TARGET_AVX512DQ\"))\n+\t\t (const_string \"HI\")\n+\t       ]\n+\t       (const_string \"QI\")))\n+   ;; Potential partial reg stall on alternative 2.\n+   (set (attr \"preferred_for_speed\")\n+     (cond [(eq_attr \"alternative\" \"2\")\n+\t      (symbol_ref \"!TARGET_PARTIAL_REG_STALL\")]\n+\t   (symbol_ref \"true\")))])\n+\n ;; Alternative 1 is needed to work around LRA limitation, see PR82524.\n (define_insn_and_split \"*<code><mode>_1_slp\"\n   [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>,&<r>\"))"}, {"sha": "23e30cbac0fadfd88fba42b39996247d8525e7ab", "filename": "gcc/testsuite/gcc.target/i386/pr107093.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498ad738690b3c464f901d63dcd4d0f49a50dd00/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107093.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498ad738690b3c464f901d63dcd4d0f49a50dd00/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107093.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107093.c?ref=498ad738690b3c464f901d63dcd4d0f49a50dd00", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512bw -O2 -mavx512vl\" } */\n+/* { dg-final { scan-assembler-times {(?n)kxnor[bwqd]} 4 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times {(?n)kxnor[bwdq]} 3 { target ia32 } } }  */\n+\n+#include<immintrin.h>\n+\n+__m512i\n+foo (__m512i a, __m512i b, __m512i c, __m512i d)\n+{\n+  __mmask32 k1 = _mm512_cmp_epi16_mask (a, b, 1);\n+  __mmask32 k2 = _mm512_cmp_epi16_mask (c, d, 2);\n+  return _mm512_mask_mov_epi16 (a, ~(k1 ^ k2), c);\n+}\n+\n+__m512i\n+foo1 (__m512i a, __m512i b, __m512i c, __m512i d)\n+{\n+  __mmask16 k1 = _mm512_cmp_epi32_mask (a, b, 1);\n+  __mmask16 k2 = _mm512_cmp_epi32_mask (c, d, 2);\n+  return _mm512_mask_mov_epi32 (a, ~(k1 ^ k2), c);\n+}\n+\n+__m512i\n+foo2 (__m512i a, __m512i b, __m512i c, __m512i d)\n+{\n+  __mmask64 k1 = _mm512_cmp_epi8_mask (a, b, 1);\n+  __mmask64 k2 = _mm512_cmp_epi8_mask (c, d, 2);\n+  return _mm512_mask_mov_epi8 (a, ~(k1 ^ k2), c);\n+}\n+\n+__m512i\n+foo3 (__m512i a, __m512i b, __m512i c, __m512i d)\n+{\n+  __mmask8 k1 = _mm512_cmp_epi64_mask (a, b, 1);\n+  __mmask8 k2 = _mm512_cmp_epi64_mask (c, d, 2);\n+  return _mm512_mask_mov_epi64 (a, ~(k1 ^ k2), c);\n+}"}]}