{"sha": "3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YyNmVkYWExOTY5YzllYzhiNzlmMmYxMjliMzdhOTFhOGIwYzdjMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-03-14T10:17:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-03-14T10:17:17Z"}, "message": "mips.h (FP_INC, [...]): New macros.\n\n\t* config/mips/mips.h (FP_INC, UNITS_PER_FPVALUE): New macros.\n\t* config/mips/mips.c (compute_frame_size): Retrofit them here.\n\t(save_restore_insns, mips_expand_epilogue): And here.\n\t(build_mips16_call_stub): And here.\n\t(mips_function_value): Use the new macros to decide whether a single\n\tor complex float can be returned in floating-point registers.  Return\n\ta parallel rtx in the complex case.\n\nFrom-SVN: r50766", "tree": {"sha": "c91ae40f49d86e8517cd6f1738c07fff20d7750d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c91ae40f49d86e8517cd6f1738c07fff20d7750d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0/comments", "author": null, "committer": null, "parents": [{"sha": "1e3881c2a0551c33bfdbe39463225d0ebf0d5e2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3881c2a0551c33bfdbe39463225d0ebf0d5e2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e3881c2a0551c33bfdbe39463225d0ebf0d5e2a"}], "stats": {"total": 104, "additions": 50, "deletions": 54}, "files": [{"sha": "84d0956f7e52f58cabd5df1c7d397f545f34da67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0", "patch": "@@ -1,3 +1,13 @@\n+2002-03-14  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.h (FP_INC, UNITS_PER_FPVALUE): New macros.\n+\t* config/mips/mips.c (compute_frame_size): Retrofit them here.\n+\t(save_restore_insns, mips_expand_epilogue): And here.\n+\t(build_mips16_call_stub): And here.\n+\t(mips_function_value): Use the new macros to decide whether a single\n+\tor complex float can be returned in floating-point registers.  Return\n+\ta parallel rtx in the complex case.\n+\n Thu Mar 14 11:03:12 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* toplev.c (rest_of_compilation): Add CLEANUP_UPDATE_LIFE to cfg_cleanup"}, {"sha": "773462fc7285e18383416984b04305c2304211bd", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 33, "deletions": 54, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0", "patch": "@@ -6362,6 +6362,7 @@ compute_frame_size (size)\n   long fmask;\t\t\t/* mask of saved fp registers */\n   int  fp_inc;\t\t\t/* 1 or 2 depending on the size of fp regs */\n   long fp_bits;\t\t\t/* bitmask to use for each fp register */\n+  tree return_type;\n \n   gp_reg_size = 0;\n   fp_reg_size = 0;\n@@ -6380,6 +6381,7 @@ compute_frame_size (size)\n     args_size = 4 * UNITS_PER_WORD;\n \n   total_size = var_size + args_size + extra_size;\n+  return_type = DECL_RESULT (current_function_decl);\n \n   /* Calculate space needed for gp registers.  */\n   for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n@@ -6398,12 +6400,9 @@ compute_frame_size (size)\n \t      && regno == GP_REG_FIRST + 31\n \t      && mips16_hard_float\n \t      && ! mips_entry\n-\t      && ! aggregate_value_p (DECL_RESULT (current_function_decl))\n-\t      && (GET_MODE_CLASS (DECL_MODE (DECL_RESULT (current_function_decl)))\n-\t\t  == MODE_FLOAT)\n-\t      && (! TARGET_SINGLE_FLOAT\n-\t\t  || (GET_MODE_SIZE (DECL_MODE (DECL_RESULT (current_function_decl)))\n-\t\t      <= 4))))\n+\t      && ! aggregate_value_p (return_type)\n+\t      && GET_MODE_CLASS (DECL_MODE (return_type)) == MODE_FLOAT\n+\t      && GET_MODE_SIZE (DECL_MODE (return_type)) <= UNITS_PER_FPVALUE))\n \t{\n \t  gp_reg_size += GET_MODE_SIZE (gpr_mode);\n \t  mask |= 1L << (regno - GP_REG_FIRST);\n@@ -6854,12 +6853,10 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n   /* Save floating point registers if needed.  */\n   if (fmask)\n     {\n-      int fp_inc = (TARGET_FLOAT64 || TARGET_SINGLE_FLOAT) ? 1 : 2;\n-      int fp_size = fp_inc * UNITS_PER_FPREG;\n-\n       /* Pick which pointer to use as a base register.  */\n       fp_offset = current_frame_info.fp_sp_offset;\n-      end_offset = fp_offset - (current_frame_info.fp_reg_size - fp_size);\n+      end_offset = fp_offset - (current_frame_info.fp_reg_size\n+\t\t\t\t- UNITS_PER_FPVALUE);\n \n       if (fp_offset < 0 || end_offset < 0)\n \tinternal_error\n@@ -6905,9 +6902,9 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \n       /* This loop must iterate over the same space as its companion in\n \t compute_frame_size.  */\n-      for (regno = (FP_REG_LAST - fp_inc + 1);\n+      for (regno = (FP_REG_LAST - FP_INC + 1);\n \t   regno >= FP_REG_FIRST;\n-\t   regno -= fp_inc)\n+\t   regno -= FP_INC)\n \tif (BITSET_P (fmask, regno - FP_REG_FIRST))\n \t  {\n \t    if (file == 0)\n@@ -6939,7 +6936,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\tfprintf (file, \"(%s)\\n\", reg_names[REGNO(base_reg_rtx)]);\n \t      }\n \n-\t    fp_offset -= fp_size;\n+\t    fp_offset -= UNITS_PER_FPVALUE;\n \t  }\n     }\n }\n@@ -7769,23 +7766,24 @@ mips_expand_epilogue ()\n int\n mips_can_use_return_insn ()\n {\n+  tree return_type;\n+\n   if (! reload_completed)\n     return 0;\n \n   if (regs_ever_live[31] || current_function_profile)\n     return 0;\n \n+  return_type = DECL_RESULT (current_function_decl);\n+\n   /* In mips16 mode, a function which returns a floating point value\n      needs to arrange to copy the return value into the floating point\n      registers.  */\n   if (TARGET_MIPS16\n       && mips16_hard_float\n-      && ! aggregate_value_p (DECL_RESULT (current_function_decl))\n-      && (GET_MODE_CLASS (DECL_MODE (DECL_RESULT (current_function_decl)))\n-\t  == MODE_FLOAT)\n-      && (! TARGET_SINGLE_FLOAT\n-\t  || (GET_MODE_SIZE (DECL_MODE (DECL_RESULT (current_function_decl)))\n-\t      <= 4)))\n+      && ! aggregate_value_p (return_type)\n+      && GET_MODE_CLASS (DECL_MODE (return_type)) == MODE_FLOAT\n+      && GET_MODE_SIZE (DECL_MODE (return_type)) <= UNITS_PER_FPVALUE)\n     return 0;\n \n   if (current_frame_info.initialized)\n@@ -7951,41 +7949,23 @@ mips_function_value (valtype, func)\n      just as PROMOTE_MODE does.  */\n   mode = promote_mode (valtype, mode, &unsignedp, 1);\n \n-  if (mclass == MODE_FLOAT)\n-    {\n-      if (TARGET_SINGLE_FLOAT\n-\t  && (mclass == MODE_FLOAT\n-\t      ? GET_MODE_SIZE (mode) > 4 : GET_MODE_SIZE (mode) / 2 > 4))\n-\treg = GP_RETURN;\n-      else\n-\treg = FP_RETURN;\n-    }\n+  if (mclass == MODE_FLOAT && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE)\n+    reg = FP_RETURN;\n \n-  else if (mclass == MODE_COMPLEX_FLOAT)\n+  else if (mclass == MODE_COMPLEX_FLOAT\n+\t   && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE * 2)\n     {\n-      if (TARGET_FLOAT64)\n-\treg = FP_RETURN;\n-      else if (mode == SCmode)\n-\t{\n-\t  /* When FP registers are 32 bits, we can't directly reference\n-\t     the odd numbered ones, so let's make a pair of evens.  */\n-\n-\t  enum machine_mode cmode = TYPE_MODE (TREE_TYPE (valtype));\n-\n-\t  return gen_rtx_PARALLEL\n-\t    (VOIDmode,\n-\t     gen_rtvec (2,\n-\t\t\tgen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t   gen_rtx_REG (cmode,\n-\t\t\t\t\t\t\tFP_RETURN),\n-\t\t\t\t\t   GEN_INT (0)),\n-\t\t\tgen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t   gen_rtx_REG (cmode,\n-\t\t\t\t\t\t\tFP_RETURN + 2),\n-\t\t\t\t\t   GEN_INT (4))));\n-\t}\n-      else\n-\treg = FP_RETURN;\n+      enum machine_mode cmode = TYPE_MODE (TREE_TYPE (valtype));\n+\n+      return gen_rtx_PARALLEL\n+\t(VOIDmode,\n+\t gen_rtvec (2,\n+\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t       gen_rtx_REG (cmode, FP_RETURN),\n+\t\t\t\t       GEN_INT (0)),\n+\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t       gen_rtx_REG (cmode, FP_RETURN + FP_INC),\n+\t\t\t\t       GEN_INT (GET_MODE_SIZE (cmode)))));\n     }\n \n   else if (TREE_CODE (valtype) == RECORD_TYPE\n@@ -8680,8 +8660,7 @@ build_mips16_call_stub (retval, fnmem, arg_size, fp_code)\n      register.  */\n   fpret = (retval != 0\n \t   && GET_MODE_CLASS (GET_MODE (retval)) == MODE_FLOAT\n-\t   && (! TARGET_SINGLE_FLOAT\n-\t       || GET_MODE_SIZE (GET_MODE (retval)) <= 4));\n+\t   && GET_MODE_SIZE (GET_MODE (retval)) <= UNITS_PER_FPVALUE);\n \n   /* We don't need to do anything if there were no floating point\n      arguments and the value will not be returned in a floating point"}, {"sha": "73d538379e919edc940e746087f62eceb3333a6a", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=3f26edaa1969c9ec8b79f2f129b37a91a8b0c7c0", "patch": "@@ -1591,6 +1591,13 @@ do {\t\t\t\t\t\t\t\\\n /* For MIPS, width of a floating point register.  */\n #define UNITS_PER_FPREG (TARGET_FLOAT64 ? 8 : 4)\n \n+/* If register $f0 holds a floating-point value, $f(0 + FP_INC) is\n+   the next available register.  */\n+#define FP_INC (TARGET_FLOAT64 || TARGET_SINGLE_FLOAT ? 1 : 2)\n+\n+/* The largest size of value that can be held in floating-point registers.  */\n+#define UNITS_PER_FPVALUE (FP_INC * UNITS_PER_FPREG)\n+\n /* A C expression for the size in bits of the type `int' on the\n    target machine.  If you don't define this, the default is one\n    word.  */"}]}