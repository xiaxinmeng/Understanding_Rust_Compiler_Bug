{"sha": "17938e578161d566577126aec74a852038899c43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc5MzhlNTc4MTYxZDU2NjU3NzEyNmFlYzc0YTg1MjAzODg5OWM0Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-26T20:11:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-26T20:11:24Z"}, "message": "(expand_expr, case IN_EXPR): Fix numerous small bugs and make some\ncleanups.\n\nFrom-SVN: r3541", "tree": {"sha": "78d661b2707dd6d1158d84a4f247a876e5c50095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78d661b2707dd6d1158d84a4f247a876e5c50095"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17938e578161d566577126aec74a852038899c43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17938e578161d566577126aec74a852038899c43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17938e578161d566577126aec74a852038899c43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17938e578161d566577126aec74a852038899c43/comments", "author": null, "committer": null, "parents": [{"sha": "cabeca29785da14dd9eb13a529b5d53364769037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cabeca29785da14dd9eb13a529b5d53364769037", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cabeca29785da14dd9eb13a529b5d53364769037"}], "stats": {"total": 57, "additions": 29, "deletions": 28}, "files": [{"sha": "c2abbcb06746cd5690d9d76fe76483869c1487ad", "filename": "gcc/expr.c", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17938e578161d566577126aec74a852038899c43/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17938e578161d566577126aec74a852038899c43/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=17938e578161d566577126aec74a852038899c43", "patch": "@@ -4483,7 +4483,7 @@ expand_expr (exp, target, tmode, modifier)\n \tenum machine_mode index_mode = TYPE_MODE (TREE_TYPE (index));\n \n \tif (target == 0)\n-\t  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n+\t  target = gen_reg_rtx (mode);\n \n \t/* If domain is empty, answer is no.  */\n \tif (tree_int_cst_lt (set_high_bound, set_low_bound))\n@@ -4497,18 +4497,14 @@ expand_expr (exp, target, tmode, modifier)\n \n \t/* Compare index against bounds, if they are constant.  */\n \tif (GET_CODE (index_val) == CONST_INT\n-\t    && GET_CODE (lo_r) == CONST_INT)\n-\t  {\n-\t    if (INTVAL (index_val) < INTVAL (lo_r))\n-\t      return const0_rtx;\n-\t  }\n+\t    && GET_CODE (lo_r) == CONST_INT\n+\t    && INTVAL (index_val) < INTVAL (lo_r))\n+\t  return const0_rtx;\n \n \tif (GET_CODE (index_val) == CONST_INT\n-\t    && GET_CODE (hi_r) == CONST_INT)\n-\t  {\n-\t    if (INTVAL (hi_r) < INTVAL (index_val))\n-\t      return const0_rtx;\n-\t  }\n+\t    && GET_CODE (hi_r) == CONST_INT\n+\t    && INTVAL (hi_r) < INTVAL (index_val))\n+\t  return const0_rtx;\n \n \t/* If we get here, we have to generate the code for both cases\n \t   (in range and out of range).  */\n@@ -4519,46 +4515,51 @@ expand_expr (exp, target, tmode, modifier)\n \tif (! (GET_CODE (index_val) == CONST_INT\n \t       && GET_CODE (lo_r) == CONST_INT))\n \t  {\n-\t    emit_cmp_insn (index_val, lo_r, LT, 0, GET_MODE (index_val), 0, 0);\n+\t    emit_cmp_insn (index_val, lo_r, LT, NULL_RTX,\n+\t\t\t   GET_MODE (index_val), 0, 0);\n \t    emit_jump_insn (gen_blt (op1));\n \t  }\n \n \tif (! (GET_CODE (index_val) == CONST_INT\n \t       && GET_CODE (hi_r) == CONST_INT))\n \t  {\n-\t    emit_cmp_insn (index_val, hi_r, GT, 0, GET_MODE (index_val), 0, 0);\n+\t    emit_cmp_insn (index_val, hi_r, GT, NULL_RTX,\n+\t\t\t   GET_MODE (index_val), 0, 0);\n \t    emit_jump_insn (gen_bgt (op1));\n \t  }\n \n \t/* Calculate the element number of bit zero in the first word\n \t   of the set.  */\n \tif (GET_CODE (lo_r) == CONST_INT)\n-\t  rlow = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t  INTVAL (lo_r) & ~ (1 << BITS_PER_UNIT));\n+\t  rlow = GEN_INT (INTVAL (lo_r)\n+\t\t\t  & ~ ((HOST_WIDE_INT) 1 << BITS_PER_UNIT));\n \telse\n-\t  rlow = expand_binop (index_mode, and_optab,\n-\t\t\t       lo_r, gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t      ~ (1 << BITS_PER_UNIT)),\n-\t\t\t       0, 0, OPTAB_LIB_WIDEN);\n+\t  rlow = expand_binop (index_mode, and_optab, lo_r,\n+\t\t\t       GEN_INT (~((HOST_WIDE_INT) 1 << BITS_PER_UNIT)),\n+\t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \n \tdiff = expand_binop (index_mode, sub_optab,\n-\t\t\t     index_val, rlow, 0, 0, OPTAB_LIB_WIDEN);\n+\t\t\t     index_val, rlow, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \n \tquo = expand_divmod (0, TRUNC_DIV_EXPR, index_mode, diff,\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode, BITS_PER_UNIT),\n-\t\t\t     0, 0);\n+\t\t\t     GEN_INT (BITS_PER_UNIT), NULL_RTX, 0);\n \trem = expand_divmod (1, TRUNC_MOD_EXPR, index_mode, index_val,\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode, BITS_PER_UNIT),\n-\t\t\t     0, 0);\n+\t\t\t     GEN_INT (BITS_PER_UNIT), NULL_RTX, 0);\n \taddr = memory_address (byte_mode,\n \t\t\t       expand_binop (index_mode, add_optab,\n-\t\t\t\t\t     diff, setaddr));\n+\t\t\t\t\t     diff, setaddr, NULL_RTX, 0,\n+\t\t\t\t\t     OPTAB_LIB_WIDEN));\n \t/* Extract the bit we want to examine */\n \tbit = expand_shift (RSHIFT_EXPR, byte_mode,\n-\t\t\t    gen_rtx (MEM, byte_mode, addr), rem, 0, 1);\n-\tresult = expand_binop (SImode, and_optab, bit, const1_rtx, target,\n+\t\t\t    gen_rtx (MEM, byte_mode, addr),\n+\t\t\t    make_tree (TREE_TYPE (index), rem),\n+\t\t\t    NULL_RTX, 1);\n+\tresult = expand_binop (byte_mode, and_optab, bit, const1_rtx,\n+\t\t\t       GET_MODE (target) == byte_mode ? target : 0,\n \t\t\t       1, OPTAB_LIB_WIDEN);\n-\temit_move_insn (target, result);\n+\n+\tif (result != target)\n+\t  convert_move (target, result, 1);\n \n \t/* Output the code to handle the out-of-range case.  */\n \temit_jump (op0);"}]}