{"sha": "d780e54fa036407bc057a43f2ebf7d945b80add0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc4MGU1NGZhMDM2NDA3YmMwNTdhNDNmMmViZjdkOTQ1YjgwYWRkMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T12:46:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T12:46:16Z"}, "message": "[multiple changes]\n\n2014-07-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* freeze.adb (Freeze_Record_Type): Replace all calls to\n\tIs_SPARK_Volatile with Is_Effectively_Volatile and update\n\trelated comments.\n\t* sem_ch3.adb (Analyze_Object_Contract, Process_Discriminants):\n\tReplace all calls to Is_SPARK_Volatile with\n\tIs_Effectively_Volatile and update related comments.\n\t* sem_ch5.adb (Analyze_Iterator_Specification,\n\tAnalyze_Loop_Parameter_Specification): Replace all calls to\n\tIs_SPARK_Volatile with Is_Effectively_Volatile and update\n\trelated comments.\n\t* sem_ch6.adb (Process_Formals): Replace all calls to\n\tIs_SPARK_Volatile with Is_Effectively_Volatile and update\n\trelated comments.\n\t* sem_ch12.adb (Instantiate_Object): Replace the call to\n\tIs_SPARK_Volatile_Object with Is_Effectively_Volatile_Object\n\tand update related comment.\n\t* sem_prag.adb (Analyze_External_Property_In_Decl_Part,\n\tAnalyze_Global_Item): Replace all calls to Is_SPARK_Volatile\n\twith Is_Effectively_Volatile and update related comments.\n\t* sem_res.adb (Resolve_Actuals, Resolve_Entity_Name): Replace\n\tall calls to Is_SPARK_Volatile with Is_Effectively_Volatile and\n\tupdate related comments.\n\t* sem_util.adb (Has_Enabled_Property,\n\tVariable_Has_Enabled_Property): Replace all calls\n\tto Is_SPARK_Volatile with Is_Effectively_Volatile and\n\tupdate related comments.\n\t(Is_Effectively_Volatile): New routine.\n\t(Is_Effectively_Volatile_Object): New routine.\n\t(Is_SPARK_Volatile): Removed.\n\t(Is_SPARK_Volatile_Object): Removed.\n\t* sem_util.ads (Is_Effectively_Volatile): New routine.\n\t(Is_Effectively_Volatile_Object): New routine.\n\t(Is_SPARK_Volatile): Removed.\n\t(Is_SPARK_Volatile_Object): Removed.\n\n2014-07-31  Pascal Obry  <obry@adacore.com>\n\n\t* s-fileio.adb (Open): Make sure a shared file gets inserted into\n\tthe global list atomically. This ensures that the file descriptor\n\twon't be freed because another tasks is closing the file.\n\nFrom-SVN: r213352", "tree": {"sha": "840e6150c70a5d4987c45efe13a41caf7c171cdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/840e6150c70a5d4987c45efe13a41caf7c171cdc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d780e54fa036407bc057a43f2ebf7d945b80add0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d780e54fa036407bc057a43f2ebf7d945b80add0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d780e54fa036407bc057a43f2ebf7d945b80add0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d780e54fa036407bc057a43f2ebf7d945b80add0/comments", "author": null, "committer": null, "parents": [{"sha": "16b5e0b7c5ddfe3d8722b1ffcfa6d66047f8228f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b5e0b7c5ddfe3d8722b1ffcfa6d66047f8228f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16b5e0b7c5ddfe3d8722b1ffcfa6d66047f8228f"}], "stats": {"total": 408, "additions": 248, "deletions": 160}, "files": [{"sha": "d8fdf61209549d2f9e935d2d0b6cc47402a6f863", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d780e54fa036407bc057a43f2ebf7d945b80add0", "patch": "@@ -1,3 +1,46 @@\n+2014-07-31  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* freeze.adb (Freeze_Record_Type): Replace all calls to\n+\tIs_SPARK_Volatile with Is_Effectively_Volatile and update\n+\trelated comments.\n+\t* sem_ch3.adb (Analyze_Object_Contract, Process_Discriminants):\n+\tReplace all calls to Is_SPARK_Volatile with\n+\tIs_Effectively_Volatile and update related comments.\n+\t* sem_ch5.adb (Analyze_Iterator_Specification,\n+\tAnalyze_Loop_Parameter_Specification): Replace all calls to\n+\tIs_SPARK_Volatile with Is_Effectively_Volatile and update\n+\trelated comments.\n+\t* sem_ch6.adb (Process_Formals): Replace all calls to\n+\tIs_SPARK_Volatile with Is_Effectively_Volatile and update\n+\trelated comments.\n+\t* sem_ch12.adb (Instantiate_Object): Replace the call to\n+\tIs_SPARK_Volatile_Object with Is_Effectively_Volatile_Object\n+\tand update related comment.\n+\t* sem_prag.adb (Analyze_External_Property_In_Decl_Part,\n+\tAnalyze_Global_Item): Replace all calls to Is_SPARK_Volatile\n+\twith Is_Effectively_Volatile and update related comments.\n+\t* sem_res.adb (Resolve_Actuals, Resolve_Entity_Name): Replace\n+\tall calls to Is_SPARK_Volatile with Is_Effectively_Volatile and\n+\tupdate related comments.\n+\t* sem_util.adb (Has_Enabled_Property,\n+\tVariable_Has_Enabled_Property): Replace all calls\n+\tto Is_SPARK_Volatile with Is_Effectively_Volatile and\n+\tupdate related comments.\n+\t(Is_Effectively_Volatile): New routine.\n+\t(Is_Effectively_Volatile_Object): New routine.\n+\t(Is_SPARK_Volatile): Removed.\n+\t(Is_SPARK_Volatile_Object): Removed.\n+\t* sem_util.ads (Is_Effectively_Volatile): New routine.\n+\t(Is_Effectively_Volatile_Object): New routine.\n+\t(Is_SPARK_Volatile): Removed.\n+\t(Is_SPARK_Volatile_Object): Removed.\n+\n+2014-07-31  Pascal Obry  <obry@adacore.com>\n+\n+\t* s-fileio.adb (Open): Make sure a shared file gets inserted into\n+\tthe global list atomically. This ensures that the file descriptor\n+\twon't be freed because another tasks is closing the file.\n+\n 2014-07-31  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb (Process_Range_Expr_In_Decl): Add comments on"}, {"sha": "5b82ae4a946ab30e53d5211ebc27fa95ba2e8e94", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=d780e54fa036407bc057a43f2ebf7d945b80add0", "patch": "@@ -3472,27 +3472,29 @@ package body Freeze is\n          --  they are not standard Ada legality rules.\n \n          if SPARK_Mode = On then\n-            if Is_SPARK_Volatile (Rec) then\n+            if Is_Effectively_Volatile (Rec) then\n \n-               --  A discriminated type cannot be volatile (SPARK RM C.6(4))\n+               --  A discriminated type cannot be effectively volatile\n+               --  (SPARK RM C.6(4)).\n \n                if Has_Discriminants (Rec) then\n                   Error_Msg_N (\"discriminated type & cannot be volatile\", Rec);\n \n-               --  A tagged type cannot be volatile (SPARK RM C.6(5))\n+               --  A tagged type cannot be effectively volatile\n+               --  (SPARK RM C.6(5)).\n \n                elsif Is_Tagged_Type (Rec) then\n                   Error_Msg_N (\"tagged type & cannot be volatile\", Rec);\n                end if;\n \n-            --  A non-volatile record type cannot contain volatile components\n-            --  (SPARK RM C.6(2))\n+            --  A non-effectively volatile record type cannot contain\n+            --  effectively volatile components (SPARK RM C.6(2)).\n \n             else\n                Comp := First_Component (Rec);\n                while Present (Comp) loop\n                   if Comes_From_Source (Comp)\n-                    and then Is_SPARK_Volatile (Etype (Comp))\n+                    and then Is_Effectively_Volatile (Etype (Comp))\n                   then\n                      Error_Msg_Name_1 := Chars (Rec);\n                      Error_Msg_N"}, {"sha": "126427942f2199dc99278aa08943166217ca1fd0", "filename": "gcc/ada/s-fileio.adb", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fs-fileio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fs-fileio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fileio.adb?ref=d780e54fa036407bc057a43f2ebf7d945b80add0", "patch": "@@ -933,6 +933,11 @@ package body System.File_IO is\n       pragma Import (C, Get_Case_Sensitive,\n                      \"__gnat_get_file_names_case_sensitive\");\n \n+      procedure Record_AFCB;\n+      --  Create and record new AFCB into the runtime, note that the\n+      --  implementation uses the variables below which corresponds to the\n+      --  status of the opened file.\n+\n       File_Names_Case_Sensitive : constant Boolean := Get_Case_Sensitive /= 0;\n       --  Set to indicate whether the operating system convention is for file\n       --  names to be case sensitive (e.g., in Unix, set True), or not case\n@@ -975,6 +980,33 @@ package body System.File_IO is\n       Encoding : CRTL.Filename_Encoding;\n       --  Filename encoding specified into the form parameter\n \n+      ------------------\n+      --  Record_AFCB --\n+      ------------------\n+\n+      procedure Record_AFCB is\n+      begin\n+         File_Ptr := AFCB_Allocate (Dummy_FCB);\n+\n+         File_Ptr.Is_Regular_File   :=\n+           (is_regular_file (fileno (Stream)) /= 0);\n+         File_Ptr.Is_System_File    := False;\n+         File_Ptr.Text_Encoding     := Text_Encoding;\n+         File_Ptr.Shared_Status     := Shared;\n+         File_Ptr.Access_Method     := Amethod;\n+         File_Ptr.Stream            := Stream;\n+         File_Ptr.Form              :=\n+           new String'(Formstr);\n+         File_Ptr.Name              :=\n+           new String'(Fullname (1 .. Full_Name_Len));\n+         File_Ptr.Mode              := Mode;\n+         File_Ptr.Is_Temporary_File := Tempfile;\n+         File_Ptr.Encoding          := Encoding;\n+\n+         Chain_File (File_Ptr);\n+         Append_Set (File_Ptr);\n+      end Record_AFCB;\n+\n    begin\n       if File_Ptr /= null then\n          raise Status_Error with \"file already open\";\n@@ -1156,17 +1188,6 @@ package body System.File_IO is\n             To_Lower (Fullname (1 .. Full_Name_Len));\n          end if;\n \n-         --  We need to lock all tasks from this point. This is needed as in\n-         --  the case of a shared file we want to ensure that the file is\n-         --  inserted into the chain with the shared status. We must be sure\n-         --  that this file won't be closed (and then the runtime file\n-         --  descriptor removed from the chain and released) before we leave\n-         --  this routine.\n-\n-         --  Take a task lock to protect Open_Files\n-\n-         SSL.Lock_Task.all;\n-\n          --  If Shared=None or Shared=Yes, then check for the existence of\n          --  another file with exactly the same full name.\n \n@@ -1175,6 +1196,10 @@ package body System.File_IO is\n                P : AFCB_Ptr;\n \n             begin\n+               --  Take a task lock to protect Open_Files\n+\n+               SSL.Lock_Task.all;\n+\n                --  Search list of open files\n \n                P := Open_Files;\n@@ -1198,6 +1223,9 @@ package body System.File_IO is\n                        and then P.Shared_Status = Yes\n                      then\n                         Stream := P.Stream;\n+\n+                        Record_AFCB;\n+\n                         exit;\n \n                      --  Otherwise one of the files has Shared=Yes and one has\n@@ -1214,12 +1242,23 @@ package body System.File_IO is\n \n                   P := P.Next;\n                end loop;\n+\n+               SSL.Unlock_Task.all;\n+\n+            exception\n+               when others =>\n+                  SSL.Unlock_Task.all;\n+                  raise;\n             end;\n          end if;\n \n-         --  Open specified file if we did not find an existing stream\n+         --  Open specified file if we did not find an existing stream,\n+         --  otherwise we just return as there is nothing more to be done.\n+\n+         if Stream /= NULL_Stream then\n+            return;\n \n-         if Stream = NULL_Stream then\n+         else\n             Fopen_Mode\n               (Mode, Text_Encoding in Text_Content_Encoding,\n                Creat, Amethod, Fopstr);\n@@ -1292,32 +1331,7 @@ package body System.File_IO is\n       --  committed to completing the opening of the file. Allocate block on\n       --  heap and fill in its fields.\n \n-      File_Ptr := AFCB_Allocate (Dummy_FCB);\n-\n-      File_Ptr.Is_Regular_File   := (is_regular_file (fileno (Stream)) /= 0);\n-      File_Ptr.Is_System_File    := False;\n-      File_Ptr.Text_Encoding     := Text_Encoding;\n-      File_Ptr.Shared_Status     := Shared;\n-      File_Ptr.Access_Method     := Amethod;\n-      File_Ptr.Stream            := Stream;\n-      File_Ptr.Form              := new String'(Formstr);\n-      File_Ptr.Name              := new String'(Fullname (1 .. Full_Name_Len));\n-      File_Ptr.Mode              := Mode;\n-      File_Ptr.Is_Temporary_File := Tempfile;\n-      File_Ptr.Encoding          := Encoding;\n-\n-      Chain_File (File_Ptr);\n-      Append_Set (File_Ptr);\n-\n-      --  We can now safely release the global lock, as the File_Ptr is\n-      --  inserted into the global file list.\n-\n-      SSL.Unlock_Task.all;\n-\n-   exception\n-      when others =>\n-         SSL.Unlock_Task.all;\n-         raise;\n+      Record_AFCB;\n    end Open;\n \n    ------------------------"}, {"sha": "ccdd2b7b7bcc1e75f811586b429f02032ba1c7a5", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=d780e54fa036407bc057a43f2ebf7d945b80add0", "patch": "@@ -9905,13 +9905,13 @@ package body Sem_Ch12 is\n            (\"actual must exclude null to match generic formal#\", Actual);\n       end if;\n \n-      --  A volatile object cannot be used as an actual in a generic instance.\n-      --  The following check is only relevant when SPARK_Mode is on as it is\n-      --  not a standard Ada legality rule.\n+      --  An effectively volatile object cannot be used as an actual in\n+      --  a generic instance. The following check is only relevant when\n+      --  SPARK_Mode is on as it is not a standard Ada legality rule.\n \n       if SPARK_Mode = On\n         and then Present (Actual)\n-        and then Is_SPARK_Volatile_Object (Actual)\n+        and then Is_Effectively_Volatile_Object (Actual)\n       then\n          Error_Msg_N\n            (\"volatile object cannot act as actual in generic instantiation \""}, {"sha": "ff3f1ecb464060245ef532cd22c81a431077b208", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d780e54fa036407bc057a43f2ebf7d945b80add0", "patch": "@@ -3018,13 +3018,13 @@ package body Sem_Ch3 is\n    begin\n       if Ekind (Obj_Id) = E_Constant then\n \n-         --  A constant cannot be volatile. This check is only relevant when\n-         --  SPARK_Mode is on as it is not standard Ada legality rule. Do not\n-         --  flag internally-generated constants that map generic formals to\n-         --  actuals in instantiations (SPARK RM 7.1.3(6)).\n+         --  A constant cannot be effectively volatile. This check is only\n+         --  relevant with SPARK_Mode on as it is not a standard Ada legality\n+         --  rule. Do not flag internally-generated constants that map generic\n+         --  formals to actuals in instantiations (SPARK RM 7.1.3(6)).\n \n          if SPARK_Mode = On\n-           and then Is_SPARK_Volatile (Obj_Id)\n+           and then Is_Effectively_Volatile (Obj_Id)\n            and then No (Corresponding_Generic_Association (Parent (Obj_Id)))\n          then\n             Error_Msg_N (\"constant cannot be volatile\", Obj_Id);\n@@ -3036,37 +3036,37 @@ package body Sem_Ch3 is\n          --  they are not standard Ada legality rules.\n \n          if SPARK_Mode = On then\n-            if Is_SPARK_Volatile (Obj_Id) then\n+            if Is_Effectively_Volatile (Obj_Id) then\n \n-               --  The declaration of a volatile object must appear at the\n-               --  library level (SPARK RM 7.1.3(7), C.6(6)).\n+               --  The declaration of an effectively volatile object must\n+               --  appear at the library level (SPARK RM 7.1.3(7), C.6(6)).\n \n                if not Is_Library_Level_Entity (Obj_Id) then\n                   Error_Msg_N\n                     (\"volatile variable & must be declared at library level\",\n                      Obj_Id);\n \n-               --  An object of a discriminated type cannot be volatile\n-               --  (SPARK RM C.6(4)).\n+               --  An object of a discriminated type cannot be effectively\n+               --  volatile (SPARK RM C.6(4)).\n \n                elsif Has_Discriminants (Obj_Typ) then\n                   Error_Msg_N\n                     (\"discriminated object & cannot be volatile\", Obj_Id);\n \n-               --  An object of a tagged type cannot be volatile\n+               --  An object of a tagged type cannot be effectively volatile\n                --  (SPARK RM C.6(5)).\n \n                elsif Is_Tagged_Type (Obj_Typ) then\n                   Error_Msg_N (\"tagged object & cannot be volatile\", Obj_Id);\n                end if;\n \n-            --  The object is not volatile\n+            --  The object is not effectively volatile\n \n             else\n-               --  A non-volatile object cannot have volatile components\n-               --  (SPARK RM 7.1.3(7)).\n+               --  A non-effectively volatile object cannot have effectively\n+               --  volatile components (SPARK RM 7.1.3(7)).\n \n-               if not Is_SPARK_Volatile (Obj_Id)\n+               if not Is_Effectively_Volatile (Obj_Id)\n                  and then Has_Volatile_Component (Obj_Typ)\n                then\n                   Error_Msg_N\n@@ -18123,12 +18123,12 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n-         --  A discriminant cannot be volatile. This check is only relevant\n-         --  when SPARK_Mode is on as it is not standard Ada legality rule\n-         --  (SPARK RM 7.1.3(6)).\n+         --  A discriminant cannot be effectively volatile. This check is only\n+         --  relevant when SPARK_Mode is on as it is not standard Ada legality\n+         --  rule (SPARK RM 7.1.3(6)).\n \n          if SPARK_Mode = On\n-           and then Is_SPARK_Volatile (Defining_Identifier (Discr))\n+           and then Is_Effectively_Volatile (Defining_Identifier (Discr))\n          then\n             Error_Msg_N (\"discriminant cannot be volatile\", Discr);\n          end if;"}, {"sha": "9106aa22c8bfa7f58d6f5c777130d000dea3612b", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=d780e54fa036407bc057a43f2ebf7d945b80add0", "patch": "@@ -2007,16 +2007,16 @@ package body Sem_Ch5 is\n          end if;\n       end if;\n \n-      --  A loop parameter cannot be volatile. This check is peformed only\n-      --  when SPARK_Mode is on as it is not a standard Ada legality check\n-      --  (SPARK RM 7.1.3(6)).\n+      --  A loop parameter cannot be effectively volatile. This check is\n+      --  peformed only when SPARK_Mode is on as it is not a standard Ada\n+      --  legality check (SPARK RM 7.1.3(6)).\n \n       --  Not clear whether this applies to element iterators, where the\n       --  cursor is not an explicit entity ???\n \n       if SPARK_Mode = On\n         and then not Of_Present (N)\n-        and then Is_SPARK_Volatile (Ent)\n+        and then Is_Effectively_Volatile (Ent)\n       then\n          Error_Msg_N (\"loop parameter cannot be volatile\", Ent);\n       end if;\n@@ -2732,11 +2732,11 @@ package body Sem_Ch5 is\n          end;\n       end if;\n \n-      --  A loop parameter cannot be volatile. This check is peformed only\n-      --  when SPARK_Mode is on as it is not a standard Ada legality check\n-      --  (SPARK RM 7.1.3(6)).\n+      --  A loop parameter cannot be effectively volatile. This check is\n+      --  peformed only when SPARK_Mode is on as it is not a standard Ada\n+      --  legality check (SPARK RM 7.1.3(6)).\n \n-      if SPARK_Mode = On and then Is_SPARK_Volatile (Id) then\n+      if SPARK_Mode = On and then Is_Effectively_Volatile (Id) then\n          Error_Msg_N (\"loop parameter cannot be volatile\", Id);\n       end if;\n    end Analyze_Loop_Parameter_Specification;"}, {"sha": "6bae214ca3ec69597a184dfad1e5a1fef6dc10c7", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d780e54fa036407bc057a43f2ebf7d945b80add0", "patch": "@@ -10095,21 +10095,22 @@ package body Sem_Ch6 is\n                     (\"function cannot have parameter of mode `OUT` or \"\n                      & \"`IN OUT`\", Formal);\n \n-               --  A function cannot have a volatile formal parameter\n-               --  (SPARK RM 7.1.3(10)).\n+               --  A function cannot have an effectively volatile formal\n+               --  parameter (SPARK RM 7.1.3(10)).\n \n-               elsif Is_SPARK_Volatile (Formal) then\n+               elsif Is_Effectively_Volatile (Formal) then\n                   Error_Msg_N\n                     (\"function cannot have a volatile formal parameter\",\n                      Formal);\n                end if;\n \n-            --  A procedure cannot have a formal parameter of mode IN because\n-            --  it behaves as a constant (SPARK RM 7.1.3(6)).\n+            --  A procedure cannot have an effectively volatile formal\n+            --  parameter of mode IN because it behaves as a constant\n+            --  (SPARK RM 7.1.3(6)).\n \n             elsif Ekind (Scope (Formal)) = E_Procedure\n               and then Ekind (Formal) = E_In_Parameter\n-              and then Is_SPARK_Volatile (Formal)\n+              and then Is_Effectively_Volatile (Formal)\n             then\n                Error_Msg_N\n                  (\"formal parameter of mode `IN` cannot be volatile\", Formal);"}, {"sha": "87695e7c58834c338db208215551e87e1c79b08e", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d780e54fa036407bc057a43f2ebf7d945b80add0", "patch": "@@ -1830,16 +1830,16 @@ package body Sem_Prag is\n    begin\n       Error_Msg_Name_1 := Pragma_Name (N);\n \n-      --  An external property pragma must apply to a volatile object other\n-      --  than a formal subprogram parameter (SPARK RM 7.1.3(2)). The check\n-      --  is performed at the end of the declarative region due to a possible\n-      --  out-of-order arrangement of pragmas:\n+      --  An external property pragma must apply to an effectively volatile\n+      --  object other than a formal subprogram parameter (SPARK RM 7.1.3(2)).\n+      --  The check is performed at the end of the declarative region due to a\n+      --  possible out-of-order arrangement of pragmas:\n \n       --    Obj : ...;\n       --    pragma Async_Readers (Obj);\n       --    pragma Volatile (Obj);\n \n-      if not Is_SPARK_Volatile (Obj_Id) then\n+      if not Is_Effectively_Volatile (Obj_Id) then\n          SPARK_Msg_N\n            (\"external property % must apply to a volatile object\", N);\n       end if;\n@@ -2021,19 +2021,21 @@ package body Sem_Prag is\n                --  SPARK_Mode is on as they are not standard Ada legality\n                --  rules.\n \n-               elsif SPARK_Mode = On and then Is_SPARK_Volatile (Item_Id) then\n-\n-                  --  A volatile object cannot appear as a global item of a\n-                  --  function (SPARK RM 7.1.3(9)).\n+               elsif SPARK_Mode = On\n+                 and then Is_Effectively_Volatile (Item_Id)\n+               then\n+                  --  An effectively volatile object cannot appear as a global\n+                  --  item of a function (SPARK RM 7.1.3(9)).\n \n                   if Ekind_In (Spec_Id, E_Function, E_Generic_Function) then\n                      Error_Msg_NE\n                        (\"volatile object & cannot act as global item of a \"\n                         & \"function\", Item, Item_Id);\n                      return;\n \n-                  --  A volatile object with property Effective_Reads set to\n-                  --  True must have mode Output or In_Out.\n+                  --  An effectively volatile object with external property\n+                  --  Effective_Reads set to True must have mode Output or\n+                  --  In_Out.\n \n                   elsif Effective_Reads_Enabled (Item_Id)\n                     and then Global_Mode = Name_Input"}, {"sha": "0e899ed9272d37515a076cce6c50236c46f5b82f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d780e54fa036407bc057a43f2ebf7d945b80add0", "patch": "@@ -4329,18 +4329,19 @@ package body Sem_Res is\n             --  they are not standard Ada legality rule.\n \n             if SPARK_Mode = On\n-              and then Is_SPARK_Volatile_Object (A)\n+              and then Is_Effectively_Volatile_Object (A)\n             then\n-               --  A volatile object may act as an actual parameter when the\n-               --  corresponding formal is of a non-scalar volatile type.\n+               --  An effectively volatile object may act as an actual\n+               --  parameter when the corresponding formal is of a non-scalar\n+               --  volatile type.\n \n                if Is_Volatile (Etype (F))\n                  and then not Is_Scalar_Type (Etype (F))\n                then\n                   null;\n \n-               --  A volatile object may act as an actual parameter in a call\n-               --  to an instance of Unchecked_Conversion.\n+               --  An effectively volatile object may act as an actual\n+               --  parameter in a call to an instance of Unchecked_Conversion.\n \n                elsif Is_Unchecked_Conversion_Instance (Nam) then\n                   null;\n@@ -6785,33 +6786,33 @@ package body Sem_Res is\n          Eval_Entity_Name (N);\n       end if;\n \n-      --  A volatile object subject to enabled properties Async_Writers or\n-      --  Effective_Reads must appear in a specific context. The following\n-      --  checks are only relevant when SPARK_Mode is on as they are not\n-      --  standard Ada legality rules.\n+      --  An effectively volatile object subject to enabled properties\n+      --  Async_Writers or Effective_Reads must appear in a specific context.\n+      --  The following checks are only relevant when SPARK_Mode is on as they\n+      --  are not standard Ada legality rules.\n \n       if SPARK_Mode = On\n         and then Is_Object (E)\n-        and then Is_SPARK_Volatile (E)\n+        and then Is_Effectively_Volatile (E)\n         and then Comes_From_Source (E)\n         and then\n           (Async_Writers_Enabled (E) or else Effective_Reads_Enabled (E))\n       then\n-         --  The volatile objects appears in a \"non-interfering context\" as\n-         --  defined in SPARK RM 7.1.3(13).\n+         --  The effectively volatile objects appears in a \"non-interfering\n+         --  context\" as defined in SPARK RM 7.1.3(13).\n \n          if Is_OK_Volatile_Context (Par, N) then\n             null;\n \n-         --  Assume that references to volatile objects that appear as actual\n-         --  parameters in a procedure call are always legal. The full legality\n-         --  check is done when the actuals are resolved.\n+         --  Assume that references to effectively volatile objects that appear\n+         --  as actual parameters in a procedure call are always legal. The\n+         --  full legality check is done when the actuals are resolved.\n \n          elsif Nkind (Par) = N_Procedure_Call_Statement then\n             null;\n \n          --  Otherwise the context causes a side effect with respect to the\n-         --  volatile object.\n+         --  effectively volatile object.\n \n          else\n             Error_Msg_N"}, {"sha": "abe834c874d4e8609c996a155f106165d737e0ef", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 67, "deletions": 39, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d780e54fa036407bc057a43f2ebf7d945b80add0", "patch": "@@ -7605,9 +7605,10 @@ package body Sem_Util is\n       --  Start of processing for Variable_Has_Enabled_Property\n \n       begin\n-         --  A non-volatile object can never possess external properties\n+         --  A non-effectively volatile object can never possess external\n+         --  properties.\n \n-         if not Is_SPARK_Volatile (Item_Id) then\n+         if not Is_Effectively_Volatile (Item_Id) then\n             return False;\n \n          --  External properties related to variables come in two flavors -\n@@ -7650,10 +7651,11 @@ package body Sem_Util is\n       elsif Ekind (Item_Id) = E_Variable then\n          return Variable_Has_Enabled_Property;\n \n-      --  Otherwise a property is enabled when the related object is volatile\n+      --  Otherwise a property is enabled when the related item is effectively\n+      --  volatile.\n \n       else\n-         return Is_SPARK_Volatile (Item_Id);\n+         return Is_Effectively_Volatile (Item_Id);\n       end if;\n    end Has_Enabled_Property;\n \n@@ -10117,6 +10119,67 @@ package body Sem_Util is\n       end if;\n    end Is_Descendent_Of;\n \n+   -----------------------------\n+   -- Is_Effectively_Volatile --\n+   -----------------------------\n+\n+   function Is_Effectively_Volatile (Id : Entity_Id) return Boolean is\n+   begin\n+      if Is_Type (Id) then\n+\n+         --  An arbitrary type is effectively volatile when it is subject to\n+         --  pragma Atomic or Volatile.\n+\n+         if Is_Volatile (Id) then\n+            return True;\n+\n+         --  An array type is effectively volatile when it is subject to pragma\n+         --  Atomic_Components or Volatile_Components or its compolent type is\n+         --  effectively volatile.\n+\n+         elsif Is_Array_Type (Id) then\n+            return\n+              Has_Volatile_Components (Id)\n+                or else\n+              Is_Effectively_Volatile (Component_Type (Base_Type (Id)));\n+\n+         else\n+            return False;\n+         end if;\n+\n+      --  Otherwise Id denotes an object\n+\n+      else\n+         return Is_Volatile (Id) or else Is_Effectively_Volatile (Etype (Id));\n+      end if;\n+   end Is_Effectively_Volatile;\n+\n+   ------------------------------------\n+   -- Is_Effectively_Volatile_Object --\n+   ------------------------------------\n+\n+   function Is_Effectively_Volatile_Object (N : Node_Id) return Boolean is\n+   begin\n+      if Is_Entity_Name (N) then\n+         return Is_Effectively_Volatile (Entity (N));\n+\n+      elsif Nkind (N) = N_Expanded_Name then\n+         return Is_Effectively_Volatile (Entity (N));\n+\n+      elsif Nkind (N) = N_Indexed_Component then\n+         return Is_Effectively_Volatile_Object (Prefix (N));\n+\n+      elsif Nkind (N) = N_Selected_Component then\n+         return\n+           Is_Effectively_Volatile_Object (Prefix (N))\n+             or else\n+           Is_Effectively_Volatile_Object (Selector_Name (N));\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Effectively_Volatile_Object;\n+\n    ----------------------------\n    -- Is_Expression_Function --\n    ----------------------------\n@@ -11491,41 +11554,6 @@ package body Sem_Util is\n       end if;\n    end Is_SPARK_Object_Reference;\n \n-   -----------------------\n-   -- Is_SPARK_Volatile --\n-   -----------------------\n-\n-   function Is_SPARK_Volatile (Id : Entity_Id) return Boolean is\n-   begin\n-      return Is_Volatile (Id) or else Is_Volatile (Etype (Id));\n-   end Is_SPARK_Volatile;\n-\n-   ------------------------------\n-   -- Is_SPARK_Volatile_Object --\n-   ------------------------------\n-\n-   function Is_SPARK_Volatile_Object (N : Node_Id) return Boolean is\n-   begin\n-      if Is_Entity_Name (N) then\n-         return Is_SPARK_Volatile (Entity (N));\n-\n-      elsif Nkind (N) = N_Expanded_Name then\n-         return Is_SPARK_Volatile (Entity (N));\n-\n-      elsif Nkind (N) = N_Indexed_Component then\n-         return Is_SPARK_Volatile_Object (Prefix (N));\n-\n-      elsif Nkind (N) = N_Selected_Component then\n-         return\n-           Is_SPARK_Volatile_Object (Prefix (N))\n-             or else\n-           Is_SPARK_Volatile_Object (Selector_Name (N));\n-\n-      else\n-         return False;\n-      end if;\n-   end Is_SPARK_Volatile_Object;\n-\n    ------------------\n    -- Is_Statement --\n    ------------------"}, {"sha": "da0a538febc06eab9d97ff90342a04d6f90e40a2", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d780e54fa036407bc057a43f2ebf7d945b80add0/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d780e54fa036407bc057a43f2ebf7d945b80add0", "patch": "@@ -1171,6 +1171,15 @@ package Sem_Util is\n    --  This is the RM definition, a type is a descendent of another type if it\n    --  is the same type or is derived from a descendent of the other type.\n \n+   function Is_Effectively_Volatile (Id : Entity_Id) return Boolean;\n+   --  The SPARK property \"effectively volatile\" applies to both types and\n+   --  objects. To qualify as such, an entity must be either volatile or be\n+   --  (of) an array type subject to aspect Volatile_Components.\n+\n+   function Is_Effectively_Volatile_Object (N : Node_Id) return Boolean;\n+   --  Determine whether an arbitrary node denotes an effectively volatile\n+   --  object.\n+\n    function Is_Expression_Function (Subp : Entity_Id) return Boolean;\n    --  Predicate to determine whether a scope entity comes from a rewritten\n    --  expression function call, and should be inlined unconditionally. Also\n@@ -1310,18 +1319,6 @@ package Sem_Util is\n    function Is_SPARK_Object_Reference (N : Node_Id) return Boolean;\n    --  Determines if the tree referenced by N represents an object in SPARK\n \n-   function Is_SPARK_Volatile (Id : Entity_Id) return Boolean;\n-   --  This routine is similar to predicate Is_Volatile, but it takes SPARK\n-   --  semantics into account. In SPARK volatile components to not render a\n-   --  type volatile.\n-\n-   function Is_SPARK_Volatile_Object (N : Node_Id) return Boolean;\n-   --  Determine whether an arbitrary node denotes a volatile object reference\n-   --  according to the semantics of SPARK. To qualify as volatile, an object\n-   --  must be subject to aspect/pragma Volatile or Atomic, or have a [sub]type\n-   --  subject to the same attributes. Note that volatile components do not\n-   --  render an object volatile.\n-\n    function Is_Statement (N : Node_Id) return Boolean;\n    pragma Inline (Is_Statement);\n    --  Check if the node N is a statement node. Note that this includes"}]}