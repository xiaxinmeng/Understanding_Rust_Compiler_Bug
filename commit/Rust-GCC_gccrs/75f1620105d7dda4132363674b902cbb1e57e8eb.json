{"sha": "75f1620105d7dda4132363674b902cbb1e57e8eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVmMTYyMDEwNWQ3ZGRhNDEzMjM2MzY3NGI5MDJjYmIxZTU3ZThlYg==", "commit": {"author": {"name": "Fei Yang", "email": "fyang@gcc.gnu.org", "date": "2015-01-19T14:21:45Z"}, "committer": {"name": "Fei Yang", "email": "fyang@gcc.gnu.org", "date": "2015-01-19T14:21:45Z"}, "message": "* gcc.target/aarch64/advsimd-intrinsics/compute-ref-data.h\n       (buffer_float64x2, buffer_pad_float64x2): New helper variables.\n       * gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h (hfloat64_t,\n       result_float64x2, expected_hfloat64x2): New helper type, variable and\n       declaration.\n       (buffer_float64x2, buffer_pad_float64x2): New helper variables.\n       * gcc.target/aarch64/advsimd-intrinsics/vfma.c: Don't run on target\n       without the FMA feature and exclude test for vfmaq_f64 on arm*-*-*.\n       * gcc.target/aarch64/advsimd-intrinsics/vfms.c: Don't run on target\n       without the FMA feature and exclude test for vfmsq_f64 on arm*-*-*.\n       * gcc.target/aarch64/advsimd-intrinsics/vfma_n.c: Don't run on arm*-*-*\n       and target without the FMA feature.\n\nFrom-SVN: r219845", "tree": {"sha": "41960d1f24a7c77d890e8013be4c820eaec1226a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41960d1f24a7c77d890e8013be4c820eaec1226a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75f1620105d7dda4132363674b902cbb1e57e8eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75f1620105d7dda4132363674b902cbb1e57e8eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75f1620105d7dda4132363674b902cbb1e57e8eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75f1620105d7dda4132363674b902cbb1e57e8eb/comments", "author": null, "committer": null, "parents": [{"sha": "af129d07878665c2c11a6801063f007317114389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af129d07878665c2c11a6801063f007317114389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af129d07878665c2c11a6801063f007317114389"}], "stats": {"total": 176, "additions": 128, "deletions": 48}, "files": [{"sha": "8f6a88fd4187256579ab83051f6f45e904d41c13", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=75f1620105d7dda4132363674b902cbb1e57e8eb", "patch": "@@ -1,8 +1,24 @@\n+2015-01-19  Felix Yang  <felix.yang@huawei.com>\n+\t    Haijian Zhang  <z.zhanghaijian@huawei.com>\n+\n+\t* gcc.target/aarch64/advsimd-intrinsics/compute-ref-data.h\n+\t(buffer_float64x2, buffer_pad_float64x2): New helper variables.\n+\t* gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h (hfloat64_t,\n+\tresult_float64x2, expected_hfloat64x2): New helper type, variable and\n+\tdeclaration.\n+\t(buffer_float64x2, buffer_pad_float64x2): New helper variables.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vfma.c: Don't run on target\n+\twithout the FMA feature and exclude test for vfmaq_f64 on arm*-*-*.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vfms.c: Don't run on target\n+\twithout the FMA feature and exclude test for vfmsq_f64 on arm*-*-*.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vfma_n.c: Don't run on arm*-*-*\n+\tand target without the FMA feature.\n+\n 2015-01-19  Jiong Wang  <jiong.wang@arm.com>\n \n \t* gcc.target/aarch64/pr64304.c: New testcase.\n \n-2014-01-19  Igor Zamyatin  <igor.zamyatin@intel.com>\n+2015-01-19  Igor Zamyatin  <igor.zamyatin@intel.com>\n \n \tPR rtl-optimization/64081\n \t* gcc.dg/pr64081.c: New test."}, {"sha": "80d6b5893cc33eaff4178a2f26aa53ccf1c48dda", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Farm-neon-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Farm-neon-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Farm-neon-ref.h?ref=75f1620105d7dda4132363674b902cbb1e57e8eb", "patch": "@@ -8,6 +8,7 @@\n \n /* helper type, to help write floating point results in integer form.  */\n typedef uint32_t hfloat32_t;\n+typedef uint64_t hfloat64_t;\n \n extern void abort(void);\n extern void *memset(void *, int, size_t);\n@@ -143,6 +144,9 @@ static ARRAY(result, uint, 64, 2);\n static ARRAY(result, poly, 8, 16);\n static ARRAY(result, poly, 16, 8);\n static ARRAY(result, float, 32, 4);\n+#ifdef __aarch64__\n+static ARRAY(result, float, 64, 2);\n+#endif\n \n /* Declare expected results, one of each size. They are defined and\n    initialized in each test file.  */\n@@ -168,6 +172,7 @@ extern ARRAY(expected, uint, 64, 2);\n extern ARRAY(expected, poly, 8, 16);\n extern ARRAY(expected, poly, 16, 8);\n extern ARRAY(expected, hfloat, 32, 4);\n+extern ARRAY(expected, hfloat, 64, 2);\n \n /* Check results. Operates on all possible vector types.  */\n #define CHECK_RESULTS(test_name,comment)\t\t\t\t\\"}, {"sha": "26203cc0a69372e6a5d826f3c2b6663a65686a37", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/compute-ref-data.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fcompute-ref-data.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fcompute-ref-data.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fcompute-ref-data.h?ref=75f1620105d7dda4132363674b902cbb1e57e8eb", "patch": "@@ -142,6 +142,10 @@ VECT_VAR_DECL_INIT(buffer, poly, 16, 8);\n PAD(buffer_pad, poly, 16, 8);\n VECT_VAR_DECL_INIT(buffer, float, 32, 4);\n PAD(buffer_pad, float, 32, 4);\n+#ifdef __aarch64__\n+VECT_VAR_DECL_INIT(buffer, float, 64, 2);\n+PAD(buffer_pad, float, 64, 2);\n+#endif\n \n /* The tests for vld1_dup and vdup expect at least 4 entries in the\n    input buffer, so force 1- and 2-elements initializers to have 4"}, {"sha": "8180108d528219d05dff3d5eb3b231e370ad8fce", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vfma.c", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvfma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvfma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvfma.c?ref=75f1620105d7dda4132363674b902cbb1e57e8eb", "patch": "@@ -2,66 +2,91 @@\n #include \"arm-neon-ref.h\"\n #include \"compute-ref-data.h\"\n \n+#ifdef __ARM_FEATURE_FMA\n /* Expected results.  */\n VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x4438ca3d, 0x44390a3d };\n VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x44869eb8, 0x4486beb8, 0x4486deb8, 0x4486feb8 };\n+#ifdef __aarch64__\n VECT_VAR_DECL(expected,hfloat,64,2) [] = { 0x408906e1532b8520, 0x40890ee1532b8520 };\n+#endif\n \n #define TEST_MSG \"VFMA/VFMAQ\"\n+\n void exec_vfma (void)\n {\n   /* Basic test: v4=vfma(v1,v2), then store the result.  */\n #define TEST_VFMA(Q, T1, T2, W, N)\t\t\t\t\t\\\n   VECT_VAR(vector_res, T1, W, N) =\t\t\t\t\t\\\n     vfma##Q##_##T2##W(VECT_VAR(vector1, T1, W, N),\t\t\t\\\n \t\t      VECT_VAR(vector2, T1, W, N),\t\t\t\\\n-\t\t\t  VECT_VAR(vector3, T1, W, N));\t\t\t\\\n+\t\t      VECT_VAR(vector3, T1, W, N));\t\t\t\\\n   vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))\n \n+#ifdef __aarch64__\n #define CHECK_VFMA_RESULTS(test_name,comment)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     CHECK_FP(test_name, float, 32, 2, PRIx32, expected, comment);\t\\\n     CHECK_FP(test_name, float, 32, 4, PRIx32, expected, comment);\t\\\n-\tCHECK_FP(test_name, float, 64, 2, PRIx64, expected, comment);\t\\\n-  }\t\n-\n-#define DECL_VABD_VAR(VAR)\t\t\t\\\n+    CHECK_FP(test_name, float, 64, 2, PRIx64, expected, comment);\t\\\n+  }\n+#define DECL_VFMA_VAR(VAR)\t\t\t\\\n   DECL_VARIABLE(VAR, float, 32, 2);\t\t\\\n   DECL_VARIABLE(VAR, float, 32, 4);\t\t\\\n-  DECL_VARIABLE(VAR, float, 64, 2);\t\t\n+  DECL_VARIABLE(VAR, float, 64, 2);\n+#else\n+#define CHECK_VFMA_RESULTS(test_name,comment)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    CHECK_FP(test_name, float, 32, 2, PRIx32, expected, comment);\t\\\n+    CHECK_FP(test_name, float, 32, 4, PRIx32, expected, comment);\t\\\n+  }\n+#define DECL_VFMA_VAR(VAR)\t\t\t\\\n+  DECL_VARIABLE(VAR, float, 32, 2);\t\t\\\n+  DECL_VARIABLE(VAR, float, 32, 4);\n+#endif\n \n-  DECL_VABD_VAR(vector1);\n-  DECL_VABD_VAR(vector2);\n-  DECL_VABD_VAR(vector3);\n-  DECL_VABD_VAR(vector_res);\n+  DECL_VFMA_VAR(vector1);\n+  DECL_VFMA_VAR(vector2);\n+  DECL_VFMA_VAR(vector3);\n+  DECL_VFMA_VAR(vector_res);\n \n   clean_results ();\n \n   /* Initialize input \"vector1\" from \"buffer\".  */\n   VLOAD(vector1, buffer, , float, f, 32, 2);\n   VLOAD(vector1, buffer, q, float, f, 32, 4);\n+#ifdef __aarch64__\n   VLOAD(vector1, buffer, q, float, f, 64, 2);\n+#endif\n \n   /* Choose init value arbitrarily.  */\n   VDUP(vector2, , float, f, 32, 2, 9.3f);\n   VDUP(vector2, q, float, f, 32, 4, 29.7f);\n+#ifdef __aarch64__\n   VDUP(vector2, q, float, f, 64, 2, 15.8f);\n+#endif\n   \n   /* Choose init value arbitrarily.  */\n   VDUP(vector3, , float, f, 32, 2, 81.2f);\n   VDUP(vector3, q, float, f, 32, 4, 36.8f);\n+#ifdef __aarch64__\n   VDUP(vector3, q, float, f, 64, 2, 51.7f);\n+#endif\n \n   /* Execute the tests.  */\n   TEST_VFMA(, float, f, 32, 2);\n   TEST_VFMA(q, float, f, 32, 4);\n+#ifdef __aarch64__\n   TEST_VFMA(q, float, f, 64, 2);\n+#endif\n \n   CHECK_VFMA_RESULTS (TEST_MSG, \"\");\n }\n+#endif\n \n int main (void)\n {\n+#ifdef __ARM_FEATURE_FMA\n   exec_vfma ();\n+#endif\n   return 0;\n }"}, {"sha": "f3e9dbbf9573cffb94200dc0a73f2c72297451dc", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vfma_n.c", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvfma_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvfma_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvfma_n.c?ref=75f1620105d7dda4132363674b902cbb1e57e8eb", "patch": "@@ -2,40 +2,42 @@\n #include \"arm-neon-ref.h\"\n #include \"compute-ref-data.h\"\n \n+#if defined(__aarch64__) && defined(__ARM_FEATURE_FMA)\n /* Expected results.  */\n VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x4438ca3d, 0x44390a3d };\n VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x44869eb8, 0x4486beb8, 0x4486deb8, 0x4486feb8 };\n VECT_VAR_DECL(expected,hfloat,64,2) [] = { 0x408906e1532b8520, 0x40890ee1532b8520 };\n \n #define VECT_VAR_ASSIGN(S,Q,T1,W) S##Q##_##T1##W\n #define ASSIGN(S, Q, T, W, V) T##W##_t S##Q##_##T##W = V\n-#define TEST_MSG \"VFMA/VFMAQ\"\n+#define TEST_MSG \"VFMA_N/VFMAQ_N\"\n+\n void exec_vfma_n (void)\n {\n   /* Basic test: v4=vfma_n(v1,v2), then store the result.  */\n-#define TEST_VFMA(Q, T1, T2, W, N)\t\t\t\t\t\\\n+#define TEST_VFMA_N(Q, T1, T2, W, N)\t\t\t\t\t\\\n   VECT_VAR(vector_res, T1, W, N) =\t\t\t\t\t\\\n     vfma##Q##_n_##T2##W(VECT_VAR(vector1, T1, W, N),\t\t\t\\\n-\t\t      VECT_VAR(vector2, T1, W, N),\t\t\t\\\n-\t\t\t  VECT_VAR_ASSIGN(Scalar, Q, T1, W));\t\t\t\\\n+\t\t\tVECT_VAR(vector2, T1, W, N),\t\t\t\\\n+\t\t\tVECT_VAR_ASSIGN(scalar, Q, T1, W));\t\t\\\n   vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))\n \n-#define CHECK_VFMA_RESULTS(test_name,comment)\t\t\t\t\\\n+#define CHECK_VFMA_N_RESULTS(test_name,comment)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     CHECK_FP(test_name, float, 32, 2, PRIx32, expected, comment);\t\\\n     CHECK_FP(test_name, float, 32, 4, PRIx32, expected, comment);\t\\\n-\tCHECK_FP(test_name, float, 64, 2, PRIx64, expected, comment);\t\\\n-  }\t\n+    CHECK_FP(test_name, float, 64, 2, PRIx64, expected, comment);\t\\\n+  }\n \n-#define DECL_VABD_VAR(VAR)\t\t\t\\\n+#define DECL_VFMA_N_VAR(VAR)\t\t\t\\\n   DECL_VARIABLE(VAR, float, 32, 2);\t\t\\\n   DECL_VARIABLE(VAR, float, 32, 4);\t\t\\\n-  DECL_VARIABLE(VAR, float, 64, 2);\t\t\n+  DECL_VARIABLE(VAR, float, 64, 2);\n \n-  DECL_VABD_VAR(vector1);\n-  DECL_VABD_VAR(vector2);\n-  DECL_VABD_VAR(vector3);\n-  DECL_VABD_VAR(vector_res);\n+  DECL_VFMA_N_VAR(vector1);\n+  DECL_VFMA_N_VAR(vector2);\n+  DECL_VFMA_N_VAR(vector3);\n+  DECL_VFMA_N_VAR(vector_res);\n \n   clean_results ();\n \n@@ -50,20 +52,23 @@ void exec_vfma_n (void)\n   VDUP(vector2, q, float, f, 64, 2, 15.8f);\n   \n   /* Choose init value arbitrarily.  */\n-  ASSIGN(Scalar, , float, 32, 81.2f);\n-  ASSIGN(Scalar, q, float, 32, 36.8f);\n-  ASSIGN(Scalar, q, float, 64, 51.7f);\n+  ASSIGN(scalar, , float, 32, 81.2f);\n+  ASSIGN(scalar, q, float, 32, 36.8f);\n+  ASSIGN(scalar, q, float, 64, 51.7f);\n \n   /* Execute the tests.  */\n-  TEST_VFMA(, float, f, 32, 2);\n-  TEST_VFMA(q, float, f, 32, 4);\n-  TEST_VFMA(q, float, f, 64, 2);\n+  TEST_VFMA_N(, float, f, 32, 2);\n+  TEST_VFMA_N(q, float, f, 32, 4);\n+  TEST_VFMA_N(q, float, f, 64, 2);\n \n-  CHECK_VFMA_RESULTS (TEST_MSG, \"\");\n+  CHECK_VFMA_N_RESULTS (TEST_MSG, \"\");\n }\n+#endif\n \n int main (void)\n {\n+#if defined(__aarch64__) && defined(__ARM_FEATURE_FMA)\n   exec_vfma_n ();\n+#endif\n   return 0;\n }"}, {"sha": "02bef09d48772ba0420647c38e81e21decaa6a87", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vfms.c", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvfms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f1620105d7dda4132363674b902cbb1e57e8eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvfms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvfms.c?ref=75f1620105d7dda4132363674b902cbb1e57e8eb", "patch": "@@ -2,66 +2,91 @@\n #include \"arm-neon-ref.h\"\n #include \"compute-ref-data.h\"\n \n+#ifdef __ARM_FEATURE_FMA\n /* Expected results.  */\n VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc440ca3d, 0xc4408a3d };\n VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc48a9eb8, 0xc48a7eb8, 0xc48a5eb8, 0xc48a3eb8 };\n+#ifdef __aarch64__\n VECT_VAR_DECL(expected,hfloat,64,2) [] = { 0xc08a06e1532b8520, 0xc089fee1532b8520 };\n+#endif\n+\n+#define TEST_MSG \"VFMS/VFMSQ\"\n \n-#define TEST_MSG \"VFMA/VFMAQ\"\n void exec_vfms (void)\n {\n   /* Basic test: v4=vfms(v1,v2), then store the result.  */\n-#define TEST_VFMA(Q, T1, T2, W, N)\t\t\t\t\t\\\n+#define TEST_VFMS(Q, T1, T2, W, N)\t\t\t\t\t\\\n   VECT_VAR(vector_res, T1, W, N) =\t\t\t\t\t\\\n     vfms##Q##_##T2##W(VECT_VAR(vector1, T1, W, N),\t\t\t\\\n \t\t      VECT_VAR(vector2, T1, W, N),\t\t\t\\\n-\t\t\t  VECT_VAR(vector3, T1, W, N));\t\t\t\\\n+\t\t      VECT_VAR(vector3, T1, W, N));\t\t\t\\\n   vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))\n \n-#define CHECK_VFMA_RESULTS(test_name,comment)\t\t\t\t\\\n+#ifdef __aarch64__\n+#define CHECK_VFMS_RESULTS(test_name,comment)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     CHECK_FP(test_name, float, 32, 2, PRIx32, expected, comment);\t\\\n     CHECK_FP(test_name, float, 32, 4, PRIx32, expected, comment);\t\\\n-\tCHECK_FP(test_name, float, 64, 2, PRIx64, expected, comment);\t\\\n-  }\t\n-\n-#define DECL_VABD_VAR(VAR)\t\t\t\\\n+    CHECK_FP(test_name, float, 64, 2, PRIx64, expected, comment);\t\\\n+  }\n+#define DECL_VFMS_VAR(VAR)\t\t\t\\\n   DECL_VARIABLE(VAR, float, 32, 2);\t\t\\\n   DECL_VARIABLE(VAR, float, 32, 4);\t\t\\\n-  DECL_VARIABLE(VAR, float, 64, 2);\t\t\n+  DECL_VARIABLE(VAR, float, 64, 2);\n+#else\n+#define CHECK_VFMS_RESULTS(test_name,comment)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    CHECK_FP(test_name, float, 32, 2, PRIx32, expected, comment);\t\\\n+    CHECK_FP(test_name, float, 32, 4, PRIx32, expected, comment);\t\\\n+  }\n+#define DECL_VFMS_VAR(VAR)\t\t\t\\\n+  DECL_VARIABLE(VAR, float, 32, 2);\t\t\\\n+  DECL_VARIABLE(VAR, float, 32, 4);\n+#endif\n \n-  DECL_VABD_VAR(vector1);\n-  DECL_VABD_VAR(vector2);\n-  DECL_VABD_VAR(vector3);\n-  DECL_VABD_VAR(vector_res);\n+  DECL_VFMS_VAR(vector1);\n+  DECL_VFMS_VAR(vector2);\n+  DECL_VFMS_VAR(vector3);\n+  DECL_VFMS_VAR(vector_res);\n \n   clean_results ();\n \n   /* Initialize input \"vector1\" from \"buffer\".  */\n   VLOAD(vector1, buffer, , float, f, 32, 2);\n   VLOAD(vector1, buffer, q, float, f, 32, 4);\n+#ifdef __aarch64__\n   VLOAD(vector1, buffer, q, float, f, 64, 2);\n+#endif\n \n   /* Choose init value arbitrarily.  */\n   VDUP(vector2, , float, f, 32, 2, 9.3f);\n   VDUP(vector2, q, float, f, 32, 4, 29.7f);\n+#ifdef __aarch64__\n   VDUP(vector2, q, float, f, 64, 2, 15.8f);\n+#endif\n   \n   /* Choose init value arbitrarily.  */\n   VDUP(vector3, , float, f, 32, 2, 81.2f);\n   VDUP(vector3, q, float, f, 32, 4, 36.8f);\n+#ifdef __aarch64__\n   VDUP(vector3, q, float, f, 64, 2, 51.7f);\n+#endif\n \n   /* Execute the tests.  */\n-  TEST_VFMA(, float, f, 32, 2);\n-  TEST_VFMA(q, float, f, 32, 4);\n-  TEST_VFMA(q, float, f, 64, 2);\n+  TEST_VFMS(, float, f, 32, 2);\n+  TEST_VFMS(q, float, f, 32, 4);\n+#ifdef __aarch64__\n+  TEST_VFMS(q, float, f, 64, 2);\n+#endif\n \n-  CHECK_VFMA_RESULTS (TEST_MSG, \"\");\n+  CHECK_VFMS_RESULTS (TEST_MSG, \"\");\n }\n+#endif\n \n int main (void)\n {\n+#ifdef __ARM_FEATURE_FMA\n   exec_vfms ();\n+#endif\n   return 0;\n }"}]}