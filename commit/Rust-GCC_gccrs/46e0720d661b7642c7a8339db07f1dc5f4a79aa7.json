{"sha": "46e0720d661b7642c7a8339db07f1dc5f4a79aa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZlMDcyMGQ2NjFiNzY0MmM3YTgzMzlkYjA3ZjFkYzVmNGE3OWFhNw==", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2010-10-28T18:11:11Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2010-10-28T18:11:11Z"}, "message": "Add ARM VFP ABI support to libffi.\n\nFrom-SVN: r166032", "tree": {"sha": "fbab5755aacbd7106c0f151823e9630759a60bf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbab5755aacbd7106c0f151823e9630759a60bf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46e0720d661b7642c7a8339db07f1dc5f4a79aa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46e0720d661b7642c7a8339db07f1dc5f4a79aa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46e0720d661b7642c7a8339db07f1dc5f4a79aa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f17aa4adf8e01cca835b37d677aa1eaf6796816c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f17aa4adf8e01cca835b37d677aa1eaf6796816c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f17aa4adf8e01cca835b37d677aa1eaf6796816c"}], "stats": {"total": 514, "additions": 484, "deletions": 30}, "files": [{"sha": "4eb9e2ffbdcafa664b95aba2120ad34f0a6902ca", "filename": "libffi/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=46e0720d661b7642c7a8339db07f1dc5f4a79aa7", "patch": "@@ -1,3 +1,41 @@\n+2010-10-28  Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* src/arm/ffi.c (ffi_prep_args): Add VFP register argument handling\n+\tcode, new parameter, and return value. Update comments.\n+\t(ffi_prep_cif_machdep): Add case for VFP struct return values. Add\n+\tcall to layout_vfp_args().\n+\t(ffi_call_SYSV): Update declaration.\n+\t(ffi_call_VFP): New declaration.\n+\t(ffi_call): Add VFP struct return conditions. Call ffi_call_VFP()\n+\twhen ABI is FFI_VFP.\n+\t(ffi_closure_VFP): New declaration.\n+\t(ffi_closure_SYSV_inner): Add new vfp_args parameter, update call to\n+\tffi_prep_incoming_args_SYSV().\n+\t(ffi_prep_incoming_args_SYSV): Update parameters. Add VFP argument\n+\tcase handling.\n+\t(ffi_prep_closure_loc): Pass ffi_closure_VFP to trampoline\n+\tconstruction under VFP hard-float.\n+\t(rec_vfp_type_p): New function.\n+\t(vfp_type_p): Same.\n+\t(place_vfp_arg): Same.\n+\t(layout_vfp_args): Same.\n+\t* src/arm/ffitarget.h (ffi_abi): Add FFI_VFP. Define FFI_DEFAULT_ABI\n+\tbased on __ARM_PCS_VFP.\n+\t(FFI_EXTRA_CIF_FIELDS): Define for adding VFP hard-float specific\n+\tfields.\n+\t(FFI_TYPE_STRUCT_VFP_FLOAT): Define internally used type code.\n+\t(FFI_TYPE_STRUCT_VFP_DOUBLE): Same.\n+\t* src/arm/sysv.S (ffi_call_SYSV): Change call of ffi_prep_args() to\n+\tdirect call. Move function pointer load upwards.\n+\t(ffi_call_VFP): New function.\n+\t(ffi_closure_VFP): Same.\n+\n+\t* testsuite/lib/libffi-dg.exp (check-flags): New function.\n+\t(dg-skip-if): New function.\n+\t* testsuite/libffi.call/cls_double_va.c: Skip if target is arm*-*-*\n+\tand compiler options include -mfloat-abi=hard.\n+\t* testsuite/libffi.call/cls_longdouble_va.c: Same.\n+\n 2010-10-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR libffi/45677"}, {"sha": "9a0a53c83a9206e78f38c771640d3de6dbff37b1", "filename": "libffi/src/arm/ffi.c", "status": "modified", "additions": 211, "deletions": 20, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Fsrc%2Farm%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Fsrc%2Farm%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffi.c?ref=46e0720d661b7642c7a8339db07f1dc5f4a79aa7", "patch": "@@ -29,12 +29,20 @@\n \n #include <stdlib.h>\n \n-/* ffi_prep_args is called by the assembly routine once stack space\n-   has been allocated for the function's arguments */\n+/* Forward declares. */\n+static int vfp_type_p (ffi_type *);\n+static void layout_vfp_args (ffi_cif *);\n \n-void ffi_prep_args(char *stack, extended_cif *ecif)\n+/* ffi_prep_args is called by the assembly routine once stack space\n+   has been allocated for the function's arguments\n+   \n+   The vfp_space parameter is the load area for VFP regs, the return\n+   value is cif->vfp_used (word bitset of VFP regs used for passing\n+   arguments). These are only used for the VFP hard-float ABI.\n+*/\n+int ffi_prep_args(char *stack, extended_cif *ecif, float *vfp_space)\n {\n-  register unsigned int i;\n+  register unsigned int i, vi = 0;\n   register void **p_argv;\n   register char *argp;\n   register ffi_type **p_arg;\n@@ -54,6 +62,21 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n     {\n       size_t z;\n \n+      /* Allocated in VFP registers. */\n+      if (ecif->cif->abi == FFI_VFP\n+\t  && vi < ecif->cif->vfp_nargs && vfp_type_p (*p_arg))\n+\t{\n+\t  float* vfp_slot = vfp_space + ecif->cif->vfp_args[vi++];\n+\t  if ((*p_arg)->type == FFI_TYPE_FLOAT)\n+\t    *((float*)vfp_slot) = *((float*)*p_argv);\n+\t  else if ((*p_arg)->type == FFI_TYPE_DOUBLE)\n+\t    *((double*)vfp_slot) = *((double*)*p_argv);\n+\t  else\n+\t    memcpy(vfp_slot, *p_argv, (*p_arg)->size);\n+\t  p_argv++;\n+\t  continue;\n+\t}\n+\n       /* Align if necessary */\n       if (((*p_arg)->alignment - 1) & (unsigned) argp) {\n \targp = (char *) ALIGN(argp, (*p_arg)->alignment);\n@@ -103,13 +126,15 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \t  p_argv++;\n \t  argp += z;\n     }\n-  \n-  return;\n+\n+  /* Indicate the VFP registers used. */\n+  return ecif->cif->vfp_used;\n }\n \n /* Perform machine dependent cif processing */\n ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n {\n+  int type_code;\n   /* Round the stack up to a multiple of 8 bytes.  This isn't needed \n      everywhere, but it is on some platforms, and it doesn't harm anything\n      when it isn't needed.  */\n@@ -130,7 +155,14 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       break;\n \n     case FFI_TYPE_STRUCT:\n-      if (cif->rtype->size <= 4)\n+      if (cif->abi == FFI_VFP\n+\t  && (type_code = vfp_type_p (cif->rtype)) != 0)\n+\t{\n+\t  /* A Composite Type passed in VFP registers, either\n+\t     FFI_TYPE_STRUCT_VFP_FLOAT or FFI_TYPE_STRUCT_VFP_DOUBLE. */\n+\t  cif->flags = (unsigned) type_code;\n+\t}\n+      else if (cif->rtype->size <= 4)\n \t/* A Composite Type not larger than 4 bytes is returned in r0.  */\n \tcif->flags = (unsigned)FFI_TYPE_INT;\n       else\n@@ -145,18 +177,27 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       break;\n     }\n \n+  /* Map out the register placements of VFP register args.\n+     The VFP hard-float calling conventions are slightly more sophisticated than\n+     the base calling conventions, so we do it here instead of in ffi_prep_args(). */\n+  if (cif->abi == FFI_VFP)\n+    layout_vfp_args (cif);\n+\n   return FFI_OK;\n }\n \n-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,\n-\t\t\t  unsigned, unsigned, unsigned *, void (*fn)(void));\n+/* Prototypes for assembly functions, in sysv.S */\n+extern void ffi_call_SYSV (void (*fn)(void), extended_cif *, unsigned, unsigned, unsigned *);\n+extern void ffi_call_VFP (void (*fn)(void), extended_cif *, unsigned, unsigned, unsigned *);\n \n void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n \n   int small_struct = (cif->flags == FFI_TYPE_INT \n \t\t      && cif->rtype->type == FFI_TYPE_STRUCT);\n+  int vfp_struct = (cif->flags == FFI_TYPE_STRUCT_VFP_FLOAT\n+\t\t    || cif->flags == FFI_TYPE_STRUCT_VFP_DOUBLE);\n \n   ecif.cif = cif;\n   ecif.avalue = avalue;\n@@ -173,38 +214,51 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n     }\n   else if (small_struct)\n     ecif.rvalue = &temp;\n+  else if (vfp_struct)\n+    {\n+      /* Largest case is double x 4. */\n+      ecif.rvalue = alloca(32);\n+    }\n   else\n     ecif.rvalue = rvalue;\n \n   switch (cif->abi) \n     {\n     case FFI_SYSV:\n-      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,\n-\t\t    fn);\n+      ffi_call_SYSV (fn, &ecif, cif->bytes, cif->flags, ecif.rvalue);\n+      break;\n \n+    case FFI_VFP:\n+      ffi_call_VFP (fn, &ecif, cif->bytes, cif->flags, ecif.rvalue);\n       break;\n+\n     default:\n       FFI_ASSERT(0);\n       break;\n     }\n   if (small_struct)\n     memcpy (rvalue, &temp, cif->rtype->size);\n+  else if (vfp_struct)\n+    memcpy (rvalue, ecif.rvalue, cif->rtype->size);\n }\n \n /** private members **/\n \n static void ffi_prep_incoming_args_SYSV (char *stack, void **ret,\n-\t\t\t\t\t void** args, ffi_cif* cif);\n+\t\t\t\t\t void** args, ffi_cif* cif, float *vfp_stack);\n \n void ffi_closure_SYSV (ffi_closure *);\n \n+void ffi_closure_VFP (ffi_closure *);\n+\n /* This function is jumped to by the trampoline */\n \n unsigned int\n-ffi_closure_SYSV_inner (closure, respp, args)\n+ffi_closure_SYSV_inner (closure, respp, args, vfp_args)\n      ffi_closure *closure;\n      void **respp;\n      void *args;\n+     void *vfp_args;\n {\n   // our various things...\n   ffi_cif       *cif;\n@@ -219,7 +273,7 @@ ffi_closure_SYSV_inner (closure, respp, args)\n    * a structure, it will re-set RESP to point to the\n    * structure return address.  */\n \n-  ffi_prep_incoming_args_SYSV(args, respp, arg_area, cif);\n+  ffi_prep_incoming_args_SYSV(args, respp, arg_area, cif, vfp_args);\n \n   (closure->fun) (cif, *respp, arg_area, closure->user_data);\n \n@@ -229,10 +283,12 @@ ffi_closure_SYSV_inner (closure, respp, args)\n /*@-exportheader@*/\n static void \n ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n-\t\t\t    void **avalue, ffi_cif *cif)\n+\t\t\t    void **avalue, ffi_cif *cif,\n+\t\t\t    /* Used only under VFP hard-float ABI. */\n+\t\t\t    float *vfp_stack)\n /*@=exportheader@*/\n {\n-  register unsigned int i;\n+  register unsigned int i, vi = 0;\n   register void **p_argv;\n   register char *argp;\n   register ffi_type **p_arg;\n@@ -249,8 +305,16 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n   for (i = cif->nargs, p_arg = cif->arg_types; (i != 0); i--, p_arg++)\n     {\n       size_t z;\n-\n-      size_t alignment = (*p_arg)->alignment;\n+      size_t alignment;\n+  \n+      if (cif->abi == FFI_VFP\n+\t  && vi < cif->vfp_nargs && vfp_type_p (*p_arg))\n+\t{\n+\t  *p_argv++ = (void*)(vfp_stack + cif->vfp_args[vi++]);\n+\t  continue;\n+\t}\n+\n+      alignment = (*p_arg)->alignment;\n       if (alignment < 4)\n \talignment = 4;\n       /* Align if necessary */\n@@ -295,10 +359,17 @@ ffi_prep_closure_loc (ffi_closure* closure,\n \t\t      void *user_data,\n \t\t      void *codeloc)\n {\n-  FFI_ASSERT (cif->abi == FFI_SYSV);\n+  void (*closure_func)(ffi_closure*) = NULL;\n \n+  if (cif->abi == FFI_SYSV)\n+    closure_func = &ffi_closure_SYSV;\n+  else if (cif->abi == FFI_VFP)\n+    closure_func = &ffi_closure_VFP;\n+  else\n+    FFI_ASSERT (0);\n+    \n   FFI_INIT_TRAMPOLINE (&closure->tramp[0], \\\n-\t\t       &ffi_closure_SYSV,  \\\n+\t\t       closure_func,  \\\n \t\t       codeloc);\n     \n   closure->cif  = cif;\n@@ -307,3 +378,123 @@ ffi_prep_closure_loc (ffi_closure* closure,\n \n   return FFI_OK;\n }\n+\n+/* Below are routines for VFP hard-float support. */\n+\n+static int rec_vfp_type_p (ffi_type *t, int *elt, int *elnum)\n+{\n+  switch (t->type)\n+    {\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_DOUBLE:\n+      *elt = (int) t->type;\n+      *elnum = 1;\n+      return 1;\n+\n+    case FFI_TYPE_STRUCT_VFP_FLOAT:\n+      *elt = FFI_TYPE_FLOAT;\n+      *elnum = t->size / sizeof (float);\n+      return 1;\n+\n+    case FFI_TYPE_STRUCT_VFP_DOUBLE:\n+      *elt = FFI_TYPE_DOUBLE;\n+      *elnum = t->size / sizeof (double);\n+      return 1;\n+\n+    case FFI_TYPE_STRUCT:;\n+      {\n+\tint base_elt = 0, total_elnum = 0;\n+\tffi_type **el = t->elements;\n+\twhile (*el)\n+\t  {\n+\t    int el_elt = 0, el_elnum = 0;\n+\t    if (! rec_vfp_type_p (*el, &el_elt, &el_elnum)\n+\t\t|| (base_elt && base_elt != el_elt)\n+\t\t|| total_elnum + el_elnum > 4)\n+\t      return 0;\n+\t    base_elt = el_elt;\n+\t    total_elnum += el_elnum;\n+\t    el++;\n+\t  }\n+\t*elnum = total_elnum;\n+\t*elt = base_elt;\n+\treturn 1;\n+      }\n+    default: ;\n+    }\n+  return 0;\n+}\n+\n+static int vfp_type_p (ffi_type *t)\n+{\n+  int elt, elnum;\n+  if (rec_vfp_type_p (t, &elt, &elnum))\n+    {\n+      if (t->type == FFI_TYPE_STRUCT)\n+\t{\n+\t  if (elnum == 1)\n+\t    t->type = elt;\n+\t  else\n+\t    t->type = (elt == FFI_TYPE_FLOAT\n+\t\t       ? FFI_TYPE_STRUCT_VFP_FLOAT\n+\t\t       : FFI_TYPE_STRUCT_VFP_DOUBLE);\n+\t}\n+      return (int) t->type;\n+    }\n+  return 0;\n+}\n+\n+static void place_vfp_arg (ffi_cif *cif, ffi_type *t)\n+{\n+  int reg = cif->vfp_reg_free;\n+  int nregs = t->size / sizeof (float);\n+  int align = ((t->type == FFI_TYPE_STRUCT_VFP_FLOAT\n+\t\t|| t->type == FFI_TYPE_FLOAT) ? 1 : 2);\n+  /* Align register number. */\n+  if ((reg & 1) && align == 2)\n+    reg++;\n+  while (reg + nregs <= 16)\n+    {\n+      int s, new_used = 0;\n+      for (s = reg; s < reg + nregs; s++)\n+\t{\n+\t  new_used |= (1 << s);\n+\t  if (cif->vfp_used & (1 << s))\n+\t    {\n+\t      reg += align;\n+\t      goto next_reg;\n+\t    }\n+\t}\n+      /* Found regs to allocate. */\n+      cif->vfp_used |= new_used;\n+      cif->vfp_args[cif->vfp_nargs++] = reg;\n+\n+      /* Update vfp_reg_free. */\n+      if (cif->vfp_used & (1 << cif->vfp_reg_free))\n+\t{\n+\t  reg += nregs;\n+\t  while (cif->vfp_used & (1 << reg))\n+\t    reg += 1;\n+\t  cif->vfp_reg_free = reg;\n+\t}\n+      return;\n+    next_reg: ;\n+    }\n+}\n+\n+static void layout_vfp_args (ffi_cif *cif)\n+{\n+  int i;\n+  /* Init VFP fields */\n+  cif->vfp_used = 0;\n+  cif->vfp_nargs = 0;\n+  cif->vfp_reg_free = 0;\n+  memset (cif->vfp_args, -1, 16); /* Init to -1. */\n+\n+  for (i = 0; i < cif->nargs; i++)\n+    {\n+      ffi_type *t = cif->arg_types[i];\n+      if (vfp_type_p (t))\n+\tplace_vfp_arg (cif, t);\n+    }\n+}"}, {"sha": "ce25b23f5a3edbf6a8e4d8574d5f71f770fead47", "filename": "libffi/src/arm/ffitarget.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Fsrc%2Farm%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Fsrc%2Farm%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffitarget.h?ref=46e0720d661b7642c7a8339db07f1dc5f4a79aa7", "patch": "@@ -1,5 +1,7 @@\n /* -----------------------------------------------------------------*-C-*-\n    ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+                 Copyright (c) 2010 CodeSourcery\n+\n    Target configuration macros for ARM.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -34,11 +36,25 @@ typedef signed long            ffi_sarg;\n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n   FFI_SYSV,\n+  FFI_VFP,\n+  FFI_LAST_ABI,\n+#ifdef __ARM_PCS_VFP\n+  FFI_DEFAULT_ABI = FFI_VFP,\n+#else\n   FFI_DEFAULT_ABI = FFI_SYSV,\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+#endif\n } ffi_abi;\n #endif\n \n+#define FFI_EXTRA_CIF_FIELDS\t\t\t\\\n+  int vfp_used;\t\t\t\t\t\\\n+  short vfp_reg_free, vfp_nargs;\t\t\\\n+  signed char vfp_args[16]\t\t\t\\\n+\n+/* Internally used. */\n+#define FFI_TYPE_STRUCT_VFP_FLOAT  (FFI_TYPE_LAST + 1)\n+#define FFI_TYPE_STRUCT_VFP_DOUBLE (FFI_TYPE_LAST + 2)\n+\n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1"}, {"sha": "7bce72712bbc6818682cf77aff7c149c5e4e532e", "filename": "libffi/src/arm/sysv.S", "status": "modified", "additions": 164, "deletions": 9, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Fsrc%2Farm%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Fsrc%2Farm%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fsysv.S?ref=46e0720d661b7642c7a8339db07f1dc5f4a79aa7", "patch": "@@ -142,12 +142,11 @@ _L__\\name:\n .endm\n \n \n-\t@ r0:   ffi_prep_args\n+\t@ r0:   fn\n \t@ r1:   &ecif\n \t@ r2:   cif->bytes\n \t@ r3:   fig->flags\n \t@ sp+0: ecif.rvalue\n-\t@ sp+4: fn\n \n \t@ This assumes we are using gas.\n ARM_FUNC_START ffi_call_SYSV\n@@ -162,24 +161,23 @@ ARM_FUNC_START ffi_call_SYSV\n \tsub\tsp, fp, r2\n \n \t@ Place all of the ffi_prep_args in position\n-\tmov\tip, r0\n \tmov\tr0, sp\n \t@     r1 already set\n \n \t@ Call ffi_prep_args(stack, &ecif)\n-\tcall_reg(ip)\n+\tbl\tffi_prep_args\n \n \t@ move first 4 parameters in registers\n \tldmia\tsp, {r0-r3}\n \n \t@ and adjust stack\n-\tldr\tip, [fp, #8]\n-        cmp\tip, #16\n-\tmovhs\tip, #16\n-        add\tsp, sp, ip\n+\tsub\tlr, fp, sp\t@ cif->bytes == fp - sp\n+\tldr\tip, [fp]\t@ load fn() in advance\n+\tcmp\tlr, #16\n+\tmovhs\tlr, #16\n+\tadd\tsp, sp, lr\n \n \t@ call (fn) (...)\n-\tldr\tip, [fp, #28]\n \tcall_reg(ip)\n \t\n \t@ Remove the space we pushed for the args\n@@ -230,6 +228,101 @@ LSYM(Lepilogue):\n \tUNWIND .fnend\n         .size    CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)\n \n+\n+\t@ r0:   fn\n+\t@ r1:   &ecif\n+\t@ r2:   cif->bytes\n+\t@ r3:   fig->flags\n+\t@ sp+0: ecif.rvalue\n+\n+ARM_FUNC_START ffi_call_VFP\n+\t@ Save registers\n+        stmfd\tsp!, {r0-r3, fp, lr}\n+\tUNWIND .save\t{r0-r3, fp, lr}\n+\tmov\tfp, sp\n+\tUNWIND .setfp\tfp, sp\n+\n+\t@ Make room for all of the new args.\n+\tsub\tsp, sp, r2\n+\n+\t@ Make room for loading VFP args\n+\tsub\tsp, sp, #64\n+\n+\t@ Place all of the ffi_prep_args in position\n+\tmov\tr0, sp\n+\t@     r1 already set\n+\tsub\tr2, fp, #64   @ VFP scratch space\n+\n+\t@ Call ffi_prep_args(stack, &ecif, vfp_space)\n+\tbl\tffi_prep_args\n+\n+\t@ Load VFP register args if needed\n+\tcmp\tr0, #0\n+\tbeq\tLSYM(Lbase_args)\n+\n+\t@ Load only d0 if possible\n+\tcmp\tr0, #3\n+\tsub\tip, fp, #64\n+\tflddle\td0, [ip]\n+\tfldmiadgt\tip, {d0-d7}\n+\n+LSYM(Lbase_args):\n+\t@ move first 4 parameters in registers\n+\tldmia\tsp, {r0-r3}\n+\n+\t@ and adjust stack\n+\tsub\tlr, ip, sp\t@ cif->bytes == (fp - 64) - sp\n+\tldr\tip, [fp]\t@ load fn() in advance\n+        cmp\tlr, #16\n+\tmovhs\tlr, #16\n+        add\tsp, sp, lr\n+\n+\t@ call (fn) (...)\n+\tcall_reg(ip)\n+\n+\t@ Remove the space we pushed for the args\n+\tmov\tsp, fp\n+\n+\t@ Load r2 with the pointer to storage for\n+\t@ the return value\n+\tldr\tr2, [sp, #24]\n+\n+\t@ Load r3 with the return type code \n+\tldr\tr3, [sp, #12]\n+\n+\t@ If the return value pointer is NULL,\n+\t@ assume no return value.\n+\tcmp\tr2, #0\n+\tbeq\tLSYM(Lepilogue_vfp)\n+\t\n+\tcmp\tr3, #FFI_TYPE_INT\n+\tstreq\tr0, [r2]\n+\tbeq\tLSYM(Lepilogue_vfp)\n+\n+\tcmp\tr3, #FFI_TYPE_SINT64\n+\tstmeqia\tr2, {r0, r1}\n+\tbeq\tLSYM(Lepilogue_vfp)\n+\n+\tcmp\tr3, #FFI_TYPE_FLOAT\n+\tfstseq\ts0, [r2]\n+\tbeq\tLSYM(Lepilogue_vfp)\n+\t\n+\tcmp\tr3, #FFI_TYPE_DOUBLE\n+\tfstdeq\td0, [r2]\n+\tbeq\tLSYM(Lepilogue_vfp)\n+\n+\tcmp\tr3, #FFI_TYPE_STRUCT_VFP_FLOAT\n+\tcmpne\tr3, #FFI_TYPE_STRUCT_VFP_DOUBLE\n+\tfstmiadeq\tr2, {d0-d3}\n+\n+LSYM(Lepilogue_vfp):\n+\tRETLDM\t\"r0-r3,fp\"\n+\n+.ffi_call_VFP_end:\n+\tUNWIND .fnend\n+        .size    CNAME(ffi_call_VFP),.ffi_call_VFP_end-CNAME(ffi_call_VFP)\n+\t\n+\t\n /*\n \tunsigned int FFI_HIDDEN\n \tffi_closure_SYSV_inner (closure, respp, args)\n@@ -302,6 +395,68 @@ ARM_FUNC_START ffi_closure_SYSV\n \tUNWIND .fnend\n         .size    CNAME(ffi_closure_SYSV),.ffi_closure_SYSV_end-CNAME(ffi_closure_SYSV)\n \n+\n+ARM_FUNC_START ffi_closure_VFP\n+\tfstmfdd\tsp!, {d0-d7}\n+\t@ r0-r3, then d0-d7\n+\tUNWIND .pad #80\n+\tadd\tip, sp, #80\n+\tstmfd\tsp!, {ip, lr}\n+\tUNWIND .save\t{r0, lr}\n+\tadd\tr2, sp, #72\n+\tadd\tr3, sp, #8\n+\t.pad #72\n+\tsub\tsp, sp, #72\n+\tstr\tsp, [sp, #64]\n+\tadd\tr1, sp, #64\n+\tbl\tffi_closure_SYSV_inner\n+\n+\tcmp\tr0, #FFI_TYPE_INT\n+\tbeq\t.Lretint_vfp\n+\n+\tcmp\tr0, #FFI_TYPE_FLOAT\n+\tbeq\t.Lretfloat_vfp\n+\n+\tcmp\tr0, #FFI_TYPE_DOUBLE\n+\tcmpne\tr0, #FFI_TYPE_LONGDOUBLE\n+\tbeq\t.Lretdouble_vfp\n+\n+\tcmp\tr0, #FFI_TYPE_SINT64\n+\tbeq\t.Lretlonglong_vfp\n+\n+\tcmp\tr0, #FFI_TYPE_STRUCT_VFP_FLOAT\n+\tbeq\t.Lretfloat_struct_vfp\n+\n+\tcmp\tr0, #FFI_TYPE_STRUCT_VFP_DOUBLE\n+\tbeq\t.Lretdouble_struct_vfp\n+\t\n+.Lclosure_epilogue_vfp:\n+\tadd\tsp, sp, #72\n+\tldmfd\tsp, {sp, pc}\n+\n+.Lretfloat_vfp:\n+\tflds\ts0, [sp]\n+\tb\t.Lclosure_epilogue_vfp\n+.Lretdouble_vfp:\n+\tfldd\td0, [sp]\n+\tb\t.Lclosure_epilogue_vfp\n+.Lretint_vfp:\n+\tldr\tr0, [sp]\n+\tb\t.Lclosure_epilogue_vfp\n+.Lretlonglong_vfp:\n+\tldmia\tsp, {r0, r1}\n+\tb\t.Lclosure_epilogue_vfp\n+.Lretfloat_struct_vfp:\n+\tfldmiad\tsp, {d0-d1}\n+\tb\t.Lclosure_epilogue_vfp\n+.Lretdouble_struct_vfp:\n+\tfldmiad\tsp, {d0-d3}\n+\tb\t.Lclosure_epilogue_vfp\n+\n+.ffi_closure_VFP_end:\n+\tUNWIND .fnend\n+        .size    CNAME(ffi_closure_VFP),.ffi_closure_VFP_end-CNAME(ffi_closure_VFP)\n+\n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",%progbits\n #endif"}, {"sha": "82d6652c183ab688a9fe737f6819c666bf6fd0fc", "filename": "libffi/testsuite/lib/libffi-dg.exp", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Ftestsuite%2Flib%2Flibffi-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Ftestsuite%2Flib%2Flibffi-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flib%2Flibffi-dg.exp?ref=46e0720d661b7642c7a8339db07f1dc5f4a79aa7", "patch": "@@ -272,6 +272,56 @@ proc dg-xfail-if { args } {\n     }\n }\n \n+proc check-flags { args } {\n+\n+    # The args are within another list; pull them out.\n+    set args [lindex $args 0]\n+\n+    # The next two arguments are optional.  If they were not specified,\n+    # use the defaults.\n+    if { [llength $args] == 2 } {\n+\tlappend $args [list \"*\"]\n+    }\n+    if { [llength $args] == 3 } {\n+\tlappend $args [list \"\"]\n+    }\n+\n+    # If the option strings are the defaults, or the same as the\n+    # defaults, there is no need to call check_conditional_xfail to\n+    # compare them to the actual options.\n+    if { [string compare [lindex $args 2] \"*\"] == 0\n+\t && [string compare [lindex $args 3] \"\" ] == 0 } {\n+\tset result 1    \n+    } else {\n+\t# The target list might be an effective-target keyword, so replace\n+\t# the original list with \"*-*-*\", since we already know it matches.\n+\tset result [check_conditional_xfail [lreplace $args 1 1 \"*-*-*\"]]\n+    }\n+\n+    return $result\n+}\n+\n+proc dg-skip-if { args } {\n+    # Verify the number of arguments.  The last two are optional.\n+    set args [lreplace $args 0 0]\n+    if { [llength $args] < 2 || [llength $args] > 4 } {\n+        error \"dg-skip-if 2: need 2, 3, or 4 arguments\"\n+    }\n+\n+    # Don't bother if we're already skipping the test.\n+    upvar dg-do-what dg-do-what\n+    if { [lindex ${dg-do-what} 1] == \"N\" } {\n+      return\n+    }\n+\n+    set selector [list target [lindex $args 1]]\n+    if { [dg-process-target $selector] == \"S\" } {\n+        if [check-flags $args] {\n+            upvar dg-do-what dg-do-what\n+            set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+        }\n+    }\n+}\n \n # We need to make sure that additional_files and additional_sources\n # are both cleared out after every test.  It is not enough to clear"}, {"sha": "62bebbd706905c595d4dcec8f5f9ba02691611a6", "filename": "libffi/testsuite/libffi.call/cls_double_va.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c?ref=46e0720d661b7642c7a8339db07f1dc5f4a79aa7", "patch": "@@ -6,6 +6,8 @@\n \n /* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */\n /* { dg-output \"\" { xfail avr32*-*-* } } */\n+/* { dg-skip-if \"\" arm*-*-* { \"-mfloat-abi=hard\" } { \"\" } } */\n+\n #include \"ffitest.h\"\n \n static void"}, {"sha": "b33b2b72214b7db6d7dd841c015e7673c397f164", "filename": "libffi/testsuite/libffi.call/cls_longdouble_va.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e0720d661b7642c7a8339db07f1dc5f4a79aa7/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c?ref=46e0720d661b7642c7a8339db07f1dc5f4a79aa7", "patch": "@@ -6,6 +6,8 @@\n \n /* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */\n /* { dg-output \"\" { xfail avr32*-*-* x86_64-*-mingw* } } */\n+/* { dg-skip-if \"\" arm*-*-* { \"-mfloat-abi=hard\" } { \"\" } } */\n+\n #include \"ffitest.h\"\n \n static void"}]}