{"sha": "54ecfb182bc32140722022c1d9818dee4bdc0e45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRlY2ZiMTgyYmMzMjE0MDcyMjAyMmMxZDk4MThkZWU0YmRjMGU0NQ==", "commit": {"author": {"name": "Hao Liu", "email": "hliu@os.amperecomputing.com", "date": "2020-06-04T08:28:37Z"}, "committer": {"name": "Hao Liu", "email": "hliu@os.amperecomputing.com", "date": "2020-06-04T09:04:09Z"}, "message": "cselim: Extend to check non-trapping for more references [PR89430]\n\nIf there is a dominating store, a store to the same reference can not be\ntrapped.  But previously, it only supports such check on MEM_REFs.\nSo this patch extends it to support ARRAY_REFs and COMPONENT_REFs.\n\nThis patch also supports a special case: if there is a dominating load of\nlocal variable without address escape, a store is not trapped, as local\nstack is always writable.  Other loads are ignored for simplicity, as they\ndon't help to check if a store can be trapped (the memory may be read-only).\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/89430\n\t* tree-ssa-phiopt.c\n\t(struct name_to_bb): Rename to ref_to_bb; add a new field exp;\n\tremove ssa_name_ver, store, offset fields.\n\t(struct ssa_names_hasher): Rename to refs_hasher; update functions.\n\t(class nontrapping_dom_walker): Rename m_seen_ssa_names to m_seen_refs.\n\t(nontrapping_dom_walker::add_or_mark_expr): Extend to support ARRAY_REFs\n\tand COMPONENT_REFs.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/89430\n\t* gcc.dg/tree-ssa/pr89430-1.c: Remove xfail.\n\t* gcc.dg/tree-ssa/pr89430-2.c: Remove xfail.\n\t* gcc.dg/tree-ssa/pr89430-5.c: Remove xfail.\n\t* gcc.dg/tree-ssa/pr89430-6.c: Remove xfail.\n\t* gcc.dg/tree-ssa/pr89430-7-comp-ref.c: New test.\n\t* gcc.dg/tree-ssa/pr89430-8-mem-ref-size.c: New test.\n\t* gcc.dg/tree-ssa/ssa-pre-17.c: Add -fno-tree-cselim.", "tree": {"sha": "d3850c29fff3700aba2e76d39f7cde8269047e9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3850c29fff3700aba2e76d39f7cde8269047e9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54ecfb182bc32140722022c1d9818dee4bdc0e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54ecfb182bc32140722022c1d9818dee4bdc0e45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54ecfb182bc32140722022c1d9818dee4bdc0e45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54ecfb182bc32140722022c1d9818dee4bdc0e45/comments", "author": {"login": "hliu-ampere", "id": 76081431, "node_id": "MDQ6VXNlcjc2MDgxNDMx", "avatar_url": "https://avatars.githubusercontent.com/u/76081431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hliu-ampere", "html_url": "https://github.com/hliu-ampere", "followers_url": "https://api.github.com/users/hliu-ampere/followers", "following_url": "https://api.github.com/users/hliu-ampere/following{/other_user}", "gists_url": "https://api.github.com/users/hliu-ampere/gists{/gist_id}", "starred_url": "https://api.github.com/users/hliu-ampere/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hliu-ampere/subscriptions", "organizations_url": "https://api.github.com/users/hliu-ampere/orgs", "repos_url": "https://api.github.com/users/hliu-ampere/repos", "events_url": "https://api.github.com/users/hliu-ampere/events{/privacy}", "received_events_url": "https://api.github.com/users/hliu-ampere/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hliu-ampere", "id": 76081431, "node_id": "MDQ6VXNlcjc2MDgxNDMx", "avatar_url": "https://avatars.githubusercontent.com/u/76081431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hliu-ampere", "html_url": "https://github.com/hliu-ampere", "followers_url": "https://api.github.com/users/hliu-ampere/followers", "following_url": "https://api.github.com/users/hliu-ampere/following{/other_user}", "gists_url": "https://api.github.com/users/hliu-ampere/gists{/gist_id}", "starred_url": "https://api.github.com/users/hliu-ampere/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hliu-ampere/subscriptions", "organizations_url": "https://api.github.com/users/hliu-ampere/orgs", "repos_url": "https://api.github.com/users/hliu-ampere/repos", "events_url": "https://api.github.com/users/hliu-ampere/events{/privacy}", "received_events_url": "https://api.github.com/users/hliu-ampere/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b4e77e807e0099c3cfbf9c5b0c9e4154b9cb7a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b4e77e807e0099c3cfbf9c5b0c9e4154b9cb7a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b4e77e807e0099c3cfbf9c5b0c9e4154b9cb7a0"}], "stats": {"total": 169, "additions": 106, "deletions": 63}, "files": [{"sha": "8ee1850ac6327c32092c32a5680ba961a0818c0d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr89430-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-1.c?ref=54ecfb182bc32140722022c1d9818dee4bdc0e45", "patch": "@@ -9,4 +9,4 @@ unsigned test(unsigned k, unsigned b) {\n         return a[0]+a[1];\n }\n \n-/* { dg-final { scan-tree-dump \"Conditional store replacement\" \"cselim\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"Conditional store replacement\" \"cselim\" } } */"}, {"sha": "9b96875ac7ab24b8beaeadedfb84eda9a136b16f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr89430-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-2.c?ref=54ecfb182bc32140722022c1d9818dee4bdc0e45", "patch": "@@ -11,4 +11,4 @@ unsigned test(unsigned k, unsigned b) {\n         return a[0]+a[1];\n }\n \n-/* { dg-final { scan-tree-dump \"Conditional store replacement\" \"cselim\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"Conditional store replacement\" \"cselim\" } } */"}, {"sha": "b2d04119381341e6e8c455d5d77c93c2cac9d53a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr89430-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-5.c?ref=54ecfb182bc32140722022c1d9818dee4bdc0e45", "patch": "@@ -13,4 +13,4 @@ int test(int b, int k) {\n     return a.data[0] + a.data[1];\n }\n \n-/* { dg-final { scan-tree-dump \"Conditional store replacement\" \"cselim\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"Conditional store replacement\" \"cselim\" } } */"}, {"sha": "8d3c4f7cc6a3b75ba7c69ec5213a67f90ad6327c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr89430-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-6.c?ref=54ecfb182bc32140722022c1d9818dee4bdc0e45", "patch": "@@ -16,4 +16,4 @@ int test(int b, int k) {\n     return a.data[0].x + a.data[1].x;\n }\n \n-/* { dg-final { scan-tree-dump \"Conditional store replacement\" \"cselim\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"Conditional store replacement\" \"cselim\" } } */"}, {"sha": "c35a2afc70b96351a9660bf2f93fff477e1b446c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr89430-7-comp-ref.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-7-comp-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-7-comp-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-7-comp-ref.c?ref=54ecfb182bc32140722022c1d9818dee4bdc0e45", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-cselim-details\" } */\n+\n+typedef union {\n+  int i;\n+  float f;\n+} U;\n+\n+int foo(U *u, int b, int i)\n+{\n+  u->i = 0;\n+  if (b)\n+    u->i = i;\n+  return u->i;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Conditional store replacement\" \"cselim\" } } */"}, {"sha": "f9e66aefb1370be4b6f7ac22ef11b8ce1b90776f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr89430-8-mem-ref-size.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-8-mem-ref-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-8-mem-ref-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89430-8-mem-ref-size.c?ref=54ecfb182bc32140722022c1d9818dee4bdc0e45", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-cselim-details\" } */\n+\n+int *t;\n+\n+int f1 (int tt)\n+{\n+  int *t1 = t;\n+  *t1 = -5;\n+  if (*t1 < tt)\n+    *((unsigned *) t1) = 5;\n+  return *t1;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Conditional store replacement\" \"cselim\" } } */"}, {"sha": "a06f339f0bb0cb7735325745c8af3ab756156c3b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-17.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c?ref=54ecfb182bc32140722022c1d9818dee4bdc0e45", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+/* { dg-options \"-O2 -fdump-tree-pre-stats -fno-tree-cselim\" } */\n \n typedef union {\n   int i;"}, {"sha": "5f283890998d635cbe5f256b7bb6c1cb9b661889", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 69, "deletions": 58, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ecfb182bc32140722022c1d9818dee4bdc0e45/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=54ecfb182bc32140722022c1d9818dee4bdc0e45", "patch": "@@ -1987,26 +1987,33 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n \n    ??? We currently are very conservative and assume that a load might\n    trap even if a store doesn't (write-only memory).  This probably is\n-   overly conservative.  */\n+   overly conservative.\n \n-/* A hash-table of SSA_NAMEs, and in which basic block an MEM_REF\n-   through it was seen, which would constitute a no-trap region for\n-   same accesses.  */\n-struct name_to_bb\n+   We currently support a special case that for !TREE_ADDRESSABLE automatic\n+   variables, it could ignore whether something is a load or store because the\n+   local stack should be always writable.  */\n+\n+/* A hash-table of references (MEM_REF/ARRAY_REF/COMPONENT_REF), and in which\n+   basic block an *_REF through it was seen, which would constitute a\n+   no-trap region for same accesses.\n+\n+   Size is needed to support 2 MEM_REFs of different types, like\n+   MEM<double>(s_1) and MEM<long>(s_1), which would compare equal with\n+   OEP_ADDRESS_OF.  */\n+struct ref_to_bb\n {\n-  unsigned int ssa_name_ver;\n+  tree exp;\n+  HOST_WIDE_INT size;\n   unsigned int phase;\n-  bool store;\n-  HOST_WIDE_INT offset, size;\n   basic_block bb;\n };\n \n /* Hashtable helpers.  */\n \n-struct ssa_names_hasher : free_ptr_hash <name_to_bb>\n+struct refs_hasher : free_ptr_hash<ref_to_bb>\n {\n-  static inline hashval_t hash (const name_to_bb *);\n-  static inline bool equal (const name_to_bb *, const name_to_bb *);\n+  static inline hashval_t hash (const ref_to_bb *);\n+  static inline bool equal (const ref_to_bb *, const ref_to_bb *);\n };\n \n /* Used for quick clearing of the hash-table when we see calls.\n@@ -2016,28 +2023,29 @@ static unsigned int nt_call_phase;\n /* The hash function.  */\n \n inline hashval_t\n-ssa_names_hasher::hash (const name_to_bb *n)\n+refs_hasher::hash (const ref_to_bb *n)\n {\n-  return n->ssa_name_ver ^ (((hashval_t) n->store) << 31)\n-         ^ (n->offset << 6) ^ (n->size << 3);\n+  inchash::hash hstate;\n+  inchash::add_expr (n->exp, hstate, OEP_ADDRESS_OF);\n+  hstate.add_hwi (n->size);\n+  return hstate.end ();\n }\n \n /* The equality function of *P1 and *P2.  */\n \n inline bool\n-ssa_names_hasher::equal (const name_to_bb *n1, const name_to_bb *n2)\n+refs_hasher::equal (const ref_to_bb *n1, const ref_to_bb *n2)\n {\n-  return n1->ssa_name_ver == n2->ssa_name_ver\n-         && n1->store == n2->store\n-         && n1->offset == n2->offset\n-         && n1->size == n2->size;\n+  return operand_equal_p (n1->exp, n2->exp, OEP_ADDRESS_OF)\n+\t && n1->size == n2->size;\n }\n \n class nontrapping_dom_walker : public dom_walker\n {\n public:\n   nontrapping_dom_walker (cdi_direction direction, hash_set<tree> *ps)\n-    : dom_walker (direction), m_nontrapping (ps), m_seen_ssa_names (128) {}\n+    : dom_walker (direction), m_nontrapping (ps), m_seen_refs (128)\n+  {}\n \n   virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n@@ -2054,7 +2062,7 @@ class nontrapping_dom_walker : public dom_walker\n   hash_set<tree> *m_nontrapping;\n \n   /* The hash table for remembering what we've seen.  */\n-  hash_table<ssa_names_hasher> m_seen_ssa_names;\n+  hash_table<refs_hasher> m_seen_refs;\n };\n \n /* Called by walk_dominator_tree, when entering the block BB.  */\n@@ -2103,65 +2111,68 @@ nontrapping_dom_walker::after_dom_children (basic_block bb)\n }\n \n /* We see the expression EXP in basic block BB.  If it's an interesting\n-   expression (an MEM_REF through an SSA_NAME) possibly insert the\n-   expression into the set NONTRAP or the hash table of seen expressions.\n-   STORE is true if this expression is on the LHS, otherwise it's on\n-   the RHS.  */\n+   expression of:\n+     1) MEM_REF\n+     2) ARRAY_REF\n+     3) COMPONENT_REF\n+   possibly insert the expression into the set NONTRAP or the hash table\n+   of seen expressions.  STORE is true if this expression is on the LHS,\n+   otherwise it's on the RHS.  */\n void\n nontrapping_dom_walker::add_or_mark_expr (basic_block bb, tree exp, bool store)\n {\n   HOST_WIDE_INT size;\n \n-  if (TREE_CODE (exp) == MEM_REF\n-      && TREE_CODE (TREE_OPERAND (exp, 0)) == SSA_NAME\n-      && tree_fits_shwi_p (TREE_OPERAND (exp, 1))\n+  if ((TREE_CODE (exp) == MEM_REF || TREE_CODE (exp) == ARRAY_REF\n+       || TREE_CODE (exp) == COMPONENT_REF)\n       && (size = int_size_in_bytes (TREE_TYPE (exp))) > 0)\n     {\n-      tree name = TREE_OPERAND (exp, 0);\n-      struct name_to_bb map;\n-      name_to_bb **slot;\n-      struct name_to_bb *n2bb;\n+      struct ref_to_bb map;\n+      ref_to_bb **slot;\n+      struct ref_to_bb *r2bb;\n       basic_block found_bb = 0;\n \n-      /* Try to find the last seen MEM_REF through the same\n-         SSA_NAME, which can trap.  */\n-      map.ssa_name_ver = SSA_NAME_VERSION (name);\n-      map.phase = 0;\n-      map.bb = 0;\n-      map.store = store;\n-      map.offset = tree_to_shwi (TREE_OPERAND (exp, 1));\n-      map.size = size;\n+      if (!store)\n+\t{\n+\t  tree base = get_base_address (exp);\n+\t  /* Only record a LOAD of a local variable without address-taken, as\n+\t     the local stack is always writable.  This allows cselim on a STORE\n+\t     with a dominating LOAD.  */\n+\t  if (!auto_var_p (base) || TREE_ADDRESSABLE (base))\n+\t    return;\n+\t}\n \n-      slot = m_seen_ssa_names.find_slot (&map, INSERT);\n-      n2bb = *slot;\n-      if (n2bb && n2bb->phase >= nt_call_phase)\n-        found_bb = n2bb->bb;\n+      /* Try to find the last seen *_REF, which can trap.  */\n+      map.exp = exp;\n+      map.size = size;\n+      slot = m_seen_refs.find_slot (&map, INSERT);\n+      r2bb = *slot;\n+      if (r2bb && r2bb->phase >= nt_call_phase)\n+\tfound_bb = r2bb->bb;\n \n-      /* If we've found a trapping MEM_REF, _and_ it dominates EXP\n-         (it's in a basic block on the path from us to the dominator root)\n+      /* If we've found a trapping *_REF, _and_ it dominates EXP\n+\t (it's in a basic block on the path from us to the dominator root)\n \t then we can't trap.  */\n       if (found_bb && (((size_t)found_bb->aux) & 1) == 1)\n \t{\n \t  m_nontrapping->add (exp);\n \t}\n       else\n-        {\n+\t{\n \t  /* EXP might trap, so insert it into the hash table.  */\n-\t  if (n2bb)\n+\t  if (r2bb)\n \t    {\n-\t      n2bb->phase = nt_call_phase;\n-\t      n2bb->bb = bb;\n+\t      r2bb->phase = nt_call_phase;\n+\t      r2bb->bb = bb;\n \t    }\n \t  else\n \t    {\n-\t      n2bb = XNEW (struct name_to_bb);\n-\t      n2bb->ssa_name_ver = SSA_NAME_VERSION (name);\n-\t      n2bb->phase = nt_call_phase;\n-\t      n2bb->bb = bb;\n-\t      n2bb->store = store;\n-\t      n2bb->offset = map.offset;\n-\t      n2bb->size = size;\n-\t      *slot = n2bb;\n+\t      r2bb = XNEW (struct ref_to_bb);\n+\t      r2bb->phase = nt_call_phase;\n+\t      r2bb->bb = bb;\n+\t      r2bb->exp = exp;\n+\t      r2bb->size = size;\n+\t      *slot = r2bb;\n \t    }\n \t}\n     }"}]}