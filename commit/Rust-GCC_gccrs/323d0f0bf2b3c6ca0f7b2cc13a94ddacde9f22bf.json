{"sha": "323d0f0bf2b3c6ca0f7b2cc13a94ddacde9f22bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIzZDBmMGJmMmIzYzZjYTBmN2IyY2MxM2E5NGRkYWNkZTlmMjJiZg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@verizon.net", "date": "2005-06-04T04:31:34Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2005-06-04T04:31:34Z"}, "message": "intrinsic.texi: Add documentation for command_argument_count...\n\n2005-06-03  Jerry DeLisle <jvdelisle@verizon.net>\n\n\t* fortran/intrinsic.texi: Add documentation for\n\tcommand_argument_count, conjg, dconjg, count,\n\tcpu_time, cshift, date_and_time, dble, dfloat.\n\nFrom-SVN: r100575", "tree": {"sha": "dbbf03ee601875c8c094da082f3246b9fa1ede2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbbf03ee601875c8c094da082f3246b9fa1ede2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/323d0f0bf2b3c6ca0f7b2cc13a94ddacde9f22bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/323d0f0bf2b3c6ca0f7b2cc13a94ddacde9f22bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/323d0f0bf2b3c6ca0f7b2cc13a94ddacde9f22bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/323d0f0bf2b3c6ca0f7b2cc13a94ddacde9f22bf/comments", "author": null, "committer": null, "parents": [{"sha": "28da59e8c4f9e8f45a8d28a98f966c98304c3520", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28da59e8c4f9e8f45a8d28a98f966c98304c3520", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28da59e8c4f9e8f45a8d28a98f966c98304c3520"}], "stats": {"total": 437, "additions": 399, "deletions": 38}, "files": [{"sha": "8327b51b763b6590983ae8e34996a10023c6306f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/323d0f0bf2b3c6ca0f7b2cc13a94ddacde9f22bf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/323d0f0bf2b3c6ca0f7b2cc13a94ddacde9f22bf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=323d0f0bf2b3c6ca0f7b2cc13a94ddacde9f22bf", "patch": "@@ -1,3 +1,9 @@\n+2005-06-03  Jerry DeLisle <jvdelisle@verizon.net>\n+\n+\t* fortran/intrinsic.texi: Add documentation for\n+\tcommand_argument_count, conjg, dconjg, count,\n+\tcpu_time, cshift, date_and_time, dble, dfloat.\n+\n 2005-06-01  Roger Sayle  <roger@eyesopen.com>\n \n \t* intrinsic.c (add_conv): No longer take a \"simplify\" argument as"}, {"sha": "16b8084a27186e050051e0057aef983edf0cc8a5", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 393, "deletions": 38, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/323d0f0bf2b3c6ca0f7b2cc13a94ddacde9f22bf/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/323d0f0bf2b3c6ca0f7b2cc13a94ddacde9f22bf/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=323d0f0bf2b3c6ca0f7b2cc13a94ddacde9f22bf", "patch": "@@ -36,7 +36,7 @@ and editing.  All contributions and corrections are strongly encouraged.\n * @code{ABORT}:         ABORT,     Abort the program     \n * @code{ABS}:           ABS,       Absolute value     \n * @code{ACHAR}:         ACHAR,     Character in @acronym{ASCII} collating sequence\n-* @code{ACOS}:          ACOS,      Arccosine function\n+* @code{ACOS}:          ACOS,      Arc cosine function\n * @code{ADJUSTL}:       ADJUSTL,   Left adjust a string\n * @code{ADJUSTR}:       ADJUSTR,   Right adjust a string\n * @code{AIMAG}:         AIMAG,     Imaginary part of complex number\n@@ -60,8 +60,16 @@ and editing.  All contributions and corrections are strongly encouraged.\n * @code{CEILING}:       CEILING,   Integer ceiling function\n * @code{CHAR}:          CHAR,      Character conversion function\n * @code{CMPLX}:         CMPLX,     Complex conversion function\n+* @code{COMMAND_ARGUMENT_COUNT}: COMMAND_ARGUMENT_COUNT,  Command line argument count\n+* @code{CONJG}:         CONJG,     Complex conjugate function\n * @code{COS}:           COS,       Cosine function\n * @code{COSH}:          COSH,      Hyperbolic cosine function\n+* @code{COUNT}:         COUNT,     Count occurences of .TRUE. in an array\n+* @code{CPU_TIME}:      CPU_TIME,  CPU time subroutine\n+* @code{CSHIFT}:        CSHIFT,    Circular array shift\n+* @code{DATE_AND_TIME}: DATE_AND_TIME, Date and time subroutine\n+* @code{DBLE}:          DBLE,      Double precision conversion\n+* @code{DFLOAT}:        DFLOAT,    Double precision conversion\n * @code{ERF}:           ERF,       Error function\n * @code{ERFC}:          ERFC,      Complementary error function\n * @code{EXP}:           EXP,       Cosine function\n@@ -248,14 +256,14 @@ end program test_achar\n \n \n @node ACOS\n-@section @code{ACOS} --- Arccosine function \n+@section @code{ACOS} --- Arc cosine function \n @findex @code{ACOS} intrinsic\n @findex @code{DACOS} intrinsic\n-@cindex arccosine\n+@cindex arc cosine\n \n @table @asis\n @item @emph{Description}:\n-@code{ACOS(X)} computes the arccosine of its @var{X}.\n+@code{ACOS(X)} computes the arc cosine of @var{X}.\n \n @item @emph{Option}:\n f95, gnu\n@@ -268,7 +276,7 @@ elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be @code{REAL(*)}, and a magnitude that is\n+@item @var{X} @tab The type shall be @code{REAL(*)} with a magnitude that is\n less than one.\n @end multitable\n \n@@ -453,7 +461,7 @@ initialization expression.\n \n @item @emph{Return value}:\n The return value is of type real with the kind type parameter of the\n-argument if the optional @var{KIND} is absence; otherwise, the kind\n+argument if the optional @var{KIND} is absent; otherwise, the kind\n type parameter will be given by @var{KIND}.  If the magnitude of \n @var{X} is less than one, then @code{AINT(X)} returns zero.  If the\n magnitude is equal to or greater than one, then it returns the largest\n@@ -555,7 +563,7 @@ end program test_all\n \n @table @asis\n @item @emph{Description}:\n-@code{ALLOCATED(X)} checks the status of wether @var{X} is allocated.\n+@code{ALLOCATED(X)} checks the status of whether @var{X} is allocated.\n \n @item @emph{Option}:\n f95, gnu\n@@ -617,7 +625,7 @@ initialization expression.\n \n @item @emph{Return value}:\n The return value is of type real with the kind type parameter of the\n-argument if the optional @var{KIND} is absence; otherwise, the kind\n+argument if the optional @var{KIND} is absent; otherwise, the kind\n type parameter will be given by @var{KIND}.  If @var{X} is greater than\n zero, then @code{ANINT(X)} returns @code{AINT(X+0.5)}.  If @var{X} is\n less than or equal to zero, then return @code{AINT(X-0.5)}.\n@@ -1292,7 +1300,7 @@ end program test_btest\n \n @table @asis\n @item @emph{Description}:\n-@code{CEILING(X,[KIND])} returns the least integer greater than or equal to @var{X}.\n+@code{CEILING(X)} returns the least integer greater than or equal to @var{X}.\n \n @item @emph{Option}:\n f95, gnu\n@@ -1301,7 +1309,7 @@ f95, gnu\n elemental function\n \n @item @emph{Syntax}:\n-@code{X = CEILING(X)}\n+@code{X = CEILING(X[,KIND])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n@@ -1341,7 +1349,7 @@ f95, gnu\n elemental function\n \n @item @emph{Syntax}:\n-@code{C = CHAR(I)}\n+@code{C = CHAR(I[,KIND])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n@@ -1372,7 +1380,9 @@ end program test_char\n \n @table @asis\n @item @emph{Description}:\n-@code{CMPLX(X,[Y,KIND])} returns a complex number where @var{X} is converted to the real component.  If @var{Y} is present it is converted to the imaginary component.  If @var{Y} is not present then the imaginary component is set to\n+@code{CMPLX(X,[Y,KIND])} returns a complex number where @var{X} is converted to\n+the real component.  If @var{Y} is present it is converted to the imaginary\n+component.  If @var{Y} is not present then the imaginary component is set to\n 0.0.  If @var{X} is complex then @var{Y} must not be present.\n \n @item @emph{Option}:\n@@ -1382,13 +1392,11 @@ f95, gnu\n elemental function\n \n @item @emph{Syntax}:\n-@code{C = CMPLX(X)}\n-@code{C = CMPLX(X,Y)}\n-@code{C = CMPLX(X,Y,KIND)}\n+@code{C = CMPLX(X[,Y,KIND])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type may be @code{INTEGER(*)} or @code{REAL(*)} or @code{COMPLEX(*)}.\n+@item @var{X} @tab The type may be @code{INTEGER(*)}, @code{REAL(*)}, or @code{COMPLEX(*)}.\n @item @var{Y} @tab Optional, allowed if @var{X} is not @code{COMPLEX(*)}.  May be @code{INTEGER(*)} or @code{REAL(*)}. \n @item @var{KIND} @tab Optional scaler integer initialization expression.\n @end multitable\n@@ -1410,6 +1418,93 @@ end program test_cmplx\n \n \n \n+@node COMMAND_ARGUMENT_COUNT\n+@section @code{COMMAND_ARGUMENT_COUNT} --- Argument count function \n+@findex @code{COMMAND_ARGUMENT_COUNT} intrinsic\n+@cindex command argument count\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{COMMAND_ARGUMENT_COUNT()} returns the number of arguments passed on the\n+command line when the containing program was invoked.\n+\n+@item @emph{Option}:\n+f2003, gnu\n+\n+@item @emph{Class}:\n+non-elemental function\n+\n+@item @emph{Syntax}:\n+@code{I = COMMAND_ARGUMENT_COUNT()}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item None\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER(4)}\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_command_argument_count\n+    integer :: count\n+    count = command_argument_count()\n+    print *, count\n+end program test_command_argument_count\n+@end smallexample\n+@end table\n+\n+\n+\n+@node CONJG\n+@section @code{CONJG} --- Complex conjugate function \n+@findex @code{CONJG} intrinsic\n+@findex @code{DCONJG} intrinsic\n+@cindex complex conjugate\n+@table @asis\n+@item @emph{Description}:\n+@code{CONJG(Z)} returns the conjugate of @var{Z}.  If @var{Z} is @code{(x, y)}\n+then the result is @code{(x, -y)}\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{Z = CONJG(Z)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{Z} @tab The type shall be @code{COMPLEX(*)}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{COMPLEX(*)}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_conjg\n+    complex :: z = (2.0, 3.0)\n+    complex(8) :: dz = (2.71_8, -3.14_8)\n+    z= conjg(z)\n+    print *, z\n+    dz = dconjg(dz)\n+    print *, dz\n+end program test_conjg\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .24 .24 .24 .24\n+@item Name             @tab Argument             @tab Return type          @tab Option\n+@item @code{DCONJG(Z)} @tab @code{COMPLEX(8) Z}  @tab @code{COMPLEX(8)}    @tab gnu\n+@end multitable\n+@end table\n+\n+\n+\n @node COS\n @section @code{COS} --- Cosine function \n @findex @code{COS} intrinsic\n@@ -1438,7 +1533,7 @@ elemental function\n @end multitable\n \n @item @emph{Return value}:\n-The return value has same type and kind than @var{X}.\n+The return value has the same type and kind as @var{X}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1450,11 +1545,11 @@ end program test_cos\n \n @item @emph{Specific names}:\n @multitable @columnfractions .24 .24 .24 .24\n-@item Name            @tab Argument          @tab Return type       @tab Option\n-@item @code{DCOS(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu\n-@item @code{CCOS(X)}  @tab @code{COMPLEX(4) X}  @tab @code{COMPLEX(4)}    @tab f95, gnu\n-@item @code{ZCOS(X)}  @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu\n-@item @code{CDCOS(X)} @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu\n+@item Name            @tab Argument          @tab Return type     @tab Option\n+@item @code{DCOS(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}  @tab f95, gnu\n+@item @code{CCOS(X)}@tab @code{COMPLEX(4) X}@tab @code{COMPLEX(4)}@tab f95, gnu\n+@item @code{ZCOS(X)}@tab @code{COMPLEX(8) X}@tab @code{COMPLEX(8)}@tab f95, gnu\n+@item @code{CDCOS(X)}@tab @code{COMPLEX(8) X}@tab @code{COMPLEX(8)}@tab f95, gnu\n @end multitable\n @end table\n \n@@ -1505,6 +1600,282 @@ end program test_cosh\n \n \n \n+@node COUNT\n+@section @code{COUNT} --- Count function\n+@findex @code{COUNT} intrinsic\n+@cindex count\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{COUNT(MASK[,DIM])} counts the number of @code{.TRUE.} elements of\n+@var{MASK} along the dimension of @var{DIM}.  If @var{DIM} is omitted it is\n+taken to be @code{1}.  @var{DIM} is a scaler of type @code{INTEGER} in the\n+range of @math{1 /leq DIM /leq n)} where @math{n} is the rank of @var{MASK}.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+transformational function\n+\n+@item @emph{Syntax}:\n+@code{I = COUNT(MASK[,DIM])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{MASK} @tab The type shall be @code{LOGICAL}.\n+@item @var{DIM}  @tab The type shall be @code{INTEGER}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER} with rank equal to that of\n+@var{MASK}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_count\n+    integer, dimension(2,3) :: a, b\n+    logical, dimension(2,3) :: mask\n+    a = reshape( (/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /))\n+    b = reshape( (/ 0, 7, 3, 4, 5, 8 /), (/ 2, 3 /))\n+    print '(3i3)', a(1,:)\n+    print '(3i3)', a(2,:)\n+    print *\n+    print '(3i3)', b(1,:)\n+    print '(3i3)', b(2,:)\n+    print *\n+    mask = a.ne.b\n+    print '(3l3)', mask(1,:)\n+    print '(3l3)', mask(2,:)\n+    print *\n+    print '(3i3)', count(mask)\n+    print *\n+    print '(3i3)', count(mask, 1)\n+    print *\n+    print '(3i3)', count(mask, 2)\n+end program test_count\n+@end smallexample\n+@end table\n+\n+\n+\n+@node CPU_TIME\n+@section @code{CPU_TIME} --- CPU elapsed time in seconds\n+@findex @code{CPU_TIME} intrinsic\n+@cindex CPU_TIME\n+\n+@table @asis\n+@item @emph{Description}:\n+Returns a @code{REAL} value representing the elapsed CPU time in seconds.  This\n+is useful for testing segments of code to determine execution time.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+subroutine\n+\n+@item @emph{Syntax}:\n+@code{CPU_TIME(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be @code{REAL} with intent out.\n+@end multitable\n+\n+@item @emph{Return value}:\n+None\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_cpu_time\n+    real :: start, finish\n+    call cpu_time(start)\n+        ! put code to test here\n+    call cpu_time(finish)\n+    print '(\"Time = \",f6.3,\" seconds.\")',finish-start\n+end program test_cpu_time\n+@end smallexample\n+@end table\n+\n+\n+\n+@node CSHIFT\n+@section @code{CSHIFT} --- Circular shift function\n+@findex @code{CSHIFT} intrinsic\n+@cindex cshift intrinsic\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{CSHIFT(ARRAY, SHIFT[,DIM])} performs a circular shift on elements of\n+@var{ARRAY} along the dimension of @var{DIM}.  If @var{DIM} is omitted it is\n+taken to be @code{1}.  @var{DIM} is a scaler of type @code{INTEGER} in the\n+range of @math{1 /leq DIM /leq n)} where @math{n} is the rank of @var{ARRAY}.\n+If the rank of @var{ARRAY} is one, then all elements of @var{ARRAY} are shifted\n+by @var{SHIFT} places.  If rank is greater than one, then all complete rank one\n+sections of @var{ARRAY} along the given dimension are shifted.  Elements\n+shifted out one end of each rank one section are shifted back in the other end.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+transformational function\n+\n+@item @emph{Syntax}:\n+@code{A = CSHIFT(A, SHIFT[,DIM])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{ARRAY}  @tab May be any type, not scaler.\n+@item @var{SHIFT}  @tab The type shall be @code{INTEGER}.\n+@item @var{DIM}    @tab The type shall be @code{INTEGER}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+Returns an array of same type and rank as the @var{ARRAY} argument.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_cshift\n+    integer, dimension(3,3) :: a\n+    a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))\n+    print '(3i3)', a(1,:)\n+    print '(3i3)', a(2,:)\n+    print '(3i3)', a(3,:)    \n+    a = cshift(a, SHIFT=(/1, 2, -1/), DIM=2)\n+    print *\n+    print '(3i3)', a(1,:)\n+    print '(3i3)', a(2,:)\n+    print '(3i3)', a(3,:)\n+end program test_cshift\n+@end smallexample\n+@end table\n+\n+\n+\n+@node DATE_AND_TIME\n+@section @code{DATE_AND_TIME} --- Date and time subroutine\n+@findex @code{DATE_AND_TIME} intrinsic\n+@cindex DATE_AND_TIME\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DATE_AND_TIME(DATE, TIME, ZONE, VALUES)} gets the corresponding date and\n+time information from the real-time system clock.  @var{DATE} is\n+@code{INTENT(OUT)} and has form ccyymmdd.  @var{TIME} is @code{INTENT(OUT)} and\n+has form hhmmss.sss.  @var{ZONE} is @code{INTENT(OUT)} and has form (+-)hhmm,\n+representing the difference with respect to Coordinated Universal Time (UTC).\n+Unavailable time and date parameters return blanks.\n+\n+@var{VALUES} is @code{INTENT(OUT)} and provides the following:\n+\n+@multitable @columnfractions .15 .30 .60\n+@item @tab @code{VALUE(1)}: @tab The year\t\n+@item @tab @code{VALUE(2)}: @tab The month\n+@item @tab @code{VALUE(3)}: @tab The day of the month\n+@item @tab @code{VAlUE(4)}: @tab Time difference with UTC in minutes\n+@item @tab @code{VALUE(5)}: @tab The hour of the day\n+@item @tab @code{VALUE(6)}: @tab The minutes of the hour\n+@item @tab @code{VALUE(7)}: @tab The seconds of the minute\n+@item @tab @code{VALUE(8)}: @tab The milliseconds of the second\n+@end multitable\t    \n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL DATE_AND_TIME([DATE, TIME, ZONE, VALUES])}\n+\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{DATE}  @tab (Optional) The type shall be @code{CHARACTER(8)} or larger.\n+@item @var{TIME}  @tab (OPtional) The type shall be @code{CHARACTER(10)} or larger.\n+@item @var{ZONE}  @tab (Optional) The type shall be @code{CHARACTER(5)} or larger.\n+@item @var{VALUES}@tab (Optional) The type shall be @code{INTEGER(8)}\n+@end multitable\n+\n+@item @emph{Return value}:\n+None\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_time_and_date\n+    character(8)  :: date\n+    character(10) :: time\n+    character(5)  :: zone\n+    integer,dimension(8) :: values\n+    ! using keyword arguments\n+    call date_and_time(date,time,zone,values)\n+    call date_and_time(DATE=date,ZONE=zone)\n+    call date_and_time(TIME=time)\n+    call date_and_time(VALUES=values)\n+    print '(a,2x,a,2x,a)', date, time, zone\n+    print '(8i5))', values\n+end program test_time_and_date\n+@end smallexample\n+@end table\n+\n+\n+\n+@node DBLE\n+@section @code{DBLE} --- Double conversion function \n+@findex @code{DBLE} intrinsic\n+@cindex double conversion\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DBLE(X)} Converts @var{X} to double precision real type.\n+@code{DFLOAT} is an alias for @code{DBLE}\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{X = DBLE(X)}\n+@code{X = DFLOAT(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be @code{INTEGER(*)}, @code{REAL(*)}, or @code{COMPLEX(*)}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type double precision real.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_dble\n+    real    :: x = 2.18\n+    integer :: i = 5\n+    complex :: z = (2.3,1.14)\n+    print *, dble(x), dble(i), dfloat(z)\n+end program test_dble\n+@end smallexample\n+@end table\n+\n+\n+\n+@node DFLOAT\n+@section @code{DFLOAT} --- Double conversion function \n+@findex @code{DFLOAT} intrinsic\n+@cindex double float conversion\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DFLOAT(X)} Converts @var{X} to double precision real type.\n+@code{DFLOAT} is an alias for @code{DBLE}.  See @code{DBLE}.\n+@end table\n+\n+\n+\n @node ERF\n @section @code{ERF} --- Error function \n @findex @code{ERF} intrinsic\n@@ -1985,22 +2356,6 @@ end program test_tanh\n \n \n \n-@comment gen   command_argument_count\n-@comment \n-@comment gen   conjg\n-@comment       dconjg\n-@comment \n-@comment gen   count\n-@comment \n-@comment sub   cpu_time\n-@comment \n-@comment gen   cshift\n-@comment \n-@comment sub   date_and_time\n-@comment \n-@comment gen   dble \n-@comment       dfloat\n-@comment \n @comment gen   dcmplx\n @comment \n @comment gen   digits"}]}