{"sha": "39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkyMTFjZDU2YmQ0ZGRlNGE3OWRhZWIxNDBjNjZkMWEwYjA2ZTBhYQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-04-28T22:48:45Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-04-28T22:48:45Z"}, "message": "34th Cygnus<->FSF merge\n\nFrom-SVN: r7171", "tree": {"sha": "d6f2c6189082ff786806379da37e2a7b8c1c4a36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6f2c6189082ff786806379da37e2a7b8c1c4a36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/comments", "author": null, "committer": null, "parents": [{"sha": "42cd70b332f6e9860e54a786df9e758bc97c5726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42cd70b332f6e9860e54a786df9e758bc97c5726", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42cd70b332f6e9860e54a786df9e758bc97c5726"}], "stats": {"total": 1462, "additions": 1017, "deletions": 445}, "files": [{"sha": "6600bb011140947e33d30f83fb5319fc9dac6d6c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -1,3 +1,263 @@\n+Thu Apr 28 15:19:46 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* cp-tree.h: disable use of backend EH.\n+\n+Wed Apr 27 19:10:04 1994  Kung Hsu  (kung@mexican.cygnus.com)\n+\n+\t* decl.c (xref_tag): not to use strstr(), it's not available on\n+\tall platforms.\n+\n+Wed Apr 27 18:10:12 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* class.c (finish_struct): Resolve yet another class/pmf confusion.\n+\n+\t* call.c (build_overload_call_real): Don't take the single-function\n+\tshortcut if we're dealing with an overloaded operator.\n+\n+Wed Apr 27 17:35:37 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* search.c (get_base_distance): Search the virtual base class\n+\tbinfos, incase someone wants to convert to a real virtual base\n+\tclass.\n+\t* search.c (expand_indirect_vtbls_init): Use convert_pointer_to_real\n+\tinstead of convert_pointer_to, as it now will work.\n+\n+Wed Apr 27 15:36:49 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* cvt.c (convert_to_reference): Don't complain about casting away\n+\tconst and volatile.\n+\n+\t* typeck.c (build_unary_op): References are too lvalues.\n+\n+Wed Apr 27 13:58:05 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* class.c (override_one_vtable): We have to prepare_fresh_vtable\n+\tbefore we modify it, not after, also, we cannot reuse an old vtable,\n+\tonce we commit to a new vtable.  Implement ambiguous overrides in\n+\tvirtual bases as abstract.  Hack until we make the class\n+\till-formed.\n+\n+Wed Apr 27 01:17:08 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* parse.y (unary_expr): Expand new_placement[opt] and\n+\tnew_initializer[opt] inline.\n+\n+\t* search.c (lookup_fnfields): Don't throw away the inheritance\n+\tinformation here, either.\n+\t(compute_access): Handle static members properly.\n+\n+\t* init.c (build_member_call): Always set basetype_path, and pass it\n+\tto lookup_fnfields.\n+\n+\t* search.c (lookup_field): Deal properly with the case where\n+\txbasetype is a chain of binfos; don't throw away the inheritance\n+\tinformation.\n+\t(compute_access): protected_ok always starts out at 0.\n+\n+\t* init.c (resolve_offset_ref): Don't cast `this' to the base type\n+\tuntil we've got our basetype_path.\n+\n+\t* cp-tree.h (IS_OVERLOAD_TYPE): aggregate or enum.\n+\n+\t* cvt.c (build_up_reference): Use build_pointer_type rather than\n+\tTYPE_POINTER_TO.\n+\n+\t* call.c (convert_harshness_ansi): Call type_promotes_to for reals\n+\tas well.\n+\n+\t* cvt.c (type_promotes_to): Retain const and volatile, add\n+\tfloat->double promotion.\n+\n+\t* decl.c (grokdeclarator): Don't bash references to arrays into\n+\treferences to pointers in function parms.  Use type_promotes_to.\n+\n+Tue Apr 26 23:44:36 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\tFinish off Apr 19th work.\n+\n+\t* class.c (finish_struct_bits): Rename has_abstract_virtuals to\n+\tmight_have_abstract_virtuals.\n+\t* class.c (strictly_overrides, override_one_vtable,\n+\tmerge_overrides): New routines to handle virtual base overrides.\n+\t* class.c (finish_struct): Call merge_overrides to handle overrides\n+\tin virtual bases.\n+\n+Tue Apr 26 12:45:53 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (build_function_call): Call build_function_call_real with\n+\tLOOKUP_NORMAL.\n+\n+\t* *: Don't deal with TYPE_EXPRs.\n+\n+\t* tree.c (lvalue_p): If the type of the expression is a reference,\n+\tit's an lvalue.\n+\n+\t* cvt.c (convert_to_reference): Complain about passing const\n+\tlvalues to non-const references.\n+\t(convert_from_reference): Don't arbitrarily throw away const and\n+\tvolatile on the target type.\n+\n+\t* parse.y: Simplify and fix rules for `new'.\n+\n+\t* decl.c (grok_op_properties): operator void is illegal.\n+\n+Mon Apr 25 02:36:28 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* parse.y (components): Anonymous bitfields can still have declspecs.\n+\n+\t* decl.c (pushdecl): Postpone handling of function templates like we\n+\tdo C functions.\n+\n+\t* search.c (expand_indirect_vtbls_init): Fix infinite loop when\n+\tconvert_pointer_to fails.\n+\n+\t* call.c (compute_conversion_costs_ansi): A user-defined conversion\n+\tby itself is better than that UDC followed by standard conversions.\n+\tDon't treat integers and reals specially.\n+\n+\t* cp-tree.h: Declare flag_ansi.\n+\n+\t* typeck.c (c_expand_return): pedwarn on return in void function\n+\teven if the expression is of type void.\n+\t(build_c_cast): Don't do as much checking for casts to void.\n+\t(build_modify_expr): pedwarn about array assignment if this code\n+\twasn't generated by the compiler.\n+\n+\t* tree.c (lvalue_p): A comma expression is an lvalue if its second\n+\toperand is.\n+\n+\t* typeck.c (default_conversion): Move code for promoting enums and\n+\tints from here.\n+\t* cvt.c (type_promotes_to): To here.\n+\t* call.c (convert_harshness_ansi): Use type_promotes_to.  Also fix\n+\tpromotion semantics for reals.\n+\n+Sun Apr 24 00:47:49 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (pushdecl): Avoid redundant warning on redeclaring function\n+\twith different return type.\n+\t(decls_match): Compare return types strictly.\n+\n+Fri Apr 22 12:55:42 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* cvt.c (build_type_conversion): Do try to convert through other\n+\tpointers.  This will fail if the class defines multiple pointer\n+\tconversions.\n+\n+\t* error.c (dump_type_prefix): Print out pointers to arrays properly.\n+\t(dump_type_suffix): Ditto.  (was 'int *[]', now 'int (*)[]')\n+\n+\t* typeck.c (build_unary_op): Disallow ++/-- on pointers to\n+\tincomplete type.\n+\n+\t* decl.c (duplicate_decls): Check mismatched TREE_CODES after\n+\tchecking for shadowing a builtin.  If we're redeclaring a builtin\n+\tfunction, bash the old decl to avoid an ambiguous overload.\n+\n+\t* cvt.c (convert_to_reference): Don't force arrays to decay here.\n+\n+\t* tree.c (lvalue_p): A MODIFY_EXPR is an lvalue.\n+\n+\t* decl.c (duplicate_decls): Don't assume that the decls will have\n+\ttypes.\n+\n+\tMon Apr 18 11:35:32 1994  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t[ cp/* changes propagated from c-* changes in 940318 snapshot ]\n+\t* c-decl.c (pushdecl): Warn if type mismatch with another external decl\n+\tin a global scope.\n+\n+\tFri Apr 22 06:38:56 1994  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t* cp/typeck2.c (signature_error): Use cp_error for \"%T\".\n+\n+\tMon Apr 18 11:59:59 1994  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t[ cp/* changes propagated from c-* changes in 940415 snapshot ]\n+\t* cp/decl.c (duplicate_decls, pushdecl, builtin_function):\n+\tUse DECL_FUNCTION_CODE instead of DECL_SET_FUNCTION_CODE.\n+\n+\tMon Apr 18 11:55:18 1994  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t[ cp/* changes propagated from c-* changes in 940409 snapshot ]\n+\t* cp/decl.c (duplicate_decls): Put new type in same obstack as\n+\told ones, or permanent if old ones in different obstacks.\n+\n+\tMon Apr 18 11:48:49 1994  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t[ cp/* changes propagated from c-* changes in 940401 snapshot ]\n+\t* cp/parse.y (attrib): Handle string args as expressions,\n+\tmerging the two rules.  `mode' attribute now takes a string arg.\n+\tDelete the rule for an identifier as arg.\n+\n+\tMon Apr 18 11:24:00 1994  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t[ cp/* changes propagated from c-* changes in 940312 snapshot ]\n+\t* cp/typeck.c (pointer_int_sum): Multiplication should be done signed.\n+\t(pointer_diff): Likewise the division.\n+\n+\tSun Mar  6 19:43:39 1994  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t[ cp/* changes propagated from c-* changes in 940304 snapshot ]\n+\t* cp/decl.c (finish_decl): Issue warning for large objects,\n+\tif requested.\n+\n+\tSat Feb 19 22:20:32 1994  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t[ cp/* changes propagated from c-* changes in 940218 snapshot ]\n+\t* cp/parse.y (attrib): Handle attribute ((section (\"string\"))).\n+\t* cp/decl.c (duplicate_decls): Merge section name into new decl.\n+\n+\tTue Feb  8 09:49:17 1994  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t[ cp/* changes propagated from c-* changes in 940206 snapshot ]\n+\t* cp/typeck.c (signed_or_unsigned_type): Check for any\n+        INTEGRAL_TYPE_P not just INTEGER_TYPE.\n+\n+\tMon Dec  6 13:35:31 1993  Norbert Kiesel  (norbert@i3.INformatik.rwth-aachen.DE)\n+\n+\t* cp/decl.c (finish_enum): Start from 0 when determining precision\n+\tfor short enums.\n+\n+\tFri Dec  3 17:07:58 1993  Ralph Campbell  (ralphc@pyramid.COM)\n+\n+\t* cp/parse.y (unary_expr): Look at $1 for tree_code rather than\n+\tcasting $$.\n+\n+\tWed Nov 17 19:22:09 1993  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t* cp/typeck.c (build_binary_op_nodefault): Propagate code\n+\tfrom C front-end to optimize unsigned short division.\n+\t(build_conditional_expr): Fix bug in \"1 ? 42 : (void *) 8\".\n+\n+\tWed Nov 17 19:17:18 1993  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t* cp/call.c (convert_harshness_ansi): Given an (e.g.) char\n+\tconstant, prefer 'const char &' to 'int'.\n+\n+\tWed Feb  3 13:11:48 1993  Chip Salzenberg  (chip@fin.uucp)\n+\n+\t* cp/class.c (finish_struct_methods):  Handle multiple\n+\tconstructors in fn_fields list.\n+\n+Fri Apr 22 12:48:10 1994  Kung Hsu  (kung@mexican.cygnus.com)\n+\n+\t* class.c (finish_struct): use TYPE_DECL_SUPPRESS_DEBUG to flag\n+\ttypes not to be dumped in stabs, like types in #pragma interface.\n+\t* decl.c (init_decl_processing): use TYPE_DECL_SUPPRESS_DEBUG to\n+\tmark unknown type.\n+\n+Thu Apr 21 18:27:57 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n+\n+\t* cp-tree.h (THUNK_DELTA):  It is normally negative, so\n+\tuse signed .i variant of frame_size rather than unsigned .u.\n+\t* cp-tree.h (VTABLE_NAME_FORMAT):  If flag_vtable_thunks,\n+\tuse \"VT\" rather than \"vt\" due to binary incompatibility.\n+\t* class.c (get_vtable_name):  Use strlen of VTABLE_NAME_FORMAT,\n+\trather than sizeof, since it is now an expression.\n+\t* class.c (modify_one_vtable):  Modify to skip initial element\n+\tcontaining a count of the vtable.\n+\n Thu Apr 21 00:09:02 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* lex.c (check_newline): Force interface_unknown on main input file."}, {"sha": "62ca226904e939a60f3f68e91b01ba8115cf52c9", "filename": "gcc/cp/call.c", "status": "modified", "additions": 54, "deletions": 71, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -358,45 +358,20 @@ convert_harshness_ansi (type, parmtype, parm)\n \n       if (coder == INTEGER_TYPE || coder == ENUMERAL_TYPE)\n \t{\n-\t  if ((TREE_UNSIGNED (type) ^ TREE_UNSIGNED (parmtype))\n-\t      || codel != coder\n-\t      || TYPE_MODE (type) != TYPE_MODE (parmtype))\n+\t  if (TYPE_MAIN_VARIANT (type)\n+\t      == TYPE_MAIN_VARIANT (type_promotes_to (parmtype)))\n \t    {\n-\t      /* Make sure a value-preserving condition [from a smaller type to\n-\t\t a larger type] is preferred to a possibly value-destroying\n-\t\t standard conversion [from a larger type to a smaller type].  */\n-\t      if (TYPE_PRECISION (type) >= TYPE_PRECISION (parmtype))\n-\t\t{\n-\t\t  h.code = PROMO_CODE;\n-\t\t  /* A char, short, wchar_t, etc., should promote to an int if\n-\t\t     it can handle it, otherwise to an unsigned.  So we'll make\n-\t\t     an unsigned.  */\n-\t\t  if (type != integer_type_node)\n-\t\t    h.int_penalty = 1;\n-\t\t}\n-\t      else\n-\t\th.code = STD_CODE;\n-\t    }\n-\n-\t  /* If the three above conditions didn't trigger, we have found two\n-\t     very similar types.  On systems where they're the same size, we\n-\t     can end up here with TYPE as `long' and PARMTYPE as `int'.  Make\n-\t     sure we realize that, even though they're the same mode, we will\n-\t     have to do some sort of integral promotion on the type, since\n-\t     they're not the same.  */\n-\t  if (! comptypes (type, parmtype, 1) && h.code == 0)\n-\t    {\n-\t      /* This call to common_type will return the best type for the\n-\t\t combination.  If it matches TYPE, that means we'll be converting\n-\t\t from a so-called smaller type (in PARMTYPE) to the larger in TYPE,\n-\t\t thus an integral promotion.  Otherwise, it must be going from a\n-\t\t larger type in PARMTYPE to a smaller expected type in TYPE, so we\n-\t\t make it a standard conversion instead.  */\n-\t      if (common_type (type, parmtype) == type)\n-\t\th.code = PROMO_CODE;\n-\t      else\n-\t\th.code = STD_CODE;\n+\t      h.code = PROMO_CODE;\n+#if 0 /* What purpose does this serve?  -jason */\n+\t      /* A char, short, wchar_t, etc., should promote to an int if\n+\t\t it can handle it, otherwise to an unsigned.  So we'll make\n+\t\t an unsigned.  */\n+\t      if (type != integer_type_node)\n+\t\th.int_penalty = 1;\n+#endif\n \t    }\n+\t  else\n+\t    h.code = STD_CODE;\n \t    \n \t  return h;\n \t}\n@@ -412,9 +387,12 @@ convert_harshness_ansi (type, parmtype, parm)\n     {\n       if (coder == REAL_TYPE)\n \t{\n-\t  /* Shun converting among float, double, and long double if a\n-\t     choice exists.  */\n-\t  h.code = PROMO_CODE;\n+\t  if (TYPE_MAIN_VARIANT (type)\n+\t      == TYPE_MAIN_VARIANT (type_promotes_to (parmtype)))\n+\t    h.code = PROMO_CODE;\n+\t  else\n+\t    h.code = STD_CODE;\n+\t    \n \t  return h;\n \t}\n       else if (coder == INTEGER_TYPE || coder == ENUMERAL_TYPE)\n@@ -549,7 +527,7 @@ convert_harshness_ansi (type, parmtype, parm)\n     tree ttl, ttr;\n     register tree intype = TYPE_MAIN_VARIANT (parmtype);\n     register enum tree_code form = TREE_CODE (intype);\n-    int penalty;\n+    int penalty = 0;\n \n     if (codel == REFERENCE_TYPE || coder == REFERENCE_TYPE)\n       {\n@@ -695,7 +673,9 @@ convert_harshness_ansi (type, parmtype, parm)\n \tif (parm && codel != REFERENCE_TYPE)\n \t  {\n \t    h = convert_harshness_ansi (ttl, ttr, NULL_TREE);\n-\t    if (penalty)\n+\t    if (penalty == 2)\n+\t      h.code |= QUAL_CODE;\n+\t    else if (penalty == 4)\n \t      h.code |= STD_CODE;\n \t    h.distance = 0;\n \t    return h;\n@@ -1457,6 +1437,7 @@ compute_conversion_costs_ansi (function, tta_in, cp, arglen)\n \t    {\n \t      tree actual_type = TREE_TYPE (TREE_VALUE (tta));\n \t      tree formal_type = TREE_VALUE (ttf);\n+\t      int extra_conversions = 0;\n \n \t      dont_convert_types = 1;\n \n@@ -1484,40 +1465,41 @@ compute_conversion_costs_ansi (function, tta_in, cp, arglen)\n \t\t  if (TYPE_LANG_SPECIFIC (actual_type)\n \t\t      && TYPE_HAS_CONVERSION (actual_type))\n \t\t    {\n-\t\t      if (TREE_CODE (formal_type) == INTEGER_TYPE\n-\t\t\t  && TYPE_HAS_INT_CONVERSION (actual_type))\n-\t\t\twin++;\n-\t\t      else if (TREE_CODE (formal_type) == REAL_TYPE\n-\t\t\t       && TYPE_HAS_REAL_CONVERSION (actual_type))\n-\t\t\twin++;\n-\t\t      else\n+\t\t      tree conv;\n+\t\t      /* Don't issue warnings since we're only groping\n+\t\t\t around for the right answer, we haven't yet\n+\t\t\t committed to going with this solution.  */\n+\t\t      int old_inhibit_warnings = inhibit_warnings;\n+\n+\t\t      inhibit_warnings = 1;\n+\t\t      conv = build_type_conversion\n+\t\t\t(CALL_EXPR, TREE_VALUE (ttf), TREE_VALUE (tta), 0);\n+\t\t      inhibit_warnings = old_inhibit_warnings;\n+\n+\t\t      if (conv)\n \t\t\t{\n-\t\t\t  tree conv;\n-\t\t\t  /* Don't issue warnings since we're only groping\n-\t\t\t     around for the right answer, we haven't yet\n-\t\t\t     committed to going with this solution.  */\n-\t\t\t  int old_inhibit_warnings = inhibit_warnings;\n-\n-\t\t\t  inhibit_warnings = 1;\n-\t\t\t  conv = build_type_conversion (CALL_EXPR, TREE_VALUE (ttf), TREE_VALUE (tta), 0);\n-\t\t\t  inhibit_warnings = old_inhibit_warnings;\n-\n+\t\t\t  if (conv == error_mark_node)\n+\t\t\t    win += 2;\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      win++;\n+\t\t\t      if (TREE_CODE (conv) != CALL_EXPR)\n+\t\t\t\textra_conversions = 1;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else if (TREE_CODE (TREE_VALUE (ttf)) == REFERENCE_TYPE)\n+\t\t\t{\n+\t\t\t  conv = build_type_conversion (CALL_EXPR, formal_type,\n+\t\t\t\t\t\t\tTREE_VALUE (tta), 0);\n \t\t\t  if (conv)\n \t\t\t    {\n \t\t\t      if (conv == error_mark_node)\n \t\t\t\twin += 2;\n \t\t\t      else\n-\t\t\t\twin++;\n-\t\t\t    }\n-\t\t\t  else if (TREE_CODE (TREE_VALUE (ttf)) == REFERENCE_TYPE)\n-\t\t\t    {\n-\t\t\t      conv = build_type_conversion (CALL_EXPR, formal_type, TREE_VALUE (tta), 0);\n-\t\t\t      if (conv)\n \t\t\t\t{\n-\t\t\t\t  if (conv == error_mark_node)\n-\t\t\t\t    win += 2;\n-\t\t\t\t  else\n-\t\t\t\t    win++;\n+\t\t\t\t  win++;\n+\t\t\t\t  if (TREE_CODE (conv) != CALL_EXPR)\n+\t\t\t\t    extra_conversions = 1;\n \t\t\t\t}\n \t\t\t    }\n \t\t\t}\n@@ -1528,7 +1510,8 @@ compute_conversion_costs_ansi (function, tta_in, cp, arglen)\n \t      if (win == 1)\n \t\t{\n \t\t  user_strikes += 1;\n-\t\t  cp->v.ansi_harshness[strike_index].code = USER_CODE;\n+\t\t  cp->v.ansi_harshness[strike_index].code\n+\t\t    = USER_CODE | (extra_conversions ? STD_CODE : 0);\n \t\t  win = 0;\n \t\t}\n \t      else\n@@ -3976,7 +3959,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n       return error_mark_node;\n     }\n \n-  if (TREE_CODE (functions) == FUNCTION_DECL)\n+  if (TREE_CODE (functions) == FUNCTION_DECL && ! IDENTIFIER_OPNAME_P (fnname))\n     {\n       functions = DECL_MAIN_VARIANT (functions);\n       if (final_cp)"}, {"sha": "0807ce7cab85bd3b2752f604e412e7cc58584f0e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 221, "deletions": 23, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -503,7 +503,7 @@ get_vtable_name (type)\n      tree type;\n {\n   tree type_id = build_typename_overload (type);\n-  char *buf = (char *)alloca (sizeof (VTABLE_NAME_FORMAT)\n+  char *buf = (char *)alloca (strlen (VTABLE_NAME_FORMAT)\n \t\t\t      + IDENTIFIER_LENGTH (type_id) + 2);\n   char *ptr = IDENTIFIER_POINTER (type_id);\n   int i;\n@@ -1608,17 +1608,23 @@ finish_struct_bits (t, max_has_virtual)\n   if (n_baseclasses && max_has_virtual)\n     {\n       /* Done by `finish_struct' for classes without baseclasses.  */\n-      int has_abstract_virtuals = CLASSTYPE_ABSTRACT_VIRTUALS (t) != 0;\n+      int might_have_abstract_virtuals = CLASSTYPE_ABSTRACT_VIRTUALS (t) != 0;\n       tree binfos = TYPE_BINFO_BASETYPES (t);\n       for (i = n_baseclasses-1; i >= 0; i--)\n \t{\n-\t  has_abstract_virtuals\n+\t  might_have_abstract_virtuals\n \t    |= (CLASSTYPE_ABSTRACT_VIRTUALS (BINFO_TYPE (TREE_VEC_ELT (binfos, i))) != 0);\n-\t  if (has_abstract_virtuals)\n+\t  if (might_have_abstract_virtuals)\n \t    break;\n \t}\n-      if (has_abstract_virtuals)\n-\tCLASSTYPE_ABSTRACT_VIRTUALS (t) = get_abstract_virtuals (t);\n+      if (might_have_abstract_virtuals)\n+\t{\n+\t  /* We use error_mark_node from override_one_vtable to signal\n+\t     an artificial abstract. */\n+\t  if (CLASSTYPE_ABSTRACT_VIRTUALS (t) == error_mark_node)\n+\t    CLASSTYPE_ABSTRACT_VIRTUALS (t) = NULL_TREE;\n+\t  CLASSTYPE_ABSTRACT_VIRTUALS (t) = get_abstract_virtuals (t);\n+\t}\n     }\n \n   if (n_baseclasses)\n@@ -1809,10 +1815,12 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t    }\n \t}\n \n-      /* Constructors are handled easily in search routines.\n-\t Besides, we know we won't find any, so do not bother looking.  */\n-      if (fn_name == name && TREE_VEC_ELT (method_vec, 0) == 0)\n-\tTREE_VEC_ELT (method_vec, 0) = fn_fields;\n+      /* Constructors are handled easily in search routines.  */\n+      if (fn_name == name)\n+\t{\n+\t  DECL_CHAIN (fn_fields) = TREE_VEC_ELT (method_vec, 0);\n+\t  TREE_VEC_ELT (method_vec, 0) = fn_fields;\n+\t}\n       else\n \t{\n \t  testp = &TREE_VEC_ELT (method_vec, 0);\n@@ -2122,17 +2130,13 @@ static void\n modify_one_vtable (binfo, t, fndecl, pfn)\n      tree binfo, t, fndecl, pfn;\n {\n-  tree virtuals;\n+  tree virtuals = BINFO_VIRTUALS (binfo);\n   unsigned HOST_WIDE_INT n;\n   \n-  virtuals = BINFO_VIRTUALS (binfo);\n   n = 0;\n-  /* Skip RTTI fake object. */\n-  if (flag_dossier)\n-    {\n-      ++n;\n+  /* Skip initial vtable length field and RTTI fake object. */\n+  for (; virtuals && n < 1 + flag_dossier; n++)\n       virtuals = TREE_CHAIN (virtuals);\n-    }\n   while (virtuals)\n     {\n       tree current_fndecl = TREE_VALUE (virtuals);\n@@ -2264,6 +2268,176 @@ modify_all_vtables (t, fndecl, vfn)\n     modify_all_indirect_vtables (TYPE_BINFO (t), 1, 0, t, fndecl, vfn);\n }\n \n+/* Here, we already know that they match in every respect.\n+   All we have to check is where they had their declarations.  */\n+static int \n+strictly_overrides (fndecl1, fndecl2)\n+     tree fndecl1, fndecl2;\n+{\n+  int distance = get_base_distance (DECL_CLASS_CONTEXT (fndecl2),\n+\t\t\t\t    DECL_CLASS_CONTEXT (fndecl1),\n+\t\t\t\t    0, (tree *)0);\n+  if (distance == -2 || distance > 0)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Merge overrides for one vtable.\n+   If we want to merge in same function, we are fine.\n+   else\n+     if one has a DECL_CLASS_CONTEXT that is a parent of the\n+       other, than choose the more derived one\n+     else\n+       potentially ill-formed (see 10.3 [class.virtual])\n+       we have to check later to see if there was an\n+       override in this class.  If there was ok, if not\n+       then it is ill-formed.  (mrs)\n+\n+   We take special care to reuse a vtable, if we can.  */\n+static void\n+override_one_vtable (binfo, old, t)\n+     tree binfo, old, t;\n+{\n+  tree virtuals = BINFO_VIRTUALS (binfo);\n+  tree old_virtuals = BINFO_VIRTUALS (old);\n+  enum { REUSE_NEW, REUSE_OLD, UNDECIDED, NEITHER } choose = UNDECIDED;\n+\n+  /* If we have already committed to modifying it, then don't try and\n+     reuse another vtable. */\n+  if (BINFO_NEW_VTABLE_MARKED (binfo))\n+    choose = NEITHER;\n+\n+  /* Skip size entry. */\n+  virtuals = TREE_CHAIN (virtuals);\n+  /* Skip RTTI fake object. */\n+  if (flag_dossier)\n+    {\n+      virtuals = TREE_CHAIN (virtuals);\n+    }\n+\n+  /* Skip size entry. */\n+  old_virtuals = TREE_CHAIN (old_virtuals);\n+  /* Skip RTTI fake object. */\n+  if (flag_dossier)\n+    {\n+      old_virtuals = TREE_CHAIN (old_virtuals);\n+    }\n+\n+  while (virtuals)\n+    {\n+      tree fndecl = TREE_VALUE (virtuals);\n+      tree old_fndecl = TREE_VALUE (old_virtuals);\n+      fndecl = FNADDR_FROM_VTABLE_ENTRY (fndecl);\n+      old_fndecl = FNADDR_FROM_VTABLE_ENTRY (old_fndecl);\n+      fndecl = TREE_OPERAND (fndecl, 0);\n+      old_fndecl = TREE_OPERAND (old_fndecl, 0);\n+      /* First check to see if they are the same. */\n+      if (DECL_ASSEMBLER_NAME (fndecl) == DECL_ASSEMBLER_NAME (old_fndecl))\n+\t{\n+\t  /* No need to do anything. */\n+\t}\n+      else if (strictly_overrides (fndecl, old_fndecl))\n+\t{\n+\t  if (choose == UNDECIDED)\n+\t    choose = REUSE_NEW;\n+\t  else if (choose == REUSE_OLD)\n+\t    {\n+\t      choose = NEITHER;\n+\t      if (! BINFO_NEW_VTABLE_MARKED (binfo))\n+\t\t{\n+\t\t  prepare_fresh_vtable (binfo, t);\n+\t\t  override_one_vtable (binfo, old, t);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+      else if (strictly_overrides (old_fndecl, fndecl))\n+\t{\n+\t  if (choose == UNDECIDED)\n+\t    choose = REUSE_OLD;\n+\t  else if (choose == REUSE_NEW)\n+\t    {\n+\t      choose = NEITHER;\n+\t      if (! BINFO_NEW_VTABLE_MARKED (binfo))\n+\t\t{\n+\t\t  prepare_fresh_vtable (binfo, t);\n+\t\t  override_one_vtable (binfo, old, t);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  TREE_VALUE (virtuals) = TREE_VALUE (old_virtuals);\n+\t}\n+      else\n+\t{\n+\t  choose = NEITHER;\n+\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n+\t    {\n+\t      prepare_fresh_vtable (binfo, t);\n+\t      override_one_vtable (binfo, old, t);\n+\t      return;\n+\t    }\n+\t  {\n+\t    /* This MUST be overriden, or the class is ill-formed.  */\n+\t    /* For now, we just make it abstract.  */\n+\t    tree fndecl = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals)), 0);\n+\t    tree vfn;\n+\n+\t    fndecl = copy_node (fndecl);\n+\t    copy_lang_decl (fndecl);\n+\t    DECL_ABSTRACT_VIRTUAL_P (fndecl) = 1;\n+\t    /* Make sure we search for it later. */\n+\t    if (! CLASSTYPE_ABSTRACT_VIRTUALS (t))\n+\t      CLASSTYPE_ABSTRACT_VIRTUALS (t) = error_mark_node;\n+\n+\t    vfn = build1 (ADDR_EXPR, ptr_type_node, fndecl);\n+\t    TREE_CONSTANT (vfn) = 1;\n+\t    \n+\t    /* We can use integer_zero_node, as we will will core dump\n+\t       if this is used anyway. */\n+\t    TREE_VALUE (virtuals) = build_vtable_entry (integer_zero_node, vfn);\n+\t  }\n+\t}\n+      virtuals = TREE_CHAIN (virtuals);\n+      old_virtuals = TREE_CHAIN (old_virtuals);\n+    }\n+\n+  /* Let's reuse the old vtable. */\n+  if (choose == REUSE_OLD)\n+    {\n+      BINFO_VTABLE (binfo) = BINFO_VTABLE (old);\n+      BINFO_VIRTUALS (binfo) = BINFO_VIRTUALS (old);\n+    }\n+}\n+\n+/* Merge in overrides for virtual bases.\n+   BINFO is the hierarchy we want to modify, and OLD has the potential\n+   overrides.  */\n+static void\n+merge_overrides (binfo, old, do_self, t)\n+     tree binfo, old, t;\n+     int do_self;\n+{\n+  tree binfos = BINFO_BASETYPES (binfo);\n+  tree old_binfos = BINFO_BASETYPES (old);\n+  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+  /* Should we use something besides CLASSTYPE_VFIELDS? */\n+  if (do_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n+    {\n+      override_one_vtable (binfo, old, t);\n+    }\n+\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      tree old_base_binfo = TREE_VEC_ELT (old_binfos, i);\n+      int is_not_base_vtable =\n+\ti != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n+      if (! TREE_VIA_VIRTUAL (base_binfo))\n+\tmerge_overrides (base_binfo, old_base_binfo, is_not_base_vtable, t);\n+    }\n+}\n+\n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n    (or C++ class declaration).\n \n@@ -2802,7 +2976,8 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t      if (TREE_CODE (type) == ARRAY_TYPE)\n \t\ttype = TREE_TYPE (type);\n \n-\t      if (TYPE_LANG_SPECIFIC (type) && ! ANON_UNION_P (x))\n+\t      if (TYPE_LANG_SPECIFIC (type) && ! ANON_UNION_P (x)\n+\t\t  && ! TYPE_PTRMEMFUNC_P (type))\n \t\t{\n \t\t  /* Never let anything with uninheritable virtuals\n \t\t     make it through without complaint.  */\n@@ -3268,12 +3443,35 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \n       while (vbases)\n \t{\n+\t  /* The rtti code should do this.  (mrs) */\n \t  /* Update dossier info with offsets for virtual baseclasses.  */\n \t  if (flag_dossier && ! BINFO_NEW_VTABLE_MARKED (vbases))\n \t    prepare_fresh_vtable (vbases, t);\n-\n \t  vbases = TREE_CHAIN (vbases);\n \t}\n+\n+      {\n+\t/* Now fixup overrides of all functions in vtables from all\n+\t   direct or indirect virtual base classes.  */\n+\ttree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n+\tint i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+\tfor (i = 0; i < n_baseclasses; i++)\n+\t  {\n+\t    tree base_binfo = TREE_VEC_ELT (binfos, i);\n+\t    tree basetype = BINFO_TYPE (base_binfo);\n+\t    tree vbases;\n+\n+\t    vbases = CLASSTYPE_VBASECLASSES (basetype);\n+\t    while (vbases)\n+\t      {\n+\t\tmerge_overrides (binfo_member (BINFO_TYPE (vbases),\n+\t\t\t\t\t       CLASSTYPE_VBASECLASSES (t)),\n+\t\t\t\t vbases, 1, t);\n+\t\tvbases = TREE_CHAIN (vbases);\n+\t      }\n+\t  }\n+\t}\n     }\n \n #ifdef NOTQUITE\n@@ -3618,16 +3816,16 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t  /* Don't output full info about any type\n \t     which does not have its implementation defined here.  */\n \t  if (TYPE_VIRTUAL_P (t) && write_virtuals == 2)\n-\t    DECL_IGNORED_P (TYPE_NAME (t))\n+\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t))\n \t      = (value_member (TYPE_IDENTIFIER (t), pending_vtables) == 0);\n \t  else if (CLASSTYPE_INTERFACE_ONLY (t))\n-\t    DECL_IGNORED_P (TYPE_NAME (t)) = 1;\n+\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 1;\n \t  else if (CLASSTYPE_INTERFACE_UNKNOWN (t))\n \t    /* Only a first approximation!  */\n-\t    DECL_IGNORED_P (TYPE_NAME (t)) = 1;\n+\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 1;\n \t}\n       else if (CLASSTYPE_INTERFACE_ONLY (t))\n-\tDECL_IGNORED_P (TYPE_NAME (t)) = 1;\n+\tTYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 1;\n     }\n \n   /* Finish debugging output for this type.  */"}, {"sha": "078b69e938f04f043e0b280f8ee52364742cb06c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -275,7 +275,12 @@ extern int flag_elide_constructors;\n \n extern int flag_handle_exceptions;\n \n-/* Nonzero means recognize and handle ansi-style exception handling constructs.  */\n+/* Nonzero means handle things in ANSI, instead of GNU fashion.  */\n+\n+extern int flag_ansi;\n+\n+/* Nonzero means recognize and handle ansi-style exception handling\n+   constructs.  */\n \n extern int flag_ansi_exceptions;\n \n@@ -325,6 +330,8 @@ enum languages { lang_c, lang_cplusplus };\n #define IS_AGGR_TYPE_2(TYPE1,TYPE2) \\\n   (TREE_CODE (TYPE1) == TREE_CODE (TYPE2)\t\\\n    && IS_AGGR_TYPE (TYPE1)&IS_AGGR_TYPE (TYPE2))\n+#define IS_OVERLOAD_TYPE_CODE(t) (IS_AGGR_TYPE_CODE (t) || t == ENUMERAL_TYPE)\n+#define IS_OVERLOAD_TYPE(t) (IS_OVERLOAD_TYPE_CODE (TREE_CODE (t)))\n \n /* In a *_TYPE, nonzero means a built-in type.  */\n #define TYPE_BUILT_IN(NODE) TYPE_LANG_FLAG_6(NODE)\n@@ -1075,7 +1082,7 @@ struct lang_decl\n /* Nonzero in IDENTIFIER_NODE means that this name is overloaded, and\n    should be looked up in a non-standard way.  */\n #define TREE_OVERLOADED(NODE) (TREE_LANG_FLAG_0 (NODE))\n-#define DECL_OVERLOADED(NODE) (NOTHING)\n+#define DECL_OVERLOADED(NODE) (DECL_LANG_FLAG_4 (NODE))\n #endif\n \n /* Nonzero if this (non-TYPE)_DECL has its virtual attribute set.\n@@ -1091,7 +1098,7 @@ struct lang_decl\n \n #if 0\n /* Same, but tells if this field is private in current context.  */\n-#define DECL_PRIVATE(NODE) (DECL_LANG_FLAG_5 (NODE))\n+#define DECL_PRIVATE(NODE) NOTHING\n \n /* Same, but tells if this field is private in current context.  */\n #define DECL_PROTECTED(NODE) (DECL_LANG_FLAG_6 (NODE))\n@@ -1253,11 +1260,11 @@ struct lang_decl\n \n /* Macros for a DECL or TYPE generated from a template to indicate that it\n    was explicitly instantiated.  */\n-#define DECL_EXPLICITLY_INSTANTIATED(NODE) (DECL_LANG_FLAG_4 (NODE))\n+#define DECL_EXPLICITLY_INSTANTIATED(NODE) (DECL_LANG_FLAG_5 (NODE))\n #define CLASSTYPE_EXPLICITLY_INSTANTIATED(NODE) \\\n   (DECL_EXPLICITLY_INSTANTIATED (TYPE_NAME (NODE)))\n \n-#define THUNK_DELTA(DECL) ((DECL)->decl.frame_size.u)\n+#define THUNK_DELTA(DECL) ((DECL)->decl.frame_size.i)\n \n /* ...and for unexpanded-parameterized-type nodes.  */\n #define UPT_TEMPLATE(NODE)      TREE_PURPOSE(TYPE_VALUES(NODE))\n@@ -1442,7 +1449,7 @@ extern int current_function_parms_stored;\n #define AUTO_TEMP_NAME \"_$tmp_\"\n #define AUTO_TEMP_FORMAT \"_$tmp_%d\"\n #define VTABLE_BASE \"$vb\"\n-#define VTABLE_NAME_FORMAT \"_vt$%s\"\n+#define VTABLE_NAME_FORMAT (flag_vtable_thunks ? \"_VT$%s\" : \"_vt$%s\")\n #define VFIELD_BASE \"$vf\"\n #define VFIELD_NAME \"_vptr$\"\n #define VFIELD_NAME_FORMAT \"_vptr$%s\"\n@@ -1464,7 +1471,7 @@ extern int current_function_parms_stored;\n #define AUTO_TEMP_NAME \"_.tmp_\"\n #define AUTO_TEMP_FORMAT \"_.tmp_%d\"\n #define VTABLE_BASE \".vb\"\n-#define VTABLE_NAME_FORMAT \"_vt.%s\"\n+#define VTABLE_NAME_FORMAT (flag_vtable_thunks ? \"_VT.%s\" : \"_vt.%s\")\n #define VFIELD_BASE \".vf\"\n #define VFIELD_NAME \"_vptr.\"\n #define VFIELD_NAME_FORMAT \"_vptr.%s\"\n@@ -1493,7 +1500,7 @@ extern int current_function_parms_stored;\n #define AUTO_TEMP_FORMAT \"__tmp_%d\"\n #define VTABLE_BASE \"__vtb\"\n #define VTABLE_NAME \"__vt_\"\n-#define VTABLE_NAME_FORMAT \"__vt_%s\"\n+#define VTABLE_NAME_FORMAT (flag_vtable_thunks ? \"_VT_%s\" : \"_vt_%s\")\n #define VTABLE_NAME_P(ID_NODE) \\\n   (!strncmp (IDENTIFIER_POINTER (ID_NODE), VTABLE_NAME, \\\n \t     sizeof (VTABLE_NAME) - 1))\n@@ -1784,6 +1791,7 @@ extern tree convert_force\t\t\tPROTO((tree, tree));\n extern tree build_type_conversion\t\tPROTO((enum tree_code, tree, tree, int));\n extern int build_default_binary_type_conversion\tPROTO((enum tree_code, tree *, tree *));\n extern int build_default_unary_type_conversion\tPROTO((enum tree_code, tree *));\n+extern tree type_promotes_to\t\t\tPROTO((tree));\n \n /* decl.c */\n extern int global_bindings_p\t\t\tPROTO((void));\n@@ -2272,6 +2280,18 @@ extern void GNU_xref_assign\t\t\tPROTO((tree));\n extern void GNU_xref_hier\t\t\tPROTO((char *, char *, int, int, int));\n extern void GNU_xref_member\t\t\tPROTO((tree, tree));\n \n+#define in_try_block(X) (0)\n+#define in_exception_handler(X) (0)\n+#define expand_raise(X) (0)\n+#define expand_start_try(A,B,C) ((void)0)\n+#define expand_end_try() ((void)0)\n+#define expand_start_except(A,B) ((void)0)\n+#define expand_escape_except() (0)\n+#define expand_end_except() (NULL_TREE)\n+#define expand_catch(X) (0)\n+#define expand_catch_default() (0)\n+#define expand_end_catch() (0)\n+\n /* -- end of C++ */\n \n #endif /* not _CP_TREE_H */"}, {"sha": "bcf21c12f9f682bc4c684d163bd560ff0e5893e9", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 75, "deletions": 32, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -579,7 +579,7 @@ build_up_reference (type, arg, flags, checkconst)\n  done:\n   if (TYPE_USES_COMPLEX_INHERITANCE (argtype))\n     {\n-      TREE_TYPE (rval) = TYPE_POINTER_TO (argtype);\n+      TREE_TYPE (rval) = build_pointer_type (argtype);\n       if (flags & LOOKUP_PROTECT)\n \trval = convert_pointer_to (target_type, rval);\n       else\n@@ -618,8 +618,11 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n   register enum tree_code form = TREE_CODE (intype);\n   tree rval = NULL_TREE;\n \n+#if 0\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     type = build_pointer_type (TREE_TYPE (type));\n+#endif\n+  \n   if (form == REFERENCE_TYPE)\n     intype = TREE_TYPE (intype);\n   intype = TYPE_MAIN_VARIANT (intype);\n@@ -642,12 +645,18 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n \t     convert_for_assignment, we have to do this checking here.\n \t     FIXME: We should have a common routine between here and\n \t     convert_for_assignment.  */\n+\n+\t  tree ttl = TREE_TYPE (reftype);\n+\t  tree ttr;\n+\t  \n \t  if (form == REFERENCE_TYPE)\n-\t    {\n-\t      register tree ttl = TREE_TYPE (reftype);\n-\t      register tree ttr = TREE_TYPE (TREE_TYPE (expr));\n+\t    ttr = TREE_TYPE (TREE_TYPE (expr));\n+\t  else\n+\t    ttr = TREE_TYPE (expr);\n \n-\t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n+\t  if (! TYPE_READONLY (ttl))\n+\t    {\n+\t      if (TYPE_READONLY (ttr) && decl != NULL_TREE)\n \t\t{\n \t\t  if (fndecl)\n \t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards const\",\n@@ -656,29 +665,29 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n \t\t    cp_pedwarn (\"%s to `%T' from `%T' discards const\",\n \t\t\t\terrtype, reftype, TREE_TYPE (expr));\n \t\t}\n-\t      if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n+\t      else if (! lvalue_p (expr))\n \t\t{\n+\t\t  /* Ensure semantics of 8.4.3 */\n \t\t  if (fndecl)\n-\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards volatile\",\n+\t\t    cp_pedwarn (\"ANSI C++ forbids passing non-lvalue `%T' as argument %P of `%D' into non-const &\",\n \t\t\t\tTREE_TYPE (expr), parmnum, fndecl);\n \t\t  else\n-\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards volatile\",\n+\t\t    cp_pedwarn (\"ANSI C++ forbids %s to `%T' from non-lvalue `%T'\",\n \t\t\t\terrtype, reftype, TREE_TYPE (expr));\n \t\t}\n-\t  } else if (TREE_CODE (reftype) == REFERENCE_TYPE\n-\t\t     && ! TREE_READONLY (TREE_TYPE (reftype))\n-\t\t     && ! lvalue_p (expr))\n+\t    }\n+\t  else if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr)\n+\t\t   && decl != NULL_TREE)\n \t    {\n-\t      /* Ensure semantics of 8.4.3 */\n \t      if (fndecl)\n-\t\tcp_pedwarn (\"ANSI C++ forbids passing non-lvalue `%T' as argument %P of `%D' into non-const &\",\n+\t\tcp_pedwarn (\"passing `%T' as argument %P of `%D' discards volatile\",\n \t\t\t    TREE_TYPE (expr), parmnum, fndecl);\n \t      else\n-\t\tcp_pedwarn (\"ANSI C++ forbids %s to `%T' from non-lvalue `%T'\",\n+\t\tcp_pedwarn (\"%s to `%T' from `%T' discards volatile\",\n \t\t\t    errtype, reftype, TREE_TYPE (expr));\n \t    }\n \t}\n-\n+      \n       /* If EXPR is of aggregate type, and is really a CALL_EXPR,\n \t then we don't need to convert it to reference type if\n \t it is only being used to initialize DECL which is also\n@@ -857,7 +866,7 @@ convert_from_reference (val)\n \t  return nval;\n \t}\n \n-      nval = build1 (INDIRECT_REF, TYPE_MAIN_VARIANT (target_type), val);\n+      nval = build1 (INDIRECT_REF, target_type, val);\n \n       TREE_THIS_VOLATILE (nval) = TYPE_VOLATILE (target_type);\n       TREE_SIDE_EFFECTS (nval) = TYPE_VOLATILE (target_type);\n@@ -1459,7 +1468,7 @@ convert_force (type, expr)\n \n   if (code == REFERENCE_TYPE)\n     return fold (convert_to_reference (0, type, e, NULL_TREE, -1,\n-\t\t\t\t       NULL, -1, LOOKUP_COMPLAIN));\n+\t\t\t\t       \"casting\", -1, LOOKUP_COMPLAIN));\n   else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n     e = convert_from_reference (e);\n \n@@ -1706,19 +1715,18 @@ build_type_conversion (code, xtype, expr, for_sure)\n \n  try_pointer:\n \n-  if (type == ptr_type_node)\n+  if (TREE_CODE (type) == POINTER_TYPE && TYPE_READONLY (TREE_TYPE (type)))\n     {\n-      /* Try converting to some other pointer type\n-\t with which void* is compatible, or in situations\n-\t in which void* is appropriate (such as &&,||, and !).  */\n+      /* Try converting to some other const pointer type and then using\n+         standard conversions. */\n \n       while (TYPE_HAS_CONVERSION (basetype))\n \t{\n-\t  if (CLASSTYPE_CONVERSION (basetype, ptr_conv) != 0)\n+\t  if (CLASSTYPE_CONVERSION (basetype, constptr_conv) != 0)\n \t    {\n-\t      if (CLASSTYPE_CONVERSION (basetype, ptr_conv) == error_mark_node)\n+\t      if (CLASSTYPE_CONVERSION (basetype, constptr_conv) == error_mark_node)\n \t\treturn error_mark_node;\n-\t      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, ptr_conv));\n+\t      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, constptr_conv));\n \t      return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n \t    }\n \t  if (TYPE_BINFO_BASETYPES (basetype))\n@@ -1727,20 +1735,18 @@ build_type_conversion (code, xtype, expr, for_sure)\n \t    break;\n \t}\n     }\n-  if (TREE_CODE (type) == POINTER_TYPE\n-      && TYPE_READONLY (TREE_TYPE (type))\n-      && TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node)\n+  if (TREE_CODE (type) == POINTER_TYPE)\n     {\n-      /* Try converting to some other pointer type\n-\t with which const void* is compatible.  */\n+      /* Try converting to some other pointer type and then using standard\n+\t conversions.  */\n \n       while (TYPE_HAS_CONVERSION (basetype))\n \t{\n-\t  if (CLASSTYPE_CONVERSION (basetype, constptr_conv) != 0)\n+\t  if (CLASSTYPE_CONVERSION (basetype, ptr_conv) != 0)\n \t    {\n-\t      if (CLASSTYPE_CONVERSION (basetype, constptr_conv) == error_mark_node)\n+\t      if (CLASSTYPE_CONVERSION (basetype, ptr_conv) == error_mark_node)\n \t\treturn error_mark_node;\n-\t      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, constptr_conv));\n+\t      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, ptr_conv));\n \t      return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n \t    }\n \t  if (TYPE_BINFO_BASETYPES (basetype))\n@@ -1749,6 +1755,7 @@ build_type_conversion (code, xtype, expr, for_sure)\n \t    break;\n \t}\n     }\n+\n   /* Use the longer or shorter conversion that is appropriate.  Have\n      to check against 0 because the conversion may come from a baseclass.  */\n   if (TREE_CODE (type) == INTEGER_TYPE\n@@ -2020,3 +2027,39 @@ build_default_unary_type_conversion (code, arg)\n     }\n   return 1;\n }\n+\n+/* Implements integral promotion (4.1) and float->double promotion. */\n+tree\n+type_promotes_to (type)\n+     tree type;\n+{\n+  int constp = TYPE_READONLY (type);\n+  int volatilep = TYPE_VOLATILE (type);\n+  type = TYPE_MAIN_VARIANT (type);\n+  \n+  /* Normally convert enums to int,\n+     but convert wide enums to something wider.  */\n+  if (TREE_CODE (type) == ENUMERAL_TYPE\n+      || type == wchar_type_node)\n+    type = type_for_size (MAX (TYPE_PRECISION (type),\n+\t\t\t       TYPE_PRECISION (integer_type_node)),\n+\t\t\t  ((flag_traditional\n+\t\t\t    || (TYPE_PRECISION (type)\n+\t\t\t\t>= TYPE_PRECISION (integer_type_node)))\n+\t\t\t   && TREE_UNSIGNED (type)));\n+  else if (C_PROMOTING_INTEGER_TYPE_P (type))\n+    {\n+      /* Traditionally, unsignedness is preserved in default promotions.\n+         Otherwise, retain unsignedness if really not getting bigger.  */\n+      if (TREE_UNSIGNED (type)\n+\t  && (flag_traditional\n+\t      || TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)))\n+\ttype = unsigned_type_node;\n+      else\n+\ttype = integer_type_node;\n+    }\n+  else if (type == float_type_node)\n+    type = double_type_node;\n+\n+  return build_type_variant (type, constp, volatilep);\n+}"}, {"sha": "5af301bc68de3d83e3c59e7c2132869dbce46b1b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 115, "deletions": 102, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -1998,8 +1998,7 @@ decls_match (newdecl, olddecl)\n \t  return 0;\n \t}\n \n-      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (f1)),\n-\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (f2)), 2))\n+      if (comptypes (TREE_TYPE (f1), TREE_TYPE (f2), 1))\n \t{\n \t  if (! strict_prototypes_lang_c && DECL_LANGUAGE (olddecl) == lang_c\n \t      && p2 == NULL_TREE)\n@@ -2147,35 +2146,13 @@ duplicate_decls (newdecl, olddecl)\n \t  && TREE_CODE (TREE_TYPE (olddecl)) == ERROR_MARK))\n     types_match = 1;\n \n-  if (TREE_CODE (olddecl) != TREE_CODE (newdecl))\n-    {\n-      if ((TREE_CODE (newdecl) == FUNCTION_DECL\n-\t   && TREE_CODE (olddecl) == TEMPLATE_DECL\n-\t   && ! DECL_TEMPLATE_IS_CLASS (olddecl))\n-\t  || (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t      && TREE_CODE (newdecl) == TEMPLATE_DECL\n-\t      && ! DECL_TEMPLATE_IS_CLASS (newdecl)))\n-\treturn 0;\n-      \n-      cp_error (\"`%#D' redeclared as different kind of symbol\", newdecl);\n-      if (TREE_CODE (olddecl) == TREE_LIST)\n-\tolddecl = TREE_VALUE (olddecl);\n-      cp_error_at (\"previous declaration of `%#D'\", olddecl);\n-\n-      /* New decl is completely inconsistent with the old one =>\n-\t tell caller to replace the old one.  */\n-\n-      return 0;\n-    }\n-\n   if (flag_traditional && TREE_CODE (newdecl) == FUNCTION_DECL\n       && IDENTIFIER_IMPLICIT_DECL (DECL_ASSEMBLER_NAME (newdecl)) == olddecl)\n     /* If -traditional, avoid error for redeclaring fcn\n        after implicit decl.  */\n     ;\n   else if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t   && (DECL_BUILT_IN (olddecl)\n-\t       || DECL_BUILT_IN_NONANSI (olddecl))\n+\t   && (DECL_BUILT_IN (olddecl) || DECL_BUILT_IN_NONANSI (olddecl))\n \t   && DECL_ASSEMBLER_NAME (newdecl) == DECL_ASSEMBLER_NAME (olddecl))\n     {\n       /* If you declare a built-in or predefined function name as static,\n@@ -2188,21 +2165,38 @@ duplicate_decls (newdecl, olddecl)\n \t\t\tDECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n \t\t\tnewdecl);\n \t  /* Discard the old built-in function.  */\n-\t  return 0;\n \t}\n-      /* Likewise, if the built-in is not ansi, then programs can\n-\t override it even globally without an error.  */\n-      else if (! DECL_BUILT_IN (olddecl))\n-\tcp_warning (\"library function `%#D' declared as non-function\",\n-\t\t    newdecl);\n-\n-      if (!types_match)\n+      else if (! types_match)\n \t{\n \t  cp_warning (\"declaration of `%#D'\", newdecl);\n \t  cp_warning (\"conflicts with built-in declaration `%#D'\",\n \t\t      olddecl);\n-\t  return 0;\n \t}\n+      if (TREE_CODE (newdecl) != FUNCTION_DECL)\n+\treturn 0;\n+\n+      if (! types_match)\n+\tTREE_TYPE (olddecl) = TREE_TYPE (newdecl);\n+    }\n+  else if (TREE_CODE (olddecl) != TREE_CODE (newdecl))\n+    {\n+      if ((TREE_CODE (newdecl) == FUNCTION_DECL\n+\t   && TREE_CODE (olddecl) == TEMPLATE_DECL\n+\t   && ! DECL_TEMPLATE_IS_CLASS (olddecl))\n+\t  || (TREE_CODE (olddecl) == FUNCTION_DECL\n+\t      && TREE_CODE (newdecl) == TEMPLATE_DECL\n+\t      && ! DECL_TEMPLATE_IS_CLASS (newdecl)))\n+\treturn 0;\n+      \n+      cp_error (\"`%#D' redeclared as different kind of symbol\", newdecl);\n+      if (TREE_CODE (olddecl) == TREE_LIST)\n+\tolddecl = TREE_VALUE (olddecl);\n+      cp_error_at (\"previous declaration of `%#D'\", olddecl);\n+\n+      /* New decl is completely inconsistent with the old one =>\n+\t tell caller to replace the old one.  */\n+\n+      return 0;\n     }\n   else if (!types_match)\n     {\n@@ -2358,6 +2352,17 @@ duplicate_decls (newdecl, olddecl)\n       /* Merge the data types specified in the two decls.  */\n       tree newtype = common_type (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n \n+      /* Make sure we put the new type in the same obstack as the old ones.\n+\t If the old types are not both in the same obstack, use the permanent\n+\t one.  */\n+      if (oldtype && TYPE_OBSTACK (oldtype) == TYPE_OBSTACK (newtype))\n+\tpush_obstacks (TYPE_OBSTACK (oldtype), TYPE_OBSTACK (oldtype));\n+      else\n+\t{\n+\t  push_obstacks_nochange ();\n+\t  end_temporary_allocation ();\n+\t}\n+\n       if (TREE_CODE (newdecl) == VAR_DECL)\n \tDECL_THIS_EXTERN (newdecl) |= DECL_THIS_EXTERN (olddecl);\n       /* Do this after calling `common_type' so that default\n@@ -2413,12 +2418,22 @@ duplicate_decls (newdecl, olddecl)\n \t  DECL_SOURCE_FILE (newdecl) = DECL_SOURCE_FILE (olddecl);\n \t  DECL_SOURCE_LINE (newdecl) = DECL_SOURCE_LINE (olddecl);\n \t}\n+\n+      /* Merge the section attribute.\n+         We want to issue an error if the sections conflict but that must be\n+\t done later in decl_attributes since we are called before attributes\n+\t are assigned.  */\n+      if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n+\tDECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);\n+\n       /* Keep the old rtl since we can safely use it, unless it's the\n \t call to abort() used for abstract virtuals.  */\n       if ((DECL_LANG_SPECIFIC (olddecl)\n \t   && !DECL_ABSTRACT_VIRTUAL_P (olddecl))\n \t  || DECL_RTL (olddecl) != DECL_RTL (abort_fndecl))\n \tDECL_RTL (newdecl) = DECL_RTL (olddecl);\n+\n+      pop_obstacks ();\n     }\n   /* If cannot merge, then use the new type and qualifiers,\n      and don't preserve the old rtl.  */\n@@ -2486,7 +2501,7 @@ duplicate_decls (newdecl, olddecl)\n \t  if (DECL_BUILT_IN (olddecl))\n \t    {\n \t      DECL_BUILT_IN (newdecl) = 1;\n-\t      DECL_SET_FUNCTION_CODE (newdecl, DECL_FUNCTION_CODE (olddecl));\n+\t      DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n \t      /* If we're keeping the built-in definition, keep the rtl,\n \t\t regardless of declaration matches.  */\n \t      DECL_RTL (newdecl) = DECL_RTL (olddecl);\n@@ -2645,7 +2660,10 @@ pushdecl (x)\n       char *file;\n       int line;\n \n-      t = lookup_name_current_level (name);\n+      if (DECL_EXTERNAL (x))\n+\tt = lookup_name (name, 0);\n+      else\n+\tt = lookup_name_current_level (name);\n       if (t == error_mark_node)\n \t{\n \t  /* error_mark_node is 0 for a while during initialization!  */\n@@ -2663,7 +2681,9 @@ pushdecl (x)\n \t  file = DECL_SOURCE_FILE (t);\n \t  line = DECL_SOURCE_LINE (t);\n \n-\t  if (TREE_CODE (x) == FUNCTION_DECL && DECL_LANGUAGE (x) == lang_c\n+\t  if (((TREE_CODE (x) == FUNCTION_DECL && DECL_LANGUAGE (x) == lang_c)\n+\t       || (TREE_CODE (x) == TEMPLATE_DECL\n+\t\t   && ! DECL_TEMPLATE_IS_CLASS (x)))\n \t      && is_overloaded_fn (t))\n \t    /* don't do anything just yet */;\n \t  else if (TREE_CODE (t) != TREE_CODE (x))\n@@ -2771,8 +2791,10 @@ pushdecl (x)\n       /* Multiple external decls of the same identifier ought to match.\n \n \t We get warnings about inline functions where they are defined.\n+\t We get warnings about other functions from push_overloaded_decl.\n+\t \n \t Avoid duplicate warnings where they are used.  */\n-      if (TREE_PUBLIC (x) && !DECL_INLINE (x))\n+      if (TREE_PUBLIC (x) && TREE_CODE (x) != FUNCTION_DECL)\n \t{\n \t  tree decl;\n \n@@ -2783,11 +2805,10 @@ pushdecl (x)\n \t  else\n \t    decl = NULL_TREE;\n \n-\t  if (decl && ! comptypes (TREE_TYPE (x), TREE_TYPE (decl), 1)\n+\t  if (decl\n \t      /* If different sort of thing, we already gave an error.  */\n \t      && TREE_CODE (decl) == TREE_CODE (x)\n-\t      /* If old decl is built-in, we already warned if we should.  */\n-\t      && !DECL_BUILT_IN (decl))\n+\t      && ! comptypes (TREE_TYPE (x), TREE_TYPE (decl), 1))\n \t    {\n \t      cp_pedwarn (\"type mismatch with previous external decl\", x);\n \t      cp_pedwarn_at (\"previous external decl of `%#D'\", decl);\n@@ -2893,7 +2914,7 @@ pushdecl (x)\n \t\t  if (DECL_BUILT_IN (oldglobal))\n \t\t    {\n \t\t      DECL_BUILT_IN (x) = DECL_BUILT_IN (oldglobal);\n-\t\t      DECL_SET_FUNCTION_CODE (x, DECL_FUNCTION_CODE (oldglobal));\n+\t\t      DECL_FUNCTION_CODE (x) = DECL_FUNCTION_CODE (oldglobal);\n \t\t    }\n \t\t  /* Keep the arg types from a file-scope fcn defn.  */\n \t\t  if (TYPE_ARG_TYPES (TREE_TYPE (oldglobal)) != NULL_TREE\n@@ -4593,6 +4614,7 @@ init_decl_processing ()\n \t\t\tunknown_type_node));\n   /* Make sure the \"unknown type\" typedecl gets ignored for debug info.  */\n   DECL_IGNORED_P (decl) = 1;\n+  TYPE_DECL_SUPPRESS_DEBUG (decl) = 1;\n #endif\n   TYPE_SIZE (unknown_type_node) = TYPE_SIZE (void_type_node);\n   TYPE_ALIGN (unknown_type_node) = 1;\n@@ -4905,7 +4927,7 @@ define_function (name, type, function_code, pfn, library_name)\n   if (function_code != NOT_BUILT_IN)\n     {\n       DECL_BUILT_IN (decl) = 1;\n-      DECL_SET_FUNCTION_CODE (decl, function_code);\n+      DECL_FUNCTION_CODE (decl) = function_code;\n     }\n   return decl;\n }\n@@ -6332,6 +6354,23 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \n  finish_end:\n \n+  /* If requested, warn about definitions of large data objects.  */\n+\n+  if (warn_larger_than\n+      && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n+      && !DECL_EXTERNAL (decl))\n+    {\n+      register tree decl_size = DECL_SIZE (decl);\n+\n+      if (decl_size && TREE_CODE (decl_size) == INTEGER_CST)\n+\t{\n+\t  unsigned units = TREE_INT_CST_LOW (decl_size) / BITS_PER_UNIT;\n+\n+\t  if (units > larger_than_size)\n+\t    warning_with_decl (decl, \"size of `%s' is %u bytes\", units);\n+\t}\n+    }\n+\n   if (need_pop)\n     {\n       /* Resume permanent allocation, if not within a function.  */\n@@ -7073,17 +7112,17 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  dname = decl;\n \t  decl = NULL_TREE;\n \n-\t  /* This may just be a variable starting with __op.  */\n-\t  if (IDENTIFIER_TYPENAME_P (dname) && TREE_TYPE (dname))\n+\t  if (IDENTIFIER_OPNAME_P (dname))\n \t    {\n-\t      my_friendly_assert (flags == NO_SPECIAL, 154);\n-\t      flags = TYPENAME_FLAG;\n-\t      ctor_return_type = TREE_TYPE (dname);\n-\t      return_type = return_conversion;\n+\t      if (IDENTIFIER_TYPENAME_P (dname))\n+\t\t{\n+\t\t  my_friendly_assert (flags == NO_SPECIAL, 154);\n+\t\t  flags = TYPENAME_FLAG;\n+\t\t  ctor_return_type = TREE_TYPE (dname);\n+\t\t  return_type = return_conversion;\n+\t\t}\n+\t      name = operator_name_string (dname);\n \t    }\n-\n-\t  if (IDENTIFIER_OPNAME_P (dname))\n-\t    name = operator_name_string (dname);\n \t  else\n \t    name = IDENTIFIER_POINTER (dname);\n \t  break;\n@@ -8639,45 +8678,25 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n     if (decl_context == PARM)\n       {\n-\ttree parmtype = type;\n-\n \tif (ctype)\n \t  error (\"cannot use `::' in parameter declaration\");\n \n \t/* A parameter declared as an array of T is really a pointer to T.\n \t   One declared as a function is really a pointer to a function.\n-\t   One declared as a member is really a pointer to member.\n-\n-\t   Don't be misled by references.  */\n-\n-\tif (TREE_CODE (type) == REFERENCE_TYPE)\n-\t  type = TREE_TYPE (type);\n+\t   One declared as a member is really a pointer to member.  */\n \n \tif (TREE_CODE (type) == ARRAY_TYPE)\n \t  {\n-\t    if (parmtype == type)\n-\t      {\n-\t\t/* Transfer const-ness of array into that of type\n-\t\t   pointed to.  */\n-\t\ttype = build_pointer_type\n-\t\t  (build_type_variant (TREE_TYPE (type), constp, volatilep));\n-\t\tvolatilep = constp = 0;\n-\t      }\n-\t    else\n-\t      type = build_pointer_type (TREE_TYPE (type));\n+\t    /* Transfer const-ness of array into that of type pointed to. */\n+\t    type = build_pointer_type\n+\t      (build_type_variant (TREE_TYPE (type), constp, volatilep));\n+\t    volatilep = constp = 0;\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n \t  type = build_pointer_type (type);\n \telse if (TREE_CODE (type) == OFFSET_TYPE)\n \t  type = build_pointer_type (type);\n \n-\tif (TREE_CODE (parmtype) == REFERENCE_TYPE)\n-\t  {\n-\t    /* Transfer const-ness of reference into that of type pointed to.  */\n-\t    type = build_type_variant (build_reference_type (type), constp, volatilep);\n-\t    constp = volatilep = 0;\n-\t  }\n-\n \tdecl = build_decl (PARM_DECL, declarator, type);\n \n \tbad_specifiers (decl, \"parameter\", virtualp, quals != NULL_TREE,\n@@ -8698,28 +8717,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t   (For example, shorts and chars are passed as ints.)\n \t   When there is a prototype, this is overridden later.  */\n \n-\tDECL_ARG_TYPE (decl) = type;\n-\tif (TYPE_MAIN_VARIANT (type) == float_type_node)\n-\t  DECL_ARG_TYPE (decl) = build_type_variant (double_type_node,\n-\t\t\t\t\t\t     TYPE_READONLY (type),\n-\t\t\t\t\t\t     TYPE_VOLATILE (type));\n-\telse if (C_PROMOTING_INTEGER_TYPE_P (type))\n-\t  {\n-\t    tree argtype;\n-\n-\t    /* Retain unsignedness if traditional or if not really\n-\t       getting wider.  */\n-\t    if (TREE_UNSIGNED (type)\n-\t\t&& (flag_traditional\n-\t\t    || TYPE_PRECISION (type)\n-\t\t\t== TYPE_PRECISION (integer_type_node)))\n-\t      argtype = unsigned_type_node;\n-\t    else\n-\t      argtype = integer_type_node;\n-\t    DECL_ARG_TYPE (decl) = build_type_variant (argtype,\n-\t\t\t\t\t\t       TYPE_READONLY (type),\n-\t\t\t\t\t\t       TYPE_VOLATILE (type));\n-\t  }\n+\tDECL_ARG_TYPE (decl) = type_promotes_to (type);\n       }\n     else if (decl_context == FIELD)\n       {\n@@ -9593,6 +9591,10 @@ grok_op_properties (decl, virtualp, friendp)\n \t  || name == ansi_opname[(int) METHOD_CALL_EXPR])\n \treturn;\t\t\t/* no restrictions on args */\n \n+      if (IDENTIFIER_TYPENAME_P (name)\n+\t  && TREE_CODE (TREE_TYPE (name)) == VOID_TYPE)\n+\terror (\"void is not a valid type conversion operator\");\n+      \n       if (name == ansi_opname[(int) MODIFY_EXPR])\n \t{\n \t  tree parmtype;\n@@ -9813,8 +9815,15 @@ xref_tag (code_type_node, name, binfo, globalize)\n       /* If we know we are defining this tag, only look it up in this scope\n        * and don't try to find it as a type. */\n       xref_next_defn = 0;\n-      if (t && TYPE_CONTEXT(t) && strstr(IDENTIFIER_POINTER(name), \"::\"))\n-\tref = t;\n+      if (t && TYPE_CONTEXT(t))\n+\t{ \n+\t  extern char *index();\n+\t  char *p;\n+\t  if ((p = index(IDENTIFIER_POINTER(name), ':')) && *(p+1) == ':')\n+\t    ref = t;\n+\t  else\n+      \t    ref = lookup_tag (code, name, b, 1);\n+\t}\n       else\n       \tref = lookup_tag (code, name, b, 1);\n     }\n@@ -10220,7 +10229,11 @@ finish_enum (enumtype, values)\n \n   if (flag_short_enums)\n     {\n-      /* Determine the precision this type needs, lay it out, and define it.  */\n+      /* Determine the precision this type needs, lay it out, and define\n+         it.  */\n+\n+      /* First reset precision */\n+      TYPE_PRECISION (enumtype) = 0;\n \n       for (i = maxvalue; i; i >>= 1)\n \tTYPE_PRECISION (enumtype)++;"}, {"sha": "1fbf21aa14e511e8a84e0a69836d527d745fc8db", "filename": "gcc/cp/error.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -330,6 +330,10 @@ dump_type_prefix (t, v)\n \t      case METHOD_TYPE:\n \t\tbreak;\n \t\t\n+\t      case ARRAY_TYPE:\n+\t\tOB_PUTC2 (' ', '(');\n+\t\tbreak;\n+\n \t      case POINTER_TYPE:\n \t\t/* We don't want \"char * *\" */\n \t\tif (! (TYPE_READONLY (sub) || TYPE_VOLATILE (sub)))\n@@ -433,6 +437,8 @@ dump_type_suffix (t, v)\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n     case OFFSET_TYPE:\n+      if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\tOB_PUTC (')');\n       dump_type_suffix (TREE_TYPE (t), v);\n       break;\n "}, {"sha": "4a7d0f827fa06d6ef4d8b49260fdb4cc7ecc9e71", "filename": "gcc/cp/except.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -615,7 +615,6 @@ void\n cplus_expand_end_except (dfault)\n      tree dfault;\n {\n-  extern tree expand_end_except (); /* stmt.c.  */\n   tree decls, raised;\n \n   if (dfault == NULL_TREE)"}, {"sha": "07de74c3d119f0606990f3e3844930a8047edc9e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -1879,7 +1879,7 @@ build_member_call (cname, name, parmlist)\n \n   if (dont_use_this)\n     {\n-      basetype_path = NULL_TREE;\n+      basetype_path = TYPE_BINFO (type);\n       decl = build1 (NOP_EXPR, TYPE_POINTER_TO (type), error_mark_node);\n     }\n   else if (current_class_decl == 0)\n@@ -1903,7 +1903,7 @@ build_member_call (cname, name, parmlist)\n \n   decl = build_indirect_ref (decl, NULL_PTR);\n \n-  if (t = lookup_fnfields (TYPE_BINFO (type), method_name, 0))\n+  if (t = lookup_fnfields (basetype_path, method_name, 0))\n     return build_method_call (decl, method_name, parmlist, basetype_path,\n \t\t\t      LOOKUP_NORMAL|LOOKUP_NONVIRTUAL);\n   if (TREE_CODE (name) == IDENTIFIER_NODE\n@@ -1994,10 +1994,12 @@ build_offset_ref (cname, name)\n       return error_mark_node;\n     }\n \n+#if 0\n   if (TREE_CODE (name) == TYPE_EXPR)\n     /* Pass a TYPE_DECL to build_component_type_expr.  */\n     return build_component_type_expr (TYPE_NAME (TREE_TYPE (cname)),\n \t\t\t\t      name, NULL_TREE, 1);\n+#endif\n \n   fnfields = lookup_fnfields (TYPE_BINFO (type), name, 1);\n   fields = lookup_field (type, name, 0, 0);\n@@ -2115,7 +2117,7 @@ build_offset_ref (cname, name)\n   if (t == NULL_TREE)\n     {\n       cp_error (\"`%D' is not a member of type `%T'\", name,\n-\t\t  IDENTIFIER_TYPE_VALUE (cname));\n+\t\tIDENTIFIER_TYPE_VALUE (cname));\n       return error_mark_node;\n     }\n \n@@ -2274,13 +2276,11 @@ resolve_offset_ref (exp)\n       enum access_type access;\n \n       if (TREE_CODE (exp) == OFFSET_REF && TREE_CODE (type) == OFFSET_TYPE)\n-\t{\n-\t  basetype = TYPE_OFFSET_BASETYPE (type);\n-\t  base = convert_pointer_to (basetype, current_class_decl);\n-\t}\n+\tbasetype = TYPE_OFFSET_BASETYPE (type);\n       else\n-\tbase = current_class_decl;\n-      basetype = DECL_CONTEXT (member);\n+\tbasetype = DECL_CONTEXT (member);\n+\n+      base = current_class_decl;\n       \n       if (get_base_distance (basetype, TREE_TYPE (TREE_TYPE (base)), 0, &basetype_path) < 0)\n \t{"}, {"sha": "c61bf487deba825c6e6340b4de6c62a0d6fb1aee", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -1521,6 +1521,7 @@ hack_identifier (value, name, yychar)\n }\n \n \f\n+#if 0\n /* Given an object OF, and a type conversion operator COMPONENT\n    build a call to the conversion operator, if a call is requested,\n    or return the address (as a pointer to member function) if one is not.\n@@ -1653,6 +1654,7 @@ build_component_type_expr (of, component, basetype_path, protect)\n \t    TREE_TYPE (name));\n   return error_mark_node;\n }\n+#endif\n \f\n static char *\n thunk_printable_name (decl)"}, {"sha": "ed57b7f1c92b67c2a18d45d65c5f5125e2ba65e6", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 91, "deletions": 71, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -244,12 +244,12 @@ empty_parms ()\n %type <ttype> maybe_raises raise_identifier raise_identifiers ansi_raise_identifier ansi_raise_identifiers\n %type <ttype> component_declarator0\n %type <ttype> forhead.1 operator_name\n-%type <ttype> new object aggr\n-%type <itype> delete\n+%type <ttype> object aggr\n+%type <itype> new delete\n /* %type <ttype> primary_no_id */\n %type <ttype> nonmomentary_expr\n %type <itype> forhead.2 initdcl0 notype_initdcl0 member_init_list\n-%type <itype> .scope try ansi_try\n+%type <itype> try ansi_try\n %type <ttype> template_header template_parm_list template_parm\n %type <ttype> template_type template_arg_list template_arg\n %type <ttype> template_instantiation template_type_name tmpl.2\n@@ -262,6 +262,7 @@ empty_parms ()\n %type <ttype> qualified_type_name complete_type_name notype_identifier\n %type <ttype> complex_type_name nested_name_specifier_1\n %type <itype> nomods_initdecls nomods_initdcl0\n+%type <ttype> new_initializer new_placement\n \n /* in order to recognize aggr tags as defining and thus shadowing. */\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n@@ -1022,8 +1023,10 @@ nonnull_exprlist:\n unary_expr:\n \t  primary %prec UNARY\n \t\t{\n+#if 0\n \t\t  if (TREE_CODE ($$) == TYPE_EXPR)\n \t\t    $$ = build_component_type_expr (C_C_D, $$, NULL_TREE, 1);\n+#endif\n \t\t}\n \t/* __extension__ turns off -pedantic for following primary.  */\n \t| EXTENSION\n@@ -1039,7 +1042,7 @@ unary_expr:\n \t| '~' cast_expr\n \t\t{ $$ = build_x_unary_op (BIT_NOT_EXPR, $2); }\n \t| unop cast_expr  %prec UNARY\n-\t\t{ $$ = build_x_unary_op ((enum tree_code) $$, $2);\n+\t\t{ $$ = build_x_unary_op ($1, $2);\n \t\t  if ($1 == NEGATE_EXPR && TREE_CODE ($2) == INTEGER_CST)\n \t\t    TREE_NEGATED_INT ($$) = 1;\n \t\t  overflow_warning ($$);\n@@ -1083,41 +1086,25 @@ unary_expr:\n \t| ALIGNOF '(' type_id ')'  %prec HYPERUNARY\n \t\t{ $$ = c_alignof (groktypename ($3)); }\n \n-\t| .scope new new_type_id %prec '='\n-\t\t{ $$ = build_new ($2, $3, NULL_TREE, $$ != NULL_TREE); }\n-\t| .scope new '(' nonnull_exprlist ')' new_type_id %prec '='\n-\t\t{ $$ = build_new ($4, $6, NULL_TREE, $$ != NULL_TREE); }\n-\t| .scope new typespec '(' nonnull_exprlist ')'\n-\t\t{ $$ = build_new ($2, $3, $5, $$ != NULL_TREE); }\n-\t| .scope new typespec '(' typespec ')'\n-\t\t{ cp_error (\"`%T' is not a valid expression\", $5);\n-\t\t  $$ = error_mark_node; }\n-\t| .scope new '(' nonnull_exprlist ')' typespec '(' nonnull_exprlist ')'\n-\t\t{ $$ = build_new ($4, $6, $8, $$ != NULL_TREE); }\n-\t| .scope new typespec LEFT_RIGHT\n-\t\t{ $$ = build_new ($2, $3, NULL_TREE, $$ != NULL_TREE); }\n-\t| .scope new '(' nonnull_exprlist ')' typespec LEFT_RIGHT\n-\t\t{ $$ = build_new ($4, $6, NULL_TREE, $$ != NULL_TREE); }\n-\t| .scope new new_type_id '=' init %prec '='\n-\t\t{ $$ = build_new ($2, $3, $5, $$ != NULL_TREE); }\n-\t| .scope new '(' nonnull_exprlist ')' new_type_id '=' init %prec '='\n-\t\t{ $$ = build_new ($4, $6, $8, $$ != NULL_TREE); }\n-\t/* If you don't understand why this is illegal, read 5.3.4. (jason) */\n-\t| .scope new '(' type_id ')' '[' nonmomentary_expr ']'\n-\t\t{ \n-\t\t  tree absdcl, typename;\n-\n-\t\t  absdcl = build_parse_node (ARRAY_REF, TREE_VALUE ($4), $7);\n-\t\t  typename = build_decl_list (TREE_PURPOSE ($4), absdcl);\n-\t\t  pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type\");\n-\t\t  $$ = build_new ($2, typename, NULL_TREE, $$ != NULL_TREE);\n-\t\t}\n-\t| .scope new '(' type_id ')'\n-\t\t{ $$ = build_new ($2, groktypename ($4), NULL_TREE,\n-\t\t\t\t  $$ != NULL_TREE); }\n-\t| .scope new '(' nonnull_exprlist ')' '(' type_id ')'\n-\t\t{ $$ = build_new ($4, groktypename ($7), NULL_TREE,\n-\t\t\t\t  $$ != NULL_TREE); }\n+\t/* The %prec EMPTY's here are required by the = init initializer\n+\t   syntax extension; see below.  */\n+\t| new new_type_id %prec EMPTY\n+\t\t{ $$ = build_new (NULL_TREE, $2, NULL_TREE, $1); }\n+\t| new new_type_id new_initializer\n+\t\t{ $$ = build_new (NULL_TREE, $2, $3, $1); }\n+\t| new new_placement new_type_id %prec EMPTY\n+\t\t{ $$ = build_new ($2, $3, NULL_TREE, $1); }\n+\t| new new_placement new_type_id new_initializer\n+\t\t{ $$ = build_new ($2, $3, $4, $1); }\n+\t| new '(' type_id ')' %prec EMPTY\n+\t\t{ $$ = build_new (NULL_TREE, groktypename($3),\n+\t\t\t\t  NULL_TREE, $1); }\n+\t| new '(' type_id ')' new_initializer\n+\t\t{ $$ = build_new (NULL_TREE, groktypename($3), $5, $1); }\n+\t| new new_placement '(' type_id ')' %prec EMPTY\n+\t\t{ $$ = build_new ($2, groktypename($4), NULL_TREE, $1); }\n+\t| new new_placement '(' type_id ')' new_initializer\n+\t\t{ $$ = build_new ($2, groktypename($4), $6, $1); }\n \n \t| delete cast_expr  %prec UNARY\n \t\t{ $$ = delete_sanity ($2, NULL_TREE, 0, $1); }\n@@ -1131,6 +1118,37 @@ unary_expr:\n \t\t    yychar = YYLEX; }\n \t;\n \n+new_placement:\n+\t  '(' nonnull_exprlist ')'\n+\t\t{ $$ = $2; }\n+\t| '{' nonnull_exprlist '}'\n+\t\t{\n+\t\t  $$ = $2; \n+\t\t  pedwarn (\"old style placement syntax, use () instead\");\n+\t\t}\n+\t;\n+\n+new_initializer:\n+\t  '(' nonnull_exprlist ')'\n+\t\t{ $$ = $2; }\n+\t| LEFT_RIGHT\n+\t\t{ $$ = NULL_TREE; }\n+\t| '(' typespec ')'\n+\t\t{\n+\t\t  cp_error (\"`%T' is not a valid expression\", $2);\n+\t\t  $$ = error_mark_node;\n+\t\t}\n+\t/* GNU extension so people can use initializer lists.  Note that\n+\t   this alters the meaning of `new int = 1', which was previously\n+\t   syntactically valid but semantically invalid.  */\n+\t| '=' init\n+\t\t{\n+\t\t  if (pedantic || flag_ansi)\n+\t\t    pedwarn (\"ANSI C++ forbids initialization of new expression with `='\");\n+\t\t  $$ = $2;\n+\t\t}\n+\t;\n+\n /* This is necessary to postpone reduction of `int ((int)(int)(int))'.  */\n regcast_or_absdcl:\n \t  '(' type_id ')' %prec EMPTY\n@@ -1615,18 +1633,8 @@ primary_no_id:\n */\n \n new:\t  NEW\n-\t\t{ $$ = NULL_TREE; }\n-\t| NEW '{' nonnull_exprlist '}'\n-\t\t{\n-\t\t  $$ = $3;\n-\t\t  pedwarn (\"old style placement syntax, use () instead\");\n-\t\t}\n-\t;\n-\n-.scope:\n-\t/* empty  */\n \t\t{ $$ = 0; }\n-\t| global_scope\n+\t| global_scope NEW\n \t\t{ got_scope = NULL_TREE; $$ = 1; }\n \t;\n \n@@ -1997,46 +2005,49 @@ attribute_list\n     ;\n \n attrib\n-    : TYPE_QUAL\n-    | IDENTIFIER\n+    : identifier\n \t{ if (strcmp (IDENTIFIER_POINTER ($1), \"packed\")\n \t      && strcmp (IDENTIFIER_POINTER ($1), \"noreturn\"))\n \t    warning (\"`%s' attribute directive ignored\",\n \t\t     IDENTIFIER_POINTER ($1));\n \t  $$ = $1; }\n-    | IDENTIFIER '(' IDENTIFIER ')'\n-\t{ /* If not \"mode (m)\", then issue warning.  */\n-\t  if (strcmp (IDENTIFIER_POINTER ($1), \"mode\") != 0)\n+    | TYPE_QUAL\n+    | identifier '(' expr_no_commas ')'\n+\t{ /* If not aligned(n), section(name), or mode(name),\n+\t     then issue warning */\n+\t  if (strcmp (IDENTIFIER_POINTER ($1), \"section\") == 0\n+\t      || strcmp (IDENTIFIER_POINTER ($1), \"mode\") == 0)\n \t    {\n-\t      warning (\"`%s' attribute directive ignored\",\n-\t\t       IDENTIFIER_POINTER ($1));\n-\t      $$ = $1;\n+\t      if (TREE_CODE ($3) != STRING_CST)\n+\t\t{\n+\t\t  error (\"invalid argument in `%s' attribute\",\n+\t\t\t IDENTIFIER_POINTER ($1));\n+\t\t  $$ = $1;\n+\t\t}\n+\t      $$ = tree_cons ($1, $3, NULL_TREE);\n \t    }\n-\t  else\n-\t    $$ = tree_cons ($1, $3, NULL_TREE); }\n-    | IDENTIFIER '(' CONSTANT ')'\n-\t{ /* if not \"aligned(n)\", then issue warning */\n-\t  if (strcmp (IDENTIFIER_POINTER ($1), \"aligned\") != 0\n-\t      || TREE_CODE ($3) != INTEGER_CST)\n+\t  else if (strcmp (IDENTIFIER_POINTER ($1), \"aligned\") != 0)\n \t    {\n \t      warning (\"`%s' attribute directive ignored\",\n \t\t       IDENTIFIER_POINTER ($1));\n \t      $$ = $1;\n \t    }\n \t  else\n \t    $$ = tree_cons ($1, $3, NULL_TREE); }\n-    | IDENTIFIER '(' IDENTIFIER ',' CONSTANT ',' CONSTANT ')'\n+    | identifier '(' IDENTIFIER ',' expr_no_commas ',' expr_no_commas ')'\n \t{ /* if not \"format(...)\", then issue warning */\n-\t  if (strcmp (IDENTIFIER_POINTER ($1), \"format\") != 0\n-\t      || TREE_CODE ($5) != INTEGER_CST\n-\t      || TREE_CODE ($7) != INTEGER_CST)\n+\t  if (strcmp (IDENTIFIER_POINTER ($1), \"format\") != 0)\n \t    {\n \t      warning (\"`%s' attribute directive ignored\",\n \t\t       IDENTIFIER_POINTER ($1));\n \t      $$ = $1;\n \t    }\n \t  else\n-\t    $$ = tree_cons ($1, tree_cons ($3, tree_cons ($5, $7, NULL_TREE), NULL_TREE), NULL_TREE); }\n+\t    $$ = tree_cons ($1,\n+\t\t\t    tree_cons ($3,\n+\t\t\t\t       tree_cons ($5, $7, NULL_TREE),\n+\t\t\t\t       NULL_TREE),\n+\t\t\t    NULL_TREE); }\n     ;\n \n /* A nonempty list of identifiers, including typenames.  */\n@@ -2623,7 +2634,7 @@ notype_component_declarator0:\n \t\t  cplus_decl_attributes ($$, $4); }\n \t| ':' expr_no_commas maybe_attribute\n \t\t{ current_declspecs = $<ttype>0;\n-\t\t  $$ = grokbitfield (NULL_TREE, NULL_TREE, $2);\n+\t\t  $$ = grokbitfield (NULL_TREE, current_declspecs, $2);\n \t\t  cplus_decl_attributes ($$, $3); }\n \t;\n \n@@ -2650,7 +2661,7 @@ notype_component_declarator:\n \t\t{ $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n \t| ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokbitfield (NULL_TREE, NULL_TREE, $2);\n+\t\t{ $$ = grokbitfield (NULL_TREE, current_declspecs, $2);\n \t\t  cplus_decl_attributes ($$, $3); }\n \t;\n \n@@ -2681,6 +2692,15 @@ new_type_id:\n \t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n \t| nonempty_type_quals %prec EMPTY\n \t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n+\t/* GNU extension to allow arrays of arbitrary types with\n+\t   non-constant dimension.  */\n+\t| '(' type_id ')' '[' expr ']'\n+\t\t{\n+\t\t  if (pedantic || flag_ansi)\n+\t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n+\t\t  $$ = build_parse_node (ARRAY_REF, TREE_VALUE ($2), $5);\n+\t\t  $$ = build_decl_list (TREE_PURPOSE ($2), $$);\n+\t\t}\n \t;\n \n type_quals:"}, {"sha": "b601075821c8dafe9a2c8ff431f946f0d36c00c1", "filename": "gcc/cp/search.c", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -574,10 +574,7 @@ get_base_distance_recursive (binfo, depth, is_private, basetype_path, rval,\n    PARENT can also be a binfo, in which case that exact parent is found\n    and no other.  convert_pointer_to_real uses this functionality.\n \n-   If BINFO is a binfo, its BINFO_INHERITANCE_CHAIN will be left alone.\n-\n-   Code in prepare_fresh_vtable relies upon the path being built even\n-   when -2 is returned.  */\n+   If BINFO is a binfo, its BINFO_INHERITANCE_CHAIN will be left alone.  */\n \n int\n get_base_distance (parent, binfo, protect, path_ptr)\n@@ -633,6 +630,16 @@ get_base_distance (parent, binfo, protect, path_ptr)\n   if (rval && protect && rval_private)\n     return -3;\n \n+  /* find real virtual base classes. */\n+  if (rval == -1 && TREE_CODE (parent) == TREE_VEC\n+      && parent == binfo_member (BINFO_TYPE (parent),\n+\t\t\t\t CLASSTYPE_VBASECLASSES (type)))\n+    {\n+      BINFO_INHERITANCE_CHAIN (parent) = binfo;\n+      new_binfo = parent;\n+      rval = 1;\n+    }\n+\n   if (path_ptr)\n     *path_ptr = new_binfo;\n   return rval;\n@@ -765,6 +772,9 @@ compute_access (basetype_path, field)\n   /* Replaces static decl above.  */\n   tree previous_scope;\n #endif\n+  int static_mem =\n+    ((TREE_CODE (field) == FUNCTION_DECL && DECL_STATIC_FUNCTION_P (field))\n+     || (TREE_CODE (field) != FUNCTION_DECL && TREE_STATIC (field)));\n \n   /* The field lives in the current class.  */\n   if (BINFO_TYPE (basetype_path) == current_class_type)\n@@ -803,7 +813,7 @@ compute_access (basetype_path, field)\n     PUBLIC_RETURN;\n \n   /* Member found immediately within object.  */\n-  if (BINFO_INHERITANCE_CHAIN (basetype_path) == NULL_TREE)\n+  if (BINFO_INHERITANCE_CHAIN (basetype_path) == NULL_TREE || static_mem)\n     {\n       /* Are we (or an enclosing scope) friends with the class that has\n          FIELD? */\n@@ -822,9 +832,7 @@ compute_access (basetype_path, field)\n       else if (TREE_PROTECTED (field))\n \t{\n \t  if (current_class_type\n-\t      && ((TREE_CODE (field) != FUNCTION_DECL && TREE_STATIC (field))\n-\t\t  || (TREE_CODE (field) == FUNCTION_DECL\n-\t\t      && DECL_STATIC_FUNCTION_P (field)))\n+\t      && static_mem\n   \t      && ACCESSIBLY_DERIVED_FROM_P (context, current_class_type))\n \t    PUBLIC_RETURN;\n \t  else\n@@ -839,8 +847,7 @@ compute_access (basetype_path, field)\n   types = basetype_path;\n   via_protected = 0;\n   access = access_default;\n-  protected_ok = current_class_type\n-    && ACCESSIBLY_UNIQUELY_DERIVED_P (BINFO_TYPE (types), current_class_type);\n+  protected_ok = 0;\n \n   while (1)\n     {\n@@ -1031,15 +1038,16 @@ lookup_field (xbasetype, name, protect, want_type)\n \n   if (TREE_CODE (xbasetype) == TREE_VEC)\n     {\n-      extern struct obstack temporary_obstack;\n-      struct obstack *tmp = current_obstack;\n-      current_obstack = &temporary_obstack;\n-      basetype_path = copy_binfo (xbasetype);\n-      current_obstack = tmp;\n       type = BINFO_TYPE (xbasetype);\n+      basetype_path = xbasetype;\n     }\n   else if (IS_AGGR_TYPE_CODE (TREE_CODE (xbasetype)))\n-    basetype_path = TYPE_BINFO (xbasetype), type = xbasetype;\n+    {\n+      type = xbasetype;\n+      basetype_path = TYPE_BINFO (xbasetype);\n+      BINFO_VIA_PUBLIC (basetype_path) = 1;\n+      BINFO_INHERITANCE_CHAIN (basetype_path) = NULL_TREE;\n+    }\n   else my_friendly_abort (97);\n \n   if (CLASSTYPE_MTABLE_ENTRY (type))\n@@ -1132,14 +1140,14 @@ lookup_field (xbasetype, name, protect, want_type)\n       return rval;\n     }\n \n-  basetype_chain = CLASSTYPE_BINFO_AS_LIST (type);\n-  TREE_VIA_PUBLIC (basetype_chain) = 1;\n+  basetype_chain = build_tree_list (NULL_TREE, basetype_path);\n+  TREE_VIA_PUBLIC (basetype_chain) = TREE_VIA_PUBLIC (basetype_path);\n+  TREE_VIA_PROTECTED (basetype_chain) = TREE_VIA_PROTECTED (basetype_path);\n+  TREE_VIA_VIRTUAL (basetype_chain) = TREE_VIA_VIRTUAL (basetype_path);\n \n   /* The ambiguity check relies upon breadth first searching. */\n \n   search_stack = push_search_level (search_stack, &search_obstack);\n-  BINFO_VIA_PUBLIC (basetype_path) = 1;\n-  BINFO_INHERITANCE_CHAIN (basetype_path) = NULL_TREE;\n   binfo = basetype_path;\n   binfo_h = binfo;\n \n@@ -1579,14 +1587,24 @@ lookup_fnfields (basetype_path, name, complain)\n     }\n   rval = NULL_TREE;\n \n-  basetype_chain = CLASSTYPE_BINFO_AS_LIST (type);\n-  TREE_VIA_PUBLIC (basetype_chain) = 1;\n+  if (basetype_path == TYPE_BINFO (type))\n+    {\n+      basetype_chain = CLASSTYPE_BINFO_AS_LIST (type);\n+      TREE_VIA_PUBLIC (basetype_chain) = 1;\n+      BINFO_VIA_PUBLIC (basetype_path) = 1;\n+      BINFO_INHERITANCE_CHAIN (basetype_path) = NULL_TREE;\n+    }\n+  else\n+    {\n+      basetype_chain = build_tree_list (NULL_TREE, basetype_path);\n+      TREE_VIA_PUBLIC (basetype_chain) = TREE_VIA_PUBLIC (basetype_path);\n+      TREE_VIA_PROTECTED (basetype_chain) = TREE_VIA_PROTECTED (basetype_path);\n+      TREE_VIA_VIRTUAL (basetype_chain) = TREE_VIA_VIRTUAL (basetype_path);\n+    }\n \n   /* The ambiguity check relies upon breadth first searching. */\n \n   search_stack = push_search_level (search_stack, &search_obstack);\n-  BINFO_VIA_PUBLIC (basetype_path) = 1;\n-  BINFO_INHERITANCE_CHAIN (basetype_path) = NULL_TREE;\n   binfo = basetype_path;\n   binfo_h = binfo;\n \n@@ -2502,13 +2520,13 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr, use_computed_offsets)\n \t}\n \n       /* Initialized with vtables of type TYPE.  */\n-      while (vbases)\n+      for (; vbases; vbases = TREE_CHAIN (vbases))\n \t{\n \t  tree addr;\n \t  if (use_computed_offsets)\n \t    addr = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vbases));\n \t  else\n-\t    addr = convert_pointer_to (vbases, vbase_decl_ptr);\n+\t    addr = convert_pointer_to_real (vbases, vbase_decl_ptr);\n \t  if (addr == error_mark_node)\n \t    continue;\n \n@@ -2517,7 +2535,6 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr, use_computed_offsets)\n \t     binfos.  (in the CLASSTPE_VFIELD_PARENT sense)  */\n \t  expand_direct_vtbls_init (vbases, TYPE_BINFO (BINFO_TYPE (vbases)),\n \t\t\t\t    1, 0, addr);\n-\t  vbases = TREE_CHAIN (vbases);\n \t}\n \n       dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep);"}, {"sha": "f035d6d6c7d7bba783be373656959083f49903d2", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 55, "deletions": 52, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -38,66 +38,69 @@ lvalue_p (ref)\n   register enum tree_code code = TREE_CODE (ref);\n \n   if (language_lvalue_valid (ref))\n-    switch (code)\n-      {\n-\t/* preincrements and predecrements are valid lvals, provided\n-\t   what they refer to are valid lvals. */\n-      case PREINCREMENT_EXPR:\n-      case PREDECREMENT_EXPR:\n-      case COMPONENT_REF:\n-      case SAVE_EXPR:\n-\treturn lvalue_p (TREE_OPERAND (ref, 0));\n-\n-      case STRING_CST:\n+    {\n+      if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n \treturn 1;\n-\n-      case VAR_DECL:\n-\tif (TREE_READONLY (ref) && ! TREE_STATIC (ref)\n-\t    && DECL_LANG_SPECIFIC (ref)\n-\t    && DECL_IN_AGGR_P (ref))\n-\t  return 0;\n-      case INDIRECT_REF:\n-      case ARRAY_REF:\n-      case PARM_DECL:\n-      case RESULT_DECL:\n-      case ERROR_MARK:\n-\tif (TREE_CODE (TREE_TYPE (ref)) != FUNCTION_TYPE\n-\t    && TREE_CODE (TREE_TYPE (ref)) != METHOD_TYPE)\n+      \n+      switch (code)\n+\t{\n+\t  /* preincrements and predecrements are valid lvals, provided\n+\t     what they refer to are valid lvals. */\n+\tcase PREINCREMENT_EXPR:\n+\tcase PREDECREMENT_EXPR:\n+\tcase COMPONENT_REF:\n+\tcase SAVE_EXPR:\n+\t  return lvalue_p (TREE_OPERAND (ref, 0));\n+\n+\tcase STRING_CST:\n \t  return 1;\n-\tbreak;\n \n-      case TARGET_EXPR:\n-      case WITH_CLEANUP_EXPR:\n-\treturn 1;\n+\tcase VAR_DECL:\n+\t  if (TREE_READONLY (ref) && ! TREE_STATIC (ref)\n+\t      && DECL_LANG_SPECIFIC (ref)\n+\t      && DECL_IN_AGGR_P (ref))\n+\t    return 0;\n+\tcase INDIRECT_REF:\n+\tcase ARRAY_REF:\n+\tcase PARM_DECL:\n+\tcase RESULT_DECL:\n+\tcase ERROR_MARK:\n+\t  if (TREE_CODE (TREE_TYPE (ref)) != FUNCTION_TYPE\n+\t      && TREE_CODE (TREE_TYPE (ref)) != METHOD_TYPE)\n+\t    return 1;\n+\t  break;\n \n-      case CALL_EXPR:\n-\tif (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE\n-\t    /* unary_complex_lvalue knows how to deal with this case.  */\n-\t    || TREE_ADDRESSABLE (TREE_TYPE (ref)))\n+\tcase TARGET_EXPR:\n+\tcase WITH_CLEANUP_EXPR:\n \t  return 1;\n-\tbreak;\n \n-\t/* A currently unresolved scope ref.  */\n-      case SCOPE_REF:\n-\tmy_friendly_abort (103);\n-      case OFFSET_REF:\n-\tif (TREE_CODE (TREE_OPERAND (ref, 1)) == FUNCTION_DECL)\n-\t  return 1;\n-\treturn lvalue_p (TREE_OPERAND (ref, 0))\n-\t  && lvalue_p (TREE_OPERAND (ref, 1));\n-\tbreak;\n-\n-      case ADDR_EXPR:\n-\t/* ANSI C++ June 5 1992 WP 5.4.14.  The result of a cast to a\n-\t   reference is an lvalue.  */\n-\tif (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n+\tcase CALL_EXPR:\n+\t  /* unary_complex_lvalue knows how to deal with this case.  */\n+\t  if (TREE_ADDRESSABLE (TREE_TYPE (ref)))\n+\t    return 1;\n+\t  break;\n+\n+\t  /* A currently unresolved scope ref.  */\n+\tcase SCOPE_REF:\n+\t  my_friendly_abort (103);\n+\tcase OFFSET_REF:\n+\t  if (TREE_CODE (TREE_OPERAND (ref, 1)) == FUNCTION_DECL)\n+\t    return 1;\n+\t  return lvalue_p (TREE_OPERAND (ref, 0))\n+\t    && lvalue_p (TREE_OPERAND (ref, 1));\n+\t  break;\n+\n+\tcase COND_EXPR:\n+\t  return (lvalue_p (TREE_OPERAND (ref, 1))\n+\t\t  && lvalue_p (TREE_OPERAND (ref, 2)));\n+\n+\tcase MODIFY_EXPR:\n \t  return 1;\n-\tbreak;\n \n-      case COND_EXPR:\n-\treturn (lvalue_p (TREE_OPERAND (ref, 1))\n-\t\t&& lvalue_p (TREE_OPERAND (ref, 2)));\n-      }\n+\tcase COMPOUND_EXPR:\n+\t  return lvalue_p (TREE_OPERAND (ref, 1));\n+\t}\n+    }\n   return 0;\n }\n "}, {"sha": "9ea4408e12dae77522f03fa95a8778c89f17e244", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 56, "deletions": 48, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -1035,7 +1035,7 @@ signed_or_unsigned_type (unsignedp, type)\n      int unsignedp;\n      tree type;\n {\n-  if (TREE_CODE (type) != INTEGER_TYPE)\n+  if (! INTEGRAL_TYPE_P (type))\n     return type;\n   if (TYPE_PRECISION (type) == TYPE_PRECISION (signed_char_type_node))\n     return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n@@ -1134,9 +1134,11 @@ c_sizeof_nowarn (type)\n \n   if (TYPE_SIZE (type) == 0)\n     {\n+#if 0\n       /* ??? Tiemann, why have any diagnostic here?\n \t There is none in the corresponding function for C.  */\n       warning (\"sizeof applied to an incomplete type\");\n+#endif\n       return size_int (0);\n     }\n \n@@ -1223,27 +1225,11 @@ default_conversion (exp)\n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Leave such NOP_EXPRs, since RHS is being used in non-lvalue context.  */\n \n-  /* Normally convert enums to int,\n-     but convert wide enums to something wider.  */\n-  if (code == ENUMERAL_TYPE)\n-    {\n-      type = type_for_size (MAX (TYPE_PRECISION (type),\n-\t\t\t\t TYPE_PRECISION (integer_type_node)),\n-\t\t\t    ((flag_traditional\n-\t\t\t      || TYPE_PRECISION (type) >= TYPE_PRECISION (integer_type_node))\n-\t\t\t     && TREE_UNSIGNED (type)));\n-      return convert (type, exp);\n-    }\n-\n-  if (C_PROMOTING_INTEGER_TYPE_P (type))\n+  if (code == ENUMERAL_TYPE || code == INTEGER_TYPE)\n     {\n-      /* Traditionally, unsignedness is preserved in default promotions.\n-         Otherwise, retain unsignedness if really not getting bigger.  */\n-      if (TREE_UNSIGNED (type)\n-\t  && (flag_traditional\n-\t      || TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)))\n-\treturn convert (unsigned_type_node, exp);\n-      return convert (integer_type_node, exp);\n+      tree t = type_promotes_to (type);\n+      if (t != TYPE_MAIN_VARIANT (type))\n+\treturn convert (t, exp);\n     }\n   if (flag_traditional\n       && TYPE_MAIN_VARIANT (type) == float_type_node)\n@@ -1498,8 +1484,10 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t&& DECL_CHAIN (TREE_VALUE (component)) == NULL_TREE), 309);\n       return build (COMPONENT_REF, TREE_TYPE (component), datum, component);\n     }\n+#if 0\n   if (TREE_CODE (component) == TYPE_EXPR)\n     return build_component_type_expr (datum, component, NULL_TREE, protect);\n+#endif\n \n   if (! IS_AGGR_TYPE_CODE (code))\n     {\n@@ -1590,9 +1578,11 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\treturn build (COMPONENT_REF, unknown_type_node, datum, fndecls);\n \t    }\n \n+#if 0\n \t  if (component == ansi_opname[(int) TYPE_EXPR])\n \t    cp_error (\"`%#T' has no such type conversion operator\", basetype);\n \t  else\n+#endif\n \t    cp_error (\"`%#T' has no member named `%D'\", basetype, component);\n \t  return error_mark_node;\n \t}\n@@ -2296,7 +2286,7 @@ tree\n build_function_call (function, params)\n      tree function, params;\n {\n-  return build_function_call_real (function, params, 1, 0);\n+  return build_function_call_real (function, params, 1, LOOKUP_NORMAL);\n }\n      \n tree\n@@ -2702,17 +2692,14 @@ build_binary_op (code, arg1, arg2, convert_p)\n    multiple inheritance, and deal with pointer to member functions.  */\n \n tree\n-build_binary_op_nodefault (code, op0, op1, error_code)\n+build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n      enum tree_code code;\n-     tree op0, op1;\n+     tree orig_op0, orig_op1;\n      enum tree_code error_code;\n {\n-  tree type0 = TREE_TYPE (op0), type1 = TREE_TYPE (op1);\n-\n-  /* The expression codes of the data types of the arguments tell us\n-     whether the arguments are integers, floating, pointers, etc.  */\n-  register enum tree_code code0 = TREE_CODE (type0);\n-  register enum tree_code code1 = TREE_CODE (type1);\n+  tree op0, op1;\n+  register enum tree_code code0, code1;\n+  tree type0, type1;\n \n   /* Expression code to give to the expression when it is built.\n      Normally this is CODE, which is what the caller asked for,\n@@ -2752,6 +2739,18 @@ build_binary_op_nodefault (code, op0, op1, error_code)\n   /* Nonzero means set RESULT_TYPE to the common type of the args.  */\n   int common = 0;\n \n+  /* Apply default conversions.  */\n+  op0 = default_conversion (orig_op0);\n+  op1 = default_conversion (orig_op1);\n+\n+  type0 = TREE_TYPE (op0);\n+  type1 = TREE_TYPE (op1);\n+\n+  /* The expression codes of the data types of the arguments tell us\n+     whether the arguments are integers, floating, pointers, etc.  */\n+  code0 = TREE_CODE (type0);\n+  code1 = TREE_CODE (type1);\n+\n   /* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */\n   STRIP_TYPE_NOPS (op0);\n   STRIP_TYPE_NOPS (op1);\n@@ -3507,10 +3506,13 @@ pointer_int_sum (resultcode, ptrop, intop)\n   if (TYPE_PRECISION (TREE_TYPE (intop)) != POINTER_SIZE)\n     intop = convert (type_for_size (POINTER_SIZE, 0), intop);\n \n-  /* Replace the integer argument\n-     with a suitable product by the object size.  */\n+  /* Replace the integer argument with a suitable product by the object size.\n+     Do this multiplication as signed, then convert to the appropriate\n+     pointer type (actually unsigned integral).  */\n \n-  intop = build_binary_op (MULT_EXPR, intop, size_exp, 1);\n+  intop = convert (result_type,\n+\t\t   build_binary_op (MULT_EXPR, intop,\n+\t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n \n   /* Create the sum or difference.  */\n \n@@ -3564,7 +3566,7 @@ pointer_diff (op0, op1)\n \n   /* Do the division.  */\n \n-  result = build (EXACT_DIV_EXPR, restype, op0, op1);\n+  result = build (EXACT_DIV_EXPR, restype, op0, convert (restype, op1));\n \n   folded = fold (result);\n   if (folded == result)\n@@ -3841,12 +3843,17 @@ build_unary_op (code, xarg, noconvert)\n \tif (typecode == POINTER_TYPE)\n \t  {\n \t    enum tree_code tmp = TREE_CODE (TREE_TYPE (argtype));\n-\t    if (tmp == FUNCTION_TYPE || tmp == METHOD_TYPE\n-\t\t|| tmp == VOID_TYPE || tmp == OFFSET_TYPE)\n+\t    if (TYPE_SIZE (TREE_TYPE (argtype)) == 0)\n+\t      cp_error (\"cannot %s a pointer to incomplete type `%T'\",\n+\t\t\t((code == PREINCREMENT_EXPR\n+\t\t\t  || code == POSTINCREMENT_EXPR)\n+\t\t\t ? \"increment\" : \"decrement\"), TREE_TYPE (argtype));\n+\t    else if (tmp == FUNCTION_TYPE || tmp == METHOD_TYPE\n+\t\t     || tmp == VOID_TYPE || tmp == OFFSET_TYPE)\n \t      cp_pedwarn (\"ANSI C++ forbids %sing a pointer of type `%T'\",\n-\t\t\t    ((code == PREINCREMENT_EXPR\n-\t\t\t      || code == POSTINCREMENT_EXPR)\n-\t\t\t     ? \"increment\" : \"decrement\"), argtype);\n+\t\t\t  ((code == PREINCREMENT_EXPR\n+\t\t\t    || code == POSTINCREMENT_EXPR)\n+\t\t\t   ? \"increment\" : \"decrement\"), argtype);\n \t    inc = c_sizeof_nowarn (TREE_TYPE (argtype));\n \t  }\n \telse\n@@ -3901,12 +3908,7 @@ build_unary_op (code, xarg, noconvert)\n       /* Note that this operation never does default_conversion\n \t regardless of NOCONVERT.  */\n \n-      if (TREE_REFERENCE_EXPR (arg))\n-\t{\n-\t  error (\"references are not lvalues\");\n-\t  return error_mark_node;\n-\t}\n-      else if (typecode == REFERENCE_TYPE)\n+      if (typecode == REFERENCE_TYPE)\n \t{\n \t  arg = build1 (CONVERT_EXPR, build_pointer_type (TREE_TYPE (TREE_TYPE (arg))), arg);\n \t  TREE_REFERENCE_EXPR (arg) = 1;\n@@ -4623,7 +4625,6 @@ build_conditional_expr (ifexp, op1, op2)\n #endif\n \t}\n       result_type = type2;\n-      op1 = null_pointer_node;\n     }\n \n   if (!result_type)\n@@ -4852,7 +4853,9 @@ build_c_cast (type, expr)\n   if (TREE_READONLY_DECL_P (value))\n     value = decl_constant_value (value);\n \n-  if (TREE_TYPE (value) == NULL_TREE\n+  if (TREE_CODE (type) == VOID_TYPE)\n+    value = build1 (NOP_EXPR, type, value);\n+  else if (TREE_TYPE (value) == NULL_TREE\n       || type_unknown_p (value))\n     {\n       value = instantiate_type (type, value, 1);\n@@ -5665,6 +5668,11 @@ build_modify_expr (lhs, modifycode, rhs)\n \n   if (TREE_CODE (lhstype) == ARRAY_TYPE)\n     {\n+      /* Allow array assignment in compiler-generated code.  */\n+      if ((pedantic || flag_ansi)\n+\t  && ! DECL_SYNTHESIZED (current_function_decl))\n+\tpedwarn (\"ANSI C++ forbids assignment between arrays\");\n+\n       /* Have to wrap this in RTL_EXPR for two cases:\n \t in base or member initialization and if we\n \t are a branch of a ?: operator.  Since we\n@@ -6774,7 +6782,7 @@ c_expand_return (retval)\n \t \"may or may not return a value\" in finish_function.  */\n       returns_value = 0;\n \n-      if (TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n+      if (retval)\n \tpedwarn (\"`return' with a value, in function returning void\");\n       expand_return (retval);\n     }"}, {"sha": "fd426a4cd9e39fd5989e4dac702fe3c29253df8b", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39211cd56bd4dde4a79daeb140c66d1a0b06e0aa/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=39211cd56bd4dde4a79daeb140c66d1a0b06e0aa", "patch": "@@ -218,7 +218,7 @@ signature_error (decl, type)\n \tcp_error (\"invalid return type for function `%#D'\", decl);\n     }\n   else\n-    error (\"cannot allocate an object of signature type `%T'\", type);\n+    cp_error (\"cannot allocate an object of signature type `%T'\", type);\n }\n \n /* Print an error message for invalid use of an incomplete type."}]}