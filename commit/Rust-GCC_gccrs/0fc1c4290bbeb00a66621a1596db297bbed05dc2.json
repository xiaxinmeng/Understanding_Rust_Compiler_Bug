{"sha": "0fc1c4290bbeb00a66621a1596db297bbed05dc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZjMWM0MjkwYmJlYjAwYTY2NjIxYTE1OTZkYjI5N2JiZWQwNWRjMg==", "commit": {"author": {"name": "Nicolas Koenig", "email": "koenigni@gcc.gnu.org", "date": "2018-07-25T19:34:33Z"}, "committer": {"name": "Nicolas Koenig", "email": "koenigni@gcc.gnu.org", "date": "2018-07-25T19:34:33Z"}, "message": "re PR fortran/25829 ([F03] Asynchronous IO support)\n\n2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n\tThomas Koenig <tkoenig@gcc.gnu.org>\n\n\tPR fortran/25829\n\t* testsuite/libgomp.fortran/async_io_1.f90: Really commit.\n\t* testsuite/libgomp.fortran/async_io_2.f90: Really commit.\n\t* testsuite/libgomp.fortran/async_io_3.f90: Really commit.\n\t* testsuite/libgomp.fortran/async_io_4.f90: Really commit.\n\t* testsuite/libgomp.fortran/async_io_5.f90: Really commit.\n\t* testsuite/libgomp.fortran/async_io_6.f90: Really commit.\n\t* testsuite/libgomp.fortran/async_io_7.f90: Really commit.\n\nFrom-SVN: r262979", "tree": {"sha": "e0a43d07441999e27ae127adaf583376732f9c56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0a43d07441999e27ae127adaf583376732f9c56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fc1c4290bbeb00a66621a1596db297bbed05dc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc1c4290bbeb00a66621a1596db297bbed05dc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fc1c4290bbeb00a66621a1596db297bbed05dc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc1c4290bbeb00a66621a1596db297bbed05dc2/comments", "author": null, "committer": null, "parents": [{"sha": "b1f45884f676cd5bde92d6babac2e8d44629f5ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1f45884f676cd5bde92d6babac2e8d44629f5ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1f45884f676cd5bde92d6babac2e8d44629f5ac"}], "stats": {"total": 356, "additions": 356, "deletions": 0}, "files": [{"sha": "07721bb230ac9403a69f08a30422b1fc39d25699", "filename": "libgomp/testsuite/libgomp.fortran/async_io_1.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_1.f90?ref=0fc1c4290bbeb00a66621a1596db297bbed05dc2", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do run }\n+!TODO: Move these testcases to gfortran testsuite\n+! once compilation with pthreads is supported there\n+! Check basic functionality of async I/O\n+program main\n+  implicit none\n+  integer:: i=1, j=2, k, l\n+  real :: a, b, c, d\n+  character(3), parameter:: yes=\"yes\"\n+  character(4) :: str\n+  complex :: cc, dd\n+  integer, dimension(4):: is = [0, 1, 2, 3]\n+  integer, dimension(4):: res\n+  character(10) :: inq\n+\n+  open (10, file='a.dat', asynchronous=yes)\n+  cc = (1.5, 0.5)\n+  inquire (10,asynchronous=inq)\n+  if (inq /= \"YES\") stop 1\n+  write (10,*,asynchronous=yes) 4, 3\n+  write (10,*,asynchronous=yes) 2, 1\n+  write (10,*,asynchronous=yes) 1.0, 3.0\n+  write (10,'(A)', asynchronous=yes) 'asdf'\n+  write (10,*, asynchronous=yes) cc\n+  close (10)\n+  open (20, file='a.dat', asynchronous=yes)\n+  read (20, *, asynchronous=yes) i, j\n+  read (20, *, asynchronous=yes) k, l\n+  read (20, *, asynchronous=yes) a, b\n+  read (20,'(A4)',asynchronous=yes) str\n+  read (20,*, asynchronous=yes) dd\n+  wait (20)\n+  if (i /= 4 .or. j /= 3) stop 2\n+  if (k /= 2 .or. l /= 1) stop 3\n+  if (a /= 1.0 .or. b /= 3.0) stop 4\n+  if (str /= 'asdf') stop 5\n+  if (cc /= dd) stop 6\n+  close (20,status=\"delete\")\n+\n+  open(10, file='c.dat', asynchronous=yes) \n+  write(10, *, asynchronous=yes) is\n+  close(10)\n+  open(20, file='c.dat', asynchronous=yes) \n+  read(20, *, asynchronous=yes) res\n+  wait (20)\n+  if (any(res /= is)) stop 7\n+  close (20,status=\"delete\")\n+end program"}, {"sha": "440d46e94639920b98b25115a180c9e337a3cb93", "filename": "libgomp/testsuite/libgomp.fortran/async_io_2.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_2.f90?ref=0fc1c4290bbeb00a66621a1596db297bbed05dc2", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do  run }\n+!TODO: Move these testcases to gfortran testsuite\n+! once compilation with pthreads is supported there\n+program main\n+  implicit none\n+  integer :: i, ios\n+  character(len=100) :: iom\n+  open (10,file=\"tst.dat\")\n+  write (10,'(A4)') 'asdf'\n+  close(10)\n+  i = 234\n+  open(10,file=\"tst.dat\", asynchronous=\"yes\")\n+  read (10,'(I4)',asynchronous=\"yes\") i\n+  iom = ' '\n+  wait (10,iostat=ios,iomsg=iom)\n+  if (iom == ' ') stop 1\n+  close(10,status=\"delete\")\n+end program main"}, {"sha": "7d5124868cfcb00fdbd61d22aecd812a7386a8e8", "filename": "libgomp/testsuite/libgomp.fortran/async_io_3.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_3.f90?ref=0fc1c4290bbeb00a66621a1596db297bbed05dc2", "patch": "@@ -0,0 +1,16 @@\n+\n+!TODO: Move these testcases to gfortran testsuite\n+! once compilation with pthreads is supported there\n+! { dg-do run }\n+program main\n+  integer :: i\n+  open (10,file=\"tst.dat\")\n+  write (10,'(A4)') 'asdf'\n+  close(10)\n+  i = 234\n+  open(10,file=\"tst.dat\", asynchronous=\"yes\")\n+  read (10,'(I4)',asynchronous=\"yes\") i\n+  wait(10)\n+end program main\n+! { dg-output \"Fortran runtime error: Bad value during integer read\" }\n+! { dg-final { remote_file build delete \"tst.dat\" } }"}, {"sha": "a21ffaef4788b15a466c6d9d370fcd8b0fb2cc2d", "filename": "libgomp/testsuite/libgomp.fortran/async_io_4.f90", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_4.f90?ref=0fc1c4290bbeb00a66621a1596db297bbed05dc2", "patch": "@@ -0,0 +1,90 @@\n+! { dg-do run { target fd_truncate } }\n+!TODO: Move these testcases to gfortran testsuite\n+! once compilation with pthreads is supported there\n+\n+! Test BACKSPACE for synchronous and asynchronous I/O\n+program main\n+  \n+  integer i, n, nr\n+  real x(10), y(10)\n+\n+  ! PR libfortran/20068\n+  open (20, status='scratch', asynchronous=\"yes\")\n+  write (20,*, asynchronous=\"yes\" ) 1\n+  write (20,*, asynchronous=\"yes\") 2\n+  write (20,*, asynchronous=\"yes\") 3\n+  rewind (20)\n+  i = 41\n+  read (20,*, asynchronous=\"yes\") i\n+  wait (20)\n+  if (i .ne. 1) STOP 1\n+  write (*,*) ' '\n+  backspace (20)\n+  i = 42\n+  read (20,*, asynchronous=\"yes\") i\n+  close (20)\n+  if (i .ne. 1) STOP 2\n+\n+  ! PR libfortran/20125\n+  open (20, status='scratch', asynchronous=\"yes\")\n+  write (20,*, asynchronous=\"yes\") 7\n+  backspace (20)\n+  read (20,*, asynchronous=\"yes\") i\n+  wait (20)\n+  if (i .ne. 7) STOP 3\n+  close (20)\n+\n+  open (20, status='scratch', form='unformatted')\n+  write (20) 8\n+  backspace (20)\n+  read (20) i\n+  if (i .ne. 8) STOP 4\n+  close (20)\n+\n+  ! PR libfortran/20471\n+  do n = 1, 10\n+     x(n) = sqrt(real(n))\n+  end do\n+  open (3, form='unformatted', status='scratch')\n+  write (3) (x(n),n=1,10)\n+  backspace (3)\n+  rewind (3)\n+  read (3) (y(n),n=1,10)\n+\n+  do n = 1, 10\n+     if (abs(x(n)-y(n)) > 0.00001) STOP 5\n+  end do\n+  close (3)\n+\n+  ! PR libfortran/20156\n+  open (3, form='unformatted', status='scratch')\n+  do i = 1, 5\n+     x(1) = i\n+     write (3) n, (x(n),n=1,10)\n+  end do\n+  nr = 0\n+  rewind (3)\n+20 continue\n+  read (3,end=30,err=90) n, (x(n),n=1,10)\n+  nr = nr + 1\n+  goto 20\n+30 continue\n+  if (nr .ne. 5) STOP 6\n+\n+  do i = 1, nr+1\n+     backspace (3)\n+  end do\n+\n+  do i = 1, nr\n+     read(3,end=70,err=90) n, (x(n),n=1,10)\n+     if (abs(x(1) - i) .gt. 0.001) STOP 7\n+  end do\n+  close (3)\n+  stop\n+\n+70 continue\n+  STOP 8\n+90 continue\n+  STOP 9\n+\n+end program"}, {"sha": "916e78aa001da3c94e73ec483d38628c5b5dbb7c", "filename": "libgomp/testsuite/libgomp.fortran/async_io_5.f90", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_5.f90?ref=0fc1c4290bbeb00a66621a1596db297bbed05dc2", "patch": "@@ -0,0 +1,132 @@\n+! { dg-do run }\n+!TODO: Move these testcases to gfortran testsuite\n+! once compilation with pthreads is supported there\n+! PR55818 Reading a REAL from a file which doesn't end in a new line fails\n+! Test case from PR reporter.\n+implicit none\n+integer :: stat\n+!integer :: var ! << works\n+real    :: var ! << fails\n+character(len=10)    :: cvar ! << fails\n+complex :: cval\n+logical :: lvar\n+\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"1\", new_line(\"\")\n+write(99) \"2\", new_line(\"\")\n+write(99) \"3\"\n+close(99)\n+\n+! Test character kind\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) cvar\n+if (stat /= 0 .or. cvar /= \"1\") STOP 1\n+read (99,*, iostat=stat) cvar\n+if (stat /= 0 .or. cvar /= \"2\") STOP 2\n+read (99,*, iostat=stat) cvar              ! << FAILS: stat /= 0\n+if (stat /= 0 .or. cvar /= \"3\") STOP 3 ! << aborts here\n+\n+! Test real kind\n+rewind(99)\n+read (99,*, iostat=stat) var\n+if (stat /= 0 .or. var /= 1.0) STOP 4\n+read (99,*, iostat=stat) var\n+if (stat /= 0 .or. var /= 2.0) STOP 5\n+read (99,*, iostat=stat) var ! << FAILS: stat /= 0\n+if (stat /= 0 .or. var /= 3.0) STOP 6\n+close(99, status=\"delete\")\n+\n+! Test real kind with exponents\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"1.0e3\", new_line(\"\")\n+write(99) \"2.0e-03\", new_line(\"\")\n+write(99) \"3.0e2\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) var\n+if (stat /= 0) STOP 7\n+read (99,*, iostat=stat) var\n+if (stat /= 0) STOP 8\n+read (99,*) var ! << FAILS: stat /= 0\n+if (stat /= 0) STOP 9\n+close(99, status=\"delete\")\n+\n+! Test logical kind\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"Tru\", new_line(\"\")\n+write(99) \"fal\", new_line(\"\")\n+write(99) \"t\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) lvar\n+if (stat /= 0 .or. (.not.lvar)) STOP 10\n+read (99,*, iostat=stat) lvar\n+if (stat /= 0 .or. lvar) STOP 11\n+read (99,*) lvar ! << FAILS: stat /= 0\n+if (stat /= 0 .or. (.not.lvar)) STOP 12\n+close(99, status=\"delete\")\n+\n+! Test combinations of Inf and Nan\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"infinity\", new_line(\"\")\n+write(99) \"nan\", new_line(\"\")\n+write(99) \"infinity\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) var\n+if (stat /= 0) STOP 13\n+read (99,*, iostat=stat) var\n+if (stat /= 0) STOP 14\n+read (99,*) var          ! << FAILS: stat /= 0\n+if (stat /= 0) STOP 1! << aborts here\n+close(99, status=\"delete\")\n+\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"infinity\", new_line(\"\")\n+write(99) \"inf\", new_line(\"\")\n+write(99) \"nan\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) var\n+if (stat /= 0) STOP 15\n+read (99,*, iostat=stat) var\n+if (stat /= 0) STOP 16\n+read (99,*) var          ! << FAILS: stat /= 0\n+if (stat /= 0) STOP 2! << aborts here\n+close(99, status=\"delete\")\n+\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"infinity\", new_line(\"\")\n+write(99) \"nan\", new_line(\"\")\n+write(99) \"inf\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) var\n+if (stat /= 0) STOP 17\n+read (99,*, iostat=stat) var\n+if (stat /= 0) STOP 18\n+read (99,*) var          ! << FAILS: stat /= 0\n+if (stat /= 0) STOP 3! << aborts here\n+close(99, status=\"delete\")\n+\n+! Test complex kind\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"(1,2)\", new_line(\"\")\n+write(99) \"(2,3)\", new_line(\"\")\n+write(99) \"(4,5)\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) cval\n+if (stat /= 0 .or. cval /= cmplx(1,2)) STOP 19\n+read (99,*, iostat=stat) cval\n+if (stat /= 0 .or. cval /= cmplx(2,3)) STOP 20\n+read (99,*, iostat=stat) cval      ! << FAILS: stat /= 0, value is okay\n+if (stat /= 0 .or. cval /= cmplx(4,5)) STOP 21\n+close(99, status=\"delete\")\n+end"}, {"sha": "f19c0379202129162f59d78f86f203d4c699505b", "filename": "libgomp/testsuite/libgomp.fortran/async_io_6.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_6.f90?ref=0fc1c4290bbeb00a66621a1596db297bbed05dc2", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do run }\n+!TODO: Move these testcases to gfortran testsuite\n+! once compilation with pthreads is supported there\n+! PR 22390 Implement flush statement\n+program flush_1\n+\n+   character(len=256) msg\n+   integer ios\n+\n+   open (unit=10, access='SEQUENTIAL', status='SCRATCH')\n+\n+   write (10, *) 42\n+   flush 10\n+\n+   write (10, *) 42\n+   flush(10)\n+\n+   write (10, *) 42\n+   flush(unit=10, iostat=ios)\n+   if (ios /= 0) STOP 1\n+\n+   write (10, *) 42\n+   flush (unit=10, err=20)\n+   goto 30\n+20 STOP 2\n+30 continue\n+\n+   call flush(10)\n+\n+end program flush_1"}, {"sha": "a7ce9ba47a7cabbf0915ebb54c02ceaaa12d45a7", "filename": "libgomp/testsuite/libgomp.fortran/async_io_7.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc1c4290bbeb00a66621a1596db297bbed05dc2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_7.f90?ref=0fc1c4290bbeb00a66621a1596db297bbed05dc2", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+!TODO: Move these testcases to gfortran testsuite\n+! once compilation with pthreads is supported there\n+! PR40008 F2008: Add NEWUNIT= for OPEN statement \n+! Contributed by Jerry DeLisle <jvdelisle@gcc.gnu.org>\n+program newunit_1\n+  character(len=25) :: str\n+  integer(1) :: myunit, myunit2\n+  myunit = 25\n+  str = \"bad\"\n+  open(newunit=myunit, status=\"scratch\")\n+  open(newunit = myunit2, file=\"newunit_1file\")\n+  write(myunit,'(e24.15e2)') 1.0d0\n+  write(myunit2,*) \"abcdefghijklmnop\"\n+  flush(myunit)\n+  rewind(myunit)\n+  rewind(myunit2)\n+  read(myunit2,'(a)') str\n+  if (str.ne.\" abcdefghijklmnop\") STOP 1\n+  close(myunit)\n+  close(myunit2, status=\"delete\")\n+end program newunit_1"}]}