{"sha": "ce535a9685b11c846560cc0f9f4dded1ca558efc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U1MzVhOTY4NWIxMWM4NDY1NjBjYzBmOWY0ZGRlZDFjYTU1OGVmYw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-09-29T12:54:05Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-09-29T12:54:05Z"}, "message": "Reduce space and time overhead of std::thread\n\n\tPR libstdc++/65393\n\t* config/abi/pre/gnu.ver: Export new symbols.\n\t* include/std/thread (thread::_State, thread::_State_impl): New types.\n\t(thread::_M_start_thread): Add overload taking unique_ptr<_State>.\n\t(thread::_M_make_routine): Remove.\n\t(thread::_S_make_state): Add.\n\t(thread::_Impl_base, thread::_Impl, thread::_M_start_thread)\n\t[_GLIBCXX_THREAD_ABI_COMPAT] Only declare conditionally.\n\t* src/c++11/thread.cc (execute_native_thread_routine): Rename to\n\texecute_native_thread_routine_compat and re-define to use _State.\n\t(thread::_State::~_State()): Define.\n\t(thread::_M_make_thread): Define new overload.\n\t(thread::_M_make_thread) [_GLIBCXX_THREAD_ABI_COMPAT]: Only define old\n\toverloads conditionally.\n\nFrom-SVN: r228242", "tree": {"sha": "1c41b68da533870ce3a44a9dd4a934252561bfbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c41b68da533870ce3a44a9dd4a934252561bfbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce535a9685b11c846560cc0f9f4dded1ca558efc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce535a9685b11c846560cc0f9f4dded1ca558efc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce535a9685b11c846560cc0f9f4dded1ca558efc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce535a9685b11c846560cc0f9f4dded1ca558efc/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c357b903daa3f831a34541a9d99469ccce226d54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c357b903daa3f831a34541a9d99469ccce226d54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c357b903daa3f831a34541a9d99469ccce226d54"}], "stats": {"total": 161, "additions": 117, "deletions": 44}, "files": [{"sha": "ad951e276d98f53d901dcc9deb26282929d61a7f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce535a9685b11c846560cc0f9f4dded1ca558efc/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce535a9685b11c846560cc0f9f4dded1ca558efc/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ce535a9685b11c846560cc0f9f4dded1ca558efc", "patch": "@@ -1,3 +1,20 @@\n+2015-09-29  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/65393\n+\t* config/abi/pre/gnu.ver: Export new symbols.\n+\t* include/std/thread (thread::_State, thread::_State_impl): New types.\n+\t(thread::_M_start_thread): Add overload taking unique_ptr<_State>.\n+\t(thread::_M_make_routine): Remove.\n+\t(thread::_S_make_state): Add.\n+\t(thread::_Impl_base, thread::_Impl, thread::_M_start_thread)\n+\t[_GLIBCXX_THREAD_ABI_COMPAT] Only declare conditionally.\n+\t* src/c++11/thread.cc (execute_native_thread_routine): Rename to\n+\texecute_native_thread_routine_compat and re-define to use _State.\n+\t(thread::_State::~_State()): Define.\n+\t(thread::_M_make_thread): Define new overload.\n+\t(thread::_M_make_thread) [_GLIBCXX_THREAD_ABI_COMPAT]: Only define old\n+\toverloads conditionally.\n+\n 2015-09-28  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/std/condition_variable (condition_variable::wait): Add"}, {"sha": "08d9bc6c50e59a18ebf18cd5129492ac04aff58b", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce535a9685b11c846560cc0f9f4dded1ca558efc/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce535a9685b11c846560cc0f9f4dded1ca558efc/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=ce535a9685b11c846560cc0f9f4dded1ca558efc", "patch": "@@ -1870,6 +1870,11 @@ GLIBCXX_3.4.22 {\n     # std::uncaught_exceptions()\n     _ZSt19uncaught_exceptionsv;\n \n+    # std::thread::_State::~_State()\n+    _ZT[ISV]NSt6thread6_StateE;\n+    _ZNSt6thread6_StateD[012]Ev;\n+    _ZNSt6thread15_M_start_threadESt10unique_ptrINS_6_StateESt14default_deleteIS1_EEPFvvE;\n+\n } GLIBCXX_3.4.21;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "c67ec46123f112a85ed8408da619672f17a8b73e", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce535a9685b11c846560cc0f9f4dded1ca558efc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce535a9685b11c846560cc0f9f4dded1ca558efc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=ce535a9685b11c846560cc0f9f4dded1ca558efc", "patch": "@@ -60,9 +60,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   class thread\n   {\n   public:\n+    // Abstract base class for types that wrap arbitrary functors to be\n+    // invoked in the new thread of execution.\n+    struct _State\n+    {\n+      virtual ~_State();\n+      virtual void _M_run() = 0;\n+    };\n+    using _State_ptr = unique_ptr<_State>;\n+\n     typedef __gthread_t\t\t\tnative_handle_type;\n-    struct _Impl_base;\n-    typedef shared_ptr<_Impl_base>\t__shared_base_type;\n \n     /// thread::id\n     class id\n@@ -92,29 +99,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \toperator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id);\n     };\n \n-    // Simple base type that the templatized, derived class containing\n-    // an arbitrary functor can be converted to and called.\n-    struct _Impl_base\n-    {\n-      __shared_base_type\t_M_this_ptr;\n-\n-      inline virtual ~_Impl_base();\n-\n-      virtual void _M_run() = 0;\n-    };\n-\n-    template<typename _Callable>\n-      struct _Impl : public _Impl_base\n-      {\n-\t_Callable\t\t_M_func;\n-\n-\t_Impl(_Callable&& __f) : _M_func(std::forward<_Callable>(__f))\n-\t{ }\n-\n-\tvoid\n-\t_M_run() { _M_func(); }\n-      };\n-\n   private:\n     id\t\t\t\t_M_id;\n \n@@ -133,16 +117,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       thread(_Callable&& __f, _Args&&... __args)\n       {\n #ifdef GTHR_ACTIVE_PROXY\n-\t// Create a reference to pthread_create, not just the gthr weak symbol\n-        _M_start_thread(_M_make_routine(std::__bind_simple(\n-                std::forward<_Callable>(__f),\n-                std::forward<_Args>(__args)...)),\n-\t    reinterpret_cast<void(*)()>(&pthread_create));\n+\t// Create a reference to pthread_create, not just the gthr weak symbol.\n+\tauto __depend = reinterpret_cast<void(*)()>(&pthread_create);\n #else\n-        _M_start_thread(_M_make_routine(std::__bind_simple(\n-                std::forward<_Callable>(__f),\n-                std::forward<_Args>(__args)...)));\n+\tauto __depend = nullptr;\n #endif\n+        _M_start_thread(_S_make_state(\n+\t      std::__bind_simple(std::forward<_Callable>(__f),\n+\t\t\t\t std::forward<_Args>(__args)...)),\n+\t    __depend);\n       }\n \n     ~thread()\n@@ -190,22 +173,47 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     hardware_concurrency() noexcept;\n \n   private:\n-    void\n-    _M_start_thread(__shared_base_type, void (*)());\n+    template<typename _Callable>\n+      struct _State_impl : public _State\n+      {\n+\t_Callable\t\t_M_func;\n+\n+\t_State_impl(_Callable&& __f) : _M_func(std::forward<_Callable>(__f))\n+\t{ }\n+\n+\tvoid\n+\t_M_run() { _M_func(); }\n+      };\n \n     void\n-    _M_start_thread(__shared_base_type);\n+    _M_start_thread(_State_ptr, void (*)());\n \n     template<typename _Callable>\n-      shared_ptr<_Impl<_Callable>>\n-      _M_make_routine(_Callable&& __f)\n+      static _State_ptr\n+      _S_make_state(_Callable&& __f)\n       {\n-\t// Create and allocate full data structure, not base.\n-\treturn std::make_shared<_Impl<_Callable>>(std::forward<_Callable>(__f));\n+\tusing _Impl = _State_impl<_Callable>;\n+\treturn _State_ptr{new _Impl{std::forward<_Callable>(__f)}};\n       }\n-  };\n+#if _GLIBCXX_THREAD_ABI_COMPAT\n+  public:\n+    struct _Impl_base;\n+    typedef shared_ptr<_Impl_base>\t__shared_base_type;\n+    struct _Impl_base\n+    {\n+      __shared_base_type\t_M_this_ptr;\n+      virtual ~_Impl_base() = default;\n+      virtual void _M_run() = 0;\n+    };\n \n-  inline thread::_Impl_base::~_Impl_base() = default;\n+  private:\n+    void\n+    _M_start_thread(__shared_base_type, void (*)());\n+\n+    void\n+    _M_start_thread(__shared_base_type);\n+#endif\n+  };\n \n   inline void\n   swap(thread& __x, thread& __y) noexcept"}, {"sha": "e116afa0ccb5595336e99481bac769a11f397eb5", "filename": "libstdc++-v3/src/c++11/thread.cc", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce535a9685b11c846560cc0f9f4dded1ca558efc/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce535a9685b11c846560cc0f9f4dded1ca558efc/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc?ref=ce535a9685b11c846560cc0f9f4dded1ca558efc", "patch": "@@ -23,6 +23,7 @@\n // <http://www.gnu.org/licenses/>.\n \n \n+#define _GLIBCXX_THREAD_ABI_COMPAT 1\n #include <thread>\n #include <system_error>\n #include <cerrno>\n@@ -74,9 +75,34 @@ namespace std _GLIBCXX_VISIBILITY(default)\n   {\n     extern \"C\" void*\n     execute_native_thread_routine(void* __p)\n+    {\n+      thread::_State_ptr __t{ static_cast<thread::_State*>(__p) };\n+\n+      __try\n+\t{\n+\t  __t->_M_run();\n+\t}\n+      __catch(const __cxxabiv1::__forced_unwind&)\n+\t{\n+\t  __throw_exception_again;\n+\t}\n+      __catch(...)\n+\t{\n+\t  std::terminate();\n+\t}\n+\n+      return nullptr;\n+    }\n+\n+#if _GLIBCXX_THREAD_ABI_COMPAT\n+    extern \"C\" void*\n+    execute_native_thread_routine_compat(void* __p)\n     {\n       thread::_Impl_base* __t = static_cast<thread::_Impl_base*>(__p);\n       thread::__shared_base_type __local;\n+      // Now that a new thread has been created we can transfer ownership of\n+      // the thread state to a local object, breaking the reference cycle\n+      // created in thread::_M_start_thread.\n       __local.swap(__t->_M_this_ptr);\n \n       __try\n@@ -94,10 +120,13 @@ namespace std _GLIBCXX_VISIBILITY(default)\n \n       return nullptr;\n     }\n+#endif\n   }\n \n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  thread::_State::~_State() = default;\n+\n   void\n   thread::join()\n   {\n@@ -126,6 +155,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_id = id();\n   }\n \n+  void\n+  thread::_M_start_thread(_State_ptr state, void (*)())\n+  {\n+    const int err = __gthread_create(&_M_id._M_thread,\n+\t\t\t\t     &execute_native_thread_routine,\n+\t\t\t\t     state.get());\n+    if (err)\n+      __throw_system_error(err);\n+    state.release();\n+  }\n+\n+#if _GLIBCXX_THREAD_ABI_COMPAT\n   void\n   thread::_M_start_thread(__shared_base_type __b)\n   {\n@@ -144,15 +185,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   thread::_M_start_thread(__shared_base_type __b, void (*)())\n   {\n     auto ptr = __b.get();\n+    // Create a reference cycle that will be broken in the new thread.\n     ptr->_M_this_ptr = std::move(__b);\n     int __e = __gthread_create(&_M_id._M_thread,\n-\t\t\t       &execute_native_thread_routine, ptr);\n+\t\t\t       &execute_native_thread_routine_compat, ptr);\n     if (__e)\n     {\n-      ptr->_M_this_ptr.reset();\n+      ptr->_M_this_ptr.reset();  // break reference cycle, destroying *ptr.\n       __throw_system_error(__e);\n     }\n   }\n+#endif\n \n   unsigned int\n   thread::hardware_concurrency() noexcept"}]}