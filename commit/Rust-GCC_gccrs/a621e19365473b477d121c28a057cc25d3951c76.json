{"sha": "a621e19365473b477d121c28a057cc25d3951c76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYyMWUxOTM2NTQ3M2I0NzdkMTIxYzI4YTA1N2NjMjVkMzk1MWM3Ng==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-12-15T17:26:07Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-12-17T17:23:46Z"}, "message": "Remove old analysis framework and strip the AST->GIMPLE pass this needs\nto use the new name and type resolution pass contexts.", "tree": {"sha": "3eb1e4ec3de18bca63b6d1806eb7c827c2098a31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eb1e4ec3de18bca63b6d1806eb7c827c2098a31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a621e19365473b477d121c28a057cc25d3951c76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a621e19365473b477d121c28a057cc25d3951c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a621e19365473b477d121c28a057cc25d3951c76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a621e19365473b477d121c28a057cc25d3951c76/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44d10d9547612b5fda3d27bb628d5d6ee79108af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d10d9547612b5fda3d27bb628d5d6ee79108af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44d10d9547612b5fda3d27bb628d5d6ee79108af"}], "stats": {"total": 6492, "additions": 103, "deletions": 6389}, "files": [{"sha": "56f308eee611ca92e9e911c3e199d6890f8b9ba4", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a621e19365473b477d121c28a057cc25d3951c76/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a621e19365473b477d121c28a057cc25d3951c76/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=a621e19365473b477d121c28a057cc25d3951c76", "patch": "@@ -69,9 +69,6 @@ GRS_OBJS = \\\n     rust/rust-parse.o \\\n     rust/rust-ast-full-test.o \\\n     rust/rust-session-manager.o \\\n-    rust/rust-name-resolution.o \\\n-    rust/rust-type-resolution.o \\\n-    rust/rust-scan.o \\\n     rust/rust-compile.o \\\n     rust/rust-macro-expand.o \\\n     rust/rust-hir-full-test.o \\\n@@ -261,11 +258,6 @@ rust/%.o: rust/ast/%.cc\n \t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n-# build rust/analysis files in rust folder\n-rust/%.o: rust/analysis/%.cc\n-\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n-\t$(POSTCOMPILE)\n-\n # build rust/backend files in rust folder\n rust/%.o: rust/backend/%.cc\n \t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<"}, {"sha": "28a4af81bd2f0f826af6b5f7c9b9cdff7abdda3a", "filename": "gcc/rust/analysis/rust-name-resolution.cc", "status": "removed", "additions": 0, "deletions": 657, "changes": 657, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-name-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-name-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-name-resolution.cc?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -1,657 +0,0 @@\n-#include \"rust-name-resolution.h\"\n-#include \"rust-diagnostics.h\"\n-\n-/*\n- * The principles of name resolution:\n- * 1. If a name resolves to a binding then it should always resolve to that\n- * binding, and if resolving a name produces an error, it should always produce\n- * an error.\n- * 2. Avoid errors due to the resolver being stuck.\n- * 3. Names should be able to be used before they are declared, but the order of\n- * declarations should be irrelevant.\n- * 4. Macros should be hygiene and manually expandable.\n- * 5. Glob imports should be manually expandable.\n- */\n-\n-/* The algorithm of name resolution\n- * 1. When encouter items which bind a name, add the name to the binding table.\n- * 2. When we find an import which can't be resolved, we add it to a work list.\n- * 3. When we find a glob import, we have to record a 'back link', so that when\n- *    a public name is added for the supplying module, we can add it for the\n- *    importing module.\n- * 4. Loop over the work list and try to lookup names.\n- *    a. If a name has exactly one best binding then we use it (and record the\n- *       binding on a list of resolved names).\n- *    b. If there are zero then we put it back on the work list.\n- *    c. If there is more than one binding, then we record an ambiguity error.\n- *    d. When the work list no longer changes, then we are done.\n- *    e. If the work list is empty, then expansion/import resolution succeeded.\n- *       Otherwise there are names not found, or ambiguous names, then failed.\n- * 5. When looking up names, we record the resolutions in the binding table.\n- *    a. If the name a glob import, we add bindings for every accessible name\n- *       currently known.\n- * 6. To expand a macro, we try to resolve the macro's name.\n- *    a. If that fails, we put it on the work list.\n- *       Otherwise, we expand that macro by parsing the arguments,\n- *       pattern matching, and doing hygienic expansion.\n- *    b. We then parse the generated code in the same way as we parsed the\n- *       original program. We add new names to the binding table, and expand any\n- *       new macro uses.\n- * 7. If we add names for a module which has back links, we must follow them and\n- *    add these names to the importing module (if they are accessible).\n- */\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-NameResolution::NameResolution (AST::Crate &crate, TopLevelScan &toplevel)\n-  : Resolution (crate, toplevel), is_work_list_changed_ (false)\n-\n-{}\n-\n-NameResolution::~NameResolution () {}\n-\n-bool\n-NameResolution::Resolve (AST::Crate &crate, TopLevelScan &toplevel)\n-{\n-  NameResolution resolver (crate, toplevel);\n-  return resolver.go ();\n-}\n-\n-void\n-NameResolution::process_work_list ()\n-{}\n-\n-void\n-NameResolution::expand_macros ()\n-{}\n-\n-bool\n-NameResolution::go ()\n-{\n-  bool ret = true;\n-\n-  do\n-    {\n-      for (auto &item : crate.items)\n-\t{\n-\t  item->accept_vis (*this);\n-\t}\n-    }\n-  while (is_work_list_changed ());\n-\n-  ret = work_list_.empty ();\n-  for (auto &item : work_list_)\n-    {\n-      std::cout << \"Resolution error: \" << item.as_string () << std::endl;\n-    }\n-\n-  return ret;\n-}\n-\n-void\n-NameResolution::visit (AST::Token &tok)\n-{}\n-\n-void\n-NameResolution::visit (AST::DelimTokenTree &delim_tok_tree)\n-{}\n-\n-void\n-NameResolution::visit (AST::AttrInputMetaItemContainer &input)\n-{}\n-\n-void\n-NameResolution::visit (AST::IdentifierExpr &ident_expr)\n-{\n-  do\n-    {\n-      process_work_list ();\n-    }\n-  while (is_work_list_changed ());\n-  expand_macros ();\n-}\n-\n-void\n-NameResolution::visit (AST::Lifetime &lifetime)\n-{}\n-\n-void\n-NameResolution::visit (AST::LifetimeParam &lifetime_param)\n-{}\n-\n-void\n-NameResolution::visit (AST::MacroInvocationSemi &macro)\n-{}\n-\n-// rust-path.h\n-void\n-NameResolution::visit (AST::PathInExpression &path)\n-{}\n-\n-void\n-NameResolution::visit (AST::TypePathSegment &segment)\n-{}\n-void\n-NameResolution::visit (AST::TypePathSegmentGeneric &segment)\n-{}\n-\n-void\n-NameResolution::visit (AST::TypePathSegmentFunction &segment)\n-{}\n-\n-void\n-NameResolution::visit (AST::TypePath &path)\n-{}\n-\n-void\n-NameResolution::visit (AST::QualifiedPathInExpression &path)\n-{\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-void\n-NameResolution::visit (AST::QualifiedPathInType &path)\n-{}\n-\n-// rust-expr.h\n-void\n-NameResolution::visit (AST::LiteralExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::AttrInputLiteral &attr_input)\n-{}\n-\n-void\n-NameResolution::visit (AST::MetaItemLitExpr &meta_item)\n-{}\n-\n-void\n-NameResolution::visit (AST::MetaItemPathLit &meta_item)\n-{}\n-\n-void\n-NameResolution::visit (AST::BorrowExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::DereferenceExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ErrorPropagationExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::NegationExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::ComparisonExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::LazyBooleanExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::TypeCastExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::AssignmentExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::CompoundAssignmentExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::GroupedExpr &expr)\n-{}\n-// void NameResolution::visit(ArrayElems& elems) {}\n-void\n-NameResolution::visit (AST::ArrayElemsValues &elems)\n-{}\n-void\n-NameResolution::visit (AST::ArrayElemsCopied &elems)\n-{}\n-void\n-NameResolution::visit (AST::ArrayExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ArrayIndexExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::TupleExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::TupleIndexExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::StructExprStruct &expr)\n-{}\n-// void NameResolution::visit(StructExprField& field) {}\n-void\n-NameResolution::visit (AST::StructExprFieldIdentifier &field)\n-{}\n-void\n-NameResolution::visit (AST::StructExprFieldIdentifierValue &field)\n-{}\n-void\n-NameResolution::visit (AST::StructExprFieldIndexValue &field)\n-{}\n-void\n-NameResolution::visit (AST::StructExprStructFields &expr)\n-{}\n-void\n-NameResolution::visit (AST::StructExprStructBase &expr)\n-{}\n-void\n-NameResolution::visit (AST::StructExprTuple &expr)\n-{}\n-void\n-NameResolution::visit (AST::StructExprUnit &expr)\n-{}\n-// void NameResolution::visit(EnumExprField& field) {}\n-void\n-NameResolution::visit (AST::EnumExprFieldIdentifier &field)\n-{}\n-void\n-NameResolution::visit (AST::EnumExprFieldIdentifierValue &field)\n-{}\n-void\n-NameResolution::visit (AST::EnumExprFieldIndexValue &field)\n-{}\n-void\n-NameResolution::visit (AST::EnumExprStruct &expr)\n-{}\n-void\n-NameResolution::visit (AST::EnumExprTuple &expr)\n-{}\n-void\n-NameResolution::visit (AST::EnumExprFieldless &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::CallExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::MethodCallExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::FieldAccessExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ClosureExprInner &expr)\n-{}\n-void\n-NameResolution::visit (AST::BlockExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ClosureExprInnerTyped &expr)\n-{}\n-void\n-NameResolution::visit (AST::ContinueExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::BreakExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeFromToExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeFromExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeToExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeFullExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeFromToInclExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeToInclExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ReturnExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::UnsafeBlockExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::LoopExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::WhileLoopExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::WhileLetLoopExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ForLoopExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfExprConseqElse &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfExprConseqIf &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfExprConseqIfLet &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfLetExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfLetExprConseqElse &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfLetExprConseqIf &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfLetExprConseqIfLet &expr)\n-{}\n-// void NameResolution::visit(MatchCase& match_case) {}\n-/*void\n-NameResolution::visit (AST::MatchCaseBlockExpr &match_case)\n-{}*/\n-/*void\n-NameResolution::visit (AST::MatchCaseExpr &match_case)\n-{}*/\n-void\n-NameResolution::visit (AST::MatchExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::AwaitExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::AsyncBlockExpr &expr)\n-{}\n-\n-// rust-item.h\n-void\n-NameResolution::visit (AST::TypeParam &param)\n-{}\n-// void NameResolution::visit(WhereClauseItem& item) {}\n-void\n-NameResolution::visit (AST::LifetimeWhereClauseItem &item)\n-{}\n-void\n-NameResolution::visit (AST::TypeBoundWhereClauseItem &item)\n-{}\n-void\n-NameResolution::visit (AST::Method &method)\n-{}\n-void\n-NameResolution::visit (AST::ModuleBodied &module)\n-{}\n-void\n-NameResolution::visit (AST::ModuleNoBody &module)\n-{}\n-void\n-NameResolution::visit (AST::ExternCrate &crate)\n-{}\n-// void NameResolution::visit(UseTree& use_tree) {}\n-void\n-NameResolution::visit (AST::UseTreeGlob &use_tree)\n-{}\n-void\n-NameResolution::visit (AST::UseTreeList &use_tree)\n-{}\n-void\n-NameResolution::visit (AST::UseTreeRebind &use_tree)\n-{}\n-void\n-NameResolution::visit (AST::UseDeclaration &use_decl)\n-{}\n-\n-void\n-NameResolution::visit (AST::Function &function)\n-{}\n-\n-void\n-NameResolution::visit (AST::TypeAlias &type_alias)\n-{}\n-void\n-NameResolution::visit (AST::StructStruct &struct_item)\n-{}\n-void\n-NameResolution::visit (AST::TupleStruct &tuple_struct)\n-{}\n-void\n-NameResolution::visit (AST::EnumItem &item)\n-{}\n-void\n-NameResolution::visit (AST::EnumItemTuple &item)\n-{}\n-void\n-NameResolution::visit (AST::EnumItemStruct &item)\n-{}\n-void\n-NameResolution::visit (AST::EnumItemDiscriminant &item)\n-{}\n-void\n-NameResolution::visit (AST::Enum &enum_item)\n-{}\n-void\n-NameResolution::visit (AST::Union &union_item)\n-{}\n-\n-void\n-NameResolution::visit (AST::ConstantItem &const_item)\n-{}\n-\n-void\n-NameResolution::visit (AST::StaticItem &static_item)\n-{}\n-void\n-NameResolution::visit (AST::TraitItemFunc &item)\n-{}\n-void\n-NameResolution::visit (AST::TraitItemMethod &item)\n-{}\n-void\n-NameResolution::visit (AST::TraitItemConst &item)\n-{}\n-void\n-NameResolution::visit (AST::TraitItemType &item)\n-{}\n-void\n-NameResolution::visit (AST::Trait &trait)\n-{}\n-void\n-NameResolution::visit (AST::InherentImpl &impl)\n-{}\n-void\n-NameResolution::visit (AST::TraitImpl &impl)\n-{}\n-// void NameResolution::visit(ExternalItem& item) {}\n-void\n-NameResolution::visit (AST::ExternalStaticItem &item)\n-{}\n-void\n-NameResolution::visit (AST::ExternalFunctionItem &item)\n-{}\n-void\n-NameResolution::visit (AST::ExternBlock &block)\n-{}\n-\n-// rust-macro.h\n-void\n-NameResolution::visit (AST::MacroMatchFragment &match)\n-{}\n-void\n-NameResolution::visit (AST::MacroMatchRepetition &match)\n-{}\n-void\n-NameResolution::visit (AST::MacroMatcher &matcher)\n-{}\n-\n-void\n-NameResolution::visit (AST::MacroRulesDefinition &rules_def)\n-{}\n-\n-void\n-NameResolution::visit (AST::MacroInvocation &macro_invoc)\n-{}\n-void\n-NameResolution::visit (AST::MetaItemPath &meta_item)\n-{}\n-void\n-NameResolution::visit (AST::MetaItemSeq &meta_item)\n-{}\n-void\n-NameResolution::visit (AST::MetaWord &meta_item)\n-{}\n-void\n-NameResolution::visit (AST::MetaNameValueStr &meta_item)\n-{}\n-void\n-NameResolution::visit (AST::MetaListPaths &meta_item)\n-{}\n-void\n-NameResolution::visit (AST::MetaListNameValueStr &meta_item)\n-{}\n-\n-// rust-pattern.h\n-void\n-NameResolution::visit (AST::LiteralPattern &pattern)\n-{}\n-\n-void\n-NameResolution::visit (AST::IdentifierPattern &pattern)\n-{}\n-\n-void\n-NameResolution::visit (AST::WildcardPattern &pattern)\n-{}\n-// void NameResolution::visit(RangePatternBound& bound) {}\n-void\n-NameResolution::visit (AST::RangePatternBoundLiteral &bound)\n-{}\n-void\n-NameResolution::visit (AST::RangePatternBoundPath &bound)\n-{}\n-void\n-NameResolution::visit (AST::RangePatternBoundQualPath &bound)\n-{}\n-void\n-NameResolution::visit (AST::RangePattern &pattern)\n-{}\n-void\n-NameResolution::visit (AST::ReferencePattern &pattern)\n-{}\n-// void NameResolution::visit(StructPatternField& field) {}\n-void\n-NameResolution::visit (AST::StructPatternFieldTuplePat &field)\n-{}\n-void\n-NameResolution::visit (AST::StructPatternFieldIdentPat &field)\n-{}\n-void\n-NameResolution::visit (AST::StructPatternFieldIdent &field)\n-{}\n-void\n-NameResolution::visit (AST::StructPattern &pattern)\n-{}\n-// void NameResolution::visit(TupleStructItems& tuple_items) {}\n-void\n-NameResolution::visit (AST::TupleStructItemsNoRange &tuple_items)\n-{}\n-void\n-NameResolution::visit (AST::TupleStructItemsRange &tuple_items)\n-{}\n-void\n-NameResolution::visit (AST::TupleStructPattern &pattern)\n-{}\n-// void NameResolution::visit(TuplePatternItems& tuple_items) {}\n-void\n-NameResolution::visit (AST::TuplePatternItemsMultiple &tuple_items)\n-{}\n-void\n-NameResolution::visit (AST::TuplePatternItemsRanged &tuple_items)\n-{}\n-void\n-NameResolution::visit (AST::TuplePattern &pattern)\n-{}\n-void\n-NameResolution::visit (AST::GroupedPattern &pattern)\n-{}\n-void\n-NameResolution::visit (AST::SlicePattern &pattern)\n-{}\n-\n-// rust-stmt.h\n-void\n-NameResolution::visit (AST::EmptyStmt &stmt)\n-{}\n-\n-void\n-NameResolution::visit (AST::LetStmt &stmt)\n-{}\n-\n-void\n-NameResolution::visit (AST::ExprStmtWithoutBlock &stmt)\n-{}\n-\n-void\n-NameResolution::visit (AST::ExprStmtWithBlock &stmt)\n-{}\n-\n-// rust-type.h\n-void\n-NameResolution::visit (AST::TraitBound &bound)\n-{}\n-\n-void\n-NameResolution::visit (AST::ImplTraitType &type)\n-{}\n-\n-void\n-NameResolution::visit (AST::TraitObjectType &type)\n-{}\n-void\n-NameResolution::visit (AST::ParenthesisedType &type)\n-{}\n-void\n-NameResolution::visit (AST::ImplTraitTypeOneBound &type)\n-{}\n-void\n-NameResolution::visit (AST::TraitObjectTypeOneBound &type)\n-{}\n-void\n-NameResolution::visit (AST::TupleType &type)\n-{}\n-void\n-NameResolution::visit (AST::NeverType &type)\n-{}\n-void\n-NameResolution::visit (AST::RawPointerType &type)\n-{}\n-void\n-NameResolution::visit (AST::ReferenceType &type)\n-{}\n-void\n-NameResolution::visit (AST::ArrayType &type)\n-{}\n-void\n-NameResolution::visit (AST::SliceType &type)\n-{}\n-void\n-NameResolution::visit (AST::InferredType &type)\n-{}\n-void\n-NameResolution::visit (AST::BareFunctionType &type)\n-{}\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "b3bc78002c054522474d1ba80f87df3ffd80dc7a", "filename": "gcc/rust/analysis/rust-name-resolution.h", "status": "removed", "additions": 0, "deletions": 232, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-name-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-name-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-name-resolution.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -1,232 +0,0 @@\n-#pragma once\n-\n-#include \"rust-resolution.h\"\n-#include <list>\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-class NameResolution : public Resolution\n-{\n-public:\n-  ~NameResolution ();\n-  static bool Resolve (AST::Crate &crate, TopLevelScan &toplevel);\n-\n-  // visitor impl\n-  // rust-ast.h\n-  //  void visit(AttrInput& attr_input);\n-  //  void visit(TokenTree& token_tree);\n-  //  void visit(MacroMatch& macro_match);\n-  void visit (AST::Token &tok) override;\n-  void visit (AST::DelimTokenTree &delim_tok_tree) override;\n-  void visit (AST::AttrInputMetaItemContainer &input) override;\n-  //  void visit(MetaItem& meta_item) override;\n-  //  void vsit(Stmt& stmt) override;\n-  //  void visit(Expr& expr) override;\n-  void visit (AST::IdentifierExpr &ident_expr) override;\n-  //  void visit(Pattern& pattern) override;\n-  //  void visit(Type& type) override;\n-  //  void visit(TypeParamBound& type_param_bound) override;\n-  void visit (AST::Lifetime &lifetime) override;\n-  //  void visit(GenericParam& generic_param) override;\n-  void visit (AST::LifetimeParam &lifetime_param) override;\n-  //  void visit(TraitItem& trait_item) override;\n-  //  void visit(InherentImplItem& inherent_impl_item) override;\n-  //  void visit(TraitImplItem& trait_impl_item) override;\n-  void visit (AST::MacroInvocationSemi &macro) override;\n-\n-  // rust-path.h\n-  void visit (AST::PathInExpression &path) override;\n-  void visit (AST::TypePathSegment &segment) override;\n-  void visit (AST::TypePathSegmentGeneric &segment) override;\n-  void visit (AST::TypePathSegmentFunction &segment) override;\n-  void visit (AST::TypePath &path) override;\n-  void visit (AST::QualifiedPathInExpression &path) override;\n-  void visit (AST::QualifiedPathInType &path) override;\n-\n-  // rust-expr.h\n-  void visit (AST::LiteralExpr &expr) override;\n-  void visit (AST::AttrInputLiteral &attr_input) override;\n-  void visit (AST::MetaItemLitExpr &meta_item) override;\n-  void visit (AST::MetaItemPathLit &meta_item) override;\n-  void visit (AST::BorrowExpr &expr) override;\n-  void visit (AST::DereferenceExpr &expr) override;\n-  void visit (AST::ErrorPropagationExpr &expr) override;\n-  void visit (AST::NegationExpr &expr) override;\n-  void visit (AST::ArithmeticOrLogicalExpr &expr) override;\n-  void visit (AST::ComparisonExpr &expr) override;\n-  void visit (AST::LazyBooleanExpr &expr) override;\n-  void visit (AST::TypeCastExpr &expr) override;\n-  void visit (AST::AssignmentExpr &expr) override;\n-  void visit (AST::CompoundAssignmentExpr &expr) override;\n-  void visit (AST::GroupedExpr &expr) override;\n-  //  void visit(ArrayElems& elems) override;\n-  void visit (AST::ArrayElemsValues &elems) override;\n-  void visit (AST::ArrayElemsCopied &elems) override;\n-  void visit (AST::ArrayExpr &expr) override;\n-  void visit (AST::ArrayIndexExpr &expr) override;\n-  void visit (AST::TupleExpr &expr) override;\n-  void visit (AST::TupleIndexExpr &expr) override;\n-  void visit (AST::StructExprStruct &expr) override;\n-  //  void visit(StructExprField& field) override;\n-  void visit (AST::StructExprFieldIdentifier &field) override;\n-  void visit (AST::StructExprFieldIdentifierValue &field) override;\n-  void visit (AST::StructExprFieldIndexValue &field) override;\n-  void visit (AST::StructExprStructFields &expr) override;\n-  void visit (AST::StructExprStructBase &expr) override;\n-  void visit (AST::StructExprTuple &expr) override;\n-  void visit (AST::StructExprUnit &expr) override;\n-  //  void visit(EnumExprField& field) override;\n-  void visit (AST::EnumExprFieldIdentifier &field) override;\n-  void visit (AST::EnumExprFieldIdentifierValue &field) override;\n-  void visit (AST::EnumExprFieldIndexValue &field) override;\n-  void visit (AST::EnumExprStruct &expr) override;\n-  void visit (AST::EnumExprTuple &expr) override;\n-  void visit (AST::EnumExprFieldless &expr) override;\n-  void visit (AST::CallExpr &expr) override;\n-  void visit (AST::MethodCallExpr &expr) override;\n-  void visit (AST::FieldAccessExpr &expr) override;\n-  void visit (AST::ClosureExprInner &expr) override;\n-  void visit (AST::BlockExpr &expr) override;\n-  void visit (AST::ClosureExprInnerTyped &expr) override;\n-  void visit (AST::ContinueExpr &expr) override;\n-  void visit (AST::BreakExpr &expr) override;\n-  void visit (AST::RangeFromToExpr &expr) override;\n-  void visit (AST::RangeFromExpr &expr) override;\n-  void visit (AST::RangeToExpr &expr) override;\n-  void visit (AST::RangeFullExpr &expr) override;\n-  void visit (AST::RangeFromToInclExpr &expr) override;\n-  void visit (AST::RangeToInclExpr &expr) override;\n-  void visit (AST::ReturnExpr &expr) override;\n-  void visit (AST::UnsafeBlockExpr &expr) override;\n-  void visit (AST::LoopExpr &expr) override;\n-  void visit (AST::WhileLoopExpr &expr) override;\n-  void visit (AST::WhileLetLoopExpr &expr) override;\n-  void visit (AST::ForLoopExpr &expr) override;\n-  void visit (AST::IfExpr &expr) override;\n-  void visit (AST::IfExprConseqElse &expr) override;\n-  void visit (AST::IfExprConseqIf &expr) override;\n-  void visit (AST::IfExprConseqIfLet &expr) override;\n-  void visit (AST::IfLetExpr &expr) override;\n-  void visit (AST::IfLetExprConseqElse &expr) override;\n-  void visit (AST::IfLetExprConseqIf &expr) override;\n-  void visit (AST::IfLetExprConseqIfLet &expr) override;\n-  //  void visit(MatchCase& match_case) override;\n-  // void visit (AST::MatchCaseBlockExpr &match_case) override;\n-  // void visit (AST::MatchCaseExpr &match_case) override;\n-  void visit (AST::MatchExpr &expr) override;\n-  void visit (AST::AwaitExpr &expr) override;\n-  void visit (AST::AsyncBlockExpr &expr) override;\n-\n-  // rust-item.h\n-  void visit (AST::TypeParam &param) override;\n-  //  void visit(WhereClauseItem& item) override;\n-  void visit (AST::LifetimeWhereClauseItem &item) override;\n-  void visit (AST::TypeBoundWhereClauseItem &item) override;\n-  void visit (AST::Method &method) override;\n-  void visit (AST::ModuleBodied &module) override;\n-  void visit (AST::ModuleNoBody &module) override;\n-  void visit (AST::ExternCrate &crate) override;\n-  //  void visit(UseTree& use_tree) override;\n-  void visit (AST::UseTreeGlob &use_tree) override;\n-  void visit (AST::UseTreeList &use_tree) override;\n-  void visit (AST::UseTreeRebind &use_tree) override;\n-  void visit (AST::UseDeclaration &use_decl) override;\n-  void visit (AST::Function &function) override;\n-  void visit (AST::TypeAlias &type_alias) override;\n-  void visit (AST::StructStruct &struct_item) override;\n-  void visit (AST::TupleStruct &tuple_struct) override;\n-  void visit (AST::EnumItem &item) override;\n-  void visit (AST::EnumItemTuple &item) override;\n-  void visit (AST::EnumItemStruct &item) override;\n-  void visit (AST::EnumItemDiscriminant &item) override;\n-  void visit (AST::Enum &enum_item) override;\n-  void visit (AST::Union &union_item) override;\n-  void visit (AST::ConstantItem &const_item) override;\n-  void visit (AST::StaticItem &static_item) override;\n-  void visit (AST::TraitItemFunc &item) override;\n-  void visit (AST::TraitItemMethod &item) override;\n-  void visit (AST::TraitItemConst &item) override;\n-  void visit (AST::TraitItemType &item) override;\n-  void visit (AST::Trait &trait) override;\n-  void visit (AST::InherentImpl &impl) override;\n-  void visit (AST::TraitImpl &impl) override;\n-  //  void visit(ExternalItem& item) override;\n-  void visit (AST::ExternalStaticItem &item) override;\n-  void visit (AST::ExternalFunctionItem &item) override;\n-  void visit (AST::ExternBlock &block) override;\n-\n-  // rust-macro.h\n-  void visit (AST::MacroMatchFragment &match) override;\n-  void visit (AST::MacroMatchRepetition &match) override;\n-  void visit (AST::MacroMatcher &matcher) override;\n-  void visit (AST::MacroRulesDefinition &rules_def) override;\n-  void visit (AST::MacroInvocation &macro_invoc) override;\n-  void visit (AST::MetaItemPath &meta_item) override;\n-  void visit (AST::MetaItemSeq &meta_item) override;\n-  void visit (AST::MetaWord &meta_item) override;\n-  void visit (AST::MetaNameValueStr &meta_item) override;\n-  void visit (AST::MetaListPaths &meta_item) override;\n-  void visit (AST::MetaListNameValueStr &meta_item) override;\n-\n-  // rust-pattern.h\n-  void visit (AST::LiteralPattern &pattern) override;\n-  void visit (AST::IdentifierPattern &pattern) override;\n-  void visit (AST::WildcardPattern &pattern) override;\n-  //  void visit(RangePatternBound& bound) override;\n-  void visit (AST::RangePatternBoundLiteral &bound) override;\n-  void visit (AST::RangePatternBoundPath &bound) override;\n-  void visit (AST::RangePatternBoundQualPath &bound) override;\n-  void visit (AST::RangePattern &pattern) override;\n-  void visit (AST::ReferencePattern &pattern) override;\n-  //  void visit(StructPatternField& field) override;\n-  void visit (AST::StructPatternFieldTuplePat &field) override;\n-  void visit (AST::StructPatternFieldIdentPat &field) override;\n-  void visit (AST::StructPatternFieldIdent &field) override;\n-  void visit (AST::StructPattern &pattern) override;\n-  //  void visit(TupleStructItems& tuple_items) override;\n-  void visit (AST::TupleStructItemsNoRange &tuple_items) override;\n-  void visit (AST::TupleStructItemsRange &tuple_items) override;\n-  void visit (AST::TupleStructPattern &pattern) override;\n-  //  void visit(TuplePatternItems& tuple_items) override;\n-  void visit (AST::TuplePatternItemsMultiple &tuple_items) override;\n-  void visit (AST::TuplePatternItemsRanged &tuple_items) override;\n-  void visit (AST::TuplePattern &pattern) override;\n-  void visit (AST::GroupedPattern &pattern) override;\n-  void visit (AST::SlicePattern &pattern) override;\n-\n-  // rust-stmt.h\n-  void visit (AST::EmptyStmt &stmt) override;\n-  void visit (AST::LetStmt &stmt) override;\n-  void visit (AST::ExprStmtWithoutBlock &stmt) override;\n-  void visit (AST::ExprStmtWithBlock &stmt) override;\n-\n-  // rust-type.h\n-  void visit (AST::TraitBound &bound) override;\n-  void visit (AST::ImplTraitType &type) override;\n-  void visit (AST::TraitObjectType &type) override;\n-  void visit (AST::ParenthesisedType &type) override;\n-  void visit (AST::ImplTraitTypeOneBound &type) override;\n-  void visit (AST::TraitObjectTypeOneBound &type) override;\n-  void visit (AST::TupleType &type) override;\n-  void visit (AST::NeverType &type) override;\n-  void visit (AST::RawPointerType &type) override;\n-  void visit (AST::ReferenceType &type) override;\n-  void visit (AST::ArrayType &type) override;\n-  void visit (AST::SliceType &type) override;\n-  void visit (AST::InferredType &type) override;\n-  void visit (AST::BareFunctionType &type) override;\n-\n-private:\n-  NameResolution (AST::Crate &crate, TopLevelScan &toplevel);\n-  bool go () override;\n-  void process_names ();\n-  void process_work_list ();\n-  void expand_macros ();\n-  bool is_work_list_changed () { return is_work_list_changed_; }\n-  std::list<AST::UseDeclaration> work_list_;\n-  bool is_work_list_changed_;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "731801a03c3786a8fcfd5a7959d4f410bf2ca83d", "filename": "gcc/rust/analysis/rust-resolution.cc", "status": "removed", "additions": 0, "deletions": 867, "changes": 867, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-resolution.cc?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -1,867 +0,0 @@\n-#include \"rust-resolution.h\"\n-#include \"rust-diagnostics.h\"\n-\n-#define ADD_BUILTIN_TYPE(_X, _S)                                               \\\n-  do                                                                           \\\n-    {                                                                          \\\n-      AST::PathIdentSegment seg (_X);                                          \\\n-      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n-\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n-\t\t\t\t  Linemap::unknown_location ()));              \\\n-      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n-      segs.push_back (::std::move (typePath));                                 \\\n-      auto bType = new AST::TypePath (::std::move (segs),                      \\\n-\t\t\t\t      Linemap::unknown_location (), false);    \\\n-      _S.Insert (_X, bType);                                                   \\\n-    }                                                                          \\\n-  while (0)\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-TypeResolution::TypeResolution (AST::Crate &crate, TopLevelScan &toplevel)\n-  : crate (crate), toplevel (toplevel)\n-{\n-  typeScope.Push ();\n-  scope.Push ();\n-\n-  // push all builtin types - this is probably too basic for future needs\n-  ADD_BUILTIN_TYPE (\"u8\", typeScope);\n-  ADD_BUILTIN_TYPE (\"u16\", typeScope);\n-  ADD_BUILTIN_TYPE (\"u32\", typeScope);\n-  ADD_BUILTIN_TYPE (\"u64\", typeScope);\n-\n-  ADD_BUILTIN_TYPE (\"i8\", typeScope);\n-  ADD_BUILTIN_TYPE (\"i16\", typeScope);\n-  ADD_BUILTIN_TYPE (\"i32\", typeScope);\n-  ADD_BUILTIN_TYPE (\"i64\", typeScope);\n-\n-  ADD_BUILTIN_TYPE (\"f32\", typeScope);\n-  ADD_BUILTIN_TYPE (\"f64\", typeScope);\n-\n-  ADD_BUILTIN_TYPE (\"char\", typeScope);\n-  ADD_BUILTIN_TYPE (\"str\", typeScope);\n-  ADD_BUILTIN_TYPE (\"bool\", typeScope);\n-}\n-\n-TypeResolution::~TypeResolution ()\n-{\n-  typeScope.Pop ();\n-  scope.Pop ();\n-}\n-\n-bool\n-TypeResolution::ResolveNamesAndTypes (AST::Crate &crate, TopLevelScan &toplevel)\n-{\n-  TypeResolution resolver (crate, toplevel);\n-  return resolver.go ();\n-}\n-\n-bool\n-TypeResolution::go ()\n-{\n-  for (auto &item : crate.items)\n-    item->accept_vis (*this);\n-\n-  return true;\n-}\n-\n-bool\n-TypeResolution::typesAreCompatible (AST::Type *lhs, AST::Type *rhs,\n-\t\t\t\t    Location locus)\n-{\n-  lhs->accept_vis (*this);\n-  rhs->accept_vis (*this);\n-\n-  auto rhsTypeStr = typeComparisonBuffer.back ();\n-  typeComparisonBuffer.pop_back ();\n-  auto lhsTypeStr = typeComparisonBuffer.back ();\n-  typeComparisonBuffer.pop_back ();\n-\n-  // FIXME this needs to handle the cases of an i8 going into an i32 which is\n-  // compatible\n-  if (lhsTypeStr.compare (rhsTypeStr))\n-    {\n-      rust_error_at (locus, \"E0308: expected: %s, found %s\",\n-\t\t     lhsTypeStr.c_str (), rhsTypeStr.c_str ());\n-      return false;\n-    }\n-\n-  return true;\n-}\n-\n-void\n-TypeResolution::visit (AST::Token &tok)\n-{}\n-\n-void\n-TypeResolution::visit (AST::DelimTokenTree &delim_tok_tree)\n-{}\n-\n-void\n-TypeResolution::visit (AST::AttrInputMetaItemContainer &input)\n-{}\n-\n-void\n-TypeResolution::visit (AST::IdentifierExpr &ident_expr)\n-{\n-  AST::Type *type = NULL;\n-  bool ok = scope.Lookup (ident_expr.ident, &type);\n-  if (!ok)\n-    {\n-      rust_error_at (ident_expr.locus, \"unknown identifier\");\n-      return;\n-    }\n-\n-  typeBuffer.push_back (type);\n-}\n-\n-void\n-TypeResolution::visit (AST::Lifetime &lifetime)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LifetimeParam &lifetime_param)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MacroInvocationSemi &macro)\n-{}\n-\n-// rust-path.h\n-void\n-TypeResolution::visit (AST::PathInExpression &path)\n-{\n-  printf (\"PathInExpression: %s\\n\", path.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::TypePathSegment &segment)\n-{}\n-void\n-TypeResolution::visit (AST::TypePathSegmentGeneric &segment)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypePathSegmentFunction &segment)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypePath &path)\n-{\n-  // this may not be robust enough for type comparisons but lets try it for now\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-void\n-TypeResolution::visit (AST::QualifiedPathInExpression &path)\n-{\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-void\n-TypeResolution::visit (AST::QualifiedPathInType &path)\n-{\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-// rust-expr.h\n-void\n-TypeResolution::visit (AST::LiteralExpr &expr)\n-{\n-  std::string type;\n-  switch (expr.literal.get_lit_type ())\n-    {\n-    case AST::Literal::CHAR:\n-      type = \"char\";\n-      break;\n-\n-    case AST::Literal::STRING:\n-    case AST::Literal::RAW_STRING:\n-      type = \"str\";\n-      break;\n-\n-    case AST::Literal::BOOL:\n-      type = \"bool\";\n-      break;\n-\n-    case AST::Literal::BYTE:\n-      type = \"u8\";\n-      break;\n-\n-      // FIXME these are not always going to be the case\n-      // eg: suffix on the value can change the type\n-    case AST::Literal::FLOAT:\n-      type = \"f32\";\n-      break;\n-\n-    case AST::Literal::INT:\n-      type = \"i32\";\n-      break;\n-\n-    case AST::Literal::BYTE_STRING:\n-    case AST::Literal::RAW_BYTE_STRING:\n-      // FIXME\n-      break;\n-    }\n-\n-  if (type.empty ())\n-    {\n-      rust_error_at (expr.locus, \"unknown literal: %s\",\n-\t\t     expr.literal.as_string ().c_str ());\n-      return;\n-    }\n-\n-  AST::Type *val = NULL;\n-  bool ok = typeScope.Lookup (type, &val);\n-  if (ok)\n-    typeBuffer.push_back (val);\n-  else\n-    rust_error_at (expr.locus, \"unknown literal type: %s\", type.c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::AttrInputLiteral &attr_input)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MetaItemLitExpr &meta_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MetaItemPathLit &meta_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::BorrowExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::DereferenceExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ErrorPropagationExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::NegationExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{\n-  size_t before;\n-  before = typeBuffer.size ();\n-  expr.visit_lhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.locus, \"unable to determine lhs type\");\n-      return;\n-    }\n-\n-  auto lhsType = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  before = typeBuffer.size ();\n-  expr.visit_rhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.locus, \"unable to determine rhs type\");\n-      return;\n-    }\n-\n-  auto rhsType = typeBuffer.back ();\n-  // not poping because we will be checking they match and the\n-  // scope will require knowledge of the type\n-\n-  // do the lhsType and the rhsType match\n-  typesAreCompatible (lhsType, rhsType, expr.right_expr->get_locus_slow ());\n-}\n-\n-void\n-TypeResolution::visit (AST::ComparisonExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LazyBooleanExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypeCastExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::AssignmentExpr &expr)\n-{\n-  size_t before;\n-  before = typeBuffer.size ();\n-  expr.visit_lhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.locus, \"unable to determine lhs type\");\n-      return;\n-    }\n-\n-  auto lhsType = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  before = typeBuffer.size ();\n-  expr.visit_rhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.locus, \"unable to determine rhs type\");\n-      return;\n-    }\n-\n-  auto rhsType = typeBuffer.back ();\n-  // not poping because we will be checking they match and the\n-  // scope will require knowledge of the type\n-\n-  // do the lhsType and the rhsType match\n-  if (!typesAreCompatible (lhsType, rhsType,\n-\t\t\t   expr.right_expr->get_locus_slow ()))\n-    return;\n-\n-  // is the lhs mutable?\n-}\n-\n-void\n-TypeResolution::visit (AST::CompoundAssignmentExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::GroupedExpr &expr)\n-{}\n-// void TypeResolution::visit(ArrayElems& elems) {}\n-void\n-TypeResolution::visit (AST::ArrayElemsValues &elems)\n-{}\n-void\n-TypeResolution::visit (AST::ArrayElemsCopied &elems)\n-{}\n-void\n-TypeResolution::visit (AST::ArrayExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ArrayIndexExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::TupleExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::TupleIndexExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprStruct &expr)\n-{}\n-// void TypeResolution::visit(StructExprField& field) {}\n-void\n-TypeResolution::visit (AST::StructExprFieldIdentifier &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprFieldIdentifierValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprFieldIndexValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprStructFields &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprStructBase &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprTuple &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprUnit &expr)\n-{}\n-// void TypeResolution::visit(EnumExprField& field) {}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIdentifier &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIdentifierValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIndexValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprStruct &expr)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprTuple &expr)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldless &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::CallExpr &expr)\n-{\n-  printf (\"CallExpr: %s\\n\", expr.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::MethodCallExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::FieldAccessExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ClosureExprInner &expr)\n-{}\n-void\n-TypeResolution::visit (AST::BlockExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ClosureExprInnerTyped &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ContinueExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::BreakExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromToExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeToExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFullExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromToInclExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeToInclExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ReturnExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::UnsafeBlockExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::LoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::WhileLoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::WhileLetLoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ForLoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfExprConseqElse &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfExprConseqIf &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfExprConseqIfLet &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqElse &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqIf &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqIfLet &expr)\n-{}\n-// void TypeResolution::visit(MatchCase& match_case) {}\n-void\n-TypeResolution::visit (AST::MatchCaseBlockExpr &match_case)\n-{}\n-void\n-TypeResolution::visit (AST::MatchCaseExpr &match_case)\n-{}\n-void\n-TypeResolution::visit (AST::MatchExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::AwaitExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::AsyncBlockExpr &expr)\n-{}\n-\n-// rust-item.h\n-void\n-TypeResolution::visit (AST::TypeParam &param)\n-{}\n-// void TypeResolution::visit(WhereClauseItem& item) {}\n-void\n-TypeResolution::visit (AST::LifetimeWhereClauseItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::TypeBoundWhereClauseItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::Method &method)\n-{}\n-void\n-TypeResolution::visit (AST::ModuleBodied &module)\n-{}\n-void\n-TypeResolution::visit (AST::ModuleNoBody &module)\n-{}\n-void\n-TypeResolution::visit (AST::ExternCrate &crate)\n-{}\n-// void TypeResolution::visit(UseTree& use_tree) {}\n-void\n-TypeResolution::visit (AST::UseTreeGlob &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseTreeList &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseTreeRebind &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseDeclaration &use_decl)\n-{}\n-\n-void\n-TypeResolution::visit (AST::Function &function)\n-{\n-  // always emit the function with return type in the event of nil return type\n-  // its  a marker for a void function\n-  scope.Insert (function.function_name, function.return_type.get ());\n-\n-  scope.Push ();\n-  for (auto &param : function.function_params)\n-    {\n-      auto before = letPatternBuffer.size ();\n-      param.param_name->accept_vis (*this);\n-      if (letPatternBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (param.locus, \"failed to analyse parameter name\");\n-\t  return;\n-\t}\n-\n-      auto paramName = letPatternBuffer.back ();\n-      letPatternBuffer.pop_back ();\n-      scope.Insert (paramName.variable_ident, param.type.get ());\n-    }\n-\n-  // walk the expression body\n-  for (auto &stmt : function.function_body->statements)\n-    {\n-      stmt->accept_vis (*this);\n-    }\n-\n-  scope.Pop ();\n-}\n-\n-void\n-TypeResolution::visit (AST::TypeAlias &type_alias)\n-{}\n-void\n-TypeResolution::visit (AST::StructStruct &struct_item)\n-{}\n-void\n-TypeResolution::visit (AST::TupleStruct &tuple_struct)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemTuple &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemStruct &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemDiscriminant &item)\n-{}\n-void\n-TypeResolution::visit (AST::Enum &enum_item)\n-{}\n-void\n-TypeResolution::visit (AST::Union &union_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ConstantItem &const_item)\n-{\n-  printf (\"ConstantItem: %s\\n\", const_item.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::StaticItem &static_item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemFunc &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemMethod &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemConst &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemType &item)\n-{}\n-void\n-TypeResolution::visit (AST::Trait &trait)\n-{}\n-void\n-TypeResolution::visit (AST::InherentImpl &impl)\n-{}\n-void\n-TypeResolution::visit (AST::TraitImpl &impl)\n-{}\n-// void TypeResolution::visit(ExternalItem& item) {}\n-void\n-TypeResolution::visit (AST::ExternalStaticItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::ExternalFunctionItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::ExternBlock &block)\n-{}\n-\n-// rust-macro.h\n-void\n-TypeResolution::visit (AST::MacroMatchFragment &match)\n-{}\n-void\n-TypeResolution::visit (AST::MacroMatchRepetition &match)\n-{}\n-void\n-TypeResolution::visit (AST::MacroMatcher &matcher)\n-{}\n-void\n-TypeResolution::visit (AST::MacroRulesDefinition &rules_def)\n-{}\n-void\n-TypeResolution::visit (AST::MacroInvocation &macro_invoc)\n-{}\n-void\n-TypeResolution::visit (AST::MetaItemPath &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaItemSeq &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaWord &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaNameValueStr &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaListPaths &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaListNameValueStr &meta_item)\n-{}\n-\n-// rust-pattern.h\n-void\n-TypeResolution::visit (AST::LiteralPattern &pattern)\n-{\n-  printf (\"LiteralPattern: %s\\n\", pattern.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::IdentifierPattern &pattern)\n-{\n-  letPatternBuffer.push_back (pattern);\n-}\n-\n-void\n-TypeResolution::visit (AST::WildcardPattern &pattern)\n-{}\n-// void TypeResolution::visit(RangePatternBound& bound) {}\n-void\n-TypeResolution::visit (AST::RangePatternBoundLiteral &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePatternBoundPath &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePatternBoundQualPath &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::ReferencePattern &pattern)\n-{}\n-// void TypeResolution::visit(StructPatternField& field) {}\n-void\n-TypeResolution::visit (AST::StructPatternFieldTuplePat &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPatternFieldIdentPat &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPatternFieldIdent &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPattern &pattern)\n-{}\n-// void TypeResolution::visit(TupleStructItems& tuple_items) {}\n-void\n-TypeResolution::visit (AST::TupleStructItemsNoRange &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TupleStructItemsRange &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TupleStructPattern &pattern)\n-{}\n-// void TypeResolution::visit(TuplePatternItems& tuple_items) {}\n-void\n-TypeResolution::visit (AST::TuplePatternItemsMultiple &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TuplePatternItemsRanged &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TuplePattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::GroupedPattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::SlicePattern &pattern)\n-{}\n-\n-// rust-stmt.h\n-void\n-TypeResolution::visit (AST::EmptyStmt &stmt)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LetStmt &stmt)\n-{\n-  if (!stmt.has_init_expr () && !stmt.has_type ())\n-    {\n-      rust_error_at (stmt.locus,\n-\t\t     \"E0282: type annotations or init expression needed\");\n-      return;\n-    }\n-\n-  AST::Type *inferedType = NULL;\n-  if (stmt.has_init_expr ())\n-    {\n-      stmt.init_expr->accept_vis (*this);\n-\n-      if (typeBuffer.empty ())\n-\t{\n-\t  rust_error_at (\n-\t    stmt.init_expr->get_locus_slow (),\n-\t    \"unable to determine type for declaration from init expr\");\n-\t  return;\n-\t}\n-\n-      inferedType = typeBuffer.back ();\n-      typeBuffer.pop_back ();\n-    }\n-\n-  if (stmt.has_type () && stmt.has_init_expr ())\n-    {\n-      if (!typesAreCompatible (stmt.type.get (), inferedType,\n-\t\t\t       stmt.init_expr->get_locus_slow ()))\n-\t{\n-\t  return;\n-\t}\n-    }\n-  else if (stmt.has_type () && !stmt.has_init_expr ())\n-    {\n-      inferedType = stmt.type.get ();\n-    }\n-\n-  // TODO check we know what the type is in the scope requires the builtins to\n-  // be defined at the constructor\n-\n-  // ensure the decl has the type set for compilation later on\n-  if (!stmt.has_type ())\n-    {\n-      // FIXME\n-      // stmt.type = inferedType;\n-    }\n-\n-  // get all the names part of this declaration and add the types to the scope\n-  stmt.variables_pattern->accept_vis (*this);\n-  for (auto it = letPatternBuffer.begin (); it != letPatternBuffer.end (); it++)\n-    {\n-      scope.Insert (it->variable_ident, inferedType);\n-    }\n-  letPatternBuffer.clear ();\n-}\n-\n-void\n-TypeResolution::visit (AST::ExprStmtWithoutBlock &stmt)\n-{\n-  stmt.expr->accept_vis (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::ExprStmtWithBlock &stmt)\n-{}\n-\n-// rust-type.h\n-void\n-TypeResolution::visit (AST::TraitBound &bound)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ImplTraitType &type)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TraitObjectType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ParenthesisedType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ImplTraitTypeOneBound &type)\n-{}\n-void\n-TypeResolution::visit (AST::TraitObjectTypeOneBound &type)\n-{}\n-void\n-TypeResolution::visit (AST::TupleType &type)\n-{}\n-void\n-TypeResolution::visit (AST::NeverType &type)\n-{}\n-void\n-TypeResolution::visit (AST::RawPointerType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ReferenceType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ArrayType &type)\n-{}\n-void\n-TypeResolution::visit (AST::SliceType &type)\n-{}\n-void\n-TypeResolution::visit (AST::InferredType &type)\n-{}\n-void\n-TypeResolution::visit (AST::BareFunctionType &type)\n-{}\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "9eb4b95a6fcf31c5cb3ffd487639308938740831", "filename": "gcc/rust/analysis/rust-resolution.h", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-resolution.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -1,51 +0,0 @@\n-#pragma once\n-\n-#include \"rust-system.h\"\n-#include \"rust-ast-full.h\"\n-#include \"rust-ast-visitor.h\"\n-#include \"rust-scan.h\"\n-#include \"scope.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-class Resolution : public AST::ASTVisitor\n-{\n-public:\n-  virtual ~Resolution ()\n-  {\n-    scope.Pop ();\n-    valueScope.Pop ();\n-    macroScope.Pop ();\n-    typeScope.Pop ();\n-  };\n-\n-private:\n-  virtual bool go () = 0;\n-\n-protected:\n-  Resolution (AST::Crate &crate, TopLevelScan &toplevel)\n-    : crate (crate), toplevel (toplevel)\n-  {\n-    scope.Push ();\n-    valueScope.Push ();\n-    macroScope.Push ();\n-    typeScope.Push ();\n-  };\n-\n-  Scope<AST::Type *> scope;\n-  Scope<AST::Type *> valueScope;\n-  Scope<AST::Type *> macroScope;\n-  Scope<AST::Type *> typeScope;\n-\n-  AST::Crate &crate;\n-  TopLevelScan &toplevel;\n-\n-  std::vector<AST::IdentifierPattern> letPatternBuffer;\n-  std::vector<AST::Type *> typeBuffer;\n-  std::vector<std::string> typeComparisonBuffer;\n-  std::vector<AST::Function *> functionLookup;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "31c89e499f791da1cafdf41c4e447c21097561ba", "filename": "gcc/rust/analysis/rust-scan.cc", "status": "removed", "additions": 0, "deletions": 593, "changes": 593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-scan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-scan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-scan.cc?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -1,593 +0,0 @@\n-#include \"rust-scan.h\"\n-#include \"rust-diagnostics.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-TopLevelScan::TopLevelScan (AST::Crate &crate) : crate (crate)\n-{\n-  for (auto &item : crate.items)\n-    item->accept_vis (*this);\n-}\n-\n-TopLevelScan::~TopLevelScan () {}\n-\n-AST::Function *\n-TopLevelScan::lookupFunction (AST::Expr *expr)\n-{\n-  auto before = fnLookup.size ();\n-  expr->accept_vis (*this);\n-  if (fnLookup.size () > before)\n-    {\n-      AST::Function *fndecl = fnLookup.back ();\n-      fnLookup.pop_back ();\n-      return fndecl;\n-    }\n-  return NULL;\n-}\n-\n-void\n-TopLevelScan::visit (AST::Token &tok)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::DelimTokenTree &delim_tok_tree)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::AttrInputMetaItemContainer &input)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::IdentifierExpr &ident_expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::Lifetime &lifetime)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::LifetimeParam &lifetime_param)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::MacroInvocationSemi &macro)\n-{}\n-\n-// rust-path.h\n-void\n-TopLevelScan::visit (AST::PathInExpression &path)\n-{\n-  auto it = functions.find (path.as_string ());\n-  bool foundFndecl = it != functions.end ();\n-  if (foundFndecl)\n-    {\n-      fnLookup.push_back (it->second);\n-      return;\n-    }\n-}\n-\n-void\n-TopLevelScan::visit (AST::TypePathSegment &segment)\n-{}\n-void\n-TopLevelScan::visit (AST::TypePathSegmentGeneric &segment)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::TypePathSegmentFunction &segment)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::TypePath &path)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::QualifiedPathInExpression &path)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::QualifiedPathInType &path)\n-{}\n-\n-// rust-expr.h\n-void\n-TopLevelScan::visit (AST::LiteralExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::AttrInputLiteral &attr_input)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::MetaItemLitExpr &meta_item)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::MetaItemPathLit &meta_item)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::BorrowExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::DereferenceExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ErrorPropagationExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::NegationExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ComparisonExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::LazyBooleanExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::TypeCastExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::AssignmentExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::CompoundAssignmentExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::GroupedExpr &expr)\n-{}\n-// void TopLevelScan::visit(ArrayElems& elems) {}\n-void\n-TopLevelScan::visit (AST::ArrayElemsValues &elems)\n-{}\n-void\n-TopLevelScan::visit (AST::ArrayElemsCopied &elems)\n-{}\n-void\n-TopLevelScan::visit (AST::ArrayExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ArrayIndexExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleIndexExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprStruct &expr)\n-{}\n-// void TopLevelScan::visit(StructExprField& field) {}\n-void\n-TopLevelScan::visit (AST::StructExprFieldIdentifier &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprFieldIdentifierValue &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprFieldIndexValue &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprStructFields &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprStructBase &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprTuple &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprUnit &expr)\n-{}\n-// void TopLevelScan::visit(EnumExprField& field) {}\n-void\n-TopLevelScan::visit (AST::EnumExprFieldIdentifier &field)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumExprFieldIdentifierValue &field)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumExprFieldIndexValue &field)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumExprStruct &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumExprTuple &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumExprFieldless &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::CallExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::MethodCallExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::FieldAccessExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ClosureExprInner &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::BlockExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ClosureExprInnerTyped &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ContinueExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::BreakExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeFromToExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeFromExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeToExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeFullExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeFromToInclExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeToInclExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ReturnExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::UnsafeBlockExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::LoopExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::WhileLoopExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::WhileLetLoopExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ForLoopExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfExprConseqElse &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfExprConseqIf &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfExprConseqIfLet &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfLetExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfLetExprConseqElse &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfLetExprConseqIf &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfLetExprConseqIfLet &expr)\n-{}\n-// void TopLevelScan::visit(MatchCase& match_case) {}\n-/*void\n-TopLevelScan::visit (AST::MatchCaseBlockExpr &match_case)\n-{}*/\n-/*void\n-TopLevelScan::visit (AST::MatchCaseExpr &match_case)\n-{}*/\n-void\n-TopLevelScan::visit (AST::MatchExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::AwaitExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::AsyncBlockExpr &expr)\n-{}\n-\n-// rust-item.h\n-void\n-TopLevelScan::visit (AST::TypeParam &param)\n-{}\n-// void TopLevelScan::visit(WhereClauseItem& item) {}\n-void\n-TopLevelScan::visit (AST::LifetimeWhereClauseItem &item)\n-{}\n-void\n-TopLevelScan::visit (AST::TypeBoundWhereClauseItem &item)\n-{}\n-void\n-TopLevelScan::visit (AST::Method &method)\n-{}\n-void\n-TopLevelScan::visit (AST::ModuleBodied &module)\n-{}\n-void\n-TopLevelScan::visit (AST::ModuleNoBody &module)\n-{}\n-void\n-TopLevelScan::visit (AST::ExternCrate &crate)\n-{}\n-// void TopLevelScan::visit(UseTree& use_tree) {}\n-void\n-TopLevelScan::visit (AST::UseTreeGlob &use_tree)\n-{}\n-void\n-TopLevelScan::visit (AST::UseTreeList &use_tree)\n-{}\n-void\n-TopLevelScan::visit (AST::UseTreeRebind &use_tree)\n-{}\n-void\n-TopLevelScan::visit (AST::UseDeclaration &use_decl)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::Function &function)\n-{\n-  functions[function.get_function_name ()] = &function;\n-}\n-\n-void\n-TopLevelScan::visit (AST::TypeAlias &type_alias)\n-{}\n-void\n-TopLevelScan::visit (AST::StructStruct &struct_item)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleStruct &tuple_struct)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumItem &item)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumItemTuple &item)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumItemStruct &item)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumItemDiscriminant &item)\n-{}\n-void\n-TopLevelScan::visit (AST::Enum &enum_item)\n-{}\n-void\n-TopLevelScan::visit (AST::Union &union_item)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ConstantItem &const_item)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::StaticItem &static_item)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitItemFunc &item)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitItemMethod &item)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitItemConst &item)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitItemType &item)\n-{}\n-void\n-TopLevelScan::visit (AST::Trait &trait)\n-{}\n-void\n-TopLevelScan::visit (AST::InherentImpl &impl)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitImpl &impl)\n-{}\n-// void TopLevelScan::visit(ExternalItem& item) {}\n-void\n-TopLevelScan::visit (AST::ExternalStaticItem &item)\n-{}\n-void\n-TopLevelScan::visit (AST::ExternalFunctionItem &item)\n-{}\n-void\n-TopLevelScan::visit (AST::ExternBlock &block)\n-{}\n-\n-// rust-macro.h\n-void\n-TopLevelScan::visit (AST::MacroMatchFragment &match)\n-{}\n-void\n-TopLevelScan::visit (AST::MacroMatchRepetition &match)\n-{}\n-void\n-TopLevelScan::visit (AST::MacroMatcher &matcher)\n-{}\n-void\n-TopLevelScan::visit (AST::MacroRulesDefinition &rules_def)\n-{}\n-void\n-TopLevelScan::visit (AST::MacroInvocation &macro_invoc)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaItemPath &meta_item)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaItemSeq &meta_item)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaWord &meta_item)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaNameValueStr &meta_item)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaListPaths &meta_item)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaListNameValueStr &meta_item)\n-{}\n-\n-// rust-pattern.h\n-void\n-TopLevelScan::visit (AST::LiteralPattern &pattern)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::IdentifierPattern &pattern)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::WildcardPattern &pattern)\n-{}\n-// void TopLevelScan::visit(RangePatternBound& bound) {}\n-void\n-TopLevelScan::visit (AST::RangePatternBoundLiteral &bound)\n-{}\n-void\n-TopLevelScan::visit (AST::RangePatternBoundPath &bound)\n-{}\n-void\n-TopLevelScan::visit (AST::RangePatternBoundQualPath &bound)\n-{}\n-void\n-TopLevelScan::visit (AST::RangePattern &pattern)\n-{}\n-void\n-TopLevelScan::visit (AST::ReferencePattern &pattern)\n-{}\n-// void TopLevelScan::visit(StructPatternField& field) {}\n-void\n-TopLevelScan::visit (AST::StructPatternFieldTuplePat &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructPatternFieldIdentPat &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructPatternFieldIdent &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructPattern &pattern)\n-{}\n-// void TopLevelScan::visit(TupleStructItems& tuple_items) {}\n-void\n-TopLevelScan::visit (AST::TupleStructItemsNoRange &tuple_items)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleStructItemsRange &tuple_items)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleStructPattern &pattern)\n-{}\n-// void TopLevelScan::visit(TuplePatternItems& tuple_items) {}\n-void\n-TopLevelScan::visit (AST::TuplePatternItemsMultiple &tuple_items)\n-{}\n-void\n-TopLevelScan::visit (AST::TuplePatternItemsRanged &tuple_items)\n-{}\n-void\n-TopLevelScan::visit (AST::TuplePattern &pattern)\n-{}\n-void\n-TopLevelScan::visit (AST::GroupedPattern &pattern)\n-{}\n-void\n-TopLevelScan::visit (AST::SlicePattern &pattern)\n-{}\n-\n-// rust-stmt.h\n-void\n-TopLevelScan::visit (AST::EmptyStmt &stmt)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::LetStmt &stmt)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ExprStmtWithoutBlock &stmt)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ExprStmtWithBlock &stmt)\n-{}\n-\n-// rust-type.h\n-void\n-TopLevelScan::visit (AST::TraitBound &bound)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ImplTraitType &type)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::TraitObjectType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::ParenthesisedType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::ImplTraitTypeOneBound &type)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitObjectTypeOneBound &type)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::NeverType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::RawPointerType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::ReferenceType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::ArrayType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::SliceType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::InferredType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::BareFunctionType &type)\n-{}\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "77beeca86a03e838094af284798475834c7254ce", "filename": "gcc/rust/analysis/rust-scan.h", "status": "removed", "additions": 0, "deletions": 233, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-scan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-scan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-scan.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -1,233 +0,0 @@\n-#pragma once\n-\n-#include \"rust-system.h\"\n-#include \"rust-ast-full.h\"\n-#include \"rust-ast-visitor.h\"\n-#include \"scope.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-class TopLevelScan : public AST::ASTVisitor\n-{\n-public:\n-  TopLevelScan (AST::Crate &crate);\n-\n-  ~TopLevelScan ();\n-\n-  AST::Function *lookupFunction (AST::Expr *expr);\n-\n-  // visitor impl\n-  // rust-ast.h\n-  // virtual void visit(AttrInput& attr_input);\n-  // virtual void visit(TokenTree& token_tree);\n-  // virtual void visit(MacroMatch& macro_match);\n-  virtual void visit (AST::Token &tok);\n-  virtual void visit (AST::DelimTokenTree &delim_tok_tree);\n-  virtual void visit (AST::AttrInputMetaItemContainer &input);\n-  // virtual void visit(MetaItem& meta_item);\n-  // virtual void vsit(Stmt& stmt);\n-  // virtual void visit(Expr& expr);\n-  virtual void visit (AST::IdentifierExpr &ident_expr);\n-  // virtual void visit(Pattern& pattern);\n-  // virtual void visit(Type& type);\n-  // virtual void visit(TypeParamBound& type_param_bound);\n-  virtual void visit (AST::Lifetime &lifetime);\n-  // virtual void visit(GenericParam& generic_param);\n-  virtual void visit (AST::LifetimeParam &lifetime_param);\n-  // virtual void visit(TraitItem& trait_item);\n-  // virtual void visit(InherentImplItem& inherent_impl_item);\n-  // virtual void visit(TraitImplItem& trait_impl_item);\n-  virtual void visit (AST::MacroInvocationSemi &macro);\n-\n-  // rust-path.h\n-  virtual void visit (AST::PathInExpression &path);\n-  virtual void visit (AST::TypePathSegment &segment);\n-  virtual void visit (AST::TypePathSegmentGeneric &segment);\n-  virtual void visit (AST::TypePathSegmentFunction &segment);\n-  virtual void visit (AST::TypePath &path);\n-  virtual void visit (AST::QualifiedPathInExpression &path);\n-  virtual void visit (AST::QualifiedPathInType &path);\n-\n-  // rust-expr.h\n-  virtual void visit (AST::LiteralExpr &expr);\n-  virtual void visit (AST::AttrInputLiteral &attr_input);\n-  virtual void visit (AST::MetaItemLitExpr &meta_item);\n-  virtual void visit (AST::MetaItemPathLit &meta_item);\n-  virtual void visit (AST::BorrowExpr &expr);\n-  virtual void visit (AST::DereferenceExpr &expr);\n-  virtual void visit (AST::ErrorPropagationExpr &expr);\n-  virtual void visit (AST::NegationExpr &expr);\n-  virtual void visit (AST::ArithmeticOrLogicalExpr &expr);\n-  virtual void visit (AST::ComparisonExpr &expr);\n-  virtual void visit (AST::LazyBooleanExpr &expr);\n-  virtual void visit (AST::TypeCastExpr &expr);\n-  virtual void visit (AST::AssignmentExpr &expr);\n-  virtual void visit (AST::CompoundAssignmentExpr &expr);\n-  virtual void visit (AST::GroupedExpr &expr);\n-  // virtual void visit(ArrayElems& elems);\n-  virtual void visit (AST::ArrayElemsValues &elems);\n-  virtual void visit (AST::ArrayElemsCopied &elems);\n-  virtual void visit (AST::ArrayExpr &expr);\n-  virtual void visit (AST::ArrayIndexExpr &expr);\n-  virtual void visit (AST::TupleExpr &expr);\n-  virtual void visit (AST::TupleIndexExpr &expr);\n-  virtual void visit (AST::StructExprStruct &expr);\n-  // virtual void visit(StructExprField& field);\n-  virtual void visit (AST::StructExprFieldIdentifier &field);\n-  virtual void visit (AST::StructExprFieldIdentifierValue &field);\n-  virtual void visit (AST::StructExprFieldIndexValue &field);\n-  virtual void visit (AST::StructExprStructFields &expr);\n-  virtual void visit (AST::StructExprStructBase &expr);\n-  virtual void visit (AST::StructExprTuple &expr);\n-  virtual void visit (AST::StructExprUnit &expr);\n-  // virtual void visit(EnumExprField& field);\n-  virtual void visit (AST::EnumExprFieldIdentifier &field);\n-  virtual void visit (AST::EnumExprFieldIdentifierValue &field);\n-  virtual void visit (AST::EnumExprFieldIndexValue &field);\n-  virtual void visit (AST::EnumExprStruct &expr);\n-  virtual void visit (AST::EnumExprTuple &expr);\n-  virtual void visit (AST::EnumExprFieldless &expr);\n-  virtual void visit (AST::CallExpr &expr);\n-  virtual void visit (AST::MethodCallExpr &expr);\n-  virtual void visit (AST::FieldAccessExpr &expr);\n-  virtual void visit (AST::ClosureExprInner &expr);\n-  virtual void visit (AST::BlockExpr &expr);\n-  virtual void visit (AST::ClosureExprInnerTyped &expr);\n-  virtual void visit (AST::ContinueExpr &expr);\n-  virtual void visit (AST::BreakExpr &expr);\n-  virtual void visit (AST::RangeFromToExpr &expr);\n-  virtual void visit (AST::RangeFromExpr &expr);\n-  virtual void visit (AST::RangeToExpr &expr);\n-  virtual void visit (AST::RangeFullExpr &expr);\n-  virtual void visit (AST::RangeFromToInclExpr &expr);\n-  virtual void visit (AST::RangeToInclExpr &expr);\n-  virtual void visit (AST::ReturnExpr &expr);\n-  virtual void visit (AST::UnsafeBlockExpr &expr);\n-  virtual void visit (AST::LoopExpr &expr);\n-  virtual void visit (AST::WhileLoopExpr &expr);\n-  virtual void visit (AST::WhileLetLoopExpr &expr);\n-  virtual void visit (AST::ForLoopExpr &expr);\n-  virtual void visit (AST::IfExpr &expr);\n-  virtual void visit (AST::IfExprConseqElse &expr);\n-  virtual void visit (AST::IfExprConseqIf &expr);\n-  virtual void visit (AST::IfExprConseqIfLet &expr);\n-  virtual void visit (AST::IfLetExpr &expr);\n-  virtual void visit (AST::IfLetExprConseqElse &expr);\n-  virtual void visit (AST::IfLetExprConseqIf &expr);\n-  virtual void visit (AST::IfLetExprConseqIfLet &expr);\n-  // virtual void visit(MatchCase& match_case);\n-  // virtual void visit (AST::MatchCaseBlockExpr &match_case);\n-  // virtual void visit (AST::MatchCaseExpr &match_case);\n-  virtual void visit (AST::MatchExpr &expr);\n-  virtual void visit (AST::AwaitExpr &expr);\n-  virtual void visit (AST::AsyncBlockExpr &expr);\n-\n-  // rust-item.h\n-  virtual void visit (AST::TypeParam &param);\n-  // virtual void visit(WhereClauseItem& item);\n-  virtual void visit (AST::LifetimeWhereClauseItem &item);\n-  virtual void visit (AST::TypeBoundWhereClauseItem &item);\n-  virtual void visit (AST::Method &method);\n-  virtual void visit (AST::ModuleBodied &module);\n-  virtual void visit (AST::ModuleNoBody &module);\n-  virtual void visit (AST::ExternCrate &crate);\n-  // virtual void visit(UseTree& use_tree);\n-  virtual void visit (AST::UseTreeGlob &use_tree);\n-  virtual void visit (AST::UseTreeList &use_tree);\n-  virtual void visit (AST::UseTreeRebind &use_tree);\n-  virtual void visit (AST::UseDeclaration &use_decl);\n-  virtual void visit (AST::Function &function);\n-  virtual void visit (AST::TypeAlias &type_alias);\n-  virtual void visit (AST::StructStruct &struct_item);\n-  virtual void visit (AST::TupleStruct &tuple_struct);\n-  virtual void visit (AST::EnumItem &item);\n-  virtual void visit (AST::EnumItemTuple &item);\n-  virtual void visit (AST::EnumItemStruct &item);\n-  virtual void visit (AST::EnumItemDiscriminant &item);\n-  virtual void visit (AST::Enum &enum_item);\n-  virtual void visit (AST::Union &union_item);\n-  virtual void visit (AST::ConstantItem &const_item);\n-  virtual void visit (AST::StaticItem &static_item);\n-  virtual void visit (AST::TraitItemFunc &item);\n-  virtual void visit (AST::TraitItemMethod &item);\n-  virtual void visit (AST::TraitItemConst &item);\n-  virtual void visit (AST::TraitItemType &item);\n-  virtual void visit (AST::Trait &trait);\n-  virtual void visit (AST::InherentImpl &impl);\n-  virtual void visit (AST::TraitImpl &impl);\n-  // virtual void visit(ExternalItem& item);\n-  virtual void visit (AST::ExternalStaticItem &item);\n-  virtual void visit (AST::ExternalFunctionItem &item);\n-  virtual void visit (AST::ExternBlock &block);\n-\n-  // rust-macro.h\n-  virtual void visit (AST::MacroMatchFragment &match);\n-  virtual void visit (AST::MacroMatchRepetition &match);\n-  virtual void visit (AST::MacroMatcher &matcher);\n-  virtual void visit (AST::MacroRulesDefinition &rules_def);\n-  virtual void visit (AST::MacroInvocation &macro_invoc);\n-  virtual void visit (AST::MetaItemPath &meta_item);\n-  virtual void visit (AST::MetaItemSeq &meta_item);\n-  virtual void visit (AST::MetaWord &meta_item);\n-  virtual void visit (AST::MetaNameValueStr &meta_item);\n-  virtual void visit (AST::MetaListPaths &meta_item);\n-  virtual void visit (AST::MetaListNameValueStr &meta_item);\n-\n-  // rust-pattern.h\n-  virtual void visit (AST::LiteralPattern &pattern);\n-  virtual void visit (AST::IdentifierPattern &pattern);\n-  virtual void visit (AST::WildcardPattern &pattern);\n-  // virtual void visit(RangePatternBound& bound);\n-  virtual void visit (AST::RangePatternBoundLiteral &bound);\n-  virtual void visit (AST::RangePatternBoundPath &bound);\n-  virtual void visit (AST::RangePatternBoundQualPath &bound);\n-  virtual void visit (AST::RangePattern &pattern);\n-  virtual void visit (AST::ReferencePattern &pattern);\n-  // virtual void visit(StructPatternField& field);\n-  virtual void visit (AST::StructPatternFieldTuplePat &field);\n-  virtual void visit (AST::StructPatternFieldIdentPat &field);\n-  virtual void visit (AST::StructPatternFieldIdent &field);\n-  virtual void visit (AST::StructPattern &pattern);\n-  // virtual void visit(TupleStructItems& tuple_items);\n-  virtual void visit (AST::TupleStructItemsNoRange &tuple_items);\n-  virtual void visit (AST::TupleStructItemsRange &tuple_items);\n-  virtual void visit (AST::TupleStructPattern &pattern);\n-  // virtual void visit(TuplePatternItems& tuple_items);\n-  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items);\n-  virtual void visit (AST::TuplePatternItemsRanged &tuple_items);\n-  virtual void visit (AST::TuplePattern &pattern);\n-  virtual void visit (AST::GroupedPattern &pattern);\n-  virtual void visit (AST::SlicePattern &pattern);\n-\n-  // rust-stmt.h\n-  virtual void visit (AST::EmptyStmt &stmt);\n-  virtual void visit (AST::LetStmt &stmt);\n-  virtual void visit (AST::ExprStmtWithoutBlock &stmt);\n-  virtual void visit (AST::ExprStmtWithBlock &stmt);\n-\n-  // rust-type.h\n-  virtual void visit (AST::TraitBound &bound);\n-  virtual void visit (AST::ImplTraitType &type);\n-  virtual void visit (AST::TraitObjectType &type);\n-  virtual void visit (AST::ParenthesisedType &type);\n-  virtual void visit (AST::ImplTraitTypeOneBound &type);\n-  virtual void visit (AST::TraitObjectTypeOneBound &type);\n-  virtual void visit (AST::TupleType &type);\n-  virtual void visit (AST::NeverType &type);\n-  virtual void visit (AST::RawPointerType &type);\n-  virtual void visit (AST::ReferenceType &type);\n-  virtual void visit (AST::ArrayType &type);\n-  virtual void visit (AST::SliceType &type);\n-  virtual void visit (AST::InferredType &type);\n-  virtual void visit (AST::BareFunctionType &type);\n-\n-private:\n-  std::map<std::string, AST::Function *> functions;\n-  AST::Crate &crate;\n-\n-  std::vector<AST::Function *> fnLookup;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "f1edec822b7258dafee2a34a2a7203e5b44ca783", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "removed", "additions": 0, "deletions": 1348, "changes": 1348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -1,1348 +0,0 @@\n-#include \"rust-type-resolution.h\"\n-#include \"rust-diagnostics.h\"\n-#include \"rust-type-visitor.h\"\n-\n-#define ADD_BUILTIN_TYPE(_X, _S)                                               \\\n-  do                                                                           \\\n-    {                                                                          \\\n-      AST::PathIdentSegment seg (_X);                                          \\\n-      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n-\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n-\t\t\t\t  Linemap::predeclared_location ()));          \\\n-      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n-      segs.push_back (::std::move (typePath));                                 \\\n-      auto bType                                                               \\\n-\t= new AST::TypePath (::std::move (segs),                               \\\n-\t\t\t     Linemap::predeclared_location (), false);         \\\n-      _S.InsertType (_X, bType);                                               \\\n-    }                                                                          \\\n-  while (0)\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-TypeResolution::TypeResolution (AST::Crate &crate, TopLevelScan &toplevel)\n-  : Resolution (crate, toplevel)\n-{\n-  scope.Push ();\n-\n-  // push all builtin types - this is probably too basic for future needs\n-  ADD_BUILTIN_TYPE (\"u8\", scope);\n-  ADD_BUILTIN_TYPE (\"u16\", scope);\n-  ADD_BUILTIN_TYPE (\"u32\", scope);\n-  ADD_BUILTIN_TYPE (\"u64\", scope);\n-\n-  ADD_BUILTIN_TYPE (\"i8\", scope);\n-  ADD_BUILTIN_TYPE (\"i16\", scope);\n-  ADD_BUILTIN_TYPE (\"i32\", scope);\n-  ADD_BUILTIN_TYPE (\"i64\", scope);\n-\n-  ADD_BUILTIN_TYPE (\"f32\", scope);\n-  ADD_BUILTIN_TYPE (\"f64\", scope);\n-\n-  ADD_BUILTIN_TYPE (\"char\", scope);\n-  ADD_BUILTIN_TYPE (\"str\", scope);\n-  ADD_BUILTIN_TYPE (\"bool\", scope);\n-\n-  // now its the crate scope\n-  scope.Push ();\n-}\n-\n-TypeResolution::~TypeResolution ()\n-{\n-  scope.Pop (); // crate\n-  scope.Pop (); // builtins\n-}\n-\n-bool\n-TypeResolution::Resolve (AST::Crate &crate, TopLevelScan &toplevel)\n-{\n-  TypeResolution resolver (crate, toplevel);\n-  return resolver.go ();\n-}\n-\n-bool\n-TypeResolution::go ()\n-{\n-  for (auto &item : crate.items)\n-    item->accept_vis (*this);\n-\n-  return true;\n-}\n-\n-bool\n-TypeResolution::typesAreCompatible (AST::Type *lhs, AST::Type *rhs,\n-\t\t\t\t    Location locus)\n-{\n-  auto before = typeComparisonBuffer.size ();\n-  lhs->accept_vis (*this);\n-  if (typeComparisonBuffer.size () <= before)\n-    {\n-      rust_error_at (locus, \"failed to understand type for lhs\");\n-      return false;\n-    }\n-\n-  auto lhsTypeStr = typeComparisonBuffer.back ();\n-  typeComparisonBuffer.pop_back ();\n-\n-  rhs->accept_vis (*this);\n-  if (typeComparisonBuffer.size () <= before)\n-    {\n-      rust_error_at (locus, \"failed to understand type for rhs\");\n-      return false;\n-    }\n-\n-  auto rhsTypeStr = typeComparisonBuffer.back ();\n-  typeComparisonBuffer.pop_back ();\n-\n-  // FIXME this needs to handle the cases of an i8 going into an i32 which is\n-  // compatible\n-  if (lhsTypeStr.compare (rhsTypeStr))\n-    {\n-      rust_error_at (locus, \"E0308: expected: %s, found %s\",\n-\t\t     lhsTypeStr.c_str (), rhsTypeStr.c_str ());\n-      return false;\n-    }\n-\n-  AST::Type *val = NULL;\n-  if (!scope.LookupType (lhsTypeStr, &val))\n-    {\n-      rust_error_at (locus, \"Unknown type: %s\", lhsTypeStr.c_str ());\n-      return false;\n-    }\n-\n-  return true;\n-}\n-\n-bool\n-TypeResolution::isTypeInScope (AST::Type *type, Location locus)\n-{\n-  auto before = typeComparisonBuffer.size ();\n-  type->accept_vis (*this);\n-  if (typeComparisonBuffer.size () <= before)\n-    {\n-      rust_error_at (locus, \"unable to decipher type: %s\",\n-\t\t     type->as_string ().c_str ());\n-      return false;\n-    }\n-\n-  auto t = typeComparisonBuffer.back ();\n-  typeComparisonBuffer.pop_back ();\n-\n-  AST::Type *val = NULL;\n-  return scope.LookupType (t, &val);\n-}\n-\n-AST::Function *\n-TypeResolution::lookupFndecl (AST::Expr *expr)\n-{\n-  size_t before = functionLookup.size ();\n-  expr->accept_vis (*this);\n-  if (functionLookup.size () > before)\n-    {\n-      auto fndecl = functionLookup.back ();\n-      functionLookup.pop_back ();\n-      return fndecl;\n-    }\n-\n-  rust_error_at (expr->get_locus_slow (), \"failed to lookup function\");\n-  return NULL;\n-}\n-\n-void\n-TypeResolution::visit (AST::Token &tok)\n-{}\n-\n-void\n-TypeResolution::visit (AST::DelimTokenTree &delim_tok_tree)\n-{}\n-\n-void\n-TypeResolution::visit (AST::AttrInputMetaItemContainer &input)\n-{}\n-\n-void\n-TypeResolution::visit (AST::IdentifierExpr &ident_expr)\n-{\n-  AST::Type *type = NULL;\n-  bool ok = scope.LookupType (ident_expr.get_ident (), &type);\n-  if (!ok)\n-    {\n-      rust_error_at (ident_expr.get_locus (), \"unknown identifier\");\n-      return;\n-    }\n-\n-  typeBuffer.push_back (type);\n-}\n-\n-void\n-TypeResolution::visit (AST::Lifetime &lifetime)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LifetimeParam &lifetime_param)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MacroInvocationSemi &macro)\n-{}\n-\n-// rust-path.h\n-void\n-TypeResolution::visit (AST::PathInExpression &path)\n-{\n-  // look up in the functionScope else lookup in the toplevel scan\n-  AST::Function *fndecl = NULL;\n-  if (scope.LookupFunction (path.as_string (), &fndecl))\n-    {\n-      functionLookup.push_back (fndecl);\n-      return;\n-    }\n-\n-  fndecl = toplevel.lookupFunction (&path);\n-  if (fndecl != NULL)\n-    {\n-      functionLookup.push_back (fndecl);\n-      return;\n-    }\n-}\n-\n-void\n-TypeResolution::visit (AST::TypePathSegment &segment)\n-{}\n-void\n-TypeResolution::visit (AST::TypePathSegmentGeneric &segment)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypePathSegmentFunction &segment)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypePath &path)\n-{\n-  // this may not be robust enough for type comparisons but lets try it for now\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-void\n-TypeResolution::visit (AST::QualifiedPathInExpression &path)\n-{\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-void\n-TypeResolution::visit (AST::QualifiedPathInType &path)\n-{\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-// rust-expr.h\n-void\n-TypeResolution::visit (AST::LiteralExpr &expr)\n-{\n-  std::string type;\n-  switch (expr.get_lit_type ())\n-    {\n-    case AST::Literal::CHAR:\n-      type = \"char\";\n-      break;\n-\n-    case AST::Literal::STRING:\n-    case AST::Literal::RAW_STRING:\n-      type = \"str\";\n-      break;\n-\n-    case AST::Literal::BOOL:\n-      type = \"bool\";\n-      break;\n-\n-    case AST::Literal::BYTE:\n-      type = \"u8\";\n-      break;\n-\n-      // FIXME these are not always going to be the case\n-      // eg: suffix on the value can change the type\n-    case AST::Literal::FLOAT:\n-      type = \"f32\";\n-      break;\n-\n-    case AST::Literal::INT:\n-      type = \"i32\";\n-      break;\n-\n-    case AST::Literal::BYTE_STRING:\n-    case AST::Literal::RAW_BYTE_STRING:\n-      // FIXME\n-      break;\n-    }\n-\n-  if (type.empty ())\n-    {\n-      rust_error_at (expr.get_locus (), \"unknown literal: %s\",\n-\t\t     expr.get_literal ().as_string ().c_str ());\n-      return;\n-    }\n-\n-  AST::Type *val = NULL;\n-  bool ok = scope.LookupType (type, &val);\n-  if (ok)\n-    typeBuffer.push_back (val);\n-  else\n-    rust_error_at (expr.get_locus (), \"unknown literal type: %s\", type.c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::AttrInputLiteral &attr_input)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MetaItemLitExpr &meta_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MetaItemPathLit &meta_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::BorrowExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::DereferenceExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ErrorPropagationExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::NegationExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{\n-  size_t before;\n-  before = typeBuffer.size ();\n-  expr.visit_lhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus (), \"unable to determine lhs type\");\n-      return;\n-    }\n-\n-  auto lhsType = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  before = typeBuffer.size ();\n-  expr.visit_rhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus (), \"unable to determine rhs type\");\n-      return;\n-    }\n-\n-  auto rhsType = typeBuffer.back ();\n-  // not poping because we will be checking they match and the\n-  // scope will require knowledge of the type\n-\n-  // do the lhsType and the rhsType match\n-  typesAreCompatible (lhsType, rhsType, expr.get_right_expr ()->get_locus_slow ());\n-}\n-\n-void\n-TypeResolution::visit (AST::ComparisonExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LazyBooleanExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypeCastExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::AssignmentExpr &expr)\n-{\n-  size_t before;\n-  before = typeBuffer.size ();\n-  expr.visit_lhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus (), \"unable to determine lhs type\");\n-      return;\n-    }\n-\n-  auto lhsType = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  before = typeBuffer.size ();\n-  expr.visit_rhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus (), \"unable to determine rhs type\");\n-      return;\n-    }\n-\n-  auto rhsType = typeBuffer.back ();\n-  // not poping because we will be checking they match and the\n-  // scope will require knowledge of the type\n-\n-  // do the lhsType and the rhsType match\n-  if (!typesAreCompatible (lhsType, rhsType,\n-\t\t\t   expr.get_right_expr ()->get_locus_slow ()))\n-    return;\n-\n-  // is the lhs mutable?\n-}\n-\n-void\n-TypeResolution::visit (AST::CompoundAssignmentExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::GroupedExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ArrayElemsValues &elems)\n-{\n-  // we need to generate the AST::ArrayType for this array init_expression\n-  // we can get the size via get_num_values() but we need to ensure each element\n-  // are type compatible\n-\n-  bool failed = false;\n-  AST::Type *last_inferred_type = nullptr;\n-  elems.iterate ([&] (AST::Expr *expr) mutable -> bool {\n-    size_t before;\n-    before = typeBuffer.size ();\n-    expr->accept_vis (*this);\n-    if (typeBuffer.size () <= before)\n-      {\n-\trust_error_at (expr->get_locus_slow (),\n-\t\t       \"unable to determine element type\");\n-\treturn false;\n-      }\n-\n-    AST::Type *inferedType = typeBuffer.back ();\n-    typeBuffer.pop_back ();\n-\n-    if (last_inferred_type == nullptr)\n-      last_inferred_type = inferedType;\n-    else\n-      {\n-\tif (!typesAreCompatible (last_inferred_type, inferedType,\n-\t\t\t\t expr->get_locus_slow ()))\n-\t  {\n-\t    failed = true;\n-\t    return false;\n-\t  }\n-      }\n-\n-    return true;\n-  });\n-\n-  // nothing to do when its failed\n-  if (failed)\n-    return;\n-\n-  // FIXME This will leak\n-  auto capacity\n-    = new AST::LiteralExpr (std::to_string (elems.get_num_values ()),\n-\t\t\t    AST::Literal::INT,\n-\t\t\t    Linemap::predeclared_location ());\n-  auto arrayType = new AST::ArrayType (last_inferred_type->clone_type (),\n-\t\t\t\t       std::unique_ptr<AST::Expr> (capacity),\n-\t\t\t\t       Linemap::predeclared_location ());\n-  typeBuffer.push_back (arrayType);\n-}\n-\n-void\n-TypeResolution::visit (AST::ArrayElemsCopied &elems)\n-{\n-  printf (\"ArrayElemsCopied: %s\\n\", elems.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::ArrayExpr &expr)\n-{\n-  auto& elements = expr.get_array_elems ();\n-\n-  auto before = typeBuffer.size ();\n-  elements->accept_vis (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"unable to determine type for ArrayExpr\");\n-      return;\n-    }\n-\n-  expr.set_inferred_type (typeBuffer.back ());\n-}\n-\n-void\n-TypeResolution::visit (AST::ArrayIndexExpr &expr)\n-{\n-  auto before = typeBuffer.size ();\n-  expr.get_array_expr ()->accept_vis (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"unable to determine type for array index expression\");\n-      return;\n-    }\n-  AST::Type *array_expr_type = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  before = typeBuffer.size ();\n-  expr.get_index_expr ()->accept_vis (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_index_expr ()->get_locus_slow (),\n-\t\t     \"unable to determine type for index expression\");\n-      return;\n-    }\n-\n-  AST::Type *array_index_type = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  // check the index_type should be an i32 which should really be\n-  // more permissive\n-  AST::Type *i32 = nullptr;\n-  scope.LookupType (\"i32\", &i32);\n-  rust_assert (i32 != nullptr);\n-\n-  if (!typesAreCompatible (array_index_type, i32,\n-\t\t\t   expr.get_index_expr ()->get_locus_slow ()))\n-    {\n-      return;\n-    }\n-\n-  // the the element type from the array_expr_type and it _must_ be an array\n-  AST::ArrayType *resolved = ArrayTypeVisitor::Resolve (array_expr_type);\n-  if (resolved == nullptr)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"unable to resolve type for array expression\");\n-      return;\n-    }\n-\n-  typeBuffer.push_back (resolved->get_elem_type ().get ());\n-}\n-\n-void\n-TypeResolution::visit (AST::TupleExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::TupleIndexExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::StructExprStruct &expr)\n-{}\n-\n-// void TypeResolution::visit(StructExprField& field) {}\n-void\n-TypeResolution::visit (AST::StructExprFieldIdentifier &field)\n-{}\n-\n-void\n-TypeResolution::visit (AST::StructExprFieldIdentifierValue &field)\n-{\n-  identifierBuffer = std::unique_ptr<std::string> (new std::string (field.get_field_name ()));\n-  field.get_value ()->accept_vis (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::StructExprFieldIndexValue &field)\n-{\n-  tupleIndexBuffer = std::unique_ptr<int> (new int (field.get_index ()));\n-  field.get_value ()->accept_vis (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::StructExprStructFields &expr)\n-{\n-  AST::StructStruct *decl = NULL;\n-  if (!scope.LookupStruct (expr.get_struct_name ().as_string (), &decl))\n-    {\n-      rust_error_at (expr.get_locus_slow (), \"unknown type\");\n-      return;\n-    }\n-\n-  for (auto &field : expr.get_fields ())\n-    {\n-      identifierBuffer = NULL;\n-      tupleIndexBuffer = NULL;\n-\n-      auto before = typeBuffer.size ();\n-      field->accept_vis (*this);\n-      if (typeBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (expr.get_locus_slow (),\n-\t\t\t \"unable to determine type for field\");\n-\t  return;\n-\t}\n-\n-      auto inferedType = typeBuffer.back ();\n-      typeBuffer.pop_back ();\n-\n-      // do we have a name for this\n-      if (identifierBuffer != NULL)\n-\t{\n-\t  AST::StructField *declField = NULL;\n-\t  for (auto &df : decl->get_fields ())\n-\t    {\n-\t      if (identifierBuffer->compare (df.get_field_name ()) == 0)\n-\t\t{\n-\t\t  declField = &df;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  identifierBuffer = NULL;\n-\n-\t  if (declField == NULL)\n-\t    {\n-\t      rust_error_at (expr.get_locus_slow (), \"unknown field\");\n-\t      return;\n-\t    }\n-\n-\t  if (!typesAreCompatible (declField->get_field_type ().get (), inferedType,\n-\t\t\t\t   expr.get_locus_slow ()))\n-\t    return;\n-\t}\n-      // do we have an index for this\n-      else if (tupleIndexBuffer != NULL)\n-\t{\n-\t  AST::StructField *declField = NULL;\n-\t  if (*tupleIndexBuffer < decl->get_fields ().size ())\n-\t    {\n-\t      declField = &decl->get_fields ()[*tupleIndexBuffer];\n-\t    }\n-\t  tupleIndexBuffer = NULL;\n-\n-\t  if (declField == NULL)\n-\t    {\n-\t      rust_error_at (expr.get_locus_slow (), \"unknown field at index\");\n-\t      return;\n-\t    }\n-\n-\t  if (!typesAreCompatible (declField->get_field_type ().get (), inferedType,\n-\t\t\t\t   expr.get_locus_slow ()))\n-\t    return;\n-\t}\n-      else\n-\t{\n-\t  rust_fatal_error (expr.get_locus_slow (), \"unknown field initialise\");\n-\t  return;\n-\t}\n-    }\n-\n-  // need to correct the ordering with the respect to the struct definition and\n-  // ensure we handle missing values and give them defaults\n-  // FIXME\n-\n-  // setup a path in type\n-  AST::PathIdentSegment seg (expr.get_struct_name ().as_string ());\n-  auto typePath = ::std::unique_ptr<AST::TypePathSegment> (\n-    new AST::TypePathSegment (::std::move (seg), false,\n-\t\t\t      expr.get_locus_slow ()));\n-  ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;\n-  segs.push_back (::std::move (typePath));\n-  auto bType\n-    = new AST::TypePath (::std::move (segs), expr.get_locus_slow (), false);\n-  typeBuffer.push_back (bType);\n-}\n-\n-void\n-TypeResolution::visit (AST::StructExprStructBase &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprTuple &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprUnit &expr)\n-{}\n-// void TypeResolution::visit(EnumExprField& field) {}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIdentifier &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIdentifierValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIndexValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprStruct &expr)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprTuple &expr)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldless &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::CallExpr &expr)\n-{\n-  // this look up should probably be moved to name resolution\n-  auto fndecl = lookupFndecl (expr.get_function_expr ().get ());\n-  if (fndecl == NULL)\n-    return;\n-\n-  // check num args match\n-  if (fndecl->get_function_params ().size () != expr.get_params ().size ())\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"differing number of arguments vs parameters to function\");\n-      return;\n-    }\n-\n-  typeBuffer.push_back (fndecl->get_return_type ().get ());\n-  expr.fndeclRef = fndecl;\n-\n-  auto before = typeBuffer.size ();\n-  for (auto &item : expr.get_params ())\n-    item->accept_vis (*this);\n-\n-  auto numInferedParams = typeBuffer.size () - before;\n-  if (numInferedParams != expr.get_params ().size ())\n-    {\n-      rust_error_at (expr.get_locus (), \"Failed to infer all parameters\");\n-      return;\n-    }\n-\n-  auto offs = numInferedParams - 1;\n-  for (auto it = fndecl->get_function_params ().rbegin ();\n-       it != fndecl->get_function_params ().rend (); ++it)\n-    {\n-      AST::Type *argument = typeBuffer.back ();\n-      typeBuffer.pop_back ();\n-\n-      if (!typesAreCompatible (it->get_type ().get (), argument,\n-\t\t\t       expr.get_params ()[offs]->get_locus_slow ()))\n-\treturn;\n-      offs--;\n-    }\n-}\n-\n-void\n-TypeResolution::visit (AST::MethodCallExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::FieldAccessExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ClosureExprInner &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::BlockExpr &expr)\n-{\n-  scope.Push ();\n-  for (auto &stmt : expr.get_statements ())\n-    {\n-      stmt->accept_vis (*this);\n-    }\n-  scope.Pop ();\n-}\n-\n-void\n-TypeResolution::visit (AST::ClosureExprInnerTyped &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ContinueExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::BreakExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromToExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeToExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFullExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromToInclExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeToInclExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ReturnExpr &expr)\n-{\n-  // Ensure the type of this matches the function\n-  auto before = typeBuffer.size ();\n-  expr.get_returned_expr ()->accept_vis (*this);\n-\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_returned_expr ()->get_locus_slow (),\n-\t\t     \"unable to determine type for return expr\");\n-      return;\n-    }\n-\n-  auto inferedType = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  // check this is compatible with the return type\n-  // this will again have issues with structs before we move to HIR\n-\n-  auto function = scope.CurrentFunction ();\n-  if (!function->has_return_type ())\n-    {\n-      rust_error_at (expr.get_locus (), \"return for void function %s\",\n-\t\t     function->as_string ().c_str ());\n-      return;\n-    }\n-\n-  if (!typesAreCompatible (function->get_return_type ().get (), inferedType,\n-\t\t\t   expr.get_locus_slow ()))\n-    {\n-      return;\n-    }\n-}\n-\n-void\n-TypeResolution::visit (AST::UnsafeBlockExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::LoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::WhileLoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::WhileLetLoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ForLoopExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::IfExpr &expr)\n-{\n-  expr.vis_if_block (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::IfExprConseqElse &expr)\n-{\n-  expr.vis_if_block (*this);\n-  expr.vis_else_block (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::IfExprConseqIf &expr)\n-{\n-  expr.vis_if_block (*this);\n-  expr.vis_conseq_if_expr (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::IfExprConseqIfLet &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqElse &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqIf &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqIfLet &expr)\n-{}\n-// void TypeResolution::visit(MatchCase& match_case) {}\n-/*void\n-TypeResolution::visit (AST::MatchCaseBlockExpr &match_case)\n-{}*/\n-/*void\n-TypeResolution::visit (AST::MatchCaseExpr &match_case)\n-{}*/\n-void\n-TypeResolution::visit (AST::MatchExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::AwaitExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::AsyncBlockExpr &expr)\n-{}\n-\n-// rust-item.h\n-void\n-TypeResolution::visit (AST::TypeParam &param)\n-{}\n-// void TypeResolution::visit(WhereClauseItem& item) {}\n-void\n-TypeResolution::visit (AST::LifetimeWhereClauseItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::TypeBoundWhereClauseItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::Method &method)\n-{}\n-void\n-TypeResolution::visit (AST::ModuleBodied &module)\n-{}\n-void\n-TypeResolution::visit (AST::ModuleNoBody &module)\n-{}\n-void\n-TypeResolution::visit (AST::ExternCrate &crate)\n-{}\n-// void TypeResolution::visit(UseTree& use_tree) {}\n-void\n-TypeResolution::visit (AST::UseTreeGlob &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseTreeList &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseTreeRebind &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseDeclaration &use_decl)\n-{}\n-\n-void\n-TypeResolution::visit (AST::Function &function)\n-{\n-  // always emit the function with return type in the event of nil return type\n-  // its  a marker for a void function\n-  scope.InsertType (function.get_function_name (), function.get_return_type ().get ());\n-  scope.InsertFunction (function.get_function_name (), &function);\n-  scope.PushFunction (&function);\n-  scope.Push ();\n-\n-  for (auto &param : function.get_function_params ())\n-    {\n-      if (!isTypeInScope (param.get_type ().get (), param.get_locus ()))\n-\t{\n-\t  scope.Pop ();\n-\t  scope.PopFunction ();\n-\t  return;\n-\t}\n-\n-      auto before = letPatternBuffer.size ();\n-      param.get_pattern ()->accept_vis (*this);\n-      if (letPatternBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (param.get_locus (), \"failed to analyse parameter name\");\n-\n-\t  scope.Pop ();\n-\t  scope.PopFunction ();\n-\t  return;\n-\t}\n-\n-      auto paramName = letPatternBuffer.back ();\n-      letPatternBuffer.pop_back ();\n-      scope.InsertType (paramName.get_ident (), param.get_type ().get ());\n-    }\n-\n-  // ensure the return type is resolved\n-  if (function.has_return_type ())\n-    {\n-      if (!isTypeInScope (function.get_return_type ().get (), function.get_locus ()))\n-\t{\n-\t  scope.Pop ();\n-\t  scope.PopFunction ();\n-\t  return;\n-\t}\n-    }\n-\n-  // walk the expression body\n-  for (auto &stmt : function.get_definition ()->get_statements ())\n-    {\n-      stmt->accept_vis (*this);\n-    }\n-\n-  auto localMap = scope.PeekLocals ();\n-  for (auto &[_, value] : localMap)\n-    function.locals.push_back (value);\n-\n-  scope.Pop ();\n-  scope.PopFunction ();\n-}\n-\n-void\n-TypeResolution::visit (AST::TypeAlias &type_alias)\n-{}\n-\n-void\n-TypeResolution::visit (AST::StructStruct &struct_item)\n-{\n-  for (auto &field : struct_item.get_fields ())\n-    {\n-      if (!isTypeInScope (field.get_field_type ().get (),\n-\t\t\t  Linemap::unknown_location ()))\n-\t{\n-\t  rust_fatal_error (Linemap::unknown_location (),\n-\t\t\t    \"unknown type in struct field\");\n-\t  return;\n-\t}\n-    }\n-\n-  scope.InsertStruct (struct_item.get_struct_name (), &struct_item);\n-}\n-\n-void\n-TypeResolution::visit (AST::TupleStruct &tuple_struct)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemTuple &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemStruct &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemDiscriminant &item)\n-{}\n-void\n-TypeResolution::visit (AST::Enum &enum_item)\n-{}\n-void\n-TypeResolution::visit (AST::Union &union_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ConstantItem &const_item)\n-{\n-  printf (\"ConstantItem: %s\\n\", const_item.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::StaticItem &static_item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemFunc &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemMethod &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemConst &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemType &item)\n-{}\n-void\n-TypeResolution::visit (AST::Trait &trait)\n-{}\n-void\n-TypeResolution::visit (AST::InherentImpl &impl)\n-{}\n-void\n-TypeResolution::visit (AST::TraitImpl &impl)\n-{}\n-// void TypeResolution::visit(ExternalItem& item) {}\n-void\n-TypeResolution::visit (AST::ExternalStaticItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::ExternalFunctionItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::ExternBlock &block)\n-{}\n-\n-// rust-macro.h\n-void\n-TypeResolution::visit (AST::MacroMatchFragment &match)\n-{}\n-void\n-TypeResolution::visit (AST::MacroMatchRepetition &match)\n-{}\n-void\n-TypeResolution::visit (AST::MacroMatcher &matcher)\n-{}\n-void\n-TypeResolution::visit (AST::MacroRulesDefinition &rules_def)\n-{}\n-void\n-TypeResolution::visit (AST::MacroInvocation &macro_invoc)\n-{}\n-void\n-TypeResolution::visit (AST::MetaItemPath &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaItemSeq &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaWord &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaNameValueStr &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaListPaths &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaListNameValueStr &meta_item)\n-{}\n-\n-// rust-pattern.h\n-void\n-TypeResolution::visit (AST::LiteralPattern &pattern)\n-{\n-  printf (\"LiteralPattern: %s\\n\", pattern.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::IdentifierPattern &pattern)\n-{\n-  letPatternBuffer.push_back (pattern);\n-}\n-\n-void\n-TypeResolution::visit (AST::WildcardPattern &pattern)\n-{}\n-// void TypeResolution::visit(RangePatternBound& bound) {}\n-void\n-TypeResolution::visit (AST::RangePatternBoundLiteral &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePatternBoundPath &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePatternBoundQualPath &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::ReferencePattern &pattern)\n-{}\n-// void TypeResolution::visit(StructPatternField& field) {}\n-void\n-TypeResolution::visit (AST::StructPatternFieldTuplePat &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPatternFieldIdentPat &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPatternFieldIdent &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPattern &pattern)\n-{}\n-// void TypeResolution::visit(TupleStructItems& tuple_items) {}\n-void\n-TypeResolution::visit (AST::TupleStructItemsNoRange &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TupleStructItemsRange &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TupleStructPattern &pattern)\n-{}\n-// void TypeResolution::visit(TuplePatternItems& tuple_items) {}\n-void\n-TypeResolution::visit (AST::TuplePatternItemsMultiple &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TuplePatternItemsRanged &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TuplePattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::GroupedPattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::SlicePattern &pattern)\n-{}\n-\n-// rust-stmt.h\n-void\n-TypeResolution::visit (AST::EmptyStmt &stmt)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LetStmt &stmt)\n-{\n-  scope.InsertLocal (stmt.as_string (), &stmt);\n-  if (!stmt.has_init_expr () && !stmt.has_type ())\n-    {\n-      rust_error_at (stmt.get_locus (),\n-\t\t     \"E0282: type annotations or init expression needed\");\n-      return;\n-    }\n-\n-  AST::Type *inferedType = nullptr;\n-  if (stmt.has_init_expr ())\n-    {\n-      auto before = typeBuffer.size ();\n-      stmt.get_init_expr ()->accept_vis (*this);\n-\n-      if (typeBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (\n-\t    stmt.get_init_expr ()->get_locus_slow (),\n-\t    \"unable to determine type for declaration from init expr\");\n-\t  return;\n-\t}\n-\n-      inferedType = typeBuffer.back ();\n-      typeBuffer.pop_back ();\n-\n-      if (inferedType == NULL)\n-\t{\n-\t  rust_error_at (stmt.get_init_expr ()->get_locus_slow (),\n-\t\t\t \"void type found for statement initialisation\");\n-\t  return;\n-\t}\n-    }\n-\n-  if (stmt.has_type () && stmt.has_init_expr ())\n-    {\n-      if (!typesAreCompatible (stmt.get_type ().get (), inferedType,\n-\t\t\t       stmt.get_init_expr ()->get_locus_slow ()))\n-\t{\n-\t  return;\n-\t}\n-    }\n-  else if (stmt.has_type ())\n-    {\n-      auto before = typeComparisonBuffer.size ();\n-      stmt.get_type ()->accept_vis (*this);\n-      if (typeComparisonBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (stmt.get_locus (), \"failed to understand type for lhs\");\n-\t  return;\n-\t}\n-      auto typeString = typeComparisonBuffer.back ();\n-      typeComparisonBuffer.pop_back ();\n-\n-      // AST::Type *val = NULL;\n-      // if (!scope.LookupType (typeString, &val))\n-      //   {\n-      //     rust_error_at (stmt.locus, \"LetStmt has unknown type: %s\",\n-      //   \t\t stmt.type->as_string ().c_str ());\n-      //     return;\n-      //   }\n-    }\n-  else if (inferedType != nullptr)\n-    {\n-      auto before = typeComparisonBuffer.size ();\n-      inferedType->accept_vis (*this);\n-      if (typeComparisonBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (stmt.get_locus (), \"failed to understand type for lhs\");\n-\t  return;\n-\t}\n-      auto typeString = typeComparisonBuffer.back ();\n-      typeComparisonBuffer.pop_back ();\n-\n-      // AST::Type *val = NULL;\n-      // if (!scope.LookupType (typeString, &val))\n-      //   {\n-      //     rust_error_at (stmt.get_locus (), \"Inferred unknown type: %s\",\n-      //   \t\t inferedType->as_string ().c_str ());\n-      //     return;\n-      //   }\n-    }\n-  else\n-    {\n-      rust_fatal_error (stmt.get_locus (), \"Failed to determine any type for LetStmt\");\n-      return;\n-    }\n-\n-  // ensure the decl has the type set for compilation later on\n-  if (!stmt.has_type ())\n-    {\n-      stmt.inferedType = inferedType;\n-    }\n-\n-  // get all the names part of this declaration and add the types to the scope\n-  stmt.get_pattern ()->accept_vis (*this);\n-  for (auto &pattern : letPatternBuffer)\n-    scope.InsertType (pattern.get_ident (), inferedType);\n-\n-  letPatternBuffer.clear ();\n-}\n-\n-void\n-TypeResolution::visit (AST::ExprStmtWithoutBlock &stmt)\n-{\n-  stmt.get_expr ()->accept_vis (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::ExprStmtWithBlock &stmt)\n-{\n-  scope.Push ();\n-  stmt.get_expr ()->accept_vis (*this);\n-  auto localMap = scope.PeekLocals ();\n-  for (auto &[_, value] : localMap)\n-    {\n-      stmt.locals.push_back (value);\n-    }\n-  scope.Pop ();\n-}\n-\n-// rust-type.h\n-void\n-TypeResolution::visit (AST::TraitBound &bound)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ImplTraitType &type)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TraitObjectType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ParenthesisedType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ImplTraitTypeOneBound &type)\n-{}\n-void\n-TypeResolution::visit (AST::TraitObjectTypeOneBound &type)\n-{}\n-void\n-TypeResolution::visit (AST::TupleType &type)\n-{}\n-void\n-TypeResolution::visit (AST::NeverType &type)\n-{}\n-void\n-TypeResolution::visit (AST::RawPointerType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ReferenceType &type)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ArrayType &type)\n-{\n-  typeComparisonBuffer.push_back (type.get_elem_type ()->as_string ());\n-}\n-\n-void\n-TypeResolution::visit (AST::SliceType &type)\n-{}\n-void\n-TypeResolution::visit (AST::InferredType &type)\n-{}\n-void\n-TypeResolution::visit (AST::BareFunctionType &type)\n-{}\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "2f61a39418110b7136431c7cb153c0cdd9db3cbf", "filename": "gcc/rust/analysis/rust-type-resolution.h", "status": "removed", "additions": 0, "deletions": 334, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -1,334 +0,0 @@\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-#pragma once\n-\n-#include \"rust-resolution.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-class TypeScoping\n-{\n-public:\n-  TypeScoping () {}\n-\n-  ~TypeScoping () {}\n-\n-  void Push ()\n-  {\n-    functionScope.Push ();\n-    localsPerBlock.Push ();\n-    structsPerBlock.Push ();\n-    typeScope.Push ();\n-  }\n-\n-  void Pop ()\n-  {\n-    functionScope.Pop ();\n-    localsPerBlock.Pop ();\n-    structsPerBlock.Pop ();\n-    typeScope.Pop ();\n-  }\n-\n-  void InsertFunction (std::string ident, AST::Function *fn)\n-  {\n-    functionScope.Insert (ident, fn);\n-  }\n-\n-  bool LookupFunction (std::string ident, AST::Function **fn)\n-  {\n-    return functionScope.Lookup (ident, fn);\n-  }\n-\n-  void PushFunction (AST::Function *fn) { functionStack.push_back (fn); }\n-\n-  void PopFunction () { functionStack.pop_back (); }\n-\n-  AST::Function *CurrentFunction () { return functionStack.back (); }\n-\n-  void InsertLocal (std::string ident, AST::LetStmt *let)\n-  {\n-    localsPerBlock.Insert (ident, let);\n-  }\n-\n-  bool LookupLocal (std::string ident, AST::LetStmt **let)\n-  {\n-    return localsPerBlock.Lookup (ident, let);\n-  }\n-\n-  std ::map<std::string, AST::LetStmt *> PeekLocals ()\n-  {\n-    return localsPerBlock.Peek ();\n-  }\n-\n-  void InsertStruct (std::string ident, AST::StructStruct *s)\n-  {\n-    structsPerBlock.Insert (ident, s);\n-  }\n-\n-  bool LookupStruct (std::string ident, AST::StructStruct **s)\n-  {\n-    return structsPerBlock.Lookup (ident, s);\n-  }\n-\n-  void InsertType (std::string ident, AST::Type *s)\n-  {\n-    typeScope.Insert (ident, s);\n-  }\n-\n-  bool LookupType (std::string ident, AST::Type **s)\n-  {\n-    return typeScope.Lookup (ident, s);\n-  }\n-\n-private:\n-  std::vector<AST::Function *> functionStack;\n-\n-  Scope<AST::Function *> functionScope;\n-  Scope<AST::LetStmt *> localsPerBlock;\n-  Scope<AST::StructStruct *> structsPerBlock;\n-  Scope<AST::Type *> typeScope;\n-};\n-\n-class TypeResolution : public Resolution\n-{\n-  friend class TypeScoping;\n-\n-public:\n-  ~TypeResolution ();\n-  static bool Resolve (AST::Crate &crate, TopLevelScan &toplevel);\n-\n-  // visitor impl\n-  // rust-ast.h\n-  //  void visit(AttrInput& attr_input);\n-  //  void visit(TokenTree& token_tree);\n-  //  void visit(MacroMatch& macro_match);\n-  void visit (AST::Token &tok) override;\n-  void visit (AST::DelimTokenTree &delim_tok_tree) override;\n-  void visit (AST::AttrInputMetaItemContainer &input) override;\n-  //  void visit(MetaItem& meta_item) override;\n-  //  void vsit(Stmt& stmt) override;\n-  //  void visit(Expr& expr) override;\n-  void visit (AST::IdentifierExpr &ident_expr) override;\n-  //  void visit(Pattern& pattern) override;\n-  //  void visit(Type& type) override;\n-  //  void visit(TypeParamBound& type_param_bound) override;\n-  void visit (AST::Lifetime &lifetime) override;\n-  //  void visit(GenericParam& generic_param) override;\n-  void visit (AST::LifetimeParam &lifetime_param) override;\n-  //  void visit(TraitItem& trait_item) override;\n-  //  void visit(InherentImplItem& inherent_impl_item) override;\n-  //  void visit(TraitImplItem& trait_impl_item) override;\n-  void visit (AST::MacroInvocationSemi &macro) override;\n-\n-  // rust-path.h\n-  void visit (AST::PathInExpression &path) override;\n-  void visit (AST::TypePathSegment &segment) override;\n-  void visit (AST::TypePathSegmentGeneric &segment) override;\n-  void visit (AST::TypePathSegmentFunction &segment) override;\n-  void visit (AST::TypePath &path) override;\n-  void visit (AST::QualifiedPathInExpression &path) override;\n-  void visit (AST::QualifiedPathInType &path) override;\n-\n-  // rust-expr.h\n-  void visit (AST::LiteralExpr &expr) override;\n-  void visit (AST::AttrInputLiteral &attr_input) override;\n-  void visit (AST::MetaItemLitExpr &meta_item) override;\n-  void visit (AST::MetaItemPathLit &meta_item) override;\n-  void visit (AST::BorrowExpr &expr) override;\n-  void visit (AST::DereferenceExpr &expr) override;\n-  void visit (AST::ErrorPropagationExpr &expr) override;\n-  void visit (AST::NegationExpr &expr) override;\n-  void visit (AST::ArithmeticOrLogicalExpr &expr) override;\n-  void visit (AST::ComparisonExpr &expr) override;\n-  void visit (AST::LazyBooleanExpr &expr) override;\n-  void visit (AST::TypeCastExpr &expr) override;\n-  void visit (AST::AssignmentExpr &expr) override;\n-  void visit (AST::CompoundAssignmentExpr &expr) override;\n-  void visit (AST::GroupedExpr &expr) override;\n-  //  void visit(ArrayElems& elems) override;\n-  void visit (AST::ArrayElemsValues &elems) override;\n-  void visit (AST::ArrayElemsCopied &elems) override;\n-  void visit (AST::ArrayExpr &expr) override;\n-  void visit (AST::ArrayIndexExpr &expr) override;\n-  void visit (AST::TupleExpr &expr) override;\n-  void visit (AST::TupleIndexExpr &expr) override;\n-  void visit (AST::StructExprStruct &expr) override;\n-  //  void visit(StructExprField& field) override;\n-  void visit (AST::StructExprFieldIdentifier &field) override;\n-  void visit (AST::StructExprFieldIdentifierValue &field) override;\n-  void visit (AST::StructExprFieldIndexValue &field) override;\n-  void visit (AST::StructExprStructFields &expr) override;\n-  void visit (AST::StructExprStructBase &expr) override;\n-  void visit (AST::StructExprTuple &expr) override;\n-  void visit (AST::StructExprUnit &expr) override;\n-  //  void visit(EnumExprField& field) override;\n-  void visit (AST::EnumExprFieldIdentifier &field) override;\n-  void visit (AST::EnumExprFieldIdentifierValue &field) override;\n-  void visit (AST::EnumExprFieldIndexValue &field) override;\n-  void visit (AST::EnumExprStruct &expr) override;\n-  void visit (AST::EnumExprTuple &expr) override;\n-  void visit (AST::EnumExprFieldless &expr) override;\n-  void visit (AST::CallExpr &expr) override;\n-  void visit (AST::MethodCallExpr &expr) override;\n-  void visit (AST::FieldAccessExpr &expr) override;\n-  void visit (AST::ClosureExprInner &expr) override;\n-  void visit (AST::BlockExpr &expr) override;\n-  void visit (AST::ClosureExprInnerTyped &expr) override;\n-  void visit (AST::ContinueExpr &expr) override;\n-  void visit (AST::BreakExpr &expr) override;\n-  void visit (AST::RangeFromToExpr &expr) override;\n-  void visit (AST::RangeFromExpr &expr) override;\n-  void visit (AST::RangeToExpr &expr) override;\n-  void visit (AST::RangeFullExpr &expr) override;\n-  void visit (AST::RangeFromToInclExpr &expr) override;\n-  void visit (AST::RangeToInclExpr &expr) override;\n-  void visit (AST::ReturnExpr &expr) override;\n-  void visit (AST::UnsafeBlockExpr &expr) override;\n-  void visit (AST::LoopExpr &expr) override;\n-  void visit (AST::WhileLoopExpr &expr) override;\n-  void visit (AST::WhileLetLoopExpr &expr) override;\n-  void visit (AST::ForLoopExpr &expr) override;\n-  void visit (AST::IfExpr &expr) override;\n-  void visit (AST::IfExprConseqElse &expr) override;\n-  void visit (AST::IfExprConseqIf &expr) override;\n-  void visit (AST::IfExprConseqIfLet &expr) override;\n-  void visit (AST::IfLetExpr &expr) override;\n-  void visit (AST::IfLetExprConseqElse &expr) override;\n-  void visit (AST::IfLetExprConseqIf &expr) override;\n-  void visit (AST::IfLetExprConseqIfLet &expr) override;\n-  //  void visit(MatchCase& match_case) override;\n-  // void visit (AST::MatchCaseBlockExpr &match_case) override;\n-  // void visit (AST::MatchCaseExpr &match_case) override;\n-  void visit (AST::MatchExpr &expr) override;\n-  void visit (AST::AwaitExpr &expr) override;\n-  void visit (AST::AsyncBlockExpr &expr) override;\n-\n-  // rust-item.h\n-  void visit (AST::TypeParam &param) override;\n-  //  void visit(WhereClauseItem& item) override;\n-  void visit (AST::LifetimeWhereClauseItem &item) override;\n-  void visit (AST::TypeBoundWhereClauseItem &item) override;\n-  void visit (AST::Method &method) override;\n-  void visit (AST::ModuleBodied &module) override;\n-  void visit (AST::ModuleNoBody &module) override;\n-  void visit (AST::ExternCrate &crate) override;\n-  //  void visit(UseTree& use_tree) override;\n-  void visit (AST::UseTreeGlob &use_tree) override;\n-  void visit (AST::UseTreeList &use_tree) override;\n-  void visit (AST::UseTreeRebind &use_tree) override;\n-  void visit (AST::UseDeclaration &use_decl) override;\n-  void visit (AST::Function &function) override;\n-  void visit (AST::TypeAlias &type_alias) override;\n-  void visit (AST::StructStruct &struct_item) override;\n-  void visit (AST::TupleStruct &tuple_struct) override;\n-  void visit (AST::EnumItem &item) override;\n-  void visit (AST::EnumItemTuple &item) override;\n-  void visit (AST::EnumItemStruct &item) override;\n-  void visit (AST::EnumItemDiscriminant &item) override;\n-  void visit (AST::Enum &enum_item) override;\n-  void visit (AST::Union &union_item) override;\n-  void visit (AST::ConstantItem &const_item) override;\n-  void visit (AST::StaticItem &static_item) override;\n-  void visit (AST::TraitItemFunc &item) override;\n-  void visit (AST::TraitItemMethod &item) override;\n-  void visit (AST::TraitItemConst &item) override;\n-  void visit (AST::TraitItemType &item) override;\n-  void visit (AST::Trait &trait) override;\n-  void visit (AST::InherentImpl &impl) override;\n-  void visit (AST::TraitImpl &impl) override;\n-  //  void visit(ExternalItem& item) override;\n-  void visit (AST::ExternalStaticItem &item) override;\n-  void visit (AST::ExternalFunctionItem &item) override;\n-  void visit (AST::ExternBlock &block) override;\n-\n-  // rust-macro.h\n-  void visit (AST::MacroMatchFragment &match) override;\n-  void visit (AST::MacroMatchRepetition &match) override;\n-  void visit (AST::MacroMatcher &matcher) override;\n-  void visit (AST::MacroRulesDefinition &rules_def) override;\n-  void visit (AST::MacroInvocation &macro_invoc) override;\n-  void visit (AST::MetaItemPath &meta_item) override;\n-  void visit (AST::MetaItemSeq &meta_item) override;\n-  void visit (AST::MetaWord &meta_item) override;\n-  void visit (AST::MetaNameValueStr &meta_item) override;\n-  void visit (AST::MetaListPaths &meta_item) override;\n-  void visit (AST::MetaListNameValueStr &meta_item) override;\n-\n-  // rust-pattern.h\n-  void visit (AST::LiteralPattern &pattern) override;\n-  void visit (AST::IdentifierPattern &pattern) override;\n-  void visit (AST::WildcardPattern &pattern) override;\n-  //  void visit(RangePatternBound& bound) override;\n-  void visit (AST::RangePatternBoundLiteral &bound) override;\n-  void visit (AST::RangePatternBoundPath &bound) override;\n-  void visit (AST::RangePatternBoundQualPath &bound) override;\n-  void visit (AST::RangePattern &pattern) override;\n-  void visit (AST::ReferencePattern &pattern) override;\n-  //  void visit(StructPatternField& field) override;\n-  void visit (AST::StructPatternFieldTuplePat &field) override;\n-  void visit (AST::StructPatternFieldIdentPat &field) override;\n-  void visit (AST::StructPatternFieldIdent &field) override;\n-  void visit (AST::StructPattern &pattern) override;\n-  //  void visit(TupleStructItems& tuple_items) override;\n-  void visit (AST::TupleStructItemsNoRange &tuple_items) override;\n-  void visit (AST::TupleStructItemsRange &tuple_items) override;\n-  void visit (AST::TupleStructPattern &pattern) override;\n-  //  void visit(TuplePatternItems& tuple_items) override;\n-  void visit (AST::TuplePatternItemsMultiple &tuple_items) override;\n-  void visit (AST::TuplePatternItemsRanged &tuple_items) override;\n-  void visit (AST::TuplePattern &pattern) override;\n-  void visit (AST::GroupedPattern &pattern) override;\n-  void visit (AST::SlicePattern &pattern) override;\n-\n-  // rust-stmt.h\n-  void visit (AST::EmptyStmt &stmt) override;\n-  void visit (AST::LetStmt &stmt) override;\n-  void visit (AST::ExprStmtWithoutBlock &stmt) override;\n-  void visit (AST::ExprStmtWithBlock &stmt) override;\n-\n-  // rust-type.h\n-  void visit (AST::TraitBound &bound) override;\n-  void visit (AST::ImplTraitType &type) override;\n-  void visit (AST::TraitObjectType &type) override;\n-  void visit (AST::ParenthesisedType &type) override;\n-  void visit (AST::ImplTraitTypeOneBound &type) override;\n-  void visit (AST::TraitObjectTypeOneBound &type) override;\n-  void visit (AST::TupleType &type) override;\n-  void visit (AST::NeverType &type) override;\n-  void visit (AST::RawPointerType &type) override;\n-  void visit (AST::ReferenceType &type) override;\n-  void visit (AST::ArrayType &type) override;\n-  void visit (AST::SliceType &type) override;\n-  void visit (AST::InferredType &type) override;\n-  void visit (AST::BareFunctionType &type) override;\n-\n-private:\n-  TypeResolution (AST::Crate &crate, TopLevelScan &toplevel);\n-  bool go () override;\n-  bool typesAreCompatible (AST::Type *lhs, AST::Type *rhs, Location locus);\n-  AST::Function *lookupFndecl (AST::Expr *expr);\n-  bool isTypeInScope (AST::Type *type, Location locus);\n-\n-  TypeScoping scope;\n-  std::unique_ptr<std::string> identifierBuffer;\n-  std::unique_ptr<int> tupleIndexBuffer;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "8cfe156782e648d50c30d2d02cbb37eb2d29c6d6", "filename": "gcc/rust/analysis/rust-type-visitor.h", "status": "removed", "additions": 0, "deletions": 261, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-type-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fanalysis%2Frust-type-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-visitor.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -1,261 +0,0 @@\n-// rust-type-visitor.h -- Rust AST Visitor to AST::Type specific\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_TYPE_VISITOR_H\n-#define RUST_TYPE_VISITOR_H\n-\n-#include \"rust-system.h\"\n-#include \"rust-ast-full.h\"\n-#include \"rust-ast-visitor.h\"\n-#include \"rust-scan.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-class BaseTypeVisitor : public AST::ASTVisitor\n-{\n-public:\n-  // visitor impl\n-  // rust-ast.h\n-  //  virtual void visit(AttrInput& attr_input);\n-  //  virtual void visit(TokenTree& token_tree);\n-  //  virtual void visit(MacroMatch& macro_match);\n-  virtual void visit (AST::Token &tok) override {}\n-  virtual void visit (AST::DelimTokenTree &delim_tok_tree) override {}\n-  virtual void visit (AST::AttrInputMetaItemContainer &input) override {}\n-  //  virtual void visit(MetaItem& meta_item) override {}\n-  //  void vsit(Stmt& stmt) override {}\n-  //  virtual void visit(Expr& expr) override {}\n-  virtual void visit (AST::IdentifierExpr &ident_expr) override {}\n-  //  virtual void visit(Pattern& pattern) override {}\n-  //  virtual void visit(Type& type) override {}\n-  //  virtual void visit(TypeParamBound& type_param_bound) override {}\n-  virtual void visit (AST::Lifetime &lifetime) override {}\n-  //  virtual void visit(GenericParam& generic_param) override {}\n-  virtual void visit (AST::LifetimeParam &lifetime_param) override {}\n-  //  virtual void visit(TraitItem& trait_item) override {}\n-  //  virtual void visit(InherentImplItem& inherent_impl_item) override {}\n-  //  virtual void visit(TraitImplItem& trait_impl_item) override {}\n-  virtual void visit (AST::MacroInvocationSemi &macro) override {}\n-\n-  // rust-path.h\n-  virtual void visit (AST::PathInExpression &path) override {}\n-  virtual void visit (AST::TypePathSegment &segment) override {}\n-  virtual void visit (AST::TypePathSegmentGeneric &segment) override {}\n-  virtual void visit (AST::TypePathSegmentFunction &segment) override {}\n-  virtual void visit (AST::TypePath &path) override {}\n-  virtual void visit (AST::QualifiedPathInExpression &path) override {}\n-  virtual void visit (AST::QualifiedPathInType &path) override {}\n-\n-  // rust-expr.h\n-  virtual void visit (AST::LiteralExpr &expr) override {}\n-  virtual void visit (AST::AttrInputLiteral &attr_input) override {}\n-  virtual void visit (AST::MetaItemLitExpr &meta_item) override {}\n-  virtual void visit (AST::MetaItemPathLit &meta_item) override {}\n-  virtual void visit (AST::BorrowExpr &expr) override {}\n-  virtual void visit (AST::DereferenceExpr &expr) override {}\n-  virtual void visit (AST::ErrorPropagationExpr &expr) override {}\n-  virtual void visit (AST::NegationExpr &expr) override {}\n-  virtual void visit (AST::ArithmeticOrLogicalExpr &expr) override {}\n-  virtual void visit (AST::ComparisonExpr &expr) override {}\n-  virtual void visit (AST::LazyBooleanExpr &expr) override {}\n-  virtual void visit (AST::TypeCastExpr &expr) override {}\n-  virtual void visit (AST::AssignmentExpr &expr) override {}\n-  virtual void visit (AST::CompoundAssignmentExpr &expr) override {}\n-  virtual void visit (AST::GroupedExpr &expr) override {}\n-  //  virtual void visit(ArrayElems& elems) override {}\n-  virtual void visit (AST::ArrayElemsValues &elems) override {}\n-  virtual void visit (AST::ArrayElemsCopied &elems) override {}\n-  virtual void visit (AST::ArrayExpr &expr) override {}\n-  virtual void visit (AST::ArrayIndexExpr &expr) override {}\n-  virtual void visit (AST::TupleExpr &expr) override {}\n-  virtual void visit (AST::TupleIndexExpr &expr) override {}\n-  virtual void visit (AST::StructExprStruct &expr) override {}\n-  //  virtual void visit(StructExprField& field) override {}\n-  virtual void visit (AST::StructExprFieldIdentifier &field) override {}\n-  virtual void visit (AST::StructExprFieldIdentifierValue &field) override {}\n-  virtual void visit (AST::StructExprFieldIndexValue &field) override {}\n-  virtual void visit (AST::StructExprStructFields &expr) override {}\n-  virtual void visit (AST::StructExprStructBase &expr) override {}\n-  virtual void visit (AST::StructExprTuple &expr) override {}\n-  virtual void visit (AST::StructExprUnit &expr) override {}\n-  //  virtual void visit(EnumExprField& field) override {}\n-  virtual void visit (AST::EnumExprFieldIdentifier &field) override {}\n-  virtual void visit (AST::EnumExprFieldIdentifierValue &field) override {}\n-  virtual void visit (AST::EnumExprFieldIndexValue &field) override {}\n-  virtual void visit (AST::EnumExprStruct &expr) override {}\n-  virtual void visit (AST::EnumExprTuple &expr) override {}\n-  virtual void visit (AST::EnumExprFieldless &expr) override {}\n-  virtual void visit (AST::CallExpr &expr) override {}\n-  virtual void visit (AST::MethodCallExpr &expr) override {}\n-  virtual void visit (AST::FieldAccessExpr &expr) override {}\n-  virtual void visit (AST::ClosureExprInner &expr) override {}\n-  virtual void visit (AST::BlockExpr &expr) override {}\n-  virtual void visit (AST::ClosureExprInnerTyped &expr) override {}\n-  virtual void visit (AST::ContinueExpr &expr) override {}\n-  virtual void visit (AST::BreakExpr &expr) override {}\n-  virtual void visit (AST::RangeFromToExpr &expr) override {}\n-  virtual void visit (AST::RangeFromExpr &expr) override {}\n-  virtual void visit (AST::RangeToExpr &expr) override {}\n-  virtual void visit (AST::RangeFullExpr &expr) override {}\n-  virtual void visit (AST::RangeFromToInclExpr &expr) override {}\n-  virtual void visit (AST::RangeToInclExpr &expr) override {}\n-  virtual void visit (AST::ReturnExpr &expr) override {}\n-  virtual void visit (AST::UnsafeBlockExpr &expr) override {}\n-  virtual void visit (AST::LoopExpr &expr) override {}\n-  virtual void visit (AST::WhileLoopExpr &expr) override {}\n-  virtual void visit (AST::WhileLetLoopExpr &expr) override {}\n-  virtual void visit (AST::ForLoopExpr &expr) override {}\n-  virtual void visit (AST::IfExpr &expr) override {}\n-  virtual void visit (AST::IfExprConseqElse &expr) override {}\n-  virtual void visit (AST::IfExprConseqIf &expr) override {}\n-  virtual void visit (AST::IfExprConseqIfLet &expr) override {}\n-  virtual void visit (AST::IfLetExpr &expr) override {}\n-  virtual void visit (AST::IfLetExprConseqElse &expr) override {}\n-  virtual void visit (AST::IfLetExprConseqIf &expr) override {}\n-  virtual void visit (AST::IfLetExprConseqIfLet &expr) override {}\n-  //  virtual void visit(MatchCase& match_case) override {}\n-  // virtual void visit (AST::MatchCaseBlockExpr &match_case) override {}\n-  // virtual void visit (AST::MatchCaseExpr &match_case) override {}\n-  virtual void visit (AST::MatchExpr &expr) override {}\n-  virtual void visit (AST::AwaitExpr &expr) override {}\n-  virtual void visit (AST::AsyncBlockExpr &expr) override {}\n-\n-  // rust-item.h\n-  virtual void visit (AST::TypeParam &param) override {}\n-  //  virtual void visit(WhereClauseItem& item) override {}\n-  virtual void visit (AST::LifetimeWhereClauseItem &item) override {}\n-  virtual void visit (AST::TypeBoundWhereClauseItem &item) override {}\n-  virtual void visit (AST::Method &method) override {}\n-  virtual void visit (AST::ModuleBodied &module) override {}\n-  virtual void visit (AST::ModuleNoBody &module) override {}\n-  virtual void visit (AST::ExternCrate &crate) override {}\n-  //  virtual void visit(UseTree& use_tree) override {}\n-  virtual void visit (AST::UseTreeGlob &use_tree) override {}\n-  virtual void visit (AST::UseTreeList &use_tree) override {}\n-  virtual void visit (AST::UseTreeRebind &use_tree) override {}\n-  virtual void visit (AST::UseDeclaration &use_decl) override {}\n-  virtual void visit (AST::Function &function) override {}\n-  virtual void visit (AST::TypeAlias &type_alias) override {}\n-  virtual void visit (AST::StructStruct &struct_item) override {}\n-  virtual void visit (AST::TupleStruct &tuple_struct) override {}\n-  virtual void visit (AST::EnumItem &item) override {}\n-  virtual void visit (AST::EnumItemTuple &item) override {}\n-  virtual void visit (AST::EnumItemStruct &item) override {}\n-  virtual void visit (AST::EnumItemDiscriminant &item) override {}\n-  virtual void visit (AST::Enum &enum_item) override {}\n-  virtual void visit (AST::Union &union_item) override {}\n-  virtual void visit (AST::ConstantItem &const_item) override {}\n-  virtual void visit (AST::StaticItem &static_item) override {}\n-  virtual void visit (AST::TraitItemFunc &item) override {}\n-  virtual void visit (AST::TraitItemMethod &item) override {}\n-  virtual void visit (AST::TraitItemConst &item) override {}\n-  virtual void visit (AST::TraitItemType &item) override {}\n-  virtual void visit (AST::Trait &trait) override {}\n-  virtual void visit (AST::InherentImpl &impl) override {}\n-  virtual void visit (AST::TraitImpl &impl) override {}\n-  //  virtual void visit(ExternalItem& item) override {}\n-  virtual void visit (AST::ExternalStaticItem &item) override {}\n-  virtual void visit (AST::ExternalFunctionItem &item) override {}\n-  virtual void visit (AST::ExternBlock &block) override {}\n-\n-  // rust-macro.h\n-  virtual void visit (AST::MacroMatchFragment &match) override {}\n-  virtual void visit (AST::MacroMatchRepetition &match) override {}\n-  virtual void visit (AST::MacroMatcher &matcher) override {}\n-  virtual void visit (AST::MacroRulesDefinition &rules_def) override {}\n-  virtual void visit (AST::MacroInvocation &macro_invoc) override {}\n-  virtual void visit (AST::MetaItemPath &meta_item) override {}\n-  virtual void visit (AST::MetaItemSeq &meta_item) override {}\n-  virtual void visit (AST::MetaWord &meta_item) override {}\n-  virtual void visit (AST::MetaNameValueStr &meta_item) override {}\n-  virtual void visit (AST::MetaListPaths &meta_item) override {}\n-  virtual void visit (AST::MetaListNameValueStr &meta_item) override {}\n-\n-  // rust-pattern.h\n-  virtual void visit (AST::LiteralPattern &pattern) override {}\n-  virtual void visit (AST::IdentifierPattern &pattern) override {}\n-  virtual void visit (AST::WildcardPattern &pattern) override {}\n-  //  virtual void visit(RangePatternBound& bound) override {}\n-  virtual void visit (AST::RangePatternBoundLiteral &bound) override {}\n-  virtual void visit (AST::RangePatternBoundPath &bound) override {}\n-  virtual void visit (AST::RangePatternBoundQualPath &bound) override {}\n-  virtual void visit (AST::RangePattern &pattern) override {}\n-  virtual void visit (AST::ReferencePattern &pattern) override {}\n-  //  virtual void visit(StructPatternField& field) override {}\n-  virtual void visit (AST::StructPatternFieldTuplePat &field) override {}\n-  virtual void visit (AST::StructPatternFieldIdentPat &field) override {}\n-  virtual void visit (AST::StructPatternFieldIdent &field) override {}\n-  virtual void visit (AST::StructPattern &pattern) override {}\n-  //  virtual void visit(TupleStructItems& tuple_items) override {}\n-  virtual void visit (AST::TupleStructItemsNoRange &tuple_items) override {}\n-  virtual void visit (AST::TupleStructItemsRange &tuple_items) override {}\n-  virtual void visit (AST::TupleStructPattern &pattern) override {}\n-  //  virtual void visit(TuplePatternItems& tuple_items) override {}\n-  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items) override {}\n-  virtual void visit (AST::TuplePatternItemsRanged &tuple_items) override {}\n-  virtual void visit (AST::TuplePattern &pattern) override {}\n-  virtual void visit (AST::GroupedPattern &pattern) override {}\n-  virtual void visit (AST::SlicePattern &pattern) override {}\n-\n-  // rust-stmt.h\n-  virtual void visit (AST::EmptyStmt &stmt) override {}\n-  virtual void visit (AST::LetStmt &stmt) override {}\n-  virtual void visit (AST::ExprStmtWithoutBlock &stmt) override {}\n-  virtual void visit (AST::ExprStmtWithBlock &stmt) override {}\n-\n-  // rust-type.h\n-  virtual void visit (AST::TraitBound &bound) override {}\n-  virtual void visit (AST::ImplTraitType &type) override {}\n-  virtual void visit (AST::TraitObjectType &type) override {}\n-  virtual void visit (AST::ParenthesisedType &type) override {}\n-  virtual void visit (AST::ImplTraitTypeOneBound &type) override {}\n-  virtual void visit (AST::TraitObjectTypeOneBound &type) override {}\n-  virtual void visit (AST::TupleType &type) override {}\n-  virtual void visit (AST::NeverType &type) override {}\n-  virtual void visit (AST::RawPointerType &type) override {}\n-  virtual void visit (AST::ReferenceType &type) override {}\n-  virtual void visit (AST::ArrayType &type) override {}\n-  virtual void visit (AST::SliceType &type) override {}\n-  virtual void visit (AST::InferredType &type) override {}\n-  virtual void visit (AST::BareFunctionType &type) override {}\n-};\n-\n-class ArrayTypeVisitor : public BaseTypeVisitor\n-{\n-public:\n-  static AST::ArrayType *Resolve (AST::Type *type)\n-  {\n-    ArrayTypeVisitor vis;\n-    type->accept_vis (vis);\n-    return vis.resolved;\n-  }\n-\n-  virtual void visit (AST::ArrayType &type) override { resolved = &type; };\n-\n-private:\n-  ArrayTypeVisitor () : resolved (nullptr) {}\n-\n-  AST::ArrayType *resolved;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust\n-\n-#endif // RUST_TYPE_VISITOR_H"}, {"sha": "a4b5cd490f22976afdac35e42e9803f596a5e26c", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 19, "deletions": 1488, "changes": 1507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a621e19365473b477d121c28a057cc25d3951c76/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a621e19365473b477d121c28a057cc25d3951c76/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=a621e19365473b477d121c28a057cc25d3951c76", "patch": "@@ -1,1500 +1,31 @@\n-#include \"rust-compile.h\"\n-#include \"rust-diagnostics.h\"\n-\n-namespace Rust {\n-namespace Compile {\n-\n-#define VISIT_POP(L, S, R, B)                                                  \\\n-  do                                                                           \\\n-    {                                                                          \\\n-      auto before = B.size ();                                                 \\\n-      S->accept_vis (*this);                                                   \\\n-      if (B.size () <= before)                                                 \\\n-\tbreak;                                                                 \\\n-      R = B.back ();                                                           \\\n-      B.pop_back ();                                                           \\\n-    }                                                                          \\\n-  while (0)\n-\n-Compilation::Compilation (AST::Crate &crate, ::Backend *backend)\n-  : crate (crate), backend (backend), scope (backend)\n-{}\n-\n-Compilation::~Compilation () {}\n-\n-bool\n-Compilation::Compile (AST::Crate &crate, ::Backend *backend)\n-{\n-  Compilation resolver (crate, backend);\n-  return resolver.go ();\n-}\n-\n-bool\n-Compilation::go ()\n-{\n-  scope.Push ();\n-\n-  // builtin primitives\n-  scope.InsertType (\"bool\",\n-\t\t    backend->named_type (\"bool\", backend->bool_type (),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"i64\",\n-\t\t    backend->named_type (\"i64\",\n-\t\t\t\t\t backend->integer_type (false, 64),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"i32\",\n-\t\t    backend->named_type (\"i32\",\n-\t\t\t\t\t backend->integer_type (false, 32),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"i16\",\n-\t\t    backend->named_type (\"i16\",\n-\t\t\t\t\t backend->integer_type (false, 16),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"i8\",\n-\t\t    backend->named_type (\"i8\", backend->integer_type (false, 8),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"u64\",\n-\t\t    backend->named_type (\"u64\",\n-\t\t\t\t\t backend->integer_type (true, 64),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"u32\",\n-\t\t    backend->named_type (\"u32\",\n-\t\t\t\t\t backend->integer_type (true, 32),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"u16\",\n-\t\t    backend->named_type (\"u16\",\n-\t\t\t\t\t backend->integer_type (true, 16),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"u8\",\n-\t\t    backend->named_type (\"u8\", backend->integer_type (true, 8),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"f64\", backend->float_type (64));\n-  scope.InsertType (\"f32\", backend->float_type (32));\n-\n-  for (auto &item : crate.items)\n-    item->accept_vis (*this);\n-  scope.Pop ();\n-\n-  // Define all globally declared values.\n-  if (saw_errors ())\n-    return false;\n-\n-  backend->write_global_definitions (type_decls, const_decls, func_decls,\n-\t\t\t\t     var_decls);\n-  return true;\n-}\n-\n-bool\n-Compilation::compileVarDecl (Bfunction *fndecl, AST::LetStmt *stmt,\n-\t\t\t     std::vector<Bvariable *> &vars)\n-{\n-  AST::Type *type = stmt->has_type () ? stmt->get_type ().get () : stmt->inferedType;\n-  translatedType = NULL;\n-  type->accept_vis (*this);\n-  if (translatedType == NULL)\n-    {\n-      rust_error_at (stmt->get_locus (), \"failed to compile type for var decl\");\n-      return false;\n-    }\n-\n-  stmt->get_pattern ()->accept_vis (*this);\n-  for (auto &pattern : patternBuffer)\n-    {\n-      auto var = backend->local_variable (fndecl, pattern.get_ident (),\n-\t\t\t\t\t  translatedType, NULL /*decl_var*/,\n-\t\t\t\t\t  false /*address_taken*/, stmt->get_locus ());\n-      vars.push_back (var);\n-      scope.InsertVar (pattern.get_ident (), var);\n-    }\n-  patternBuffer.clear ();\n-  return true;\n-}\n-\n-Bexpression *\n-Compilation::compileBooleanLiteral (std::string val)\n-{\n-  bool bval = val.compare (\"true\") == 0;\n-  return backend->boolean_constant_expression (bval);\n-}\n-\n-Bexpression *\n-Compilation::compileFloatLiteral (std::string val, Location locus)\n-{\n-  Btype *type = NULL;\n-  bool ok = scope.LookupType (\"f32\", &type);\n-  if (!ok)\n-    {\n-      rust_fatal_error (locus, \"unable to find type\");\n-      return NULL;\n-    }\n-  mpfr_t fval;\n-  if (mpfr_init_set_str (fval, val.c_str (), 10, GMP_RNDN) != 0)\n-    {\n-      rust_fatal_error (locus, \"bad number in literal\");\n-      return NULL;\n-    }\n-  return backend->float_constant_expression (type, fval);\n-}\n-\n-Bexpression *\n-Compilation::compileIntegerLiteral (std::string val, Location locus)\n-{\n-  Btype *type = NULL;\n-  bool ok = scope.LookupType (\"i32\", &type);\n-  if (!ok)\n-    {\n-      rust_fatal_error (locus, \"unable to find type\");\n-      return NULL;\n-    }\n-  mpz_t ival;\n-  if (mpz_init_set_str (ival, val.c_str (), 10) != 0)\n-    {\n-      rust_fatal_error (locus, \"bad number in literal\");\n-      return NULL;\n-    }\n-  return backend->integer_constant_expression (type, ival);\n-}\n-\n-void\n-Compilation::visit (AST::Token &tok)\n-{}\n-\n-void\n-Compilation::visit (AST::DelimTokenTree &delim_tok_tree)\n-{}\n-\n-void\n-Compilation::visit (AST::AttrInputMetaItemContainer &input)\n-{}\n-\n-void\n-Compilation::visit (AST::IdentifierExpr &ident_expr)\n-{\n-  Bvariable *var = NULL;\n-  if (!scope.LookupVar (ident_expr.as_string (), &var))\n-    {\n-      rust_fatal_error (ident_expr.get_locus (), \"unknown var\");\n-      return;\n-    }\n-  exprs.push_back (backend->var_expression (var, ident_expr.get_locus ()));\n-}\n-\n-void\n-Compilation::visit (AST::Lifetime &lifetime)\n-{}\n-\n-void\n-Compilation::visit (AST::LifetimeParam &lifetime_param)\n-{}\n-\n-void\n-Compilation::visit (AST::MacroInvocationSemi &macro)\n-{}\n-\n-// rust-path.h\n-void\n-Compilation::visit (AST::PathInExpression &path)\n-{\n-  Bfunction *fn = NULL;\n-  if (scope.LookupFunction (path.as_string (), &fn))\n-    {\n-      auto expr\n-\t= backend->function_code_expression (fn, path.get_locus ());\n-      exprs.push_back (expr);\n-      translatedType = scope.GetFnRetType (fn);\n-      return;\n-    }\n-}\n-\n-void\n-Compilation::visit (AST::TypePathSegment &segment)\n-{}\n-void\n-Compilation::visit (AST::TypePathSegmentGeneric &segment)\n-{}\n-void\n-Compilation::visit (AST::TypePathSegmentFunction &segment)\n-{}\n-\n-void\n-Compilation::visit (AST::TypePath &path)\n-{\n-  if (path.get_segments ().size () > 1)\n-    {\n-      rust_error_at (path.get_locus (), \"unable to compile multi segment types yet\");\n-      return;\n-    }\n-\n-  Btype *type = NULL;\n-  if (!scope.LookupType (path.as_string (), &type))\n-    {\n-      rust_error_at (path.get_locus (), \"unknown type\");\n-      return;\n-    }\n-  translatedType = type;\n-}\n-\n-void\n-Compilation::visit (AST::QualifiedPathInExpression &path)\n-{}\n-void\n-Compilation::visit (AST::QualifiedPathInType &path)\n-{}\n-\n-// rust-expr.h\n-void\n-Compilation::visit (AST::LiteralExpr &expr)\n-{\n-  Bexpression *compiled;\n-  switch (expr.get_lit_type ())\n-    {\n-    case AST::Literal::BOOL:\n-      compiled = compileBooleanLiteral (expr.as_string ());\n-      break;\n-\n-    case AST::Literal::FLOAT:\n-      compiled\n-\t= compileFloatLiteral (expr.as_string (), expr.get_locus ());\n-      break;\n-\n-    case AST::Literal::INT:\n-      compiled\n-\t= compileIntegerLiteral (expr.as_string (), expr.get_locus ());\n-      break;\n-\n-    default:\n-      rust_fatal_error (expr.get_locus (), \"unknown literal\");\n-      return;\n-    }\n-\n-  exprs.push_back (compiled);\n-}\n-\n-void\n-Compilation::visit (AST::AttrInputLiteral &attr_input)\n-{}\n-void\n-Compilation::visit (AST::MetaItemLitExpr &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaItemPathLit &meta_item)\n-{}\n-void\n-Compilation::visit (AST::BorrowExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::DereferenceExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::ErrorPropagationExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::NegationExpr &expr)\n-{\n-  Bexpression *root = NULL;\n-  VISIT_POP (expr.get_negated_expr ()->get_locus_slow (), expr.get_negated_expr ().get (), root,\n-\t     exprs);\n-  if (root == NULL)\n-    {\n-      rust_error_at (expr.get_negated_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Operator op;\n-  switch (expr.get_negation_type ())\n-    {\n-    case AST::NegationExpr::NEGATE:\n-      op = OPERATOR_MINUS;\n-      break;\n-    case AST::NegationExpr::NOT:\n-      op = OPERATOR_NOT;\n-      break;\n-    default:\n-      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n-      return;\n-    }\n-\n-  auto unary = backend->unary_expression (op, root, expr.get_locus ());\n-  exprs.push_back (unary);\n-}\n-\n-void\n-Compilation::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{\n-  Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n-  if (lhs == NULL)\n-    {\n-      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Bexpression *rhs = NULL;\n-  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n-  if (rhs == NULL)\n-    {\n-      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Operator op;\n-  switch (expr.get_expr_type ())\n-    {\n-    case AST::ArithmeticOrLogicalExpr::ADD:\n-      op = OPERATOR_PLUS;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::SUBTRACT:\n-      op = OPERATOR_MINUS;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::MULTIPLY:\n-      op = OPERATOR_MULT;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::DIVIDE:\n-      op = OPERATOR_DIV;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::MODULUS:\n-      op = OPERATOR_MOD;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::BITWISE_AND:\n-      op = OPERATOR_AND;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::BITWISE_OR:\n-      op = OPERATOR_OR;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::BITWISE_XOR:\n-      op = OPERATOR_XOR;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::LEFT_SHIFT:\n-      op = OPERATOR_LSHIFT;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::RIGHT_SHIFT:\n-      op = OPERATOR_RSHIFT;\n-      break;\n-    default:\n-      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n-      return;\n-    }\n-\n-  auto binExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n-  exprs.push_back (binExpr);\n-}\n-\n-void\n-Compilation::visit (AST::ComparisonExpr &expr)\n-{\n-  Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n-  if (lhs == NULL)\n-    {\n-      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Bexpression *rhs = NULL;\n-  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n-  if (rhs == NULL)\n-    {\n-      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Operator op;\n-  switch (expr.get_expr_type ())\n-    {\n-    case AST::ComparisonExpr::EQUAL:\n-      op = OPERATOR_EQEQ;\n-      break;\n-    case AST::ComparisonExpr::NOT_EQUAL:\n-      op = OPERATOR_NOTEQ;\n-      break;\n-    case AST::ComparisonExpr::GREATER_THAN:\n-      op = OPERATOR_GT;\n-      break;\n-    case AST::ComparisonExpr::LESS_THAN:\n-      op = OPERATOR_LT;\n-      break;\n-    case AST::ComparisonExpr::GREATER_OR_EQUAL:\n-      op = OPERATOR_GE;\n-      break;\n-    case AST::ComparisonExpr::LESS_OR_EQUAL:\n-      op = OPERATOR_LE;\n-      break;\n-    default:\n-      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n-      return;\n-    }\n-\n-  auto compExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n-  exprs.push_back (compExpr);\n-}\n-\n-void\n-Compilation::visit (AST::LazyBooleanExpr &expr)\n-{\n-  Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n-  if (lhs == NULL)\n-    {\n-      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Bexpression *rhs = NULL;\n-  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n-  if (rhs == NULL)\n-    {\n-      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Operator op;\n-  switch (expr.get_expr_type ())\n-    {\n-    case AST::LazyBooleanExpr::LOGICAL_OR:\n-      op = OPERATOR_OROR;\n-      break;\n-    case AST::LazyBooleanExpr::LOGICAL_AND:\n-      op = OPERATOR_ANDAND;\n-      break;\n-    default:\n-      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n-      return;\n-    }\n-\n-  auto compExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n-  exprs.push_back (compExpr);\n-}\n-\n-void\n-Compilation::visit (AST::TypeCastExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::AssignmentExpr &expr)\n-{\n-  Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n-  if (lhs == NULL)\n-    {\n-      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Bexpression *rhs = NULL;\n-  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n-  if (rhs == NULL)\n-    {\n-      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  auto s = backend->assignment_statement (scope.GetCurrentFndecl (), lhs, rhs,\n-\t\t\t\t\t  expr.get_locus ());\n-  scope.AddStatement (s);\n-}\n-\n-void\n-Compilation::visit (AST::CompoundAssignmentExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::GroupedExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::ArrayElemsValues &elems)\n-{\n-  std::vector< ::Bexpression *> elements;\n-\n-  bool failed = false;\n-  elems.iterate ([&] (AST::Expr *expr) mutable -> bool {\n-    Bexpression *value = nullptr;\n-    VISIT_POP (expr.get_locus_slow (), expr, value, exprs);\n-    if (value == nullptr)\n-      {\n-\trust_fatal_error (expr->get_locus_slow (),\n-\t\t\t  \"failed to compile value to array initialiser\");\n-\treturn false;\n-      }\n-    elements.push_back (value);\n-    return true;\n-  });\n-\n-  // nothing to do when its failed\n-  if (failed)\n-    return;\n-\n-  arrayConsStack.push_back (elements);\n-}\n-\n-void\n-Compilation::visit (AST::ArrayElemsCopied &elems)\n-{}\n-\n-void\n-Compilation::visit (AST::ArrayExpr &expr)\n-{\n-  translatedType = nullptr;\n-  expr.get_inferred_type ()->accept_vis (*this);\n-  if (translatedType == nullptr)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"failed to compile array type for ArrayExpr\");\n-      return;\n-    }\n-\n-  ::Btype *compiledType = translatedType;\n-  translatedType = nullptr;\n-\n-  auto before = arrayConsStack.size ();\n-  expr.get_array_elems ()->accept_vis (*this);\n-  if (arrayConsStack.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"failed to compile the array constructor\");\n-      return;\n-    }\n-  std::vector< ::Bexpression *> initializer = arrayConsStack.back ();\n-  arrayConsStack.pop_back ();\n-\n-  std::vector<unsigned long> indexes;\n-  for (unsigned long i = 0; i < initializer.size (); ++i)\n-    indexes.push_back (i);\n-\n-  Bexpression *cons\n-    = backend->array_constructor_expression (compiledType, indexes, initializer,\n-\t\t\t\t\t     expr.get_locus_slow ());\n-  exprs.push_back (cons);\n-}\n-\n-void\n-Compilation::visit (AST::ArrayIndexExpr &expr)\n-{\n-  Bexpression *arrayExpr = nullptr;\n-  VISIT_POP (expr.get_array_expr ()->get_locus_slow (), expr.get_array_expr (),\n-\t     arrayExpr, exprs);\n-  if (arrayExpr == nullptr)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"failed to compile value to array expression reference\");\n-      return;\n-    }\n-\n-  Bexpression *indexExpr = nullptr;\n-  VISIT_POP (expr.get_index_expr ()->get_locus_slow (), expr.get_index_expr (),\n-\t     indexExpr, exprs);\n-  if (indexExpr == nullptr)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"failed to compile value to array index expression\");\n-      return;\n-    }\n-\n-  Bexpression *indexExpression\n-    = backend->array_index_expression (arrayExpr, indexExpr,\n-\t\t\t\t       expr.get_locus_slow ());\n-  exprs.push_back (indexExpression);\n-}\n-\n-void\n-Compilation::visit (AST::TupleExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::TupleIndexExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::StructExprStruct &expr)\n-{}\n-// void Compilation::visit(StructExprField& field) {}\n-void\n-Compilation::visit (AST::StructExprFieldIdentifier &field)\n-{}\n-\n-void\n-Compilation::visit (AST::StructExprFieldIdentifierValue &field)\n-{\n-  Bexpression *value = NULL;\n-  VISIT_POP (field.get_value ()->get_locus_slow (), field.get_value ().get (), value, exprs);\n-  if (value == NULL)\n-    {\n-      rust_fatal_error (field.get_value ()->get_locus_slow (),\n-\t\t\t\"failed to compile value to struct\");\n-      return;\n-    }\n-  exprs.push_back (value);\n-}\n-\n-void\n-Compilation::visit (AST::StructExprFieldIndexValue &field)\n-{\n-  Bexpression *value = NULL;\n-  VISIT_POP (field.get_value ()->get_locus_slow (), field.get_value ().get (), value, exprs);\n-  if (value == NULL)\n-    {\n-      rust_fatal_error (field.get_value ()->get_locus_slow (),\n-\t\t\t\"failed to compile value to struct\");\n-      return;\n-    }\n-  exprs.push_back (value);\n-}\n-\n-void\n-Compilation::visit (AST::StructExprStructFields &expr)\n-{\n-  AST::StructStruct *decl = NULL;\n-  if (!scope.LookupStructDecl (expr.get_struct_name ().as_string (), &decl))\n-    {\n-      rust_error_at (expr.get_locus (), \"unknown type\");\n-      return;\n-    }\n-\n-  Btype *structType = NULL;\n-  if (!scope.LookupType (expr.get_struct_name ().as_string (), &structType))\n-    {\n-      rust_fatal_error (expr.get_locus (), \"unknown type\");\n-      return;\n-    }\n-\n-  structBuffer.push_back (decl);\n-  std::vector<Bexpression *> constructor;\n-\n-  // FIXME type resolution pass should ensures these are in correct order\n-  // and have defaults if required\n-  for (auto &field : expr.get_fields ())\n-    {\n-      Bexpression *value = NULL;\n-      VISIT_POP (expr.get_locus (), field, value, exprs);\n-      if (value == NULL)\n-\t{\n-\t  rust_fatal_error (expr.get_locus (),\n-\t\t\t    \"failed to compile value to struct\");\n-\t  return;\n-\t}\n-\n-      constructor.push_back (value);\n-    }\n-\n-  structBuffer.pop_back ();\n-  auto cons = backend->constructor_expression (structType, constructor,\n-\t\t\t\t\t       expr.get_locus ());\n-  exprs.push_back (cons);\n-}\n-\n-void\n-Compilation::visit (AST::StructExprStructBase &expr)\n-{}\n-void\n-Compilation::visit (AST::StructExprTuple &expr)\n-{}\n-void\n-Compilation::visit (AST::StructExprUnit &expr)\n-{}\n-// void Compilation::visit(EnumExprField& field) {}\n-void\n-Compilation::visit (AST::EnumExprFieldIdentifier &field)\n-{}\n-void\n-Compilation::visit (AST::EnumExprFieldIdentifierValue &field)\n-{}\n-void\n-Compilation::visit (AST::EnumExprFieldIndexValue &field)\n-{}\n-void\n-Compilation::visit (AST::EnumExprStruct &expr)\n-{}\n-void\n-Compilation::visit (AST::EnumExprTuple &expr)\n-{}\n-void\n-Compilation::visit (AST::EnumExprFieldless &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::CallExpr &expr)\n-{\n-  Bexpression *fn = NULL;\n-  VISIT_POP (expr.get_function_expr ()->get_locus_slow (), expr.get_function_expr (), fn, exprs);\n-  if (fn == NULL)\n-    {\n-      rust_error_at (expr.get_function_expr ()->get_locus_slow (), \"failed to resolve\");\n-      return;\n-    }\n-\n-  std::vector<Bexpression *> args;\n-  for (auto &param : expr.get_params ())\n-    {\n-      Bexpression *arg = NULL;\n-      VISIT_POP (param->get_locus_slow (), param, arg, exprs);\n-      if (arg == NULL)\n-\t{\n-\t  rust_error_at (param->get_locus_slow (),\n-\t\t\t \"failed to compile argument\");\n-\t  return;\n-\t}\n-\n-      args.push_back (arg);\n-    }\n-\n-  auto call = backend->call_expression (scope.GetCurrentFndecl (), fn, args,\n-\t\t\t\t\tNULL, expr.get_locus ());\n-  exprs.push_back (call);\n-}\n-\n-void\n-Compilation::visit (AST::MethodCallExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::FieldAccessExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::ClosureExprInner &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::BlockExpr &expr)\n-{\n-  Bblock *enclosingScope = NULL;\n-  Location start_location; /* = stmt.locus; FIXME */\n-  Location end_location;   // FIXME\n-\n-  std::vector<Bvariable *> vars;\n-  auto code_block\n-    = backend->block (scope.GetCurrentFndecl (), scope.CurBlock (), vars,\n-\t\t      start_location, end_location);\n-\n-  scope.PushBlock (code_block);\n-  for (auto &stmt : expr.get_statements ())\n-    {\n-      stmt->accept_vis (*this);\n-    }\n-  // dont pop\n-}\n-\n-void\n-Compilation::visit (AST::ClosureExprInnerTyped &expr)\n-{}\n-void\n-Compilation::visit (AST::ContinueExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::BreakExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeFromToExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeFromExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeToExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeFullExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeFromToInclExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeToInclExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::ReturnExpr &expr)\n-{\n-  Bexpression *ret = NULL;\n-  VISIT_POP (expr.get_returned_expr ()->get_locus_slow (), expr.get_returned_expr ().get (), ret, exprs);\n-  if (ret == NULL)\n-    {\n-      rust_fatal_error (expr.get_returned_expr ()->get_locus_slow (),\n-\t\t\t\"failed to compile\");\n-      return;\n-    }\n-\n-  std::vector<Bexpression *> retstmts;\n-  retstmts.push_back (ret);\n-  auto s = backend->return_statement (scope.GetCurrentFndecl (), retstmts,\n-\t\t\t\t      expr.get_locus ());\n-  scope.AddStatement (s);\n-}\n-\n-void\n-Compilation::visit (AST::UnsafeBlockExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::LoopExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::WhileLoopExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::WhileLetLoopExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::ForLoopExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::IfExpr &expr)\n-{\n-  Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n-\t     expr.get_condition_expr ().get (), cond, exprs);\n-  if (cond == NULL)\n-    {\n-      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n-\t\t     \"failed to compile\");\n-      return;\n-    }\n-\n-  expr.vis_if_block (*this);\n-  Bblock *then_block = scope.PopBlock ();\n-\n-  auto stmt = backend->if_statement (scope.GetCurrentFndecl (), cond,\n-\t\t\t\t     then_block, NULL, expr.get_locus ());\n-  stmts.push_back (stmt);\n-}\n-\n-void\n-Compilation::visit (AST::IfExprConseqElse &expr)\n-{\n-  Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n-\t     expr.get_condition_expr ().get (), cond, exprs);\n-  if (cond == NULL)\n-    {\n-      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n-\t\t     \"failed to compile\");\n-      return;\n-    }\n-\n-  expr.vis_if_block (*this);\n-  Bblock *then_block = scope.PopBlock ();\n-\n-  expr.vis_else_block (*this);\n-  Bblock *else_block = scope.PopBlock ();\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n \n-  auto stmt\n-    = backend->if_statement (scope.GetCurrentFndecl (), cond, then_block,\n-\t\t\t     else_block, expr.get_locus ());\n-  stmts.push_back (stmt);\n-}\n+// This file is part of GCC.\n \n-void\n-Compilation::visit (AST::IfExprConseqIf &expr)\n-{\n-  Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n-\t     expr.get_condition_expr ().get (), cond, exprs);\n-  if (cond == NULL)\n-    {\n-      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n-\t\t     \"failed to compile\");\n-      return;\n-    }\n-\n-  expr.vis_if_block (*this);\n-  Bblock *then_block = scope.PopBlock ();\n-\n-  // setup else block\n-  Bblock *enclosingScope = NULL;\n-  Location start_location; /* = stmt.locus; FIXME */\n-  Location end_location;   // FIXME\n-\n-  std::vector<Bvariable *> vars;\n-  auto else_block\n-    = backend->block (scope.GetCurrentFndecl (), scope.CurBlock (), vars,\n-\t\t      start_location, end_location);\n-\n-  scope.PushBlock (else_block);\n-  expr.vis_conseq_if_expr (*this);\n-  // get trailing if required\n-  for (auto &s : stmts)\n-    scope.AddStatement (s);\n-  stmts.clear ();\n-  scope.PopBlock ();\n-\n-  auto stmt\n-    = backend->if_statement (scope.GetCurrentFndecl (), cond, then_block,\n-\t\t\t     else_block, expr.get_locus ());\n-  stmts.push_back (stmt);\n-}\n-\n-void\n-Compilation::visit (AST::IfExprConseqIfLet &expr)\n-{\n-  printf (\"IfExprConseqIfLet %s\\n\", expr.as_string ().c_str ());\n-}\n-void\n-Compilation::visit (AST::IfLetExpr &expr)\n-{\n-  printf (\"IfLetExpr %s\\n\", expr.as_string ().c_str ());\n-}\n-void\n-Compilation::visit (AST::IfLetExprConseqElse &expr)\n-{\n-  printf (\"IfLetExprConseqElse %s\\n\", expr.as_string ().c_str ());\n-}\n-\n-void\n-Compilation::visit (AST::IfLetExprConseqIf &expr)\n-{\n-  printf (\"IfLetExprConseqIf %s\\n\", expr.as_string ().c_str ());\n-}\n-\n-void\n-Compilation::visit (AST::IfLetExprConseqIfLet &expr)\n-{\n-  printf (\"IfLetExprConseqIfLet %s\\n\", expr.as_string ().c_str ());\n-}\n-\n-// void Compilation::visit(MatchCase& match_case) {}\n-/*void\n-Compilation::visit (AST::MatchCaseBlockExpr &match_case)\n-{}*/\n-/*void\n-Compilation::visit (AST::MatchCaseExpr &match_case)\n-{}*/\n-void\n-Compilation::visit (AST::MatchExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::AwaitExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::AsyncBlockExpr &expr)\n-{}\n-\n-// rust-item.h\n-void\n-Compilation::visit (AST::TypeParam &param)\n-{}\n-// void Compilation::visit(WhereClauseItem& item) {}\n-void\n-Compilation::visit (AST::LifetimeWhereClauseItem &item)\n-{}\n-void\n-Compilation::visit (AST::TypeBoundWhereClauseItem &item)\n-{}\n-void\n-Compilation::visit (AST::Method &method)\n-{}\n-void\n-Compilation::visit (AST::ModuleBodied &module)\n-{}\n-void\n-Compilation::visit (AST::ModuleNoBody &module)\n-{}\n-void\n-Compilation::visit (AST::ExternCrate &crate)\n-{}\n-// void Compilation::visit(UseTree& use_tree) {}\n-void\n-Compilation::visit (AST::UseTreeGlob &use_tree)\n-{}\n-void\n-Compilation::visit (AST::UseTreeList &use_tree)\n-{}\n-void\n-Compilation::visit (AST::UseTreeRebind &use_tree)\n-{}\n-void\n-Compilation::visit (AST::UseDeclaration &use_decl)\n-{}\n-\n-void\n-Compilation::visit (AST::Function &function)\n-{\n-  Backend::Btyped_identifier receiver;\n-  std::vector<Backend::Btyped_identifier> parameters;\n-  std::vector<Backend::Btyped_identifier> results;\n-\n-  for (auto &param : function.get_function_params ())\n-    {\n-      // translate the type\n-      translatedType = NULL;\n-      param.get_type ()->accept_vis (*this);\n-      if (translatedType == NULL)\n-\t{\n-\t  rust_error_at (param.get_locus (), \"failed to generate type for parameter\");\n-\t  return;\n-\t}\n-\n-      auto before = patternBuffer.size ();\n-      param.get_pattern ()->accept_vis (*this);\n-      if (patternBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (param.get_locus (), \"failed to analyse parameter name\");\n-\t  return;\n-\t}\n-\n-      auto numParamsPerType = patternBuffer.size () - before;\n-      for (size_t i = 0; i < numParamsPerType; i++)\n-\t{\n-\t  auto paramName = patternBuffer.back ();\n-\t  patternBuffer.pop_back ();\n-\t  parameters.push_back (\n-\t    Backend::Btyped_identifier (paramName.get_ident (),\n-\t\t\t\t\ttranslatedType, param.get_locus ()));\n-\t}\n-    }\n-\n-  Btype *returnType = NULL;\n-  if (function.has_return_type ())\n-    {\n-      translatedType = NULL;\n-      function.get_return_type ()->accept_vis (*this);\n-      if (translatedType == NULL)\n-\t{\n-\t  rust_fatal_error (function.get_locus (),\n-\t\t\t    \"failed to generate type for function\");\n-\t  return;\n-\t}\n-      returnType = translatedType;\n-\n-      // add into the results:\n-      results.push_back (\n-\tBackend::Btyped_identifier (\"_\", translatedType, Location ()));\n-    }\n-\n-  Btype *fntype = backend->function_type (receiver, parameters, results, NULL,\n-\t\t\t\t\t  function.get_locus ());\n-  Bfunction *fndecl\n-    = backend->function (fntype, function.get_function_name (), \"\" /* asm_name */,\n-\t\t\t 0 /* flags */, function.get_locus ());\n-\n-  scope.InsertFunction (function.get_function_name (), fndecl, returnType);\n-  scope.Push ();\n-\n-  // setup the params\n-  std::vector<Bvariable *> param_vars;\n-  for (auto &param : parameters)\n-    {\n-      bool tree_addressable = false;\n-      auto p = backend->parameter_variable (fndecl, param.name, param.btype,\n-\t\t\t\t\t    tree_addressable, param.location);\n-\n-      scope.InsertVar (param.name, p);\n-      param_vars.push_back (p);\n-    }\n-\n-  if (!backend->function_set_parameters (fndecl, param_vars))\n-    {\n-      rust_error_at (function.get_locus (), \"failed to setup parameter variables\");\n-      return;\n-    }\n-\n-  std::vector<Bvariable *> vars;\n-  for (auto &decl : function.locals)\n-    {\n-      if (!compileVarDecl (fndecl, decl, vars))\n-\t{\n-\t  rust_error_at (decl->get_locus (), \"failed to compile var decl\");\n-\t  return;\n-\t}\n-    }\n-\n-  // is null for top level functions - nested functions will have an enclosing\n-  // scope\n-  Bblock *enclosingScope = NULL;\n-  Location start_location = function.get_locus ();\n-  Location end_location;\n-  if (function.get_definition ()->get_statements ().size () > 0)\n-    {\n-      end_location\n-\t= function.get_definition ()->get_statements ().back ()->get_locus_slow ();\n-    }\n-\n-  auto code_block = backend->block (fndecl, enclosingScope, vars,\n-\t\t\t\t    start_location, end_location);\n-\n-  scope.PushBlock (code_block);\n-\n-  Bvariable *retDecl = NULL;\n-  if (function.has_return_type ())\n-    {\n-      bool address_is_taken = false;\n-      Bstatement *ret_var_stmt = NULL;\n-      retDecl = backend->temporary_variable (fndecl, code_block, returnType,\n-\t\t\t\t\t     NULL, address_is_taken,\n-\t\t\t\t\t     function.get_locus (), &ret_var_stmt);\n-      scope.AddStatement (ret_var_stmt);\n-    }\n-  scope.PushCurrentFunction (function.get_function_name (), fndecl, returnType,\n-\t\t\t     retDecl);\n-\n-  for (auto &stmt : function.get_definition ()->get_statements ())\n-    stmt->accept_vis (*this);\n-\n-  scope.PopBlock ();\n-\n-  auto body = backend->block_statement (code_block);\n-  if (!backend->function_set_body (fndecl, body))\n-    {\n-      rust_error_at (function.get_locus (), \"failed to set body to function\");\n-      return;\n-    }\n-\n-  scope.Pop ();\n-  scope.PopCurrentFunction ();\n-\n-  func_decls.push_back (fndecl);\n-}\n-\n-void\n-Compilation::visit (AST::TypeAlias &type_alias)\n-{}\n-\n-void\n-Compilation::visit (AST::StructStruct &struct_item)\n-{\n-  std::vector<Backend::Btyped_identifier> fields;\n-  for (auto &field : struct_item.get_fields ())\n-    {\n-      translatedType = NULL;\n-      field.get_field_type ()->accept_vis (*this);\n-      if (translatedType == NULL)\n-\t{\n-\t  rust_fatal_error (\n-\t    struct_item.get_locus () /* StructField is mi sing locus */,\n-\t    \"failed to compile struct field\");\n-\t  return;\n-\t}\n-\n-      fields.push_back (Backend::Btyped_identifier (\n-\tfield.get_field_name (), translatedType,\n-\tstruct_item.get_locus () /* StructField is mi sing locus */));\n-    }\n-\n-  auto compiledStruct\n-    = backend->placeholder_struct_type (struct_item.get_struct_name (),\n-\t\t\t\t\tstruct_item.get_locus ());\n-  bool ok = backend->set_placeholder_struct_type (compiledStruct, fields);\n-  if (!ok)\n-    {\n-      rust_fatal_error (struct_item.get_locus (), \"failed to compile struct\");\n-      return;\n-    }\n-\n-  type_decls.push_back (compiledStruct);\n-  scope.InsertType (struct_item.get_struct_name (), compiledStruct);\n-  scope.InsertStructDecl (struct_item.get_struct_name (), &struct_item);\n-}\n-\n-void\n-Compilation::visit (AST::TupleStruct &tuple_struct)\n-{}\n-void\n-Compilation::visit (AST::EnumItem &item)\n-{}\n-void\n-Compilation::visit (AST::EnumItemTuple &item)\n-{}\n-void\n-Compilation::visit (AST::EnumItemStruct &item)\n-{}\n-void\n-Compilation::visit (AST::EnumItemDiscriminant &item)\n-{}\n-void\n-Compilation::visit (AST::Enum &enum_item)\n-{}\n-void\n-Compilation::visit (AST::Union &union_item)\n-{}\n-void\n-Compilation::visit (AST::ConstantItem &const_item)\n-{}\n-void\n-Compilation::visit (AST::StaticItem &static_item)\n-{}\n-void\n-Compilation::visit (AST::TraitItemFunc &item)\n-{}\n-void\n-Compilation::visit (AST::TraitItemMethod &item)\n-{}\n-void\n-Compilation::visit (AST::TraitItemConst &item)\n-{}\n-void\n-Compilation::visit (AST::TraitItemType &item)\n-{}\n-void\n-Compilation::visit (AST::Trait &trait)\n-{}\n-void\n-Compilation::visit (AST::InherentImpl &impl)\n-{}\n-void\n-Compilation::visit (AST::TraitImpl &impl)\n-{}\n-// void Compilation::visit(ExternalItem& item) {}\n-void\n-Compilation::visit (AST::ExternalStaticItem &item)\n-{}\n-void\n-Compilation::visit (AST::ExternalFunctionItem &item)\n-{}\n-void\n-Compilation::visit (AST::ExternBlock &block)\n-{}\n-\n-// rust-macro.h\n-void\n-Compilation::visit (AST::MacroMatchFragment &match)\n-{}\n-void\n-Compilation::visit (AST::MacroMatchRepetition &match)\n-{}\n-void\n-Compilation::visit (AST::MacroMatcher &matcher)\n-{}\n-void\n-Compilation::visit (AST::MacroRulesDefinition &rules_def)\n-{}\n-void\n-Compilation::visit (AST::MacroInvocation &macro_invoc)\n-{}\n-void\n-Compilation::visit (AST::MetaItemPath &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaItemSeq &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaWord &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaNameValueStr &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaListPaths &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaListNameValueStr &meta_item)\n-{}\n-\n-// rust-pattern.h\n-void\n-Compilation::visit (AST::LiteralPattern &pattern)\n-{\n-  printf (\"LiteralPattern: %s\\n\", pattern.as_string ().c_str ());\n-}\n-\n-void\n-Compilation::visit (AST::IdentifierPattern &pattern)\n-{\n-  patternBuffer.push_back (pattern);\n-}\n-\n-void\n-Compilation::visit (AST::WildcardPattern &pattern)\n-{}\n-// void Compilation::visit(RangePatternBound& bound) {}\n-void\n-Compilation::visit (AST::RangePatternBoundLiteral &bound)\n-{}\n-void\n-Compilation::visit (AST::RangePatternBoundPath &bound)\n-{}\n-void\n-Compilation::visit (AST::RangePatternBoundQualPath &bound)\n-{}\n-void\n-Compilation::visit (AST::RangePattern &pattern)\n-{}\n-void\n-Compilation::visit (AST::ReferencePattern &pattern)\n-{}\n-// void Compilation::visit(StructPatternField& field) {}\n-void\n-Compilation::visit (AST::StructPatternFieldTuplePat &field)\n-{}\n-void\n-Compilation::visit (AST::StructPatternFieldIdentPat &field)\n-{}\n-void\n-Compilation::visit (AST::StructPatternFieldIdent &field)\n-{}\n-void\n-Compilation::visit (AST::StructPattern &pattern)\n-{}\n-// void Compilation::visit(TupleStructItems& tuple_items) {}\n-void\n-Compilation::visit (AST::TupleStructItemsNoRange &tuple_items)\n-{}\n-void\n-Compilation::visit (AST::TupleStructItemsRange &tuple_items)\n-{}\n-void\n-Compilation::visit (AST::TupleStructPattern &pattern)\n-{}\n-// void Compilation::visit(TuplePatternItems& tuple_items) {}\n-void\n-Compilation::visit (AST::TuplePatternItemsMultiple &tuple_items)\n-{}\n-void\n-Compilation::visit (AST::TuplePatternItemsRanged &tuple_items)\n-{}\n-void\n-Compilation::visit (AST::TuplePattern &pattern)\n-{}\n-void\n-Compilation::visit (AST::GroupedPattern &pattern)\n-{}\n-void\n-Compilation::visit (AST::SlicePattern &pattern)\n-{}\n-\n-// rust-stmt.h\n-void\n-Compilation::visit (AST::EmptyStmt &stmt)\n-{}\n-void\n-\n-Compilation::visit (AST::LetStmt &stmt)\n-{\n-  if (!stmt.has_init_expr ())\n-    return;\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n \n-  stmt.get_pattern ()->accept_vis (*this);\n-  for (auto &pattern : patternBuffer)\n-    {\n-      Bvariable *var = NULL;\n-      if (!scope.LookupVar (pattern.get_ident (), &var))\n-\t{\n-\t  rust_error_at (stmt.get_locus (), \"failed to find var decl for %s\",\n-\t\t\t pattern.get_ident ().c_str ());\n-\t  return;\n-\t}\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n \n-      varBuffer.push_back (var);\n-\n-      Bexpression *init = NULL;\n-      VISIT_POP (stmt.get_init_expr ()->get_locus_slow (), stmt.get_init_expr (), init,\n-\t\t exprs);\n-      if (init == NULL)\n-\t{\n-\t  rust_error_at (stmt.get_init_expr ()->get_locus_slow (),\n-\t\t\t \"failed to compile init statement\");\n-\t  return;\n-\t}\n-\n-      auto s = backend->init_statement (scope.GetCurrentFndecl (), var, init);\n-      scope.AddStatement (s);\n-\n-      varBuffer.pop_back ();\n-    }\n-  patternBuffer.clear ();\n-}\n-\n-void\n-Compilation::visit (AST::ExprStmtWithoutBlock &stmt)\n-{\n-  stmt.get_expr ()->accept_vis (*this);\n-}\n-\n-void\n-Compilation::visit (AST::ExprStmtWithBlock &stmt)\n-{\n-  Bblock *enclosingScope = NULL;\n-  Location start_location; /* = stmt.locus; FIXME */\n-  Location end_location;   // FIXME\n-\n-  std::vector<Bvariable *> vars;\n-  auto code_block\n-    = backend->block (scope.GetCurrentFndecl (), scope.CurBlock (), vars,\n-\t\t      start_location, end_location);\n-\n-  scope.PushBlock (code_block);\n-  stmt.get_expr ()->accept_vis (*this);\n-\n-  // get trailing if required\n-  for (auto &s : stmts)\n-    {\n-      scope.AddStatement (s);\n-    }\n-  stmts.clear ();\n-\n-  scope.PopBlock ();\n-\n-  auto body = backend->block_statement (code_block);\n-  scope.AddStatement (body);\n-}\n-\n-// rust-type.h\n-void\n-Compilation::visit (AST::TraitBound &bound)\n-{}\n-void\n-Compilation::visit (AST::ImplTraitType &type)\n-{}\n-void\n-Compilation::visit (AST::TraitObjectType &type)\n-{}\n-void\n-Compilation::visit (AST::ParenthesisedType &type)\n-{}\n-void\n-Compilation::visit (AST::ImplTraitTypeOneBound &type)\n-{}\n-void\n-Compilation::visit (AST::TraitObjectTypeOneBound &type)\n-{}\n-void\n-Compilation::visit (AST::TupleType &type)\n-{}\n-void\n-Compilation::visit (AST::NeverType &type)\n-{}\n-void\n-Compilation::visit (AST::RawPointerType &type)\n-{}\n-void\n-Compilation::visit (AST::ReferenceType &type)\n-{}\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n \n-void\n-Compilation::visit (AST::ArrayType &type)\n-{\n-  Btype *elementType;\n-  translatedType = nullptr;\n-  type.get_elem_type ()->accept_vis (*this);\n-  if (translatedType == nullptr)\n-    {\n-      rust_error_at (type.get_locus (),\n-\t\t     \"Failed to compile element type for array\");\n-      return;\n-    }\n-  elementType = translatedType;\n+#include \"rust-compile.h\"\n+#include \"rust-diagnostics.h\"\n \n-  Bexpression *length = nullptr;\n-  VISIT_POP (type.get_size_expr ()->get_locus_slow (), type.get_size_expr (),\n-\t     length, exprs);\n-  if (length == nullptr)\n-    {\n-      rust_error_at (type.get_size_expr ()->get_locus_slow (),\n-\t\t     \"failed to size for array type\");\n-      return;\n-    }\n+namespace Rust {\n+namespace Compile {\n \n-  translatedType = backend->array_type (elementType, length);\n-}\n+CompileCrate::~CompileCrate () {}\n \n void\n-Compilation::visit (AST::SliceType &type)\n-{}\n-void\n-Compilation::visit (AST::InferredType &type)\n-{}\n-void\n-Compilation::visit (AST::BareFunctionType &type)\n+CompileCrate::Compile (HIR::Crate &crate, Context *ctx)\n {}\n \n } // namespace Compile"}, {"sha": "5ee11227099bb14a374f9535d98985e3eaebac57", "filename": "gcc/rust/backend/rust-compile.h", "status": "modified", "additions": 69, "deletions": 237, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a621e19365473b477d121c28a057cc25d3951c76/gcc%2Frust%2Fbackend%2Frust-compile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a621e19365473b477d121c28a057cc25d3951c76/gcc%2Frust%2Fbackend%2Frust-compile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.h?ref=a621e19365473b477d121c28a057cc25d3951c76", "patch": "@@ -1,257 +1,89 @@\n-#pragma once\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_H\n+#define RUST_COMPILE_H\n \n #include \"rust-system.h\"\n-#include \"rust-ast-full.h\"\n-#include \"rust-ast-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-linemap.h\"\n #include \"rust-backend.h\"\n-#include \"cscope.h\"\n \n namespace Rust {\n namespace Compile {\n \n-class Compilation : public AST::ASTVisitor\n+class Context\n {\n public:\n-  static bool Compile (AST::Crate &crate, ::Backend *backend);\n-\n-  ~Compilation ();\n-\n-  // visitor impl\n-  // rust-ast.h\n-  // virtual void visit(AttrInput& attr_input);\n-  // virtual void visit(TokenTree& token_tree);\n-  // virtual void visit(MacroMatch& macro_match);\n-  virtual void visit (AST::Token &tok);\n-  virtual void visit (AST::DelimTokenTree &delim_tok_tree);\n-  virtual void visit (AST::AttrInputMetaItemContainer &input);\n-  // virtual void visit(MetaItem& meta_item);\n-  // virtual void vsit(Stmt& stmt);\n-  // virtual void visit(Expr& expr);\n-  virtual void visit (AST::IdentifierExpr &ident_expr);\n-  // virtual void visit(Pattern& pattern);\n-  // virtual void visit(Type& type);\n-  // virtual void visit(TypeParamBound& type_param_bound);\n-  virtual void visit (AST::Lifetime &lifetime);\n-  // virtual void visit(GenericParam& generic_param);\n-  virtual void visit (AST::LifetimeParam &lifetime_param);\n-  // virtual void visit(TraitItem& trait_item);\n-  // virtual void visit(InherentImplItem& inherent_impl_item);\n-  // virtual void visit(TraitImplItem& trait_impl_item);\n-  virtual void visit (AST::MacroInvocationSemi &macro);\n-\n-  // rust-path.h\n-  virtual void visit (AST::PathInExpression &path);\n-  virtual void visit (AST::TypePathSegment &segment);\n-  virtual void visit (AST::TypePathSegmentGeneric &segment);\n-  virtual void visit (AST::TypePathSegmentFunction &segment);\n-  virtual void visit (AST::TypePath &path);\n-  virtual void visit (AST::QualifiedPathInExpression &path);\n-  virtual void visit (AST::QualifiedPathInType &path);\n-\n-  // rust-expr.h\n-  virtual void visit (AST::LiteralExpr &expr);\n-  virtual void visit (AST::AttrInputLiteral &attr_input);\n-  virtual void visit (AST::MetaItemLitExpr &meta_item);\n-  virtual void visit (AST::MetaItemPathLit &meta_item);\n-  virtual void visit (AST::BorrowExpr &expr);\n-  virtual void visit (AST::DereferenceExpr &expr);\n-  virtual void visit (AST::ErrorPropagationExpr &expr);\n-  virtual void visit (AST::NegationExpr &expr);\n-  virtual void visit (AST::ArithmeticOrLogicalExpr &expr);\n-  virtual void visit (AST::ComparisonExpr &expr);\n-  virtual void visit (AST::LazyBooleanExpr &expr);\n-  virtual void visit (AST::TypeCastExpr &expr);\n-  virtual void visit (AST::AssignmentExpr &expr);\n-  virtual void visit (AST::CompoundAssignmentExpr &expr);\n-  virtual void visit (AST::GroupedExpr &expr);\n-  // virtual void visit(ArrayElems& elems);\n-  virtual void visit (AST::ArrayElemsValues &elems);\n-  virtual void visit (AST::ArrayElemsCopied &elems);\n-  virtual void visit (AST::ArrayExpr &expr);\n-  virtual void visit (AST::ArrayIndexExpr &expr);\n-  virtual void visit (AST::TupleExpr &expr);\n-  virtual void visit (AST::TupleIndexExpr &expr);\n-  virtual void visit (AST::StructExprStruct &expr);\n-  // virtual void visit(StructExprField& field);\n-  virtual void visit (AST::StructExprFieldIdentifier &field);\n-  virtual void visit (AST::StructExprFieldIdentifierValue &field);\n-  virtual void visit (AST::StructExprFieldIndexValue &field);\n-  virtual void visit (AST::StructExprStructFields &expr);\n-  virtual void visit (AST::StructExprStructBase &expr);\n-  virtual void visit (AST::StructExprTuple &expr);\n-  virtual void visit (AST::StructExprUnit &expr);\n-  // virtual void visit(EnumExprField& field);\n-  virtual void visit (AST::EnumExprFieldIdentifier &field);\n-  virtual void visit (AST::EnumExprFieldIdentifierValue &field);\n-  virtual void visit (AST::EnumExprFieldIndexValue &field);\n-  virtual void visit (AST::EnumExprStruct &expr);\n-  virtual void visit (AST::EnumExprTuple &expr);\n-  virtual void visit (AST::EnumExprFieldless &expr);\n-  virtual void visit (AST::CallExpr &expr);\n-  virtual void visit (AST::MethodCallExpr &expr);\n-  virtual void visit (AST::FieldAccessExpr &expr);\n-  virtual void visit (AST::ClosureExprInner &expr);\n-  virtual void visit (AST::BlockExpr &expr);\n-  virtual void visit (AST::ClosureExprInnerTyped &expr);\n-  virtual void visit (AST::ContinueExpr &expr);\n-  virtual void visit (AST::BreakExpr &expr);\n-  virtual void visit (AST::RangeFromToExpr &expr);\n-  virtual void visit (AST::RangeFromExpr &expr);\n-  virtual void visit (AST::RangeToExpr &expr);\n-  virtual void visit (AST::RangeFullExpr &expr);\n-  virtual void visit (AST::RangeFromToInclExpr &expr);\n-  virtual void visit (AST::RangeToInclExpr &expr);\n-  virtual void visit (AST::ReturnExpr &expr);\n-  virtual void visit (AST::UnsafeBlockExpr &expr);\n-  virtual void visit (AST::LoopExpr &expr);\n-  virtual void visit (AST::WhileLoopExpr &expr);\n-  virtual void visit (AST::WhileLetLoopExpr &expr);\n-  virtual void visit (AST::ForLoopExpr &expr);\n-  virtual void visit (AST::IfExpr &expr);\n-  virtual void visit (AST::IfExprConseqElse &expr);\n-  virtual void visit (AST::IfExprConseqIf &expr);\n-  virtual void visit (AST::IfExprConseqIfLet &expr);\n-  virtual void visit (AST::IfLetExpr &expr);\n-  virtual void visit (AST::IfLetExprConseqElse &expr);\n-  virtual void visit (AST::IfLetExprConseqIf &expr);\n-  virtual void visit (AST::IfLetExprConseqIfLet &expr);\n-  // virtual void visit(MatchCase& match_case);\n-  // virtual void visit (AST::MatchCaseBlockExpr &match_case);\n-  // virtual void visit (AST::MatchCaseExpr &match_case);\n-  virtual void visit (AST::MatchExpr &expr);\n-  virtual void visit (AST::AwaitExpr &expr);\n-  virtual void visit (AST::AsyncBlockExpr &expr);\n-\n-  // rust-item.h\n-  virtual void visit (AST::TypeParam &param);\n-  // virtual void visit(WhereClauseItem& item);\n-  virtual void visit (AST::LifetimeWhereClauseItem &item);\n-  virtual void visit (AST::TypeBoundWhereClauseItem &item);\n-  virtual void visit (AST::Method &method);\n-  virtual void visit (AST::ModuleBodied &module);\n-  virtual void visit (AST::ModuleNoBody &module);\n-  virtual void visit (AST::ExternCrate &crate);\n-  // virtual void visit(UseTree& use_tree);\n-  virtual void visit (AST::UseTreeGlob &use_tree);\n-  virtual void visit (AST::UseTreeList &use_tree);\n-  virtual void visit (AST::UseTreeRebind &use_tree);\n-  virtual void visit (AST::UseDeclaration &use_decl);\n-  virtual void visit (AST::Function &function);\n-  virtual void visit (AST::TypeAlias &type_alias);\n-  virtual void visit (AST::StructStruct &struct_item);\n-  virtual void visit (AST::TupleStruct &tuple_struct);\n-  virtual void visit (AST::EnumItem &item);\n-  virtual void visit (AST::EnumItemTuple &item);\n-  virtual void visit (AST::EnumItemStruct &item);\n-  virtual void visit (AST::EnumItemDiscriminant &item);\n-  virtual void visit (AST::Enum &enum_item);\n-  virtual void visit (AST::Union &union_item);\n-  virtual void visit (AST::ConstantItem &const_item);\n-  virtual void visit (AST::StaticItem &static_item);\n-  virtual void visit (AST::TraitItemFunc &item);\n-  virtual void visit (AST::TraitItemMethod &item);\n-  virtual void visit (AST::TraitItemConst &item);\n-  virtual void visit (AST::TraitItemType &item);\n-  virtual void visit (AST::Trait &trait);\n-  virtual void visit (AST::InherentImpl &impl);\n-  virtual void visit (AST::TraitImpl &impl);\n-  // virtual void visit(ExternalItem& item);\n-  virtual void visit (AST::ExternalStaticItem &item);\n-  virtual void visit (AST::ExternalFunctionItem &item);\n-  virtual void visit (AST::ExternBlock &block);\n-\n-  // rust-macro.h\n-  virtual void visit (AST::MacroMatchFragment &match);\n-  virtual void visit (AST::MacroMatchRepetition &match);\n-  virtual void visit (AST::MacroMatcher &matcher);\n-  virtual void visit (AST::MacroRulesDefinition &rules_def);\n-  virtual void visit (AST::MacroInvocation &macro_invoc);\n-  virtual void visit (AST::MetaItemPath &meta_item);\n-  virtual void visit (AST::MetaItemSeq &meta_item);\n-  virtual void visit (AST::MetaWord &meta_item);\n-  virtual void visit (AST::MetaNameValueStr &meta_item);\n-  virtual void visit (AST::MetaListPaths &meta_item);\n-  virtual void visit (AST::MetaListNameValueStr &meta_item);\n-\n-  // rust-pattern.h\n-  virtual void visit (AST::LiteralPattern &pattern);\n-  virtual void visit (AST::IdentifierPattern &pattern);\n-  virtual void visit (AST::WildcardPattern &pattern);\n-  // virtual void visit(RangePatternBound& bound);\n-  virtual void visit (AST::RangePatternBoundLiteral &bound);\n-  virtual void visit (AST::RangePatternBoundPath &bound);\n-  virtual void visit (AST::RangePatternBoundQualPath &bound);\n-  virtual void visit (AST::RangePattern &pattern);\n-  virtual void visit (AST::ReferencePattern &pattern);\n-  // virtual void visit(StructPatternField& field);\n-  virtual void visit (AST::StructPatternFieldTuplePat &field);\n-  virtual void visit (AST::StructPatternFieldIdentPat &field);\n-  virtual void visit (AST::StructPatternFieldIdent &field);\n-  virtual void visit (AST::StructPattern &pattern);\n-  // virtual void visit(TupleStructItems& tuple_items);\n-  virtual void visit (AST::TupleStructItemsNoRange &tuple_items);\n-  virtual void visit (AST::TupleStructItemsRange &tuple_items);\n-  virtual void visit (AST::TupleStructPattern &pattern);\n-  // virtual void visit(TuplePatternItems& tuple_items);\n-  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items);\n-  virtual void visit (AST::TuplePatternItemsRanged &tuple_items);\n-  virtual void visit (AST::TuplePattern &pattern);\n-  virtual void visit (AST::GroupedPattern &pattern);\n-  virtual void visit (AST::SlicePattern &pattern);\n-\n-  // rust-stmt.h\n-  virtual void visit (AST::EmptyStmt &stmt);\n-  virtual void visit (AST::LetStmt &stmt);\n-  virtual void visit (AST::ExprStmtWithoutBlock &stmt);\n-  virtual void visit (AST::ExprStmtWithBlock &stmt);\n-\n-  // rust-type.h\n-  virtual void visit (AST::TraitBound &bound);\n-  virtual void visit (AST::ImplTraitType &type);\n-  virtual void visit (AST::TraitObjectType &type);\n-  virtual void visit (AST::ParenthesisedType &type);\n-  virtual void visit (AST::ImplTraitTypeOneBound &type);\n-  virtual void visit (AST::TraitObjectTypeOneBound &type);\n-  virtual void visit (AST::TupleType &type);\n-  virtual void visit (AST::NeverType &type);\n-  virtual void visit (AST::RawPointerType &type);\n-  virtual void visit (AST::ReferenceType &type);\n-  virtual void visit (AST::ArrayType &type);\n-  virtual void visit (AST::SliceType &type);\n-  virtual void visit (AST::InferredType &type);\n-  virtual void visit (AST::BareFunctionType &type);\n+  Context (::Backend *backend)\n+    : backend (backend), resolver (Resolver::Resolver::get ()),\n+      tyctx (Resolver::TypeCheckContext::get ()),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  ~Context () {}\n+\n+  ::Backend *get_backend () { return backend; }\n+  Resolver::Resolver *get_resolver () { return resolver; }\n+  Resolver::TypeCheckContext *get_tyctx () { return tyctx; }\n+  Analysis::Mappings *get_mappings () { return mappings; }\n+\n+  void push_type (::Btype *t) { type_decls.push_back (t); }\n+  void push_var (::Bvariable *v) { var_decls.push_back (v); }\n+  void push_const (::Bexpression *c) { const_decls.push_back (c); }\n+  void push_function (::Bfunction *f) { func_decls.push_back (f); }\n+\n+  void write_to_backend ()\n+  {\n+    backend->write_global_definitions (type_decls, const_decls, func_decls,\n+\t\t\t\t       var_decls);\n+  }\n \n private:\n-  Compilation (AST::Crate &crate, Backend *backend);\n-  bool go ();\n+  ::Backend *backend;\n+  Resolver::Resolver *resolver;\n+  Resolver::TypeCheckContext *tyctx;\n+  Analysis::Mappings *mappings;\n \n-  AST::Crate &crate;\n-  Backend *backend;\n-\n-  // utils\n-  bool compileVarDecl (Bfunction *fndecl, AST::LetStmt *stmt,\n-\t\t       std::vector<Bvariable *> &vars);\n-\n-  Bexpression *compileBooleanLiteral (std::string val);\n-  Bexpression *compileFloatLiteral (std::string val, Location locus);\n-  Bexpression *compileIntegerLiteral (std::string val, Location locus);\n-\n-  // state\n-  Scope scope;\n-  ::Btype *translatedType;\n-  std::vector<AST::IdentifierPattern> patternBuffer;\n-  std::vector< ::Bexpression *> exprs;\n-  std::vector< ::Bstatement *> stmts;\n-  std::vector< ::Bvariable *> varBuffer;\n-  std::vector<AST::StructStruct *> structBuffer;\n-  std::vector<std::vector< ::Bexpression *> > arrayConsStack;\n-\n-  // careful these are the vectors we pass into the GCC middle-end\n+  // To GCC middle-end\n   std::vector< ::Btype *> type_decls;\n   std::vector< ::Bvariable *> var_decls;\n   std::vector< ::Bexpression *> const_decls;\n   std::vector< ::Bfunction *> func_decls;\n };\n \n+class CompileCrate\n+{\n+public:\n+  static void Compile (HIR::Crate &crate, Context *ctx);\n+\n+  ~CompileCrate ();\n+\n+private:\n+  CompileCrate (HIR::Crate &crate, Context *ctx);\n+\n+  HIR::Crate &crate;\n+  Context *ctx;\n+};\n+\n } // namespace Compile\n } // namespace Rust\n+\n+#endif // RUST_COMPILE_H"}, {"sha": "17ff24ae5d799e9199dd3536a4caf6a5fc66ef92", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a621e19365473b477d121c28a057cc25d3951c76/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a621e19365473b477d121c28a057cc25d3951c76/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=a621e19365473b477d121c28a057cc25d3951c76", "patch": "@@ -30,11 +30,11 @@\n \n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n-#include \"rust-scan.h\"\n #include \"rust-macro-expand.h\"\n #include \"rust-ast-resolve.h\"\n #include \"rust-ast-lower.h\"\n #include \"rust-hir-type-check.h\"\n+#include \"rust-compile.h\"\n \n extern Linemap *\n rust_get_linemap ();\n@@ -529,6 +529,9 @@ Session::parse_file (const char *filename)\n       // TODO: what do I dump here? resolved names? AST with resolved names?\n     }\n \n+  if (saw_errors ())\n+    return;\n+\n   // lower AST to HIR\n   HIR::Crate hir = lower_ast (parsed_crate);\n   if (options.dump_option == CompileOptions::HIR_DUMP)\n@@ -537,14 +540,24 @@ Session::parse_file (const char *filename)\n       return;\n     }\n \n+  if (saw_errors ())\n+    return;\n+\n   // type resolve\n   type_resolution (hir);\n \n   if (saw_errors ())\n     return;\n \n   // do compile\n-  // Compile::Compilation::Compile (parsed_crate, backend);\n+  Compile::Context ctx (backend);\n+  Compile::CompileCrate::Compile (hir, &ctx);\n+\n+  if (saw_errors ())\n+    return;\n+\n+  // pass to GCC\n+  ctx.write_to_backend ();\n }\n \n // TODO: actually implement method"}, {"sha": "6e853c3d0d5ce40981267ff4bf53598975e00d7d", "filename": "gcc/rust/util/scope.h", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Futil%2Fscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Futil%2Fscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Fscope.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -1,78 +0,0 @@\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_SCOPE_H\n-#define RUST_SCOPE_H\n-\n-#include \"rust-system.h\"\n-#include \"rust-ast-full.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-template <class T> class Scope\n-{\n-public:\n-  Scope () : scopeStack () {}\n-\n-  ~Scope () {}\n-\n-  bool Insert (std::string key, T val)\n-  {\n-    if (scopeStack.back ().find (key) != scopeStack.back ().end ())\n-      {\n-\treturn false;\n-      }\n-\n-    scopeStack.back ().insert (std::make_pair (key, std::move (val)));\n-    return true;\n-  }\n-\n-  bool Lookup (std::string key, T *result)\n-  {\n-    for (auto it = scopeStack.rbegin (); it != scopeStack.rend (); ++it)\n-      {\n-\tauto lookup = it->find (key);\n-\tif (lookup != it->end ())\n-\t  {\n-\t    *result = lookup->second;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n-\n-  void Push () { scopeStack.push_back ({}); }\n-\n-  std ::map<std::string, T> Pop ()\n-  {\n-    auto toplevel = scopeStack.back ();\n-    scopeStack.pop_back ();\n-    return toplevel;\n-  }\n-\n-  std ::map<std::string, T> Peek () { return scopeStack.back (); }\n-\n-private:\n-  std::vector<std::map<std::string, T> > scopeStack;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust\n-\n-#endif // RUST_SCOPE_H"}]}