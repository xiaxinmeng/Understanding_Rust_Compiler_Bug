{"sha": "5940c2b7a753530dfa922df00866d7b381ae21ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk0MGMyYjdhNzUzNTMwZGZhOTIyZGYwMDg2NmQ3YjM4MWFlMjFlZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-04-23T19:09:56Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-04-23T19:09:56Z"}, "message": "resolve.cc (_Jv_PrepareClass): Round size up to alignment required by this object.\n\n\t* resolve.cc (_Jv_PrepareClass): Round size up to alignment\n\trequired by this object.  Search superclasses to find required\n\talignment.\n\t(get_alignment_from_class): Use alignment of type as it appears\n\tin a struct.\n\t(ALIGNOF): New macro.\n\t(struct aligner): New helper structure.\n\nFrom-SVN: r66008", "tree": {"sha": "8f32984591d353ba8c70d6ee87fe3369346b8447", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f32984591d353ba8c70d6ee87fe3369346b8447"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5940c2b7a753530dfa922df00866d7b381ae21ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5940c2b7a753530dfa922df00866d7b381ae21ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5940c2b7a753530dfa922df00866d7b381ae21ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5940c2b7a753530dfa922df00866d7b381ae21ed/comments", "author": null, "committer": null, "parents": [{"sha": "10aef094c67c46a028b07b61640bb1b15499d870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10aef094c67c46a028b07b61640bb1b15499d870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10aef094c67c46a028b07b61640bb1b15499d870"}], "stats": {"total": 74, "additions": 59, "deletions": 15}, "files": [{"sha": "03e855f6aa7be449a1ef4aac638c883e1f1c3e2a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5940c2b7a753530dfa922df00866d7b381ae21ed/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5940c2b7a753530dfa922df00866d7b381ae21ed/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5940c2b7a753530dfa922df00866d7b381ae21ed", "patch": "@@ -1,3 +1,13 @@\n+2003-04-23  Tom Tromey  <tromey@redhat.com>\n+\n+\t* resolve.cc (_Jv_PrepareClass): Round size up to alignment\n+\trequired by this object.  Search superclasses to find required\n+\talignment.\n+\t(get_alignment_from_class): Use alignment of type as it appears\n+\tin a struct.\n+\t(ALIGNOF): New macro.\n+\t(struct aligner): New helper structure.\n+\n 2003-04-20  Scott Gilbertson  <scottg@mantatest.com>\n \n \t* java/awt/Container.java (addImpl): Enable paint events if adding"}, {"sha": "7cf0b0a3f8ee583cad3e300c2e5469fa241e9f90", "filename": "libjava/resolve.cc", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5940c2b7a753530dfa922df00866d7b381ae21ed/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5940c2b7a753530dfa922df00866d7b381ae21ed/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=5940c2b7a753530dfa922df00866d7b381ae21ed", "patch": "@@ -459,16 +459,36 @@ _Jv_PrepareClass(jclass klass)\n \n   /************ PART ONE: OBJECT LAYOUT ***************/\n \n+  // Compute the alignment for this type by searching through the\n+  // superclasses and finding the maximum required alignment.  We\n+  // could consider caching this in the Class.\n+  int max_align = __alignof__ (java::lang::Object);\n+  jclass super = clz->superclass;\n+  while (super != NULL)\n+    {\n+      int num = JvNumInstanceFields (super);\n+      _Jv_Field *field = JvGetFirstInstanceField (super);\n+      while (num > 0)\n+\t{\n+\t  int field_align = get_alignment_from_class (field->type);\n+\t  if (field_align > max_align)\n+\t    max_align = field_align;\n+\t  ++field;\n+\t  --num;\n+\t}\n+      super = super->superclass;\n+    }\n+\n   int instance_size;\n-  int static_size;\n+  int static_size = 0;\n \n   // Although java.lang.Object is never interpreted, an interface can\n-  // have a null superclass.\n+  // have a null superclass.  Note that we have to lay out an\n+  // interface because it might have static fields.\n   if (clz->superclass)\n     instance_size = clz->superclass->size();\n   else\n     instance_size = java::lang::Object::class$.size();\n-  static_size   = 0;\n \n   for (int i = 0; i < clz->field_count; i++)\n     {\n@@ -510,13 +530,15 @@ _Jv_PrepareClass(jclass klass)\n \t  instance_size      = ROUND (instance_size, field_align);\n \t  field->u.boffset   = instance_size;\n \t  instance_size     += field_size;\n+\t  if (field_align > max_align)\n+\t    max_align = field_align;\n \t}\n     }\n \n   // Set the instance size for the class.  Note that first we round it\n-  // to the alignment required for Object; this keeps us in sync with\n-  // our current ABI.\n-  instance_size = ROUND (instance_size, __alignof__ (java::lang::Object));\n+  // to the alignment required for this object; this keeps us in sync\n+  // with our current ABI.\n+  instance_size = ROUND (instance_size, max_align);\n   clz->size_in_bytes = instance_size;\n \n   // allocate static memory\n@@ -709,27 +731,39 @@ _Jv_InitField (jobject obj, jclass klass, int index)\n     }\n }\n \n+template<typename T>\n+struct aligner\n+{\n+  T field;\n+};\n+\n+#define ALIGNOF(TYPE) (__alignof__ (((aligner<TYPE> *) 0)->field))\n+\n+// This returns the alignment of a type as it would appear in a\n+// structure.  This can be different from the alignment of the type\n+// itself.  For instance on x86 double is 8-aligned but struct{double}\n+// is 4-aligned.\n static int\n get_alignment_from_class (jclass klass)\n {\n   if (klass == JvPrimClass (byte))\n-    return  __alignof__ (jbyte);\n+    return ALIGNOF (jbyte);\n   else if (klass == JvPrimClass (short))\n-    return  __alignof__ (jshort);\n+    return ALIGNOF (jshort);\n   else if (klass == JvPrimClass (int)) \n-    return  __alignof__ (jint);\n+    return ALIGNOF (jint);\n   else if (klass == JvPrimClass (long))\n-    return  __alignof__ (jlong);\n+    return ALIGNOF (jlong);\n   else if (klass == JvPrimClass (boolean))\n-    return  __alignof__ (jboolean);\n+    return ALIGNOF (jboolean);\n   else if (klass == JvPrimClass (char))\n-    return  __alignof__ (jchar);\n+    return ALIGNOF (jchar);\n   else if (klass == JvPrimClass (float))\n-    return  __alignof__ (jfloat);\n+    return ALIGNOF (jfloat);\n   else if (klass == JvPrimClass (double))\n-    return  __alignof__ (jdouble);\n+    return ALIGNOF (jdouble);\n   else\n-    return __alignof__ (jobject);\n+    return ALIGNOF (jobject);\n }\n \n "}]}