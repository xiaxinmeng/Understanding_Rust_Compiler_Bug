{"sha": "c4963a0a324c37a487535f25590f2c539ceb39fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ5NjNhMGEzMjRjMzdhNDg3NTM1ZjI1NTkwZjJjNTM5Y2ViMzlmYw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2006-03-21T13:07:33Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2006-03-21T13:07:33Z"}, "message": "bfin-protos.h (bfin_dsp_memref_p): Declare.\n\n\t* config/bfin/bfin-protos.h (bfin_dsp_memref_p): Declare.\n\t* config/bfin/bfin.c (bfin_dsp_memref_p): New function.\n\t(bfin_valid_reg_p): Test for pseudos explicitly and use only\n\tREGNO_MODE_CODE_OK_FOR_BASE_P.  New args MODE and OUTER_CODE; all\n\tcallers changed.\n\t* config/bfin/bfin.h (PREG_P): Use P_REGNO_P.\n\t(IREG_P, P_REGNO_P, I_REGNO_P): New macros.\n\t(enum reg_class, REG_CLASS_CONTENTS): Add IPREGS.\n\t(BASE_REG_CLASS, REG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P,\n\tREGNO_OK_FOR_BASE_STRICT_P, REGNO_OK_FOR_BASE_NONSTRICT_P): Delete\n\tmacros.\n\t(IREG_POSSIBLE_P, MODE_CODE_BASE_REG_CLASS,\n\tREGNO_MODE_CODE_OK_FOR_BASE_P): New macros.\n\t(REGNO_REG_CLASS): ARGP is in PREGS.\n\t* config/bfin/bfin.md (movhi_insn): Allow for addresses containing\n\tIREGS.\n\t(zero_extendhisi2, extendhisi2): Likewise; changed to define_and_split\n\tto deal with those addresses.\n\t* addresses.h: New file.\n\t* caller-save.c: Include \"addresses.h\".\n\t(init_caller_save): Use new base_reg_class function.\n\t* rtl-factoring.c: Include \"addresses.h\".\n\t(recompute_gain_for_pattern_seq): Use new function ok_for_base_p_1.\n\t* recog.c: Include \"addresses.h\".\n\t(preprocess_constraints): Use new base_reg_class function.\n\t* regrename.c: Include \"addresses.h\".\n\t(scan_rtx_address): Use new regno_ok_for_base_p and base_reg_class\n\tfunctions.  Keep track of a new var INDEX_CODE to compute valid\n\tclasses.\n\t(replace_oldest_value_addr): Likewise.\n\t(replace_oldest_value_mem): Use base_reg_class.\n\t* reload.c: Include \"addresses.h\".\n\t(REGNO_MODE_OK_FOR_BASE_P, REG_MODE_OK_FOR_BASE_P): Delete macros.\n\t(find_reloads): Use new base_reg_class function.\n\t(find_reloads_address): Likewise; also use regno_ok_for_base_p.\n\t(find_reloads_address_1): Likewise. New args OUTER_CODE and INDEX_CODE;\n\tall callers and prototype changed.\n\t* reload1.c: Include \"addresses.h\".\n\t(maybe_fix_stack_asms): Use base_reg_class.\n\t* regclass.c: Include \"addresses.h\".\n\t(ok_for_index_p_nonstrict, ok_for_base_p_nonstrict): New functions.\n\t(init_reg_autoinc): Use new base_reg_class function.\n\t(record_reg_classes): Likewise.\n\t(record_address_regs): Delete arg CLASS; add args CONTEXT, MODE,\n\tOUTER_CODE and INDEX_CODE.  All callers and prototype changed.\n\tUse new args to compute necessary class.\n\n\t* Makefile.in (regclass.o, reload.o, reload1.o, caller-save.o, recog.o,\n\tregrename.o, rtl-factoring.o): Update dependencies.\n\t* doc/tm.texi (MODE_CODE_BASE_REG_CLASS): Document.\n\t(REGNO_MODE_CODE_OK_FOR_BASE_P): Likewise.\n\t(REG_OK_FOR_BASE_P, REG_MODE_OK_FOR_BASE_P, REG_MODE_OK_FOR_REG_BASE_P,\n\tREG_OK_FOR_INDEX_P): Delete documentation.\n\nFrom-SVN: r112248", "tree": {"sha": "ba78a3bc5838547dd82ee9515db1126afb067ab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba78a3bc5838547dd82ee9515db1126afb067ab0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4963a0a324c37a487535f25590f2c539ceb39fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4963a0a324c37a487535f25590f2c539ceb39fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4963a0a324c37a487535f25590f2c539ceb39fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4963a0a324c37a487535f25590f2c539ceb39fc/comments", "author": null, "committer": null, "parents": [{"sha": "0002d5d2bc68f9381ec990ea94307bafa700b0ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0002d5d2bc68f9381ec990ea94307bafa700b0ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0002d5d2bc68f9381ec990ea94307bafa700b0ad"}], "stats": {"total": 842, "additions": 547, "deletions": 295}, "files": [{"sha": "288f1664b3b1e212a744f72a1202a24733693efc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -1,3 +1,59 @@\n+2006-03-21  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin-protos.h (bfin_dsp_memref_p): Declare.\n+\t* config/bfin/bfin.c (bfin_dsp_memref_p): New function.\n+\t(bfin_valid_reg_p): Test for pseudos explicitly and use only\n+\tREGNO_MODE_CODE_OK_FOR_BASE_P.  New args MODE and OUTER_CODE; all\n+\tcallers changed.\n+\t* config/bfin/bfin.h (PREG_P): Use P_REGNO_P.\n+\t(IREG_P, P_REGNO_P, I_REGNO_P): New macros.\n+\t(enum reg_class, REG_CLASS_CONTENTS): Add IPREGS.\n+\t(BASE_REG_CLASS, REG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P,\n+\tREGNO_OK_FOR_BASE_STRICT_P, REGNO_OK_FOR_BASE_NONSTRICT_P): Delete\n+\tmacros.\n+\t(IREG_POSSIBLE_P, MODE_CODE_BASE_REG_CLASS,\n+\tREGNO_MODE_CODE_OK_FOR_BASE_P): New macros.\n+\t(REGNO_REG_CLASS): ARGP is in PREGS.\n+\t* config/bfin/bfin.md (movhi_insn): Allow for addresses containing\n+\tIREGS.\n+\t(zero_extendhisi2, extendhisi2): Likewise; changed to define_and_split\n+\tto deal with those addresses.\n+\t* addresses.h: New file.\n+\t* caller-save.c: Include \"addresses.h\".\n+\t(init_caller_save): Use new base_reg_class function.\n+\t* rtl-factoring.c: Include \"addresses.h\".\n+\t(recompute_gain_for_pattern_seq): Use new function ok_for_base_p_1.\n+\t* recog.c: Include \"addresses.h\".\n+\t(preprocess_constraints): Use new base_reg_class function.\n+\t* regrename.c: Include \"addresses.h\".\n+\t(scan_rtx_address): Use new regno_ok_for_base_p and base_reg_class\n+\tfunctions.  Keep track of a new var INDEX_CODE to compute valid\n+\tclasses.\n+\t(replace_oldest_value_addr): Likewise.\n+\t(replace_oldest_value_mem): Use base_reg_class.\n+\t* reload.c: Include \"addresses.h\".\n+\t(REGNO_MODE_OK_FOR_BASE_P, REG_MODE_OK_FOR_BASE_P): Delete macros.\n+\t(find_reloads): Use new base_reg_class function.\n+\t(find_reloads_address): Likewise; also use regno_ok_for_base_p.\n+\t(find_reloads_address_1): Likewise. New args OUTER_CODE and INDEX_CODE;\n+\tall callers and prototype changed.\n+\t* reload1.c: Include \"addresses.h\".\n+\t(maybe_fix_stack_asms): Use base_reg_class.\n+\t* regclass.c: Include \"addresses.h\".\n+\t(ok_for_index_p_nonstrict, ok_for_base_p_nonstrict): New functions.\n+\t(init_reg_autoinc): Use new base_reg_class function.\n+\t(record_reg_classes): Likewise.\n+\t(record_address_regs): Delete arg CLASS; add args CONTEXT, MODE,\n+\tOUTER_CODE and INDEX_CODE.  All callers and prototype changed.\n+\tUse new args to compute necessary class.\n+\n+\t* Makefile.in (regclass.o, reload.o, reload1.o, caller-save.o, recog.o,\n+\tregrename.o, rtl-factoring.o): Update dependencies.\n+\t* doc/tm.texi (MODE_CODE_BASE_REG_CLASS): Document.\n+\t(REGNO_MODE_CODE_OK_FOR_BASE_P): Likewise.\n+\t(REG_OK_FOR_BASE_P, REG_MODE_OK_FOR_BASE_P, REG_MODE_OK_FOR_REG_BASE_P,\n+\tREG_OK_FOR_INDEX_P): Delete documentation.\n+\n 2006-03-21  Alexey Starovoytov  <alexey.starovoytov@sun.com>\n \n \t* config.gcc (sparc-*-solaris2*): Change the default CPU setting"}, {"sha": "4aa7e4d8e2cb91042eba566148d12f1679a21724", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -1916,7 +1916,7 @@ tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    tree-ssa-propagate.h\n rtl-factoring.o : rtl-factoring.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    coretypes.h $(TM_H) $(BASIC_BLOCK_H) $(GGC_H) $(REGS_H) $(PARAMS_H) $(EXPR_H) \\\n-   $(TM_P_H) tree-pass.h tree-flow.h timevar.h output.h\n+   addresses.h $(TM_P_H) tree-pass.h tree-flow.h timevar.h output.h\n tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(FUNCTION_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(DIAGNOSTIC_H) except.h tree-pass.h $(FLAGS_H) langhooks.h \\\n@@ -2468,11 +2468,12 @@ vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) coretypes.h vec.h $(GGC_H) \\\n reload.o : reload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) output.h $(EXPR_H) $(OPTABS_H) reload.h $(RECOG_H) \\\n    hard-reg-set.h insn-config.h $(REGS_H) $(FUNCTION_H) toplev.h \\\n-   $(TM_P_H) $(PARAMS_H) $(TARGET_H) $(REAL_H)\n+   addresses.h $(TM_P_H) $(PARAMS_H) $(TARGET_H) $(REAL_H)\n reload1.o : reload1.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) hard-reg-set.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(RECOG_H) output.h $(FUNCTION_H) toplev.h $(TM_P_H) \\\n-   except.h $(TREE_H) $(REAL_H) $(FLAGS_H) $(MACHMODE_H) $(OBSTACK_H)\n+   addresses.h except.h $(TREE_H) $(REAL_H) $(FLAGS_H) $(MACHMODE_H) \\\n+   $(OBSTACK_H)\n rtlhooks.o :  rtlhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    rtlhooks-def.h $(EXPR_H) $(RECOG_H)\n postreload.o : postreload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n@@ -2487,7 +2488,7 @@ postreload-gcse.o : postreload-gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(PARAMS_H) timevar.h tree-pass.h $(REAL_H)\n caller-save.o : caller-save.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(FUNCTION_H) \\\n-   $(RECOG_H) reload.h $(EXPR_H) toplev.h $(TM_P_H)\n+   addresses.h $(RECOG_H) reload.h $(EXPR_H) toplev.h $(TM_P_H)\n bt-load.o : bt-load.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) except.h \\\n    $(RTL_H) hard-reg-set.h $(REGS_H) $(TM_P_H) $(FIBHEAP_H) output.h $(EXPR_H) \\\n    $(TARGET_H) $(FLAGS_H) $(INSN_ATTR_H) $(FUNCTION_H) tree-pass.h toplev.h\n@@ -2543,7 +2544,7 @@ final.o : final.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FUNCTION_H) $(BASIC_BLOCK_H) $(REGS_H) $(RECOG_H) $(EXPR_H) \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) toplev.h output.h reload.h \\\n-   $(TM_P_H) timevar.h tree-pass.h hard-reg-set.h $(REAL_H)\n+   addresses.h $(TM_P_H) timevar.h tree-pass.h hard-reg-set.h $(REAL_H)\n reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) $(RECOG_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \\\n    insn-config.h toplev.h reload.h $(FUNCTION_H) $(TM_P_H) $(GGC_H) \\\n@@ -2575,7 +2576,7 @@ timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h $(RECOG_H) $(FUNCTION_H) $(OBSTACK_H) $(FLAGS_H) $(TM_P_H) \\\n-   reload.h toplev.h timevar.h tree-pass.h\n+   addresses.h reload.h toplev.h timevar.h tree-pass.h\n ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) toplev.h $(FLAGS_H) insn-config.h $(FUNCTION_H) $(RECOG_H) \\\n    $(TARGET_H) $(BASIC_BLOCK_H) $(EXPR_H) output.h except.h $(TM_P_H) \\"}, {"sha": "6741acac041edeecbaaf81e9b02dedc535caa23c", "filename": "gcc/addresses.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Faddresses.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Faddresses.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Faddresses.h?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -0,0 +1,81 @@\n+/* Inline functions to test validity of reg classes for addressing modes.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* Wrapper function to unify target macros MODE_CODE_BASE_REG_CLASS,\n+   MODE_BASE_REG_REG_CLASS, MODE_BASE_REG_CLASS and BASE_REG_CLASS.\n+   Arguments as for the MODE_CODE_BASE_REG_CLASS macro.  */\n+\n+static inline enum reg_class\n+base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\tenum rtx_code outer_code ATTRIBUTE_UNUSED,\n+\t\tenum rtx_code index_code ATTRIBUTE_UNUSED)\n+{\n+#ifdef MODE_CODE_BASE_REG_CLASS\n+  return MODE_CODE_BASE_REG_CLASS (mode, outer_code, index_code);\n+#else\n+#ifdef MODE_BASE_REG_REG_CLASS\n+  if (index_code == REG)\n+    return MODE_BASE_REG_REG_CLASS (mode);\n+#endif\n+#ifdef MODE_BASE_REG_CLASS\n+  return MODE_BASE_REG_CLASS (mode);\n+#else\n+  return BASE_REG_CLASS;\n+#endif\n+#endif\n+}\n+\n+/* Wrapper function to unify target macros REGNO_MODE_CODE_OK_FOR_BASE_P,\n+   REGNO_MODE_OK_FOR_REG_BASE_P, REGNO_MODE_OK_FOR_BASE_P and\n+   REGNO_OK_FOR_BASE_P.\n+   Arguments as for the REGNO_MODE_CODE_OK_FOR_BASE_P macro.  */\n+\n+static inline bool\n+ok_for_base_p_1 (unsigned regno, enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t enum rtx_code outer_code ATTRIBUTE_UNUSED,\n+\t\t enum rtx_code index_code ATTRIBUTE_UNUSED)\n+{\n+#ifdef REGNO_MODE_CODE_OK_FOR_BASE_P\n+  return REGNO_MODE_CODE_OK_FOR_BASE_P (regno, mode, outer_code, index_code);\n+#else\n+#ifdef REGNO_MODE_OK_FOR_REG_BASE_P\n+  if (index_code == REG)\n+    return REGNO_MODE_OK_FOR_REG_BASE_P (regno, mode);\n+#endif\n+#ifdef REGNO_MODE_OK_FOR_BASE_P\n+  return REGNO_MODE_OK_FOR_BASE_P (regno, mode);\n+#else\n+  return REGNO_OK_FOR_BASE_P (regno);\n+#endif\n+#endif\n+}\n+\n+/* Wrapper around ok_for_base_p_1, for use after register allocation is\n+   complete.  Arguments as for the called function.  */\n+\n+static inline bool\n+regno_ok_for_base_p (unsigned regno, enum machine_mode mode,\n+\t\t     enum rtx_code outer_code, enum rtx_code index_code)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] >= 0)\n+    regno = reg_renumber[regno];\n+\n+  return ok_for_base_p_1 (regno, mode, outer_code, index_code);\n+}"}, {"sha": "d0c33e3cf31221c89808a6721fb71e2824eb6c02", "filename": "gcc/caller-save.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -25,6 +25,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n+#include \"addresses.h\"\n #include \"insn-config.h\"\n #include \"flags.h\"\n #include \"hard-reg-set.h\"\n@@ -153,7 +154,7 @@ init_caller_save (void)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (TEST_HARD_REG_BIT\n \t(reg_class_contents\n-\t [(int) MODE_BASE_REG_CLASS (regno_save_mode [i][1])], i))\n+\t [(int) base_reg_class (regno_save_mode [i][1], PLUS, CONST_INT)], i))\n       break;\n \n   gcc_assert (i < FIRST_PSEUDO_REGISTER);"}, {"sha": "4d586acb96ec855d57c20819dd2007d0684562fa", "filename": "gcc/config/bfin/bfin-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -47,6 +47,7 @@ extern rtx bfin_gen_compare (rtx, Mmode);\n extern void expand_move (rtx *, Mmode);\n extern void bfin_expand_call (rtx, rtx, rtx, rtx, int);\n extern bool bfin_longcall_p (rtx, int);\n+extern bool bfin_dsp_memref_p (rtx);\n extern bool bfin_expand_strmov (rtx, rtx, rtx, rtx);\n \n extern void conditional_register_usage (void);"}, {"sha": "692964083b280f9c01487fc55778d4b64374400e", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -1062,6 +1062,19 @@ effective_address_32bit_p (rtx op, enum machine_mode mode)\n   return offset < 0 || offset > 30;\n }\n \n+/* Returns true if X is a memory reference using an I register.  */\n+bool\n+bfin_dsp_memref_p (rtx x)\n+{\n+  if (! MEM_P (x))\n+    return false;\n+  x = XEXP (x, 0);\n+  if (GET_CODE (x) == POST_INC || GET_CODE (x) == PRE_INC\n+      || GET_CODE (x) == POST_DEC || GET_CODE (x) == PRE_DEC)\n+    x = XEXP (x, 0);\n+  return IREG_P (x);\n+}\n+\n /* Return cost of the memory address ADDR.\n    All addressing modes are equally cheap on the Blackfin.  */\n \n@@ -2100,23 +2113,26 @@ bfin_valid_add (enum machine_mode mode, HOST_WIDE_INT value)\n }\n \n static bool\n-bfin_valid_reg_p (unsigned int regno, int strict)\n+bfin_valid_reg_p (unsigned int regno, int strict, enum machine_mode mode,\n+\t\t  enum rtx_code outer_code)\n {\n-  return ((strict && REGNO_OK_FOR_BASE_STRICT_P (regno))\n-\t  || (!strict && REGNO_OK_FOR_BASE_NONSTRICT_P (regno)));\n+  if (strict)\n+    return REGNO_OK_FOR_BASE_STRICT_P (regno, mode, outer_code, SCRATCH);\n+  else\n+    return REGNO_OK_FOR_BASE_NONSTRICT_P (regno, mode, outer_code, SCRATCH);\n }\n \n bool\n bfin_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n {\n   switch (GET_CODE (x)) {\n   case REG:\n-    if (bfin_valid_reg_p (REGNO (x), strict))\n+    if (bfin_valid_reg_p (REGNO (x), strict, mode, MEM))\n       return true;\n     break;\n   case PLUS:\n     if (REG_P (XEXP (x, 0))\n-\t&& bfin_valid_reg_p (REGNO (XEXP (x, 0)), strict)\n+\t&& bfin_valid_reg_p (REGNO (XEXP (x, 0)), strict, mode, PLUS)\n \t&& (GET_CODE (XEXP (x, 1)) == UNSPEC\n \t    || (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t\t&& bfin_valid_add (mode, INTVAL (XEXP (x, 1))))))\n@@ -2126,13 +2142,13 @@ bfin_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n   case POST_DEC:\n     if (LEGITIMATE_MODE_FOR_AUTOINC_P (mode)\n \t&& REG_P (XEXP (x, 0))\n-\t&& bfin_valid_reg_p (REGNO (XEXP (x, 0)), strict))\n+\t&& bfin_valid_reg_p (REGNO (XEXP (x, 0)), strict, mode, POST_INC))\n       return true;\n   case PRE_DEC:\n     if (LEGITIMATE_MODE_FOR_AUTOINC_P (mode)\n \t&& XEXP (x, 0) == stack_pointer_rtx\n \t&& REG_P (XEXP (x, 0))\n-\t&& bfin_valid_reg_p (REGNO (XEXP (x, 0)), strict))\n+\t&& bfin_valid_reg_p (REGNO (XEXP (x, 0)), strict, mode, PRE_DEC))\n       return true;\n     break;\n   default:"}, {"sha": "3d2f1bbe00985f4d0ba663c670f6b7900775b196", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -215,9 +215,13 @@ extern const char *bfin_library_id_string;\n \n #define FIRST_PSEUDO_REGISTER 44\n \n-#define PREG_P(X) (REG_P (X) && REGNO (X) >= REG_P0 && REGNO (X) <= REG_P7)\n+#define PREG_P(X) (REG_P (X) && P_REGNO_P (REGNO (X)))\n+#define IREG_P(X) (REG_P (X) && I_REGNO_P (REGNO (X)))\n #define ADDRESS_REGNO_P(X) ((X) >= REG_P0 && (X) <= REG_M3)\n #define D_REGNO_P(X) ((X) <= REG_R7)\n+#define P_REGNO_P(X) ((X) >= REG_P0 && (X) <= REG_P7)\n+#define I_REGNO_P(X) \\\n+  ((X) == REG_I0 || (X) == REG_I1 || (X) == REG_I2 || (X) == REG_I3)\n \n #define REGISTER_NAMES { \\\n   \"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \\\n@@ -344,6 +348,7 @@ enum reg_class\n   DREGS,\n   PREGS_CLOBBERED,\n   PREGS,\n+  IPREGS,\n   DPREGS,\n   MOST_REGS,\n   PROLOGUE_REGS,\n@@ -374,6 +379,7 @@ enum reg_class\n    \"DREGS\",\t\t\\\n    \"PREGS_CLOBBERED\",\t\\\n    \"PREGS\",\t\t\\\n+   \"IPREGS\",\t\t\\\n    \"DPREGS\",\t\t\\\n    \"MOST_REGS\",\t\t\\\n    \"PROLOGUE_REGS\",\t\\\n@@ -412,27 +418,40 @@ enum reg_class\n     { 0x000000ff,    0 },\t\t/* DREGS */   \\\n     { 0x00004700,    0x800 },\t\t/* PREGS_CLOBBERED */   \\\n     { 0x0000ff00,    0x800 },\t\t/* PREGS */   \\\n+    { 0x000fff00,    0x800 },\t\t/* IPREGS */\t\\\n     { 0x0000ffff,    0x800 },\t\t/* DPREGS */   \\\n     { 0xffffffff,    0x800 },\t\t/* MOST_REGS */\\\n     { 0x00000000,    0x7f8 },\t\t/* PROLOGUE_REGS */\\\n     { 0xffffffff,    0xff8 },\t\t/* NON_A_CC_REGS */\\\n     { 0xffffffff,    0xfff }}\t\t/* ALL_REGS */\n \n-#define BASE_REG_CLASS          PREGS\n+#define IREG_POSSIBLE_P(OUTER)\t\t\t\t     \\\n+  ((OUTER) == POST_INC || (OUTER) == PRE_INC\t\t     \\\n+   || (OUTER) == POST_DEC || (OUTER) == PRE_DEC\t\t     \\\n+   || (OUTER) == MEM || (OUTER) == ADDRESS)\n+\n+#define MODE_CODE_BASE_REG_CLASS(MODE, OUTER, INDEX)\t\t\t\\\n+  ((MODE) == HImode && IREG_POSSIBLE_P (OUTER) ? IPREGS : PREGS)\n+\n #define INDEX_REG_CLASS         PREGS\n \n-#define REGNO_OK_FOR_BASE_STRICT_P(X) (REGNO_REG_CLASS (X) == BASE_REG_CLASS)\n-#define REGNO_OK_FOR_BASE_NONSTRICT_P(X)  \\\n- (((X) >= FIRST_PSEUDO_REGISTER) || REGNO_REG_CLASS (X) == BASE_REG_CLASS)\n+#define REGNO_OK_FOR_BASE_STRICT_P(X, MODE, OUTER, INDEX)\t\\\n+  (P_REGNO_P (X) || (X) == REG_ARGP\t\t\t\t\\\n+   || (IREG_POSSIBLE_P (OUTER) && (MODE) == HImode\t\t\\\n+       && I_REGNO_P (X)))\n+\n+#define REGNO_OK_FOR_BASE_NONSTRICT_P(X, MODE, OUTER, INDEX)\t\\\n+  ((X) >= FIRST_PSEUDO_REGISTER\t\t\t\t\t\\\n+   || REGNO_OK_FOR_BASE_STRICT_P (X, MODE, OUTER, INDEX))\n \n #ifdef REG_OK_STRICT\n-#define REGNO_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_STRICT_P (X)\n+#define REGNO_MODE_CODE_OK_FOR_BASE_P(X, MODE, OUTER, INDEX) \\\n+  REGNO_OK_FOR_BASE_STRICT_P (X, MODE, OUTER, INDEX)\n #else\n-#define REGNO_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_NONSTRICT_P (X)\n+#define REGNO_MODE_CODE_OK_FOR_BASE_P(X, MODE, OUTER, INDEX) \\\n+  REGNO_OK_FOR_BASE_NONSTRICT_P (X, MODE, OUTER, INDEX)\n #endif\n \n-#define REG_OK_FOR_BASE_P(X)    (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n-#define REG_OK_FOR_INDEX_P(X)   0\n #define REGNO_OK_FOR_INDEX_P(X)   0\n \n /* Get reg_class from a letter such as appears in the machine description.  */\n@@ -464,7 +483,7 @@ enum reg_class\n #define REGNO_REG_CLASS(REGNO) \\\n  ((REGNO) < REG_P0 ? DREGS\t\t\t\t\\\n  : (REGNO) < REG_I0 ? PREGS\t\t\t\t\\\n- : (REGNO) == REG_ARGP ? BASE_REG_CLASS\t\t\t\\\n+ : (REGNO) == REG_ARGP ? PREGS\t\t\t\t\\\n  : (REGNO) >= REG_I0 && (REGNO) <= REG_I3 ? IREGS\t\\\n  : (REGNO) >= REG_L0 && (REGNO) <= REG_L3 ? LREGS\t\\\n  : (REGNO) >= REG_B0 && (REGNO) <= REG_B3 ? BREGS\t\\"}, {"sha": "221e0ceed82ff5b668cb36f1f6d5aea44818c509", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -418,12 +418,23 @@\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=x,da,x,d,mr\")\n         (match_operand:HI 1 \"general_operand\" \"x,xKs7,xKsh,mr,d\"))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n-  \"@\n-   %0 = %1;\n-   %0 = %1 (X);\n-   %0 = %1 (X);\n-   %0 = W %1 (X);\n-   W %0 = %1;\"\n+{\n+  static const char *templates[] = {\n+    \"%0 = %1;\",\n+    \"%0 = %1 (X);\",\n+    \"%0 = %1 (X);\",\n+    \"%0 = W %1 (X);\",\n+    \"W %0 = %1;\",\n+    \"%h0 = W %1;\",\n+    \"W %0 = %h1;\"\n+  };\n+  int alt = which_alternative;\n+  rtx mem = (MEM_P (operands[0]) ? operands[0]\n+\t     : MEM_P (operands[1]) ? operands[1] : NULL_RTX);\n+  if (mem && bfin_dsp_memref_p (mem))\n+    alt += 2;\n+  return templates[alt];\n+}\n   [(set_attr \"type\" \"move,mvi,mvi,mcld,mcst\")\n    (set_attr \"length\" \"2,2,4,*,*\")])\n \n@@ -588,22 +599,34 @@\n \n ;; Sign and zero extensions\n \n-(define_insn \"extendhisi2\"\n+(define_insn_and_split \"extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d, d\")\n \t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d, m\")))]\n   \"\"\n   \"@\n    %0 = %h1 (X);\n    %0 = W %h1 (X);\"\n+  \"reload_completed && bfin_dsp_memref_p (operands[1])\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (sign_extend:SI (match_dup 2)))]\n+{\n+  operands[2] = gen_lowpart (HImode, operands[0]);\n+}\n   [(set_attr \"type\" \"alu0,mcld\")])\n \n-(define_insn \"zero_extendhisi2\"\n+(define_insn_and_split \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d, d\")\n \t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d, m\")))]\n   \"\"\n   \"@\n    %0 = %h1 (Z);\n-   %0 = W%h1 (Z);\"\n+   %0 = W %h1 (Z);\"\n+  \"reload_completed && bfin_dsp_memref_p (operands[1])\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (zero_extend:SI (match_dup 2)))]\n+{\n+  operands[2] = gen_lowpart (HImode, operands[0]);\n+}\n   [(set_attr \"type\" \"alu0,mcld\")])\n \n (define_insn \"zero_extendbisi2\""}, {"sha": "3d470e94730753b5728d35ffc99228b12ba89992", "filename": "gcc/defaults.h", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -631,40 +631,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define\tTARGET_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n #endif\n \n-/* Some macros can be defined by the backend in either a mode-dependent\n-   or mode-independent form.  The compiler proper should only use the\n-   mode-dependent form, providing VOIDmode when the mode is unknown.\n-   We can't poison the macros because the backend may reference them.  */\n-\n-#ifndef REGNO_MODE_OK_FOR_BASE_P\n-#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE) REGNO_OK_FOR_BASE_P (REGNO)\n-#endif\n-\n-#ifndef REG_MODE_OK_FOR_BASE_P\n-#define REG_MODE_OK_FOR_BASE_P(REG, MODE) REG_OK_FOR_BASE_P (REG)\n-#endif\n-\n-/* Determine the register class for registers suitable to be the base\n-   address register in a MEM.  Allow the choice to be dependent upon\n-   the mode of the memory access.  */\n-#ifndef MODE_BASE_REG_CLASS\n-#define MODE_BASE_REG_CLASS(MODE) BASE_REG_CLASS\n-#endif\n-\n-/* Some machines require a different base register class if the index\n-   is a register.  By default, assume that a base register is acceptable.  */\n-#ifndef MODE_BASE_REG_REG_CLASS\n-#define MODE_BASE_REG_REG_CLASS(MODE) MODE_BASE_REG_CLASS(MODE)\n-#endif\n-\n-#ifndef REGNO_MODE_OK_FOR_REG_BASE_P\n-#define REGNO_MODE_OK_FOR_REG_BASE_P(REGNO, MODE) REGNO_MODE_OK_FOR_BASE_P (REGNO, MODE)\n-#endif\n-\n-#ifndef REG_MODE_OK_FOR_REG_BASE_P\n-#define REG_MODE_OK_FOR_REG_BASE_P(REGNO, MODE) REG_MODE_OK_FOR_BASE_P (REGNO, MODE)\n-#endif\n-\n #ifndef LARGEST_EXPONENT_IS_NORMAL\n #define LARGEST_EXPONENT_IS_NORMAL(SIZE) 0\n #endif"}, {"sha": "708a5af408546e31e2f4909dc71f98aecb4b6b66", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 27, "deletions": 43, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -2294,6 +2294,16 @@ register address.  You should define this macro if base plus index\n addresses have different requirements than other base register uses.\n @end defmac\n \n+@defmac MODE_CODE_BASE_REG_CLASS (@var{mode}, @var{outer_code}, @var{index_code})\n+A C expression whose value is the register class to which a valid\n+base register must belong.  @var{outer_code} and @var{index_code} define the\n+context in which the base register occurs.  @var{outer_code} is the code of\n+the immediately enclosing expression (@code{MEM} for the top level of an\n+address, @code{ADDRESS} for something that occurs in an\n+@code{address_operand}).  @var{index_code} is the code of the corresponding\n+index expression if @var{outer_code} is @code{PLUS}; @code{SCRATCH} otherwise.\n+@end defmac\n+\n @defmac INDEX_REG_CLASS\n A macro whose definition is the name of the class to which a valid\n index register must belong.  An index register is one used in an\n@@ -2314,7 +2324,9 @@ that expression may examine the mode of the memory reference in\n @var{mode}.  You should define this macro if the mode of the memory\n reference affects whether a register may be used as a base register.  If\n you define this macro, the compiler will use it instead of\n-@code{REGNO_OK_FOR_BASE_P}.\n+@code{REGNO_OK_FOR_BASE_P}.  The mode may be @code{VOIDmode} for addresses\n+that appear outside a @code{MEM}, i.e. as an @code{address_operand}.\n+\n @end defmac\n \n @defmac REGNO_MODE_OK_FOR_REG_BASE_P (@var{num}, @var{mode})\n@@ -2324,6 +2336,20 @@ memory in mode @var{mode}.  It may be either a suitable hard register or a\n pseudo register that has been allocated such a hard register.  You should\n define this macro if base plus index addresses have different requirements\n than other base register uses.\n+\n+Use of this macro is deprecated; please use the more general\n+@code{REGNO_MODE_CODE_OK_FOR_BASE_P}.\n+@end defmac\n+\n+@defmac REGNO_MODE_CODE_OK_FOR_BASE_P (@var{num}, @var{mode}, @var{outer_code}, @var{index_code})\n+A C expression that is just like @code{REGNO_MODE_OK_FOR_BASE_P}, except that\n+that expression may examine the context in which the register appears in the\n+memory reference.  @var{outer_code} is the code of the immediately enclosing\n+expression (@code{MEM} if at the top level of the address, @code{ADDRESS} for\n+something that occurs in an @code{address_operand}).  @var{index_code} is the\n+code of the corresponding index expression if @var{outer_code} is @code{PLUS};\n+@code{SCRATCH} otherwise.  The mode may be @code{VOIDmode} for addresses\n+that appear outside a @code{MEM}, i.e. as an @code{address_operand}.\n @end defmac\n \n @defmac REGNO_OK_FOR_INDEX_P (@var{num})\n@@ -5056,48 +5082,6 @@ into the @code{symbol_ref}, and then check for it here.  When you see a\n Format}.\n @end defmac\n \n-@defmac REG_OK_FOR_BASE_P (@var{x})\n-A C expression that is nonzero if @var{x} (assumed to be a @code{reg}\n-RTX) is valid for use as a base register.  For hard registers, it\n-should always accept those which the hardware permits and reject the\n-others.  Whether the macro accepts or rejects pseudo registers must be\n-controlled by @code{REG_OK_STRICT} as described above.  This usually\n-requires two variant definitions, of which @code{REG_OK_STRICT}\n-controls the one actually used.\n-@end defmac\n-\n-@defmac REG_MODE_OK_FOR_BASE_P (@var{x}, @var{mode})\n-A C expression that is just like @code{REG_OK_FOR_BASE_P}, except that\n-that expression may examine the mode of the memory reference in\n-@var{mode}.  You should define this macro if the mode of the memory\n-reference affects whether a register may be used as a base register.  If\n-you define this macro, the compiler will use it instead of\n-@code{REG_OK_FOR_BASE_P}.\n-@end defmac\n-\n-@defmac REG_MODE_OK_FOR_REG_BASE_P (@var{x}, @var{mode})\n-A C expression which is nonzero if @var{x} (assumed to be a @code{reg} RTX)\n-is suitable for use as a base register in base plus index operand addresses,\n-accessing memory in mode @var{mode}.  It may be either a suitable hard\n-register or a pseudo register that has been allocated such a hard register.\n-You should define this macro if base plus index addresses have different\n-requirements than other base register uses.\n-@end defmac\n-\n-@defmac REG_OK_FOR_INDEX_P (@var{x})\n-A C expression that is nonzero if @var{x} (assumed to be a @code{reg}\n-RTX) is valid for use as an index register.\n-\n-The difference between an index register and a base register is that\n-the index register may be scaled.  If an address involves the sum of\n-two registers, neither one of them scaled, then either one may be\n-labeled the ``base'' and the other the ``index''; but whichever\n-labeling is used must fit the machine's constraints of which registers\n-may serve in each capacity.  The compiler will try both labelings,\n-looking for one that is valid, and will reload one or both registers\n-only if neither labeling works.\n-@end defmac\n-\n @defmac FIND_BASE_TERM (@var{x})\n A C expression to determine the base term of address @var{x}.\n This macro is used in only one place: `find_base_term' in alias.c."}, {"sha": "342699f71e96ad38d5d4e0542cd51bf9f2e189ed", "filename": "gcc/recog.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"hard-reg-set.h\"\n #include \"recog.h\"\n #include \"regs.h\"\n+#include \"addresses.h\"\n #include \"expr.h\"\n #include \"function.h\"\n #include \"flags.h\"\n@@ -2157,7 +2158,7 @@ preprocess_constraints (void)\n \t\tcase 'p':\n \t\t  op_alt[j].is_address = 1;\n \t\t  op_alt[j].cl = reg_class_subunion[(int) op_alt[j].cl]\n-\t\t    [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n+\t\t      [(int) base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n \t\t  break;\n \n \t\tcase 'g':\n@@ -2178,7 +2179,8 @@ preprocess_constraints (void)\n \t\t      op_alt[j].cl\n \t\t\t= (reg_class_subunion\n \t\t\t   [(int) op_alt[j].cl]\n-\t\t\t   [(int) MODE_BASE_REG_CLASS (VOIDmode)]);\n+\t\t\t   [(int) base_reg_class (VOIDmode, ADDRESS,\n+\t\t\t\t\t\t  SCRATCH)]);\n \t\t      break;\n \t\t    }\n "}, {"sha": "f76fdcd77cfa6942bfbb1b51ce364d44834d0d87", "filename": "gcc/regclass.c", "status": "modified", "additions": 89, "deletions": 51, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -36,6 +36,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"flags.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n+#include \"addresses.h\"\n #include \"function.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n@@ -852,12 +853,36 @@ static void record_reg_classes (int, int, rtx *, enum machine_mode *,\n \t\t\t\tstruct reg_pref *);\n static int copy_cost (rtx, enum machine_mode, enum reg_class, int,\n \t\t      secondary_reload_info *);\n-static void record_address_regs (rtx, enum reg_class, int);\n+static void record_address_regs (enum machine_mode, rtx, int, enum rtx_code,\n+\t\t\t\t enum rtx_code, int);\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n static int auto_inc_dec_reg_p (rtx, enum machine_mode);\n #endif\n static void reg_scan_mark_refs (rtx, rtx, int);\n \n+/* Wrapper around REGNO_OK_FOR_INDEX_P, to allow pseudo registers.  */\n+\n+static inline bool\n+ok_for_index_p_nonstrict (rtx reg)\n+{\n+  unsigned regno = REGNO (reg);\n+  return regno >= FIRST_PSEUDO_REGISTER || REGNO_OK_FOR_INDEX_P (regno);\n+}\n+\n+/* A version of regno_ok_for_base_p for use during regclass, when all pseudos\n+   should count as OK.  Arguments as for regno_ok_for_base_p.  */\n+\n+static inline bool\n+ok_for_base_p_nonstrict (rtx reg, enum machine_mode mode,\n+\t\t\t enum rtx_code outer_code, enum rtx_code index_code)\n+{\n+  unsigned regno = REGNO (reg);\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return true;\n+\n+  return ok_for_base_p_1 (regno, mode, outer_code, index_code);\n+}\n+\n /* Return the reg_class in which pseudo reg number REGNO is best allocated.\n    This function is sometimes called before the info has been computed.\n    When that happens, just return GENERAL_REGS, which is innocuous.  */\n@@ -958,12 +983,13 @@ record_operand_costs (rtx insn, struct costs *op_costs,\n \trecog_data.operand[i] = SUBREG_REG (recog_data.operand[i]);\n \n       if (MEM_P (recog_data.operand[i]))\n-\trecord_address_regs (XEXP (recog_data.operand[i], 0),\n-\t\t\t     MODE_BASE_REG_CLASS (modes[i]), frequency * 2);\n+\trecord_address_regs (GET_MODE (recog_data.operand[i]),\n+\t\t\t     XEXP (recog_data.operand[i], 0),\n+\t\t\t     0, MEM, SCRATCH, frequency * 2);\n       else if (constraints[i][0] == 'p'\n \t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0], constraints[i]))\n-\trecord_address_regs (recog_data.operand[i],\n-\t\t\t     MODE_BASE_REG_CLASS (modes[i]), frequency * 2);\n+\trecord_address_regs (VOIDmode, recog_data.operand[i], 0, ADDRESS,\n+\t\t\t     SCRATCH, frequency * 2);\n     }\n \n   /* Check for commutative in a separate loop so everything will\n@@ -1037,8 +1063,8 @@ scan_one_insn (rtx insn, int pass)\n \t-= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)),\n \t\t\t      GENERAL_REGS, 1)\n \t    * frequency);\n-      record_address_regs (XEXP (SET_SRC (set), 0),\n-\t\t\t   MODE_BASE_REG_CLASS (VOIDmode), frequency * 2);\n+      record_address_regs (GET_MODE (SET_SRC (set)), XEXP (SET_SRC (set), 0),\n+\t\t\t   0, MEM, SCRATCH, frequency * 2);\n       return insn;\n     }\n \n@@ -1148,7 +1174,12 @@ init_reg_autoinc (void)\n \t\t m = (enum machine_mode) ((int) m + 1))\n \t      if (HARD_REGNO_MODE_OK (j, m))\n \t\t{\n-\t\t  enum reg_class base_class = MODE_BASE_REG_CLASS (VOIDmode);\n+\t\t  /* ??? There are two assumptions here; that the base class does not\n+\t\t     depend on the exact outer code (POST_INC vs. PRE_INC etc.), and\n+\t\t     that it does not depend on the machine mode of the memory\n+\t\t     reference.  */\n+\t\t  enum reg_class base_class\n+\t\t    = base_reg_class (VOIDmode, POST_INC, SCRATCH);\n \n \t\t  PUT_MODE (r, m);\n \n@@ -1544,7 +1575,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     address, i.e. BASE_REG_CLASS.  */\n \t\t  classes[i]\n \t\t    = reg_class_subunion[(int) classes[i]]\n-\t\t      [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n+\t\t    [(int) base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n \t\t  break;\n \n \t\tcase 'm':  case 'o':  case 'V':\n@@ -1658,7 +1689,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t\t address, i.e. BASE_REG_CLASS.  */\n \t\t      classes[i]\n \t\t\t= reg_class_subunion[(int) classes[i]]\n-\t\t\t  [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n+\t\t\t[(int) base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n \t\t    }\n #endif\n \t\t  break;\n@@ -1890,16 +1921,28 @@ copy_cost (rtx x, enum machine_mode mode, enum reg_class class, int to_p,\n /* Record the pseudo registers we must reload into hard registers\n    in a subexpression of a memory address, X.\n \n-   CLASS is the class that the register needs to be in and is either\n-   BASE_REG_CLASS or INDEX_REG_CLASS.\n+   If CONTEXT is 0, we are looking at the base part of an address, otherwise we\n+   are looking at the index part.\n+\n+   MODE is the mode of the memory reference; OUTER_CODE and INDEX_CODE\n+   give the context that the rtx appears in.  These three arguments are\n+   passed down to base_reg_class.\n \n    SCALE is twice the amount to multiply the cost by (it is twice so we\n    can represent half-cost adjustments).  */\n \n static void\n-record_address_regs (rtx x, enum reg_class class, int scale)\n+record_address_regs (enum machine_mode mode, rtx x, int context,\n+\t\t     enum rtx_code outer_code, enum rtx_code index_code,\n+\t\t     int scale)\n {\n   enum rtx_code code = GET_CODE (x);\n+  enum reg_class class;\n+\n+  if (context == 1)\n+    class = INDEX_REG_CLASS;\n+  else\n+    class = base_reg_class (mode, outer_code, index_code);\n \n   switch (code)\n     {\n@@ -1940,54 +1983,52 @@ record_address_regs (rtx x, enum reg_class class, int scale)\n \t   be in the first operand.  */\n \n \tif (MAX_REGS_PER_ADDRESS == 1)\n-\t  record_address_regs (arg0, class, scale);\n+\t  record_address_regs (mode, arg0, 0, PLUS, code1, scale);\n \n \t/* If index and base registers are the same on this machine, just\n \t   record registers in any non-constant operands.  We assume here,\n \t   as well as in the tests below, that all addresses are in\n \t   canonical form.  */\n \n-\telse if (INDEX_REG_CLASS == MODE_BASE_REG_CLASS (VOIDmode))\n+\telse if (INDEX_REG_CLASS == base_reg_class (VOIDmode, PLUS, SCRATCH))\n \t  {\n-\t    record_address_regs (arg0, class, scale);\n+\t    record_address_regs (mode, arg0, context, PLUS, code1, scale);\n \t    if (! CONSTANT_P (arg1))\n-\t      record_address_regs (arg1, class, scale);\n+\t      record_address_regs (mode, arg1, context, PLUS, code0, scale);\n \t  }\n \n \t/* If the second operand is a constant integer, it doesn't change\n \t   what class the first operand must be.  */\n \n \telse if (code1 == CONST_INT || code1 == CONST_DOUBLE)\n-\t  record_address_regs (arg0, class, scale);\n+\t  record_address_regs (mode, arg0, context, PLUS, code1, scale);\n \n \t/* If the second operand is a symbolic constant, the first operand\n \t   must be an index register.  */\n \n \telse if (code1 == SYMBOL_REF || code1 == CONST || code1 == LABEL_REF)\n-\t  record_address_regs (arg0, INDEX_REG_CLASS, scale);\n+\t  record_address_regs (mode, arg0, 1, PLUS, code1, scale);\n \n \t/* If both operands are registers but one is already a hard register\n \t   of index or reg-base class, give the other the class that the\n \t   hard register is not.  */\n \n \telse if (code0 == REG && code1 == REG\n \t\t && REGNO (arg0) < FIRST_PSEUDO_REGISTER\n-\t\t && (REG_MODE_OK_FOR_REG_BASE_P (arg0, VOIDmode)\n-\t\t     || REG_OK_FOR_INDEX_P (arg0)))\n-\t  record_address_regs (arg1,\n-\t\t\t       REG_MODE_OK_FOR_REG_BASE_P (arg0, VOIDmode)\n-\t\t\t       ? INDEX_REG_CLASS\n-\t\t\t       : MODE_BASE_REG_REG_CLASS (VOIDmode),\n-\t\t\t       scale);\n+\t\t && (ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)\n+\t\t     || ok_for_index_p_nonstrict (arg0)))\n+\t  record_address_regs (mode, arg1,\n+\t\t\t       ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)\n+\t\t\t       ? 1 : 0,\n+\t\t\t       PLUS, REG, scale);\n \telse if (code0 == REG && code1 == REG\n \t\t && REGNO (arg1) < FIRST_PSEUDO_REGISTER\n-\t\t && (REG_MODE_OK_FOR_REG_BASE_P (arg1, VOIDmode)\n-\t\t     || REG_OK_FOR_INDEX_P (arg1)))\n-\t  record_address_regs (arg0,\n-\t\t\t       REG_MODE_OK_FOR_REG_BASE_P (arg1, VOIDmode)\n-\t\t\t       ? INDEX_REG_CLASS\n-\t\t\t       : MODE_BASE_REG_REG_CLASS (VOIDmode),\n-\t\t\t       scale);\n+\t\t && (ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)\n+\t\t     || ok_for_index_p_nonstrict (arg1)))\n+\t  record_address_regs (mode, arg0,\n+\t\t\t       ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)\n+\t\t\t       ? 1 : 0,\n+\t\t\t       PLUS, REG, scale);\n \n \t/* If one operand is known to be a pointer, it must be the base\n \t   with the other operand the index.  Likewise if the other operand\n@@ -1996,29 +2037,25 @@ record_address_regs (rtx x, enum reg_class class, int scale)\n \telse if ((code0 == REG && REG_POINTER (arg0))\n \t\t || code1 == MULT)\n \t  {\n-\t    record_address_regs (arg0, MODE_BASE_REG_REG_CLASS (VOIDmode),\n-\t\t\t\t scale);\n-\t    record_address_regs (arg1, INDEX_REG_CLASS, scale);\n+\t    record_address_regs (mode, arg0, 0, PLUS, code1, scale);\n+\t    record_address_regs (mode, arg1, 1, PLUS, code0, scale);\n \t  }\n \telse if ((code1 == REG && REG_POINTER (arg1))\n \t\t || code0 == MULT)\n \t  {\n-\t    record_address_regs (arg0, INDEX_REG_CLASS, scale);\n-\t    record_address_regs (arg1, MODE_BASE_REG_REG_CLASS (VOIDmode),\n-\t\t\t\t scale);\n+\t    record_address_regs (mode, arg0, 1, PLUS, code1, scale);\n+\t    record_address_regs (mode, arg1, 0, PLUS, code0, scale);\n \t  }\n \n \t/* Otherwise, count equal chances that each might be a base\n \t   or index register.  This case should be rare.  */\n \n \telse\n \t  {\n-\t    record_address_regs (arg0, MODE_BASE_REG_REG_CLASS (VOIDmode),\n-\t\t\t\t scale / 2);\n-\t    record_address_regs (arg0, INDEX_REG_CLASS, scale / 2);\n-\t    record_address_regs (arg1, MODE_BASE_REG_REG_CLASS (VOIDmode),\n-\t\t\t\t scale / 2);\n-\t    record_address_regs (arg1, INDEX_REG_CLASS, scale / 2);\n+\t    record_address_regs (mode, arg0, 0, PLUS, code1, scale / 2);\n+\t    record_address_regs (mode, arg0, 1, PLUS, code1, scale / 2);\n+\t    record_address_regs (mode, arg1, 0, PLUS, code0, scale / 2);\n+\t    record_address_regs (mode, arg1, 1, PLUS, code0, scale / 2);\n \t  }\n       }\n       break;\n@@ -2028,11 +2065,11 @@ record_address_regs (rtx x, enum reg_class class, int scale)\n \t if it ends up in the wrong place.  */\n     case POST_MODIFY:\n     case PRE_MODIFY:\n-      record_address_regs (XEXP (x, 0), MODE_BASE_REG_CLASS (VOIDmode),\n-\t\t\t   2 * scale);\n+      record_address_regs (mode, XEXP (x, 0), 0, code,\n+\t\t\t   GET_CODE (XEXP (XEXP (x, 1), 1)), 2 * scale);\n       if (REG_P (XEXP (XEXP (x, 1), 1)))\n-\trecord_address_regs (XEXP (XEXP (x, 1), 1),\n-\t\t\t     INDEX_REG_CLASS, 2 * scale);\n+\trecord_address_regs (mode, XEXP (XEXP (x, 1), 1), 1, code, REG,\n+\t\t\t     2 * scale);\n       break;\n \n     case POST_INC:\n@@ -2050,7 +2087,7 @@ record_address_regs (rtx x, enum reg_class class, int scale)\n \tin_inc_dec[REGNO (XEXP (x, 0))] = 1;\n #endif\n \n-      record_address_regs (XEXP (x, 0), class, 2 * scale);\n+      record_address_regs (mode, XEXP (x, 0), 0, code, SCRATCH, 2 * scale);\n       break;\n \n     case REG:\n@@ -2071,7 +2108,8 @@ record_address_regs (rtx x, enum reg_class class, int scale)\n \tint i;\n \tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t  if (fmt[i] == 'e')\n-\t    record_address_regs (XEXP (x, i), class, scale);\n+\t    record_address_regs (mode, XEXP (x, i), context, code, SCRATCH,\n+\t\t\t\t scale);\n       }\n     }\n }"}, {"sha": "ebb7cbb5fab6595fdd4d15c2d4bf09adb369e655", "filename": "gcc/regrename.c", "status": "modified", "additions": 55, "deletions": 33, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -27,6 +27,7 @@\n #include \"tm_p.h\"\n #include \"insn-config.h\"\n #include \"regs.h\"\n+#include \"addresses.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"reload.h\"\n@@ -528,7 +529,7 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n \trtx op1 = orig_op1;\n \trtx *locI = NULL;\n \trtx *locB = NULL;\n-\trtx *locB_reg = NULL;\n+\tenum rtx_code index_code;\n \n \tif (GET_CODE (op0) == SUBREG)\n \t  {\n@@ -547,59 +548,70 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n \t  {\n \t    locI = &XEXP (x, 0);\n \t    locB = &XEXP (x, 1);\n+\t    index_code = GET_CODE (*locI);\n \t  }\n \telse if (code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE\n \t\t || code1 == ZERO_EXTEND || code0 == MEM)\n \t  {\n \t    locI = &XEXP (x, 1);\n \t    locB = &XEXP (x, 0);\n+\t    index_code = GET_CODE (*locI);\n \t  }\n \telse if (code0 == CONST_INT || code0 == CONST\n \t\t || code0 == SYMBOL_REF || code0 == LABEL_REF)\n-\t  locB = &XEXP (x, 1);\n+\t  {\n+\t    locB = &XEXP (x, 1);\n+\t    index_code = GET_CODE (XEXP (x, 0));\n+\t  }\n \telse if (code1 == CONST_INT || code1 == CONST\n \t\t || code1 == SYMBOL_REF || code1 == LABEL_REF)\n-\t  locB = &XEXP (x, 0);\n+\t  {\n+\t    locB = &XEXP (x, 0);\n+\t    index_code = GET_CODE (XEXP (x, 1));\n+\t  }\n \telse if (code0 == REG && code1 == REG)\n \t  {\n \t    int index_op;\n+\t    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);\n \n-\t    if (REG_OK_FOR_INDEX_P (op0)\n-\t\t&& REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n+\t    if (REGNO_OK_FOR_INDEX_P (regno0)\n+\t\t&& regno_ok_for_base_p (regno1, mode, PLUS, REG))\n \t      index_op = 0;\n-\t    else if (REG_OK_FOR_INDEX_P (op1)\n-\t\t     && REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n+\t    else if (REGNO_OK_FOR_INDEX_P (regno1)\n+\t\t     && regno_ok_for_base_p (regno0, mode, PLUS, REG))\n \t      index_op = 1;\n-\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n+\t    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))\n \t      index_op = 0;\n-\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n+\t    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG))\n \t      index_op = 1;\n-\t    else if (REG_OK_FOR_INDEX_P (op1))\n+\t    else if (REGNO_OK_FOR_INDEX_P (regno1))\n \t      index_op = 1;\n \t    else\n \t      index_op = 0;\n \n \t    locI = &XEXP (x, index_op);\n-\t    locB_reg = &XEXP (x, !index_op);\n+\t    locB = &XEXP (x, !index_op);\n+\t    index_code = GET_CODE (*locI);\n \t  }\n \telse if (code0 == REG)\n \t  {\n \t    locI = &XEXP (x, 0);\n \t    locB = &XEXP (x, 1);\n+\t    index_code = GET_CODE (*locI);\n \t  }\n \telse if (code1 == REG)\n \t  {\n \t    locI = &XEXP (x, 1);\n \t    locB = &XEXP (x, 0);\n+\t    index_code = GET_CODE (*locI);\n \t  }\n \n \tif (locI)\n \t  scan_rtx_address (insn, locI, INDEX_REG_CLASS, action, mode);\n \tif (locB)\n-\t  scan_rtx_address (insn, locB, MODE_BASE_REG_CLASS (mode), action, mode);\n-\tif (locB_reg)\n-\t  scan_rtx_address (insn, locB_reg, MODE_BASE_REG_REG_CLASS (mode),\n+\t  scan_rtx_address (insn, locB, base_reg_class (mode, PLUS, index_code),\n \t\t\t    action, mode);\n+\n \treturn;\n       }\n \n@@ -618,7 +630,7 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n \n     case MEM:\n       scan_rtx_address (insn, &XEXP (x, 0),\n-\t\t\tMODE_BASE_REG_CLASS (GET_MODE (x)), action,\n+\t\t\tbase_reg_class (GET_MODE (x), MEM, SCRATCH), action,\n \t\t\tGET_MODE (x));\n       return;\n \n@@ -669,7 +681,7 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl,\n \n     case MEM:\n       scan_rtx_address (insn, &XEXP (x, 0),\n-\t\t\tMODE_BASE_REG_CLASS (GET_MODE (x)), action,\n+\t\t\tbase_reg_class (GET_MODE (x), MEM, SCRATCH), action,\n \t\t\tGET_MODE (x));\n       return;\n \n@@ -1441,7 +1453,7 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n \trtx op1 = orig_op1;\n \trtx *locI = NULL;\n \trtx *locB = NULL;\n-\trtx *locB_reg = NULL;\n+\tenum rtx_code index_code;\n \n \tif (GET_CODE (op0) == SUBREG)\n \t  {\n@@ -1460,62 +1472,71 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n \t  {\n \t    locI = &XEXP (x, 0);\n \t    locB = &XEXP (x, 1);\n+\t    index_code = GET_CODE (*locI);\n \t  }\n \telse if (code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE\n \t\t || code1 == ZERO_EXTEND || code0 == MEM)\n \t  {\n \t    locI = &XEXP (x, 1);\n \t    locB = &XEXP (x, 0);\n+\t    index_code = GET_CODE (*locI);\n \t  }\n \telse if (code0 == CONST_INT || code0 == CONST\n \t\t || code0 == SYMBOL_REF || code0 == LABEL_REF)\n-\t  locB = &XEXP (x, 1);\n+\t  {\n+\t    locB = &XEXP (x, 1);\n+\t    index_code = GET_CODE (XEXP (x, 0));\n+\t  }\n \telse if (code1 == CONST_INT || code1 == CONST\n \t\t || code1 == SYMBOL_REF || code1 == LABEL_REF)\n-\t  locB = &XEXP (x, 0);\n+\t  {\n+\t    locB = &XEXP (x, 0);\n+\t    index_code = GET_CODE (XEXP (x, 1));\n+\t  }\n \telse if (code0 == REG && code1 == REG)\n \t  {\n \t    int index_op;\n+\t    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);\n \n-\t    if (REG_OK_FOR_INDEX_P (op0)\n-\t\t&& REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n+\t    if (REGNO_OK_FOR_INDEX_P (regno0)\n+\t\t&& regno_ok_for_base_p (regno1, mode, PLUS, REG))\n \t      index_op = 0;\n-\t    else if (REG_OK_FOR_INDEX_P (op1)\n-\t\t     && REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n+\t    else if (REGNO_OK_FOR_INDEX_P (regno1)\n+\t\t     && regno_ok_for_base_p (regno0, mode, PLUS, REG))\n \t      index_op = 1;\n-\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n+\t    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))\n \t      index_op = 0;\n-\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n+\t    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG))\n \t      index_op = 1;\n-\t    else if (REG_OK_FOR_INDEX_P (op1))\n+\t    else if (REGNO_OK_FOR_INDEX_P (regno1))\n \t      index_op = 1;\n \t    else\n \t      index_op = 0;\n \n \t    locI = &XEXP (x, index_op);\n-\t    locB_reg = &XEXP (x, !index_op);\n+\t    locB = &XEXP (x, !index_op);\n+\t    index_code = GET_CODE (*locI);\n \t  }\n \telse if (code0 == REG)\n \t  {\n \t    locI = &XEXP (x, 0);\n \t    locB = &XEXP (x, 1);\n+\t    index_code = GET_CODE (*locI);\n \t  }\n \telse if (code1 == REG)\n \t  {\n \t    locI = &XEXP (x, 1);\n \t    locB = &XEXP (x, 0);\n+\t    index_code = GET_CODE (*locI);\n \t  }\n \n \tif (locI)\n \t  changed |= replace_oldest_value_addr (locI, INDEX_REG_CLASS, mode,\n \t\t\t\t\t\tinsn, vd);\n \tif (locB)\n \t  changed |= replace_oldest_value_addr (locB,\n-\t\t\t\t\t\tMODE_BASE_REG_CLASS (mode),\n-\t\t\t\t\t\tmode, insn, vd);\n-\tif (locB_reg)\n-\t  changed |= replace_oldest_value_addr (locB_reg,\n-\t\t\t\t\t\tMODE_BASE_REG_REG_CLASS (mode),\n+\t\t\t\t\t\tbase_reg_class (mode, PLUS,\n+\t\t\t\t\t\t\t\tindex_code),\n \t\t\t\t\t\tmode, insn, vd);\n \treturn changed;\n       }\n@@ -1559,7 +1580,8 @@ static bool\n replace_oldest_value_mem (rtx x, rtx insn, struct value_data *vd)\n {\n   return replace_oldest_value_addr (&XEXP (x, 0),\n-\t\t\t\t    MODE_BASE_REG_CLASS (GET_MODE (x)),\n+\t\t\t\t    base_reg_class (GET_MODE (x), MEM,\n+\t\t\t\t\t\t    SCRATCH),\n \t\t\t\t    GET_MODE (x), insn, vd);\n }\n "}, {"sha": "9bfb74854cae88d29dc6a403cda54b7ea957cd67", "filename": "gcc/reload.c", "status": "modified", "additions": 134, "deletions": 95, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -100,6 +100,7 @@ a register with any other reload.  */\n #include \"recog.h\"\n #include \"reload.h\"\n #include \"regs.h\"\n+#include \"addresses.h\"\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"real.h\"\n@@ -269,7 +270,8 @@ static int find_reloads_address (enum machine_mode, rtx *, rtx, rtx *,\n static rtx subst_reg_equivs (rtx, rtx);\n static rtx subst_indexed_address (rtx);\n static void update_auto_inc_notes (rtx, int, int);\n-static int find_reloads_address_1 (enum machine_mode, rtx, int, rtx *,\n+static int find_reloads_address_1 (enum machine_mode, rtx, int,\n+\t\t\t\t   enum rtx_code, enum rtx_code, rtx *,\n \t\t\t\t   int, enum reload_type,int, rtx);\n static void find_reloads_address_part (rtx, rtx *, enum reg_class,\n \t\t\t\t       enum machine_mode, int,\n@@ -3119,7 +3121,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t      case 'p':\n \t\t/* All necessary reloads for an address_operand\n \t\t   were handled in find_reloads_address.  */\n-\t\tthis_alternative[i] = (int) MODE_BASE_REG_CLASS (VOIDmode);\n+\t\tthis_alternative[i]\n+\t\t  = (int) base_reg_class (VOIDmode, ADDRESS, SCRATCH);\n \t\twin = 1;\n \t\tbadop = 0;\n \t\tbreak;\n@@ -3323,7 +3326,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t\t\t/* If we didn't already win, we can reload\n \t\t\t   the address into a base register.  */\n-\t\t\tthis_alternative[i] = (int) MODE_BASE_REG_CLASS (VOIDmode);\n+\t\t\tthis_alternative[i]\n+\t\t\t  = (int) base_reg_class (VOIDmode, ADDRESS, SCRATCH);\n \t\t\tbadop = 0;\n \t\t\tbreak;\n \t\t      }\n@@ -3826,7 +3830,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t    operand_reloadnum[i]\n \t      = push_reload (XEXP (recog_data.operand[i], 0), NULL_RTX,\n \t\t\t     &XEXP (recog_data.operand[i], 0), (rtx*) 0,\n-\t\t\t     MODE_BASE_REG_CLASS (VOIDmode),\n+\t\t\t     base_reg_class (VOIDmode, MEM, SCRATCH),\n \t\t\t     GET_MODE (XEXP (recog_data.operand[i], 0)),\n \t\t\t     VOIDmode, 0, 0, i, RELOAD_FOR_INPUT);\n \t    rld[operand_reloadnum[i]].inc\n@@ -4745,12 +4749,12 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t subject of a CLOBBER in this insn.  */\n \n       else if (regno < FIRST_PSEUDO_REGISTER\n-\t       && REGNO_MODE_OK_FOR_BASE_P (regno, mode)\n+\t       && regno_ok_for_base_p (regno, mode, MEM, SCRATCH)\n \t       && ! regno_clobbered_p (regno, this_insn, mode, 0))\n \treturn 0;\n \n       /* If we do not have one of the cases above, we must do the reload.  */\n-      push_reload (ad, NULL_RTX, loc, (rtx*) 0, MODE_BASE_REG_CLASS (mode),\n+      push_reload (ad, NULL_RTX, loc, (rtx*) 0, base_reg_class (mode, MEM, SCRATCH),\n \t\t   GET_MODE (ad), VOIDmode, 0, 0, opnum, type);\n       return 1;\n     }\n@@ -4851,7 +4855,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t  /* Must use TEM here, not AD, since it is the one that will\n \t     have any subexpressions reloaded, if needed.  */\n \t  push_reload (tem, NULL_RTX, loc, (rtx*) 0,\n-\t\t       MODE_BASE_REG_CLASS (mode), GET_MODE (tem),\n+\t\t       base_reg_class (mode, MEM, SCRATCH), GET_MODE (tem),\n \t\t       VOIDmode, 0,\n \t\t       0, opnum, type);\n \t  return ! removed_and;\n@@ -4868,8 +4872,10 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n   else if (GET_CODE (ad) == PLUS\n \t   && REG_P (XEXP (ad, 0))\n \t   && REGNO (XEXP (ad, 0)) < FIRST_PSEUDO_REGISTER\n-\t   && REG_MODE_OK_FOR_BASE_P (XEXP (ad, 0), mode)\n-\t   && GET_CODE (XEXP (ad, 1)) == CONST_INT)\n+\t   && GET_CODE (XEXP (ad, 1)) == CONST_INT\n+\t   && regno_ok_for_base_p (REGNO (XEXP (ad, 0)), mode, PLUS,\n+\t\t\t\t   CONST_INT))\n+\n     {\n       /* Unshare the MEM rtx so we can safely alter it.  */\n       if (memrefloc)\n@@ -4897,7 +4903,8 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t  /* If the sum of two regs is not necessarily valid,\n \t     reload the sum into a base reg.\n \t     That will at least work.  */\n-\t  find_reloads_address_part (ad, loc, MODE_BASE_REG_CLASS (mode),\n+\t  find_reloads_address_part (ad, loc,\n+\t\t\t\t     base_reg_class (mode, MEM, SCRATCH),\n \t\t\t\t     Pmode, opnum, type, ind_levels);\n \t}\n       return ! removed_and;\n@@ -4931,19 +4938,26 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \n   for (op_index = 0; op_index < 2; ++op_index)\n     {\n-      rtx operand;\n+      rtx operand, addend;\n+      enum rtx_code inner_code;\n+\n+      if (GET_CODE (ad) != PLUS)\n+\t  continue;\n \n+      inner_code = GET_CODE (XEXP (ad, 0));\n       if (!(GET_CODE (ad) == PLUS \n \t    && GET_CODE (XEXP (ad, 1)) == CONST_INT\n-\t    && (GET_CODE (XEXP (ad, 0)) == PLUS\n-\t\t|| GET_CODE (XEXP (ad, 0)) == LO_SUM)))\n+\t    && (inner_code == PLUS || inner_code == LO_SUM)))\n \tcontinue;\n \n       operand = XEXP (XEXP (ad, 0), op_index);\n       if (!REG_P (operand) || REGNO (operand) >= FIRST_PSEUDO_REGISTER)\n \tcontinue;\n \n-      if ((REG_MODE_OK_FOR_BASE_P (operand, mode)\n+      addend = XEXP (XEXP (ad, 0), 1 - op_index);\n+\n+      if ((regno_ok_for_base_p (REGNO (operand), mode, inner_code,\n+\t\t\t\tGET_CODE (addend))\n \t   || operand == frame_pointer_rtx\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n \t   || operand == hard_frame_pointer_rtx\n@@ -4956,11 +4970,10 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t\t\t\t       &XEXP (XEXP (ad, 0), 1 - op_index)))\n \t{\n \t  rtx offset_reg;\n-\t  rtx addend;\n+\t  enum reg_class cls;\n \n \t  offset_reg = plus_constant (operand, INTVAL (XEXP (ad, 1)));\n-\t  addend = XEXP (XEXP (ad, 0), 1 - op_index);\n-\t  \n+\n \t  /* Form the adjusted address.  */\n \t  if (GET_CODE (XEXP (ad, 0)) == PLUS)\n \t    ad = gen_rtx_PLUS (GET_MODE (ad), \n@@ -4972,12 +4985,13 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t\t\t\t op_index == 0 ? addend : offset_reg);\n \t  *loc = ad;\n \n+\t  cls = base_reg_class (mode, MEM, GET_CODE (addend));\n \t  find_reloads_address_part (XEXP (ad, op_index), \n-\t\t\t\t     &XEXP (ad, op_index),\n-\t\t\t\t     MODE_BASE_REG_CLASS (mode),\n+\t\t\t\t     &XEXP (ad, op_index), cls,\n \t\t\t\t     GET_MODE (ad), opnum, type, ind_levels);\n-\t  find_reloads_address_1 (mode, \n-\t\t\t\t  XEXP (ad, 1 - op_index), 1, \n+\t  find_reloads_address_1 (mode,\n+\t\t\t\t  XEXP (ad, 1 - op_index), 1, GET_CODE (ad),\n+\t\t\t\t  GET_CODE (XEXP (ad, op_index)),\n \t\t\t\t  &XEXP (ad, 1 - op_index), opnum,\n \t\t\t\t  type, 0, insn);\n \n@@ -5023,13 +5037,13 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t    loc = &XEXP (*loc, 0);\n \t}\n \n-      find_reloads_address_part (ad, loc, MODE_BASE_REG_CLASS (mode),\n+      find_reloads_address_part (ad, loc, base_reg_class (mode, MEM, SCRATCH),\n \t\t\t\t Pmode, opnum, type, ind_levels);\n       return ! removed_and;\n     }\n \n-  return find_reloads_address_1 (mode, ad, 0, loc, opnum, type, ind_levels,\n-\t\t\t\t insn);\n+  return find_reloads_address_1 (mode, ad, 0, MEM, SCRATCH, loc, opnum, type,\n+\t\t\t\t ind_levels, insn);\n }\n \f\n /* Find all pseudo regs appearing in AD\n@@ -5240,9 +5254,12 @@ update_auto_inc_notes (rtx insn ATTRIBUTE_UNUSED, int regno ATTRIBUTE_UNUSED,\n    is strictly valid.)\n \n    CONTEXT = 1 means we are considering regs as index regs,\n-   = 0 means we are considering them as base regs, = 2 means we\n-   are considering them as base regs for REG + REG.\n-\n+   = 0 means we are considering them as base regs.\n+   OUTER_CODE is the code of the enclosing RTX, typically a MEM, a PLUS,\n+   or an autoinc code.\n+   If CONTEXT == 0 and OUTER_CODE is a PLUS or LO_SUM, then INDEX_CODE\n+   is the code of the index part of the address.  Otherwise, pass SCRATCH\n+   for this argument.\n    OPNUM and TYPE specify the purpose of any reloads made.\n \n    IND_LEVELS says how many levels of indirect addressing are\n@@ -5263,25 +5280,22 @@ update_auto_inc_notes (rtx insn ATTRIBUTE_UNUSED, int regno ATTRIBUTE_UNUSED,\n \n static int\n find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n+\t\t\tenum rtx_code outer_code, enum rtx_code index_code,\n \t\t\trtx *loc, int opnum, enum reload_type type,\n \t\t\tint ind_levels, rtx insn)\n {\n-#define REG_OK_FOR_CONTEXT(CONTEXT, REGNO, MODE)\t\t\\\n-  ((CONTEXT) == 2\t\t\t\t\t\\\n-   ? REGNO_MODE_OK_FOR_REG_BASE_P (REGNO, MODE)\t\t\\\n-   : (CONTEXT) == 1\t\t\t\t\t\\\n-   ? REGNO_OK_FOR_INDEX_P (REGNO)\t\t\t\\\n-   : REGNO_MODE_OK_FOR_BASE_P (REGNO, MODE))\n+#define REG_OK_FOR_CONTEXT(CONTEXT, REGNO, MODE, OUTER, INDEX)\t\t\\\n+  ((CONTEXT) == 0\t\t\t\t\t\t\t\\\n+   ? regno_ok_for_base_p (REGNO, MODE, OUTER, INDEX)\t\t\t\\\n+   : REGNO_OK_FOR_INDEX_P (REGNO))\t\t\t\t\t\n \n   enum reg_class context_reg_class;\n   RTX_CODE code = GET_CODE (x);\n \n-  if (context == 2)\n-    context_reg_class = MODE_BASE_REG_REG_CLASS (mode);\n-  else if (context == 1)\n+  if (context == 1)\n     context_reg_class = INDEX_REG_CLASS;\n   else\n-    context_reg_class = MODE_BASE_REG_CLASS (mode);\n+    context_reg_class = base_reg_class (mode, outer_code, index_code);\n \n   switch (code)\n     {\n@@ -5338,74 +5352,90 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE\n \t    || code0 == ZERO_EXTEND || code1 == MEM)\n \t  {\n-\t    find_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n-\t\t\t\t    type, ind_levels, insn);\n-\t    find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n-\t\t\t\t    type, ind_levels, insn);\n+\t    find_reloads_address_1 (mode, orig_op0, 1, PLUS, SCRATCH,\n+\t\t\t\t    &XEXP (x, 0), opnum, type, ind_levels,\n+\t\t\t\t    insn);\n+\t    find_reloads_address_1 (mode, orig_op1, 0, PLUS, code0,\n+\t\t\t\t    &XEXP (x, 1), opnum, type, ind_levels,\n+\t\t\t\t    insn);\n \t  }\n \n \telse if (code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE\n \t\t || code1 == ZERO_EXTEND || code0 == MEM)\n \t  {\n-\t    find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n-\t\t\t\t    type, ind_levels, insn);\n-\t    find_reloads_address_1 (mode, orig_op1, 1, &XEXP (x, 1), opnum,\n-\t\t\t\t    type, ind_levels, insn);\n+\t    find_reloads_address_1 (mode, orig_op0, 0, PLUS, code1,\n+\t\t\t\t    &XEXP (x, 0), opnum, type, ind_levels,\n+\t\t\t\t    insn);\n+\t    find_reloads_address_1 (mode, orig_op1, 1, PLUS, SCRATCH,\n+\t\t\t\t    &XEXP (x, 1), opnum, type, ind_levels,\n+\t\t\t\t    insn);\n \t  }\n \n \telse if (code0 == CONST_INT || code0 == CONST\n \t\t || code0 == SYMBOL_REF || code0 == LABEL_REF)\n-\t  find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n-\t\t\t\t  type, ind_levels, insn);\n+\t  find_reloads_address_1 (mode, orig_op1, 0, PLUS, code0,\n+\t\t\t\t  &XEXP (x, 1), opnum, type, ind_levels,\n+\t\t\t\t  insn);\n \n \telse if (code1 == CONST_INT || code1 == CONST\n \t\t || code1 == SYMBOL_REF || code1 == LABEL_REF)\n-\t  find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n-\t\t\t\t  type, ind_levels, insn);\n+\t  find_reloads_address_1 (mode, orig_op0, 0, PLUS, code1,\n+\t\t\t\t  &XEXP (x, 0), opnum, type, ind_levels,\n+\t\t\t\t  insn);\n \n \telse if (code0 == REG && code1 == REG)\n \t  {\n-\t    if (REG_OK_FOR_INDEX_P (op0)\n-\t\t&& REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n+\t    if (REGNO_OK_FOR_INDEX_P (REGNO (op0))\n+\t\t&& regno_ok_for_base_p (REGNO (op1), mode, PLUS, REG))\n \t      return 0;\n-\t    else if (REG_OK_FOR_INDEX_P (op1)\n-\t\t     && REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n+\t    else if (REGNO_OK_FOR_INDEX_P (REGNO (op1))\n+\t\t     && regno_ok_for_base_p (REGNO (op0), mode, PLUS, REG))\n \t      return 0;\n-\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op1, mode))\n-\t      find_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n-\t\t\t\t      type, ind_levels, insn);\n-\t    else if (REG_MODE_OK_FOR_REG_BASE_P (op0, mode))\n-\t      find_reloads_address_1 (mode, orig_op1, 1, &XEXP (x, 1), opnum,\n-\t\t\t\t      type, ind_levels, insn);\n-\t    else if (REG_OK_FOR_INDEX_P (op1))\n-\t      find_reloads_address_1 (mode, orig_op0, 2, &XEXP (x, 0), opnum,\n-\t\t\t\t      type, ind_levels, insn);\n-\t    else if (REG_OK_FOR_INDEX_P (op0))\n-\t      find_reloads_address_1 (mode, orig_op1, 2, &XEXP (x, 1), opnum,\n-\t\t\t\t      type, ind_levels, insn);\n+\t    else if (regno_ok_for_base_p (REGNO (op1), mode, PLUS, REG))\n+\t      find_reloads_address_1 (mode, orig_op0, 1, PLUS, SCRATCH,\n+\t\t\t\t      &XEXP (x, 0), opnum, type, ind_levels,\n+\t\t\t\t      insn);\n+\t    else if (regno_ok_for_base_p (REGNO (op0), mode, PLUS, REG))\n+\t      find_reloads_address_1 (mode, orig_op1, 1, PLUS, SCRATCH,\n+\t\t\t\t      &XEXP (x, 1), opnum, type, ind_levels,\n+\t\t\t\t      insn);\n+\t    else if (REGNO_OK_FOR_INDEX_P (REGNO (op1)))\n+\t      find_reloads_address_1 (mode, orig_op0, 0, PLUS, REG,\n+\t\t\t\t      &XEXP (x, 0), opnum, type, ind_levels,\n+\t\t\t\t      insn);\n+\t    else if (REGNO_OK_FOR_INDEX_P (REGNO (op0)))\n+\t      find_reloads_address_1 (mode, orig_op1, 0, PLUS, REG,\n+\t\t\t\t      &XEXP (x, 1), opnum, type, ind_levels,\n+\t\t\t\t      insn);\n \t    else\n \t      {\n-\t\tfind_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n-\t\t\t\t\ttype, ind_levels, insn);\n-\t\tfind_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n-\t\t\t\t\ttype, ind_levels, insn);\n+\t\tfind_reloads_address_1 (mode, orig_op0, 1, PLUS, SCRATCH,\n+\t\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels,\n+\t\t\t\t\tinsn);\n+\t\tfind_reloads_address_1 (mode, orig_op1, 0, PLUS, REG,\n+\t\t\t\t\t&XEXP (x, 1), opnum, type, ind_levels,\n+\t\t\t\t\tinsn);\n \t      }\n \t  }\n \n \telse if (code0 == REG)\n \t  {\n-\t    find_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n-\t\t\t\t    type, ind_levels, insn);\n-\t    find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n-\t\t\t\t    type, ind_levels, insn);\n+\t    find_reloads_address_1 (mode, orig_op0, 1, PLUS, SCRATCH,\n+\t\t\t\t    &XEXP (x, 0), opnum, type, ind_levels,\n+\t\t\t\t    insn);\n+\t    find_reloads_address_1 (mode, orig_op1, 0, PLUS, REG,\n+\t\t\t\t    &XEXP (x, 1), opnum, type, ind_levels,\n+\t\t\t\t    insn);\n \t  }\n \n \telse if (code1 == REG)\n \t  {\n-\t    find_reloads_address_1 (mode, orig_op1, 1, &XEXP (x, 1), opnum,\n-\t\t\t\t    type, ind_levels, insn);\n-\t    find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n-\t\t\t\t    type, ind_levels, insn);\n+\t    find_reloads_address_1 (mode, orig_op1, 1, PLUS, SCRATCH,\n+\t\t\t\t    &XEXP (x, 1), opnum, type, ind_levels,\n+\t\t\t\t    insn);\n+\t    find_reloads_address_1 (mode, orig_op0, 0, PLUS, REG,\n+\t\t\t\t    &XEXP (x, 0), opnum, type, ind_levels,\n+\t\t\t\t    insn);\n \t  }\n       }\n \n@@ -5416,6 +5446,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n       {\n \trtx op0 = XEXP (x, 0);\n \trtx op1 = XEXP (x, 1);\n+\tenum rtx_code index_code;\n \tint regno;\n \tint reloadnum;\n \n@@ -5434,12 +5465,14 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t   register with its equivalent constant where applicable.  */\n \tif (REG_P (XEXP (op1, 1)))\n \t  if (!REGNO_OK_FOR_INDEX_P (REGNO (XEXP (op1, 1))))\n-\t    find_reloads_address_1 (mode, XEXP (op1, 1), 1, &XEXP (op1, 1),\n-\t\t\t\t    opnum, type, ind_levels, insn);\n+\t    find_reloads_address_1 (mode, XEXP (op1, 1), 1, code, SCRATCH,\n+\t\t\t\t    &XEXP (op1, 1), opnum, type, ind_levels,\n+\t\t\t\t    insn);\n \n \tgcc_assert (REG_P (XEXP (op1, 0)));\n \n \tregno = REGNO (XEXP (op1, 0));\n+\tindex_code = GET_CODE (XEXP (op1, 1));\n \n \t/* A register that is incremented cannot be constant!  */\n \tgcc_assert (regno < FIRST_PSEUDO_REGISTER\n@@ -5466,12 +5499,13 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t\t\t      ind_levels, insn);\n \n \t\t/* Then reload the memory location into a base\n-\t\t    register.  */\n+\t\t   register.  */\n \t\treloadnum = push_reload (tem, tem, &XEXP (x, 0),\n-\t\t\t\t\t  &XEXP (op1, 0),\n-\t\t\t\t\t  MODE_BASE_REG_CLASS (mode),\n-\t\t\t\t\t  GET_MODE (x), GET_MODE (x), 0,\n-\t\t\t\t\t  0, opnum, RELOAD_OTHER);\n+\t\t\t\t\t &XEXP (op1, 0),\n+\t\t\t\t\t base_reg_class (mode, code,\n+\t\t\t\t\t\t\t index_code),\n+\t\t\t\t\t GET_MODE (x), GET_MODE (x), 0,\n+\t\t\t\t\t 0, opnum, RELOAD_OTHER);\n \n \t\tupdate_auto_inc_notes (this_insn, regno, reloadnum);\n \t\treturn 0;\n@@ -5482,13 +5516,13 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t  regno = reg_renumber[regno];\n \n \t/* We require a base register here...  */\n-\tif (!REGNO_MODE_OK_FOR_BASE_P (regno, GET_MODE (x)))\n+\tif (!regno_ok_for_base_p (regno, GET_MODE (x), code, index_code))\n \t  {\n \t    reloadnum = push_reload (XEXP (op1, 0), XEXP (x, 0),\n-\t\t\t\t      &XEXP (op1, 0), &XEXP (x, 0),\n-\t\t\t\t      MODE_BASE_REG_CLASS (mode),\n-\t\t\t\t      GET_MODE (x), GET_MODE (x), 0, 0,\n-\t\t\t\t      opnum, RELOAD_OTHER);\n+\t\t\t\t     &XEXP (op1, 0), &XEXP (x, 0),\n+\t\t\t\t     base_reg_class (mode, code, index_code),\n+\t\t\t\t     GET_MODE (x), GET_MODE (x), 0, 0,\n+\t\t\t\t     opnum, RELOAD_OTHER);\n \n \t    update_auto_inc_notes (this_insn, regno, reloadnum);\n \t    return 0;\n@@ -5546,7 +5580,8 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t  if (reg_renumber[regno] >= 0)\n \t    regno = reg_renumber[regno];\n \t  if (regno >= FIRST_PSEUDO_REGISTER\n-\t      || !REG_OK_FOR_CONTEXT (context, regno, mode))\n+\t      || !REG_OK_FOR_CONTEXT (context, regno, mode, outer_code,\n+\t\t\t\t      index_code))\n \t    {\n \t      int reloadnum;\n \n@@ -5654,7 +5689,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t (or perhaps even a different part of an outer expression), should\n \t define LEGITIMIZE_RELOAD_ADDRESS.  */\n       find_reloads_address_1 (GET_MODE (XEXP (x, 0)), XEXP (x, 0),\n-\t\t\t      context, &XEXP (x, 0), opnum,\n+\t\t\t      context, code, SCRATCH, &XEXP (x, 0), opnum,\n \t\t\t      type, ind_levels, insn);\n       push_reload (x, NULL_RTX, loc, (rtx*) 0,\n \t\t   context_reg_class,\n@@ -5722,7 +5757,8 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t  regno = reg_renumber[regno];\n \n \tif (regno >= FIRST_PSEUDO_REGISTER\n-\t    || !REG_OK_FOR_CONTEXT (context, regno, mode))\n+\t    || !REG_OK_FOR_CONTEXT (context, regno, mode, outer_code,\n+\t\t\t\t    index_code))\n \t  {\n \t    push_reload (x, NULL_RTX, loc, (rtx*) 0,\n \t\t\t context_reg_class,\n@@ -5754,7 +5790,8 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t    {\n \t      int regno ATTRIBUTE_UNUSED = subreg_regno (x);\n \n-\t      if (! REG_OK_FOR_CONTEXT (context, regno, mode))\n+\t      if (!REG_OK_FOR_CONTEXT (context, regno, mode, outer_code,\n+\t\t\t\t       index_code))\n \t\t{\n \t\t  push_reload (x, NULL_RTX, loc, (rtx*) 0,\n \t\t\t       context_reg_class,\n@@ -5792,8 +5829,10 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n \tif (fmt[i] == 'e')\n-\t  find_reloads_address_1 (mode, XEXP (x, i), context, &XEXP (x, i),\n-\t\t\t\t  opnum, type, ind_levels, insn);\n+\t  /* Pass SCRATCH for INDEX_CODE, since CODE can never be a PLUS once\n+\t     we get here.  */\n+\t  find_reloads_address_1 (mode, XEXP (x, i), context, code, SCRATCH,\n+\t\t\t\t  &XEXP (x, i), opnum, type, ind_levels, insn);\n       }\n   }\n "}, {"sha": "a735cfed00fd337f471922557404f001e0770d68", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -36,6 +36,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"expr.h\"\n #include \"optabs.h\"\n #include \"regs.h\"\n+#include \"addresses.h\"\n #include \"basic-block.h\"\n #include \"reload.h\"\n #include \"recog.h\"\n@@ -1375,7 +1376,7 @@ maybe_fix_stack_asms (void)\n \n \t\tcase 'p':\n \t\t  cls = (int) reg_class_subunion[cls]\n-\t\t    [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n+\t\t      [(int) base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n \t\t  break;\n \n \t\tcase 'g':\n@@ -1386,7 +1387,7 @@ maybe_fix_stack_asms (void)\n \t\tdefault:\n \t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n \t\t    cls = (int) reg_class_subunion[cls]\n-\t\t      [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n+\t\t      [(int) base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n \t\t  else\n \t\t    cls = (int) reg_class_subunion[cls]\n \t\t      [(int) REG_CLASS_FROM_CONSTRAINT (c, p)];"}, {"sha": "8113306e0e87cabcd7dc8f15a717dc46a66e1ea5", "filename": "gcc/rtl-factoring.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Frtl-factoring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4963a0a324c37a487535f25590f2c539ceb39fc/gcc%2Frtl-factoring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-factoring.c?ref=c4963a0a324c37a487535f25590f2c539ceb39fc", "patch": "@@ -36,6 +36,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-flow.h\"\n #include \"timevar.h\"\n #include \"output.h\"\n+#include \"addresses.h\"\n \n /* Sequence abstraction:\n \n@@ -689,8 +690,9 @@ recompute_gain_for_pattern_seq (pattern_seq pseq)\n #ifdef REGNO_OK_FOR_INDIRECT_JUMP_P\n         || (!REGNO_OK_FOR_INDIRECT_JUMP_P (i, Pmode))\n #else\n-        || (!REGNO_MODE_OK_FOR_BASE_P (i, Pmode))\n-        || (!reg_class_subset_p (REGNO_REG_CLASS (i), BASE_REG_CLASS))\n+        || (!ok_for_base_p_1 (i, Pmode, MEM, SCRATCH))\n+        || (!reg_class_subset_p (REGNO_REG_CLASS (i),\n+\t\t\t\t base_reg_class (VOIDmode, MEM, SCRATCH)))\n #endif\n         || (hascall && call_used_regs[i])\n         || (!call_used_regs[i] && !regs_ever_live[i]))"}]}