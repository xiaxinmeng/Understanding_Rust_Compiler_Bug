{"sha": "0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZmYWM4MzIyZjg4MjVjMGQ2OTZkOWM3MDBiMGQwZjFhMzk1ZDExYQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-05-18T15:33:03Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-05-18T15:33:03Z"}, "message": "ZipOutputStream.java (level): Initial value is Deflater.DEFAULT_COMPRESSION.\n\n\t* java/util/zip/ZipOutputStream.java (level): Initial value is\n\tDeflater.DEFAULT_COMPRESSION.\n\t(close): New method.\n\t(closeEntry): Likewise.\n\t(finish): Likewise.\n\t(put_version): Likewise.\n\t(write_entry): Likewise.\n\t(put2, put4): Now return `int'.\n\t(comment): Default to empty string.\n\t(bytes_written): New instance variable.\n\t(chain): Likewise.\n\t* java/util/zip/ZipEntry.java (setComment): Limit length of\n\tcomment string.\n\t(setCrc): Check CRC validity.\n\t(setExtra): Check argument validity.\n\t(setMethod): Likewise.\n\t(setSize): Likewise.\n\t(ZipEntry): Likewise.\n\t* include/javaprims.h: Updated namespace declarations.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (ordinary_java_source_files): Mention new files.\n\t(nat_source_files): Likewise.\n\t* java/util/zip/ZipFile.java (readu2): Throw ZipException, not\n\tEOFException.\n\t(read4): Likewise.\n\t(getInputStream): Handle compressed entries.\n\t* java/util/zip/GZIPOutputStream.java: New file.\n\t* java/util/zip/GZIPInputStream.java: New file.\n\t* java/util/zip/DataFormatException.java: New file.\n\t* java/util/zip/CheckedInputStream.java: New file.\n\t* java/util/zip/CheckedOutputStream.java: New file.\n\t* java/util/zip/InflaterInputStream.java: Implemented.\n\t* java/util/zip/natInflater.cc: New file.\n\t* java/util/zip/Deflater.java: Implemented.\n\t* java/util/zip/natDeflater.cc: New file.\n\t* java/util/zip/DeflaterOutputStream.java: Implemented.\n\t* java/util/zip/ZipInputStream.java (closeZipEntry): Throw\n\tZipException, not IOException.\n\t* java/util/zip/ZipFile.java (readDirectory): Throw ZipException,\n\tnot IOException.\n\nFrom-SVN: r26996", "tree": {"sha": "c538fe74824c64ba74944a357c354f0c77e93be5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c538fe74824c64ba74944a357c354f0c77e93be5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/comments", "author": null, "committer": null, "parents": [{"sha": "5a9e5c6fb6c140bd80a2986f1d537a250a62ea59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59"}], "stats": {"total": 1619, "additions": 1547, "deletions": 72}, "files": [{"sha": "1e5b4224ba5b6e8f714eaacf3064018d797893bd", "filename": "libjava/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -1,3 +1,47 @@\n+1999-05-18  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java/util/zip/ZipOutputStream.java (level): Initial value is\n+\tDeflater.DEFAULT_COMPRESSION.\n+\t(close): New method.\n+\t(closeEntry): Likewise.\n+\t(finish): Likewise.\n+\t(put_version): Likewise.\n+\t(write_entry): Likewise.\n+\t(put2, put4): Now return `int'.\n+\t(comment): Default to empty string.\n+\t(bytes_written): New instance variable.\n+\t(chain): Likewise.\n+\t* java/util/zip/ZipEntry.java (setComment): Limit length of\n+\tcomment string.\n+\t(setCrc): Check CRC validity.\n+\t(setExtra): Check argument validity.\n+\t(setMethod): Likewise.\n+\t(setSize): Likewise.\n+\t(ZipEntry): Likewise.\n+\t* include/javaprims.h: Updated namespace declarations.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (ordinary_java_source_files): Mention new files.\n+\t(nat_source_files): Likewise.\n+\t* java/util/zip/ZipFile.java (readu2): Throw ZipException, not\n+\tEOFException.\n+\t(read4): Likewise.\n+\t(getInputStream): Handle compressed entries.\n+\t* java/util/zip/GZIPOutputStream.java: New file.\n+\t* java/util/zip/GZIPInputStream.java: New file.\n+\t* java/util/zip/DataFormatException.java: New file.\n+\t* java/util/zip/CheckedInputStream.java: New file.\n+\t* java/util/zip/CheckedOutputStream.java: New file.\n+\t* java/util/zip/InflaterInputStream.java: Implemented.\n+\t* java/util/zip/natInflater.cc: New file.\n+\t* java/util/zip/Deflater.java: Implemented.\n+\t* java/util/zip/natDeflater.cc: New file.\n+\t* java/util/zip/DeflaterOutputStream.java: Implemented.\n+\n+\t* java/util/zip/ZipInputStream.java (closeZipEntry): Throw\n+\tZipException, not IOException.\n+\t* java/util/zip/ZipFile.java (readDirectory): Throw ZipException,\n+\tnot IOException.\n+\n 1999-05-17  Tom Tromey  <tromey@cygnus.com>\n \n \t* java/lang/natSystem.cc (init_properties): URL now points to"}, {"sha": "48bf5742e19ccadc44b54c50d4f5dc8eefc8c1a6", "filename": "libjava/Makefile.am", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -654,9 +654,15 @@ java/util/TooManyListenersException.java \\\n java/util/Vector.java \\\n java/util/zip/Adler32.java \\\n java/util/zip/CRC32.java \\\n+java/util/zip/CheckedInputStream.java \\\n+java/util/zip/CheckedOutputStream.java \\\n java/util/zip/Checksum.java \\\n+java/util/zip/DataFormatException.java \\\n java/util/zip/Deflater.java \\\n java/util/zip/DeflaterOutputStream.java\t\\\n+java/util/zip/GZIPInputStream.java \\\n+java/util/zip/GZIPOutputStream.java \\\n+java/util/zip/Inflater.java \\\n java/util/zip/InflaterInputStream.java\t\\\n java/util/zip/ZipConstants.java\t\\\n java/util/zip/ZipEntry.java \\\n@@ -715,7 +721,9 @@ java/net/natInetAddress.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n java/util/natDate.cc \\\n-java/util/natGregorianCalendar.cc\n+java/util/natGregorianCalendar.cc \\\n+java/util/zip/natDeflater.cc \\\n+java/util/zip/natInflater.cc\n \n ## ################################################################\n "}, {"sha": "8550997742d541449842fa49b05c89f70c2faa5d", "filename": "libjava/Makefile.in", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -203,7 +203,7 @@ jv_convert_LINK = $(LIBTOOL) --mode=link $(GCJ) $(JC1FLAGS) $(LDFLAGS) \\\n \t-o jv-convert\n \n jv_convert_LDADD = $(convert_source_files:.java=.lo) libgcj.la \\\n-\t$(GCLIBS) $(THREADLIBS) $(ZLIBS)\n+\t$(GCLIBS) $(THREADLIBS) $(ZLIBS) -L$(here)/.libs\n \n jv_convert_DEPENDENCIES = $(convert_source_files:.java=.lo) \\\n \t$(GCDEPS) $(THREADDEPS) $(ZDEPS) libgcj.la libgcj.spec\n@@ -505,9 +505,15 @@ java/util/TooManyListenersException.java \\\n java/util/Vector.java \\\n java/util/zip/Adler32.java \\\n java/util/zip/CRC32.java \\\n+java/util/zip/CheckedInputStream.java \\\n+java/util/zip/CheckedOutputStream.java \\\n java/util/zip/Checksum.java \\\n+java/util/zip/DataFormatException.java \\\n java/util/zip/Deflater.java \\\n java/util/zip/DeflaterOutputStream.java\t\\\n+java/util/zip/GZIPInputStream.java \\\n+java/util/zip/GZIPOutputStream.java \\\n+java/util/zip/Inflater.java \\\n java/util/zip/InflaterInputStream.java\t\\\n java/util/zip/ZipConstants.java\t\\\n java/util/zip/ZipEntry.java \\\n@@ -566,7 +572,9 @@ java/net/natInetAddress.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n java/util/natDate.cc \\\n-java/util/natGregorianCalendar.cc\n+java/util/natGregorianCalendar.cc \\\n+java/util/zip/natDeflater.cc \\\n+java/util/zip/natInflater.cc\n \n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n@@ -832,9 +840,14 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/Stack.P .deps/java/util/StringTokenizer.P \\\n .deps/java/util/TimeZone.P .deps/java/util/TooManyListenersException.P \\\n .deps/java/util/Vector.P .deps/java/util/zip/Adler32.P \\\n-.deps/java/util/zip/CRC32.P .deps/java/util/zip/Checksum.P \\\n+.deps/java/util/zip/CRC32.P .deps/java/util/zip/CheckedInputStream.P \\\n+.deps/java/util/zip/CheckedOutputStream.P \\\n+.deps/java/util/zip/Checksum.P \\\n+.deps/java/util/zip/DataFormatException.P \\\n .deps/java/util/zip/Deflater.P \\\n .deps/java/util/zip/DeflaterOutputStream.P \\\n+.deps/java/util/zip/GZIPInputStream.P \\\n+.deps/java/util/zip/GZIPOutputStream.P .deps/java/util/zip/Inflater.P \\\n .deps/java/util/zip/InflaterInputStream.P \\\n .deps/java/util/zip/ZipConstants.P .deps/java/util/zip/ZipEntry.P \\\n .deps/java/util/zip/ZipException.P .deps/java/util/zip/ZipFile.P \\"}, {"sha": "98781ad51f22708e2351fe07b67c862fdf13f94a", "filename": "libjava/include/javaprims.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Finclude%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Finclude%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjavaprims.h?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -211,9 +211,15 @@ extern \"Java\"\n       {\n         class Adler32;\n         class CRC32;\n+        class CheckedInputStream;\n+        class CheckedOutputStream;\n         class Checksum;\n+        class DataFormatException;\n         class Deflater;\n         class DeflaterOutputStream;\n+        class GZIPInputStream;\n+        class GZIPOutputStream;\n+        class Inflater;\n         class InflaterInputStream;\n         class ZipConstants;\n         class ZipEntry;"}, {"sha": "a6a9058a5a44c25e60636e42341cd401fa5b5493", "filename": "libjava/java/util/zip/CheckedInputStream.java", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FCheckedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FCheckedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FCheckedInputStream.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -0,0 +1,80 @@\n+// CheckedInputStream.java - Compute checksum of data being read.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.util.zip;\n+\n+import java.io.FilterInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+/**\n+ * @author Tom Tromey\n+ * @date May 17, 1999\n+ */\n+\n+/* Written using on-line Java Platform 1.2 API Specification\n+ * and JCL book.\n+ * Believed complete and correct.\n+ */\n+\n+public class CheckedInputStream extends FilterInputStream\n+{\n+  public CheckedInputStream (InputStream in, Checksum sum)\n+  {\n+    super (in);\n+    this.sum = sum;\n+  }\n+\n+  public Checksum getChecksum ()\n+  {\n+    return sum;\n+  }\n+\n+  public int read () throws IOException\n+  {\n+    int x = in.read();\n+    if (x != -1)\n+      sum.update(x);\n+    return x;\n+  }\n+\n+  public int read (byte[] buf, int off, int len) throws IOException\n+  {\n+    int r = in.read(buf, off, len);\n+    if (r != -1)\n+      sum.update(buf, off, r);\n+    return r;\n+  }\n+\n+  public long skip (long n) throws IOException\n+  {\n+    if (n == 0)\n+      return 0;\n+\n+    int min = (int) Math.min(n, 1024);\n+    byte[] buf = new byte[min];\n+\n+    long s = 0;\n+    while (n > 0)\n+      {\n+\tint r = in.read(buf, 0, min);\n+\tif (r == -1)\n+\t  break;\n+\tn -= r;\n+\ts += r;\n+\tsum.update(buf, 0, r);\n+      }\n+\n+    return s;\n+  }\n+\n+  // The checksum object.\n+  private Checksum sum;\n+}"}, {"sha": "30dbc734f8aa2d29d29a739e816b4a8c341bd465", "filename": "libjava/java/util/zip/CheckedOutputStream.java", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FCheckedOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FCheckedOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FCheckedOutputStream.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -0,0 +1,54 @@\n+// CheckedOutputStream.java - Compute checksum of data being written.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.util.zip;\n+\n+import java.io.FilterOutputStream;\n+import java.io.OutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * @author Tom Tromey\n+ * @date May 17, 1999\n+ */\n+\n+/* Written using on-line Java Platform 1.2 API Specification\n+ * and JCL book.\n+ * Believed complete and correct.\n+ */\n+\n+public class CheckedOutputStream extends FilterOutputStream\n+{\n+  public CheckedOutputStream (OutputStream out, Checksum cksum)\n+  {\n+    super (out);\n+    this.sum = cksum;\n+  }\n+\n+  public Checksum getChecksum ()\n+  {\n+    return sum;\n+  }\n+\n+  public void write (int bval) throws IOException\n+  {\n+    out.write(bval);\n+    sum.update(bval);\n+  }\n+\n+  public void write (byte[] buf, int off, int len) throws IOException\n+  {\n+    out.write(buf, off, len);\n+    sum.update(buf, off, len);\n+  }\n+\n+  // The checksum object.\n+  private Checksum sum;\n+}"}, {"sha": "258f47f16a38f923954b9a5c8fc331d7c369605b", "filename": "libjava/java/util/zip/DataFormatException.java", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FDataFormatException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FDataFormatException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FDataFormatException.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -0,0 +1,33 @@\n+// DataFormatException.java\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libjava.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libjava License.  Please consult the file \"LIBJAVA_LICENSE\" for\n+details.  */\n+\n+package java.util.zip;\n+\n+/**\n+ * @author Tom Tromey\n+ * @date May 17, 1999\n+ */\n+\n+/* Written using on-line Java Platform 1.2 API Specification.\n+ * Believed complete and correct.\n+ */\n+\n+public class DataFormatException extends java.io.IOException\n+{\n+  public DataFormatException ()\n+  {\n+    super();\n+  }\n+\n+  public DataFormatException (String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "70855c5a3bc6c96b76db347c49df5cd7b1c5e65b", "filename": "libjava/java/util/zip/Deflater.java", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FDeflater.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FDeflater.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FDeflater.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -1,3 +1,5 @@\n+// Deflater.java - Compress a data stream.\n+\n /* Copyright (C) 1999  Cygnus Solutions\n \n    This file is part of libgcj.\n@@ -8,6 +10,123 @@\n \n package java.util.zip;\n \n+import gnu.gcj.RawData;\n+\n+/**\n+ * @author Tom Tromey\n+ * @date May 17, 1999\n+ */\n+\n+/* Written using on-line Java Platform 1.2 API Specification\n+ * and JCL book.\n+ * Believed complete and correct.\n+ */\n+\n public class Deflater\n {\n+  public static final int BEST_COMPRESSION = 9;\n+  public static final int BEST_SPEED = 1;\n+  public static final int DEFAULT_COMPRESSION = -1;\n+  public static final int NO_COMPRESSION = 0;\n+\n+  public static final int DEFAULT_STRATEGY = 0;\n+  public static final int FILTERED = 1;\n+  public static final int HUFFMAN_ONLY = 2;\n+\n+  public static final int DEFLATED = 8;\n+\n+  public int deflate (byte[] buf)\n+  {\n+    return deflate (buf, 0, buf.length);\n+  }\n+\n+  public native int deflate (byte[] buf, int off, int len);\n+  public native void init (int level, boolean noHeader);\n+  public native void update ();\n+\n+  public Deflater ()\n+  {\n+    this (DEFAULT_COMPRESSION, false);\n+  }\n+\n+  public Deflater (int lvl)\n+  {\n+    this (lvl, false);\n+  }\n+\n+  public Deflater (int lvl, boolean noHeader)\n+  {\n+    this.strategy = DEFAULT_STRATEGY;\n+    init (lvl, noHeader);\n+    setLevel (lvl);\n+  }\n+\n+  public native void end ();\n+\n+  public void finalize ()\n+  {\n+    end ();\n+  }\n+\n+  public native void finish ();\n+\n+  public synchronized boolean finished ()\n+  {\n+    return is_finished;\n+  }\n+\n+  public native int getAdler ();\n+  public native int getTotalIn ();\n+  public native int getTotalOut ();\n+  public native boolean needsInput ();\n+  public native void reset ();\n+\n+  public void setDictionary (byte[] buf)\n+  {\n+    setDictionary (buf, 0, buf.length);\n+  }\n+\n+  public native void setDictionary (byte[] buf, int off, int len);\n+\n+  public void setInput (byte[] buf)\n+  {\n+    setInput (buf, 0, buf.length);\n+  }\n+\n+  public native void setInput (byte[] buf, int off, int len);\n+\n+  public synchronized void setLevel (int lvl)\n+  {\n+    if (lvl != -1 && (lvl < 0 || lvl > 9))\n+      throw new IllegalArgumentException ();\n+    level = (lvl == -1) ? 6 : lvl;\n+    update ();\n+  }\n+\n+  public synchronized void setStrategy (int stgy)\n+  {\n+    if (stgy != DEFAULT_STRATEGY && stgy != FILTERED\n+\t&& stgy != HUFFMAN_ONLY)\n+      throw new IllegalArgumentException ();\n+    strategy = stgy;\n+    update ();\n+  }\n+\n+  // Compression level.\n+  private int level;\n+\n+  // Compression strategy.\n+  private int strategy;\n+\n+  // The zlib stream.\n+  private RawData zstream;\n+\n+  // True if finished.\n+  private boolean is_finished;\n+\n+  // Total number of bytes made available at last setInput.\n+  private int last_input_count;\n+\n+  // `Flush' flag to pass to next call to deflate.\n+  private int flush_flag;\n }"}, {"sha": "ce5ae23101f2a75197bcaf644727a0e574bb0b7b", "filename": "libjava/java/util/zip/DeflaterOutputStream.java", "status": "modified", "additions": 53, "deletions": 12, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -1,3 +1,5 @@\n+// DeflaterOutputStream.java - Output filter for compressing.\n+\n /* Copyright (C) 1999  Cygnus Solutions\n \n    This file is part of libgcj.\n@@ -7,40 +9,79 @@\n details.  */\n \n package java.util.zip;\n-import java.io.*;\n \n-/** JUST AN INCOMPLETE STUB! */\n+import java.io.FilterOutputStream;\n+import java.io.OutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * @author Tom Tromey\n+ * @date May 17, 1999\n+ */\n+\n+/* Written using on-line Java Platform 1.2 API Specification\n+ * and JCL book.\n+ * Believed complete and correct.\n+ */\n \n public class DeflaterOutputStream extends FilterOutputStream\n {\n-  protected byte[] buf;\n+  public void close () throws IOException\n+  {\n+    finish ();\n+    out.close();\n+  }\n \n-  protected Deflater def;\n+  protected void deflate () throws IOException\n+  {\n+    while (true)\n+      {\n+\tint len = def.deflate(buf, 0, buf.length);\n+\tif (len == 0 || len == -1)\n+\t  break;\n+\tout.write(buf, 0, len);\n+      }\n+  }\n \n-  public DeflaterOutputStream(OutputStream out)\n+  public DeflaterOutputStream (OutputStream out)\n   {\n-    this(out, null, 512);\n+    this (out, new Deflater (), 512);\n   }\n \n-  public DeflaterOutputStream(OutputStream out, Deflater defl)\n+  public DeflaterOutputStream (OutputStream out, Deflater defl)\n   {\n-    this(out, defl, 512);\n+    this (out, defl, 512);\n   }\n \n   public DeflaterOutputStream(OutputStream out, Deflater defl, int bufsize)\n   {\n-    super(out);\n+    super (out);\n     buf = new byte[bufsize];\n     def = defl;\n   }\n \n   public void finish () throws IOException\n   {\n+    def.finish();\n+    deflate ();\n   }\n \n-  public void close () throws IOException\n+  public void write (int bval) throws IOException\n   {\n-    finish();\n-    out.close();\n+    byte[] b = new byte[1];\n+    b[0] = (byte) bval;\n+    write (b, 0, 1);\n+  }\n+\n+  public void write (byte[] buf, int off, int len) throws IOException\n+  {\n+    def.setInput (buf, off, len);\n+    deflate ();\n   }\n+\n+  // The retrieval buffer.\n+  protected byte[] buf;\n+\n+  // Deflater used to compress data.\n+  protected Deflater def;\n }"}, {"sha": "109ee82b1d21e77f8aafd63e4a7d445ae572b42f", "filename": "libjava/java/util/zip/GZIPInputStream.java", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FGZIPInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FGZIPInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FGZIPInputStream.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -0,0 +1,154 @@\n+// GZIPInputStream.java - Input tiler for reading gzip file.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.util.zip;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+/**\n+ * @author Tom Tromey\n+ * @date May 17, 1999\n+ */\n+\n+/* Written using on-line Java Platform 1.2 API Specification\n+ * and JCL book.\n+ * Believed complete and correct.\n+ */\n+\n+public class GZIPInputStream extends InflaterInputStream\n+{\n+  public static final int GZIP_MAGIC = 0x8b1f;\n+\n+  public void close () throws IOException\n+  {\n+    // Nothing to do here.\n+    super.close();\n+  }\n+\n+  public GZIPInputStream (InputStream istream) throws IOException\n+  {\n+    this (istream, 512);\n+  }\n+\n+  private final int eof_read () throws IOException\n+  {\n+    int r = in.read();\n+    if (r == -1)\n+      throw new ZipException (\"gzip header corrupted\");\n+    return r & 0xff;\n+  }\n+\n+  public GZIPInputStream (InputStream istream, int readsize)\n+    throws IOException\n+  {\n+    super (istream, new Inflater (true), readsize);\n+\n+    // NOTE: header reading code taken from zlib's gzio.c.\n+\n+    // Read the magic number.\n+    int magic = eof_read () | (eof_read () << 8);\n+    if (magic != GZIP_MAGIC)\n+      throw new ZipException (\"gzip header corrupted\");\n+\n+    int method = eof_read ();\n+    int flags = eof_read ();\n+    // Test from zlib.\n+    if (method != Z_DEFLATED || (flags & RESERVED) != 0)\n+      throw new ZipException (\"gzip header corrupted\");\n+\n+    // Discard time, xflags, OS code.\n+    for (int i = 0; i < 6; ++i)\n+      eof_read ();\n+\n+    // Skip the extra field.\n+    if ((flags & EXTRA_FIELD) != 0)\n+      {\n+\tint len = eof_read () | (eof_read () << 8);\n+\twhile (len-- != 0)\n+\t  eof_read ();\n+      }\n+\n+    if ((flags & ORIG_NAME) != 0)\n+      {\n+\twhile (true)\n+\t  {\n+\t    int c = eof_read ();\n+\t    if (c == 0)\n+\t      break;\n+\t  }\n+      }\n+\n+    if ((flags & COMMENT) != 0)\n+      {\n+\twhile (true)\n+\t  {\n+\t    int c = eof_read ();\n+\t    if (c == 0)\n+\t      break;\n+\t  }\n+      }\n+\n+    if ((flags & HEAD_CRC) != 0)\n+      {\n+\t// FIXME: consider checking CRC of the header.\n+\teof_read ();\n+\teof_read ();\n+      }\n+\n+    crc = new CRC32 ();\n+  }\n+\n+  public int read (byte[] buf, int off, int len) throws IOException\n+  {\n+    if (eos)\n+      return -1;\n+    int r = super.read(buf, off, len);\n+    if (r == -1)\n+      {\n+\teos = true;\n+\tint header_crc = read4 ();\n+\tif (crc.getValue() != header_crc)\n+\t  throw new ZipException (\"corrupted gzip file\");\n+\t// Read final `ISIZE' field.\n+\t// FIXME: should we check this length?\n+\tread4 ();\n+\treturn -1;\n+      }\n+    crc.update(buf, off, r);\n+    return r;\n+  }\n+\n+  private final int read4 () throws IOException\n+  {\n+    int byte0 = in.read();\n+    int byte1 = in.read();\n+    int byte2 = in.read();\n+    int byte3 = in.read();\n+    if (byte3 < 0)\n+      throw new ZipException (\".zip archive ended prematurely\");\n+    return ((byte3 & 0xFF) << 24) + ((byte2 & 0xFF) << 16)\n+      + ((byte1 & 0xFF) << 8) + (byte0 & 0xFF);\n+  }\n+\n+  // Checksum used by this input stream.\n+  protected CRC32 crc;\n+\n+  // Indicates whether end-of-stream has been reached.\n+  protected boolean eos;\n+\n+  // Some constants from zlib.\n+  static final int Z_DEFLATED = 8;\n+  static final int HEAD_CRC    = 0x02;\n+  static final int EXTRA_FIELD = 0x04;\n+  static final int ORIG_NAME   = 0x08;\n+  static final int COMMENT     = 0x10;\n+  static final int RESERVED    = 0xe0;\n+}"}, {"sha": "1d93fd17d0cac1c9320ceaa7f55d168a5f8cbd76", "filename": "libjava/java/util/zip/GZIPOutputStream.java", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FGZIPOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FGZIPOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FGZIPOutputStream.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -0,0 +1,88 @@\n+// GZIPOutputStream.java - Create a file in gzip format.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.util.zip;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/**\n+ * @author Tom Tromey\n+ * @date May 17, 1999\n+ */\n+\n+/* Written using on-line Java Platform 1.2 API Specification\n+ * and JCL book.\n+ * Believed complete and correct.\n+ */\n+\n+public class GZIPOutputStream extends DeflaterOutputStream\n+{\n+  public void close () throws IOException\n+  {\n+    finish ();\n+    out.close ();\n+  }\n+\n+  public void finish () throws IOException\n+  {\n+    super.finish();\n+    put4 ((int) crc.getValue());\n+    put4 (def.getTotalIn());\n+  }\n+\n+  public GZIPOutputStream (OutputStream out) throws IOException\n+  {\n+    this (out, 512);\n+  }\n+\n+  public GZIPOutputStream (OutputStream out, int readsize) throws IOException\n+  {\n+    super (out, new Deflater (Deflater.DEFAULT_COMPRESSION, true), readsize);\n+\n+    put2 (GZIPInputStream.GZIP_MAGIC);\n+    out.write (GZIPInputStream.Z_DEFLATED);\n+    // No flags for now.\n+    out.write (0);\n+    // No time either.\n+    put2 (0);\n+    put2 (0);\n+    // No xflags either.\n+    out.write (0);\n+    // FIXME: unknown OS.\n+    out.write (255);\n+\n+    crc = new CRC32 ();\n+  }\n+\n+  public synchronized void write (byte[] buf, int off, int len)\n+    throws IOException\n+  {\n+    super.write(buf, off, len);\n+    crc.update(buf, off, len);\n+  }\n+\n+  private final void put2 (int i) throws IOException\n+  {\n+    out.write (i);\n+    out.write (i >> 8);\n+  }\n+\n+  private final void put4 (int i) throws IOException\n+  {\n+    out.write (i);\n+    out.write (i >> 8);\n+    out.write (i >> 16);\n+    out.write (i >> 24);\n+  }\n+\n+  // Checksum used by this stream.\n+  protected CRC32 crc;\n+}"}, {"sha": "724b5b4a1b524a170f87f78d82f5348f6b714ab2", "filename": "libjava/java/util/zip/Inflater.java", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FInflater.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FInflater.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FInflater.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -0,0 +1,101 @@\n+// Inflater.java - Decompress a data stream.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.util.zip;\n+\n+import gnu.gcj.RawData;\n+\n+/**\n+ * @author Tom Tromey\n+ * @date May 17, 1999\n+ */\n+\n+/* Written using on-line Java Platform 1.2 API Specification\n+ * and JCL book.\n+ * Believed complete and correct.\n+ */\n+\n+public class Inflater\n+{\n+  public native void end ();\n+\n+  protected void finalize ()\n+  {\n+    end ();\n+  }\n+\n+  public synchronized boolean finished ()\n+  {\n+    return is_finished;\n+  }\n+\n+  public native int getAdler ();\n+  public native int getRemaining ();\n+  public native int getTotalIn ();\n+  public native int getTotalOut ();\n+\n+  public int inflate (byte[] buf) throws DataFormatException\n+  {\n+    return inflate (buf, 0, buf.length);\n+  }\n+\n+  public native int inflate (byte[] buf, int off, int len)\n+    throws DataFormatException;\n+\n+  private native void init (boolean noHeader);\n+\n+  public Inflater ()\n+  {\n+    this (false);\n+  }\n+\n+  public Inflater (boolean noHeader)\n+  {\n+    init (noHeader);\n+  }\n+\n+  public synchronized boolean needsDictionary ()\n+  {\n+    return dict_needed;\n+  }\n+\n+  public synchronized boolean needsInput ()\n+  {\n+    return getRemaining () == 0;\n+  }\n+\n+  public native void reset ();\n+\n+  public void setDictionary (byte[] buf)\n+  {\n+    setDictionary (buf, 0, buf.length);\n+  }\n+\n+  public native void setDictionary (byte[] buf, int off, int len);\n+\n+  public void setInput (byte[] buf)\n+  {\n+    setInput (buf, 0, buf.length);\n+  }\n+\n+  public native void setInput (byte[] buf, int off, int len);\n+\n+  // The zlib stream.\n+  private RawData zstream;\n+\n+  // True if finished.\n+  private boolean is_finished;\n+\n+  // True if dictionary needed.\n+  private boolean dict_needed;\n+\n+  // Total number of bytes made available at last setInput.\n+  private int last_input_count;\n+}"}, {"sha": "7ee445560f45517f7fc084d9d4451eb83a394972", "filename": "libjava/java/util/zip/InflaterInputStream.java", "status": "modified", "additions": 86, "deletions": 4, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -1,3 +1,5 @@\n+// InflaterInputStream.java - Input stream filter for decompressing.\n+\n /* Copyright (C) 1999  Cygnus Solutions\n \n    This file is part of libgcj.\n@@ -7,14 +9,94 @@\n details.  */\n \n package java.util.zip;\n-import java.io.*;\n \n-/** Placefolder - very incomplete. */\n+import java.io.FilterInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+/**\n+ * @author Tom Tromey\n+ * @date May 17, 1999\n+ */\n+\n+/* Written using on-line Java Platform 1.2 API Specification\n+ * and JCL book.\n+ * Believed complete and correct.\n+ */\n \n public class InflaterInputStream extends FilterInputStream\n {\n-  public InflaterInputStream(InputStream in)\n+  protected void fill () throws IOException\n+  {\n+    len = in.read(buf, 0, buf.length);\n+    if (len != -1)\n+      inf.setInput(buf, 0, len);\n+  }\n+\n+  public InflaterInputStream (InputStream in)\n+  {\n+    this (in, new Inflater (), 512);\n+  }\n+\n+  public InflaterInputStream (InputStream in, Inflater infl)\n   {\n-    super(in);\n+    this (in, infl, 512);\n   }\n+\n+  public InflaterInputStream (InputStream in, Inflater infl, int bufsize)\n+  {\n+    super (in);\n+    this.inf = infl;\n+    this.buf = new byte[bufsize];\n+  }\n+\n+  public int read () throws IOException\n+  {\n+    byte[] buf = new byte[1];\n+    int r = read (buf, 0, 1);\n+    if (r != -1)\n+      r = buf[0] & 0xff;\n+    return r;\n+  }\n+\n+  public int read (byte[] buf, int off, int len) throws IOException\n+  {\n+    if (inf.finished())\n+      return -1;\n+    if (inf.needsInput())\n+      fill ();\n+    if (inf.needsDictionary())\n+      return -1;\n+    return inf.inflate(buf, off, len);\n+  }\n+\n+  public long skip (long n) throws IOException\n+  {\n+    if (n == 0)\n+      return 0;\n+\n+    int min = (int) Math.min(n, 1024);\n+    byte[] buf = new byte[min];\n+\n+    long s = 0;\n+    while (n > 0)\n+      {\n+\tint r = read (buf, 0, min);\n+\tif (r == -1)\n+\t  break;\n+\tn -= r;\n+\ts += r;\n+      }\n+\n+    return s;\n+  }\n+\n+  // Buffer for delivering uncompressed data to inflater.\n+  protected byte[] buf;\n+\n+  // Inflater used to decompress data.\n+  protected Inflater inf;\n+\n+  // Number of read bytes in buf.\n+  protected int len;\n }"}, {"sha": "7035ab500748690143cf449d051317adc7731602", "filename": "libjava/java/util/zip/ZipEntry.java", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -39,6 +39,10 @@\n \n   public ZipEntry (String name)\n   {\n+    if (name == null)\n+      throw new NullPointerException ();\n+    if (name.length() > 65535)\n+      throw new IllegalArgumentException ();\n     this.name = name;\n   }\n \n@@ -69,17 +73,45 @@ public boolean isDirectory ()\n     return false;\n   }\n \n-  public void setComment (String comment) { this.comment = comment; }\n+  public void setComment (String comment)\n+  {\n+    if (comment != null && comment.length() > 65535)\n+      throw new IllegalArgumentException ();\n+    this.comment = comment;\n+  }\n \n-  public void setCrc (long crc) { this.crc = crc; }\n+  public void setCrc (long crc) \n+  {\n+    if (crc < 0 || crc > 0xffffffff)\n+      throw new IllegalArgumentException ();\n+    this.crc = crc;\n+  }\n \n-  public void setExtra (byte[] extra) { this.extra = extra; }\n+  public void setExtra (byte[] extra)\n+  {\n+    if (extra != null && extra.length > 65535)\n+      throw new IllegalArgumentException ();\n+    this.extra = extra;\n+  }\n \n-  public void setMethod(int method) { this.method = method; }\n+  public void setMethod (int method)\n+  {\n+    if (method != DEFLATED && method != STORED)\n+      throw new IllegalArgumentException ();\n+    this.method = method;\n+  }\n \n-  public void setSize (long size) { this.size = size; }\n+  public void setSize (long size)\n+  {\n+    if (size < 0 || size > 0xffffffff)\n+      throw new IllegalArgumentException ();\n+    this.size = size;\n+  }\n \n-  public void setTime (long time) { this.time = time; }\n+  public void setTime (long time)\n+  {\n+    this.time = time;\n+  }\n \n   private final static short[] daysToMonthStart = {\n     //Jan Feb Mar    Apr      May         Jun         Jul"}, {"sha": "bfb077d45859e9421f2192cd2357614a24c0ca11", "filename": "libjava/java/util/zip/ZipFile.java", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -1,3 +1,5 @@\n+// ZipFile.java - Read contents of a ZIP file.\n+\n /* Copyright (C) 1999  Cygnus Solutions\n \n    This file is part of libgcj.\n@@ -9,16 +11,13 @@\n package java.util.zip;\n import java.io.*;\n \n-/** UNFINISHED, but can read non-comrepssed .zip archives. */\n+/* Written using on-line Java Platform 1.2 API Specification\n+ * and JCL book.\n+ * Believed complete and correct.\n+ */\n \n public class ZipFile implements ZipConstants\n {\n-\n-  ZipEntry entries;\n-  int numEntries;\n-  RandomAccessFile file;\n-  String name;\n-\n   public ZipFile (String fname) throws IOException\n   {\n     file = new RandomAccessFile(fname, \"r\");\n@@ -35,7 +34,7 @@ void readDirectory () throws IOException\n   {\n     long size = file.length ();\n     if (size < ZipConstants.END_CENTRAL_DIR_SIZE)\n-      throw new IOException (\"zipfile too short\");\n+      throw new ZipException (\"zipfile too short\");\n     // We do not handle a \"zipfile comment\", which the appnote says can\n     // be at the end of a .zip file.  We could handle this by seeking\n     // to the beginning and reading forwards.\n@@ -44,7 +43,7 @@ void readDirectory () throws IOException\n \t|| file.read() != 'K'\n \t|| file.read() != '\\005'\n \t|| file.read() != '\\006')\n-      throw new IOException(\"not a valid zipfile\");\n+      throw new ZipException(\"not a valid zipfile\");\n     file.skipBytes(6);\n     numEntries = readu2();\n     int dir_size = read4 ();  // Read \"size of the central directory\".\n@@ -103,7 +102,6 @@ public java.util.Enumeration entries()\n \n   public void close() throws IOException\n   {\n-    //  FIXME - check this\n     file.close();\n     entries = null;\n     numEntries = 0;\n@@ -121,14 +119,17 @@ public ZipEntry getEntry(String name)\n \n   public InputStream getInputStream(ZipEntry ze)  throws IOException\n   {\n-    // FIXME - does not handle compression!\n     byte[] buffer = new byte[(int) ze.getSize()];\n     int data_offset = ZipConstants.LOCAL_FILE_HEADER_SIZE + name.length();\n     if (ze.extra != null)\n       data_offset += ze.extra.length;\n     file.seek(ze.relativeOffset + data_offset);\n     file.readFully(buffer);\n-    return new ByteArrayInputStream(buffer);\n+\n+    InputStream is = new ByteArrayInputStream (buffer);\n+    if (ze.getMethod() == ZipEntry.DEFLATED)\n+      is = new InflaterInputStream (is);\n+    return is;\n   }\n \n   public String getName () { return name; }\n@@ -138,7 +139,7 @@ private int readu2 () throws IOException\n     int byte0 = file.read();\n     int byte1 = file.read();\n     if (byte0 < 0 || byte1 < 0)\n-      throw new EOFException(\".zip archive ended prematurely\");\n+      throw new ZipException (\".zip archive ended prematurely\");\n     return ((byte1 & 0xFF) << 8) | (byte0 & 0xFF);\n   }\n \n@@ -149,10 +150,15 @@ private int read4 () throws IOException\n     int byte2 = file.read();\n     int byte3 = file.read();\n     if (byte3 < 0)\n-      throw new EOFException(\".zip archive ended prematurely\");\n+      throw new ZipException (\".zip archive ended prematurely\");\n     return ((byte3 & 0xFF) << 24) + ((byte2 & 0xFF) << 16)\n       + ((byte1 & 0xFF) << 8) + (byte0 & 0xFF);\n   }\n+\n+  ZipEntry entries;\n+  int numEntries;\n+  RandomAccessFile file;\n+  String name;\n }\n \n class ZipEnumeration implements java.util.Enumeration"}, {"sha": "f2e042b8fafee988c72bd12435784dffa3688701", "filename": "libjava/java/util/zip/ZipInputStream.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -168,14 +168,14 @@ public void closeZipEntry ()  throws IOException\n \t  {\n \t    int sig = read4();\n \t    if (sig != 0x04034b50)\n-\t      throw new IOException(\"bad/missing magic number at end of .zip entry\");\n+\t      throw new ZipException(\"bad/missing magic number at end of .zip entry\");\n \t    int crc = read4();\n \t    int compressedSize = read4();\n \t    int uncompressedSize = read4();\n \t    if (current.compressedSize != compressedSize\n \t\t|| current.size != uncompressedSize\n \t\t|| current.crc != crc)\n-\t      throw new IOException(\"bad data descriptor at end of .zip entry\");\n+\t      throw new ZipException(\"bad data descriptor at end of .zip entry\");\n \t  }\n \tcurrent = null;\n \tavail = 0;"}, {"sha": "f4ce7accc0104023467105e1e362f9e4d12c9778", "filename": "libjava/java/util/zip/ZipOutputStream.java", "status": "modified", "additions": 233, "deletions": 30, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FZipOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FZipOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipOutputStream.java?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -9,65 +9,268 @@\n package java.util.zip;\n import java.io.*;\n \n-/** JUST AN INCOMPLETE STUB! */\n+/* Written using on-line Java Platform 1.2 API Specification\n+ * and JCL book.\n+ * Believed complete and correct.\n+ */\n \n public class ZipOutputStream extends DeflaterOutputStream\n   implements ZipConstants\n {\n-  ZipEntry current;\n-  int method = DEFLATED;\n-  int level = 3;  // FIXME - should be DEFAULT_COMPRESSION\n-  String comment;\n-\n   public static final int STORED = 0;\n   public static final int DEFLATED = 8;\n \n-  public ZipOutputStream (OutputStream out)\n+  public void close () throws IOException\n   {\n-    super(out);\n+    finish ();\n+    out.close();\n+  }\n+\n+  public void closeEntry ()  throws IOException\n+  {\n+    int uncompressed_size = def.getTotalIn();\n+    int compressed_size = def.getTotalOut();\n+    int crc = (int) (filter.getChecksum().getValue());\n+\n+    bytes_written += compressed_size;\n+\n+    bytes_written += put4 (0x08074b50);\n+    if (current.getCrc() == -1 || current.getCompressedSize() == -1\n+\t|| current.getSize() == -1)\n+      {\n+\tcurrent.setCrc(crc);\n+\tcurrent.compressedSize = compressed_size;\n+\tcurrent.setSize(uncompressed_size);\n+      }\n+    else\n+      {\n+\tif (current.getCrc() != crc\n+\t    || current.getCompressedSize() != compressed_size\n+\t    || current.getSize() != uncompressed_size)\n+\t  throw new ZipException (\"zip entry field incorrect\");\n+      }\n+    bytes_written += put4 ((int) (current.getCrc()));\n+    bytes_written += put4 ((int) (current.getCompressedSize()));\n+    bytes_written += put4 ((int) (current.getSize()));\n+\n+    current.next = chain;\n+    chain = current;\n+    current = null;\n+    filter = null;\n+  }\n+\n+  public void finish () throws IOException\n+  {\n+    if (current != null)\n+      closeEntry ();\n+\n+    // Write the central directory.\n+    long offset = bytes_written;\n+    int count = 0;\n+    int bytes = 0;\n+    while (chain != null)\n+      {\n+\tbytes += write_entry (chain, false);\n+\t++count;\n+\tchain = chain.next;\n+      }\n+\n+    // Write the end of the central directory record.\n+    put4 (0x06054b50);\n+    // Disk number.\n+    put2 (0);\n+    // Another disk number.\n+    put2 (0);\n+    put2 (count);\n+    put4 (bytes);\n+    put4 ((int) offset);\n+\n+    byte[] c = comment.getBytes(\"8859_1\");\n+    put2 (c.length);\n+    out.write(c);\n+    out.write((byte) 0);\n   }\n \n-  public void setLevel (int level) { this.level = level; }\n-  public void setMethod (int method) { this.method = method; }\n-  public void setComment(String comment) { this.comment = comment; }\n+  // Helper for finish and putNextEntry.\n+  private int write_entry (ZipEntry entry, boolean is_local)\n+    throws IOException\n+  {\n+    long offset = bytes_written;\n+\n+    int bytes = put4 (is_local ? 0x04034b50 : 0x02014b50);\n+    if (! is_local)\n+      bytes += put_version ();\n+    bytes += put_version ();\n+\n+    boolean crc_after = false;\n+    if (is_local\n+\t&& (current.getCrc() == -1 || current.getCompressedSize() == -1\n+\t    || current.getSize() == -1))\n+      crc_after = true;\n+    // For the bits field we always indicate `normal' compression,\n+    // even if that isn't true.\n+    bytes += put2 (crc_after ? (1 << 3) : 0);\n+    bytes += put2 (entry.method);\n+\n+    bytes += put2(0);  // time - FIXME\n+    bytes += put2(0);  // date - FIXME\n+\n+    if (crc_after)\n+      {\n+\t// CRC, compressedSize, and Size are always 0 in this header.\n+\t// The actual values are given after the entry.\n+\tbytes += put4 (0);\n+\tbytes += put4 (0);\n+\tbytes += put4 (0);\n+      }\n+    else\n+      {\n+\tbytes += put4 ((int) (entry.getCrc()));\n+\tbytes += put4 ((int) (entry.getCompressedSize()));\n+\tbytes += put4 ((int) (entry.getSize()));\n+      }\n+\n+    byte[] name = entry.name.getBytes(\"8859_1\");\n+    bytes += put2 (name.length);\n+    bytes += put2 (entry.extra == null ? 0 : entry.extra.length);\n+\n+    byte[] comment = null;\n+    if (! is_local)\n+      {\n+\tif (entry.getComment() == null)\n+\t  bytes += put2 (0);\n+\telse\n+\t  {\n+\t    comment = entry.getComment().getBytes(\"8859_1\");\n+\t    bytes += put2 (comment.length);\n+\t  }\n+\n+\t// Disk number start.\n+\tbytes += put2 (0);\n+\t// Internal file attributes.\n+\tbytes += put2 (0);\n+\t// External file attributes.\n+\tbytes += put2 (0);\n+\t// Relative offset of local header.\n+\tbytes += put2 ((int) offset);\n+      }\n+\n+    out.write (name);\n+    out.write ((byte) 0);\n+    bytes += name.length + 1;\n+    if (entry.extra != null)\n+      {\n+\tout.write(entry.extra);\n+\tout.write((byte) 0);\n+\tbytes += entry.extra.length + 1;\n+      }\n+    if (comment != null)\n+      {\n+\tout.write(comment);\n+\tout.write((byte) 0);\n+\tbytes += comment.length + 1;\n+      }\n+\n+    bytes_written += bytes;\n+    return bytes;\n+  }\n \n   public void putNextEntry (ZipEntry entry) throws IOException\n   {\n-    put4(0x04034b50);\n-    put2(0);  // version - FIXME\n-    put2(0);  // bits - FIXME\n+    if (current != null)\n+      closeEntry ();\n+\n     if (entry.method < 0 )\n       entry.method = method;\n-    put2(entry.method);\n-    put2(0);  // time - FIXME\n-    put2(0);  // date - FIXME\n-    put4((int) entry.crc);\n-    put4((int) entry.compressedSize); // FIXME\n-    put4((int) entry.size); // FIXME\n-    put2(entry.name.length());\n-    put2(entry.extra == null ? 0 : entry.extra.length);\n-    byte[] name = entry.name.getBytes(\"8859_1\");\n-    out.write(name);\n-    if (entry.extra != null)\n-      out.write(entry.extra);\n-    throw new Error (\"java.util.zip.ZipOutputStream.putNextEntry:  not implemented\");\n+    if (entry.method == STORED)\n+      {\n+\tif (entry.getSize() == -1 || entry.getCrc() == -1)\n+\t  throw new ZipException (\"required entry not set\");\n+\t// Just in case.\n+\tentry.compressedSize = entry.getSize();\n+      }\n+    write_entry (entry, true);\n+    current = entry;\n+    int compr = (method == STORED) ? Deflater.NO_COMPRESSION : level;\n+    def.reset();\n+    def.setLevel(compr);\n+    filter = new CheckedOutputStream (new DeflaterOutputStream (out, def),\n+\t\t\t\t      new CRC32 ());\n   }\n \n-  public void closeEntry ()  throws IOException\n+  public void setLevel (int level)\n   {\n+    if (level != Deflater.DEFAULT_COMPRESSION\n+\t&& (level < Deflater.NO_COMPRESSION\n+\t    || level > Deflater.BEST_COMPRESSION))\n+      throw new IllegalArgumentException ();\n+    this.level = level;\n   }\n \n-  private void put2 (int i)  throws IOException\n+  public void setMethod (int method)\n+  {\n+    if (method != DEFLATED && method != STORED)\n+      throw new IllegalArgumentException ();\n+    this.method = method;\n+  }\n+\n+  public void setComment (String comment)\n+  {\n+    if (comment.length() > 65535)\n+      throw new IllegalArgumentException ();\n+    this.comment = comment;\n+  }\n+\n+  public synchronized void write (byte[] buf, int off, int len)\n+    throws IOException\n+  {\n+    if (filter == null)\n+      throw new ZipException (\"no open zip entry\");\n+    filter.write(buf, off, len);\n+  }\n+\n+  public ZipOutputStream (OutputStream out)\n+  {\n+    super (out);\n+    def = new Deflater (level, true);\n+  }\n+\n+  private int put2 (int i) throws IOException\n   {\n     out.write (i);\n     out.write (i >> 8);\n+    return 2;\n   }\n \n-  private void put4 (int i)  throws IOException\n+  private int put4 (int i) throws IOException\n   {\n     out.write (i);\n     out.write (i >> 8);\n     out.write (i >> 16);\n     out.write (i >> 24);\n+    return 4;\n   }\n+\n+  private int put_version () throws IOException\n+  {\n+    // FIXME: for now we assume Unix, and we ignore the version\n+    // number.\n+    return put2 (3 << 8);\n+  }\n+\n+  // The entry we are currently writing, or null if we've called\n+  // closeEntry.\n+  private ZipEntry current;\n+  // The chain of entries which have been written to this file.\n+  private ZipEntry chain;\n+  // The output stream to which data should be sent.\n+  private CheckedOutputStream filter;\n+\n+  private int method = DEFLATED;\n+  private int level = Deflater.DEFAULT_COMPRESSION;\n+  private String comment = \"\";\n+  private long bytes_written;\n+\n+  // The Deflater we use.\n+  private Deflater def;\n }"}, {"sha": "07cf009454fdc9957feb0e2e4d52a2b2436598fc", "filename": "libjava/java/util/zip/natDeflater.cc", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FnatDeflater.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FnatDeflater.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FnatDeflater.cc?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -0,0 +1,209 @@\n+// natDeflater.cc - Implementation of Deflater native methods.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// Written by Tom Tromey <tromey@cygnus.com>\n+\n+#include <config.h>\n+\n+#include <zlib.h>\n+\n+#include <cni.h>\n+#include <jvm.h>\n+\n+#include <java/util/zip/Deflater.h>\n+#include <java/util/zip/DataFormatException.h>\n+\n+#include <java/lang/InternalError.h>\n+#include <java/lang/NullPointerException.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+\n+extern void *_Jv_ZMalloc (void *, uInt nitems, uInt size);\n+extern void _Jv_ZFree (void *, void *addr);\n+\n+\f\n+\n+jint\n+java::util::zip::Deflater::deflate (jbyteArray buf, jint off, jint len)\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+\n+  if (! buf)\n+    _Jv_Throw (new java::lang::NullPointerException);\n+  if (off < 0 || len < 0 || off + len > buf->length)\n+    _Jv_Throw (new java::lang::ArrayIndexOutOfBoundsException);\n+\n+  s->next_out = (Bytef *) (elements (buf) + off);\n+  s->avail_out = len;\n+\n+  switch (::deflate (s, flush_flag))\n+    {\n+    case Z_STREAM_END:\n+      is_finished = true;\n+      if (s->avail_out == len)\n+\treturn -1;\n+      break;\n+\n+    case Z_STREAM_ERROR:\n+    case Z_BUF_ERROR:\n+      // FIXME?\n+      _Jv_Throw (new java::lang::InternalError);\n+      break;\n+\n+    case Z_OK:\n+      break;\n+    }\n+\n+  return len - s->avail_out;\n+}\n+\n+void\n+java::util::zip::Deflater::end ()\n+{\n+  JvSynchronize sync (this);\n+  // Just ignore errors.\n+  deflateEnd ((z_streamp) zstream);\n+  _Jv_Free (zstream);\n+  zstream = NULL;\n+}\n+\n+void\n+java::util::zip::Deflater::finish ()\n+{\n+  JvSynchronize sync (this);\n+  flush_flag = Z_FINISH;\n+}\n+\n+jint\n+java::util::zip::Deflater::getAdler ()\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+  return s->adler;\n+}\n+\n+jint\n+java::util::zip::Deflater::getTotalIn ()\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+  return s->total_in;\n+}\n+\n+jint\n+java::util::zip::Deflater::getTotalOut ()\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+  return s->total_out;\n+}\n+\n+jboolean\n+java::util::zip::Deflater::needsInput ()\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+  return s->avail_in - last_input_count == 0;\n+}\n+\n+void\n+java::util::zip::Deflater::reset ()\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+  // Just ignore errors.\n+  deflateReset (s);\n+  flush_flag = 0;\n+}\n+\n+void\n+java::util::zip::Deflater::setDictionary (jbyteArray buf, jint off, jint len)\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+\n+  if (! buf)\n+    _Jv_Throw (new java::lang::NullPointerException);\n+  if (off < 0 || len < 0 || off + len > buf->length)\n+    _Jv_Throw (new java::lang::ArrayIndexOutOfBoundsException);\n+\n+  // Ignore errors.\n+  deflateSetDictionary (s, (Bytef *) (elements (buf) + off), len);\n+}\n+\n+void\n+java::util::zip::Deflater::setInput (jbyteArray buf, jint off, jint len)\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+\n+  if (! buf)\n+    _Jv_Throw (new java::lang::NullPointerException);\n+  if (off < 0 || len < 0 || off + len > buf->length)\n+    _Jv_Throw (new java::lang::ArrayIndexOutOfBoundsException);\n+\n+  last_input_count = len;\n+  s->next_in = (Bytef *) (elements (buf) + off);\n+  s->avail_in = len;\n+}\n+\n+void\n+java::util::zip::Deflater::update ()\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+\n+  int strat;\n+  switch (strategy)\n+    {\n+    case DEFAULT_STRATEGY:\n+      strat = Z_DEFAULT_STRATEGY;\n+      break;\n+    case FILTERED:\n+      strat = Z_FILTERED;\n+      break;\n+    case HUFFMAN_ONLY:\n+      strat = Z_HUFFMAN_ONLY;\n+      break;\n+    }\n+\n+  // Ignore errors.\n+  deflateParams (s, level, strat);\n+}\n+\n+void\n+java::util::zip::Deflater::init (jint level, jboolean no_header)\n+{\n+  z_stream_s *stream = (z_stream_s *) _Jv_Malloc (sizeof (z_stream_s));\n+  stream->next_in = Z_NULL;\n+  stream->avail_in = 0;\n+  stream->zalloc = _Jv_ZMalloc;\n+  stream->zfree = _Jv_ZFree;\n+  stream->opaque = NULL;\n+\n+  // Handle NO_HEADER using undocumented zlib feature.\n+  int wbits = MAX_WBITS;\n+  if (no_header)\n+    wbits = - wbits;\n+\n+#define DEFAULT_MEM_LEVEL 8\n+  if (deflateInit2 (stream, level, Z_DEFLATED, wbits,\n+\t\t    DEFAULT_MEM_LEVEL, Z_DEFAULT_STRATEGY) != Z_OK)\n+    {\n+      jstring msg = NULL;\n+      if (stream->msg != NULL)\n+\tmsg = JvNewStringLatin1 (stream->msg);\n+      _Jv_Throw (new java::lang::InternalError (msg));\n+    }\n+\n+  zstream = reinterpret_cast<gnu::gcj::RawData *> (stream);\n+  is_finished = false;\n+  flush_flag = 0;\n+}"}, {"sha": "b33ab50747f15142db20d7e532170c9caad35fb0", "filename": "libjava/java/util/zip/natInflater.cc", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FnatInflater.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffac8322f8825c0d696d9c700b0d0f1a395d11a/libjava%2Fjava%2Futil%2Fzip%2FnatInflater.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FnatInflater.cc?ref=0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "patch": "@@ -0,0 +1,202 @@\n+// natInflater.cc - Implementation of Inflater native methods.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// Written by Tom Tromey <tromey@cygnus.com>\n+\n+#include <config.h>\n+\n+#include <zlib.h>\n+\n+#include <cni.h>\n+#include <jvm.h>\n+\n+#include <java/util/zip/Inflater.h>\n+#include <java/util/zip/DataFormatException.h>\n+\n+#include <java/lang/InternalError.h>\n+#include <java/lang/NullPointerException.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/OutOfMemoryError.h>\n+\n+\f\n+\n+// A couple of helper functions used to interface with zlib's\n+// allocation.\n+\n+void *\n+_Jv_ZMalloc (void *, uInt nitems, uInt size)\n+{\n+  return _Jv_Malloc (nitems * size);\n+}\n+\n+void\n+_Jv_ZFree (void *, void *addr)\n+{\n+  _Jv_Free (addr);\n+}\n+\n+\f\n+\n+void\n+java::util::zip::Inflater::end ()\n+{\n+  JvSynchronize sync (this);\n+  // Just ignore errors.\n+  inflateEnd ((z_streamp) zstream);\n+  _Jv_Free (zstream);\n+  zstream = NULL;\n+}\n+\n+jint\n+java::util::zip::Inflater::getAdler ()\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+  return s->adler;\n+}\n+\n+jint\n+java::util::zip::Inflater::getRemaining ()\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+  return s->avail_in - last_input_count;\n+}\n+\n+jint\n+java::util::zip::Inflater::getTotalIn ()\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+  return s->total_in;\n+}\n+\n+jint\n+java::util::zip::Inflater::getTotalOut ()\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+  return s->total_out;\n+}\n+\n+jint\n+java::util::zip::Inflater::inflate (jbyteArray buf, jint off, jint len)\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+\n+  if (! buf)\n+    _Jv_Throw (new java::lang::NullPointerException);\n+  if (off < 0 || len < 0 || off + len > buf->length)\n+    _Jv_Throw (new java::lang::ArrayIndexOutOfBoundsException);\n+\n+  s->next_out = (Bytef *) (elements (buf) + off);\n+  s->avail_out = len;\n+\n+  switch (::inflate (s, Z_SYNC_FLUSH))\n+    {\n+    case Z_STREAM_END:\n+      is_finished = true;\n+      if (s->avail_out == len)\n+\treturn -1;\n+      break;\n+\n+    case Z_NEED_DICT:\n+      dict_needed = true;\n+      break;\n+\n+    case Z_DATA_ERROR:\n+      _Jv_Throw (new java::util::zip::DataFormatException);\n+      break;\n+\n+    case Z_MEM_ERROR:\n+      _Jv_Throw (new java::lang::OutOfMemoryError);\n+      break;\n+\n+    case Z_BUF_ERROR:\n+      // FIXME?\n+      _Jv_Throw (new java::lang::InternalError);\n+      break;\n+\n+    case Z_OK:\n+      break;\n+    }\n+\n+  return len - s->avail_out;\n+}\n+\n+void\n+java::util::zip::Inflater::reset ()\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+  // Just ignore errors.\n+  inflateReset (s);\n+}\n+\n+void\n+java::util::zip::Inflater::setDictionary (jbyteArray buf, jint off, jint len)\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+\n+  if (! buf)\n+    _Jv_Throw (new java::lang::NullPointerException);\n+  if (off < 0 || len < 0 || off + len > buf->length)\n+    _Jv_Throw (new java::lang::ArrayIndexOutOfBoundsException);\n+\n+  // Ignore errors.\n+  inflateSetDictionary (s, (Bytef *) (elements (buf) + off), len);\n+  dict_needed = false;\n+}\n+\n+void\n+java::util::zip::Inflater::setInput (jbyteArray buf, jint off, jint len)\n+{\n+  JvSynchronize sync (this);\n+  z_streamp s = (z_streamp) zstream;\n+\n+  if (! buf)\n+    _Jv_Throw (new java::lang::NullPointerException);\n+  if (off < 0 || len < 0 || off + len > buf->length)\n+    _Jv_Throw (new java::lang::ArrayIndexOutOfBoundsException);\n+\n+  last_input_count = len;\n+  s->next_in = (Bytef *) (elements (buf) + off);\n+  s->avail_in = len;\n+}\n+\n+void\n+java::util::zip::Inflater::init (jboolean no_header)\n+{\n+  z_stream_s *stream = (z_stream_s *) _Jv_Malloc (sizeof (z_stream_s));\n+  stream->next_in = Z_NULL;\n+  stream->avail_in = 0;\n+  stream->zalloc = _Jv_ZMalloc;\n+  stream->zfree = _Jv_ZFree;\n+  stream->opaque = NULL;\n+\n+  // Handle NO_HEADER using undocumented zlib feature.\n+  int wbits = MAX_WBITS;\n+  if (no_header)\n+    wbits = - wbits;\n+\n+  if (inflateInit2 (stream, wbits) != Z_OK)\n+    {\n+      jstring msg = NULL;\n+      if (stream->msg != NULL)\n+\tmsg = JvNewStringLatin1 (stream->msg);\n+      _Jv_Throw (new java::lang::InternalError (msg));\n+    }\n+\n+  zstream = reinterpret_cast<gnu::gcj::RawData *> (stream);\n+  is_finished = false;\n+  dict_needed = false;\n+}"}]}