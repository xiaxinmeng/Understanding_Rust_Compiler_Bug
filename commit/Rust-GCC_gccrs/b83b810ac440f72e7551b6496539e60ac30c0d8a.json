{"sha": "b83b810ac440f72e7551b6496539e60ac30c0d8a", "node_id": "C_kwDOANBUbNoAKGI4M2I4MTBhYzQ0MGY3MmU3NTUxYjY0OTY1MzllNjBhYzMwYzBkOGE", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-13T16:19:57Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-13T19:36:51Z"}, "message": "libstdc++: Refactor filesystem::path encoding conversions\n\nAdjust the __detail::__effective_range overloads so they always return a\nstring or string view using std::char_traits, because we don't care\nabout the traits of an incoming string.\n\nUse std::contiguous_iterator in the __effective_range(const Source&)\noverload, to allow returning a basic_string_view in more cases. For the\nnon-contiguous casecl in both __effective_range and __string_from_range,\nreturn a std::string instead of std::u8string when the value type of the\nrange is char8_t.  These changes avoid unnecessary basic_string\ntemporaries.\n\nAlso simplify __string_from_range(Iter, Iter) to not need\nstd::__to_address for the contiguous case.\n\nCombine the _S_convert(string_type) and _S_convert(const T&) overloads\ninto a single _S_convert(T) function which also avoids the dangling\nview problem of PR 102592 (should that recur somehow).\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/fs_path.h (__detail::__is_contiguous): New\n\tvariable template to identify contiguous iterators.\n\t(__detail::__unified_char8_t): New alias template to decide when\n\tto treat char8_t as char without encoding conversion.\n\t(__detail::__effective_range(const basic_string<C,T>&)): Use\n\tstd::char_traits<C> for returned string view.\n\t(__detail::__effective_range(const basic_string_view<C,T>&)):\n\tLikewise.\n\t(__detail::__effective_range(const Source&)): Use\n\t__is_contiguous to detect mode cases of contiguous iterators.\n\tUse __unified_char8_t to return a std::string instead of\n\tstd::u8string.", "tree": {"sha": "2fdc3a35cdac161449a892500a4ada7a73c10927", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fdc3a35cdac161449a892500a4ada7a73c10927"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b83b810ac440f72e7551b6496539e60ac30c0d8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b83b810ac440f72e7551b6496539e60ac30c0d8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b83b810ac440f72e7551b6496539e60ac30c0d8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b83b810ac440f72e7551b6496539e60ac30c0d8a/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85b24e32dc27ec2e70b853713e0713cbc1ff08c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b24e32dc27ec2e70b853713e0713cbc1ff08c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b24e32dc27ec2e70b853713e0713cbc1ff08c3"}], "stats": {"total": 126, "additions": 81, "deletions": 45}, "files": [{"sha": "05db792fbaec07cffe44032ebdb7106a93734d47", "filename": "libstdc++-v3/include/bits/fs_path.h", "status": "modified", "additions": 81, "deletions": 45, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b83b810ac440f72e7551b6496539e60ac30c0d8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b83b810ac440f72e7551b6496539e60ac30c0d8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h?ref=b83b810ac440f72e7551b6496539e60ac30c0d8a", "patch": "@@ -153,33 +153,56 @@ namespace __detail\n   template<typename _Iter, typename _Tr = __safe_iterator_traits<_Iter>>\n     using _Path2 = enable_if_t<__is_path_iter_src<_Tr>::value, path>;\n \n+#if __cpp_lib_concepts\n+  template<typename _Iter>\n+    constexpr bool __is_contiguous = std::contiguous_iterator<_Iter>;\n+#else\n+  template<typename _Iter>\n+    constexpr bool __is_contiguous = is_pointer_v<_Iter>;\n+#endif\n+\n+#if !defined _GLIBCXX_FILESYSTEM_IS_WINDOWS && defined _GLIBCXX_USE_CHAR8_T\n+  // For POSIX treat char8_t sequences as char without encoding conversions.\n+  template<typename _EcharT>\n+    using __unified_u8_t\n+      = __conditional_t<is_same_v<_EcharT, char8_t>, char, _EcharT>;\n+#else\n+  template<typename _EcharT>\n+    using __unified_u8_t = _EcharT;\n+#endif\n+\n   // The __effective_range overloads convert a Source parameter into\n-  // either a basic_string_view or basic_string containing the\n+  // either a basic_string_view<C> or basic_string<C> containing the\n   // effective range of the Source, as defined in [fs.path.req].\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n-    inline basic_string_view<_CharT, _Traits>\n+    inline basic_string_view<_CharT>\n     __effective_range(const basic_string<_CharT, _Traits, _Alloc>& __source)\n+    noexcept\n     { return __source; }\n \n   template<typename _CharT, typename _Traits>\n-    inline const basic_string_view<_CharT, _Traits>&\n+    inline basic_string_view<_CharT>\n     __effective_range(const basic_string_view<_CharT, _Traits>& __source)\n+    noexcept\n     { return __source; }\n \n+  // Return the effective range of an NTCTS.\n   template<typename _Source>\n-    inline auto\n+    auto\n     __effective_range(const _Source& __source)\n     {\n-      if constexpr (is_pointer_v<decay_t<_Source>>)\n-\treturn basic_string_view{&*__source};\n+      // Remove a level of normal/safe iterator indirection, or decay an array.\n+      using _Iter = decltype(std::__niter_base(__source));\n+      using value_type = typename iterator_traits<_Iter>::value_type;\n+\n+      if constexpr (__is_contiguous<_Iter>)\n+\treturn basic_string_view<value_type>{&*__source};\n       else\n \t{\n \t  // _Source is an input iterator that iterates over an NTCTS.\n \t  // Create a basic_string by reading until the null character.\n-\t  using value_type\n-\t    = typename iterator_traits<_Source>::value_type;\n-\t  basic_string<value_type> __str;\n+\t  basic_string<__unified_u8_t<value_type>> __str;\n \t  _Source __it = __source;\n \t  for (value_type __ch = *__it; __ch != value_type(); __ch = *++__it)\n \t    __str.push_back(__ch);\n@@ -188,52 +211,67 @@ namespace __detail\n     }\n \n   // The value type of a Source parameter's effective range.\n-  template<typename _Tp>\n-    using __value_t = typename remove_reference_t<\n-      decltype(__detail::__effective_range(std::declval<_Tp>()))>::value_type;\n+  template<typename _Source>\n+    struct __source_value_type_impl\n+    {\n+      using type\n+\t= typename __safe_iterator_traits<decay_t<_Source>>::value_type;\n+    };\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    struct __source_value_type_impl<basic_string<_CharT, _Traits, _Alloc>>\n+    {\n+      using type = _CharT;\n+    };\n+\n+  template<typename _CharT, typename _Traits>\n+    struct __source_value_type_impl<basic_string_view<_CharT, _Traits>>\n+    {\n+      using type = _CharT;\n+    };\n+\n+  // The value type of a Source parameter's effective range.\n+  template<typename _Source>\n+    using __source_value_t = typename __source_value_type_impl<_Source>::type;\n \n   // SFINAE helper to check that an effective range has value_type char,\n   // as required by path constructors taking a std::locale parameter.\n   // The type _Tp must have already been checked by _Path<Tp> or _Path2<_Tp>.\n-  template<typename _Tp, typename _Val = __value_t<_Tp>>\n+  template<typename _Tp, typename _Val = __source_value_t<_Tp>>\n     using __value_type_is_char\n       = std::enable_if_t<std::is_same_v<_Val, char>, _Val>;\n \n   // As above, but also allows char8_t, as required by u8path\n   // C++20 [depr.fs.path.factory]\n-  template<typename _Tp, typename _Val = __value_t<_Tp>>\n+  template<typename _Tp, typename _Val = __source_value_t<_Tp>>\n     using __value_type_is_char_or_char8_t\n       = std::enable_if_t<std::is_same_v<_Val, char>\n #ifdef _GLIBCXX_USE_CHAR8_T\n \t\t\t || std::is_same_v<_Val, char8_t>\n #endif\n \t\t\t , _Val>;\n \n-  // Create a string or string view from an iterator range.\n+  // Create a basic_string<C> or basic_string_view<C> from an iterator range.\n   template<typename _InputIterator>\n     inline auto\n     __string_from_range(_InputIterator __first, _InputIterator __last)\n     {\n       using _EcharT\n \t= typename std::iterator_traits<_InputIterator>::value_type;\n-      static_assert(__is_encoded_char<_EcharT>);\n+      static_assert(__is_encoded_char<_EcharT>); // C++17 [fs.req]/3\n \n-#if __cpp_lib_concepts\n-      constexpr bool __contiguous = std::contiguous_iterator<_InputIterator>;\n-#else\n-      constexpr bool __contiguous\n-\t= is_pointer_v<decltype(std::__niter_base(__first))>;\n-#endif\n-      if constexpr (__contiguous)\n+      if constexpr (__is_contiguous<_InputIterator>)\n \t{\n \t  // For contiguous iterators we can just return a string view.\n-\t  const auto* __f = std::__to_address(std::__niter_base(__first));\n-\t  const auto* __l = std::__to_address(std::__niter_base(__last));\n-\t  return basic_string_view<_EcharT>(__f, __l - __f);\n+\t  if (auto __len = __last - __first) [[__likely__]]\n+\t    return basic_string_view<_EcharT>(&*__first, __len);\n+\t  return basic_string_view<_EcharT>();\n \t}\n       else\n-\t// Conversion requires contiguous characters, so create a string.\n-\treturn basic_string<_EcharT>(__first, __last);\n+\t{\n+\t  // Conversion requires contiguous characters, so create a string.\n+\t  return basic_string<__unified_u8_t<_EcharT>>(__first, __last);\n+\t}\n     }\n \n   /// @} group filesystem\n@@ -573,27 +611,22 @@ namespace __detail\n     pair<const string_type*, size_t> _M_find_extension() const noexcept;\n \n     // path::_S_convert creates a basic_string<value_type> or\n-    // basic_string_view<value_type> from a range (either the effective\n-    // range of a Source parameter, or a pair of InputIterator parameters),\n+    // basic_string_view<value_type> from a basic_string<C> or\n+    // basic_string_view<C>, for an encoded character type C,\n     // performing the conversions required by [fs.path.type.cvt].\n-    // If the value_type of the range value type is path::value_type,\n-    // no encoding conversion is performed. If the range is contiguous\n-    // a string_view\n-\n-    static string_type\n-    _S_convert(string_type __str)\n-    { return __str; }\n-\n     template<typename _Tp>\n       static auto\n-      _S_convert(const _Tp& __str)\n+      _S_convert(_Tp __str)\n       {\n-\tif constexpr (is_same_v<_Tp, string_type>)\n-\t  return __str;\n-\telse if constexpr (is_same_v<_Tp, basic_string_view<value_type>>)\n-\t  return __str;\n-\telse if constexpr (is_same_v<typename _Tp::value_type, value_type>)\n-\t  return basic_string_view<value_type>(__str.data(), __str.size());\n+\tif constexpr (is_same_v<_Tp, typename _Tp::value_type>)\n+\t  return __str; // No conversion needed.\n+#if !defined _GLIBCXX_FILESYSTEM_IS_WINDOWS && defined _GLIBCXX_USE_CHAR8_T\n+\telse if constexpr (is_same_v<_Tp, std::u8string>)\n+\t  // Calling _S_convert<char8_t> will return a u8string_view that\n+\t  // refers to __str and would dangle after this function returns.\n+\t  // Return a string_type instead, to avoid dangling.\n+\t  return string_type(_S_convert(std::u8string_view(__str)));\n+#endif\n \telse\n \t  return _S_convert(__str.data(), __str.data() + __str.size());\n       }\n@@ -602,6 +635,9 @@ namespace __detail\n       static auto\n       _S_convert(const _EcharT* __first, const _EcharT* __last);\n \n+    // _S_convert_loc converts a range of char to string_type, using the\n+    // supplied locale for encoding conversions.\n+\n     static string_type\n     _S_convert_loc(const char* __first, const char* __last,\n \t\t   const std::locale& __loc);"}]}