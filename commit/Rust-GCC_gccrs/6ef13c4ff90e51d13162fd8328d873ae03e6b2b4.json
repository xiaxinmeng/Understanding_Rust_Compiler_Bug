{"sha": "6ef13c4ff90e51d13162fd8328d873ae03e6b2b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVmMTNjNGZmOTBlNTFkMTMxNjJmZDgzMjhkODczYWUwM2U2YjJiNA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2019-07-11T08:02:35Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-11T08:02:35Z"}, "message": "[Ada] Remove redundant predicate checks\n\nThis patch removes redundant dynamic predicate checks generated by type\nconversions in various contexts. The patch also recognizes additional\nsuch checks that can be evaluated statically when applied to constant\nvalues.\n\nNo simple test available.\n\n2019-07-11  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_N_Type_Conversion): If a predicate check\n\tis generated, analyze it with range check suppressed, because\n\tthat check has been previously applied.\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): If the RHS is a\n\ttype conversion to the type of the LHS, do not apply a predicate\n\tcheck to the RHS because it will have been generated already\n\tduring its expansion.\n\t* exp_ch6.adb (Can_Fold_Predicate_Call): Extend processing to\n\thandle a predicate check on a constant entity whose value is\n\tstatic.\n\nFrom-SVN: r273395", "tree": {"sha": "33d3ab5a650516467f4c7d02b8bde04513d0c8cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33d3ab5a650516467f4c7d02b8bde04513d0c8cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "220dc4b2825745db538915298d0c79f2f12ce5e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220dc4b2825745db538915298d0c79f2f12ce5e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/220dc4b2825745db538915298d0c79f2f12ce5e0"}], "stats": {"total": 69, "additions": 51, "deletions": 18}, "files": [{"sha": "0b4871c2d26adeb6df759a27e488e0758675ca4d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6ef13c4ff90e51d13162fd8328d873ae03e6b2b4", "patch": "@@ -1,3 +1,16 @@\n+2019-07-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): If a predicate check\n+\tis generated, analyze it with range check suppressed, because\n+\tthat check has been previously applied.\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement): If the RHS is a\n+\ttype conversion to the type of the LHS, do not apply a predicate\n+\tcheck to the RHS because it will have been generated already\n+\tduring its expansion.\n+\t* exp_ch6.adb (Can_Fold_Predicate_Call): Extend processing to\n+\thandle a predicate check on a constant entity whose value is\n+\tstatic.\n+\n 2019-07-11  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* bindo.adb: Remove the documentation of switch -d_N because it"}, {"sha": "7a1e0b88325566ec34c01b7ebd20f4b7ee3ca8ef", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=6ef13c4ff90e51d13162fd8328d873ae03e6b2b4", "patch": "@@ -12050,10 +12050,13 @@ package body Exp_Ch4 is\n \n          begin\n             --  Avoid infinite recursion on the subsequent expansion of\n-            --  of the copy of the original type conversion.\n+            --  of the copy of the original type conversion. When needed,\n+            --  a range check has already been applied to the expression.\n \n             Set_Comes_From_Source (New_Expr, False);\n-            Insert_Action (N, Make_Predicate_Check (Target_Type, New_Expr));\n+            Insert_Action (N,\n+               Make_Predicate_Check (Target_Type, New_Expr),\n+               Suppress => Range_Check);\n          end;\n       end if;\n    end Expand_N_Type_Conversion;"}, {"sha": "18e9708cf7fc3934d5a5ccea302e3e93bd6a9c81", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=6ef13c4ff90e51d13162fd8328d873ae03e6b2b4", "patch": "@@ -2021,15 +2021,21 @@ package body Exp_Ch5 is\n \n       if not Suppress_Assignment_Checks (N) then\n \n-         --  First deal with generation of range check if required\n+         --  First deal with generation of range check if required,\n+         --  and then predicate checks if the type carries a predicate.\n+         --  If the Rhs is an expression these tests may have been applied\n+         --  already. This is the case if the RHS is a type conversion.\n+         --  Other such redundant checks could be removed ???\n+\n+         if Nkind (Rhs) /= N_Type_Conversion\n+           or else Entity (Subtype_Mark (Rhs)) /= Typ\n+         then\n+            if Do_Range_Check (Rhs) then\n+               Generate_Range_Check (Rhs, Typ, CE_Range_Check_Failed);\n+            end if;\n \n-         if Do_Range_Check (Rhs) then\n-            Generate_Range_Check (Rhs, Typ, CE_Range_Check_Failed);\n+            Apply_Predicate_Check (Rhs, Typ);\n          end if;\n-\n-         --  Then generate predicate check if required\n-\n-         Apply_Predicate_Check (Rhs, Typ);\n       end if;\n \n       --  Check for a special case where a high level transformation is"}, {"sha": "f38dd671b6d9b13d5829ed681d5d7f363711614b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef13c4ff90e51d13162fd8328d873ae03e6b2b4/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6ef13c4ff90e51d13162fd8328d873ae03e6b2b4", "patch": "@@ -2479,8 +2479,7 @@ package body Exp_Ch6 is\n       -----------------------------\n \n       function Can_Fold_Predicate_Call (P : Entity_Id) return Boolean is\n-         Actual : constant Node_Id :=\n-                    First (Parameter_Associations (Call_Node));\n+         Actual : Node_Id;\n \n          function May_Fold (N : Node_Id) return Traverse_Result;\n          --  The predicate expression is foldable if it only contains operators\n@@ -2533,10 +2532,11 @@ package body Exp_Ch6 is\n \n          function Try_Fold is new Traverse_Func (May_Fold);\n \n-         --  Local variables\n+         --  Other lLocal variables\n \n-         Subt : constant Entity_Id := Etype (First_Entity (P));\n-         Pred : Node_Id;\n+         Subt   : constant Entity_Id := Etype (First_Entity (P));\n+         Aspect : Node_Id;\n+         Pred   : Node_Id;\n \n       --  Start of processing for Can_Fold_Predicate_Call\n \n@@ -2545,18 +2545,29 @@ package body Exp_Ch6 is\n          --  has a Dynamic_Predicate aspect. For CodePeer we preserve the\n          --  function call.\n \n-         if Nkind (Actual) /= N_Integer_Literal\n+         Actual := First (Parameter_Associations (Call_Node));\n+         Aspect := Find_Aspect (Subt, Aspect_Dynamic_Predicate);\n+\n+         --  If actual is a declared constant, retrieve its value\n+\n+         if Is_Entity_Name (Actual)\n+           and then Ekind (Entity (Actual)) = E_Constant\n+         then\n+            Actual := Constant_Value (Entity (Actual));\n+         end if;\n+\n+         if No (Actual)\n+           or else Nkind (Actual) /= N_Integer_Literal\n            or else not Has_Dynamic_Predicate_Aspect (Subt)\n+           or else No (Aspect)\n            or else CodePeer_Mode\n          then\n             return False;\n          end if;\n \n          --  Retrieve the analyzed expression for the predicate\n \n-         Pred :=\n-           New_Copy_Tree\n-             (Expression (Find_Aspect (Subt, Aspect_Dynamic_Predicate)));\n+         Pred := New_Copy_Tree (Expression (Aspect));\n \n          if Try_Fold (Pred) = OK then\n             Rewrite (Call_Node, Pred);"}]}