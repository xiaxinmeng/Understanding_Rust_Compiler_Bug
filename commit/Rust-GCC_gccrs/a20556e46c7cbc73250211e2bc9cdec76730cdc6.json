{"sha": "a20556e46c7cbc73250211e2bc9cdec76730cdc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIwNTU2ZTQ2YzdjYmM3MzI1MDIxMWUyYmM5Y2RlYzc2NzMwY2RjNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-10-31T08:00:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-10-31T08:00:39Z"}, "message": "expmed.c (store_bit_field_using_insv): New function, split out from...\n\ngcc/\n\t* expmed.c (store_bit_field_using_insv): New function,\n\tsplit out from...\n\t(store_bit_field_1): ...here.\n\t(extract_bit_field_using_extv): New function, split out from...\n\t(extract_bit_field_1): ...here.\n\nFrom-SVN: r193023", "tree": {"sha": "a989ac385cac54e6813b307f2a4cbeda78f06bb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a989ac385cac54e6813b307f2a4cbeda78f06bb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a20556e46c7cbc73250211e2bc9cdec76730cdc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20556e46c7cbc73250211e2bc9cdec76730cdc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a20556e46c7cbc73250211e2bc9cdec76730cdc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20556e46c7cbc73250211e2bc9cdec76730cdc6/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "94eba7a819f107f909777b30a536f554baa3a77c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94eba7a819f107f909777b30a536f554baa3a77c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94eba7a819f107f909777b30a536f554baa3a77c"}], "stats": {"total": 398, "additions": 216, "deletions": 182}, "files": [{"sha": "3bf1bba568f98bafb99419d56f4f81a9c9d29037", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20556e46c7cbc73250211e2bc9cdec76730cdc6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20556e46c7cbc73250211e2bc9cdec76730cdc6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a20556e46c7cbc73250211e2bc9cdec76730cdc6", "patch": "@@ -1,3 +1,11 @@\n+2012-10-31  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* expmed.c (store_bit_field_using_insv): New function,\n+\tsplit out from...\n+\t(store_bit_field_1): ...here.\n+\t(extract_bit_field_using_extv): New function, split out from...\n+\t(extract_bit_field_1): ...here.\n+\n 2012-10-31  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* expmed.c (store_bit_field_1): Use OP_MODE to check whether an"}, {"sha": "4e20a9456015d068065a8fabc6f00fc7161035ca", "filename": "gcc/expmed.c", "status": "modified", "additions": 208, "deletions": 182, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20556e46c7cbc73250211e2bc9cdec76730cdc6/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20556e46c7cbc73250211e2bc9cdec76730cdc6/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=a20556e46c7cbc73250211e2bc9cdec76730cdc6", "patch": "@@ -404,6 +404,120 @@ lowpart_bit_field_p (unsigned HOST_WIDE_INT bitnum,\n     return bitnum % BITS_PER_WORD == 0;\n }\n \f\n+/* Try to use an insv pattern to store VALUE into a field of OP0.\n+   OP_MODE is the mode of the insertion and BITSIZE and BITNUM are\n+   as for store_bit_field.  */\n+\n+static bool\n+store_bit_field_using_insv (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+\t\t\t    unsigned HOST_WIDE_INT bitnum, rtx value,\n+\t\t\t    enum machine_mode op_mode)\n+{\n+  struct expand_operand ops[4];\n+  rtx value1;\n+  rtx xop0 = op0;\n+  rtx last = get_last_insn ();\n+  bool copy_back = false;\n+\n+  unsigned int unit = GET_MODE_BITSIZE (op_mode);\n+  if (bitsize == 0 || bitsize > unit)\n+    return false;\n+\n+  if (MEM_P (xop0))\n+    {\n+      /* Get a reference to the first byte of the field.  */\n+      xop0 = adjust_bitfield_address (xop0, byte_mode, bitnum / BITS_PER_UNIT);\n+      bitnum %= BITS_PER_UNIT;\n+    }\n+  else\n+    {\n+      /* Convert from counting within OP0 to counting in OP_MODE.  */\n+      if (BYTES_BIG_ENDIAN)\n+\tbitnum += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n+\n+      /* If xop0 is a register, we need it in OP_MODE\n+\t to make it acceptable to the format of insv.  */\n+      if (GET_CODE (xop0) == SUBREG)\n+\t/* We can't just change the mode, because this might clobber op0,\n+\t   and we will need the original value of op0 if insv fails.  */\n+\txop0 = gen_rtx_SUBREG (op_mode, SUBREG_REG (xop0), SUBREG_BYTE (xop0));\n+      if (REG_P (xop0) && GET_MODE (xop0) != op_mode)\n+\txop0 = gen_lowpart_SUBREG (op_mode, xop0);\n+    }\n+\n+  /* If the destination is a paradoxical subreg such that we need a\n+     truncate to the inner mode, perform the insertion on a temporary and\n+     truncate the result to the original destination.  Note that we can't\n+     just truncate the paradoxical subreg as (truncate:N (subreg:W (reg:N\n+     X) 0)) is (reg:N X).  */\n+  if (GET_CODE (xop0) == SUBREG\n+      && REG_P (SUBREG_REG (xop0))\n+      && !TRULY_NOOP_TRUNCATION_MODES_P (GET_MODE (SUBREG_REG (xop0)),\n+\t\t\t\t\t op_mode))\n+    {\n+      rtx tem = gen_reg_rtx (op_mode);\n+      emit_move_insn (tem, xop0);\n+      xop0 = tem;\n+      copy_back = true;\n+    }\n+\n+  /* If BITS_BIG_ENDIAN is zero on a BYTES_BIG_ENDIAN machine, we count\n+     \"backwards\" from the size of the unit we are inserting into.\n+     Otherwise, we count bits from the most significant on a\n+     BYTES/BITS_BIG_ENDIAN machine.  */\n+\n+  if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n+    bitnum = unit - bitsize - bitnum;\n+\n+  /* Convert VALUE to op_mode (which insv insn wants) in VALUE1.  */\n+  value1 = value;\n+  if (GET_MODE (value) != op_mode)\n+    {\n+      if (GET_MODE_BITSIZE (GET_MODE (value)) >= bitsize)\n+\t{\n+\t  /* Optimization: Don't bother really extending VALUE\n+\t     if it has all the bits we will actually use.  However,\n+\t     if we must narrow it, be sure we do it correctly.  */\n+\n+\t  if (GET_MODE_SIZE (GET_MODE (value)) < GET_MODE_SIZE (op_mode))\n+\t    {\n+\t      rtx tmp;\n+\n+\t      tmp = simplify_subreg (op_mode, value1, GET_MODE (value), 0);\n+\t      if (! tmp)\n+\t\ttmp = simplify_gen_subreg (op_mode,\n+\t\t\t\t\t   force_reg (GET_MODE (value),\n+\t\t\t\t\t\t      value1),\n+\t\t\t\t\t   GET_MODE (value), 0);\n+\t      value1 = tmp;\n+\t    }\n+\t  else\n+\t    value1 = gen_lowpart (op_mode, value1);\n+\t}\n+      else if (CONST_INT_P (value))\n+\tvalue1 = gen_int_mode (INTVAL (value), op_mode);\n+      else\n+\t/* Parse phase is supposed to make VALUE's data type\n+\t   match that of the component reference, which is a type\n+\t   at least as wide as the field; so VALUE should have\n+\t   a mode that corresponds to that type.  */\n+\tgcc_assert (CONSTANT_P (value));\n+    }\n+\n+  create_fixed_operand (&ops[0], xop0);\n+  create_integer_operand (&ops[1], bitsize);\n+  create_integer_operand (&ops[2], bitnum);\n+  create_input_operand (&ops[3], value1, op_mode);\n+  if (maybe_expand_insn (CODE_FOR_insv, 4, ops))\n+    {\n+      if (copy_back)\n+\tconvert_move (op0, xop0, true);\n+      return true;\n+    }\n+  delete_insns_since (last);\n+  return false;\n+}\n+\n /* A subroutine of store_bit_field, with the same arguments.  Return true\n    if the operation could be implemented.\n \n@@ -670,8 +784,6 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   enum machine_mode op_mode = mode_for_extraction (EP_insv, 3);\n   if (op_mode != MAX_MACHINE_MODE\n-      && bitsize > 0\n-      && GET_MODE_BITSIZE (op_mode) >= bitsize\n       /* Do not use insv for volatile bitfields when\n          -fstrict-volatile-bitfields is in effect.  */\n       && !(MEM_P (op0) && MEM_VOLATILE_P (op0)\n@@ -681,110 +793,9 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t restricted region.  */\n       && !(MEM_P (op0) && bitregion_end\n \t   && bitnum - (bitnum % BITS_PER_UNIT) + GET_MODE_BITSIZE (op_mode)\n-\t      > bitregion_end + 1))\n-    {\n-      struct expand_operand ops[4];\n-      unsigned HOST_WIDE_INT bitpos = bitnum;\n-      rtx value1;\n-      rtx xop0 = op0;\n-      rtx last = get_last_insn ();\n-      bool copy_back = false;\n-\n-      unsigned int unit = GET_MODE_BITSIZE (op_mode);\n-      if (MEM_P (xop0))\n-\t{\n-\t  /* Get a reference to the first byte of the field.  */\n-\t  xop0 = adjust_bitfield_address (xop0, byte_mode,\n-\t\t\t\t\t  bitpos / BITS_PER_UNIT);\n-\t  bitpos %= BITS_PER_UNIT;\n-\t}\n-      else\n-\t{\n-\t  /* Convert from counting within OP0 to counting in OP_MODE.  */\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n-\t}\n-\n-      /* If xop0 is a register, we need it in OP_MODE\n-\t to make it acceptable to the format of insv.  */\n-      if (GET_CODE (xop0) == SUBREG)\n-\t/* We can't just change the mode, because this might clobber op0,\n-\t   and we will need the original value of op0 if insv fails.  */\n-\txop0 = gen_rtx_SUBREG (op_mode, SUBREG_REG (xop0), SUBREG_BYTE (xop0));\n-      if (REG_P (xop0) && GET_MODE (xop0) != op_mode)\n-\txop0 = gen_lowpart_SUBREG (op_mode, xop0);\n-\n-      /* If the destination is a paradoxical subreg such that we need a\n-\t truncate to the inner mode, perform the insertion on a temporary and\n-\t truncate the result to the original destination.  Note that we can't\n-\t just truncate the paradoxical subreg as (truncate:N (subreg:W (reg:N\n-\t X) 0)) is (reg:N X).  */\n-      if (GET_CODE (xop0) == SUBREG\n-\t  && REG_P (SUBREG_REG (xop0))\n-\t  && (!TRULY_NOOP_TRUNCATION_MODES_P (GET_MODE (SUBREG_REG (xop0)),\n-\t\t\t\t\t      op_mode)))\n-\t{\n-\t  rtx tem = gen_reg_rtx (op_mode);\n-\t  emit_move_insn (tem, xop0);\n-\t  xop0 = tem;\n-\t  copy_back = true;\n-\t}\n-\n-      /* If BITS_BIG_ENDIAN is zero on a BYTES_BIG_ENDIAN machine, we count\n-         \"backwards\" from the size of the unit we are inserting into.\n-\t Otherwise, we count bits from the most significant on a\n-\t BYTES/BITS_BIG_ENDIAN machine.  */\n-\n-      if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n-\tbitpos = unit - bitsize - bitpos;\n-\n-      /* Convert VALUE to op_mode (which insv insn wants) in VALUE1.  */\n-      value1 = value;\n-      if (GET_MODE (value) != op_mode)\n-\t{\n-\t  if (GET_MODE_BITSIZE (GET_MODE (value)) >= bitsize)\n-\t    {\n-\t      /* Optimization: Don't bother really extending VALUE\n-\t\t if it has all the bits we will actually use.  However,\n-\t\t if we must narrow it, be sure we do it correctly.  */\n-\n-\t      if (GET_MODE_SIZE (GET_MODE (value)) < GET_MODE_SIZE (op_mode))\n-\t\t{\n-\t\t  rtx tmp;\n-\n-\t\t  tmp = simplify_subreg (op_mode, value1, GET_MODE (value), 0);\n-\t\t  if (! tmp)\n-\t\t    tmp = simplify_gen_subreg (op_mode,\n-\t\t\t\t\t       force_reg (GET_MODE (value),\n-\t\t\t\t\t\t\t  value1),\n-\t\t\t\t\t       GET_MODE (value), 0);\n-\t\t  value1 = tmp;\n-\t\t}\n-\t      else\n-\t\tvalue1 = gen_lowpart (op_mode, value1);\n-\t    }\n-\t  else if (CONST_INT_P (value))\n-\t    value1 = gen_int_mode (INTVAL (value), op_mode);\n-\t  else\n-\t    /* Parse phase is supposed to make VALUE's data type\n-\t       match that of the component reference, which is a type\n-\t       at least as wide as the field; so VALUE should have\n-\t       a mode that corresponds to that type.  */\n-\t    gcc_assert (CONSTANT_P (value));\n-\t}\n-\n-      create_fixed_operand (&ops[0], xop0);\n-      create_integer_operand (&ops[1], bitsize);\n-      create_integer_operand (&ops[2], bitpos);\n-      create_input_operand (&ops[3], value1, op_mode);\n-      if (maybe_expand_insn (CODE_FOR_insv, 4, ops))\n-\t{\n-\t  if (copy_back)\n-\t    convert_move (op0, xop0, true);\n-\t  return true;\n-\t}\n-      delete_insns_since (last);\n-    }\n+\t      > bitregion_end + 1)\n+      && store_bit_field_using_insv (op0, bitsize, bitnum, value, op_mode))\n+    return true;\n \n   /* If OP0 is a memory, try copying it to a register and seeing if a\n      cheap register alternative is available.  */\n@@ -1211,6 +1222,91 @@ convert_extracted_bit_field (rtx x, enum machine_mode mode,\n   return convert_to_mode (tmode, x, unsignedp);\n }\n \n+/* Try to use an ext(z)v pattern to extract a field from OP0.\n+   Return the extracted value on success, otherwise return null.\n+   EXT_MODE is the mode of the extraction and the other arguments\n+   are as for extract_bit_field.  */\n+\n+static rtx\n+extract_bit_field_using_extv (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+\t\t\t      unsigned HOST_WIDE_INT bitnum,\n+\t\t\t      int unsignedp, rtx target,\n+\t\t\t      enum machine_mode mode, enum machine_mode tmode,\n+\t\t\t      enum machine_mode ext_mode)\n+{\n+  struct expand_operand ops[4];\n+  rtx spec_target = target;\n+  rtx spec_target_subreg = 0;\n+  unsigned unit = GET_MODE_BITSIZE (ext_mode);\n+\n+  if (bitsize == 0 || unit < bitsize)\n+    return NULL_RTX;\n+\n+  if (MEM_P (op0))\n+    {\n+      /* Get a reference to the first byte of the field.  */\n+      op0 = adjust_bitfield_address (op0, byte_mode, bitnum / BITS_PER_UNIT);\n+      bitnum %= BITS_PER_UNIT;\n+    }\n+  else\n+    {\n+      /* Convert from counting within OP0 to counting in EXT_MODE.  */\n+      if (BYTES_BIG_ENDIAN)\n+\tbitnum += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n+\n+      /* If op0 is a register, we need it in EXT_MODE to make it\n+\t acceptable to the format of ext(z)v.  */\n+      if (GET_CODE (op0) == SUBREG && GET_MODE (op0) != ext_mode)\n+\treturn NULL_RTX;\n+      if (REG_P (op0) && GET_MODE (op0) != ext_mode)\n+\top0 = gen_lowpart_SUBREG (ext_mode, op0);\n+    }\n+\n+  /* If BITS_BIG_ENDIAN is zero on a BYTES_BIG_ENDIAN machine, we count\n+     \"backwards\" from the size of the unit we are extracting from.\n+     Otherwise, we count bits from the most significant on a\n+     BYTES/BITS_BIG_ENDIAN machine.  */\n+\n+  if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n+    bitnum = unit - bitsize - bitnum;\n+\n+  if (target == 0)\n+    target = spec_target = gen_reg_rtx (tmode);\n+\n+  if (GET_MODE (target) != ext_mode)\n+    {\n+      /* Don't use LHS paradoxical subreg if explicit truncation is needed\n+\t between the mode of the extraction (word_mode) and the target\n+\t mode.  Instead, create a temporary and use convert_move to set\n+\t the target.  */\n+      if (REG_P (target)\n+\t  && TRULY_NOOP_TRUNCATION_MODES_P (GET_MODE (target), ext_mode))\n+\t{\n+\t  target = gen_lowpart (ext_mode, target);\n+\t  if (GET_MODE_PRECISION (ext_mode)\n+\t      > GET_MODE_PRECISION (GET_MODE (spec_target)))\n+\t    spec_target_subreg = target;\n+\t}\n+      else\n+\ttarget = gen_reg_rtx (ext_mode);\n+    }\n+\n+  create_output_operand (&ops[0], target, ext_mode);\n+  create_fixed_operand (&ops[1], op0);\n+  create_integer_operand (&ops[2], bitsize);\n+  create_integer_operand (&ops[3], bitnum);\n+  if (maybe_expand_insn (unsignedp ? CODE_FOR_extzv : CODE_FOR_extv, 4, ops))\n+    {\n+      target = ops[0].value;\n+      if (target == spec_target)\n+\treturn target;\n+      if (target == spec_target_subreg)\n+\treturn spec_target;\n+      return convert_extracted_bit_field (target, mode, tmode, unsignedp);\n+    }\n+  return NULL_RTX;\n+}\n+\n /* A subroutine of extract_bit_field, with the same arguments.\n    If FALLBACK_P is true, fall back to extract_fixed_bit_field\n    if we can find no other means of implementing the operation.\n@@ -1499,86 +1595,16 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   ext_mode = mode_for_extraction (unsignedp ? EP_extzv : EP_extv, 0);\n   if (ext_mode != MAX_MACHINE_MODE\n-      && bitsize > 0\n-      && GET_MODE_BITSIZE (ext_mode) >= bitsize\n       /* Do not use extv/extzv for volatile bitfields when\n          -fstrict-volatile-bitfields is in effect.  */\n       && !(MEM_P (op0) && MEM_VOLATILE_P (op0)\n-\t   && flag_strict_volatile_bitfields > 0)\n-      /* If op0 is a register, we need it in EXT_MODE to make it\n-\t acceptable to the format of ext(z)v.  */\n-      && !(GET_CODE (op0) == SUBREG && GET_MODE (op0) != ext_mode))\n+\t   && flag_strict_volatile_bitfields > 0))\n     {\n-      struct expand_operand ops[4];\n-      unsigned HOST_WIDE_INT bitpos = bitnum;\n-      rtx xop0 = op0;\n-      rtx xtarget = target;\n-      rtx xspec_target = target;\n-      rtx xspec_target_subreg = 0;\n-      unsigned unit = GET_MODE_BITSIZE (ext_mode);\n-\n-      /* If op0 is a register, we need it in EXT_MODE to make it\n-\t acceptable to the format of ext(z)v.  */\n-      if (REG_P (xop0) && GET_MODE (xop0) != ext_mode)\n-\txop0 = gen_lowpart_SUBREG (ext_mode, xop0);\n-\n-      if (MEM_P (xop0))\n-\t{\n-\t  /* Get a reference to the first byte of the field.  */\n-\t  xop0 = adjust_bitfield_address (xop0, byte_mode,\n-\t\t\t\t\t  bitpos / BITS_PER_UNIT);\n-\t  bitpos %= BITS_PER_UNIT;\n-\t}\n-      else\n-\t{\n-\t  /* Convert from counting within OP0 to counting in EXT_MODE.  */\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n-\t}\n-\n-      /* If BITS_BIG_ENDIAN is zero on a BYTES_BIG_ENDIAN machine, we count\n-         \"backwards\" from the size of the unit we are extracting from.\n-\t Otherwise, we count bits from the most significant on a\n-\t BYTES/BITS_BIG_ENDIAN machine.  */\n-\n-      if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n-\tbitpos = unit - bitsize - bitpos;\n-\n-      if (xtarget == 0)\n-\txtarget = xspec_target = gen_reg_rtx (tmode);\n-\n-      if (GET_MODE (xtarget) != ext_mode)\n-\t{\n-\t  /* Don't use LHS paradoxical subreg if explicit truncation is needed\n-\t     between the mode of the extraction (word_mode) and the target\n-\t     mode.  Instead, create a temporary and use convert_move to set\n-\t     the target.  */\n-\t  if (REG_P (xtarget)\n-\t      && TRULY_NOOP_TRUNCATION_MODES_P (GET_MODE (xtarget), ext_mode))\n-\t    {\n-\t      xtarget = gen_lowpart (ext_mode, xtarget);\n-\t      if (GET_MODE_PRECISION (ext_mode)\n-\t\t  > GET_MODE_PRECISION (GET_MODE (xspec_target)))\n-\t\txspec_target_subreg = xtarget;\n-\t    }\n-\t  else\n-\t    xtarget = gen_reg_rtx (ext_mode);\n-\t}\n-\n-      create_output_operand (&ops[0], xtarget, ext_mode);\n-      create_fixed_operand (&ops[1], xop0);\n-      create_integer_operand (&ops[2], bitsize);\n-      create_integer_operand (&ops[3], bitpos);\n-      if (maybe_expand_insn (unsignedp ? CODE_FOR_extzv : CODE_FOR_extv,\n-\t\t\t     4, ops))\n-\t{\n-\t  xtarget = ops[0].value;\n-\t  if (xtarget == xspec_target)\n-\t    return xtarget;\n-\t  if (xtarget == xspec_target_subreg)\n-\t    return xspec_target;\n-\t  return convert_extracted_bit_field (xtarget, mode, tmode, unsignedp);\n-\t}\n+      rtx result = extract_bit_field_using_extv (op0, bitsize, bitnum,\n+\t\t\t\t\t\t unsignedp, target, mode,\n+\t\t\t\t\t\t tmode, ext_mode);\n+      if (result)\n+\treturn result;\n     }\n \n   /* If OP0 is a memory, try copying it to a register and seeing if a"}]}