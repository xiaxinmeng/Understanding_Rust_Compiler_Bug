{"sha": "57a95bc48d07fcd237553acf979f2e340590ed48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdhOTViYzQ4ZDA3ZmNkMjM3NTUzYWNmOTc5ZjJlMzQwNTkwZWQ0OA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2005-05-26T08:12:35Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-05-26T08:12:35Z"}, "message": "df.h (DF_SUBREGS, [...]): New.\n\n2005-05-26  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* df.h (DF_SUBREGS, df_local_def_available_p, df_insn_modified_p): New.\n\t* df.c (DF_SUBREGS, df_local_def_available_p, df_insn_modified_p): New.\n\nFrom-SVN: r100197", "tree": {"sha": "de741b09a4c6275ce287d076d0076ab1b43d2a63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de741b09a4c6275ce287d076d0076ab1b43d2a63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57a95bc48d07fcd237553acf979f2e340590ed48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57a95bc48d07fcd237553acf979f2e340590ed48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57a95bc48d07fcd237553acf979f2e340590ed48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57a95bc48d07fcd237553acf979f2e340590ed48/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "383898f7654cd9e2db0586fa2ff18ec933a61a81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/383898f7654cd9e2db0586fa2ff18ec933a61a81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/383898f7654cd9e2db0586fa2ff18ec933a61a81"}], "stats": {"total": 77, "additions": 71, "deletions": 6}, "files": [{"sha": "3c79b2a478ab3ab9a43c3f2ec296d53654bc5a55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a95bc48d07fcd237553acf979f2e340590ed48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a95bc48d07fcd237553acf979f2e340590ed48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57a95bc48d07fcd237553acf979f2e340590ed48", "patch": "@@ -1,3 +1,8 @@\n+2005-05-26  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* df.h (DF_SUBREGS, df_local_def_available_p, df_insn_modified_p): New.\n+\t* df.c (DF_SUBREGS, df_local_def_available_p, df_insn_modified_p): New.\n+\n 2005-05-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/21716"}, {"sha": "339f2c9ac4f4fdddb91698b696b85137e5569818", "filename": "gcc/df.c", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a95bc48d07fcd237553acf979f2e340590ed48/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a95bc48d07fcd237553acf979f2e340590ed48/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=57a95bc48d07fcd237553acf979f2e340590ed48", "patch": "@@ -820,7 +820,8 @@ df_ref_record (struct df *df, rtx reg, rtx *loc, rtx insn,\n      reg.  As written in the docu those should have the form\n      (subreg:SI (reg:M A) N), with size(SImode) > size(Mmode).\n      XXX Is that true?  We could also use the global word_mode variable.  */\n-  if (GET_CODE (reg) == SUBREG\n+  if ((df->flags & DF_SUBREGS) == 0\n+      && GET_CODE (reg) == SUBREG\n       && (GET_MODE_SIZE (GET_MODE (reg)) < GET_MODE_SIZE (word_mode)\n \t  || GET_MODE_SIZE (GET_MODE (reg))\n \t       >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (reg)))))\n@@ -2675,6 +2676,20 @@ df_insn_modify (struct df *df, basic_block bb, rtx insn)\n      will just get ignored.  */\n }\n \n+/* Check if INSN was marked as changed.  Of course the correctness of\n+   the information depends on whether the instruction was really modified\n+   at the time df_insn_modify was called.  */\n+bool\n+df_insn_modified_p (struct df *df, rtx insn)\n+{\n+  unsigned int uid;\n+\n+  uid = INSN_UID (insn);\n+  return (df->insns_modified\n+\t  && uid < df->insn_size\n+          && bitmap_bit_p (df->insns_modified, uid));\n+}\n+\n typedef struct replace_args\n {\n   rtx match;\n@@ -3237,6 +3252,48 @@ df_bb_regs_lives_compare (struct df *df, basic_block bb, rtx reg1, rtx reg2)\n }\n \n \n+/* Return true if the definition DEF, which is in the same basic\n+   block as USE, is available at USE.  So DEF may as well be\n+   dead, in which case using it will extend its live range.  */\n+bool\n+df_local_def_available_p (struct df *df, struct ref *def, struct ref *use)\n+{\n+  struct df_link *link;\n+  int def_luid = DF_INSN_LUID (df, DF_REF_INSN (def));\n+  int in_bb = 0;\n+  unsigned int regno = REGNO (def->reg);\n+  basic_block bb;\n+\n+  /* The regs must be local to BB.  */\n+  gcc_assert (DF_REF_BB (def) == DF_REF_BB (use));\n+  bb = DF_REF_BB (def);\n+\n+  /* This assumes that the reg-def list is ordered such that for any\n+     BB, the first def is found first.  However, since the BBs are not\n+     ordered, the first def in the chain is not necessarily the first\n+     def in the function.  */\n+  for (link = df->regs[regno].defs; link; link = link->next)\n+    {\n+      struct ref *this_def = link->ref;\n+      if (DF_REF_BB (this_def) == bb)\n+\t{\n+\t  int this_luid = DF_INSN_LUID (df, DF_REF_INSN (this_def));\n+\t  /* Do nothing with defs coming before DEF.  */\n+\t  if (this_luid > def_luid)\n+\t    return this_luid > DF_INSN_LUID (df, DF_REF_INSN (use));\n+\n+\t  in_bb = 1;\n+        }\n+      else if (in_bb)\n+\t/* DEF was the last in its basic block.  */\n+        return 1;\n+    }\n+\n+  /* DEF was the last in the function.  */\n+  return 1;\n+}\n+\n+\n /* Return last use of REGNO within BB.  */\n struct ref *\n df_bb_regno_last_use_find (struct df *df, basic_block bb, unsigned int regno)\n@@ -3304,7 +3361,7 @@ df_bb_regno_last_def_find (struct df *df, basic_block bb, unsigned int regno)\n   return last_def;\n }\n \n-/* Return first use of REGNO inside INSN within BB.  */\n+/* Return last use of REGNO inside INSN within BB.  */\n static struct ref *\n df_bb_insn_regno_last_use_find (struct df *df,\n \t\t\t\tbasic_block bb ATTRIBUTE_UNUSED, rtx insn,"}, {"sha": "43820819025a53872aeef5848b138f2b1bda15f2", "filename": "gcc/df.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a95bc48d07fcd237553acf979f2e340590ed48/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a95bc48d07fcd237553acf979f2e340590ed48/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=57a95bc48d07fcd237553acf979f2e340590ed48", "patch": "@@ -38,6 +38,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define DF_ALL\t\t255\n #define DF_HARD_REGS\t1024\t/* Mark hard registers.  */\n #define DF_EQUIV_NOTES\t2048\t/* Mark uses present in EQUIV/EQUAL notes.  */\n+#define DF_SUBREGS\t4096\t/* Return subregs rather than the inner reg.  */\n \n enum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE, DF_REF_REG_MEM_LOAD,\n \t\t  DF_REF_REG_MEM_STORE};\n@@ -207,11 +208,9 @@ struct df_map\n ((DF)->regs[REGNUM].uses ? (DF)->regs[REGNUM].uses->ref : 0)\n \n #define DF_REGNO_FIRST_BB(DF, REGNUM) \\\n-(DF_REGNO_FIRST_DEF (DF, REGNUM) \\\n-? DF_REF_BB (DF_REGNO_FIRST_DEF (DF, REGNUM)) : 0)\n+((DF)->regs[REGNUM].defs ? DF_REF_BB ((DF)->regs[REGNUM].defs->ref) : 0)\n #define DF_REGNO_LAST_BB(DF, REGNUM) \\\n-(DF_REGNO_LAST_USE (DF, REGNUM) \\\n-? DF_REF_BB (DF_REGNO_LAST_USE (DF, REGNUM)) : 0)\n+((DF)->regs[REGNUM].uses ? DF_REF_BB ((DF)->regs[REGNUM].uses->ref) : 0)\n \n \n /* Macros to access the elements within the insn_info structure table.  */\n@@ -235,6 +234,8 @@ extern void df_dump (struct df *, int, FILE *);\n \n /* Functions to modify insns.  */\n \n+extern bool df_insn_modified_p (struct df *, rtx);\n+\n extern void df_insn_modify (struct df *, basic_block, rtx);\n \n extern rtx df_insn_delete (struct df *, basic_block, rtx);\n@@ -280,6 +281,8 @@ extern int df_bb_reg_live_end_p (struct df *, basic_block, rtx);\n \n extern int df_bb_regs_lives_compare (struct df *, basic_block, rtx, rtx);\n \n+extern bool df_local_def_available_p (struct df *, struct ref *, struct ref *);\n+\n extern rtx df_bb_single_def_use_insn_find (struct df *, basic_block, rtx,\n \t\t\t\t\t   rtx);\n extern struct ref *df_bb_regno_last_use_find (struct df *, basic_block, unsigned int);"}]}