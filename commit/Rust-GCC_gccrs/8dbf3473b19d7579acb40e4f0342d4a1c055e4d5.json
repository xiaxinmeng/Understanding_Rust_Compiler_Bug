{"sha": "8dbf3473b19d7579acb40e4f0342d4a1c055e4d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRiZjM0NzNiMTlkNzU3OWFjYjQwZTRmMDM0MmQ0YTFjMDU1ZTRkNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-20T08:18:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-20T08:18:43Z"}, "message": "[multiple changes]\n\n2009-04-20  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb: Minor reformatting\n\n\t* lib-load.adb: Minor reformatting\n\n\t* sem_ch4.adb: Minor reformatting\n\n2009-04-20  Robert Dewar  <dewar@adacore.com>\n\n\t* namet-sp.ads, namet-sp.adb (Is_Bad_Spelling_Of): Implement new spec\n\t(equal values => False).\n\n2009-04-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Is_Null_Procedure): predicate is global, so that calls\n\tto null procedures can be inlined unconditionally.\n\nFrom-SVN: r146368", "tree": {"sha": "cbbdb7b765b7450d3975715bb6b8f577fd8d8e65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbbdb7b765b7450d3975715bb6b8f577fd8d8e65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/comments", "author": null, "committer": null, "parents": [{"sha": "56fe7b052dda1139d25bddad2e9fe9cb6ea222bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56fe7b052dda1139d25bddad2e9fe9cb6ea222bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56fe7b052dda1139d25bddad2e9fe9cb6ea222bf"}], "stats": {"total": 193, "additions": 118, "deletions": 75}, "files": [{"sha": "1ef52e07f479f339b99d2307836aa22ca035c061", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8dbf3473b19d7579acb40e4f0342d4a1c055e4d5", "patch": "@@ -1,3 +1,21 @@\n+2009-04-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb: Minor reformatting\n+\n+\t* lib-load.adb: Minor reformatting\n+\n+\t* sem_ch4.adb: Minor reformatting\n+\n+2009-04-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* namet-sp.ads, namet-sp.adb (Is_Bad_Spelling_Of): Implement new spec\n+\t(equal values => False).\n+\n+2009-04-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Is_Null_Procedure): predicate is global, so that calls\n+\tto null procedures can be inlined unconditionally.\n+\n 2009-04-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (call_to_gnu): When creating the copy for a"}, {"sha": "17332f26fbc874de45eadf982d0475422426820a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 72, "deletions": 57, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=8dbf3473b19d7579acb40e4f0342d4a1c055e4d5", "patch": "@@ -215,6 +215,10 @@ package body Exp_Ch6 is\n    --  reference to the object itself, and the call becomes a call to the\n    --  corresponding protected subprogram.\n \n+   function Is_Null_Procedure (Subp : Entity_Id) return Boolean;\n+   --  Predicate to recognize stubbed procedures and null procedures, which\n+   --  can be inlined unconditionally in all cases.\n+\n    ----------------------------------------------\n    -- Add_Access_Actual_To_Build_In_Place_Call --\n    ----------------------------------------------\n@@ -2887,6 +2891,14 @@ package body Exp_Ch6 is\n       if Ekind (Subp) = E_Function\n         or else Ekind (Subp) = E_Procedure\n       then\n+         --  A simple optimization: always replace calls to null procedures\n+         --  with a null statement.\n+\n+         if Is_Null_Procedure (Subp)  then\n+            Rewrite (N, Make_Null_Statement (Loc));\n+            return;\n+         end if;\n+\n          if Is_Inlined (Subp) then\n \n             Inlined_Subprogram : declare\n@@ -3216,10 +3228,6 @@ package body Exp_Ch6 is\n       --  If the type returned by the function is unconstrained and the\n       --  call can be inlined, special processing is required.\n \n-      function Is_Null_Procedure return Boolean;\n-      --  Predicate to recognize stubbed procedures and null procedures, for\n-      --  which there is no need for the full inlining mechanism.\n-\n       procedure Make_Exit_Label;\n       --  Build declaration for exit label to be used in Return statements\n \n@@ -3246,50 +3254,6 @@ package body Exp_Ch6 is\n       function Formal_Is_Used_Once (Formal : Entity_Id) return Boolean;\n       --  Determine whether a formal parameter is used only once in Orig_Bod\n \n-      -----------------------\n-      -- Is_Null_Procedure --\n-      -----------------------\n-\n-      function Is_Null_Procedure return Boolean is\n-         Decl : constant Node_Id := Unit_Declaration_Node (Subp);\n-\n-      begin\n-         if Ekind (Subp) /= E_Procedure then\n-            return False;\n-\n-         elsif Nkind (Orig_Bod) /= N_Subprogram_Body then\n-            return False;\n-\n-         --  Check if this is an Ada 2005 null procedure\n-\n-         elsif Nkind (Decl) = N_Subprogram_Declaration\n-           and then Null_Present (Specification (Decl))\n-         then\n-            return True;\n-\n-         --  Check if the body contains only a null statement, followed by the\n-         --  return statement added during expansion.\n-\n-         else\n-            declare\n-               Stat : constant Node_Id :=\n-                        First\n-                          (Statements (Handled_Statement_Sequence (Orig_Bod)));\n-\n-               Stat2 : constant Node_Id := Next (Stat);\n-\n-            begin\n-               return\n-                 Nkind (Stat) = N_Null_Statement\n-                   and then\n-                     (No (Stat2)\n-                       or else\n-                         (Nkind (Stat2) = N_Simple_Return_Statement\n-                           and then No (Next (Stat2))));\n-            end;\n-         end if;\n-      end Is_Null_Procedure;\n-\n       ---------------------\n       -- Make_Exit_Label --\n       ---------------------\n@@ -3611,22 +3575,18 @@ package body Exp_Ch6 is\n    --  Start of processing for Expand_Inlined_Call\n \n    begin\n-      --  Check for special case of To_Address call, and if so, just do an\n-      --  unchecked conversion instead of expanding the call. Not only is this\n-      --  more efficient, but it also avoids problem with order of elaboration\n-      --  when address clauses are inlined (address expression elaborated at\n-      --  wrong point).\n+\n+      --  For To_Address, just do an unchecked conversion . Not only is this\n+      --  efficient, but it also avoids problem with order of elaboration\n+      --  when address clauses are inlined (address expression elaborated\n+      --  at the wrong point).\n \n       if Subp = RTE (RE_To_Address) then\n          Rewrite (N,\n            Unchecked_Convert_To\n             (RTE (RE_Address),\n              Relocate_Node (First_Actual (N))));\n          return;\n-\n-      elsif Is_Null_Procedure  then\n-         Rewrite (N, Make_Null_Statement (Loc));\n-         return;\n       end if;\n \n       --  Check for an illegal attempt to inline a recursive procedure. If the\n@@ -4930,6 +4890,61 @@ package body Exp_Ch6 is\n       end;\n    end Freeze_Subprogram;\n \n+   -----------------------\n+   -- Is_Null_Procedure --\n+   -----------------------\n+\n+   function Is_Null_Procedure (Subp : Entity_Id) return Boolean is\n+      Decl : constant Node_Id := Unit_Declaration_Node (Subp);\n+\n+   begin\n+      if Ekind (Subp) /= E_Procedure then\n+         return False;\n+\n+      --  Check if this is a declared null procedure\n+\n+      elsif Nkind (Decl) = N_Subprogram_Declaration then\n+         if Null_Present (Specification (Decl)) then\n+            return True;\n+\n+         elsif No (Body_To_Inline (Decl)) then\n+            return False;\n+\n+         --  Check if the body contains only a null statement, followed by\n+         --  the return statement added during expansion.\n+\n+         else\n+            declare\n+               Orig_Bod : constant Node_Id := Body_To_Inline (Decl);\n+\n+               Stat  : Node_Id;\n+               Stat2 : Node_Id;\n+\n+            begin\n+               if Nkind (Orig_Bod) /= N_Subprogram_Body then\n+                  return False;\n+               else\n+                  Stat :=\n+                     First\n+                       (Statements (Handled_Statement_Sequence (Orig_Bod)));\n+                  Stat2 := Next (Stat);\n+\n+                  return\n+                    Nkind (Stat) = N_Null_Statement\n+                      and then\n+                        (No (Stat2)\n+                          or else\n+                            (Nkind (Stat2) = N_Simple_Return_Statement\n+                              and then No (Next (Stat2))));\n+               end if;\n+            end;\n+         end if;\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Null_Procedure;\n+\n    -------------------------------------------\n    -- Make_Build_In_Place_Call_In_Allocator --\n    -------------------------------------------"}, {"sha": "508b2e871ad4077f800b7a6df0e391458b679b9f", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=8dbf3473b19d7579acb40e4f0342d4a1c055e4d5", "patch": "@@ -714,12 +714,12 @@ package body Lib.Load is\n                   --  it may very likely be the case that there is also pragma\n                   --  Restriction forbidding its usage. This is typically the\n                   --  case when building a configurable run time, where the\n-                  --  usage of certain run-time units is restricted by\n-                  --  means of both the corresponding pragma Restriction (such\n-                  --  as No_Calendar), and by not including the unit. Hence,\n-                  --  we check whether this predefined unit is forbidden, so\n-                  --  that the message about the restriction violation is\n-                  --  generated, if needed.\n+                  --  usage of certain run-time units is restricted by means\n+                  --  of both the corresponding pragma Restriction (such as\n+                  --  No_Calendar), and by not including the unit. Hence, we\n+                  --  check whether this predefined unit is forbidden, so that\n+                  --  the message about the restriction violation is generated,\n+                  --  if needed.\n \n                   Check_Restricted_Unit (Load_Name, Error_Node);\n "}, {"sha": "30f85f52c02eeee86f2b888cf38b55bce55cd57d", "filename": "gcc/ada/namet-sp.adb", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Fnamet-sp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Fnamet-sp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet-sp.adb?ref=8dbf3473b19d7579acb40e4f0342d4a1c055e4d5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2009, Free Software Foundation, Inc.            --\n+--            Copyright (C) 2008-2009, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -186,9 +186,18 @@ package body Namet.Sp is\n    begin\n       Get_Name_String_UTF_32 (Found, FB, FBL);\n       Get_Name_String_UTF_32 (Expect, EB, EBL);\n-      return\n-        GNAT.UTF_32_Spelling_Checker.Is_Bad_Spelling_Of\n-          (FB (1 .. FBL), EB (1 .. EBL));\n+\n+      --  For an exact match, return False, otherwise check bad spelling. We\n+      --  need this special test because the library routine returns True for\n+      --  an exact match.\n+\n+      if FB (1 .. FBL) = EB (1 .. EBL) then\n+         return False;\n+      else\n+         return\n+           GNAT.UTF_32_Spelling_Checker.Is_Bad_Spelling_Of\n+             (FB (1 .. FBL), EB (1 .. EBL));\n+      end if;\n    end Is_Bad_Spelling_Of;\n \n end Namet.Sp;"}, {"sha": "15d41a07b058d077682e23dfcf90e1ae5e25421b", "filename": "gcc/ada/namet-sp.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Fnamet-sp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Fnamet-sp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet-sp.ads?ref=8dbf3473b19d7579acb40e4f0342d4a1c055e4d5", "patch": "@@ -40,6 +40,7 @@ package Namet.Sp is\n    function Is_Bad_Spelling_Of (Found, Expect : Name_Id) return Boolean;\n    --  Compares two identifier names from the names table, and returns True if\n    --  Found is a plausible misspelling of Expect. This function properly deals\n-   --  with wide and wide wide character encodings in the input names.\n+   --  with wide and wide wide character encodings in the input names. Note\n+   --  that an exact match in the names results in False being returned.\n \n end Namet.Sp;"}, {"sha": "e80c6626a3b1d1ec2be12ca428a3a18a85de9ec0", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=8dbf3473b19d7579acb40e4f0342d4a1c055e4d5", "patch": "@@ -993,9 +993,9 @@ package body Sem_Ch3 is\n    is\n \n       procedure Check_For_Premature_Usage (Def : Node_Id);\n-      --  Check that type T_Name is not used, directly or recursively,\n-      --  as a parameter or a return type in Def. Def is either a subtype,\n-      --  an access_definition, or an access_to_subprogram_definition.\n+      --  Check that type T_Name is not used, directly or recursively, as a\n+      --  parameter or a return type in Def. Def is either a subtype, an\n+      --  access_definition, or an access_to_subprogram_definition.\n \n       -------------------------------\n       -- Check_For_Premature_Usage --"}, {"sha": "e572f56905bd38de3f1398bba158edd9d07d7f4d", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dbf3473b19d7579acb40e4f0342d4a1c055e4d5/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=8dbf3473b19d7579acb40e4f0342d4a1c055e4d5", "patch": "@@ -127,10 +127,10 @@ package body Sem_Ch4 is\n    procedure Check_Misspelled_Selector\n      (Prefix : Entity_Id;\n       Sel    : Node_Id);\n-   --  Give possible misspelling diagnostic if Sel is likely to be\n-   --  a misspelling of one of the selectors of the Prefix.\n-   --  This is called by Analyze_Selected_Component after producing\n-   --  an invalid selector error message.\n+   --  Give possible misspelling diagnostic if Sel is likely to be a mis-\n+   --  spelling of one of the selectors of the Prefix. This is called by\n+   --  Analyze_Selected_Component after producing an invalid selector error\n+   --  message.\n \n    function Defined_In_Scope (T : Entity_Id; S : Entity_Id) return Boolean;\n    --  Verify that type T is declared in scope S. Used to find interpretations"}]}