{"sha": "6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM5MjlhMmVhMGVhY2FkMWMzYzU5YzQ2YmNkZWQyZmE3MmIyYzdjZA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-04-06T09:24:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:24:49Z"}, "message": "par-ch3.adb: (P_Type_Declaration): Set Type_Token_Location\n\n2007-04-06  Robert Dewar  <dewar@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\n\t* par-ch3.adb: (P_Type_Declaration): Set Type_Token_Location\n\t(P_Interface_Type_Definition): Remove the formal Is_Synchronized because\n\tthere is no need to generate always a record_definition_node in case\n\tof synchronized interface types.\n\t(P_Type_Declaration): Update calls to P_Interface_Type_Definition.\n\t(P_Null_Exclusion): For AI-447: Remove warnings about \"not null\" being\n\tillegal in Ada 95, in cases where it is legal. Change the warnings to\n\terrors in other cases. Don't give the error unless the \"not null\"\n\tparses properly. Correct the source position at which the error occurs.\n\t(P_Known_Discriminant_Part_Opt): Pass Allow_Anonymous_In_95 => True to\n\tP_Null_Exclusion, to suppress \"not null\" warnings.\n\t(P_Identifier_Declarations): Code cleanup. Removed unrequired label and\n\tassociated goto statements.\n\n\t* par-endh.adb (Pop_End_Context): Allow more flexibility in placement\n\tof END RECORD\n\n\t* scans.ads (Type_Token_Location): New flag\n\n\t* par-ch6.adb (P_Mode): Check specifically for case of IN ACCESS\n\t(P_Formal_Part): Pass Allow_Anonymous_In_95 => True to\n\tP_Null_Exclusion, to suppress \"not null\" warnings.\n\nFrom-SVN: r123587", "tree": {"sha": "57fdc43089af249b66c36d761b0f245a8f584c8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57fdc43089af249b66c36d761b0f245a8f584c8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd/comments", "author": null, "committer": null, "parents": [{"sha": "3726d5d99a29d89a37d50c9597cbd9771247194b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3726d5d99a29d89a37d50c9597cbd9771247194b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3726d5d99a29d89a37d50c9597cbd9771247194b"}], "stats": {"total": 151, "additions": 91, "deletions": 60}, "files": [{"sha": "b284b307413ebaa3ecefd583f77c860ce8c84e99", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 61, "deletions": 57, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd", "patch": "@@ -286,6 +286,7 @@ package body Ch3 is\n       --  If we have TYPE, then proceed ahead and scan identifier\n \n       if Token = Tok_Type then\n+         Type_Token_Location := Type_Loc;\n          Scan; -- past TYPE\n          Ident_Node := P_Defining_Identifier (C_Is);\n \n@@ -634,9 +635,8 @@ package body Ch3 is\n                  or else (Token = Tok_Identifier\n                            and then Chars (Token_Node) = Name_Interface)\n                then\n-                  Typedef_Node := P_Interface_Type_Definition\n-                                    (Abstract_Present,\n-                                     Is_Synchronized => False);\n+                  Typedef_Node :=\n+                    P_Interface_Type_Definition (Abstract_Present);\n                   Abstract_Present := True;\n                   Set_Limited_Present (Typedef_Node);\n \n@@ -721,8 +721,7 @@ package body Ch3 is\n             --  Ada 2005 (AI-251): INTERFACE\n \n             when Tok_Interface =>\n-               Typedef_Node := P_Interface_Type_Definition\n-                                (Abstract_Present, Is_Synchronized => False);\n+               Typedef_Node := P_Interface_Type_Definition (Abstract_Present);\n                Abstract_Present := True;\n                TF_Semicolon;\n                exit;\n@@ -761,8 +760,7 @@ package body Ch3 is\n \n                   else\n                      Typedef_Node :=\n-                       P_Interface_Type_Definition\n-                         (Abstract_Present, Is_Synchronized => True);\n+                       P_Interface_Type_Definition (Abstract_Present);\n                      Abstract_Present := True;\n \n                      case Saved_Token is\n@@ -925,25 +923,44 @@ package body Ch3 is\n \n    --  Error recovery: can raise Error_Resync\n \n-   function P_Null_Exclusion return Boolean is\n+   function P_Null_Exclusion\n+     (Allow_Anonymous_In_95 : Boolean := False) return Boolean\n+   is\n+      Not_Loc : constant Source_Ptr := Token_Ptr;\n+      --  Source position of \"not\", if present\n+\n    begin\n       if Token /= Tok_Not then\n          return False;\n \n       else\n-         --  Ada 2005 (AI-441): The qualifier has no semantic meaning in Ada 95\n-         --  (all access Parameters Are \"not null\" in Ada 95).\n-\n-         if Ada_Version < Ada_05 then\n-            Error_Msg_SP\n-              (\"null-excluding access is an Ada 2005 extension?\");\n-            Error_Msg_SP (\"\\unit should be compiled with -gnat05 switch?\");\n-         end if;\n-\n          Scan; --  past NOT\n \n          if Token = Tok_Null then\n             Scan; --  past NULL\n+\n+            --  Ada 2005 (AI-441, AI-447): null_exclusion is illegal in Ada 95,\n+            --  except in the case of anonymous access types.\n+            --  Allow_Anonymous_In_95 will be True if we're parsing a\n+            --  formal parameter or discriminant, which are the only places\n+            --  where anonymous access types occur in Ada 95. \"Formal : not\n+            --  null access ...\" is legal in Ada 95, whereas \"Formal : not\n+            --  null Named_Access_Type\" is not.\n+\n+            if Ada_Version >= Ada_05\n+              or else (Ada_Version >= Ada_95\n+                        and then Allow_Anonymous_In_95\n+                        and then Token = Tok_Access)\n+            then\n+               null; -- OK\n+\n+            else\n+               Error_Msg\n+                 (\"null-excluding access is an Ada 2005 extension\", Not_Loc);\n+               Error_Msg\n+                 (\"\\unit should be compiled with -gnat05 switch\", Not_Loc);\n+            end if;\n+\n          else\n             Error_Msg_SP (\"NULL expected\");\n          end if;\n@@ -953,8 +970,9 @@ package body Ch3 is\n    end P_Null_Exclusion;\n \n    function P_Subtype_Indication\n-     (Not_Null_Present : Boolean := False) return Node_Id is\n-      Type_Node        : Node_Id;\n+     (Not_Null_Present : Boolean := False) return Node_Id\n+   is\n+      Type_Node : Node_Id;\n \n    begin\n       if Token = Tok_Identifier or else Token = Tok_Operator_Symbol then\n@@ -984,9 +1002,10 @@ package body Ch3 is\n \n    function P_Subtype_Indication\n      (Subtype_Mark     : Node_Id;\n-      Not_Null_Present : Boolean := False) return Node_Id is\n-      Indic_Node       : Node_Id;\n-      Constr_Node      : Node_Id;\n+      Not_Null_Present : Boolean := False) return Node_Id\n+   is\n+      Indic_Node  : Node_Id;\n+      Constr_Node : Node_Id;\n \n    begin\n       Constr_Node := P_Constraint_Opt;\n@@ -1019,7 +1038,6 @@ package body Ch3 is\n    function P_Subtype_Mark return Node_Id is\n    begin\n       return P_Subtype_Mark_Resync;\n-\n    exception\n       when Error_Resync =>\n          return Error;\n@@ -1602,7 +1620,6 @@ package body Ch3 is\n                if Token /= Tok_Renames then\n                   Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n                   Set_Object_Definition (Decl_Node, Acc_Node);\n-                  goto init;\n \n                else\n                   Scan; --  past renames\n@@ -1675,7 +1692,6 @@ package body Ch3 is\n             if Token /= Tok_Renames then\n                Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n                Set_Object_Definition (Decl_Node, Acc_Node);\n-               goto init; -- ??? is this really needed goes here anyway\n \n             else\n                Scan; --  past renames\n@@ -1723,7 +1739,6 @@ package body Ch3 is\n \n          --  Scan out initialization, allowed only for object declaration\n \n-         <<init>> -- is this really needed ???\n          Init_Loc := Token_Ptr;\n          Init_Expr := Init_Expr_Opt;\n \n@@ -2785,7 +2800,8 @@ package body Ch3 is\n                Specification_Node :=\n                  New_Node (N_Discriminant_Specification, Ident_Sloc);\n                Set_Defining_Identifier (Specification_Node, Idents (Ident));\n-               Not_Null_Present := P_Null_Exclusion; -- Ada 2005 (AI-231)\n+               Not_Null_Present :=  --  Ada 2005 (AI-231, AI-447)\n+                 P_Null_Exclusion (Allow_Anonymous_In_95 => True);\n \n                if Token = Tok_Access then\n                   if Ada_Version = Ada_83 then\n@@ -3566,8 +3582,7 @@ package body Ch3 is\n    --  Error recovery: cannot raise Error_Resync\n \n    function P_Interface_Type_Definition\n-     (Abstract_Present : Boolean;\n-      Is_Synchronized  : Boolean) return Node_Id\n+     (Abstract_Present : Boolean) return Node_Id\n    is\n       Typedef_Node : Node_Id;\n \n@@ -3584,34 +3599,17 @@ package body Ch3 is\n \n       Scan; -- past INTERFACE\n \n-      --  Ada 2005 (AI-345): In case of synchronized interfaces and\n-      --  interfaces with a null list of interfaces we build a\n-      --  record_definition node.\n+      --  Ada 2005 (AI-345): In case of interfaces with a null list of\n+      --  interfaces we build a record_definition node.\n \n-      if Is_Synchronized\n-        or else Token = Tok_Semicolon\n-      then\n+      if Token = Tok_Semicolon then\n          Typedef_Node := New_Node (N_Record_Definition, Token_Ptr);\n \n          Set_Abstract_Present  (Typedef_Node);\n          Set_Tagged_Present    (Typedef_Node);\n          Set_Null_Present      (Typedef_Node);\n          Set_Interface_Present (Typedef_Node);\n \n-         if Is_Synchronized\n-           and then Token = Tok_And\n-         then\n-            Scan; -- past AND\n-            Set_Interface_List (Typedef_Node, New_List);\n-\n-            loop\n-               Append (P_Qualified_Simple_Name,\n-                       Interface_List (Typedef_Node));\n-               exit when Token /= Tok_And;\n-               Scan; -- past AND\n-            end loop;\n-         end if;\n-\n       --  Ada 2005 (AI-251): In case of not-synchronized interfaces that have\n       --  a list of interfaces we build a derived_type_definition node. This\n       --  simplifies the semantic analysis (and hence further mainteinance)\n@@ -3678,18 +3676,23 @@ package body Ch3 is\n    --  Error recovery: can raise Error_Resync\n \n    function P_Access_Type_Definition\n-     (Header_Already_Parsed : Boolean := False) return Node_Id is\n-      Access_Loc            : constant Source_Ptr := Token_Ptr;\n-      Prot_Flag             : Boolean;\n-      Not_Null_Present      : Boolean := False;\n-      Type_Def_Node         : Node_Id;\n-      Result_Not_Null       : Boolean;\n-      Result_Node           : Node_Id;\n+     (Header_Already_Parsed : Boolean := False) return Node_Id\n+   is\n+      Access_Loc       : constant Source_Ptr := Token_Ptr;\n+      Prot_Flag        : Boolean;\n+      Not_Null_Present : Boolean := False;\n+      Type_Def_Node    : Node_Id;\n+      Result_Not_Null  : Boolean;\n+      Result_Node      : Node_Id;\n \n       procedure Check_Junk_Subprogram_Name;\n       --  Used in access to subprogram definition cases to check for an\n       --  identifier or operator symbol that does not belong.\n \n+      --------------------------------\n+      -- Check_Junk_Subprogram_Name --\n+      --------------------------------\n+\n       procedure Check_Junk_Subprogram_Name is\n          Saved_State : Saved_Scan_State;\n \n@@ -3846,7 +3849,8 @@ package body Ch3 is\n    --  Error recovery: cannot raise Error_Resync\n \n    function P_Access_Definition\n-     (Null_Exclusion_Present : Boolean) return Node_Id is\n+     (Null_Exclusion_Present : Boolean) return Node_Id\n+   is\n       Def_Node  : Node_Id;\n       Subp_Node : Node_Id;\n "}, {"sha": "903cc4e0de51a65849b1fc8b2bbeada5ccaa4d5e", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd", "patch": "@@ -1084,7 +1084,13 @@ package body Ch6 is\n                Specification_Node :=\n                  New_Node (N_Parameter_Specification, Ident_Sloc);\n                Set_Defining_Identifier (Specification_Node, Idents (Ident));\n-               Not_Null_Present := P_Null_Exclusion;     --  Ada 2005 (AI-231)\n+\n+               --  Scan possible NOT NULL for Ada 2005 (AI-231, AI-447)\n+\n+               Not_Null_Present :=\n+                 P_Null_Exclusion (Allow_Anonymous_In_95 => True);\n+\n+               --  Case of ACCESS keyword present\n \n                if Token = Tok_Access then\n                   Set_Null_Exclusion_Present\n@@ -1094,8 +1100,11 @@ package body Ch6 is\n                      Error_Msg_SC (\"(Ada 83) access parameters not allowed\");\n                   end if;\n \n-                  Set_Parameter_Type (Specification_Node,\n-                    P_Access_Definition (Not_Null_Present));\n+                  Set_Parameter_Type\n+                    (Specification_Node,\n+                     P_Access_Definition (Not_Null_Present));\n+\n+               --  Case of IN or OUT present\n \n                else\n                   if Token = Tok_In or else Token = Tok_Out then\n@@ -1237,6 +1246,11 @@ package body Ch6 is\n          if Style.Mode_In_Check and then Token /= Tok_Out then\n             Error_Msg_SP (\"(style) IN should be omitted\");\n          end if;\n+\n+         if Token = Tok_Access then\n+            Error_Msg_SP (\"IN not allowed together with ACCESS\");\n+            Scan; -- past ACCESS\n+         end if;\n       end if;\n \n       if Token = Tok_Out then"}, {"sha": "92f7e9b8375190b47e406219ca7956d570f5b3fa", "filename": "gcc/ada/par-endh.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd/gcc%2Fada%2Fpar-endh.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd/gcc%2Fada%2Fpar-endh.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-endh.adb?ref=6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd", "patch": "@@ -1042,6 +1042,13 @@ package body Endh is\n             if Style.RM_Column_Check then\n                if End_Column /= Scope.Table (Scope.Last).Ecol\n                  and then Current_Line_Start > Scope.Table (Scope.Last).Sloc\n+\n+               --  A special case, for END RECORD, we are also allowed to\n+               --  line up with the TYPE keyword opening the declaration.\n+\n+                 and then (Scope.Table (Scope.Last).Etyp /= E_Record\n+                            or else Get_Column_Number (End_Sloc) /=\n+                                    Get_Column_Number (Type_Token_Location))\n                then\n                   Error_Msg_Col := Scope.Table (Scope.Last).Ecol;\n                   Error_Msg"}, {"sha": "a01b9570e2245a779fe592a2f4b8543ebdd7e470", "filename": "gcc/ada/scans.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd/gcc%2Fada%2Fscans.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd/gcc%2Fada%2Fscans.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscans.ads?ref=6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd", "patch": "@@ -365,6 +365,12 @@ package Scans is\n    --  on the line containing the current token. This is used for error\n    --  recovery circuits which depend on looking at the column line up.\n \n+   Type_Token_Location : Source_Ptr;\n+   --  Within a type declaration, gives the location of the TYPE keyword that\n+   --  opened the type declaration. Used in checking the end column of a record\n+   --  declaration, which can line up either with the TYPE keyword, or with the\n+   --  start of the line containing the RECORD keyword.\n+\n    Checksum : Word;\n    --  Used to accumulate a CRC representing the tokens in the source\n    --  file being compiled. This CRC includes only program tokens, and"}]}