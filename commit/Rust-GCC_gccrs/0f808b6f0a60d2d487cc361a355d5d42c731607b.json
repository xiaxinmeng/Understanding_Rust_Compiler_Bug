{"sha": "0f808b6f0a60d2d487cc361a355d5d42c731607b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY4MDhiNmYwYTYwZDJkNDg3Y2MzNjFhMzU1ZDVkNDJjNzMxNjA3Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "2000-01-03T15:49:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-01-03T15:49:51Z"}, "message": "combine.c (expand_compound_operation): Do not convert ZERO_EXTEND to SIGN_EXTEND, convert SIGN_EXTEND to ZERO_EXTEND.\n\n\n\t* combine.c (expand_compound_operation): Do not convert ZERO_EXTEND to\n\tSIGN_EXTEND, convert SIGN_EXTEND to ZERO_EXTEND.\n\t(make_compound_operation): Choose cheaper alternative between\n\tZERO_EXTEND and SIGN_EXTEND when sign bit is not set.\n\nFrom-SVN: r31180", "tree": {"sha": "cb538d78bfdc59b555389ff61e14e20a45fccd68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb538d78bfdc59b555389ff61e14e20a45fccd68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f808b6f0a60d2d487cc361a355d5d42c731607b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f808b6f0a60d2d487cc361a355d5d42c731607b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f808b6f0a60d2d487cc361a355d5d42c731607b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f808b6f0a60d2d487cc361a355d5d42c731607b/comments", "author": null, "committer": null, "parents": [{"sha": "f741a71c75d5196f226fc86697fa46cc0e427bf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f741a71c75d5196f226fc86697fa46cc0e427bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f741a71c75d5196f226fc86697fa46cc0e427bf5"}], "stats": {"total": 97, "additions": 69, "deletions": 28}, "files": [{"sha": "61ce55b04c03e10b028135d5e2750393d533b49c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f808b6f0a60d2d487cc361a355d5d42c731607b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f808b6f0a60d2d487cc361a355d5d42c731607b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f808b6f0a60d2d487cc361a355d5d42c731607b", "patch": "@@ -1,5 +1,10 @@\n Mon Jan  3 15:33:37 MET 2000  Jan Hubicka  <hubicka@freesoft.cz>\n \n+\t* combine.c (expand_compound_operation): Do not convert ZERO_EXTEND to\n+\tSIGN_EXTEND, convert SIGN_EXTEND to ZERO_EXTEND.\n+\t(make_compound_operation): Choose cheaper alternative between\n+\tZERO_EXTEND and SIGN_EXTEND when sign bit is not set.\n+\n \t* regclass.c (op_costs): Remove global variable.\n \t(record_reg_classes): New parameter \"op_costs\" and \"reg_pref\".\n \t(record_operand_costs): Break out from ..."}, {"sha": "2cb0c4561ab07895973cfbb188392343f7e38147", "filename": "gcc/combine.c", "status": "modified", "additions": 64, "deletions": 28, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f808b6f0a60d2d487cc361a355d5d42c731607b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f808b6f0a60d2d487cc361a355d5d42c731607b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0f808b6f0a60d2d487cc361a355d5d42c731607b", "patch": "@@ -5486,6 +5486,20 @@ expand_compound_operation (x)\n     default:\n       return x;\n     }\n+  /* Convert sign extension to zero extension, if we know that the high\n+     bit is not set, as this is easier to optimize.  It will be converted\n+     back to cheaper alternative in make_extraction.  */\n+  if (GET_CODE (x) == SIGN_EXTEND\n+      && (GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT\n+\t  && ((nonzero_bits (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n+\t\t& ~ (((unsigned HOST_WIDE_INT)\n+\t\t      GET_MODE_MASK (GET_MODE (XEXP (x, 0))))\n+\t\t     >> 1))\n+\t       == 0)))\n+    {\n+      rtx temp = gen_rtx_ZERO_EXTEND (GET_MODE (x), XEXP (x, 0));\n+      return expand_compound_operation (temp);\n+    }\n \n   /* We can optimize some special cases of ZERO_EXTEND.  */\n   if (GET_CODE (x) == ZERO_EXTEND)\n@@ -5533,30 +5547,6 @@ expand_compound_operation (x)\n \t      & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n \treturn SUBREG_REG (XEXP (x, 0));\n \n-      /* If sign extension is cheaper than zero extension, then use it\n-\t if we know that no extraneous bits are set, and that the high\n-\t bit is not set.  */\n-      if (flag_expensive_optimizations\n-\t  && ((GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT\n-\t       && ((nonzero_bits (XEXP (x, 0), GET_MODE (x))\n-\t\t    & ~ (((unsigned HOST_WIDE_INT)\n-\t\t\t  GET_MODE_MASK (GET_MODE (XEXP (x, 0))))\n-\t\t\t >> 1))\n-\t\t   == 0))\n-\t      || (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t\t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n-\t\t      <= HOST_BITS_PER_WIDE_INT)\n-\t\t  && (((HOST_WIDE_INT) STORE_FLAG_VALUE\n-\t\t       & ~ (((unsigned HOST_WIDE_INT)\n-\t\t\t     GET_MODE_MASK (GET_MODE (XEXP (x, 0))))\n-\t\t\t    >> 1))\n-\t\t      == 0))))\n-\t{\n-\t  rtx temp = gen_rtx_SIGN_EXTEND (GET_MODE (x), XEXP (x, 0));\n-\n-\t  if (rtx_cost (temp, SET) < rtx_cost (x, SET))\n-\t    return expand_compound_operation (temp);\n-\t}\n     }\n \n   /* If we reach here, we want to return a pair of shifts.  The inner\n@@ -5894,12 +5884,35 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t\t   ? gen_rtx_CLOBBER (tmode, const0_rtx)\n \t\t   : gen_rtx_combine (STRICT_LOW_PART, VOIDmode, new)));\n \n+      if (mode == tmode)\n+\treturn new;\n+\n+      /* If we know that no extraneous bits are set, and that the high\n+\t bit is not set, convert the extraction to the cheaper of\n+\t sign and zero extension, that are equivalent in these cases.  */\n+      if (flag_expensive_optimizations\n+\t  && (GET_MODE_BITSIZE (tmode) <= HOST_BITS_PER_WIDE_INT\n+\t      && ((nonzero_bits (new, tmode)\n+\t\t   & ~ (((unsigned HOST_WIDE_INT)\n+\t\t\t GET_MODE_MASK (tmode))\n+\t\t\t>> 1))\n+\t\t  == 0)))\n+\t{\n+\t  rtx temp = gen_rtx_ZERO_EXTEND (mode, new);\n+\t  rtx temp1 = gen_rtx_SIGN_EXTEND (mode, new);\n+\n+\t  /* Prefer ZERO_EXTENSION, since it gives more information to\n+\t     backends.  */\n+\t  if (rtx_cost (temp, SET) < rtx_cost (temp1, SET))\n+\t    return temp;\n+\t  return temp1;\n+\t}\n+\n       /* Otherwise, sign- or zero-extend unless we already are in the\n \t proper mode.  */\n \n-      return (mode == tmode ? new\n-\t      : gen_rtx_combine (unsignedp ? ZERO_EXTEND : SIGN_EXTEND,\n-\t\t\t\t mode, new));\n+      return (gen_rtx_combine (unsignedp ? ZERO_EXTEND : SIGN_EXTEND,\n+\t\t\t       mode, new));\n     }\n \n   /* Unless this is a COMPARE or we have a funny memory reference,\n@@ -6088,7 +6101,30 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n      have to zero extend.  Otherwise, we can just use a SUBREG.  */\n   if (pos_rtx != 0\n       && GET_MODE_SIZE (pos_mode) > GET_MODE_SIZE (GET_MODE (pos_rtx)))\n-    pos_rtx = gen_rtx_combine (ZERO_EXTEND, pos_mode, pos_rtx);\n+    {\n+      rtx temp = gen_rtx_combine (ZERO_EXTEND, pos_mode, pos_rtx);\n+\n+      /* If we know that no extraneous bits are set, and that the high\n+\t bit is not set, convert extraction to cheaper one - eighter\n+\t SIGN_EXTENSION or ZERO_EXTENSION, that are equivalent in these\n+\t cases.  */\n+      if (flag_expensive_optimizations\n+\t  && (GET_MODE_BITSIZE (GET_MODE (pos_rtx)) <= HOST_BITS_PER_WIDE_INT\n+\t      && ((nonzero_bits (pos_rtx, GET_MODE (pos_rtx))\n+\t\t   & ~ (((unsigned HOST_WIDE_INT)\n+\t\t\t GET_MODE_MASK (GET_MODE (pos_rtx)))\n+\t\t\t>> 1))\n+\t\t  == 0)))\n+\t{\n+\t  rtx temp1 = gen_rtx_SIGN_EXTEND (pos_mode, pos_rtx);\n+\n+\t  /* Preffer ZERO_EXTENSION, since it gives more information to\n+\t     backends.  */\n+\t  if (rtx_cost (temp1, SET) < rtx_cost (temp, SET))\n+\t    temp = temp1;\n+\t}\n+      pos_rtx = temp;\n+    }\n   else if (pos_rtx != 0\n \t   && GET_MODE_SIZE (pos_mode) < GET_MODE_SIZE (GET_MODE (pos_rtx)))\n     pos_rtx = gen_lowpart_for_combine (pos_mode, pos_rtx);"}]}