{"sha": "5d733372faa97c1c3943a20a252d000db37c738b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ3MzMzNzJmYWE5N2MxYzM5NDNhMjBhMjUyZDAwMGRiMzdjNzM4Yg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2019-08-02T18:46:51Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2019-08-02T18:46:51Z"}, "message": "rework Ada EH Machine_Occurrence deallocation\n\nIntroduce exception handler ABI #1 to ensure single release, no access\nafter release of reraised Machine_Occurrences, and no failure to\nre-reraise a Machine_Occurrence.\n\nUnlike Ada exceptions, foreign exceptions do not get a new\nMachine_Occurrence upon reraise, but each handler would delete the\nexception upon completion, normal or exceptional, save for the case of\na 'raise;' statement within the handler, that avoided the delete by\nclearing the exception pointer that the cleanup would use to release\nit.  The cleared exception pointer might then be used by a subsequent\nreraise within the same handler.  Get_Current_Excep.all would also\nexpose the Machine_Occurrence to reuse by Reraise_Occurrence, even for\nnative exceptions.\n\nUnder ABI #1, Begin_Handler_v1 claims responsibility for releasing an\nexception by saving its cleanup and setting it to Claimed_Cleanup.\nEnd_Handler_v1 restores the cleanup and runs it, as long as it isn't\nstill Claimed_Cleanup (which indicates an enclosing handler has\nalready claimed responsibility for releasing it), and as long as the\nsame exception is not being propagated up (the next handler of the\npropagating exception will then claim responsibility for releasing\nit), so reraise no longer needs to clear the exception pointer, and it\ncan just propagate the exception, just like Reraise_Occurrence.\n\nABI #1 is fully interoperable with ABI #0, i.e., exception handlers\nthat call the #0 primitives can be linked together with ones that call\nthe #1 primitives, and they will not misbehave.  When a #1 handler\nclaims responsibility for releasing an exception, even #0 reraises\ndynamically nested within it will refrain from releasing it.  However,\nwhen a #0 handler is a handler of a foreign exception that would have\nbeen responsible for releasing it with #1, a Reraise_Occurrence of\nthat foreign or other Machine_Occurrence-carrying exception may still\ncause the exception to be released multiple times, and to be used\nafter it is first released, even if other handlers of the foreign\nexception use #1.\n\n\nfor  gcc/ada/ChangeLog\n\n\t* libgnat/a-exexpr.adb (Begin_Handler_v1, End_Handler_v1): New.\n\t(Claimed_Cleanup): New.\n\t(Begin_Handler, End_Handler): Document.\n\t* gcc-interface/trans.c (gigi): Switch to exception handler\n\tABI #1.\n\t(Exception_Handler_to_gnu_gcc): Save the original cleanup\n\treturned by begin handler, pass it to end handler, and use\n\tEH_ELSE_EXPR to pass a propagating exception to end handler.\n\t(gnat_to_gnu): Leave the exception pointer alone for reraise.\n\t(add_cleanup): Handle EH_ELSE_EXPR, require it by itself.\n\nFrom-SVN: r274029", "tree": {"sha": "9c33de25ac3ceb1916f205d3475222ff71a38272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c33de25ac3ceb1916f205d3475222ff71a38272"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d733372faa97c1c3943a20a252d000db37c738b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d733372faa97c1c3943a20a252d000db37c738b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d733372faa97c1c3943a20a252d000db37c738b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d733372faa97c1c3943a20a252d000db37c738b/comments", "author": null, "committer": null, "parents": [{"sha": "59e01f364927e66c0bb1ebc22c401cf2630616c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59e01f364927e66c0bb1ebc22c401cf2630616c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59e01f364927e66c0bb1ebc22c401cf2630616c0"}], "stats": {"total": 363, "additions": 316, "deletions": 47}, "files": [{"sha": "bcfc8cc1ae4578a31c9c26972b25c66b72a5e63f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d733372faa97c1c3943a20a252d000db37c738b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d733372faa97c1c3943a20a252d000db37c738b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5d733372faa97c1c3943a20a252d000db37c738b", "patch": "@@ -1,3 +1,16 @@\n+2019-08-02  Alexandre Oliva <oliva@adacore.com>\n+\n+\t* libgnat/a-exexpr.adb (Begin_Handler_v1, End_Handler_v1): New.\n+\t(Claimed_Cleanup): New.\n+\t(Begin_Handler, End_Handler): Document.\n+\t* gcc-interface/trans.c (gigi): Switch to exception handler\n+\tABI #1.\n+\t(Exception_Handler_to_gnu_gcc): Save the original cleanup\n+\treturned by begin handler, pass it to end handler, and use\n+\tEH_ELSE_EXPR to pass a propagating exception to end handler.\n+\t(gnat_to_gnu): Leave the exception pointer alone for reraise.\n+\t(add_cleanup): Handle EH_ELSE_EXPR, require it by itself.\n+\n 2019-07-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Check_Aspect_At_End_Of_Declarations,"}, {"sha": "b484bc78532a62e293eea29878c1e4e51d5364d8", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 118, "deletions": 44, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d733372faa97c1c3943a20a252d000db37c738b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d733372faa97c1c3943a20a252d000db37c738b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=5d733372faa97c1c3943a20a252d000db37c738b", "patch": "@@ -524,22 +524,27 @@ gigi (Node_Id gnat_root,\n        NULL_TREE, is_default, true, true, true, false, false, NULL, Empty);\n \n   /* Hooks to call when entering/leaving an exception handler.  */\n-  ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n-\n+  ftype = build_function_type_list (ptr_type_node,\n+\t\t\t\t    ptr_type_node, NULL_TREE);\n   begin_handler_decl\n-    = create_subprog_decl (get_identifier (\"__gnat_begin_handler\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE,\n+    = create_subprog_decl (get_identifier (\"__gnat_begin_handler_v1\"),\n+\t\t\t   NULL_TREE, ftype, NULL_TREE,\n \t\t\t   is_default, true, true, true, false, false, NULL,\n \t\t\t   Empty);\n-  /* __gnat_begin_handler is a dummy procedure.  */\n+  /* __gnat_begin_handler_v1 is not a dummy procedure, but we arrange\n+     for it not to throw.  */\n   TREE_NOTHROW (begin_handler_decl) = 1;\n \n+  ftype = build_function_type_list (ptr_type_node,\n+\t\t\t\t    ptr_type_node, ptr_type_node,\n+\t\t\t\t    ptr_type_node, NULL_TREE);\n   end_handler_decl\n-    = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n+    = create_subprog_decl (get_identifier (\"__gnat_end_handler_v1\"), NULL_TREE,\n \t\t\t   ftype, NULL_TREE,\n \t\t\t   is_default, true, true, true, false, false, NULL,\n \t\t\t   Empty);\n \n+  ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n   unhandled_except_decl\n     = create_subprog_decl (get_identifier (\"__gnat_unhandled_except_handler\"),\n \t\t\t   NULL_TREE, ftype, NULL_TREE,\n@@ -6201,59 +6206,120 @@ Exception_Handler_to_gnu_gcc (Node_Id gnat_node)\n   start_stmt_group ();\n   gnat_pushlevel ();\n \n-  /* Expand a call to the begin_handler hook at the beginning of the handler,\n-     and arrange for a call to the end_handler hook to occur on every possible\n-     exit path.\n+  /* Expand a call to the begin_handler hook at the beginning of the\n+     handler, and arrange for a call to the end_handler hook to occur\n+     on every possible exit path.  GDB sets a breakpoint in the\n+     begin_handler for catchpoints.\n \n-     The hooks expect a pointer to the low level occurrence. This is required\n-     for our stack management scheme because a raise inside the handler pushes\n-     a new occurrence on top of the stack, which means that this top does not\n-     necessarily match the occurrence this handler was dealing with.\n+     A v1 begin handler saves the cleanup from the exception object,\n+     and marks the exception as in use, so that it will not be\n+     released by other handlers.  A v1 end handler restores the\n+     cleanup and releases the exception object, unless it is still\n+     claimed, or the exception is being propagated (reraised).\n \n      __builtin_eh_pointer references the exception occurrence being\n-     propagated. Upon handler entry, this is the exception for which the\n-     handler is triggered. This might not be the case upon handler exit,\n-     however, as we might have a new occurrence propagated by the handler's\n-     body, and the end_handler hook called as a cleanup in this context.\n-\n-     We use a local variable to retrieve the incoming value at handler entry\n-     time, and reuse it to feed the end_handler hook's argument at exit.  */\n-\n+     handled or propagated.  Within the handler region, it is the\n+     former, but within the else branch of the EH_ELSE_EXPR, i.e. the\n+     exceptional cleanup path, it is the latter, so we must save the\n+     occurrence being handled early on, so that, should an exception\n+     be (re)raised, we can release the current exception, or figure\n+     out we're not to release it because we're propagating a reraise\n+     thereof.\n+\n+     We use local variables to retrieve the incoming value at handler\n+     entry time (EXPTR), the saved cleanup (EXCLN) and the token\n+     (EXVTK), and reuse them to feed the end_handler hook's argument\n+     at exit.  */\n+\n+  /* CODE: void *EXPTR = __builtin_eh_pointer (0); */\n   tree gnu_current_exc_ptr\n     = build_call_expr (builtin_decl_explicit (BUILT_IN_EH_POINTER),\n \t\t       1, integer_zero_node);\n-  tree prev_gnu_incoming_exc_ptr = gnu_incoming_exc_ptr;\n-  gnu_incoming_exc_ptr\n+  tree exc_ptr\n     = create_var_decl (get_identifier (\"EXPTR\"), NULL_TREE,\n \t\t       ptr_type_node, gnu_current_exc_ptr,\n-\t\t       false, false, false, false, false, true, true,\n+\t\t       true, false, false, false, false, true, true,\n \t\t       NULL, gnat_node);\n \n-  add_stmt_with_node (build_call_n_expr (begin_handler_decl, 1,\n-\t\t\t\t\t gnu_incoming_exc_ptr),\n-\t\t      gnat_node);\n+  tree prev_gnu_incoming_exc_ptr = gnu_incoming_exc_ptr;\n+  gnu_incoming_exc_ptr = exc_ptr;\n+\n+  /* begin_handler_decl must not throw, so we can use it as an\n+     initializer for a variable used in cleanups.\n+\n+     CODE: void *EXCLN = __gnat_begin_handler_v1 (EXPTR); */\n+  tree exc_cleanup\n+    = create_var_decl (get_identifier (\"EXCLN\"), NULL_TREE,\n+\t\t       ptr_type_node,\n+\t\t       build_call_n_expr (begin_handler_decl, 1,\n+\t\t\t\t\t  exc_ptr),\n+\t\t       true, false, false, false, false,\n+\t\t       true, true, NULL, gnat_node);\n \n   /* Declare and initialize the choice parameter, if present.  */\n   if (Present (Choice_Parameter (gnat_node)))\n     {\n       tree gnu_param\n \t= gnat_to_gnu_entity (Choice_Parameter (gnat_node), NULL_TREE, true);\n \n+      /* CODE: __gnat_set_exception_parameter (&choice_param, EXPTR); */\n       add_stmt (build_call_n_expr\n \t\t(set_exception_parameter_decl, 2,\n \t\t build_unary_op (ADDR_EXPR, NULL_TREE, gnu_param),\n \t\t gnu_incoming_exc_ptr));\n     }\n \n+  /* CODE: <handler proper> */\n   add_stmt_list (Statements (gnat_node));\n \n-  /* We don't have an End_Label at hand to set the location of the cleanup\n-     actions, so we use that of the exception handler itself instead.  */\n-  tree stmt = build_call_n_expr (end_handler_decl, 1, gnu_incoming_exc_ptr);\n+  tree call = build_call_n_expr (end_handler_decl, 3,\n+\t\t\t\t exc_ptr,\n+\t\t\t\t exc_cleanup,\n+\t\t\t\t null_pointer_node);\n+  /* If the handler can only end by falling off the end, don't bother\n+     with cleanups.  */\n   if (stmt_list_cannot_alter_control_flow_p (Statements (gnat_node)))\n-    add_stmt_with_node (stmt, gnat_node);\n+    /* CODE: __gnat_end_handler_v1 (EXPTR, EXCLN, NULL);  */\n+    add_stmt_with_node (call, gnat_node);\n+  /* Otherwise, all of the above is after\n+     CODE: try {\n+\n+     The call above will appear after\n+     CODE: } finally {\n+\n+     And the code below will appear after\n+     CODE: } else {\n+\n+     The else block to a finally block is taken instead of the finally\n+     block when an exception propagates out of the try block.  */\n   else\n-    add_cleanup (stmt, gnat_node);\n+    {\n+      start_stmt_group ();\n+      gnat_pushlevel ();\n+      /* CODE: void *EXPRP = __builtin_eh_handler (0); */\n+      tree prop_ptr\n+\t= create_var_decl (get_identifier (\"EXPRP\"), NULL_TREE,\n+\t\t\t   ptr_type_node,\n+\t\t\t   build_call_expr (builtin_decl_explicit\n+\t\t\t\t\t    (BUILT_IN_EH_POINTER),\n+\t\t\t\t\t    1, integer_zero_node),\n+\t\t\t   true, false, false, false, false,\n+\t\t\t   true, true, NULL, gnat_node);\n+\n+      /* CODE: __gnat_end_handler_v1 (EXPTR, EXCLN, EXPRP);  */\n+      tree ecall = build_call_n_expr (end_handler_decl, 3,\n+\t\t\t\t      exc_ptr,\n+\t\t\t\t      exc_cleanup,\n+\t\t\t\t      prop_ptr);\n+\n+      add_stmt_with_node (ecall, gnat_node);\n+\n+      /* CODE: } */\n+      gnat_poplevel ();\n+      tree eblk = end_stmt_group ();\n+      tree ehls = build2 (EH_ELSE_EXPR, void_type_node, call, eblk);\n+      add_cleanup (ehls, gnat_node);\n+    }\n \n   gnat_poplevel ();\n \n@@ -8270,19 +8336,11 @@ gnat_to_gnu (Node_Id gnat_node)\n       gcc_assert (No (Name (gnat_node)) && Back_End_Exceptions ());\n \n       start_stmt_group ();\n-      gnat_pushlevel ();\n \n-      /* Clear the current exception pointer so that the occurrence won't be\n-\t deallocated.  */\n-      gnu_expr = create_var_decl (get_identifier (\"SAVED_EXPTR\"), NULL_TREE,\n-\t\t\t\t  ptr_type_node, gnu_incoming_exc_ptr,\n-\t\t\t\t  false, false, false, false, false,\n-\t\t\t\t  true, true, NULL, gnat_node);\n+      add_stmt_with_node (build_call_n_expr (reraise_zcx_decl, 1,\n+\t\t\t\t\t     gnu_incoming_exc_ptr),\n+\t\t\t  gnat_node);\n \n-      add_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_incoming_exc_ptr,\n-\t\t\t\t build_int_cst (ptr_type_node, 0)));\n-      add_stmt (build_call_n_expr (reraise_zcx_decl, 1, gnu_expr));\n-      gnat_poplevel ();\n       gnu_result = end_stmt_group ();\n       break;\n \n@@ -9073,7 +9131,23 @@ add_cleanup (tree gnu_cleanup, Node_Id gnat_node)\n {\n   if (Present (gnat_node))\n     set_expr_location_from_node (gnu_cleanup, gnat_node, true);\n-  append_to_statement_list (gnu_cleanup, &current_stmt_group->cleanups);\n+  /* An EH_ELSE_EXPR must be by itself, and that's all we need when we\n+     use it.  The assert below makes sure that is so.  Should we ever\n+     need more than that, we could combine EH_ELSE_EXPRs, and copy\n+     non-EH_ELSE_EXPR stmts into both cleanup paths of an\n+     EH_ELSE_EXPR.  */\n+  if (TREE_CODE (gnu_cleanup) == EH_ELSE_EXPR)\n+    {\n+      gcc_assert (!current_stmt_group->cleanups);\n+      current_stmt_group->cleanups = gnu_cleanup;\n+    }\n+  else\n+    {\n+      gcc_assert (!current_stmt_group->cleanups\n+\t\t  || (TREE_CODE (current_stmt_group->cleanups)\n+\t\t      != EH_ELSE_EXPR));\n+      append_to_statement_list (gnu_cleanup, &current_stmt_group->cleanups);\n+    }\n }\n \n /* Set the BLOCK node corresponding to the current code group to GNU_BLOCK.  */"}, {"sha": "5e72fd6e3f2a5df5727de8d93e5fc6de6fc90058", "filename": "gcc/ada/libgnat/a-exexpr.adb", "status": "modified", "additions": 185, "deletions": 3, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d733372faa97c1c3943a20a252d000db37c738b/gcc%2Fada%2Flibgnat%2Fa-exexpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d733372faa97c1c3943a20a252d000db37c738b/gcc%2Fada%2Flibgnat%2Fa-exexpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-exexpr.adb?ref=5d733372faa97c1c3943a20a252d000db37c738b", "patch": "@@ -197,15 +197,75 @@ package body Exception_Propagation is\n    --  whose machine occurrence is Mo. The message is empty, the backtrace\n    --  is empty too and the exception identity is Foreign_Exception.\n \n-   --  Hooks called when entering/leaving an exception handler for a given\n-   --  occurrence, aimed at handling the stack of active occurrences. The\n-   --  calls are generated by gigi in tree_transform/N_Exception_Handler.\n+   --  Hooks called when entering/leaving an exception handler for a\n+   --  given occurrence.  The calls are generated by gigi in\n+   --  Exception_Handler_to_gnu_gcc.\n+\n+   --  Begin_Handler_v1, called when entering an exception handler,\n+   --  claims responsibility for the handler to release the\n+   --  GCC_Exception occurrence.  End_Handler_v1, called when\n+   --  leaving the handler, releases the occurrence, unless the\n+   --  occurrence is propagating further up, or the handler is\n+   --  dynamically nested in the context of another handler that\n+   --  claimed responsibility for releasing that occurrence.\n+\n+   --  Responsibility is claimed by changing the Cleanup field to\n+   --  Claimed_Cleanup, which enables claimed exceptions to be\n+   --  recognized, and avoids accidental releases even by foreign\n+   --  handlers.\n+\n+   function Begin_Handler_v1\n+     (GCC_Exception : not null GCC_Exception_Access)\n+     return System.Address;\n+   pragma Export (C, Begin_Handler_v1, \"__gnat_begin_handler_v1\");\n+   --  Called when entering an exception handler.  Claim\n+   --  responsibility for releasing GCC_Exception, by setting the\n+   --  cleanup/release function to Claimed_Cleanup, and return the\n+   --  address of the previous cleanup/release function.\n+\n+   procedure End_Handler_v1\n+     (GCC_Exception : not null GCC_Exception_Access;\n+      Saved_Cleanup : System.Address;\n+      Propagating_Exception : GCC_Exception_Access);\n+   pragma Export (C, End_Handler_v1, \"__gnat_end_handler_v1\");\n+   --  Called when leaving an exception handler.  Restore the\n+   --  Saved_Cleanup in the GCC_Exception occurrence, and then release\n+   --  it, unless it remains claimed by an enclosing handler, or\n+   --  GCC_Exception and Propagating_Exception are the same\n+   --  occurrence.  Propagating_Exception could be either an\n+   --  occurrence (re)raised within the handler of GCC_Exception, when\n+   --  we're executing as an exceptional cleanup, or null, if we're\n+   --  completing the handler of GCC_Exception normally.\n+\n+   procedure Claimed_Cleanup\n+     (Reason : Unwind_Reason_Code;\n+      GCC_Exception : not null GCC_Exception_Access);\n+   pragma Export (C, Claimed_Cleanup, \"__gnat_claimed_cleanup\");\n+   --  A do-nothing placeholder installed as GCC_Exception.Cleanup\n+   --  while handling GCC_Exception, to claim responsibility for\n+   --  releasing it, and to stop it from being accidentally released.\n+\n+   --  The following are version 0 implementations of the version 1\n+   --  hooks above.  They remain in place for compatibility with the\n+   --  output of compilers that still use version 0, such as those\n+   --  used during bootstrap.  They are interoperable with the v1\n+   --  hooks, except that the older versions may malfunction when\n+   --  handling foreign exceptions passed to Reraise_Occurrence.\n \n    procedure Begin_Handler (GCC_Exception : not null GCC_Exception_Access);\n    pragma Export (C, Begin_Handler, \"__gnat_begin_handler\");\n+   --  Called when entering an exception handler translated by an old\n+   --  compiler.  It does nothing.\n \n    procedure End_Handler (GCC_Exception : GCC_Exception_Access);\n    pragma Export (C, End_Handler, \"__gnat_end_handler\");\n+   --  Called when leaving an exception handler translated by an old\n+   --  compiler.  It releases GCC_Exception, unless it is null.  It is\n+   --  only ever null when the handler has a 'raise;' translated by a\n+   --  v0-using compiler.  The artificial handler variable passed to\n+   --  End_Handler was set to null to tell End_Handler to refrain from\n+   --  releasing the reraised exception.  In v1 safer ways are used to\n+   --  accomplish that.\n \n    --------------------------------------------------------------------\n    -- Accessors to Basic Components of a GNAT Exception Data Pointer --\n@@ -352,6 +412,128 @@ package body Exception_Propagation is\n       end if;\n    end Setup_Current_Excep;\n \n+   ----------------------\n+   -- Begin_Handler_v1 --\n+   ----------------------\n+\n+   function Begin_Handler_v1\n+     (GCC_Exception : not null GCC_Exception_Access)\n+     return System.Address is\n+      Saved_Cleanup : constant System.Address := GCC_Exception.Cleanup;\n+   begin\n+      --  Claim responsibility for releasing this exception, and stop\n+      --  others from releasing it.\n+      GCC_Exception.Cleanup := Claimed_Cleanup'Address;\n+      return Saved_Cleanup;\n+   end Begin_Handler_v1;\n+\n+   --------------------\n+   -- End_Handler_v1 --\n+   --------------------\n+\n+   procedure End_Handler_v1\n+     (GCC_Exception : not null GCC_Exception_Access;\n+      Saved_Cleanup : System.Address;\n+      Propagating_Exception : GCC_Exception_Access) is\n+   begin\n+      GCC_Exception.Cleanup := Saved_Cleanup;\n+      --  Restore the Saved_Cleanup, so that it is either used to\n+      --  release GCC_Exception below, or transferred to the next\n+      --  handler of the Propagating_Exception occurrence.  The\n+      --  following test ensures that an occurrence is only released\n+      --  once, even after reraises.\n+      --\n+      --  The idea is that the GCC_Exception is not to be released\n+      --  unless it had an unclaimed Cleanup when the handler started\n+      --  (see Begin_Handler_v1 above), but if we propagate across its\n+      --  handler a reraise of the same exception, we transfer to the\n+      --  Propagating_Exception the responsibility for running the\n+      --  Saved_Cleanup when its handler completes.\n+      --\n+      --  This ownership transfer mechanism ensures safety, as in\n+      --  single release and no dangling pointers, because there is no\n+      --  way to hold on to the Machine_Occurrence of an\n+      --  Exception_Occurrence: the only situations in which another\n+      --  Exception_Occurrence gets the same Machine_Occurrence are\n+      --  through Reraise_Occurrence, and plain reraise, and so we\n+      --  have the following possibilities:\n+      --\n+      --  - Reraise_Occurrence is handled within the running handler,\n+      --  and so when completing the dynamically nested handler, we\n+      --  must NOT release the exception.  A Claimed_Cleanup upon\n+      --  entry of the nested handler, installed when entering the\n+      --  enclosing handler, ensures the exception will not be\n+      --  released by the nested handler, but rather by the enclosing\n+      --  handler.\n+      --\n+      --  - Reraise_Occurrence/reraise escapes the running handler,\n+      --  and we run as an exceptional cleanup for GCC_Exception.  The\n+      --  Saved_Cleanup was reinstalled, but since we're propagating\n+      --  the same machine occurrence, we do not release it.  Instead,\n+      --  we transfer responsibility for releasing it to the eventual\n+      --  handler of the propagating exception.\n+      --\n+      --  - An unrelated exception propagates through the running\n+      --  handler.  We restored GCC_Exception.Saved_Cleanup above.\n+      --  Since we're propagating a different exception, we proceed to\n+      --  release GCC_Exception, unless Saved_Cleanup was\n+      --  Claimed_Cleanup, because then we know we're not in the\n+      --  outermost handler for GCC_Exception.\n+      --\n+      --  - The handler completes normally, so it reinstalls the\n+      --  Saved_Cleanup and runs it, unless it was Claimed_Cleanup.\n+      --  If Saved_Cleanup is null, Unwind_DeleteException (currently)\n+      --  has no effect, so we could skip it, but if it is ever\n+      --  changed to do more in this case, we're ready for that,\n+      --  calling it exactly once.\n+      if Saved_Cleanup /= Claimed_Cleanup'Address\n+        and then\n+        Propagating_Exception /= GCC_Exception\n+      then\n+         declare\n+            Current : constant EOA := Get_Current_Excep.all;\n+            Cur_Occ : constant GCC_Exception_Access\n+              := To_GCC_Exception (Current.Machine_Occurrence);\n+         begin\n+            --  If we are releasing the Machine_Occurrence of the current\n+            --  exception, reset the access to it, so that it is no\n+            --  longer accessible.\n+            if Cur_Occ = GCC_Exception then\n+               Current.Machine_Occurrence := System.Null_Address;\n+            end if;\n+         end;\n+         Unwind_DeleteException (GCC_Exception);\n+      end if;\n+   end End_Handler_v1;\n+\n+   ---------------------\n+   -- Claimed_Cleanup --\n+   ---------------------\n+\n+   procedure Claimed_Cleanup\n+     (Reason : Unwind_Reason_Code;\n+      GCC_Exception : not null GCC_Exception_Access) is\n+      pragma Unreferenced (Reason);\n+      pragma Unreferenced (GCC_Exception);\n+   begin\n+      --  This procedure should never run.  If it does, it's either a\n+      --  version 0 handler or a foreign handler, attempting to\n+      --  release an exception while a version 1 handler that claimed\n+      --  responsibility for releasing the exception remains still\n+      --  active.  This placeholder stops GCC_Exception from being\n+      --  released by them.\n+\n+      --  We could get away with just Null_Address instead, with\n+      --  nearly the same effect, but with this placeholder we can\n+      --  detect and report unexpected releases, and we can tell apart\n+      --  a GCC_Exception without a Cleanup, from one with another\n+      --  active handler, so as to still call Unwind_DeleteException\n+      --  exactly once: currently, Unwind_DeleteException does nothing\n+      --  when the Cleanup is null, but should it ever be changed to\n+      --  do more, we'll still be safe.\n+      null;\n+   end Claimed_Cleanup;\n+\n    -------------------\n    -- Begin_Handler --\n    -------------------"}]}