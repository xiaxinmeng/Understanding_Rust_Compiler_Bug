{"sha": "a9c5ddf90c294e351661f3b487315b8602f2851c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTljNWRkZjkwYzI5NGUzNTE2NjFmM2I0ODczMTViODYwMmYyODUxYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-08-08T21:38:24Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-08-08T21:38:24Z"}, "message": "re PR middle-end/22439 (ICE with char VLA and __SIZE_TYPE__ argument (so no cast))\n\n        PR 22439\n        * gimplify.c (gimplify_one_sizepos): Preserve the original type.\n\nFrom-SVN: r102879", "tree": {"sha": "025597e589fb555cd81a2643920c6a05aac62efc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/025597e589fb555cd81a2643920c6a05aac62efc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9c5ddf90c294e351661f3b487315b8602f2851c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c5ddf90c294e351661f3b487315b8602f2851c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9c5ddf90c294e351661f3b487315b8602f2851c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c5ddf90c294e351661f3b487315b8602f2851c/comments", "author": null, "committer": null, "parents": [{"sha": "224694090c01069cec258efe72c5115b7ef2a879", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224694090c01069cec258efe72c5115b7ef2a879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/224694090c01069cec258efe72c5115b7ef2a879"}], "stats": {"total": 39, "additions": 35, "deletions": 4}, "files": [{"sha": "b01aa11f41ae0a52e6711dcc6ed12081bc9c8cea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c5ddf90c294e351661f3b487315b8602f2851c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c5ddf90c294e351661f3b487315b8602f2851c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9c5ddf90c294e351661f3b487315b8602f2851c", "patch": "@@ -1,3 +1,8 @@\n+2005-08-08  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 22439\n+\t* gimplify.c (gimplify_one_sizepos): Preserve the original type.\n+\n 2005-08-08  Bob Wilson  <bob.wilson@acm.org>\n \n \t* expr.c (write_complex_part): Return after handling MEM."}, {"sha": "d207e7c554697c9dc62cd12ca1ec74c768d31472", "filename": "gcc/gimplify.c", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c5ddf90c294e351661f3b487315b8602f2851c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c5ddf90c294e351661f3b487315b8602f2851c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=a9c5ddf90c294e351661f3b487315b8602f2851c", "patch": "@@ -4610,18 +4610,44 @@ gimplify_type_sizes (tree type, tree *list_p)\n void\n gimplify_one_sizepos (tree *expr_p, tree *stmt_p)\n {\n+  tree type, expr = *expr_p;\n+\n   /* We don't do anything if the value isn't there, is constant, or contains\n      A PLACEHOLDER_EXPR.  We also don't want to do anything if it's already\n      a VAR_DECL.  If it's a VAR_DECL from another function, the gimplifier\n      will want to replace it with a new variable, but that will cause problems\n      if this type is from outside the function.  It's OK to have that here.  */\n-  if (*expr_p == NULL_TREE || TREE_CONSTANT (*expr_p)\n-      || TREE_CODE (*expr_p) == VAR_DECL\n-      || CONTAINS_PLACEHOLDER_P (*expr_p))\n+  if (expr == NULL_TREE || TREE_CONSTANT (expr)\n+      || TREE_CODE (expr) == VAR_DECL\n+      || CONTAINS_PLACEHOLDER_P (expr))\n     return;\n \n-  *expr_p = unshare_expr (*expr_p);\n+  type = TREE_TYPE (expr);\n+  *expr_p = unshare_expr (expr);\n+\n   gimplify_expr (expr_p, stmt_p, NULL, is_gimple_val, fb_rvalue);\n+  expr = *expr_p;\n+\n+  /* Verify that we've an exact type match with the original expression.\n+     In particular, we do not wish to drop a \"sizetype\" in favour of a\n+     type of similar dimensions.  We don't want to pollute the generic\n+     type-stripping code with this knowledge because it doesn't matter\n+     for the bulk of GENERIC/GIMPLE.  It only matters that TYPE_SIZE_UNIT\n+     and friends retain their \"sizetype-ness\".  */\n+  if (TREE_TYPE (expr) != type && TYPE_IS_SIZETYPE (type))\n+    {\n+      tree tmp;\n+\n+      *expr_p = create_tmp_var (type, NULL);\n+      tmp = build1 (NOP_EXPR, type, expr);\n+      tmp = build2 (MODIFY_EXPR, type, *expr_p, expr);\n+      if (EXPR_HAS_LOCATION (expr))\n+\tSET_EXPR_LOCUS (tmp, EXPR_LOCUS (expr));\n+      else\n+\tSET_EXPR_LOCATION (tmp, input_location);\n+\n+      gimplify_and_add (tmp, stmt_p);\n+    }\n }\n \f\n #ifdef ENABLE_CHECKING"}]}