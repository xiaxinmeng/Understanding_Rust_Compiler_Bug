{"sha": "e7749837caaa5c7a7fddea3e8eb90b852cead3d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc3NDk4MzdjYWFhNWM3YTdmZGRlYTNlOGViOTBiODUyY2VhZDNkNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-11-05T00:49:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-11-05T00:49:03Z"}, "message": "bitmap.h (BITMAP_XFREE): New.\n\n        * bitmap.h (BITMAP_XFREE): New.\n        * flow.c (life_analysis): Use it.\n        (life_analysis_1): Free blocks.\n\n        * combine.c (undo_commit): New.\n        (try_combine): Use it.  Don't zap undobuf.undos.\n        (combine_instructions): Don't zap undobuf.undos; free the\n        undobuf.frees list.\n\n        * local-alloc.c (local_alloc): Free qty_phys_num_sugg.\n\n        * stmt.c (cost_table_): New.\n        (estimate_case_costs): Use it instead of xmalloc.\n\n        * toplev.c (compile_file): Reuse dumpname memory instead\n        of strdup'ing it.\n\nFrom-SVN: r30404", "tree": {"sha": "36caca6632c74bf9cd783c44f1c99239c1b55570", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36caca6632c74bf9cd783c44f1c99239c1b55570"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7749837caaa5c7a7fddea3e8eb90b852cead3d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7749837caaa5c7a7fddea3e8eb90b852cead3d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7749837caaa5c7a7fddea3e8eb90b852cead3d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/comments", "author": null, "committer": null, "parents": [{"sha": "920a303df913c5bcc6912ce722bee38e8fc04197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/920a303df913c5bcc6912ce722bee38e8fc04197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/920a303df913c5bcc6912ce722bee38e8fc04197"}], "stats": {"total": 99, "additions": 80, "deletions": 19}, "files": [{"sha": "512eabaa706a95c2c89c305f8674a23210981d0c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7749837caaa5c7a7fddea3e8eb90b852cead3d6", "patch": "@@ -1,3 +1,22 @@\n+Thu Nov  4 16:44:53 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* bitmap.h (BITMAP_XFREE): New.\n+\t* flow.c (life_analysis): Use it.\n+\t(life_analysis_1): Free blocks.\n+\n+\t* combine.c (undo_commit): New.\n+\t(try_combine): Use it.  Don't zap undobuf.undos.\n+\t(combine_instructions): Don't zap undobuf.undos; free the\n+\tundobuf.frees list.\n+\n+\t* local-alloc.c (local_alloc): Free qty_phys_num_sugg.\n+\n+\t* stmt.c (cost_table_): New.\n+\t(estimate_case_costs): Use it instead of xmalloc.\n+\n+\t* toplev.c (compile_file): Reuse dumpname memory instead\n+\tof strdup'ing it.\n+\n Thu Nov  4 16:36:44 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* reg-stack.c (convert_regs_1): Initialize target_stack->top"}, {"sha": "99f45492e22b0ea03c6383d5a372cc7b6611022c", "filename": "gcc/bitmap.h", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=e7749837caaa5c7a7fddea3e8eb90b852cead3d6", "patch": "@@ -119,13 +119,24 @@ extern void debug_bitmap PROTO((bitmap));\n   bitmap_initialize ((bitmap) xmalloc (sizeof (bitmap_head)))\n \n /* Do any cleanup needed on a bitmap when it is no longer used.  */\n-#define BITMAP_FREE(BITMAP)\t\t\t\t\t\\\n-do {\t\t\t\t\\\n-  if (BITMAP)\t\t\t\\\n-    {\t\t\t\t\\\n-      bitmap_clear (BITMAP);\t\\\n-      (BITMAP) = 0;\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+#define BITMAP_FREE(BITMAP)\t\t\t\\\n+do {\t\t\t\t\t\t\\\n+  if (BITMAP)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      bitmap_clear (BITMAP);\t\t\t\\\n+      (BITMAP) = 0;\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Do any cleanup needed on an xmalloced bitmap when it is no longer used.  */\n+#define BITMAP_XFREE(BITMAP)\t\t\t\\\n+do {\t\t\t\t\t\t\\\n+  if (BITMAP)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      bitmap_clear (BITMAP);\t\t\t\\\n+      free (BITMAP);\t\t\t\t\\\n+      (BITMAP) = 0;\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n } while (0)\n \n /* Do any one-time initializations needed for bitmaps.  */"}, {"sha": "4a1cb0ee62c8d36d4722e349572719debee561d2", "filename": "gcc/combine.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e7749837caaa5c7a7fddea3e8eb90b852cead3d6", "patch": "@@ -361,6 +361,7 @@ static int combinable_i3pat\tPROTO((rtx, rtx *, rtx, rtx, int, rtx *));\n static int contains_muldiv\tPROTO((rtx));\n static rtx try_combine\t\tPROTO((rtx, rtx, rtx));\n static void undo_all\t\tPROTO((void));\n+static void undo_commit\t\tPROTO((void));\n static rtx *find_split_point\tPROTO((rtx *, rtx));\n static rtx subst\t\tPROTO((rtx, rtx, rtx, int, int));\n static rtx combine_simplify_rtx\tPROTO((rtx, enum machine_mode, int, int));\n@@ -495,7 +496,6 @@ combine_instructions (f, nregs)\n   combine_merges = 0;\n   combine_extras = 0;\n   combine_successes = 0;\n-  undobuf.undos = undobuf.previous_undos = 0;\n \n   combine_max_regno = nregs;\n \n@@ -717,6 +717,16 @@ combine_instructions (f, nregs)\n   free (reg_last_set_sign_bit_copies);\n   free (uid_cuid);\n \n+  {\n+    struct undo *undo, *next;\n+    for (undo = undobuf.frees; undo; undo = next)\n+      {\n+\tnext = undo->next;\n+\tfree (undo);\n+      }\n+    undobuf.frees = 0;\n+  }\n+\n   total_attempts += combine_attempts;\n   total_merges += combine_merges;\n   total_extras += combine_extras;\n@@ -1461,8 +1471,6 @@ try_combine (i3, i2, i1)\n     return 0;\n \n   combine_attempts++;\n-\n-  undobuf.undos = undobuf.previous_undos = 0;\n   undobuf.other_insn = 0;\n \n   /* Save the current high-water-mark so we can free storage if we didn't\n@@ -2620,6 +2628,7 @@ try_combine (i3, i2, i1)\n   }\n \n   combine_successes++;\n+  undo_commit ();\n \n   /* Clear this here, so that subsequent get_last_value calls are not\n      affected.  */\n@@ -2659,6 +2668,24 @@ undo_all ()\n      affected.  */\n   subst_prev_insn = NULL_RTX;\n }\n+\n+/* We've committed to accepting the changes we made.  Move all\n+   of the undos to the free list.  */\n+\n+static void\n+undo_commit ()\n+{\n+  struct undo *undo, *next;\n+\n+  for (undo = undobuf.undos; undo; undo = next)\n+    {\n+      next = undo->next;\n+      undo->next = undobuf.frees;\n+      undobuf.frees = undo;\n+    }\n+  undobuf.undos = undobuf.previous_undos = 0;\n+}\n+\n \f\n /* Find the innermost point within the rtx at LOC, possibly LOC itself,\n    where we have an arithmetic expression and return that point.  LOC will"}, {"sha": "43688ae11d3ef53f339c278686692a7c1730b606", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e7749837caaa5c7a7fddea3e8eb90b852cead3d6", "patch": "@@ -2466,8 +2466,7 @@ life_analysis (f, nregs, file, remove_dead_code)\n   if (file)\n     dump_flow_info (file);\n \n-  BITMAP_FREE (uid_volatile);\n-  free (uid_volatile);\n+  BITMAP_XFREE (uid_volatile);\n   free_basic_block_vars (1);\n }\n \n@@ -2940,6 +2939,7 @@ life_analysis_1 (f, nregs, flags)\n     blocks = sbitmap_alloc (n_basic_blocks);\n     sbitmap_ones (blocks);\n     calculate_global_regs_live (blocks, blocks, flags & PROP_SCAN_DEAD_CODE);\n+    sbitmap_free (blocks);\n   }\n \n   /* The only pseudos that are live at the beginning of the function are"}, {"sha": "a135cad07d7a73044ff688c4d55a792e7672c453", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=e7749837caaa5c7a7fddea3e8eb90b852cead3d6", "patch": "@@ -420,6 +420,7 @@ local_alloc ()\n   free (qty_phys_copy_sugg);\n   free (qty_phys_num_copy_sugg);\n   free (qty_phys_sugg);\n+  free (qty_phys_num_sugg);\n   free (qty_birth);\n   free (qty_death);\n   free (qty_first_reg);"}, {"sha": "17a2402c37cb88975d80e5d64d213165e256b19a", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e7749837caaa5c7a7fddea3e8eb90b852cead3d6", "patch": "@@ -106,6 +106,7 @@ typedef struct case_node *case_node_ptr;\n /* These are used by estimate_case_costs and balance_case_nodes.  */\n \n /* This must be a signed type, and non-ANSI compilers lack signed char.  */\n+static short cost_table_[129];\n static short *cost_table;\n static int use_cost_table;\n \f\n@@ -5694,7 +5695,7 @@ estimate_case_costs (node)\n \n   if (cost_table == NULL)\n     {\n-      cost_table = ((short *) xcalloc (129, sizeof (short))) + 1;\n+      cost_table = cost_table_ + 1;\n \n       for (i = 0; i < 128; i++)\n \t{"}, {"sha": "89bef06d70facde4901385e69c898e596f349591", "filename": "gcc/toplev.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7749837caaa5c7a7fddea3e8eb90b852cead3d6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e7749837caaa5c7a7fddea3e8eb90b852cead3d6", "patch": "@@ -3053,13 +3053,15 @@ compile_file (name)\n \tasm_out_file = stdout;\n       else\n \t{\n-\t  int len = strlen (dump_base_name);\n-\t  register char *dumpname = (char *) xmalloc (len + 6);\n-\t  strcpy (dumpname, dump_base_name);\n-\t  strip_off_ending (dumpname, len);\n-\t  strcat (dumpname, \".s\");\n \t  if (asm_file_name == 0)\n-\t    asm_file_name = xstrdup (dumpname);\n+\t    {\n+\t      int len = strlen (dump_base_name);\n+\t      char *dumpname = (char *) xmalloc (len + 6);\n+\t      memcpy (dumpname, dump_base_name, len + 1);\n+\t      strip_off_ending (dumpname, len);\n+\t      strcat (dumpname, \".s\");\n+\t      asm_file_name = dumpname;\n+\t    }\n \t  if (!strcmp (asm_file_name, \"-\"))\n \t    asm_out_file = stdout;\n \t  else"}]}