{"sha": "91d68769419b64ef9843c4c1eac5261217693b1e", "node_id": "C_kwDOANBUbNoAKDkxZDY4NzY5NDE5YjY0ZWY5ODQzYzRjMWVhYzUyNjEyMTc2OTNiMWU", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2022-02-04T14:20:20Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-12T12:38:36Z"}, "message": "[Ada] Proof of 'Image support for signed integers\n\nProve System.Image_I, similarly to the proof done for System.Image_U.\nThe contracts make the connection between the result of Image_Integer,\nthe available space computed with System.Width_U and the result of\n'Value as computed by Value_Integer.\n\nI/O units that now depend on non-pure units are also marked not Pure\nanymore.\n\ngcc/ada/\n\n\t* libgnat/s-imagef.adb: Adapt to new signature of Image_I, by\n\tproviding ghost imported subprograms. For now, no contract is\n\tused on these subprograms, as System.Image_F is not proved.\n\t* libgnat/s-imagef.ads: Add modular type Uns as formal\n\tparameter, to use in defining Int_Params for instantiating\n\tImage_I.\n\t* libgnat/s-imagei.adb: Add contracts and ghost code.\n\t* libgnat/s-imagei.ads: Replace Int formal parameter by package\n\tInt_Params, which bundles type Int and Uns with ghost\n\tsubprograms.  Add contracts.\n\t* libgnat/s-imfi128.ads: Adapt to new formal of Image_F.\n\t* libgnat/s-imfi32.ads: Adapt to new formal of Image_F.\n\t* libgnat/s-imfi64.ads: Adapt to new formal of Image_F.\n\t* libgnat/s-imgint.ads: Adapt to new formals of Image_I.\n\t* libgnat/s-imglli.ads: Adapt to new formals of Image_I.\n\t* libgnat/s-imgllli.ads: Adapt to new formals of Image_I.\n\t* libgnat/s-valint.ads: Adapt to new formals of Value_I.\n\t* libgnat/s-vallli.ads: Adapt to new formals of Value_I.\n\t* libgnat/s-valllli.ads: Adapt to new formals of Value_I.\n\t* libgnat/s-valuei.adb (Prove_Scan_Only_Decimal_Ghost): New\n\tghost lemma.\n\t* libgnat/s-valuei.ads: New formal parameters to prove the new\n\tlemma.\n\t* libgnat/s-valuti.ads (Int_Params): Define a generic package to\n\tbe used as a trait-like formal parameter in Image_I and other\n\tgenerics that need to instantiate Image_I.\n\t* libgnat/s-widthu.ads (Big_10): Qualify the 10 literal.", "tree": {"sha": "5b71311910b10b848c80e12e11fbe68d7d5e1cc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b71311910b10b848c80e12e11fbe68d7d5e1cc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91d68769419b64ef9843c4c1eac5261217693b1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d68769419b64ef9843c4c1eac5261217693b1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91d68769419b64ef9843c4c1eac5261217693b1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d68769419b64ef9843c4c1eac5261217693b1e/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4f6f9f1769ab691d28da4579c61c13d5d1c2bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f6f9f1769ab691d28da4579c61c13d5d1c2bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4f6f9f1769ab691d28da4579c61c13d5d1c2bda"}], "stats": {"total": 818, "additions": 786, "deletions": 32}, "files": [{"sha": "2166ece6be94b2b911e91c8def9a7e868e85c8f8", "filename": "gcc/ada/libgnat/s-imagef.adb", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imagef.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imagef.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagef.adb?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -31,9 +31,24 @@\n \n with System.Image_I;\n with System.Img_Util; use System.Img_Util;\n+with System.Val_Util;\n \n package body System.Image_F is\n \n+   --  Contracts, ghost code, loop invariants and assertions in this unit are\n+   --  meant for analysis only, not for run-time checking, as it would be too\n+   --  costly otherwise. This is enforced by setting the assertion policy to\n+   --  Ignore.\n+\n+   pragma Assertion_Policy (Assert             => Ignore,\n+                            Assert_And_Cut     => Ignore,\n+                            Contract_Cases     => Ignore,\n+                            Ghost              => Ignore,\n+                            Loop_Invariant     => Ignore,\n+                            Pre                => Ignore,\n+                            Post               => Ignore,\n+                            Subprogram_Variant => Ignore);\n+\n    Maxdigs : constant Natural := Int'Width - 2;\n    --  Maximum number of decimal digits that can be represented in an Int.\n    --  The \"-2\" accounts for the sign and one extra digit, since we need the\n@@ -54,7 +69,70 @@ package body System.Image_F is\n    --  if the small is larger than 1, and smaller than 2**(Int'Size - 1) / 10\n    --  if the small is smaller than 1.\n \n-   package Image_I is new System.Image_I (Int);\n+   --  Define ghost subprograms without implementation (marked as Import) to\n+   --  create a suitable package Int_Params for type Int, as instantiations\n+   --  of System.Image_F use for this type one of the derived integer types\n+   --  defined in Interfaces, instead of the standard signed integer types\n+   --  which are used to define System.Img_*.Int_Params.\n+\n+   type Uns_Option (Overflow : Boolean := False) is record\n+      case Overflow is\n+         when True =>\n+            null;\n+         when False =>\n+            Value : Uns := 0;\n+      end case;\n+   end record;\n+\n+   Unsigned_Width_Ghost : constant Natural := Int'Width;\n+\n+   function Wrap_Option (Value : Uns) return Uns_Option\n+     with Ghost, Import;\n+   function Only_Decimal_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Boolean\n+     with Ghost, Import;\n+   function Hexa_To_Unsigned_Ghost (X : Character) return Uns\n+     with Ghost, Import;\n+   function Scan_Based_Number_Ghost\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+      return Uns_Option\n+     with Ghost, Import;\n+   function Is_Integer_Ghost (Str : String) return Boolean\n+     with Ghost, Import;\n+   procedure Prove_Iter_Scan_Based_Number_Ghost\n+     (Str1, Str2 : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+     with Ghost, Import;\n+   procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int)\n+     with Ghost, Import;\n+   function Abs_Uns_Of_Int (Val : Int) return Uns\n+     with Ghost, Import;\n+   function Value_Integer (Str : String) return Int\n+     with Ghost, Import;\n+\n+   package Int_Params is new Val_Util.Int_Params\n+     (Int                                => Int,\n+      Uns                                => Uns,\n+      Uns_Option                         => Uns_Option,\n+      Unsigned_Width_Ghost               => Unsigned_Width_Ghost,\n+      Wrap_Option                        => Wrap_Option,\n+      Only_Decimal_Ghost                 => Only_Decimal_Ghost,\n+      Hexa_To_Unsigned_Ghost             => Hexa_To_Unsigned_Ghost,\n+      Scan_Based_Number_Ghost            => Scan_Based_Number_Ghost,\n+      Is_Integer_Ghost                   => Is_Integer_Ghost,\n+      Prove_Iter_Scan_Based_Number_Ghost => Prove_Iter_Scan_Based_Number_Ghost,\n+      Prove_Scan_Only_Decimal_Ghost      => Prove_Scan_Only_Decimal_Ghost,\n+      Abs_Uns_Of_Int                     => Abs_Uns_Of_Int,\n+      Value_Integer                      => Value_Integer);\n+\n+   package Image_I is new System.Image_I (Int_Params);\n \n    procedure Set_Image_Integer\n      (V : Int;"}, {"sha": "13ea22fae9fb729273297f0599a7cd47e50ca1da", "filename": "gcc/ada/libgnat/s-imagef.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imagef.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imagef.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagef.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -36,6 +36,7 @@\n generic\n \n    type Int is range <>;\n+   type Uns is mod <>;\n \n    with procedure Scaled_Divide\n           (X, Y, Z : Int;"}, {"sha": "f340d139e26e8be8fb388d1af945a268290518a1", "filename": "gcc/ada/libgnat/s-imagei.adb", "status": "modified", "additions": 363, "deletions": 2, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imagei.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imagei.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagei.adb?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -29,18 +29,140 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+use Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+\n package body System.Image_I is\n \n+   --  Ghost code, loop invariants and assertions in this unit are meant for\n+   --  analysis only, not for run-time checking, as it would be too costly\n+   --  otherwise. This is enforced by setting the assertion policy to Ignore.\n+\n+   pragma Assertion_Policy (Ghost              => Ignore,\n+                            Loop_Invariant     => Ignore,\n+                            Assert             => Ignore,\n+                            Assert_And_Cut     => Ignore,\n+                            Pre                => Ignore,\n+                            Post               => Ignore,\n+                            Subprogram_Variant => Ignore);\n+\n+   --  As a use_clause for Int_Params cannot be used for instances of this\n+   --  generic in System specs, rename all constants and subprograms.\n+\n+   Unsigned_Width_Ghost : constant Natural := Int_Params.Unsigned_Width_Ghost;\n+\n+   function Wrap_Option (Value : Uns) return Uns_Option\n+     renames Int_Params.Wrap_Option;\n+   function Only_Decimal_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Boolean\n+      renames Int_Params.Only_Decimal_Ghost;\n+   function Hexa_To_Unsigned_Ghost (X : Character) return Uns\n+     renames Int_Params.Hexa_To_Unsigned_Ghost;\n+   function Scan_Based_Number_Ghost\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+      return Uns_Option\n+      renames Int_Params.Scan_Based_Number_Ghost;\n+   function Is_Integer_Ghost (Str : String) return Boolean\n+     renames Int_Params.Is_Integer_Ghost;\n+   procedure Prove_Iter_Scan_Based_Number_Ghost\n+     (Str1, Str2 : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+      renames Int_Params.Prove_Iter_Scan_Based_Number_Ghost;\n+   procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int)\n+     renames Int_Params.Prove_Scan_Only_Decimal_Ghost;\n+   function Abs_Uns_Of_Int (Val : Int) return Uns\n+     renames Int_Params.Abs_Uns_Of_Int;\n+   function Value_Integer (Str : String) return Int\n+     renames Int_Params.Value_Integer;\n+\n    subtype Non_Positive is Int range Int'First .. 0;\n \n+   function Uns_Of_Non_Positive (T : Non_Positive) return Uns is\n+     (if T = Int'First then Uns (Int'Last) + 1 else Uns (-T));\n+\n    procedure Set_Digits\n      (T : Non_Positive;\n       S : in out String;\n-      P : in out Natural);\n+      P : in out Natural)\n+   with\n+     Pre  => P < Integer'Last\n+       and then S'Last < Integer'Last\n+       and then S'First <= P + 1\n+       and then S'First <= S'Last\n+       and then P <= S'Last - Unsigned_Width_Ghost + 1,\n+     Post => S (S'First .. P'Old) = S'Old (S'First .. P'Old)\n+       and then P in P'Old + 1 .. S'Last\n+       and then Only_Decimal_Ghost (S, From => P'Old + 1, To => P)\n+       and then Scan_Based_Number_Ghost (S, From => P'Old + 1, To => P)\n+         = Wrap_Option (Uns_Of_Non_Positive (T));\n    --  Set digits of absolute value of T, which is zero or negative. We work\n    --  with the negative of the value so that the largest negative number is\n    --  not a special case.\n \n+   package Unsigned_Conversion is new Unsigned_Conversions (Int => Uns);\n+\n+   function Big (Arg : Uns) return Big_Integer renames\n+     Unsigned_Conversion.To_Big_Integer;\n+\n+   function From_Big (Arg : Big_Integer) return Uns renames\n+     Unsigned_Conversion.From_Big_Integer;\n+\n+   Big_10 : constant Big_Integer := Big (10) with Ghost;\n+\n+   ------------------\n+   -- Local Lemmas --\n+   ------------------\n+\n+   procedure Lemma_Non_Zero (X : Uns)\n+   with\n+     Ghost,\n+     Pre  => X /= 0,\n+     Post => Big (X) /= 0;\n+\n+   procedure Lemma_Div_Commutation (X, Y : Uns)\n+   with\n+     Ghost,\n+     Pre  => Y /= 0,\n+     Post => Big (X) / Big (Y) = Big (X / Y);\n+\n+   procedure Lemma_Div_Twice (X : Big_Natural; Y, Z : Big_Positive)\n+   with\n+     Ghost,\n+     Post => X / Y / Z = X / (Y * Z);\n+\n+   ---------------------------\n+   -- Lemma_Div_Commutation --\n+   ---------------------------\n+\n+   procedure Lemma_Non_Zero (X : Uns) is null;\n+   procedure Lemma_Div_Commutation (X, Y : Uns) is null;\n+\n+   ---------------------\n+   -- Lemma_Div_Twice --\n+   ---------------------\n+\n+   procedure Lemma_Div_Twice (X : Big_Natural; Y, Z : Big_Positive) is\n+      XY  : constant Big_Natural := X / Y;\n+      YZ  : constant Big_Natural := Y * Z;\n+      XYZ : constant Big_Natural := X / Y / Z;\n+      R   : constant Big_Natural := (XY rem Z) * Y + (X rem Y);\n+   begin\n+      pragma Assert (X = XY * Y + (X rem Y));\n+      pragma Assert (XY = XY / Z * Z + (XY rem Z));\n+      pragma Assert (X = XYZ * YZ + R);\n+      pragma Assert ((XY rem Z) * Y <= (Z - 1) * Y);\n+      pragma Assert (R <= YZ - 1);\n+      pragma Assert (X / YZ = (XYZ * YZ + R) / YZ);\n+      pragma Assert (X / YZ = XYZ + R / YZ);\n+   end Lemma_Div_Twice;\n+\n    -------------------\n    -- Image_Integer --\n    -------------------\n@@ -52,6 +174,39 @@ package body System.Image_I is\n    is\n       pragma Assert (S'First = 1);\n \n+      procedure Prove_Value_Integer\n+      with\n+        Ghost,\n+        Pre => S'First = 1\n+          and then S'Last < Integer'Last\n+          and then P in 2 .. S'Last\n+          and then S (1) in ' ' | '-'\n+          and then (S (1) = '-') = (V < 0)\n+          and then Only_Decimal_Ghost (S, From => 2, To => P)\n+          and then Scan_Based_Number_Ghost (S, From => 2, To => P)\n+            = Wrap_Option (Abs_Uns_Of_Int (V)),\n+        Post => Is_Integer_Ghost (S (1 .. P))\n+          and then Value_Integer (S (1 .. P)) = V;\n+      --  Ghost lemma to prove the value of Value_Integer from the value of\n+      --  Scan_Based_Number_Ghost and the sign on a decimal string.\n+\n+      -------------------------\n+      -- Prove_Value_Integer --\n+      -------------------------\n+\n+      procedure Prove_Value_Integer is\n+         Str : constant String := S (1 .. P);\n+      begin\n+         pragma Assert (Str'First = 1);\n+         pragma Assert (Only_Decimal_Ghost (Str, From => 2, To => P));\n+         Prove_Iter_Scan_Based_Number_Ghost (S, Str, From => 2, To => P);\n+         pragma Assert (Scan_Based_Number_Ghost (Str, From => 2, To => P)\n+            = Wrap_Option (Abs_Uns_Of_Int (V)));\n+         Prove_Scan_Only_Decimal_Ghost (Str, V);\n+      end Prove_Value_Integer;\n+\n+   --  Start of processing for Image_Integer\n+\n    begin\n       if V >= 0 then\n          S (1) := ' ';\n@@ -63,7 +218,16 @@ package body System.Image_I is\n          pragma Assert (P < S'Last - 1);\n       end if;\n \n-      Set_Image_Integer (V, S, P);\n+      declare\n+         P_Prev : constant Integer := P with Ghost;\n+         Offset : constant Positive := (if V >= 0 then 1 else 2) with Ghost;\n+      begin\n+         Set_Image_Integer (V, S, P);\n+\n+         pragma Assert (P_Prev + Offset = 2);\n+      end;\n+\n+      Prove_Value_Integer;\n    end Image_Integer;\n \n    ----------------\n@@ -77,6 +241,106 @@ package body System.Image_I is\n    is\n       Nb_Digits : Natural := 0;\n       Value     : Non_Positive := T;\n+\n+      --  Local ghost variables\n+\n+      Pow        : Big_Positive := 1 with Ghost;\n+      S_Init     : constant String := S with Ghost;\n+      Uns_T      : constant Uns := Uns_Of_Non_Positive (T) with Ghost;\n+      Uns_Value  : Uns := Uns_Of_Non_Positive (Value) with Ghost;\n+      Prev, Cur  : Uns_Option with Ghost;\n+      Prev_Value : Uns with Ghost;\n+      Prev_S     : String := S with Ghost;\n+\n+      --  Local ghost lemmas\n+\n+      procedure Prove_Character_Val (RU : Uns; RI : Int)\n+      with\n+        Ghost,\n+        Pre  => RU in 0 .. 9\n+          and then RI in 0 .. 9,\n+        Post => Character'Val (48 + RU) in '0' .. '9'\n+          and then Character'Val (48 + RI) in '0' .. '9';\n+      --  Ghost lemma to prove the value of a character corresponding to the\n+      --  next figure.\n+\n+      procedure Prove_Hexa_To_Unsigned_Ghost (RU : Uns; RI : Int)\n+      with\n+        Ghost,\n+        Pre  => RU in 0 .. 9\n+          and then RI in 0 .. 9,\n+        Post => Hexa_To_Unsigned_Ghost (Character'Val (48 + RU)) = RU\n+          and then Hexa_To_Unsigned_Ghost (Character'Val (48 + RI)) = Uns (RI);\n+      --  Ghost lemma to prove that Hexa_To_Unsigned_Ghost returns the source\n+      --  figure when applied to the corresponding character.\n+\n+      procedure Prove_Unchanged\n+      with\n+        Ghost,\n+        Pre  => P <= S'Last\n+          and then S_Init'First = S'First\n+          and then S_Init'Last = S'Last\n+          and then (for all K in S'First .. P => S (K) = S_Init (K)),\n+        Post => S (S'First .. P) = S_Init (S'First .. P);\n+      --  Ghost lemma to prove that the part of string S before P has not been\n+      --  modified.\n+\n+      procedure Prove_Uns_Of_Non_Positive_Value\n+      with\n+        Ghost,\n+        Pre  => Uns_Value = Uns_Of_Non_Positive (Value),\n+        Post => Uns_Value / 10 = Uns_Of_Non_Positive (Value / 10)\n+          and then Uns_Value rem 10 = Uns_Of_Non_Positive (Value rem 10);\n+      --  Ghost lemma to prove that the relation between Value and its unsigned\n+      --  version is preserved.\n+\n+      procedure Prove_Iter_Scan\n+        (Str1, Str2 : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+      with\n+        Ghost,\n+        Pre  => Str1'Last /= Positive'Last\n+          and then\n+            (From > To or else (From >= Str1'First and then To <= Str1'Last))\n+          and then Only_Decimal_Ghost (Str1, From, To)\n+          and then Str1'First = Str2'First\n+          and then Str1'Last = Str2'Last\n+          and then (for all J in From .. To => Str1 (J) = Str2 (J)),\n+        Post =>\n+          Scan_Based_Number_Ghost (Str1, From, To, Base, Acc)\n+            = Scan_Based_Number_Ghost (Str2, From, To, Base, Acc);\n+      --  Ghost lemma to prove that the result of Scan_Based_Number_Ghost only\n+      --  depends on the value of the argument string in the (From .. To) range\n+      --  of indexes. This is a wrapper on Prove_Iter_Scan_Based_Number_Ghost\n+      --  so that we can call it here on ghost arguments.\n+\n+      -----------------------------\n+      -- Local lemma null bodies --\n+      -----------------------------\n+\n+      procedure Prove_Character_Val (RU : Uns; RI : Int) is null;\n+      procedure Prove_Hexa_To_Unsigned_Ghost (RU : Uns; RI : Int) is null;\n+      procedure Prove_Unchanged is null;\n+      procedure Prove_Uns_Of_Non_Positive_Value is null;\n+\n+      ---------------------\n+      -- Prove_Iter_Scan --\n+      ---------------------\n+\n+      procedure Prove_Iter_Scan\n+        (Str1, Str2 : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+      is\n+      begin\n+         Prove_Iter_Scan_Based_Number_Ghost (Str1, Str2, From, To, Base, Acc);\n+      end Prove_Iter_Scan;\n+\n+   --  Start of processing for Set_Digits\n+\n    begin\n       pragma Assert (P >= S'First - 1 and P < S'Last);\n       --  No check is done since, as documented in the Set_Image_Integer\n@@ -86,19 +350,116 @@ package body System.Image_I is\n       --  First we compute the number of characters needed for representing\n       --  the number.\n       loop\n+         Lemma_Div_Commutation (Uns_Of_Non_Positive (Value), 10);\n+         Lemma_Div_Twice (Big (Uns_Of_Non_Positive (T)),\n+                          Big_10 ** Nb_Digits, Big_10);\n+         Prove_Uns_Of_Non_Positive_Value;\n+\n          Value := Value / 10;\n          Nb_Digits := Nb_Digits + 1;\n+\n+         Uns_Value := Uns_Value / 10;\n+         Pow := Pow * 10;\n+\n+         pragma Loop_Invariant (Uns_Value = Uns_Of_Non_Positive (Value));\n+         pragma Loop_Invariant (Nb_Digits in 1 .. Unsigned_Width_Ghost - 1);\n+         pragma Loop_Invariant (Pow = Big_10 ** Nb_Digits);\n+         pragma Loop_Invariant (Big (Uns_Value) = Big (Uns_T) / Pow);\n+         pragma Loop_Variant (Increases => Value);\n+\n          exit when Value = 0;\n+\n+         Lemma_Non_Zero (Uns_Value);\n+         pragma Assert (Pow <= Big (Uns'Last));\n       end loop;\n \n       Value := T;\n+      Uns_Value := Uns_Of_Non_Positive (T);\n+      Pow := 1;\n+\n+      pragma Assert (Uns_Value = From_Big (Big (Uns_T) / Big_10 ** 0));\n \n       --  We now populate digits from the end of the string to the beginning\n       for J in reverse  1 .. Nb_Digits loop\n+         Lemma_Div_Commutation (Uns_Value, 10);\n+         Lemma_Div_Twice (Big (Uns_T), Big_10 ** (Nb_Digits - J), Big_10);\n+         Prove_Character_Val (Uns_Value rem 10, -(Value rem 10));\n+         Prove_Hexa_To_Unsigned_Ghost (Uns_Value rem 10, -(Value rem 10));\n+         Prove_Uns_Of_Non_Positive_Value;\n+         pragma Assert (Uns_Value rem 10 = Uns_Of_Non_Positive (Value rem 10));\n+         pragma Assert (Uns_Value rem 10 = Uns (-(Value rem 10)));\n+\n+         Prev_Value := Uns_Value;\n+         Prev_S := S;\n+         Pow := Pow * 10;\n+         Uns_Value := Uns_Value / 10;\n+\n          S (P + J) := Character'Val (48 - (Value rem 10));\n          Value := Value / 10;\n+\n+         pragma Assert (S (P + J) in '0' .. '9');\n+         pragma Assert (Hexa_To_Unsigned_Ghost (S (P + J)) =\n+           From_Big (Big (Uns_T) / Big_10 ** (Nb_Digits - J)) rem 10);\n+         pragma Assert\n+           (for all K in P + J + 1 .. P + Nb_Digits => S (K) in '0' .. '9');\n+\n+         Prev := Scan_Based_Number_Ghost\n+           (Str  => S,\n+            From => P + J + 1,\n+            To   => P + Nb_Digits,\n+            Base => 10,\n+            Acc  => Prev_Value);\n+         Cur := Scan_Based_Number_Ghost\n+           (Str  => S,\n+            From => P + J,\n+            To   => P + Nb_Digits,\n+            Base => 10,\n+            Acc  => Uns_Value);\n+         pragma Assert (Prev_Value = 10 * Uns_Value + (Prev_Value rem 10));\n+         pragma Assert\n+           (Prev_Value rem 10 = Hexa_To_Unsigned_Ghost (S (P + J)));\n+         pragma Assert\n+           (Prev_Value = 10 * Uns_Value + Hexa_To_Unsigned_Ghost (S (P + J)));\n+\n+         if J /= Nb_Digits then\n+            Prove_Iter_Scan\n+              (Prev_S, S, P + J + 1, P + Nb_Digits, 10, Prev_Value);\n+         end if;\n+\n+         pragma Assert (Prev = Cur);\n+         pragma Assert (Prev = Wrap_Option (Uns_T));\n+\n+         pragma Loop_Invariant (Uns_Value = Uns_Of_Non_Positive (Value));\n+         pragma Loop_Invariant (Uns_Value <= Uns'Last / 10);\n+         pragma Loop_Invariant\n+           (for all K in S'First .. P => S (K) = S_Init (K));\n+         pragma Loop_Invariant (Only_Decimal_Ghost (S, P + J, P + Nb_Digits));\n+         pragma Loop_Invariant\n+           (for all K in P + J .. P + Nb_Digits => S (K) in '0' .. '9');\n+         pragma Loop_Invariant (Pow = Big_10 ** (Nb_Digits - J + 1));\n+         pragma Loop_Invariant (Big (Uns_Value) = Big (Uns_T) / Pow);\n+         pragma Loop_Invariant\n+           (Scan_Based_Number_Ghost\n+              (Str  => S,\n+               From => P + J,\n+               To   => P + Nb_Digits,\n+               Base => 10,\n+               Acc  => Uns_Value)\n+              = Wrap_Option (Uns_T));\n       end loop;\n \n+      pragma Assert (Big (Uns_Value) = Big (Uns_T) / Big_10 ** (Nb_Digits));\n+      pragma Assert (Uns_Value = 0);\n+      Prove_Unchanged;\n+      pragma Assert\n+        (Scan_Based_Number_Ghost\n+           (Str  => S,\n+            From => P + 1,\n+            To   => P + Nb_Digits,\n+            Base => 10,\n+            Acc  => Uns_Value)\n+         = Wrap_Option (Uns_T));\n+\n       P := P + Nb_Digits;\n    end Set_Digits;\n "}, {"sha": "10116d123ed6295f13272bb7052d717196fe1024", "filename": "gcc/ada/libgnat/s-imagei.ads", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imagei.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imagei.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagei.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -33,25 +33,77 @@\n --  signed integer types, and also for conversion operations required in\n --  Text_IO.Integer_IO for such types.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n+with System.Val_Util;\n+\n generic\n \n-   type Int is range <>;\n+   with package Int_Params is new System.Val_Util.Int_Params (<>);\n \n package System.Image_I is\n-   pragma Pure;\n+\n+   subtype Int is Int_Params.Int;\n+   use type Int_Params.Int;\n+\n+   subtype Uns is Int_Params.Uns;\n+   use type Int_Params.Uns;\n+\n+   subtype Uns_Option is Int_Params.Uns_Option;\n+   use type Int_Params.Uns_Option;\n \n    procedure Image_Integer\n      (V : Int;\n       S : in out String;\n-      P : out Natural);\n+      P : out Natural)\n+   with\n+     Pre  => S'First = 1\n+       and then S'Last < Integer'Last\n+       and then S'Last >= Int_Params.Unsigned_Width_Ghost,\n+     Post => P in S'Range\n+       and then Int_Params.Value_Integer (S (1 .. P)) = V;\n    --  Computes Int'Image (V) and stores the result in S (1 .. P)\n    --  setting the resulting value of P. The caller guarantees that S\n    --  is long enough to hold the result, and that S'First is 1.\n \n    procedure Set_Image_Integer\n      (V : Int;\n       S : in out String;\n-      P : in out Natural);\n+      P : in out Natural)\n+   with\n+     Pre  => P < Integer'Last\n+       and then S'Last < Integer'Last\n+       and then S'First <= P + 1\n+       and then S'First <= S'Last\n+       and then\n+         (if V >= 0 then\n+            P <= S'Last - Int_Params.Unsigned_Width_Ghost + 1\n+          else\n+            P <= S'Last - Int_Params.Unsigned_Width_Ghost),\n+     Post => S (S'First .. P'Old) = S'Old (S'First .. P'Old)\n+       and then\n+         (declare\n+            Minus  : constant Boolean := S (P'Old + 1) = '-';\n+            Offset : constant Positive := (if V >= 0 then 1 else 2);\n+            Abs_V  : constant Uns := Int_Params.Abs_Uns_Of_Int (V);\n+          begin\n+            Minus = (V < 0)\n+              and then P in P'Old + Offset .. S'Last\n+              and then Int_Params.Only_Decimal_Ghost\n+                (S, From => P'Old + Offset, To => P)\n+              and then Int_Params.Scan_Based_Number_Ghost\n+                (S, From => P'Old + Offset, To => P)\n+                = Int_Params.Wrap_Option (Abs_V));\n    --  Stores the image of V in S starting at S (P + 1), P is updated to point\n    --  to the last character stored. The value stored is identical to the value\n    --  of Int'Image (V) except that no leading space is stored when V is"}, {"sha": "7f64b83e9a84928b1ced1d190f93707a21026d3e", "filename": "gcc/ada/libgnat/s-imfi128.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imfi128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imfi128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imfi128.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -39,8 +39,9 @@ with System.Image_F;\n package System.Img_Fixed_128 is\n \n    subtype Int128 is Interfaces.Integer_128;\n+   subtype Uns128 is Interfaces.Unsigned_128;\n \n-   package Impl is new Image_F (Int128, Arith_128.Scaled_Divide128);\n+   package Impl is new Image_F (Int128, Uns128, Arith_128.Scaled_Divide128);\n \n    procedure Image_Fixed128\n      (V    : Int128;"}, {"sha": "e5c6ff8cbc8b28857db45dc67ba05f3096cb6f3c", "filename": "gcc/ada/libgnat/s-imfi32.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imfi32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imfi32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imfi32.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -39,8 +39,9 @@ with System.Image_F;\n package System.Img_Fixed_32 is\n \n    subtype Int32 is Interfaces.Integer_32;\n+   subtype Uns32 is Interfaces.Unsigned_32;\n \n-   package Impl is new Image_F (Int32, Arith_32.Scaled_Divide32);\n+   package Impl is new Image_F (Int32, Uns32, Arith_32.Scaled_Divide32);\n \n    procedure Image_Fixed32\n      (V    : Int32;"}, {"sha": "91f4daf54eb9e471449507670b2f63bf6db45b71", "filename": "gcc/ada/libgnat/s-imfi64.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imfi64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imfi64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imfi64.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -39,8 +39,9 @@ with System.Image_F;\n package System.Img_Fixed_64 is\n \n    subtype Int64 is Interfaces.Integer_64;\n+   subtype Uns64 is Interfaces.Unsigned_64;\n \n-   package Impl is new Image_F (Int64, Arith_64.Scaled_Divide64);\n+   package Impl is new Image_F (Int64, Uns64, Arith_64.Scaled_Divide64);\n \n    procedure Image_Fixed64\n      (V    : Int64;"}, {"sha": "fd5bea31c2ab45616a598b5925a6eefd592a8938", "filename": "gcc/ada/libgnat/s-imgint.ads", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imgint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imgint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgint.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -33,12 +33,51 @@\n --  signed integer types up to Integer, and also for conversion operations\n --  required in Text_IO.Integer_IO for such types.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n with System.Image_I;\n+with System.Unsigned_Types;\n+with System.Val_Int;\n+with System.Val_Uns;\n+with System.Val_Util;\n+with System.Wid_Uns;\n+\n+package System.Img_Int\n+  with SPARK_Mode\n+is\n+   subtype Unsigned is Unsigned_Types.Unsigned;\n \n-package System.Img_Int is\n-   pragma Pure;\n+   package Int_Params is new Val_Util.Int_Params\n+     (Int                                => Integer,\n+      Uns                                => Unsigned,\n+      Uns_Option                         => Val_Uns.Impl.Uns_Option,\n+      Unsigned_Width_Ghost               =>\n+         Wid_Uns.Width_Unsigned (0, Unsigned'Last),\n+      Only_Decimal_Ghost                 => Val_Uns.Impl.Only_Decimal_Ghost,\n+      Hexa_To_Unsigned_Ghost             =>\n+         Val_Uns.Impl.Hexa_To_Unsigned_Ghost,\n+      Wrap_Option                        => Val_Uns.Impl.Wrap_Option,\n+      Scan_Based_Number_Ghost            =>\n+         Val_Uns.Impl.Scan_Based_Number_Ghost,\n+      Prove_Iter_Scan_Based_Number_Ghost =>\n+         Val_Uns.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n+      Is_Integer_Ghost                   => Val_Int.Impl.Is_Integer_Ghost,\n+      Prove_Scan_Only_Decimal_Ghost      =>\n+         Val_Int.Impl.Prove_Scan_Only_Decimal_Ghost,\n+      Abs_Uns_Of_Int                     => Val_Int.Impl.Abs_Uns_Of_Int,\n+      Value_Integer                      => Val_Int.Impl.Value_Integer);\n \n-   package Impl is new Image_I (Integer);\n+   package Impl is new Image_I (Int_Params);\n \n    procedure Image_Integer\n      (V : Integer;"}, {"sha": "20f108c8e45f84d318343364580ac0f4fa11bf0a", "filename": "gcc/ada/libgnat/s-imglli.ads", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imglli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imglli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglli.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -33,12 +33,51 @@\n --  signed integer types larger than Integer, and also for conversion\n --  operations required in Text_IO.Integer_IO for such types.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n with System.Image_I;\n+with System.Unsigned_Types;\n+with System.Val_LLI;\n+with System.Val_LLU;\n+with System.Val_Util;\n+with System.Wid_LLU;\n+\n+package System.Img_LLI\n+  with SPARK_Mode\n+is\n+   subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n \n-package System.Img_LLI is\n-   pragma Pure;\n+   package Int_Params is new Val_Util.Int_Params\n+     (Int                                => Long_Long_Integer,\n+      Uns                                => Long_Long_Unsigned,\n+      Uns_Option                         => Val_LLU.Impl.Uns_Option,\n+      Unsigned_Width_Ghost               =>\n+         Wid_LLU.Width_Long_Long_Unsigned (0, Long_Long_Unsigned'Last),\n+      Only_Decimal_Ghost                 => Val_LLU.Impl.Only_Decimal_Ghost,\n+      Hexa_To_Unsigned_Ghost             =>\n+         Val_LLU.Impl.Hexa_To_Unsigned_Ghost,\n+      Wrap_Option                        => Val_LLU.Impl.Wrap_Option,\n+      Scan_Based_Number_Ghost            =>\n+         Val_LLU.Impl.Scan_Based_Number_Ghost,\n+      Prove_Iter_Scan_Based_Number_Ghost =>\n+         Val_LLU.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n+      Is_Integer_Ghost                   => Val_LLI.Impl.Is_Integer_Ghost,\n+      Prove_Scan_Only_Decimal_Ghost      =>\n+         Val_LLI.Impl.Prove_Scan_Only_Decimal_Ghost,\n+      Abs_Uns_Of_Int                     => Val_LLI.Impl.Abs_Uns_Of_Int,\n+      Value_Integer                      => Val_LLI.Impl.Value_Integer);\n \n-   package Impl is new Image_I (Long_Long_Integer);\n+   package Impl is new Image_I (Int_Params);\n \n    procedure Image_Long_Long_Integer\n      (V : Long_Long_Integer;"}, {"sha": "989c296d759d7fd421ecc131ecacfa1a02d08aa4", "filename": "gcc/ada/libgnat/s-imgllli.ads", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -33,12 +33,52 @@\n --  signed integer types larger than Long_Long_Integer, and also for conversion\n --  operations required in Text_IO.Integer_IO for such types.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n with System.Image_I;\n+with System.Unsigned_Types;\n+with System.Val_LLLI;\n+with System.Val_LLLU;\n+with System.Val_Util;\n+with System.Wid_LLLU;\n+\n+package System.Img_LLLI\n+  with SPARK_Mode\n+is\n+   subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n \n-package System.Img_LLLI is\n-   pragma Pure;\n+   package Int_Params is new Val_Util.Int_Params\n+     (Int                                => Long_Long_Long_Integer,\n+      Uns                                => Long_Long_Long_Unsigned,\n+      Uns_Option                         => Val_LLLU.Impl.Uns_Option,\n+      Unsigned_Width_Ghost               =>\n+         Wid_LLLU.Width_Long_Long_Long_Unsigned\n+           (0, Long_Long_Long_Unsigned'Last),\n+      Only_Decimal_Ghost                 => Val_LLLU.Impl.Only_Decimal_Ghost,\n+      Hexa_To_Unsigned_Ghost             =>\n+         Val_LLLU.Impl.Hexa_To_Unsigned_Ghost,\n+      Wrap_Option                        => Val_LLLU.Impl.Wrap_Option,\n+      Scan_Based_Number_Ghost            =>\n+         Val_LLLU.Impl.Scan_Based_Number_Ghost,\n+      Prove_Iter_Scan_Based_Number_Ghost =>\n+         Val_LLLU.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n+      Is_Integer_Ghost                   => Val_LLLI.Impl.Is_Integer_Ghost,\n+      Prove_Scan_Only_Decimal_Ghost      =>\n+         Val_LLLI.Impl.Prove_Scan_Only_Decimal_Ghost,\n+      Abs_Uns_Of_Int                     => Val_LLLI.Impl.Abs_Uns_Of_Int,\n+      Value_Integer                      => Val_LLLI.Impl.Value_Integer);\n \n-   package Impl is new Image_I (Long_Long_Long_Integer);\n+   package Impl is new Image_I (Int_Params);\n \n    procedure Image_Long_Long_Long_Integer\n      (V : Long_Long_Long_Integer;"}, {"sha": "9e47f1bc9f0a74d13d9d685e1a1926c22f6b152c", "filename": "gcc/ada/libgnat/s-valint.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-valint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-valint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valint.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -57,14 +57,20 @@ package System.Val_Int with SPARK_Mode is\n      (Int                          => Integer,\n       Uns                          => Unsigned,\n       Scan_Raw_Unsigned            => Val_Uns.Scan_Raw_Unsigned,\n+      Uns_Option                   => Val_Uns.Impl.Uns_Option,\n+      Wrap_Option                  => Val_Uns.Impl.Wrap_Option,\n       Is_Raw_Unsigned_Format_Ghost =>\n          Val_Uns.Impl.Is_Raw_Unsigned_Format_Ghost,\n       Raw_Unsigned_Overflows_Ghost =>\n          Val_Uns.Impl.Raw_Unsigned_Overflows_Ghost,\n       Scan_Raw_Unsigned_Ghost      =>\n          Val_Uns.Impl.Scan_Raw_Unsigned_Ghost,\n       Raw_Unsigned_Last_Ghost      =>\n-         Val_Uns.Impl.Raw_Unsigned_Last_Ghost);\n+         Val_Uns.Impl.Raw_Unsigned_Last_Ghost,\n+      Only_Decimal_Ghost           =>\n+         Val_Uns.Impl.Only_Decimal_Ghost,\n+      Scan_Based_Number_Ghost      =>\n+         Val_Uns.Impl.Scan_Based_Number_Ghost);\n \n    procedure Scan_Integer\n      (Str : String;"}, {"sha": "5bccb1a726b0dc50b1a977ad0bfce379536171c9", "filename": "gcc/ada/libgnat/s-vallli.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-vallli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-vallli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vallli.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -58,14 +58,20 @@ package System.Val_LLI with SPARK_Mode is\n       Uns                          => Long_Long_Unsigned,\n       Scan_Raw_Unsigned            =>\n          Val_LLU.Scan_Raw_Long_Long_Unsigned,\n+      Uns_Option                   => Val_LLU.Impl.Uns_Option,\n+      Wrap_Option                  => Val_LLU.Impl.Wrap_Option,\n       Is_Raw_Unsigned_Format_Ghost =>\n          Val_LLU.Impl.Is_Raw_Unsigned_Format_Ghost,\n       Raw_Unsigned_Overflows_Ghost =>\n          Val_LLU.Impl.Raw_Unsigned_Overflows_Ghost,\n       Scan_Raw_Unsigned_Ghost      =>\n          Val_LLU.Impl.Scan_Raw_Unsigned_Ghost,\n       Raw_Unsigned_Last_Ghost      =>\n-         Val_LLU.Impl.Raw_Unsigned_Last_Ghost);\n+         Val_LLU.Impl.Raw_Unsigned_Last_Ghost,\n+      Only_Decimal_Ghost           =>\n+         Val_LLU.Impl.Only_Decimal_Ghost,\n+      Scan_Based_Number_Ghost      =>\n+         Val_LLU.Impl.Scan_Based_Number_Ghost);\n \n    procedure Scan_Long_Long_Integer\n      (Str  : String;"}, {"sha": "586c7379d215d8986db61d58b0057483ef5cb3e0", "filename": "gcc/ada/libgnat/s-valllli.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-valllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-valllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valllli.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -58,14 +58,20 @@ package System.Val_LLLI with SPARK_Mode is\n       Uns                          => Long_Long_Long_Unsigned,\n       Scan_Raw_Unsigned            =>\n          Val_LLLU.Scan_Raw_Long_Long_Long_Unsigned,\n+      Uns_Option                   => Val_LLLU.Impl.Uns_Option,\n+      Wrap_Option                  => Val_LLLU.Impl.Wrap_Option,\n       Is_Raw_Unsigned_Format_Ghost =>\n          Val_LLLU.Impl.Is_Raw_Unsigned_Format_Ghost,\n       Raw_Unsigned_Overflows_Ghost =>\n          Val_LLLU.Impl.Raw_Unsigned_Overflows_Ghost,\n       Scan_Raw_Unsigned_Ghost      =>\n          Val_LLLU.Impl.Scan_Raw_Unsigned_Ghost,\n       Raw_Unsigned_Last_Ghost      =>\n-         Val_LLLU.Impl.Raw_Unsigned_Last_Ghost);\n+         Val_LLLU.Impl.Raw_Unsigned_Last_Ghost,\n+      Only_Decimal_Ghost           =>\n+         Val_LLLU.Impl.Only_Decimal_Ghost,\n+      Scan_Based_Number_Ghost      =>\n+         Val_LLLU.Impl.Scan_Based_Number_Ghost);\n \n    procedure Scan_Long_Long_Long_Integer\n      (Str  : String;"}, {"sha": "b453ffc38dae33b0c8d0b5481ab97ff28900abbb", "filename": "gcc/ada/libgnat/s-valuei.adb", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuei.adb?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -41,6 +41,59 @@ package body System.Value_I is\n                             Assert_And_Cut     => Ignore,\n                             Subprogram_Variant => Ignore);\n \n+   -----------------------------------\n+   -- Prove_Scan_Only_Decimal_Ghost --\n+   -----------------------------------\n+\n+   procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int) is\n+      Non_Blank : constant Positive := First_Non_Space_Ghost\n+        (Str, Str'First, Str'Last);\n+      pragma Assert\n+        (if Val < 0 then Non_Blank = Str'First\n+         else\n+            Only_Space_Ghost (Str, Str'First, Str'First)\n+            and then Non_Blank = Str'First + 1);\n+      Minus : constant Boolean := Str (Non_Blank) = '-';\n+      Fst_Num   : constant Positive :=\n+        (if Minus then Non_Blank + 1 else Non_Blank);\n+      pragma Assert (Fst_Num = Str'First + 1);\n+      Uval      : constant Uns :=\n+        Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Str'Last);\n+\n+      procedure Unique_Int_Of_Uns (Val1, Val2 : Int)\n+      with\n+        Pre  => Uns_Is_Valid_Int (Minus, Uval)\n+          and then Is_Int_Of_Uns (Minus, Uval, Val1)\n+          and then Is_Int_Of_Uns (Minus, Uval, Val2),\n+        Post => Val1 = Val2;\n+      --  Local proof of the unicity of the signed representation\n+\n+      procedure Unique_Int_Of_Uns (Val1, Val2 : Int) is null;\n+\n+   --  Start of processing for Prove_Scan_Only_Decimal_Ghost\n+\n+   begin\n+      pragma Assert (Minus = (Val < 0));\n+      pragma Assert (Uval = Abs_Uns_Of_Int (Val));\n+      pragma Assert (if Minus then Uval <= Uns (Int'Last) + 1\n+                     else Uval <= Uns (Int'Last));\n+      pragma Assert (Uns_Is_Valid_Int (Minus, Uval));\n+      pragma Assert\n+        (if Minus and then Uval = Uns (Int'Last) + 1 then Val = Int'First\n+         elsif Minus then Val = -(Int (Uval))\n+         else Val = Int (Uval));\n+      pragma Assert (Is_Int_Of_Uns (Minus, Uval, Val));\n+      pragma Assert\n+        (Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last)));\n+      pragma Assert\n+        (not Raw_Unsigned_Overflows_Ghost (Str, Fst_Num, Str'Last));\n+      pragma Assert (Only_Space_Ghost\n+        (Str, Raw_Unsigned_Last_Ghost (Str, Fst_Num, Str'Last), Str'Last));\n+      pragma Assert (Is_Integer_Ghost (Str));\n+      pragma Assert (Is_Value_Integer_Ghost (Str, Val));\n+      Unique_Int_Of_Uns (Val, Value_Integer (Str));\n+   end Prove_Scan_Only_Decimal_Ghost;\n+\n    ------------------\n    -- Scan_Integer --\n    ------------------"}, {"sha": "d2e857a3de37180433d88170ff3bbbf336a0d88e", "filename": "gcc/ada/libgnat/s-valuei.ads", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-valuei.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-valuei.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuei.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -56,19 +56,31 @@ generic\n \n    --  Additional parameters for ghost subprograms used inside contracts\n \n+   type Uns_Option is private;\n+   with function Wrap_Option (Value : Uns) return Uns_Option;\n    with function Is_Raw_Unsigned_Format_Ghost (Str : String) return Boolean;\n    with function Raw_Unsigned_Overflows_Ghost\n-          (Str      : String;\n-           From, To : Integer)\n-           return Boolean;\n+     (Str      : String;\n+      From, To : Integer)\n+      return Boolean;\n    with function Scan_Raw_Unsigned_Ghost\n-          (Str      : String;\n-           From, To : Integer)\n-           return Uns;\n+     (Str      : String;\n+      From, To : Integer)\n+      return Uns;\n    with function Raw_Unsigned_Last_Ghost\n-          (Str      : String;\n-           From, To : Integer)\n-           return Positive;\n+     (Str      : String;\n+      From, To : Integer)\n+      return Positive;\n+   with function Only_Decimal_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Boolean;\n+   with function Scan_Based_Number_Ghost\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+      return Uns_Option;\n \n package System.Value_I is\n    pragma Preelaborate;\n@@ -96,6 +108,13 @@ package System.Value_I is\n      Post => True;\n    --  Return True if Uval (or -Uval when Minus is True) is equal to Val\n \n+   function Abs_Uns_Of_Int (Val : Int) return Uns is\n+     (if Val = Int'First then Uns (Int'Last) + 1\n+      elsif Val < 0 then Uns (-Val)\n+      else Uns (Val))\n+   with Ghost;\n+   --  Return the unsigned absolute value of Val\n+\n    procedure Scan_Integer\n      (Str : String;\n       Ptr : not null access Integer;\n@@ -238,6 +257,22 @@ package System.Value_I is\n    --  argument of the attribute. Constraint_Error is raised if the string is\n    --  malformed, or if the value is out of range.\n \n+   procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int)\n+   with\n+     Ghost,\n+     Pre  => Str'Last /= Positive'Last\n+       and then Str'Length >= 2\n+       and then Str (Str'First) in ' ' | '-'\n+       and then (Str (Str'First) = '-') = (Val < 0)\n+       and then Only_Decimal_Ghost (Str, Str'First + 1, Str'Last)\n+       and then Scan_Based_Number_Ghost (Str, Str'First + 1, Str'Last)\n+         = Wrap_Option (Abs_Uns_Of_Int (Val)),\n+     Post => Is_Integer_Ghost (Slide_If_Necessary (Str))\n+       and then Value_Integer (Str) = Val;\n+   --  Ghost lemma used in the proof of 'Image implementation, to prove that\n+   --  the result of Value_Integer on a decimal string is the same as the\n+   --  signing the result of Scan_Based_Number_Ghost.\n+\n private\n \n    ----------------"}, {"sha": "db1051b7e3f0bc73c5d0f6bbe86eae3c51a3a79d", "filename": "gcc/ada/libgnat/s-valuti.ads", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-valuti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-valuti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuti.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -376,6 +376,41 @@ is\n    --  no check for this case, the caller must ensure this condition is met.\n    pragma Warnings (GNATprove, On, \"\"\"Ptr\"\" is not modified\");\n \n+   --  Bundle Int type with other types, constants and subprograms used in\n+   --  ghost code, so that this package can be instantiated once and used\n+   --  multiple times as generic formal for a given Int type.\n+   generic\n+      type Int is range <>;\n+      type Uns is mod <>;\n+      type Uns_Option is private;\n+\n+      Unsigned_Width_Ghost : Natural;\n+\n+      with function Wrap_Option (Value : Uns) return Uns_Option;\n+      with function Only_Decimal_Ghost\n+        (Str      : String;\n+         From, To : Integer)\n+         return Boolean;\n+      with function Hexa_To_Unsigned_Ghost (X : Character) return Uns;\n+      with function Scan_Based_Number_Ghost\n+        (Str      : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+         return Uns_Option;\n+      with function Is_Integer_Ghost (Str : String) return Boolean;\n+      with procedure Prove_Iter_Scan_Based_Number_Ghost\n+        (Str1, Str2 : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0);\n+      with procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int);\n+      with function Abs_Uns_Of_Int (Val : Int) return Uns;\n+      with function Value_Integer (Str : String) return Int;\n+\n+   package Int_Params is\n+   end Int_Params;\n+\n private\n \n    ------------------------"}, {"sha": "2c583b31c6c10fee9ef4584e39b66f41d1fc4627", "filename": "gcc/ada/libgnat/s-widthu.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-widthu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d68769419b64ef9843c4c1eac5261217693b1e/gcc%2Fada%2Flibgnat%2Fs-widthu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widthu.ads?ref=91d68769419b64ef9843c4c1eac5261217693b1e", "patch": "@@ -59,7 +59,7 @@ is\n    function Big (Arg : Uns) return Big_Integer renames\n      Unsigned_Conversion.To_Big_Integer;\n \n-   Big_10 : constant Big_Integer := Big (10) with Ghost;\n+   Big_10 : constant Big_Integer := Big (Uns'(10)) with Ghost;\n \n    --  Maximum value of exponent for 10 that fits in Uns'Base\n    function Max_Log10 return Natural is"}]}