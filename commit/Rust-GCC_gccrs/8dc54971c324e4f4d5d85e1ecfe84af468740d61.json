{"sha": "8dc54971c324e4f4d5d85e1ecfe84af468740d61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjNTQ5NzFjMzI0ZTRmNGQ1ZDg1ZTFlY2ZlODRhZjQ2ODc0MGQ2MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-10-09T21:12:45Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-10-09T21:12:45Z"}, "message": "Make-lang.in (CXX_EXTRA_HEADERS): Remove.\n\n        * Make-lang.in (CXX_EXTRA_HEADERS): Remove.\n        (c++ language support bits for libgcc): Remove.\n        (c++.clean): Remove cplib2.txt cleanup.\n        * config-lang.in (headers, lib2funcs): Remove.\n\n        * exception.cc, new.cc, new1.cc, new2.cc: Remove files.\n        * tinfo.cc, tinfo.h, tinfo2.cc, vec.cc: Remove files.\n        * inc/cxxabi.h, inc/exception, inc/new: Remove files.\n        * inc/new.h, inc/typeinfo: Remove files.\n\nFrom-SVN: r36816", "tree": {"sha": "1645dbc5856ddb791e5e2117f2b95546d325c675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1645dbc5856ddb791e5e2117f2b95546d325c675"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dc54971c324e4f4d5d85e1ecfe84af468740d61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc54971c324e4f4d5d85e1ecfe84af468740d61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc54971c324e4f4d5d85e1ecfe84af468740d61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc54971c324e4f4d5d85e1ecfe84af468740d61/comments", "author": null, "committer": null, "parents": [{"sha": "3734420fe1abfd0cbe626423a5a4a2b7046e733b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3734420fe1abfd0cbe626423a5a4a2b7046e733b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3734420fe1abfd0cbe626423a5a4a2b7046e733b"}], "stats": {"total": 3677, "additions": 12, "deletions": 3665}, "files": [{"sha": "a5a1b5e47640ab599f0b34fc261c6633a88f7352", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc54971c324e4f4d5d85e1ecfe84af468740d61/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc54971c324e4f4d5d85e1ecfe84af468740d61/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8dc54971c324e4f4d5d85e1ecfe84af468740d61", "patch": "@@ -1,3 +1,15 @@\n+2000-10-09  Richard Henderson  <rth@cygnus.com>\n+\n+\t* Make-lang.in (CXX_EXTRA_HEADERS): Remove.\n+\t(c++ language support bits for libgcc): Remove.\n+\t(c++.clean): Remove cplib2.txt cleanup.\n+\t* config-lang.in (headers, lib2funcs): Remove.\n+\n+\t* exception.cc, new.cc, new1.cc, new2.cc: Remove files.\n+\t* tinfo.cc, tinfo.h, tinfo2.cc, vec.cc: Remove files.\n+\t* inc/cxxabi.h, inc/exception, inc/new: Remove files.\n+\t* inc/new.h, inc/typeinfo: Remove files.\n+\n 2000-10-08  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* decl.c (INTMAX_TYPE, UINTMAX_TYPE): Define if not already"}, {"sha": "2e426b6c491b4abab8dda54d388abe22f5150b13", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc54971c324e4f4d5d85e1ecfe84af468740d61/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc54971c324e4f4d5d85e1ecfe84af468740d61/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=8dc54971c324e4f4d5d85e1ecfe84af468740d61", "patch": "@@ -56,10 +56,6 @@ DEMANGLER_CROSS_NAME = `t='$(program_transform_cross_name)'; echo c++filt | sed\n # The name to use for the demangler program.\n DEMANGLER_PROG = c++filt$(exeext)\n \n-# Extra headers to install.\n-CXX_EXTRA_HEADERS = $(srcdir)/cp/inc/typeinfo $(srcdir)/cp/inc/exception \\\n-\t$(srcdir)/cp/inc/new $(srcdir)/cp/inc/new.h $(srcdir)/cp/inc/cxxabi.h\n-\n # Extra code to include in libgcc2.\n CXX_LIB2FUNCS = tinfo.o tinfo2.o new.o opnew.o opnewnt.o opvnew.o opvnewnt.o \\\n \topdel.o opdelnt.o opvdel.o opvdelnt.o exception.o vec.o\n@@ -137,59 +133,6 @@ c++.rest.encap: $(DEMANGLER_PROG)\n \n c++.info:\n c++.dvi:\n-\n-# C++ language-support library pieces for libgcc.\n-tinfo.o: cc1plus$(exeext) $(srcdir)/cp/tinfo.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/tinfo.cc\n-tinfo2.o: cc1plus$(exeext) $(srcdir)/cp/tinfo2.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/tinfo2.cc\n-exception.o: cc1plus$(exeext) $(srcdir)/cp/exception.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c -fexceptions $(srcdir)/cp/exception.cc\n-new.o: cc1plus$(exeext) $(srcdir)/cp/new.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/new.cc\n-opnew.o: cc1plus$(exeext) $(srcdir)/cp/new1.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/new1.cc -DL_op_new -o opnew.o\n-opnewnt.o: cc1plus$(exeext) $(srcdir)/cp/new1.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/new1.cc -DL_op_newnt -o opnewnt.o\n-opvnew.o: cc1plus$(exeext) $(srcdir)/cp/new2.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/new2.cc -DL_op_vnew -o opvnew.o\n-opvnewnt.o: cc1plus$(exeext) $(srcdir)/cp/new2.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/new2.cc -DL_op_vnewnt -o opvnewnt.o\n-opdel.o: cc1plus$(exeext) $(srcdir)/cp/new2.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/new2.cc -DL_op_delete -o opdel.o\n-opdelnt.o: cc1plus$(exeext) $(srcdir)/cp/new2.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/new2.cc -DL_op_delnt -o opdelnt.o\n-opvdel.o: cc1plus$(exeext) $(srcdir)/cp/new2.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/new2.cc -DL_op_vdel -o opvdel.o\n-opvdelnt.o: cc1plus$(exeext) $(srcdir)/cp/new2.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/new2.cc -DL_op_vdelnt -o opvdelnt.o\n-vec.o: cc1plus$(exeext) $(srcdir)/cp/vec.cc\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n-\t  -c $(srcdir)/cp/vec.cc -o vec.o\n-\n-# We want to update cplib2.txt if any of the source files change or if the\n-# Makefile (which contains the list of sources) changes.\n-cplib2.txt: $(CXX_LIB2SRCS) $(CXX_EXTRA_HEADERS) cp/Makefile\n-\tcase \" $(LANGUAGES) \" in \\\n-\t*\" \"[cC]\"++ \"*) \\\n-\t  echo $(CXX_LIB2FUNCS) > cplib2.new;; \\\n-\t*) \\\n-\t  echo \"\" > cplib2.new;; \\\n-\tesac\n-\tmv -f cplib2.new cplib2.txt \n-\n #\f\n # Install hooks:\n # cc1plus is installed elsewhere as part of $(COMPILERS).\n@@ -269,7 +212,6 @@ c++.uninstall:\n c++.mostlyclean:\n \t-rm -f cp/*$(objext) $(DEMANGLER_PROG)\n c++.clean:\n-\t-rm -f cplib2.txt\n c++.distclean:\n \t-rm -f cp/config.status cp/Makefile\n \t-rm -f cp/parse.output"}, {"sha": "5b334f148ef9f11d7bebc5e7b95af48dffa469cd", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc54971c324e4f4d5d85e1ecfe84af468740d61/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc54971c324e4f4d5d85e1ecfe84af468740d61/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=8dc54971c324e4f4d5d85e1ecfe84af468740d61", "patch": "@@ -34,8 +34,4 @@ stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n diff_excludes=\"-x parse.c -x parse.h\"\n \n-headers='$(CXX_EXTRA_HEADERS)'\n-\n-lib2funcs=cplib2.txt\n-\n outputs=cp/Makefile"}, {"sha": "886915c823bb5554ea93f59761ed7d5884193679", "filename": "gcc/cp/exception.cc", "status": "removed", "additions": 0, "deletions": 403, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,403 +0,0 @@\n-// Functions for Exception Support for -*- C++ -*-\n-// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA. \n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#pragma implementation \"exception\"\n-\n-#include \"typeinfo\"\n-#include \"exception\"\n-#include <stddef.h>\n-#include \"gansidecl.h\" /* Needed to support macros used in eh-common.h. */\n-#include \"eh-common.h\"\n-\n-/* Define terminate, unexpected, set_terminate, set_unexpected as\n-   well as the default terminate func and default unexpected func.  */\n-\n-extern std::terminate_handler __terminate_func __attribute__((__noreturn__));\n-using std::terminate;\n-\n-void\n-std::terminate ()\n-{\n-  __terminate_func ();\n-}\n-\n-void\n-__default_unexpected ()\n-{\n-  terminate ();\n-}\n-\n-static std::unexpected_handler __unexpected_func __attribute__((__noreturn__))\n-  = __default_unexpected;\n-\n-std::terminate_handler\n-std::set_terminate (std::terminate_handler func)\n-{\n-  std::terminate_handler old = __terminate_func;\n-\n-  __terminate_func = func;\n-  return old;\n-}\n-\n-std::unexpected_handler\n-std::set_unexpected (std::unexpected_handler func)\n-{\n-  std::unexpected_handler old = __unexpected_func;\n-\n-  __unexpected_func = func;\n-  return old;\n-}\n-\n-void\n-std::unexpected ()\n-{\n-  __unexpected_func ();\n-}\n-\n-/* The type of a function called to clean up an exception object.\n-   (These will be destructors.)  Under the old ABI, these take a\n-   second argument (the `in-charge' argument), that indicates whether\n-   or not do delete the object, and whether or not to destroy virtual\n-   bases.  Under the new ABI, there is no second argument.  */\n-#if !defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-typedef void (*cleanup_fn)(void *, int);\n-/* The `2' is the value for the in-charge parameter that indicates\n-   that virtual bases should be destroyed.  */\n-#define CALL_CLEANUP(FN, THIS) FN (THIS, 2)\n-#else\n-typedef void (*cleanup_fn)(void *);\n-#define CALL_CLEANUP(FN, THIS) FN (THIS)\n-#endif\n-\n-/* C++-specific state about the current exception.\n-   This must match init_exception_processing().\n-\n-   Note that handlers and caught are not redundant; when rethrown, an\n-   exception can have multiple active handlers and still be considered\n-   uncaught.  */\n-\n-struct cp_eh_info\n-{\n-  __eh_info eh_info;\n-  void *value;\n-  void *type;\n-  cleanup_fn cleanup;\n-  bool caught;\n-  cp_eh_info *next;\n-  long handlers;\n-  void *original_value;\n-};\n-\n-/* Language-specific EH info pointer, defined in libgcc2. */\n-\n-extern \"C\" cp_eh_info **__get_eh_info (); \t// actually void **\n-\n-/* Exception allocate and free, defined in libgcc2. */\n-extern \"C\" void *__eh_alloc(size_t);\n-extern \"C\" void __eh_free(void *);\n-\n-/* Is P the type_info node for a pointer of some kind?  */\n-\n-extern bool __is_pointer (void *);\n-\n-\n-/* OLD Compiler hook to return a pointer to the info for the current exception.\n-   Used by get_eh_info ().  This fudges the actualy returned value to\n-   point to the beginning of what USE to be the cp_eh_info structure.\n-   THis is so that old code that dereferences this pointer will find\n-   things where it expects it to be.*/\n-extern \"C\" void *\n-__cp_exception_info (void)\n-{\n-  return &((*__get_eh_info ())->value);\n-}\n-\n-#define CP_EH_INFO ((cp_eh_info *) *__get_eh_info ())\n-\n-/* Old Compiler hook to return a pointer to the info for the current exception.\n-   Used by get_eh_info ().  */\n-\n-extern \"C\" cp_eh_info *\n-__cp_eh_info (void)\n-{\n-  cp_eh_info *p = CP_EH_INFO;\n-  return p;\n-}\n-\n-/* Compiler hook to return a pointer to the info for the current exception,\n-   Set the caught bit, and increment the number of handlers that are\n-   looking at this exception. This makes handlers smaller. */\n-\n-extern \"C\" cp_eh_info *\n-__start_cp_handler (void)\n-{\n-  cp_eh_info *p = CP_EH_INFO;\n-  p->caught = 1;\n-  p->handlers++;\n-  return p;\n-}\n-\n-extern \"C\" int __throw_type_match_rtti_2 (const void *, const void *,\n-\t\t\t\t\t void *, void **);\n-\n-extern \"C\" void *\n-__cplus_type_matcher (__eh_info *info_, void *match_info,\n-\t\t      exception_descriptor *exception_table)\n-{\n-  cp_eh_info *info = (cp_eh_info *)info_;\n-\n-  /* No exception table implies the old style mechanism, so don't check. */\n-  if (exception_table != NULL \n-      && exception_table->lang.language != EH_LANG_C_plus_plus)\n-    return NULL;\n-\n-  if (match_info == CATCH_ALL_TYPE)\n-    return (void *)1;\n-\n-  /* we don't worry about version info yet, there is only one version! */\n-  \n-  void *match_type = match_info;\n-  \n-#if !defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-  match_type  = ((void *(*)())match_type) ();\n-#endif\n-\n-  if (__throw_type_match_rtti_2 (match_type, info->type,\n-\t\t\t\t info->original_value, &info->value))\n-    // Arbitrary non-null pointer.\n-    return (void *)1;\n-  else\n-    return NULL;\n-}\n-\n-/* Compiler hook to push a new exception onto the stack.\n-   Used by expand_throw().  */\n-\n-extern \"C\" void\n-__cp_push_exception (void *value, void *type, cleanup_fn cleanup)\n-{\n-  cp_eh_info *p = (cp_eh_info *) __eh_alloc (sizeof (cp_eh_info));\n-\n-  p->value = value;\n-  p->type = type;\n-  p->cleanup = cleanup;\n-  p->handlers = 0;\n-  p->caught = false;\n-  p->original_value = value;\n-\n-  p->eh_info.match_function = __cplus_type_matcher;\n-  p->eh_info.language = EH_LANG_C_plus_plus;\n-  p->eh_info.version = 1;\n-\n-  cp_eh_info **q = __get_eh_info ();\n-\n-  p->next = *q;\n-  *q = p;\n-}\n-\n-/* Compiler hook to pop an exception that has been finalized.  Used by\n-   push_eh_cleanup().  P is the info for the exception caught by the\n-   current catch block.  */\n-\n-extern \"C\" void\n-__cp_pop_exception (cp_eh_info *p)\n-{\n-  cp_eh_info **stack = __get_eh_info ();\n-  cp_eh_info **q = stack;\n-\n-  --p->handlers;\n-\n-  /* Do nothing if our exception is being rethrown (i.e. if the active\n-     exception is our exception and it is uncaught).  */\n-  if (p == *q && !p->caught)\n-    return;\n-\n-  /* Don't really pop if there are still active handlers for our exception;\n-     rather, push it down past any uncaught exceptions.  */\n-  if (p->handlers != 0)\n-    {\n-      if (p == *q && p->next && !p->next->caught)\n-\t{\n-\t  q = &(p->next);\n-\t  while (1)\n-\t    {\n-\t      if (*q == 0 || (*q)->caught)\n-\t\tbreak;\n-\n-\t      q = &((*q)->next);\n-\t    }\n-\t  *stack = p->next;\n-\t  p->next = *q;\n-\t  *q = p;\n-\t}\n-      return;\n-    }\n-\n-  for (; *q; q = &((*q)->next))\n-    if (*q == p)\n-      break;\n-\n-  if (! *q)\n-    terminate ();\n-\n-  *q = p->next;\n-\n-  if (p->cleanup)\n-    // value may have been adjusted.\n-    CALL_CLEANUP (p->cleanup, p->original_value);\n-\n-  if (! __is_pointer (p->type))\n-    __eh_free (p->original_value);  // value may have been adjusted.\n-\n-  __eh_free (p);\n-}\n-\n-/* We're doing a rethrow.  Find the currently handled exception, mark it\n-   uncaught, and move it to the top of the EH stack.  */\n-\n-extern \"C\" void\n-__uncatch_exception (void)\n-{\n-  cp_eh_info **stack = __get_eh_info ();\n-  cp_eh_info **q = stack;\n-  cp_eh_info *p;\n-\n-  while (1)\n-    {\n-      p = *q;\n-\n-      if (p == 0)\n-\tterminate ();\n-      if (p->caught)\n-\tbreak;\n-\n-      q = &(p->next);\n-    }\n-\n-  if (q != stack)\n-    {\n-      *q = p->next;\n-      p->next = *stack;\n-      *stack = p;\n-    }\n-\n-  p->caught = false;\n-}\n-\n-/* As per [except.unexpected]:\n-   If an exception is thrown, we check it against the spec.  If it doesn't\n-   match, we call unexpected ().  If unexpected () throws, we check that\n-   exception against the spec.  If it doesn't match, if the spec allows\n-   bad_exception we throw that; otherwise we call terminate ().\n-\n-   The compiler treats an exception spec as a try block with a generic\n-   handler that just calls this function with a list of the allowed\n-   exception types, so we have an active exception that can be rethrown.\n-\n-   This function does not return.  */   \n-\n-extern \"C\" void\n-__check_eh_spec (int n, const void **spec)\n-{\n-  cp_eh_info *p = CP_EH_INFO;\n-  void *d;\n-\n-  for (int i = 0; i < n; ++i)\n-    {\n-      if (__throw_type_match_rtti_2 (spec[i], p->type, p->value, &d))\n-\tthrow;\n-    }\n-\n-  try\n-    {\n-      std::unexpected ();\n-    }\n-  catch (...)\n-    {\n-      // __exception_info is an artificial var pushed into each catch block.\n-      if (p != __exception_info)\n-\t{\n-\t  p = __exception_info;\n-\t  for (int i = 0; i < n; ++i)\n-\t    {\n-\t      if (__throw_type_match_rtti_2 (spec[i], p->type, p->value, &d))\n-\t\tthrow;\n-\t    }\n-\t}\n-\n-      const std::type_info &bad_exc = typeid (std::bad_exception);\n-      for (int i = 0; i < n; ++i)\n-\t{\n-\t  if (__throw_type_match_rtti_2 (spec[i], &bad_exc, p->value, &d))\n-\t    throw std::bad_exception ();\n-\t}\n-\n-      terminate ();\n-    }\n-}\n-\n-/* Special case of the above for throw() specs.  */\n-\n-extern \"C\" void\n-__check_null_eh_spec (void)\n-{\n-  __check_eh_spec (0, 0);\n-}\n-\n-// Helpers for rtti. Although these don't return, we give them return types so\n-// that the type system is not broken.\n-\n-extern \"C\" void *\n-__throw_bad_cast ()\n-{\n-  throw std::bad_cast ();\n-  return 0;\n-}\n-\n-extern \"C\" std::type_info const &\n-__throw_bad_typeid ()\n-{\n-  throw std::bad_typeid ();\n-  return typeid (void);\n-}\n-\n-/* Has the current exception been caught?  */\n-\n-bool\n-std::uncaught_exception ()\n-{\n-  cp_eh_info *p = CP_EH_INFO;\n-  return p && ! p->caught;\n-}\n-\n-const char * std::exception::\n-what () const\n-{\n-  return typeid (*this).name ();\n-}"}, {"sha": "908d7c467fec0b25c5bc20e955090e5a7fbb454e", "filename": "gcc/cp/inc/cxxabi.h", "status": "removed", "additions": 0, "deletions": 519, "changes": 519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Finc%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Finc%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fcxxabi.h?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,519 +0,0 @@\n-/* new abi support -*- C++ -*-\n-   Copyright (C) 2000\n-   Free Software Foundation, Inc.\n-   Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>  */\n-\n-// This file is part of GNU CC.\n-//\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/* This file declares the new abi entry points into the runtime. It is not\n-   normally necessary for user programs to include this header, or use the\n-   entry points directly. However, this header is available should that be\n-   needed.\n-   \n-   Some of the entry points are intended for both C and C++, thus this header\n-   is includable from both C and C++. Though the C++ specific parts are not\n-   available in C, naturally enough.  */\n-\n-#ifndef __CXXABI_H\n-#define __CXXABI_H 1\n-\n-#if defined(__cplusplus) && (!defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100)\n-/* These structures only make sense when targeting the new abi, catch a\n-   bonehead error early rather than let the user get very confused.  */\n-#error \"Not targetting the new abi, supply -fnew-abi\"\n-#endif\n-\n-#ifdef __cplusplus\n-\n-// We use the compiler builtins __SIZE_TYPE__ and __PTRDIFF_TYPE__ instead of\n-// std::size_t and std::ptrdiff_t respectively. This makes us independant of\n-// the conformance level of <cstddef> and whether -fhonor-std was supplied.\n-// <cstddef> is not currently available during compiler building anyway.\n-// Including <stddef.h> would be wrong, as that would rudely place size_t in\n-// the global namespace.\n-\n-#include <typeinfo>\n-\n-namespace __cxxabiv1\n-{\n-\n-/* type information for int, float etc */\n-class __fundamental_type_info\n-  : public std::type_info\n-{\n-public:\n-  virtual ~__fundamental_type_info ();\n-public:\n-  explicit __fundamental_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-};\n-\n-/* type information for array objects */\n-class __array_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-protected:\n-  virtual ~__array_type_info ();\n-public:\n-  explicit __array_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-};\n-\n-/* type information for functions (both member and non-member) */\n-class __function_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__function_type_info ();\n-public:\n-  explicit __function_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-  \n-/* implementation defined member functions */\n-protected:\n-  virtual bool __is_function_p () const;\n-};\n-\n-/* type information for enumerations */\n-class __enum_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__enum_type_info ();\n-public:\n-  explicit __enum_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-};\n-\n-/* common type information for simple pointers and pointers to member */\n-class __pbase_type_info\n-  : public std::type_info\n-{\n-/* abi defined member variables */\n-public:\n-  unsigned int __qualifier_flags; /* qualification of the target object */\n-  const std::type_info *__pointee;   /* type of pointed to object */\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__pbase_type_info ();\n-public:\n-  explicit __pbase_type_info (const char *__n,\n-                                int __quals,\n-                                const std::type_info *__type)\n-    : std::type_info (__n), __qualifier_flags (__quals), __pointee (__type)\n-    { }\n-\n-/* implementation defined types */\n-public:\n-  enum __qualifier_masks {\n-    __const_mask = 0x1,\n-    __volatile_mask = 0x2,\n-    __restrict_mask = 0x4,\n-    __incomplete_mask = 0x8,\n-    __incomplete_class_mask = 0x10\n-  };\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_catch (const std::type_info *__thr_type,\n-                           void **__thr_obj,\n-                           unsigned __outer) const;\n-protected:\n-  inline virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n-                                       void **__thr_obj,\n-                                       unsigned __outer) const;\n-};\n-\n-/* type information for simple pointers */\n-class __pointer_type_info\n-  : public __pbase_type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__pointer_type_info ();\n-public:\n-  explicit __pointer_type_info (const char *__n,\n-                                int __quals,\n-                                const std::type_info *__type)\n-    : __pbase_type_info (__n, __quals, __type)\n-    { }\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __is_pointer_p () const;\n-\n-protected:\n-  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n-                                void **__thr_obj,\n-                                unsigned __outer) const;\n-};\n-\n-/* type information for a pointer to member variable */\n-class __pointer_to_member_type_info\n-  : public __pbase_type_info\n-{\n-/* abi defined member variables */\n-public:\n-  __class_type_info *__context_class;   /* class of the member */\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__pointer_to_member_type_info ();\n-public:\n-  explicit __pointer_to_member_type_info (const char *__n,\n-                                          int __quals,\n-                                          const std::type_info *__type,\n-                                          __class_type_info *__klass)\n-    : __pbase_type_info (__n, __quals, __type), __context_class (__klass)\n-    { }\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n-                                void **__thr_obj,\n-                                unsigned __outer) const;\n-};\n-\n-class __class_type_info;\n-\n-/* helper class for __vmi_class_type */\n-class __base_class_info\n-{\n-/* abi defined member variables */\n-public:\n-  const __class_type_info *__base;    /* base class type */\n-  long __offset_flags;            /* offset and info */\n-\n-/* implementation defined types */\n-public:\n-  enum __offset_flags_masks {\n-    __virtual_mask = 0x1,\n-    __public_mask = 0x2,\n-    hwm_bit = 2,\n-    offset_shift = 8          /* bits to shift offset by */\n-  };\n-  \n-/* implementation defined member functions */\n-public:\n-  bool __is_virtual_p () const\n-    { return __offset_flags & __virtual_mask; }\n-  bool __is_public_p () const\n-    { return __offset_flags & __public_mask; }\n-  __PTRDIFF_TYPE__ __offset () const\n-    { \n-      // This shift, being of a signed type, is implementation defined. GCC\n-      // implements such shifts as arithmetic, which is what we want.\n-      return static_cast<__PTRDIFF_TYPE__> (__offset_flags) >> offset_shift;\n-    }\n-};\n-\n-/* type information for a class */\n-class __class_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__class_type_info ();\n-public:\n-  explicit __class_type_info (const char *__n)\n-    : type_info (__n)\n-    { }\n-\n-/* implementation defined types */\n-public:\n-  /* sub_kind tells us about how a base object is contained within a derived\n-     object. We often do this lazily, hence the UNKNOWN value. At other times\n-     we may use NOT_CONTAINED to mean not publicly contained. */\n-  enum __sub_kind\n-  {\n-    __unknown = 0,              /* we have no idea */\n-    __not_contained,            /* not contained within us (in some */\n-                                /* circumstances this might mean not contained */\n-                                /* publicly) */\n-    __contained_ambig,          /* contained ambiguously */\n-    \n-    __contained_virtual_mask = __base_class_info::__virtual_mask, /* via a virtual path */\n-    __contained_public_mask = __base_class_info::__public_mask,   /* via a public path */\n-    __contained_mask = 1 << __base_class_info::hwm_bit,         /* contained within us */\n-    \n-    __contained_private = __contained_mask,\n-    __contained_public = __contained_mask | __contained_public_mask\n-  };\n-\n-public:  \n-  struct __upcast_result;\n-  struct __dyncast_result;\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_upcast (const __class_type_info *__dst_type, void **__obj_ptr) const;\n-\n-protected:\n-  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,\n-                           unsigned __outer) const;\n-\n-\n-public:\n-  /* Helper for upcast. See if DST is us, or one of our bases. */\n-  /* Return false if not found, true if found. */\n-  virtual bool __do_upcast (const __class_type_info *__dst,\n-                            const void *__obj,\n-                            __upcast_result &__restrict __result) const;\n-\n-public:\n-  /* Indicate whether SRC_PTR of type SRC_TYPE is contained publicly within\n-     OBJ_PTR. OBJ_PTR points to a base object of our type, which is the\n-     destination type. SRC2DST indicates how SRC objects might be contained\n-     within this type.  If SRC_PTR is one of our SRC_TYPE bases, indicate the\n-     virtuality. Returns not_contained for non containment or private\n-     containment. */\n-  inline __sub_kind __find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                       const void *__obj_ptr,\n-                                       const __class_type_info *__src_type,\n-                                       const void *__src_ptr) const;\n-\n-public:\n-  /* dynamic cast helper. ACCESS_PATH gives the access from the most derived\n-     object to this base. DST_TYPE indicates the desired type we want. OBJ_PTR\n-     points to a base of our type within the complete object. SRC_TYPE\n-     indicates the static type started from and SRC_PTR points to that base\n-     within the most derived object. Fill in RESULT with what we find. Return\n-     true if we have located an ambiguous match. */\n-  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n-                             __sub_kind __access_path,\n-                             const __class_type_info *__dst_type,\n-                             const void *__obj_ptr,\n-                             const __class_type_info *__src_type,\n-                             const void *__src_ptr,\n-                             __dyncast_result &__result) const;\n-public:\n-  /* Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE bases are\n-     inherited by the type started from -- which is not necessarily the\n-     current type. The current type will be a base of the destination type.\n-     OBJ_PTR points to the current base. */\n-  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                           const void *__obj_ptr,\n-                                           const __class_type_info *__src_type,\n-                                           const void *__src_ptr) const;\n-};\n-\n-/* type information for a class with a single non-virtual base */\n-class __si_class_type_info\n-  : public __class_type_info\n-{\n-/* abi defined member variables */\n-public:\n-  const __class_type_info *__base_type;\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__si_class_type_info ();\n-public:\n-  explicit __si_class_type_info (const char *__n,\n-                                 const __class_type_info *__base)\n-    : __class_type_info (__n), __base_type (__base)\n-    { }\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n-                             __sub_kind __access_path,\n-                             const __class_type_info *__dst_type,\n-                             const void *__obj_ptr,\n-                             const __class_type_info *__src_type,\n-                             const void *__src_ptr,\n-                             __dyncast_result &__result) const;\n-  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                           const void *__obj_ptr,\n-                                           const __class_type_info *__src_type,\n-                                           const void *__sub_ptr) const;\n-  virtual bool __do_upcast (const __class_type_info *__dst,\n-                            const void *__obj,\n-                            __upcast_result &__restrict __result) const;\n-};\n-\n-/* type information for a class with multiple and/or virtual bases */\n-class __vmi_class_type_info : public __class_type_info {\n-/* abi defined member variables */\n-public:\n-  unsigned int __flags;         /* details about the class heirarchy */\n-  unsigned int __base_count;    /* number of direct bases */\n-  __base_class_info const __base_info[1]; /* array of bases */\n-  /* The array of bases uses the trailing array struct hack\n-     so this class is not constructable with a normal constructor. It is\n-     internally generated by the compiler. */\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__vmi_class_type_info ();\n-public:\n-  explicit __vmi_class_type_info (const char *__n,\n-                                  int ___flags)\n-    : __class_type_info (__n), __flags (___flags), __base_count (0)\n-    { }\n-\n-/* implementation defined types */\n-public:\n-  enum __flags_masks {\n-    __non_diamond_repeat_mask = 0x1,   /* distinct instance of repeated base */\n-    __diamond_shaped_mask = 0x2,       /* diamond shaped multiple inheritance */\n-    non_public_base_mask = 0x4,      /* has non-public direct or indirect base */\n-    public_base_mask = 0x8,          /* has public base (direct) */\n-    \n-    __flags_unknown_mask = 0x10\n-  };\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n-                             __sub_kind __access_path,\n-                             const __class_type_info *__dst_type,\n-                             const void *__obj_ptr,\n-                             const __class_type_info *__src_type,\n-                             const void *__src_ptr,\n-                             __dyncast_result &__result) const;\n-  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                           const void *__obj_ptr,\n-                                           const __class_type_info *__src_type,\n-                                           const void *__src_ptr) const;\n-  virtual bool __do_upcast (const __class_type_info *__dst,\n-                            const void *__obj,\n-                            __upcast_result &__restrict __result) const;\n-};\n-\n-/* dynamic cast runtime */\n-extern \"C\"\n-void *__dynamic_cast (const void *__src_ptr,    /* object started from */\n-                      const __class_type_info *__src_type, /* static type of object */\n-                      const __class_type_info *__dst_type, /* desired target type */\n-                      __PTRDIFF_TYPE__ __src2dst); /* how src and dst are related */\n-\n-    /* src2dst has the following possible values\n-       >= 0: src_type is a unique public non-virtual base of dst_type\n-             dst_ptr + src2dst == src_ptr\n-       -1: unspecified relationship\n-       -2: src_type is not a public base of dst_type\n-       -3: src_type is a multiple public non-virtual base of dst_type */\n-\n-/* array ctor/dtor routines */\n-\n-/* allocate and construct array */\n-extern \"C\"\n-void *__cxa_vec_new (__SIZE_TYPE__ __element_count,\n-                     __SIZE_TYPE__ __element_size,\n-                     __SIZE_TYPE__ __padding_size,\n-                     void (*__constructor) (void *),\n-                     void (*__destructor) (void *));\n-\n-extern \"C\"\n-void *__cxa_vec_new2 (__SIZE_TYPE__ __element_count,\n-                      __SIZE_TYPE__ __element_size,\n-                      __SIZE_TYPE__ __padding_size,\n-                      void (*__constructor) (void *),\n-                      void (*__destructor) (void *),\n-                      void *(*__alloc) (__SIZE_TYPE__),\n-                      void (*__dealloc) (void *));\n-\n-extern \"C\"\n-void *__cxa_vec_new3 (__SIZE_TYPE__ __element_count,\n-                      __SIZE_TYPE__ __element_size,\n-                      __SIZE_TYPE__ __padding_size,\n-                      void (*__constructor) (void *),\n-                      void (*__destructor) (void *),\n-                      void *(*__alloc) (__SIZE_TYPE__),\n-                      void (*__dealloc) (void *, __SIZE_TYPE__));\n-\n-/* construct array */\n-extern \"C\"\n-void __cxa_vec_ctor (void *__array_address,\n-                     __SIZE_TYPE__ __element_count,\n-                     __SIZE_TYPE__ __element_size,\n-                     void (*__constructor) (void *),\n-                     void (*__destructor) (void *));\n-\n-extern \"C\"\n-void __cxa_vec_cctor (void *dest_array,\n-\t\t      void *src_array,\n-\t\t      __SIZE_TYPE__ element_count,\n-\t\t      __SIZE_TYPE__ element_size,\n-\t\t      void (*constructor) (void *, void *),\n-\t\t      void (*destructor) (void *));\n- \n-/* destruct array */\n-extern \"C\"\n-void __cxa_vec_dtor (void *__array_address,\n-                     __SIZE_TYPE__ __element_count,\n-                     __SIZE_TYPE__ __element_size,\n-                     void (*__destructor) (void *));\n-\n-/* destruct and release array */\n-extern \"C\"\n-void __cxa_vec_delete (void *__array_address,\n-                       __SIZE_TYPE__ __element_size,\n-                       __SIZE_TYPE__ __padding_size,\n-                       void (*__destructor) (void *));\n-\n-extern \"C\"\n-void __cxa_vec_delete2 (void *__array_address,\n-                        __SIZE_TYPE__ __element_size,\n-                        __SIZE_TYPE__ __padding_size,\n-                        void (*__destructor) (void *),\n-                        void (*__dealloc) (void *));\n-                  \n-extern \"C\"\n-void __cxa_vec_delete3 (void *__array_address,\n-                        __SIZE_TYPE__ __element_size,\n-                        __SIZE_TYPE__ __padding_size,\n-                        void (*__destructor) (void *),\n-                        void (*__dealloc) (void *, __SIZE_TYPE__));\n-                  \n-/* demangling routines */\n-\n-extern \"C\" \n-char *__cxa_demangle (const char *__mangled_name,\n-\t\t      char *__output_buffer,\n-\t\t      __SIZE_TYPE__ *__length,\n-\t\t      int *__status);\n-\n-} /* namespace __cxxabiv1 */\n-\n-/* User programs should use the alias `abi'. */\n-namespace abi = __cxxabiv1;\n-\n-#else\n-#endif /* __cplusplus */\n-\n-\n-#endif /* __CXXABI_H */"}, {"sha": "4d35c56c4054ecadc6615534e174c4479aaeba30", "filename": "gcc/cp/inc/exception", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Finc%2Fexception", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Finc%2Fexception", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fexception?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,65 +0,0 @@\n-// Exception Handling support header for -*- C++ -*-\n-// Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-//\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef __EXCEPTION__\n-#define __EXCEPTION__\n-\n-#pragma interface \"exception\"\n-\n-extern \"C++\" {\n-\n-namespace std {\n-\n-class exception {\n-public:\n-  exception () { }\n-  virtual ~exception () { }\n-  virtual const char* what () const;\n-};\n-\n-class bad_exception : public exception {\n-public:\n-  bad_exception () { }\n-  virtual ~bad_exception () { }\n-};\n-\n-typedef void (*terminate_handler) ();\n-typedef void (*unexpected_handler) ();\n-\n-terminate_handler set_terminate (terminate_handler);\n-void terminate () __attribute__ ((__noreturn__));\n-unexpected_handler set_unexpected (unexpected_handler);\n-void unexpected () __attribute__ ((__noreturn__));\n-bool uncaught_exception ();\n-\n-} // namespace std\n-\n-} // extern \"C++\"\n-\n-#endif"}, {"sha": "cbb8d107acff183f8d109e5d341ff9fd00cab464", "filename": "gcc/cp/inc/new", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Finc%2Fnew", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Finc%2Fnew", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fnew?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,68 +0,0 @@\n-// The -*- C++ -*- dynamic memory management header.\n-// Copyright (C) 1994, 1996, 1997, 1998, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-//\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef __NEW__\n-#define __NEW__\n-\n-#pragma interface \"new\"\n-#include <stddef.h>\n-#include <exception>\n-\n-extern \"C++\" {\n-\n-namespace std {\n-\n-  class bad_alloc : public exception {\n-  public:\n-    virtual const char* what() const throw() { return \"bad_alloc\"; }\n-  };\n-\n-  struct nothrow_t {};\n-  extern const nothrow_t nothrow;\n-  typedef void (*new_handler)();\n-  new_handler set_new_handler (new_handler);\n-\n-} // namespace std\n-\n-// replaceable signatures\n-void *operator new (size_t) throw (std::bad_alloc);\n-void *operator new[] (size_t) throw (std::bad_alloc);\n-void operator delete (void *) throw();\n-void operator delete[] (void *) throw();\n-void *operator new (size_t, const std::nothrow_t&) throw();\n-void *operator new[] (size_t, const std::nothrow_t&) throw();\n-void operator delete (void *, const std::nothrow_t&) throw();\n-void operator delete[] (void *, const std::nothrow_t&) throw();\n-\n-// default placement versions of operator new\n-inline void *operator new(size_t, void *place) throw() { return place; }\n-inline void *operator new[](size_t, void *place) throw() { return place; }\n-} // extern \"C++\"\n-\n-#endif"}, {"sha": "cb1fa4cb5caa3becee3728a9a79acb64649d8205", "filename": "gcc/cp/inc/new.h", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Finc%2Fnew.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Finc%2Fnew.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fnew.h?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,38 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// Copyright (C) 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-//\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef __NEW_H__\n-#define __NEW_H__\n-\n-#include <new>\n-\n-using std::new_handler;\n-using std::set_new_handler;\n-\n-#endif // __NEW_H__"}, {"sha": "91f0de2c720c8b7885685bdb2ffc9f34e7c1a55b", "filename": "gcc/cp/inc/typeinfo", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Finc%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Finc%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Ftypeinfo?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,134 +0,0 @@\n-// RTTI support for -*- C++ -*-\n-// Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-//\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-// __GXX_ABI_VERSION distinguishes the ABI that is being used. Values <100\n-// indicate the `old' abi, which grew as C++ was defined. Values >=100\n-// indicate the `new' abi, which is a cross vendor C++ abi, documented at\n-// `http://reality.sgi.com/dehnert_engr/cxx/'.\n-\n-#ifndef __TYPEINFO__\n-#define __TYPEINFO__\n-\n-#pragma interface \"typeinfo\"\n-\n-#include <exception>\n-\n-extern \"C++\" {\n-\n-#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n-namespace __cxxabiv1\n-{\n-  class __class_type_info;\n-} // namespace __cxxabiv1\n-#endif\n-\n-namespace std {\n-\n-class type_info {\n-public:\n-  // Destructor. Being the first non-inline virtual function, this controls in\n-  // which translation unit the vtable is emitted. The compiler makes use of\n-  // that information to know where to emit the runtime-mandated type_info\n-  // structures in the new-abi.\n-  virtual ~type_info ();\n-\n-private:\n-  // Assigning type_info is not supported.  made private.\n-  type_info& operator= (const type_info&);\n-  type_info (const type_info&);\n-\n-protected:\n-  const char *__name;\n-\n-protected:\n-  explicit type_info (const char *__n): __name (__n) { }\n-\n-public:\n-  // the public interface\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-  // In old abi, there can be multiple instances of a type_info object for one\n-  // type. Uniqueness must use the _name value, not object address.\n-  bool before (const type_info& arg) const;\n-  const char* name () const\n-    { return __name; }\n-  bool operator== (const type_info& __arg) const;\n-  bool operator!= (const type_info& __arg) const\n-    { return !operator== (__arg); }\n-\n-#else\n-  // In new abi we can rely on type_info's NTBS being unique,\n-  // and therefore address comparisons are sufficient.\n-  bool before (const type_info& __arg) const\n-    { return __name < __arg.__name; }\n-  const char* name () const\n-    { return __name; }\n-  bool operator== (const type_info& __arg) const\n-    { return __name == __arg.__name; }\n-  bool operator!= (const type_info& __arg) const\n-    { return !operator== (__arg); }\n-#endif\n-\n-  // the internal interface\n-#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n-public:\n-  // return true if this is a pointer type of some kind\n-  virtual bool __is_pointer_p () const;\n-  // return true if this is a function type\n-  virtual bool __is_function_p () const;\n-\n-  // Try and catch a thrown type. Store an adjusted pointer to the caught type\n-  // in THR_OBJ. If THR_TYPE is not a pointer type, then THR_OBJ points to the\n-  // thrown object. If THR_TYPE is a pointer type, then THR_OBJ is the pointer\n-  // itself. OUTER indicates the number of outer pointers, and whether they\n-  // were const qualified.\n-  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,\n-                         unsigned __outer) const;\n-\n-  // internally used during catch matching\n-  virtual bool __do_upcast (const __cxxabiv1::__class_type_info *__target,\n-\t\t\t    void **__obj_ptr) const;\n-#endif\n-};\n-\n-class bad_cast : public exception {\n-public:\n-  bad_cast() { }\n-  virtual ~bad_cast() { }\n-};\n-\n-class bad_typeid : public exception {\n- public:\n-  bad_typeid () { }\n-  virtual ~bad_typeid () { }\n-};\n-\n-} // namespace std\n-\n-} // extern \"C++\"\n-#endif"}, {"sha": "4015ae7cd4ba2c93e3e37243adb266c8cc31e9d7", "filename": "gcc/cp/new.cc", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Fnew.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Fnew.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fnew.cc?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,44 +0,0 @@\n-// Implementation file for the -*- C++ -*- dynamic memory management header.\n-// Copyright (C) 1996, 1997, 1998, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA. \n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#pragma implementation \"new\"\n-#include \"new\"\n-\n-const std::nothrow_t std::nothrow = { };\n-\n-using std::new_handler;\n-new_handler __new_handler;\n-\n-new_handler\n-std::set_new_handler (new_handler handler)\n-{\n-  new_handler prev_handler = __new_handler;\n-  __new_handler = handler;\n-  return prev_handler;\n-}"}, {"sha": "8d76f414356f0e70e912545396490abaea7425d6", "filename": "gcc/cp/new1.cc", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Fnew1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Fnew1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fnew1.cc?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,91 +0,0 @@\n-// Support routines for the -*- C++ -*- dynamic memory management.\n-// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#include \"new\"\n-using std::new_handler;\n-using std::bad_alloc;\n-\n-extern \"C\" void *malloc (size_t);\n-extern new_handler __new_handler;\n-\n-#define WEAK(x) \\\n-  x __attribute__ ((weak)); \\\n-  x\n-\n-#ifdef L_op_newnt\n-WEAK (void * operator new (size_t sz, const std::nothrow_t&) throw())\n-{\n-  void *p;\n-\n-  /* malloc (0) is unpredictable; avoid it.  */\n-  if (sz == 0)\n-    sz = 1;\n-  p = (void *) malloc (sz);\n-  while (p == 0)\n-    {\n-      new_handler handler = __new_handler;\n-      if (! handler)\n-\treturn 0;\n-      try\n-\t{\n-\t  handler ();\n-\t}\n-      catch (bad_alloc &)\n-\t{\n-\t  return 0;\n-\t}\n-\n-      p = (void *) malloc (sz);\n-    }\n-\n-  return p;\n-}\n-#endif\n-\n-#ifdef L_op_new\n-WEAK (void * operator new (size_t sz) throw (std::bad_alloc))\n-{\n-  void *p;\n-\n-  /* malloc (0) is unpredictable; avoid it.  */\n-  if (sz == 0)\n-    sz = 1;\n-  p = (void *) malloc (sz);\n-  while (p == 0)\n-    {\n-      new_handler handler = __new_handler;\n-      if (! handler)\n-\tthrow bad_alloc ();\n-      handler ();\n-      p = (void *) malloc (sz);\n-    }\n-\n-  return p;\n-}\n-#endif"}, {"sha": "abf4420da5db968d65b0c3d23ab966043b7d24ff", "filename": "gcc/cp/new2.cc", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Fnew2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Fnew2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fnew2.cc?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,80 +0,0 @@\n-// Boilerplate support routines for -*- C++ -*- dynamic memory management.\n-// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#include \"new\"\n-\n-extern \"C\" void free (void *);\n-\n-#define WEAK(x) \\\n-  x __attribute__ ((weak)); \\\n-  x\n-\n-#ifdef L_op_vnew\n-WEAK(void * operator new[] (size_t sz) throw (std::bad_alloc))\n-{\n-  return ::operator new(sz);\n-}\n-#endif\n-\n-#ifdef L_op_vnewnt\n-WEAK(void *operator new[] (size_t sz, const std::nothrow_t& nothrow) throw())\n-{\n-  return ::operator new(sz, nothrow);\n-}\n-#endif\n-\n-#ifdef L_op_delete\n-WEAK (void operator delete (void *ptr) throw ())\n-{\n-  if (ptr)\n-    free (ptr);\n-}\n-#endif\n-\n-#ifdef L_op_vdel\n-WEAK (void operator delete[] (void *ptr) throw ())\n-{\n-  ::operator delete (ptr);\n-}\n-#endif\n-\n-#ifdef L_op_delnt\n-WEAK (void operator delete (void *ptr, const std::nothrow_t&) throw ())\n-{\n-  if (ptr)\n-    free (ptr);\n-}\n-#endif\n-\n-#ifdef L_op_vdelnt\n-WEAK (void operator delete[] (void *ptr, const std::nothrow_t&) throw ())\n-{\n-  ::operator delete (ptr);\n-}\n-#endif"}, {"sha": "c381ff111013a5735f38bb547d70496317f0f12a", "filename": "gcc/cp/tinfo.cc", "status": "removed", "additions": 0, "deletions": 1210, "changes": 1210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,1210 +0,0 @@\n-// Methods for type_info for -*- C++ -*- Run Time Type Identification.\n-// Copyright (C) 1994, 1996, 1998, 1999, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA. \n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#pragma implementation \"typeinfo\"\n-\n-#include <stddef.h>\n-#include \"tinfo.h\"\n-#include \"new\"\t\t\t// for placement new\n-\n-// This file contains the minimal working set necessary to link with code\n-// that uses virtual functions and -frtti but does not actually use RTTI\n-// functionality.\n-\n-std::type_info::\n-~type_info ()\n-{ }\n-\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-// original (old) abi\n-\n-namespace\n-{\n-// ADDR is a pointer to an object.  Convert it to a pointer to a base,\n-// using OFFSET.\n-inline void*\n-convert_to_base (void *addr, bool is_virtual, myint32 offset)\n-{\n-  if (!addr)\n-    return NULL;\n-\n-  if (!is_virtual)\n-    return (char *) addr + offset;\n-\n-  // Under the old ABI, the offset gives us the address of a pointer\n-  // to the virtual base.\n-  return *((void **) ((char *) addr + offset));\n-}\n-\n-}\n-\n-// We can't rely on common symbols being shared between shared objects.\n-bool std::type_info::\n-operator== (const std::type_info& arg) const\n-{\n-  return (&arg == this) || (__builtin_strcmp (name (), arg.name ()) == 0);\n-}\n-\n-extern \"C\" void\n-__rtti_class (void *addr, const char *name,\n-\t      const __class_type_info::base_info *bl, size_t bn)\n-{ new (addr) __class_type_info (name, bl, bn); }\n-\n-extern \"C\" void\n-__rtti_si (void *addr, const char *n, const std::type_info *ti)\n-{\n-  new (addr) __si_type_info\n-    (n, static_cast <const __user_type_info &> (*ti));\n-}\n-\n-extern \"C\" void\n-__rtti_user (void *addr, const char *name)\n-{ new (addr) __user_type_info (name); }\n-\n-// Upcast for catch checking. OBJPTR points to the thrown object and might be\n-// NULL. Return 0 on failure, non-zero on success. Set *ADJPTR to adjusted\n-// object pointer.\n-int __user_type_info::\n-upcast (const type_info &target, void *objptr,\n-        void **adjptr) const\n-{\n-  upcast_result result;\n-  \n-  if (do_upcast (contained_public, target, objptr, result))\n-    return 0;\n-  *adjptr = result.target_obj;\n-  return contained_public_p (result.whole2target);\n-}\n-\n-// Down or cross cast for dynamic_cast. OBJPTR points to the most derrived\n-// object, SUBPTR points to the static base object. Both must not be NULL.\n-// TARGET specifies the desired target type, SUBTYPE specifies the static\n-// type. Both must be defined. Returns adjusted object pointer on success,\n-// NULL on failure. [expr.dynamic.cast]/8 says 'unambiguous public base'. This\n-// itself is an ambiguous statement. We choose it to mean the base must be\n-// separately unambiguous and public, rather than unambiguous considering only\n-// public bases.\n-void *__user_type_info::\n-dyncast (int boff,\n-         const type_info &target, void *objptr,\n-         const type_info &subtype, void *subptr) const\n-{\n-  dyncast_result result;\n-  \n-  do_dyncast (boff, contained_public,\n-              target, objptr, subtype, subptr, result);\n-  if (!result.target_obj)\n-    return NULL;\n-  if (contained_public_p (result.target2sub))\n-    return result.target_obj;\n-  if (contained_public_p (sub_kind (result.whole2sub & result.whole2target)))\n-    // Found a valid cross cast\n-    return result.target_obj;\n-  if (contained_nonvirtual_p (result.whole2sub))\n-    // Found an invalid cross cast, which cannot also be a down cast\n-    return NULL;\n-  if (result.target2sub == unknown)\n-    result.target2sub = static_cast <const __user_type_info &> (target)\n-                        .find_public_subobj (boff, subtype,\n-                                             result.target_obj, subptr);\n-  if (contained_public_p (result.target2sub))\n-    // Found a valid down cast\n-    return result.target_obj;\n-  // Must be an invalid down cast, or the cross cast wasn't bettered\n-  return NULL;\n-}\n-\n-// Catch cast helper. ACCESS_PATH is the access from the complete thrown\n-// object to this base. TARGET is the desired type we want to catch. OBJPTR\n-// points to this base within the throw object, it might be NULL. Fill in\n-// RESULT with what we find. Return true, should we determine catch must fail.\n-bool __user_type_info::\n-do_upcast (sub_kind access_path,\n-           const type_info &target, void *objptr,\n-           upcast_result &__restrict result) const\n-{\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.base_type = nonvirtual_base_type;\n-      result.whole2target = access_path;\n-      return contained_nonpublic_p (access_path);\n-    }\n-  return false;\n-}\n-\n-// dynamic cast helper. ACCESS_PATH gives the access from the most derived\n-// object to this base. TARGET indicates the desired type we want. OBJPTR\n-// points to this base within the object. SUBTYPE indicates the static type\n-// started from and SUBPTR points to that base within the most derived object.\n-// Fill in RESULT with what we find. Return true if we have located an\n-// ambiguous match.\n-bool __user_type_info::\n-do_dyncast (int, sub_kind access_path,\n-            const type_info &target, void *objptr,\n-            const type_info &subtype, void *subptr,\n-            dyncast_result &__restrict result) const\n-{\n-  if (objptr == subptr && *this == subtype)\n-    {\n-      // The subobject we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2sub = access_path;\n-      return false;\n-    }\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.whole2target = access_path;\n-      result.target2sub = not_contained;\n-      return false;\n-    }\n-  return false;\n-}\n-\n-// find_public_subobj helper. Return contained_public if we are the desired\n-// subtype. OBJPTR points to this base type, SUBPTR points to the desired base\n-// object.\n-__user_type_info::sub_kind __user_type_info::\n-do_find_public_subobj (int, const type_info &, void *objptr, void *subptr) const\n-{\n-  if (subptr == objptr)\n-    // Must be our type, as the pointers match.\n-    return contained_public;\n-  return not_contained;\n-}\n-\n-// catch helper for single public inheritance types. See\n-// __user_type_info::do_upcast for semantics.\n-bool __si_type_info::\n-do_upcast (sub_kind access_path,\n-           const type_info &target, void *objptr,\n-           upcast_result &__restrict result) const\n-{\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.base_type = nonvirtual_base_type;\n-      result.whole2target = access_path;\n-      return contained_nonpublic_p (access_path);\n-    }\n-  return base.do_upcast (access_path, target, objptr, result);\n-}\n-\n-// dynamic cast helper for single public inheritance types. See\n-// __user_type_info::do_dyncast for semantics. BOFF indicates how SUBTYPE\n-// types are inherited by TARGET types.\n-bool __si_type_info::\n-do_dyncast (int boff, sub_kind access_path,\n-            const type_info &target, void *objptr,\n-            const type_info &subtype, void *subptr,\n-            dyncast_result &__restrict result) const\n-{\n-  if (objptr == subptr && *this == subtype)\n-    {\n-      // The subobject we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2sub = access_path;\n-      return false;\n-    }\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.whole2target = access_path;\n-      if (boff >= 0)\n-        result.target2sub = ((char *)subptr - (char *)objptr) == boff\n-              ? contained_public : not_contained;\n-      else if (boff == -2)\n-        result.target2sub = not_contained;\n-      return false;\n-    }\n-  return base.do_dyncast (boff, access_path,\n-                          target, objptr, subtype, subptr, result);\n-}\n-\n-// find_public_subobj helper. See __user_type_info::do_find_public_subobj or\n-// semantics. BOFF indicates how SUBTYPE types are inherited by the original\n-// target object.\n-__user_type_info::sub_kind __si_type_info::\n-do_find_public_subobj (int boff, const type_info &subtype, void *objptr, void *subptr) const\n-{\n-  if (subptr == objptr && subtype == *this)\n-    return contained_public;\n-  return base.do_find_public_subobj (boff, subtype, objptr, subptr);\n-}\n-\n-// catch helper for multiple or non-public inheritance types. See\n-// __user_type_info::do_upcast for semantics.\n-bool __class_type_info::\n-do_upcast (sub_kind access_path,\n-           const type_info &target, void *objptr,\n-           upcast_result &__restrict result) const\n-{\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.base_type = nonvirtual_base_type;\n-      result.whole2target = access_path;\n-      return contained_nonpublic_p (access_path);\n-    }\n-  \n-  for (size_t i = n_bases; i--;)\n-    {\n-      upcast_result result2;\n-      void *p = objptr;\n-      sub_kind sub_access = access_path;\n-      p = convert_to_base (p, \n-\t\t\t   base_list[i].is_virtual,\n-\t\t\t   base_list[i].offset);\n-      if (base_list[i].is_virtual)\n-\tsub_access = sub_kind (sub_access | contained_virtual_mask);\n-      if (base_list[i].access != PUBLIC)\n-        sub_access = sub_kind (sub_access & ~contained_public_mask);\n-      if (base_list[i].base->do_upcast (sub_access, target, p, result2)\n-          && !contained_virtual_p (result2.whole2target))\n-        return true; // must fail\n-      if (result2.base_type)\n-        {\n-          if (result2.base_type == nonvirtual_base_type\n-              && base_list[i].is_virtual)\n-            result2.base_type = base_list[i].base;\n-          if (!result.base_type)\n-            result = result2;\n-          else if (result.target_obj != result2.target_obj)\n-            {\n-              // Found an ambiguity.\n-\t      result.target_obj = NULL;\n-\t      result.whole2target = contained_ambig;\n-\t      return true;\n-            }\n-          else if (result.target_obj)\n-            {\n-              // Ok, found real object via a virtual path.\n-              result.whole2target\n-                  = sub_kind (result.whole2target | result2.whole2target);\n-            }\n-          else\n-            {\n-              // Dealing with a null pointer, need to check vbase\n-              // containing each of the two choices.\n-              if (result2.base_type == nonvirtual_base_type\n-                  || result.base_type == nonvirtual_base_type\n-                  || !(*result2.base_type == *result.base_type))\n-                {\n-                  // Already ambiguous, not virtual or via different virtuals.\n-                  // Cannot match.\n-                  result.whole2target = contained_ambig;\n-                  return true;\n-                }\n-              result.whole2target\n-                  = sub_kind (result.whole2target | result2.whole2target);\n-            }\n-        }\n-    }\n-  return false;\n-}\n-\n-// dynamic cast helper for non-public or multiple inheritance types. See\n-// __user_type_info::do_dyncast for overall semantics.\n-// This is a big hairy function. Although the run-time behaviour of\n-// dynamic_cast is simple to describe, it gives rise to some non-obvious\n-// behaviour. We also desire to determine as early as possible any definite\n-// answer we can get. Because it is unknown what the run-time ratio of\n-// succeeding to failing dynamic casts is, we do not know in which direction\n-// to bias any optimizations. To that end we make no particular effort towards\n-// early fail answers or early success answers. Instead we try to minimize\n-// work by filling in things lazily (when we know we need the information),\n-// and opportunisticly take early success or failure results.\n-bool __class_type_info::\n-do_dyncast (int boff, sub_kind access_path,\n-            const type_info &target, void *objptr,\n-            const type_info &subtype, void *subptr,\n-            dyncast_result &__restrict result) const\n-{\n-  if (objptr == subptr && *this == subtype)\n-    {\n-      // The subobject we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2sub = access_path;\n-      return false;\n-    }\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.whole2target = access_path;\n-      if (boff >= 0)\n-        result.target2sub = ((char *)subptr - (char *)objptr) == boff\n-              ? contained_public : not_contained;\n-      else if (boff == -2)\n-        result.target2sub = not_contained;\n-      return false;\n-    }\n-  bool result_ambig = false;\n-  for (size_t i = n_bases; i--;)\n-    {\n-      dyncast_result result2;\n-      void *p;\n-      sub_kind sub_access = access_path;\n-      p = convert_to_base (objptr, \n-\t\t\t   base_list[i].is_virtual,\n-\t\t\t   base_list[i].offset);\n-      if (base_list[i].is_virtual)\n-\tsub_access = sub_kind (sub_access | contained_virtual_mask);\n-      if (base_list[i].access != PUBLIC)\n-        sub_access = sub_kind (sub_access & ~contained_public_mask);\n-      \n-      bool result2_ambig\n-          = base_list[i].base->do_dyncast (boff, sub_access,\n-                                           target, p, subtype, subptr, result2);\n-      result.whole2sub = sub_kind (result.whole2sub | result2.whole2sub);\n-      if (result2.target2sub == contained_public\n-          || result2.target2sub == contained_ambig)\n-        {\n-          result.target_obj = result2.target_obj;\n-          result.whole2target = result2.whole2target;\n-          result.target2sub = result2.target2sub;\n-          // Found a downcast which can't be bettered or an ambiguous downcast\n-          // which can't be disambiguated\n-          return result2_ambig;\n-        }\n-      \n-      if (!result_ambig && !result.target_obj)\n-        {\n-          // Not found anything yet.\n-          result.target_obj = result2.target_obj;\n-          result.whole2target = result2.whole2target;\n-          result_ambig = result2_ambig;\n-        }\n-      else if (result.target_obj && result.target_obj == result2.target_obj)\n-        {\n-          // Found at same address, must be via virtual.  Pick the most\n-          // accessible path.\n-          result.whole2target =\n-              sub_kind (result.whole2target | result2.whole2target);\n-        }\n-      else if ((result.target_obj && result2.target_obj)\n-               || (result_ambig && result2.target_obj)\n-               || (result2_ambig && result.target_obj))\n-        {\n-          // Found two different TARGET bases, or a valid one and a set of\n-          // ambiguous ones, must disambiguate. See whether SUBOBJ is\n-          // contained publicly within one of the non-ambiguous choices.\n-          // If it is in only one, then that's the choice. If it is in\n-          // both, then we're ambiguous and fail. If it is in neither,\n-          // we're ambiguous, but don't yet fail as we might later find a\n-          // third base which does contain SUBPTR.\n-        \n-          sub_kind new_sub_kind = result2.target2sub;\n-          sub_kind old_sub_kind = result.target2sub;\n-          \n-          if (contained_nonvirtual_p (result.whole2sub))\n-            {\n-              // We already found SUBOBJ as a non-virtual base of most\n-              // derived. Therefore if it is in either choice, it can only be\n-              // in one of them, and we will already know.\n-              if (old_sub_kind == unknown)\n-                old_sub_kind = not_contained;\n-              if (new_sub_kind == unknown)\n-                new_sub_kind = not_contained;\n-            }\n-          else\n-            {\n-              const __user_type_info &t =\n-                  static_cast <const __user_type_info &> (target);\n-              \n-              if (old_sub_kind >= not_contained)\n-                ;// already calculated\n-              else if (contained_nonvirtual_p (new_sub_kind))\n-                // Already found non-virtually inside the other choice,\n-                // cannot be in this.\n-                old_sub_kind = not_contained;\n-              else\n-                old_sub_kind = t.find_public_subobj (boff, subtype,\n-                                                     result.target_obj, subptr);\n-          \n-              if (new_sub_kind >= not_contained)\n-                ;// already calculated\n-              else if (contained_nonvirtual_p (old_sub_kind))\n-                // Already found non-virtually inside the other choice,\n-                // cannot be in this.\n-                new_sub_kind = not_contained;\n-              else\n-                new_sub_kind = t.find_public_subobj (boff, subtype,\n-                                                     result2.target_obj, subptr);\n-            }\n-          \n-          // Neither sub_kind can be contained_ambig -- we bail out early\n-          // when we find those.\n-          if (contained_p (sub_kind (new_sub_kind ^ old_sub_kind)))\n-            {\n-              // Only on one choice, not ambiguous.\n-              if (contained_p (new_sub_kind))\n-                {\n-                  // Only in new.\n-                  result.target_obj = result2.target_obj;\n-                  result.whole2target = result2.whole2target;\n-                  result_ambig = false;\n-                  old_sub_kind = new_sub_kind;\n-                }\n-              result.target2sub = old_sub_kind;\n-              if (result.target2sub == contained_public)\n-                return false; // Can't be an ambiguating downcast for later discovery.\n-            }\n-          else if (contained_p (sub_kind (new_sub_kind & old_sub_kind)))\n-            {\n-              // In both.\n-              result.target_obj = NULL;\n-              result.target2sub = contained_ambig;\n-              return true;  // Fail.\n-            }\n-          else\n-            {\n-              // In neither publicly, ambiguous for the moment, but keep\n-              // looking. It is possible that it was private in one or\n-              // both and therefore we should fail, but that's just tough.\n-              result.target_obj = NULL;\n-              result.target2sub = not_contained;\n-              result_ambig = true;\n-            }\n-        }\n-      \n-      if (result.whole2sub == contained_private)\n-        // We found SUBOBJ as a private non-virtual base, therefore all\n-        // cross casts will fail. We have already found a down cast, if\n-        // there is one.\n-        return result_ambig;\n-    }\n-\n-  return result_ambig;\n-}\n-\n-// find_public_subobj helper for non-public or multiple inheritance types. See\n-// __user_type_info::do_find_public_subobj for semantics. We make use of BOFF\n-// to prune the base class walk.\n-__user_type_info::sub_kind __class_type_info::\n-do_find_public_subobj (int boff, const type_info &subtype, void *objptr, void *subptr) const\n-{\n-  if (objptr == subptr && subtype == *this)\n-    return contained_public;\n-  \n-  for (size_t i = n_bases; i--;)\n-    {\n-      if (base_list[i].access != PUBLIC)\n-        continue; // Not public, can't be here.\n-      void *p;\n-\n-      if (base_list[i].is_virtual && boff == -3)\n-\t// Not a virtual base, so can't be here.\n-\tcontinue;\n-      \n-      p = convert_to_base (objptr, \n-\t\t\t   base_list[i].is_virtual,\n-\t\t\t   base_list[i].offset);\n-\n-      sub_kind base_kind = base_list[i].base->do_find_public_subobj\n-                              (boff, subtype, p, subptr);\n-      if (contained_p (base_kind))\n-        {\n-          if (base_list[i].is_virtual)\n-            base_kind = sub_kind (base_kind | contained_virtual_mask);\n-          return base_kind;\n-        }\n-    }\n-  \n-  return not_contained;\n-}\n-#else\n-// new abi\n-\n-namespace std {\n-\n-// return true if this is a type_info for a pointer type\n-bool type_info::\n-__is_pointer_p () const\n-{\n-  return false;\n-}\n-\n-// return true if this is a type_info for a function type\n-bool type_info::\n-__is_function_p () const\n-{\n-  return false;\n-}\n-\n-// try and catch a thrown object.\n-bool type_info::\n-__do_catch (const type_info *thr_type, void **, unsigned) const\n-{\n-  return *this == *thr_type;\n-}\n-\n-// upcast from this type to the target. __class_type_info will override\n-bool type_info::\n-__do_upcast (const abi::__class_type_info *, void **) const\n-{\n-  return false;\n-}\n-\n-};\n-\n-namespace {\n-\n-using namespace std;\n-using namespace abi;\n-\n-// initial part of a vtable, this structure is used with offsetof, so we don't\n-// have to keep alignments consistent manually.\n-struct vtable_prefix {\n-  ptrdiff_t whole_object;           // offset to most derived object\n-  const __class_type_info *whole_type;  // pointer to most derived type_info\n-  const void *origin;               // what a class's vptr points to\n-};\n-\n-template <typename T>\n-inline const T *\n-adjust_pointer (const void *base, ptrdiff_t offset)\n-{\n-  return reinterpret_cast <const T *>\n-    (reinterpret_cast <const char *> (base) + offset);\n-}\n-\n-// ADDR is a pointer to an object.  Convert it to a pointer to a base,\n-// using OFFSET. IS_VIRTUAL is true, if we are getting a virtual base.\n-inline void const *\n-convert_to_base (void const *addr, bool is_virtual, ptrdiff_t offset)\n-{\n-  if (is_virtual)\n-    {\n-      const void *vtable = *static_cast <const void *const *> (addr);\n-      \n-      offset = *adjust_pointer<ptrdiff_t> (vtable, offset);\n-    }\n-\n-  return adjust_pointer<void> (addr, offset);\n-}\n-\n-// some predicate functions for __class_type_info::__sub_kind\n-inline bool contained_p (__class_type_info::__sub_kind access_path)\n-{\n-  return access_path >= __class_type_info::__contained_mask;\n-}\n-inline bool public_p (__class_type_info::__sub_kind access_path)\n-{\n-  return access_path & __class_type_info::__contained_public_mask;\n-}\n-inline bool virtual_p (__class_type_info::__sub_kind access_path)\n-{\n-  return (access_path & __class_type_info::__contained_virtual_mask);\n-}\n-inline bool contained_public_p (__class_type_info::__sub_kind access_path)\n-{\n-  return ((access_path & __class_type_info::__contained_public)\n-          == __class_type_info::__contained_public);\n-}\n-inline bool contained_nonpublic_p (__class_type_info::__sub_kind access_path)\n-{\n-  return ((access_path & __class_type_info::__contained_public)\n-          == __class_type_info::__contained_mask);\n-}\n-inline bool contained_nonvirtual_p (__class_type_info::__sub_kind access_path)\n-{\n-  return ((access_path & (__class_type_info::__contained_mask\n-                          | __class_type_info::__contained_virtual_mask))\n-          == __class_type_info::__contained_mask);\n-}\n-\n-static const __class_type_info *const nonvirtual_base_type =\n-    static_cast <const __class_type_info *> (0) + 1;\n-\n-}; // namespace\n-\n-namespace __cxxabiv1\n-{\n-\n-__class_type_info::\n-~__class_type_info ()\n-{}\n-\n-__si_class_type_info::\n-~__si_class_type_info ()\n-{}\n-\n-__vmi_class_type_info::\n-~__vmi_class_type_info ()\n-{}\n-\n-// __upcast_result is used to hold information during traversal of a class\n-// heirarchy when catch matching.\n-struct __class_type_info::__upcast_result\n-{\n-  const void *dst_ptr;        // pointer to caught object\n-  __sub_kind part2dst;        // path from current base to target\n-  int src_details;            // hints about the source type heirarchy\n-  const __class_type_info *base_type; // where we found the target,\n-                              // if in vbase the __class_type_info of vbase\n-                              // if a non-virtual base then 1\n-                              // else NULL\n-  public:\n-  __upcast_result (int d)\n-    :dst_ptr (NULL), part2dst (__unknown), src_details (d), base_type (NULL)\n-    {}\n-};\n-\n-// __dyncast_result is used to hold information during traversal of a class\n-// heirarchy when dynamic casting.\n-struct __class_type_info::__dyncast_result\n-{\n-  const void *dst_ptr;        // pointer to target object or NULL\n-  __sub_kind whole2dst;       // path from most derived object to target\n-  __sub_kind whole2src;       // path from most derived object to sub object\n-  __sub_kind dst2src;         // path from target to sub object\n-  int whole_details;          // details of the whole class heirarchy\n-  \n-  public:\n-  __dyncast_result (int details_ = __vmi_class_type_info::__flags_unknown_mask)\n-    :dst_ptr (NULL), whole2dst (__unknown),\n-     whole2src (__unknown), dst2src (__unknown),\n-     whole_details (details_)\n-    {}\n-};\n-\n-bool __class_type_info::\n-__do_catch (const type_info *thr_type,\n-            void **thr_obj,\n-            unsigned outer) const\n-{\n-  if (*this == *thr_type)\n-    return true;\n-  if (outer >= 4)\n-    // Neither `A' nor `A *'.\n-    return false;\n-  return thr_type->__do_upcast (this, thr_obj);\n-}\n-\n-bool __class_type_info::\n-__do_upcast (const __class_type_info *dst_type,\n-             void **obj_ptr) const\n-{\n-  __upcast_result result (__vmi_class_type_info::__flags_unknown_mask);\n-  \n-  __do_upcast (dst_type, *obj_ptr, result);\n-  if (!contained_public_p (result.part2dst))\n-    return false;\n-  *obj_ptr = const_cast <void *> (result.dst_ptr);\n-  return true;\n-}\n-\n-inline __class_type_info::__sub_kind __class_type_info::\n-__find_public_src (ptrdiff_t src2dst,\n-                   const void *obj_ptr,\n-                   const __class_type_info *src_type,\n-                   const void *src_ptr) const\n-{\n-  if (src2dst >= 0)\n-    return adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n-            ? __contained_public : __not_contained;\n-  if (src2dst == -2)\n-    return __not_contained;\n-  return __do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n-}\n-\n-__class_type_info::__sub_kind __class_type_info::\n-__do_find_public_src (ptrdiff_t,\n-                      const void *obj_ptr,\n-                      const __class_type_info *,\n-                      const void *src_ptr) const\n-{\n-  if (src_ptr == obj_ptr)\n-    // Must be our type, as the pointers match.\n-    return __contained_public;\n-  return __not_contained;\n-}\n-\n-__class_type_info::__sub_kind __si_class_type_info::\n-__do_find_public_src (ptrdiff_t src2dst,\n-                      const void *obj_ptr,\n-                      const __class_type_info *src_type,\n-                      const void *src_ptr) const\n-{\n-  if (src_ptr == obj_ptr && *this == *src_type)\n-    return __contained_public;\n-  return __base_type->__do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n-}\n-\n-__class_type_info::__sub_kind __vmi_class_type_info::\n-__do_find_public_src (ptrdiff_t src2dst,\n-                      const void *obj_ptr,\n-                      const __class_type_info *src_type,\n-                      const void *src_ptr) const\n-{\n-  if (obj_ptr == src_ptr && *this == *src_type)\n-    return __contained_public;\n-  \n-  for (size_t i = __base_count; i--;)\n-    {\n-      if (!__base_info[i].__is_public_p ())\n-        continue; // Not public, can't be here.\n-      \n-      const void *base = obj_ptr;\n-      ptrdiff_t offset = __base_info[i].__offset ();\n-      bool is_virtual = __base_info[i].__is_virtual_p ();\n-      \n-      if (is_virtual)\n-        {\n-          if (src2dst == -3)\n-            continue; // Not a virtual base, so can't be here.\n-        }\n-      base = convert_to_base (base, is_virtual, offset);\n-      \n-      __sub_kind base_kind = __base_info[i].__base->__do_find_public_src\n-                              (src2dst, base, src_type, src_ptr);\n-      if (contained_p (base_kind))\n-        {\n-          if (is_virtual)\n-            base_kind = __sub_kind (base_kind | __contained_virtual_mask);\n-          return base_kind;\n-        }\n-    }\n-  \n-  return __not_contained;\n-}\n-\n-bool __class_type_info::\n-__do_dyncast (ptrdiff_t,\n-              __sub_kind access_path,\n-              const __class_type_info *dst_type,\n-              const void *obj_ptr,\n-              const __class_type_info *src_type,\n-              const void *src_ptr,\n-              __dyncast_result &__restrict result) const\n-{\n-  if (obj_ptr == src_ptr && *this == *src_type)\n-    {\n-      // The src object we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2src = access_path;\n-      return false;\n-    }\n-  if (*this == *dst_type)\n-    {\n-      result.dst_ptr = obj_ptr;\n-      result.whole2dst = access_path;\n-      result.dst2src = __not_contained;\n-      return false;\n-    }\n-  return false;\n-}\n-\n-bool __si_class_type_info::\n-__do_dyncast (ptrdiff_t src2dst,\n-              __sub_kind access_path,\n-              const __class_type_info *dst_type,\n-              const void *obj_ptr,\n-              const __class_type_info *src_type,\n-              const void *src_ptr,\n-              __dyncast_result &__restrict result) const\n-{\n-  if (*this == *dst_type)\n-    {\n-      result.dst_ptr = obj_ptr;\n-      result.whole2dst = access_path;\n-      if (src2dst >= 0)\n-        result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n-              ? __contained_public : __not_contained;\n-      else if (src2dst == -2)\n-        result.dst2src = __not_contained;\n-      return false;\n-    }\n-  if (obj_ptr == src_ptr && *this == *src_type)\n-    {\n-      // The src object we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2src = access_path;\n-      return false;\n-    }\n-  return __base_type->__do_dyncast (src2dst, access_path, dst_type, obj_ptr,\n-                             src_type, src_ptr, result);\n-}\n-\n-// This is a big hairy function. Although the run-time behaviour of\n-// dynamic_cast is simple to describe, it gives rise to some non-obvious\n-// behaviour. We also desire to determine as early as possible any definite\n-// answer we can get. Because it is unknown what the run-time ratio of\n-// succeeding to failing dynamic casts is, we do not know in which direction\n-// to bias any optimizations. To that end we make no particular effort towards\n-// early fail answers or early success answers. Instead we try to minimize\n-// work by filling in things lazily (when we know we need the information),\n-// and opportunisticly take early success or failure results.\n-bool __vmi_class_type_info::\n-__do_dyncast (ptrdiff_t src2dst,\n-              __sub_kind access_path,\n-              const __class_type_info *dst_type,\n-              const void *obj_ptr,\n-              const __class_type_info *src_type,\n-              const void *src_ptr,\n-              __dyncast_result &__restrict result) const\n-{\n-  if (result.whole_details & __flags_unknown_mask)\n-    result.whole_details = __flags;\n-  \n-  if (obj_ptr == src_ptr && *this == *src_type)\n-    {\n-      // The src object we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2src = access_path;\n-      return false;\n-    }\n-  if (*this == *dst_type)\n-    {\n-      result.dst_ptr = obj_ptr;\n-      result.whole2dst = access_path;\n-      if (src2dst >= 0)\n-        result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n-              ? __contained_public : __not_contained;\n-      else if (src2dst == -2)\n-        result.dst2src = __not_contained;\n-      return false;\n-    }\n-\n-  bool result_ambig = false;\n-  for (size_t i = __base_count; i--;)\n-    {\n-      __dyncast_result result2 (result.whole_details);\n-      void const *base = obj_ptr;\n-      __sub_kind base_access = access_path;\n-      ptrdiff_t offset = __base_info[i].__offset ();\n-      bool is_virtual = __base_info[i].__is_virtual_p ();\n-      \n-      if (is_virtual)\n-        base_access = __sub_kind (base_access | __contained_virtual_mask);\n-      base = convert_to_base (base, is_virtual, offset);\n-\n-      if (!__base_info[i].__is_public_p ())\n-        {\n-          if (src2dst == -2 &&\n-              !(result.whole_details\n-                & (__non_diamond_repeat_mask | __diamond_shaped_mask)))\n-            // The hierarchy has no duplicate bases (which might ambiguate\n-            // things) and where we started is not a public base of what we\n-            // want (so it cannot be a downcast). There is nothing of interest\n-            // hiding in a non-public base.\n-            continue;\n-          base_access = __sub_kind (base_access & ~__contained_public_mask);\n-        }\n-      \n-      bool result2_ambig\n-          = __base_info[i].__base->__do_dyncast (src2dst, base_access,\n-                                             dst_type, base,\n-                                             src_type, src_ptr, result2);\n-      result.whole2src = __sub_kind (result.whole2src | result2.whole2src);\n-      if (result2.dst2src == __contained_public\n-          || result2.dst2src == __contained_ambig)\n-        {\n-          result.dst_ptr = result2.dst_ptr;\n-          result.whole2dst = result2.whole2dst;\n-          result.dst2src = result2.dst2src;\n-          // Found a downcast which can't be bettered or an ambiguous downcast\n-          // which can't be disambiguated\n-          return result2_ambig;\n-        }\n-      \n-      if (!result_ambig && !result.dst_ptr)\n-        {\n-          // Not found anything yet.\n-          result.dst_ptr = result2.dst_ptr;\n-          result.whole2dst = result2.whole2dst;\n-          result_ambig = result2_ambig;\n-          if (result.dst_ptr && result.whole2src != __unknown\n-              && !(__flags & __non_diamond_repeat_mask))\n-            // Found dst and src and we don't have repeated bases.\n-            return result_ambig;\n-        }\n-      else if (result.dst_ptr && result.dst_ptr == result2.dst_ptr)\n-        {\n-          // Found at same address, must be via virtual.  Pick the most\n-          // accessible path.\n-          result.whole2dst =\n-              __sub_kind (result.whole2dst | result2.whole2dst);\n-        }\n-      else if ((result.dst_ptr != 0 | result_ambig)\n-               && (result2.dst_ptr != 0 | result2_ambig))\n-        {\n-          // Found two different DST_TYPE bases, or a valid one and a set of\n-          // ambiguous ones, must disambiguate. See whether SRC_PTR is\n-          // contained publicly within one of the non-ambiguous choices. If it\n-          // is in only one, then that's the choice. If it is in both, then\n-          // we're ambiguous and fail. If it is in neither, we're ambiguous,\n-          // but don't yet fail as we might later find a third base which does\n-          // contain SRC_PTR.\n-        \n-          __sub_kind new_sub_kind = result2.dst2src;\n-          __sub_kind old_sub_kind = result.dst2src;\n-          \n-          if (contained_p (result.whole2src)\n-              && (!virtual_p (result.whole2src)\n-                  || !(result.whole_details & __diamond_shaped_mask)))\n-            {\n-              // We already found SRC_PTR as a base of most derived, and\n-              // either it was non-virtual, or the whole heirarchy is\n-              // not-diamond shaped. Therefore if it is in either choice, it\n-              // can only be in one of them, and we will already know.\n-              if (old_sub_kind == __unknown)\n-                old_sub_kind = __not_contained;\n-              if (new_sub_kind == __unknown)\n-                new_sub_kind = __not_contained;\n-            }\n-          else\n-            {\n-              if (old_sub_kind >= __not_contained)\n-                ;// already calculated\n-              else if (contained_p (new_sub_kind)\n-                       && (!virtual_p (new_sub_kind)\n-                           || !(__flags & __diamond_shaped_mask)))\n-                // Already found inside the other choice, and it was\n-                // non-virtual or we are not diamond shaped.\n-                old_sub_kind = __not_contained;\n-              else\n-                old_sub_kind = dst_type->__find_public_src\n-                                (src2dst, result.dst_ptr, src_type, src_ptr);\n-          \n-              if (new_sub_kind >= __not_contained)\n-                ;// already calculated\n-              else if (contained_p (old_sub_kind)\n-                       && (!virtual_p (old_sub_kind)\n-                           || !(__flags & __diamond_shaped_mask)))\n-                // Already found inside the other choice, and it was\n-                // non-virtual or we are not diamond shaped.\n-                new_sub_kind = __not_contained;\n-              else\n-                new_sub_kind = dst_type->__find_public_src\n-                                (src2dst, result2.dst_ptr, src_type, src_ptr);\n-            }\n-          \n-          // Neither sub_kind can be contained_ambig -- we bail out early\n-          // when we find those.\n-          if (contained_p (__sub_kind (new_sub_kind ^ old_sub_kind)))\n-            {\n-              // Only on one choice, not ambiguous.\n-              if (contained_p (new_sub_kind))\n-                {\n-                  // Only in new.\n-                  result.dst_ptr = result2.dst_ptr;\n-                  result.whole2dst = result2.whole2dst;\n-                  result_ambig = false;\n-                  old_sub_kind = new_sub_kind;\n-                }\n-              result.dst2src = old_sub_kind;\n-              if (public_p (result.dst2src))\n-                return false; // Can't be an ambiguating downcast for later discovery.\n-              if (!virtual_p (result.dst2src))\n-                return false; // Found non-virtually can't be bettered\n-            }\n-          else if (contained_p (__sub_kind (new_sub_kind & old_sub_kind)))\n-            {\n-              // In both.\n-              result.dst_ptr = NULL;\n-              result.dst2src = __contained_ambig;\n-              return true;  // Fail.\n-            }\n-          else\n-            {\n-              // In neither publicly, ambiguous for the moment, but keep\n-              // looking. It is possible that it was private in one or\n-              // both and therefore we should fail, but that's just tough.\n-              result.dst_ptr = NULL;\n-              result.dst2src = __not_contained;\n-              result_ambig = true;\n-            }\n-        }\n-      \n-      if (result.whole2src == __contained_private)\n-        // We found SRC_PTR as a private non-virtual base, therefore all\n-        // cross casts will fail. We have already found a down cast, if\n-        // there is one.\n-        return result_ambig;\n-    }\n-\n-  return result_ambig;\n-}\n-\n-bool __class_type_info::\n-__do_upcast (const __class_type_info *dst, const void *obj,\n-             __upcast_result &__restrict result) const\n-{\n-  if (*this == *dst)\n-    {\n-      result.dst_ptr = obj;\n-      result.base_type = nonvirtual_base_type;\n-      result.part2dst = __contained_public;\n-      return true;\n-    }\n-  return false;\n-}\n-\n-bool __si_class_type_info::\n-__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n-             __upcast_result &__restrict result) const\n-{\n-  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n-    return true;\n-  \n-  return __base_type->__do_upcast (dst, obj_ptr, result);\n-}\n-\n-bool __vmi_class_type_info::\n-__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n-             __upcast_result &__restrict result) const\n-{\n-  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n-    return true;\n-  \n-  int src_details = result.src_details;\n-  if (src_details & __flags_unknown_mask)\n-    src_details = __flags;\n-  \n-  for (size_t i = __base_count; i--;)\n-    {\n-      __upcast_result result2 (src_details);\n-      const void *base = obj_ptr;\n-      ptrdiff_t offset = __base_info[i].__offset ();\n-      bool is_virtual = __base_info[i].__is_virtual_p ();\n-      bool is_public = __base_info[i].__is_public_p ();\n-      \n-      if (!is_public && !(src_details & __non_diamond_repeat_mask))\n-        // original cannot have an ambiguous base, so skip private bases\n-        continue;\n-\n-      if (base)\n-        base = convert_to_base (base, is_virtual, offset);\n-      \n-      if (__base_info[i].__base->__do_upcast (dst, base, result2))\n-        {\n-          if (result2.base_type == nonvirtual_base_type && is_virtual)\n-            result2.base_type = __base_info[i].__base;\n-          if (contained_p (result2.part2dst) && !is_public)\n-            result2.part2dst = __sub_kind (result2.part2dst & ~__contained_public_mask);\n-          \n-          if (!result.base_type)\n-            {\n-              result = result2;\n-              if (!contained_p (result.part2dst))\n-                return true; // found ambiguously\n-              \n-              if (result.part2dst & __contained_public_mask)\n-                {\n-                  if (!(__flags & __non_diamond_repeat_mask))\n-                    return true;  // cannot have an ambiguous other base\n-                }\n-              else\n-                {\n-                  if (!virtual_p (result.part2dst))\n-                    return true; // cannot have another path\n-                  if (!(__flags & __diamond_shaped_mask))\n-                    return true; // cannot have a more accessible path\n-                }\n-            }\n-          else if (result.dst_ptr != result2.dst_ptr)\n-            {\n-              // Found an ambiguity.\n-\t      result.dst_ptr = NULL;\n-\t      result.part2dst = __contained_ambig;\n-\t      return true;\n-            }\n-          else if (result.dst_ptr)\n-            {\n-              // Ok, found real object via a virtual path.\n-              result.part2dst\n-                  = __sub_kind (result.part2dst | result2.part2dst);\n-            }\n-          else\n-            {\n-              // Dealing with a null pointer, need to check vbase\n-              // containing each of the two choices.\n-              if (result2.base_type == nonvirtual_base_type\n-                  || result.base_type == nonvirtual_base_type\n-                  || !(*result2.base_type == *result.base_type))\n-                {\n-                  // Already ambiguous, not virtual or via different virtuals.\n-                  // Cannot match.\n-                  result.part2dst = __contained_ambig;\n-                  return true;\n-                }\n-              result.part2dst\n-                  = __sub_kind (result.part2dst | result2.part2dst);\n-            }\n-        }\n-    }\n-  return result.part2dst != __unknown;\n-}\n-\n-// this is the external interface to the dynamic cast machinery\n-extern \"C\" void *\n-__dynamic_cast (const void *src_ptr,    // object started from\n-                const __class_type_info *src_type, // type of the starting object\n-                const __class_type_info *dst_type, // desired target type\n-                ptrdiff_t src2dst) // how src and dst are related\n-{\n-  const void *vtable = *static_cast <const void *const *> (src_ptr);\n-  const vtable_prefix *prefix =\n-      adjust_pointer <vtable_prefix> (vtable, \n-\t\t\t\t      -offsetof (vtable_prefix, origin));\n-  const void *whole_ptr =\n-      adjust_pointer <void> (src_ptr, prefix->whole_object);\n-  const __class_type_info *whole_type = prefix->whole_type;\n-  __class_type_info::__dyncast_result result;\n-  \n-  whole_type->__do_dyncast (src2dst, __class_type_info::__contained_public,\n-                            dst_type, whole_ptr, src_type, src_ptr, result);\n-  if (!result.dst_ptr)\n-    return NULL;\n-  if (contained_public_p (result.dst2src))\n-    // Src is known to be a public base of dst.\n-    return const_cast <void *> (result.dst_ptr);\n-  if (contained_public_p (__class_type_info::__sub_kind (result.whole2src & result.whole2dst)))\n-    // Both src and dst are known to be public bases of whole. Found a valid\n-    // cross cast.\n-    return const_cast <void *> (result.dst_ptr);\n-  if (contained_nonvirtual_p (result.whole2src))\n-    // Src is known to be a non-public nonvirtual base of whole, and not a\n-    // base of dst. Found an invalid cross cast, which cannot also be a down\n-    // cast\n-    return NULL;\n-  if (result.dst2src == __class_type_info::__unknown)\n-    result.dst2src = dst_type->__find_public_src (src2dst, result.dst_ptr,\n-                                                  src_type, src_ptr);\n-  if (contained_public_p (result.dst2src))\n-    // Found a valid down cast\n-    return const_cast <void *> (result.dst_ptr);\n-  // Must be an invalid down cast, or the cross cast wasn't bettered\n-  return NULL;\n-}\n-\n-}; // namespace __cxxabiv1\n-#endif"}, {"sha": "b52f681a3a8b4add5fdaa1e7290fac6613f0d9ab", "filename": "gcc/cp/tinfo.h", "status": "removed", "additions": 0, "deletions": 220, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Ftinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Ftinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.h?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,220 +0,0 @@\n-// RTTI support internals for -*- C++ -*-\n-// Copyright (C) 1994, 1995, 1996, 1998, 1999, 2000 Free Software Foundation\n-\n-#include \"typeinfo\"\n-\n-// Class declarations shared between the typeinfo implementation files.\n-\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-// original (old) abi\n-\n-// type_info for a class with no base classes (or an enum).\n-\n-struct __user_type_info : public std::type_info {\n-  __user_type_info (const char *n) : type_info (n) {}\n-\n-  // If our type can be upcast to a public and unambiguous base, then return\n-  // non-zero and set RES to point to the base object. OBJ points to the throw\n-  // object and can be NULL, if there is no object to adjust.\n-  int upcast (const type_info &target, void *obj, void **res) const;\n-  \n-  // If our type can be dynamicly cast to the target type, then return\n-  // pointer to the target object. OBJ is the pointer to the most derived\n-  // type and cannot be NULL. SUBTYPE and SUBOBJ indicate the static type\n-  // base object from whence we came, it cannot be NULL. SUBTYPE cannot be\n-  // the same as TARGET. TARGET cannot be a base of SUBTYPE.\n-  // BOFF indicates how SUBTYPE is related to TARGET.\n-  // BOFF >= 0, there is only one public non-virtual SUBTYPE base at offset\n-  //    BOFF, and there are no public virtual SUBTYPE bases.\n-  //    Therefore check if SUBOBJ is at offset BOFF when we find a target\n-  // BOFF == -1, SUBTYPE occurs as multiple public virtual or non-virtual bases.\n-  //    Lazily search all the bases of TARGET.\n-  // BOFF == -2, SUBTYPE is not a public base.\n-  // BOFF == -3, SUBTYPE occurs as multiple public non-virtual bases.\n-  //    Lazily search the non-virtual bases of TARGET.\n-  // For backwards compatibility set BOFF to -1, that is the safe \"unknown\"\n-  // value. We do not care about SUBTYPES as private bases of TARGET, as they\n-  // can never succeed as downcasts, only as crosscasts -- and then only if\n-  // they are virtual. This is more complicated that it might seem.\n-  void *dyncast (int boff,\n-                 const type_info &target, void *obj,\n-                 const type_info &subtype, void *subobj) const;\n-  \n-  // non_virtual_base_type is used to indicate that a base class is via a\n-  // non-virtual access path.\n-  static const type_info *const nonvirtual_base_type\n-      = static_cast <const type_info *> (0) + 1;\n-  \n-  // sub_kind tells us about how a base object is contained within a derived\n-  // object. We often do this lazily, hence the UNKNOWN value. At other times\n-  // we may use NOT_CONTAINED to mean not publicly contained.\n-  enum sub_kind\n-  {\n-    unknown = 0,              // we have no idea\n-    not_contained,            // not contained within us (in some\n-                              // circumstances this might mean not contained\n-                              // publicly)\n-    contained_ambig,          // contained ambiguously\n-    contained_mask = 4,       // contained within us\n-    contained_virtual_mask = 1, // via a virtual path\n-    contained_public_mask = 2,  // via a public path\n-    contained_private = contained_mask,\n-    contained_public = contained_mask | contained_public_mask\n-  };\n-  // some predicate functions for sub_kind\n-  static inline bool contained_p (sub_kind access_path)\n-  {\n-    return access_path >= contained_mask;\n-  }\n-  static inline bool contained_public_p (sub_kind access_path)\n-  {\n-    return access_path >= contained_public;\n-  }\n-  static inline bool contained_nonpublic_p (sub_kind access_path)\n-  {\n-    return (access_path & contained_public) == contained_mask;\n-  }\n-  static inline bool contained_nonvirtual_p (sub_kind access_path)\n-  {\n-    return (access_path & (contained_mask | contained_virtual_mask))\n-           == contained_mask;\n-  }\n-  static inline bool contained_virtual_p (sub_kind access_path)\n-  {\n-    return (access_path & (contained_mask | contained_virtual_mask))\n-           == (contained_mask | contained_virtual_mask);\n-  }\n-  \n-  struct upcast_result\n-  {\n-    void *target_obj;   // pointer to target object or NULL (init NULL)\n-    sub_kind whole2target;      // path from most derived object to target\n-    const type_info *base_type; // where we found the target, (init NULL)\n-                                // if in vbase the __user_type_info of vbase)\n-                                // if a non-virtual base then 1\n-                                // else NULL\n-    public:\n-    upcast_result ()\n-      :target_obj (NULL), whole2target (unknown), base_type (NULL)\n-      {}\n-  };\n-  struct dyncast_result\n-  {\n-    void *target_obj;   // pointer to target object or NULL (init NULL)\n-    sub_kind whole2target;      // path from most derived object to target\n-    sub_kind whole2sub;         // path from most derived object to sub object\n-    sub_kind target2sub;        // path from target to sub object\n-    \n-    public:\n-    dyncast_result ()\n-      :target_obj (NULL), whole2target (unknown),\n-       whole2sub (unknown), target2sub (unknown)\n-      {}\n-  };\n-  \n-  public:\n-  // Helper for upcast. See if TARGET is us, or one of our bases. ACCESS_PATH\n-  // gives the access from the start object. Return TRUE if we know the catch\n-  // fails.\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const type_info &target, void *obj,\n-                          upcast_result &__restrict result) const;\n-  // Helper for dyncast. BOFF indicates how the SUBTYPE is related to TARGET.\n-  // ACCESS_PATH indicates the access from the most derived object.  It is\n-  // used to prune the DAG walk. All information about what we find is put\n-  // into RESULT. Return true, if the match we have found is ambiguous.\n-  virtual bool do_dyncast (int boff, sub_kind access_path,\n-                           const type_info &target, void *obj,\n-                           const type_info &subtype, void *subptr,\n-                           dyncast_result &__restrict result) const;\n-  public:\n-  // Indicate whether SUBPTR of type SUBTYPE is contained publicly within\n-  // OBJPTR. OBJPTR points to this base object. BOFF indicates how SUBTYPE\n-  // objects might be contained within this type.  If SUBPTR is one of our\n-  // SUBTYPE bases, indicate virtuality. Returns not_contained for non\n-  // containment or private containment.\n-  sub_kind find_public_subobj (int boff, const type_info &subtype,\n-                               void *objptr, void *subptr) const\n-  {\n-    if (boff >= 0)\n-      return ((char *)subptr - (char *)objptr) == boff\n-              ? contained_public : not_contained;\n-    if (boff == -2)\n-      return not_contained;\n-    return do_find_public_subobj (boff, subtype, objptr, subptr);\n-  }\n-  \n-  public:\n-  // Helper for find_subobj. BOFF indicates how SUBTYPE bases are inherited by\n-  // the type started from -- which is not necessarily the current type.\n-  // OBJPTR points to the current base.\n-  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,\n-                                          void *objptr, void *subptr) const;\n-};\n-\n-// type_info for a class with one public, nonvirtual base class.\n-\n-class __si_type_info : public __user_type_info {\n-  const __user_type_info &base;\n-\n-public:\n-  __si_type_info (const char *n, const __user_type_info &b)\n-    : __user_type_info (n), base (b) { }\n-\n-  private:\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const type_info &target, void *obj,\n-                          upcast_result &__restrict result) const;\n-  virtual bool do_dyncast (int boff, sub_kind access_path,\n-                           const type_info &target, void *obj,\n-                           const type_info &subtype, void *subptr,\n-                           dyncast_result &__restrict result) const;\n-  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,\n-                                          void *objptr, void *subptr) const;\n-};\n-\n-// type_info for a general class.\n-\n-// Kludge, kludge, kludge.\n-#include \"tconfig.h\"\n-\n-#if BITS_PER_UNIT == 8\n-typedef int myint32 __attribute__ ((mode (SI)));\n-#elif BITS_PER_UNIT == 16\n-typedef int myint32 __attribute__ ((mode (HI)));\n-#elif BITS_PER_UNIT == 32\n-typedef int myint32 __attribute__ ((mode (QI)));\n-#endif\n-\n-struct __class_type_info : public __user_type_info {\n-  enum access { PUBLIC = 1, PROTECTED = 2, PRIVATE = 3 };\n-\n-  struct base_info {\n-    const __user_type_info *base;\n-    myint32 offset: 29;\n-    bool is_virtual: 1;\n-    enum access access: 2;\n-  };\n-\n-  const base_info *base_list;\n-  size_t n_bases;\n-\n-  __class_type_info (const char *name, const base_info *bl, size_t bn)\n-    : __user_type_info (name), base_list (bl), n_bases (bn) {}\n-\n-  public:\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const type_info &target, void *obj,\n-                          upcast_result &__restrict result) const;\n-  virtual bool do_dyncast (int boff, sub_kind access_path,\n-                           const type_info &target, void *obj,\n-                           const type_info &subtype, void *subptr,\n-                           dyncast_result &__restrict result) const;\n-  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,\n-                                          void *objptr, void *subptr) const;\n-};\n-#else\n-// new abi\n-#include <cxxabi.h>\n-\n-#endif"}, {"sha": "7c9a764134c305ef38363295a5844b1a2269832b", "filename": "gcc/cp/tinfo2.cc", "status": "removed", "additions": 0, "deletions": 452, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,452 +0,0 @@\n-// Methods for type_info for -*- C++ -*- Run Time Type Identification.\n-// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000 Free Software Foundation\n-\n-// This file is part of GNU CC.\n-\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA. \n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#include <stddef.h>\n-#include \"tinfo.h\"\n-#include \"new\"\t\t\t// for placement new\n-\n-// We can't rely on having stdlib.h if we're freestanding.\n-extern \"C\" void abort ();\n-\n-using std::type_info;\n-\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-bool\n-type_info::before (const type_info &arg) const\n-{\n-  return __builtin_strcmp (name (), arg.name ()) < 0;\n-}\n-\n-// type info for pointer type.\n-\n-struct __pointer_type_info : public type_info {\n-  const type_info& type;\n-\n-  __pointer_type_info (const char *n, const type_info& ti)\n-    : type_info (n), type (ti) {}\n-};\n-\n-// type info for attributes\n-\n-struct __attr_type_info : public type_info {\n-  enum cv { NONE = 0, CONST = 1, VOLATILE = 2, CONSTVOL = 1 | 2 };\n-\n-  const type_info& type;\n-  cv attr;\n-\n-  __attr_type_info (const char *n, cv a, const type_info& t)\n-    : type_info (n), type (t), attr (a) {}\n-};\n-\n-// type_info for builtin type\n-\n-struct __builtin_type_info : public type_info {\n-  __builtin_type_info (const char *n): type_info (n) {}\n-};\n-\n-// type info for function.\n-\n-struct __func_type_info : public type_info {\n-  __func_type_info (const char *n) : type_info (n) {}\n-};\n-\n-// type info for pointer to member function.\n-\n-struct __ptmf_type_info : public type_info {\n-  __ptmf_type_info (const char *n) : type_info (n) {}\n-};\n-\n-// type info for pointer to data member.\n-\n-struct __ptmd_type_info : public type_info {\n-  __ptmd_type_info (const char *n): type_info (n) {}\n-};\n-\n-// type info for array.\n-\n-struct __array_type_info : public type_info {\n-  __array_type_info (const char *n): type_info (n) {}\n-};\n-\n-#else\n-\n-#include <cxxabi.h>\n-#endif\n-\n-#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n-namespace __cxxabiv1 {\n-\n-using namespace std;\n-\n-// This has special meaning to the compiler, and will cause it\n-// to emit the type_info structures for the fundamental types which are\n-// mandated to exist in the runtime.\n-__fundamental_type_info::\n-~__fundamental_type_info ()\n-{}\n-\n-__array_type_info::\n-~__array_type_info ()\n-{}\n-\n-__function_type_info::\n-~__function_type_info ()\n-{}\n-\n-__enum_type_info::\n-~__enum_type_info ()\n-{}\n-\n-__pbase_type_info::\n-~__pbase_type_info ()\n-{}\n-\n-__pointer_type_info::\n-~__pointer_type_info ()\n-{}\n-\n-__pointer_to_member_type_info::\n-~__pointer_to_member_type_info ()\n-{}\n-\n-bool __pointer_type_info::\n-__is_pointer_p () const\n-{\n-  return true;\n-}\n-\n-bool __function_type_info::\n-__is_function_p () const\n-{\n-  return true;\n-}\n-\n-bool __pbase_type_info::\n-__do_catch (const type_info *thr_type,\n-            void **thr_obj,\n-            unsigned outer) const\n-{\n-  if (*this == *thr_type)\n-    return true;      // same type\n-  if (typeid (*this) != typeid (*thr_type))\n-    return false;     // not both same kind of pointers\n-  \n-  if (!(outer & 1))\n-    // We're not the same and our outer pointers are not all const qualified\n-    // Therefore there must at least be a qualification conversion involved\n-    // But for that to be valid, our outer pointers must be const qualified.\n-    return false;\n-  \n-  const __pbase_type_info *thrown_type =\n-    static_cast <const __pbase_type_info *> (thr_type);\n-  \n-  if (thrown_type->__qualifier_flags & ~__qualifier_flags)\n-    // We're less qualified.\n-    return false;\n-  \n-  if (!(__qualifier_flags & __const_mask))\n-    outer &= ~1;\n-  \n-  return __pointer_catch (thrown_type, thr_obj, outer);\n-}\n-\n-inline bool __pbase_type_info::\n-__pointer_catch (const __pbase_type_info *thrown_type,\n-                 void **thr_obj,\n-                 unsigned outer) const\n-{\n-  return __pointee->__do_catch (thrown_type->__pointee, thr_obj, outer + 2);\n-}\n-\n-bool __pointer_type_info::\n-__pointer_catch (const __pbase_type_info *thrown_type,\n-                 void **thr_obj,\n-                 unsigned outer) const\n-{\n-  if (outer < 2 && *__pointee == typeid (void))\n-    {\n-      // conversion to void\n-      return !thrown_type->__pointee->__is_function_p ();\n-    }\n-  \n-  return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);\n-}\n-\n-bool __pointer_to_member_type_info::\n-__pointer_catch (const __pbase_type_info *thr_type,\n-                 void **thr_obj,\n-                 unsigned outer) const\n-{\n-  // This static cast is always valid, as our caller will have determined that\n-  // thr_type is really a __pointer_to_member_type_info.\n-  const __pointer_to_member_type_info *thrown_type =\n-    static_cast <const __pointer_to_member_type_info *> (thr_type);\n-  \n-  if (*__context_class != *thrown_type->__context_class)\n-    return false;     // not pointers to member of same class\n-  \n-  return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);\n-}\n-\n-} // namespace std\n-#endif\n-\n-// Entry points for the compiler.\n-\n-/* Low level match routine used by compiler to match types of catch\n-   variables and thrown objects.  */\n-\n-extern \"C\" int\n-__throw_type_match_rtti_2 (const void *catch_type_r, const void *throw_type_r,\n-\t\t\t void *objptr, void **valp)\n-{\n-  const type_info &catch_type = *(const type_info *)catch_type_r;\n-  const type_info &throw_type = *(const type_info *)throw_type_r;\n-\n-  *valp = objptr;\n-\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-// old abi\n-  if (catch_type == throw_type)\n-    return 1;\n-  \n-  if (const __user_type_info *p\n-      = dynamic_cast <const __user_type_info *> (&throw_type))\n-    {\n-      return p->upcast (catch_type, objptr, valp);\n-    }\n-  else if (const __pointer_type_info *fr =\n-\t   dynamic_cast <const __pointer_type_info *> (&throw_type))\n-    {\n-      const __pointer_type_info *to =\n-\t   dynamic_cast <const __pointer_type_info *> (&catch_type);\n-\n-      if (! to)\n-\treturn 0;\n-\n-      const type_info *subfr = &fr->type, *subto = &to->type;\n-      __attr_type_info::cv cvfrom, cvto;\n-\n-      if (const __attr_type_info *at\n-\t  = dynamic_cast <const __attr_type_info *> (subfr))\n-\t{\n-\t  cvfrom = at->attr;\n-\t  subfr = &at->type;\n-\t}\n-      else\n-\tcvfrom = __attr_type_info::NONE;\n-      \n-      if (const __attr_type_info *at\n-\t  = dynamic_cast <const __attr_type_info *> (subto))\n-\t{\n-\t  cvto = at->attr;\n-\t  subto = &at->type;\n-\t}\n-      else\n-\tcvto = __attr_type_info::NONE;\n-\n-      if (((cvfrom & __attr_type_info::CONST)\n-\t   > (cvto & __attr_type_info::CONST))\n-\t  || ((cvfrom & __attr_type_info::VOLATILE)\n-\t      > (cvto & __attr_type_info::VOLATILE)))\n-\treturn 0;\n-\n-      if (*subto == *subfr)\n-\treturn 1;\n-      else if (*subto == typeid (void)\n-\t       && dynamic_cast <const __func_type_info *> (subfr) == 0)\n-\treturn 1;\n-      else if (const __user_type_info *p\n-\t       = dynamic_cast <const __user_type_info *> (subfr))\n-\treturn p->upcast (*subto, objptr, valp);\n-      else if (const __pointer_type_info *pfr\n-\t       = dynamic_cast <const __pointer_type_info *> (subfr))\n-\t{\n-\t  // Multi-level pointer conversion.\n-\n-\t  const __pointer_type_info *pto\n-\t    = dynamic_cast <const __pointer_type_info *> (subto);\n-\n-\t  if (! pto)\n-\t    return 0;\n-\t    \n-\t  bool constp = (cvto & __attr_type_info::CONST);\n-\t  for (subto = &pto->type, subfr = &pfr->type; ;\n-\t       subto = &pto->type, subfr = &pfr->type)\n-\t    {\n-\t      if (const __attr_type_info *at\n-\t\t  = dynamic_cast <const __attr_type_info *> (subfr))\n-\t\t{\n-\t\t  cvfrom = at->attr;\n-\t\t  subfr = &at->type;\n-\t\t}\n-\t      else\n-\t\tcvfrom = __attr_type_info::NONE;\n-      \n-\t      if (const __attr_type_info *at\n-\t\t  = dynamic_cast <const __attr_type_info *> (subto))\n-\t\t{\n-\t\t  cvto = at->attr;\n-\t\t  subto = &at->type;\n-\t\t}\n-\t      else\n-\t\tcvto = __attr_type_info::NONE;\n-\n-\t      if (((cvfrom & __attr_type_info::CONST)\n-\t\t   > (cvto & __attr_type_info::CONST))\n-\t\t  || ((cvfrom & __attr_type_info::VOLATILE)\n-\t\t      > (cvto & __attr_type_info::VOLATILE)))\n-\t\treturn 0;\n-\n-\t      if (! constp\n-\t\t  && (((cvfrom & __attr_type_info::CONST)\n-\t\t       < (cvto & __attr_type_info::CONST))\n-\t\t      || ((cvfrom & __attr_type_info::VOLATILE)\n-\t\t\t  < (cvto & __attr_type_info::VOLATILE))))\n-\t\treturn 0;\n-\n-\t      if (*subto == *subfr)\n-\t\treturn 1;\n-\n-\t      pto = dynamic_cast <const __pointer_type_info *> (subto);\n-\t      pfr = dynamic_cast <const __pointer_type_info *> (subfr);\n-\t      if (! pto || ! pfr)\n-\t\treturn 0;\t\t\n-\n-\t      if (! (cvto & __attr_type_info::CONST))\n-\t\tconstp = false;\n-\t    }\n-\t}\n-    }\n-#else\n-// new abi\n-  \n-  return catch_type.__do_catch (&throw_type, valp, 1);\n-#endif\n-  return 0;\n-}\n-\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-/* Backward compatibility wrapper.  */\n-\n-extern \"C\" void*\n-__throw_type_match_rtti (const void *catch_type_r, const void *throw_type_r,\n-\t\t\t void *objptr)\n-{\n-  void *ret;\n-  if (__throw_type_match_rtti_2 (catch_type_r, throw_type_r, objptr, &ret))\n-    return ret;\n-  return NULL;\n-}\n-#endif\n-\n-/* Called from __cp_pop_exception.  Is P the type_info node for a pointer\n-   of some kind?  */\n-\n-bool\n-__is_pointer (void *p)\n-{\n-  const type_info *t = reinterpret_cast <const type_info *>(p);\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-// old abi\n-  const __pointer_type_info *pt =\n-    dynamic_cast <const __pointer_type_info *> (t);\n-  return pt != 0;\n-#else\n-// new abi\n-  return t->__is_pointer_p ();\n-#endif\n-}\n-\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-// old abi\n-\n-extern \"C\" void\n-__rtti_ptr (void *addr, const char *n, const type_info *ti)\n-{ new (addr) __pointer_type_info (n, *ti); }\n-\n-extern \"C\" void\n-__rtti_attr (void *addr, const char *n, int attrval, const type_info *ti)\n-{\n-  new (addr) __attr_type_info\n-    (n, static_cast <__attr_type_info::cv> (attrval), *ti);\n-}\n-\n-extern \"C\" void\n-__rtti_func (void *addr, const char *name)\n-{ new (addr) __func_type_info (name); }\n-\n-extern \"C\" void\n-__rtti_ptmf (void *addr, const char *name)\n-{ new (addr) __ptmf_type_info (name); }\n-\n-extern \"C\" void\n-__rtti_ptmd (void *addr, const char *name)\n-{ new (addr) __ptmd_type_info (name); }\n-\n-extern \"C\" void\n-__rtti_array (void *addr, const char *name)\n-{ new (addr) __array_type_info (name); }\n-\n-extern \"C\" void *\n-__dynamic_cast (const type_info& (*from)(void), const type_info& (*to)(void),\n-\t\tint require_public, void *address, const type_info & (*sub)(void), void *subptr)\n-{\n-  if (!require_public) abort();\n-  return static_cast <__user_type_info const &> (from ()).dyncast\n-      (/*boff=*/-1, to (), address, sub (), subptr);\n-}\n-\n-extern \"C\" void *\n-__dynamic_cast_2 (const type_info& (*from)(void), const type_info& (*to)(void),\n-                  int boff,\n-\t\t  void *address, const type_info & (*sub)(void), void *subptr)\n-{\n-  return static_cast <__user_type_info const &> (from ()).dyncast\n-      (boff, to (), address, sub (), subptr);\n-}\n-\n-// type_info nodes and functions for the builtin types.  The mangling here\n-// must match the mangling in gcc/cp/rtti.c.\n-\n-#define BUILTIN(mangled)\t\t\t\t\t\\\n-unsigned char __ti##mangled [sizeof (__builtin_type_info)]\t\\\n-  __attribute__ ((aligned (__alignof__ (void *))));\t\t\\\n-extern \"C\" const type_info &__tf##mangled (void) {\t\t\\\n-  if ((*(void **) __ti##mangled) == 0)\t\t\t\t\\\n-    new (__ti##mangled) __builtin_type_info (#mangled);\t\t\\\n-  return *(type_info *)__ti##mangled;\t\t\t\t\\\n-}\n-\n-BUILTIN (v); BUILTIN (x); BUILTIN (l); BUILTIN (i); BUILTIN (s); BUILTIN (b);\n-BUILTIN (c); BUILTIN (w); BUILTIN (r); BUILTIN (d); BUILTIN (f);\n-BUILTIN (Ui); BUILTIN (Ul); BUILTIN (Ux); BUILTIN (Us); BUILTIN (Uc);\n-BUILTIN (Sc);\n-\n-#endif"}, {"sha": "966feb486de49a7f124dd1b9263d6e60e7681454", "filename": "gcc/cp/vec.cc", "status": "removed", "additions": 0, "deletions": 279, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Fvec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3734420fe1abfd0cbe626423a5a4a2b7046e733b/gcc%2Fcp%2Fvec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fvec.cc?ref=3734420fe1abfd0cbe626423a5a4a2b7046e733b", "patch": "@@ -1,279 +0,0 @@\n-// new abi support -*- C++ -*-\n-// Copyright (C) 2000\n-// Free Software Foundation, Inc.\n-// Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>\n-// \n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA. \n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n-#include <cxxabi.h>\n-#include <new>\n-#include <exception>\n-\n-// Exception handling hook, to mark current exception as not caught --\n-// generally because we're about to rethrow it after some cleanup.\n-extern \"C\" void __uncatch_exception (void);\n-\n-namespace __cxxabiv1\n-{\n-\n-/* allocate and construct array */\n-extern \"C\" void *\n-__cxa_vec_new (size_t element_count,\n-               size_t element_size,\n-               size_t padding_size,\n-               void (*constructor) (void *),\n-               void (*destructor) (void *))\n-{\n-  return __cxa_vec_new2 (element_count, element_size, padding_size,\n-                         constructor, destructor,\n-                         &operator new[], &operator delete []);\n-}\n-\n-extern \"C\" void *\n-__cxa_vec_new2 (size_t element_count,\n-                size_t element_size,\n-                size_t padding_size,\n-                void (*constructor) (void *),\n-                void (*destructor) (void *),\n-                void *(*alloc) (size_t),\n-                void (*dealloc) (void *))\n-{\n-  size_t size = element_count * element_size + padding_size;\n-  char *base = static_cast <char *> (alloc (size));\n-  \n-  if (padding_size)\n-    {\n-      base += padding_size;\n-      reinterpret_cast <size_t *> (base)[-1] = element_count;\n-    }\n-  try\n-    {\n-      __cxa_vec_ctor (base, element_count, element_size,\n-                      constructor, destructor);\n-    }\n-  catch (...)\n-    {\n-      __uncatch_exception ();\n-      dealloc (base - padding_size);\n-      throw;\n-    }\n-  return base;\n-}\n-\n-extern \"C\" void *\n-__cxa_vec_new3 (size_t element_count,\n-                size_t element_size,\n-                size_t padding_size,\n-                void (*constructor) (void *),\n-                void (*destructor) (void *),\n-                void *(*alloc) (size_t),\n-                void (*dealloc) (void *, size_t))\n-{\n-  size_t size = element_count * element_size + padding_size;\n-  char *base = static_cast <char *> (alloc (size));\n-  \n-  if (padding_size)\n-    {\n-      base += padding_size;\n-      reinterpret_cast <size_t *> (base)[-1] = element_count;\n-    }\n-  try\n-    {\n-      __cxa_vec_ctor (base, element_count, element_size,\n-                      constructor, destructor);\n-    }\n-  catch (...)\n-    {\n-      __uncatch_exception ();\n-      dealloc (base - padding_size, size);\n-      throw;\n-    }\n-  return base;\n-}\n-\n-/* construct array */\n-extern \"C\" void\n-__cxa_vec_ctor (void *array_address,\n-                size_t element_count,\n-                size_t element_size,\n-                void (*constructor) (void *),\n-                void (*destructor) (void *))\n-{\n-  size_t ix = 0;\n-  char *ptr = static_cast <char *> (array_address);\n-  \n-  try\n-    {\n-      if (constructor)\n-        for (; ix != element_count; ix++, ptr += element_size)\n-          constructor (ptr);\n-    }\n-  catch (...)\n-    {\n-      __uncatch_exception ();\n-      __cxa_vec_dtor (array_address, ix, element_size, destructor);\n-      throw;\n-    }\n-}\n-\n-/* construct an array by copying */\n-\n-extern \"C\" void\n-__cxa_vec_cctor (void *dest_array,\n-\t\t void *src_array,\n-\t\t size_t element_count,\n-\t\t size_t element_size,\n-\t\t void (*constructor) (void *, void *),\n-\t\t void (*destructor) (void *))\n-{\n-  size_t ix = 0;\n-  char *dest_ptr = static_cast <char *> (dest_array);\n-  char *src_ptr = static_cast <char *> (src_array);\n-\n-  try\n-    {\n-      if (constructor)\n-\tfor (; ix != element_count; \n-\t     ix++, src_ptr += element_size, dest_ptr += element_size)\n-\t  constructor (dest_ptr, src_ptr);\n-    }\n-  catch (...)\n-    {\n-      __uncatch_exception ();\n-      __cxa_vec_dtor (dest_array, ix, element_size, destructor);\n-      throw;\n-    }\n-}\n-\n-/* destruct array */\n-extern \"C\" void\n-__cxa_vec_dtor (void *array_address,\n-                size_t element_count,\n-                size_t element_size,\n-                void (*destructor) (void *))\n-{\n-  if (destructor)\n-    {\n-      char *ptr = static_cast <char *> (array_address);\n-      size_t ix = element_count;\n-      bool unwinding = std::uncaught_exception ();\n-      \n-      ptr += element_count * element_size;\n-      \n-      try\n-        {\n-          while (ix--)\n-            {\n-              ptr -= element_size;\n-              destructor (ptr);\n-            }\n-        }\n-      catch (...)\n-        {\n-          if (unwinding)\n-            // [except.ctor]/3 If a destructor called during stack unwinding\n-            // exits with an exception, terminate is called.\n-            std::terminate ();\n-          __uncatch_exception ();\n-          __cxa_vec_dtor (array_address, ix, element_size, destructor);\n-          throw;\n-        }\n-    }\n-}\n-\n-/* destruct and release array */\n-extern \"C\" void\n-__cxa_vec_delete (void *array_address,\n-                  size_t element_size,\n-                  size_t padding_size,\n-                  void (*destructor) (void *))\n-{\n-  __cxa_vec_delete2 (array_address, element_size, padding_size,\n-                     destructor,\n-                     &operator delete []);\n-}\n-\n-extern \"C\" void\n-__cxa_vec_delete2 (void *array_address,\n-                  size_t element_size,\n-                  size_t padding_size,\n-                  void (*destructor) (void *),\n-                  void (*dealloc) (void *))\n-{\n-  char *base = static_cast <char *> (array_address);\n-  \n-  if (padding_size)\n-    {\n-      size_t element_count = reinterpret_cast <size_t *> (base)[-1];\n-      base -= padding_size;\n-      try\n-        {\n-          __cxa_vec_dtor (array_address, element_count, element_size,\n-                          destructor);\n-        }\n-      catch (...)\n-        {\n-          __uncatch_exception ();\n-          dealloc (base);\n-          throw;\n-        }\n-    }\n-  dealloc (base);\n-}\n-\n-extern \"C\" void\n-__cxa_vec_delete3 (void *array_address,\n-                  size_t element_size,\n-                  size_t padding_size,\n-                  void (*destructor) (void *),\n-                  void (*dealloc) (void *, size_t))\n-{\n-  char *base = static_cast <char *> (array_address);\n-  size_t size = 0;\n-  \n-  if (padding_size)\n-    {\n-      size_t element_count = reinterpret_cast <size_t *> (base)[-1];\n-      base -= padding_size;\n-      size = element_count * element_size + padding_size;\n-      try\n-        {\n-          __cxa_vec_dtor (array_address, element_count, element_size,\n-                          destructor);\n-        }\n-      catch (...)\n-        {\n-          __uncatch_exception ();\n-          dealloc (base, size);\n-          throw;\n-        }\n-    }\n-  dealloc (base, size);\n-}\n-\n-} // namespace __cxxabiv1\n-\n-#endif // defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100"}]}