{"sha": "91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFlM2VjMjlhZjJiMjBkMjZhOTdiNGI4MGM4OGVhYzlhZDk1ZTAxMQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-10-30T21:58:35Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-10-30T21:58:35Z"}, "message": "PR middle-end/87041 - -Wformat reading through null pointer on unreachable code\n\ngcc/ChangeLog:\n\n\tPR middle-end/87041\n\t* gimple-ssa-sprintf.c (format_directive): Use %G to include\n\tinlining context.\n\t(sprintf_dom_walker::compute_format_length):\n\tAvoid setting POSUNDER4K here.\n\t(get_destination_size): Handle null argument values.\n\t(get_user_idx_format): New function.\n\t(sprintf_dom_walker::handle_gimple_call): Handle all printf-like\n\tfunctions, including user-defined with attribute format printf.\n\tUse %G to include inlining context.\n\tSet POSUNDER4K here.\n\ngcc/c-family/ChangeLog:\n\n\tPR middle-end/87041\n\t* c-format.c (check_format_types): Avoid diagnosing null pointer\n\targuments to printf-family of functions.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/87041\n\t* gcc.c-torture/execute/fprintf-2.c: New test.\n\t* gcc.c-torture/execute/printf-2.c: Same.\n\t* gcc.c-torture/execute/user-printf.c: Same.\n\t* gcc.dg/tree-ssa/builtin-fprintf-warn-1.c: Same.\n\t* gcc.dg/tree-ssa/builtin-printf-2.c: Same.\n\t* gcc.dg/tree-ssa/builtin-printf-warn-1.c: Same.\n\t* gcc.dg/tree-ssa/user-printf-warn-1.c: Same.\n\nFrom-SVN: r265648", "tree": {"sha": "d20422e7e859155af3641fb4809c1ccabcd62586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d20422e7e859155af3641fb4809c1ccabcd62586"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "448af20a27c9a1706712eba8500f5f81f5f6a46d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/448af20a27c9a1706712eba8500f5f81f5f6a46d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/448af20a27c9a1706712eba8500f5f81f5f6a46d"}], "stats": {"total": 1034, "additions": 1009, "deletions": 25}, "files": [{"sha": "6cdbe51ce752f628e8777dc8ea8fdeeba87d7c85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -1,3 +1,17 @@\n+2018-10-30  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/87041\n+\t* gimple-ssa-sprintf.c (format_directive): Use %G to include\n+\tinlining context.\n+\t(sprintf_dom_walker::compute_format_length):\n+\tAvoid setting POSUNDER4K here.\n+\t(get_destination_size): Handle null argument values.\n+\t(get_user_idx_format): New function.\n+\t(sprintf_dom_walker::handle_gimple_call): Handle all printf-like\n+\tfunctions, including user-defined with attribute format printf.\n+\tUse %G to include inlining context.\n+\tSet POSUNDER4K here.\n+\n 2018-10-30  Jan Hubicka  <jh@suse.cz>\n \n \t* params.def (lto-partitions): Bump from 32 to 128."}, {"sha": "5b9658256200c5b54e5be8a06ac0a2c678410b56", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -1,3 +1,9 @@\n+2018-10-30  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/87041\n+\t* c-format.c (check_format_types): Avoid diagnosing null pointer\n+\targuments to printf-family of functions.\n+\n 2018-10-30  Marek Polacek  <polacek@redhat.com>\n \n \tImplement P0892R2, explicit(bool)."}, {"sha": "dc937c6cabafd732c768ce46589437f96a4c1288", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -3123,8 +3123,11 @@ check_format_types (const substring_loc &fmt_loc,\n \t\twarning (OPT_Wformat_, \"writing through null pointer \"\n \t\t\t \"(argument %d)\", arg_num);\n \n-\t      /* Check for reading through a NULL pointer.  */\n-\t      if (types->reading_from_flag\n+\t      /* Check for reading through a NULL pointer.  Ignore\n+\t\t printf-family of functions as they are checked for\n+\t\t null arguments by the middle-end.  */\n+\t      if (fki->conversion_specs != print_char_table\n+\t\t  && types->reading_from_flag\n \t\t  && i == 0\n \t\t  && cur_param != 0\n \t\t  && integer_zerop (cur_param))"}, {"sha": "456a7d400115713a6600b1ce7bb303b6c971550e", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 167, "deletions": 23, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -68,6 +68,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"langhooks.h\"\n \n+#include \"attribs.h\"\n #include \"builtins.h\"\n #include \"stor-layout.h\"\n \n@@ -2796,8 +2797,9 @@ format_directive (const sprintf_dom_walker::call_info &info,\n   if (fmtres.nullp)\n     {\n       fmtwarn (dirloc, argloc, NULL, info.warnopt (),\n-\t       \"%<%.*s%> directive argument is null\",\n-\t       dirlen, target_to_host (hostdir, sizeof hostdir, dir.beg));\n+\t       \"%G%<%.*s%> directive argument is null\",\n+\t       info.callstmt, dirlen,\n+\t       target_to_host (hostdir, sizeof hostdir, dir.beg));\n \n       /* Don't bother processing the rest of the format string.  */\n       res->warned = true;\n@@ -3475,7 +3477,6 @@ sprintf_dom_walker::compute_format_length (call_info &info,\n      by the known range [0, 0] (with no conversion resulting in a failure\n      or producing more than 4K bytes) until determined otherwise.  */\n   res->knownrange = true;\n-  res->posunder4k = true;\n   res->floating = false;\n   res->warned = false;\n \n@@ -3518,6 +3519,10 @@ sprintf_dom_walker::compute_format_length (call_info &info,\n static unsigned HOST_WIDE_INT\n get_destination_size (tree dest)\n {\n+  /* When there is no destination return -1.  */\n+  if (!dest)\n+    return HOST_WIDE_INT_M1U;\n+\n   /* Initialize object size info before trying to compute it.  */\n   init_object_sizes ();\n \n@@ -3738,6 +3743,37 @@ try_simplify_call (gimple_stmt_iterator *gsi,\n   return false;\n }\n \n+/* Return the zero-based index of the format string argument of a printf\n+   like function and set *IDX_ARGS to the first format argument.  When\n+   no such index exists return UINT_MAX.  */\n+\n+static unsigned\n+get_user_idx_format (tree fndecl, unsigned *idx_args)\n+{\n+  tree attrs = lookup_attribute (\"format\", DECL_ATTRIBUTES (fndecl));\n+  if (!attrs)\n+    attrs = lookup_attribute (\"format\", TYPE_ATTRIBUTES (TREE_TYPE (fndecl)));\n+\n+  if (!attrs)\n+    return UINT_MAX;\n+\n+  attrs = TREE_VALUE (attrs);\n+\n+  tree archetype = TREE_VALUE (attrs);\n+  if (strcmp (\"printf\", IDENTIFIER_POINTER (archetype)))\n+    return UINT_MAX;\n+\n+  attrs = TREE_CHAIN (attrs);\n+  tree fmtarg = TREE_VALUE (attrs);\n+\n+  attrs = TREE_CHAIN (attrs);\n+  tree elliparg = TREE_VALUE (attrs);\n+\n+  /* Attribute argument indices are 1-based but we use zero-based.  */\n+  *idx_args = tree_to_uhwi (elliparg) - 1;\n+  return tree_to_uhwi (fmtarg) - 1;\n+}\n+\n /* Determine if a GIMPLE CALL is to one of the sprintf-like built-in\n    functions and if so, handle it.  Return true if the call is removed\n    and gsi_next should not be performed in the caller.  */\n@@ -3748,29 +3784,93 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n   call_info info = call_info ();\n \n   info.callstmt = gsi_stmt (*gsi);\n-  if (!gimple_call_builtin_p (info.callstmt, BUILT_IN_NORMAL))\n+  info.func = gimple_call_fndecl (info.callstmt);\n+  if (!info.func)\n     return false;\n \n-  info.func = gimple_call_fndecl (info.callstmt);\n   info.fncode = DECL_FUNCTION_CODE (info.func);\n \n+  /* Format string argument number (valid for all functions).  */\n+  unsigned idx_format = UINT_MAX;\n+  if (!gimple_call_builtin_p (info.callstmt, BUILT_IN_NORMAL))\n+    {\n+      unsigned idx_args;\n+      idx_format = get_user_idx_format (info.func, &idx_args);\n+      if (idx_format == UINT_MAX)\n+\treturn false;\n+      info.argidx = idx_args;\n+    }\n+\n   /* The size of the destination as in snprintf(dest, size, ...).  */\n   unsigned HOST_WIDE_INT dstsize = HOST_WIDE_INT_M1U;\n \n   /* The size of the destination determined by __builtin_object_size.  */\n   unsigned HOST_WIDE_INT objsize = HOST_WIDE_INT_M1U;\n \n-  /* Buffer size argument number (snprintf and vsnprintf).  */\n-  unsigned HOST_WIDE_INT idx_dstsize = HOST_WIDE_INT_M1U;\n+  /* Zero-based buffer size argument number (snprintf and vsnprintf).  */\n+  unsigned idx_dstsize = UINT_MAX;\n \n   /* Object size argument number (snprintf_chk and vsnprintf_chk).  */\n-  unsigned HOST_WIDE_INT idx_objsize = HOST_WIDE_INT_M1U;\n+  unsigned idx_objsize = UINT_MAX;\n \n-  /* Format string argument number (valid for all functions).  */\n-  unsigned idx_format;\n+  /* Destinaton argument number (valid for sprintf functions only).  */\n+  unsigned idx_dstptr = 0;\n \n   switch (info.fncode)\n     {\n+    case BUILT_IN_NONE:\n+      // User-defined function with attribute format (printf).\n+      idx_dstptr = -1;\n+      break;\n+\n+    case BUILT_IN_FPRINTF:\n+      // Signature:\n+      //   __builtin_fprintf (FILE*, format, ...)\n+      idx_format = 1;\n+      info.argidx = 2;\n+      idx_dstptr = -1;\n+      break;\n+\n+    case BUILT_IN_FPRINTF_CHK:\n+      // Signature:\n+      //   __builtin_fprintf_chk (FILE*, ost, format, ...)\n+      idx_format = 2;\n+      info.argidx = 3;\n+      idx_dstptr = -1;\n+      break;\n+\n+    case BUILT_IN_FPRINTF_UNLOCKED:\n+      // Signature:\n+      //   __builtin_fprintf_unnlocked (FILE*, format, ...)\n+      idx_format = 1;\n+      info.argidx = 2;\n+      idx_dstptr = -1;\n+      break;\n+\n+    case BUILT_IN_PRINTF:\n+      // Signature:\n+      //   __builtin_printf (format, ...)\n+      idx_format = 0;\n+      info.argidx = 1;\n+      idx_dstptr = -1;\n+      break;\n+\n+    case BUILT_IN_PRINTF_CHK:\n+      // Signature:\n+      //   __builtin_printf_chk (it, format, ...)\n+      idx_format = 1;\n+      info.argidx = 2;\n+      idx_dstptr = -1;\n+      break;\n+\n+    case BUILT_IN_PRINTF_UNLOCKED:\n+      // Signature:\n+      //   __builtin_printf (format, ...)\n+      idx_format = 0;\n+      info.argidx = 1;\n+      idx_dstptr = -1;\n+      break;\n+\n     case BUILT_IN_SPRINTF:\n       // Signature:\n       //   __builtin_sprintf (dst, format, ...)\n@@ -3805,6 +3905,38 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n       info.bounded = true;\n       break;\n \n+    case BUILT_IN_VFPRINTF:\n+      // Signature:\n+      //   __builtin_vprintf (FILE*, format, va_list)\n+      idx_format = 1;\n+      info.argidx = -1;\n+      idx_dstptr = -1;\n+      break;\n+\n+    case BUILT_IN_VFPRINTF_CHK:\n+      // Signature:\n+      //   __builtin___vfprintf_chk (FILE*, ost, format, va_list)\n+      idx_format = 2;\n+      info.argidx = -1;\n+      idx_dstptr = -1;\n+      break;\n+\n+    case BUILT_IN_VPRINTF:\n+      // Signature:\n+      //   __builtin_vprintf (format, va_list)\n+      idx_format = 0;\n+      info.argidx = -1;\n+      idx_dstptr = -1;\n+      break;\n+\n+    case BUILT_IN_VPRINTF_CHK:\n+      // Signature:\n+      //   __builtin___vprintf_chk (ost, format, va_list)\n+      idx_format = 1;\n+      info.argidx = -1;\n+      idx_dstptr = -1;\n+      break;\n+\n     case BUILT_IN_VSNPRINTF:\n       // Signature:\n       //   __builtin_vsprintf (dst, size, format, va)\n@@ -3846,16 +3978,18 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n   /* Set the global warning level for this function.  */\n   warn_level = info.bounded ? warn_format_trunc : warn_format_overflow;\n \n-  /* The first argument is a pointer to the destination.  */\n-  tree dstptr = gimple_call_arg (info.callstmt, 0);\n+  /* For all string functions the first argument is a pointer to\n+     the destination.  */\n+  tree dstptr = (idx_dstptr < gimple_call_num_args (info.callstmt)\n+\t\t ? gimple_call_arg (info.callstmt, 0) : NULL_TREE);\n \n   info.format = gimple_call_arg (info.callstmt, idx_format);\n \n   /* True when the destination size is constant as opposed to the lower\n      or upper bound of a range.  */\n   bool dstsize_cst_p = true;\n \n-  if (idx_dstsize == HOST_WIDE_INT_M1U)\n+  if (idx_dstsize == UINT_MAX)\n     {\n       /* For non-bounded functions like sprintf, determine the size\n \t of the destination from the object or pointer passed to it\n@@ -3880,7 +4014,7 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n \t      /* Avoid warning if -Wstringop-overflow is specified since\n \t\t it also warns for the same thing though only for the\n \t\t checking built-ins.  */\n-\t      if ((idx_objsize == HOST_WIDE_INT_M1U\n+\t      if ((idx_objsize == UINT_MAX\n \t\t   || !warn_stringop_overflow))\n \t\twarning_at (gimple_location (info.callstmt), info.warnopt (),\n \t\t\t    \"specified bound %wu exceeds maximum object size \"\n@@ -3910,7 +4044,7 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n \t}\n     }\n \n-  if (idx_objsize != HOST_WIDE_INT_M1U)\n+  if (idx_objsize != UINT_MAX)\n     if (tree size = gimple_call_arg (info.callstmt, idx_objsize))\n       if (tree_fits_uhwi_p (size))\n \tobjsize = tree_to_uhwi (size);\n@@ -3930,14 +4064,15 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n       /* For calls to non-bounded functions or to those of bounded\n \t functions with a non-zero size, warn if the destination\n \t pointer is null.  */\n-      if (integer_zerop (dstptr))\n+      if (dstptr && integer_zerop (dstptr))\n \t{\n \t  /* This is diagnosed with -Wformat only when the null is a constant\n \t     pointer.  The warning here diagnoses instances where the pointer\n \t     is not constant.  */\n \t  location_t loc = gimple_location (info.callstmt);\n \t  warning_at (EXPR_LOC_OR_LOC (dstptr, loc),\n-\t\t      info.warnopt (), \"null destination pointer\");\n+\t\t      info.warnopt (), \"%Gnull destination pointer\",\n+\t\t      info.callstmt);\n \t  return false;\n \t}\n \n@@ -3950,7 +4085,7 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n \t  /* Avoid warning if -Wstringop-overflow is specified since\n \t     it also warns for the same thing though only for the\n \t     checking built-ins.  */\n-\t  && (idx_objsize == HOST_WIDE_INT_M1U\n+\t  && (idx_objsize == UINT_MAX\n \t      || !warn_stringop_overflow))\n \t{\n \t  warning_at (gimple_location (info.callstmt), info.warnopt (),\n@@ -3959,14 +4094,15 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n \t}\n     }\n \n-  if (integer_zerop (info.format))\n+  /* Determine if the format argument may be null and warn if not\n+     and if the argument is null.  */\n+  if (integer_zerop (info.format)\n+      && gimple_call_builtin_p (info.callstmt, BUILT_IN_NORMAL))\n     {\n-      /* This is diagnosed with -Wformat only when the null is a constant\n-\t pointer.  The warning here diagnoses instances where the pointer\n-\t is not constant.  */\n       location_t loc = gimple_location (info.callstmt);\n       warning_at (EXPR_LOC_OR_LOC (info.format, loc),\n-\t\t  info.warnopt (), \"null format string\");\n+\t\t  info.warnopt (), \"%Gnull format string\",\n+\t\t  info.callstmt);\n       return false;\n     }\n \n@@ -3978,6 +4114,14 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n      including the terminating NUL.  */\n   format_result res = format_result ();\n \n+  /* I/O functions with no destination argument (i.e., all forms of fprintf\n+     and printf) may fail under any conditions.  Others (i.e., all forms of\n+     sprintf) may only fail under specific conditions determined for each\n+     directive.  Clear POSUNDER4K for the former set of functions and set\n+     it to true for the latter (it can only be cleared later, but it is\n+     never set to true again).  */\n+  res.posunder4k = dstptr;\n+\n   bool success = compute_format_length (info, &res);\n   if (res.warned)\n     gimple_set_no_warning (info.callstmt, true);"}, {"sha": "3d96f1caaa006c4772309bcf2e40b25fcc5615d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -1,3 +1,14 @@\n+2018-10-30  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/87041\n+\t* gcc.c-torture/execute/fprintf-2.c: New test.\n+\t* gcc.c-torture/execute/printf-2.c: Same.\n+\t* gcc.c-torture/execute/user-printf.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-fprintf-warn-1.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-printf-2.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-printf-warn-1.c: Same.\n+\t* gcc.dg/tree-ssa/user-printf-warn-1.c: Same.\n+\n 2018-10-30  Marek Polacek  <polacek@redhat.com>\n \n \tImplement P0892R2, explicit(bool)."}, {"sha": "bba4a446ee95822540866462ee5cab8dfc10598b", "filename": "gcc/testsuite/gcc.c-torture/execute/fprintf-2.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffprintf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffprintf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffprintf-2.c?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -0,0 +1,53 @@\n+/* Verify that calls to fprintf don't get eliminated even if their\n+   result on success can be computed at compile time (they can fail).\n+   The calls can still be transformed into those of other functions.\n+   { dg-skip-if \"requires io\" { freestanding } } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+int main (void)\n+{\n+  char *tmpfname = tmpnam (0);\n+  FILE *f = fopen (tmpfname, \"w\");\n+  if (!f)\n+    {\n+      perror (\"fopen for writing\");\n+      return 1;\n+    }\n+\n+  fprintf (f, \"1\");\n+  fprintf (f, \"%c\", '2');\n+  fprintf (f, \"%c%c\", '3', '4');\n+  fprintf (f, \"%s\", \"5\");\n+  fprintf (f, \"%s%s\", \"6\", \"7\");\n+  fprintf (f, \"%i\", 8);\n+  fprintf (f, \"%.1s\\n\", \"9x\");\n+  fclose (f);\n+\n+  f = fopen (tmpfname, \"r\");\n+  if (!f)\n+    {\n+      perror (\"fopen for reading\");\n+      remove (tmpfname);\n+      return 1;\n+    }\n+\n+  char buf[12] = \"\";\n+  if (1 != fscanf (f, \"%s\", buf))\n+    {\n+      perror (\"fscanf\");\n+      fclose (f);\n+      remove (tmpfname);\n+      return 1;\n+    }\n+\n+  fclose (f);\n+  remove (tmpfname);\n+\n+  if (strcmp (buf, \"123456789\"))\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "50741101bbd64fb301e3069b01d423b4d007f575", "filename": "gcc/testsuite/gcc.c-torture/execute/printf-2.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fprintf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fprintf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fprintf-2.c?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -0,0 +1,60 @@\n+/* Verify that calls to printf don't get eliminated even if their\n+   result on success can be computed at compile time (they can fail).\n+   The calls can still be transformed into those of other functions.\n+   { dg-skip-if \"requires io\" { freestanding } } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+__attribute__ ((noipa)) void\n+write_file (void)\n+{\n+  printf (\"1\");\n+  printf (\"%c\", '2');\n+  printf (\"%c%c\", '3', '4');\n+  printf (\"%s\", \"5\");\n+  printf (\"%s%s\", \"6\", \"7\");\n+  printf (\"%i\", 8);\n+  printf (\"%.1s\\n\", \"9x\");\n+}\n+\n+\n+int main (void)\n+{\n+  char *tmpfname = tmpnam (0);\n+  FILE *f = freopen (tmpfname, \"w\", stdout);\n+  if (!f)\n+    {\n+      perror (\"fopen for writing\");\n+      return 1;\n+    }\n+\n+  write_file ();\n+  fclose (f);\n+\n+  f = fopen (tmpfname, \"r\");\n+  if (!f)\n+    {\n+      perror (\"fopen for reading\");\n+      remove (tmpfname);\n+      return 1;\n+    }\n+\n+  char buf[12] = \"\";\n+  if (1 != fscanf (f, \"%s\", buf))\n+    {\n+      perror (\"fscanf\");\n+      fclose (f);\n+      remove (tmpfname);\n+      return 1;\n+    }\n+\n+  fclose (f);\n+  remove (tmpfname);\n+\n+  if (strcmp (buf, \"123456789\"))\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "e5784ed8e961e87c8f2d8ba85bbee6bb1b432155", "filename": "gcc/testsuite/gcc.c-torture/execute/user-printf.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fuser-printf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fuser-printf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fuser-printf.c?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -0,0 +1,64 @@\n+/* Verify that calls to a function declared wiith attribute format (printf)\n+   don't get eliminated even if their result on success can be computed at\n+   compile time (they can fail).\n+   { dg-skip-if \"requires io\" { freestanding } } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+void __attribute__ ((format (printf, 1, 2), noipa))\n+user_print (const char *fmt, ...)\n+{\n+  va_list va;\n+  va_start (va, fmt);\n+  vfprintf (stdout, fmt, va);\n+  va_end (va);\n+}\n+\n+int main (void)\n+{\n+  char *tmpfname = tmpnam (0);\n+  FILE *f = freopen (tmpfname, \"w\", stdout);\n+  if (!f)\n+    {\n+      perror (\"fopen for writing\");\n+      return 1;\n+    }\n+\n+  user_print (\"1\");\n+  user_print (\"%c\", '2');\n+  user_print (\"%c%c\", '3', '4');\n+  user_print (\"%s\", \"5\");\n+  user_print (\"%s%s\", \"6\", \"7\");\n+  user_print (\"%i\", 8);\n+  user_print (\"%.1s\\n\", \"9x\");\n+\n+  fclose (f);\n+\n+  f = fopen (tmpfname, \"r\");\n+  if (!f)\n+    {\n+      perror (\"fopen for reading\");\n+      remove (tmpfname);\n+      return 1;\n+    }\n+\n+  char buf[12] = \"\";\n+  if (1 != fscanf (f, \"%s\", buf))\n+    {\n+      perror (\"fscanf\");\n+      fclose (f);\n+      remove (tmpfname);\n+      return 1;\n+    }\n+\n+  fclose (f);\n+  remove (tmpfname);\n+\n+  if (strcmp (buf, \"123456789\"))\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "5e193d6854ada3f35dcc21df1bd23e7dd3b94787", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-fprintf-warn-1.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-warn-1.c?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -0,0 +1,132 @@\n+/* PR middle-end/87041 - -Wformat \"reading through null pointer\" on\n+   unreachable code\n+   Test to verify that the applicable subset of -Wformat-overflow warnings\n+   are issued for the fprintf function.\n+   { dg-do compile }\n+   { dg-options \"-O -Wformat -Wformat-overflow=1 -ftrack-macro-expansion=0\" }\n+   { dg-require-effective-target int32plus } */\n+\n+/* When debugging, define LINE to the line number of the test case to exercise\n+   and avoid exercising any of the others.  The buffer and objsize macros\n+   below make use of LINE to avoid warnings for other lines.  */\n+#ifndef LINE\n+# define LINE 0\n+#endif\n+\n+#define INT_MAX __INT_MAX__\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#if !__cplusplus\n+typedef __WCHAR_TYPE__ wchar_t;\n+#endif\n+\n+typedef __WINT_TYPE__ wint_t;\n+\n+void sink (void*, ...);\n+\n+/* Declare as void* to work around bug 87775.  */\n+typedef void FILE;\n+\n+int dummy_fprintf (FILE*, const char*, ...);\n+\n+FILE *fp;\n+\n+const char chr_no_nul = 'a';\n+const char arr_no_nul[] = { 'a', 'b' };\n+\n+\n+/* Helper to expand function to either __builtin_f or dummy_f to\n+   make debugging GCC easy.  */\n+#define T(...)\t\t\t\t\t\t\t\\\n+  (((!LINE || LINE == __LINE__)\t\t\t\t\t\\\n+    ? __builtin_fprintf : dummy_fprintf) (fp, __VA_ARGS__))\n+\n+/* Exercise the \"%c\" directive with constant arguments.  */\n+\n+void test_fprintf_c_const (int width)\n+{\n+  /* Verify that a warning is issued for exceeding INT_MAX bytes and\n+     not otherwise.  */\n+  T (\"%*c\",  INT_MAX - 1, '1');\n+  T (\"%*c\",  INT_MAX,     '1');\n+  T (\"X%*c\", INT_MAX - 1, '1');\n+  T (\"X%*c\", INT_MAX,     '1');   /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  T (\"%*c%*c\", INT_MAX - 1, '1', INT_MAX - 1, '2'); /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  T (\"%*cX\", INT_MAX - 2, '1');\n+  T (\"%*cX\", INT_MAX - 1, '1');\n+  T (\"%*cX\", INT_MAX,     '1');   /* { dg-warning \"output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  if (width < INT_MAX - 1)\n+    width = INT_MAX - 1;\n+  T (\"%*cX\", width, '1');\n+  T (\"%*cXY\", width, '1');        /* { dg-warning \".XY. directive output of 2 bytes causes result to exceed .INT_MAX.\" } */\n+\n+  /* Also exercise a non-constant format string.  The warning points\n+     to the line where the format is declared (see bug 87773) so avoid\n+     triggering that bug here.  */\n+  const char *fmt = \"%*cXYZ\";  T (fmt, width, '1');            /* { dg-warning \".XYZ. directive output of 3 bytes causes result to exceed .INT_MAX.\" } */\n+}\n+\n+\n+/* Exercise the \"%s\" directive with constant arguments.  */\n+\n+void test_fprintf_s_const (int width)\n+{\n+  const char *nulptr = 0;\n+\n+  T (\"%s\", nulptr);               /* { dg-warning \"\\\\\\[-Wformat|-Wnonnull\" } */\n+  T (\"%.0s\", nulptr);             /* { dg-warning \".%.0s. directive argument is null\" } */\n+\n+  /* Verify no warning is issued for unreachable code.  */\n+  if (nulptr)\n+    T (\"%s\", nulptr);\n+\n+  T (\"%s\", &chr_no_nul);          /* { dg-warning \".%s. directive argument is not a nul-terminated string\" \"pr87756\" { xfail *-*-* } } */\n+  T (\"%s\", arr_no_nul);           /* { dg-warning \".%s. directive argument is not a nul-terminated string\" \"pr87756\" { xfail *-*-* } } */\n+\n+  /* Verify that output in excess of INT_MAX bytes is diagnosed even\n+     when the size of the destination object is unknown.  */\n+  T (\"%*s\",  INT_MAX - 1, \"\");\n+  T (\"%*s\",  INT_MAX,     \"\");\n+  T (\"X%*s\", INT_MAX,     \"\");    /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  if (width < INT_MAX - 1)\n+    width = INT_MAX - 1;\n+  T (\"%*sX\", width, \"1\");\n+  T (\"%*sXY\", width, \"1\");        /* { dg-warning \".XY. directive output of 2 bytes causes result to exceed .INT_MAX.\" } */\n+}\n+\n+\n+const wchar_t wchr_no_nul = L'a';\n+const wchar_t warr_no_nul[] = { L'a', L'b' };\n+\n+/* Exercise the \"%s\" directive with constant arguments.  */\n+\n+void test_fprintf_ls_const (int width)\n+{\n+  const wchar_t *nulptr = 0;\n+\n+  T (\"%ls\", nulptr);              /* { dg-warning \".%ls. directive argument is null\" } */\n+  T (\"%.0ls\", nulptr);            /* { dg-warning \".%.0ls. directive argument is null\" } */\n+\n+  /* Verify no warning is issued for unreachable code.  */\n+  if (nulptr)\n+    T (\"%ls\", nulptr);\n+\n+  T (\"%ls\", &wchr_no_nul);        /* { dg-warning \".%ls. directive argument is not a nul-terminated string\" \"pr87756\" { xfail *-*-* } } */\n+  T (\"%ls\", warr_no_nul);         /* { dg-warning \".%ls. directive argument is not a nul-terminated string\" \"pr87756\" { xfail *-*-* } } */\n+\n+  /* Verify that output in excess of INT_MAX bytes is diagnosed even\n+     when the size of the destination object is unknown.  */\n+  T (\"%*ls\",  INT_MAX - 1, L\"\");\n+  T (\"%*ls\",  INT_MAX,     L\"\");\n+  T (\"X%*ls\", INT_MAX,     L\"\");  /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  if (width < INT_MAX - 1)\n+    width = INT_MAX - 1;\n+  T (\"%*lsX\", width, L\"1\");\n+  T (\"%*lsXY\", width, L\"1\");      /* { dg-warning \".XY. directive output of 2 bytes causes result to exceed .INT_MAX.\" } */\n+}"}, {"sha": "701f61a703a6276f0da469b3162c7797549bf5ae", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-printf-2.c", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-2.c?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -0,0 +1,213 @@\n+/* Verify that tests for the result of calls to fprintf, printf, vfprintf,\n+   and vprintf are not eliminated, even if it is possible to determine\n+   their value on success (the calls may fail and return a negative value).\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+typedef struct FILE FILE;\n+typedef __builtin_va_list va_list;\n+\n+extern int printf (const char *, ...);\n+extern int printf_unlocked (const char *, ...);\n+extern int vprintf (const char *, va_list);\n+\n+extern int fprintf (FILE*, const char *, ...);\n+extern int fprintf_unlocked (FILE*, const char *, ...);\n+extern int vfprintf (FILE*, const char *, va_list);\n+\n+#define fprintf_chk    __builtin___fprintf_chk\n+#define printf_chk     __builtin___printf_chk\n+#define vfprintf_chk   __builtin___vfprintf_chk\n+#define vprintf_chk    __builtin___vprintf_chk\n+\n+#define CAT(s, n)   s ## n\n+\n+#define KEEP(func, line)   CAT (func ## _test_on_line_, line)\n+\n+/* Emit one call to a function named call_on_line_NNN when the result\n+   of the call FUNC ARGS is less than zero, zero, or greater than zero.\n+   This verifies that the expression is not eliminated.\n+\n+   For known output it is possible to bound the return value to\n+   [INT_MIN, -1] U [0, N] with N being the size of the output, but\n+   that optimization isn't implemented (yet).  */\n+\n+#define T(func, args)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    extern void KEEP (func, __LINE__)(const char*);\t\t\\\n+    if ((func args) < 0) KEEP (func, __LINE__)(\"< 0\");\t\t\\\n+    if ((func args) >= 0) KEEP (func, __LINE__)(\">= 0\");\t\\\n+  } while (0)\n+\n+void test_fprintf (FILE *f, const char *s)\n+{\n+  /* Here the result is in [INT_MIN, 0], i.e., it cannot be positive.\n+     It might be a useful enhancement to implement this optimization.  */\n+  T (fprintf, (f, \"\"));\n+  T (fprintf, (f, \"1\"));\n+  T (fprintf, (f, \"123\"));\n+  T (fprintf, (f, s));\n+\n+  T (fprintf, (f, \"%c\", 0));\n+  T (fprintf, (f, \"%c\", '1'));\n+  T (fprintf, (f, \"%c\", *s));\n+\n+  T (fprintf, (f, \"%s\", \"\"));\n+  T (fprintf, (f, \"%s\", \"1\"));\n+  T (fprintf, (f, \"%.0s\", \"\"));\n+  T (fprintf, (f, \"%.0s\", s));\n+\n+  /* { dg-final { scan-tree-dump-times \" fprintf_test_on_line_\" 22 \"optimized\"} } */\n+}\n+\n+\n+void test_fprintf_unlocked (FILE *f, const char *s)\n+{\n+  T (fprintf_unlocked, (f, \"\"));\n+  T (fprintf_unlocked, (f, \"1\"));\n+  T (fprintf_unlocked, (f, \"123\"));\n+  T (fprintf_unlocked, (f, s));\n+\n+  T (fprintf_unlocked, (f, \"%c\", 0));\n+  T (fprintf_unlocked, (f, \"%c\", '1'));\n+  T (fprintf_unlocked, (f, \"%c\", *s));\n+\n+  T (fprintf_unlocked, (f, \"%s\", \"\"));\n+  T (fprintf_unlocked, (f, \"%s\", \"1\"));\n+  T (fprintf_unlocked, (f, \"%.0s\", \"\"));\n+  T (fprintf_unlocked, (f, \"%.0s\", s));\n+\n+  /* { dg-final { scan-tree-dump-times \" fprintf_unlocked_test_on_line_\" 22 \"optimized\"} } */\n+}\n+\n+\n+void test_fprintf_chk (FILE *f, const char *s)\n+{\n+  T (fprintf_chk, (f, 0, \"\"));\n+  T (fprintf_chk, (f, 0, \"1\"));\n+  T (fprintf_chk, (f, 0, \"123\"));\n+  T (fprintf_chk, (f, 0, s));\n+\n+  T (fprintf_chk, (f, 0, \"%c\", 0));\n+  T (fprintf_chk, (f, 0, \"%c\", '1'));\n+  T (fprintf_chk, (f, 0, \"%c\", *s));\n+\n+  T (fprintf_chk, (f, 0, \"%s\", \"\"));\n+  T (fprintf_chk, (f, 0, \"%s\", \"1\"));\n+  T (fprintf_chk, (f, 0, \"%.0s\", \"\"));\n+  T (fprintf_chk, (f, 0, \"%.0s\", s));\n+\n+  /* { dg-final { scan-tree-dump-times \" __builtin___fprintf_chk_test_on_line_\" 22 \"optimized\"} } */\n+}\n+\n+\n+void test_vfprintf (FILE *f, va_list va)\n+{\n+  T (vfprintf, (f, \"\", va));\n+  T (vfprintf, (f, \"123\", va));\n+\n+  T (vfprintf, (f, \"%c\", va));\n+\n+  T (vfprintf, (f, \"%.0s\", va));\n+\n+  /* { dg-final { scan-tree-dump-times \" vfprintf_test_on_line_\" 8 \"optimized\"} } */\n+}\n+\n+\n+void test_vfprintf_chk (FILE *f, va_list va)\n+{\n+  T (vfprintf_chk, (f, 0, \"\", va));\n+  T (vfprintf_chk, (f, 0, \"123\", va));\n+\n+  T (vfprintf_chk, (f, 0, \"%c\", va));\n+\n+  T (vfprintf_chk, (f, 0, \"%.0s\", va));\n+\n+  /* { dg-final { scan-tree-dump-times \" __builtin___vfprintf_chk_test_on_line_\" 8 \"optimized\"} } */\n+}\n+\n+\n+void test_printf (const char *s)\n+{\n+  T (printf, (\"\"));\n+  T (printf, (\"1\"));\n+  T (printf, (\"123\"));\n+  T (printf, (s));\n+\n+  T (printf, (\"%c\", 0));\n+  T (printf, (\"%c\", '1'));\n+  T (printf, (\"%c\", *s));\n+\n+  T (printf, (\"%s\", \"\"));\n+  T (printf, (\"%s\", \"1\"));\n+  T (printf, (\"%.0s\", \"\"));\n+  T (printf, (\"%.0s\", s));\n+\n+/* { dg-final { scan-tree-dump-times \" printf_test_on_line_\" 22 \"optimized\"} } */\n+}\n+\n+\n+void test_printf_unlocked (const char *s)\n+{\n+  T (printf_unlocked, (\"\"));\n+  T (printf_unlocked, (\"1\"));\n+  T (printf_unlocked, (\"123\"));\n+  T (printf_unlocked, (s));\n+\n+  T (printf_unlocked, (\"%c\", 0));\n+  T (printf_unlocked, (\"%c\", '1'));\n+  T (printf_unlocked, (\"%c\", *s));\n+\n+  T (printf_unlocked, (\"%s\", \"\"));\n+  T (printf_unlocked, (\"%s\", \"1\"));\n+  T (printf_unlocked, (\"%.0s\", \"\"));\n+  T (printf_unlocked, (\"%.0s\", s));\n+\n+/* { dg-final { scan-tree-dump-times \" printf_unlocked_test_on_line_\" 22 \"optimized\"} } */\n+}\n+\n+\n+void test_printf_chk (const char *s)\n+{\n+  T (printf_chk, (0, \"\"));\n+  T (printf_chk, (0, \"1\"));\n+  T (printf_chk, (0, \"123\"));\n+  T (printf_chk, (0, s));\n+\n+  T (printf_chk, (0, \"%c\", 0));\n+  T (printf_chk, (0, \"%c\", '1'));\n+  T (printf_chk, (0, \"%c\", *s));\n+\n+  T (printf_chk, (0, \"%s\", \"\"));\n+  T (printf_chk, (0, \"%s\", \"1\"));\n+  T (printf_chk, (0, \"%.0s\", \"\"));\n+  T (printf_chk, (0, \"%.0s\", s));\n+\n+/* { dg-final { scan-tree-dump-times \" __builtin___printf_chk_test_on_line_\" 22 \"optimized\"} } */\n+}\n+\n+\n+void test_vprintf (va_list va)\n+{\n+  T (vprintf, (\"\", va));\n+  T (vprintf, (\"123\", va));\n+\n+  T (vprintf, (\"%c\", va));\n+\n+  T (vprintf, (\"%.0s\", va));\n+\n+  /* { dg-final { scan-tree-dump-times \" vprintf_test_on_line_\" 8 \"optimized\"} } */\n+}\n+\n+\n+void test_vprintf_chk (va_list va)\n+{\n+  T (vprintf_chk, (0, \"\", va));\n+  T (vprintf_chk, (0, \"123\", va));\n+\n+  T (vprintf_chk, (0, \"%c\", va));\n+\n+  T (vprintf_chk, (0, \"%.0s\", va));\n+\n+  /* { dg-final { scan-tree-dump-times \" __builtin___vprintf_chk_test_on_line_\" 8 \"optimized\"} } */\n+}"}, {"sha": "31a5bd3e9b075b3e37ae8409228dce4b6011998e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-printf-warn-1.c", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-warn-1.c?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -0,0 +1,129 @@\n+/* PR middle-end/87041 - -Wformat \"reading through null pointer\" on\n+   unreachable code\n+   Test to verify that the applicable subset of -Wformat-overflow warnings\n+   are issued for the printf function.\n+   { dg-do compile }\n+   { dg-options \"-O -Wformat -Wformat-overflow=1 -ftrack-macro-expansion=0\" }\n+   { dg-require-effective-target int32plus } */\n+\n+/* When debugging, define LINE to the line number of the test case to exercise\n+   and avoid exercising any of the others.  The buffer and objsize macros\n+   below make use of LINE to avoid warnings for other lines.  */\n+#ifndef LINE\n+# define LINE 0\n+#endif\n+\n+#define INT_MAX __INT_MAX__\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#if !__cplusplus\n+typedef __WCHAR_TYPE__ wchar_t;\n+#endif\n+\n+typedef __WINT_TYPE__ wint_t;\n+\n+typedef unsigned char UChar;\n+\n+void sink (void*, ...);\n+\n+int dummy_printf (const char*, ...);\n+\n+const char chr_no_nul = 'a';\n+const char arr_no_nul[] = { 'a', 'b' };\n+\n+\n+/* Helper to expand function to either __builtin_f or dummy_f to\n+   make debugging GCC easy.  */\n+#define T(...)\t\t\t\t\t\t\t\\\n+  (((!LINE || LINE == __LINE__)\t\t\t\t\t\\\n+    ? __builtin_printf : dummy_printf) (__VA_ARGS__))\n+\n+/* Exercise the \"%c\" directive with constant arguments.  */\n+\n+void test_printf_c_const (int width)\n+{\n+  /* Verify that a warning is issued for exceeding INT_MAX bytes and\n+     not otherwise.  */\n+  T (\"%*c\",  INT_MAX - 1, '1');\n+  T (\"%*c\",  INT_MAX,     '1');\n+  T (\"X%*c\", INT_MAX - 1, '1');\n+  T (\"X%*c\", INT_MAX,     '1');   /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  T (\"%*c%*c\", INT_MAX - 1, '1', INT_MAX - 1, '2'); /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  T (\"%*cX\", INT_MAX - 2, '1');\n+  T (\"%*cX\", INT_MAX - 1, '1');\n+  T (\"%*cX\", INT_MAX,     '1');   /* { dg-warning \"output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  if (width < INT_MAX - 1)\n+    width = INT_MAX - 1;\n+  T (\"%*cX\", width, '1');\n+  T (\"%*cXY\", width, '1');        /* { dg-warning \".XY. directive output of 2 bytes causes result to exceed .INT_MAX.\" } */\n+\n+  /* Also exercise a non-constant format string.  The warning points\n+     to the line where the format is declared (see bug 87773) so avoid\n+     triggering that bug here.  */\n+  const char *fmt = \"%*cXYZ\";  T (fmt, width, '1');            /* { dg-warning \".XYZ. directive output of 3 bytes causes result to exceed .INT_MAX.\" } */\n+}\n+\n+\n+/* Exercise the \"%s\" directive with constant arguments.  */\n+\n+void test_printf_s_const (int width)\n+{\n+  const char *nulptr = 0;\n+\n+  T (\"%s\", nulptr);               /* { dg-warning \"\\\\\\[-Wformat|-Wnonnull]\" } */\n+  T (\"%.0s\", nulptr);             /* { dg-warning \".%.0s. directive argument is null\" } */\n+\n+  /* Verify no warning is issued for unreachable code.  */\n+  if (nulptr)\n+    T (\"%s\", nulptr);\n+\n+  T (\"%s\", &chr_no_nul);          /* { dg-warning \".%s. directive argument is not a nul-terminated string\" \"pr87756\" { xfail *-*-* } } */\n+  T (\"%s\", arr_no_nul);           /* { dg-warning \".%s. directive argument is not a nul-terminated string\" } */\n+\n+  /* Verify that output in excess of INT_MAX bytes is diagnosed even\n+     when the size of the destination object is unknown.  */\n+  T (\"%*s\",  INT_MAX - 1, \"\");\n+  T (\"%*s\",  INT_MAX,     \"\");\n+  T (\"X%*s\", INT_MAX,     \"\");    /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  if (width < INT_MAX - 1)\n+    width = INT_MAX - 1;\n+  T (\"%*sX\", width, \"1\");\n+  T (\"%*sXY\", width, \"1\");        /* { dg-warning \".XY. directive output of 2 bytes causes result to exceed .INT_MAX.\" } */\n+}\n+\n+\n+const wchar_t wchr_no_nul = L'a';\n+const wchar_t warr_no_nul[] = { L'a', L'b' };\n+\n+/* Exercise the \"%s\" directive with constant arguments.  */\n+\n+void test_printf_ls_const (int width)\n+{\n+  const wchar_t *nulptr = 0;\n+\n+  T (\"%ls\", nulptr);              /* { dg-warning \".%ls. directive argument is null\" } */\n+  T (\"%.0ls\", nulptr);            /* { dg-warning \".%.0ls. directive argument is null\" } */\n+\n+  /* Verify no warning is issued for unreachable code.  */\n+  if (nulptr)\n+    T (\"%ls\", nulptr);\n+\n+  T (\"%ls\", &wchr_no_nul);        /* { dg-warning \".%ls. directive argument is not a nul-terminated string\" \"pr87756\" { xfail *-*-* } } */\n+  T (\"%ls\", warr_no_nul);         /* { dg-warning \".%ls. directive argument is not a nul-terminated string\" \"pr87756\" { xfail *-*-* } } */\n+\n+  /* Verify that output in excess of INT_MAX bytes is diagnosed even\n+     when the size of the destination object is unknown.  */\n+  T (\"%*ls\",  INT_MAX - 1, L\"\");\n+  T (\"%*ls\",  INT_MAX,     L\"\");\n+  T (\"X%*ls\", INT_MAX,     L\"\");  /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  if (width < INT_MAX - 1)\n+    width = INT_MAX - 1;\n+  T (\"%*lsX\", width, L\"1\");\n+  T (\"%*lsXY\", width, L\"1\");      /* { dg-warning \".XY. directive output of 2 bytes causes result to exceed .INT_MAX.\" } */\n+}"}, {"sha": "4788b02025fa04ca401978ae570a49689d678f86", "filename": "gcc/testsuite/gcc.dg/tree-ssa/user-printf-warn-1.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fuser-printf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e3ec29af2b20d26a97b4b80c88eac9ad95e011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fuser-printf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fuser-printf-warn-1.c?ref=91e3ec29af2b20d26a97b4b80c88eac9ad95e011", "patch": "@@ -0,0 +1,155 @@\n+/* PR middle-end/87041 - -Wformat \"reading through null pointer\" on\n+   unreachable code\n+   Test to verify that the applicable subset of -Wformat-overflow warnings\n+   are issued for user-defined function declared attribute format printf.\n+   { dg-do compile }\n+   { dg-options \"-O -Wformat -Wformat-overflow=1 -ftrack-macro-expansion=0\" }\n+   { dg-require-effective-target int32plus } */\n+\n+/* When debugging, define LINE to the line number of the test case to exercise\n+   and avoid exercising any of the others.  The buffer and objsize macros\n+   below make use of LINE to avoid warnings for other lines.  */\n+#ifndef LINE\n+# define LINE 0\n+#endif\n+\n+#define INT_MAX __INT_MAX__\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#if !__cplusplus\n+typedef __WCHAR_TYPE__ wchar_t;\n+#endif\n+\n+typedef __WINT_TYPE__ wint_t;\n+\n+ATTR (format (printf, 2, 3)) void\n+user_print (char*, const char*, ...);\n+\n+ATTR (format (printf, 2, 3), nonnull) void\n+user_print_nonnull (char*, const char*, ...);\n+\n+ATTR (format (printf, 2, 3), nonnull (2)) void\n+user_print_nonnull_fmt (char*, const char*, ...);\n+\n+ATTR (format (printf, 2, 4), nonnull (3)) void\n+user_print_nonnull_other (char*, const char*, char*, ...);\n+\n+void dummy_print (char*, const char*, ...);\n+\n+const char chr_no_nul = 'a';\n+const char arr_no_nul[] = { 'a', 'b' };\n+\n+\n+/* Helper to expand function to either __builtin_f or dummy_f to\n+   make debugging GCC easy.  */\n+#define T(...)\t\t\t\t\t\t\t\\\n+  (((!LINE || LINE == __LINE__)\t\t\t\t\t\\\n+    ? user_print : dummy_print) (0, __VA_ARGS__))\n+\n+/* Exercise the \"%c\" directive with constant arguments.  */\n+\n+void test_user_print_format_string (void)\n+{\n+  char *null = 0;\n+  /* Verify that no warning is issued for a null format string unless\n+     the corresponding parameter is declared nonnull.  */\n+  user_print (0, null);\n+  user_print_nonnull (\"x\", \"y\");\n+  user_print_nonnull (\"x\", null);   /* { dg-warning \"\\\\\\[-Wnonnull]\" } */\n+  user_print_nonnull_fmt (null, \"x\");\n+  user_print_nonnull_fmt (0, null); /* { dg-warning \"\\\\\\[-Wnonnull]\" } */\n+  user_print_nonnull_other (null, \"x\", \"y\");\n+  user_print_nonnull_other (null, \"x\", null);  /* { dg-warning \"\\\\\\[-Wnonnull]\" } */\n+}\n+\n+\n+/* Exercise the \"%c\" directive with constant arguments.  */\n+\n+void test_user_print_c_const (int width)\n+{\n+  /* Verify that a warning is issued for exceeding INT_MAX bytes and\n+     not otherwise.  */\n+  T (\"%*c\",  INT_MAX - 1, '1');\n+  T (\"%*c\",  INT_MAX,     '1');\n+  T (\"X%*c\", INT_MAX - 1, '1');\n+  T (\"X%*c\", INT_MAX,     '1');   /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  T (\"%*c%*c\", INT_MAX - 1, '1', INT_MAX - 1, '2'); /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  T (\"%*cX\", INT_MAX - 2, '1');\n+  T (\"%*cX\", INT_MAX - 1, '1');\n+  T (\"%*cX\", INT_MAX,     '1');   /* { dg-warning \"output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  if (width < INT_MAX - 1)\n+    width = INT_MAX - 1;\n+  T (\"%*cX\", width, '1');\n+  T (\"%*cXY\", width, '1');        /* { dg-warning \".XY. directive output of 2 bytes causes result to exceed .INT_MAX.\" } */\n+\n+  /* Also exercise a non-constant format string.  The warning points\n+     to the line where the format is declared (see bug 87773) so avoid\n+     triggering that bug here.  */\n+  const char *fmt = \"%*cXYZ\";  T (fmt, width, '1');            /* { dg-warning \".XYZ. directive output of 3 bytes causes result to exceed .INT_MAX.\" } */\n+}\n+\n+\n+/* Exercise the \"%s\" directive with constant arguments.  */\n+\n+void test_user_print_s_const (int width)\n+{\n+  const char *null = 0;\n+\n+  T (\"%s\", null);                 /* { dg-warning \".%s. directive argument is null\" } */\n+  T (\"%.0s\", null);               /* { dg-warning \".%.0s. directive argument is null\" } */\n+\n+  /* Verify no warning is issued for unreachable code.  */\n+  if (null)\n+    T (\"%s\", null);\n+\n+  T (\"%s\", &chr_no_nul);          /* { dg-warning \".%s. directive argument is not a nul-terminated string\" \"pr87756\" { xfail *-*-* } } */\n+  T (\"%s\", arr_no_nul);           /* { dg-warning \".%s. directive argument is not a nul-terminated string\" } */\n+\n+  /* Verify that output in excess of INT_MAX bytes is diagnosed even\n+     when the size of the destination object is unknown.  */\n+  T (\"%*s\",  INT_MAX - 1, \"\");\n+  T (\"%*s\",  INT_MAX,     \"\");\n+  T (\"X%*s\", INT_MAX,     \"\");    /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  if (width < INT_MAX - 1)\n+    width = INT_MAX - 1;\n+  T (\"%*sX\", width, \"1\");\n+  T (\"%*sXY\", width, \"1\");        /* { dg-warning \".XY. directive output of 2 bytes causes result to exceed .INT_MAX.\" } */\n+}\n+\n+\n+const wchar_t wchr_no_nul = L'a';\n+const wchar_t warr_no_nul[] = { L'a', L'b' };\n+\n+/* Exercise the \"%s\" directive with constant arguments.  */\n+\n+void test_user_print_ls_const (int width)\n+{\n+  const wchar_t *null = 0;\n+\n+  T (\"%ls\", null);                /* { dg-warning \".%ls. directive argument is null\" } */\n+  T (\"%.0ls\", null);              /* { dg-warning \".%.0ls. directive argument is null\" } */\n+\n+  /* Verify no warning is issued for unreachable code.  */\n+  if (null)\n+    T (\"%ls\", null);\n+\n+  T (\"%ls\", &wchr_no_nul);        /* { dg-warning \".%ls. directive argument is not a nul-terminated string\" \"pr87756\" { xfail *-*-* } } */\n+  T (\"%ls\", warr_no_nul);         /* { dg-warning \".%ls. directive argument is not a nul-terminated string\" \"pr87756\" { xfail *-*-* } } */\n+\n+  /* Verify that output in excess of INT_MAX bytes is diagnosed even\n+     when the size of the destination object is unknown.  */\n+  T (\"%*ls\",  INT_MAX - 1, L\"\");\n+  T (\"%*ls\",  INT_MAX,     L\"\");\n+  T (\"X%*ls\", INT_MAX,     L\"\");  /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  if (width < INT_MAX - 1)\n+    width = INT_MAX - 1;\n+  T (\"%*lsX\", width, L\"1\");\n+  T (\"%*lsXY\", width, L\"1\");      /* { dg-warning \".XY. directive output of 2 bytes causes result to exceed .INT_MAX.\" } */\n+}"}]}