{"sha": "30a8f67295f4123fd7cb740c6927592bccb0e7c5", "node_id": "C_kwDOANBUbNoAKDMwYThmNjcyOTVmNDEyM2ZkN2NiNzQwYzY5Mjc1OTJiY2NiMGU3YzU", "commit": {"author": {"name": "Joel Brobecker", "email": "brobecker@adacore.com", "date": "2022-06-23T12:12:12Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-06-27T10:08:17Z"}, "message": "libstdc++: testsuite: avoid predicable mkstemp\n\nWe have noticed that, on RTEMS, a small number of testscases are\nfailing because two calls to this method return the same filename.\nThis happens for instance in 27_io/filesystem/operations/copy_file.cc\nwhere it does:\n\n  auto from = __gnu_test::nonexistent_path();\n  auto to = __gnu_test::nonexistent_path();\n\nWe tracked this issue down to the fact that the implementation of\nmkstemp on that system appears to use a very predictable algorithm\nfor chosing the name of the temporary file, where the same filename\nappears to be tried in the same order, regardless of past calls.\nSo, as long as the file gets deleted after a call to mkstemp (something\nwe do here in our nonexistent_path method), the next call to mkstemps\nends up returning the same filename, causing the collision we se above.\n\nThis commit enhances the __gnu_test::nonexistent_path method to\nintroduce in the filename being returned a counter which gets\nincremented at every call of this method.\n\nCo-authored-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/util/testsuite_fs.h (__gnu_test::nonexistent_path):\n\tAlways include a counter in the filename returned.", "tree": {"sha": "3be8d6b7a927c1350ac302966279bc124014b767", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3be8d6b7a927c1350ac302966279bc124014b767"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30a8f67295f4123fd7cb740c6927592bccb0e7c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30a8f67295f4123fd7cb740c6927592bccb0e7c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30a8f67295f4123fd7cb740c6927592bccb0e7c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30a8f67295f4123fd7cb740c6927592bccb0e7c5/comments", "author": {"login": "brobecke", "id": 11981700, "node_id": "MDQ6VXNlcjExOTgxNzAw", "avatar_url": "https://avatars.githubusercontent.com/u/11981700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brobecke", "html_url": "https://github.com/brobecke", "followers_url": "https://api.github.com/users/brobecke/followers", "following_url": "https://api.github.com/users/brobecke/following{/other_user}", "gists_url": "https://api.github.com/users/brobecke/gists{/gist_id}", "starred_url": "https://api.github.com/users/brobecke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brobecke/subscriptions", "organizations_url": "https://api.github.com/users/brobecke/orgs", "repos_url": "https://api.github.com/users/brobecke/repos", "events_url": "https://api.github.com/users/brobecke/events{/privacy}", "received_events_url": "https://api.github.com/users/brobecke/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a364488f7a70ebf6c1fd59fed9f6a8a477591087", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a364488f7a70ebf6c1fd59fed9f6a8a477591087", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a364488f7a70ebf6c1fd59fed9f6a8a477591087"}], "stats": {"total": 57, "additions": 38, "deletions": 19}, "files": [{"sha": "908fcdbcaeed1bc8096a69b19818c4275587df6c", "filename": "libstdc++-v3/testsuite/util/testsuite_fs.h", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30a8f67295f4123fd7cb740c6927592bccb0e7c5/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30a8f67295f4123fd7cb740c6927592bccb0e7c5/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h?ref=30a8f67295f4123fd7cb740c6927592bccb0e7c5", "patch": "@@ -32,14 +32,14 @@ namespace test_fs = std::experimental::filesystem;\n #endif\n #include <algorithm>\n #include <fstream>\n+#include <random>   // std::random_device\n #include <string>\n+#include <system_error>\n #include <cstdio>\n #include <unistd.h> // unlink, close, getpid, geteuid\n \n #if defined(_GNU_SOURCE) || _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200112L\n #include <stdlib.h> // mkstemp\n-#else\n-#include <random>   // std::random_device\n #endif\n \n #ifndef _GLIBCXX_HAVE_SYMLINK\n@@ -123,32 +123,51 @@ namespace __gnu_test\n     if (pos != file.npos)\n       file.erase(0, pos+1);\n \n+    file.reserve(file.size() + 40);\n+    file.insert(0, \"filesystem-test.\");\n+\n+    // A counter, starting from a random value, to be included as part\n+    // of the filename being returned, and incremented each time\n+    // this function is used.  It allows us to ensure that two calls\n+    // to this function can never return the same filename, something\n+    // testcases do when they need multiple non-existent filenames\n+    // for their purposes.\n+    static unsigned counter = std::random_device{}();\n+    file += '.';\n+    file += std::to_string(counter++);\n+    file += '.';\n+\n     test_fs::path p;\n #if defined(_GNU_SOURCE) || _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200112L\n-    char tmp[] = \"filesystem-test.XXXXXX\";\n-    int fd = ::mkstemp(tmp);\n+\n+    // Use mkstemp to determine the name of a file which does not exist yet.\n+    //\n+    // Note that we have seen on some systems (such as RTEMS, for instance)\n+    // that mkstemp behaves very predictably, causing it to always try\n+    // the same sequence of file names.  In other words, if we call mkstemp\n+    // with a pattern, delete the file it created (which is what we do, here),\n+    // and call mkstemp with the same pattern again, it returns the same\n+    // filename once more.  While most implementations introduce a degree\n+    // of randomness, it is not mandated by the standard, and this is why\n+    // we also include a counter in the template passed to mkstemp.\n+    file += \"XXXXXX\";\n+    int fd = ::mkstemp(&file[0]);\n     if (fd == -1)\n       throw test_fs::filesystem_error(\"mkstemp failed\",\n \t  std::error_code(errno, std::generic_category()));\n-    ::unlink(tmp);\n+    ::unlink(file.c_str());\n     ::close(fd);\n-    if (!file.empty())\n-      file.insert(0, 1, '-');\n-    file.insert(0, tmp);\n-    p = file;\n+    p = std::move(file);\n #else\n     if (file.length() > 64)\n       file.resize(64);\n-    char buf[128];\n-    static unsigned counter = std::random_device{}();\n-#if _GLIBCXX_USE_C99_STDIO\n-    std::snprintf(buf, 128,\n-#else\n-    std::sprintf(buf,\n-#endif\n-      \"filesystem-test.%u.%lu-%s\", counter++, (unsigned long) ::getpid(),\n-      file.c_str());\n-    p = buf;\n+    // The combination of random counter and PID should be unique for a given\n+    // run of the testsuite.\n+    file += std::to_string(::getpid());\n+    p = std::move(file);\n+    if (test_fs::exists(p))\n+      throw test_fs::filesystem_error(\"Failed to generate unique pathname\", p,\n+\t  std::make_error_code(std::errc::file_exists));\n #endif\n     return p;\n   }"}]}