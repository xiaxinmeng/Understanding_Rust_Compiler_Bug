{"sha": "6bda9bdf522dc14c5deff16d364b19d1095d8a33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJkYTliZGY1MjJkYzE0YzVkZWZmMTZkMzY0YjE5ZDEwOTVkOGEzMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-11-26T21:35:35Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-11-26T21:35:35Z"}, "message": "re PR rtl-optimization/38582 (excessive time in rename registers)\n\n\tPR rtl-opt/38582\n\t* regrename.c (struct du_chain): Remove member earlyclobber.\n\t(scan_rtx_reg): Don't set it.  Remove argument earlyclobber,\n\tall callers changed.\n\t(scan_rtx): Remove argument earlyclobber, all callers changed.\n\t(hide_operands, restore_operands, record_out_operands): New functions,\n\tbroken out of build_def_use.\n\t(build_def_use): Call them as necessary.\n\nFrom-SVN: r154687", "tree": {"sha": "fb1c9327efe96a24e54b38bf9d4fc812d8212f38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb1c9327efe96a24e54b38bf9d4fc812d8212f38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bda9bdf522dc14c5deff16d364b19d1095d8a33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bda9bdf522dc14c5deff16d364b19d1095d8a33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bda9bdf522dc14c5deff16d364b19d1095d8a33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bda9bdf522dc14c5deff16d364b19d1095d8a33/comments", "author": null, "committer": null, "parents": [{"sha": "c5c39ab37a0a4280456eb82b36dcf4e6a42ad7e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5c39ab37a0a4280456eb82b36dcf4e6a42ad7e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5c39ab37a0a4280456eb82b36dcf4e6a42ad7e8"}], "stats": {"total": 245, "additions": 135, "deletions": 110}, "files": [{"sha": "8ba23e98076e6bc757c5ff3b489ea3049f80affb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bda9bdf522dc14c5deff16d364b19d1095d8a33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bda9bdf522dc14c5deff16d364b19d1095d8a33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6bda9bdf522dc14c5deff16d364b19d1095d8a33", "patch": "@@ -1,3 +1,14 @@\n+2009-11-26  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\tPR rtl-opt/38582\n+\t* regrename.c (struct du_chain): Remove member earlyclobber.\n+\t(scan_rtx_reg): Don't set it.  Remove argument earlyclobber,\n+\tall callers changed.\n+\t(scan_rtx): Remove argument earlyclobber, all callers changed.\n+\t(hide_operands, restore_operands, record_out_operands): New functions,\n+\tbroken out of build_def_use.\n+\t(build_def_use): Call them as necessary.\n+\n 2009-11-26  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-dce.c (nr_walks): New variable."}, {"sha": "f5c1414946ebd708c20aa0f021df1750fff5a74d", "filename": "gcc/regrename.c", "status": "modified", "additions": 124, "deletions": 110, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bda9bdf522dc14c5deff16d364b19d1095d8a33/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bda9bdf522dc14c5deff16d364b19d1095d8a33/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=6bda9bdf522dc14c5deff16d364b19d1095d8a33", "patch": "@@ -68,8 +68,6 @@ struct du_chain\n   rtx *loc;\n   /* The register class required by the insn at this location.  */\n   ENUM_BITFIELD(reg_class) cl : 16;\n-  /* Nonzero if the register is subject to earlyclobber.  */\n-  unsigned int earlyclobber:1;\n };\n \n enum scan_actions\n@@ -101,11 +99,11 @@ static struct obstack rename_obstack;\n \n static void do_replace (struct du_head *, int);\n static void scan_rtx_reg (rtx, rtx *, enum reg_class,\n-\t\t\t  enum scan_actions, enum op_type, int);\n+\t\t\t  enum scan_actions, enum op_type);\n static void scan_rtx_address (rtx, rtx *, enum reg_class,\n \t\t\t      enum scan_actions, enum machine_mode);\n static void scan_rtx (rtx, rtx *, enum reg_class, enum scan_actions,\n-\t\t      enum op_type, int);\n+\t\t      enum op_type);\n static struct du_head *build_def_use (basic_block);\n static void dump_def_use_chain (struct du_head *);\n static void note_sets (rtx, const_rtx, void *);\n@@ -431,8 +429,8 @@ static struct du_head *open_chains;\n static struct du_head *closed_chains;\n \n static void\n-scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n-\t      enum scan_actions action, enum op_type type, int earlyclobber)\n+scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n+\t      enum op_type type)\n {\n   struct du_head **p;\n   rtx x = *loc;\n@@ -458,7 +456,6 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \t  this_du->loc = loc;\n \t  this_du->insn = insn;\n \t  this_du->cl = cl;\n-\t  this_du->earlyclobber = earlyclobber;\n \t}\n       return;\n     }\n@@ -681,7 +678,7 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n       return;\n \n     case REG:\n-      scan_rtx_reg (insn, loc, cl, action, OP_IN, 0);\n+      scan_rtx_reg (insn, loc, cl, action, OP_IN);\n       return;\n \n     default:\n@@ -700,8 +697,8 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n }\n \n static void\n-scan_rtx (rtx insn, rtx *loc, enum reg_class cl,\n-\t  enum scan_actions action, enum op_type type, int earlyclobber)\n+scan_rtx (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n+\t  enum op_type type)\n {\n   const char *fmt;\n   rtx x = *loc;\n@@ -723,7 +720,7 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl,\n       return;\n \n     case REG:\n-      scan_rtx_reg (insn, loc, cl, action, type, earlyclobber);\n+      scan_rtx_reg (insn, loc, cl, action, type);\n       return;\n \n     case MEM:\n@@ -733,21 +730,21 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl,\n       return;\n \n     case SET:\n-      scan_rtx (insn, &SET_SRC (x), cl, action, OP_IN, 0);\n+      scan_rtx (insn, &SET_SRC (x), cl, action, OP_IN);\n       scan_rtx (insn, &SET_DEST (x), cl, action,\n-\t\tGET_CODE (PATTERN (insn)) == COND_EXEC ? OP_INOUT : OP_OUT, 0);\n+\t\tGET_CODE (PATTERN (insn)) == COND_EXEC ? OP_INOUT : OP_OUT);\n       return;\n \n     case STRICT_LOW_PART:\n-      scan_rtx (insn, &XEXP (x, 0), cl, action, OP_INOUT, earlyclobber);\n+      scan_rtx (insn, &XEXP (x, 0), cl, action, OP_INOUT);\n       return;\n \n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n       scan_rtx (insn, &XEXP (x, 0), cl, action,\n-\t\ttype == OP_IN ? OP_IN : OP_INOUT, earlyclobber);\n-      scan_rtx (insn, &XEXP (x, 1), cl, action, OP_IN, 0);\n-      scan_rtx (insn, &XEXP (x, 2), cl, action, OP_IN, 0);\n+\t\ttype == OP_IN ? OP_IN : OP_INOUT);\n+      scan_rtx (insn, &XEXP (x, 1), cl, action, OP_IN);\n+      scan_rtx (insn, &XEXP (x, 2), cl, action, OP_IN);\n       return;\n \n     case POST_INC:\n@@ -761,13 +758,13 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl,\n \n     case CLOBBER:\n       scan_rtx (insn, &SET_DEST (x), cl, action,\n-\t\tGET_CODE (PATTERN (insn)) == COND_EXEC ? OP_INOUT : OP_OUT, 0);\n+\t\tGET_CODE (PATTERN (insn)) == COND_EXEC ? OP_INOUT : OP_OUT);\n       return;\n \n     case EXPR_LIST:\n-      scan_rtx (insn, &XEXP (x, 0), cl, action, type, 0);\n+      scan_rtx (insn, &XEXP (x, 0), cl, action, type);\n       if (XEXP (x, 1))\n-\tscan_rtx (insn, &XEXP (x, 1), cl, action, type, 0);\n+\tscan_rtx (insn, &XEXP (x, 1), cl, action, type);\n       return;\n \n     default:\n@@ -778,10 +775,99 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl,\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tscan_rtx (insn, &XEXP (x, i), cl, action, type, 0);\n+\tscan_rtx (insn, &XEXP (x, i), cl, action, type);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  scan_rtx (insn, &XVECEXP (x, i, j), cl, action, type, 0);\n+\t  scan_rtx (insn, &XVECEXP (x, i, j), cl, action, type);\n+    }\n+}\n+\n+/* Hide operands of the current insn (of which there are N_OPS) by\n+   substituting cc0 for them.\n+   Previous values are stored in the OLD_OPERANDS and OLD_DUPS.\n+   If INOUT_ONLY is set, we only do this for OP_INOUT type operands.  */\n+\n+static void\n+hide_operands (int n_ops, rtx *old_operands, rtx *old_dups,\n+\t       bool inout_only)\n+{\n+  int i;\n+  for (i = 0; i < n_ops; i++)\n+    {\n+      old_operands[i] = recog_data.operand[i];\n+      /* Don't squash match_operator or match_parallel here, since\n+\t we don't know that all of the contained registers are\n+\t reachable by proper operands.  */\n+      if (recog_data.constraints[i][0] == '\\0')\n+\tcontinue;\n+      if (!inout_only || recog_data.operand_type[i] == OP_INOUT)\n+\t*recog_data.operand_loc[i] = cc0_rtx;\n+    }\n+  for (i = 0; i < recog_data.n_dups; i++)\n+    {\n+      int opn = recog_data.dup_num[i];\n+      old_dups[i] = *recog_data.dup_loc[i];\n+      if (!inout_only || recog_data.operand_type[opn] == OP_INOUT)\n+\t*recog_data.dup_loc[i] = cc0_rtx;\n+    }\n+}\n+\n+/* Undo the substitution performed by hide_operands.  INSN is the insn we\n+   are processing; the arguments are the same as in hide_operands.  */\n+\n+static void\n+restore_operands (rtx insn, int n_ops, rtx *old_operands, rtx *old_dups)\n+{\n+  int i;\n+  for (i = 0; i < recog_data.n_dups; i++)\n+    *recog_data.dup_loc[i] = old_dups[i];\n+  for (i = 0; i < n_ops; i++)\n+    *recog_data.operand_loc[i] = old_operands[i];\n+  if (recog_data.n_dups)\n+    df_insn_rescan (insn);\n+}\n+\n+/* For each output operand of INSN, call scan_rtx to create a new\n+   open chain.  */\n+\n+static void\n+record_out_operands (rtx insn)\n+{\n+  int n_ops = recog_data.n_operands;\n+  int alt = which_alternative;\n+\n+  int i;\n+\n+  for (i = 0; i < n_ops + recog_data.n_dups; i++)\n+    {\n+      int opn = i < n_ops ? i : recog_data.dup_num[i - n_ops];\n+      rtx *loc = (i < n_ops\n+\t\t  ? recog_data.operand_loc[opn]\n+\t\t  : recog_data.dup_loc[i - n_ops]);\n+      rtx op = *loc;\n+      enum reg_class cl = recog_op_alt[opn][alt].cl;\n+\n+      struct du_head *prev_open;\n+\n+      if (recog_data.operand_type[opn] != OP_OUT)\n+\tcontinue;\n+\n+      prev_open = open_chains;\n+      scan_rtx (insn, loc, cl, mark_write, OP_OUT);\n+\n+      /* ??? Many targets have output constraints on the SET_DEST\n+\t of a call insn, which is stupid, since these are certainly\n+\t ABI defined hard registers.  For these, and for asm operands\n+\t that originally referenced hard registers, we must record that\n+\t the chain cannot be renamed.  */\n+      if (CALL_P (insn)\n+\t  || (asm_noperands (PATTERN (insn)) > 0\n+\t      && REG_P (op)\n+\t      && REGNO (op) == ORIGINAL_REGNO (op)))\n+\t{\n+\t  if (prev_open != open_chains)\n+\t    open_chains->first->cl = NO_REGS;\n+\t}\n     }\n }\n \n@@ -849,42 +935,21 @@ build_def_use (basic_block bb)\n \t  for (i = 0; i < n_ops; i++)\n \t    scan_rtx (insn, recog_data.operand_loc[i],\n \t\t      NO_REGS, terminate_overlapping_read,\n-\t\t      recog_data.operand_type[i], 0);\n+\t\t      recog_data.operand_type[i]);\n \n \t  /* Step 2: Close chains for which we have reads outside operands.\n \t     We do this by munging all operands into CC0, and closing\n \t     everything remaining.  */\n \n-\t  for (i = 0; i < n_ops; i++)\n-\t    {\n-\t      old_operands[i] = recog_data.operand[i];\n-\t      /* Don't squash match_operator or match_parallel here, since\n-\t\t we don't know that all of the contained registers are\n-\t\t reachable by proper operands.  */\n-\t      if (recog_data.constraints[i][0] == '\\0')\n-\t\tcontinue;\n-\t      *recog_data.operand_loc[i] = cc0_rtx;\n-\t    }\n-\t  for (i = 0; i < recog_data.n_dups; i++)\n-\t    {\n-\t      old_dups[i] = *recog_data.dup_loc[i];\n-\t      *recog_data.dup_loc[i] = cc0_rtx;\n-\t    }\n-\n+\t  hide_operands (n_ops, old_operands, old_dups, false);\n \t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_all_read,\n-\t\t    OP_IN, 0);\n-\n-\t  for (i = 0; i < recog_data.n_dups; i++)\n-\t    *recog_data.dup_loc[i] = old_dups[i];\n-\t  for (i = 0; i < n_ops; i++)\n-\t    *recog_data.operand_loc[i] = old_operands[i];\n-\t  if (recog_data.n_dups)\n-\t    df_insn_rescan (insn);\n+\t\t    OP_IN);\n+\t  restore_operands (insn, n_ops, old_operands, old_dups);\n \n \t  /* Step 2B: Can't rename function call argument registers.  */\n \t  if (CALL_P (insn) && CALL_INSN_FUNCTION_USAGE (insn))\n \t    scan_rtx (insn, &CALL_INSN_FUNCTION_USAGE (insn),\n-\t\t      NO_REGS, terminate_all_read, OP_IN, 0);\n+\t\t      NO_REGS, terminate_all_read, OP_IN);\n \n \t  /* Step 2C: Can't rename asm operands that were originally\n \t     hard registers.  */\n@@ -898,7 +963,7 @@ build_def_use (basic_block bb)\n \t\t    && REGNO (op) == ORIGINAL_REGNO (op)\n \t\t    && (recog_data.operand_type[i] == OP_IN\n \t\t\t|| recog_data.operand_type[i] == OP_INOUT))\n-\t\t  scan_rtx (insn, loc, NO_REGS, terminate_all_read, OP_IN, 0);\n+\t\t  scan_rtx (insn, loc, NO_REGS, terminate_all_read, OP_IN);\n \t      }\n \n \t  /* Step 3: Append to chains for reads inside operands.  */\n@@ -920,7 +985,7 @@ build_def_use (basic_block bb)\n \t      if (recog_op_alt[opn][alt].is_address)\n \t\tscan_rtx_address (insn, loc, cl, mark_read, VOIDmode);\n \t      else\n-\t\tscan_rtx (insn, loc, cl, mark_read, type, 0);\n+\t\tscan_rtx (insn, loc, cl, mark_read, type);\n \t    }\n \n \t  /* Step 3B: Record updates for regs in REG_INC notes, and\n@@ -929,13 +994,13 @@ build_def_use (basic_block bb)\n \t    if (REG_NOTE_KIND (note) == REG_INC\n \t\t|| REG_NOTE_KIND (note) == REG_FRAME_RELATED_EXPR)\n \t      scan_rtx (insn, &XEXP (note, 0), ALL_REGS, mark_read,\n-\t\t\tOP_INOUT, 0);\n+\t\t\tOP_INOUT);\n \n \t  /* Step 4: Close chains for registers that die here.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_DEAD)\n \t      scan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead,\n-\t\t\tOP_IN, 0);\n+\t\t\tOP_IN);\n \n \t  /* Step 4B: If this is a call, any chain live at this point\n \t     requires a caller-saved reg.  */\n@@ -950,83 +1015,32 @@ build_def_use (basic_block bb)\n \t     step 2, we hide in-out operands, since we do not want to\n \t     close these chains.  */\n \n-\t  for (i = 0; i < n_ops; i++)\n-\t    {\n-\t      old_operands[i] = recog_data.operand[i];\n-\t      if (recog_data.operand_type[i] == OP_INOUT)\n-\t\t*recog_data.operand_loc[i] = cc0_rtx;\n-\t    }\n-\t  for (i = 0; i < recog_data.n_dups; i++)\n-\t    {\n-\t      int opn = recog_data.dup_num[i];\n-\t      old_dups[i] = *recog_data.dup_loc[i];\n-\t      if (recog_data.operand_type[opn] == OP_INOUT)\n-\t\t*recog_data.dup_loc[i] = cc0_rtx;\n-\t    }\n-\n-\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_write, OP_IN, 0);\n-\n-\t  for (i = 0; i < recog_data.n_dups; i++)\n-\t    *recog_data.dup_loc[i] = old_dups[i];\n-\t  for (i = 0; i < n_ops; i++)\n-\t    *recog_data.operand_loc[i] = old_operands[i];\n+\t  hide_operands (n_ops, old_operands, old_dups, true);\n+\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_write, OP_IN);\n+\t  restore_operands (insn, n_ops, old_operands, old_dups);\n \n \t  /* Step 6: Begin new chains for writes inside operands.  */\n-\t  /* ??? Many targets have output constraints on the SET_DEST\n-\t     of a call insn, which is stupid, since these are certainly\n-\t     ABI defined hard registers.  Don't change calls at all.\n-\t     Similarly take special care for asm statement that originally\n-\t     referenced hard registers.  */\n-\t  if (asm_noperands (PATTERN (insn)) > 0)\n-\t    {\n-\t      for (i = 0; i < n_ops; i++)\n-\t\tif (recog_data.operand_type[i] == OP_OUT)\n-\t\t  {\n-\t\t    rtx *loc = recog_data.operand_loc[i];\n-\t\t    rtx op = *loc;\n-\t\t    enum reg_class cl = recog_op_alt[i][alt].cl;\n-\n-\t\t    if (REG_P (op)\n-\t\t\t&& REGNO (op) == ORIGINAL_REGNO (op))\n-\t\t      continue;\n-\n-\t\t    scan_rtx (insn, loc, cl, mark_write, OP_OUT,\n-\t\t\t      recog_op_alt[i][alt].earlyclobber);\n-\t\t  }\n-\t    }\n-\t  else if (!CALL_P (insn))\n-\t    for (i = 0; i < n_ops + recog_data.n_dups; i++)\n-\t      {\n-\t\tint opn = i < n_ops ? i : recog_data.dup_num[i - n_ops];\n-\t\trtx *loc = (i < n_ops\n-\t\t\t    ? recog_data.operand_loc[opn]\n-\t\t\t    : recog_data.dup_loc[i - n_ops]);\n-\t\tenum reg_class cl = recog_op_alt[opn][alt].cl;\n-\n-\t\tif (recog_data.operand_type[opn] == OP_OUT)\n-\t\t  scan_rtx (insn, loc, cl, mark_write, OP_OUT,\n-\t\t\t    recog_op_alt[opn][alt].earlyclobber);\n-\t      }\n+\t  record_out_operands (insn);\n \n \t  /* Step 6B: Record destination regs in REG_FRAME_RELATED_EXPR\n \t     notes for update.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_FRAME_RELATED_EXPR)\n \t      scan_rtx (insn, &XEXP (note, 0), ALL_REGS, mark_access,\n-\t\t\tOP_INOUT, 0);\n+\t\t\tOP_INOUT);\n \n \t  /* Step 7: Close chains for registers that were never\n \t     really used here.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_UNUSED)\n \t      scan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead,\n-\t\t\tOP_IN, 0);\n+\t\t\tOP_IN);\n \t}\n       else if (DEBUG_INSN_P (insn)\n \t       && !VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (insn)))\n \t{\n \t  scan_rtx (insn, &INSN_VAR_LOCATION_LOC (insn),\n-\t\t    ALL_REGS, mark_read, OP_IN, 0);\n+\t\t    ALL_REGS, mark_read, OP_IN);\n \t}\n       if (insn == BB_END (bb))\n \tbreak;"}]}