{"sha": "f38df0e11608009b95e0332b9fbab26eb593095c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM4ZGYwZTExNjA4MDA5Yjk1ZTAzMzJiOWZiYWIyNmViNTkzMDk1Yw==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2007-06-06T10:29:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:29:21Z"}, "message": "g-debpoo.ads, [...] (Free_Physically.Free_Blocks): Use the absolute value of Header.Block_Size when...\n\n2007-04-20  Vincent Celier  <celier@adacore.com>\n\t    Emmanuel Briot  <briot@adacore.com>\n\t    Olivier Hainque  <hainque@adacore.com>\n\n\t* g-debpoo.ads, g-debpoo.adb (Free_Physically.Free_Blocks): Use the\n\tabsolute value of Header.Block_Size when displaying the freed physical\n\tmemory in traces.\n\t(Allocate): Compute Storage_Address using Integer_Address, not\n\tStorage_Offset, because the range of Storage_Offset may not be large\n\tenough.\n\t(Configure): New parameter Low_Level_Traces\n\t(Allocate, Deallocation, Free_Physically): Added low-level traces\n\t(Configure): new parameter Errors_To_Stdout.\n\t(Output_File): new subprogram\n\t(Deallocate, Dereference): Send error messages to the proper stream\n\t(Print_Pool, Print_Info_Stdout): Make sure the output goes to stdout, as\n\tdocumented. Previous code would send it to the current output file\n\tdefined in GNAT.IO, which might not be stdout\n\t(Is_Valid): Adjust comment to mention that a positive reply means that\n\tHeader_Of may be used to retrieve the allocation header associated with\n\tthe subprogram Storage address argument. Return False early if this\n\taddress argument is misaligned.\n\nFrom-SVN: r125415", "tree": {"sha": "d9f4f7e45822978c48f55c3ee87a62b262e05ca4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9f4f7e45822978c48f55c3ee87a62b262e05ca4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f38df0e11608009b95e0332b9fbab26eb593095c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38df0e11608009b95e0332b9fbab26eb593095c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f38df0e11608009b95e0332b9fbab26eb593095c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38df0e11608009b95e0332b9fbab26eb593095c/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8"}], "stats": {"total": 283, "additions": 217, "deletions": 66}, "files": [{"sha": "fa127470712284b7df4fc97bad7235adc71bb3b6", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 194, "deletions": 61, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38df0e11608009b95e0332b9fbab26eb593095c/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38df0e11608009b95e0332b9fbab26eb593095c/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=f38df0e11608009b95e0332b9fbab26eb593095c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -223,21 +223,27 @@ package body GNAT.Debug_Pools is\n    --  including, an address between Ignored_Frame_Start .. Ignored_Frame_End\n    --  are ignored.\n \n+   function Output_File (Pool : Debug_Pool) return File_Type;\n+   pragma Inline (Output_File);\n+   --  Returns file_type on which error messages have to be generated for Pool\n+\n    procedure Put_Line\n-     (Depth               : Natural;\n+     (File                : File_Type;\n+      Depth               : Natural;\n       Traceback           : Tracebacks_Array_Access;\n       Ignored_Frame_Start : System.Address := System.Null_Address;\n       Ignored_Frame_End   : System.Address := System.Null_Address);\n-   --  Print Traceback to Standard_Output. If Traceback is null, print the\n-   --  call_chain at the current location, up to Depth levels, ignoring all\n-   --  addresses up to the first one in the range\n-   --  Ignored_Frame_Start .. Ignored_Frame_End\n+   --  Print Traceback to File. If Traceback is null, print the call_chain\n+   --  at the current location, up to Depth levels, ignoring all addresses\n+   --  up to the first one in the range:\n+   --    Ignored_Frame_Start .. Ignored_Frame_End\n \n    package Validity is\n       function Is_Valid (Storage : System.Address) return Boolean;\n       pragma Inline (Is_Valid);\n-      --  Return True if Storage is an address that the debug pool has under\n-      --  its control.\n+      --  Return True if Storage is the address of a block that the debug pool\n+      --  has under its control, in which case Header_Of may be used to access\n+      --  the associated allocation header.\n \n       procedure Set_Valid (Storage : System.Address; Value : Boolean);\n       pragma Inline (Set_Valid);\n@@ -356,12 +362,26 @@ package body GNAT.Debug_Pools is\n       return Header (1 + Result mod Integer_Address (Header'Last));\n    end Hash;\n \n+   -----------------\n+   -- Output_File --\n+   -----------------\n+\n+   function Output_File (Pool : Debug_Pool) return File_Type is\n+   begin\n+      if Pool.Errors_To_Stdout then\n+         return Standard_Output;\n+      else\n+         return Standard_Error;\n+      end if;\n+   end Output_File;\n+\n    --------------\n    -- Put_Line --\n    --------------\n \n    procedure Put_Line\n-     (Depth               : Natural;\n+     (File                : File_Type;\n+      Depth               : Natural;\n       Traceback           : Tracebacks_Array_Access;\n       Ignored_Frame_Start : System.Address := System.Null_Address;\n       Ignored_Frame_End   : System.Address := System.Null_Address)\n@@ -376,9 +396,9 @@ package body GNAT.Debug_Pools is\n       procedure Print (Tr : Tracebacks_Array) is\n       begin\n          for J in Tr'Range loop\n-            Put (\"0x\" & Address_Image (PC_For (Tr (J))) & ' ');\n+            Put (File, \"0x\" & Address_Image (PC_For (Tr (J))) & ' ');\n          end loop;\n-         Put (ASCII.LF);\n+         Put (File, ASCII.LF);\n       end Print;\n \n    --  Start of processing for Put_Line\n@@ -555,21 +575,35 @@ package body GNAT.Debug_Pools is\n \n       function Is_Valid (Storage : System.Address) return Boolean is\n          Int_Storage  : constant Integer_Address := To_Integer (Storage);\n-         Block_Number : constant Integer_Address :=\n-                          Int_Storage /  Memory_Chunk_Size;\n-         Ptr          : constant Validity_Bits_Ref :=\n-                          Validy_Htable.Get (Block_Number);\n-         Offset       : constant Integer_Address :=\n-                          (Int_Storage - (Block_Number * Memory_Chunk_Size)) /\n-                             Default_Alignment;\n-         Bit          : constant Byte :=\n-                          2 ** Natural (Offset mod System.Storage_Unit);\n+\n       begin\n-         if Ptr = No_Validity_Bits then\n+         --  The pool only returns addresses aligned on Default_Alignment so\n+         --  anything off cannot be a valid block address and we can return\n+         --  early in this case. We actually have to since our datastructures\n+         --  map validity bits for such aligned addresses only.\n+\n+         if Int_Storage mod Default_Alignment /= 0 then\n             return False;\n-         else\n-            return (Ptr (Offset / System.Storage_Unit) and Bit) /= 0;\n          end if;\n+\n+         declare\n+            Block_Number : constant Integer_Address :=\n+                             Int_Storage /  Memory_Chunk_Size;\n+            Ptr          : constant Validity_Bits_Ref :=\n+                             Validy_Htable.Get (Block_Number);\n+            Offset       : constant Integer_Address :=\n+                             (Int_Storage -\n+                               (Block_Number * Memory_Chunk_Size)) /\n+                                  Default_Alignment;\n+            Bit          : constant Byte :=\n+                             2 ** Natural (Offset mod System.Storage_Unit);\n+         begin\n+            if Ptr = No_Validity_Bits then\n+               return False;\n+            else\n+               return (Ptr (Offset / System.Storage_Unit) and Bit) /= 0;\n+            end if;\n+         end;\n       end Is_Valid;\n \n       ---------------\n@@ -673,10 +707,13 @@ package body GNAT.Debug_Pools is\n       end;\n \n       Storage_Address :=\n-        System.Null_Address + Default_Alignment\n-          * (((P.all'Address + Default_Alignment - 1) - System.Null_Address)\n-             / Default_Alignment)\n-        + Header_Offset;\n+        To_Address\n+          (Default_Alignment *\n+             ((To_Integer (P.all'Address) + Default_Alignment - 1)\n+               / Default_Alignment)\n+           + Integer_Address (Header_Offset));\n+      --  Computation is done in Integer_Address, not Storage_Offset, because\n+      --  the range of Storage_Offset may not be large enough.\n \n       pragma Assert ((Storage_Address - System.Null_Address)\n                      mod Default_Alignment = 0);\n@@ -721,6 +758,20 @@ package body GNAT.Debug_Pools is\n \n       Set_Valid (Storage_Address, True);\n \n+      if Pool.Low_Level_Traces then\n+         Put (Output_File (Pool),\n+              \"info: Allocated\"\n+                & Storage_Count'Image (Size_In_Storage_Elements)\n+                & \" bytes at 0x\" & Address_Image (Storage_Address)\n+                & \" (physically:\"\n+                & Storage_Count'Image (Local_Storage_Array'Length)\n+                & \" bytes at 0x\" & Address_Image (P.all'Address)\n+                & \"), at \");\n+         Put_Line (Output_File (Pool), Pool.Stack_Trace_Depth, null,\n+                   Allocate_Label'Address,\n+                   Code_Address_For_Deallocate_End);\n+      end if;\n+\n       --  Update internal data\n \n       Pool.Allocated :=\n@@ -894,6 +945,17 @@ package body GNAT.Debug_Pools is\n                end;\n \n                Next := Header.Next;\n+\n+               if Pool.Low_Level_Traces then\n+                  Put_Line\n+                    (Output_File (Pool),\n+                     \"info: Freeing physical memory \"\n+                       & Storage_Count'Image\n+                       ((abs Header.Block_Size) + Minimum_Allocation)\n+                       & \" bytes at 0x\"\n+                       & Address_Image (Header.Allocation_Address));\n+               end if;\n+\n                System.Memory.Free (Header.Allocation_Address);\n                Set_Valid (Tmp, False);\n \n@@ -1065,8 +1127,9 @@ package body GNAT.Debug_Pools is\n          if Pool.Raise_Exceptions then\n             raise Freeing_Not_Allocated_Storage;\n          else\n-            Put (\"error: Freeing not allocated storage, at \");\n-            Put_Line (Pool.Stack_Trace_Depth, null,\n+            Put (Output_File (Pool),\n+                 \"error: Freeing not allocated storage, at \");\n+            Put_Line (Output_File (Pool), Pool.Stack_Trace_Depth, null,\n                       Deallocate_Label'Address,\n                       Code_Address_For_Deallocate_End);\n          end if;\n@@ -1076,21 +1139,53 @@ package body GNAT.Debug_Pools is\n          if Pool.Raise_Exceptions then\n             raise Freeing_Deallocated_Storage;\n          else\n-            Put (\"error: Freeing already deallocated storage, at \");\n-            Put_Line (Pool.Stack_Trace_Depth, null,\n+            Put (Output_File (Pool),\n+                 \"error: Freeing already deallocated storage, at \");\n+            Put_Line (Output_File (Pool), Pool.Stack_Trace_Depth, null,\n                       Deallocate_Label'Address,\n                       Code_Address_For_Deallocate_End);\n-            Put (\"   Memory already deallocated at \");\n-            Put_Line (0, To_Traceback (Header.Dealloc_Traceback).Traceback);\n-            Put (\"   Memory was allocated at \");\n-            Put_Line (0, Header.Alloc_Traceback.Traceback);\n+            Put (Output_File (Pool), \"   Memory already deallocated at \");\n+            Put_Line\n+               (Output_File (Pool), 0,\n+                To_Traceback (Header.Dealloc_Traceback).Traceback);\n+            Put (Output_File (Pool), \"   Memory was allocated at \");\n+            Put_Line (Output_File (Pool), 0, Header.Alloc_Traceback.Traceback);\n          end if;\n \n       else\n+         --  Some sort of codegen problem or heap corruption caused the\n+         --  Size_In_Storage_Elements to be wrongly computed.\n+         --  The code below is all based on the assumption that Header.all\n+         --  is not corrupted, such that the error is non-fatal.\n+\n+         if Header.Block_Size /= Size_In_Storage_Elements then\n+            Put_Line (Output_File (Pool),\n+                      \"error: Deallocate size \"\n+                        & Storage_Count'Image (Size_In_Storage_Elements)\n+                        & \" does not match allocate size \"\n+                        & Storage_Count'Image (Header.Block_Size));\n+         end if;\n+\n+         if Pool.Low_Level_Traces then\n+            Put (Output_File (Pool),\n+                 \"info: Deallocated\"\n+                 & Storage_Count'Image (Size_In_Storage_Elements)\n+                 & \" bytes at 0x\" & Address_Image (Storage_Address)\n+                 & \" (physically\"\n+                 & Storage_Count'Image (Header.Block_Size + Minimum_Allocation)\n+                 & \" bytes at 0x\" & Address_Image (Header.Allocation_Address)\n+                 & \"), at \");\n+            Put_Line (Output_File (Pool), Pool.Stack_Trace_Depth, null,\n+                      Deallocate_Label'Address,\n+                      Code_Address_For_Deallocate_End);\n+            Put (Output_File (Pool), \"   Memory was allocated at \");\n+            Put_Line (Output_File (Pool), 0, Header.Alloc_Traceback.Traceback);\n+         end if;\n+\n          --  Remove this block from the list of used blocks\n \n          Previous :=\n-           To_Address (Header_Of (Storage_Address).Dealloc_Traceback);\n+           To_Address (Header.Dealloc_Traceback);\n \n          if Previous = System.Null_Address then\n             Pool.First_Used_Block := Header_Of (Pool.First_Used_Block).Next;\n@@ -1101,12 +1196,11 @@ package body GNAT.Debug_Pools is\n             end if;\n \n          else\n-            Header_Of (Previous).Next := Header_Of (Storage_Address).Next;\n+            Header_Of (Previous).Next := Header.Next;\n \n-            if Header_Of (Storage_Address).Next /= System.Null_Address then\n+            if Header.Next /= System.Null_Address then\n                Header_Of\n-                 (Header_Of (Storage_Address).Next).Dealloc_Traceback :=\n-                    To_Address (Previous);\n+                 (Header.Next).Dealloc_Traceback := To_Address (Previous);\n             end if;\n          end if;\n \n@@ -1122,15 +1216,14 @@ package body GNAT.Debug_Pools is\n                                         Deallocate_Label'Address,\n                                         Code_Address_For_Deallocate_End)),\n             Next               => System.Null_Address,\n-            Block_Size         => -Size_In_Storage_Elements);\n+            Block_Size         => -Header.Block_Size);\n \n          if Pool.Reset_Content_On_Free then\n-            Set_Dead_Beef (Storage_Address, Size_In_Storage_Elements);\n+            Set_Dead_Beef (Storage_Address, -Header.Block_Size);\n          end if;\n \n          Pool.Logically_Deallocated :=\n-           Pool.Logically_Deallocated +\n-             Byte_Count (Size_In_Storage_Elements);\n+           Pool.Logically_Deallocated + Byte_Count (-Header.Block_Size);\n \n          --  Link this free block with the others (at the end of the list, so\n          --  that we can start releasing the older blocks first later on).\n@@ -1201,8 +1294,9 @@ package body GNAT.Debug_Pools is\n          if Pool.Raise_Exceptions then\n             raise Accessing_Not_Allocated_Storage;\n          else\n-            Put (\"error: Accessing not allocated storage, at \");\n-            Put_Line (Pool.Stack_Trace_Depth, null,\n+            Put (Output_File (Pool),\n+                 \"error: Accessing not allocated storage, at \");\n+            Put_Line (Output_File (Pool), Pool.Stack_Trace_Depth, null,\n                       Dereference_Label'Address,\n                       Code_Address_For_Dereference_End);\n          end if;\n@@ -1214,15 +1308,20 @@ package body GNAT.Debug_Pools is\n             if Pool.Raise_Exceptions then\n                raise Accessing_Deallocated_Storage;\n             else\n-               Put (\"error: Accessing deallocated storage, at \");\n+               Put (Output_File (Pool),\n+                    \"error: Accessing deallocated storage, at \");\n                Put_Line\n-                 (Pool.Stack_Trace_Depth, null,\n+                 (Output_File (Pool), Pool.Stack_Trace_Depth, null,\n                   Dereference_Label'Address,\n                   Code_Address_For_Dereference_End);\n-               Put (\"  First deallocation at \");\n-               Put_Line (0, To_Traceback (Header.Dealloc_Traceback).Traceback);\n-               Put (\"  Initial allocation at \");\n-               Put_Line (0, Header.Alloc_Traceback.Traceback);\n+               Put (Output_File (Pool), \"  First deallocation at \");\n+               Put_Line\n+                 (Output_File (Pool),\n+                  0, To_Traceback (Header.Dealloc_Traceback).Traceback);\n+               Put (Output_File (Pool), \"  Initial allocation at \");\n+               Put_Line\n+                 (Output_File (Pool),\n+                  0, Header.Alloc_Traceback.Traceback);\n             end if;\n          end if;\n       end if;\n@@ -1441,7 +1540,9 @@ package body GNAT.Debug_Pools is\n       Minimum_To_Free                : SSC     := Default_Min_Freed;\n       Reset_Content_On_Free          : Boolean := Default_Reset_Content;\n       Raise_Exceptions               : Boolean := Default_Raise_Exceptions;\n-      Advanced_Scanning              : Boolean := Default_Advanced_Scanning)\n+      Advanced_Scanning              : Boolean := Default_Advanced_Scanning;\n+      Errors_To_Stdout               : Boolean := Default_Errors_To_Stdout;\n+      Low_Level_Traces               : Boolean := Default_Low_Level_Traces)\n    is\n    begin\n       Pool.Stack_Trace_Depth              := Stack_Trace_Depth;\n@@ -1450,6 +1551,8 @@ package body GNAT.Debug_Pools is\n       Pool.Raise_Exceptions               := Raise_Exceptions;\n       Pool.Minimum_To_Free                := Minimum_To_Free;\n       Pool.Advanced_Scanning              := Advanced_Scanning;\n+      Pool.Errors_To_Stdout               := Errors_To_Stdout;\n+      Pool.Low_Level_Traces               := Low_Level_Traces;\n    end Configure;\n \n    ----------------\n@@ -1467,23 +1570,27 @@ package body GNAT.Debug_Pools is\n       --  instead of passing the value of my_var\n \n       if A = System.Null_Address then\n-         Put_Line (\"Memory not under control of the storage pool\");\n+         Put_Line\n+            (Standard_Output, \"Memory not under control of the storage pool\");\n          return;\n       end if;\n \n       if not Valid then\n-         Put_Line (\"Memory not under control of the storage pool\");\n+         Put_Line\n+            (Standard_Output, \"Memory not under control of the storage pool\");\n \n       else\n          Header := Header_Of (Storage);\n-         Put_Line (\"0x\" & Address_Image (A)\n+         Put_Line (Standard_Output, \"0x\" & Address_Image (A)\n                      & \" allocated at:\");\n-         Put_Line (0, Header.Alloc_Traceback.Traceback);\n+         Put_Line (Standard_Output, 0, Header.Alloc_Traceback.Traceback);\n \n          if To_Traceback (Header.Dealloc_Traceback) /= null then\n-            Put_Line (\"0x\" & Address_Image (A)\n+            Put_Line (Standard_Output, \"0x\" & Address_Image (A)\n                       & \" logically freed memory, deallocated at:\");\n-            Put_Line (0, To_Traceback (Header.Dealloc_Traceback).Traceback);\n+            Put_Line\n+               (Standard_Output, 0,\n+                To_Traceback (Header.Dealloc_Traceback).Traceback);\n          end if;\n       end if;\n    end Print_Pool;\n@@ -1498,9 +1605,35 @@ package body GNAT.Debug_Pools is\n       Display_Slots : Boolean := False;\n       Display_Leaks : Boolean := False)\n    is\n+      procedure Stdout_Put      (S : String);\n+      procedure Stdout_Put_Line (S : String);\n+      --  Wrappers for Put and Put_Line that ensure we always write to stdout\n+      --  instead of the current output file defined in GNAT.IO.\n+\n       procedure Internal is new Print_Info\n-        (Put_Line => GNAT.IO.Put_Line,\n-         Put      => GNAT.IO.Put);\n+        (Put_Line => Stdout_Put_Line,\n+         Put      => Stdout_Put);\n+\n+      ----------------\n+      -- Stdout_Put --\n+      ----------------\n+\n+      procedure Stdout_Put (S : String) is\n+      begin\n+         Put_Line (Standard_Output, S);\n+      end Stdout_Put;\n+\n+      ---------------------\n+      -- Stdout_Put_Line --\n+      ---------------------\n+\n+      procedure Stdout_Put_Line (S : String) is\n+      begin\n+         Put_Line (Standard_Output, S);\n+      end Stdout_Put_Line;\n+\n+   --  Start of processing for Print_Info_Stdout\n+\n    begin\n       Internal (Pool, Cumulate, Display_Slots, Display_Leaks);\n    end Print_Info_Stdout;"}, {"sha": "d3072c3d2f605cea3b3c52835259a10d4b7d86e5", "filename": "gcc/ada/g-debpoo.ads", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38df0e11608009b95e0332b9fbab26eb593095c/gcc%2Fada%2Fg-debpoo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38df0e11608009b95e0332b9fbab26eb593095c/gcc%2Fada%2Fg-debpoo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.ads?ref=f38df0e11608009b95e0332b9fbab26eb593095c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,7 +36,7 @@\n --  The goal of this debug pool is to detect incorrect uses of memory\n --  (multiple deallocations, access to invalid memory,...). Errors are reported\n --  in one of two ways: either by immediately raising an exception, or by\n---  printing a message on standard output.\n+--  printing a message on standard output or standard error.\n \n --  You need to instrument your code to use this package: for each access type\n --  you want to monitor, you need to add a clause similar to:\n@@ -102,6 +102,8 @@ package GNAT.Debug_Pools is\n    Default_Raise_Exceptions  : constant Boolean := True;\n    Default_Advanced_Scanning : constant Boolean := False;\n    Default_Min_Freed         : constant SSC     := 0;\n+   Default_Errors_To_Stdout  : constant Boolean := True;\n+   Default_Low_Level_Traces  : constant Boolean := False;\n    --  The above values are constants used for the parameters to Configure\n    --  if not overridden in the call. See description of Configure for full\n    --  details on these parameters. If these defaults are not satisfactory,\n@@ -114,7 +116,9 @@ package GNAT.Debug_Pools is\n       Minimum_To_Free                : SSC     := Default_Min_Freed;\n       Reset_Content_On_Free          : Boolean := Default_Reset_Content;\n       Raise_Exceptions               : Boolean := Default_Raise_Exceptions;\n-      Advanced_Scanning              : Boolean := Default_Advanced_Scanning);\n+      Advanced_Scanning              : Boolean := Default_Advanced_Scanning;\n+      Errors_To_Stdout               : Boolean := Default_Errors_To_Stdout;\n+      Low_Level_Traces               : Boolean := Default_Low_Level_Traces);\n    --  Subprogram used to configure the debug pool.\n    --\n    --    Stack_Trace_Depth. This parameter controls the maximum depth of stack\n@@ -143,7 +147,8 @@ package GNAT.Debug_Pools is\n    --\n    --    Raise_Exceptions: If true, the exceptions below will be raised every\n    --    time an error is detected. If you set this to False, then the action\n-   --    is to generate output on standard error, noting the errors, but to\n+   --    is to generate output on standard error or standard output, depending\n+   --    on Errors_To_Stdout, noting the errors, but to\n    --    keep running if possible (of course if storage is badly damaged, this\n    --    attempt may fail. This helps to detect more than one error in a run.\n    --\n@@ -153,6 +158,17 @@ package GNAT.Debug_Pools is\n    --    Note that this algorithm is approximate, and it is recommended\n    --    that you set Minimum_To_Free to a non-zero value to save time.\n    --\n+   --    Errors_To_Stdout: Errors messages will be displayed on stdout if\n+   --    this parameter is True, or to stderr otherwise.\n+   --\n+   --    Low_Level_Traces: Traces all allocation and deallocations on the\n+   --    stream specified by Errors_To_Stdout. This can be used for\n+   --    post-processing by your own application, or to debug the\n+   --    debug_pool itself. The output indicates the size of the allocated\n+   --    block both as requested by the application and as physically\n+   --    allocated to fit the additional information needed by the debug\n+   --    pool.\n+   --\n    --  All instantiations of this pool use the same internal tables. However,\n    --  they do not store the same amount of information for the tracebacks,\n    --  and they have different counters for maximum logically freed memory.\n@@ -289,6 +305,8 @@ private\n       Raise_Exceptions               : Boolean := Default_Raise_Exceptions;\n       Minimum_To_Free                : SSC     := Default_Min_Freed;\n       Advanced_Scanning              : Boolean := Default_Advanced_Scanning;\n+      Errors_To_Stdout               : Boolean := Default_Errors_To_Stdout;\n+      Low_Level_Traces               : Boolean := Default_Low_Level_Traces;\n \n       Allocated : Byte_Count := 0;\n       --  Total number of bytes allocated in this pool\n@@ -297,7 +315,7 @@ private\n       --  Total number of bytes logically deallocated in this pool. This is the\n       --  memory that the application has released, but that the pool has not\n       --  yet physically released through a call to free(), to detect later\n-      --  accesed to deallocated memory.\n+      --  accessed to deallocated memory.\n \n       Physically_Deallocated : Byte_Count := 0;\n       --  Total number of bytes that were free()-ed"}]}