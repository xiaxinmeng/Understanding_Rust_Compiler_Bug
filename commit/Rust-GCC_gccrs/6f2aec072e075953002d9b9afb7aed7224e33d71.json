{"sha": "6f2aec072e075953002d9b9afb7aed7224e33d71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYyYWVjMDcyZTA3NTk1MzAwMmQ5YjlhZmI3YWVkNzIyNGUzM2Q3MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-09-21T03:19:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-09-21T03:19:00Z"}, "message": "tree-ssanames.c (make_ssa_name): No longer need to clear, then initialize key elements here.\n\n\n\t* tree-ssanames.c (make_ssa_name): No longer need to clear, then\n\tinitialize key elements here.\n\t(release_ssa_name): Zero the released SSA_NAME here.\n\t* tree.h (SSA_NAME_EQUIV, SET_SSA_NAME_EQUIV): New macros.\n\t(struct tree_ssa_name): Add new \"equiv\" field.\n\t* tree-ssa-dom.c (const_and_copies): Kill the global varray.\n\t(tree_ssa_dominator_optimize): No longer allocate, resize or\n\tclear CONST_AND_COPIES.\n\t(get_value_for, set_value_for): Kill.\n\t(thread_across_edge): Get/set the equivalency using\n\tSSA_NAME_EQUIV and SET_SSA_NAME_EQUIV.\n\t(restore_vars_to_original_value): Likewise.\n\t(record_equivalences_from_phis): Likewise.\n\t(record_dominating_conditions): Likewise.\n\t(record_const_or_copy, record_equality): Likewise.\n\t(lookup_avail_expr): Likewise.\n\t(record_equivalences_from_stmt, cprop_operand): Likewise.\n\t(cprop_into_successor_phis): No longer need to pass around\n\tCONST_AND_COPIES.  Callers updated. Get equivalences via\n\tSSA_NAME_EQUIV.\n\t(cprop_into_phis): Likewise.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r87787", "tree": {"sha": "d63342eb84f672e7ec05ab0664ccacf61232ea1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d63342eb84f672e7ec05ab0664ccacf61232ea1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f2aec072e075953002d9b9afb7aed7224e33d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f2aec072e075953002d9b9afb7aed7224e33d71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f2aec072e075953002d9b9afb7aed7224e33d71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f2aec072e075953002d9b9afb7aed7224e33d71/comments", "author": null, "committer": null, "parents": [{"sha": "c162c75e43f4813cd30a1d4a693ce20f35a3f9fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c162c75e43f4813cd30a1d4a693ce20f35a3f9fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c162c75e43f4813cd30a1d4a693ce20f35a3f9fb"}], "stats": {"total": 159, "additions": 86, "deletions": 73}, "files": [{"sha": "0e22456397b1271def2335a392677974e63bb99e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2aec072e075953002d9b9afb7aed7224e33d71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2aec072e075953002d9b9afb7aed7224e33d71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f2aec072e075953002d9b9afb7aed7224e33d71", "patch": "@@ -1,3 +1,28 @@\n+2004-09-20 Jeff Law  <law@redhat.com>\n+           Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssanames.c (make_ssa_name): No longer need to clear, then\n+\tinitialize key elements here.\n+\t(release_ssa_name): Zero the released SSA_NAME here.\n+\t* tree.h (SSA_NAME_EQUIV, SET_SSA_NAME_EQUIV): New macros.\n+\t(struct tree_ssa_name): Add new \"equiv\" field.\n+\t* tree-ssa-dom.c (const_and_copies): Kill the global varray.\n+\t(tree_ssa_dominator_optimize): No longer allocate, resize or\n+\tclear CONST_AND_COPIES.\n+\t(get_value_for, set_value_for): Kill.\n+\t(thread_across_edge): Get/set the equivalency using\n+\tSSA_NAME_EQUIV and SET_SSA_NAME_EQUIV.\n+\t(restore_vars_to_original_value): Likewise.\n+\t(record_equivalences_from_phis): Likewise.\n+\t(record_dominating_conditions): Likewise.\n+\t(record_const_or_copy, record_equality): Likewise.\n+\t(lookup_avail_expr): Likewise.\n+\t(record_equivalences_from_stmt, cprop_operand): Likewise.\n+\t(cprop_into_successor_phis): No longer need to pass around\n+\tCONST_AND_COPIES.  Callers updated. Get equivalences via\n+\tSSA_NAME_EQUIV.\n+\t(cprop_into_phis): Likewise.\n+\n 2004-09-20  Matt Austern <austern@apple.com>\n \t    Zack Weinberg  <zack@codesourcery.com>\n "}, {"sha": "a0acd5d9ecc73131667595e654307602309d4369", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 24, "deletions": 60, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2aec072e075953002d9b9afb7aed7224e33d71/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2aec072e075953002d9b9afb7aed7224e33d71/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=6f2aec072e075953002d9b9afb7aed7224e33d71", "patch": "@@ -109,16 +109,6 @@ struct expr_hash_elt\n   hashval_t hash;\n };\n \n-/* Table of constant values and copies indexed by SSA name.  When the\n-   renaming pass finds an assignment of a constant (X_i = C) or a copy\n-   assignment from another SSA variable (X_i = Y_j), it creates a mapping\n-   between X_i and the RHS in this table.  This mapping is used later on,\n-   when renaming uses of X_i.  If an assignment to X_i is found in this\n-   table, instead of using X_i, we use the RHS of the statement stored in\n-   this table (thus performing very simplistic copy and constant\n-   propagation).  */\n-static varray_type const_and_copies;\n-\n /* Stack of dest,src pairs that need to be restored during finalization.\n \n    A NULL entry is used to mark the end of pairs which need to be\n@@ -229,8 +219,6 @@ struct eq_expr_value\n static void optimize_stmt (struct dom_walk_data *, \n \t\t\t   basic_block bb,\n \t\t\t   block_stmt_iterator);\n-static inline tree get_value_for (tree, varray_type table);\n-static inline void set_value_for (tree, tree, varray_type table);\n static tree lookup_avail_expr (tree, bool);\n static struct eq_expr_value get_eq_expr_value (tree, int, basic_block);\n static hashval_t avail_expr_hash (const void *);\n@@ -281,22 +269,6 @@ local_fold (tree t)\n   return t;\n }\n \n-/* Return the value associated with variable VAR in TABLE.  */\n-\n-static inline tree\n-get_value_for (tree var, varray_type table)\n-{\n-  return VARRAY_TREE (table, SSA_NAME_VERSION (var));\n-}\n-\n-/* Associate VALUE to variable VAR in TABLE.  */\n-\n-static inline void\n-set_value_for (tree var, tree value, varray_type table)\n-{\n-  VARRAY_TREE (table, SSA_NAME_VERSION (var)) = value;\n-}\n-\n /* Jump threading, redundancy elimination and const/copy propagation. \n \n    This pass may expose new symbols that need to be renamed into SSA.  For\n@@ -321,7 +293,6 @@ tree_ssa_dominator_optimize (void)\n   avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free);\n   VARRAY_TREE_INIT (avail_exprs_stack, 20, \"Available expression stack\");\n   VARRAY_TREE_INIT (block_defs_stack, 20, \"Block DEFS stack\");\n-  VARRAY_TREE_INIT (const_and_copies, num_ssa_names, \"const_and_copies\");\n   VARRAY_TREE_INIT (const_and_copies_stack, 20, \"Block const_and_copies stack\");\n   VARRAY_TREE_INIT (nonzero_vars_stack, 20, \"Block nonzero_vars stack\");\n   VARRAY_TREE_INIT (vrp_variables_stack, 20, \"Block vrp_variables stack\");\n@@ -392,16 +363,12 @@ tree_ssa_dominator_optimize (void)\n \n       rewrite_ssa_into_ssa ();\n \n-      if (VARRAY_ACTIVE_SIZE (const_and_copies) <= num_ssa_names)\n-\t{\n-\t  VARRAY_GROW (const_and_copies, num_ssa_names);\n-\t  VARRAY_GROW (vrp_data, num_ssa_names);\n-\t}\n+      if (VARRAY_ACTIVE_SIZE (vrp_data) <= num_ssa_names)\n+\tVARRAY_GROW (vrp_data, num_ssa_names);\n \n       /* Reinitialize the various tables.  */\n       bitmap_clear (nonzero_vars);\n       htab_empty (avail_exprs);\n-      VARRAY_CLEAR (const_and_copies);\n       VARRAY_CLEAR (vrp_data);\n \n       for (i = 0; i < num_referenced_vars; i++)\n@@ -525,7 +492,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \n \t      uses_copy[i] = USE_OP (uses, i);\n \t      if (TREE_CODE (USE_OP (uses, i)) == SSA_NAME)\n-\t\ttmp = get_value_for (USE_OP (uses, i), const_and_copies);\n+\t\ttmp = SSA_NAME_EQUIV (USE_OP (uses, i));\n \t      if (tmp)\n \t\tSET_USE_OP (uses, i, tmp);\n \t    }\n@@ -537,7 +504,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \n \t      vuses_copy[i] = VUSE_OP (vuses, i);\n \t      if (TREE_CODE (VUSE_OP (vuses, i)) == SSA_NAME)\n-\t\ttmp = get_value_for (VUSE_OP (vuses, i), const_and_copies);\n+\t\ttmp = SSA_NAME_EQUIV (VUSE_OP (vuses, i));\n \t      if (tmp)\n \t\tSET_VUSE_OP (vuses, i, tmp);\n \t    }\n@@ -629,14 +596,14 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t  /* Get the current value of both operands.  */\n \t  if (TREE_CODE (op0) == SSA_NAME)\n \t    {\n-\t      tree tmp = get_value_for (op0, const_and_copies);\n+\t      tree tmp = SSA_NAME_EQUIV (op0);\n \t      if (tmp)\n \t\top0 = tmp;\n \t    }\n \n \t  if (TREE_CODE (op1) == SSA_NAME)\n \t    {\n-\t      tree tmp = get_value_for (op1, const_and_copies);\n+\t      tree tmp = SSA_NAME_EQUIV (op1);\n \t      if (tmp)\n \t\top1 = tmp;\n \t    }\n@@ -676,7 +643,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n       else if (TREE_CODE (cond) == SSA_NAME)\n \t{\n \t  cached_lhs = cond;\n-\t  cached_lhs = get_value_for (cached_lhs, const_and_copies);\n+\t  cached_lhs = SSA_NAME_EQUIV (cached_lhs);\n \t  if (cached_lhs && ! is_gimple_min_invariant (cached_lhs))\n \t    cached_lhs = 0;\n \t}\n@@ -831,7 +798,7 @@ restore_vars_to_original_value (void)\n       prev_value = VARRAY_TOP_TREE (const_and_copies_stack);\n       VARRAY_POP (const_and_copies_stack);\n \n-      set_value_for (dest, prev_value, const_and_copies);\n+      SET_SSA_NAME_EQUIV (dest, prev_value);\n     }\n }\n \n@@ -1083,7 +1050,7 @@ record_equivalences_from_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t by this assignment, so unwinding just costs time and space.  */\n       if (i == PHI_NUM_ARGS (phi)\n \t  && may_propagate_copy (lhs, rhs))\n-\tset_value_for (lhs, rhs, const_and_copies);\n+\tSET_SSA_NAME_EQUIV (lhs, rhs);\n \n       /* Now see if we know anything about the nonzero property for the\n \t result of this PHI.  */\n@@ -1479,7 +1446,7 @@ record_dominating_conditions (tree cond)\n static void\n record_const_or_copy_1 (tree x, tree y, tree prev_x)\n {\n-  set_value_for (x, y, const_and_copies);\n+  SET_SSA_NAME_EQUIV (x, y);\n \n   VARRAY_PUSH_TREE (const_and_copies_stack, prev_x);\n   VARRAY_PUSH_TREE (const_and_copies_stack, x);\n@@ -1491,11 +1458,11 @@ record_const_or_copy_1 (tree x, tree y, tree prev_x)\n static void\n record_const_or_copy (tree x, tree y)\n {\n-  tree prev_x = get_value_for (x, const_and_copies);\n+  tree prev_x = SSA_NAME_EQUIV (x);\n \n   if (TREE_CODE (y) == SSA_NAME)\n     {\n-      tree tmp = get_value_for (y, const_and_copies);\n+      tree tmp = SSA_NAME_EQUIV (y);\n       if (tmp)\n \ty = tmp;\n     }\n@@ -1512,9 +1479,9 @@ record_equality (tree x, tree y)\n   tree prev_x = NULL, prev_y = NULL;\n \n   if (TREE_CODE (x) == SSA_NAME)\n-    prev_x = get_value_for (x, const_and_copies);\n+    prev_x = SSA_NAME_EQUIV (x);\n   if (TREE_CODE (y) == SSA_NAME)\n-    prev_y = get_value_for (y, const_and_copies);\n+    prev_y = SSA_NAME_EQUIV (y);\n \n   /* If one of the previous values is invariant, then use that.\n      Otherwise it doesn't matter which value we choose, just so\n@@ -2169,9 +2136,7 @@ simplify_switch_and_lookup_avail_expr (tree stmt, int insert)\n    nodes of the successors of BB.  */\n \n static void\n-cprop_into_successor_phis (basic_block bb,\n-\t\t\t   varray_type const_and_copies,\n-\t\t\t   bitmap nonzero_vars)\n+cprop_into_successor_phis (basic_block bb, bitmap nonzero_vars)\n {\n   edge e;\n \n@@ -2243,7 +2208,7 @@ cprop_into_successor_phis (basic_block bb,\n \n \t  /* If we have *ORIG_P in our constant/copy table, then replace\n \t     ORIG_P with its value in our constant/copy table.  */\n-\t  new = VARRAY_TREE (const_and_copies, SSA_NAME_VERSION (orig));\n+\t  new = SSA_NAME_EQUIV (orig);\n \t  if (new\n \t      && (TREE_CODE (new) == SSA_NAME\n \t\t  || is_gimple_min_invariant (new))\n@@ -2263,7 +2228,7 @@ static void\n cprop_into_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t basic_block bb)\n {\n-  cprop_into_successor_phis (bb, const_and_copies, nonzero_vars);\n+  cprop_into_successor_phis (bb, nonzero_vars);\n }\n \n /* Search for redundant computations in STMT.  If any are found, then\n@@ -2388,7 +2353,7 @@ record_equivalences_from_stmt (tree stmt,\n       if (may_optimize_p\n \t  && (TREE_CODE (rhs) == SSA_NAME\n \t      || is_gimple_min_invariant (rhs)))\n-\tset_value_for (lhs, rhs, const_and_copies);\n+\tSET_SSA_NAME_EQUIV (lhs, rhs);\n \n       /* alloca never returns zero and the address of a non-weak symbol\n \t is never zero.  NOP_EXPRs and CONVERT_EXPRs can be completely\n@@ -2499,7 +2464,7 @@ record_equivalences_from_stmt (tree stmt,\n    CONST_AND_COPIES.  */\n \n static bool\n-cprop_operand (tree stmt, use_operand_p op_p, varray_type const_and_copies)\n+cprop_operand (tree stmt, use_operand_p op_p)\n {\n   bool may_have_exposed_new_symbols = false;\n   tree val;\n@@ -2508,7 +2473,7 @@ cprop_operand (tree stmt, use_operand_p op_p, varray_type const_and_copies)\n   /* If the operand has a known constant value or it is known to be a\n      copy of some other variable, use the value or copy stored in\n      CONST_AND_COPIES.  */\n-  val = VARRAY_TREE (const_and_copies, SSA_NAME_VERSION (op));\n+  val = SSA_NAME_EQUIV (op);\n   if (val)\n     {\n       tree op_type, val_type;\n@@ -2590,7 +2555,7 @@ cprop_operand (tree stmt, use_operand_p op_p, varray_type const_and_copies)\n    v_may_def_ops of STMT.  */\n \n static bool\n-cprop_into_stmt (tree stmt, varray_type const_and_copies)\n+cprop_into_stmt (tree stmt)\n {\n   bool may_have_exposed_new_symbols = false;\n   use_operand_p op_p;\n@@ -2600,8 +2565,7 @@ cprop_into_stmt (tree stmt, varray_type const_and_copies)\n   FOR_EACH_SSA_USE_OPERAND (op_p, stmt, iter, SSA_OP_ALL_USES)\n     {\n       if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n-\tmay_have_exposed_new_symbols\n-\t  |= cprop_operand (stmt, op_p, const_and_copies);\n+\tmay_have_exposed_new_symbols |= cprop_operand (stmt, op_p);\n     }\n \n   if (may_have_exposed_new_symbols)\n@@ -2653,7 +2617,7 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n     }\n \n   /* Const/copy propagate into USES, VUSES and the RHS of V_MAY_DEFs.  */\n-  may_have_exposed_new_symbols = cprop_into_stmt (stmt, const_and_copies);\n+  may_have_exposed_new_symbols = cprop_into_stmt (stmt);\n \n   /* If the statement has been modified with constant replacements,\n      fold its RHS before checking for redundant computations.  */\n@@ -2895,7 +2859,7 @@ lookup_avail_expr (tree stmt, bool insert)\n      use the value from the const_and_copies table.  */\n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n-      temp = get_value_for (lhs, const_and_copies);\n+      temp = SSA_NAME_EQUIV (lhs);\n       if (temp)\n \tlhs = temp;\n     }"}, {"sha": "0d8ccf81b16904c4badfc4ee722be3d6abf85dee", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2aec072e075953002d9b9afb7aed7224e33d71/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2aec072e075953002d9b9afb7aed7224e33d71/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=6f2aec072e075953002d9b9afb7aed7224e33d71", "patch": "@@ -186,27 +186,19 @@ make_ssa_name (tree var, tree stmt)\n \n   gcc_assert (!stmt || EXPR_P (stmt) || TREE_CODE (stmt) == PHI_NODE);\n \n-  /* If our free list has an element, then use it.  Also reuse the\n-     SSA version number of the element on the free list which helps\n-     keep sbitmaps and arrays sized HIGHEST_SSA_VERSION smaller.  */\n+  /* If our free list has an element, then use it.  */\n   if (free_ssanames)\n     {\n-      unsigned int save_version;\n-\n       t = free_ssanames;\n       free_ssanames = TREE_CHAIN (free_ssanames);\n #ifdef GATHER_STATISTICS\n       ssa_name_nodes_reused++;\n #endif\n \n-      /* Clear the node so that it looks just like one we would have\n-\t received from make_node.  */\n-      save_version = SSA_NAME_VERSION (t);\n-      memset (t, 0, tree_size (t));\n-      TREE_SET_CODE (t, SSA_NAME);\n-      SSA_NAME_VERSION (t) = save_version;\n-      gcc_assert (ssa_name (save_version) == NULL);\n-      VARRAY_TREE (ssa_names, save_version) = t;\n+      /* The node was cleared out when we put it on the free list, so\n+\t there is no need to do so again here.  */\n+      gcc_assert (ssa_name (SSA_NAME_VERSION (t)) == NULL);\n+      VARRAY_TREE (ssa_names, SSA_NAME_VERSION (t)) = t;\n     }\n   else\n     {\n@@ -262,8 +254,27 @@ release_ssa_name (tree var)\n      defining statement.  */\n   if (! SSA_NAME_IN_FREE_LIST (var))\n     {\n+      tree saved_ssa_name_var = SSA_NAME_VAR (var);\n+      int saved_ssa_name_version = SSA_NAME_VERSION (var);\n+\n       VARRAY_TREE (ssa_names, SSA_NAME_VERSION (var)) = NULL;\n+      memset (var, 0, tree_size (var));\n+\n+      /* First put back the right tree node so that the tree checking\n+\t macros do not complain.  */\n+      TREE_SET_CODE (var, SSA_NAME);\n+\n+      /* Restore the version number.  */\n+      SSA_NAME_VERSION (var) = saved_ssa_name_version;\n+\n+      /* Hopefully this can go away once we have the new incremental\n+         SSA updating code installed.  */\n+      SSA_NAME_VAR (var) = saved_ssa_name_var;\n+\n+      /* Note this SSA_NAME is now in the first list.  */\n       SSA_NAME_IN_FREE_LIST (var) = 1;\n+\n+      /* And finally link it into the free list.  */\n       TREE_CHAIN (var) = free_ssanames;\n       free_ssanames = var;\n     }"}, {"sha": "0f78e743897beaae325fbce18a84fcbf940507ff", "filename": "gcc/tree.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2aec072e075953002d9b9afb7aed7224e33d71/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2aec072e075953002d9b9afb7aed7224e33d71/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6f2aec072e075953002d9b9afb7aed7224e33d71", "patch": "@@ -1304,12 +1304,23 @@ struct tree_exp GTY(())\n #define SSA_NAME_OCCURS_IN_ABNORMAL_PHI(NODE) \\\n     SSA_NAME_CHECK (NODE)->common.asm_written_flag\n \n+\n /* Nonzero if this SSA_NAME expression is currently on the free list of\n    SSA_NAMES.  Using NOTHROW_FLAG seems reasonably safe since throwing\n    has no meaning for an SSA_NAME.  */\n #define SSA_NAME_IN_FREE_LIST(NODE) \\\n     SSA_NAME_CHECK (NODE)->common.nothrow_flag\n \n+#define SSA_NAME_EQUIV(NAME) __extension__ \\\n+  ({  tree equiv = SSA_NAME_CHECK (NAME)->ssa_name.equiv; \\\n+      if (equiv && TREE_CODE (equiv) == SSA_NAME) \\\n+\tequiv = ssa_name (SSA_NAME_VERSION (equiv)); \\\n+      equiv; \\\n+   })\n+\n+#define SET_SSA_NAME_EQUIV(NAME, EQUIV)\\\n+   SSA_NAME_CHECK (NAME)->ssa_name.equiv = (EQUIV);\n+\n /* Attributes for SSA_NAMEs for pointer-type variables.  */\n #define SSA_NAME_PTR_INFO(N) \\\n     SSA_NAME_CHECK (N)->ssa_name.ptr_info\n@@ -1333,6 +1344,8 @@ struct tree_ssa_name GTY(())\n   /* _DECL wrapped by this SSA name.  */\n   tree var;\n \n+  tree equiv;\n+\n   /* SSA version number.  */\n   unsigned int version;\n "}]}