{"sha": "04ef43c7b35e006559781f758a81c207e6d54a15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRlZjQzYzdiMzVlMDA2NTU5NzgxZjc1OGE4MWMyMDdlNmQ1NGExNQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-21T12:45:36Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-21T17:49:44Z"}, "message": "rs6000: Build and store function type identifiers\n\n2021-07-21  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-gen-builtins.c (complete_vector_type): New\n\tfunction.\n\t(complete_base_type): Likewise.\n\t(construct_fntype_id): Likewise.\n\t(parse_bif_entry): Call contruct_fntype_id.\n\t(parse_ovld_entry): Likewise.", "tree": {"sha": "d3acca9b1144a9eaa75c01b95c40d7df4139f8d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3acca9b1144a9eaa75c01b95c40d7df4139f8d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04ef43c7b35e006559781f758a81c207e6d54a15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04ef43c7b35e006559781f758a81c207e6d54a15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04ef43c7b35e006559781f758a81c207e6d54a15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04ef43c7b35e006559781f758a81c207e6d54a15/comments", "author": null, "committer": null, "parents": [{"sha": "582b56dfd023077e9210a3adce478dd73d96d340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/582b56dfd023077e9210a3adce478dd73d96d340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/582b56dfd023077e9210a3adce478dd73d96d340"}], "stats": {"total": 231, "additions": 231, "deletions": 0}, "files": [{"sha": "2ddebcbf9ee448135e3be72bbd3c2e8ae30ebde0", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04ef43c7b35e006559781f758a81c207e6d54a15/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04ef43c7b35e006559781f758a81c207e6d54a15/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=04ef43c7b35e006559781f758a81c207e6d54a15", "patch": "@@ -1295,6 +1295,229 @@ parse_bif_attrs (attrinfo *attrptr)\n   return PC_OK;\n }\n \n+/* Convert a vector type into a mode string.  */\n+static void\n+complete_vector_type (typeinfo *typeptr, char *buf, int *bufi)\n+{\n+  if (typeptr->isbool)\n+    buf[(*bufi)++] = 'b';\n+  buf[(*bufi)++] = 'v';\n+  if (typeptr->ispixel)\n+    {\n+      memcpy (&buf[*bufi], \"p8hi\", 4);\n+      *bufi += 4;\n+      return;\n+    }\n+  switch (typeptr->base)\n+    {\n+    case BT_CHAR:\n+      memcpy (&buf[*bufi], \"16qi\", 4);\n+      *bufi += 4;\n+      break;\n+    case BT_SHORT:\n+      memcpy (&buf[*bufi], \"8hi\", 3);\n+      *bufi += 3;\n+      break;\n+    case BT_INT:\n+      memcpy (&buf[*bufi], \"4si\", 3);\n+      *bufi += 3;\n+      break;\n+    case BT_LONGLONG:\n+      memcpy (&buf[*bufi], \"2di\", 3);\n+      *bufi += 3;\n+      break;\n+    case BT_FLOAT:\n+      memcpy (&buf[*bufi], \"4sf\", 3);\n+      *bufi += 3;\n+      break;\n+    case BT_DOUBLE:\n+      memcpy (&buf[*bufi], \"2df\", 3);\n+      *bufi += 3;\n+      break;\n+    case BT_INT128:\n+      memcpy (&buf[*bufi], \"1ti\", 3);\n+      *bufi += 3;\n+      break;\n+    case BT_FLOAT128:\n+      memcpy (&buf[*bufi], \"1tf\", 3);\n+      *bufi += 3;\n+      break;\n+    case BT_VPAIR:\n+      memcpy (&buf[*bufi], \"1poi\", 4);\n+      *bufi += 4;\n+      break;\n+    case BT_VQUAD:\n+      memcpy (&buf[*bufi], \"1pxi\", 4);\n+      *bufi += 4;\n+      break;\n+    default:\n+      (*diag) (\"unhandled basetype %d.\\n\", typeptr->base);\n+      exit (1);\n+    }\n+}\n+\n+/* Convert a base type into a mode string.  */\n+static void\n+complete_base_type (typeinfo *typeptr, char *buf, int *bufi)\n+{\n+  switch (typeptr->base)\n+    {\n+    case BT_CHAR:\n+      memcpy (&buf[*bufi], \"qi\", 2);\n+      break;\n+    case BT_SHORT:\n+      memcpy (&buf[*bufi], \"hi\", 2);\n+      break;\n+    case BT_INT:\n+      memcpy (&buf[*bufi], \"si\", 2);\n+      break;\n+    case BT_LONG:\n+      memcpy (&buf[*bufi], \"lg\", 2);\n+      break;\n+    case BT_LONGLONG:\n+      memcpy (&buf[*bufi], \"di\", 2);\n+      break;\n+    case BT_FLOAT:\n+      memcpy (&buf[*bufi], \"sf\", 2);\n+      break;\n+    case BT_DOUBLE:\n+      memcpy (&buf[*bufi], \"df\", 2);\n+      break;\n+    case BT_LONGDOUBLE:\n+      memcpy (&buf[*bufi], \"ld\", 2);\n+      break;\n+    case BT_INT128:\n+      memcpy (&buf[*bufi], \"ti\", 2);\n+      break;\n+    case BT_FLOAT128:\n+      memcpy (&buf[*bufi], \"tf\", 2);\n+      break;\n+    case BT_BOOL:\n+      memcpy (&buf[*bufi], \"bi\", 2);\n+      break;\n+    case BT_STRING:\n+      memcpy (&buf[*bufi], \"st\", 2);\n+      break;\n+    case BT_DECIMAL32:\n+      memcpy (&buf[*bufi], \"sd\", 2);\n+      break;\n+    case BT_DECIMAL64:\n+      memcpy (&buf[*bufi], \"dd\", 2);\n+      break;\n+    case BT_DECIMAL128:\n+      memcpy (&buf[*bufi], \"td\", 2);\n+      break;\n+    case BT_IBM128:\n+      memcpy (&buf[*bufi], \"if\", 2);\n+      break;\n+    default:\n+      (*diag) (\"unhandled basetype %d.\\n\", typeptr->base);\n+      exit (1);\n+    }\n+\n+  *bufi += 2;\n+}\n+\n+/* Build a function type descriptor identifier from the return type\n+   and argument types described by PROTOPTR, and store it if it does\n+   not already exist.  Return the identifier.  */\n+static char *\n+construct_fntype_id (prototype *protoptr)\n+{\n+  /* Determine the maximum space for a function type descriptor id.\n+     Each type requires at most 9 characters (6 for the mode*, 1 for\n+     the optional 'u' preceding the mode, 1 for the optional 'p'\n+     preceding the mode, and 1 for an underscore following the mode).\n+     We also need 5 characters for the string \"ftype\" that separates\n+     the return mode from the argument modes.  The last argument doesn't\n+     need a trailing underscore, but we count that as the one trailing\n+     \"ftype\" instead.  For the special case of zero arguments, we need 9\n+     for the return type and 7 for \"ftype_v\".  Finally, we need one\n+     character for the terminating null.  Thus for a function with N\n+     arguments, we need at most 9N+15 characters for N>0, otherwise 17.\n+     ----\n+       *Worst case is bv16qi for \"vector bool char\".  */\n+  int len = protoptr->nargs ? (protoptr->nargs + 1) * 9 + 6 : 17;\n+  char *buf = (char *) malloc (len);\n+  int bufi = 0;\n+\n+  if (protoptr->rettype.ispointer)\n+    buf[bufi++] = 'p';\n+\n+  if (protoptr->rettype.isvoid)\n+    buf[bufi++] = 'v';\n+  else\n+    {\n+      if (protoptr->rettype.isunsigned)\n+\tbuf[bufi++] = 'u';\n+      if (protoptr->rettype.isvector)\n+\tcomplete_vector_type (&protoptr->rettype, buf, &bufi);\n+      else\n+\tcomplete_base_type (&protoptr->rettype, buf, &bufi);\n+    }\n+\n+  memcpy (&buf[bufi], \"_ftype\", 6);\n+  bufi += 6;\n+\n+  if (!protoptr->nargs)\n+    {\n+      memcpy (&buf[bufi], \"_v\", 2);\n+      bufi += 2;\n+    }\n+  else\n+    {\n+      typelist *argptr = protoptr->args;\n+      for (int i = 0; i < protoptr->nargs; i++, argptr = argptr->next)\n+\t{\n+\t  assert (argptr);\n+\t  buf[bufi++] = '_';\n+\t  if (argptr->info.isconst\n+\t      && argptr->info.base == BT_INT\n+\t      && !argptr->info.ispointer)\n+\t    {\n+\t      buf[bufi++] = 'c';\n+\t      buf[bufi++] = 'i';\n+\t      continue;\n+\t    }\n+\t  if (argptr->info.ispointer)\n+\t    {\n+\t      if (argptr->info.isvoid)\n+\t\t{\n+\t\t  if (argptr->info.isconst)\n+\t\t    {\n+\t\t      memcpy (&buf[bufi], \"pcvoid\", 6);\n+\t\t      bufi += 6;\n+\t\t      continue;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      buf[bufi++] = 'p';\n+\t\t      buf[bufi++] = 'v';\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tbuf[bufi++] = 'p';\n+\t    }\n+\n+\t  if (argptr->info.isunsigned)\n+\t    buf[bufi++] = 'u';\n+\t  if (argptr->info.isvector)\n+\t    complete_vector_type (&argptr->info, buf, &bufi);\n+\t  else\n+\t    complete_base_type (&argptr->info, buf, &bufi);\n+\t}\n+      assert (!argptr);\n+    }\n+\n+  buf[bufi] = '\\0';\n+\n+  /* Ignore return value, as duplicates are fine and expected here.  */\n+  rbt_insert (&fntype_rbt, buf);\n+\n+  return buf;\n+}\n+\n /* Parse a function prototype.  This code is shared by the bif and overload\n    file processing.  */\n static parse_codes\n@@ -1407,6 +1630,10 @@ parse_bif_entry (void)\n   if (parse_prototype (&bifs[curr_bif].proto) == PC_PARSEFAIL)\n     return PC_PARSEFAIL;\n \n+  /* Build a function type descriptor identifier from the return type\n+     and argument types, and store it if it does not already exist.  */\n+  bifs[curr_bif].fndecl = construct_fntype_id (&bifs[curr_bif].proto);\n+\n   /* Now process line 2.  First up is the builtin id.  */\n   if (!advance_line (bif_file))\n     {\n@@ -1580,6 +1807,10 @@ parse_ovld_entry (void)\n   if (ovlds[curr_ovld].proto.nargs > max_ovld_args)\n     max_ovld_args = ovlds[curr_ovld].proto.nargs;\n \n+  /* Build a function type descriptor identifier from the return type\n+     and argument types, and store it if it does not already exist.  */\n+  ovlds[curr_ovld].fndecl = construct_fntype_id (&ovlds[curr_ovld].proto);\n+\n   /* Now process line 2, which just contains the builtin id and an\n      optional overload id.  */\n   if (!advance_line (ovld_file))"}]}