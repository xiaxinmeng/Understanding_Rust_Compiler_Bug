{"sha": "1a048f8232e75f673c8227b8bcd89e0242946512", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEwNDhmODIzMmU3NWY2NzNjODIyN2I4YmNkODllMDI0Mjk0NjUxMg==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2010-01-29T14:30:41Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2010-01-29T14:30:41Z"}, "message": "Fix PRs c++/42758, c++/42634, c++/42797\n\n... and mitigate PR c++/42336\n\ngcc/cp/ChangeLog:\n\tPR c++/42758\n\tPR c++/42634\n\tPR c++/42336\n\tPR c++/42797\n\tPR c++/42880\n\t* cp-tree.h (NON_DEFAULT_TEMPLATE_ARGS_COUNT,\n\tSET_NON_DEFAULT_TEMPLATE_ARGS_COUNT,\n\tGET_NON_DEFAULT_TEMPLATE_ARGS_COUNT): New accessor macros.\n\t* pt.c (coerce_template_parms, type_unification_real,\n\texpand_template_argument_pack, coerce_template_parameter_pack):\n\tSet the non default template args count.\n\t(current_template_args): Always set non defaulted\n\ttemplate args count when compiled with --enable-checking\n\t(tsubst_template_args, type_unification_real): Propagate the non\n\tdefaulted template args count.\n\t* error.c (get_non_default_template_args_count): Renamed\n\tcount_non_default_template_args into this. Don't calculate the\n\tnon default template argument count anymore. Use the new\n\taccessor macros above to get it.\n\t(dump_template_argument_list, dump_type, dump_decl,\n\tdump_template_parms): Adjust.\n\t* parser.c (cp_parser_template_argument_list): Always set defaulted\n\ttemplate args count when compiled with --enable-checking.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/42758\n\tPR c++/42634\n\tPR c++/42336\n\tPR c++/42797\n\tPR c++/42880\n\t* g++.dg/other/crash-5.C: New test.\n\t* g++.dg/other/crash-6.C: New test.\n\t* g++.dg/other/crash-7.C: New test.\n\t* g++.dg/other/crash-8.C: New test.\n\nFrom-SVN: r156351", "tree": {"sha": "2ee93041dfe1e8e764098880a0e8717715707c64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ee93041dfe1e8e764098880a0e8717715707c64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a048f8232e75f673c8227b8bcd89e0242946512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a048f8232e75f673c8227b8bcd89e0242946512", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a048f8232e75f673c8227b8bcd89e0242946512", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a048f8232e75f673c8227b8bcd89e0242946512/comments", "author": null, "committer": null, "parents": [{"sha": "eb6b98c71cbb85510d9b85c2b7439176b730a9b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6b98c71cbb85510d9b85c2b7439176b730a9b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6b98c71cbb85510d9b85c2b7439176b730a9b7"}], "stats": {"total": 370, "additions": 322, "deletions": 48}, "files": [{"sha": "2cb7f4753d3a32b60cac6a67799eed1c043e518e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1a048f8232e75f673c8227b8bcd89e0242946512", "patch": "@@ -1,3 +1,29 @@\n+2010-01-29  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/42758\n+\tPR c++/42634\n+\tPR c++/42336\n+\tPR c++/42797\n+\tPR c++/42880\n+\t* cp-tree.h (NON_DEFAULT_TEMPLATE_ARGS_COUNT,\n+\tSET_NON_DEFAULT_TEMPLATE_ARGS_COUNT,\n+\tGET_NON_DEFAULT_TEMPLATE_ARGS_COUNT): New accessor macros.\n+\t* pt.c (coerce_template_parms, type_unification_real,\n+\texpand_template_argument_pack, coerce_template_parameter_pack):\n+\tSet the non default template args count.\n+\t(current_template_args): Always set non defaulted\n+\ttemplate args count when compiled with --enable-checking\n+\t(tsubst_template_args, type_unification_real): Propagate the non\n+\tdefaulted template args count.\n+\t* error.c (get_non_default_template_args_count): Renamed\n+\tcount_non_default_template_args into this. Don't calculate the\n+\tnon default template argument count anymore. Use the new\n+\taccessor macros above to get it.\n+\t(dump_template_argument_list, dump_type, dump_decl,\n+\tdump_template_parms): Adjust.\n+\t* parser.c (cp_parser_template_argument_list): Always set defaulted\n+\ttemplate args count when compiled with --enable-checking.\n+\n 2010-01-29  Shujing Zhao  <pearly.zhao@oracle.com>\n \n \t* decl.c (redeclaration_error_message): Wrap the return messages into"}, {"sha": "2f925e15e8ada4512daf0a60ad50817d56e412b5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1a048f8232e75f673c8227b8bcd89e0242946512", "patch": "@@ -2497,6 +2497,23 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define TI_TEMPLATE(NODE) TREE_TYPE (TEMPLATE_INFO_CHECK (NODE))\n #define TI_ARGS(NODE) TREE_CHAIN (TEMPLATE_INFO_CHECK (NODE))\n #define TI_PENDING_TEMPLATE_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n+/* For a given TREE_VEC containing a template argument list,\n+   this property contains the number of arguments that are not\n+   defaulted.  */\n+#define NON_DEFAULT_TEMPLATE_ARGS_COUNT(NODE) TREE_CHAIN (TREE_VEC_CHECK (NODE))\n+/* Below are the setter and getter of the NON_DEFAULT_TEMPLATE_ARGS_COUNT\n+   property.  */\n+#define SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT(NODE, INT_VALUE) \\\n+  NON_DEFAULT_TEMPLATE_ARGS_COUNT(NODE) = build_int_cst (NULL_TREE, INT_VALUE)\n+#ifdef ENABLE_CHECKING\n+#define GET_NON_DEFAULT_TEMPLATE_ARGS_COUNT(NODE) \\\n+    int_cst_value (NON_DEFAULT_TEMPLATE_ARGS_COUNT (NODE))\n+#else\n+#define GET_NON_DEFAULT_TEMPLATE_ARGS_COUNT(NODE) \\\n+  NON_DEFAULT_TEMPLATE_ARGS_COUNT (NODE) \\\n+  ? int_cst_value (NON_DEFAULT_TEMPLATE_ARGS_COUNT (NODE)) \\\n+  : TREE_VEC_LENGTH (INNERMOST_TEMPLATE_ARGS (NODE))\n+#endif\n /* The list of typedefs - used in the template - that need\n    access checking at template instantiation time.  */\n #define TI_TYPEDEFS_NEEDING_ACCESS_CHECKING(NODE) \\\n@@ -2513,7 +2530,13 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n \n    It is incorrect to ever form a template argument vector containing\n    only one level of arguments, but which is a TREE_VEC containing as\n-   its only entry the TREE_VEC for that level.  */\n+   its only entry the TREE_VEC for that level.\n+\n+   For each TREE_VEC containing the template arguments for a single\n+   level, it's possible to get or set the number of non defaulted\n+   template arguments by using the accessor macros\n+   GET_NON_DEFAULT_TEMPLATE_ARGS_COUNT or\n+   SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT.  */\n \n /* Nonzero if the template arguments is actually a vector of vectors,\n    rather than just a vector.  */"}, {"sha": "3d9f1424685a58b01056d2af653c17ef4a8e81e5", "filename": "gcc/cp/error.c", "status": "modified", "additions": 13, "deletions": 43, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=1a048f8232e75f673c8227b8bcd89e0242946512", "patch": "@@ -78,14 +78,12 @@ static void dump_global_iord (tree);\n static void dump_parameters (tree, int);\n static void dump_exception_spec (tree, int);\n static void dump_template_argument (tree, int);\n-static void dump_template_argument_list (tree, tree, int);\n+static void dump_template_argument_list (tree, int);\n static void dump_template_parameter (tree, int);\n static void dump_template_bindings (tree, tree, VEC(tree,gc) *);\n static void dump_scope (tree, int);\n static void dump_template_parms (tree, int, int);\n-\n-static int count_non_default_template_args (tree, tree, int);\n-\n+static int get_non_default_template_args_count (tree, int);\n static const char *function_category (tree);\n static void maybe_print_instantiation_context (diagnostic_context *);\n static void print_instantiation_full_context (diagnostic_context *);\n@@ -147,7 +145,7 @@ static void\n dump_template_argument (tree arg, int flags)\n {\n   if (ARGUMENT_PACK_P (arg))\n-    dump_template_argument_list (ARGUMENT_PACK_ARGS (arg), NULL_TREE, flags);\n+    dump_template_argument_list (ARGUMENT_PACK_ARGS (arg), flags);\n   else if (TYPE_P (arg) || TREE_CODE (arg) == TEMPLATE_DECL)\n     dump_type (arg, flags & ~TFF_CLASS_KEY_OR_ENUM);\n   else\n@@ -163,52 +161,29 @@ dump_template_argument (tree arg, int flags)\n    match the (optional) default template parameter in PARAMS  */\n \n static int\n-count_non_default_template_args (tree args, tree params, int flags)\n+get_non_default_template_args_count (tree args, int flags)\n {\n-  tree inner_args = INNERMOST_TEMPLATE_ARGS (args);\n-  int n = TREE_VEC_LENGTH (inner_args);\n-  int last;\n+  int n = TREE_VEC_LENGTH (INNERMOST_TEMPLATE_ARGS (args));\n \n-  if (params == NULL_TREE\n-      /* We use this flag when generating debug information.  We don't\n+  if (/* We use this flag when generating debug information.  We don't\n \t want to expand templates at this point, for this may generate\n \t new decls, which gets decl counts out of sync, which may in\n \t turn cause codegen differences between compilations with and\n \t without -g.  */\n-      || (flags & TFF_NO_OMIT_DEFAULT_TEMPLATE_ARGUMENTS) != 0\n+      (flags & TFF_NO_OMIT_DEFAULT_TEMPLATE_ARGUMENTS) != 0\n       || !flag_pretty_templates)\n     return n;\n \n-  for (last = n - 1; last >= 0; --last)\n-    {\n-      tree param = TREE_VEC_ELT (params, last);\n-      tree def = TREE_PURPOSE (param);\n-\n-      if (!def)\n-        break;\n-      if (uses_template_parms (def))\n-\t{\n-\t  ++processing_template_decl;\n-\t  /* This speculative substitution must not cause any classes to be\n-\t     instantiated that otherwise wouldn't be.  */\n-\t  def = tsubst_copy_and_build (def, args, tf_no_class_instantiations,\n-\t\t\t\t       NULL_TREE, false, true);\n-\t  --processing_template_decl;\n-\t}\n-      if (!cp_tree_equal (TREE_VEC_ELT (inner_args, last), def))\n-        break;\n-    }\n-\n-  return last + 1;\n+  return GET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (INNERMOST_TEMPLATE_ARGS (args));\n }\n \n /* Dump a template-argument-list ARGS (always a TREE_VEC) under control\n    of FLAGS.  */\n \n static void\n-dump_template_argument_list (tree args, tree parms, int flags)\n+dump_template_argument_list (tree args, int flags)\n {\n-  int n = count_non_default_template_args (args, parms, flags);\n+  int n = get_non_default_template_args_count (args, flags);\n   int need_comma = 0;\n   int i;\n \n@@ -422,7 +397,7 @@ dump_type (tree t, int flags)\n \tpp_cxx_cv_qualifier_seq (cxx_pp, t);\n \tpp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n \tpp_cxx_begin_template_argument_list (cxx_pp);\n-\tdump_template_argument_list (args, NULL_TREE, flags);\n+\tdump_template_argument_list (args, flags);\n \tpp_cxx_end_template_argument_list (cxx_pp);\n       }\n       break;\n@@ -1041,7 +1016,7 @@ dump_decl (tree t, int flags)\n \tdump_decl (name, flags);\n \tpp_cxx_begin_template_argument_list (cxx_pp);\n \tif (TREE_OPERAND (t, 1))\n-\t  dump_template_argument_list (TREE_OPERAND (t, 1), NULL_TREE, flags);\n+\t  dump_template_argument_list (TREE_OPERAND (t, 1), flags);\n \tpp_cxx_end_template_argument_list (cxx_pp);\n       }\n       break;\n@@ -1487,12 +1462,7 @@ dump_template_parms (tree info, int primary, int flags)\n   if (args && !primary)\n     {\n       int len, ix;\n-      /* We don't know the parms for a friend template specialization.  */\n-      tree params = (TREE_CODE (TI_TEMPLATE (info)) == TEMPLATE_DECL\n-\t\t     ? DECL_INNERMOST_TEMPLATE_PARMS (TI_TEMPLATE (info))\n-\t\t     : NULL_TREE);\n-\n-      len = count_non_default_template_args (args, params, flags);\n+      len = get_non_default_template_args_count (args, flags);\n \n       args = INNERMOST_TEMPLATE_ARGS (args);\n       for (ix = 0; ix != len; ix++)"}, {"sha": "cff2c632ad1619775eee0bca25e033b67e19a395", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1a048f8232e75f673c8227b8bcd89e0242946512", "patch": "@@ -11246,6 +11246,9 @@ cp_parser_template_argument_list (cp_parser* parser)\n   parser->non_integral_constant_expression_p = saved_non_ice_p;\n   parser->integral_constant_expression_p = saved_ice_p;\n   parser->in_template_argument_list_p = saved_in_template_argument_list_p;\n+#ifdef ENABLE_CHECKING\n+  SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (vec, TREE_VEC_LENGTH (vec));\n+#endif\n   return vec;\n }\n "}, {"sha": "b903f7735c58e5f9858fc774627a4f1af178b083", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1a048f8232e75f673c8227b8bcd89e0242946512", "patch": "@@ -3207,6 +3207,7 @@ expand_template_argument_pack (tree args)\n   tree result_args = NULL_TREE;\n   int in_arg, out_arg = 0, nargs = args ? TREE_VEC_LENGTH (args) : 0;\n   int num_result_args = -1;\n+  int non_default_args_count = -1;\n \n   /* First, determine if we need to expand anything, and the number of\n      slots we'll need.  */\n@@ -3236,6 +3237,9 @@ expand_template_argument_pack (tree args)\n \n   /* Expand arguments.  */\n   result_args = make_tree_vec (num_result_args);\n+  if (NON_DEFAULT_TEMPLATE_ARGS_COUNT (args))\n+    non_default_args_count =\n+      GET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (args);\n   for (in_arg = 0; in_arg < nargs; ++in_arg)\n     {\n       tree arg = TREE_VEC_ELT (args, in_arg);\n@@ -3245,14 +3249,17 @@ expand_template_argument_pack (tree args)\n           int i, num_packed = TREE_VEC_LENGTH (packed);\n           for (i = 0; i < num_packed; ++i, ++out_arg)\n             TREE_VEC_ELT (result_args, out_arg) = TREE_VEC_ELT(packed, i);\n+\t  if (non_default_args_count > 0)\n+\t    non_default_args_count += num_packed;\n         }\n       else\n         {\n           TREE_VEC_ELT (result_args, out_arg) = arg;\n           ++out_arg;\n         }\n     }\n-\n+  if (non_default_args_count >= 0)\n+    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (result_args, non_default_args_count);\n   return result_args;\n }\n \n@@ -3616,6 +3623,10 @@ current_template_args (void)\n                           /* Turn this argument into a TYPE_ARGUMENT_PACK\n                              with a single element, which expands T.  */\n                           tree vec = make_tree_vec (1);\n+#ifdef ENABLE_CHECKING\n+\t\t\t  SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT\n+\t\t\t\t(vec, TREE_VEC_LENGTH (vec));\n+#endif\n                           TREE_VEC_ELT (vec, 0) = make_pack_expansion (t);\n                           \n                           t = cxx_make_type (TYPE_ARGUMENT_PACK);\n@@ -3632,6 +3643,10 @@ current_template_args (void)\n                              with a single element, which expands T.  */\n                           tree vec = make_tree_vec (1);\n                           tree type = TREE_TYPE (TEMPLATE_PARM_DECL (t));\n+#ifdef ENABLE_CHECKING\n+\t\t\t  SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT\n+\t\t\t\t(vec, TREE_VEC_LENGTH (vec));\n+#endif\n                           TREE_VEC_ELT (vec, 0) = make_pack_expansion (t);\n                           \n                           t  = make_node (NONTYPE_ARGUMENT_PACK);\n@@ -3644,6 +3659,10 @@ current_template_args (void)\n \t    }\n \t}\n \n+#ifdef ENABLE_CHECKING\n+      SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (a, TREE_VEC_LENGTH (a));\n+#endif\n+\n       if (length > 1)\n \tTREE_VEC_ELT (args, --l) = a;\n       else\n@@ -5736,6 +5755,10 @@ coerce_template_parameter_pack (tree parms,\n     }\n \n   SET_ARGUMENT_PACK_ARGS (argument_pack, packed_args);\n+#ifdef ENABLE_CHECKING\n+  SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (packed_args,\n+\t\t\t\t       TREE_VEC_LENGTH (packed_args));\n+#endif\n   return argument_pack;\n }\n \n@@ -5891,9 +5914,16 @@ coerce_template_parms (tree parms,\n             }\n         }\n       else if (require_all_args)\n-        /* There must be a default arg in this case.  */\n-        arg = tsubst_template_arg (TREE_PURPOSE (parm), new_args,\n-                                   complain, in_decl);\n+\t{\n+\t  /* There must be a default arg in this case.  */\n+\t  arg = tsubst_template_arg (TREE_PURPOSE (parm), new_args,\n+\t\t\t\t     complain, in_decl);\n+\t  /* The position of the first default template argument,\n+\t     is also the number of non-defaulted arguments in NEW_INNER_ARGS.\n+\t     Record that.  */\n+\t  if (!NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args))\n+\t    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args, arg_idx);\n+\t}\n       else\n \tbreak;\n \n@@ -5924,6 +5954,12 @@ coerce_template_parms (tree parms,\n   if (lost)\n     return error_mark_node;\n \n+#ifdef ENABLE_CHECKING\n+  if (!NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args))\n+    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args,\n+\t\t\t\t\t TREE_VEC_LENGTH (new_inner_args));\n+#endif\n+\n   return new_inner_args;\n }\n \n@@ -8392,6 +8428,19 @@ tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   /* Make space for the expanded arguments coming from template\n      argument packs.  */\n   t = make_tree_vec (len + expanded_len_adjust);\n+  /* ORIG_T can contain TREE_VECs. That happens if ORIG_T contains the\n+     arguments for a member template.\n+     In that case each TREE_VEC in ORIG_T represents a level of template\n+     arguments, and ORIG_T won't carry any non defaulted argument count.\n+     It will rather be the nested TREE_VECs that will carry one.\n+     In other words, ORIG_T carries a non defaulted argument count only\n+     if it doesn't contain any nested TREE_VEC.  */\n+  if (NON_DEFAULT_TEMPLATE_ARGS_COUNT (orig_t))\n+    {\n+      int count = GET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (orig_t);\n+      count += expanded_len_adjust;\n+      SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (t, count);\n+    }\n   for (i = 0, out = 0; i < len; i++)\n     {\n       if ((PACK_EXPANSION_P (TREE_VEC_ELT (orig_t, i))\n@@ -13247,6 +13296,10 @@ type_unification_real (tree tparms,\n   gcc_assert (xparms == NULL_TREE || TREE_CODE (xparms) == TREE_LIST);\n   gcc_assert (ntparms > 0);\n \n+  /* Reset the number of non-defaulted template arguments contained\n+     in in TARGS.  */\n+  NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs) = NULL_TREE;\n+\n   switch (strict)\n     {\n     case DEDUCE_CALL:\n@@ -13425,6 +13478,11 @@ type_unification_real (tree tparms,\n               else\n                 {\n                   TREE_VEC_ELT (targs, i) = arg;\n+\t\t  /* The position of the first default template argument,\n+\t\t     is also the number of non-defaulted arguments in TARGS.\n+\t\t     Record that.  */\n+\t\t  if (!NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs))\n+\t\t    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs, i);\n                   continue;\n                 }\n             }\n@@ -13452,6 +13510,10 @@ type_unification_real (tree tparms,\n \n \t  return 2;\n \t}\n+#ifdef ENABLE_CHECKING\n+  if (!NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs))\n+    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs, TREE_VEC_LENGTH (targs));\n+#endif\n \n   return 0;\n }"}, {"sha": "273395e1d4734f202e3f07f60f6577c9162d4c39", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a048f8232e75f673c8227b8bcd89e0242946512", "patch": "@@ -1,3 +1,15 @@\n+2010-01-29  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/42758\n+\tPR c++/42634\n+\tPR c++/42336\n+\tPR c++/42797\n+\tPR c++/42880\n+\t* g++.dg/other/crash-5.C: New test.\n+\t* g++.dg/other/crash-6.C: New test.\n+\t* g++.dg/other/crash-7.C: New test.\n+\t* g++.dg/other/crash-8.C: New test.\n+\n 2010-01-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/42889"}, {"sha": "25a70b7df36838db6d23ea98f495070a82b7ecd2", "filename": "gcc/testsuite/g++.dg/other/crash-5.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-5.C?ref=1a048f8232e75f673c8227b8bcd89e0242946512", "patch": "@@ -0,0 +1,16 @@\n+// Origin: PR c++/42758\n+// { dg-do compile }\n+\n+template<class T> struct less {};\n+\n+template<class T, typename U = less<T> > struct set {};\n+\n+struct int_less_than {};\n+\n+void assert_fail (const char*);\n+\n+int f(const set<int, int_less_than>&)\n+{\n+    assert_fail (__PRETTY_FUNCTION__);\n+\n+}"}, {"sha": "2220675dc707a658b79fb3270778602c20a5b874", "filename": "gcc/testsuite/g++.dg/other/crash-6.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-6.C?ref=1a048f8232e75f673c8227b8bcd89e0242946512", "patch": "@@ -0,0 +1,34 @@\n+// Origin: PR c++/42634\n+// { dg-options \"-g -std=c++0x\" }\n+// { dg-do compile }\n+\n+template<typename T> T declval();\n+\n+template<typename T, typename... Args> struct is_constructible {\n+    template<typename T1, typename... Args1> static decltype(T1(declval<Args1>()...), char()) test();\n+    static const bool value = sizeof(test<T, Args...>()) == 1;\n+};\n+template<bool> struct enable_if {\n+        typedef void type;\n+};\n+template<class T1, class T2> struct pair {\n+    template<class U2,\n+             class = typename enable_if<is_constructible<T2,U2&&>::value>::type\n+             >\n+    pair(const T1&, U2&&) { }\n+};\n+struct string {\n+  string() : p(0) {}\n+  char* p;\n+};\n+\n+struct Foo {\n+  string s;\n+  int i;\n+};\n+\n+void f()\n+{\n+  pair<int, Foo>(1, Foo());\n+}\n+"}, {"sha": "d5bc892c07cc8de6d2a36537949293b24449fe8b", "filename": "gcc/testsuite/g++.dg/other/crash-7.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-7.C?ref=1a048f8232e75f673c8227b8bcd89e0242946512", "patch": "@@ -0,0 +1,19 @@\n+// Origin: PR c++/42336\n+// { dg-options \"-std=c++0x -O2 -g\" }\n+// { dg-do compile }\n+\n+struct X {\n+      void func() {}\n+};\n+\n+template<typename T, void (X::*P)() = &T::func>\n+void b(T) {}\n+\n+int main() {\n+      b(X()); /* line 9 */\n+        X().func();\n+\n+          return 0;\n+}\n+\n+"}, {"sha": "c260431d5ec587c1827013cbad67cc9540b9bf22", "filename": "gcc/testsuite/g++.dg/other/crash-8.C", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a048f8232e75f673c8227b8bcd89e0242946512/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcrash-8.C?ref=1a048f8232e75f673c8227b8bcd89e0242946512", "patch": "@@ -0,0 +1,109 @@\n+// Origin: PR c++/42797\n+// { dg-options \"-g -O2 -std=c++0x\" }\n+\n+template<typename _Tp, _Tp __v>     struct integral_constant     {\n+    static const _Tp value = __v;\n+};\n+\n+template<typename _Tp>     _Tp declval();\n+\n+template<typename _Tp, typename... _Args>\n+class __is_constructible_helper  {\n+};\n+\n+template<typename _Tp, typename _Arg>\n+class __is_constructible_helper<_Tp, _Arg>  {\n+\n+    template<typename _Tp1, typename _Arg1>\n+    static decltype(static_cast<_Tp1>(declval<_Arg1>()), char())  __test(int);\n+public:\n+    static const bool __value = sizeof(__test<_Tp, _Arg>(0)) == 1;\n+};\n+\n+template<typename _Tp, typename... _Args>\n+struct is_constructible     : public integral_constant<bool,__is_constructible_helper<_Tp, _Args...>::__value>     { };\n+\n+template<bool, typename _Tp = void>\n+struct enable_if  { };\n+\n+template<typename _Tp>\n+struct enable_if<true, _Tp>     {\n+    typedef _Tp type;\n+};\n+\n+template<class _T1, class _T2>     struct pair     {\n+    _T1 first;\n+    _T2 second;\n+\n+    template<class _U2, class = typename  enable_if<is_constructible<_T2, _U2&&>::value>::type>\n+    pair(const _T1& __x, _U2&& __y)  : first(__x),\n+                                       second(__y) { }\n+};\n+\n+namespace __gnu_cxx {\n+template<typename _Tp>\n+class new_allocator     {\n+public:\n+    new_allocator() throw() { }\n+    new_allocator(const new_allocator&) throw() { }\n+};\n+}\n+\n+template<typename _Tp>\n+class allocator: public __gnu_cxx::new_allocator<_Tp>     {\n+public:\n+\n+    template<typename _Tp1>\n+    struct rebind  {\n+        typedef allocator<_Tp1> other;\n+    };\n+};\n+\n+\n+template<typename _Tp, typename _Alloc>     struct _Vector_base     {\n+    typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;\n+\n+    struct _Vector_impl       : public _Tp_alloc_type   {\n+        _Vector_impl()\n+        { }\n+    };\n+public:\n+\n+    _Vector_impl _M_impl;\n+};\n+\n+template<typename _Tp, typename _Alloc = allocator<_Tp> >\n+class vector : protected _Vector_base<_Tp, _Alloc> {\n+    typedef _Alloc allocator_type;\n+public:\n+    vector()       { }\n+    explicit       vector(int, const allocator_type& __a = allocator_type())\n+    {\n+    }\n+};\n+\n+\n+template <typename _Key, typename _Tp>\n+class map {\n+    typedef _Key key_type;\n+    typedef _Tp mapped_type;\n+    typedef pair<const _Key, _Tp> value_type;\n+public:\n+\n+    void insert(const value_type& __x)\n+    {\n+    }\n+\n+    mapped_type&       operator[](const key_type& __k)       {\n+        insert(value_type(__k, mapped_type()));\n+    }\n+\n+};\n+\n+struct Foo {\n+    Foo() {}      template<typename Tp>     Foo(Tp *p) {} };\n+void foo() {\n+    map <int, vector<Foo>> the_map;\n+    the_map[1] = vector<Foo>();\n+}\n+"}]}