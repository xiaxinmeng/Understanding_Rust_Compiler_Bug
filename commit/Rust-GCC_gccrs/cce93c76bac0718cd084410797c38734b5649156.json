{"sha": "cce93c76bac0718cd084410797c38734b5649156", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NlOTNjNzZiYWMwNzE4Y2QwODQ0MTA3OTdjMzg3MzRiNTY0OTE1Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-01-22T09:21:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-01-22T09:21:48Z"}, "message": "re PR libstdc++/64535 (Emergency buffer for exception allocation too small)\n\n2015-01-22  Richard Biener  <rguenther@suse.de>\n\n\tPR libstdc++/64535\n\t* libsupc++/eh_alloc.cc: Include new.\n\t(bitmask_type): Remove.\n\t(one_buffer): Likewise.\n\t(emergency_buffer): Likewise.\n\t(emergency_used): Likewise.\n\t(dependents_buffer): Likewise.\n\t(dependents_used): Likewise.\n\t(class pool): New custom fixed-size arena, variable size object\n\tallocator.\n\t(emergency_pool): New global.\n\t(__cxxabiv1::__cxa_allocate_exception): Use new emergency_pool.\n\t(__cxxabiv1::__cxa_free_exception): Likewise.\n\t(__cxxabiv1::__cxa_allocate_dependent_exception): Likewise.\n\t(__cxxabiv1::__cxa_free_dependent_exception): Likewise.\n\n\t* g++.old-deja/g++.eh/badalloc1.C: Adjust.\n\nFrom-SVN: r219988", "tree": {"sha": "abf3aa1d03797c5bd51f6b44701776fde16675dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abf3aa1d03797c5bd51f6b44701776fde16675dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cce93c76bac0718cd084410797c38734b5649156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce93c76bac0718cd084410797c38734b5649156", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cce93c76bac0718cd084410797c38734b5649156", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce93c76bac0718cd084410797c38734b5649156/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "770acfc9e3753d7b9d4727293ac6f16811fa751f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770acfc9e3753d7b9d4727293ac6f16811fa751f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/770acfc9e3753d7b9d4727293ac6f16811fa751f"}], "stats": {"total": 295, "additions": 208, "deletions": 87}, "files": [{"sha": "8246787f8aa974df525d1ddc886b6058192e7e30", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce93c76bac0718cd084410797c38734b5649156/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce93c76bac0718cd084410797c38734b5649156/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cce93c76bac0718cd084410797c38734b5649156", "patch": "@@ -1,3 +1,8 @@\n+2015-01-22  Richard Biener  <rguenther@suse.de>\n+\n+\tPR libstdc++/64535\n+\t* g++.old-deja/g++.eh/badalloc1.C: Adjust.\n+\n 2015-01-21  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/64682"}, {"sha": "f4f443bd325f244228d7aeeec491f2ff354d5f2e", "filename": "gcc/testsuite/g++.old-deja/g++.eh/badalloc1.C", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce93c76bac0718cd084410797c38734b5649156/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fbadalloc1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce93c76bac0718cd084410797c38734b5649156/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fbadalloc1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fbadalloc1.C?ref=cce93c76bac0718cd084410797c38734b5649156", "patch": "@@ -12,21 +12,24 @@ typedef __SIZE_TYPE__ size_t;\n extern \"C\" void abort();\n extern \"C\" void *memcpy(void *, const void *, size_t);\n \n+// libstdc++ requires a large initialization time allocation for the\n+// emergency EH allocation pool.  Add that to the arena size.\n+\n // Assume that STACK_SIZE defined implies a system that does not have a\n // large data space either, and additionally that we're not linking against\n // a shared libstdc++ (which requires quite a bit more initialization space).\n #ifdef STACK_SIZE\n-const int arena_size = 256;\n+const int arena_size = 256 + 8 * 128;\n #else\n #if defined(__FreeBSD__) || defined(__sun__) || defined(__hpux__)\n // FreeBSD, Solaris and HP-UX require even more space at initialization time.\n // FreeBSD 5 now requires over 131072 bytes.\n-const int arena_size = 262144;\n+const int arena_size = 262144 + 72 * 1024;\n #else\n // Because pointers make up the bulk of our exception-initialization\n // allocations, we scale by the pointer size from the original\n // 32-bit-systems-based estimate.\n-const int arena_size = 32768 * ((sizeof (void *) + 3)/4);\n+const int arena_size = 32768 * ((sizeof (void *) + 3)/4) + 72 * 1024;\n #endif\n #endif\n "}, {"sha": "ffa74961b804cf903872654a3be2a59d135a06e0", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce93c76bac0718cd084410797c38734b5649156/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce93c76bac0718cd084410797c38734b5649156/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=cce93c76bac0718cd084410797c38734b5649156", "patch": "@@ -1,3 +1,21 @@\n+2015-01-22  Richard Biener  <rguenther@suse.de>\n+\n+\tPR libstdc++/64535\n+\t* libsupc++/eh_alloc.cc: Include new.\n+\t(bitmask_type): Remove.\n+\t(one_buffer): Likewise.\n+\t(emergency_buffer): Likewise.\n+\t(emergency_used): Likewise.\n+\t(dependents_buffer): Likewise.\n+\t(dependents_used): Likewise.\n+\t(class pool): New custom fixed-size arena, variable size object\n+\tallocator.\n+\t(emergency_pool): New global.\n+\t(__cxxabiv1::__cxa_allocate_exception): Use new emergency_pool.\n+\t(__cxxabiv1::__cxa_free_exception): Likewise.\n+\t(__cxxabiv1::__cxa_allocate_dependent_exception): Likewise.\n+\t(__cxxabiv1::__cxa_free_dependent_exception): Likewise.\n+\n 2015-01-22  Tim Shen  <timshen@google.com>\n \n \tPR libstdc++/64680"}, {"sha": "c77f53fdf025616a32b205883aa06cae30a4b880", "filename": "libstdc++-v3/libsupc++/eh_alloc.cc", "status": "modified", "additions": 179, "deletions": 84, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce93c76bac0718cd084410797c38734b5649156/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce93c76bac0718cd084410797c38734b5649156/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc?ref=cce93c76bac0718cd084410797c38734b5649156", "patch": "@@ -34,6 +34,7 @@\n #include <exception>\n #include \"unwind-cxx.h\"\n #include <ext/concurrence.h>\n+#include <new>\n \n #if _GLIBCXX_HOSTED\n using std::free;\n@@ -72,28 +73,174 @@ using namespace __cxxabiv1;\n # define EMERGENCY_OBJ_COUNT\t4\n #endif\n \n-#if INT_MAX == 32767 || EMERGENCY_OBJ_COUNT <= 32\n-typedef unsigned int bitmask_type;\n-#else\n-#if defined (_GLIBCXX_LLP64)\n-typedef unsigned long long bitmask_type;\n-#else\n-typedef unsigned long bitmask_type;\n-#endif\n-#endif\n \n+namespace\n+{\n+  // A fixed-size heap, variable size object allocator\n+  class pool\n+    {\n+    public:\n+      pool();\n+\n+      void *allocate (std::size_t);\n+      void free (void *);\n+\n+      bool in_pool (void *);\n+\n+    private:\n+      struct free_entry {\n+\tstd::size_t size;\n+\tfree_entry *next;\n+      };\n+      struct allocated_entry {\n+\tstd::size_t size;\n+\tchar data[];\n+      };\n+\n+      // A single mutex controlling emergency allocations.\n+      __gnu_cxx::__mutex emergency_mutex;\n+\n+      // The free-list\n+      free_entry *first_free_entry;\n+      // The arena itself - we need to keep track of these only\n+      // to implement in_pool.\n+      char *arena;\n+      std::size_t arena_size;\n+    };\n+\n+  pool::pool()\n+    {\n+      // Allocate the arena - we could add a GLIBCXX_EH_ARENA_SIZE environment\n+      // to make this tunable.\n+      arena_size = (EMERGENCY_OBJ_SIZE * EMERGENCY_OBJ_COUNT\n+\t\t    + EMERGENCY_OBJ_COUNT * sizeof (__cxa_dependent_exception));\n+      arena = (char *)malloc (arena_size);\n+      if (!arena)\n+\t{\n+\t  // If the allocation failed go without an emergency pool.\n+\t  arena_size = 0;\n+\t  first_free_entry = NULL;\n+\t  return;\n+\t}\n \n-typedef char one_buffer[EMERGENCY_OBJ_SIZE] __attribute__((aligned));\n-static one_buffer emergency_buffer[EMERGENCY_OBJ_COUNT];\n-static bitmask_type emergency_used;\n+      // Populate the free-list with a single entry covering the whole arena\n+      first_free_entry = reinterpret_cast <free_entry *> (arena);\n+      new (first_free_entry) free_entry;\n+      first_free_entry->size = arena_size;\n+      first_free_entry->next = NULL;\n+    }\n \n-static __cxa_dependent_exception dependents_buffer[EMERGENCY_OBJ_COUNT];\n-static bitmask_type dependents_used;\n+  void *pool::allocate (std::size_t size)\n+    {\n+      __gnu_cxx::__scoped_lock sentry(emergency_mutex);\n+      // We need an additional size_t member.\n+      size += sizeof (std::size_t);\n+      // And we need to at least hand out objects of the size of\n+      // a freelist entry.\n+      if (size < sizeof (free_entry))\n+\tsize = sizeof (free_entry);\n+      // And we need to align objects we hand out to the required\n+      // alignment of a freelist entry (this really aligns the\n+      // tail which will become a new freelist entry).\n+      size = ((size + __alignof__(free_entry) - 1)\n+\t      & ~(__alignof__(free_entry) - 1));\n+      // Search for an entry of proper size on the freelist.\n+      free_entry **e;\n+      for (e = &first_free_entry;\n+\t   *e && (*e)->size < size;\n+\t   e = &(*e)->next)\n+\t;\n+      if (!*e)\n+\treturn NULL;\n+      allocated_entry *x;\n+      if ((*e)->size - size >= sizeof (free_entry))\n+\t{\n+\t  // Slit block if it is too large.\n+\t  free_entry *f = reinterpret_cast <free_entry *>\n+\t      (reinterpret_cast <char *> (*e) + size);\n+\t  std::size_t sz = (*e)->size;\n+\t  free_entry *next = (*e)->next;\n+\t  new (f) free_entry;\n+\t  f->next = next;\n+\t  f->size = sz - size;\n+\t  x = reinterpret_cast <allocated_entry *> (*e);\n+\t  new (x) allocated_entry;\n+\t  x->size = size;\n+\t  *e = f;\n+\t}\n+      else\n+\t{\n+\t  // Exact size match or too small overhead for a free entry.\n+\t  std::size_t sz = (*e)->size;\n+\t  free_entry *next = (*e)->next;\n+\t  x = reinterpret_cast <allocated_entry *> (*e);\n+\t  new (x) allocated_entry;\n+\t  x->size = sz;\n+\t  *e = next;\n+\t}\n+      return &x->data;\n+    }\n \n-namespace\n-{\n-  // A single mutex controlling emergency allocations.\n-  __gnu_cxx::__mutex emergency_mutex;\n+  void pool::free (void *data)\n+    {\n+      __gnu_cxx::__scoped_lock sentry(emergency_mutex);\n+      allocated_entry *e = reinterpret_cast <allocated_entry *>\n+\t(reinterpret_cast <char *> (data) - sizeof (std::size_t));\n+      std::size_t sz = e->size;\n+      if (!first_free_entry)\n+\t{\n+\t  // If the free list is empty just put the entry there.\n+\t  free_entry *f = reinterpret_cast <free_entry *> (e);\n+\t  new (f) free_entry;\n+\t  f->size = sz;\n+\t  f->next = NULL;\n+\t  first_free_entry = f;\n+\t}\n+      else if (reinterpret_cast <char *> (e) + sz\n+\t       == reinterpret_cast <char *> (first_free_entry))\n+\t{\n+\t  // Check if we can merge with the first free entry being right\n+\t  // after us.\n+\t  free_entry *f = reinterpret_cast <free_entry *> (e);\n+\t  new (f) free_entry;\n+\t  f->size = sz + first_free_entry->size;\n+\t  f->next = first_free_entry->next;\n+\t  first_free_entry = f;\n+\t}\n+      else\n+\t{\n+\t  // Else search for a free item we can merge with at its end.\n+\t  free_entry **fe;\n+\t  for (fe = &first_free_entry;\n+\t       (*fe)->next\n+\t       && (reinterpret_cast <char *> ((*fe)->next)\n+\t\t   > reinterpret_cast <char *> (e) + sz);\n+\t       fe = &(*fe)->next)\n+\t    ;\n+\t  if (reinterpret_cast <char *> (*fe) + (*fe)->size\n+\t      == reinterpret_cast <char *> (e))\n+\t    /* Merge with the freelist entry.  */\n+\t    (*fe)->size += sz;\n+\t  else\n+\t    {\n+\t      // Else put it after it which keeps the freelist sorted.\n+\t      free_entry *f = reinterpret_cast <free_entry *> (e);\n+\t      new (f) free_entry;\n+\t      f->size = sz;\n+\t      f->next = (*fe)->next;\n+\t      (*fe)->next = f;\n+\t    }\n+\t}\n+    }\n+\n+  bool pool::in_pool (void *ptr)\n+    {\n+      char *p = reinterpret_cast <char *> (ptr);\n+      return (p > arena\n+\t      && p < arena + arena_size);\n+    }\n+\n+  pool emergency_pool;\n }\n \n extern \"C\" void *\n@@ -104,30 +251,11 @@ __cxxabiv1::__cxa_allocate_exception(std::size_t thrown_size) _GLIBCXX_NOTHROW\n   thrown_size += sizeof (__cxa_refcounted_exception);\n   ret = malloc (thrown_size);\n \n-  if (! ret)\n-    {\n-      __gnu_cxx::__scoped_lock sentry(emergency_mutex);\n-\n-      bitmask_type used = emergency_used;\n-      unsigned int which = 0;\n-\n-      if (thrown_size > EMERGENCY_OBJ_SIZE)\n-\tgoto failed;\n-      while (used & 1)\n-\t{\n-\t  used >>= 1;\n-\t  if (++which >= EMERGENCY_OBJ_COUNT)\n-\t    goto failed;\n-\t}\n-\n-      emergency_used |= (bitmask_type)1 << which;\n-      ret = &emergency_buffer[which][0];\n-\n-    failed:;\n+  if (!ret)\n+    ret = emergency_pool.allocate (thrown_size);\n \n-      if (!ret)\n-\tstd::terminate ();\n-    }\n+  if (!ret)\n+    std::terminate ();\n \n   memset (ret, 0, sizeof (__cxa_refcounted_exception));\n \n@@ -138,19 +266,11 @@ __cxxabiv1::__cxa_allocate_exception(std::size_t thrown_size) _GLIBCXX_NOTHROW\n extern \"C\" void\n __cxxabiv1::__cxa_free_exception(void *vptr) _GLIBCXX_NOTHROW\n {\n-  char *base = (char *) emergency_buffer;\n-  char *ptr = (char *) vptr;\n-  if (ptr >= base\n-      && ptr < base + sizeof (emergency_buffer))\n-    {\n-      const unsigned int which\n-\t= (unsigned) (ptr - base) / EMERGENCY_OBJ_SIZE;\n-\n-      __gnu_cxx::__scoped_lock sentry(emergency_mutex);\n-      emergency_used &= ~((bitmask_type)1 << which);\n-    }\n+  char *ptr = (char *) vptr - sizeof (__cxa_refcounted_exception);\n+  if (emergency_pool.in_pool (ptr))\n+    emergency_pool.free (ptr);\n   else\n-    free (ptr - sizeof (__cxa_refcounted_exception));\n+    free (ptr);\n }\n \n \n@@ -163,27 +283,11 @@ __cxxabiv1::__cxa_allocate_dependent_exception() _GLIBCXX_NOTHROW\n     (malloc (sizeof (__cxa_dependent_exception)));\n \n   if (!ret)\n-    {\n-      __gnu_cxx::__scoped_lock sentry(emergency_mutex);\n-\n-      bitmask_type used = dependents_used;\n-      unsigned int which = 0;\n-\n-      while (used & 1)\n-\t{\n-\t  used >>= 1;\n-\t  if (++which >= EMERGENCY_OBJ_COUNT)\n-\t    goto failed;\n-\t}\n-\n-      dependents_used |= (bitmask_type)1 << which;\n-      ret = &dependents_buffer[which];\n+    ret = static_cast <__cxa_dependent_exception*>\n+      (emergency_pool.allocate (sizeof (__cxa_dependent_exception)));\n \n-    failed:;\n-\n-      if (!ret)\n-\tstd::terminate ();\n-    }\n+  if (!ret)\n+    std::terminate ();\n \n   memset (ret, 0, sizeof (__cxa_dependent_exception));\n \n@@ -195,17 +299,8 @@ extern \"C\" void\n __cxxabiv1::__cxa_free_dependent_exception\n   (__cxa_dependent_exception *vptr) _GLIBCXX_NOTHROW\n {\n-  char *base = (char *) dependents_buffer;\n-  char *ptr = (char *) vptr;\n-  if (ptr >= base\n-      && ptr < base + sizeof (dependents_buffer))\n-    {\n-      const unsigned int which\n-\t= (unsigned) (ptr - base) / sizeof (__cxa_dependent_exception);\n-\n-      __gnu_cxx::__scoped_lock sentry(emergency_mutex);\n-      dependents_used &= ~((bitmask_type)1 << which);\n-    }\n+  if (emergency_pool.in_pool (vptr))\n+    emergency_pool.free (vptr);\n   else\n     free (vptr);\n }"}]}