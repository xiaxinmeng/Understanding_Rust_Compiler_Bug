{"sha": "c7303e411e27224a555ee8fae64bb421c26425cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzczMDNlNDExZTI3MjI0YTU1NWVlOGZhZTY0YmI0MjFjMjY0MjVjZg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-12-06T18:55:42Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-12-06T18:55:42Z"}, "message": "[multiple changes]\n\n2000-10-18  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * jcf-write.c (OP1): Update `last_bc'.\n        (struct jcf_block): Fixed indentation and typo in comments.  New\n        field `last_bc'.\n        (generate_bytecode_insns): Insert `nop' if `jsr' immediately\n        follows `monitorenter'.\n        * parse.y (patch_synchronized_statement): New local `tmp'. Call\n        `patch_string'.\n        Fixes gcj/232.\n\n2000-10-13  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * check-init.c (check_init): Fixed leading comment. Use\n        LOCAL_FINAL_P.\n        * decl.c (push_jvm_slot): Use MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC.\n        (give_name_to_locals): Likewise.\n        (lang_mark_tree): Handle FIELD_DECL. Register `am' and `wfl'\n        fields in lang_decl_var.\n        * java-tree.h (DECL_FUNCTION_SYNTHETIC_CTOR,\n        DECL_FUNCTION_ALL_FINAL_INITIALIZED): New macros.\n        (FIELD_INNER_ACCESS): Removed ugly cast, macro rewritten.\n        (FIELD_INNER_ACCESS_P, DECL_FIELD_FINAL_IUD, DECL_FIELD_FINAL_LIIC,\n        DECL_FIELD_FINAL_IERR, DECL_FIELD_FINAL_WFL): New macros.\n        (LOCAL_FINAL): Rewritten.\n        (LOCAL_FINAL_P, FINAL_VARIABLE_P, CLASS_FINAL_VARIABLE_P\n        MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC): New macros.\n        (struct lang_decl): Fixed comments. Added `synthetic_ctor' and\n        `init_final' fields.\n        (struct lang_decl_var): Fixed leading comment. Added `am', `wfl',\n        `final_uid', `final_liic', `final_ierr' and `local_final' fields.\n        (TYPE_HAS_FINAL_VARIABLE): New macro.\n        (struct lang_type): Added `afv' field.\n        * parse.y (check_static_final_variable_assignment_flag): New function.\n        (reset_static_final_variable_assignment_flag): Likewise.\n        (check_final_variable_local_assignment_flag): Likewise.\n        (reset_final_variable_local_assignment_flag): Likewise.\n        (check_final_variable_indirect_assignment): Likewise.\n        (check_final_variable_global_assignment_flag): Likewise.\n        (add_inner_class_fields): Use LOCAL_FINAL_P.\n        (register_fields): Handle local finals and final variables.\n        (craft_constructor): Set DECL_FUNCTION_SYNTHETIC_CTOR.\n        (declare_local_variables): Call MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC.\n        (source_start_java_method): Call MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC\n        on local finals.\n        (java_complete_expand_methods): Loop to set\n        TYPE_HAS_FINAL_VARIABLE. Call\n        `reset_final_variable_local_assignment_flag' and\n        `check_final_variable_local_assignment_flag' accordingly before\n        and after constructor expansion. Call\n        `reset_static_final_variable_assignment_flag'\n        before expanding <clinit> and after call\n        `check_static_final_variable_assignment_flag' if the\n        current_class isn't an interface. After all methods have been\n        expanded, call `check_final_variable_global_assignment_flag' and\n        `check_static_final_variable_assignment_flag' if the current class\n        is an interface.\n        (maybe_yank_clinit): Fixed typo in comment.\n        (build_outer_field_access_methods): Removed old sanity check. Use\n        FIELD_INNER_ACCESS_P. Call MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC.\n        Don't create access methods for finals.\n        (resolve_field_access): Use `CLASS_FINAL_VARIABLE_P'.\n        (java_complete_tree): Likewise. Reset DECL_FIELD_FINAL_IUD if\n        existing DECL_INIT has been processed.\n        (java_complete_lhs): Likewise.\n        (check_final_assignment): Filter input on `lvalue''s TREE_CODE.\n        Test for COMPONENT_REF to get to the FIELD_DECL. Implemented new\n        logic.\n        (patch_assignment): Use LOCAL_FINAL_P.\n        (fold_constant_for_init): Reset DECL_FIELD_FINAL_IUD if\n        DECL_INITIAL is nullified.\n        Fixes gcj/163.\n\n2000-10-09  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * parse.y (pop_current_osb): New function.\n        (array_type:): Use `dims:', changed actions\n        accordingly. Suggested by Anthony Green.\n        (array_creation_expression:): Used pop_current_osb.\n        (cast_expression:): Likewise.\n        (search_applicable_method_list): Fixed indentation.\n\n2000-10-08  Anthony Green  <green@redhat.com>\n\n        * parse.y (array_type_literal): Remove production.\n        (type_literals): Refer to array_type, not array_type_literal.\n\n(http://gcc.gnu.org/ml/gcc-patches/2000-12/msg00317.html)\n\nFrom-SVN: r38070", "tree": {"sha": "bab5cce64b7453c82f9667ebeaae7027f855769d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bab5cce64b7453c82f9667ebeaae7027f855769d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7303e411e27224a555ee8fae64bb421c26425cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7303e411e27224a555ee8fae64bb421c26425cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7303e411e27224a555ee8fae64bb421c26425cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7303e411e27224a555ee8fae64bb421c26425cf/comments", "author": null, "committer": null, "parents": [{"sha": "ee4570050a9b98deda6ec035906037a9e39c8335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee4570050a9b98deda6ec035906037a9e39c8335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee4570050a9b98deda6ec035906037a9e39c8335"}], "stats": {"total": 687, "additions": 573, "deletions": 114}, "files": [{"sha": "895f618eb24599160b091de099949e3faae89f54", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c7303e411e27224a555ee8fae64bb421c26425cf", "patch": "@@ -235,6 +235,17 @@ Thu Nov 23 02:19:14 2000  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* verify.c (CHECK_PC_IN_RANGE): Cast result of stmt-expr to void.\n \n+2000-10-18  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* jcf-write.c (OP1): Update `last_bc'.\n+\t(struct jcf_block): Fixed indentation and typo in comments.  New\n+\tfield `last_bc'.\n+\t(generate_bytecode_insns): Insert `nop' if `jsr' immediately\n+\tfollows `monitorenter'.\n+\t* parse.y (patch_synchronized_statement): New local `tmp'. Call\n+\t`patch_string'.\n+\tFixes gcj/232.\n+\n 2000-10-16  Tom Tromey  <tromey@cygnus.com>\n \n \t* jvspec.c (lang_specific_driver): Recognize -MF and -MT.\n@@ -298,6 +309,68 @@ Thu Nov 23 02:19:14 2000  J\"orn Rennecke <amylaar@redhat.com>\n \t* decl.c (init_decl_processing): Call init_class_processing before\n \tanything else.\n \n+2000-10-13  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* check-init.c (check_init): Fixed leading comment. Use\n+\tLOCAL_FINAL_P.\n+\t* decl.c (push_jvm_slot): Use MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC.\n+\t(give_name_to_locals): Likewise.\n+\t(lang_mark_tree): Handle FIELD_DECL. Register `am' and `wfl'\n+\tfields in lang_decl_var.\n+\t* java-tree.h (DECL_FUNCTION_SYNTHETIC_CTOR,\n+\tDECL_FUNCTION_ALL_FINAL_INITIALIZED): New macros.\n+\t(FIELD_INNER_ACCESS): Removed ugly cast, macro rewritten.\n+\t(FIELD_INNER_ACCESS_P, DECL_FIELD_FINAL_IUD, DECL_FIELD_FINAL_LIIC,\n+\tDECL_FIELD_FINAL_IERR, DECL_FIELD_FINAL_WFL): New macros.\n+\t(LOCAL_FINAL): Rewritten.\n+\t(LOCAL_FINAL_P, FINAL_VARIABLE_P, CLASS_FINAL_VARIABLE_P\n+\tMAYBE_CREATE_VAR_LANG_DECL_SPECIFIC): New macros.\n+\t(struct lang_decl): Fixed comments. Added `synthetic_ctor' and\n+\t`init_final' fields.\n+\t(struct lang_decl_var): Fixed leading comment. Added `am', `wfl',\n+\t`final_uid', `final_liic', `final_ierr' and `local_final' fields.\n+\t(TYPE_HAS_FINAL_VARIABLE): New macro.\n+\t(struct lang_type): Added `afv' field.\n+\t* parse.y (check_static_final_variable_assignment_flag): New function.\n+\t(reset_static_final_variable_assignment_flag): Likewise.\n+\t(check_final_variable_local_assignment_flag): Likewise.\n+\t(reset_final_variable_local_assignment_flag): Likewise.\n+\t(check_final_variable_indirect_assignment): Likewise.\n+\t(check_final_variable_global_assignment_flag): Likewise.\n+\t(add_inner_class_fields): Use LOCAL_FINAL_P.\n+\t(register_fields): Handle local finals and final variables.\n+\t(craft_constructor): Set DECL_FUNCTION_SYNTHETIC_CTOR.\n+\t(declare_local_variables): Call MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC.\n+\t(source_start_java_method): Call MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC\n+\ton local finals.\n+\t(java_complete_expand_methods): Loop to set\n+\tTYPE_HAS_FINAL_VARIABLE. Call\n+\t`reset_final_variable_local_assignment_flag' and \n+\t`check_final_variable_local_assignment_flag' accordingly before\n+\tand after constructor expansion. Call\n+\t`reset_static_final_variable_assignment_flag'\n+\tbefore expanding <clinit> and after call \n+\t`check_static_final_variable_assignment_flag' if the\n+\tcurrent_class isn't an interface. After all methods have been\n+\texpanded, call `check_final_variable_global_assignment_flag' and\n+\t`check_static_final_variable_assignment_flag' if the current class\n+\tis an interface. \n+\t(maybe_yank_clinit): Fixed typo in comment.\n+\t(build_outer_field_access_methods): Removed old sanity check. Use\n+\tFIELD_INNER_ACCESS_P. Call MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC.\n+\tDon't create access methods for finals.\n+\t(resolve_field_access): Use `CLASS_FINAL_VARIABLE_P'.\n+\t(java_complete_tree): Likewise. Reset DECL_FIELD_FINAL_IUD if\n+\texisting DECL_INIT has been processed. \n+\t(java_complete_lhs): Likewise.\n+\t(check_final_assignment): Filter input on `lvalue''s TREE_CODE.\n+\tTest for COMPONENT_REF to get to the FIELD_DECL. Implemented new\n+\tlogic.\n+\t(patch_assignment): Use LOCAL_FINAL_P.\n+\t(fold_constant_for_init): Reset DECL_FIELD_FINAL_IUD if\n+\tDECL_INITIAL is nullified.\n+\tFixes gcj/163.\n+\n 2000-10-13  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Make-lang.in (parse.c, parse-scan.c): Create atomically.\n@@ -403,6 +476,20 @@ Thu Nov 23 02:19:14 2000  J\"orn Rennecke <amylaar@redhat.com>\n \tfields.\n \t* lex.h (java_lexer): Added out_buffer, out_first, out_last.\n \n+2000-10-09  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (pop_current_osb): New function.\n+\t(array_type:): Use `dims:', changed actions\n+\taccordingly. Suggested by Anthony Green.\n+\t(array_creation_expression:): Used pop_current_osb.\n+\t(cast_expression:): Likewise.\n+\t(search_applicable_method_list): Fixed indentation.\n+\n+2000-10-08  Anthony Green  <green@redhat.com>\n+\n+\t* parse.y (array_type_literal): Remove production.\n+\t(type_literals): Refer to array_type, not array_type_literal.\n+\n 2000-10-07  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \tPatch contributed by Corey Minyard."}, {"sha": "7de0e183b3a433acb9bebe4a59e2697681473941", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=c7303e411e27224a555ee8fae64bb421c26425cf", "patch": "@@ -356,8 +356,7 @@ done_alternative (after, current)\n   start_current_locals = current.save_start_current_locals; \\\n }\n \n-/* Check for (un)initialized local variables in EXP.\n-*/\n+/* Check for (un)initialized local variables in EXP.  */\n \n static void\n check_init (exp, before)\n@@ -387,14 +386,14 @@ check_init (exp, before)\n       /* We're interested in variable declaration and parameter\n          declaration when they're declared with the `final' modifier. */\n       if ((TREE_CODE (tmp) == VAR_DECL && ! FIELD_STATIC (tmp))\n-\t  || (TREE_CODE (tmp) == PARM_DECL && LOCAL_FINAL (tmp)))\n+\t  || (TREE_CODE (tmp) == PARM_DECL && LOCAL_FINAL_P (tmp)))\n \t{\n \t  int index;\n \t  check_init (TREE_OPERAND (exp, 1), before);\n \t  index = DECL_BIT_INDEX (tmp);\n \t  /* A final local already assigned or a final parameter\n              assigned must be reported as errors */\n-\t  if (LOCAL_FINAL (tmp) \n+\t  if (LOCAL_FINAL_P (tmp)\n \t      && (index == -1 || TREE_CODE (tmp) == PARM_DECL))\n \t    parse_error_context (wfl, \"Can't assign here a value to the `final' variable `%s'\", IDENTIFIER_POINTER (DECL_NAME (tmp)));\n "}, {"sha": "0ed71700bde8ee5ffe4e2871ec10e96de8306526", "filename": "gcc/java/decl.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=c7303e411e27224a555ee8fae64bb421c26425cf", "patch": "@@ -127,8 +127,7 @@ push_jvm_slot (index, decl)\n   /* Now link the decl into the decl_map. */\n   if (DECL_LANG_SPECIFIC (decl) == NULL)\n     {\n-      DECL_LANG_SPECIFIC (decl)\n-\t= (struct lang_decl *) ggc_alloc (sizeof (struct lang_decl_var));\n+      MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n       DECL_LOCAL_START_PC (decl) = 0;\n       DECL_LOCAL_END_PC (decl) = DECL_CODE_LENGTH (current_function_decl);\n       DECL_LOCAL_SLOT_NUMBER (decl) = index;\n@@ -1620,8 +1619,7 @@ give_name_to_locals (jcf)\n \t     comments for expr.c:maybe_adjust_start_pc. */\n \t  start_pc = maybe_adjust_start_pc (jcf, code_offset, start_pc, slot);\n \n-\t  DECL_LANG_SPECIFIC (decl)\n-\t    = (struct lang_decl *) ggc_alloc (sizeof (struct lang_decl_var));\n+\t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n \t  DECL_LOCAL_SLOT_NUMBER (decl) = slot;\n \t  DECL_LOCAL_START_PC (decl) = start_pc;\n #if 0\n@@ -1901,14 +1899,17 @@ lang_mark_tree (t)\n       ggc_mark_tree (li->utf8_ref);\n     }\n   else if (TREE_CODE (t) == VAR_DECL\n-\t   || TREE_CODE (t) == PARM_DECL)\n+\t   || TREE_CODE (t) == PARM_DECL\n+\t   || TREE_CODE (t) == FIELD_DECL)\n     {\n       struct lang_decl_var *ldv = \n \t((struct lang_decl_var *) DECL_LANG_SPECIFIC (t));\n       if (ldv)\n \t{\n \t  ggc_mark (ldv);\n \t  ggc_mark_tree (ldv->slot_chain);\n+\t  ggc_mark_tree (ldv->am);\n+\t  ggc_mark_tree (ldv->wfl);\n \t}\n     }\n   else if (TREE_CODE (t) == FUNCTION_DECL)"}, {"sha": "f9b47ddb082a2cec2b86bc34e9ecd420a2121640", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 61, "deletions": 13, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=c7303e411e27224a555ee8fae64bb421c26425cf", "patch": "@@ -88,7 +88,6 @@ struct JCF;\n    3: METHOD_FINAL (in FUNCTION_DECL)\n       FIELD_FINAL (in FIELD_DECL)\n       CLASS_FINAL (in TYPE_DECL)\n-      LOCAL_FINAL (in VAR_DECL)\n    4: METHOD_SYNCHRONIZED (in FUNCTION_DECL).\n       LABEL_IN_SUBR (in LABEL_DECL)\n       CLASS_INTERFACE (in TYPE_DECL)\n@@ -701,11 +700,12 @@ struct lang_identifier\n    is excluded, because sometimes created as a parameter before the\n    function decl exists. */\n #define DECL_FUNCTION_NAP(DECL) (DECL_LANG_SPECIFIC(DECL)->nap)\n-\n-/* For a FIELD_DECL, holds the name of the access method used to\n-   read/write the content of the field from an inner class. \n-   The cast is ugly. FIXME  */\n-#define FIELD_INNER_ACCESS(DECL)       ((tree)DECL_LANG_SPECIFIC (DECL))\n+/* True if DECL is a synthetic ctor.  */\n+#define DECL_FUNCTION_SYNTHETIC_CTOR(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->synthetic_ctor)\n+/* True if DECL initializes all its finals */\n+#define DECL_FUNCTION_ALL_FINAL_INITIALIZED(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->init_final)\n \n /* True when DECL aliases an outer context local variable.  */\n #define FIELD_LOCAL_ALIAS(DECL) DECL_LANG_FLAG_6 (DECL)\n@@ -779,6 +779,46 @@ struct lang_identifier\n    slot_number in decl_map. */\n #define DECL_LOCAL_SLOT_CHAIN(NODE) \\\n   (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->slot_chain)\n+/* For a FIELD_DECL, holds the name of the access method. Used to\n+   read/write the content of the field from an inner class.  */\n+#define FIELD_INNER_ACCESS(DECL) \\\n+  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(DECL))->am)\n+/* Safely tests whether FIELD_INNER_ACCESS exists or not. */\n+#define FIELD_INNER_ACCESS_P(DECL) \\\n+  DECL_LANG_SPECIFIC (DECL) && FIELD_INNER_ACCESS (DECL)\n+/* True if a final variable was initialized upon its declaration. */\n+#define DECL_FIELD_FINAL_IUD(NODE) \\\n+  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->final_iud)\n+/* Set to true if a final variable is seen locally initialized on a\n+   ctor. */\n+#define DECL_FIELD_FINAL_LIIC(NODE) \\\n+  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->final_liic)\n+/* Set to true if an initialization error was already found with this\n+   final variable. */\n+#define DECL_FIELD_FINAL_IERR(NODE) \\\n+  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->final_ierr)\n+/* The original WFL of a final variable. */\n+#define DECL_FIELD_FINAL_WFL(NODE) \\\n+  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->wfl)\n+/* True if NODE is a local final (as opposed to a final variable.)\n+   This macro accesses the flag to read or set it. */\n+#define LOCAL_FINAL(NODE) \\\n+  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->local_final)\n+/* True if NODE is a local final. */\n+#define LOCAL_FINAL_P(NODE) (DECL_LANG_SPECIFIC (NODE) && LOCAL_FINAL (NODE))\n+/* True if NODE is a final variable */\n+#define FINAL_VARIABLE_P(NODE) (FIELD_FINAL (NODE) && !FIELD_STATIC (NODE))\n+/* True if NODE is a class final variable */\n+#define CLASS_FINAL_VARIABLE_P(NODE) \\\n+  (FIELD_FINAL (NODE) && FIELD_STATIC (NODE))\n+/* Create a DECL_LANG_SPECIFIC if necessary. */\n+#define MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC(T)\t\t\t\\\n+  if (DECL_LANG_SPECIFIC (T) == NULL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      DECL_LANG_SPECIFIC ((T))\t\t\t\t\t\\\n+\t= ((struct lang_decl *)\t\t\t\t\t\\\n+\t   ggc_alloc_cleared (sizeof (struct lang_decl_var)));\t\\\n+    }\n \n /* For a local VAR_DECL, holds the index into a words bitstring that\n    specifies if this decl is definitively assigned.\n@@ -798,15 +838,15 @@ struct lang_decl\n   tree throws_list;\t\t/* Exception specified by `throws' */\n   tree function_decl_body;\t/* Hold all function's statements */\n   tree called_constructor;\t/* When decl is a constructor, the\n-\t\t\t\t   list of other constructor it calls. */\n+\t\t\t\t   list of other constructor it calls */\n   struct hash_table init_test_table;\n-\t\t\t\t/* Class initialization test variables.  */\n+\t\t\t\t/* Class initialization test variables  */\n   tree inner_access;\t\t/* The identifier of the access method\n \t\t\t\t   used for invocation from inner classes */\n   int nap;\t\t\t/* Number of artificial parameters */\n-\n-  int native : 1;\t\t/* Nonzero if this is a native\n-\t\t\t\t   method.  */\n+  int native : 1;\t\t/* Nonzero if this is a native method  */\n+  int synthetic_ctor : 1;\t/* Nonzero if this is a synthetic ctor */\n+  int init_final : 1;\t\t/* Nonzero all finals are initialized */\n };\n \n /* init_test_table hash table entry structure.  */\n@@ -816,13 +856,20 @@ struct init_test_hash_entry\n   tree init_test_decl;\n };\n \n-/* DECL_LANG_SPECIFIC for VAR_DECL and PARM_DECL. */\n+/* DECL_LANG_SPECIFIC for VAR_DECL, PARM_DECL and sometimes FIELD_DECL\n+   (access methods on outer class fields) and final fields. */\n struct lang_decl_var\n {\n   int slot_number;\n   int start_pc;\n   int end_pc;\n   tree slot_chain;\n+  tree am;\t\t\t/* Access method for this field (1.1) */\n+  tree wfl;\t\t\t/* Original wfl */\n+  int final_iud : 1;\t\t/* Final initialized upon declaration */\n+  int final_liic : 1;\t\t/* Final locally initialized in ctors */\n+  int final_ierr : 1;\t\t/* Initialization error already detected */\n+  int local_final : 1;\t\t/* True if the decl is a local final */\n };\n \n /* Macro to access fields in `struct lang_type'.  */\n@@ -847,6 +894,7 @@ struct lang_decl_var\n #define TYPE_DOT_CLASS(T)        (TYPE_LANG_SPECIFIC(T)->dot_class)\n #define TYPE_PRIVATE_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->pic)\n #define TYPE_PROTECTED_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->poic)\n+#define TYPE_HAS_FINAL_VARIABLE(T) (TYPE_LANG_SPECIFIC(T)->afv)\n \n struct lang_type\n {\n@@ -863,6 +911,7 @@ struct lang_type\n \t\t\t\t   <non_primitive_type>.class */\n   unsigned pic:1;\t\t/* Private Inner Class. */\n   unsigned poic:1;\t\t/* Protected Inner Class. */\n+  unsigned afv:1;\t\t/* Has final variables */\n };\n \n #ifdef JAVA_USE_HANDLES\n@@ -1110,7 +1159,6 @@ struct rtx_def * java_lang_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n #define FIELD_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n #define FIELD_VOLATILE(DECL) DECL_LANG_FLAG_4 (DECL)\n #define FIELD_TRANSIENT(DECL) DECL_LANG_FLAG_5 (DECL)\n-#define LOCAL_FINAL(DECL) FIELD_FINAL(DECL)\n \n /* Access flags etc for a class (a TYPE_DECL): */\n "}, {"sha": "b66db937245d5f50ae407adb1db80579874094e6", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=c7303e411e27224a555ee8fae64bb421c26425cf", "patch": "@@ -57,7 +57,7 @@ char *jcf_write_base_directory = NULL;\n /* Add a 1-byte instruction/operand I to bytecode.data,\n    assuming space has already been RESERVE'd. */\n \n-#define OP1(I) (*state->bytecode.ptr++ = (I), CHECK_OP(state))\n+#define OP1(I) (state->last_bc = *state->bytecode.ptr++ = (I), CHECK_OP(state))\n \n /* Like OP1, but I is a 2-byte big endian integer. */\n \n@@ -131,13 +131,14 @@ struct jcf_block\n \n   int linenumber;\n \n-  /* After finish_jcf_block is called, The actual instructions contained in this block.\n-     Before than NULL, and the instructions are in state->bytecode. */\n+  /* After finish_jcf_block is called, The actual instructions\n+     contained in this block.  Before than NULL, and the instructions\n+     are in state->bytecode. */\n   union {\n     struct chunk *chunk;\n \n     /* If pc==PENDING_CLEANUP_PC, start_label is the start of the region\n-       coveed by the cleanup. */\n+       covered by the cleanup. */\n     struct jcf_block *start_label;\n   } v;\n \n@@ -272,8 +273,10 @@ struct jcf_partial\n   /* If non-NULL, use this for the return value. */\n   tree return_value_decl;\n \n-  /* Information about the current switch statemenet. */\n+  /* Information about the current switch statement. */\n   struct jcf_switch_state *sw_state;\n+\n+  enum java_opcode last_bc;\t/* The last emitted bytecode */\n };\n \n static void generate_bytecode_insns PARAMS ((tree, int, struct jcf_partial *));\n@@ -2158,7 +2161,16 @@ generate_bytecode_insns (exp, target, state)\n \ttree src = TREE_OPERAND (exp, 0);\n \ttree src_type = TREE_TYPE (src);\n \ttree dst_type = TREE_TYPE (exp);\n-\tgenerate_bytecode_insns (TREE_OPERAND (exp, 0), target, state);\n+\t/* Detect the situation of compiling an empty synchronized\n+\t   block.  A nop should be emitted in order to produce\n+\t   verifiable bytecode. */\n+\tif (exp == empty_stmt_node\n+\t    && state->last_bc == OPCODE_monitorenter\n+\t    && state->labeled_blocks\n+\t    && state->labeled_blocks->pc == PENDING_CLEANUP_PC)\n+\t  OP1 (OPCODE_nop);\n+\telse\n+\t  generate_bytecode_insns (TREE_OPERAND (exp, 0), target, state);\n \tif (target == IGNORE_TARGET || src_type == dst_type)\n \t  break;\n \tif (TREE_CODE (dst_type) == POINTER_TYPE)"}, {"sha": "249dcfd9e5ee31645df9598f6db634a14d348ed1", "filename": "gcc/java/parse.y", "status": "modified", "additions": 398, "deletions": 86, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7303e411e27224a555ee8fae64bb421c26425cf/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c7303e411e27224a555ee8fae64bb421c26425cf", "patch": "@@ -102,6 +102,12 @@ static int process_imports PARAMS ((void));\n static void read_import_dir PARAMS ((tree));\n static int find_in_imports_on_demand PARAMS ((tree));\n static void find_in_imports PARAMS ((tree));\n+static void check_static_final_variable_assignment_flag PARAMS ((tree));\n+static void reset_static_final_variable_assignment_flag PARAMS ((tree));\n+static void check_final_variable_local_assignment_flag PARAMS ((tree, tree));\n+static void reset_final_variable_local_assignment_flag PARAMS ((tree));\n+static int  check_final_variable_indirect_assignment PARAMS ((tree));\n+static void check_final_variable_global_assignment_flag PARAMS ((tree));\n static void check_inner_class_access PARAMS ((tree, tree, tree));\n static int check_pkg_class_access PARAMS ((tree, tree));\n static void register_package PARAMS ((tree));\n@@ -287,6 +293,7 @@ static void java_parser_context_pop_initialized_field PARAMS ((void));\n static tree reorder_static_initialized PARAMS ((tree));\n static void java_parser_context_suspend PARAMS ((void));\n static void java_parser_context_resume PARAMS ((void));\n+static int pop_current_osb PARAMS ((struct parser_ctxt *));\n \n /* JDK 1.1 work. FIXME */\n \n@@ -580,7 +587,7 @@ static tree currently_caught_type_list;\n \t\t\tBOOLEAN_TK INTEGRAL_TK FP_TK\n \n /* Added or modified JDK 1.1 rule types  */\n-%type\t <node>\t\ttype_literals array_type_literal\n+%type\t <node>\t\ttype_literals\n \n %%\n /* 19.2 Production from 2.3: The Syntactic Grammar  */\n@@ -652,19 +659,23 @@ interface_type:\n ;\n \n array_type:\n-\tprimitive_type OSB_TK CSB_TK\n+\tprimitive_type dims\n \t\t{ \n-\t\t  $$ = build_java_array_type ($1, -1);\n-\t\t  CLASS_LOADED_P ($$) = 1;\n+\t\t  int osb = pop_current_osb (ctxp);\n+\t\t  tree t = build_java_array_type (($1), -1);\n+\t\t  CLASS_LOADED_P (t) = 1;\n+\t\t  while (--osb)\n+\t\t    t = build_unresolved_array_type (t);\n+\t\t  $$ = t;\n+\t\t}\n+|\tname dims\n+\t\t{ \n+\t\t  int osb = pop_current_osb (ctxp);\n+\t\t  tree t = $1;\n+\t\t  while (osb--)\n+\t\t    t = build_unresolved_array_type (t);\n+\t\t  $$ = t;\n \t\t}\n-|\tname OSB_TK CSB_TK\n-\t\t{ $$ = build_unresolved_array_type ($1); }\n-|\tarray_type OSB_TK CSB_TK\n-\t\t{ $$ = build_unresolved_array_type ($1); }\n-|\tprimitive_type OSB_TK error\n-\t\t{RULE (\"']' expected\"); RECOVER;}\n-|\tarray_type OSB_TK error\n-\t\t{RULE (\"']' expected\"); RECOVER;}\n ;\n \n /* 19.5 Productions from 6: Names  */\n@@ -1935,28 +1946,10 @@ primary_no_new_array:\n \t\t{yyerror (\"'class' expected\" ); RECOVER;}\n ;\n \n-/* Added, JDK1.1 type literals. We can't use `type' directly, so we\n-   broke the rule down a bit. */\n-\n-array_type_literal:\n-\tprimitive_type OSB_TK CSB_TK\n-\t\t{ \n-\t\t  $$ = build_java_array_type ($1, -1);\n-\t\t  CLASS_LOADED_P ($$) = 1;\n-\t\t}\n-|\tname OSB_TK CSB_TK\n-\t\t{ $$ = build_unresolved_array_type ($1); }\n-/* This triggers two reduce/reduce conflict between array_type_literal and\n-   dims. FIXME.\n-|\tarray_type OSB_TK CSB_TK\n-\t\t{ $$ = build_unresolved_array_type ($1); }\n-*/\n-;\n-\n type_literals:\n \tname DOT_TK CLASS_TK\n \t\t{ $$ = build_incomplete_class_ref ($2.location, $1); }\n-|\tarray_type_literal DOT_TK CLASS_TK\n+|\tarray_type DOT_TK CLASS_TK\n \t\t{ $$ = build_incomplete_class_ref ($2.location, $1); }\n |\tprimitive_type DOT_TK CLASS_TK\n \t\t{ $$ = build_class_ref ($1); }\n@@ -2085,24 +2078,26 @@ array_creation_expression:\n |\tNEW_TK class_or_interface_type dim_exprs\n \t\t{ $$ = build_newarray_node ($2, $3, 0); }\n |\tNEW_TK primitive_type dim_exprs dims\n-\t\t{ $$ = build_newarray_node ($2, $3, CURRENT_OSB (ctxp));}\n+\t\t{ $$ = build_newarray_node ($2, $3, pop_current_osb (ctxp));}\n |\tNEW_TK class_or_interface_type dim_exprs dims\n-\t\t{ $$ = build_newarray_node ($2, $3, CURRENT_OSB (ctxp));}\n+\t\t{ $$ = build_newarray_node ($2, $3, pop_current_osb (ctxp));}\n         /* Added, JDK1.1 anonymous array. Initial documentation rule\n            modified */\n |\tNEW_TK class_or_interface_type dims array_initializer\n \t\t{\n \t\t  char *sig;\n-\t\t  while (CURRENT_OSB (ctxp)--)\n+\t\t  int osb = pop_current_osb (ctxp);\n+\t\t  while (osb--)\n \t\t    obstack_1grow (&temporary_obstack, '[');\n \t\t  sig = obstack_finish (&temporary_obstack);\n \t\t  $$ = build (NEW_ANONYMOUS_ARRAY_EXPR, NULL_TREE,\n \t\t\t      $2, get_identifier (sig), $4);\n \t\t}\n |\tNEW_TK primitive_type dims array_initializer\n \t\t{ \n+\t\t  int osb = pop_current_osb (ctxp);\n \t\t  tree type = $2;\n-\t\t  while (CURRENT_OSB (ctxp)--)\n+\t\t  while (osb--)\n \t\t    type = build_java_array_type (type, -1);\n \t\t  $$ = build (NEW_ANONYMOUS_ARRAY_EXPR, NULL_TREE, \n \t\t\t      build_pointer_type (type), NULL_TREE, $4);\n@@ -2325,9 +2320,9 @@ cast_expression:\t\t/* Error handling here is potentially weak */\n \tOP_TK primitive_type dims CP_TK unary_expression\n \t\t{ \n \t\t  tree type = $2;\n-\t\t  while (CURRENT_OSB (ctxp)--)\n+\t\t  int osb = pop_current_osb (ctxp);\n+\t\t  while (osb--)\n \t\t    type = build_java_array_type (type, -1);\n-\t\t  ctxp->osb_depth--;\n \t\t  $$ = build_cast ($1.location, type, $5); \n \t\t}\n |\tOP_TK primitive_type CP_TK unary_expression\n@@ -2337,9 +2332,9 @@ cast_expression:\t\t/* Error handling here is potentially weak */\n |\tOP_TK name dims CP_TK unary_expression_not_plus_minus\n \t\t{ \n \t\t  const char *ptr;\n-\t\t  while (CURRENT_OSB (ctxp)--)\n+\t\t  int osb = pop_current_osb (ctxp); \n+\t\t  while (osb--)\n \t\t    obstack_1grow (&temporary_obstack, '[');\n-\t\t  ctxp->osb_depth--;\n \t\t  obstack_grow0 (&temporary_obstack, \n \t\t\t\t IDENTIFIER_POINTER (EXPR_WFL_NODE ($2)),\n \t\t\t\t IDENTIFIER_LENGTH (EXPR_WFL_NODE ($2)));\n@@ -2593,6 +2588,25 @@ constant_expression:\n ;\n \n %%\n+\n+/* Helper function to retrieve an OSB count. Should be used when the\n+   `dims:' rule is being used.  */\n+\n+static int\n+pop_current_osb (ctxp)\n+     struct parser_ctxt *ctxp;\n+{\n+  int to_return;\n+\n+  if (ctxp->osb_depth < 0)\n+    fatal (\"osb stack underflow\");\n+  \n+  to_return = CURRENT_OSB (ctxp);\n+  ctxp->osb_depth--;\n+  \n+  return to_return;\n+}\n+\n \f\n \n /* This section of the code deal with save/restoring parser contexts.\n@@ -3952,7 +3966,7 @@ add_inner_class_fields (class_decl, fct_decl)\n \t  tree wfl, init, list;\n \t  \n \t  /* Avoid non final arguments. */\n-\t  if (!LOCAL_FINAL (decl))\n+\t  if (!LOCAL_FINAL_P (decl))\n \t    continue;\n \t  \n \t  MANGLE_OUTER_LOCAL_VARIABLE_NAME (name, DECL_NAME (decl));\n@@ -4185,11 +4199,29 @@ register_fields (flags, type, variable_list)\n       field_decl = add_field (class_type, current_name, real_type, flags);\n       CHECK_DEPRECATED (field_decl);\n \n-      /* If the couple initializer/initialized is marked ARG_FINAL_P, we\n-\t mark the created field FIELD_LOCAL_ALIAS, so that we can \n-\t hide parameters to this inner class finit$ and constructors. */\n+      /* If the field denotes a final instance variable, then we\n+\t allocate a LANG_DECL_SPECIFIC part to keep track of its\n+\t initialization. We also mark whether the field was\n+\t initialized upon it's declaration. We don't do that if the\n+\t created field is an alias to a final local. */\n+      if (!ARG_FINAL_P (current) && (flags & ACC_FINAL))\n+\t{\n+\t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (field_decl);\n+\t  DECL_FIELD_FINAL_WFL (field_decl) = cl;\n+\t  if ((flags & ACC_STATIC) && init)\n+\t    DECL_FIELD_FINAL_IUD (field_decl) = 1;\n+\t}\n+\n+      /* If the couple initializer/initialized is marked ARG_FINAL_P,\n+\t we mark the created field FIELD_LOCAL_ALIAS, so that we can\n+\t hide parameters to this inner class finit$ and\n+\t constructors. It also means that the field isn't final per\n+\t say. */\n       if (ARG_FINAL_P (current))\n-\tFIELD_LOCAL_ALIAS (field_decl) = 1;\n+\t{\n+\t  FIELD_LOCAL_ALIAS (field_decl) = 1;\n+\t  FIELD_FINAL (field_decl) = 0;\n+\t}\n       \n       /* Check if we must chain. */\n       if (must_chain)\n@@ -5182,7 +5214,7 @@ craft_constructor (class_decl, args)\n   fix_method_argument_names (parm, decl);\n   /* Now, mark the artificial parameters. */\n   DECL_FUNCTION_NAP (decl) = artificial;\n-  DECL_CONSTRUCTOR_P (decl) = 1;\n+  DECL_FUNCTION_SYNTHETIC_CTOR (decl) = DECL_CONSTRUCTOR_P (decl) = 1;\n }\n \n \n@@ -7039,6 +7071,7 @@ declare_local_variables (modifier, type, vlist)\n       /* Never layout this decl. This will be done when its scope\n \t will be entered */\n       decl = build_decl (VAR_DECL, name, real_type);\n+      MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n       LOCAL_FINAL (decl) = final_p;\n       BLOCK_CHAIN_DECL (decl);\n       \n@@ -7116,7 +7149,10 @@ source_start_java_method (fndecl)\n       /* Remember if a local variable was declared final (via its\n          TREE_LIST of type/name.) Set LOCAL_FINAL accordingly. */\n       if (ARG_FINAL_P (tem))\n-\tLOCAL_FINAL (parm_decl) = 1;\n+\t{\n+\t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (parm_decl);\n+\t  LOCAL_FINAL (parm_decl) = 1;\n+\t}\n \n       BLOCK_CHAIN_DECL (parm_decl);\n     }\n@@ -7164,7 +7200,7 @@ static void\n end_artificial_method_body (mdecl)\n      tree mdecl;\n {\n-  BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)) = exit_block ();\n+  BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)) = exit_blcok ();\n   exit_block ();\n }\n \n@@ -7472,6 +7508,14 @@ java_complete_expand_methods (class_decl)\n \n   current_class = TREE_TYPE (class_decl);\n \n+  /* Find whether the class has final variables */\n+  for (decl = TYPE_FIELDS (current_class); decl; decl = TREE_CHAIN (decl))\n+    if (FIELD_FINAL (decl))\n+      {\n+\tTYPE_HAS_FINAL_VARIABLE (current_class) = 1;\n+\tbreak;\n+      }\n+\n   /* Initialize a new constant pool */\n   init_outgoing_cpool ();\n \n@@ -7504,7 +7548,15 @@ java_complete_expand_methods (class_decl)\n       if (no_body)\n \trestore_line_number_status (1);\n \n+      /* Reset the final local variable assignment flags */\n+      if (TYPE_HAS_FINAL_VARIABLE (current_class))\n+\treset_final_variable_local_assignment_flag (current_class);\n+\n       java_complete_expand_method (decl);\n+\n+      /* Check for missed out final variable assignment */\n+      if (TYPE_HAS_FINAL_VARIABLE (current_class))\n+\tcheck_final_variable_local_assignment_flag (current_class, decl);\n       \n       if (no_body)\n \trestore_line_number_status (0);\n@@ -7532,10 +7584,17 @@ java_complete_expand_methods (class_decl)\n   /* If there is indeed a <clinit>, fully expand it now */\n   if (clinit)\n     {\n+      /* Reset the final local variable assignment flags */\n+      if (TYPE_HAS_FINAL_VARIABLE (current_class))\n+\treset_static_final_variable_assignment_flag (current_class);\n       /* Prevent the use of `this' inside <clinit> */\n       ctxp->explicit_constructor_p = 1;\n       java_complete_expand_method (clinit);\n       ctxp->explicit_constructor_p = 0;\n+      /* Check for missed out static final variable assignment */\n+      if (TYPE_HAS_FINAL_VARIABLE (current_class)\n+\t  && !CLASS_INTERFACE (class_decl))\n+\tcheck_static_final_variable_assignment_flag (current_class);\n     }\n   \n   /* We might have generated a class$ that we now want to expand */\n@@ -7550,6 +7609,15 @@ java_complete_expand_methods (class_decl)\n \t  && verify_constructor_circularity (decl, decl))\n \tbreak;\n \n+  /* Final check on the initialization of final variables. */\n+  if (TYPE_HAS_FINAL_VARIABLE (current_class))\n+    {\n+      check_final_variable_global_assignment_flag (current_class);\n+      /* If we have an interface, check for uninitialized fields. */\n+      if (CLASS_INTERFACE (class_decl))\n+\tcheck_static_final_variable_assignment_flag (current_class);\n+    }\n+\n   /* Save the constant pool. We'll need to restore it later. */\n   TYPE_CPOOL (current_class) = outgoing_cpool;\n }\n@@ -7690,7 +7758,7 @@ maybe_yank_clinit (mdecl)\n \tcontinue;\n \n       /* Anything that isn't String or a basic type is ruled out -- or\n-\t if we now how to deal with it (when doing things natively) we\n+\t if we know how to deal with it (when doing things natively) we\n \t should generated an empty <clinit> so that SUID are computed\n \t correctly. */\n       if (! JSTRING_TYPE_P (TREE_TYPE (current))\n@@ -8045,14 +8113,11 @@ build_outer_field_access_methods (decl)\n {\n   tree id, args, stmt, mdecl;\n   \n-  /* Check point, to be removed. FIXME */\n-  if (FIELD_INNER_ACCESS (decl) \n-      && TREE_CODE (FIELD_INNER_ACCESS (decl)) != IDENTIFIER_NODE)\n-    abort ();\n-\n-  if (FIELD_INNER_ACCESS (decl))\n+  if (FIELD_INNER_ACCESS_P (decl))\n     return FIELD_INNER_ACCESS (decl);\n \n+  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n+ \n   /* Create the identifier and a function named after it. */\n   id = build_new_access_id ();\n \n@@ -8070,17 +8135,21 @@ build_outer_field_access_methods (decl)\n \t\t\t\t\t   TREE_TYPE (decl), id, args, stmt);\n   DECL_FUNCTION_ACCESS_DECL (mdecl) = decl;\n \n-  /* Create the write access method */\n-  args = build_tree_list (inst_id, build_pointer_type (DECL_CONTEXT (decl)));\n-  TREE_CHAIN (args) = build_tree_list (wpv_id, TREE_TYPE (decl));\n-  TREE_CHAIN (TREE_CHAIN (args)) = end_params_node;\n-  stmt = make_qualified_primary (build_wfl_node (inst_id),\n-\t\t\t\t build_wfl_node (DECL_NAME (decl)), 0);\n-  stmt = build_return (0, build_assignment (ASSIGN_TK, 0, stmt,\n-\t\t\t\t\t    build_wfl_node (wpv_id)));\n-\n-  mdecl = build_outer_field_access_method (DECL_CONTEXT (decl), \n-\t\t\t\t\t   TREE_TYPE (decl), id, args, stmt);\n+  /* Create the write access method. No write access for final variable */\n+  if (!FIELD_FINAL (decl))\n+    {\n+      args = build_tree_list (inst_id, \n+\t\t\t      build_pointer_type (DECL_CONTEXT (decl)));\n+      TREE_CHAIN (args) = build_tree_list (wpv_id, TREE_TYPE (decl));\n+      TREE_CHAIN (TREE_CHAIN (args)) = end_params_node;\n+      stmt = make_qualified_primary (build_wfl_node (inst_id),\n+\t\t\t\t     build_wfl_node (DECL_NAME (decl)), 0);\n+      stmt = build_return (0, build_assignment (ASSIGN_TK, 0, stmt,\n+\t\t\t\t\t\tbuild_wfl_node (wpv_id)));\n+      mdecl = build_outer_field_access_method (DECL_CONTEXT (decl), \n+\t\t\t\t\t       TREE_TYPE (decl), id, \n+\t\t\t\t\t       args, stmt);\n+    }\n   DECL_FUNCTION_ACCESS_DECL (mdecl) = decl;\n \n   /* Return the access name */\n@@ -8986,7 +9055,7 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n       if (!type_found)\n \ttype_found = DECL_CONTEXT (decl);\n       is_static = JDECL_P (decl) && FIELD_STATIC (decl);\n-      if (FIELD_FINAL (decl) && FIELD_STATIC (decl)\n+      if (CLASS_FINAL_VARIABLE_P (decl)\n \t  && JPRIMITIVE_TYPE_P (TREE_TYPE (decl))\n \t  && DECL_INITIAL (decl))\n \t{\n@@ -10587,7 +10656,7 @@ search_applicable_methods_list (lc, method, name, arglist, list, all_list)\n       else if (!lc && (DECL_CONSTRUCTOR_P (method) \n \t\t       || (GET_METHOD_NAME (method) != name)))\n \tcontinue;\n-\t  \n+\n       if (argument_types_convertible (method, arglist))\n \t{\n \t  /* Retain accessible methods only */\n@@ -10996,7 +11065,7 @@ java_complete_tree (node)\n      tree node;\n {\n   node = java_complete_lhs (node);\n-  if (JDECL_P (node) && FIELD_STATIC (node) && FIELD_FINAL (node) \n+  if (JDECL_P (node) && CLASS_FINAL_VARIABLE_P (node)\n       && DECL_INITIAL (node) != NULL_TREE\n       && !flag_emit_xref)\n     {\n@@ -11015,6 +11084,8 @@ java_complete_tree (node)\n \t  else\n \t    return value;\n \t}\n+      else\n+        DECL_FIELD_FINAL_IUD (node) = 0;\n     }\n   return node;\n }\n@@ -11505,6 +11576,8 @@ java_complete_lhs (node)\n \t    }\n \t  if (! flag_emit_class_files)\n \t    DECL_INITIAL (nn) = NULL_TREE;\n+\t  if (CLASS_FINAL_VARIABLE_P (nn))\n+\t    DECL_FIELD_FINAL_IUD (nn) = 0;\n \t}\n       wfl_op2 = TREE_OPERAND (node, 1);\n \n@@ -12062,34 +12135,267 @@ print_int_node (node)\n   return buffer;\n }\n \n+\f\n+\n+/* This section of the code handle assignment check with FINAL\n+   variables.  */\n+\n+static void\n+reset_static_final_variable_assignment_flag (class)\n+     tree class;\n+{\n+  tree field;\n+  for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n+    if (CLASS_FINAL_VARIABLE_P (field))\n+      DECL_FIELD_FINAL_LIIC (field) = 0;\n+}\n+\n+/* Figure whether all final static variable have been initialized.  */\n+\n+static void\n+check_static_final_variable_assignment_flag (class)\n+     tree class;\n+{\n+  tree field;\n+\n+  for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n+    if (CLASS_FINAL_VARIABLE_P (field)\n+\t&& !DECL_FIELD_FINAL_IUD (field) && !DECL_FIELD_FINAL_LIIC (field))\n+      parse_error_context\n+\t(DECL_FIELD_FINAL_WFL (field),\n+\t \"Blank static final variable `%s' may not have be initialized\",\n+\t IDENTIFIER_POINTER (DECL_NAME (field)));\n+}\n+\n+/* This function marks all final variable locally unassigned.  */\n+\n+static void\n+reset_final_variable_local_assignment_flag (class)\n+     tree class;\n+{\n+  tree field;\n+  for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n+    if (FINAL_VARIABLE_P (field))\n+      DECL_FIELD_FINAL_LIIC (field) = 0;\n+}\n+\n+/* Figure whether all final variables have beem initialized in MDECL\n+   and mark MDECL accordingly.  */\n+\n+static void\n+check_final_variable_local_assignment_flag (class, mdecl)\n+     tree class;\n+     tree mdecl;\n+{\n+  tree field;\n+  int initialized = 0;\n+  int non_initialized = 0; \n+\n+  if (DECL_FUNCTION_SYNTHETIC_CTOR (mdecl))\n+    return;\n+\n+  /* First find out whether all final variables or no final variable\n+     are initialized in this ctor. We don't take into account final\n+     variable that have been initialized upon declaration.  */\n+  for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n+    if (FINAL_VARIABLE_P (field) && !DECL_FIELD_FINAL_IUD (field))\n+      {\n+\tif (DECL_FIELD_FINAL_LIIC (field))\n+\t  initialized++;\n+\telse\n+\t  non_initialized++;\n+      }\n+\n+  /* There were no non initialized variable and no initialized variable.\n+     This ctor is fine. */\n+  if (!non_initialized && !initialized)\n+    DECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl) = 1;\n+  /* If no variables have been initialized, that fine. We'll check\n+     later whether this ctor calls a constructor which initializes\n+     them. We mark the ctor as not initializing all its finals. */\n+  else if (initialized == 0)\n+    DECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl) = 0;\n+  /* If we have a mixed bag, then we have a problem. We need to report\n+     all the variables we're not initializing.  */\n+  else if (initialized && non_initialized)\n+    {\n+      DECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl) = 0;\n+      for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n+\tif (FIELD_FINAL (field)\n+\t    && !DECL_FIELD_FINAL_IUD (field) && !DECL_FIELD_FINAL_LIIC (field))\n+\t  {\n+\t    parse_error_context \n+\t      (lookup_cl (mdecl),\n+\t       \"Blank final variable `%s' may not have been initialized in this constructor\",\n+\t       IDENTIFIER_POINTER (DECL_NAME (field)));\n+\t    DECL_FIELD_FINAL_IERR (field) = 1;\n+\t  }\n+    }\n+  /* Otherwise we know this ctor is initializing all its final\n+     variable. We mark it so. */\n+  else\n+    DECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl) = 1;\n+}\n+\n+/* This function recurses in a simple what through STMT and stops when\n+   it finds a constructor call. It then verifies that the called\n+   constructor initialized its final properly. Return 1 upon success,\n+   0 or -1 otherwise.  */\n+\n+static int\n+check_final_variable_indirect_assignment (stmt)\n+     tree stmt;\n+{\n+  int res;\n+  switch (TREE_CODE (stmt))\n+    {\n+    case EXPR_WITH_FILE_LOCATION:\n+      return check_final_variable_indirect_assignment (EXPR_WFL_NODE (stmt));\n+    case COMPOUND_EXPR:\n+      res = check_final_variable_indirect_assignment (TREE_OPERAND (stmt, 0));\n+      if (res)\n+\treturn res;\n+      return check_final_variable_indirect_assignment (TREE_OPERAND (stmt, 1));\n+    case SAVE_EXPR:\n+      return check_final_variable_indirect_assignment (TREE_OPERAND (stmt, 0));\n+    case CALL_EXPR:\n+      {\n+\ttree decl = TREE_OPERAND (stmt, 0);\n+\ttree fbody;\n+\n+\tif (TREE_CODE (decl) != FUNCTION_DECL)\n+\t  decl = TREE_OPERAND (TREE_OPERAND (decl, 0), 0);\n+\tif (TREE_CODE (decl) != FUNCTION_DECL)\n+\t  fatal (\"Can't find FUNCTION_DECL in CALL_EXPR - check_final_variable_indirect_assignment\");\n+\tif (DECL_FUNCTION_ALL_FINAL_INITIALIZED (decl))\n+\t  return 1;\n+\tif (DECL_FINIT_P (decl) || DECL_CONTEXT (decl) != current_class)\n+\t  return -1;\n+\tfbody = BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (decl));\n+\tif (fbody == error_mark_node)\n+\t  return -1;\n+\tfbody = BLOCK_EXPR_BODY (fbody);\n+\treturn check_final_variable_indirect_assignment (fbody);\n+      }\n+    default:\n+      break;\n+    }\n+  return 0;\n+}\n+\n+/* This is the last chance to catch a final variable initialization\n+   problem. This routine will report an error if a final variable was\n+   never (globally) initialized and never reported as not having been\n+   initialized properly. */\n+\n+static void\n+check_final_variable_global_assignment_flag (class)\n+     tree class;\n+{\n+  tree field, mdecl;\n+  int nnctor = 0;\n+\n+  /* We go through all natural ctors and see whether they're\n+     initializing all their final variables or not. */\n+  current_function_decl = NULL_TREE; /* For the error report. */\n+  for (mdecl = TYPE_METHODS (class); mdecl; mdecl = TREE_CHAIN (mdecl))\n+    if (DECL_CONSTRUCTOR_P (mdecl) && ! DECL_FUNCTION_SYNTHETIC_CTOR (mdecl))\n+      {\n+\tif (!DECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl))\n+\t  {\n+\t    /* It doesn't. Maybe it calls a constructor that initializes\n+\t       them.  find out. */\n+\t    tree fbody = BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl));\n+\t    if (fbody == error_mark_node)\n+\t      continue;\n+\t    fbody = BLOCK_EXPR_BODY (fbody);\n+\t    if (check_final_variable_indirect_assignment (fbody) == 1)\n+\t      {\n+\t\tDECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl) = 1;\n+\t\tnnctor++;\n+\t      }\n+\t    else\n+\t      parse_error_context\n+\t\t(lookup_cl (mdecl),\n+\t\t \"Final variable initialization error in this constructor\");\n+\t  }\n+\telse\n+\t  nnctor++;\n+      }\n+\n+  /* Finally we catch final variables that never were initialized */\n+  for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n+    if (FINAL_VARIABLE_P (field)\n+\t/* If the field wasn't initialized upon declaration */\n+\t&& !DECL_FIELD_FINAL_IUD (field)\n+\t/* There wasn't natural ctor in which the field could have been\n+\t   initialized */\n+\t&& !nnctor\n+\t/* If we never reported a problem with this field */\n+\t&& !DECL_FIELD_FINAL_IERR (field))\n+      {\n+\tcurrent_function_decl = NULL;\n+\tparse_error_context\n+\t  (DECL_FIELD_FINAL_WFL (field),\n+\t   \"Final variable `%s' hasn't been initialized upon its declaration\",\n+\t   IDENTIFIER_POINTER (DECL_NAME (field)));\n+      }\n+\n+}\n+\n /* Return 1 if an assignment to a FINAL is attempted in a non suitable\n    context.  */\n \n static int\n check_final_assignment (lvalue, wfl)\n      tree lvalue, wfl;\n {\n-  if (TREE_CODE (lvalue) == COMPOUND_EXPR \n+  if (TREE_CODE (lvalue) != COMPONENT_REF && !JDECL_P (lvalue))\n+    return 0;\n+\n+  if (TREE_CODE (lvalue) == COMPONENT_REF\n       && JDECL_P (TREE_OPERAND (lvalue, 1)))\n     lvalue = TREE_OPERAND (lvalue, 1);\n \n-  /* When generating class files, references to the `length' field\n-     look a bit different.  */\n-  if ((flag_emit_class_files\n-       && TREE_CODE (lvalue) == COMPONENT_REF\n-       && TYPE_ARRAY_P (TREE_TYPE (TREE_OPERAND (lvalue, 0)))\n-       && FIELD_FINAL (TREE_OPERAND (lvalue, 1)))\n-      || (TREE_CODE (lvalue) == FIELD_DECL\n-\t  && FIELD_FINAL (lvalue)\n-\t  && !DECL_CLINIT_P (current_function_decl)\n-\t  && !DECL_FINIT_P (current_function_decl)))\n+  if (!FIELD_FINAL (lvalue))\n+    return 0;\n+\n+  /* Now the logic. We can modify a final VARIABLE:\n+     1) in finit$, (its declaration was followed by an initialization,)\n+     2) consistently in each natural ctor, if it wasn't initialized in\n+        finit$ or once in <clinit>.  In any other cases, an error should be\n+\treported. */\n+  if (DECL_FINIT_P (current_function_decl))\n     {\n-      parse_error_context \n-        (wfl, \"Can't assign a value to the final variable `%s'\",\n-\t IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n-      return 1;\n+      DECL_FIELD_FINAL_IUD (lvalue) = 1;\n+      return 0;\n     }\n-  return 0;\n+\n+  if (!DECL_FUNCTION_SYNTHETIC_CTOR (current_function_decl)\n+      /* Only if it wasn't given a value upon initialization */\n+      && DECL_LANG_SPECIFIC (lvalue) && !DECL_FIELD_FINAL_IUD (lvalue)\n+      /* If it was never assigned a value in this constructor */\n+      && !DECL_FIELD_FINAL_LIIC (lvalue))\n+    {\n+      /* Turn the locally assigned flag on, it will be checked later\n+\t on to point out at discrepancies. */\n+      DECL_FIELD_FINAL_LIIC (lvalue) = 1;\n+      if (DECL_CLINIT_P (current_function_decl))\n+\tDECL_FIELD_FINAL_IUD (lvalue) = 1;\n+      return 0;\n+    }\n+\n+  /* Other problems should be reported right away. */\n+  parse_error_context \n+    (wfl, \"Can't %sassign a value to the final variable `%s'\",\n+     (FIELD_STATIC (lvalue) ? \"re\" : \"\"),\n+     IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n+\n+  /* Note that static field can be initialized once and only once. */\n+  if (FIELD_STATIC (lvalue))\n+    DECL_FIELD_FINAL_IERR (lvalue) = 1;\n+\n+  return 1;\n }\n \n /* Inline references to java.lang.PRIMTYPE.TYPE when accessed in\n@@ -12297,7 +12603,7 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   /* Final locals can be used as case values in switch\n      statement. Prepare them for this eventuality. */\n   if (TREE_CODE (lvalue) == VAR_DECL \n-      && LOCAL_FINAL (lvalue)\n+      && LOCAL_FINAL_P (lvalue)\n       && TREE_CONSTANT (new_rhs)\n       && IDENTIFIER_LOCAL_VALUE (DECL_NAME (lvalue))\n       && JINTEGRAL_TYPE_P (TREE_TYPE (lvalue))\n@@ -14820,14 +15126,18 @@ patch_synchronized_statement (node, wfl_op1)\n   tree expr = java_complete_tree (TREE_OPERAND (node, 0));\n   tree block = TREE_OPERAND (node, 1);\n \n-  tree enter, exit, expr_decl, assignment;\n+  tree tmp, enter, exit, expr_decl, assignment;\n \n   if (expr == error_mark_node)\n     {\n       block = java_complete_tree (block);\n       return expr;\n     }\n \n+  /* We might be trying to synchronize on a STRING_CST */\n+  if ((tmp = patch_string (expr)))\n+    expr = tmp;\n+\n   /* The TYPE of expr must be a reference type */\n   if (!JREFERENCE_TYPE_P (TREE_TYPE (expr)))\n     {\n@@ -15265,6 +15575,8 @@ fold_constant_for_init (node, context)\n       DECL_INITIAL (node) = NULL_TREE;\n       val = fold_constant_for_init (val, node);\n       DECL_INITIAL (node) = val;\n+      if (!val && CLASS_FINAL_VARIABLE_P (node))\n+\tDECL_FIELD_FINAL_IUD (node) = 0;\n       return val;\n \n     case EXPR_WITH_FILE_LOCATION:"}]}