{"sha": "3759634f3208cbc1226bec19d22cbff989a287c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc1OTYzNGYzMjA4Y2JjMTIyNmJlYzE5ZDIyY2JmZjk4OWEyODdjMw==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2009-03-31T04:38:12Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2009-03-31T04:38:12Z"}, "message": "alloc_alloc_expr_1.f90: Adjust for new error message.\n\n2008-12-10  Steven G. Kargl  <kargls@comcast.net>\n\n\t* gfortran.dg/alloc_alloc_expr_1.f90: Adjust for new error message.\n\t* gfortran.dg/allocate_alloc_opt_1.f90: New test.\n\t* gfortran.dg/allocate_alloc_opt_2.f90: Ditto.\n\t* gfortran.dg/allocate_alloc_opt_3.f90: Ditto.\n\t* gfortran.dg/deallocate_alloc_opt_1.f90: Ditto.\n\t* gfortran.dg/deallocate_alloc_opt_2.f90: Ditto.\n\t* gfortran.dg/deallocate_alloc_opt_3.f90: Ditto.\n\n\n2008-12-10  Steven G. Kargl  <kargls@comcast.net>\n\n\t* trans-stmt.c(gfc_trans_allocate): Add translation of ERRMSG.\n\t(gfc_trans_deallocate): Add translation of ERRMSG.  Remove stale\n\tcomments.  Minor whitespace cleanup.\n\t* resolve.c(is_scalar_expr_ptr): Whitespace cleanup.\n\t(resolve_deallocate_expr (gfc_expr *e): Update error message.\n\t(resolve_allocate_expr):  Remove dead code.  Update error message.\n\tMove error checking to ...\n\t(resolve_allocate_deallocate): ... here.  Add additional error\n\tchecking for STAT, ERRMSG, and allocate-objects.\n\t* match.c(gfc_match_allocate,gfc_match_deallocate):  Parse ERRMSG.\n\tCheck for redundant uses of STAT and ERRMSG.  Reword error message\n\tand add checking for pointer, allocatable, and proc_pointer attributes.\n\nFrom-SVN: r145331", "tree": {"sha": "68d7f06e5527fece36527f377f12c08b89a27d34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68d7f06e5527fece36527f377f12c08b89a27d34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3759634f3208cbc1226bec19d22cbff989a287c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3759634f3208cbc1226bec19d22cbff989a287c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3759634f3208cbc1226bec19d22cbff989a287c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3759634f3208cbc1226bec19d22cbff989a287c3/comments", "author": null, "committer": null, "parents": [{"sha": "9752c4ad248eb383f72f9bd354af4c1890f1f1a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9752c4ad248eb383f72f9bd354af4c1890f1f1a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9752c4ad248eb383f72f9bd354af4c1890f1f1a3"}], "stats": {"total": 599, "additions": 502, "deletions": 97}, "files": [{"sha": "09c6961c48be73123a10c77baec799888543dd24", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -1,3 +1,19 @@\n+2009-03-30  Steven G. Kargl  <kargls@comcast.net>\n+\n+\tPR fortran/38389\n+\t* trans-stmt.c(gfc_trans_allocate): Add translation of ERRMSG.\n+\t(gfc_trans_deallocate): Add translation of ERRMSG.  Remove stale\n+\tcomments.  Minor whitespace cleanup.\n+\t* resolve.c(is_scalar_expr_ptr): Whitespace cleanup.\n+\t(resolve_deallocate_expr (gfc_expr *e): Update error message.\n+\t(resolve_allocate_expr):  Remove dead code.  Update error message.\n+\tMove error checking to ...\n+\t(resolve_allocate_deallocate): ... here.  Add additional error\n+\tchecking for STAT, ERRMSG, and allocate-objects.\n+\t* match.c(gfc_match_allocate,gfc_match_deallocate):  Parse ERRMSG.\n+\tCheck for redundant uses of STAT and ERRMSG.  Reword error message\n+\tand add checking for pointer, allocatable, and proc_pointer attributes.\n+\n 2009-03-30  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/22571"}, {"sha": "a5c9f32199af331e43a79445a63c0f53c7e63e1f", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 140, "deletions": 21, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -2222,11 +2222,13 @@ match\n gfc_match_allocate (void)\n {\n   gfc_alloc *head, *tail;\n-  gfc_expr *stat;\n+  gfc_expr *stat, *errmsg, *tmp;\n   match m;\n+  bool saw_stat, saw_errmsg;\n \n   head = tail = NULL;\n-  stat = NULL;\n+  stat = errmsg = tmp = NULL;\n+  saw_stat = saw_errmsg = false;\n \n   if (gfc_match_char ('(') != MATCH_YES)\n     goto syntax;\n@@ -2250,35 +2252,92 @@ gfc_match_allocate (void)\n       if (gfc_check_do_variable (tail->expr->symtree))\n \tgoto cleanup;\n \n-      if (gfc_pure (NULL)\n-\t  && gfc_impure_variable (tail->expr->symtree->n.sym))\n+      if (gfc_pure (NULL) && gfc_impure_variable (tail->expr->symtree->n.sym))\n \t{\n-\t  gfc_error (\"Bad allocate-object in ALLOCATE statement at %C for a \"\n-\t\t     \"PURE procedure\");\n+\t  gfc_error (\"Bad allocate-object at %C for a PURE procedure\");\n \t  goto cleanup;\n \t}\n \n       if (tail->expr->ts.type == BT_DERIVED)\n \ttail->expr->ts.derived = gfc_use_derived (tail->expr->ts.derived);\n \n+      /* FIXME: disable the checking on derived types and arrays.  */\n+      if (!(tail->expr->ref\n+\t   && (tail->expr->ref->type == REF_COMPONENT\n+\t       || tail->expr->ref->type == REF_ARRAY)) \n+\t  && tail->expr->symtree->n.sym\n+\t  && !(tail->expr->symtree->n.sym->attr.allocatable\n+\t       || tail->expr->symtree->n.sym->attr.pointer\n+\t       || tail->expr->symtree->n.sym->attr.proc_pointer))\n+\t{\n+\t  gfc_error (\"Allocate-object at %C is not a nonprocedure pointer \"\n+\t\t     \"or an allocatable variable\");\n+\t  goto cleanup;\n+\t}\n+\n       if (gfc_match_char (',') != MATCH_YES)\n \tbreak;\n \n-      m = gfc_match (\" stat = %v\", &stat);\n+alloc_opt_list:\n+\n+      m = gfc_match (\" stat = %v\", &tmp);\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n-\tbreak;\n+\t{\n+\t  if (saw_stat)\n+\t    {\n+\t      gfc_error (\"Redundant STAT tag found at %L \", &tmp->where);\n+\t      gfc_free_expr (tmp);\n+\t      goto cleanup;\n+\t    }\n+\n+\t  stat = tmp;\n+\t  saw_stat = true;\n+\n+\t  if (gfc_check_do_variable (stat->symtree))\n+\t    goto cleanup;\n+\n+\t  if (gfc_match_char (',') == MATCH_YES)\n+\t    goto alloc_opt_list;\n+\t}\n+\n+      m = gfc_match (\" errmsg = %v\", &tmp);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ERRMSG at %L\",\n+\t\t\t      &tmp->where) == FAILURE)\n+\t    goto cleanup;\n+\n+\t  if (saw_errmsg)\n+\t    {\n+\t      gfc_error (\"Redundant ERRMSG tag found at %L \", &tmp->where);\n+\t      gfc_free_expr (tmp);\n+\t      goto cleanup;\n+\t    }\n+\n+\t  errmsg = tmp;\n+\t  saw_errmsg = true;\n+\n+\t  if (gfc_match_char (',') == MATCH_YES)\n+\t    goto alloc_opt_list;\n+\t}\n+\n+\tgfc_gobble_whitespace ();\n+\n+\tif (gfc_peek_char () == ')')\n+\t  break;\n     }\n \n-  if (stat != NULL)\n-    gfc_check_do_variable(stat->symtree);\n \n   if (gfc_match (\" )%t\") != MATCH_YES)\n     goto syntax;\n \n   new_st.op = EXEC_ALLOCATE;\n   new_st.expr = stat;\n+  new_st.expr2 = errmsg;\n   new_st.ext.alloc_list = head;\n \n   return MATCH_YES;\n@@ -2287,6 +2346,7 @@ gfc_match_allocate (void)\n   gfc_syntax_error (ST_ALLOCATE);\n \n cleanup:\n+  gfc_free_expr (errmsg);\n   gfc_free_expr (stat);\n   gfc_free_alloc_list (head);\n   return MATCH_ERROR;\n@@ -2367,11 +2427,13 @@ match\n gfc_match_deallocate (void)\n {\n   gfc_alloc *head, *tail;\n-  gfc_expr *stat;\n+  gfc_expr *stat, *errmsg, *tmp;\n   match m;\n+  bool saw_stat, saw_errmsg;\n \n   head = tail = NULL;\n-  stat = NULL;\n+  stat = errmsg = tmp = NULL;\n+  saw_stat = saw_errmsg = false;\n \n   if (gfc_match_char ('(') != MATCH_YES)\n     goto syntax;\n@@ -2395,32 +2457,88 @@ gfc_match_deallocate (void)\n       if (gfc_check_do_variable (tail->expr->symtree))\n \tgoto cleanup;\n \n-      if (gfc_pure (NULL)\n-\t  && gfc_impure_variable (tail->expr->symtree->n.sym))\n+      if (gfc_pure (NULL) && gfc_impure_variable (tail->expr->symtree->n.sym))\n \t{\n-\t  gfc_error (\"Illegal deallocate-expression in DEALLOCATE at %C \"\n-\t\t     \"for a PURE procedure\");\n+\t  gfc_error (\"Illegal allocate-object at %C for a PURE procedure\");\n+\t  goto cleanup;\n+\t}\n+\n+      /* FIXME: disable the checking on derived types.  */\n+      if (!(tail->expr->ref\n+\t   && (tail->expr->ref->type == REF_COMPONENT\n+\t       || tail->expr->ref->type == REF_ARRAY)) \n+\t  && tail->expr->symtree->n.sym\n+\t  && !(tail->expr->symtree->n.sym->attr.allocatable\n+\t       || tail->expr->symtree->n.sym->attr.pointer\n+\t       || tail->expr->symtree->n.sym->attr.proc_pointer))\n+\t{\n+\t  gfc_error (\"Allocate-object at %C is not a nonprocedure pointer \"\n+\t\t     \"or an allocatable variable\");\n \t  goto cleanup;\n \t}\n \n       if (gfc_match_char (',') != MATCH_YES)\n \tbreak;\n \n-      m = gfc_match (\" stat = %v\", &stat);\n+dealloc_opt_list:\n+\n+      m = gfc_match (\" stat = %v\", &tmp);\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n-\tbreak;\n-    }\n+\t{\n+\t  if (saw_stat)\n+\t    {\n+\t      gfc_error (\"Redundant STAT tag found at %L \", &tmp->where);\n+\t      gfc_free_expr (tmp);\n+\t      goto cleanup;\n+\t    }\n+\n+\t  stat = tmp;\n+\t  saw_stat = true;\n+\n+\t  if (gfc_check_do_variable (stat->symtree))\n+\t    goto cleanup;\n+\n+\t  if (gfc_match_char (',') == MATCH_YES)\n+\t    goto dealloc_opt_list;\n+\t}\n \n-  if (stat != NULL)\n-    gfc_check_do_variable(stat->symtree);\n+      m = gfc_match (\" errmsg = %v\", &tmp);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ERRMSG at %L\",\n+\t\t\t      &tmp->where) == FAILURE)\n+\t    goto cleanup;\n+\n+\t  if (saw_errmsg)\n+\t    {\n+\t      gfc_error (\"Redundant ERRMSG tag found at %L \", &tmp->where);\n+\t      gfc_free_expr (tmp);\n+\t      goto cleanup;\n+\t    }\n+\n+\t  errmsg = tmp;\n+\t  saw_errmsg = true;\n+\n+\t  if (gfc_match_char (',') == MATCH_YES)\n+\t    goto dealloc_opt_list;\n+\t}\n+\n+\tgfc_gobble_whitespace ();\n+\n+\tif (gfc_peek_char () == ')')\n+\t  break;\n+    }\n \n   if (gfc_match (\" )%t\") != MATCH_YES)\n     goto syntax;\n \n   new_st.op = EXEC_DEALLOCATE;\n   new_st.expr = stat;\n+  new_st.expr2 = errmsg;\n   new_st.ext.alloc_list = head;\n \n   return MATCH_YES;\n@@ -2429,6 +2547,7 @@ gfc_match_deallocate (void)\n   gfc_syntax_error (ST_DEALLOCATE);\n \n cleanup:\n+  gfc_free_expr (errmsg);\n   gfc_free_expr (stat);\n   gfc_free_alloc_list (head);\n   return MATCH_ERROR;"}, {"sha": "4ab9df63a2a3706a029a7d84a637ac3764fd76aa", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 86, "deletions": 41, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -2034,16 +2034,16 @@ is_scalar_expr_ptr (gfc_expr *expr)\n \t\t    }\n \t\t  else\n \t\t    {\n-                  /* We have constant lower and upper bounds.  If the\n-                     difference between is 1, it can be considered a\n-                     scalar.  */\n-                  start = (int) mpz_get_si\n-                                (ref->u.ar.as->lower[0]->value.integer);\n-                  end = (int) mpz_get_si\n-                              (ref->u.ar.as->upper[0]->value.integer);\n-                  if (end - start + 1 != 1)\n-                    retval = FAILURE;\n-                }\n+\t\t      /* We have constant lower and upper bounds.  If the\n+\t\t\t difference between is 1, it can be considered a\n+\t\t\t scalar.  */\n+\t\t      start = (int) mpz_get_si\n+\t\t\t\t(ref->u.ar.as->lower[0]->value.integer);\n+\t\t      end = (int) mpz_get_si\n+\t\t\t\t(ref->u.ar.as->upper[0]->value.integer);\n+\t\t      if (end - start + 1 != 1)\n+\t\t\tretval = FAILURE;\n+\t\t   }\n                 }\n               else\n                 retval = FAILURE;\n@@ -5181,8 +5181,8 @@ resolve_deallocate_expr (gfc_expr *e)\n   if (allocatable == 0 && attr.pointer == 0)\n     {\n     bad:\n-      gfc_error (\"Expression in DEALLOCATE statement at %L must be \"\n-\t\t \"ALLOCATABLE or a POINTER\", &e->where);\n+      gfc_error (\"Allocate-object at %L must be ALLOCATABLE or a POINTER\",\n+\t\t &e->where);\n     }\n \n   if (check_intent_in\n@@ -5267,11 +5267,6 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   if (gfc_resolve_expr (e) == FAILURE)\n     return FAILURE;\n \n-  if (code->expr && code->expr->expr_type == EXPR_VARIABLE)\n-    sym = code->expr->symtree->n.sym;\n-  else\n-    sym = NULL;\n-\n   /* Make sure the expression is allocatable or a pointer.  If it is\n      pointer, the next-to-last reference must be a pointer.  */\n \n@@ -5290,14 +5285,6 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       pointer = e->symtree->n.sym->attr.pointer;\n       dimension = e->symtree->n.sym->attr.dimension;\n \n-      if (sym == e->symtree->n.sym && sym->ts.type != BT_DERIVED)\n-\t{\n-\t  gfc_error (\"The STAT variable '%s' in an ALLOCATE statement must \"\n-\t\t     \"not be allocated in the same statement at %L\",\n-\t\t      sym->name, &e->where);\n-\t  return FAILURE;\n-\t}\n-\n       for (ref = e->ref; ref; ref2 = ref, ref = ref->next)\n \t{\n \t  if (pointer)\n@@ -5328,8 +5315,8 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \n   if (allocatable == 0 && pointer == 0)\n     {\n-      gfc_error (\"Expression in ALLOCATE statement at %L must be \"\n-\t\t \"ALLOCATABLE or a POINTER\", &e->where);\n+      gfc_error (\"Allocate-object at %L must be ALLOCATABLE or a POINTER\",\n+\t\t &e->where);\n       return FAILURE;\n     }\n \n@@ -5424,26 +5411,83 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n static void\n resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n {\n-  gfc_symbol *s = NULL;\n-  gfc_alloc *a;\n+  gfc_expr *stat, *errmsg, *pe, *qe;\n+  gfc_alloc *a, *p, *q;\n+\n+  stat = code->expr ? code->expr : NULL;\n \n-  if (code->expr)\n-    s = code->expr->symtree->n.sym;\n+  errmsg = code->expr2 ? code->expr2 : NULL;\n \n-  if (s)\n+  /* Check the stat variable.  */\n+  if (stat)\n     {\n-      if (s->attr.intent == INTENT_IN)\n-\tgfc_error (\"STAT variable '%s' of %s statement at %C cannot \"\n-\t\t   \"be INTENT(IN)\", s->name, fcn);\n+      if (stat->symtree->n.sym->attr.intent == INTENT_IN)\n+\tgfc_error (\"Stat-variable '%s' at %L cannot be INTENT(IN)\",\n+\t\t   stat->symtree->n.sym->name, &stat->where);\n \n-      if (gfc_pure (NULL) && gfc_impure_variable (s))\n-\tgfc_error (\"Illegal STAT variable in %s statement at %C \"\n-\t\t   \"for a PURE procedure\", fcn);\n+      if (gfc_pure (NULL) && gfc_impure_variable (stat->symtree->n.sym))\n+\tgfc_error (\"Illegal stat-variable at %L for a PURE procedure\",\n+\t\t   &stat->where);\n+\n+      if (stat->ts.type != BT_INTEGER\n+\t  && !(stat->ref && (stat->ref->type == REF_ARRAY\n+\t       || stat->ref->type == REF_COMPONENT)))\n+\tgfc_error (\"Stat-variable at %L must be a scalar INTEGER \"\n+\t\t   \"variable\", &stat->where);\n+\n+      for (p = code->ext.alloc_list; p; p = p->next)\n+\tif (p->expr->symtree->n.sym->name == stat->symtree->n.sym->name)\n+\t  gfc_error (\"Stat-variable at %L shall not be %sd within \"\n+\t\t     \"the same %s statement\", &stat->where, fcn, fcn);\n     }\n \n-  if (s && code->expr->ts.type != BT_INTEGER)\n-\tgfc_error (\"STAT tag in %s statement at %L must be \"\n-\t\t       \"of type INTEGER\", fcn, &code->expr->where);\n+  /* Check the errmsg variable.  */\n+  if (errmsg)\n+    {\n+      if (!stat)\n+\tgfc_warning (\"ERRMSG at %L is useless without a STAT tag\",\n+\t\t     &errmsg->where);\n+\n+      if (errmsg->symtree->n.sym->attr.intent == INTENT_IN)\n+\tgfc_error (\"Errmsg-variable '%s' at %L cannot be INTENT(IN)\",\n+\t\t   errmsg->symtree->n.sym->name, &errmsg->where);\n+\n+      if (gfc_pure (NULL) && gfc_impure_variable (errmsg->symtree->n.sym))\n+\tgfc_error (\"Illegal errmsg-variable at %L for a PURE procedure\",\n+\t\t   &errmsg->where);\n+\n+      if (errmsg->ts.type != BT_CHARACTER\n+\t  && !(errmsg->ref\n+\t       && (errmsg->ref->type == REF_ARRAY\n+\t  \t   || errmsg->ref->type == REF_COMPONENT)))\n+\tgfc_error (\"Errmsg-variable at %L must be a scalar CHARACTER \"\n+\t\t   \"variable\", &errmsg->where);\n+\n+      for (p = code->ext.alloc_list; p; p = p->next)\n+\tif (p->expr->symtree->n.sym->name == errmsg->symtree->n.sym->name)\n+\t  gfc_error (\"Errmsg-variable at %L shall not be %sd within \"\n+\t\t     \"the same %s statement\", &errmsg->where, fcn, fcn);\n+    }\n+\n+  /* Check that an allocate-object appears only once in the statement.  \n+     FIXME: Checking derived types is disabled.  */\n+  for (p = code->ext.alloc_list; p; p = p->next)\n+    {\n+      pe = p->expr;\n+      if ((pe->ref && pe->ref->type != REF_COMPONENT)\n+\t   && (pe->symtree->n.sym->ts.type != BT_DERIVED))\n+\t{\n+\t  for (q = p->next; q; q = q->next)\n+\t    {\n+\t      qe = q->expr;\n+\t      if ((qe->ref && qe->ref->type != REF_COMPONENT)\n+\t\t  && (qe->symtree->n.sym->ts.type != BT_DERIVED)\n+\t\t  && (pe->symtree->n.sym->name == qe->symtree->n.sym->name))\n+\t\tgfc_error (\"Allocate-object at %L also appears at %L\",\n+\t\t\t   &pe->where, &qe->where);\n+\t    }\n+\t}\n+    }\n \n   if (strcmp (fcn, \"ALLOCATE\") == 0)\n     {\n@@ -5457,6 +5501,7 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n     }\n }\n \n+\n /************ SELECT CASE resolution subroutines ************/\n \n /* Callback function for our mergesort variant.  Determines interval"}, {"sha": "24e7b80be193db4dbb7b3ed06445104358eaa72c", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 81, "deletions": 33, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -3932,9 +3932,12 @@ gfc_trans_allocate (gfc_code * code)\n   if (!code->ext.alloc_list)\n     return NULL_TREE;\n \n+  pstat = stat = error_label = tmp = NULL_TREE;\n+\n   gfc_start_block (&block);\n \n-  if (code->expr)\n+  /* Either STAT= and/or ERRMSG is present.  */\n+  if (code->expr || code->expr2)\n     {\n       tree gfc_int4_type_node = gfc_get_int_type (4);\n \n@@ -3944,8 +3947,6 @@ gfc_trans_allocate (gfc_code * code)\n       error_label = gfc_build_label_decl (NULL_TREE);\n       TREE_USED (error_label) = 1;\n     }\n-  else\n-    pstat = stat = error_label = NULL_TREE;\n \n   for (al = code->ext.alloc_list; al != NULL; al = al->next)\n     {\n@@ -3971,7 +3972,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t     fold_convert (TREE_TYPE (se.expr), tmp));\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n-\t  if (code->expr)\n+\t  if (code->expr || code->expr2)\n \t    {\n \t      tmp = build1_v (GOTO_EXPR, error_label);\n \t      parm = fold_build2 (NE_EXPR, boolean_type_node,\n@@ -3994,7 +3995,7 @@ gfc_trans_allocate (gfc_code * code)\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n-  /* Assign the value to the status variable.  */\n+  /* STAT block.  */\n   if (code->expr)\n     {\n       tmp = build1_v (LABEL_EXPR, error_label);\n@@ -4006,44 +4007,63 @@ gfc_trans_allocate (gfc_code * code)\n       gfc_add_modify (&block, se.expr, tmp);\n     }\n \n+  /* ERRMSG block.  */\n+  if (code->expr2)\n+    {\n+      /* A better error message may be possible, but not required.  */\n+      const char *msg = \"Attempt to allocate an allocated object\";\n+      tree errmsg, slen, dlen;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr_lhs (&se, code->expr2);\n+\n+      errmsg = gfc_create_var (pchar_type_node, \"ERRMSG\");\n+\n+      gfc_add_modify (&block, errmsg,\n+\t\tgfc_build_addr_expr (pchar_type_node,\n+\t\t\tgfc_build_localized_cstring_const (msg)));\n+\n+      slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n+      dlen = gfc_get_expr_charlen (code->expr2);\n+      slen = fold_build2 (MIN_EXPR, TREE_TYPE (slen), dlen, slen);\n+\n+      dlen = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\tgfc_build_addr_expr (pvoid_type_node, se.expr), errmsg, slen);\n+\n+      tmp = fold_build2 (NE_EXPR, boolean_type_node, stat,\n+\t\t\t build_int_cst (TREE_TYPE (stat), 0));\n+\n+      tmp = build3_v (COND_EXPR, tmp, dlen, build_empty_stmt ());\n+\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+\n   return gfc_finish_block (&block);\n }\n \n \n-/* Translate a DEALLOCATE statement.\n-   There are two cases within the for loop:\n-   (1) deallocate(a1, a2, a3) is translated into the following sequence\n-       _gfortran_deallocate(a1, 0B)\n-       _gfortran_deallocate(a2, 0B)\n-       _gfortran_deallocate(a3, 0B)\n-       where the STAT= variable is passed a NULL pointer.\n-   (2) deallocate(a1, a2, a3, stat=i) is translated into the following\n-       astat = 0\n-       _gfortran_deallocate(a1, &stat)\n-       astat = astat + stat\n-       _gfortran_deallocate(a2, &stat)\n-       astat = astat + stat\n-       _gfortran_deallocate(a3, &stat)\n-       astat = astat + stat\n-    In case (1), we simply return at the end of the for loop.  In case (2)\n-    we set STAT= astat.  */\n+/* Translate a DEALLOCATE statement.  */\n+\n tree\n-gfc_trans_deallocate (gfc_code * code)\n+gfc_trans_deallocate (gfc_code *code)\n {\n   gfc_se se;\n   gfc_alloc *al;\n   gfc_expr *expr;\n   tree apstat, astat, pstat, stat, tmp;\n   stmtblock_t block;\n \n+  pstat = apstat = stat = astat = tmp = NULL_TREE;\n+\n   gfc_start_block (&block);\n \n-  /* Set up the optional STAT= */\n-  if (code->expr)\n+  /* Count the number of failed deallocations.  If deallocate() was\n+     called with STAT= , then set STAT to the count.  If deallocate\n+     was called with ERRMSG, then set ERRMG to a string.  */\n+  if (code->expr || code->expr2)\n     {\n       tree gfc_int4_type_node = gfc_get_int_type (4);\n \n-      /* Variable used with the library call.  */\n       stat = gfc_create_var (gfc_int4_type_node, \"stat\");\n       pstat = gfc_build_addr_expr (NULL_TREE, stat);\n \n@@ -4054,8 +4074,6 @@ gfc_trans_deallocate (gfc_code * code)\n       /* Initialize astat to 0.  */\n       gfc_add_modify (&block, astat, build_int_cst (TREE_TYPE (astat), 0));\n     }\n-  else\n-    pstat = apstat = stat = astat = NULL_TREE;\n \n   for (al = code->ext.alloc_list; al != NULL; al = al->next)\n     {\n@@ -4069,8 +4087,7 @@ gfc_trans_deallocate (gfc_code * code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n-      if (expr->ts.type == BT_DERIVED\n-\t    && expr->ts.derived->attr.alloc_comp)\n+      if (expr->ts.type == BT_DERIVED && expr->ts.derived->attr.alloc_comp)\n         {\n \t  gfc_ref *ref;\n \t  gfc_ref *last = NULL;\n@@ -4081,7 +4098,7 @@ gfc_trans_deallocate (gfc_code * code)\n \t  /* Do not deallocate the components of a derived type\n \t     ultimate pointer component.  */\n \t  if (!(last && last->u.c.component->attr.pointer)\n-\t\t   && !(!last && expr->symtree->n.sym->attr.pointer))\n+\t\t&& !(!last && expr->symtree->n.sym->attr.pointer))\n \t    {\n \t      tmp = gfc_deallocate_alloc_comp (expr->ts.derived, se.expr,\n \t\t\t\t\t       expr->rank);\n@@ -4104,7 +4121,7 @@ gfc_trans_deallocate (gfc_code * code)\n \n       /* Keep track of the number of failed deallocations by adding stat\n \t of the last deallocation to the running total.  */\n-      if (code->expr)\n+      if (code->expr || code->expr2)\n \t{\n \t  apstat = fold_build2 (PLUS_EXPR, TREE_TYPE (stat), astat, stat);\n \t  gfc_add_modify (&se.pre, astat, apstat);\n@@ -4115,7 +4132,7 @@ gfc_trans_deallocate (gfc_code * code)\n \n     }\n \n-  /* Assign the value to the status variable.  */\n+  /* Set STAT.  */\n   if (code->expr)\n     {\n       gfc_init_se (&se, NULL);\n@@ -4124,6 +4141,37 @@ gfc_trans_deallocate (gfc_code * code)\n       gfc_add_modify (&block, se.expr, tmp);\n     }\n \n+  /* Set ERRMSG.  */\n+  if (code->expr2)\n+    {\n+      /* A better error message may be possible, but not required.  */\n+      const char *msg = \"Attempt to deallocate an unallocated object\";\n+      tree errmsg, slen, dlen;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr_lhs (&se, code->expr2);\n+\n+      errmsg = gfc_create_var (pchar_type_node, \"ERRMSG\");\n+\n+      gfc_add_modify (&block, errmsg,\n+\t\tgfc_build_addr_expr (pchar_type_node,\n+                        gfc_build_localized_cstring_const (msg)));\n+\n+      slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n+      dlen = gfc_get_expr_charlen (code->expr2);\n+      slen = fold_build2 (MIN_EXPR, TREE_TYPE (slen), dlen, slen);\n+\n+      dlen = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\tgfc_build_addr_expr (pvoid_type_node, se.expr), errmsg, slen);\n+\n+      tmp = fold_build2 (NE_EXPR, boolean_type_node, astat,\n+\t\t\t build_int_cst (TREE_TYPE (astat), 0));\n+\n+      tmp = build3_v (COND_EXPR, tmp, dlen, build_empty_stmt ());\n+\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+\n   return gfc_finish_block (&block);\n }\n "}, {"sha": "aadb0da5e3398486d79af253890f66aaced0f1e2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -1,3 +1,14 @@\n+2009-03-30  Steven G. Kargl  <kargls@comcast.net>\n+\n+\tPR fortran/38389\n+\t* gfortran.dg/alloc_alloc_expr_1.f90: Adjust for new error message.\n+\t* gfortran.dg/allocate_alloc_opt_1.f90: New test.\n+\t* gfortran.dg/allocate_alloc_opt_2.f90: Ditto.\n+\t* gfortran.dg/allocate_alloc_opt_3.f90: Ditto.\n+\t* gfortran.dg/deallocate_alloc_opt_1.f90: Ditto.\n+\t* gfortran.dg/deallocate_alloc_opt_2.f90: Ditto.\n+\t* gfortran.dg/deallocate_alloc_opt_3.f90: Ditto.\n+\n 2009-03-30  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/22571"}, {"sha": "516ccd46a3a9f30bad8c507e0b6d0cc3c04a2b0b", "filename": "gcc/testsuite/gfortran.dg/alloc_alloc_expr_1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_alloc_expr_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_alloc_expr_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_alloc_expr_1.f90?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -18,9 +18,9 @@ program fc011\n   integer, pointer :: PTR\n   integer, allocatable :: ALLOCS(:)\n \n-  allocate (PTR, stat=PTR) ! { dg-error \"allocated in the same statement\" }\n+  allocate (PTR, stat=PTR) ! { dg-error \"in the same ALLOCATE statement\" }\n \n-  allocate (ALLOCS(10),stat=ALLOCS(1)) ! { dg-error \"allocated in the same statement\" }\n+  allocate (ALLOCS(10),stat=ALLOCS(1)) ! { dg-error \"in the same ALLOCATE statement\" }\n \n   ALLOCATE(PTR,ALLOCS(PTR)) ! { dg-error \"same ALLOCATE statement\" }\n "}, {"sha": "cd611ccfde6ed035fa9577a7b0fa278ffb8d028c", "filename": "gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_1.f90?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+program a\n+\n+  implicit none\n+\n+  real x\n+  integer j, k, n(4)\n+  character(len=70) err\n+  character(len=70), allocatable :: error(:)\n+\n+  integer, allocatable :: i(:)\n+\n+  type b\n+    integer, allocatable :: c(:), d(:)\n+  end type b\n+\n+  type(b) e, f(3)\n+\n+  allocate(i(2), stat=x) ! { dg-error \"must be a scalar INTEGER\" }\n+  allocate(i(2), stat=j, stat=k) ! { dg-error \"Redundant STAT\" }\n+  allocate(i(2))\n+  allocate(i(2))) ! { dg-error \"Syntax error in ALLOCATE\" }\n+  allocate(i(2), errmsg=err, errmsg=err) ! { dg-error \"Redundant ERRMSG\" }\n+  allocate(i(2), errmsg=err) ! { dg-warning \"useless without a STAT\" }\n+  allocate(i(2), stat=j, errmsg=x) ! { dg-error \"must be a scalar CHARACTER\" }\n+\n+  allocate(err) ! { dg-error \"nonprocedure pointer or an allocatable\" }\n+\n+  allocate(error(2),stat=j,errmsg=error) ! { dg-error \"shall not be ALLOCATEd within\" }\n+  allocate(i(2), stat = i)  ! { dg-error \"shall not be ALLOCATEd within\" }\n+\n+  allocate(n) ! { dg-error \"must be ALLOCATABLE or a POINTER\" }\n+\n+  allocate(i(2), i(2)) ! { dg-error \"Allocate-object at\" }\n+\n+  ! These should not fail the check for duplicate alloc-objects.\n+  allocate(f(1)%c(2), f(2)%d(2))\n+  allocate(e%c(2), e%d(2))\n+\n+end program a"}, {"sha": "b6d6ca5acb1c69d54db1aee936e3a6ae24ca7f33", "filename": "gcc/testsuite/gfortran.dg/allocate_alloc_opt_2.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_2.f90?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+subroutine sub(i, j, err)\n+   implicit none\n+   character(len=*), intent(in) :: err\n+   integer, intent(in) :: j\n+   integer, intent(in), allocatable :: i(:)\n+   integer, allocatable :: m(:)\n+   integer n\n+   allocate(i(2))                    ! { dg-error \"Cannot allocate\" \"\" }\n+   allocate(m(2), stat=j)            ! { dg-error \"cannot be\" \"\" }\n+   allocate(m(2),stat=n,errmsg=err)  ! { dg-error \"cannot be\" \"\" }\n+end subroutine sub"}, {"sha": "d8c177f117d18041e89f5b4c0fb3007c1f72c6f5", "filename": "gcc/testsuite/gfortran.dg/allocate_alloc_opt_3.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_3.f90?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+program a\n+\n+  implicit none\n+\n+  integer n\n+  character(len=70) e1\n+  character(len=30) e2\n+  integer, allocatable :: i(:)\n+\n+  e1 = 'No error'\n+  allocate(i(4), stat=n, errmsg=e1)\n+  if (trim(e1) /= 'No error') call abort\n+  deallocate(i)\n+\n+  e2 = 'No error'\n+  allocate(i(4),stat=n, errmsg=e2)\n+  if (trim(e2) /= 'No error') call abort\n+  deallocate(i)\n+\n+\n+  e1 = 'No error'\n+  allocate(i(4), stat=n, errmsg=e1)\n+  allocate(i(4), stat=n, errmsg=e1)\n+  if (trim(e1) /= 'Attempt to allocate an allocated object') call abort\n+  deallocate(i)\n+\n+  e2 = 'No error'\n+  allocate(i(4), stat=n, errmsg=e2)\n+  allocate(i(4), stat=n, errmsg=e2)\n+  if (trim(e2) /= 'Attempt to allocate an allocat') call abort\n+\n+end program a"}, {"sha": "75da7013f30c0dd462df1f52ac10318c51a0fe62", "filename": "gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_1.f90?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+program a\n+\n+  implicit none\n+\n+  real x\n+  integer j, k, n(4)\n+  character(len=70) err\n+  character(len=70), allocatable :: error(:)\n+\n+  integer, allocatable :: i(:)\n+\n+  type b\n+    integer, allocatable :: c(:), d(:)\n+  end type b\n+\n+  type(b) e, f(3)\n+\n+  deallocate(i, stat=x) ! { dg-error \"must be a scalar INTEGER\" }\n+  deallocate(i, stat=j, stat=k) ! { dg-error \"Redundant STAT\" }\n+  deallocate(i)\n+  deallocate(i)) ! { dg-error \"Syntax error in DEALLOCATE\" }\n+  deallocate(i, errmsg=err, errmsg=err) ! { dg-error \"Redundant ERRMSG\" }\n+  deallocate(i, errmsg=err) ! { dg-warning \"useless without a STAT\" }\n+  deallocate(i, stat=j, errmsg=x) ! { dg-error \"must be a scalar CHARACTER\" }\n+\n+  deallocate(err) ! { dg-error \"nonprocedure pointer or an allocatable\" }\n+\n+  deallocate(error,stat=j,errmsg=error) ! { dg-error \"shall not be DEALLOCATEd within\" }\n+  deallocate(i, stat = i)  ! { dg-error \"shall not be DEALLOCATEd within\" }\n+\n+  deallocate(n) ! { dg-error \"must be ALLOCATABLE or a POINTER\" }\n+\n+  deallocate(i, i) ! { dg-error \"Allocate-object at\" }\n+\n+  ! These should not fail the check for duplicate alloc-objects.\n+  deallocate(f(1)%c, f(2)%d)\n+  deallocate(e%c, e%d)\n+\n+end program a"}, {"sha": "0c3e8694a6c3ae5985204422ccefde33c6b71cf7", "filename": "gcc/testsuite/gfortran.dg/deallocate_alloc_opt_2.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_2.f90?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+subroutine sub(i, j, err)\n+   implicit none\n+   character(len=*), intent(in) :: err\n+   integer, intent(in) :: j\n+   integer, intent(in), allocatable :: i(:)\n+   integer, allocatable :: m(:)\n+   integer n\n+   deallocate(i)                    ! { dg-error \"Cannot deallocate\" \"\" }\n+   deallocate(m, stat=j)            ! { dg-error \"cannot be\" \"\" }\n+   deallocate(m,stat=n,errmsg=err)  ! { dg-error \"cannot be\" \"\" }\n+end subroutine sub"}, {"sha": "67ec14a4a1912096add32f18ea2399ff116058aa", "filename": "gcc/testsuite/gfortran.dg/deallocate_alloc_opt_3.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3759634f3208cbc1226bec19d22cbff989a287c3/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_3.f90?ref=3759634f3208cbc1226bec19d22cbff989a287c3", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+program a\n+\n+  implicit none\n+\n+  integer n\n+  character(len=70) e1\n+  character(len=30) e2\n+  integer, allocatable :: i(:)\n+\n+  e1 = 'No error'\n+  allocate(i(4))\n+  deallocate(i, stat=n, errmsg=e1)\n+  if (trim(e1) /= 'No error') call abort\n+\n+  e2 = 'No error'\n+  allocate(i(4))\n+  deallocate(i, stat=n, errmsg=e2)\n+  if (trim(e2) /= 'No error') call abort\n+\n+  e1 = 'No error'\n+  deallocate(i, stat=n, errmsg=e1)\n+  if (trim(e1) /= 'Attempt to deallocate an unallocated object') call abort\n+\n+  e2 = 'No error'\n+  deallocate(i, stat=n, errmsg=e2)\n+  if (trim(e2) /= 'Attempt to deallocate an unall') call abort\n+\n+end program a"}]}