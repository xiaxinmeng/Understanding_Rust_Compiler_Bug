{"sha": "951661a1a5a4271ba4975cde0f0093af99861acf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUxNjYxYTFhNWE0MjcxYmE0OTc1Y2RlMGYwMDkzYWY5OTg2MWFjZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-07-07T21:33:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-07-07T21:33:09Z"}, "message": "re PR target/10567 (-fno-delayed-branch not honored in back-end)\n\n\tPR target/10567\n\t* config/sparc/sparc.c (load_pic_register): Honor flag_delayed_branch.\n\t(output_return): Likewise.\n\t(output_sibcall): Abort if !flag_delayed_branch.\n\t(sparc_function_ok_for_sibcall): Return 0 if !flag_delayed_branch.\n\t(emit_and_preserve): New function.\n\t(sparc_output_mi_thunk): Use it.  Honor flag_delayed_branch.  Emit an\n\tindirect jump to the thunked-to function if !flag_delayed_branch.\n\t* config/sparc/sparc.md (delayed_branch): New attribute.\n\t(load_pcrel_sym): Honor flag_delayed_branch.  Use above\n\tattribute to compute the length of the insn.\n\t(goto_handler_and_restore): Likewise.\n\nFrom-SVN: r84232", "tree": {"sha": "13cf5c801f37168a06c5e065e71434e2c8481037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13cf5c801f37168a06c5e065e71434e2c8481037"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/951661a1a5a4271ba4975cde0f0093af99861acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/951661a1a5a4271ba4975cde0f0093af99861acf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/951661a1a5a4271ba4975cde0f0093af99861acf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/951661a1a5a4271ba4975cde0f0093af99861acf/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5f7b21560685728b826f0702459292806ea8bbb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f7b21560685728b826f0702459292806ea8bbb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f7b21560685728b826f0702459292806ea8bbb8"}], "stats": {"total": 193, "additions": 171, "deletions": 22}, "files": [{"sha": "7d5e7db4ac467c113c8f449daa30b0f01933995d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/951661a1a5a4271ba4975cde0f0093af99861acf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/951661a1a5a4271ba4975cde0f0093af99861acf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=951661a1a5a4271ba4975cde0f0093af99861acf", "patch": "@@ -1,3 +1,18 @@\n+2004-07-07  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/10567\n+\t* config/sparc/sparc.c (load_pic_register): Honor flag_delayed_branch.\n+\t(output_return): Likewise.\n+\t(output_sibcall): Abort if !flag_delayed_branch.\n+\t(sparc_function_ok_for_sibcall): Return 0 if !flag_delayed_branch.\n+\t(emit_and_preserve): New function.\n+\t(sparc_output_mi_thunk): Use it.  Honor flag_delayed_branch.  Emit an\n+\tindirect jump to the thunked-to function if !flag_delayed_branch.\n+\t* config/sparc/sparc.md (delayed_branch): New attribute.\n+\t(load_pcrel_sym): Honor flag_delayed_branch.  Use above\n+\tattribute to compute the length of the insn.\n+\t(goto_handler_and_restore): Likewise.\n+\n 2004-07-07  Andrew Pinski  <apinski@apple.com>\n \n \tPR tree-optimization/15777"}, {"sha": "75ce1471cc9e43e30c7e842ebcfdbd327e2a6ea4", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 131, "deletions": 16, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/951661a1a5a4271ba4975cde0f0093af99861acf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/951661a1a5a4271ba4975cde0f0093af99861acf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=951661a1a5a4271ba4975cde0f0093af99861acf", "patch": "@@ -3657,8 +3657,12 @@ load_pic_register (void)\n       if (align > 0)\n \tASM_OUTPUT_ALIGN (asm_out_file, align);\n       ASM_OUTPUT_LABEL (asm_out_file, add_pc_to_pic_symbol_name);\n-      fprintf (asm_out_file, \"\\tjmp %%o7+8\\n\\t add\\t%%o7, %s, %s\\n\",\n-\t       pic_name, pic_name);\n+      if (flag_delayed_branch)\n+\tfprintf (asm_out_file, \"\\tjmp %%o7+8\\n\\t add\\t%%o7, %s, %s\\n\",\n+\t\t pic_name, pic_name);\n+      else\n+\tfprintf (asm_out_file, \"\\tadd\\t%%o7, %s, %s\\n\\tjmp %%o7+8\\n\\t nop\\n\",\n+\t\t pic_name, pic_name);\n     }\n \n   /* Initialize every time through, since we can't easily\n@@ -4453,12 +4457,18 @@ output_return (rtx insn)\n \t  if (delay_slot_filled_p || sparc_skip_caller_unimp)\n \t    abort ();\n \n+\t  if (! flag_delayed_branch)\n+\t    fputs (\"\\tadd\\t%fp, %g1, %fp\\n\", asm_out_file);\n+\n \t  if (TARGET_V9)\n \t    fputs (\"\\treturn\\t%i7+8\\n\", asm_out_file);\n \t  else\n \t    fputs (\"\\trestore\\n\\tjmp\\t%o7+8\\n\", asm_out_file);\n \n-\t  fputs (\"\\t add\\t%sp, %g1, %sp\\n\", asm_out_file);\n+\t  if (flag_delayed_branch)\n+\t    fputs (\"\\t add\\t%sp, %g1, %sp\\n\", asm_out_file);\n+\t  else\n+\t    fputs (\"\\t nop\\n\", asm_out_file);\n \t}\n       else if (delay_slot_filled_p)\n \t{\n@@ -4493,9 +4503,12 @@ output_return (rtx insn)\n \t  if (TARGET_V9)\n \t    fprintf (asm_out_file, \"\\treturn\\t%%i7+%d\\n\\t nop\\n\",\n \t\t     sparc_skip_caller_unimp ? 12 : 8);\n-\t  else\n+\t  else if (flag_delayed_branch)\n \t    fprintf (asm_out_file, \"\\tjmp\\t%%i7+%d\\n\\t restore\\n\",\n \t\t     sparc_skip_caller_unimp ? 12 : 8);\n+\t  else\n+\t    fprintf (asm_out_file, \"\\trestore\\n\\tjmp\\t%%o7+%d\\n\\t nop\\n\",\n+\t\t     sparc_skip_caller_unimp ? 12 : 8);\n \t}\n     }\n \n@@ -4511,6 +4524,9 @@ output_sibcall (rtx insn, rtx call_operand)\n   bool delay_slot_filled_p = dbr_sequence_length () > 0;\n   rtx operands[1];\n \n+  if (! flag_delayed_branch)\n+    abort();\n+\n   operands[0] = call_operand;\n \n   if (leaf_function_p)\n@@ -7787,7 +7803,10 @@ sparc_elf_asm_named_section (const char *name, unsigned int flags)\n #endif /* OBJECT_FORMAT_ELF */\n \n /* We do not allow indirect calls to be optimized into sibling calls.\n-   \n+\n+   We cannot use sibling calls when delayed branches are disabled\n+   because they will likely require the call delay slot to be filled.\n+\n    Also, on SPARC 32-bit we cannot emit a sibling call when the\n    current function returns a structure.  This is because the \"unimp\n    after call\" convention would cause the callee to return to the\n@@ -7797,14 +7816,16 @@ sparc_elf_asm_named_section (const char *name, unsigned int flags)\n    It may seem strange how this last case could occur.  Usually there\n    is code after the call which jumps to epilogue code which dumps the\n    return value into the struct return area.  That ought to invalidate\n-   the sibling call right?  Well, in the c++ case we can end up passing\n+   the sibling call right?  Well, in the C++ case we can end up passing\n    the pointer to the struct return area to a constructor (which returns\n    void) and then nothing else happens.  Such a sibling call would look\n    valid without the added check here.  */\n static bool\n sparc_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n-  return (decl && (TARGET_ARCH64 || ! current_function_returns_struct));\n+  return (decl\n+\t  && flag_delayed_branch\n+\t  && (TARGET_ARCH64 || ! current_function_returns_struct));\n }\n \f\n /* libfunc renaming.  */\n@@ -8332,6 +8353,21 @@ sparc_rtx_costs (rtx x, int code, int outer_code, int *total)\n     }\n }\n \n+/* Emit the sequence of insns SEQ while preserving the register REG.  */\n+\n+static void\n+emit_and_preserve (rtx seq, rtx reg)\n+{\n+  rtx slot = gen_rtx_MEM (word_mode,\n+\t\t\t  plus_constant (stack_pointer_rtx, SPARC_STACK_BIAS));\n+\n+  emit_stack_pointer_decrement (GEN_INT (UNITS_PER_WORD));\n+  emit_insn (gen_rtx_SET (VOIDmode, slot, reg));\n+  emit_insn (seq);\n+  emit_insn (gen_rtx_SET (VOIDmode, reg, slot));\n+  emit_stack_pointer_increment (GEN_INT (UNITS_PER_WORD));\n+}\n+\n /* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n    Used for C++ multiple inheritance.  */\n \n@@ -8341,22 +8377,42 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t\t       HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n \t\t       tree function)\n {\n-  rtx this, insn, funexp, delta_rtx, tmp;\n+  rtx this, insn, funexp, delta_rtx;\n+  unsigned int int_arg_first;\n \n   reload_completed = 1;\n   epilogue_completed = 1;\n   no_new_pseudos = 1;\n-  current_function_uses_only_leaf_regs = 1;\n   reset_block_changes ();\n \n   emit_note (NOTE_INSN_PROLOGUE_END);\n \n+  if (flag_delayed_branch)\n+    {\n+      /* We will emit a regular sibcall below, so we need to instruct\n+\t output_sibcall that we are in a leaf function.  */\n+      current_function_uses_only_leaf_regs = 1;\n+\n+      /* This will cause final.c to invoke leaf_renumber_regs so we\n+\t must behave as if we were in a not-yet-leafified function.  */\n+      int_arg_first = SPARC_INCOMING_INT_ARG_FIRST;\n+    }\n+  else\n+    {\n+      /* We will emit the sibcall manually below, so we will need to\n+\t manually spill non-leaf registers.  */\n+      current_function_uses_only_leaf_regs = 0;\n+\n+      /* We really are in a leaf function.  */\n+      int_arg_first = SPARC_OUTGOING_INT_ARG_FIRST;\n+    }\n+\n   /* Find the \"this\" pointer.  Normally in %o0, but in ARCH64 if the function\n      returns a structure, the structure return pointer is there instead.  */\n   if (TARGET_ARCH64 && aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n-    this = gen_rtx_REG (Pmode, SPARC_INCOMING_INT_ARG_FIRST + 1);\n+    this = gen_rtx_REG (Pmode, int_arg_first + 1);\n   else\n-    this = gen_rtx_REG (Pmode, SPARC_INCOMING_INT_ARG_FIRST);\n+    this = gen_rtx_REG (Pmode, int_arg_first);\n \n   /* Add DELTA.  When possible use a plain add, otherwise load it into\n      a register first.  */\n@@ -8378,8 +8434,9 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n       delta_rtx = scratch;\n     }\n \n-  tmp = gen_rtx_PLUS (Pmode, this, delta_rtx);\n-  emit_insn (gen_rtx_SET (VOIDmode, this, tmp));\n+  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t  this,\n+\t\t\t  gen_rtx_PLUS (Pmode, this, delta_rtx)));\n \n   /* Generate a tail call to the target function.  */\n   if (! TREE_USED (function))\n@@ -8388,9 +8445,67 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n       TREE_USED (function) = 1;\n     }\n   funexp = XEXP (DECL_RTL (function), 0);\n-  funexp = gen_rtx_MEM (FUNCTION_MODE, funexp);\n-  insn = emit_call_insn (gen_sibcall (funexp));\n-  SIBLING_CALL_P (insn) = 1;\n+\n+  if (flag_delayed_branch)\n+    {\n+      funexp = gen_rtx_MEM (FUNCTION_MODE, funexp);\n+      insn = emit_call_insn (gen_sibcall (funexp));\n+      SIBLING_CALL_P (insn) = 1;\n+    }\n+  else\n+    {\n+      /* The hoops we have to jump through in order to generate a sibcall\n+\t without using delay slots...  */\n+      rtx spill_reg, seq, scratch = gen_rtx_REG (Pmode, 1);\n+\n+      if (flag_pic)\n+        {\n+\t  spill_reg = gen_rtx_REG (word_mode, 15);  /* %o7 */\n+\t  start_sequence ();\n+\t  load_pic_register ();  /* clobbers %o7 */\n+\t  scratch = legitimize_pic_address (funexp, Pmode, scratch);\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n+\t  emit_and_preserve (seq, spill_reg);\n+\t}\n+      else if (TARGET_ARCH32)\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  scratch,\n+\t\t\t\t  gen_rtx_HIGH (SImode, funexp)));\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  scratch,\n+\t\t\t\t  gen_rtx_LO_SUM (SImode, scratch, funexp)));\n+\t}\n+      else  /* TARGET_ARCH64 */\n+        {\n+\t  switch (sparc_cmodel)\n+\t    {\n+\t    case CM_MEDLOW:\n+\t    case CM_MEDMID:\n+\t      /* The destination can serve as a temporary.  */\n+\t      sparc_emit_set_symbolic_const64 (scratch, funexp, scratch);\n+\t      break;\n+\n+\t    case CM_MEDANY:\n+\t    case CM_EMBMEDANY:\n+\t      /* The destination cannot serve as a temporary.  */\n+\t      spill_reg = gen_rtx_REG (DImode, 15);  /* %o7 */\n+\t      start_sequence ();\n+\t      sparc_emit_set_symbolic_const64 (scratch, funexp, spill_reg);\n+\t      seq = get_insns ();\n+\t      end_sequence ();\n+\t      emit_and_preserve (seq, spill_reg);\n+\t      break;\n+\n+\t    default:\n+\t      abort();\n+\t    }\n+\t}\n+\n+      emit_jump_insn (gen_indirect_jump (scratch));\n+    }\n+\n   emit_barrier ();\n \n   /* Run just enough of rest_of_compilation to get the insns emitted."}, {"sha": "c4f4daf2e643546df9255f06a13002f71e0d984a", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/951661a1a5a4271ba4975cde0f0093af99861acf/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/951661a1a5a4271ba4975cde0f0093af99861acf/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=951661a1a5a4271ba4975cde0f0093af99861acf", "patch": "@@ -125,6 +125,9 @@\n (define_attr \"current_function_calls_alloca\" \"false,true\"\n   (symbol_ref \"current_function_calls_alloca != 0\"))\n \n+(define_attr \"delayed_branch\" \"false,true\"\n+  (symbol_ref \"flag_delayed_branch != 0\"))\n+\n ;; Length (in # of insns).\n (define_attr \"length\" \"\"\n   (cond [(eq_attr \"type\" \"uncond_branch,call,sibcall\")\n@@ -1674,9 +1677,17 @@\n \t\t (match_operand 2 \"call_operand_address\" \"\")] UNSPEC_LOAD_PCREL_SYM))\n    (clobber (reg:SI 15))]\n   \"\"\n-  \"sethi\\t%%hi(%a1-4), %0\\n\\tcall\\t%a2\\n\\tadd\\t%0, %%lo(%a1+4), %0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"3\")])\n+{\n+  if (flag_delayed_branch)\n+    return \"sethi\\t%%hi(%a1-4), %0\\n\\tcall\\t%a2\\n\\t add\\t%0, %%lo(%a1+4), %0\";\n+  else\n+    return \"sethi\\t%%hi(%a1-8), %0\\n\\tadd\\t%0, %%lo(%a1-4), %0\\n\\tcall\\t%a2\\n\\t nop\";\n+}\n+  [(set (attr \"type\") (const_string \"multi\"))\n+   (set (attr \"length\")\n+\t(if_then_else (eq_attr \"delayed_branch\" \"true\")\n+\t\t      (const_int 3)\n+\t\t      (const_int 4)))])\n \f\n ;; Move instructions\n \n@@ -7824,9 +7835,17 @@\n (define_insn \"goto_handler_and_restore\"\n   [(unspec_volatile [(match_operand 0 \"register_operand\" \"=r\")] UNSPECV_GOTO)]\n   \"GET_MODE (operands[0]) == Pmode\"\n-  \"jmp\\t%0+0\\n\\trestore\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n+{\n+  if (flag_delayed_branch)\n+    return \"jmp\\t%0\\n\\t restore\";\n+  else\n+    return \"mov\\t%0,%%g1\\n\\trestore\\n\\tjmp\\t%%g1\\n\\t nop\";\n+}\n+  [(set (attr \"type\") (const_string \"multi\"))\n+   (set (attr \"length\")\n+\t(if_then_else (eq_attr \"delayed_branch\" \"true\")\n+\t\t      (const_int 2)\n+\t\t      (const_int 4)))])\n \n ;; For __builtin_setjmp we need to flush register windows iff the function\n ;; calls alloca as well, because otherwise the register window might be"}]}