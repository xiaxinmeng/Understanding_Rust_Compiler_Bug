{"sha": "4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRhYmIzNzkxZGZlOWRiMjQ4MzkxNGFhZmYzZWU3OWY5Y2M3NGJiZg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@cygnus.com", "date": "1996-05-08T18:18:35Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-05-08T18:18:35Z"}, "message": "86th Cygnus<->FSF quick merge\n\nFrom-SVN: r11956", "tree": {"sha": "bdd7ab2e44811ccfa2fcc97aeec1ab3f591e7374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdd7ab2e44811ccfa2fcc97aeec1ab3f591e7374"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/comments", "author": null, "committer": null, "parents": [{"sha": "887a8bd9fa39dc2bb96ce479a0c1b5b13d88c654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/887a8bd9fa39dc2bb96ce479a0c1b5b13d88c654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/887a8bd9fa39dc2bb96ce479a0c1b5b13d88c654"}], "stats": {"total": 231, "additions": 123, "deletions": 108}, "files": [{"sha": "431c8b59c95604b99c5c775eb56a8a65a9972586", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -1,3 +1,12 @@\n+Tue May  7 20:39:57 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.h (build_overload_call_maybe): Removed.\n+\t* call.c (build_overload_call_real): Invert meaning of last arg to\n+\tbe require_complete.\n+\t(build_overload_call): Ditto.\n+\t* typeck.c (build_x_function_call): Use build_overload_call_real\n+\tinstead of build_overload_call_maybe.\n+\n Mon May  6 01:23:32 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (finish_file): Don't try to emit functions that haven't"}, {"sha": "a50c5888b1ee0c2f1c6f340e80e3aeed870a1ece", "filename": "gcc/cp/call.c", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -228,10 +228,10 @@ convert_harshness (type, parmtype, parm)\n \t  tree ttl = TYPE_METHOD_BASETYPE (type);\n \t  tree ttr = TYPE_METHOD_BASETYPE (parmtype);\n \n-\t  int b_or_d = get_base_distance (ttr, ttl, 0, 0);\n+\t  int b_or_d = get_base_distance (ttr, ttl, 0, (tree*)0);\n \t  if (b_or_d < 0)\n \t    {\n-\t      b_or_d = get_base_distance (ttl, ttr, 0, 0);\n+\t      b_or_d = get_base_distance (ttl, ttr, 0, (tree*)0);\n \t      if (b_or_d < 0)\n \t\treturn EVIL_RETURN (h);\n \t      h.distance = -b_or_d;\n@@ -361,10 +361,10 @@ convert_harshness (type, parmtype, parm)\n \th.code = 0;\n       else\n \t{\n-\t  int b_or_d = get_base_distance (ttr, ttl, 0, 0);\n+\t  int b_or_d = get_base_distance (ttr, ttl, 0, (tree*)0);\n \t  if (b_or_d < 0)\n \t    {\n-\t      b_or_d = get_base_distance (ttl, ttr, 0, 0);\n+\t      b_or_d = get_base_distance (ttl, ttr, 0, (tree*)0);\n \t      if (b_or_d < 0)\n \t\treturn EVIL_RETURN (h);\n \t      h.distance = -b_or_d;\n@@ -551,10 +551,10 @@ convert_harshness (type, parmtype, parm)\n \n       if (TREE_CODE (ttl) == RECORD_TYPE && TREE_CODE (ttr) == RECORD_TYPE)\n \t{\n-\t  int b_or_d = get_base_distance (ttl, ttr, 0, 0);\n+\t  int b_or_d = get_base_distance (ttl, ttr, 0, (tree*)0);\n \t  if (b_or_d < 0)\n \t    {\n-\t      b_or_d = get_base_distance (ttr, ttl, 0, 0);\n+\t      b_or_d = get_base_distance (ttr, ttl, 0, (tree*)0);\n \t      if (b_or_d < 0)\n \t\treturn EVIL_RETURN (h);\n \t      h.distance = -b_or_d;\n@@ -611,10 +611,10 @@ convert_harshness (type, parmtype, parm)\n \n   if (codel == RECORD_TYPE && coder == RECORD_TYPE)\n     {\n-      int b_or_d = get_base_distance (type, parmtype, 0, 0);\n+      int b_or_d = get_base_distance (type, parmtype, 0, (tree*)0);\n       if (b_or_d < 0)\n \t{\n-\t  b_or_d = get_base_distance (parmtype, type, 0, 0);\n+\t  b_or_d = get_base_distance (parmtype, type, 0, (tree*)0);\n \t  if (b_or_d < 0)\n \t    return EVIL_RETURN (h);\n \t  h.distance = -b_or_d;\n@@ -1178,7 +1178,7 @@ build_vfield_ref (datum, type)\n     rval = build (COMPONENT_REF, TREE_TYPE (CLASSTYPE_VFIELD (type)),\n \t\t  datum, CLASSTYPE_VFIELD (type));\n   else\n-    rval = build_component_ref (datum, DECL_NAME (CLASSTYPE_VFIELD (type)), 0, 0);\n+    rval = build_component_ref (datum, DECL_NAME (CLASSTYPE_VFIELD (type)), NULL_TREE, 0);\n   flag_assume_nonnull_objects = old_assume_nonnull_objects;\n \n   return rval;\n@@ -1431,7 +1431,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n \t  name = build_min_nt (BIT_NOT_EXPR, type);\n \t}\n       name = build_min_nt (SCOPE_REF, basetype, name);\n-      return build_min_nt (METHOD_CALL_EXPR, name, exp, parms, 0);\n+      return build_min_nt (METHOD_CALL_EXPR, name, exp, parms, NULL_TREE);\n     }\n \n   if (TREE_CODE (type) == REFERENCE_TYPE)\n@@ -1604,7 +1604,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  name = build_min_nt (BIT_NOT_EXPR, type);\n \t}\n \n-      return build_min_nt (METHOD_CALL_EXPR, name, instance, parms, 0);\n+      return build_min_nt (METHOD_CALL_EXPR, name, instance, parms, NULL_TREE);\n     }\n \n   /* This is the logic that magically deletes the second argument to\n@@ -2089,6 +2089,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\talloca ((len + 1) * sizeof (struct harshness_code));\n \n \t      result = build_overload_call (name, friend_parms, 0, cp);\n+\n \t      /* If it turns out to be the one we were actually looking for\n \t\t (it was probably a friend function), the return the\n \t\t good result.  */\n@@ -2577,11 +2578,11 @@ build_method_call (instance, name, parms, basetype_path, flags)\n    function's new name.  */\n \n tree\n-build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n+build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n      tree fnname, parms;\n      int flags;\n      struct candidate *final_cp;\n-     int buildxxx;\n+     int require_complete;\n {\n   /* must check for overloading here */\n   tree functions, function, parm;\n@@ -2829,8 +2830,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n       if (final_cp)\n \treturn rval;\n \n-      return buildxxx ? build_function_call_real (rval, parms, 0, flags)\n-        : build_function_call_real (rval, parms, 1, flags);\n+      return build_function_call_real (rval, parms, require_complete, flags);\n     }\n \n   if (flags & LOOKUP_SPECULATIVELY)\n@@ -2843,20 +2843,12 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n   return error_mark_node;\n }\n \n+/* This requires a complete type on the result of the call.  */\n tree\n build_overload_call (fnname, parms, flags, final_cp)\n      tree fnname, parms;\n      int flags;\n      struct candidate *final_cp;\n-{\n-  return build_overload_call_real (fnname, parms, flags, final_cp, 0);\n-}\n-\n-tree\n-build_overload_call_maybe (fnname, parms, flags, final_cp)\n-     tree fnname, parms;\n-     int flags;\n-     struct candidate *final_cp;\n {\n   return build_overload_call_real (fnname, parms, flags, final_cp, 1);\n }"}, {"sha": "4f1f23a624abe59864bf88c26cbd31c9dcf9ac28", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -126,7 +126,7 @@ build_vbase_pointer (exp, type)\n \n   name = (char *) alloca (TYPE_NAME_LENGTH (type) + sizeof (VBASE_NAME) + 1);\n   sprintf (name, VBASE_NAME_FORMAT, TYPE_NAME_STRING (type));\n-  return build_component_ref (exp, get_identifier (name), 0, 0);\n+  return build_component_ref (exp, get_identifier (name), NULL_TREE, 0);\n }\n \n /* Is the type of the EXPR, the complete type of the object?"}, {"sha": "d6db7a0103d4e78bb95484f1b1a6581ca12136e9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -1282,8 +1282,8 @@ extern int flag_new_for_scope;\n #define TYPE_GET_PTRMEMFUNC_TYPE(NODE) ((tree)TYPE_LANG_SPECIFIC(NODE))\n #define TYPE_SET_PTRMEMFUNC_TYPE(NODE, VALUE) (TYPE_LANG_SPECIFIC(NODE) = ((struct lang_type *)(void*)(VALUE)))\n /* These are to get the delta2 and pfn fields from a TYPE_PTRMEMFUNC_P. */\n-#define DELTA2_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, 0, 0), delta2_identifier, 0, 0))\n-#define PFN_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, 0, 0), pfn_identifier, 0, 0))\n+#define DELTA2_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, NULL_TREE, 0), delta2_identifier, NULL_TREE, 0))\n+#define PFN_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, NULL_TREE, 0), pfn_identifier, NULL_TREE, 0))\n \n /* Nonzero for VAR_DECL and FUNCTION_DECL node means that `extern' was\n    specified in its declaration.  */\n@@ -1945,7 +1945,6 @@ extern tree build_scoped_method_call\t\tPROTO((tree, tree, tree, tree));\n extern tree build_method_call\t\t\tPROTO((tree, tree, tree, tree, int));\n extern tree build_overload_call_real\t\tPROTO((tree, tree, int, struct candidate *, int));\n extern tree build_overload_call\t\t\tPROTO((tree, tree, int, struct candidate *));\n-extern tree build_overload_call_maybe\t\tPROTO((tree, tree, int, struct candidate *));\n \n /* in class.c */\n extern tree build_vbase_pointer\t\t\tPROTO((tree, tree));"}, {"sha": "5c09175e8722f99cca2e2581917c759874529db3", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -609,7 +609,7 @@ build_up_reference (type, arg, flags, checkconst)\n              use INDIRECT_BIND.  */\n \t  tree slot = build (VAR_DECL, argtype);\n \t  layout_decl (slot, 0);\n-\t  rval = build (TARGET_EXPR, argtype, slot, arg, 0);\n+\t  rval = build (TARGET_EXPR, argtype, slot, arg, NULL_TREE);\n \t  rval = build1 (ADDR_EXPR, type, rval);\n \t  goto done;\n \t}"}, {"sha": "7411a4eaa0d110e6282c02a311301e56e0167d15", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -139,7 +139,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t    call_target = validize_mem (call_target);\n \t  }\n \n-\tcall_exp = build (CALL_EXPR, type, func, args, 0);\n+\tcall_exp = build (CALL_EXPR, type, func, args, NULL_TREE);\n \tTREE_SIDE_EFFECTS (call_exp) = 1;\n \treturn_target = expand_call (call_exp, call_target, ignore);\n \tif (call_target == 0)"}, {"sha": "ccdc8aef4c1dc2e3236c425019632d6c58a52984", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -682,6 +682,15 @@ appear in cp-decl.c and cp-decl2.c, so the are a good candidate for\n proper fixing, and removal.\n \n \n+@item TREE_HAS_CONSTRUCTOR\n+A flag to indicate when a CALL_EXPR represents a call to a constructor.\n+If set, we know that the type of the object, is the complete type of the\n+object, and that the value returned is nonnull.  When used in this\n+fashion, it is an optimization.  Can also be used on SAVE_EXPRs to\n+indicate when they are of fixed type and nonnull.  Can also be used on\n+INDIRECT_EXPRs on CALL_EXPRs that represent a call to a constructor.\n+\n+\n @item TREE_PRIVATE\n Set for FIELD_DECLs by finish_struct.  But not uniformly set.\n "}, {"sha": "45dc9c280eb236386a2b9c8d1b9f55560ddbc24a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -174,7 +174,7 @@ perform_member_init (member, name, init, explicit, protect_list)\n       if (init != NULL_TREE && TREE_CODE (init) != TREE_LIST)\n \tinit = build_tree_list (NULL_TREE, init);\n \n-      decl = build_component_ref (C_C_D, name, 0, explicit);\n+      decl = build_component_ref (C_C_D, name, NULL_TREE, explicit);\n \n       if (explicit\n \t  && TREE_CODE (type) == ARRAY_TYPE\n@@ -220,7 +220,7 @@ perform_member_init (member, name, init, explicit, protect_list)\n \t current_member_init_list.  */\n       if (init || explicit)\n \t{\n-\t  decl = build_component_ref (C_C_D, name, 0, explicit);\n+\t  decl = build_component_ref (C_C_D, name, NULL_TREE, explicit);\n \t  expand_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n \t}\n     }\n@@ -237,7 +237,7 @@ perform_member_init (member, name, init, explicit, protect_list)\n \n   if (TYPE_NEEDS_DESTRUCTOR (type))\n     {\n-      tree expr = build_component_ref (C_C_D, name, 0, explicit);\n+      tree expr = build_component_ref (C_C_D, name, NULL_TREE, explicit);\n       expr = build_delete (type, expr, integer_zero_node,\n \t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n \n@@ -1071,7 +1071,7 @@ expand_member_init (exp, name, init)\n \t  TREE_USED (exp) = 1;\n \t}\n       type = TYPE_MAIN_VARIANT (TREE_TYPE (field));\n-      parm = build_component_ref (exp, name, 0, 0);\n+      parm = build_component_ref (exp, name, NULL_TREE, 0);\n \n       /* Now get to the constructors.  */\n       fndecl = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 0);\n@@ -1114,7 +1114,7 @@ expand_member_init (exp, name, init)\n     }\n   else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (field)))\n     {\n-      parm = build_component_ref (exp, name, 0, 0);\n+      parm = build_component_ref (exp, name, NULL_TREE, 0);\n       expand_aggr_init (parm, NULL_TREE, 0, 0);\n       rval = error_mark_node;\n     }\n@@ -1457,7 +1457,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t      tree arg = build_unary_op (ADDR_EXPR, exp, 0);\n \t      init = TREE_OPERAND (init, 1);\n \t      init = build (CALL_EXPR, build_pointer_type (TREE_TYPE (init)),\n-\t\t\t    TREE_OPERAND (init, 0), TREE_OPERAND (init, 1), 0);\n+\t\t\t    TREE_OPERAND (init, 0), TREE_OPERAND (init, 1), NULL_TREE);\n \t      TREE_SIDE_EFFECTS (init) = 1;\n \t      TREE_VALUE (TREE_OPERAND (init, 1))\n \t\t= convert_pointer_to (TREE_TYPE (TREE_TYPE (TREE_VALUE (tmp))), arg);\n@@ -2529,7 +2529,7 @@ build_builtin_call (type, node, arglist)\n      tree node;\n      tree arglist;\n {\n-  tree rval = build (CALL_EXPR, type, node, arglist, 0);\n+  tree rval = build (CALL_EXPR, type, node, arglist, NULL_TREE);\n   TREE_SIDE_EFFECTS (rval) = 1;\n   assemble_external (TREE_OPERAND (node, 0));\n   TREE_USED (TREE_OPERAND (node, 0)) = 1;\n@@ -2842,7 +2842,7 @@ build_new (placement, decl, init, use_global_new)\n       cookie = build_indirect_ref (build (MINUS_EXPR, build_pointer_type (BI_header_type),\n \t\t\t\t\t  rval, extra), NULL_PTR);\n       exp1 = build (MODIFY_EXPR, void_type_node,\n-\t\t    build_component_ref (cookie, nc_nelts_field_id, 0, 0),\n+\t\t    build_component_ref (cookie, nc_nelts_field_id, NULL_TREE, 0),\n \t\t    nelts);\n       TREE_SIDE_EFFECTS (exp1) = 1;\n       rval = convert (build_pointer_type (true_type), rval);\n@@ -3080,9 +3080,9 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n \t\t\t\t\t       base,\n \t\t\t\t\t       virtual_size)));\n   DECL_REGISTER (tbase) = 1;\n-  controller = build (BIND_EXPR, void_type_node, tbase, 0, 0);\n+  controller = build (BIND_EXPR, void_type_node, tbase, NULL_TREE, NULL_TREE);\n   TREE_SIDE_EFFECTS (controller) = 1;\n-  block = build_block (tbase, 0, 0, 0, 0);\n+  block = build_block (tbase, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE);\n   add_block_current_level (block);\n \n   if (auto_delete != integer_zero_node\n@@ -3802,7 +3802,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t    continue;\n \t  if (TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (member)))\n \t    {\n-\t      tree this_member = build_component_ref (ref, DECL_NAME (member), 0, 0);\n+\t      tree this_member = build_component_ref (ref, DECL_NAME (member), NULL_TREE, 0);\n \t      tree this_type = TREE_TYPE (member);\n \t      expr = build_delete (this_type, this_member, integer_two_node, flags, 0);\n \t      exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n@@ -3884,7 +3884,7 @@ build_vec_delete (base, maxindex, auto_delete_vec, auto_delete,\n       tree cookie_addr = build (MINUS_EXPR, build_pointer_type (BI_header_type),\n \t\t\t\tbase, BI_header_size);\n       tree cookie = build_indirect_ref (cookie_addr, NULL_PTR);\n-      maxindex = build_component_ref (cookie, nc_nelts_field_id, 0, 0);\n+      maxindex = build_component_ref (cookie, nc_nelts_field_id, NULL_TREE, 0);\n       do\n \ttype = TREE_TYPE (type);\n       while (TREE_CODE (type) == ARRAY_TYPE);"}, {"sha": "5d16db6d8bc4264ee9321bd2f79d68dd19179cd6", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -1462,7 +1462,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n     }\n   else if (code == COND_EXPR)\n     {\n-      parms = tree_cons (0, xarg2, build_tree_list (NULL_TREE, arg3));\n+      parms = tree_cons (NULL_TREE, xarg2, build_tree_list (NULL_TREE, arg3));\n       rval = build_method_call (xarg1, fnname, parms, NULL_TREE, flags);\n     }\n   else if (code == METHOD_CALL_EXPR)\n@@ -1561,7 +1561,7 @@ hack_identifier (value, name)\n \t this field was initialized by a base initializer,\n \t we can emit an error message.  */\n       TREE_USED (value) = 1;\n-      value = build_component_ref (C_C_D, name, 0, 1);\n+      value = build_component_ref (C_C_D, name, NULL_TREE, 1);\n     }\n   else if (really_overloaded_fn (value))\n     {\n@@ -1775,7 +1775,7 @@ build_component_type_expr (of, component, basetype_path, protect)\n \t}\n \n       this_this = convert_pointer_to (TREE_TYPE (of), current_class_decl);\n-      return build_component_ref (this_this, name, 0, protect);\n+      return build_component_ref (this_this, name, NULL_TREE, protect);\n     }\n   else if (cname)\n     return build_offset_ref (cname, name);"}, {"sha": "bd44fd445e94b10968ed04c0e6c7b6e7e0d2638a", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -1494,13 +1494,13 @@ primary:\n \t\t{ $$ = build_offset_ref (OP0 ($$), OP1 ($$)); }\n \t| overqualified_id '(' nonnull_exprlist ')'\n \t\t{ if (current_template_parms)\n-\t\t    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), $3, 0);\n+\t\t    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), $3, NULL_TREE);\n \t\t  else\n \t\t    $$ = build_member_call (OP0 ($$), OP1 ($$), $3); }\n \t| overqualified_id LEFT_RIGHT\n \t\t{ if (current_template_parms)\n \t\t    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), \n-\t\t\t\t       NULL_TREE, 0);\n+\t\t\t\t       NULL_TREE, NULL_TREE);\n \t\t  else\n \t\t    $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }\n \t| object unqualified_id  %prec UNARY"}, {"sha": "47a37c85a164663d06df8b03fb2c9bebdcfca50f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -1799,7 +1799,7 @@ tsubst (t, args, nargs, in_decl)\n     case CALL_EXPR:\n       return build_parse_node\n \t(CALL_EXPR, tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl), 0);\n+\t tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl), NULL_TREE);\n \n     case SCOPE_REF:\n       return build_parse_node"}, {"sha": "be98275434928be5d7726d384883f5ef4d2ef1bc", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -165,7 +165,7 @@ build_typeid (exp)\n \tt = build_vfn_ref ((tree *) 0, exp, integer_zero_node);\n       TREE_TYPE (t) = build_pointer_type (tinfo_fn_type);\n \n-      t = build (CALL_EXPR, TREE_TYPE (tinfo_fn_type), t, NULL_TREE, 0);\n+      t = build (CALL_EXPR, TREE_TYPE (tinfo_fn_type), t, NULL_TREE, NULL_TREE);\n       TREE_SIDE_EFFECTS (t) = 1;\n       return convert_from_reference (t);\n     }\n@@ -263,7 +263,7 @@ get_typeid_1 (type)\n      tree type;\n {\n   tree t = build (CALL_EXPR, TREE_TYPE (tinfo_fn_type),\n-\t\t  default_conversion (get_tinfo_fn (type)), NULL_TREE, 0);\n+\t\t  default_conversion (get_tinfo_fn (type)), NULL_TREE, NULL_TREE);\n   TREE_SIDE_EFFECTS (t) = 1;\n   return convert_from_reference (t);\n }\n@@ -317,7 +317,7 @@ throw_bad_cast ()\n \n   pop_obstacks ();\n \n-  d = build (CALL_EXPR, void_type_node, default_conversion (d), NULL_TREE, 0);\n+  d = build (CALL_EXPR, void_type_node, default_conversion (d), NULL_TREE, NULL_TREE);\n   TREE_SIDE_EFFECTS (d) = 1;\n   return d;\n }\n@@ -526,7 +526,7 @@ build_dynamic_cast (type, expr)\n \t    }\n \t  \n           result = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (dcast_fn)),\n-\t\t\t  decay_conversion (dcast_fn), elems, 0);\n+\t\t\t  decay_conversion (dcast_fn), elems, NULL_TREE);\n \t  TREE_SIDE_EFFECTS (result) = 1;\n \n \t  if (tc == REFERENCE_TYPE)\n@@ -611,7 +611,7 @@ expand_si_desc (tdecl, type)\n     }\n \n   fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t      decay_conversion (fn), elems, 0);\n+\t      decay_conversion (fn), elems, NULL_TREE);\n   TREE_SIDE_EFFECTS (fn) = 1;\n   expand_expr_stmt (fn);\n }\n@@ -791,7 +791,7 @@ expand_class_desc (tdecl, type)\n     }\n \n   fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t      decay_conversion (fn), elems, 0);\n+\t      decay_conversion (fn), elems, NULL_TREE);\n   TREE_SIDE_EFFECTS (fn) = 1;\n   expand_expr_stmt (fn);\n }\n@@ -839,7 +839,7 @@ expand_ptr_desc (tdecl, type)\n     }\n \n   fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t      decay_conversion (fn), elems, 0);\n+\t      decay_conversion (fn), elems, NULL_TREE);\n   TREE_SIDE_EFFECTS (fn) = 1;\n   expand_expr_stmt (fn);\n }\n@@ -890,7 +890,7 @@ expand_attr_desc (tdecl, type)\n     }\n \n   fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t      decay_conversion (fn), elems, 0);\n+\t      decay_conversion (fn), elems, NULL_TREE);\n   TREE_SIDE_EFFECTS (fn) = 1;\n   expand_expr_stmt (fn);\n }\n@@ -932,7 +932,7 @@ expand_generic_desc (tdecl, type, fnname)\n     }\n \n   fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t      decay_conversion (fn), elems, 0);\n+\t      decay_conversion (fn), elems, NULL_TREE);\n   TREE_SIDE_EFFECTS (fn) = 1;\n   expand_expr_stmt (fn);\n }"}, {"sha": "d7db46bec3567e54c1eade8a81d782ba82edbee6", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -2785,8 +2785,8 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t  assemble_external (vtbl);\n \t  aref = build_array_ref (vtbl, idx);\n \t  naref = build_array_ref (nvtbl, idx);\n-\t  old_delta = build_component_ref (aref, delta_identifier, 0, 0);\n-\t  new_delta = build_component_ref (naref, delta_identifier, 0, 0);\n+\t  old_delta = build_component_ref (aref, delta_identifier, NULL_TREE, 0);\n+\t  new_delta = build_component_ref (naref, delta_identifier, NULL_TREE, 0);\n \n \t  /* This is a upcast, so we have to add the offset for the\n \t     virtual base.  */"}, {"sha": "00f257efbd8320e5f8c02d5296c02d4d7c13d3bb", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -981,7 +981,7 @@ build_signature_method_call (basetype, instance, function, parms)\n       if (flag_vtable_thunks)\n \tvfn = aref;\n       else\n-\tvfn = build_component_ref (aref, pfn_identifier, 0, 0);\n+\tvfn = build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n \n       TREE_TYPE (vfn) = build_pointer_type (TREE_TYPE (function));\n "}, {"sha": "7a8ef461b1a045ed6c9dc7f9a15d94f48ce9c200", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -220,7 +220,7 @@ build_cplus_new (type, init)\n \t\tTREE_OPERAND (init, 0), TREE_OPERAND (init, 1), slot);\n   TREE_SIDE_EFFECTS (rval) = 1;\n   TREE_ADDRESSABLE (rval) = 1;\n-  rval = build (TARGET_EXPR, type, slot, rval, 0);\n+  rval = build (TARGET_EXPR, type, slot, rval, NULL_TREE);\n   TREE_SIDE_EFFECTS (rval) = 1;\n   TREE_ADDRESSABLE (rval) = 1;\n "}, {"sha": "88ce4dbe11ad267042f5aef6e940caa2cf627bfc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -2242,12 +2242,11 @@ build_array_ref (array, idx)\n    In the second case, TREE_PURPOSE (function) is the function's\n    name directly.\n \n-   DECL is the class instance variable, usually CURRENT_CLASS_DECL.  */\n+   DECL is the class instance variable, usually CURRENT_CLASS_DECL.\n+\n+   When calling a TEMPLATE_DECL, we don't require a complete return\n+   type.  */\n \n-/*\n- * [eichin:19911015.1726EST] actually return a possibly incomplete\n- * type\n- */\n tree\n build_x_function_call (function, params, decl)\n      tree function, params, decl;\n@@ -2259,7 +2258,7 @@ build_x_function_call (function, params, decl)\n     return error_mark_node;\n \n   if (current_template_parms)\n-    return build_min_nt (CALL_EXPR, function, params, 0);\n+    return build_min_nt (CALL_EXPR, function, params, NULL_TREE);\n \n   type = TREE_TYPE (function);\n \n@@ -2373,8 +2372,8 @@ build_x_function_call (function, params, decl)\n \t  tree val = TREE_VALUE (function);\n \n \t  if (TREE_CODE (val) == TEMPLATE_DECL)\n-\t    return build_overload_call_maybe\n-\t      (function, params, LOOKUP_COMPLAIN, (struct candidate *)0);\n+\t    return build_overload_call_real\n+\t      (function, params, LOOKUP_COMPLAIN, (struct candidate *)0, 0);\n \t  else if (DECL_CHAIN (val) != NULL_TREE)\n \t    return build_overload_call\n \t      (function, params, LOOKUP_COMPLAIN, (struct candidate *)0);\n@@ -2484,11 +2483,11 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n       index = save_expr (build_component_ref (function,\n \t\t\t\t\t      index_identifier,\n-\t\t\t\t\t      0, 0));\n+\t\t\t\t\t      NULL_TREE, 0));\n       e1 = build (GT_EXPR, boolean_type_node, index,\n \t\t  convert (delta_type_node, integer_zero_node));\n       delta = convert (ptrdiff_type_node,\n-\t\t       build_component_ref (function, delta_identifier, 0, 0));\n+\t\t       build_component_ref (function, delta_identifier, NULL_TREE, 0));\n       delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n \n       /* convert down to the right base, before using the instance. */\n@@ -2512,7 +2511,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t  aref = save_expr (aref);\n \n \t  delta = build_binary_op (PLUS_EXPR,\n-\t\t\t\t   build_conditional_expr (e1, build_component_ref (aref, delta_identifier, 0, 0), integer_zero_node),\n+\t\t\t\t   build_conditional_expr (e1, build_component_ref (aref, delta_identifier, NULL_TREE, 0), integer_zero_node),\n \t\t\t\t   delta, 1);\n \t}\n \n@@ -2521,7 +2520,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       if (flag_vtable_thunks)\n \te2 = aref;\n       else\n-\te2 = build_component_ref (aref, pfn_identifier, 0, 0);\n+\te2 = build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n \n       e3 = PFN_FROM_PTRMEMFUNC (function);\n       TREE_TYPE (e2) = TREE_TYPE (e3);\n@@ -3365,14 +3364,14 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       else if (TYPE_PTRMEMFUNC_P (type0) && TREE_CODE (op1) == INTEGER_CST\n \t       && integer_zerop (op1))\n \t{\n-\t  op0 = build_component_ref (op0, index_identifier, 0, 0);\n+\t  op0 = build_component_ref (op0, index_identifier, NULL_TREE, 0);\n \t  op1 = integer_zero_node;\n \t  result_type = TREE_TYPE (op0);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type1) && TREE_CODE (op0) == INTEGER_CST\n \t       && integer_zerop (op0))\n \t{\n-\t  op0 = build_component_ref (op1, index_identifier, 0, 0);\n+\t  op0 = build_component_ref (op1, index_identifier, NULL_TREE, 0);\n \t  op1 = integer_zero_node;\n \t  result_type = TREE_TYPE (op0);\n \t}\n@@ -3386,8 +3385,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t   && ((op1.index != -1 && op0.delta2 == op1.delta2)\n \t       || op0.pfn == op1.pfn)) */\n \n-\t  tree index0 = build_component_ref (op0, index_identifier, 0, 0);\n-\t  tree index1 = save_expr (build_component_ref (op1, index_identifier, 0, 0));\n+\t  tree index0 = build_component_ref (op0, index_identifier, NULL_TREE, 0);\n+\t  tree index1 = save_expr (build_component_ref (op1, index_identifier, NULL_TREE, 0));\n \t  tree pfn0 = PFN_FROM_PTRMEMFUNC (op0);\n \t  tree pfn1 = PFN_FROM_PTRMEMFUNC (op1);\n \t  tree delta20 = DELTA2_FROM_PTRMEMFUNC (op0);\n@@ -3408,7 +3407,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       else if (TYPE_PTRMEMFUNC_P (type0)\n \t       && TYPE_PTRMEMFUNC_FN_TYPE (type0) == type1)\n \t{\n-\t  tree index0 = build_component_ref (op0, index_identifier, 0, 0);\n+\t  tree index0 = build_component_ref (op0, index_identifier, NULL_TREE, 0);\n \t  tree index1;\n \t  tree pfn0 = PFN_FROM_PTRMEMFUNC (op0);\n \t  tree delta20 = DELTA2_FROM_PTRMEMFUNC (op0);\n@@ -5909,7 +5908,7 @@ build_x_modify_expr (lhs, modifycode, rhs)\n {\n   if (current_template_parms)\n     return build_min_nt (MODOP_EXPR, lhs,\n-\t\t\t build_min_nt (modifycode, 0, 0), rhs);\n+\t\t\t build_min_nt (modifycode, NULL_TREE, NULL_TREE), rhs);\n \n   if (modifycode != NOP_EXPR)\n     {\n@@ -6024,30 +6023,30 @@ build_ptrmemfunc (type, pfn, force)\n       if (TREE_CODE (pfn) != CONSTRUCTOR)\n \t{\n \t  tree e1, e2, e3;\n-\t  ndelta = convert (ptrdiff_type_node, build_component_ref (pfn, delta_identifier, 0, 0));\n+\t  ndelta = convert (ptrdiff_type_node, build_component_ref (pfn, delta_identifier, NULL_TREE, 0));\n \t  ndelta2 = convert (ptrdiff_type_node, DELTA2_FROM_PTRMEMFUNC (pfn));\n-\t  index = build_component_ref (pfn, index_identifier, 0, 0);\n+\t  index = build_component_ref (pfn, index_identifier, NULL_TREE, 0);\n \t  delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))),\n \t\t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n \t\t\t\t\tforce);\n \t  delta = build_binary_op (PLUS_EXPR, delta, ndelta, 1);\n \t  delta2 = build_binary_op (PLUS_EXPR, ndelta2, delta2, 1);\n \t  e1 = fold (build (GT_EXPR, boolean_type_node, index, integer_zero_node));\n \t  \n-\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (delta2_identifier, delta2, NULL_TREE));\n-\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t\t   tree_cons (NULL_TREE, index,\n-\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n+\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (delta2_identifier, delta2, NULL_TREE));\n+\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, delta,\n+\t\t\t\t\t\t\t   tree_cons (NULL_TREE, index,\n+\t\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n \t  e2 = digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n \n \t  pfn = PFN_FROM_PTRMEMFUNC (pfn);\n \t  npfn = build1 (NOP_EXPR, type, pfn);\n \t  TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n \n-\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (pfn_identifier, npfn, NULL_TREE));\n-\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t\t   tree_cons (NULL_TREE, index,\n-\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n+\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (pfn_identifier, npfn, NULL_TREE));\n+\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, delta,\n+\t\t\t\t\t\t\t   tree_cons (NULL_TREE, index,\n+\t\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n \t  e3 = digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n \t  return build_conditional_expr (e1, e2, e3);\n \t}\n@@ -6068,10 +6067,10 @@ build_ptrmemfunc (type, pfn, force)\n \t  pfn = build1 (NOP_EXPR, type, npfn);\n \t  TREE_CONSTANT (pfn) = TREE_CONSTANT (npfn);\n \n-\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (pfn_identifier, pfn, NULL_TREE));\n-\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t\t   tree_cons (NULL_TREE, nindex,\n-\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n+\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (pfn_identifier, pfn, NULL_TREE));\n+\t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, delta,\n+\t\t\t\t\t\t\t   tree_cons (NULL_TREE, nindex,\n+\t\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n \t  e3 = digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n \t  return e3;\n \t}\n@@ -6086,10 +6085,10 @@ build_ptrmemfunc (type, pfn, force)\n   if (integer_zerop (pfn))\n     {\n       pfn = build_c_cast (type, integer_zero_node, 0);\n-      u = build_nt (CONSTRUCTOR, 0, tree_cons (pfn_identifier, pfn, NULL_TREE));\n-      u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t       tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t\t\t  tree_cons (NULL_TREE, u, NULL_TREE))));\n+      u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (pfn_identifier, pfn, NULL_TREE));\n+      u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, integer_zero_node,\n+\t\t\t\t\t\t       tree_cons (NULL_TREE, integer_zero_node,\n+\t\t\t\t\t\t\t\t  tree_cons (NULL_TREE, u, NULL_TREE))));\n       return digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n     }\n \n@@ -6127,21 +6126,28 @@ build_ptrmemfunc (type, pfn, force)\n       index = size_binop (PLUS_EXPR,\n \t\t\t  DECL_VINDEX (TREE_OPERAND (pfn, 0)),\n \t\t\t  integer_one_node);\n-      u = build_nt (CONSTRUCTOR, 0, tree_cons (delta2_identifier, delta2, NULL_TREE));\n+      u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (delta2_identifier, delta2, NULL_TREE));\n     }\n   else\n     {\n       index = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n \n-      npfn = build1 (NOP_EXPR, type, pfn);\n-      TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n+      if (type == TREE_TYPE (pfn))\n+\t{\n+\t  npfn = pfn;\n+\t}\n+      else\n+\t{\n+\t  npfn = build1 (NOP_EXPR, type, pfn);\n+\t  TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n+\t}\n \n-      u = build_nt (CONSTRUCTOR, 0, tree_cons (pfn_identifier, npfn, NULL_TREE));\n+      u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (pfn_identifier, npfn, NULL_TREE));\n     }\n \n-  u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t   tree_cons (NULL_TREE, index,\n-\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n+  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, delta,\n+\t\t\t\t\t\t   tree_cons (NULL_TREE, index,\n+\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n   return digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n }\n "}, {"sha": "602a092e0ae382806ede97131d9e4401b98b8eb8", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dabb3791dfe9db2483914aaff3ee79f9cc74bbf/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4dabb3791dfe9db2483914aaff3ee79f9cc74bbf", "patch": "@@ -873,11 +873,11 @@ digest_init (type, init, tail)\n       else if (flag_traditional)\n \t/* Traditionally one can say `char x[100] = 0;'.  */\n \treturn process_init_constructor (type,\n-\t\t\t\t\t build_nt (CONSTRUCTOR, 0,\n-\t\t\t\t\t\t   tree_cons (0, init, 0)),\n-\t\t\t\t\t 0);\n+\t\t\t\t\t build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\t\t\t\t\t   tree_cons (NULL_TREE, init, NULL_TREE)),\n+\t\t\t\t\t (tree*)0);\n       if (code != ARRAY_TYPE)\n-\treturn convert_for_initialization (0, type, init, LOOKUP_NORMAL,\n+\treturn convert_for_initialization (NULL_TREE, type, init, LOOKUP_NORMAL,\n \t\t\t\t\t   \"initialization\", NULL_TREE, 0);\n     }\n "}]}