{"sha": "3ce1534782482f0885a330a6b0aad2f84c80b135", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NlMTUzNDc4MjQ4MmYwODg1YTMzMGE2YjBhYWQyZjg0YzgwYjEzNQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-10-01T15:11:18Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-10-01T15:11:18Z"}, "message": "Add support for v850 special data areas.\n\nFrom-SVN: r22716", "tree": {"sha": "b74ab9d466cf207ea9b5974bd432edeb82196ba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b74ab9d466cf207ea9b5974bd432edeb82196ba7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ce1534782482f0885a330a6b0aad2f84c80b135", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ce1534782482f0885a330a6b0aad2f84c80b135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ce1534782482f0885a330a6b0aad2f84c80b135", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ce1534782482f0885a330a6b0aad2f84c80b135/comments", "author": null, "committer": null, "parents": [{"sha": "e6e8607164f10e01b442ac598581a48c3d3a0001", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6e8607164f10e01b442ac598581a48c3d3a0001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6e8607164f10e01b442ac598581a48c3d3a0001"}], "stats": {"total": 1220, "additions": 1091, "deletions": 129}, "files": [{"sha": "149eeaadb49d9de97b14b73730d9b25c7694616b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce1534782482f0885a330a6b0aad2f84c80b135/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce1534782482f0885a330a6b0aad2f84c80b135/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ce1534782482f0885a330a6b0aad2f84c80b135", "patch": "@@ -13,6 +13,11 @@ Thu Oct  1 15:56:01 1998  Gavin Romig-Koch  <gavin@cygnus.com>\n \n Thu Oct  1 10:42:27 1998  Nick Clifton  <nickc@cygnus.com>\n \n+\t* config/v850/v850.c: Add function prototypes.\n+\tAdd support for v850 special data areas.\n+\n+\t* config/v850/v850.h: Add support for v850 special data areas.\n+\t\n \t* c-pragma.c: Add support for HANDLE_PRAGMA_PACK and\n \tHANDLE_PRAGMA_PACK_PUSH_POP.\n \t(push_alignment): New function: Cache an alignment requested"}, {"sha": "8d9981c810c161298da3ced161381ac78eca57d5", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 825, "deletions": 57, "changes": 882, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce1534782482f0885a330a6b0aad2f84c80b135/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce1534782482f0885a330a6b0aad2f84c80b135/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=3ce1534782482f0885a330a6b0aad2f84c80b135", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for NEC V850 series\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n This file is part of GNU CC.\n@@ -22,6 +22,7 @@ Boston, MA 02111-1307, USA.  */\n #include <stdio.h>\n #include <ctype.h>\n #include \"config.h\"\n+#include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -34,8 +35,64 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"recog.h\"\n #include \"expr.h\"\n-#include \"tree.h\"\n #include \"obstack.h\"\n+#include \"toplev.h\"\n+\n+#ifndef streq\n+#define streq(a,b) (strcmp (a, b) == 0)\n+#endif\n+\n+/* Function prototypes that cannot exist in v850.h due to dependency\n+   compilcations.  */\n+extern rtx    function_arg\n+  PROTO ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n+extern int    function_arg_partial_nregs\n+  PROTO ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n+extern void   asm_file_start                PROTO ((FILE *));\n+extern void   print_operand                 PROTO ((FILE *, rtx, int ));\n+extern void   print_operand_address         PROTO ((FILE *, rtx));\n+extern void   v850_output_aligned_bss\n+  PROTO ((FILE *, tree, char *, int, int));\n+extern void   v850_output_common\n+  PROTO ((FILE *, tree, char *, int, int));\n+extern void   v850_output_local\n+  PROTO ((FILE *, tree, char *, int, int));\n+extern int    const_costs                   PROTO ((rtx, enum rtx_code));\n+extern char * output_move_double            PROTO ((rtx *));\n+extern char * output_move_single            PROTO ((rtx *));\n+extern int    ep_memory_operand\n+  PROTO ((rtx, enum machine_mode, int));\n+extern int    reg_or_0_operand              PROTO ((rtx, enum machine_mode));\n+extern int    reg_or_int5_operand           PROTO ((rtx, enum machine_mode));\n+extern int    call_address_operand          PROTO ((rtx, enum machine_mode));\n+extern int    movsi_source_operand          PROTO ((rtx, enum machine_mode));\n+extern int    power_of_two_operand          PROTO ((rtx, enum machine_mode));\n+extern int    not_power_of_two_operand      PROTO ((rtx, enum machine_mode));\n+extern int    special_symbolref_operand     PROTO ((rtx, enum machine_mode));\n+extern void   v850_reorg                    PROTO ((rtx));\n+extern void   notice_update_cc              PROTO ((rtx, rtx));\n+extern int    v850_valid_machine_decl_attribute\n+  PROTO ((tree, tree, tree));\n+extern int    v850_interrupt_function_p     PROTO ((tree));\n+extern int    pattern_is_ok_for_prologue    PROTO ((rtx, enum machine_mode));\n+extern int    pattern_is_ok_for_epilogue    PROTO ((rtx, enum machine_mode));\n+extern int    register_is_ok_for_epilogue   PROTO ((rtx, enum machine_mode));\n+extern char * construct_save_jarl           PROTO ((rtx));\n+extern char * construct_restore_jr          PROTO ((rtx));\n+extern void   v850_encode_data_area         PROTO ((tree));\n+extern void   v850_set_default_decl_attr    PROTO ((tree));\n+\n+/* Function prototypes for stupid compilers:  */\n+static void const_double_split\n+  PROTO ((rtx, HOST_WIDE_INT *, HOST_WIDE_INT *));\n+static int  const_costs_int        PROTO ((HOST_WIDE_INT, int));\n+static void substitute_ep_register PROTO ((rtx, rtx, int, int, rtx *, rtx *));\n+static int  push_data_area         PROTO ((v850_data_area));\n+static int  pop_data_area          PROTO ((v850_data_area));\n+static int  parse_ghs_pragma_token PROTO ((char *));\n+static int  ep_memory_offset       PROTO ((enum machine_mode, int));\n+static int  mark_current_function_as_interrupt PROTO ((void));\n+static void v850_set_data_area     PROTO ((tree, v850_data_area));\n \n /* True if the current function has anonymous arguments.  */\n int current_function_anonymous_args;\n@@ -70,7 +127,7 @@ void\n override_options ()\n {\n   int i;\n-  extern int atoi ();\n+  extern int atoi PROTO ((const char *));\n \n   /* Parse -m{s,t,z}da=nnn switches */\n   for (i = 0; i < (int)SMALL_MEMORY_max; i++)\n@@ -235,6 +292,9 @@ const_double_split (x, p_high, p_low)\n \t  *p_high = CONST_DOUBLE_HIGH (x);\n \t  *p_low  = CONST_DOUBLE_LOW (x);\n \t  return;\n+\n+\tdefault:\n+\t  break;\n \t}\n     }\n \n@@ -437,13 +497,16 @@ print_operand (file, x, code)\n     case 'R':\t\t/* 2nd word of a double.  */\n       switch (GET_CODE (x))\n \t{\n-\t  case REG:\n-\t    fprintf (file, reg_names[REGNO (x) + 1]);\n-\t    break;\n-\t  case MEM:\n-\t    print_operand_address (file,\n-\t\t\t\t   XEXP (adj_offsettable_operand (x, 4), 0));\n-\t    break;\n+\tcase REG:\n+\t  fprintf (file, reg_names[REGNO (x) + 1]);\n+\t  break;\n+\tcase MEM:\n+\t  print_operand_address (file,\n+\t\t\t\t XEXP (adj_offsettable_operand (x, 4), 0));\n+\t  break;\n+\t  \n+\tdefault:\n+\t  break;\n \t}\n       break;\n     case 'S':\n@@ -724,7 +787,8 @@ output_move_single (operands)\n }\n \n \f\n-/* Return appropriate code to load up an 8 byte integer or floating point value */\n+/* Return appropriate code to load up an 8 byte integer or\n+   floating point value */\n \n char *\n output_move_double (operands)\n@@ -805,10 +869,10 @@ output_move_double (operands)\n /* Return maximum offset supported for a short EP memory reference of mode\n    MODE and signedness UNSIGNEDP.  */\n \n-int\n+static int\n ep_memory_offset (mode, unsignedp)\n      enum machine_mode mode;\n-     int unsignedp;\n+     int ATTRIBUTE_UNUSED unsignedp;\n {\n   int max_offset = 0;\n \n@@ -826,6 +890,9 @@ ep_memory_offset (mode, unsignedp)\n     case SFmode:\n       max_offset = (1 << 8);\n       break;\n+      \n+    default:\n+      break;\n     }\n \n   return max_offset;\n@@ -920,7 +987,7 @@ reg_or_int5_operand (op, mode)\n int\n call_address_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode ATTRIBUTE_UNUSED mode;\n {\n   /* Only registers are valid call operands if TARGET_LONG_CALLS.  */\n   if (TARGET_LONG_CALLS)\n@@ -931,7 +998,7 @@ call_address_operand (op, mode)\n int\n special_symbolref_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode ATTRIBUTE_UNUSED mode;\n {\n   if (GET_CODE (op) == SYMBOL_REF)\n     return ENCODED_NAME_P (XSTR (op, 0));\n@@ -968,7 +1035,7 @@ movsi_source_operand (op, mode)\n int\n power_of_two_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode ATTRIBUTE_UNUSED mode;\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -1017,7 +1084,6 @@ substitute_ep_register (first_insn, last_insn, uses, regno, p_r1, p_ep)\n {\n   rtx reg = gen_rtx (REG, Pmode, regno);\n   rtx insn;\n-  int i;\n \n   if (!*p_r1)\n     {\n@@ -1027,7 +1093,8 @@ substitute_ep_register (first_insn, last_insn, uses, regno, p_r1, p_ep)\n     }\n \n   if (TARGET_DEBUG)\n-    fprintf (stderr, \"Saved %d bytes (%d uses of register %s) in function %s, starting as insn %d, ending at %d\\n\",\n+    fprintf (stderr, \"\\\n+Saved %d bytes (%d uses of register %s) in function %s, starting as insn %d, ending at %d\\n\",\n \t     2 * (uses - 3), uses, reg_names[regno],\n \t     IDENTIFIER_POINTER (DECL_NAME (current_function_decl)),\n \t     INSN_UID (first_insn), INSN_UID (last_insn));\n@@ -1073,7 +1140,7 @@ substitute_ep_register (first_insn, last_insn, uses, regno, p_r1, p_ep)\n \t\t\t   && GET_CODE (XEXP (addr, 0)) == REG\n \t\t\t   && REGNO (XEXP (addr, 0)) == regno\n \t\t\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT\n-\t\t\t   && (((unsigned)INTVAL (XEXP (addr, 1)))\n+\t\t\t   && ((INTVAL (XEXP (addr, 1)))\n \t\t\t       < ep_memory_offset (GET_MODE (*p_mem),\n \t\t\t\t\t\t   unsignedp)))\n \t\t    *p_mem = change_address (*p_mem, VOIDmode,\n@@ -1110,11 +1177,13 @@ substitute_ep_register (first_insn, last_insn, uses, regno, p_r1, p_ep)\n void v850_reorg (start_insn)\n      rtx start_insn;\n {\n-  struct {\n+  struct\n+  {\n     int uses;\n     rtx first_insn;\n     rtx last_insn;\n-  } regs[FIRST_PSEUDO_REGISTER];\n+  }\n+  regs[FIRST_PSEUDO_REGISTER];\n \n   int i;\n   int use_ep = FALSE;\n@@ -1215,7 +1284,7 @@ void v850_reorg (start_insn)\n \t\t  else if (GET_CODE (addr) == PLUS\n \t\t\t   && GET_CODE (XEXP (addr, 0)) == REG\n \t\t\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT\n-\t\t\t   && (((unsigned)INTVAL (XEXP (addr, 1)))\n+\t\t\t   && ((INTVAL (XEXP (addr, 1)))\n \t\t\t       < ep_memory_offset (GET_MODE (mem), unsignedp)))\n \t\t    {\n \t\t      short_p = TRUE;\n@@ -1274,7 +1343,8 @@ void v850_reorg (start_insn)\n \t\t\t{\n \t\t\t  substitute_ep_register (regs[max_regno].first_insn,\n \t\t\t\t\t\t  regs[max_regno].last_insn,\n-\t\t\t\t\t\t  max_uses, max_regno, &r1, &ep);\n+\t\t\t\t\t\t  max_uses, max_regno, &r1,\n+\t\t\t\t\t\t  &ep);\n \n \t\t\t  /* Since we made a substitution, zap all remembered\n \t\t\t     registers.  */\n@@ -1397,8 +1467,8 @@ expand_prologue ()\n   unsigned int init_stack_alloc = 0;\n   rtx save_regs[32];\n   rtx save_all;\n-  int num_save;\n-  int default_stack;\n+  unsigned int num_save;\n+  unsigned int default_stack;\n   int code;\n   int interrupt_handler = v850_interrupt_function_p (current_function_decl);\n   long reg_saved = 0;\n@@ -1476,7 +1546,8 @@ expand_prologue ()\n \t stack space is allocated.  */\n       if (save_func_len < save_normal_len)\n \t{\n-\t  save_all = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (num_save + (TARGET_V850 ? 2 : 1)));\n+\t  save_all = gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t      rtvec_alloc (num_save + (TARGET_V850 ? 2 : 1)));\n \t  XVECEXP (save_all, 0, 0) = gen_rtx (SET, VOIDmode,\n \t\t\t\t\t      stack_pointer_rtx,\n \t\t\t\t\t      gen_rtx (PLUS, Pmode,\n@@ -1508,7 +1579,8 @@ expand_prologue ()\n \t      actual_fsize -= alloc_stack;\n \n \t      if (TARGET_DEBUG)\n-\t\tfprintf (stderr, \"Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n+\t\tfprintf (stderr, \"\\\n+Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n \t\t\t save_normal_len - save_func_len,\n \t\t\t save_normal_len, save_func_len,\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n@@ -1518,8 +1590,8 @@ expand_prologue ()\n \t}\n     }\n \n-  /* If no prolog save function is available, store the registers the old fashioned\n-     way (one by one). */\n+  /* If no prolog save function is available, store the registers the old\n+     fashioned way (one by one). */\n   if (!save_all)\n     {\n       /* Special case interrupt functions that save all registers for a call.  */\n@@ -1600,8 +1672,8 @@ expand_epilogue ()\n   unsigned int init_stack_free = 0;\n   rtx restore_regs[32];\n   rtx restore_all;\n-  int num_restore;\n-  int default_stack;\n+  unsigned int num_restore;\n+  unsigned int default_stack;\n   int code;\n   int interrupt_handler = v850_interrupt_function_p (current_function_decl);\n \n@@ -1637,7 +1709,8 @@ expand_epilogue ()\n   /* See if we have an insn that restores the particular registers we\n      want to.  */\n   restore_all = NULL_RTX;\n-  if (TARGET_PROLOG_FUNCTION && num_restore > 0 && actual_fsize >= default_stack\n+  if (TARGET_PROLOG_FUNCTION && num_restore > 0\n+      && actual_fsize >= default_stack\n       && !interrupt_handler)\n     {\n       int alloc_stack = (4 * num_restore) + default_stack;\n@@ -1675,7 +1748,8 @@ expand_epilogue ()\n \t\t= gen_rtx (SET, VOIDmode,\n \t\t\t   restore_regs[i],\n \t\t\t   gen_rtx (MEM, Pmode,\n-\t\t\t\t    plus_constant (stack_pointer_rtx, offset)));\n+\t\t\t\t    plus_constant\n+\t\t\t\t    (stack_pointer_rtx, offset)));\n \t      offset -= 4;\n \t    }\n \n@@ -1705,7 +1779,8 @@ expand_epilogue ()\n \t      INSN_CODE (insn) = code;\n \n \t      if (TARGET_DEBUG)\n-\t\tfprintf (stderr, \"Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n+\t\tfprintf (stderr, \"\\\n+Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n \t\t\t restore_normal_len - restore_func_len,\n \t\t\t restore_normal_len, restore_func_len,\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n@@ -1727,9 +1802,13 @@ expand_epilogue ()\n \n       /* Deallocate the rest of the stack if it is > 32K or if extra stack\n \t was allocated for an interrupt handler that makes a call.  */\n-      if (actual_fsize > init_stack_free || (interrupt_handler && actual_fsize))\n+      if (actual_fsize > init_stack_free\n+\t  || (interrupt_handler && actual_fsize))\n \t{\n-\t  int diff = actual_fsize - ((interrupt_handler) ? 0 : init_stack_free);\n+\t  int diff;\n+\n+\t  diff = actual_fsize - ((interrupt_handler) ? 0 : init_stack_free);\n+\t  \n \t  if (CONST_OK_FOR_K (diff))\n \t    emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t\t   stack_pointer_rtx,\n@@ -1843,31 +1922,97 @@ notice_update_cc (body, insn)\n       break;\n     }\n }\n-\n \f\n-/* Return nonzero if ATTR is a valid attribute for DECL.\n-   ATTRIBUTES are any existing attributes and ARGS are the arguments\n-   supplied with ATTR.\n+/* Retrieve the data area that has been chosen for the given decl.  */\n \n-   Supported attributes:\n+v850_data_area\n+v850_get_data_area (decl)\n+     tree decl;\n+{\n+  if (lookup_attribute (\"sda\", DECL_MACHINE_ATTRIBUTES (decl)) != NULL_TREE)\n+    return DATA_AREA_SDA;\n+  \n+  if (lookup_attribute (\"tda\", DECL_MACHINE_ATTRIBUTES (decl)) != NULL_TREE)\n+    return DATA_AREA_TDA;\n+  \n+  if (lookup_attribute (\"zda\", DECL_MACHINE_ATTRIBUTES (decl)) != NULL_TREE)\n+    return DATA_AREA_ZDA;\n+\n+  return DATA_AREA_NORMAL;\n+}\n \n-   interrupt_handler or interrupt: output a prologue and epilogue suitable\n-   for an interrupt handler.  */\n+/* Store the indicated data area in the decl's attributes.  */\n+\n+static void\n+v850_set_data_area (decl, data_area)\n+     tree decl;\n+     v850_data_area data_area;\n+{\n+  tree name;\n+  \n+  switch (data_area)\n+    {\n+    case DATA_AREA_SDA: name = get_identifier (\"sda\"); break;\n+    case DATA_AREA_TDA: name = get_identifier (\"tda\"); break;\n+    case DATA_AREA_ZDA: name = get_identifier (\"zda\"); break;\n+    default:\n+      return;\n+    }\n+\n+  DECL_MACHINE_ATTRIBUTES (decl) = tree_cons\n+    (name, NULL, DECL_MACHINE_ATTRIBUTES (decl));\n+}\n+\f\n+/* Return nonzero if ATTR is a valid attribute for DECL.\n+   ARGS are the arguments supplied with ATTR.  */\n \n int\n-v850_valid_machine_decl_attribute (decl, attributes, attr, args)\n+v850_valid_machine_decl_attribute (decl, attr, args)\n      tree decl;\n-     tree attributes;\n      tree attr;\n      tree args;\n {\n+  v850_data_area data_area;\n+  v850_data_area area;\n+  \n   if (args != NULL_TREE)\n     return 0;\n \n   if (is_attribute_p (\"interrupt_handler\", attr)\n       || is_attribute_p (\"interrupt\", attr))\n     return TREE_CODE (decl) == FUNCTION_DECL;\n \n+  /* Implement data area attribute.  */\n+  if (is_attribute_p (\"sda\", attr))\n+    data_area = DATA_AREA_SDA;\n+  else if (is_attribute_p (\"tda\", attr))\n+    data_area = DATA_AREA_TDA;\n+  else if (is_attribute_p (\"zda\", attr))\n+    data_area = DATA_AREA_ZDA;\n+  else\n+    return 0;\n+  \n+  switch (TREE_CODE (decl))\n+    {\n+    case VAR_DECL:\n+      if (current_function_decl != NULL_TREE)\n+\terror_with_decl (decl, \"\\\n+a data area attribute cannot be specified for local variables\");\n+      \n+      /* Drop through.  */\n+\n+    case FUNCTION_DECL:\n+      area = v850_get_data_area (decl);\n+      if (area != DATA_AREA_NORMAL && data_area != area)\n+\terror_with_decl (decl, \"\\\n+data area of '%s' conflicts with previous declaration\");\n+      \n+      return 1;\n+      \n+    default:\n+      break;\n+    }\n+  \n   return 0;\n }\n \n@@ -1907,26 +2052,75 @@ v850_interrupt_function_p (func)\n }\n \n \f\n-extern struct obstack *saveable_obstack;\n+extern struct obstack * saveable_obstack;\n \n+void\n v850_encode_data_area (decl)\n      tree decl;\n {\n-  char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n-  int len = strlen (str);\n-  char *newstr;\n+  char * str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+  int    len = strlen (str);\n+  char * newstr;\n+\n+  /* Map explict sections into the appropriate attribute */\n+  if (v850_get_data_area (decl) == DATA_AREA_NORMAL)\n+    {\n+      if (DECL_SECTION_NAME (decl))\n+\t{\n+\t  char * name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n+\t  \n+\t  if (streq (name, \".zdata\") || streq (name, \".zbss\"))\n+\t    v850_set_data_area (decl, DATA_AREA_ZDA);\n+\n+\t  else if (streq (name, \".sdata\") || streq (name, \".sbss\"))\n+\t    v850_set_data_area (decl, DATA_AREA_SDA);\n+\n+\t  else if (streq (name, \".tdata\"))\n+\t    v850_set_data_area (decl, DATA_AREA_TDA);\n+\t}\n+\n+      /* If no attribute, support -m{zda,sda,tda}=n */\n+      else\n+\t{\n+\t  int size = int_size_in_bytes (TREE_TYPE (decl));\n+\t  if (size <= 0)\n+\t    ;\n+\n+\t  else if (size <= small_memory [(int) SMALL_MEMORY_TDA].max)\n+\t    v850_set_data_area (decl, DATA_AREA_TDA);\n+\n+\t  else if (size <= small_memory [(int) SMALL_MEMORY_SDA].max)\n+\t    v850_set_data_area (decl, DATA_AREA_SDA);\n+\n+\t  else if (size <= small_memory [(int) SMALL_MEMORY_ZDA].max)\n+\t    v850_set_data_area (decl, DATA_AREA_ZDA);\n+\t}\n+      \n+      if (v850_get_data_area (decl) == DATA_AREA_NORMAL)\n+\treturn;\n+    }\n+\n+  newstr = obstack_alloc (saveable_obstack, len + 2);\n \n-  /* In the Cygnus sources we actually do something; this is just\n-     here to make merges easier.  */\n-  return;\n+  strcpy (newstr + 1, str);\n+\n+  switch (v850_get_data_area (decl))\n+    {\n+    case DATA_AREA_ZDA: *newstr = ZDA_NAME_FLAG_CHAR; break;\n+    case DATA_AREA_TDA: *newstr = TDA_NAME_FLAG_CHAR; break;\n+    case DATA_AREA_SDA: *newstr = SDA_NAME_FLAG_CHAR; break;\n+    default: abort ();\n+    }\n+\n+  XSTR (XEXP (DECL_RTL (decl), 0), 0) = newstr;\n }\n \n /* Return true if the given RTX is a register which can be restored\n    by a function epilogue.  */\n int\n register_is_ok_for_epilogue (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode ATTRIBUTE_UNUSED mode;\n {\n   /* The save/restore routines can only cope with registers 2, and 20 - 31 */\n   return (GET_CODE (op) == REG)\n@@ -1939,7 +2133,7 @@ register_is_ok_for_epilogue (op, mode)\n int\n pattern_is_ok_for_epilogue (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode ATTRIBUTE_UNUSED mode;\n {\n   int count = XVECLEN (op, 0);\n   int i;\n@@ -2085,7 +2279,7 @@ construct_restore_jr (op)\n \n   /* Note, it is possible to have gaps in the register mask.\n      We ignore this here, and generate a JR anyway.  We will\n-     be popping more registers thatn is strictly necessary, but\n+     be popping more registers than is strictly necessary, but\n      it does save code space.  */\n   \n   if (first == last)\n@@ -2102,7 +2296,7 @@ construct_restore_jr (op)\n int\n pattern_is_ok_for_prologue (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode ATTRIBUTE_UNUSED mode;\n {\n   int count = XVECLEN (op, 0);\n   int i; \n@@ -2271,7 +2465,7 @@ construct_save_jarl (op)\n \n   /* Note, it is possible to have gaps in the register mask.\n      We ignore this here, and generate a JARL anyway.  We will\n-     be pushing more registers thatn is strictly necessary, but\n+     be pushing more registers than is strictly necessary, but\n      it does save code space.  */\n   \n   if (first == last)\n@@ -2283,3 +2477,577 @@ construct_save_jarl (op)\n   return buff;\n }\n \n+extern tree last_assemble_variable_decl;\n+extern int size_directive_output;\n+\n+/* A version of asm_output_aligned_bss() that copes with the special\n+   data areas of the v850. */\n+void\n+v850_output_aligned_bss (file, decl, name, size, align)\n+     FILE * file;\n+     tree decl;\n+     char * name;\n+     int size;\n+     int align;\n+{\n+  ASM_GLOBALIZE_LABEL (file, name);\n+  \n+  switch (v850_get_data_area (decl))\n+    {\n+    case DATA_AREA_ZDA:\n+      zbss_section ();\n+      break;\n+\n+    case DATA_AREA_SDA:\n+      sbss_section ();\n+      break;\n+\n+    case DATA_AREA_TDA:\n+      tdata_section ();\n+      \n+    default:\n+      bss_section ();\n+      break;\n+    }\n+  \n+  ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));\n+#ifdef ASM_DECLARE_OBJECT_NAME\n+  last_assemble_variable_decl = decl;\n+  ASM_DECLARE_OBJECT_NAME (file, name, decl);\n+#else\n+  /* Standard thing is just output label for the object.  */\n+  ASM_OUTPUT_LABEL (file, name);\n+#endif /* ASM_DECLARE_OBJECT_NAME */\n+  ASM_OUTPUT_SKIP (file, size ? size : 1);\n+}\n+\n+/* Called via the macro ASM_OUTPUT_DECL_COMMON */\n+void\n+v850_output_common (file, decl, name, size, align)\n+     FILE * file;\n+     tree decl;\n+     char * name;\n+     int size;\n+     int align;\n+{\n+  if (decl == NULL_TREE)\n+    {\n+      fprintf (file, \"\\t%s\\t\", COMMON_ASM_OP);\n+    }\n+  else\n+    {\n+      switch (v850_get_data_area (decl))\n+\t{\n+\tcase DATA_AREA_ZDA:\n+\t  fprintf (file, \"\\t%s\\t\", ZCOMMON_ASM_OP);\n+\t  break;\n+\n+\tcase DATA_AREA_SDA:\n+\t  fprintf (file, \"\\t%s\\t\", SCOMMON_ASM_OP);\n+\t  break;\n+\n+\tcase DATA_AREA_TDA:\n+\t  fprintf (file, \"\\t%s\\t\", TCOMMON_ASM_OP);\n+\t  break;\n+      \n+\tdefault:\n+\t  fprintf (file, \"\\t%s\\t\", COMMON_ASM_OP);\n+\t  break;\n+\t}\n+    }\n+  \n+  assemble_name (file, name);\n+  fprintf (file, \",%u,%u\\n\", size, align / BITS_PER_UNIT);\n+}\n+\n+/* Called via the macro ASM_OUTPUT_DECL_LOCAL */\n+void\n+v850_output_local (file, decl, name, size, align)\n+     FILE * file;\n+     tree decl;\n+     char * name;\n+     int size;\n+     int align;\n+{\n+  fprintf (file, \"\\t%s\\t\", LOCAL_ASM_OP);\n+  assemble_name (file, name);\n+  fprintf (file, \"\\n\");\n+  \n+  ASM_OUTPUT_ALIGNED_DECL_COMMON (file, decl, name, size, align);\n+}\n+\n+/* The following code is for handling pragmas supported by the\n+   v850 compiler produced by Green Hills Software.  This is at\n+   the specific request of a customer.  */\n+\n+/* Track the current data area set by the data area pragma (which \n+   can be nested).  Tested by check_default_data_area. */\n+\n+typedef struct data_area_stack_element\n+{\n+  struct data_area_stack_element * prev;\n+  v850_data_area                   data_area; /* current default data area. */\n+} data_area_stack_element;\n+\n+static data_area_stack_element * data_area_stack = NULL;\n+\n+/* Names of the various data areas used on the v850.  */\n+static tree GHS_default_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];\n+static tree GHS_current_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];\n+\n+/* Push a data area onto the stack.  */\n+static int\n+push_data_area (data_area)\n+     v850_data_area data_area;\n+{\n+  data_area_stack_element * elem;\n+\n+  elem = (data_area_stack_element *) xmalloc (sizeof (* elem));\n+\n+  if (elem == NULL)\n+    return 0;\n+\n+  elem->prev      = data_area_stack;\n+  elem->data_area = data_area;\n+\n+  data_area_stack = elem;\n+\n+  return 1;\n+}\n+\n+/* Remove a data area from the stack.  */\n+static int\n+pop_data_area (data_area)\n+     v850_data_area data_area;\n+{\n+  if (data_area_stack == NULL)\n+    warning (\"#pragma GHS endXXXX found without previous startXXX\");\n+  else if (data_area != data_area_stack->data_area)\n+    warning (\"#pragma GHS endXXX does not match previous startXXX\");\n+  else\n+    {\n+      data_area_stack_element * elem;\n+\n+      elem = data_area_stack;\n+      data_area_stack = data_area_stack->prev;\n+\n+      free (elem);\n+\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Set the machine specific 'interrupt' attribute on the current function.  */\n+static int\n+mark_current_function_as_interrupt ()\n+{\n+  tree name;\n+  \n+  if (current_function_decl ==  NULL_TREE)\n+    {\n+      warning (\"Cannot set interrupt attribute: no current function\");\n+      return 0;\n+    }\n+\n+  name = get_identifier (\"interrupt\");\n+\n+  if (name == NULL_TREE || TREE_CODE (name) != IDENTIFIER_NODE)\n+    {\n+      warning (\"Cannot set interrupt attribute: no such identifier\");\n+      return 0;\n+    }\n+  \n+  return valid_machine_attribute\n+    (name, NULL_TREE, current_function_decl, NULL_TREE);\n+}\n+\n+/* Parse STRING as part of a GHS pragma.\n+   Returns 0 if the pragma has been parsed and there was a problem,\n+   non-zero in all other cases.  */\n+static int\n+parse_ghs_pragma_token (string)\n+     char * string;\n+{\n+  static enum v850_pragma_state state = V850_PS_START;\n+  static enum v850_pragma_type  type  = V850_PT_UNKNOWN;\n+  static v850_data_area         data_area = DATA_AREA_NORMAL;\n+  static char *                 data_area_name;\n+  static enum GHS_section_kind  GHS_section_kind = GHS_SECTION_KIND_DEFAULT;\n+\n+  /* If the string is NULL then we have reached the end of the\n+     #pragma construct.  Make sure that we are in an end state, and\n+     then implement the pragma's directive.  */\n+  if (string == NULL)\n+    {\n+      int ret_val = 1;\n+      \n+      if (state != V850_PS_SHOULD_BE_DONE\n+\t  && state != V850_PS_MAYBE_COMMA\n+\t  && state != V850_PS_MAYBE_SECTION_NAME)\n+\t{\n+\t  if (state != V850_PS_BAD)\n+\t    warning (\"Incomplete #pragma ghs\");\n+\n+\t  ret_val = 0;\n+\t}\n+      else switch (type)\n+\t{\n+\tcase V850_PT_UNKNOWN:\n+\t  warning (\"Nothing follows #pragma ghs\");\n+\t  ret_val = 0;\n+\t  break;\n+\t  \n+\tcase V850_PT_INTERRUPT:\n+\t  ret_val = mark_current_function_as_interrupt ();\n+\t  break;\n+\t  \n+\tcase V850_PT_SECTION:\n+\t  /* If a section kind has not been specified, then reset\n+\t     all section names back to their defaults.  */\n+\t  if (GHS_section_kind == GHS_SECTION_KIND_DEFAULT)\n+\t    {\n+\t      int i;\n+\t      \n+\t      for (i = COUNT_OF_GHS_SECTION_KINDS; i--;)\n+\t\tGHS_current_section_names [i] = NULL;\n+\t    }\n+\t  /* If a section has been specified, then this will be handled\n+\t     by check_default_section_name ().  */\n+\t  break;\n+\t  \n+\tcase V850_PT_START_SECTION:\n+\t  ret_val = push_data_area (data_area);\n+\t  break;\n+\t  \n+\tcase V850_PT_END_SECTION:\n+\t  ret_val = pop_data_area (data_area);\n+\t  break;\n+\t}\n+\n+      state = V850_PS_START;\n+      type  = V850_PT_UNKNOWN;\n+      \n+      return ret_val;\n+    }\n+  \n+  switch (state)\n+    {\n+    case V850_PS_START:\n+      data_area = DATA_AREA_NORMAL;\n+      data_area_name = NULL;\n+      \n+      if (streq (string, \"interrupt\"))\n+\t{\n+\t  type = V850_PT_INTERRUPT;\n+\t  state = V850_PS_SHOULD_BE_DONE;\n+\t}\n+      else if (streq (string, \"section\"))\n+\t{\n+\t  type = V850_PT_SECTION;\n+\t  state = V850_PS_MAYBE_SECTION_NAME;\n+\t  GHS_section_kind = GHS_SECTION_KIND_DEFAULT;\n+\t}\n+      else if (streq (string, \"starttda\"))\n+\t{\n+\t  type = V850_PT_START_SECTION;\n+\t  state = V850_PS_SHOULD_BE_DONE;\n+\t  data_area = DATA_AREA_TDA;\n+\t}\n+      else if (streq (string, \"endtda\"))\n+\t{\n+\t  type = V850_PT_END_SECTION;\n+\t  state = V850_PS_SHOULD_BE_DONE;\n+\t  data_area = DATA_AREA_TDA;\n+\t}\n+      else if (streq (string, \"startsda\"))\n+\t{\n+\t  type = V850_PT_START_SECTION;\n+\t  state = V850_PS_SHOULD_BE_DONE;\n+\t  data_area = DATA_AREA_SDA;\n+\t}\n+      else if (streq (string, \"endsda\"))\n+\t{\n+\t  type = V850_PT_END_SECTION;\n+\t  state = V850_PS_SHOULD_BE_DONE;\n+\t  data_area = DATA_AREA_SDA;\n+\t}\n+      else if (streq (string, \"startzda\"))\n+\t{\n+\t  type = V850_PT_START_SECTION;\n+\t  state = V850_PS_SHOULD_BE_DONE;\n+\t  data_area = DATA_AREA_ZDA;\n+\t}\n+      else if (streq (string, \"endzda\"))\n+\t{\n+\t  type = V850_PT_END_SECTION;\n+\t  state = V850_PS_SHOULD_BE_DONE;\n+\t  data_area = DATA_AREA_ZDA;\n+\t}\n+      else\n+\t{\n+\t  warning (\"Unrecognised GHS pragma: '%s'\\n\", string);\n+\t  state = V850_PS_BAD;\n+\t}\n+      break;\n+      \n+    case V850_PS_SHOULD_BE_DONE:\n+      warning (\"Extra text after valid #pragma: '%s'\", string);\n+      state = V850_PS_BAD;\n+      break;\n+      \n+    case V850_PS_BAD:\n+      /* Ignore tokens in a pragma that has been diagnosed as being corrupt. */\n+      break;\n+\n+    case V850_PS_MAYBE_SECTION_NAME:\n+      state = V850_PS_EXPECTING_EQUALS;\n+      \n+           if (streq (string, \"data\"))\t  GHS_section_kind = GHS_SECTION_KIND_DATA;\n+      else if (streq (string, \"text\"))\t  GHS_section_kind = GHS_SECTION_KIND_TEXT;\n+      else if (streq (string, \"rodata\"))  GHS_section_kind = GHS_SECTION_KIND_RODATA;\n+      else if (streq (string, \"const\"))\t  GHS_section_kind = GHS_SECTION_KIND_RODATA;\n+      else if (streq (string, \"rosdata\")) GHS_section_kind = GHS_SECTION_KIND_ROSDATA;\n+      else if (streq (string, \"rozdata\")) GHS_section_kind = GHS_SECTION_KIND_ROZDATA;\n+      else if (streq (string, \"sdata\"))\t  GHS_section_kind = GHS_SECTION_KIND_SDATA;\n+      else if (streq (string, \"tdata\"))\t  GHS_section_kind = GHS_SECTION_KIND_TDATA;\n+      else if (streq (string, \"zdata\"))\t  GHS_section_kind = GHS_SECTION_KIND_ZDATA;\n+      /* According to GHS beta documentation, the following should not be allowed!  */\n+      else if (streq (string, \"bss\"))\t  GHS_section_kind = GHS_SECTION_KIND_BSS;\n+      else if (streq (string, \"zbss\"))\t  GHS_section_kind = GHS_SECTION_KIND_ZDATA;\n+      else\n+\t{\n+\t  warning (\"Unrecognised section name '%s' in GHS section pragma\",\n+\t\t   string);\n+\t  state = V850_PS_BAD;\n+\t}\n+      break;\n+\n+    case V850_PS_EXPECTING_EQUALS:\n+      if (streq (string, \"=\"))\n+\tstate = V850_PS_EXPECTING_SECTION_ALIAS;\n+      else\n+\t{\n+\t  warning (\"Missing '=' in GHS section pragma\");\n+\t  state = V850_PS_BAD;\n+\t}\n+      break;\n+      \n+    case V850_PS_EXPECTING_SECTION_ALIAS:\n+      if (streq (string, \"default\"))\n+\tGHS_current_section_names [GHS_section_kind] = NULL;\n+      else\n+\tGHS_current_section_names [GHS_section_kind] =\n+\t  build_string (strlen (string) + 1, string);\n+      \n+      state = V850_PS_MAYBE_COMMA;\n+      break;\n+      \n+    case V850_PS_MAYBE_COMMA:\n+      if (streq (string, \",\"))\n+\tstate = V850_PS_MAYBE_SECTION_NAME;\n+      else\n+\t{\n+\t  warning\n+\t    (\"Malformed GHS section pragma: found '%s' instead of a comma\",\n+\t     string);\n+\t  state = V850_PS_BAD;\n+\t}\n+      break;\n+    }\n+  \n+  return 1;\n+}\n+\n+/* Handle the parsing of an entire GHS pragma.  */\n+int\n+v850_handle_pragma (p_getc, p_ungetc, name)\n+     int (*  p_getc) PROTO ((void));\n+     void (* p_ungetc) PROTO ((int));\n+     char *  name;\n+{\n+  /* Parse characters in the input stream until:\n+\n+   * end of line\n+   * end of file\n+   * a complete GHS pragma has been parsed\n+   * a corrupted GHS pragma has been parsed\n+   * an unknown pragma is encountered.\n+\n+   If an unknown pragma is encountered, we must return with\n+   the input stream in the same state as upon entry to this function.\n+   \n+   The first token in the input stream has already been parsed\n+   for us, and is passed as 'name'.  */\n+  \n+  if (! streq (name, \"ghs\"))\n+    return 0;\n+\n+  /* We now know that we are parsing a GHS pragma, so we do\n+     not need to preserve the original input stream state.  */\n+  for (;;)\n+    {\n+      static char buffer [128];\n+      int         c;\n+      char *      buff;\n+      \n+      /* Skip white space.  */\n+      do\n+\tc = p_getc ();\n+      while (c == ' ' || c == '\\t');\n+      \n+      p_ungetc (c);\n+      \n+      if (c == '\\n' || c == EOF || c == '\\r')\n+\treturn parse_ghs_pragma_token (NULL);\n+\n+      /* Read next word.  We have to do the parsing ourselves, rather\n+\t than calling yylex() because we can be built with front ends\n+\t that do not provide such functions.  */\n+      buff = buffer;\n+      * buff ++ = (c = p_getc ());\n+\n+      switch (c)\n+\t{\n+\tcase ',':\n+\tcase '=':\n+\t  * buff ++ = (c = p_getc ());\n+\t  break;\n+\t  \n+\tcase '\"':\n+\t  /* Skip opening double parenthesis.  */\n+\t  -- buff;\n+\n+\t  /* Read string.  */\n+\t  do\n+\t    * buff ++ = (c = p_getc ());\n+\t  while (c != EOF && isascii (c)\n+\t\t && (isalnum (c) || c == '_' || c == '.' || c == ' ')\n+\t\t && (buff < buffer + 126));\n+\t  \n+\t  if (c != '\"')\n+\t    warning (\"Missing trailing \\\" in #pragma ghs\");\n+\t  else\n+\t    c = p_getc ();\n+\t  break;\n+\n+\tdefault:\n+\t  while (c != EOF && isascii (c)\n+\t\t && (isalnum (c) || c == '_' || c == '.')\n+\t\t && (buff < buffer + 126))\n+\t    * buff ++ = (c = p_getc ());\n+\t  break;\n+\t}\n+\n+      p_ungetc (c);\n+\n+      /* If nothing was read then terminate the parsing.  */\n+      if (buff == buffer + 1)\n+\treturn parse_ghs_pragma_token (NULL);\n+\n+      /* Parse and continue.  */\n+      * -- buff = 0;\n+      \n+      parse_ghs_pragma_token (buffer);\n+    }\n+}\n+\n+/* Add data area to the given declaration if a ghs data area pragma is\n+   currently in effect (#pragma ghs startXXX/endXXX).  */\n+void\n+v850_set_default_decl_attr (decl)\n+     tree decl;\n+{\n+  if (data_area_stack\n+      && data_area_stack->data_area\n+      && current_function_decl == NULL_TREE\n+      && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == CONST_DECL)\n+      && v850_get_data_area (decl) == DATA_AREA_NORMAL)\n+    v850_set_data_area (decl, data_area_stack->data_area);\n+\n+  /* Initialise the default names of the v850 specific sections,\n+     if this has not been done before.  */\n+  \n+  if (GHS_default_section_names [(int) GHS_SECTION_KIND_SDATA] == NULL)\n+    {\n+      GHS_default_section_names [(int) GHS_SECTION_KIND_SDATA]\n+\t= build_string (sizeof (\".sdata\")-1, \".sdata\");\n+\n+      GHS_default_section_names [(int) GHS_SECTION_KIND_ROSDATA]\n+\t= build_string (sizeof (\".rosdata\")-1, \".rosdata\");\n+\n+      GHS_default_section_names [(int) GHS_SECTION_KIND_TDATA]\n+\t= build_string (sizeof (\".tdata\")-1, \".tdata\");\n+      \n+      GHS_default_section_names [(int) GHS_SECTION_KIND_ZDATA]\n+\t= build_string (sizeof (\".zdata\")-1, \".zdata\");\n+\n+      GHS_default_section_names [(int) GHS_SECTION_KIND_ROZDATA]\n+\t= build_string (sizeof (\".rozdata\")-1, \".rozdata\");\n+    }\n+  \n+  if (current_function_decl == NULL_TREE\n+      && (TREE_CODE (decl) == VAR_DECL\n+\t  || TREE_CODE (decl) == CONST_DECL\n+\t  || TREE_CODE (decl) == FUNCTION_DECL)\n+      && (!DECL_EXTERNAL (decl) || DECL_INITIAL (decl))\n+      && !DECL_SECTION_NAME (decl))\n+    {\n+      enum GHS_section_kind kind = GHS_SECTION_KIND_DEFAULT;\n+      tree chosen_section;\n+\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\tkind = GHS_SECTION_KIND_TEXT;\n+      else\n+\t{\n+\t  /* First choose a section kind based on the data area of the decl. */\n+\t  switch (v850_get_data_area (decl))\n+\t    {\n+\t    default:\n+\t      abort ();\n+\t      \n+\t    case DATA_AREA_SDA:\n+\t      kind = ((TREE_READONLY (decl))\n+\t\t      ? GHS_SECTION_KIND_ROSDATA\n+\t\t      : GHS_SECTION_KIND_SDATA);\n+\t      break;\n+\t      \n+\t    case DATA_AREA_TDA:\n+\t      kind = GHS_SECTION_KIND_TDATA;\n+\t      break;\n+\t      \n+\t    case DATA_AREA_ZDA:\n+\t      kind = ((TREE_READONLY (decl))\n+\t\t      ? GHS_SECTION_KIND_ROZDATA\n+\t\t      : GHS_SECTION_KIND_ZDATA);\n+\t      break;\n+\t      \n+\t    case DATA_AREA_NORMAL:\t\t /* default data area */\n+\t      if (TREE_READONLY (decl))\n+\t\tkind = GHS_SECTION_KIND_RODATA;\n+\t      else if (DECL_INITIAL (decl))\n+\t\tkind = GHS_SECTION_KIND_DATA;\n+\t      else\n+\t\tkind = GHS_SECTION_KIND_BSS;\n+\t    }\n+\t}\n+\n+      /* Now, if the section kind has been explicitly renamed,\n+         then attach a section attribute. */\n+      chosen_section = GHS_current_section_names [(int) kind];\n+\n+      /* Otherwise, if this kind of section needs an explicit section\n+         attribute, then also attach one. */\n+      if (chosen_section == NULL)\n+        chosen_section = GHS_default_section_names [(int) kind];\n+\n+      if (chosen_section)\n+\t{\n+\t  /* Only set the section name if specified by a pragma, because\n+\t     otherwise it will force those variables to get allocated storage\n+\t     in this module, rather than by the linker.  */\n+\t  DECL_SECTION_NAME (decl) = chosen_section;\n+\t}\n+    }\n+}"}, {"sha": "8a417f079fc7d643d9398df241273681ddb18bca", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 261, "deletions": 72, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce1534782482f0885a330a6b0aad2f84c80b135/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce1534782482f0885a330a6b0aad2f84c80b135/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=3ce1534782482f0885a330a6b0aad2f84c80b135", "patch": "@@ -20,6 +20,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"svr4.h\"\t/* Automatically does #undef CPP_PREDEFINES */\n+#include \"gansidecl.h\"\t/* For the PROTO macro  */\n \n #undef ASM_SPEC\n #define ASM_SPEC \"%{mv*:-mv%*}\"\n@@ -78,7 +79,7 @@ extern int target_flags;\n      * Doubles are normally 4 byte aligned, except in argument\n      lists where they are 8 byte aligned.  Is the alignment\n      in the argument list based on the first parameter,\n-     first stack parameter, etc., etc.\n+     first stack parameter, etc etc.\n \n      * Passing/returning of large structures probably isn't the same\n      as GHS.  We don't have enough documentation on their conventions\n@@ -112,21 +113,27 @@ extern int target_flags;\n    An empty string NAME is used to identify the default VALUE.  */\n \n #define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n-  {{ \"ghs\",\t\t\t MASK_GHS },\t\t\t\t\\\n-   { \"no-ghs\",\t\t\t-MASK_GHS },\t\t\t\t\\\n-   { \"long-calls\",\t\t MASK_LONG_CALLS },\t\t\t\\\n-   { \"no-long-calls\",\t\t-MASK_LONG_CALLS },\t\t\t\\\n-   { \"ep\",\t\t\t MASK_EP },\t\t\t\t\\\n-   { \"no-ep\",\t\t\t-MASK_EP },\t\t\t\t\\\n-   { \"prolog-function\",\t\t MASK_PROLOG_FUNCTION },\t\t\\\n-   { \"no-prolog-function\",\t-MASK_PROLOG_FUNCTION },\t\t\\\n-   { \"space\",\t\t\t MASK_EP | MASK_PROLOG_FUNCTION },\t\\\n-   { \"debug\",\t\t\t MASK_DEBUG },\t\t\t\t\\\n-   { \"v850\",\t\t \t MASK_V850 },\t\t\t\t\\\n-   { \"v850\",\t\t \t -(MASK_V850 ^ MASK_CPU) },\t\t\\\n-   { \"big-switch\",\t\t MASK_BIG_SWITCH },\t\t\t\\\n+  {{ \"ghs\",\t\t\t MASK_GHS, \"Support Green Hills ABI\" },\t\\\n+   { \"no-ghs\",\t\t\t-MASK_GHS, \"\" },\t\t\t\\\n+   { \"long-calls\",\t\t MASK_LONG_CALLS, \t\t\t\\\n+       \t\t\t\t\"Prohibit PC relative function calls\" },\\\n+   { \"no-long-calls\",\t\t-MASK_LONG_CALLS, \"\" },\t\t\t\\\n+   { \"ep\",\t\t\t MASK_EP,\t\t\t\t\\\n+                                \"Reuse r30 on a per function basis\" },  \\\n+   { \"no-ep\",\t\t\t-MASK_EP, \"\" },\t\t\t\t\\\n+   { \"prolog-function\",\t\t MASK_PROLOG_FUNCTION, \t\t\t\\\n+       \t\t\t\t\"Use stubs for function prologues\" },\t\\\n+   { \"no-prolog-function\",\t-MASK_PROLOG_FUNCTION, \"\" },\t\t\\\n+   { \"space\",\t\t\t MASK_EP | MASK_PROLOG_FUNCTION, \t\\\n+       \t\t\t\t\"Same as: -mep -mprolog-function\" },\t\\\n+   { \"debug\",\t\t\t MASK_DEBUG, \"Enable backend debugging\" }, \\\n+   { \"v850\",\t\t \t MASK_V850,\t\t\t\t\\\n+                                \"Compile for the v850 processor\" },\t\\\n+   { \"v850\",\t\t \t -(MASK_V850 ^ MASK_CPU), \"\" },\t\t\\\n+   { \"big-switch\",\t\t MASK_BIG_SWITCH, \t\t\t\\\n+       \t\t\t\t\"Use 4 byte entries in switch tables\" },\\\n    EXTRA_SWITCHES\t\t\t\t\t\t\t\\\n-   { \"\",\t\t\t TARGET_DEFAULT}}\n+   { \"\",\t\t\t TARGET_DEFAULT, \"\"}}\n \n #ifndef EXTRA_SWITCHES\n #define EXTRA_SWITCHES\n@@ -176,12 +183,15 @@ extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n \n #define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  { \"tda=\",\t&small_memory[ (int)SMALL_MEMORY_TDA ].value },\t\t\\\n-  { \"tda-\",\t&small_memory[ (int)SMALL_MEMORY_TDA ].value },\t\t\\\n-  { \"sda=\",\t&small_memory[ (int)SMALL_MEMORY_SDA ].value },\t\t\\\n-  { \"sda-\",\t&small_memory[ (int)SMALL_MEMORY_SDA ].value },\t\t\\\n-  { \"zda=\",\t&small_memory[ (int)SMALL_MEMORY_ZDA ].value },\t\t\\\n-  { \"zda-\",\t&small_memory[ (int)SMALL_MEMORY_ZDA ].value },\t\t\\\n+  { \"tda=\",\t&small_memory[ (int)SMALL_MEMORY_TDA ].value,\t\t\\\n+      \"Set the max size of data eligible for the TDA area\"  },\t\t\\\n+  { \"tda-\",\t&small_memory[ (int)SMALL_MEMORY_TDA ].value, \"\" },\t\\\n+  { \"sda=\",\t&small_memory[ (int)SMALL_MEMORY_SDA ].value, \t\t\\\n+      \"Set the max size of data eligible for the SDA area\"  },\t\t\\\n+  { \"sda-\",\t&small_memory[ (int)SMALL_MEMORY_SDA ].value, \"\" },\t\\\n+  { \"zda=\",\t&small_memory[ (int)SMALL_MEMORY_ZDA ].value, \t\t\\\n+      \"Set the max size of data eligible for the ZDA area\"  },\t\t\\\n+  { \"zda-\",\t&small_memory[ (int)SMALL_MEMORY_ZDA ].value, \"\" },\t\\\n }\n \n /* Sometimes certain combinations of command options do not make\n@@ -405,7 +415,8 @@ extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n    \n-enum reg_class {\n+enum reg_class\n+{\n   NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n@@ -581,13 +592,14 @@ enum reg_class {\n \n    Do not define this macro if it would be the same as\n    `FRAME_POINTER_REGNUM'. */\n+#undef  HARD_FRAME_POINTER_REGNUM \n #define HARD_FRAME_POINTER_REGNUM 29\n \n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM 33\n \n /* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM 5\n+#define STATIC_CHAIN_REGNUM 20\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n@@ -690,7 +702,6 @@ struct cum_arg { int nbytes; };\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-struct rtx_def *function_arg();\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, NAMED)\n \n@@ -1035,17 +1046,29 @@ do {\t\t\t\t\t\t\t\t\t\\\n    into an indirect call.  */\n #define NO_FUNCTION_CSE\n \n+/* The four different data regions on the v850.  */\n+typedef enum \n+{\n+  DATA_AREA_NORMAL,\n+  DATA_AREA_SDA,\n+  DATA_AREA_TDA,\n+  DATA_AREA_ZDA\n+} v850_data_area;\n+\n /* A list of names for sections other than the standard two, which are\n    `in_text' and `in_data'.  You need not define this macro on a\n    system with no other sections (that GCC needs to use).  */\n #undef\tEXTRA_SECTIONS\n-#define EXTRA_SECTIONS in_tdata, in_sdata, in_zdata, in_const, in_ctors, in_dtors\n+#define EXTRA_SECTIONS in_tdata, in_sdata, in_zdata, in_const, in_ctors, \\\n+in_dtors, in_rozdata, in_rosdata, in_sbss, in_zbss, in_zcommon, in_scommon\n \n /* One or more functions to be defined in `varasm.c'.  These\n    functions should do jobs analogous to those of `text_section' and\n    `data_section', for your additional sections.  Do not define this\n    macro if you do not define `EXTRA_SECTIONS'. */\n #undef\tEXTRA_SECTION_FUNCTIONS\n+\n+/* This could be done a lot more cleanly using ANSI C ... */\n #define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n CONST_SECTION_FUNCTION\t\t\t\t\t\t\t\\\n CTORS_SECTION_FUNCTION\t\t\t\t\t\t\t\\\n@@ -1062,6 +1085,26 @@ sdata_section ()\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n+rosdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_rosdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", ROSDATA_SECTION_ASM_OP);\t\t\\\n+      in_section = in_sdata;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+sbss_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_sbss)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", SBSS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_sbss;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n tdata_section ()\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (in_section != in_tdata)\t\t\t\t\t\t\\\n@@ -1079,16 +1122,42 @@ zdata_section ()\t\t\t\t\t\t\t\\\n       fprintf (asm_out_file, \"%s\\n\", ZDATA_SECTION_ASM_OP);\t\t\\\n       in_section = in_zdata;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+rozdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_rozdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", ROZDATA_SECTION_ASM_OP);\t\t\\\n+      in_section = in_rozdata;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+zbss_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_zbss)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", ZBSS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_zbss;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n }\n \n-#define TEXT_SECTION_ASM_OP \"\\t.section .text\"\n-#define DATA_SECTION_ASM_OP \"\\t.section .data\"\n-#define BSS_SECTION_ASM_OP \"\\t.section .bss\"\n+#define TEXT_SECTION_ASM_OP  \"\\t.section .text\"\n+#define DATA_SECTION_ASM_OP  \"\\t.section .data\"\n+#define BSS_SECTION_ASM_OP   \"\\t.section .bss\"\n #define SDATA_SECTION_ASM_OP \"\\t.section .sdata,\\\"aw\\\"\"\n-#define SBSS_SECTION_ASM_OP \"\\t.section .sbss,\\\"aw\\\"\"\n+#define SBSS_SECTION_ASM_OP  \"\\t.section .sbss,\\\"aw\\\"\"\n #define ZDATA_SECTION_ASM_OP \"\\t.section .zdata,\\\"aw\\\"\"\n-#define ZBSS_SECTION_ASM_OP \"\\t.section .zbss,\\\"aw\\\"\"\n+#define ZBSS_SECTION_ASM_OP  \"\\t.section .zbss,\\\"aw\\\"\"\n #define TDATA_SECTION_ASM_OP \"\\t.section .tdata,\\\"aw\\\"\"\n+#define ROSDATA_SECTION_ASM_OP \"\\t.section .rosdata,\\\"a\\\"\"\n+#define ROZDATA_SECTION_ASM_OP \"\\t.section .rozdata,\\\"a\\\"\"\n+\n+#define SCOMMON_ASM_OP \t       \".scomm\"\n+#define ZCOMMON_ASM_OP \t       \".zcomm\"\n+#define TCOMMON_ASM_OP \t       \".tcomm\"\n \n /* A C statement or statements to switch to the appropriate section\n    for output of EXP.  You can assume that EXP is either a `VAR_DECL'\n@@ -1099,18 +1168,48 @@ zdata_section ()\t\t\t\t\t\t\t\\\n \n    Do not define this macro if you put all read-only variables and\n    constants in the read-only data section (usually the text section).  */\n-#undef\tSELECT_SECTION\n+#undef  SELECT_SECTION\n #define SELECT_SECTION(EXP, RELOC)\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   if (TREE_CODE (EXP) == VAR_DECL)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if (!TREE_READONLY (EXP) || TREE_SIDE_EFFECTS (EXP)\t\t\\\n+      int is_const;\t\t\t\t\t\t\t\\\n+      if (!TREE_READONLY (EXP)\t\t\t\t\t\t\\\n+\t  || TREE_SIDE_EFFECTS (EXP)\t\t\t\t\t\\\n \t  || !DECL_INITIAL (EXP)\t\t\t\t\t\\\n \t  || (DECL_INITIAL (EXP) != error_mark_node\t\t\t\\\n \t      && !TREE_CONSTANT (DECL_INITIAL (EXP))))\t\t\t\\\n-\tdata_section ();\t\t\t\t\t\t\\\n+        is_const = FALSE;\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n-\tconst_section ();\t\t\t\t\t\t\\\n+        is_const = TRUE;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      switch (v850_get_data_area (EXP))\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+        case DATA_AREA_ZDA:\t\t\t\t\t\t\\\n+\t  if (is_const)\t        \t\t\t\t\t\\\n+\t    rozdata_section ();\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    zdata_section ();\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        case DATA_AREA_TDA:\t\t\t\t\t\t\\\n+\t  tdata_section ();\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        case DATA_AREA_SDA:\t\t\t\t\t\t\\\n+\t  if (is_const)\t\t                        \t\t\\\n+\t    rosdata_section ();\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    sdata_section ();\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        default:\t\t\t\t\t\t\t\\\n+          if (is_const)\t\t\t\t\t\t\t\\\n+\t    const_section ();\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    data_section ();\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else if (TREE_CODE (EXP) == STRING_CST)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -1203,6 +1302,24 @@ do { char dstr[30];\t\t\t\t\t\\\n #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n   asm_output_aligned_bss ((FILE), (DECL), (NAME), (SIZE), (ALIGN))\n \n+#undef  ASM_OUTPUT_ALIGNED_BSS \n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n+  v850_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+\n+/* This says how to output the assembler to define a global\n+   uninitialized, common symbol. */\n+#undef  ASM_OUTPUT_ALIGNED_COMMON\n+#undef  ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN) \\\n+     v850_output_common (FILE, DECL, NAME, SIZE, ALIGN)\n+\n+/* This says how to output the assembler to define a local\n+   uninitialized symbol. */\n+#undef  ASM_OUTPUT_ALIGNED_LOCAL\n+#undef  ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN) \\\n+     v850_output_local (FILE, DECL, NAME, SIZE, ALIGN)\n+     \n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n \n@@ -1266,7 +1383,7 @@ do { char dstr[30];\t\t\t\t\t\\\n /* Print an instruction operand X on file FILE.\n    look in v850.c for details */\n \n-#define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE,X,CODE)\n+#define PRINT_OPERAND(FILE, X, CODE)  print_operand (FILE, X, CODE)\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n   ((CODE) == '.')\n@@ -1377,15 +1494,69 @@ do { char dstr[30];\t\t\t\t\t\\\n    is a valid machine specific attribute for DECL.\n    The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n-v850_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n+  v850_valid_machine_decl_attribute (DECL, IDENTIFIER, ARGS)\n \n-/* Tell compiler we have {ZDA,TDA,SDA} small data regions */\n-#define HAVE_ZDA 1\n-#define HAVE_SDA 1\n-#define HAVE_TDA 1\n+/* A C statement that assigns default attributes to a newly created DECL.  */\n+#define SET_DEFAULT_DECL_ATTRIBUTES(decl, attr) \\\n+     v850_set_default_decl_attr (decl)\n \n /* Tell compiler we want to support GHS pragmas */\n-#define HANDLE_GHS_PRAGMA\n+#define HANDLE_PRAGMA(get, unget, name) v850_handle_pragma (get, unget, name)\n+\n+enum v850_pragma_state\n+{\n+  V850_PS_START,\n+  V850_PS_SHOULD_BE_DONE,\n+  V850_PS_BAD,\n+  V850_PS_MAYBE_SECTION_NAME,\n+  V850_PS_EXPECTING_EQUALS,\n+  V850_PS_EXPECTING_SECTION_ALIAS,\n+  V850_PS_MAYBE_COMMA\n+};\n+\n+enum v850_pragma_type\n+{\n+  V850_PT_UNKNOWN,\n+  V850_PT_INTERRUPT,\n+  V850_PT_SECTION,\n+  V850_PT_START_SECTION,\n+  V850_PT_END_SECTION\n+};\n+\n+/* enum GHS_SECTION_KIND is an enumeration of the kinds of sections that\n+   can appear in the \"ghs section\" pragma.  These names are used to index\n+   into the GHS_default_section_names[] and GHS_current_section_names[]\n+   that are defined in v850.c, and so the ordering of each must remain\n+   consistant. \n+\n+   These arrays give the default and current names for each kind of \n+   section defined by the GHS pragmas.  The current names can be changed\n+   by the \"ghs section\" pragma.  If the current names are null, use \n+   the default names.  Note that the two arrays have different types.\n+\n+   For the *normal* section kinds (like .data, .text, etc.) we do not\n+   want to explicitly force the name of these sections, but would rather\n+   let the linker (or at least the back end) choose the name of the \n+   section, UNLESS the user has force a specific name for these section\n+   kinds.  To accomplish this set the name in ghs_default_section_names\n+   to null.  */\n+\n+enum GHS_section_kind\n+{ \n+  GHS_SECTION_KIND_DEFAULT,\n+\n+  GHS_SECTION_KIND_TEXT,\n+  GHS_SECTION_KIND_DATA, \n+  GHS_SECTION_KIND_RODATA,\n+  GHS_SECTION_KIND_BSS,\n+  GHS_SECTION_KIND_SDATA,\n+  GHS_SECTION_KIND_ROSDATA,\n+  GHS_SECTION_KIND_TDATA,\n+  GHS_SECTION_KIND_ZDATA,\n+  GHS_SECTION_KIND_ROZDATA,\n+\n+  COUNT_OF_GHS_SECTION_KINDS  /* must be last */\n+};\n \n /* The assembler op to start the file.  */\n \n@@ -1444,34 +1615,52 @@ do {\t\t\t\t\t\t\t\t\t\\\n { \"register_is_ok_for_epilogue\",{ REG }},\t\t\t\t\\\n { \"not_power_of_two_operand\",\t{ CONST_INT }},\n \n-extern void override_options ();\n-extern void asm_file_start ();\n-extern int function_arg_partial_nregs ();\n-extern int const_costs ();\n-extern void print_operand ();\n-extern void print_operand_address ();\n-extern char *output_move_double ();\n-extern char *output_move_single ();\n-extern int ep_operand ();\n-extern int reg_or_0_operand ();\n-extern int reg_or_int5_operand ();\n-extern int call_address_operand ();\n-extern int movsi_source_operand ();\n-extern int power_of_two_operand ();\n-extern int not_power_of_two_operand ();\n-extern void v850_reorg ();\n-extern int compute_register_save_size ();\n-extern int compute_frame_size ();\n-extern void expand_prologue ();\n-extern void expand_epilogue ();\n-extern void notice_update_cc ();\n-extern int v850_valid_machine_decl_attribute ();\n-extern int v850_interrupt_function_p ();\n-\n-extern int pattern_is_ok_for_prologue();\n-extern int pattern_is_ok_for_epilogue();\n-extern int register_is_ok_for_epilogue ();\n-extern char *construct_save_jarl ();\n-extern char *construct_restore_jr ();\n-\n-\n+  /* Note, due to dependency and search path conflicts, prototypes\n+     involving the FILE, rtx or tree types cannot be included here.\n+     They are included at the start of v850.c  */\n+  \n+extern void   asm_file_start                ();\n+extern void   print_operand                 ();\n+extern void   print_operand_address         ();\n+extern int    function_arg_partial_nregs    ();\n+extern int    const_costs                   ();\n+extern char * output_move_double            ();\n+extern char * output_move_single            ();\n+extern int    ep_memory_operand             ();\n+extern int    reg_or_0_operand              ();\n+extern int    reg_or_int5_operand           ();\n+extern int    call_address_operand          ();\n+extern int    movsi_source_operand          ();\n+extern int    power_of_two_operand          ();\n+extern int    not_power_of_two_operand      ();\n+extern int    special_symbolref_operand     ();\n+extern void   v850_reorg                    ();\n+extern void   notice_update_cc              ();\n+extern int    v850_valid_machine_decl_attribute ();\n+extern int    v850_interrupt_function_p     ();\n+extern int    pattern_is_ok_for_prologue    ();\n+extern int    pattern_is_ok_for_epilogue    ();\n+extern int    register_is_ok_for_epilogue   ();\n+extern char * construct_save_jarl           ();\n+extern char * construct_restore_jr          ();\n+\n+extern void   override_options              PROTO ((void));\n+extern int    compute_register_save_size    PROTO ((long *));\n+extern int    compute_frame_size            PROTO ((int, long *));\n+extern void   expand_prologue               PROTO ((void));\n+extern void   expand_epilogue               PROTO ((void));\n+\n+extern void   v850_output_aligned_bss       ();\n+extern void   v850_output_common            ();\n+extern void   v850_output_local             ();\n+extern void   sdata_section                 PROTO ((void));\n+extern void   rosdata_section               PROTO ((void));\n+extern void   sbss_section                  PROTO ((void));\n+extern void   tdata_section                 PROTO ((void));\n+extern void   zdata_section                 PROTO ((void));\n+extern void   rozdata_section               PROTO ((void));\n+extern void   zbss_section                  PROTO ((void));\n+extern int    v850_handle_pragma            PROTO ((int (*)(void), void (*)(int), char *));\n+extern void   v850_encode_data_area         ();\n+extern void   v850_set_default_decl_attr    ();\n+extern v850_data_area v850_get_data_area    ();"}]}