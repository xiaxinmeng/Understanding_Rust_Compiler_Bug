{"sha": "278c466207b2d592d8ea21234d6cb228b95bc246", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc4YzQ2NjIwN2IyZDU5MmQ4ZWEyMTIzNGQ2Y2IyMjhiOTViYzI0Ng==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2002-06-19T05:40:08Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-19T05:40:08Z"}, "message": "cpphash.h (struct cpp_reader): Make date and time strings.\n\n\t* cpphash.h (struct cpp_reader): Make date and time strings.\n\t(_cpp_builtin_macro_text, _cpp_copy_replacement_text,\n\t_cpp_replacement_text_len): New.\n\t* cppinit.c (cpp_create_reader): Update.\n\t(init_builtins): Register appropriate builtins for -traditional-cpp.\n\t* cppmacro.c (new_number_token): Remove.\n\t(_cpp_builtin_macro_text): New.\n\t(builtin_macro): Use it.\n\t(cpp_macro_definition): Update to handle traditional macros.\n\t* cppmain.c (cb_line_change): Don't do column positioning for\n\ttraditional output.\n\t* cpptrad.c (enum ls): Rename ls_fun_macro to ls_fun_open.  New\n\tstate ls_fun_close.\n\t(skip_whitespace): Fix.\n\t(maybe_start_funlike): Don't set state.parsing_args.\n\t(scan_out_logical_line): Remove duplicate error.  Use lex_state\n\trather than state.parsing_args.\n\t(push_replacement_text): Handle builtins.\n\t(_cpp_replacement_text_len, _cpp_copy_replacement_text): New.\n\nFrom-SVN: r54771", "tree": {"sha": "3c3d821dfd3b04ed9aaf9b7fbdf7297ca8b32a1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c3d821dfd3b04ed9aaf9b7fbdf7297ca8b32a1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/278c466207b2d592d8ea21234d6cb228b95bc246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/278c466207b2d592d8ea21234d6cb228b95bc246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/278c466207b2d592d8ea21234d6cb228b95bc246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/278c466207b2d592d8ea21234d6cb228b95bc246/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9d7b4c5a4ff06264dd94b5da29bd32ffc8e4435a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d7b4c5a4ff06264dd94b5da29bd32ffc8e4435a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d7b4c5a4ff06264dd94b5da29bd32ffc8e4435a"}], "stats": {"total": 340, "additions": 234, "deletions": 106}, "files": [{"sha": "327cc7c26eb2dd511f17ab5607ba0550873d3615", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=278c466207b2d592d8ea21234d6cb228b95bc246", "patch": "@@ -1,3 +1,25 @@\n+2002-06-19  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* cpphash.h (struct cpp_reader): Make date and time strings.\n+\t(_cpp_builtin_macro_text, _cpp_copy_replacement_text,\n+\t_cpp_replacement_text_len): New.\n+\t* cppinit.c (cpp_create_reader): Update.\n+\t(init_builtins): Register appropriate builtins for -traditional-cpp.\n+\t* cppmacro.c (new_number_token): Remove.\n+\t(_cpp_builtin_macro_text): New.\n+\t(builtin_macro): Use it.\n+\t(cpp_macro_definition): Update to handle traditional macros.\n+\t* cppmain.c (cb_line_change): Don't do column positioning for\n+\ttraditional output.\n+\t* cpptrad.c (enum ls): Rename ls_fun_macro to ls_fun_open.  New\n+\tstate ls_fun_close.\n+\t(skip_whitespace): Fix.\n+\t(maybe_start_funlike): Don't set state.parsing_args.\n+\t(scan_out_logical_line): Remove duplicate error.  Use lex_state\n+\trather than state.parsing_args.\n+\t(push_replacement_text): Handle builtins.\n+\t(_cpp_replacement_text_len, _cpp_copy_replacement_text): New.\n+\n 2002-06-18  Hans-Peter Nilsson  <hp@axis.com>\n             Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n "}, {"sha": "ee9a47effc4ed6df40de180f4ebfd8c491625752", "filename": "gcc/cpphash.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=278c466207b2d592d8ea21234d6cb228b95bc246", "patch": "@@ -370,9 +370,9 @@ struct cpp_reader\n      for include files.  (Altered as we get more of them.)  */\n   unsigned int max_include_len;\n \n-  /* Date and time tokens.  Calculated together if either is requested.  */\n-  cpp_token date;\n-  cpp_token time;\n+  /* Date and time text.  Calculated together if either is requested.  */\n+  const uchar *date;\n+  const uchar *time;\n \n   /* EOF token, and a token forcing paste avoidance.  */\n   cpp_token avoid_paste;\n@@ -475,7 +475,8 @@ extern bool _cpp_save_parameter\t\tPARAMS ((cpp_reader *, cpp_macro *,\n extern bool _cpp_arguments_ok\t\tPARAMS ((cpp_reader *, cpp_macro *,\n \t\t\t\t\t\t const cpp_hashnode *,\n \t\t\t\t\t\t unsigned int));\n-\n+extern const uchar *_cpp_builtin_macro_text PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t     cpp_hashnode *));\n /* In cpphash.c */\n extern void _cpp_init_hashtable\t\tPARAMS ((cpp_reader *, hash_table *));\n extern void _cpp_destroy_hashtable\tPARAMS ((cpp_reader *));\n@@ -532,6 +533,8 @@ extern void _cpp_set_trad_context PARAMS ((cpp_reader *));\n extern bool _cpp_create_trad_definition PARAMS ((cpp_reader *, cpp_macro *));\n extern bool _cpp_expansions_different_trad PARAMS ((const cpp_macro *,\n \t\t\t\t\t\t    const cpp_macro *));\n+extern uchar *_cpp_copy_replacement_text PARAMS ((const cpp_macro *, uchar *));\n+extern size_t _cpp_replacement_text_len PARAMS ((const cpp_macro *));\n \n /* Utility routines and macros.  */\n #define DSC(str) (const uchar *)str, sizeof str - 1"}, {"sha": "1df4bacb12bcd654d0df9b81fe9b23b863e007b0", "filename": "gcc/cppinit.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=278c466207b2d592d8ea21234d6cb228b95bc246", "patch": "@@ -512,7 +512,6 @@ cpp_create_reader (lang)\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n \n   /* Set up static tokens.  */\n-  pfile->date.type = CPP_EOF;\n   pfile->avoid_paste.type = CPP_PADDING;\n   pfile->avoid_paste.val.source = NULL;\n   pfile->eof.type = CPP_EOF;\n@@ -640,6 +639,8 @@ static const struct builtin builtin_array[] =\n   B(\"__BASE_FILE__\",\t BT_BASE_FILE),\n   B(\"__LINE__\",\t\t BT_SPECLINE),\n   B(\"__INCLUDE_LEVEL__\", BT_INCLUDE_LEVEL),\n+  /* Keep builtins not used for -traditional-cpp at the end, and\n+     update init_builtins() if any more are added.  */\n   B(\"_Pragma\",\t\t BT_PRAGMA),\n   B(\"__STDC__\",\t\t BT_STDC),\n };\n@@ -684,10 +685,12 @@ init_builtins (pfile)\n      cpp_reader *pfile;\n {\n   const struct builtin *b;\n+  size_t n = ARRAY_SIZE (builtin_array);\n \n-  for(b = builtin_array;\n-      b < (builtin_array + ARRAY_SIZE (builtin_array));\n-      b++)\n+  if (CPP_OPTION (pfile, traditional))\n+    n -= 2;\n+\n+  for(b = builtin_array; b < builtin_array + n; b++)\n     {\n       cpp_hashnode *hp = cpp_lookup (pfile, b->name, b->len);\n       hp->type = NT_MACRO;"}, {"sha": "99cdc19e0073d54cd38aafba906a742c31ebe2f1", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 87, "deletions": 64, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=278c466207b2d592d8ea21234d6cb228b95bc246", "patch": "@@ -54,7 +54,6 @@ static const cpp_token *padding_token\n static void expand_arg PARAMS ((cpp_reader *, macro_arg *));\n static const cpp_token *new_string_token PARAMS ((cpp_reader *, uchar *,\n \t\t\t\t\t\t  unsigned int));\n-static const cpp_token *new_number_token PARAMS ((cpp_reader *, unsigned int));\n static const cpp_token *stringify_arg PARAMS ((cpp_reader *, macro_arg *));\n static void paste_all_tokens PARAMS ((cpp_reader *, const cpp_token *));\n static bool paste_tokens PARAMS ((cpp_reader *, const cpp_token **,\n@@ -93,24 +92,6 @@ new_string_token (pfile, text, len)\n   return token;\n }\n \n-/* Allocates and returns a CPP_NUMBER token evaluating to NUMBER.  */\n-static const cpp_token *\n-new_number_token (pfile, number)\n-     cpp_reader *pfile;\n-     unsigned int number;\n-{\n-  cpp_token *token = _cpp_temp_token (pfile);\n-  /* 21 bytes holds all NUL-terminated unsigned 64-bit numbers.  */\n-  unsigned char *buf = _cpp_unaligned_alloc (pfile, 21);\n-\n-  sprintf ((char *) buf, \"%u\", number);\n-  token->type = CPP_NUMBER;\n-  token->val.str.text = buf;\n-  token->val.str.len = ustrlen (buf);\n-  token->flags = 0;\n-  return token;\n-}\n-\n static const char * const monthnames[] =\n {\n   \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n@@ -121,19 +102,20 @@ static const char * const monthnames[] =\n    on the context stack.  Also handles _Pragma, for which no new token\n    is created.  Returns 1 if it generates a new token context, 0 to\n    return the token to the caller.  */\n-static int\n-builtin_macro (pfile, node)\n+const uchar *\n+_cpp_builtin_macro_text (pfile, node)\n      cpp_reader *pfile;\n      cpp_hashnode *node;\n {\n-  const cpp_token *result;\n+  const uchar *result = NULL;\n+  unsigned int number = 1;\n \n   switch (node->value.builtin)\n     {\n     default:\n       cpp_error (pfile, DL_ICE, \"invalid built-in macro \\\"%s\\\"\",\n \t\t NODE_NAME (node));\n-      return 0;\n+      break;\n \n     case BT_FILE:\n     case BT_BASE_FILE:\n@@ -149,27 +131,31 @@ builtin_macro (pfile, node)\n \n \tname = map->to_file;\n \tlen = strlen (name);\n-\tbuf = _cpp_unaligned_alloc (pfile, len * 4 + 1);\n-\tlen = cpp_quote_string (buf, (const unsigned char *) name, len) - buf;\n-\n-\tresult = new_string_token (pfile, buf, len);\n+\tbuf = _cpp_unaligned_alloc (pfile, len * 4 + 3);\n+\tresult = buf;\n+\t*buf = '\"';\n+\tbuf = cpp_quote_string (buf + 1, (const unsigned char *) name, len);\n+\t*buf++ = '\"';\n+\t*buf = '\\0';\n       }\n       break;\n \n     case BT_INCLUDE_LEVEL:\n       /* The line map depth counts the primary source as level 1, but\n \t historically __INCLUDE_DEPTH__ has called the primary source\n \t level 0.  */\n-      result = new_number_token (pfile, pfile->line_maps.depth - 1);\n+      number = pfile->line_maps.depth - 1;\n       break;\n \n     case BT_SPECLINE:\n       /* If __LINE__ is embedded in a macro, it must expand to the\n \t line of the macro's invocation, not its definition.\n \t Otherwise things like assert() will not work properly.  */\n-      result = new_number_token (pfile,\n-\t\t\t\t SOURCE_LINE (pfile->map,\n-\t\t\t\t\t      pfile->cur_token[-1].line));\n+      if (CPP_OPTION (pfile, traditional))\n+\tnumber = pfile->line;\n+      else\n+\tnumber = pfile->cur_token[-1].line;\n+      number = SOURCE_LINE (pfile->map, number);\n       break;\n \n       /* __STDC__ has the value 1 under normal circumstances.\n@@ -179,23 +165,20 @@ builtin_macro (pfile, node)\n \t value 0.  */\n     case BT_STDC:\n       {\n-\tint stdc;\n \tenum c_lang lang = CPP_OPTION (pfile, lang);\n \tif (CPP_IN_SYSTEM_HEADER (pfile)\n \t    && CPP_OPTION (pfile, stdc_0_in_system_headers)\n \t    && !(lang == CLK_STDC89 || lang == CLK_STDC94\n \t\t || lang == CLK_STDC99))  /* || lang == CLK_CXX98 ? */\n-\t  stdc = 0;\n+\t  number = 0;\n \telse\n-\t  stdc = 1;\n-\n-\tresult = new_number_token (pfile, stdc);\n+\t  number = 1;\n       }\n       break;\n \n     case BT_DATE:\n     case BT_TIME:\n-      if (pfile->date.type == CPP_EOF)\n+      if (pfile->date == NULL)\n \t{\n \t  /* Allocate __DATE__ and __TIME__ strings from permanent\n \t     storage.  We only do this once, and don't generate them\n@@ -204,30 +187,46 @@ builtin_macro (pfile, node)\n \t  time_t tt = time (NULL);\n \t  struct tm *tb = localtime (&tt);\n \n-\t  pfile->date.val.str.text =\n-\t    _cpp_unaligned_alloc (pfile, sizeof (\"Oct 11 1347\"));\n-\t  pfile->date.val.str.len = sizeof (\"Oct 11 1347\") - 1;\n-\t  pfile->date.type = CPP_STRING;\n-\t  pfile->date.flags = 0;\n-\t  sprintf ((char *) pfile->date.val.str.text, \"%s %2d %4d\",\n+\t  pfile->date = _cpp_unaligned_alloc (pfile,\n+\t\t\t\t\t      sizeof (\"\\\"Oct 11 1347\\\"\"));\n+\t  sprintf ((char *) pfile->date, \"\\\"%s %2d %4d\\\"\",\n \t\t   monthnames[tb->tm_mon], tb->tm_mday, tb->tm_year + 1900);\n \n-\t  pfile->time.val.str.text =\n-\t    _cpp_unaligned_alloc (pfile, sizeof (\"12:34:56\"));\n-\t  pfile->time.val.str.len = sizeof (\"12:34:56\") - 1;\n-\t  pfile->time.type = CPP_STRING;\n-\t  pfile->time.flags = 0;\n-\t  sprintf ((char *) pfile->time.val.str.text, \"%02d:%02d:%02d\",\n+\t  pfile->time = _cpp_unaligned_alloc (pfile, sizeof (\"\\\"12:34:56\\\"\"));\n+\t  sprintf ((char *) pfile->time, \"\\\"%02d:%02d:%02d\\\"\",\n \t\t   tb->tm_hour, tb->tm_min, tb->tm_sec);\n \t}\n \n       if (node->value.builtin == BT_DATE)\n-\tresult = &pfile->date;\n+\tresult = pfile->date;\n       else\n-\tresult = &pfile->time;\n+\tresult = pfile->time;\n       break;\n+    }\n+\n+  if (result == NULL)\n+    {\n+      /* 21 bytes holds all NUL-terminated unsigned 64-bit numbers.  */\n+      result = _cpp_unaligned_alloc (pfile, 21);\n+      sprintf ((char *) result, \"%u\", number);\n+    }\n+\n+  return result;      \n+}\n+\n+/* Convert builtin macros like __FILE__ to a token and push it on the\n+   context stack.  Also handles _Pragma, for which no new token is\n+   created.  Returns 1 if it generates a new token context, 0 to\n+   return the token to the caller.  */\n+static int\n+builtin_macro (pfile, node)\n+     cpp_reader *pfile;\n+     cpp_hashnode *node;\n+{\n+  const uchar *buf;\n \n-    case BT_PRAGMA:\n+  if (node->value.builtin == BT_PRAGMA)\n+    {\n       /* Don't interpret _Pragma within directives.  The standard is\n          not clear on this, but to me this makes most sense.  */\n       if (pfile->state.in_directive)\n@@ -237,7 +236,24 @@ builtin_macro (pfile, node)\n       return 1;\n     }\n \n-  push_token_context (pfile, NULL, result, 1);\n+  buf = _cpp_builtin_macro_text (pfile, node);\n+\n+  cpp_push_buffer (pfile, buf, ustrlen (buf), /* from_stage3 */ true, 1);\n+\n+  /* Tweak the column number the lexer will report.  */\n+  pfile->buffer->col_adjust = pfile->cur_token[-1].col - 1;\n+\n+  /* We don't want a leading # to be interpreted as a directive.  */\n+  pfile->buffer->saved_flags = 0;\n+\n+  /* Set pfile->cur_token as required by _cpp_lex_direct.  */\n+  pfile->cur_token = _cpp_temp_token (pfile);\n+  push_token_context (pfile, NULL, _cpp_lex_direct (pfile), 1);\n+  if (pfile->buffer->cur != pfile->buffer->rlimit)\n+    cpp_error (pfile, DL_ICE, \"invalid built-in macro \\\"%s\\\"\",\n+\t       NODE_NAME (node));\n+  _cpp_pop_buffer (pfile);\n+\n   return 1;\n }\n \n@@ -1598,18 +1614,23 @@ cpp_macro_definition (pfile, node)\n \tlen += NODE_LEN (macro->params[i]) + 1; /* \",\" */\n     }\n \n-  for (i = 0; i < macro->count; i++)\n+  if (CPP_OPTION (pfile, traditional))\n+    len += _cpp_replacement_text_len (macro);\n+  else\n     {\n-      cpp_token *token = &macro->exp.tokens[i];\n+      for (i = 0; i < macro->count; i++)\n+\t{\n+\t  cpp_token *token = &macro->exp.tokens[i];\n \n-      if (token->type == CPP_MACRO_ARG)\n-\tlen += NODE_LEN (macro->params[token->val.arg_no - 1]);\n-      else\n-\tlen += cpp_token_len (token); /* Includes room for ' '.  */\n-      if (token->flags & STRINGIFY_ARG)\n-\tlen++;\t\t\t/* \"#\" */\n-      if (token->flags & PASTE_LEFT)\n-\tlen += 3;\t\t/* \" ##\" */\n+\t  if (token->type == CPP_MACRO_ARG)\n+\t    len += NODE_LEN (macro->params[token->val.arg_no - 1]);\n+\t  else\n+\t    len += cpp_token_len (token); /* Includes room for ' '.  */\n+\t  if (token->flags & STRINGIFY_ARG)\n+\t    len++;\t\t\t/* \"#\" */\n+\t  if (token->flags & PASTE_LEFT)\n+\t    len += 3;\t\t/* \" ##\" */\n+\t}\n     }\n \n   if (len > pfile->macro_buffer_len)\n@@ -1652,8 +1673,10 @@ cpp_macro_definition (pfile, node)\n      definition is the empty string.  */\n   *buffer++ = ' ';\n \n+  if (CPP_OPTION (pfile, traditional))\n+    buffer = _cpp_copy_replacement_text (macro, buffer);\n+  else if (macro->count)\n   /* Expansion tokens.  */\n-  if (macro->count)\n     {\n       for (i = 0; i < macro->count; i++)\n \t{"}, {"sha": "dba64041bf5b14820ab5024e9a6a10f8716fcd23", "filename": "gcc/cppmain.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=278c466207b2d592d8ea21234d6cb228b95bc246", "patch": "@@ -320,7 +320,6 @@ cb_line_change (pfile, token, parsing_args)\n     return;\n \n   maybe_print_line (print.map, token->line);\n-  print.printed = 1;\n   print.prev = 0;\n   print.source = 0;\n \n@@ -329,12 +328,16 @@ cb_line_change (pfile, token, parsing_args)\n      will provide a space if PREV_WHITE.  Don't bother trying to\n      reconstruct tabs; we can't get it right in general, and nothing\n      ought to care.  Some things do care; the fault lies with them.  */\n-  if (token->col > 2)\n+  if (!CPP_OPTION (pfile, traditional))\n     {\n-      unsigned int spaces = token->col - 2;\n+      print.printed = 1;\n+      if (token->col > 2)\n+\t{\n+\t  unsigned int spaces = token->col - 2;\n \n-      while (spaces--)\n-\tputc (' ', print.outf);\n+\t  while (spaces--)\n+\t    putc (' ', print.outf);\n+\t}\n     }\n }\n "}, {"sha": "1adceaf3271a556d31fcf5feffcf6aee93031271", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 103, "deletions": 29, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278c466207b2d592d8ea21234d6cb228b95bc246/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=278c466207b2d592d8ea21234d6cb228b95bc246", "patch": "@@ -65,7 +65,8 @@ struct fun_macro\n \n /* Lexing state.  It is mostly used to prevent macro expansion.  */\n enum ls {ls_none = 0,\t\t/* Normal state.  */\n-\t ls_fun_macro,\t\t/* When looking for '('.  */\n+\t ls_fun_open,\t\t/* When looking for '('.  */\n+\t ls_fun_close,\t\t/* When looking for ')'.  */\n \t ls_defined,\t\t/* After defined.  */\n \t ls_defined_close,\t/* Looking for ')' of defined().  */\n \t ls_hash,\t\t/* After # in preprocessor conditional.  */\n@@ -262,7 +263,7 @@ skip_whitespace (pfile, cur, skip_comments)\n       if (is_nvspace (c) && c)\n \tcontinue;\n \n-      if (!c && cur != RLIMIT (pfile->context))\n+      if (!c && cur - 1 != RLIMIT (pfile->context))\n \tcontinue;\n \n       if (*cur == '/' && skip_comments)\n@@ -409,8 +410,6 @@ maybe_start_funlike (pfile, node, start, macro)\n   macro->node = node;\n   macro->offset = start - pfile->out.base;\n   macro->argc = 0;\n-\n-  pfile->state.parsing_args = 1;\n }\n \n /* Save the OFFSET of the start of the next argument to MACRO.  */\n@@ -485,19 +484,17 @@ scan_out_logical_line (pfile, macro)\n \t  cur--;\n \t  if (!pfile->buffer->from_stage3)\n \t    cpp_error (pfile, DL_PEDWARN, \"no newline at end of file\");\n-\t  if (pfile->state.parsing_args == 2)\n-\t    cpp_error (pfile, DL_ERROR,\n-\t\t       \"unterminated argument list invoking macro \\\"%s\\\"\",\n-\t\t       NODE_NAME (fmacro.node));\n \t  pfile->line++;\n \t  goto done;\n \n \tcase '\\r': case '\\n':\n \t  cur = handle_newline (pfile, cur - 1);\n-\t  if (pfile->state.parsing_args == 2 && !pfile->state.in_directive)\n+\t  if ((lex_state == ls_fun_open || lex_state == ls_fun_close)\n+\t      && !pfile->state.in_directive)\n \t    {\n \t      /* Newlines in arguments become a space.  */\n-\t      out[-1] = ' ';\n+\t      if (lex_state == ls_fun_close)\n+\t\tout[-1] = ' ';\n \t      continue;\n \t    }\n \t  goto done;\n@@ -578,14 +575,17 @@ scan_out_logical_line (pfile, macro)\n \n \t      if (node->type == NT_MACRO\n \t\t  /* Should we expand for ls_answer?  */\n-\t\t  && lex_state == ls_none\n+\t\t  && (lex_state == ls_none || lex_state == ls_fun_open)\n \t\t  && !pfile->state.prevent_expansion\n \t\t  && !recursive_macro (pfile, node))\n \t\t{\n-\t\t  if (node->value.macro->fun_like)\n+\t\t  /* Macros invalidate MI optimization.  */\n+\t\t  pfile->mi_valid = false;\n+\t\t  if (! (node->flags & NODE_BUILTIN)\n+\t\t      && node->value.macro->fun_like)\n \t\t    {\n \t\t      maybe_start_funlike (pfile, node, out_start, &fmacro);\n-\t\t      lex_state = ls_fun_macro;\n+\t\t      lex_state = ls_fun_open;\n \t\t      continue;\n \t\t    }\n \t\t  else\n@@ -594,6 +594,7 @@ scan_out_logical_line (pfile, macro)\n \t\t\t output, and push its replacement text.  */\n \t\t      pfile->out.cur = out_start;\n \t\t      push_replacement_text (pfile, node);\n+\t\t      lex_state = ls_none;\n \t\t      goto new_context;\n \t\t    }\n \t\t}\n@@ -622,10 +623,9 @@ scan_out_logical_line (pfile, macro)\n \t  if (quote == 0)\n \t    {\n \t      paren_depth++;\n-\t      if (lex_state == ls_fun_macro)\n+\t      if (lex_state == ls_fun_open)\n \t\t{\n-\t\t  lex_state = ls_none;\n-\t\t  pfile->state.parsing_args = 2;\n+\t\t  lex_state = ls_fun_close;\n \t\t  paren_depth = 1;\n \t\t  out = pfile->out.base + fmacro.offset;\n \t\t  fmacro.args[0] = fmacro.offset;\n@@ -638,19 +638,19 @@ scan_out_logical_line (pfile, macro)\n \t  break;\n \n \tcase ',':\n-\t  if (quote == 0 && pfile->state.parsing_args == 2 && paren_depth == 1)\n+\t  if (quote == 0 && lex_state == ls_fun_close && paren_depth == 1)\n \t    save_argument (&fmacro, out - pfile->out.base);\n \t  break;\n \n \tcase ')':\n \t  if (quote == 0)\n \t    {\n \t      paren_depth--;\n-\t      if (pfile->state.parsing_args == 2 && paren_depth == 0)\n+\t      if (lex_state == ls_fun_close && paren_depth == 0)\n \t\t{\n \t\t  cpp_macro *m = fmacro.node->value.macro;\n \n-\t\t  pfile->state.parsing_args = 0;\n+\t\t  lex_state = ls_none;\n \t\t  save_argument (&fmacro, out - pfile->out.base);\n \n \t\t  /* A single zero-length argument is no argument.  */\n@@ -701,12 +701,9 @@ scan_out_logical_line (pfile, macro)\n \n       /* Some of these transitions of state are syntax errors.  The\n \t ISO preprocessor will issue errors later.  */\n-      if (lex_state == ls_fun_macro)\n-\t{\n-\t  /* Missing '('.  */\n-\t  lex_state = ls_none;\n-\t  pfile->state.parsing_args = 0;\n-\t}\n+      if (lex_state == ls_fun_open)\n+\t/* Missing '('.  */\n+\tlex_state = ls_none;\n       else if (lex_state == ls_hash\n \t       || lex_state == ls_predicate\n \t       || lex_state == ls_defined)\n@@ -722,11 +719,10 @@ scan_out_logical_line (pfile, macro)\n   if (fmacro.buff)\n     _cpp_release_buff (pfile, fmacro.buff);\n \n-  if (pfile->state.parsing_args == 2)\n+  if (lex_state == ls_fun_close)\n     cpp_error (pfile, DL_ERROR,\n \t       \"unterminated argument list invoking macro \\\"%s\\\"\",\n \t       NODE_NAME (fmacro.node));\n-  pfile->state.parsing_args = 0;\n }\n \n /* Push a context holding the replacement text of the macro NODE on\n@@ -737,9 +733,22 @@ push_replacement_text (pfile, node)\n      cpp_reader *pfile;\n      cpp_hashnode *node;\n {\n-  cpp_macro *macro = node->value.macro;\n+  size_t len;\n+  const uchar *text;\n+\n+  if (node->flags & NODE_BUILTIN)\n+    {\n+      text = _cpp_builtin_macro_text (pfile, node);\n+      len = ustrlen (text);\n+    }\n+  else\n+    {\n+      cpp_macro *macro = node->value.macro;\n+      text = macro->exp.text;\n+      len = macro->count;\n+    }\n \n-  _cpp_push_text_context (pfile, node, macro->exp.text, macro->count);\n+  _cpp_push_text_context (pfile, node, text, len);\n }\n \n /* Returns TRUE if traditional macro recursion is detected.  */\n@@ -784,6 +793,71 @@ recursive_macro (pfile, node)\n   return recursing;\n }\n \n+/* Return the length of the replacement text of a function-like or\n+   object-like non-builtin macro.  */\n+size_t\n+_cpp_replacement_text_len (macro)\n+     const cpp_macro *macro;\n+{\n+  size_t len;\n+\n+  if (macro->fun_like)\n+    {\n+      const uchar *exp;\n+\n+      for (exp = macro->exp.text;;)\n+\t{\n+\t  struct block *b = (struct block *) exp;\n+\n+\t  len += b->text_len;\n+\t  if (b->arg_index == 0)\n+\t    break;\n+\t  len += NODE_LEN (macro->params[b->arg_index - 1]);\n+\t  exp += BLOCK_LEN (b->text_len);\n+\t}\n+    }\n+  else\n+    len = macro->count;\n+  \n+  return len;\n+}\n+\n+/* Copy the replacement text of MACRO to DEST, which must be of\n+   sufficient size.  It is not NUL-terminated.  The next character is\n+   returned.  */\n+uchar *\n+_cpp_copy_replacement_text (macro, dest)\n+     const cpp_macro *macro;\n+     uchar *dest;\n+{\n+  if (macro->fun_like)\n+    {\n+      const uchar *exp;\n+\n+      for (exp = macro->exp.text;;)\n+\t{\n+\t  struct block *b = (struct block *) exp;\n+\t  cpp_hashnode *param;\n+\n+\t  memcpy (dest, b->text, b->text_len);\n+\t  dest += b->text_len;\n+\t  if (b->arg_index == 0)\n+\t    break;\n+\t  param = macro->params[b->arg_index - 1];\n+\t  memcpy (dest, NODE_NAME (param), NODE_LEN (param));\n+\t  dest += NODE_LEN (param);\n+\t  exp += BLOCK_LEN (b->text_len);\n+\t}\n+    }\n+  else\n+    {\n+      memcpy (dest, macro->exp.text, macro->count);\n+      dest += macro->count;\n+    }\n+\n+  return dest;\n+}\n+\n /* Push a context holding the replacement text of the macro NODE on\n    the context stack.  NODE is either object-like, or a function-like\n    macro with no arguments.  */"}]}