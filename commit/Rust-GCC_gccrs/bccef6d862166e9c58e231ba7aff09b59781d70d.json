{"sha": "bccef6d862166e9c58e231ba7aff09b59781d70d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNjZWY2ZDg2MjE2NmU5YzU4ZTIzMWJhN2FmZjA5YjU5NzgxZDcwZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-12-15T11:23:19Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-12-15T11:23:19Z"}, "message": "Second part of MS1->MT renaming\n\n\tSecond part of MS1->MT renaming\n\t* config/mt/mt.md (doloop_end): Call mt_add_loop.\n\t(movqi, movhi): Call mt_set_memflags.\n\t(*movdf_internal): Call mt_split_words. \n\t(reload_inqi, reload_outqi, reload_inhi, reload_outhi): Call\n\tmt_set_memflags.\n\t(cmpsi): Store to mt_compare_op[01].\n\t(beq, bne, bge, bgt, ble, blt, bgeu, bgtu, bleu, bltu, bunge,\n\tbungt, bunle, bunlt): Call mt_emit_cbranch.\n\t(prologue): Call mt_expand_prologue.\n\t(epilogu): Call mt_expend_epilogue.\n\t(eh_return): Call mt_expand_eh_return.\n\t(eh_epilogue): Call me_emit_eh_epilogue.\n\t(conditional_trap): Store to mt_compare_op[01].\n\t* config/mt/crti.asm: Adjust comment.\n\t* config/mt/crtn.asm: Adjust comment.\n\t* config/mt/mt.c (MT_INT_ARG_FIRST): Renamed.\n\t(mt_compare_op0, mt_compare_op1): Renamed.\n\t(current_frame_info, zero_frame_info): Adjust type.\n\t(mt_ucmpsi3_libcall): Renamed.\n\t(mt_flag_delayed_branch): Renamed.\n\t(mt_struct_value_rtx, mt_return_addr_rtx): Renamed.\n\t(mt_nops_required, mt_nop_reasons): Renamed.\n\t(mt_asm_output_opcode, mt_get_attr_type, mt_final_prescan_insn,\n\tmt_debug_stack, mt_print_operand_simple_address,\n\tmt_print_operand_address, mt_print_operand): Renamed, adjusted.\n\t(mt_init_cumulative_args, mt_function_arg_slotno, mt_function_arg,\n\tmt_function_arg_advance, mt_arg_partial_bytes,\n\tmt_pass_by_reference, mt_function_arg_boundary,\n\tmt_reg_ok_for_base_p, mt_legitimate_simple_address_p,\n\tmt_legitimate_address_p): Renamed, adjusted.\n\t(mt_cpu): Renamed.\n\t(mt_init_machine_status, mt_override_options, mt_builtin_saveregs,\n\tmt_va_start, mt_compute_frame_size, mt_emit_save_restore,\n\tmt_emit_save_fp, mt_emit_save_regs, mt_interrupt_function_p, \n\tmt_expand_prologue, mt_epilogue_uses, mt_expand_epilogue,\n\tmt_expand_eh_return, mt_emit_eh_prologue,\n\tmt_handl_interrupt_attribute): Renamed, adjusted.\n\t(mt_attribute_table): Renamed, adjusted.\n\t(mt_initial_elimination_offset, mt_generate_compare,\n\tmt_emit_cbranch, mt_set_memflags_1, mt_set_memflags,\n\tmt_secondary_reload_class, mt_function_value, mt_split_words,\n\tmt_pass_in_stack, mt_add_loop, mt_loop_nesting, mt_block_length,\n\tmt_scan_loop, mt_reorg_loops): Renamed, adjusted.\n\t(mt_labels): Renamed.\n\t(mt_add_branches, mt_check_delay_slot, mt_reorg_hazard,\n\tmt_machine_reorg): Renamed, adjusted.\n\t(mt_attribute_table: Renamed.\n\t(TARGET_ATTRIBUTE_TABLE, TARGET_STRUCT_VALUE_RTX,\n\tTARGET_PASS_BY_REFERENCE, TARGET_MUST_PASS_IN_STACK,\n\tTARGET_ARG_PARTIAL_BYTES, TARGET_MACHINE_DEPENDENT_REORG): Adjust.\n\t* config/mt/mt.opt (march): Set mt_cpu_string.\n\t* config/mt/mt.h (mt_ucmpsi3_libcall, mt_cpu): Renamed.\n\t(TARGET_CPU_CPP_BUILTINS): Adjust.\n\t(TARGET_MS1_64_001, TARGET_MS1_16_002, TARGET_MS1_16_003,\n\tTARGET_MS2): Adjust.\n\t(TARGET_VERSION, OVERRIDE_OPTIONS, SECONDARY_RELOAD_CLASS): Adjust.\n\t(MT_MIN_INT): Renamed.\n\t(RETURN_ADDR_RTX): Adjust.\n\t(struct mt_frame_info): Renamed.\n\t(current_frame_info): Adjust type.\n\t(INITIAL_ELIMINATION_OFFSET): Adjust.\n\t(MT_NUM_ARG_REGS): Renamed.\n\t(REG_PARM_STACK_SPACE, FUNCTION_ARG, INIT_CUMULATVE_ARGS,\n\tFUNCTION_ARG_ADVANCE, FUNCTION_ARG_BOUNDARY, FUNCTION_VALUE,\n\tLIBCALL_VALUE, EPILOGUE_USES, EXPAND_BUILTIN_VA_START,\n\tGO_IF_LEGITIMATE_ADDRESS, REG_OK_FOR_BASE_P, ASM_OUTPUT_OPCODE,\n\tFINAL_REPSCAN_INSN, PRINT_OPERAND, PRINT_OPERAND_ADDRESS): Adjust.\n\t(mt_compare_op0, mt_compare_op1): Renamed.\n\t* config/mt/mt-protos.h: Rename prototypes.\n\nFrom-SVN: r108569", "tree": {"sha": "30674b2a1081141d15b11c1c3638d59e1d4d80e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30674b2a1081141d15b11c1c3638d59e1d4d80e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bccef6d862166e9c58e231ba7aff09b59781d70d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bccef6d862166e9c58e231ba7aff09b59781d70d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bccef6d862166e9c58e231ba7aff09b59781d70d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bccef6d862166e9c58e231ba7aff09b59781d70d/comments", "author": null, "committer": null, "parents": [{"sha": "6bec9271941b9b72ad47b3b357a243ed0690baa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bec9271941b9b72ad47b3b357a243ed0690baa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bec9271941b9b72ad47b3b357a243ed0690baa7"}], "stats": {"total": 754, "additions": 413, "deletions": 341}, "files": [{"sha": "ecf6ad43195bc6c8336afca807f08bb7781adad4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bccef6d862166e9c58e231ba7aff09b59781d70d", "patch": "@@ -1,3 +1,76 @@\n+2005-12-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tSecond part of MS1->MT renaming\n+\t* config/mt/mt.md (doloop_end): Call mt_add_loop.\n+\t(movqi, movhi): Call mt_set_memflags.\n+\t(*movdf_internal): Call mt_split_words. \n+\t(reload_inqi, reload_outqi, reload_inhi, reload_outhi): Call\n+\tmt_set_memflags.\n+\t(cmpsi): Store to mt_compare_op[01].\n+\t(beq, bne, bge, bgt, ble, blt, bgeu, bgtu, bleu, bltu, bunge,\n+\tbungt, bunle, bunlt): Call mt_emit_cbranch.\n+\t(prologue): Call mt_expand_prologue.\n+\t(epilogu): Call mt_expend_epilogue.\n+\t(eh_return): Call mt_expand_eh_return.\n+\t(eh_epilogue): Call me_emit_eh_epilogue.\n+\t(conditional_trap): Store to mt_compare_op[01].\n+\t* config/mt/crti.asm: Adjust comment.\n+\t* config/mt/crtn.asm: Adjust comment.\n+\t* config/mt/mt.c (MT_INT_ARG_FIRST): Renamed.\n+\t(mt_compare_op0, mt_compare_op1): Renamed.\n+\t(current_frame_info, zero_frame_info): Adjust type.\n+\t(mt_ucmpsi3_libcall): Renamed.\n+\t(mt_flag_delayed_branch): Renamed.\n+\t(mt_struct_value_rtx, mt_return_addr_rtx): Renamed.\n+\t(mt_nops_required, mt_nop_reasons): Renamed.\n+\t(mt_asm_output_opcode, mt_get_attr_type, mt_final_prescan_insn,\n+\tmt_debug_stack, mt_print_operand_simple_address,\n+\tmt_print_operand_address, mt_print_operand): Renamed, adjusted.\n+\t(mt_init_cumulative_args, mt_function_arg_slotno, mt_function_arg,\n+\tmt_function_arg_advance, mt_arg_partial_bytes,\n+\tmt_pass_by_reference, mt_function_arg_boundary,\n+\tmt_reg_ok_for_base_p, mt_legitimate_simple_address_p,\n+\tmt_legitimate_address_p): Renamed, adjusted.\n+\t(mt_cpu): Renamed.\n+\t(mt_init_machine_status, mt_override_options, mt_builtin_saveregs,\n+\tmt_va_start, mt_compute_frame_size, mt_emit_save_restore,\n+\tmt_emit_save_fp, mt_emit_save_regs, mt_interrupt_function_p, \n+\tmt_expand_prologue, mt_epilogue_uses, mt_expand_epilogue,\n+\tmt_expand_eh_return, mt_emit_eh_prologue,\n+\tmt_handl_interrupt_attribute): Renamed, adjusted.\n+\t(mt_attribute_table): Renamed, adjusted.\n+\t(mt_initial_elimination_offset, mt_generate_compare,\n+\tmt_emit_cbranch, mt_set_memflags_1, mt_set_memflags,\n+\tmt_secondary_reload_class, mt_function_value, mt_split_words,\n+\tmt_pass_in_stack, mt_add_loop, mt_loop_nesting, mt_block_length,\n+\tmt_scan_loop, mt_reorg_loops): Renamed, adjusted.\n+\t(mt_labels): Renamed.\n+\t(mt_add_branches, mt_check_delay_slot, mt_reorg_hazard,\n+\tmt_machine_reorg): Renamed, adjusted.\n+\t(mt_attribute_table: Renamed.\n+\t(TARGET_ATTRIBUTE_TABLE, TARGET_STRUCT_VALUE_RTX,\n+\tTARGET_PASS_BY_REFERENCE, TARGET_MUST_PASS_IN_STACK,\n+\tTARGET_ARG_PARTIAL_BYTES, TARGET_MACHINE_DEPENDENT_REORG): Adjust.\n+\t* config/mt/mt.opt (march): Set mt_cpu_string.\n+\t* config/mt/mt.h (mt_ucmpsi3_libcall, mt_cpu): Renamed.\n+\t(TARGET_CPU_CPP_BUILTINS): Adjust.\n+\t(TARGET_MS1_64_001, TARGET_MS1_16_002, TARGET_MS1_16_003,\n+\tTARGET_MS2): Adjust.\n+\t(TARGET_VERSION, OVERRIDE_OPTIONS, SECONDARY_RELOAD_CLASS): Adjust.\n+\t(MT_MIN_INT): Renamed.\n+\t(RETURN_ADDR_RTX): Adjust.\n+\t(struct mt_frame_info): Renamed.\n+\t(current_frame_info): Adjust type.\n+\t(INITIAL_ELIMINATION_OFFSET): Adjust.\n+\t(MT_NUM_ARG_REGS): Renamed.\n+\t(REG_PARM_STACK_SPACE, FUNCTION_ARG, INIT_CUMULATVE_ARGS,\n+\tFUNCTION_ARG_ADVANCE, FUNCTION_ARG_BOUNDARY, FUNCTION_VALUE,\n+\tLIBCALL_VALUE, EPILOGUE_USES, EXPAND_BUILTIN_VA_START,\n+\tGO_IF_LEGITIMATE_ADDRESS, REG_OK_FOR_BASE_P, ASM_OUTPUT_OPCODE,\n+\tFINAL_REPSCAN_INSN, PRINT_OPERAND, PRINT_OPERAND_ADDRESS): Adjust.\n+\t(mt_compare_op0, mt_compare_op1): Renamed.\n+\t* config/mt/mt-protos.h: Rename prototypes.\n+\n 2005-12-15  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-flow.h (okay_component_ref_for_subvars): Remove.\n@@ -147,6 +220,9 @@\n \n 2005-12-13  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* sim/common/sim-signal.c (sim_signal_to_target): Add missing ':'.\n+\t* sim/common/sim-signal.h (sim_signal_to_target): Return an int.\n+\n \t* config/mt/t-mt (crti.o, crtn.o): Add multilib options.\n \t(EXTRA_MULTILIB_PARTS): Define.\n "}, {"sha": "07bc6ff77b641bb066ee066ac04e6b8233a519cd", "filename": "gcc/config/mt/crti.asm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fcrti.asm?ref=bccef6d862166e9c58e231ba7aff09b59781d70d", "patch": "@@ -1,4 +1,4 @@\n-# crti.asm for ms1\n+# crti.asm for mt\n #\n #   Copyright (C) 2005 Free Software Foundation, Inc.\n # "}, {"sha": "d179c1895cf033637d31f935942f46b293c956d1", "filename": "gcc/config/mt/crtn.asm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fcrtn.asm?ref=bccef6d862166e9c58e231ba7aff09b59781d70d", "patch": "@@ -1,4 +1,4 @@\n-# crtn.asm for ms1\n+# crtn.asm for mt\n \n #   Copyright (C) 2005 Free Software Foundation, Inc.\n # "}, {"sha": "32867994618f77438ffc4a4904289a838e4af1c5", "filename": "gcc/config/mt/mt-protos.h", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fmt-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fmt-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt-protos.h?ref=bccef6d862166e9c58e231ba7aff09b59781d70d", "patch": "@@ -18,49 +18,49 @@\n    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301, USA.  */\n \n-extern void         ms1_init_expanders\t (void);\n-extern void         ms1_expand_prologue\t (void);\n-extern void         ms1_expand_epilogue\t (enum epilogue_type);\n-extern unsigned     ms1_compute_frame_size (int);\n-extern void\t    ms1_override_options (void);\n-extern int\t    ms1_initial_elimination_offset (int, int);\n-extern const char * ms1_asm_output_opcode (FILE *, const char *);\n-extern int          ms1_epilogue_uses\t (int);\n-extern void\t    ms1_add_loop \t (void);\n+extern void         mt_init_expanders\t (void);\n+extern void         mt_expand_prologue\t (void);\n+extern void         mt_expand_epilogue\t (enum epilogue_type);\n+extern unsigned     mt_compute_frame_size (int);\n+extern void\t    mt_override_options (void);\n+extern int\t    mt_initial_elimination_offset (int, int);\n+extern const char * mt_asm_output_opcode (FILE *, const char *);\n+extern int          mt_epilogue_uses\t (int);\n+extern void\t    mt_add_loop \t (void);\n \n #ifdef TREE_CODE\n-extern const char * ms1_cannot_inline_p\t (tree);\n-extern int          ms1_function_arg_boundary (enum machine_mode, tree);\n-extern void         ms1_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree,  int);\n+extern const char * mt_cannot_inline_p\t (tree);\n+extern int          mt_function_arg_boundary (enum machine_mode, tree);\n+extern void         mt_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree,  int);\n #endif\n \n #ifdef RTX_CODE\n-extern void\t    ms1_expand_eh_return (rtx *);\n-extern void\t    ms1_emit_eh_epilogue (rtx *);\n-extern void         ms1_print_operand\t (FILE *, rtx, int);\n-extern void         ms1_print_operand_address (FILE *, rtx);\n-extern int          ms1_check_split\t (rtx, enum machine_mode);\n-extern int          ms1_reg_ok_for_base_p (rtx, int);\n-extern int          ms1_legitimate_address_p (enum machine_mode, rtx, int);\n+extern void\t    mt_expand_eh_return (rtx *);\n+extern void\t    mt_emit_eh_epilogue (rtx *);\n+extern void         mt_print_operand\t (FILE *, rtx, int);\n+extern void         mt_print_operand_address (FILE *, rtx);\n+extern int          mt_check_split\t (rtx, enum machine_mode);\n+extern int          mt_reg_ok_for_base_p (rtx, int);\n+extern int          mt_legitimate_address_p (enum machine_mode, rtx, int);\n /* Predicates for machine description.  */\n extern int          uns_arith_operand\t (rtx, enum machine_mode);\n extern int          arith_operand\t (rtx, enum machine_mode);\n extern int          reg_or_0_operand\t (rtx, enum machine_mode);\n extern int\t    big_const_operand\t (rtx, enum machine_mode);\n extern int\t    single_const_operand (rtx, enum machine_mode);\n-extern void\t    ms1_emit_cbranch\t (enum rtx_code, rtx, rtx, rtx);\n-extern void\t    ms1_set_memflags\t (rtx);\n-extern rtx\t    ms1_return_addr_rtx\t (int);\n-extern void\t    ms1_split_words\t (enum machine_mode, enum machine_mode, rtx *);\n-extern void\t    ms1_final_prescan_insn (rtx, rtx *, int);\n+extern void\t    mt_emit_cbranch\t (enum rtx_code, rtx, rtx, rtx);\n+extern void\t    mt_set_memflags\t (rtx);\n+extern rtx\t    mt_return_addr_rtx\t (int);\n+extern void\t    mt_split_words\t (enum machine_mode, enum machine_mode, rtx *);\n+extern void\t    mt_final_prescan_insn (rtx, rtx *, int);\n #endif\n \n #ifdef TREE_CODE\n #ifdef RTX_CODE\n-extern void         ms1_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n-extern rtx          ms1_function_arg\t (const CUMULATIVE_ARGS *, enum machine_mode, tree, int, int);\n-extern void\t    ms1_va_start\t (tree, rtx);\n-extern enum reg_class ms1_secondary_reload_class (enum reg_class, enum machine_mode, rtx);\n-extern rtx\t    ms1_function_value\t (tree, enum machine_mode, tree);\n+extern void         mt_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n+extern rtx          mt_function_arg\t (const CUMULATIVE_ARGS *, enum machine_mode, tree, int, int);\n+extern void\t    mt_va_start\t (tree, rtx);\n+extern enum reg_class mt_secondary_reload_class (enum reg_class, enum machine_mode, rtx);\n+extern rtx\t    mt_function_value\t (tree, enum machine_mode, tree);\n #endif\n #endif"}, {"sha": "6d7ca3c0834fcdba3ce4cbecebe57169e6783e78", "filename": "gcc/config/mt/mt.c", "status": "modified", "additions": 217, "deletions": 218, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.c?ref=bccef6d862166e9c58e231ba7aff09b59781d70d", "patch": "@@ -56,7 +56,7 @@\n #define LINK_MASK\t \t (1 << (GPR_LINK))\n \n /* First GPR.  */\n-#define MS1_INT_ARG_FIRST 1\n+#define MT_INT_ARG_FIRST 1\n \n /* Given a SIZE in bytes, advance to the next word.  */\n #define ROUND_ADVANCE(SIZE) (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n@@ -74,31 +74,31 @@ struct machine_function GTY(())\n \n /* Define the information needed to generate branch and scc insns.\n    This is stored from the compare operation.  */\n-struct rtx_def * ms1_compare_op0;\n-struct rtx_def * ms1_compare_op1;\n+struct rtx_def * mt_compare_op0;\n+struct rtx_def * mt_compare_op1;\n \n /* Current frame information calculated by compute_frame_size.  */\n-struct ms1_frame_info current_frame_info;\n+struct mt_frame_info current_frame_info;\n \n /* Zero structure to initialize current_frame_info.  */\n-struct ms1_frame_info zero_frame_info;\n+struct mt_frame_info zero_frame_info;\n \n-/* ms1 doesn't have unsigned compares need a library call for this.  */\n-struct rtx_def * ms1_ucmpsi3_libcall;\n+/* mt doesn't have unsigned compares need a library call for this.  */\n+struct rtx_def * mt_ucmpsi3_libcall;\n \n-static int ms1_flag_delayed_branch;\n+static int mt_flag_delayed_branch;\n \n \f\n static rtx\n-ms1_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED,\n+mt_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED,\n \t\t\t int incoming ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (Pmode, RETVAL_REGNUM);\n }\n \n /* Implement RETURN_ADDR_RTX.  */\n rtx\n-ms1_return_addr_rtx (int count)\n+mt_return_addr_rtx (int count)\n {\n   if (count != 0)\n     return NULL_RTX;\n@@ -109,21 +109,21 @@ ms1_return_addr_rtx (int count)\n /* The following variable value indicates the number of nops required\n    between the current instruction and the next instruction to avoid\n    any pipeline hazards.  */\n-static int ms1_nops_required = 0;\n-static const char * ms1_nop_reasons = \"\";\n+static int mt_nops_required = 0;\n+static const char * mt_nop_reasons = \"\";\n \n /* Implement ASM_OUTPUT_OPCODE.  */\n const char *\n-ms1_asm_output_opcode (FILE *f ATTRIBUTE_UNUSED, const char *ptr)\n+mt_asm_output_opcode (FILE *f ATTRIBUTE_UNUSED, const char *ptr)\n {\n-  if (ms1_nops_required)\n+  if (mt_nops_required)\n     fprintf (f, \";# need %d nops because of %s\\n\\t\",\n-\t     ms1_nops_required, ms1_nop_reasons);\n+\t     mt_nops_required, mt_nop_reasons);\n   \n-  while (ms1_nops_required)\n+  while (mt_nops_required)\n     {\n       fprintf (f, \"or r0, r0, r0\\n\\t\");\n-      -- ms1_nops_required;\n+      -- mt_nops_required;\n     }\n   \n   return ptr;\n@@ -132,7 +132,7 @@ ms1_asm_output_opcode (FILE *f ATTRIBUTE_UNUSED, const char *ptr)\n /* Given an insn, return whether it's a memory operation or a branch\n    operation, otherwise return TYPE_ARITH.  */\n static enum attr_type\n-ms1_get_attr_type (rtx complete_insn)\n+mt_get_attr_type (rtx complete_insn)\n {\n   rtx insn = PATTERN (complete_insn);\n \n@@ -206,19 +206,19 @@ insn_true_dependent_p (rtx x, rtx y)\n \n /* The following determines the number of nops that need to be\n    inserted between the previous instructions and current instruction\n-   to avoid pipeline hazards on the ms1 processor.  Remember that\n+   to avoid pipeline hazards on the mt processor.  Remember that\n    the function is not called for asm insns.  */\n \n void\n-ms1_final_prescan_insn (rtx   insn,\n+mt_final_prescan_insn (rtx   insn,\n \t\t\trtx * opvec ATTRIBUTE_UNUSED,\n \t\t\tint   noperands ATTRIBUTE_UNUSED)\n {\n   rtx prev_i;\n   enum attr_type prev_attr;\n \n-  ms1_nops_required = 0;\n-  ms1_nop_reasons = \"\";\n+  mt_nops_required = 0;\n+  mt_nop_reasons = \"\";\n \n   /* ms2 constraints are dealt with in reorg.  */\n   if (TARGET_MS2)\n@@ -245,22 +245,22 @@ ms1_final_prescan_insn (rtx   insn,\n   if (prev_i == NULL || ! INSN_P (prev_i))\n     return;\n \n-  prev_attr = ms1_get_attr_type (prev_i);\n+  prev_attr = mt_get_attr_type (prev_i);\n   \n   /* Delayed branch slots already taken care of by delay branch scheduling.  */\n   if (prev_attr == TYPE_BRANCH)\n     return;\n \n-  switch (ms1_get_attr_type (insn))\n+  switch (mt_get_attr_type (insn))\n     {\n     case TYPE_LOAD:\n     case TYPE_STORE:\n       /* Avoid consecutive memory operation.  */\n       if  ((prev_attr == TYPE_LOAD || prev_attr == TYPE_STORE)\n \t   && TARGET_MS1_64_001)\n \t{\n-\t  ms1_nops_required = 1;\n-\t  ms1_nop_reasons = \"consecutive mem ops\";\n+\t  mt_nops_required = 1;\n+\t  mt_nop_reasons = \"consecutive mem ops\";\n \t}\n       /* Drop through.  */\n \n@@ -271,8 +271,8 @@ ms1_final_prescan_insn (rtx   insn,\n       if (prev_attr == TYPE_LOAD\n \t  && insn_true_dependent_p (prev_i, insn))\n \t{\n-\t  ms1_nops_required = 1;\n-\t  ms1_nop_reasons = \"load->arith dependency delay\";\n+\t  mt_nops_required = 1;\n+\t  mt_nop_reasons = \"load->arith dependency delay\";\n \t}\n       break;\n \n@@ -283,31 +283,31 @@ ms1_final_prescan_insn (rtx   insn,\n \t    {\n \t      /* One cycle of delay between arith\n \t\t instructions and branch dependent on arith.  */\n-\t      ms1_nops_required = 1;\n-\t      ms1_nop_reasons = \"arith->branch dependency delay\";\n+\t      mt_nops_required = 1;\n+\t      mt_nop_reasons = \"arith->branch dependency delay\";\n \t    }\n \t  else if (prev_attr == TYPE_LOAD)\n \t    {\n \t      /* Two cycles of delay are required\n \t\t between load and dependent branch.  */\n \t      if (TARGET_MS1_64_001)\n-\t\tms1_nops_required = 2;\n+\t\tmt_nops_required = 2;\n \t      else\n-\t\tms1_nops_required = 1;\n-\t      ms1_nop_reasons = \"load->branch dependency delay\";\n+\t\tmt_nops_required = 1;\n+\t      mt_nop_reasons = \"load->branch dependency delay\";\n \t    }\n \t}\n       break;\n \n     default:\n-      fatal_insn (\"ms1_final_prescan_insn, invalid insn #1\", insn);\n+      fatal_insn (\"mt_final_prescan_insn, invalid insn #1\", insn);\n       break;\n     }\n }\n \n /* Print debugging information for a frame.  */\n static void\n-ms1_debug_stack (struct ms1_frame_info * info)\n+mt_debug_stack (struct mt_frame_info * info)\n {\n   int regno;\n \n@@ -347,7 +347,7 @@ ms1_debug_stack (struct ms1_frame_info * info)\n /* Print a memory address as an operand to reference that memory location.  */\n \n static void\n-ms1_print_operand_simple_address (FILE * file, rtx addr)\n+mt_print_operand_simple_address (FILE * file, rtx addr)\n {\n   if (!addr)\n     error (\"PRINT_OPERAND_ADDRESS, null pointer\");\n@@ -402,19 +402,19 @@ ms1_print_operand_simple_address (FILE * file, rtx addr)\n \n /* Implement PRINT_OPERAND_ADDRESS.  */\n void\n-ms1_print_operand_address (FILE * file, rtx addr)\n+mt_print_operand_address (FILE * file, rtx addr)\n {\n   if (GET_CODE (addr) == AND\n       && GET_CODE (XEXP (addr, 1)) == CONST_INT\n       && INTVAL (XEXP (addr, 1)) == -3)\n-    ms1_print_operand_simple_address (file, XEXP (addr, 0));\n+    mt_print_operand_simple_address (file, XEXP (addr, 0));\n   else\n-    ms1_print_operand_simple_address (file, addr);\n+    mt_print_operand_simple_address (file, addr);\n }\n \n /* Implement PRINT_OPERAND.  */\n void\n-ms1_print_operand (FILE * file, rtx x, int code)\n+mt_print_operand (FILE * file, rtx x, int code)\n {\n   switch (code)\n     {\n@@ -452,7 +452,7 @@ ms1_print_operand (FILE * file, rtx x, int code)\n       break;\n \n     default:\n-      /* output_operand_lossage (\"ms1_print_operand: unknown code\"); */\n+      /* output_operand_lossage (\"mt_print_operand: unknown code\"); */\n       fprintf (file, \"unknown code\");\n       return;\n     }\n@@ -469,7 +469,7 @@ ms1_print_operand (FILE * file, rtx x, int code)\n       break;\n \n     case MEM:\n-      ms1_print_operand_address(file, XEXP (x,0));\n+      mt_print_operand_address(file, XEXP (x,0));\n       break;\n \n     case LABEL_REF:\n@@ -487,14 +487,14 @@ ms1_print_operand (FILE * file, rtx x, int code)\n \n /* Implement INIT_CUMULATIVE_ARGS.  */\n void\n-ms1_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype, rtx libname,\n-\t\t\t     tree fndecl ATTRIBUTE_UNUSED, int incoming)\n+mt_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype, rtx libname,\n+\t\t\t tree fndecl ATTRIBUTE_UNUSED, int incoming)\n {\n   *cum = 0;\n \n   if (TARGET_DEBUG_ARG)\n     {\n-      fprintf (stderr, \"\\nms1_init_cumulative_args:\");\n+      fprintf (stderr, \"\\nmt_init_cumulative_args:\");\n \n       if (incoming)\n \tfputs (\" incoming\", stderr);\n@@ -531,20 +531,20 @@ ms1_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype, rtx libname,\n    *PREGNO records the register number to use if scalar type.  */\n \n static int\n-ms1_function_arg_slotno (const CUMULATIVE_ARGS * cum,\n-\t\t\t    enum machine_mode mode,\n-\t\t\t    tree type,\n-\t\t\t    int named ATTRIBUTE_UNUSED,\n-\t\t\t    int incoming_p ATTRIBUTE_UNUSED,\n-\t\t\t    int * pregno)\n-{\n-  int regbase = MS1_INT_ARG_FIRST;\n+mt_function_arg_slotno (const CUMULATIVE_ARGS * cum,\n+\t\t\tenum machine_mode mode,\n+\t\t\ttree type,\n+\t\t\tint named ATTRIBUTE_UNUSED,\n+\t\t\tint incoming_p ATTRIBUTE_UNUSED,\n+\t\t\tint * pregno)\n+{\n+  int regbase = MT_INT_ARG_FIRST;\n   int slotno  = * cum;\n \n   if (mode == VOIDmode || targetm.calls.must_pass_in_stack (mode, type))\n     return -1;\n \n-  if (slotno >= MS1_NUM_ARG_REGS)\n+  if (slotno >= MT_NUM_ARG_REGS)\n     return -1;\n \n   * pregno = regbase + slotno;\n@@ -554,17 +554,16 @@ ms1_function_arg_slotno (const CUMULATIVE_ARGS * cum,\n \n /* Implement FUNCTION_ARG.  */\n rtx\n-ms1_function_arg (const CUMULATIVE_ARGS * cum,\n-\t\t  enum machine_mode mode,\n-\t\t  tree type,\n-\t\t  int named,\n-\t\t  int incoming_p)\n+mt_function_arg (const CUMULATIVE_ARGS * cum,\n+\t\t enum machine_mode mode,\n+\t\t tree type,\n+\t\t int named,\n+\t\t int incoming_p)\n {\n   int slotno, regno;\n   rtx reg;\n \n-  slotno = ms1_function_arg_slotno (cum, mode, type, named, incoming_p, \n-\t\t\t\t       & regno);\n+  slotno = mt_function_arg_slotno (cum, mode, type, named, incoming_p, &regno);\n \n   if (slotno == -1)\n     reg = NULL_RTX;\n@@ -576,23 +575,23 @@ ms1_function_arg (const CUMULATIVE_ARGS * cum,\n \n /* Implement FUNCTION_ARG_ADVANCE.  */\n void\n-ms1_function_arg_advance (CUMULATIVE_ARGS * cum,\n-\t\t\t  enum machine_mode mode,\n-\t\t\t  tree type ATTRIBUTE_UNUSED,\n-\t\t\t  int named)\n+mt_function_arg_advance (CUMULATIVE_ARGS * cum,\n+\t\t\t enum machine_mode mode,\n+\t\t\t tree type ATTRIBUTE_UNUSED,\n+\t\t\t int named)\n {\n   int slotno, regno;\n \n   /* We pass 0 for incoming_p here, it doesn't matter.  */\n-  slotno = ms1_function_arg_slotno (cum, mode, type, named, 0, &regno);\n+  slotno = mt_function_arg_slotno (cum, mode, type, named, 0, &regno);\n \n   * cum += (mode != BLKmode\n \t    ? ROUND_ADVANCE (GET_MODE_SIZE (mode))\n \t    : ROUND_ADVANCE (int_size_in_bytes (type)));\n \n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr,\n-\t     \"ms1_function_arg_advance: words = %2d, mode = %4s, named = %d, size = %3d\\n\",\n+\t     \"mt_function_arg_advance: words = %2d, mode = %4s, named = %d, size = %3d\\n\",\n \t     *cum, GET_MODE_NAME (mode), named, \n \t     (*cum) * UNITS_PER_WORD);\n }\n@@ -604,7 +603,7 @@ ms1_function_arg_advance (CUMULATIVE_ARGS * cum,\n    that are passed entirely in registers or that are entirely pushed\n    on the stack.  */\n static int\n-ms1_arg_partial_bytes (CUMULATIVE_ARGS * pcum,\n+mt_arg_partial_bytes (CUMULATIVE_ARGS * pcum,\n \t\t       enum machine_mode mode,\n \t\t       tree type,\n \t\t       bool named ATTRIBUTE_UNUSED)\n@@ -618,11 +617,11 @@ ms1_arg_partial_bytes (CUMULATIVE_ARGS * pcum,\n   else\n     words = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n-  if (! targetm.calls.pass_by_reference (& cum, mode, type, named)\n-      && cum < MS1_NUM_ARG_REGS\n-      && (cum + words) > MS1_NUM_ARG_REGS)\n+  if (! targetm.calls.pass_by_reference (&cum, mode, type, named)\n+      && cum < MT_NUM_ARG_REGS\n+      && (cum + words) > MT_NUM_ARG_REGS)\n     {\n-      int bytes = (MS1_NUM_ARG_REGS - cum) * UNITS_PER_WORD; \n+      int bytes = (MT_NUM_ARG_REGS - cum) * UNITS_PER_WORD; \n \n       if (TARGET_DEBUG)\n \tfprintf (stderr, \"function_arg_partial_nregs = %d\\n\", bytes);\n@@ -635,7 +634,7 @@ ms1_arg_partial_bytes (CUMULATIVE_ARGS * pcum,\n \n /* Implement TARGET_PASS_BY_REFERENCE hook.  */\n static bool\n-ms1_pass_by_reference (CUMULATIVE_ARGS * cum ATTRIBUTE_UNUSED,\n+mt_pass_by_reference (CUMULATIVE_ARGS * cum ATTRIBUTE_UNUSED,\n \t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       tree type,\n \t\t       bool named ATTRIBUTE_UNUSED)\n@@ -645,27 +644,26 @@ ms1_pass_by_reference (CUMULATIVE_ARGS * cum ATTRIBUTE_UNUSED,\n \n /* Implement FUNCTION_ARG_BOUNDARY.  */\n int\n-ms1_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n+mt_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t   tree type ATTRIBUTE_UNUSED)\n {\n   return BITS_PER_WORD;\n }\n \n /* Implement REG_OK_FOR_BASE_P.  */\n int\n-ms1_reg_ok_for_base_p (rtx x, int strict)\n+mt_reg_ok_for_base_p (rtx x, int strict)\n {\n   if (strict)\n     return  (((unsigned) REGNO (x)) < FIRST_PSEUDO_REGISTER);\n   return 1;\n }\n \n-/* Helper function of ms1_legitimate_address_p.  Return true if XINSN\n+/* Helper function of mt_legitimate_address_p.  Return true if XINSN\n    is a simple address, otherwise false.  */\n static bool\n-ms1_legitimate_simple_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t\t rtx xinsn,\n-\t\t\t\t int strict)\n+mt_legitimate_simple_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\trtx xinsn, int strict)\n {\n   if (TARGET_DEBUG)\t\t\t\t\t\t\n     {\t\t\t\t\t\t\t\t\t\n@@ -674,12 +672,12 @@ ms1_legitimate_simple_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n       debug_rtx (xinsn);\n     }\n \n-  if (GET_CODE (xinsn) == REG && ms1_reg_ok_for_base_p (xinsn, strict))\n+  if (GET_CODE (xinsn) == REG && mt_reg_ok_for_base_p (xinsn, strict))\n     return true;\n \n   if (GET_CODE (xinsn) == PLUS\n       && GET_CODE (XEXP (xinsn, 0)) == REG\n-      && ms1_reg_ok_for_base_p (XEXP (xinsn, 0), strict)\n+      && mt_reg_ok_for_base_p (XEXP (xinsn, 0), strict)\n       && GET_CODE (XEXP (xinsn, 1)) == CONST_INT\n       && SMALL_INT (XEXP (xinsn, 1)))\n     return true;\n@@ -689,20 +687,18 @@ ms1_legitimate_simple_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \n \n /* Helper function of GO_IF_LEGITIMATE_ADDRESS.  Return non-zero if\n-   XINSN is a legitimate address on MS1.  */\n+   XINSN is a legitimate address on MT.  */\n int\n-ms1_legitimate_address_p (enum machine_mode mode,\n-\t\t\t  rtx xinsn,\n-\t\t\t  int strict)\n+mt_legitimate_address_p (enum machine_mode mode, rtx xinsn, int strict)\n {\n-  if (ms1_legitimate_simple_address_p (mode, xinsn, strict))\n+  if (mt_legitimate_simple_address_p (mode, xinsn, strict))\n     return 1;\n \n   if ((mode) == SImode\n       && GET_CODE (xinsn) == AND\n       && GET_CODE (XEXP (xinsn, 1)) == CONST_INT\n       && INTVAL (XEXP (xinsn, 1)) == -3)\n-    return ms1_legitimate_simple_address_p (mode, XEXP (xinsn, 0), strict);\n+    return mt_legitimate_simple_address_p (mode, XEXP (xinsn, 0), strict);\n   else\n     return 0;\n }\n@@ -782,10 +778,10 @@ single_const_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n /* True if the current function is an interrupt handler\n    (either via #pragma or an attribute specification).  */\n int interrupt_handler;\n-enum processor_type ms1_cpu;\n+enum processor_type mt_cpu;\n \n static struct machine_function *\n-ms1_init_machine_status (void)\n+mt_init_machine_status (void)\n {\n   struct machine_function *f;\n \n@@ -796,23 +792,23 @@ ms1_init_machine_status (void)\n \n /* Implement OVERRIDE_OPTIONS.  */\n void\n-ms1_override_options (void)\n+mt_override_options (void)\n {\n-  if (ms1_cpu_string != NULL)\n+  if (mt_cpu_string != NULL)\n     {\n-      if (!strcasecmp (ms1_cpu_string, \"MS1-64-001\"))\n-\tms1_cpu = PROCESSOR_MS1_64_001;\n-      else if (!strcasecmp (ms1_cpu_string, \"MS1-16-002\"))\n-\tms1_cpu = PROCESSOR_MS1_16_002;\n-      else if  (!strcasecmp (ms1_cpu_string, \"MS1-16-003\"))\n-\tms1_cpu = PROCESSOR_MS1_16_003;\n-      else if (!strcasecmp (ms1_cpu_string, \"MS2\"))\n-\tms1_cpu = PROCESSOR_MS2;\n+      if (!strcasecmp (mt_cpu_string, \"MS1-64-001\"))\n+\tmt_cpu = PROCESSOR_MS1_64_001;\n+      else if (!strcasecmp (mt_cpu_string, \"MS1-16-002\"))\n+\tmt_cpu = PROCESSOR_MS1_16_002;\n+      else if  (!strcasecmp (mt_cpu_string, \"MS1-16-003\"))\n+\tmt_cpu = PROCESSOR_MS1_16_003;\n+      else if (!strcasecmp (mt_cpu_string, \"MS2\"))\n+\tmt_cpu = PROCESSOR_MS2;\n       else\n-\terror (\"bad value (%s) for -march= switch\", ms1_cpu_string);\n+\terror (\"bad value (%s) for -march= switch\", mt_cpu_string);\n     }\n   else\n-    ms1_cpu = PROCESSOR_MS2;\n+    mt_cpu = PROCESSOR_MS2;\n \n   if (flag_exceptions)\n     {\n@@ -821,30 +817,31 @@ ms1_override_options (void)\n     }\n \n   /* We do delayed branch filling in machine dependent reorg */\n-  ms1_flag_delayed_branch = flag_delayed_branch;\n+  mt_flag_delayed_branch = flag_delayed_branch;\n   flag_delayed_branch = 0;\n \n-  init_machine_status = ms1_init_machine_status;\n+  init_machine_status = mt_init_machine_status;\n }\n \n /* Do what is necessary for `va_start'.  We look at the current function\n    to determine if stdarg or varargs is used and return the address of the\n    first unnamed parameter.  */\n \n static rtx\n-ms1_builtin_saveregs (void)\n+mt_builtin_saveregs (void)\n {\n   int first_reg = 0;\n   rtx address;\n   int regno;\n \n-  for (regno = first_reg; regno < MS1_NUM_ARG_REGS; regno ++)\n-    emit_move_insn (gen_rtx_MEM (word_mode,\n-\t\t\t\t gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t       gen_rtx_REG (SImode, ARG_POINTER_REGNUM),\n-\t\t\t\t\t       GEN_INT (UNITS_PER_WORD * regno))),\n-\t\t    gen_rtx_REG (word_mode,\n-\t\t\t\t MS1_INT_ARG_FIRST + regno));\n+  for (regno = first_reg; regno < MT_NUM_ARG_REGS; regno ++)\n+    emit_move_insn\n+      (gen_rtx_MEM (word_mode,\n+\t\t    gen_rtx_PLUS (Pmode,\n+\t\t\t\t  gen_rtx_REG (SImode, ARG_POINTER_REGNUM),\n+\t\t\t\t  GEN_INT (UNITS_PER_WORD * regno))),\n+       gen_rtx_REG (word_mode,\n+\t\t    MT_INT_ARG_FIRST + regno));\n \n   address = gen_rtx_PLUS (Pmode,\n \t\t\t  gen_rtx_REG (SImode, ARG_POINTER_REGNUM),\n@@ -855,9 +852,9 @@ ms1_builtin_saveregs (void)\n /* Implement `va_start'.  */\n \n void\n-ms1_va_start (tree valist, rtx nextarg)\n+mt_va_start (tree valist, rtx nextarg)\n {\n-  ms1_builtin_saveregs ();\n+  mt_builtin_saveregs ();\n   std_expand_builtin_va_start (valist, nextarg);\n }\n \n@@ -866,7 +863,7 @@ ms1_va_start (tree valist, rtx nextarg)\n    needed for local variables.  */\n \n unsigned int\n-ms1_compute_frame_size (int size)\n+mt_compute_frame_size (int size)\n {\n   int           regno;\n   unsigned int  total_size;\n@@ -928,10 +925,8 @@ ms1_compute_frame_size (int size)\n    STACK_OFFSET is the offset from the SP where the save will happen.\n    This function sets the REG_FRAME_RELATED_EXPR note accordingly.  */\n static void\n-ms1_emit_save_restore (enum save_direction direction,\n-\t\t       rtx reg,\n-\t\t       rtx mem,\n-\t\t       int stack_offset)\n+mt_emit_save_restore (enum save_direction direction,\n+\t\t      rtx reg, rtx mem, int stack_offset)\n {\n   if (direction == FROM_PROCESSOR_TO_MEM)\n     {\n@@ -940,15 +935,15 @@ ms1_emit_save_restore (enum save_direction direction,\n       insn = emit_move_insn (mem, reg);\n       RTX_FRAME_RELATED_P (insn) = 1;\n       REG_NOTES (insn)\n-\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t     gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t  gen_rtx_MEM\n-\t\t\t\t\t  (SImode,\n-\t\t\t\t\t   gen_rtx_PLUS (SImode,\n-\t\t\t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t\t\t GEN_INT (stack_offset))),\n-\t\t\t\t\t  reg),\n-\t\t\t     REG_NOTES (insn));\n+\t= gen_rtx_EXPR_LIST\n+\t(REG_FRAME_RELATED_EXPR,\n+\t gen_rtx_SET (VOIDmode,\n+\t\t      gen_rtx_MEM (SImode,\n+\t\t\t\t   gen_rtx_PLUS (SImode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t GEN_INT (stack_offset))),\n+\t\t      reg),\n+\t REG_NOTES (insn));\n     }\n   else\n     emit_move_insn (reg, mem);\n@@ -959,8 +954,8 @@ ms1_emit_save_restore (enum save_direction direction,\n    frame pointer in epilogue.  */\n \n static void\n-ms1_emit_save_fp (enum save_direction direction,\n-\t\t  struct ms1_frame_info info)\n+mt_emit_save_fp (enum save_direction direction,\n+\t\t  struct mt_frame_info info)\n {\n   rtx base_reg;\n   int reg_mask = info.reg_mask  & ~(FP_MASK | LINK_MASK);\n@@ -986,19 +981,20 @@ ms1_emit_save_fp (enum save_direction direction,\n     {\n       offset -= UNITS_PER_WORD;\n       stack_offset -= UNITS_PER_WORD;\n-      ms1_emit_save_restore (direction, gen_rtx_REG (SImode, GPR_FP),\n-\t     gen_rtx_MEM (SImode, \n-\t\t\t  gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n-\t     stack_offset);\n+      mt_emit_save_restore\n+\t(direction, gen_rtx_REG (SImode, GPR_FP),\n+\t gen_rtx_MEM (SImode,\n+\t\t      gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n+\t stack_offset);\n     }\n }\n \n /* Emit code to save registers in the prologue and restore register\n    in epilogue.  */\n \n static void\n-ms1_emit_save_regs (enum save_direction direction,\n-\t\t    struct ms1_frame_info info)\n+mt_emit_save_regs (enum save_direction direction,\n+\t\t    struct mt_frame_info info)\n {\n   rtx base_reg;\n   int regno;\n@@ -1024,7 +1020,7 @@ ms1_emit_save_regs (enum save_direction direction,\n   if (info.save_fp)\n     {\n       /* This just records the space for it, the actual move generated in\n-\t ms1_emit_save_fp ().  */\n+\t mt_emit_save_fp ().  */\n       offset -= UNITS_PER_WORD;\n       stack_offset -= UNITS_PER_WORD;\n     }\n@@ -1033,10 +1029,11 @@ ms1_emit_save_regs (enum save_direction direction,\n     {\n       offset -= UNITS_PER_WORD;\n       stack_offset -= UNITS_PER_WORD;\n-      ms1_emit_save_restore (direction, gen_rtx_REG (SImode, GPR_LINK), \n-\t\tgen_rtx_MEM (SImode,\n-\t\t\t     gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n-\t\tstack_offset);\n+      mt_emit_save_restore\n+\t(direction, gen_rtx_REG (SImode, GPR_LINK), \n+\t gen_rtx_MEM (SImode,\n+\t\t      gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n+\t stack_offset);\n     }\n \n   /* Save any needed call-saved regs.  */\n@@ -1046,17 +1043,18 @@ ms1_emit_save_regs (enum save_direction direction,\n \t{\n \t  offset -= UNITS_PER_WORD;\n \t  stack_offset -= UNITS_PER_WORD;\n-\t  ms1_emit_save_restore (direction, gen_rtx_REG (SImode, regno),\n-\t\t\t\t    gen_rtx_MEM (SImode,\n-\t\t\t\t\t\t gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n-\t\t\t\t    stack_offset);\n+\t  mt_emit_save_restore\n+\t    (direction, gen_rtx_REG (SImode, regno),\n+\t     gen_rtx_MEM (SImode,\n+\t\t\t  gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n+\t     stack_offset);\n \t}\n     }\n }\n \n /* Return true if FUNC is a function with the 'interrupt' attribute.  */\n static bool\n-ms1_interrupt_function_p (tree func)\n+mt_interrupt_function_p (tree func)\n {\n   tree a;\n \n@@ -1069,22 +1067,22 @@ ms1_interrupt_function_p (tree func)\n \n /* Generate prologue code.  */\n void\n-ms1_expand_prologue (void)\n+mt_expand_prologue (void)\n {\n   rtx size_rtx, insn;\n   unsigned int frame_size;\n \n-  if (ms1_interrupt_function_p (current_function_decl))\n+  if (mt_interrupt_function_p (current_function_decl))\n     {\n       interrupt_handler = 1;\n       if (cfun->machine)\n \tcfun->machine->interrupt_handler = 1;\n     }\n \n-  ms1_compute_frame_size (get_frame_size ());\n+  mt_compute_frame_size (get_frame_size ());\n \n   if (TARGET_DEBUG_STACK)\n-    ms1_debug_stack (&current_frame_info);\n+    mt_debug_stack (&current_frame_info);\n \n   /* Compute size of stack adjustment.  */\n   frame_size = current_frame_info.total_size;\n@@ -1123,13 +1121,14 @@ ms1_expand_prologue (void)\n \t\t\t     REG_NOTES (insn));\n     }\n \n-  /* Set R9 to point to old sp if required for access to register save area.  */\n+  /* Set R9 to point to old sp if required for access to register save\n+     area.  */\n   if ( current_frame_info.reg_size != 0\n        && !CONST_OK_FOR_LETTER_P (frame_size, 'O'))\n       emit_insn (gen_addsi3 (size_rtx, size_rtx, stack_pointer_rtx));\n   \n   /* Save the frame pointer.  */\n-  ms1_emit_save_fp (FROM_PROCESSOR_TO_MEM, current_frame_info);\n+  mt_emit_save_fp (FROM_PROCESSOR_TO_MEM, current_frame_info);\n \n   /* Now put the frame pointer into the frame pointer register.  */\n   if (frame_pointer_needed)\n@@ -1139,7 +1138,7 @@ ms1_expand_prologue (void)\n     }\n \n   /* Save the registers.  */\n-  ms1_emit_save_regs (FROM_PROCESSOR_TO_MEM, current_frame_info);\n+  mt_emit_save_regs (FROM_PROCESSOR_TO_MEM, current_frame_info);\n \n   /* If we are profiling, make sure no instructions are scheduled before\n      the call to mcount.  */\n@@ -1149,7 +1148,7 @@ ms1_expand_prologue (void)\n \n /* Implement EPILOGUE_USES.  */\n int\n-ms1_epilogue_uses (int regno)\n+mt_epilogue_uses (int regno)\n {\n   if (cfun->machine && cfun->machine->interrupt_handler && reload_completed)\n     return 1;\n@@ -1160,15 +1159,15 @@ ms1_epilogue_uses (int regno)\n    function epilogue, or EH_EPILOGUE when generating an EH\n    epilogue.  */\n void\n-ms1_expand_epilogue (enum epilogue_type eh_mode)\n+mt_expand_epilogue (enum epilogue_type eh_mode)\n {\n   rtx size_rtx, insn;\n   unsigned frame_size;\n \n-  ms1_compute_frame_size (get_frame_size ());\n+  mt_compute_frame_size (get_frame_size ());\n \n   if (TARGET_DEBUG_STACK)\n-    ms1_debug_stack (& current_frame_info);\n+    mt_debug_stack (& current_frame_info);\n \n   /* Compute size of stack adjustment.  */\n   frame_size = current_frame_info.total_size;\n@@ -1196,8 +1195,8 @@ ms1_expand_epilogue (enum epilogue_type eh_mode)\n     insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n \n   /* Restore the registers.  */\n-  ms1_emit_save_fp (FROM_MEM_TO_PROCESSOR, current_frame_info);\n-  ms1_emit_save_regs (FROM_MEM_TO_PROCESSOR, current_frame_info);\n+  mt_emit_save_fp (FROM_MEM_TO_PROCESSOR, current_frame_info);\n+  mt_emit_save_regs (FROM_MEM_TO_PROCESSOR, current_frame_info);\n \n   /* Make stack adjustment and use scratch register if constant too\n      large to fit as immediate.  */\n@@ -1250,7 +1249,7 @@ ms1_expand_epilogue (enum epilogue_type eh_mode)\n \n /* Generate code for the \"eh_return\" pattern.  */\n void\n-ms1_expand_eh_return (rtx * operands)\n+mt_expand_eh_return (rtx * operands)\n {\n   if (GET_CODE (operands[0]) != REG\n       || REGNO (operands[0]) != EH_RETURN_STACKADJ_REGNO)\n@@ -1266,15 +1265,15 @@ ms1_expand_eh_return (rtx * operands)\n \n /* Generate code for the \"eh_epilogue\" pattern.  */\n void\n-ms1_emit_eh_epilogue (rtx * operands ATTRIBUTE_UNUSED)\n+mt_emit_eh_epilogue (rtx * operands ATTRIBUTE_UNUSED)\n {\n   cfun->machine->eh_stack_adjust = EH_RETURN_STACKADJ_RTX; /* operands[0]; */\n-  ms1_expand_epilogue (EH_EPILOGUE);\n+  mt_expand_epilogue (EH_EPILOGUE);\n }\n \n /* Handle an \"interrupt\" attribute.  */\n static tree\n-ms1_handle_interrupt_attribute (tree * node,\n+mt_handle_interrupt_attribute (tree * node,\n \t\t\t  tree   name,\n \t\t\t  tree   args  ATTRIBUTE_UNUSED,\n \t\t\t  int    flags ATTRIBUTE_UNUSED,\n@@ -1292,18 +1291,18 @@ ms1_handle_interrupt_attribute (tree * node,\n }\n \n /* Table of machine attributes.  */\n-const struct attribute_spec ms1_attribute_table[] =\n+const struct attribute_spec mt_attribute_table[] =\n {\n   /* name,        min, max, decl?, type?, func?, handler  */\n-  { \"interrupt\",  0,   0,   false, false, false, ms1_handle_interrupt_attribute },\n+  { \"interrupt\",  0,   0,   false, false, false, mt_handle_interrupt_attribute },\n   { NULL,         0,   0,   false, false, false, NULL }\n };\n \n /* Implement INITIAL_ELIMINATION_OFFSET.  */\n int\n-ms1_initial_elimination_offset (int from, int to)\n+mt_initial_elimination_offset (int from, int to)\n {\n-  ms1_compute_frame_size (get_frame_size ());\n+  mt_compute_frame_size (get_frame_size ());\n \n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return 0;\n@@ -1322,7 +1321,7 @@ ms1_initial_elimination_offset (int from, int to)\n    represents the result of the compare.  */\n \n static rtx\n-ms1_generate_compare (enum rtx_code code, rtx op0, rtx op1)\n+mt_generate_compare (enum rtx_code code, rtx op0, rtx op1)\n {\n   rtx scratch0, scratch1, const_scratch;\n \n@@ -1335,7 +1334,7 @@ ms1_generate_compare (enum rtx_code code, rtx op0, rtx op1)\n       /* Need to adjust ranges for faking unsigned compares.  */\n       scratch0 = gen_reg_rtx (SImode);\n       scratch1 = gen_reg_rtx (SImode);\n-      const_scratch = force_reg (SImode, GEN_INT(MS1_MIN_INT));\n+      const_scratch = force_reg (SImode, GEN_INT(MT_MIN_INT));\n       emit_insn (gen_addsi3 (scratch0, const_scratch, op0));\n       emit_insn (gen_addsi3 (scratch1, const_scratch, op1));\n       break;\n@@ -1368,7 +1367,7 @@ ms1_generate_compare (enum rtx_code code, rtx op0, rtx op1)\n /* Emit a branch of kind CODE to location LOC.  */\n \n void\n-ms1_emit_cbranch (enum rtx_code code, rtx loc, rtx op0, rtx op1)\n+mt_emit_cbranch (enum rtx_code code, rtx loc, rtx op0, rtx op1)\n {\n   rtx condition_rtx, loc_ref;\n \n@@ -1378,7 +1377,7 @@ ms1_emit_cbranch (enum rtx_code code, rtx loc, rtx op0, rtx op1)\n   if (! reg_or_0_operand (op1, SImode))\n     op1 = copy_to_mode_reg (SImode, op1);\n \n-  condition_rtx = ms1_generate_compare (code, op0, op1);\n+  condition_rtx = mt_generate_compare (code, op0, op1);\n   loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);\n   emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n \t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,\n@@ -1389,7 +1388,7 @@ ms1_emit_cbranch (enum rtx_code code, rtx loc, rtx op0, rtx op1)\n    found in part of X.  */\n \n static void\n-ms1_set_memflags_1 (rtx x, int in_struct_p, int volatile_p)\n+mt_set_memflags_1 (rtx x, int in_struct_p, int volatile_p)\n {\n   int i;\n \n@@ -1398,16 +1397,16 @@ ms1_set_memflags_1 (rtx x, int in_struct_p, int volatile_p)\n     case SEQUENCE:\n     case PARALLEL:\n       for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\tms1_set_memflags_1 (XVECEXP (x, 0, i), in_struct_p, volatile_p);\n+\tmt_set_memflags_1 (XVECEXP (x, 0, i), in_struct_p, volatile_p);\n       break;\n \n     case INSN:\n-      ms1_set_memflags_1 (PATTERN (x), in_struct_p, volatile_p);\n+      mt_set_memflags_1 (PATTERN (x), in_struct_p, volatile_p);\n       break;\n \n     case SET:\n-      ms1_set_memflags_1 (SET_DEST (x), in_struct_p, volatile_p);\n-      ms1_set_memflags_1 (SET_SRC (x), in_struct_p, volatile_p);\n+      mt_set_memflags_1 (SET_DEST (x), in_struct_p, volatile_p);\n+      mt_set_memflags_1 (SET_SRC (x), in_struct_p, volatile_p);\n       break;\n \n     case MEM:\n@@ -1431,7 +1430,7 @@ ms1_set_memflags_1 (rtx x, int in_struct_p, int volatile_p)\n    If REF is not a MEM, don't do anything.  */\n \n void\n-ms1_set_memflags (rtx ref)\n+mt_set_memflags (rtx ref)\n {\n   rtx insn;\n   int in_struct_p, volatile_p;\n@@ -1442,19 +1441,19 @@ ms1_set_memflags (rtx ref)\n   in_struct_p = MEM_IN_STRUCT_P (ref);\n   volatile_p = MEM_VOLATILE_P (ref);\n \n-  /* This is only called from ms1.md, after having had something \n+  /* This is only called from mt.md, after having had something \n      generated from one of the insn patterns.  So if everything is\n      zero, the pattern is already up-to-date.  */\n   if (! in_struct_p && ! volatile_p)\n     return;\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    ms1_set_memflags_1 (insn, in_struct_p, volatile_p);\n+    mt_set_memflags_1 (insn, in_struct_p, volatile_p);\n }\n \n /* Implement SECONDARY_RELOAD_CLASS.  */\n enum reg_class\n-ms1_secondary_reload_class (enum reg_class class ATTRIBUTE_UNUSED,\n+mt_secondary_reload_class (enum reg_class class ATTRIBUTE_UNUSED,\n \t\t\t    enum machine_mode mode,\n \t\t\t    rtx x)\n {\n@@ -1475,7 +1474,7 @@ ms1_secondary_reload_class (enum reg_class class ATTRIBUTE_UNUSED,\n /* Handle FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE, and LIBCALL_VALUE\n    macros.  */\n rtx\n-ms1_function_value (tree valtype, enum machine_mode mode, tree func_decl ATTRIBUTE_UNUSED)\n+mt_function_value (tree valtype, enum machine_mode mode, tree func_decl ATTRIBUTE_UNUSED)\n {\n   if ((mode) == DImode || (mode) == DFmode)\n     return gen_rtx_MEM (mode, gen_rtx_REG (mode, RETURN_VALUE_REGNUM));\n@@ -1493,7 +1492,7 @@ ms1_function_value (tree valtype, enum machine_mode mode, tree func_decl ATTRIBU\n    and OPERANDS[5].  */\n \n void\n-ms1_split_words (enum machine_mode nmode,\n+mt_split_words (enum machine_mode nmode,\n \t\t enum machine_mode omode,\n \t\t rtx *operands)\n {\n@@ -1642,7 +1641,7 @@ ms1_split_words (enum machine_mode nmode,\n \n /* Implement TARGET_MUST_PASS_IN_STACK hook.  */\n static bool\n-ms1_pass_in_stack (enum machine_mode mode ATTRIBUTE_UNUSED, tree type)\n+mt_pass_in_stack (enum machine_mode mode ATTRIBUTE_UNUSED, tree type)\n {\n   return (((type) != 0\n \t   && (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n@@ -1652,7 +1651,7 @@ ms1_pass_in_stack (enum machine_mode mode ATTRIBUTE_UNUSED, tree type)\n /* Increment the counter for the number of loop instructions in the\n    current function.  */\n \n-void ms1_add_loop (void)\n+void mt_add_loop (void)\n {\n   cfun->machine->has_loops++;\n }\n@@ -1745,7 +1744,7 @@ DEF_VEC_ALLOC_O (loop_work,heap);\n    is bad.  */\n \n static bool\n-ms1_loop_nesting (loop_info loop)\n+mt_loop_nesting (loop_info loop)\n {\n   loop_info inner;\n   unsigned ix;\n@@ -1775,7 +1774,7 @@ ms1_loop_nesting (loop_info loop)\n \t  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix++, inner);)\n \t    {\n \t      if (!inner->depth)\n-\t\tms1_loop_nesting (inner);\n+\t\tmt_loop_nesting (inner);\n \t      \n \t      if (inner->depth < 0)\n \t\t{\n@@ -1802,7 +1801,7 @@ ms1_loop_nesting (loop_info loop)\n /* Determine the length of block BB.  */\n \n static int\n-ms1_block_length (basic_block bb)\n+mt_block_length (basic_block bb)\n {\n   int length = 0;\n   rtx insn;\n@@ -1830,7 +1829,7 @@ ms1_block_length (basic_block bb)\n    insn if it matches DBNZ.  */\n \n static bool\n-ms1_scan_loop (loop_info loop, rtx reg, rtx dbnz)\n+mt_scan_loop (loop_info loop, rtx reg, rtx dbnz)\n {\n   unsigned ix;\n   loop_info inner;\n@@ -1853,7 +1852,7 @@ ms1_scan_loop (loop_info loop, rtx reg, rtx dbnz)\n \t}\n     }\n   for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, inner); ix++)\n-    if (ms1_scan_loop (inner, reg, NULL_RTX))\n+    if (mt_scan_loop (inner, reg, NULL_RTX))\n       return true;\n   \n   return false;\n@@ -1893,7 +1892,7 @@ ms1_scan_loop (loop_info loop, rtx reg, rtx dbnz)\n    subroutine calls in the loop.  */\n \n static void\n-ms1_reorg_loops (FILE *dump_file)\n+mt_reorg_loops (FILE *dump_file)\n {\n   basic_block bb;\n   loop_info loops = NULL;\n@@ -1930,7 +1929,7 @@ ms1_reorg_loops (FILE *dump_file)\n \t  loop->predecessor = NULL;\n \t  loop->dbnz = tail;\n \t  loop->depth = 0;\n-\t  loop->length = ms1_block_length (bb);\n+\t  loop->length = mt_block_length (bb);\n \t  loop->blocks = VEC_alloc (basic_block, heap, 20);\n \t  VEC_quick_push (basic_block, loop->blocks, bb);\n \t  loop->loops = NULL;\n@@ -1981,7 +1980,7 @@ ms1_reorg_loops (FILE *dump_file)\n \t  /* We've not seen this block before.  Add it to the loop's\n \t     list and then add each successor to the work list.  */\n \t  bb->aux = loop;\n-\t  loop->length += ms1_block_length (bb);\n+\t  loop->length += mt_block_length (bb);\n \t  VEC_safe_push (basic_block, heap, loop->blocks, bb);\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n@@ -2027,7 +2026,7 @@ ms1_reorg_loops (FILE *dump_file)\n       rtx iter_reg, insn, init_insn;\n       rtx init_val, loop_end, loop_init, end_label, head_label;\n \n-      if (!ms1_loop_nesting (loop))\n+      if (!mt_loop_nesting (loop))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \";; loop %d is bad\\n\", loop->loop_no);\n@@ -2090,7 +2089,7 @@ ms1_reorg_loops (FILE *dump_file)\n \t}\n       \n       /* Scan all the blocks to make sure they don't use iter_reg.  */\n-      if (ms1_scan_loop (loop, iter_reg, loop->dbnz))\n+      if (mt_scan_loop (loop, iter_reg, loop->dbnz))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \";; loop %d uses iterator\\n\",\n@@ -2170,29 +2169,29 @@ typedef struct label_info\n } label_info;\n \n /* Chain of labels found in current function, used during reorg.  */\n-static label_info *ms1_labels;\n+static label_info *mt_labels;\n \n /* If *X is a label, add INSN to the list of branches for that\n    label.  */\n \n static int\n-ms1_add_branches (rtx *x, void *insn)\n+mt_add_branches (rtx *x, void *insn)\n {\n   if (GET_CODE (*x) == LABEL_REF)\n     {\n       branch_info *branch = xmalloc (sizeof (*branch));\n       rtx label = XEXP (*x, 0);\n       label_info *info;\n \n-      for (info = ms1_labels; info; info = info->next)\n+      for (info = mt_labels; info; info = info->next)\n \tif (info->label == label)\n \t  break;\n \n       if (!info)\n \t{\n \t  info = xmalloc (sizeof (*info));\n-\t  info->next = ms1_labels;\n-\t  ms1_labels = info;\n+\t  info->next = mt_labels;\n+\t  mt_labels = info;\n \t  \n \t  info->label = label;\n \t  info->branches = NULL;\n@@ -2212,7 +2211,7 @@ ms1_add_branches (rtx *x, void *insn)\n    In that case, the caller must insert nops at the branch target.  */\n \n static rtx\n-ms1_check_delay_slot (rtx branch, rtx insn)\n+mt_check_delay_slot (rtx branch, rtx insn)\n {\n   rtx slot;\n   rtx tmp;\n@@ -2266,7 +2265,7 @@ ms1_check_delay_slot (rtx branch, rtx insn)\n    delay slot.  */\n \n static void\n-ms1_reorg_hazard (void)\n+mt_reorg_hazard (void)\n {\n   rtx insn, next;\n \n@@ -2295,7 +2294,7 @@ ms1_reorg_hazard (void)\n \t     jmp = NEXT_INSN (jmp))\n \t  continue;\n \n-      for_each_rtx (&PATTERN (jmp), ms1_add_branches, insn);\n+      for_each_rtx (&PATTERN (jmp), mt_add_branches, insn);\n     }\n \n   /* Now scan for dependencies.  */\n@@ -2367,7 +2366,7 @@ ms1_reorg_hazard (void)\n \t\t  label_info *label;\n \t\t  branch_info *branch;\n \n-\t\t  for (label = ms1_labels;\n+\t\t  for (label = mt_labels;\n \t\t       label;\n \t\t       label = label->next)\n \t\t    if (label->label == prev)\n@@ -2376,7 +2375,7 @@ ms1_reorg_hazard (void)\n \t\t\t     branch;\n \t\t\t     branch = branch->next)\n \t\t\t  {\n-\t\t\t    tmp = ms1_check_delay_slot (branch->insn, jmp);\n+\t\t\t    tmp = mt_check_delay_slot (branch->insn, jmp);\n \n \t\t\t    if (tmp == branch->insn)\n \t\t\t      {\n@@ -2397,7 +2396,7 @@ ms1_reorg_hazard (void)\n \t      if (GET_CODE (PATTERN (prev)) == SEQUENCE)\n \t\t{\n \t\t  /* Look at the delay slot.  */\n-\t\t  tmp = ms1_check_delay_slot (prev, jmp);\n+\t\t  tmp = mt_check_delay_slot (prev, jmp);\n \t\t  if (tmp == prev)\n \t\t    nops = count;\n \t\t  break;\n@@ -2443,12 +2442,12 @@ ms1_reorg_hazard (void)\n     }\n \n   /* Free the data structures.  */\n-  while (ms1_labels)\n+  while (mt_labels)\n     {\n-      label_info *label = ms1_labels;\n+      label_info *label = mt_labels;\n       branch_info *branch, *next;\n       \n-      ms1_labels = label->next;\n+      mt_labels = label->next;\n       for (branch = label->branches; branch; branch = next)\n \t{\n \t  next = branch->next;\n@@ -2462,35 +2461,35 @@ ms1_reorg_hazard (void)\n    scheduling hazards.  */\n \n static void\n-ms1_machine_reorg (void)\n+mt_machine_reorg (void)\n {\n   if (cfun->machine->has_loops && TARGET_MS2)\n-    ms1_reorg_loops (dump_file);\n+    mt_reorg_loops (dump_file);\n \n-  if (ms1_flag_delayed_branch)\n+  if (mt_flag_delayed_branch)\n     dbr_schedule (get_insns (), dump_file);\n   \n   if (TARGET_MS2)\n-    ms1_reorg_hazard ();\n+    mt_reorg_hazard ();\n }\n \f\n /* Initialize the GCC target structure.  */\n-const struct attribute_spec ms1_attribute_table[];\n+const struct attribute_spec mt_attribute_table[];\n \n #undef  TARGET_ATTRIBUTE_TABLE\n-#define TARGET_ATTRIBUTE_TABLE \t\tms1_attribute_table\n+#define TARGET_ATTRIBUTE_TABLE \t\tmt_attribute_table\n #undef  TARGET_STRUCT_VALUE_RTX\n-#define TARGET_STRUCT_VALUE_RTX\t\tms1_struct_value_rtx\n+#define TARGET_STRUCT_VALUE_RTX\t\tmt_struct_value_rtx\n #undef  TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES\thook_bool_tree_true\n #undef  TARGET_PASS_BY_REFERENCE\n-#define TARGET_PASS_BY_REFERENCE\tms1_pass_by_reference\n+#define TARGET_PASS_BY_REFERENCE\tmt_pass_by_reference\n #undef  TARGET_MUST_PASS_IN_STACK\n-#define TARGET_MUST_PASS_IN_STACK       ms1_pass_in_stack\n+#define TARGET_MUST_PASS_IN_STACK       mt_pass_in_stack\n #undef  TARGET_ARG_PARTIAL_BYTES\n-#define TARGET_ARG_PARTIAL_BYTES\tms1_arg_partial_bytes\n+#define TARGET_ARG_PARTIAL_BYTES\tmt_arg_partial_bytes\n #undef  TARGET_MACHINE_DEPENDENT_REORG\n-#define TARGET_MACHINE_DEPENDENT_REORG  ms1_machine_reorg\n+#define TARGET_MACHINE_DEPENDENT_REORG  mt_machine_reorg\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f"}, {"sha": "75d56f91ae47073226e9e8e17007fe69a363c5e4", "filename": "gcc/config/mt/mt.h", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.h?ref=bccef6d862166e9c58e231ba7aff09b59781d70d", "patch": "@@ -19,7 +19,7 @@\n    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301, USA.  */\n \n-extern struct rtx_def * ms1_ucmpsi3_libcall;\n+extern struct rtx_def * mt_ucmpsi3_libcall;\n \n enum processor_type\n {\n@@ -35,7 +35,7 @@ enum epilogue_type\n   NORMAL_EPILOGUE\n };\n \n-extern enum processor_type ms1_cpu;\n+extern enum processor_type mt_cpu;\n \n \f\n /* A C string constant that tells the GCC driver program options to pass to\n@@ -91,19 +91,19 @@ march=MS2:exit-ms2.o%s; \\\n #define TARGET_CPU_CPP_BUILTINS() \t\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n-      builtin_define_std (\"ms1\");\t\t\\\n-      builtin_assert (\"machine=ms1\");\t\\\n+      builtin_define_std (\"mt\");\t\t\\\n+      builtin_assert (\"machine=mt\");\t\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n \n-#define TARGET_MS1_64_001 (ms1_cpu == PROCESSOR_MS1_64_001)\n-#define TARGET_MS1_16_002 (ms1_cpu == PROCESSOR_MS1_16_002)\n-#define TARGET_MS1_16_003 (ms1_cpu == PROCESSOR_MS1_16_003)\n-#define TARGET_MS2 (ms1_cpu == PROCESSOR_MS2)\n+#define TARGET_MS1_64_001 (mt_cpu == PROCESSOR_MS1_64_001)\n+#define TARGET_MS1_16_002 (mt_cpu == PROCESSOR_MS1_16_002)\n+#define TARGET_MS1_16_003 (mt_cpu == PROCESSOR_MS1_16_003)\n+#define TARGET_MS2 (mt_cpu == PROCESSOR_MS2)\n \n-#define TARGET_VERSION  fprintf (stderr, \" (ms1)\");\n+#define TARGET_VERSION  fprintf (stderr, \" (mt)\");\n \n-#define OVERRIDE_OPTIONS ms1_override_options ()\n+#define OVERRIDE_OPTIONS mt_override_options ()\n \n #define CAN_DEBUG_WITHOUT_FP 1\n \n@@ -343,7 +343,7 @@ enum reg_class\n #define PREFERRED_RELOAD_CLASS(X, CLASS) (CLASS)\n \n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,X) \\\n-  ms1_secondary_reload_class((CLASS), (MODE), (X))\n+  mt_secondary_reload_class((CLASS), (MODE), (X))\n \n /* A C expression for the maximum number of consecutive registers of\n    class CLASS needed to hold a value of mode MODE.  */\n@@ -402,8 +402,8 @@ enum reg_class\n    (`G', `H') that specify particular ranges of `const_double' values.  */\n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n \n-/* Most negative value represent on ms1 */\n-#define MS1_MIN_INT 0x80000000\n+/* Most negative value represent on mt */\n+#define MT_MIN_INT 0x80000000\n \f\n /* Basic Stack Layout.  */\n \n@@ -454,7 +454,7 @@ enum save_direction\n #define FIRST_PARM_OFFSET(FUNDECL) 0\n \n #define RETURN_ADDR_RTX(COUNT, FRAMEADDR) \t\t\t\t\\\n-    ms1_return_addr_rtx (COUNT)\n+    mt_return_addr_rtx (COUNT)\n \n /* A C expression whose value is RTL representing the location of the incoming\n    return address at the beginning of any function, before the prologue.  This\n@@ -493,7 +493,7 @@ enum save_direction\n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n \n-struct ms1_frame_info\n+struct mt_frame_info\n {\n   unsigned int total_size;      /* # Bytes that the entire frame takes up.  */\n   unsigned int pretend_size;    /* # Bytes we push and pretend caller did.  */\n@@ -508,7 +508,7 @@ struct ms1_frame_info\n   int          initialized;     /* Nonzero if frame size already calculated.  */\n }; \n \n-extern struct ms1_frame_info current_frame_info;\n+extern struct mt_frame_info current_frame_info;\n \n /* If defined, this macro specifies a table of register pairs used to eliminate\n    unneeded registers that point into the stack frame.  */\n@@ -531,7 +531,7 @@ extern struct ms1_frame_info current_frame_info;\n    registers.  This macro must be defined if `ELIMINABLE_REGS' is\n    defined.  */\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-  (OFFSET) = ms1_initial_elimination_offset (FROM, TO)\n+  (OFFSET) = mt_initial_elimination_offset (FROM, TO)\n \n /* If defined, the maximum amount of space required for outgoing\n    arguments will be computed and placed into the variable\n@@ -543,11 +543,11 @@ extern struct ms1_frame_info current_frame_info;\n #define OUTGOING_REG_PARM_STACK_SPACE\n \n /* The number of register assigned to holding function arguments.  */\n-#define MS1_NUM_ARG_REGS        4\n+#define MT_NUM_ARG_REGS        4\n \n /* Define this if it is the responsibility of the caller to allocate\n    the area reserved for arguments passed in registers.  */\n-#define REG_PARM_STACK_SPACE(FNDECL) (MS1_NUM_ARG_REGS * UNITS_PER_WORD)\n+#define REG_PARM_STACK_SPACE(FNDECL) (MT_NUM_ARG_REGS * UNITS_PER_WORD)\n \n /* Define this macro if `REG_PARM_STACK_SPACE' is defined, but the stack\n    parameters don't skip the area specified by it.  */\n@@ -560,29 +560,29 @@ extern struct ms1_frame_info current_frame_info;\n #define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-   ms1_function_arg (& (CUM), (MODE), (TYPE), (NAMED), FALSE)\n+   mt_function_arg (& (CUM), (MODE), (TYPE), (NAMED), FALSE)\n \n #define CUMULATIVE_ARGS int\n \n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS)\t\\\n-    ms1_init_cumulative_args (& (CUM), FNTYPE, LIBNAME, FNDECL, FALSE)\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n+    mt_init_cumulative_args (& (CUM), FNTYPE, LIBNAME, FNDECL, FALSE)\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-    ms1_function_arg_advance (&CUM, MODE, TYPE, NAMED)\n+    mt_function_arg_advance (&CUM, MODE, TYPE, NAMED)\n \n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n-    ms1_function_arg_boundary (MODE, TYPE)\n+    mt_function_arg_boundary (MODE, TYPE)\n \n #define FUNCTION_ARG_REGNO_P(REGNO)\t\t\t\t\t\\\n   ((REGNO) >= FIRST_ARG_REGNUM && ((REGNO) <= LAST_ARG_REGNUM))\n \n #define RETURN_VALUE_REGNUM\tRETVAL_REGNUM\n      \n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-   ms1_function_value (VALTYPE, TYPE_MODE(VALTYPE), FUNC)\n+   mt_function_value (VALTYPE, TYPE_MODE(VALTYPE), FUNC)\n \n #define LIBCALL_VALUE(MODE) \\\n-   ms1_function_value (NULL_TREE, MODE, NULL_TREE)\n+   mt_function_value (NULL_TREE, MODE, NULL_TREE)\n \n #define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == RETURN_VALUE_REGNUM)\n \n@@ -600,7 +600,7 @@ extern struct ms1_frame_info current_frame_info;\n    adjust the stack pointer before a return from the function.  */\n #define EXIT_IGNORE_STACK 1\n \n-#define EPILOGUE_USES(REGNO) ms1_epilogue_uses(REGNO)\n+#define EPILOGUE_USES(REGNO) mt_epilogue_uses(REGNO)\n \n /* Define this macro if the function epilogue contains delay slots to which\n    instructions from the rest of the function can be \"moved\".  */\n@@ -613,7 +613,7 @@ extern struct ms1_frame_info current_frame_info;\n #define FUNCTION_PROFILER(FILE, LABELNO) gcc_unreachable ()\n \n #define EXPAND_BUILTIN_VA_START(VALIST, NEXTARG)\t\t\\\n-  ms1_va_start (VALIST, NEXTARG)\n+  mt_va_start (VALIST, NEXTARG)\n \n /* Trampolines are not implemented.  */\n #define TRAMPOLINE_SIZE 0\n@@ -637,21 +637,21 @@ extern struct ms1_frame_info current_frame_info;\n #ifdef REG_OK_STRICT\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n {\t\t\t\t\t\t\\\n-  if (ms1_legitimate_address_p (MODE, X, 1))\t\\\n+  if (mt_legitimate_address_p (MODE, X, 1))\t\\\n     goto ADDR;\t\t\t\t\t\\\n }\n #else\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n {\t\t\t\t\t\t\\\n-  if (ms1_legitimate_address_p (MODE, X, 0))\t\\\n+  if (mt_legitimate_address_p (MODE, X, 0))\t\\\n     goto ADDR;\t\t\t\t\t\\\n }\n #endif\n \n #ifdef REG_OK_STRICT\n-#define REG_OK_FOR_BASE_P(X) ms1_reg_ok_for_base_p (X, 1)\n+#define REG_OK_FOR_BASE_P(X) mt_reg_ok_for_base_p (X, 1)\n #else\n-#define REG_OK_FOR_BASE_P(X) ms1_reg_ok_for_base_p (X, 0)\n+#define REG_OK_FOR_BASE_P(X) mt_reg_ok_for_base_p (X, 0)\n #endif\n \n #define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n@@ -759,19 +759,19 @@ extern struct ms1_frame_info current_frame_info;\n    desire, and increment the variable PTR to point at the end of the opcode so\n    that it will not be output twice.  */\n #define ASM_OUTPUT_OPCODE(STREAM, PTR) \\\n-   (PTR) = ms1_asm_output_opcode (STREAM, PTR)\n+   (PTR) = mt_asm_output_opcode (STREAM, PTR)\n \n #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n-  ms1_final_prescan_insn (INSN, OPVEC, NOPERANDS)\n+  mt_final_prescan_insn (INSN, OPVEC, NOPERANDS)\n \n-#define PRINT_OPERAND(STREAM, X, CODE) ms1_print_operand (STREAM, X, CODE)\n+#define PRINT_OPERAND(STREAM, X, CODE) mt_print_operand (STREAM, X, CODE)\n \n /* A C expression which evaluates to true if CODE is a valid punctuation\n    character for use in the `PRINT_OPERAND' macro.  */\n /* #:  Print nop for delay slot.  */\n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '#')\n \n-#define PRINT_OPERAND_ADDRESS(STREAM, X) ms1_print_operand_address (STREAM, X)\n+#define PRINT_OPERAND_ADDRESS(STREAM, X) mt_print_operand_address (STREAM, X)\n \n /* If defined, C string expressions to be used for the `%R', `%L', `%U', and\n    `%I' options of `asm_fprintf' (see `final.c').  These are useful when a\n@@ -874,6 +874,6 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */\n \n-extern struct rtx_def * ms1_compare_op0;\n-extern struct rtx_def * ms1_compare_op1;\n+extern struct rtx_def * mt_compare_op0;\n+extern struct rtx_def * mt_compare_op1;\n "}, {"sha": "caf6fffb8f96a7697af8092ac173f632e53205dc", "filename": "gcc/config/mt/mt.md", "status": "modified", "additions": 49, "deletions": 52, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fmt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fmt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.md?ref=bccef6d862166e9c58e231ba7aff09b59781d70d", "patch": "@@ -68,8 +68,8 @@\n \f\n ;; Delay Slots\n \n-;; The ms1 does not allow branches in the delay slot.\n-;; The ms1 does not allow back to back memory or io instruction.\n+;; The mt does not allow branches in the delay slot.\n+;; The mt does not allow back to back memory or io instruction.\n ;; The compiler does not know what the type of instruction is at\n ;; the destination of the branch.  Thus, only type that will be acceptable\n ;; (safe) is the arith type.\n@@ -199,7 +199,7 @@\n \t\t\t    (const_int -1)))\n \t      (clobber (match_scratch:SI 5 \"\"))])]\n   \"TARGET_MS1_16_003 || TARGET_MS2\"\n-  {ms1_add_loop ();})\n+  {mt_add_loop ();})\n \f\n ;; Moves\n \n@@ -294,7 +294,7 @@\n \tstart_sequence ();\n \temit_insn (gen_storeqi (gen_lowpart (SImode, data), address,\n \t\t\t\tscratch1, scratch2, scratch3));\n-\tms1_set_memflags (operands[0]);\n+\tmt_set_memflags (operands[0]);\n \tseq = get_insns ();\n \tend_sequence ();\n \temit_insn (seq);\n@@ -313,7 +313,7 @@\n \n \tstart_sequence ();\n \temit_insn (gen_loadqi (gen_lowpart (SImode, data), address, scratch1));\n-\tms1_set_memflags (operands[1]);\n+\tmt_set_memflags (operands[1]);\n \tseq = get_insns ();\n \tend_sequence ();\n \temit_insn (seq);\n@@ -333,7 +333,7 @@\n \n \tstart_sequence ();\n \temit_insn (gen_movsi (gen_lowpart (SImode, data), address));\n-\tms1_set_memflags (operands[1]);\n+\tmt_set_memflags (operands[1]);\n \tseq = get_insns ();\n \tend_sequence ();\n \temit_insn (seq);\n@@ -467,7 +467,7 @@\n \tstart_sequence ();\n \temit_insn (gen_storehi (gen_lowpart (SImode, data), address,\n \t\t\t        scratch1, scratch2, scratch3));\n-\tms1_set_memflags (operands[0]);\n+\tmt_set_memflags (operands[0]);\n \tseq = get_insns ();\n \tend_sequence ();\n \temit_insn (seq);\n@@ -487,7 +487,7 @@\n \tstart_sequence ();\n \temit_insn (gen_loadhi (gen_lowpart (SImode, data), address,\n \t\t\t       scratch1));\n-\tms1_set_memflags (operands[1]);\n+\tmt_set_memflags (operands[1]);\n \tseq = get_insns ();\n \tend_sequence ();\n \temit_insn (seq);\n@@ -506,7 +506,7 @@\n \n \tstart_sequence ();\n \temit_insn (gen_movsi (gen_lowpart (SImode, data), address));\n-\tms1_set_memflags (operands[1]);\n+\tmt_set_memflags (operands[1]);\n \tseq = get_insns ();\n \tend_sequence ();\n \temit_insn (seq);\n@@ -716,7 +716,7 @@\n \n   \"{\n     /* figure out what precisely to put into operands 2, 3, 4, and 5 */\n-    ms1_split_words (SImode, DFmode, operands);\n+    mt_split_words (SImode, DFmode, operands);\n   }\"\n )\n \n@@ -757,7 +757,7 @@\n \n   start_sequence ();\n   emit_insn (gen_loadqi (gen_lowpart (SImode, data), address, scratch1));\n-  ms1_set_memflags (operands[1]);\n+  mt_set_memflags (operands[1]);\n   seq = get_insns ();\n   end_sequence ();\n   emit_insn (seq);\n@@ -786,7 +786,7 @@\n   start_sequence ();\n   emit_insn (gen_storeqi (gen_lowpart (SImode, data), address, \n \t\t\t  scratch1, scratch2, scratch3));\n-  ms1_set_memflags (operands[0]);\n+  mt_set_memflags (operands[0]);\n   seq = get_insns ();\n   end_sequence ();\n   emit_insn (seq);\n@@ -824,7 +824,7 @@\n   start_sequence ();\n   emit_insn (gen_loadhi (gen_lowpart (SImode, data), address,\n \t\t         scratch1));\n-  ms1_set_memflags (operands[1]);\n+  mt_set_memflags (operands[1]);\n   seq = get_insns ();\n   end_sequence ();\n   emit_insn (seq);\n@@ -853,7 +853,7 @@\n   start_sequence ();\n   emit_insn (gen_storehi (gen_lowpart (SImode, data), address,\n \t\t          scratch1, scratch2, scratch3));\n-  ms1_set_memflags (operands[0]);\n+  mt_set_memflags (operands[0]);\n   seq = get_insns ();\n   end_sequence ();\n   emit_insn (seq);\n@@ -1014,8 +1014,8 @@\n   \"\"\n   \"\n {\n-  ms1_compare_op0 = operands[0];\n-  ms1_compare_op1 = operands[1];\n+  mt_compare_op0 = operands[0];\n+  mt_compare_op1 = operands[1];\n   DONE;\n }\")\n \n@@ -1026,98 +1026,98 @@\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n   \"\n-{  ms1_emit_cbranch (EQ, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+{\n+  mt_emit_cbranch (EQ, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n (define_expand \"bne\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n   \"\n-{  ms1_emit_cbranch (NE, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+{\n+  mt_emit_cbranch (NE, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n (define_expand \"bge\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n   \"\n-{  ms1_emit_cbranch (GE, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+{\n+  mt_emit_cbranch (GE, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n (define_expand \"bgt\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n   \"\n-{  ms1_emit_cbranch (GT, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+{\n+  mt_emit_cbranch (GT, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n (define_expand \"ble\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n   \"\n-{  ms1_emit_cbranch (LE, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+{\n+  mt_emit_cbranch (LE, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n (define_expand \"blt\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n   \"\n-{  ms1_emit_cbranch (LT, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+{\n+  mt_emit_cbranch (LT, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n (define_expand \"bgeu\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n   \"\n-{  ms1_emit_cbranch (GEU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+{\n+  mt_emit_cbranch (GEU, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n (define_expand \"bgtu\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n   \"\n-{  ms1_emit_cbranch (GTU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+{\n+  mt_emit_cbranch (GTU, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n (define_expand \"bleu\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n   \"\n-{  ms1_emit_cbranch (LEU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+{\n+  mt_emit_cbranch (LEU, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n (define_expand \"bltu\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n   \"\n-{  ms1_emit_cbranch (LTU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+{\n+  mt_emit_cbranch (LTU, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n (define_expand \"bunge\"\n   [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n   \"\n-{  ms1_emit_cbranch (GEU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+{\n+  mt_emit_cbranch (GEU, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n@@ -1126,8 +1126,7 @@\n   \"\"\n   \"\n {\n-  ms1_emit_cbranch (GTU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+  mt_emit_cbranch (GTU, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n@@ -1136,8 +1135,7 @@\n   \"\"\n   \"\n {\n-  ms1_emit_cbranch (LEU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+  mt_emit_cbranch (LEU, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n@@ -1146,8 +1144,7 @@\n   \"\"\n   \"\n {\n-  ms1_emit_cbranch (LTU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n+  mt_emit_cbranch (LTU, operands[0], mt_compare_op0, mt_compare_op1);\n   DONE;\n }\")\n \n@@ -1284,15 +1281,15 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"branch\")])\n \n-;; No unsigned operators on Morpho ms1.  All the unsigned operations are\n+;; No unsigned operators on Morpho mt.  All the unsigned operations are\n ;; converted to the signed operations above.\n \n \f\n ;; Set flag operations\n \n ;; \"seq\", \"sne\", \"slt\", \"sle\", \"sgt\", \"sge\", \"sltu\", \"sleu\",\n ;; \"sgtu\", and \"sgeu\" don't exist as regular instruction on the\n-;; ms1, so these are not defined\n+;; mt, so these are not defined\n \n ;; Call and branch instructions\n \n@@ -1402,7 +1399,7 @@\n   \"\"\n   \"\n {\n-  ms1_expand_prologue ();\n+  mt_expand_prologue ();\n   DONE;\n }\")\n \n@@ -1411,7 +1408,7 @@\n   \"\"\n   \"\n {\n-  ms1_expand_epilogue (NORMAL_EPILOGUE);\n+  mt_expand_epilogue (NORMAL_EPILOGUE);\n   DONE;\n }\")\n \n@@ -1421,7 +1418,7 @@\n   \"\"\n   \"\n {\n-  ms1_expand_eh_return (operands);\n+  mt_expand_eh_return (operands);\n   DONE;\n }\")\n \n@@ -1432,7 +1429,7 @@\n   \"#\"\n   \"reload_completed\"\n   [(const_int 1)]\n-  \"ms1_emit_eh_epilogue (operands); DONE;\"\n+  \"mt_emit_eh_epilogue (operands); DONE;\"\n )\n \f\n ;; No operation, needed in case the user uses -g but not -O.\n@@ -1479,8 +1476,8 @@\n   \"\"\n   \"\n {\n-  operands[2] = ms1_compare_op0;\n-  operands[3] = ms1_compare_op1;\n+  operands[2] = mt_compare_op0;\n+  operands[3] = mt_compare_op1;\n }\")\n \n ;; Templates to control handling of interrupts"}, {"sha": "83e93562b055430fad1a3b9124343b5839300897", "filename": "gcc/config/mt/mt.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fmt.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bccef6d862166e9c58e231ba7aff09b59781d70d/gcc%2Fconfig%2Fmt%2Fmt.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.opt?ref=bccef6d862166e9c58e231ba7aff09b59781d70d", "patch": "@@ -1,4 +1,4 @@\n-; Options for the ms1 port of the compiler\n+; Options for the mt port of the compiler\n ;\n ; Copyright (C) 2005 Free Software Foundation, Inc.\n ;\n@@ -52,5 +52,5 @@ Target RejectNegative Mask(DEBUG)\n Internal debug switch\n \n march=\n-Target RejectNegative Joined Var(ms1_cpu_string)\n+Target RejectNegative Joined Var(mt_cpu_string)\n Specify CPU for code generation purposes"}]}