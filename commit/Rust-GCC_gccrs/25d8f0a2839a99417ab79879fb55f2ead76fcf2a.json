{"sha": "25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVkOGYwYTI4MzlhOTk0MTdhYjc5ODc5ZmI1NWYyZWFkNzZmY2YyYQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2005-10-30T18:09:55Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2005-10-30T18:09:55Z"}, "message": "arith.c (gfc_enum_initializer): New function.\n\nfortran/\n2005-10-30  Gaurav Gautam  <gauravga@noida.hcltech.com>\n\t    Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n\n\t* arith.c (gfc_enum_initializer): New function.\n\t(gfc_check_integer_range): Made extern.\n\t* decl.c (enumerator_history): New typedef.\n\t(last_initializer, enum_history, max_enum): New variables.\n\t(create_enum_history, gfc_free_enum_history): New functions.\n\t(add_init_expr_to_sym): Call create_enum_history if parsing ENUM.\n\t(variable_decl): Modified to parse enumerator definition.\n\t(match_attr_spec): Add PARAMETER attribute to ENUMERATORs.\n\t(gfc_match_data_decl): Issues error, if match_type_spec do not\n\treturn desired return values.\n\t(set_enum_kind, gfc_match_enum, gfc_match_enumerator_def): New\n\tfunctions.\n\t(gfc_match_end): Deal with END ENUM.\n\t* gfortran.h (gfc_statement): ST_ENUM, ST_ENUMERATOR, ST_END_ENUM\n\tadded.\n\t(symbol_attribute): Bit field for enumerator added.\n\t(gfc_options): Add fshort_enums.\n\t(gfc_enum_initializer, gfc_check_integer_range): Add prototypes.\n\t* options.c: Include target.h\n\t(gfc_init_options): Initialize fshort_enums.\n\t(gfc_handle_option): Deal with fshort_enums.\n\t* parse.c (decode_statement): Match ENUM and ENUMERATOR statement.\n\t(gfc_ascii_statement): Deal with the enumerator statements.\n\t(parse_enum): New function to parse enum construct.\n\t(parse_spec): Added case ST_ENUM.\n\t* parse.h (gfc_compile_state): COMP_ENUM added.\n\t(gfc_match_enum, gfc_match_enumerator_def, gfc_free_enum_history):\n\tPrototype added.\n\t* symbol.c (gfc_copy_attr): Copy enumeration attribute.\n\t* lang.opt (fshort-enums): Option added.\n\ntestsuite/\n2005-10-30  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n\n\t* gfortran.dg/enum_10.f90, gfortran.dg/enum_10.c: New test.\n\n2005-10-30  Gaurav Gautam  <gauravga@noida.hcltech.com>\n\n\t* gfortran.dg/enum_1.f90, gfortran.dg/enum_2.f90,\n\tgfortran.dg/enum_3.f90, gfortran.dg/enum_4.f90,\n\tgfortran.dg/enum_5.f90, gfortran.dg/enum_6.f90,\n\tgfortran.dg/enum_7.f90, gfortran.dg/enum_8.f90,\n\tgfortran.dg/enum_9.f90,\n\tgfortran.fortran-torture/compile/enum_1.f90,\n\tgfortran.fortran-torture/execute/enum_1.f90,\n\tgfortran.fortran-torture/execute/enum_2.f90,\n\tgfortran.fortran-torture/execute/enum_3.f90,\n\tgfortran.fortran-torture/execute/enum_4.f90: New tests.\n\nFrom-SVN: r106246", "tree": {"sha": "3920d0fc1db1a9d875d55587afd2ffefff790a10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3920d0fc1db1a9d875d55587afd2ffefff790a10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8299ec258037fb73ee906633760ff1191bf05e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8299ec258037fb73ee906633760ff1191bf05e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8299ec258037fb73ee906633760ff1191bf05e1"}], "stats": {"total": 853, "additions": 849, "deletions": 4}, "files": [{"sha": "46795ed60a6d6aa0a2e7e945474de5b149e9e975", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -1,3 +1,37 @@\n+2005-10-30  Gaurav Gautam  <gauravga@noida.hcltech.com>\n+\t    Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* arith.c (gfc_enum_initializer): New function.\n+\t(gfc_check_integer_range): Made extern.\n+\t* decl.c (enumerator_history): New typedef.\n+\t(last_initializer, enum_history, max_enum): New variables.\n+\t(create_enum_history, gfc_free_enum_history): New functions.\n+\t(add_init_expr_to_sym): Call create_enum_history if parsing ENUM.\n+\t(variable_decl): Modified to parse enumerator definition.\n+\t(match_attr_spec): Add PARAMETER attribute to ENUMERATORs.\n+\t(gfc_match_data_decl): Issues error, if match_type_spec do not\n+\treturn desired return values.\n+\t(set_enum_kind, gfc_match_enum, gfc_match_enumerator_def): New\n+\tfunctions.\n+\t(gfc_match_end): Deal with END ENUM.\n+\t* gfortran.h (gfc_statement): ST_ENUM, ST_ENUMERATOR, ST_END_ENUM\n+\tadded.\n+\t(symbol_attribute): Bit field for enumerator added.\n+\t(gfc_options): Add fshort_enums.\n+\t(gfc_enum_initializer, gfc_check_integer_range): Add prototypes.\n+\t* options.c: Include target.h\n+\t(gfc_init_options): Initialize fshort_enums.\n+\t(gfc_handle_option): Deal with fshort_enums.\n+\t* parse.c (decode_statement): Match ENUM and ENUMERATOR statement.\n+\t(gfc_ascii_statement): Deal with the enumerator statements.\n+\t(parse_enum): New function to parse enum construct.\n+\t(parse_spec): Added case ST_ENUM.\n+\t* parse.h (gfc_compile_state): COMP_ENUM added.\n+\t(gfc_match_enum, gfc_match_enumerator_def, gfc_free_enum_history):\n+\tPrototype added.\n+\t* symbol.c (gfc_copy_attr): Copy enumeration attribute.\n+\t* lang.opt (fshort-enums): Option added.\n+\n 2005-10-30  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* check.c (gfc_check_malloc, gfc_check_free): New functions."}, {"sha": "aac3cb4f390fb434e4091f548b35d4c0831f2de8", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -339,7 +339,7 @@ gfc_arith_done_1 (void)\n    the range of the kind.  Returns ARITH_OK, ARITH_ASYMMETRIC or\n    ARITH_OVERFLOW.  */\n \n-static arith\n+arith\n gfc_check_integer_range (mpz_t p, int kind)\n {\n   arith result;\n@@ -2405,3 +2405,47 @@ gfc_hollerith2logical (gfc_expr * src, int kind)\n \n   return result;\n }\n+\n+/* Returns an initializer whose value is one higher than the value of the\n+   LAST_INITIALIZER argument.  If that is argument is NULL, the\n+   initializers value will be set to zero.  The initializer's kind\n+   will be set to gfc_c_int_kind.\n+\n+   If -fshort-enums is given, the appropriate kind will be selected\n+   later after all enumerators have been parsed.  A warning is issued\n+   here if an initializer exceeds gfc_c_int_kind.  */\n+\n+gfc_expr *\n+gfc_enum_initializer (gfc_expr *last_initializer, locus where)\n+{\n+  gfc_expr *result;\n+\n+  result = gfc_get_expr ();\n+  result->expr_type = EXPR_CONSTANT;\n+  result->ts.type = BT_INTEGER;\n+  result->ts.kind = gfc_c_int_kind;\n+  result->where = where;\n+\n+  mpz_init (result->value.integer);\n+\n+  if (last_initializer != NULL)\n+    {\n+      mpz_add_ui (result->value.integer, last_initializer->value.integer, 1);\n+      result->where = last_initializer->where;\n+\n+      if (gfc_check_integer_range (result->value.integer,\n+             gfc_c_int_kind) != ARITH_OK)\n+        {\n+          gfc_error (\"Enumerator exceeds the C integer type at %C\");\n+          return NULL;\n+        }\n+    }\n+  else\n+    {\n+      /* Control comes here, if it's the very first enumerator and no\n+         initializer has been given.  It will be initialized to ZERO (0). */\n+      mpz_set_si (result->value.integer, 0);\n+    }\n+\n+  return result;\n+}"}, {"sha": "7516057bfeecef96b99e3b6425557e2703c6cb70", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -43,6 +43,30 @@ static symbol_attribute current_attr;\n static gfc_array_spec *current_as;\n static int colon_seen;\n \n+/* Initializer of the previous enumerator.  */\n+\n+static gfc_expr *last_initializer;\n+\n+/* History of all the enumerators is maintained, so that\n+   kind values of all the enumerators could be updated depending\n+   upon the maximum initialized value.  */\n+\n+typedef struct enumerator_history\n+{\n+  gfc_symbol *sym;\n+  gfc_expr *initializer;\n+  struct enumerator_history *next;\n+}\n+enumerator_history;\n+\n+/* Header of enum history chain.  */\n+\n+static enumerator_history *enum_history = NULL;\n+\n+/* Pointer of enum history node containing largest initializer.  */\n+\n+static enumerator_history *max_enum = NULL;\n+\n /* gfc_new_block points to the symbol of a newly matched block.  */\n \n gfc_symbol *gfc_new_block;\n@@ -677,6 +701,63 @@ gfc_set_constant_character_len (int len, gfc_expr * expr)\n     }\n }\n \n+\n+/* Function to create and update the enumumerator history \n+   using the information passed as arguments.\n+   Pointer \"max_enum\" is also updated, to point to \n+   enum history node containing largest initializer.  \n+\n+   SYM points to the symbol node of enumerator.\n+   INIT points to its enumerator value.   */\n+\n+static void \n+create_enum_history(gfc_symbol *sym, gfc_expr *init)\n+{\n+  enumerator_history *new_enum_history;\n+  gcc_assert (sym != NULL && init != NULL);\n+\n+  new_enum_history = gfc_getmem (sizeof (enumerator_history));\n+\n+  new_enum_history->sym = sym;\n+  new_enum_history->initializer = init;\n+  new_enum_history->next = NULL;\n+\n+  if (enum_history == NULL)\n+    {\n+      enum_history = new_enum_history;\n+      max_enum = enum_history;\n+    }\n+  else\n+    {\n+      new_enum_history->next = enum_history;\n+      enum_history = new_enum_history;\n+\n+      if (mpz_cmp (max_enum->initializer->value.integer, \n+\t\t   new_enum_history->initializer->value.integer) < 0)\n+        max_enum = new_enum_history;\n+    }\n+}\n+\n+\n+/* Function to free enum kind history.  */ \n+\n+void \n+gfc_free_enum_history(void)\n+{\n+  enumerator_history *current = enum_history;  \n+  enumerator_history *next;  \n+\n+  while (current != NULL)\n+    {\n+      next = current->next;\n+      gfc_free (current);\n+      current = next;\n+    }\n+  max_enum = NULL;\n+  enum_history = NULL;\n+}\n+\n+\n /* Function called by variable_decl() that adds an initialization\n    expression to a symbol.  */\n \n@@ -785,6 +866,10 @@ add_init_expr_to_sym (const char *name, gfc_expr ** initp,\n       *initp = NULL;\n     }\n \n+  /* Maintain enumerator history.  */\n+  if (gfc_current_state () == COMP_ENUM)\n+    create_enum_history (sym, init);\n+\n   return SUCCESS;\n }\n \n@@ -918,10 +1003,12 @@ variable_decl (int elem)\n   match m;\n   try t;\n   gfc_symbol *sym;\n+  locus old_locus;\n \n   initializer = NULL;\n   as = NULL;\n   cp_as = NULL;\n+  old_locus = gfc_current_locus;\n \n   /* When we get here, we've just matched a list of attributes and\n      maybe a type and a double colon.  The next thing we expect to see\n@@ -938,8 +1025,17 @@ variable_decl (int elem)\n     cp_as = gfc_copy_array_spec (as);\n   else if (m == MATCH_ERROR)\n     goto cleanup;\n+\n   if (m == MATCH_NO)\n     as = gfc_copy_array_spec (current_as);\n+  else if (gfc_current_state () == COMP_ENUM)\n+    {\n+      gfc_error (\"Enumerator cannot be array at %C\");\n+      gfc_free_enum_history ();\n+      m = MATCH_ERROR;\n+      goto cleanup;\n+    }\n+\n \n   char_len = NULL;\n   cl = NULL;\n@@ -1135,6 +1231,30 @@ variable_decl (int elem)\n \t}\n     }\n \n+  /* Check if we are parsing an enumeration and if the current enumerator\n+     variable has an initializer or not. If it does not have an\n+     initializer, the initialization value of the previous enumerator \n+     (stored in last_initializer) is incremented by 1 and is used to\n+     initialize the current enumerator.  */\n+  if (gfc_current_state () == COMP_ENUM)\n+    {\n+      if (initializer == NULL)\n+        initializer = gfc_enum_initializer (last_initializer, old_locus);\n+ \n+      if (initializer == NULL || initializer->ts.type != BT_INTEGER)\n+        {\n+          gfc_error(\"ENUMERATOR %L not initialized with integer expression\",\n+\t\t    &var_locus);\n+          m = MATCH_ERROR; \n+          gfc_free_enum_history ();\n+          goto cleanup;\n+        }\n+\n+      /* Store this current initializer, for the next enumerator\n+\t variable to be parsed.  */\n+      last_initializer = initializer;\n+    }\n+\n   /* Add the initializer.  Note that it is fine if initializer is\n      NULL here, because we sometimes also need to check if a\n      declaration *must* have an initialization expression.  */\n@@ -1837,6 +1957,12 @@ match_attr_spec (void)\n       d = (decl_types) gfc_match_strings (decls);\n       if (d == DECL_NONE || d == DECL_COLON)\n \tbreak;\n+       \n+      if (gfc_current_state () == COMP_ENUM)\n+        {\n+          gfc_error (\"Enumerator cannot have attributes %C\");\n+          return MATCH_ERROR;\n+        }\n \n       seen[d]++;\n       seen_at[d] = gfc_current_locus;\n@@ -1856,6 +1982,18 @@ match_attr_spec (void)\n \t}\n     }\n \n+  /* If we are parsing an enumeration and have enusured that no other\n+     attributes are present we can now set the parameter attribute.  */\n+  if (gfc_current_state () == COMP_ENUM)\n+    {\n+      t = gfc_add_flavor (&current_attr, FL_PARAMETER, NULL, NULL);\n+      if (t == FAILURE)\n+        {\n+          m = MATCH_ERROR;\n+          goto cleanup;\n+        }\n+    }\n+\n   /* No double colon, so assume that we've been looking at something\n      else the whole time.  */\n   if (d == DECL_NONE)\n@@ -2678,6 +2816,40 @@ contained_procedure (void)\n   return 0;\n }\n \n+/* Set the kind of each enumerator.  The kind is selected such that it is \n+   interoperable with the corresponding C enumeration type, making\n+   sure that -fshort-enums is honored.  */\n+\n+static void\n+set_enum_kind(void)\n+{\n+  enumerator_history *current_history = NULL;\n+  int kind;\n+  int i;\n+\n+  if (max_enum == NULL || enum_history == NULL)\n+    return;\n+\n+  if (!gfc_option.fshort_enums)\n+    return; \n+  \n+  i = 0;\n+  do\n+    {\n+      kind = gfc_integer_kinds[i++].kind;\n+    }\n+  while (kind < gfc_c_int_kind \n+\t && gfc_check_integer_range (max_enum->initializer->value.integer,\n+\t\t\t\t     kind) != ARITH_OK);\n+\n+  current_history = enum_history;\n+  while (current_history != NULL)\n+    {\n+      current_history->sym->ts.kind = kind;\n+      current_history = current_history->next;\n+    }\n+}\n+\n /* Match any of the various end-block statements.  Returns the type of\n    END to the caller.  The END INTERFACE, END IF, END DO and END\n    SELECT statements cannot be replaced by a single END statement.  */\n@@ -2783,6 +2955,15 @@ gfc_match_end (gfc_statement * st)\n       eos_ok = 0;\n       break;\n \n+    case COMP_ENUM:\n+      *st = ST_END_ENUM;\n+      target = \" enum\";\n+      eos_ok = 0;\n+      last_initializer = NULL;\n+      set_enum_kind ();\n+      gfc_free_enum_history ();\n+      break;\n+\n     default:\n       gfc_error (\"Unexpected END statement at %C\");\n       goto cleanup;\n@@ -3742,3 +3923,87 @@ gfc_mod_pointee_as (gfc_array_spec *as)\n     }\n   return MATCH_YES;\n }\n+\n+\n+/* Match the enum definition statement, here we are trying to match \n+   the first line of enum definition statement.  \n+   Returns MATCH_YES if match is found.  */\n+\n+match\n+gfc_match_enum (void)\n+{\n+  match m;\n+  \n+  m = gfc_match_eos ();\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  if (gfc_notify_std (GFC_STD_F2003, \n+\t\t      \"New in Fortran 2003: ENUM AND ENUMERATOR at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  return MATCH_YES;\n+}\n+\n+\n+/* Match the enumerator definition statement. */\n+\n+match\n+gfc_match_enumerator_def (void)\n+{\n+  match m;\n+  int elem; \n+  \n+  gfc_clear_ts (&current_ts);\n+  \n+  m = gfc_match (\" enumerator\");\n+  if (m != MATCH_YES)\n+    return m;\n+  \n+  if (gfc_current_state () != COMP_ENUM)\n+    {\n+      gfc_error (\"ENUM definition statement expected before %C\");\n+      gfc_free_enum_history ();\n+      return MATCH_ERROR;\n+    }\n+\n+  (&current_ts)->type = BT_INTEGER;\n+  (&current_ts)->kind = gfc_c_int_kind;\n+  \n+  m = match_attr_spec ();\n+  if (m == MATCH_ERROR)\n+    {\n+      m = MATCH_NO;\n+      goto cleanup;\n+    }\n+\n+  elem = 1;\n+  for (;;)\n+    {\n+      m = variable_decl (elem++);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_NO)\n+\tbreak;\n+\n+      if (gfc_match_eos () == MATCH_YES)\n+\tgoto cleanup;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tbreak;\n+    }\n+\n+  if (gfc_current_state () == COMP_ENUM)\n+    {\n+      gfc_free_enum_history ();\n+      gfc_error (\"Syntax error in ENUMERATOR definition at %C\");\n+      m = MATCH_ERROR;\n+    }\n+\n+cleanup:\n+  gfc_free_array_spec (current_as);\n+  current_as = NULL;\n+  return m;\n+\n+}\n+"}, {"sha": "8068b10d35fb3f80787c55be24175b5da0434b7b", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -756,7 +756,9 @@ show_symtree (gfc_symtree * st)\n   gfc_status (\"symtree: %s  Ambig %d\", st->name, st->ambiguous);\n \n   if (st->n.sym->ns != gfc_current_ns)\n-    gfc_status (\" from namespace %s\", st->n.sym->ns->proc_name->name);\n+    /* Do nothing\n+       gfc_status (\" from namespace %s\", st->n.sym->ns->proc_name->name); */\n+    ;\n   else\n     gfc_show_symbol (st->n.sym);\n }"}, {"sha": "083fc33f14714220ebe515049684dfee866d81b8", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -214,7 +214,7 @@ typedef enum\n   ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WRITE,\n   ST_ASSIGNMENT, ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE,\n   ST_SIMPLE_IF, ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT,\n-  ST_NONE\n+  ST_ENUM, ST_ENUMERATOR, ST_END_ENUM, ST_NONE\n }\n gfc_statement;\n \n@@ -1484,6 +1484,7 @@ typedef struct\n   int warn_std;\n   int allow_std;\n   int warn_nonstd_intrinsics;\n+  int fshort_enums;\n }\n gfc_option_t;\n \n@@ -1626,6 +1627,8 @@ void gfc_get_errors (int *, int *);\n /* arith.c */\n void gfc_arith_init_1 (void);\n void gfc_arith_done_1 (void);\n+gfc_expr *gfc_enum_initializer (gfc_expr *, locus);\n+arith gfc_check_integer_range (mpz_t p, int kind);\n \n /* trans-types.c */\n int gfc_validate_kind (bt, int, bool);"}, {"sha": "66f79db3bee28d2e59ade0f1602c4e4f683a1015", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -189,4 +189,8 @@ std=legacy\n Fortran\n Accept extensions to support legacy code\n \n+fshort-enums\n+Fortran\n+Use the narrowest integer type possible for enumeration types\n+\n ; This comment is to ensure we retain the blank line above."}, {"sha": "ebce409ba94d3d923ba547b55c0575bfee92becc", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -32,6 +32,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-inline.h\"\n \n #include \"gfortran.h\"\n+#include \"target.h\"\n \n gfc_option_t gfc_option;\n \n@@ -90,6 +91,9 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n \n   gfc_option.warn_nonstd_intrinsics = 0;\n \n+  /* -fshort-enums can be default on some targets.  */\n+  gfc_option.fshort_enums = targetm.default_short_enums ();\n+\n   return CL_Fortran;\n }\n \n@@ -517,6 +521,10 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n     case OPT_Wnonstd_intrinsics:\n       gfc_option.warn_nonstd_intrinsics = 1;\n       break;\n+\n+    case OPT_fshort_enums:\n+      gfc_option.fshort_enums = 1;\n+      break;\n     }\n \n   return result;"}, {"sha": "430d8f3761c83ccac87d1961d05ec61ccae56c68", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -132,6 +132,7 @@ decode_statement (void)\n   match (NULL, gfc_match_st_function, ST_STATEMENT_FUNCTION);\n \n   match (NULL, gfc_match_data_decl, ST_DATA_DECL);\n+  match (NULL, gfc_match_enumerator_def, ST_ENUMERATOR);\n \n   /* Try to match a subroutine statement, which has the same optional\n      prefixes that functions can have.  */\n@@ -205,6 +206,7 @@ decode_statement (void)\n       match (\"else\", gfc_match_else, ST_ELSE);\n       match (\"else where\", gfc_match_elsewhere, ST_ELSEWHERE);\n       match (\"else if\", gfc_match_elseif, ST_ELSEIF);\n+      match (\"enum , bind ( c )\", gfc_match_enum, ST_ENUM);\n \n       if (gfc_match_end (&st) == MATCH_YES)\n \treturn st;\n@@ -951,6 +953,15 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_LABEL_ASSIGNMENT:\n       p = \"LABEL ASSIGNMENT\";\n       break;\n+    case ST_ENUM:\n+      p = \"ENUM DEFINITION\";\n+      break;\n+    case ST_ENUMERATOR:\n+      p = \"ENUMERATOR DEFINITION\";\n+      break;\n+    case ST_END_ENUM:\n+      p = \"END ENUM\";\n+      break;\n     default:\n       gfc_internal_error (\"gfc_ascii_statement(): Bad statement code\");\n     }\n@@ -1335,6 +1346,56 @@ parse_derived (void)\n \n \n \n+/* Parse an ENUM.  */\n+ \n+static void\n+parse_enum (void)\n+{\n+  int error_flag;\n+  gfc_statement st;\n+  int compiling_enum;\n+  gfc_state_data s;\n+  int seen_enumerator = 0;\n+\n+  error_flag = 0;\n+\n+  push_state (&s, COMP_ENUM, gfc_new_block);\n+\n+  compiling_enum = 1;\n+\n+  while (compiling_enum)\n+    {\n+      st = next_statement ();\n+      switch (st)\n+        {\n+        case ST_NONE:\n+          unexpected_eof ();\n+          break;\n+\n+        case ST_ENUMERATOR:\n+\t  seen_enumerator = 1;\n+          accept_statement (st);\n+          break;\n+\n+        case ST_END_ENUM:\n+          compiling_enum = 0;\n+\t  if (!seen_enumerator)\n+            {\n+              gfc_error (\"ENUM declaration at %C has no ENUMERATORS\");\n+\t      error_flag = 1;\n+            }\n+          accept_statement (st);\n+          break;\n+\n+        default:\n+          gfc_free_enum_history ();\n+          unexpected_statement (st);\n+          break;\n+        }\n+    }\n+  pop_state ();\n+}\n+\n /* Parse an interface.  We must be able to deal with the possibility\n    of recursive interfaces.  The parse_spec() subroutine is mutually\n    recursive with parse_interface().  */\n@@ -1540,6 +1601,12 @@ parse_spec (gfc_statement st)\n       st = next_statement ();\n       goto loop;\n \n+    case ST_ENUM:\n+      accept_statement (st);\n+      parse_enum();\n+      st = next_statement ();\n+      goto loop;\n+\n     default:\n       break;\n     }"}, {"sha": "193e11506743a3295e0a4875688c9a5fce41afeb", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -30,7 +30,7 @@ typedef enum\n {\n   COMP_NONE, COMP_PROGRAM, COMP_MODULE, COMP_SUBROUTINE, COMP_FUNCTION,\n   COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_IF, COMP_DO,\n-  COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS\n+  COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM\n }\n gfc_compile_state;\n \n@@ -63,5 +63,8 @@ int gfc_check_do_variable (gfc_symtree *);\n try gfc_find_state (gfc_compile_state);\n gfc_state_data *gfc_enclosing_unit (gfc_compile_state *);\n const char *gfc_ascii_statement (gfc_statement);\n+match gfc_match_enum (void);\n+match gfc_match_enumerator_def (void);\n+void gfc_free_enum_history (void);\n \n #endif  /* GFC_PARSE_H  */"}, {"sha": "09b9ada1629b5ea631575aabc7b523dd8630460b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -1,3 +1,20 @@\n+2005-10-30  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* gfortran.dg/enum_10.f90, gfortran.dg/enum_10.c: New test.\n+\n+2005-10-30  Gaurav Gautam  <gauravga@noida.hcltech.com>\n+\n+\t* gfortran.dg/enum_1.f90, gfortran.dg/enum_2.f90,\n+\tgfortran.dg/enum_3.f90, gfortran.dg/enum_4.f90,\n+\tgfortran.dg/enum_5.f90, gfortran.dg/enum_6.f90,\n+\tgfortran.dg/enum_7.f90, gfortran.dg/enum_8.f90,\n+\tgfortran.dg/enum_9.f90,\n+\tgfortran.fortran-torture/compile/enum_1.f90,\n+\tgfortran.fortran-torture/execute/enum_1.f90,\n+\tgfortran.fortran-torture/execute/enum_2.f90,\n+\tgfortran.fortran-torture/execute/enum_3.f90,\n+\tgfortran.fortran-torture/execute/enum_4.f90: New tests.\n+\n 2005-10-30  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \tPR target/18482"}, {"sha": "1af5ab82f8169c6aa11c6966f976f96d28801522", "filename": "gcc/testsuite/gfortran.dg/enum_1.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_1.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do run }\n+! Program to test ENUM parsing \n+\n+program main\n+  implicit none\n+  enum, bind (c)  ! { dg-warning \"New in Fortran 2003\" }\n+    enumerator :: red, black\n+    enumerator blue\n+  end enum\n+  if (red /= 0) call abort\n+end program main"}, {"sha": "28beb12f821abb85a0c9732f1ddc31e5d895f2d0", "filename": "gcc/testsuite/gfortran.dg/enum_10.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_10.c?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,27 @@\n+/* This testcase is meant to be compiled together with enum_10.f90  */\n+\n+extern void abort (void);\n+\n+typedef enum\n+  { MAX1 = 127 } onebyte;\n+\n+void f1_ (onebyte *i, int *j)\n+{\n+  if (*i != *j) abort ();\n+}\n+\n+typedef enum\n+  { MAX2 = 32767 } twobyte;\n+\n+void f2_ (twobyte *i, int *j)\n+{\n+  if (*i != *j) abort ();\n+}\n+\n+typedef enum\n+  { MAX4 = 2000000 } fourbyte; /* don't need the precise value. */\n+\n+void f4_ (fourbyte *i, int *j)\n+{\n+  if (*i != *j) abort ();\n+}"}, {"sha": "c3fbe535c4ffb9843fd6b65affedc806bf3ee0f3", "filename": "gcc/testsuite/gfortran.dg/enum_10.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_10.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do run }\n+! { dg-additional-sources enum_10.c }\n+! { dg-options \"-fshort-enums\" }\n+! Make sure short enums are indeed interoperable with the\n+! corresponding C type.\n+\n+module enum_10\n+enum, bind( c )   ! { dg-warning \"New in Fortran 2003\" }\n+   enumerator :: one1 = 1, two1, max1 = huge(1_1)\n+end enum\n+\n+enum, bind( c )   ! { dg-warning \"New in Fortran 2003\" }\n+   enumerator :: one2 = 1, two2, max2 = huge(1_2)\n+end enum\n+\n+enum, bind( c )   ! { dg-warning \"New in Fortran 2003\" }\n+   enumerator :: one4 = 1, two4, max4 = huge(1_4)\n+end enum\n+end module enum_10\n+\n+use enum_10\n+\n+interface f1\n+  subroutine f1(i,j)\n+    use enum_10\n+    integer (kind(max1)) :: i\n+    integer :: j\n+  end subroutine f1\n+end interface\n+\n+\n+interface f2\n+  subroutine f2(i,j)\n+    use enum_10\n+    integer (kind(max2)) :: i\n+    integer :: j\n+  end subroutine f2\n+end interface\n+\n+\n+interface f4\n+  subroutine f4(i,j)\n+    use enum_10\n+    integer (kind(max4)) :: i\n+    integer :: j\n+  end subroutine f4\n+end interface\n+\n+\n+call f1 (one1, 1)\n+call f1 (two1, 2)\n+call f1 (max1, huge(1_1)+0) ! Adding 0 to get default integer\n+\n+call f2 (one2, 1)\n+call f2 (two2, 2)\n+call f2 (max2, huge(1_2)+0)\n+\n+call f4 (one4, 1)\n+call f4 (two4, 2)\n+call f4 (max4, huge(1_4)+0)\n+end"}, {"sha": "1fd72474dd3cf3afe14130fb444ee7abc9def1d0", "filename": "gcc/testsuite/gfortran.dg/enum_2.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_2.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! Program to test ENUM parsing errors \n+\n+program main\n+  implicit none\n+  enum, bind (c)  ! { dg-warning \"New in Fortran 2003\" }\n+    enumerator :: red, black\n+    integer :: x  ! { dg-error \"Unexpected data declaration\" }\n+    enumerator blue = 1  ! { dg-error \"Syntax error in ENUMERATOR definition\" }\n+  end enum\n+\n+  enumerator :: sun  ! { dg-error \"ENUM\" }\n+end program main"}, {"sha": "3b01f93de311073819eaa1d51400a61c253b92fa", "filename": "gcc/testsuite/gfortran.dg/enum_3.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_3.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+! Program to test ENUM parsing errors \n+\n+program main\n+  implicit none\n+  enum, bind (c)  ! { dg-warning \"New in Fortran 2003\" } \n+    enumerator :: red, black = 2.2  ! { dg-error \"initialized with integer expression\" }\n+    enumerator :: blue = \"x\"  ! { dg-error \"initialized with integer expression\" }\n+  end enum  ! { dg-error \"has no ENUMERATORS\" }\n+\n+end program main"}, {"sha": "e3b13d7e73e3f23eaf779b9b7aaa05fc5e8183ab", "filename": "gcc/testsuite/gfortran.dg/enum_4.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_4.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+! Program to test ENUM parsing errors \n+\n+program main\n+  implicit none\n+  enum, bind (c)  ! { dg-warning \"New in Fortran 2003\" } \n+    enumerator :: red, black = 2     \n+    enumerator :: blue = 1, red  ! { dg-error \"already\" }\n+  end enum\n+\n+  enum, bind (c)  ! { dg-warning \"New in Fortran 2003\" } \n+    enumerator :: r, b(10) = 2  ! { dg-error \"cannot be array\" }\n+    enumerator , save :: g = 1  ! { dg-error \"cannot have attributes\" }  \n+  end  ! { dg-error \" END ENUM\" } \n+\n+end program main  ! { dg-excess-errors \"\" }"}, {"sha": "a095cfe1bf35a9ae6a1848f1a7bd4f66dbdd82d0", "filename": "gcc/testsuite/gfortran.dg/enum_5.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_5.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! Program to test ENUM parsing errors \n+\n+program main\n+  implicit none\n+  integer :: i = 1\n+\n+  enum, bind (c)  ! { dg-warning \"New in Fortran 2003\" } \n+    enumerator :: red, black = i  ! { dg-error \"cannot appear\" }\n+    enumerator :: blue = 1  \n+  end enum junk  ! { dg-error \"Syntax error\" }\n+\n+  blue = 10  ! { dg-error \"Expected VARIABLE\" }\n+\n+end program main  ! { dg-excess-errors \"\" }"}, {"sha": "0396862684f8340c24cd7043534ea0cd78b41abf", "filename": "gcc/testsuite/gfortran.dg/enum_6.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_6.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! Program to test ENUM parsing errors \n+\n+program main\n+  implicit none\n+  integer :: i = 1\n+\n+  enum, bind (c)  ! { dg-warning \"New in Fortran 2003\" } \n+    enumerator :: sun, mon = 2    \n+    i = 2  ! { dg-error \"Unexpected\" }  \n+    enumerator :: wed = 1    \n+  end enum       \n+\n+  i = 1\n+\n+  enum, bind (c)  ! { dg-error \"Unexpected\" } \n+    enumerator :: red, black = 2  ! { dg-error \"ENUM definition statement expected\" }\n+    enumerator :: blue = 1  ! { dg-error \"ENUM definition statement expected\" }\n+  end enum  ! { dg-excess-errors \"Expecting END PROGRAM\" }\n+\n+end program main        "}, {"sha": "d85e61d62f84fb6f5649d8eef8522eac7a53d3d8", "filename": "gcc/testsuite/gfortran.dg/enum_7.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_7.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! Program to test ENUM parsing errors \n+\n+program main\n+  implicit none\n+\n+  enum, bind (c)  ! { dg-warning \"New in Fortran 2003\" } \n+    enumerator :: sun, mon = 2    \n+    enum, bind (c)  ! { dg-error \"Unexpected\" }\n+      enumerator :: apple, mango\n+    end enum  \n+    enumerator :: wed = 1  ! { dg-error \"ENUM definition statement expected\" }  \n+  end enum  ! { dg-error \"Expecting END PROGRAM\" }  \n+\n+end program main        "}, {"sha": "686b12880c404ae63517fec17aa6dc200b96ab39", "filename": "gcc/testsuite/gfortran.dg/enum_8.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_8.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! Program to test the initialisation range of enumerators \n+! and kind values check\n+\n+program main\n+  implicit none\n+  enum, bind (c)  ! { dg-warning \"New in Fortran 2003\" }\n+    enumerator :: pp , qq = 4294967295, rr  ! { dg-error \"not initialized with integer\" }\n+  end enum  ! { dg-error \"has no ENUMERATORS\" }\n+\n+  enum, bind (c)  ! { dg-warning \"New in Fortran 2003\" }\n+    enumerator :: p , q = 4294967299_8, r  ! { dg-error \"Arithmetic overflow\" }\n+  end enum  ! { dg-error \"has no ENUMERATORS\" }\n+\n+end program main"}, {"sha": "81c441aca2c667f8d541c523a0e0fcab2784b4ec", "filename": "gcc/testsuite/gfortran.dg/enum_9.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_9.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! { dg-options \"-fshort-enums\" }\n+! Program to test enumerations when option -fshort-enums is given\n+\n+program main\n+  implicit none\n+  enum, bind (c)  ! { dg-warning \"New in Fortran 2003\" }\n+    enumerator :: red, black = 127\n+    enumerator blue\n+  end enum\n+  if (red /= 0) call abort\n+  if (black /= 127) call abort\n+  if (blue /= 128) call abort\n+end program main"}, {"sha": "7a6b424030cfa5a090a9b67d8184db8c4cfff9c8", "filename": "gcc/testsuite/gfortran.fortran-torture/compile/enum_1.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fenum_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fenum_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fenum_1.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,46 @@\n+! Program to test parsing of ENUM in different program units\n+\n+program main\n+  implicit none\n+  interface \n+    subroutine sub1\n+    end subroutine sub1\n+  end interface\n+  integer :: i = 55\n+\n+  enum , bind (c)\n+    enumerator :: a , b=5\n+    enumerator c, d\n+  end enum\n+\n+  call sub\n+  call sub1\n+  i = fun() \n+\n+contains\n+\n+  subroutine sub\n+    enum, bind(c)\n+      enumerator :: p = b, q = 10 + 50\n+      enumerator r, s\n+    end enum\n+  end subroutine sub\n+\n+  function fun()\n+  integer :: fun\n+  enum, bind (c)\n+    enumerator :: red, yellow = 23\n+    enumerator :: blue \n+    enumerator :: green\n+  end enum\n+  fun = 1\n+  end function fun\n+end program main\n+\n+subroutine sub1\n+  implicit none\n+  enum, bind(c)  \n+    enumerator x , y\n+    enumerator :: z = 100\n+  end enum\n+end subroutine sub1"}, {"sha": "838b70c38db61a7f0ca36207c20ba5bce21ff138", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/enum_1.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_1.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,28 @@\n+! Program to test the default initialisation of enumerators \n+\n+program main\n+  implicit none\n+\n+  enum, bind (c)\n+    enumerator :: red , yellow, blue\n+    enumerator :: green\n+  end enum\n+\n+  enum, bind (c)\n+    enumerator :: a , b , c = 10\n+    enumerator :: d\n+  end enum\n+\n+\n+  if (red /= 0 ) call abort\n+  if (yellow /= 1) call abort\n+  if (blue /= 2) call abort\n+  if (green /= 3) call abort\n+\n+  if (a /= 0 ) call abort\n+  if (b /= 1) call abort\n+  if (c /= 10) call abort\n+  if (d /= 11) call abort\n+\n+  \n+end program main"}, {"sha": "d0acf6595c8abc2bd1e9e050201271c0b47f3b38", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/enum_2.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_2.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,29 @@\n+! Program to test the incremental assignment of enumerators\n+\n+program main\n+  implicit none\n+\n+  enum, bind (c)\n+    enumerator :: red = 4 , yellow, blue\n+    enumerator  green \n+  end enum\n+\n+  enum, bind (c)\n+    enumerator :: sun = -10 , mon, tue\n+    enumerator :: wed = 10, sat\n+  end enum\n+\n+\n+  if (red /= 4 ) call abort\n+  if (yellow /= (red + 1)) call abort\n+  if (blue /= (yellow + 1)) call abort\n+  if (green /= (blue + 1)) call abort\n+  \n+\n+  if (sun /= -10 ) call abort\n+  if (mon /= (sun + 1)) call abort\n+  if (tue /= (mon + 1)) call abort\n+  if (wed /= 10) call abort\n+  if (sat /= (wed+1)) call abort\n+\n+end program main"}, {"sha": "71ab35d118b4f381ed493d3133c2577fc776577d", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/enum_3.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_3.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,57 @@\n+! Program to test the initialisation range of enumerators \n+! and kind values check\n+\n+program main\n+  implicit none\n+\n+  enum, bind (c)\n+    enumerator :: red , yellow =255 , blue \n+  end enum\n+\n+  enum, bind (c)\n+    enumerator :: r , y = 32767, b\n+  end enum\n+\n+  enum, bind (c)\n+    enumerator :: aa , bb = 65535, cc\n+  end enum\n+\n+  enum, bind (c)\n+    enumerator :: m , n = 2147483645, o\n+  end enum\n+\n+\n+ if (red /= 0 ) call abort\n+ if (yellow /= 255) call abort\n+ if (blue /= 256) call abort\n+  \n+ if (r /= 0 ) call abort\n+ if (y /= 32767) call abort\n+ if (b /= 32768) call abort\n+\n+ if (kind (red) /= 4) call abort\n+ if (kind (yellow) /= 4) call abort\n+ if (kind (blue) /= 4) call abort\n+\n+ if (kind(r) /= 4 ) call abort\n+ if (kind(y) /= 4) call abort\n+ if (kind(b) /= 4) call abort\n+\n+ if (aa /= 0 ) call abort\n+ if (bb /= 65535) call abort\n+ if (cc /= 65536) call abort\n+\n+ if (kind (aa) /= 4 ) call abort\n+ if (kind (bb) /= 4) call abort\n+ if (kind (cc) /= 4) call abort\n+\n+\n+ if (m /= 0 ) call abort\n+ if (n /= 2147483645) call abort\n+ if (o /= 2147483646) call abort\n+\n+ if (kind (m) /= 4 ) call abort\n+ if (kind (n) /= 4) call abort\n+ if (kind (o) /= 4) call abort\n+\n+end program main"}, {"sha": "ff329dc7d4146c9e1c51202b156ad4d7a7117ca3", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/enum_4.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d8f0a2839a99417ab79879fb55f2ead76fcf2a/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fenum_4.f90?ref=25d8f0a2839a99417ab79879fb55f2ead76fcf2a", "patch": "@@ -0,0 +1,19 @@\n+! Program to test the default initialisation of enumerators inside different program unit\n+\n+module mod\n+  implicit none\n+  enum, bind (c)\n+    enumerator :: red , yellow, blue\n+    enumerator :: green\n+  end enum\n+end module mod\n+\n+program main\n+  use mod\n+  implicit none\n+\n+  if (red /= 0 ) call abort\n+  if (yellow /= 1) call abort\n+  if (blue /= 2) call abort\n+  if (green /= 3) call abort\n+end program main"}]}