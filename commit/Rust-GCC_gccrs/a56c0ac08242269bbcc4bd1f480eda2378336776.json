{"sha": "a56c0ac08242269bbcc4bd1f480eda2378336776", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU2YzBhYzA4MjQyMjY5YmJjYzRiZDFmNDgwZWRhMjM3ODMzNjc3Ng==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-02-09T20:55:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-02-09T20:55:54Z"}, "message": "PR c++/79316 - default argument in deduction guide\n\n\tPR c++/79350 - explicit deduction guide\n\t* parser.c (cp_parser_constructor_declarator_p)\n\t(cp_parser_direct_declarator): Parse deduction guides more like\n\tconstructors.\n\t* cp-tree.h (enum special_function_kind): Add sfk_deduction_guide.\n\t* tree.c (special_function_p): Return it.\n\t* decl.c (check_special_function_return_type): Handle it.\n\t(grokdeclarator, grokfndecl): Adjust.\n\t(cp_finish_decl): Pass flags to do_auto_deduction.\n\t* error.c (dump_decl_name): Use TFF_UNQUALIFIED_NAME.\n\t* pt.c (dguide_name_p): Take a const_tree.\n\t(do_class_deduction): Handle explicit.\n\t(do_auto_deduction): Pass flags through.\n\t(build_deduction_guide): Copy explicit flag.\n\nFrom-SVN: r245314", "tree": {"sha": "fdb30ba42b1dd45219d4eab973e41db807ec03b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdb30ba42b1dd45219d4eab973e41db807ec03b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a56c0ac08242269bbcc4bd1f480eda2378336776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56c0ac08242269bbcc4bd1f480eda2378336776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a56c0ac08242269bbcc4bd1f480eda2378336776", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56c0ac08242269bbcc4bd1f480eda2378336776/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "388dde26a5b5a6740018340953955eb05abba817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/388dde26a5b5a6740018340953955eb05abba817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/388dde26a5b5a6740018340953955eb05abba817"}], "stats": {"total": 257, "additions": 191, "deletions": 66}, "files": [{"sha": "caa1df91383302646323967fd3d234ab9d0ff078", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a56c0ac08242269bbcc4bd1f480eda2378336776", "patch": "@@ -1,3 +1,21 @@\n+2017-02-09  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/79316 - default argument in deduction guide\n+\tPR c++/79350 - explicit deduction guide\n+\t* parser.c (cp_parser_constructor_declarator_p)\n+\t(cp_parser_direct_declarator): Parse deduction guides more like\n+\tconstructors.\n+\t* cp-tree.h (enum special_function_kind): Add sfk_deduction_guide.\n+\t* tree.c (special_function_p): Return it.\n+\t* decl.c (check_special_function_return_type): Handle it.\n+\t(grokdeclarator, grokfndecl): Adjust.\n+\t(cp_finish_decl): Pass flags to do_auto_deduction.\n+\t* error.c (dump_decl_name): Use TFF_UNQUALIFIED_NAME.\n+\t* pt.c (dguide_name_p): Take a const_tree.\n+\t(do_class_deduction): Handle explicit.\n+\t(do_auto_deduction): Pass flags through.\n+\t(build_deduction_guide): Copy explicit flag.\n+\n 2017-02-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/79429"}, {"sha": "a4109261d4892c7d08718887be6f909c4b06e9b8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a56c0ac08242269bbcc4bd1f480eda2378336776", "patch": "@@ -4733,6 +4733,7 @@ enum special_function_kind {\n \t\t\t      deletes the object after it has been\n \t\t\t      destroyed.  */\n   sfk_conversion,\t   /* A conversion operator.  */\n+  sfk_deduction_guide,\t   /* A class template deduction guide.  */\n   sfk_inheriting_constructor /* An inheriting constructor */\n };\n \n@@ -6150,7 +6151,8 @@ extern tree do_auto_deduction                   (tree, tree, tree);\n extern tree do_auto_deduction                   (tree, tree, tree,\n                                                  tsubst_flags_t,\n                                                  auto_deduction_context,\n-\t\t\t\t\t\t tree = NULL_TREE);\n+\t\t\t\t\t\t tree = NULL_TREE,\n+\t\t\t\t\t\t int = LOOKUP_NORMAL);\n extern tree type_uses_auto\t\t\t(tree);\n extern tree type_uses_auto_or_concept\t\t(tree);\n extern void append_type_to_template_for_access_check (tree, tree, tree,\n@@ -6280,7 +6282,7 @@ extern tree extract_fnparm_pack                 (tree, tree *);\n extern tree template_parm_to_arg                (tree);\n extern tree dguide_name\t\t\t\t(tree);\n extern bool dguide_name_p\t\t\t(tree);\n-extern bool deduction_guide_p\t\t\t(tree);\n+extern bool deduction_guide_p\t\t\t(const_tree);\n \n /* in repo.c */\n extern void init_repo\t\t\t\t(void);"}, {"sha": "734a6c751d0cecdeb18f3c96e40fc64cb8f9b287", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a56c0ac08242269bbcc4bd1f480eda2378336776", "patch": "@@ -6821,7 +6821,8 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n       if (VAR_P (decl) && DECL_DECOMPOSITION_P (decl))\n \tadc = adc_decomp_type;\n       type = TREE_TYPE (decl) = do_auto_deduction (type, d_init, auto_node,\n-\t\t\t\t\t\t   tf_warning_or_error, adc);\n+\t\t\t\t\t\t   tf_warning_or_error, adc,\n+\t\t\t\t\t\t   NULL_TREE, flags);\n       if (type == error_mark_node)\n \treturn;\n       if (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -8730,14 +8731,6 @@ grokfndecl (tree ctype,\n \t\t    \"namespace scope\", decl);\n \t  return NULL_TREE;\n \t}\n-      tree type = TREE_TYPE (DECL_NAME (decl));\n-      if (CP_DECL_CONTEXT (decl) != CP_TYPE_CONTEXT (type))\n-\t{\n-\t  error_at (location, \"deduction guide %qD must be declared in the \"\n-\t\t    \"same scope as %qT\", decl, type);\n-\t  inform (location_of (type), \"  declared here\");\n-\t  return NULL_TREE;\n-\t}\n       if (funcdef_flag)\n \terror_at (location,\n \t\t  \"deduction guide %qD must not have a function body\", decl);\n@@ -9758,6 +9751,20 @@ check_special_function_return_type (special_function_kind sfk,\n       type = optype;\n       break;\n \n+    case sfk_deduction_guide:\n+      if (type)\n+\terror (\"return type specified for deduction guide\");\n+      else if (type_quals != TYPE_UNQUALIFIED)\n+\terror_at (smallest_type_quals_location (type_quals, locations),\n+\t\t  \"qualifiers are not allowed on declaration of \"\n+\t\t  \"deduction guide\");\n+      type = make_template_placeholder (CLASSTYPE_TI_TEMPLATE (optype));\n+      for (int i = 0; i < ds_last; ++i)\n+\tif (i != ds_explicit && locations[i])\n+\t  error_at (locations[i],\n+\t\t    \"decl-specifier in declaration of deduction guide\");\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -10105,7 +10112,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  {\n \t\t    gcc_assert (flags == NO_SPECIAL);\n \t\t    flags = TYPENAME_FLAG;\n-\t\t    ctor_return_type = TREE_TYPE (dname);\n \t\t    sfk = sfk_conversion;\n \t\t    if (is_typename_at_global_scope (dname))\n \t\t      name = identifier_to_locale (IDENTIFIER_POINTER (dname));\n@@ -10285,8 +10291,9 @@ grokdeclarator (const cp_declarator *declarator,\n #endif\n   typedef_type = type;\n \n-\n-  if (sfk != sfk_conversion)\n+  if (sfk == sfk_conversion || sfk == sfk_deduction_guide)\n+    ctor_return_type = TREE_TYPE (dname);\n+  else\n     ctor_return_type = ctype;\n \n   if (sfk != sfk_none)\n@@ -10906,12 +10913,13 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\tif (!late_return_type)\n \t\t\t  {\n \t\t\t    if (dguide_name_p (unqualified_id))\n-\t\t\t      error_at (typespec_loc, \"deduction guide for \"\n-\t\t\t\t\t\"%qT must have trailing return type\",\n-\t\t\t\t\tTREE_TYPE (tmpl));\n+\t\t\t      error_at (declarator->id_loc, \"deduction guide \"\n+\t\t\t\t\t\"for %qT must have trailing return \"\n+\t\t\t\t\t\"type\", TREE_TYPE (tmpl));\n \t\t\t    else\n-\t\t\t      error_at (typespec_loc, \"deduced class type %qT \"\n-\t\t\t\t\t\"in function return type\", type);\n+\t\t\t      error_at (declarator->id_loc, \"deduced class \"\n+\t\t\t\t\t\"type %qT in function return type\",\n+\t\t\t\t\ttype);\n \t\t\t    inform (DECL_SOURCE_LOCATION (tmpl),\n \t\t\t\t    \"%qD declared here\", tmpl);\n \t\t\t  }\n@@ -11039,6 +11047,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tif (late_return_type_p)\n \t\t  error (\"a conversion function cannot have a trailing return type\");\n \t      }\n+\t    else if (sfk == sfk_deduction_guide)\n+\t      {\n+\t\tif (explicitp == 1)\n+\t\t  explicitp = 2;\n+\t      }\n \n \t    arg_types = grokparms (declarator->u.function.parameters,\n \t\t\t\t   &parms);\n@@ -12207,6 +12220,8 @@ grokdeclarator (const cp_declarator *declarator,\n \tif (decl == NULL_TREE)\n \t  return error_mark_node;\n \n+\tif (explicitp == 2)\n+\t  DECL_NONCONVERTING_P (decl) = 1;\n \tif (staticp == 1)\n \t  {\n \t    int invalid_static = 0;"}, {"sha": "d8c5d5ea41245ae57fd9b481b0d8b0c22df4f366", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=a56c0ac08242269bbcc4bd1f480eda2378336776", "patch": "@@ -1015,7 +1015,7 @@ dump_decl_name (cxx_pretty_printer *pp, tree t, int flags)\n   if (dguide_name_p (t))\n     {\n       dump_decl (pp, CLASSTYPE_TI_TEMPLATE (TREE_TYPE (t)),\n-\t\t TFF_PLAIN_IDENTIFIER);\n+\t\t TFF_UNQUALIFIED_NAME);\n       return;\n     }\n "}, {"sha": "8812f8ce77b2f3107d1d306eb3154ece66b651ca", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 53, "deletions": 38, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a56c0ac08242269bbcc4bd1f480eda2378336776", "patch": "@@ -19050,26 +19050,9 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   token = cp_lexer_peek_token (parser->lexer);\n \n-  cp_parser_declarator_kind cdk = CP_PARSER_DECLARATOR_NAMED;\n-  if (token->type == CPP_OPEN_PAREN\n-      && decl_specifiers->type\n-      && is_auto (decl_specifiers->type)\n-      && CLASS_PLACEHOLDER_TEMPLATE (decl_specifiers->type))\n-    {\n-      // C++17 deduction guide.\n-      cdk = CP_PARSER_DECLARATOR_ABSTRACT;\n-\n-      for (int i = 0; i < ds_last; ++i)\n-\tif (i != ds_type_spec\n-\t    && decl_specifiers->locations[i]\n-\t    && !cp_parser_simulate_error (parser))\n-\t  error_at (decl_specifiers->locations[i],\n-\t\t    \"decl-specifier in declaration of deduction guide\");\n-    }\n-\n   /* Parse the declarator.  */\n   declarator\n-    = cp_parser_declarator (parser, cdk,\n+    = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t    &ctor_dtor_or_conv_p,\n \t\t\t    /*parenthesized_p=*/NULL,\n \t\t\t    member_p, friend_p);\n@@ -19083,17 +19066,6 @@ cp_parser_init_declarator (cp_parser* parser,\n   if (declarator == cp_error_declarator)\n     return error_mark_node;\n \n-  if (cdk == CP_PARSER_DECLARATOR_ABSTRACT)\n-    {\n-      gcc_assert (declarator->kind == cdk_function\n-\t\t  && !declarator->declarator);\n-      tree t = CLASS_PLACEHOLDER_TEMPLATE (decl_specifiers->type);\n-      declarator->declarator = make_id_declarator (NULL_TREE, dguide_name (t),\n-\t\t\t\t\t\t   sfk_none);\n-      declarator->declarator->id_loc\n-\t= decl_specifiers->locations[ds_type_spec];\n-    }\n-\n   /* Check that the number of template-parameter-lists is OK.  */\n   if (!cp_parser_check_declarator_template_parameters (parser, declarator,\n \t\t\t\t\t\t       token->location))\n@@ -19136,6 +19108,25 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   if (function_declarator_p (declarator))\n     {\n+      /* Handle C++17 deduction guides.  */\n+      if (!decl_specifiers->type\n+\t  && ctor_dtor_or_conv_p <= 0\n+\t  && cxx_dialect >= cxx1z)\n+\t{\n+\t  cp_declarator *id = get_id_declarator (declarator);\n+\t  tree name = id->u.id.unqualified_name;\n+\t  parser->scope = id->u.id.qualifying_scope;\n+\t  tree tmpl = cp_parser_lookup_name_simple (parser, name, id->id_loc);\n+\t  if (tmpl\n+\t      && (DECL_CLASS_TEMPLATE_P (tmpl)\n+\t\t  || DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)))\n+\t    {\n+\t      id->u.id.unqualified_name = dguide_name (tmpl);\n+\t      id->u.id.sfk = sfk_deduction_guide;\n+\t      ctor_dtor_or_conv_p = 1;\n+\t    }\n+\t}\n+\n       /* Check to see if the token indicates the start of a\n \t function-definition.  */\n       if (cp_parser_token_starts_function_definition_p (token))\n@@ -19202,8 +19193,8 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   /* [dcl.dcl]\n \n-     Only in function declarations for constructors, destructors, and\n-     type conversions can the decl-specifier-seq be omitted.\n+     Only in function declarations for constructors, destructors, type\n+     conversions, and deduction guides can the decl-specifier-seq be omitted.\n \n      We explicitly postpone this check past the point where we handle\n      function-definitions because we tolerate function-definitions\n@@ -19453,8 +19444,8 @@ cp_parser_init_declarator (cp_parser* parser,\n      attributes [opt] direct-abstract-declarator\n \n    If CTOR_DTOR_OR_CONV_P is not NULL, *CTOR_DTOR_OR_CONV_P is used to\n-   detect constructor, destructor or conversion operators. It is set\n-   to -1 if the declarator is a name, and +1 if it is a\n+   detect constructors, destructors, deduction guides, or conversion operators.\n+   It is set to -1 if the declarator is a name, and +1 if it is a\n    function. Otherwise it is set to zero. Usually you just want to\n    test for >0, but internally the negative value is used.\n \n@@ -25929,8 +25920,8 @@ cp_parser_global_scope_opt (cp_parser* parser, bool current_scope_valid_p)\n }\n \n /* Returns TRUE if the upcoming token sequence is the start of a\n-   constructor declarator.  If FRIEND_P is true, the declarator is\n-   preceded by the `friend' specifier.  */\n+   constructor declarator or C++17 deduction guide.  If FRIEND_P is true, the\n+   declarator is preceded by the `friend' specifier.  */\n \n static bool\n cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n@@ -25975,8 +25966,10 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t\t\t       || friend_p);\n \n   /* Outside of a class-specifier, there must be a\n-     nested-name-specifier.  */\n-  if (!nested_name_specifier && outside_class_specifier_p)\n+     nested-name-specifier.  Except in C++17 mode, where we\n+     might be declaring a guiding declaration.  */\n+  if (!nested_name_specifier && outside_class_specifier_p\n+      && cxx_dialect < cxx1z)\n     constructor_p = false;\n   else if (nested_name_specifier == error_mark_node)\n     constructor_p = false;\n@@ -26007,6 +26000,9 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t   };\n \n \t we must recognize that the nested `S' names a class.  */\n+      if (cxx_dialect >= cxx1z)\n+\tcp_parser_parse_tentatively (parser);\n+\n       tree type_decl;\n       type_decl = cp_parser_class_name (parser,\n \t\t\t\t\t/*typename_keyword_p=*/false,\n@@ -26015,13 +26011,32 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t\t\t\t\t/*check_dependency_p=*/false,\n \t\t\t\t\t/*class_head_p=*/false,\n \t\t\t\t\t/*is_declaration=*/false);\n+\n+      if (cxx_dialect >= cxx1z\n+\t  && !cp_parser_parse_definitely (parser))\n+\t{\n+\t  type_decl = NULL_TREE;\n+\t  tree tmpl = cp_parser_template_name (parser,\n+\t\t\t\t\t       /*template_keyword*/false,\n+\t\t\t\t\t       /*check_dependency_p*/false,\n+\t\t\t\t\t       /*is_declaration*/false,\n+\t\t\t\t\t       none_type,\n+\t\t\t\t\t       /*is_identifier*/NULL);\n+\t  if (DECL_CLASS_TEMPLATE_P (tmpl)\n+\t      || DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl))\n+\t    /* It's a deduction guide, return true.  */;\n+\t  else\n+\t    cp_parser_simulate_error (parser);\n+\t}\n+\n       /* If there was no class-name, then this is not a constructor.\n \t Otherwise, if we are in a class-specifier and we aren't\n \t handling a friend declaration, check that its type matches\n \t current_class_type (c++/38313).  Note: error_mark_node\n \t is left alone for error recovery purposes.  */\n       constructor_p = (!cp_parser_error_occurred (parser)\n \t\t       && (outside_class_specifier_p\n+\t\t\t   || type_decl == NULL_TREE\n \t\t\t   || type_decl == error_mark_node\n \t\t\t   || same_type_p (current_class_type,\n \t\t\t\t\t   TREE_TYPE (type_decl))));\n@@ -26056,7 +26071,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t     in the scope of the class.  */\n \t  if (current_class_type)\n \t    type = NULL_TREE;\n-\t  else\n+\t  else if (type_decl)\n \t    {\n \t      type = TREE_TYPE (type_decl);\n \t      if (TREE_CODE (type) == TYPENAME_TYPE)"}, {"sha": "58d60160e9807eef56c63850cd203aa05622b0ca", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a56c0ac08242269bbcc4bd1f480eda2378336776", "patch": "@@ -24786,7 +24786,7 @@ dguide_name_p (tree name)\n /* True if FN is a deduction guide.  */\n \n bool\n-deduction_guide_p (tree fn)\n+deduction_guide_p (const_tree fn)\n {\n   if (DECL_P (fn))\n     if (tree name = DECL_NAME (fn))\n@@ -24999,6 +24999,7 @@ build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)\n \t\t\t\t     dguide_name (type), fntype);\n   DECL_ARGUMENTS (ded_fn) = fargs;\n   DECL_ARTIFICIAL (ded_fn) = true;\n+  DECL_NONCONVERTING_P (ded_fn) = DECL_NONCONVERTING_P (ctor);\n   tree ded_tmpl = build_template_decl (ded_fn, tparms, /*member*/false);\n   DECL_ARTIFICIAL (ded_tmpl) = true;\n   DECL_TEMPLATE_RESULT (ded_tmpl) = ded_fn;\n@@ -25015,8 +25016,9 @@ build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)\n    template TMPL based on the initializer INIT, and return the resulting\n    type.  */\n \n-tree\n-do_class_deduction (tree ptype, tree tmpl, tree init, tsubst_flags_t complain)\n+static tree\n+do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n+\t\t    tsubst_flags_t complain)\n {\n   if (!DECL_CLASS_TEMPLATE_P (tmpl))\n     {\n@@ -25083,9 +25085,48 @@ do_class_deduction (tree ptype, tree tmpl, tree init, tsubst_flags_t complain)\n       return error_mark_node;\n     }\n \n+  /* Prune explicit deduction guides in copy-initialization context.  */\n+  tree old_cands = cands;\n+  if (flags & LOOKUP_ONLYCONVERTING)\n+    {\n+      tree t = cands;\n+      for (; t; t = OVL_NEXT (t))\n+\tif (DECL_NONCONVERTING_P (DECL_TEMPLATE_RESULT (OVL_CURRENT (t))))\n+\t  break;\n+      if (t)\n+\t{\n+\t  tree pruned = NULL_TREE;\n+\t  for (t = cands; t; t = OVL_NEXT (t))\n+\t    {\n+\t      tree f = OVL_CURRENT (t);\n+\t      if (!DECL_NONCONVERTING_P (DECL_TEMPLATE_RESULT (f)))\n+\t\tpruned = build_overload (f, pruned);\n+\t    }\n+\t  cands = pruned;\n+\t  if (cands == NULL_TREE)\n+\t    {\n+\t      error (\"cannot deduce template arguments for copy-initialization\"\n+\t\t     \" of %qT, as it has no non-explicit deduction guides or \"\n+\t\t     \"user-declared constructors\", type);\n+\t      return error_mark_node;\n+\t    }\n+\t}\n+    }\n+\n   ++cp_unevaluated_operand;\n   tree t = build_new_function_call (cands, &args, /*koenig*/false,\n-\t\t\t\t    complain|tf_decltype);\n+\t\t\t\t    tf_decltype);\n+\n+  if (t == error_mark_node && (complain & tf_warning_or_error))\n+    {\n+      error (\"class template argument deduction failed:\");\n+      t = build_new_function_call (cands, &args, /*koenig*/false,\n+\t\t\t\t   complain | tf_decltype);\n+      if (old_cands != cands)\n+\tinform (input_location, \"explicit deduction guides not considered \"\n+\t\t\"for copy-initialization\");\n+    }\n+\n   --cp_unevaluated_operand;\n   release_tree_vector (args);\n \n@@ -25106,15 +25147,18 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n /* Replace occurrences of 'auto' in TYPE with the appropriate type deduced\n    from INIT.  AUTO_NODE is the TEMPLATE_TYPE_PARM used for 'auto' in TYPE.\n    The CONTEXT determines the context in which auto deduction is performed\n-   and is used to control error diagnostics.\n+   and is used to control error diagnostics.  FLAGS are the LOOKUP_* flags.\n+   OUTER_TARGS are used during template argument deduction\n+   (context == adc_unify) to properly substitute the result, and is ignored\n+   in other contexts.\n \n    For partial-concept-ids, extra args may be appended to the list of deduced\n    template arguments prior to determining constraint satisfaction.  */\n \n tree\n do_auto_deduction (tree type, tree init, tree auto_node,\n                    tsubst_flags_t complain, auto_deduction_context context,\n-\t\t   tree outer_targs)\n+\t\t   tree outer_targs, int flags)\n {\n   tree targs;\n \n@@ -25129,7 +25173,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \n   if (tree tmpl = CLASS_PLACEHOLDER_TEMPLATE (auto_node))\n     /* C++17 class template argument deduction.  */\n-    return do_class_deduction (type, tmpl, init, complain);\n+    return do_class_deduction (type, tmpl, init, flags, complain);\n \n   /* [dcl.spec.auto]: Obtain P from T by replacing the occurrences of auto\n      with either a new invented type template parameter U or, if the"}, {"sha": "785dfafae540f051c8159c3a450f312c14786650", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a56c0ac08242269bbcc4bd1f480eda2378336776", "patch": "@@ -4374,6 +4374,8 @@ special_function_p (const_tree decl)\n     return sfk_deleting_destructor;\n   if (DECL_CONV_FN_P (decl))\n     return sfk_conversion;\n+  if (deduction_guide_p (decl))\n+    return sfk_deduction_guide;\n \n   return sfk_none;\n }"}, {"sha": "ce5c5d73e9f481a6192dedc7ed87e6a026218afd", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction27.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction27.C?ref=a56c0ac08242269bbcc4bd1f480eda2378336776", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/79316\n+// { dg-options -std=c++1z }\n+\n+  template<typename T> struct S { S(T t) {} };\n+  template<typename T> S(T, int = 7) -> S<T>;"}, {"sha": "c91ec0dccaf09e928e5ff5310c80f5119b8fe35c", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction28.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction28.C?ref=a56c0ac08242269bbcc4bd1f480eda2378336776", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/79350\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+struct A\n+{\n+  explicit A(T);\n+};\n+\n+\n+A a (42);\n+A a2 = 42; \t\t\t// { dg-error \"\" }\n+\n+template <class T>\n+struct B\n+{\n+  B(T*);\n+};\n+\n+template <class T>\n+explicit B(T) -> B<T*>;\n+\n+B b1 (0);\n+B b2 = 0;\t\t\t// { dg-error \"\" }"}, {"sha": "149ef43e5ca33076dace8e09b8982671dac0ed41", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c0ac08242269bbcc4bd1f480eda2378336776/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction9.C?ref=a56c0ac08242269bbcc4bd1f480eda2378336776", "patch": "@@ -10,7 +10,7 @@ namespace N {\n }\n \n template <class T>\n-N::A(T) -> N::A<T>;\t\t// { dg-error \"scope\" }\n+N::A(T) -> N::A<T>;\t  // { dg-error \"should have been declared inside .N\" }\n \n namespace N {\n   template <class T>"}]}