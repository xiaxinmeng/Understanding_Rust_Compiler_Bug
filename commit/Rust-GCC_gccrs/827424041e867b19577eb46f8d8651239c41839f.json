{"sha": "827424041e867b19577eb46f8d8651239c41839f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI3NDI0MDQxZTg2N2IxOTU3N2ViNDZmOGQ4NjUxMjM5YzQxODM5Zg==", "commit": {"author": {"name": "Hale Wang", "email": "hale.wang@arm.com", "date": "2016-07-11T17:11:31Z"}, "committer": {"name": "Andre Vieira", "email": "avieira@gcc.gnu.org", "date": "2016-07-11T17:11:31Z"}, "message": "lib1funcs.S: Add new wrapper.\n\n2016-07-11  Hale Wang  <hale.wang@arm.com>\n\t    Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\t* config/arm/lib1funcs.S: Add new wrapper.\n\nCo-Authored-By: Andre Vieira <andre.simoesdiasvieira@arm.com>\n\nFrom-SVN: r238215", "tree": {"sha": "651f39122b7885ff572d3d87648266f44cc5cbdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/651f39122b7885ff572d3d87648266f44cc5cbdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/827424041e867b19577eb46f8d8651239c41839f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/827424041e867b19577eb46f8d8651239c41839f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/827424041e867b19577eb46f8d8651239c41839f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/827424041e867b19577eb46f8d8651239c41839f/comments", "author": null, "committer": null, "parents": [{"sha": "9a54f10dbb88b9cffb3794492f2dd9a22822d619", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a54f10dbb88b9cffb3794492f2dd9a22822d619", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a54f10dbb88b9cffb3794492f2dd9a22822d619"}], "stats": {"total": 255, "additions": 223, "deletions": 32}, "files": [{"sha": "974ac5e5a4c2b26dd7a6dc7ce78a2cf26fb45e06", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827424041e867b19577eb46f8d8651239c41839f/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827424041e867b19577eb46f8d8651239c41839f/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=827424041e867b19577eb46f8d8651239c41839f", "patch": "@@ -1,3 +1,8 @@\n+2016-07-11  Hale Wang  <hale.wang@arm.com>\n+\t    Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\t* config/arm/lib1funcs.S: Add new wrapper.\n+\n 2016-07-07  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* config/arm/lib1funcs.S (__ARM_ARCH__): Define to 8 for ARMv8-M."}, {"sha": "ba52e7b762f5573445349a574a3878859a992f13", "filename": "libgcc/config/arm/lib1funcs.S", "status": "modified", "additions": 218, "deletions": 32, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827424041e867b19577eb46f8d8651239c41839f/libgcc%2Fconfig%2Farm%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827424041e867b19577eb46f8d8651239c41839f/libgcc%2Fconfig%2Farm%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Flib1funcs.S?ref=827424041e867b19577eb46f8d8651239c41839f", "patch": "@@ -311,34 +311,13 @@ LSYM(Lend_fde):\n #ifdef __ARM_EABI__\n .macro THUMB_LDIV0 name signed\n #ifdef NOT_ISA_TARGET_32BIT\n-\t.ifc \\signed, unsigned\n-\tcmp\tr0, #0\n-\tbeq\t1f\n-\tmov\tr0, #0\n-\tmvn\tr0, r0\t\t@ 0xffffffff\n-1:\n-\t.else\n-\tcmp\tr0, #0\n-\tbeq\t2f\n-\tblt\t3f\n+\n+\tpush\t{r0, lr}\n \tmov\tr0, #0\n-\tmvn\tr0, r0\n-\tlsr\tr0, r0, #1\t@ 0x7fffffff\n-\tb\t2f\n-3:\tmov\tr0, #0x80\n-\tlsl\tr0, r0, #24\t@ 0x80000000\n-2:\n-\t.endif\n-\tpush\t{r0, r1, r2}\n-\tldr\tr0, 4f\n-\tadr\tr1, 4f\n-\tadd\tr0, r1\n-\tstr\tr0, [sp, #8]\n+\tbl\tSYM(__aeabi_idiv0)\n \t@ We know we are not on armv4t, so pop pc is safe.\n-\tpop\t{r0, r1, pc}\n-\t.align\t2\n-4:\n-\t.word\t__aeabi_idiv0 - 4b\n+\tpop\t{r1, pc}\n+\n #elif defined(__thumb2__)\n \t.syntax unified\n \t.ifc \\signed, unsigned\n@@ -950,7 +929,170 @@ LSYM(Lover7):\n \tadd\tdividend, work\n   .endif\n LSYM(Lgot_result):\n-.endm\t\n+.endm\n+\n+/* If performance is preferred, the following functions are provided.  */\n+#if defined(__prefer_thumb__) && !defined(__OPTIMIZE_SIZE__)\n+\n+/* Branch to div(n), and jump to label if curbit is lo than divisior.  */\n+.macro BranchToDiv n, label\n+\tlsr\tcurbit, dividend, \\n\n+\tcmp\tcurbit, divisor\n+\tblo\t\\label\n+.endm\n+\n+/* Body of div(n).  Shift the divisor in n bits and compare the divisor\n+   and dividend.  Update the dividend as the substruction result.  */\n+.macro DoDiv n\n+\tlsr\tcurbit, dividend, \\n\n+\tcmp\tcurbit, divisor\n+\tbcc\t1f\n+\tlsl\tcurbit, divisor, \\n\n+\tsub\tdividend, dividend, curbit\n+\n+1:\tadc\tresult, result\n+.endm\n+\n+/* The body of division with positive divisor.  Unless the divisor is very\n+   big, shift it up in multiples of four bits, since this is the amount of\n+   unwinding in the main division loop.  Continue shifting until the divisor\n+   is larger than the dividend.  */\n+.macro THUMB1_Div_Positive\n+\tmov\tresult, #0\n+\tBranchToDiv #1, LSYM(Lthumb1_div1)\n+\tBranchToDiv #4, LSYM(Lthumb1_div4)\n+\tBranchToDiv #8, LSYM(Lthumb1_div8)\n+\tBranchToDiv #12, LSYM(Lthumb1_div12)\n+\tBranchToDiv #16, LSYM(Lthumb1_div16)\n+LSYM(Lthumb1_div_large_positive):\n+\tmov\tresult, #0xff\n+\tlsl\tdivisor, divisor, #8\n+\trev\tresult, result\n+\tlsr\tcurbit, dividend, #16\n+\tcmp\tcurbit, divisor\n+\tblo\t1f\n+\tasr\tresult, #8\n+\tlsl\tdivisor, divisor, #8\n+\tbeq\tLSYM(Ldivbyzero_waypoint)\n+\n+1:\tlsr\tcurbit, dividend, #12\n+\tcmp\tcurbit, divisor\n+\tblo\tLSYM(Lthumb1_div12)\n+\tb\tLSYM(Lthumb1_div16)\n+LSYM(Lthumb1_div_loop):\n+\tlsr\tdivisor, divisor, #8\n+LSYM(Lthumb1_div16):\n+\tDodiv\t#15\n+\tDodiv\t#14\n+\tDodiv\t#13\n+\tDodiv\t#12\n+LSYM(Lthumb1_div12):\n+\tDodiv\t#11\n+\tDodiv\t#10\n+\tDodiv\t#9\n+\tDodiv\t#8\n+\tbcs\tLSYM(Lthumb1_div_loop)\n+LSYM(Lthumb1_div8):\n+\tDodiv\t#7\n+\tDodiv\t#6\n+\tDodiv\t#5\n+LSYM(Lthumb1_div5):\n+\tDodiv\t#4\n+LSYM(Lthumb1_div4):\n+\tDodiv\t#3\n+LSYM(Lthumb1_div3):\n+\tDodiv\t#2\n+LSYM(Lthumb1_div2):\n+\tDodiv\t#1\n+LSYM(Lthumb1_div1):\n+\tsub\tdivisor, dividend, divisor\n+\tbcs\t1f\n+\tcpy\tdivisor, dividend\n+\n+1:\tadc\tresult, result\n+\tcpy\tdividend, result\n+\tRET\n+\n+LSYM(Ldivbyzero_waypoint):\n+\tb\tLSYM(Ldiv0)\n+.endm\n+\n+/* The body of division with negative divisor.  Similar with\n+   THUMB1_Div_Positive except that the shift steps are in multiples\n+   of six bits.  */\n+.macro THUMB1_Div_Negative\n+\tlsr\tresult, divisor, #31\n+\tbeq\t1f\n+\tneg\tdivisor, divisor\n+\n+1:\tasr\tcurbit, dividend, #32\n+\tbcc\t2f\n+\tneg\tdividend, dividend\n+\n+2:\teor\tcurbit, result\n+\tmov\tresult, #0\n+\tcpy\tip, curbit\n+\tBranchToDiv #4, LSYM(Lthumb1_div_negative4)\n+\tBranchToDiv #8, LSYM(Lthumb1_div_negative8)\n+LSYM(Lthumb1_div_large):\n+\tmov\tresult, #0xfc\n+\tlsl\tdivisor, divisor, #6\n+\trev\tresult, result\n+\tlsr\tcurbit, dividend, #8\n+\tcmp\tcurbit, divisor\n+\tblo\tLSYM(Lthumb1_div_negative8)\n+\n+\tlsl\tdivisor, divisor, #6\n+\tasr\tresult, result, #6\n+\tcmp\tcurbit, divisor\n+\tblo\tLSYM(Lthumb1_div_negative8)\n+\n+\tlsl\tdivisor, divisor, #6\n+\tasr\tresult, result, #6\n+\tcmp\tcurbit, divisor\n+\tblo\tLSYM(Lthumb1_div_negative8)\n+\n+\tlsl\tdivisor, divisor, #6\n+\tbeq\tLSYM(Ldivbyzero_negative)\n+\tasr\tresult, result, #6\n+\tb\tLSYM(Lthumb1_div_negative8)\n+LSYM(Lthumb1_div_negative_loop):\n+\tlsr\tdivisor, divisor, #6\n+LSYM(Lthumb1_div_negative8):\n+\tDoDiv\t#7\n+\tDoDiv\t#6\n+\tDoDiv\t#5\n+\tDoDiv\t#4\n+LSYM(Lthumb1_div_negative4):\n+\tDoDiv\t#3\n+\tDoDiv\t#2\n+\tbcs\tLSYM(Lthumb1_div_negative_loop)\n+\tDoDiv\t#1\n+\tsub\tdivisor, dividend, divisor\n+\tbcs\t1f\n+\tcpy\tdivisor, dividend\n+\n+1:\tcpy\tcurbit, ip\n+\tadc\tresult, result\n+\tasr\tcurbit, curbit, #1\n+\tcpy\tdividend, result\n+\tbcc\t2f\n+\tneg\tdividend, dividend\n+\tcmp\tcurbit, #0\n+\n+2:\tbpl\t3f\n+\tneg\tdivisor, divisor\n+\n+3:\tRET\n+\n+LSYM(Ldivbyzero_negative):\n+\tcpy\tcurbit, ip\n+\tasr\tcurbit, curbit, #1\n+\tbcc\tLSYM(Ldiv0)\n+\tneg\tdividend, dividend\n+.endm\n+#endif /* ARM Thumb version.  */\n+\n /* ------------------------------------------------------------------------ */\n /*\t\tStart of the Real Functions\t\t\t\t    */\n /* ------------------------------------------------------------------------ */\n@@ -960,6 +1102,7 @@ LSYM(Lgot_result):\n \n \tFUNC_START udivsi3\n \tFUNC_ALIAS aeabi_uidiv udivsi3\n+#if defined(__OPTIMIZE_SIZE__)\n \n \tcmp\tdivisor, #0\n \tbeq\tLSYM(Ldiv0)\n@@ -977,6 +1120,14 @@ LSYM(udivsi3_skip_div0_test):\n \tpop\t{ work }\n \tRET\n \n+/* Implementation of aeabi_uidiv for ARMv6m.  This version is only\n+   used in ARMv6-M when we need an efficient implementation.  */\n+#else\n+LSYM(udivsi3_skip_div0_test):\n+\tTHUMB1_Div_Positive\n+\n+#endif /* __OPTIMIZE_SIZE__ */\n+\n #elif defined(__ARM_ARCH_EXT_IDIV__)\n \n \tARM_FUNC_START udivsi3\n@@ -1028,12 +1179,21 @@ LSYM(udivsi3_skip_div0_test):\n FUNC_START aeabi_uidivmod\n \tcmp\tr1, #0\n \tbeq\tLSYM(Ldiv0)\n+# if defined(__OPTIMIZE_SIZE__)\n \tpush\t{r0, r1, lr}\n \tbl\tLSYM(udivsi3_skip_div0_test)\n \tPOP\t{r1, r2, r3}\n \tmul\tr2, r0\n \tsub\tr1, r1, r2\n \tbx\tr3\n+# else\n+\t/* Both the quotient and remainder are calculated simultaneously\n+\t   in THUMB1_Div_Positive.  There is no need to calculate the\n+\t   remainder again here.  */\n+\tb\tLSYM(udivsi3_skip_div0_test)\n+\tRET\n+# endif /* __OPTIMIZE_SIZE__ */\n+\n #elif defined(__ARM_ARCH_EXT_IDIV__)\n ARM_FUNC_START aeabi_uidivmod\n \tcmp\tr1, #0\n@@ -1089,7 +1249,7 @@ LSYM(Lover10):\n \tRET\n \t\n #else  /* ARM version.  */\n-\t\n+\n \tFUNC_START umodsi3\n \n \tsubs\tr2, r1, #1\t\t\t@ compare divisor with 1\n@@ -1114,8 +1274,9 @@ LSYM(Lover10):\n \n #if defined(__prefer_thumb__)\n \n-\tFUNC_START divsi3\t\n+\tFUNC_START divsi3\n \tFUNC_ALIAS aeabi_idiv divsi3\n+#if defined(__OPTIMIZE_SIZE__)\n \n \tcmp\tdivisor, #0\n \tbeq\tLSYM(Ldiv0)\n@@ -1138,7 +1299,7 @@ LSYM(Lover11):\n \tblo\tLSYM(Lgot_result)\n \n \tTHUMB_DIV_MOD_BODY 0\n-\t\n+\n \tmov\tr0, result\n \tmov\twork, ip\n \tcmp\twork, #0\n@@ -1148,6 +1309,22 @@ LSYM(Lover12):\n \tpop\t{ work }\n \tRET\n \n+/* Implementation of aeabi_idiv for ARMv6m.  This version is only\n+   used in ARMv6-M when we need an efficient implementation.  */\n+#else\n+LSYM(divsi3_skip_div0_test):\n+\tcpy\tcurbit, dividend\n+\torr\tcurbit, divisor\n+\tbmi\tLSYM(Lthumb1_div_negative)\n+\n+LSYM(Lthumb1_div_positive):\n+\tTHUMB1_Div_Positive\n+\n+LSYM(Lthumb1_div_negative):\n+\tTHUMB1_Div_Negative\n+\n+#endif /* __OPTIMIZE_SIZE__ */\n+\n #elif defined(__ARM_ARCH_EXT_IDIV__)\n \n \tARM_FUNC_START divsi3\n@@ -1159,8 +1336,8 @@ LSYM(Lover12):\n \tRET\n \n #else /* ARM/Thumb-2 version.  */\n-\t\n-\tARM_FUNC_START divsi3\t\n+\n+\tARM_FUNC_START divsi3\n \tARM_FUNC_ALIAS aeabi_idiv divsi3\n \n \tcmp\tr1, #0\n@@ -1214,12 +1391,21 @@ LSYM(divsi3_skip_div0_test):\n FUNC_START aeabi_idivmod\n \tcmp\tr1, #0\n \tbeq\tLSYM(Ldiv0)\n+# if defined(__OPTIMIZE_SIZE__)\n \tpush\t{r0, r1, lr}\n \tbl\tLSYM(divsi3_skip_div0_test)\n \tPOP\t{r1, r2, r3}\n \tmul\tr2, r0\n \tsub\tr1, r1, r2\n \tbx\tr3\n+# else\n+\t/* Both the quotient and remainder are calculated simultaneously\n+\t   in THUMB1_Div_Positive and THUMB1_Div_Negative.  There is no\n+\t   need to calculate the remainder again here.  */\n+\tb\tLSYM(divsi3_skip_div0_test)\n+\tRET\n+# endif /* __OPTIMIZE_SIZE__ */\n+\n #elif defined(__ARM_ARCH_EXT_IDIV__)\n ARM_FUNC_START aeabi_idivmod\n \tcmp \tr1, #0"}]}