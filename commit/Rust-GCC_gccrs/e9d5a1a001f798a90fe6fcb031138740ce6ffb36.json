{"sha": "e9d5a1a001f798a90fe6fcb031138740ce6ffb36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlkNWExYTAwMWY3OThhOTBmZTZmY2IwMzExMzg3NDBjZTZmZmIzNg==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2015-01-15T14:12:25Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-01-15T14:12:25Z"}, "message": "tree-if-conv.c: Include hash-map.h.\n\ngcc/\n\n\t* tree-if-conv.c: Include hash-map.h.\n\t(aggressive_if_conv): New variable.\n\t(fold_build_cond_expr): Add simplification of non-zero condition.\n\t(add_to_dst_predicate_list): Invoke add_to_predicate_list if edge\n\tdestination block is not always executed.\n\t(if_convertible_phi_p): Fix commentary, allow phi nodes have more\n\tthan two predecessors if AGGRESSIVE_IF_CONV is true.\n\t(if_convertible_stmt_p): Fix commentary.\n\t(all_preds_critical_p): New function.\n\t(has_pred_critical_p): New function.\n\t(if_convertible_bb_p): Fix commentary, if AGGRESSIVE_IF_CONV is true\n\tBB can have more than two predecessors and all incoming edges can be\n\tcritical.\n\t(predicate_bbs): Skip predication for loop exit block, use build2_loc\n\tto compute predicate for true edge.\n\t(find_phi_replacement_condition): Delete this function.\n\t(is_cond_scalar_reduction): Add arguments ARG_0, ARG_1 and EXTENDED.\n\tAllow interchange PHI arguments if EXTENDED is false.\n\tChange check that block containing reduction statement candidate\n\tis predecessor of phi-block since phi may have more than two arguments.\n\t(phi_args_hash_traits): New helper structure.\n\t(struct phi_args_hash_traits): New type.\n\t(phi_args_hash_traits::hash): New function.\n\t(phi_args_hash_traits::equal_keys): New function.\n\t(gen_phi_arg_condition): New function.\n\t(predicate_scalar_phi): Add handling of phi nodes with more than two\n\targuments, delete COND and TRUE_BB arguments, insert body of\n\tfind_phi_replacement_condition to predicate ordinary phi nodes.\n\t(predicate_all_scalar_phis): Skip blocks with the only predecessor,\n\tdelete call of find_phi_replacement_condition and invoke\n\tpredicate_scalar_phi with two arguments.\n\t(insert_gimplified_predicates): Add assert that non-predicated block\n\tdon't have statements to insert.\n\t(ifcvt_split_critical_edges): New function.\n\t(ifcvt_split_def_stmt): Likewise.\n\t(ifcvt_walk_pattern_tree): Likewise.\n\t(stmt_is_root_of_bool_pattern): Likewise.\n\t(ifcvt_repair_bool_pattern): Likewise.\n\t(ifcvt_local_dce): Likewise.\n\t(tree_if_conversion): Add initialization of AGGRESSIVE_IF_CONV which\n\tis copy of inner or outer loop force_vectorize field, invoke\n\tifcvt_split_critical_edges, ifcvt_local_dce and\n\tifcvt_repair_bool_pattern for aggressive if-conversion.\n\ngcc/testsuite/\n\n\t* gcc.dg/vect/vect-aggressive-1.c: New.\n\t* gcc.target/i386/avx2-vect-aggressive.c: New.\n\nFrom-SVN: r219658", "tree": {"sha": "15889e3c86ef1a49cddf88fca71779164746b800", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15889e3c86ef1a49cddf88fca71779164746b800"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9d5a1a001f798a90fe6fcb031138740ce6ffb36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d5a1a001f798a90fe6fcb031138740ce6ffb36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d5a1a001f798a90fe6fcb031138740ce6ffb36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d5a1a001f798a90fe6fcb031138740ce6ffb36/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0f06fc9d33debe67f022acc91ddabb56f929742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0f06fc9d33debe67f022acc91ddabb56f929742", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0f06fc9d33debe67f022acc91ddabb56f929742"}], "stats": {"total": 952, "additions": 820, "deletions": 132}, "files": [{"sha": "7b7caf766956e061dc9eb677be757c3df675ccac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d5a1a001f798a90fe6fcb031138740ce6ffb36/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d5a1a001f798a90fe6fcb031138740ce6ffb36/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9d5a1a001f798a90fe6fcb031138740ce6ffb36", "patch": "@@ -1,3 +1,49 @@\n+2015-01-15  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* tree-if-conv.c: Include hash-map.h.\n+\t(aggressive_if_conv): New variable.\n+\t(fold_build_cond_expr): Add simplification of non-zero condition.\n+\t(add_to_dst_predicate_list): Invoke add_to_predicate_list if edge\n+\tdestination block is not always executed.\n+\t(if_convertible_phi_p): Fix commentary, allow phi nodes have more\n+\tthan two predecessors if AGGRESSIVE_IF_CONV is true.\n+\t(if_convertible_stmt_p): Fix commentary.\n+\t(all_preds_critical_p): New function.\n+\t(has_pred_critical_p): New function.\n+\t(if_convertible_bb_p): Fix commentary, if AGGRESSIVE_IF_CONV is true\n+\tBB can have more than two predecessors and all incoming edges can be\n+\tcritical.\n+\t(predicate_bbs): Skip predication for loop exit block, use build2_loc\n+\tto compute predicate for true edge.\n+\t(find_phi_replacement_condition): Delete this function.\n+\t(is_cond_scalar_reduction): Add arguments ARG_0, ARG_1 and EXTENDED.\n+\tAllow interchange PHI arguments if EXTENDED is false.\n+\tChange check that block containing reduction statement candidate\n+\tis predecessor of phi-block since phi may have more than two arguments.\n+\t(phi_args_hash_traits): New helper structure.\n+\t(struct phi_args_hash_traits): New type.\n+\t(phi_args_hash_traits::hash): New function.\n+\t(phi_args_hash_traits::equal_keys): New function.\n+\t(gen_phi_arg_condition): New function.\n+\t(predicate_scalar_phi): Add handling of phi nodes with more than two\n+\targuments, delete COND and TRUE_BB arguments, insert body of\n+\tfind_phi_replacement_condition to predicate ordinary phi nodes.\n+\t(predicate_all_scalar_phis): Skip blocks with the only predecessor,\n+\tdelete call of find_phi_replacement_condition and invoke\n+\tpredicate_scalar_phi with two arguments.\n+\t(insert_gimplified_predicates): Add assert that non-predicated block\n+\tdon't have statements to insert.\n+\t(ifcvt_split_critical_edges): New function.\n+\t(ifcvt_split_def_stmt): Likewise.\n+\t(ifcvt_walk_pattern_tree): Likewise.\n+\t(stmt_is_root_of_bool_pattern): Likewise.\n+\t(ifcvt_repair_bool_pattern): Likewise.\n+\t(ifcvt_local_dce): Likewise.\n+\t(tree_if_conversion): Add initialization of AGGRESSIVE_IF_CONV which\n+\tis copy of inner or outer loop force_vectorize field, invoke\n+\tifcvt_split_critical_edges, ifcvt_local_dce and\n+\tifcvt_repair_bool_pattern for aggressive if-conversion.\n+\n 2015-01-15  Philipp Tomsich  <ptomsich@theobroma-systems.com>\n \n \t* config/aarch64/aarch64.md: Include xgene1.md."}, {"sha": "0659126c43341834ef10809cbbc0c81759d9c36c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d5a1a001f798a90fe6fcb031138740ce6ffb36/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d5a1a001f798a90fe6fcb031138740ce6ffb36/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e9d5a1a001f798a90fe6fcb031138740ce6ffb36", "patch": "@@ -1,3 +1,8 @@\n+2015-01-15  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* gcc.dg/vect/vect-aggressive-1.c: New.\n+\t* gcc.target/i386/avx2-vect-aggressive.c: New.\n+\n 2015-01-15  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.target/i386/pr54445-2.c: Adjust scan string for PIE."}, {"sha": "c9836e362f2be70eb14384d645206b8932736977", "filename": "gcc/testsuite/gcc.dg/vect/vect-aggressive-1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d5a1a001f798a90fe6fcb031138740ce6ffb36/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-aggressive-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d5a1a001f798a90fe6fcb031138740ce6ffb36/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-aggressive-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-aggressive-1.c?ref=e9d5a1a001f798a90fe6fcb031138740ce6ffb36", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+\n+#include <stdlib.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+int a[N];\n+int c[N];\n+\n+__attribute__ ((noinline)) int\n+foo (void)\n+{\n+  int i, res = 0;\n+#pragma omp simd safelen(8)\n+  for (i = 0; i < N; i++)\n+  {\n+    int t = a[i];\n+    if (c[i] != 0)\n+      if (t != 100 & t > 5)\n+\tres += 1;\n+  }\n+  return res;\n+}\n+\n+__attribute__ ((noinline)) int\n+hundred (void)\n+{\n+  return 100;\n+}\n+\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      c[i] = i & 1;\n+      switch (i & 3)\n+\t{\n+case 0:\n+\t  a[i] = hundred ();\n+\t  break;\n+case 1:\n+\t  a[i] = 1;\n+\t  break;\n+default:\n+\t  a[i] = i + 6;\n+\t  break;\n+\t}\n+    }\n+  if (foo () != 16)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "07f0821e573bb68db2e23928caaa9f6abeb00005", "filename": "gcc/testsuite/gcc.target/i386/avx2-vect-aggressive.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d5a1a001f798a90fe6fcb031138740ce6ffb36/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-aggressive.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d5a1a001f798a90fe6fcb031138740ce6ffb36/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-aggressive.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-aggressive.c?ref=e9d5a1a001f798a90fe6fcb031138740ce6ffb36", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-options \"-mavx2 -O3 -fopenmp-simd -fdump-tree-vect-details\" } */\n+\n+#include \"avx2-check.h\"\n+#define N 64\n+float a[N];\n+int c[N];\n+\n+__attribute__ ((noinline)) int\n+foo ()\n+{\n+  int i, res = 0;\n+#pragma omp simd safelen(8)\n+  for (i=0; i<N; i++)\n+  {\n+    float t = a[i];\n+    if (t > 0.0f & t < 1.0e+2f)\n+      if (c[i] != 0)\n+\tres += 1;\n+  }\n+  return res;\n+}\n+\n+__attribute__ ((noinline)) float\n+hundred ()\n+{\n+  return 100.0f;\n+}\n+\n+static void\n+avx2_test (void)\n+{\n+  int i, res;\n+  for (i=0; i<N; i++)\n+    {\n+      c[i] = i % 4;\n+      if (i < N / 2)\n+\ta[i] = (float) (i + 1);\n+      else\n+\ta[i] = (float) i + hundred ();\n+    }\n+  if (foo () != 24)\n+    abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "ade692a39ae460b4464072de7ee97ca60b9995d3", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 657, "deletions": 132, "changes": 789, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d5a1a001f798a90fe6fcb031138740ce6ffb36/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d5a1a001f798a90fe6fcb031138740ce6ffb36/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=e9d5a1a001f798a90fe6fcb031138740ce6ffb36", "patch": "@@ -145,10 +145,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"insn-codes.h\"\n #include \"optabs.h\"\n+#include \"hash-map.h\"\n \n /* List of basic blocks in if-conversion-suitable order.  */\n static basic_block *ifc_bbs;\n \n+/* Apply more aggressive (extended) if-conversion if true.  */\n+static bool aggressive_if_conv;\n+\n /* Structure used to predicate basic blocks.  This is attached to the\n    ->aux field of the BBs in the loop to be if-converted.  */\n typedef struct bb_predicate_s {\n@@ -391,6 +395,18 @@ static tree\n fold_build_cond_expr (tree type, tree cond, tree rhs, tree lhs)\n {\n   tree rhs1, lhs1, cond_expr;\n+\n+  /* If COND is comparison r != 0 and r has boolean type, convert COND\n+     to SSA_NAME to accept by vect bool pattern.  */\n+  if (TREE_CODE (cond) == NE_EXPR)\n+    {\n+      tree op0 = TREE_OPERAND (cond, 0);\n+      tree op1 = TREE_OPERAND (cond, 1);\n+      if (TREE_CODE (op0) == SSA_NAME\n+\t  && TREE_CODE (TREE_TYPE (op0)) == BOOLEAN_TYPE\n+\t  && (integer_zerop (op1)))\n+\tcond = op0;\n+    }\n   cond_expr = fold_ternary (COND_EXPR, type, cond,\n \t\t\t    rhs, lhs);\n \n@@ -505,7 +521,8 @@ add_to_dst_predicate_list (struct loop *loop, edge e,\n     cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\tprev_cond, cond);\n \n-  add_to_predicate_list (loop, e->dest, cond);\n+  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, e->dest))\n+    add_to_predicate_list (loop, e->dest, cond);\n }\n \n /* Return true if one of the successor edges of BB exits LOOP.  */\n@@ -532,7 +549,9 @@ bb_with_exit_edge_p (struct loop *loop, basic_block bb)\n    When the flag_tree_loop_if_convert_stores is not set, PHI is not\n    if-convertible if:\n    - a virtual PHI is immediately used in another PHI node,\n-   - there is a virtual PHI in a BB other than the loop->header.  */\n+   - there is a virtual PHI in a BB other than the loop->header.\n+   When the aggressive_if_conv is set, PHI can have more than\n+   two arguments.  */\n \n static bool\n if_convertible_phi_p (struct loop *loop, basic_block bb, gphi *phi,\n@@ -544,11 +563,15 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gphi *phi,\n       print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);\n     }\n \n-  if (bb != loop->header && gimple_phi_num_args (phi) != 2)\n+  if (bb != loop->header)\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"More than two phi node args.\\n\");\n-      return false;\n+      if (gimple_phi_num_args (phi) != 2\n+\t  && !aggressive_if_conv)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"More than two phi node args.\\n\");\n+\t  return false;\n+        }\n     }\n \n   if (flag_tree_loop_if_convert_stores || any_mask_load_store)\n@@ -915,7 +938,8 @@ if_convertible_gimple_assign_stmt_p (gimple stmt,\n \n    A statement is if-convertible if:\n    - it is an if-convertible GIMPLE_ASSIGN,\n-   - it is a GIMPLE_LABEL or a GIMPLE_COND.  */\n+   - it is a GIMPLE_LABEL or a GIMPLE_COND,\n+   - it is builtins call.  */\n \n static bool\n if_convertible_stmt_p (gimple stmt, vec<data_reference_p> refs,\n@@ -962,6 +986,35 @@ if_convertible_stmt_p (gimple stmt, vec<data_reference_p> refs,\n   return true;\n }\n \n+/* Assumes that BB has more than 1 predecessors.\n+   Returns false if at least one successor is not on critical edge\n+   and true otherwise.  */\n+\n+static inline bool\n+all_preds_critical_p (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (EDGE_COUNT (e->src->succs) == 1)\n+      return false;\n+  return true;\n+}\n+\n+/* Returns true if at least one successor in on critical edge.  */\n+static inline bool\n+has_pred_critical_p (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (EDGE_COUNT (e->src->succs) > 1)\n+      return true;\n+  return false;\n+}\n+\n /* Return true when BB is if-convertible.  This routine does not check\n    basic block's statements and phis.\n \n@@ -970,6 +1023,8 @@ if_convertible_stmt_p (gimple stmt, vec<data_reference_p> refs,\n    - it is after the exit block but before the latch,\n    - its edges are not normal.\n \n+   Last restriction is valid if aggressive_if_conv is false.\n+\n    EXIT_BB is the basic block containing the exit of the LOOP.  BB is\n    inside LOOP.  */\n \n@@ -982,8 +1037,11 @@ if_convertible_bb_p (struct loop *loop, basic_block bb, basic_block exit_bb)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"----------[%d]-------------\\n\", bb->index);\n \n+  if (EDGE_COUNT (bb->succs) > 2)\n+    return false;\n+\n   if (EDGE_COUNT (bb->preds) > 2\n-      || EDGE_COUNT (bb->succs) > 2)\n+      && !aggressive_if_conv)\n     return false;\n \n   if (exit_bb)\n@@ -1021,20 +1079,15 @@ if_convertible_bb_p (struct loop *loop, basic_block bb, basic_block exit_bb)\n \n   /* At least one incoming edge has to be non-critical as otherwise edge\n      predicates are not equal to basic-block predicates of the edge\n-     source.  */\n-  if (EDGE_COUNT (bb->preds) > 1\n-      && bb != loop->header)\n-    {\n-      bool found = false;\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (EDGE_COUNT (e->src->succs) == 1)\n-\t  found = true;\n-      if (!found)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"only critical predecessors\\n\");\n-\t  return false;\n-\t}\n+     source.  This check is skipped if aggressive_if_conv is true.  */\n+  if (!aggressive_if_conv\n+      && EDGE_COUNT (bb->preds) > 1\n+      && bb != loop->header\n+      && all_preds_critical_p (bb))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"only critical predecessors\\n\");\n+\treturn false;\n     }\n \n   return true;\n@@ -1146,11 +1199,12 @@ predicate_bbs (loop_p loop)\n       tree cond;\n       gimple stmt;\n \n-      /* The loop latch is always executed and has no extra conditions\n-\t to be processed: skip it.  */\n-      if (bb == loop->latch)\n+      /* The loop latch and loop exit block are always executed and\n+\t have no extra conditions to be processed: skip them.  */\n+      if (bb == loop->latch\n+\t  || bb_with_exit_edge_p (loop, bb))\n \t{\n-\t  reset_bb_predicate (loop->latch);\n+\t  reset_bb_predicate (bb);\n \t  continue;\n \t}\n \n@@ -1161,7 +1215,7 @@ predicate_bbs (loop_p loop)\n \t  tree c2;\n \t  edge true_edge, false_edge;\n \t  location_t loc = gimple_location (stmt);\n-\t  tree c = fold_build2_loc (loc, gimple_cond_code (stmt),\n+\t  tree c = build2_loc (loc, gimple_cond_code (stmt),\n \t\t\t\t    boolean_type_node,\n \t\t\t\t    gimple_cond_lhs (stmt),\n \t\t\t\t    gimple_cond_rhs (stmt));\n@@ -1383,60 +1437,6 @@ if_convertible_loop_p (struct loop *loop, bool *any_mask_load_store)\n   return res;\n }\n \n-/* Basic block BB has two predecessors.  Using predecessor's bb\n-   predicate, set an appropriate condition COND for the PHI node\n-   replacement.  Return the true block whose phi arguments are\n-   selected when cond is true.  LOOP is the loop containing the\n-   if-converted region, GSI is the place to insert the code for the\n-   if-conversion.  */\n-\n-static basic_block\n-find_phi_replacement_condition (basic_block bb, tree *cond,\n-\t\t\t\tgimple_stmt_iterator *gsi)\n-{\n-  edge first_edge, second_edge;\n-  tree tmp_cond;\n-\n-  gcc_assert (EDGE_COUNT (bb->preds) == 2);\n-  first_edge = EDGE_PRED (bb, 0);\n-  second_edge = EDGE_PRED (bb, 1);\n-\n-  /* Prefer an edge with a not negated predicate.\n-     ???  That's a very weak cost model.  */\n-  tmp_cond = bb_predicate (first_edge->src);\n-  gcc_assert (tmp_cond);\n-  if (TREE_CODE (tmp_cond) == TRUTH_NOT_EXPR)\n-    {\n-      edge tmp_edge;\n-\n-      tmp_edge = first_edge;\n-      first_edge = second_edge;\n-      second_edge = tmp_edge;\n-    }\n-\n-  /* Check if the edge we take the condition from is not critical.\n-     We know that at least one non-critical edge exists.  */\n-  if (EDGE_COUNT (first_edge->src->succs) > 1)\n-    {\n-      *cond = bb_predicate (second_edge->src);\n-\n-      if (TREE_CODE (*cond) == TRUTH_NOT_EXPR)\n-\t*cond = TREE_OPERAND (*cond, 0);\n-      else\n-\t/* Select non loop header bb.  */\n-\tfirst_edge = second_edge;\n-    }\n-  else\n-    *cond = bb_predicate (first_edge->src);\n-\n-  /* Gimplify the condition to a valid cond-expr conditonal operand.  */\n-  *cond = force_gimple_operand_gsi_1 (gsi, unshare_expr (*cond),\n-\t\t\t\t      is_gimple_condexpr, NULL_TREE,\n-\t\t\t\t      true, GSI_SAME_STMT);\n-\n-  return first_edge->src;\n-}\n-\n /* Returns true if def-stmt for phi argument ARG is simple increment/decrement\n    which is in predicated basic block.\n    In fact, the following PHI pattern is searching:\n@@ -1447,14 +1447,15 @@ find_phi_replacement_condition (basic_block bb, tree *cond,\n \t  reduc_3 = ...\n \treduc_2 = PHI <reduc_1, reduc_3>\n \n-   REDUC, OP0 and OP1 contain reduction stmt and its operands.  */\n+   ARG_0 and ARG_1 are correspondent PHI arguments.\n+   REDUC, OP0 and OP1 contain reduction stmt and its operands.\n+   EXTENDED is true if PHI has > 2 arguments.  */\n \n static bool\n-is_cond_scalar_reduction (gimple phi, gimple *reduc,\n-\t\t\t  tree *op0, tree *op1)\n+is_cond_scalar_reduction (gimple phi, gimple *reduc, tree arg_0, tree arg_1,\n+\t\t\t  tree *op0, tree *op1, bool extended)\n {\n   tree lhs, r_op1, r_op2;\n-  tree arg_0, arg_1;\n   gimple stmt;\n   gimple header_phi = NULL;\n   enum tree_code reduction_op;\n@@ -1463,13 +1464,13 @@ is_cond_scalar_reduction (gimple phi, gimple *reduc,\n   edge latch_e = loop_latch_edge (loop);\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n-\n-  arg_0 = PHI_ARG_DEF (phi, 0);\n-  arg_1 = PHI_ARG_DEF (phi, 1);\n+  edge e;\n+  edge_iterator ei;\n+  bool result = false;\n   if (TREE_CODE (arg_0) != SSA_NAME || TREE_CODE (arg_1) != SSA_NAME)\n     return false;\n \n-  if (gimple_code (SSA_NAME_DEF_STMT (arg_0)) == GIMPLE_PHI)\n+  if (!extended && gimple_code (SSA_NAME_DEF_STMT (arg_0)) == GIMPLE_PHI)\n     {\n       lhs = arg_1;\n       header_phi = SSA_NAME_DEF_STMT (arg_0);\n@@ -1500,8 +1501,13 @@ is_cond_scalar_reduction (gimple phi, gimple *reduc,\n     return false;\n \n   /* Check that stmt-block is predecessor of phi-block.  */\n-  if (EDGE_PRED (bb, 0)->src != gimple_bb (stmt)\n-      && EDGE_PRED (bb, 1)->src != gimple_bb (stmt))\n+  FOR_EACH_EDGE (e, ei, gimple_bb (stmt)->succs)\n+    if (e->dest == bb)\n+      {\n+\tresult = true;\n+\tbreak;\n+      }\n+  if (!result)\n     return false;\n \n   if (!has_single_use (lhs))\n@@ -1598,79 +1604,277 @@ convert_scalar_cond_reduction (gimple reduc, gimple_stmt_iterator *gsi,\n   return rhs;\n }\n \n+/* Helpers for PHI arguments hashtable map.  */\n+\n+struct phi_args_hash_traits : default_hashmap_traits\n+{\n+  static inline hashval_t hash (tree);\n+  static inline bool equal_keys (tree, tree);\n+};\n+\n+inline hashval_t\n+phi_args_hash_traits::hash (tree value)\n+{\n+  return iterative_hash_expr (value, 0);\n+}\n+\n+inline bool\n+phi_args_hash_traits::equal_keys (tree value1, tree value2)\n+{\n+  return operand_equal_p (value1, value2, 0);\n+}\n+\n+  /* Produce condition for all occurrences of ARG in PHI node.  */\n+\n+static tree\n+gen_phi_arg_condition (gphi *phi, vec<int> *occur,\n+\t\t       gimple_stmt_iterator *gsi)\n+{\n+  int len;\n+  int i;\n+  tree cond = NULL_TREE;\n+  tree c;\n+  edge e;\n+\n+  len = occur->length ();\n+  gcc_assert (len > 0);\n+  for (i = 0; i < len; i++)\n+    {\n+      e = gimple_phi_arg_edge (phi, (*occur)[i]);\n+      c = bb_predicate (e->src);\n+      if (is_true_predicate (c))\n+\tcontinue;\n+      c = force_gimple_operand_gsi_1 (gsi, unshare_expr (c),\n+\t\t\t\t      is_gimple_condexpr, NULL_TREE,\n+\t\t\t\t      true, GSI_SAME_STMT);\n+      if (cond != NULL_TREE)\n+\t{\n+\t  /* Must build OR expression.  */\n+\t  cond = fold_or_predicates (EXPR_LOCATION (c), c, cond);\n+\t  cond = force_gimple_operand_gsi_1 (gsi, unshare_expr (cond),\n+\t\t\t\t\t     is_gimple_condexpr, NULL_TREE,\n+\t\t\t\t\t     true, GSI_SAME_STMT);\n+\t}\n+      else\n+\tcond = c;\n+    }\n+  gcc_assert (cond != NULL_TREE);\n+  return cond;\n+}\n+\n /* Replace a scalar PHI node with a COND_EXPR using COND as condition.\n-   This routine does not handle PHI nodes with more than two\n-   arguments.\n+   This routine can handle PHI nodes with more than two arguments.\n \n    For example,\n      S1: A = PHI <x1(1), x2(5)>\n    is converted into,\n      S2: A = cond ? x1 : x2;\n \n    The generated code is inserted at GSI that points to the top of\n-   basic block's statement list.  When COND is true, phi arg from\n-   TRUE_BB is selected.  */\n+   basic block's statement list.\n+   If PHI node has more than two arguments a chain of conditional\n+   expression is produced.  */\n+\n \n static void\n-predicate_scalar_phi (gphi *phi, tree cond,\n-\t\t      basic_block true_bb,\n-\t\t      gimple_stmt_iterator *gsi)\n+predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n {\n-  gimple new_stmt;\n+  gimple new_stmt = NULL, reduc;\n+  tree rhs, res, arg0, arg1, op0, op1, scev;\n+  tree cond;\n+  unsigned int index0;\n+  unsigned int max, args_len;\n+  edge e;\n   basic_block bb;\n-  tree rhs, res, arg, scev;\n-\n-  gcc_assert (gimple_code (phi) == GIMPLE_PHI\n-\t      && gimple_phi_num_args (phi) == 2);\n+  unsigned int i;\n \n   res = gimple_phi_result (phi);\n-  /* Do not handle virtual phi nodes.  */\n   if (virtual_operand_p (res))\n     return;\n \n-  bb = gimple_bb (phi);\n-\n-  if ((arg = degenerate_phi_result (phi))\n+  if ((rhs = degenerate_phi_result (phi))\n       || ((scev = analyze_scalar_evolution (gimple_bb (phi)->loop_father,\n \t\t\t\t\t    res))\n \t  && !chrec_contains_undetermined (scev)\n \t  && scev != res\n-\t  && (arg = gimple_phi_arg_def (phi, 0))))\n-    rhs = arg;\n-  else\n+\t  && (rhs = gimple_phi_arg_def (phi, 0))))\n     {\n-      tree arg_0, arg_1;\n-      tree op0, op1;\n-      gimple reduc;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Degenerate phi!\\n\");\n+\t  print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);\n+\t}\n+      new_stmt = gimple_build_assign (res, rhs);\n+      gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+      update_stmt (new_stmt);\n+      return;\n+    }\n \n-      /* Use condition that is not TRUTH_NOT_EXPR in conditional modify expr.  */\n+  bb = gimple_bb (phi);\n+  if (EDGE_COUNT (bb->preds) == 2)\n+    {\n+      /* Predicate ordinary PHI node with 2 arguments.  */\n+      edge first_edge, second_edge;\n+      basic_block true_bb;\n+      first_edge = EDGE_PRED (bb, 0);\n+      second_edge = EDGE_PRED (bb, 1);\n+      cond = bb_predicate (first_edge->src);\n+      if (TREE_CODE (cond) == TRUTH_NOT_EXPR)\n+\t{\n+\t  edge tmp_edge = first_edge;\n+\t  first_edge = second_edge;\n+\t  second_edge = tmp_edge;\n+\t}\n+      if (EDGE_COUNT (first_edge->src->succs) > 1)\n+\t{\n+\t  cond = bb_predicate (second_edge->src);\n+\t  if (TREE_CODE (cond) == TRUTH_NOT_EXPR)\n+\t    cond = TREE_OPERAND (cond, 0);\n+\t  else\n+\t    first_edge = second_edge;\n+\t}\n+      else\n+\tcond = bb_predicate (first_edge->src);\n+      /* Gimplify the condition to a valid cond-expr conditonal operand.  */\n+      cond = force_gimple_operand_gsi_1 (gsi, unshare_expr (cond),\n+\t\t\t\t\t is_gimple_condexpr, NULL_TREE,\n+\t\t\t\t\t true, GSI_SAME_STMT);\n+      true_bb = first_edge->src;\n       if (EDGE_PRED (bb, 1)->src == true_bb)\n \t{\n-\t  arg_0 = gimple_phi_arg_def (phi, 1);\n-\t  arg_1 = gimple_phi_arg_def (phi, 0);\n+\t  arg0 = gimple_phi_arg_def (phi, 1);\n+\t  arg1 = gimple_phi_arg_def (phi, 0);\n \t}\n       else\n \t{\n-\t  arg_0 = gimple_phi_arg_def (phi, 0);\n-\t  arg_1 = gimple_phi_arg_def (phi, 1);\n+\t  arg0 = gimple_phi_arg_def (phi, 0);\n+\t  arg1 = gimple_phi_arg_def (phi, 1);\n \t}\n-      if (is_cond_scalar_reduction (phi, &reduc, &op0, &op1))\n+      if (is_cond_scalar_reduction (phi, &reduc, arg0, arg1,\n+\t\t\t\t    &op0, &op1, false))\n \t/* Convert reduction stmt into vectorizable form.  */\n \trhs = convert_scalar_cond_reduction (reduc, gsi, cond, op0, op1,\n \t\t\t\t\t     true_bb != gimple_bb (reduc));\n       else\n \t/* Build new RHS using selected condition and arguments.  */\n \trhs = fold_build_cond_expr (TREE_TYPE (res), unshare_expr (cond),\n-\t\t\t\t    arg_0, arg_1);\n+\t\t\t\t    arg0, arg1);\n+      new_stmt = gimple_build_assign (res, rhs);\n+      gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+      update_stmt (new_stmt);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"new phi replacement stmt\\n\");\n+\t  print_gimple_stmt (dump_file, new_stmt, 0, TDF_SLIM);\n+\t}\n+      return;\n+    }\n+\n+  /* Create hashmap for PHI node which contain vector of argument indexes\n+     having the same value.  */\n+  bool swap = false;\n+  hash_map<tree, auto_vec<int>, phi_args_hash_traits> phi_arg_map;\n+  unsigned int num_args = gimple_phi_num_args (phi);\n+  int max_ind = -1;\n+  /* Vector of different PHI argument values.  */\n+  auto_vec<tree> args (num_args);\n+\n+  /* Compute phi_arg_map.  */\n+  for (i = 0; i < num_args; i++)\n+    {\n+      tree arg;\n+\n+      arg = gimple_phi_arg_def (phi, i);\n+      if (!phi_arg_map.get (arg))\n+\targs.quick_push (arg);\n+      phi_arg_map.get_or_insert (arg).safe_push (i);\n+    }\n+\n+  /* Determine element with max number of occurrences.  */\n+  max_ind = -1;\n+  max = 1;\n+  args_len = args.length ();\n+  for (i = 0; i < args_len; i++)\n+    {\n+      unsigned int len;\n+      if ((len = phi_arg_map.get (args[i])->length ()) > max)\n+\t{\n+\t  max_ind = (int) i;\n+\t  max = len;\n+\t}\n+    }\n+\n+  /* Put element with max number of occurences to the end of ARGS.  */\n+  if (max_ind != -1 && max_ind +1 != (int) args_len)\n+    {\n+      tree tmp = args[args_len - 1];\n+      args[args_len - 1] = args[max_ind];\n+      args[max_ind] = tmp;\n     }\n \n-  new_stmt = gimple_build_assign (res, rhs);\n-  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n-  update_stmt (new_stmt);\n+  /* Handle one special case when number of arguments with different values\n+     is equal 2 and one argument has the only occurrence.  Such PHI can be\n+     handled as if would have only 2 arguments.  */\n+  if (args_len == 2 && phi_arg_map.get (args[0])->length () == 1)\n+    {\n+      vec<int> *indexes;\n+      indexes = phi_arg_map.get (args[0]);\n+      index0 = (*indexes)[0];\n+      arg0 = args[0];\n+      arg1 = args[1];\n+      e = gimple_phi_arg_edge (phi, index0);\n+      cond = bb_predicate (e->src);\n+      if (TREE_CODE (cond) == TRUTH_NOT_EXPR)\n+\t{\n+\t  swap = true;\n+\t  cond = TREE_OPERAND (cond, 0);\n+\t}\n+      /* Gimplify the condition to a valid cond-expr conditonal operand.  */\n+      cond = force_gimple_operand_gsi_1 (gsi, unshare_expr (cond),\n+\t\t\t\t\t is_gimple_condexpr, NULL_TREE,\n+\t\t\t\t\t true, GSI_SAME_STMT);\n+      if (!(is_cond_scalar_reduction (phi, &reduc, arg0 , arg1,\n+\t\t\t\t      &op0, &op1, true)))\n+\trhs = fold_build_cond_expr (TREE_TYPE (res), unshare_expr (cond),\n+\t\t\t\t    swap? arg1 : arg0,\n+\t\t\t\t    swap? arg0 : arg1);\n+      else\n+\t/* Convert reduction stmt into vectorizable form.  */\n+\trhs = convert_scalar_cond_reduction (reduc, gsi, cond, op0, op1,\n+\t\t\t\t\t     swap);\n+      new_stmt = gimple_build_assign (res, rhs);\n+      gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+      update_stmt (new_stmt);\n+    }\n+  else\n+    {\n+      /* Common case.  */\n+      vec<int> *indexes;\n+      tree type = TREE_TYPE (gimple_phi_result (phi));\n+      tree lhs;\n+      arg1 = args[1];\n+      for (i = 0; i < args_len; i++)\n+\t{\n+\t  arg0 = args[i];\n+\t  indexes = phi_arg_map.get (args[i]);\n+\t  if (i != args_len - 1)\n+\t    lhs = make_temp_ssa_name (type, NULL, \"_ifc_\");\n+\t  else\n+\t    lhs = res;\n+\t  cond = gen_phi_arg_condition (phi, indexes, gsi);\n+\t  rhs = fold_build_cond_expr (type, unshare_expr (cond),\n+\t\t\t\t      arg0, arg1);\n+\t  new_stmt = gimple_build_assign (lhs, rhs);\n+\t  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+\t  update_stmt (new_stmt);\n+\t  arg1 = lhs;\n+\t}\n+    }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"new phi replacement stmt\\n\");\n+      fprintf (dump_file, \"new extended phi replacement stmt\\n\");\n       print_gimple_stmt (dump_file, new_stmt, 0, TDF_SLIM);\n     }\n }\n@@ -1688,28 +1892,25 @@ predicate_all_scalar_phis (struct loop *loop)\n   for (i = 1; i < orig_loop_num_nodes; i++)\n     {\n       gphi *phi;\n-      tree cond = NULL_TREE;\n       gimple_stmt_iterator gsi;\n       gphi_iterator phi_gsi;\n-      basic_block true_bb = NULL;\n       bb = ifc_bbs[i];\n \n       if (bb == loop->header)\n \tcontinue;\n \n+      if (EDGE_COUNT (bb->preds) == 1)\n+\tcontinue;\n+\n       phi_gsi = gsi_start_phis (bb);\n       if (gsi_end_p (phi_gsi))\n \tcontinue;\n \n-      /* BB has two predecessors.  Using predecessor's aux field, set\n-\t appropriate condition for the PHI node replacement.  */\n       gsi = gsi_after_labels (bb);\n-      true_bb = find_phi_replacement_condition (bb, &cond, &gsi);\n-\n       while (!gsi_end_p (phi_gsi))\n \t{\n \t  phi = phi_gsi.phi ();\n-\t  predicate_scalar_phi (phi, cond, true_bb, &gsi);\n+\t  predicate_scalar_phi (phi, &gsi);\n \t  release_phi_node (phi);\n \t  gsi_next (&phi_gsi);\n \t}\n@@ -1730,7 +1931,8 @@ insert_gimplified_predicates (loop_p loop, bool any_mask_load_store)\n     {\n       basic_block bb = ifc_bbs[i];\n       gimple_seq stmts;\n-\n+      if (!is_predicated (bb))\n+\tgcc_assert (bb_predicate_gimplified_stmts (bb) == NULL);\n       if (!is_predicated (bb))\n \t{\n \t  /* Do not insert statements for a basic block that is not\n@@ -2154,6 +2356,307 @@ version_loop_for_if_conversion (struct loop *loop)\n   return true;\n }\n \n+/* Performs splitting of critical edges if aggressive_if_conv is true.\n+   Returns false if loop won't be if converted and true otherwise.  */\n+\n+static bool\n+ifcvt_split_critical_edges (struct loop *loop)\n+{\n+  basic_block *body;\n+  basic_block bb;\n+  unsigned int num = loop->num_nodes;\n+  unsigned int i;\n+  gimple stmt;\n+  edge e;\n+  edge_iterator ei;\n+\n+  if (num <= 2)\n+    return false;\n+  if (loop->inner)\n+    return false;\n+  if (!single_exit (loop))\n+    return false;\n+\n+  body = get_loop_body (loop);\n+  for (i = 0; i < num; i++)\n+    {\n+      bb = body[i];\n+      if (bb == loop->latch\n+\t  || bb_with_exit_edge_p (loop, bb))\n+\tcontinue;\n+      stmt = last_stmt (bb);\n+      /* Skip basic blocks not ending with conditional branch.  */\n+      if (!(stmt && gimple_code (stmt) == GIMPLE_COND))\n+\tcontinue;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (EDGE_CRITICAL_P (e) && e->dest->loop_father == loop)\n+\t  split_edge (e);\n+    }\n+  free (body);\n+  return true;\n+}\n+\n+/* Assumes that lhs of DEF_STMT have multiple uses.\n+   Delete one use by (1) creation of copy DEF_STMT with\n+   unique lhs; (2) change original use of lhs in one\n+   use statement with newly created lhs.  */\n+\n+static void\n+ifcvt_split_def_stmt (gimple def_stmt, gimple use_stmt)\n+{\n+  tree var;\n+  tree lhs;\n+  gimple copy_stmt;\n+  gimple_stmt_iterator gsi;\n+  use_operand_p use_p;\n+  imm_use_iterator imm_iter;\n+\n+  var = gimple_assign_lhs (def_stmt);\n+  copy_stmt = gimple_copy (def_stmt);\n+  lhs = make_temp_ssa_name (TREE_TYPE (var), NULL, \"_ifc_\");\n+  gimple_assign_set_lhs (copy_stmt, lhs);\n+  SSA_NAME_DEF_STMT (lhs) = copy_stmt;\n+  /* Insert copy of DEF_STMT.  */\n+  gsi = gsi_for_stmt (def_stmt);\n+  gsi_insert_after (&gsi, copy_stmt, GSI_SAME_STMT);\n+  /* Change use of var to lhs in use_stmt.  */\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Change use of var  \");\n+      print_generic_expr (dump_file, var, TDF_SLIM);\n+      fprintf (dump_file, \" to \");\n+      print_generic_expr (dump_file, lhs, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n+    {\n+      if (USE_STMT (use_p) != use_stmt)\n+\tcontinue;\n+      SET_USE (use_p, lhs);\n+      break;\n+    }\n+}\n+\n+/* Traverse bool pattern recursively starting from VAR.\n+   Save its def and use statements to defuse_list if VAR does\n+   not have single use.  */\n+\n+static void\n+ifcvt_walk_pattern_tree (tree var, vec<gimple> *defuse_list,\n+\t\t\t gimple use_stmt)\n+{\n+  tree rhs1, rhs2;\n+  enum tree_code code;\n+  gimple def_stmt;\n+\n+  def_stmt = SSA_NAME_DEF_STMT (var);\n+  if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n+    return;\n+  if (!has_single_use (var))\n+    {\n+      /* Put def and use stmts into defuse_list.  */\n+      defuse_list->safe_push (def_stmt);\n+      defuse_list->safe_push (use_stmt);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Multiple lhs uses in stmt\\n\");\n+\t  print_gimple_stmt (dump_file, def_stmt, 0, TDF_SLIM);\n+\t}\n+    }\n+  rhs1 = gimple_assign_rhs1 (def_stmt);\n+  code = gimple_assign_rhs_code (def_stmt);\n+  switch (code)\n+    {\n+    case SSA_NAME:\n+      ifcvt_walk_pattern_tree (rhs1, defuse_list, def_stmt);\n+      break;\n+    CASE_CONVERT:\n+      if ((TYPE_PRECISION (TREE_TYPE (rhs1)) != 1\n+\t   || !TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n+\t  && TREE_CODE (TREE_TYPE (rhs1)) != BOOLEAN_TYPE)\n+\tbreak;\n+      ifcvt_walk_pattern_tree (rhs1, defuse_list, def_stmt);\n+      break;\n+    case BIT_NOT_EXPR:\n+      ifcvt_walk_pattern_tree (rhs1, defuse_list, def_stmt);\n+      break;\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+      ifcvt_walk_pattern_tree (rhs1, defuse_list, def_stmt);\n+      rhs2 = gimple_assign_rhs2 (def_stmt);\n+      ifcvt_walk_pattern_tree (rhs2, defuse_list, def_stmt);\n+      break;\n+    default:\n+      break;\n+    }\n+  return;\n+}\n+\n+/* Returns true if STMT can be a root of bool pattern apllied\n+   by vectorizer.  VAR contains SSA_NAME which starts pattern.  */\n+\n+static bool\n+stmt_is_root_of_bool_pattern (gimple stmt, tree *var)\n+{\n+  enum tree_code code;\n+  tree lhs, rhs;\n+\n+  code = gimple_assign_rhs_code (stmt);\n+  if (CONVERT_EXPR_CODE_P (code))\n+    {\n+      lhs = gimple_assign_lhs (stmt);\n+      rhs = gimple_assign_rhs1 (stmt);\n+      if (TREE_CODE (TREE_TYPE (rhs)) != BOOLEAN_TYPE)\n+\treturn false;\n+      if (TREE_CODE (TREE_TYPE (lhs)) == BOOLEAN_TYPE)\n+\treturn false;\n+      *var = rhs;\n+      return true;\n+    }\n+  else if (code == COND_EXPR)\n+    {\n+      rhs = gimple_assign_rhs1 (stmt);\n+      if (TREE_CODE (rhs) != SSA_NAME)\n+\treturn false;\n+      *var = rhs;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/*  Traverse all statements in BB which correspondent to loop header to\n+    find out all statements which can start bool pattern applied by\n+    vectorizer and convert multiple uses in it to conform pattern\n+    restrictions.  Such case can occur if the same predicate is used both\n+    for phi node conversion and load/store mask.  */\n+\n+static void\n+ifcvt_repair_bool_pattern (basic_block bb)\n+{\n+  tree rhs;\n+  gimple stmt;\n+  gimple_stmt_iterator gsi;\n+  vec<gimple> defuse_list = vNULL;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      stmt = gsi_stmt (gsi);\n+      if (gimple_code (stmt) != GIMPLE_ASSIGN)\n+\tcontinue;\n+      if (!stmt_is_root_of_bool_pattern (stmt, &rhs))\n+\tcontinue;\n+      ifcvt_walk_pattern_tree (rhs, &defuse_list, stmt);\n+      while (defuse_list.length () > 0)\n+\t{\n+\t  gimple def_stmt, use_stmt;\n+\t  use_stmt = defuse_list.pop ();\n+\t  def_stmt = defuse_list.pop ();\n+\t  ifcvt_split_def_stmt (def_stmt, use_stmt);\n+\t}\n+    }\n+}\n+\n+/* Delete redundant statements produced by predication which prevents\n+   loop vectorization.  */\n+\n+static void\n+ifcvt_local_dce (basic_block bb)\n+{\n+  gimple stmt;\n+  gimple stmt1;\n+  gimple phi;\n+  gimple_stmt_iterator gsi;\n+  vec<gimple> worklist;\n+  enum gimple_code code;\n+  use_operand_p use_p;\n+  imm_use_iterator imm_iter;\n+\n+  worklist.create (64);\n+  /* Consider all phi as live statements.  */\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      phi = gsi_stmt (gsi);\n+      gimple_set_plf (phi, GF_PLF_2, true);\n+      worklist.safe_push (phi);\n+    }\n+  /* Consider load/store statemnts, CALL and COND as live.  */\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      stmt = gsi_stmt (gsi);\n+      if (gimple_store_p (stmt)\n+\t  || gimple_assign_load_p (stmt)\n+\t  || is_gimple_debug (stmt))\n+\t{\n+\t  gimple_set_plf (stmt, GF_PLF_2, true);\n+\t  worklist.safe_push (stmt);\n+\t  continue;\n+\t}\n+      code = gimple_code (stmt);\n+      if (code == GIMPLE_COND || code == GIMPLE_CALL)\n+\t{\n+\t  gimple_set_plf (stmt, GF_PLF_2, true);\n+\t  worklist.safe_push (stmt);\n+\t  continue;\n+\t}\n+      gimple_set_plf (stmt, GF_PLF_2, false);\n+\n+      if (code == GIMPLE_ASSIGN)\n+\t{\n+\t  tree lhs = gimple_assign_lhs (stmt);\n+\t  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+\t    {\n+\t      stmt1 = USE_STMT (use_p);\n+\t      if (gimple_bb (stmt1) != bb)\n+\t\t{\n+\t\t  gimple_set_plf (stmt, GF_PLF_2, true);\n+\t\t  worklist.safe_push (stmt);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  /* Propagate liveness through arguments of live stmt.  */\n+  while (worklist.length () > 0)\n+    {\n+      ssa_op_iter iter;\n+      use_operand_p use_p;\n+      tree use;\n+\n+      stmt = worklist.pop ();\n+      FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n+\t{\n+\t  use = USE_FROM_PTR (use_p);\n+\t  if (TREE_CODE (use) != SSA_NAME)\n+\t    continue;\n+\t  stmt1 = SSA_NAME_DEF_STMT (use);\n+\t  if (gimple_bb (stmt1) != bb\n+\t      || gimple_plf (stmt1, GF_PLF_2))\n+\t    continue;\n+\t  gimple_set_plf (stmt1, GF_PLF_2, true);\n+\t  worklist.safe_push (stmt1);\n+\t}\n+    }\n+  /* Delete dead statements.  */\n+  gsi = gsi_start_bb (bb);\n+  while (!gsi_end_p (gsi))\n+    {\n+      stmt = gsi_stmt (gsi);\n+      if (gimple_plf (stmt, GF_PLF_2))\n+\t{\n+\t  gsi_next (&gsi);\n+\t  continue;\n+\t}\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Delete dead stmt in bb#%d\\n\", bb->index);\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t}\n+      gsi_remove (&gsi, true);\n+      release_defs (stmt);\n+    }\n+}\n+\n /* If-convert LOOP when it is legal.  For the moment this pass has no\n    profitability analysis.  Returns non-zero todo flags when something\n    changed.  */\n@@ -2165,6 +2668,20 @@ tree_if_conversion (struct loop *loop)\n   ifc_bbs = NULL;\n   bool any_mask_load_store = false;\n \n+  /* Set-up aggressive if-conversion for loops marked with simd pragma.  */\n+  aggressive_if_conv = loop->force_vectorize;\n+  /* Check either outer loop was marked with simd pragma.  */\n+  if (!aggressive_if_conv)\n+    {\n+      struct loop *outer_loop = loop_outer (loop);\n+      if (outer_loop && outer_loop->force_vectorize)\n+\taggressive_if_conv = true;\n+    }\n+\n+  if (aggressive_if_conv)\n+    if (!ifcvt_split_critical_edges (loop))\n+      goto cleanup;\n+\n   if (!if_convertible_loop_p (loop, &any_mask_load_store)\n       || !dbg_cnt (if_conversion_tree))\n     goto cleanup;\n@@ -2182,6 +2699,14 @@ tree_if_conversion (struct loop *loop)\n      on-the-fly.  */\n   combine_blocks (loop, any_mask_load_store);\n \n+  /* Delete dead predicate computations and repair tree correspondent\n+     to bool pattern to delete multiple uses of preidcates.  */\n+  if (aggressive_if_conv)\n+    {\n+      ifcvt_local_dce (loop->header);\n+      ifcvt_repair_bool_pattern (loop->header);\n+    }\n+\n   todo |= TODO_cleanup_cfg;\n   if (flag_tree_loop_if_convert_stores || any_mask_load_store)\n     {"}]}