{"sha": "f4390da0c537d637e6aa582f68c65bac13396196", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQzOTBkYTBjNTM3ZDYzN2U2YWE1ODJmNjhjNjViYWMxMzM5NjE5Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-03-13T04:43:33Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-03-13T04:43:33Z"}, "message": "compiler: add new debugging helper function debug_go_type()\n    \n    Add a new debugging utility routine debug_go_type(), intended to\n    display the contents of a Type object in a way useful to debugging\n    a run of the compiler.  Prior to this the only useful alternative\n    for debugging types was invoking the mangled_name() method, which\n    has problems (for example, won't work on interface types prior\n    to finalizing of methods).\n    \n    This is a \"deep\" dump, meaning that all types reachable from the\n    type passed to debug_go_type() will be printed out. Example:\n    \n    (gdb) print debug_go_type(t1)\n          T0        0x535f300  'net/http.Header' -> T1\n          T1        0x535d3d0  map ['string' -> string] T4\n          T2        0x5304bb0  'string' -> string\n          T3        0x331f900  string\n          T4        0x535d370  array [] 'string' -> string\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/166637\n\nFrom-SVN: r269633", "tree": {"sha": "7fc3215fb12fb17da8347ab761ef8c7cebfafc36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fc3215fb12fb17da8347ab761ef8c7cebfafc36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4390da0c537d637e6aa582f68c65bac13396196", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4390da0c537d637e6aa582f68c65bac13396196", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4390da0c537d637e6aa582f68c65bac13396196", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4390da0c537d637e6aa582f68c65bac13396196/comments", "author": null, "committer": null, "parents": [{"sha": "50e021a590c75eae2ad86d3874b29eedf63b9646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e021a590c75eae2ad86d3874b29eedf63b9646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e021a590c75eae2ad86d3874b29eedf63b9646"}], "stats": {"total": 391, "additions": 388, "deletions": 3}, "files": [{"sha": "5104e7b3dba6c45b07ef126dbd336c2db12938e1", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4390da0c537d637e6aa582f68c65bac13396196/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4390da0c537d637e6aa582f68c65bac13396196/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f4390da0c537d637e6aa582f68c65bac13396196", "patch": "@@ -1,4 +1,4 @@\n-3106ec19626d75d8275be16c86421132548fa13e\n+565b5cd0f49a00ca20941ea042c07ebe6ddf3553\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "0e90373ff07e2691fcd6b5ac50fb01e1ab1c6a14", "filename": "gcc/go/gofrontend/ast-dump.cc", "status": "modified", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4390da0c537d637e6aa582f68c65bac13396196/gcc%2Fgo%2Fgofrontend%2Fast-dump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4390da0c537d637e6aa582f68c65bac13396196/gcc%2Fgo%2Fgofrontend%2Fast-dump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fast-dump.cc?ref=f4390da0c537d637e6aa582f68c65bac13396196", "patch": "@@ -8,6 +8,7 @@\n \n #include <iostream>\n #include <fstream>\n+#include <sstream>\n \n #include \"gogo.h\"\n #include \"expressions.h\"\n@@ -580,3 +581,382 @@ debug_go_block_deep(const Block* block)\n   Block* ncblock = const_cast<Block*>(block);\n   adc.dump_block(ncblock);\n }\n+\n+class Type_dumper\n+{\n+  typedef Unordered_map(const Type*, unsigned) idx_map;\n+ public:\n+  Type_dumper(const Type* type)\n+      : top_(type), ntypes_(0)\n+  {\n+    this->worklist_.push_back(type);\n+  }\n+\n+  void visit();\n+\n+  std::string stringResult() { return ss_.str(); }\n+\n+ private:\n+  void emitpre(unsigned tag, const Type* addr);\n+  void typeref(const char*, const Type*, const char *);\n+  void visit_forward_declaration_type(const Forward_declaration_type* fdt);\n+  void visit_function_type(const Function_type* ft);\n+  void visit_struct_type(const Struct_type* st);\n+  void visit_array_type(const Array_type* at);\n+  void visit_map_type(const Map_type* mt);\n+  void visit_channel_type(const Channel_type* mt);\n+  void visit_interface_type(const Interface_type* mt);\n+  void visit_methods(const Typed_identifier_list* methods,\n+                     const char *tag);\n+  std::pair<bool, unsigned> lookup(const Type*);\n+\n+  static constexpr unsigned notag = 0xffffffff;\n+\n+ private:\n+  const Type* top_;\n+  idx_map types_;\n+  unsigned ntypes_;\n+  std::list<const Type*> worklist_;\n+  std::ostringstream ss_;\n+};\n+\n+// Look up a type, installing it in 'types_'. Return is <found, N>\n+// where 'found' is true if type had been previously recorded, and N\n+// is the index/tag assigned to N.  The input argument is appended to\n+// the work list if this is the first time we've seen it.\n+\n+std::pair<bool, unsigned> Type_dumper::lookup(const Type* t)\n+{\n+  std::pair<const Type*, unsigned> entry = std::make_pair(t, this->ntypes_);\n+  std::pair<idx_map::iterator, bool> ins = this->types_.insert(entry);\n+  if (ins.second)\n+    {\n+      this->ntypes_++;\n+      if (t != this->top_)\n+        this->worklist_.push_back(t);\n+    }\n+  return std::make_pair(ins.second, ins.first->second);\n+}\n+\n+// Emit preamble prior to dumping a type, including the type\n+// pointer itself and the tag we've assigned it.  If no\n+// tag is specified (via special \"notag\" value) and/or the\n+// pointer is null, then just emit an equivalent amount\n+// of spaces.\n+\n+void Type_dumper::emitpre(unsigned tag, const Type* ptr)\n+{\n+  char tbuf[50], pbuf[50], buf[200];\n+\n+  tbuf[0] = '\\0';\n+  if (tag != notag)\n+    snprintf(tbuf, sizeof tbuf, \"T%u\", tag);\n+\n+  pbuf[0] = '\\0';\n+  if (ptr != NULL)\n+    snprintf(pbuf, sizeof pbuf, \"%p\", (const void*) ptr);\n+\n+  snprintf(buf, sizeof buf, \"%8s %16s  \", tbuf, pbuf);\n+  this->ss_ << buf;\n+}\n+\n+// Emit a reference to a type into the dump buffer. In most cases this means\n+// just the type tag, but for named types we also emit the name, and for\n+// simple/primitive types (ex: int64) we emit the type itself. If \"pref\" is\n+// non-NULL, emit the string prior to the reference, and if \"suf\" is non-NULL,\n+// emit it following the reference.\n+\n+void Type_dumper::typeref(const char* pref, const Type* t, const char* suf)\n+{\n+  if (pref != NULL)\n+    this->ss_ << pref;\n+  std::pair<bool, unsigned> p = this->lookup(t);\n+  unsigned tag = p.second;\n+  switch (t->classification())\n+    {\n+      case Type::TYPE_NAMED:\n+        {\n+          const Named_type* nt = t->named_type();\n+          const Named_object* no = nt->named_object();\n+          this->ss_ << \"'\" << no->message_name() << \"' -> \";\n+          const Type* underlying = nt->real_type();\n+          this->typeref(NULL, underlying, NULL);\n+          break;\n+        }\n+      case Type::TYPE_POINTER:\n+        this->typeref(\"*\", t->points_to(), NULL);\n+        break;\n+      case Type::TYPE_ERROR:\n+        this->ss_ << \"error_type\";\n+        break;\n+      case Type::TYPE_INTEGER:\n+        {\n+          const Integer_type* it = t->integer_type();\n+          if (it->is_abstract())\n+            this->ss_ << \"abstract_int\";\n+          else\n+            this->ss_ << (it->is_unsigned() ? \"u\" : \"\") << \"int\" << it->bits();\n+          break;\n+        }\n+      case Type::TYPE_FLOAT:\n+        {\n+          const Float_type* ft = t->float_type();\n+          if (ft->is_abstract())\n+            this->ss_ << \"abstract_float\";\n+          else\n+            this->ss_ << \"float\" << ft->bits();\n+          break;\n+        }\n+      case Type::TYPE_COMPLEX:\n+        {\n+          const Complex_type* ct = t->complex_type();\n+          if (ct->is_abstract())\n+            this->ss_ << \"abstract_complex\";\n+          else\n+            this->ss_ << \"complex\" << ct->bits();\n+          break;\n+        }\n+      case Type::TYPE_BOOLEAN:\n+        this->ss_ << \"bool\";\n+        break;\n+      case Type::TYPE_STRING:\n+        this->ss_ << \"string\";\n+        break;\n+      case Type::TYPE_NIL:\n+        this->ss_ << \"nil_type\";\n+        break;\n+    case Type::TYPE_VOID:\n+        this->ss_ << \"void_type\";\n+        break;\n+    case Type::TYPE_FUNCTION:\n+    case Type::TYPE_STRUCT:\n+    case Type::TYPE_ARRAY:\n+    case Type::TYPE_MAP:\n+    case Type::TYPE_CHANNEL:\n+    case Type::TYPE_FORWARD:\n+    case Type::TYPE_INTERFACE:\n+      this->ss_ << \"T\" << tag;\n+      break;\n+\n+    default:\n+      // This is a debugging routine, so instead of a go_unreachable()\n+      // issue a warning/error, to allow for the possibility that the\n+      // compiler we're debugging is in a bad state.\n+      this->ss_ << \"<??? \" << ((unsigned)t->classification()) << \"> \"\n+                << \"T\" << tag;\n+    }\n+  if (suf != NULL)\n+    this->ss_ << suf;\n+}\n+\n+void Type_dumper::visit_forward_declaration_type(const Forward_declaration_type* fdt)\n+{\n+  this->ss_ << \"forward_declaration_type \";\n+  if (fdt->is_defined())\n+    this->typeref(\"-> \", fdt->real_type(), NULL);\n+  else\n+    this->ss_ << \"'\" << fdt->name() << \"'\";\n+  this->ss_ << \"\\n\";\n+}\n+\n+void Type_dumper::visit_function_type(const Function_type* ft)\n+{\n+  this->ss_ << \"function\\n\";\n+  const Typed_identifier* rec = ft->receiver();\n+  if (rec != NULL)\n+    {\n+      this->emitpre(notag, NULL);\n+      this->typeref(\"receiver \", rec->type(), NULL);\n+    }\n+  const Typed_identifier_list* parameters = ft->parameters();\n+  if (parameters != NULL)\n+    {\n+      for (Typed_identifier_list::const_iterator p = parameters->begin();\n+\t   p != parameters->end();\n+\t   ++p)\n+        {\n+          this->emitpre(notag, NULL);\n+          this->typeref(\" param \", p->type(), \"\\n\");\n+        }\n+    }\n+  const Typed_identifier_list* results = ft->results();\n+  if (results != NULL)\n+    {\n+      for (Typed_identifier_list::const_iterator p = results->begin();\n+\t   p != results->end();\n+\t   ++p)\n+        {\n+          this->emitpre(notag, NULL);\n+          this->typeref(\" result \", p->type(), \"\\n\");\n+        }\n+    }\n+}\n+\n+void Type_dumper::visit_struct_type(const Struct_type* st)\n+{\n+  this->ss_ << \"struct\\n\";\n+  const Struct_field_list* fields = st->fields();\n+  if (fields != NULL)\n+    {\n+      for (Struct_field_list::const_iterator p = fields->begin();\n+           p != fields->end();\n+           ++p)\n+        {\n+          this->emitpre(notag, NULL);\n+          this->typeref(\" field \", p->type(), \"\\n\");\n+        }\n+    }\n+}\n+\n+void Type_dumper::visit_array_type(const Array_type* at)\n+{\n+  this->ss_ << \"array [\";\n+  if (at->length() != NULL)\n+    {\n+      int64_t len = 0;\n+      if (at->int_length(&len))\n+        this->ss_ << len;\n+    }\n+  this->typeref(\"] \", at->element_type(), \"\\n\");\n+}\n+\n+void Type_dumper::visit_map_type(const Map_type* mt)\n+{\n+  this->ss_ << \"map [\";\n+  this->typeref(NULL, mt->key_type(), NULL);\n+  this->typeref(\"] \", mt->val_type(), \"\\n\");\n+}\n+\n+void Type_dumper::visit_methods(const Typed_identifier_list* methods,\n+                                const char *tag)\n+{\n+  if (tag != NULL)\n+    {\n+      this->emitpre(notag, NULL);\n+      this->ss_ << tag << \"\\n\";\n+    }\n+  for (Typed_identifier_list::const_iterator p = methods->begin();\n+       p != methods->end();\n+       ++p)\n+    {\n+      this->emitpre(notag, NULL);\n+      if (p->name().empty())\n+        this->typeref(\"  embedded method \", p->type(), \"\\n\");\n+      else\n+        {\n+          this->ss_ << \"  method '\" << p->name() << \"' \";\n+          this->typeref(NULL, p->type(), \"\\n\");\n+        }\n+    }\n+}\n+\n+void Type_dumper::visit_interface_type(const Interface_type* it)\n+{\n+  const Typed_identifier_list* methods =\n+      (it->methods_are_finalized() ? it->methods() : it->local_methods());\n+  if (methods == NULL)\n+    {\n+      this->ss_ << \"empty_interface\\n\";\n+      return;\n+    }\n+  this->ss_ << \"interface\";\n+  if (! it->methods_are_finalized())\n+    {\n+      this->ss_ << \" [unfinalized]\\n\";\n+      visit_methods(it->local_methods(), NULL);\n+    }\n+  else\n+    {\n+      this->ss_ << \"\\n\";\n+      visit_methods(it->local_methods(), \"[parse_methods]\");\n+      visit_methods(it->methods(), \"[all_methods]\");\n+    }\n+}\n+\n+void Type_dumper::visit_channel_type(const Channel_type* ct)\n+{\n+  this->ss_ << \"channel {\";\n+  if (ct->may_send())\n+    this->ss_ << \" send\";\n+  if (ct->may_receive())\n+    this->ss_ << \" receive\";\n+  this->typeref(\" } \", ct->element_type(), \"\\n\");\n+}\n+\n+void Type_dumper::visit()\n+{\n+  while (! this->worklist_.empty()) {\n+    const Type* t = this->worklist_.front();\n+    this->worklist_.pop_front();\n+\n+    std::pair<bool, unsigned> p = this->lookup(t);\n+    unsigned tag = p.second;\n+    this->emitpre(tag, t);\n+\n+    switch(t->classification())\n+      {\n+        case Type::TYPE_ERROR:\n+        case Type::TYPE_INTEGER:\n+        case Type::TYPE_FLOAT:\n+        case Type::TYPE_COMPLEX:\n+        case Type::TYPE_BOOLEAN:\n+        case Type::TYPE_STRING:\n+        case Type::TYPE_VOID:\n+        case Type::TYPE_POINTER:\n+        case Type::TYPE_NIL:\n+        case Type::TYPE_NAMED:\n+          this->typeref(NULL, t, \"\\n\");\n+          break;\n+        case Type::TYPE_FORWARD:\n+          this->visit_forward_declaration_type(t->forward_declaration_type());\n+          break;\n+\n+        case Type::TYPE_FUNCTION:\n+          this->visit_function_type(t->function_type());\n+          break;\n+        case Type::TYPE_STRUCT:\n+          this->visit_struct_type(t->struct_type());\n+          break;\n+        case Type::TYPE_ARRAY:\n+          this->visit_array_type(t->array_type());\n+          break;\n+        case Type::TYPE_MAP:\n+          this->visit_map_type(t->map_type());\n+          break;\n+        case Type::TYPE_CHANNEL:\n+          this->visit_channel_type(t->channel_type());\n+          break;\n+        case Type::TYPE_INTERFACE:\n+          this->visit_interface_type(t->interface_type());\n+          break;\n+        default:\n+          // This is a debugging routine, so instead of a go_unreachable()\n+          // issue a warning/error, to allow for the possibility that the\n+          // compiler we're debugging is in a bad state.\n+          this->ss_ << \"<unknown/unrecognized classification \"\n+                    << ((unsigned)t->classification()) << \">\\n\";\n+      }\n+  }\n+}\n+\n+// Dump a Go type for debugging purposes. This is a deep as opposed\n+// to shallow dump; all of the types reachable from the specified\n+// type will be dumped in addition to the type itself.\n+\n+void debug_go_type(const Type* type)\n+{\n+  if (type == NULL)\n+    {\n+      std::cerr << \"<NULL type>\\n\";\n+      return;\n+    }\n+  Type_dumper dumper(type);\n+  dumper.visit();\n+  std::cerr << dumper.stringResult();\n+}\n+\n+void debug_go_type(Type* type)\n+{\n+  const Type* ctype = type;\n+  debug_go_type(ctype);\n+}"}, {"sha": "e12e6706006c8272709f3533aebd3351f0a4c6f3", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4390da0c537d637e6aa582f68c65bac13396196/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4390da0c537d637e6aa582f68c65bac13396196/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=f4390da0c537d637e6aa582f68c65bac13396196", "patch": "@@ -6951,7 +6951,7 @@ Type::make_struct_type(Struct_field_list* fields,\n // called for a slice.\n \n bool\n-Array_type::int_length(int64_t* plen)\n+Array_type::int_length(int64_t* plen) const\n {\n   go_assert(this->length_ != NULL);\n   Numeric_constant nc;"}, {"sha": "976d41a4c094fd9b3643aa1ddcacbb38e030aca0", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4390da0c537d637e6aa582f68c65bac13396196/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4390da0c537d637e6aa582f68c65bac13396196/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=f4390da0c537d637e6aa582f68c65bac13396196", "patch": "@@ -2706,7 +2706,7 @@ class Array_type : public Type\n   // length can not be determined.  This will assert if called for a\n   // slice.\n   bool\n-  int_length(int64_t* plen);\n+  int_length(int64_t* plen) const;\n \n   // Whether this type is identical with T.\n   bool\n@@ -3160,6 +3160,11 @@ class Interface_type : public Type\n   static Type*\n   make_interface_type_descriptor_type();\n \n+  // Return whether methods are finalized for this interface.\n+  bool\n+  methods_are_finalized() const\n+  { return this->methods_are_finalized_; }\n+\n  protected:\n   int\n   do_traverse(Traverse*);"}]}