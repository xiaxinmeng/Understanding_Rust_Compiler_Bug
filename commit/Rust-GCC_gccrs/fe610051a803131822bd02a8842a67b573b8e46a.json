{"sha": "fe610051a803131822bd02a8842a67b573b8e46a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU2MTAwNTFhODAzMTMxODIyYmQwMmE4ODQyYTY3YjU3M2I4ZTQ2YQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-07-12T14:34:41Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-07-12T14:35:14Z"}, "message": "Change the type of memory classification functions to bool\n\n2021-07-12  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/\n\t* recog.c (memory_address_addr_space_p): Change the type to bool.\n\tReturn true/false instead of 1/0.\n\t(offsettable_memref_p): Ditto.\n\t(offsettable_nonstrict_memref_p): Ditto.\n\t(offsettable_address_addr_space_p): Ditto.\n\tChange the type of addressp indirect function to bool.\n\t* recog.h (memory_address_addr_space_p): Change the type to bool.\n\t(strict_memory_address_addr_space_p): Ditto.\n\t(offsettable_memref_p): Ditto.\n\t(offsettable_nonstrict_memref_p): Ditto.\n\t(offsettable_address_addr_space_p): Ditto.\n\t* reload.c (maybe_memory_address_addr_space_p): Ditto.\n\t(strict_memory_address_addr_space_p): Change the type to bool.\n\tReturn true/false instead of 1/0.\n\t(maybe_memory_address_addr_space_p): Change the type to bool.", "tree": {"sha": "f07119f50a0457279b2f422cf09d9f9388ccc229", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f07119f50a0457279b2f422cf09d9f9388ccc229"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe610051a803131822bd02a8842a67b573b8e46a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe610051a803131822bd02a8842a67b573b8e46a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe610051a803131822bd02a8842a67b573b8e46a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe610051a803131822bd02a8842a67b573b8e46a/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bebd55e12375b397ed187630bb57d58611dfc5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bebd55e12375b397ed187630bb57d58611dfc5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bebd55e12375b397ed187630bb57d58611dfc5f"}], "stats": {"total": 64, "additions": 31, "deletions": 33}, "files": [{"sha": "5a42c45361d5c6d615f0ad58d9b08fc096e1eaee", "filename": "gcc/recog.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe610051a803131822bd02a8842a67b573b8e46a/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe610051a803131822bd02a8842a67b573b8e46a/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=fe610051a803131822bd02a8842a67b573b8e46a", "patch": "@@ -1776,20 +1776,20 @@ pop_operand (rtx op, machine_mode mode)\n   return XEXP (op, 0) == stack_pointer_rtx;\n }\n \n-/* Return 1 if ADDR is a valid memory address\n+/* Return true if ADDR is a valid memory address\n    for mode MODE in address space AS.  */\n \n-int\n+bool\n memory_address_addr_space_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t     rtx addr, addr_space_t as)\n {\n #ifdef GO_IF_LEGITIMATE_ADDRESS\n   gcc_assert (ADDR_SPACE_GENERIC_P (as));\n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n-  return 0;\n+  return false;\n \n  win:\n-  return 1;\n+  return true;\n #else\n   return targetm.addr_space.legitimate_address_p (mode, addr, 0, as);\n #endif\n@@ -2361,18 +2361,16 @@ find_constant_term_loc (rtx *p)\n   return 0;\n }\n \f\n-/* Return 1 if OP is a memory reference\n-   whose address contains no side effects\n-   and remains valid after the addition\n-   of a positive integer less than the\n-   size of the object being referenced.\n+/* Return true if OP is a memory reference whose address contains\n+   no side effects and remains valid after the addition of a positive\n+   integer less than the size of the object being referenced.\n \n    We assume that the original address is valid and do not check it.\n \n    This uses strict_memory_address_p as a subroutine, so\n    don't use it before reload.  */\n \n-int\n+bool\n offsettable_memref_p (rtx op)\n {\n   return ((MEM_P (op))\n@@ -2383,15 +2381,15 @@ offsettable_memref_p (rtx op)\n /* Similar, but don't require a strictly valid mem ref:\n    consider pseudo-regs valid as index or base regs.  */\n \n-int\n+bool\n offsettable_nonstrict_memref_p (rtx op)\n {\n   return ((MEM_P (op))\n \t  && offsettable_address_addr_space_p (0, GET_MODE (op), XEXP (op, 0),\n \t\t\t\t\t       MEM_ADDR_SPACE (op)));\n }\n \n-/* Return 1 if Y is a memory address which contains no side effects\n+/* Return true if Y is a memory address which contains no side effects\n    and would remain valid for address space AS after the addition of\n    a positive integer less than the size of that mode.\n \n@@ -2401,27 +2399,27 @@ offsettable_nonstrict_memref_p (rtx op)\n    If STRICTP is nonzero, we require a strictly valid address,\n    for the sake of use in reload.c.  */\n \n-int\n+bool\n offsettable_address_addr_space_p (int strictp, machine_mode mode, rtx y,\n \t\t\t\t  addr_space_t as)\n {\n   enum rtx_code ycode = GET_CODE (y);\n   rtx z;\n   rtx y1 = y;\n   rtx *y2;\n-  int (*addressp) (machine_mode, rtx, addr_space_t) =\n+  bool (*addressp) (machine_mode, rtx, addr_space_t) =\n     (strictp ? strict_memory_address_addr_space_p\n \t     : memory_address_addr_space_p);\n   poly_int64 mode_sz = GET_MODE_SIZE (mode);\n \n   if (CONSTANT_ADDRESS_P (y))\n-    return 1;\n+    return true;\n \n   /* Adjusting an offsettable address involves changing to a narrower mode.\n      Make sure that's OK.  */\n \n   if (mode_dependent_address_p (y, as))\n-    return 0;\n+    return false;\n \n   machine_mode address_mode = GET_MODE (y);\n   if (address_mode == VOIDmode)\n@@ -2442,7 +2440,7 @@ offsettable_address_addr_space_p (int strictp, machine_mode mode, rtx y,\n \n   if ((ycode == PLUS) && (y2 = find_constant_term_loc (&y1)))\n     {\n-      int good;\n+      bool good;\n \n       y1 = *y2;\n       *y2 = plus_constant (address_mode, *y2, mode_sz - 1);\n@@ -2456,7 +2454,7 @@ offsettable_address_addr_space_p (int strictp, machine_mode mode, rtx y,\n     }\n \n   if (GET_RTX_CLASS (ycode) == RTX_AUTOINC)\n-    return 0;\n+    return false;\n \n   /* The offset added here is chosen as the maximum offset that\n      any instruction could need to add when operating on something\n@@ -2486,7 +2484,7 @@ offsettable_address_addr_space_p (int strictp, machine_mode mode, rtx y,\n   return (*addressp) (QImode, z, as);\n }\n \n-/* Return 1 if ADDR is an address-expression whose effect depends\n+/* Return true if ADDR is an address-expression whose effect depends\n    on the mode of the memory reference it is used in.\n \n    ADDRSPACE is the address space associated with the address."}, {"sha": "1df1a6e740449f0f6132643f96b6e9d5a4c65455", "filename": "gcc/recog.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe610051a803131822bd02a8842a67b573b8e46a/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe610051a803131822bd02a8842a67b573b8e46a/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=fe610051a803131822bd02a8842a67b573b8e46a", "patch": "@@ -200,11 +200,11 @@ extern void temporarily_undo_changes (int);\n extern void redo_changes (int);\n extern int constrain_operands (int, alternative_mask);\n extern int constrain_operands_cached (rtx_insn *, int);\n-extern int memory_address_addr_space_p (machine_mode, rtx, addr_space_t);\n+extern bool memory_address_addr_space_p (machine_mode, rtx, addr_space_t);\n #define memory_address_p(mode,addr) \\\n \tmemory_address_addr_space_p ((mode), (addr), ADDR_SPACE_GENERIC)\n-extern int strict_memory_address_addr_space_p (machine_mode, rtx,\n-\t\t\t\t\t       addr_space_t);\n+extern bool strict_memory_address_addr_space_p (machine_mode, rtx,\n+\t\t\t\t\t\taddr_space_t);\n #define strict_memory_address_p(mode,addr) \\\n \tstrict_memory_address_addr_space_p ((mode), (addr), ADDR_SPACE_GENERIC)\n extern int validate_replace_rtx_subexp (rtx, rtx, rtx_insn *, rtx *);\n@@ -218,9 +218,9 @@ extern int num_changes_pending (void);\n extern bool reg_fits_class_p (const_rtx, reg_class_t, int, machine_mode);\n extern bool valid_insn_p (rtx_insn *);\n \n-extern int offsettable_memref_p (rtx);\n-extern int offsettable_nonstrict_memref_p (rtx);\n-extern int offsettable_address_addr_space_p (int, machine_mode, rtx,\n+extern bool offsettable_memref_p (rtx);\n+extern bool offsettable_nonstrict_memref_p (rtx);\n+extern bool offsettable_address_addr_space_p (int, machine_mode, rtx,\n \t\t\t\t\t     addr_space_t);\n #define offsettable_address_p(strict,mode,addr) \\\n \toffsettable_address_addr_space_p ((strict), (mode), (addr), \\"}, {"sha": "4c55ca58a5f720d01e8c970caedb78afeb8bc2ff", "filename": "gcc/reload.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe610051a803131822bd02a8842a67b573b8e46a/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe610051a803131822bd02a8842a67b573b8e46a/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=fe610051a803131822bd02a8842a67b573b8e46a", "patch": "@@ -262,8 +262,8 @@ static bool alternative_allows_const_pool_ref (rtx, const char *, int);\n static rtx find_reloads_toplev (rtx, int, enum reload_type, int, int,\n \t\t\t\trtx_insn *, int *);\n static rtx make_memloc (rtx, int);\n-static int maybe_memory_address_addr_space_p (machine_mode, rtx,\n-\t\t\t\t\t      addr_space_t, rtx *);\n+static bool maybe_memory_address_addr_space_p (machine_mode, rtx,\n+\t\t\t\t\t       addr_space_t, rtx *);\n static int find_reloads_address (machine_mode, rtx *, rtx, rtx *,\n \t\t\t\t int, enum reload_type, int, rtx_insn *);\n static rtx subst_reg_equivs (rtx, rtx_insn *);\n@@ -2156,21 +2156,21 @@ hard_reg_set_here_p (unsigned int beg_regno, unsigned int end_regno, rtx x)\n   return 0;\n }\n \n-/* Return 1 if ADDR is a valid memory address for mode MODE\n+/* Return true if ADDR is a valid memory address for mode MODE\n    in address space AS, and check that each pseudo reg has the\n    proper kind of hard reg.  */\n \n-int\n+bool\n strict_memory_address_addr_space_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t    rtx addr, addr_space_t as)\n {\n #ifdef GO_IF_LEGITIMATE_ADDRESS\n   gcc_assert (ADDR_SPACE_GENERIC_P (as));\n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n-  return 0;\n+  return false;\n \n  win:\n-  return 1;\n+  return true;\n #else\n   return targetm.addr_space.legitimate_address_p (mode, addr, 1, as);\n #endif\n@@ -4829,11 +4829,11 @@ make_memloc (rtx ad, int regno)\n    to mode MODE in address space AS by reloading the part pointed to\n    by PART into a register.  */\n \n-static int\n+static bool\n maybe_memory_address_addr_space_p (machine_mode mode, rtx ad,\n \t\t\t\t   addr_space_t as, rtx *part)\n {\n-  int retv;\n+  bool retv;\n   rtx tem = *part;\n   rtx reg = gen_rtx_REG (GET_MODE (tem), max_reg_num ());\n "}]}