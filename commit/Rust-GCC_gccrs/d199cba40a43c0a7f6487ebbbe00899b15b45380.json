{"sha": "d199cba40a43c0a7f6487ebbbe00899b15b45380", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE5OWNiYTQwYTQzYzBhN2Y2NDg3ZWJiYmUwMDg5OWIxNWI0NTM4MA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-07-07T14:11:34Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-07-07T14:11:34Z"}, "message": "* cpp.texi: Update.\n\nFrom-SVN: r34903", "tree": {"sha": "454cf1d9d3d5518b56736f00620db21da99d1e4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/454cf1d9d3d5518b56736f00620db21da99d1e4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d199cba40a43c0a7f6487ebbbe00899b15b45380", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d199cba40a43c0a7f6487ebbbe00899b15b45380", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d199cba40a43c0a7f6487ebbbe00899b15b45380", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d199cba40a43c0a7f6487ebbbe00899b15b45380/comments", "author": null, "committer": null, "parents": [{"sha": "6d0be3693d2706fe395af6ac4bd092ab2dd90c4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d0be3693d2706fe395af6ac4bd092ab2dd90c4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d0be3693d2706fe395af6ac4bd092ab2dd90c4a"}], "stats": {"total": 85, "additions": 69, "deletions": 16}, "files": [{"sha": "e53d1e53bf962c461ed24d3b0269a68a113eac8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d199cba40a43c0a7f6487ebbbe00899b15b45380/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d199cba40a43c0a7f6487ebbbe00899b15b45380/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d199cba40a43c0a7f6487ebbbe00899b15b45380", "patch": "@@ -1,3 +1,7 @@\n+2000-07-07  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpp.texi: Update.\n+\n Fri Jul  7 07:47:35 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* final.c (final): Detect out of bounds array access to"}, {"sha": "74270d085302c20606ca5009fd8e8ffb3e49be78", "filename": "gcc/cpp.texi", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d199cba40a43c0a7f6487ebbbe00899b15b45380/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d199cba40a43c0a7f6487ebbbe00899b15b45380/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=d199cba40a43c0a7f6487ebbbe00899b15b45380", "patch": "@@ -894,18 +894,20 @@ whether there is a space.\n @cindex macro with variable arguments\n @cindex rest argument (in macro)\n \n-In GNU C, a macro can accept a variable number of arguments, much as a\n-function can.  The syntax for defining the macro looks much like that\n-used for a function.  Here is an example:\n+In the ISO C standard of 1999, a macro can be declared to accept a\n+variable number of arguments much as a function can.  The syntax for\n+defining the macro is similar to that of a function.  Here is an\n+example:\n \n @example\n #define eprintf(...) fprintf (stderr, __VA_ARGS__)\n @end example\n \n-Here @samp{<@dots{}>} is a @dfn{variable argument}.  It represents the\n-zero or more tokens until the matching closing parenthesis, including\n-commas.  This set of tokens is substituted into the macro body wherever\n-@code{__VA_ARGS__} is used.  Thus, we have this expansion:\n+Here @samp{@dots{}} is a @dfn{variable argument}.  In the invocation of\n+such a macro, it represents the zero or more tokens until the closing\n+parenthesis that ends the invocation, including any commas.  This set of\n+tokens replaces the identifier @code{__VA_ARGS__} in the macro body\n+wherever it appears.  Thus, we have this expansion:\n \n @example\n eprintf (\"%s:%d: \", input_file_name, line_number)\n@@ -919,9 +921,9 @@ We might instead have defined eprintf as follows:-\n #define eprintf(format, ...) fprintf (stderr, format, __VA_ARGS__)\n @end example\n \n-This formulation causes problems if there are no arguments to fprintf\n-after the format, however.  There is no way to produce expanded output\n-of\n+This formulation looks more descriptive, but unfortunately causes\n+problems if fprintf wants no arguments the format.  There is no way to\n+produce expanded output of\n \n @example\n fprintf (stderr, \"success!\\n\")\n@@ -935,8 +937,38 @@ eprintf (\"success!\\n\", )\n @end example\n \n @noindent\n-produces an unwanted extra comma, originating from the expansion and not\n-the invocation of eprintf, in the output.\n+produces\n+\n+@example\n+fprintf (stderr, \"success!\\n\",)\n+@end example\n+\n+@noindent\n+where the extra comma originates from the replacement list and not from\n+the arguments to eprintf.\n+\n+Within a @samp{#define} directive, ISO C mandates that the only place\n+the identifier @code{__VA_ARGS__} can appear is in the replacement list\n+of a variable-argument macro.  Using it as a macro name, macro argument\n+or within a different type of macro is illegal.\n+\n+Before standardization, previous GNU preprocessors implemented a\n+slightly different syntax for defining variable-argument macros.  The\n+macros were called ``rest args macros''.  You could assign a name to the\n+variable arguments, by contrast the standardized method leaves them\n+anonymous.  For example, the eprintf macro could have been defined like\n+this\n+\n+@example\n+#define eprintf(format...) fprintf (stderr, format)\n+@end example\n+\n+Now that there is a standardized construct, you are encouraged to use\n+that instead.  It is unlikely that support for named variable arguments\n+will be removed in future revisions of CPP, since being able to assign a\n+name is descriptive, and there is a wide base of legacy code.  However,\n+two obscure features of the GNU style are deprecated and likely to be\n+dropped in future.  @xref{Unreliable Features}.\n \n @node Predefined, Stringification, Macro Varargs, Macros\n @subsection Predefined Macros\n@@ -2731,7 +2763,7 @@ Preservation of the form of whitespace between tokens is unlikely to\n change from current behavior (see @ref{Output}), but you are advised not\n to rely on it.\n \n-The following is undocumented and subject to change:-\n+The following are undocumented and subject to change:-\n \n @itemize @bullet\n \n@@ -2763,9 +2795,9 @@ point in the future:-\n \n @itemize @bullet\n \n-@item ## swallowing the previous token in variable-argument macros\n+@item ## swallowing the previous token in GNU rest argument macros\n \n-In a macro expansion, if ## appeared before a variable arguments\n+In a macro expansion, if ## appeared before a GNU named variable arguments\n parameter, and the set of tokens specified for that argument in the\n macro invocation was empty, previous versions of the GNU C preprocessor\n would back up and remove the token appearing before the ##.  This\n@@ -2776,7 +2808,24 @@ conflicts with behavior mandated by the standard, this feature is now\n deprecated and will be removed in future.\n \n The current preprocessor still supports it for reasons of code\n-migration, and warns at the location of the macro definition.\n+migration, and warns at each use of the feature.\n+\n+@item Optional argument when invoking GNU rest argument macros\n+\n+In the invocation of a GNU named variable arguments macro, the variable\n+arguments were optional.  For example, the following two invocations are\n+both legal for GNU rest args.  The first is illegal in the equivalent\n+formulation using ISO C anonymous variable arguments and\n+@code{__VA_ARGS__}:-\n+\n+@smallexample\n+#define debug(format, args...) printf (format, args)\n+debug(\"string\");       /* Illegal in ISO C equivalent.  */\n+debug(\"string\",);      /* OK for both.  */\n+@end smallexample\n+\n+The current preprocessor still supports it for reasons of code\n+migration, and warns at each use of the feature.\n \n @item Attempting to paste two tokens which together do not form a valid\n preprocessing token"}]}