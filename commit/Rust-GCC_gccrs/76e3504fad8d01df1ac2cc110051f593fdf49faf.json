{"sha": "76e3504fad8d01df1ac2cc110051f593fdf49faf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZlMzUwNGZhZDhkMDFkZjFhYzJjYzExMDA1MWY1OTNmZGY0OWZhZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T09:48:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T09:48:35Z"}, "message": "[multiple changes]\n\n2010-10-11  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch10.adb (Analyze_With_Clause): Add missing test to ensure\n\tavailability of attribute Instance_Spec.\n\n2010-10-11  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat1drv.adb (Adjust_Global_Switches): Disable codepeer mode if\n\tchecking syntax only or in ASIS mode.\n\n2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Check_Delayed_Subprogram): Abstract subprograms may also\n\tneed a freeze node if some type in the profile has one.\n\t* gcc-interface/trans.c (case N_Abstract_Subprogram_Declaration): If\n\tentity has a freeze node, defer elaboration.\n\n2010-10-11  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-nmsc.adb (Check_Aggregate_Project): Add support for finding all\n\taggregated projects.\n\nFrom-SVN: r165287", "tree": {"sha": "d086737515eaf19da233b1d479e7cf13f22b53da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d086737515eaf19da233b1d479e7cf13f22b53da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76e3504fad8d01df1ac2cc110051f593fdf49faf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76e3504fad8d01df1ac2cc110051f593fdf49faf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76e3504fad8d01df1ac2cc110051f593fdf49faf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76e3504fad8d01df1ac2cc110051f593fdf49faf/comments", "author": null, "committer": null, "parents": [{"sha": "ae6ede7778adc56299bdecf1e73302aebc990fef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae6ede7778adc56299bdecf1e73302aebc990fef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae6ede7778adc56299bdecf1e73302aebc990fef"}], "stats": {"total": 461, "additions": 289, "deletions": 172}, "files": [{"sha": "cb8db41b688d459455d43dd701d6e3610eb4d92a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=76e3504fad8d01df1ac2cc110051f593fdf49faf", "patch": "@@ -1,3 +1,25 @@\n+2010-10-11  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch10.adb (Analyze_With_Clause): Add missing test to ensure\n+\tavailability of attribute Instance_Spec.\n+\n+2010-10-11  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat1drv.adb (Adjust_Global_Switches): Disable codepeer mode if\n+\tchecking syntax only or in ASIS mode.\n+\n+2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Check_Delayed_Subprogram): Abstract subprograms may also\n+\tneed a freeze node if some type in the profile has one.\n+\t* gcc-interface/trans.c (case N_Abstract_Subprogram_Declaration): If\n+\tentity has a freeze node, defer elaboration.\n+\n+2010-10-11  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-nmsc.adb (Check_Aggregate_Project): Add support for finding all\n+\taggregated projects.\n+\n 2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_res.adb (Resolve_Entry_Call): Generate 's' reference for entry"}, {"sha": "9d021b8a78221355c89ae8b9cd5c28bf8cb0aa0e", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=76e3504fad8d01df1ac2cc110051f593fdf49faf", "patch": "@@ -5011,10 +5011,14 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Abstract_Subprogram_Declaration:\n       /* This subprogram doesn't exist for code generation purposes, but we\n \t have to elaborate the types of any parameters and result, unless\n-\t they are imported types (nothing to generate in this case).  */\n+\t they are imported types (nothing to generate in this case).\n \n-      /* Process the parameter types first.  */\n+\t The parameter list may contain types with freeze nodes, e.g. not null\n+\t subtypes, so the subprogram itself may carry a freeze node, in which\n+\t case its elaboration must be deferred.  */\n \n+      /* Process the parameter types first.  */\n+      if (No (Freeze_Node (Defining_Entity (Specification (gnat_node)))))\n       for (gnat_temp\n \t   = First_Formal_With_Extras\n \t      (Defining_Entity (Specification (gnat_node)));\n@@ -5024,9 +5028,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    && !From_With_Type (Etype (gnat_temp)))\n \t  gnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, 0);\n \n-\n       /* Then the result type, set to Standard_Void_Type for procedures.  */\n-\n       {\n \tEntity_Id gnat_temp_type\n \t  = Etype (Defining_Entity (Specification (gnat_node)));"}, {"sha": "5e95182425decb5e0431344a2a8c9d020e717733", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=76e3504fad8d01df1ac2cc110051f593fdf49faf", "patch": "@@ -123,6 +123,13 @@ procedure Gnat1drv is\n          Generate_SCIL := True;\n       end if;\n \n+      --  Disable CodePeer_Mode in Check_Syntax, since we need front-end\n+      --  expansion.\n+\n+      if Operating_Mode = Check_Syntax then\n+         CodePeer_Mode := False;\n+      end if;\n+\n       --  Set ASIS mode if -gnatt and -gnatc are set\n \n       if Operating_Mode = Check_Semantics and then Tree_Output then\n@@ -136,10 +143,11 @@ procedure Gnat1drv is\n \n          Inline_Active := False;\n \n-         --  Turn off SCIL generation in ASIS mode, since SCIL requires front-\n-         --  end expansion.\n+         --  Turn off SCIL generation and CodePeer mode in semantics mode,\n+         --  since SCIL requires front-end expansion.\n \n          Generate_SCIL := False;\n+         CodePeer_Mode := False;\n       end if;\n \n       --  SCIL mode needs to disable front-end inlining since the generated\n@@ -160,10 +168,6 @@ procedure Gnat1drv is\n          Front_End_Inlining := False;\n          Inline_Active      := False;\n \n-         --  Turn off ASIS mode: incompatible with front-end expansion\n-\n-         ASIS_Mode := False;\n-\n          --  Disable front-end optimizations, to keep the tree as close to the\n          --  source code as possible, and also to avoid inconsistencies between\n          --  trees when using different optimization switches."}, {"sha": "3433ecf55daf4f0857fc8cf123ac34b53673be94", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 238, "deletions": 142, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=76e3504fad8d01df1ac2cc110051f593fdf49faf", "patch": "@@ -43,6 +43,7 @@ with Ada.Strings.Maps.Constants; use Ada.Strings.Maps.Constants;\n with GNAT.Case_Util;            use GNAT.Case_Util;\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.Dynamic_HTables;\n+with GNAT.Regexp;                use GNAT.Regexp;\n with GNAT.Table;\n \n package body Prj.Nmsc is\n@@ -213,12 +214,10 @@ package body Prj.Nmsc is\n    --  as appropriate.\n \n    type Search_Type is (Search_Files, Search_Directories);\n-   pragma Unreferenced (Search_Files);\n \n    generic\n       with procedure Callback\n-        (Path_Id         : Path_Name_Type;\n-         Display_Path_Id : Path_Name_Type;\n+        (Path            : Path_Information;\n          Pattern_Index   : Natural);\n    procedure Expand_Subdirectory_Pattern\n      (Project       : Project_Id;\n@@ -315,7 +314,8 @@ package body Prj.Nmsc is\n    procedure Check_Aggregate_Project\n      (Project : Project_Id;\n       Data    : in out Tree_Processing_Data);\n-   --  Check aggregate projects attributes\n+   --  Check aggregate projects attributes, and find the list of aggregated\n+   --  projects. They are stored as a \"project_files\" language in Project.\n \n    procedure Check_Abstract_Project\n      (Project : Project_Id;\n@@ -920,14 +920,47 @@ package body Prj.Nmsc is\n                           (Snames.Name_Project_Files,\n                            Project.Decl.Attributes,\n                            Data.Tree);\n+\n+      procedure Found_Project_File (Path : Path_Information; Rank : Natural);\n+\n+      procedure Expand_Project_Files is new Expand_Subdirectory_Pattern\n+        (Callback => Found_Project_File);\n+\n+      ------------------------\n+      -- Found_Project_File --\n+      ------------------------\n+\n+      procedure Found_Project_File (Path : Path_Information; Rank : Natural) is\n+         pragma Unreferenced (Rank);\n+      begin\n+         if Current_Verbosity = High then\n+            Write_Str (\"  Aggregates:\");\n+            Write_Line (Get_Name_String (Path.Display_Name));\n+         end if;\n+      end Found_Project_File;\n+\n    begin\n       if Project_Files.Default then\n          Error_Msg_Name_1 := Snames.Name_Project_Files;\n          Error_Msg\n            (Data.Flags,\n             \"Attribute %% must be specified in aggregate project\",\n             Project.Location, Project);\n+         return;\n       end if;\n+\n+      --  Look for aggregated projects. For similarity with source files and\n+      --  dirs, the aggregated project files are not searched for on the\n+      --  project path, and are only found through the path specified in\n+      --  the Project_Files attribute.\n+\n+      Expand_Project_Files\n+        (Project       => Project,\n+         Data          => Data,\n+         Patterns      => Project_Files.Values,\n+         Search_For    => Search_Files,\n+         Resolve_Links => Opt.Follow_Links_For_Files);\n+\n    end Check_Aggregate_Project;\n \n    ----------------------------\n@@ -988,8 +1021,15 @@ package body Prj.Nmsc is\n       Initialize (Prj_Data, Project);\n \n       Check_If_Externally_Built   (Project, Data);\n-      Get_Directories             (Project, Data);\n-      Check_Programming_Languages (Project, Data);\n+\n+      if Project.Qualifier /= Aggregate then\n+         Get_Directories             (Project, Data);\n+         Check_Programming_Languages (Project, Data);\n+\n+         if Current_Verbosity = High then\n+            Show_Source_Dirs (Project, Data.Tree);\n+         end if;\n+      end if;\n \n       case Project.Qualifier is\n          when Aggregate => Check_Aggregate_Project (Project, Data);\n@@ -1003,26 +1043,20 @@ package body Prj.Nmsc is\n \n       Check_Configuration (Project, Data);\n \n-      Check_Library_Attributes (Project, Data);\n-\n-      if Current_Verbosity = High then\n-         Show_Source_Dirs (Project, Data.Tree);\n-      end if;\n-\n-      Check_Package_Naming (Project, Data);\n-\n       if Project.Qualifier /= Aggregate then\n+\n+         Check_Library_Attributes (Project, Data);\n+         Check_Package_Naming (Project, Data);\n          Look_For_Sources (Prj_Data, Data);\n-      end if;\n+         Check_Interfaces (Project, Data);\n \n-      Check_Interfaces (Project, Data);\n+         if Project.Library then\n+            Check_Stand_Alone_Library (Project, Data);\n+         end if;\n \n-      if Project.Library then\n-         Check_Stand_Alone_Library (Project, Data);\n+         Get_Mains (Project, Data);\n       end if;\n \n-      Get_Mains (Project, Data);\n-\n       Free (Prj_Data);\n    end Check;\n \n@@ -4928,9 +4962,7 @@ package body Prj.Nmsc is\n       Remove_Source_Dirs : Boolean := False;\n \n       procedure Add_To_Or_Remove_From_Source_Dirs\n-        (Path_Id         : Path_Name_Type;\n-         Display_Path_Id : Path_Name_Type;\n-         Rank            : Natural);\n+        (Path : Path_Information; Rank : Natural);\n       --  When Removed = False, the directory Path_Id to the list of\n       --  source_dirs if not already in the list. When Removed = True,\n       --  removed directory Path_Id if in the list.\n@@ -4943,9 +4975,7 @@ package body Prj.Nmsc is\n       ---------------------------------------\n \n       procedure Add_To_Or_Remove_From_Source_Dirs\n-        (Path_Id         : Path_Name_Type;\n-         Display_Path_Id : Path_Name_Type;\n-         Rank            : Natural)\n+        (Path : Path_Information; Rank : Natural)\n       is\n          List       : String_List_Id;\n          Prev       : String_List_Id;\n@@ -4960,7 +4990,7 @@ package body Prj.Nmsc is\n          Rank_List := Project.Source_Dir_Ranks;\n          while List /= Nil_String loop\n             Element := Data.Tree.String_Elements.Table (List);\n-            exit when Element.Value = Name_Id (Path_Id);\n+            exit when Element.Value = Name_Id (Path.Name);\n             Prev := List;\n             List := Element.Next;\n             Prev_Rank := Rank_List;\n@@ -4972,14 +5002,14 @@ package body Prj.Nmsc is\n          if not Remove_Source_Dirs and then List = Nil_String then\n             if Current_Verbosity = High then\n                Write_Str  (\"   Adding Source Dir=\");\n-               Write_Line (Get_Name_String (Display_Path_Id));\n+               Write_Line (Get_Name_String (Path.Display_Name));\n             end if;\n \n             String_Element_Table.Increment_Last (Data.Tree.String_Elements);\n             Element :=\n-              (Value         => Name_Id (Path_Id),\n+              (Value         => Name_Id (Path.Name),\n                Index         => 0,\n-               Display_Value => Name_Id (Display_Path_Id),\n+               Display_Value => Name_Id (Path.Display_Name),\n                Location      => No_Location,\n                Flag          => False,\n                Next          => Nil_String);\n@@ -5207,8 +5237,8 @@ package body Prj.Nmsc is\n \n          Remove_Source_Dirs := False;\n          Add_To_Or_Remove_From_Source_Dirs\n-           (Path_Id         => Project.Directory.Name,\n-            Display_Path_Id => Project.Directory.Display_Name,\n+           (Path => (Name         => Project.Directory.Name,\n+                     Display_Name => Project.Directory.Display_Name),\n             Rank            => 1);\n \n       else\n@@ -6706,7 +6736,6 @@ package body Prj.Nmsc is\n       Search_For    : Search_Type;\n       Resolve_Links : Boolean)\n    is\n-      pragma Unreferenced (Search_For);\n       package Recursive_Dirs is new GNAT.Dynamic_HTables.Simple_HTable\n         (Header_Num => Header_Num,\n          Element    => Boolean,\n@@ -6718,61 +6747,102 @@ package body Prj.Nmsc is\n       --  several times, and to avoid cycles that may be introduced by symbolic\n       --  links.\n \n+      File_Pattern    : GNAT.Regexp.Regexp;\n+      --  Pattern to use when matching file names.\n+\n       Visited : Recursive_Dirs.Instance;\n \n       procedure Find_Pattern\n-        (Pattern : String; Rank : Natural; Location : Source_Ptr);\n+        (Pattern_Id : Name_Id; Rank : Natural; Location : Source_Ptr);\n       --  Find a specific pattern\n \n-      procedure Recursive_Find_Dirs (Normalized_Path : String; Rank : Natural);\n-      --  Search all the subdirectories (recursively) of Path\n+      function Recursive_Find_Dirs\n+        (Path : Path_Information; Rank : Natural) return Boolean;\n+      --  Search all the subdirectories (recursively) of Path.\n+      --  Return True if at least one file or directory was processed\n \n-      procedure Check_Directory_And_Subdirs\n-        (Directory       : String;\n-         Include_Subdirs : Boolean;\n-         Rank            : Natural;\n-         Location        : Source_Ptr);\n-      --  Make sur that Directory exists (and if not report an error/warning\n-      --  message depending on the flags.\n-      --  Calls Callback for Directory itself and all its subdirectories if\n-      --  Include_Subdirs is True).\n+      function Subdirectory_Matches\n+        (Path : Path_Information; Rank : Natural) return Boolean;\n+      --  Called when a matching directory was found. If the user is in fact\n+      --  searching for files, we then search for those files matching the\n+      --  pattern within the directory.\n+      --  Return True if at least one file or directory was processed\n+\n+      --------------------------\n+      -- Subdirectory_Matches --\n+      --------------------------\n+\n+      function Subdirectory_Matches\n+        (Path : Path_Information; Rank : Natural) return Boolean\n+      is\n+         Dir   : Dir_Type;\n+         Name  : String (1 .. 250);\n+         Last  : Natural;\n+         Found : Path_Information;\n+         Success : Boolean := False;\n+      begin\n+         case Search_For is\n+            when Search_Directories =>\n+               Callback (Path, Rank);\n+               return True;\n+\n+            when Search_Files =>\n+               Open (Dir, Get_Name_String (Path.Display_Name));\n+               loop\n+                  Read (Dir, Name, Last);\n+                  exit when Last = 0;\n+\n+                  if Name (Name'First .. Last) /= \".\"\n+                    and then Name (Name'First .. Last) /= \"..\"\n+                    and then Match (Name (Name'First .. Last), File_Pattern)\n+                  then\n+                     Get_Name_String (Path.Display_Name);\n+                     Add_Str_To_Name_Buffer (Name (Name'First .. Last));\n+\n+                     Found.Display_Name := Name_Find;\n+                     Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+                     Found.Name := Name_Find;\n+\n+                     Callback (Found, Rank);\n+                     Success := True;\n+                  end if;\n+               end loop;\n+\n+               Close (Dir);\n+\n+               return Success;\n+         end case;\n+      end Subdirectory_Matches;\n \n       -------------------------\n       -- Recursive_Find_Dirs --\n       -------------------------\n \n-      procedure Recursive_Find_Dirs\n-        (Normalized_Path : String; Rank : Natural)\n+      function Recursive_Find_Dirs\n+        (Path : Path_Information; Rank : Natural) return Boolean\n       is\n-         Dir  : Dir_Type;\n-         Name : String (1 .. 250);\n-         Last : Natural;\n-\n-         Non_Canonical_Path : Path_Name_Type := No_Path;\n-         Canonical_Path     : Path_Name_Type := No_Path;\n-\n-         The_Path_Last : constant Natural :=\n-           Compute_Directory_Last (Normalized_Path);\n+         Path_Str : constant String := Get_Name_String (Path.Display_Name);\n+         Dir   : Dir_Type;\n+         Name  : String (1 .. 250);\n+         Last  : Natural;\n+         Success : Boolean := False;\n \n       begin\n-         Name_Len := 0;\n-         Add_Str_To_Name_Buffer\n-           (Normalized_Path (Normalized_Path'First .. The_Path_Last));\n-         Non_Canonical_Path := Name_Find;\n-\n-         Canonical_Path :=\n-           Path_Name_Type\n-             (Canonical_Case_File_Name (Name_Id (Non_Canonical_Path)));\n+         if Current_Verbosity = High then\n+            Write_Str (\"  Looking for subdirs of \"\"\");\n+            Write_Str (Path_Str);\n+            Write_Line (\"\"\"\");\n+         end if;\n \n-         if Recursive_Dirs.Get (Visited, Canonical_Path) then\n-            return;\n+         if Recursive_Dirs.Get (Visited, Path.Name) then\n+            return Success;\n          end if;\n \n-         Recursive_Dirs.Set (Visited, Canonical_Path, True);\n+         Recursive_Dirs.Set (Visited, Path.Name, True);\n \n-         Callback (Canonical_Path, Non_Canonical_Path, Rank);\n+         Success := Subdirectory_Matches (Path, Rank) or Success;\n \n-         Open (Dir, Normalized_Path (Normalized_Path'First .. The_Path_Last));\n+         Open (Dir, Path_Str);\n \n          loop\n             Read (Dir, Name, Last);\n@@ -6781,52 +6851,113 @@ package body Prj.Nmsc is\n             if Name (1 .. Last) /= \".\"\n               and then Name (1 .. Last) /= \"..\"\n             then\n-               if Current_Verbosity = High then\n-                  Write_Str  (\"   Checking \");\n-                  Write_Line (Name (1 .. Last));\n-               end if;\n-\n                declare\n                   Path_Name : constant String :=\n                     Normalize_Pathname\n                       (Name           => Name (1 .. Last),\n-                       Directory      =>\n-                         Normalized_Path\n-                           (Normalized_Path'First .. The_Path_Last),\n+                       Directory      => Path_Str,\n                        Resolve_Links  => Resolve_Links)\n                     & Directory_Separator;\n+                  Path2 : Path_Information;\n                begin\n                   if Is_Directory (Path_Name) then\n-                     Recursive_Find_Dirs (Path_Name, Rank);\n+                     Name_Len := 0;\n+                     Add_Str_To_Name_Buffer (Path_Name);\n+                     Path2.Display_Name := Name_Find;\n+\n+                     Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+                     Path2.Name := Name_Find;\n+\n+                     Success := Recursive_Find_Dirs (Path2, Rank) or Success;\n                   end if;\n                end;\n             end if;\n          end loop;\n \n          Close (Dir);\n \n+         return Success;\n+\n       exception\n          when Directory_Error =>\n-            null;\n+            return Success;\n       end Recursive_Find_Dirs;\n \n-      ---------------------------------\n-      -- Check_Directory_And_Subdirs --\n-      ---------------------------------\n+      ------------------\n+      -- Find_Pattern --\n+      ------------------\n \n-      procedure Check_Directory_And_Subdirs\n-        (Directory       : String;\n-         Include_Subdirs : Boolean;\n-         Rank            : Natural;\n-         Location        : Source_Ptr)\n+      procedure Find_Pattern\n+        (Pattern_Id : Name_Id; Rank : Natural; Location : Source_Ptr)\n       is\n-         Dir        : File_Name_Type;\n-         Path_Name  : Path_Information;\n-         Dir_Exists : Boolean;\n-         Has_Error  : Boolean := False;\n+         Pattern     : constant String := Get_Name_String (Pattern_Id);\n+         Pattern_End : Natural := Pattern'Last;\n+         Recursive   : Boolean;\n+         Dir         : File_Name_Type;\n+         Path_Name   : Path_Information;\n+         Dir_Exists  : Boolean;\n+         Has_Error   : Boolean := False;\n+         Success     : Boolean;\n       begin\n-         Name_Len := Directory'Length;\n-         Name_Buffer (1 .. Name_Len) := Directory;\n+         if Current_Verbosity = High then\n+            Write_Str (\"Expand_Subdirectory_Pattern (\"\"\");\n+            Write_Str (Pattern);\n+            Write_Line (\"\"\")\");\n+         end if;\n+\n+         --  If we are looking for files, find the pattern for the files\n+\n+         if Search_For = Search_Files then\n+            while Pattern_End >= Pattern'First\n+              and then Pattern (Pattern_End) /= '/'\n+              and then Pattern (Pattern_End) /= Directory_Separator\n+            loop\n+               Pattern_End := Pattern_End - 1;\n+            end loop;\n+\n+            if Pattern_End = Pattern'Last then\n+               Err_Vars.Error_Msg_File_1 := File_Name_Type (Pattern_Id);\n+               Error_Or_Warning\n+                 (Data.Flags, Data.Flags.Missing_Source_Files,\n+                  \"Missing file name or pattern in {\", Location, Project);\n+               return;\n+            end if;\n+\n+            if Current_Verbosity = High then\n+               Write_Str (\"  file pattern=\");\n+               Write_Line (Pattern (Pattern_End + 1 .. Pattern'Last));\n+               Write_Str (\"  Expand directory pattern=\");\n+               Write_Line (Pattern (Pattern'First .. Pattern_End));\n+            end if;\n+\n+            File_Pattern := Compile\n+              (Pattern (Pattern_End + 1 .. Pattern'Last),\n+               Glob           => True,\n+               Case_Sensitive => File_Names_Case_Sensitive);\n+\n+            --  If we had just \"*.gpr\", this is equivalent to \"./*.gpr\"\n+\n+            if Pattern_End > Pattern'First then\n+               Pattern_End := Pattern_End - 1; --  Skip directory separator\n+            end if;\n+         end if;\n+\n+         Recursive :=\n+           Pattern_End - 1 >= Pattern'First\n+           and then Pattern (Pattern_End - 1 .. Pattern_End) = \"**\"\n+           and then (Pattern_End - 1 = Pattern'First\n+                     or else Pattern (Pattern_End - 2) = '/'\n+                     or else Pattern (Pattern_End - 2) = Directory_Separator);\n+\n+         if Recursive then\n+            Pattern_End := Pattern_End - 2;\n+            if Pattern_End > Pattern'First then\n+               Pattern_End := Pattern_End - 1; --  Skip '/'\n+            end if;\n+         end if;\n+\n+         Name_Len := Pattern_End - Pattern'First + 1;\n+         Name_Buffer (1 .. Name_Len) := Pattern (Pattern'First .. Pattern_End);\n          Dir := Name_Find;\n \n          Locate_Directory\n@@ -6849,58 +6980,24 @@ package body Prj.Nmsc is\n             --  Links have been resolved if necessary, and Path_Name\n             --  always ends with a directory separator.\n \n-            if Include_Subdirs then\n-               if Current_Verbosity = High then\n-                  Write_Str (\"Looking for all subdirectories of \"\"\");\n-                  Write_Str (Directory);\n-                  Write_Line (\"\"\"\");\n-               end if;\n-\n-               Recursive_Find_Dirs (Get_Name_String (Path_Name.Name), Rank);\n-\n-               if Current_Verbosity = High then\n-                  Write_Line (\"End of looking for source directories.\");\n-               end if;\n-\n+            if Recursive then\n+               Success := Recursive_Find_Dirs (Path_Name, Rank);\n             else\n-               Callback (Path_Name.Name, Path_Name.Display_Name, Rank);\n+               Success := Subdirectory_Matches (Path_Name, Rank);\n             end if;\n-         end if;\n-      end Check_Directory_And_Subdirs;\n-\n-      ------------------\n-      -- Find_Pattern --\n-      ------------------\n \n-      procedure Find_Pattern\n-        (Pattern : String; Rank : Natural; Location : Source_Ptr) is\n-      begin\n-         if Current_Verbosity = High then\n-            Write_Str (\"Expand_Subdirectory_Pattern (\"\"\");\n-            Write_Str (Pattern);\n-            Write_Line (\"\"\")\");\n-         end if;\n+            if not Success then\n+               case Search_For is\n+                  when Search_Directories =>\n+                     null;  --  Error can't occur\n \n-         --  First, check if we are looking for a directory tree, indicated\n-         --  by \"/**\" at the end.\n-\n-         if Pattern'Length >= 3\n-           and then Pattern (Pattern'Last - 1 .. Pattern'Last) = \"**\"\n-           and then (Pattern (Pattern'Last - 2) = '/'\n-                     or else Pattern (Pattern'Last - 2) = Directory_Separator)\n-         then\n-            if Pattern'Length = 3 then\n-               --  Case of \"/**\": all directories in file system\n-               Check_Directory_And_Subdirs\n-                 (Pattern (Pattern'First .. Pattern'First),\n-                  True, Rank, Location);\n-            else\n-               Check_Directory_And_Subdirs\n-                 (Pattern (Pattern'First .. Pattern'Last - 3),\n-                  True, Rank, Location);\n+                  when Search_Files =>\n+                     Err_Vars.Error_Msg_File_1 := File_Name_Type (Pattern_Id);\n+                     Error_Or_Warning\n+                       (Data.Flags, Data.Flags.Missing_Source_Files,\n+                        \"file { not found\", Location, Project);\n+               end case;\n             end if;\n-         else\n-            Check_Directory_And_Subdirs (Pattern, False, Rank, Location);\n          end if;\n       end Find_Pattern;\n \n@@ -6912,8 +7009,7 @@ package body Prj.Nmsc is\n    begin\n       while Pattern_Id /= Nil_String loop\n          Element := Data.Tree.String_Elements.Table (Pattern_Id);\n-         Find_Pattern\n-           (Get_Name_String (Element.Value), Rank, Element.Location);\n+         Find_Pattern (Element.Value, Rank, Element.Location);\n          Rank := Rank + 1;\n          Pattern_Id := Element.Next;\n       end loop;"}, {"sha": "0f7e1abb3f28e5a1a45bc4cb48328192dff9c629", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=76e3504fad8d01df1ac2cc110051f593fdf49faf", "patch": "@@ -2490,6 +2490,7 @@ package body Sem_Ch10 is\n \n       elsif Unit_Kind = N_Package_Instantiation\n         and then Nkind (U) = N_Package_Instantiation\n+        and then Present (Instance_Spec (U))\n       then\n          --  If the instance has not been rewritten as a package declaration,\n          --  then it appeared already in a previous with clause. Retrieve"}, {"sha": "f106141968f7998499b8a5b2e6e09265b4c9322a", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76e3504fad8d01df1ac2cc110051f593fdf49faf/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=76e3504fad8d01df1ac2cc110051f593fdf49faf", "patch": "@@ -4240,29 +4240,21 @@ package body Sem_Ch6 is\n    --  Start of processing for Check_Delayed_Subprogram\n \n    begin\n-      --  Never need to freeze abstract subprogram\n+      --  All subprograms, including abstract subprograms, may need a freeze\n+      --  node if some formal type or the return type needs one.\n \n-      if Ekind (Designator) /= E_Subprogram_Type\n-        and then Is_Abstract_Subprogram (Designator)\n-      then\n-         null;\n-      else\n-         --  Need delayed freeze if return type itself needs a delayed\n-         --  freeze and is not yet frozen.\n+      Possible_Freeze (Etype (Designator));\n+      Possible_Freeze (Base_Type (Etype (Designator))); -- needed ???\n \n-         Possible_Freeze (Etype (Designator));\n-         Possible_Freeze (Base_Type (Etype (Designator))); -- needed ???\n+      --  Need delayed freeze if any of the formal types themselves need\n+      --  a delayed freeze and are not yet frozen.\n \n-         --  Need delayed freeze if any of the formal types themselves need\n-         --  a delayed freeze and are not yet frozen.\n-\n-         F := First_Formal (Designator);\n-         while Present (F) loop\n-            Possible_Freeze (Etype (F));\n-            Possible_Freeze (Base_Type (Etype (F))); -- needed ???\n-            Next_Formal (F);\n-         end loop;\n-      end if;\n+      F := First_Formal (Designator);\n+      while Present (F) loop\n+         Possible_Freeze (Etype (F));\n+         Possible_Freeze (Base_Type (Etype (F))); -- needed ???\n+         Next_Formal (F);\n+      end loop;\n \n       --  Mark functions that return by reference. Note that it cannot be\n       --  done for delayed_freeze subprograms because the underlying"}]}