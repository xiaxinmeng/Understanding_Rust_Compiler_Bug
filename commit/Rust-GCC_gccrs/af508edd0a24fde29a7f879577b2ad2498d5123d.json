{"sha": "af508edd0a24fde29a7f879577b2ad2498d5123d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY1MDhlZGQwYTI0ZmRlMjlhN2Y4Nzk1NzdiMmFkMjQ5OGQ1MTIzZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-26T15:06:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-26T15:06:01Z"}, "message": "(do_store_flag): When computing via a shift, allow for an inner RSHIFT_EXPR in BITNUM.\n\n(do_store_flag): When computing via a shift, allow for an inner RSHIFT_EXPR\nin BITNUM.\nSometimes do the operations as signed.\n\nFrom-SVN: r4747", "tree": {"sha": "72fd3a71be6f482bcd04eae42c3139cb43c66a50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72fd3a71be6f482bcd04eae42c3139cb43c66a50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af508edd0a24fde29a7f879577b2ad2498d5123d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af508edd0a24fde29a7f879577b2ad2498d5123d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af508edd0a24fde29a7f879577b2ad2498d5123d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af508edd0a24fde29a7f879577b2ad2498d5123d/comments", "author": null, "committer": null, "parents": [{"sha": "96d4cf0aced6b394b62fbdb765d7e484123e3e61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96d4cf0aced6b394b62fbdb765d7e484123e3e61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96d4cf0aced6b394b62fbdb765d7e484123e3e61"}], "stats": {"total": 43, "additions": 35, "deletions": 8}, "files": [{"sha": "89be8598eb7b21e43460e8f213f152eae93d0702", "filename": "gcc/expr.c", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af508edd0a24fde29a7f879577b2ad2498d5123d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af508edd0a24fde29a7f879577b2ad2498d5123d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=af508edd0a24fde29a7f879577b2ad2498d5123d", "patch": "@@ -7864,30 +7864,57 @@ do_store_flag (exp, target, mode, only_cheap)\n       && integer_pow2p (TREE_OPERAND (arg0, 1))\n       && TYPE_PRECISION (type) <= HOST_BITS_PER_WIDE_INT)\n     {\n+      tree inner = TREE_OPERAND (arg0, 0);\n       int bitnum = exact_log2 (INTVAL (expand_expr (TREE_OPERAND (arg0, 1),\n \t\t\t\t\t\t    NULL_RTX, VOIDmode, 0)));\n+      int ops_unsignedp;\n+\n+      /* If INNER is a right shift of a constant and it plus BITNUM does\n+\t not overflow, adjust BITNUM and INNER.  */\n+\n+      if (TREE_CODE (inner) == RSHIFT_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (inner, 1)) == INTEGER_CST\n+\t  && TREE_INT_CST_HIGH (TREE_OPERAND (inner, 1)) == 0\n+\t  && (bitnum + TREE_INT_CST_LOW (TREE_OPERAND (inner, 1))\n+\t      < TYPE_PRECISION (type)))\n+\t{\n+\t  bitnum +=TREE_INT_CST_LOW (TREE_OPERAND (inner, 1));\n+\t  inner = TREE_OPERAND (inner, 0);\n+\t}\n+\n+      /* If we are going to be able to omit the AND below, we must do our\n+\t operations as unsigned.  If we must use the AND, we have a choice.\n+\t Normally unsigned is faster, but for some machines signed is.  */\n+      ops_unsignedp = (bitnum == TYPE_PRECISION (type) - 1 ? 1\n+#ifdef BYTE_LOADS_SIGN_EXTEND\n+\t\t       : 0\n+#else\n+\t\t       : 1\n+#endif\n+\t\t       );\n \n       if (subtarget == 0 || GET_CODE (subtarget) != REG\n \t  || GET_MODE (subtarget) != operand_mode\n-\t  || ! safe_from_p (subtarget, TREE_OPERAND (arg0, 0)))\n+\t  || ! safe_from_p (subtarget, inner))\n \tsubtarget = 0;\n \n-      op0 = expand_expr (TREE_OPERAND (arg0, 0), subtarget, VOIDmode, 0);\n+      op0 = expand_expr (inner, subtarget, VOIDmode, 0);\n \n       if (bitnum != 0)\n \top0 = expand_shift (RSHIFT_EXPR, GET_MODE (op0), op0,\n-\t\t\t    size_int (bitnum), target, 1);\n+\t\t\t    size_int (bitnum), target, ops_unsignedp);\n \n       if (GET_MODE (op0) != mode)\n-\top0 = convert_to_mode (mode, op0, 1);\n+\top0 = convert_to_mode (mode, op0, ops_unsignedp);\n+\n+      if ((code == EQ && ! invert) || (code == NE && invert))\n+\top0 = expand_binop (mode, xor_optab, op0, const1_rtx, target,\n+\t\t\t    ops_unsignedp, OPTAB_LIB_WIDEN);\n \n+      /* Put the AND last so it can combine with more things.  */\n       if (bitnum != TYPE_PRECISION (type) - 1)\n \top0 = expand_and (op0, const1_rtx, target);\n \n-      if ((code == EQ && ! invert) || (code == NE && invert))\n-\top0 = expand_binop (mode, xor_optab, op0, const1_rtx, target, 0,\n-\t\t\t    OPTAB_LIB_WIDEN);\n-\n       return op0;\n     }\n "}]}