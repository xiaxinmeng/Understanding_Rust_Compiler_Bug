{"sha": "c49439f11242a706e036abed21a70ac547cdaac7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ5NDM5ZjExMjQyYTcwNmUwMzZhYmVkMjFhNzBhYzU0N2NkYWFjNw==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-08-27T15:31:02Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-08-27T15:31:02Z"}, "message": "Scheduling revamp:\n\n\t* sh.md (attribute type): Add types mt_group, fload, pcfload, fpul_gp,\n\tmac_gp ftrc_s and cwb.  Add / Adjust definitions in individual insn\n\taccordingly.\n\t(attribute insn_class): Provide default definitions based on type.\n\tRemove all insn-specific settings.\n\t(various function units): Remove old SH4 scheduling.\n\t(branch_zero, dfp_comp, late_fp_use, any_fp_comp, any_int_load):\n\tNew attributes.  Set them where appropriate.\n\t(cpu unit FS): Don't define / use.\n\t(F3, load_store): New cpu units.\n\t(F01): New reservation.\n\t(all insn_reservations): Make dependent on sh4 pipeline model.\n\tFix latencies.\n\t(nil, reg_mov, freg_mov, sh4_fpul_gp, sh4_call): New insn_reservations.\n\t(sh4_mac_gp, fp_arith_ftrc, arith3, arith3b): Likewise.\n\t(mt insn_reservation): Use type mt_group.\n\t(insn_reservation load_store): Split into sh4_load, sh4_load_si,\n\tsh4_fload and sh4_store.\n\t(insn_reservation branch_zero and branch): Replace with sh4_branch.\n\t(insn_reservation branch_far): Replace with sh4_return.\n\t(insn_reservation return_from_exp): Rename to:\n\t(sh4_return_from_exp).  Change to be just d_lock*5.\n\t(insn_reservation lds_to_pr): Rename to:\n\t(sh4_lds_to_pr).  Change to be just d_lock*2.\n\t(insn_reservation ldsmem_to_pr, sts_from_pr): Change to be just\n\td_lock*2.\n\t(insn_reservation prload_mem): Rename to:\n\t(sh4_prstore_mem).  Change to d_lock*2,nothing,memory.\n\t(insn_reservation fpscr_store): Rename to:\n\t(fpscr_load).  Change to d_lock,nothing,F1*3.\n\t(insn_reservation fpscr_store_mem): Rename to:\n\t(fpscr_load_mem).  Change to d_lock,nothing,(F1+memory),F1*2.\n\t(insn_reservation multi): Change to\n\td_lock,(d_lock+f1_1),(f1_1|f1_2)*3,F2.\n\t(insn_reservation fp_arith): Change to issue,F01,F2.\n\t(insn_reservation fp_div: Change to issue,F01+F3,F2+F3,F3*7,F1+F3,F2.\n\t(insn_reservation dp_float): Change to issue,F01,F1+F2,F2.\n\t(insn_reservation fp_double_arith): Change to issue,F01,F1+F2,fpu*4,F2.\n\t(insn_reservation fp_double_cmp): Change to\n\td_lock,(d_lock+F01),F1+F2,F2.\n\t(insn_reservation dp_div): Change to\n\tissue,F01+F3,F1+F2+F3,F2+F3,F3*16,F1+F3,(fpu+F3)*2,F2.\n\t* sh.c (flow_dependent_p, flow_dependent_p_1): New functions.\n\t(sh_adjust_cost, SHcompact): Differentiate between different\n\tkinds of dependencies.  Drop factor of ten for superscalar.\n\tUse new instruction types.  Add new exception rules.\n\nTwo small bug fixes:\n\t* sh.md (mulhisi3, umulhisi3: Add a REG_EQUAL note.\n\n\t* sh.md (mperm_w): Add DONE.\n\nFrom-SVN: r56601", "tree": {"sha": "5409446db95d8b24bbcd79a331adae8e9c703328", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5409446db95d8b24bbcd79a331adae8e9c703328"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c49439f11242a706e036abed21a70ac547cdaac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49439f11242a706e036abed21a70ac547cdaac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c49439f11242a706e036abed21a70ac547cdaac7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49439f11242a706e036abed21a70ac547cdaac7/comments", "author": null, "committer": null, "parents": [{"sha": "f34fc46e7972fe81d1327b76a72b68530486cb83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f34fc46e7972fe81d1327b76a72b68530486cb83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f34fc46e7972fe81d1327b76a72b68530486cb83"}], "stats": {"total": 951, "additions": 543, "deletions": 408}, "files": [{"sha": "bb1ab0855a88742ce834fdf31fb8218aeb61a67a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49439f11242a706e036abed21a70ac547cdaac7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49439f11242a706e036abed21a70ac547cdaac7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c49439f11242a706e036abed21a70ac547cdaac7", "patch": "@@ -1,3 +1,56 @@\n+Tue Aug 27 14:39:09 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.md (attribute type): Add types mt_group, fload, pcfload, fpul_gp,\n+\tmac_gp ftrc_s and cwb.  Add / Adjust definitions in individual insn\n+\taccordingly.\n+\t(attribute insn_class): Provide default definitions based on type.\n+\tRemove all insn-specific settings.\n+\t(various function units): Remove old SH4 scheduling.\n+\t(branch_zero, dfp_comp, late_fp_use, any_fp_comp, any_int_load):\n+\tNew attributes.  Set them where appropriate.\n+\t(cpu unit FS): Don't define / use.\n+\t(F3, load_store): New cpu units.\n+\t(F01): New reservation.\n+\t(all insn_reservations): Make dependent on sh4 pipeline model.\n+\tFix latencies.\n+\t(nil, reg_mov, freg_mov, sh4_fpul_gp, sh4_call): New insn_reservations.\n+\t(sh4_mac_gp, fp_arith_ftrc, arith3, arith3b): Likewise.\n+\t(mt insn_reservation): Use type mt_group.\n+\t(insn_reservation load_store): Split into sh4_load, sh4_load_si,\n+\tsh4_fload and sh4_store.\n+\t(insn_reservation branch_zero and branch): Replace with sh4_branch.\n+\t(insn_reservation branch_far): Replace with sh4_return.\n+\t(insn_reservation return_from_exp): Rename to:\n+\t(sh4_return_from_exp).  Change to be just d_lock*5.\n+\t(insn_reservation lds_to_pr): Rename to:\n+\t(sh4_lds_to_pr).  Change to be just d_lock*2.\n+\t(insn_reservation ldsmem_to_pr, sts_from_pr): Change to be just\n+\td_lock*2.\n+\t(insn_reservation prload_mem): Rename to:\n+\t(sh4_prstore_mem).  Change to d_lock*2,nothing,memory.\n+\t(insn_reservation fpscr_store): Rename to:\n+\t(fpscr_load).  Change to d_lock,nothing,F1*3.\n+\t(insn_reservation fpscr_store_mem): Rename to:\n+\t(fpscr_load_mem).  Change to d_lock,nothing,(F1+memory),F1*2.\n+\t(insn_reservation multi): Change to\n+\td_lock,(d_lock+f1_1),(f1_1|f1_2)*3,F2.\n+\t(insn_reservation fp_arith): Change to issue,F01,F2.\n+\t(insn_reservation fp_div: Change to issue,F01+F3,F2+F3,F3*7,F1+F3,F2.\n+\t(insn_reservation dp_float): Change to issue,F01,F1+F2,F2.\n+\t(insn_reservation fp_double_arith): Change to issue,F01,F1+F2,fpu*4,F2.\n+\t(insn_reservation fp_double_cmp): Change to\n+\td_lock,(d_lock+F01),F1+F2,F2.\n+\t(insn_reservation dp_div): Change to\n+\tissue,F01+F3,F1+F2+F3,F2+F3,F3*16,F1+F3,(fpu+F3)*2,F2.\n+\t* sh.c (flow_dependent_p, flow_dependent_p_1): New functions.\n+\t(sh_adjust_cost, SHcompact): Differentiate between different\n+\tkinds of dependencies.  Drop factor of ten for superscalar.\n+\tUse new instruction types.  Add new exception rules.\n+\n+\t* sh.md (mulhisi3, umulhisi3: Add a REG_EQUAL note.\n+\n+\t* sh.md (mperm_w): Add DONE.\n+\n 2002-08-27  David Edelsohn  <edelsohn@gnu.org>\n \n \t* longlong.h: Import current PowerPC defintion from GMP-4.1."}, {"sha": "228e0fa9fc4c116bc90bf790f14bfc8f26bf1bf5", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 116, "deletions": 45, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49439f11242a706e036abed21a70ac547cdaac7/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49439f11242a706e036abed21a70ac547cdaac7/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c49439f11242a706e036abed21a70ac547cdaac7", "patch": "@@ -208,6 +208,8 @@ static const char *sh_strip_name_encoding PARAMS ((const char *));\n static void sh_init_builtins PARAMS ((void));\n static void sh_media_init_builtins PARAMS ((void));\n static rtx sh_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n+static int flow_dependent_p PARAMS ((rtx, rtx));\n+static void flow_dependent_p_1 PARAMS ((rtx, rtx, void *));\n \n \f\n /* Initialize the GCC target structure.  */\n@@ -6994,7 +6996,7 @@ sh_adjust_cost (insn, link, dep_insn, cost)\n      rtx dep_insn;\n      int cost;\n {\n-  rtx reg;\n+  rtx reg, use_pat;\n \n   if (TARGET_SHMEDIA)\n     {\n@@ -7007,49 +7009,119 @@ sh_adjust_cost (insn, link, dep_insn, cost)\n           && get_attr_is_mac_media (dep_insn))\n         cost = 1;\n     }\n-  else if (GET_CODE(insn) == CALL_INSN)\n+  else if (REG_NOTE_KIND (link) == 0)\n     {\n+      enum attr_type dep_type, type;\n+\n+      if (recog_memoized (insn) < 0\n+\t  || recog_memoized (dep_insn) < 0)\n+\treturn;\n+\n+      dep_type = get_attr_type (dep_insn);\n+      if (dep_type == TYPE_FLOAD || dep_type == TYPE_PCFLOAD)\n+\tcost--;\n+      if ((dep_type == TYPE_LOAD_SI || dep_type == TYPE_PCLOAD_SI)\n+\t  && (type = get_attr_type (insn)) != TYPE_CALL\n+\t  && type != TYPE_SFUNC)\n+\tcost--;\n+\n       /* The only input for a call that is timing-critical is the\n \t function's address.  */\n-      rtx call = PATTERN (insn);\n-\n-      if (GET_CODE (call) == PARALLEL)\n-\tcall = XVECEXP (call, 0 ,0);\n-      if (GET_CODE (call) == SET)\n-\tcall = SET_SRC (call);\n-      if (GET_CODE (call) == CALL && GET_CODE (XEXP (call, 0)) == MEM\n-\t  && ! reg_set_p (XEXP (XEXP (call, 0), 0), dep_insn))\n-\tcost = 0;\n-    }\n-  /* All sfunc calls are parallels with at least four components.\n-     Exploit this to avoid unnecessary calls to sfunc_uses_reg.  */\n-  else if (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t   && XVECLEN (PATTERN (insn), 0) >= 4\n-\t   && (reg = sfunc_uses_reg (insn)))\n-    {\n+      if (GET_CODE(insn) == CALL_INSN)\n+\t{\n+\t  rtx call = PATTERN (insn);\n+\n+\t  if (GET_CODE (call) == PARALLEL)\n+\t    call = XVECEXP (call, 0 ,0);\n+\t  if (GET_CODE (call) == SET)\n+\t    call = SET_SRC (call);\n+\t  if (GET_CODE (call) == CALL && GET_CODE (XEXP (call, 0)) == MEM\n+\t      && ! reg_set_p (XEXP (XEXP (call, 0), 0), dep_insn))\n+\t    cost = 0;\n+\t}\n       /* Likewise, the most timing critical input for an sfuncs call\n \t is the function address.  However, sfuncs typically start\n \t using their arguments pretty quickly.\n \t Assume a four cycle delay before they are needed.  */\n-      if (! reg_set_p (reg, dep_insn))\n-\tcost -= TARGET_SUPERSCALAR ? 40 : 4;\n-    }\n-  /* Adjust load_si / pcload_si type insns latency.  Use the known\n-     nominal latency and form of the insn to speed up the check.  */\n-  else if (cost == 3\n-\t   && GET_CODE (PATTERN (dep_insn)) == SET\n-\t   /* Latency for dmpy type insns is also 3, so check the that\n-\t      it's actually a move insn.  */\n-\t   && general_movsrc_operand (SET_SRC (PATTERN (dep_insn)), SImode))\n+      /* All sfunc calls are parallels with at least four components.\n+\t Exploit this to avoid unnecessary calls to sfunc_uses_reg.  */\n+      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t       && XVECLEN (PATTERN (insn), 0) >= 4\n+\t       && (reg = sfunc_uses_reg (insn)))\n+\t{\n+\t  if (! reg_set_p (reg, dep_insn))\n+\t    cost -= 4;\n+\t}\n+      /* When the preceding instruction loads the shift amount of\n+\t the following SHAD/SHLD, the latency of the load is increased\n+\t by 1 cycle.  */\n+      else if (TARGET_SH4\n+\t       && get_attr_type (insn) == TYPE_DYN_SHIFT\n+\t       && get_attr_any_int_load (dep_insn) == ANY_INT_LOAD_YES\n+\t       && reg_overlap_mentioned_p (SET_DEST (PATTERN (dep_insn)),\n+\t\t\t\t\t   XEXP (SET_SRC (single_set(insn)),\n+\t\t\t\t\t\t 1)))\n+\tcost++;\n+      /* When an LS group instruction with a latency of less than\n+\t 3 cycles is followed by a double-precision floating-point\n+\t instruction, FIPR, or FTRV, the latency of the first\n+\t instruction is increased to 3 cycles.  */\n+      else if (cost < 3\n+\t       && get_attr_insn_class (dep_insn) == INSN_CLASS_LS_GROUP\n+\t       && get_attr_dfp_comp (insn) == DFP_COMP_YES)\n+\tcost = 3;\n+      /* The lsw register of a double-precision computation is ready one\n+\t cycle earlier.  */\n+      else if (reload_completed\n+\t       && get_attr_dfp_comp (dep_insn) == DFP_COMP_YES\n+\t       && (use_pat = single_set (insn))\n+\t       && ! regno_use_in (REGNO (SET_DEST (single_set (dep_insn))),\n+\t\t\t\t  SET_SRC (use_pat)))\n+\tcost -= 1;\n+\n+      if (get_attr_any_fp_comp (dep_insn) == ANY_FP_COMP_YES\n+\t  && get_attr_late_fp_use (insn) == LATE_FP_USE_YES)\n+\tcost -= 1;\n+    }\n+  /* An anti-dependence penalty of two applies if the first insn is a double\n+     precision fadd / fsub / fmul.  */\n+  else if (REG_NOTE_KIND (link) == REG_DEP_ANTI\n+\t   && recog_memoized (dep_insn) >= 0\n+\t   && get_attr_type (dep_insn) == TYPE_DFP_ARITH\n+\t   /* A lot of alleged anti-flow dependences are fake,\n+\t      so check this one is real.  */\n+\t   && flow_dependent_p (dep_insn, insn))\n     cost = 2;\n-  else if (cost == 30\n-\t   && GET_CODE (PATTERN (dep_insn)) == SET\n-\t   && GET_MODE (SET_SRC (PATTERN (dep_insn))) == SImode)\n-    cost = 20;\n+\n \n   return cost;\n }\n \n+/* Check if INSN is flow-dependent on DEP_INSN.  Can also be used to check\n+   if DEP_INSN is anti-flow dependent on INSN.  */\n+static int\n+flow_dependent_p (insn, dep_insn)\n+     rtx insn, dep_insn;\n+{\n+  rtx tmp = PATTERN (insn);\n+\n+  note_stores (PATTERN (dep_insn), flow_dependent_p_1, &tmp);\n+  return tmp == NULL_RTX;\n+}\n+\n+/* A helper function for flow_dependent_p called through note_stores.  */\n+static void\n+flow_dependent_p_1 (x, pat, data)\n+     rtx x;\n+     rtx pat ATTRIBUTE_UNUSED;\n+     void *data;\n+{\n+  rtx * pinsn = (rtx *) data;\n+\n+  if (*pinsn && reg_referenced_p (x, *pinsn))\n+    *pinsn = NULL_RTX;\n+}\n+\n /* For use by ALLOCATE_INITIAL_VALUE.  Note that sh.md contains some\n    'special function' patterns (type sfunc) that clobber pr, but that\n    do not look like function calls to leaf_function_p.  Hence we must\n@@ -7060,27 +7132,26 @@ sh_pr_n_sets ()\n   return REG_N_SETS (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n }\n \n-/* This Function Returns non zero if DFA based scheduler\n-   interface is to be used.At present supported only for\n-   SH4.  */\n+/* This Function returns non zero if the DFA based scheduler interface\n+   is to be used.  At present this is supported for the SH4 only.  */\n static int\n sh_use_dfa_interface()\n {\n-        if (TARGET_SH4)\n-                return 1;\n-        else\n-                return 0;\n+  if (TARGET_HARD_SH4)\n+    return 1;\n+  else\n+    return 0;\n }\n \n-/* This function returns \"2\" that signifies dual issue \n-   for SH4 processor.To be used by DFA pipeline description.  */\n+/* This function returns \"2\" to indicate dual issue for the SH4\n+   processor.  To be used by the DFA pipeline description.  */\n static int\n sh_issue_rate()\n {\n-\tif(TARGET_SH4)\n-\t\treturn 2;\n-\telse\n-\t\treturn 1;\n+  if (TARGET_SUPERSCALAR)\n+    return 2;\n+  else\n+    return 1;\n }\n \n /* SHmedia requires registers for branches, so we can't generate new"}, {"sha": "88b2dc89a9e6c9b3b3ceb67727bcace944809cda", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 374, "deletions": 363, "changes": 737, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49439f11242a706e036abed21a70ac547cdaac7/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49439f11242a706e036abed21a70ac547cdaac7/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=c49439f11242a706e036abed21a70ac547cdaac7", "patch": "@@ -183,8 +183,10 @@\n ;; arith3b\tlike above, but might end with a redirected branch\n ;; load\t\tfrom memory\n ;; load_si\tLikewise, SImode variant for general register.\n+;; fload\tLikewise, but load to fp register.\n ;; store\tto memory\n-;; move\t\tregister to register\n+;; move\t\tgeneral purpose register to register\n+;; mt_group\tother sh4 mt instructions\n ;; fmove\tregister to register, floating point\n ;; smpy\t\tword precision integer multiply\n ;; dmpy\t\tlongword or doublelongword precision integer multiply\n@@ -194,15 +196,20 @@\n ;; pstore\tstore of pr reg, which can't be put into delay slot of jsr\n ;; prget\tcopy pr to register, ditto\n ;; pcload\tpc relative load of constant value\n+;; pcfload\tLikewise, but load to fp register.\n ;; pcload_si\tLikewise, SImode variant for general register.\n ;; rte\t\treturn from exception\n ;; sfunc\tspecial function call with known used registers\n ;; call\t\tfunction call\n ;; fp\t\tfloating point\n ;; fdiv\t\tfloating point divide (or square root)\n-;; gp_fpul\tmove between general purpose register and fpul\n+;; gp_fpul\tmove from general purpose register to fpul\n+;; fpul_gp\tmove from fpul to general purpose register\n+;; mac_gp\tmove from mac[lh] to general purpose register\n ;; dfp_arith, dfp_cmp,dfp_conv\n+;; ftrc_s\tfix_truncsfsi2_i4\n ;; dfdiv\tdouble precision floating point divide (or square root)\n+;; cwb\t\tic_invalidate_line_i\n ;; arith_media\tSHmedia arithmetic, logical, and shift instructions\n ;; cbranch_media SHmedia conditional branch instructions\n ;; cmp_media\tSHmedia compare instructions\n@@ -233,30 +240,32 @@\n ;; nil\t\tno-op move, will be deleted.\n \n (define_attr \"type\"\n- \"cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,load,load_si,store,move,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,rte,sfunc,call,fp,fdiv,dfp_arith,dfp_cmp,dfp_conv,dfdiv,gp_fpul,arith_media,cbranch_media,cmp_media,dfdiv_media,dfmul_media,dfparith_media,dfpconv_media,dmpy_media,fcmp_media,fdiv_media,fload_media,fmove_media,fparith_media,fpconv_media,fstore_media,gettr_media,invalidate_line_media,jump_media,load_media,pt_media,ptabs_media,store_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media,nil,other\"\n+ \"mt_group,cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,load,load_si,fload,store,move,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,pcfload,rte,sfunc,call,fp,fdiv,ftrc_s,dfp_arith,dfp_cmp,dfp_conv,dfdiv,gp_fpul,fpul_gp,mac_gp,mem_fpscr,gp_fpscr,cwb,arith_media,cbranch_media,cmp_media,dfdiv_media,dfmul_media,dfparith_media,dfpconv_media,dmpy_media,fcmp_media,fdiv_media,fload_media,fmove_media,fparith_media,fpconv_media,fstore_media,gettr_media,invalidate_line_media,jump_media,load_media,pt_media,ptabs_media,store_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media,nil,other\"\n   (const_string \"other\"))\n \n ;; We define a new attribute namely \"insn_class\".We use\n-;; this for DFA based pipeline description.\n-;; Although the \"type\" attribute covers almost all insn \n-;; classes,it is more convenient to define new attribute\n-;; for certain reservations.\n+;; this for the DFA based pipeline description.\n ;;\n ;; mt_group      SH4 \"mt\" group instructions.\n ;;\n-;; ex_group      SH4 \"ex\" group instructions.They mostly\n-;;               overlap with arithmetic instructions but\n-;;               new attribute defined to distinguish from\n-;;\t         mt group instructions.\n+;; ex_group      SH4 \"ex\" group instructions.\n+;;\n+;; ls_group      SH4 \"ls\" group instructions.\n ;;\n-;; lds_to_fpscr  The \"type\" attribute couldn't sufficiently\n-;;               distinguish it from others.It is part of \n-;;               new attribute.Similar case with ldsmem_to_fpscr\n-;;\t  \t and cwb. \n \n (define_attr \"insn_class\"\n-\t     \"mt_group,ex_group,lds_to_fpscr,ldsmem_to_fpscr,cwb,none\"\n-\t     (const_string \"none\"))\n+  \"mt_group,ex_group,ls_group,br_group,fe_group,co_group,none\"\n+  (cond [(eq_attr \"type\" \"move,mt_group\") (const_string \"mt_group\")\n+         (eq_attr \"type\" \"arith,dyn_shift\") (const_string \"ex_group\")\n+\t (eq_attr \"type\" \"fmove,load,pcload,load_si,pcload_si,fload,pcfload,store,gp_fpul,fpul_gp\") (const_string \"ls_group\")\n+\t (eq_attr \"type\" \"cbranch,jump\") (const_string \"br_group\")\n+\t (eq_attr \"type\" \"fp,fdiv,ftrc_s,dfp_arith,dfp_conv,dfdiv\")\n+\t   (const_string \"fe_group\")\n+\t (eq_attr \"type\" \"jump_ind,smpy,dmpy,mac_gp,return,pload,prset,pstore,prget,rte,sfunc,call,dfp_cmp,mem_fpscr,gp_fpscr,cwb\") (const_string \"co_group\")]\n+\t(const_string \"none\")))\n+;; nil are zero instructions, and arith3 / arith3b are multiple instructions,\n+;; so these do not belong in an insn group, although they are modeled\n+;; with their own define_insn_reservations.\n \n ;; Indicate what precision must be selected in fpscr for this insn, if any.\n \n@@ -445,178 +454,6 @@\n   (and (eq_attr \"pipe_model\" \"sh1\") (eq_attr \"type\" \"fdiv\")) 13 12)\n \n \n-;; SH4 scheduling\n-;; The SH4 is a dual-issue implementation, thus we have to multiply all\n-;; costs by at least two.\n-;; There will be single increments of the modeled that don't correspond\n-;; to the actual target ;; whenever two insns to be issued depend one a\n-;; single resource, and the scheduler picks to be the first one.\n-;; If we multiplied the costs just by two, just two of these single\n-;; increments would amount to an actual cycle.  By picking a larger\n-;; factor, we can ameliorate the effect; However, we then have to make sure\n-;; that only two insns are modeled as issued per actual cycle.\n-;; Moreover, we need a way to specify the latency of insns that don't\n-;; use an actual function unit.\n-;; We use an 'issue' function unit to do that, and a cost factor of 10.\n-\n-(define_function_unit \"issue\" 2 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"!nil,arith3\"))\n-  10 10)\n-\n-(define_function_unit \"issue\" 2 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"arith3\"))\n-  30 30)\n-\n-;; There is no point in providing exact scheduling information about branches,\n-;; because they are at the starts / ends of basic blocks anyways.\n-\n-;; Some insns cannot be issued before/after another insn in the same cycle,\n-;; irrespective of the type of the other insn.\n-\n-;; default is dual-issue, but can't be paired with an insn that\n-;; uses multiple function units.\n-(define_function_unit \"single_issue\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"!smpy,dmpy,pload,pstore,dfp_cmp,gp_fpul,call,sfunc,arith3,arith3b\"))\n-  1 10\n-  [(eq_attr \"type\" \"smpy,dmpy,pload,pstore,dfp_cmp,gp_fpul\")])\n-\n-(define_function_unit \"single_issue\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"smpy,dmpy,pload,pstore,dfp_cmp,gp_fpul\"))\n-  10 10\n-  [(const_int 1)])\n-\n-;; arith3 insns are always pairable at the start, but not inecessarily at\n-;; the end; however, there doesn't seem to be a way to express that.\n-(define_function_unit \"single_issue\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"arith3\"))\n-  30 20\n-  [(const_int 1)])\n-\n-;; arith3b insn are pairable at the end and have latency that prevents pairing\n-;; with the following branch, but we don't want this latency be respected;\n-;; When the following branch is immediately adjacent, we can redirect the\n-;; internal branch, which is likly to be a larger win.\n-(define_function_unit \"single_issue\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"arith3b\"))\n-  20 20\n-  [(const_int 1)])\n-\n-;; calls introduce a longisch delay that is likely to flush the pipelines.\n-(define_function_unit \"single_issue\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"call,sfunc\"))\n-  160 160\n-  [(eq_attr \"type\" \"!call\") (eq_attr \"type\" \"call\")])\n-\n-;; Load and store instructions have no alignment peculiarities for the SH4,\n-;; but they use the load-store unit, which they share with the fmove type\n-;; insns (fldi[01]; fmov frn,frm; flds; fsts; fabs; fneg) .\n-;; Loads have a latency of two.\n-;; However, call insns can only paired with a preceding insn, and have\n-;; a delay slot, so that we want two more insns to be scheduled between the\n-;; load of the function address and the call.  This is equivalent to a\n-;; latency of three.\n-;; We cannot use a conflict list for this, because we need to distinguish\n-;; between the actual call address and the function arguments.\n-;; ADJUST_COST can only properly handle reductions of the cost, so we\n-;; use a latency of three here, which gets multiplied by 10 to yield 30.\n-;; We only do this for SImode loads of general registers, to make the work\n-;; for ADJUST_COST easier.\n-\n-;; When specifying different latencies for different insns using the\n-;; the same function unit, genattrtab.c assumes a 'FIFO constraint'\n-;; so that the blockage is at least READY-COST (E) + 1 - READY-COST (C)\n-;; for an executing insn E and a candidate insn C.\n-;; Therefore, we define three different function units for load_store:\n-;; load_store, load and load_si.\n-\n-(define_function_unit \"load_si\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"load_si,pcload_si\")) 30 10)\n-(define_function_unit \"load\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"load,pcload,pload\")) 20 10)\n-(define_function_unit \"load_store\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"load_si,pcload_si,load,pcload,pload,store,pstore,fmove\"))\n-  10 10)\n-\n-(define_function_unit \"int\"    1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"arith,dyn_shift\")) 10 10)\n-\n-;; Again, we have to pretend a lower latency for the \"int\" unit to avoid a\n-;; spurious FIFO constraint; the multiply instructions use the \"int\"\n-;; unit actually only for two cycles.\n-(define_function_unit \"int\"    1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"smpy,dmpy\")) 20 20)\n-\n-;; We use a fictous \"mpy\" unit to express the actual latency.\n-(define_function_unit \"mpy\"    1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"smpy,dmpy\")) 40 20)\n-\n-;; Again, we have to pretend a lower latency for the \"int\" unit to avoid a\n-;; spurious FIFO constraint.\n-(define_function_unit \"int\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"gp_fpul\")) 10 10)\n-\n-;; We use a fictous \"gp_fpul\" unit to express the actual latency.\n-(define_function_unit \"gp_fpul\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"gp_fpul\")) 20 10)\n-\n-;; ??? multiply uses the floating point unit, but with a two cycle delay.\n-;; Thus, a simple single-precision fp operation could finish if issued in\n-;; the very next cycle, but stalls when issued two or three cycles later.\n-;; Similarily, a divide / sqrt can work without stalls if issued in\n-;; the very next cycle, while it would have to block if issued two or\n-;; three cycles later.\n-;; There is no way to model this with gcc's function units.  This problem is\n-;; actually mentioned in md.texi.  Tackling this problem requires first that\n-;; it is possible to speak about the target in an open discussion.\n-;;\n-;; However, simple double-precision operations always conflict.\n-\n-(define_function_unit \"fp\"    1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"smpy,dmpy\")) 40 40\n-  [(eq_attr \"type\" \"dfp_cmp,dfp_conv,dfp_arith\")])\n-\n-;; The \"fp\" unit is for pipeline stages F1 and F2.\n-\n-(define_function_unit \"fp\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"fp\")) 30 10)\n-\n-;; Again, we have to pretend a lower latency for the \"fp\" unit to avoid a\n-;; spurious FIFO constraint; the bulk of the fdiv type insns executes in\n-;; the F3 stage.\n-(define_function_unit \"fp\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"fdiv\")) 30 10)\n-\n-;; The \"fdiv\" function unit models the aggregate effect of the F1, F2 and F3\n-;; pipeline stages on the pipelining of fdiv/fsqrt insns.\n-;; We also use it to give the actual latency here.\n-;; fsqrt is actually one cycle faster than fdiv (and the value used here),\n-;; but that will hardly matter in practice for scheduling.\n-(define_function_unit \"fdiv\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"fdiv\")) 120 100)\n-\n-;; There is again a late use of the \"fp\" unit by [d]fdiv type insns\n-;; that we can't express.\n-\n-(define_function_unit \"fp\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"dfp_cmp,dfp_conv\")) 40 20)\n-\n-(define_function_unit \"fp\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"dfp_arith\")) 80 60)\n-\n-(define_function_unit \"fp\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"dfdiv\")) 230 10)\n-\n-(define_function_unit \"fdiv\"     1 0\n-  (and (eq_attr \"pipe_model\" \"sh4\") (eq_attr \"type\" \"dfdiv\")) 230 210)\n-\n ;; SH-5 SHmedia scheduling\n ;; When executing SHmedia code, the SH-5 is a fairly straightforward\n ;; single-issue machine.  It has four pipelines, the branch unit (br),\n@@ -706,6 +543,35 @@\n (define_attr \"is_mac_media\" \"\"\n   (if_then_else (eq_attr \"type\" \"mac_media\") (const_int 1) (const_int 0)))\n \n+(define_attr \"branch_zero\" \"yes,no\"\n+  (cond [(eq_attr \"type\" \"!cbranch\") (const_string \"no\")\n+\t (ne (symbol_ref \"(next_active_insn (insn)\\\n+\t\t\t   == (prev_active_insn\\\n+\t\t\t       (XEXP (SET_SRC (PATTERN (insn)), 1))))\\\n+\t\t\t  && get_attr_length (next_active_insn (insn)) == 2\")\n+\t     (const_int 0))\n+\t (const_string \"yes\")]\n+\t(const_string \"no\")))\n+\n+;; SH4 Double-precision computation with double-precision result -\n+;; the two halves are ready at different times.\n+(define_attr \"dfp_comp\" \"yes,no\"\n+  (cond [(eq_attr \"type\" \"dfp_arith,dfp_conv,dfdiv\") (const_string \"yes\")]\n+\t(const_string \"no\")))\n+\n+;; Insns for which the latency of a preceding fp insn is decreased by one.\n+(define_attr \"late_fp_use\" \"yes,no\" (const_string \"no\"))\n+;; And feeding insns for which this relevant.\n+(define_attr \"any_fp_comp\" \"yes,no\"\n+  (cond [(eq_attr \"type\" \"fp,fdiv,ftrc_s,dfp_arith,dfp_conv,dfdiv\")\n+\t (const_string \"yes\")]\n+\t(const_string \"no\")))\n+\n+(define_attr \"any_int_load\" \"yes,no\"\n+  (cond [(eq_attr \"type\" \"load,load_si,pcload,pcload_si\")\n+\t (const_string \"yes\")]\n+\t(const_string \"no\")))\n+\n (define_delay\n   (eq_attr \"needs_delay_slot\" \"yes\")\n   [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n@@ -755,7 +621,7 @@\n \t       (const_int 0)))]\n   \"TARGET_SH1\"\n   \"tst\t%1,%0\"\n-  [(set_attr \"insn_class\" \"mt_group\")])\n+  [(set_attr \"type\" \"mt_group\")])\n \n ;; ??? Perhaps should only accept reg/constant if the register is reg 0.\n ;; That would still allow reload to create cmpi instructions, but would\n@@ -772,7 +638,7 @@\n \ttst\t%0,%0\n \tcmp/eq\t%1,%0\n \tcmp/eq\t%1,%0\"\n-   [(set_attr \"insn_class\" \"mt_group,mt_group,mt_group\")])\n+   [(set_attr \"type\" \"mt_group\")])\n \n (define_insn \"cmpgtsi_t\"\n   [(set (reg:SI T_REG)\n@@ -782,7 +648,7 @@\n   \"@\n \tcmp/gt\t%1,%0\n \tcmp/pl\t%0\"\n-   [(set_attr \"insn_class\" \"mt_group,mt_group\")])\n+   [(set_attr \"type\" \"mt_group\")])\n \n (define_insn \"cmpgesi_t\"\n   [(set (reg:SI T_REG)\n@@ -792,7 +658,7 @@\n   \"@\n \tcmp/ge\t%1,%0\n \tcmp/pz\t%0\"\n-   [(set_attr \"insn_class\" \"mt_group,mt_group\")])\n+   [(set_attr \"type\" \"mt_group\")])\n \n ;; -------------------------------------------------------------------------\n ;; SImode unsigned integer comparisons\n@@ -804,15 +670,15 @@\n \t\t(match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"cmp/hs\t%1,%0\"\n-   [(set_attr \"insn_class\" \"mt_group\")])\n+   [(set_attr \"type\" \"mt_group\")])\n \n (define_insn \"cmpgtusi_t\"\n   [(set (reg:SI T_REG)\n \t(gtu:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n \t\t(match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"cmp/hi\t%1,%0\"\n-   [(set_attr \"insn_class\" \"mt_group\")])\n+   [(set_attr \"type\" \"mt_group\")])\n \n ;; We save the compare operands in the cmpxx patterns and use them when\n ;; we generate the branch.\n@@ -909,7 +775,7 @@\n \tcmp/eq\\\\t%S1,%S0\\;bf{.|/}s\\\\t%,Ldi%=\\;cmp/ge\\\\t%S1,%S0\\;cmp/hs\\\\t%R1,%R0\\\\n%,Ldi%=:\n \tcmp/pz\\\\t%S0\"\n   [(set_attr \"length\" \"8,2\")\n-   (set_attr \"type\" \"arith3,arith\")])\n+   (set_attr \"type\" \"arith3,mt_group\")])\n \f\n ;; -------------------------------------------------------------------------\n ;; DImode unsigned integer comparisons\n@@ -1176,8 +1042,7 @@\n \t(ltu:SI (plus:SI (match_dup 1) (match_dup 2)) (match_dup 1)))]\n   \"TARGET_SH1\"\n   \"addc\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"addc1\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -1187,8 +1052,7 @@\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n   \"addc\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n@@ -1217,8 +1081,7 @@\n \t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n   \"TARGET_SH1\"\n   \"add\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n ;; -------------------------------------------------------------------------\n ;; Subtraction instructions\n@@ -1287,8 +1150,7 @@\n \t(gtu:SI (minus:SI (match_dup 1) (match_dup 2)) (match_dup 1)))]\n   \"TARGET_SH1\"\n   \"subc\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"subc1\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -1298,17 +1160,15 @@\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n   \"subc\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"*subsi3_internal\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"sub\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"*subsi3_media\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -1734,6 +1594,14 @@\n      invariant code motion can move it.  */\n   REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n   REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  /* expand_binop can't find a suitable code in umul_widen_optab to\n+     make a REG_EQUAL note from, so make one here.\n+     See also smulsi3_highpart.\n+     ??? Alternatively, we could put this at the calling site of expand_binop,\n+     i.e. expand_expr.  */\n+  REG_NOTES (last)\n+    = gen_rtx_EXPR_LIST (REG_EQUAL, copy_rtx (SET_SRC (single_set (first))),\n+\t\t\t REG_NOTES (last));\n   DONE;\n }\")\n \n@@ -1756,6 +1624,14 @@\n      invariant code motion can move it.  */\n   REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n   REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  /* expand_binop can't find a suitable code in umul_widen_optab to\n+     make a REG_EQUAL note from, so make one here.\n+     See also smulsi3_highpart.\n+     ??? Alternatively, we could put this at the calling site of expand_binop,\n+     i.e. expand_expr.  */\n+  REG_NOTES (last)\n+    = gen_rtx_EXPR_LIST (REG_EQUAL, copy_rtx (SET_SRC (single_set (first))),\n+\t\t\t REG_NOTES (last));\n   DONE;\n }\")\n \n@@ -2019,6 +1895,7 @@\n   REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n   /* expand_binop can't find a suitable code in mul_highpart_optab to\n      make a REG_EQUAL note from, so make one here.\n+     See also {,u}mulhisi.\n      ??? Alternatively, we could put this at the calling site of expand_binop,\n      i.e. expand_mult_highpart.  */\n   REG_NOTES (last)\n@@ -2076,8 +1953,7 @@\n \t\t(match_operand:SI 2 \"logical_operand\" \"r,L\")))]\n   \"TARGET_SH1\"\n   \"and\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n ;; If the constant is 255, then emit a extu.b instruction instead of an\n ;; and, since that will give better code.\n@@ -2133,8 +2009,7 @@\n \t\t(match_operand:SI 2 \"logical_operand\" \"r,L\")))]\n   \"TARGET_SH1\"\n   \"or\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"iordi3\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -2152,8 +2027,7 @@\n \t\t(match_operand:SI 2 \"logical_operand\" \"L,r\")))]\n   \"TARGET_SH1\"\n   \"xor\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"xordi3\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -2220,8 +2094,7 @@\n \t(lshiftrt:SI (match_dup 1) (const_int 31)))]\n   \"TARGET_SH1\"\n   \"rotl\t%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"rotlsi3_31\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -2230,17 +2103,15 @@\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n   \"rotr\t%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"rotlsi3_16\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n \t\t   (const_int 16)))]\n   \"TARGET_SH1\"\n   \"swap.w\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")\n-  (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_expand \"rotlsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n@@ -2304,8 +2175,7 @@\n \t\t   (const_int 8)))]\n   \"TARGET_SH1\"\n   \"swap.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_expand \"rotlhi3\"\n   [(set (match_operand:HI 0 \"arith_reg_operand\" \"\")\n@@ -2347,8 +2217,7 @@\n      (clobber (match_dup 4))])]\n   \"operands[4] = gen_rtx_SCRATCH (SImode);\"\n   [(set_attr \"length\" \"*,*,*,4\")\n-   (set_attr \"type\" \"dyn_shift,arith,arith,arith\")\n-   (set_attr \"insn_class\" \"ex_group,ex_group,ex_group,ex_group\")])\n+   (set_attr \"type\" \"dyn_shift,arith,arith,arith\")])\n \n (define_insn \"ashlhi3_k\"\n   [(set (match_operand:HI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -2358,8 +2227,7 @@\n   \"@\n \tadd\t%0,%0\n \tshll%O2\t%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"ashlsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -2376,8 +2244,7 @@\n \t       (eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 3))\n \t       (const_string \"6\")]\n \t      (const_string \"8\")))\n-   (set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+   (set_attr \"type\" \"arith\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n@@ -2466,8 +2333,7 @@\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1 && INTVAL (operands[2]) == 1\"\n   \"shar\t%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n ;; We can't do HImode right shifts correctly unless we start out with an\n ;; explicit zero / sign extension; doing that would result in worse overall\n@@ -2526,17 +2392,15 @@\n \t(lt:SI (match_dup 1) (const_int 0)))]\n   \"TARGET_SH1\"\n   \"shll\t%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"ashrsi3_d\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n   \"TARGET_SH3\"\n   \"shad\t%2,%0\"\n-  [(set_attr \"type\" \"dyn_shift\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"dyn_shift\")])\n \n (define_insn \"ashrsi3_n\"\n   [(set (reg:SI R4_REG)\n@@ -2587,8 +2451,7 @@\n \t\t     (neg:SI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n   \"TARGET_SH3\"\n   \"shld\t%2,%0\"\n-  [(set_attr \"type\" \"dyn_shift\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"dyn_shift\")])\n \n ;;  Only the single bit shift clobbers the T bit.\n \n@@ -2599,8 +2462,7 @@\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1 && CONST_OK_FOR_M (INTVAL (operands[2]))\"\n   \"shlr\t%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"lshrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -2609,8 +2471,7 @@\n   \"TARGET_SH1 && CONST_OK_FOR_K (INTVAL (operands[2]))\n    && ! CONST_OK_FOR_M (INTVAL (operands[2]))\"\n   \"shlr%O2\t%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"lshrsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -2689,8 +2550,7 @@\n   \"TARGET_SH1\"\n   \"shll\t%R0\\;rotcl\t%S0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+   (set_attr \"type\" \"arith\")])\n \n (define_insn \"ashldi3_media\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -2730,8 +2590,7 @@\n   \"TARGET_SH1\"\n   \"shlr\t%S0\\;rotcr\t%R0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+   (set_attr \"type\" \"arith\")])\n \n (define_insn \"lshrdi3_media\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -2771,8 +2630,7 @@\n   \"TARGET_SH1\"\n   \"shar\t%S0\\;rotcr\t%R0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+   (set_attr \"type\" \"arith\")])\n \n (define_insn \"ashrdi3_media\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -3007,8 +2865,7 @@\n \t\t\t     (const_int 16))))]\n   \"TARGET_SH1\"\n   \"xtrct\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"xtrct_right\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -3018,8 +2875,7 @@\n \t\t\t   (const_int 16))))]\n   \"TARGET_SH1\"\n   \"xtrct\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n ;; -------------------------------------------------------------------------\n ;; Unary arithmetic\n@@ -3034,8 +2890,7 @@\n \t       (const_int 0)))]\n   \"TARGET_SH1\"\n   \"negc\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"*negdi_media\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n@@ -3073,16 +2928,14 @@\n \t(neg:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"neg\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(not:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"not\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_expand \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n@@ -3157,8 +3010,7 @@\n \t(zero_extend:SI (match_operand:HI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"extu.w\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"*zero_extendhisi2_media\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -3196,8 +3048,7 @@\n \t(zero_extend:SI (match_operand:QI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"extu.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"*zero_extendqisi2_media\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -3213,8 +3064,7 @@\n \t(zero_extend:HI (match_operand:QI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"extu.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"insn_class\" \"ex_group\")])\n+  [(set_attr \"type\" \"arith\")])\n \n ;; -------------------------------------------------------------------------\n ;; Sign extension instructions\n@@ -3288,8 +3138,7 @@\n   \"@\n \texts.w\t%1,%0\n    \tmov.w\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load\")\n-   (set_attr \"insn_class\" \"ex_group,*\")])\n+  [(set_attr \"type\" \"arith,load\")])\n \n (define_insn \"*extendhisi2_media\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -3325,8 +3174,7 @@\n   \"@\n \texts.b\t%1,%0\n \tmov.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load\")\n-   (set_attr \"insn_class\" \"ex_group,*\")])\n+  [(set_attr \"type\" \"arith,load\")])\n \n (define_insn \"*extendqisi2_media\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -3356,8 +3204,7 @@\n   \"@\n \texts.b\t%1,%0\n \tmov.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load\")\n-   (set_attr \"insn_class\" \"ex_group,*\")])\n+  [(set_attr \"type\" \"arith,load\")])\n \n /* It would seem useful to combine the truncXi patterns into the movXi\n    patterns, but unary operators are ignored when matching constraints,\n@@ -3431,6 +3278,7 @@\n   \"TARGET_SH3E && ! TARGET_SH5\"\n   \"sts.l\tfpul,@-r15\"\n   [(set_attr \"type\" \"store\")\n+   (set_attr \"late_fp_use\" \"yes\")\n    (set_attr \"hit_stack\" \"yes\")])\n \n ;; DFmode pushes for sh4 require a lot of what is defined for movdf_i4,\n@@ -3506,8 +3354,7 @@\n \tlds.l\t%1,%0\n \tlds.l\t%1,%0\n \tfake\t%1,%0\"\n-  [(set_attr \"type\" \"pcload_si,move,*,load_si,move,prget,move,store,store,pstore,move,prset,load,pload,pcload_si\")\n-   (set_attr \"insn_class\"  \"*,*,mt_group,*,*,*,*,*,*,*,*,*,*,*,*\")\n+  [(set_attr \"type\" \"pcload_si,move,mt_group,load_si,mac_gp,prget,move,store,store,pstore,move,prset,load,pload,pcload_si\")\n    (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n \n ;; t/r must come after r/r, lest reload will try to reload stuff like\n@@ -3541,7 +3388,8 @@\n \tlds\t%1,%0\n \tsts\t%1,%0\n \t! move optimized away\"\n-  [(set_attr \"type\" \"pcload_si,move,*,load_si,move,prget,move,store,store,pstore,move,prset,load,pload,load,store,pcload_si,gp_fpul,gp_fpul,nil\")\n+  [(set_attr \"type\" \"pcload_si,move,*,load_si,mac_gp,prget,move,store,store,pstore,move,prset,load,pload,load,store,pcload_si,gp_fpul,fpul_gp,nil\")\n+   (set_attr \"late_fp_use\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,yes,*,*,yes,*\")\n    (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,0\")])\n \n (define_insn \"movsi_i_lowpart\"\n@@ -3666,7 +3514,7 @@\n   \"TARGET_HARD_SH4\"\n   \"ocbwb\\\\t@%0\\;extu.w\\\\t%0,%2\\;or\\\\t%1,%2\\;mov.l\\\\t%0,@%2\"\n   [(set_attr \"length\" \"8\")\n-   (set_attr \"insn_class\" \"cwb\")])\n+   (set_attr \"type\" \"cwb\")])\n \n ;; ??? could make arg 0 an offsettable memory operand to allow to save\n ;; an add in the code that calculates the address.\n@@ -4313,7 +4161,8 @@\n       (if_then_else\n        (ne (symbol_ref \"TARGET_SHCOMPACT\") (const_int 0))\n        (const_int 10) (const_int 8))])\n-   (set_attr \"type\" \"fmove,move,pcload,load,store,pcload,load,store,load,load\")\n+   (set_attr \"type\" \"fmove,move,pcfload,fload,store,pcload,load,store,load,fload\")\n+   (set_attr \"late_fp_use\" \"*,*,*,*,yes,*,*,*,*,*\")\n    (set (attr \"fp_mode\") (if_then_else (eq_attr \"fmovd\" \"yes\")\n \t\t\t\t\t   (const_string \"double\")\n \t\t\t\t\t   (const_string \"none\")))])\n@@ -5015,7 +4864,8 @@\n \tsts.l\t%1,%0\n \tlds.l\t%1,%0\n \t! move optimized away\"\n-  [(set_attr \"type\" \"fmove,move,fmove,fmove,pcload,load,store,pcload,load,store,fmove,fmove,load,*,gp_fpul,gp_fpul,store,load,nil\")\n+  [(set_attr \"type\" \"fmove,move,fmove,fmove,pcfload,fload,store,pcload,load,store,fmove,fmove,load,*,fpul_gp,gp_fpul,store,load,nil\")\n+   (set_attr \"late_fp_use\" \"*,*,*,*,*,*,yes,*,*,*,*,*,*,*,yes,*,yes,*,*\")\n    (set_attr \"length\" \"*,*,*,*,4,*,*,*,*,*,2,2,2,4,2,2,2,2,0\")\n    (set (attr \"fp_mode\") (if_then_else (eq_attr \"fmovd\" \"yes\")\n \t\t\t\t\t   (const_string \"single\")\n@@ -7996,8 +7846,8 @@\n ;; GO_IF_LEGITIMATE_ADDRESS guards about bogus addresses before reload,\n ;; SECONDARY_INPUT_RELOAD_CLASS does this during reload, and the insn's\n ;; predicate after reload.\n-;; The gp_fpul type for r/!c might look a bit odd, but it actually schedules\n-;; like a gpr <-> fpul move.\n+;; The mac_gp type for r/!c might look a bit odd, but it actually schedules\n+;; like a mac -> gpr move.\n (define_insn \"fpu_switch\"\n   [(set (match_operand:PSI 0 \"register_operand\" \"=c,c,r,c,c,r,m,r\")\n \t(match_operand:PSI 1 \"general_movsrc_operand\" \"c,>,m,m,r,r,r,!c\"))]\n@@ -8016,8 +7866,7 @@\n \tmov.l\t%1,%0\n \tsts\tfpscr,%0\"\n   [(set_attr \"length\" \"0,2,2,4,2,2,2,2\")\n-   (set_attr \"type\" \"dfp_conv,dfp_conv,load,dfp_conv,dfp_conv,move,store,gp_fpul\")\n-   (set_attr \"insn_class\" \"ldsmem_to_fpscr,*,*,lds_to_fpscr,*,*,*,*\")])\n+   (set_attr \"type\" \"nil,mem_fpscr,load,mem_fpscr,gp_fpscr,move,store,mac_gp\")])\n \n (define_split\n   [(set (reg:PSI FPSCR_REG)\n@@ -8363,7 +8212,7 @@\n    (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n   \"TARGET_SH4\"\n   \"ftrc\t%1,%0\"\n-  [(set_attr \"type\" \"fp\")\n+  [(set_attr \"type\" \"ftrc_s\")\n    (set_attr \"fp_mode\" \"single\")])\n \n ;; ??? This pattern is used nowhere.  fix_truncsfsi2 always expands to\n@@ -8785,6 +8634,7 @@\n   \"TARGET_SH4\"\n   \"ftrc\t%1,%0\"\n   [(set_attr \"type\" \"dfp_conv\")\n+   (set_attr \"dfp_comp\" \"no\")\n    (set_attr \"fp_mode\" \"double\")])\n \n ;; ??? This pattern is used nowhere.  fix_truncdfsi2 always expands to\n@@ -9877,6 +9727,7 @@\n {\n   emit_insn ((TARGET_LITTLE_ENDIAN ? gen_mperm_w_little : gen_mperm_w_big)\n \t     (operands[0], operands[1], operands[2]));\n+  DONE;\n }\")\n \n ; This use of vec_select isn't exactly correct according to rtl.texi\n@@ -10591,18 +10442,22 @@\n \n (define_cpu_unit \"f1_1,f1_2\" \"fpu_pipe\")\n \n-;; The floating point units.\n+;; The floating point units (except FS - F2 always precedes it.)\n \n-(define_cpu_unit \"F1,F2,F3,FS\" \"fpu_pipe\")\n+(define_cpu_unit \"F0,F1,F2,F3\" \"fpu_pipe\")\n \n ;; This is basically the MA unit of SH4\n ;; used in LOAD/STORE pipeline.\n \n (define_cpu_unit \"memory\" \"inst_pipeline\")\n \n+;; However, there are LS group insns that don't use it, even ones that\n+;; complete in 0 cycles.  So we use an extra unit for the issue of LS insns.\n+(define_cpu_unit \"load_store\" \"inst_pipeline\")\n+\n ;; The address calculator used for branch instructions.\n-;; This will be reserved with \"issue\" of branch instructions\n-;; and this is to make sure that  no two branch instructions \n+;; This will be reserved after \"issue\" of branch instructions\n+;; and this is to make sure that no two branch instructions \n ;; can be issued in parallel. \n \n (define_cpu_unit \"pcr_addrcalc\" \"inst_pipeline\")\n@@ -10613,115 +10468,228 @@\n (define_reservation  \"issue\"  \"pipe_01|pipe_02\")\n \n ;; This is to express the locking of D stage.\n+;; Note that the issue of a CO group insn also effectively locks the D stage.\n \n (define_reservation  \"d_lock\" \"pipe_01+pipe_02\")\n \n+;; Every FE instruction but fipr / ftrv starts with issue and this.\n+(define_reservation \"F01\" \"F0+F1\")\n+\n ;; This is to simplify description where F1,F2,FS\n ;; are used simultaneously.\n \n-(define_reservation \"fpu\" \"F1+F2+FS\")\n+(define_reservation \"fpu\" \"F1+F2\")\n \n ;; This is to highlight the fact that f1 \n ;; cannot overlap with F1.\n \n (exclusion_set  \"f1_1,f1_2\" \"F1\")\n \n+(define_insn_reservation \"nil\" 0 (eq_attr \"type\" \"nil\") \"nothing\")\n+\n ;; Although reg moves have a latency of zero \n ;; we need to highlight that they use D stage\n ;; for one cycle.\n \n+;; Group:\tMT\n+\n (define_insn_reservation \"reg_mov\" 0\n-               (eq_attr \"type\" \"move,fmove\")\n-              \"issue\")\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"move\"))\n+  \"issue\")\n+\n+;; Group:\tLS\n+\n+(define_insn_reservation \"freg_mov\" 0\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"fmove\"))\n+  \"issue+load_store\")\n+\n+;; We don't model all pipeline stages; we model the issue ('D') stage\n+;; inasmuch as we allow only two instructions to issue simultanously,\n+;; and CO instructions prevent any simultanous issue of another instruction.\n+;; (This uses pipe_01 and pipe_02).\n+;; Double issue of EX insns is prevented by using the int unit in the EX stage.\n+;; Double issue of EX / BR insns is prevented by using the int unit /\n+;; pcr_addrcalc unit in the EX stage.\n+;; Double issue of BR / LS instructions is prevented by using the\n+;; pcr_addrcalc / load_store unit in the issue cycle.\n+;; Double issue of FE instructions is prevented by using F0 in the first\n+;; pipeline stage after the first D stage.\n+;; There is no need to describe the [ES]X / [MN]A / S stages after a D stage\n+;; (except in the cases outlined above), nor to describe the FS stage after\n+;; the F2 stage.\n \n ;; Other MT  group intructions(1 step operations)\n ;; Group:\tMT\n ;; Latency: \t1\n ;; Issue Rate: \t1\n \n (define_insn_reservation \"mt\" 1\n-                      (eq_attr \"insn_class\" \"mt_group\")\n-                      \"issue,nothing\")\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"mt_group\"))\n+  \"issue\")\n \n ;; Fixed Point Arithmetic Instructions(1 step operations)\n ;; Group:\tEX\n ;; Latency: \t1\n ;; Issue Rate: \t1\n \n-(define_insn_reservation \"simple_arith\" 1 \n-            (eq_attr \"insn_class\" \"ex_group\")\n-            \"issue,int\")\n+(define_insn_reservation \"sh4_simple_arith\" 1 \n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"insn_class\" \"ex_group\"))\n+  \"issue,int\")\n+\n+;; Load and store instructions have no alignment peculiarities for the SH4,\n+;; but they use the load-store unit, which they share with the fmove type\n+;; insns (fldi[01]; fmov frn,frm; flds; fsts; fabs; fneg) .\n+;; Loads have a latency of two.\n+;; However, call insns can only paired with a preceding insn, and have\n+;; a delay slot, so that we want two more insns to be scheduled between the\n+;; load of the function address and the call.  This is equivalent to a\n+;; latency of three.\n+;; ADJUST_COST can only properly handle reductions of the cost, so we\n+;; use a latency of three here, which gets multiplied by 10 to yield 30.\n+;; We only do this for SImode loads of general registers, to make the work\n+;; for ADJUST_COST easier.\n \n ;; Load Store instructions. (MOV.[BWL]@(d,GBR)\n ;; Group:\tLS\n ;; Latency: \t2\n ;; Issue Rate: \t1\n \n-(define_insn_reservation \"load_store\" 2\n-       (eq_attr \"type\" \"load,load_si,pcload,pcload_si,store\")\n-       \"issue,memory*2\")\n+(define_insn_reservation \"sh4_load\" 2\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"load,pcload\"))\n+  \"issue+load_store,nothing,memory\")\n+\n+;; calls / sfuncs need an extra instruction for their delay slot.\n+;; Moreover, estimating the latency for SImode loads as 3 will also allow\n+;; adjust_cost to meaningfully bump it back up to 3 if they load the shift\n+;; count of a dynamic shift.\n+(define_insn_reservation \"sh4_load_si\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"load_si,pcload_si\"))\n+  \"issue+load_store,nothing,memory\")\n+\n+;; (define_bypass 2 \"sh4_load_si\" \"!sh4_call\")\n+\n+;; The load latency is upped to three higher if the dependent insn does\n+;; double precision computation.  We want the 'default' latency to reflect\n+;; that increased latency because otherwise the insn priorities won't\n+;; allow proper scheduling.\n+(define_insn_reservation \"sh4_fload\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"fload,pcfload\"))\n+  \"issue+load_store,nothing,memory\")\n+\n+;; (define_bypass 2 \"sh4_fload\" \"!\")\n+\n+(define_insn_reservation \"sh4_store\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"store\"))\n+  \"issue+load_store,nothing,memory\")\n+\n+;; Load Store instructions.\n+;; Group:\tLS\n+;; Latency: \t1\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"sh4_gp_fpul\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"gp_fpul\"))\n+  \"issue+load_store\")\n+\n+;; Load Store instructions.\n+;; Group:\tLS\n+;; Latency: \t3\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"sh4_fpul_gp\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"fpul_gp\"))\n+  \"issue+load_store\")\n \n ;; Branch (BF,BF/S,BT,BT/S,BRA)\n ;; Group:\tBR\n-;; Latency: \t2 (or 1) Actually Observed to be 5/7\n+;; Latency when taken: \t2 (or 1)\n ;; Issue Rate: \t1\n ;; The latency is 1 when displacement is 0.\n-;; This reservation can be further broken into 2\n-;;    1. branch_zero : One with latency 1 and in the TEST \n-;;       part it also checks for 0 (ZERO) displacement \n-;;    2. branch: Latency 2.\n-\n-(define_insn_reservation \"branch_zero\"  5\n-             (and (eq_attr \"type\" \"cbranch\")\n-\t\t  (eq_attr \"length\" \"2\"))\n-             \"(issue+pcr_addrcalc),pcr_addrcalc,nothing\")\n+;; We can't really do much with the latency, even if we could express it,\n+;; but the pairing restrictions are useful to take into account.\n+;; ??? If the branch is likely, we might want to fill the delay slot;\n+;; if the branch is likely, but not very likely, should we pretend to use\n+;; a resource that CO instructions use, to get a pairable delay slot insn?\n \n-(define_insn_reservation \"branch\"  7\n-             (eq_attr \"type\" \"cbranch\")\n-             \"(issue+pcr_addrcalc),pcr_addrcalc,nothing\")\n+(define_insn_reservation \"sh4_branch\"  1\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"cbranch,jump\"))\n+  \"issue+pcr_addrcalc\")\n \n ;; Branch Far (JMP,RTS,BRAF)\n ;; Group:\tCO\n ;; Latency: \t3\n ;; Issue Rate: \t2\n-;;    Since issue stage (D stage) is blocked for 2nd cycle, \n-;;    cpu_unit  int  is reserved since it might be required for far\n-;;    address calculation.\n+;; ??? Scheduling happens before branch shortening, and hence jmp and braf\n+;; can't be distinguished from bra for the \"jump\" pattern.\n \n-(define_insn_reservation \"branch_far\" 12\n-         (and (eq_attr \"type\" \"jump,return\")\n-\t      (eq_attr \"length\" \"6\"))\n-         \"d_lock*2,int+pcr_addrcalc,pcr_addrcalc\")\n+(define_insn_reservation \"sh4_return\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"return,jump_ind\"))\n+         \"d_lock*2\")\n \n ;; RTE\n ;; Group:\tCO\n-;; atency: \t5\n+;; Latency: \t5\n ;; Issue Rate: \t5\n ;; this instruction can be executed in any of the pipelines \n ;; and blocks the pipeline for next 4 stages.\n \n-(define_insn_reservation \"return_from_exp\" 5\n-          (eq_attr \"type\" \"rte\")\n-         \"(issue+pcr_addrcalc),d_lock*4,int+pcr_addrcalc,nothing\")\n+(define_insn_reservation \"sh4_return_from_exp\" 5\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"rte\"))\n+  \"d_lock*5\")\n \n ;; OCBP, OCBWB\n ;; Group:\tCO\n-;; Latency: \t5\n+;; Latency: \t1-5\n ;; Issue Rate: \t1\n \n-(define_insn_reservation \"ocbwb\"  5\n-          (eq_attr \"insn_class\" \"cwb\") \n- \t   \"issue,(int+memory),memory*5\")\n+;; cwb is used for the sequence ocbwb @%0; extu.w %0,%2; or %1,%2; mov.l %0,@%2\n+;; ocbwb on its own would be \"d_lock,nothing,memory*5\"\n+(define_insn_reservation \"ocbwb\"  6\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"cwb\"))\n+  \"d_lock*2,(d_lock+memory)*3,issue+load_store+memory,memory*2\")\n \t\t\n ;; LDS to PR,JSR\n ;; Group:\tCO\n ;; Latency: \t3\n ;; Issue Rate: \t2\n ;; The SX stage is blocked for last 2 cycles.\n+;; OTOH, the only time that has an effect for insns generated by the compiler\n+;; is when lds to PR is followed by sts from PR - and that is highly unlikely -\n+;; or when we are doing a function call - and we don't do inter-function\n+;; scheduling.  For the function call case, it's really best that we end with\n+;; something that models an rts.\n \n-(define_insn_reservation \"lds_to_pr\" 3 \n-          (eq_attr \"type\" \"prset,call,sfunc\") \n-          \"(issue+pcr_addrcalc),(issue+int+pcr_addrcalc),(int+pcr_addrcalc)*2\")\n+(define_insn_reservation \"sh4_lds_to_pr\" 3 \n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"prset\") )\n+  \"d_lock*2\")\n+\n+;; calls introduce a longisch delay that is likely to flush the pipelines\n+;; of the caller's instructions.  Ordinary functions tend to end with a\n+;; load to restore a register (in the delay slot of rts), while sfuncs\n+;; tend to end with an EX or MT insn.  But that is not actually relevant,\n+;; since there are no instructions that contend for memory access early.\n+;; We could, of course, provide exact scheduling information for specific\n+;; sfuncs, if that should prove useful.\n+\n+(define_insn_reservation \"sh4_call\" 16 \n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"call,sfunc\"))\n+  \"d_lock*16\")\n \n ;; LDS.L to PR \n ;; Group:\tCO\n@@ -10730,8 +10698,9 @@\n ;; The SX unit is blocked for last 2 cycles.\n  \n (define_insn_reservation \"ldsmem_to_pr\"  3\n-      (eq_attr \"type\" \"pload\") \n-     \"(issue+pcr_addrcalc),(issue+int+pcr_addrcalc),(int+memory+pcr_addrcalc),(int+pcr_addrcalc)\")\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"pload\"))\n+  \"d_lock*2\")\n \n ;; STS from PR\n ;; Group:\tCO\n@@ -10740,27 +10709,30 @@\n ;; The SX unit in second and third cycles.\n \n (define_insn_reservation \"sts_from_pr\" 2\n-        (eq_attr \"type\" \"prget\")\n-       \"(issue+pcr_addrcalc),(pipe_01+int+pcr_addrcalc),(int+pcr_addrcalc),nothing\")\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"prget\"))\n+  \"d_lock*2\")\n \n ;; STS.L from PR\n ;; Group:\tCO\n ;; Latency: \t2\n ;; Issue Rate: \t2\n \n-(define_insn_reservation \"prload_mem\" 2 \n-          (eq_attr \"type\" \"pstore\")\n-           \"(issue+pcr_addrcalc),(pipe_01+int+pcr_addrcalc),(int+memory+pcr_addrcalc),memory\")\n+(define_insn_reservation \"sh4_prstore_mem\" 2 \n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"pstore\"))\n+  \"d_lock*2,nothing,memory\")\n \n ;; LDS to FPSCR\n ;; Group:\tCO\n ;; Latency: \t4\n ;; Issue Rate: \t1\n ;; F1 is blocked for last three cycles. \n \n-(define_insn_reservation \"fpscr_store\" 4\n-        (eq_attr \"insn_class\" \"lds_to_fpscr\")\n-       \"issue,int,F1*3\")\n+(define_insn_reservation \"fpscr_load\" 4\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"gp_fpscr\"))\n+  \"d_lock,nothing,F1*3\")\n \n ;; LDS.L to FPSCR\n ;; Group:\tCO\n@@ -10769,9 +10741,10 @@\n ;; Issue Rate: \t1\n ;; F1 is blocked for last three cycles.\n \n-(define_insn_reservation \"fpscr_store_mem\" 4\n-        (eq_attr \"insn_class\"  \"ldsmem_to_fpscr\") \n-        \"issue,(int+memory),(F1+memory),F1*2\")\n+(define_insn_reservation \"fpscr_load_mem\" 4\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\"  \"mem_fpscr\"))\n+  \"d_lock,nothing,(F1+memory),F1*2\")\n \n \f\n ;; Fixed point multiplication (DMULS.L DMULU.L MUL.L MULS.W,MULU.W)\n@@ -10780,63 +10753,101 @@\n ;; Issue Rate: \t1\n \n (define_insn_reservation \"multi\" 4\n-\t(eq_attr \"type\" \"smpy,dmpy\")\n- \t\"issue,(issue+int+f1_1),(int+f1_1),(f1_1|f1_2)*2,F2,FS\")\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"smpy,dmpy\"))\n+  \"d_lock,(d_lock+f1_1),(f1_1|f1_2)*3,F2\")\n+\n+;; Fixed STS from MACL / MACH\n+;; Group:\tCO\n+;; Latency: \t3\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"sh4_mac_gp\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"mac_gp\"))\n+  \"d_lock\")\n \n \n ;; Single precision floating point computation FCMP/EQ,\n-;; FCP/GT, FADD, FLOAT, FMAC, FMUL, FSUB, FTRC, FRVHG, FSCHG\n+;; FCMP/GT, FADD, FLOAT, FMAC, FMUL, FSUB, FTRC, FRVHG, FSCHG\n ;; Group:\tFE\n-;; Latency: \t4\n+;; Latency: \t3/4\n ;; Issue Rate: \t1\n \n-(define_insn_reservation \"fp_arith\"  4\n-              (eq_attr \"type\" \"fp\")\n- \t      \"issue,F1,F2,FS\")\n+(define_insn_reservation \"fp_arith\"  3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"fp\"))\n+  \"issue,F01,F2\")\n+\n+(define_insn_reservation \"fp_arith_ftrc\"  3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"ftrc_s\"))\n+  \"issue,F01,F2\")\n+\n+(define_bypass 1 \"fp_arith_ftrc\" \"sh4_fpul_gp\")\n \n ;; Single Precision FDIV/SQRT\n ;; Group:\tFE\n-;; Latency: \t12/13\n+;; Latency: \t12/13 (FDIV); 11/12 (FSQRT)\n ;; Issue Rate: \t1\n+;; We describe fdiv here; fsqrt is actually one cycle faster.\n \n-(define_insn_reservation \"fp_div\" 13\n-               (eq_attr \"type\" \"fdiv\")\n-               \"issue,F1+F3,F1+F2+F3,F3*7,F1+F3,F2,FS\")\n+(define_insn_reservation \"fp_div\" 12\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"fdiv\"))\n+  \"issue,F01+F3,F2+F3,F3*7,F1+F3,F2\")\n \n ;; Double Precision floating point computation\n ;; (FCNVDS, FCNVSD, FLOAT, FTRC)\n ;; Group:\tFE\n ;; Latency: \t(3,4)/5\n ;; Issue Rate: \t1\n \n-(define_insn_reservation \"dp_float\" 5\n-         (eq_attr \"type\" \"dfp_conv\")\n-\t \"issue,F1,F1+F2,F2+FS,FS\")\n+(define_insn_reservation \"dp_float\" 4\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"dfp_conv\"))\n+  \"issue,F01,F1+F2,F2\")\n \n-;; Double-precision floating-point (FADD ,FMUL,FSUB) \n+;; Double-precision floating-point (FADD,FMUL,FSUB) \n ;; Group:\tFE\n ;; Latency: \t(7,8)/9\n ;; Issue Rate: \t1\n \n-(define_insn_reservation \"fp_double_arith\" 9\n-        (eq_attr \"type\" \"dfp_arith\")\n-\t\"issue,F1,F1+F2,fpu*4,F2+FS,FS\")\n+(define_insn_reservation \"fp_double_arith\" 8\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"dfp_arith\"))\n+  \"issue,F01,F1+F2,fpu*4,F2\")\n \n ;; Double-precision FCMP (FCMP/EQ,FCMP/GT) \n-;; Group:\tFE\n+;; Group:\tCO\n ;; Latency: \t3/5\n ;; Issue Rate: \t2\n \n-(define_insn_reservation \"fp_double_cmp\" 5 \n-        (eq_attr \"type\" \"dfp_cmp\")\n-\t\"issue,(issue+F1),F1+F2,F2+FS,FS\")\n+(define_insn_reservation \"fp_double_cmp\" 3 \n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"dfp_cmp\"))\n+  \"d_lock,(d_lock+F01),F1+F2,F2\")\n \n ;; Double precision FDIV/SQRT\n ;; Group:\tFE\n ;; Latency: \t(24,25)/26\n ;; Issue Rate: \t1\n \n-(define_insn_reservation \"dp_div\" 26\n-        (eq_attr \"type\" \"dfdiv\")\n- \t\"issue,F1+F3,F1+F2+F3,F2+F3+FS,F3*16,F1+F3,F1+F2+F3,fpu+F3,F2+FS,FS\")\n+(define_insn_reservation \"dp_div\" 25\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"dfdiv\"))\n+  \"issue,F01+F3,F1+F2+F3,F2+F3,F3*16,F1+F3,(fpu+F3)*2,F2\")\n+\n \n+;; Use the branch-not-taken case to model arith3 insns.  For the branch taken\n+;; case, we'd get a d_lock instead of issue at the end.\n+(define_insn_reservation \"arith3\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"arith3\"))\n+  \"issue,d_lock+pcr_addrcalc,issue\")\n+\n+;; arith3b insns schedule the same no matter if the branch is taken or not.\n+(define_insn_reservation \"arith3b\" 2\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"arith3\"))\n+  \"issue,d_lock+pcr_addrcalc\")"}]}