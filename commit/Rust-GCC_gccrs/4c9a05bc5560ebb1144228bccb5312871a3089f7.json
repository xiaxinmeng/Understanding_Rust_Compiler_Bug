{"sha": "4c9a05bc5560ebb1144228bccb5312871a3089f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM5YTA1YmM1NTYwZWJiMTE0NDIyOGJjY2I1MzEyODcxYTMwODlmNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-14T22:19:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-14T22:19:28Z"}, "message": "Cast pointer operands to bzero, bcopy, and bcmp to (char *).\n\nFrom-SVN: r7472", "tree": {"sha": "a7bb6982dd7325e985889dd58de3ba6d06851867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7bb6982dd7325e985889dd58de3ba6d06851867"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c9a05bc5560ebb1144228bccb5312871a3089f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9a05bc5560ebb1144228bccb5312871a3089f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c9a05bc5560ebb1144228bccb5312871a3089f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9a05bc5560ebb1144228bccb5312871a3089f7/comments", "author": null, "committer": null, "parents": [{"sha": "de953b38a3adb0580dd8caf88991fc78226b1f4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de953b38a3adb0580dd8caf88991fc78226b1f4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de953b38a3adb0580dd8caf88991fc78226b1f4e"}], "stats": {"total": 620, "additions": 341, "deletions": 279}, "files": [{"sha": "b5d0c6ce0d7121d836a90dcece1ee655d53bc758", "filename": "gcc/bc-emit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fbc-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fbc-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-emit.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -361,7 +361,7 @@ bc_seg_write (seg, file)\n \t  if (i % 8 != 0)\n \t    putc ('\\n', file);\n \n-\t  bcopy (seg->data + i, &offset, sizeof (int));\n+\t  bcopy (seg->data + i, (char *) &offset, sizeof (int));\n \t  i += sizeof (int) - 1;\n \n \t  BC_WRITE_RELOC_ENTRY (segreloc, file, offset);\n@@ -603,7 +603,7 @@ bc_end_function ()\n     if (ref->label->defined)\n       {\n \taddr = ref->label->offset;\n-\tbcopy (&addr, bytecode->data + ref->offset, sizeof addr);\n+\tbcopy ((char *) &addr, bytecode->data + ref->offset, sizeof addr);\n       }\n \n   /* Free the chains of labelrefs and labeldefs. */"}, {"sha": "d3b21a9d0c09e1e758ffce764e0b50b015a001b8", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -949,7 +949,7 @@ expand_call (exp, target, ignore)\n \n   /* Make a vector to hold all the information about each arg.  */\n   args = (struct arg_data *) alloca (num_actuals * sizeof (struct arg_data));\n-  bzero (args, num_actuals * sizeof (struct arg_data));\n+  bzero ((char *) args, num_actuals * sizeof (struct arg_data));\n \n   args_size.constant = 0;\n   args_size.var = 0;"}, {"sha": "39b9a175df758188566f7bf32ee4268de5375b1b", "filename": "gcc/cccp.c", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -1157,11 +1157,11 @@ main (argc, argv)\n   cplusplus = 0;\n   cplusplus_comments = 0;\n \n-  bzero (pend_files, argc * sizeof (char *));\n-  bzero (pend_defs, argc * sizeof (char *));\n-  bzero (pend_undefs, argc * sizeof (char *));\n-  bzero (pend_assertions, argc * sizeof (char *));\n-  bzero (pend_includes, argc * sizeof (char *));\n+  bzero ((char *) pend_files, argc * sizeof (char *));\n+  bzero ((char *) pend_defs, argc * sizeof (char *));\n+  bzero ((char *) pend_undefs, argc * sizeof (char *));\n+  bzero ((char *) pend_assertions, argc * sizeof (char *));\n+  bzero ((char *) pend_includes, argc * sizeof (char *));\n \n   /* Process switches and find input file name.  */\n \n@@ -1790,7 +1790,8 @@ main (argc, argv)\n \t  endp++;\n       }\n       /* Put the usual defaults back in at the end.  */\n-      bcopy (include_defaults_array, &include_defaults[num_dirs],\n+      bcopy ((char *) include_defaults_array,\n+\t     (char *) &include_defaults[num_dirs],\n \t     sizeof (include_defaults_array));\n     }\n   }\n@@ -2229,17 +2230,19 @@ trigraph_pcp (buf)\n       continue;\n     }\n     len = sptr - fptr - 2;\n+\n+    /* BSD doc says bcopy () works right for overlapping strings.  In ANSI\n+       C, this will be memmove (). */\n     if (bptr != fptr && len > 0)\n-      bcopy (fptr, bptr, len);\t/* BSD doc says bcopy () works right\n-\t\t\t\t   for overlapping strings.  In ANSI\n-\t\t\t\t   C, this will be memmove (). */\n+      bcopy ((char *) fptr, (char *) bptr, len);\n+\n     bptr += len;\n     *bptr++ = c;\n     fptr = ++sptr;\n   }\n   len = buf->length - (fptr - buf->buf);\n   if (bptr != fptr && len > 0)\n-    bcopy (fptr, bptr, len);\n+    bcopy ((char *) fptr, (char *) bptr, len);\n   buf->length -= fptr - bptr;\n   buf->buf[buf->length] = '\\0';\n   if (warn_trigraphs && fptr != bptr)\n@@ -2538,7 +2541,7 @@ do { ip = &instack[indepth];\t\t\\\n \tif (*ibp == '(') {\n \t  ip->bufp = ibp;\n \t  skip_paren_group (ip);\n-\t  bcopy (ibp, obp, ip->bufp - ibp);\n+\t  bcopy ((char *) ibp, (char *) obp, ip->bufp - ibp);\n \t  obp += ip->bufp - ibp;\n \t  ibp = ip->bufp;\n \t}\n@@ -2753,7 +2756,7 @@ do { ip = &instack[indepth];\t\t\\\n \t  while (ibp < limit) {\n \t    if (ibp[-1] != '\\\\' && *ibp == '\\n') {\n \t      if (put_out_comments) {\n-\t\tbcopy (before_bp, obp, ibp - before_bp);\n+\t\tbcopy ((char *) before_bp, (char *) obp, ibp - before_bp);\n \t\tobp += ibp - before_bp;\n \t      }\n \t      break;\n@@ -2789,14 +2792,14 @@ do { ip = &instack[indepth];\t\t\\\n \tif (lintcmd != NULL) {\n \t  /* I believe it is always safe to emit this newline: */\n \t  obp[-1] = '\\n';\n-\t  bcopy (\"#pragma lint \", obp, 13);\n+\t  bcopy (\"#pragma lint \", (char *) obp, 13);\n \t  obp += 13;\n-\t  bcopy (lintcmd, obp, cmdlen);\n+\t  bcopy (lintcmd, (char *) obp, cmdlen);\n \t  obp += cmdlen;\n \n \t  if (arglen != 0) {\n \t    *(obp++) = ' ';\n-\t    bcopy (argbp, obp, arglen);\n+\t    bcopy (argbp, (char *) obp, arglen);\n \t    obp += arglen;\n \t  }\n \n@@ -2854,7 +2857,7 @@ do { ip = &instack[indepth];\t\t\\\n \telse {\n \t  ibp++;\n \t  if (put_out_comments) {\n-\t    bcopy (before_bp, obp, ibp - before_bp);\n+\t    bcopy ((char *) before_bp, (char *) obp, ibp - before_bp);\n \t    obp += ibp - before_bp;\n \t  }\n \t}\n@@ -3616,7 +3619,7 @@ handle_directive (ip, op)\n \t/* Output arguments.  */\n \tlen = (bp - buf);\n \tcheck_expand (op, len);\n-\tbcopy (buf, op->bufp, len);\n+\tbcopy (buf, (char *) op->bufp, len);\n \top->bufp += len;\n \t/* Take account of any (escaped) newlines just output.  */\n \twhile (--len >= 0)\n@@ -3735,14 +3738,14 @@ handle_directive (ip, op)\n \t/* Output directive name.  */\n         check_expand (op, kt->length + 1);\n         *op->bufp++ = '#';\n-        bcopy (kt->name, op->bufp, kt->length);\n+        bcopy (kt->name, (char *) op->bufp, kt->length);\n         op->bufp += kt->length;\n \n \tif (kt->pass_thru || dump_macros == dump_definitions) {\n \t  /* Output arguments.  */\n \t  len = (cp - buf);\n \t  check_expand (op, len);\n-\t  bcopy (buf, op->bufp, len);\n+\t  bcopy (buf, (char *) op->bufp, len);\n \t  op->bufp += len;\n \t} else if (kt->type == T_DEFINE && dump_macros == dump_names) {\n \t  U_CHAR *xp = buf;\n@@ -3957,7 +3960,7 @@ special_symbol (hp, op)\n   }\n   len = strlen (buf);\n   check_expand (op, len);\n-  bcopy (buf, op->bufp, len);\n+  bcopy (buf, (char *) op->bufp, len);\n   op->bufp += len;\n \n   return;\n@@ -4131,7 +4134,7 @@ do_include (buf, limit, op, keyword)\n     } else {\n       trybuf = expand_to_temp_buffer (buf, limit, 0, 0);\n       buf = (U_CHAR *) alloca (trybuf.bufp - trybuf.buf + 1);\n-      bcopy (trybuf.buf, buf, trybuf.bufp - trybuf.buf);\n+      bcopy ((char *) trybuf.buf, (char *) buf, trybuf.bufp - trybuf.buf);\n       limit = buf + (trybuf.bufp - trybuf.buf);\n       free (trybuf.buf);\n       retried++;\n@@ -4351,7 +4354,8 @@ do_include (buf, limit, op, keyword)\n \t    struct stat s;\n \n \t    fstat (pcf, &s);\n-\t    if (bcmp (&stat_f.st_ino, &s.st_ino, sizeof (s.st_ino))\n+\t    if (bcmp ((char *) &stat_f.st_ino, (char *) &s.st_ino,\n+\t\t      sizeof (s.st_ino))\n \t\t|| stat_f.st_dev != s.st_dev)\n \t      {\n \t\tpcfbuf = check_precompiled (pcf, fname, &pcfbuflimit);\n@@ -4672,7 +4676,7 @@ finclude (f, fname, op, system_header_p, dirptr)\n     }\n \n   fp = &instack[indepth + 1];\n-  bzero (fp, sizeof (FILE_BUF));\n+  bzero ((char *) fp, sizeof (FILE_BUF));\n   fp->nominal_fname = fp->fname = fname;\n   fp->length = 0;\n   fp->lineno = 1;\n@@ -4845,7 +4849,7 @@ lookup_import (filename, searchptr)\n     while (i) {\n       /* Compare the inode and the device.\n \t Supposedly on some systems the inode is not a scalar.  */\n-      if (!bcmp (&i->inode, &sb.st_ino, sizeof (sb.st_ino))\n+      if (!bcmp ((char *) &i->inode, (char *) &sb.st_ino, sizeof (sb.st_ino))\n \t  && i->dev == sb.st_dev) {\n         close (fd);\n         return -2;\t\t/* return found */\n@@ -4872,7 +4876,7 @@ add_import (fd, fname)\n   i = (struct import_file *)xmalloc (sizeof (struct import_file));\n   i->name = (char *)xmalloc (strlen (fname)+1);\n   strcpy (i->name, fname);\n-  bcopy (&sb.st_ino, &i->inode, sizeof (sb.st_ino));\n+  bcopy ((char *) &sb.st_ino, (char *) &i->inode, sizeof (sb.st_ino));\n   i->dev = sb.st_dev;\n   i->next = import_hash_table[hashval];\n   import_hash_table[hashval] = i;\n@@ -5193,11 +5197,11 @@ pass_thru_directive (buf, limit, op, keyword)\n \n   check_expand (op, 1 + keyword_length + (limit - buf));\n   *op->bufp++ = '#';\n-  bcopy (keyword->name, op->bufp, keyword_length);\n+  bcopy (keyword->name, (char *) op->bufp, keyword_length);\n   op->bufp += keyword_length;\n   if (limit != buf && buf[0] != ' ')\n     *op->bufp++ = ' ';\n-  bcopy (buf, op->bufp, limit - buf);\n+  bcopy ((char *) buf, (char *) op->bufp, limit - buf);\n   op->bufp += (limit - buf);\n #if 0\n   *op->bufp++ = '\\n';\n@@ -5425,7 +5429,7 @@ do_define (buf, limit, op, keyword)\n \n \tmsg = (U_CHAR *) alloca (mdef.symlen + 22);\n \t*msg = '`';\n-\tbcopy (mdef.symnam, msg + 1, mdef.symlen);\n+\tbcopy ((char *) mdef.symnam, (char *) (msg + 1), mdef.symlen);\n \tstrcpy ((char *) (msg + mdef.symlen + 1), \"' redefined\");\n \tpedwarn (msg);\n \tif (hp->type == T_MACRO)\n@@ -5471,7 +5475,7 @@ check_macro_name (symname, usage)\n   else if (!is_idstart[*symname]) {\n     U_CHAR *msg;\t\t\t/* what pain... */\n     msg = (U_CHAR *) alloca (sym_length + 1);\n-    bcopy (symname, msg, sym_length);\n+    bcopy ((char *) symname, (char *) msg, sym_length);\n     msg[sym_length] = 0;\n     error (\"invalid %s name `%s'\", usage, msg);\n   } else {\n@@ -6124,7 +6128,7 @@ read_token_list (bpp, limit, error_flag)\n \n     temp = (struct arglist *) xmalloc (sizeof (struct arglist));\n     temp->name = (U_CHAR *) xmalloc (bp - beg + 1);\n-    bcopy (beg, temp->name, bp - beg);\n+    bcopy ((char *) beg, (char *) temp->name, bp - beg);\n     temp->name[bp - beg] = 0;\n     temp->next = token_ptrs;\n     token_ptrs = temp;\n@@ -6457,7 +6461,7 @@ do_error (buf, limit, op, keyword)\n {\n   int length = limit - buf;\n   U_CHAR *copy = (U_CHAR *) xmalloc (length + 1);\n-  bcopy (buf, copy, length);\n+  bcopy ((char *) buf, (char *) copy, length);\n   copy[length] = 0;\n   SKIP_WHITE_SPACE (copy);\n   error (\"#error %s\", copy);\n@@ -6478,7 +6482,7 @@ do_warning (buf, limit, op, keyword)\n {\n   int length = limit - buf;\n   U_CHAR *copy = (U_CHAR *) xmalloc (length + 1);\n-  bcopy (buf, copy, length);\n+  bcopy ((char *) buf, (char *) copy, length);\n   copy[length] = 0;\n   SKIP_WHITE_SPACE (copy);\n   warning (\"#warning %s\", copy);\n@@ -6530,19 +6534,19 @@ do_ident (buf, limit)\n \n   trybuf = expand_to_temp_buffer (buf, limit, 0, 0);\n   buf = (U_CHAR *) alloca (trybuf.bufp - trybuf.buf + 1);\n-  bcopy (trybuf.buf, buf, trybuf.bufp - trybuf.buf);\n+  bcopy ((char *) trybuf.buf, (char *) buf, trybuf.bufp - trybuf.buf);\n   limit = buf + (trybuf.bufp - trybuf.buf);\n   len = (limit - buf);\n   free (trybuf.buf);\n \n   /* Output directive name.  */\n   check_expand (op, 8);\n-  bcopy (\"#ident \", op->bufp, 7);\n+  bcopy (\"#ident \", (char *) op->bufp, 7);\n   op->bufp += 7;\n \n   /* Output the expanded argument line.  */\n   check_expand (op, len);\n-  bcopy (buf, op->bufp, len);\n+  bcopy ((char *) buf, (char *) op->bufp, len);\n   op->bufp += len;\n \n   return 0;\n@@ -6803,7 +6807,7 @@ do_xifdef (buf, limit, op, keyword)\n     skip = (hp == NULL) ^ (keyword->type == T_IFNDEF);\n     if (start_of_file && !skip) {\n       control_macro = (U_CHAR *) xmalloc (end - buf + 1);\n-      bcopy (buf, control_macro, end - buf);\n+      bcopy ((char *) buf, (char *) control_macro, end - buf);\n       control_macro[end - buf] = 0;\n     }\n   }\n@@ -7551,7 +7555,7 @@ output_line_command (ip, op, conditional, file_change)\n   check_expand (op, len + 1);\n   if (op->bufp > op->buf && op->bufp[-1] != '\\n')\n     *op->bufp++ = '\\n';\n-  bcopy (line_cmd_buf, op->bufp, len);\n+  bcopy ((char *) line_cmd_buf, (char *) op->bufp, len);\n   op->bufp += len;\n   op->lineno = ip->lineno;\n }\n@@ -7881,7 +7885,7 @@ macroexpand (hp, op)\n \t    }\n \t  }\n \n-\t  bcopy (p1, xbuf + totlen, l1 - p1);\n+\t  bcopy ((char *) p1, (char *) (xbuf + totlen), l1 - p1);\n \t  totlen += l1 - p1;\n \t  if (!traditional && !ap->raw_after) {\n \t    /* Ordinary expanded use of the argument.\n@@ -7896,7 +7900,8 @@ macroexpand (hp, op)\n \t    xbuf[totlen++] = '\\n';\n \t    xbuf[totlen++] = ' ';\n \t  }\n-\t  bcopy (arg->expanded, xbuf + totlen, arg->expand_length);\n+\t  bcopy ((char *) arg->expanded, (char *) (xbuf + totlen),\n+\t\t arg->expand_length);\n \t  totlen += arg->expand_length;\n \t  if (!traditional) {\n \t    xbuf[totlen++] = '\\n';\n@@ -8016,7 +8021,7 @@ macarg (argptr, rest_args)\n     U_CHAR *buffer = (U_CHAR *) xmalloc (bufsize + extra + 1);\n     int final_start = 0;\n \n-    bcopy (ip->bufp, buffer, bufsize);\n+    bcopy ((char *) ip->bufp, (char *) buffer, bufsize);\n     ip->bufp = bp;\n     ip->lineno += newlines;\n \n@@ -8037,7 +8042,8 @@ macarg (argptr, rest_args)\n       bufsize += bp - ip->bufp;\n       extra += newlines;\n       buffer = (U_CHAR *) xrealloc (buffer, bufsize + extra + 1);\n-      bcopy (ip->bufp, buffer + bufsize - (bp - ip->bufp), bp - ip->bufp);\n+      bcopy ((char *) ip->bufp, (char *) (buffer + bufsize - (bp - ip->bufp)),\n+\t     bp - ip->bufp);\n       ip->bufp = bp;\n       ip->lineno += newlines;\n     }"}, {"sha": "b2301997710fdcb863a2e61f83ecdf46cb96daf9", "filename": "gcc/collect2.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -552,7 +552,9 @@ putenv (str)\n   /* Add a new environment variable */\n   environ = (char **) xmalloc (sizeof (char *) * (num_envs+2));\n   *environ = str;\n-  bcopy (old_environ, environ+1, sizeof (char *) * (num_envs+1));\n+  bcopy ((char *) old_environ, (char *) (environ + 1),\n+\t sizeof (char *) * (num_envs+1));\n+\n   return 0;\n #endif\t/* VMS */\n }\n@@ -1828,7 +1830,7 @@ scan_prog_file (prog_name, which_pass)\n       if (rw)\n \t{\n \t  load_union_t *ptr = (load_union_t *) xmalloc (load_hdr->hdr.ldci_cmd_size);\n-\t  bcopy ((generic *)load_hdr, (generic *)ptr, load_hdr->hdr.ldci_cmd_size);\n+\t  bcopy ((char *)load_hdr, (char *)ptr, load_hdr->hdr.ldci_cmd_size);\n \t  load_hdr = ptr;\n \n \t  /* null out old command map, because we will rewrite at the end.  */\n@@ -2013,7 +2015,7 @@ scan_prog_file (prog_name, which_pass)\n \t  if (debug)\n \t    print_load_command (load_hdr, offset, i);\n \n-\t  bcopy ((generic *)load_hdr, (generic *)(obj + offset), size);\n+\t  bcopy ((char *)load_hdr, (char *)(obj + offset), size);\n \t  offset += size;\n \t}\n     }"}, {"sha": "ff902e4c9722a35826c17dc1ec72f96ff718d6b7", "filename": "gcc/combine.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -465,7 +465,7 @@ combine_instructions (f, nregs)\n     = (unsigned HOST_WIDE_INT *) alloca (nregs * sizeof (HOST_WIDE_INT));\n   reg_sign_bit_copies = (char *) alloca (nregs * sizeof (char));\n \n-  bzero (reg_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n+  bzero ((char *) reg_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n   bzero (reg_sign_bit_copies, nregs * sizeof (char));\n \n   reg_last_death = (rtx *) alloca (nregs * sizeof (rtx));\n@@ -658,14 +658,14 @@ init_reg_last_arrays ()\n {\n   int nregs = combine_max_regno;\n \n-  bzero (reg_last_death, nregs * sizeof (rtx));\n-  bzero (reg_last_set, nregs * sizeof (rtx));\n-  bzero (reg_last_set_value, nregs * sizeof (rtx));\n-  bzero (reg_last_set_table_tick, nregs * sizeof (int));\n-  bzero (reg_last_set_label, nregs * sizeof (int));\n+  bzero ((char *) reg_last_death, nregs * sizeof (rtx));\n+  bzero ((char *) reg_last_set, nregs * sizeof (rtx));\n+  bzero ((char *) reg_last_set_value, nregs * sizeof (rtx));\n+  bzero ((char *) reg_last_set_table_tick, nregs * sizeof (int));\n+  bzero ((char *) reg_last_set_label, nregs * sizeof (int));\n   bzero (reg_last_set_invalid, nregs * sizeof (char));\n-  bzero (reg_last_set_mode, nregs * sizeof (enum machine_mode));\n-  bzero (reg_last_set_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n+  bzero ((char *) reg_last_set_mode, nregs * sizeof (enum machine_mode));\n+  bzero ((char *) reg_last_set_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n   bzero (reg_last_set_sign_bit_copies, nregs * sizeof (char));\n }\n \f\n@@ -1629,7 +1629,7 @@ try_combine (i3, i2, i1)\n \t  rtvec old = XVEC (newpat, 0);\n \t  total_sets = XVECLEN (newpat, 0) + added_sets_1 + added_sets_2;\n \t  newpat = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (total_sets));\n-\t  bcopy (&old->elem[0], &XVECEXP (newpat, 0, 0),\n+\t  bcopy ((char *) &old->elem[0], (char *) &XVECEXP (newpat, 0, 0),\n \t\t sizeof (old->elem[0]) * old->num_elem);\n \t}\n       else"}, {"sha": "514798f3ff75ce10545916a9e77b78d9b3d5fc5a", "filename": "gcc/cse.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -763,10 +763,11 @@ new_basic_block ()\n \n   next_qty = max_reg;\n \n-  bzero (reg_tick, max_reg * sizeof (int));\n+  bzero ((char *) reg_tick, max_reg * sizeof (int));\n \n-  bcopy (all_minus_one, reg_in_table, max_reg * sizeof (int));\n-  bcopy (consec_ints, reg_qty, max_reg * sizeof (int));\n+  bcopy ((char *) all_minus_one, (char *) reg_in_table,\n+\t max_reg * sizeof (int));\n+  bcopy ((char *) consec_ints, (char *) reg_qty, max_reg * sizeof (int));\n   CLEAR_HARD_REG_SET (hard_regs_in_table);\n \n   /* The per-quantity values used to be initialized here, but it is\n@@ -782,7 +783,7 @@ new_basic_block ()\n \t}\n     }\n \n-  bzero (table, sizeof table);\n+  bzero ((char *) table, sizeof table);\n \n   prev_insn = 0;\n \n@@ -4092,7 +4093,7 @@ simplify_plus_minus (code, mode, op0, op1)\n   int first = 1, negate = 0, changed;\n   int i, j;\n \n-  bzero (ops, sizeof ops);\n+  bzero ((char *) ops, sizeof ops);\n   \n   /* Set up the two operands and then expand them until nothing has been\n      changed.  If we run out of room in our array, give up; this should\n@@ -7989,15 +7990,15 @@ cse_main (f, nregs, after_loop, file)\n \n   /* Discard all the free elements of the previous function\n      since they are allocated in the temporarily obstack.  */\n-  bzero (table, sizeof table);\n+  bzero ((char *) table, sizeof table);\n   free_element_chain = 0;\n   n_elements_made = 0;\n \n   /* Find the largest uid.  */\n \n   max_uid = get_max_uid ();\n   uid_cuid = (int *) alloca ((max_uid + 1) * sizeof (int));\n-  bzero (uid_cuid, (max_uid + 1) * sizeof (int));\n+  bzero ((char *) uid_cuid, (max_uid + 1) * sizeof (int));\n \n   /* Compute the mapping from uids to cuids.\n      CUIDs are numbers assigned to insns, like uids,\n@@ -8418,7 +8419,7 @@ delete_dead_from_cse (insns, nreg)\n   int in_libcall = 0;\n \n   /* First count the number of times each register is used.  */\n-  bzero (counts, sizeof (int) * nreg);\n+  bzero ((char *) counts, sizeof (int) * nreg);\n   for (insn = next_real_insn (insns); insn; insn = next_real_insn (insn))\n     count_reg_usage (insn, counts, NULL_RTX, 1);\n "}, {"sha": "5418566033ed4509650315b603f33ccafe0a5d0b", "filename": "gcc/dbxout.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -399,7 +399,7 @@ dbxout_init (asm_file, input_file_name, syms)\n \n   typevec_len = 100;\n   typevec = (enum typestatus *) xmalloc (typevec_len * sizeof typevec[0]);\n-  bzero (typevec, typevec_len * sizeof typevec[0]);\n+  bzero ((char *) typevec, typevec_len * sizeof typevec[0]);\n \n   /* Convert Ltext into the appropriate format for local labels in case\n      the system doesn't insert underscores in front of user generated\n@@ -940,8 +940,10 @@ dbxout_type (type, full, show_arg_types)\n \n       if (next_type_number == typevec_len)\n \t{\n-\t  typevec = (enum typestatus *) xrealloc (typevec, typevec_len * 2 * sizeof typevec[0]);\n-\t  bzero (typevec + typevec_len, typevec_len * sizeof typevec[0]);\n+\t  int len = typevec_len * 2 * sizeof typevec[0];\n+\n+\t  typevec = (enum typestatus *) xrealloc (typevec, len);\n+\t  bzero ((char *) (typevec + typevec_len), len);\n \t  typevec_len *= 2;\n \t}\n     }"}, {"sha": "3afcccbcf5e9372b62945f749f784cfe59b0dae0", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -501,8 +501,9 @@ gen_reg_rtx (mode)\n       regno_pointer_flag = new;\n \n       new1 = (rtx *) oballoc (regno_pointer_flag_length * 2 * sizeof (rtx));\n-      bcopy (regno_reg_rtx, new1, regno_pointer_flag_length * sizeof (rtx));\n-      bzero (&new1[regno_pointer_flag_length],\n+      bcopy ((char *) regno_reg_rtx, (char *) new1,\n+\t     regno_pointer_flag_length * sizeof (rtx));\n+      bzero ((char *) &new1[regno_pointer_flag_length],\n \t     regno_pointer_flag_length * sizeof (rtx));\n       regno_reg_rtx = new1;\n \n@@ -1523,8 +1524,9 @@ copy_rtx_if_shared (orig)\n       register rtx copy;\n \n       copy = rtx_alloc (code);\n-      bcopy (x, copy, (sizeof (*copy) - sizeof (copy->fld)\n-\t\t       + sizeof (copy->fld[0]) * GET_RTX_LENGTH (code)));\n+      bcopy ((char *) x, (char *) copy,\n+\t     (sizeof (*copy) - sizeof (copy->fld)\n+\t      + sizeof (copy->fld[0]) * GET_RTX_LENGTH (code)));\n       x = copy;\n       copied = 1;\n     }\n@@ -3087,8 +3089,9 @@ restore_reg_data_1 (orig)\n \t\t  bcopy (regno_pointer_flag, new, regno_pointer_flag_length);\n \n \t\t  new1 = (rtx *) oballoc (newlen * sizeof (rtx));\n-\t\t  bzero (new1, newlen * sizeof (rtx));\n-\t\t  bcopy (regno_reg_rtx, new1, regno_pointer_flag_length * sizeof (rtx));\n+\t\t  bzero ((char *) new1, newlen * sizeof (rtx));\n+\t\t  bcopy ((char *) regno_reg_rtx, (char *) new1,\n+\t\t\t regno_pointer_flag_length * sizeof (rtx));\n \n \t\t  regno_pointer_flag = new;\n \t\t  regno_reg_rtx = new1;\n@@ -3166,7 +3169,7 @@ init_emit ()\n \n   regno_reg_rtx \n     = (rtx *) oballoc (regno_pointer_flag_length * sizeof (rtx));\n-  bzero (regno_reg_rtx, regno_pointer_flag_length * sizeof (rtx));\n+  bzero ((char *) regno_reg_rtx, regno_pointer_flag_length * sizeof (rtx));\n \n   /* Put copies of all the virtual register rtx into regno_reg_rtx.  */\n   regno_reg_rtx[VIRTUAL_INCOMING_ARGS_REGNUM] = virtual_incoming_args_rtx;\n@@ -3257,10 +3260,10 @@ init_emit_once (line_numbers)\n \t  rtx tem = rtx_alloc (CONST_DOUBLE);\n \t  union real_extract u;\n \n-\t  bzero (&u, sizeof u);  /* Zero any holes in a structure.  */\n+\t  bzero ((char *) &u, sizeof u);  /* Zero any holes in a structure.  */\n \t  u.d = i == 0 ? dconst0 : i == 1 ? dconst1 : dconst2;\n \n-\t  bcopy (&u, &CONST_DOUBLE_LOW (tem), sizeof u);\n+\t  bcopy ((char *) &u, (char *) &CONST_DOUBLE_LOW (tem), sizeof u);\n \t  CONST_DOUBLE_MEM (tem) = cc0_rtx;\n \t  PUT_MODE (tem, mode);\n "}, {"sha": "c0fe5f7e22888863ac8fe1039a45fcf523a14be1", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -2116,8 +2116,10 @@ synth_mult (alg_out, t, cost_limit)\n      best_alg is normally undefined, and this is a critical function.  */\n   alg_out->ops = best_alg->ops + 1;\n   alg_out->cost = cost_limit;\n-  bcopy (best_alg->op, alg_out->op, alg_out->ops * sizeof *alg_out->op);\n-  bcopy (best_alg->log, alg_out->log, alg_out->ops * sizeof *alg_out->log);\n+  bcopy ((char *) best_alg->op, (char *) alg_out->op,\n+\t alg_out->ops * sizeof *alg_out->op);\n+  bcopy ((char *) best_alg->log, (char *) alg_out->log,\n+\t alg_out->ops * sizeof *alg_out->log);\n }\n \f\n /* Perform a multiplication and return an rtx for the result."}, {"sha": "ae976771e46ae0e7f873276921100adb6d297513", "filename": "gcc/flow.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -808,29 +808,36 @@ life_analysis (f, nregs)\n   allocate_for_life_analysis ();\n \n   reg_next_use = (rtx *) alloca (nregs * sizeof (rtx));\n-  bzero (reg_next_use, nregs * sizeof (rtx));\n+  bzero ((char *) reg_next_use, nregs * sizeof (rtx));\n \n   /* Set up several regset-vectors used internally within this function.\n      Their meanings are documented above, with their declarations.  */\n \n-  basic_block_live_at_end = (regset *) alloca (n_basic_blocks * sizeof (regset));\n+  basic_block_live_at_end\n+    = (regset *) alloca (n_basic_blocks * sizeof (regset));\n+\n   /* Don't use alloca since that leads to a crash rather than an error message\n      if there isn't enough space.\n      Don't use oballoc since we may need to allocate other things during\n      this function on the temporary obstack.  */\n   tem = (regset) obstack_alloc (&flow_obstack, n_basic_blocks * regset_bytes);\n-  bzero (tem, n_basic_blocks * regset_bytes);\n-  init_regset_vector (basic_block_live_at_end, tem, n_basic_blocks, regset_bytes);\n+  bzero ((char *) tem, n_basic_blocks * regset_bytes);\n+  init_regset_vector (basic_block_live_at_end, tem,\n+\t\t      n_basic_blocks, regset_bytes);\n \n-  basic_block_new_live_at_end = (regset *) alloca (n_basic_blocks * sizeof (regset));\n+  basic_block_new_live_at_end\n+    = (regset *) alloca (n_basic_blocks * sizeof (regset));\n   tem = (regset) obstack_alloc (&flow_obstack, n_basic_blocks * regset_bytes);\n-  bzero (tem, n_basic_blocks * regset_bytes);\n-  init_regset_vector (basic_block_new_live_at_end, tem, n_basic_blocks, regset_bytes);\n+  bzero ((char *) tem, n_basic_blocks * regset_bytes);\n+  init_regset_vector (basic_block_new_live_at_end, tem,\n+\t\t      n_basic_blocks, regset_bytes);\n \n-  basic_block_significant = (regset *) alloca (n_basic_blocks * sizeof (regset));\n+  basic_block_significant\n+    = (regset *) alloca (n_basic_blocks * sizeof (regset));\n   tem = (regset) obstack_alloc (&flow_obstack, n_basic_blocks * regset_bytes);\n-  bzero (tem, n_basic_blocks * regset_bytes);\n-  init_regset_vector (basic_block_significant, tem, n_basic_blocks, regset_bytes);\n+  bzero ((char *) tem, n_basic_blocks * regset_bytes);\n+  init_regset_vector (basic_block_significant, tem,\n+\t\t      n_basic_blocks, regset_bytes);\n \n   /* Record which insns refer to any volatile memory\n      or for any reason can't be deleted just because they are dead stores.\n@@ -1035,10 +1042,10 @@ life_analysis (f, nregs)\n \t    {\n \t      /* Update the basic_block_live_at_start\n \t\t by propagation backwards through the block.  */\n-\t      bcopy (basic_block_new_live_at_end[i],\n-\t\t     basic_block_live_at_end[i], regset_bytes);\n-\t      bcopy (basic_block_live_at_end[i],\n-\t\t     basic_block_live_at_start[i], regset_bytes);\n+\t      bcopy ((char *) basic_block_new_live_at_end[i],\n+\t\t     (char *) basic_block_live_at_end[i], regset_bytes);\n+\t      bcopy ((char *) basic_block_live_at_end[i],\n+\t\t     (char *) basic_block_live_at_start[i], regset_bytes);\n \t      propagate_block (basic_block_live_at_start[i],\n \t\t\t       basic_block_head[i], basic_block_end[i], 0,\n \t\t\t       first_pass ? basic_block_significant[i]\n@@ -1168,31 +1175,33 @@ allocate_for_life_analysis ()\n   regset_bytes = regset_size * sizeof (*(regset)0);\n \n   reg_n_refs = (int *) oballoc (max_regno * sizeof (int));\n-  bzero (reg_n_refs, max_regno * sizeof (int));\n+  bzero ((char *) reg_n_refs, max_regno * sizeof (int));\n \n   reg_n_sets = (short *) oballoc (max_regno * sizeof (short));\n-  bzero (reg_n_sets, max_regno * sizeof (short));\n+  bzero ((char *) reg_n_sets, max_regno * sizeof (short));\n \n   reg_n_deaths = (short *) oballoc (max_regno * sizeof (short));\n-  bzero (reg_n_deaths, max_regno * sizeof (short));\n+  bzero ((char *) reg_n_deaths, max_regno * sizeof (short));\n \n   reg_live_length = (int *) oballoc (max_regno * sizeof (int));\n-  bzero (reg_live_length, max_regno * sizeof (int));\n+  bzero ((char *) reg_live_length, max_regno * sizeof (int));\n \n   reg_n_calls_crossed = (int *) oballoc (max_regno * sizeof (int));\n-  bzero (reg_n_calls_crossed, max_regno * sizeof (int));\n+  bzero ((char *) reg_n_calls_crossed, max_regno * sizeof (int));\n \n   reg_basic_block = (int *) oballoc (max_regno * sizeof (int));\n   for (i = 0; i < max_regno; i++)\n     reg_basic_block[i] = REG_BLOCK_UNKNOWN;\n \n-  basic_block_live_at_start = (regset *) oballoc (n_basic_blocks * sizeof (regset));\n+  basic_block_live_at_start\n+    = (regset *) oballoc (n_basic_blocks * sizeof (regset));\n   tem = (regset) oballoc (n_basic_blocks * regset_bytes);\n-  bzero (tem, n_basic_blocks * regset_bytes);\n-  init_regset_vector (basic_block_live_at_start, tem, n_basic_blocks, regset_bytes);\n+  bzero ((char *) tem, n_basic_blocks * regset_bytes);\n+  init_regset_vector (basic_block_live_at_start, tem,\n+\t\t      n_basic_blocks, regset_bytes);\n \n   regs_live_at_setjmp = (regset) oballoc (regset_bytes);\n-  bzero (regs_live_at_setjmp, regset_bytes);\n+  bzero ((char *) regs_live_at_setjmp, regset_bytes);\n }\n \n /* Make each element of VECTOR point at a regset,\n@@ -1294,7 +1303,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \n       num_scratch = 0;\n       maxlive = (regset) alloca (regset_bytes);\n-      bcopy (old, maxlive, regset_bytes);\n+      bcopy ((char *) old, (char *) maxlive, regset_bytes);\n       regs_sometimes_live\n \t= (struct sometimes *) alloca (max_regno * sizeof (struct sometimes));\n "}, {"sha": "c52051477b33528d6e86d1ee888831378358ced4", "filename": "gcc/fold-const.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -339,7 +339,7 @@ mul_double (l1, h1, l2, h2, lv, hv)\n   encode (arg1, l1, h1);\n   encode (arg2, l2, h2);\n \n-  bzero (prod, sizeof prod);\n+  bzero ((char *) prod, sizeof prod);\n \n   for (i = 0; i < MAX_SHORTS; i++)\n     for (j = 0; j < MAX_SHORTS; j++)\n@@ -595,10 +595,10 @@ div_and_round_double (code, uns,\n       goto finish_up;\n     }\n \n-  bzero (quo, sizeof quo);\n+  bzero ((char *) quo, sizeof quo);\n \n-  bzero (num, sizeof num);\t/* to zero 9th element */\n-  bzero (den, sizeof den);\n+  bzero ((char *) num, sizeof num);\t/* to zero 9th element */\n+  bzero ((char *) den, sizeof den);\n \n   encode (num, lnum, hnum); \n   encode (den, lden, hden);\n@@ -1837,7 +1837,8 @@ operand_equal_p (arg0, arg1, only_const)\n   /* Detect when real constants are equal.  */\n   if (TREE_CODE (arg0) == TREE_CODE (arg1)\n       && TREE_CODE (arg0) == REAL_CST)\n-    return !bcmp (&TREE_REAL_CST (arg0), &TREE_REAL_CST (arg1),\n+    return !bcmp ((char *) &TREE_REAL_CST (arg0),\n+\t\t  (char *) &TREE_REAL_CST (arg1),\n \t\t  sizeof (REAL_VALUE_TYPE));\n \n   if (only_const)"}, {"sha": "4b9e33cd33bb2156c204af625f06521b1a77f844", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -3085,7 +3085,7 @@ assign_parms (fndecl, second_time)\n     }\n \t\t\t       \n   parm_reg_stack_loc = (rtx *) oballoc (nparmregs * sizeof (rtx));\n-  bzero (parm_reg_stack_loc, nparmregs * sizeof (rtx));\n+  bzero ((char *) parm_reg_stack_loc, nparmregs * sizeof (rtx));\n \n #ifdef INIT_CUMULATIVE_INCOMING_ARGS\n   INIT_CUMULATIVE_INCOMING_ARGS (args_so_far, fntype, NULL_RTX);\n@@ -3569,8 +3569,9 @@ assign_parms (fndecl, second_time)\n \n \t      nparmregs = regno + 5;\n \t      new = (rtx *) oballoc (nparmregs * sizeof (rtx));\n-\t      bcopy (parm_reg_stack_loc, new, old_nparmregs * sizeof (rtx));\n-\t      bzero (new + old_nparmregs,\n+\t      bcopy ((char *) parm_reg_stack_loc, (char *) new,\n+\t\t     old_nparmregs * sizeof (rtx));\n+\t      bzero ((char *) (new + old_nparmregs),\n \t\t     (nparmregs - old_nparmregs) * sizeof (rtx));\n \t      parm_reg_stack_loc = new;\n \t    }"}, {"sha": "56b99edd9cf712ba5f0e1b355878fa5fb4778b5a", "filename": "gcc/gcc.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -1031,11 +1031,12 @@ read_specs (filename)\n \t    = ((struct compiler *)\n \t       xrealloc (compilers, (n_compilers + 2) * sizeof (struct compiler)));\n \t  compilers[n_compilers].suffix = suffix;\n-\t  bzero (compilers[n_compilers].spec,\n+\t  bzero ((char *) compilers[n_compilers].spec,\n \t\t sizeof compilers[n_compilers].spec);\n \t  compilers[n_compilers].spec[0] = spec;\n \t  n_compilers++;\n-\t  bzero (&compilers[n_compilers], sizeof compilers[n_compilers]);\n+\t  bzero ((char *) &compilers[n_compilers],\n+\t\t sizeof compilers[n_compilers]);\n \t}\n \n       if (*suffix == 0)\n@@ -1526,7 +1527,8 @@ putenv (str)\n   /* Add a new environment variable */\n   environ = (char **) xmalloc (sizeof (char *) * (num_envs+2));\n   *environ = str;\n-  bcopy (old_environ, environ+1, sizeof (char *) * (num_envs+1));\n+  bcopy ((char *) old_environ, (char *) (environ + 1),\n+\t sizeof (char *) * (num_envs+1));\n \n #endif\t/* VMS */\n }\n@@ -3951,7 +3953,8 @@ main (argc, argv)\n      This means one element containing 0s, as a terminator.  */\n \n   compilers = (struct compiler *) xmalloc (sizeof default_compilers);\n-  bcopy (default_compilers, compilers, sizeof default_compilers);\n+  bcopy ((char *) default_compilers, (char *) compilers,\n+\t sizeof default_compilers);\n   n_compilers = n_default_compilers;\n \n   /* Read specs from a file if there is one.  */\n@@ -4054,7 +4057,7 @@ main (argc, argv)\n      that correspond to the input files.  */\n \n   outfiles = (char **) xmalloc (n_infiles * sizeof (char *));\n-  bzero (outfiles, n_infiles * sizeof (char *));\n+  bzero ((char *) outfiles, n_infiles * sizeof (char *));\n \n   /* Record which files were specified explicitly as link input.  */\n \n@@ -4262,8 +4265,8 @@ lookup_compiler (name, length, language)\n \t      language = cp->spec[0] + 1;\n \t      new = (struct compiler *) xmalloc (sizeof (struct compiler));\n \t      new->suffix = cp->suffix;\n-\t      bcopy (lookup_compiler (NULL_PTR, 0, language)->spec,\n-\t\t     new->spec, sizeof new->spec);\n+\t      bcopy ((char *) lookup_compiler (NULL_PTR, 0, language)->spec,\n+\t\t     (char *) new->spec, sizeof new->spec);\n \t      return new;\n \t    }\n \t  /* A non-alias entry: return it.  */"}, {"sha": "cd5ae43b11eec6065fdd4d415593c5dee463528f", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -1883,7 +1883,7 @@ expand_units ()\n \t    * sizeof (struct function_unit_op *));\n \n   for (unit = units, i = 0; unit; i += unit->num_opclasses, unit = unit->next)\n-    bcopy (unit_ops[unit->num], &op_array[i],\n+    bcopy ((char *) unit_ops[unit->num], (char *) &op_array[i],\n \t   unit->num_opclasses * sizeof (struct function_unit_op *));\n \n   /* Compute the ready cost function for each unit by computing the\n@@ -2425,7 +2425,7 @@ simplify_cond (exp, insn_code, insn_index)\n   /* This lets us free all storage allocated below, if appropriate.  */\n   first_spacer = (char *) obstack_finish (rtl_obstack);\n \n-  bcopy (&XVECEXP (exp, 0, 0), tests, len * sizeof (rtx));\n+  bcopy ((char *) &XVECEXP (exp, 0, 0), (char *) tests, len * sizeof (rtx));\n \n   /* See if default value needs simplification.  */\n   if (GET_CODE (defval) == COND)\n@@ -2517,7 +2517,8 @@ simplify_cond (exp, insn_code, insn_index)\n       rtx newexp = rtx_alloc (COND);\n \n       XVEC (newexp, 0) = rtvec_alloc (len);\n-      bcopy (tests, &XVECEXP (newexp, 0, 0), len * sizeof (rtx));\n+      bcopy ((char *) tests, (char *) &XVECEXP (newexp, 0, 0),\n+\t     len * sizeof (rtx));\n       XEXP (newexp, 1) = new_defval;\n       return newexp;\n     }\n@@ -3301,8 +3302,9 @@ optimize_attrs ()\n   insn_code_values\n     = (struct attr_value_list **) alloca ((insn_code_number + 2)\n \t\t\t\t\t  * sizeof (struct attr_value_list *));\n-  bzero (insn_code_values,\n+  bzero ((char *) insn_code_values,\n \t (insn_code_number + 2) * sizeof (struct attr_value_list *));\n+\n   /* Offset the table address so we can index by -2 or -1.  */\n   insn_code_values += 2;\n \n@@ -5436,7 +5438,7 @@ copy_rtx_unchanging (orig)\n   PUT_MODE (copy, GET_MODE (orig));\n   RTX_UNCHANGING_P (copy) = 1;\n   \n-  bcopy (&XEXP (orig, 0), &XEXP (copy, 0),\n+  bcopy ((char *) &XEXP (orig, 0), (char *) &XEXP (copy, 0),\n \t GET_RTX_LENGTH (GET_CODE (copy)) * sizeof (rtx));\n   return copy;\n #endif"}, {"sha": "c3dc7493ee52c2f9fae51318701b8877c58c0e6c", "filename": "gcc/global.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -364,7 +364,7 @@ global_alloc (file)\n   /* Initialize the shared-hard-reg mapping\n      from the list of pairs that may share.  */\n   reg_may_share = (int *) alloca (max_regno * sizeof (int));\n-  bzero (reg_may_share, max_regno * sizeof (int));\n+  bzero ((char *) reg_may_share, max_regno * sizeof (int));\n   for (x = regs_may_share; x; x = XEXP (XEXP (x, 1), 1))\n     {\n       int r1 = REGNO (XEXP (x, 0));\n@@ -400,10 +400,10 @@ global_alloc (file)\n   allocno_calls_crossed = (int *) alloca (max_allocno * sizeof (int));\n   allocno_n_refs = (int *) alloca (max_allocno * sizeof (int));\n   allocno_live_length = (int *) alloca (max_allocno * sizeof (int));\n-  bzero (allocno_size, max_allocno * sizeof (int));\n-  bzero (allocno_calls_crossed, max_allocno * sizeof (int));\n-  bzero (allocno_n_refs, max_allocno * sizeof (int));\n-  bzero (allocno_live_length, max_allocno * sizeof (int));\n+  bzero ((char *) allocno_size, max_allocno * sizeof (int));\n+  bzero ((char *) allocno_calls_crossed, max_allocno * sizeof (int));\n+  bzero ((char *) allocno_n_refs, max_allocno * sizeof (int));\n+  bzero ((char *) allocno_live_length, max_allocno * sizeof (int));\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (reg_allocno[i] >= 0)\n@@ -420,8 +420,8 @@ global_alloc (file)\n   /* Calculate amount of usage of each hard reg by pseudos\n      allocated by local-alloc.  This is to see if we want to\n      override it.  */\n-  bzero (local_reg_live_length, sizeof local_reg_live_length);\n-  bzero (local_reg_n_refs, sizeof local_reg_n_refs);\n+  bzero ((char *) local_reg_live_length, sizeof local_reg_live_length);\n+  bzero ((char *) local_reg_n_refs, sizeof local_reg_n_refs);\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (reg_allocno[i] < 0 && reg_renumber[i] >= 0)\n       {\n@@ -446,30 +446,32 @@ global_alloc (file)\n \n   hard_reg_conflicts\n     = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n-  bzero (hard_reg_conflicts, max_allocno * sizeof (HARD_REG_SET));\n+  bzero ((char *) hard_reg_conflicts, max_allocno * sizeof (HARD_REG_SET));\n \n   hard_reg_preferences\n     = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n-  bzero (hard_reg_preferences, max_allocno * sizeof (HARD_REG_SET));\n+  bzero ((char *) hard_reg_preferences, max_allocno * sizeof (HARD_REG_SET));\n   \n   hard_reg_copy_preferences\n     = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n-  bzero (hard_reg_copy_preferences, max_allocno * sizeof (HARD_REG_SET));\n+  bzero ((char *) hard_reg_copy_preferences,\n+\t max_allocno * sizeof (HARD_REG_SET));\n   \n   hard_reg_full_preferences\n     = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n-  bzero (hard_reg_full_preferences, max_allocno * sizeof (HARD_REG_SET));\n+  bzero ((char *) hard_reg_full_preferences,\n+\t max_allocno * sizeof (HARD_REG_SET));\n   \n   regs_someone_prefers\n     = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n-  bzero (regs_someone_prefers, max_allocno * sizeof (HARD_REG_SET));\n+  bzero ((char *) regs_someone_prefers, max_allocno * sizeof (HARD_REG_SET));\n \n   allocno_row_words = (max_allocno + INT_BITS - 1) / INT_BITS;\n \n   conflicts = (INT_TYPE *) alloca (max_allocno * allocno_row_words\n \t\t\t\t   * sizeof (INT_TYPE));\n-  bzero (conflicts, max_allocno * allocno_row_words\n-\t * sizeof (INT_TYPE));\n+  bzero ((char *) conflicts,\n+\t max_allocno * allocno_row_words * sizeof (INT_TYPE));\n \n   allocnos_live = (INT_TYPE *) alloca (allocno_row_words * sizeof (INT_TYPE));\n \n@@ -604,7 +606,7 @@ global_conflicts ()\n \n   for (b = 0; b < n_basic_blocks; b++)\n     {\n-      bzero (allocnos_live, allocno_row_words * sizeof (INT_TYPE));\n+      bzero ((char *) allocnos_live, allocno_row_words * sizeof (INT_TYPE));\n \n       /* Initialize table of registers currently live\n \t to the state at the beginning of this basic block."}, {"sha": "bf0c285491421265515458fd1a96b608604c67bf", "filename": "gcc/integrate.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -242,7 +242,7 @@ initialize_for_inline (fndecl, min_labelno, max_labelno, max_reg, copy)\n        + current_function_uses_pic_offset_table * FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE);\n \n   /* Clear out PARMDECL_MAP.  It was allocated in the caller's frame.  */\n-  bzero (parmdecl_map, max_parm_reg * sizeof (tree));\n+  bzero ((char *) parmdecl_map, max_parm_reg * sizeof (tree));\n   arg_vector = rtvec_alloc (list_length (DECL_ARGUMENTS (fndecl)));\n \n   for (parms = DECL_ARGUMENTS (fndecl), i = 0;\n@@ -465,8 +465,8 @@ save_for_inline_copying (fndecl)\n     reg_map[i] = (rtx)obstack_copy (function_maybepermanent_obstack,\n \t\t\t\t    regno_reg_rtx[i], len);\n \n-  bcopy (reg_map + LAST_VIRTUAL_REGISTER + 1,\n-\t regno_reg_rtx + LAST_VIRTUAL_REGISTER + 1,\n+  bcopy ((char *) (reg_map + LAST_VIRTUAL_REGISTER + 1),\n+\t (char *) (regno_reg_rtx + LAST_VIRTUAL_REGISTER + 1),\n \t (max_reg - (LAST_VIRTUAL_REGISTER + 1)) * sizeof (rtx));\n \n   /* Likewise each label rtx must have a unique rtx as its copy.  */\n@@ -480,7 +480,7 @@ save_for_inline_copying (fndecl)\n   /* Record the mapping of old insns to copied insns.  */\n \n   insn_map = (rtx *) alloca (max_uid * sizeof (rtx));\n-  bzero (insn_map, max_uid * sizeof (rtx));\n+  bzero ((char *) insn_map, max_uid * sizeof (rtx));\n \n   /* Get the insn which signals the end of parameter setup code.  */\n   first_nonparm_insn = get_first_nonparm_insn ();\n@@ -1060,8 +1060,9 @@ copy_for_inline (orig)\n   /* Replace this rtx with a copy of itself.  */\n \n   x = rtx_alloc (code);\n-  bcopy (orig, x, (sizeof (*x) - sizeof (x->fld)\n-\t\t   + sizeof (x->fld[0]) * GET_RTX_LENGTH (code)));\n+  bcopy ((char *) orig, (char *) x,\n+\t (sizeof (*x) - sizeof (x->fld)\n+\t  + sizeof (x->fld[0]) * GET_RTX_LENGTH (code)));\n \n   /* Now scan the subexpressions recursively.\n      We can store any replaced subexpressions directly into X\n@@ -1306,13 +1307,13 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n   map->fndecl = fndecl;\n \n   map->reg_map = (rtx *) alloca (max_regno * sizeof (rtx));\n-  bzero (map->reg_map, max_regno * sizeof (rtx));\n+  bzero ((char *) map->reg_map, max_regno * sizeof (rtx));\n \n   map->label_map = (rtx *)alloca ((max_labelno - min_labelno) * sizeof (rtx));\n   map->label_map -= min_labelno;\n \n   map->insn_map = (rtx *) alloca (INSN_UID (header) * sizeof (rtx));\n-  bzero (map->insn_map, INSN_UID (header) * sizeof (rtx));\n+  bzero ((char *) map->insn_map, INSN_UID (header) * sizeof (rtx));\n   map->min_insnno = 0;\n   map->max_insnno = INSN_UID (header);\n \n@@ -1335,11 +1336,13 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \n   map->const_equiv_map\n     = (rtx *)alloca (map->const_equiv_map_size * sizeof (rtx));\n-  bzero (map->const_equiv_map, map->const_equiv_map_size * sizeof (rtx));\n+  bzero ((char *) map->const_equiv_map,\n+\t map->const_equiv_map_size * sizeof (rtx));\n \n   map->const_age_map\n     = (unsigned *)alloca (map->const_equiv_map_size * sizeof (unsigned));\n-  bzero (map->const_age_map, map->const_equiv_map_size * sizeof (unsigned));\n+  bzero ((char *) map->const_age_map,\n+\t map->const_equiv_map_size * sizeof (unsigned));\n   map->const_age = 0;\n \n   /* Record the current insn in case we have to set up pointers to frame"}, {"sha": "b8eaf11b99c533617adac44d36b4b81f0ff072fa", "filename": "gcc/jump.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -197,7 +197,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n      we make.  */\n   max_jump_chain = max_uid * 14 / 10;\n   jump_chain = (rtx *) alloca (max_jump_chain * sizeof (rtx));\n-  bzero (jump_chain, max_jump_chain * sizeof (rtx));\n+  bzero ((char *) jump_chain, max_jump_chain * sizeof (rtx));\n \n   /* Mark the label each jump jumps to.\n      Combine consecutive labels, and count uses of labels.\n@@ -2082,7 +2082,7 @@ duplicate_loop_exit_test (loop_start)\n \t    if (reg_map == 0)\n \t      {\n \t\treg_map = (rtx *) alloca (max_reg * sizeof (rtx));\n-\t\tbzero (reg_map, max_reg * sizeof (rtx));\n+\t\tbzero ((char *) reg_map, max_reg * sizeof (rtx));\n \t      }\n \n \t    REG_LOOP_TEST_P (SET_DEST (set)) = 1;\n@@ -4052,7 +4052,8 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t  bzero (modified_regs, max_reg * sizeof (char));\n \t  modified_mem = 0;\n \n-\t  bcopy (all_reset, same_regs, max_reg * sizeof (int));\n+\t  bcopy ((char *) all_reset, (char *) same_regs,\n+\t\t max_reg * sizeof (int));\n \t  num_same_regs = 0;\n \n \t  label = JUMP_LABEL (b1);"}, {"sha": "3b2d81ecf9bd68528032d5c49f8ddde4d063e255", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -415,13 +415,14 @@ local_alloc ()\n \n   scratch_list_length = max_qty;\n   scratch_list = (rtx *) xmalloc (scratch_list_length * sizeof (rtx));\n-  bzero (scratch_list, scratch_list_length * sizeof (rtx));\n+  bzero ((char *) scratch_list, scratch_list_length * sizeof (rtx));\n   scratch_block = (int *) xmalloc (scratch_list_length * sizeof (int));\n-  bzero (scratch_block, scratch_list_length * sizeof (int));\n+  bzero ((char *) scratch_block, scratch_list_length * sizeof (int));\n   scratch_index = 0;\n \n   qty_phys_reg = (short *) alloca (max_qty * sizeof (short));\n-  qty_phys_copy_sugg = (HARD_REG_SET *) alloca (max_qty * sizeof (HARD_REG_SET));\n+  qty_phys_copy_sugg\n+    = (HARD_REG_SET *) alloca (max_qty * sizeof (HARD_REG_SET));\n   qty_phys_num_copy_sugg = (short *) alloca (max_qty * sizeof (short));\n   qty_phys_sugg = (HARD_REG_SET *) alloca (max_qty * sizeof (HARD_REG_SET));\n   qty_phys_num_sugg = (short *) alloca (max_qty * sizeof (short));\n@@ -430,10 +431,13 @@ local_alloc ()\n   qty_scratch_rtx = (rtx *) alloca (max_qty * sizeof (rtx));\n   qty_first_reg = (int *) alloca (max_qty * sizeof (int));\n   qty_size = (int *) alloca (max_qty * sizeof (int));\n-  qty_mode = (enum machine_mode *) alloca (max_qty * sizeof (enum machine_mode));\n+  qty_mode\n+    = (enum machine_mode *) alloca (max_qty * sizeof (enum machine_mode));\n   qty_n_calls_crossed = (int *) alloca (max_qty * sizeof (int));\n-  qty_min_class = (enum reg_class *) alloca (max_qty * sizeof (enum reg_class));\n-  qty_alternate_class = (enum reg_class *) alloca (max_qty * sizeof (enum reg_class));\n+  qty_min_class\n+    = (enum reg_class *) alloca (max_qty * sizeof (enum reg_class));\n+  qty_alternate_class\n+    = (enum reg_class *) alloca (max_qty * sizeof (enum reg_class));\n   qty_n_refs = (int *) alloca (max_qty * sizeof (int));\n \n   reg_qty = (int *) alloca (max_regno * sizeof (int));\n@@ -492,7 +496,7 @@ local_alloc ()\n       else\n \t{\n #define CLEAR(vector)  \\\n-\t  bzero ((vector), (sizeof (*(vector))) * next_qty);\n+\t  bzero ((char *) (vector), (sizeof (*(vector))) * next_qty);\n \n \t  CLEAR (qty_scratch_rtx);\n \t  CLEAR (qty_phys_copy_sugg);\n@@ -937,8 +941,8 @@ update_equiv_regs ()\n   rtx *reg_equiv_replacement = (rtx *) alloca (max_regno * sizeof (rtx *));\n   rtx insn;\n \n-  bzero (reg_equiv_init_insn, max_regno * sizeof (rtx *));\n-  bzero (reg_equiv_replacement, max_regno * sizeof (rtx *));\n+  bzero ((char *) reg_equiv_init_insn, max_regno * sizeof (rtx *));\n+  bzero ((char *) reg_equiv_replacement, max_regno * sizeof (rtx *));\n \n   init_alias_analysis ();\n \n@@ -1139,7 +1143,7 @@ block_alloc (b)\n      the birth of a CLOBBER in the first insn.  */\n   regs_live_at = (HARD_REG_SET *) alloca ((2 * insn_count + 2)\n \t\t\t\t\t  * sizeof (HARD_REG_SET));\n-  bzero (regs_live_at, (2 * insn_count + 2) * sizeof (HARD_REG_SET));\n+  bzero ((char *) regs_live_at, (2 * insn_count + 2) * sizeof (HARD_REG_SET));\n \n   /* Initialize table of hardware registers currently live.  */\n "}, {"sha": "6469707c07d86b9e8cb63f7dec4b3ed79aa4fae5", "filename": "gcc/loop.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -361,8 +361,8 @@ loop_optimize (f, dumpfile)\n   uid_luid = (int *) alloca (max_uid_for_loop * sizeof (int));\n   uid_loop_num = (int *) alloca (max_uid_for_loop * sizeof (int));\n \n-  bzero (uid_luid, max_uid_for_loop * sizeof (int));\n-  bzero (uid_loop_num, max_uid_for_loop * sizeof (int));\n+  bzero ((char *) uid_luid, max_uid_for_loop * sizeof (int));\n+  bzero ((char *) uid_loop_num, max_uid_for_loop * sizeof (int));\n \n   /* Allocate tables for recording each loop.  We set each entry, so they need\n      not be zeroed.  */\n@@ -573,21 +573,21 @@ scan_loop (loop_start, end, nregs)\n      the setting of register I.  If this loop has calls, set\n      reg_single_usage[I].  */\n \n-  bzero (n_times_set, nregs * sizeof (short));\n+  bzero ((char *) n_times_set, nregs * sizeof (short));\n   bzero (may_not_optimize, nregs);\n \n   if (loop_has_call)\n     {\n       reg_single_usage = (rtx *) alloca (nregs * sizeof (rtx));\n-      bzero (reg_single_usage, nregs * sizeof (rtx));\n+      bzero ((char *) reg_single_usage, nregs * sizeof (rtx));\n     }\n \n   count_loop_regs_set (loop_top ? loop_top : loop_start, end,\n \t\t       may_not_optimize, reg_single_usage, &insn_count, nregs);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     may_not_optimize[i] = 1, n_times_set[i] = 1;\n-  bcopy (n_times_set, n_times_used, nregs * sizeof (short));\n+  bcopy ((char *) n_times_set, (char *) n_times_used, nregs * sizeof (short));\n \n   if (loop_dump_stream)\n     {\n@@ -1535,7 +1535,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n   char *already_moved = (char *) alloca (nregs);\n \n   bzero (already_moved, nregs);\n-  bzero (reg_map, nregs * sizeof (rtx));\n+  bzero ((char *) reg_map, nregs * sizeof (rtx));\n \n   num_movables = 0;\n \n@@ -2917,7 +2917,7 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n   register int count = 0;\n   register rtx dest;\n \n-  bzero (last_set, nregs * sizeof (rtx));\n+  bzero ((char *) last_set, nregs * sizeof (rtx));\n   for (insn = from; insn != to; insn = NEXT_INSN (insn))\n     {\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n@@ -3004,8 +3004,9 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n \t\t}\n \t    }\n \t}\n+\n       if (GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == JUMP_INSN)\n-\tbzero (last_set, nregs * sizeof (rtx));\n+\tbzero ((char *) last_set, nregs * sizeof (rtx));\n     }\n   *count_ptr = count;\n }"}, {"sha": "f4f878f8b34c4cf4c073f55cb276a1a008cc750c", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -51,8 +51,9 @@ debug_tree (node)\n      tree node;\n {\n   char *object = (char *) oballoc (0);\n+\n   table = (struct bucket **) oballoc (HASH_SIZE * sizeof (struct bucket *));\n-  bzero (table, HASH_SIZE * sizeof (struct bucket *));\n+  bzero ((char *) table, HASH_SIZE * sizeof (struct bucket *));\n   print_node (stderr, \"\", node, 0);\n   table = 0;\n   obfree (object);"}, {"sha": "34d6d67838975ad2313f6d4a8e658d8034235e00", "filename": "gcc/real.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -417,7 +417,7 @@ REAL_VALUE_TYPE real_value_from_int_cst ();\n \n #define REAL_VALUE_FROM_CONST_DOUBLE(to, from)\t\t\\\n do { union real_extract u;\t\t\t\t\\\n-     bcopy (&CONST_DOUBLE_LOW ((from)), &u, sizeof u);\t\\\n+     bcopy ((char *) &CONST_DOUBLE_LOW ((from)), (char *) &u, sizeof u); \\\n      to = u.d; } while (0)\n \n /* Return a CONST_DOUBLE with value R and mode M.  */"}, {"sha": "d4636d5837414d5ef8caff749f1f2025d0a59bff", "filename": "gcc/regclass.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -219,7 +219,7 @@ init_reg_sets ()\n \n   /* Compute number of hard regs in each class.  */\n \n-  bzero (reg_class_size, sizeof reg_class_size);\n+  bzero ((char *) reg_class_size, sizeof reg_class_size);\n   for (i = 0; i < N_REG_CLASSES; i++)\n     for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n       if (TEST_HARD_REG_BIT (reg_class_contents[i], j))\n@@ -702,7 +702,7 @@ regclass (f, nregs)\n     {\n       /* Zero out our accumulation of the cost of each class for each reg.  */\n \n-      bzero (costs, nregs * sizeof (struct costs));\n+      bzero ((char *) costs, nregs * sizeof (struct costs));\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n       bzero (in_inc_dec, nregs);\n@@ -1662,10 +1662,11 @@ reg_scan (f, nregs, repeat)\n \t= (short *) oballoc (highest_regno_in_uid_map * sizeof (short));\n     }\n \n-  bzero (regno_first_uid, highest_regno_in_uid_map * sizeof (int));\n-  bzero (regno_last_uid, highest_regno_in_uid_map * sizeof (int));\n-  bzero (regno_last_note_uid, highest_regno_in_uid_map * sizeof (int));\n-  bzero (reg_n_sets, highest_regno_in_uid_map * sizeof (short));\n+  bzero ((char *) regno_first_uid, highest_regno_in_uid_map * sizeof (int));\n+  bzero ((char *) regno_last_uid, highest_regno_in_uid_map * sizeof (int));\n+  bzero ((char *) regno_last_note_uid,\n+\t highest_regno_in_uid_map * sizeof (int));\n+  bzero ((char *) reg_n_sets, highest_regno_in_uid_map * sizeof (short));\n \n   max_parallel = 3;\n "}, {"sha": "6aabcf299b61711dd705f419f129b039758a6876", "filename": "gcc/reload.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -671,7 +671,7 @@ get_secondary_mem (x, mode, opnum, type)\n void\n clear_secondary_mem ()\n {\n-  bzero (secondary_memlocs, sizeof secondary_memlocs);\n+  bzero ((char *) secondary_memlocs, sizeof secondary_memlocs);\n }\n #endif /* SECONDARY_MEMORY_NEEDED */\n \f\n@@ -2180,7 +2180,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   /* The eliminated forms of any secondary memory locations are per-insn, so\n      clear them out here.  */\n \n-  bzero (secondary_memlocs_elim, sizeof secondary_memlocs_elim);\n+  bzero ((char *) secondary_memlocs_elim, sizeof secondary_memlocs_elim);\n #endif\n \n   /* Find what kind of insn this is.  NOPERANDS gets number of operands.\n@@ -2231,7 +2231,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t       constraints, operand_mode);\n \t  if (noperands > 0)\n \t    {\n-\t      bcopy (constraints, constraints1, noperands * sizeof (char *));\n+\t      bcopy ((char *) constraints, (char *) constraints1,\n+\t\t     noperands * sizeof (char *));\n \t      n_alternatives = n_occurrences (',', constraints[0]) + 1;\n \t      for (i = 1; i < noperands; i++)\n \t\tif (n_alternatives != n_occurrences (',', constraints[i]) + 1)\n@@ -3186,7 +3187,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  pref_or_nothing[commutative] = pref_or_nothing[commutative + 1];\n \t  pref_or_nothing[commutative + 1] = t;\n \n-\t  bcopy (constraints1, constraints, noperands * sizeof (char *));\n+\t  bcopy ((char *) constraints1, (char *) constraints,\n+\t\t noperands * sizeof (char *));\n \t  goto try_swapped;\n \t}\n       else"}, {"sha": "98b779f8394b428cb9325c199cb96650a82bea1e", "filename": "gcc/reload1.c", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -479,8 +479,8 @@ reload (first, global, dumpfile)\n   bcopy (regs_ever_live, regs_explicitly_used, sizeof regs_ever_live);\n \n   /* We don't have a stack slot for any spill reg yet.  */\n-  bzero (spill_stack_slot, sizeof spill_stack_slot);\n-  bzero (spill_stack_slot_width, sizeof spill_stack_slot_width);\n+  bzero ((char *) spill_stack_slot, sizeof spill_stack_slot);\n+  bzero ((char *) spill_stack_slot_width, sizeof spill_stack_slot_width);\n \n   /* Initialize the save area information for caller-save, in case some\n      are needed.  */\n@@ -513,17 +513,17 @@ reload (first, global, dumpfile)\n      be substituted eventually by altering the REG-rtx's.  */\n \n   reg_equiv_constant = (rtx *) alloca (max_regno * sizeof (rtx));\n-  bzero (reg_equiv_constant, max_regno * sizeof (rtx));\n+  bzero ((char *) reg_equiv_constant, max_regno * sizeof (rtx));\n   reg_equiv_memory_loc = (rtx *) alloca (max_regno * sizeof (rtx));\n-  bzero (reg_equiv_memory_loc, max_regno * sizeof (rtx));\n+  bzero ((char *) reg_equiv_memory_loc, max_regno * sizeof (rtx));\n   reg_equiv_mem = (rtx *) alloca (max_regno * sizeof (rtx));\n-  bzero (reg_equiv_mem, max_regno * sizeof (rtx));\n+  bzero ((char *) reg_equiv_mem, max_regno * sizeof (rtx));\n   reg_equiv_init = (rtx *) alloca (max_regno * sizeof (rtx));\n-  bzero (reg_equiv_init, max_regno * sizeof (rtx));\n+  bzero ((char *) reg_equiv_init, max_regno * sizeof (rtx));\n   reg_equiv_address = (rtx *) alloca (max_regno * sizeof (rtx));\n-  bzero (reg_equiv_address, max_regno * sizeof (rtx));\n+  bzero ((char *) reg_equiv_address, max_regno * sizeof (rtx));\n   reg_max_ref_width = (int *) alloca (max_regno * sizeof (int));\n-  bzero (reg_max_ref_width, max_regno * sizeof (int));\n+  bzero ((char *) reg_max_ref_width, max_regno * sizeof (int));\n   cannot_omit_stores = (char *) alloca (max_regno);\n   bzero (cannot_omit_stores, max_regno);\n \n@@ -711,7 +711,7 @@ reload (first, global, dumpfile)\n   if (global)\n     for (i = 0; i < N_REG_CLASSES; i++)\n       {\n-\tbasic_block_needs[i] = (char *)alloca (n_basic_blocks);\n+\tbasic_block_needs[i] = (char *) alloca (n_basic_blocks);\n \tbzero (basic_block_needs[i], n_basic_blocks);\n       }\n \n@@ -763,13 +763,13 @@ reload (first, global, dumpfile)\n       static char *reg_class_names[] = REG_CLASS_NAMES;\n \n       something_changed = 0;\n-      bzero (max_needs, sizeof max_needs);\n-      bzero (max_groups, sizeof max_groups);\n-      bzero (max_nongroups, sizeof max_nongroups);\n-      bzero (max_needs_insn, sizeof max_needs_insn);\n-      bzero (max_groups_insn, sizeof max_groups_insn);\n-      bzero (max_nongroups_insn, sizeof max_nongroups_insn);\n-      bzero (group_size, sizeof group_size);\n+      bzero ((char *) max_needs, sizeof max_needs);\n+      bzero ((char *) max_groups, sizeof max_groups);\n+      bzero ((char *) max_nongroups, sizeof max_nongroups);\n+      bzero ((char *) max_needs_insn, sizeof max_needs_insn);\n+      bzero ((char *) max_groups_insn, sizeof max_groups_insn);\n+      bzero ((char *) max_nongroups_insn, sizeof max_nongroups_insn);\n+      bzero ((char *) group_size, sizeof group_size);\n       for (i = 0; i < N_REG_CLASSES; i++)\n \tgroup_mode[i] = VOIDmode;\n \n@@ -802,7 +802,7 @@ reload (first, global, dumpfile)\n \n       num_not_at_initial_offset = 0;\n \n-      bzero (&offsets_known_at[get_first_label_num ()], num_labels);\n+      bzero ((char *) &offsets_known_at[get_first_label_num ()], num_labels);\n \n       /* Set a known offset for each forced label to be at the initial offset\n \t of each elimination.  We do this because we assume that all\n@@ -1020,7 +1020,7 @@ reload (first, global, dumpfile)\n \t\tcontinue;\n \n \t      something_needs_reloads = 1;\n-\t      bzero (&insn_needs, sizeof insn_needs);\n+\t      bzero ((char *) &insn_needs, sizeof insn_needs);\n \n \t      /* Count each reload once in every class\n \t\t containing the reload's own class.  */\n@@ -3060,9 +3060,9 @@ eliminate_regs (x, mem_mode, insn)\n \t  if (new != XEXP (x, i) && ! copied)\n \t    {\n \t      rtx new_x = rtx_alloc (code);\n-\t      bcopy (x, new_x, (sizeof (*new_x) - sizeof (new_x->fld)\n-\t\t\t\t+ (sizeof (new_x->fld[0])\n-\t\t\t\t   * GET_RTX_LENGTH (code))));\n+\t      bcopy ((char *) x, (char *) new_x,\n+\t\t     (sizeof (*new_x) - sizeof (new_x->fld)\n+\t\t      + sizeof (new_x->fld[0]) * GET_RTX_LENGTH (code)));\n \t      x = new_x;\n \t      copied = 1;\n \t    }\n@@ -3081,9 +3081,10 @@ eliminate_regs (x, mem_mode, insn)\n \t\t  if (! copied)\n \t\t    {\n \t\t      rtx new_x = rtx_alloc (code);\n-\t\t      bcopy (x, new_x, (sizeof (*new_x) - sizeof (new_x->fld)\n-\t\t\t\t\t+ (sizeof (new_x->fld[0])\n-\t\t\t\t\t   * GET_RTX_LENGTH (code))));\n+\t\t      bcopy ((char *) x, (char *) new_x,\n+\t\t\t     (sizeof (*new_x) - sizeof (new_x->fld)\n+\t\t\t      + (sizeof (new_x->fld[0])\n+\t\t\t\t * GET_RTX_LENGTH (code))));\n \t\t      x = new_x;\n \t\t      copied = 1;\n \t\t    }\n@@ -3640,10 +3641,10 @@ reload_as_needed (first, live_known)\n   rtx x;\n   rtx after_call = 0;\n \n-  bzero (spill_reg_rtx, sizeof spill_reg_rtx);\n-  bzero (spill_reg_store, sizeof spill_reg_store);\n+  bzero ((char *) spill_reg_rtx, sizeof spill_reg_rtx);\n+  bzero ((char *) spill_reg_store, sizeof spill_reg_store);\n   reg_last_reload_reg = (rtx *) alloca (max_regno * sizeof (rtx));\n-  bzero (reg_last_reload_reg, max_regno * sizeof (rtx));\n+  bzero ((char *) reg_last_reload_reg, max_regno * sizeof (rtx));\n   reg_has_output_reload = (char *) alloca (max_regno);\n   for (i = 0; i < n_spills; i++)\n     {\n@@ -4817,8 +4818,8 @@ choose_reload_regs (insn, avoid_return_reg)\n   HARD_REG_SET save_reload_reg_used_at_all;\n \n   bzero (reload_inherited, MAX_RELOADS);\n-  bzero (reload_inheritance_insn, MAX_RELOADS * sizeof (rtx));\n-  bzero (reload_override_in, MAX_RELOADS * sizeof (rtx));\n+  bzero ((char *) reload_inheritance_insn, MAX_RELOADS * sizeof (rtx));\n+  bzero ((char *) reload_override_in, MAX_RELOADS * sizeof (rtx));\n \n   CLEAR_HARD_REG_SET (reload_reg_used);\n   CLEAR_HARD_REG_SET (reload_reg_used_at_all);\n@@ -4939,13 +4940,15 @@ choose_reload_regs (insn, avoid_return_reg)\n   if (n_reloads > 1)\n     qsort (reload_order, n_reloads, sizeof (short), reload_reg_class_lower);\n \n-  bcopy (reload_reg_rtx, save_reload_reg_rtx, sizeof reload_reg_rtx);\n+  bcopy ((char *) reload_reg_rtx, (char *) save_reload_reg_rtx,\n+\t sizeof reload_reg_rtx);\n   bcopy (reload_inherited, save_reload_inherited, sizeof reload_inherited);\n-  bcopy (reload_inheritance_insn, save_reload_inheritance_insn,\n+  bcopy ((char *) reload_inheritance_insn,\n+\t (char *) save_reload_inheritance_insn,\n \t sizeof reload_inheritance_insn);\n-  bcopy (reload_override_in, save_reload_override_in,\n+  bcopy ((char *) reload_override_in, (char *) save_reload_override_in,\n \t sizeof reload_override_in);\n-  bcopy (reload_spill_index, save_reload_spill_index,\n+  bcopy ((char *) reload_spill_index, (char *) save_reload_spill_index,\n \t sizeof reload_spill_index);\n   COPY_HARD_REG_SET (save_reload_reg_used, reload_reg_used);\n   COPY_HARD_REG_SET (save_reload_reg_used_at_all, reload_reg_used_at_all);\n@@ -5312,13 +5315,16 @@ choose_reload_regs (insn, avoid_return_reg)\n       /* Loop around and try without any inheritance.  */\n       /* First undo everything done by the failed attempt\n \t to allocate with inheritance.  */\n-      bcopy (save_reload_reg_rtx, reload_reg_rtx, sizeof reload_reg_rtx);\n-      bcopy (save_reload_inherited, reload_inherited, sizeof reload_inherited);\n-      bcopy (save_reload_inheritance_insn, reload_inheritance_insn,\n+      bcopy ((char *) save_reload_reg_rtx, (char *) reload_reg_rtx,\n+\t     sizeof reload_reg_rtx);\n+      bcopy ((char *) save_reload_inherited, (char *) reload_inherited,\n+\t     sizeof reload_inherited);\n+      bcopy ((char *) save_reload_inheritance_insn,\n+\t     (char *) reload_inheritance_insn,\n \t     sizeof reload_inheritance_insn);\n-      bcopy (save_reload_override_in, reload_override_in,\n+      bcopy ((char *) save_reload_override_in, (char *) reload_override_in,\n \t     sizeof reload_override_in);\n-      bcopy (save_reload_spill_index, reload_spill_index,\n+      bcopy ((char *) save_reload_spill_index, (char *) reload_spill_index,\n \t     sizeof reload_spill_index);\n       COPY_HARD_REG_SET (reload_reg_used, save_reload_reg_used);\n       COPY_HARD_REG_SET (reload_reg_used_at_all, save_reload_reg_used_at_all);"}, {"sha": "9870967ea7109972bf4192f6469097b76ab0751e", "filename": "gcc/sched.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -407,14 +407,14 @@ init_alias_analysis ()\n   reg_known_value\n     = (rtx *) oballoc ((maxreg-FIRST_PSEUDO_REGISTER) * sizeof (rtx))\n       - FIRST_PSEUDO_REGISTER;\n-  bzero (reg_known_value+FIRST_PSEUDO_REGISTER,\n+  bzero ((char *) (reg_known_value + FIRST_PSEUDO_REGISTER),\n \t (maxreg-FIRST_PSEUDO_REGISTER) * sizeof (rtx));\n \n   reg_known_equiv_p\n-    = (char *) oballoc ((maxreg-FIRST_PSEUDO_REGISTER) * sizeof (char))\n+    = (char *) oballoc ((maxreg -FIRST_PSEUDO_REGISTER) * sizeof (char))\n       - FIRST_PSEUDO_REGISTER;\n-  bzero (reg_known_equiv_p+FIRST_PSEUDO_REGISTER,\n-\t (maxreg-FIRST_PSEUDO_REGISTER) * sizeof (char));\n+  bzero (reg_known_equiv_p + FIRST_PSEUDO_REGISTER,\n+\t (maxreg - FIRST_PSEUDO_REGISTER) * sizeof (char));\n \n   /* Fill in the entries with known constant values.  */\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -1170,9 +1170,9 @@ static int unit_n_insns[FUNCTION_UNITS_SIZE];\n static void\n clear_units ()\n {\n-  bzero (unit_last_insn, sizeof (unit_last_insn));\n-  bzero (unit_tick, sizeof (unit_tick));\n-  bzero (unit_n_insns, sizeof (unit_n_insns));\n+  bzero ((char *) unit_last_insn, sizeof (unit_last_insn));\n+  bzero ((char *) unit_tick, sizeof (unit_tick));\n+  bzero ((char *) unit_n_insns, sizeof (unit_n_insns));\n }\n \n /* Record an insn as one that will use the units encoded by UNIT.  */\n@@ -3088,11 +3088,11 @@ schedule_block (b, file)\n \n   i = max_reg_num ();\n   reg_last_uses = (rtx *) alloca (i * sizeof (rtx));\n-  bzero (reg_last_uses, i * sizeof (rtx));\n+  bzero ((char *) reg_last_uses, i * sizeof (rtx));\n   reg_last_sets = (rtx *) alloca (i * sizeof (rtx));\n-  bzero (reg_last_sets, i * sizeof (rtx));\n+  bzero ((char *) reg_last_sets, i * sizeof (rtx));\n   reg_pending_sets = (regset) alloca (regset_bytes);\n-  bzero (reg_pending_sets, regset_bytes);\n+  bzero ((char *) reg_pending_sets, regset_bytes);\n   reg_pending_sets_all = 0;\n   clear_units ();\n \n@@ -3327,8 +3327,9 @@ schedule_block (b, file)\n \n   if (reload_completed == 0)\n     {\n-      bcopy (basic_block_live_at_start[b], bb_live_regs, regset_bytes);\n-      bzero (bb_dead_regs, regset_bytes);\n+      bcopy ((char *) basic_block_live_at_start[b], (char *) bb_live_regs,\n+\t     regset_bytes);\n+      bzero ((char *) bb_dead_regs, regset_bytes);\n \n       if (b == 0)\n \t{\n@@ -3568,7 +3569,7 @@ schedule_block (b, file)\n \n   /* Q_SIZE will always be zero here.  */\n   q_ptr = 0; clock = 0;\n-  bzero (insn_queue, sizeof (insn_queue));\n+  bzero ((char *) insn_queue, sizeof (insn_queue));\n \n   /* Now, perform list scheduling.  */\n \n@@ -4627,9 +4628,10 @@ schedule_insns (dump_file)\n       sched_reg_live_length = (int *) alloca (max_regno * sizeof (int));\n       bb_dead_regs = (regset) alloca (regset_bytes);\n       bb_live_regs = (regset) alloca (regset_bytes);\n-      bzero (sched_reg_n_calls_crossed, max_regno * sizeof (int));\n-      bzero (sched_reg_live_length, max_regno * sizeof (int));\n-      bcopy (reg_n_deaths, sched_reg_n_deaths, max_regno * sizeof (short));\n+      bzero ((char *) sched_reg_n_calls_crossed, max_regno * sizeof (int));\n+      bzero ((char *) sched_reg_live_length, max_regno * sizeof (int));\n+      bcopy ((char *) reg_n_deaths, (char *) sched_reg_n_deaths,\n+\t     max_regno * sizeof (short));\n       init_alias_analysis ();\n     }\n   else\n@@ -4648,9 +4650,9 @@ schedule_insns (dump_file)\n       rtx line;\n \n       line_note = (rtx *) alloca (max_uid * sizeof (rtx));\n-      bzero (line_note, max_uid * sizeof (rtx));\n+      bzero ((char *) line_note, max_uid * sizeof (rtx));\n       line_note_head = (rtx *) alloca (n_basic_blocks * sizeof (rtx));\n-      bzero (line_note_head, n_basic_blocks * sizeof (rtx));\n+      bzero ((char *) line_note_head, n_basic_blocks * sizeof (rtx));\n \n       /* Determine the line-number at the start of each basic block.\n \t This must be computed and saved now, because after a basic block's\n@@ -4666,13 +4668,13 @@ schedule_insns (dump_file)\n \t    }\n     }\n \n-  bzero (insn_luid, max_uid * sizeof (int));\n-  bzero (insn_priority, max_uid * sizeof (int));\n-  bzero (insn_tick, max_uid * sizeof (int));\n-  bzero (insn_costs, max_uid * sizeof (short));\n-  bzero (insn_units, max_uid * sizeof (short));\n-  bzero (insn_blockage, max_uid * sizeof (unsigned int));\n-  bzero (insn_ref_count, max_uid * sizeof (int));\n+  bzero ((char *) insn_luid, max_uid * sizeof (int));\n+  bzero ((char *) insn_priority, max_uid * sizeof (int));\n+  bzero ((char *) insn_tick, max_uid * sizeof (int));\n+  bzero ((char *) insn_costs, max_uid * sizeof (short));\n+  bzero ((char *) insn_units, max_uid * sizeof (short));\n+  bzero ((char *) insn_blockage, max_uid * sizeof (unsigned int));\n+  bzero ((char *) insn_ref_count, max_uid * sizeof (int));\n \n   /* Schedule each basic block, block by block.  */\n "}, {"sha": "acaa436cacffbb9c47509bcf65c7b63de09abb70", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -4527,7 +4527,7 @@ expand_end_case (orig_index)\n \n \t  ncases = TREE_INT_CST_LOW (range) + 1;\n \t  labelvec = (rtx *) alloca (ncases * sizeof (rtx));\n-\t  bzero (labelvec, ncases * sizeof (rtx));\n+\t  bzero ((char *) labelvec, ncases * sizeof (rtx));\n \n \t  for (n = thiscase->data.case_stmt.case_list; n; n = n->right)\n \t    {\n@@ -4756,7 +4756,7 @@ estimate_case_costs (node)\n   if (cost_table == NULL)\n     {\n       cost_table = ((short *) xmalloc (129 * sizeof (short))) + 1;\n-      bzero (cost_table - 1, 129 * sizeof (short));\n+      bzero ((char *) (cost_table - 1), 129 * sizeof (short));\n \n       for (i = 0; i < 128; i++)\n \t{"}, {"sha": "7ceec9f973719ed44a904e27f5cf4e4ce882cb56", "filename": "gcc/stupid.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -149,13 +149,13 @@ stupid_life_analysis (f, nregs, file)\n   /* Allocate tables to record info about regs.  */\n \n   reg_where_dead = (int *) alloca (nregs * sizeof (int));\n-  bzero (reg_where_dead, nregs * sizeof (int));\n+  bzero ((char *) reg_where_dead, nregs * sizeof (int));\n \n   reg_where_born = (int *) alloca (nregs * sizeof (int));\n-  bzero (reg_where_born, nregs * sizeof (int));\n+  bzero ((char *) reg_where_born, nregs * sizeof (int));\n \n   reg_order = (int *) alloca (nregs * sizeof (int));\n-  bzero (reg_order, nregs * sizeof (int));\n+  bzero ((char *) reg_order, nregs * sizeof (int));\n \n   reg_renumber = (short *) oballoc (nregs * sizeof (short));\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -167,7 +167,7 @@ stupid_life_analysis (f, nregs, file)\n   after_insn_hard_regs\n     = (HARD_REG_SET *) alloca (max_suid * sizeof (HARD_REG_SET));\n \n-  bzero (after_insn_hard_regs, max_suid * sizeof (HARD_REG_SET));\n+  bzero ((char *) after_insn_hard_regs, max_suid * sizeof (HARD_REG_SET));\n \n   /* Allocate and zero out many data structures\n      that will record the data from lifetime analysis.  */"}, {"sha": "2cd794379a9e046bb3ae421fa2f0643aee1cdb5d", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -1798,7 +1798,7 @@ set_float_handler (handler)\n {\n   float_handled = (handler != 0);\n   if (handler)\n-    bcopy (handler, float_handler, sizeof (float_handler));\n+    bcopy ((char *) handler, (char *) float_handler, sizeof (float_handler));\n }\n \n /* Specify, in HANDLER, where to longjmp to when a floating arithmetic\n@@ -1813,8 +1813,10 @@ push_float_handler (handler, old_handler)\n \n   float_handled = 1;\n   if (was_handled)\n-    bcopy (float_handler, old_handler, sizeof (float_handler));\n-  bcopy (handler, float_handler, sizeof (float_handler));\n+    bcopy ((char *) float_handler, (char *) old_handler,\n+\t   sizeof (float_handler));\n+\n+  bcopy ((char *) handler, (char *) float_handler, sizeof (float_handler));\n   return was_handled;\n }\n \n@@ -1828,7 +1830,7 @@ pop_float_handler (handled, handler)\n {\n   float_handled = handled;\n   if (handled)\n-    bcopy (handler, float_handler, sizeof (float_handler));\n+    bcopy ((char *) handler, (char *) float_handler, sizeof (float_handler));\n }\n \n /* Signals actually come here.  */\n@@ -3877,6 +3879,9 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #ifndef VMS\n   if (flag_print_mem)\n     {\n+#ifdef __alpha\n+      char *sbrk ();\n+#endif\n       char *lim = (char *) sbrk (0);\n \n       fprintf (stderr, \"Data size %d.\\n\","}, {"sha": "e0aa0aea6bf97c9447af6717131e022438bc6b08", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -292,7 +292,7 @@ init_obstacks ()\n   rtl_obstack = saveable_obstack = &permanent_obstack;\n \n   /* Init the hash table of identifiers.  */\n-  bzero (hash_table, sizeof hash_table);\n+  bzero ((char *) hash_table, sizeof hash_table);\n }\n \n void\n@@ -812,11 +812,11 @@ init_tree_codes ()\n   tree_code_type = (char **) xmalloc (sizeof (standard_tree_code_type));\n   tree_code_length = (int *) xmalloc (sizeof (standard_tree_code_length));\n   tree_code_name = (char **) xmalloc (sizeof (standard_tree_code_name));\n-  bcopy (standard_tree_code_type, tree_code_type,\n+  bcopy ((char *) standard_tree_code_type, (char *) tree_code_type,\n \t sizeof (standard_tree_code_type));\n-  bcopy (standard_tree_code_length, tree_code_length,\n+  bcopy ((char *) standard_tree_code_length, (char *) tree_code_length,\n \t sizeof (standard_tree_code_length));\n-  bcopy (standard_tree_code_name, tree_code_name,\n+  bcopy ((char *) standard_tree_code_name, (char *) tree_code_name,\n \t sizeof (standard_tree_code_name));\n }\n "}, {"sha": "3f628bddc8a7353efd438dd1f9050123e9d755a1", "filename": "gcc/unroll.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -705,12 +705,12 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n      to access the splittable_regs[] and addr_combined_regs[] arrays.  */\n \n   splittable_regs = (rtx *) alloca (maxregnum * sizeof (rtx));\n-  bzero (splittable_regs, maxregnum * sizeof (rtx));\n+  bzero ((char *) splittable_regs, maxregnum * sizeof (rtx));\n   splittable_regs_updates = (int *) alloca (maxregnum * sizeof (int));\n-  bzero (splittable_regs_updates, maxregnum * sizeof (int));\n+  bzero ((char *) splittable_regs_updates, maxregnum * sizeof (int));\n   addr_combined_regs\n     = (struct induction **) alloca (maxregnum * sizeof (struct induction *));\n-  bzero (addr_combined_regs, maxregnum * sizeof (struct induction *));\n+  bzero ((char *) addr_combined_regs, maxregnum * sizeof (struct induction *));\n \n   /* If this loop requires exit tests when unrolled, check to see if we\n      can precondition the loop so as to make the exit tests unnecessary.\n@@ -913,9 +913,10 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t      emit_label_after (labels[unroll_number - i],\n \t\t\t\tPREV_INSN (loop_start));\n \n-\t      bzero (map->insn_map, max_insnno * sizeof (rtx));\n-\t      bzero (map->const_equiv_map, maxregnum * sizeof (rtx));\n-\t      bzero (map->const_age_map, maxregnum * sizeof (unsigned));\n+\t      bzero ((char *) map->insn_map, max_insnno * sizeof (rtx));\n+\t      bzero ((char *) map->const_equiv_map, maxregnum * sizeof (rtx));\n+\t      bzero ((char *) map->const_age_map,\n+\t\t     maxregnum * sizeof (unsigned));\n \t      map->const_age = 0;\n \n \t      for (j = 0; j < max_labelno; j++)\n@@ -1050,9 +1051,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n   for (i = 0; i < unroll_number; i++)\n     {\n-      bzero (map->insn_map, max_insnno * sizeof (rtx));\n-      bzero (map->const_equiv_map, new_maxregnum * sizeof (rtx));\n-      bzero (map->const_age_map, new_maxregnum * sizeof (unsigned));\n+      bzero ((char *) map->insn_map, max_insnno * sizeof (rtx));\n+      bzero ((char *) map->const_equiv_map, new_maxregnum * sizeof (rtx));\n+      bzero ((char *) map->const_age_map, new_maxregnum * sizeof (unsigned));\n       map->const_age = 0;\n \n       for (j = 0; j < max_labelno; j++)"}, {"sha": "ebf8deda0f3a2acf1372463b04d57a0fbbe61c6a", "filename": "gcc/varasm.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a05bc5560ebb1144228bccb5312871a3089f7/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=4c9a05bc5560ebb1144228bccb5312871a3089f7", "patch": "@@ -1694,7 +1694,7 @@ assemble_real (d, mode)\n     {\n       error (\"floating point trap outputting a constant\");\n #ifdef REAL_IS_NOT_DOUBLE\n-      bzero (&d, sizeof d);\n+      bzero ((char *) &d, sizeof d);\n       d = dconst0;\n #else\n       d = 0;\n@@ -1885,7 +1885,7 @@ immed_real_const_1 (d, mode)\n   /* Detect special cases.  */\n \n   /* Avoid REAL_VALUES_EQUAL here in order to distinguish minus zero.  */\n-  if (!bcmp (&dconst0, &d, sizeof d))\n+  if (!bcmp ((char *) &dconst0, (char *) &d, sizeof d))\n     return CONST0_RTX (mode);\n   /* Check for NaN first, because some ports (specifically the i386) do not\n      emit correct ieee-fp code by default, and thus will generate a core\n@@ -1905,7 +1905,7 @@ immed_real_const_1 (d, mode)\n      If one is found, return it.  */\n \n   for (r = const_double_chain; r; r = CONST_DOUBLE_CHAIN (r))\n-    if (! bcmp (&CONST_DOUBLE_LOW (r), &u, sizeof u)\n+    if (! bcmp ((char *) &CONST_DOUBLE_LOW (r), (char *) &u, sizeof u)\n \t&& GET_MODE (r) == mode)\n       return r;\n \n@@ -1921,7 +1921,7 @@ immed_real_const_1 (d, mode)\n   rtl_in_saveable_obstack ();\n   r = rtx_alloc (CONST_DOUBLE);\n   PUT_MODE (r, mode);\n-  bcopy (&u, &CONST_DOUBLE_LOW (r), sizeof u);\n+  bcopy ((char *) &u, (char *) &CONST_DOUBLE_LOW (r), sizeof u);\n   pop_obstacks ();\n \n   /* Don't touch const_double_chain in nested function; see force_const_mem.\n@@ -2214,7 +2214,7 @@ compare_constant_1 (exp, p)\n \treturn 0;\n       strp = TREE_STRING_POINTER (exp);\n       len = TREE_STRING_LENGTH (exp);\n-      if (bcmp (&TREE_STRING_LENGTH (exp), p,\n+      if (bcmp ((char *) &TREE_STRING_LENGTH (exp), p,\n \t\tsizeof TREE_STRING_LENGTH (exp)))\n \treturn 0;\n       p += sizeof TREE_STRING_LENGTH (exp);\n@@ -2232,7 +2232,7 @@ compare_constant_1 (exp, p)\n       int length = list_length (CONSTRUCTOR_ELTS (exp));\n       tree type;\n \n-      if (bcmp (&length, p, sizeof length))\n+      if (bcmp ((char *) &length, p, sizeof length))\n \treturn 0;\n       p += sizeof length;\n \n@@ -2242,15 +2242,15 @@ compare_constant_1 (exp, p)\n \ttype = TREE_TYPE (exp);\n       else\n \ttype = 0;\n-      if (bcmp (&type, p, sizeof type))\n+      if (bcmp ((char *) &type, p, sizeof type))\n \treturn 0;\n       p += sizeof type;\n \n       /* For arrays, insist that the size in bytes match.  */\n       if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n \t{\n \t  int size = int_size_in_bytes (TREE_TYPE (exp));\n-\t  if (bcmp (&size, p, sizeof size))\n+\t  if (bcmp ((char *) &size, p, sizeof size))\n \t    return 0;\n \t  p += sizeof size;\n \t}\n@@ -2266,7 +2266,7 @@ compare_constant_1 (exp, p)\n \t    {\n \t      tree zero = 0;\n \n-\t      if (bcmp (&zero, p, sizeof zero))\n+\t      if (bcmp ((char *) &zero, p, sizeof zero))\n \t\treturn 0;\n \t      p += sizeof zero;\n \t    }\n@@ -2774,9 +2774,9 @@ init_const_rtx_hash_table ()\n   const_rtx_sym_hash_table\n     = ((struct pool_sym **)\n        oballoc (MAX_RTX_HASH_TABLE * sizeof (struct pool_sym *)));\n-  bzero (const_rtx_hash_table,\n+  bzero ((char *) const_rtx_hash_table,\n \t MAX_RTX_HASH_TABLE * sizeof (struct constant_descriptor *));\n-  bzero (const_rtx_sym_hash_table,\n+  bzero ((char *) const_rtx_sym_hash_table,\n \t MAX_RTX_HASH_TABLE * sizeof (struct pool_sym *));\n \n   first_pool = last_pool = 0;\n@@ -2852,7 +2852,8 @@ decode_rtx_const (mode, x, value)\n       value->kind = RTX_DOUBLE;\n       if (GET_MODE (x) != VOIDmode)\n \tvalue->mode = GET_MODE (x);\n-      bcopy (&CONST_DOUBLE_LOW (x), &value->un.du, sizeof value->un.du);\n+      bcopy ((char *) &CONST_DOUBLE_LOW (x),\n+\t     (char *) &value->un.du, sizeof value->un.du);\n       break;\n \n     case CONST_INT:\n@@ -3226,7 +3227,7 @@ output_constant_pool (fnname, fndecl)\n \t  if (GET_CODE (x) != CONST_DOUBLE)\n \t    abort ();\n \n-\t  bcopy (&CONST_DOUBLE_LOW (x), &u, sizeof u);\n+\t  bcopy ((char *) &CONST_DOUBLE_LOW (x), (char *) &u, sizeof u);\n \t  assemble_real (u.d, pool->mode);\n \t  break;\n "}]}