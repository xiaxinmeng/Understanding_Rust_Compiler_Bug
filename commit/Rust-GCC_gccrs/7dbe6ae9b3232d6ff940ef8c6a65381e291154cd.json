{"sha": "7dbe6ae9b3232d6ff940ef8c6a65381e291154cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RiZTZhZTliMzIzMmQ2ZmY5NDBlZjhjNmE2NTM4MWUyOTExNTRjZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-11-27T14:42:54Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-11-27T14:42:54Z"}, "message": "Re-apply an earlier fix, with a small update\n\nFrom-SVN: r37794", "tree": {"sha": "6d154dfc6c0730c4f7ae41a405ed947c335379a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d154dfc6c0730c4f7ae41a405ed947c335379a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dbe6ae9b3232d6ff940ef8c6a65381e291154cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dbe6ae9b3232d6ff940ef8c6a65381e291154cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dbe6ae9b3232d6ff940ef8c6a65381e291154cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dbe6ae9b3232d6ff940ef8c6a65381e291154cd/comments", "author": null, "committer": null, "parents": [{"sha": "76e57b458976f18172c6e0ac1cffea3e6b6a1e24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76e57b458976f18172c6e0ac1cffea3e6b6a1e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76e57b458976f18172c6e0ac1cffea3e6b6a1e24"}], "stats": {"total": 41, "additions": 26, "deletions": 15}, "files": [{"sha": "6e8fd8984dc31f3784ccd9f14b9976bb6ba4fb43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbe6ae9b3232d6ff940ef8c6a65381e291154cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbe6ae9b3232d6ff940ef8c6a65381e291154cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7dbe6ae9b3232d6ff940ef8c6a65381e291154cd", "patch": "@@ -12,6 +12,11 @@\n \thtab_find_slot_with_hash.\n \t(cselib_lookup): Likewise.\n \n+\tBased on a patch from Geoff Keating <geoffk@redhat.com>:\n+\t* loop.c (basic_induction_var): If a REG is set from something\n+\tthat is not a biv, then the REG is not a biv.  Even if it is\n+\tearlier set from something that is a biv.\n+\n 2000-11-27  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* configure.in (extra_objs): Enclose extra_headers in quotes."}, {"sha": "7b4fd319168297c51e4a5b2f0283c2c90327dd03", "filename": "gcc/loop.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbe6ae9b3232d6ff940ef8c6a65381e291154cd/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbe6ae9b3232d6ff940ef8c6a65381e291154cd/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=7dbe6ae9b3232d6ff940ef8c6a65381e291154cd", "patch": "@@ -5467,6 +5467,7 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val, location)\n       insn = p;\n       while (1)\n \t{\n+\t  rtx dest;\n \t  do\n \t    {\n \t      insn = PREV_INSN (insn);\n@@ -5479,21 +5480,26 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val, location)\n \t  set = single_set (insn);\n \t  if (set == 0)\n \t    break;\n-\n-\t  if ((SET_DEST (set) == x\n-\t       || (GET_CODE (SET_DEST (set)) == SUBREG\n-\t\t   && (GET_MODE_SIZE (GET_MODE (SET_DEST (set)))\n-\t\t       <= UNITS_PER_WORD)\n-\t\t   && (GET_MODE_CLASS (GET_MODE (SET_DEST (set)))\n-\t\t       == MODE_INT)\n-\t\t   && SUBREG_REG (SET_DEST (set)) == x))\n-\t      && basic_induction_var (loop, SET_SRC (set),\n-\t\t\t\t      (GET_MODE (SET_SRC (set)) == VOIDmode\n-\t\t\t\t       ? GET_MODE (x)\n-\t\t\t\t       : GET_MODE (SET_SRC (set))),\n-\t\t\t\t      dest_reg, insn,\n-\t\t\t\t      inc_val, mult_val, location))\n-\t    return 1;\n+\t  dest = SET_DEST (set);\n+\t  if (dest == x\n+\t      || (GET_CODE (dest) == SUBREG\n+\t\t  && (GET_MODE_SIZE (GET_MODE (dest)) <= UNITS_PER_WORD)\n+\t\t  && (GET_MODE_CLASS (GET_MODE (dest)) == MODE_INT)\n+\t\t  && SUBREG_REG (dest) == x))\n+\t    return basic_induction_var (loop, SET_SRC (set),\n+\t\t\t\t\t(GET_MODE (SET_SRC (set)) == VOIDmode\n+\t\t\t\t\t ? GET_MODE (x)\n+\t\t\t\t\t : GET_MODE (SET_SRC (set))),\n+\t\t\t\t\tdest_reg, insn,\n+\t\t\t\t\tinc_val, mult_val, location);\n+\n+\t  while (GET_CODE (dest) == SIGN_EXTRACT\n+\t\t || GET_CODE (dest) == ZERO_EXTRACT\n+\t\t || GET_CODE (dest) == SUBREG\n+\t\t || GET_CODE (dest) == STRICT_LOW_PART)\n+\t    dest = XEXP (dest, 0);\n+\t  if (dest == x)\n+\t    break;\n \t}\n       /* Fall through.  */\n "}]}