{"sha": "90ea9897a0940659bc41355d41573fde6c35617a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBlYTk4OTdhMDk0MDY1OWJjNDEzNTVkNDE1NzNmZGU2YzM1NjE3YQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-07-14T15:34:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-14T15:34:30Z"}, "message": "cp-tree.h (IDENTIFIER_VALUE): Remove.\n\n\t* cp-tree.h (IDENTIFIER_VALUE): Remove.\n\t(BINFO_PUSHDECLS_MARKED): Likewise.\n\t(maybe_inject_for_scope_var): Likewise.\n\t(push_class_decls): Likewise.\n\t* name-lookup.h (push_class_binding): Remove.\n\t(innermost_non_namespace_value): New function.\n\t(outer_binding): Likewise.\n\t* class.c (add_method): Push bindings before adding to\n\tTYPE_METHODS.\n\t(restore_class_cache): Do not restore class_shadowed.\n\t(pushclass): Do not add USING_DECLs.  Do not call\n\tpush_class_decls.\n\t* config-lang.in (gtfiles): Remove $(srcdir)/cp/search.c.\n\t* decl.c (pushdecl): Use outer_binding.\n\t(poplevel): Set the scope for an out-of-scope for-loop declaration\n\tappropriately.\n\t(cp_finish_decl): Don't call maybe_inject_for_scope_var.\n\t* name-lookup.c (new_class_binding): New function.\n\t(push_binding): Use it.\n\t(pushdecl): Use innermost_non_namespace_value.\n\t(maybe_inject_for_scope_var): Remove.\n\t(push_class_binding): Remove.\n\t(set_inherited_value_binding_p): New function.\n\t(get_class_binding): New function.\n\t(push_class_level_binding): Assert that the current_class_type is\n\tbeing defined.\n\t(outer_binding): New function.\n\t(innermost_non_namespace_value): Likewise.\n\t(lookup_name_real): Use outer_binding.\n\t(lookup_name_current_level): Ignore out-of-scope variables.\n\t* pt.c (check_template_shadow): Use innermost_non_namespace_value.\n\t(lookup_template_class): Likewise.\n\t* search.c (dfs_push_type_decls): Remove.\n\t(dfs_push_decls): Likewise.\n\t(setup_class_bindings): Likewise.\n\t(lookup_field_1): Handle USING_DECLs from dependent scopes.\n\t(marked_pushdecls_p): Remove.\n\t(unmarked_pushdecls_p): Remove.\n\t(marked_identifiers): Remove.\n\t(setup_class_bindings): Remove.\n\t(dfs_push_type_decls): Remove.\n\t(dfs_push_decls): Remove.\n\t(push_class_decls): Remove.\n\nFrom-SVN: r84689", "tree": {"sha": "5c6490013ea86502c34dbabd84c9be78d2ebd025", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c6490013ea86502c34dbabd84c9be78d2ebd025"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90ea9897a0940659bc41355d41573fde6c35617a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90ea9897a0940659bc41355d41573fde6c35617a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90ea9897a0940659bc41355d41573fde6c35617a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90ea9897a0940659bc41355d41573fde6c35617a/comments", "author": null, "committer": null, "parents": [{"sha": "95674810682ca0c2862094c96cdfa5537113693c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95674810682ca0c2862094c96cdfa5537113693c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95674810682ca0c2862094c96cdfa5537113693c"}], "stats": {"total": 816, "additions": 371, "deletions": 445}, "files": [{"sha": "df264d901e752b2a3bb8e2dc61b6ab95c2e53c68", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=90ea9897a0940659bc41355d41573fde6c35617a", "patch": "@@ -1,3 +1,49 @@\n+2004-07-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (IDENTIFIER_VALUE): Remove.\n+\t(BINFO_PUSHDECLS_MARKED): Likewise.\n+\t(maybe_inject_for_scope_var): Likewise.\n+\t(push_class_decls): Likewise.\n+\t* name-lookup.h (push_class_binding): Remove.\n+\t(innermost_non_namespace_value): New function.\n+\t(outer_binding): Likewise.\n+\t* class.c (add_method): Push bindings before adding to\n+\tTYPE_METHODS.\n+\t(restore_class_cache): Do not restore class_shadowed.\n+\t(pushclass): Do not add USING_DECLs.  Do not call\n+\tpush_class_decls.\n+\t* config-lang.in (gtfiles): Remove $(srcdir)/cp/search.c.\n+\t* decl.c (pushdecl): Use outer_binding.\n+\t(poplevel): Set the scope for an out-of-scope for-loop declaration\n+\tappropriately.\n+\t(cp_finish_decl): Don't call maybe_inject_for_scope_var.\n+\t* name-lookup.c (new_class_binding): New function.\n+\t(push_binding): Use it.\n+\t(pushdecl): Use innermost_non_namespace_value.\n+\t(maybe_inject_for_scope_var): Remove.\n+\t(push_class_binding): Remove.\n+\t(set_inherited_value_binding_p): New function.\n+\t(get_class_binding): New function.\n+\t(push_class_level_binding): Assert that the current_class_type is\n+\tbeing defined.\n+\t(outer_binding): New function.\n+\t(innermost_non_namespace_value): Likewise.\n+\t(lookup_name_real): Use outer_binding.\n+\t(lookup_name_current_level): Ignore out-of-scope variables.\n+\t* pt.c (check_template_shadow): Use innermost_non_namespace_value.\n+\t(lookup_template_class): Likewise.\n+\t* search.c (dfs_push_type_decls): Remove.\n+\t(dfs_push_decls): Likewise.\n+\t(setup_class_bindings): Likewise.\n+\t(lookup_field_1): Handle USING_DECLs from dependent scopes.\n+\t(marked_pushdecls_p): Remove.\n+\t(unmarked_pushdecls_p): Remove.\n+\t(marked_identifiers): Remove.\n+\t(setup_class_bindings): Remove.\n+\t(dfs_push_type_decls): Remove.\n+\t(dfs_push_decls): Remove.\n+\t(push_class_decls): Remove.\n+\t\n 2004-07-13  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/16518"}, {"sha": "b292255fd135f0e786fd71c80bade38afd643420", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=90ea9897a0940659bc41355d41573fde6c35617a", "patch": "@@ -807,6 +807,7 @@ add_method (tree type, tree method, int error_p)\n   int len;\n   int slot;\n   tree method_vec;\n+  tree overload;\n   int template_conv_p;\n \n   if (method == error_mark_node)\n@@ -1025,15 +1026,14 @@ add_method (tree type, tree method, int error_p)\n \t}\n     }\n \n-  /* Actually insert the new method.  */\n-  TREE_VEC_ELT (method_vec, slot) \n-    = build_overload (method, TREE_VEC_ELT (method_vec, slot));\n-\n   /* Add the new binding.  */ \n+  overload = build_overload (method, TREE_VEC_ELT (method_vec, slot));\n   if (!DECL_CONSTRUCTOR_P (method)\n       && !DECL_DESTRUCTOR_P (method))\n-    push_class_level_binding (DECL_NAME (method),\n-\t\t\t      TREE_VEC_ELT (method_vec, slot));\n+    push_class_level_binding (DECL_NAME (method), overload);\n+\n+  /* Actually insert the new method.  */\n+  TREE_VEC_ELT (method_vec, slot) = overload;\n }\n \n /* Subroutines of finish_struct.  */\n@@ -5484,28 +5484,14 @@ init_class_processing (void)\n static void\n restore_class_cache (void)\n {\n-  cp_class_binding *cb;\n   tree type;\n-  size_t i;\n \n   /* We are re-entering the same class we just left, so we don't\n      have to search the whole inheritance matrix to find all the\n      decls to bind again.  Instead, we install the cached\n      class_shadowed list and walk through it binding names.  */\n   push_binding_level (previous_class_level);\n   class_binding_level = previous_class_level;\n-  for (i = 0; \n-       (cb = VEC_iterate (cp_class_binding, \n-\t\t\t  previous_class_level->class_shadowed,\n-\t\t\t  i));\n-       ++i)\n-    {\n-      tree id;\n-\n-      id = cb->identifier;\n-      cb->base.previous = IDENTIFIER_BINDING (id);\n-      IDENTIFIER_BINDING (id) = &cb->base;\n-    }\n   /* Restore IDENTIFIER_TYPE_VALUE.  */\n   for (type = class_binding_level->type_shadowed; \n        type; \n@@ -5567,22 +5553,7 @@ pushclass (tree type)\n   if (!previous_class_level \n       || type != previous_class_level->this_entity\n       || current_class_depth > 1)\n-    {\n-      pushlevel_class ();\n-      push_class_decls (type);\n-      if (CLASSTYPE_TEMPLATE_INFO (type) && !CLASSTYPE_USE_TEMPLATE (type))\n-\t{\n-\t  /* If we are entering the scope of a template declaration (not a\n-\t     specialization), we need to push all the using decls with\n-\t     dependent scope too.  */\n-\t  tree fields;\n-\n-\t  for (fields = TYPE_FIELDS (type);\n-\t       fields; fields = TREE_CHAIN (fields))\n-\t    if (TREE_CODE (fields) == USING_DECL && !TREE_TYPE (fields))\n-\t      pushdecl_class_level (fields);\n-\t}\n-    }\n+    pushlevel_class ();\n   else\n     restore_class_cache ();\n   "}, {"sha": "563cfb4d1c02e231aa64b30b0c29deca53827336", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=90ea9897a0940659bc41355d41573fde6c35617a", "patch": "@@ -34,4 +34,4 @@ stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n target_libs=\"target-libstdc++-v3 target-gperf\"\n \n-gtfiles=\"\\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/search.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c\"\n+gtfiles=\"\\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c\""}, {"sha": "95c633a1f422bd3e50541b62b695ced8939d1d96", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=90ea9897a0940659bc41355d41573fde6c35617a", "patch": "@@ -334,11 +334,6 @@ typedef enum cp_id_kind\n #define IDENTIFIER_BINDING(NODE) \\\n   (LANG_IDENTIFIER_CAST (NODE)->bindings)\n \n-/* The IDENTIFIER_VALUE is the value of the IDENTIFIER_BINDING, or\n-   NULL_TREE if there is no binding.  */\n-#define IDENTIFIER_VALUE(NODE)\t\t\t\\\n-  (IDENTIFIER_BINDING (NODE) ? IDENTIFIER_BINDING (NODE)->value : NULL)\n-\n /* TREE_TYPE only indicates on local and class scope the current\n    type. For namespace scope, the presence of a type in any namespace\n    is indicated with global_type_node, and the real type behind must\n@@ -1388,9 +1383,6 @@ struct lang_type GTY(())\n    my_friendly_assert (CLASSTYPE_VFIELDS (BINFO_TYPE (B)) != NULL_TREE,  \\\n \t\t       20000517))\n \n-/* Nonzero means this class has done dfs_pushdecls.  */\n-#define BINFO_PUSHDECLS_MARKED(NODE) BINFO_VTABLE_PATH_MARKED (NODE)\n-\n /* Nonzero if this BINFO is a primary base class.  */\n \n #define BINFO_PRIMARY_P(NODE) \\\n@@ -3708,7 +3700,6 @@ extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int,\n extern void start_decl_1\t\t\t(tree);\n extern void cp_finish_decl\t\t\t(tree, tree, tree, int);\n extern void finish_decl\t\t\t\t(tree, tree, tree);\n-extern void maybe_inject_for_scope_var          (tree);\n extern int complete_array_type\t\t\t(tree, tree, int);\n extern tree build_ptrmemfunc_type\t\t(tree);\n extern tree build_ptrmem_type                   (tree, tree);\n@@ -4003,7 +3994,6 @@ extern int look_for_overrides\t\t\t(tree, tree);\n extern void get_pure_virtuals\t\t        (tree);\n extern void maybe_suppress_debug_info\t\t(tree);\n extern void note_debug_info_needed\t\t(tree);\n-extern void push_class_decls\t\t\t(tree);\n extern void print_search_statistics\t\t(void);\n extern void reinit_search_statistics\t\t(void);\n extern tree current_scope\t\t\t(void);"}, {"sha": "727734347d23d49fffb8bbf6062f33a505c73523", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=90ea9897a0940659bc41355d41573fde6c35617a", "patch": "@@ -540,27 +540,28 @@ poplevel (int keep, int reverse, int functionbody)\n       if (leaving_for_scope && TREE_CODE (link) == VAR_DECL\n           && DECL_NAME (link))\n \t{\n-\t  cxx_binding *outer_binding\n-\t    = IDENTIFIER_BINDING (DECL_NAME (link))->previous;\n+\t  tree name = DECL_NAME (link);\n+\t  cxx_binding *ob;\n \t  tree ns_binding;\n \n-\t  if (!outer_binding)\n-\t    ns_binding = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (link));\n+\t  ob = outer_binding (name,\n+\t\t\t      IDENTIFIER_BINDING (name),\n+\t\t\t      /*class_p=*/true);\n+\t  if (!ob)\n+\t    ns_binding = IDENTIFIER_NAMESPACE_VALUE (name);\n \t  else\n \t    ns_binding = NULL_TREE;\n \n-\t  if (outer_binding\n-\t      && outer_binding->scope == current_binding_level->level_chain)\n+\t  if (ob && ob->scope == current_binding_level->level_chain)\n \t    /* We have something like:\n \n \t         int i;\n \t         for (int i; ;);\n \n \t       and we are leaving the `for' scope.  There's no reason to\n \t       keep the binding of the inner `i' in this case.  */\n-\t    pop_binding (DECL_NAME (link), link);\n-\t  else if ((outer_binding\n-\t\t    && (TREE_CODE (outer_binding->value) == TYPE_DECL))\n+\t    pop_binding (name, link);\n+\t  else if ((ob && (TREE_CODE (ob->value) == TYPE_DECL))\n \t\t   || (ns_binding && TREE_CODE (ns_binding) == TYPE_DECL))\n \t    /* Here, we have something like:\n \n@@ -572,7 +573,7 @@ poplevel (int keep, int reverse, int functionbody)\n \n \t       We must pop the for-scope binding so we know what's a\n \t       type and what isn't.  */\n-\t    pop_binding (DECL_NAME (link), link);\n+\t    pop_binding (name, link);\n \t  else\n \t    {\n \t      /* Mark this VAR_DECL as dead so that we can tell we left it\n@@ -581,8 +582,8 @@ poplevel (int keep, int reverse, int functionbody)\n \n \t      /* Keep track of what should have happened when we\n \t\t popped the binding.  */\n-\t      if (outer_binding && outer_binding->value)\n-\t\tDECL_SHADOWED_FOR_VAR (link) = outer_binding->value;\n+\t      if (ob && ob->value)\n+\t\tDECL_SHADOWED_FOR_VAR (link) = ob->value;\n \n \t      /* Add it to the list of dead variables in the next\n \t\t outermost binding to that we can remove these when we\n@@ -594,7 +595,8 @@ poplevel (int keep, int reverse, int functionbody)\n \n \t      /* Although we don't pop the cxx_binding, we do clear\n \t\t its SCOPE since the scope is going away now.  */\n-\t      IDENTIFIER_BINDING (DECL_NAME (link))->scope = NULL;\n+\t      IDENTIFIER_BINDING (name)->scope \n+\t\t= current_binding_level->level_chain;\n \t    }\n \t}\n       else\n@@ -4846,8 +4848,6 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t  /* A variable definition.  */\n \t  if (DECL_FUNCTION_SCOPE_P (decl))\n \t    {\n-\t      /* This is a local declaration.  */\n-\t      maybe_inject_for_scope_var (decl);\n \t      /* Initialize the local variable.  */\n \t      if (processing_template_decl)\n \t\t{"}, {"sha": "0aff14b999cafb506b33792734c7af79ab8c4aea", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 278, "deletions": 160, "changes": 438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=90ea9897a0940659bc41355d41573fde6c35617a", "patch": "@@ -368,40 +368,65 @@ cxx_binding_free (cxx_binding *binding)\n   free_bindings = binding;\n }\n \n-/* Make DECL the innermost binding for ID.  The LEVEL is the binding\n-   level at which this declaration is being bound.  */\n+/* Create a new binding for NAME (with the indicated VALUE and TYPE\n+   bindings) in the class scope indicated by SCOPE.  */\n \n-static void\n-push_binding (tree id, tree decl, cxx_scope* level)\n+static cxx_binding *\n+new_class_binding (tree name, tree value, tree type, cxx_scope *scope)\n {\n+  cp_class_binding *cb;\n   cxx_binding *binding;\n-\n-  if (level != class_binding_level)\n-    binding = cxx_binding_make (decl, NULL_TREE);\n-  else\n+  \n+  if (VEC_length (cp_class_binding, scope->class_shadowed))\n     {\n-      cp_class_binding *cb;\n-\n-      if (VEC_reserve (cp_class_binding, level->class_shadowed, -1))\n+      cp_class_binding *old_base;\n+      old_base = VEC_index (cp_class_binding, scope->class_shadowed, 0);\n+      if (VEC_reserve (cp_class_binding, scope->class_shadowed, -1))\n \t{\n \t  /* Fixup the current bindings, as they might have moved.  */\n \t  size_t i;\n \t  \n \t  for (i = 0;\n-\t       (cb = VEC_iterate (cp_class_binding, level->class_shadowed, i));\n+\t       (cb = VEC_iterate (cp_class_binding, scope->class_shadowed, i));\n \t       i++)\n-\t    IDENTIFIER_BINDING (cb->identifier) = &cb->base;\n+\t    {\n+\t      cxx_binding **b;\n+\t      b = &IDENTIFIER_BINDING (cb->identifier);\n+\t      while (*b != &old_base[i].base)\n+\t\tb = &((*b)->previous);\n+\t      *b = &cb->base;\n+\t    }\n \t}\n+      cb = VEC_quick_push (cp_class_binding, scope->class_shadowed, NULL);\n+    }\n+  else\n+    cb = VEC_safe_push (cp_class_binding, scope->class_shadowed, NULL);\n+  \n+  cb->identifier = name;\n+  binding = &cb->base;\n+  binding->scope = scope;\n+  cxx_binding_init (binding, value, type);\n+  return binding;\n+}\n+\n+/* Make DECL the innermost binding for ID.  The LEVEL is the binding\n+   level at which this declaration is being bound.  */\n+\n+static void\n+push_binding (tree id, tree decl, cxx_scope* level)\n+{\n+  cxx_binding *binding;\n \n-      cb = VEC_quick_push (cp_class_binding, level->class_shadowed, NULL);\n-      cb->identifier = id;\n-      binding = &cb->base;\n-      cxx_binding_init (binding, decl, NULL_TREE);\n+  if (level != class_binding_level)\n+    {\n+      binding = cxx_binding_make (decl, NULL_TREE);\n+      binding->scope = level;\n     }\n+  else\n+    binding = new_class_binding (id, decl, /*type=*/NULL_TREE, level);\n \t\t\t      \n   /* Now, fill in the binding information.  */\n   binding->previous = IDENTIFIER_BINDING (id);\n-  binding->scope = level;\n   INHERITED_VALUE_BINDING_P (binding) = 0;\n   LOCAL_BINDING_P (binding) = (level != class_binding_level);\n \n@@ -665,7 +690,7 @@ pushdecl (tree x)\n \t  && DECL_EXTERNAL (x))\n \t{\n \t  /* Look in block scope.  */\n-\t  t = IDENTIFIER_VALUE (name);\n+\t  t = innermost_non_namespace_value (name);\n \t  /* Or in the innermost namespace.  */\n \t  if (! t)\n \t    t = namespace_binding (name, DECL_CONTEXT (x));\n@@ -893,7 +918,7 @@ pushdecl (tree x)\n       else\n \t{\n \t  /* Here to install a non-global value.  */\n-\t  tree oldlocal = IDENTIFIER_VALUE (name);\n+\t  tree oldlocal = innermost_non_namespace_value (name);\n \t  tree oldglobal = IDENTIFIER_NAMESPACE_VALUE (name);\n \n \t  if (need_new_binding)\n@@ -1113,59 +1138,6 @@ push_local_binding (tree id, tree decl, int flags)\n   add_decl_to_level (decl, b);\n }\n \n-/* The old ARM scoping rules injected variables declared in the\n-   initialization statement of a for-statement into the surrounding\n-   scope.  We support this usage, in order to be backward-compatible.\n-   DECL is a just-declared VAR_DECL; if necessary inject its\n-   declaration into the surrounding scope.  */\n-\n-void\n-maybe_inject_for_scope_var (tree decl)\n-{\n-  timevar_push (TV_NAME_LOOKUP);\n-  if (!DECL_NAME (decl))\n-    {\n-      timevar_pop (TV_NAME_LOOKUP);\n-      return;\n-    }\n-  \n-  /* Declarations of __FUNCTION__ and its ilk appear magically when\n-     the variable is first used.  If that happens to be inside a\n-     for-loop, we don't want to do anything special.  */\n-  if (DECL_PRETTY_FUNCTION_P (decl))\n-    {\n-      timevar_pop (TV_NAME_LOOKUP);\n-      return;\n-    }\n-\n-  if (current_binding_level->kind == sk_for)\n-    {\n-      struct cp_binding_level *outer\n-\t= current_binding_level->level_chain;\n-\n-      /* Check to see if the same name is already bound at the outer\n-\t level, either because it was directly declared, or because a\n-\t dead for-decl got preserved.  In either case, the code would\n-\t not have been valid under the ARM scope rules, so clear\n-\t is_for_scope for the current_binding_level.\n-\n-\t Otherwise, we need to preserve the temp slot for decl to last\n-\t into the outer binding level.  */\n-\n-      cxx_binding *outer_binding\n-\t= IDENTIFIER_BINDING (DECL_NAME (decl))->previous;\n-\n-      if (outer_binding && outer_binding->scope == outer\n-\t  && (TREE_CODE (outer_binding->value) == VAR_DECL)\n-\t  && DECL_DEAD_FOR_LOCAL (outer_binding->value))\n-\t{\n-\t  outer_binding->value = DECL_SHADOWED_FOR_VAR (outer_binding->value);\n-\t  current_binding_level->kind = sk_block;\n-\t}\n-    }\n-  timevar_pop (TV_NAME_LOOKUP);\n-}\n-\n /* Check to see whether or not DECL is a variable that would have been\n    in scope under the ARM, but is not in scope under the ANSI/ISO\n    standard.  If so, issue an error message.  If name lookup would\n@@ -2647,10 +2619,15 @@ poplevel_class (void)\n     SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (shadowed), TREE_VALUE (shadowed));\n \n   /* Remove the bindings for all of the class-level declarations.  */\n-  for (i = 0;\n-       (cb = VEC_iterate (cp_class_binding, level->class_shadowed, i));\n-       ++i)\n-    IDENTIFIER_BINDING (cb->identifier) = cb->base.previous;\n+  if (level->class_shadowed)\n+    {\n+      for (i = 0;\n+\t   (cb = VEC_iterate (cp_class_binding, level->class_shadowed, i));\n+\t   ++i)\n+\tIDENTIFIER_BINDING (cb->identifier) = cb->base.previous;\n+      ggc_free (level->class_shadowed);\n+      level->class_shadowed = NULL;\n+    }\n \n   /* Now, pop out of the binding level which we created up in the\n      `pushlevel_class' routine.  */\n@@ -2661,33 +2638,17 @@ poplevel_class (void)\n   timevar_pop (TV_NAME_LOOKUP);\n }\n \n-/* Bind DECL to ID in the class_binding_level.  Returns nonzero if the\n-   binding was successful.  */\n+/* Set INHERITED_VALUE_BINDING_P on BINDING to true or false, as\n+   appropriate.  DECL is the value to which a name has just been\n+   bound.  */\n \n-int\n-push_class_binding (tree id, tree decl)\n+static void\n+set_inherited_value_binding_p (cxx_binding *binding, tree decl)\n {\n-  int result = 1;\n-  cxx_binding *binding = IDENTIFIER_BINDING (id);\n-  tree context;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  /* Note that we declared this value so that we can issue an error if\n-     this is an invalid redeclaration of a name already used for some\n-     other purpose.  */\n-  note_name_declared_in_class (id, decl);\n-\n-  if (binding && binding->scope == class_binding_level)\n-    /* Supplement the existing binding.  */\n-    result = supplement_binding (IDENTIFIER_BINDING (id), decl);\n-  else\n-    /* Create a new binding.  */\n-    push_binding (id, decl, class_binding_level);\n-\n-  /* If this is a binding from a base class, mark it as such.  */\n-  binding = IDENTIFIER_BINDING (id);\n   if (binding->value == decl && TREE_CODE (decl) != TREE_LIST)\n     {\n+      tree context;\n+\n       if (TREE_CODE (decl) == OVERLOAD)\n \tcontext = CP_DECL_CONTEXT (OVL_CURRENT (decl));\n       else\n@@ -2702,12 +2663,12 @@ push_class_binding (tree id, tree decl)\n \tINHERITED_VALUE_BINDING_P (binding) = 0;\n     }\n   else if (binding->value == decl)\n-    /* We only encounter a TREE_LIST when push_class_decls detects an\n-       ambiguity.  Such an ambiguity can be overridden by a definition\n-       in this class.  */\n+    /* We only encounter a TREE_LIST when there is an ambiguity in the\n+       base classes.  Such an ambiguity can be overridden by a\n+       definition in this class.  */\n     INHERITED_VALUE_BINDING_P (binding) = 1;\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result);\n+  else\n+    INHERITED_VALUE_BINDING_P (binding) = 0;\n }\n \n /* Make the declaration of X appear in CLASS scope.  */\n@@ -2752,78 +2713,146 @@ pushdecl_class_level (tree x)\n   return is_valid;\n }\n \n+/* Return the BINDING (if any) for NAME in SCOPE, which is a class\n+   scope.  If the value returned is non-NULL, and the PREVIOUS field\n+   is not set, callers must set the PREVIOUS field explicitly.  */\n+\n+static cxx_binding *\n+get_class_binding (tree name, cxx_scope *scope)\n+{\n+  tree class_type;\n+  tree type_binding;\n+  tree value_binding;\n+  cxx_binding *binding;\n+\n+  class_type = scope->this_entity;\n+\n+  /* Get the type binding.  */\n+  type_binding = lookup_member (class_type, name,\n+\t\t\t\t/*protect=*/2, /*want_type=*/true);\n+  /* Get the value binding.  */\n+  value_binding = lookup_member (class_type, name,\n+\t\t\t\t /*protect=*/2, /*want_type=*/false);\n+\n+  if (value_binding\n+      && (TREE_CODE (value_binding) == TYPE_DECL\n+\t  || DECL_CLASS_TEMPLATE_P (value_binding)\n+\t  || (TREE_CODE (value_binding) == TREE_LIST\n+\t      && TREE_TYPE (value_binding) == error_mark_node\n+\t      && (TREE_CODE (TREE_VALUE (value_binding))\n+\t\t  == TYPE_DECL))))\n+    /* We found a type binding, even when looking for a non-type\n+       binding.  This means that we already processed this binding\n+       above.  */\n+    ;\n+  else if (value_binding)\n+    {\n+      if (TREE_CODE (value_binding) == TREE_LIST \n+\t  && TREE_TYPE (value_binding) == error_mark_node)\n+\t/* NAME is ambiguous.  */\n+\t;\n+      else if (BASELINK_P (value_binding))\n+\t/* NAME is some overloaded functions.  */\n+\tvalue_binding = BASELINK_FUNCTIONS (value_binding);\n+    }\n+\n+  /* If we found either a type binding or a value binding, create a\n+     new binding object.  */\n+  if (type_binding || value_binding)\n+    {\n+      binding = new_class_binding (name, \n+\t\t\t\t   value_binding, \n+\t\t\t\t   type_binding,\n+\t\t\t\t   scope);\n+      /* This is a class-scope binding, not a block-scope binding.  */\n+      LOCAL_BINDING_P (binding) = 0;\n+      set_inherited_value_binding_p (binding, value_binding);\n+    }\n+  else\n+    binding = NULL;\n+\n+  return binding;\n+}\n+\t\t   \n /* Make the declaration(s) of X appear in CLASS scope under the name\n    NAME.  Returns true if the binding is valid.  */\n \n bool\n push_class_level_binding (tree name, tree x)\n {\n   cxx_binding *binding;\n+  tree decl = x;\n+  bool ok;\n \n   timevar_push (TV_NAME_LOOKUP);\n   /* The class_binding_level will be NULL if x is a template\n      parameter name in a member template.  */\n   if (!class_binding_level)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \n-  /* Check for invalid member names, if the class is being defined.\n-     This function is also used to restore bindings when reentering\n-     the class scope, and there is no point in checking again at that\n-     time.  */\n-  if (TYPE_BEING_DEFINED (current_class_type))\n-    {\n-      tree decl = x;\n-\n-      /* We could have been passed a tree list if this is an ambiguous\n-\t declaration. If so, pull the declaration out because\n-\t check_template_shadow will not handle a TREE_LIST. */\n-      if (TREE_CODE (decl) == TREE_LIST \n-\t  && TREE_TYPE (decl) == error_mark_node)\n-\tdecl = TREE_VALUE (decl);\n-      \n-      check_template_shadow (decl);\n+  /* Check for invalid member names.  */\n+  my_friendly_assert (TYPE_BEING_DEFINED (current_class_type), 20040713);\n+  /* We could have been passed a tree list if this is an ambiguous\n+     declaration. If so, pull the declaration out because\n+     check_template_shadow will not handle a TREE_LIST. */\n+  if (TREE_CODE (decl) == TREE_LIST \n+      && TREE_TYPE (decl) == error_mark_node)\n+    decl = TREE_VALUE (decl);\n \n-      /* [class.mem]\n+  check_template_shadow (decl);\n \n-\t If T is the name of a class, then each of the following shall\n-\t have a name different from T:\n+  /* [class.mem]\n \n-\t -- every static data member of class T;\n+     If T is the name of a class, then each of the following shall\n+     have a name different from T:\n \n-\t -- every member of class T that is itself a type;\n+     -- every static data member of class T;\n \n-\t -- every enumerator of every member of class T that is an\n-\t    enumerated type;\n+     -- every member of class T that is itself a type;\n \n-\t -- every member of every anonymous union that is a member of\n-\t    class T.\n+     -- every enumerator of every member of class T that is an\n+\tenumerated type;\n \n-\t (Non-static data members were also forbidden to have the same\n-\t name as T until TC1.)  */\n-      if ((TREE_CODE (x) == VAR_DECL\n-\t   || TREE_CODE (x) == CONST_DECL\n-\t   || (TREE_CODE (x) == TYPE_DECL\n-\t       && !DECL_SELF_REFERENCE_P (x))\n-\t   /* A data member of an anonymous union.  */\n-\t   || (TREE_CODE (x) == FIELD_DECL\n-\t       && DECL_CONTEXT (x) != current_class_type))\n-\t  && DECL_NAME (x) == constructor_name (current_class_type))\n+     -- every member of every anonymous union that is a member of\n+\tclass T.\n+\n+     (Non-static data members were also forbidden to have the same\n+     name as T until TC1.)  */\n+  if ((TREE_CODE (x) == VAR_DECL\n+       || TREE_CODE (x) == CONST_DECL\n+       || (TREE_CODE (x) == TYPE_DECL\n+\t   && !DECL_SELF_REFERENCE_P (x))\n+       /* A data member of an anonymous union.  */\n+       || (TREE_CODE (x) == FIELD_DECL\n+\t   && DECL_CONTEXT (x) != current_class_type))\n+      && DECL_NAME (x) == constructor_name (current_class_type))\n+    {\n+      tree scope = context_for_name_lookup (x);\n+      if (TYPE_P (scope) && same_type_p (scope, current_class_type))\n \t{\n-\t  tree scope = context_for_name_lookup (x);\n-\t  if (TYPE_P (scope) && same_type_p (scope, current_class_type))\n-\t    {\n-\t      error (\"`%D' has the same name as the class in which it is \"\n-\t\t     \"declared\",\n-\t\t     x);\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n-\t    }\n+\t  error (\"`%D' has the same name as the class in which it is \"\n+\t\t \"declared\",\n+\t\t x);\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n \t}\n     }\n \n-  /* If this declaration shadows a declaration from an enclosing\n-     class, then we will need to restore bindings when we leave this\n-     class.  Record the shadowed declaration here.  */\n+  /* Get the current binding for NAME in this class, if any.  */\n   binding = IDENTIFIER_BINDING (name);\n+  if (!binding || binding->scope != class_binding_level)\n+    {\n+      binding = get_class_binding (name, class_binding_level);\n+      /* If a new binding was created, put it at the front of the\n+\t IDENTIFIER_BINDING list.  */\n+      if (binding)\n+\t{\n+\t  binding->previous = IDENTIFIER_BINDING (name);\n+\t  IDENTIFIER_BINDING (name) = binding;\n+\t}\n+    }\n+\n+  /* If there is already a binding, then we may need to update the\n+     current value.  */\n   if (binding && binding->value)\n     {\n       tree bval = binding->value;\n@@ -2855,8 +2884,7 @@ push_class_level_binding (tree name, tree x)\n       else if (TREE_CODE (bval) == USING_DECL && is_overloaded_fn (x))\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \n-      if (old_decl\n-\t  && binding->scope == class_binding_level)\n+      if (old_decl && binding->scope == class_binding_level)\n \t{\n \t  binding->value = x;\n \t  /* It is always safe to clear INHERITED_VALUE_BINDING_P\n@@ -2872,12 +2900,29 @@ push_class_level_binding (tree name, tree x)\n \t}\n     }\n \n+  /* Note that we declared this value so that we can issue an error if\n+     this is an invalid redeclaration of a name already used for some\n+     other purpose.  */\n+  note_name_declared_in_class (name, decl);\n+\n   /* If we didn't replace an existing binding, put the binding on the\n-     stack of bindings for the identifier, and update the shadowed list.  */\n-  if (push_class_binding (name, x))\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+     stack of bindings for the identifier, and update the shadowed\n+     list.  */\n+  if (binding && binding->scope == class_binding_level)\n+    /* Supplement the existing binding.  */\n+    ok = supplement_binding (binding, decl);\n+  else\n+    {\n+      /* Create a new binding.  */\n+      push_binding (name, decl, class_binding_level);\n+      ok = true;\n+    }\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n+  /* Determine whether or not this binding is from a base class.  */\n+  binding = IDENTIFIER_BINDING (name);\n+  set_inherited_value_binding_p (binding, decl);\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ok);\n }\n \n tree\n@@ -3929,6 +3974,73 @@ qualified_lookup_using_namespace (tree name, tree scope,\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result->value != error_mark_node);\n }\n \n+/* Return the innermost non-namespace binding for NAME from a scope\n+   containing BINDING, or, if BINDING is NULL, the current scope.  If\n+   CLASS_P is false, then class bindings are ignored.  */\n+\n+cxx_binding *\n+outer_binding (tree name, \n+\t       cxx_binding *binding,\n+\t       bool class_p)\n+{\n+  cxx_binding *outer;\n+  cxx_scope *scope;\n+  cxx_scope *outer_scope;\n+\n+  if (binding)\n+    {\n+      scope = binding->scope->level_chain;\n+      outer = binding->previous;\n+    }\n+  else\n+    {\n+      scope = current_binding_level;\n+      outer = IDENTIFIER_BINDING (name);\n+    }\n+  outer_scope = outer ? outer->scope : NULL;\n+\n+  /* Because we create class bindings lazily, we might be missing a\n+     class binding for NAME.  If there are any class binding levels\n+     between the LAST_BINDING_LEVEL and the scope in which OUTER was\n+     declared, we must lookup NAME in those class scopes.  */\n+  if (class_p)\n+    while (scope && scope != outer_scope && scope->kind != sk_namespace)\n+      {\n+\tif (scope->kind == sk_class) \n+\t  {\n+\t    cxx_binding *class_binding;\n+\t    \n+\t    class_binding = get_class_binding (name, scope);\n+\t    if (class_binding)\n+\t      {\n+\t\t/* Thread this new class-scope binding onto the\n+\t\t   IDENTIFIER_BINDING list so that future lookups\n+\t\t   find it quickly.  */\n+\t\tclass_binding->previous = outer;\n+\t\tif (binding)\n+\t\t  binding->previous = class_binding;\n+\t\telse\n+\t\t  IDENTIFIER_BINDING (name) = class_binding;\n+\t\treturn class_binding;\n+\t      }\n+\t  }\n+\tscope = scope->level_chain;\n+      }\n+\n+  return outer;\n+}\n+\n+/* Return the innermost block-scope or class-scope value binding for\n+   NAME, or NULL_TREE if there is no such binding.  */\n+\n+tree\n+innermost_non_namespace_value (tree name)\n+{\n+  cxx_binding *binding;\n+  binding = outer_binding (name, /*binding=*/NULL, /*class_p=*/true);\n+  return binding ? binding->value : NULL_TREE;\n+}\n+\n /* Look up NAME in the current binding level and its superiors in the\n    namespace of variables, functions and typedefs.  Return a ..._DECL\n    node of some kind representing its definition if there is only one\n@@ -3987,7 +4099,9 @@ lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n     nonclass = 1;\n \n   if (block_p || !nonclass)\n-    for (iter = IDENTIFIER_BINDING (name); iter; iter = iter->previous)\n+    for (iter = outer_binding (name, NULL, !nonclass);\n+\t iter;\n+\t iter = outer_binding (name, iter, !nonclass))\n       {\n \ttree binding;\n \t\n@@ -4075,10 +4189,14 @@ lookup_name_current_level (tree name)\n   else if (IDENTIFIER_BINDING (name)\n \t   && LOCAL_BINDING_P (IDENTIFIER_BINDING (name)))\n     {\n+      cxx_binding *binding;\n+      binding = IDENTIFIER_BINDING (name);\n       while (1)\n \t{\n-\t  if (IDENTIFIER_BINDING (name)->scope == b)\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, IDENTIFIER_VALUE (name));\n+\t  if (binding->scope == b\n+\t      && !(TREE_CODE (binding->value) == VAR_DECL\n+\t\t   && DECL_DEAD_FOR_LOCAL (binding->value)))\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, binding->value);\n \n \t  if (b->kind == sk_cleanup)\n \t    b = b->level_chain;"}, {"sha": "892303b565f4022143e71fee577e128952566730", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=90ea9897a0940659bc41355d41573fde6c35617a", "patch": "@@ -310,7 +310,6 @@ extern tree lookup_qualified_name (tree, tree, bool, bool);\n extern tree lookup_name_nonclass (tree);\n extern tree lookup_function_nonclass (tree, tree, bool);\n extern void push_local_binding (tree, tree, int);\n-extern int push_class_binding (tree, tree);\n extern bool pushdecl_class_level (tree);\n extern tree pushdecl_namespace_level (tree);\n extern bool push_class_level_binding (tree, tree);\n@@ -329,7 +328,8 @@ extern void do_using_directive (tree);\n extern tree lookup_arg_dependent (tree, tree, tree);\n extern bool is_associated_namespace (tree, tree);\n extern void parse_using_directive (tree, tree);\n-\n+extern tree innermost_non_namespace_value (tree);\n+extern cxx_binding *outer_binding (tree, cxx_binding *, bool);\n \n /* Set *DECL to the (non-hidden) declaration for ID at global scope,\n    if present and return true; otherwise return false.  */"}, {"sha": "6dd3c6462125a9544d80e499c0ca8c5000ac83de", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=90ea9897a0940659bc41355d41573fde6c35617a", "patch": "@@ -2075,7 +2075,7 @@ check_template_shadow (tree decl)\n   /* Figure out what we're shadowing.  */\n   if (TREE_CODE (decl) == OVERLOAD)\n     decl = OVL_CURRENT (decl);\n-  olddecl = IDENTIFIER_VALUE (DECL_NAME (decl));\n+  olddecl = innermost_non_namespace_value (DECL_NAME (decl));\n \n   /* If there's no previous binding for this name, we're not shadowing\n      anything, let alone a template parameter.  */\n@@ -4156,9 +4156,9 @@ lookup_template_class (tree d1,\n   \n   if (TREE_CODE (d1) == IDENTIFIER_NODE)\n     {\n-      if (IDENTIFIER_VALUE (d1) \n-\t  && DECL_TEMPLATE_TEMPLATE_PARM_P (IDENTIFIER_VALUE (d1)))\n-\ttemplate = IDENTIFIER_VALUE (d1);\n+      tree value = innermost_non_namespace_value (d1);\n+      if (value && DECL_TEMPLATE_TEMPLATE_PARM_P (value))\n+\ttemplate = value;\n       else\n \t{\n \t  if (context)\n@@ -4200,11 +4200,7 @@ lookup_template_class (tree d1,\n       context = DECL_CONTEXT (template);\n     }\n \n-  /* With something like `template <class T> class X class X { ... };'\n-     we could end up with D1 having nothing but an IDENTIFIER_VALUE.\n-     We don't want to do that, but we have to deal with the situation,\n-     so let's give them some syntax errors to chew on instead of a\n-     crash. Alternatively D1 might not be a template type at all.  */\n+  /* Issue an error message if we didn't find a template.  */\n   if (! template)\n     {\n       if (complain & tf_error)"}, {"sha": "506c581e86d441989430c23ec0e3392e92b6ab25", "filename": "gcc/cp/search.c", "status": "modified", "additions": 17, "deletions": 212, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ea9897a0940659bc41355d41573fde6c35617a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=90ea9897a0940659bc41355d41573fde6c35617a", "patch": "@@ -49,12 +49,8 @@ static tree dfs_check_overlap (tree, void *);\n static tree dfs_no_overlap_yet (tree, int, void *);\n static base_kind lookup_base_r (tree, tree, base_access, bool, tree *);\n static int dynamic_cast_base_recurse (tree, tree, bool, tree *);\n-static tree marked_pushdecls_p (tree, int, void *);\n-static tree unmarked_pushdecls_p (tree, int, void *);\n static tree dfs_debug_unmarkedp (tree, int, void *);\n static tree dfs_debug_mark (tree, void *);\n-static tree dfs_push_type_decls (tree, void *);\n-static tree dfs_push_decls (tree, void *);\n static tree add_conversions (tree, void *);\n static int look_for_overrides_r (tree, tree);\n static tree bfs_walk (tree, tree (*) (tree, void *),\n@@ -68,7 +64,6 @@ static tree dfs_access_in_type (tree, void *);\n static access_kind access_in_type (tree, tree);\n static int protected_accessible_p (tree, tree, tree);\n static int friend_accessible_p (tree, tree, tree);\n-static void setup_class_bindings (tree, int);\n static int template_self_reference_p (tree, tree);\n static tree dfs_get_pure_virtuals (tree, void *);\n \n@@ -455,12 +450,23 @@ lookup_field_1 (tree type, tree name, bool want_type)\n \t    return temp;\n \t}\n       if (TREE_CODE (field) == USING_DECL)\n-\t/* For now, we're just treating member using declarations as\n-\t   old ARM-style access declarations.  Thus, there's no reason\n-\t   to return a USING_DECL, and the rest of the compiler can't\n-\t   handle it.  Once the class is defined, these are purged\n-\t   from TYPE_FIELDS anyhow; see handle_using_decl.  */\n-\tcontinue;\n+\t{\n+\t  /* We generally treat class-scope using-declarations as\n+\t     ARM-style access specifications, because support for the\n+\t     ISO semantics has not been implemented.  So, in general,\n+\t     there's no reason to return a USING_DECL, and the rest of\n+\t     the compiler cannot handle that.  Once the class is\n+\t     defined, USING_DECLs are purged from TYPE_FIELDS; see\n+\t     handle_using_decl.  However, we make special efforts to\n+\t     make using-declarations in template classes work\n+\t     correctly.  */\n+\t  if (CLASSTYPE_TEMPLATE_INFO (type)\n+\t      && !CLASSTYPE_USE_TEMPLATE (type)\n+\t      && !TREE_TYPE (field))\n+\t    ;\n+\t  else\n+\t    continue;\n+\t}\n \n       if (DECL_NAME (field) == name\n \t  && (!want_type \n@@ -1912,24 +1918,6 @@ unmarkedp (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n   return !BINFO_MARKED (binfo) ? binfo : NULL_TREE; \n }\n \n-static tree\n-marked_pushdecls_p (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n-{\n-  tree binfo = BINFO_BASE_BINFO (derived, ix);\n-  \n-  return (!BINFO_DEPENDENT_BASE_P (binfo)\n-\t  && BINFO_PUSHDECLS_MARKED (binfo)) ? binfo : NULL_TREE; \n-}\n-\n-static tree\n-unmarked_pushdecls_p (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n-{ \n-  tree binfo = BINFO_BASE_BINFO (derived, ix);\n-  \n-  return (!BINFO_DEPENDENT_BASE_P (binfo)\n-\t  && !BINFO_PUSHDECLS_MARKED (binfo)) ? binfo : NULL_TREE;\n-}\n-\n /* The worker functions for `dfs_walk'.  These do not need to\n    test anything (vis a vis marking) if they are paired with\n    a predicate function (above).  */\n@@ -2032,188 +2020,6 @@ note_debug_info_needed (tree type)\n   dfs_walk (TYPE_BINFO (type), dfs_debug_mark, dfs_debug_unmarkedp, 0);\n }\n \f\n-/* A vector of IDENTIFIER_NODEs that have been processed by\n-   setup_class_bindings.  */\n-\n-static GTY(()) VEC(tree) *marked_identifiers;\n-\n-/* Subroutines of push_class_decls ().  */\n-\n-static void\n-setup_class_bindings (tree name, int type_binding_p)\n-{\n-  tree type_binding = NULL_TREE;\n-  tree value_binding;\n-\n-  /* If we've already done the lookup for this declaration, we're\n-     done.  */\n-  if (IDENTIFIER_MARKED (name))\n-    return;\n-\n-  IDENTIFIER_MARKED (name) = 1;\n-  VEC_safe_push (tree, marked_identifiers, name);\n-\n-  /* First, deal with the type binding.  */\n-  if (type_binding_p)\n-    {\n-      type_binding = lookup_member (current_class_type, name,\n-\t\t\t\t    /*protect=*/2, /*want_type=*/true);\n-      if (TREE_CODE (type_binding) == TREE_LIST \n-\t  && TREE_TYPE (type_binding) == error_mark_node)\n-\t/* NAME is ambiguous.  */\n-\tpush_class_level_binding (name, type_binding);\n-      else\n-\tpushdecl_class_level (type_binding);\n-    }\n-\n-  /* Now, do the value binding.  */\n-  value_binding = lookup_member (current_class_type, name,\n-\t\t\t\t /*protect=*/2, /*want_type=*/false);\n-\n-  if (type_binding_p\n-      && (TREE_CODE (value_binding) == TYPE_DECL\n-\t  || DECL_CLASS_TEMPLATE_P (value_binding)\n-\t  || (TREE_CODE (value_binding) == TREE_LIST\n-\t      && TREE_TYPE (value_binding) == error_mark_node\n-\t      && (TREE_CODE (TREE_VALUE (value_binding))\n-\t\t  == TYPE_DECL))))\n-    /* We found a type-binding, even when looking for a non-type\n-       binding.  This means that we already processed this binding\n-       above.  */;\n-  else if (value_binding)\n-    {\n-      if (TREE_CODE (value_binding) == TREE_LIST \n-\t  && TREE_TYPE (value_binding) == error_mark_node)\n-\t/* NAME is ambiguous.  */\n-\tpush_class_level_binding (name, value_binding);\n-      else\n-\t{\n-\t  if (BASELINK_P (value_binding))\n-\t    /* NAME is some overloaded functions.  */\n-\t    value_binding = BASELINK_FUNCTIONS (value_binding);\n-\t  /* Two conversion operators that convert to the same type\n-\t     may have different names.  (See\n-\t     mangle_conv_op_name_for_type.)  To avoid recording the\n-\t     same conversion operator declaration more than once we\n-\t     must check to see that the same operator was not already\n-\t     found under another name.  */\n-\t  if (IDENTIFIER_TYPENAME_P (name)\n-\t      && is_overloaded_fn (value_binding))\n-\t    {\n-\t      tree fns;\n-\t      for (fns = value_binding; fns; fns = OVL_NEXT (fns))\n-\t\t{\n-\t\t  tree name = DECL_NAME (OVL_CURRENT (fns));\n-\t\t  if (IDENTIFIER_MARKED (name))\n-\t\t    return;\n-\t\t  IDENTIFIER_MARKED (name) = 1;\n-\t\t  VEC_safe_push (tree, marked_identifiers, name);\n-\t\t}\n-\t    }\n-\t  pushdecl_class_level (value_binding);\n-\t}\n-    }\n-}\n-\n-/* Push class-level declarations for any names appearing in BINFO that\n-   are TYPE_DECLS.  */\n-\n-static tree\n-dfs_push_type_decls (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{\n-  tree type;\n-  tree fields;\n-\n-  type = BINFO_TYPE (binfo);\n-  for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n-    if (DECL_NAME (fields) && TREE_CODE (fields) == TYPE_DECL\n-\t&& !(!same_type_p (type, current_class_type)\n-\t     && template_self_reference_p (type, fields)))\n-      setup_class_bindings (DECL_NAME (fields), /*type_binding_p=*/1);\n-\n-  /* We can't just use BINFO_MARKED because envelope_add_decl uses\n-     DERIVED_FROM_P, which calls get_base_distance.  */\n-  BINFO_PUSHDECLS_MARKED (binfo) = 1;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Push class-level declarations for any names appearing in BINFO that\n-   are not TYPE_DECLS.  */\n-\n-static tree\n-dfs_push_decls (tree binfo, void *data)\n-{\n-  tree type = BINFO_TYPE (binfo);\n-  tree method_vec;\n-  tree fields;\n-  \n-  for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n-    if (DECL_NAME (fields) \n-\t&& TREE_CODE (fields) != TYPE_DECL\n-\t&& TREE_CODE (fields) != USING_DECL\n-\t&& !DECL_ARTIFICIAL (fields))\n-      setup_class_bindings (DECL_NAME (fields), /*type_binding_p=*/0);\n-    else if (TREE_CODE (fields) == FIELD_DECL\n-\t     && ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n-      dfs_push_decls (TYPE_BINFO (TREE_TYPE (fields)), data);\n-  \n-  method_vec = (CLASS_TYPE_P (type) \n-\t\t? CLASSTYPE_METHOD_VEC (type) : NULL_TREE);\n-  \n-  if (method_vec && TREE_VEC_LENGTH (method_vec) >= 3)\n-    {\n-      tree *methods;\n-      tree *end;\n-      \n-      /* Farm out constructors and destructors.  */\n-      end = TREE_VEC_END (method_vec);\n-      \n-      for (methods = &TREE_VEC_ELT (method_vec, 2);\n-\t   methods < end && *methods;\n-\t   methods++)\n-\tsetup_class_bindings (DECL_NAME (OVL_CURRENT (*methods)), \n-\t\t\t      /*type_binding_p=*/0);\n-    }\n-\n-  BINFO_PUSHDECLS_MARKED (binfo) = 0;\n-\n-  return NULL_TREE;\n-}\n-\n-/* When entering the scope of a class, we cache all of the\n-   fields that that class provides within its inheritance\n-   lattice.  Where ambiguities result, we mark them\n-   with `error_mark_node' so that if they are encountered\n-   without explicit qualification, we can emit an error\n-   message.  */\n-\n-void\n-push_class_decls (tree type)\n-{\n-  tree id;\n-  size_t i;\n-\n-  if (!TYPE_BINFO (type))\n-    /* This occurs when parsing an invalid declarator id where the\n-       scope is incomplete.  */\n-    return;\n-  \n-  /* Enter type declarations and mark.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_push_type_decls, unmarked_pushdecls_p, 0);\n-\n-  /* Enter non-type declarations and unmark.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_push_decls, marked_pushdecls_p, 0);\n-\n-  /* Clear the IDENTIFIER_MARKED bits.  */\n-  for (i = 0;\n-       (id = VEC_iterate (tree, marked_identifiers, i));\n-       ++i)\n-    IDENTIFIER_MARKED (id) = 0;\n-  if (marked_identifiers)\n-    VEC_truncate (tree, marked_identifiers, 0);\n-}\n-\n void\n print_search_statistics (void)\n {\n@@ -2533,4 +2339,3 @@ original_binfo (tree binfo, tree here)\n   return result;\n }\n \n-#include \"gt-cp-search.h\""}]}