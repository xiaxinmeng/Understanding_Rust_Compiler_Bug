{"sha": "0fc1b4ad1d2015fd464f4c843945b1919c666c94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZjMWI0YWQxZDIwMTVmZDQ2NGY0Yzg0Mzk0NWIxOTE5YzY2NmM5NA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2020-05-05T17:22:47Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-06T11:35:21Z"}, "message": "[Ada] Ada2020: AI12-0198 potentially unevaluated array components\n\ngcc/ada/\n\n\t* sem_util.ads (Interval_Lists.Aggregate_Intervals): New\n\tsubprogram.\n\t* sem_util.adb (Has_Null_Others_Choice,\n\tNon_Static_Or_Null_Range, Interval_Lists.Aggregate_Intervals):\n\tNew subprograms.\n\t(Is_Potentially_Unevaluated): Adding support to detect\n\tpotentially unevaluated components of array aggregates.", "tree": {"sha": "482ccdd9331d6d989eccaac0f15ff88192d54d94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/482ccdd9331d6d989eccaac0f15ff88192d54d94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fc1b4ad1d2015fd464f4c843945b1919c666c94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc1b4ad1d2015fd464f4c843945b1919c666c94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fc1b4ad1d2015fd464f4c843945b1919c666c94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc1b4ad1d2015fd464f4c843945b1919c666c94/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49665da2e51e3e455fa1ed700987b081c4c3af6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49665da2e51e3e455fa1ed700987b081c4c3af6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49665da2e51e3e455fa1ed700987b081c4c3af6e"}], "stats": {"total": 232, "additions": 224, "deletions": 8}, "files": [{"sha": "36efebb8aa748fe8d772b00c224ef1a7805bbf47", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 214, "deletions": 8, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc1b4ad1d2015fd464f4c843945b1919c666c94/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc1b4ad1d2015fd464f4c843945b1919c666c94/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=0fc1b4ad1d2015fd464f4c843945b1919c666c94", "patch": "@@ -17694,9 +17694,81 @@ package body Sem_Util is\n    --------------------------------\n \n    function Is_Potentially_Unevaluated (N : Node_Id) return Boolean is\n+      function Has_Null_Others_Choice (Aggr : Node_Id) return Boolean;\n+      --  Aggr is an array aggregate with static bounds and an others clause;\n+      --  return True if the others choice of the given array aggregate does\n+      --  not cover any component (i.e. is null).\n+\n+      function Non_Static_Or_Null_Range (N : Node_Id) return Boolean;\n+      --  Return True if the given range is nonstatic or null\n+\n+      ----------------------------\n+      -- Has_Null_Others_Choice --\n+      ----------------------------\n+\n+      function Has_Null_Others_Choice (Aggr : Node_Id) return Boolean is\n+         Idx : constant Node_Id := First_Index (Etype (Aggr));\n+         Hiv : constant Uint := Expr_Value (Type_High_Bound (Etype (Idx)));\n+         Lov : constant Uint := Expr_Value (Type_Low_Bound (Etype (Idx)));\n+\n+      begin\n+         declare\n+            Intervals : constant Interval_Lists.Discrete_Interval_List :=\n+              Interval_Lists.Aggregate_Intervals (Aggr);\n+\n+         begin\n+            --  The others choice is null if, after normalization, we\n+            --  have a single interval covering the whole aggregate.\n+\n+            return Intervals'Length = 1\n+              and then\n+                Intervals (Intervals'First).Low = Lov\n+              and then\n+                Intervals (Intervals'First).High = Hiv;\n+         end;\n+\n+      --  If the aggregate is malformed (that is, indexes are not disjoint)\n+      --  then no action is needed at this stage; the error will be reported\n+      --  later by the frontend.\n+\n+      exception\n+         when Interval_Lists.Intervals_Error =>\n+            return False;\n+      end Has_Null_Others_Choice;\n+\n+      ------------------------------\n+      -- Non_Static_Or_Null_Range --\n+      ------------------------------\n+\n+      function Non_Static_Or_Null_Range (N : Node_Id) return Boolean is\n+         Low, High : Node_Id;\n+\n+      begin\n+         Get_Index_Bounds (N, Low, High);\n+\n+         --  Check static bounds\n+\n+         if not Compile_Time_Known_Value (Low)\n+           or else not Compile_Time_Known_Value (High)\n+         then\n+            return True;\n+\n+         --  Check null range\n+\n+         elsif Expr_Value (High) < Expr_Value (Low) then\n+            return True;\n+         end if;\n+\n+         return False;\n+      end Non_Static_Or_Null_Range;\n+\n+      --  Local variables\n+\n       Par  : Node_Id;\n       Expr : Node_Id;\n \n+   --  Start of processing for Is_Potentially_Unevaluated\n+\n    begin\n       Expr := N;\n       Par  := N;\n@@ -17732,6 +17804,8 @@ package body Sem_Util is\n                                N_Not_In,\n                                N_Or_Else,\n                                N_Quantified_Expression)\n+        and then not (Nkind (Par) = N_Aggregate\n+                        and then Is_Array_Type (Etype (Par)))\n       loop\n          Expr := Par;\n          Par  := Parent (Par);\n@@ -17776,6 +17850,55 @@ package body Sem_Util is\n       elsif Nkind (Par) = N_Quantified_Expression then\n          return Expr = Condition (Par);\n \n+      elsif Nkind (Par) = N_Aggregate\n+        and then Is_Array_Type (Etype (Par))\n+        and then Nkind (Expr) = N_Component_Association\n+      then\n+         declare\n+            Choice           : Node_Id;\n+            In_Others_Choice : Boolean := False;\n+\n+         begin\n+            --  The expression of an array_component_association is potentially\n+            --  unevaluated if the associated choice is a subtype_indication or\n+            --  range that defines a nonstatic or null range.\n+\n+            Choice := First (Choices (Expr));\n+            while Present (Choice) loop\n+               if Nkind (Choice) = N_Range\n+                 and then Non_Static_Or_Null_Range (Choice)\n+               then\n+                  return True;\n+\n+               elsif Nkind (Choice) = N_Identifier\n+                 and then Present (Scalar_Range (Etype (Choice)))\n+                 and then\n+                   Non_Static_Or_Null_Range (Scalar_Range (Etype (Choice)))\n+               then\n+                  return True;\n+\n+               elsif Nkind (Choice) = N_Others_Choice then\n+                  In_Others_Choice := True;\n+               end if;\n+\n+               Next (Choice);\n+            end loop;\n+\n+            --  It is also potentially unevaluated if the associated choice\n+            --  is an others choice and the applicable index constraint is\n+            --  nonstatic or null.\n+\n+            if In_Others_Choice then\n+               if not Compile_Time_Known_Bounds (Etype (Par)) then\n+                  return True;\n+               else\n+                  return Has_Null_Others_Choice (Par);\n+               end if;\n+            end if;\n+         end;\n+\n+         return False;\n+\n       else\n          return False;\n       end if;\n@@ -28770,10 +28893,97 @@ package body Sem_Util is\n \n    package body Interval_Lists is\n \n+      procedure Check_Consistency (Intervals : Discrete_Interval_List);\n+      --  Check that list is sorted, lacks null intervals, and has gaps\n+      --  between intervals.\n+\n       function In_Interval\n         (Value : Uint; Interval : Discrete_Interval) return Boolean;\n       --  Does the given value lie within the given interval?\n \n+      procedure Normalize_Interval_List\n+         (List : in out Discrete_Interval_List; Last : out Nat);\n+      --  Perform sorting and merging as required by Check_Consistency.\n+\n+      -------------------------\n+      -- Aggregate_Intervals --\n+      -------------------------\n+\n+      function Aggregate_Intervals (N : Node_Id) return Discrete_Interval_List\n+      is\n+         pragma Assert (Nkind (N) = N_Aggregate\n+           and then Is_Array_Type (Etype (N)));\n+\n+         function Unmerged_Intervals_Count return Nat;\n+         --  Count the number of intervals given in the aggregate N; the others\n+         --  choice (if present) is not taken into account.\n+\n+         function Unmerged_Intervals_Count return Nat is\n+            Count  : Nat := 0;\n+            Choice : Node_Id;\n+            Comp   : Node_Id;\n+         begin\n+            Comp := First (Component_Associations (N));\n+            while Present (Comp) loop\n+               Choice := First (Choices (Comp));\n+\n+               while Present (Choice) loop\n+                  if Nkind (Choice) /= N_Others_Choice then\n+                     Count := Count + 1;\n+                  end if;\n+\n+                  Next (Choice);\n+               end loop;\n+\n+               Next (Comp);\n+            end loop;\n+\n+            return Count;\n+         end Unmerged_Intervals_Count;\n+\n+         --  Local variables\n+\n+         Comp      : Node_Id;\n+         Max_I     : constant Nat := Unmerged_Intervals_Count;\n+         Intervals : Discrete_Interval_List (1 .. Max_I);\n+         Num_I     : Nat := 0;\n+\n+      begin\n+         --  No action needed if there are no intervals\n+\n+         if Max_I = 0 then\n+            return Intervals;\n+         end if;\n+\n+         --  Internally store all the unsorted intervals\n+\n+         Comp := First (Component_Associations (N));\n+         while Present (Comp) loop\n+            declare\n+               Choice_Intervals : constant Discrete_Interval_List\n+                 := Choice_List_Intervals (Choices (Comp));\n+            begin\n+               for J in Choice_Intervals'Range loop\n+                  Num_I := Num_I + 1;\n+                  Intervals (Num_I) := Choice_Intervals (J);\n+               end loop;\n+            end;\n+\n+            Next (Comp);\n+         end loop;\n+\n+         --  Normalize the lists sorting and merging the intervals\n+\n+         declare\n+            Aggr_Intervals : Discrete_Interval_List (1 .. Num_I)\n+                               := Intervals (1 .. Num_I);\n+         begin\n+            Normalize_Interval_List (Aggr_Intervals, Num_I);\n+            Check_Consistency (Aggr_Intervals (1 .. Num_I));\n+            return Aggr_Intervals (1 .. Num_I);\n+         end;\n+      end Aggregate_Intervals;\n+\n       -----------------\n       -- In_Interval --\n       -----------------\n@@ -28783,10 +28993,6 @@ package body Sem_Util is\n          return Value >= Interval.Low and then Value <= Interval.High;\n       end In_Interval;\n \n-      procedure Check_Consistency (Intervals : Discrete_Interval_List);\n-      --  Check that list is sorted, lacks null intervals, and has gaps\n-      --  between intervals.\n-\n       ------------------------\n       --  Check_Consistency --\n       ------------------------\n@@ -28896,10 +29102,6 @@ package body Sem_Util is\n          end if;\n       end Type_Intervals;\n \n-      procedure Normalize_Interval_List\n-         (List : in out Discrete_Interval_List; Last : out Nat);\n-      --  Perform sorting and merging as required by Check_Consistency.\n-\n       -----------------------------\n       -- Normalize_Interval_List --\n       -----------------------------\n@@ -29009,6 +29211,10 @@ package body Sem_Util is\n                   List (Idx) := Null_Interval;\n                   Null_Interval_Count := Null_Interval_Count + 1;\n                else\n+                  if List (Idx).Low <= List (Not_Null).High then\n+                     raise Intervals_Error;\n+                  end if;\n+\n                   pragma Assert (List (Idx).Low > List (Not_Null).High);\n                   Not_Null := Idx;\n                end if;"}, {"sha": "22be399488e928a79dd93f849aab8aff2a5f3f78", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc1b4ad1d2015fd464f4c843945b1919c666c94/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc1b4ad1d2015fd464f4c843945b1919c666c94/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=0fc1b4ad1d2015fd464f4c843945b1919c666c94", "patch": "@@ -3116,6 +3116,12 @@ package Sem_Util is\n       --  successive intervals (i.e., mergeable intervals are merged).\n       --  Low bound is one; high bound is nonnegative.\n \n+      function Aggregate_Intervals (N : Node_Id) return Discrete_Interval_List;\n+      --  Given an array aggregate N, returns the (unique) interval list\n+      --  representing the values of the aggregate choices; if all the array\n+      --  components are covered by the others choice then the length of the\n+      --  result is zero.\n+\n       function Type_Intervals (Typ : Entity_Id) return Discrete_Interval_List;\n       --  Given a static discrete type or subtype, returns the (unique)\n       --  interval list representing the values of the type/subtype.\n@@ -3138,5 +3144,9 @@ package Sem_Util is\n       --  rules that reference \"is statically compatible\" pertain to\n       --  discriminants and therefore do require support for real types;\n       --  the exception is 12.5.1(8).\n+\n+      Intervals_Error : exception;\n+      --  Raised when the list of non-empty pair-wise disjoint intervals cannot\n+      --  be built.\n    end Interval_Lists;\n end Sem_Util;"}]}