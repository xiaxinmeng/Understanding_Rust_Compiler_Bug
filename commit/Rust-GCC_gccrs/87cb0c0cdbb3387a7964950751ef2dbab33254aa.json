{"sha": "87cb0c0cdbb3387a7964950751ef2dbab33254aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdjYjBjMGNkYmIzMzg3YTc5NjQ5NTA3NTFlZjJkYmFiMzMyNTRhYQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2014-07-30T16:26:15Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2014-07-30T16:26:15Z"}, "message": "s390.c (s390_emit_tpf_eh_return): Pass original return address as second parameter to __tpf_eh_return routine.\n\ngcc/\n\n2014-07-30  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* config/s390/s390.c (s390_emit_tpf_eh_return): Pass original return\n\taddress as second parameter to __tpf_eh_return routine.\n\nlibgcc/\n\n2014-07-30  J. D. Johnston  <jjohnst@us.ibm.com>\n\n\t* config/s390/tpf-unwind.h: Include <stdbool.h>.\n\t(__tpf_eh_return): Add original return address as second parameter.\n\tHandle cases where unwinder routines were called directly, instead\n\tof from within the C++ library.\n\nFrom-SVN: r213305", "tree": {"sha": "57f3cc9e5f416ad89cc5891a65172ed17a41e0eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57f3cc9e5f416ad89cc5891a65172ed17a41e0eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87cb0c0cdbb3387a7964950751ef2dbab33254aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87cb0c0cdbb3387a7964950751ef2dbab33254aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87cb0c0cdbb3387a7964950751ef2dbab33254aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87cb0c0cdbb3387a7964950751ef2dbab33254aa/comments", "author": null, "committer": null, "parents": [{"sha": "e58d3b417cef2189f53a7e5923280ae8524970b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e58d3b417cef2189f53a7e5923280ae8524970b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e58d3b417cef2189f53a7e5923280ae8524970b8"}], "stats": {"total": 82, "additions": 59, "deletions": 23}, "files": [{"sha": "04b0d3cf1873e2e4441bb9401cf2df56cb7dfc3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87cb0c0cdbb3387a7964950751ef2dbab33254aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87cb0c0cdbb3387a7964950751ef2dbab33254aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87cb0c0cdbb3387a7964950751ef2dbab33254aa", "patch": "@@ -1,3 +1,8 @@\n+2014-07-30  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_emit_tpf_eh_return): Pass original return\n+\taddress as second parameter to __tpf_eh_return routine.\n+\n 2014-07-30  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/arm/arm.c (arm_get_frame_offsets): Adjust condition for"}, {"sha": "03b85ff2ee1dbe66592afd5b3a9c7a378ecdc9bd", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87cb0c0cdbb3387a7964950751ef2dbab33254aa/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87cb0c0cdbb3387a7964950751ef2dbab33254aa/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=87cb0c0cdbb3387a7964950751ef2dbab33254aa", "patch": "@@ -10850,17 +10850,20 @@ static GTY(()) rtx s390_tpf_eh_return_symbol;\n void\n s390_emit_tpf_eh_return (rtx target)\n {\n-  rtx insn, reg;\n+  rtx insn, reg, orig_ra;\n \n   if (!s390_tpf_eh_return_symbol)\n     s390_tpf_eh_return_symbol = gen_rtx_SYMBOL_REF (Pmode, \"__tpf_eh_return\");\n \n   reg = gen_rtx_REG (Pmode, 2);\n+  orig_ra = gen_rtx_REG (Pmode, 3);\n \n   emit_move_insn (reg, target);\n+  emit_move_insn (orig_ra, get_hard_reg_initial_val (Pmode, RETURN_REGNUM));\n   insn = s390_emit_call (s390_tpf_eh_return_symbol, NULL_RTX, reg,\n                                      gen_rtx_REG (Pmode, RETURN_REGNUM));\n   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), reg);\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), orig_ra);\n \n   emit_move_insn (EH_RETURN_HANDLER_RTX, reg);\n }"}, {"sha": "4795414d166a565dbd9cc12fc520569bc6c5bb90", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87cb0c0cdbb3387a7964950751ef2dbab33254aa/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87cb0c0cdbb3387a7964950751ef2dbab33254aa/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=87cb0c0cdbb3387a7964950751ef2dbab33254aa", "patch": "@@ -1,3 +1,10 @@\n+2014-07-30  J. D. Johnston  <jjohnst@us.ibm.com>\n+\n+\t* config/s390/tpf-unwind.h: Include <stdbool.h>.\n+\t(__tpf_eh_return): Add original return address as second parameter.\n+\tHandle cases where unwinder routines were called directly, instead\n+\tof from within the C++ library.\n+\n 2014-07-29  Nathan Sidwell  <nathan@acm.org>\n \n \t* libgcov.h: Move renaming of entry points to lib gcov specific"}, {"sha": "efffda5d434e2fcad653ad1a52ae47fe371be880", "filename": "libgcc/config/s390/tpf-unwind.h", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87cb0c0cdbb3387a7964950751ef2dbab33254aa/libgcc%2Fconfig%2Fs390%2Ftpf-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87cb0c0cdbb3387a7964950751ef2dbab33254aa/libgcc%2Fconfig%2Fs390%2Ftpf-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fs390%2Ftpf-unwind.h?ref=87cb0c0cdbb3387a7964950751ef2dbab33254aa", "patch": "@@ -24,6 +24,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include <dlfcn.h>\n+#include <stdbool.h>\n \n /* Function Name: __isPATrange\n    Parameters passed into it:  address to check\n@@ -139,48 +140,65 @@ s390_fallback_frame_state (struct _Unwind_Context *context,\n #define TPFAREA_SIZE STACK_POINTER_OFFSET-TPFAREA_OFFSET\n #define INVALID_RETURN 0\n \n-void * __tpf_eh_return (void *target);\n+void * __tpf_eh_return (void *target, void *origRA);\n \n void *\n-__tpf_eh_return (void *target)\n+__tpf_eh_return (void *target, void *origRA)\n {\n   Dl_info targetcodeInfo, currentcodeInfo;\n   int retval;\n   void *current, *stackptr, *destination_frame;\n-  unsigned long int shifter, is_a_stub;\n+  unsigned long int shifter;\n+  bool is_a_stub, frameDepth2, firstIteration;\n \n-  is_a_stub = 0;\n+  is_a_stub = false;\n+  frameDepth2 = false;\n+  firstIteration = true;\n \n   /* Get code info for target return's address.  */\n   retval = dladdr (target, &targetcodeInfo);\n \n+  /* Check if original RA is a Pat stub.  If so set flag.  */\n+  if (__isPATrange (origRA))\n+    frameDepth2 = true;\n+\n   /* Ensure the code info is valid (for target).  */\n   if (retval != INVALID_RETURN)\n     {\n-\n-      /* Get the stack pointer of the stack frame to be modified by\n-         the exception unwinder.  So that we can begin our climb\n-         there.  */\n-      stackptr = (void *) *((unsigned long int *) (*(PREVIOUS_STACK_PTR())));\n+      /* Get the stack pointer of the first stack frame beyond the\n+         unwinder or if exists the calling C++ runtime function (e.g.,\n+         __cxa_throw).  */\n+      if (!frameDepth2)\n+        stackptr = (void *) *((unsigned long int *) (*(PREVIOUS_STACK_PTR())));\n+      else\n+        stackptr = (void *) *(PREVIOUS_STACK_PTR());\n \n       /* Begin looping through stack frames.  Stop if invalid\n          code information is retrieved or if a match between the\n          current stack frame iteration shared object's address\n          matches that of the target, calculated above.  */\n       do\n         {\n-          /* Get return address based on our stackptr iterator.  */\n-          current = (void *) *((unsigned long int *)\n-                      (stackptr+RA_OFFSET));\n-\n-          /* Is it a Pat Stub?  */\n-          if (__isPATrange (current))\n+          if (!frameDepth2 || (frameDepth2 && !firstIteration))\n+            {\n+              /* Get return address based on our stackptr iterator.  */\n+              current = (void *) *((unsigned long int *)\n+                                   (stackptr + RA_OFFSET));\n+\n+              /* Is it a Pat Stub?  */\n+              if (__isPATrange (current))\n+                {\n+                  /* Yes it was, get real return address in TPF stack area.  */\n+                  current = (void *) *((unsigned long int *)\n+                                       (stackptr + TPFRA_OFFSET))\n+                  is_a_stub = true;\n+                }\n+            }\n+          else\n             {\n-              /* Yes it was, get real return address\n-                 in TPF stack area.  */\n               current = (void *) *((unsigned long int *)\n-                          (stackptr+TPFRA_OFFSET));\n-              is_a_stub = 1;\n+                                   (stackptr + TPFRA_OFFSET));\n+              is_a_stub = true;\n             }\n \n           /* Get codeinfo on RA so that we can figure out\n@@ -219,8 +237,10 @@ __tpf_eh_return (void *target)\n                   This is necessary for CTOA stubs.\n                   Otherwise we leap one byte past where we want to\n                   go to in the TPF pat stub linkage code.  */\n-               shifter = *((unsigned long int *)\n-                     (stackptr + RA_OFFSET));\n+               if (!frameDepth2 || (frameDepth2 && !firstIteration))\n+                 shifter = *((unsigned long int *) (stackptr + RA_OFFSET));\n+               else\n+                 shifter = (unsigned long int) origRA;\n \n                shifter &= ~1ul;\n \n@@ -239,7 +259,8 @@ __tpf_eh_return (void *target)\n              Bump stack frame iterator.  */\n           stackptr = (void *) *(unsigned long int *) stackptr;\n \n-          is_a_stub = 0;\n+          is_a_stub = false;\n+          firstIteration = false;\n \n         }  while (stackptr && retval != INVALID_RETURN\n                 && targetcodeInfo.dli_fbase != currentcodeInfo.dli_fbase);"}]}