{"sha": "8d245821a2f3c28b71bf0958c90cf7fed6c9871d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyNDU4MjFhMmYzYzI4YjcxYmYwOTU4YzkwY2Y3ZmVkNmM5ODcxZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-03T18:13:44Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-03T18:13:44Z"}, "message": "call.c (build_scoped_method_call): Use convert_to_void.\n\n\t* call.c (build_scoped_method_call): Use convert_to_void.\n\t(build_method_call): Likewise.\n\t* class.c (check_field_decls): Remove dead code.\n\t* cvt.c (convert_from_reference): Remove OFFSET_TYPE handling.\n\t* decl2.c (grok_array_decl): Remove dead code.\n\t(arg_assoc_type): Avoid relying on POINTER_TYPE over OFFSET_TYPE\n\tas pointer-to-member representation.\n\t* init.c (build_offset_ref): Tidy.\n\t(build_vec_delete_1): Use convert_to_void.\n\t* mangle.c (write_type): Avoid relying on POINTER_TYPE over OFFSET_TYPE\n\tas pointer-to-member representation.\n\nFrom-SVN: r68895", "tree": {"sha": "7a1b74d528559e87eba7c56bcafd46a0a8dea100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a1b74d528559e87eba7c56bcafd46a0a8dea100"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d245821a2f3c28b71bf0958c90cf7fed6c9871d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d245821a2f3c28b71bf0958c90cf7fed6c9871d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d245821a2f3c28b71bf0958c90cf7fed6c9871d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/comments", "author": null, "committer": null, "parents": [{"sha": "ee41cff421132bb2891a4ad51fae0f83ffcfe087", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee41cff421132bb2891a4ad51fae0f83ffcfe087", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee41cff421132bb2891a4ad51fae0f83ffcfe087"}], "stats": {"total": 117, "additions": 53, "deletions": 64}, "files": [{"sha": "1e75a34f95cfdd9de44093b62fd86ca4ad199060", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8d245821a2f3c28b71bf0958c90cf7fed6c9871d", "patch": "@@ -1,3 +1,17 @@\n+2003-07-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (build_scoped_method_call): Use convert_to_void.\n+\t(build_method_call): Likewise.\n+\t* class.c (check_field_decls): Remove dead code.\n+\t* cvt.c (convert_from_reference): Remove OFFSET_TYPE handling.\n+\t* decl2.c (grok_array_decl): Remove dead code.\n+\t(arg_assoc_type): Avoid relying on POINTER_TYPE over OFFSET_TYPE\n+\tas pointer-to-member representation.\n+\t* init.c (build_offset_ref): Tidy.\n+\t(build_vec_delete_1): Use convert_to_void.\n+\t* mangle.c (write_type): Avoid relying on POINTER_TYPE over OFFSET_TYPE\n+\tas pointer-to-member representation.\n+\t\n 2003-07-03  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/9162"}, {"sha": "bc1179b6cb0037daa1125576b853dd4704a4d326", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8d245821a2f3c28b71bf0958c90cf7fed6c9871d", "patch": "@@ -263,7 +263,7 @@ build_scoped_method_call (tree exp, tree basetype, tree name, tree parms)\n \t    error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n \t\t      exp, basetype, type);\n \n-\t  return cp_convert (void_type_node, exp);\n+\t  return convert_to_void (exp, /*implicit=*/NULL);\n \t}\n     }\n \n@@ -290,7 +290,7 @@ build_scoped_method_call (tree exp, tree basetype, tree name, tree parms)\n       if (TREE_CODE (name) == BIT_NOT_EXPR)\n \t{\n \t  if (! TYPE_HAS_DESTRUCTOR (TREE_TYPE (decl)))\n-\t    return cp_convert (void_type_node, exp);\n+\t    return convert_to_void (exp, /*implicit=*/NULL);\n \t  \n \t  return build_delete (TREE_TYPE (decl), decl, \n \t\t\t       sfk_complete_destructor,\n@@ -496,7 +496,7 @@ build_method_call (tree instance, tree name, tree parms,\n \t   TREE_OPERAND (name, 0), object_type);\n \n       if (! TYPE_HAS_DESTRUCTOR (complete_type (object_type)))\n-\treturn cp_convert (void_type_node, instance);\n+\treturn convert_to_void (instance, /*implicit=*/NULL);\n       instance = default_conversion (instance);\n       instance_ptr = build_unary_op (ADDR_EXPR, instance, 0);\n       return build_delete (build_pointer_type (object_type),"}, {"sha": "978e8447b749e50282999c0f5e664257fbc503eb", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8d245821a2f3c28b71bf0958c90cf7fed6c9871d", "patch": "@@ -3091,12 +3091,6 @@ check_field_decls (tree t, tree *access_decls,\n \t  type = build_pointer_type (type);\n \t  TREE_TYPE (x) = type;\n \t}\n-      else if (TREE_CODE (type) == OFFSET_TYPE)\n-\t{\n-\t  cp_error_at (\"field `%D' invalidly declared offset type\", x);\n-\t  type = build_pointer_type (type);\n-\t  TREE_TYPE (x) = type;\n-\t}\n \n       if (type == error_mark_node)\n \tcontinue;"}, {"sha": "29f02226af05fcd9a58e52321845f6e1afd0d848", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8d245821a2f3c28b71bf0958c90cf7fed6c9871d", "patch": "@@ -552,11 +552,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n tree\n convert_from_reference (tree val)\n {\n-  tree type = TREE_TYPE (val);\n-\n-  if (TREE_CODE (type) == OFFSET_TYPE)\n-    type = TREE_TYPE (type);\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TREE_CODE (TREE_TYPE (val)) == REFERENCE_TYPE)\n     return build_indirect_ref (val, NULL);\n   return val;\n }"}, {"sha": "f70103788976f90dda20d93959959f648374a359", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8d245821a2f3c28b71bf0958c90cf7fed6c9871d", "patch": "@@ -407,16 +407,9 @@ grok_array_decl (tree array_expr, tree index_exp)\n     return build_min (ARRAY_REF, type ? TREE_TYPE (type) : NULL_TREE,\n \t\t      array_expr, index_exp);\n \n-  if (type == NULL_TREE)\n-    {\n-      /* Something has gone very wrong.  Assume we are mistakenly reducing\n-\t an expression instead of a declaration.  */\n-      error (\"parser may be lost: is there a '{' missing somewhere?\");\n-      return NULL_TREE;\n-    }\n+  my_friendly_assert (type, 20030626);\n \n-  if (TREE_CODE (type) == OFFSET_TYPE\n-      || TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n   /* If they have an `operator[]', use that.  */\n@@ -4069,8 +4062,15 @@ arg_assoc_type (struct arg_lookup *k, tree type)\n      right, we can end up with such things without a type.  */\n   if (!type)\n     return false;\n-  \n-  switch (TREE_CODE (type))\n+\n+  if (TYPE_PTRMEM_P (type))\n+    {\n+      /* Pointer to member: associate class type and value type.  */\n+      if (arg_assoc_type (k, TYPE_PTRMEM_CLASS_TYPE (type)))\n+\treturn true;\n+      return arg_assoc_type (k, TYPE_PTRMEM_POINTED_TO_TYPE (type));\n+    }\n+  else switch (TREE_CODE (type))\n     {\n     case ERROR_MARK:\n       return false;\n@@ -4093,11 +4093,6 @@ arg_assoc_type (struct arg_lookup *k, tree type)\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n       return arg_assoc_namespace (k, decl_namespace (TYPE_MAIN_DECL (type)));\n-    case OFFSET_TYPE:\n-      /* Pointer to member: associate class type and value type.  */\n-      if (arg_assoc_type (k, TYPE_OFFSET_BASETYPE (type)))\n-\treturn true;\n-      return arg_assoc_type (k, TREE_TYPE (type));\n     case METHOD_TYPE:\n       /* The basetype is referenced in the first arg type, so just\n \t fall through.  */"}, {"sha": "b88f1f24243db7ca4dee254655d39d45f6c18b17", "filename": "gcc/cp/init.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8d245821a2f3c28b71bf0958c90cf7fed6c9871d", "patch": "@@ -1501,7 +1501,7 @@ build_member_call (tree type, tree name, tree parmlist)\n tree\n build_offset_ref (tree type, tree name)\n {\n-  tree decl, t = error_mark_node;\n+  tree decl;\n   tree member;\n   tree basebinfo = NULL_TREE;\n   tree orig_name = name;\n@@ -1546,7 +1546,7 @@ build_offset_ref (tree type, tree name)\n   /* Handle namespace names fully here.  */\n   if (TREE_CODE (type) == NAMESPACE_DECL)\n     {\n-      t = lookup_namespace_name (type, name);\n+      tree t = lookup_namespace_name (type, name);\n       if (t == error_mark_node)\n         return t;\n       if (TREE_CODE (orig_name) == TEMPLATE_ID_EXPR)\n@@ -1597,7 +1597,7 @@ build_offset_ref (tree type, tree name)\n     {\n       /* Go from the TREE_BASELINK to the member function info.  */\n       tree fnfields = member;\n-      t = BASELINK_FUNCTIONS (fnfields);\n+      tree t = BASELINK_FUNCTIONS (fnfields);\n \n       if (TREE_CODE (orig_name) == TEMPLATE_ID_EXPR)\n \t{\n@@ -1644,44 +1644,43 @@ build_offset_ref (tree type, tree name)\n       return t;\n     }\n \n-  t = member;\n-\n-  if (t == NULL_TREE)\n+  if (member == NULL_TREE)\n     {\n       error (\"`%D' is not a member of type `%T'\", name, type);\n       return error_mark_node;\n     }\n \n-  if (TREE_CODE (t) == TYPE_DECL)\n+  if (TREE_CODE (member) == TYPE_DECL)\n     {\n-      TREE_USED (t) = 1;\n-      return t;\n+      TREE_USED (member) = 1;\n+      return member;\n     }\n   /* static class members and class-specific enum\n      values can be returned without further ado.  */\n-  if (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == CONST_DECL)\n+  if (TREE_CODE (member) == VAR_DECL || TREE_CODE (member) == CONST_DECL)\n     {\n-      mark_used (t);\n-      return convert_from_reference (t);\n+      mark_used (member);\n+      return convert_from_reference (member);\n     }\n \n-  if (TREE_CODE (t) == FIELD_DECL && DECL_C_BIT_FIELD (t))\n+  if (TREE_CODE (member) == FIELD_DECL && DECL_C_BIT_FIELD (member))\n     {\n-      error (\"invalid pointer to bit-field `%D'\", t);\n+      error (\"invalid pointer to bit-field `%D'\", member);\n       return error_mark_node;\n     }\n \n   /* static class functions too.  */\n-  if (TREE_CODE (t) == FUNCTION_DECL\n-      && TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n+  if (TREE_CODE (member) == FUNCTION_DECL\n+      && TREE_CODE (TREE_TYPE (member)) == FUNCTION_TYPE)\n     abort ();\n \n   /* In member functions, the form `type::name' is no longer\n      equivalent to `this->type::name', at least not until\n      resolve_offset_ref.  */\n-  t = build (OFFSET_REF, build_offset_type (type, TREE_TYPE (t)), decl, t);\n-  PTRMEM_OK_P (t) = 1;\n-  return t;\n+  member = build (OFFSET_REF, build_offset_type (type, TREE_TYPE (member)), \n+\t\t  decl, member);\n+  PTRMEM_OK_P (member) = 1;\n+  return member;\n }\n \n /* If a OFFSET_REF made it through to here, then it did\n@@ -2625,7 +2624,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n     /* Pre-evaluate the SAVE_EXPR outside of the BIND_EXPR.  */\n     body = build (COMPOUND_EXPR, void_type_node, base, body);\n \n-  return cp_convert (void_type_node, body);\n+  return convert_to_void (body, /*implicit=*/NULL);\n }\n \n /* Create an unnamed variable of the indicated TYPE.  */ "}, {"sha": "27f5c7faae30c79666cf03a1c2e57cc16fd55853", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d245821a2f3c28b71bf0958c90cf7fed6c9871d/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=8d245821a2f3c28b71bf0958c90cf7fed6c9871d", "patch": "@@ -1441,7 +1441,9 @@ write_type (tree type)\n       /* See through any typedefs.  */\n       type = TYPE_MAIN_VARIANT (type);\n \n-      switch (TREE_CODE (type))\n+      if (TYPE_PTRMEM_P (type))\n+\twrite_pointer_to_member_type (type);\n+      else switch (TREE_CODE (type))\n \t{\n \tcase VOID_TYPE:\n \tcase BOOLEAN_TYPE:\n@@ -1483,15 +1485,8 @@ write_type (tree type)\n \t  break;\n \n \tcase POINTER_TYPE:\n-\t  /* A pointer-to-member variable is represented by a POINTER_TYPE\n-\t     to an OFFSET_TYPE, so check for this first.  */\n-\t  if (TYPE_PTRMEM_P (type))\n-\t    write_pointer_to_member_type (type);\n-\t  else\n-\t    {\n-\t      write_char ('P');\n-\t      write_type (TREE_TYPE (type));\n-\t    }\n+\t  write_char ('P');\n+\t  write_type (TREE_TYPE (type));\n \t  break;\n \n \tcase REFERENCE_TYPE:\n@@ -1514,10 +1509,6 @@ write_type (tree type)\n \t    (TI_ARGS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (type)));\n \t  break;\n \n-\tcase OFFSET_TYPE:\n-\t  write_pointer_to_member_type (build_pointer_type (type));\n-\t  break;\n-\n \tcase VECTOR_TYPE:\n \t  write_string (\"U8__vector\");\n \t  write_type (TREE_TYPE (type));"}]}