{"sha": "8d09227450c03328a943db0cd5cfd0985964987b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQwOTIyNzQ1MGMwMzMyOGE5NDNkYjBjZDVjZmQwOTg1OTY0OTg3Yg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-04-21T19:51:01Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-04-21T19:51:01Z"}, "message": "(find_splittable_givs): Share dest_reg for multiple address givs within a single instruction.\n\n(find_splittable_givs): Share dest_reg for multiple\naddress givs within a single instruction.\n(copy_loop_body): Only update psuedo-reg for shared giv once.\n\nFrom-SVN: r7124", "tree": {"sha": "39ade6bb1f8b15c036845d8a8fc3e40a11db4628", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39ade6bb1f8b15c036845d8a8fc3e40a11db4628"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d09227450c03328a943db0cd5cfd0985964987b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d09227450c03328a943db0cd5cfd0985964987b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d09227450c03328a943db0cd5cfd0985964987b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d09227450c03328a943db0cd5cfd0985964987b/comments", "author": null, "committer": null, "parents": [{"sha": "aee2c3c58e51267c48e8d0b2c487961e75cde815", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee2c3c58e51267c48e8d0b2c487961e75cde815", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aee2c3c58e51267c48e8d0b2c487961e75cde815"}], "stats": {"total": 46, "additions": 35, "deletions": 11}, "files": [{"sha": "7644cf4f1398f138f852d83daa4ee1d4ca602042", "filename": "gcc/unroll.c", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d09227450c03328a943db0cd5cfd0985964987b/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d09227450c03328a943db0cd5cfd0985964987b/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=8d09227450c03328a943db0cd5cfd0985964987b", "patch": "@@ -1558,16 +1558,25 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t\telse\n \t\t\t  dest_reg = XEXP (tv->dest_reg, 0);\n \t\t\t\n-\t\t\t/* tv->dest_reg may actually be a (PLUS (REG) (CONST))\n-\t\t\t   here, so we must call plus_constant to add\n-\t\t\t   the const_adjust amount before calling\n-\t\t\t   emit_unrolled_add below.  */\n-\t\t\tvalue = plus_constant (tv->dest_reg, tv->const_adjust);\n-\n-\t\t\t/* The constant could be too large for an add\n-\t\t\t   immediate, so can't directly emit an insn here.  */\n-\t\t\temit_unrolled_add (dest_reg, XEXP (value, 0),\n-\t\t\t\t\t   XEXP (value, 1));\n+\t\t\t/* Check for shared address givs, and avoid\n+\t\t\t   incrementing the shared psuedo reg more than\n+\t\t\t   once.  */\n+\t\t\tif (! (tv != v && tv->insn == v->insn\n+\t\t\t       && tv->new_reg == v->new_reg))\n+\t\t\t  {\n+\t\t\t    /* tv->dest_reg may actually be a (PLUS (REG)\n+\t\t\t       (CONST)) here, so we must call plus_constant\n+\t\t\t       to add the const_adjust amount before calling\n+\t\t\t       emit_unrolled_add below.  */\n+\t\t\t    value = plus_constant (tv->dest_reg,\n+\t\t\t\t\t\t   tv->const_adjust);\n+\n+\t\t\t    /* The constant could be too large for an add\n+\t\t\t       immediate, so can't directly emit an insn\n+\t\t\t       here.  */\n+\t\t\t    emit_unrolled_add (dest_reg, XEXP (value, 0),\n+\t\t\t\t\t       XEXP (value, 1));\n+\t\t\t  }\n \t\t\t\n \t\t\t/* Reset the giv to be just the register again, in case\n \t\t\t   it is used after the set we have just emitted.\n@@ -2602,8 +2611,23 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t the work of simplifying multiple address givs to the\n \t\t following cse pass.  */\n \t      \n+\t      /* As a special case, if we have multiple identical address givs\n+\t\t within a single instruction, then we do use a single psuedo\n+\t\t reg for both.  This is necessary in case one is a match_dup\n+\t\t of the other.  */\n+\n \t      v->const_adjust = 0;\n-\t      if (unroll_type != UNROLL_COMPLETELY)\n+\n+\t      if (v->same && v->same->insn == v->insn\n+\t\t  && v->new_reg == v->same->new_reg)\n+\t\t{\n+\t\t  v->dest_reg = v->same->dest_reg;\n+\t\t  if (loop_dump_stream)\n+\t\t    fprintf (loop_dump_stream,\n+\t\t\t     \"Sharing address givs with reg %d\\n\",\n+\t\t\t     REGNO (v->dest_reg));\n+\t\t}\n+\t      else if (unroll_type != UNROLL_COMPLETELY)\n \t\t{\n \t\t  /* If not completely unrolling the loop, then create a new\n \t\t     register to hold the split value of the DEST_ADDR giv."}]}