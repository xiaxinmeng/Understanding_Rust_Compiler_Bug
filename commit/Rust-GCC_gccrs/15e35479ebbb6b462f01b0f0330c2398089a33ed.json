{"sha": "15e35479ebbb6b462f01b0f0330c2398089a33ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlMzU0NzllYmJiNmI0NjJmMDFiMGYwMzMwYzIzOTgwODlhMzNlZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-06-26T13:37:16Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-06-26T13:37:16Z"}, "message": "Makefile.in (OBJS): Add postreload.o.\n\n\t* Makefile.in (OBJS): Add postreload.o.\n\tRemove cselib.h from the dependency list for reload1.o.\n\tAdd a dependency list for postreload.o.\n\t* reload.h: Change the comment for the prototype of\n\treload_cse_regs.\n\t* reload1.c: Don't include cselib.h.\n\t(reload_cse_regs): Move to postreload.c\n\t(reload_cse_regs_1): Likewise.\n\t(reload_cse_noop_set_p): Likewise.\n\t(reload_cse_simplify_set): Likewise.\n\t(reload_cse_simplify_operands): Likewise.\n\t(RELOAD_COMBINE_MAX_USES): Likewise.\n\t(reload_combine_ruid): Likewise.\n\t(LABEL_LIVE): Likewise.\n\t(reload_combine): Likewise.\n\t(reload_combine_note_use): Likewise.\n\t(reload_combine_note_store): Likewise.\n\t(reg_set_luid): Likewise.\n\t(reg_offset): Likewise.\n\t(reg_base_reg): Likewise.\n\t(reg_mode): Likewise.\n\t(move2add_luid): Likewise.\n\t(move2add_last_label_luid): Likewise.\n\t(MODES_OK_FOR_MOVE2ADD): Likewise.\n\t(reload_cse_move2add): Likewise.\n\t(move2add_note_store): Likewise.\n\t(reload_cse_simplify): Likewise.\n\t* postreload.c: New.\n\nFrom-SVN: r68532", "tree": {"sha": "76d6a4ea370809129acaf35189c9d3d2e6176a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76d6a4ea370809129acaf35189c9d3d2e6176a97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15e35479ebbb6b462f01b0f0330c2398089a33ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e35479ebbb6b462f01b0f0330c2398089a33ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e35479ebbb6b462f01b0f0330c2398089a33ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e35479ebbb6b462f01b0f0330c2398089a33ed/comments", "author": null, "committer": null, "parents": [{"sha": "555c346adb6613adc2b366eba9599ed6d6662b67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/555c346adb6613adc2b366eba9599ed6d6662b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/555c346adb6613adc2b366eba9599ed6d6662b67"}], "stats": {"total": 3027, "additions": 1553, "deletions": 1474}, "files": [{"sha": "ba5cd5bc1072b4a6563e5ace5a9941251a25be2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e35479ebbb6b462f01b0f0330c2398089a33ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e35479ebbb6b462f01b0f0330c2398089a33ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15e35479ebbb6b462f01b0f0330c2398089a33ed", "patch": "@@ -1,3 +1,34 @@\n+2003-06-26  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* Makefile.in (OBJS): Add postreload.o.\n+\tRemove cselib.h from the dependency list for reload1.o.\n+\tAdd a dependency list for postreload.o.\n+\t* reload.h: Change the comment for the prototype of\n+\treload_cse_regs.\n+\t* reload1.c: Don't include cselib.h.\n+\t(reload_cse_regs): Move to postreload.c\n+\t(reload_cse_regs_1): Likewise.\n+\t(reload_cse_noop_set_p): Likewise.\n+\t(reload_cse_simplify_set): Likewise.\n+\t(reload_cse_simplify_operands): Likewise.\n+\t(RELOAD_COMBINE_MAX_USES): Likewise.\n+\t(reload_combine_ruid): Likewise.\n+\t(LABEL_LIVE): Likewise.\n+\t(reload_combine): Likewise.\n+\t(reload_combine_note_use): Likewise.\n+\t(reload_combine_note_store): Likewise.\n+\t(reg_set_luid): Likewise.\n+\t(reg_offset): Likewise.\n+\t(reg_base_reg): Likewise.\n+\t(reg_mode): Likewise.\n+\t(move2add_luid): Likewise.\n+\t(move2add_last_label_luid): Likewise.\n+\t(MODES_OK_FOR_MOVE2ADD): Likewise.\n+\t(reload_cse_move2add): Likewise.\n+\t(move2add_note_store): Likewise.\n+\t(reload_cse_simplify): Likewise.\n+\t* postreload.c: New.\n+\n 2003-06-26  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/avr/avr.c (final_prescan_insn): Remove support for"}, {"sha": "78153b64df013aecb2f59430f3ac5dad396e66a7", "filename": "gcc/postreload.c", "status": "added", "additions": 1519, "deletions": 0, "changes": 1519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e35479ebbb6b462f01b0f0330c2398089a33ed/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e35479ebbb6b462f01b0f0330c2398089a33ed/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=15e35479ebbb6b462f01b0f0330c2398089a33ed", "patch": "@@ -0,0 +1,1519 @@\n+/* Perform simple optimizations to clean up the result of reload.\n+   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+\n+#include \"machmode.h\"\n+#include \"hard-reg-set.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"obstack.h\"\n+#include \"insn-config.h\"\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"regs.h\"\n+#include \"basic-block.h\"\n+#include \"reload.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+#include \"cselib.h\"\n+#include \"real.h\"\n+#include \"toplev.h\"\n+#include \"except.h\"\n+#include \"tree.h\"\n+\n+static int reload_cse_noop_set_p\tPARAMS ((rtx));\n+static void reload_cse_simplify\t\tPARAMS ((rtx, rtx));\n+static void reload_cse_regs_1\t\tPARAMS ((rtx));\n+static int reload_cse_simplify_set\tPARAMS ((rtx, rtx));\n+static int reload_cse_simplify_operands\tPARAMS ((rtx, rtx));\n+\n+static void reload_combine\t\tPARAMS ((void));\n+static void reload_combine_note_use\tPARAMS ((rtx *, rtx));\n+static void reload_combine_note_store\tPARAMS ((rtx, rtx, void *));\n+\n+static void reload_cse_move2add\t\tPARAMS ((rtx));\n+static void move2add_note_store\t\tPARAMS ((rtx, rtx, void *));\n+\n+/* Call cse / combine like post-reload optimization phases.\n+   FIRST is the first instruction.  */\n+void\n+reload_cse_regs (first)\n+     rtx first ATTRIBUTE_UNUSED;\n+{\n+  reload_cse_regs_1 (first);\n+  reload_combine ();\n+  reload_cse_move2add (first);\n+  if (flag_expensive_optimizations)\n+    reload_cse_regs_1 (first);\n+}\n+\n+/* See whether a single set SET is a noop.  */\n+static int\n+reload_cse_noop_set_p (set)\n+     rtx set;\n+{\n+  if (cselib_reg_set_mode (SET_DEST (set)) != GET_MODE (SET_DEST (set)))\n+    return 0;\n+\n+  return rtx_equal_for_cselib_p (SET_DEST (set), SET_SRC (set));\n+}\n+\n+/* Try to simplify INSN.  */\n+static void\n+reload_cse_simplify (insn, testreg)\n+     rtx insn;\n+     rtx testreg;\n+{\n+  rtx body = PATTERN (insn);\n+\n+  if (GET_CODE (body) == SET)\n+    {\n+      int count = 0;\n+\n+      /* Simplify even if we may think it is a no-op.\n+         We may think a memory load of a value smaller than WORD_SIZE\n+         is redundant because we haven't taken into account possible\n+         implicit extension.  reload_cse_simplify_set() will bring\n+         this out, so it's safer to simplify before we delete.  */\n+      count += reload_cse_simplify_set (body, insn);\n+\n+      if (!count && reload_cse_noop_set_p (body))\n+\t{\n+\t  rtx value = SET_DEST (body);\n+\t  if (REG_P (value)\n+\t      && ! REG_FUNCTION_VALUE_P (value))\n+\t    value = 0;\n+\t  delete_insn_and_edges (insn);\n+\t  return;\n+\t}\n+\n+      if (count > 0)\n+\tapply_change_group ();\n+      else\n+\treload_cse_simplify_operands (insn, testreg);\n+    }\n+  else if (GET_CODE (body) == PARALLEL)\n+    {\n+      int i;\n+      int count = 0;\n+      rtx value = NULL_RTX;\n+\n+      /* If every action in a PARALLEL is a noop, we can delete\n+\t the entire PARALLEL.  */\n+      for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n+\t{\n+\t  rtx part = XVECEXP (body, 0, i);\n+\t  if (GET_CODE (part) == SET)\n+\t    {\n+\t      if (! reload_cse_noop_set_p (part))\n+\t\tbreak;\n+\t      if (REG_P (SET_DEST (part))\n+\t\t  && REG_FUNCTION_VALUE_P (SET_DEST (part)))\n+\t\t{\n+\t\t  if (value)\n+\t\t    break;\n+\t\t  value = SET_DEST (part);\n+\t\t}\n+\t    }\n+\t  else if (GET_CODE (part) != CLOBBER)\n+\t    break;\n+\t}\n+\n+      if (i < 0)\n+\t{\n+\t  delete_insn_and_edges (insn);\n+\t  /* We're done with this insn.  */\n+\t  return;\n+\t}\n+\n+      /* It's not a no-op, but we can try to simplify it.  */\n+      for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n+\tif (GET_CODE (XVECEXP (body, 0, i)) == SET)\n+\t  count += reload_cse_simplify_set (XVECEXP (body, 0, i), insn);\n+\n+      if (count > 0)\n+\tapply_change_group ();\n+      else\n+\treload_cse_simplify_operands (insn, testreg);\n+    }\n+}\n+\n+/* Do a very simple CSE pass over the hard registers.\n+\n+   This function detects no-op moves where we happened to assign two\n+   different pseudo-registers to the same hard register, and then\n+   copied one to the other.  Reload will generate a useless\n+   instruction copying a register to itself.\n+\n+   This function also detects cases where we load a value from memory\n+   into two different registers, and (if memory is more expensive than\n+   registers) changes it to simply copy the first register into the\n+   second register.\n+\n+   Another optimization is performed that scans the operands of each\n+   instruction to see whether the value is already available in a\n+   hard register.  It then replaces the operand with the hard register\n+   if possible, much like an optional reload would.  */\n+\n+static void\n+reload_cse_regs_1 (first)\n+     rtx first;\n+{\n+  rtx insn;\n+  rtx testreg = gen_rtx_REG (VOIDmode, -1);\n+\n+  cselib_init ();\n+  init_alias_analysis ();\n+\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (INSN_P (insn))\n+\treload_cse_simplify (insn, testreg);\n+\n+      cselib_process_insn (insn);\n+    }\n+\n+  /* Clean up.  */\n+  end_alias_analysis ();\n+  cselib_finish ();\n+}\n+\n+/* Try to simplify a single SET instruction.  SET is the set pattern.\n+   INSN is the instruction it came from.\n+   This function only handles one case: if we set a register to a value\n+   which is not a register, we try to find that value in some other register\n+   and change the set into a register copy.  */\n+\n+static int\n+reload_cse_simplify_set (set, insn)\n+     rtx set;\n+     rtx insn;\n+{\n+  int did_change = 0;\n+  int dreg;\n+  rtx src;\n+  enum reg_class dclass;\n+  int old_cost;\n+  cselib_val *val;\n+  struct elt_loc_list *l;\n+#ifdef LOAD_EXTEND_OP\n+  enum rtx_code extend_op = NIL;\n+#endif\n+\n+  dreg = true_regnum (SET_DEST (set));\n+  if (dreg < 0)\n+    return 0;\n+\n+  src = SET_SRC (set);\n+  if (side_effects_p (src) || true_regnum (src) >= 0)\n+    return 0;\n+\n+  dclass = REGNO_REG_CLASS (dreg);\n+\n+#ifdef LOAD_EXTEND_OP\n+  /* When replacing a memory with a register, we need to honor assumptions\n+     that combine made wrt the contents of sign bits.  We'll do this by\n+     generating an extend instruction instead of a reg->reg copy.  Thus\n+     the destination must be a register that we can widen.  */\n+  if (GET_CODE (src) == MEM\n+      && GET_MODE_BITSIZE (GET_MODE (src)) < BITS_PER_WORD\n+      && (extend_op = LOAD_EXTEND_OP (GET_MODE (src))) != NIL\n+      && GET_CODE (SET_DEST (set)) != REG)\n+    return 0;\n+#endif\n+\n+  /* If memory loads are cheaper than register copies, don't change them.  */\n+  if (GET_CODE (src) == MEM)\n+    old_cost = MEMORY_MOVE_COST (GET_MODE (src), dclass, 1);\n+  else if (CONSTANT_P (src))\n+    old_cost = rtx_cost (src, SET);\n+  else if (GET_CODE (src) == REG)\n+    old_cost = REGISTER_MOVE_COST (GET_MODE (src),\n+\t\t\t\t   REGNO_REG_CLASS (REGNO (src)), dclass);\n+  else\n+    /* ???   */\n+    old_cost = rtx_cost (src, SET);\n+\n+  val = cselib_lookup (src, GET_MODE (SET_DEST (set)), 0);\n+  if (! val)\n+    return 0;\n+  for (l = val->locs; l; l = l->next)\n+    {\n+      rtx this_rtx = l->loc;\n+      int this_cost;\n+\n+      if (CONSTANT_P (this_rtx) && ! references_value_p (this_rtx, 0))\n+\t{\n+#ifdef LOAD_EXTEND_OP\n+\t  if (extend_op != NIL)\n+\t    {\n+\t      HOST_WIDE_INT this_val;\n+\n+\t      /* ??? I'm lazy and don't wish to handle CONST_DOUBLE.  Other\n+\t\t constants, such as SYMBOL_REF, cannot be extended.  */\n+\t      if (GET_CODE (this_rtx) != CONST_INT)\n+\t\tcontinue;\n+\n+\t      this_val = INTVAL (this_rtx);\n+\t      switch (extend_op)\n+\t\t{\n+\t\tcase ZERO_EXTEND:\n+\t\t  this_val &= GET_MODE_MASK (GET_MODE (src));\n+\t\t  break;\n+\t\tcase SIGN_EXTEND:\n+\t\t  /* ??? In theory we're already extended.  */\n+\t\t  if (this_val == trunc_int_for_mode (this_val, GET_MODE (src)))\n+\t\t    break;\n+\t\tdefault:\n+\t\t  abort ();\n+\t\t}\n+\t      this_rtx = GEN_INT (this_val);\n+\t    }\n+#endif\n+\t  this_cost = rtx_cost (this_rtx, SET);\n+\t}\n+      else if (GET_CODE (this_rtx) == REG)\n+\t{\n+#ifdef LOAD_EXTEND_OP\n+\t  if (extend_op != NIL)\n+\t    {\n+\t      this_rtx = gen_rtx_fmt_e (extend_op, word_mode, this_rtx);\n+\t      this_cost = rtx_cost (this_rtx, SET);\n+\t    }\n+\t  else\n+#endif\n+\t    this_cost = REGISTER_MOVE_COST (GET_MODE (this_rtx),\n+\t\t\t\t\t    REGNO_REG_CLASS (REGNO (this_rtx)),\n+\t\t\t\t\t    dclass);\n+\t}\n+      else\n+\tcontinue;\n+\n+      /* If equal costs, prefer registers over anything else.  That\n+\t tends to lead to smaller instructions on some machines.  */\n+      if (this_cost < old_cost\n+\t  || (this_cost == old_cost\n+\t      && GET_CODE (this_rtx) == REG\n+\t      && GET_CODE (SET_SRC (set)) != REG))\n+\t{\n+#ifdef LOAD_EXTEND_OP\n+\t  if (GET_MODE_BITSIZE (GET_MODE (SET_DEST (set))) < BITS_PER_WORD\n+\t      && extend_op != NIL\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+\t      && !CANNOT_CHANGE_MODE_CLASS (GET_MODE (SET_DEST (set)),\n+\t\t\t\t\t    word_mode,\n+\t\t\t\t\t    REGNO_REG_CLASS (REGNO (SET_DEST (set))))\n+#endif\n+\t      )\n+\t    {\n+\t      rtx wide_dest = gen_rtx_REG (word_mode, REGNO (SET_DEST (set)));\n+\t      ORIGINAL_REGNO (wide_dest) = ORIGINAL_REGNO (SET_DEST (set));\n+\t      validate_change (insn, &SET_DEST (set), wide_dest, 1);\n+\t    }\n+#endif\n+\n+\t  validate_change (insn, &SET_SRC (set), copy_rtx (this_rtx), 1);\n+\t  old_cost = this_cost, did_change = 1;\n+\t}\n+    }\n+\n+  return did_change;\n+}\n+\n+/* Try to replace operands in INSN with equivalent values that are already\n+   in registers.  This can be viewed as optional reloading.\n+\n+   For each non-register operand in the insn, see if any hard regs are\n+   known to be equivalent to that operand.  Record the alternatives which\n+   can accept these hard registers.  Among all alternatives, select the\n+   ones which are better or equal to the one currently matching, where\n+   \"better\" is in terms of '?' and '!' constraints.  Among the remaining\n+   alternatives, select the one which replaces most operands with\n+   hard registers.  */\n+\n+static int\n+reload_cse_simplify_operands (insn, testreg)\n+     rtx insn;\n+     rtx testreg;\n+{\n+  int i, j;\n+\n+  /* For each operand, all registers that are equivalent to it.  */\n+  HARD_REG_SET equiv_regs[MAX_RECOG_OPERANDS];\n+\n+  const char *constraints[MAX_RECOG_OPERANDS];\n+\n+  /* Vector recording how bad an alternative is.  */\n+  int *alternative_reject;\n+  /* Vector recording how many registers can be introduced by choosing\n+     this alternative.  */\n+  int *alternative_nregs;\n+  /* Array of vectors recording, for each operand and each alternative,\n+     which hard register to substitute, or -1 if the operand should be\n+     left as it is.  */\n+  int *op_alt_regno[MAX_RECOG_OPERANDS];\n+  /* Array of alternatives, sorted in order of decreasing desirability.  */\n+  int *alternative_order;\n+\n+  extract_insn (insn);\n+\n+  if (recog_data.n_alternatives == 0 || recog_data.n_operands == 0)\n+    return 0;\n+\n+  /* Figure out which alternative currently matches.  */\n+  if (! constrain_operands (1))\n+    fatal_insn_not_found (insn);\n+\n+  alternative_reject = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n+  alternative_nregs = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n+  alternative_order = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n+  memset ((char *) alternative_reject, 0, recog_data.n_alternatives * sizeof (int));\n+  memset ((char *) alternative_nregs, 0, recog_data.n_alternatives * sizeof (int));\n+\n+  /* For each operand, find out which regs are equivalent.  */\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      cselib_val *v;\n+      struct elt_loc_list *l;\n+\n+      CLEAR_HARD_REG_SET (equiv_regs[i]);\n+\n+      /* cselib blows up on CODE_LABELs.  Trying to fix that doesn't seem\n+\t right, so avoid the problem here.  Likewise if we have a constant\n+         and the insn pattern doesn't tell us the mode we need.  */\n+      if (GET_CODE (recog_data.operand[i]) == CODE_LABEL\n+\t  || (CONSTANT_P (recog_data.operand[i])\n+\t      && recog_data.operand_mode[i] == VOIDmode))\n+\tcontinue;\n+\n+      v = cselib_lookup (recog_data.operand[i], recog_data.operand_mode[i], 0);\n+      if (! v)\n+\tcontinue;\n+\n+      for (l = v->locs; l; l = l->next)\n+\tif (GET_CODE (l->loc) == REG)\n+\t  SET_HARD_REG_BIT (equiv_regs[i], REGNO (l->loc));\n+    }\n+\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      enum machine_mode mode;\n+      int regno;\n+      const char *p;\n+\n+      op_alt_regno[i] = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n+      for (j = 0; j < recog_data.n_alternatives; j++)\n+\top_alt_regno[i][j] = -1;\n+\n+      p = constraints[i] = recog_data.constraints[i];\n+      mode = recog_data.operand_mode[i];\n+\n+      /* Add the reject values for each alternative given by the constraints\n+\t for this operand.  */\n+      j = 0;\n+      while (*p != '\\0')\n+\t{\n+\t  char c = *p++;\n+\t  if (c == ',')\n+\t    j++;\n+\t  else if (c == '?')\n+\t    alternative_reject[j] += 3;\n+\t  else if (c == '!')\n+\t    alternative_reject[j] += 300;\n+\t}\n+\n+      /* We won't change operands which are already registers.  We\n+\t also don't want to modify output operands.  */\n+      regno = true_regnum (recog_data.operand[i]);\n+      if (regno >= 0\n+\t  || constraints[i][0] == '='\n+\t  || constraints[i][0] == '+')\n+\tcontinue;\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t{\n+\t  int class = (int) NO_REGS;\n+\n+\t  if (! TEST_HARD_REG_BIT (equiv_regs[i], regno))\n+\t    continue;\n+\n+\t  REGNO (testreg) = regno;\n+\t  PUT_MODE (testreg, mode);\n+\n+\t  /* We found a register equal to this operand.  Now look for all\n+\t     alternatives that can accept this register and have not been\n+\t     assigned a register they can use yet.  */\n+\t  j = 0;\n+\t  p = constraints[i];\n+\t  for (;;)\n+\t    {\n+\t      char c = *p;\n+\n+\t      switch (c)\n+\t\t{\n+\t\tcase '=':  case '+':  case '?':\n+\t\tcase '#':  case '&':  case '!':\n+\t\tcase '*':  case '%':\n+\t\tcase '0':  case '1':  case '2':  case '3':  case '4':\n+\t\tcase '5':  case '6':  case '7':  case '8':  case '9':\n+\t\tcase 'm':  case '<':  case '>':  case 'V':  case 'o':\n+\t\tcase 'E':  case 'F':  case 'G':  case 'H':\n+\t\tcase 's':  case 'i':  case 'n':\n+\t\tcase 'I':  case 'J':  case 'K':  case 'L':\n+\t\tcase 'M':  case 'N':  case 'O':  case 'P':\n+\t\tcase 'p': case 'X':\n+\t\t  /* These don't say anything we care about.  */\n+\t\t  break;\n+\n+\t\tcase 'g': case 'r':\n+\t\t  class = reg_class_subunion[(int) class][(int) GENERAL_REGS];\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  class\n+\t\t    = (reg_class_subunion\n+\t\t       [(int) class]\n+\t\t       [(int) REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)]);\n+\t\t  break;\n+\n+\t\tcase ',': case '\\0':\n+\t\t  /* See if REGNO fits this alternative, and set it up as the\n+\t\t     replacement register if we don't have one for this\n+\t\t     alternative yet and the operand being replaced is not\n+\t\t     a cheap CONST_INT.  */\n+\t\t  if (op_alt_regno[i][j] == -1\n+\t\t      && reg_fits_class_p (testreg, class, 0, mode)\n+\t\t      && (GET_CODE (recog_data.operand[i]) != CONST_INT\n+\t\t\t  || (rtx_cost (recog_data.operand[i], SET)\n+\t\t\t      > rtx_cost (testreg, SET))))\n+\t\t    {\n+\t\t      alternative_nregs[j]++;\n+\t\t      op_alt_regno[i][j] = regno;\n+\t\t    }\n+\t\t  j++;\n+\t\t  break;\n+\t\t}\n+\t      p += CONSTRAINT_LEN (c, p);\n+\n+\t      if (c == '\\0')\n+\t\tbreak;\n+\t    }\n+\t}\n+    }\n+\n+  /* Record all alternatives which are better or equal to the currently\n+     matching one in the alternative_order array.  */\n+  for (i = j = 0; i < recog_data.n_alternatives; i++)\n+    if (alternative_reject[i] <= alternative_reject[which_alternative])\n+      alternative_order[j++] = i;\n+  recog_data.n_alternatives = j;\n+\n+  /* Sort it.  Given a small number of alternatives, a dumb algorithm\n+     won't hurt too much.  */\n+  for (i = 0; i < recog_data.n_alternatives - 1; i++)\n+    {\n+      int best = i;\n+      int best_reject = alternative_reject[alternative_order[i]];\n+      int best_nregs = alternative_nregs[alternative_order[i]];\n+      int tmp;\n+\n+      for (j = i + 1; j < recog_data.n_alternatives; j++)\n+\t{\n+\t  int this_reject = alternative_reject[alternative_order[j]];\n+\t  int this_nregs = alternative_nregs[alternative_order[j]];\n+\n+\t  if (this_reject < best_reject\n+\t      || (this_reject == best_reject && this_nregs < best_nregs))\n+\t    {\n+\t      best = j;\n+\t      best_reject = this_reject;\n+\t      best_nregs = this_nregs;\n+\t    }\n+\t}\n+\n+      tmp = alternative_order[best];\n+      alternative_order[best] = alternative_order[i];\n+      alternative_order[i] = tmp;\n+    }\n+\n+  /* Substitute the operands as determined by op_alt_regno for the best\n+     alternative.  */\n+  j = alternative_order[0];\n+\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      enum machine_mode mode = recog_data.operand_mode[i];\n+      if (op_alt_regno[i][j] == -1)\n+\tcontinue;\n+\n+      validate_change (insn, recog_data.operand_loc[i],\n+\t\t       gen_rtx_REG (mode, op_alt_regno[i][j]), 1);\n+    }\n+\n+  for (i = recog_data.n_dups - 1; i >= 0; i--)\n+    {\n+      int op = recog_data.dup_num[i];\n+      enum machine_mode mode = recog_data.operand_mode[op];\n+\n+      if (op_alt_regno[op][j] == -1)\n+\tcontinue;\n+\n+      validate_change (insn, recog_data.dup_loc[i],\n+\t\t       gen_rtx_REG (mode, op_alt_regno[op][j]), 1);\n+    }\n+\n+  return apply_change_group ();\n+}\n+\f\n+/* If reload couldn't use reg+reg+offset addressing, try to use reg+reg\n+   addressing now.\n+   This code might also be useful when reload gave up on reg+reg addressing\n+   because of clashes between the return register and INDEX_REG_CLASS.  */\n+\n+/* The maximum number of uses of a register we can keep track of to\n+   replace them with reg+reg addressing.  */\n+#define RELOAD_COMBINE_MAX_USES 6\n+\n+/* INSN is the insn where a register has ben used, and USEP points to the\n+   location of the register within the rtl.  */\n+struct reg_use { rtx insn, *usep; };\n+\n+/* If the register is used in some unknown fashion, USE_INDEX is negative.\n+   If it is dead, USE_INDEX is RELOAD_COMBINE_MAX_USES, and STORE_RUID\n+   indicates where it becomes live again.\n+   Otherwise, USE_INDEX is the index of the last encountered use of the\n+   register (which is first among these we have seen since we scan backwards),\n+   OFFSET contains the constant offset that is added to the register in\n+   all encountered uses, and USE_RUID indicates the first encountered, i.e.\n+   last, of these uses.\n+   STORE_RUID is always meaningful if we only want to use a value in a\n+   register in a different place: it denotes the next insn in the insn\n+   stream (i.e. the last encountered) that sets or clobbers the register.  */\n+static struct\n+  {\n+    struct reg_use reg_use[RELOAD_COMBINE_MAX_USES];\n+    int use_index;\n+    rtx offset;\n+    int store_ruid;\n+    int use_ruid;\n+  } reg_state[FIRST_PSEUDO_REGISTER];\n+\n+/* Reverse linear uid.  This is increased in reload_combine while scanning\n+   the instructions from last to first.  It is used to set last_label_ruid\n+   and the store_ruid / use_ruid fields in reg_state.  */\n+static int reload_combine_ruid;\n+\n+#define LABEL_LIVE(LABEL) \\\n+  (label_live[CODE_LABEL_NUMBER (LABEL) - min_labelno])\n+\n+static void\n+reload_combine ()\n+{\n+  rtx insn, set;\n+  int first_index_reg = -1;\n+  int last_index_reg = 0;\n+  int i;\n+  basic_block bb;\n+  unsigned int r;\n+  int last_label_ruid;\n+  int min_labelno, n_labels;\n+  HARD_REG_SET ever_live_at_start, *label_live;\n+\n+  /* If reg+reg can be used in offsetable memory addresses, the main chunk of\n+     reload has already used it where appropriate, so there is no use in\n+     trying to generate it now.  */\n+  if (double_reg_address_ok && INDEX_REG_CLASS != NO_REGS)\n+    return;\n+\n+  /* To avoid wasting too much time later searching for an index register,\n+     determine the minimum and maximum index register numbers.  */\n+  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+    if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], r))\n+      {\n+\tif (first_index_reg == -1)\n+\t  first_index_reg = r;\n+\n+\tlast_index_reg = r;\n+      }\n+\n+  /* If no index register is available, we can quit now.  */\n+  if (first_index_reg == -1)\n+    return;\n+\n+  /* Set up LABEL_LIVE and EVER_LIVE_AT_START.  The register lifetime\n+     information is a bit fuzzy immediately after reload, but it's\n+     still good enough to determine which registers are live at a jump\n+     destination.  */\n+  min_labelno = get_first_label_num ();\n+  n_labels = max_label_num () - min_labelno;\n+  label_live = (HARD_REG_SET *) xmalloc (n_labels * sizeof (HARD_REG_SET));\n+  CLEAR_HARD_REG_SET (ever_live_at_start);\n+\n+  FOR_EACH_BB_REVERSE (bb)\n+    {\n+      insn = bb->head;\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  HARD_REG_SET live;\n+\n+\t  REG_SET_TO_HARD_REG_SET (live,\n+\t\t\t\t   bb->global_live_at_start);\n+\t  compute_use_by_pseudos (&live,\n+\t\t\t\t  bb->global_live_at_start);\n+\t  COPY_HARD_REG_SET (LABEL_LIVE (insn), live);\n+\t  IOR_HARD_REG_SET (ever_live_at_start, live);\n+\t}\n+    }\n+\n+  /* Initialize last_label_ruid, reload_combine_ruid and reg_state.  */\n+  last_label_ruid = reload_combine_ruid = 0;\n+  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+    {\n+      reg_state[r].store_ruid = reload_combine_ruid;\n+      if (fixed_regs[r])\n+\treg_state[r].use_index = -1;\n+      else\n+\treg_state[r].use_index = RELOAD_COMBINE_MAX_USES;\n+    }\n+\n+  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+    {\n+      rtx note;\n+\n+      /* We cannot do our optimization across labels.  Invalidating all the use\n+\t information we have would be costly, so we just note where the label\n+\t is and then later disable any optimization that would cross it.  */\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tlast_label_ruid = reload_combine_ruid;\n+      else if (GET_CODE (insn) == BARRIER)\n+\tfor (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+\t  if (! fixed_regs[r])\n+\t      reg_state[r].use_index = RELOAD_COMBINE_MAX_USES;\n+\n+      if (! INSN_P (insn))\n+\tcontinue;\n+\n+      reload_combine_ruid++;\n+\n+      /* Look for (set (REGX) (CONST_INT))\n+\t (set (REGX) (PLUS (REGX) (REGY)))\n+\t ...\n+\t ... (MEM (REGX)) ...\n+\t and convert it to\n+\t (set (REGZ) (CONST_INT))\n+\t ...\n+\t ... (MEM (PLUS (REGZ) (REGY)))... .\n+\n+\t First, check that we have (set (REGX) (PLUS (REGX) (REGY)))\n+\t and that we know all uses of REGX before it dies.  */\n+      set = single_set (insn);\n+      if (set != NULL_RTX\n+\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && (HARD_REGNO_NREGS (REGNO (SET_DEST (set)),\n+\t\t\t\tGET_MODE (SET_DEST (set)))\n+\t      == 1)\n+\t  && GET_CODE (SET_SRC (set)) == PLUS\n+\t  && GET_CODE (XEXP (SET_SRC (set), 1)) == REG\n+\t  && rtx_equal_p (XEXP (SET_SRC (set), 0), SET_DEST (set))\n+\t  && last_label_ruid < reg_state[REGNO (SET_DEST (set))].use_ruid)\n+\t{\n+\t  rtx reg = SET_DEST (set);\n+\t  rtx plus = SET_SRC (set);\n+\t  rtx base = XEXP (plus, 1);\n+\t  rtx prev = prev_nonnote_insn (insn);\n+\t  rtx prev_set = prev ? single_set (prev) : NULL_RTX;\n+\t  unsigned int regno = REGNO (reg);\n+\t  rtx const_reg = NULL_RTX;\n+\t  rtx reg_sum = NULL_RTX;\n+\n+\t  /* Now, we need an index register.\n+\t     We'll set index_reg to this index register, const_reg to the\n+\t     register that is to be loaded with the constant\n+\t     (denoted as REGZ in the substitution illustration above),\n+\t     and reg_sum to the register-register that we want to use to\n+\t     substitute uses of REG (typically in MEMs) with.\n+\t     First check REG and BASE for being index registers;\n+\t     we can use them even if they are not dead.  */\n+\t  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], regno)\n+\t      || TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS],\n+\t\t\t\t    REGNO (base)))\n+\t    {\n+\t      const_reg = reg;\n+\t      reg_sum = plus;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, look for a free index register.  Since we have\n+\t\t checked above that neiter REG nor BASE are index registers,\n+\t\t if we find anything at all, it will be different from these\n+\t\t two registers.  */\n+\t      for (i = first_index_reg; i <= last_index_reg; i++)\n+\t\t{\n+\t\t  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS],\n+\t\t\t\t\t i)\n+\t\t      && reg_state[i].use_index == RELOAD_COMBINE_MAX_USES\n+\t\t      && reg_state[i].store_ruid <= reg_state[regno].use_ruid\n+\t\t      && HARD_REGNO_NREGS (i, GET_MODE (reg)) == 1)\n+\t\t    {\n+\t\t      rtx index_reg = gen_rtx_REG (GET_MODE (reg), i);\n+\n+\t\t      const_reg = index_reg;\n+\t\t      reg_sum = gen_rtx_PLUS (GET_MODE (reg), index_reg, base);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* Check that PREV_SET is indeed (set (REGX) (CONST_INT)) and that\n+\t     (REGY), i.e. BASE, is not clobbered before the last use we'll\n+\t     create.  */\n+\t  if (prev_set != 0\n+\t      && GET_CODE (SET_SRC (prev_set)) == CONST_INT\n+\t      && rtx_equal_p (SET_DEST (prev_set), reg)\n+\t      && reg_state[regno].use_index >= 0\n+\t      && (reg_state[REGNO (base)].store_ruid\n+\t\t  <= reg_state[regno].use_ruid)\n+\t      && reg_sum != 0)\n+\t    {\n+\t      int i;\n+\n+\t      /* Change destination register and, if necessary, the\n+\t\t constant value in PREV, the constant loading instruction.  */\n+\t      validate_change (prev, &SET_DEST (prev_set), const_reg, 1);\n+\t      if (reg_state[regno].offset != const0_rtx)\n+\t\tvalidate_change (prev,\n+\t\t\t\t &SET_SRC (prev_set),\n+\t\t\t\t GEN_INT (INTVAL (SET_SRC (prev_set))\n+\t\t\t\t\t  + INTVAL (reg_state[regno].offset)),\n+\t\t\t\t 1);\n+\n+\t      /* Now for every use of REG that we have recorded, replace REG\n+\t\t with REG_SUM.  */\n+\t      for (i = reg_state[regno].use_index;\n+\t\t   i < RELOAD_COMBINE_MAX_USES; i++)\n+\t\tvalidate_change (reg_state[regno].reg_use[i].insn,\n+\t\t\t\t reg_state[regno].reg_use[i].usep,\n+\t\t\t\t /* Each change must have its own\n+\t\t\t\t    replacement.  */\n+\t\t\t\t copy_rtx (reg_sum), 1);\n+\n+\t      if (apply_change_group ())\n+\t\t{\n+\t\t  rtx *np;\n+\n+\t\t  /* Delete the reg-reg addition.  */\n+\t\t  delete_insn (insn);\n+\n+\t\t  if (reg_state[regno].offset != const0_rtx)\n+\t\t    /* Previous REG_EQUIV / REG_EQUAL notes for PREV\n+\t\t       are now invalid.  */\n+\t\t    for (np = &REG_NOTES (prev); *np;)\n+\t\t      {\n+\t\t\tif (REG_NOTE_KIND (*np) == REG_EQUAL\n+\t\t\t    || REG_NOTE_KIND (*np) == REG_EQUIV)\n+\t\t\t  *np = XEXP (*np, 1);\n+\t\t\telse\n+\t\t\t  np = &XEXP (*np, 1);\n+\t\t      }\n+\n+\t\t  reg_state[regno].use_index = RELOAD_COMBINE_MAX_USES;\n+\t\t  reg_state[REGNO (const_reg)].store_ruid\n+\t\t    = reload_combine_ruid;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t}\n+\n+      note_stores (PATTERN (insn), reload_combine_note_store, NULL);\n+\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  rtx link;\n+\n+\t  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+\t    if (call_used_regs[r])\n+\t      {\n+\t\treg_state[r].use_index = RELOAD_COMBINE_MAX_USES;\n+\t\treg_state[r].store_ruid = reload_combine_ruid;\n+\t      }\n+\n+\t  for (link = CALL_INSN_FUNCTION_USAGE (insn); link;\n+\t       link = XEXP (link, 1))\n+\t    {\n+\t      rtx usage_rtx = XEXP (XEXP (link, 0), 0);\n+\t      if (GET_CODE (usage_rtx) == REG)\n+\t        {\n+\t\t  unsigned int i;\n+\t\t  unsigned int start_reg = REGNO (usage_rtx);\n+\t\t  unsigned int num_regs =\n+\t\t\tHARD_REGNO_NREGS (start_reg, GET_MODE (usage_rtx));\n+\t\t  unsigned int end_reg  = start_reg + num_regs - 1;\n+\t\t  for (i = start_reg; i <= end_reg; i++)\n+\t\t    if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n+\t\t      {\n+\t\t        reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n+\t\t        reg_state[i].store_ruid = reload_combine_ruid;\n+\t\t      }\n+\t\t    else\n+\t\t      reg_state[i].use_index = -1;\n+\t         }\n+\t     }\n+\n+\t}\n+      else if (GET_CODE (insn) == JUMP_INSN\n+\t       && GET_CODE (PATTERN (insn)) != RETURN)\n+\t{\n+\t  /* Non-spill registers might be used at the call destination in\n+\t     some unknown fashion, so we have to mark the unknown use.  */\n+\t  HARD_REG_SET *live;\n+\n+\t  if ((condjump_p (insn) || condjump_in_parallel_p (insn))\n+\t      && JUMP_LABEL (insn))\n+\t    live = &LABEL_LIVE (JUMP_LABEL (insn));\n+\t  else\n+\t    live = &ever_live_at_start;\n+\n+\t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n+\t    if (TEST_HARD_REG_BIT (*live, i))\n+\t      reg_state[i].use_index = -1;\n+\t}\n+\n+      reload_combine_note_use (&PATTERN (insn), insn);\n+      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t{\n+\t  if (REG_NOTE_KIND (note) == REG_INC\n+\t      && GET_CODE (XEXP (note, 0)) == REG)\n+\t    {\n+\t      int regno = REGNO (XEXP (note, 0));\n+\n+\t      reg_state[regno].store_ruid = reload_combine_ruid;\n+\t      reg_state[regno].use_index = -1;\n+\t    }\n+\t}\n+    }\n+\n+  free (label_live);\n+}\n+\n+/* Check if DST is a register or a subreg of a register; if it is,\n+   update reg_state[regno].store_ruid and reg_state[regno].use_index\n+   accordingly.  Called via note_stores from reload_combine.  */\n+\n+static void\n+reload_combine_note_store (dst, set, data)\n+     rtx dst, set;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  int regno = 0;\n+  int i;\n+  enum machine_mode mode = GET_MODE (dst);\n+\n+  if (GET_CODE (dst) == SUBREG)\n+    {\n+      regno = subreg_regno_offset (REGNO (SUBREG_REG (dst)),\n+\t\t\t\t   GET_MODE (SUBREG_REG (dst)),\n+\t\t\t\t   SUBREG_BYTE (dst),\n+\t\t\t\t   GET_MODE (dst));\n+      dst = SUBREG_REG (dst);\n+    }\n+  if (GET_CODE (dst) != REG)\n+    return;\n+  regno += REGNO (dst);\n+\n+  /* note_stores might have stripped a STRICT_LOW_PART, so we have to be\n+     careful with registers / register parts that are not full words.\n+\n+     Similarly for ZERO_EXTRACT and SIGN_EXTRACT.  */\n+  if (GET_CODE (set) != SET\n+      || GET_CODE (SET_DEST (set)) == ZERO_EXTRACT\n+      || GET_CODE (SET_DEST (set)) == SIGN_EXTRACT\n+      || GET_CODE (SET_DEST (set)) == STRICT_LOW_PART)\n+    {\n+      for (i = HARD_REGNO_NREGS (regno, mode) - 1 + regno; i >= regno; i--)\n+\t{\n+\t  reg_state[i].use_index = -1;\n+\t  reg_state[i].store_ruid = reload_combine_ruid;\n+\t}\n+    }\n+  else\n+    {\n+      for (i = HARD_REGNO_NREGS (regno, mode) - 1 + regno; i >= regno; i--)\n+\t{\n+\t  reg_state[i].store_ruid = reload_combine_ruid;\n+\t  reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n+\t}\n+    }\n+}\n+\n+/* XP points to a piece of rtl that has to be checked for any uses of\n+   registers.\n+   *XP is the pattern of INSN, or a part of it.\n+   Called from reload_combine, and recursively by itself.  */\n+static void\n+reload_combine_note_use (xp, insn)\n+     rtx *xp, insn;\n+{\n+  rtx x = *xp;\n+  enum rtx_code code = x->code;\n+  const char *fmt;\n+  int i, j;\n+  rtx offset = const0_rtx; /* For the REG case below.  */\n+\n+  switch (code)\n+    {\n+    case SET:\n+      if (GET_CODE (SET_DEST (x)) == REG)\n+\t{\n+\t  reload_combine_note_use (&SET_SRC (x), insn);\n+\t  return;\n+\t}\n+      break;\n+\n+    case USE:\n+      /* If this is the USE of a return value, we can't change it.  */\n+      if (GET_CODE (XEXP (x, 0)) == REG && REG_FUNCTION_VALUE_P (XEXP (x, 0)))\n+\t{\n+\t/* Mark the return register as used in an unknown fashion.  */\n+\t  rtx reg = XEXP (x, 0);\n+\t  int regno = REGNO (reg);\n+\t  int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\n+\t  while (--nregs >= 0)\n+\t    reg_state[regno + nregs].use_index = -1;\n+\t  return;\n+\t}\n+      break;\n+\n+    case CLOBBER:\n+      if (GET_CODE (SET_DEST (x)) == REG)\n+\t{\n+\t  /* No spurious CLOBBERs of pseudo registers may remain.  */\n+\t  if (REGNO (SET_DEST (x)) >= FIRST_PSEUDO_REGISTER)\n+\t    abort ();\n+\t  return;\n+\t}\n+      break;\n+\n+    case PLUS:\n+      /* We are interested in (plus (reg) (const_int)) .  */\n+      if (GET_CODE (XEXP (x, 0)) != REG\n+\t  || GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\tbreak;\n+      offset = XEXP (x, 1);\n+      x = XEXP (x, 0);\n+      /* Fall through.  */\n+    case REG:\n+      {\n+\tint regno = REGNO (x);\n+\tint use_index;\n+\tint nregs;\n+\n+\t/* No spurious USEs of pseudo registers may remain.  */\n+\tif (regno >= FIRST_PSEUDO_REGISTER)\n+\t  abort ();\n+\n+\tnregs = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\n+\t/* We can't substitute into multi-hard-reg uses.  */\n+\tif (nregs > 1)\n+\t  {\n+\t    while (--nregs >= 0)\n+\t      reg_state[regno + nregs].use_index = -1;\n+\t    return;\n+\t  }\n+\n+\t/* If this register is already used in some unknown fashion, we\n+\t   can't do anything.\n+\t   If we decrement the index from zero to -1, we can't store more\n+\t   uses, so this register becomes used in an unknown fashion.  */\n+\tuse_index = --reg_state[regno].use_index;\n+\tif (use_index < 0)\n+\t  return;\n+\n+\tif (use_index != RELOAD_COMBINE_MAX_USES - 1)\n+\t  {\n+\t    /* We have found another use for a register that is already\n+\t       used later.  Check if the offsets match; if not, mark the\n+\t       register as used in an unknown fashion.  */\n+\t    if (! rtx_equal_p (offset, reg_state[regno].offset))\n+\t      {\n+\t\treg_state[regno].use_index = -1;\n+\t\treturn;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    /* This is the first use of this register we have seen since we\n+\t       marked it as dead.  */\n+\t    reg_state[regno].offset = offset;\n+\t    reg_state[regno].use_ruid = reload_combine_ruid;\n+\t  }\n+\treg_state[regno].reg_use[use_index].insn = insn;\n+\treg_state[regno].reg_use[use_index].usep = xp;\n+\treturn;\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Recursively process the components of X.  */\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\treload_combine_note_use (&XEXP (x, i), insn);\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    reload_combine_note_use (&XVECEXP (x, i, j), insn);\n+\t}\n+    }\n+}\n+\f\n+/* See if we can reduce the cost of a constant by replacing a move\n+   with an add.  We track situations in which a register is set to a\n+   constant or to a register plus a constant.  */\n+/* We cannot do our optimization across labels.  Invalidating all the\n+   information about register contents we have would be costly, so we\n+   use move2add_last_label_luid to note where the label is and then\n+   later disable any optimization that would cross it.\n+   reg_offset[n] / reg_base_reg[n] / reg_mode[n] are only valid if\n+   reg_set_luid[n] is greater than move2add_last_label_luid.  */\n+static int reg_set_luid[FIRST_PSEUDO_REGISTER];\n+\n+/* If reg_base_reg[n] is negative, register n has been set to\n+   reg_offset[n] in mode reg_mode[n] .\n+   If reg_base_reg[n] is non-negative, register n has been set to the\n+   sum of reg_offset[n] and the value of register reg_base_reg[n]\n+   before reg_set_luid[n], calculated in mode reg_mode[n] .  */\n+static HOST_WIDE_INT reg_offset[FIRST_PSEUDO_REGISTER];\n+static int reg_base_reg[FIRST_PSEUDO_REGISTER];\n+static enum machine_mode reg_mode[FIRST_PSEUDO_REGISTER];\n+\n+/* move2add_luid is linearly increased while scanning the instructions\n+   from first to last.  It is used to set reg_set_luid in\n+   reload_cse_move2add and move2add_note_store.  */\n+static int move2add_luid;\n+\n+/* move2add_last_label_luid is set whenever a label is found.  Labels\n+   invalidate all previously collected reg_offset data.  */\n+static int move2add_last_label_luid;\n+\n+/* ??? We don't know how zero / sign extension is handled, hence we\n+   can't go from a narrower to a wider mode.  */\n+#define MODES_OK_FOR_MOVE2ADD(OUTMODE, INMODE) \\\n+  (GET_MODE_SIZE (OUTMODE) == GET_MODE_SIZE (INMODE) \\\n+   || (GET_MODE_SIZE (OUTMODE) <= GET_MODE_SIZE (INMODE) \\\n+       && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (OUTMODE), \\\n+\t\t\t\t GET_MODE_BITSIZE (INMODE))))\n+\n+static void\n+reload_cse_move2add (first)\n+     rtx first;\n+{\n+  int i;\n+  rtx insn;\n+\n+  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n+    reg_set_luid[i] = 0;\n+\n+  move2add_last_label_luid = 0;\n+  move2add_luid = 2;\n+  for (insn = first; insn; insn = NEXT_INSN (insn), move2add_luid++)\n+    {\n+      rtx pat, note;\n+\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  move2add_last_label_luid = move2add_luid;\n+\t  /* We're going to increment move2add_luid twice after a\n+\t     label, so that we can use move2add_last_label_luid + 1 as\n+\t     the luid for constants.  */\n+\t  move2add_luid++;\n+\t  continue;\n+\t}\n+      if (! INSN_P (insn))\n+\tcontinue;\n+      pat = PATTERN (insn);\n+      /* For simplicity, we only perform this optimization on\n+\t straightforward SETs.  */\n+      if (GET_CODE (pat) == SET\n+\t  && GET_CODE (SET_DEST (pat)) == REG)\n+\t{\n+\t  rtx reg = SET_DEST (pat);\n+\t  int regno = REGNO (reg);\n+\t  rtx src = SET_SRC (pat);\n+\n+\t  /* Check if we have valid information on the contents of this\n+\t     register in the mode of REG.  */\n+\t  if (reg_set_luid[regno] > move2add_last_label_luid\n+\t      && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg), reg_mode[regno]))\n+\t    {\n+\t      /* Try to transform (set (REGX) (CONST_INT A))\n+\t\t\t\t  ...\n+\t\t\t\t  (set (REGX) (CONST_INT B))\n+\t\t to\n+\t\t\t\t  (set (REGX) (CONST_INT A))\n+\t\t\t\t  ...\n+\t\t\t\t  (set (REGX) (plus (REGX) (CONST_INT B-A)))\n+\t\t or\n+\t\t\t\t  (set (REGX) (CONST_INT A))\n+\t\t\t\t  ...\n+\t\t\t\t  (set (STRICT_LOW_PART (REGX)) (CONST_INT B))\n+\t      */\n+\n+\t      if (GET_CODE (src) == CONST_INT && reg_base_reg[regno] < 0)\n+\t\t{\n+\t\t  rtx new_src =\n+\t\t    GEN_INT (trunc_int_for_mode (INTVAL (src)\n+\t\t\t\t\t\t - reg_offset[regno],\n+\t\t\t\t\t\t GET_MODE (reg)));\n+\t\t  /* (set (reg) (plus (reg) (const_int 0))) is not canonical;\n+\t\t     use (set (reg) (reg)) instead.\n+\t\t     We don't delete this insn, nor do we convert it into a\n+\t\t     note, to avoid losing register notes or the return\n+\t\t     value flag.  jump2 already knows how to get rid of\n+\t\t     no-op moves.  */\n+\t\t  if (new_src == const0_rtx)\n+\t\t    {\n+\t\t      /* If the constants are different, this is a\n+\t\t\t truncation, that, if turned into (set (reg)\n+\t\t\t (reg)), would be discarded.  Maybe we should\n+\t\t\t try a truncMN pattern?  */\n+\t\t      if (INTVAL (src) == reg_offset [regno])\n+\t\t\tvalidate_change (insn, &SET_SRC (pat), reg, 0);\n+\t\t    }\n+\t\t  else if (rtx_cost (new_src, PLUS) < rtx_cost (src, SET)\n+\t\t\t   && have_add2_insn (reg, new_src))\n+\t\t    {\n+\t\t      rtx newpat = gen_add2_insn (reg, new_src);\n+\t\t      if (INSN_P (newpat) && NEXT_INSN (newpat) == NULL_RTX)\n+\t\t\tnewpat = PATTERN (newpat);\n+\t\t      /* If it was the first insn of a sequence or\n+\t\t\t some other emitted insn, validate_change will\n+\t\t\t reject it.  */\n+\t\t      validate_change (insn, &PATTERN (insn),\n+\t\t\t\t       newpat, 0);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      enum machine_mode narrow_mode;\n+\t\t      for (narrow_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t\t\t   narrow_mode != GET_MODE (reg);\n+\t\t\t   narrow_mode = GET_MODE_WIDER_MODE (narrow_mode))\n+\t\t\t{\n+\t\t\t  if (have_insn_for (STRICT_LOW_PART, narrow_mode)\n+\t\t\t      && ((reg_offset[regno]\n+\t\t\t\t   & ~GET_MODE_MASK (narrow_mode))\n+\t\t\t\t  == (INTVAL (src)\n+\t\t\t\t      & ~GET_MODE_MASK (narrow_mode))))\n+\t\t\t    {\n+\t\t\t      rtx narrow_reg = gen_rtx_REG (narrow_mode,\n+\t\t\t\t\t\t\t    REGNO (reg));\n+\t\t\t      rtx narrow_src =\n+\t\t\t\tGEN_INT (trunc_int_for_mode (INTVAL (src),\n+\t\t\t\t\t\t\t     narrow_mode));\n+\t\t\t      rtx new_set =\n+\t\t\t\tgen_rtx_SET (VOIDmode,\n+\t\t\t\t\t     gen_rtx_STRICT_LOW_PART (VOIDmode,\n+\t\t\t\t\t\t\t\t      narrow_reg),\n+\t\t\t\t\t     narrow_src);\n+\t\t\t      if (validate_change (insn, &PATTERN (insn),\n+\t\t\t\t\t\t   new_set, 0))\n+\t\t\t\tbreak;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  reg_set_luid[regno] = move2add_luid;\n+\t\t  reg_mode[regno] = GET_MODE (reg);\n+\t\t  reg_offset[regno] = INTVAL (src);\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* Try to transform (set (REGX) (REGY))\n+\t\t\t\t  (set (REGX) (PLUS (REGX) (CONST_INT A)))\n+\t\t\t\t  ...\n+\t\t\t\t  (set (REGX) (REGY))\n+\t\t\t\t  (set (REGX) (PLUS (REGX) (CONST_INT B)))\n+\t\t to\n+\t\t\t\t  (set (REGX) (REGY))\n+\t\t\t\t  (set (REGX) (PLUS (REGX) (CONST_INT A)))\n+\t\t\t\t  ...\n+\t\t\t\t  (set (REGX) (plus (REGX) (CONST_INT B-A)))  */\n+\t      else if (GET_CODE (src) == REG\n+\t\t       && reg_set_luid[regno] == reg_set_luid[REGNO (src)]\n+\t\t       && reg_base_reg[regno] == reg_base_reg[REGNO (src)]\n+\t\t       && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg),\n+\t\t\t\t\t\t reg_mode[REGNO (src)]))\n+\t\t{\n+\t\t  rtx next = next_nonnote_insn (insn);\n+\t\t  rtx set = NULL_RTX;\n+\t\t  if (next)\n+\t\t    set = single_set (next);\n+\t\t  if (set\n+\t\t      && SET_DEST (set) == reg\n+\t\t      && GET_CODE (SET_SRC (set)) == PLUS\n+\t\t      && XEXP (SET_SRC (set), 0) == reg\n+\t\t      && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n+\t\t    {\n+\t\t      rtx src3 = XEXP (SET_SRC (set), 1);\n+\t\t      HOST_WIDE_INT added_offset = INTVAL (src3);\n+\t\t      HOST_WIDE_INT base_offset = reg_offset[REGNO (src)];\n+\t\t      HOST_WIDE_INT regno_offset = reg_offset[regno];\n+\t\t      rtx new_src =\n+\t\t\tGEN_INT (trunc_int_for_mode (added_offset\n+\t\t\t\t\t\t     + base_offset\n+\t\t\t\t\t\t     - regno_offset,\n+\t\t\t\t\t\t     GET_MODE (reg)));\n+\t\t      int success = 0;\n+\n+\t\t      if (new_src == const0_rtx)\n+\t\t\t/* See above why we create (set (reg) (reg)) here.  */\n+\t\t\tsuccess\n+\t\t\t  = validate_change (next, &SET_SRC (set), reg, 0);\n+\t\t      else if ((rtx_cost (new_src, PLUS)\n+\t\t\t\t< COSTS_N_INSNS (1) + rtx_cost (src3, SET))\n+\t\t\t       && have_add2_insn (reg, new_src))\n+\t\t\t{\n+\t\t\t  rtx newpat = gen_add2_insn (reg, new_src);\n+\t\t\t  if (INSN_P (newpat)\n+\t\t\t      && NEXT_INSN (newpat) == NULL_RTX)\n+\t\t\t    newpat = PATTERN (newpat);\n+\t\t\t  success\n+\t\t\t    = validate_change (next, &PATTERN (next),\n+\t\t\t\t\t       newpat, 0);\n+\t\t\t}\n+\t\t      if (success)\n+\t\t\tdelete_insn (insn);\n+\t\t      insn = next;\n+\t\t      reg_mode[regno] = GET_MODE (reg);\n+\t\t      reg_offset[regno] =\n+\t\t\ttrunc_int_for_mode (added_offset + base_offset,\n+\t\t\t\t\t    GET_MODE (reg));\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t{\n+\t  if (REG_NOTE_KIND (note) == REG_INC\n+\t      && GET_CODE (XEXP (note, 0)) == REG)\n+\t    {\n+\t      /* Reset the information about this register.  */\n+\t      int regno = REGNO (XEXP (note, 0));\n+\t      if (regno < FIRST_PSEUDO_REGISTER)\n+\t\treg_set_luid[regno] = 0;\n+\t    }\n+\t}\n+      note_stores (PATTERN (insn), move2add_note_store, NULL);\n+\n+      /* If INSN is a conditional branch, we try to extract an\n+\t implicit set out of it.  */\n+      if (any_condjump_p (insn) && onlyjump_p (insn))\n+\t{\n+\t  rtx cnd = fis_get_condition (insn);\n+\n+\t  if (cnd != NULL_RTX\n+\t      && GET_CODE (cnd) == NE\n+\t      && GET_CODE (XEXP (cnd, 0)) == REG\n+\t      /* The following two checks, which are also in\n+\t\t move2add_note_store, are intended to reduce the\n+\t\t number of calls to gen_rtx_SET to avoid memory\n+\t\t allocation if possible.  */\n+\t      && SCALAR_INT_MODE_P (GET_MODE (XEXP (cnd, 0)))\n+\t      && HARD_REGNO_NREGS (REGNO (XEXP (cnd, 0)), GET_MODE (XEXP (cnd, 0))) == 1\n+\t      && GET_CODE (XEXP (cnd, 1)) == CONST_INT)\n+\t    {\n+\t      rtx implicit_set =\n+\t\tgen_rtx_SET (VOIDmode, XEXP (cnd, 0), XEXP (cnd, 1));\n+\t      move2add_note_store (SET_DEST (implicit_set), implicit_set, 0);\n+\t    }\n+\t}\n+\n+      /* If this is a CALL_INSN, all call used registers are stored with\n+\t unknown values.  */\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n+\t    {\n+\t      if (call_used_regs[i])\n+\t\t/* Reset the information about this register.  */\n+\t\treg_set_luid[i] = 0;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* SET is a SET or CLOBBER that sets DST.\n+   Update reg_set_luid, reg_offset and reg_base_reg accordingly.\n+   Called from reload_cse_move2add via note_stores.  */\n+\n+static void\n+move2add_note_store (dst, set, data)\n+     rtx dst, set;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  unsigned int regno = 0;\n+  unsigned int i;\n+  enum machine_mode mode = GET_MODE (dst);\n+\n+  if (GET_CODE (dst) == SUBREG)\n+    {\n+      regno = subreg_regno_offset (REGNO (SUBREG_REG (dst)),\n+\t\t\t\t   GET_MODE (SUBREG_REG (dst)),\n+\t\t\t\t   SUBREG_BYTE (dst),\n+\t\t\t\t   GET_MODE (dst));\n+      dst = SUBREG_REG (dst);\n+    }\n+\n+  /* Some targets do argument pushes without adding REG_INC notes.  */\n+\n+  if (GET_CODE (dst) == MEM)\n+    {\n+      dst = XEXP (dst, 0);\n+      if (GET_CODE (dst) == PRE_INC || GET_CODE (dst) == POST_INC\n+\t  || GET_CODE (dst) == PRE_DEC || GET_CODE (dst) == POST_DEC)\n+\treg_set_luid[REGNO (XEXP (dst, 0))] = 0;\n+      return;\n+    }\n+  if (GET_CODE (dst) != REG)\n+    return;\n+\n+  regno += REGNO (dst);\n+\n+  if (SCALAR_INT_MODE_P (mode)\n+      && HARD_REGNO_NREGS (regno, mode) == 1 && GET_CODE (set) == SET\n+      && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT\n+      && GET_CODE (SET_DEST (set)) != SIGN_EXTRACT\n+      && GET_CODE (SET_DEST (set)) != STRICT_LOW_PART)\n+    {\n+      rtx src = SET_SRC (set);\n+      rtx base_reg;\n+      HOST_WIDE_INT offset;\n+      int base_regno;\n+      /* This may be different from mode, if SET_DEST (set) is a\n+\t SUBREG.  */\n+      enum machine_mode dst_mode = GET_MODE (dst);\n+\n+      switch (GET_CODE (src))\n+\t{\n+\tcase PLUS:\n+\t  if (GET_CODE (XEXP (src, 0)) == REG)\n+\t    {\n+\t      base_reg = XEXP (src, 0);\n+\n+\t      if (GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\toffset = INTVAL (XEXP (src, 1));\n+\t      else if (GET_CODE (XEXP (src, 1)) == REG\n+\t\t       && (reg_set_luid[REGNO (XEXP (src, 1))]\n+\t\t\t   > move2add_last_label_luid)\n+\t\t       && (MODES_OK_FOR_MOVE2ADD\n+\t\t\t   (dst_mode, reg_mode[REGNO (XEXP (src, 1))])))\n+\t\t{\n+\t\t  if (reg_base_reg[REGNO (XEXP (src, 1))] < 0)\n+\t\t    offset = reg_offset[REGNO (XEXP (src, 1))];\n+\t\t  /* Maybe the first register is known to be a\n+\t\t     constant.  */\n+\t\t  else if (reg_set_luid[REGNO (base_reg)]\n+\t\t\t   > move2add_last_label_luid\n+\t\t\t   && (MODES_OK_FOR_MOVE2ADD\n+\t\t\t       (dst_mode, reg_mode[REGNO (XEXP (src, 1))]))\n+\t\t\t   && reg_base_reg[REGNO (base_reg)] < 0)\n+\t\t    {\n+\t\t      offset = reg_offset[REGNO (base_reg)];\n+\t\t      base_reg = XEXP (src, 1);\n+\t\t    }\n+\t\t  else\n+\t\t    goto invalidate;\n+\t\t}\n+\t      else\n+\t\tgoto invalidate;\n+\n+\t      break;\n+\t    }\n+\n+\t  goto invalidate;\n+\n+\tcase REG:\n+\t  base_reg = src;\n+\t  offset = 0;\n+\t  break;\n+\n+\tcase CONST_INT:\n+\t  /* Start tracking the register as a constant.  */\n+\t  reg_base_reg[regno] = -1;\n+\t  reg_offset[regno] = INTVAL (SET_SRC (set));\n+\t  /* We assign the same luid to all registers set to constants.  */\n+\t  reg_set_luid[regno] = move2add_last_label_luid + 1;\n+\t  reg_mode[regno] = mode;\n+\t  return;\n+\n+\tdefault:\n+\tinvalidate:\n+\t  /* Invalidate the contents of the register.  */\n+\t  reg_set_luid[regno] = 0;\n+\t  return;\n+\t}\n+\n+      base_regno = REGNO (base_reg);\n+      /* If information about the base register is not valid, set it\n+\t up as a new base register, pretending its value is known\n+\t starting from the current insn.  */\n+      if (reg_set_luid[base_regno] <= move2add_last_label_luid)\n+\t{\n+\t  reg_base_reg[base_regno] = base_regno;\n+\t  reg_offset[base_regno] = 0;\n+\t  reg_set_luid[base_regno] = move2add_luid;\n+\t  reg_mode[base_regno] = mode;\n+\t}\n+      else if (! MODES_OK_FOR_MOVE2ADD (dst_mode,\n+\t\t\t\t\treg_mode[base_regno]))\n+\tgoto invalidate;\n+\n+      reg_mode[regno] = mode;\n+\n+      /* Copy base information from our base register.  */\n+      reg_set_luid[regno] = reg_set_luid[base_regno];\n+      reg_base_reg[regno] = reg_base_reg[base_regno];\n+\n+      /* Compute the sum of the offsets or constants.  */\n+      reg_offset[regno] = trunc_int_for_mode (offset\n+\t\t\t\t\t      + reg_offset[base_regno],\n+\t\t\t\t\t      dst_mode);\n+    }\n+  else\n+    {\n+      unsigned int endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+\n+      for (i = regno; i < endregno; i++)\n+\t/* Reset the information about this register.  */\n+\treg_set_luid[i] = 0;\n+    }\n+}"}, {"sha": "b163339d9b4fdff82da2eaeffb87004ce3ea88ec", "filename": "gcc/reload.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e35479ebbb6b462f01b0f0330c2398089a33ed/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e35479ebbb6b462f01b0f0330c2398089a33ed/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=15e35479ebbb6b462f01b0f0330c2398089a33ed", "patch": "@@ -338,9 +338,10 @@ extern int push_reload PARAMS ((rtx, rtx, rtx *, rtx *, enum reg_class,\n \t\t\t\tenum machine_mode, enum machine_mode,\n \t\t\t\tint, int, int, enum reload_type));\n \n-/* Functions in reload1.c:  */\n-\n+/* Functions in postreload.c:  */\n extern void reload_cse_regs\t\tPARAMS ((rtx));\n+\n+/* Functions in reload1.c:  */\n extern int reloads_conflict\t\tPARAMS ((int, int));\n \n /* Initialize the reload pass once per compilation.  */"}, {"sha": "bd9c0184ecf5fa5852e16102968af94c169e347a", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 1472, "changes": 1472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e35479ebbb6b462f01b0f0330c2398089a33ed/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e35479ebbb6b462f01b0f0330c2398089a33ed/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=15e35479ebbb6b462f01b0f0330c2398089a33ed", "patch": "@@ -39,7 +39,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"reload.h\"\n #include \"recog.h\"\n #include \"output.h\"\n-#include \"cselib.h\"\n #include \"real.h\"\n #include \"toplev.h\"\n #include \"except.h\"\n@@ -440,20 +439,10 @@ static void delete_output_reload\tPARAMS ((rtx, int, int));\n static void delete_address_reloads\tPARAMS ((rtx, rtx));\n static void delete_address_reloads_1\tPARAMS ((rtx, rtx, rtx));\n static rtx inc_for_reload\t\tPARAMS ((rtx, rtx, rtx, int));\n-static void reload_cse_regs_1\t\tPARAMS ((rtx));\n-static int reload_cse_noop_set_p\tPARAMS ((rtx));\n-static int reload_cse_simplify_set\tPARAMS ((rtx, rtx));\n-static int reload_cse_simplify_operands\tPARAMS ((rtx, rtx));\n-static void reload_combine\t\tPARAMS ((void));\n-static void reload_combine_note_use\tPARAMS ((rtx *, rtx));\n-static void reload_combine_note_store\tPARAMS ((rtx, rtx, void *));\n-static void reload_cse_move2add\t\tPARAMS ((rtx));\n-static void move2add_note_store\t\tPARAMS ((rtx, rtx, void *));\n #ifdef AUTO_INC_DEC\n static void add_auto_inc_notes\t\tPARAMS ((rtx, rtx));\n #endif\n static void copy_eh_notes\t\tPARAMS ((rtx, rtx));\n-static void reload_cse_simplify\t\tPARAMS ((rtx, rtx));\n extern void dump_needs\t\t\tPARAMS ((struct insn_chain *));\n \f\n /* Initialize the reload pass once per compilation.  */\n@@ -8035,1467 +8024,6 @@ inc_for_reload (reloadreg, in, value, inc_amount)\n   return store;\n }\n \f\n-\n-/* See whether a single set SET is a noop.  */\n-static int\n-reload_cse_noop_set_p (set)\n-     rtx set;\n-{\n-  if (cselib_reg_set_mode (SET_DEST (set)) != GET_MODE (SET_DEST (set)))\n-    return 0;\n-\n-  return rtx_equal_for_cselib_p (SET_DEST (set), SET_SRC (set));\n-}\n-\n-/* Try to simplify INSN.  */\n-static void\n-reload_cse_simplify (insn, testreg)\n-     rtx insn;\n-     rtx testreg;\n-{\n-  rtx body = PATTERN (insn);\n-\n-  if (GET_CODE (body) == SET)\n-    {\n-      int count = 0;\n-\n-      /* Simplify even if we may think it is a no-op.\n-         We may think a memory load of a value smaller than WORD_SIZE\n-         is redundant because we haven't taken into account possible\n-         implicit extension.  reload_cse_simplify_set() will bring\n-         this out, so it's safer to simplify before we delete.  */\n-      count += reload_cse_simplify_set (body, insn);\n-\n-      if (!count && reload_cse_noop_set_p (body))\n-\t{\n-\t  rtx value = SET_DEST (body);\n-\t  if (REG_P (value)\n-\t      && ! REG_FUNCTION_VALUE_P (value))\n-\t    value = 0;\n-\t  delete_insn_and_edges (insn);\n-\t  return;\n-\t}\n-\n-      if (count > 0)\n-\tapply_change_group ();\n-      else\n-\treload_cse_simplify_operands (insn, testreg);\n-    }\n-  else if (GET_CODE (body) == PARALLEL)\n-    {\n-      int i;\n-      int count = 0;\n-      rtx value = NULL_RTX;\n-\n-      /* If every action in a PARALLEL is a noop, we can delete\n-\t the entire PARALLEL.  */\n-      for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n-\t{\n-\t  rtx part = XVECEXP (body, 0, i);\n-\t  if (GET_CODE (part) == SET)\n-\t    {\n-\t      if (! reload_cse_noop_set_p (part))\n-\t\tbreak;\n-\t      if (REG_P (SET_DEST (part))\n-\t\t  && REG_FUNCTION_VALUE_P (SET_DEST (part)))\n-\t\t{\n-\t\t  if (value)\n-\t\t    break;\n-\t\t  value = SET_DEST (part);\n-\t\t}\n-\t    }\n-\t  else if (GET_CODE (part) != CLOBBER)\n-\t    break;\n-\t}\n-\n-      if (i < 0)\n-\t{\n-\t  delete_insn_and_edges (insn);\n-\t  /* We're done with this insn.  */\n-\t  return;\n-\t}\n-\n-      /* It's not a no-op, but we can try to simplify it.  */\n-      for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n-\tif (GET_CODE (XVECEXP (body, 0, i)) == SET)\n-\t  count += reload_cse_simplify_set (XVECEXP (body, 0, i), insn);\n-\n-      if (count > 0)\n-\tapply_change_group ();\n-      else\n-\treload_cse_simplify_operands (insn, testreg);\n-    }\n-}\n-\n-/* Do a very simple CSE pass over the hard registers.\n-\n-   This function detects no-op moves where we happened to assign two\n-   different pseudo-registers to the same hard register, and then\n-   copied one to the other.  Reload will generate a useless\n-   instruction copying a register to itself.\n-\n-   This function also detects cases where we load a value from memory\n-   into two different registers, and (if memory is more expensive than\n-   registers) changes it to simply copy the first register into the\n-   second register.\n-\n-   Another optimization is performed that scans the operands of each\n-   instruction to see whether the value is already available in a\n-   hard register.  It then replaces the operand with the hard register\n-   if possible, much like an optional reload would.  */\n-\n-static void\n-reload_cse_regs_1 (first)\n-     rtx first;\n-{\n-  rtx insn;\n-  rtx testreg = gen_rtx_REG (VOIDmode, -1);\n-\n-  cselib_init ();\n-  init_alias_analysis ();\n-\n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_P (insn))\n-\treload_cse_simplify (insn, testreg);\n-\n-      cselib_process_insn (insn);\n-    }\n-\n-  /* Clean up.  */\n-  end_alias_analysis ();\n-  cselib_finish ();\n-}\n-\n-/* Call cse / combine like post-reload optimization phases.\n-   FIRST is the first instruction.  */\n-void\n-reload_cse_regs (first)\n-     rtx first;\n-{\n-  reload_cse_regs_1 (first);\n-  reload_combine ();\n-  reload_cse_move2add (first);\n-  if (flag_expensive_optimizations)\n-    reload_cse_regs_1 (first);\n-}\n-\n-/* Try to simplify a single SET instruction.  SET is the set pattern.\n-   INSN is the instruction it came from.\n-   This function only handles one case: if we set a register to a value\n-   which is not a register, we try to find that value in some other register\n-   and change the set into a register copy.  */\n-\n-static int\n-reload_cse_simplify_set (set, insn)\n-     rtx set;\n-     rtx insn;\n-{\n-  int did_change = 0;\n-  int dreg;\n-  rtx src;\n-  enum reg_class dclass;\n-  int old_cost;\n-  cselib_val *val;\n-  struct elt_loc_list *l;\n-#ifdef LOAD_EXTEND_OP\n-  enum rtx_code extend_op = NIL;\n-#endif\n-\n-  dreg = true_regnum (SET_DEST (set));\n-  if (dreg < 0)\n-    return 0;\n-\n-  src = SET_SRC (set);\n-  if (side_effects_p (src) || true_regnum (src) >= 0)\n-    return 0;\n-\n-  dclass = REGNO_REG_CLASS (dreg);\n-\n-#ifdef LOAD_EXTEND_OP\n-  /* When replacing a memory with a register, we need to honor assumptions\n-     that combine made wrt the contents of sign bits.  We'll do this by\n-     generating an extend instruction instead of a reg->reg copy.  Thus\n-     the destination must be a register that we can widen.  */\n-  if (GET_CODE (src) == MEM\n-      && GET_MODE_BITSIZE (GET_MODE (src)) < BITS_PER_WORD\n-      && (extend_op = LOAD_EXTEND_OP (GET_MODE (src))) != NIL\n-      && GET_CODE (SET_DEST (set)) != REG)\n-    return 0;\n-#endif\n-\n-  /* If memory loads are cheaper than register copies, don't change them.  */\n-  if (GET_CODE (src) == MEM)\n-    old_cost = MEMORY_MOVE_COST (GET_MODE (src), dclass, 1);\n-  else if (CONSTANT_P (src))\n-    old_cost = rtx_cost (src, SET);\n-  else if (GET_CODE (src) == REG)\n-    old_cost = REGISTER_MOVE_COST (GET_MODE (src),\n-\t\t\t\t   REGNO_REG_CLASS (REGNO (src)), dclass);\n-  else\n-    /* ???   */\n-    old_cost = rtx_cost (src, SET);\n-\n-  val = cselib_lookup (src, GET_MODE (SET_DEST (set)), 0);\n-  if (! val)\n-    return 0;\n-  for (l = val->locs; l; l = l->next)\n-    {\n-      rtx this_rtx = l->loc;\n-      int this_cost;\n-\n-      if (CONSTANT_P (this_rtx) && ! references_value_p (this_rtx, 0))\n-\t{\n-#ifdef LOAD_EXTEND_OP\n-\t  if (extend_op != NIL)\n-\t    {\n-\t      HOST_WIDE_INT this_val;\n-\n-\t      /* ??? I'm lazy and don't wish to handle CONST_DOUBLE.  Other\n-\t\t constants, such as SYMBOL_REF, cannot be extended.  */\n-\t      if (GET_CODE (this_rtx) != CONST_INT)\n-\t\tcontinue;\n-\n-\t      this_val = INTVAL (this_rtx);\n-\t      switch (extend_op)\n-\t\t{\n-\t\tcase ZERO_EXTEND:\n-\t\t  this_val &= GET_MODE_MASK (GET_MODE (src));\n-\t\t  break;\n-\t\tcase SIGN_EXTEND:\n-\t\t  /* ??? In theory we're already extended.  */\n-\t\t  if (this_val == trunc_int_for_mode (this_val, GET_MODE (src)))\n-\t\t    break;\n-\t\tdefault:\n-\t\t  abort ();\n-\t\t}\n-\t      this_rtx = GEN_INT (this_val);\n-\t    }\n-#endif\n-\t  this_cost = rtx_cost (this_rtx, SET);\n-\t}\n-      else if (GET_CODE (this_rtx) == REG)\n-\t{\n-#ifdef LOAD_EXTEND_OP\n-\t  if (extend_op != NIL)\n-\t    {\n-\t      this_rtx = gen_rtx_fmt_e (extend_op, word_mode, this_rtx);\n-\t      this_cost = rtx_cost (this_rtx, SET);\n-\t    }\n-\t  else\n-#endif\n-\t    this_cost = REGISTER_MOVE_COST (GET_MODE (this_rtx),\n-\t\t\t\t\t    REGNO_REG_CLASS (REGNO (this_rtx)),\n-\t\t\t\t\t    dclass);\n-\t}\n-      else\n-\tcontinue;\n-\n-      /* If equal costs, prefer registers over anything else.  That\n-\t tends to lead to smaller instructions on some machines.  */\n-      if (this_cost < old_cost\n-\t  || (this_cost == old_cost\n-\t      && GET_CODE (this_rtx) == REG\n-\t      && GET_CODE (SET_SRC (set)) != REG))\n-\t{\n-#ifdef LOAD_EXTEND_OP\n-\t  if (GET_MODE_BITSIZE (GET_MODE (SET_DEST (set))) < BITS_PER_WORD\n-\t      && extend_op != NIL\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\t      && !CANNOT_CHANGE_MODE_CLASS (GET_MODE (SET_DEST (set)),\n-\t\t\t\t\t    word_mode,\n-\t\t\t\t\t    REGNO_REG_CLASS (REGNO (SET_DEST (set))))\n-#endif\n-\t      )\n-\t    {\n-\t      rtx wide_dest = gen_rtx_REG (word_mode, REGNO (SET_DEST (set)));\n-\t      ORIGINAL_REGNO (wide_dest) = ORIGINAL_REGNO (SET_DEST (set));\n-\t      validate_change (insn, &SET_DEST (set), wide_dest, 1);\n-\t    }\n-#endif\n-\n-\t  validate_change (insn, &SET_SRC (set), copy_rtx (this_rtx), 1);\n-\t  old_cost = this_cost, did_change = 1;\n-\t}\n-    }\n-\n-  return did_change;\n-}\n-\n-/* Try to replace operands in INSN with equivalent values that are already\n-   in registers.  This can be viewed as optional reloading.\n-\n-   For each non-register operand in the insn, see if any hard regs are\n-   known to be equivalent to that operand.  Record the alternatives which\n-   can accept these hard registers.  Among all alternatives, select the\n-   ones which are better or equal to the one currently matching, where\n-   \"better\" is in terms of '?' and '!' constraints.  Among the remaining\n-   alternatives, select the one which replaces most operands with\n-   hard registers.  */\n-\n-static int\n-reload_cse_simplify_operands (insn, testreg)\n-     rtx insn;\n-     rtx testreg;\n-{\n-  int i, j;\n-\n-  /* For each operand, all registers that are equivalent to it.  */\n-  HARD_REG_SET equiv_regs[MAX_RECOG_OPERANDS];\n-\n-  const char *constraints[MAX_RECOG_OPERANDS];\n-\n-  /* Vector recording how bad an alternative is.  */\n-  int *alternative_reject;\n-  /* Vector recording how many registers can be introduced by choosing\n-     this alternative.  */\n-  int *alternative_nregs;\n-  /* Array of vectors recording, for each operand and each alternative,\n-     which hard register to substitute, or -1 if the operand should be\n-     left as it is.  */\n-  int *op_alt_regno[MAX_RECOG_OPERANDS];\n-  /* Array of alternatives, sorted in order of decreasing desirability.  */\n-  int *alternative_order;\n-\n-  extract_insn (insn);\n-\n-  if (recog_data.n_alternatives == 0 || recog_data.n_operands == 0)\n-    return 0;\n-\n-  /* Figure out which alternative currently matches.  */\n-  if (! constrain_operands (1))\n-    fatal_insn_not_found (insn);\n-\n-  alternative_reject = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n-  alternative_nregs = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n-  alternative_order = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n-  memset ((char *) alternative_reject, 0, recog_data.n_alternatives * sizeof (int));\n-  memset ((char *) alternative_nregs, 0, recog_data.n_alternatives * sizeof (int));\n-\n-  /* For each operand, find out which regs are equivalent.  */\n-  for (i = 0; i < recog_data.n_operands; i++)\n-    {\n-      cselib_val *v;\n-      struct elt_loc_list *l;\n-\n-      CLEAR_HARD_REG_SET (equiv_regs[i]);\n-\n-      /* cselib blows up on CODE_LABELs.  Trying to fix that doesn't seem\n-\t right, so avoid the problem here.  Likewise if we have a constant\n-         and the insn pattern doesn't tell us the mode we need.  */\n-      if (GET_CODE (recog_data.operand[i]) == CODE_LABEL\n-\t  || (CONSTANT_P (recog_data.operand[i])\n-\t      && recog_data.operand_mode[i] == VOIDmode))\n-\tcontinue;\n-\n-      v = cselib_lookup (recog_data.operand[i], recog_data.operand_mode[i], 0);\n-      if (! v)\n-\tcontinue;\n-\n-      for (l = v->locs; l; l = l->next)\n-\tif (GET_CODE (l->loc) == REG)\n-\t  SET_HARD_REG_BIT (equiv_regs[i], REGNO (l->loc));\n-    }\n-\n-  for (i = 0; i < recog_data.n_operands; i++)\n-    {\n-      enum machine_mode mode;\n-      int regno;\n-      const char *p;\n-\n-      op_alt_regno[i] = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n-      for (j = 0; j < recog_data.n_alternatives; j++)\n-\top_alt_regno[i][j] = -1;\n-\n-      p = constraints[i] = recog_data.constraints[i];\n-      mode = recog_data.operand_mode[i];\n-\n-      /* Add the reject values for each alternative given by the constraints\n-\t for this operand.  */\n-      j = 0;\n-      while (*p != '\\0')\n-\t{\n-\t  char c = *p++;\n-\t  if (c == ',')\n-\t    j++;\n-\t  else if (c == '?')\n-\t    alternative_reject[j] += 3;\n-\t  else if (c == '!')\n-\t    alternative_reject[j] += 300;\n-\t}\n-\n-      /* We won't change operands which are already registers.  We\n-\t also don't want to modify output operands.  */\n-      regno = true_regnum (recog_data.operand[i]);\n-      if (regno >= 0\n-\t  || constraints[i][0] == '='\n-\t  || constraints[i][0] == '+')\n-\tcontinue;\n-\n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t{\n-\t  int class = (int) NO_REGS;\n-\n-\t  if (! TEST_HARD_REG_BIT (equiv_regs[i], regno))\n-\t    continue;\n-\n-\t  REGNO (testreg) = regno;\n-\t  PUT_MODE (testreg, mode);\n-\n-\t  /* We found a register equal to this operand.  Now look for all\n-\t     alternatives that can accept this register and have not been\n-\t     assigned a register they can use yet.  */\n-\t  j = 0;\n-\t  p = constraints[i];\n-\t  for (;;)\n-\t    {\n-\t      char c = *p;\n-\n-\t      switch (c)\n-\t\t{\n-\t\tcase '=':  case '+':  case '?':\n-\t\tcase '#':  case '&':  case '!':\n-\t\tcase '*':  case '%':\n-\t\tcase '0':  case '1':  case '2':  case '3':  case '4':\n-\t\tcase '5':  case '6':  case '7':  case '8':  case '9':\n-\t\tcase 'm':  case '<':  case '>':  case 'V':  case 'o':\n-\t\tcase 'E':  case 'F':  case 'G':  case 'H':\n-\t\tcase 's':  case 'i':  case 'n':\n-\t\tcase 'I':  case 'J':  case 'K':  case 'L':\n-\t\tcase 'M':  case 'N':  case 'O':  case 'P':\n-\t\tcase 'p': case 'X':\n-\t\t  /* These don't say anything we care about.  */\n-\t\t  break;\n-\n-\t\tcase 'g': case 'r':\n-\t\t  class = reg_class_subunion[(int) class][(int) GENERAL_REGS];\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  class\n-\t\t    = (reg_class_subunion\n-\t\t       [(int) class]\n-\t\t       [(int) REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)]);\n-\t\t  break;\n-\n-\t\tcase ',': case '\\0':\n-\t\t  /* See if REGNO fits this alternative, and set it up as the\n-\t\t     replacement register if we don't have one for this\n-\t\t     alternative yet and the operand being replaced is not\n-\t\t     a cheap CONST_INT.  */\n-\t\t  if (op_alt_regno[i][j] == -1\n-\t\t      && reg_fits_class_p (testreg, class, 0, mode)\n-\t\t      && (GET_CODE (recog_data.operand[i]) != CONST_INT\n-\t\t\t  || (rtx_cost (recog_data.operand[i], SET)\n-\t\t\t      > rtx_cost (testreg, SET))))\n-\t\t    {\n-\t\t      alternative_nregs[j]++;\n-\t\t      op_alt_regno[i][j] = regno;\n-\t\t    }\n-\t\t  j++;\n-\t\t  break;\n-\t\t}\n-\t      p += CONSTRAINT_LEN (c, p);\n-\n-\t      if (c == '\\0')\n-\t\tbreak;\n-\t    }\n-\t}\n-    }\n-\n-  /* Record all alternatives which are better or equal to the currently\n-     matching one in the alternative_order array.  */\n-  for (i = j = 0; i < recog_data.n_alternatives; i++)\n-    if (alternative_reject[i] <= alternative_reject[which_alternative])\n-      alternative_order[j++] = i;\n-  recog_data.n_alternatives = j;\n-\n-  /* Sort it.  Given a small number of alternatives, a dumb algorithm\n-     won't hurt too much.  */\n-  for (i = 0; i < recog_data.n_alternatives - 1; i++)\n-    {\n-      int best = i;\n-      int best_reject = alternative_reject[alternative_order[i]];\n-      int best_nregs = alternative_nregs[alternative_order[i]];\n-      int tmp;\n-\n-      for (j = i + 1; j < recog_data.n_alternatives; j++)\n-\t{\n-\t  int this_reject = alternative_reject[alternative_order[j]];\n-\t  int this_nregs = alternative_nregs[alternative_order[j]];\n-\n-\t  if (this_reject < best_reject\n-\t      || (this_reject == best_reject && this_nregs < best_nregs))\n-\t    {\n-\t      best = j;\n-\t      best_reject = this_reject;\n-\t      best_nregs = this_nregs;\n-\t    }\n-\t}\n-\n-      tmp = alternative_order[best];\n-      alternative_order[best] = alternative_order[i];\n-      alternative_order[i] = tmp;\n-    }\n-\n-  /* Substitute the operands as determined by op_alt_regno for the best\n-     alternative.  */\n-  j = alternative_order[0];\n-\n-  for (i = 0; i < recog_data.n_operands; i++)\n-    {\n-      enum machine_mode mode = recog_data.operand_mode[i];\n-      if (op_alt_regno[i][j] == -1)\n-\tcontinue;\n-\n-      validate_change (insn, recog_data.operand_loc[i],\n-\t\t       gen_rtx_REG (mode, op_alt_regno[i][j]), 1);\n-    }\n-\n-  for (i = recog_data.n_dups - 1; i >= 0; i--)\n-    {\n-      int op = recog_data.dup_num[i];\n-      enum machine_mode mode = recog_data.operand_mode[op];\n-\n-      if (op_alt_regno[op][j] == -1)\n-\tcontinue;\n-\n-      validate_change (insn, recog_data.dup_loc[i],\n-\t\t       gen_rtx_REG (mode, op_alt_regno[op][j]), 1);\n-    }\n-\n-  return apply_change_group ();\n-}\n-\f\n-/* If reload couldn't use reg+reg+offset addressing, try to use reg+reg\n-   addressing now.\n-   This code might also be useful when reload gave up on reg+reg addressing\n-   because of clashes between the return register and INDEX_REG_CLASS.  */\n-\n-/* The maximum number of uses of a register we can keep track of to\n-   replace them with reg+reg addressing.  */\n-#define RELOAD_COMBINE_MAX_USES 6\n-\n-/* INSN is the insn where a register has ben used, and USEP points to the\n-   location of the register within the rtl.  */\n-struct reg_use { rtx insn, *usep; };\n-\n-/* If the register is used in some unknown fashion, USE_INDEX is negative.\n-   If it is dead, USE_INDEX is RELOAD_COMBINE_MAX_USES, and STORE_RUID\n-   indicates where it becomes live again.\n-   Otherwise, USE_INDEX is the index of the last encountered use of the\n-   register (which is first among these we have seen since we scan backwards),\n-   OFFSET contains the constant offset that is added to the register in\n-   all encountered uses, and USE_RUID indicates the first encountered, i.e.\n-   last, of these uses.\n-   STORE_RUID is always meaningful if we only want to use a value in a\n-   register in a different place: it denotes the next insn in the insn\n-   stream (i.e. the last encountered) that sets or clobbers the register.  */\n-static struct\n-  {\n-    struct reg_use reg_use[RELOAD_COMBINE_MAX_USES];\n-    int use_index;\n-    rtx offset;\n-    int store_ruid;\n-    int use_ruid;\n-  } reg_state[FIRST_PSEUDO_REGISTER];\n-\n-/* Reverse linear uid.  This is increased in reload_combine while scanning\n-   the instructions from last to first.  It is used to set last_label_ruid\n-   and the store_ruid / use_ruid fields in reg_state.  */\n-static int reload_combine_ruid;\n-\n-#define LABEL_LIVE(LABEL) \\\n-  (label_live[CODE_LABEL_NUMBER (LABEL) - min_labelno])\n-\n-static void\n-reload_combine ()\n-{\n-  rtx insn, set;\n-  int first_index_reg = -1;\n-  int last_index_reg = 0;\n-  int i;\n-  basic_block bb;\n-  unsigned int r;\n-  int last_label_ruid;\n-  int min_labelno, n_labels;\n-  HARD_REG_SET ever_live_at_start, *label_live;\n-\n-  /* If reg+reg can be used in offsetable memory addresses, the main chunk of\n-     reload has already used it where appropriate, so there is no use in\n-     trying to generate it now.  */\n-  if (double_reg_address_ok && INDEX_REG_CLASS != NO_REGS)\n-    return;\n-\n-  /* To avoid wasting too much time later searching for an index register,\n-     determine the minimum and maximum index register numbers.  */\n-  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n-    if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], r))\n-      {\n-\tif (first_index_reg == -1)\n-\t  first_index_reg = r;\n-\n-\tlast_index_reg = r;\n-      }\n-\n-  /* If no index register is available, we can quit now.  */\n-  if (first_index_reg == -1)\n-    return;\n-\n-  /* Set up LABEL_LIVE and EVER_LIVE_AT_START.  The register lifetime\n-     information is a bit fuzzy immediately after reload, but it's\n-     still good enough to determine which registers are live at a jump\n-     destination.  */\n-  min_labelno = get_first_label_num ();\n-  n_labels = max_label_num () - min_labelno;\n-  label_live = (HARD_REG_SET *) xmalloc (n_labels * sizeof (HARD_REG_SET));\n-  CLEAR_HARD_REG_SET (ever_live_at_start);\n-\n-  FOR_EACH_BB_REVERSE (bb)\n-    {\n-      insn = bb->head;\n-      if (GET_CODE (insn) == CODE_LABEL)\n-\t{\n-\t  HARD_REG_SET live;\n-\n-\t  REG_SET_TO_HARD_REG_SET (live,\n-\t\t\t\t   bb->global_live_at_start);\n-\t  compute_use_by_pseudos (&live,\n-\t\t\t\t  bb->global_live_at_start);\n-\t  COPY_HARD_REG_SET (LABEL_LIVE (insn), live);\n-\t  IOR_HARD_REG_SET (ever_live_at_start, live);\n-\t}\n-    }\n-\n-  /* Initialize last_label_ruid, reload_combine_ruid and reg_state.  */\n-  last_label_ruid = reload_combine_ruid = 0;\n-  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n-    {\n-      reg_state[r].store_ruid = reload_combine_ruid;\n-      if (fixed_regs[r])\n-\treg_state[r].use_index = -1;\n-      else\n-\treg_state[r].use_index = RELOAD_COMBINE_MAX_USES;\n-    }\n-\n-  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n-    {\n-      rtx note;\n-\n-      /* We cannot do our optimization across labels.  Invalidating all the use\n-\t information we have would be costly, so we just note where the label\n-\t is and then later disable any optimization that would cross it.  */\n-      if (GET_CODE (insn) == CODE_LABEL)\n-\tlast_label_ruid = reload_combine_ruid;\n-      else if (GET_CODE (insn) == BARRIER)\n-\tfor (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n-\t  if (! fixed_regs[r])\n-\t      reg_state[r].use_index = RELOAD_COMBINE_MAX_USES;\n-\n-      if (! INSN_P (insn))\n-\tcontinue;\n-\n-      reload_combine_ruid++;\n-\n-      /* Look for (set (REGX) (CONST_INT))\n-\t (set (REGX) (PLUS (REGX) (REGY)))\n-\t ...\n-\t ... (MEM (REGX)) ...\n-\t and convert it to\n-\t (set (REGZ) (CONST_INT))\n-\t ...\n-\t ... (MEM (PLUS (REGZ) (REGY)))... .\n-\n-\t First, check that we have (set (REGX) (PLUS (REGX) (REGY)))\n-\t and that we know all uses of REGX before it dies.  */\n-      set = single_set (insn);\n-      if (set != NULL_RTX\n-\t  && GET_CODE (SET_DEST (set)) == REG\n-\t  && (HARD_REGNO_NREGS (REGNO (SET_DEST (set)),\n-\t\t\t\tGET_MODE (SET_DEST (set)))\n-\t      == 1)\n-\t  && GET_CODE (SET_SRC (set)) == PLUS\n-\t  && GET_CODE (XEXP (SET_SRC (set), 1)) == REG\n-\t  && rtx_equal_p (XEXP (SET_SRC (set), 0), SET_DEST (set))\n-\t  && last_label_ruid < reg_state[REGNO (SET_DEST (set))].use_ruid)\n-\t{\n-\t  rtx reg = SET_DEST (set);\n-\t  rtx plus = SET_SRC (set);\n-\t  rtx base = XEXP (plus, 1);\n-\t  rtx prev = prev_nonnote_insn (insn);\n-\t  rtx prev_set = prev ? single_set (prev) : NULL_RTX;\n-\t  unsigned int regno = REGNO (reg);\n-\t  rtx const_reg = NULL_RTX;\n-\t  rtx reg_sum = NULL_RTX;\n-\n-\t  /* Now, we need an index register.\n-\t     We'll set index_reg to this index register, const_reg to the\n-\t     register that is to be loaded with the constant\n-\t     (denoted as REGZ in the substitution illustration above),\n-\t     and reg_sum to the register-register that we want to use to\n-\t     substitute uses of REG (typically in MEMs) with.\n-\t     First check REG and BASE for being index registers;\n-\t     we can use them even if they are not dead.  */\n-\t  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], regno)\n-\t      || TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS],\n-\t\t\t\t    REGNO (base)))\n-\t    {\n-\t      const_reg = reg;\n-\t      reg_sum = plus;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Otherwise, look for a free index register.  Since we have\n-\t\t checked above that neiter REG nor BASE are index registers,\n-\t\t if we find anything at all, it will be different from these\n-\t\t two registers.  */\n-\t      for (i = first_index_reg; i <= last_index_reg; i++)\n-\t\t{\n-\t\t  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS],\n-\t\t\t\t\t i)\n-\t\t      && reg_state[i].use_index == RELOAD_COMBINE_MAX_USES\n-\t\t      && reg_state[i].store_ruid <= reg_state[regno].use_ruid\n-\t\t      && HARD_REGNO_NREGS (i, GET_MODE (reg)) == 1)\n-\t\t    {\n-\t\t      rtx index_reg = gen_rtx_REG (GET_MODE (reg), i);\n-\n-\t\t      const_reg = index_reg;\n-\t\t      reg_sum = gen_rtx_PLUS (GET_MODE (reg), index_reg, base);\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  /* Check that PREV_SET is indeed (set (REGX) (CONST_INT)) and that\n-\t     (REGY), i.e. BASE, is not clobbered before the last use we'll\n-\t     create.  */\n-\t  if (prev_set != 0\n-\t      && GET_CODE (SET_SRC (prev_set)) == CONST_INT\n-\t      && rtx_equal_p (SET_DEST (prev_set), reg)\n-\t      && reg_state[regno].use_index >= 0\n-\t      && (reg_state[REGNO (base)].store_ruid\n-\t\t  <= reg_state[regno].use_ruid)\n-\t      && reg_sum != 0)\n-\t    {\n-\t      int i;\n-\n-\t      /* Change destination register and, if necessary, the\n-\t\t constant value in PREV, the constant loading instruction.  */\n-\t      validate_change (prev, &SET_DEST (prev_set), const_reg, 1);\n-\t      if (reg_state[regno].offset != const0_rtx)\n-\t\tvalidate_change (prev,\n-\t\t\t\t &SET_SRC (prev_set),\n-\t\t\t\t GEN_INT (INTVAL (SET_SRC (prev_set))\n-\t\t\t\t\t  + INTVAL (reg_state[regno].offset)),\n-\t\t\t\t 1);\n-\n-\t      /* Now for every use of REG that we have recorded, replace REG\n-\t\t with REG_SUM.  */\n-\t      for (i = reg_state[regno].use_index;\n-\t\t   i < RELOAD_COMBINE_MAX_USES; i++)\n-\t\tvalidate_change (reg_state[regno].reg_use[i].insn,\n-\t\t\t\t reg_state[regno].reg_use[i].usep,\n-\t\t\t\t /* Each change must have its own\n-\t\t\t\t    replacement.  */\n-\t\t\t\t copy_rtx (reg_sum), 1);\n-\n-\t      if (apply_change_group ())\n-\t\t{\n-\t\t  rtx *np;\n-\n-\t\t  /* Delete the reg-reg addition.  */\n-\t\t  delete_insn (insn);\n-\n-\t\t  if (reg_state[regno].offset != const0_rtx)\n-\t\t    /* Previous REG_EQUIV / REG_EQUAL notes for PREV\n-\t\t       are now invalid.  */\n-\t\t    for (np = &REG_NOTES (prev); *np;)\n-\t\t      {\n-\t\t\tif (REG_NOTE_KIND (*np) == REG_EQUAL\n-\t\t\t    || REG_NOTE_KIND (*np) == REG_EQUIV)\n-\t\t\t  *np = XEXP (*np, 1);\n-\t\t\telse\n-\t\t\t  np = &XEXP (*np, 1);\n-\t\t      }\n-\n-\t\t  reg_state[regno].use_index = RELOAD_COMBINE_MAX_USES;\n-\t\t  reg_state[REGNO (const_reg)].store_ruid\n-\t\t    = reload_combine_ruid;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t}\n-\n-      note_stores (PATTERN (insn), reload_combine_note_store, NULL);\n-\n-      if (GET_CODE (insn) == CALL_INSN)\n-\t{\n-\t  rtx link;\n-\n-\t  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n-\t    if (call_used_regs[r])\n-\t      {\n-\t\treg_state[r].use_index = RELOAD_COMBINE_MAX_USES;\n-\t\treg_state[r].store_ruid = reload_combine_ruid;\n-\t      }\n-\n-\t  for (link = CALL_INSN_FUNCTION_USAGE (insn); link;\n-\t       link = XEXP (link, 1))\n-\t    {\n-\t      rtx usage_rtx = XEXP (XEXP (link, 0), 0);\n-\t      if (GET_CODE (usage_rtx) == REG)\n-\t        {\n-\t\t  unsigned int i;\n-\t\t  unsigned int start_reg = REGNO (usage_rtx);\n-\t\t  unsigned int num_regs =\n-\t\t\tHARD_REGNO_NREGS (start_reg, GET_MODE (usage_rtx));\n-\t\t  unsigned int end_reg  = start_reg + num_regs - 1;\n-\t\t  for (i = start_reg; i <= end_reg; i++)\n-\t\t    if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n-\t\t      {\n-\t\t        reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n-\t\t        reg_state[i].store_ruid = reload_combine_ruid;\n-\t\t      }\n-\t\t    else\n-\t\t      reg_state[i].use_index = -1;\n-\t         }\n-\t     }\n-\n-\t}\n-      else if (GET_CODE (insn) == JUMP_INSN\n-\t       && GET_CODE (PATTERN (insn)) != RETURN)\n-\t{\n-\t  /* Non-spill registers might be used at the call destination in\n-\t     some unknown fashion, so we have to mark the unknown use.  */\n-\t  HARD_REG_SET *live;\n-\n-\t  if ((condjump_p (insn) || condjump_in_parallel_p (insn))\n-\t      && JUMP_LABEL (insn))\n-\t    live = &LABEL_LIVE (JUMP_LABEL (insn));\n-\t  else\n-\t    live = &ever_live_at_start;\n-\n-\t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n-\t    if (TEST_HARD_REG_BIT (*live, i))\n-\t      reg_state[i].use_index = -1;\n-\t}\n-\n-      reload_combine_note_use (&PATTERN (insn), insn);\n-      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t{\n-\t  if (REG_NOTE_KIND (note) == REG_INC\n-\t      && GET_CODE (XEXP (note, 0)) == REG)\n-\t    {\n-\t      int regno = REGNO (XEXP (note, 0));\n-\n-\t      reg_state[regno].store_ruid = reload_combine_ruid;\n-\t      reg_state[regno].use_index = -1;\n-\t    }\n-\t}\n-    }\n-\n-  free (label_live);\n-}\n-\n-/* Check if DST is a register or a subreg of a register; if it is,\n-   update reg_state[regno].store_ruid and reg_state[regno].use_index\n-   accordingly.  Called via note_stores from reload_combine.  */\n-\n-static void\n-reload_combine_note_store (dst, set, data)\n-     rtx dst, set;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  int regno = 0;\n-  int i;\n-  enum machine_mode mode = GET_MODE (dst);\n-\n-  if (GET_CODE (dst) == SUBREG)\n-    {\n-      regno = subreg_regno_offset (REGNO (SUBREG_REG (dst)),\n-\t\t\t\t   GET_MODE (SUBREG_REG (dst)),\n-\t\t\t\t   SUBREG_BYTE (dst),\n-\t\t\t\t   GET_MODE (dst));\n-      dst = SUBREG_REG (dst);\n-    }\n-  if (GET_CODE (dst) != REG)\n-    return;\n-  regno += REGNO (dst);\n-\n-  /* note_stores might have stripped a STRICT_LOW_PART, so we have to be\n-     careful with registers / register parts that are not full words.\n-\n-     Similarly for ZERO_EXTRACT and SIGN_EXTRACT.  */\n-  if (GET_CODE (set) != SET\n-      || GET_CODE (SET_DEST (set)) == ZERO_EXTRACT\n-      || GET_CODE (SET_DEST (set)) == SIGN_EXTRACT\n-      || GET_CODE (SET_DEST (set)) == STRICT_LOW_PART)\n-    {\n-      for (i = HARD_REGNO_NREGS (regno, mode) - 1 + regno; i >= regno; i--)\n-\t{\n-\t  reg_state[i].use_index = -1;\n-\t  reg_state[i].store_ruid = reload_combine_ruid;\n-\t}\n-    }\n-  else\n-    {\n-      for (i = HARD_REGNO_NREGS (regno, mode) - 1 + regno; i >= regno; i--)\n-\t{\n-\t  reg_state[i].store_ruid = reload_combine_ruid;\n-\t  reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n-\t}\n-    }\n-}\n-\n-/* XP points to a piece of rtl that has to be checked for any uses of\n-   registers.\n-   *XP is the pattern of INSN, or a part of it.\n-   Called from reload_combine, and recursively by itself.  */\n-static void\n-reload_combine_note_use (xp, insn)\n-     rtx *xp, insn;\n-{\n-  rtx x = *xp;\n-  enum rtx_code code = x->code;\n-  const char *fmt;\n-  int i, j;\n-  rtx offset = const0_rtx; /* For the REG case below.  */\n-\n-  switch (code)\n-    {\n-    case SET:\n-      if (GET_CODE (SET_DEST (x)) == REG)\n-\t{\n-\t  reload_combine_note_use (&SET_SRC (x), insn);\n-\t  return;\n-\t}\n-      break;\n-\n-    case USE:\n-      /* If this is the USE of a return value, we can't change it.  */\n-      if (GET_CODE (XEXP (x, 0)) == REG && REG_FUNCTION_VALUE_P (XEXP (x, 0)))\n-\t{\n-\t/* Mark the return register as used in an unknown fashion.  */\n-\t  rtx reg = XEXP (x, 0);\n-\t  int regno = REGNO (reg);\n-\t  int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\n-\t  while (--nregs >= 0)\n-\t    reg_state[regno + nregs].use_index = -1;\n-\t  return;\n-\t}\n-      break;\n-\n-    case CLOBBER:\n-      if (GET_CODE (SET_DEST (x)) == REG)\n-\t{\n-\t  /* No spurious CLOBBERs of pseudo registers may remain.  */\n-\t  if (REGNO (SET_DEST (x)) >= FIRST_PSEUDO_REGISTER)\n-\t    abort ();\n-\t  return;\n-\t}\n-      break;\n-\n-    case PLUS:\n-      /* We are interested in (plus (reg) (const_int)) .  */\n-      if (GET_CODE (XEXP (x, 0)) != REG\n-\t  || GET_CODE (XEXP (x, 1)) != CONST_INT)\n-\tbreak;\n-      offset = XEXP (x, 1);\n-      x = XEXP (x, 0);\n-      /* Fall through.  */\n-    case REG:\n-      {\n-\tint regno = REGNO (x);\n-\tint use_index;\n-\tint nregs;\n-\n-\t/* No spurious USEs of pseudo registers may remain.  */\n-\tif (regno >= FIRST_PSEUDO_REGISTER)\n-\t  abort ();\n-\n-\tnregs = HARD_REGNO_NREGS (regno, GET_MODE (x));\n-\n-\t/* We can't substitute into multi-hard-reg uses.  */\n-\tif (nregs > 1)\n-\t  {\n-\t    while (--nregs >= 0)\n-\t      reg_state[regno + nregs].use_index = -1;\n-\t    return;\n-\t  }\n-\n-\t/* If this register is already used in some unknown fashion, we\n-\t   can't do anything.\n-\t   If we decrement the index from zero to -1, we can't store more\n-\t   uses, so this register becomes used in an unknown fashion.  */\n-\tuse_index = --reg_state[regno].use_index;\n-\tif (use_index < 0)\n-\t  return;\n-\n-\tif (use_index != RELOAD_COMBINE_MAX_USES - 1)\n-\t  {\n-\t    /* We have found another use for a register that is already\n-\t       used later.  Check if the offsets match; if not, mark the\n-\t       register as used in an unknown fashion.  */\n-\t    if (! rtx_equal_p (offset, reg_state[regno].offset))\n-\t      {\n-\t\treg_state[regno].use_index = -1;\n-\t\treturn;\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    /* This is the first use of this register we have seen since we\n-\t       marked it as dead.  */\n-\t    reg_state[regno].offset = offset;\n-\t    reg_state[regno].use_ruid = reload_combine_ruid;\n-\t  }\n-\treg_state[regno].reg_use[use_index].insn = insn;\n-\treg_state[regno].reg_use[use_index].usep = xp;\n-\treturn;\n-      }\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Recursively process the components of X.  */\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\treload_combine_note_use (&XEXP (x, i), insn);\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    reload_combine_note_use (&XVECEXP (x, i, j), insn);\n-\t}\n-    }\n-}\n-\f\n-/* See if we can reduce the cost of a constant by replacing a move\n-   with an add.  We track situations in which a register is set to a\n-   constant or to a register plus a constant.  */\n-/* We cannot do our optimization across labels.  Invalidating all the\n-   information about register contents we have would be costly, so we\n-   use move2add_last_label_luid to note where the label is and then\n-   later disable any optimization that would cross it.\n-   reg_offset[n] / reg_base_reg[n] / reg_mode[n] are only valid if\n-   reg_set_luid[n] is greater than move2add_last_label_luid.  */\n-static int reg_set_luid[FIRST_PSEUDO_REGISTER];\n-\n-/* If reg_base_reg[n] is negative, register n has been set to\n-   reg_offset[n] in mode reg_mode[n] .\n-   If reg_base_reg[n] is non-negative, register n has been set to the\n-   sum of reg_offset[n] and the value of register reg_base_reg[n]\n-   before reg_set_luid[n], calculated in mode reg_mode[n] .  */\n-static HOST_WIDE_INT reg_offset[FIRST_PSEUDO_REGISTER];\n-static int reg_base_reg[FIRST_PSEUDO_REGISTER];\n-static enum machine_mode reg_mode[FIRST_PSEUDO_REGISTER];\n-\n-/* move2add_luid is linearly increased while scanning the instructions\n-   from first to last.  It is used to set reg_set_luid in\n-   reload_cse_move2add and move2add_note_store.  */\n-static int move2add_luid;\n-\n-/* move2add_last_label_luid is set whenever a label is found.  Labels\n-   invalidate all previously collected reg_offset data.  */\n-static int move2add_last_label_luid;\n-\n-/* ??? We don't know how zero / sign extension is handled, hence we\n-   can't go from a narrower to a wider mode.  */\n-#define MODES_OK_FOR_MOVE2ADD(OUTMODE, INMODE) \\\n-  (GET_MODE_SIZE (OUTMODE) == GET_MODE_SIZE (INMODE) \\\n-   || (GET_MODE_SIZE (OUTMODE) <= GET_MODE_SIZE (INMODE) \\\n-       && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (OUTMODE), \\\n-\t\t\t\t GET_MODE_BITSIZE (INMODE))))\n-\n-static void\n-reload_cse_move2add (first)\n-     rtx first;\n-{\n-  int i;\n-  rtx insn;\n-\n-  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n-    reg_set_luid[i] = 0;\n-\n-  move2add_last_label_luid = 0;\n-  move2add_luid = 2;\n-  for (insn = first; insn; insn = NEXT_INSN (insn), move2add_luid++)\n-    {\n-      rtx pat, note;\n-\n-      if (GET_CODE (insn) == CODE_LABEL)\n-\t{\n-\t  move2add_last_label_luid = move2add_luid;\n-\t  /* We're going to increment move2add_luid twice after a\n-\t     label, so that we can use move2add_last_label_luid + 1 as\n-\t     the luid for constants.  */\n-\t  move2add_luid++;\n-\t  continue;\n-\t}\n-      if (! INSN_P (insn))\n-\tcontinue;\n-      pat = PATTERN (insn);\n-      /* For simplicity, we only perform this optimization on\n-\t straightforward SETs.  */\n-      if (GET_CODE (pat) == SET\n-\t  && GET_CODE (SET_DEST (pat)) == REG)\n-\t{\n-\t  rtx reg = SET_DEST (pat);\n-\t  int regno = REGNO (reg);\n-\t  rtx src = SET_SRC (pat);\n-\n-\t  /* Check if we have valid information on the contents of this\n-\t     register in the mode of REG.  */\n-\t  if (reg_set_luid[regno] > move2add_last_label_luid\n-\t      && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg), reg_mode[regno]))\n-\t    {\n-\t      /* Try to transform (set (REGX) (CONST_INT A))\n-\t\t\t\t  ...\n-\t\t\t\t  (set (REGX) (CONST_INT B))\n-\t\t to\n-\t\t\t\t  (set (REGX) (CONST_INT A))\n-\t\t\t\t  ...\n-\t\t\t\t  (set (REGX) (plus (REGX) (CONST_INT B-A)))\n-\t\t or\n-\t\t\t\t  (set (REGX) (CONST_INT A))\n-\t\t\t\t  ...\n-\t\t\t\t  (set (STRICT_LOW_PART (REGX)) (CONST_INT B))\n-\t      */\n-\n-\t      if (GET_CODE (src) == CONST_INT && reg_base_reg[regno] < 0)\n-\t\t{\n-\t\t  rtx new_src =\n-\t\t    GEN_INT (trunc_int_for_mode (INTVAL (src)\n-\t\t\t\t\t\t - reg_offset[regno],\n-\t\t\t\t\t\t GET_MODE (reg)));\n-\t\t  /* (set (reg) (plus (reg) (const_int 0))) is not canonical;\n-\t\t     use (set (reg) (reg)) instead.\n-\t\t     We don't delete this insn, nor do we convert it into a\n-\t\t     note, to avoid losing register notes or the return\n-\t\t     value flag.  jump2 already knows how to get rid of\n-\t\t     no-op moves.  */\n-\t\t  if (new_src == const0_rtx)\n-\t\t    {\n-\t\t      /* If the constants are different, this is a\n-\t\t\t truncation, that, if turned into (set (reg)\n-\t\t\t (reg)), would be discarded.  Maybe we should\n-\t\t\t try a truncMN pattern?  */\n-\t\t      if (INTVAL (src) == reg_offset [regno])\n-\t\t\tvalidate_change (insn, &SET_SRC (pat), reg, 0);\n-\t\t    }\n-\t\t  else if (rtx_cost (new_src, PLUS) < rtx_cost (src, SET)\n-\t\t\t   && have_add2_insn (reg, new_src))\n-\t\t    {\n-\t\t      rtx newpat = gen_add2_insn (reg, new_src);\n-\t\t      if (INSN_P (newpat) && NEXT_INSN (newpat) == NULL_RTX)\n-\t\t\tnewpat = PATTERN (newpat);\n-\t\t      /* If it was the first insn of a sequence or\n-\t\t\t some other emitted insn, validate_change will\n-\t\t\t reject it.  */\n-\t\t      validate_change (insn, &PATTERN (insn),\n-\t\t\t\t       newpat, 0);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      enum machine_mode narrow_mode;\n-\t\t      for (narrow_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t\t\t   narrow_mode != GET_MODE (reg);\n-\t\t\t   narrow_mode = GET_MODE_WIDER_MODE (narrow_mode))\n-\t\t\t{\n-\t\t\t  if (have_insn_for (STRICT_LOW_PART, narrow_mode)\n-\t\t\t      && ((reg_offset[regno]\n-\t\t\t\t   & ~GET_MODE_MASK (narrow_mode))\n-\t\t\t\t  == (INTVAL (src)\n-\t\t\t\t      & ~GET_MODE_MASK (narrow_mode))))\n-\t\t\t    {\n-\t\t\t      rtx narrow_reg = gen_rtx_REG (narrow_mode,\n-\t\t\t\t\t\t\t    REGNO (reg));\n-\t\t\t      rtx narrow_src =\n-\t\t\t\tGEN_INT (trunc_int_for_mode (INTVAL (src),\n-\t\t\t\t\t\t\t     narrow_mode));\n-\t\t\t      rtx new_set =\n-\t\t\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t\t\t     gen_rtx_STRICT_LOW_PART (VOIDmode,\n-\t\t\t\t\t\t\t\t      narrow_reg),\n-\t\t\t\t\t     narrow_src);\n-\t\t\t      if (validate_change (insn, &PATTERN (insn),\n-\t\t\t\t\t\t   new_set, 0))\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t  reg_set_luid[regno] = move2add_luid;\n-\t\t  reg_mode[regno] = GET_MODE (reg);\n-\t\t  reg_offset[regno] = INTVAL (src);\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* Try to transform (set (REGX) (REGY))\n-\t\t\t\t  (set (REGX) (PLUS (REGX) (CONST_INT A)))\n-\t\t\t\t  ...\n-\t\t\t\t  (set (REGX) (REGY))\n-\t\t\t\t  (set (REGX) (PLUS (REGX) (CONST_INT B)))\n-\t\t to\n-\t\t\t\t  (set (REGX) (REGY))\n-\t\t\t\t  (set (REGX) (PLUS (REGX) (CONST_INT A)))\n-\t\t\t\t  ...\n-\t\t\t\t  (set (REGX) (plus (REGX) (CONST_INT B-A)))  */\n-\t      else if (GET_CODE (src) == REG\n-\t\t       && reg_set_luid[regno] == reg_set_luid[REGNO (src)]\n-\t\t       && reg_base_reg[regno] == reg_base_reg[REGNO (src)]\n-\t\t       && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg),\n-\t\t\t\t\t\t reg_mode[REGNO (src)]))\n-\t\t{\n-\t\t  rtx next = next_nonnote_insn (insn);\n-\t\t  rtx set = NULL_RTX;\n-\t\t  if (next)\n-\t\t    set = single_set (next);\n-\t\t  if (set\n-\t\t      && SET_DEST (set) == reg\n-\t\t      && GET_CODE (SET_SRC (set)) == PLUS\n-\t\t      && XEXP (SET_SRC (set), 0) == reg\n-\t\t      && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n-\t\t    {\n-\t\t      rtx src3 = XEXP (SET_SRC (set), 1);\n-\t\t      HOST_WIDE_INT added_offset = INTVAL (src3);\n-\t\t      HOST_WIDE_INT base_offset = reg_offset[REGNO (src)];\n-\t\t      HOST_WIDE_INT regno_offset = reg_offset[regno];\n-\t\t      rtx new_src =\n-\t\t\tGEN_INT (trunc_int_for_mode (added_offset\n-\t\t\t\t\t\t     + base_offset\n-\t\t\t\t\t\t     - regno_offset,\n-\t\t\t\t\t\t     GET_MODE (reg)));\n-\t\t      int success = 0;\n-\n-\t\t      if (new_src == const0_rtx)\n-\t\t\t/* See above why we create (set (reg) (reg)) here.  */\n-\t\t\tsuccess\n-\t\t\t  = validate_change (next, &SET_SRC (set), reg, 0);\n-\t\t      else if ((rtx_cost (new_src, PLUS)\n-\t\t\t\t< COSTS_N_INSNS (1) + rtx_cost (src3, SET))\n-\t\t\t       && have_add2_insn (reg, new_src))\n-\t\t\t{\n-\t\t\t  rtx newpat = gen_add2_insn (reg, new_src);\n-\t\t\t  if (INSN_P (newpat)\n-\t\t\t      && NEXT_INSN (newpat) == NULL_RTX)\n-\t\t\t    newpat = PATTERN (newpat);\n-\t\t\t  success\n-\t\t\t    = validate_change (next, &PATTERN (next),\n-\t\t\t\t\t       newpat, 0);\n-\t\t\t}\n-\t\t      if (success)\n-\t\t\tdelete_insn (insn);\n-\t\t      insn = next;\n-\t\t      reg_mode[regno] = GET_MODE (reg);\n-\t\t      reg_offset[regno] =\n-\t\t\ttrunc_int_for_mode (added_offset + base_offset,\n-\t\t\t\t\t    GET_MODE (reg));\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t{\n-\t  if (REG_NOTE_KIND (note) == REG_INC\n-\t      && GET_CODE (XEXP (note, 0)) == REG)\n-\t    {\n-\t      /* Reset the information about this register.  */\n-\t      int regno = REGNO (XEXP (note, 0));\n-\t      if (regno < FIRST_PSEUDO_REGISTER)\n-\t\treg_set_luid[regno] = 0;\n-\t    }\n-\t}\n-      note_stores (PATTERN (insn), move2add_note_store, NULL);\n-\n-      /* If INSN is a conditional branch, we try to extract an\n-\t implicit set out of it.  */\n-      if (any_condjump_p (insn) && onlyjump_p (insn))\n-\t{\n-\t  rtx cnd = fis_get_condition (insn);\n-\n-\t  if (cnd != NULL_RTX\n-\t      && GET_CODE (cnd) == NE\n-\t      && GET_CODE (XEXP (cnd, 0)) == REG\n-\t      /* The following two checks, which are also in\n-\t\t move2add_note_store, are intended to reduce the\n-\t\t number of calls to gen_rtx_SET to avoid memory\n-\t\t allocation if possible.  */\n-\t      && SCALAR_INT_MODE_P (GET_MODE (XEXP (cnd, 0)))\n-\t      && HARD_REGNO_NREGS (REGNO (XEXP (cnd, 0)), GET_MODE (XEXP (cnd, 0))) == 1\n-\t      && GET_CODE (XEXP (cnd, 1)) == CONST_INT)\n-\t    {\n-\t      rtx implicit_set =\n-\t\tgen_rtx_SET (VOIDmode, XEXP (cnd, 0), XEXP (cnd, 1));\n-\t      move2add_note_store (SET_DEST (implicit_set), implicit_set, 0);\n-\t    }\n-\t}\n-\n-      /* If this is a CALL_INSN, all call used registers are stored with\n-\t unknown values.  */\n-      if (GET_CODE (insn) == CALL_INSN)\n-\t{\n-\t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n-\t    {\n-\t      if (call_used_regs[i])\n-\t\t/* Reset the information about this register.  */\n-\t\treg_set_luid[i] = 0;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* SET is a SET or CLOBBER that sets DST.\n-   Update reg_set_luid, reg_offset and reg_base_reg accordingly.\n-   Called from reload_cse_move2add via note_stores.  */\n-\n-static void\n-move2add_note_store (dst, set, data)\n-     rtx dst, set;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  unsigned int regno = 0;\n-  unsigned int i;\n-  enum machine_mode mode = GET_MODE (dst);\n-\n-  if (GET_CODE (dst) == SUBREG)\n-    {\n-      regno = subreg_regno_offset (REGNO (SUBREG_REG (dst)),\n-\t\t\t\t   GET_MODE (SUBREG_REG (dst)),\n-\t\t\t\t   SUBREG_BYTE (dst),\n-\t\t\t\t   GET_MODE (dst));\n-      dst = SUBREG_REG (dst);\n-    }\n-\n-  /* Some targets do argument pushes without adding REG_INC notes.  */\n-\n-  if (GET_CODE (dst) == MEM)\n-    {\n-      dst = XEXP (dst, 0);\n-      if (GET_CODE (dst) == PRE_INC || GET_CODE (dst) == POST_INC\n-\t  || GET_CODE (dst) == PRE_DEC || GET_CODE (dst) == POST_DEC)\n-\treg_set_luid[REGNO (XEXP (dst, 0))] = 0;\n-      return;\n-    }\n-  if (GET_CODE (dst) != REG)\n-    return;\n-\n-  regno += REGNO (dst);\n-\n-  if (SCALAR_INT_MODE_P (mode)\n-      && HARD_REGNO_NREGS (regno, mode) == 1 && GET_CODE (set) == SET\n-      && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT\n-      && GET_CODE (SET_DEST (set)) != SIGN_EXTRACT\n-      && GET_CODE (SET_DEST (set)) != STRICT_LOW_PART)\n-    {\n-      rtx src = SET_SRC (set);\n-      rtx base_reg;\n-      HOST_WIDE_INT offset;\n-      int base_regno;\n-      /* This may be different from mode, if SET_DEST (set) is a\n-\t SUBREG.  */\n-      enum machine_mode dst_mode = GET_MODE (dst);\n-\n-      switch (GET_CODE (src))\n-\t{\n-\tcase PLUS:\n-\t  if (GET_CODE (XEXP (src, 0)) == REG)\n-\t    {\n-\t      base_reg = XEXP (src, 0);\n-\n-\t      if (GET_CODE (XEXP (src, 1)) == CONST_INT)\n-\t\toffset = INTVAL (XEXP (src, 1));\n-\t      else if (GET_CODE (XEXP (src, 1)) == REG\n-\t\t       && (reg_set_luid[REGNO (XEXP (src, 1))]\n-\t\t\t   > move2add_last_label_luid)\n-\t\t       && (MODES_OK_FOR_MOVE2ADD\n-\t\t\t   (dst_mode, reg_mode[REGNO (XEXP (src, 1))])))\n-\t\t{\n-\t\t  if (reg_base_reg[REGNO (XEXP (src, 1))] < 0)\n-\t\t    offset = reg_offset[REGNO (XEXP (src, 1))];\n-\t\t  /* Maybe the first register is known to be a\n-\t\t     constant.  */\n-\t\t  else if (reg_set_luid[REGNO (base_reg)]\n-\t\t\t   > move2add_last_label_luid\n-\t\t\t   && (MODES_OK_FOR_MOVE2ADD\n-\t\t\t       (dst_mode, reg_mode[REGNO (XEXP (src, 1))]))\n-\t\t\t   && reg_base_reg[REGNO (base_reg)] < 0)\n-\t\t    {\n-\t\t      offset = reg_offset[REGNO (base_reg)];\n-\t\t      base_reg = XEXP (src, 1);\n-\t\t    }\n-\t\t  else\n-\t\t    goto invalidate;\n-\t\t}\n-\t      else\n-\t\tgoto invalidate;\n-\n-\t      break;\n-\t    }\n-\n-\t  goto invalidate;\n-\n-\tcase REG:\n-\t  base_reg = src;\n-\t  offset = 0;\n-\t  break;\n-\n-\tcase CONST_INT:\n-\t  /* Start tracking the register as a constant.  */\n-\t  reg_base_reg[regno] = -1;\n-\t  reg_offset[regno] = INTVAL (SET_SRC (set));\n-\t  /* We assign the same luid to all registers set to constants.  */\n-\t  reg_set_luid[regno] = move2add_last_label_luid + 1;\n-\t  reg_mode[regno] = mode;\n-\t  return;\n-\n-\tdefault:\n-\tinvalidate:\n-\t  /* Invalidate the contents of the register.  */\n-\t  reg_set_luid[regno] = 0;\n-\t  return;\n-\t}\n-\n-      base_regno = REGNO (base_reg);\n-      /* If information about the base register is not valid, set it\n-\t up as a new base register, pretending its value is known\n-\t starting from the current insn.  */\n-      if (reg_set_luid[base_regno] <= move2add_last_label_luid)\n-\t{\n-\t  reg_base_reg[base_regno] = base_regno;\n-\t  reg_offset[base_regno] = 0;\n-\t  reg_set_luid[base_regno] = move2add_luid;\n-\t  reg_mode[base_regno] = mode;\n-\t}\n-      else if (! MODES_OK_FOR_MOVE2ADD (dst_mode,\n-\t\t\t\t\treg_mode[base_regno]))\n-\tgoto invalidate;\n-\n-      reg_mode[regno] = mode;\n-\n-      /* Copy base information from our base register.  */\n-      reg_set_luid[regno] = reg_set_luid[base_regno];\n-      reg_base_reg[regno] = reg_base_reg[base_regno];\n-\n-      /* Compute the sum of the offsets or constants.  */\n-      reg_offset[regno] = trunc_int_for_mode (offset\n-\t\t\t\t\t      + reg_offset[base_regno],\n-\t\t\t\t\t      dst_mode);\n-    }\n-  else\n-    {\n-      unsigned int endregno = regno + HARD_REGNO_NREGS (regno, mode);\n-\n-      for (i = regno; i < endregno; i++)\n-\t/* Reset the information about this register.  */\n-\treg_set_luid[i] = 0;\n-    }\n-}\n-\n #ifdef AUTO_INC_DEC\n static void\n add_auto_inc_notes (insn, x)"}]}