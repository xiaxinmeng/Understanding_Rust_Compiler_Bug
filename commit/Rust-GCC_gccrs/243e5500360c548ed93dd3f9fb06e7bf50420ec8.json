{"sha": "243e5500360c548ed93dd3f9fb06e7bf50420ec8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQzZTU1MDAzNjBjNTQ4ZWQ5M2RkM2Y5ZmIwNmU3YmY1MDQyMGVjOA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-05-29T16:53:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-05-29T16:53:46Z"}, "message": "haifa-sched.c (schedule_block): Do not count USE and CLOBBER insns against the issue rate.\n\n        * haifa-sched.c (schedule_block): Do not count USE and CLOBBER\n        insns against the issue rate.\n\n        * sched-deps.c (sched_create_groups_for_libcalls): New function.\n        (sched_analyze): Use it.\n\nFrom-SVN: r54004", "tree": {"sha": "c2e12f795a472858ce2552909194ce2d7ba71110", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2e12f795a472858ce2552909194ce2d7ba71110"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/243e5500360c548ed93dd3f9fb06e7bf50420ec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243e5500360c548ed93dd3f9fb06e7bf50420ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/243e5500360c548ed93dd3f9fb06e7bf50420ec8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243e5500360c548ed93dd3f9fb06e7bf50420ec8/comments", "author": null, "committer": null, "parents": [{"sha": "45b1f7c746372e7dc48d79c9b5089ce12cbef1e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b1f7c746372e7dc48d79c9b5089ce12cbef1e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45b1f7c746372e7dc48d79c9b5089ce12cbef1e5"}], "stats": {"total": 76, "additions": 73, "deletions": 3}, "files": [{"sha": "26ef675a9a39ffdf24c4b98e211bd8d5ca9cd7e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243e5500360c548ed93dd3f9fb06e7bf50420ec8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243e5500360c548ed93dd3f9fb06e7bf50420ec8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=243e5500360c548ed93dd3f9fb06e7bf50420ec8", "patch": "@@ -1,3 +1,14 @@\n+2002-05-29  Dale Johannesen  <dalej@apple.com>\n+            Michael Matz  <matz@kde.org>\n+            David Edelsohn  <edesohn@gnu.org>\n+            Jeff Law <law@redhat.com>\n+\n+\t* haifa-sched.c (schedule_block): Do not count USE and CLOBBER\n+\tinsns against the issue rate.\n+\n+\t* sched-deps.c (sched_create_groups_for_libcalls): New function.\n+\t(sched_analyze): Use it.\n+\n 2002-05-29  Chris Lattner  <sabre@nondot.org>\n \n         * ssa.c (rename_insn_1): Rename uses of undefined registers to\n@@ -3086,7 +3097,7 @@ doc:\n \t(mips_expand_prologue, mips_expand_epilogue): Update callers.\n \t(highpart_shift_operator): Attach ATTRIBUTE_UNUSED to mode argument.\n \n-Thu May  9 11:50:09 2002  Jeffrey A Law  (law@cygnus.com)\n+Thu May  9 11:50:09 2002  Jeffrey A Law  (law@redhat.com)\n \n \t* athlon.md, k6.md, pentium.md, ppro.md): New files.\n \t* i386.md: Move scheduling information into new files.\n@@ -4276,7 +4287,7 @@ Tue Apr 30 19:15:36 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \t(scheduling descriptions): Kill uses of fop1.\n \t(sse, mmx, fp patterns): Set type and mode properly.\n \n-Tue Apr 30 09:31:59 2002  Jeffrey A Law  (law@cygnus.com)\n+Tue Apr 30 09:31:59 2002  Jeffrey A Law  (law@redhat.com)\n \n \t* pa.c (override_options): Default to PA8000 scheduling.\n \t* doc/invoke.texi (HP-PA options): Mention newly added 7300"}, {"sha": "a03b9b346b48ae2b16d51a4ec9f06723c07afeee", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243e5500360c548ed93dd3f9fb06e7bf50420ec8/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243e5500360c548ed93dd3f9fb06e7bf50420ec8/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=243e5500360c548ed93dd3f9fb06e7bf50420ec8", "patch": "@@ -2179,7 +2179,10 @@ schedule_block (b, rgn_n_insns)\n \t    can_issue_more =\n \t      (*targetm.sched.variable_issue) (sched_dump, sched_verbose,\n \t\t\t\t\t       insn, can_issue_more);\n-\t  else\n+\t  /* A naked CLOBBER or USE generates no instruction, so do\n+\t     not count them against the issue rate.  */\n+\t  else if (GET_CODE (PATTERN (insn)) != USE\n+\t\t   && GET_CODE (PATTERN (insn)) != CLOBBER)\n \t    can_issue_more--;\n \n \t  schedule_insn (insn, &ready, clock_var);"}, {"sha": "715463547770a0342525abfb843ad46d5de4c0d4", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243e5500360c548ed93dd3f9fb06e7bf50420ec8/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243e5500360c548ed93dd3f9fb06e7bf50420ec8/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=243e5500360c548ed93dd3f9fb06e7bf50420ec8", "patch": "@@ -88,6 +88,7 @@ static void flush_pending_lists PARAMS ((struct deps *, rtx, int, int));\n static void sched_analyze_1 PARAMS ((struct deps *, rtx, rtx));\n static void sched_analyze_2 PARAMS ((struct deps *, rtx, rtx));\n static void sched_analyze_insn PARAMS ((struct deps *, rtx, rtx, rtx));\n+static void sched_create_groups_for_libcalls PARAMS ((rtx, rtx));\n static rtx group_leader PARAMS ((rtx));\n \n static rtx get_condition PARAMS ((rtx));\n@@ -1210,6 +1211,57 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n     }\n }\n \n+/* Find any libcall sequences between HEAD and TAIL inclusive; set\n+   SCHED_GROUP_P appropriately for such sequences.  */\n+\n+static void\n+sched_create_groups_for_libcalls (head, tail)\n+     rtx head, tail;\n+{\n+  rtx insn;\n+  int tail_seen_p = 0;\n+\n+  for (insn = head;; insn = NEXT_INSN (insn))\n+    {\n+      rtx link, end_seq, set, r0, note;\n+      if (INSN_P (insn) && GET_CODE (PATTERN (insn)) == CLOBBER\n+\t  && (r0 = XEXP (PATTERN (insn), 0), GET_CODE (r0) == REG)\n+\t  && (link = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0\n+\t  && (end_seq = XEXP (link, 0)) != 0\n+\t  && INSN_P (end_seq)\n+\t  && (set = single_set (end_seq)) != 0\n+\t  && SET_DEST (set) == r0 && SET_SRC (set) == r0\n+\t  && (note = find_reg_note (end_seq, REG_EQUAL, NULL_RTX)) != 0)\n+\t{\n+\t  /* We found a libcall block between insn and end_seq.\n+\t     The inner insns should be scheduled in a block.  */\n+\t  rtx inner;\n+\t  /* Paranoia.  */\n+\t  if (insn == tail)\n+\t    tail_seen_p = 1;\n+\t  /* We don't want to set this flag on the initial clobber, because\n+\t     the semantic of SCHED_GROUP_P is to make insn be scheduled\n+\t     together with the previous insn.  */\n+\t  for (inner = NEXT_INSN (insn); inner; inner = NEXT_INSN (inner))\n+\t    {\n+\t      if (INSN_P (inner))\n+\t\tset_sched_group_p (inner);\n+\t      /* Paranoia.  */\n+\t      if (inner == tail)\n+\t\ttail_seen_p = 1;\n+\t      if (inner == end_seq)\n+\t\tbreak;\n+\t    }\n+\t  /* We should be able to skip the whole lib-call block.\n+\t     Remember that one NEXT_INSN is done in the loop-iteration.  */\n+\t  insn = end_seq;\n+\t}\n+      if (insn == tail || tail_seen_p)\n+\tbreak;\n+    }\n+  return;\n+}\n+\n /* Analyze every insn between HEAD and TAIL inclusive, creating LOG_LINKS\n    for every dependency.  */\n \n@@ -1357,6 +1409,10 @@ sched_analyze (deps, head, tail)\n \t{\n \t  if (current_sched_info->use_cselib)\n \t    cselib_finish ();\n+\n+\t  if (! reload_completed)\n+\t    sched_create_groups_for_libcalls (head, tail);\n+\n \t  return;\n \t}\n     }"}]}