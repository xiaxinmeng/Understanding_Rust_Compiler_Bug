{"sha": "f2404867dfe7ed85f8a9aff6cf218055ebbb23ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI0MDQ4NjdkZmU3ZWQ4NWY4YTlhZmY2Y2YyMTgwNTVlYmJiMjNhZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-02T09:32:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-02T09:32:10Z"}, "message": "[multiple changes]\n\n2011-09-02  Bob Duff  <duff@adacore.com>\n\n\t* lib-xref.adb: (Hash): Avoid use of 'Mod attribute, because old\n\tcompilers don't understand it.\n\n2011-09-02  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Pass the\n\tunderlying subtype rather than its base type on the call to\n\tBuild_Record_Or_Elementary_Input_Function, so that any\n\tconstraints on a discriminated subtype will be available for\n\tdoing the check required by AI05-0192.\n\t* exp_strm.adb (Build_Record_Or_Elementary_Input_Function):\n\tIf the prefix subtype of the 'Input attribute is a constrained\n\tdiscriminated subtype, then check each constrained discriminant value\n\tagainst the corresponding value read from the stream.\n\nFrom-SVN: r178453", "tree": {"sha": "caef630ef7510b81c5a71c1d4defcfb67cfe67f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caef630ef7510b81c5a71c1d4defcfb67cfe67f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae/comments", "author": null, "committer": null, "parents": [{"sha": "029b67bac325590fb9557b5964aea6bb2aac0cba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029b67bac325590fb9557b5964aea6bb2aac0cba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/029b67bac325590fb9557b5964aea6bb2aac0cba"}], "stats": {"total": 88, "additions": 70, "deletions": 18}, "files": [{"sha": "1af7b0dda3db8a93c30f453ef52b30eb056294dd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f2404867dfe7ed85f8a9aff6cf218055ebbb23ae", "patch": "@@ -1,3 +1,20 @@\n+2011-09-02  Bob Duff  <duff@adacore.com>\n+\n+\t* lib-xref.adb: (Hash): Avoid use of 'Mod attribute, because old\n+\tcompilers don't understand it.\n+\n+2011-09-02  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Pass the\n+\tunderlying subtype rather than its base type on the call to\n+\tBuild_Record_Or_Elementary_Input_Function, so that any\n+\tconstraints on a discriminated subtype will be available for\n+\tdoing the check required by AI05-0192.\n+\t* exp_strm.adb (Build_Record_Or_Elementary_Input_Function):\n+\tIf the prefix subtype of the 'Input attribute is a constrained\n+\tdiscriminated subtype, then check each constrained discriminant value\n+\tagainst the corresponding value read from the stream.\n+\n 2011-09-02  Yannick Moy  <moy@adacore.com>\n \n \t* usage.adb, warnsw.adb, sem_ch6.adb, opt.ads: Disable by default"}, {"sha": "598520acb24ff2df296849e697b07da16c74403f", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=f2404867dfe7ed85f8a9aff6cf218055ebbb23ae", "patch": "@@ -2531,8 +2531,12 @@ package body Exp_Attr is\n                   return;\n                end if;\n \n+               --  Build the type's Input function, passing the subtype rather\n+               --  than its base type, because checks are needed in the case of\n+               --  constrained discriminants (see Ada 2012 AI05-0192).\n+\n                Build_Record_Or_Elementary_Input_Function\n-                 (Loc, Base_Type (U_Type), Decl, Fname);\n+                 (Loc, U_Type, Decl, Fname);\n                Insert_Action (N, Decl);\n \n                if Nkind (Parent (N)) = N_Object_Declaration"}, {"sha": "c88c789432e6d525e25f11b6e4ceb3d1563f0e1f", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=f2404867dfe7ed85f8a9aff6cf218055ebbb23ae", "patch": "@@ -25,6 +25,7 @@\n \n with Atree;    use Atree;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Exp_Util; use Exp_Util;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -1106,23 +1107,32 @@ package body Exp_Strm is\n       Decl : out Node_Id;\n       Fnam : out Entity_Id)\n    is\n-      Cn       : Name_Id;\n-      Constr   : List_Id;\n-      Decls    : List_Id;\n-      Discr    : Entity_Id;\n-      J        : Pos;\n-      Obj_Decl : Node_Id;\n-      Odef     : Node_Id;\n-      Stms     : List_Id;\n+      B_Typ      : constant Entity_Id := Base_Type (Typ);\n+      Cn         : Name_Id;\n+      Constr     : List_Id;\n+      Decls      : List_Id;\n+      Discr      : Entity_Id;\n+      Discr_Elmt : Elmt_Id            := No_Elmt;\n+      J          : Pos;\n+      Obj_Decl   : Node_Id;\n+      Odef       : Node_Id;\n+      Stms       : List_Id;\n \n    begin\n       Decls  := New_List;\n       Constr := New_List;\n \n       J := 1;\n \n-      if Has_Discriminants (Typ) then\n-         Discr := First_Discriminant (Typ);\n+      if Has_Discriminants (B_Typ) then\n+         Discr := First_Discriminant (B_Typ);\n+\n+         --  If the prefix subtype is constrained, then retrieve the first\n+         --  element of its constraint.\n+\n+         if Is_Constrained (Typ) then\n+            Discr_Elmt := First_Elmt (Discriminant_Constraint (Typ));\n+         end if;\n \n          while Present (Discr) loop\n             Cn := New_External_Name ('C', J);\n@@ -1153,21 +1163,38 @@ package body Exp_Strm is\n \n             Append_To (Constr, Make_Identifier (Loc, Cn));\n \n+            --  If the prefix subtype imposes a discriminant constraint, then\n+            --  check that each discriminant value equals the value read.\n+\n+            if Present (Discr_Elmt) then\n+               Append_To (Decls,\n+                 Make_Raise_Constraint_Error (Loc,\n+                   Condition => Make_Op_Ne (Loc,\n+                                  Left_Opnd  =>\n+                                    New_Reference_To\n+                                      (Defining_Identifier (Decl), Loc),\n+                                  Right_Opnd =>\n+                                    New_Copy_Tree (Node (Discr_Elmt))),\n+                   Reason    => CE_Discriminant_Check_Failed));\n+\n+               Next_Elmt (Discr_Elmt);\n+            end if;\n+\n             Next_Discriminant (Discr);\n             J := J + 1;\n          end loop;\n \n          Odef :=\n            Make_Subtype_Indication (Loc,\n-             Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n+             Subtype_Mark => New_Occurrence_Of (B_Typ, Loc),\n              Constraint =>\n                Make_Index_Or_Discriminant_Constraint (Loc,\n                  Constraints => Constr));\n \n       --  If no discriminants, then just use the type with no constraint\n \n       else\n-         Odef := New_Occurrence_Of (Typ, Loc);\n+         Odef := New_Occurrence_Of (B_Typ, Loc);\n       end if;\n \n       --  Create an extended return statement encapsulating the result object\n@@ -1184,7 +1211,7 @@ package body Exp_Strm is\n       --  The object is about to get its value from Read, and if the type is\n       --  null excluding we do not want spurious warnings on an initial null.\n \n-      if Is_Access_Type (Typ) then\n+      if Is_Access_Type (B_Typ) then\n          Set_No_Initialization (Obj_Decl);\n       end if;\n \n@@ -1195,15 +1222,15 @@ package body Exp_Strm is\n             Make_Handled_Sequence_Of_Statements (Loc,\n               Statements => New_List (\n                 Make_Attribute_Reference (Loc,\n-                  Prefix         => New_Occurrence_Of (Typ, Loc),\n+                  Prefix         => New_Occurrence_Of (B_Typ, Loc),\n                   Attribute_Name => Name_Read,\n                   Expressions    => New_List (\n                     Make_Identifier (Loc, Name_S),\n                     Make_Identifier (Loc, Name_V)))))));\n \n-      Fnam := Make_Stream_Subprogram_Name (Loc, Typ, TSS_Stream_Input);\n+      Fnam := Make_Stream_Subprogram_Name (Loc, B_Typ, TSS_Stream_Input);\n \n-      Build_Stream_Function (Loc, Typ, Decl, Fnam, Decls, Stms);\n+      Build_Stream_Function (Loc, B_Typ, Decl, Fnam, Decls, Stms);\n    end Build_Record_Or_Elementary_Input_Function;\n \n    -------------------------------------------------"}, {"sha": "e8c47d7025f944f09cb80d3483fdc7d59effa112", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2404867dfe7ed85f8a9aff6cf218055ebbb23ae/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=f2404867dfe7ed85f8a9aff6cf218055ebbb23ae", "patch": "@@ -1057,7 +1057,11 @@ package body Lib.Xref is\n \n       XE : Xref_Entry renames Xrefs.Table (F);\n       type M is mod 2**32;\n-      H : constant M := M'Mod (XE.Key.Ent) + 2**7 * M'Mod (XE.Key.Loc);\n+\n+      H : constant M := M (XE.Key.Ent) + 2**7 * M (abs XE.Key.Loc);\n+      --  We can't use M'Mod above, because it prevents bootstrapping with\n+      --  older compilers. Loc can be negative, so we do \"abs\" before\n+      --  converting.\n    begin\n       return Header_Num (H mod Num_Buckets);\n    end Hash;"}]}