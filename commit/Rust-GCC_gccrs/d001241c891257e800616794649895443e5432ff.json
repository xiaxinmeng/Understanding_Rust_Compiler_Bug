{"sha": "d001241c891257e800616794649895443e5432ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAwMTI0MWM4OTEyNTdlODAwNjE2Nzk0NjQ5ODk1NDQzZTU0MzJmZg==", "commit": {"author": {"name": "Jan-Benedict Glaw", "email": "jbglaw@lug-owl.de", "date": "2005-05-14T17:50:00Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2005-05-14T17:50:00Z"}, "message": "vax.c: (override_options) Remove 'register' keyword.\n\n\t* config/vax/vax.c: (override_options) Remove 'register' keyword.\n\t(split_quadword_operands) Likewise. (rev_cond_name) Likewise.\n\t(vax_float_literal) Likewise. (vax_rtx_costs) Remove trailing\n\twhitespace.\n\t* config/vax/vax.h: Remove 'register' keyword. Misc. whitespace fixes,\n\tmostly removal of trailing spaces...\n\t* config/vax/vax-modes.def: Remove trailing whitespace.\n\nFrom-SVN: r99701", "tree": {"sha": "195d0641663e63da2f40a7da3cb6fa7e1492c64a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/195d0641663e63da2f40a7da3cb6fa7e1492c64a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d001241c891257e800616794649895443e5432ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d001241c891257e800616794649895443e5432ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d001241c891257e800616794649895443e5432ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d001241c891257e800616794649895443e5432ff/comments", "author": {"login": "jbglaw", "id": 7965297, "node_id": "MDQ6VXNlcjc5NjUyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/7965297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbglaw", "html_url": "https://github.com/jbglaw", "followers_url": "https://api.github.com/users/jbglaw/followers", "following_url": "https://api.github.com/users/jbglaw/following{/other_user}", "gists_url": "https://api.github.com/users/jbglaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbglaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbglaw/subscriptions", "organizations_url": "https://api.github.com/users/jbglaw/orgs", "repos_url": "https://api.github.com/users/jbglaw/repos", "events_url": "https://api.github.com/users/jbglaw/events{/privacy}", "received_events_url": "https://api.github.com/users/jbglaw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0b55eafa7ecd3bf9981cf6708db2b65aebe5cd1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b55eafa7ecd3bf9981cf6708db2b65aebe5cd1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b55eafa7ecd3bf9981cf6708db2b65aebe5cd1d"}], "stats": {"total": 126, "additions": 68, "deletions": 58}, "files": [{"sha": "e0aba2775c704540d6cddde25f25625afa9c47f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d001241c891257e800616794649895443e5432ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d001241c891257e800616794649895443e5432ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d001241c891257e800616794649895443e5432ff", "patch": "@@ -1,5 +1,13 @@\n 2005-05-14  Jan-Benedict Glaw  <jbglaw@lug-owl.de>\n \n+\t* config/vax/vax.c: (override_options) Remove 'register' keyword.\n+\t(split_quadword_operands) Likewise. (rev_cond_name) Likewise.\n+\t(vax_float_literal) Likewise. (vax_rtx_costs) Remove trailing\n+\twhitespace.\n+\t* config/vax/vax.h: Remove 'register' keyword. Misc. whitespace fixes,\n+\tmostly removal of trailing spaces...\n+\t* config/vax/vax-modes.def: Remove trailing whitespace.\n+\n \t* config/vax/elf.h: Update whitespace.\n \n 2005-05-14  Richard Guenther  <rguenth@gcc.gnu.org>"}, {"sha": "dc630b45b9b966ec48c323e66149389dd95fdeef", "filename": "gcc/config/vax/vax-modes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d001241c891257e800616794649895443e5432ff/gcc%2Fconfig%2Fvax%2Fvax-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d001241c891257e800616794649895443e5432ff/gcc%2Fconfig%2Fvax%2Fvax-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-modes.def?ref=d001241c891257e800616794649895443e5432ff", "patch": "@@ -1,4 +1,4 @@\n-/* VAX extra machine modes. \n+/* VAX extra machine modes.\n    Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GCC."}, {"sha": "81e6e2801a9ab843e8bd539867d803e838c3efc0", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d001241c891257e800616794649895443e5432ff/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d001241c891257e800616794649895443e5432ff/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=d001241c891257e800616794649895443e5432ff", "patch": "@@ -112,8 +112,8 @@ override_options (void)\n static void\n vax_output_function_prologue (FILE * file, HOST_WIDE_INT size)\n {\n-  register int regno;\n-  register int mask = 0;\n+  int regno;\n+  int mask = 0;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (regs_ever_live[regno] && !call_used_regs[regno])\n@@ -199,9 +199,9 @@ split_quadword_operands (rtx * operands, rtx * low, int n ATTRIBUTE_UNUSED)\n }\n \f\n void\n-print_operand_address (FILE * file, register rtx addr)\n+print_operand_address (FILE * file, rtx addr)\n {\n-  register rtx reg1, breg, ireg;\n+  rtx reg1, breg, ireg;\n   rtx offset;\n \n  retry:\n@@ -411,9 +411,9 @@ rev_cond_name (rtx op)\n }\n \n int\n-vax_float_literal(register rtx c)\n+vax_float_literal(rtx c)\n {\n-  register enum machine_mode mode;\n+  enum machine_mode mode;\n   REAL_VALUE_TYPE r, s;\n   int i;\n \n@@ -457,7 +457,7 @@ vax_float_literal(register rtx c)\n \n \n static int\n-vax_address_cost_1 (register rtx addr)\n+vax_address_cost_1 (rtx addr)\n {\n   int reg = 0, indexed = 0, indir = 0, offset = 0, predec = 0;\n   rtx plus_op0 = 0, plus_op1 = 0;"}, {"sha": "3fed80b0f5356b0c38f1c0a49d72b9ff950fa849", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d001241c891257e800616794649895443e5432ff/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d001241c891257e800616794649895443e5432ff/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=d001241c891257e800616794649895443e5432ff", "patch": "@@ -150,8 +150,8 @@ Boston, MA 02111-1307, USA.  */\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n    On the VAX, all registers are one word long.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n- ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the VAX, all registers can hold all modes.  */\n@@ -210,7 +210,7 @@ Boston, MA 02111-1307, USA.  */\n \n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n-   \n+\n /* The VAX has only one kind of registers, so NO_REGS and ALL_REGS\n    are the only classes.  */\n \n@@ -225,8 +225,8 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n /* Give names of register classes as strings for dump file.  */\n \n-#define REG_CLASS_NAMES \\\n- {\"NO_REGS\", \"ALL_REGS\" }\n+#define REG_CLASS_NAMES\t\\\n+  { \"NO_REGS\", \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n@@ -264,7 +264,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    'N' is a value between 0 and 65535 (inclusive)\n    `O' is a value between -63 and -1 (inclusive)  */\n \n-#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n   (  (C) == 'I' ?\t(VALUE) == 0\t\t\t\t\\\n    : (C) == 'J' ?\t0 <= (VALUE) && (VALUE) < 64\t\t\\\n    : (C) == 'O' ?\t-63 <= (VALUE) && (VALUE) < 0\t\t\\\n@@ -275,11 +275,11 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    : 0)\n \n /* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself. \n+   Here VALUE is the CONST_DOUBLE rtx itself.\n \n    `G' is a floating-point zero.  */\n \n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\\\n   ((C) == 'G' ? ((VALUE) == CONST0_RTX (DFmode)\t\t\\\n \t\t || (VALUE) == CONST0_RTX (SFmode))\t\\\n    : 0)\n@@ -289,7 +289,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    For the VAX, `Q' means that OP is a MEM that does not have a mode-dependent\n    address.  */\n \n-#define EXTRA_CONSTRAINT(OP, C) \\\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n   ((C) == 'Q'\t\t\t\t\t\t\t\t\\\n    ? GET_CODE (OP) == MEM && ! mode_dependent_address_p (XEXP (OP, 0))\t\\\n    : 0)\n@@ -348,23 +348,23 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n    On the VAX, the RET insn pops a maximum of 255 args for any function.  */\n \n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \\\n-  ((SIZE) > 255*4 ? 0 : (SIZE))\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)\t\\\n+  ((SIZE) > 255 * 4 ? 0 : (SIZE))\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n \n-/* On the VAX the return value is in R0 regardless.  */   \n+/* On the VAX the return value is in R0 regardless.  */\n \n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\\\n   gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-/* On the VAX the return value is in R0 regardless.  */   \n+/* On the VAX the return value is in R0 regardless.  */\n \n #define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 0)\n \n@@ -408,9 +408,9 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) += ((MODE) != BLKmode\t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+  ((CUM) += ((MODE) != BLKmode\t\t\t\t\\\n+\t     ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\t\\\n+\t     : (int_size_in_bytes (TYPE) + 3) & ~3))\n \n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n@@ -425,7 +425,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-/* On the VAX all args are pushed.  */   \n+/* On the VAX all args are pushed.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n \n@@ -510,9 +510,9 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    FRAMEADDR is already the frame pointer of the COUNT frame, so we\n    can ignore COUNT.  */\n \n-#define RETURN_ADDR_RTX(COUNT, FRAME)\t\\\n-  ((COUNT == 0)\t\t\t\t\\\n-   ? gen_rtx_MEM (Pmode, plus_constant (FRAME, RETURN_ADDRESS_OFFSET)) \\\n+#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\\\n+  ((COUNT == 0)\t\t\t\t\t\t\t\t\\\n+   ? gen_rtx_MEM (Pmode, plus_constant (FRAME, RETURN_ADDRESS_OFFSET))\t\\\n    : (rtx) 0)\n \n \f\n@@ -530,10 +530,10 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    Since they use reg_renumber, they are safe only once reg_renumber\n    has been allocated, which happens in local-alloc.c.  */\n \n-#define REGNO_OK_FOR_INDEX_P(regno)  \\\n-((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n-#define REGNO_OK_FOR_BASE_P(regno) \\\n-((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+#define REGNO_OK_FOR_INDEX_P(regno)\t\\\n+  ((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+#define REGNO_OK_FOR_BASE_P(regno)\t\\\n+  ((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n \f\n /* Maximum number of registers that can appear in a valid memory address.  */\n \n@@ -574,7 +574,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.  */\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-{ if (legitimate_address_p ((MODE), (X), 0)) goto ADDR; }\n+  { if (legitimate_address_p ((MODE), (X), 0)) goto ADDR; }\n \n #else\n \n@@ -587,14 +587,14 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.  */\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-{ if (legitimate_address_p ((MODE), (X), 1)) goto ADDR; }\n+  { if (legitimate_address_p ((MODE), (X), 1)) goto ADDR; }\n \n #endif\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL) \\\n- { if (vax_mode_dependent_address_p (ADDR)) goto LABEL; }\n+  { if (vax_mode_dependent_address_p (ADDR)) goto LABEL; }\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n@@ -665,13 +665,14 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    after execution of an instruction whose pattern is EXP.\n    Do not alter them if the instruction would not alter the cc's.  */\n \n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+#define NOTICE_UPDATE_CC(EXP, INSN)\t\\\n   vax_notice_update_cc ((EXP), (INSN))\n \n-#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)  \\\n-{ if (cc_status.flags & CC_NO_OVERFLOW)\t\t\t\t\\\n-    return NO_OV;\t\t\t\t\t\t\\\n-  return NORMAL; }\n+#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)\t\\\n+  { if (cc_status.flags & CC_NO_OVERFLOW)\t\\\n+      return NO_OV;\t\t\t\t\\\n+    return NORMAL;\t\t\t\t\\\n+  }\n \f\n /* Control the assembler format that we output.  */\n \n@@ -704,9 +705,9 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    The register names will be prefixed by REGISTER_PREFIX, if any.  */\n \n #define REGISTER_PREFIX \"\"\n-#define REGISTER_NAMES \\\n-{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \\\n- \"r9\", \"r10\", \"r11\", \"ap\", \"fp\", \"sp\", \"pc\"}\n+#define REGISTER_NAMES\t\t\t\t\t\\\n+  { \"r0\", \"r1\",  \"r2\",  \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\t\\\n+    \"r8\", \"r9\", \"r10\", \"r11\", \"ap\", \"fp\", \"sp\", \"pc\", }\n \n /* This is BSD, so it wants DBX format.  */\n \n@@ -760,8 +761,8 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* This is how to output an insn to pop a register from the stack.\n    It need not be very fast code.  */\n \n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmovl (%s)+,%s\\n\", reg_names[STACK_POINTER_REGNUM], \\\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tmovl (%s)+,%s\\n\", reg_names[STACK_POINTER_REGNUM],\t\\\n \t   reg_names[REGNO])\n \n /* This is how to output an element of a case-vector that is absolute.\n@@ -811,26 +812,26 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* This says how to output an assembler line\n    to define a global common symbol.  */\n \n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (int)(ROUNDED)))\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n+  ( fputs (\".comm \", (FILE)),\t\t\t\t\\\n+    assemble_name ((FILE), (NAME)),\t\t\t\\\n+    fprintf ((FILE), \",%u\\n\", (int)(ROUNDED)))\n \n /* This says how to output an assembler line\n    to define a local common symbol.  */\n \n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".lcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (int)(ROUNDED)))\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n+  ( fputs (\".lcomm \", (FILE)),\t\t\t\t\\\n+    assemble_name ((FILE), (NAME)),\t\t\t\\\n+    fprintf ((FILE), \",%u\\n\", (int)(ROUNDED)))\n \n /* Store in OUTPUT a string (made with alloca) containing\n    an assembler-name for a local static variable named NAME.\n    LABELNO is an integer which is different for each call.  */\n \n #define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n-( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n-  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+  ( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+    sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n \n /* Print an instruction operand X on file FILE.\n    CODE is the code from the %-spec that requested printing this operand;\n@@ -865,7 +866,7 @@ VAX operand formatting codes:\n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n   ((CODE) == '#' || (CODE) == '|')\n \n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n+#define PRINT_OPERAND(FILE, X, CODE)\t\t\t\t\t\\\n { if (CODE == '#') fputc (ASM_DOUBLE_CHAR, FILE);\t\t\t\\\n   else if (CODE == '|')\t\t\t\t\t\t\t\\\n     fputs (REGISTER_PREFIX, FILE);\t\t\t\t\t\\\n@@ -910,9 +911,10 @@ VAX operand formatting codes:\n    This uses a function in output-vax.c.  */\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n- print_operand_address (FILE, ADDR)\n+  print_operand_address (FILE, ADDR)\n \n /* This is a blatent lie.  However, it's good enough, since we don't\n    actually have any code whatsoever for which this isn't overridden\n    by the proper FDE definition.  */\n #define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, PC_REGNUM)\n+"}]}