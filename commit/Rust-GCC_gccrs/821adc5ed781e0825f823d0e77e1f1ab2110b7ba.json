{"sha": "821adc5ed781e0825f823d0e77e1f1ab2110b7ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIxYWRjNWVkNzgxZTA4MjVmODIzZDBlNzdlMWYxYWIyMTEwYjdiYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-01-17T15:35:28Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-01-17T15:35:28Z"}, "message": "* dbxout.c (dbxout_type): Support const and volatile.\n\nFrom-SVN: r48954", "tree": {"sha": "7a54a9a7ef4139b4421418ab70e145b4ee700a9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a54a9a7ef4139b4421418ab70e145b4ee700a9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/821adc5ed781e0825f823d0e77e1f1ab2110b7ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/821adc5ed781e0825f823d0e77e1f1ab2110b7ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/821adc5ed781e0825f823d0e77e1f1ab2110b7ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/821adc5ed781e0825f823d0e77e1f1ab2110b7ba/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dbd680e1636e46f4a7ee628da1adb73862d9f419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbd680e1636e46f4a7ee628da1adb73862d9f419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbd680e1636e46f4a7ee628da1adb73862d9f419"}], "stats": {"total": 51, "additions": 36, "deletions": 15}, "files": [{"sha": "de5d585dabaf2b3dee5f4020512d8ff5dfbdb18c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821adc5ed781e0825f823d0e77e1f1ab2110b7ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821adc5ed781e0825f823d0e77e1f1ab2110b7ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=821adc5ed781e0825f823d0e77e1f1ab2110b7ba", "patch": "@@ -1,5 +1,7 @@\n 2002-01-17  Jason Merrill  <jason@redhat.com>\n \n+\t* dbxout.c (dbxout_type): Support const and volatile.\n+\n \t* except.c (add_partial_entry): Remove backwards compatibility code.\n \t(end_protect_partials): Likewise.\n "}, {"sha": "abcbee0ed979c6e6fec323c266af53635a059d23", "filename": "gcc/dbxout.c", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821adc5ed781e0825f823d0e77e1f1ab2110b7ba/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821adc5ed781e0825f823d0e77e1f1ab2110b7ba/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=821adc5ed781e0825f823d0e77e1f1ab2110b7ba", "patch": "@@ -1038,6 +1038,7 @@ dbxout_type (type, full)\n      int full;\n {\n   tree tem;\n+  tree main_variant;\n   static int anonymous_type_number = 0;\n \n   if (TREE_CODE (type) == VECTOR_TYPE)\n@@ -1050,24 +1051,24 @@ dbxout_type (type, full)\n     type = integer_type_node;\n   else\n     {\n-      /* Try to find the \"main variant\" with the same name but not const\n-\t or volatile.  (Since stabs does not distinguish const and volatile,\n-\t there is no need to make them separate types.  But types with\n-\t different names are usefully distinguished.) */\n-\t \n-      for (tem = TYPE_MAIN_VARIANT (type); tem; tem = TYPE_NEXT_VARIANT (tem))\n-\tif (!TYPE_READONLY (tem) && !TYPE_VOLATILE (tem)\n-\t    && TYPE_NAME (tem) == TYPE_NAME (type))\n-\t  {\n-\t    type = tem;\n-\t    break;\n-\t  }\n       if (TYPE_NAME (type)\n \t  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t  && TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (type)))\n \tfull = 0;\n     }\n \n+  /* Try to find the \"main variant\" with the same name.  */\n+  if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+      && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))\n+    main_variant = TREE_TYPE (TYPE_NAME (type));\n+  else\n+    main_variant = TYPE_MAIN_VARIANT (type);\n+\n+  /* If we are not using extensions, stabs does not distinguish const and\n+     volatile, so there is no need to make them separate types.  */\n+  if (!use_gnu_debug_info_extensions)\n+    type = main_variant;\n+\n   if (TYPE_SYMTAB_ADDRESS (type) == 0)\n     {\n       /* Type has no dbx number assigned.  Assign next available number.  */\n@@ -1157,12 +1158,30 @@ dbxout_type (type, full)\n \n   typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_DEFINED;\n \n-  if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-      && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))\n-    { \n+  /* If this type is a variant of some other, hand off.  Types with\n+     different names are usefully distinguished.  We only distinguish\n+     cv-qualified types if we're using extensions.  */\n+  if (TYPE_READONLY (type) > TYPE_READONLY (main_variant))\n+    {\n+      putc ('k', asmfile);\n+      CHARS (1);\n+      dbxout_type (build_type_variant (type, 0, TYPE_VOLATILE (type)), 0);\n+      return;\n+    }\n+  else if (TYPE_VOLATILE (type) > TYPE_VOLATILE (main_variant))\n+    {\n+      putc ('B', asmfile);\n+      CHARS (1);\n+      dbxout_type (build_type_variant (type, TYPE_READONLY (type), 0), 0);\n+      return;\n+    }\n+  else if (main_variant != TYPE_MAIN_VARIANT (type))\n+    {\n+      /* 'type' is a typedef; output the type it refers to.  */\n       dbxout_type (DECL_ORIGINAL_TYPE (TYPE_NAME (type)), 0);\n       return;\n     }\n+  /* else continue.  */\n \n   switch (TREE_CODE (type))\n     {"}]}