{"sha": "848bcda52d7431c3be9c33c9803928ae7c54583a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ4YmNkYTUyZDc0MzFjM2JlOWMzM2M5ODAzOTI4YWU3YzU0NTgzYQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-08-09T11:02:53Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-08-09T11:02:53Z"}, "message": "Improve handling of unknown sign bit in CCP.\n\nThis middle-end patch implements several related improvements to\ntree-ssa's conditional (bit) constant propagation pass.  The current\ncode handling ordered comparisons contains the comment \"If the\nmost significant bits are not known we know nothing\" which is not\nentirely true [this test even prevents this pass understanding these\ncomparisons always have a zero or one result].  This patch introduces\na new value_mask_to_min_max helper function, that understands the\ndifferent semantics of the most significant bit on signed vs.\nunsigned values.  This allows us to generalize ordered comparisons,\nGE_EXPR, GT_EXPR, LE_EXPR and LT_EXPR, where to code is tweaked to\ncorrectly handle the potential equal cases.  Then finally support\nis added for the related tree codes MIN_EXPR, MAX_EXPR, ABS_EXPR\nand ABSU_EXPR.\n\nRegression testing revealed three test cases in the testsuite that\nwere checking for specific optimizations that are now being performed\nearlier than expected.  These tests can continue to check their\noriginal transformations by explicitly adding -fno-tree-ccp to their\ndg-options (some already specify -fno-ipa-vrp or -fno-tree-forwprop\nfor the same reason).\n\n2021-08-09  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* tree-ssa-ccp.c (value_mask_to_min_max): Helper function to\n\tdetermine the upper and lower bounds from a mask-value pair.\n\t(bit_value_unop) [ABS_EXPR, ABSU_EXPR]: Add support for\n\tabsolute value and unsigned absolute value expressions.\n\t(bit_value_binop):  Initialize *VAL's precision.\n\t[LT_EXPR, LE_EXPR]: Use value_mask_to_min_max to determine\n\tupper and lower bounds of operands.  Add LE_EXPR/GE_EXPR\n\tsupport when the operands are unknown but potentially equal.\n\t[MIN_EXPR, MAX_EXPR]: Support minimum/maximum expressions.\n\ngcc/testsuite/ChangeLog\n\t* gcc.dg/pr68217.c: Add -fno-tree-ccp option.\n\t* gcc.dg/tree-ssa/vrp24.c: Add -fno-tree-ccp option.\n\t* g++.dg/ipa/pure-const-3.C: Add -fno-tree-ccp option.", "tree": {"sha": "4f610e987914521bbad5d6b65bb317d3f6fc310c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f610e987914521bbad5d6b65bb317d3f6fc310c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/848bcda52d7431c3be9c33c9803928ae7c54583a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848bcda52d7431c3be9c33c9803928ae7c54583a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/848bcda52d7431c3be9c33c9803928ae7c54583a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848bcda52d7431c3be9c33c9803928ae7c54583a/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eff2a3cb521c58212885a3dca638764285b5691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eff2a3cb521c58212885a3dca638764285b5691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eff2a3cb521c58212885a3dca638764285b5691"}], "stats": {"total": 124, "additions": 107, "deletions": 17}, "files": [{"sha": "172a36bedb5b3df66b02a2eae6c0cc7574d43de9", "filename": "gcc/testsuite/g++.dg/ipa/pure-const-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bcda52d7431c3be9c33c9803928ae7c54583a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bcda52d7431c3be9c33c9803928ae7c54583a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-3.C?ref=848bcda52d7431c3be9c33c9803928ae7c54583a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-ipa-vrp -fdump-tree-optimized\"  } */\n+/* { dg-options \"-O2 -fno-ipa-vrp -fdump-tree-optimized -fno-tree-ccp\"  } */\n int *ptr;\n static int barvar;\n static int b(int a);"}, {"sha": "eb4f15e048fe3f84578283bf4fd7cdf0b87fb0ee", "filename": "gcc/testsuite/gcc.dg/pr68217.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bcda52d7431c3be9c33c9803928ae7c54583a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr68217.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bcda52d7431c3be9c33c9803928ae7c54583a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr68217.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr68217.c?ref=848bcda52d7431c3be9c33c9803928ae7c54583a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdisable-tree-evrp -fdump-tree-vrp1\" } */\n+/* { dg-options \"-O2 -fdisable-tree-evrp -fdump-tree-vrp1 -fno-tree-ccp\" } */\n \n int foo (void)\n {"}, {"sha": "91015da86aebe385c6d47256d2e8e1e0782bc640", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp24.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bcda52d7431c3be9c33c9803928ae7c54583a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bcda52d7431c3be9c33c9803928ae7c54583a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp24.c?ref=848bcda52d7431c3be9c33c9803928ae7c54583a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-forwprop -fdump-tree-evrp-details -fdump-tree-optimized\" } */\n+/* { dg-options \"-O2 -fno-tree-forwprop -fdump-tree-evrp-details -fdump-tree-optimized -fno-tree-ccp\" } */\n \n \n struct rtx_def;"}, {"sha": "003c9c2af9df8a58cc2eb86e703f95c9a052ac12", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 104, "deletions": 14, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bcda52d7431c3be9c33c9803928ae7c54583a/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bcda52d7431c3be9c33c9803928ae7c54583a/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=848bcda52d7431c3be9c33c9803928ae7c54583a", "patch": "@@ -1293,6 +1293,28 @@ ccp_fold (gimple *stmt)\n     }\n }\n \n+/* Determine the minimum and maximum values, *MIN and *MAX respectively,\n+   represented by the mask pair VAL and MASK with signedness SGN and\n+   precision PRECISION.  */\n+\n+void\n+value_mask_to_min_max (widest_int *min, widest_int *max,\n+\t\t       const widest_int &val, const widest_int &mask,\n+\t\t       signop sgn, int precision)\n+{\n+  *min = wi::bit_and_not (val, mask);\n+  *max = val | mask;\n+  if (sgn == SIGNED && wi::neg_p (mask))\n+    {\n+      widest_int sign_bit = wi::lshift (1, precision - 1);\n+      *min ^= sign_bit;\n+      *max ^= sign_bit;\n+      /* MAX is zero extended, and MIN is sign extended.  */\n+      *min = wi::ext (*min, precision, sgn);\n+      *max = wi::ext (*max, precision, sgn);\n+    }\n+}\n+\n /* Apply the operation CODE in type TYPE to the value, mask pair\n    RVAL and RMASK representing a value of type RTYPE and set\n    the value, mask pair *VAL and *MASK to the result.  */\n@@ -1334,6 +1356,33 @@ bit_value_unop (enum tree_code code, signop type_sgn, int type_precision,\n \tbreak;\n       }\n \n+    case ABS_EXPR:\n+    case ABSU_EXPR:\n+      if (wi::sext (rmask, rtype_precision) == -1)\n+\t*mask = -1;\n+      else if (wi::neg_p (rmask))\n+\t{\n+\t  /* Result is either rval or -rval.  */\n+\t  widest_int temv, temm;\n+\t  bit_value_unop (NEGATE_EXPR, rtype_sgn, rtype_precision, &temv,\n+\t\t\t  &temm, type_sgn, type_precision, rval, rmask);\n+\t  temm |= (rmask | (rval ^ temv));\n+\t  /* Extend the result.  */\n+\t  *mask = wi::ext (temm, type_precision, type_sgn);\n+\t  *val = wi::ext (temv, type_precision, type_sgn);\n+\t}\n+      else if (wi::neg_p (rval))\n+\t{\n+\t  bit_value_unop (NEGATE_EXPR, type_sgn, type_precision, val, mask,\n+\t\t\t  type_sgn, type_precision, rval, rmask);\n+\t}\n+      else\n+\t{\n+\t  *mask = rmask;\n+\t  *val = rval;\n+\t}\n+      break;\n+\n     default:\n       *mask = -1;\n       break;\n@@ -1357,6 +1406,8 @@ bit_value_binop (enum tree_code code, signop sgn, int width,\n   /* Assume we'll get a constant result.  Use an initial non varying\n      value, we fall back to varying in the end if necessary.  */\n   *mask = -1;\n+  /* Ensure that VAL is initialized (to any value).  */\n+  *val = 0;\n \n   switch (code)\n     {\n@@ -1527,33 +1578,29 @@ bit_value_binop (enum tree_code code, signop sgn, int width,\n     case LT_EXPR:\n     case LE_EXPR:\n       {\n+\twidest_int min1, max1, min2, max2;\n \tint minmax, maxmin;\n \n \tconst widest_int &o1val = swap_p ? r2val : r1val;\n \tconst widest_int &o1mask = swap_p ? r2mask : r1mask;\n \tconst widest_int &o2val = swap_p ? r1val : r2val;\n \tconst widest_int &o2mask = swap_p ? r1mask : r2mask;\n \n-\t/* If the most significant bits are not known we know nothing.  */\n-\tif (wi::neg_p (o1mask) || wi::neg_p (o2mask))\n-\t  break;\n+\tvalue_mask_to_min_max (&min1, &max1, o1val, o1mask,\n+\t\t\t       r1type_sgn, r1type_precision);\n+\tvalue_mask_to_min_max (&min2, &max2, o2val, o2mask,\n+\t\t\t       r1type_sgn, r1type_precision);\n \n \t/* For comparisons the signedness is in the comparison operands.  */\n-\tsgn = r1type_sgn;\n-\n-\t/* If we know the most significant bits we know the values\n-\t   value ranges by means of treating varying bits as zero\n-\t   or one.  Do a cross comparison of the max/min pairs.  */\n-\tmaxmin = wi::cmp (o1val | o1mask,\n-\t\t\t  wi::bit_and_not (o2val, o2mask), sgn);\n-\tminmax = wi::cmp (wi::bit_and_not (o1val, o1mask),\n-\t\t\t  o2val | o2mask, sgn);\n-\tif (maxmin < 0)  /* o1 is less than o2.  */\n+\t/* Do a cross comparison of the max/min pairs.  */\n+\tmaxmin = wi::cmp (max1, min2, r1type_sgn);\n+\tminmax = wi::cmp (min1, max2, r1type_sgn);\n+\tif (maxmin < (code == LE_EXPR ? 1: 0))  /* o1 < or <= o2.  */\n \t  {\n \t    *mask = 0;\n \t    *val = 1;\n \t  }\n-\telse if (minmax > 0)  /* o1 is not less or equal to o2.  */\n+\telse if (minmax > (code == LT_EXPR ? -1 : 0))  /* o1 >= or > o2.  */\n \t  {\n \t    *mask = 0;\n \t    *val = 0;\n@@ -1574,6 +1621,49 @@ bit_value_binop (enum tree_code code, signop sgn, int width,\n \tbreak;\n       }\n \n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+      {\n+\twidest_int min1, max1, min2, max2;\n+\n+\tvalue_mask_to_min_max (&min1, &max1, r1val, r1mask, sgn, width);\n+\tvalue_mask_to_min_max (&min2, &max2, r2val, r2mask, sgn, width);\n+\n+\tif (wi::cmp (max1, min2, sgn) <= 0)  /* r1 is less than r2.  */\n+\t  {\n+\t    if (code == MIN_EXPR)\n+\t      {\n+\t\t*mask = r1mask;\n+\t\t*val = r1val;\n+\t      }\n+\t    else\n+\t      {\n+\t\t*mask = r2mask;\n+\t\t*val = r2val;\n+\t      }\n+\t  }\n+\telse if (wi::cmp (min1, max2, sgn) >= 0)  /* r2 is less than r1.  */\n+\t  {\n+\t    if (code == MIN_EXPR)\n+\t      {\n+\t\t*mask = r2mask;\n+\t\t*val = r2val;\n+\t      }\n+\t    else\n+\t      {\n+\t\t*mask = r1mask;\n+\t\t*val = r1val;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    /* The result is either r1 or r2.  */\n+\t    *mask = r1mask | r2mask | (r1val ^ r2val);\n+\t    *val = r1val;\n+\t  }\n+\tbreak;\n+      }\n+\n     default:;\n     }\n }"}]}