{"sha": "4d9720f0c7f0f8fe29b036198c07750d0538b806", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ5NzIwZjBjN2YwZjhmZTI5YjAzNjE5OGMwNzc1MGQwNTM4YjgwNg==", "commit": {"author": {"name": "Hans Boehm", "email": "Hans_Boehm@hp.com", "date": "2001-12-28T22:15:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-28T22:15:41Z"}, "message": "linux.h (MD_FALLBACK_FRAME_STATE_FOR): New.\n\n        * config/ia64/linux.h (MD_FALLBACK_FRAME_STATE_FOR): New.\n        * config/ia64/unwind-ia64.c (uw_init_context_1): Redo sp, psp,\n        bsp setup.  Set pri_unat_loc to something reasonable.\n        (uw_install_context): Add missing cast.\n        (unw_access_gr): Fix off-by-1 indexing error.\n\nFrom-SVN: r48352", "tree": {"sha": "8f8b1cf4bd5e6d0b98e28646d4e99653f59495d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f8b1cf4bd5e6d0b98e28646d4e99653f59495d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d9720f0c7f0f8fe29b036198c07750d0538b806", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d9720f0c7f0f8fe29b036198c07750d0538b806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d9720f0c7f0f8fe29b036198c07750d0538b806", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d9720f0c7f0f8fe29b036198c07750d0538b806/comments", "author": null, "committer": null, "parents": [{"sha": "be3996918fa6ab11da8e1a9a78e2fa54af428f1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be3996918fa6ab11da8e1a9a78e2fa54af428f1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be3996918fa6ab11da8e1a9a78e2fa54af428f1a"}], "stats": {"total": 118, "additions": 95, "deletions": 23}, "files": [{"sha": "c81563f79ec56a23157fb1079e5343e61ea43c8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9720f0c7f0f8fe29b036198c07750d0538b806/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9720f0c7f0f8fe29b036198c07750d0538b806/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d9720f0c7f0f8fe29b036198c07750d0538b806", "patch": "@@ -1,3 +1,11 @@\n+2001-12-28  Hans Bohem  <hans_boehm@hp.com>\n+\n+\t* config/ia64/linux.h (MD_FALLBACK_FRAME_STATE_FOR): New.\n+\t* config/ia64/unwind-ia64.c (uw_init_context_1): Redo sp, psp,\n+\tbsp setup.  Set pri_unat_loc to something reasonable.\n+\t(uw_install_context): Add missing cast.\n+\t(unw_access_gr): Fix off-by-1 indexing error.\n+\n 2001-12-28  Kazu Hirata  <kazu@hxi.com>\n \n \t* except.c: Fix comment formatting."}, {"sha": "61e80a4a0396b80639bc7dc4b92db74b5823f8bf", "filename": "gcc/config/ia64/linux.h", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9720f0c7f0f8fe29b036198c07750d0538b806/gcc%2Fconfig%2Fia64%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9720f0c7f0f8fe29b036198c07750d0538b806/gcc%2Fconfig%2Fia64%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Flinux.h?ref=4d9720f0c7f0f8fe29b036198c07750d0538b806", "patch": "@@ -60,4 +60,63 @@\n #undef LINK_EH_SPEC\n #define LINK_EH_SPEC \"\"\n \n-/* End of linux.h */\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#ifdef IN_LIBGCC2\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+\n+#define IA64_GATE_AREA_START 0xa000000000000100LL\n+#define IA64_GATE_AREA_END   0xa000000000010000LL\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n+  if ((CONTEXT)->rp >= IA64_GATE_AREA_START\t\t\t\t\\\n+      && (CONTEXT)->rp < IA64_GATE_AREA_END)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      struct sigframe {\t\t\t\t\t\t\t\\\n+\tchar scratch[16];\t\t\t\t\t\t\\\n+\tunsigned long sig_number;\t\t\t\t\t\\\n+\tstruct siginfo *info;\t\t\t\t\t\t\\\n+\tstruct sigcontext *sc;\t\t\t\t\t\t\\\n+      } *frame_ = (struct sigframe *)(CONTEXT)->psp;\t\t\t\\\n+      struct sigcontext *sc_ = frame_->sc;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Restore scratch registers in case the unwinder needs to\t\\\n+\t refer to a value stored in one of them.  */\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint i_;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfor (i_ = 2; i_ < 4; i_++)\t\t\t\t\t\\\n+\t  (CONTEXT)->ireg[i_ - 2].loc = &sc_->sc_gr[i_];\t\t\\\n+\tfor (i_ = 8; i_ < 12; i_++)\t\t\t\t\t\\\n+\t  (CONTEXT)->ireg[i_ - 2].loc = &sc_->sc_gr[i_];\t\t\\\n+\tfor (i_ = 14; i_ < 32; i_++)\t\t\t\t\t\\\n+\t  (CONTEXT)->ireg[i_ - 2].loc = &sc_->sc_gr[i_];\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\t\\\n+      (CONTEXT)->pfs_loc = &(sc_->sc_ar_pfs);\t\t\t\t\\\n+      (CONTEXT)->lc_loc = &(sc_->sc_ar_lc);\t\t\t\t\\\n+      (CONTEXT)->unat_loc = &(sc_->sc_ar_unat);\t\t\t\t\\\n+      (CONTEXT)->pr = sc_->sc_pr;\t\t\t\t\t\\\n+      (CONTEXT)->psp = sc_->sc_gr[12];\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Don't touch the branch registers.  The kernel doesn't\t\t\\\n+\t pass the preserved branch registers in the sigcontext but\t\\\n+\t leaves them intact, so there's no need to do anything\t\t\\\n+\t with them here.  */\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tunsigned long sof = sc_->sc_cfm & 0x7f;\t\t\t\t\\\n+\t(CONTEXT)->bsp = (unsigned long)\t\t\t\t\\\n+\t  ia64_rse_skip_regs ((unsigned long *)(sc_->sc_ar_bsp), -sof); \\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      (FS)->curr.reg[UNW_REG_RP].where = UNW_WHERE_SPREL;\t\t\\\n+      (FS)->curr.reg[UNW_REG_RP].val \t\t\t\t\t\\\n+\t= (unsigned long)&(sc_->sc_ip) - (CONTEXT)->psp;\t\t\\\n+      (FS)->curr.reg[UNW_REG_RP].when = -1;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      goto SUCCESS;\t\t\t\t\t\t\t\\\n+    }\n+#endif /* IN_LIBGCC2 */"}, {"sha": "045abe5b7f60d2144a3b60ce85984ed95f341933", "filename": "gcc/config/ia64/unwind-ia64.c", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9720f0c7f0f8fe29b036198c07750d0538b806/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9720f0c7f0f8fe29b036198c07750d0538b806/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=4d9720f0c7f0f8fe29b036198c07750d0538b806", "patch": "@@ -36,9 +36,6 @@\n #include \"unwind-ia64.h\"\n \n #if !USING_SJLJ_EXCEPTIONS\n-\n-#define inline\n-\f\n #define UNW_VER(x)\t\t((x) >> 48)\n #define UNW_FLAG_MASK\t\t0x0000ffff00000000\n #define UNW_FLAG_OSMASK\t\t0x0000f00000000000\n@@ -174,7 +171,8 @@ struct _Unwind_Context\n   unsigned long regstk_top;\t/* bsp for first frame */\n \n   /* Current frame info.  */\n-  unsigned long bsp;\t\t/* backing store pointer value */\n+  unsigned long bsp;\t\t/* backing store pointer value\n+\t\t\t\t   corresponding to psp.  */\n   unsigned long sp;\t\t/* stack pointer value */\n   unsigned long psp;\t\t/* previous sp value */\n   unsigned long rp;\t\t/* return pointer */\n@@ -203,10 +201,14 @@ struct _Unwind_Context\n       enum unw_nat_type type : 3;\n       signed long off : 61;\t\t/* NaT word is at loc+nat.off */\n     } nat;\n-  } ireg[32 - 2];\n+  } ireg[32 - 2];\t/* Indexed by <register number> - 2 */\n \n   unsigned long *br_loc[7];\n   void *fr_loc[32 - 2];\n+\n+  /* ??? We initially point pri_unat_loc here.  The entire NAT bit\n+     logic needs work.  */\n+  unsigned long initial_unat;\n };\n \n typedef unsigned long unw_word;\n@@ -1317,7 +1319,7 @@ unw_access_gr (struct _Unwind_Context *info, int regnum,\n   else if (regnum < 32)\n     {\n       /* Access a non-stacked register.  */\n-      ireg = &info->ireg[regnum - 1];\n+      ireg = &info->ireg[regnum - 2];\n       addr = ireg->loc;\n       if (addr)\n \t{\n@@ -1468,7 +1470,7 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n     {\n       /* Couldn't find unwind info for this function.  Try an\n \t os-specific fallback mechanism.  This will necessarily\n-\t not profide a personality routine or LSDA.  */\n+\t not provide a personality routine or LSDA.  */\n #ifdef MD_FALLBACK_FRAME_STATE_FOR\n       MD_FALLBACK_FRAME_STATE_FOR (context, fs, success);\n \n@@ -1727,38 +1729,40 @@ uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n }\n \n /* Fill in CONTEXT for top-of-stack.  The only valid registers at this\n-   level will be the return address and the CFA.  */\n+   level will be the return address and the CFA.  Note that CFA = SP+16.  */\n    \n-#define uw_init_context(CONTEXT) \\\n-  uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (), __builtin_ia64_bsp ())\n+#define uw_init_context(CONTEXT)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    /* ??? There is a whole lot o code in uw_install_context that\t\\\n+       tries to avoid spilling the entire machine state here.  We\t\\\n+       should try to make that work again.  */\t\t\t\t\\\n+    __builtin_unwind_init();\t\t\t\t\t\t\\\n+    uw_init_context_1 (CONTEXT, __builtin_ia64_bsp ());\t\t\t\\\n+  } while (0)\n \n static void\n-uw_init_context_1 (struct _Unwind_Context *context, void *psp, void *bsp)\n+uw_init_context_1 (struct _Unwind_Context *context, void *bsp)\n {\n   void *rp = __builtin_extract_return_addr (__builtin_return_address (0));\n-  void *sp = __builtin_dwarf_cfa ();\n+  /* Set psp to the caller's stack pointer. */\n+  void *psp = __builtin_dwarf_cfa () - 16;\n   _Unwind_FrameState fs;\n \n   /* Flush the register stack to memory so that we can access it.  */\n   __builtin_ia64_flushrs ();\n \n   memset (context, 0, sizeof (struct _Unwind_Context));\n-  context->bsp = (unsigned long) bsp;\n-  context->sp = (unsigned long) sp;\n+  context->bsp = context->regstk_top = (unsigned long) bsp;\n   context->psp = (unsigned long) psp;\n   context->rp = (unsigned long) rp;\n-\n+  asm (\"mov %0 = sp\" : \"=r\" (context->sp));\n   asm (\"mov %0 = pr\" : \"=r\" (context->pr));\n+  context->pri_unat_loc = &context->initial_unat;\t/* ??? */\n   /* ??? Get rnat.  Don't we have to turn off the rse for that?  */\n \n   if (uw_frame_state_for (context, &fs) != _URC_NO_REASON)\n     abort ();\n \n-  /* Force the frame state to use the known cfa value.  */\n-  fs.curr.reg[UNW_REG_PSP].when = -1;\n-  fs.curr.reg[UNW_REG_PSP].where = UNW_WHERE_NONE;\n-  fs.curr.reg[UNW_REG_PSP].val = sp - psp;\n-\n   uw_update_context (context, &fs);\n }\n \n@@ -1791,8 +1795,9 @@ uw_install_context (struct _Unwind_Context *current __attribute__((unused)),\n      target function.  The value that we install below will be\n      adjusted by the BR.RET instruction based on the contents\n      of AR.PFS.  So we must unadjust that here.  */\n-  target->bsp\n-    = ia64_rse_skip_regs (target->bsp, (*target->pfs_loc >> 7) & 0x7f);\n+  target->bsp = (unsigned long)\n+    ia64_rse_skip_regs ((unsigned long *)target->bsp,\n+\t\t\t(*target->pfs_loc >> 7) & 0x7f);\n \n   /* Provide assembly with the offsets into the _Unwind_Context.  */\n   asm volatile (\"uc_rnat = %0\""}]}