{"sha": "e89993b3f2085c19cda293fc0476ba2c7da3107d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg5OTkzYjNmMjA4NWMxOWNkYTI5M2ZjMDQ3NmJhMmM3ZGEzMTA3ZA==", "commit": {"author": {"name": "Andrew Pinski", "email": "andrew_pinski@playstation.sony.com", "date": "2007-06-15T03:39:31Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2007-06-15T03:39:31Z"}, "message": "tree-mudflap.c: Fix whitespace issues.\n\n2007-06-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        * tree-mudflap.c: Fix whitespace issues.\n\nFrom-SVN: r125733", "tree": {"sha": "a62c724880cca675c9c86a4b9b67f1e12836306e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a62c724880cca675c9c86a4b9b67f1e12836306e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e89993b3f2085c19cda293fc0476ba2c7da3107d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89993b3f2085c19cda293fc0476ba2c7da3107d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e89993b3f2085c19cda293fc0476ba2c7da3107d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89993b3f2085c19cda293fc0476ba2c7da3107d/comments", "author": null, "committer": null, "parents": [{"sha": "83f6221b98886998f42915bf5d594b2a2ae17c71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f6221b98886998f42915bf5d594b2a2ae17c71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83f6221b98886998f42915bf5d594b2a2ae17c71"}], "stats": {"total": 48, "additions": 33, "deletions": 15}, "files": [{"sha": "a473387d7e80fc8c2a3ccb6d479a0129070b14c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89993b3f2085c19cda293fc0476ba2c7da3107d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89993b3f2085c19cda293fc0476ba2c7da3107d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e89993b3f2085c19cda293fc0476ba2c7da3107d", "patch": "@@ -1,3 +1,7 @@\n+2007-06-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree-mudflap.c: Fix whitespace issues.\n+\n 2007-06-15  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* config/m68k/m68k.c (ASM_DOT, ASM_DOTW, ASM_DOTL): Remove."}, {"sha": "c3c8604b177c0456b8a95d2fcaa4b22d06c3ab8e", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89993b3f2085c19cda293fc0476ba2c7da3107d/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89993b3f2085c19cda293fc0476ba2c7da3107d/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=e89993b3f2085c19cda293fc0476ba2c7da3107d", "patch": "@@ -328,17 +328,23 @@ mf_make_mf_cache_struct_type (tree field_type)\n   return struct_type;\n }\n \n-#define build_function_type_0(rtype)            \\\n+#define build_function_type_0(rtype)           \t\t\t\t\\\n   build_function_type (rtype, void_list_node)\n-#define build_function_type_1(rtype, arg1)                 \\\n+#define build_function_type_1(rtype, arg1)                \t\t\\\n   build_function_type (rtype, tree_cons (0, arg1, void_list_node))\n #define build_function_type_3(rtype, arg1, arg2, arg3)                  \\\n-  build_function_type (rtype, tree_cons (0, arg1, tree_cons (0, arg2,   \\\n-                                                             tree_cons (0, arg3, void_list_node))))\n+  build_function_type (rtype,\t\t\t\t\t\t\\\n+\t\t       tree_cons (0, arg1, \t\t\t\t\\\n+\t\t\t\t  tree_cons (0, arg2,  \t\t\t\\\n+                                              tree_cons (0, arg3, \t\\\n+\t\t\t\t\t\t\t void_list_node))))\n #define build_function_type_4(rtype, arg1, arg2, arg3, arg4)            \\\n-  build_function_type (rtype, tree_cons (0, arg1, tree_cons (0, arg2,   \\\n-                                                             tree_cons (0, arg3, tree_cons (0, arg4, \\\n-                                                                                            void_list_node)))))\n+  build_function_type (rtype, \t\t\t\t\t\t\\\n+\t\t       tree_cons (0, arg1,\t\t\t\t\\\n+\t\t\t\t  tree_cons (0, arg2,   \t\t\\\n+                                             tree_cons (0, arg3,\t\\\n+\t\t\t\t\t\t\ttree_cons (0, arg4, \\\n+                                                \t\t   void_list_node)))))\n \n /* Initialize the global tree nodes that correspond to mf-runtime.h\n    declarations.  */\n@@ -571,9 +577,11 @@ mf_build_check_statement_for (tree base, tree limit,\n   /* Build: __mf_elem = &__mf_lookup_cache [(__mf_base >> __mf_shift)\n                                             & __mf_mask].  */\n   t = build2 (RSHIFT_EXPR, mf_uintptr_type, mf_base,\n-              (flag_mudflap_threads ? mf_cache_shift_decl : mf_cache_shift_decl_l));\n+              flag_mudflap_threads ? mf_cache_shift_decl\n+\t       : mf_cache_shift_decl_l);\n   t = build2 (BIT_AND_EXPR, mf_uintptr_type, t,\n-              (flag_mudflap_threads ? mf_cache_mask_decl : mf_cache_mask_decl_l));\n+              flag_mudflap_threads ? mf_cache_mask_decl\n+\t       : mf_cache_mask_decl_l);\n   t = build4 (ARRAY_REF,\n               TREE_TYPE (TREE_TYPE (mf_cache_array_decl)),\n               mf_cache_array_decl, t, NULL_TREE, NULL_TREE);\n@@ -699,7 +707,8 @@ mf_decl_eligible_p (tree decl)\n           /* The decl must have its address taken.  In the case of\n              arrays, this flag is also set if the indexes are not\n              compile-time known valid constants.  */\n-          && TREE_ADDRESSABLE (decl)    /* XXX: not sufficient: return-by-value structs! */\n+\t  /* XXX: not sufficient: return-by-value structs! */\n+          && TREE_ADDRESSABLE (decl)\n           /* The type of the variable must be complete.  */\n           && COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (decl))\n \t  /* The decl hasn't been decomposed somehow.  */\n@@ -758,7 +767,8 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n         while (1)\n           {\n \t    if (bitfield_ref_p && elt == NULL_TREE\n-\t\t&& (TREE_CODE (var) == ARRAY_REF || TREE_CODE (var) == COMPONENT_REF))\n+\t\t&& (TREE_CODE (var) == ARRAY_REF\n+\t\t    || TREE_CODE (var) == COMPONENT_REF))\n \t      elt = var;\n \t\n             if (TREE_CODE (var) == ARRAY_REF)\n@@ -787,7 +797,8 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n                   return;\n                 else\n \t\t  {\n-\t\t    base = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (var)), var);\n+\t\t    base = build1 (ADDR_EXPR,\n+\t\t\t\t   build_pointer_type (TREE_TYPE (var)), var);\n \t\t    break;\n \t\t  }\n               }\n@@ -810,7 +821,8 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n               size = DECL_SIZE_UNIT (field);\n             \n \t    if (elt)\n-\t      elt = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (elt)), elt);\n+\t      elt = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (elt)),\n+\t\t\t    elt);\n             addr = fold_convert (ptr_type_node, elt ? elt : base);\n             addr = fold_build2 (PLUS_EXPR, ptr_type_node,\n \t\t\t\taddr, fold_convert (ptr_type_node,\n@@ -1031,7 +1043,8 @@ mx_register_decls (tree decl, tree *stmt_list)\n \t\t     IDENTIFIER_POINTER (DECL_NAME (decl)));\n \t  else\n \t    {\n-\t      tsi_link_before (&initially_stmts, register_fncall, TSI_SAME_STMT);\n+\t      tsi_link_before (&initially_stmts, register_fncall,\n+\t\t\t       TSI_SAME_STMT);\n \n \t      /* Accumulate the FINALLY piece.  */\n \t      append_to_statement_list (unregister_fncall, &finally_stmts);\n@@ -1117,7 +1130,8 @@ mf_mark (tree t)\n   void **slot;\n \n   if (marked_trees == NULL)\n-    marked_trees = htab_create_ggc (31, htab_hash_pointer, htab_eq_pointer, NULL);\n+    marked_trees = htab_create_ggc (31, htab_hash_pointer, htab_eq_pointer,\n+\t\t\t\t    NULL);\n \n   slot = htab_find_slot (marked_trees, t, INSERT);\n   *slot = t;"}]}