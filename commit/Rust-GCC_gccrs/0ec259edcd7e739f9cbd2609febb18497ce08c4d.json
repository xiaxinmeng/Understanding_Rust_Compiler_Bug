{"sha": "0ec259edcd7e739f9cbd2609febb18497ce08c4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVjMjU5ZWRjZDdlNzM5ZjljYmQyNjA5ZmViYjE4NDk3Y2UwOGM0ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-22T20:43:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-22T20:43:26Z"}, "message": "i386.md (pushsi, [...]): Disable.\n\n\t* i386.md (pushsi, pushsi2_prologue): Disable.\n\t(pushsi2_rex64): New.\n\t(movabs?i_1_rex64, movabs?i_2_rex64): New.\n\t(movqi_ext_1): Disable for 64bit.\n\t(movqi_ext_1_rex64): New.\n\t(pushdi2_rex64): New pattern, peep2s and splitter.\n\t(pushdi2_prologue_rex64): New pattern.\n\t(popdi1_epilogue_rex64, popdi1, movdi_xor_rex64, movdi_or_rex64):\n\tLikewise.\n\t(movdi splitters): Disable for 64bit.\n\t(movdi_1_rex64): New pattern, peep2s and splitters.\n\t(swapdi): New pattern.\n\t(pushsf): Disable for 64bit.\n\t(pushsf_rex64): New pattern and splitter.\n\t(pushdf_nointeger): Disable for 64bit.\n\t(pushdf_integer): Handle the 64bit case.\n\t(pushtf): Likewise; update splitters.\n\nFrom-SVN: r40758", "tree": {"sha": "ae238bd4ec97ef1a8044ee6461a4f67b80524d36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae238bd4ec97ef1a8044ee6461a4f67b80524d36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ec259edcd7e739f9cbd2609febb18497ce08c4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec259edcd7e739f9cbd2609febb18497ce08c4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ec259edcd7e739f9cbd2609febb18497ce08c4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec259edcd7e739f9cbd2609febb18497ce08c4d/comments", "author": null, "committer": null, "parents": [{"sha": "ee402fc993d675c1c5ba634df921223bb529df45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee402fc993d675c1c5ba634df921223bb529df45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee402fc993d675c1c5ba634df921223bb529df45"}], "stats": {"total": 495, "additions": 475, "deletions": 20}, "files": [{"sha": "ce95c886796d1ca4339e6eb4f57a879f4778ffed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ec259edcd7e739f9cbd2609febb18497ce08c4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ec259edcd7e739f9cbd2609febb18497ce08c4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ec259edcd7e739f9cbd2609febb18497ce08c4d", "patch": "@@ -1,3 +1,23 @@\n+Thu Mar 22 21:41:16 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (pushsi, pushsi2_prologue): Disable.\n+\t(pushsi2_rex64): New.\n+\t(movabs?i_1_rex64, movabs?i_2_rex64): New.\n+\t(movqi_ext_1): Disable for 64bit.\n+\t(movqi_ext_1_rex64): New.\n+\t(pushdi2_rex64): New pattern, peep2s and splitter.\n+\t(pushdi2_prologue_rex64): New pattern.\n+\t(popdi1_epilogue_rex64, popdi1, movdi_xor_rex64, movdi_or_rex64):\n+\tLikewise.\n+\t(movdi splitters): Disable for 64bit.\n+\t(movdi_1_rex64): New pattern, peep2s and splitters.\n+\t(swapdi): New pattern.\n+\t(pushsf): Disable for 64bit.\n+\t(pushsf_rex64): New pattern and splitter.\n+\t(pushdf_nointeger): Disable for 64bit.\n+\t(pushdf_integer): Handle the 64bit case.\n+\t(pushtf): Likewise; update splitters.\n+\n 2001-03-22  Richard Henderson  <rth@redhat.com>\n \n \t* mkconfig.sh: Include insn-flags.h."}, {"sha": "0a2600984c44b9b53766139a19b4963542b04ca0", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 455, "deletions": 20, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ec259edcd7e739f9cbd2609febb18497ce08c4d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ec259edcd7e739f9cbd2609febb18497ce08c4d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0ec259edcd7e739f9cbd2609febb18497ce08c4d", "patch": "@@ -1622,16 +1622,25 @@\n (define_insn \"*pushsi2\"\n   [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n \t(match_operand:SI 1 \"general_no_elim_operand\" \"ri*m\"))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"push{l}\\\\t%1\"\n   [(set_attr \"type\" \"push\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; For 64BIT abi we always round up to 8 bytes.\n+(define_insn \"*pushsi2_rex64\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=X\")\n+\t(match_operand:SI 1 \"nonmemory_no_elim_operand\" \"ri\"))]\n+  \"TARGET_64BIT\"\n+  \"push{q}\\\\t%q1\"\n+  [(set_attr \"type\" \"push\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*pushsi2_prologue\"\n   [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n \t(match_operand:SI 1 \"general_no_elim_operand\" \"ri*m\"))\n    (set (reg:SI 6) (reg:SI 6))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"push{l}\\\\t%1\"\n   [(set_attr \"type\" \"push\")\n    (set_attr \"mode\" \"SI\")])\n@@ -1715,6 +1724,38 @@\n    (set_attr \"modrm\" \"0,*,0,*,*,*\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; Stores and loads of ax to arbitary constant address.\n+;; We fake an second form of instruction to force reload to load address\n+;; into register when rax is not available\n+(define_insn \"*movabssi_1_rex64\"\n+  [(set (mem:SI (match_operand:DI 0 \"x86_64_movabs_operand\" \"i,r,r\"))\n+\t(match_operand:SI 1 \"nonmemory_operand\" \"a,er,i\"))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   movabs{l}\\\\t{%1, %P0|%P0, %1}\n+   mov{l}\\\\t{%1, %a0|%a0, %1}\n+   movabs{l}\\\\t{%1, %a0|%a0, %1}\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"modrm\" \"0,*,*\")\n+   (set_attr \"length_address\" \"8,0,0\")\n+   (set_attr \"length_immediate\" \"0,*,*\")\n+   (set_attr \"memory\" \"store\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*movabssi_2_rex64\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,r\")\n+        (mem:SI (match_operand:DI 1 \"x86_64_movabs_operand\" \"i,r\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   movabs{l}\\\\t{%P1, %0|%0, %P1}\n+   mov{l}\\\\t{%a1, %0|%0, %a1}\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"modrm\" \"0,*\")\n+   (set_attr \"length_address\" \"8,0\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"memory\" \"load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*swapsi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"+r\")\n \t(match_operand:SI 1 \"register_operand\" \"+r\"))\n@@ -1796,6 +1837,38 @@\n \t    (const_string \"HI\")))\n    (set_attr \"modrm\" \"0,*,*,0,*,*\")])\n \n+;; Stores and loads of ax to arbitary constant address.\n+;; We fake an second form of instruction to force reload to load address\n+;; into register when rax is not available\n+(define_insn \"*movabshi_1_rex64\"\n+  [(set (mem:HI (match_operand:DI 0 \"x86_64_movabs_operand\" \"i,r,r\"))\n+\t(match_operand:HI 1 \"nonmemory_operand\" \"a,er,i\"))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   movabs{w}\\\\t{%1, %P0|%P0, %1}\n+   mov{w}\\\\t{%1, %a0|%a0, %1}\n+   movabs{w}\\\\t{%1, %a0|%a0, %1}\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"modrm\" \"0,*,*\")\n+   (set_attr \"length_address\" \"8,0,0\")\n+   (set_attr \"length_immediate\" \"0,*,*\")\n+   (set_attr \"memory\" \"store\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"*movabshi_2_rex64\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a,r\")\n+        (mem:HI (match_operand:DI 1 \"x86_64_movabs_operand\" \"i,r\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   movabs{w}\\\\t{%P1, %0|%0, %P1}\n+   mov{w}\\\\t{%a1, %0|%0, %a1}\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"modrm\" \"0,*\")\n+   (set_attr \"length_address\" \"8,0\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"memory\" \"load\")\n+   (set_attr \"mode\" \"HI\")])\n+\n (define_insn \"*swaphi_1\"\n   [(set (match_operand:HI 0 \"register_operand\" \"+r\")\n \t(match_operand:HI 1 \"register_operand\" \"+r\"))\n@@ -2024,11 +2097,11 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*movqi_extv_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,?r\")\n-        (sign_extract:QI (match_operand:SI 1 \"register_operand\" \"q,q\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=Qm,?r\")\n+        (sign_extract:QI (match_operand:SI 1 \"ext_register_operand\" \"Q,Q\")\n                          (const_int 8)\n                          (const_int 8)))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n {\n   switch (get_attr_type (insn))\n@@ -2051,6 +2124,66 @@\n \t(const_string \"SI\")\n \t(const_string \"QI\")))])\n \n+(define_insn \"*movqi_extv_1_rex64\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=Q,?R\")\n+        (sign_extract:QI (match_operand:SI 1 \"ext_register_operand\" \"Q,Q\")\n+                         (const_int 8)\n+                         (const_int 8)))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_IMOVX:\n+      return \\\"movs{bl|x}\\\\t{%h1, %k0|%k0, %h1}\\\";\n+    default:\n+      return \\\"mov{b}\\\\t{%h1, %0|%0, %h1}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (and (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t\t(ior (not (match_operand:QI 0 \"q_regs_operand\" \"\"))\n+\t\t\t     (ne (symbol_ref \"TARGET_MOVX\")\n+\t\t\t\t (const_int 0))))\n+\t(const_string \"imovx\")\n+\t(const_string \"imov\")))\n+   (set (attr \"mode\")\n+     (if_then_else (eq_attr \"type\" \"imovx\")\n+\t(const_string \"SI\")\n+\t(const_string \"QI\")))])\n+\n+;; Stores and loads of ax to arbitary constant address.\n+;; We fake an second form of instruction to force reload to load address\n+;; into register when rax is not available\n+(define_insn \"*movabsqi_1_rex64\"\n+  [(set (mem:QI (match_operand:DI 0 \"x86_64_movabs_operand\" \"i,r,r\"))\n+\t(match_operand:QI 1 \"nonmemory_operand\" \"a,er,i\"))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   movabs{q}\\\\t{%1, %P0|%P0, %1}\n+   mov{q}\\\\t{%1, %a0|%a0, %1}\n+   movabs{q}\\\\t{%1, %a0|%a0, %1}\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"modrm\" \"0,*,*\")\n+   (set_attr \"length_address\" \"8,0,0\")\n+   (set_attr \"length_immediate\" \"0,*,*\")\n+   (set_attr \"memory\" \"store\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*movabsqi_2_rex64\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=a,r\")\n+        (mem:QI (match_operand:DI 1 \"x86_64_movabs_operand\" \"i,r\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   movabs{q}\\\\t{%P1, %0|%0, %P1}\n+   mov{q}\\\\t{%a1, %0|%0, %a1}\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"modrm\" \"0,*\")\n+   (set_attr \"length_address\" \"8,0\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"memory\" \"load\")\n+   (set_attr \"mode\" \"QI\")])\n+\n (define_insn \"*movsi_extzv_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=R\")\n \t(zero_extract:SI (match_operand 1 \"ext_register_operand\" \"Q\")\n@@ -2160,6 +2293,117 @@\n   \"!TARGET_64BIT\"\n   \"#\")\n \n+(define_insn \"pushdi2_rex64\"\n+  [(set (match_operand:DI 0 \"push_operand\" \"=<,!<\")\n+\t(match_operand:DI 1 \"general_no_elim_operand\" \"re*m,n\"))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   push{q}\\\\t%1\n+   #\"\n+  [(set_attr \"type\" \"push,multi\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+;; Convert impossible pushes of immediate to existing instructions.\n+;; First try to get scratch register and go trought it.  In case this\n+;; fails, push sign extended lower part first and then overwrite\n+;; upper part by 32bit move.\n+(define_peephole2\n+  [(match_scratch:DI 2 \"r\")\n+   (set (match_operand:DI 0 \"push_operand\" \"\")\n+        (match_operand:DI 1 \"immediate_operand\" \"\"))]\n+  \"TARGET_64BIT && !symbolic_operand (operands[1], DImode)\n+   && !x86_64_immediate_operand (operands[1], DImode)\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (match_dup 2))]\n+  \"\")\n+\n+;; We need to define this as both peepholer and splitter for case\n+;; peephole2 pass is not run.\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"push_operand\" \"\")\n+        (match_operand:DI 1 \"immediate_operand\" \"\"))]\n+  \"TARGET_64BIT && !symbolic_operand (operands[1], DImode)\n+   && !x86_64_immediate_operand (operands[1], DImode) && 1\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2) (match_dup 3))]\n+  \"split_di (operands + 1, 1, operands + 2, operands + 3);\n+   operands[1] = gen_lowpart (DImode, operands[2]);\n+   operands[2] = gen_rtx_MEM (SImode, gen_rtx_PLUS (DImode, stack_pointer_rtx,\n+\t\t\t\t\t\t    GEN_INT (4)));\n+  \")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"push_operand\" \"\")\n+        (match_operand:DI 1 \"immediate_operand\" \"\"))]\n+  \"TARGET_64BIT && (flow2_completed || (reload_completed && !flag_peephole2))\n+   && !symbolic_operand (operands[1], DImode)\n+   && !x86_64_immediate_operand (operands[1], DImode)\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2) (match_dup 3))]\n+  \"split_di (operands + 1, 1, operands + 2, operands + 3);\n+   operands[1] = gen_lowpart (DImode, operands[2]);\n+   operands[2] = gen_rtx_MEM (SImode, gen_rtx_PLUS (DImode, stack_pointer_rtx,\n+\t\t\t\t\t\t    GEN_INT (4)));\n+  \")\n+\n+(define_insn \"*pushdi2_prologue_rex64\"\n+  [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n+\t(match_operand:DI 1 \"general_no_elim_operand\" \"re*m\"))\n+   (set (reg:DI 6) (reg:DI 6))]\n+  \"TARGET_64BIT\"\n+  \"push{q}\\\\t%1\"\n+  [(set_attr \"type\" \"push\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*popdi1_epilogue_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r*m\")\n+\t(mem:DI (reg:DI 7)))\n+   (set (reg:DI 7)\n+\t(plus:DI (reg:DI 7) (const_int 8)))\n+   (set (reg:DI 6) (reg:DI 6))]\n+  \"TARGET_64BIT\"\n+  \"pop{q}\\\\t%0\"\n+  [(set_attr \"type\" \"pop\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"popdi1\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r*m\")\n+\t(mem:DI (reg:DI 7)))\n+   (set (reg:DI 7)\n+\t(plus:DI (reg:DI 7) (const_int 8)))]\n+  \"TARGET_64BIT\"\n+  \"pop{q}\\\\t%0\"\n+  [(set_attr \"type\" \"pop\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*movdi_xor_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"const0_operand\" \"i\"))\n+   (clobber (reg:CC 17))]\n+  \"reload_completed && (!TARGET_USE_MOV0 || optimize_size)\n+   && TARGET_64BIT\"\n+  \"xor{l}\\\\t{%k0, %k0|%k0, %k0}\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"length_immediate\" \"0\")])\n+\n+(define_insn \"*movdi_or_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"const_int_operand\" \"i\"))\n+   (clobber (reg:CC 17))]\n+  \"reload_completed && GET_CODE (operands[1]) == CONST_INT\n+   && TARGET_64BIT\n+   && INTVAL (operands[1]) == -1\n+   && (TARGET_PENTIUM || optimize_size)\"\n+  \"*\n+{\n+  operands[1] = constm1_rtx;\n+  return \\\"or{q}\\\\t{%1, %0|%0, %1}\\\";\n+}\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"length_immediate\" \"1\")])\n+\n (define_insn \"*movdi_2\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,!m*y,!*y\")\n \t(match_operand:DI 1 \"general_operand\" \"riFo,riF,*y,m\"))]\n@@ -2175,18 +2419,143 @@\n (define_split\n   [(set (match_operand:DI 0 \"push_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"reload_completed && ! MMX_REG_P (operands[1]) && !TARGET_64BIT\"\n+  \"!TARGET_64BIT && reload_completed && ! MMX_REG_P (operands[1])\"\n   [(const_int 0)]\n   \"if (!ix86_split_long_move (operands)) abort (); DONE;\")\n \n ;; %%% This multiword shite has got to go.\n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"reload_completed && ! MMX_REG_P (operands[0]) && ! MMX_REG_P (operands[1])\"\n+  \"!TARGET_64BIT && reload_completed && ! MMX_REG_P (operands[0])\n+   && ! MMX_REG_P (operands[1])\"\n   [(set (match_dup 2) (match_dup 5))\n    (set (match_dup 3) (match_dup 6))]\n   \"if (ix86_split_long_move (operands)) DONE;\")\n+\n+(define_insn \"*movdi_1_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,mr,!mr,!m*y,!*y,*m,*Y\")\n+\t(match_operand:DI 1 \"general_operand\" \"Z,rem,i,re,n,*y,m,*Y,*m\"))]\n+  \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+   && TARGET_64BIT\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_SSE:\n+    case TYPE_MMX:\n+      return \\\"movd\\\\t{%1, %0|%0, %1}\\\";\n+    case TYPE_MULTI:\n+      return \\\"#\\\";\n+    case TYPE_LEA:\n+      return \\\"lea{q}\\\\t{%a1, %0|%0, %a1}\\\";\n+    default:\n+      if (flag_pic && SYMBOLIC_CONST (operands[1]))\n+\tabort ();\n+      if (get_attr_mode (insn) == MODE_SI)\n+\treturn \\\"mov{l}\\\\t{%k1, %k0|%k0, %k1}\\\";\n+      else if (which_alternative == 2)\n+\treturn \\\"movabs{q}\\\\t{%1, %0|%0, %1}\\\";\n+      else\n+\treturn \\\"mov{q}\\\\t{%1, %0|%0, %1}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (cond [(eq_attr \"alternative\" \"5,6\")\n+\t      (const_string \"mmx\")\n+\t    (eq_attr \"alternative\" \"7,8\")\n+\t      (const_string \"sse\")\n+\t    (eq_attr \"alternative\" \"4\")\n+\t      (const_string \"multi\")\n+ \t    (and (ne (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t (match_operand:DI 1 \"symbolic_operand\" \"\"))\n+\t      (const_string \"lea\")\n+\t   ]\n+\t   (const_string \"imov\")))\n+   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*\")\n+   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*\")\n+   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,DI\")])\n+\n+;; Stores and loads of ax to arbitary constant address.\n+;; We fake an second form of instruction to force reload to load address\n+;; into register when rax is not available\n+(define_insn \"*movabsdi_1_rex64\"\n+  [(set (mem:DI (match_operand:DI 0 \"x86_64_movabs_operand\" \"i,r,r\"))\n+\t(match_operand:DI 1 \"nonmemory_operand\" \"a,er,i\"))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   movabs{q}\\\\t{%1, %P0|%P0, %1}\n+   mov{q}\\\\t{%1, %a0|%a0, %1}\n+   movabs{q}\\\\t{%1, %a0|%a0, %1}\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"modrm\" \"0,*,*\")\n+   (set_attr \"length_address\" \"8,0,0\")\n+   (set_attr \"length_immediate\" \"0,*,*\")\n+   (set_attr \"memory\" \"store\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*movabsdi_2_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a,r\")\n+        (mem:DI (match_operand:DI 1 \"x86_64_movabs_operand\" \"i,r\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   movabs{q}\\\\t{%P1, %0|%0, %P1}\n+   mov{q}\\\\t{%a1, %0|%0, %a1}\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"modrm\" \"0,*\")\n+   (set_attr \"length_address\" \"8,0\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"memory\" \"load\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+;; Convert impossible stores of immediate to existing instructions.\n+;; First try to get scratch register and go trought it.  In case this\n+;; fails, move by 32bit parts.\n+(define_peephole2\n+  [(match_scratch:DI 2 \"r\")\n+   (set (match_operand:DI 0 \"memory_operand\" \"\")\n+        (match_operand:DI 1 \"immediate_operand\" \"\"))]\n+  \"TARGET_64BIT && !symbolic_operand (operands[1], DImode)\n+   && !x86_64_immediate_operand (operands[1], DImode)\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (match_dup 2))]\n+  \"\")\n+\n+;; We need to define this as both peepholer and splitter for case\n+;; peephole2 pass is not run.\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"memory_operand\" \"\")\n+        (match_operand:DI 1 \"immediate_operand\" \"\"))]\n+  \"TARGET_64BIT && !symbolic_operand (operands[1], DImode)\n+   && !x86_64_immediate_operand (operands[1], DImode) && 1\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"split_di (operands, 2, operands + 2, operands + 4);\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"memory_operand\" \"\")\n+        (match_operand:DI 1 \"immediate_operand\" \"\"))]\n+  \"TARGET_64BIT && (flow2_completed || (reload_completed && !flag_peephole2))\n+   && !symbolic_operand (operands[1], DImode)\n+   && !x86_64_immediate_operand (operands[1], DImode)\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"split_di (operands, 2, operands + 2, operands + 4);\")\n+\n+(define_insn \"*swapdi_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+r\")\n+\t(match_operand:DI 1 \"register_operand\" \"+r\"))\n+   (set (match_dup 1)\n+\t(match_dup 0))]\n+  \"TARGET_64BIT\"\n+  \"xchg{q}\\\\t%1, %0\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"pent_pair\" \"np\")\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"modrm\" \"0\")\n+   (set_attr \"ppro_uops\" \"few\")])\n+\n   \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n@@ -2197,7 +2566,7 @@\n (define_insn \"*pushsf\"\n   [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<\")\n \t(match_operand:SF 1 \"general_no_elim_operand\" \"f#rx,rFm#fx,x#rf\"))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n {\n   switch (which_alternative)\n@@ -2224,6 +2593,37 @@\n   [(set_attr \"type\" \"multi,push,multi\")\n    (set_attr \"mode\" \"SF,SI,SF\")])\n \n+(define_insn \"*pushsf_rex64\"\n+  [(set (match_operand:SF 0 \"push_operand\" \"=X,X,X\")\n+\t(match_operand:SF 1 \"nonmemory_no_elim_operand\" \"f#rx,rF#fx,x#rf\"))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* %%% We loose REG_DEAD notes for controling pops if we split late.  */\n+      operands[0] = gen_rtx_MEM (SFmode, stack_pointer_rtx);\n+      operands[2] = stack_pointer_rtx;\n+      operands[3] = GEN_INT (8);\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\treturn \\\"sub{q}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+      else\n+\treturn \\\"sub{q}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n+\n+    case 1:\n+      return \\\"push{q}\\\\t%q1\\\";\n+\n+    case 2:\n+      return \\\"#\\\";\n+\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"multi,push,multi\")\n+   (set_attr \"mode\" \"SF,DI,SF\")])\n+\n (define_split\n   [(set (match_operand:SF 0 \"push_operand\" \"\")\n \t(match_operand:SF 1 \"memory_operand\" \"\"))]\n@@ -2240,10 +2640,17 @@\n (define_split\n   [(set (match_operand:SF 0 \"push_operand\" \"\")\n \t(match_operand:SF 1 \"register_operand\" \"\"))]\n-  \"ANY_FP_REGNO_P (REGNO (operands[1]))\"\n+  \"!TARGET_64BIT && ANY_FP_REGNO_P (REGNO (operands[1]))\"\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -4)))\n    (set (mem:SF (reg:SI 7)) (match_dup 1))])\n \n+(define_split\n+  [(set (match_operand:SF 0 \"push_operand\" \"\")\n+\t(match_operand:SF 1 \"register_operand\" \"\"))]\n+  \"TARGET_64BIT && ANY_FP_REGNO_P (REGNO (operands[1]))\"\n+  [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int -8)))\n+   (set (mem:SF (reg:DI 7)) (match_dup 1))])\n+\n (define_insn \"*movsf_1\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f#xr,m,f#xr,r#xf,m,x#rf,x#rf,x#rf,m\")\n \t(match_operand:SF 1 \"general_operand\" \"fm#rx,f#rx,G,rmF#fx,Fr#fx,H,x,xm#rf,x#rf\"))]\n@@ -2331,7 +2738,7 @@\n (define_insn \"*pushdf_nointeger\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<,<\")\n \t(match_operand:DF 1 \"general_no_elim_operand\" \"f#Y,Fo#fY,*r#fY,Y#f\"))]\n-  \"!TARGET_INTEGER_DFMODE_MOVES\"\n+  \"!TARGET_64BIT && !TARGET_INTEGER_DFMODE_MOVES\"\n   \"*\n {\n   switch (which_alternative)\n@@ -2361,7 +2768,7 @@\n (define_insn \"*pushdf_integer\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<\")\n \t(match_operand:DF 1 \"general_no_elim_operand\" \"f#rY,rFo#fY,Y#rf\"))]\n-  \"TARGET_INTEGER_DFMODE_MOVES\"\n+  \"TARGET_64BIT || TARGET_INTEGER_DFMODE_MOVES\"\n   \"*\n {\n   switch (which_alternative)\n@@ -2371,10 +2778,17 @@\n       operands[0] = gen_rtx_MEM (DFmode, stack_pointer_rtx);\n       operands[2] = stack_pointer_rtx;\n       operands[3] = GEN_INT (8);\n-      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n-\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+      if (TARGET_64BIT)\n+\tif (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\t  return \\\"sub{q}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+\telse\n+\t  return \\\"sub{q}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n       else\n-\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n+\tif (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\t  return \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+\telse\n+\t  return \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n+\n \n     case 1:\n     case 2:\n@@ -2391,11 +2805,19 @@\n (define_split\n   [(set (match_operand:DF 0 \"push_operand\" \"\")\n \t(match_operand:DF 1 \"register_operand\" \"\"))]\n-  \"reload_completed && ANY_FP_REGNO_P (REGNO (operands[1]))\"\n+  \"!TARGET_64BIT && reload_completed && ANY_FP_REGNO_P (REGNO (operands[1]))\"\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -8)))\n    (set (mem:DF (reg:SI 7)) (match_dup 1))]\n   \"\")\n \n+(define_split\n+  [(set (match_operand:DF 0 \"push_operand\" \"\")\n+\t(match_operand:DF 1 \"register_operand\" \"\"))]\n+  \"TARGET_64BIT && reload_completed && ANY_FP_REGNO_P (REGNO (operands[1]))\"\n+  [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int -8)))\n+   (set (mem:DF (reg:DI 7)) (match_dup 1))]\n+  \"\")\n+\n (define_split\n   [(set (match_operand:DF 0 \"push_operand\" \"\")\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n@@ -2673,10 +3095,16 @@\n       operands[0] = gen_rtx_MEM (XFmode, stack_pointer_rtx);\n       operands[2] = stack_pointer_rtx;\n       operands[3] = GEN_INT (16);\n-      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n-\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+      if (TARGET_64BIT)\n+\tif (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\t  return \\\"sub{q}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+\telse\n+\t  return \\\"sub{q}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n       else\n-\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n+\tif (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\t  return \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+\telse\n+\t  return \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n \n     case 1:\n       return \\\"#\\\";\n@@ -2702,17 +3130,24 @@\n (define_split\n   [(set (match_operand:XF 0 \"push_operand\" \"\")\n \t(match_operand:XF 1 \"register_operand\" \"\"))]\n-  \"ANY_FP_REGNO_P (REGNO (operands[1]))\"\n+  \"!TARGET_64BIT && ANY_FP_REGNO_P (REGNO (operands[1]))\"\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -12)))\n    (set (mem:XF (reg:SI 7)) (match_dup 1))])\n \n (define_split\n   [(set (match_operand:TF 0 \"push_operand\" \"\")\n \t(match_operand:TF 1 \"register_operand\" \"\"))]\n-  \"ANY_FP_REGNO_P (REGNO (operands[1]))\"\n+  \"!TARGET_64BIT && ANY_FP_REGNO_P (REGNO (operands[1]))\"\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -16)))\n    (set (mem:TF (reg:SI 7)) (match_dup 1))])\n \n+(define_split\n+  [(set (match_operand:TF 0 \"push_operand\" \"\")\n+\t(match_operand:TF 1 \"register_operand\" \"\"))]\n+  \"TARGET_64BIT && ANY_FP_REGNO_P (REGNO (operands[1]))\"\n+  [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int -16)))\n+   (set (mem:TF (reg:DI 7)) (match_dup 1))])\n+\n ;; Do not use integer registers when optimizing for size\n (define_insn \"*movxf_nointeger\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")"}]}