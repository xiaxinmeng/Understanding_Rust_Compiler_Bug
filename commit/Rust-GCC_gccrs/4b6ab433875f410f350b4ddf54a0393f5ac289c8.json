{"sha": "4b6ab433875f410f350b4ddf54a0393f5ac289c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI2YWI0MzM4NzVmNDEwZjM1MGI0ZGRmNTRhMDM5M2Y1YWMyODljOA==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2016-11-02T03:45:45Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2016-11-02T03:45:45Z"}, "message": "split up some variables to use rtx_insn * more\n\ngcc/ChangeLog:\n\n2016-11-01  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* config/alpha/alpha.c (alpha_legitimize_address_1): Split up\n\tvariables so some can be rtx_insn *.\n\t(alpha_emit_xfloating_libcall): Likewise.\n\t* config/mips/mips.c (mips_call_tls_get_addr): Likewise.\n\t(mips_legitimize_tls_address): Likewise.\n\t* optabs.c (expand_binop): Likewise.\n\t* reload1.c (gen_reload): Likewise.\n\nFrom-SVN: r241770", "tree": {"sha": "819905075f69a65778543aa96f4a2de290f45895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/819905075f69a65778543aa96f4a2de290f45895"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b6ab433875f410f350b4ddf54a0393f5ac289c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6ab433875f410f350b4ddf54a0393f5ac289c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b6ab433875f410f350b4ddf54a0393f5ac289c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6ab433875f410f350b4ddf54a0393f5ac289c8/comments", "author": null, "committer": null, "parents": [{"sha": "88f9bb4dcba670c721b82628e51fd263779566ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f9bb4dcba670c721b82628e51fd263779566ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88f9bb4dcba670c721b82628e51fd263779566ae"}], "stats": {"total": 202, "additions": 111, "deletions": 91}, "files": [{"sha": "9728d9d1d5960a095ae1f64820adb607cd3d02b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6ab433875f410f350b4ddf54a0393f5ac289c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6ab433875f410f350b4ddf54a0393f5ac289c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b6ab433875f410f350b4ddf54a0393f5ac289c8", "patch": "@@ -1,3 +1,13 @@\n+2016-11-01  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* config/alpha/alpha.c (alpha_legitimize_address_1): Split up\n+\tvariables so some can be rtx_insn *.\n+\t(alpha_emit_xfloating_libcall): Likewise.\n+\t* config/mips/mips.c (mips_call_tls_get_addr): Likewise.\n+\t(mips_legitimize_tls_address): Likewise.\n+\t* optabs.c (expand_binop): Likewise.\n+\t* reload1.c (gen_reload): Likewise.\n+\n 2016-11-01  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* reorg.c (relax_delay_slots): Split up the trial variable."}, {"sha": "6d390ae6dfa67e5bddc0f685ab212c7b676e042a", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6ab433875f410f350b4ddf54a0393f5ac289c8/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6ab433875f410f350b4ddf54a0393f5ac289c8/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=4b6ab433875f410f350b4ddf54a0393f5ac289c8", "patch": "@@ -1017,74 +1017,79 @@ alpha_legitimize_address_1 (rtx x, rtx scratch, machine_mode mode)\n       && GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n       && symbolic_operand (x, Pmode))\n     {\n-      rtx r0, r16, eqv, tga, tp, insn, dest, seq;\n+      rtx r0, r16, eqv, tga, tp, dest, seq;\n+      rtx_insn *insn;\n \n       switch (tls_symbolic_operand_type (x))\n \t{\n \tcase TLS_MODEL_NONE:\n \t  break;\n \n \tcase TLS_MODEL_GLOBAL_DYNAMIC:\n-\t  start_sequence ();\n+\t  {\n+\t    start_sequence ();\n \n-\t  r0 = gen_rtx_REG (Pmode, 0);\n-\t  r16 = gen_rtx_REG (Pmode, 16);\n-\t  tga = get_tls_get_addr ();\n-\t  dest = gen_reg_rtx (Pmode);\n-\t  seq = GEN_INT (alpha_next_sequence_number++);\n+\t    r0 = gen_rtx_REG (Pmode, 0);\n+\t    r16 = gen_rtx_REG (Pmode, 16);\n+\t    tga = get_tls_get_addr ();\n+\t    dest = gen_reg_rtx (Pmode);\n+\t    seq = GEN_INT (alpha_next_sequence_number++);\n \n-\t  emit_insn (gen_movdi_er_tlsgd (r16, pic_offset_table_rtx, x, seq));\n-\t  insn = gen_call_value_osf_tlsgd (r0, tga, seq);\n-\t  insn = emit_call_insn (insn);\n-\t  RTL_CONST_CALL_P (insn) = 1;\n-\t  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r16);\n+\t    emit_insn (gen_movdi_er_tlsgd (r16, pic_offset_table_rtx, x, seq));\n+\t    rtx val = gen_call_value_osf_tlsgd (r0, tga, seq);\n+\t    insn = emit_call_insn (val);\n+\t    RTL_CONST_CALL_P (insn) = 1;\n+\t    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r16);\n \n-          insn = get_insns ();\n-\t  end_sequence ();\n+\t    insn = get_insns ();\n+\t    end_sequence ();\n \n-\t  emit_libcall_block (insn, dest, r0, x);\n-\t  return dest;\n+\t    emit_libcall_block (insn, dest, r0, x);\n+\t    return dest;\n+\t  }\n \n \tcase TLS_MODEL_LOCAL_DYNAMIC:\n-\t  start_sequence ();\n+\t  {\n+\t    start_sequence ();\n \n-\t  r0 = gen_rtx_REG (Pmode, 0);\n-\t  r16 = gen_rtx_REG (Pmode, 16);\n-\t  tga = get_tls_get_addr ();\n-\t  scratch = gen_reg_rtx (Pmode);\n-\t  seq = GEN_INT (alpha_next_sequence_number++);\n+\t    r0 = gen_rtx_REG (Pmode, 0);\n+\t    r16 = gen_rtx_REG (Pmode, 16);\n+\t    tga = get_tls_get_addr ();\n+\t    scratch = gen_reg_rtx (Pmode);\n+\t    seq = GEN_INT (alpha_next_sequence_number++);\n \n-\t  emit_insn (gen_movdi_er_tlsldm (r16, pic_offset_table_rtx, seq));\n-\t  insn = gen_call_value_osf_tlsldm (r0, tga, seq);\n-\t  insn = emit_call_insn (insn);\n-\t  RTL_CONST_CALL_P (insn) = 1;\n-\t  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r16);\n+\t    emit_insn (gen_movdi_er_tlsldm (r16, pic_offset_table_rtx, seq));\n+\t    rtx val = gen_call_value_osf_tlsldm (r0, tga, seq);\n+\t    insn = emit_call_insn (val);\n+\t    RTL_CONST_CALL_P (insn) = 1;\n+\t    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r16);\n \n-          insn = get_insns ();\n-\t  end_sequence ();\n+\t    insn = get_insns ();\n+\t    end_sequence ();\n \n-\t  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n-\t\t\t\tUNSPEC_TLSLDM_CALL);\n-\t  emit_libcall_block (insn, scratch, r0, eqv);\n+\t    eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t\t  UNSPEC_TLSLDM_CALL);\n+\t    emit_libcall_block (insn, scratch, r0, eqv);\n \n-\t  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_DTPREL);\n-\t  eqv = gen_rtx_CONST (Pmode, eqv);\n+\t    eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_DTPREL);\n+\t    eqv = gen_rtx_CONST (Pmode, eqv);\n \n-\t  if (alpha_tls_size == 64)\n-\t    {\n-\t      dest = gen_reg_rtx (Pmode);\n-\t      emit_insn (gen_rtx_SET (dest, eqv));\n-\t      emit_insn (gen_adddi3 (dest, dest, scratch));\n-\t      return dest;\n-\t    }\n-\t  if (alpha_tls_size == 32)\n-\t    {\n-\t      insn = gen_rtx_HIGH (Pmode, eqv);\n-\t      insn = gen_rtx_PLUS (Pmode, scratch, insn);\n-\t      scratch = gen_reg_rtx (Pmode);\n-\t      emit_insn (gen_rtx_SET (scratch, insn));\n-\t    }\n-\t  return gen_rtx_LO_SUM (Pmode, scratch, eqv);\n+\t    if (alpha_tls_size == 64)\n+\t      {\n+\t\tdest = gen_reg_rtx (Pmode);\n+\t\temit_insn (gen_rtx_SET (dest, eqv));\n+\t\temit_insn (gen_adddi3 (dest, dest, scratch));\n+\t\treturn dest;\n+\t      }\n+\t    if (alpha_tls_size == 32)\n+\t      {\n+\t\trtx temp = gen_rtx_HIGH (Pmode, eqv);\n+\t\ttemp = gen_rtx_PLUS (Pmode, scratch, temp);\n+\t\tscratch = gen_reg_rtx (Pmode);\n+\t\temit_insn (gen_rtx_SET (scratch, temp));\n+\t      }\n+\t    return gen_rtx_LO_SUM (Pmode, scratch, eqv);\n+\t  }\n \n \tcase TLS_MODEL_INITIAL_EXEC:\n \t  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_TPREL);\n@@ -1106,10 +1111,10 @@ alpha_legitimize_address_1 (rtx x, rtx scratch, machine_mode mode)\n \t  emit_insn (gen_get_thread_pointerdi (tp));\n \t  if (alpha_tls_size == 32)\n \t    {\n-\t      insn = gen_rtx_HIGH (Pmode, eqv);\n-\t      insn = gen_rtx_PLUS (Pmode, tp, insn);\n+\t      rtx temp = gen_rtx_HIGH (Pmode, eqv);\n+\t      temp = gen_rtx_PLUS (Pmode, tp, temp);\n \t      tp = gen_reg_rtx (Pmode);\n-\t      emit_insn (gen_rtx_SET (tp, insn));\n+\t      emit_insn (gen_rtx_SET (tp, temp));\n \t    }\n \t  return gen_rtx_LO_SUM (Pmode, tp, eqv);\n \n@@ -3059,7 +3064,7 @@ static void\n alpha_emit_xfloating_libcall (rtx func, rtx target, rtx operands[],\n \t\t\t      int noperands, rtx equiv)\n {\n-  rtx usage = NULL_RTX, tmp, reg;\n+  rtx usage = NULL_RTX, reg;\n   int regno = 16, i;\n \n   start_sequence ();\n@@ -3109,9 +3114,9 @@ alpha_emit_xfloating_libcall (rtx func, rtx target, rtx operands[],\n       gcc_unreachable ();\n     }\n \n-  tmp = gen_rtx_MEM (QImode, func);\n-  tmp = emit_call_insn (gen_call_value (reg, tmp, const0_rtx,\n-\t\t\t\t\tconst0_rtx, const0_rtx));\n+  rtx mem = gen_rtx_MEM (QImode, func);\n+  rtx_insn *tmp = emit_call_insn (gen_call_value (reg, mem, const0_rtx,\n+\t\t\t\t\t\t  const0_rtx, const0_rtx));\n   CALL_INSN_FUNCTION_USAGE (tmp) = usage;\n   RTL_CONST_CALL_P (tmp) = 1;\n "}, {"sha": "552b73adaf740cc98c52cea45822a287f280266e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6ab433875f410f350b4ddf54a0393f5ac289c8/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6ab433875f410f350b4ddf54a0393f5ac289c8/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=4b6ab433875f410f350b4ddf54a0393f5ac289c8", "patch": "@@ -3396,10 +3396,11 @@ static GTY(()) rtx mips_tls_symbol;\n    (either global dynamic or local dynamic).  V0 is an RTX for the\n    return value location.  */\n \n-static rtx\n+static rtx_insn *\n mips_call_tls_get_addr (rtx sym, enum mips_symbol_type type, rtx v0)\n {\n-  rtx insn, loc, a0;\n+  rtx loc, a0;\n+  rtx_insn *insn;\n \n   a0 = gen_rtx_REG (Pmode, GP_ARG_FIRST);\n \n@@ -3455,7 +3456,7 @@ mips_get_tp (void)\n static rtx\n mips_legitimize_tls_address (rtx loc)\n {\n-  rtx dest, insn, v0, tp, tmp1, tmp2, eqv, offset;\n+  rtx dest, v0, tp, tmp1, tmp2, eqv, offset;\n   enum tls_model model;\n \n   model = SYMBOL_REF_TLS_MODEL (loc);\n@@ -3468,33 +3469,37 @@ mips_legitimize_tls_address (rtx loc)\n   switch (model)\n     {\n     case TLS_MODEL_GLOBAL_DYNAMIC:\n-      v0 = gen_rtx_REG (Pmode, GP_RETURN);\n-      insn = mips_call_tls_get_addr (loc, SYMBOL_TLSGD, v0);\n-      dest = gen_reg_rtx (Pmode);\n-      emit_libcall_block (insn, dest, v0, loc);\n-      break;\n+      {\n+\tv0 = gen_rtx_REG (Pmode, GP_RETURN);\n+\trtx_insn *insn = mips_call_tls_get_addr (loc, SYMBOL_TLSGD, v0);\n+\tdest = gen_reg_rtx (Pmode);\n+\temit_libcall_block (insn, dest, v0, loc);\n+\tbreak;\n+      }\n \n     case TLS_MODEL_LOCAL_DYNAMIC:\n-      v0 = gen_rtx_REG (Pmode, GP_RETURN);\n-      insn = mips_call_tls_get_addr (loc, SYMBOL_TLSLDM, v0);\n-      tmp1 = gen_reg_rtx (Pmode);\n-\n-      /* Attach a unique REG_EQUIV, to allow the RTL optimizers to\n-\t share the LDM result with other LD model accesses.  */\n-      eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n-\t\t\t    UNSPEC_TLS_LDM);\n-      emit_libcall_block (insn, tmp1, v0, eqv);\n-\n-      offset = mips_unspec_address (loc, SYMBOL_DTPREL);\n-      if (mips_split_p[SYMBOL_DTPREL])\n-\t{\n-\t  tmp2 = mips_unspec_offset_high (NULL, tmp1, loc, SYMBOL_DTPREL);\n-\t  dest = gen_rtx_LO_SUM (Pmode, tmp2, offset);\n-\t}\n-      else\n-\tdest = expand_binop (Pmode, add_optab, tmp1, offset,\n-\t\t\t     0, 0, OPTAB_DIRECT);\n-      break;\n+      {\n+\tv0 = gen_rtx_REG (Pmode, GP_RETURN);\n+\trtx_insn *insn = mips_call_tls_get_addr (loc, SYMBOL_TLSLDM, v0);\n+\ttmp1 = gen_reg_rtx (Pmode);\n+\n+\t/* Attach a unique REG_EQUIV, to allow the RTL optimizers to\n+\t   share the LDM result with other LD model accesses.  */\n+\teqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t      UNSPEC_TLS_LDM);\n+\temit_libcall_block (insn, tmp1, v0, eqv);\n+\n+\toffset = mips_unspec_address (loc, SYMBOL_DTPREL);\n+\tif (mips_split_p[SYMBOL_DTPREL])\n+\t  {\n+\t    tmp2 = mips_unspec_offset_high (NULL, tmp1, loc, SYMBOL_DTPREL);\n+\t    dest = gen_rtx_LO_SUM (Pmode, tmp2, offset);\n+\t  }\n+\telse\n+\t  dest = expand_binop (Pmode, add_optab, tmp1, offset,\n+\t\t\t       0, 0, OPTAB_DIRECT);\n+\tbreak;\n+      }\n \n     case TLS_MODEL_INITIAL_EXEC:\n       tp = mips_get_tp ();"}, {"sha": "7a1f02533bcc8a083742008aaaaa9cd3f623ea86", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6ab433875f410f350b4ddf54a0393f5ac289c8/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6ab433875f410f350b4ddf54a0393f5ac289c8/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=4b6ab433875f410f350b4ddf54a0393f5ac289c8", "patch": "@@ -1712,8 +1712,9 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t{\n \t  if (optab_handler (mov_optab, mode) != CODE_FOR_nothing)\n \t    {\n-\t      temp = emit_move_insn (target ? target : product, product);\n-\t      set_dst_reg_note (temp,\n+\t      rtx_insn *move = emit_move_insn (target ? target : product,\n+\t\t\t\t\t       product);\n+\t      set_dst_reg_note (move,\n \t\t\t\tREG_EQUAL,\n \t\t\t\tgen_rtx_fmt_ee (MULT, mode,\n \t\t\t\t\t\tcopy_rtx (op0),"}, {"sha": "876f7eff6b60a2eebf085e443efcc63a1df1089c", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6ab433875f410f350b4ddf54a0393f5ac289c8/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6ab433875f410f350b4ddf54a0393f5ac289c8/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=4b6ab433875f410f350b4ddf54a0393f5ac289c8", "patch": "@@ -8703,7 +8703,6 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n #endif\n   else if (REG_P (out) && UNARY_P (in))\n     {\n-      rtx insn;\n       rtx op1;\n       rtx out_moded;\n       rtx_insn *set;\n@@ -8728,13 +8727,13 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n \n       gen_reload (out_moded, op1, opnum, type);\n \n-      insn = gen_rtx_SET (out, gen_rtx_fmt_e (GET_CODE (in), GET_MODE (in),\n-\t\t\t\t\t      out_moded));\n-      insn = emit_insn_if_valid_for_reload (insn);\n+      rtx temp = gen_rtx_SET (out, gen_rtx_fmt_e (GET_CODE (in), GET_MODE (in),\n+\t\t\t\t\t\t  out_moded));\n+      rtx_insn *insn = emit_insn_if_valid_for_reload (temp);\n       if (insn)\n \t{\n \t  set_unique_reg_note (insn, REG_EQUIV, in);\n-\t  return as_a <rtx_insn *> (insn);\n+\t  return insn;\n \t}\n \n       fatal_insn (\"failure trying to reload:\", set);"}]}