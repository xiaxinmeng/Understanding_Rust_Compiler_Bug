{"sha": "aefae0f13c8622a095ae966de321566d529bbd70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVmYWUwZjEzYzg2MjJhMDk1YWU5NjZkZTMyMTU2NmQ1MjliYmQ3MA==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2016-07-14T16:41:06Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2016-07-14T16:41:06Z"}, "message": "re PR rtl-optimization/71878 (ICE in cselib_record_set)\n\n2016-07-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    PR rtl-optimization/71878\n    * lra-constraints.c (match_reload): Pass information about other\n    output operands.  Create new unique register value if matching input\n    operand shares same register value as output operand being considered.\n    (curr_insn_transform): Record output operands already processed.\n\nFrom-SVN: r238346", "tree": {"sha": "41a9b43f5af88ac0409db94bfd22aaa9c74e9c70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41a9b43f5af88ac0409db94bfd22aaa9c74e9c70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aefae0f13c8622a095ae966de321566d529bbd70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aefae0f13c8622a095ae966de321566d529bbd70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aefae0f13c8622a095ae966de321566d529bbd70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aefae0f13c8622a095ae966de321566d529bbd70/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ea5ec6b7e0f8b2e3cc4bce670651aedc33211a46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea5ec6b7e0f8b2e3cc4bce670651aedc33211a46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea5ec6b7e0f8b2e3cc4bce670651aedc33211a46"}], "stats": {"total": 69, "additions": 57, "deletions": 12}, "files": [{"sha": "3232bafa118d3140da2b26ad8f229229e5e1e3ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aefae0f13c8622a095ae966de321566d529bbd70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aefae0f13c8622a095ae966de321566d529bbd70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aefae0f13c8622a095ae966de321566d529bbd70", "patch": "@@ -1,3 +1,11 @@\n+2016-07-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR rtl-optimization/71878\n+\t* lra-constraints.c (match_reload): Pass information about other\n+\toutput operands.  Create new unique register value if matching input\n+\toperand shares same register value as output operand being considered.\n+\t(curr_insn_transform): Record output operands already processed.\n+\n 2016-07-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/65951"}, {"sha": "45b65069e68729e53af3181ceec60134c52f9437", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aefae0f13c8622a095ae966de321566d529bbd70/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aefae0f13c8622a095ae966de321566d529bbd70/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=aefae0f13c8622a095ae966de321566d529bbd70", "patch": "@@ -871,15 +871,18 @@ regno_val_use_in (unsigned int regno, rtx x)\n }\n \n /* Generate reloads for matching OUT and INS (array of input operand\n-   numbers with end marker -1) with reg class GOAL_CLASS.  Add input\n-   and output reloads correspondingly to the lists *BEFORE and *AFTER.\n-   OUT might be negative.  In this case we generate input reloads for\n-   matched input operands INS.  EARLY_CLOBBER_P is a flag that the\n-   output operand is early clobbered for chosen alternative.  */\n+   numbers with end marker -1) with reg class GOAL_CLASS, considering\n+   output operands OUTS (similar array to INS) needing to be in different\n+   registers.  Add input and output reloads correspondingly to the lists\n+   *BEFORE and *AFTER.  OUT might be negative.  In this case we generate\n+   input reloads for matched input operands INS.  EARLY_CLOBBER_P is a flag\n+   that the output operand is early clobbered for chosen alternative.  */\n static void\n-match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n-\t      rtx_insn **before, rtx_insn **after, bool early_clobber_p)\n+match_reload (signed char out, signed char *ins, signed char *outs,\n+\t      enum reg_class goal_class, rtx_insn **before,\n+\t      rtx_insn **after, bool early_clobber_p)\n {\n+  bool out_conflict;\n   int i, in;\n   rtx new_in_reg, new_out_reg, reg;\n   machine_mode inmode, outmode;\n@@ -968,12 +971,32 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t We don't care about eliminable hard regs here as we are\n \t interesting only in pseudos.  */\n \n+      /* Matching input's register value is the same as one of the other\n+\t output operand.  Output operands in a parallel insn must be in\n+\t different registers.  */\n+      out_conflict = false;\n+      if (REG_P (in_rtx))\n+\t{\n+\t  for (i = 0; outs[i] >= 0; i++)\n+\t    {\n+\t      rtx other_out_rtx = *curr_id->operand_loc[outs[i]];\n+\t      if (REG_P (other_out_rtx)\n+\t\t  && (regno_val_use_in (REGNO (in_rtx), other_out_rtx)\n+\t\t      != NULL_RTX))\n+\t\t{\n+\t\t  out_conflict = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n       new_in_reg = new_out_reg\n \t= (! early_clobber_p && ins[1] < 0 && REG_P (in_rtx)\n \t   && (int) REGNO (in_rtx) < lra_new_regno_start\n \t   && find_regno_note (curr_insn, REG_DEAD, REGNO (in_rtx))\n \t   && (out < 0\n \t       || regno_val_use_in (REGNO (in_rtx), out_rtx) == NULL_RTX)\n+\t   && !out_conflict\n \t   ? lra_create_new_reg (inmode, in_rtx, goal_class, \"\")\n \t   : lra_create_new_reg_with_unique_value (outmode, out_rtx,\n \t\t\t\t\t\t   goal_class, \"\"));\n@@ -3469,9 +3492,11 @@ curr_insn_transform (bool check_only_p)\n   int i, j, k;\n   int n_operands;\n   int n_alternatives;\n+  int n_outputs;\n   int commutative;\n   signed char goal_alt_matched[MAX_RECOG_OPERANDS][MAX_RECOG_OPERANDS];\n   signed char match_inputs[MAX_RECOG_OPERANDS + 1];\n+  signed char outputs[MAX_RECOG_OPERANDS + 1];\n   rtx_insn *before, *after;\n   bool alt_p = false;\n   /* Flag that the insn has been changed through a transformation.  */\n@@ -3881,6 +3906,8 @@ curr_insn_transform (bool check_only_p)\n \t  }\n       }\n \n+  n_outputs = 0;\n+  outputs[0] = -1;\n   for (i = 0; i < n_operands; i++)\n     {\n       int regno;\n@@ -4038,7 +4065,7 @@ curr_insn_transform (bool check_only_p)\n \t  /* generate reloads for input and matched outputs.  */\n \t  match_inputs[0] = i;\n \t  match_inputs[1] = -1;\n-\t  match_reload (goal_alt_matched[i][0], match_inputs,\n+\t  match_reload (goal_alt_matched[i][0], match_inputs, outputs,\n \t\t\tgoal_alt[i], &before, &after,\n \t\t\tcurr_static_id->operand_alternative\n \t\t\t[goal_alt_number * n_operands + goal_alt_matched[i][0]]\n@@ -4048,9 +4075,9 @@ curr_insn_transform (bool check_only_p)\n \t       && (curr_static_id->operand[goal_alt_matched[i][0]].type\n \t\t   == OP_IN))\n \t/* Generate reloads for output and matched inputs.  */\n-\tmatch_reload (i, goal_alt_matched[i], goal_alt[i], &before, &after,\n-\t\t      curr_static_id->operand_alternative\n-\t\t      [goal_alt_number * n_operands + i].earlyclobber);\n+\tmatch_reload (i, goal_alt_matched[i], outputs, goal_alt[i], &before,\n+\t\t      &after, curr_static_id->operand_alternative\n+\t\t\t      [goal_alt_number * n_operands + i].earlyclobber);\n       else if (curr_static_id->operand[i].type == OP_IN\n \t       && (curr_static_id->operand[goal_alt_matched[i][0]].type\n \t\t   == OP_IN))\n@@ -4060,12 +4087,22 @@ curr_insn_transform (bool check_only_p)\n \t  for (j = 0; (k = goal_alt_matched[i][j]) >= 0; j++)\n \t    match_inputs[j + 1] = k;\n \t  match_inputs[j + 1] = -1;\n-\t  match_reload (-1, match_inputs, goal_alt[i], &before, &after, false);\n+\t  match_reload (-1, match_inputs, outputs, goal_alt[i], &before,\n+\t\t\t&after, false);\n \t}\n       else\n \t/* We must generate code in any case when function\n \t   process_alt_operands decides that it is possible.  */\n \tgcc_unreachable ();\n+\n+      /* Memorise processed outputs so that output remaining to be processed\n+\t can avoid using the same register value (see match_reload).  */\n+      if (curr_static_id->operand[i].type == OP_OUT)\n+\t{\n+\t  outputs[n_outputs++] = i;\n+\t  outputs[n_outputs] = -1;\n+\t}\n+\n       if (optional_p)\n \t{\n \t  lra_assert (REG_P (op));"}]}