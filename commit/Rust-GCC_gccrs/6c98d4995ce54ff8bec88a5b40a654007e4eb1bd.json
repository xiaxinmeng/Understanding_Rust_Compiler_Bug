{"sha": "6c98d4995ce54ff8bec88a5b40a654007e4eb1bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM5OGQ0OTk1Y2U1NGZmOGJlYzg4YTViNDBhNjU0MDA3ZTRlYjFiZA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2015-09-22T20:50:38Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2015-09-22T20:50:38Z"}, "message": "shrink-wrap: Handle multiple predecessors of prologue\n\nThe caller of try_shrink_wrapping wants to be returned a single edge to\nput the prologue on.  To make that work even if there are multiple edges\n(all pointing to the PRO block) that need the prologue, add a new block\nthat becomes the destination of all such edges, and then jumps to PRO.\n\nIn the general case, some edges to PRO will need to be redirected, and\nnot all edges *can* be redirected.  This adds a can_get_prologue function\nthat detects such cases.  This then happily can also handle the \"prologue\nclobbers some reg that is live on the edge we want to insert it on\" case.\n\nNot all EDGE_CROSSING edges can be redirected, so handle those the same\nas EDGE_COMPLEX edges.\n\n\n2015-09-22  Segher Boessenkool  <segher@kernel.crashing.org>\n\n\t* function.c (thread_prologue_and_epilogue_insns): Delete\n\torig_entry_edge argument to try_shrink_wrapping.\n\t* shrink-wrap.c (can_get_prologue): New function.\n\t(can_dup_for_shrink_wrapping): Also handle EDGE_CROSSING.\n\t(try_shrink_wrapping): Delete orig_entry_edge argument.  Use\n\tcan_get_prologue where needed.  Remove code that finds a single\n\tedge for the prologue.  Remove code that tests if any reg clobbered\n\tby the prologue is live on the prologue edge.  Remove code that finds\n\tthe new prologue edge after duplicating blocks.  Make a new prologue\n\tblock and edge.\n\t* shrink-wrap.h (try_shrink_wrapping): Delete orig_entry_edge argument.\n\nFrom-SVN: r228022", "tree": {"sha": "6c4b9f01b10be2f4390fa87e4680491acee3ba07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c4b9f01b10be2f4390fa87e4680491acee3ba07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "50fa47d9167aa830a911df8f5ba4d52cec79536d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50fa47d9167aa830a911df8f5ba4d52cec79536d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50fa47d9167aa830a911df8f5ba4d52cec79536d"}], "stats": {"total": 188, "additions": 112, "deletions": 76}, "files": [{"sha": "162725548807a02e9f13aa28d338f98484bef768", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c98d4995ce54ff8bec88a5b40a654007e4eb1bd", "patch": "@@ -1,3 +1,17 @@\n+2015-09-22  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* function.c (thread_prologue_and_epilogue_insns): Delete\n+\torig_entry_edge argument to try_shrink_wrapping.\n+\t* shrink-wrap.c (can_get_prologue): New function.\n+\t(can_dup_for_shrink_wrapping): Also handle EDGE_CROSSING.\n+\t(try_shrink_wrapping): Delete orig_entry_edge argument.  Use\n+\tcan_get_prologue where needed.  Remove code that finds a single\n+\tedge for the prologue.  Remove code that tests if any reg clobbered\n+\tby the prologue is live on the prologue edge.  Remove code that finds\n+\tthe new prologue edge after duplicating blocks.  Make a new prologue\n+\tblock and edge.\n+\t* shrink-wrap.h (try_shrink_wrapping): Delete orig_entry_edge argument.\n+\n 2015-09-22  Jeff Law  <law@redhat.com>\n \n \t* config/pa/pa.h (MIN_LEGIT_64BIT_CONST_INT: Avoid undefined"}, {"sha": "27feb3bee8b805e321dc964c9425cf56a2f58ade", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6c98d4995ce54ff8bec88a5b40a654007e4eb1bd", "patch": "@@ -6145,7 +6145,7 @@ thread_prologue_and_epilogue_insns (void)\n      prologue/epilogue is emitted only around those parts of the\n      function that require it.  */\n \n-  try_shrink_wrapping (&entry_edge, orig_entry_edge, &bb_flags, prologue_seq);\n+  try_shrink_wrapping (&entry_edge, &bb_flags, prologue_seq);\n \n   if (split_prologue_seq != NULL_RTX)\n     {"}, {"sha": "a99474d52f53c290dd2067470b8aaa269d25c0c5", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 95, "deletions": 73, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=6c98d4995ce54ff8bec88a5b40a654007e4eb1bd", "patch": "@@ -462,6 +462,30 @@ prepare_shrink_wrap (basic_block entry_block)\n       }\n }\n \n+/* Return whether basic block PRO can get the prologue.  It can not if it\n+   has incoming complex edges that need a prologue inserted (we make a new\n+   block for the prologue, so those edges would need to be redirected, which\n+   does not work).  It also can not if there exist registers live on entry\n+   to PRO that are clobbered by the prologue.  */\n+\n+static bool\n+can_get_prologue (basic_block pro, HARD_REG_SET prologue_clobbered)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, pro->preds)\n+    if (e->flags & (EDGE_COMPLEX | EDGE_CROSSING)\n+\t&& !dominated_by_p (CDI_DOMINATORS, e->src, pro))\n+      return false;\n+\n+  HARD_REG_SET live;\n+  REG_SET_TO_HARD_REG_SET (live, df_get_live_in (pro));\n+  if (hard_reg_set_intersect_p (live, prologue_clobbered))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Return whether we can duplicate basic block BB for shrink wrapping.  We\n    cannot if the block cannot be duplicated at all, or if any of its incoming\n    edges are complex and come from a block that does not require a prologue\n@@ -478,7 +502,7 @@ can_dup_for_shrink_wrapping (basic_block bb, basic_block pro, unsigned max_size)\n   edge e;\n   edge_iterator ei;\n   FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_COMPLEX\n+    if (e->flags & (EDGE_COMPLEX | EDGE_CROSSING)\n \t&& !dominated_by_p (CDI_DOMINATORS, e->src, pro))\n       return false;\n \n@@ -577,14 +601,13 @@ fix_fake_fallthrough_edge (edge e)\n    (bb 4 is duplicated to 5; the prologue is inserted on the edge 5->3).\n \n    ENTRY_EDGE is the edge where the prologue will be placed, possibly\n-   changed by this function.  ORIG_ENTRY_EDGE is the edge where it\n-   would be placed without shrink-wrapping.  BB_WITH is a bitmap that,\n-   if we do shrink-wrap, will on return contain the interesting blocks\n-   that run with prologue.  PROLOGUE_SEQ is the prologue we will insert.  */\n+   changed by this function.  BB_WITH is a bitmap that, if we do shrink-\n+   wrap, will on return contain the interesting blocks that run with\n+   prologue.  PROLOGUE_SEQ is the prologue we will insert.  */\n \n void\n-try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n-\t\t     bitmap_head *bb_with, rtx_insn *prologue_seq)\n+try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_with,\n+\t\t     rtx_insn *prologue_seq)\n {\n   /* If we cannot shrink-wrap, are told not to shrink-wrap, or it makes\n      no sense to shrink-wrap: then do not shrink-wrap!  */\n@@ -631,6 +654,9 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n \tIOR_HARD_REG_SET (prologue_used, this_used);\n \tnote_stores (PATTERN (insn), record_hard_reg_sets, &prologue_clobbered);\n       }\n+  CLEAR_HARD_REG_BIT (prologue_clobbered, STACK_POINTER_REGNUM);\n+  if (frame_pointer_needed)\n+    CLEAR_HARD_REG_BIT (prologue_clobbered, HARD_FRAME_POINTER_REGNUM);\n \n   /* Find out what registers are set up by the prologue; any use of these\n      cannot happen before the prologue.  */\n@@ -695,8 +721,9 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n \t     pro->index);\n \n   /* Now see if we can put the prologue at the start of PRO.  Putting it\n-     there might require duplicating a block that cannot be duplicated;\n-     if so, try again with the immediate dominator of PRO, and so on.\n+     there might require duplicating a block that cannot be duplicated,\n+     or in some cases we cannot insert the prologue there at all.  If PRO\n+     wont't do, try again with the immediate dominator of PRO, and so on.\n \n      The blocks that need duplicating are those reachable from PRO but\n      not dominated by it.  We keep in BB_WITH a bitmap of the blocks\n@@ -714,6 +741,14 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n \n   while (!vec.is_empty () && pro != entry)\n     {\n+      while (pro != entry && !can_get_prologue (pro, prologue_clobbered))\n+\t{\n+\t  pro = get_immediate_dominator (CDI_DOMINATORS, pro);\n+\n+\t  bitmap_set_bit (bb_with, pro->index);\n+\t  vec.quick_push (pro);\n+\t}\n+\n       basic_block bb = vec.pop ();\n       if (!can_dup_for_shrink_wrapping (bb, pro, max_grow_size))\n \twhile (!dominated_by_p (CDI_DOMINATORS, bb, pro))\n@@ -746,14 +781,18 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n     {\n       calculate_dominance_info (CDI_POST_DOMINATORS);\n \n+      basic_block last_ok = pro;\n       while (pro != entry)\n \t{\n \t  basic_block pre = get_immediate_dominator (CDI_DOMINATORS, pro);\n-\t  if (dominated_by_p (CDI_POST_DOMINATORS, pre, pro))\n-\t    pro = pre;\n-\t  else\n+\t  if (!dominated_by_p (CDI_POST_DOMINATORS, pre, pro))\n \t    break;\n+\n+\t  pro = pre;\n+\t  if (can_get_prologue (pro, prologue_clobbered))\n+\t    last_ok = pro;\n \t}\n+      pro = last_ok;\n \n       free_dominance_info (CDI_POST_DOMINATORS);\n     }\n@@ -762,62 +801,29 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n     fprintf (dump_file, \"Bumping back to anticipatable blocks, PRO is now %d\\n\",\n \t     pro->index);\n \n-  /* If there is more than one predecessor of PRO not dominated by PRO, fail.\n-     Also find that single edge that leads to PRO.  */\n-\n-  bool multi = false;\n-  edge the_edge = 0;\n-  FOR_EACH_EDGE (e, ei, pro->preds)\n-    if (!dominated_by_p (CDI_DOMINATORS, e->src, pro))\n-      {\n-\tif (the_edge)\n-\t  multi = true;\n-\telse\n-\t  the_edge = e;\n-      }\n-\n-  if (multi)\n+  if (pro == entry)\n     {\n-      the_edge = orig_entry_edge;\n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"More than one candidate edge.\\n\");\n+      free_dominance_info (CDI_DOMINATORS);\n+      return;\n     }\n \n-  if (dump_file)\n-    fprintf (dump_file, \"Found candidate edge for shrink-wrapping, %d->%d.\\n\",\n-\t     the_edge->src->index, the_edge->dest->index);\n-\n-  *entry_edge = the_edge;\n-\n   /* Compute what fraction of the frequency and count of the blocks that run\n      both with and without prologue are for running with prologue.  This gives\n      the correct answer for reducible flow graphs; for irreducible flow graphs\n      our profile is messed up beyond repair anyway.  */\n \n-  int num = (*entry_edge)->probability;\n-  int den = REG_BR_PROB_BASE;\n-\n-  if (*entry_edge == orig_entry_edge)\n-    goto out;\n+  gcov_type num = 0;\n+  gcov_type den = 0;\n \n-  /* Test whether the prologue is known to clobber any register\n-     (other than FP or SP) which are live on the edge.  */\n+  FOR_EACH_EDGE (e, ei, pro->preds)\n+    if (!dominated_by_p (CDI_DOMINATORS, e->src, pro))\n+      {\n+\tnum += EDGE_FREQUENCY (e);\n+\tden += e->src->frequency;\n+      }\n \n-  HARD_REG_SET live_on_edge;\n-  CLEAR_HARD_REG_BIT (prologue_clobbered, STACK_POINTER_REGNUM);\n-  if (frame_pointer_needed)\n-    CLEAR_HARD_REG_BIT (prologue_clobbered, HARD_FRAME_POINTER_REGNUM);\n-  REG_SET_TO_HARD_REG_SET (live_on_edge,\n-\t\t\t   df_get_live_in ((*entry_edge)->dest));\n-  if (hard_reg_set_intersect_p (live_on_edge, prologue_clobbered))\n-    {\n-      *entry_edge = orig_entry_edge;\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \"Shrink-wrapping aborted due to clobber.\\n\");\n-      goto out;\n-    }\n+  if (den == 0)\n+    den = 1;\n \n   /* All is okay, so do it.  */\n \n@@ -852,20 +858,6 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n \tdup->count -= bb->count;\n       }\n \n-  /* Change ENTRY_EDGE, if its src is duplicated.  Do this first, before\n-     the redirects have had a chance to create new blocks on the edge we\n-     want to use for the prologue, which makes us not find it.  */\n-\n-  gcc_assert (!dominated_by_p (CDI_DOMINATORS, (*entry_edge)->src, pro));\n-\n-  if (bitmap_bit_p (bb_with, (*entry_edge)->src->index))\n-    {\n-      basic_block src = (basic_block) (*entry_edge)->src->aux;\n-      FOR_EACH_EDGE (e, ei, src->succs)\n-\tif (e->dest == pro)\n-\t  *entry_edge = e;\n-    }\n-\n   /* Now change the edges to point to the copies, where appropriate.  */\n \n   FOR_EACH_BB_FN (bb, cfun)\n@@ -923,7 +915,37 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n \t    emit_barrier_after_bb (e->src);\n \t  }\n \n-out:\n+  /* Finally, we want a single edge to put the prologue on.  Make a new\n+     block before the PRO block; the edge beteen them is the edge we want.\n+     Then redirect those edges into PRO that come from blocks without the\n+     prologue, to point to the new block instead.  The new prologue block\n+     is put at the end of the insn chain.  */\n+\n+  basic_block new_bb = create_empty_bb (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n+  BB_COPY_PARTITION (new_bb, pro);\n+  if (dump_file)\n+    fprintf (dump_file, \"Made prologue block %d\\n\", new_bb->index);\n+\n+  for (ei = ei_start (pro->preds); (e = ei_safe_edge (ei)); )\n+    {\n+      if (bitmap_bit_p (bb_with, e->src->index)\n+\t  || dominated_by_p (CDI_DOMINATORS, e->src, pro))\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n+\n+      new_bb->count += RDIV (e->src->count * e->probability, REG_BR_PROB_BASE);\n+      new_bb->frequency += EDGE_FREQUENCY (e);\n+\n+      redirect_edge_and_branch_force (e, new_bb);\n+      if (dump_file)\n+\tfprintf (dump_file, \"Redirected edge from %d\\n\", e->src->index);\n+    }\n+\n+  *entry_edge = make_single_succ_edge (new_bb, pro, EDGE_FALLTHRU);\n+  force_nonfallthru (*entry_edge);\n+\n   free_dominance_info (CDI_DOMINATORS);\n }\n "}, {"sha": "527a57a4231aa9e2e552cf458353529c803795ae", "filename": "gcc/shrink-wrap.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd/gcc%2Fshrink-wrap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c98d4995ce54ff8bec88a5b40a654007e4eb1bd/gcc%2Fshrink-wrap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.h?ref=6c98d4995ce54ff8bec88a5b40a654007e4eb1bd", "patch": "@@ -24,8 +24,8 @@ along with GCC; see the file COPYING3.  If not see\n \n /* In shrink-wrap.c.  */\n extern bool requires_stack_frame_p (rtx_insn *, HARD_REG_SET, HARD_REG_SET);\n-extern void try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n-\t\t\t\t bitmap_head *bb_flags, rtx_insn *prologue_seq);\n+extern void try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_flags,\n+\t\t\t\t rtx_insn *prologue_seq);\n extern edge get_unconverted_simple_return (edge, bitmap_head,\n \t\t\t\t\t   vec<edge> *, rtx_insn **);\n extern void convert_to_simple_return (edge entry_edge, edge orig_entry_edge,"}]}