{"sha": "5e9754afebd0a9433fd5b147fce4d39b687ea88d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU5NzU0YWZlYmQwYTk0MzNmZDViMTQ3ZmNlNGQzOWI2ODdlYTg4ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-04T14:38:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-04T14:38:27Z"}, "message": "c-lex.c (narrowest_unsigned_type, [...]): Take low/high pair.\n\n\t* c-lex.c (narrowest_unsigned_type, narrowest_signed_type): Take\n\tlow/high pair. Do range checking directly.\n\t(interpret_integer): Adjust.\n\nFrom-SVN: r85559", "tree": {"sha": "0a6a470d019d3994f8981662fef27725c628f174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a6a470d019d3994f8981662fef27725c628f174"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e9754afebd0a9433fd5b147fce4d39b687ea88d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e9754afebd0a9433fd5b147fce4d39b687ea88d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e9754afebd0a9433fd5b147fce4d39b687ea88d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e9754afebd0a9433fd5b147fce4d39b687ea88d/comments", "author": null, "committer": null, "parents": [{"sha": "6c167c45b1059150631362a647864ee0ca900a91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c167c45b1059150631362a647864ee0ca900a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c167c45b1059150631362a647864ee0ca900a91"}], "stats": {"total": 66, "additions": 42, "deletions": 24}, "files": [{"sha": "81b43147a3662d1fe146c1ccf29a6016af1aa3ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9754afebd0a9433fd5b147fce4d39b687ea88d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9754afebd0a9433fd5b147fce4d39b687ea88d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e9754afebd0a9433fd5b147fce4d39b687ea88d", "patch": "@@ -1,3 +1,9 @@\n+2004-08-03  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* c-lex.c (narrowest_unsigned_type, narrowest_signed_type): Take\n+\tlow/high pair. Do range checking directly.\n+\t(interpret_integer): Adjust.\n+\n 2004-08-04  Nick Clifton  <nickc@redhat.com>\n \n \t* config/sh/sh.h (TARGET_SWITCHES): Add no-renesas to select the\n@@ -108,7 +114,7 @@\n \t* config/i386/xmmintrin.h: Include <mm_malloc.h>.\n \n 2004-08-03  H.J. Lu  <hongjiu.lu@intel.com>\n-\t    Tanguy Fautr\ufffd  <tfautre@pandora.be>\n+\t    Tanguy Fautr\u00c3  <tfautre@pandora.be>\n \n \t* config/i386/pmm_malloc.h: New file.\n "}, {"sha": "ee0ae3e8df36a5f79f75a6831e4d05b428b5c095", "filename": "gcc/c-lex.c", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9754afebd0a9433fd5b147fce4d39b687ea88d/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9754afebd0a9433fd5b147fce4d39b687ea88d/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=5e9754afebd0a9433fd5b147fce4d39b687ea88d", "patch": "@@ -62,10 +62,10 @@ int c_lex_string_translate = 1;\n \n static tree interpret_integer (const cpp_token *, unsigned int);\n static tree interpret_float (const cpp_token *, unsigned int);\n-static enum integer_type_kind\n-  narrowest_unsigned_type (tree, unsigned int);\n-static enum integer_type_kind\n-  narrowest_signed_type (tree, unsigned int);\n+static enum integer_type_kind narrowest_unsigned_type\n+\t(unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT, unsigned int);\n+static enum integer_type_kind narrowest_signed_type\n+\t(unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT, unsigned int);\n static enum cpp_ttype lex_string (const cpp_token *, tree *, bool);\n static tree lex_charconst (const cpp_token *);\n static void update_header_times (const char *);\n@@ -461,10 +461,13 @@ c_lex (tree *value)\n }\n \n /* Returns the narrowest C-visible unsigned type, starting with the\n-   minimum specified by FLAGS, that can fit VALUE, or itk_none if\n+   minimum specified by FLAGS, that can fit HIGH:LOW, or itk_none if\n    there isn't one.  */\n+\n static enum integer_type_kind\n-narrowest_unsigned_type (tree value, unsigned int flags)\n+narrowest_unsigned_type (unsigned HOST_WIDE_INT low,\n+\t\t\t unsigned HOST_WIDE_INT high,\n+\t\t\t unsigned int flags)\n {\n   enum integer_type_kind itk;\n \n@@ -475,20 +478,23 @@ narrowest_unsigned_type (tree value, unsigned int flags)\n   else\n     itk = itk_unsigned_long_long;\n \n-  /* int_fits_type_p must think the type of its first argument is\n-     wider than its second argument, or it won't do the proper check.  */\n-  TREE_TYPE (value) = widest_unsigned_literal_type_node;\n-\n   for (; itk < itk_none; itk += 2 /* skip unsigned types */)\n-    if (int_fits_type_p (value, integer_types[itk]))\n-      return itk;\n+    {\n+      tree upper = TYPE_MAX_VALUE (integer_types[itk]);\n+\n+      if ((unsigned HOST_WIDE_INT)TREE_INT_CST_HIGH (upper) > high\n+\t  || ((unsigned HOST_WIDE_INT)TREE_INT_CST_HIGH (upper) == high\n+\t      && TREE_INT_CST_LOW (upper) >= low))\n+\treturn itk;\n+    }\n \n   return itk_none;\n }\n \n /* Ditto, but narrowest signed type.  */\n static enum integer_type_kind\n-narrowest_signed_type (tree value, unsigned int flags)\n+narrowest_signed_type (unsigned HOST_WIDE_INT low,\n+\t\t       unsigned HOST_WIDE_INT high, unsigned int flags)\n {\n   enum integer_type_kind itk;\n \n@@ -499,13 +505,16 @@ narrowest_signed_type (tree value, unsigned int flags)\n   else\n     itk = itk_long_long;\n \n-  /* int_fits_type_p must think the type of its first argument is\n-     wider than its second argument, or it won't do the proper check.  */\n-  TREE_TYPE (value) = widest_unsigned_literal_type_node;\n \n   for (; itk < itk_none; itk += 2 /* skip signed types */)\n-    if (int_fits_type_p (value, integer_types[itk]))\n-      return itk;\n+    {\n+      tree upper = TYPE_MAX_VALUE (integer_types[itk]);\n+      \n+      if ((unsigned HOST_WIDE_INT)TREE_INT_CST_HIGH (upper) > high\n+\t  || ((unsigned HOST_WIDE_INT)TREE_INT_CST_HIGH (upper) == high\n+\t      && TREE_INT_CST_LOW (upper) >= low))\n+\treturn itk;\n+    }\n \n   return itk_none;\n }\n@@ -521,18 +530,19 @@ interpret_integer (const cpp_token *token, unsigned int flags)\n \n   integer = cpp_interpret_integer (parse_in, token, flags);\n   integer = cpp_num_sign_extend (integer, options->precision);\n-  value = build_int_2 (integer.low, integer.high);\n \n   /* The type of a constant with a U suffix is straightforward.  */\n   if (flags & CPP_N_UNSIGNED)\n-    itk = narrowest_unsigned_type (value, flags);\n+    itk = narrowest_unsigned_type (integer.low, integer.high, flags);\n   else\n     {\n       /* The type of a potentially-signed integer constant varies\n \t depending on the base it's in, the standard in use, and the\n \t length suffixes.  */\n-      enum integer_type_kind itk_u = narrowest_unsigned_type (value, flags);\n-      enum integer_type_kind itk_s = narrowest_signed_type (value, flags);\n+      enum integer_type_kind itk_u\n+\t= narrowest_unsigned_type (integer.low, integer.high, flags);\n+      enum integer_type_kind itk_s\n+\t= narrowest_signed_type (integer.low, integer.high, flags);\n \n       /* In both C89 and C99, octal and hex constants may be signed or\n \t unsigned, whichever fits tighter.  We do not warn about this\n@@ -578,11 +588,13 @@ interpret_integer (const cpp_token *token, unsigned int flags)\n     pedwarn (\"integer constant is too large for \\\"%s\\\" type\",\n \t     (flags & CPP_N_UNSIGNED) ? \"unsigned long\" : \"long\");\n \n+  value = build_int_2 (integer.low, integer.high);\n   TREE_TYPE (value) = type;\n \n   /* Convert imaginary to a complex type.  */\n   if (flags & CPP_N_IMAGINARY)\n-    value = build_complex (NULL_TREE, convert (type, integer_zero_node), value);\n+    value = build_complex (NULL_TREE,\n+\t\t\t   convert (type, integer_zero_node), value);\n \n   return value;\n }"}]}