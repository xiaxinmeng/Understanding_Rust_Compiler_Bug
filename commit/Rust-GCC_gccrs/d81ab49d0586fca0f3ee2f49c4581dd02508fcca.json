{"sha": "d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgxYWI0OWQwNTg2ZmNhMGYzZWUyZjQ5YzQ1ODFkZDAyNTA4ZmNjYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-08-06T07:26:32Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-08-06T07:26:32Z"}, "message": "tree.h (OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV): Rename to ...\n\n\t* tree.h (OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV): Rename to ...\n\t(OMP_CLAUSE_LASTPRIVATE_LOOP_IV): ... this.  Adjust comment.\n\t* gimplify.c (gimple_add_tmp_var): In SIMD contexts, turn addressable\n\tnew vars into GOVD_PRIVATE rather than GOVD_LOCAL.\n\t(gimplify_omp_for): Don't do C++ random access iterator clause\n\tadjustments on combined constructs from OMP_LOOP.  For OMP_LOOP,\n\tdon't predetermine the artificial iterator in case of C++ random\n\taccess iterators as lastprivate, but private.  For OMP_LOOP, force\n\tbind expr around simd body and force for_pre_body before the\n\tconstruct.  Use OMP_CLAUSE_LASTPRIVATE_LOOP_IV instead of\n\tOMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV.\n\t(gimplify_omp_loop): Add firstprivate clauses on OMP_PARALLEL for\n\tdiff var of C++ random access iterators.  Handle\n\tOMP_CLAUSE_FIRSTPRIVATE.  For OMP_CLAUSE_LASTPRIVATE_LOOP_IV, if\n\tnot outermost also add OMP_CLAUSE_FIRSTPRIVATE, and in both cases\n\tclear OMP_CLAUSE_LASTPRIVATE_LOOP_IV on the lastprivate clause\n\ton the OMP_FOR and OMP_DISTRIBUTE constructs if any.\n\t* omp-low.c (lower_rec_input_clauses): For\n\tOMP_CLAUSE_LASTPRIVATE_LOOP_IV on simd copy construct the private\n\tvariables instead of default constructing them.\n\t(lower_lastprivate_clauses): Use OMP_CLAUSE_LASTPRIVATE_LOOP_IV\n\tinstead of OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV and move the\n\tis_taskloop_ctx check from the assert to the guarding condition.\ngcc/cp/\n\t* parser.c (cp_parser_omp_for_loop): For OMP_LOOP, ignore parallel\n\tclauses and predetermine iterator as lastprivate.\n\t* semantics.c (handle_omp_for_class_iterator): Use\n\tOMP_CLAUSE_LASTPRIVATE_LOOP_IV instead of\n\tOMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV, set it for lastprivate also\n\ton OMP_LOOP construct.  If a clause is missing for class iterator\n\ton OMP_LOOP, add firstprivate clause, and if there is private\n\tclause, turn it into firstprivate too.\n\t(finish_omp_for): Formatting fix.  For OMP_LOOP, adjust\n\tOMP_CLAUSE_LASTPRIVATE_LOOP_IV clause CP_CLAUSE_INFO, so that it\n\tuses copy ctor instead of default ctor.\n\t* cp-gimplify.c (cp_gimplify_expr): Handle OMP_LOOP like\n\tOMP_DISTRIBUTE etc.\n\t(cp_fold_r): Likewise.\n\t(cp_genericize_r): Likewise.\n\t(cxx_omp_finish_clause): Also finish lastprivate clause with\n\tOMP_CLAUSE_LASTPRIVATE_LOOP_IV flag.\n\t* pt.c (tsubst_omp_clauses): Handle OMP_CLAUSE_BIND.\n\t(tsubst_omp_for_iterator): For OMP_LOOP, ignore parallel\n\tclauses and predetermine iterator as lastprivate.\n\t* constexpr.c (potential_constant_expression_1): Handle OMP_LOOP\n\tlike OMP_DISTRIBUTE etc.\nlibgomp/\n\t* testsuite/libgomp.c++/loop-13.C: New test.\n\t* testsuite/libgomp.c++/loop-14.C: New test.\n\t* testsuite/libgomp.c++/loop-15.C: New test.\n\nFrom-SVN: r274138", "tree": {"sha": "d3d4e04d7c7e987c478e88417ded02a08e3e8aad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3d4e04d7c7e987c478e88417ded02a08e3e8aad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7551a6e467c64b3155d5b8f005cd7ea7143b21f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7551a6e467c64b3155d5b8f005cd7ea7143b21f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7551a6e467c64b3155d5b8f005cd7ea7143b21f3"}], "stats": {"total": 1277, "additions": 1237, "deletions": 40}, "files": [{"sha": "ccb7253c4804ca6d266a33aec2cd3dafbb7ae569", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -1,3 +1,29 @@\n+2019-08-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree.h (OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV): Rename to ...\n+\t(OMP_CLAUSE_LASTPRIVATE_LOOP_IV): ... this.  Adjust comment.\n+\t* gimplify.c (gimple_add_tmp_var): In SIMD contexts, turn addressable\n+\tnew vars into GOVD_PRIVATE rather than GOVD_LOCAL.\n+\t(gimplify_omp_for): Don't do C++ random access iterator clause\n+\tadjustments on combined constructs from OMP_LOOP.  For OMP_LOOP,\n+\tdon't predetermine the artificial iterator in case of C++ random\n+\taccess iterators as lastprivate, but private.  For OMP_LOOP, force\n+\tbind expr around simd body and force for_pre_body before the\n+\tconstruct.  Use OMP_CLAUSE_LASTPRIVATE_LOOP_IV instead of\n+\tOMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV.\n+\t(gimplify_omp_loop): Add firstprivate clauses on OMP_PARALLEL for\n+\tdiff var of C++ random access iterators.  Handle\n+\tOMP_CLAUSE_FIRSTPRIVATE.  For OMP_CLAUSE_LASTPRIVATE_LOOP_IV, if\n+\tnot outermost also add OMP_CLAUSE_FIRSTPRIVATE, and in both cases\n+\tclear OMP_CLAUSE_LASTPRIVATE_LOOP_IV on the lastprivate clause\n+\ton the OMP_FOR and OMP_DISTRIBUTE constructs if any.\n+\t* omp-low.c (lower_rec_input_clauses): For\n+\tOMP_CLAUSE_LASTPRIVATE_LOOP_IV on simd copy construct the private\n+\tvariables instead of default constructing them.\n+\t(lower_lastprivate_clauses): Use OMP_CLAUSE_LASTPRIVATE_LOOP_IV\n+\tinstead of OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV and move the\n+\tis_taskloop_ctx check from the assert to the guarding condition.\n+\n 2019-08-06  Kito Cheng  <kito.cheng@sifive.com>\n \n \t* gcc/config/riscv/multilib-generator: (canonical_order): New."}, {"sha": "98e3b3f41d8e85f1b45b68da8147aee260281898", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -1,3 +1,28 @@\n+2019-08-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* parser.c (cp_parser_omp_for_loop): For OMP_LOOP, ignore parallel\n+\tclauses and predetermine iterator as lastprivate.\n+\t* semantics.c (handle_omp_for_class_iterator): Use\n+\tOMP_CLAUSE_LASTPRIVATE_LOOP_IV instead of\n+\tOMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV, set it for lastprivate also\n+\ton OMP_LOOP construct.  If a clause is missing for class iterator\n+\ton OMP_LOOP, add firstprivate clause, and if there is private\n+\tclause, turn it into firstprivate too.\n+\t(finish_omp_for): Formatting fix.  For OMP_LOOP, adjust\n+\tOMP_CLAUSE_LASTPRIVATE_LOOP_IV clause CP_CLAUSE_INFO, so that it\n+\tuses copy ctor instead of default ctor.\n+\t* cp-gimplify.c (cp_gimplify_expr): Handle OMP_LOOP like\n+\tOMP_DISTRIBUTE etc.\n+\t(cp_fold_r): Likewise.\n+\t(cp_genericize_r): Likewise.\n+\t(cxx_omp_finish_clause): Also finish lastprivate clause with\n+\tOMP_CLAUSE_LASTPRIVATE_LOOP_IV flag.\n+\t* pt.c (tsubst_omp_clauses): Handle OMP_CLAUSE_BIND.\n+\t(tsubst_omp_for_iterator): For OMP_LOOP, ignore parallel\n+\tclauses and predetermine iterator as lastprivate.\n+\t* constexpr.c (potential_constant_expression_1): Handle OMP_LOOP\n+\tlike OMP_DISTRIBUTE etc.\n+\n 2019-08-05  Marek Polacek  <polacek@redhat.com>\n \n \tDR 2413 - typename in conversion-function-ids."}, {"sha": "36a66337433f071aeef192c149a73aea365743d5", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -6437,6 +6437,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     case OMP_SIMD:\n     case OMP_DISTRIBUTE:\n     case OMP_TASKLOOP:\n+    case OMP_LOOP:\n     case OMP_TEAMS:\n     case OMP_TARGET_DATA:\n     case OMP_TARGET:"}, {"sha": "065dcb7ba06ceb048ff872c1bbf852e893376ec2", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -796,6 +796,7 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n     case OMP_FOR:\n     case OMP_SIMD:\n     case OMP_DISTRIBUTE:\n+    case OMP_LOOP:\n     case OMP_TASKLOOP:\n       ret = cp_gimplify_omp_for (expr_p, pre_p);\n       break;\n@@ -1053,7 +1054,7 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)\n \n   code = TREE_CODE (stmt);\n   if (code == OMP_FOR || code == OMP_SIMD || code == OMP_DISTRIBUTE\n-      || code == OMP_TASKLOOP || code == OACC_LOOP)\n+      || code == OMP_LOOP || code == OMP_TASKLOOP || code == OACC_LOOP)\n     {\n       tree x;\n       int i, n;\n@@ -1544,6 +1545,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n     case OMP_FOR:\n     case OMP_SIMD:\n     case OMP_DISTRIBUTE:\n+    case OMP_LOOP:\n     case OACC_LOOP:\n       genericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n       break;\n@@ -2097,7 +2099,9 @@ cxx_omp_finish_clause (tree c, gimple_seq *)\n   tree decl, inner_type;\n   bool make_shared = false;\n \n-  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE)\n+  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE\n+      && (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_LASTPRIVATE\n+\t  || !OMP_CLAUSE_LASTPRIVATE_LOOP_IV (c)))\n     return;\n \n   decl = OMP_CLAUSE_DECL (c);\n@@ -2115,9 +2119,11 @@ cxx_omp_finish_clause (tree c, gimple_seq *)\n   /* Check for special function availability by building a call to one.\n      Save the results, because later we won't be in the right context\n      for making these queries.  */\n+  bool first = OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE;\n   if (!make_shared\n       && CLASS_TYPE_P (inner_type)\n-      && cxx_omp_create_clause_info (c, inner_type, false, true, false, true))\n+      && cxx_omp_create_clause_info (c, inner_type, !first, first, !first,\n+\t\t\t\t     true))\n     make_shared = true;\n \n   if (make_shared)"}, {"sha": "79da7b52eb9a27558bb0b8777ca3bdd5216bc367", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -37458,7 +37458,8 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \treal_decl = decl;\n       if (cclauses != NULL\n \t  && cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] != NULL\n-\t  && real_decl != NULL_TREE)\n+\t  && real_decl != NULL_TREE\n+\t  && code != OMP_LOOP)\n \t{\n \t  tree *c;\n \t  for (c = &cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL]; *c ; )\n@@ -37518,12 +37519,12 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t    }\n \t  if (c == NULL)\n \t    {\n-\t      if (code != OMP_SIMD)\n+\t      if ((code == OMP_SIMD && collapse != 1) || code == OMP_LOOP)\n+\t\tc = build_omp_clause (loc, OMP_CLAUSE_LASTPRIVATE);\n+\t      else if (code != OMP_SIMD)\n \t\tc = build_omp_clause (loc, OMP_CLAUSE_PRIVATE);\n-\t      else if (collapse == 1)\n-\t\tc = build_omp_clause (loc, OMP_CLAUSE_LINEAR);\n \t      else\n-\t\tc = build_omp_clause (loc, OMP_CLAUSE_LASTPRIVATE);\n+\t\tc = build_omp_clause (loc, OMP_CLAUSE_LINEAR);\n \t      OMP_CLAUSE_DECL (c) = add_private_clause;\n \t      c = finish_omp_clauses (c, C_ORT_OMP);\n \t      if (c)"}, {"sha": "903e589b66309a2b73d4d0ed0a263d1eeea23b3b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -16404,6 +16404,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \tcase OMP_CLAUSE_SIMD:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_ORDER:\n+\tcase OMP_CLAUSE_BIND:\n \tcase OMP_CLAUSE_INDEPENDENT:\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n@@ -16732,7 +16733,8 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree &orig_declv,\n     {\n       tree *pc;\n       int j;\n-      for (j = (omp_parallel_combined_clauses == NULL ? 1 : 0); j < 2; j++)\n+      for (j = ((omp_parallel_combined_clauses == NULL\n+\t\t|| TREE_CODE (t) == OMP_LOOP) ? 1 : 0); j < 2; j++)\n \t{\n \t  for (pc = j ? clauses : omp_parallel_combined_clauses; *pc; )\n \t    {\n@@ -16772,7 +16774,10 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree &orig_declv,\n \t}\n       if (*pc == NULL_TREE)\n \t{\n-\t  tree c = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n+\t  tree c = build_omp_clause (input_location,\n+\t\t\t\t     TREE_CODE (t) == OMP_LOOP\n+\t\t\t\t     ? OMP_CLAUSE_LASTPRIVATE\n+\t\t\t\t     : OMP_CLAUSE_PRIVATE);\n \t  OMP_CLAUSE_DECL (c) = decl;\n \t  c = finish_omp_clauses (c, C_ORT_OMP);\n \t  if (c)"}, {"sha": "fa6962454bf4357980eccf056f813953b8689d59", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -8422,24 +8422,25 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \n   incr = cp_convert (TREE_TYPE (diff), incr, tf_warning_or_error);\n   incr = cp_fully_fold (incr);\n-  bool taskloop_iv_seen = false;\n+  tree loop_iv_seen = NULL_TREE;\n   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n     if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t&& OMP_CLAUSE_DECL (c) == iter)\n       {\n-\tif (code == OMP_TASKLOOP)\n+\tif (code == OMP_TASKLOOP || code == OMP_LOOP)\n \t  {\n-\t    taskloop_iv_seen = true;\n-\t    OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV (c) = 1;\n+\t    loop_iv_seen = c;\n+\t    OMP_CLAUSE_LASTPRIVATE_LOOP_IV (c) = 1;\n \t  }\n \tbreak;\n       }\n-    else if (code == OMP_TASKLOOP\n+    else if ((code == OMP_TASKLOOP || code == OMP_LOOP)\n \t     && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n \t     && OMP_CLAUSE_DECL (c) == iter)\n       {\n-\ttaskloop_iv_seen = true;\n-\tOMP_CLAUSE_PRIVATE_TASKLOOP_IV (c) = 1;\n+\tloop_iv_seen = c;\n+\tif (code == OMP_TASKLOOP)\n+\t  OMP_CLAUSE_PRIVATE_TASKLOOP_IV (c) = 1;\n       }\n \n   decl = create_temporary_var (TREE_TYPE (diff));\n@@ -8459,7 +8460,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n   tree diffvar = NULL_TREE;\n   if (code == OMP_TASKLOOP)\n     {\n-      if (!taskloop_iv_seen)\n+      if (!loop_iv_seen)\n \t{\n \t  tree ivc = build_omp_clause (locus, OMP_CLAUSE_FIRSTPRIVATE);\n \t  OMP_CLAUSE_DECL (ivc) = iter;\n@@ -8475,6 +8476,28 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n       pushdecl (diffvar);\n       add_decl_expr (diffvar);\n     }\n+  else if (code == OMP_LOOP)\n+    {\n+      if (!loop_iv_seen)\n+\t{\n+\t  /* While iterators on the loop construct are predetermined\n+\t     lastprivate, if the decl is not declared inside of the\n+\t     loop, OMP_CLAUSE_LASTPRIVATE should have been added\n+\t     already.  */\n+\t  loop_iv_seen = build_omp_clause (locus, OMP_CLAUSE_FIRSTPRIVATE);\n+\t  OMP_CLAUSE_DECL (loop_iv_seen) = iter;\n+\t  OMP_CLAUSE_CHAIN (loop_iv_seen) = clauses;\n+\t  clauses = loop_iv_seen;\n+\t}\n+      else if (OMP_CLAUSE_CODE (loop_iv_seen) == OMP_CLAUSE_PRIVATE)\n+\t{\n+\t  OMP_CLAUSE_PRIVATE_DEBUG (loop_iv_seen) = 0;\n+\t  OMP_CLAUSE_PRIVATE_OUTER_REF (loop_iv_seen) = 0;\n+\t  OMP_CLAUSE_CODE (loop_iv_seen) = OMP_CLAUSE_FIRSTPRIVATE;\n+\t}\n+      if (OMP_CLAUSE_CODE (loop_iv_seen) == OMP_CLAUSE_FIRSTPRIVATE)\n+\tcxx_omp_finish_clause (loop_iv_seen, NULL);\n+    }\n \n   orig_pre_body = *pre_body;\n   *pre_body = push_stmt_list ();\n@@ -8825,9 +8848,7 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n     omp_for = NULL_TREE;\n \n   if (omp_for == NULL)\n-    {\n-      return NULL;\n-    }\n+    return NULL;\n \n   add_stmt (omp_for);\n \n@@ -8926,6 +8947,16 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t      gcc_unreachable ();\n \t    }\n \t}\n+  /* Override saved methods on OMP_LOOP's OMP_CLAUSE_LASTPRIVATE_LOOP_IV\n+     clauses, we need copy ctor for those rather than default ctor,\n+     plus as for other lastprivates assignment op and dtor.  */\n+  if (code == OMP_LOOP && !processing_template_decl)\n+    for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t  && OMP_CLAUSE_LASTPRIVATE_LOOP_IV (c)\n+\t  && cxx_omp_create_clause_info (c, TREE_TYPE (OMP_CLAUSE_DECL (c)),\n+\t\t\t\t\t false, true, true, true))\n+\tCP_OMP_CLAUSE_INFO (c) = NULL_TREE;\n \n   return omp_for;\n }"}, {"sha": "10b9b68d5ce633491fd9ad83d5813a5abc5568fe", "filename": "gcc/gimplify.c", "status": "modified", "additions": 71, "deletions": 9, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -775,14 +775,27 @@ gimple_add_tmp_var (tree tmp)\n       if (gimplify_omp_ctxp)\n \t{\n \t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n+\t  int flag = GOVD_LOCAL;\n \t  while (ctx\n \t\t && (ctx->region_type == ORT_WORKSHARE\n \t\t     || ctx->region_type == ORT_TASKGROUP\n \t\t     || ctx->region_type == ORT_SIMD\n \t\t     || ctx->region_type == ORT_ACC))\n-\t    ctx = ctx->outer_context;\n+\t    {\n+\t      if (ctx->region_type == ORT_SIMD\n+\t\t  && TREE_ADDRESSABLE (tmp)\n+\t\t  && !TREE_STATIC (tmp))\n+\t\t{\n+\t\t  if (TREE_CODE (DECL_SIZE_UNIT (tmp)) != INTEGER_CST)\n+\t\t    ctx->add_safelen1 = true;\n+\t\t  else\n+\t\t    flag = GOVD_PRIVATE;\n+\t\t  break;\n+\t\t}\n+\t      ctx = ctx->outer_context;\n+\t    }\n \t  if (ctx)\n-\t    omp_add_variable (ctx, tmp, GOVD_LOCAL | GOVD_SEEN);\n+\t    omp_add_variable (ctx, tmp, flag | GOVD_SEEN);\n \t}\n     }\n   else if (cfun)\n@@ -10590,6 +10603,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n   orig_for_stmt = for_stmt = *expr_p;\n \n+  bool loop_p = (omp_find_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_BIND)\n+\t\t != NULL_TREE);\n   if (OMP_FOR_INIT (for_stmt) == NULL_TREE)\n     {\n       tree *data[4] = { NULL, NULL, NULL, NULL };\n@@ -10641,15 +10656,18 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t}\n \n       for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (inner_for_stmt)); i++)\n-\tif (OMP_FOR_ORIG_DECLS (inner_for_stmt)\n+\tif (!loop_p\n+\t    && OMP_FOR_ORIG_DECLS (inner_for_stmt)\n \t    && TREE_CODE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner_for_stmt),\n \t\t\t\t\ti)) == TREE_LIST\n \t    && TREE_PURPOSE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner_for_stmt),\n \t\t\t\t\t   i)))\n \t  {\n \t    tree orig = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner_for_stmt), i);\n \t    /* Class iterators aren't allowed on OMP_SIMD, so the only\n-\t       case we need to solve is distribute parallel for.  */\n+\t       case we need to solve is distribute parallel for.  They are\n+\t       allowed on the loop construct, but that is already handled\n+\t       in gimplify_omp_loop.  */\n \t    gcc_assert (TREE_CODE (inner_for_stmt) == OMP_FOR\n \t\t\t&& TREE_CODE (for_stmt) == OMP_DISTRIBUTE\n \t\t\t&& data[1]);\n@@ -10791,8 +10809,6 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t  }\n     }\n \n-  bool loop_p = (omp_find_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_BIND)\n-\t\t != NULL_TREE);\n   if (TREE_CODE (for_stmt) != OMP_TASKLOOP)\n     gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p, ort,\n \t\t\t       loop_p && TREE_CODE (for_stmt) != OMP_SIMD\n@@ -11163,6 +11179,13 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t   || !bitmap_bit_p (has_decl_expr, DECL_UID (decl)));\n \t      if (TREE_PRIVATE (t))\n \t\tlastprivate = false;\n+\t      if (loop_p && OMP_FOR_ORIG_DECLS (for_stmt))\n+\t\t{\n+\t\t  tree elt = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (for_stmt), i);\n+\t\t  if (TREE_CODE (elt) == TREE_LIST && TREE_PURPOSE (elt))\n+\t\t    lastprivate = false;\n+\t\t}\n+\n \t      struct gimplify_omp_ctx *outer\n \t\t= gimplify_omp_ctxp->outer_context;\n \t      if (outer && lastprivate)\n@@ -11485,7 +11508,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n   BITMAP_FREE (has_decl_expr);\n \n-  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)\n+  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP\n+      || (loop_p && orig_for_stmt == for_stmt))\n     {\n       push_gimplify_context ();\n       if (TREE_CODE (OMP_FOR_BODY (orig_for_stmt)) != BIND_EXPR)\n@@ -11500,7 +11524,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   gimple *g = gimplify_and_return_first (OMP_FOR_BODY (orig_for_stmt),\n \t\t\t\t\t &for_body);\n \n-  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)\n+  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP\n+      || (loop_p && orig_for_stmt == for_stmt))\n     {\n       if (gimple_code (g) == GIMPLE_BIND)\n \tpop_gimplify_context (g);\n@@ -11540,6 +11565,11 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n     default:\n       gcc_unreachable ();\n     }\n+  if (loop_p && kind == GF_OMP_FOR_KIND_SIMD)\n+    {\n+      gimplify_seq_add_seq (pre_p, for_pre_body);\n+      for_pre_body = NULL;\n+    }\n   gfor = gimple_build_omp_for (for_body, kind, OMP_FOR_CLAUSES (orig_for_stmt),\n \t\t\t       TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)),\n \t\t\t       for_pre_body);\n@@ -11640,7 +11670,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t     a shared clause on task.  If the same decl is also firstprivate,\n \t     add also firstprivate clause on the inner taskloop.  */\n \t  case OMP_CLAUSE_LASTPRIVATE:\n-\t    if (OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV (c))\n+\t    if (OMP_CLAUSE_LASTPRIVATE_LOOP_IV (c))\n \t      {\n \t\t/* For taskloop C++ lastprivate IVs, we want:\n \t\t   1) private on outer taskloop\n@@ -11963,6 +11993,21 @@ gimplify_omp_loop (tree *expr_p, gimple_seq *pre_p)\n \t  OMP_PARALLEL_BODY (*expr_p) = bind;\n \t  OMP_PARALLEL_COMBINED (*expr_p) = 1;\n \t  SET_EXPR_LOCATION (*expr_p, EXPR_LOCATION (for_stmt));\n+\t  tree *pc = &OMP_PARALLEL_CLAUSES (*expr_p);\n+\t  for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)\n+\t    if (OMP_FOR_ORIG_DECLS (for_stmt)\n+\t\t&& (TREE_CODE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (for_stmt), i))\n+\t\t    == TREE_LIST))\n+\t      {\n+\t\ttree elt = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (for_stmt), i);\n+\t\tif (TREE_PURPOSE (elt) && TREE_VALUE (elt))\n+\t\t  {\n+\t\t    *pc = build_omp_clause (UNKNOWN_LOCATION,\n+\t\t\t\t\t    OMP_CLAUSE_FIRSTPRIVATE);\n+\t\t    OMP_CLAUSE_DECL (*pc) = TREE_VALUE (elt);\n+\t\t    pc = &OMP_CLAUSE_CHAIN (*pc);\n+\t\t  }\n+\t      }\n \t}\n       tree t = make_node (pass == 2 ? OMP_DISTRIBUTE : OMP_FOR);\n       tree *pc = &OMP_FOR_CLAUSES (t);\n@@ -11979,12 +12024,29 @@ gimplify_omp_loop (tree *expr_p, gimple_seq *pre_p)\n \t    pc = &OMP_CLAUSE_CHAIN (*pc);\n \t    break;\n \t  case OMP_CLAUSE_PRIVATE:\n+\t  case OMP_CLAUSE_FIRSTPRIVATE:\n \t    /* Only needed on innermost.  */\n \t    break;\n \t  case OMP_CLAUSE_LASTPRIVATE:\n+\t    if (OMP_CLAUSE_LASTPRIVATE_LOOP_IV (c) && pass != last)\n+\t      {\n+\t\t*pc = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\tOMP_CLAUSE_FIRSTPRIVATE);\n+\t\tOMP_CLAUSE_DECL (*pc) = OMP_CLAUSE_DECL (c);\n+\t\tlang_hooks.decls.omp_finish_clause (*pc, NULL);\n+\t\tpc = &OMP_CLAUSE_CHAIN (*pc);\n+\t      }\n \t    *pc = copy_node (c);\n \t    OMP_CLAUSE_LASTPRIVATE_STMT (*pc) = NULL_TREE;\n \t    TREE_TYPE (*pc) = unshare_expr (TREE_TYPE (c));\n+\t    if (OMP_CLAUSE_LASTPRIVATE_LOOP_IV (c))\n+\t      {\n+\t\tif (pass != last)\n+\t\t  OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (*pc) = 1;\n+\t\telse\n+\t\t  lang_hooks.decls.omp_finish_clause (*pc, NULL);\n+\t\tOMP_CLAUSE_LASTPRIVATE_LOOP_IV (*pc) = 0;\n+\t      }\n \t    pc = &OMP_CLAUSE_CHAIN (*pc);\n \t    break;\n \t  case OMP_CLAUSE_REDUCTION:"}, {"sha": "4a6ea0a1b71586411b0b96abbf548c0cd3d795cc", "filename": "gcc/omp-low.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -5139,8 +5139,17 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\tx = NULL;\n \t    do_private:\n \t      tree nx;\n-\t      nx = lang_hooks.decls.omp_clause_default_ctor\n-\t\t\t\t\t\t(c, unshare_expr (new_var), x);\n+\t      bool copy_ctor;\n+\t      copy_ctor = false;\n+\t      nx = unshare_expr (new_var);\n+\t      if (is_simd\n+\t\t  && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t\t  && OMP_CLAUSE_LASTPRIVATE_LOOP_IV (c))\n+\t\tcopy_ctor = true;\n+\t      if (copy_ctor)\n+\t\tnx = lang_hooks.decls.omp_clause_copy_ctor (c, nx, x);\n+\t      else\n+\t\tnx = lang_hooks.decls.omp_clause_default_ctor (c, nx, x);\n \t      if (is_simd)\n \t\t{\n \t\t  tree y = lang_hooks.decls.omp_clause_dtor (c, new_var);\n@@ -5165,8 +5174,16 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t}\n \n \t\t      if (nx)\n-\t\t\tx = lang_hooks.decls.omp_clause_default_ctor\n-\t\t\t\t\t\t(c, unshare_expr (ivar), x);\n+\t\t\t{\n+\t\t\t  tree iv = unshare_expr (ivar);\n+\t\t\t  if (copy_ctor)\n+\t\t\t    x = lang_hooks.decls.omp_clause_copy_ctor (c, iv,\n+\t\t\t\t\t\t\t\t       x);\n+\t\t\t  else\n+\t\t\t    x = lang_hooks.decls.omp_clause_default_ctor (c,\n+\t\t\t\t\t\t\t\t\t  iv,\n+\t\t\t\t\t\t\t\t\t  x);\n+\t\t\t}\n \t\t      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE__CONDTEMP_)\n \t\t\t{\n \t\t\t  x = build2 (MODIFY_EXPR, TREE_TYPE (ivar),\n@@ -6469,9 +6486,9 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *body_p,\n \n \t  x = NULL_TREE;\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n-\t      && OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV (c))\n+\t      && OMP_CLAUSE_LASTPRIVATE_LOOP_IV (c)\n+\t      && is_taskloop_ctx (ctx))\n \t    {\n-\t      gcc_checking_assert (is_taskloop_ctx (ctx));\n \t      tree ovar = maybe_lookup_decl_in_outer_ctx (var,\n \t\t\t\t\t\t\t  ctx->outer->outer);\n \t      if (is_global_var (ovar))"}, {"sha": "ce75b0cdc25bfa12e5985b1433bb0f21af248cdf", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -1517,10 +1517,11 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ(NODE) \\\n   (OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_init\n \n-/* True if a LASTPRIVATE clause is for a C++ class IV on taskloop construct\n-   (thus should be lastprivate on the outer taskloop and firstprivate on\n-   task).  */\n-#define OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV(NODE) \\\n+/* True if a LASTPRIVATE clause is for a C++ class IV on taskloop or\n+   loop construct (thus should be lastprivate on the outer taskloop and\n+   firstprivate on task for the taskloop construct and carefully handled\n+   for loop construct).  */\n+#define OMP_CLAUSE_LASTPRIVATE_LOOP_IV(NODE) \\\n   TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LASTPRIVATE))\n \n /* True if a LASTPRIVATE clause has CONDITIONAL: modifier.  */"}, {"sha": "0331c51c6394e2348282927c791050ee699742ba", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -1,3 +1,9 @@\n+2019-08-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.c++/loop-13.C: New test.\n+\t* testsuite/libgomp.c++/loop-14.C: New test.\n+\t* testsuite/libgomp.c++/loop-15.C: New test.\n+\n 2019-07-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/91301"}, {"sha": "663212c1f74d4a1cf49d8c3581255c7dfe70ffdc", "filename": "libgomp/testsuite/libgomp.c++/loop-13.C", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-13.C?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -0,0 +1,298 @@\n+// { dg-do run }\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+extern \"C\" void abort ();\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+template <typename T> I<T>::I () : p (0) {}\n+template <typename T> I<T>::~I () {}\n+template <typename T> I<T>::I (T *x) : p (x) {}\n+template <typename T> I<T>::I (const I &x) : p (x.p) {}\n+template <typename T> T &I<T>::operator * () { return *p; }\n+template <typename T> T *I<T>::operator -> () { return p; }\n+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n+  const I<T> &begin ();\n+  const I<T> &end ();\n+private:\n+  I<T> b, e;\n+};\n+\n+template <typename T> const I<T> &J<T>::begin () { return b; }\n+template <typename T> const I<T> &J<T>::end () { return e; }\n+\n+int results[2000];\n+\n+template <typename T>\n+static inline void\n+baz (I<T> &i)\n+{\n+  results[*i]++;\n+}\n+\n+void\n+f1 (const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel loop order(concurrent)\n+  for (I<int> i = x; i <= y; i += 6)\n+    baz (i);\n+}\n+\n+void\n+f2 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp loop private(i) bind(parallel)\n+  for (i = x; i < y - 1; i = 1 - 6 + 7 + i)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f3 (const I<int> &x, const I<int> &y)\n+{\n+#pragma omp loop bind(thread) order(concurrent)\n+  for (I<int> i = x; i <= y; i = i + 9 - 8)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f4 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel loop lastprivate(i)\n+  for (i = x + 2000 - 64; i > y + 10; --i)\n+    baz (i);\n+}\n+\n+void\n+f5 (const I<int> &x, const I<int> &y)\n+{\n+#pragma omp loop bind(teams)\n+  for (I<int> i = x + 2000 - 64; i > y + 10; i -= 10)\n+    baz (i);\n+}\n+\n+template <int N>\n+void\n+f6 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp teams loop order(concurrent)\n+  for (i = x + 2000 - 64; i > y + 10; i = i - 12 + 2)\n+    {\n+      I<int> j = i + N;\n+      baz (j);\n+    }\n+}\n+\n+template <int N>\n+void\n+f7 (I<int> i, const I<int> &x, const I<int> &y)\n+{\n+#pragma omp master\n+#pragma omp loop\n+  for (i = x - 10; i <= y + 10; i += N)\n+    baz (i);\n+}\n+\n+template <int N>\n+void\n+f8 (J<int> j)\n+{\n+  I<int> i;\n+#pragma omp parallel loop\n+  for (i = j.begin (); i <= j.end () + N; i += 2)\n+    baz (i);\n+}\n+\n+template <typename T, int N>\n+void\n+f9 (const I<T> &x, const I<T> &y)\n+{\n+  I<T> i;\n+#pragma omp loop bind(teams) private(i)\n+  for (i = x; i <= y; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T, int N>\n+void\n+f10 (const I<T> &x, const I<T> &y)\n+{\n+  I<T> i;\n+#pragma omp loop bind(thread) private(i)\n+  for (i = x; i > y; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f11 (const T &x, const T &y)\n+{\n+#pragma omp parallel\n+  {\n+#pragma omp loop\n+    for (T i = x; i <= y; i += 3)\n+      baz (i);\n+#pragma omp single\n+    {\n+      T j = y + 3;\n+      baz (j);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void\n+f12 (const T &x, const T &y)\n+{\n+  T i;\n+#pragma omp loop lastprivate(i) bind(thread)\n+  for (i = x; i > y; --i)\n+    baz (i);\n+}\n+\n+template <int N>\n+struct K\n+{\n+  template <typename T>\n+  static void\n+  f13 (const T &x, const T &y)\n+  {\n+    T i;\n+#pragma omp teams loop order(concurrent) bind(teams) lastprivate (i)\n+    for (i = x; i <= y + N; i += N)\n+      baz (i);\n+  }\n+};\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (results[i] != 1)\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\\\n+\tresults[i] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (results[i])\t\t\t\t\\\n+      abort ()\n+\n+int\n+main ()\n+{\n+  int a[2000];\n+  long b[2000];\n+  for (int i = 0; i < 2000; i++)\n+    {\n+      a[i] = i;\n+      b[i] = i;\n+    }\n+  f1 (&a[10], &a[1990]);\n+  check (i >= 10 && i <= 1990 && (i - 10) % 6 == 0);\n+  #pragma omp parallel\n+  f2 (&a[0], &a[1999]);\n+  check (i < 1998 && (i & 1) == 0);\n+  f3<char> (&a[20], &a[1837]);\n+  check (i >= 20 && i <= 1837);\n+  f4<int> (&a[0], &a[30]);\n+  check (i > 40 && i <= 2000 - 64);\n+  #pragma omp teams\n+  f5 (&a[0], &a[100]);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f6<-10> (&a[10], &a[110]);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  #pragma omp parallel num_threads(2)\n+  f7<6> (I<int> (), &a[12], &a[1800]);\n+  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);\n+  f8<121> (J<int> (&a[14], &a[1803]));\n+  check (i >= 14 && i <= 1924 && (i & 1) == 0);\n+  #pragma omp teams\n+  f9<int, 7> (&a[33], &a[1967]);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<int, -7> (&a[1939], &a[17]);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<I<int> > (&a[16], &a[1981]);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<I<int> > (&a[1761], &a[37]);\n+  check (i > 37 && i <= 1761);\n+  K<5>::f13<I<int> > (&a[1], &a[1935]);\n+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n+  #pragma omp teams\n+  f9<long, 7> (&b[33], &b[1967]);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<long, -7> (&b[1939], &b[17]);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<I<long> > (&b[16], &b[1981]);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<I<long> > (&b[1761], &b[37]);\n+  check (i > 37 && i <= 1761);\n+  K<5>::f13<I<long> > (&b[1], &b[1935]);\n+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n+}"}, {"sha": "191ab681b3c8f32e33e1d10b3eab41c2900db38e", "filename": "libgomp/testsuite/libgomp.c++/loop-14.C", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-14.C?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -0,0 +1,301 @@\n+// { dg-do run }\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+extern \"C\" void abort ();\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+template <typename T> I<T>::I () : p (0) {}\n+template <typename T> I<T>::~I () { p = (T *) 0; }\n+template <typename T> I<T>::I (T *x) : p (x) {}\n+template <typename T> I<T>::I (const I &x) : p (x.p) {}\n+template <typename T> T &I<T>::operator * () { return *p; }\n+template <typename T> T *I<T>::operator -> () { return p; }\n+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n+  const I<T> &begin ();\n+  const I<T> &end ();\n+private:\n+  I<T> b, e;\n+};\n+\n+template <typename T> const I<T> &J<T>::begin () { return b; }\n+template <typename T> const I<T> &J<T>::end () { return e; }\n+\n+int results[2000];\n+\n+template <typename T>\n+static inline void\n+baz (I<T> &i)\n+{\n+  results[*i]++;\n+}\n+\n+I<int>\n+f1 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel shared (i)\n+  {\n+  #pragma omp loop lastprivate (i) order(concurrent)\n+    for (i = x; i < y - 1; ++i)\n+      baz (i);\n+  #pragma omp single\n+    i += 3;\n+  }\n+  return I<int> (i);\n+}\n+\n+I<int>\n+f2 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel loop bind(parallel)\n+  for (i = x; i < y - 1; i = 1 - 6 + 7 + i)\n+    baz (i);\n+  return I<int> (i);\n+}\n+\n+template <typename T>\n+I<int>\n+f3 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp teams\n+  #pragma omp loop order(concurrent)\n+    for (i = x + 1000 - 64; i <= y - 10; i++)\n+      baz (i);\n+  return i;\n+}\n+\n+template <typename T>\n+I<int>\n+f4 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp teams loop lastprivate (i)\n+  for (i = x + 2000 - 64; i > y + 10; --i)\n+    baz (i);\n+  return I<int> (i);\n+}\n+\n+template <typename T>\n+I<int>\n+f5 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp loop lastprivate (i) bind(thread)\n+  for (i = x; i > y + T (6); i--)\n+    baz (i);\n+  return i;\n+}\n+\n+template <typename T>\n+I<int>\n+f6 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp loop bind(thread)\n+  for (i = x - T (7); i > y; i -= T (2))\n+    baz (i);\n+  return I<int> (i);\n+}\n+\n+template <int N>\n+I<int>\n+f7 (I<int> i, const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for lastprivate (i)\n+  for (i = x - 10; i <= y + 10; i += N)\n+    baz (i);\n+  return I<int> (i);\n+}\n+\n+template <int N>\n+I<int>\n+f8 (J<int> j)\n+{\n+  I<int> i;\n+#pragma omp parallel shared (i)\n+  #pragma omp loop lastprivate (i)\n+    for (i = j.begin (); i <= j.end () + N; i += 2)\n+      baz (i);\n+  return i;\n+}\n+\n+I<int> i9;\n+\n+template <long N>\n+I<int> &\n+f9 (J<int> j)\n+{\n+#pragma omp loop bind(parallel)\n+  for (i9 = j.begin () + N; i9 <= j.end () - N; i9 = i9 - N)\n+    baz (i9);\n+  return i9;\n+}\n+\n+template <typename T, int N>\n+I<T>\n+f10 (const I<T> &x, const I<T> &y)\n+{\n+  I<T> i;\n+#pragma omp parallel loop lastprivate (i)\n+  for (i = x; i > y; i = i + N)\n+    baz (i);\n+  return i;\n+}\n+\n+template <typename T, typename U>\n+T\n+f11 (T i, const T &x, const T &y)\n+{\n+  #pragma omp loop bind(thread)\n+  for (i = x + U (2); i <= y + U (1); i = U (2) + U (3) + i)\n+    baz (i);\n+  return T (i);\n+}\n+\n+template <typename T>\n+T\n+f12 (const T &x, const T &y)\n+{\n+  T i;\n+#pragma omp teams loop\n+  for (i = x; i > y; --i)\n+    baz (i);\n+  return i;\n+}\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (results[i] != 1)\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\\\n+\tresults[i] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (results[i])\t\t\t\t\\\n+      abort ()\n+\n+int\n+main ()\n+{\n+  int a[2000];\n+  long b[2000];\n+  for (int i = 0; i < 2000; i++)\n+    {\n+      a[i] = i;\n+      b[i] = i;\n+    }\n+  if (*f1 (&a[10], &a[1873]) != 1875)\n+    abort ();\n+  check (i >= 10 && i < 1872);\n+  if (*f2 (&a[0], &a[1998]) != 1998)\n+    abort ();\n+  check (i < 1997 && (i & 1) == 0);\n+  if (*f3<int> (&a[10], &a[1971]) != 1962)\n+    abort ();\n+  check (i >= 946 && i <= 1961);\n+  if (*f4<int> (&a[0], &a[30]) != 40)\n+    abort ();\n+  check (i > 40 && i <= 2000 - 64);\n+  if (*f5<short> (&a[1931], &a[17]) != 23)\n+    abort ();\n+  check (i > 23 && i <= 1931);\n+  if (*f6<long> (&a[1931], &a[17]) != 16)\n+    abort ();\n+  check (i > 17 && i <= 1924 && (i & 1) == 0);\n+  if (*f7<6> (I<int> (), &a[12], &a[1800]) != 1814)\n+    abort ();\n+  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);\n+  if (*f8<121> (J<int> (&a[14], &a[1803])) != 1926)\n+    abort ();\n+  check (i >= 14 && i <= 1924 && (i & 1) == 0);\n+  #pragma omp parallel\n+  if (*f9<-3L> (J<int> (&a[27], &a[1761])) != 1767)\n+    abort ();\n+  check (i >= 24 && i <= 1764 && (i % 3) == 0);\n+  if (*f10<int, -7> (&a[1939], &a[17]) != 14)\n+    abort ();\n+  check (i >= 21 && i <= 1939 && i % 7 == 0);\n+  if (*f11<I<int>, short> (I<int> (), &a[71], &a[1941]) != 1943)\n+    abort ();\n+  check (i >= 73 && i <= 1938 && (i - 73) % 5 == 0);\n+  if (*f12<I<int> > (&a[1761], &a[37]) != 37)\n+    abort ();\n+  check (i > 37 && i <= 1761);\n+  if (*f10<long, -7> (&b[1939], &b[17]) != 14)\n+    abort ();\n+  check (i >= 21 && i <= 1939 && i % 7 == 0);\n+  if (*f11<I<long>, short> (I<long> (), &b[71], &b[1941]) != 1943)\n+    abort ();\n+  check (i >= 73 && i <= 1938 && (i - 73) % 5 == 0);\n+  if (*f12<I<long> > (&b[1761], &b[37]) != 37)\n+    abort ();\n+  check (i > 37 && i <= 1761);\n+}"}, {"sha": "b523b9bd2f945eb01513a7263cd5adde5e670763", "filename": "libgomp/testsuite/libgomp.c++/loop-15.C", "status": "added", "additions": 417, "deletions": 0, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81ab49d0586fca0f3ee2f49c4581dd02508fcca/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-15.C?ref=d81ab49d0586fca0f3ee2f49c4581dd02508fcca", "patch": "@@ -0,0 +1,417 @@\n+// { dg-do run }\n+// { dg-additional-options \"-std=c++17\" }\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+extern \"C\" void abort ();\n+\n+namespace std {\n+  template<typename T> struct tuple_size;\n+  template<int, typename> struct tuple_element;\n+}\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+template <typename T> I<T>::I () : p (0) {}\n+template <typename T> I<T>::~I () {}\n+template <typename T> I<T>::I (T *x) : p (x) {}\n+template <typename T> I<T>::I (const I &x) : p (x.p) {}\n+template <typename T> T &I<T>::operator * () { return *p; }\n+template <typename T> T *I<T>::operator -> () { return p; }\n+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n+  const I<T> &begin ();\n+  const I<T> &end ();\n+private:\n+  I<T> b, e;\n+};\n+\n+template <typename T> const I<T> &J<T>::begin () { return b; }\n+template <typename T> const I<T> &J<T>::end () { return e; }\n+\n+template <typename T>\n+class K\n+{\n+public:\n+  K ();\n+  ~K ();\n+  template <int N> T &get () { if (N == 0) return c; else if (N == 1) return b; return a; }\n+  T a, b, c;\n+};\n+\n+template <typename T> K<T>::K () : a {}, b {}, c {} {}\n+template <typename T> K<T>::~K () {}\n+template <typename T> struct std::tuple_size<K<T>> { static constexpr int value = 3; };\n+template <typename T, int N> struct std::tuple_element<N, K<T>> { using type = T; };\n+\n+template <typename T>\n+class L\n+{\n+public:\n+  L ();\n+  ~L ();\n+  T a, b, c;\n+};\n+\n+template <typename T> L<T>::L () : a {}, b {}, c {} {}\n+template <typename T> L<T>::~L () {}\n+\n+int a[2000];\n+long b[40];\n+short c[50];\n+int d[1024];\n+K<int> e[1089];\n+L<int> f[1093];\n+int results[2000];\n+\n+template <typename T>\n+static inline void\n+baz (I<T> &i)\n+{\n+  results[*i]++;\n+}\n+\n+static inline void\n+baz (int i)\n+{\n+  results[i]++;\n+}\n+\n+void\n+f1 ()\n+{\n+#pragma omp parallel loop shared(a) default(none)\n+  for (auto i : a)\n+    baz (i);\n+}\n+\n+void\n+f2 ()\n+{\n+#pragma omp loop order(concurrent) bind(parallel)\n+  for (auto &i : a)\n+    if (&i != &a[i])\n+      abort ();\n+    else\n+      baz (i);\n+}\n+\n+void\n+f3 ()\n+{\n+#pragma omp teams loop collapse(3) default(none) shared(b, c)\n+  for (auto &i : b)\n+    for (int j = 9; j < 10; j++)\n+      for (auto k : c)\n+\tif (&i != &b[i] || i < 0 || i >= 40 || j != 9 || k < 0 || k >= 50)\n+\t  abort ();\n+\telse\n+\t  baz (i * 50 + k);\n+}\n+\n+void\n+f4 (J<int> j)\n+{\n+#pragma omp loop bind(teams)\n+  for (auto &i : j)\n+    if (&i != &a[i])\n+      abort ();\n+    else\n+      baz (i);\n+}\n+\n+void\n+f5 ()\n+{\n+#pragma omp loop bind(thread)\n+  for (auto i : d)\n+    results[i % 1024] += 2 * ((unsigned) i >> 10) + 1;\n+}\n+\n+void\n+f6 (J<K<int>> j)\n+{\n+#pragma omp loop bind(parallel)\n+  for (auto & [k, l, m] : j)\n+    if (&k != &e[m].c || &l != &e[m].b || &m != &e[m].a || k != m * 3 || l != m * 2)\n+      abort ();\n+    else\n+      baz (m);\n+}\n+\n+void\n+f7 (J<L<int>> j)\n+{\n+#pragma omp parallel loop default(none) shared(j, f)\n+  for (auto & [k, l, m] : j)\n+    if (&k != &f[k].a || &l != &f[k].b || &m != &f[k].c || l != k * 4 || m != k * 5)\n+      abort ();\n+    else\n+      baz (k);\n+}\n+\n+void\n+f8 (J<K<int>> j)\n+{\n+#pragma omp parallel loop default(none) shared(j)\n+  for (auto [k, l, m] : j)\n+    if (k != m * 3 || l != m * 2)\n+      abort ();\n+    else\n+      baz (m);\n+}\n+\n+void\n+f9 (J<L<int>> j)\n+{\n+#pragma omp teams loop default(none) shared(j)\n+  for (auto [k, l, m] : j)\n+    if (l != k * 4 || m != k * 5)\n+      abort ();\n+    else\n+      baz (k);\n+}\n+\n+template <int N>\n+void\n+f10 ()\n+{\n+#pragma omp loop bind(teams)\n+  for (auto i : a)\n+    baz (i);\n+}\n+\n+template <int N>\n+void\n+f11 ()\n+{\n+#pragma omp loop bind(thread)\n+  for (auto &i : a)\n+    if (&i != &a[i])\n+      abort ();\n+    else\n+      baz (i);\n+}\n+\n+template <int N>\n+void\n+f12 ()\n+{\n+#pragma omp parallel loop collapse(3) default(none) shared(a, b, c) bind(parallel)\n+  for (auto &i : b)\n+    for (I<int> j = I<int> (&a[9]); j < I<int> (&a[10]); j++)\n+      for (auto k : c)\n+\tif (&i != &b[i] || i < 0 || i >= 40 || *j != 9 || k < 0 || k >= 50)\n+\t  abort ();\n+\telse\n+\t  baz (i * 50 + k);\n+}\n+\n+template <typename T>\n+void\n+f13 (J<T> j)\n+{\n+#pragma omp loop bind(thread)\n+  for (auto &i : j)\n+    if (&i != &a[i])\n+      abort ();\n+    else\n+      baz (i);\n+}\n+\n+template <int N>\n+void\n+f14 ()\n+{\n+#pragma omp parallel loop default(none) shared(d, results)\n+  for (auto i : d)\n+    results[i % N] += 2 * ((unsigned) i >> 10) + 1;\n+}\n+\n+template <typename T>\n+void\n+f15 (J<K<T>> j)\n+{\n+#pragma omp parallel loop default(none) shared(j, e) bind(parallel)\n+  for (auto & [k, l, m] : j)\n+    if (&k != &e[m].c || &l != &e[m].b || &m != &e[m].a || k != m * 3 || l != m * 2)\n+      abort ();\n+    else\n+      baz (m);\n+}\n+\n+template <typename T>\n+void\n+f16 (J<L<T>> j)\n+{\n+#pragma omp loop bind(parallel)\n+  for (auto & [k, l, m] : j)\n+    if (&k != &f[k].a || &l != &f[k].b || &m != &f[k].c || l != k * 4 || m != k * 5)\n+      abort ();\n+    else\n+      baz (k);\n+}\n+\n+template <int N>\n+void\n+f17 (J<K<int>> j)\n+{\n+#pragma omp parallel loop default(none) shared(j)\n+  for (auto [k, l, m] : j)\n+    if (k != m * 3 || l != m * 2)\n+      abort ();\n+    else\n+      baz (m);\n+}\n+\n+template <int N>\n+void\n+f18 (J<L<int>> j)\n+{\n+#pragma omp teams loop default(none) shared(j)\n+  for (auto [k, l, m] : j)\n+    if (l != k * 4 || m != k * 5)\n+      abort ();\n+    else\n+      baz (k);\n+}\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (results[i] != 1)\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\\\n+\tresults[i] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (results[i])\t\t\t\t\\\n+      abort ()\n+\n+int\n+main ()\n+{\n+  for (int i = 0; i < 2000; i++)\n+    a[i] = i;\n+  for (int i = 0; i < 40; i++)\n+    b[i] = i;\n+  for (int i = 0; i < 50; i++)\n+    c[i] = i;\n+  for (int i = 0; i < 1024; i++)\n+    d[i] = i;\n+  for (int i = 0; i < 1089; i++)\n+    {\n+      e[i].a = i;\n+      e[i].b = 2 * i;\n+      e[i].c = 3 * i;\n+    }\n+  for (int i = 0; i < 1093; i++)\n+    {\n+      f[i].a = i;\n+      f[i].b = 4 * i;\n+      f[i].c = 5 * i;\n+    }\n+  f1 ();\n+  check (1);\n+  #pragma omp parallel\n+  f2 ();\n+  check (1);\n+  f3 ();\n+  check (1);\n+  #pragma omp teams\n+  f4 (J<int> (&a[14], &a[1803]));\n+  check (i >= 14 && i < 1803);\n+  f5 ();\n+  check (i >= 0 && i < 1024);\n+  #pragma omp parallel\n+  f6 (J<K<int>> (&e[19], &e[1029]));\n+  check (i >= 19 && i < 1029);\n+  f7 (J<L<int>> (&f[15], &f[1091]));\n+  check (i >= 15 && i < 1091);\n+  f8 (J<K<int>> (&e[27], &e[1037]));\n+  check (i >= 27 && i < 1037);\n+  f9 (J<L<int>> (&f[1], &f[1012]));\n+  check (i >= 1 && i < 1012);\n+  #pragma omp teams\n+  f10 <0> ();\n+  check (1);\n+  f11 <1> ();\n+  check (1);\n+  f12 <2> ();\n+  check (1);\n+  f13 (J<int> (&a[24], &a[1703]));\n+  check (i >= 24 && i < 1703);\n+  f14 <1024> ();\n+  check (i >= 0 && i < 1024);\n+  f15 (J<K<int>> (&e[39], &e[929]));\n+  check (i >= 39 && i < 929);\n+  #pragma omp parallel\n+  f16 (J<L<int>> (&f[17], &f[1071]));\n+  check (i >= 17 && i < 1071);\n+  f17 <3> (J<K<int>> (&e[7], &e[1017]));\n+  check (i >= 7 && i < 1017);\n+  f18 <5> (J<L<int>> (&f[121], &f[1010]));\n+  check (i >= 121 && i < 1010);\n+}"}]}