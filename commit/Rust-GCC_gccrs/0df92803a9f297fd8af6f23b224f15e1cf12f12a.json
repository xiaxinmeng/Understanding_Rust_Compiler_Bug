{"sha": "0df92803a9f297fd8af6f23b224f15e1cf12f12a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRmOTI4MDNhOWYyOTdmZDhhZjZmMjNiMjI0ZjE1ZTFjZjEyZjEyYQ==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2018-09-30T20:03:14Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2018-09-30T20:03:14Z"}, "message": "re PR rtl-optimization/86939 (IRA incorrectly creates an interference between a pseudo register and a hard register)\n\ngcc/\n\tPR rtl-optimization/86939\n\t* ira-lives.c (make_hard_regno_born): Rename from this...\n\t(make_hard_regno_live): ... to this.  Remove update to conflict\n\tinformation.  Update function comment.\n\t(make_hard_regno_dead): Add conflict information update.  Update\n\tfunction comment.\n\t(make_object_born): Rename from this...\n\t(make_object_live): ... to this.  Remove update to conflict information.\n\tUpdate function comment.\n\t(make_object_dead):  Add conflict information update.  Update function\n\tcomment.\n\t(mark_pseudo_regno_live): Call make_object_live.\n\t(mark_pseudo_regno_subword_live): Likewise.\n\t(mark_hard_reg_dead): Update function comment.\n\t(mark_hard_reg_live): Call make_hard_regno_live.\n\t(process_bb_node_lives): Likewise.\n\t* lra-lives.c (make_hard_regno_born): Rename from this...\n\t(make_hard_regno_live): ... to this.  Remove update to conflict\n\tinformation.  Remove now uneeded check_pic_pseudo_p argument.\n\tUpdate function comment.\n\t(make_hard_regno_dead): Add check_pic_pseudo_p argument and add update\n\tto conflict information.  Update function comment.\n\t(mark_pseudo_live): Remove update to conflict information.  Update\n\tfunction comment.\n\t(mark_pseudo_dead): Add conflict information update.\n\t(mark_regno_live): Call make_hard_regno_live.\n\t(mark_regno_dead): Call make_hard_regno_dead with new arguement.\n\t(process_bb_lives): Call make_hard_regno_live and make_hard_regno_dead.\n\nFrom-SVN: r264726", "tree": {"sha": "b6dae223a430f5e7fecd8cf91c5602da541d0401", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6dae223a430f5e7fecd8cf91c5602da541d0401"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0df92803a9f297fd8af6f23b224f15e1cf12f12a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0df92803a9f297fd8af6f23b224f15e1cf12f12a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0df92803a9f297fd8af6f23b224f15e1cf12f12a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0df92803a9f297fd8af6f23b224f15e1cf12f12a/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a086078b8f7ee2580e55afc03026acf63bfb9605", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a086078b8f7ee2580e55afc03026acf63bfb9605", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a086078b8f7ee2580e55afc03026acf63bfb9605"}], "stats": {"total": 163, "additions": 97, "deletions": 66}, "files": [{"sha": "f6b8c37c3e78f5293d522f9ee9828d22d828eab3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0df92803a9f297fd8af6f23b224f15e1cf12f12a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0df92803a9f297fd8af6f23b224f15e1cf12f12a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0df92803a9f297fd8af6f23b224f15e1cf12f12a", "patch": "@@ -1,3 +1,34 @@\n+2018-09-30  Peter Bergner  <bergner@linux.ibm.com>\n+\n+\tPR rtl-optimization/86939\n+\t* ira-lives.c (make_hard_regno_born): Rename from this...\n+\t(make_hard_regno_live): ... to this.  Remove update to conflict\n+\tinformation.  Update function comment.\n+\t(make_hard_regno_dead): Add conflict information update.  Update\n+\tfunction comment.\n+\t(make_object_born): Rename from this...\n+\t(make_object_live): ... to this.  Remove update to conflict information.\n+\tUpdate function comment.\n+\t(make_object_dead):  Add conflict information update.  Update function\n+\tcomment.\n+\t(mark_pseudo_regno_live): Call make_object_live.\n+\t(mark_pseudo_regno_subword_live): Likewise.\n+\t(mark_hard_reg_dead): Update function comment.\n+\t(mark_hard_reg_live): Call make_hard_regno_live.\n+\t(process_bb_node_lives): Likewise.\n+\t* lra-lives.c (make_hard_regno_born): Rename from this...\n+\t(make_hard_regno_live): ... to this.  Remove update to conflict\n+\tinformation.  Remove now uneeded check_pic_pseudo_p argument.\n+\tUpdate function comment.\n+\t(make_hard_regno_dead): Add check_pic_pseudo_p argument and add update\n+\tto conflict information.  Update function comment.\n+\t(mark_pseudo_live): Remove update to conflict information.  Update\n+\tfunction comment.\n+\t(mark_pseudo_dead): Add conflict information update.\n+\t(mark_regno_live): Call make_hard_regno_live.\n+\t(mark_regno_dead): Call make_hard_regno_dead with new arguement.\n+\t(process_bb_lives): Call make_hard_regno_live and make_hard_regno_dead.\n+\n 2018-09-29  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/87370"}, {"sha": "ab8ad4a058925603983aa1ba8d6cebb30146f62f", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0df92803a9f297fd8af6f23b224f15e1cf12f12a/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0df92803a9f297fd8af6f23b224f15e1cf12f12a/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=0df92803a9f297fd8af6f23b224f15e1cf12f12a", "patch": "@@ -84,43 +84,37 @@ static int *allocno_saved_at_call;\n    supplemental to recog_data.  */\n static alternative_mask preferred_alternatives;\n \n-/* Record the birth of hard register REGNO, updating hard_regs_live and\n-   hard reg conflict information for living allocnos.  */\n+/* Record hard register REGNO as now being live.  */\n static void\n-make_hard_regno_born (int regno)\n+make_hard_regno_live (int regno)\n {\n-  unsigned int i;\n-\n   SET_HARD_REG_BIT (hard_regs_live, regno);\n+}\n+\n+/* Process the definition of hard register REGNO.  This updates\n+   hard_regs_live and hard reg conflict information for living allocnos.  */\n+static void\n+make_hard_regno_dead (int regno)\n+{\n+  unsigned int i;\n   EXECUTE_IF_SET_IN_SPARSESET (objects_live, i)\n     {\n       ira_object_t obj = ira_object_id_map[i];\n \n       SET_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj), regno);\n       SET_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), regno);\n     }\n-}\n-\n-/* Process the death of hard register REGNO.  This updates\n-   hard_regs_live.  */\n-static void\n-make_hard_regno_dead (int regno)\n-{\n   CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n }\n \n-/* Record the birth of object OBJ.  Set a bit for it in objects_live,\n-   start a new live range for it if necessary and update hard register\n-   conflicts.  */\n+/* Record object OBJ as now being live.  Set a bit for it in objects_live,\n+   and start a new live range for it if necessary.  */\n static void\n-make_object_born (ira_object_t obj)\n+make_object_live (ira_object_t obj)\n {\n-  live_range_t lr = OBJECT_LIVE_RANGES (obj);\n-\n   sparseset_set_bit (objects_live, OBJECT_CONFLICT_ID (obj));\n-  IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), hard_regs_live);\n-  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), hard_regs_live);\n \n+  live_range_t lr = OBJECT_LIVE_RANGES (obj);\n   if (lr == NULL\n       || (lr->finish != curr_point && lr->finish + 1 != curr_point))\n     ira_add_live_range_to_object (obj, curr_point, -1);\n@@ -154,14 +148,18 @@ update_allocno_pressure_excess_length (ira_object_t obj)\n     }\n }\n \n-/* Process the death of object OBJ, which is associated with allocno\n-   A.  This finishes the current live range for it.  */\n+/* Process the definition of object OBJ, which is associated with allocno A.\n+   This finishes the current live range for it.  */\n static void\n make_object_dead (ira_object_t obj)\n {\n   live_range_t lr;\n \n   sparseset_clear_bit (objects_live, OBJECT_CONFLICT_ID (obj));\n+\n+  IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), hard_regs_live);\n+  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), hard_regs_live);\n+\n   lr = OBJECT_LIVE_RANGES (obj);\n   ira_assert (lr != NULL);\n   lr->finish = curr_point;\n@@ -290,7 +288,7 @@ mark_pseudo_regno_live (int regno)\n \tcontinue;\n \n       inc_register_pressure (pclass, nregs);\n-      make_object_born (obj);\n+      make_object_live (obj);\n     }\n }\n \n@@ -327,7 +325,7 @@ mark_pseudo_regno_subword_live (int regno, int subword)\n     return;\n \n   inc_register_pressure (pclass, 1);\n-  make_object_born (obj);\n+  make_object_live (obj);\n }\n \n /* Mark the register REG as live.  Store a 1 in hard_regs_live for\n@@ -351,7 +349,7 @@ mark_hard_reg_live (rtx reg)\n \t      aclass = ira_hard_regno_allocno_class[regno];\n \t      pclass = ira_pressure_class_translate[aclass];\n \t      inc_register_pressure (pclass, 1);\n-\t      make_hard_regno_born (regno);\n+\t      make_hard_regno_live (regno);\n \t    }\n \t  regno++;\n \t}\n@@ -457,8 +455,8 @@ mark_pseudo_regno_subword_dead (int regno, int subword)\n   make_object_dead (obj);\n }\n \n-/* Mark the hard register REG as dead.  Store a 0 in hard_regs_live for the\n-   register.  */\n+/* Process the definition of hard register REG.  This updates hard_regs_live\n+   and hard reg conflict information for living allocnos.  */\n static void\n mark_hard_reg_dead (rtx reg)\n {\n@@ -1298,7 +1296,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t    unsigned int regno = EH_RETURN_DATA_REGNO (j);\n \t    if (regno == INVALID_REGNUM)\n \t      break;\n-\t    make_hard_regno_born (regno);\n+\t    make_hard_regno_live (regno);\n \t  }\n \n       /* Allocnos can't go in stack regs at the start of a basic block\n@@ -1317,7 +1315,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t      ALLOCNO_TOTAL_NO_STACK_REG_P (a) = true;\n \t    }\n \t  for (px = FIRST_STACK_REG; px <= LAST_STACK_REG; px++)\n-\t    make_hard_regno_born (px);\n+\t    make_hard_regno_live (px);\n #endif\n \t  /* No need to record conflicts for call clobbered regs if we\n \t     have nonlocal labels around, as we don't ever try to\n@@ -1340,7 +1338,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t      && REGNO (pic_offset_table_rtx) >= FIRST_PSEUDO_REGISTER)\n #endif\n \t\t  )\n-\t\tmake_hard_regno_born (px);\n+\t\tmake_hard_regno_live (px);\n \t}\n \n       EXECUTE_IF_SET_IN_SPARSESET (objects_live, i)"}, {"sha": "b41df60eb613759eeeec66f677dcfdd227c75e35", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0df92803a9f297fd8af6f23b224f15e1cf12f12a/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0df92803a9f297fd8af6f23b224f15e1cf12f12a/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=0df92803a9f297fd8af6f23b224f15e1cf12f12a", "patch": "@@ -223,42 +223,41 @@ lra_intersected_live_ranges_p (lra_live_range_t r1, lra_live_range_t r2)\n /* The corresponding bitmaps of BB currently being processed.  */\n static bitmap bb_killed_pseudos, bb_gen_pseudos;\n \n-/* The function processing birth of hard register REGNO.  It updates\n-   living hard regs, START_LIVING, and conflict hard regs for living\n-   pseudos.  Conflict hard regs for the pic pseudo is not updated if\n-   REGNO is REAL_PIC_OFFSET_TABLE_REGNUM and CHECK_PIC_PSEUDO_P is\n-   true.  */\n+/* Record hard register REGNO as now being live.  It updates\n+   living hard regs and START_LIVING.  */\n static void\n-make_hard_regno_born (int regno, bool check_pic_pseudo_p ATTRIBUTE_UNUSED)\n+make_hard_regno_live (int regno)\n {\n-  unsigned int i;\n-\n   lra_assert (regno < FIRST_PSEUDO_REGISTER);\n   if (TEST_HARD_REG_BIT (hard_regs_live, regno))\n     return;\n   SET_HARD_REG_BIT (hard_regs_live, regno);\n   sparseset_set_bit (start_living, regno);\n-  EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, i)\n-#ifdef REAL_PIC_OFFSET_TABLE_REGNUM\n-    if (! check_pic_pseudo_p\n-\t|| regno != REAL_PIC_OFFSET_TABLE_REGNUM\n-\t|| pic_offset_table_rtx == NULL\n-\t|| i != REGNO (pic_offset_table_rtx))\n-#endif\n-      SET_HARD_REG_BIT (lra_reg_info[i].conflict_hard_regs, regno);\n   if (fixed_regs[regno] || TEST_HARD_REG_BIT (hard_regs_spilled_into, regno))\n     bitmap_set_bit (bb_gen_pseudos, regno);\n }\n \n-/* Process the death of hard register REGNO.  This updates\n-   hard_regs_live and START_DYING.  */\n+/* Process the definition of hard register REGNO.  This updates\n+   hard_regs_live, START_DYING and conflict hard regs for living\n+   pseudos.  Conflict hard regs for the pic pseudo is not updated if\n+   REGNO is REAL_PIC_OFFSET_TABLE_REGNUM and CHECK_PIC_PSEUDO_P is\n+   true.  */\n static void\n-make_hard_regno_dead (int regno)\n+make_hard_regno_dead (int regno, bool check_pic_pseudo_p ATTRIBUTE_UNUSED)\n {\n   lra_assert (regno < FIRST_PSEUDO_REGISTER);\n   if (! TEST_HARD_REG_BIT (hard_regs_live, regno))\n     return;\n   sparseset_set_bit (start_dying, regno);\n+  unsigned int i;\n+  EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, i)\n+#ifdef REAL_PIC_OFFSET_TABLE_REGNUM\n+    if (! check_pic_pseudo_p\n+\t|| regno != REAL_PIC_OFFSET_TABLE_REGNUM\n+\t|| pic_offset_table_rtx == NULL\n+\t|| i != REGNO (pic_offset_table_rtx))\n+#endif\n+      SET_HARD_REG_BIT (lra_reg_info[i].conflict_hard_regs, regno);\n   CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n   if (fixed_regs[regno] || TEST_HARD_REG_BIT (hard_regs_spilled_into, regno))\n     {\n@@ -267,9 +266,9 @@ make_hard_regno_dead (int regno)\n     }\n }\n \n-/* Mark pseudo REGNO as living at program point POINT, update conflicting\n-   hard registers of the pseudo and START_LIVING, and start a new live\n-   range for the pseudo corresponding to REGNO if it is necessary.  */\n+/* Mark pseudo REGNO as living at program point POINT, update START_LIVING\n+   and start a new live range for the pseudo corresponding to REGNO if it\n+   is necessary.  */\n static void\n mark_pseudo_live (int regno, int point)\n {\n@@ -278,7 +277,6 @@ mark_pseudo_live (int regno, int point)\n   lra_assert (regno >= FIRST_PSEUDO_REGISTER);\n   lra_assert (! sparseset_bit_p (pseudos_live, regno));\n   sparseset_set_bit (pseudos_live, regno);\n-  IOR_HARD_REG_SET (lra_reg_info[regno].conflict_hard_regs, hard_regs_live);\n \n   if ((complete_info_p || lra_get_regno_hard_regno (regno) < 0)\n       && ((p = lra_reg_info[regno].live_ranges) == NULL\n@@ -301,6 +299,9 @@ mark_pseudo_dead (int regno, int point)\n   lra_assert (sparseset_bit_p (pseudos_live, regno));\n   sparseset_clear_bit (pseudos_live, regno);\n   sparseset_set_bit (start_dying, regno);\n+\n+  IOR_HARD_REG_SET (lra_reg_info[regno].conflict_hard_regs, hard_regs_live);\n+\n   if (complete_info_p || lra_get_regno_hard_regno (regno) < 0)\n     {\n       p = lra_reg_info[regno].live_ranges;\n@@ -322,7 +323,7 @@ mark_regno_live (int regno, machine_mode mode, int point)\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n       for (last = end_hard_regno (mode, regno); regno < last; regno++)\n-\tmake_hard_regno_born (regno, false);\n+\tmake_hard_regno_live (regno);\n     }\n   else\n     {\n@@ -349,7 +350,7 @@ mark_regno_dead (int regno, machine_mode mode, int point)\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n       for (last = end_hard_regno (mode, regno); regno < last; regno++)\n-\tmake_hard_regno_dead (regno);\n+\tmake_hard_regno_dead (regno, false);\n     }\n   else\n     {\n@@ -834,13 +835,13 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type != OP_IN)\n-\t  make_hard_regno_born (reg->regno, false);\n+\t  make_hard_regno_live (reg->regno);\n \n       if (curr_id->arg_hard_regs != NULL)\n \tfor (i = 0; (regno = curr_id->arg_hard_regs[i]) >= 0; i++)\n \t  if (regno >= FIRST_PSEUDO_REGISTER)\n \t    /* It is a clobber.  */\n-\t    make_hard_regno_born (regno - FIRST_PSEUDO_REGISTER, false);\n+\t    make_hard_regno_live (regno - FIRST_PSEUDO_REGISTER);\n \n       sparseset_copy (unused_set, start_living);\n \n@@ -857,13 +858,14 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_OUT\n \t    && ! reg_early_clobber_p (reg, n_alt) && ! reg->subreg_p)\n-\t  make_hard_regno_dead (reg->regno);\n+\t  make_hard_regno_dead (reg->regno, false);\n \n       if (curr_id->arg_hard_regs != NULL)\n \tfor (i = 0; (regno = curr_id->arg_hard_regs[i]) >= 0; i++)\n \t  if (regno >= FIRST_PSEUDO_REGISTER)\n-\t    /* It is a clobber.  */\n-\t    make_hard_regno_dead (regno - FIRST_PSEUDO_REGISTER);\n+\t    /* It is a clobber.  Don't create conflict of used\n+\t       REAL_PIC_OFFSET_TABLE_REGNUM and the pic pseudo.  */\n+\t    make_hard_regno_dead (regno - FIRST_PSEUDO_REGISTER, true);\n \n       if (call_p)\n \t{\n@@ -920,14 +922,14 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_IN)\n-\t  make_hard_regno_born (reg->regno, false);\n+\t  make_hard_regno_live (reg->regno);\n \n       if (curr_id->arg_hard_regs != NULL)\n \t/* Make argument hard registers live.  Don't create conflict\n \t   of used REAL_PIC_OFFSET_TABLE_REGNUM and the pic pseudo.  */\n \tfor (i = 0; (regno = curr_id->arg_hard_regs[i]) >= 0; i++)\n \t  if (regno < FIRST_PSEUDO_REGISTER)\n-\t    make_hard_regno_born (regno, true);\n+\t    make_hard_regno_live (regno);\n \n       sparseset_and_compl (dead_set, start_living, start_dying);\n \n@@ -952,7 +954,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t      if (reg2->type != OP_OUT && reg2->regno == reg->regno)\n \t\tbreak;\n \t    if (reg2 == NULL)\n-\t      make_hard_regno_dead (reg->regno);\n+\t      make_hard_regno_dead (reg->regno, false);\n \t  }\n \n       if (need_curr_point_incr)\n@@ -995,7 +997,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n \tif (regno == INVALID_REGNUM)\n \t  break;\n-\tmake_hard_regno_born (regno, false);\n+\tmake_hard_regno_live (regno);\n       }\n \n   /* Pseudos can't go in stack regs at the start of a basic block that\n@@ -1009,7 +1011,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, px)\n \tlra_reg_info[px].no_stack_p = true;\n       for (px = FIRST_STACK_REG; px <= LAST_STACK_REG; px++)\n-\tmake_hard_regno_born (px, false);\n+\tmake_hard_regno_live (px);\n #endif\n       /* No need to record conflicts for call clobbered regs if we\n \t have nonlocal labels around, as we don't ever try to\n@@ -1029,7 +1031,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t\t  && REGNO (pic_offset_table_rtx) >= FIRST_PSEUDO_REGISTER)\n #endif\n \t      )\n-\t    make_hard_regno_born (px, false);\n+\t    make_hard_regno_live (px);\n     }\n \n   bool live_change_p = false;"}]}