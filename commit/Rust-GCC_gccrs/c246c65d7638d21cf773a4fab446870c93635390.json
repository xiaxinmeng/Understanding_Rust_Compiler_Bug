{"sha": "c246c65d7638d21cf773a4fab446870c93635390", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI0NmM2NWQ3NjM4ZDIxY2Y3NzNhNGZhYjQ0Njg3MGM5MzYzNTM5MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-12-04T20:13:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-12-04T20:13:01Z"}, "message": "PR c++/8461, c++/8625\n\n        PR c++/8461, c++/8625\n        * integrate.c (copy_decl_for_inlining): Handle explicit invisible\n        references.\n        * tree-inline.c (initialize_inlined_parameters): Likewise.\n\n2002-12-03  Jason Merrill  <jason@redhat.com>\n\n        PR c++/8461, c++/8625\n        * call.c (convert_for_arg_passing): Don't mess with error_mark_node.\n        (cp_convert_parm_for_inlining): Remove.\n        * cp-lang.c (LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING):\n        Remove.\n        * cp-tree.h (ADDR_IS_INVISIREF): Remove.\n        * except.c (stabilize_throw_expr): Remove ADDR_IS_INVISIREF code.\n\nFrom-SVN: r59827", "tree": {"sha": "b67e00c5506ddc2ca24b4895249a6aa8ba5a0347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b67e00c5506ddc2ca24b4895249a6aa8ba5a0347"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c246c65d7638d21cf773a4fab446870c93635390", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c246c65d7638d21cf773a4fab446870c93635390", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c246c65d7638d21cf773a4fab446870c93635390", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c246c65d7638d21cf773a4fab446870c93635390/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae598ab989bc96176b5218df66234a006acdf52e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae598ab989bc96176b5218df66234a006acdf52e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae598ab989bc96176b5218df66234a006acdf52e"}], "stats": {"total": 165, "additions": 106, "deletions": 59}, "files": [{"sha": "76609c3ce427595751fb4eaf541d6f1437be4baa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c246c65d7638d21cf773a4fab446870c93635390/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c246c65d7638d21cf773a4fab446870c93635390/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c246c65d7638d21cf773a4fab446870c93635390", "patch": "@@ -1,3 +1,12 @@\n+2002-12-04  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/8461, c++/8625\n+\t* integrate.c (copy_decl_for_inlining): Handle explicit invisible\n+\treferences.\n+\t* tree-inline.c (initialize_inlined_parameters): Likewise.\n+\n+\t* tree.c (variably_modified_type_p): Just return an error_mark_node.\n+\n 2002-12-04  Chris Demetriou  <cgd@broadcom.com>\n \n \t* config/mips/mips.md (get_fnaddr): Avoid placing an \"la\""}, {"sha": "60789ee32d46dd0e8e6dfe2ccfacec917eb1177c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c246c65d7638d21cf773a4fab446870c93635390", "patch": "@@ -6,6 +6,18 @@\n \n 2002-12-03  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/8674\n+\t* call.c (build_over_call): Check specifically for TARGET_EXPR\n+\twhen eliding.\n+\n+\tPR c++/8461, c++/8625\n+\t* call.c (convert_for_arg_passing): Don't mess with error_mark_node.\n+\t(cp_convert_parm_for_inlining): Remove.\n+\t* cp-lang.c (LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING): \n+\tRemove.\n+\t* cp-tree.h (ADDR_IS_INVISIREF): Remove.\n+\t* except.c (stabilize_throw_expr): Remove ADDR_IS_INVISIREF code.\n+\n \t* call.c (build_user_type_conversion_1): Don't set ICS_BAD_FLAG on\n \tan ambiguous conversion.\n "}, {"sha": "072fbe6451528bc15191603d94fa02e4d8255e41", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c246c65d7638d21cf773a4fab446870c93635390", "patch": "@@ -4276,37 +4276,18 @@ tree\n convert_for_arg_passing (type, val)\n      tree type, val;\n {\n+  if (val == error_mark_node)\n+    ;\n   /* Pass classes with copy ctors by invisible reference.  */\n-  if (TREE_ADDRESSABLE (type))\n-    {\n-      val = build1 (ADDR_EXPR, build_reference_type (type), val);\n-      ADDR_IS_INVISIREF (val) = 1;\n-    }\n+  else if (TREE_ADDRESSABLE (type))\n+    val = build1 (ADDR_EXPR, build_reference_type (type), val);\n   else if (PROMOTE_PROTOTYPES\n \t   && INTEGRAL_TYPE_P (type)\n \t   && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n     val = default_conversion (val);\n   return val;\n }\n \n-/* Convert VALUE for assignment into inlined parameter PARM.  */\n-\n-tree\n-cp_convert_parm_for_inlining (parm, value, fn)\n-     tree parm, value;\n-     tree fn ATTRIBUTE_UNUSED;\n-{\n-  /* When inlining, we don't need to mess with invisible references, so\n-     undo the ADDR_EXPR.  */\n-  if (TREE_ADDRESSABLE (TREE_TYPE (parm)))\n-    {\n-      value = TREE_OPERAND (value, 0);\n-      if (TREE_CODE (value) != TARGET_EXPR)\n-\tabort ();\n-    }\n-  return value;\n-}\n-\n /* Subroutine of the various build_*_call functions.  Overload resolution\n    has chosen a winning candidate CAND; build up a CALL_EXPR accordingly.\n    ARGS is a TREE_LIST of the unconverted arguments to the call.  FLAGS is a\n@@ -4477,12 +4458,12 @@ build_over_call (cand, args, flags)\n          temp or an INIT_EXPR otherwise.  */\n       if (integer_zerop (TREE_VALUE (args)))\n \t{\n-\t  if (! real_lvalue_p (arg))\n+\t  if (TREE_CODE (arg) == TARGET_EXPR)\n \t    return arg;\n \t  else if (TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n \t    return build_target_expr_with_type (arg, DECL_CONTEXT (fn));\n \t}\n-      else if (!real_lvalue_p (arg)\n+      else if (TREE_CODE (arg) == TARGET_EXPR\n \t       || TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n \t{\n \t  tree address;"}, {"sha": "a7f2d85966ed1c9ef3ed436cf4f7a9786183c9c7", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=c246c65d7638d21cf773a4fab446870c93635390", "patch": "@@ -122,9 +122,6 @@ static bool cp_var_mod_type_p PARAMS ((tree));\n #undef LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING\n #define LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING \\\n   cp_copy_res_decl_for_inlining\n-#undef LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING\n-#define LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n-  cp_convert_parm_for_inlining\n #undef LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P\n #define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P anon_aggr_type_p\n #undef LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P"}, {"sha": "4c0efd20e049812df5407d85d31a8d60a97a3a1a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c246c65d7638d21cf773a4fab446870c93635390", "patch": "@@ -65,7 +65,6 @@ struct diagnostic_context;\n       BINDING_HAS_LEVEL_P (in CPLUS_BINDING)\n       BINFO_LOST_PRIMARY_P (in BINFO)\n       TREE_PARMLIST (in TREE_LIST)\n-      ADDR_IS_INVISIREF (in ADDR_EXPR)\n    3: TYPE_USES_VIRTUAL_BASECLASSES (in a class TYPE).\n       BINFO_VTABLE_PATH_MARKED.\n       BINFO_PUSHDECLS_MARKED.\n@@ -1687,10 +1686,6 @@ struct lang_type GTY(())\n /* Nonzero for a parmlist means that this parmlist ended in ...  */\n #define PARMLIST_ELLIPSIS_P(NODE) TREE_LANG_FLAG_0 (NODE)\n \n-/* Nonzero if this ADDR_EXPR is used to implement the pass by invisible\n-   reference calling convention.  */\n-#define ADDR_IS_INVISIREF(NODE) TREE_LANG_FLAG_2 (NODE)\n-\n /* For FUNCTION_TYPE or METHOD_TYPE, a list of the exceptions that\n    this type can raise.  Each TREE_VALUE is a _TYPE.  The TREE_VALUE\n    will be NULL_TREE to indicate a throw specification of `()', or"}, {"sha": "747cc1aaef692feb3387c2324cf9f1a01833feaa", "filename": "gcc/cp/except.c", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=c246c65d7638d21cf773a4fab446870c93635390", "patch": "@@ -601,28 +601,12 @@ stabilize_throw_expr (exp, initp)\n \t{\n \t  tree arg = TREE_VALUE (args);\n \t  tree arg_init_expr;\n-\t  if (TREE_CODE (arg) == ADDR_EXPR\n-\t      && ADDR_IS_INVISIREF (arg))\n-\t    {\n-\t      /* A sub-TARGET_EXPR.  Recurse; we can't wrap the actual call\n-\t\t without introducing an extra copy.  */\n-\t      tree sub = TREE_OPERAND (arg, 0);\n-\t      if (TREE_CODE (sub) != TARGET_EXPR)\n-\t\tabort ();\n-\t      sub = stabilize_throw_expr (sub, &arg_init_expr);\n-\t      TREE_OPERAND (arg, 0) = sub;\n-\t      if (TREE_SIDE_EFFECTS (arg_init_expr))\n-\t\tinit_expr = build (COMPOUND_EXPR, void_type_node, init_expr,\n-\t\t\t\t   arg_init_expr);\n-\t    }\n-\t  else\n-\t    {\n-\t      arg = stabilize_expr (arg, &arg_init_expr);\n \n-\t      if (TREE_SIDE_EFFECTS (arg_init_expr))\n-\t\tinit_expr = build (COMPOUND_EXPR, void_type_node, init_expr,\n-\t\t\t\t   arg_init_expr);\n-\t    }\n+\t  arg = stabilize_expr (arg, &arg_init_expr);\n+\n+\t  if (TREE_SIDE_EFFECTS (arg_init_expr))\n+\t    init_expr = build (COMPOUND_EXPR, void_type_node, init_expr,\n+\t\t\t       arg_init_expr);\n \t  *p = tree_cons (NULL_TREE, arg, NULL_TREE);\n \t  p = &TREE_CHAIN (*p);\n \t}"}, {"sha": "7752d66fb51d81203fdcb1eedf73b5c2b3b6c652", "filename": "gcc/integrate.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c246c65d7638d21cf773a4fab446870c93635390", "patch": "@@ -344,12 +344,36 @@ copy_decl_for_inlining (decl, from_fn, to_fn)\n   /* Copy the declaration.  */\n   if (TREE_CODE (decl) == PARM_DECL || TREE_CODE (decl) == RESULT_DECL)\n     {\n+      tree type;\n+      int invisiref = 0;\n+\n+      /* See if the frontend wants to pass this by invisible reference.  */\n+      if (TREE_CODE (decl) == PARM_DECL\n+\t  && DECL_ARG_TYPE (decl) != TREE_TYPE (decl)\n+\t  && POINTER_TYPE_P (DECL_ARG_TYPE (decl))\n+\t  && TREE_TYPE (DECL_ARG_TYPE (decl)) == TREE_TYPE (decl))\n+\t{\n+\t  invisiref = 1;\n+\t  type = DECL_ARG_TYPE (decl);\n+\t}\n+      else\n+\ttype = TREE_TYPE (decl);\n+\n       /* For a parameter, we must make an equivalent VAR_DECL, not a\n \t new PARM_DECL.  */\n-      copy = build_decl (VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n-      TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n-      TREE_READONLY (copy) = TREE_READONLY (decl);\n-      TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n+      copy = build_decl (VAR_DECL, DECL_NAME (decl), type);\n+      if (!invisiref)\n+\t{\n+\t  TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n+\t  TREE_READONLY (copy) = TREE_READONLY (decl);\n+\t  TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n+\t}\n+      else\n+\t{\n+\t  TREE_ADDRESSABLE (copy) = 0;\n+\t  TREE_READONLY (copy) = 1;\n+\t  TREE_THIS_VOLATILE (copy) = 0;\n+\t}\n     }\n   else\n     {"}, {"sha": "e6d3300b56bc754d87703ec2dcdf2e06ba6e7ce4", "filename": "gcc/testsuite/g++.dg/init/elide2.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Felide2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Felide2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Felide2.C?ref=c246c65d7638d21cf773a4fab446870c93635390", "patch": "@@ -0,0 +1,30 @@\n+// PR c++/8674\n+\n+// Bug: Since B().a is an rvalue, we tried to treat it like a TARGET_EXPR\n+// and elide the copy.  But that produces a bitwise copy, which causes us\n+// to abort in cp_expr_size.\n+\n+// Test that we actually run the A copy constructor when calling f().\n+\n+// { dg-do run }\n+\n+int c;\n+\n+struct A\n+{\n+  A () { ++c; }\n+  A (const A&) { ++c; }\n+};\n+\n+struct B\n+{\n+  A a;\n+};\n+\n+void f (A) { }\n+\n+int main ()\n+{\n+  f (B().a);\n+  return c < 2;\n+}"}, {"sha": "0f5ab59158f3fb9e513321a72eb928bf3e7bef20", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=c246c65d7638d21cf773a4fab446870c93635390", "patch": "@@ -632,6 +632,7 @@ initialize_inlined_parameters (id, args, fn, block)\n #endif /* not INLINER_FOR_JAVA */\n       tree var;\n       tree value;\n+      tree var_sub;\n \n       /* Find the initializer.  */\n       value = (*lang_hooks.tree_inlining.convert_parm_for_inlining)\n@@ -669,12 +670,23 @@ initialize_inlined_parameters (id, args, fn, block)\n \n       /* Make an equivalent VAR_DECL.  */\n       var = copy_decl_for_inlining (p, fn, VARRAY_TREE (id->fns, 0));\n+\n+      /* See if the frontend wants to pass this by invisible reference.  If\n+\t so, our new VAR_DECL will have REFERENCE_TYPE, and we need to\n+\t replace uses of the PARM_DECL with dereferences.  */\n+      if (TREE_TYPE (var) != TREE_TYPE (p)\n+\t  && POINTER_TYPE_P (TREE_TYPE (var))\n+\t  && TREE_TYPE (TREE_TYPE (var)) == TREE_TYPE (p))\n+\tvar_sub = build1 (INDIRECT_REF, TREE_TYPE (p), var);\n+      else\n+\tvar_sub = var;\n+\n       /* Register the VAR_DECL as the equivalent for the PARM_DECL;\n \t that way, when the PARM_DECL is encountered, it will be\n \t automatically replaced by the VAR_DECL.  */\n       splay_tree_insert (id->decl_map,\n \t\t\t (splay_tree_key) p,\n-\t\t\t (splay_tree_value) var);\n+\t\t\t (splay_tree_value) var_sub);\n \n       /* Declare this new variable.  */\n #ifndef INLINER_FOR_JAVA"}, {"sha": "dfac289f137643e2af8f12cefc125b146dc0da32", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c246c65d7638d21cf773a4fab446870c93635390/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c246c65d7638d21cf773a4fab446870c93635390", "patch": "@@ -4118,6 +4118,9 @@ bool\n variably_modified_type_p (type)\n      tree type;\n {\n+  if (type == error_mark_node)\n+    return false;\n+\n   /* If TYPE itself has variable size, it is variably modified.  \n \n      We do not yet have a representation of the C99 '[*]' syntax."}]}