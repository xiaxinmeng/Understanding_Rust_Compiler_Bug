{"sha": "454ff5cbf0544db194bc0b1a87902f913ab93faa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU0ZmY1Y2JmMDU0NGRiMTk0YmMwYjFhODc5MDJmOTEzYWI5M2ZhYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-09-18T19:47:10Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-09-18T19:47:10Z"}, "message": "alias.c, [...]: Fix comment typos.\n\n\t* alias.c, crtstuff.c, dbxout.c, domwalk.c, domwalk.h, gcc.c,\n\tgcse.c, global.c, lambda-code.c, loop.c, mips-tdump.c,\n\toptabs.h, predict.c, reg-stack.c, regclass.c, sched-rgn.c,\n\ttree-optimize.c, tree-ssa-dom.c, tree-ssa-forwprop.c,\n\ttree-ssa-operands.c, tree-ssa-phiopt.c,\n\ttree-ssa-threadupdate.c: Fix comment typos.\n\nFrom-SVN: r87707", "tree": {"sha": "415e77fa8943b51c9cb97549ca6147abb08d118f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/415e77fa8943b51c9cb97549ca6147abb08d118f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/454ff5cbf0544db194bc0b1a87902f913ab93faa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/454ff5cbf0544db194bc0b1a87902f913ab93faa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/454ff5cbf0544db194bc0b1a87902f913ab93faa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/454ff5cbf0544db194bc0b1a87902f913ab93faa/comments", "author": null, "committer": null, "parents": [{"sha": "112cdef5e66fccce5475fabb5317805e012dc212", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112cdef5e66fccce5475fabb5317805e012dc212", "html_url": "https://github.com/Rust-GCC/gccrs/commit/112cdef5e66fccce5475fabb5317805e012dc212"}], "stats": {"total": 73, "additions": 41, "deletions": 32}, "files": [{"sha": "9cbeca88ec0c49351a2bf02e9564e2018c99ee96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -1,3 +1,12 @@\n+2004-09-18  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* alias.c, crtstuff.c, dbxout.c, domwalk.c, domwalk.h, gcc.c,\n+\tgcse.c, global.c, lambda-code.c, loop.c, mips-tdump.c,\n+\toptabs.h, predict.c, reg-stack.c, regclass.c, sched-rgn.c,\n+\ttree-optimize.c, tree-ssa-dom.c, tree-ssa-forwprop.c,\n+\ttree-ssa-operands.c, tree-ssa-phiopt.c,\n+\ttree-ssa-threadupdate.c: Fix comment typos.\n+\n 2004-09-18  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/darwin-c.c, config/arc/arc.c, config/arc/arc.md,"}, {"sha": "b937cb13cb84572bcd85d9e1035b7f799429b0ed", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -2698,7 +2698,7 @@ memory_modified_1 (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n \n \n /* Return true when INSN possibly modify memory contents of MEM\n-   (ie address can be modified).  */\n+   (i.e. address can be modified).  */\n bool\n memory_modified_in_insn_p (rtx mem, rtx insn)\n {"}, {"sha": "ecb3dea314ac56891116c6db0100f4e07e37f640", "filename": "gcc/crtstuff.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fcrtstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fcrtstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcrtstuff.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -109,7 +109,7 @@ call_ ## FUNC (void)\t\t\t\t\t\\\n    but not its definition.\n \n    Making TARGET_WEAK_ATTRIBUTE conditional seems like a good solution until\n-   one thinks about scaling to larger problems -- ie, the condition under\n+   one thinks about scaling to larger problems -- i.e., the condition under\n    which TARGET_WEAK_ATTRIBUTE is active will eventually get far too\n    complicated.\n "}, {"sha": "f822feef7992e7099833943fdb186ce285cd59e4", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -1431,7 +1431,7 @@ dbxout_type (tree type, int full)\n     {\n     case VOID_TYPE:\n     case LANG_TYPE:\n-      /* For a void type, just define it as itself; ie, \"5=5\".\n+      /* For a void type, just define it as itself; i.e., \"5=5\".\n \t This makes us consider it defined\n \t without saying what it is.  The debugger will make it\n \t a void type when the reference is seen, and nothing will"}, {"sha": "7ac7ecf4f3e025966d3dc0641a76473d07eb968c", "filename": "gcc/domwalk.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -52,7 +52,7 @@ Boston, MA 02111-1307, USA.  */\n \n \n   [ Note this walker can also walk the post-dominator tree, which is\n-    defined in a similar manner.  ie, block B1 is said to post-dominate\n+    defined in a similar manner.  i.e., block B1 is said to post-dominate\n     block B2 if all paths from B2 to the exit block must pass through\n     B1.  ]\n "}, {"sha": "53a872e34fc5204e08b65c183cf121075ccd5cdf", "filename": "gcc/domwalk.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -25,7 +25,7 @@ Boston, MA 02111-1307, USA.  */\n \n struct dom_walk_data\n {\n-  /* This is the direction of the dominator tree we want to walk.  ie,\n+  /* This is the direction of the dominator tree we want to walk.  i.e.,\n      if it is set to CDI_DOMINATORS, then we walk the dominator tree,\n      if it is set to CDI_POST_DOMINATORS, then we walk the post\n      dominator tree.  */"}, {"sha": "e6f72bf3cdf0c85264afbdddce8dfbb900630bc4", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -5169,7 +5169,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      }\n \t    else\n \t      /* Catch the case where a spec string contains something like\n-\t\t '%{foo:%*}'.  ie there is no * in the pattern on the left\n+\t\t '%{foo:%*}'.  i.e. there is no * in the pattern on the left\n \t\t hand side of the :.  */\n \t      error (\"spec failure: '%%*' has not been initialized by pattern match\");\n \t    break;"}, {"sha": "7ad4f7eeef220331a54774e81ad01863bb259763", "filename": "gcc/gcse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -453,7 +453,7 @@ static int reg_set_table_size;\n /* This is a list of expressions which are MEMs and will be used by load\n    or store motion.\n    Load motion tracks MEMs which aren't killed by\n-   anything except itself. (ie, loads and stores to a single location).\n+   anything except itself. (i.e., loads and stores to a single location).\n    We can then allow movement of these MEM refs with a little special\n    allowance. (all stores copy the same value to the reaching reg used\n    for the loads).  This means all values used to store into memory must have\n@@ -2768,7 +2768,7 @@ find_avail_set (int regno, rtx insn)\n   struct expr *set1 = 0;\n \n   /* Loops are not possible here.  To get a loop we would need two sets\n-     available at the start of the block containing INSN.  ie we would\n+     available at the start of the block containing INSN.  i.e. we would\n      need two sets like this available at the start of the block:\n \n        (set (reg X) (reg Y))\n@@ -2814,7 +2814,7 @@ find_avail_set (int regno, rtx insn)\n       if (! REG_P (src))\n \tbreak;\n \n-      /* Follow the copy chain, ie start another iteration of the loop\n+      /* Follow the copy chain, i.e. start another iteration of the loop\n \t and see if we have an available copy into SRC.  */\n       regno = REGNO (src);\n     }"}, {"sha": "223a468e45bd131c3a9b9bc6d9beb23f54495c1e", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -734,7 +734,7 @@ global_conflicts (void)\n \t\t   evaluates X.\n \n \t\t3. Either X or Y is not evaluated on the path to P\n-\t\t   (ie it is used uninitialized) and thus the\n+\t\t   (i.e. it is used uninitialized) and thus the\n \t\t   conflict can be ignored.\n \n \t    In cases #1 and #2 the conflict will be recorded when we"}, {"sha": "3faeee1bb9b7dcc87563f8630a36411500089ad5", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -2033,7 +2033,7 @@ stmt_is_bumper_for_loop (struct loop *loop, tree stmt)\n    innermost loop body.\n    If S is a program statement, then\n \n-   ie \n+   i.e. \n    DO I = 1, 20\n        S1\n        DO J = 1, 20\n@@ -2395,7 +2395,7 @@ perfect_nestify (struct loops *loops,\n    matrix T is legal when applied to a loop nest with a set of\n    lexicographically non-negative distance vectors RDG if and only if\n    for each vector d in RDG, (T.d >= 0) is lexicographically positive.\n-   ie.: if and only if it transforms the lexicographically positive\n+   i.e.: if and only if it transforms the lexicographically positive\n    distance vectors to lexicographically positive vectors.  Note that\n    a unimodular matrix must transform the zero vector (and only it) to\n    the zero vector.\" S.Muchnick.  */"}, {"sha": "0f62789cab28de171634dab320e620f072cc34b1", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -3558,7 +3558,7 @@ note_addr_stored (rtx x, rtx y ATTRIBUTE_UNUSED,\n }\n \n /* X is a value modified by an INSN that references a biv inside a loop\n-   exit test (ie, X is somehow related to the value of the biv).  If X\n+   exit test (i.e., X is somehow related to the value of the biv).  If X\n    is a pseudo that is used more than once, then the biv is (effectively)\n    used more than once.  DATA is a pointer to a loop_regs structure.  */\n "}, {"sha": "d320330531dfd3afe0632e1c9fcd5da16ac2b745", "filename": "gcc/mips-tdump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -631,7 +631,7 @@ type_to_string (AUXU *aux_ptr, int index, FDR *fdp)\n       /*\n        * Snarf up any array bounds in the correct order.  Arrays\n        * store 5 successive words in the aux. table:\n-       *\tword 0\tRNDXR to type of the bounds (ie, int)\n+       *\tword 0\tRNDXR to type of the bounds (i.e., int)\n        *\tword 1\tCurrent file descriptor index\n        *\tword 2\tlow bound\n        *\tword 3\thigh bound (or -1 if [])\n@@ -689,7 +689,7 @@ type_to_string (AUXU *aux_ptr, int index, FDR *fdp)\n \t\tint first_array = i;\n \t\tint j;\n \n-\t\t/* Print array bounds reversed (ie, in the order the C\n+\t\t/* Print array bounds reversed (i.e., in the order the C\n \t\t   programmer writes them).  C is such a fun language....  */\n \n \t\twhile (i < 5 && qualifiers[i+1].type == tq_Array)"}, {"sha": "b5632c770fe9adf9caa3cd73d81f4ce64a50dd95", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -374,12 +374,12 @@ extern GTY(()) optab code_to_optab[NUM_RTX_CODE + 1];\n \f\n typedef rtx (*rtxfun) (rtx);\n \n-/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n+/* Indexed by the rtx-code for a conditional (e.g. EQ, LT,...)\n    gives the gen_function to make a branch to test that condition.  */\n \n extern rtxfun bcc_gen_fctn[NUM_RTX_CODE];\n \n-/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n+/* Indexed by the rtx-code for a conditional (e.g. EQ, LT,...)\n    gives the insn code to make a store-condition insn\n    to test that condition.  */\n "}, {"sha": "88de74b80b29df5f2d144d6a101c4fab839f7686", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -823,7 +823,7 @@ estimate_probability (struct loops *loops_info)\n \t       && !last_basic_block_p (e->dest))\n \t    predict_edge_def (e, PRED_EARLY_RETURN, TAKEN);\n \n-\t  /* Look for block we are guarding (ie we dominate it,\n+\t  /* Look for block we are guarding (i.e. we dominate it,\n \t     but it doesn't postdominate us).  */\n \t  if (e->dest != EXIT_BLOCK_PTR && e->dest != bb\n \t      && dominated_by_p (CDI_DOMINATORS, e->dest, e->src)\n@@ -1183,7 +1183,7 @@ tree_estimate_probability (void)\n \t       && !last_basic_block_p (e->dest))\n \t    predict_edge_def (e, PRED_EARLY_RETURN, TAKEN);\n \n-\t  /* Look for block we are guarding (ie we dominate it,\n+\t  /* Look for block we are guarding (i.e. we dominate it,\n \t     but it doesn't postdominate us).  */\n \t  if (e->dest != EXIT_BLOCK_PTR && e->dest != bb\n \t      && dominated_by_p (CDI_DOMINATORS, e->dest, e->src)"}, {"sha": "ee9c1e90402e1574f1f5fca8f32acad1177fdb2d", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -105,7 +105,7 @@\n \t\tasm (\"foo\" : \"=t\" (a) : \"f\" (b));\n \n       This asm says that input B is not popped by the asm, and that\n-      the asm pushes a result onto the reg-stack, ie, the stack is one\n+      the asm pushes a result onto the reg-stack, i.e., the stack is one\n       deeper after the asm than it was before.  But, it is possible that\n       reload will think that it can use the same reg for both the input and\n       the output, if input B dies in this insn.\n@@ -2393,7 +2393,7 @@ subst_stack_regs (rtx insn, stack regstack)\n \n    Insert any needed insns before or after INSN, as indicated by\n    WHERE.  OLD is the original stack layout, and NEW is the desired\n-   form.  OLD is updated to reflect the code emitted, ie, it will be\n+   form.  OLD is updated to reflect the code emitted, i.e., it will be\n    the same as NEW upon return.\n \n    This function will not preserve block_end[].  But that information"}, {"sha": "1d33a0977b2fb164b6606b376b4fc2f58d3d2a93", "filename": "gcc/regclass.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -1582,7 +1582,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t  win = address_operand (op, GET_MODE (op));\n \t\t  /* We know this operand is an address, so we want it to be\n \t\t     allocated to a register that can be the base of an\n-\t\t     address, ie BASE_REG_CLASS.  */\n+\t\t     address, i.e. BASE_REG_CLASS.  */\n \t\t  classes[i]\n \t\t    = reg_class_subunion[(int) classes[i]]\n \t\t      [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n@@ -1696,7 +1696,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t\twin = 1;\n \t\t      /* We know this operand is an address, so we want it to\n \t\t\t be allocated to a register that can be the base of an\n-\t\t\t address, ie BASE_REG_CLASS.  */\n+\t\t\t address, i.e. BASE_REG_CLASS.  */\n \t\t      classes[i]\n \t\t\t= reg_class_subunion[(int) classes[i]]\n \t\t\t  [(int) MODE_BASE_REG_CLASS (VOIDmode)];"}, {"sha": "4da38c530c6ec2b807548e96910d2242fe93d403", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -912,7 +912,7 @@ find_rgns (struct edge_list *edge_list)\n \t\t d\t  b\n \n \t     The algorithm in the DFS traversal may not mark B & D as part\n-\t     of the loop (ie they will not have max_hdr set to A).\n+\t     of the loop (i.e. they will not have max_hdr set to A).\n \n \t     We know they can not be loop latches (else they would have\n \t     had max_hdr set since they'd have a backedge to a dominator"}, {"sha": "9a18f37e0c53e934b7a7920809862b877facddc6", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -541,7 +541,7 @@ execute_pass_list (struct tree_opt_pass *pass)\n }\n \f\n \n-/* update recursivly all inlined_to pointers of functions\n+/* Update recursively all inlined_to pointers of functions\n    inlined into NODE to INLINED_TO.  */\n static void\n update_inlined_to_pointers (struct cgraph_node *node,"}, {"sha": "daf46ea9f4bbc5cf592d53ca5ab40a008ddb7986", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -170,7 +170,7 @@ struct opt_stats_d\n    optimizations are not performed.\n \n    Note carefully we do not propagate information through each statement\n-   in the block.  ie, if we know variable X has a value defined of\n+   in the block.  i.e., if we know variable X has a value defined of\n    [0, 25] and we encounter Y = X + 1, we do not track a value range\n    for Y (which would be [1, 26] if we cared).  Similarly we do not\n    constrain values as we encounter narrowing typecasts, etc.  */\n@@ -1988,7 +1988,7 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \n \t  /* We really want to avoid unnecessary computations of range\n \t     info.  So all ranges are computed lazily; this avoids a\n-\t     lot of unnecessary work.  ie, we record the conditional,\n+\t     lot of unnecessary work.  i.e., we record the conditional,\n \t     but do not process how it constrains the variable's \n \t     potential values until we know that processing the condition\n \t     could be helpful.\n@@ -3095,7 +3095,7 @@ get_eq_expr_value (tree if_stmt,\n       tree op1 = TREE_OPERAND (cond, 1);\n \n       /* Special case comparing booleans against a constant as we know\n-\t the value of OP0 on both arms of the branch.  ie, we can record\n+\t the value of OP0 on both arms of the branch.  i.e., we can record\n \t an equivalence for OP0 rather than COND.  */\n       if ((TREE_CODE (cond) == EQ_EXPR || TREE_CODE (cond) == NE_EXPR)\n \t  && TREE_CODE (op0) == SSA_NAME"}, {"sha": "619cab0332008d2616b5a9b799cb690535bc83ef", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -39,7 +39,7 @@ Boston, MA 02111-1307, USA.  */\n \n    Right now we only bother forward propagating into COND_EXPRs since those\n    are relatively common cases where forward propagation creates valid\n-   gimple code without the expression needing to fold.  ie\n+   gimple code without the expression needing to fold.  i.e.\n \n      bb0:\n        x = a COND b;"}, {"sha": "7f9840f9fcbad98a18db00b949430c5e1a125d65", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -75,7 +75,7 @@ Boston, MA 02111-1307, USA.  */\n    variable, and that same variable occurs in the same operands cache, then \n    the new cache vector will also get the same SSA_NAME.\n \n-  ie, if a stmt had a VUSE of 'a_5', and 'a' occurs in the new operand \n+  i.e., if a stmt had a VUSE of 'a_5', and 'a' occurs in the new operand \n   vector for VUSE, then the new vector will also be modified such that \n   it contains 'a_5' rather than 'a'.\n "}, {"sha": "fe0fddf93454a99107a898b19315c7edd6db53cb", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -47,7 +47,7 @@ static bool candidate_bb_for_phi_optimization (basic_block,\n \t\t\t\t\t       basic_block *);\n \n /* This pass eliminates PHI nodes which can be trivially implemented as\n-   an assignment from a conditional expression.  ie if we have something\n+   an assignment from a conditional expression.  i.e. if we have something\n    like:\n \n      bb0:"}, {"sha": "ce6dcad49481fc7c00657f0a9cf06606d53f36df", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454ff5cbf0544db194bc0b1a87902f913ab93faa/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=454ff5cbf0544db194bc0b1a87902f913ab93faa", "patch": "@@ -41,7 +41,7 @@ Boston, MA 02111-1307, USA.  */\n    one or more in-edges to B to instead reach the destination of an\n    out-edge from B while preserving any side effects in B.\n \n-   ie, given A->B and B->C, change A->B to be A->C yet still preserve the\n+   i.e., given A->B and B->C, change A->B to be A->C yet still preserve the\n    side effects of executing B.\n \n      1. Make a copy of B (including its outgoing edges and statements).  Call"}]}