{"sha": "e91d0adbc165ca56844bc0f0c8c92782739d75f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkxZDBhZGJjMTY1Y2E1Njg0NGJjMGYwYzhjOTI3ODI3MzlkNzVmNA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-06-14T18:52:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-06-14T18:52:32Z"}, "message": "gimple.h (gimple_can_coalesce_p): Prototype.\n\n\t* gimple.h (gimple_can_coalesce_p): Prototype.\n\t* tree-ssa-coalesce.c (gimple_can_coalesce_p): New function.\n\t(create_outofssa_var_map, coalesce_partitions): Use it.\n\t* tree-ssa-uncprop.c (uncprop_into_successor_phis): Similarly.\n\t* tree-ssa-live.c (var_map_base_init): Use TYPE_CANONICAL\n\tif it's available.\n\n\t* gcc.dg/tree-ssa/coalesce-1.c: New test.\n\nFrom-SVN: r200103", "tree": {"sha": "885f6be93528b5d127ff4ebdfff5e4d673b7ab15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/885f6be93528b5d127ff4ebdfff5e4d673b7ab15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e91d0adbc165ca56844bc0f0c8c92782739d75f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e91d0adbc165ca56844bc0f0c8c92782739d75f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e91d0adbc165ca56844bc0f0c8c92782739d75f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e91d0adbc165ca56844bc0f0c8c92782739d75f4/comments", "author": null, "committer": null, "parents": [{"sha": "51b08adabf40a7922771ff4e0c36c8680c082825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b08adabf40a7922771ff4e0c36c8680c082825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b08adabf40a7922771ff4e0c36c8680c082825"}], "stats": {"total": 270, "additions": 250, "deletions": 20}, "files": [{"sha": "8ae07c9ba5d9d78a34140375189e8ea0f8c4c269", "filename": "gcc/gimple.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e91d0adbc165ca56844bc0f0c8c92782739d75f4/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e91d0adbc165ca56844bc0f0c8c92782739d75f4/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=e91d0adbc165ca56844bc0f0c8c92782739d75f4", "patch": "@@ -1101,6 +1101,9 @@ extern tree tree_ssa_strip_useless_type_conversions (tree);\n extern bool useless_type_conversion_p (tree, tree);\n extern bool types_compatible_p (tree, tree);\n \n+/* In tree-ssa-coalesce.c */\n+extern bool gimple_can_coalesce_p (tree, tree);\n+\n /* Return the first node in GIMPLE sequence S.  */\n \n static inline gimple_seq_node"}, {"sha": "5cae9ae2a350ea2c6e3fe50372bb650d16bc45b2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/coalesce-1.c", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e91d0adbc165ca56844bc0f0c8c92782739d75f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcoalesce-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e91d0adbc165ca56844bc0f0c8c92782739d75f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcoalesce-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcoalesce-1.c?ref=e91d0adbc165ca56844bc0f0c8c92782739d75f4", "patch": "@@ -0,0 +1,195 @@\n+/* { dg-do compile } */\n+\n+/* { dg-options \"-O2 -fdump-rtl-expand-details\" } */\n+\n+typedef long unsigned int size_t;\n+union tree_node;\n+typedef union tree_node *tree;\n+union gimple_statement_d;\n+typedef union gimple_statement_d *gimple;\n+typedef const union tree_node *const_tree;\n+typedef const union gimple_statement_d *const_gimple;\n+struct gimple_seq_d;\n+typedef struct gimple_seq_d *gimple_seq;\n+struct edge_def;\n+typedef struct edge_def *edge;\n+struct basic_block_def;\n+typedef struct basic_block_def *basic_block;\n+typedef const struct basic_block_def *const_basic_block;\n+struct tree_exp\n+{\n+  tree operands[1];\n+};\n+typedef struct ssa_use_operand_d\n+{\n+  tree *use;\n+} ssa_use_operand_t;\n+struct phi_arg_d\n+{\n+  struct ssa_use_operand_d imm_use;\n+};\n+union tree_node\n+{\n+  struct tree_exp exp;\n+};\n+struct function\n+{\n+};\n+extern struct function *cfun;\n+struct edge_def\n+{\n+  unsigned int dest_idx;\n+};\n+static __inline__ void\n+VEC_edge_must_be_pointer_type (void)\n+{\n+  (void) ((edge) 1 == (void *) 1);\n+} typedef struct VEC_edge_base\n+\n+{\n+  unsigned num;\n+  unsigned alloc;\n+  edge vec[1];\n+} VEC_edge_base;\n+typedef struct VEC_edge_none\n+{\n+  VEC_edge_base base;\n+} VEC_edge_none;\n+\n+static __inline__ edge\n+VEC_edge_base_index (const VEC_edge_base * vec_, unsigned ix_,\n+\t\t     const char *file_, unsigned line_, const char *function_)\n+{\n+  return vec_->vec[ix_];\n+}\n+\n+typedef struct VEC_edge_gc\n+{\n+  VEC_edge_base base;\n+} VEC_edge_gc;\n+struct basic_block_def\n+{\n+  VEC_edge_gc *succs;\n+};\n+static __inline__ edge\n+single_succ_edge (const_basic_block bb)\n+{\n+  return (VEC_edge_base_index\n+\t  ((((bb)->succs) ? &((bb)->succs)->base : 0), (0),\n+\t   \"/home/gcc/virgin-gcc/gcc/basic-block.h\", 563, __FUNCTION__));\n+}\n+\n+edge find_edge (basic_block, basic_block);\n+typedef tree *def_operand_p;\n+typedef ssa_use_operand_t *use_operand_p;\n+struct gimple_seq_node_d;\n+typedef struct gimple_seq_node_d *gimple_seq_node;\n+struct gimple_seq_node_d\n+{\n+  gimple stmt;\n+};\n+typedef struct\n+{\n+  gimple_seq_node ptr;\n+  gimple_seq seq;\n+  basic_block bb;\n+} gimple_stmt_iterator;\n+struct gimple_statement_phi\n+{\n+  struct phi_arg_d args[1];\n+};\n+union gimple_statement_d\n+{\n+  struct gimple_statement_phi gimple_phi;\n+};\n+extern size_t const gimple_ops_offset_[];\n+static __inline__ tree *\n+gimple_ops (gimple gs)\n+{\n+  size_t off;\n+  off = gimple_ops_offset_[gimple_statement_structure (gs)];\n+  return (tree *) ((char *) gs + off);\n+}\n+\n+static __inline__ tree\n+gimple_op (const_gimple gs, unsigned i)\n+{\n+  return gimple_ops ((((union\n+\t\t\t{\n+\t\t\tconst union gimple_statement_d * _q;\n+\t\t\tunion gimple_statement_d * _nq;}) (((gs))))._nq))[i];\n+}\n+\n+static __inline__ struct phi_arg_d *\n+gimple_phi_arg (gimple gs, unsigned index)\n+{\n+  return &(gs->gimple_phi.args[index]);\n+}\n+\n+static __inline__ tree\n+gimple_switch_label (const_gimple gs, unsigned index)\n+{\n+  return gimple_op (gs, index + 1);\n+}\n+\n+gimple_stmt_iterator gsi_start_phis (basic_block);\n+extern basic_block label_to_block_fn (struct function *, tree);\n+\n+static __inline__ tree\n+get_use_from_ptr (use_operand_p use)\n+{\n+  return *(use->use);\n+}\n+\n+static __inline__ use_operand_p\n+gimple_phi_arg_imm_use_ptr (gimple gs, int i)\n+{\n+  return &gimple_phi_arg (gs, i)->imm_use;\n+}\n+\n+struct switch_conv_info\n+{\n+  basic_block final_bb;\n+  basic_block switch_bb;\n+  const char *reason;\n+  tree *default_values;\n+};\n+static struct switch_conv_info info;\n+\n+static void\n+gather_default_values (tree default_case)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb =\n+    (label_to_block_fn ((cfun + 0), default_case->exp.operands[2]));\n+  edge e;\n+  int i = 0;\n+  if (bb == info.final_bb)\n+    e = find_edge (info.switch_bb, bb);\n+  else\n+    e = single_succ_edge (bb);\n+  for (gsi = gsi_start_phis (info.final_bb);\n+       gsi_gsi_start_phis (info.final_bb); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi.ptr->stmt;\n+      tree val = get_use_from_ptr (gimple_phi_arg_imm_use_ptr\n+\t\t\t\t   ((((phi))), (((e)->dest_idx))));\n+      info.default_values[i++] = val;\n+    }\n+}\n+\n+unsigned char\n+process_switch (gimple swtch)\n+{\n+  unsigned int i, branch_num = gimple_switch_num_labels (swtch);\n+  tree index_type;\n+  info.reason = \"switch has no labels\\n\";\n+  gather_default_values (gimple_switch_label (swtch, 0));\n+}\n+\n+/* Verify that out-of-ssa coalescing did its job by verifying there are not\n+   any partition copies inserted.  */\n+\n+/* { dg-final { scan-rtl-dump-not \"partition copy\" \"expand\"} } */\n+/* { dg-final { cleanup-rtl-dump \"expand\" } } */\n+"}, {"sha": "d6471918d5196f739752412d62c903742a9b8dac", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e91d0adbc165ca56844bc0f0c8c92782739d75f4/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e91d0adbc165ca56844bc0f0c8c92782739d75f4/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=e91d0adbc165ca56844bc0f0c8c92782739d75f4", "patch": "@@ -943,8 +943,7 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t\tcontinue;\n \n \t      register_ssa_partition (map, arg);\n-\t      if ((SSA_NAME_VAR (arg) == SSA_NAME_VAR (res)\n-\t\t   && TREE_TYPE (arg) == TREE_TYPE (res))\n+\t      if (gimple_can_coalesce_p (arg, res)\n \t\t  || (e->flags & EDGE_ABNORMAL))\n \t\t{\n \t\t  saw_copy = true;\n@@ -985,8 +984,7 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t\tif (gimple_assign_copy_p (stmt)\n                     && TREE_CODE (lhs) == SSA_NAME\n \t\t    && TREE_CODE (rhs1) == SSA_NAME\n-\t\t    && SSA_NAME_VAR (lhs) == SSA_NAME_VAR (rhs1)\n-\t\t    && TREE_TYPE (lhs) == TREE_TYPE (rhs1))\n+\t\t    && gimple_can_coalesce_p (lhs, rhs1))\n \t\t  {\n \t\t    v1 = SSA_NAME_VERSION (lhs);\n \t\t    v2 = SSA_NAME_VERSION (rhs1);\n@@ -1037,8 +1035,7 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t\t    v1 = SSA_NAME_VERSION (outputs[match]);\n \t\t    v2 = SSA_NAME_VERSION (input);\n \n-\t\t    if (SSA_NAME_VAR (outputs[match]) == SSA_NAME_VAR (input)\n-\t\t\t&& TREE_TYPE (outputs[match]) == TREE_TYPE (input))\n+\t\t    if (gimple_can_coalesce_p (outputs[match], input))\n \t\t      {\n \t\t\tcost = coalesce_cost (REG_BR_PROB_BASE,\n \t\t\t\t\t      optimize_bb_for_size_p (bb));\n@@ -1072,8 +1069,7 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t\tfirst = var;\n \t      else\n \t\t{\n-\t\t  gcc_assert (SSA_NAME_VAR (var) == SSA_NAME_VAR (first)\n-\t\t\t      && TREE_TYPE (var) == TREE_TYPE (first));\n+\t\t  gcc_assert (gimple_can_coalesce_p (var, first));\n \t\t  v1 = SSA_NAME_VERSION (first);\n \t\t  v2 = SSA_NAME_VERSION (var);\n \t\t  bitmap_set_bit (used_in_copy, v1);\n@@ -1210,8 +1206,7 @@ coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n       var2 = ssa_name (y);\n \n       /* Assert the coalesces have the same base variable.  */\n-      gcc_assert (SSA_NAME_VAR (var1) == SSA_NAME_VAR (var2)\n-\t\t  && TREE_TYPE (var1) == TREE_TYPE (var2));\n+      gcc_assert (gimple_can_coalesce_p (var1, var2));\n \n       if (debug)\n \tfprintf (debug, \"Coalesce list: \");\n@@ -1341,3 +1336,38 @@ coalesce_ssa_name (void)\n \n   return map;\n }\n+\n+/* Given SSA_NAMEs NAME1 and NAME2, return true if they are candidates for\n+   coalescing together, false otherwise.\n+\n+   This must stay consistent with var_map_base_init in tree-ssa-live.c.  */\n+\n+bool\n+gimple_can_coalesce_p (tree name1, tree name2)\n+{\n+  /* First check the SSA_NAME's associated DECL.  We only want to\n+     coalesce if they have the same DECL or both have no associated DECL.  */\n+  if (SSA_NAME_VAR (name1) != SSA_NAME_VAR (name2))\n+    return false;\n+\n+  /* Now check the types.  If the types are the same, then we should\n+     try to coalesce V1 and V2.  */\n+  tree t1 = TREE_TYPE (name1);\n+  tree t2 = TREE_TYPE (name2);\n+  if (t1 == t2)\n+    return true;\n+\n+  /* If the types are not the same, check for a canonical type match.  This\n+     (for example) allows coalescing when the types are fundamentally the\n+     same, but just have different names. \n+\n+     Note pointer types with different address spaces may have the same\n+     canonical type.  Those are rejected for coalescing by the\n+     types_compatible_p check.  */\n+  if (TYPE_CANONICAL (t1)\n+      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2)\n+      && types_compatible_p (t1, t2))\n+    return true;\n+\n+  return false;\n+}"}, {"sha": "a624d0055c225ab6e084a92a4992b802474c9bd2", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e91d0adbc165ca56844bc0f0c8c92782739d75f4/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e91d0adbc165ca56844bc0f0c8c92782739d75f4/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=e91d0adbc165ca56844bc0f0c8c92782739d75f4", "patch": "@@ -111,8 +111,12 @@ var_map_base_init (var_map map)\n \t   as it restricts the sets we compute conflicts for.\n \t   Using TREE_TYPE to generate sets is the easies as\n \t   type equivalency also holds for SSA names with the same\n-\t   underlying decl.  */\n-\tm->base.from = TREE_TYPE (var);\n+\t   underlying decl. \n+\n+\t   Check gimple_can_coalesce_p when changing this code.  */\n+\tm->base.from = (TYPE_CANONICAL (TREE_TYPE (var))\n+\t\t\t? TYPE_CANONICAL (TREE_TYPE (var))\n+\t\t\t: TREE_TYPE (var));\n       /* If base variable hasn't been seen, set it up.  */\n       slot = tree_to_index.find_slot (m, INSERT);\n       if (!*slot)"}, {"sha": "555485a07c31d451dcd0b0bd486e20a4a54896ee", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e91d0adbc165ca56844bc0f0c8c92782739d75f4/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e91d0adbc165ca56844bc0f0c8c92782739d75f4/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=e91d0adbc165ca56844bc0f0c8c92782739d75f4", "patch": "@@ -474,12 +474,11 @@ uncprop_into_successor_phis (basic_block bb)\n \t  equiv_hash_elt an_equiv_elt;\n \t  equiv_hash_elt **slot;\n \n-\t  /* If the argument is not an invariant, and refers to the same\n-\t     underlying variable as the PHI result, then there's no\n-\t     point in un-propagating the argument.  */\n+\t  /* If the argument is not an invariant and can be potentially\n+\t     coalesced with the result, then there's no point in\n+\t     un-propagating the argument.  */\n \t  if (!is_gimple_min_invariant (arg)\n-\t      && (SSA_NAME_VAR (arg) == SSA_NAME_VAR (res)\n-\t\t  && TREE_TYPE (arg) == TREE_TYPE (res)))\n+\t      && gimple_can_coalesce_p (arg, res))\n \t    continue;\n \n \t  /* Lookup this argument's value in the hash table.  */\n@@ -493,16 +492,15 @@ uncprop_into_successor_phis (basic_block bb)\n \t      int j;\n \n \t      /* Walk every equivalence with the same value.  If we find\n-\t\t one with the same underlying variable as the PHI result,\n+\t\t one that can potentially coalesce with the PHI rsult,\n \t\t then replace the value in the argument with its equivalent\n \t\t SSA_NAME.  Use the most recent equivalence as hopefully\n \t\t that results in shortest lifetimes.  */\n \t      for (j = elt->equivalences.length () - 1; j >= 0; j--)\n \t\t{\n \t\t  tree equiv = elt->equivalences[j];\n \n-\t\t  if (SSA_NAME_VAR (equiv) == SSA_NAME_VAR (res)\n-\t\t      && TREE_TYPE (equiv) == TREE_TYPE (res))\n+\t\t  if (gimple_can_coalesce_p (equiv, res))\n \t\t    {\n \t\t      SET_PHI_ARG_DEF (phi, e->dest_idx, equiv);\n \t\t      break;"}]}