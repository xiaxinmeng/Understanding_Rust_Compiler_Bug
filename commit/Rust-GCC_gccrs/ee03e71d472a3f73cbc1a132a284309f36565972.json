{"sha": "ee03e71d472a3f73cbc1a132a284309f36565972", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUwM2U3MWQ0NzJhM2Y3M2NiYzFhMTMyYTI4NDMwOWYzNjU2NTk3Mg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-06-17T15:08:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-06-17T15:08:24Z"}, "message": "lto-streamer.h (enum LTO_tags): Add LTO_tree_scc.\n\n2013-06-17  Richard Biener  <rguenther@suse.de>\n\n\t* lto-streamer.h (enum LTO_tags): Add LTO_tree_scc.\n\t(lto_input_scc): Declare.\n\t(lto_input_tree_1): Likewise.\n\t(struct lto_stats_d): Add num_tree_bodies_output and\n\tnum_pickle_refs_output.\n\t* lto-streamer-in.c (lto_read_body): Use streamer_tree_cache_get_tree.\n\t(lto_read_tree_1): Split out from ...\n\t(lto_read_tree): ... this.\n\t(lto_input_scc): New function.\n\t(lto_input_tree_1): Split out from ...\n\t(lto_input_tree): ... this.  Handle LTO_tree_scc.\n\t(lto_data_in_create): Create the streamer cache without hashes.\n\t* lto-streamer-out.c (create_output_block): Create the streamer\n\tcache with hashes when not doing WPA.\n\t(lto_write_tree_1): Split out from ...\n\t(lto_write_tree): ... this.\n\t(get_symbol_initial_value): New function.\n\t(lto_output_tree_1): Split out from ...\n\t(lto_output_tree): ... this.  Write trees as series of SCCs\n\tusing a DFS walk via DFS_write_tree.\n\t(struct sccs, struct scc_entry): New types.\n\t(next_dfs_num, sccstack, sccstate, sccstate_obstack): New globals.\n\t(DFS_write_tree_body): New function.\n\t(DFS_write_tree): Likewise.\n\t(hash_tree): Likewise.\n\t(scc_entry_compare): Likewise.\n\t(hash_scc): Likewise.\n\t(tree_is_indexable): DEBUG_EXPR_DECLs are local entities.\n\t* tree-streamer-in.c (lto_input_ts_list_tree_pointers): Stream\n\tTREE_CHAIN as regular reference.\n\t(streamer_read_integer_cst): Remove.\n\t(streamer_get_pickled_tree): Adjust.\n\t* tree-streamer-out.c (streamer_write_chain): Disable streaming\n\tof DECL_EXTERNALs in BLOCK_VARS for now.\n\t(write_ts_list_tree_pointers): Stream TREE_CHAIN as regular\n\treference.\n\t* tree-streamer.c (streamer_tree_cache_add_to_node_array):\n\tAdd hash value argument and record that if hashes are recorded\n\tin the cache.\n\t(streamer_tree_cache_insert_1): Adjust.\n\t(streamer_tree_cache_insert): Likewise.\n\t(streamer_tree_cache_insert_at): Rename to ...\n\t(streamer_tree_cache_replace_tree): ... this and adjust.\n\t(streamer_tree_cache_append): Adjust.\n\t(record_common_node): Likewise.\n\t(streamer_tree_cache_create): Add argument whether to\n\trecord hash values together with trees.\n\t(streamer_tree_cache_delete): Adjust.\n\t* tree-streamer.h (struct streamer_tree_cache_d): Add\n\tvector of hashes.\n\t(streamer_read_integer_cst): Remove.\n\t(streamer_tree_cache_insert): Adjust.\n\t(streamer_tree_cache_append): Likewise.\n\t(streamer_tree_cache_insert_at): Rename to ...\n\t(streamer_tree_cache_replace_tree): ... this and adjust.\n\t(streamer_tree_cache_create): Add argument whether to record hashes.\n\t(streamer_tree_cache_get): Rename to ...\n\t(streamer_tree_cache_get_tree): ... this.\n\t(streamer_tree_cache_get_hash): New function.\n\t* tree.c (cache_integer_cst): New function.\n\t* tree.h (cache_integer_cst): Declare.\n\t(ANON_AGGRNAME_FORMAT, ANON_AGGRNAME_P): Move here from cp/cp-tree.h.\n\t* lto-symtab.c (lto_varpool_replace_node): Only release\n\tDECL_INITIAL of non-prevailing decls.\n\t* varpool.c (varpool_remove_initializer): Do not release\n\tDECL_INITIAL when we are still in CGRAPH_LTO_STREAMING.\n\n\tcp/\n\t* cp-tree.h (ANON_AGGRNAME_FORMAT, ANON_AGGRNAME_P): Move to tree.h.\n\n\tlto/\n\t* Make-lang.in (lto.o): Add $(DATA_STREAMER_H) dependency.\n\t* lto.c: Include data-streamer.h.\n\t(lto_read_in_decl_state): Use streamer_tree_cache_get_tree.\n\t(gimple_type_leader_entry_s, gimple_type_leader,\n\tgimple_lookup_type_leader): Remove.\n\t(gtc_visit): Simplify.\n\t(gimple_types_compatible_p): Likewise.\n\t(gimple_register_type_1): Likewise.  Merge into ...\n\t(gimple_register_type): ... this.  Keep it as legacy for\n\tstatistics purposes for now.\n\t(fixup_integer_cst): Remove.\n\t(LTO_FIXUP_TREE, lto_fixup_types, lto_ft_*): Simplify and\n\trename to ...\n\t(MAYBE_REMEMBER_WITH_VARS, maybe_remember_with_vars,\n\tmaybe_remember_with_vars_*): ... these.\n\t(uniquify_nodes): Remove.\n\t(lto_fixup_prevailing_type): New function.\n\t(struct tree_scc, struct tree_scc_hasher): New type and hasher.\n\t(tree_scc_hash, tree_scc_hash_obstack): New globals.\n\t(num_merged_types, num_prevailing_types, num_not_merged_types,\n\tnum_not_merged_types_in_same_scc, total_scc_size, num_sccs_read,\n\ttotal_scc_size_merged, num_sccs_merged, num_scc_compares,\n\tnum_scc_compare_collisions): New global counters.\n\t(compare_tree_sccs_1): New function.\n\t(compare_tree_sccs): Likewise.\n\t(unify_scc): Likewise.\n\t(lto_read_decls): Stream in tree SCCs and unify them on the\n\tway in.  Finalize prevailing SCC tree members.\n\t(read_cgraph_and_symbols): Do not initialize or free gimple_type_leader.\n\tAllocate and free tree_scc_hash_obstack and tree_scc_hash, do not bother\n\tto ggc-collect during merging.\n\t(print_lto_report_1): Adjust for new merging code.\n\nFrom-SVN: r200151", "tree": {"sha": "37057cc11efb7f662edca2c35160d9fcf3e20d36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37057cc11efb7f662edca2c35160d9fcf3e20d36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee03e71d472a3f73cbc1a132a284309f36565972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee03e71d472a3f73cbc1a132a284309f36565972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee03e71d472a3f73cbc1a132a284309f36565972", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee03e71d472a3f73cbc1a132a284309f36565972/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0e33cbcd8966627b6a9d88b14e4ad9efccc97b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0e33cbcd8966627b6a9d88b14e4ad9efccc97b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0e33cbcd8966627b6a9d88b14e4ad9efccc97b4"}], "stats": {"total": 2973, "additions": 2381, "deletions": 592}, "files": [{"sha": "a58dd00927b5d8b70dc3a64b06deb4c57f8f4ce9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -1,3 +1,72 @@\n+2013-06-17  Richard Biener  <rguenther@suse.de>\n+\n+\t* lto-streamer.h (enum LTO_tags): Add LTO_tree_scc.\n+\t(lto_input_scc): Declare.\n+\t(lto_input_tree_1): Likewise.\n+\t(struct lto_stats_d): Add num_tree_bodies_output and\n+\tnum_pickle_refs_output.\n+\t* lto-streamer-in.c (lto_read_body): Use streamer_tree_cache_get_tree.\n+\t(lto_read_tree_1): Split out from ...\n+\t(lto_read_tree): ... this.\n+\t(lto_input_scc): New function.\n+\t(lto_input_tree_1): Split out from ...\n+\t(lto_input_tree): ... this.  Handle LTO_tree_scc.\n+\t(lto_data_in_create): Create the streamer cache without hashes.\n+\t* lto-streamer-out.c (create_output_block): Create the streamer\n+\tcache with hashes when not doing WPA.\n+\t(lto_write_tree_1): Split out from ...\n+\t(lto_write_tree): ... this.\n+\t(get_symbol_initial_value): New function.\n+\t(lto_output_tree_1): Split out from ...\n+\t(lto_output_tree): ... this.  Write trees as series of SCCs\n+\tusing a DFS walk via DFS_write_tree.\n+\t(struct sccs, struct scc_entry): New types.\n+\t(next_dfs_num, sccstack, sccstate, sccstate_obstack): New globals.\n+\t(DFS_write_tree_body): New function.\n+\t(DFS_write_tree): Likewise.\n+\t(hash_tree): Likewise.\n+\t(scc_entry_compare): Likewise.\n+\t(hash_scc): Likewise.\n+\t(tree_is_indexable): DEBUG_EXPR_DECLs are local entities.\n+\t* tree-streamer-in.c (lto_input_ts_list_tree_pointers): Stream\n+\tTREE_CHAIN as regular reference.\n+\t(streamer_read_integer_cst): Remove.\n+\t(streamer_get_pickled_tree): Adjust.\n+\t* tree-streamer-out.c (streamer_write_chain): Disable streaming\n+\tof DECL_EXTERNALs in BLOCK_VARS for now.\n+\t(write_ts_list_tree_pointers): Stream TREE_CHAIN as regular\n+\treference.\n+\t* tree-streamer.c (streamer_tree_cache_add_to_node_array):\n+\tAdd hash value argument and record that if hashes are recorded\n+\tin the cache.\n+\t(streamer_tree_cache_insert_1): Adjust.\n+\t(streamer_tree_cache_insert): Likewise.\n+\t(streamer_tree_cache_insert_at): Rename to ...\n+\t(streamer_tree_cache_replace_tree): ... this and adjust.\n+\t(streamer_tree_cache_append): Adjust.\n+\t(record_common_node): Likewise.\n+\t(streamer_tree_cache_create): Add argument whether to\n+\trecord hash values together with trees.\n+\t(streamer_tree_cache_delete): Adjust.\n+\t* tree-streamer.h (struct streamer_tree_cache_d): Add\n+\tvector of hashes.\n+\t(streamer_read_integer_cst): Remove.\n+\t(streamer_tree_cache_insert): Adjust.\n+\t(streamer_tree_cache_append): Likewise.\n+\t(streamer_tree_cache_insert_at): Rename to ...\n+\t(streamer_tree_cache_replace_tree): ... this and adjust.\n+\t(streamer_tree_cache_create): Add argument whether to record hashes.\n+\t(streamer_tree_cache_get): Rename to ...\n+\t(streamer_tree_cache_get_tree): ... this.\n+\t(streamer_tree_cache_get_hash): New function.\n+\t* tree.c (cache_integer_cst): New function.\n+\t* tree.h (cache_integer_cst): Declare.\n+\t(ANON_AGGRNAME_FORMAT, ANON_AGGRNAME_P): Move here from cp/cp-tree.h.\n+\t* lto-symtab.c (lto_varpool_replace_node): Only release\n+\tDECL_INITIAL of non-prevailing decls.\n+\t* varpool.c (varpool_remove_initializer): Do not release\n+\tDECL_INITIAL when we are still in CGRAPH_LTO_STREAMING.\n+\n 2013-06-16  J\u00fcrgen Urban  <JuergenUrban@gmx.de>\n \n \t* config/mips/mips.h (ISA_HAS_MUL3): Include TARGET_MIPS5900."}, {"sha": "1b58ba00f4b59cae7f118121eb1d34e734f2db26", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -1,3 +1,7 @@\n+2013-06-17  Richard Biener  <rguenther@suse.de>\n+\n+\t* cp-tree.h (ANON_AGGRNAME_FORMAT, ANON_AGGRNAME_P): Move to tree.h.\n+\n 2013-06-17  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/16128"}, {"sha": "2931ac566f02cd5a7ec952419043745f52db2d94", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -4345,8 +4345,6 @@ extern GTY(()) vec<tree, va_gc> *local_classes;\n #define VFIELD_NAME \"_vptr.\"\n #define VFIELD_NAME_FORMAT \"_vptr.%s\"\n \n-#define ANON_AGGRNAME_FORMAT \"._%d\"\n-\n #else /* NO_DOT_IN_LABEL */\n \n #ifndef NO_DOLLAR_IN_LABEL\n@@ -4357,7 +4355,6 @@ extern GTY(()) vec<tree, va_gc> *local_classes;\n #define VFIELD_BASE \"$vf\"\n #define VFIELD_NAME \"_vptr$\"\n #define VFIELD_NAME_FORMAT \"_vptr$%s\"\n-#define ANON_AGGRNAME_FORMAT \"$_%d\"\n \n #else /* NO_DOLLAR_IN_LABEL */\n \n@@ -4376,12 +4373,6 @@ extern GTY(()) vec<tree, va_gc> *local_classes;\n \t    sizeof (VFIELD_NAME) - 1))\n #define VFIELD_NAME_FORMAT \"__vptr_%s\"\n \n-#define ANON_AGGRNAME_PREFIX \"__anon_\"\n-#define ANON_AGGRNAME_P(ID_NODE) \\\n-  (!strncmp (IDENTIFIER_POINTER (ID_NODE), ANON_AGGRNAME_PREFIX, \\\n-\t     sizeof (ANON_AGGRNAME_PREFIX) - 1))\n-#define ANON_AGGRNAME_FORMAT \"__anon_%d\"\n-\n #endif\t/* NO_DOLLAR_IN_LABEL */\n #endif\t/* NO_DOT_IN_LABEL */\n \n@@ -4418,11 +4409,6 @@ extern GTY(()) vec<tree, va_gc> *local_classes;\n #define VFIELD_NAME_P(ID_NODE) \\\n   (!strncmp (IDENTIFIER_POINTER (ID_NODE), VFIELD_NAME, sizeof(VFIELD_NAME)-1))\n \n-/* For anonymous aggregate types, we need some sort of name to\n-   hold on to.  In practice, this should not appear, but it should\n-   not be harmful if it does.  */\n-#define ANON_AGGRNAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[0] == JOINER \\\n-\t\t\t\t  && IDENTIFIER_POINTER (ID_NODE)[1] == '_')\n #endif /* !defined(NO_DOLLAR_IN_LABEL) || !defined(NO_DOT_IN_LABEL) */\n \n \f"}, {"sha": "2484cc23f5233339aa16dac64b0db52ead959120", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 117, "deletions": 32, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -1016,7 +1016,7 @@ lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n \t  unsigned i;\n \t  for (i = len; i-- > from;)\n \t    {\n-\t      tree t = cache->nodes[i];\n+\t      tree t = streamer_tree_cache_get_tree (cache, i);\n \t      if (t == NULL_TREE)\n \t\tcontinue;\n \n@@ -1056,48 +1056,114 @@ lto_input_function_body (struct lto_file_decl_data *file_data,\n }\n \n \n+/* Read the physical representation of a tree node EXPR from\n+   input block IB using the per-file context in DATA_IN.  */\n+\n+static void\n+lto_read_tree_1 (struct lto_input_block *ib, struct data_in *data_in, tree expr)\n+{\n+  /* Read all the bitfield values in EXPR.  Note that for LTO, we\n+     only write language-independent bitfields, so no more unpacking is\n+     needed.  */\n+  streamer_read_tree_bitfields (ib, data_in, expr);\n+\n+  /* Read all the pointer fields in EXPR.  */\n+  streamer_read_tree_body (ib, data_in, expr);\n+\n+  /* Read any LTO-specific data not read by the tree streamer.  */\n+  if (DECL_P (expr)\n+      && TREE_CODE (expr) != FUNCTION_DECL\n+      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n+    DECL_INITIAL (expr) = stream_read_tree (ib, data_in);\n+\n+  /* We should never try to instantiate an MD or NORMAL builtin here.  */\n+  if (TREE_CODE (expr) == FUNCTION_DECL)\n+    gcc_assert (!streamer_handle_as_builtin_p (expr));\n+\n+#ifdef LTO_STREAMER_DEBUG\n+  /* Remove the mapping to RESULT's original address set by\n+     streamer_alloc_tree.  */\n+  lto_orig_address_remove (expr);\n+#endif\n+}\n+\n /* Read the physical representation of a tree node with tag TAG from\n    input block IB using the per-file context in DATA_IN.  */\n \n static tree\n lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n-\t       enum LTO_tags tag)\n+\t       enum LTO_tags tag, hashval_t hash)\n {\n   /* Instantiate a new tree node.  */\n   tree result = streamer_alloc_tree (ib, data_in, tag);\n \n   /* Enter RESULT in the reader cache.  This will make RESULT\n      available so that circular references in the rest of the tree\n      structure can be resolved in subsequent calls to stream_read_tree.  */\n-  streamer_tree_cache_append (data_in->reader_cache, result);\n+  streamer_tree_cache_append (data_in->reader_cache, result, hash);\n \n-  /* Read all the bitfield values in RESULT.  Note that for LTO, we\n-     only write language-independent bitfields, so no more unpacking is\n-     needed.  */\n-  streamer_read_tree_bitfields (ib, data_in, result);\n+  lto_read_tree_1 (ib, data_in, result);\n \n-  /* Read all the pointer fields in RESULT.  */\n-  streamer_read_tree_body (ib, data_in, result);\n+  /* end_marker = */ streamer_read_uchar (ib);\n \n-  /* Read any LTO-specific data not read by the tree streamer.  */\n-  if (DECL_P (result)\n-      && TREE_CODE (result) != FUNCTION_DECL\n-      && TREE_CODE (result) != TRANSLATION_UNIT_DECL)\n-    DECL_INITIAL (result) = stream_read_tree (ib, data_in);\n+  return result;\n+}\n \n-  /* We should never try to instantiate an MD or NORMAL builtin here.  */\n-  if (TREE_CODE (result) == FUNCTION_DECL)\n-    gcc_assert (!streamer_handle_as_builtin_p (result));\n \n-  /* end_marker = */ streamer_read_uchar (ib);\n+/* Populate the reader cache with trees materialized from the SCC\n+   following in the IB, DATA_IN stream.  */\n \n-#ifdef LTO_STREAMER_DEBUG\n-  /* Remove the mapping to RESULT's original address set by\n-     streamer_alloc_tree.  */\n-  lto_orig_address_remove (result);\n-#endif\n+hashval_t\n+lto_input_scc (struct lto_input_block *ib, struct data_in *data_in,\n+\t       unsigned *len, unsigned *entry_len)\n+{\n+  /* A blob of unnamed tree nodes, fill the cache from it and\n+     recurse.  */\n+  unsigned size = streamer_read_uhwi (ib);\n+  hashval_t scc_hash = streamer_read_uhwi (ib);\n+  unsigned scc_entry_len = 1;\n \n-  return result;\n+  if (size == 1)\n+    {\n+      enum LTO_tags tag = streamer_read_record_start (ib);\n+      lto_input_tree_1 (ib, data_in, tag, scc_hash);\n+    }\n+  else\n+    {\n+      unsigned int first = data_in->reader_cache->nodes.length ();\n+      tree result;\n+\n+      scc_entry_len = streamer_read_uhwi (ib);\n+\n+      /* Materialize size trees by reading their headers.  */\n+      for (unsigned i = 0; i < size; ++i)\n+\t{\n+\t  enum LTO_tags tag = streamer_read_record_start (ib);\n+\t  if (tag == LTO_null\n+\t      || (tag >= LTO_field_decl_ref && tag <= LTO_global_decl_ref)\n+\t      || tag == LTO_tree_pickle_reference\n+\t      || tag == LTO_builtin_decl\n+\t      || tag == LTO_integer_cst\n+\t      || tag == LTO_tree_scc)\n+\t    gcc_unreachable ();\n+\n+\t  result = streamer_alloc_tree (ib, data_in, tag);\n+\t  streamer_tree_cache_append (data_in->reader_cache, result, 0);\n+\t}\n+\n+      /* Read the tree bitpacks and references.  */\n+      for (unsigned i = 0; i < size; ++i)\n+\t{\n+\t  result = streamer_tree_cache_get_tree (data_in->reader_cache,\n+\t\t\t\t\t\t first + i);\n+\t  lto_read_tree_1 (ib, data_in, result);\n+\t  /* end_marker = */ streamer_read_uchar (ib);\n+\t}\n+    }\n+\n+  *len = size;\n+  *entry_len = scc_entry_len;\n+  return scc_hash;\n }\n \n \n@@ -1106,12 +1172,11 @@ lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n    to previously read nodes.  */\n \n tree\n-lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n+lto_input_tree_1 (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t  enum LTO_tags tag, hashval_t hash)\n {\n-  enum LTO_tags tag;\n   tree result;\n \n-  tag = streamer_read_record_start (ib);\n   gcc_assert ((unsigned) tag < (unsigned) LTO_NUM_TAGS);\n \n   if (tag == LTO_null)\n@@ -1137,19 +1202,39 @@ lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n     }\n   else if (tag == LTO_integer_cst)\n     {\n-      /* For shared integer constants we only need the type and its hi/low\n-\t words.  */\n-      result = streamer_read_integer_cst (ib, data_in);\n+      /* For shared integer constants in singletons we can use the existing\n+         tree integer constant merging code.  */\n+      tree type = stream_read_tree (ib, data_in);\n+      unsigned HOST_WIDE_INT low = streamer_read_uhwi (ib);\n+      HOST_WIDE_INT high = streamer_read_hwi (ib);\n+      result = build_int_cst_wide (type, low, high);\n+      streamer_tree_cache_append (data_in->reader_cache, result, hash);\n+    }\n+  else if (tag == LTO_tree_scc)\n+    {\n+      unsigned len, entry_len;\n+\n+      /* Input and skip the SCC.  */\n+      lto_input_scc (ib, data_in, &len, &entry_len);\n+\n+      /* Recurse.  */\n+      return lto_input_tree (ib, data_in);\n     }\n   else\n     {\n       /* Otherwise, materialize a new node from IB.  */\n-      result = lto_read_tree (ib, data_in, tag);\n+      result = lto_read_tree (ib, data_in, tag, hash);\n     }\n \n   return result;\n }\n \n+tree\n+lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  return lto_input_tree_1 (ib, data_in, streamer_read_record_start (ib), 0);\n+}\n+\n \n /* Input toplevel asms.  */\n \n@@ -1220,7 +1305,7 @@ lto_data_in_create (struct lto_file_decl_data *file_data, const char *strings,\n   data_in->strings = strings;\n   data_in->strings_len = len;\n   data_in->globals_resolution = resolutions;\n-  data_in->reader_cache = streamer_tree_cache_create ();\n+  data_in->reader_cache = streamer_tree_cache_create (false);\n \n   return data_in;\n }"}, {"sha": "1a72092f2970f7ce279c13cd6e0e8477ca20facb", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 996, "deletions": 52, "changes": 1048, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -71,7 +71,7 @@ create_output_block (enum lto_section_type section_type)\n   ob->decl_state = lto_get_out_decl_state ();\n   ob->main_stream = XCNEW (struct lto_output_stream);\n   ob->string_stream = XCNEW (struct lto_output_stream);\n-  ob->writer_cache = streamer_tree_cache_create ();\n+  ob->writer_cache = streamer_tree_cache_create (!flag_wpa);\n \n   if (section_type == LTO_section_function_body)\n     ob->cfg_stream = XCNEW (struct lto_output_stream);\n@@ -129,6 +129,8 @@ tree_is_indexable (tree t)\n   else if (TREE_CODE (t) == VAR_DECL && decl_function_context (t)\n \t   && !TREE_STATIC (t))\n     return false;\n+  else if (TREE_CODE (t) == DEBUG_EXPR_DECL)\n+    return false;\n   /* Variably modified types need to be streamed alongside function\n      bodies because they can refer to local entities.  Together with\n      them we have to localize their members as well.\n@@ -293,27 +295,48 @@ lto_is_streamable (tree expr)\n }\n \n \n+/* For EXPR lookup and return what we want to stream to OB as DECL_INITIAL.  */\n+\n+static tree\n+get_symbol_initial_value (struct output_block *ob, tree expr)\n+{\n+  gcc_checking_assert (DECL_P (expr)\n+\t\t       && TREE_CODE (expr) != FUNCTION_DECL\n+\t\t       && TREE_CODE (expr) != TRANSLATION_UNIT_DECL);\n+\n+  /* Handle DECL_INITIAL for symbols.  */\n+  tree initial = DECL_INITIAL (expr);\n+  if (TREE_CODE (expr) == VAR_DECL\n+      && (TREE_STATIC (expr) || DECL_EXTERNAL (expr))\n+      && !DECL_IN_CONSTANT_POOL (expr)\n+      && initial)\n+    {\n+      lto_symtab_encoder_t encoder;\n+      struct varpool_node *vnode;\n+\n+      encoder = ob->decl_state->symtab_node_encoder;\n+      vnode = varpool_get_node (expr);\n+      if (!vnode\n+\t  || !lto_symtab_encoder_encode_initializer_p (encoder,\n+\t\t\t\t\t\t       vnode))\n+\tinitial = error_mark_node;\n+    }\n+\n+  return initial;\n+}\n+\n+\n /* Write a physical representation of tree node EXPR to output block\n    OB.  If REF_P is true, the leaves of EXPR are emitted as references\n    via lto_output_tree_ref.  IX is the index into the streamer cache\n    where EXPR is stored.  */\n \n static void\n-lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n+lto_write_tree_1 (struct output_block *ob, tree expr, bool ref_p)\n {\n-  struct bitpack_d bp;\n-\n-  if (!lto_is_streamable (expr))\n-    internal_error (\"tree code %qs is not supported in LTO streams\",\n-\t            tree_code_name[TREE_CODE (expr)]);\n-\n-  /* Write the header, containing everything needed to materialize\n-     EXPR on the reading side.  */\n-  streamer_write_tree_header (ob, expr);\n-\n   /* Pack all the non-pointer fields in EXPR into a bitpack and write\n      the resulting bitpack.  */\n-  bp = bitpack_create (ob->main_stream);\n+  bitpack_d bp = bitpack_create (ob->main_stream);\n   streamer_pack_tree_bitfields (ob, &bp, expr);\n   streamer_write_bitpack (&bp);\n \n@@ -326,30 +349,939 @@ lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n       && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n     {\n       /* Handle DECL_INITIAL for symbols.  */\n-      tree initial = DECL_INITIAL (expr);\n-      if (TREE_CODE (expr) == VAR_DECL\n-\t  && (TREE_STATIC (expr) || DECL_EXTERNAL (expr))\n-\t  && !DECL_IN_CONSTANT_POOL (expr)\n-\t  && initial)\n-\t{\n-\t  lto_symtab_encoder_t encoder;\n-\t  struct varpool_node *vnode;\n-\n-\t  encoder = ob->decl_state->symtab_node_encoder;\n-\t  vnode = varpool_get_node (expr);\n-\t  if (!vnode\n-\t      || !lto_symtab_encoder_encode_initializer_p (encoder,\n-\t\t\t\t\t\t\t    vnode))\n-\t    initial = error_mark_node;\n-\t}\n-\n+      tree initial = get_symbol_initial_value (ob, expr);\n       stream_write_tree (ob, initial, ref_p);\n     }\n+}\n+\n+/* Write a physical representation of tree node EXPR to output block\n+   OB.  If REF_P is true, the leaves of EXPR are emitted as references\n+   via lto_output_tree_ref.  IX is the index into the streamer cache\n+   where EXPR is stored.  */\n+\n+static void\n+lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  if (!lto_is_streamable (expr))\n+    internal_error (\"tree code %qs is not supported in LTO streams\",\n+\t\t    tree_code_name[TREE_CODE (expr)]);\n+\n+  /* Write the header, containing everything needed to materialize\n+     EXPR on the reading side.  */\n+  streamer_write_tree_header (ob, expr);\n+\n+  lto_write_tree_1 (ob, expr, ref_p);\n \n   /* Mark the end of EXPR.  */\n   streamer_write_zero (ob);\n }\n \n+/* Emit the physical representation of tree node EXPR to output block\n+   OB.  If THIS_REF_P is true, the leaves of EXPR are emitted as references\n+   via lto_output_tree_ref.  REF_P is used for streaming siblings of EXPR.  */\n+\n+static void\n+lto_output_tree_1 (struct output_block *ob, tree expr, hashval_t hash,\n+\t\t   bool ref_p, bool this_ref_p)\n+{\n+  unsigned ix;\n+\n+  gcc_checking_assert (expr != NULL_TREE\n+\t\t       && !(this_ref_p && tree_is_indexable (expr)));\n+\n+  bool exists_p = streamer_tree_cache_insert (ob->writer_cache,\n+\t\t\t\t\t      expr, hash, &ix);\n+  gcc_assert (!exists_p);\n+  if (streamer_handle_as_builtin_p (expr))\n+    {\n+      /* MD and NORMAL builtins do not need to be written out\n+\t completely as they are always instantiated by the\n+\t compiler on startup.  The only builtins that need to\n+\t be written out are BUILT_IN_FRONTEND.  For all other\n+\t builtins, we simply write the class and code.  */\n+      streamer_write_builtin (ob, expr);\n+    }\n+  else if (TREE_CODE (expr) == INTEGER_CST\n+\t   && !TREE_OVERFLOW (expr))\n+    {\n+      /* Shared INTEGER_CST nodes are special because they need their\n+\t original type to be materialized by the reader (to implement\n+\t TYPE_CACHED_VALUES).  */\n+      streamer_write_integer_cst (ob, expr, ref_p);\n+    }\n+  else\n+    {\n+      /* This is the first time we see EXPR, write its fields\n+\t to OB.  */\n+      lto_write_tree (ob, expr, ref_p);\n+    }\n+}\n+\n+struct sccs\n+{\n+  unsigned int dfsnum;\n+  unsigned int low;\n+};\n+\n+struct scc_entry\n+{\n+  tree t;\n+  hashval_t hash;\n+};\n+\n+static unsigned int next_dfs_num;\n+static vec<scc_entry> sccstack;\n+static struct pointer_map_t *sccstate;\n+static struct obstack sccstate_obstack;\n+\n+static void\n+DFS_write_tree (struct output_block *ob, sccs *from_state,\n+\t\ttree expr, bool ref_p, bool this_ref_p);\n+\n+/* Handle the tree EXPR in the DFS walk with SCC state EXPR_STATE and\n+   DFS recurse for all tree edges originating from it.  */\n+\n+static void\n+DFS_write_tree_body (struct output_block *ob,\n+\t\t     tree expr, sccs *expr_state, bool ref_p)\n+{\n+#define DFS_follow_tree_edge(DEST) \\\n+  DFS_write_tree (ob, expr_state, DEST, ref_p, ref_p)\n+\n+  enum tree_code code;\n+\n+  code = TREE_CODE (expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n+    {\n+      if (TREE_CODE (expr) != IDENTIFIER_NODE)\n+\tDFS_follow_tree_edge (TREE_TYPE (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n+    {\n+      for (unsigned i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n+\tDFS_follow_tree_edge (VECTOR_CST_ELT (expr, i));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n+    {\n+      DFS_follow_tree_edge (TREE_REALPART (expr));\n+      DFS_follow_tree_edge (TREE_IMAGPART (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n+    {\n+      /* Drop names that were created for anonymous entities.  */\n+      if (DECL_NAME (expr)\n+\t  && TREE_CODE (DECL_NAME (expr)) == IDENTIFIER_NODE\n+\t  && ANON_AGGRNAME_P (DECL_NAME (expr)))\n+\t;\n+      else\n+\tDFS_follow_tree_edge (DECL_NAME (expr));\n+      DFS_follow_tree_edge (DECL_CONTEXT (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    {\n+      DFS_follow_tree_edge (DECL_SIZE (expr));\n+      DFS_follow_tree_edge (DECL_SIZE_UNIT (expr));\n+\n+      /* Note, DECL_INITIAL is not handled here.  Since DECL_INITIAL needs\n+\t special handling in LTO, it must be handled by streamer hooks.  */\n+\n+      DFS_follow_tree_edge (DECL_ATTRIBUTES (expr));\n+\n+      /* Do not follow DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n+\t for early inlining so drop it on the floor instead of ICEing in\n+\t dwarf2out.c.  */\n+\n+      if ((TREE_CODE (expr) == VAR_DECL\n+\t   || TREE_CODE (expr) == PARM_DECL)\n+\t  && DECL_HAS_VALUE_EXPR_P (expr))\n+\tDFS_follow_tree_edge (DECL_VALUE_EXPR (expr));\n+      if (TREE_CODE (expr) == VAR_DECL)\n+\tDFS_follow_tree_edge (DECL_DEBUG_EXPR (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n+    {\n+      if (TREE_CODE (expr) == FUNCTION_DECL)\n+\t{\n+\t  for (tree t = DECL_ARGUMENTS (expr); t; t = TREE_CHAIN (t))\n+\t    DFS_follow_tree_edge (t);\n+\t  DFS_follow_tree_edge (DECL_RESULT (expr));\n+\t}\n+      else if (TREE_CODE (expr) == TYPE_DECL)\n+\tDFS_follow_tree_edge (DECL_ORIGINAL_TYPE (expr));\n+      DFS_follow_tree_edge (DECL_VINDEX (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    {\n+      /* Make sure we don't inadvertently set the assembler name.  */\n+      if (DECL_ASSEMBLER_NAME_SET_P (expr))\n+\tDFS_follow_tree_edge (DECL_ASSEMBLER_NAME (expr));\n+      DFS_follow_tree_edge (DECL_SECTION_NAME (expr));\n+      DFS_follow_tree_edge (DECL_COMDAT_GROUP (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n+    {\n+      DFS_follow_tree_edge (DECL_FIELD_OFFSET (expr));\n+      DFS_follow_tree_edge (DECL_BIT_FIELD_TYPE (expr));\n+      DFS_follow_tree_edge (DECL_BIT_FIELD_REPRESENTATIVE (expr));\n+      DFS_follow_tree_edge (DECL_FIELD_BIT_OFFSET (expr));\n+      DFS_follow_tree_edge (DECL_FCONTEXT (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    {\n+      DFS_follow_tree_edge (DECL_FUNCTION_PERSONALITY (expr));\n+      DFS_follow_tree_edge (DECL_FUNCTION_SPECIFIC_TARGET (expr));\n+      DFS_follow_tree_edge (DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    {\n+      DFS_follow_tree_edge (TYPE_SIZE (expr));\n+      DFS_follow_tree_edge (TYPE_SIZE_UNIT (expr));\n+      DFS_follow_tree_edge (TYPE_ATTRIBUTES (expr));\n+      DFS_follow_tree_edge (TYPE_NAME (expr));\n+      /* Do not follow TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n+\t reconstructed during fixup.  */\n+      /* Do not follow TYPE_NEXT_VARIANT, we reconstruct the variant lists\n+\t during fixup.  */\n+      DFS_follow_tree_edge (TYPE_MAIN_VARIANT (expr));\n+      DFS_follow_tree_edge (TYPE_CONTEXT (expr));\n+      /* TYPE_CANONICAL is re-computed during type merging, so no need\n+\t to follow it here.  */\n+      DFS_follow_tree_edge (TYPE_STUB_DECL (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n+    {\n+      if (TREE_CODE (expr) == ENUMERAL_TYPE)\n+\tDFS_follow_tree_edge (TYPE_VALUES (expr));\n+      else if (TREE_CODE (expr) == ARRAY_TYPE)\n+\tDFS_follow_tree_edge (TYPE_DOMAIN (expr));\n+      else if (RECORD_OR_UNION_TYPE_P (expr))\n+\tfor (tree t = TYPE_FIELDS (expr); t; t = TREE_CHAIN (t))\n+\t  DFS_follow_tree_edge (t);\n+      else if (TREE_CODE (expr) == FUNCTION_TYPE\n+\t       || TREE_CODE (expr) == METHOD_TYPE)\n+\tDFS_follow_tree_edge (TYPE_ARG_TYPES (expr));\n+\n+      if (!POINTER_TYPE_P (expr))\n+\tDFS_follow_tree_edge (TYPE_MINVAL (expr));\n+      DFS_follow_tree_edge (TYPE_MAXVAL (expr));\n+      if (RECORD_OR_UNION_TYPE_P (expr))\n+\tDFS_follow_tree_edge (TYPE_BINFO (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n+    {\n+      DFS_follow_tree_edge (TREE_PURPOSE (expr));\n+      DFS_follow_tree_edge (TREE_VALUE (expr));\n+      DFS_follow_tree_edge (TREE_CHAIN (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    {\n+      for (int i = 0; i < TREE_VEC_LENGTH (expr); i++)\n+\tDFS_follow_tree_edge (TREE_VEC_ELT (expr, i));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n+    {\n+      for (int i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n+\tDFS_follow_tree_edge (TREE_OPERAND (expr, i));\n+      DFS_follow_tree_edge (TREE_BLOCK (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n+    {\n+      for (tree t = BLOCK_VARS (expr); t; t = TREE_CHAIN (t))\n+\t/* ???  FIXME.  See also streamer_write_chain.  */\n+\tif (!(VAR_OR_FUNCTION_DECL_P (t)\n+\t      && DECL_EXTERNAL (t)))\n+\t  DFS_follow_tree_edge (t);\n+\n+      DFS_follow_tree_edge (BLOCK_SUPERCONTEXT (expr));\n+\n+      /* Follow BLOCK_ABSTRACT_ORIGIN for the limited cases we can\n+\t handle - those that represent inlined function scopes.\n+\t For the drop rest them on the floor instead of ICEing\n+\t in dwarf2out.c.  */\n+      if (inlined_function_outer_scope_p (expr))\n+\t{\n+\t  tree ultimate_origin = block_ultimate_origin (expr);\n+\t  DFS_follow_tree_edge (ultimate_origin);\n+\t}\n+      /* Do not follow BLOCK_NONLOCALIZED_VARS.  We cannot handle debug\n+\t information for early inlined BLOCKs so drop it on the floor instead\n+\t of ICEing in dwarf2out.c.  */\n+\n+      /* BLOCK_FRAGMENT_ORIGIN and BLOCK_FRAGMENT_CHAIN is not live at LTO\n+\t streaming time.  */\n+\n+      /* Do not output BLOCK_SUBBLOCKS.  Instead on streaming-in this\n+\t list is re-constructed from BLOCK_SUPERCONTEXT.  */\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    {\n+      unsigned i;\n+      tree t;\n+\n+      /* Note that the number of BINFO slots has already been emitted in\n+\t EXPR's header (see streamer_write_tree_header) because this length\n+\t is needed to build the empty BINFO node on the reader side.  */\n+      FOR_EACH_VEC_ELT (*BINFO_BASE_BINFOS (expr), i, t)\n+\tDFS_follow_tree_edge (t);\n+      DFS_follow_tree_edge (BINFO_OFFSET (expr));\n+      DFS_follow_tree_edge (BINFO_VTABLE (expr));\n+      DFS_follow_tree_edge (BINFO_VPTR_FIELD (expr));\n+\n+      /* The number of BINFO_BASE_ACCESSES has already been emitted in\n+\t EXPR's bitfield section.  */\n+      FOR_EACH_VEC_SAFE_ELT (BINFO_BASE_ACCESSES (expr), i, t)\n+\tDFS_follow_tree_edge (t);\n+\n+      DFS_follow_tree_edge (BINFO_INHERITANCE_CHAIN (expr));\n+      DFS_follow_tree_edge (BINFO_SUBVTT_INDEX (expr));\n+      DFS_follow_tree_edge (BINFO_VPTR_INDEX (expr));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n+    {\n+      unsigned i;\n+      tree index, value;\n+\n+      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (expr), i, index, value)\n+\t{\n+\t  DFS_follow_tree_edge (index);\n+\t  DFS_follow_tree_edge (value);\n+\t}\n+    }\n+\n+#undef DFS_follow_tree_edge\n+}\n+\n+/* Return a hash value for the tree T.  */\n+\n+static hashval_t\n+hash_tree (struct streamer_tree_cache_d *cache, tree t)\n+{\n+#define visit(SIBLING) \\\n+  do { \\\n+    unsigned ix; \\\n+    if (SIBLING && streamer_tree_cache_lookup (cache, SIBLING, &ix)) \\\n+      v = iterative_hash_hashval_t (streamer_tree_cache_get_hash (cache, ix), v); \\\n+  } while (0)\n+\n+  /* Hash TS_BASE.  */\n+  enum tree_code code = TREE_CODE (t);\n+  hashval_t v = iterative_hash_host_wide_int (code, 0);\n+  if (!TYPE_P (t))\n+    {\n+      v = iterative_hash_host_wide_int (TREE_SIDE_EFFECTS (t)\n+\t\t\t\t\t| (TREE_CONSTANT (t) << 1)\n+\t\t\t\t\t| (TREE_READONLY (t) << 2)\n+\t\t\t\t\t| (TREE_PUBLIC (t) << 3), v);\n+    }\n+  v = iterative_hash_host_wide_int (TREE_ADDRESSABLE (t)\n+\t\t\t\t    | (TREE_THIS_VOLATILE (t) << 1), v);\n+  if (DECL_P (t))\n+    v = iterative_hash_host_wide_int (DECL_UNSIGNED (t), v);\n+  else if (TYPE_P (t))\n+    v = iterative_hash_host_wide_int (TYPE_UNSIGNED (t), v);\n+  if (TYPE_P (t))\n+    v = iterative_hash_host_wide_int (TYPE_ARTIFICIAL (t), v);\n+  else\n+    v = iterative_hash_host_wide_int (TREE_NO_WARNING (t), v);\n+  v = iterative_hash_host_wide_int (TREE_NOTHROW (t)\n+\t\t\t\t    | (TREE_STATIC (t) << 1)\n+\t\t\t\t    | (TREE_PROTECTED (t) << 2)\n+\t\t\t\t    | (TREE_DEPRECATED (t) << 3), v);\n+  if (code != TREE_BINFO)\n+    v = iterative_hash_host_wide_int (TREE_PRIVATE (t), v);\n+  if (TYPE_P (t))\n+    v = iterative_hash_host_wide_int (TYPE_SATURATING (t)\n+\t\t\t\t      | (TYPE_ADDR_SPACE (t) << 1), v);\n+  else if (code == SSA_NAME)\n+    v = iterative_hash_host_wide_int (SSA_NAME_IS_DEFAULT_DEF (t), v);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_INT_CST))\n+    {\n+      v = iterative_hash_host_wide_int (TREE_INT_CST_LOW (t), v);\n+      v = iterative_hash_host_wide_int (TREE_INT_CST_HIGH (t), v);\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_REAL_CST))\n+    {\n+      REAL_VALUE_TYPE r = TREE_REAL_CST (t);\n+      v = iterative_hash_host_wide_int (r.cl, v);\n+      v = iterative_hash_host_wide_int (r.decimal\n+\t\t\t\t\t| (r.sign << 1)\n+\t\t\t\t\t| (r.signalling << 2)\n+\t\t\t\t\t| (r.canonical << 3), v);\n+      v = iterative_hash_host_wide_int (r.uexp, v);\n+      for (unsigned i = 0; i < SIGSZ; ++i)\n+\tv = iterative_hash_host_wide_int (r.sig[i], v);\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIXED_CST))\n+    {\n+      FIXED_VALUE_TYPE f = TREE_FIXED_CST (t);\n+      v = iterative_hash_host_wide_int (f.mode, v);\n+      v = iterative_hash_host_wide_int (f.data.low, v);\n+      v = iterative_hash_host_wide_int (f.data.high, v);\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    {\n+      v = iterative_hash_host_wide_int (DECL_MODE (t), v);\n+      v = iterative_hash_host_wide_int (DECL_NONLOCAL (t)\n+\t\t\t\t\t| (DECL_VIRTUAL_P (t) << 1)\n+\t\t\t\t\t| (DECL_IGNORED_P (t) << 2)\n+\t\t\t\t\t| (DECL_ABSTRACT (t) << 3)\n+\t\t\t\t\t| (DECL_ARTIFICIAL (t) << 4)\n+\t\t\t\t\t| (DECL_USER_ALIGN (t) << 5)\n+\t\t\t\t\t| (DECL_PRESERVE_P (t) << 6)\n+\t\t\t\t\t| (DECL_EXTERNAL (t) << 7)\n+\t\t\t\t\t| (DECL_GIMPLE_REG_P (t) << 8), v);\n+      v = iterative_hash_host_wide_int (DECL_ALIGN (t), v);\n+      if (code == LABEL_DECL)\n+\t{\n+\t  v = iterative_hash_host_wide_int (DECL_ERROR_ISSUED (t), v);\n+\t  v = iterative_hash_host_wide_int (EH_LANDING_PAD_NR (t), v);\n+\t  v = iterative_hash_host_wide_int (LABEL_DECL_UID (t), v);\n+\t}\n+      else if (code == FIELD_DECL)\n+\t{\n+\t  v = iterative_hash_host_wide_int (DECL_PACKED (t)\n+\t\t\t\t\t    | (DECL_NONADDRESSABLE_P (t) << 1),\n+\t\t\t\t\t    v);\n+\t  v = iterative_hash_host_wide_int (DECL_OFFSET_ALIGN (t), v);\n+\t}\n+      else if (code == VAR_DECL)\n+\t{\n+\t  v = iterative_hash_host_wide_int (DECL_HAS_DEBUG_EXPR_P (t)\n+\t\t\t\t\t    | (DECL_NONLOCAL_FRAME (t) << 1),\n+\t\t\t\t\t    v);\n+\t}\n+      if (code == RESULT_DECL\n+\t  || code == PARM_DECL\n+\t  || code == VAR_DECL)\n+\t{\n+\t  v = iterative_hash_host_wide_int (DECL_BY_REFERENCE (t), v);\n+\t  if (code == VAR_DECL\n+\t      || code == PARM_DECL)\n+\t    v = iterative_hash_host_wide_int (DECL_HAS_VALUE_EXPR_P (t), v);\n+\t}\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n+    v = iterative_hash_host_wide_int (DECL_REGISTER (t), v);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    {\n+      v = iterative_hash_host_wide_int (DECL_DEFER_OUTPUT (t)\n+\t\t\t\t\t| (DECL_COMMON (t) << 1)\n+\t\t\t\t\t| (DECL_DLLIMPORT_P (t) << 2)\n+\t\t\t\t\t| (DECL_WEAK (t) << 3)\n+\t\t\t\t\t| (DECL_SEEN_IN_BIND_EXPR_P (t) << 4)\n+\t\t\t\t\t| (DECL_COMDAT (t) << 5)\n+\t\t\t\t\t| (DECL_VISIBILITY_SPECIFIED (t) << 6),\n+\t\t\t\t\tv);\n+      v = iterative_hash_host_wide_int (DECL_VISIBILITY (t), v);\n+      if (code == VAR_DECL)\n+\t{\n+\t  v = iterative_hash_host_wide_int (DECL_HARD_REGISTER (t)\n+\t\t\t\t\t    | (DECL_IN_TEXT_SECTION (t) << 1)\n+\t\t\t\t\t    | (DECL_IN_CONSTANT_POOL (t) << 2),\n+\t\t\t\t\t    v);\n+\t  v = iterative_hash_host_wide_int (DECL_TLS_MODEL (t), v);\n+\t}\n+      if (VAR_OR_FUNCTION_DECL_P (t))\n+\tv = iterative_hash_host_wide_int (DECL_INIT_PRIORITY (t), v);\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    {\n+      v = iterative_hash_host_wide_int (DECL_BUILT_IN_CLASS (t), v);\n+      v = iterative_hash_host_wide_int (DECL_STATIC_CONSTRUCTOR (t)\n+\t\t\t\t\t| (DECL_STATIC_DESTRUCTOR (t) << 1)\n+\t\t\t\t\t| (DECL_UNINLINABLE (t) << 2)\n+\t\t\t\t\t| (DECL_POSSIBLY_INLINED (t) << 3)\n+\t\t\t\t\t| (DECL_IS_NOVOPS (t) << 4)\n+\t\t\t\t\t| (DECL_IS_RETURNS_TWICE (t) << 5)\n+\t\t\t\t\t| (DECL_IS_MALLOC (t) << 6)\n+\t\t\t\t\t| (DECL_IS_OPERATOR_NEW (t) << 7)\n+\t\t\t\t\t| (DECL_DECLARED_INLINE_P (t) << 8)\n+\t\t\t\t\t| (DECL_STATIC_CHAIN (t) << 9)\n+\t\t\t\t\t| (DECL_NO_INLINE_WARNING_P (t) << 10)\n+\t\t\t\t\t| (DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (t) << 11)\n+\t\t\t\t\t| (DECL_NO_LIMIT_STACK (t) << 12)\n+\t\t\t\t\t| (DECL_DISREGARD_INLINE_LIMITS (t) << 13)\n+\t\t\t\t\t| (DECL_PURE_P (t) << 14)\n+\t\t\t\t\t| (DECL_LOOPING_CONST_OR_PURE_P (t) << 15), v);\n+      if (DECL_BUILT_IN_CLASS (t) != NOT_BUILT_IN)\n+\tv = iterative_hash_host_wide_int (DECL_FUNCTION_CODE (t), v);\n+      if (DECL_STATIC_DESTRUCTOR (t))\n+\tv = iterative_hash_host_wide_int (DECL_FINI_PRIORITY (t), v);\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    {\n+      v = iterative_hash_host_wide_int (TYPE_MODE (t), v);\n+      v = iterative_hash_host_wide_int (TYPE_STRING_FLAG (t)\n+\t\t\t\t\t| (TYPE_NO_FORCE_BLK (t) << 1)\n+\t\t\t\t\t| (TYPE_NEEDS_CONSTRUCTING (t) << 2)\n+\t\t\t\t\t| (TYPE_PACKED (t) << 3)\n+\t\t\t\t\t| (TYPE_RESTRICT (t) << 4)\n+\t\t\t\t\t| (TYPE_USER_ALIGN (t) << 5)\n+\t\t\t\t\t| (TYPE_READONLY (t) << 6), v);\n+      if (RECORD_OR_UNION_TYPE_P (t))\n+\tv = iterative_hash_host_wide_int (TYPE_TRANSPARENT_AGGR (t), v);\n+      else if (code == ARRAY_TYPE)\n+\tv = iterative_hash_host_wide_int (TYPE_NONALIASED_COMPONENT (t), v);\n+      v = iterative_hash_host_wide_int (TYPE_PRECISION (t), v);\n+      v = iterative_hash_host_wide_int (TYPE_ALIGN (t), v);\n+      v = iterative_hash_host_wide_int ((TYPE_ALIAS_SET (t) == 0\n+\t\t\t\t\t || (!in_lto_p\n+\t\t\t\t\t     && get_alias_set (t) == 0))\n+\t\t\t\t\t? 0 : -1, v);\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n+    v = iterative_hash (TRANSLATION_UNIT_LANGUAGE (t),\n+\t\t\tstrlen (TRANSLATION_UNIT_LANGUAGE (t)), v);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TARGET_OPTION))\n+    v = iterative_hash (t, sizeof (struct cl_target_option), v);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_OPTIMIZATION))\n+    v = iterative_hash (t, sizeof (struct cl_optimization), v);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n+    v = iterative_hash_host_wide_int (IDENTIFIER_HASH_VALUE (t), v);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n+    v = iterative_hash (TREE_STRING_POINTER (t), TREE_STRING_LENGTH (t), v);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n+    {\n+      if (POINTER_TYPE_P (t))\n+\t{\n+\t  /* For pointers factor in the pointed-to type recursively as\n+\t     we cannot recurse through only pointers.\n+\t     ???  We can generalize this by keeping track of the\n+\t     in-SCC edges for each tree (or arbitrarily the first\n+\t     such edge) and hashing that in in a second stage\n+\t     (instead of the quadratic mixing of the SCC we do now).  */\n+\t  hashval_t x;\n+\t  unsigned ix;\n+\t  if (streamer_tree_cache_lookup (cache, TREE_TYPE (t), &ix))\n+\t    x = streamer_tree_cache_get_hash (cache, ix);\n+\t  else\n+\t    x = hash_tree (cache, TREE_TYPE (t));\n+\t  v = iterative_hash_hashval_t (x, v);\n+\t}\n+      else if (code != IDENTIFIER_NODE)\n+\tvisit (TREE_TYPE (t));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n+    for (unsigned i = 0; i < VECTOR_CST_NELTS (t); ++i)\n+      visit (VECTOR_CST_ELT (t, i));\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n+    {\n+      visit (TREE_REALPART (t));\n+      visit (TREE_IMAGPART (t));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n+    {\n+      /* Drop names that were created for anonymous entities.  */\n+      if (DECL_NAME (t)\n+\t  && TREE_CODE (DECL_NAME (t)) == IDENTIFIER_NODE\n+\t  && ANON_AGGRNAME_P (DECL_NAME (t)))\n+\t;\n+      else\n+\tvisit (DECL_NAME (t));\n+      if (DECL_FILE_SCOPE_P (t))\n+\t;\n+      else\n+\tvisit (DECL_CONTEXT (t));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    {\n+      visit (DECL_SIZE (t));\n+      visit (DECL_SIZE_UNIT (t));\n+      visit (DECL_ATTRIBUTES (t));\n+      if ((code == VAR_DECL\n+\t   || code == PARM_DECL)\n+\t  && DECL_HAS_VALUE_EXPR_P (t))\n+\tvisit (DECL_VALUE_EXPR (t));\n+      if (code == VAR_DECL\n+\t  && DECL_HAS_DEBUG_EXPR_P (t))\n+\tvisit (DECL_DEBUG_EXPR (t));\n+      /* ???  Hash DECL_INITIAL as streamed.  Needs the output-block to\n+         be able to call get_symbol_initial_value.  */\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n+    {\n+      if (code == FUNCTION_DECL)\n+\t{\n+\t  for (tree a = DECL_ARGUMENTS (t); a; a = DECL_CHAIN (a))\n+\t    visit (a);\n+\t  visit (DECL_RESULT (t));\n+\t}\n+      else if (code == TYPE_DECL)\n+\tvisit (DECL_ORIGINAL_TYPE (t));\n+      visit (DECL_VINDEX (t));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    {\n+      if (DECL_ASSEMBLER_NAME_SET_P (t))\n+\tvisit (DECL_ASSEMBLER_NAME (t));\n+      visit (DECL_SECTION_NAME (t));\n+      visit (DECL_COMDAT_GROUP (t));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n+    {\n+      visit (DECL_FIELD_OFFSET (t));\n+      visit (DECL_BIT_FIELD_TYPE (t));\n+      visit (DECL_BIT_FIELD_REPRESENTATIVE (t));\n+      visit (DECL_FIELD_BIT_OFFSET (t));\n+      visit (DECL_FCONTEXT (t));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    {\n+      visit (DECL_FUNCTION_PERSONALITY (t));\n+      visit (DECL_FUNCTION_SPECIFIC_TARGET (t));\n+      visit (DECL_FUNCTION_SPECIFIC_OPTIMIZATION (t));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    {\n+      visit (TYPE_SIZE (t));\n+      visit (TYPE_SIZE_UNIT (t));\n+      visit (TYPE_ATTRIBUTES (t));\n+      visit (TYPE_NAME (t));\n+      visit (TYPE_MAIN_VARIANT (t));\n+      if (TYPE_FILE_SCOPE_P (t))\n+\t;\n+      else\n+\tvisit (TYPE_CONTEXT (t));\n+      visit (TYPE_STUB_DECL (t));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n+    {\n+      if (code == ENUMERAL_TYPE)\n+\tvisit (TYPE_VALUES (t));\n+      else if (code == ARRAY_TYPE)\n+\tvisit (TYPE_DOMAIN (t));\n+      else if (RECORD_OR_UNION_TYPE_P (t))\n+\tfor (tree f = TYPE_FIELDS (t); f; f = TREE_CHAIN (f))\n+\t  visit (f);\n+      else if (code == FUNCTION_TYPE\n+\t       || code == METHOD_TYPE)\n+\tvisit (TYPE_ARG_TYPES (t));\n+      if (!POINTER_TYPE_P (t))\n+\tvisit (TYPE_MINVAL (t));\n+      visit (TYPE_MAXVAL (t));\n+      if (RECORD_OR_UNION_TYPE_P (t))\n+\tvisit (TYPE_BINFO (t));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n+    {\n+      visit (TREE_PURPOSE (t));\n+      visit (TREE_VALUE (t));\n+      visit (TREE_CHAIN (t));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    for (int i = 0; i < TREE_VEC_LENGTH (t); ++i)\n+      visit (TREE_VEC_ELT (t, i));\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n+    {\n+      v = iterative_hash_host_wide_int (TREE_OPERAND_LENGTH (t), v);\n+      for (int i = 0; i < TREE_OPERAND_LENGTH (t); ++i)\n+\tvisit (TREE_OPERAND (t, i));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    {\n+      unsigned i;\n+      tree b;\n+      FOR_EACH_VEC_ELT (*BINFO_BASE_BINFOS (t), i, b)\n+\tvisit (b);\n+      visit (BINFO_OFFSET (t));\n+      visit (BINFO_VTABLE (t));\n+      visit (BINFO_VPTR_FIELD (t));\n+      FOR_EACH_VEC_SAFE_ELT (BINFO_BASE_ACCESSES (t), i, b)\n+\tvisit (b);\n+      visit (BINFO_INHERITANCE_CHAIN (t));\n+      visit (BINFO_SUBVTT_INDEX (t));\n+      visit (BINFO_VPTR_INDEX (t));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n+    {\n+      unsigned i;\n+      tree index, value;\n+      v = iterative_hash_host_wide_int (CONSTRUCTOR_NELTS (t), v);\n+      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t), i, index, value)\n+\t{\n+\t  visit (index);\n+\t  visit (value);\n+\t}\n+    }\n+\n+  return v;\n+\n+#undef visit\n+}\n+\n+/* Compare two SCC entries by their hash value for qsorting them.  */\n+\n+static int\n+scc_entry_compare (const void *p1_, const void *p2_)\n+{\n+  const scc_entry *p1 = (const scc_entry *) p1_;\n+  const scc_entry *p2 = (const scc_entry *) p2_;\n+  if (p1->hash < p2->hash)\n+    return -1;\n+  else if (p1->hash > p2->hash)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return a hash value for the SCC on the SCC stack from FIRST with\n+   size SIZE.  */\n+\n+static hashval_t\n+hash_scc (struct streamer_tree_cache_d *cache, unsigned first, unsigned size)\n+{\n+  /* Compute hash values for the SCC members.  */\n+  for (unsigned i = 0; i < size; ++i)\n+    sccstack[first+i].hash = hash_tree (cache, sccstack[first+i].t);\n+\n+  if (size == 1)\n+    return sccstack[first].hash;\n+\n+  /* Sort the SCC of type, hash pairs so that when we mix in\n+     all members of the SCC the hash value becomes independent on\n+     the order we visited the SCC.  Disregard hashes equal to\n+     the hash of the tree we mix into because we cannot guarantee\n+     a stable sort for those across different TUs.  */\n+  qsort (&sccstack[first], size, sizeof (scc_entry), scc_entry_compare);\n+  hashval_t *tem = XALLOCAVEC (hashval_t, size);\n+  for (unsigned i = 0; i < size; ++i)\n+    {\n+      hashval_t hash = sccstack[first+i].hash;\n+      hashval_t orig_hash = hash;\n+      unsigned j;\n+      /* Skip same hashes.  */\n+      for (j = i + 1;\n+\t   j < size && sccstack[first+j].hash == orig_hash; ++j)\n+\t;\n+      for (; j < size; ++j)\n+\thash = iterative_hash_hashval_t (sccstack[first+j].hash, hash);\n+      for (j = 0; sccstack[first+j].hash != orig_hash; ++j)\n+\thash = iterative_hash_hashval_t (sccstack[first+j].hash, hash);\n+      tem[i] = hash;\n+    }\n+  hashval_t scc_hash = 0;\n+  for (unsigned i = 0; i < size; ++i)\n+    {\n+      sccstack[first+i].hash = tem[i];\n+      scc_hash = iterative_hash_hashval_t (tem[i], scc_hash);\n+    }\n+  return scc_hash;\n+}\n+\n+/* DFS walk EXPR and stream SCCs of tree bodies if they are not\n+   already in the streamer cache.  Main routine called for\n+   each visit of EXPR.  */\n+\n+static void\n+DFS_write_tree (struct output_block *ob, sccs *from_state,\n+\t\ttree expr, bool ref_p, bool this_ref_p)\n+{\n+  unsigned ix;\n+  sccs **slot;\n+\n+  /* Handle special cases.  */\n+  if (expr == NULL_TREE)\n+    return;\n+\n+  /* Do not DFS walk into indexable trees.  */\n+  if (this_ref_p && tree_is_indexable (expr))\n+    return;\n+\n+  /* Check if we already streamed EXPR.  */\n+  if (streamer_tree_cache_lookup (ob->writer_cache, expr, &ix))\n+    return;\n+\n+  slot = (sccs **)pointer_map_insert (sccstate, expr);\n+  sccs *cstate = *slot;\n+  if (!cstate)\n+    {\n+      scc_entry e = { expr, 0 };\n+      /* Not yet visited.  DFS recurse and push it onto the stack.  */\n+      *slot = cstate = XOBNEW (&sccstate_obstack, struct sccs);\n+      sccstack.safe_push (e);\n+      cstate->dfsnum = next_dfs_num++;\n+      cstate->low = cstate->dfsnum;\n+\n+      if (streamer_handle_as_builtin_p (expr))\n+\t;\n+      else if (TREE_CODE (expr) == INTEGER_CST\n+\t       && !TREE_OVERFLOW (expr))\n+\tDFS_write_tree (ob, cstate, TREE_TYPE (expr), ref_p, ref_p);\n+      else\n+\t{\n+\t  DFS_write_tree_body (ob, expr, cstate, ref_p);\n+\n+\t  /* Walk any LTO-specific edges.  */\n+\t  if (DECL_P (expr)\n+\t      && TREE_CODE (expr) != FUNCTION_DECL\n+\t      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n+\t    {\n+\t      /* Handle DECL_INITIAL for symbols.  */\n+\t      tree initial = get_symbol_initial_value (ob, expr);\n+\t      DFS_write_tree (ob, cstate, initial, ref_p, ref_p);\n+\t    }\n+\t}\n+\n+      /* See if we found an SCC.  */\n+      if (cstate->low == cstate->dfsnum)\n+\t{\n+\t  unsigned first, size;\n+\t  tree x;\n+\n+\t  /* Pop the SCC and compute its size.  */\n+\t  first = sccstack.length ();\n+\t  do\n+\t    {\n+\t      x = sccstack[--first].t;\n+\t    }\n+\t  while (x != expr);\n+\t  size = sccstack.length () - first;\n+\n+\t  /* No need to compute hashes for LTRANS units, we don't perform\n+\t     any merging there.  */\n+\t  hashval_t scc_hash = 0;\n+\t  unsigned scc_entry_len = 0;\n+\t  if (!flag_wpa)\n+\t    {\n+\t      scc_hash = hash_scc (ob->writer_cache, first, size);\n+\n+\t      /* Put the entries with the least number of collisions first.  */\n+\t      unsigned entry_start = 0;\n+\t      scc_entry_len = size + 1;\n+\t      for (unsigned i = 0; i < size;)\n+\t\t{\n+\t\t  unsigned from = i;\n+\t\t  for (i = i + 1; i < size\n+\t\t       && (sccstack[first + i].hash\n+\t\t\t   == sccstack[first + from].hash); ++i)\n+\t\t    ;\n+\t\t  if (i - from < scc_entry_len)\n+\t\t    {\n+\t\t      scc_entry_len = i - from;\n+\t\t      entry_start = from;\n+\t\t    }\n+\t\t}\n+\t      for (unsigned i = 0; i < scc_entry_len; ++i)\n+\t\t{\n+\t\t  scc_entry tem = sccstack[first + i];\n+\t\t  sccstack[first + i] = sccstack[first + entry_start + i];\n+\t\t  sccstack[first + entry_start + i] = tem;\n+\t\t}\n+\t    }\n+\n+\t  /* Write LTO_tree_scc.  */\n+\t  streamer_write_record_start (ob, LTO_tree_scc);\n+\t  streamer_write_uhwi (ob, size);\n+\t  streamer_write_uhwi (ob, scc_hash);\n+\n+\t  /* Write size-1 SCCs without wrapping them inside SCC bundles.\n+\t     All INTEGER_CSTs need to be handled this way as we need\n+\t     their type to materialize them.  Also builtins are handled\n+\t     this way.\n+\t     ???  We still wrap these in LTO_tree_scc so at the\n+\t     input side we can properly identify the tree we want\n+\t     to ultimatively return.  */\n+\t  size_t old_len = ob->writer_cache->nodes.length ();\n+\t  if (size == 1)\n+\t    lto_output_tree_1 (ob, expr, scc_hash, ref_p, this_ref_p);\n+\t  else\n+\t    {\n+\t      /* Write the size of the SCC entry candidates.  */\n+\t      streamer_write_uhwi (ob, scc_entry_len);\n+\n+\t      /* Write all headers and populate the streamer cache.  */\n+\t      for (unsigned i = 0; i < size; ++i)\n+\t\t{\n+\t\t  hashval_t hash = sccstack[first+i].hash;\n+\t\t  tree t = sccstack[first+i].t;\n+\t\t  bool exists_p = streamer_tree_cache_insert (ob->writer_cache,\n+\t\t\t\t\t\t\t      t, hash, &ix);\n+\t\t  gcc_assert (!exists_p);\n+\n+\t\t  if (!lto_is_streamable (t))\n+\t\t    internal_error (\"tree code %qs is not supported \"\n+\t\t\t\t    \"in LTO streams\",\n+\t\t\t\t    tree_code_name[TREE_CODE (t)]);\n+\n+\t\t  gcc_checking_assert (!streamer_handle_as_builtin_p (t));\n+\n+\t\t  /* Write the header, containing everything needed to\n+\t\t     materialize EXPR on the reading side.  */\n+\t\t  streamer_write_tree_header (ob, t);\n+\t\t}\n+\n+\t      /* Write the bitpacks and tree references.  */\n+\t      for (unsigned i = 0; i < size; ++i)\n+\t\t{\n+\t\t  lto_write_tree_1 (ob, sccstack[first+i].t, ref_p);\n+\n+\t\t  /* Mark the end of the tree.  */\n+\t\t  streamer_write_zero (ob);\n+\t\t}\n+\t    }\n+\t  gcc_assert (old_len + size == ob->writer_cache->nodes.length ());\n+\n+\t  /* Finally truncate the vector.  */\n+\t  sccstack.truncate (first);\n+\n+\t  if (from_state)\n+\t    from_state->low = MIN (from_state->low, cstate->low);\n+\t  return;\n+\t}\n+\n+      if (from_state)\n+\tfrom_state->low = MIN (from_state->low, cstate->low);\n+    }\n+  gcc_checking_assert (from_state);\n+  if (cstate->dfsnum < from_state->dfsnum)\n+    from_state->low = MIN (cstate->dfsnum, from_state->low);\n+}\n+\n \n /* Emit the physical representation of tree node EXPR to output block\n    OB.  If THIS_REF_P is true, the leaves of EXPR are emitted as references\n@@ -374,16 +1306,7 @@ lto_output_tree (struct output_block *ob, tree expr,\n       return;\n     }\n \n-  /* Shared INTEGER_CST nodes are special because they need their original type\n-     to be materialized by the reader (to implement TYPE_CACHED_VALUES).  */\n-  if (TREE_CODE (expr) == INTEGER_CST\n-      && !TREE_OVERFLOW (expr))\n-    {\n-      streamer_write_integer_cst (ob, expr, ref_p);\n-      return;\n-    }\n-\n-  existed_p = streamer_tree_cache_insert (ob->writer_cache, expr, &ix);\n+  existed_p = streamer_tree_cache_lookup (ob->writer_cache, expr, &ix);\n   if (existed_p)\n     {\n       /* If a node has already been streamed out, make sure that\n@@ -393,21 +1316,42 @@ lto_output_tree (struct output_block *ob, tree expr,\n       streamer_write_uhwi (ob, ix);\n       streamer_write_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS,\n \t\t\t   lto_tree_code_to_tag (TREE_CODE (expr)));\n-    }\n-  else if (streamer_handle_as_builtin_p (expr))\n-    {\n-      /* MD and NORMAL builtins do not need to be written out\n-\t completely as they are always instantiated by the\n-\t compiler on startup.  The only builtins that need to\n-\t be written out are BUILT_IN_FRONTEND.  For all other\n-\t builtins, we simply write the class and code.  */\n-      streamer_write_builtin (ob, expr);\n+      lto_stats.num_pickle_refs_output++;\n     }\n   else\n     {\n-      /* This is the first time we see EXPR, write its fields\n-\t to OB.  */\n-      lto_write_tree (ob, expr, ref_p);\n+      /* This is the first time we see EXPR, write all reachable\n+\t trees to OB.  */\n+      static bool in_dfs_walk;\n+\n+      /* Protect against recursion which means disconnect between\n+         what tree edges we walk in the DFS walk and what edges\n+\t we stream out.  */\n+      gcc_assert (!in_dfs_walk);\n+\n+      /* Start the DFS walk.  */\n+      /* Save ob state ... */\n+      /* let's see ... */\n+      in_dfs_walk = true;\n+      sccstate = pointer_map_create ();\n+      gcc_obstack_init (&sccstate_obstack);\n+      next_dfs_num = 1;\n+      DFS_write_tree (ob, NULL, expr, ref_p, this_ref_p);\n+      sccstack.release ();\n+      pointer_map_destroy (sccstate);\n+      obstack_free (&sccstate_obstack, NULL);\n+      in_dfs_walk = false;\n+\n+      /* Finally append a reference to the tree we were writing.\n+\t ???  If expr ended up as a singleton we could have\n+\t inlined it here and avoid outputting a reference.  */\n+      existed_p = streamer_tree_cache_lookup (ob->writer_cache, expr, &ix);\n+      gcc_assert (existed_p);\n+      streamer_write_record_start (ob, LTO_tree_pickle_reference);\n+      streamer_write_uhwi (ob, ix);\n+      streamer_write_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS,\n+\t\t\t   lto_tree_code_to_tag (TREE_CODE (expr)));\n+      lto_stats.num_pickle_refs_output++;\n     }\n }\n "}, {"sha": "e7b66c167b5345b1490bdaaf57980b79b58f3c58", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -227,6 +227,13 @@ print_lto_report (const char *s)\n \t       HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n \t       lto_stats.num_output_symtab_nodes);\n \n+      fprintf (stderr, \"[%s] # of output tree pickle references: \"\n+\t       HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n+\t       lto_stats.num_pickle_refs_output);\n+      fprintf (stderr, \"[%s] # of output tree bodies: \"\n+\t       HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n+\t       lto_stats.num_tree_bodies_output);\n+\n       fprintf (stderr, \"[%s] # callgraph partitions: \"\n \t       HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n \t       lto_stats.num_cgraph_partitions);"}, {"sha": "58a7f580dfff7343ab9cb105982e96008d710968", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -199,6 +199,9 @@ enum LTO_tags\n   /* EH try/catch node.  */\n   LTO_eh_catch,\n \n+  /* Special for global streamer.  A blob of unnamed tree nodes.  */\n+  LTO_tree_scc,\n+\n   /* References to indexable tree nodes.  These objects are stored in\n      tables that are written separately from the function bodies that\n      reference them.  This way they can be instantiated even when the\n@@ -421,6 +424,8 @@ struct lto_stats_d\n   unsigned HOST_WIDE_INT num_compressed_il_bytes;\n   unsigned HOST_WIDE_INT num_input_il_bytes;\n   unsigned HOST_WIDE_INT num_uncompressed_il_bytes;\n+  unsigned HOST_WIDE_INT num_tree_bodies_output;\n+  unsigned HOST_WIDE_INT num_pickle_refs_output;\n };\n \n /* Entry of LTO symtab encoder.  */\n@@ -854,6 +859,10 @@ tree lto_input_tree_ref (struct lto_input_block *, struct data_in *,\n \t\t\t struct function *, enum LTO_tags);\n void lto_tag_check_set (enum LTO_tags, int, ...);\n void lto_init_eh (void);\n+hashval_t lto_input_scc (struct lto_input_block *, struct data_in *,\n+\t\t\t unsigned *, unsigned *);\n+tree lto_input_tree_1 (struct lto_input_block *, struct data_in *,\n+\t\t       enum LTO_tags, hashval_t hash);\n tree lto_input_tree (struct lto_input_block *, struct data_in *);\n \n "}, {"sha": "6c980f89f2d6170423006233d84181f6b5ef8082", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -97,7 +97,8 @@ lto_varpool_replace_node (struct varpool_node *vnode,\n   ipa_clone_referring ((symtab_node)prevailing_node, &vnode->symbol.ref_list);\n \n   /* Be sure we can garbage collect the initializer.  */\n-  if (DECL_INITIAL (vnode->symbol.decl))\n+  if (DECL_INITIAL (vnode->symbol.decl)\n+      && vnode->symbol.decl != prevailing_node->symbol.decl)\n     DECL_INITIAL (vnode->symbol.decl) = error_mark_node;\n   /* Finally remove the replaced node.  */\n   varpool_remove_node (vnode);"}, {"sha": "8e5c160ea6daf48dea9a1925b9839e656f8bf9b0", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -1,3 +1,38 @@\n+2013-06-17  Richard Biener  <rguenther@suse.de>\n+\n+\t* Make-lang.in (lto.o): Add $(DATA_STREAMER_H) dependency.\n+\t* lto.c: Include data-streamer.h.\n+\t(lto_read_in_decl_state): Use streamer_tree_cache_get_tree.\n+\t(gimple_type_leader_entry_s, gimple_type_leader,\n+\tgimple_lookup_type_leader): Remove.\n+\t(gtc_visit): Simplify.\n+\t(gimple_types_compatible_p): Likewise.\n+\t(gimple_register_type_1): Likewise.  Merge into ...\n+\t(gimple_register_type): ... this.  Keep it as legacy for\n+\tstatistics purposes for now.\n+\t(fixup_integer_cst): Remove.\n+\t(LTO_FIXUP_TREE, lto_fixup_types, lto_ft_*): Simplify and\n+\trename to ...\n+\t(MAYBE_REMEMBER_WITH_VARS, maybe_remember_with_vars,\n+\tmaybe_remember_with_vars_*): ... these.\n+\t(uniquify_nodes): Remove.\n+\t(lto_fixup_prevailing_type): New function.\n+\t(struct tree_scc, struct tree_scc_hasher): New type and hasher.\n+\t(tree_scc_hash, tree_scc_hash_obstack): New globals.\n+\t(num_merged_types, num_prevailing_types, num_not_merged_types,\n+\tnum_not_merged_types_in_same_scc, total_scc_size, num_sccs_read,\n+\ttotal_scc_size_merged, num_sccs_merged, num_scc_compares,\n+\tnum_scc_compare_collisions): New global counters.\n+\t(compare_tree_sccs_1): New function.\n+\t(compare_tree_sccs): Likewise.\n+\t(unify_scc): Likewise.\n+\t(lto_read_decls): Stream in tree SCCs and unify them on the\n+\tway in.  Finalize prevailing SCC tree members.\n+\t(read_cgraph_and_symbols): Do not initialize or free gimple_type_leader.\n+\tAllocate and free tree_scc_hash_obstack and tree_scc_hash, do not bother\n+\tto ggc-collect during merging.\n+\t(print_lto_report_1): Adjust for new merging code.\n+\n 2013-06-12  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (read_cgraph_and_symbols): Set cgraph into streaming state."}, {"sha": "5f2f475879a94e36055b3c2cc08722d746e9671b", "filename": "gcc/lto/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FMake-lang.in?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -85,7 +85,7 @@ lto/lto.o: lto/lto.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(OPTS_H) \\\n \tlanghooks.h $(VEC_H) $(BITMAP_H) pointer-set.h $(IPA_PROP_H) \\\n \t$(COMMON_H) debug.h $(GIMPLE_H) $(LTO_H) $(LTO_TREE_H) \\\n \t$(LTO_TAGS_H) $(LTO_STREAMER_H) $(SPLAY_TREE_H) gt-lto-lto.h \\\n-\t$(TREE_STREAMER_H) lto/lto-partition.h\n+\t$(TREE_STREAMER_H) $(DATA_STREAMER_H) lto/lto-partition.h\n lto/lto-partition.o: lto/lto-partition.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \ttoplev.h $(TREE_H) $(TM_H) \\\n \t$(CGRAPH_H) $(TIMEVAR_H) \\"}, {"sha": "065443cc1a2d3c17e602b3b4c9fb309187f5742f", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 940, "deletions": 439, "changes": 1379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-streamer.h\"\n #include \"splay-tree.h\"\n #include \"lto-partition.h\"\n+#include \"data-streamer.h\"\n \n static GTY(()) tree first_personality_decl;\n \n@@ -254,7 +255,7 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n   uint32_t i, j;\n \n   ix = *data++;\n-  decl = streamer_tree_cache_get (data_in->reader_cache, ix);\n+  decl = streamer_tree_cache_get_tree (data_in->reader_cache, ix);\n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n       gcc_assert (decl == void_type_node);\n@@ -268,7 +269,7 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n       tree *decls = ggc_alloc_vec_tree (size);\n \n       for (j = 0; j < size; j++)\n-\tdecls[j] = streamer_tree_cache_get (data_in->reader_cache, data[j]);\n+\tdecls[j] = streamer_tree_cache_get_tree (data_in->reader_cache, data[j]);\n \n       state->streams[i].size = size;\n       state->streams[i].trees = decls;\n@@ -280,6 +281,9 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n \n \n \n+/* ???  Old hashing and merging code follows, we keep it for statistics\n+   purposes for now.  */\n+\n /* Global type table.  FIXME, it should be possible to re-use some\n    of the type hashing routines in tree.c (type_hash_canon, type_hash_lookup,\n    etc), but those assume that types were built with the various\n@@ -366,33 +370,6 @@ struct sccs\n static unsigned int next_dfs_num;\n static unsigned int gtc_next_dfs_num;\n \n-/* GIMPLE type merging cache.  A direct-mapped cache based on TYPE_UID.  */\n-\n-typedef struct GTY(()) gimple_type_leader_entry_s {\n-  tree type;\n-  tree leader;\n-} gimple_type_leader_entry;\n-\n-#define GIMPLE_TYPE_LEADER_SIZE 16381\n-static GTY((length(\"GIMPLE_TYPE_LEADER_SIZE\")))\n-  gimple_type_leader_entry *gimple_type_leader;\n-\n-/* Lookup an existing leader for T and return it or NULL_TREE, if\n-   there is none in the cache.  */\n-\n-static inline tree\n-gimple_lookup_type_leader (tree t)\n-{\n-  gimple_type_leader_entry *leader;\n-\n-  leader = &gimple_type_leader[TYPE_UID (t) % GIMPLE_TYPE_LEADER_SIZE];\n-  if (leader->type != t)\n-    return NULL_TREE;\n-\n-  return leader->leader;\n-}\n-\n-\n /* Return true if T1 and T2 have the same name.  If FOR_COMPLETION_P is\n    true then if any type has no name return false, otherwise return\n    true if both types have no names.  */\n@@ -450,7 +427,6 @@ gtc_visit (tree t1, tree t2,\n   struct sccs *cstate = NULL;\n   type_pair_t p;\n   void **slot;\n-  tree leader1, leader2;\n \n   /* Check first for the obvious case of pointer identity.  */\n   if (t1 == t2)\n@@ -507,15 +483,6 @@ gtc_visit (tree t1, tree t2,\n       /* For other types fall through to more complex checks.  */\n     }\n \n-  /* If the types have been previously registered and found equal\n-     they still are.  */\n-  leader1 = gimple_lookup_type_leader (t1);\n-  leader2 = gimple_lookup_type_leader (t2);\n-  if (leader1 == t2\n-      || t1 == leader2\n-      || (leader1 && leader1 == leader2))\n-    return true;\n-\n   /* If the hash values of t1 and t2 are different the types can't\n      possibly be the same.  This helps keeping the type-pair hashtable\n      small, only tracking comparisons for hash collisions.  */\n@@ -879,7 +846,6 @@ gimple_types_compatible_p (tree t1, tree t2)\n   struct obstack sccstate_obstack;\n   type_pair_t p = NULL;\n   bool res;\n-  tree leader1, leader2;\n \n   /* Before starting to set up the SCC machinery handle simple cases.  */\n \n@@ -938,15 +904,6 @@ gimple_types_compatible_p (tree t1, tree t2)\n       /* For other types fall through to more complex checks.  */\n     }\n \n-  /* If the types have been previously registered and found equal\n-     they still are.  */\n-  leader1 = gimple_lookup_type_leader (t1);\n-  leader2 = gimple_lookup_type_leader (t2);\n-  if (leader1 == t2\n-      || t1 == leader2\n-      || (leader1 && leader1 == leader2))\n-    return true;\n-\n   /* If the hash values of t1 and t2 are different the types can't\n      possibly be the same.  This helps keeping the type-pair hashtable\n      small, only tracking comparisons for hash collisions.  */\n@@ -1335,68 +1292,25 @@ gimple_type_eq (const void *p1, const void *p2)\n \t\t\t\t    CONST_CAST_TREE (t2));\n }\n \n-\n-/* Worker for gimple_register_type.\n-   Register type T in the global type table gimple_types.\n-   When REGISTERING_MV is false first recurse for the main variant of T.  */\n+/* Register type T in the global type table gimple_types.  */\n \n static tree\n-gimple_register_type_1 (tree t, bool registering_mv)\n+gimple_register_type (tree t)\n {\n   void **slot;\n-  gimple_type_leader_entry *leader;\n-\n-  /* If we registered this type before return the cached result.  */\n-  leader = &gimple_type_leader[TYPE_UID (t) % GIMPLE_TYPE_LEADER_SIZE];\n-  if (leader->type == t)\n-    return leader->leader;\n-\n-  /* Always register the main variant first.  This is important so we\n-     pick up the non-typedef variants as canonical, otherwise we'll end\n-     up taking typedef ids for structure tags during comparison.\n-     It also makes sure that main variants will be merged to main variants.\n-     As we are operating on a possibly partially fixed up type graph\n-     do not bother to recurse more than once, otherwise we may end up\n-     walking in circles.\n-     If we are registering a main variant it will either remain its\n-     own main variant or it will be merged to something else in which\n-     case we do not care for the main variant leader.  */\n-  if (!registering_mv\n-      && TYPE_MAIN_VARIANT (t) != t)\n-    gimple_register_type_1 (TYPE_MAIN_VARIANT (t), true);\n \n   /* See if we already have an equivalent type registered.  */\n   slot = htab_find_slot (gimple_types, t, INSERT);\n   if (*slot\n       && *(tree *)slot != t)\n-    {\n-      tree new_type = (tree) *((tree *) slot);\n-      leader->type = t;\n-      leader->leader = new_type;\n-      return new_type;\n-    }\n+    return (tree) *((tree *) slot);\n \n   /* If not, insert it to the cache and the hash.  */\n-  leader->type = t;\n-  leader->leader = t;\n   *slot = (void *) t;\n   return t;\n }\n \n-/* Register type T in the global type table gimple_types.\n-   If another type T', compatible with T, already existed in\n-   gimple_types then return T', otherwise return T.  This is used by\n-   LTO to merge identical types read from different TUs.  */\n-\n-static tree\n-gimple_register_type (tree t)\n-{\n-  gcc_assert (TYPE_P (t));\n-  return gimple_register_type_1 (t, false);\n-}\n-\n-#define GIMPLE_REGISTER_TYPE(tt) \\\n-   (TREE_VISITED (tt) ? gimple_register_type (tt) : tt)\n+/* End of old merging code.  */\n \n \n \n@@ -1413,220 +1327,173 @@ remember_with_vars (tree t)\n   *(tree *) htab_find_slot (tree_with_vars, t, INSERT) = t;\n }\n \n-#define LTO_FIXUP_TREE(tt) \\\n+#define MAYBE_REMEMBER_WITH_VARS(tt) \\\n   do \\\n     { \\\n       if (tt) \\\n \t{ \\\n-\t  if (TYPE_P (tt)) \\\n-\t    (tt) = GIMPLE_REGISTER_TYPE (tt); \\\n \t  if (VAR_OR_FUNCTION_DECL_P (tt) && TREE_PUBLIC (tt)) \\\n \t    remember_with_vars (t); \\\n-\t  if (TREE_CODE (tt) == INTEGER_CST) \\\n-\t    (tt) = fixup_integer_cst (tt); \\\n \t} \\\n     } while (0)\n \n-static void lto_fixup_types (tree);\n-\n-/* Return integer_cst T with updated type.  */\n-\n-static tree\n-fixup_integer_cst (tree t)\n-{\n-  tree type = GIMPLE_REGISTER_TYPE (TREE_TYPE (t));\n-\n-  if (type == TREE_TYPE (t))\n-    return t;\n-\n-  /* If overflow was set, streamer_read_integer_cst\n-     produced local copy of T. */\n-  if (TREE_OVERFLOW (t))\n-    {\n-      TREE_TYPE (t) = type;\n-      return t;\n-    }\n-  else\n-  /* Otherwise produce new shared node for the new type.  */\n-    return build_int_cst_wide (type, TREE_INT_CST_LOW (t),\n-\t\t\t       TREE_INT_CST_HIGH (t));\n-}\n-\n /* Fix up fields of a tree_typed T.  */\n \n static void\n-lto_ft_typed (tree t)\n+maybe_remember_with_vars_typed (tree t)\n {\n-  LTO_FIXUP_TREE (TREE_TYPE (t));\n+  MAYBE_REMEMBER_WITH_VARS (TREE_TYPE (t));\n }\n \n /* Fix up fields of a tree_common T.  */\n \n static void\n-lto_ft_common (tree t)\n+maybe_remember_with_vars_common (tree t)\n {\n-  lto_ft_typed (t);\n-  LTO_FIXUP_TREE (TREE_CHAIN (t));\n+  maybe_remember_with_vars_typed (t);\n+  MAYBE_REMEMBER_WITH_VARS (TREE_CHAIN (t));\n }\n \n /* Fix up fields of a decl_minimal T.  */\n \n static void\n-lto_ft_decl_minimal (tree t)\n+maybe_remember_with_vars_decl_minimal (tree t)\n {\n-  lto_ft_common (t);\n-  LTO_FIXUP_TREE (DECL_NAME (t));\n-  LTO_FIXUP_TREE (DECL_CONTEXT (t));\n+  maybe_remember_with_vars_common (t);\n+  MAYBE_REMEMBER_WITH_VARS (DECL_NAME (t));\n+  MAYBE_REMEMBER_WITH_VARS (DECL_CONTEXT (t));\n }\n \n /* Fix up fields of a decl_common T.  */\n \n static void\n-lto_ft_decl_common (tree t)\n+maybe_remember_with_vars_decl_common (tree t)\n {\n-  lto_ft_decl_minimal (t);\n-  LTO_FIXUP_TREE (DECL_SIZE (t));\n-  LTO_FIXUP_TREE (DECL_SIZE_UNIT (t));\n-  LTO_FIXUP_TREE (DECL_INITIAL (t));\n-  LTO_FIXUP_TREE (DECL_ATTRIBUTES (t));\n-  LTO_FIXUP_TREE (DECL_ABSTRACT_ORIGIN (t));\n+  maybe_remember_with_vars_decl_minimal (t);\n+  MAYBE_REMEMBER_WITH_VARS (DECL_SIZE (t));\n+  MAYBE_REMEMBER_WITH_VARS (DECL_SIZE_UNIT (t));\n+  MAYBE_REMEMBER_WITH_VARS (DECL_INITIAL (t));\n+  MAYBE_REMEMBER_WITH_VARS (DECL_ATTRIBUTES (t));\n+  MAYBE_REMEMBER_WITH_VARS (DECL_ABSTRACT_ORIGIN (t));\n }\n \n /* Fix up fields of a decl_with_vis T.  */\n \n static void\n-lto_ft_decl_with_vis (tree t)\n+maybe_remember_with_vars_decl_with_vis (tree t)\n {\n-  lto_ft_decl_common (t);\n+  maybe_remember_with_vars_decl_common (t);\n \n   /* Accessor macro has side-effects, use field-name here. */\n-  LTO_FIXUP_TREE (t->decl_with_vis.assembler_name);\n-  LTO_FIXUP_TREE (DECL_SECTION_NAME (t));\n+  MAYBE_REMEMBER_WITH_VARS (t->decl_with_vis.assembler_name);\n+  MAYBE_REMEMBER_WITH_VARS (DECL_SECTION_NAME (t));\n }\n \n /* Fix up fields of a decl_non_common T.  */\n \n static void\n-lto_ft_decl_non_common (tree t)\n+maybe_remember_with_vars_decl_non_common (tree t)\n {\n-  lto_ft_decl_with_vis (t);\n-  LTO_FIXUP_TREE (DECL_ARGUMENT_FLD (t));\n-  LTO_FIXUP_TREE (DECL_RESULT_FLD (t));\n-  LTO_FIXUP_TREE (DECL_VINDEX (t));\n-  /* The C frontends may create exact duplicates for DECL_ORIGINAL_TYPE\n-     like for 'typedef enum foo foo'.  We have no way of avoiding to\n-     merge them and dwarf2out.c cannot deal with this,\n-     so fix this up by clearing DECL_ORIGINAL_TYPE in this case.  */\n-  if (TREE_CODE (t) == TYPE_DECL\n-      && DECL_ORIGINAL_TYPE (t) == TREE_TYPE (t))\n-    DECL_ORIGINAL_TYPE (t) = NULL_TREE;\n+  maybe_remember_with_vars_decl_with_vis (t);\n+  MAYBE_REMEMBER_WITH_VARS (DECL_ARGUMENT_FLD (t));\n+  MAYBE_REMEMBER_WITH_VARS (DECL_RESULT_FLD (t));\n+  MAYBE_REMEMBER_WITH_VARS (DECL_VINDEX (t));\n }\n \n /* Fix up fields of a decl_non_common T.  */\n \n static void\n-lto_ft_function (tree t)\n+maybe_remember_with_vars_function (tree t)\n {\n-  lto_ft_decl_non_common (t);\n-  LTO_FIXUP_TREE (DECL_FUNCTION_PERSONALITY (t));\n+  maybe_remember_with_vars_decl_non_common (t);\n+  MAYBE_REMEMBER_WITH_VARS (DECL_FUNCTION_PERSONALITY (t));\n }\n \n /* Fix up fields of a field_decl T.  */\n \n static void\n-lto_ft_field_decl (tree t)\n+maybe_remember_with_vars_field_decl (tree t)\n {\n-  lto_ft_decl_common (t);\n-  LTO_FIXUP_TREE (DECL_FIELD_OFFSET (t));\n-  LTO_FIXUP_TREE (DECL_BIT_FIELD_TYPE (t));\n-  LTO_FIXUP_TREE (DECL_QUALIFIER (t));\n-  LTO_FIXUP_TREE (DECL_FIELD_BIT_OFFSET (t));\n-  LTO_FIXUP_TREE (DECL_FCONTEXT (t));\n+  maybe_remember_with_vars_decl_common (t);\n+  MAYBE_REMEMBER_WITH_VARS (DECL_FIELD_OFFSET (t));\n+  MAYBE_REMEMBER_WITH_VARS (DECL_BIT_FIELD_TYPE (t));\n+  MAYBE_REMEMBER_WITH_VARS (DECL_QUALIFIER (t));\n+  MAYBE_REMEMBER_WITH_VARS (DECL_FIELD_BIT_OFFSET (t));\n+  MAYBE_REMEMBER_WITH_VARS (DECL_FCONTEXT (t));\n }\n \n /* Fix up fields of a type T.  */\n \n static void\n-lto_ft_type (tree t)\n+maybe_remember_with_vars_type (tree t)\n {\n-  lto_ft_common (t);\n-  LTO_FIXUP_TREE (TYPE_CACHED_VALUES (t));\n-  LTO_FIXUP_TREE (TYPE_SIZE (t));\n-  LTO_FIXUP_TREE (TYPE_SIZE_UNIT (t));\n-  LTO_FIXUP_TREE (TYPE_ATTRIBUTES (t));\n-  LTO_FIXUP_TREE (TYPE_NAME (t));\n+  maybe_remember_with_vars_common (t);\n+  MAYBE_REMEMBER_WITH_VARS (TYPE_CACHED_VALUES (t));\n+  MAYBE_REMEMBER_WITH_VARS (TYPE_SIZE (t));\n+  MAYBE_REMEMBER_WITH_VARS (TYPE_SIZE_UNIT (t));\n+  MAYBE_REMEMBER_WITH_VARS (TYPE_ATTRIBUTES (t));\n+  MAYBE_REMEMBER_WITH_VARS (TYPE_NAME (t));\n \n   /* Accessors are for derived node types only. */\n   if (!POINTER_TYPE_P (t))\n-    LTO_FIXUP_TREE (TYPE_MINVAL (t));\n-  LTO_FIXUP_TREE (TYPE_MAXVAL (t));\n+    MAYBE_REMEMBER_WITH_VARS (TYPE_MINVAL (t));\n+  MAYBE_REMEMBER_WITH_VARS (TYPE_MAXVAL (t));\n \n   /* Accessor is for derived node types only. */\n-  LTO_FIXUP_TREE (t->type_non_common.binfo);\n+  MAYBE_REMEMBER_WITH_VARS (t->type_non_common.binfo);\n \n-  LTO_FIXUP_TREE (TYPE_CONTEXT (t));\n+  MAYBE_REMEMBER_WITH_VARS (TYPE_CONTEXT (t));\n }\n \n /* Fix up fields of a BINFO T.  */\n \n static void\n-lto_ft_binfo (tree t)\n+maybe_remember_with_vars_binfo (tree t)\n {\n   unsigned HOST_WIDE_INT i, n;\n-  tree base, saved_base;\n \n-  lto_ft_common (t);\n-  LTO_FIXUP_TREE (BINFO_VTABLE (t));\n-  LTO_FIXUP_TREE (BINFO_OFFSET (t));\n-  LTO_FIXUP_TREE (BINFO_VIRTUALS (t));\n-  LTO_FIXUP_TREE (BINFO_VPTR_FIELD (t));\n+  maybe_remember_with_vars_common (t);\n+  MAYBE_REMEMBER_WITH_VARS (BINFO_VTABLE (t));\n+  MAYBE_REMEMBER_WITH_VARS (BINFO_OFFSET (t));\n+  MAYBE_REMEMBER_WITH_VARS (BINFO_VIRTUALS (t));\n+  MAYBE_REMEMBER_WITH_VARS (BINFO_VPTR_FIELD (t));\n   n = vec_safe_length (BINFO_BASE_ACCESSES (t));\n   for (i = 0; i < n; i++)\n-    {\n-      saved_base = base = BINFO_BASE_ACCESS (t, i);\n-      LTO_FIXUP_TREE (base);\n-      if (base != saved_base)\n-\t(*BINFO_BASE_ACCESSES (t))[i] = base;\n-    }\n-  LTO_FIXUP_TREE (BINFO_INHERITANCE_CHAIN (t));\n-  LTO_FIXUP_TREE (BINFO_SUBVTT_INDEX (t));\n-  LTO_FIXUP_TREE (BINFO_VPTR_INDEX (t));\n+    MAYBE_REMEMBER_WITH_VARS (BINFO_BASE_ACCESS (t, i));\n+  MAYBE_REMEMBER_WITH_VARS (BINFO_INHERITANCE_CHAIN (t));\n+  MAYBE_REMEMBER_WITH_VARS (BINFO_SUBVTT_INDEX (t));\n+  MAYBE_REMEMBER_WITH_VARS (BINFO_VPTR_INDEX (t));\n   n = BINFO_N_BASE_BINFOS (t);\n   for (i = 0; i < n; i++)\n-    {\n-      saved_base = base = BINFO_BASE_BINFO (t, i);\n-      LTO_FIXUP_TREE (base);\n-      if (base != saved_base)\n-\t(*BINFO_BASE_BINFOS (t))[i] = base;\n-    }\n+    MAYBE_REMEMBER_WITH_VARS (BINFO_BASE_BINFO (t, i));\n }\n \n /* Fix up fields of a CONSTRUCTOR T.  */\n \n static void\n-lto_ft_constructor (tree t)\n+maybe_remember_with_vars_constructor (tree t)\n {\n   unsigned HOST_WIDE_INT idx;\n   constructor_elt *ce;\n \n-  lto_ft_typed (t);\n+  maybe_remember_with_vars_typed (t);\n \n   for (idx = 0; vec_safe_iterate (CONSTRUCTOR_ELTS (t), idx, &ce); idx++)\n     {\n-      LTO_FIXUP_TREE (ce->index);\n-      LTO_FIXUP_TREE (ce->value);\n+      MAYBE_REMEMBER_WITH_VARS (ce->index);\n+      MAYBE_REMEMBER_WITH_VARS (ce->value);\n     }\n }\n \n /* Fix up fields of an expression tree T.  */\n \n static void\n-lto_ft_expr (tree t)\n+maybe_remember_with_vars_expr (tree t)\n {\n   int i;\n-  lto_ft_typed (t);\n+  maybe_remember_with_vars_typed (t);\n   for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n-    LTO_FIXUP_TREE (TREE_OPERAND (t, i));\n+    MAYBE_REMEMBER_WITH_VARS (TREE_OPERAND (t, i));\n }\n \n /* Given a tree T fixup fields of T by replacing types with their merged\n@@ -1635,49 +1502,49 @@ lto_ft_expr (tree t)\n    for instance integer or string constants.  */\n \n static void\n-lto_fixup_types (tree t)\n+maybe_remember_with_vars (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n     case IDENTIFIER_NODE:\n       break;\n \n     case TREE_LIST:\n-      LTO_FIXUP_TREE (TREE_VALUE (t));\n-      LTO_FIXUP_TREE (TREE_PURPOSE (t));\n-      LTO_FIXUP_TREE (TREE_CHAIN (t));\n+      MAYBE_REMEMBER_WITH_VARS (TREE_VALUE (t));\n+      MAYBE_REMEMBER_WITH_VARS (TREE_PURPOSE (t));\n+      MAYBE_REMEMBER_WITH_VARS (TREE_CHAIN (t));\n       break;\n \n     case FIELD_DECL:\n-      lto_ft_field_decl (t);\n+      maybe_remember_with_vars_field_decl (t);\n       break;\n \n     case LABEL_DECL:\n     case CONST_DECL:\n     case PARM_DECL:\n     case RESULT_DECL:\n     case IMPORTED_DECL:\n-      lto_ft_decl_common (t);\n+      maybe_remember_with_vars_decl_common (t);\n       break;\n \n     case VAR_DECL:\n-      lto_ft_decl_with_vis (t);\n+      maybe_remember_with_vars_decl_with_vis (t);\n       break;\n \n     case TYPE_DECL:\n-      lto_ft_decl_non_common (t);\n+      maybe_remember_with_vars_decl_non_common (t);\n       break;\n \n     case FUNCTION_DECL:\n-      lto_ft_function (t);\n+      maybe_remember_with_vars_function (t);\n       break;\n \n     case TREE_BINFO:\n-      lto_ft_binfo (t);\n+      maybe_remember_with_vars_binfo (t);\n       break;\n \n     case PLACEHOLDER_EXPR:\n-      lto_ft_common (t);\n+      maybe_remember_with_vars_common (t);\n       break;\n \n     case BLOCK:\n@@ -1686,21 +1553,19 @@ lto_fixup_types (tree t)\n     case TARGET_OPTION_NODE:\n       break;\n \n+    case CONSTRUCTOR:\n+      maybe_remember_with_vars_constructor (t);\n+      break;\n+\n     default:\n       if (TYPE_P (t))\n-\tlto_ft_type (t);\n-      else if (TREE_CODE (t) == CONSTRUCTOR)\n-\tlto_ft_constructor (t);\n+\tmaybe_remember_with_vars_type (t);\n       else if (CONSTANT_CLASS_P (t))\n-\tLTO_FIXUP_TREE (TREE_TYPE (t));\n+\tMAYBE_REMEMBER_WITH_VARS (TREE_TYPE (t));\n       else if (EXPR_P (t))\n-\t{\n-\t  lto_ft_expr (t);\n-\t}\n+\tmaybe_remember_with_vars_expr (t);\n       else\n-\t{\n-\t  remember_with_vars (t);\n-\t}\n+\tremember_with_vars (t);\n     }\n }\n \n@@ -1786,221 +1651,721 @@ lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl)\n     }\n }\n \n-static unsigned long num_merged_types = 0;\n \n-/* Given a streamer cache structure DATA_IN (holding a sequence of trees\n-   for one compilation unit) go over all trees starting at index FROM until the\n-   end of the sequence and replace fields of those trees, and the trees\n-   themself with their canonical variants as per gimple_register_type.  */\n+/* For the type T re-materialize it in the type variant list and\n+   the pointer/reference-to chains.  */\n \n static void\n-uniquify_nodes (struct data_in *data_in, unsigned from)\n+lto_fixup_prevailing_type (tree t)\n {\n-  struct streamer_tree_cache_d *cache = data_in->reader_cache;\n-  unsigned len = cache->nodes.length ();\n-  unsigned i;\n+  /* The following re-creates proper variant lists while fixing up\n+     the variant leaders.  We do not stream TYPE_NEXT_VARIANT so the\n+     variant list state before fixup is broken.  */\n \n-  /* Go backwards because children streamed for the first time come\n-     as part of their parents, and hence are created after them.  */\n+  /* If we are not our own variant leader link us into our new leaders\n+     variant list.  */\n+  if (TYPE_MAIN_VARIANT (t) != t)\n+    {\n+      tree mv = TYPE_MAIN_VARIANT (t);\n+      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (mv);\n+      TYPE_NEXT_VARIANT (mv) = t;\n+    }\n \n-  /* First register all the types in the cache.  This makes sure to\n-     have the original structure in the type cycles when registering\n-     them and computing hashes.  */\n-  for (i = len; i-- > from;)\n+  /* The following reconstructs the pointer chains\n+     of the new pointed-to type if we are a main variant.  We do\n+     not stream those so they are broken before fixup.  */\n+  if (TREE_CODE (t) == POINTER_TYPE\n+      && TYPE_MAIN_VARIANT (t) == t)\n     {\n-      tree t = cache->nodes[i];\n-      if (t && TYPE_P (t))\n+      TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (TREE_TYPE (t));\n+      TYPE_POINTER_TO (TREE_TYPE (t)) = t;\n+    }\n+  else if (TREE_CODE (t) == REFERENCE_TYPE\n+\t   && TYPE_MAIN_VARIANT (t) == t)\n+    {\n+      TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (TREE_TYPE (t));\n+      TYPE_REFERENCE_TO (TREE_TYPE (t)) = t;\n+    }\n+}\n+\n+\n+/* We keep prevailing tree SCCs in a hashtable with manual collision\n+   handling (in case all hashes compare the same) and keep the colliding\n+   entries in the tree_scc->next chain.  */\n+\n+struct tree_scc\n+{\n+  tree_scc *next;\n+  /* Hash of the whole SCC.  */\n+  hashval_t hash;\n+  /* Number of trees in the SCC.  */\n+  unsigned len;\n+  /* Number of possible entries into the SCC (tree nodes [0..entry_len-1]\n+     which share the same individual tree hash).  */\n+  unsigned entry_len;\n+  /* The members of the SCC.\n+     We only need to remember the first entry node candidate for prevailing\n+     SCCs (but of course have access to all entries for SCCs we are\n+     processing).\n+     ???  For prevailing SCCs we really only need hash and the first\n+     entry candidate, but that's too awkward to implement.  */\n+  tree entries[1];\n+};\n+\n+struct tree_scc_hasher : typed_noop_remove <tree_scc>\n+{\n+  typedef tree_scc value_type;\n+  typedef tree_scc compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+hashval_t\n+tree_scc_hasher::hash (const value_type *scc)\n+{\n+  return scc->hash;\n+}\n+\n+bool\n+tree_scc_hasher::equal (const value_type *scc1, const compare_type *scc2)\n+{\n+  if (scc1->hash != scc2->hash\n+      || scc1->len != scc2->len\n+      || scc1->entry_len != scc2->entry_len)\n+    return false;\n+  return true;\n+}\n+\n+static hash_table <tree_scc_hasher> tree_scc_hash;\n+static struct obstack tree_scc_hash_obstack;\n+\n+static unsigned long num_merged_types;\n+static unsigned long num_prevailing_types;\n+static unsigned long num_not_merged_types;\n+static unsigned long num_not_merged_types_in_same_scc;\n+static unsigned long num_not_merged_types_trees;\n+static unsigned long num_not_merged_types_in_same_scc_trees;\n+static unsigned long num_type_scc_trees;\n+static unsigned long total_scc_size;\n+static unsigned long num_sccs_read;\n+static unsigned long total_scc_size_merged;\n+static unsigned long num_sccs_merged;\n+static unsigned long num_scc_compares;\n+static unsigned long num_scc_compare_collisions;\n+\n+\n+/* Compare the two entries T1 and T2 of two SCCs that are possibly equal,\n+   recursing through in-SCC tree edges.  Returns true if the SCCs entered\n+   through T1 and T2 are equal and fills in *MAP with the pairs of\n+   SCC entries we visited, starting with (*MAP)[0] = T1 and (*MAP)[1] = T2.  */\n+\n+static bool\n+compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n+{\n+  enum tree_code code;\n+\n+  /* Mark already visited nodes.  */\n+  TREE_ASM_WRITTEN (t2) = 1;\n+\n+  /* Push the pair onto map.  */\n+  (*map)[0] = t1;\n+  (*map)[1] = t2;\n+  *map = *map + 2;\n+\n+  /* Compare value-fields.  */\n+#define compare_values(X) \\\n+  do { \\\n+    if (X(t1) != X(t2)) \\\n+      return false; \\\n+  } while (0)\n+\n+  compare_values (TREE_CODE);\n+  code = TREE_CODE (t1);\n+\n+  if (!TYPE_P (t1))\n+    {\n+      compare_values (TREE_SIDE_EFFECTS);\n+      compare_values (TREE_CONSTANT);\n+      compare_values (TREE_READONLY);\n+      compare_values (TREE_PUBLIC);\n+    }\n+  compare_values (TREE_ADDRESSABLE);\n+  compare_values (TREE_THIS_VOLATILE);\n+  if (DECL_P (t1))\n+    compare_values (DECL_UNSIGNED);\n+  else if (TYPE_P (t1))\n+    compare_values (TYPE_UNSIGNED);\n+  if (TYPE_P (t1))\n+    compare_values (TYPE_ARTIFICIAL);\n+  else\n+    compare_values (TREE_NO_WARNING);\n+  compare_values (TREE_NOTHROW);\n+  compare_values (TREE_STATIC);\n+  if (code != TREE_BINFO)\n+    compare_values (TREE_PRIVATE);\n+  compare_values (TREE_PROTECTED);\n+  compare_values (TREE_DEPRECATED);\n+  if (TYPE_P (t1))\n+    {\n+      compare_values (TYPE_SATURATING);\n+      compare_values (TYPE_ADDR_SPACE);\n+    }\n+  else if (code == SSA_NAME)\n+    compare_values (SSA_NAME_IS_DEFAULT_DEF);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_INT_CST))\n+    {\n+      compare_values (TREE_INT_CST_LOW);\n+      compare_values (TREE_INT_CST_HIGH);\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_REAL_CST))\n+    {\n+      /* ???  No suitable compare routine available.  */\n+      REAL_VALUE_TYPE r1 = TREE_REAL_CST (t1);\n+      REAL_VALUE_TYPE r2 = TREE_REAL_CST (t2);\n+      if (r1.cl != r2.cl\n+\t  || r1.decimal != r2.decimal\n+\t  || r1.sign != r2.sign\n+\t  || r1.signalling != r2.signalling\n+\t  || r1.canonical != r2.canonical\n+\t  || r1.uexp != r2.uexp)\n+\treturn false;\n+      for (unsigned i = 0; i < SIGSZ; ++i)\n+\tif (r1.sig[i] != r2.sig[i])\n+\t  return false;\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIXED_CST))\n+    if (!fixed_compare (EQ_EXPR,\n+\t\t\tTREE_FIXED_CST_PTR (t1), TREE_FIXED_CST_PTR (t2)))\n+      return false;\n+\n+\n+  /* We don't want to compare locations, so there is nothing do compare\n+     for TS_DECL_MINIMAL.  */\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    {\n+      compare_values (DECL_MODE);\n+      compare_values (DECL_NONLOCAL);\n+      compare_values (DECL_VIRTUAL_P);\n+      compare_values (DECL_IGNORED_P);\n+      compare_values (DECL_ABSTRACT);\n+      compare_values (DECL_ARTIFICIAL);\n+      compare_values (DECL_USER_ALIGN);\n+      compare_values (DECL_PRESERVE_P);\n+      compare_values (DECL_EXTERNAL);\n+      compare_values (DECL_GIMPLE_REG_P);\n+      compare_values (DECL_ALIGN);\n+      if (code == LABEL_DECL)\n \t{\n-\t  tree newt = gimple_register_type (t);\n-\t  /* Mark non-prevailing types so we fix them up.  No need\n-\t     to reset that flag afterwards - nothing that refers\n-\t     to those types is left and they are collected.  */\n-\t  if (newt != t)\n-\t    {\n-\t      num_merged_types++;\n-\t      TREE_VISITED (t) = 1;\n-\t    }\n+\t  compare_values (DECL_ERROR_ISSUED);\n+\t  compare_values (EH_LANDING_PAD_NR);\n+\t  compare_values (LABEL_DECL_UID);\n+\t}\n+      else if (code == FIELD_DECL)\n+\t{\n+\t  compare_values (DECL_PACKED);\n+\t  compare_values (DECL_NONADDRESSABLE_P);\n+\t  compare_values (DECL_OFFSET_ALIGN);\n+\t}\n+      else if (code == VAR_DECL)\n+\t{\n+\t  compare_values (DECL_HAS_DEBUG_EXPR_P);\n+\t  compare_values (DECL_NONLOCAL_FRAME);\n+\t}\n+      if (code == RESULT_DECL\n+\t  || code == PARM_DECL\n+\t  || code == VAR_DECL)\n+\t{\n+\t  compare_values (DECL_BY_REFERENCE);\n+\t  if (code == VAR_DECL\n+\t      || code == PARM_DECL)\n+\t    compare_values (DECL_HAS_VALUE_EXPR_P);\n+\t}\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n+    compare_values (DECL_REGISTER);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    {\n+      compare_values (DECL_DEFER_OUTPUT);\n+      compare_values (DECL_COMMON);\n+      compare_values (DECL_DLLIMPORT_P);\n+      compare_values (DECL_WEAK);\n+      compare_values (DECL_SEEN_IN_BIND_EXPR_P);\n+      compare_values (DECL_COMDAT);\n+      compare_values (DECL_VISIBILITY);\n+      compare_values (DECL_VISIBILITY_SPECIFIED);\n+      if (code == VAR_DECL)\n+\t{\n+\t  compare_values (DECL_HARD_REGISTER);\n+\t  compare_values (DECL_IN_TEXT_SECTION);\n+\t  compare_values (DECL_IN_CONSTANT_POOL);\n+\t  compare_values (DECL_TLS_MODEL);\n \t}\n+      if (VAR_OR_FUNCTION_DECL_P (t1))\n+\tcompare_values (DECL_INIT_PRIORITY);\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    {\n+      compare_values (DECL_BUILT_IN_CLASS);\n+      compare_values (DECL_STATIC_CONSTRUCTOR);\n+      compare_values (DECL_STATIC_DESTRUCTOR);\n+      compare_values (DECL_UNINLINABLE);\n+      compare_values (DECL_POSSIBLY_INLINED);\n+      compare_values (DECL_IS_NOVOPS);\n+      compare_values (DECL_IS_RETURNS_TWICE);\n+      compare_values (DECL_IS_MALLOC);\n+      compare_values (DECL_IS_OPERATOR_NEW);\n+      compare_values (DECL_DECLARED_INLINE_P);\n+      compare_values (DECL_STATIC_CHAIN);\n+      compare_values (DECL_NO_INLINE_WARNING_P);\n+      compare_values (DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT);\n+      compare_values (DECL_NO_LIMIT_STACK);\n+      compare_values (DECL_DISREGARD_INLINE_LIMITS);\n+      compare_values (DECL_PURE_P);\n+      compare_values (DECL_LOOPING_CONST_OR_PURE_P);\n+      if (DECL_BUILT_IN_CLASS (t1) != NOT_BUILT_IN)\n+\tcompare_values (DECL_FUNCTION_CODE);\n+      if (DECL_STATIC_DESTRUCTOR (t1))\n+\tcompare_values (DECL_FINI_PRIORITY);\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    {\n+      compare_values (TYPE_MODE);\n+      compare_values (TYPE_STRING_FLAG);\n+      compare_values (TYPE_NO_FORCE_BLK);\n+      compare_values (TYPE_NEEDS_CONSTRUCTING);\n+      if (RECORD_OR_UNION_TYPE_P (t1))\n+\tcompare_values (TYPE_TRANSPARENT_AGGR);\n+      else if (code == ARRAY_TYPE)\n+\tcompare_values (TYPE_NONALIASED_COMPONENT);\n+      compare_values (TYPE_PACKED);\n+      compare_values (TYPE_RESTRICT);\n+      compare_values (TYPE_USER_ALIGN);\n+      compare_values (TYPE_READONLY);\n+      compare_values (TYPE_PRECISION);\n+      compare_values (TYPE_ALIGN);\n+      compare_values (TYPE_ALIAS_SET);\n+    }\n+\n+  /* We don't want to compare locations, so there is nothing do compare\n+     for TS_EXP.  */\n+\n+  /* BLOCKs are function local and we don't merge anything there, so\n+     simply refuse to merge.  */\n+  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n+    return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n+    if (strcmp (TRANSLATION_UNIT_LANGUAGE (t1),\n+\t\tTRANSLATION_UNIT_LANGUAGE (t2)) != 0)\n+      return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TARGET_OPTION))\n+    if (memcmp (TREE_TARGET_OPTION (t1), TREE_TARGET_OPTION (t2),\n+\t\tsizeof (struct cl_target_option)) != 0)\n+      return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_OPTIMIZATION))\n+    if (memcmp (TREE_OPTIMIZATION (t1), TREE_OPTIMIZATION (t2),\n+\t\tsizeof (struct cl_optimization)) != 0)\n+      return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    if (vec_safe_length (BINFO_BASE_ACCESSES (t1))\n+\t!= vec_safe_length (BINFO_BASE_ACCESSES (t2)))\n+      return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n+    compare_values (CONSTRUCTOR_NELTS);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n+    if (IDENTIFIER_LENGTH (t1) != IDENTIFIER_LENGTH (t2)\n+\t|| memcmp (IDENTIFIER_POINTER (t1), IDENTIFIER_POINTER (t2),\n+\t\t   IDENTIFIER_LENGTH (t1)) != 0)\n+      return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n+    if (TREE_STRING_LENGTH (t1) != TREE_STRING_LENGTH (t2)\n+\t|| memcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),\n+\t\t   TREE_STRING_LENGTH (t1)) != 0)\n+      return false;\n+\n+#undef compare_values\n+\n+\n+  /* Compare pointer fields.  */\n+\n+  /* Recurse.  Search & Replaced from DFS_write_tree_body.\n+     Folding the early checks into the compare_tree_edges recursion\n+     macro makes debugging way quicker as you are able to break on\n+     compare_tree_sccs_1 and simply finish until a call returns false\n+     to spot the SCC members with the difference.  */\n+#define compare_tree_edges(E1, E2) \\\n+  do { \\\n+    tree t1_ = (E1), t2_ = (E2); \\\n+    if (t1_ != t2_ \\\n+\t&& (!t1_ || !t2_ \\\n+\t    || !TREE_VISITED (t2_) \\\n+\t    || (!TREE_ASM_WRITTEN (t2_) \\\n+\t\t&& !compare_tree_sccs_1 (t1_, t2_, map)))) \\\n+      return false; \\\n+    /* Only non-NULL trees outside of the SCC may compare equal.  */ \\\n+    gcc_checking_assert (t1_ != t2_ || (!t2_ || !TREE_VISITED (t2_))); \\\n+  } while (0)\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n+    {\n+      if (code != IDENTIFIER_NODE)\n+\tcompare_tree_edges (TREE_TYPE (t1), TREE_TYPE (t2));\n     }\n \n-  /* Second fixup all trees in the new cache entries.  */\n-  for (i = len; i-- > from;)\n+  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n     {\n-      tree t = cache->nodes[i];\n-      tree oldt = t;\n-      if (!t)\n-\tcontinue;\n+      unsigned i;\n+      /* Note that the number of elements for EXPR has already been emitted\n+\t in EXPR's header (see streamer_write_tree_header).  */\n+      for (i = 0; i < VECTOR_CST_NELTS (t1); ++i)\n+\tcompare_tree_edges (VECTOR_CST_ELT (t1, i), VECTOR_CST_ELT (t2, i));\n+    }\n \n-      /* First fixup the fields of T.  */\n-      lto_fixup_types (t);\n+  if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n+    {\n+      compare_tree_edges (TREE_REALPART (t1), TREE_REALPART (t2));\n+      compare_tree_edges (TREE_IMAGPART (t1), TREE_IMAGPART (t2));\n+    }\n \n-      if (!TYPE_P (t))\n-\tcontinue;\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n+    {\n+      compare_tree_edges (DECL_NAME (t1), DECL_NAME (t2));\n+      /* ???  Global decls from different TUs have non-matching\n+\t TRANSLATION_UNIT_DECLs.  Only consider a small set of\n+\t decls equivalent, we should not end up merging others.  */\n+      if ((code == TYPE_DECL\n+\t   || code == NAMESPACE_DECL\n+\t   || code == IMPORTED_DECL\n+\t   || code == CONST_DECL\n+\t   || (VAR_OR_FUNCTION_DECL_P (t1)\n+\t       && (TREE_PUBLIC (t1) || DECL_EXTERNAL (t1))))\n+\t  && DECL_FILE_SCOPE_P (t1) && DECL_FILE_SCOPE_P (t2))\n+\t;\n+      else\n+\tcompare_tree_edges (DECL_CONTEXT (t1), DECL_CONTEXT (t2));\n+    }\n \n-      /* Now try to find a canonical variant of T itself.  */\n-      t = GIMPLE_REGISTER_TYPE (t);\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    {\n+      compare_tree_edges (DECL_SIZE (t1), DECL_SIZE (t2));\n+      compare_tree_edges (DECL_SIZE_UNIT (t1), DECL_SIZE_UNIT (t2));\n+      compare_tree_edges (DECL_ATTRIBUTES (t1), DECL_ATTRIBUTES (t2));\n+      if ((code == VAR_DECL\n+\t   || code == PARM_DECL)\n+\t  && DECL_HAS_VALUE_EXPR_P (t1))\n+\tcompare_tree_edges (DECL_VALUE_EXPR (t1), DECL_VALUE_EXPR (t2));\n+      if (code == VAR_DECL\n+\t  && DECL_HAS_DEBUG_EXPR_P (t1))\n+\tcompare_tree_edges (DECL_DEBUG_EXPR (t1), DECL_DEBUG_EXPR (t2));\n+      /* LTO specific edges.  */\n+      if (code != FUNCTION_DECL\n+\t  && code != TRANSLATION_UNIT_DECL)\n+\tcompare_tree_edges (DECL_INITIAL (t1), DECL_INITIAL (t2));\n+    }\n \n-      if (t == oldt)\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n+    {\n+      if (code == FUNCTION_DECL)\n \t{\n-\t  /* The following re-creates proper variant lists while fixing up\n-\t     the variant leaders.  We do not stream TYPE_NEXT_VARIANT so the\n-\t     variant list state before fixup is broken.  */\n-\t  tree tem, mv;\n+\t  tree a1, a2;\n+\t  for (a1 = DECL_ARGUMENTS (t1), a2 = DECL_ARGUMENTS (t2);\n+\t       a1 || a2;\n+\t       a1 = TREE_CHAIN (a1), a2 = TREE_CHAIN (a2))\n+\t    compare_tree_edges (a1, a2);\n+\t  compare_tree_edges (DECL_RESULT (t1), DECL_RESULT (t2));\n+\t}\n+      else if (code == TYPE_DECL)\n+\tcompare_tree_edges (DECL_ORIGINAL_TYPE (t1), DECL_ORIGINAL_TYPE (t2));\n+      compare_tree_edges (DECL_VINDEX (t1), DECL_VINDEX (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    {\n+      /* Make sure we don't inadvertently set the assembler name.  */\n+      if (DECL_ASSEMBLER_NAME_SET_P (t1))\n+\tcompare_tree_edges (DECL_ASSEMBLER_NAME (t1),\n+\t\t\t    DECL_ASSEMBLER_NAME (t2));\n+      compare_tree_edges (DECL_SECTION_NAME (t1), DECL_SECTION_NAME (t2));\n+      compare_tree_edges (DECL_COMDAT_GROUP (t1), DECL_COMDAT_GROUP (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n+    {\n+      compare_tree_edges (DECL_FIELD_OFFSET (t1), DECL_FIELD_OFFSET (t2));\n+      compare_tree_edges (DECL_BIT_FIELD_TYPE (t1), DECL_BIT_FIELD_TYPE (t2));\n+      compare_tree_edges (DECL_BIT_FIELD_REPRESENTATIVE (t1),\n+\t\t\t  DECL_BIT_FIELD_REPRESENTATIVE (t2));\n+      compare_tree_edges (DECL_FIELD_BIT_OFFSET (t1),\n+\t\t\t  DECL_FIELD_BIT_OFFSET (t2));\n+      compare_tree_edges (DECL_FCONTEXT (t1), DECL_FCONTEXT (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    {\n+      compare_tree_edges (DECL_FUNCTION_PERSONALITY (t1),\n+\t\t\t  DECL_FUNCTION_PERSONALITY (t2));\n+      compare_tree_edges (DECL_FUNCTION_SPECIFIC_TARGET (t1),\n+\t\t\t  DECL_FUNCTION_SPECIFIC_TARGET (t2));\n+      compare_tree_edges (DECL_FUNCTION_SPECIFIC_OPTIMIZATION (t1),\n+\t\t\t  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    {\n+      compare_tree_edges (TYPE_SIZE (t1), TYPE_SIZE (t2));\n+      compare_tree_edges (TYPE_SIZE_UNIT (t1), TYPE_SIZE_UNIT (t2));\n+      compare_tree_edges (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2));\n+      compare_tree_edges (TYPE_NAME (t1), TYPE_NAME (t2));\n+      /* Do not compare TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n+\t reconstructed during fixup.  */\n+      /* Do not compare TYPE_NEXT_VARIANT, we reconstruct the variant lists\n+\t during fixup.  */\n+      compare_tree_edges (TYPE_MAIN_VARIANT (t1), TYPE_MAIN_VARIANT (t2));\n+      /* ???  Global types from different TUs have non-matching\n+\t TRANSLATION_UNIT_DECLs.  Still merge them if they are otherwise\n+\t equal.  */\n+      if (TYPE_FILE_SCOPE_P (t1) && TYPE_FILE_SCOPE_P (t2))\n+\t;\n+      else\n+\tcompare_tree_edges (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2));\n+      /* TYPE_CANONICAL is re-computed during type merging, so do not\n+\t compare it here.  */\n+      compare_tree_edges (TYPE_STUB_DECL (t1), TYPE_STUB_DECL (t2));\n+    }\n \n-#ifdef ENABLE_CHECKING\n-\t  /* Remove us from our main variant list if we are not the\n-\t     variant leader.  */\n-\t  if (TYPE_MAIN_VARIANT (t) != t)\n-\t    {\n-\t      tem = TYPE_MAIN_VARIANT (t);\n-\t      while (tem && TYPE_NEXT_VARIANT (tem) != t)\n-\t\ttem = TYPE_NEXT_VARIANT (tem);\n-\t      gcc_assert (!tem && !TYPE_NEXT_VARIANT (t));\n-\t    }\n-#endif\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n+    {\n+      if (code == ENUMERAL_TYPE)\n+\tcompare_tree_edges (TYPE_VALUES (t1), TYPE_VALUES (t2));\n+      else if (code == ARRAY_TYPE)\n+\tcompare_tree_edges (TYPE_DOMAIN (t1), TYPE_DOMAIN (t2));\n+      else if (RECORD_OR_UNION_TYPE_P (t1))\n+\t{\n+\t  tree f1, f2;\n+\t  for (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n+\t       f1 || f2;\n+\t       f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\t    compare_tree_edges (f1, f2);\n+\t  compare_tree_edges (TYPE_BINFO (t1), TYPE_BINFO (t2));\n+\t}\n+      else if (code == FUNCTION_TYPE\n+\t       || code == METHOD_TYPE)\n+\tcompare_tree_edges (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2));\n+      if (!POINTER_TYPE_P (t1))\n+\tcompare_tree_edges (TYPE_MINVAL (t1), TYPE_MINVAL (t2));\n+      compare_tree_edges (TYPE_MAXVAL (t1), TYPE_MAXVAL (t2));\n+    }\n \n-\t  /* Query our new main variant.  */\n-\t  mv = GIMPLE_REGISTER_TYPE (TYPE_MAIN_VARIANT (t));\n+  if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n+    {\n+      compare_tree_edges (TREE_PURPOSE (t1), TREE_PURPOSE (t2));\n+      compare_tree_edges (TREE_VALUE (t1), TREE_VALUE (t2));\n+      compare_tree_edges (TREE_CHAIN (t1), TREE_CHAIN (t2));\n+    }\n \n-\t  /* If we were the variant leader and we get replaced ourselves drop\n-\t     all variants from our list.  */\n-\t  if (TYPE_MAIN_VARIANT (t) == t\n-\t      && mv != t)\n-\t    {\n-\t      tem = t;\n-\t      while (tem)\n-\t\t{\n-\t\t  tree tem2 = TYPE_NEXT_VARIANT (tem);\n-\t\t  TYPE_NEXT_VARIANT (tem) = NULL_TREE;\n-\t\t  tem = tem2;\n-\t\t}\n-\t    }\n+  if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    for (int i = 0; i < TREE_VEC_LENGTH (t1); i++)\n+      compare_tree_edges (TREE_VEC_ELT (t1, i), TREE_VEC_ELT (t2, i));\n \n-\t  /* If we are not our own variant leader link us into our new leaders\n-\t     variant list.  */\n-\t  if (mv != t)\n-\t    {\n-\t      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (mv);\n-\t      TYPE_NEXT_VARIANT (mv) = t;\n-\t      if (RECORD_OR_UNION_TYPE_P (t))\n-\t\tTYPE_BINFO (t) = TYPE_BINFO (mv);\n-\t      /* Preserve the invariant that type variants share their\n-\t\t TYPE_FIELDS.  */\n-\t      if (RECORD_OR_UNION_TYPE_P (t)\n-\t\t  && TYPE_FIELDS (mv) != TYPE_FIELDS (t))\n-\t\t{\n-\t\t  tree f1, f2;\n-\t\t  for (f1 = TYPE_FIELDS (mv), f2 = TYPE_FIELDS (t);\n-\t\t       f1 && f2; f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n-\t\t    {\n-\t\t      unsigned ix;\n-\t\t      gcc_assert (f1 != f2\n-\t\t\t\t  && DECL_NAME (f1) == DECL_NAME (f2));\n-\t\t      if (!streamer_tree_cache_lookup (cache, f2, &ix))\n-\t\t\tgcc_unreachable ();\n-\t\t      /* If we're going to replace an element which we'd\n-\t\t\t still visit in the next iterations, we wouldn't\n-\t\t\t handle it, so do it here.  We do have to handle it\n-\t\t\t even though the field_decl itself will be removed,\n-\t\t\t as it could refer to e.g. integer_cst which we\n-\t\t\t wouldn't reach via any other way, hence they\n-\t\t\t (and their type) would stay uncollected.  */\n-\t\t      /* ???  We should rather make sure to replace all\n-\t\t\t references to f2 with f1.  That means handling\n-\t\t\t COMPONENT_REFs and CONSTRUCTOR elements in\n-\t\t\t lto_fixup_types and special-case the field-decl\n-\t\t\t operand handling.  */\n-\t\t      /* ???  Not sure the above is all relevant in this\n-\t\t         path canonicalizing TYPE_FIELDS to that of the\n-\t\t\t main variant.  */\n-\t\t      if (ix < i)\n-\t\t\tlto_fixup_types (f2);\n-\t\t      streamer_tree_cache_insert_at (cache, f1, ix);\n-\t\t    }\n-\t\t  TYPE_FIELDS (t) = TYPE_FIELDS (mv);\n-\t\t}\n-\t    }\n+  if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n+    {\n+      for (int i = 0; i < TREE_OPERAND_LENGTH (t1); i++)\n+\tcompare_tree_edges (TREE_OPERAND (t1, i),\n+\t\t\t    TREE_OPERAND (t2, i));\n \n-\t  /* Finally adjust our main variant and fix it up.  */\n-\t  TYPE_MAIN_VARIANT (t) = mv;\n+      /* BLOCKs are function local and we don't merge anything there.  */\n+      if (TREE_BLOCK (t1) || TREE_BLOCK (t2))\n+\treturn false;\n+    }\n \n-\t  /* The following reconstructs the pointer chains\n-\t     of the new pointed-to type if we are a main variant.  We do\n-\t     not stream those so they are broken before fixup.  */\n-\t  if (TREE_CODE (t) == POINTER_TYPE\n-\t      && TYPE_MAIN_VARIANT (t) == t)\n-\t    {\n-\t      TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (TREE_TYPE (t));\n-\t      TYPE_POINTER_TO (TREE_TYPE (t)) = t;\n-\t    }\n-\t  else if (TREE_CODE (t) == REFERENCE_TYPE\n-\t\t   && TYPE_MAIN_VARIANT (t) == t)\n-\t    {\n-\t      TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (TREE_TYPE (t));\n-\t      TYPE_REFERENCE_TO (TREE_TYPE (t)) = t;\n-\t    }\n+  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    {\n+      unsigned i;\n+      tree t;\n+      /* Lengths have already been compared above.  */\n+      FOR_EACH_VEC_ELT (*BINFO_BASE_BINFOS (t1), i, t)\n+\tcompare_tree_edges (t, BINFO_BASE_BINFO (t2, i));\n+      FOR_EACH_VEC_SAFE_ELT (BINFO_BASE_ACCESSES (t1), i, t)\n+\tcompare_tree_edges (t, BINFO_BASE_ACCESS (t2, i));\n+      compare_tree_edges (BINFO_OFFSET (t1), BINFO_OFFSET (t2));\n+      compare_tree_edges (BINFO_VTABLE (t1), BINFO_VTABLE (t2));\n+      compare_tree_edges (BINFO_VPTR_FIELD (t1), BINFO_VPTR_FIELD (t2));\n+      compare_tree_edges (BINFO_INHERITANCE_CHAIN (t1),\n+\t\t\t  BINFO_INHERITANCE_CHAIN (t2));\n+      compare_tree_edges (BINFO_SUBVTT_INDEX (t1),\n+\t\t\t  BINFO_SUBVTT_INDEX (t2));\n+      compare_tree_edges (BINFO_VPTR_INDEX (t1),\n+\t\t\t  BINFO_VPTR_INDEX (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n+    {\n+      unsigned i;\n+      tree index, value;\n+      /* Lengths have already been compared above.  */\n+      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t1), i, index, value)\n+\t{\n+\t  compare_tree_edges (index, CONSTRUCTOR_ELT (t2, i)->index);\n+\t  compare_tree_edges (value, CONSTRUCTOR_ELT (t2, i)->value);\n \t}\n+    }\n \n-      else\n+#undef compare_tree_edges\n+\n+  return true;\n+}\n+\n+/* Compare the tree scc SCC to the prevailing candidate PSCC, filling\n+   out MAP if they are equal.  */\n+\n+static bool\n+compare_tree_sccs (tree_scc *pscc, tree_scc *scc,\n+\t\t   tree *map)\n+{\n+  /* Assume SCC entry hashes are sorted after their cardinality.  Which\n+     means we can simply take the first n-tuple of equal hashes\n+     (which is recorded as entry_len) and do n SCC entry candidate\n+     comparisons.  */\n+  for (unsigned i = 0; i < pscc->entry_len; ++i)\n+    {\n+      tree *mapp = map;\n+      num_scc_compare_collisions++;\n+      if (compare_tree_sccs_1 (pscc->entries[0], scc->entries[i], &mapp))\n \t{\n-\t  if (RECORD_OR_UNION_TYPE_P (t))\n-\t    {\n-\t      tree f1, f2;\n-\t      if (TYPE_FIELDS (t) != TYPE_FIELDS (oldt))\n-\t\tfor (f1 = TYPE_FIELDS (t), f2 = TYPE_FIELDS (oldt);\n-\t\t     f1 && f2; f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n-\t\t  {\n-\t\t    unsigned ix;\n-\t\t    gcc_assert (f1 != f2 && DECL_NAME (f1) == DECL_NAME (f2));\n-\t\t    if (!streamer_tree_cache_lookup (cache, f2, &ix))\n-\t\t      gcc_unreachable ();\n-\t\t    /* If we're going to replace an element which we'd\n-\t\t       still visit in the next iterations, we wouldn't\n-\t\t       handle it, so do it here.  We do have to handle it\n-\t\t       even though the field_decl itself will be removed,\n-\t\t       as it could refer to e.g. integer_cst which we\n-\t\t       wouldn't reach via any other way, hence they\n-\t\t       (and their type) would stay uncollected.  */\n-\t\t    /* ???  We should rather make sure to replace all\n-\t\t       references to f2 with f1.  That means handling\n-\t\t       COMPONENT_REFs and CONSTRUCTOR elements in\n-\t\t       lto_fixup_types and special-case the field-decl\n-\t\t       operand handling.  */\n-\t\t    if (ix < i)\n-\t\t      lto_fixup_types (f2);\n-\t\t    streamer_tree_cache_insert_at (cache, f1, ix);\n-\t\t  }\n-\t    }\n+\t  /* Equal - no need to reset TREE_VISITED or TREE_ASM_WRITTEN\n+\t     on the scc as all trees will be freed.  */\n+\t  return true;\n+\t}\n+      /* Reset TREE_ASM_WRITTEN on scc for the next compare or in case\n+         the SCC prevails.  */\n+      for (unsigned j = 0; j < scc->len; ++j)\n+\tTREE_ASM_WRITTEN (scc->entries[j]) = 0;\n+    }\n+\n+  return false;\n+}\n+\n+/* Try to unify the SCC with nodes FROM to FROM + LEN in CACHE and\n+   hash value SCC_HASH with an already recorded SCC.  Return true if\n+   that was successful, otherwise return false.  */\n \n-\t  /* If we found a tree that is equal to oldt replace it in the\n-\t     cache, so that further users (in the various LTO sections)\n-\t     make use of it.  */\n-\t  streamer_tree_cache_insert_at (cache, t, i);\n+static bool\n+unify_scc (struct streamer_tree_cache_d *cache, unsigned from,\n+\t   unsigned len, unsigned scc_entry_len, hashval_t scc_hash)\n+{\n+  bool unified_p = false;\n+  tree_scc *scc\n+    = (tree_scc *) alloca (sizeof (tree_scc) + (len - 1) * sizeof (tree));\n+  scc->next = NULL;\n+  scc->hash = scc_hash;\n+  scc->len = len;\n+  scc->entry_len = scc_entry_len;\n+  for (unsigned i = 0; i < len; ++i)\n+    {\n+      tree t = streamer_tree_cache_get_tree (cache, from + i);\n+      scc->entries[i] = t;\n+      /* Do not merge SCCs with local entities inside them.  Also do\n+\t not merge TRANSLATION_UNIT_DECLs.  */\n+      if (TREE_CODE (t) == TRANSLATION_UNIT_DECL\n+\t  || (VAR_OR_FUNCTION_DECL_P (t)\n+\t      && !(TREE_PUBLIC (t) || DECL_EXTERNAL (t)))\n+\t  || TREE_CODE (t) == LABEL_DECL)\n+\t{\n+\t  /* Avoid doing any work for these cases and do not worry to\n+\t     record the SCCs for further merging.  */\n+\t  return false;\n \t}\n     }\n \n-  /* Finally compute the canonical type of all TREE_TYPEs and register\n-     VAR_DECL and FUNCTION_DECL nodes in the symbol table.\n-     From this point there are no longer any types with\n-     TYPE_STRUCTURAL_EQUALITY_P and its type-based alias problems.\n-     This step requires the TYPE_POINTER_TO lists being present, so\n-     make sure it is done last.  */\n-  for (i = len; i-- > from;)\n+  /* Look for the list of candidate SCCs to compare against.  */\n+  tree_scc **slot;\n+  slot = tree_scc_hash.find_slot_with_hash (scc, scc_hash, INSERT);\n+  if (*slot)\n     {\n-      tree t = cache->nodes[i];\n-      if (t == NULL_TREE)\n-\tcontinue;\n+      /* Try unifying against each candidate.  */\n+      num_scc_compares++;\n+\n+      /* Set TREE_VISITED on the scc so we can easily identify tree nodes\n+\t outside of the scc when following tree edges.  Make sure\n+\t that TREE_ASM_WRITTEN is unset so we can use it as 2nd bit\n+\t to track whether we visited the SCC member during the compare.\n+\t We cannot use TREE_VISITED on the pscc members as the extended\n+\t scc and pscc can overlap.  */\n+      for (unsigned i = 0; i < scc->len; ++i)\n+\t{\n+\t  TREE_VISITED (scc->entries[i]) = 1;\n+\t  gcc_assert (!TREE_ASM_WRITTEN (scc->entries[i]));\n+\t}\n+\n+      tree *map = XALLOCAVEC (tree, 2 * len);\n+      for (tree_scc *pscc = *slot; pscc; pscc = pscc->next)\n+\t{\n+\t  if (!compare_tree_sccs (pscc, scc, map))\n+\t    continue;\n+\n+\t  /* Found an equal SCC.  */\n+\t  unified_p = true;\n+\t  num_scc_compare_collisions--;\n+\t  num_sccs_merged++;\n+\t  total_scc_size_merged += len;\n+\n+\t  /* Fixup the streamer cache with the prevailing nodes according\n+\t     to the tree node mapping computed by compare_tree_sccs.  */\n+\t  for (unsigned i = 0; i < len; ++i)\n+\t    {\n+\t      tree t = map[2*i+1];\n+\t      enum tree_code code = TREE_CODE (t);\n+\t      unsigned ix;\n+\t      bool r;\n+\t      /* IDENTIFIER_NODEs should be singletons and are merged by the\n+\t\t streamer.  The others should be singletons, too, and we\n+\t\t should not merge them in any way.  */\n+\t      gcc_assert (code != TRANSLATION_UNIT_DECL\n+\t\t\t  && code != IDENTIFIER_NODE\n+\t\t\t  && !streamer_handle_as_builtin_p (t));\n+\t      r = streamer_tree_cache_lookup (cache, t, &ix);\n+\t      gcc_assert (r && ix >= from);\n+\t      streamer_tree_cache_replace_tree (cache, map[2 * i], ix);\n+\t      if (TYPE_P (t))\n+\t\tnum_merged_types++;\n+\t    }\n+\t  /* Free the tree nodes from the read SCC.  */\n+\t  for (unsigned i = 0; i < len; ++i)\n+\t    ggc_free (scc->entries[i]);\n+\t  break;\n+\t}\n+\n+      /* Reset TREE_VISITED if we didn't unify the SCC with another.  */\n+      if (!unified_p)\n+\tfor (unsigned i = 0; i < scc->len; ++i)\n+\t  TREE_VISITED (scc->entries[i]) = 0;\n+    }\n \n-      if (TREE_CODE (t) == VAR_DECL)\n-\tlto_register_var_decl_in_symtab (data_in, t);\n-      else if (TREE_CODE (t) == FUNCTION_DECL && !DECL_BUILT_IN (t))\n-\tlto_register_function_decl_in_symtab (data_in, t);\n-      else if (!flag_wpa\n-\t       && TREE_CODE (t) == TYPE_DECL)\n-\tdebug_hooks->type_decl (t, !DECL_FILE_SCOPE_P (t));\n-      else if (TYPE_P (t) && !TYPE_CANONICAL (t))\n-\tTYPE_CANONICAL (t) = gimple_register_canonical_type (t);\n+  /* If we didn't unify it to any candidate duplicate the relevant\n+     pieces to permanent storage and link it into the chain.  */\n+  if (!unified_p)\n+    {\n+      tree_scc *pscc\n+\t= XOBNEWVAR (&tree_scc_hash_obstack, tree_scc, sizeof (tree_scc));\n+      memcpy (pscc, scc, sizeof (tree_scc));\n+      pscc->next = (*slot);\n+      *slot = pscc;\n     }\n+  return unified_p;\n }\n \n \n@@ -2036,9 +2401,123 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n     {\n       tree t;\n       unsigned from = data_in->reader_cache->nodes.length ();\n-      t = stream_read_tree (&ib_main, data_in);\n-      gcc_assert (t && ib_main.p <= ib_main.len);\n-      uniquify_nodes (data_in, from);\n+      /* Read and uniquify SCCs as in the input stream.  */\n+      enum LTO_tags tag = streamer_read_record_start (&ib_main);\n+      if (tag == LTO_tree_scc)\n+\t{\n+\t  unsigned len_;\n+\t  unsigned scc_entry_len;\n+\t  hashval_t scc_hash = lto_input_scc (&ib_main, data_in, &len_,\n+\t\t\t\t\t      &scc_entry_len);\n+\t  unsigned len = data_in->reader_cache->nodes.length () - from;\n+\t  gcc_assert (len == len_);\n+\n+\t  total_scc_size += len;\n+\t  num_sccs_read++;\n+\n+\t  /* We have the special case of size-1 SCCs that are pre-merged\n+\t     by means of identifier and string sharing for example.\n+\t     ???  Maybe we should avoid streaming those as SCCs.  */\n+\t  tree first = streamer_tree_cache_get_tree (data_in->reader_cache,\n+\t\t\t\t\t\t     from);\n+\t  if (len == 1\n+\t      && (TREE_CODE (first) == IDENTIFIER_NODE\n+\t\t  || TREE_CODE (first) == INTEGER_CST\n+\t\t  || TREE_CODE (first) == TRANSLATION_UNIT_DECL\n+\t\t  || streamer_handle_as_builtin_p (first)))\n+\t    continue;\n+\n+\t  /* Try to unify the SCC with already existing ones.  */\n+\t  if (!flag_ltrans\n+\t      && unify_scc (data_in->reader_cache, from,\n+\t\t\t    len, scc_entry_len, scc_hash))\n+\t    continue;\n+\n+\t  /* Do remaining fixup tasks for prevailing nodes.  */\n+\t  bool seen_type = false;\n+\t  bool not_merged_type_same_scc = false;\n+\t  bool not_merged_type_not_same_scc = false;\n+\t  for (unsigned i = 0; i < len; ++i)\n+\t    {\n+\t      tree t = streamer_tree_cache_get_tree (data_in->reader_cache,\n+\t\t\t\t\t\t     from + i);\n+\t      /* For statistics, see if the old code would have merged\n+\t\t the type.  */\n+\t      if (TYPE_P (t)\n+\t\t  && (flag_lto_report || (flag_wpa && flag_lto_report_wpa)))\n+\t\t{\n+\t\t  tree newt = gimple_register_type (t);\n+\t\t  if (newt != t)\n+\t\t    {\n+\t\t      num_not_merged_types++;\n+\t\t      unsigned j;\n+\t\t      /* Check if we can never merge the types because\n+\t\t\t they are in the same SCC and thus the old\n+\t\t\t code was broken.  */\n+\t\t      for (j = 0; j < len; ++j)\n+\t\t\tif (i != j\n+\t\t\t    && streamer_tree_cache_get_tree\n+\t\t\t         (data_in->reader_cache, from + j) == newt)\n+\t\t\t  {\n+\t\t\t    num_not_merged_types_in_same_scc++;\n+\t\t\t    not_merged_type_same_scc = true;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t      if (j == len)\n+\t\t\tnot_merged_type_not_same_scc = true;\n+\t\t    }\n+\t\t}\n+\t      /* Reconstruct the type variant and pointer-to/reference-to\n+\t\t chains.  */\n+\t      if (TYPE_P (t))\n+\t\t{\n+\t\t  seen_type = true;\n+\t\t  num_prevailing_types++;\n+\t\t  lto_fixup_prevailing_type (t);\n+\t\t}\n+\t      /* Compute the canonical type of all types.\n+\t\t ???  Should be able to assert that !TYPE_CANONICAL.  */\n+\t      if (TYPE_P (t) && !TYPE_CANONICAL (t))\n+\t\tTYPE_CANONICAL (t) = gimple_register_canonical_type (t);\n+\t      /* Link shared INTEGER_CSTs into TYPE_CACHED_VALUEs of its\n+\t\t type which is also member of this SCC.  */\n+\t      if (TREE_CODE (t) == INTEGER_CST\n+\t\t  && !TREE_OVERFLOW (t))\n+\t\tcache_integer_cst (t);\n+\t      /* Register TYPE_DECLs with the debuginfo machinery.  */\n+\t      if (!flag_wpa\n+\t\t  && TREE_CODE (t) == TYPE_DECL)\n+\t\tdebug_hooks->type_decl (t, !DECL_FILE_SCOPE_P (t));\n+\t      if (!flag_ltrans)\n+\t\t{\n+\t\t  /* Register variables and functions with the\n+\t\t     symbol table.  */\n+\t\t  if (TREE_CODE (t) == VAR_DECL)\n+\t\t    lto_register_var_decl_in_symtab (data_in, t);\n+\t\t  else if (TREE_CODE (t) == FUNCTION_DECL\n+\t\t\t   && !DECL_BUILT_IN (t))\n+\t\t    lto_register_function_decl_in_symtab (data_in, t);\n+\t\t  /* Scan the tree for references to global functions or\n+\t\t     variables and record those for later fixup.  */\n+\t\t  maybe_remember_with_vars (t);\n+\t\t}\n+\t    }\n+\t  if (not_merged_type_same_scc)\n+\t    {\n+\t      num_not_merged_types_in_same_scc_trees += len;\n+\t      num_not_merged_types_trees += len;\n+\t    }\n+\t  else if (not_merged_type_not_same_scc)\n+\t    num_not_merged_types_trees += len;\n+\t  if (seen_type)\n+\t    num_type_scc_trees += len;\n+\t}\n+      else\n+\t{\n+\t  /* Pickle stray references.  */\n+\t  t = lto_input_tree_1 (&ib_main, data_in, tag, 0);\n+\t  gcc_assert (t && data_in->reader_cache->nodes.length () == from);\n+\t}\n     }\n \n   /* Read in lto_in_decl_state objects.  */\n@@ -2898,9 +3377,9 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n \t\t\t\t     tree_int_map_eq, NULL);\n   type_pair_cache = XCNEWVEC (struct type_pair_d, GIMPLE_TYPE_PAIR_SIZE);\n-  gimple_type_leader = ggc_alloc_cleared_vec_gimple_type_leader_entry_s\n-\t\t        (GIMPLE_TYPE_LEADER_SIZE);\n   gimple_types = htab_create_ggc (16381, gimple_type_hash, gimple_type_eq, 0);\n+  gcc_obstack_init (&tree_scc_hash_obstack);\n+  tree_scc_hash.create (4096);\n \n   if (!quiet_flag)\n     fprintf (stderr, \"Reading object files:\");\n@@ -2933,7 +3412,6 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n       lto_obj_file_close (current_lto_file);\n       free (current_lto_file);\n       current_lto_file = NULL;\n-      ggc_collect ();\n     }\n \n   lto_flatten_files (decl_data, count, last_file_ix);\n@@ -2955,7 +3433,8 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   type_hash_cache = NULL;\n   free (type_pair_cache);\n   type_pair_cache = NULL;\n-  gimple_type_leader = NULL;\n+  tree_scc_hash.dispose ();\n+  obstack_free (&tree_scc_hash_obstack, NULL);\n   free_gimple_type_tables ();\n   ggc_collect ();\n \n@@ -3121,27 +3600,49 @@ print_lto_report_1 (void)\n   const char *pfx = (flag_lto) ? \"LTO\" : (flag_wpa) ? \"WPA\" : \"LTRANS\";\n   fprintf (stderr, \"%s statistics\\n\", pfx);\n \n-  if (gimple_types)\n-    fprintf (stderr, \"[%s] GIMPLE type table: size %ld, %ld elements, \"\n-\t     \"%ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n-\t     (long) htab_size (gimple_types),\n-\t     (long) htab_elements (gimple_types),\n-\t     (long) gimple_types->searches,\n-\t     (long) gimple_types->collisions,\n-\t     htab_collisions (gimple_types));\n-  else\n-    fprintf (stderr, \"[%s] GIMPLE type table is empty\\n\", pfx);\n-  if (type_hash_cache)\n-    fprintf (stderr, \"[%s] GIMPLE type hash cache table: size %ld, %ld elements, \"\n-\t     \"%ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n-\t     (long) htab_size (type_hash_cache),\n-\t     (long) htab_elements (type_hash_cache),\n-\t     (long) type_hash_cache->searches,\n-\t     (long) type_hash_cache->collisions,\n-\t     htab_collisions (type_hash_cache));\n-  else\n-    fprintf (stderr, \"[%s] GIMPLE type hash cache table is empty\\n\", pfx);\n-  fprintf (stderr, \"[%s] Merged %lu types\\n\", pfx, num_merged_types);\n+  fprintf (stderr, \"[%s] read %lu SCCs of average size %f\\n\",\n+\t   pfx, num_sccs_read, total_scc_size / (double)num_sccs_read);\n+  fprintf (stderr, \"[%s] %lu tree bodies read in total\\n\", pfx, total_scc_size);\n+  if (flag_wpa && tree_scc_hash.is_created ())\n+    {\n+      fprintf (stderr, \"[%s] tree SCC table: size %ld, %ld elements, \"\n+\t       \"collision ratio: %f\\n\", pfx,\n+\t       (long) tree_scc_hash.size (),\n+\t       (long) tree_scc_hash.elements (),\n+\t       tree_scc_hash.collisions ());\n+      hash_table<tree_scc_hasher>::iterator hiter;\n+      tree_scc *scc, *max_scc = NULL;\n+      unsigned max_length = 0;\n+      FOR_EACH_HASH_TABLE_ELEMENT (tree_scc_hash, scc, x, hiter)\n+\t{\n+\t  unsigned length = 0;\n+\t  tree_scc *s = scc;\n+\t  for (; s; s = s->next)\n+\t    length++;\n+\t  if (length > max_length)\n+\t    {\n+\t      max_length = length;\n+\t      max_scc = scc;\n+\t    }\n+\t}\n+      fprintf (stderr, \"[%s] tree SCC max chain length %u (size %u)\\n\",\n+\t       pfx, max_length, max_scc->len);\n+      fprintf (stderr, \"[%s] Compared %lu SCCs, %lu collisions (%f)\\n\", pfx,\n+\t       num_scc_compares, num_scc_compare_collisions,\n+\t       num_scc_compare_collisions / (double) num_scc_compares);\n+      fprintf (stderr, \"[%s] Merged %lu SCCs\\n\", pfx, num_sccs_merged);\n+      fprintf (stderr, \"[%s] Merged %lu tree bodies\\n\", pfx,\n+\t       total_scc_size_merged);\n+      fprintf (stderr, \"[%s] Merged %lu types\\n\", pfx, num_merged_types);\n+      fprintf (stderr, \"[%s] %lu types prevailed (%lu associated trees)\\n\",\n+\t       pfx, num_prevailing_types, num_type_scc_trees);\n+      fprintf (stderr, \"[%s] Old merging code merges an additional %lu types\"\n+\t       \" of which %lu are in the same SCC with their \"\n+\t       \"prevailing variant (%lu and %lu associated trees)\\n\",\n+\t       pfx, num_not_merged_types, num_not_merged_types_in_same_scc,\n+\t       num_not_merged_types_trees,\n+\t       num_not_merged_types_in_same_scc_trees);\n+    }\n \n   print_gimple_types_stats (pfx);\n   print_lto_report (pfx);"}, {"sha": "00f78a13df3a46c03ccf8418d442ef711391230a", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -122,10 +122,10 @@ unpack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n     TYPE_ARTIFICIAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n   else\n     TREE_NO_WARNING (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TREE_USED (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TREE_NOTHROW (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TREE_STATIC (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TREE_PRIVATE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  if (TREE_CODE (expr) != TREE_BINFO)\n+    TREE_PRIVATE (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TREE_PROTECTED (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TREE_DEPRECATED (expr) = (unsigned) bp_unpack_value (bp, 1);\n   if (TYPE_P (expr))\n@@ -351,8 +351,6 @@ unpack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n     TYPE_NONALIASED_COMPONENT (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TYPE_PACKED (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TYPE_RESTRICT (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TYPE_CONTAINS_PLACEHOLDER_INTERNAL (expr)\n-    \t= (unsigned) bp_unpack_value (bp, 2);\n   TYPE_USER_ALIGN (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TYPE_READONLY (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TYPE_PRECISION (expr) = bp_unpack_var_len_unsigned (bp);\n@@ -811,7 +809,7 @@ lto_input_ts_list_tree_pointers (struct lto_input_block *ib,\n {\n   TREE_PURPOSE (expr) = stream_read_tree (ib, data_in);\n   TREE_VALUE (expr) = stream_read_tree (ib, data_in);\n-  TREE_CHAIN (expr) = streamer_read_chain (ib, data_in);\n+  TREE_CHAIN (expr) = stream_read_tree (ib, data_in);\n }\n \n \n@@ -1021,19 +1019,6 @@ streamer_read_tree_body (struct lto_input_block *ib, struct data_in *data_in,\n }\n \n \n-/* Read and INTEGER_CST node from input block IB using the per-file\n-   context in DATA_IN.  */\n-\n-tree\n-streamer_read_integer_cst (struct lto_input_block *ib, struct data_in *data_in)\n-{\n-  tree type = stream_read_tree (ib, data_in);\n-  unsigned HOST_WIDE_INT low = streamer_read_uhwi (ib);\n-  HOST_WIDE_INT high = streamer_read_hwi (ib);\n-  return build_int_cst_wide (type, low, high);\n-}\n-\n-\n /* Read an index IX from input block IB and return the tree node at\n    DATA_IN->FILE_DATA->GLOBALS_INDEX[IX].  */\n \n@@ -1047,7 +1032,7 @@ streamer_get_pickled_tree (struct lto_input_block *ib, struct data_in *data_in)\n   ix = streamer_read_uhwi (ib);\n   expected_tag = streamer_read_enum (ib, LTO_tags, LTO_NUM_TAGS);\n \n-  result = streamer_tree_cache_get (data_in->reader_cache, ix);\n+  result = streamer_tree_cache_get_tree (data_in->reader_cache, ix);\n   gcc_assert (result\n               && TREE_CODE (result) == lto_tag_to_tree_code (expected_tag));\n \n@@ -1091,7 +1076,7 @@ streamer_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n   if (asmname)\n     set_builtin_user_assembler_name (result, asmname);\n \n-  streamer_tree_cache_append (data_in->reader_cache, result);\n+  streamer_tree_cache_append (data_in->reader_cache, result, 0);\n \n   return result;\n }"}, {"sha": "fa50ef5b7ad1df71319768630e0a854e47e935d9", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -95,10 +95,10 @@ pack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n     bp_pack_value (bp, TYPE_ARTIFICIAL (expr), 1);\n   else\n     bp_pack_value (bp, TREE_NO_WARNING (expr), 1);\n-  bp_pack_value (bp, TREE_USED (expr), 1);\n   bp_pack_value (bp, TREE_NOTHROW (expr), 1);\n   bp_pack_value (bp, TREE_STATIC (expr), 1);\n-  bp_pack_value (bp, TREE_PRIVATE (expr), 1);\n+  if (TREE_CODE (expr) != TREE_BINFO)\n+    bp_pack_value (bp, TREE_PRIVATE (expr), 1);\n   bp_pack_value (bp, TREE_PROTECTED (expr), 1);\n   bp_pack_value (bp, TREE_DEPRECATED (expr), 1);\n   if (TYPE_P (expr))\n@@ -298,12 +298,15 @@ pack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n     bp_pack_value (bp, TYPE_NONALIASED_COMPONENT (expr), 1);\n   bp_pack_value (bp, TYPE_PACKED (expr), 1);\n   bp_pack_value (bp, TYPE_RESTRICT (expr), 1);\n-  bp_pack_value (bp, TYPE_CONTAINS_PLACEHOLDER_INTERNAL (expr), 2);\n   bp_pack_value (bp, TYPE_USER_ALIGN (expr), 1);\n   bp_pack_value (bp, TYPE_READONLY (expr), 1);\n   bp_pack_var_len_unsigned (bp, TYPE_PRECISION (expr));\n   bp_pack_var_len_unsigned (bp, TYPE_ALIGN (expr));\n-  bp_pack_var_len_int (bp, TYPE_ALIAS_SET (expr) == 0 ? 0 : -1);\n+  /* Make sure to preserve the fact whether the frontend would assign\n+     alias-set zero to this type.  */\n+  bp_pack_var_len_int (bp, (TYPE_ALIAS_SET (expr) == 0\n+\t\t\t    || (!in_lto_p\n+\t\t\t\t&& get_alias_set (expr) == 0)) ? 0 : -1);\n }\n \n \n@@ -491,9 +494,10 @@ streamer_write_chain (struct output_block *ob, tree t, bool ref_p)\n \t to the global decls section as we do not want to have them\n \t enter decl merging.  This is, of course, only for the call\n \t for streaming BLOCK_VARS, but other callers are safe.  */\n+      /* ???  FIXME wrt SCC streaming.  Drop these for now.  */\n       if (VAR_OR_FUNCTION_DECL_P (t)\n \t  && DECL_EXTERNAL (t))\n-\tstream_write_tree_shallow_non_ref (ob, t, ref_p);\n+\t; /* stream_write_tree_shallow_non_ref (ob, t, ref_p); */\n       else\n \tstream_write_tree (ob, t, ref_p);\n \n@@ -553,7 +557,13 @@ static void\n write_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t     bool ref_p)\n {\n-  stream_write_tree (ob, DECL_NAME (expr), ref_p);\n+  /* Drop names that were created for anonymous entities.  */\n+  if (DECL_NAME (expr)\n+      && TREE_CODE (DECL_NAME (expr)) == IDENTIFIER_NODE\n+      && ANON_AGGRNAME_P (DECL_NAME (expr)))\n+    stream_write_tree (ob, NULL_TREE, ref_p);\n+  else\n+    stream_write_tree (ob, DECL_NAME (expr), ref_p);\n   stream_write_tree (ob, DECL_CONTEXT (expr), ref_p);\n }\n \n@@ -716,7 +726,7 @@ write_ts_list_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n   stream_write_tree (ob, TREE_PURPOSE (expr), ref_p);\n   stream_write_tree (ob, TREE_VALUE (expr), ref_p);\n-  streamer_write_chain (ob, TREE_CHAIN (expr), ref_p);\n+  stream_write_tree (ob, TREE_CHAIN (expr), ref_p);\n }\n \n \n@@ -842,6 +852,8 @@ streamer_write_tree_body (struct output_block *ob, tree expr, bool ref_p)\n {\n   enum tree_code code;\n \n+  lto_stats.num_tree_bodies_output++;\n+\n   code = TREE_CODE (expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPED))"}, {"sha": "fcdf432735063216a84f87f7a6d5cfdf5e038d4b", "filename": "gcc/tree-streamer.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.c?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -92,16 +92,24 @@ streamer_check_handled_ts_structures (void)\n \n static void\n streamer_tree_cache_add_to_node_array (struct streamer_tree_cache_d *cache,\n-\t\t\t\t       unsigned ix, tree t)\n+\t\t\t\t       unsigned ix, tree t, hashval_t hash)\n {\n   /* Make sure we're either replacing an old element or\n      appending consecutively.  */\n   gcc_assert (ix <= cache->nodes.length ());\n \n   if (ix == cache->nodes.length ())\n-    cache->nodes.safe_push (t);\n+    {\n+      cache->nodes.safe_push (t);\n+      if (cache->hashes.exists ())\n+\tcache->hashes.safe_push (hash);\n+    }\n   else\n-    cache->nodes[ix] = t;\n+    {\n+      cache->nodes[ix] = t;\n+      if (cache->hashes.exists ())\n+\tcache->hashes[ix] = hash;\n+    }\n }\n \n \n@@ -117,7 +125,7 @@ streamer_tree_cache_add_to_node_array (struct streamer_tree_cache_d *cache,\n \n static bool\n streamer_tree_cache_insert_1 (struct streamer_tree_cache_d *cache,\n-\t\t\t      tree t, unsigned *ix_p,\n+\t\t\t      tree t, hashval_t hash, unsigned *ix_p,\n \t\t\t      bool insert_at_next_slot_p)\n {\n   void **slot;\n@@ -136,7 +144,7 @@ streamer_tree_cache_insert_1 (struct streamer_tree_cache_d *cache,\n \tix = *ix_p;\n        *slot = (void *)(size_t) (ix + 1);\n \n-      streamer_tree_cache_add_to_node_array (cache, ix, t);\n+      streamer_tree_cache_add_to_node_array (cache, ix, t, hash);\n \n       /* Indicate that the item was not present in the cache.  */\n       existed_p = false;\n@@ -151,7 +159,7 @@ streamer_tree_cache_insert_1 (struct streamer_tree_cache_d *cache,\n \t     location, and ENTRY->TO does not match *IX_P, add T to\n \t     the requested location slot.  */\n \t  ix = *ix_p;\n-\t  streamer_tree_cache_add_to_node_array (cache, ix, t);\n+\t  streamer_tree_cache_add_to_node_array (cache, ix, t, hash);\n \t  *slot = (void *)(size_t) (ix + 1);\n \t}\n \n@@ -174,30 +182,33 @@ streamer_tree_cache_insert_1 (struct streamer_tree_cache_d *cache,\n \n bool\n streamer_tree_cache_insert (struct streamer_tree_cache_d *cache, tree t,\n-\t\t\t    unsigned *ix_p)\n+\t\t\t    hashval_t hash, unsigned *ix_p)\n {\n-  return streamer_tree_cache_insert_1 (cache, t, ix_p, true);\n+  return streamer_tree_cache_insert_1 (cache, t, hash, ix_p, true);\n }\n \n \n-/* Insert tree node T in CACHE at slot IX.  If T already\n-   existed in the cache return true.  Otherwise, return false.  */\n+/* Replace the tree node with T in CACHE at slot IX.  */\n \n-bool\n-streamer_tree_cache_insert_at (struct streamer_tree_cache_d *cache,\n-\t\t\t       tree t, unsigned ix)\n+void\n+streamer_tree_cache_replace_tree (struct streamer_tree_cache_d *cache,\n+\t\t\t\t  tree t, unsigned ix)\n {\n-  return streamer_tree_cache_insert_1 (cache, t, &ix, false);\n+  hashval_t hash = 0;\n+  if (cache->hashes.exists ())\n+    hash = streamer_tree_cache_get_hash (cache, ix);\n+  streamer_tree_cache_insert_1 (cache, t, hash, &ix, false);\n }\n \n \n /* Appends tree node T to CACHE, even if T already existed in it.  */\n \n void\n-streamer_tree_cache_append (struct streamer_tree_cache_d *cache, tree t)\n+streamer_tree_cache_append (struct streamer_tree_cache_d *cache,\n+\t\t\t    tree t, hashval_t hash)\n {\n   unsigned ix = cache->nodes.length ();\n-  streamer_tree_cache_insert_1 (cache, t, &ix, false);\n+  streamer_tree_cache_insert_1 (cache, t, hash, &ix, false);\n }\n \n /* Return true if tree node T exists in CACHE, otherwise false.  If IX_P is\n@@ -257,7 +268,10 @@ record_common_node (struct streamer_tree_cache_d *cache, tree node)\n   if (!node)\n     node = error_mark_node;\n \n-  streamer_tree_cache_append (cache, node);\n+  /* ???  FIXME, devise a better hash value.  But the hash needs to be equal\n+     for all frontend and lto1 invocations.  So just use the position\n+     in the cache as hash value.  */\n+  streamer_tree_cache_append (cache, node, cache->nodes.length ());\n \n   if (POINTER_TYPE_P (node)\n       || TREE_CODE (node) == COMPLEX_TYPE\n@@ -305,13 +319,16 @@ preload_common_nodes (struct streamer_tree_cache_d *cache)\n /* Create a cache of pickled nodes.  */\n \n struct streamer_tree_cache_d *\n-streamer_tree_cache_create (void)\n+streamer_tree_cache_create (bool with_hashes)\n {\n   struct streamer_tree_cache_d *cache;\n \n   cache = XCNEW (struct streamer_tree_cache_d);\n \n   cache->node_map = pointer_map_create ();\n+  cache->nodes.create (165);\n+  if (with_hashes)\n+    cache->hashes.create (165);\n \n   /* Load all the well-known tree nodes that are always created by\n      the compiler on startup.  This prevents writing them out\n@@ -332,5 +349,6 @@ streamer_tree_cache_delete (struct streamer_tree_cache_d *c)\n \n   pointer_map_destroy (c->node_map);\n   c->nodes.release ();\n+  c->hashes.release ();\n   free (c);\n }"}, {"sha": "d28552846c29b01ed243263a232eb6e967937f7e", "filename": "gcc/tree-streamer.h", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.h?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -43,13 +43,16 @@ along with GCC; see the file COPYING3.  If not see\n      T.  The reconstructed T is inserted in some array so that when\n      the reference index for T is found in the input stream, it can be\n      used to look up into the array to get the reconstructed T.  */\n+\n struct streamer_tree_cache_d\n {\n   /* The mapping between tree nodes and slots into the nodes array.  */\n   struct pointer_map_t *node_map;\n \n   /* The nodes pickled so far.  */\n   vec<tree> nodes;\n+  /* The node hashes (if available).  */\n+  vec<hashval_t> hashes;\n };\n \n /* Return true if tree node EXPR should be streamed as a builtin.  For\n@@ -71,7 +74,6 @@ tree streamer_alloc_tree (struct lto_input_block *, struct data_in *,\n void streamer_read_tree_body (struct lto_input_block *, struct data_in *, tree);\n tree streamer_get_pickled_tree (struct lto_input_block *, struct data_in *);\n tree streamer_get_builtin_tree (struct lto_input_block *, struct data_in *);\n-tree streamer_read_integer_cst (struct lto_input_block *, struct data_in *);\n struct bitpack_d streamer_read_tree_bitfields (struct lto_input_block *,\n \t\t\t\t\t       struct data_in *, tree);\n \n@@ -89,22 +91,31 @@ void streamer_write_builtin (struct output_block *, tree);\n /* In tree-streamer.c.  */\n void streamer_check_handled_ts_structures (void);\n bool streamer_tree_cache_insert (struct streamer_tree_cache_d *, tree,\n-\t\t\t\t unsigned *);\n-bool streamer_tree_cache_insert_at (struct streamer_tree_cache_d *, tree,\n-\t\t\t\t    unsigned);\n-void streamer_tree_cache_append (struct streamer_tree_cache_d *, tree);\n+\t\t\t\t hashval_t, unsigned *);\n+void streamer_tree_cache_replace_tree (struct streamer_tree_cache_d *, tree,\n+\t\t\t\t       unsigned);\n+void streamer_tree_cache_append (struct streamer_tree_cache_d *, tree,\n+\t\t\t\t hashval_t);\n bool streamer_tree_cache_lookup (struct streamer_tree_cache_d *, tree,\n \t\t\t\t unsigned *);\n-struct streamer_tree_cache_d *streamer_tree_cache_create (void);\n+struct streamer_tree_cache_d *streamer_tree_cache_create (bool);\n void streamer_tree_cache_delete (struct streamer_tree_cache_d *);\n \n /* Return the tree node at slot IX in CACHE.  */\n \n static inline tree\n-streamer_tree_cache_get (struct streamer_tree_cache_d *cache, unsigned ix)\n+streamer_tree_cache_get_tree (struct streamer_tree_cache_d *cache, unsigned ix)\n {\n   return cache->nodes[ix];\n }\n \n+/* Return the tree hash value at slot IX in CACHE.  */\n+\n+static inline hashval_t\n+streamer_tree_cache_get_hash (struct streamer_tree_cache_d *cache, unsigned ix)\n+{\n+  return cache->hashes[ix];\n+}\n+\n \n #endif  /* GCC_TREE_STREAMER_H  */"}, {"sha": "67553b89294d5d2d984f46b76a52e8d89a3a65ad", "filename": "gcc/tree.c", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -1266,6 +1266,99 @@ build_int_cst_wide (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n   return t;\n }\n \n+void\n+cache_integer_cst (tree t)\n+{\n+  tree type = TREE_TYPE (t);\n+  HOST_WIDE_INT hi = TREE_INT_CST_HIGH (t);\n+  unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (t);\n+  int ix = -1;\n+  int limit = 0;\n+\n+  gcc_assert (!TREE_OVERFLOW (t));\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case NULLPTR_TYPE:\n+      gcc_assert (hi == 0 && low == 0);\n+      /* Fallthru.  */\n+\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      /* Cache NULL pointer.  */\n+      if (!hi && !low)\n+\t{\n+\t  limit = 1;\n+\t  ix = 0;\n+\t}\n+      break;\n+\n+    case BOOLEAN_TYPE:\n+      /* Cache false or true.  */\n+      limit = 2;\n+      if (!hi && low < 2)\n+\tix = low;\n+      break;\n+\n+    case INTEGER_TYPE:\n+    case OFFSET_TYPE:\n+      if (TYPE_UNSIGNED (type))\n+\t{\n+\t  /* Cache 0..N */\n+\t  limit = INTEGER_SHARE_LIMIT;\n+\t  if (!hi && low < (unsigned HOST_WIDE_INT)INTEGER_SHARE_LIMIT)\n+\t    ix = low;\n+\t}\n+      else\n+\t{\n+\t  /* Cache -1..N */\n+\t  limit = INTEGER_SHARE_LIMIT + 1;\n+\t  if (!hi && low < (unsigned HOST_WIDE_INT)INTEGER_SHARE_LIMIT)\n+\t    ix = low + 1;\n+\t  else if (hi == -1 && low == -(unsigned HOST_WIDE_INT)1)\n+\t    ix = 0;\n+\t}\n+      break;\n+\n+    case ENUMERAL_TYPE:\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (ix >= 0)\n+    {\n+      /* Look for it in the type's vector of small shared ints.  */\n+      if (!TYPE_CACHED_VALUES_P (type))\n+\t{\n+\t  TYPE_CACHED_VALUES_P (type) = 1;\n+\t  TYPE_CACHED_VALUES (type) = make_tree_vec (limit);\n+\t}\n+\n+      gcc_assert (TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix) == NULL_TREE);\n+      TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix) = t;\n+    }\n+  else\n+    {\n+      /* Use the cache of larger shared ints.  */\n+      void **slot;\n+\n+      slot = htab_find_slot (int_cst_hash_table, t, INSERT);\n+      /* If there is already an entry for the number verify it's the\n+         same.  */\n+      if (*slot)\n+\t{\n+\t  gcc_assert (TREE_INT_CST_LOW ((tree)*slot) == low\n+\t\t      && TREE_INT_CST_HIGH ((tree)*slot) == hi);\n+\t  return;\n+\t}\n+      /* Otherwise insert this one into the hash table.  */\n+      *slot = t;\n+    }\n+}\n+\n+\n /* Builds an integer constant in TYPE such that lowest BITS bits are ones\n    and the rest are zeros.  */\n "}, {"sha": "cbbdd0bbc0839d58eb2ffb1770508f8a36442db2", "filename": "gcc/tree.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -5637,6 +5637,7 @@ extern const_tree strip_invariant_refs (const_tree);\n extern tree lhd_gcc_personality (void);\n extern void assign_assembler_name_if_neeeded (tree);\n extern void warn_deprecated_use (tree, tree);\n+extern void cache_integer_cst (tree);\n \n \f\n /* In cgraph.c */\n@@ -6582,4 +6583,27 @@ builtin_decl_implicit_p (enum built_in_function fncode)\n \t  && builtin_info.implicit_p[uns_fncode]);\n }\n \n+\n+/* For anonymous aggregate types, we need some sort of name to\n+   hold on to.  In practice, this should not appear, but it should\n+   not be harmful if it does.  */\n+#ifndef NO_DOT_IN_LABEL\n+#define ANON_AGGRNAME_FORMAT \"._%d\"\n+#define ANON_AGGRNAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[0] == '.' \\\n+\t\t\t\t  && IDENTIFIER_POINTER (ID_NODE)[1] == '_')\n+#else /* NO_DOT_IN_LABEL */\n+#ifndef NO_DOLLAR_IN_LABEL\n+#define ANON_AGGRNAME_FORMAT \"$_%d\"\n+#define ANON_AGGRNAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[0] == '$' \\\n+\t\t\t\t  && IDENTIFIER_POINTER (ID_NODE)[1] == '_')\n+#else /* NO_DOLLAR_IN_LABEL */\n+#define ANON_AGGRNAME_PREFIX \"__anon_\"\n+#define ANON_AGGRNAME_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), ANON_AGGRNAME_PREFIX, \\\n+\t     sizeof (ANON_AGGRNAME_PREFIX) - 1))\n+#define ANON_AGGRNAME_FORMAT \"__anon_%d\"\n+#endif\t/* NO_DOLLAR_IN_LABEL */\n+#endif\t/* NO_DOT_IN_LABEL */\n+\n+\n #endif  /* GCC_TREE_H  */"}, {"sha": "80e98b3dd5dde6d4441bcc1b0e4ebebfd9c9169e", "filename": "gcc/varpool.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee03e71d472a3f73cbc1a132a284309f36565972/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=ee03e71d472a3f73cbc1a132a284309f36565972", "patch": "@@ -84,7 +84,12 @@ varpool_remove_initializer (struct varpool_node *node)\n       /* Keep vtables for BINFO folding.  */\n       && !DECL_VIRTUAL_P (node->symbol.decl)\n       /* FIXME: http://gcc.gnu.org/PR55395 */\n-      && debug_info_level == DINFO_LEVEL_NONE)\n+      && debug_info_level == DINFO_LEVEL_NONE\n+      /* When doing declaration merging we have duplicate\n+\t entries for given decl.  Do not attempt to remove\n+\t the boides, or we will end up remiving\n+\t wrong one.  */\n+      && cgraph_state != CGRAPH_LTO_STREAMING)\n     DECL_INITIAL (node->symbol.decl) = error_mark_node;\n }\n "}]}