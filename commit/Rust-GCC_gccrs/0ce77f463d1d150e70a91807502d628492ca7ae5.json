{"sha": "0ce77f463d1d150e70a91807502d628492ca7ae5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNlNzdmNDYzZDFkMTUwZTcwYTkxODA3NTAyZDYyODQ5MmNhN2FlNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:21:19Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:21:19Z"}, "message": "Remove global call sets: regrename.c\n\nThis patch makes regrename use a similar mask-and-clobber-set\npair to IRA when tracking whether registers are clobbered by\ncalls in a region.  Testing for a nonzero ABI mask is equivalent\nto testing for a register that crosses a call.\n\nSince AArch64 and c6x use regrename.h, they need to be updated\nto include function-abi.h first.  AIUI this is preferred over\nincluding function-abi.h in regrename.h.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* regrename.h (du_head::call_clobber_mask): New field.\n\t(du_head::need_caller_save_reg): Replace with...\n\t(du_head::call_abis): ...this new field.\n\t* regrename.c: Include function-abi.h.\n\t(call_clobbered_in_chain_p): New function.\n\t(check_new_reg_p): Use crtl->abi when deciding whether a register\n\tis free for use after RA.  Use call_clobbered_in_chain_p to test\n\twhether a candidate register would be clobbered by a call.\n\t(find_rename_reg): Don't add call-clobber conflicts here.\n\t(rename_chains): Check call_abis instead of need_caller_save_reg.\n\t(merge_chains): Update for changes to du_head.\n\t(build_def_use): Use insn_callee_abi to get the ABI of the call insn\n\ttarget.  Record the ABI identifier in call_abis and the set of\n\tfully or partially clobbered registers in call_clobber_mask.\n\tAdd fully-clobbered registers to hard_conflicts here rather\n\tthan in find_rename_reg.\n\t* config/aarch64/cortex-a57-fma-steering.c: Include function-abi.h.\n\t(rename_single_chain): Check call_abis instead of need_caller_save_reg.\n\t* config/aarch64/falkor-tag-collision-avoidance.c: Include\n\tfunction-abi.h.\n\t* config/c6x/c6x.c: Likewise.\n\nFrom-SVN: r276332", "tree": {"sha": "fff69a7a5884e5343e2f31969d911df27599af70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fff69a7a5884e5343e2f31969d911df27599af70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ce77f463d1d150e70a91807502d628492ca7ae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ce77f463d1d150e70a91807502d628492ca7ae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ce77f463d1d150e70a91807502d628492ca7ae5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ce77f463d1d150e70a91807502d628492ca7ae5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30503f4ea491b9d6b9da00889155ecaa5d15cfb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30503f4ea491b9d6b9da00889155ecaa5d15cfb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30503f4ea491b9d6b9da00889155ecaa5d15cfb9"}], "stats": {"total": 77, "additions": 59, "deletions": 18}, "files": [{"sha": "6458d2b2e3bfcadf94fdef4afdac9bb649835f59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ce77f463d1d150e70a91807502d628492ca7ae5", "patch": "@@ -1,3 +1,27 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* regrename.h (du_head::call_clobber_mask): New field.\n+\t(du_head::need_caller_save_reg): Replace with...\n+\t(du_head::call_abis): ...this new field.\n+\t* regrename.c: Include function-abi.h.\n+\t(call_clobbered_in_chain_p): New function.\n+\t(check_new_reg_p): Use crtl->abi when deciding whether a register\n+\tis free for use after RA.  Use call_clobbered_in_chain_p to test\n+\twhether a candidate register would be clobbered by a call.\n+\t(find_rename_reg): Don't add call-clobber conflicts here.\n+\t(rename_chains): Check call_abis instead of need_caller_save_reg.\n+\t(merge_chains): Update for changes to du_head.\n+\t(build_def_use): Use insn_callee_abi to get the ABI of the call insn\n+\ttarget.  Record the ABI identifier in call_abis and the set of\n+\tfully or partially clobbered registers in call_clobber_mask.\n+\tAdd fully-clobbered registers to hard_conflicts here rather\n+\tthan in find_rename_reg.\n+\t* config/aarch64/cortex-a57-fma-steering.c: Include function-abi.h.\n+\t(rename_single_chain): Check call_abis instead of need_caller_save_reg.\n+\t* config/aarch64/falkor-tag-collision-avoidance.c: Include\n+\tfunction-abi.h.\n+\t* config/c6x/c6x.c: Likewise.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* regcprop.c (copyprop_hardreg_forward_1): Use the recorded"}, {"sha": "d8e6038d13c1fe4353b3fe7173d587601e26a2f8", "filename": "gcc/config/aarch64/cortex-a57-fma-steering.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c?ref=0ce77f463d1d150e70a91807502d628492ca7ae5", "patch": "@@ -37,6 +37,7 @@\n #include \"insn-attr.h\"\n #include \"context.h\"\n #include \"tree-pass.h\"\n+#include \"function-abi.h\"\n #include \"regrename.h\"\n #include \"aarch64-protos.h\"\n \n@@ -281,7 +282,7 @@ rename_single_chain (du_head_p head, HARD_REG_SET *unavailable)\n     {\n       fprintf (dump_file, \"Register %s in insn %d\", reg_names[reg],\n \t       INSN_UID (head->first->insn));\n-      if (head->need_caller_save_reg)\n+      if (head->call_abis)\n \tfprintf (dump_file, \" crosses a call\");\n     }\n "}, {"sha": "35ca79232570d088bfe825168cb153cfc002c89a", "filename": "gcc/config/aarch64/falkor-tag-collision-avoidance.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2Fconfig%2Faarch64%2Ffalkor-tag-collision-avoidance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2Fconfig%2Faarch64%2Ffalkor-tag-collision-avoidance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Ffalkor-tag-collision-avoidance.c?ref=0ce77f463d1d150e70a91807502d628492ca7ae5", "patch": "@@ -38,6 +38,7 @@\n #include \"optabs.h\"\n #include \"regs.h\"\n #include \"recog.h\"\n+#include \"function-abi.h\"\n #include \"regrename.h\"\n #include \"print-rtl.h\"\n "}, {"sha": "f8e8295245baa99baf6e32bd1bee2813164aa07d", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=0ce77f463d1d150e70a91807502d628492ca7ae5", "patch": "@@ -55,6 +55,7 @@\n #include \"sel-sched.h\"\n #include \"debug.h\"\n #include \"hw-doloop.h\"\n+#include \"function-abi.h\"\n #include \"regrename.h\"\n #include \"dumpfile.h\"\n #include \"builtins.h\""}, {"sha": "8c3bae8998c4decc788f940d265f7449f604571b", "filename": "gcc/regrename.c", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=0ce77f463d1d150e70a91807502d628492ca7ae5", "patch": "@@ -33,6 +33,7 @@\n #include \"addresses.h\"\n #include \"cfganal.h\"\n #include \"tree-pass.h\"\n+#include \"function-abi.h\"\n #include \"regrename.h\"\n \n /* This file implements the RTL register renaming pass of the compiler.  It is\n@@ -303,6 +304,18 @@ merge_overlapping_regs (HARD_REG_SET *pset, class du_head *head)\n     }\n }\n \n+/* Return true if (reg:MODE REGNO) would be clobbered by a call covered\n+   by THIS_HEAD.  */\n+\n+static bool\n+call_clobbered_in_chain_p (du_head *this_head, machine_mode mode,\n+\t\t\t   unsigned int regno)\n+{\n+  return call_clobbered_in_region_p (this_head->call_abis,\n+\t\t\t\t     this_head->call_clobber_mask,\n+\t\t\t\t     mode, regno);\n+}\n+\n /* Check if NEW_REG can be the candidate register to rename for\n    REG in THIS_HEAD chain.  THIS_UNAVAILABLE is a set of unavailable hard\n    registers.  */\n@@ -322,7 +335,7 @@ check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n \t|| global_regs[new_reg + i]\n \t/* Can't use regs which aren't saved by the prologue.  */\n \t|| (! df_regs_ever_live_p (new_reg + i)\n-\t    && ! call_used_or_fixed_reg_p (new_reg + i))\n+\t    && ! crtl->abi->clobbers_full_reg_p (new_reg + i))\n #ifdef LEAF_REGISTERS\n \t/* We can't use a non-leaf register if we're in a\n \t   leaf function.  */\n@@ -337,11 +350,8 @@ check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n   for (tmp = this_head->first; tmp; tmp = tmp->next_use)\n     if ((!targetm.hard_regno_mode_ok (new_reg, GET_MODE (*tmp->loc))\n \t && ! DEBUG_INSN_P (tmp->insn))\n-\t|| (this_head->need_caller_save_reg\n-\t    && ! (targetm.hard_regno_call_part_clobbered\n-\t\t  (0, reg, GET_MODE (*tmp->loc)))\n-\t    && (targetm.hard_regno_call_part_clobbered\n-\t\t(0, new_reg, GET_MODE (*tmp->loc)))))\n+\t|| call_clobbered_in_chain_p (this_head, GET_MODE (*tmp->loc),\n+\t\t\t\t      new_reg))\n       return false;\n \n   return true;\n@@ -363,12 +373,6 @@ find_rename_reg (du_head_p this_head, enum reg_class super_class,\n   int pass;\n   int best_new_reg = old_reg;\n \n-  /* Further narrow the set of registers we can use for renaming.\n-     If the chain needs a call-saved register, mark the call-used\n-     registers as unavailable.  */\n-  if (this_head->need_caller_save_reg)\n-    *unavailable |= call_used_or_fixed_regs;\n-\n   /* Mark registers that overlap this chain's lifetime as unavailable.  */\n   merge_overlapping_regs (unavailable, this_head);\n \n@@ -499,7 +503,7 @@ rename_chains (void)\n \t{\n \t  fprintf (dump_file, \"Register %s in insn %d\",\n \t\t   reg_names[reg], INSN_UID (this_head->first->insn));\n-\t  if (this_head->need_caller_save_reg)\n+\t  if (this_head->call_abis)\n \t    fprintf (dump_file, \" crosses a call\");\n \t}\n \n@@ -680,7 +684,8 @@ merge_chains (du_head_p c1, du_head_p c2)\n   c1->hard_conflicts |= c2->hard_conflicts;\n   bitmap_ior_into (&c1->conflicts, &c2->conflicts);\n \n-  c1->need_caller_save_reg |= c2->need_caller_save_reg;\n+  c1->call_clobber_mask |= c2->call_clobber_mask;\n+  c1->call_abis |= c2->call_abis;\n   c1->cannot_rename |= c2->cannot_rename;\n }\n \n@@ -1834,9 +1839,15 @@ build_def_use (basic_block bb)\n \t     requires a caller-saved reg.  */\n \t  if (CALL_P (insn))\n \t    {\n+\t      function_abi callee_abi = insn_callee_abi (insn);\n \t      class du_head *p;\n \t      for (p = open_chains; p; p = p->next_chain)\n-\t\tp->need_caller_save_reg = 1;\n+\t\t{\n+\t\t  p->call_abis |= (1 << callee_abi.id ());\n+\t\t  p->call_clobber_mask\n+\t\t    |= callee_abi.full_and_partial_reg_clobbers ();\n+\t\t  p->hard_conflicts |= callee_abi.full_reg_clobbers ();\n+\t\t}\n \t    }\n \n \t  /* Step 5: Close open chains that overlap writes.  Similar to"}, {"sha": "a67896368a96795fc5d9fc17f36336878ee358f1", "filename": "gcc/regrename.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2Fregrename.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce77f463d1d150e70a91807502d628492ca7ae5/gcc%2Fregrename.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.h?ref=0ce77f463d1d150e70a91807502d628492ca7ae5", "patch": "@@ -41,9 +41,12 @@ class du_head\n   bitmap_head conflicts;\n   /* Conflicts with untracked hard registers.  */\n   HARD_REG_SET hard_conflicts;\n+  /* Which registers are fully or partially clobbered by the calls that\n+     the chain crosses.  */\n+  HARD_REG_SET call_clobber_mask;\n \n-  /* Nonzero if the chain crosses a call.  */\n-  unsigned int need_caller_save_reg:1;\n+  /* A bitmask of ABIs used by the calls that the chain crosses.  */\n+  unsigned int call_abis : NUM_ABI_IDS;\n   /* Nonzero if the register is used in a way that prevents renaming,\n      such as the SET_DEST of a CALL_INSN or an asm operand that used\n      to be a hard register.  */"}]}