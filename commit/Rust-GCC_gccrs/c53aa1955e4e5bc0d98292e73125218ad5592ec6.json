{"sha": "c53aa1955e4e5bc0d98292e73125218ad5592ec6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUzYWExOTU1ZTRlNWJjMGQ5ODI5MmU3MzEyNTIxOGFkNTU5MmVjNg==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-06-25T20:58:55Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-06-25T20:58:55Z"}, "message": "x\n\nFrom-SVN: r14321", "tree": {"sha": "3f257fd456ff251f7121d808703023c3faa34dac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f257fd456ff251f7121d808703023c3faa34dac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c53aa1955e4e5bc0d98292e73125218ad5592ec6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c53aa1955e4e5bc0d98292e73125218ad5592ec6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c53aa1955e4e5bc0d98292e73125218ad5592ec6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c53aa1955e4e5bc0d98292e73125218ad5592ec6/comments", "author": null, "committer": null, "parents": [{"sha": "8440cf1b3ad89ba57fe813deca7ae06b2cce4099", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8440cf1b3ad89ba57fe813deca7ae06b2cce4099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8440cf1b3ad89ba57fe813deca7ae06b2cce4099"}], "stats": {"total": 290, "additions": 240, "deletions": 50}, "files": [{"sha": "3521fdd3b3b9d2b8097f87fbbd0db8d6501f1e89", "filename": "gcc/config/mips/iris6.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fconfig%2Fmips%2Firis6.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fconfig%2Fmips%2Firis6.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis6.h?ref=c53aa1955e4e5bc0d98292e73125218ad5592ec6", "patch": "@@ -183,8 +183,8 @@ Boston, MA 02111-1307, USA.  */\n \n #define POPSECTION_ASM_OP\t\".popsection\"\n \n-#define DEBUG_SECTION\t\t\".debug_info,0x7000001e,0,0,1\"\n-#define LINE_SECTION\t\t\".debug_line,0x7000001e,0,0,1\"\n+#define DEBUG_INFO_SECTION\t\".debug_info,0x7000001e,0,0,1\"\n+#define DEBUG_LINE_SECTION\t\".debug_line,0x7000001e,0,0,1\"\n #define SFNAMES_SECTION\t\t\".debug_sfnames,0x7000001e,0,0,1\"\n #define SRCINFO_SECTION\t\t\".debug_srcinfo,0x7000001e,0,0,1\"\n #define MACINFO_SECTION\t\t\".debug_macinfo,0x7000001e,0,0,1\""}, {"sha": "97c315d942d3cec3287b439a9167993d8c4fe13e", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=c53aa1955e4e5bc0d98292e73125218ad5592ec6", "patch": "@@ -62,7 +62,8 @@ Boston, MA 02111-1307, USA.  */\n \n #undef DBX_REGISTER_NUMBER\n /* Same as sparc.h */\n-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+#define DBX_REGISTER_NUMBER(REGNO) \\\n+  (TARGET_FLAT && REGNO == FRAME_POINTER_REGNUM ? 31 : REGNO)\n \n /* We use stabs-in-elf for debugging, because that is what the native\n    toolchain uses.  */"}, {"sha": "9cf09747f49f81bb622320801082d673255d6176", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 150, "deletions": 30, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c53aa1955e4e5bc0d98292e73125218ad5592ec6", "patch": "@@ -2894,12 +2894,13 @@ sparc_init_modes ()\n __inline__\n #endif\n static int\n-save_regs (file, low, high, base, offset, n_regs)\n+save_regs (file, low, high, base, offset, n_regs, real_offset)\n      FILE *file;\n      int low, high;\n      char *base;\n      int offset;\n      int n_regs;\n+     int real_offset;\n {\n   int i;\n \n@@ -2908,9 +2909,15 @@ save_regs (file, low, high, base, offset, n_regs)\n       for (i = low; i < high; i++)\n \t{\n \t  if (regs_ever_live[i] && ! call_used_regs[i])\n-\t    fprintf (file, \"\\tstx %s,[%s+%d]\\n\",\n-\t      reg_names[i], base, offset + 4 * n_regs),\n-\t    n_regs += 2;\n+\t    {\n+\t      fprintf (file, \"\\tstx %s,[%s+%d]\\n\",\n+\t\t       reg_names[i], base, offset + 4 * n_regs);\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t      if (write_symbols == DWARF2_DEBUG)\n+\t\tdwarf2out_reg_save (\"\", i, real_offset + 4 * n_regs);\n+#endif\n+\t      n_regs += 2;\n+\t    }\n \t}\n     }\n   else\n@@ -2919,17 +2926,39 @@ save_regs (file, low, high, base, offset, n_regs)\n \t{\n \t  if (regs_ever_live[i] && ! call_used_regs[i])\n \t    if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n-\t      fprintf (file, \"\\tstd %s,[%s+%d]\\n\",\n-\t\t       reg_names[i], base, offset + 4 * n_regs),\n-\t      n_regs += 2;\n+\t      {\n+\t\tfprintf (file, \"\\tstd %s,[%s+%d]\\n\",\n+\t\t\t reg_names[i], base, offset + 4 * n_regs);\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t\tif (write_symbols == DWARF2_DEBUG)\n+\t\t  {\n+\t\t    char *l = (char *) dwarf2out_cfi_label ();\n+\t\t    dwarf2out_reg_save (l, i, real_offset + 4 * n_regs);\n+\t\t    dwarf2out_reg_save (l, i+1, real_offset + 4 * n_regs + 4);\n+\t\t  }\n+#endif\n+\t\tn_regs += 2;\n+\t      }\n \t    else\n+\t      {\n+\t\tfprintf (file, \"\\tst %s,[%s+%d]\\n\",\n+\t\t\t reg_names[i], base, offset + 4 * n_regs);\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t\tif (write_symbols == DWARF2_DEBUG)\n+\t\t  dwarf2out_reg_save (\"\", i, real_offset + 4 * n_regs);\n+#endif\n+\t\tn_regs += 2;\n+\t      }\n+\t  else if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n+\t    {\n \t      fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n-\t\t       reg_names[i], base, offset + 4 * n_regs),\n+\t\t       reg_names[i+1], base, offset + 4 * n_regs + 4);\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t      if (write_symbols == DWARF2_DEBUG)\n+\t\tdwarf2out_reg_save (\"\", i + 1, real_offset + 4 * n_regs + 4);\n+#endif\n \t      n_regs += 2;\n-\t  else if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n-\t    fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n-\t\t     reg_names[i+1], base, offset + 4 * n_regs + 4),\n-\t    n_regs += 2;\n+\t    }\n \t}\n     }\n   return n_regs;\n@@ -3169,17 +3198,40 @@ output_function_prologue (file, size, leaf_function)\n \t}\n     }\n \n+#ifdef DWARF2_DEBUGGING_INFO\n+  if (write_symbols == DWARF2_DEBUG && actual_fsize)\n+    {\n+      char *label = (char *) dwarf2out_cfi_label ();\n+\n+      /* The canonical frame address refers to the top of the frame.  */\n+      dwarf2out_def_cfa (label, (leaf_function ? STACK_POINTER_REGNUM\n+\t\t\t\t : FRAME_POINTER_REGNUM),\n+\t\t\t frame_base_offset);\n+\n+      if (! leaf_function)\n+\t{\n+\t  /* Note the register window save.  This tells the unwinder that\n+\t     it needs to restore the window registers from the previous\n+\t     frame's window save area at 0(cfa).  */\n+\t  dwarf2out_window_save (label);\n+\n+\t  /* The return address (-8) is now in %i7.  */\n+\t  dwarf2out_return_reg (label, 31);\n+\t}\n+    }\n+#endif\n+\n   /* If doing anything with PIC, do it now.  */\n   if (! flag_pic)\n     fprintf (file, \"\\t!#PROLOGUE# 1\\n\");\n \n   /* Call saved registers are saved just above the outgoing argument area.  */\n   if (num_gfregs)\n     {\n-      int offset, n_regs;\n+      int offset, real_offset, n_regs;\n       char *base;\n \n-      offset = -apparent_fsize + frame_base_offset;\n+      real_offset = offset = -apparent_fsize + frame_base_offset;\n       if (offset < -4096 || offset + num_gfregs * 4 > 4096)\n \t{\n \t  /* ??? This might be optimized a little as %g1 might already have a\n@@ -3200,12 +3252,13 @@ output_function_prologue (file, size, leaf_function)\n \n       if (TARGET_EPILOGUE && ! leaf_function)\n \t/* ??? Originally saved regs 0-15 here.  */\n-\tn_regs = save_regs (file, 0, 8, base, offset, 0);\n+\tn_regs = save_regs (file, 0, 8, base, offset, 0, real_offset);\n       else if (leaf_function)\n \t/* ??? Originally saved regs 0-31 here.  */\n-\tn_regs = save_regs (file, 0, 8, base, offset, 0);\n+\tn_regs = save_regs (file, 0, 8, base, offset, 0, real_offset);\n       if (TARGET_EPILOGUE)\n-\tsave_regs (file, 32, TARGET_V9 ? 96 : 64, base, offset, n_regs);\n+\tsave_regs (file, 32, TARGET_V9 ? 96 : 64, base, offset, n_regs,\n+\t\t   real_offset);\n     }\n \n   leaf_label = 0;\n@@ -4626,14 +4679,15 @@ sparc_flat_compute_frame_size (size)\n    DOUBLEWORD_OP is either \"std\" for save, \"ldd\" for restore.  */\n \n void\n-sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op, doubleword_op)\n+sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op, doubleword_op, base_offset)\n      FILE *file;\n      char *base_reg;\n      unsigned int offset;\n      unsigned long gmask;\n      unsigned long fmask;\n      char *word_op;\n      char *doubleword_op;\n+     unsigned long base_offset;\n {\n   int regno;\n \n@@ -4661,9 +4715,20 @@ sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op, doublewo\n \t\t    offset += UNITS_PER_WORD;\n \n \t\t  if (word_op[0] == 's')\n-\t\t    fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n-\t\t\t     doubleword_op, reg_names[regno],\n-\t\t\t     base_reg, offset);\n+\t\t    {\n+\t\t      fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n+\t\t\t       doubleword_op, reg_names[regno],\n+\t\t\t       base_reg, offset);\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t\t      if (write_symbols == DWARF2_DEBUG)\n+\t\t\t{\n+\t\t\t  char *l = (char *) dwarf2out_cfi_label ();\n+\t\t\t  dwarf2out_reg_save (l, regno, offset + base_offset);\n+\t\t\t  dwarf2out_reg_save\n+\t\t\t    (l, regno+1, offset+base_offset + UNITS_PER_WORD);\n+\t\t\t}\n+#endif\n+\t\t    }\n \t\t  else\n \t\t    fprintf (file, \"\\t%s [%s+%d],%s\\n\",\n \t\t\t     doubleword_op, base_reg, offset,\n@@ -4675,9 +4740,15 @@ sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op, doublewo\n \t      else\n \t\t{\n \t\t  if (word_op[0] == 's')\n-\t\t    fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n-\t\t\t     word_op, reg_names[regno],\n-\t\t\t     base_reg, offset);\n+\t\t    {\n+\t\t      fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n+\t\t\t       word_op, reg_names[regno],\n+\t\t\t       base_reg, offset);\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t\t      if (write_symbols == DWARF2_DEBUG)\n+\t\t\tdwarf2out_reg_save (\"\", regno, offset + base_offset);\n+#endif\n+\t\t    }\n \t\t  else\n \t\t    fprintf (file, \"\\t%s [%s+%d],%s\\n\",\n \t\t\t     word_op, base_reg, offset, reg_names[regno]);\n@@ -4695,9 +4766,15 @@ sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op, doublewo\n \t  if ((fmask & (1L << (regno - 32))) != 0)\n \t    {\n \t      if (word_op[0] == 's')\n-\t\tfprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n-\t\t\t word_op, reg_names[regno],\n-\t\t\t base_reg, offset);\n+\t\t{\n+\t\t  fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n+\t\t\t   word_op, reg_names[regno],\n+\t\t\t   base_reg, offset);\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t\t  if (write_symbols == DWARF2_DEBUG)\n+\t\t    dwarf2out_reg_save (\"\", regno, offset + base_offset);\n+#endif\n+\t\t}\n \t      else\n \t\tfprintf (file, \"\\t%s [%s+%d],%s\\n\",\n \t\t\t word_op, base_reg, offset, reg_names[regno]);\n@@ -4794,16 +4871,34 @@ sparc_flat_output_function_prologue (file, size)\n \t\t  reg_offset += 4;\n \t\t}\n \t    }\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t  if (write_symbols == DWARF2_DEBUG)\n+\t    {\n+\t      char *l = (char *) dwarf2out_cfi_label ();\n+\t      if (gmask & FRAME_POINTER_MASK)\n+\t\t{\n+\t\t  dwarf2out_reg_save (l, FRAME_POINTER_REGNUM,\n+\t\t\t\t      reg_offset - 4 - size);\n+\t\t  dwarf2out_def_cfa (l, FRAME_POINTER_REGNUM, 0);\n+\t\t}\n+\t      else\n+\t\tdwarf2out_def_cfa (l, STACK_POINTER_REGNUM, size);\n+\t    }\n+#endif\n \t  if (gmask & RETURN_ADDR_MASK)\n \t    {\n \t      fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n \t\t       reg_names[RETURN_ADDR_REGNUM], sp_str, reg_offset);\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t      if (write_symbols == DWARF2_DEBUG)\n+\t\tdwarf2out_return_save (\"\", reg_offset - size);\n+#endif\n \t      reg_offset += 4;\n \t    }\n \t  sparc_flat_save_restore (file, sp_str, reg_offset,\n \t\t\t\t   gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n \t\t\t\t   current_frame_info.fmask,\n-\t\t\t\t   \"st\", \"std\");\n+\t\t\t\t   \"st\", \"std\", 0);\n \t}\n       else\n \t{\n@@ -4836,18 +4931,43 @@ sparc_flat_output_function_prologue (file, size)\n \t\t  offset += 4;\n \t\t}\n \t    }\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t  if (write_symbols == DWARF2_DEBUG)\n+\t    {\n+\t      char *l = (char *) dwarf2out_cfi_label ();\n+\t      if (gmask & FRAME_POINTER_MASK)\n+\t\t{\n+\t\t  dwarf2out_reg_save (l, FRAME_POINTER_REGNUM,\n+\t\t\t\t      offset - 4 - size1);\n+\t\t  dwarf2out_def_cfa (l, FRAME_POINTER_REGNUM, 0);\n+\t\t}\n+\t      else\n+\t\tdwarf2out_def_cfa (l, STACK_POINTER_REGNUM, size1);\n+\t    }\n+#endif\n \t  if (gmask & RETURN_ADDR_MASK)\n \t    {\n \t      fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n \t\t       reg_names[RETURN_ADDR_REGNUM], sp_str, offset);\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t      if (write_symbols == DWARF2_DEBUG)\n+\t\t/* offset - size1 == reg_offset - size\n+\t\t   if reg_offset were updated above like offset.  */\n+\t\tdwarf2out_return_save (\"\", offset - size1);\n+#endif\n \t      offset += 4;\n \t    }\n \t  sparc_flat_save_restore (file, sp_str, offset,\n \t\t\t\t   gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n \t\t\t\t   current_frame_info.fmask,\n-\t\t\t\t   \"st\", \"std\");\n+\t\t\t\t   \"st\", \"std\", size - size1);\n \t  fprintf (file, \"\\tset %d,%s\\n\\tsub %s,%s,%s\\n\",\n \t\t   size - size1, t1_str, sp_str, t1_str, sp_str);\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t  if (write_symbols == DWARF2_DEBUG)\n+\t    if (! (gmask & FRAME_POINTER_MASK))\n+\t      dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, size);\n+#endif\n \t}\n     }\n \n@@ -4952,7 +5072,7 @@ sparc_flat_output_function_epilogue (file, size)\n       sparc_flat_save_restore (file, sp_str, reg_offset,\n \t\t\t       current_frame_info.gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n \t\t\t       current_frame_info.fmask,\n-\t\t\t       \"ld\", \"ldd\");\n+\t\t\t       \"ld\", \"ldd\", 0);\n \n       /* If we had to increment %sp in two steps, record it so the second\n \t restoration in the epilogue finishes up.  */"}, {"sha": "c787e6036b8b63a2782a9aef04aa0607da62f383", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=c53aa1955e4e5bc0d98292e73125218ad5592ec6", "patch": "@@ -2788,9 +2788,11 @@ extern struct rtx_def *legitimize_pic_address ();\n #define ADDITIONAL_REGISTER_NAMES \\\n {{\"ccr\", SPARC_ICC_REG}, {\"cc\", SPARC_ICC_REG}}\n \n-/* How to renumber registers for dbx and gdb.  */\n+/* How to renumber registers for dbx and gdb.  In the flat model, the frame\n+   pointer is really %i7.  */\n \n-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+#define DBX_REGISTER_NUMBER(REGNO) \\\n+  (TARGET_FLAT && REGNO == FRAME_POINTER_REGNUM ? 31 : REGNO)\n \n /* On Sun 4, this limit is 2048.  We use 1000 to be safe, since the length\n    can run past this up to a continuation point.  Once we used 1500, but\n@@ -3124,3 +3126,10 @@ extern char *output_return ();\n /* Defined in flags.h, but insn-emit.c does not include flags.h.  */\n \n extern int flag_pic;\n+\n+/* Before the prologue, the return address is %o7 + 8.  OK, sometimes it's\n+   +12, but always using +8 is close enough for frame unwind purposes.\n+   Actually, just using %o7 is close enough for unwinding, but %o7+8\n+   is something you can return to.  */\n+#define INCOMING_RETURN_ADDR_RTX \\\n+  gen_rtx (PLUS, word_mode, gen_rtx (REG, word_mode, 15), GEN_INT (8))"}, {"sha": "6e394fe4123e8471dbd927ef9fa5fd2aab0281bc", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=c53aa1955e4e5bc0d98292e73125218ad5592ec6", "patch": "@@ -493,7 +493,10 @@ enum dwarf_call_frame_info\n     DW_CFA_def_cfa_register = 0x0d,\n     DW_CFA_def_cfa_offset = 0x0e,\n     /* SGI/MIPS specific */\n-    DW_CFA_MIPS_advance_loc8 = 0x1d\n+    DW_CFA_MIPS_advance_loc8 = 0x1d,\n+\n+    /* GNU extensions */\n+    DW_CFA_GNU_window_save = 0x2d,\n   };\n \n #define DW_CIE_ID\t  0xffffffff"}, {"sha": "aed0de476b4ccc2a83d3e692df0f763d1f4a4595", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 71, "deletions": 14, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53aa1955e4e5bc0d98292e73125218ad5592ec6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c53aa1955e4e5bc0d98292e73125218ad5592ec6", "patch": "@@ -189,7 +189,7 @@ static unsigned long size_of_uleb128\tPROTO((unsigned long));\n static unsigned long size_of_sleb128\tPROTO((long));\n static void output_uleb128\t\tPROTO((unsigned long));\n static void output_sleb128\t\tPROTO((long));\n-static char *dwarf2out_cfi_label\tPROTO((void));\n+char *dwarf2out_cfi_label\t\tPROTO((void));\n static void add_fde_cfi\t\t\tPROTO((char *, dw_cfi_ref));\n static void lookup_cfa_1\t\tPROTO((dw_cfi_ref, unsigned long *,\n \t\t\t\t\t       long *));\n@@ -246,7 +246,11 @@ static unsigned reg_number\t\tPROTO((rtx));\n    almost all svr4 assemblers, except for the sparc, where the section name\n    must be enclosed in double quotes.  (See sparcv4.h).  */\n #ifndef SECTION_FORMAT\n-#define SECTION_FORMAT\t\"\\t%s\\t%s\\n\"\n+#ifdef PUSHSECTION_FORMAT\n+#define SECTION_FORMAT PUSHSECTION_FORMAT\n+#else\n+#define SECTION_FORMAT\t\t\"\\t%s\\t%s\\n\"\n+#endif\n #endif\n \n #ifndef FRAME_SECTION\n@@ -466,9 +470,15 @@ dwarf_cfi_name (cfi_opc)\n       return \"DW_CFA_def_cfa_register\";\n     case DW_CFA_def_cfa_offset:\n       return \"DW_CFA_def_cfa_offset\";\n+\n     /* SGI/MIPS specific */\n     case DW_CFA_MIPS_advance_loc8:\n       return \"DW_CFA_MIPS_advance_loc8\";\n+\n+    /* GNU extensions */\n+    case DW_CFA_GNU_window_save:\n+      return \"DW_CFA_GNU_window_save\";\n+\n     default:\n       return \"DW_CFA_<unknown>\";\n     }\n@@ -506,7 +516,7 @@ add_cfi (list_head, cfi)\n \n /* Generate a new label for the CFI info to refer to.  */\n \n-static char *\n+char *\n dwarf2out_cfi_label ()\n {\n   static char label[20];\n@@ -698,8 +708,24 @@ reg_save (label, reg, sreg, offset)\n   add_fde_cfi (label, cfi);\n }\n \n-/* Entry point for saving a register.  REG is the GCC register number.\n-   LABEL and OFFSET are passed to reg_save.  */\n+/* Add the CFI for saving a register window.  LABEL is passed to reg_save.\n+   This CFI tells the unwinder that it needs to restore the window registers\n+   from the previous frame's window save area.\n+   \n+   ??? Perhaps we should note in the CIE where windows are saved (instead of\n+   assuming 0(cfa)) and what registers are in the window.  */\n+\n+void\n+dwarf2out_window_save (label)\n+     register char * label;\n+{\n+  register dw_cfi_ref cfi = new_cfi ();\n+  cfi->dw_cfi_opc = DW_CFA_GNU_window_save;\n+  add_fde_cfi (label, cfi);\n+}\n+\n+/* Entry point for saving a register to the stack.  REG is the GCC register\n+   number.  LABEL and OFFSET are passed to reg_save.  */\n \n void\n dwarf2out_reg_save (label, reg, offset)\n@@ -710,6 +736,28 @@ dwarf2out_reg_save (label, reg, offset)\n   reg_save (label, DWARF_FRAME_REGNUM (reg), -1, offset);\n }\n \n+/* Entry point for saving the return address in the stack.\n+   LABEL and OFFSET are passed to reg_save.  */\n+\n+void\n+dwarf2out_return_save (label, offset)\n+     register char * label;\n+     register long offset;\n+{\n+  reg_save (label, DWARF_FRAME_RETURN_COLUMN, -1, offset);\n+}\n+\n+/* Entry point for saving the return address in a register.\n+   LABEL and SREG are passed to reg_save.  */\n+\n+void\n+dwarf2out_return_reg (label, sreg)\n+     register char * label;\n+     register unsigned sreg;\n+{\n+  reg_save (label, DWARF_FRAME_RETURN_COLUMN, sreg, 0);\n+}\n+\n /* Record the initial position of the return address.  RTL is\n    INCOMING_RETURN_ADDR_RTX.  */\n \n@@ -747,6 +795,13 @@ initial_return_save (rtl)\n \t  abort ();\n \t}\n       break;\n+    case PLUS:\n+      /* The return address is at some offset from any value we can\n+\t actually load.  For instance, on the SPARC it is in %i7+8. Just\n+\t ignore the offset for now; it doesn't matter for unwinding frames.  */\n+      assert (GET_CODE (XEXP (rtl, 1)) == CONST_INT);\n+      initial_return_save (XEXP (rtl, 0));\n+      return;\n     default:\n       abort ();\n     }\n@@ -1223,6 +1278,8 @@ output_cfi (cfi, fde)\n \t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n           fputc ('\\n', asm_out_file);\n \t  break;\n+\tcase DW_CFA_GNU_window_save:\n+\t  break;\n \tdefault:\n \t  break;\n \t}\n@@ -2058,8 +2115,8 @@ static void gen_decl_die\t\tPROTO((tree, dw_die_ref));\n static unsigned lookup_filename\t\tPROTO((char *));\n \n /* Section names used to hold DWARF debugging information.  */\n-#ifndef DEBUG_SECTION\n-#define DEBUG_SECTION\t\t\".debug_info\"\n+#ifndef DEBUG_INFO_SECTION\n+#define DEBUG_INFO_SECTION\t\".debug_info\"\n #endif\n #ifndef ABBREV_SECTION\n #define ABBREV_SECTION\t\t\".debug_abbrev\"\n@@ -2070,8 +2127,8 @@ static unsigned lookup_filename\t\tPROTO((char *));\n #ifndef DW_MACINFO_SECTION\n #define DW_MACINFO_SECTION\t\".debug_macinfo\"\n #endif\n-#ifndef LINE_SECTION\n-#define LINE_SECTION\t\t\".debug_line\"\n+#ifndef DEBUG_LINE_SECTION\n+#define DEBUG_LINE_SECTION\t\".debug_line\"\n #endif\n #ifndef LOC_SECTION\n #define LOC_SECTION\t\t\".debug_loc\"\n@@ -5005,7 +5062,7 @@ output_pubnames ()\n     fprintf (asm_out_file, \"\\t%s DWARF Version\", ASM_COMMENT_START);\n \n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, stripattributes (DEBUG_SECTION));\n+  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, stripattributes (DEBUG_INFO_SECTION));\n   if (flag_verbose_asm)\n     fprintf (asm_out_file, \"\\t%s Offset of Compilation Unit Info.\",\n \t     ASM_COMMENT_START);\n@@ -5079,7 +5136,7 @@ output_aranges ()\n     fprintf (asm_out_file, \"\\t%s DWARF Version\", ASM_COMMENT_START);\n \n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, stripattributes (DEBUG_SECTION));\n+  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, stripattributes (DEBUG_INFO_SECTION));\n   if (flag_verbose_asm)\n     fprintf (asm_out_file, \"\\t%s Offset of Compilation Unit Info.\",\n \t     ASM_COMMENT_START);\n@@ -9218,7 +9275,7 @@ dwarf2out_finish ()\n   if (line_info_table_in_use > 1 || separate_line_info_table_in_use)\n     {\n       fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_SECTION (asm_out_file, LINE_SECTION);\n+      ASM_OUTPUT_SECTION (asm_out_file, DEBUG_LINE_SECTION);\n       output_line_info ();\n \n       /* We can only use the low/high_pc attributes if all of the code\n@@ -9229,7 +9286,7 @@ dwarf2out_finish ()\n \t  add_AT_lbl_id (comp_unit_die, DW_AT_high_pc, text_end_label);\n \t}\n \n-      add_AT_section_offset (comp_unit_die, DW_AT_stmt_list, LINE_SECTION);\n+      add_AT_section_offset (comp_unit_die, DW_AT_stmt_list, DEBUG_LINE_SECTION);\n     }\n \n   /* Output the abbreviation table.  */\n@@ -9244,7 +9301,7 @@ dwarf2out_finish ()\n \n   /* Output debugging information.  */\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_SECTION (asm_out_file, DEBUG_SECTION);\n+  ASM_OUTPUT_SECTION (asm_out_file, DEBUG_INFO_SECTION);\n   output_compilation_unit_header ();\n   output_die (comp_unit_die);\n "}]}