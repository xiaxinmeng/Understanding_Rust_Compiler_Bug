{"sha": "dc491a250a946a50bdea3813e9f1f67d368e348b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM0OTFhMjUwYTk0NmE1MGJkZWEzODEzZTlmMWY2N2QzNjhlMzQ4Yg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-06-19T15:29:18Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-06-19T15:29:18Z"}, "message": "dse.c (struct store_info): Rename bitmap field to bmap.\n\n./:\t* dse.c (struct store_info): Rename bitmap field to bmap.  Change\n\tall uses.\n\n\t* c-decl.c (in_struct, struct_types): Remove.\n\t(struct c_binding): Add in_struct field.\n\t(c_binding_ptr): Define type, along with VEC.\n\t(struct c_struct_parse_info): Define.\n\t(struct_parse_info): New static variable.\n\t(bind): Initialize in_struct field.\n\t(start_struct): Remove enclosing_in_struct and\n\tenclosing_struct_types parameters.  Add\n\tenclosing_struct_parse_info parameter.  Change all callers.  Set\n\tstruct_parse_info rather than in_struct and struct_types.\n\t(grokfield): If -Wc++-compat and there is a symbol binding for the\n\tfield name, set the in_struct flag and push it on the\n\tstruct_parse_info->fields vector.\n\t(warn_cxx_compat_finish_struct): New static function.\n\t(finish_struct): Remove enclosing_in_struct and\n\tenclosing_struct_types parameters.  Add\n\tenclosing_struct_parse_info parameter.  Change all callers.  Don't\n\tset C_TYPE_DEFINED_IN_STRUCT here.  Call\n\twarn_cxx_compat_finish_struct.  Free struct_parse_info and set to\n\tparameter.  Only push on struct_types if warn_cxx_compat.\n\t(finish_enum): Only push on struct_types if warn_cxx_compat.\n\t(declspecs_add_type): Add loc parameter.  Change all callers.\n\tChange all error calls to error_at.  Pass loc, not input_location,\n\tto pedwarn calls.  Warn if -Wc++-compat and a typedef name is\n\tdefined in a struct.  If -Wc++-compat and parsing a struct, record\n\tthat a typedef name was used.\n\t* c-parser.c (c_parser_declspecs): Get location to pass to\n\tdeclspecs_add_type.\n\t(c_parser_struct_or_union_specifier): Update calls to start_struct\n\tand finish_struct.\n\t* c-tree.h (struct c_struct_parse_info): Declare.\n\t(finish_struct, start_struct): Update declarations.\n\t(declspecs_add_type): Update declaration.\nobjc/:\n\t* objc-act.c (objc_in_struct, objc_struct_types): Remove.\n\t(objc_struct_info): New static variable.\n\t(objc_start_struct): Pass &objc_struct_info, not &objc_in_struct\n\tand &objc_struct_types, to start_struct.\n\t(objc_finish_struct): Likewise for finish_struct.\nobjcp/:\n\t* objcp-decl.h (start_struct): Remove in_struct and struct_types\n\tparameters.  Add struct_info parameter.\n\t(finish_struct): Likewise.\ntestsuite/:\n\t* gcc.dg/Wcxx-compat-15.c: New testcase.\n\nFrom-SVN: r148709", "tree": {"sha": "0dea9b2fb4eca6aa396f8ba7b9c2513061e504ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0dea9b2fb4eca6aa396f8ba7b9c2513061e504ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc491a250a946a50bdea3813e9f1f67d368e348b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc491a250a946a50bdea3813e9f1f67d368e348b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc491a250a946a50bdea3813e9f1f67d368e348b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc491a250a946a50bdea3813e9f1f67d368e348b/comments", "author": null, "committer": null, "parents": [{"sha": "88eeff6f5a1347dc09de33c26a68648c4dea7f80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88eeff6f5a1347dc09de33c26a68648c4dea7f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88eeff6f5a1347dc09de33c26a68648c4dea7f80"}], "stats": {"total": 818, "additions": 558, "deletions": 260}, "files": [{"sha": "c6a39f15718ed6f49aafd0cb6b035840430e03ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc491a250a946a50bdea3813e9f1f67d368e348b", "patch": "@@ -1,3 +1,42 @@\n+2009-06-19  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dse.c (struct store_info): Rename bitmap field to bmap.  Change\n+\tall uses.\n+\n+\t* c-decl.c (in_struct, struct_types): Remove.\n+\t(struct c_binding): Add in_struct field.\n+\t(c_binding_ptr): Define type, along with VEC.\n+\t(struct c_struct_parse_info): Define.\n+\t(struct_parse_info): New static variable.\n+\t(bind): Initialize in_struct field.\n+\t(start_struct): Remove enclosing_in_struct and\n+\tenclosing_struct_types parameters.  Add\n+\tenclosing_struct_parse_info parameter.  Change all callers.  Set\n+\tstruct_parse_info rather than in_struct and struct_types.\n+\t(grokfield): If -Wc++-compat and there is a symbol binding for the\n+\tfield name, set the in_struct flag and push it on the\n+\tstruct_parse_info->fields vector.\n+\t(warn_cxx_compat_finish_struct): New static function.\n+\t(finish_struct): Remove enclosing_in_struct and\n+\tenclosing_struct_types parameters.  Add\n+\tenclosing_struct_parse_info parameter.  Change all callers.  Don't\n+\tset C_TYPE_DEFINED_IN_STRUCT here.  Call\n+\twarn_cxx_compat_finish_struct.  Free struct_parse_info and set to\n+\tparameter.  Only push on struct_types if warn_cxx_compat.\n+\t(finish_enum): Only push on struct_types if warn_cxx_compat.\n+\t(declspecs_add_type): Add loc parameter.  Change all callers.\n+\tChange all error calls to error_at.  Pass loc, not input_location,\n+\tto pedwarn calls.  Warn if -Wc++-compat and a typedef name is\n+\tdefined in a struct.  If -Wc++-compat and parsing a struct, record\n+\tthat a typedef name was used.\n+\t* c-parser.c (c_parser_declspecs): Get location to pass to\n+\tdeclspecs_add_type.\n+\t(c_parser_struct_or_union_specifier): Update calls to start_struct\n+\tand finish_struct.\n+\t* c-tree.h (struct c_struct_parse_info): Declare.\n+\t(finish_struct, start_struct): Update declarations.\n+\t(declspecs_add_type): Update declaration.\n+\n 2009-06-19  Ian Lance Taylor  <iant@google.com>\n \n \t* c-decl.c (grokdeclarator): If -Wc++-compat, warn about a global"}, {"sha": "57cf389dc7359a909ce7c9dca98fd8d74b8903bf", "filename": "gcc/c-decl.c", "status": "modified", "additions": 438, "deletions": 230, "changes": 668, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=dc491a250a946a50bdea3813e9f1f67d368e348b", "patch": "@@ -126,15 +126,6 @@ static GTY(()) struct stmt_tree_s c_stmt_tree;\n tree c_break_label;\n tree c_cont_label;\n \n-/* True if we are currently parsing the fields of a struct or\n-   union.  */\n-\n-static bool in_struct;\n-\n-/* A list of types defined in the current struct or union.  */\n-\n-static VEC(tree,heap) *struct_types;\n-\n /* Linked list of TRANSLATION_UNIT_DECLS for the translation units\n    included in this invocation.  Note that the current translation\n    unit is not included in this list.  */\n@@ -223,7 +214,7 @@ struct GTY((chain_next (\"%h.prev\"))) c_binding {\n   BOOL_BITFIELD invisible : 1;  /* normal lookup should ignore this binding */\n   BOOL_BITFIELD nested : 1;     /* do not set DECL_CONTEXT when popping */\n   BOOL_BITFIELD inner_comp : 1; /* incomplete array completed in inner scope */\n-  /* one free bit */\n+  BOOL_BITFIELD in_struct : 1;\t/* currently defined as struct field */\n   location_t locus;\t\t/* location for nested bindings */\n };\n #define B_IN_SCOPE(b1, b2) ((b1)->depth == (b2)->depth)\n@@ -513,6 +504,34 @@ static bool keep_next_level_flag;\n \n static bool next_is_function_body;\n \n+/* A VEC of pointers to c_binding structures.  */\n+\n+typedef struct c_binding *c_binding_ptr;\n+DEF_VEC_P(c_binding_ptr);\n+DEF_VEC_ALLOC_P(c_binding_ptr,heap);\n+\n+/* Information that we keep for a struct or union while it is being\n+   parsed.  */\n+\n+struct c_struct_parse_info\n+{\n+  /* If warn_cxx_compat, a list of types defined within this\n+     struct.  */\n+  VEC(tree,heap) *struct_types;\n+  /* If warn_cxx_compat, a list of field names which have bindings,\n+     and which are defined in this struct, but which are not defined\n+     in any enclosing struct.  This is used to clear the in_struct\n+     field of the c_bindings structure.  */\n+  VEC(c_binding_ptr,heap) *fields;\n+  /* If warn_cxx_compat, a list of typedef names used when defining\n+     fields in this struct.  */\n+  VEC(tree,heap) *typedefs_seen;\n+};\n+\n+/* Information for the struct or union currently being parsed, or\n+   NULL if not parsing a struct or union.  */\n+static struct c_struct_parse_info *struct_parse_info;\n+\n /* Forward declarations.  */\n static tree lookup_name_in_scope (tree, struct c_scope *);\n static tree c_make_fname_decl (location_t, tree, int);\n@@ -588,6 +607,7 @@ bind (tree name, tree decl, struct c_scope *scope, bool invisible,\n   b->invisible = invisible;\n   b->nested = nested;\n   b->inner_comp = 0;\n+  b->in_struct = 0;\n   b->locus = locus;\n \n   b->u.type = NULL;\n@@ -6289,16 +6309,14 @@ xref_tag (enum tree_code code, tree name)\n    LOC is the location of the struct's definition.\n    CODE says which kind of tag NAME ought to be.\n \n-   This stores the current value of the file static IN_STRUCT in\n-   *ENCLOSING_IN_STRUCT, and sets IN_STRUCT to true.  Similarly, this\n-   sets STRUCT_TYPES in *ENCLOSING_STRUCT_TYPES, and sets STRUCT_TYPES\n-   to an empty vector.  The old values are restored in\n-   finish_struct.  */\n+   This stores the current value of the file static STRUCT_PARSE_INFO\n+   in *ENCLOSING_STRUCT_PARSE_INFO, and points STRUCT_PARSE_INFO at a\n+   new c_struct_parse_info structure.  The old value of\n+   STRUCT_PARSE_INFO is restored in finish_struct.  */\n \n tree\n start_struct (location_t loc, enum tree_code code, tree name,\n-    \t      bool *enclosing_in_struct,\n-\t      VEC(tree,heap) **enclosing_struct_types)\n+\t      struct c_struct_parse_info **enclosing_struct_parse_info)\n {\n   /* If there is already a tag defined at this scope\n      (as a forward reference), just return it.  */\n@@ -6346,10 +6364,11 @@ start_struct (location_t loc, enum tree_code code, tree name,\n   C_TYPE_BEING_DEFINED (ref) = 1;\n   TYPE_PACKED (ref) = flag_pack_struct;\n \n-  *enclosing_in_struct = in_struct;\n-  *enclosing_struct_types = struct_types;\n-  in_struct = true;\n-  struct_types = VEC_alloc(tree, heap, 0);\n+  *enclosing_struct_parse_info = struct_parse_info;\n+  struct_parse_info = XNEW (struct c_struct_parse_info);\n+  struct_parse_info->struct_types = VEC_alloc (tree, heap, 0);\n+  struct_parse_info->fields = VEC_alloc (c_binding_ptr, heap, 0);\n+  struct_parse_info->typedefs_seen = VEC_alloc (tree, heap, 0);\n \n   /* FIXME: This will issue a warning for a use of a type defined\n      within a statement expr used within sizeof, et. al.  This is not\n@@ -6437,6 +6456,25 @@ grokfield (location_t loc,\n   finish_decl (value, loc, NULL_TREE, NULL_TREE, NULL_TREE);\n   DECL_INITIAL (value) = width;\n \n+  if (warn_cxx_compat && DECL_NAME (value) != NULL_TREE)\n+    {\n+      /* If we currently have a binding for this field, set the\n+\t in_struct field in the binding, so that we warn about lookups\n+\t which find it.  */\n+      struct c_binding *b = I_SYMBOL_BINDING (DECL_NAME (value));\n+      if (b != NULL)\n+\t{\n+\t  /* If the in_struct field is not yet set, push it on a list\n+\t     to be cleared when this struct is finished.  */\n+\t  if (!b->in_struct)\n+\t    {\n+\t      VEC_safe_push (c_binding_ptr, heap,\n+\t\t\t     struct_parse_info->fields, b);\n+\t      b->in_struct = 1;\n+\t    }\n+\t}\n+    }\n+\n   return value;\n }\n \f\n@@ -6497,25 +6535,80 @@ detect_field_duplicates (tree fieldlist)\n     }\n }\n \n+/* Finish up struct info used by -Wc++-compat.  */\n+\n+static void\n+warn_cxx_compat_finish_struct (tree fieldlist)\n+{\n+  unsigned int ix;\n+  tree x;\n+  struct c_binding *b;\n+\n+  /* Set the C_TYPE_DEFINED_IN_STRUCT flag for each type defined in\n+     the current struct.  We do this now at the end of the struct\n+     because the flag is used to issue visibility warnings, and we\n+     only want to issue those warnings if the type is referenced\n+     outside of the struct declaration.  */\n+  for (ix = 0; VEC_iterate (tree, struct_parse_info->struct_types, ix, x); ++ix)\n+    C_TYPE_DEFINED_IN_STRUCT (x) = 1;\n+\n+  /* The TYPEDEFS_SEEN field of STRUCT_PARSE_INFO is a list of\n+     typedefs used when declaring fields in this struct.  If the name\n+     of any of the fields is also a typedef name then the struct would\n+     not parse in C++, because the C++ lookup rules say that the\n+     typedef name would be looked up in the context of the struct, and\n+     would thus be the field rather than the typedef.  */\n+  if (!VEC_empty (tree, struct_parse_info->typedefs_seen)\n+      && fieldlist != NULL_TREE)\n+    {\n+      /* Use a pointer_set using the name of the typedef.  We can use\n+\t a pointer_set because identifiers are interned.  */\n+      struct pointer_set_t *tset = pointer_set_create ();\n+\n+      for (ix = 0;\n+\t   VEC_iterate (tree, struct_parse_info->typedefs_seen, ix, x);\n+\t   ++ix)\n+\tpointer_set_insert (tset, DECL_NAME (x));\n+\n+      for (x = fieldlist; x != NULL_TREE; x = TREE_CHAIN (x))\n+\t{\n+\t  if (pointer_set_contains (tset, DECL_NAME (x)))\n+\t    {\n+\t      warning_at (DECL_SOURCE_LOCATION (x), OPT_Wc___compat,\n+\t\t\t  (\"using %qD as both field and typedef name is \"\n+\t\t\t   \"invalid in C++\"),\n+\t\t\t  x);\n+\t      /* FIXME: It would be nice to report the location where\n+\t\t the typedef name is used.  */\n+\t    }\n+\t}\n+\n+      pointer_set_destroy (tset);\n+    }\n+\n+  /* For each field which has a binding and which was not defined in\n+     an enclosing struct, clear the in_struct field.  */\n+  for (ix = 0;\n+       VEC_iterate (c_binding_ptr, struct_parse_info->fields, ix, b);\n+       ++ix)\n+    b->in_struct = 0;\n+}\n+\n /* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.\n    LOC is the location of the RECORD_TYPE or UNION_TYPE's definition.\n    FIELDLIST is a chain of FIELD_DECL nodes for the fields.\n    ATTRIBUTES are attributes to be applied to the structure.\n \n-   ENCLOSING_IN_STRUCT is the value of IN_STRUCT, and\n-   ENCLOSING_STRUCT_TYPES is the value of STRUCT_TYPES, when the\n-   struct was started.  This sets the C_TYPE_DEFINED_IN_STRUCT flag\n-   for any type defined in the current struct.  */\n+   ENCLOSING_STRUCT_PARSE_INFO is the value of STRUCT_PARSE_INFO when\n+   the struct was started.  */\n \n tree\n finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n-\t       bool enclosing_in_struct,\n-\t       VEC(tree,heap) *enclosing_struct_types)\n+\t       struct c_struct_parse_info *enclosing_struct_parse_info)\n {\n   tree x;\n   bool toplevel = file_scope == current_scope;\n   int saw_named_field;\n-  unsigned int ix;\n \n   /* If this type was previously laid out as a forward reference,\n      make sure we lay it out again.  */\n@@ -6773,23 +6866,22 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n     add_stmt (build_stmt (loc,\n \t\t\t  DECL_EXPR, build_decl (loc, TYPE_DECL, NULL, t)));\n \n-  /* Set the C_TYPE_DEFINED_IN_STRUCT flag for each type defined in\n-     the current struct.  We do this now at the end of the struct\n-     because the flag is used to issue visibility warnings when using\n-     -Wc++-compat, and we only want to issue those warnings if the\n-     type is referenced outside of the struct declaration.  */\n-  for (ix = 0; VEC_iterate (tree, struct_types, ix, x); ++ix)\n-    C_TYPE_DEFINED_IN_STRUCT (x) = 1;\n+  if (warn_cxx_compat)\n+    warn_cxx_compat_finish_struct (fieldlist);\n \n-  VEC_free (tree, heap, struct_types);\n+  VEC_free (tree, heap, struct_parse_info->struct_types);\n+  VEC_free (c_binding_ptr, heap, struct_parse_info->fields);\n+  VEC_free (tree, heap, struct_parse_info->typedefs_seen);\n+  XDELETE (struct_parse_info);\n \n-  in_struct = enclosing_in_struct;\n-  struct_types = enclosing_struct_types;\n+  struct_parse_info = enclosing_struct_parse_info;\n \n   /* If this struct is defined inside a struct, add it to\n-     STRUCT_TYPES.  */\n-  if (in_struct && !in_sizeof && !in_typeof && !in_alignof)\n-    VEC_safe_push (tree, heap, struct_types, t);\n+     struct_types.  */\n+  if (warn_cxx_compat\n+      && struct_parse_info != NULL\n+      && !in_sizeof && !in_typeof && !in_alignof)\n+    VEC_safe_push (tree, heap, struct_parse_info->struct_types, t);\n \n   return t;\n }\n@@ -7003,9 +7095,11 @@ finish_enum (tree enumtype, tree values, tree attributes)\n   rest_of_type_compilation (enumtype, toplevel);\n \n   /* If this enum is defined inside a struct, add it to\n-     STRUCT_TYPES.  */\n-  if (in_struct && !in_sizeof && !in_typeof && !in_alignof)\n-    VEC_safe_push (tree, heap, struct_types, enumtype);\n+     struct_types.  */\n+  if (warn_cxx_compat\n+      && struct_parse_info != NULL\n+      && !in_sizeof && !in_typeof && !in_alignof)\n+    VEC_safe_push (tree, heap, struct_parse_info->struct_types, enumtype);\n \n   return enumtype;\n }\n@@ -8267,7 +8361,8 @@ declspecs_add_qual (struct c_declspecs *specs, tree qual)\n    returning SPECS.  */\n \n struct c_declspecs *\n-declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n+declspecs_add_type (location_t loc, struct c_declspecs *specs,\n+\t\t    struct c_typespec spec)\n {\n   tree type = spec.spec;\n   specs->non_sc_seen_p = true;\n@@ -8284,7 +8379,7 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n       enum rid i = C_RID_CODE (type);\n       if (specs->type)\n \t{\n-\t  error (\"two or more data types in declaration specifiers\");\n+\t  error_at (loc, \"two or more data types in declaration specifiers\");\n \t  return specs;\n \t}\n       if ((int) i <= (int) RID_LAST_MODIFIER)\n@@ -8296,203 +8391,257 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t    case RID_LONG:\n \t      if (specs->long_long_p)\n \t\t{\n-\t\t  error (\"%<long long long%> is too long for GCC\");\n+\t\t  error_at (loc, \"%<long long long%> is too long for GCC\");\n \t\t  break;\n \t\t}\n \t      if (specs->long_p)\n \t\t{\n \t\t  if (specs->typespec_word == cts_double)\n \t\t    {\n-\t\t      error (\"both %<long long%> and %<double%> in \"\n-\t\t\t     \"declaration specifiers\");\n+\t\t      error_at (loc,\n+\t\t\t\t(\"both %<long long%> and %<double%> in \"\n+\t\t\t\t \"declaration specifiers\"));\n \t\t      break;\n \t\t    }\n-\t\t  pedwarn_c90 (input_location, OPT_Wlong_long, \n+\t\t  pedwarn_c90 (loc, OPT_Wlong_long,\n \t\t\t       \"ISO C90 does not support %<long long%>\");\n \t\t  specs->long_long_p = 1;\n \t\t  break;\n \t\t}\n \t      if (specs->short_p)\n-\t\terror (\"both %<long%> and %<short%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<short%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_void)\n-\t\terror (\"both %<long%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_bool)\n-\t\terror (\"both %<long%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_char)\n-\t\terror (\"both %<long%> and %<char%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<char%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_float)\n-\t\terror (\"both %<long%> and %<float%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<float%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat32)\n-\t\terror (\"both %<long%> and %<_Decimal32%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<_Decimal32%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat64)\n-\t\terror (\"both %<long%> and %<_Decimal64%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<_Decimal64%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat128)\n-\t\terror (\"both %<long%> and %<_Decimal128%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<_Decimal128%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->long_p = true;\n \t      break;\n \t    case RID_SHORT:\n \t      dupe = specs->short_p;\n \t      if (specs->long_p)\n-\t\terror (\"both %<long%> and %<short%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<short%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_void)\n-\t\terror (\"both %<short%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_bool)\n-\t\terror (\"both %<short%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_char)\n-\t\terror (\"both %<short%> and %<char%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<char%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_float)\n-\t\terror (\"both %<short%> and %<float%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<float%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_double)\n-\t\terror (\"both %<short%> and %<double%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<double%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat32)\n-                error (\"both %<short%> and %<_Decimal32%> in \"\n-\t\t       \"declaration specifiers\");\n+                error_at (loc,\n+\t\t\t  (\"both %<short%> and %<_Decimal32%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat64)\n-\t\terror (\"both %<short%> and %<_Decimal64%> in \"\n-\t\t                        \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<_Decimal64%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat128)\n-\t\terror (\"both %<short%> and %<_Decimal128%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<_Decimal128%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->short_p = true;\n \t      break;\n \t    case RID_SIGNED:\n \t      dupe = specs->signed_p;\n \t      if (specs->unsigned_p)\n-\t\terror (\"both %<signed%> and %<unsigned%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<unsigned%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_void)\n-\t\terror (\"both %<signed%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_bool)\n-\t\terror (\"both %<signed%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_float)\n-\t\terror (\"both %<signed%> and %<float%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<float%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_double)\n-\t\terror (\"both %<signed%> and %<double%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<double%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat32)\n-\t\terror (\"both %<signed%> and %<_Decimal32%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<_Decimal32%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat64)\n-\t\terror (\"both %<signed%> and %<_Decimal64%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<_Decimal64%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat128)\n-\t\terror (\"both %<signed%> and %<_Decimal128%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<_Decimal128%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->signed_p = true;\n \t      break;\n \t    case RID_UNSIGNED:\n \t      dupe = specs->unsigned_p;\n \t      if (specs->signed_p)\n-\t\terror (\"both %<signed%> and %<unsigned%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<unsigned%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_void)\n-\t\terror (\"both %<unsigned%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_bool)\n-\t\terror (\"both %<unsigned%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_float)\n-\t\terror (\"both %<unsigned%> and %<float%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<float%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_double)\n-\t\terror (\"both %<unsigned%> and %<double%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<double%> in \"\n+\t\t\t   \"declaration specifiers\"));\n               else if (specs->typespec_word == cts_dfloat32)\n-\t\terror (\"both %<unsigned%> and %<_Decimal32%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<_Decimal32%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat64)\n-\t\terror (\"both %<unsigned%> and %<_Decimal64%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<_Decimal64%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat128)\n-\t\terror (\"both %<unsigned%> and %<_Decimal128%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<_Decimal128%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->unsigned_p = true;\n \t      break;\n \t    case RID_COMPLEX:\n \t      dupe = specs->complex_p;\n \t      if (!flag_isoc99 && !in_system_header)\n-\t\tpedwarn (input_location, OPT_pedantic, \"ISO C90 does not support complex types\");\n+\t\tpedwarn (loc, OPT_pedantic,\n+\t\t\t \"ISO C90 does not support complex types\");\n \t      if (specs->typespec_word == cts_void)\n-\t\terror (\"both %<complex%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_bool)\n-\t\terror (\"both %<complex%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n               else if (specs->typespec_word == cts_dfloat32)\n-\t\terror (\"both %<complex%> and %<_Decimal32%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<_Decimal32%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat64)\n-\t\terror (\"both %<complex%> and %<_Decimal64%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<_Decimal64%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat128)\n-\t\terror (\"both %<complex%> and %<_Decimal128%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<_Decimal128%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_fract)\n-\t\terror (\"both %<complex%> and %<_Fract%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<_Fract%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_accum)\n-\t\terror (\"both %<complex%> and %<_Accum%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<_Accum%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->saturating_p)\n-\t\terror (\"both %<complex%> and %<_Sat%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<_Sat%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->complex_p = true;\n \t      break;\n \t    case RID_SAT:\n \t      dupe = specs->saturating_p;\n-\t      pedwarn (input_location, OPT_pedantic, \"ISO C does not support saturating types\");\n+\t      pedwarn (loc, OPT_pedantic,\n+\t\t       \"ISO C does not support saturating types\");\n \t      if (specs->typespec_word == cts_void)\n-\t\terror (\"both %<_Sat%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_bool)\n-\t\terror (\"both %<_Sat%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_char)\n-\t\terror (\"both %<_Sat%> and %<char%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<char%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_int)\n-\t\terror (\"both %<_Sat%> and %<int%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<int%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_float)\n-\t\terror (\"both %<_Sat%> and %<float%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<float%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_double)\n-\t\terror (\"both %<_Sat%> and %<double%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<double%> in \"\n+\t\t\t   \"declaration specifiers\"));\n               else if (specs->typespec_word == cts_dfloat32)\n-\t\terror (\"both %<_Sat%> and %<_Decimal32%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<_Decimal32%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat64)\n-\t\terror (\"both %<_Sat%> and %<_Decimal64%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<_Decimal64%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_dfloat128)\n-\t\terror (\"both %<_Sat%> and %<_Decimal128%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<_Decimal128%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->complex_p)\n-\t\terror (\"both %<_Sat%> and %<complex%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<complex%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->saturating_p = true;\n \t      break;\n@@ -8501,7 +8650,7 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t    }\n \n \t  if (dupe)\n-\t    error (\"duplicate %qE\", type);\n+\t    error_at (loc, \"duplicate %qE\", type);\n \n \t  return specs;\n \t}\n@@ -8511,110 +8660,137 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t     \"_Decimal64\", \"_Decimal128\", \"_Fract\" or \"_Accum\".  */\n \t  if (specs->typespec_word != cts_none)\n \t    {\n-\t      error (\"two or more data types in declaration specifiers\");\n+\t      error_at (loc,\n+\t\t\t\"two or more data types in declaration specifiers\");\n \t      return specs;\n \t    }\n \t  switch (i)\n \t    {\n \t    case RID_VOID:\n \t      if (specs->long_p)\n-\t\terror (\"both %<long%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->short_p)\n-\t\terror (\"both %<short%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->signed_p)\n-\t\terror (\"both %<signed%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->unsigned_p)\n-\t\terror (\"both %<unsigned%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->complex_p)\n-\t\terror (\"both %<complex%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->saturating_p)\n-\t\terror (\"both %<_Sat%> and %<void%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<void%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->typespec_word = cts_void;\n \t      return specs;\n \t    case RID_BOOL:\n \t      if (specs->long_p)\n-\t\terror (\"both %<long%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->short_p)\n-\t\terror (\"both %<short%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->signed_p)\n-\t\terror (\"both %<signed%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->unsigned_p)\n-\t\terror (\"both %<unsigned%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->complex_p)\n-\t\terror (\"both %<complex%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->saturating_p)\n-\t\terror (\"both %<_Sat%> and %<_Bool%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<_Bool%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->typespec_word = cts_bool;\n \t      return specs;\n \t    case RID_CHAR:\n \t      if (specs->long_p)\n-\t\terror (\"both %<long%> and %<char%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<char%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->short_p)\n-\t\terror (\"both %<short%> and %<char%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<char%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->saturating_p)\n-\t\terror (\"both %<_Sat%> and %<char%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<char%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->typespec_word = cts_char;\n \t      return specs;\n \t    case RID_INT:\n \t      if (specs->saturating_p)\n-\t\terror (\"both %<_Sat%> and %<int%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<int%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->typespec_word = cts_int;\n \t      return specs;\n \t    case RID_FLOAT:\n \t      if (specs->long_p)\n-\t\terror (\"both %<long%> and %<float%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<float%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->short_p)\n-\t\terror (\"both %<short%> and %<float%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<float%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->signed_p)\n-\t\terror (\"both %<signed%> and %<float%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<float%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->unsigned_p)\n-\t\terror (\"both %<unsigned%> and %<float%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<float%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->saturating_p)\n-\t\terror (\"both %<_Sat%> and %<float%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<float%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->typespec_word = cts_float;\n \t      return specs;\n \t    case RID_DOUBLE:\n \t      if (specs->long_long_p)\n-\t\terror (\"both %<long long%> and %<double%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long long%> and %<double%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->short_p)\n-\t\terror (\"both %<short%> and %<double%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<double%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->signed_p)\n-\t\terror (\"both %<signed%> and %<double%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<double%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->unsigned_p)\n-\t\terror (\"both %<unsigned%> and %<double%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<double%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->saturating_p)\n-\t\terror (\"both %<_Sat%> and %<double%> in \"\n-\t\t       \"declaration specifiers\");\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<double%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else\n \t\tspecs->typespec_word = cts_double;\n \t      return specs;\n@@ -8630,26 +8806,40 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t\telse\n \t\t  str = \"_Decimal128\";\n \t\tif (specs->long_long_p)\n-\t\t  error (\"both %<long long%> and %<%s%> in \"\n-\t\t\t \"declaration specifiers\", str);\n+\t\t  error_at (loc,\n+\t\t\t    (\"both %<long long%> and %<%s%> in \"\n+\t\t\t     \"declaration specifiers\"),\n+\t\t\t    str);\n \t\tif (specs->long_p)\n-\t\t  error (\"both %<long%> and %<%s%> in \"\n-\t\t\t \"declaration specifiers\", str);\n+\t\t  error_at (loc,\n+\t\t\t    (\"both %<long%> and %<%s%> in \"\n+\t\t\t     \"declaration specifiers\"),\n+\t\t\t    str);\n \t\telse if (specs->short_p)\n-\t\t  error (\"both %<short%> and %<%s%> in \"\n-\t\t\t \"declaration specifiers\", str);\n+\t\t  error_at (loc,\n+\t\t\t    (\"both %<short%> and %<%s%> in \"\n+\t\t\t     \"declaration specifiers\"),\n+\t\t\t    str);\n \t\telse if (specs->signed_p)\n-\t\t  error (\"both %<signed%> and %<%s%> in \"\n-\t\t\t \"declaration specifiers\", str);\n+\t\t  error_at (loc,\n+\t\t\t    (\"both %<signed%> and %<%s%> in \"\n+\t\t\t     \"declaration specifiers\"),\n+\t\t\t    str);\n \t\telse if (specs->unsigned_p)\n-\t\t  error (\"both %<unsigned%> and %<%s%> in \"\n-\t\t\t \"declaration specifiers\", str);\n+\t\t  error_at (loc,\n+\t\t\t    (\"both %<unsigned%> and %<%s%> in \"\n+\t\t\t     \"declaration specifiers\"),\n+\t\t\t    str);\n                 else if (specs->complex_p)\n-                  error (\"both %<complex%> and %<%s%> in \"\n-                         \"declaration specifiers\", str);\n+                  error_at (loc,\n+\t\t\t    (\"both %<complex%> and %<%s%> in \"\n+\t\t\t     \"declaration specifiers\"),\n+\t\t\t    str);\n                 else if (specs->saturating_p)\n-                  error (\"both %<_Sat%> and %<%s%> in \"\n-                         \"declaration specifiers\", str);\n+                  error_at (loc,\n+\t\t\t    (\"both %<_Sat%> and %<%s%> in \"\n+\t\t\t     \"declaration specifiers\"),\n+\t\t\t    str);\n \t\telse if (i == RID_DFLOAT32)\n \t\t  specs->typespec_word = cts_dfloat32;\n \t\telse if (i == RID_DFLOAT64)\n@@ -8658,8 +8848,10 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t\t  specs->typespec_word = cts_dfloat128;\n \t      }\n \t      if (!targetm.decimal_float_supported_p ())\n-\t\terror (\"decimal floating point not supported for this target\");\n-\t      pedwarn (input_location, OPT_pedantic, \n+\t\terror_at (loc,\n+\t\t\t  (\"decimal floating point not supported \"\n+\t\t\t   \"for this target\"));\n+\t      pedwarn (loc, OPT_pedantic,\n \t\t       \"ISO C does not support decimal floating point\");\n \t      return specs;\n \t    case RID_FRACT:\n@@ -8671,16 +8863,19 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t\telse\n \t\t  str = \"_Accum\";\n                 if (specs->complex_p)\n-                  error (\"both %<complex%> and %<%s%> in \"\n-                         \"declaration specifiers\", str);\n+                  error_at (loc,\n+\t\t\t    (\"both %<complex%> and %<%s%> in \"\n+\t\t\t     \"declaration specifiers\"),\n+\t\t\t    str);\n \t\telse if (i == RID_FRACT)\n \t\t    specs->typespec_word = cts_fract;\n \t\telse\n \t\t    specs->typespec_word = cts_accum;\n \t      }\n \t      if (!targetm.fixed_point_supported_p ())\n-\t\terror (\"fixed-point types not supported for this target\");\n-\t      pedwarn (input_location, OPT_pedantic, \n+\t\terror_at (loc,\n+\t\t\t  \"fixed-point types not supported for this target\");\n+\t      pedwarn (loc, OPT_pedantic,\n \t\t       \"ISO C does not support fixed-point types\");\n \t      return specs;\n \t    default:\n@@ -8698,7 +8893,7 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n   if (specs->type || specs->typespec_word != cts_none\n       || specs->long_p || specs->short_p || specs->signed_p\n       || specs->unsigned_p || specs->complex_p)\n-    error (\"two or more data types in declaration specifiers\");\n+    error_at (loc, \"two or more data types in declaration specifiers\");\n   else if (TREE_CODE (type) == TYPE_DECL)\n     {\n       if (TREE_TYPE (type) == error_mark_node)\n@@ -8709,13 +8904,26 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t  specs->decl_attr = DECL_ATTRIBUTES (type);\n \t  specs->typedef_p = true;\n \t  specs->explicit_signed_p = C_TYPEDEF_EXPLICITLY_SIGNED (type);\n+\n+\t  /* If this typedef name is defined in a struct, then a C++\n+\t     lookup would return a different value.  */\n+\t  if (warn_cxx_compat\n+\t      && I_SYMBOL_BINDING (DECL_NAME (type))->in_struct)\n+\t    warning_at (loc, OPT_Wc___compat,\n+\t\t\t\"C++ lookup of %qD would return a field, not a type\",\n+\t\t\ttype);\n+\n+\t  /* If we are parsing a struct, record that a struct field\n+\t     used a typedef.  */\n+\t  if (warn_cxx_compat && struct_parse_info != NULL)\n+\t    VEC_safe_push (tree, heap, struct_parse_info->typedefs_seen, type);\n \t}\n     }\n   else if (TREE_CODE (type) == IDENTIFIER_NODE)\n     {\n       tree t = lookup_name (type);\n       if (!t || TREE_CODE (t) != TYPE_DECL)\n-\terror (\"%qE fails to be a typedef or built in type\", type);\n+\terror_at (loc, \"%qE fails to be a typedef or built in type\", type);\n       else if (TREE_TYPE (t) == error_mark_node)\n \t;\n       else"}, {"sha": "0fc1abb5119d1afade22303d86762823bd045820", "filename": "gcc/c-parser.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=dc491a250a946a50bdea3813e9f1f67d368e348b", "patch": "@@ -1447,6 +1447,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n     {\n       struct c_typespec t;\n       tree attrs;\n+      location_t loc = c_parser_peek_token (parser)->location;\n       if (c_parser_next_token_is (parser, CPP_NAME))\n \t{\n \t  tree value = c_parser_peek_token (parser)->value;\n@@ -1482,7 +1483,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t      t.expr = NULL_TREE;\n \t      t.expr_const_operands = true;\n \t    }\n-\t  declspecs_add_type (specs, t);\n+\t  declspecs_add_type (loc, specs, t);\n \t  continue;\n \t}\n       if (c_parser_next_token_is (parser, CPP_LESS))\n@@ -1498,7 +1499,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  t.spec = objc_get_protocol_qualified_type (NULL_TREE, proto);\n \t  t.expr = NULL_TREE;\n \t  t.expr_const_operands = true;\n-\t  declspecs_add_type (specs, t);\n+\t  declspecs_add_type (loc, specs, t);\n \t  continue;\n \t}\n       gcc_assert (c_parser_next_token_is (parser, CPP_KEYWORD));\n@@ -1547,7 +1548,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  t.spec = c_parser_peek_token (parser)->value;\n \t  t.expr = NULL_TREE;\n \t  t.expr_const_operands = true;\n-\t  declspecs_add_type (specs, t);\n+\t  declspecs_add_type (loc, specs, t);\n \t  c_parser_consume_token (parser);\n \t  break;\n \tcase RID_ENUM:\n@@ -1556,7 +1557,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  attrs_ok = true;\n \t  seen_type = true;\n \t  t = c_parser_enum_specifier (parser);\n-\t  declspecs_add_type (specs, t);\n+\t  declspecs_add_type (loc, specs, t);\n \t  break;\n \tcase RID_STRUCT:\n \tcase RID_UNION:\n@@ -1566,7 +1567,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  seen_type = true;\n \t  t = c_parser_struct_or_union_specifier (parser);\n           invoke_plugin_callbacks (PLUGIN_FINISH_TYPE, t.spec);\n-\t  declspecs_add_type (specs, t);\n+\t  declspecs_add_type (loc, specs, t);\n \t  break;\n \tcase RID_TYPEOF:\n \t  /* ??? The old parser rejected typeof after other type\n@@ -1577,7 +1578,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  attrs_ok = true;\n \t  seen_type = true;\n \t  t = c_parser_typeof_specifier (parser);\n-\t  declspecs_add_type (specs, t);\n+\t  declspecs_add_type (loc, specs, t);\n \t  break;\n \tcase RID_CONST:\n \tcase RID_VOLATILE:\n@@ -1815,10 +1816,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n     {\n       /* Parse a struct or union definition.  Start the scope of the\n \t tag before parsing components.  */\n-      bool in_struct;\n-      VEC(tree,heap) *struct_types;\n-      tree type = start_struct (struct_loc, code, ident,\n-\t  \t\t\t&in_struct, &struct_types);\n+      struct c_struct_parse_info *struct_info;\n+      tree type = start_struct (struct_loc, code, ident, &struct_info);\n       tree postfix_attrs;\n       /* We chain the components in reverse order, then put them in\n \t forward order at the end.  Each struct-declaration may\n@@ -1908,8 +1907,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t}\n       postfix_attrs = c_parser_attributes (parser);\n       ret.spec = finish_struct (struct_loc, type, nreverse (contents),\n-\t\t\t\tchainon (attrs, postfix_attrs),\n-\t\t\t\tin_struct, struct_types);\n+\t\t\t\tchainon (attrs, postfix_attrs), struct_info);\n       ret.kind = ctsk_tagdef;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;"}, {"sha": "9d3d2f30da0dd3d2c56b433b8b5d5a04c3021e60", "filename": "gcc/c-tree.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=dc491a250a946a50bdea3813e9f1f67d368e348b", "patch": "@@ -430,6 +430,7 @@ extern void gen_aux_info_record (tree, int, int, int);\n \n /* in c-decl.c */\n struct c_spot_bindings;\n+struct c_struct_parse_info;\n extern struct obstack parser_obstack;\n extern tree c_break_label;\n extern tree c_cont_label;\n@@ -465,7 +466,8 @@ extern void c_maybe_initialize_eh (void);\n extern void finish_decl (tree, location_t, tree, tree, tree);\n extern tree finish_enum (tree, tree, tree);\n extern void finish_function (void);\n-extern tree finish_struct (location_t, tree, tree, tree, bool, VEC(tree,heap) *);\n+extern tree finish_struct (location_t, tree, tree, tree,\n+\t\t\t   struct c_struct_parse_info *);\n extern struct c_arg_info *get_parm_info (bool);\n extern tree grokfield (location_t, struct c_declarator *,\n \t\t       struct c_declspecs *, tree, tree *);\n@@ -487,7 +489,8 @@ extern tree start_enum (location_t, struct c_enum_contents *, tree);\n extern int  start_function (struct c_declspecs *, struct c_declarator *, tree);\n extern tree start_decl (struct c_declarator *, struct c_declspecs *, bool,\n \t\t\ttree);\n-extern tree start_struct (location_t, enum tree_code, tree, bool *, VEC(tree,heap) **);\n+extern tree start_struct (location_t, enum tree_code, tree,\n+\t\t\t  struct c_struct_parse_info **);\n extern void store_parm_decls (void);\n extern void store_parm_decls_from (struct c_arg_info *);\n extern tree xref_tag (enum tree_code, tree);\n@@ -504,7 +507,8 @@ extern struct c_declarator *make_pointer_declarator (struct c_declspecs *,\n \t\t\t\t\t\t     struct c_declarator *);\n extern struct c_declspecs *build_null_declspecs (void);\n extern struct c_declspecs *declspecs_add_qual (struct c_declspecs *, tree);\n-extern struct c_declspecs *declspecs_add_type (struct c_declspecs *,\n+extern struct c_declspecs *declspecs_add_type (location_t,\n+\t\t\t\t\t       struct c_declspecs *,\n \t\t\t\t\t       struct c_typespec);\n extern struct c_declspecs *declspecs_add_scspec (struct c_declspecs *, tree);\n extern struct c_declspecs *declspecs_add_attrs (struct c_declspecs *, tree);"}, {"sha": "ca227ea15dd5e0d3f3d5a3e1dec0991050f42ad6", "filename": "gcc/dse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=dc491a250a946a50bdea3813e9f1f67d368e348b", "patch": "@@ -244,7 +244,7 @@ struct store_info\n \t{\n \t  /* A bitmap with one bit per byte.  Cleared bit means the position\n \t     is needed.  Used if IS_LARGE is false.  */\n-\t  bitmap bitmap;\n+\t  bitmap bmap;\n \n \t  /* Number of set bits (i.e. unneeded bytes) in BITMAP.  If it is\n \t     equal to END - BEGIN, the whole store is unused.  */\n@@ -791,7 +791,7 @@ free_store_info (insn_info_t insn_info)\n     {\n       store_info_t next = store_info->next;\n       if (store_info->is_large)\n-\tBITMAP_FREE (store_info->positions_needed.large.bitmap);\n+\tBITMAP_FREE (store_info->positions_needed.large.bmap);\n       if (store_info->cse_base)\n \tpool_free (cse_store_info_pool, store_info);\n       else\n@@ -1213,10 +1213,10 @@ set_position_unneeded (store_info_t s_info, int pos)\n {\n   if (__builtin_expect (s_info->is_large, false))\n     {\n-      if (!bitmap_bit_p (s_info->positions_needed.large.bitmap, pos))\n+      if (!bitmap_bit_p (s_info->positions_needed.large.bmap, pos))\n \t{\n \t  s_info->positions_needed.large.count++;\n-\t  bitmap_set_bit (s_info->positions_needed.large.bitmap, pos);\n+\t  bitmap_set_bit (s_info->positions_needed.large.bmap, pos);\n \t}\n     }\n   else\n@@ -1233,7 +1233,7 @@ set_all_positions_unneeded (store_info_t s_info)\n     {\n       int pos, end = s_info->end - s_info->begin;\n       for (pos = 0; pos < end; pos++)\n-\tbitmap_set_bit (s_info->positions_needed.large.bitmap, pos);\n+\tbitmap_set_bit (s_info->positions_needed.large.bmap, pos);\n       s_info->positions_needed.large.count = end;\n     }\n   else\n@@ -1263,7 +1263,7 @@ all_positions_needed_p (store_info_t s_info, int start, int width)\n     {\n       int end = start + width;\n       while (start < end)\n-\tif (bitmap_bit_p (s_info->positions_needed.large.bitmap, start++))\n+\tif (bitmap_bit_p (s_info->positions_needed.large.bmap, start++))\n \t  return false;\n       return true;\n     }\n@@ -1605,7 +1605,7 @@ record_store (rtx body, bb_info_t bb_info)\n     {\n       store_info->is_large = true;\n       store_info->positions_needed.large.count = 0;\n-      store_info->positions_needed.large.bitmap = BITMAP_ALLOC (NULL);\n+      store_info->positions_needed.large.bmap = BITMAP_ALLOC (NULL);\n     }\n   else\n     {\n@@ -2721,7 +2721,7 @@ dse_step1 (void)\n \t\t  for (s_info = ptr->store_rec; s_info; s_info = s_info->next)\n \t\t    if (s_info->is_large)\n \t\t      {\n-\t\t\tBITMAP_FREE (s_info->positions_needed.large.bitmap);\n+\t\t\tBITMAP_FREE (s_info->positions_needed.large.bmap);\n \t\t\ts_info->is_large = false;\n \t\t      }\n \t\t}"}, {"sha": "426a6a8a2f3280fdd785377cafbc1c9ee33a361b", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=dc491a250a946a50bdea3813e9f1f67d368e348b", "patch": "@@ -1,3 +1,11 @@\n+2009-06-19  Ian Lance Taylor  <iant@google.com>\n+\n+\t* objc-act.c (objc_in_struct, objc_struct_types): Remove.\n+\t(objc_struct_info): New static variable.\n+\t(objc_start_struct): Pass &objc_struct_info, not &objc_in_struct\n+\tand &objc_struct_types, to start_struct.\n+\t(objc_finish_struct): Likewise for finish_struct.\n+\n 2009-06-15  Ian Lance Taylor  <iant@google.com>\n \n \t* objc-act.c (objc_start_function): Don't set"}, {"sha": "b6a01ed316bcb77403341c52438259a4ac5832a9", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=dc491a250a946a50bdea3813e9f1f67d368e348b", "patch": "@@ -420,8 +420,7 @@ static int generating_instance_variables = 0;\n    is compiled as part of obj-c++.  */\n \n static bool objc_building_struct;\n-static bool objc_in_struct ATTRIBUTE_UNUSED;\n-static VEC(tree,heap) *objc_struct_types ATTRIBUTE_UNUSED;\n+static struct c_struct_parse_info *objc_struct_info ATTRIBUTE_UNUSED;\n \n /* Start building a struct for objc.  */\n \n@@ -430,8 +429,7 @@ objc_start_struct (tree name)\n {\n   gcc_assert (!objc_building_struct);\n   objc_building_struct = true;\n-  return start_struct (input_location, RECORD_TYPE, \n-\t\t       name, &objc_in_struct, &objc_struct_types);\n+  return start_struct (input_location, RECORD_TYPE, name, &objc_struct_info);\n }\n \n /* Finish building a struct for objc.  */\n@@ -442,7 +440,7 @@ objc_finish_struct (tree type, tree fieldlist)\n   gcc_assert (objc_building_struct);\n   objc_building_struct = false;\n   return finish_struct (input_location, type, fieldlist, NULL_TREE,\n-\t\t\tobjc_in_struct, objc_struct_types);\n+\t\t\tobjc_struct_info);\n }\n \n /* Some platforms pass small structures through registers versus"}, {"sha": "526830f588b9884f2af8fc779cff3f1bd0a3ba56", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=dc491a250a946a50bdea3813e9f1f67d368e348b", "patch": "@@ -1,3 +1,9 @@\n+2009-06-19  Ian Lance Taylor  <iant@google.com>\n+\n+\t* objcp-decl.h (start_struct): Remove in_struct and struct_types\n+\tparameters.  Add struct_info parameter.\n+\t(finish_struct): Likewise.\n+\n 2009-06-13  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* objcp-decl.h (start_struct): Add location argument."}, {"sha": "50d98287662b12a89fd4b4ae440d9a1a5495fc9e", "filename": "gcc/objcp/objcp-decl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fobjcp%2Fobjcp-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Fobjcp%2Fobjcp-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-decl.h?ref=dc491a250a946a50bdea3813e9f1f67d368e348b", "patch": "@@ -37,9 +37,9 @@ extern tree objcp_end_compound_stmt (tree, int);\n    invoke the original C++ functions if needed).  */\n #ifdef OBJCP_REMAP_FUNCTIONS\n \n-#define start_struct(loc, code, name, in_struct, struct_types) \\\n+#define start_struct(loc, code, name, struct_info) \\\n \tobjcp_start_struct (loc, code, name)\n-#define finish_struct(loc, t, fieldlist, attributes, in_struct, struct_types) \\\n+#define finish_struct(loc, t, fieldlist, attributes, struct_info) \\\n \tobjcp_finish_struct (loc, t, fieldlist, attributes)\n #define finish_function() \\\n \tobjcp_finish_function ()"}, {"sha": "db6c860c175983635cdf7084ceae549478920167", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dc491a250a946a50bdea3813e9f1f67d368e348b", "patch": "@@ -1,3 +1,7 @@\n+2009-06-19  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/Wcxx-compat-15.c: New testcase.\n+\n 2009-06-19  Ian Lance Taylor  <iant@google.com>\n \n \t* gcc.dg/Wcxx-compat-16.c: New testcase."}, {"sha": "82a76ec4d0f1088e6fbab78889a9ec0863aed9ed", "filename": "gcc/testsuite/gcc.dg/Wcxx-compat-15.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc491a250a946a50bdea3813e9f1f67d368e348b/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-15.c?ref=dc491a250a946a50bdea3813e9f1f67d368e348b", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wc++-compat\" } */\n+\n+typedef int myint1;\n+typedef int myint2;\n+typedef int myint3;\n+struct s1\n+{\n+  myint1 myint1;\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+  myint2 *myint2;\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+  int myint3;\n+  struct s2\n+  {\n+    myint3 f2;\t\t/* { dg-warning \"C\\[+\\]\\[+\\]\" } */\n+  } f1;\n+};\n+\n+struct s3\n+{\n+  int myint1;\n+  struct s4\n+  {\n+    int myint1;\n+  } f1;\n+  struct s5\n+  {\n+    int myint1;\n+    struct s6\n+    {\n+      myint1 f4;\t/* { dg-warning \"C\\[+\\]\\[+\\]\" } */\n+    } f3;\n+  } f2;\n+};"}]}