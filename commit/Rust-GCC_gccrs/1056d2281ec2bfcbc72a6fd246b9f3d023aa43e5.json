{"sha": "1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA1NmQyMjgxZWMyYmZjYmM3MmE2ZmQyNDZiOWYzZDAyM2FhNDNlNQ==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-09-05T22:37:17Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-09-05T22:37:17Z"}, "message": "cp-demangle.c (demangle_encoding): Rename variable.\n\n\t* cp-demangle.c (demangle_encoding): Rename variable.\n\t(demangle_name): Rename parameter.  Handle return type\n\tsuppression.\n\t(demangle_nested_name): Rename parameter.\n\t(demangle_prefix): Likewise.  Change return type suppression.\n\t(demangle_unqualified_name): Add parameter.  Flag constructors and\n\tconversion operators.\n\t(demangle_special_name): Fix comment.\n\t(demangle_type): Rename variable.\n\t(demangle_bare_function_type): Check for missing return type and\n\tparameter.\n\t(demangle_class_enum_type): Rename parameter.\n\t(demangle_discriminator): Fix misspelling in comment.\n\nFrom-SVN: r36168", "tree": {"sha": "e3d1b77f9102ab980795e71b5f5d9d9cb43957e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3d1b77f9102ab980795e71b5f5d9d9cb43957e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5/comments", "author": null, "committer": null, "parents": [{"sha": "1e570a6a1b002e7ebceb6b400164df3c8344109b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e570a6a1b002e7ebceb6b400164df3c8344109b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e570a6a1b002e7ebceb6b400164df3c8344109b"}], "stats": {"total": 186, "additions": 113, "deletions": 73}, "files": [{"sha": "fd7f555ee4ebe77f6d97a9eae1585ef29bec13d4", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5", "patch": "@@ -1,3 +1,19 @@\n+2000-09-05  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* cp-demangle.c (demangle_encoding): Rename variable.\n+\t(demangle_name): Rename parameter.  Handle return type\n+\tsuppression.\n+\t(demangle_nested_name): Rename parameter.\n+\t(demangle_prefix): Likewise.  Change return type suppression.\n+\t(demangle_unqualified_name): Add parameter.  Flag constructors and\n+\tconversion operators.\n+\t(demangle_special_name): Fix comment.\n+\t(demangle_type): Rename variable.\n+\t(demangle_bare_function_type): Check for missing return type and\n+\tparameter. \n+\t(demangle_class_enum_type): Rename parameter.\n+\t(demangle_discriminator): Fix misspelling in comment.\n+\n 2000-08-31  DJ Delorie  <dj@redhat.com>\n \n \t* configure.in (Cygwin): special case cygwin only when we're"}, {"sha": "48325e66d9fbd06db63d42b3379c1c801529e160", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 97, "deletions": 73, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5", "patch": "@@ -805,7 +805,7 @@ static status_t demangle_nested_name\n static status_t demangle_prefix\n   PARAMS ((demangling_t, int *));\n static status_t demangle_unqualified_name\n-  PARAMS ((demangling_t));\n+  PARAMS ((demangling_t, int *));\n static status_t demangle_source_name\n   PARAMS ((demangling_t));\n static status_t demangle_number\n@@ -922,7 +922,7 @@ static status_t\n demangle_encoding (dm)\n      demangling_t dm;\n {\n-  int template_p;\n+  int encode_return_type;\n   int start_position;\n   template_arg_list_t old_arg_list = current_template_arg_list (dm);\n   char peek = peek_char (dm);\n@@ -938,14 +938,14 @@ demangle_encoding (dm)\n   else\n     {\n       /* Now demangle the name.  */\n-      RETURN_IF_ERROR (demangle_name (dm, &template_p));\n+      RETURN_IF_ERROR (demangle_name (dm, &encode_return_type));\n \n       /* If there's anything left, the name was a function name, with\n \t maybe its return type, and its parameters types, following.  */\n       if (!end_of_name_p (dm) \n \t  && peek_char (dm) != 'E')\n \t{\n-\t  if (template_p)\n+\t  if (encode_return_type)\n \t    /* Template functions have their return type encoded.  The\n \t       return type should be inserted at start_position.  */\n \t    RETURN_IF_ERROR \n@@ -980,26 +980,32 @@ demangle_encoding (dm)\n                         ::= <substitution>  */\n \n static status_t\n-demangle_name (dm, template_p)\n+demangle_name (dm, encode_return_type)\n      demangling_t dm;\n-     int *template_p;\n+     int *encode_return_type;\n {\n   int start = substitution_start (dm);\n   char peek = peek_char (dm);\n   int is_std_substitution = 0;\n \n+  /* Generally, the return type is encoded if the function is a\n+     template-id, and suppressed otherwise.  There are a few cases,\n+     though, in which the return type is not encoded even for a\n+     templated function.  In these cases, this flag is set.  */\n+  int suppress_return_type = 0;\n+\n   DEMANGLE_TRACE (\"name\", dm);\n \n   switch (peek)\n     {\n     case 'N':\n       /* This is a <nested-name>.  */\n-      RETURN_IF_ERROR (demangle_nested_name (dm, template_p));\n+      RETURN_IF_ERROR (demangle_nested_name (dm, encode_return_type));\n       break;\n \n     case 'Z':\n       RETURN_IF_ERROR (demangle_local_name (dm));\n-      *template_p = 0;\n+      *encode_return_type = 0;\n       break;\n \n     case 'S':\n@@ -1010,13 +1016,12 @@ demangle_name (dm, template_p)\n \t  (void) next_char (dm);\n \t  (void) next_char (dm);\n \t  RETURN_IF_ERROR (result_append (dm, \"std::\"));\n-\t  RETURN_IF_ERROR (demangle_unqualified_name (dm));\n+\t  RETURN_IF_ERROR \n+\t    (demangle_unqualified_name (dm, &suppress_return_type));\n \t  is_std_substitution = 1;\n \t}\n       else\n-\t{\n-\t  RETURN_IF_ERROR (demangle_substitution (dm, template_p));\n-\t}\n+\tRETURN_IF_ERROR (demangle_substitution (dm, encode_return_type));\n       /* Check if a template argument list immediately follows.\n \t If so, then we just demangled an <unqualified-template-name>.  */\n       if (peek_char (dm) == 'I') \n@@ -1027,16 +1032,16 @@ demangle_name (dm, template_p)\n \t    RETURN_IF_ERROR (substitution_add (dm, start, 0));\n \t  /* Demangle the <template-args> here.  */\n \t  RETURN_IF_ERROR (demangle_template_args (dm));\n-\t  *template_p = 1;\n+\t  *encode_return_type = !suppress_return_type;\n \t}\n       else\n-\t*template_p = 0;\n+\t*encode_return_type = 0;\n \n       break;\n \n     default:\n       /* This is an <unscoped-name> or <unscoped-template-name>.  */\n-      RETURN_IF_ERROR (demangle_unqualified_name (dm));\n+      RETURN_IF_ERROR (demangle_unqualified_name (dm, &suppress_return_type));\n \n       /* If the <unqualified-name> is followed by template args, this\n \t is an <unscoped-template-name>.  */\n@@ -1046,10 +1051,10 @@ demangle_name (dm, template_p)\n \t  RETURN_IF_ERROR (substitution_add (dm, start, 0));\n \n \t  RETURN_IF_ERROR (demangle_template_args (dm));\n-\t  *template_p = 1;\n+\t  *encode_return_type = !suppress_return_type;\n \t}\n       else\n-\t*template_p = 0;\n+\t*encode_return_type = 0;\n \n       break;\n     }\n@@ -1062,9 +1067,9 @@ demangle_name (dm, template_p)\n     <nested-name>     ::= N [<CV-qualifiers>] <prefix> <unqulified-name> E  */\n \n static status_t\n-demangle_nested_name (dm, template_p)\n+demangle_nested_name (dm, encode_return_type)\n      demangling_t dm;\n-     int *template_p;\n+     int *encode_return_type;\n {\n   char peek;\n \n@@ -1089,7 +1094,7 @@ demangle_nested_name (dm, template_p)\n       RETURN_IF_ERROR (result_append_space (dm));\n     }\n   \n-  RETURN_IF_ERROR (demangle_prefix (dm, template_p));\n+  RETURN_IF_ERROR (demangle_prefix (dm, encode_return_type));\n   /* No need to demangle the final <unqualified-name>; demangle_prefix\n      will handle it.  */\n   RETURN_IF_ERROR (demangle_char (dm, 'E'));\n@@ -1108,20 +1113,22 @@ demangle_nested_name (dm, template_p)\n                         ::= <substitution>  */\n \n static status_t\n-demangle_prefix (dm, template_p)\n+demangle_prefix (dm, encode_return_type)\n      demangling_t dm;\n-     int *template_p;\n+     int *encode_return_type;\n {\n   int start = substitution_start (dm);\n   int nested = 0;\n \n-  /* This flag is set to non-zero if the most recent (rightmost)\n-     element in the prefix was a constructor.  */\n-  int last_was_ctor = 0;\n+  /* ENCODE_RETURN_TYPE is updated as we decend the nesting chain.\n+     After <template-args>, it is set to non-zero; after everything\n+     else it is set to zero.  */\n \n-  /* TEMPLATE_P is updated as we decend the nesting chain.  After\n-     <template-args>, it is set to non-zero; after everything else it\n-     is set to zero.  */\n+  /* Generally, the return type is encoded if the function is a\n+     template-id, and suppressed otherwise.  There are a few cases,\n+     though, in which the return type is not encoded even for a\n+     templated function.  In these cases, this flag is set.  */\n+  int suppress_return_type = 0;\n \n   DEMANGLE_TRACE (\"prefix\", dm);\n \n@@ -1134,14 +1141,14 @@ demangle_prefix (dm, template_p)\n \n       peek = peek_char (dm);\n       \n-      /* We'll initialize last_was_ctor to false, and set it to true\n+      /* We'll initialize suppress_return_type to false, and set it to true\n \t if we end up demangling a constructor name.  However, make\n \t sure we're not actually about to demangle template arguments\n \t -- if so, this is the <template-args> following a\n \t <template-prefix>, so we'll want the previous flag value\n \t around.  */\n       if (peek != 'I')\n-\tlast_was_ctor = 0;\n+\tsuppress_return_type = 0;\n \n       if (IS_DIGIT ((unsigned char) peek)\n \t  || (peek >= 'a' && peek <= 'z')\n@@ -1157,18 +1164,14 @@ demangle_prefix (dm, template_p)\n \t  if (peek == 'S')\n \t    /* The substitution determines whether this is a\n \t       template-id.  */\n-\t    RETURN_IF_ERROR (demangle_substitution (dm, template_p));\n+\t    RETURN_IF_ERROR (demangle_substitution (dm, encode_return_type));\n \t  else\n \t    {\n \t      /* It's just a name.  */\n-\t      RETURN_IF_ERROR (demangle_unqualified_name (dm));\n-\t      *template_p = 0;\n+\t      RETURN_IF_ERROR \n+\t\t(demangle_unqualified_name (dm, &suppress_return_type));\n+\t      *encode_return_type = 0;\n \t    }\n-\n-\t  /* If this element was a constructor name, make a note of\n-\t     that.  */\n-\t  if (peek == 'C')\n-\t    last_was_ctor = 1;\n \t}\n       else if (peek == 'Z')\n \tRETURN_IF_ERROR (demangle_local_name (dm));\n@@ -1180,14 +1183,10 @@ demangle_prefix (dm, template_p)\n \t     demangled template arguments, thus the prefix was a\n \t     <template-prefix>.  That's so that the caller knows to\n \t     demangle the function's return type, if this turns out to\n-\t     be a function name.  */\n-\t  if (!last_was_ctor)\n-\t    *template_p = 1;\n-\t  else\n-\t    /* But, if it's a member template constructor, report it\n-\t       as untemplated.  We don't ever want to demangle the\n-\t       return type of a constructor.  */\n-\t    *template_p = 0;\n+\t     be a function name.  But, if it's a member template\n+\t     constructor or a templated conversion operator, report it\n+\t     as untemplated.  Those never get encoded return types.  */\n+\t  *encode_return_type = !suppress_return_type;\n \t}\n       else if (peek == 'E')\n \t/* All done.  */\n@@ -1198,36 +1197,53 @@ demangle_prefix (dm, template_p)\n       if (peek != 'S'\n \t  && peek_char (dm) != 'E')\n \t/* Add a new substitution for the prefix thus far.  */\n-\tRETURN_IF_ERROR (substitution_add (dm, start, *template_p));\n+\tRETURN_IF_ERROR (substitution_add (dm, start, *encode_return_type));\n     }\n }\n \n-/* Demangles and emits an <unqualified-name>.  If the\n-   <unqualified-name> is a function and the first element in the\n-   argument list should be taken to be its return type,\n-   ENCODE_RETURN_TYPE is non-zero.\n+/* Demangles and emits an <unqualified-name>.  If this\n+   <unqualified-name> is for a special function type that should never\n+   have its return type encoded (particularly, a constructor or\n+   conversion operator), *SUPPRESS_RETURN_TYPE is set to 1; otherwise,\n+   it is set to zero.\n \n     <unqualified-name>  ::= <operator-name>\n \t\t\t::= <special-name>  \n \t\t\t::= <source-name>  */\n \n static status_t\n-demangle_unqualified_name (dm)\n+demangle_unqualified_name (dm, suppress_return_type)\n      demangling_t dm;\n+     int *suppress_return_type;\n {\n   char peek = peek_char (dm);\n \n   DEMANGLE_TRACE (\"unqualified-name\", dm);\n \n+  /* By default, don't force suppression of the return type (though\n+     non-template functions still don't get a return type encoded).  */ \n+  *suppress_return_type = 0;\n+\n   if (IS_DIGIT ((unsigned char) peek))\n     RETURN_IF_ERROR (demangle_source_name (dm));\n   else if (peek >= 'a' && peek <= 'z')\n     {\n       int num_args;\n+\n+      /* Conversion operators never have a return type encoded.  */\n+      if (peek == 'c' && peek_char_next (dm) == 'v')\n+\t*suppress_return_type = 1;\n+\n       RETURN_IF_ERROR (demangle_operator_name (dm, 0, &num_args));\n     }\n   else if (peek == 'C' || peek == 'D')\n-    RETURN_IF_ERROR (demangle_ctor_dtor_name (dm));\n+    {\n+      /* Constructors never have a return type encoded.  */\n+      if (peek == 'C')\n+\t*suppress_return_type = 1;\n+\n+      RETURN_IF_ERROR (demangle_ctor_dtor_name (dm));\n+    }\n   else\n     return \"Unexpected character in <unqualified-name>.\";\n \n@@ -1725,7 +1741,7 @@ demangle_call_offset (dm)\n \n    Also demangles the special g++ manglings,\n \n-    <special-name> ::= CT <type> <offset number> _ <base type>\n+    <special-name> ::= TC <type> <offset number> _ <base type>\n                                           # construction vtable\n \t\t   ::= TF <type>\t  # typeinfo function (old ABI only)\n \t\t   ::= TJ <type>\t  # java Class structure  */\n@@ -2148,7 +2164,7 @@ demangle_type (dm)\n   int start = substitution_start (dm);\n   char peek = peek_char (dm);\n   char peek_next;\n-  int template_p = 0;\n+  int encode_return_type = 0;\n   template_arg_list_t old_arg_list = current_template_arg_list (dm);\n   int insert_pos;\n \n@@ -2162,7 +2178,7 @@ demangle_type (dm)\n   /* A <class-enum-type> can start with a digit (a <source-name>), an\n      N (a <nested-name>), or a Z (a <local-name>).  */\n   if (IS_DIGIT ((unsigned char) peek) || peek == 'N' || peek == 'Z')\n-    RETURN_IF_ERROR (demangle_class_enum_type (dm, &template_p));\n+    RETURN_IF_ERROR (demangle_class_enum_type (dm, &encode_return_type));\n   /* Lower-case letters begin <builtin-type>s, except for `r', which\n      denotes restrict.  */\n   else if (peek >= 'a' && peek <= 'z' && peek != 'r')\n@@ -2235,7 +2251,7 @@ demangle_type (dm)\n \t    /* Add a substitution candidate.  The template parameter\n \t       `T' token is a substitution candidate by itself,\n \t       without the template argument list.  */\n-\t    RETURN_IF_ERROR (substitution_add (dm, start, template_p));\n+\t    RETURN_IF_ERROR (substitution_add (dm, start, encode_return_type));\n \n \t    /* Now demangle the template argument list.  */\n \t    RETURN_IF_ERROR (demangle_template_args (dm));\n@@ -2254,7 +2270,7 @@ demangle_type (dm)\n \tpeek_next = peek_char_next (dm);\n \tif (IS_DIGIT (peek_next) || peek_next == '_')\n \t  {\n-\t    RETURN_IF_ERROR (demangle_substitution (dm, &template_p));\n+\t    RETURN_IF_ERROR (demangle_substitution (dm, &encode_return_type));\n \t    \n \t    /* The substituted name may have been a template name.\n \t       Check if template arguments follow, and if so, demangle\n@@ -2271,7 +2287,7 @@ demangle_type (dm)\n \t  /* While the special substitution token itself is not a\n \t     substitution candidate, the <class-enum-type> is, so\n \t     don't clear is_substitution_candidate.  */\n-\t  RETURN_IF_ERROR (demangle_class_enum_type (dm, &template_p));\n+\t  RETURN_IF_ERROR (demangle_class_enum_type (dm, &encode_return_type));\n \n \tbreak;\n \n@@ -2315,7 +2331,7 @@ demangle_type (dm)\n        <template-param>, pass its index since from the point of\n        substitutions; a <template-param> token is a substitution\n        candidate distinct from the type that is substituted for it.  */\n-    RETURN_IF_ERROR (substitution_add (dm, start, template_p));\n+    RETURN_IF_ERROR (substitution_add (dm, start, encode_return_type));\n \n   /* Pop off template argument lists added during mangling of this\n      type.  */\n@@ -2536,38 +2552,46 @@ demangle_bare_function_type (dm, return_type_pos)\n \t     the only type in a parameter list; in that case, we want\n \t     to print `foo ()' instead of `foo (void)'.  */\n \t  if (peek_char (dm) == 'v')\n+\t    /* Consume the v.  */\n+\t    advance_char (dm);\n+\t  else\n \t    {\n-\t      /* Consume the v.  */\n-\t      advance_char (dm);\n-\t      continue;\n+\t      /* Separate parameter types by commas.  */\n+\t      if (sequence > 0)\n+\t\tRETURN_IF_ERROR (result_append (dm, \", \"));\n+\t      /* Demangle the type.  */\n+\t      RETURN_IF_ERROR (demangle_type (dm));\n \t    }\n-\t  /* Separate parameter types by commas.  */\n-\t  if (sequence > 0)\n-\t    RETURN_IF_ERROR (result_append (dm, \", \"));\n-\t  /* Demangle the type.  */\n-\t  RETURN_IF_ERROR (demangle_type (dm));\n \t}\n \n       ++sequence;\n     }\n   RETURN_IF_ERROR (result_append_char (dm, ')'));\n \n+  /* We should have demangled at least one parameter type (which would\n+     be void, for a function that takes no parameters), plus the\n+     return type, if we were supposed to demangle that.  */\n+  if (sequence == -1)\n+    return \"Missing function return type.\";\n+  else if (sequence == 0)\n+    return \"Missing function parameter.\";\n+\n   return STATUS_OK;\n }\n \n-/* Demangles and emits a <class-enum-type>.  *TEMPLATE_P is set to\n+/* Demangles and emits a <class-enum-type>.  *ENCODE_RETURN_TYPE is set to\n    non-zero if the type is a template-id, zero otherwise.  \n \n     <class-enum-type> ::= <name>  */\n \n static status_t\n-demangle_class_enum_type (dm, template_p)\n+demangle_class_enum_type (dm, encode_return_type)\n      demangling_t dm;\n-     int *template_p;\n+     int *encode_return_type;\n {\n   DEMANGLE_TRACE (\"class-enum-type\", dm);\n \n-  RETURN_IF_ERROR (demangle_name (dm, template_p));\n+  RETURN_IF_ERROR (demangle_name (dm, encode_return_type));\n   return STATUS_OK;\n }\n \n@@ -3204,7 +3228,7 @@ demangle_discriminator (dm, suppress_first)\n      int suppress_first;\n {\n   /* Output for <discriminator>s to the demangled name is completely\n-     supressed if not in verbose mode.  */\n+     suppressed if not in verbose mode.  */\n \n   if (peek_char (dm) == '_')\n     {"}]}