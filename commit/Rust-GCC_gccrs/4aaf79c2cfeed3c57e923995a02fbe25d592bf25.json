{"sha": "4aaf79c2cfeed3c57e923995a02fbe25d592bf25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFhZjc5YzJjZmVlZDNjNTdlOTIzOTk1YTAyZmJlMjVkNTkyYmYyNQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-11-03T12:01:01Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-11-03T12:01:01Z"}, "message": "re PR target/51244 ([SH] Inefficient conditional branch and code around T bit)\n\n\tPR target/51244\n\t* config/sh/sh.md (*cbranch_t): Allow splitting after reload.\n\tAllow going beyond current basic block before reload when looking for\n\tthe reg set insn.\n\t* config/sh/sh.c (sh_find_set_of_reg): Don't stop at labels.\n\n\tPR target/51244\n\t* gcc.target/sh/pr51244-18.c: New.\n\t* gcc.target/sh/pr51244-19.c: New.\n\nFrom-SVN: r193119", "tree": {"sha": "ef0d9e9173002423f55c425d4b7c49f155dccdfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef0d9e9173002423f55c425d4b7c49f155dccdfc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4aaf79c2cfeed3c57e923995a02fbe25d592bf25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aaf79c2cfeed3c57e923995a02fbe25d592bf25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aaf79c2cfeed3c57e923995a02fbe25d592bf25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/comments", "author": null, "committer": null, "parents": [{"sha": "49503de9a9ccdfab8247742065896d59f48a9022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49503de9a9ccdfab8247742065896d59f48a9022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49503de9a9ccdfab8247742065896d59f48a9022"}], "stats": {"total": 202, "additions": 199, "deletions": 3}, "files": [{"sha": "8af3547cd4e4fd2aca45b230eed4930dc0fe3888", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4aaf79c2cfeed3c57e923995a02fbe25d592bf25", "patch": "@@ -1,3 +1,11 @@\n+2012-11-03  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* config/sh/sh.md (*cbranch_t): Allow splitting after reload.\n+\tAllow going beyond current basic block before reload when looking for\n+\tthe reg set insn.\n+\t* config/sh/sh.c (sh_find_set_of_reg): Don't stop at labels.\n+\n 2012-11-02  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-loop-niter.c (discover_iteration_bound_by_body_walk): Add"}, {"sha": "25573b36982093bca02b489126962d6bdbeb330b", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=4aaf79c2cfeed3c57e923995a02fbe25d592bf25", "patch": "@@ -13486,7 +13486,7 @@ sh_find_set_of_reg (rtx reg, rtx insn, rtx(*stepfunc)(rtx))\n   for (result.insn = stepfunc (insn); result.insn != NULL_RTX;\n        result.insn = stepfunc (result.insn))\n     {\n-      if (LABEL_P (result.insn) || BARRIER_P (result.insn))\n+      if (BARRIER_P (result.insn))\n \treturn result;\n       if (!NONJUMP_INSN_P (result.insn))\n \tcontinue;"}, {"sha": "a002304845ee9d00903f4f6dc30fcb31c15814cb", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=4aaf79c2cfeed3c57e923995a02fbe25d592bf25", "patch": "@@ -8167,13 +8167,15 @@ label:\n {\n   return output_branch (sh_eval_treg_value (operands[1]), insn, operands);\n }\n-  \"&& can_create_pseudo_p ()\"\n+  \"&& 1\"\n   [(set (pc) (if_then_else (eq (reg:SI T_REG) (match_dup 2))\n \t\t\t   (label_ref (match_dup 0))\n \t\t\t   (pc)))]\n {\n   /* Try to find missed test and branch combine opportunities which result\n      in redundant T bit tests before conditional branches.\n+     This is done not only after combine (and before reload) but in every\n+     split pass, because some opportunities are formed also after combine.\n      FIXME: Probably this would not be needed if CCmode was used\n      together with TARGET_FIXED_CONDITION_CODE_REGS.  */\n \n@@ -8212,8 +8214,11 @@ label:\n \n   while (true)\n     {\n+      /* It's not safe to go beyond the current basic block after reload.  */\n       set_of_reg s1 = sh_find_set_of_reg (tested_reg, s0.insn,\n-\t\t\t\t\t  prev_nonnote_insn_bb);\n+\t\t\t\t\t  reload_completed\n+\t\t\t\t\t  ? prev_nonnote_insn_bb\n+\t\t\t\t\t  : prev_nonnote_insn);\n       if (s1.set_src == NULL_RTX)\n \tbreak;\n "}, {"sha": "2f5d1f77dba1b9bca3a097ae6feacc79b37fb303", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4aaf79c2cfeed3c57e923995a02fbe25d592bf25", "patch": "@@ -1,3 +1,9 @@\n+2012-11-03  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* gcc.target/sh/pr51244-18.c: New.\n+\t* gcc.target/sh/pr51244-19.c: New.\n+\n 2012-11-03  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gcc.target/mips/octeon-exts-7.c (bar): Make sure the extraction of"}, {"sha": "dbfb9901c2b04ca233857a8a17dfa8ab4ba540df", "filename": "gcc/testsuite/gcc.target/sh/pr51244-18.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-18.c?ref=4aaf79c2cfeed3c57e923995a02fbe25d592bf25", "patch": "@@ -0,0 +1,102 @@\n+/* Check that no unnecessary T bit stores are done before conditional\n+   branches.\n+   This case was extracted from the CSiBE set and contained the following\n+   sequence:\n+\tcmp/hi\tr1,r0\n+\tmovt\tr1\n+\ttst\tr1,r1\n+\tbt\t.L12\n+\tmov.l\t@r10,r1\n+   In this reduced code the movt and tst insns were only present in the\n+   unwanted sequence.  Thus, if we see any tst or movt insns, something is\n+   not working as expected.  This test requires -O2 because the T bit stores\n+   in question will be eliminated in additional insn split passes after\n+   reload.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"movt|tst\" } } */\n+\n+typedef char Char;\n+typedef unsigned char Bool;\n+typedef unsigned char UChar;\n+typedef int Int32;\n+typedef unsigned int UInt32;\n+typedef short Int16;\n+typedef unsigned short UInt16;\n+\n+static inline Bool\n+mainGtU (UInt32 i1, UInt32 i2, UChar* block, UInt16* quadrant, UInt32 nblock,\n+\t Int32* budget)\n+{\n+  Int32 k;\n+  UChar c1, c2;\n+  UInt16 s1, s2;\n+  k = nblock + 8;\n+  do\n+    {\n+      c1 = block[i1];\n+      c2 = block[i2];\n+      if (c1 != c2)\n+\treturn (c1 > c2);\n+      s1 = quadrant[i1];\n+      s2 = quadrant[i2];\n+      if (s1 != s2)\n+\treturn (s1 > s2);\n+\n+      i1++; i2++;\n+      k -= 8;\n+   } while (k >= 0);\n+\n+  return 0;\n+}\n+\n+static inline void\n+mainSimpleSort (UInt32* ptr, UChar* block, UInt16* quadrant, Int32 nblock,\n+\t\tInt32 lo, Int32 hi, Int32 d, Int32* budget)\n+{\n+  Int32 i, j, h, bigN, hp;\n+  UInt32 v;\n+  bigN = hi - lo + 1;\n+  hp = 0;\n+  h = 1;\n+  j = lo + h;\n+  v = ptr[j];\n+\n+  while (mainGtU (ptr[j-h]+d, v+d, block, quadrant, nblock, budget))\n+    {\n+      ptr[j] = ptr[j-h];\n+      j = j - h;\n+    }\n+}\n+\n+static inline void\n+mainQSort3 (UInt32* ptr, UChar* block, UInt16* quadrant, Int32 nblock,\n+\t    Int32 loSt, Int32 hiSt, Int32 dSt, Int32* budget)\n+{\n+  Int32 unLo, unHi, ltLo, gtHi;\n+  Int32 sp, lo, hi, d;\n+\n+  Int32 stackLo[100];\n+  Int32 stackHi[100];\n+  Int32 stackD [100];\n+\n+  sp = 0;\n+  stackLo[sp] = loSt;\n+  stackHi[sp] = hiSt;\n+  stackD [sp] = dSt;\n+  lo = stackLo[sp];\n+  hi = stackHi[sp];\n+  d = stackD [sp];\n+  mainSimpleSort (ptr, block, quadrant, nblock, lo, hi, d, budget);\n+}\n+\n+void\n+mainSort (UInt32* ptr, UChar* block, UInt16* quadrant, UInt32* ftab,\n+\t  Int32 nblock, Int32 verb, Int32* budget)\n+{\n+  Int32 sb = 0;\n+  Int32 lo = ftab[sb] & (~((1 << 21)));\n+  Int32 hi = (ftab[sb+1] & (~((1 << 21)))) - 1;\n+  mainQSort3 (ptr, block, quadrant, nblock, lo, hi, 2, budget);\n+}"}, {"sha": "4d4f781ed5cc511c97febdc25356d2b3c9fb200d", "filename": "gcc/testsuite/gcc.target/sh/pr51244-19.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aaf79c2cfeed3c57e923995a02fbe25d592bf25/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-19.c?ref=4aaf79c2cfeed3c57e923995a02fbe25d592bf25", "patch": "@@ -0,0 +1,75 @@\n+/* Check that no unnecessary T bit stores are done before conditional\n+   branches.\n+   This case was extracted from the CSiBE set and contained the following\n+   sequence:\n+\tmov.l\t@(8,r4),r2\n+\tmov.l\t@(4,r4),r3\n+\tcmp/gt\tr2,r3\n+\tmovt\tr2\n+.L3:\n+\ttst\tr2,r2\n+\tbt/s\t.L12\n+\tmov\t#-1,r0\n+\n+\t.....\n+\n+\tmov.l\t@r4,r2\n+\ttst\tr2,r2\n+\tbra\t.L3\n+\tmovt\tr2\n+\n+   In this reduced code the movt insns were only present in the\n+   unwanted sequences.  Thus, if we see any movt insns, something is not\n+   working as expected.  This test requires -O2 because the T bit stores\n+   in question will be eliminated in additional insn split passes after\n+   reload.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"movt\" } } */\n+\n+struct request\n+{\n+ unsigned long nr_sectors;\n+};\n+\n+struct request_list\n+{\n+ int count;\n+};\n+\n+struct request_queue\n+{\n+ struct request_list rq;\n+ volatile int nr_sectors;\n+ int max_queue_sectors;\n+ int can_throttle;\n+ unsigned long bounce_pfn;\n+};\n+\n+typedef struct request_queue request_queue_t;\n+\n+static inline int\n+blk_oversized_queue (request_queue_t* q)\n+{\n+  if (q->can_throttle)\n+    return q->nr_sectors > q->max_queue_sectors;\n+  return q->rq.count == 0;\n+}\n+\n+struct request*\n+get_request (request_queue_t* q, int rw)\n+{\n+  struct request* rq = ((void*)0);\n+  struct request_list *rl = &q->rq;\n+\n+  if (blk_oversized_queue (q))\n+    {\n+      if ((rw == 1) || (rw == 0))\n+\treturn ((void*)0);\n+      if (blk_oversized_queue (q))\n+\treturn ((void*)0);\n+    }\n+\n+  return (void*)-100;\n+}"}]}