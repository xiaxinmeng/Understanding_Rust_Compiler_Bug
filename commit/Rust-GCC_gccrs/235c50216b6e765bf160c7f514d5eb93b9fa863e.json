{"sha": "235c50216b6e765bf160c7f514d5eb93b9fa863e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM1YzUwMjE2YjZlNzY1YmYxNjBjN2Y1MTRkNWViOTNiOWZhODYzZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-23T22:41:46Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-23T22:41:46Z"}, "message": "(expand_asm_operands): Handle '+' constraint.\n\nFrom-SVN: r12787", "tree": {"sha": "4842c87c81a55111c240132f32abce2ce0846cce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4842c87c81a55111c240132f32abce2ce0846cce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/235c50216b6e765bf160c7f514d5eb93b9fa863e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235c50216b6e765bf160c7f514d5eb93b9fa863e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/235c50216b6e765bf160c7f514d5eb93b9fa863e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235c50216b6e765bf160c7f514d5eb93b9fa863e/comments", "author": null, "committer": null, "parents": [{"sha": "c1f7febfcb105bd5ceb464576227897245c4ef1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1f7febfcb105bd5ceb464576227897245c4ef1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1f7febfcb105bd5ceb464576227897245c4ef1c"}], "stats": {"total": 45, "additions": 40, "deletions": 5}, "files": [{"sha": "5e4edc5b32b901f0112b161bc71cea71c1a773e1", "filename": "gcc/stmt.c", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235c50216b6e765bf160c7f514d5eb93b9fa863e/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235c50216b6e765bf160c7f514d5eb93b9fa863e/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=235c50216b6e765bf160c7f514d5eb93b9fa863e", "patch": "@@ -1369,11 +1369,15 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   rtx body;\n   int ninputs = list_length (inputs);\n   int noutputs = list_length (outputs);\n+  int ninout = 0;\n   int nclobbers;\n   tree tail;\n   register int i;\n   /* Vector of RTX's of evaluated output operands.  */\n   rtx *output_rtx = (rtx *) alloca (noutputs * sizeof (rtx));\n+  int *inout_opnum = (int *) alloca (noutputs * sizeof (int));\n+  enum machine_mode *inout_mode\n+    = (enum machine_mode *) alloca (noutputs * sizeof (enum machine_mode));\n   /* The insn we have emitted.  */\n   rtx insn;\n \n@@ -1405,6 +1409,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       tree val1;\n       int j;\n       int found_equal = 0;\n+      int found_plus = 0;\n       int allows_reg = 0;\n \n       /* If there's an erroneous arg, emit no insn.  */\n@@ -1420,8 +1425,17 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \tswitch (TREE_STRING_POINTER (TREE_PURPOSE (tail))[j])\n \t  {\n \t  case '+':\n-\t    error (\"output operand constraint contains `+'\");\n-\t    return;\n+\t    /* Make sure we can specify the matching operand.  */\n+\t    if (i >= '0' && i <= '9')\n+\t      {\n+\t\terror (\"output operand constraint %d contains `+'\", i);\n+\t\treturn;\n+\t      }\n+\n+\t    /* Replace '+' with '='.  */\n+\t    TREE_STRING_POINTER (TREE_PURPOSE (tail))[j] = '=';\n+\t    found_plus = 1;\n+\t    break;\n \n \t  case '=':\n \t    found_equal = 1;\n@@ -1450,7 +1464,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t    break;\n \t  }\n \n-      if (! found_equal)\n+      if (! found_equal && ! found_plus)\n \t{\n \t  error (\"output operand constraint lacks `='\");\n \t  return;\n@@ -1465,7 +1479,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  || (TREE_CODE_CLASS (TREE_CODE (val)) == 'd'\n \t      && ! (GET_CODE (DECL_RTL (val)) == REG\n \t\t    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))\n-\t  || ! allows_reg)\n+\t  || ! allows_reg\n+\t  || found_plus)\n \t{\n \t  if (! allows_reg)\n \t    mark_addressable (TREE_VALUE (tail));\n@@ -1481,8 +1496,15 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  output_rtx[i] = assign_temp (type, 0, 0, 0);\n \t  TREE_VALUE (tail) = make_tree (type, output_rtx[i]);\n \t}\n+\n+      if (found_plus)\n+\t{\n+\t  inout_mode[ninout] = TYPE_MODE (TREE_TYPE (TREE_VALUE (tail)));\n+\t  inout_opnum[ninout++] = i;\n+\t}\n     }\n \n+  ninputs += ninout;\n   if (ninputs + noutputs > MAX_RECOG_OPERANDS)\n     {\n       error (\"more than %d operands in `asm'\", MAX_RECOG_OPERANDS);\n@@ -1593,12 +1615,25 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   /* Protect all the operands from the queue,\n      now that they have all been evaluated.  */\n \n-  for (i = 0; i < ninputs; i++)\n+  for (i = 0; i < ninputs - ninout; i++)\n     XVECEXP (body, 3, i) = protect_from_queue (XVECEXP (body, 3, i), 0);\n \n   for (i = 0; i < noutputs; i++)\n     output_rtx[i] = protect_from_queue (output_rtx[i], 1);\n \n+  /* For in-out operands, copy output rtx to input rtx. */\n+  for (i = 0; i < ninout; i++)\n+    {\n+      static char match[9+1][2]\n+\t= {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"};\n+      int j = inout_opnum[i];\n+\n+      XVECEXP (body, 3, ninputs - ninout + i)      /* argvec */\n+\t= output_rtx[j];\n+      XVECEXP (body, 4, ninputs - ninout + i)      /* constraints */\n+\t= gen_rtx (ASM_INPUT, inout_mode[j], match[j]);\n+    }\n+\n   /* Now, for each output, construct an rtx\n      (set OUTPUT (asm_operands INSN OUTPUTNUMBER OUTPUTCONSTRAINT\n \t\t\t       ARGVEC CONSTRAINTS))"}]}