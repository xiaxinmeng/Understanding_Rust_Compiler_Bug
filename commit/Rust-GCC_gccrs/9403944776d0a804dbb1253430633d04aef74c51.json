{"sha": "9403944776d0a804dbb1253430633d04aef74c51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQwMzk0NDc3NmQwYTgwNGRiYjEyNTM0MzA2MzNkMDRhZWY3NGM1MQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-04-04T23:19:09Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-04T23:19:09Z"}, "message": "Use backend interface for return statements.\n\n\t* go-gcc.cc: #include \"tree-iterator.h\", \"gimple.h\", and \"gogo.h\".\n\t(class Bfunction): Define.\n\t(Gcc_backend::assignment_statement): Rename from assignment.\n\tCheck for errors.\n\t(Gcc_backend::return_statement): New function.\n\t(tree_to_function): New function.\n\t* Make-lang.in (go/go-gcc.o): Depend on tree-iterator.h,\n\t$(GIMPLE_H), and $(GO_GOGO_H).\n\nFrom-SVN: r171959", "tree": {"sha": "8d44210d8783d83e459d812c1f0df7bd37abb3c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d44210d8783d83e459d812c1f0df7bd37abb3c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9403944776d0a804dbb1253430633d04aef74c51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9403944776d0a804dbb1253430633d04aef74c51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9403944776d0a804dbb1253430633d04aef74c51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9403944776d0a804dbb1253430633d04aef74c51/comments", "author": null, "committer": null, "parents": [{"sha": "69387b92c18aa7fe8d29aa7788ae838a027b5d48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69387b92c18aa7fe8d29aa7788ae838a027b5d48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69387b92c18aa7fe8d29aa7788ae838a027b5d48"}], "stats": {"total": 543, "additions": 254, "deletions": 289}, "files": [{"sha": "b8a11f6d5d1dca718a477b45ca5e9148267091e3", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -1,3 +1,14 @@\n+2011-04-04  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc: #include \"tree-iterator.h\", \"gimple.h\", and \"gogo.h\".\n+\t(class Bfunction): Define.\n+\t(Gcc_backend::assignment_statement): Rename from assignment.\n+\tCheck for errors.\n+\t(Gcc_backend::return_statement): New function.\n+\t(tree_to_function): New function.\n+\t* Make-lang.in (go/go-gcc.o): Depend on tree-iterator.h,\n+\t$(GIMPLE_H), and $(GO_GOGO_H).\n+\n 2011-04-03  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc: New file."}, {"sha": "67900d7749733901e048b24cc4009007db41ac4f", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -236,7 +236,8 @@ go/go-lang.o: go/go-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(OPTS_H) \\\n \n GOINCLUDES = -I $(srcdir)/go -I $(srcdir)/go/gofrontend\n \n-go/go-gcc.o: go/go-gcc.cc $(GO_SYSTEM_H) $(TREE_H) go/gofrontend/backend.h\n+go/go-gcc.o: go/go-gcc.cc $(GO_SYSTEM_H) $(TREE_H) tree-iterator.h \\\n+\t\t$(GIMPLE_H) $(GO_GOGO_H) go/gofrontend/backend.h\n \t$(CXX) -c $(GOINCLUDES) $(ALL_CPPFLAGS) $(ALL_CXXFLAGS) $< $(OUTPUT_OPTION)\n \n go/%.o: go/gofrontend/%.cc"}, {"sha": "2785bf296dc743b3fa671adbf69fbe8389ba3880", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 90, "deletions": 6, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -30,11 +30,14 @@ extern \"C\"\n #endif\n \n #include \"tree.h\"\n+#include \"tree-iterator.h\"\n+#include \"gimple.h\"\n \n #ifndef ENABLE_BUILD_WITH_CXX\n }\n #endif\n \n+#include \"gogo.h\"\n #include \"backend.h\"\n \n // A class wrapping a tree.\n@@ -79,6 +82,14 @@ class Bstatement : public Gcc_tree\n   { }\n };\n \n+class Bfunction : public Gcc_tree\n+{\n+ public:\n+  Bfunction(tree t)\n+    : Gcc_tree(t)\n+  { }\n+};\n+\n // This file implements the interface between the Go frontend proper\n // and the gcc IR.  This implements specific instantiations of\n // abstract classes defined by the Go frontend proper.  The Go\n@@ -149,8 +160,12 @@ class Gcc_backend : public Backend\n \n   // Create an assignment statement.\n   Bstatement*\n-  assignment(Bexpression* lhs, Bexpression* rhs,\n-\t     source_location location);\n+  assignment_statement(Bexpression* lhs, Bexpression* rhs, source_location);\n+\n+  // Create a return statement.\n+  Bstatement*\n+  return_statement(Bfunction*, const std::vector<Bexpression*>&,\n+\t\t   source_location);\n \n  private:\n   // Make a Bstatement from a tree.\n@@ -162,13 +177,76 @@ class Gcc_backend : public Backend\n // Assignment.\n \n Bstatement*\n-Gcc_backend::assignment(Bexpression* lhs, Bexpression* rhs,\n-\t\t\tsource_location location)\n+Gcc_backend::assignment_statement(Bexpression* lhs, Bexpression* rhs,\n+\t\t\t\t  source_location location)\n {\n+  tree lhs_tree = lhs->get_tree();\n+  tree rhs_tree = rhs->get_tree();\n+  if (lhs_tree == error_mark_node || rhs_tree == error_mark_node)\n+    return this->make_statement(error_mark_node);\n   return this->make_statement(fold_build2_loc(location, MODIFY_EXPR,\n \t\t\t\t\t      void_type_node,\n-\t\t\t\t\t      lhs->get_tree(),\n-\t\t\t\t\t      rhs->get_tree()));\n+\t\t\t\t\t      lhs_tree, rhs_tree));\n+}\n+\n+// Return.\n+\n+Bstatement*\n+Gcc_backend::return_statement(Bfunction* bfunction,\n+\t\t\t      const std::vector<Bexpression*>& vals,\n+\t\t\t      source_location location)\n+{\n+  tree fntree = bfunction->get_tree();\n+  if (fntree == error_mark_node)\n+    return this->make_statement(error_mark_node);\n+  tree result = DECL_RESULT(fntree);\n+  if (result == error_mark_node)\n+    return this->make_statement(error_mark_node);\n+  tree ret;\n+  if (vals.empty())\n+    ret = fold_build1_loc(location, RETURN_EXPR, void_type_node, NULL_TREE);\n+  else if (vals.size() == 1)\n+    {\n+      tree val = vals.front()->get_tree();\n+      if (val == error_mark_node)\n+\treturn this->make_statement(error_mark_node);\n+      tree set = fold_build2_loc(location, MODIFY_EXPR, void_type_node,\n+\t\t\t\t result, vals.front()->get_tree());\n+      ret = fold_build1_loc(location, RETURN_EXPR, void_type_node, set);\n+    }\n+  else\n+    {\n+      // To return multiple values, copy the values into a temporary\n+      // variable of the right structure type, and then assign the\n+      // temporary variable to the DECL_RESULT in the return\n+      // statement.\n+      tree stmt_list = NULL_TREE;\n+      tree rettype = TREE_TYPE(result);\n+      tree rettmp = create_tmp_var(rettype, \"RESULT\");\n+      tree field = TYPE_FIELDS(rettype);\n+      for (std::vector<Bexpression*>::const_iterator p = vals.begin();\n+\t   p != vals.end();\n+\t   p++, field = DECL_CHAIN(field))\n+\t{\n+\t  gcc_assert(field != NULL_TREE);\n+\t  tree ref = fold_build3_loc(location, COMPONENT_REF, TREE_TYPE(field),\n+\t\t\t\t     rettmp, field, NULL_TREE);\n+\t  tree val = (*p)->get_tree();\n+\t  if (val == error_mark_node)\n+\t    return this->make_statement(error_mark_node);\n+\t  tree set = fold_build2_loc(location, MODIFY_EXPR, void_type_node,\n+\t\t\t\t     ref, (*p)->get_tree());\n+\t  append_to_statement_list(set, &stmt_list);\n+\t}\n+      gcc_assert(field == NULL_TREE);\n+      tree set = fold_build2_loc(location, MODIFY_EXPR, void_type_node,\n+\t\t\t\t result, rettmp);\n+      tree ret_expr = fold_build1_loc(location, RETURN_EXPR, void_type_node,\n+\t\t\t\t      set);\n+      append_to_statement_list(ret_expr, &stmt_list);\n+      ret = stmt_list;\n+    }\n+  return this->make_statement(ret);\n }\n \n // The single backend.\n@@ -192,6 +270,12 @@ tree_to_expr(tree t)\n   return new Bexpression(t);\n }\n \n+Bfunction*\n+tree_to_function(tree t)\n+{\n+  return new Bfunction(t);\n+}\n+\n tree\n statement_to_tree(Bstatement* bs)\n {"}, {"sha": "959fc7862c061bf178567e26b49c51010f852afb", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -24,6 +24,9 @@ class Bexpression;\n // The backend representation of a statement.\n class Bstatement;\n \n+// The backend representation of a function definition.\n+class Bfunction;\n+\n // A list of backend types.\n typedef std::vector<Btype*> Btypes;\n \n@@ -103,7 +106,14 @@ class Backend\n \n   // Create an assignment statement.\n   virtual Bstatement*\n-  assignment(Bexpression* lhs, Bexpression* rhs, source_location location) = 0;\n+  assignment_statement(Bexpression* lhs, Bexpression* rhs,\n+\t\t       source_location) = 0;\n+\n+  // Create a return statement, passing the representation of the\n+  // function and the list of values to return.\n+  virtual Bstatement*\n+  return_statement(Bfunction*, const std::vector<Bexpression*>&,\n+\t\t   source_location) = 0;\n };\n \n // The backend interface has to define this function.\n@@ -114,6 +124,7 @@ extern Backend* go_get_backend();\n // interface.\n \n extern Bexpression* tree_to_expr(tree);\n+extern Bfunction* tree_to_function(tree);\n extern tree statement_to_tree(Bstatement*);\n \n #endif // !defined(GO_BACKEND_H)"}, {"sha": "a0cfcfcdf7452f55d77e240f7b6fc2ef59508fd4", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -10415,8 +10415,7 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n \t  for (size_t i = 0; i < count; ++i)\n \t    retvals->push_back(Expression::make_call_result(call, i));\n \t}\n-      s = Statement::make_return_statement(no->func_value()->type()->results(),\n-\t\t\t\t\t   retvals, location);\n+      s = Statement::make_return_statement(retvals, location);\n     }\n   gogo->add_statement(s);\n "}, {"sha": "bd5945bd7ba6072c98f55643cca282263677c41c", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -1761,27 +1761,16 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n   if (results == NULL || results->empty())\n     return NULL_TREE;\n \n-  // In the case of an exception handler created for functions with\n-  // defer statements, the result variables may be unnamed.\n-  bool is_named = !results->front().name().empty();\n-  if (is_named)\n+  gcc_assert(this->results_ != NULL);\n+  if (this->results_->size() != results->size())\n     {\n-      gcc_assert(this->named_results_ != NULL);\n-      if (this->named_results_->size() != results->size())\n-\t{\n-\t  gcc_assert(saw_errors());\n-\t  return error_mark_node;\n-\t}\n+      gcc_assert(saw_errors());\n+      return error_mark_node;\n     }\n \n   tree retval;\n   if (results->size() == 1)\n-    {\n-      if (is_named)\n-\treturn this->named_results_->front()->get_tree(gogo, named_function);\n-      else\n-\treturn results->front().type()->get_init_tree(gogo, false);\n-    }\n+    return this->results_->front()->get_tree(gogo, named_function);\n   else\n     {\n       tree rettype = TREE_TYPE(DECL_RESULT(this->fndecl_));\n@@ -1794,11 +1783,7 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n \t{\n \t  gcc_assert(field != NULL);\n \t  tree val;\n-\t  if (is_named)\n-\t    val = (*this->named_results_)[index]->get_tree(gogo,\n-\t\t\t\t\t\t\t   named_function);\n-\t  else\n-\t    val = pr->type()->get_init_tree(gogo, false);\n+\t  val = (*this->results_)[index]->get_tree(gogo, named_function);\n \t  tree set = fold_build2_loc(location, MODIFY_EXPR, void_type_node,\n \t\t\t\t     build3(COMPONENT_REF, TREE_TYPE(field),\n \t\t\t\t\t    retval, field, NULL_TREE),"}, {"sha": "5b3ac8cd9c28f9455c4fcf5d6119a2fb440d1031", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -642,7 +642,7 @@ Gogo::start_function(const std::string& name, Function_type* type,\n \t}\n     }\n \n-  function->create_named_result_variables(this);\n+  function->create_result_variables(this);\n \n   const std::string* pname;\n   std::string nested_name;\n@@ -2195,8 +2195,7 @@ Build_recover_thunks::function(Named_object* orig_no)\n \t  for (size_t i = 0; i < rc; ++i)\n \t    vals->push_back(Expression::make_call_result(call, i));\n \t}\n-      s = Statement::make_return_statement(new_func->type()->results(),\n-\t\t\t\t\t   vals, location);\n+      s = Statement::make_return_statement(vals, location);\n     }\n   s->determine_types();\n   gogo->add_statement(s);\n@@ -2252,8 +2251,8 @@ Build_recover_thunks::function(Named_object* orig_no)\n   new_func->traverse(&convert_recover);\n \n   // Update the function pointers in any named results.\n-  new_func->update_named_result_variables();\n-  orig_func->update_named_result_variables();\n+  new_func->update_result_variables();\n+  orig_func->update_result_variables();\n \n   return TRAVERSE_CONTINUE;\n }\n@@ -2619,26 +2618,27 @@ Gogo::convert_named_types_in_bindings(Bindings* bindings)\n \n Function::Function(Function_type* type, Function* enclosing, Block* block,\n \t\t   source_location location)\n-  : type_(type), enclosing_(enclosing), named_results_(NULL),\n+  : type_(type), enclosing_(enclosing), results_(NULL),\n     closure_var_(NULL), block_(block), location_(location), fndecl_(NULL),\n-    defer_stack_(NULL), calls_recover_(false), is_recover_thunk_(false),\n-    has_recover_thunk_(false)\n+    defer_stack_(NULL), results_are_named_(false), calls_recover_(false),\n+    is_recover_thunk_(false), has_recover_thunk_(false)\n {\n }\n \n // Create the named result variables.\n \n void\n-Function::create_named_result_variables(Gogo* gogo)\n+Function::create_result_variables(Gogo* gogo)\n {\n   const Typed_identifier_list* results = this->type_->results();\n-  if (results == NULL\n-      || results->empty()\n-      || results->front().name().empty())\n+  if (results == NULL || results->empty())\n     return;\n \n-  this->named_results_ = new Named_results();\n-  this->named_results_->reserve(results->size());\n+  if (!results->front().name().empty())\n+    this->results_are_named_ = true;\n+\n+  this->results_ = new Results();\n+  this->results_->reserve(results->size());\n \n   Block* block = this->block_;\n   int index = 0;\n@@ -2647,32 +2647,43 @@ Function::create_named_result_variables(Gogo* gogo)\n        ++p, ++index)\n     {\n       std::string name = p->name();\n-      if (Gogo::is_sink_name(name))\n+      if (name.empty() || Gogo::is_sink_name(name))\n \t{\n-\t  static int unnamed_result_counter;\n+\t  static int result_counter;\n \t  char buf[100];\n-\t  snprintf(buf, sizeof buf, \"_$%d\", unnamed_result_counter);\n-\t  ++unnamed_result_counter;\n+\t  snprintf(buf, sizeof buf, \"$ret%d\", result_counter);\n+\t  ++result_counter;\n \t  name = gogo->pack_hidden_name(buf, false);\n \t}\n       Result_variable* result = new Result_variable(p->type(), this, index);\n       Named_object* no = block->bindings()->add_result_variable(name, result);\n       if (no->is_result_variable())\n-\tthis->named_results_->push_back(no);\n+\tthis->results_->push_back(no);\n+      else\n+\t{\n+\t  static int dummy_result_count;\n+\t  char buf[100];\n+\t  snprintf(buf, sizeof buf, \"$dret%d\", dummy_result_count);\n+\t  ++dummy_result_count;\n+\t  name = gogo->pack_hidden_name(buf, false);\n+\t  no = block->bindings()->add_result_variable(name, result);\n+\t  gcc_assert(no->is_result_variable());\n+\t  this->results_->push_back(no);\n+\t}\n     }\n }\n \n // Update the named result variables when cloning a function which\n // calls recover.\n \n void\n-Function::update_named_result_variables()\n+Function::update_result_variables()\n {\n-  if (this->named_results_ == NULL)\n+  if (this->results_ == NULL)\n     return;\n \n-  for (Named_results::iterator p = this->named_results_->begin();\n-       p != this->named_results_->end();\n+  for (Results::iterator p = this->results_->begin();\n+       p != this->results_->end();\n        ++p)\n     (*p)->result_var_value()->set_function(this);\n }\n@@ -2819,7 +2830,7 @@ void\n Function::swap_for_recover(Function *x)\n {\n   gcc_assert(this->enclosing_ == x->enclosing_);\n-  std::swap(this->named_results_, x->named_results_);\n+  std::swap(this->results_, x->results_);\n   std::swap(this->closure_var_, x->closure_var_);\n   std::swap(this->block_, x->block_);\n   gcc_assert(this->location_ == x->location_);"}, {"sha": "87e2da6890b5a5c556e5cf69001c7e25dc878db1", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -822,14 +822,27 @@ class Function\n     this->enclosing_ = enclosing;\n   }\n \n-  // Create the named result variables in the outer block.\n+  // The result variables.\n+  typedef std::vector<Named_object*> Results;\n+\n+  // Create the result variables in the outer block.\n   void\n-  create_named_result_variables(Gogo*);\n+  create_result_variables(Gogo*);\n \n   // Update the named result variables when cloning a function which\n   // calls recover.\n   void\n-  update_named_result_variables();\n+  update_result_variables();\n+\n+  // Return the result variables.\n+  Results*\n+  result_variables()\n+  { return this->results_; }\n+\n+  // Whether the result variables have names.\n+  bool\n+  results_are_named() const\n+  { return this->results_are_named_; }\n \n   // Add a new field to the closure variable.\n   void\n@@ -992,8 +1005,6 @@ class Function\n   void\n   build_defer_wrapper(Gogo*, Named_object*, tree*, tree*);\n \n-  typedef std::vector<Named_object*> Named_results;\n-\n   typedef std::vector<std::pair<Named_object*,\n \t\t\t\tsource_location> > Closure_fields;\n \n@@ -1002,8 +1013,8 @@ class Function\n   // The enclosing function.  This is NULL when there isn't one, which\n   // is the normal case.\n   Function* enclosing_;\n-  // The named result variables, if any.\n-  Named_results* named_results_;\n+  // The result variables, if any.\n+  Results* results_;\n   // If there is a closure, this is the list of variables which appear\n   // in the closure.  This is created by the parser, and then resolved\n   // to a real type when we lower parse trees.\n@@ -1022,6 +1033,8 @@ class Function\n   // A variable holding the defer stack variable.  This is NULL unless\n   // we actually need a defer stack.\n   tree defer_stack_;\n+  // True if the result variables are named.\n+  bool results_are_named_;\n   // True if this function calls the predeclared recover function.\n   bool calls_recover_;\n   // True if this a thunk built for a function which calls recover."}, {"sha": "e5ea636b08aa1078753a961c7f2e4078b07d6636", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -3732,10 +3732,7 @@ Parse::return_stat()\n   Expression_list* vals = NULL;\n   if (this->expression_may_start_here())\n     vals = this->expression_list(NULL, false);\n-  const Function* function = this->gogo_->current_function()->func_value();\n-  const Typed_identifier_list* results = function->type()->results();\n-  this->gogo_->add_statement(Statement::make_return_statement(results, vals,\n-\t\t\t\t\t\t\t      location));\n+  this->gogo_->add_statement(Statement::make_return_statement(vals, location));\n }\n \n // IfStmt    = \"if\" [ SimpleStmt \";\" ] Expression Block [ \"else\" Statement ] ."}, {"sha": "3783fb83a519b3b52c89b120d78110e836c2aef3", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 70, "deletions": 204, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -561,9 +561,10 @@ Assignment_statement::do_get_tree(Translate_context* context)\n   if (rhs_tree == error_mark_node)\n     return error_mark_node;\n \n-  Bstatement* ret = context->backend()->assignment(tree_to_expr(lhs_tree),\n-\t\t\t\t\t\t   tree_to_expr(rhs_tree),\n-\t\t\t\t\t\t   this->location());\n+  Bstatement* ret;\n+  ret = context->backend()->assignment_statement(tree_to_expr(lhs_tree),\n+\t\t\t\t\t\t tree_to_expr(rhs_tree),\n+\t\t\t\t\t\t this->location());\n   return statement_to_tree(ret);\n }\n \n@@ -2289,10 +2290,7 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name,\n \n       Expression_list* vals = new Expression_list();\n       vals->push_back(Expression::make_boolean(false, location));\n-      const Typed_identifier_list* results =\n-\tfunction->func_value()->type()->results();\n-      gogo->add_statement(Statement::make_return_statement(results, vals,\n-\t\t\t\t\t\t\t  location));\n+      gogo->add_statement(Statement::make_return_statement(vals, location));\n     }\n \n   // That is all the thunk has to do.\n@@ -2442,69 +2440,76 @@ Return_statement::do_traverse_assignments(Traverse_assignments* tassign)\n // panic/recover work correctly.\n \n Statement*\n-Return_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n+Return_statement::do_lower(Gogo*, Named_object* function, Block* enclosing)\n {\n-  if (this->vals_ == NULL)\n+  if (this->is_lowered_)\n     return this;\n \n-  const Typed_identifier_list* results = this->results_;\n-  if (results == NULL || results->empty())\n-    return this;\n+  Expression_list* vals = this->vals_;\n+  this->vals_ = NULL;\n+  this->is_lowered_ = true;\n+\n+  source_location loc = this->location();\n+\n+  size_t vals_count = vals == NULL ? 0 : vals->size();\n+  Function::Results* results = function->func_value()->result_variables();\n+  size_t results_count = results == NULL ? 0 : results->size();\n+\n+  if (vals_count == 0)\n+    {\n+      if (results_count > 0 && !function->func_value()->results_are_named())\n+\t{\n+\t  this->report_error(_(\"not enough arguments to return\"));\n+\t  return this;\n+\t}\n+      return this;\n+    }\n+\n+  if (results_count == 0)\n+    {\n+      this->report_error(_(\"return with value in function \"\n+\t\t\t   \"with no return type\"));\n+      return this;\n+    }\n \n   // If the current function has multiple return values, and we are\n   // returning a single call expression, split up the call expression.\n-  size_t results_count = results->size();\n   if (results_count > 1\n-      && this->vals_->size() == 1\n-      && this->vals_->front()->call_expression() != NULL)\n+      && vals->size() == 1\n+      && vals->front()->call_expression() != NULL)\n     {\n-      Call_expression* call = this->vals_->front()->call_expression();\n-      size_t count = results->size();\n-      Expression_list* vals = new Expression_list;\n-      for (size_t i = 0; i < count; ++i)\n+      Call_expression* call = vals->front()->call_expression();\n+      delete vals;\n+      vals = new Expression_list;\n+      for (size_t i = 0; i < results_count; ++i)\n \tvals->push_back(Expression::make_call_result(call, i));\n-      delete this->vals_;\n-      this->vals_ = vals;\n+      vals_count = results_count;\n     }\n \n-  if (results->front().name().empty())\n-    return this;\n-\n-  if (results_count != this->vals_->size())\n+  if (vals_count < results_count)\n     {\n-      // Presumably an error which will be reported in check_types.\n+      this->report_error(_(\"not enough arguments to return\"));\n       return this;\n     }\n \n-  // Assign to named return values and then return them.\n-\n-  source_location loc = this->location();\n-  const Block* top = enclosing;\n-  while (top->enclosing() != NULL)\n-    top = top->enclosing();\n+  if (vals_count > results_count)\n+    {\n+      this->report_error(_(\"too many values in return statement\"));\n+      return this;\n+    }\n \n-  const Bindings *bindings = top->bindings();\n   Block* b = new Block(enclosing, loc);\n \n   Expression_list* lhs = new Expression_list();\n   Expression_list* rhs = new Expression_list();\n \n-  Expression_list::const_iterator pe = this->vals_->begin();\n+  Expression_list::const_iterator pe = vals->begin();\n   int i = 1;\n-  for (Typed_identifier_list::const_iterator pr = results->begin();\n+  for (Function::Results::const_iterator pr = results->begin();\n        pr != results->end();\n        ++pr, ++pe, ++i)\n     {\n-      Named_object* rv = bindings->lookup_local(pr->name());\n-      if (rv == NULL || !rv->is_result_variable())\n-\t{\n-\t  // Presumably an error.\n-\t  delete b;\n-\t  delete lhs;\n-\t  delete rhs;\n-\t  return this;\n-\t}\n-\n+      Named_object* rv = *pr;\n       Expression* e = *pe;\n \n       // Check types now so that we give a good error message.  The\n@@ -2546,187 +2551,48 @@ Return_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n   else\n     b->add_statement(Statement::make_tuple_assignment(lhs, rhs, loc));\n \n-  b->add_statement(Statement::make_return_statement(this->results_, NULL,\n-\t\t\t\t\t\t    loc));\n-\n-  return Statement::make_block_statement(b, loc);\n-}\n-\n-// Determine types.\n-\n-void\n-Return_statement::do_determine_types()\n-{\n-  if (this->vals_ == NULL)\n-    return;\n-  const Typed_identifier_list* results = this->results_;\n-\n-  Typed_identifier_list::const_iterator pt;\n-  if (results != NULL)\n-    pt = results->begin();\n-  for (Expression_list::iterator pe = this->vals_->begin();\n-       pe != this->vals_->end();\n-       ++pe)\n-    {\n-      if (results == NULL || pt == results->end())\n-\t(*pe)->determine_type_no_context();\n-      else\n-\t{\n-\t  Type_context context(pt->type(), false);\n-\t  (*pe)->determine_type(&context);\n-\t  ++pt;\n-\t}\n-    }\n-}\n-\n-// Check types.\n+  b->add_statement(this);\n \n-void\n-Return_statement::do_check_types(Gogo*)\n-{\n-  const Typed_identifier_list* results = this->results_;\n-  if (this->vals_ == NULL)\n-    {\n-      if (results != NULL\n-\t  && !results->empty()\n-\t  && results->front().name().empty())\n-\t{\n-\t  // The result parameters are not named, which means that we\n-\t  // need to supply values for them.\n-\t  this->report_error(_(\"not enough arguments to return\"));\n-\t}\n-      return;\n-    }\n+  delete vals;\n \n-  if (results == NULL)\n-    {\n-      this->report_error(_(\"return with value in function \"\n-\t\t\t   \"with no return type\"));\n-      return;\n-    }\n-\n-  int i = 1;\n-  Typed_identifier_list::const_iterator pt = results->begin();\n-  for (Expression_list::const_iterator pe = this->vals_->begin();\n-       pe != this->vals_->end();\n-       ++pe, ++pt, ++i)\n-    {\n-      if (pt == results->end())\n-\t{\n-\t  this->report_error(_(\"too many values in return statement\"));\n-\t  return;\n-\t}\n-      std::string reason;\n-      if (!Type::are_assignable(pt->type(), (*pe)->type(), &reason))\n-\t{\n-\t  if (reason.empty())\n-\t    error_at(this->location(),\n-\t\t     \"incompatible type for return value %d\",\n-\t\t     i);\n-\t  else\n-\t    error_at(this->location(),\n-\t\t     \"incompatible type for return value %d (%s)\",\n-\t\t     i, reason.c_str());\n-\t  this->set_is_error();\n-\t}\n-      else if (pt->type()->is_error() || (*pe)->type()->is_error())\n-\tthis->set_is_error();\n-    }\n-\n-  if (pt != results->end())\n-    this->report_error(_(\"not enough arguments to return\"));\n+  return Statement::make_block_statement(b, loc);\n }\n \n-// Build a RETURN_EXPR tree.\n+// Convert a return statement to the backend representation.\n \n tree\n Return_statement::do_get_tree(Translate_context* context)\n {\n   Function* function = context->function()->func_value();\n   tree fndecl = function->get_decl();\n-  if (fndecl == error_mark_node || DECL_RESULT(fndecl) == error_mark_node)\n-    return error_mark_node;\n-\n-  const Typed_identifier_list* results = this->results_;\n \n-  if (this->vals_ == NULL)\n-    {\n-      tree stmt_list = NULL_TREE;\n-      tree retval = function->return_value(context->gogo(),\n-\t\t\t\t\t   context->function(),\n-\t\t\t\t\t   this->location(),\n-\t\t\t\t\t   &stmt_list);\n-      tree set;\n-      if (retval == NULL_TREE)\n-\tset = NULL_TREE;\n-      else if (retval == error_mark_node)\n-\treturn error_mark_node;\n-      else\n-\tset = fold_build2_loc(this->location(), MODIFY_EXPR, void_type_node,\n-\t\t\t      DECL_RESULT(fndecl), retval);\n-      append_to_statement_list(this->build_stmt_1(RETURN_EXPR, set),\n-\t\t\t       &stmt_list);\n-      return stmt_list;\n-    }\n-  else if (this->vals_->size() == 1)\n-    {\n-      gcc_assert(!VOID_TYPE_P(TREE_TYPE(TREE_TYPE(fndecl))));\n-      tree val = (*this->vals_->begin())->get_tree(context);\n-      gcc_assert(results != NULL && results->size() == 1);\n-      val = Expression::convert_for_assignment(context,\n-\t\t\t\t\t       results->begin()->type(),\n-\t\t\t\t\t       (*this->vals_->begin())->type(),\n-\t\t\t\t\t       val, this->location());\n-      if (val == error_mark_node)\n-\treturn error_mark_node;\n-      tree set = build2(MODIFY_EXPR, void_type_node,\n-\t\t\tDECL_RESULT(fndecl), val);\n-      SET_EXPR_LOCATION(set, this->location());\n-      return this->build_stmt_1(RETURN_EXPR, set);\n-    }\n-  else\n+  Function::Results* results = function->result_variables();\n+  std::vector<Bexpression*> retvals;\n+  if (results != NULL && !results->empty())\n     {\n-      gcc_assert(!VOID_TYPE_P(TREE_TYPE(TREE_TYPE(fndecl))));\n-      tree stmt_list = NULL_TREE;\n-      tree rettype = TREE_TYPE(DECL_RESULT(fndecl));\n-      tree retvar = create_tmp_var(rettype, \"RESULT\");\n-      gcc_assert(results != NULL && results->size() == this->vals_->size());\n-      Expression_list::const_iterator pv = this->vals_->begin();\n-      Typed_identifier_list::const_iterator pr = results->begin();\n-      for (tree field = TYPE_FIELDS(rettype);\n-\t   field != NULL_TREE;\n-\t   ++pv, ++pr, field = DECL_CHAIN(field))\n+      retvals.reserve(results->size());\n+      for (Function::Results::const_iterator p = results->begin();\n+\t   p != results->end();\n+\t   p++)\n \t{\n-\t  gcc_assert(pv != this->vals_->end());\n-\t  tree val = (*pv)->get_tree(context);\n-\t  val = Expression::convert_for_assignment(context, pr->type(),\n-\t\t\t\t\t\t   (*pv)->type(), val,\n-\t\t\t\t\t\t   this->location());\n-\t  if (val == error_mark_node)\n-\t    return error_mark_node;\n-\t  tree set = build2(MODIFY_EXPR, void_type_node,\n-\t\t\t    build3(COMPONENT_REF, TREE_TYPE(field),\n-\t\t\t\t   retvar, field, NULL_TREE),\n-\t\t\t    val);\n-\t  SET_EXPR_LOCATION(set, this->location());\n-\t  append_to_statement_list(set, &stmt_list);\n+\t  tree rv = (*p)->get_tree(context->gogo(), context->function());\n+\t  retvals.push_back(tree_to_expr(rv));\n \t}\n-      tree set = build2(MODIFY_EXPR, void_type_node, DECL_RESULT(fndecl),\n-\t\t\tretvar);\n-      append_to_statement_list(this->build_stmt_1(RETURN_EXPR, set),\n-\t\t\t       &stmt_list);\n-      return stmt_list;\n     }\n+\n+  Bstatement* ret;\n+  ret = context->backend()->return_statement(tree_to_function(fndecl),\n+\t\t\t\t\t     retvals, this->location());\n+  return statement_to_tree(ret);\n }\n \n // Make a return statement.\n \n Statement*\n-Statement::make_return_statement(const Typed_identifier_list* results,\n-\t\t\t\t Expression_list* vals,\n+Statement::make_return_statement(Expression_list* vals,\n \t\t\t\t source_location location)\n {\n-  return new Return_statement(results, vals, location);\n+  return new Return_statement(vals, location);\n }\n \n // A break or continue statement."}, {"sha": "986d72b8780e0c0d34d900111d5e07c3aba587a1", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -200,8 +200,7 @@ class Statement\n \n   // Make a return statement.\n   static Statement*\n-  make_return_statement(const Typed_identifier_list*, Expression_list*,\n-\t\t\tsource_location);\n+  make_return_statement(Expression_list*, source_location);\n \n   // Make a break statement.\n   static Statement*\n@@ -556,10 +555,9 @@ class Variable_declaration_statement : public Statement\n class Return_statement : public Statement\n {\n  public:\n-  Return_statement(const Typed_identifier_list* results, Expression_list* vals,\n-\t\t   source_location location)\n+  Return_statement(Expression_list* vals, source_location location)\n     : Statement(STATEMENT_RETURN, location),\n-      results_(results), vals_(vals)\n+      vals_(vals), is_lowered_(false)\n   { }\n \n   // The list of values being returned.  This may be NULL.\n@@ -578,12 +576,6 @@ class Return_statement : public Statement\n   Statement*\n   do_lower(Gogo*, Named_object*, Block*);\n \n-  void\n-  do_determine_types();\n-\n-  void\n-  do_check_types(Gogo*);\n-\n   bool\n   do_may_fall_through() const\n   { return false; }\n@@ -592,12 +584,10 @@ class Return_statement : public Statement\n   do_get_tree(Translate_context*);\n \n  private:\n-  // The result types of the function we are returning from.  This is\n-  // here because in some of the traversals it is inconvenient to get\n-  // it.\n-  const Typed_identifier_list* results_;\n   // Return values.  This may be NULL.\n   Expression_list* vals_;\n+  // True if this statement has been lowered.\n+  bool is_lowered_;\n };\n \n // A send statement."}, {"sha": "1143376e4b37d1bdc80ede71e0a02e1071780ae7", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403944776d0a804dbb1253430633d04aef74c51/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=9403944776d0a804dbb1253430633d04aef74c51", "patch": "@@ -7924,10 +7924,7 @@ Type::build_one_stub_method(Gogo* gogo, Method* method,\n \t  for (size_t i = 0; i < count; ++i)\n \t    retvals->push_back(Expression::make_call_result(call, i));\n \t}\n-      const Function* function = gogo->current_function()->func_value();\n-      const Typed_identifier_list* results = function->type()->results();\n-      Statement* retstat = Statement::make_return_statement(results, retvals,\n-\t\t\t\t\t\t\t    location);\n+      Statement* retstat = Statement::make_return_statement(retvals, location);\n       gogo->add_statement(retstat);\n     }\n }"}]}