{"sha": "5c5e108f9bc25c1a4043e402d6c9adf6d9405e31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM1ZTEwOGY5YmMyNWMxYTQwNDNlNDAyZDZjOWFkZjZkOTQwNWUzMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T11:55:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T11:55:37Z"}, "message": "[multiple changes]\n\n2014-11-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Do not apply\n\tinlining expansion if function build in place, i.e. has a limited\n\treturn type.\n\n2014-11-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Refined_Depends_In_Decl_Part): Add\n\tvariables Body_Id, Body_Inputs, Body_Outputs, Spec_Inputs,\n\tSpec_Outputs. Synthesize the inputs and outputs of the subprogram\n\twhen pragma [Refined_]Global is missing and perform legality\n\tchecks on output states with visible refinement.\n\t(Appears_In): Update the comment on usage.\n\t(Check_Output_States): New routine.\n\t(Collect_Dependency_Clause): New routine.\n\t(Collect_Global_Items): Relocated to\n\tAnalyze_Refined_Global_In_Decl_Part.\n\t(Collect_Subprogram_Inputs_Outputs): Add new formal parameters\n\tSynthesize and Depends_Seen. The routine can now synthesize inputs\n\tand outputs from pragma [Refined_]Depends.\n\t(Normalize_Clause): Update the comment on usage. The routine no longer\n\tperforms normalization of outputs.\n\t(Normalize_Clauses): Normalize both inputs and outputs.\n\t(Normalize_Output): Relocated to Normalize_Clauses.\n\t* sem_prag.ads (Collect_Subprogram_Inputs_Outputs): Add new\n\tformal parameters Synthesize and Depends_Seen and update the\n\tcomment on usage.\n\n2014-11-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Reset_Loop_Variable): New subsidiary procedure\n\tin Build_Predicate_Functions, to handle properly quantified\n\texpressions in dynamic predicates.\n\nFrom-SVN: r217850", "tree": {"sha": "d441d9be32e70f549063623cf981eeef747e73da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d441d9be32e70f549063623cf981eeef747e73da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31/comments", "author": null, "committer": null, "parents": [{"sha": "bfe25016e3146d7d6d11c1d378dc00507ab0b8c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe25016e3146d7d6d11c1d378dc00507ab0b8c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfe25016e3146d7d6d11c1d378dc00507ab0b8c6"}], "stats": {"total": 858, "additions": 582, "deletions": 276}, "files": [{"sha": "f24e4fd26b9880bc738ccbaf9cebb6f4bf98273c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5c5e108f9bc25c1a4043e402d6c9adf6d9405e31", "patch": "@@ -1,3 +1,44 @@\n+2014-11-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Do not apply\n+\tinlining expansion if function build in place, i.e. has a limited\n+\treturn type.\n+\n+2014-11-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Refined_Depends_In_Decl_Part): Add\n+\tvariables Body_Id, Body_Inputs, Body_Outputs, Spec_Inputs,\n+\tSpec_Outputs. Synthesize the inputs and outputs of the subprogram\n+\twhen pragma [Refined_]Global is missing and perform legality\n+\tchecks on output states with visible refinement.\n+\t(Appears_In): Update the comment on usage.\n+\t(Check_Output_States): New routine.\n+\t(Collect_Dependency_Clause): New routine.\n+\t(Collect_Global_Items): Relocated to\n+\tAnalyze_Refined_Global_In_Decl_Part.\n+\t(Collect_Subprogram_Inputs_Outputs): Add new formal parameters\n+\tSynthesize and Depends_Seen. The routine can now synthesize inputs\n+\tand outputs from pragma [Refined_]Depends.\n+\t(Normalize_Clause): Update the comment on usage. The routine no longer\n+\tperforms normalization of outputs.\n+\t(Normalize_Clauses): Normalize both inputs and outputs.\n+\t(Normalize_Output): Relocated to Normalize_Clauses.\n+\t* sem_prag.ads (Collect_Subprogram_Inputs_Outputs): Add new\n+\tformal parameters Synthesize and Depends_Seen and update the\n+\tcomment on usage.\n+\n+2014-11-20  Vincent Celier  <celier@adacore.com>\n+\n+\tPR ada/47500\n+\t* back_end.adb (Scan_Back_End_Switches): Skip switch -G and\n+\tits argument.\n+\n+2014-11-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Reset_Loop_Variable): New subsidiary procedure\n+\tin Build_Predicate_Functions, to handle properly quantified\n+\texpressions in dynamic predicates.\n+\n 2014-11-20  Robert Dewar  <dewar@adacore.com>\n \n \t* gnatcmd.adb, sem_ch6.adb, exp_dist.adb: Minor reformatting."}, {"sha": "fe358b30b78814e3cd9211c81093040e9ddb51f9", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=5c5e108f9bc25c1a4043e402d6c9adf6d9405e31", "patch": "@@ -2853,6 +2853,7 @@ package body Sem_Ch13 is\n                begin\n                   if A_Id = Aspect_Pre or else A_Id = Aspect_Precondition then\n                      Pname := Name_Precondition;\n+\n                   else\n                      Pname := Name_Postcondition;\n                   end if;\n@@ -2925,6 +2926,7 @@ package body Sem_Ch13 is\n                   --  with delay of visibility for the expression analysis.\n \n                   Insert_Pragma (Aitem);\n+\n                   goto Continue;\n                end Pre_Post;\n \n@@ -3552,7 +3554,7 @@ package body Sem_Ch13 is\n             --  the type of the formal match.\n \n             if Base_Type (Typ) /= Base_Type (Ent)\n-              or else Present ((Next_Formal (F)))\n+              or else Present (Next_Formal (F))\n             then\n                return False;\n \n@@ -3630,7 +3632,8 @@ package body Sem_Ch13 is\n                Error_Msg_N (\"stream subprogram must not be abstract\", Expr);\n                return;\n \n-            --  Test for stream subprogram for interface type being non-null\n+            --  A stream subprogram for an interface type must be a null\n+            --  procedure (RM 13.13.2 (38/3)).\n \n             elsif Is_Interface (U_Ent)\n               and then not Inside_A_Generic\n@@ -8268,11 +8271,44 @@ package body Sem_Ch13 is\n \n          if Raise_Expression_Present then\n             declare\n-               Map : constant Elist_Id := New_Elmt_List;\n+               Map   : constant Elist_Id := New_Elmt_List;\n+               New_V : Entity_Id := Empty;\n+\n+               --  The unanalyzed expression will be copied and appear in\n+               --  both functions. Normally expressions do not declare new\n+               --  entities, but quantified expressions do, so we need to\n+               --  create new entities for their bound variables, to prevent\n+               --  multiple definitions in gigi.\n+\n+               function Reset_Loop_Variable (N : Node_Id)\n+                 return Traverse_Result;\n+\n+               procedure Collect_Loop_Variables is\n+                 new Traverse_Proc (Reset_Loop_Variable);\n+\n+               ------------------------\n+               -- Reset_Loop_Variable --\n+               ------------------------\n+\n+               function Reset_Loop_Variable (N : Node_Id)\n+                 return Traverse_Result\n+               is\n+               begin\n+                  if Nkind (N) = N_Iterator_Specification then\n+                     New_V := Make_Defining_Identifier\n+                       (Sloc (N), Chars (Defining_Identifier (N)));\n+\n+                     Set_Defining_Identifier (N, New_V);\n+                  end if;\n+\n+                  return OK;\n+               end Reset_Loop_Variable;\n+\n             begin\n                Append_Elmt (Object_Entity, Map);\n                Append_Elmt (Object_Entity_M, Map);\n                Expr_M := New_Copy_Tree (Expr, Map => Map);\n+               Collect_Loop_Variables (Expr_M);\n             end;\n          end if;\n "}, {"sha": "d0c1f9e897290cbf26ef97324b57da6ba51b5d10", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=5c5e108f9bc25c1a4043e402d6c9adf6d9405e31", "patch": "@@ -3691,6 +3691,11 @@ package body Sem_Ch6 is\n                if Comes_From_Source (Body_Id)\n                  and then Ekind (Spec_Id) = E_Function\n                  and then Returns_Unconstrained_Type (Spec_Id)\n+\n+                 --  If function builds in place, i.e. returns a limited type,\n+                 --  inlining cannot be done.\n+\n+                 and then not Is_Limited_Type (Etype (Spec_Id))\n                then\n                   Check_And_Split_Unconstrained_Function (N, Spec_Id, Body_Id);\n "}, {"sha": "aed0d21cde1bb358ccc5735480e924cae01e1f97", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 485, "deletions": 268, "changes": 753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5c5e108f9bc25c1a4043e402d6c9adf6d9405e31", "patch": "@@ -178,9 +178,9 @@ package body Sem_Prag is\n    --  casing is constructed.\n \n    function Appears_In (List : Elist_Id; Item_Id : Entity_Id) return Boolean;\n-   --  Subsidiary to the analysis of pragma Global and pragma Depends. Query\n-   --  whether a particular item appears in a mixed list of nodes and entities.\n-   --  It is assumed that all nodes in the list have entities.\n+   --  Subsidiary to analysis of pragmas Depends, Global and Refined_Depends.\n+   --  Query whether a particular item appears in a mixed list of nodes and\n+   --  entities. It is assumed that all nodes in the list have entities.\n \n    function Check_Kind (Nam : Name_Id) return Name_Id;\n    --  This function is used in connection with pragmas Assert, Check,\n@@ -216,25 +216,6 @@ package body Sem_Prag is\n    --  corresponding constituent from list Constits (if any) appear in the same\n    --  context denoted by Context. If this is the case, emit an error.\n \n-   procedure Collect_Global_Items\n-     (Prag               : Node_Id;\n-      In_Items           : in out Elist_Id;\n-      In_Out_Items       : in out Elist_Id;\n-      Out_Items          : in out Elist_Id;\n-      Proof_In_Items     : in out Elist_Id;\n-      Has_In_State       : out Boolean;\n-      Has_In_Out_State   : out Boolean;\n-      Has_Out_State      : out Boolean;\n-      Has_Proof_In_State : out Boolean;\n-      Has_Null_State     : out Boolean);\n-   --  Subsidiary to the analysis of pragma Refined_Depends/Refined_Global.\n-   --  Prag denotes pragma [Refined_]Global. Gather all input, in out, output\n-   --  and Proof_In items of Prag in lists In_Items, In_Out_Items, Out_Items\n-   --  and Proof_In_Items. Flags Has_In_State, Has_In_Out_State, Has_Out_State\n-   --  and Has_Proof_In_State are set when there is at least one abstract state\n-   --  with visible refinement available in the corresponding mode. Flag\n-   --  Has_Null_State is set when at least state has a null refinement.\n-\n    function Find_Related_Subprogram_Or_Body\n      (Prag      : Node_Id;\n       Do_Checks : Boolean := False) return Node_Id;\n@@ -581,9 +562,7 @@ package body Sem_Prag is\n       --  error if this is not the case.\n \n       procedure Normalize_Clause (Clause : Node_Id);\n-      --  Remove a self-dependency \"+\" from the input list of a clause. Split\n-      --  a clause with multiple outputs into multiple clauses with a single\n-      --  output.\n+      --  Remove a self-dependency \"+\" from the input list of a clause\n \n       -----------------------------\n       -- Add_Item_To_Name_Buffer --\n@@ -1335,11 +1314,6 @@ package body Sem_Prag is\n          --  Flag Multiple should be set when Output comes from a list with\n          --  multiple items.\n \n-         procedure Normalize_Outputs;\n-         --  If Clause contains more than one output, split the clause into\n-         --  multiple clauses with a single output. All new clauses are added\n-         --  after Clause.\n-\n          -----------------------------\n          -- Create_Or_Modify_Clause --\n          -----------------------------\n@@ -1525,68 +1499,6 @@ package body Sem_Prag is\n             end if;\n          end Create_Or_Modify_Clause;\n \n-         -----------------------\n-         -- Normalize_Outputs --\n-         -----------------------\n-\n-         procedure Normalize_Outputs is\n-            Inputs      : constant Node_Id    := Expression (Clause);\n-            Loc         : constant Source_Ptr := Sloc (Clause);\n-            Outputs     : constant Node_Id    := First (Choices (Clause));\n-            Last_Output : Node_Id;\n-            New_Clause  : Node_Id;\n-            Next_Output : Node_Id;\n-            Output      : Node_Id;\n-\n-         begin\n-            --  Multiple outputs appear as an aggregate. Nothing to do when\n-            --  the clause has exactly one output.\n-\n-            if Nkind (Outputs) = N_Aggregate then\n-               Last_Output := Last (Expressions (Outputs));\n-\n-               --  Create a clause for each output. Note that each time a new\n-               --  clause is created, the original output list slowly shrinks\n-               --  until there is one item left.\n-\n-               Output := First (Expressions (Outputs));\n-               while Present (Output) loop\n-                  Next_Output := Next (Output);\n-\n-                  --  Unhook the output from the original output list as it\n-                  --  will be relocated to a new clause.\n-\n-                  Remove (Output);\n-\n-                  --  Special processing for the last output. At this point\n-                  --  the original aggregate has been stripped down to one\n-                  --  element. Replace the aggregate by the element itself.\n-\n-                  if Output = Last_Output then\n-                     Rewrite (Outputs, Output);\n-\n-                  else\n-                     --  Generate a clause of the form:\n-                     --    (Output => Inputs)\n-\n-                     New_Clause :=\n-                       Make_Component_Association (Loc,\n-                         Choices    => New_List (Output),\n-                         Expression => New_Copy_Tree (Inputs));\n-\n-                     --  The new clause contains replicated content that has\n-                     --  already been analyzed. There is not need to reanalyze\n-                     --  them.\n-\n-                     Set_Analyzed (New_Clause);\n-                     Insert_After (Clause, New_Clause);\n-                  end if;\n-\n-                  Output := Next_Output;\n-               end loop;\n-            end if;\n-         end Normalize_Outputs;\n-\n          --  Local variables\n \n          Outputs     : constant Node_Id := First (Choices (Clause));\n@@ -1641,11 +1553,6 @@ package body Sem_Prag is\n                   Multiple => False);\n             end if;\n          end if;\n-\n-         --  Split a clause with multiple outputs into multiple clauses with a\n-         --  single output.\n-\n-         Normalize_Outputs;\n       end Normalize_Clause;\n \n       --  Local variables\n@@ -21856,6 +21763,11 @@ package body Sem_Prag is\n    ------------------------------------------\n \n    procedure Analyze_Refined_Depends_In_Decl_Part (N : Node_Id) is\n+      Body_Inputs  : Elist_Id := No_Elist;\n+      Body_Outputs : Elist_Id := No_Elist;\n+      --  The inputs and outputs of the subprogram body synthesized from pragma\n+      --  Refined_Depends.\n+\n       Dependencies : List_Id := No_List;\n       Depends      : Node_Id;\n       --  The corresponding Depends pragma along with its clauses\n@@ -21870,11 +21782,21 @@ package body Sem_Prag is\n       Spec_Id : Entity_Id;\n       --  The entity of the subprogram subject to pragma Refined_Depends\n \n+      Spec_Inputs  : Elist_Id := No_Elist;\n+      Spec_Outputs : Elist_Id := No_Elist;\n+      --  The inputs and outputs of the subprogram spec synthesized from pragma\n+      --  Depends.\n+\n       procedure Check_Dependency_Clause (Dep_Clause : Node_Id);\n       --  Try to match a single dependency clause Dep_Clause against one or\n       --  more refinement clauses found in list Refinements. Each successful\n       --  match eliminates at least one refinement clause from Refinements.\n \n+      procedure Check_Output_States;\n+      --  Determine whether pragma Depends contains an output state with a\n+      --  visible refinement and if so, ensure that pragma Refined_Depends\n+      --  mentions all its constituents as outputs.\n+\n       procedure Normalize_Clauses (Clauses : List_Id);\n       --  Given a list of dependence or refinement clauses Clauses, normalize\n       --  each clause by creating multiple dependencies with exactly one input\n@@ -22250,6 +22172,109 @@ package body Sem_Prag is\n          end if;\n       end Check_Dependency_Clause;\n \n+      -------------------------\n+      -- Check_Output_States --\n+      -------------------------\n+\n+      procedure Check_Output_States is\n+         procedure Check_Constituent_Usage (State_Id : Entity_Id);\n+         --  Determine whether all constituents of state State_Id with visible\n+         --  refinement are used as outputs in pragma Refined_Depends. Emit an\n+         --  error if this is not the case.\n+\n+         -----------------------------\n+         -- Check_Constituent_Usage --\n+         -----------------------------\n+\n+         procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n+            Constit_Elmt : Elmt_Id;\n+            Constit_Id   : Entity_Id;\n+            Posted       : Boolean := False;\n+\n+         begin\n+            Constit_Elmt := First_Elmt (Refinement_Constituents (State_Id));\n+            while Present (Constit_Elmt) loop\n+               Constit_Id := Node (Constit_Elmt);\n+\n+               --  The constituent acts as an input (SPARK RM 7.2.5(3))\n+\n+               if Present (Body_Inputs)\n+                 and then Appears_In (Body_Inputs, Constit_Id)\n+               then\n+                  Error_Msg_Name_1 := Chars (State_Id);\n+                  SPARK_Msg_NE\n+                    (\"constituent & of state % must act as output in \"\n+                     & \"dependence refinement\", N, Constit_Id);\n+\n+               --  The constituent is altogether missing (SPARK RM 7.2.5(3))\n+\n+               elsif No (Body_Outputs)\n+                 or else not Appears_In (Body_Outputs, Constit_Id)\n+               then\n+                  if not Posted then\n+                     Posted := True;\n+                     SPARK_Msg_NE\n+                       (\"output state & must be replaced by all its \"\n+                        & \"constituents in dependence refinement\",\n+                        N, State_Id);\n+                  end if;\n+\n+                  SPARK_Msg_NE\n+                    (\"\\constituent & is missing in output list\",\n+                     N, Constit_Id);\n+               end if;\n+\n+               Next_Elmt (Constit_Elmt);\n+            end loop;\n+         end Check_Constituent_Usage;\n+\n+         --  Local variables\n+\n+         Item      : Node_Id;\n+         Item_Elmt : Elmt_Id;\n+         Item_Id   : Entity_Id;\n+\n+      --  Start of processing for Check_Output_States\n+\n+      begin\n+         --  Inspect the outputs of pragma Depends looking for a state with a\n+         --  visible refinement.\n+\n+         if Present (Spec_Outputs) then\n+            Item_Elmt := First_Elmt (Spec_Outputs);\n+            while Present (Item_Elmt) loop\n+               Item := Node (Item_Elmt);\n+\n+               --  Deal with the mixed nature of the input and output lists\n+\n+               if Nkind (Item) = N_Defining_Identifier then\n+                  Item_Id := Item;\n+               else\n+                  Item_Id := Available_View (Entity_Of (Item));\n+               end if;\n+\n+               if Ekind (Item_Id) = E_Abstract_State then\n+\n+                  --  The state acts as an input-output, skip it\n+\n+                  if Present (Spec_Inputs)\n+                    and then Appears_In (Spec_Inputs, Item_Id)\n+                  then\n+                     null;\n+\n+                  --  Ensure that all of the constituents are utilized as\n+                  --  outputs in pragma Refined_Depends.\n+\n+                  elsif Has_Non_Null_Refinement (Item_Id) then\n+                     Check_Constituent_Usage (Item_Id);\n+                  end if;\n+               end if;\n+\n+               Next_Elmt (Item_Elmt);\n+            end loop;\n+         end if;\n+      end Check_Output_States;\n+\n       -----------------------\n       -- Normalize_Clauses --\n       -----------------------\n@@ -22265,6 +22290,15 @@ package body Sem_Prag is\n          --    Output => Input_1                 --  normalizations\n          --    Output => Input_2\n \n+         procedure Normalize_Outputs (Clause : Node_Id);\n+         --  Normalize clause Clause by creating multiple clause for each\n+         --  output item of Clause. The transformation is as follows:\n+         --\n+         --    (Output_1, Output_2) => Input     --  original\n+         --\n+         --     Output_1 => Input                --  normalization\n+         --     Output_2 => Input\n+\n          ----------------------\n          -- Normalize_Inputs --\n          ----------------------\n@@ -22324,13 +22358,81 @@ package body Sem_Prag is\n             end if;\n          end Normalize_Inputs;\n \n+         -----------------------\n+         -- Normalize_Outputs --\n+         -----------------------\n+\n+         procedure Normalize_Outputs (Clause : Node_Id) is\n+            Inputs      : constant Node_Id    := Expression (Clause);\n+            Loc         : constant Source_Ptr := Sloc (Clause);\n+            Outputs     : constant Node_Id    := First (Choices (Clause));\n+            Last_Output : Node_Id;\n+            New_Clause  : Node_Id;\n+            Next_Output : Node_Id;\n+            Output      : Node_Id;\n+\n+         begin\n+            --  Multiple outputs appear as an aggregate. Nothing to do when\n+            --  the clause has exactly one output.\n+\n+            if Nkind (Outputs) = N_Aggregate then\n+               Last_Output := Last (Expressions (Outputs));\n+\n+               --  Create a clause for each output. Note that each time a new\n+               --  clause is created, the original output list slowly shrinks\n+               --  until there is one item left.\n+\n+               Output := First (Expressions (Outputs));\n+               while Present (Output) loop\n+                  Next_Output := Next (Output);\n+\n+                  --  Unhook the output from the original output list as it\n+                  --  will be relocated to a new clause.\n+\n+                  Remove (Output);\n+\n+                  --  Special processing for the last output. At this point\n+                  --  the original aggregate has been stripped down to one\n+                  --  element. Replace the aggregate by the element itself.\n+\n+                  if Output = Last_Output then\n+                     Rewrite (Outputs, Output);\n+\n+                  else\n+                     --  Generate a clause of the form:\n+                     --    (Output => Inputs)\n+\n+                     New_Clause :=\n+                       Make_Component_Association (Loc,\n+                         Choices    => New_List (Output),\n+                         Expression => New_Copy_Tree (Inputs));\n+\n+                     --  The new clause contains replicated content that has\n+                     --  already been analyzed. There is not need to reanalyze\n+                     --  them.\n+\n+                     Set_Analyzed (New_Clause);\n+                     Insert_After (Clause, New_Clause);\n+                  end if;\n+\n+                  Output := Next_Output;\n+               end loop;\n+            end if;\n+         end Normalize_Outputs;\n+\n          --  Local variables\n \n          Clause : Node_Id;\n \n       --  Start of processing for Normalize_Clauses\n \n       begin\n+         Clause := First (Clauses);\n+         while Present (Clause) loop\n+            Normalize_Outputs (Clause);\n+            Next (Clause);\n+         end loop;\n+\n          Clause := First (Clauses);\n          while Present (Clause) loop\n             Normalize_Inputs (Clause);\n@@ -22368,12 +22470,14 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      Body_Decl : constant Node_Id := Find_Related_Subprogram_Or_Body (N);\n-      Errors    : constant Nat     := Serious_Errors_Detected;\n-      Refs      : constant Node_Id :=\n+      Body_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n+      Body_Id   : constant Entity_Id := Defining_Entity (Body_Decl);\n+      Errors    : constant Nat       := Serious_Errors_Detected;\n+      Refs      : constant Node_Id   :=\n                     Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n       Clause    : Node_Id;\n       Deps      : Node_Id;\n+      Dummy     : Boolean;\n \n    --  Start of processing for Analyze_Refined_Depends_In_Decl_Part\n \n@@ -22417,11 +22521,43 @@ package body Sem_Prag is\n       Analyze_Depends_In_Decl_Part (N);\n \n       --  Do not match dependencies against refinements if Refined_Depends is\n-      --  illegal to avoid emitting misleading error. Matching is disabled in\n-      --  ASIS because clauses are not normalized as this is a tree altering\n-      --  activity similar to expansion.\n+      --  illegal to avoid emitting misleading error.\n+\n+      if Serious_Errors_Detected = Errors then\n+\n+         --  The related subprogram lacks pragma [Refined_]Global. Synthesize\n+         --  the inputs and outputs of the subprogram spec and body to verify\n+         --  the use of states with visible refinement and their constituents.\n+\n+         if No (Get_Pragma (Spec_Id, Pragma_Global))\n+           or else No (Get_Pragma (Body_Id, Pragma_Refined_Global))\n+         then\n+            Collect_Subprogram_Inputs_Outputs\n+              (Subp_Id      => Spec_Id,\n+               Synthesize   => True,\n+               Subp_Inputs  => Spec_Inputs,\n+               Subp_Outputs => Spec_Outputs,\n+               Global_Seen  => Dummy);\n+\n+            Collect_Subprogram_Inputs_Outputs\n+              (Subp_Id      => Body_Id,\n+               Synthesize   => True,\n+               Subp_Inputs  => Body_Inputs,\n+               Subp_Outputs => Body_Outputs,\n+               Global_Seen  => Dummy);\n+\n+            --  For an output state with a visible refinement, ensure that all\n+            --  constituents appear as outputs in the dependency refinement.\n \n-      if Serious_Errors_Detected = Errors and then not ASIS_Mode then\n+            Check_Output_States;\n+         end if;\n+\n+         --  Matching is disabled in ASIS because clauses are not normalized as\n+         --  this is a tree altering activity similar to expansion.\n+\n+         if ASIS_Mode then\n+            return;\n+         end if;\n \n          --  Multiple dependency clauses appear as component associations of an\n          --  aggregate. Note that the clauses are copied because the algorithm\n@@ -22533,6 +22669,14 @@ package body Sem_Prag is\n       --  Verify the legality of a single global list declaration. Global_Mode\n       --  denotes the current mode in effect.\n \n+      procedure Collect_Global_Items (Prag : Node_Id);\n+      --  Gather all input, in out, output and Proof_In items of pragma Prag\n+      --  in lists In_Items, In_Out_Items, Out_Items and Proof_In_Items. Flags\n+      --  Has_In_State, Has_In_Out_State, Has_Out_State and Has_Proof_In_State\n+      --  are set when there is at least one abstract state with visible\n+      --  refinement available in the corresponding mode. Flag Has_Null_State\n+      --  is set when at least state has a null refinement.\n+\n       function Present_Then_Remove\n         (List : Elist_Id;\n          Item : Entity_Id) return Boolean;\n@@ -23068,6 +23212,142 @@ package body Sem_Prag is\n          end if;\n       end Check_Refined_Global_List;\n \n+      --------------------------\n+      -- Collect_Global_Items --\n+      --------------------------\n+\n+      procedure Collect_Global_Items (Prag : Node_Id) is\n+         procedure Process_Global_List\n+           (List : Node_Id;\n+            Mode : Name_Id := Name_Input);\n+         --  Collect all items housed in a global list. Formal Mode denotes the\n+         --  current mode in effect.\n+\n+         -------------------------\n+         -- Process_Global_List --\n+         -------------------------\n+\n+         procedure Process_Global_List\n+           (List : Node_Id;\n+            Mode : Name_Id := Name_Input)\n+         is\n+            procedure Process_Global_Item (Item : Node_Id; Mode : Name_Id);\n+            --  Add a single item to the appropriate list. Formal Mode denotes\n+            --  the current mode in effect.\n+\n+            -------------------------\n+            -- Process_Global_Item --\n+            -------------------------\n+\n+            procedure Process_Global_Item (Item : Node_Id; Mode : Name_Id) is\n+               Item_Id : constant Entity_Id :=\n+                           Available_View (Entity_Of (Item));\n+               --  The above handles abstract views of variables and states\n+               --  built for limited with clauses.\n+\n+            begin\n+               --  Signal that the global list contains at least one abstract\n+               --  state with a visible refinement. Note that the refinement\n+               --  may be null in which case there are no constituents.\n+\n+               if Ekind (Item_Id) = E_Abstract_State then\n+                  if Has_Null_Refinement (Item_Id) then\n+                     Has_Null_State := True;\n+\n+                  elsif Has_Non_Null_Refinement (Item_Id) then\n+                     if Mode = Name_Input then\n+                        Has_In_State := True;\n+                     elsif Mode = Name_In_Out then\n+                        Has_In_Out_State := True;\n+                     elsif Mode = Name_Output then\n+                        Has_Out_State := True;\n+                     elsif Mode = Name_Proof_In then\n+                        Has_Proof_In_State := True;\n+                     end if;\n+                  end if;\n+               end if;\n+\n+               --  Add the item to the proper list\n+\n+               if Mode = Name_Input then\n+                  Add_Item (Item_Id, In_Items);\n+               elsif Mode = Name_In_Out then\n+                  Add_Item (Item_Id, In_Out_Items);\n+               elsif Mode = Name_Output then\n+                  Add_Item (Item_Id, Out_Items);\n+               elsif Mode = Name_Proof_In then\n+                  Add_Item (Item_Id, Proof_In_Items);\n+               end if;\n+            end Process_Global_Item;\n+\n+            --  Local variables\n+\n+            Item : Node_Id;\n+\n+         --  Start of processing for Process_Global_List\n+\n+         begin\n+            if Nkind (List) = N_Null then\n+               null;\n+\n+            --  Single global item declaration\n+\n+            elsif Nkind_In (List, N_Expanded_Name,\n+                                  N_Identifier,\n+                                  N_Selected_Component)\n+            then\n+               Process_Global_Item (List, Mode);\n+\n+            --  Single global list or moded global list declaration\n+\n+            elsif Nkind (List) = N_Aggregate then\n+\n+               --  The declaration of a simple global list appear as a\n+               --  collection of expressions.\n+\n+               if Present (Expressions (List)) then\n+                  Item := First (Expressions (List));\n+                  while Present (Item) loop\n+                     Process_Global_Item (Item, Mode);\n+                     Next (Item);\n+                  end loop;\n+\n+               --  The declaration of a moded global list appears as a\n+               --  collection of component associations where individual\n+               --  choices denote mode.\n+\n+               elsif Present (Component_Associations (List)) then\n+                  Item := First (Component_Associations (List));\n+                  while Present (Item) loop\n+                     Process_Global_List\n+                       (List => Expression (Item),\n+                        Mode => Chars (First (Choices (Item))));\n+\n+                     Next (Item);\n+                  end loop;\n+\n+               --  Invalid tree\n+\n+               else\n+                  raise Program_Error;\n+               end if;\n+\n+            --  To accomodate partial decoration of disabled SPARK features,\n+            --  this routine may be called with illegal input. If this is the\n+            --  case, do not raise Program_Error.\n+\n+            else\n+               null;\n+            end if;\n+         end Process_Global_List;\n+\n+      --  Start of processing for Collect_Global_Items\n+\n+      begin\n+         Process_Global_List\n+           (Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag))));\n+      end Collect_Global_Items;\n+\n       -------------------------\n       -- Present_Then_Remove --\n       -------------------------\n@@ -23159,17 +23439,7 @@ package body Sem_Prag is\n \n       --  Extract all relevant items from the corresponding Global pragma\n \n-      Collect_Global_Items\n-        (Prag               => Global,\n-         In_Items           => In_Items,\n-         In_Out_Items       => In_Out_Items,\n-         Out_Items          => Out_Items,\n-         Proof_In_Items     => Proof_In_Items,\n-         Has_In_State       => Has_In_State,\n-         Has_In_Out_State   => Has_In_Out_State,\n-         Has_Out_State      => Has_Out_State,\n-         Has_Proof_In_State => Has_Proof_In_State,\n-         Has_Null_State     => Has_Null_State);\n+      Collect_Global_Items (Global);\n \n       --  Corresponding Global pragma must mention at least one state witha\n       --  visible refinement at the point Refined_Global is processed. States\n@@ -24638,135 +24908,89 @@ package body Sem_Prag is\n       end loop;\n    end Check_State_And_Constituent_Use;\n \n-   --------------------------\n-   -- Collect_Global_Items --\n-   --------------------------\n-\n-   procedure Collect_Global_Items\n-     (Prag               : Node_Id;\n-      In_Items           : in out Elist_Id;\n-      In_Out_Items       : in out Elist_Id;\n-      Out_Items          : in out Elist_Id;\n-      Proof_In_Items     : in out Elist_Id;\n-      Has_In_State       : out Boolean;\n-      Has_In_Out_State   : out Boolean;\n-      Has_Out_State      : out Boolean;\n-      Has_Proof_In_State : out Boolean;\n-      Has_Null_State     : out Boolean)\n+   ---------------------------------------\n+   -- Collect_Subprogram_Inputs_Outputs --\n+   ---------------------------------------\n+\n+   procedure Collect_Subprogram_Inputs_Outputs\n+     (Subp_Id      : Entity_Id;\n+      Synthesize   : Boolean := False;\n+      Subp_Inputs  : in out Elist_Id;\n+      Subp_Outputs : in out Elist_Id;\n+      Global_Seen  : out Boolean)\n    is\n-      procedure Process_Global_List\n+      procedure Collect_Dependency_Clause (Clause : Node_Id);\n+      --  Collect all relevant items from a dependency clause\n+\n+      procedure Collect_Global_List\n         (List : Node_Id;\n          Mode : Name_Id := Name_Input);\n-      --  Collect all items housed in a global list. Formal Mode denotes the\n-      --  current mode in effect.\n+      --  Collect all relevant items from a global list\n \n-      -------------------------\n-      -- Process_Global_List --\n-      -------------------------\n+      -------------------------------\n+      -- Collect_Dependency_Clause --\n+      -------------------------------\n \n-      procedure Process_Global_List\n-        (List : Node_Id;\n-         Mode : Name_Id := Name_Input)\n-      is\n-         procedure Process_Global_Item (Item : Node_Id; Mode : Name_Id);\n-         --  Add a single item to the appropriate list. Formal Mode denotes the\n-         --  current mode in effect.\n+      procedure Collect_Dependency_Clause (Clause : Node_Id) is\n+         procedure Collect_Dependency_Item\n+           (Item     : Node_Id;\n+            Is_Input : Boolean);\n+         --  Add an item to the proper subprogram input or output collection\n \n-         -------------------------\n-         -- Process_Global_Item --\n-         -------------------------\n+         -----------------------------\n+         -- Collect_Dependency_Item --\n+         -----------------------------\n \n-         procedure Process_Global_Item (Item : Node_Id; Mode : Name_Id) is\n-            Item_Id : constant Entity_Id := Available_View (Entity_Of (Item));\n-            --  The above handles abstract views of variables and states built\n-            --  for limited with clauses.\n+         procedure Collect_Dependency_Item\n+           (Item     : Node_Id;\n+            Is_Input : Boolean)\n+         is\n+            Extra : Node_Id;\n \n          begin\n-            --  Signal that the global list contains at least one abstract\n-            --  state with a visible refinement. Note that the refinement may\n-            --  be null in which case there are no constituents.\n-\n-            if Ekind (Item_Id) = E_Abstract_State then\n-               if Has_Null_Refinement (Item_Id) then\n-                  Has_Null_State := True;\n-\n-               elsif Has_Non_Null_Refinement (Item_Id) then\n-                  if Mode = Name_Input then\n-                     Has_In_State := True;\n-                  elsif Mode = Name_In_Out then\n-                     Has_In_Out_State := True;\n-                  elsif Mode = Name_Output then\n-                     Has_Out_State := True;\n-                  elsif Mode = Name_Proof_In then\n-                     Has_Proof_In_State := True;\n-                  end if;\n-               end if;\n-            end if;\n-\n-            --  Add the item to the proper list\n-\n-            if Mode = Name_Input then\n-               Add_Item (Item_Id, In_Items);\n-            elsif Mode = Name_In_Out then\n-               Add_Item (Item_Id, In_Out_Items);\n-            elsif Mode = Name_Output then\n-               Add_Item (Item_Id, Out_Items);\n-            elsif Mode = Name_Proof_In then\n-               Add_Item (Item_Id, Proof_In_Items);\n-            end if;\n-         end Process_Global_Item;\n-\n-         --  Local variables\n-\n-         Item : Node_Id;\n+            --  Nothing to collect when the item is null\n \n-      --  Start of processing for Process_Global_List\n-\n-      begin\n-         if Nkind (List) = N_Null then\n-            null;\n-\n-         --  Single global item declaration\n-\n-         elsif Nkind_In (List, N_Expanded_Name,\n-                               N_Identifier,\n-                               N_Selected_Component)\n-         then\n-            Process_Global_Item (List, Mode);\n-\n-         --  Single global list or moded global list declaration\n+            if Nkind (Item) = N_Null then\n+               null;\n \n-         elsif Nkind (List) = N_Aggregate then\n+            --  Ditto for attribute 'Result\n \n-            --  The declaration of a simple global list appear as a collection\n-            --  of expressions.\n+            elsif Is_Attribute_Result (Item) then\n+               null;\n \n-            if Present (Expressions (List)) then\n-               Item := First (Expressions (List));\n-               while Present (Item) loop\n-                  Process_Global_Item (Item, Mode);\n+            --  Multiple items appear as an aggregate\n \n-                  Next (Item);\n+            elsif Nkind (Item) = N_Aggregate then\n+               Extra := First (Expressions (Item));\n+               while Present (Extra) loop\n+                  Collect_Dependency_Item (Extra, Is_Input);\n+                  Next (Extra);\n                end loop;\n \n-            --  The declaration of a moded global list appears as a collection\n-            --  of component associations where individual choices denote mode.\n+            --  Otherwise this is a solitary item\n \n-            elsif Present (Component_Associations (List)) then\n-               Item := First (Component_Associations (List));\n-               while Present (Item) loop\n-                  Process_Global_List\n-                    (List => Expression (Item),\n-                     Mode => Chars (First (Choices (Item))));\n+            else\n+               if Is_Input then\n+                  Add_Item (Item, Subp_Inputs);\n+               else\n+                  Add_Item (Item, Subp_Outputs);\n+               end if;\n+            end if;\n+         end Collect_Dependency_Item;\n \n-                  Next (Item);\n-               end loop;\n+      --  Start of processing for Collect_Dependency_Clause\n \n-            --  Invalid tree\n+      begin\n+         if Nkind (Clause) = N_Null then\n+            null;\n \n-            else\n-               raise Program_Error;\n-            end if;\n+         --  A dependency cause appears as component association\n+\n+         elsif Nkind (Clause) = N_Component_Association then\n+            Collect_Dependency_Item\n+              (Expression (Clause),      Is_Input => True);\n+            Collect_Dependency_Item\n+              (First (Choices (Clause)), Is_Input => False);\n \n          --  To accomodate partial decoration of disabled SPARK features, this\n          --  routine may be called with illegal input. If this is the case, do\n@@ -24775,41 +24999,7 @@ package body Sem_Prag is\n          else\n             null;\n          end if;\n-      end Process_Global_List;\n-\n-      --  Local variables\n-\n-      Items : constant Node_Id :=\n-                Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n-\n-   --  Start of processing for Collect_Global_Items\n-\n-   begin\n-      --  Assume that no states have been encountered\n-\n-      Has_In_State       := False;\n-      Has_In_Out_State   := False;\n-      Has_Out_State      := False;\n-      Has_Proof_In_State := False;\n-      Has_Null_State     := False;\n-\n-      Process_Global_List (Items);\n-   end Collect_Global_Items;\n-\n-   ---------------------------------------\n-   -- Collect_Subprogram_Inputs_Outputs --\n-   ---------------------------------------\n-\n-   procedure Collect_Subprogram_Inputs_Outputs\n-     (Subp_Id      : Entity_Id;\n-      Subp_Inputs  : in out Elist_Id;\n-      Subp_Outputs : in out Elist_Id;\n-      Global_Seen  : out Boolean)\n-   is\n-      procedure Collect_Global_List\n-        (List : Node_Id;\n-         Mode : Name_Id := Name_Input);\n-      --  Collect all relevant items from a global list\n+      end Collect_Dependency_Clause;\n \n       -------------------------\n       -- Collect_Global_List --\n@@ -24887,7 +25077,10 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      Subp_Decl : constant Node_Id := Parent (Parent (Subp_Id));\n+      Subp_Decl : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n+      Clause    : Node_Id;\n+      Clauses   : Node_Id;\n+      Depends   : Node_Id;\n       Formal    : Entity_Id;\n       Global    : Node_Id;\n       List      : Node_Id;\n@@ -24939,18 +25132,23 @@ package body Sem_Prag is\n          Next_Formal (Formal);\n       end loop;\n \n-      --  When processing a subprogram body, look for pragma Refined_Global as\n-      --  it provides finer granularity of inputs and outputs.\n+      --  When processing a subprogram body, look for pragmas Refined_Depends\n+      --  and Refined_Global as they specify the inputs and outputs.\n \n       if Ekind (Subp_Id) = E_Subprogram_Body then\n-         Global := Get_Pragma (Subp_Id, Pragma_Refined_Global);\n+         Depends := Get_Pragma (Subp_Id, Pragma_Refined_Depends);\n+         Global  := Get_Pragma (Subp_Id, Pragma_Refined_Global);\n \n-      --  Subprogram declaration case, look for pragma Global\n+      --  Subprogram declaration case, look for pragmas Depends and Global\n \n       else\n-         Global := Get_Pragma (Spec_Id, Pragma_Global);\n+         Depends := Get_Pragma (Spec_Id, Pragma_Depends);\n+         Global  := Get_Pragma (Spec_Id, Pragma_Global);\n       end if;\n \n+      --  Pragma [Refined_]Global takes precedence over [Refined_]Depends\n+      --  because it provides finer granularity of inputs and outputs.\n+\n       if Present (Global) then\n          Global_Seen := True;\n          List := Expression (First (Pragma_Argument_Associations (Global)));\n@@ -24967,10 +25165,29 @@ package body Sem_Prag is\n             end if;\n          end if;\n \n-         --  Nothing to be done for a null global list\n+         Collect_Global_List (List);\n+\n+      --  When the related subprogram lacks pragma [Refined_]Global, fall back\n+      --  to [Refined_]Depends if the caller requests this behavior. Synthesize\n+      --  the inputs and outputs from [Refined_]Depends.\n+\n+      elsif Synthesize and then Present (Depends) then\n+         Clauses :=\n+           Get_Pragma_Arg (First (Pragma_Argument_Associations (Depends)));\n+\n+         --  Multiple dependency clauses appear as an aggregate\n+\n+         if Nkind (Clauses) = N_Aggregate then\n+            Clause := First (Component_Associations (Clauses));\n+            while Present (Clause) loop\n+               Collect_Dependency_Clause (Clause);\n+               Next (Clause);\n+            end loop;\n+\n+         --  Otherwise this is a single dependency clause\n \n-         if Nkind (List) /= N_Null then\n-            Collect_Global_List (List);\n+         else\n+            Collect_Dependency_Clause (Clauses);\n          end if;\n       end if;\n    end Collect_Subprogram_Inputs_Outputs;"}, {"sha": "d89039af32079d02466a2f8db145517abf022fd8", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5e108f9bc25c1a4043e402d6c9adf6d9405e31/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=5c5e108f9bc25c1a4043e402d6c9adf6d9405e31", "patch": "@@ -172,14 +172,21 @@ package Sem_Prag is\n \n    procedure Collect_Subprogram_Inputs_Outputs\n      (Subp_Id      : Entity_Id;\n+      Synthesize   : Boolean := False;\n       Subp_Inputs  : in out Elist_Id;\n       Subp_Outputs : in out Elist_Id;\n       Global_Seen  : out Boolean);\n-   --  Used during the analysis of pragmas Depends, Global, Refined_Depends,\n-   --  and Refined_Global. Also used by GNATprove. Gathers all inputs and\n-   --  outputs of subprogram Subp_Id in lists Subp_Inputs and Subp_Outputs.\n-   --  If subprogram has no inputs and/or outputs, then the returned list\n-   --  is No_Elist. Global_Seen is set when the related subprogram has\n+   --  Subsidiary to the analysis of pragmas Depends, Global, Refined_Depends\n+   --  and Refined_Global. The routine is also used by GNATprove. Collect all\n+   --  inputs and outputs of subprogram Subp_Id in lists Subp_Inputs (inputs)\n+   --  and Subp_Outputs (outputs). The inputs and outputs are gathered from:\n+   --    1) The formal parameters of the subprogram\n+   --    2) The items of pragma [Refined_]Global\n+   --         or\n+   --    3) The items of pragma [Refined_]Depends if there is no pragma\n+   --       [Refined_]Global present and flag Synthesize is set to True.\n+   --  If the subprogram has no inputs and/or outputs, then the returned list\n+   --  is No_Elist. Flag Global_Seen is set when the related subprogram has\n    --  pragma [Refined_]Global.\n \n    function Delay_Config_Pragma_Analyze (N : Node_Id) return Boolean;"}]}