{"sha": "e7f373fa6952ad2c1bc8980dc29f584127ee0171", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdmMzczZmE2OTUyYWQyYzFiYzg5ODBkYzI5ZjU4NDEyN2VlMDE3MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-09-17T17:27:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-09-17T17:27:00Z"}, "message": "dwarf2out.c: Include tree-pass.h and gimple.h.\n\n\n\t* dwarf2out.c: Include tree-pass.h and gimple.h.\n\t(loc_list_plus_const): New function.\n\t(loc_descriptor_from_tree_1): Rename to ...\n\t(loc_descriptor_from_tree): ... remove original.\n\t(loc_list_from_tree): New function.\n\t(add_AT_location_description): Accept location list.\n\t(tls_mem_loc_descriptor): Update call of loc_descriptor_from_tree.\n\t(concatn_mem_loc_descriptor): Remove.\n\t(mem_loc_descriptor): Handle CONCAT/CONCATN and VAR_LOCATION by\n\treturning NULL.\n\t(secname_for_decl): Move up.\n\t(hidden_reference_p): New function; break out from ...\n\t(loc_by_refernece): ... here; move up.\n\t(dw_loc_list): New function.\n\t(single_element_loc_list): New function.\n\t(single_element_loc_list_p): New function.\n\t(add_loc_descr_to_each): New function.\n\t(add_loc_list): New function.\n\t(loc_descr_from_tree): Make wraper of loc_list_from_tree.\n\t(loc_list_from_tree): Reroganized from loc_descr_from_tree;\n\tadd diagnostics why expansion failed.\n\t(add_location_or_const_value_attribute): Support location lists.\n\t(add_bound_info): Likewise.\n\t(descr_info_loc): Update call of loc_descriptor_from_tree.\n\t(gen_variable_die): Work on location lists.\n\t* final.c (pass_final): Add dump file.\n\t* Makefile.in (dwarf2out.o): Add new dependencies.\n\nFrom-SVN: r151807", "tree": {"sha": "a9d4821ab39040c52fd6eded99a01e7bd28822ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9d4821ab39040c52fd6eded99a01e7bd28822ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7f373fa6952ad2c1bc8980dc29f584127ee0171", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f373fa6952ad2c1bc8980dc29f584127ee0171", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f373fa6952ad2c1bc8980dc29f584127ee0171", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f373fa6952ad2c1bc8980dc29f584127ee0171/comments", "author": null, "committer": null, "parents": [{"sha": "d2da4af2c7872e1d9892cc5b3792d10dd86782a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2da4af2c7872e1d9892cc5b3792d10dd86782a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2da4af2c7872e1d9892cc5b3792d10dd86782a4"}], "stats": {"total": 807, "additions": 567, "deletions": 240}, "files": [{"sha": "bc01e5e9136a57de8fb19e3b3873cd1261396bea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f373fa6952ad2c1bc8980dc29f584127ee0171/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f373fa6952ad2c1bc8980dc29f584127ee0171/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7f373fa6952ad2c1bc8980dc29f584127ee0171", "patch": "@@ -1,3 +1,33 @@\n+2009-09-17  Jan Hubicka  <jh@suse.cz>\n+\n+\t* dwarf2out.c: Include tree-pass.h and gimple.h.\n+\t(loc_list_plus_const): New function.\n+\t(loc_descriptor_from_tree_1): Rename to ...\n+\t(loc_descriptor_from_tree): ... remove original.\n+\t(loc_list_from_tree): New function.\n+\t(add_AT_location_description): Accept location list.\n+\t(tls_mem_loc_descriptor): Update call of loc_descriptor_from_tree.\n+\t(concatn_mem_loc_descriptor): Remove.\n+\t(mem_loc_descriptor): Handle CONCAT/CONCATN and VAR_LOCATION by\n+\treturning NULL.\n+\t(secname_for_decl): Move up.\n+\t(hidden_reference_p): New function; break out from ...\n+\t(loc_by_refernece): ... here; move up.\n+\t(dw_loc_list): New function.\n+\t(single_element_loc_list): New function.\n+\t(single_element_loc_list_p): New function.\n+\t(add_loc_descr_to_each): New function.\n+\t(add_loc_list): New function.\n+\t(loc_descr_from_tree): Make wraper of loc_list_from_tree.\n+\t(loc_list_from_tree): Reroganized from loc_descr_from_tree;\n+\tadd diagnostics why expansion failed.\n+\t(add_location_or_const_value_attribute): Support location lists.\n+\t(add_bound_info): Likewise.\n+\t(descr_info_loc): Update call of loc_descriptor_from_tree.\n+\t(gen_variable_die): Work on location lists.\n+\t* final.c (pass_final): Add dump file.\n+\t* Makefile.in (dwarf2out.o): Add new dependencies.\n+\n 2009-09-17  Janis Johnson  <janis187@us.ibm.com>\n \n \tPR c/41049"}, {"sha": "cbd68d84ee4ce7868496372cf1eb7ca5e9c30a65", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f373fa6952ad2c1bc8980dc29f584127ee0171/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f373fa6952ad2c1bc8980dc29f584127ee0171/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e7f373fa6952ad2c1bc8980dc29f584127ee0171", "patch": "@@ -2731,7 +2731,7 @@ dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    output.h $(DIAGNOSTIC_H) $(REAL_H) hard-reg-set.h $(REGS_H) $(EXPR_H) \\\n    libfuncs.h $(TOPLEV_H) dwarf2out.h reload.h $(GGC_H) $(EXCEPT_H) dwarf2asm.h \\\n    $(TM_P_H) langhooks.h $(HASHTAB_H) gt-dwarf2out.h $(TARGET_H) $(CGRAPH_H) \\\n-   $(MD5_H) $(INPUT_H) $(FUNCTION_H) $(VARRAY_H)\n+   $(MD5_H) $(INPUT_H) $(FUNCTION_H) $(VARRAY_H) $(GIMPLE_H) $(TREE_PASS_H)\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(FLAGS_H) $(RTL_H) $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H) \\\n    gt-dwarf2asm.h $(DWARF2_H) $(SPLAY_TREE_H) $(TARGET_H)"}, {"sha": "7e43d1b0acf7abb3b213a1108b49c5e738d51fd3", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 535, "deletions": 238, "changes": 773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f373fa6952ad2c1bc8980dc29f584127ee0171/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f373fa6952ad2c1bc8980dc29f584127ee0171/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e7f373fa6952ad2c1bc8980dc29f584127ee0171", "patch": "@@ -89,6 +89,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"cgraph.h\"\n #include \"input.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n \n #ifdef DWARF2_DEBUGGING_INFO\n static void dwarf2out_source_line (unsigned int, const char *, int, bool);\n@@ -4655,6 +4657,16 @@ loc_descr_plus_const (dw_loc_descr_ref *list_head, HOST_WIDE_INT offset)\n     }\n }\n \n+/* Add a constant OFFSET to a location list.  */\n+\n+static void\n+loc_list_plus_const (dw_loc_list_ref list_head, HOST_WIDE_INT offset)\n+{\n+  dw_loc_list_ref d;\n+  for (d = list_head; d != NULL; d = d->dw_loc_next)\n+    loc_descr_plus_const (&d->expr, offset);\n+}\n+\n /* Return the size of a location descriptor.  */\n \n static unsigned long\n@@ -5938,16 +5950,16 @@ static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx,\n \t\t\t\t\t       enum var_init_status);\n static dw_loc_descr_ref loc_descriptor (rtx, enum machine_mode mode,\n \t\t\t\t\tenum var_init_status);\n-static dw_loc_descr_ref loc_descriptor_from_tree_1 (tree, int);\n-static dw_loc_descr_ref loc_descriptor_from_tree (tree);\n+static dw_loc_list_ref loc_list_from_tree (tree, int);\n+static dw_loc_descr_ref loc_descriptor_from_tree (tree, int);\n static HOST_WIDE_INT ceiling (HOST_WIDE_INT, unsigned int);\n static tree field_type (const_tree);\n static unsigned int simple_type_align_in_bits (const_tree);\n static unsigned int simple_decl_align_in_bits (const_tree);\n static unsigned HOST_WIDE_INT simple_type_size_in_bits (const_tree);\n static HOST_WIDE_INT field_byte_offset (const_tree);\n static void add_AT_location_description\t(dw_die_ref, enum dwarf_attribute,\n-\t\t\t\t\t dw_loc_descr_ref);\n+\t\t\t\t\t dw_loc_list_ref);\n static void add_data_member_location_attribute (dw_die_ref, tree);\n static void add_const_value_attribute (dw_die_ref, rtx);\n static void insert_int (HOST_WIDE_INT, unsigned, unsigned char *);\n@@ -10958,36 +10970,6 @@ is_based_loc (const_rtx rtl)\n \t       && CONST_INT_P (XEXP (rtl, 1)))));\n }\n \n-/* Return a descriptor that describes the concatenation of N locations\n-   used to form the address of a memory location.  */\n-\n-static dw_loc_descr_ref\n-concatn_mem_loc_descriptor (rtx concatn, enum machine_mode mode,\n-\t\t\t    enum var_init_status initialized)\n-{\n-  unsigned int i;\n-  dw_loc_descr_ref cc_loc_result = NULL;\n-  unsigned int n = XVECLEN (concatn, 0);\n-\n-  for (i = 0; i < n; ++i)\n-    {\n-      dw_loc_descr_ref ref;\n-      rtx x = XVECEXP (concatn, 0, i);\n-\n-      ref = mem_loc_descriptor (x, mode, VAR_INIT_STATUS_INITIALIZED);\n-      if (ref == NULL)\n-\treturn NULL;\n-\n-      add_loc_descr (&cc_loc_result, ref);\n-      add_loc_descr_op_piece (&cc_loc_result, GET_MODE_SIZE (GET_MODE (x)));\n-    }\n-\n-  if (cc_loc_result && initialized == VAR_INIT_STATUS_UNINITIALIZED)\n-    add_loc_descr (&cc_loc_result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));\n-\n-  return cc_loc_result;\n-}\n-\n /* Try to handle TLS MEMs, for which mem_loc_descriptor on XEXP (mem, 0)\n    failed.  */\n \n@@ -11006,7 +10988,7 @@ tls_mem_loc_descriptor (rtx mem)\n       || !DECL_THREAD_LOCAL_P (base))\n     return NULL;\n \n-  loc_result = loc_descriptor_from_tree_1 (MEM_EXPR (mem), 2);\n+  loc_result = loc_descriptor_from_tree (MEM_EXPR (mem), 2);\n   if (loc_result == NULL)\n     return NULL;\n \n@@ -11016,6 +10998,26 @@ tls_mem_loc_descriptor (rtx mem)\n   return loc_result;\n }\n \n+/* Output debug info about reason why we failed to expand expression as dwarf\n+   expression.  */\n+\n+static void\n+expansion_failed (tree expr, rtx rtl, char const *reason)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Failed to expand as dwarf: \");\n+      if (expr)\n+\tprint_generic_expr (dump_file, expr, dump_flags);\n+      if (rtl)\n+\t{\n+\t  fprintf (dump_file, \"\\n\");\n+\t  print_rtl (dump_file, rtl);\n+\t}\n+      fprintf (dump_file, \"\\nReason: %s\\n\", reason);\n+    }\n+}\n+\n /* The following routine converts the RTL for a variable or parameter\n    (resident in memory) into an equivalent Dwarf representation of a\n    mechanism for getting the address of that same variable onto the top of a\n@@ -11163,7 +11165,11 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t     FIXME: might try to use DW_OP_const_value here, though\n \t     DW_OP_piece complicates it.  */\n \t  if (!marked)\n-\t    return 0;\n+\t    {\n+\t      expansion_failed (NULL_TREE, rtl,\n+\t\t\t\t\"Constant was removed from constant pool.\\n\");\n+\t      return 0;\n+\t    }\n \t}\n \n       if (GET_CODE (rtl) == SYMBOL_REF\n@@ -11193,6 +11199,14 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n       break;\n \n+    case CONCAT:\n+    case CONCATN:\n+    case VAR_LOCATION:\n+      expansion_failed (NULL_TREE, rtl,\n+\t\t\t\"CONCAT/CONCATN/VAR_LOCATION is handled only by loc_descriptor\");\n+      gcc_unreachable ();\n+      return 0;\n+\n     case PRE_MODIFY:\n       /* Extract the PLUS expression nested inside and fall into\n \t PLUS code below.  */\n@@ -11322,11 +11336,6 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       mem_loc_result = int_loc_descriptor (INTVAL (rtl));\n       break;\n \n-    case CONCATN:\n-      mem_loc_result = concatn_mem_loc_descriptor (rtl, mode,\n-\t\t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n-      break;\n-\n     case EQ:\n       op = DW_OP_eq;\n       goto do_scompare;\n@@ -11972,16 +11981,310 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n   return loc_result;\n }\n \n-/* Similar, but generate the descriptor from trees instead of rtl.  This comes\n-   up particularly with variable length arrays.  WANT_ADDRESS is 2 if this is\n-   a top-level invocation of loc_descriptor_from_tree; is 1 if this is not a\n-   top-level invocation, and we require the address of LOC; is 0 if we require\n-   the value of LOC.  */\n+/* We need to figure out what section we should use as the base for the\n+   address ranges where a given location is valid.\n+   1. If this particular DECL has a section associated with it, use that.\n+   2. If this function has a section associated with it, use that.\n+   3. Otherwise, use the text section.\n+   XXX: If you split a variable across multiple sections, we won't notice.  */\n+\n+static const char *\n+secname_for_decl (const_tree decl)\n+{\n+  const char *secname;\n+\n+  if (VAR_OR_FUNCTION_DECL_P (decl) && DECL_SECTION_NAME (decl))\n+    {\n+      tree sectree = DECL_SECTION_NAME (decl);\n+      secname = TREE_STRING_POINTER (sectree);\n+    }\n+  else if (current_function_decl && DECL_SECTION_NAME (current_function_decl))\n+    {\n+      tree sectree = DECL_SECTION_NAME (current_function_decl);\n+      secname = TREE_STRING_POINTER (sectree);\n+    }\n+  else if (cfun && in_cold_section_p)\n+    secname = crtl->subsections.cold_section_label;\n+  else\n+    secname = text_section_label;\n+\n+  return secname;\n+}\n+\n+/* Return true when DECL_BY_REFERENCE is defined and set for DECL.  */\n+\n+static bool\n+decl_by_reference_p (tree decl)\n+{\n+  return ((TREE_CODE (decl) == PARM_DECL || TREE_CODE (decl) == RESULT_DECL\n+  \t   || TREE_CODE (decl) == VAR_DECL)\n+\t  && DECL_BY_REFERENCE (decl));\n+}\n+\n+\n+/* Dereference a location expression LOC if DECL is passed by invisible\n+   reference.  */\n \n static dw_loc_descr_ref\n-loc_descriptor_from_tree_1 (tree loc, int want_address)\n+loc_by_reference (dw_loc_descr_ref loc, tree decl)\n+{\n+  HOST_WIDE_INT size;\n+  enum dwarf_location_atom op;\n+\n+  if (loc == NULL)\n+    return NULL;\n+\n+  if (!decl_by_reference_p (decl))\n+    return loc;\n+\n+  /* If loc is DW_OP_reg{0...31,x}, don't add DW_OP_deref, instead\n+     change it into corresponding DW_OP_breg{0...31,x} 0.  Then the\n+     location expression is considered to be address of a memory location,\n+     rather than the register itself.  */\n+  if (((loc->dw_loc_opc >= DW_OP_reg0 && loc->dw_loc_opc <= DW_OP_reg31)\n+       || loc->dw_loc_opc == DW_OP_regx)\n+      && (loc->dw_loc_next == NULL\n+\t  || (loc->dw_loc_next->dw_loc_opc == DW_OP_GNU_uninit\n+\t      && loc->dw_loc_next->dw_loc_next == NULL)))\n+    {\n+      if (loc->dw_loc_opc == DW_OP_regx)\n+\t{\n+\t  loc->dw_loc_opc = DW_OP_bregx;\n+\t  loc->dw_loc_oprnd2.v.val_int = 0;\n+\t}\n+      else\n+\t{\n+\t  loc->dw_loc_opc\n+\t    = (enum dwarf_location_atom)\n+\t      (loc->dw_loc_opc + (DW_OP_breg0 - DW_OP_reg0));\n+\t  loc->dw_loc_oprnd1.v.val_int = 0;\n+\t}\n+      return loc;\n+    }\n+\n+  size = int_size_in_bytes (TREE_TYPE (decl));\n+  if (size > DWARF2_ADDR_SIZE || size == -1)\n+    return 0;\n+  else if (size == DWARF2_ADDR_SIZE)\n+    op = DW_OP_deref;\n+  else\n+    op = DW_OP_deref_size;\n+  add_loc_descr (&loc, new_loc_descr (op, size, 0));\n+  return loc;\n+}\n+\n+/* Return dwarf representation of location list representing for\n+   LOC_LIST of DECL.  */\n+\n+static dw_loc_list_ref\n+dw_loc_list (var_loc_list * loc_list, tree decl, bool toplevel)\n+{\n+  const char *endname, *secname;\n+  dw_loc_list_ref list;\n+  rtx varloc;\n+  enum var_init_status initialized;\n+  struct var_loc_node *node;\n+  dw_loc_descr_ref descr;\n+  char label_id[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+  bool by_reference = decl_by_reference_p (decl);\n+\n+  /* Now that we know what section we are using for a base,\n+     actually construct the list of locations.\n+     The first location information is what is passed to the\n+     function that creates the location list, and the remaining\n+     locations just get added on to that list.\n+     Note that we only know the start address for a location\n+     (IE location changes), so to build the range, we use\n+     the range [current location start, next location start].\n+     This means we have to special case the last node, and generate\n+     a range of [last location start, end of function label].  */\n+\n+  node = loc_list->first;\n+  varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n+  secname = secname_for_decl (decl);\n+\n+  if (NOTE_VAR_LOCATION_LOC (node->var_loc_note))\n+    initialized = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n+  else\n+    initialized = VAR_INIT_STATUS_INITIALIZED;\n+\n+  if (!toplevel || by_reference)\n+    {\n+      gcc_assert (GET_CODE (varloc) == VAR_LOCATION);\n+      /* Single part.  */\n+      if (GET_CODE (XEXP (varloc, 1)) != PARALLEL)\n+\tdescr = loc_by_reference (mem_loc_descriptor (XEXP (XEXP (varloc, 1), 0),\n+\t\t\t\t\t\t      TYPE_MODE (TREE_TYPE (decl)),\n+\t\t\t\t\t\t      initialized),\n+\t\t\t\t  decl);\n+      else\n+\tdescr = NULL;\n+    }\n+  else\n+    descr = loc_descriptor (varloc, DECL_MODE (decl), initialized);\n+\n+  if (!current_function_decl)\n+    endname = text_end_label;\n+  else\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n+\t\t\t\t   current_function_funcdef_no);\n+      endname = ggc_strdup (label_id);\n+    }\n+  list = new_loc_list (descr, node->label, node->next ? node->next->label : endname, secname, 1);\n+  node = node->next;\n+\n+  if (!node)\n+    return NULL;\n+\n+  for (; node->next; node = node->next)\n+    if (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n+      {\n+\t/* The variable has a location between NODE->LABEL and\n+\t   NODE->NEXT->LABEL.  */\n+\tenum var_init_status initialized =\n+\t  NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n+\tvarloc = NOTE_VAR_LOCATION (node->var_loc_note);\n+\tif (!toplevel || by_reference)\n+\t  {\n+\t    gcc_assert (GET_CODE (varloc) == VAR_LOCATION);\n+\t    /* Single part.  */\n+\t    if (GET_CODE (XEXP (varloc, 1)) != PARALLEL)\n+\t      descr = mem_loc_descriptor (XEXP (XEXP (varloc, 1), 0),\n+\t      \t\t\t\t  TYPE_MODE (TREE_TYPE (decl)), initialized);\n+\t    else\n+\t      descr = NULL;\n+\t    descr = loc_by_reference (descr, decl);\n+\t  }\n+\telse\n+\t  descr = loc_descriptor (varloc, DECL_MODE (decl), initialized);\n+\tadd_loc_descr_to_loc_list (&list, descr,\n+\t\t\t\t   node->label, node->next->label, secname);\n+      }\n+\n+  /* If the variable has a location at the last label\n+     it keeps its location until the end of function.  */\n+  if (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n+    {\n+      enum var_init_status initialized =\n+\tNOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n+\n+      varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n+      if (!toplevel || by_reference)\n+\t{\n+\t  gcc_assert (GET_CODE (varloc) == VAR_LOCATION);\n+\t  /* Single part.  */\n+\t  if (GET_CODE (XEXP (varloc, 1)) != PARALLEL)\n+\t    descr = mem_loc_descriptor (XEXP (XEXP (varloc, 1), 0),\n+\t    \t\t\t\tTYPE_MODE (TREE_TYPE (decl)), initialized);\n+\t  else\n+\t    descr = NULL;\n+\t  descr = loc_by_reference (descr, decl);\n+\t}\n+      else\n+\tdescr = loc_descriptor (varloc, DECL_MODE (decl), initialized);\n+      add_loc_descr_to_loc_list (&list, descr, node->label, endname, secname);\n+    }\n+  return list;\n+}\n+\n+/* Return single element location list containing loc descr REF.  */\n+\n+static dw_loc_list_ref\n+single_element_loc_list (dw_loc_descr_ref ref)\n+{\n+  return new_loc_list (ref, NULL, NULL, NULL, 0);\n+}\n+\n+/* Return if the loc_list has only single element and thus can be represented\n+   as location description.   */\n+\n+static bool\n+single_element_loc_list_p (dw_loc_list_ref list)\n {\n-  dw_loc_descr_ref ret, ret1;\n+  return (!list->dw_loc_next && !list->begin && !list->end);\n+}\n+\n+/* To each location in list LIST add loc descr REF.  */\n+\n+static void\n+add_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref)\n+{\n+  dw_loc_descr_ref copy;\n+  add_loc_descr (&list->expr, ref);\n+  list = list->dw_loc_next;\n+  while (list)\n+    {\n+      copy = GGC_CNEW (dw_loc_descr_node);\n+      memcpy (copy, ref, sizeof (dw_loc_descr_node));\n+      add_loc_descr (&list->expr, copy);\n+      while (copy->dw_loc_next)\n+\t{\n+\t  dw_loc_descr_ref new_copy = GGC_CNEW (dw_loc_descr_node);\n+\t  memcpy (new_copy, copy->dw_loc_next, sizeof (dw_loc_descr_node));\n+\t  copy->dw_loc_next = new_copy;\n+\t  copy = new_copy;\n+\t}\n+      list = list->dw_loc_next;\n+    }\n+}\n+\n+/* Given two lists RET and LIST\n+   produce location list that is result of adding expression in LIST\n+   to expression in RET on each possition in program.\n+   Might be destructive on both RET and LIST.\n+\n+   TODO: We handle only simple cases of RET or LIST having at most one\n+   element. General case would inolve sorting the lists in program order\n+   and merging them that will need some additional work.  \n+   Adding that will improve quality of debug info especially for SRA-ed\n+   structures.  */\n+\n+static void\n+add_loc_list (dw_loc_list_ref *ret, dw_loc_list_ref list)\n+{\n+  if (!list)\n+    return;\n+  if (!*ret)\n+    {\n+      *ret = list;\n+      return;\n+    }\n+  if (!list->dw_loc_next)\n+    {\n+      add_loc_descr_to_each (*ret, list->expr);\n+      return;\n+    }\n+  if (!(*ret)->dw_loc_next)\n+    {\n+      add_loc_descr_to_each (list, (*ret)->expr);\n+      *ret = list;\n+      return;\n+    }\n+  expansion_failed (NULL_TREE, NULL_RTX,\n+\t\t    \"Don't know how to merge two non-trivial\"\n+\t\t    \" location lists.\\n\");\n+  *ret = NULL;\n+  return;\n+}\n+\n+/* Generate Dwarf location list representing LOC.\n+   If WANT_ADDRESS is false, expression computing LOC will be computed\n+   If WANT_ADDRESS is 1, expression computing address of LOC will be returned\n+   if WANT_ADDRESS is 2, expression computing address useable in location\n+     will be returned (i.e. DW_OP_reg can be used\n+     to refer to register values) \n+   TODO: Dwarf4 adds types to the stack machine that ought to be used here\n+   DW_OP_stack_value will help in cases where we fail to find address of the\n+   expression.\n+ */\n+\n+static dw_loc_list_ref\n+loc_list_from_tree (tree loc, int want_address)\n+{\n+  dw_loc_descr_ref ret = NULL, ret1 = NULL;\n+  dw_loc_list_ref list_ret = NULL, list_ret1 = NULL;\n   int have_address = 0;\n   enum dwarf_location_atom op;\n \n@@ -11992,32 +12295,40 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n   switch (TREE_CODE (loc))\n     {\n     case ERROR_MARK:\n+      expansion_failed (loc, NULL_RTX, \"ERROR_MARK\");\n       return 0;\n \n     case PLACEHOLDER_EXPR:\n       /* This case involves extracting fields from an object to determine the\n \t position of other fields.  We don't try to encode this here.  The\n \t only user of this is Ada, which encodes the needed information using\n \t the names of types.  */\n+      expansion_failed (loc, NULL_RTX, \"PLACEHOLDER_EXPR\");\n       return 0;\n \n     case CALL_EXPR:\n+      expansion_failed (loc, NULL_RTX, \"CALL_EXPR\");\n+      /* There are no opcodes for these operations.  */\n       return 0;\n \n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n+      expansion_failed (loc, NULL_RTX, \"PRE/POST INDCREMENT/DECREMENT\");\n       /* There are no opcodes for these operations.  */\n       return 0;\n \n     case ADDR_EXPR:\n       /* If we already want an address, there's nothing we can do.  */\n       if (want_address)\n-\treturn 0;\n+\t{\n+\t  expansion_failed (loc, NULL_RTX, \"need address of ADDR_EXPR\");\n+\t  return 0;\n+\t}\n \n       /* Otherwise, process the argument and look for the address.  */\n-      return loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 1);\n+      return loc_list_from_tree (TREE_OPERAND (loc, 0), 1);\n \n     case VAR_DECL:\n       if (DECL_THREAD_LOCAL_P (loc))\n@@ -12030,7 +12341,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \t  if (targetm.have_tls)\n \t    {\n \t      /* If this is not defined, we have no way to emit the\n-\t         data.  */\n+\t\t data.  */\n \t      if (!targetm.asm_out.output_dwarf_dtprel)\n \t\treturn 0;\n \n@@ -12077,17 +12388,24 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \n     case PARM_DECL:\n       if (DECL_HAS_VALUE_EXPR_P (loc))\n-\treturn loc_descriptor_from_tree_1 (DECL_VALUE_EXPR (loc),\n-\t\t\t\t\t   want_address);\n+\treturn loc_list_from_tree (DECL_VALUE_EXPR (loc),\n+\t\t\t\t\t      want_address);\n       /* FALLTHRU */\n \n     case RESULT_DECL:\n     case FUNCTION_DECL:\n       {\n \trtx rtl = rtl_for_decl_location (loc);\n+\tvar_loc_list *loc_list = lookup_decl_loc (loc);\n \n-\tif (rtl == NULL_RTX)\n-\t  return 0;\n+\tif (loc_list && loc_list->first\n+\t    && (list_ret = dw_loc_list (loc_list, loc, want_address == 2)))\n+\t  have_address = 1;\n+\telse if (rtl == NULL_RTX)\n+\t  {\n+\t    expansion_failed (loc, NULL_RTX, \"DECL has no RTL\");\n+\t    return 0;\n+\t  }\n \telse if (CONST_INT_P (rtl))\n \t  {\n \t    HOST_WIDE_INT val = INTVAL (rtl);\n@@ -12096,7 +12414,10 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \t    ret = int_loc_descriptor (val);\n \t  }\n \telse if (GET_CODE (rtl) == CONST_STRING)\n-\t  return 0;\n+\t  {\n+\t    expansion_failed (loc, NULL_RTX, \"CONST_STRING\");\n+\t    return 0;\n+\t  }\n \telse if (CONSTANT_P (rtl))\n \t  {\n \t    ret = new_loc_descr (DW_OP_addr, 0, 0);\n@@ -12109,33 +12430,41 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \n \t    /* Certain constructs can only be represented at top-level.  */\n \t    if (want_address == 2)\n-\t      return loc_descriptor (rtl, VOIDmode,\n-\t\t\t\t     VAR_INIT_STATUS_INITIALIZED);\n-\n-\t    mode = GET_MODE (rtl);\n-\t    if (MEM_P (rtl))\n \t      {\n-\t\trtl = XEXP (rtl, 0);\n+\t\tret = loc_descriptor (rtl, VOIDmode,\n+\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n \t\thave_address = 1;\n \t      }\n-\t    ret = mem_loc_descriptor (rtl, mode, VAR_INIT_STATUS_INITIALIZED);\n+\t    else\n+\t      {\n+\t\tmode = GET_MODE (rtl);\n+\t\tif (MEM_P (rtl))\n+\t\t  {\n+\t\t    rtl = XEXP (rtl, 0);\n+\t\t    have_address = 1;\n+\t\t  }\n+\t\tret = mem_loc_descriptor (rtl, mode, VAR_INIT_STATUS_INITIALIZED);\n+\t      }\n+\t    if (!ret)\n+\t      expansion_failed (loc, rtl,\n+\t\t\t\t\"failed to produce loc descriptor for rtl\");\n \t  }\n       }\n       break;\n \n     case INDIRECT_REF:\n-      ret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);\n+      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n       have_address = 1;\n       break;\n \n     case COMPOUND_EXPR:\n-      return loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 1), want_address);\n+      return loc_list_from_tree (TREE_OPERAND (loc, 1), want_address);\n \n     CASE_CONVERT:\n     case VIEW_CONVERT_EXPR:\n     case SAVE_EXPR:\n     case MODIFY_EXPR:\n-      return loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), want_address);\n+      return loc_list_from_tree (TREE_OPERAND (loc, 0), want_address);\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n@@ -12151,26 +12480,35 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \tobj = get_inner_reference (loc, &bitsize, &bitpos, &offset, &mode,\n \t\t\t\t   &unsignedp, &volatilep, false);\n \n-\tif (obj == loc)\n-\t  return 0;\n+\tgcc_assert (obj != loc);\n \n-\tret = loc_descriptor_from_tree_1 (obj, 1);\n-\tif (ret == 0\n-\t    || bitpos % BITS_PER_UNIT != 0 || bitsize % BITS_PER_UNIT != 0)\n+\tlist_ret = loc_list_from_tree (obj, 1);\n+\tif (list_ret == 0)\n \t  return 0;\n+\tif (bitpos % BITS_PER_UNIT != 0 || bitsize % BITS_PER_UNIT != 0)\n+\t  {\n+\t    expansion_failed (loc, NULL_RTX,\n+\t\t\t      \"bitfield access\");\n+\t    return 0;\n+\t  }\n \n \tif (offset != NULL_TREE)\n \t  {\n \t    /* Variable offset.  */\n-\t    ret1 = loc_descriptor_from_tree_1 (offset, 0);\n-\t    if (ret1 == 0)\n+\t    list_ret1 = loc_list_from_tree (offset, 0);\n+\t    if (list_ret1 == 0)\n \t      return 0;\n-\t    add_loc_descr (&ret, ret1);\n-\t    add_loc_descr (&ret, new_loc_descr (DW_OP_plus, 0, 0));\n+\t    add_loc_list (&list_ret, list_ret1);\n+\t    if (!list_ret)\n+\t      return 0;\n+\t    add_loc_descr_to_each (list_ret, new_loc_descr (DW_OP_plus, 0, 0));\n \t  }\n \n \tbytepos = bitpos / BITS_PER_UNIT;\n-\tloc_descr_plus_const (&ret, bytepos);\n+\tif (bytepos > 0)\n+\t  add_loc_descr_to_each (list_ret, new_loc_descr (DW_OP_plus_uconst, bytepos, 0));\n+\telse if (bytepos < 0)\n+\t  loc_list_plus_const (list_ret, bytepos); \n \n \thave_address = 1;\n \tbreak;\n@@ -12180,7 +12518,11 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n       if (host_integerp (loc, 0))\n \tret = int_loc_descriptor (tree_low_cst (loc, 0));\n       else\n-\treturn 0;\n+\t{\n+\t  expansion_failed (loc, NULL_RTX,\n+\t\t\t    \"Integer operand is not host integer\");\n+\t  return 0;\n+\t}\n       break;\n \n     case CONSTRUCTOR:\n@@ -12250,11 +12592,11 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n       if (TREE_CODE (TREE_OPERAND (loc, 1)) == INTEGER_CST\n \t  && host_integerp (TREE_OPERAND (loc, 1), 0))\n \t{\n-\t  ret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);\n-\t  if (ret == 0)\n+\t  list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n+\t  if (list_ret == 0)\n \t    return 0;\n \n-\t  loc_descr_plus_const (&ret, tree_low_cst (TREE_OPERAND (loc, 1), 0));\n+\t  loc_list_plus_const (list_ret, tree_low_cst (TREE_OPERAND (loc, 1), 0));\n \t  break;\n \t}\n \n@@ -12298,13 +12640,15 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n       goto do_binop;\n \n     do_binop:\n-      ret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);\n-      ret1 = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 1), 0);\n-      if (ret == 0 || ret1 == 0)\n+      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n+      list_ret1 = loc_list_from_tree (TREE_OPERAND (loc, 1), 0);\n+      if (list_ret == 0 || list_ret1 == 0)\n \treturn 0;\n \n-      add_loc_descr (&ret, ret1);\n-      add_loc_descr (&ret, new_loc_descr (op, 0, 0));\n+      add_loc_list (&list_ret, list_ret1);\n+      if (list_ret == 0)\n+\treturn 0;\n+      add_loc_descr_to_each (list_ret, new_loc_descr (op, 0, 0));\n       break;\n \n     case TRUTH_NOT_EXPR:\n@@ -12321,11 +12665,11 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n       goto do_unop;\n \n     do_unop:\n-      ret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);\n-      if (ret == 0)\n+      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n+      if (list_ret == 0)\n \treturn 0;\n \n-      add_loc_descr (&ret, new_loc_descr (op, 0, 0));\n+      add_loc_descr_to_each (list_ret, new_loc_descr (op, 0, 0));\n       break;\n \n     case MIN_EXPR:\n@@ -12345,29 +12689,29 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n     case COND_EXPR:\n       {\n \tdw_loc_descr_ref lhs\n-\t  = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 1), 0);\n-\tdw_loc_descr_ref rhs\n-\t  = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 2), 0);\n+\t  = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0);\n+\tdw_loc_list_ref rhs\n+\t  = loc_list_from_tree (TREE_OPERAND (loc, 2), 0);\n \tdw_loc_descr_ref bra_node, jump_node, tmp;\n \n-\tret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);\n-\tif (ret == 0 || lhs == 0 || rhs == 0)\n+\tlist_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n+\tif (list_ret == 0 || lhs == 0 || rhs == 0)\n \t  return 0;\n \n \tbra_node = new_loc_descr (DW_OP_bra, 0, 0);\n-\tadd_loc_descr (&ret, bra_node);\n+\tadd_loc_descr_to_each (list_ret, bra_node);\n \n-\tadd_loc_descr (&ret, rhs);\n+\tadd_loc_list (&list_ret, rhs);\n \tjump_node = new_loc_descr (DW_OP_skip, 0, 0);\n-\tadd_loc_descr (&ret, jump_node);\n+\tadd_loc_descr_to_each (list_ret, jump_node);\n \n-\tadd_loc_descr (&ret, lhs);\n+\tadd_loc_descr_to_each (list_ret, lhs);\n \tbra_node->dw_loc_oprnd1.val_class = dw_val_class_loc;\n \tbra_node->dw_loc_oprnd1.v.val_loc = lhs;\n \n \t/* ??? Need a node to point the skip at.  Use a nop.  */\n \ttmp = new_loc_descr (DW_OP_nop, 0, 0);\n-\tadd_loc_descr (&ret, tmp);\n+\tadd_loc_descr_to_each (list_ret, tmp);\n \tjump_node->dw_loc_oprnd1.val_class = dw_val_class_loc;\n \tjump_node->dw_loc_oprnd1.v.val_loc = tmp;\n       }\n@@ -12381,7 +12725,11 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \t up, for instance, with the C STMT_EXPR.  */\n       if ((unsigned int) TREE_CODE (loc)\n \t  >= (unsigned int) LAST_AND_UNUSED_TREE_CODE)\n-\treturn 0;\n+\t{\n+\t  expansion_failed (loc, NULL_RTX,\n+\t\t\t    \"language specific tree node\");\n+\t  return 0;\n+\t}\n \n #ifdef ENABLE_CHECKING\n       /* Otherwise this is a generic code; we should just lists all of\n@@ -12394,32 +12742,60 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n #endif\n     }\n \n+  if (!ret && !list_ret)\n+    return 0;\n+\n   /* Show if we can't fill the request for an address.  */\n   if (want_address && !have_address)\n-    return 0;\n+    {\n+      expansion_failed (loc, NULL_RTX,\n+\t\t\t\"Want address and only have value\");\n+      return 0;\n+    }\n+\n+  gcc_assert (!ret || !list_ret);\n \n   /* If we've got an address and don't want one, dereference.  */\n-  if (!want_address && have_address && ret)\n+  if (!want_address && have_address)\n     {\n       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (loc));\n \n       if (size > DWARF2_ADDR_SIZE || size == -1)\n-\treturn 0;\n+\t{\n+\t  expansion_failed (loc, NULL_RTX,\n+\t\t\t    \"DWARF address size mismatch\");\n+\t  return 0;\n+\t}\n       else if (size == DWARF2_ADDR_SIZE)\n \top = DW_OP_deref;\n       else\n \top = DW_OP_deref_size;\n \n-      add_loc_descr (&ret, new_loc_descr (op, size, 0));\n+      if (ret)\n+\tadd_loc_descr (&ret, new_loc_descr (op, size, 0));\n+      else\n+\tadd_loc_descr_to_each (list_ret, new_loc_descr (op, size, 0));\n     }\n+  if (ret)\n+    list_ret = single_element_loc_list (ret);\n \n-  return ret;\n+  return list_ret;\n }\n \n-static inline dw_loc_descr_ref\n-loc_descriptor_from_tree (tree loc)\n+/* Same as above but return only single location expression.  */\n+static dw_loc_descr_ref\n+loc_descriptor_from_tree (tree loc, int want_address)\n {\n-  return loc_descriptor_from_tree_1 (loc, 2);\n+  dw_loc_list_ref ret = loc_list_from_tree (loc, want_address);\n+  if (!ret)\n+    return NULL;\n+  if (ret->dw_loc_next)\n+    {\n+      expansion_failed (loc, NULL_RTX,\n+\t\t\t\"Location list where only loc descriptor needed\");\n+      return NULL;\n+    }\n+  return ret->expr;\n }\n \n /* Given a value, round it up to the lowest multiple of `boundary'\n@@ -12529,9 +12905,9 @@ field_byte_offset (const_tree decl)\n       field_size_tree = DECL_SIZE (decl);\n \n       /* The size could be unspecified if there was an error, or for\n-         a flexible array member.  */\n+\t a flexible array member.  */\n       if (!field_size_tree)\n-        field_size_tree = bitsize_zero_node;\n+\tfield_size_tree = bitsize_zero_node;\n \n       /* If the size of the field is not constant, use the type size.  */\n       if (host_integerp (field_size_tree, 1))\n@@ -12626,10 +13002,14 @@ field_byte_offset (const_tree decl)\n \n static inline void\n add_AT_location_description (dw_die_ref die, enum dwarf_attribute attr_kind,\n-\t\t\t     dw_loc_descr_ref descr)\n+\t\t\t     dw_loc_list_ref descr)\n {\n-  if (descr != 0)\n-    add_AT_loc (die, attr_kind, descr);\n+  if (descr == 0)\n+    return;\n+  if (single_element_loc_list_p (descr))\n+    add_AT_loc (die, attr_kind, descr->expr);\n+  else\n+    add_AT_loc_list (die, attr_kind, descr);\n }\n \n /* Attach the specialized form of location attribute used for data members of\n@@ -13267,36 +13647,6 @@ rtl_for_decl_location (tree decl)\n   return rtl;\n }\n \n-/* We need to figure out what section we should use as the base for the\n-   address ranges where a given location is valid.\n-   1. If this particular DECL has a section associated with it, use that.\n-   2. If this function has a section associated with it, use that.\n-   3. Otherwise, use the text section.\n-   XXX: If you split a variable across multiple sections, we won't notice.  */\n-\n-static const char *\n-secname_for_decl (const_tree decl)\n-{\n-  const char *secname;\n-\n-  if (VAR_OR_FUNCTION_DECL_P (decl) && DECL_SECTION_NAME (decl))\n-    {\n-      tree sectree = DECL_SECTION_NAME (decl);\n-      secname = TREE_STRING_POINTER (sectree);\n-    }\n-  else if (current_function_decl && DECL_SECTION_NAME (current_function_decl))\n-    {\n-      tree sectree = DECL_SECTION_NAME (current_function_decl);\n-      secname = TREE_STRING_POINTER (sectree);\n-    }\n-  else if (cfun && in_cold_section_p)\n-    secname = crtl->subsections.cold_section_label;\n-  else\n-    secname = text_section_label;\n-\n-  return secname;\n-}\n-\n /* Check whether decl is a Fortran COMMON symbol.  If not, NULL_TREE is\n    returned.  If so, the decl for the COMMON block is returned, and the\n    value is the offset into the common block for the symbol.  */\n@@ -13347,60 +13697,6 @@ fortran_common (tree decl, HOST_WIDE_INT *value)\n   return cvar;\n }\n \n-/* Dereference a location expression LOC if DECL is passed by invisible\n-   reference.  */\n-\n-static dw_loc_descr_ref\n-loc_by_reference (dw_loc_descr_ref loc, tree decl)\n-{\n-  HOST_WIDE_INT size;\n-  enum dwarf_location_atom op;\n-\n-  if (loc == NULL)\n-    return NULL;\n-\n-  if ((TREE_CODE (decl) != PARM_DECL\n-       && TREE_CODE (decl) != RESULT_DECL\n-       && TREE_CODE (decl) != VAR_DECL)\n-      || !DECL_BY_REFERENCE (decl))\n-    return loc;\n-\n-  /* If loc is DW_OP_reg{0...31,x}, don't add DW_OP_deref, instead\n-     change it into corresponding DW_OP_breg{0...31,x} 0.  Then the\n-     location expression is considered to be address of a memory location,\n-     rather than the register itself.  */\n-  if (((loc->dw_loc_opc >= DW_OP_reg0 && loc->dw_loc_opc <= DW_OP_reg31)\n-       || loc->dw_loc_opc == DW_OP_regx)\n-      && (loc->dw_loc_next == NULL\n-\t  || (loc->dw_loc_next->dw_loc_opc == DW_OP_GNU_uninit\n-\t      && loc->dw_loc_next->dw_loc_next == NULL)))\n-    {\n-      if (loc->dw_loc_opc == DW_OP_regx)\n-\t{\n-\t  loc->dw_loc_opc = DW_OP_bregx;\n-\t  loc->dw_loc_oprnd2.v.val_int = 0;\n-\t}\n-      else\n-\t{\n-\t  loc->dw_loc_opc\n-\t    = (enum dwarf_location_atom)\n-\t      (loc->dw_loc_opc + (DW_OP_breg0 - DW_OP_reg0));\n-\t  loc->dw_loc_oprnd1.v.val_int = 0;\n-\t}\n-      return loc;\n-    }\n-\n-  size = int_size_in_bytes (TREE_TYPE (decl));\n-  if (size > DWARF2_ADDR_SIZE || size == -1)\n-    return 0;\n-  else if (size == DWARF2_ADDR_SIZE)\n-    op = DW_OP_deref;\n-  else\n-    op = DW_OP_deref_size;\n-  add_loc_descr (&loc, new_loc_descr (op, size, 0));\n-  return loc;\n-}\n-\n /* Generate *either* a DW_AT_location attribute or else a DW_AT_const_value\n    data attribute for a variable or a parameter.  We generate the\n    DW_AT_const_value attribute only in those cases where the given variable\n@@ -13418,6 +13714,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n {\n   rtx rtl;\n   dw_loc_descr_ref descr;\n+  dw_loc_list_ref descr_list;\n   var_loc_list *loc_list;\n   struct var_loc_node *node;\n   if (TREE_CODE (decl) == ERROR_MARK)\n@@ -13539,18 +13836,18 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       if (descr)\n \t{\n \t  descr = loc_by_reference (descr, decl);\n-\t  add_AT_location_description (die, attr, descr);\n+\t  add_AT_location_description (die, attr, single_element_loc_list (descr));\n \t  return;\n \t}\n     }\n \n   /* We couldn't get any rtl, so try directly generating the location\n      description from the tree.  */\n-  descr = loc_descriptor_from_tree (decl);\n-  if (descr)\n+  descr_list = loc_list_from_tree (decl, 2);\n+  if (descr_list)\n     {\n       descr = loc_by_reference (descr, decl);\n-      add_AT_location_description (die, attr, descr);\n+      add_AT_location_description (die, attr, descr_list);\n       return;\n     }\n   /* None of that worked, so it must not really have a location;\n@@ -13967,7 +14264,7 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n     case RESULT_DECL:\n       {\n \tdw_die_ref decl_die = lookup_decl_die (bound);\n-\tdw_loc_descr_ref loc;\n+\tdw_loc_list_ref loc;\n \n \t/* ??? Can this happen, or should the variable have been bound\n \t   first?  Probably it can, since I imagine that we try to create\n@@ -13978,7 +14275,7 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n \t  add_AT_die_ref (subrange_die, bound_attr, decl_die);\n \telse\n \t  {\n-\t    loc = loc_descriptor_from_tree_1 (bound, 0);\n+\t    loc = loc_list_from_tree (bound, 0);\n \t    add_AT_location_description (subrange_die, bound_attr, loc);\n \t  }\n \tbreak;\n@@ -13990,10 +14287,10 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n \t   evaluate the value of the array bound.  */\n \n \tdw_die_ref ctx, decl_die;\n-\tdw_loc_descr_ref loc;\n+\tdw_loc_list_ref list;\n \n-\tloc = loc_descriptor_from_tree (bound);\n-\tif (loc == NULL)\n+\tlist = loc_list_from_tree (bound, 2);\n+\tif (list == NULL)\n \t  break;\n \n \tif (current_function_decl == 0)\n@@ -14004,7 +14301,10 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n \tdecl_die = new_die (DW_TAG_variable, ctx, bound);\n \tadd_AT_flag (decl_die, DW_AT_artificial, 1);\n \tadd_type_attribute (decl_die, TREE_TYPE (bound), 1, 0, ctx);\n-\tadd_AT_loc (decl_die, DW_AT_location, loc);\n+\tif (list->dw_loc_next)\n+\t  add_AT_loc_list (decl_die, DW_AT_location, list);\n+\telse\n+\t  add_AT_loc (decl_die, DW_AT_location, list->expr);\n \n \tadd_AT_die_ref (subrange_die, bound_attr, decl_die);\n \tbreak;\n@@ -14610,12 +14910,12 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n \t       && DECL_P (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n \t{\n \t  tree szdecl = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-\t  dw_loc_descr_ref loc = loc_descriptor_from_tree (szdecl);\n+\t  dw_loc_list_ref loc = loc_list_from_tree (szdecl, 2);\n \n \t  size = int_size_in_bytes (TREE_TYPE (szdecl));\n \t  if (loc && size > 0)\n \t    {\n-\t      add_AT_loc (array_die, DW_AT_string_length, loc);\n+\t      add_AT_location_description (array_die, DW_AT_string_length, loc);\n \t      if (size != DWARF2_ADDR_SIZE)\n \t\tadd_AT_unsigned (array_die, DW_AT_byte_size, size);\n \t    }\n@@ -14709,7 +15009,7 @@ descr_info_loc (tree val, tree base_decl)\n     CASE_CONVERT:\n       return descr_info_loc (TREE_OPERAND (val, 0), base_decl);\n     case VAR_DECL:\n-      return loc_descriptor_from_tree_1 (val, 0);\n+      return loc_descriptor_from_tree (val, 0);\n     case INTEGER_CST:\n       if (host_integerp (val, 0))\n \treturn int_loc_descriptor (tree_low_cst (val, 0));\n@@ -15015,7 +15315,7 @@ gen_formal_parameter_die (tree node, tree origin, dw_die_ref context_die)\n \t{\n \t  tree type = TREE_TYPE (node);\n \t  add_name_and_src_coords_attributes (parm_die, node);\n-\t  if (DECL_BY_REFERENCE (node))\n+\t  if (decl_by_reference_p (node))\n \t    add_type_attribute (parm_die, TREE_TYPE (type), 0, 0,\n \t\t\t\tcontext_die);\n \t  else\n@@ -15467,7 +15767,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n       if (cfun->static_chain_decl)\n \tadd_AT_location_description (subr_die, DW_AT_static_link,\n-\t\t loc_descriptor_from_tree (cfun->static_chain_decl));\n+\t\t loc_list_from_tree (cfun->static_chain_decl, 2));\n     }\n \n   /* Generate child dies for template paramaters.  */\n@@ -15637,30 +15937,31 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n     {\n       tree field;\n       dw_die_ref com_die;\n-      dw_loc_descr_ref loc;\n+      dw_loc_list_ref loc;\n       die_node com_die_arg;\n \n       var_die = lookup_decl_die (decl_or_origin);\n       if (var_die)\n \t{\n \t  if (get_AT (var_die, DW_AT_location) == NULL)\n \t    {\n-\t      loc = loc_descriptor_from_tree (com_decl);\n+\t      loc = loc_list_from_tree (com_decl, off ? 1 : 2);\n \t      if (loc)\n \t\t{\n \t\t  if (off)\n \t\t    {\n \t\t      /* Optimize the common case.  */\n-\t\t      if (loc->dw_loc_opc == DW_OP_addr\n-\t\t\t  && loc->dw_loc_next == NULL\n-\t\t\t  && GET_CODE (loc->dw_loc_oprnd1.v.val_addr)\n+\t\t      if (single_element_loc_list_p (loc)\n+\t\t\t  && loc->expr->dw_loc_opc == DW_OP_addr\n+\t\t\t  && loc->expr->dw_loc_next == NULL\n+\t\t\t  && GET_CODE (loc->expr->dw_loc_oprnd1.v.val_addr)\n \t\t\t     == SYMBOL_REF)\n-\t\t\tloc->dw_loc_oprnd1.v.val_addr\n-\t\t\t  = plus_constant (loc->dw_loc_oprnd1.v.val_addr, off);\n+\t\t\tloc->expr->dw_loc_oprnd1.v.val_addr\n+\t\t\t  = plus_constant (loc->expr->dw_loc_oprnd1.v.val_addr, off);\n \t\t\telse\n-\t\t\t  loc_descr_plus_const (&loc, off);\n+\t\t\t  loc_list_plus_const (loc, off);\n \t\t    }\n-\t\t  add_AT_loc (var_die, DW_AT_location, loc);\n+\t\t  add_AT_location_description (var_die, DW_AT_location, loc);\n \t\t  remove_AT (var_die, DW_AT_declaration);\n \t\t}\n \t    }\n@@ -15676,7 +15977,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n       com_die_arg.decl_id = DECL_UID (com_decl);\n       com_die_arg.die_parent = context_die;\n       com_die = (dw_die_ref) htab_find (common_block_die_table, &com_die_arg);\n-      loc = loc_descriptor_from_tree (com_decl);\n+      loc = loc_list_from_tree (com_decl, 2);\n       if (com_die == NULL)\n \t{\n \t  const char *cnam\n@@ -15687,10 +15988,10 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t  add_name_and_src_coords_attributes (com_die, com_decl);\n \t  if (loc)\n \t    {\n-\t      add_AT_loc (com_die, DW_AT_location, loc);\n+\t      add_AT_location_description (com_die, DW_AT_location, loc);\n \t      /* Avoid sharing the same loc descriptor between\n \t\t DW_TAG_common_block and DW_TAG_variable.  */\n-\t      loc = loc_descriptor_from_tree (com_decl);\n+\t      loc = loc_list_from_tree (com_decl, 2);\n \t    }\n           else if (DECL_EXTERNAL (decl))\n \t    add_AT_flag (com_die, DW_AT_declaration, 1);\n@@ -15701,8 +16002,8 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t}\n       else if (get_AT (com_die, DW_AT_location) == NULL && loc)\n \t{\n-\t  add_AT_loc (com_die, DW_AT_location, loc);\n-\t  loc = loc_descriptor_from_tree (com_decl);\n+\t  add_AT_location_description (com_die, DW_AT_location, loc);\n+\t  loc = loc_list_from_tree (com_decl, 2);\n \t  remove_AT (com_die, DW_AT_declaration);\n \t}\n       var_die = new_die (DW_TAG_variable, com_die, decl);\n@@ -15715,15 +16016,16 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t  if (off)\n \t    {\n \t      /* Optimize the common case.  */\n-\t      if (loc->dw_loc_opc == DW_OP_addr\n-\t\t  && loc->dw_loc_next == NULL\n-\t\t  && GET_CODE (loc->dw_loc_oprnd1.v.val_addr) == SYMBOL_REF)\n-\t\tloc->dw_loc_oprnd1.v.val_addr\n-\t\t  = plus_constant (loc->dw_loc_oprnd1.v.val_addr, off);\n+\t      if (single_element_loc_list_p (loc)\n+\t\t  && loc->expr->dw_loc_opc == DW_OP_addr\n+\t\t  && loc->expr->dw_loc_next == NULL\n+\t\t  && GET_CODE (loc->expr->dw_loc_oprnd1.v.val_addr) == SYMBOL_REF)\n+\t\tloc->expr->dw_loc_oprnd1.v.val_addr\n+\t\t  = plus_constant (loc->expr->dw_loc_oprnd1.v.val_addr, off);\n \t      else\n-\t\tloc_descr_plus_const (&loc, off);\n+\t\tloc_list_plus_const (loc, off);\n \t    }\n-\t  add_AT_loc (var_die, DW_AT_location, loc);\n+\t  add_AT_location_description (var_die, DW_AT_location, loc);\n \t}\n       else if (DECL_EXTERNAL (decl))\n \tadd_AT_flag (var_die, DW_AT_declaration, 1);\n@@ -15786,10 +16088,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n       tree type = TREE_TYPE (decl);\n \n       add_name_and_src_coords_attributes (var_die, decl);\n-      if ((TREE_CODE (decl) == PARM_DECL\n-\t   || TREE_CODE (decl) == RESULT_DECL\n-\t   || TREE_CODE (decl) == VAR_DECL)\n-\t  && DECL_BY_REFERENCE (decl))\n+      if (decl_by_reference_p (decl))\n \tadd_type_attribute (var_die, TREE_TYPE (type), 0, 0, context_die);\n       else\n \tadd_type_attribute (var_die, type, TREE_READONLY (decl),\n@@ -17066,9 +17365,7 @@ gen_decl_die (tree decl, tree origin, dw_die_ref context_die)\n \n       /* Output any DIEs that are needed to specify the type of this data\n \t object.  */\n-      if ((TREE_CODE (decl_or_origin) == RESULT_DECL\n-\t   || TREE_CODE (decl_or_origin) == VAR_DECL)\n-          && DECL_BY_REFERENCE (decl_or_origin))\n+      if (decl_by_reference_p (decl_or_origin))\n \tgen_type_die (TREE_TYPE (TREE_TYPE (decl_or_origin)), context_die);\n       else\n \tgen_type_die (TREE_TYPE (decl_or_origin), context_die);"}, {"sha": "cd36860455f07ce1c224ce51934f47bc97181d74", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f373fa6952ad2c1bc8980dc29f584127ee0171/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f373fa6952ad2c1bc8980dc29f584127ee0171/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=e7f373fa6952ad2c1bc8980dc29f584127ee0171", "patch": "@@ -4304,7 +4304,7 @@ struct rtl_opt_pass pass_final =\n {\n  {\n   RTL_PASS,\n-  NULL,                                 /* name */\n+  \"final\",                              /* name */\n   NULL,                                 /* gate */\n   rest_of_handle_final,                 /* execute */\n   NULL,                                 /* sub */"}]}