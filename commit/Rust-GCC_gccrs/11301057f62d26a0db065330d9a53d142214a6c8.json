{"sha": "11301057f62d26a0db065330d9a53d142214a6c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEzMDEwNTdmNjJkMjZhMGRiMDY1MzMwZDlhNTNkMTQyMjE0YTZjOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-12-29T12:02:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-12-29T12:02:15Z"}, "message": "sparc.c (input_operand): Recognize (const (constant_p_rtx)).\n\n        * sparc.c (input_operand): Recognize (const (constant_p_rtx)).\n        (arith_operand): Remove constant_p_rtx handling.\n        (const64_operand, const64_high_operand): Likewise.\n        (arith11_operand, arith10_operand, arith_double_operand): Likewise.\n        (arith11_double_operand, arith10_double_operand, small_int): Likewise.\n        (small_int_or_double, uns_small_int, zero_operand): Likewise.\n        * sparc.h (PREDICATE_CODES): Likewise.\n\nFrom-SVN: r24440", "tree": {"sha": "c23c138ac7cae260dd5f806c453cae3a42d2df4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c23c138ac7cae260dd5f806c453cae3a42d2df4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11301057f62d26a0db065330d9a53d142214a6c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11301057f62d26a0db065330d9a53d142214a6c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11301057f62d26a0db065330d9a53d142214a6c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11301057f62d26a0db065330d9a53d142214a6c8/comments", "author": null, "committer": null, "parents": [{"sha": "185ebd6c71d791ea2f333a23382589620e9bf848", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/185ebd6c71d791ea2f333a23382589620e9bf848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/185ebd6c71d791ea2f333a23382589620e9bf848"}], "stats": {"total": 144, "additions": 71, "deletions": 73}, "files": [{"sha": "c33075b3b5c77335d19280b7ecb8443205d88848", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11301057f62d26a0db065330d9a53d142214a6c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11301057f62d26a0db065330d9a53d142214a6c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=11301057f62d26a0db065330d9a53d142214a6c8", "patch": "@@ -1,3 +1,13 @@\n+Tue Dec 29 11:58:53 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* sparc.c (input_operand): Recognize (const (constant_p_rtx)).\n+\t(arith_operand): Remove constant_p_rtx handling.\n+\t(const64_operand, const64_high_operand): Likewise.\n+\t(arith11_operand, arith10_operand, arith_double_operand): Likewise.\n+\t(arith11_double_operand, arith10_double_operand, small_int): Likewise.\n+\t(small_int_or_double, uns_small_int, zero_operand): Likewise.\n+\t* sparc.h (PREDICATE_CODES): Likewise.\n+\n Tue Dec 29 11:32:54 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>:\n \n \t* rtl.def (CONSTANT_P_RTX): Clarify commentary."}, {"sha": "2748a9ad643e3ea60b5f2b496d03b0c24fd43e31", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11301057f62d26a0db065330d9a53d142214a6c8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11301057f62d26a0db065330d9a53d142214a6c8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=11301057f62d26a0db065330d9a53d142214a6c8", "patch": "@@ -792,8 +792,7 @@ arith_operand (op, mode)\n      enum machine_mode mode;\n {\n   int val;\n-  if (register_operand (op, mode)\n-      || GET_CODE (op) == CONSTANT_P_RTX)\n+  if (register_operand (op, mode))\n     return 1;\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -842,7 +841,7 @@ const64_operand (op, mode)\n \t\t  ((CONST_DOUBLE_LOW (op) & 0x80000000) != 0 ?\n \t\t   (HOST_WIDE_INT)0xffffffff : 0)))\n #endif\n-\t  || GET_CODE (op) == CONSTANT_P_RTX);\n+\t  );\n }\n \n /* The same, but only for sethi instructions.  */\n@@ -864,8 +863,7 @@ const64_high_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_DOUBLE\n \t      && CONST_DOUBLE_HIGH (op) == 0\n \t      && (CONST_DOUBLE_LOW (op) & 0xfffffc00) != 0\n-\t      && SPARC_SETHI_P (CONST_DOUBLE_LOW (op)))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX);\n+\t      && SPARC_SETHI_P (CONST_DOUBLE_LOW (op))));\n }\n \n /* Return true if OP is a register, or is a CONST_INT that can fit in a\n@@ -878,7 +876,6 @@ arith11_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || (GET_CODE (op) == CONST_INT && SPARC_SIMM11_P (INTVAL (op))));\n }\n \n@@ -892,7 +889,6 @@ arith10_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || (GET_CODE (op) == CONST_INT && SPARC_SIMM10_P (INTVAL (op))));\n }\n \n@@ -909,7 +905,6 @@ arith_double_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n \t  || (! TARGET_ARCH64\n \t      && GET_CODE (op) == CONST_DOUBLE\n@@ -959,7 +954,6 @@ arith11_double_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || (GET_CODE (op) == CONST_DOUBLE\n \t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n \t      && (unsigned HOST_WIDE_INT) (CONST_DOUBLE_LOW (op) + 0x400) < 0x800\n@@ -983,7 +977,6 @@ arith10_double_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || (GET_CODE (op) == CONST_DOUBLE\n \t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n \t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x200) < 0x400\n@@ -1005,8 +998,7 @@ small_int (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  return ((GET_CODE (op) == CONST_INT && SMALL_INT (op))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX);\n+  return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n }\n \n int\n@@ -1017,8 +1009,7 @@ small_int_or_double (op, mode)\n   return ((GET_CODE (op) == CONST_INT && SMALL_INT (op))\n \t  || (GET_CODE (op) == CONST_DOUBLE\n \t      && CONST_DOUBLE_HIGH (op) == 0\n-\t      && SPARC_SIMM13_P (CONST_DOUBLE_LOW (op)))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX);\n+\t      && SPARC_SIMM13_P (CONST_DOUBLE_LOW (op))));\n }\n \n /* Recognize operand values for the umul instruction.  That instruction sign\n@@ -1032,17 +1023,15 @@ uns_small_int (op, mode)\n {\n #if HOST_BITS_PER_WIDE_INT > 32\n   /* All allowed constants will fit a CONST_INT.  */\n-  return ((GET_CODE (op) == CONST_INT\n-\t   && ((INTVAL (op) >= 0 && INTVAL (op) < 0x1000)\n-\t       || (INTVAL (op) >= 0xFFFFF000\n-                   && INTVAL (op) < 0x100000000)))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX);\n+  return (GET_CODE (op) == CONST_INT\n+\t  && ((INTVAL (op) >= 0 && INTVAL (op) < 0x1000)\n+\t      || (INTVAL (op) >= 0xFFFFF000\n+                  && INTVAL (op) < 0x100000000)));\n #else\n-  return (((GET_CODE (op) == CONST_INT && (unsigned) INTVAL (op) < 0x1000)\n-\t   || (GET_CODE (op) == CONST_DOUBLE\n-\t       && CONST_DOUBLE_HIGH (op) == 0\n-\t       && (unsigned) CONST_DOUBLE_LOW (op) - 0xFFFFF000 < 0x1000))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX);\n+  return ((GET_CODE (op) == CONST_INT && (unsigned) INTVAL (op) < 0x1000)\n+\t  || (GET_CODE (op) == CONST_DOUBLE\n+\t      && CONST_DOUBLE_HIGH (op) == 0\n+\t      && (unsigned) CONST_DOUBLE_LOW (op) - 0xFFFFF000 < 0x1000));\n #endif\n }\n \n@@ -1070,7 +1059,7 @@ zero_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  return (op == const0_rtx || GET_CODE (op) == CONSTANT_P_RTX);\n+  return op == const0_rtx;\n }\n \n /* Return 1 if OP is a valid operand for the source of a move insn.  */\n@@ -1084,6 +1073,10 @@ input_operand (op, mode)\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n+  /* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */\n+  if (GET_CODE (op) == CONST && GET_CODE (XEXP (op, 0)) == CONSTANT_P_RTX)\n+    return 1;\n+\n   /* Allow any one instruction integer constant, and all CONST_INT\n      variants when we are working in DImode and !arch64.  */\n   if (GET_MODE_CLASS (mode) == MODE_INT\n@@ -1112,10 +1105,6 @@ input_operand (op, mode)\n \t\t  ))))\n     return 1;\n \n-  /* Always match this.  */\n-  if (GET_CODE (op) == CONSTANT_P_RTX)\n-    return 1;\n-\n   /* If !arch64 and this is a DImode const, allow it so that\n      the splits can be generated.  */\n   if (! TARGET_ARCH64"}, {"sha": "a0ecb146f0beb4c3f403f91d3fc5d2348e6b1802", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11301057f62d26a0db065330d9a53d142214a6c8/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11301057f62d26a0db065330d9a53d142214a6c8/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=11301057f62d26a0db065330d9a53d142214a6c8", "patch": "@@ -3276,50 +3276,49 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Define the codes that are matched by predicates in sparc.c.  */\n \n-#define PREDICATE_CODES\t\t\t\t\t\t\t\t    \\\n-{\"reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t\t    \\\n-{\"fp_zero_operand\", {CONST_DOUBLE}},\t\t\t\t\t\t    \\\n-{\"intreg_operand\", {SUBREG, REG}},\t\t\t\t\t\t    \\\n-{\"fcc_reg_operand\", {REG}},\t\t\t\t\t\t\t    \\\n-{\"icc_or_fcc_reg_operand\", {REG}},\t\t\t\t\t\t    \\\n-{\"restore_operand\", {REG}},\t\t\t\t\t\t\t    \\\n-{\"call_operand\", {MEM}},\t\t\t\t\t\t\t    \\\n-{\"call_operand_address\", {SYMBOL_REF, LABEL_REF, CONST, CONST_DOUBLE, ADDRESSOF,    \\\n-                          SUBREG, REG, PLUS, LO_SUM, CONST_INT}},\t\t    \\\n-{\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST, CONST_DOUBLE}},\t\t    \\\n-{\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\t\t    \\\n-{\"label_ref_operand\", {LABEL_REF}},\t\t\t\t\t\t    \\\n-{\"sp64_medium_pic_operand\", {CONST}},\t\t\t\t\t\t    \\\n-{\"data_segment_operand\", {SYMBOL_REF, PLUS, CONST}},\t\t\t\t    \\\n-{\"text_segment_operand\", {LABEL_REF, SYMBOL_REF, PLUS, CONST}},\t\t\t    \\\n-{\"reg_or_nonsymb_mem_operand\", {SUBREG, REG, MEM}},\t\t\t\t    \\\n-{\"splittable_symbolic_memory_operand\", {MEM}},\t\t\t\t\t    \\\n-{\"splittable_immediate_memory_operand\", {MEM}},\t\t\t\t\t    \\\n-{\"eq_or_neq\", {EQ, NE}},\t\t\t\t\t\t\t    \\\n-{\"normal_comp_operator\", {GE, GT, LE, LT, GTU, LEU}},\t\t\t\t    \\\n-{\"noov_compare_op\", {NE, EQ, GE, GT, LE, LT, GEU, GTU, LEU, LTU}},\t\t    \\\n-{\"v9_regcmp_op\", {EQ, NE, GE, LT, LE, GT}},\t\t\t\t\t    \\\n-{\"extend_op\", {SIGN_EXTEND, ZERO_EXTEND}},\t\t\t\t\t    \\\n-{\"cc_arithop\", {AND, IOR, XOR}},\t\t\t\t\t\t    \\\n-{\"cc_arithopn\", {AND, IOR}},\t\t\t\t\t\t\t    \\\n-{\"arith_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT}},\t\t\t    \\\n-{\"arith_add_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT}},\t\t    \\\n-{\"arith11_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT}},\t\t\t    \\\n-{\"arith10_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT}},\t\t\t    \\\n-{\"arith_double_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, CONST_DOUBLE}},   \\\n-{\"arith_double_add_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, CONST_DOUBLE}},\\\n-{\"arith11_double_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, CONST_DOUBLE}}, \\\n-{\"arith10_double_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, CONST_DOUBLE}}, \\\n-{\"small_int\", {CONST_INT, CONSTANT_P_RTX}},\t\t\t\t\t    \\\n-{\"small_int_or_double\", {CONST_INT, CONST_DOUBLE, CONSTANT_P_RTX}},\t\t    \\\n-{\"uns_small_int\", {CONST_INT, CONSTANT_P_RTX}},\t\t\t\t\t    \\\n-{\"uns_arith_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\t    \\\n-{\"clobbered_register\", {REG}},\t\t\t\t\t\t\t    \\\n-{\"input_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, MEM}},\t\t    \\\n-{\"zero_operand\", {CONST_INT, CONSTANT_P_RTX}},\t\t\t\t\t    \\\n-{\"const64_operand\", {CONST_INT, CONST_DOUBLE, CONSTANT_P_RTX}},\t\t\t    \\\n-{\"const64_high_operand\", {CONST_INT, CONST_DOUBLE, CONSTANT_P_RTX}},\n-\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+{\"reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t\\\n+{\"fp_zero_operand\", {CONST_DOUBLE}},\t\t\t\t\t\\\n+{\"intreg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n+{\"fcc_reg_operand\", {REG}},\t\t\t\t\t\t\\\n+{\"icc_or_fcc_reg_operand\", {REG}},\t\t\t\t\t\\\n+{\"restore_operand\", {REG}},\t\t\t\t\t\t\\\n+{\"call_operand\", {MEM}},\t\t\t\t\t\t\\\n+{\"call_operand_address\", {SYMBOL_REF, LABEL_REF, CONST, CONST_DOUBLE,\t\\\n+\tADDRESSOF, SUBREG, REG, PLUS, LO_SUM, CONST_INT}},\t\t\\\n+{\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST, CONST_DOUBLE}},\t\\\n+{\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n+{\"label_ref_operand\", {LABEL_REF}},\t\t\t\t\t\\\n+{\"sp64_medium_pic_operand\", {CONST}},\t\t\t\t\t\\\n+{\"data_segment_operand\", {SYMBOL_REF, PLUS, CONST}},\t\t\t\\\n+{\"text_segment_operand\", {LABEL_REF, SYMBOL_REF, PLUS, CONST}},\t\t\\\n+{\"reg_or_nonsymb_mem_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n+{\"splittable_symbolic_memory_operand\", {MEM}},\t\t\t\t\\\n+{\"splittable_immediate_memory_operand\", {MEM}},\t\t\t\t\\\n+{\"eq_or_neq\", {EQ, NE}},\t\t\t\t\t\t\\\n+{\"normal_comp_operator\", {GE, GT, LE, LT, GTU, LEU}},\t\t\t\\\n+{\"noov_compare_op\", {NE, EQ, GE, GT, LE, LT, GEU, GTU, LEU, LTU}},\t\\\n+{\"v9_regcmp_op\", {EQ, NE, GE, LT, LE, GT}},\t\t\t\t\\\n+{\"extend_op\", {SIGN_EXTEND, ZERO_EXTEND}},\t\t\t\t\\\n+{\"cc_arithop\", {AND, IOR, XOR}},\t\t\t\t\t\\\n+{\"cc_arithopn\", {AND, IOR}},\t\t\t\t\t\t\\\n+{\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+{\"arith_add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+{\"arith11_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+{\"arith10_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+{\"arith_double_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n+{\"arith_double_add_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n+{\"arith11_double_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n+{\"arith10_double_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n+{\"small_int\", {CONST_INT}},\t\t\t\t\t\t\\\n+{\"small_int_or_double\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n+{\"uns_small_int\", {CONST_INT}},\t\t\t\t\t\t\\\n+{\"uns_arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+{\"clobbered_register\", {REG}},\t\t\t\t\t\t\\\n+{\"input_operand\", {SUBREG, REG, CONST_INT, MEM, CONST}},\t\t\\\n+{\"zero_operand\", {CONST_INT}},\t\t\t\t\t\t\\\n+{\"const64_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\t\\\n+{\"const64_high_operand\", {CONST_INT, CONST_DOUBLE}},\n \n /* The number of Pmode words for the setjmp buffer.  */\n #define JMP_BUF_SIZE 12"}]}