{"sha": "88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhhOTVhMTE5YjVjZDk1M2VjZjhkZWRlYmUyMDA4YzQ1MTRjYmMwYw==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2010-09-08T19:35:35Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2010-09-08T19:35:35Z"}, "message": "re PR fortran/38282 (Bit intrinsics: ILEN and IBCHNG)\n\n\tPR fortran/38282\n\n\t* intrinsic.c (add_functions): Add B{G,L}{E,T}, DSHIFT{L,R},\n\tMASK{L,R}, MERGE_BITS and SHIFT{A,L,R}.\n\t* gfortran.h: Define ISYM values for above intrinsics.\n\t* intrinsic.h (gfc_check_bge_bgt_ble_blt, gfc_check_dshift,\n\tgfc_check_mask, gfc_check_merge_bits, gfc_check_shift,\n\tgfc_simplify_bge, gfc_simplify_bgt, gfc_simplify_ble,\n\tgfc_simplify_blt, gfc_simplify_dshiftl, gfc_simplify_dshiftr,\n\tgfc_simplify_lshift, gfc_simplify_maskl, gfc_simplify_maskr,\n\tgfc_simplify_merge_bits, gfc_simplify_rshift,\n\tgfc_simplify_shifta, gfc_simplify_shiftl, gfc_simplify_shiftr,\n\tgfc_resolve_dshift, gfc_resolve_mask, gfc_resolve_merge_bits,\n\tgfc_resolve_shift): New prototypes.\n\t* iresolve.c (gfc_resolve_dshift, gfc_resolve_mask,\n\tgfc_resolve_merge_bits, gfc_resolve_shift): New functions.\n\t* check.c (gfc_check_bge_bgt_ble_blt, gfc_check_dshift,\n\tgfc_check_mask, gfc_check_merge_bits, gfc_check_shift): New\n\tfunctions.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_dshift,\n\tgfc_conv_intrinsic_bitcomp, gfc_conv_intrinsic_shift,\n\tgfc_conv_intrinsic_merge_bits, gfc_conv_intrinsic_mask): New\n\tfunctions.\n\t(gfc_conv_intrinsic_function): Call above static functions.\n\t* intrinsic.texi: Document new intrinsics.\n\t* simplify.c (gfc_simplify_bge, gfc_simplify_bgt, gfc_simplify_ble,\n        gfc_simplify_blt, gfc_simplify_dshiftl, gfc_simplify_dshiftr,\n        gfc_simplify_lshift, gfc_simplify_maskl, gfc_simplify_maskr,\n        gfc_simplify_merge_bits, gfc_simplify_rshift, \n        gfc_simplify_shifta, gfc_simplify_shiftl, gfc_simplify_shiftr):\n\tNew functions.\n\n\t* gfortran.dg/bit_comparison_1.F90: New test.\n\t* gfortran.dg/leadz_trailz_3.f90: New test.\n\t* gfortran.dg/masklr_2.F90: New test.\n\t* gfortran.dg/shiftalr_1.F90: New test.\n\t* gfortran.dg/merge_bits_2.F90: New test.\n\t* gfortran.dg/dshift_2.F90: New test.\n\t* gfortran.dg/bit_comparison_2.F90: New test.\n\t* gfortran.dg/masklr_1.F90: New test.\n\t* gfortran.dg/merge_bits_1.F90: New test.\n\t* gfortran.dg/dshift_1.F90: New test.\n\t* gfortran.dg/shiftalr_2.F90: New test.\n\nFrom-SVN: r164021", "tree": {"sha": "c19b0a8679d5f05b750bdcabd97a0981c2238d99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c19b0a8679d5f05b750bdcabd97a0981c2238d99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd72fc7cd4e91ac2297c14bc62980c6506e8c56c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd72fc7cd4e91ac2297c14bc62980c6506e8c56c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd72fc7cd4e91ac2297c14bc62980c6506e8c56c"}], "stats": {"total": 2335, "additions": 2283, "deletions": 52}, "files": [{"sha": "c0551e15ba1dfc08b47b944989f37a57803f97fa", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -1,3 +1,36 @@\n+2010-09-08  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/38282\n+\t* intrinsic.c (add_functions): Add B{G,L}{E,T}, DSHIFT{L,R},\n+\tMASK{L,R}, MERGE_BITS and SHIFT{A,L,R}.\n+\t* gfortran.h: Define ISYM values for above intrinsics.\n+\t* intrinsic.h (gfc_check_bge_bgt_ble_blt, gfc_check_dshift,\n+\tgfc_check_mask, gfc_check_merge_bits, gfc_check_shift,\n+\tgfc_simplify_bge, gfc_simplify_bgt, gfc_simplify_ble,\n+\tgfc_simplify_blt, gfc_simplify_dshiftl, gfc_simplify_dshiftr,\n+\tgfc_simplify_lshift, gfc_simplify_maskl, gfc_simplify_maskr,\n+\tgfc_simplify_merge_bits, gfc_simplify_rshift,\n+\tgfc_simplify_shifta, gfc_simplify_shiftl, gfc_simplify_shiftr,\n+\tgfc_resolve_dshift, gfc_resolve_mask, gfc_resolve_merge_bits,\n+\tgfc_resolve_shift): New prototypes.\n+\t* iresolve.c (gfc_resolve_dshift, gfc_resolve_mask,\n+\tgfc_resolve_merge_bits, gfc_resolve_shift): New functions.\n+\t* check.c (gfc_check_bge_bgt_ble_blt, gfc_check_dshift,\n+\tgfc_check_mask, gfc_check_merge_bits, gfc_check_shift): New\n+\tfunctions.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_dshift,\n+\tgfc_conv_intrinsic_bitcomp, gfc_conv_intrinsic_shift,\n+\tgfc_conv_intrinsic_merge_bits, gfc_conv_intrinsic_mask): New\n+\tfunctions.\n+\t(gfc_conv_intrinsic_function): Call above static functions.\n+\t* intrinsic.texi: Document new intrinsics.\n+\t* simplify.c (gfc_simplify_bge, gfc_simplify_bgt, gfc_simplify_ble,\n+\tgfc_simplify_blt, gfc_simplify_dshiftl, gfc_simplify_dshiftr,\n+\tgfc_simplify_lshift, gfc_simplify_maskl, gfc_simplify_maskr,\n+\tgfc_simplify_merge_bits, gfc_simplify_rshift, \n+\tgfc_simplify_shifta, gfc_simplify_shiftl, gfc_simplify_shiftr):\n+\tNew functions.\n+\n 2010-09-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* frontend-passes.c (optimize_code_node): Walk block chain by default."}, {"sha": "51ea8778fe3694783cbb5da3dd7975d59884da9f", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 150, "deletions": 7, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -299,30 +299,68 @@ nonnegative_check (const char *arg, gfc_expr *expr)\n \n \n /* If expr2 is constant, then check that the value is less than\n-   bit_size(expr1).  */\n+   (less than or equal to, if 'or_equal' is true) bit_size(expr1).  */\n \n static gfc_try\n less_than_bitsize1 (const char *arg1, gfc_expr *expr1, const char *arg2,\n-\t       gfc_expr *expr2)\n+\t\t    gfc_expr *expr2, bool or_equal)\n {\n   int i2, i3;\n \n   if (expr2->expr_type == EXPR_CONSTANT)\n     {\n       gfc_extract_int (expr2, &i2);\n       i3 = gfc_validate_kind (BT_INTEGER, expr1->ts.kind, false);\n-      if (i2 >= gfc_integer_kinds[i3].bit_size)\n+      if (or_equal)\n \t{\n-\t  gfc_error (\"'%s' at %L must be less than BIT_SIZE('%s')\",\n-\t\t     arg2, &expr2->where, arg1);\n-\t  return FAILURE;\n+\t  if (i2 > gfc_integer_kinds[i3].bit_size)\n+\t    {\n+\t      gfc_error (\"'%s' at %L must be less than \"\n+\t\t\t \"or equal to BIT_SIZE('%s')\",\n+\t\t\t arg2, &expr2->where, arg1);\n+\t      return FAILURE;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (i2 >= gfc_integer_kinds[i3].bit_size)\n+\t    {\n+\t      gfc_error (\"'%s' at %L must be less than BIT_SIZE('%s')\",\n+\t\t\t arg2, &expr2->where, arg1);\n+\t      return FAILURE;\n+\t    }\n \t}\n     }\n \n   return SUCCESS;\n }\n \n \n+/* If expr is constant, then check that the value is less than or equal\n+   to the bit_size of the kind k.  */\n+\n+static gfc_try\n+less_than_bitsizekind (const char *arg, gfc_expr *expr, int k)\n+{\n+  int i, val;\n+\n+  if (expr->expr_type != EXPR_CONSTANT)\n+    return SUCCESS;\n+ \n+  i = gfc_validate_kind (BT_INTEGER, k, false);\n+  gfc_extract_int (expr, &val);\n+\n+  if (val > gfc_integer_kinds[i].bit_size)\n+    {\n+      gfc_error (\"'%s' at %L must be less than or equal to the BIT_SIZE of \"\n+\t\t \"INTEGER(KIND=%d)\", arg, &expr->where, k);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n /* If expr2 and expr3 are constants, then check that the value is less than\n    or equal to bit_size(expr1).  */\n \n@@ -928,6 +966,19 @@ gfc_check_bessel_n2 (gfc_expr *n1, gfc_expr *n2, gfc_expr *x)\n }\n \n \n+gfc_try\n+gfc_check_bge_bgt_ble_blt (gfc_expr *i, gfc_expr *j)\n+{\n+  if (type_check (i, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (j, 1, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n gfc_try\n gfc_check_bitfcn (gfc_expr *i, gfc_expr *pos)\n {\n@@ -940,7 +991,7 @@ gfc_check_bitfcn (gfc_expr *i, gfc_expr *pos)\n   if (nonnegative_check (\"pos\", pos) == FAILURE)\n     return FAILURE;\n \n-  if (less_than_bitsize1 (\"i\", i, \"pos\", pos) == FAILURE)\n+  if (less_than_bitsize1 (\"i\", i, \"pos\", pos, false) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n@@ -1316,6 +1367,31 @@ gfc_check_dprod (gfc_expr *x, gfc_expr *y)\n }\n \n \n+gfc_try\n+gfc_check_dshift (gfc_expr *i, gfc_expr *j, gfc_expr *shift)\n+{\n+  if (type_check (i, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (j, 1, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (same_type_check (i, 0, j, 1) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (shift, 2, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (nonnegative_check (\"SHIFT\", shift) == FAILURE)\n+    return FAILURE;\n+\n+  if (less_than_bitsize1 (\"I\", i, \"SHIFT\", shift, true) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n gfc_try\n gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \t\t   gfc_expr *dim)\n@@ -2355,6 +2431,32 @@ gfc_check_product_sum (gfc_actual_arglist *ap)\n \n /* For IANY, IALL and IPARITY.  */\n \n+gfc_try\n+gfc_check_mask (gfc_expr *i, gfc_expr *kind)\n+{\n+  int k;\n+\n+  if (type_check (i, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (nonnegative_check (\"I\", i) == FAILURE)\n+    return FAILURE;\n+\n+  if (kind_check (kind, 1, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (kind)\n+    gfc_extract_int (kind, &k);\n+  else\n+    k = gfc_default_integer_kind;\n+\n+  if (less_than_bitsizekind (\"I\", i, k) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n gfc_try\n gfc_check_transf_bit_intrins (gfc_actual_arglist *ap)\n {\n@@ -2389,6 +2491,28 @@ gfc_check_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)\n }\n \n \n+gfc_try\n+gfc_check_merge_bits (gfc_expr *i, gfc_expr *j, gfc_expr *mask)\n+{\n+  if (type_check (i, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (j, 1, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (mask, 2, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (same_type_check (i, 0, j, 1) == FAILURE)\n+    return FAILURE;\n+\n+  if (same_type_check (i, 0, mask, 2) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n gfc_try\n gfc_check_move_alloc (gfc_expr *from, gfc_expr *to)\n {\n@@ -3117,6 +3241,25 @@ gfc_check_shape (gfc_expr *source)\n }\n \n \n+gfc_try\n+gfc_check_shift (gfc_expr *i, gfc_expr *shift)\n+{\n+  if (type_check (i, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (shift, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (nonnegative_check (\"SHIFT\", shift) == FAILURE)\n+    return FAILURE;\n+\n+  if (less_than_bitsize1 (\"I\", i, \"SHIFT\", shift, true) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n gfc_try\n gfc_check_sign (gfc_expr *a, gfc_expr *b)\n {"}, {"sha": "ef4612fc4968c28b52ef1f880d6280c00de5e68c", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -331,7 +331,11 @@ enum gfc_isym_id\n   GFC_ISYM_ATAN,\n   GFC_ISYM_ATAN2,\n   GFC_ISYM_ATANH,\n+  GFC_ISYM_BGE,\n+  GFC_ISYM_BGT,\n   GFC_ISYM_BIT_SIZE,\n+  GFC_ISYM_BLE,\n+  GFC_ISYM_BLT,\n   GFC_ISYM_BTEST,\n   GFC_ISYM_CEILING,\n   GFC_ISYM_CHAR,\n@@ -355,6 +359,8 @@ enum gfc_isym_id\n   GFC_ISYM_DIM,\n   GFC_ISYM_DOT_PRODUCT,\n   GFC_ISYM_DPROD,\n+  GFC_ISYM_DSHIFTL,\n+  GFC_ISYM_DSHIFTR,\n   GFC_ISYM_DTIME,\n   GFC_ISYM_EOSHIFT,\n   GFC_ISYM_EPSILON,\n@@ -449,6 +455,8 @@ enum gfc_isym_id\n   GFC_ISYM_LSTAT,\n   GFC_ISYM_LTIME,\n   GFC_ISYM_MALLOC,\n+  GFC_ISYM_MASKL,\n+  GFC_ISYM_MASKR,\n   GFC_ISYM_MATMUL,\n   GFC_ISYM_MAX,\n   GFC_ISYM_MAXEXPONENT,\n@@ -457,6 +465,7 @@ enum gfc_isym_id\n   GFC_ISYM_MCLOCK,\n   GFC_ISYM_MCLOCK8,\n   GFC_ISYM_MERGE,\n+  GFC_ISYM_MERGE_BITS,\n   GFC_ISYM_MIN,\n   GFC_ISYM_MINEXPONENT,\n   GFC_ISYM_MINLOC,\n@@ -500,6 +509,9 @@ enum gfc_isym_id\n   GFC_ISYM_SECOND,\n   GFC_ISYM_SET_EXPONENT,\n   GFC_ISYM_SHAPE,\n+  GFC_ISYM_SHIFTA,\n+  GFC_ISYM_SHIFTL,\n+  GFC_ISYM_SHIFTR,\n   GFC_ISYM_SIGN,\n   GFC_ISYM_SIGNAL,\n   GFC_ISYM_SI_KIND,"}, {"sha": "1a1d8284a2b31826ca9976ff7b6aaf0e5164a7fd", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 104, "deletions": 6, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -1392,12 +1392,40 @@ add_functions (void)\n \n   make_generic (\"bessel_yn\", GFC_ISYM_YN, GFC_STD_F2008);\n \n+  add_sym_2 (\"bge\", GFC_ISYM_BGE, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_LOGICAL, dl, GFC_STD_F2008,\n+\t     gfc_check_bge_bgt_ble_blt, gfc_simplify_bge, NULL,\n+\t     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"bge\", GFC_ISYM_BGE, GFC_STD_F2008);\n+\n+  add_sym_2 (\"bgt\", GFC_ISYM_BGT, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_LOGICAL, dl, GFC_STD_F2008,\n+\t     gfc_check_bge_bgt_ble_blt, gfc_simplify_bgt, NULL,\n+\t     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"bgt\", GFC_ISYM_BGT, GFC_STD_F2008);\n+\n   add_sym_1 (\"bit_size\", GFC_ISYM_BIT_SIZE, CLASS_INQUIRY, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n \t     gfc_check_i, gfc_simplify_bit_size, NULL,\n \t     i, BT_INTEGER, di, REQUIRED);\n \n   make_generic (\"bit_size\", GFC_ISYM_BIT_SIZE, GFC_STD_F95);\n \n+  add_sym_2 (\"ble\", GFC_ISYM_BLE, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_LOGICAL, dl, GFC_STD_F2008,\n+\t     gfc_check_bge_bgt_ble_blt, gfc_simplify_ble, NULL,\n+\t     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"ble\", GFC_ISYM_BLE, GFC_STD_F2008);\n+\n+  add_sym_2 (\"blt\", GFC_ISYM_BLT, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_LOGICAL, dl, GFC_STD_F2008,\n+\t     gfc_check_bge_bgt_ble_blt, gfc_simplify_blt, NULL,\n+\t     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"blt\", GFC_ISYM_BLT, GFC_STD_F2008);\n+\n   add_sym_2 (\"btest\", GFC_ISYM_BTEST, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL, dl, GFC_STD_F95,\n \t     gfc_check_bitfcn, gfc_simplify_btest, gfc_resolve_btest,\n \t     i, BT_INTEGER, di, REQUIRED, pos, BT_INTEGER, di, REQUIRED);\n@@ -1561,10 +1589,28 @@ add_functions (void)\n \n   make_generic (\"dreal\", GFC_ISYM_REAL, GFC_STD_GNU);\n \n+  add_sym_3 (\"dshiftl\", GFC_ISYM_DSHIFTL, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F2008,\n+\t     gfc_check_dshift, gfc_simplify_dshiftl, gfc_resolve_dshift,\n+\t     i, BT_INTEGER, di, REQUIRED,\n+\t     j, BT_INTEGER, di, REQUIRED,\n+\t     sh, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"dshiftl\", GFC_ISYM_DSHIFTL, GFC_STD_F2008);\n+\n+  add_sym_3 (\"dshiftr\", GFC_ISYM_DSHIFTR, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F2008,\n+\t     gfc_check_dshift, gfc_simplify_dshiftr, gfc_resolve_dshift,\n+\t     i, BT_INTEGER, di, REQUIRED,\n+\t     j, BT_INTEGER, di, REQUIRED,\n+\t     sh, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"dshiftr\", GFC_ISYM_DSHIFTR, GFC_STD_F2008);\n+\n   add_sym_4 (\"eoshift\", GFC_ISYM_EOSHIFT, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n \t     gfc_check_eoshift, NULL, gfc_resolve_eoshift,\n-\t     ar, BT_REAL, dr, 0, sh, BT_INTEGER, ii, REQUIRED,\n-\t     bd, BT_REAL, dr, 1, dm, BT_INTEGER, ii, OPTIONAL);\n+\t     ar, BT_REAL, dr, REQUIRED, sh, BT_INTEGER, ii, REQUIRED,\n+\t     bd, BT_REAL, dr, OPTIONAL, dm, BT_INTEGER, ii, OPTIONAL);\n \n   make_generic (\"eoshift\", GFC_ISYM_EOSHIFT, GFC_STD_F95);\n \n@@ -1940,14 +1986,16 @@ add_functions (void)\n \n   make_generic (\"isnan\", GFC_ISYM_ISNAN, GFC_STD_GNU);\n \n-  add_sym_2 (\"rshift\", GFC_ISYM_RSHIFT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_GNU,\n-\t     gfc_check_ishft, NULL, gfc_resolve_rshift,\n+  add_sym_2 (\"rshift\", GFC_ISYM_RSHIFT, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_GNU,\n+\t     gfc_check_ishft, gfc_simplify_rshift, gfc_resolve_rshift,\n \t     i, BT_INTEGER, di, REQUIRED, sh, BT_INTEGER, di, REQUIRED);\n \n   make_generic (\"rshift\", GFC_ISYM_RSHIFT, GFC_STD_GNU);\n \n-  add_sym_2 (\"lshift\", GFC_ISYM_LSHIFT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_GNU,\n-\t     gfc_check_ishft, NULL, gfc_resolve_lshift,\n+  add_sym_2 (\"lshift\", GFC_ISYM_LSHIFT, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_GNU,\n+\t     gfc_check_ishft, gfc_simplify_lshift, gfc_resolve_lshift,\n \t     i, BT_INTEGER, di, REQUIRED, sh, BT_INTEGER, di, REQUIRED);\n \n   make_generic (\"lshift\", GFC_ISYM_LSHIFT, GFC_STD_GNU);\n@@ -2120,6 +2168,22 @@ add_functions (void)\n \n   make_generic (\"malloc\", GFC_ISYM_MALLOC, GFC_STD_GNU);\n \n+  add_sym_2 (\"maskl\", GFC_ISYM_MASKL, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F2008,\n+\t     gfc_check_mask, gfc_simplify_maskl, gfc_resolve_mask,\n+\t     i, BT_INTEGER, di, REQUIRED,\n+\t     kind, BT_INTEGER, di, OPTIONAL);\n+\n+  make_generic (\"maskl\", GFC_ISYM_MASKL, GFC_STD_F2008);\n+\n+  add_sym_2 (\"maskr\", GFC_ISYM_MASKR, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F2008,\n+\t     gfc_check_mask, gfc_simplify_maskr, gfc_resolve_mask,\n+\t     i, BT_INTEGER, di, REQUIRED,\n+\t     kind, BT_INTEGER, di, OPTIONAL);\n+\n+  make_generic (\"maskr\", GFC_ISYM_MASKR, GFC_STD_F2008);\n+\n   add_sym_2 (\"matmul\", GFC_ISYM_MATMUL, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n \t     gfc_check_matmul, gfc_simplify_matmul, gfc_resolve_matmul,\n \t     ma, BT_REAL, dr, REQUIRED, mb, BT_REAL, dr, REQUIRED);\n@@ -2192,6 +2256,16 @@ add_functions (void)\n \n   make_generic (\"merge\", GFC_ISYM_MERGE, GFC_STD_F95);\n \n+  add_sym_3 (\"merge_bits\", GFC_ISYM_MERGE_BITS, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F2008,\n+\t     gfc_check_merge_bits, gfc_simplify_merge_bits,\n+\t     gfc_resolve_merge_bits,\n+\t     i, BT_INTEGER, di, REQUIRED,\n+\t     j, BT_INTEGER, di, REQUIRED,\n+\t     msk, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"merge_bits\", GFC_ISYM_MERGE_BITS, GFC_STD_F2008);\n+\n   /* Note: amin0 is equivalent to real(min), min1 is equivalent to\n      int(min).  */\n \n@@ -2491,6 +2565,30 @@ add_functions (void)\n \n   make_generic (\"shape\", GFC_ISYM_SHAPE, GFC_STD_F95);\n \n+  add_sym_2 (\"shifta\", GFC_ISYM_SHIFTA, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F2008,\n+\t     gfc_check_shift, gfc_simplify_shifta, gfc_resolve_shift,\n+\t     i, BT_INTEGER, di, REQUIRED,\n+\t     sh, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"shifta\", GFC_ISYM_SHIFTA, GFC_STD_F2008);\n+\n+  add_sym_2 (\"shiftl\", GFC_ISYM_SHIFTL, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F2008,\n+\t     gfc_check_shift, gfc_simplify_shiftl, gfc_resolve_shift,\n+\t     i, BT_INTEGER, di, REQUIRED,\n+\t     sh, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"shiftl\", GFC_ISYM_SHIFTL, GFC_STD_F2008);\n+\n+  add_sym_2 (\"shiftr\", GFC_ISYM_SHIFTR, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F2008,\n+\t     gfc_check_shift, gfc_simplify_shiftr, gfc_resolve_shift,\n+\t     i, BT_INTEGER, di, REQUIRED,\n+\t     sh, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"shiftr\", GFC_ISYM_SHIFTR, GFC_STD_F2008);\n+\n   add_sym_2 (\"sign\", GFC_ISYM_SIGN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr, GFC_STD_F77,\n \t     gfc_check_sign, gfc_simplify_sign, gfc_resolve_sign,\n \t     a, BT_REAL, dr, REQUIRED, b, BT_REAL, dr, REQUIRED);"}, {"sha": "9818f7a9f47d4b348e74dc5fcc36ee5f5adf7a8c", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -41,6 +41,7 @@ gfc_try gfc_check_atan_2 (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_atan2 (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_besn (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_bessel_n2 (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_bge_bgt_ble_blt (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_bitfcn (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_char (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_chdir (gfc_expr *);\n@@ -56,6 +57,7 @@ gfc_try gfc_check_dble (gfc_expr *);\n gfc_try gfc_check_digits (gfc_expr *);\n gfc_try gfc_check_dot_product (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_dprod (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_dshift (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_dtime_etime (gfc_expr *);\n gfc_try gfc_check_fgetputc (gfc_expr *, gfc_expr *);\n@@ -102,8 +104,10 @@ gfc_try gfc_check_min_max_integer (gfc_actual_arglist *);\n gfc_try gfc_check_min_max_real (gfc_actual_arglist *);\n gfc_try gfc_check_min_max_double (gfc_actual_arglist *);\n gfc_try gfc_check_malloc (gfc_expr *);\n+gfc_try gfc_check_mask (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_matmul (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_merge (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_merge_bits (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_minloc_maxloc (gfc_actual_arglist *);\n gfc_try gfc_check_minval_maxval (gfc_actual_arglist *);\n gfc_try gfc_check_nearest (gfc_expr *, gfc_expr *);\n@@ -132,6 +136,7 @@ gfc_try gfc_check_selected_int_kind (gfc_expr *);\n gfc_try gfc_check_selected_real_kind (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_set_exponent (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_shape (gfc_expr *);\n+gfc_try gfc_check_shift (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_size (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_sign (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_signal (gfc_expr *, gfc_expr *);\n@@ -232,7 +237,11 @@ gfc_expr *gfc_simplify_bessel_y0 (gfc_expr *);\n gfc_expr *gfc_simplify_bessel_y1 (gfc_expr *);\n gfc_expr *gfc_simplify_bessel_yn (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_bessel_yn2 (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_bge (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_bgt (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_bit_size (gfc_expr *);\n+gfc_expr *gfc_simplify_ble (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_blt (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_btest (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ceiling (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_char (gfc_expr *, gfc_expr *);\n@@ -248,6 +257,8 @@ gfc_expr *gfc_simplify_digits (gfc_expr *);\n gfc_expr *gfc_simplify_dim (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dprod (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dot_product (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_dshiftl (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_dshiftr (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_epsilon (gfc_expr *);\n gfc_expr *gfc_simplify_erf (gfc_expr *);\n gfc_expr *gfc_simplify_erfc (gfc_expr *);\n@@ -298,8 +309,12 @@ gfc_expr *gfc_simplify_llt (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_log (gfc_expr *);\n gfc_expr *gfc_simplify_log10 (gfc_expr *);\n gfc_expr *gfc_simplify_logical (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_lshift (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_matmul (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_maskl (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_maskr (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_merge (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_merge_bits (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_min (gfc_expr *);\n gfc_expr *gfc_simplify_minval (gfc_expr *, gfc_expr*, gfc_expr*);\n gfc_expr *gfc_simplify_max (gfc_expr *);\n@@ -333,6 +348,7 @@ gfc_expr *gfc_simplify_repeat (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_reshape (gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t\tgfc_expr *);\n gfc_expr *gfc_simplify_rrspacing (gfc_expr *);\n+gfc_expr *gfc_simplify_rshift (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_scale (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_scan (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_selected_char_kind (gfc_expr *);\n@@ -341,6 +357,9 @@ gfc_expr *gfc_simplify_selected_real_kind (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_set_exponent (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_sign (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_shape (gfc_expr *);\n+gfc_expr *gfc_simplify_shifta (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_shiftl (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_shiftr (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_sin (gfc_expr *);\n gfc_expr *gfc_simplify_sinh (gfc_expr *);\n gfc_expr *gfc_simplify_size (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -409,6 +428,7 @@ void gfc_resolve_dble (gfc_expr *, gfc_expr *);\n void gfc_resolve_dim (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_dot_product (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_dprod (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_dshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_dtime_sub (gfc_code *);\n void gfc_resolve_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t  gfc_expr *);\n@@ -478,7 +498,9 @@ void gfc_resolve_maxloc (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_maxval (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_mclock (gfc_expr *);\n void gfc_resolve_mclock8 (gfc_expr *);\n+void gfc_resolve_mask (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_merge (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_merge_bits (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_min (gfc_expr *, gfc_actual_arglist *);\n void gfc_resolve_minloc (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_minval (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -506,6 +528,7 @@ void gfc_resolve_second_sub (gfc_code *);\n void gfc_resolve_secnds (gfc_expr *, gfc_expr *);\n void gfc_resolve_set_exponent (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_shape (gfc_expr *, gfc_expr *);\n+void gfc_resolve_shift (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_sign (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_signal (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_sin (gfc_expr *, gfc_expr *);"}, {"sha": "65b3c0500f26db7dcfc6b8f3e6cb1e91b7e1e585", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 467, "deletions": 5, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -67,7 +67,11 @@ Some basic guidelines for editing this document:\n * @code{BESSEL_Y0}:     BESSEL_Y0, Bessel function of the second kind of order 0\n * @code{BESSEL_Y1}:     BESSEL_Y1, Bessel function of the second kind of order 1\n * @code{BESSEL_YN}:     BESSEL_YN, Bessel function of the second kind\n+* @code{BGE}:           BGE,       Bitwise greater than or equal to\n+* @code{BGT}:           BGT,       Bitwise greater than\n * @code{BIT_SIZE}:      BIT_SIZE,  Bit size inquiry function\n+* @code{BLE}:           BLE,       Bitwise less than or equal to\n+* @code{BLT}:           BLT,       Bitwise less than\n * @code{BTEST}:         BTEST,     Bit test function\n * @code{C_ASSOCIATED}:  C_ASSOCIATED, Status of a C pointer\n * @code{C_F_POINTER}:   C_F_POINTER, Convert C into Fortran pointer\n@@ -97,6 +101,8 @@ Some basic guidelines for editing this document:\n * @code{DOT_PRODUCT}:   DOT_PRODUCT, Dot product function\n * @code{DPROD}:         DPROD,     Double product function\n * @code{DREAL}:         DREAL,     Double real part function\n+* @code{DSHIFTL}:       DSHIFTL,   Combined left shift\n+* @code{DSHIFTR}:       DSHIFTR,   Combined right shift\n * @code{DTIME}:         DTIME,     Execution time subroutine (or function)\n * @code{EOSHIFT}:       EOSHIFT,   End-off shift elements of an array\n * @code{EPSILON}:       EPSILON,   Epsilon function\n@@ -188,6 +194,8 @@ Some basic guidelines for editing this document:\n * @code{LSTAT}:         LSTAT,     Get file status\n * @code{LTIME}:         LTIME,     Convert time to local time info\n * @code{MALLOC}:        MALLOC,    Dynamic memory allocation function\n+* @code{MASKL}:         MASKL,     Left justified mask\n+* @code{MASKR}:         MASKR,     Right justified mask\n * @code{MATMUL}:        MATMUL,    matrix multiplication\n * @code{MAX}:           MAX,       Maximum value of an argument list\n * @code{MAXEXPONENT}:   MAXEXPONENT, Maximum exponent of a real kind\n@@ -196,6 +204,7 @@ Some basic guidelines for editing this document:\n * @code{MCLOCK}:        MCLOCK,    Time function\n * @code{MCLOCK8}:       MCLOCK8,   Time function (64-bit)\n * @code{MERGE}:         MERGE,     Merge arrays\n+* @code{MERGE_BITS}:    MERGE_BITS, Merge of bits under mask\n * @code{MIN}:           MIN,       Minimum value of an argument list\n * @code{MINEXPONENT}:   MINEXPONENT, Minimum exponent of a real kind\n * @code{MINLOC}:        MINLOC,    Location of the minimum value within an array\n@@ -242,6 +251,9 @@ Some basic guidelines for editing this document:\n * @code{SELECTED_REAL_KIND}: SELECTED_REAL_KIND,  Choose real kind\n * @code{SET_EXPONENT}:  SET_EXPONENT, Set the exponent of the model\n * @code{SHAPE}:         SHAPE,     Determine the shape of an array\n+* @code{SHIFTA}:        SHIFTA,    Right shift with fill\n+* @code{SHIFTL}:        SHIFTL,    Left shift\n+* @code{SHIFTR}:        SHIFTR,    Right shift\n * @code{SIGN}:          SIGN,      Sign copying function\n * @code{SIGNAL}:        SIGNAL,    Signal handling subroutine (or function)\n * @code{SIN}:           SIN,       Sine function\n@@ -1851,6 +1863,75 @@ end program test_besyn\n \n \n \n+@node BGE\n+@section @code{BGE} --- Bitwise greater than or equal to\n+@fnindex BGE\n+@cindex bitwise comparison\n+\n+@table @asis\n+@item @emph{Description}:\n+Determines whether an integral is a bitwise greater than or equal to\n+another.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = BGE(I, J)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I} @tab Shall be of @code{INTEGER} type.\n+@item @var{J} @tab Shall be of @code{INTEGER} type, and of the same kind\n+as @var{I}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{LOGICAL} and of the default kind.\n+\n+@item @emph{See also}:\n+@ref{BGT}, @ref{BLE}, @ref{BLT}\n+@end table\n+\n+\n+\n+@node BGT\n+@section @code{BGT} --- Bitwise greater than\n+@fnindex BGT\n+@cindex bitwise comparison\n+\n+@table @asis\n+@item @emph{Description}:\n+Determines whether an integral is a bitwise greater than another.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = BGT(I, J)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I} @tab Shall be of @code{INTEGER} type.\n+@item @var{J} @tab Shall be of @code{INTEGER} type, and of the same kind\n+as @var{I}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{LOGICAL} and of the default kind.\n+\n+@item @emph{See also}:\n+@ref{BGE}, @ref{BLE}, @ref{BLT}\n+@end table\n+\n+\n+\n @node BIT_SIZE\n @section @code{BIT_SIZE} --- Bit size inquiry function\n @fnindex BIT_SIZE\n@@ -1893,6 +1974,75 @@ end program test_bit_size\n \n \n \n+@node BLE\n+@section @code{BLE} --- Bitwise less than or equal to\n+@fnindex BLE\n+@cindex bitwise comparison\n+\n+@table @asis\n+@item @emph{Description}:\n+Determines whether an integral is a bitwise less than or equal to\n+another.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = BLE(I, J)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I} @tab Shall be of @code{INTEGER} type.\n+@item @var{J} @tab Shall be of @code{INTEGER} type, and of the same kind\n+as @var{I}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{LOGICAL} and of the default kind.\n+\n+@item @emph{See also}:\n+@ref{BGT}, @ref{BGE}, @ref{BLT}\n+@end table\n+\n+\n+\n+@node BLT\n+@section @code{BLT} --- Bitwise less than\n+@fnindex BLT\n+@cindex bitwise comparison\n+\n+@table @asis\n+@item @emph{Description}:\n+Determines whether an integral is a bitwise less than another.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = BLT(I, J)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I} @tab Shall be of @code{INTEGER} type.\n+@item @var{J} @tab Shall be of @code{INTEGER} type, and of the same kind\n+as @var{I}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{LOGICAL} and of the default kind.\n+\n+@item @emph{See also}:\n+@ref{BGE}, @ref{BGT}, @ref{BLE}\n+@end table\n+\n+\n+\n @node BTEST\n @section @code{BTEST} --- Bit test function\n @fnindex BTEST\n@@ -3424,6 +3574,86 @@ end program test_dreal\n \n \n \n+@node DSHIFTL\n+@section @code{DSHIFTL} --- Combined left shift\n+@fnindex DSHIFTL\n+@cindex left shift, combined\n+@cindex shift, left\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DSHIFTL(I, J, SHIFT)} combines bits of @var{I} and @var{J}. The\n+rightmost @var{SHIFT} bits of the result are the leftmost @var{SHIFT}\n+bits of @var{J}, and the remaining bits are the rightmost bits of\n+@var{I}.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = DSHIFTL(I, J, SHIFT)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I} @tab Shall be of type @code{INTEGER}.\n+@item @var{J} @tab Shall be of type @code{INTEGER}, and of the same kind\n+as @var{I}.\n+@item @var{SHIFT} @tab Shall be of type @code{INTEGER}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value has same type and kind as @var{I}.\n+\n+@item @emph{See also}:\n+@ref{DSHIFTR}\n+\n+@end table\n+\n+\n+\n+@node DSHIFTR\n+@section @code{DSHIFTR} --- Combined right shift\n+@fnindex DSHIFTR\n+@cindex right shift, combined\n+@cindex shift, right\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DSHIFTR(I, J, SHIFT)} combines bits of @var{I} and @var{J}. The\n+leftmost @var{SHIFT} bits of the result are the rightmost @var{SHIFT}\n+bits of @var{I}, and the remaining bits are the leftmost bits of\n+@var{J}.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = DSHIFTR(I, J, SHIFT)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I} @tab Shall be of type @code{INTEGER}.\n+@item @var{J} @tab Shall be of type @code{INTEGER}, and of the same kind\n+as @var{I}.\n+@item @var{SHIFT} @tab Shall be of type @code{INTEGER}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value has same type and kind as @var{I}.\n+\n+@item @emph{See also}:\n+@ref{DSHIFTL}\n+\n+@end table\n+\n+\n+\n @node DTIME\n @section @code{DTIME} --- Execution time subroutine (or function)\n @fnindex DTIME\n@@ -7644,7 +7874,8 @@ Bits shifted out from the left end are lost; zeros are shifted in from\n the opposite end.\n \n This function has been superseded by the @code{ISHFT} intrinsic, which\n-is standard in Fortran 95 and later.\n+is standard in Fortran 95 and later, and the @code{SHIFTL} intrinsic,\n+which is standard in Fortran 2008 and later.\n \n @item @emph{Standard}:\n GNU extension\n@@ -7666,7 +7897,8 @@ The return value is of type @code{INTEGER} and of the same kind as\n @var{I}.\n \n @item @emph{See also}:\n-@ref{ISHFT}, @ref{ISHFTC}, @ref{RSHIFT}\n+@ref{ISHFT}, @ref{ISHFTC}, @ref{RSHIFT}, @ref{SHIFTA}, @ref{SHIFTL},\n+@ref{SHIFTR}\n \n @end table\n \n@@ -7829,6 +8061,80 @@ end program test_malloc\n \n \n \n+@node MASKL\n+@section @code{MASKL} --- Left justified mask\n+@fnindex MASKL\n+@cindex mask, left justified\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{MASKL(I[, KIND])} has its leftmost @var{I} bits set to 1, and the\n+remaining bits set to 0.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = MASKL(I[, KIND])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I} @tab Shall be of type @code{INTEGER}.\n+@item @var{KIND} @tab Shall be a scalar constant expression of type\n+@code{INTEGER}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER}. If @var{KIND} is present, it\n+specifies the kind value of the return type; otherwise, it is of the\n+default integer kind.\n+\n+@item @emph{See also}:\n+@ref{MASKR}\n+@end table\n+\n+\n+\n+@node MASKR\n+@section @code{MASKR} --- Right justified mask\n+@fnindex MASKR\n+@cindex mask, right justified\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{MASKL(I[, KIND])} has its rightmost @var{I} bits set to 1, and the\n+remaining bits set to 0.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = MASKR(I[, KIND])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I} @tab Shall be of type @code{INTEGER}.\n+@item @var{KIND} @tab Shall be a scalar constant expression of type\n+@code{INTEGER}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER}. If @var{KIND} is present, it\n+specifies the kind value of the return type; otherwise, it is of the\n+default integer kind.\n+\n+@item @emph{See also}:\n+@ref{MASKL}\n+@end table\n+\n+\n+\n @node MATMUL\n @section @code{MATMUL} --- matrix multiplication\n @fnindex MATMUL\n@@ -8190,6 +8496,43 @@ The result is of the same type and type parameters as @var{TSOURCE}.\n \n \n \n+@node MERGE_BITS\n+@section @code{MERGE_BITS} --- Merge of bits under mask\n+@fnindex MERGE_BITS\n+@cindex bits, merge\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{MERGE_BITS(I, J, MASK)} merges the bits of @var{I} and @var{J}\n+as determined by the mask.  The i-th bit of the result is equal to the \n+i-th bit of @var{I} if the i-th bit of @var{MASK} is 1; it is equal to\n+the i-th bit of @var{J} otherwise.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = MERGE_BITS(I, J, MASK)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I}    @tab Shall be of type @code{INTEGER}.\n+@item @var{J}    @tab Shall be of type @code{INTEGER} and of the same\n+kind as @var{I}.\n+@item @var{MASK} @tab Shall be of type @code{INTEGER} and of the same\n+kind as @var{I}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The result is of the same type and kind as @var{I}.\n+\n+@end table\n+\n+\n+\n @node MIN\n @section @code{MIN} --- Minimum value of an argument list\n @fnindex MIN\n@@ -9895,8 +10238,8 @@ Bits shifted out from the right end are lost. The fill is arithmetic: the\n bits shifted in from the left end are equal to the leftmost bit, which in\n two's complement representation is the sign bit.\n \n-This function has been superseded by the @code{ISHFT} intrinsic, which\n-is standard in Fortran 95 and later.\n+This function has been superseded by the @code{SHIFTA} intrinsic, which\n+is standard in Fortran 2008 and later.\n \n @item @emph{Standard}:\n GNU extension\n@@ -9918,7 +10261,8 @@ The return value is of type @code{INTEGER} and of the same kind as\n @var{I}.\n \n @item @emph{See also}:\n-@ref{ISHFT}, @ref{ISHFTC}, @ref{LSHIFT}\n+@ref{ISHFT}, @ref{ISHFTC}, @ref{LSHIFT}, @ref{SHIFTA}, @ref{SHIFTR},\n+@ref{SHIFTL}\n \n @end table\n \n@@ -10415,6 +10759,124 @@ END PROGRAM\n \n \n \n+@node SHIFTA\n+@section @code{SHIFTA} --- Right shift with fill\n+@fnindex SHIFTA\n+@cindex bits, shift right\n+@cindex shift, right with fill\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{SHIFTA} returns a value corresponding to @var{I} with all of the\n+bits shifted right by @var{SHIFT} places.  If the absolute value of\n+@var{SHIFT} is greater than @code{BIT_SIZE(I)}, the value is undefined.\n+Bits shifted out from the right end are lost. The fill is arithmetic: the\n+bits shifted in from the left end are equal to the leftmost bit, which in\n+two's complement representation is the sign bit.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = SHIFTA(I, SHIFT)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{SHIFT} @tab The type shall be @code{INTEGER}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER} and of the same kind as\n+@var{I}.\n+\n+@item @emph{See also}:\n+@ref{SHIFTL}, @ref{SHIFTR}\n+@end table\n+\n+\n+\n+@node SHIFTL\n+@section @code{SHIFTL} --- Left shift\n+@fnindex SHIFTL\n+@cindex bits, shift left\n+@cindex shift, left\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{SHIFTL} returns a value corresponding to @var{I} with all of the\n+bits shifted left by @var{SHIFT} places.  If the absolute value of\n+@var{SHIFT} is greater than @code{BIT_SIZE(I)}, the value is undefined.\n+Bits shifted out from the left end are lost, and bits shifted in from\n+the right end are set to 0.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = SHIFTL(I, SHIFT)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{SHIFT} @tab The type shall be @code{INTEGER}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER} and of the same kind as\n+@var{I}.\n+\n+@item @emph{See also}:\n+@ref{SHIFTA}, @ref{SHIFTR}\n+@end table\n+\n+\n+\n+@node SHIFTR\n+@section @code{SHIFTR} --- Right shift\n+@fnindex SHIFTR\n+@cindex bits, shift right\n+@cindex shift, right\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{SHIFTR} returns a value corresponding to @var{I} with all of the\n+bits shifted right by @var{SHIFT} places.  If the absolute value of\n+@var{SHIFT} is greater than @code{BIT_SIZE(I)}, the value is undefined.\n+Bits shifted out from the right end are lost, and bits shifted in from\n+the left end are set to 0.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = SHIFTR(I, SHIFT)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{SHIFT} @tab The type shall be @code{INTEGER}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER} and of the same kind as\n+@var{I}.\n+\n+@item @emph{See also}:\n+@ref{SHIFTA}, @ref{SHIFTL}\n+@end table\n+\n+\n+\n @node SIGN\n @section @code{SIGN} --- Sign copying function\n @fnindex SIGN"}, {"sha": "e7a92da905e9d26dc601c8d00464e1bafc63e782", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -824,6 +824,20 @@ gfc_resolve_dprod (gfc_expr *f, gfc_expr *a ATTRIBUTE_UNUSED,\n }\n \n \n+void\n+gfc_resolve_dshift (gfc_expr *f, gfc_expr *i, gfc_expr *j ATTRIBUTE_UNUSED,\n+\t\t    gfc_expr *shift ATTRIBUTE_UNUSED)\n+{\n+  f->ts = i->ts;\n+  if (f->value.function.isym->id == GFC_ISYM_DSHIFTL)\n+    f->value.function.name = gfc_get_string (\"dshiftl_i%d\", f->ts.kind);\n+  else if (f->value.function.isym->id == GFC_ISYM_DSHIFTR)\n+    f->value.function.name = gfc_get_string (\"dshiftr_i%d\", f->ts.kind);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+\n void\n gfc_resolve_eoshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n \t\t     gfc_expr *boundary, gfc_expr *dim)\n@@ -1688,6 +1702,21 @@ gfc_resolve_mclock8 (gfc_expr *f)\n }\n \n \n+void\n+gfc_resolve_mask (gfc_expr *f, gfc_expr *i ATTRIBUTE_UNUSED,\n+\t\t  gfc_expr *kind)\n+{\n+  f->ts.type = BT_INTEGER;\n+  f->ts.kind = kind ? mpz_get_si (kind->value.integer)\n+\t\t    : gfc_default_integer_kind;\n+\n+  if (f->value.function.isym->id == GFC_ISYM_MASKL)\n+    f->value.function.name = gfc_get_string (\"__maskl_i%d\", f->ts.kind);\n+  else\n+    f->value.function.name = gfc_get_string (\"__maskr_i%d\", f->ts.kind);\n+}\n+\n+\n void\n gfc_resolve_merge (gfc_expr *f, gfc_expr *tsource,\n \t\t   gfc_expr *fsource ATTRIBUTE_UNUSED,\n@@ -1709,6 +1738,16 @@ gfc_resolve_merge (gfc_expr *f, gfc_expr *tsource,\n }\n \n \n+void\n+gfc_resolve_merge_bits (gfc_expr *f, gfc_expr *i,\n+\t\t\tgfc_expr *j ATTRIBUTE_UNUSED,\n+\t\t\tgfc_expr *mask ATTRIBUTE_UNUSED)\n+{\n+  f->ts = i->ts;\n+  f->value.function.name = gfc_get_string (\"__merge_bits_i%d\", i->ts.kind);\n+}\n+\n+\n void\n gfc_resolve_min (gfc_expr *f, gfc_actual_arglist *args)\n {\n@@ -2157,6 +2196,21 @@ gfc_resolve_shape (gfc_expr *f, gfc_expr *array)\n }\n \n \n+void\n+gfc_resolve_shift (gfc_expr *f, gfc_expr *i, gfc_expr *shift ATTRIBUTE_UNUSED)\n+{\n+  f->ts = i->ts;\n+  if (f->value.function.isym->id == GFC_ISYM_SHIFTA)\n+    f->value.function.name = gfc_get_string (\"shifta_i%d\", f->ts.kind);\n+  else if (f->value.function.isym->id == GFC_ISYM_SHIFTL)\n+    f->value.function.name = gfc_get_string (\"shiftl_i%d\", f->ts.kind);\n+  else if (f->value.function.isym->id == GFC_ISYM_SHIFTR)\n+    f->value.function.name = gfc_get_string (\"shiftr_i%d\", f->ts.kind);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+\n void\n gfc_resolve_sign (gfc_expr *f, gfc_expr *a, gfc_expr *b ATTRIBUTE_UNUSED)\n {"}, {"sha": "a7b678f406a7b65d321250ce5f8532e3a491e6ca", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 317, "deletions": 27, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -1464,6 +1464,74 @@ gfc_simplify_btest (gfc_expr *e, gfc_expr *bit)\n }\n \n \n+static int\n+compare_bitwise (gfc_expr *i, gfc_expr *j)\n+{\n+  mpz_t x, y;\n+  int k, res;\n+\n+  gcc_assert (i->ts.type == BT_INTEGER);\n+  gcc_assert (j->ts.type == BT_INTEGER);\n+\n+  mpz_init_set (x, i->value.integer);\n+  k = gfc_validate_kind (i->ts.type, i->ts.kind, false);\n+  convert_mpz_to_unsigned (x, gfc_integer_kinds[k].bit_size);\n+\n+  mpz_init_set (y, j->value.integer);\n+  k = gfc_validate_kind (j->ts.type, j->ts.kind, false);\n+  convert_mpz_to_unsigned (y, gfc_integer_kinds[k].bit_size);\n+\n+  res = mpz_cmp (x, y);\n+  mpz_clear (x);\n+  mpz_clear (y);\n+  return res;\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_bge (gfc_expr *i, gfc_expr *j)\n+{\n+  if (i->expr_type != EXPR_CONSTANT || j->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  return gfc_get_logical_expr (gfc_default_logical_kind, &i->where,\n+\t\t\t       compare_bitwise (i, j) >= 0);\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_bgt (gfc_expr *i, gfc_expr *j)\n+{\n+  if (i->expr_type != EXPR_CONSTANT || j->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  return gfc_get_logical_expr (gfc_default_logical_kind, &i->where,\n+\t\t\t       compare_bitwise (i, j) > 0);\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_ble (gfc_expr *i, gfc_expr *j)\n+{\n+  if (i->expr_type != EXPR_CONSTANT || j->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  return gfc_get_logical_expr (gfc_default_logical_kind, &i->where,\n+\t\t\t       compare_bitwise (i, j) <= 0);\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_blt (gfc_expr *i, gfc_expr *j)\n+{\n+  if (i->expr_type != EXPR_CONSTANT || j->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  return gfc_get_logical_expr (gfc_default_logical_kind, &i->where,\n+\t\t\t       compare_bitwise (i, j) < 0);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_ceiling (gfc_expr *e, gfc_expr *k)\n {\n@@ -1814,6 +1882,64 @@ gfc_simplify_dprod (gfc_expr *x, gfc_expr *y)\n }\n \n \n+static gfc_expr *\n+simplify_dshift (gfc_expr *arg1, gfc_expr *arg2, gfc_expr *shiftarg,\n+\t\t      bool right)\n+{\n+  gfc_expr *result;\n+  int i, k, size, shift;\n+\n+  if (arg1->expr_type != EXPR_CONSTANT || arg2->expr_type != EXPR_CONSTANT\n+      || shiftarg->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  k = gfc_validate_kind (BT_INTEGER, arg1->ts.kind, false);\n+  size = gfc_integer_kinds[k].bit_size;\n+\n+  if (gfc_extract_int (shiftarg, &shift) != NULL)\n+    {\n+      gfc_error (\"Invalid SHIFT argument of DSHIFTL at %L\", &shiftarg->where);\n+      return &gfc_bad_expr;\n+    }\n+\n+  gcc_assert (shift >= 0 && shift <= size);\n+\n+  /* DSHIFTR(I,J,SHIFT) = DSHIFTL(I,J,SIZE-SHIFT).  */\n+  if (right)\n+    shift = size - shift;\n+\n+  result = gfc_get_constant_expr (BT_INTEGER, arg1->ts.kind, &arg1->where);\n+  mpz_set_ui (result->value.integer, 0);\n+\n+  for (i = 0; i < shift; i++)\n+    if (mpz_tstbit (arg2->value.integer, size - shift + i))\n+      mpz_setbit (result->value.integer, i);\n+\n+  for (i = 0; i < size - shift; i++)\n+    if (mpz_tstbit (arg1->value.integer, i))\n+      mpz_setbit (result->value.integer, shift + i);\n+\n+  /* Convert to a signed value.  */\n+  convert_mpz_to_signed (result->value.integer, size);\n+\n+  return result;\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_dshiftr (gfc_expr *arg1, gfc_expr *arg2, gfc_expr *shiftarg)\n+{\n+  return simplify_dshift (arg1, arg2, shiftarg, true);\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_dshiftl (gfc_expr *arg1, gfc_expr *arg2, gfc_expr *shiftarg)\n+{\n+  return simplify_dshift (arg1, arg2, shiftarg, false);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_erf (gfc_expr *x)\n {\n@@ -2776,56 +2902,75 @@ gfc_simplify_isnan (gfc_expr *x)\n }\n \n \n-gfc_expr *\n-gfc_simplify_ishft (gfc_expr *e, gfc_expr *s)\n+/* Performs a shift on its first argument.  Depending on the last\n+   argument, the shift can be arithmetic, i.e. with filling from the\n+   left like in the SHIFTA intrinsic.  */\n+static gfc_expr *\n+simplify_shift (gfc_expr *e, gfc_expr *s, const char *name,\n+\t\tbool arithmetic, int direction)\n {\n   gfc_expr *result;\n-  int shift, ashift, isize, k, *bits, i;\n+  int ashift, *bits, i, k, bitsize, shift;\n \n   if (e->expr_type != EXPR_CONSTANT || s->expr_type != EXPR_CONSTANT)\n     return NULL;\n-\n   if (gfc_extract_int (s, &shift) != NULL)\n     {\n-      gfc_error (\"Invalid second argument of ISHFT at %L\", &s->where);\n+      gfc_error (\"Invalid second argument of %s at %L\", name, &s->where);\n       return &gfc_bad_expr;\n     }\n \n   k = gfc_validate_kind (BT_INTEGER, e->ts.kind, false);\n+  bitsize = gfc_integer_kinds[k].bit_size;\n \n-  isize = gfc_integer_kinds[k].bit_size;\n+  result = gfc_get_constant_expr (e->ts.type, e->ts.kind, &e->where);\n \n-  if (shift >= 0)\n-    ashift = shift;\n-  else\n-    ashift = -shift;\n+  if (shift == 0)\n+    {\n+      mpz_set (result->value.integer, e->value.integer);\n+      return result;\n+    }\n \n-  if (ashift > isize)\n+  if (direction > 0 && shift < 0)\n     {\n-      gfc_error (\"Magnitude of second argument of ISHFT exceeds bit size \"\n-\t\t \"at %L\", &s->where);\n+      /* Left shift, as in SHIFTL.  */\n+      gfc_error (\"Second argument of %s is negative at %L\", name, &e->where);\n       return &gfc_bad_expr;\n     }\n+  else if (direction < 0)\n+    {\n+      /* Right shift, as in SHIFTR or SHIFTA.  */\n+      if (shift < 0)\n+\t{\n+\t  gfc_error (\"Second argument of %s is negative at %L\",\n+\t\t     name, &e->where);\n+\t  return &gfc_bad_expr;\n+\t}\n \n-  result = gfc_get_constant_expr (e->ts.type, e->ts.kind, &e->where);\n+      shift = -shift;\n+    }\n \n-  if (shift == 0)\n+  ashift = (shift >= 0 ? shift : -shift);\n+\n+  if (ashift > bitsize)\n     {\n-      mpz_set (result->value.integer, e->value.integer);\n-      return range_check (result, \"ISHFT\");\n+      gfc_error (\"Magnitude of second argument of %s exceeds bit size \"\n+\t\t \"at %L\", name, &e->where);\n+      return &gfc_bad_expr;\n     }\n-  \n-  bits = XCNEWVEC (int, isize);\n \n-  for (i = 0; i < isize; i++)\n+  bits = XCNEWVEC (int, bitsize);\n+\n+  for (i = 0; i < bitsize; i++)\n     bits[i] = mpz_tstbit (e->value.integer, i);\n \n   if (shift > 0)\n     {\n+      /* Left shift.  */\n       for (i = 0; i < shift; i++)\n \tmpz_clrbit (result->value.integer, i);\n \n-      for (i = 0; i < isize - shift; i++)\n+      for (i = 0; i < bitsize - shift; i++)\n \t{\n \t  if (bits[i] == 0)\n \t    mpz_clrbit (result->value.integer, i + shift);\n@@ -2835,10 +2980,15 @@ gfc_simplify_ishft (gfc_expr *e, gfc_expr *s)\n     }\n   else\n     {\n-      for (i = isize - 1; i >= isize - ashift; i--)\n-\tmpz_clrbit (result->value.integer, i);\n+      /* Right shift.  */\n+      if (arithmetic && bits[bitsize - 1])\n+\tfor (i = bitsize - 1; i >= bitsize - ashift; i--)\n+\t  mpz_setbit (result->value.integer, i);\n+      else\n+\tfor (i = bitsize - 1; i >= bitsize - ashift; i--)\n+\t  mpz_clrbit (result->value.integer, i);\n \n-      for (i = isize - 1; i >= ashift; i--)\n+      for (i = bitsize - 1; i >= ashift; i--)\n \t{\n \t  if (bits[i] == 0)\n \t    mpz_clrbit (result->value.integer, i - ashift);\n@@ -2847,13 +2997,55 @@ gfc_simplify_ishft (gfc_expr *e, gfc_expr *s)\n \t}\n     }\n \n-  convert_mpz_to_signed (result->value.integer, isize);\n-\n+  convert_mpz_to_signed (result->value.integer, bitsize);\n   gfc_free (bits);\n+\n   return result;\n }\n \n \n+gfc_expr *\n+gfc_simplify_ishft (gfc_expr *e, gfc_expr *s)\n+{\n+  return simplify_shift (e, s, \"ISHFT\", false, 0);\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_lshift (gfc_expr *e, gfc_expr *s)\n+{\n+  return simplify_shift (e, s, \"LSHIFT\", false, 1);\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_rshift (gfc_expr *e, gfc_expr *s)\n+{\n+  return simplify_shift (e, s, \"RSHIFT\", true, -1);\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_shifta (gfc_expr *e, gfc_expr *s)\n+{\n+  return simplify_shift (e, s, \"SHIFTA\", true, -1);\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_shiftl (gfc_expr *e, gfc_expr *s)\n+{\n+  return simplify_shift (e, s, \"SHIFTL\", false, 1);\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_shiftr (gfc_expr *e, gfc_expr *s)\n+{\n+  return simplify_shift (e, s, \"SHIFTR\", false, -1);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_ishftc (gfc_expr *e, gfc_expr *s, gfc_expr *sz)\n {\n@@ -3656,6 +3848,73 @@ gfc_simplify_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n }\n \n \n+gfc_expr *\n+gfc_simplify_maskr (gfc_expr *i, gfc_expr *kind_arg)\n+{\n+  gfc_expr *result;\n+  int kind, arg, k;\n+  const char *s;\n+\n+  if (i->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+ \n+  kind = get_kind (BT_INTEGER, kind_arg, \"MASKR\", gfc_default_integer_kind);\n+  if (kind == -1)\n+    return &gfc_bad_expr;\n+  k = gfc_validate_kind (BT_INTEGER, kind, false);\n+\n+  s = gfc_extract_int (i, &arg);\n+  gcc_assert (!s);\n+\n+  result = gfc_get_constant_expr (BT_INTEGER, kind, &i->where);\n+\n+  /* MASKR(n) = 2^n - 1 */\n+  mpz_set_ui (result->value.integer, 1);\n+  mpz_mul_2exp (result->value.integer, result->value.integer, arg);\n+  mpz_sub_ui (result->value.integer, result->value.integer, 1);\n+\n+  convert_mpz_to_signed (result->value.integer, gfc_integer_kinds[k].bit_size);\n+\n+  return result;\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_maskl (gfc_expr *i, gfc_expr *kind_arg)\n+{\n+  gfc_expr *result;\n+  int kind, arg, k;\n+  const char *s;\n+  mpz_t z;\n+\n+  if (i->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+ \n+  kind = get_kind (BT_INTEGER, kind_arg, \"MASKL\", gfc_default_integer_kind);\n+  if (kind == -1)\n+    return &gfc_bad_expr;\n+  k = gfc_validate_kind (BT_INTEGER, kind, false);\n+\n+  s = gfc_extract_int (i, &arg);\n+  gcc_assert (!s);\n+\n+  result = gfc_get_constant_expr (BT_INTEGER, kind, &i->where);\n+\n+  /* MASKL(n) = 2^bit_size - 2^(bit_size - n) */\n+  mpz_init_set_ui (z, 1);\n+  mpz_mul_2exp (z, z, gfc_integer_kinds[k].bit_size);\n+  mpz_set_ui (result->value.integer, 1);\n+  mpz_mul_2exp (result->value.integer, result->value.integer,\n+\t\tgfc_integer_kinds[k].bit_size - arg);\n+  mpz_sub (result->value.integer, z, result->value.integer);\n+  mpz_clear (z);\n+\n+  convert_mpz_to_signed (result->value.integer, gfc_integer_kinds[k].bit_size);\n+\n+  return result;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)\n {\n@@ -3668,7 +3927,38 @@ gfc_simplify_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)\n }\n \n \n-/* Selects bewteen current value and extremum for simplify_min_max\n+gfc_expr *\n+gfc_simplify_merge_bits (gfc_expr *i, gfc_expr *j, gfc_expr *mask_expr)\n+{\n+  mpz_t arg1, arg2, mask;\n+  gfc_expr *result;\n+\n+  if (i->expr_type != EXPR_CONSTANT || j->expr_type != EXPR_CONSTANT\n+      || mask_expr->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  result = gfc_get_constant_expr (BT_INTEGER, i->ts.kind, &i->where);\n+\n+  /* Convert all argument to unsigned.  */\n+  mpz_init_set (arg1, i->value.integer);\n+  mpz_init_set (arg2, j->value.integer);\n+  mpz_init_set (mask, mask_expr->value.integer);\n+\n+  /* MERGE_BITS(I,J,MASK) = IOR (IAND (I, MASK), IAND (J, NOT (MASK))).  */\n+  mpz_and (arg1, arg1, mask);\n+  mpz_com (mask, mask);\n+  mpz_and (arg2, arg2, mask);\n+  mpz_ior (result->value.integer, arg1, arg2);\n+\n+  mpz_clear (arg1);\n+  mpz_clear (arg2);\n+  mpz_clear (mask);\n+\n+  return result;\n+}\n+\n+\n+/* Selects between current value and extremum for simplify_min_max\n    and simplify_minval_maxval.  */\n static void\n min_max_choose (gfc_expr *arg, gfc_expr *extremum, int sign)"}, {"sha": "29116d6bf8006d5a6aa8d14df0706823d6761e7e", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 236, "deletions": 7, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -1288,6 +1288,62 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n     }\n }\n \n+/* DSHIFTL(I,J,S) = (I << S) | (J >> (BITSIZE(J) - S))\n+   DSHIFTR(I,J,S) = (I << (BITSIZE(I) - S)) | (J >> S)\n+   where the right shifts are logical (i.e. 0's are shifted in).\n+   Because SHIFT_EXPR's want shifts strictly smaller than the integral\n+   type width, we have to special-case both S == 0 and S == BITSIZE(J):\n+     DSHIFTL(I,J,0) = I\n+     DSHIFTL(I,J,BITSIZE) = J\n+     DSHIFTR(I,J,0) = J\n+     DSHIFTR(I,J,BITSIZE) = I.  */\n+\n+static void\n+gfc_conv_intrinsic_dshift (gfc_se * se, gfc_expr * expr, bool dshiftl)\n+{\n+  tree type, utype, stype, arg1, arg2, shift, res, left, right;\n+  tree args[3], cond, tmp;\n+  int bitsize;\n+\n+  gfc_conv_intrinsic_function_args (se, expr, args, 3);\n+\n+  gcc_assert (TREE_TYPE (args[0]) == TREE_TYPE (args[1]));\n+  type = TREE_TYPE (args[0]);\n+  bitsize = TYPE_PRECISION (type);\n+  utype = unsigned_type_for (type);\n+  stype = TREE_TYPE (args[2]);\n+\n+  arg1 = gfc_evaluate_now (args[0], &se->pre);\n+  arg2 = gfc_evaluate_now (args[1], &se->pre);\n+  shift = gfc_evaluate_now (args[2], &se->pre);\n+\n+  /* The generic case.  */\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, stype,\n+\t\t\t build_int_cst (stype, bitsize), shift);\n+  left = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n+\t\t\t  arg1, dshiftl ? shift : tmp);\n+\n+  right = fold_build2_loc (input_location, RSHIFT_EXPR, utype,\n+\t\t\t   fold_convert (utype, arg2), dshiftl ? tmp : shift);\n+  right = fold_convert (type, right);\n+\n+  res = fold_build2_loc (input_location, BIT_IOR_EXPR, type, left, right);\n+\n+  /* Special cases.  */\n+  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, shift,\n+\t\t\t  build_int_cst (stype, 0));\n+  res = fold_build3_loc (input_location, COND_EXPR, type, cond,\n+\t\t\t dshiftl ? arg1 : arg2, res);\n+\n+  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, shift,\n+\t\t\t  build_int_cst (stype, bitsize));\n+  res = fold_build3_loc (input_location, COND_EXPR, type, cond,\n+\t\t\t dshiftl ? arg2 : arg1, res);\n+\n+  se->expr = res;\n+}\n+\n+\n /* Positive difference DIM (x, y) = ((x - y) < 0) ? 0 : x - y.  */\n \n static void\n@@ -3209,6 +3265,33 @@ gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n   se->expr = convert (type, tmp);\n }\n \n+\n+/* Generate code for BGE, BGT, BLE and BLT intrinsics.  */\n+static void\n+gfc_conv_intrinsic_bitcomp (gfc_se * se, gfc_expr * expr, enum tree_code op)\n+{\n+  tree args[2];\n+\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+\n+  /* Convert both arguments to the unsigned type of the same size.  */\n+  args[0] = fold_convert (unsigned_type_for (TREE_TYPE (args[0])), args[0]);\n+  args[1] = fold_convert (unsigned_type_for (TREE_TYPE (args[1])), args[1]);\n+\n+  /* If they have unequal type size, convert to the larger one.  */\n+  if (TYPE_PRECISION (TREE_TYPE (args[0]))\n+      > TYPE_PRECISION (TREE_TYPE (args[1])))\n+    args[1] = fold_convert (TREE_TYPE (args[0]), args[1]);\n+  else if (TYPE_PRECISION (TREE_TYPE (args[1]))\n+\t   > TYPE_PRECISION (TREE_TYPE (args[0])))\n+    args[0] = fold_convert (TREE_TYPE (args[1]), args[0]);\n+\n+  /* Now, we compare them.  */\n+  se->expr = fold_build2_loc (input_location, op, boolean_type_node,\n+\t\t\t      args[0], args[1]);\n+}\n+\n+\n /* Generate code to perform the specified operation.  */\n static void\n gfc_conv_intrinsic_bitop (gfc_se * se, gfc_expr * expr, enum tree_code op)\n@@ -3277,18 +3360,39 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n   se->expr = fold_build2_loc (input_location, BIT_AND_EXPR, type, tmp, mask);\n }\n \n-/* RSHIFT (I, SHIFT) = I >> SHIFT\n-   LSHIFT (I, SHIFT) = I << SHIFT  */\n static void\n-gfc_conv_intrinsic_rlshift (gfc_se * se, gfc_expr * expr, int right_shift)\n+gfc_conv_intrinsic_shift (gfc_se * se, gfc_expr * expr, bool right_shift,\n+\t\t\t  bool arithmetic)\n {\n-  tree args[2];\n+  tree args[2], type, num_bits, cond;\n \n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n \n+  args[0] = gfc_evaluate_now (args[0], &se->pre);\n+  args[1] = gfc_evaluate_now (args[1], &se->pre);\n+  type = TREE_TYPE (args[0]);\n+\n+  if (!arithmetic)\n+    args[0] = fold_convert (unsigned_type_for (type), args[0]);\n+  else\n+    gcc_assert (right_shift);\n+\n   se->expr = fold_build2_loc (input_location,\n \t\t\t      right_shift ? RSHIFT_EXPR : LSHIFT_EXPR,\n \t\t\t      TREE_TYPE (args[0]), args[0], args[1]);\n+\n+  if (!arithmetic)\n+    se->expr = fold_convert (type, se->expr);\n+\n+  /* The Fortran standard allows shift widths <= BIT_SIZE(I), whereas\n+     gcc requires a shift width < BIT_SIZE(I), so we have to catch this\n+     special case.  */\n+  num_bits = build_int_cst (TREE_TYPE (args[1]), TYPE_PRECISION (type));\n+  cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t\t\t  args[1], num_bits);\n+\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond,\n+\t\t\t      build_int_cst (type, 0), se->expr);\n }\n \n /* ISHFT (I, SHIFT) = (abs (shift) >= BIT_SIZE (i))\n@@ -3510,7 +3614,6 @@ gfc_conv_intrinsic_leadz (gfc_se * se, gfc_expr * expr)\n \t      return clzll ((unsigned long long) (x >> ULLSIZE));\n \t    else\n \t      return ULL_SIZE + clzll ((unsigned long long) x);\n-\n \t where ULL_MAX is the largest value that a ULL_MAX can hold\n \t (0xFFFFFFFFFFFFFFFF for a 64-bit long long type), and ULLSIZE\n \t is the bit-size of the long long type (64 in this example).  */\n@@ -4032,6 +4135,84 @@ gfc_conv_intrinsic_merge (gfc_se * se, gfc_expr * expr)\n }\n \n \n+/* MERGE_BITS (I, J, MASK) = (I & MASK) | (I & (~MASK)).  */\n+\n+static void\n+gfc_conv_intrinsic_merge_bits (gfc_se * se, gfc_expr * expr)\n+{\n+  tree args[3], mask, type;\n+\n+  gfc_conv_intrinsic_function_args (se, expr, args, 3);\n+  mask = gfc_evaluate_now (args[2], &se->pre);\n+\n+  type = TREE_TYPE (args[0]);\n+  gcc_assert (TREE_TYPE (args[1]) == type);\n+  gcc_assert (TREE_TYPE (mask) == type);\n+\n+  args[0] = fold_build2_loc (input_location, BIT_AND_EXPR, type, args[0], mask);\n+  args[1] = fold_build2_loc (input_location, BIT_AND_EXPR, type, args[1],\n+\t\t\t     fold_build1_loc (input_location, BIT_NOT_EXPR,\n+\t\t\t\t\t      type, mask));\n+  se->expr = fold_build2_loc (input_location, BIT_IOR_EXPR, type,\n+\t\t\t      args[0], args[1]);\n+}\n+\n+\n+/* MASKL(n)  =  n == 0 ? 0 : (~0) << (BIT_SIZE - n)\n+   MASKR(n)  =  n == BIT_SIZE ? ~0 : ~((~0) << n)  */\n+\n+static void\n+gfc_conv_intrinsic_mask (gfc_se * se, gfc_expr * expr, int left)\n+{\n+  tree arg, allones, type, utype, res, cond, bitsize;\n+  int i;\n+ \n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  arg = gfc_evaluate_now (arg, &se->pre);\n+\n+  type = gfc_get_int_type (expr->ts.kind);\n+  utype = unsigned_type_for (type);\n+\n+  i = gfc_validate_kind (BT_INTEGER, expr->ts.kind, false);\n+  bitsize = build_int_cst (TREE_TYPE (arg), gfc_integer_kinds[i].bit_size);\n+\n+  allones = fold_build1_loc (input_location, BIT_NOT_EXPR, utype,\n+\t\t\t     build_int_cst (utype, 0));\n+\n+  if (left)\n+    {\n+      /* Left-justified mask.  */\n+      res = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (arg),\n+\t\t\t     bitsize, arg);\n+      res = fold_build2_loc (input_location, LSHIFT_EXPR, utype, allones,\n+\t\t\t     fold_convert (utype, res));\n+\n+      /* Special case arg == 0, because SHIFT_EXPR wants a shift strictly\n+\t smaller than type width.  */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, arg,\n+\t\t\t      build_int_cst (TREE_TYPE (arg), 0));\n+      res = fold_build3_loc (input_location, COND_EXPR, utype, cond,\n+\t\t\t     build_int_cst (utype, 0), res);\n+    }\n+  else\n+    {\n+      /* Right-justified mask.  */\n+      res = fold_build2_loc (input_location, LSHIFT_EXPR, utype, allones,\n+\t\t\t     fold_convert (utype, arg));\n+      res = fold_build1_loc (input_location, BIT_NOT_EXPR, utype, res);\n+\n+      /* Special case agr == bit_size, because SHIFT_EXPR wants a shift\n+\t strictly smaller than type width.  */\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t      arg, bitsize);\n+      res = fold_build3_loc (input_location, COND_EXPR, utype,\n+\t\t\t     cond, allones, res);\n+    }\n+\n+  se->expr = fold_convert (type, res);\n+}\n+\n+\n /* FRACTION (s) is translated into frexp (s, &dummy_int).  */\n static void\n gfc_conv_intrinsic_fraction (gfc_se * se, gfc_expr * expr)\n@@ -5548,6 +5729,22 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_btest (se, expr);\n       break;\n \n+    case GFC_ISYM_BGE:\n+      gfc_conv_intrinsic_bitcomp (se, expr, GE_EXPR);\n+      break;\n+\n+    case GFC_ISYM_BGT:\n+      gfc_conv_intrinsic_bitcomp (se, expr, GT_EXPR);\n+      break;\n+\n+    case GFC_ISYM_BLE:\n+      gfc_conv_intrinsic_bitcomp (se, expr, LE_EXPR);\n+      break;\n+\n+    case GFC_ISYM_BLT:\n+      gfc_conv_intrinsic_bitcomp (se, expr, LT_EXPR);\n+      break;\n+\n     case GFC_ISYM_ACHAR:\n     case GFC_ISYM_CHAR:\n       gfc_conv_intrinsic_char (se, expr);\n@@ -5625,6 +5822,14 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_dprod (se, expr);\n       break;\n \n+    case GFC_ISYM_DSHIFTL:\n+      gfc_conv_intrinsic_dshift (se, expr, true);\n+      break;\n+\n+    case GFC_ISYM_DSHIFTR:\n+      gfc_conv_intrinsic_dshift (se, expr, false);\n+      break;\n+\n     case GFC_ISYM_FDATE:\n       gfc_conv_intrinsic_fdate (se, expr);\n       break;\n@@ -5704,11 +5909,23 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_LSHIFT:\n-      gfc_conv_intrinsic_rlshift (se, expr, 0);\n+      gfc_conv_intrinsic_shift (se, expr, false, false);\n       break;\n \n     case GFC_ISYM_RSHIFT:\n-      gfc_conv_intrinsic_rlshift (se, expr, 1);\n+      gfc_conv_intrinsic_shift (se, expr, true, true);\n+      break;\n+\n+    case GFC_ISYM_SHIFTA:\n+      gfc_conv_intrinsic_shift (se, expr, true, true);\n+      break;\n+\n+    case GFC_ISYM_SHIFTL:\n+      gfc_conv_intrinsic_shift (se, expr, false, false);\n+      break;\n+\n+    case GFC_ISYM_SHIFTR:\n+      gfc_conv_intrinsic_shift (se, expr, true, false);\n       break;\n \n     case GFC_ISYM_ISHFT:\n@@ -5773,6 +5990,14 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_strcmp (se, expr, LT_EXPR);\n       break;\n \n+    case GFC_ISYM_MASKL:\n+      gfc_conv_intrinsic_mask (se, expr, 1);\n+      break;\n+\n+    case GFC_ISYM_MASKR:\n+      gfc_conv_intrinsic_mask (se, expr, 0);\n+      break;\n+\n     case GFC_ISYM_MAX:\n       if (expr->ts.type == BT_CHARACTER)\n \tgfc_conv_intrinsic_minmax_char (se, expr, 1);\n@@ -5792,6 +6017,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_merge (se, expr);\n       break;\n \n+    case GFC_ISYM_MERGE_BITS:\n+      gfc_conv_intrinsic_merge_bits (se, expr);\n+      break;\n+\n     case GFC_ISYM_MIN:\n       if (expr->ts.type == BT_CHARACTER)\n \tgfc_conv_intrinsic_minmax_char (se, expr, -1);"}, {"sha": "8c649a22ed90aaad6f0035055e2c97fb03205c37", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -1,3 +1,18 @@\n+2010-09-08  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/38282\n+\t* gfortran.dg/bit_comparison_1.F90: New test.\n+\t* gfortran.dg/leadz_trailz_3.f90: New test.\n+\t* gfortran.dg/masklr_2.F90: New test.\n+\t* gfortran.dg/shiftalr_1.F90: New test.\n+\t* gfortran.dg/merge_bits_2.F90: New test.\n+\t* gfortran.dg/dshift_2.F90: New test.\n+\t* gfortran.dg/bit_comparison_2.F90: New test.\n+\t* gfortran.dg/masklr_1.F90: New test.\n+\t* gfortran.dg/merge_bits_1.F90: New test.\n+\t* gfortran.dg/dshift_1.F90: New test.\n+\t* gfortran.dg/shiftalr_2.F90: New test.\n+\n 2010-09-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/type-stream-1.m: Replaced with a test that tests that"}, {"sha": "97b00b5be7ff4936c996147962470e541777c911", "filename": "gcc/testsuite/gfortran.dg/bit_comparison_1.F90", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbit_comparison_1.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbit_comparison_1.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbit_comparison_1.F90?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -0,0 +1,153 @@\n+! Test the BGE, BGT, BLE and BLT intrinsics.\n+!\n+! { dg-do run }\n+! { dg-options \"-ffree-line-length-none\" }\n+\n+  interface run_bge\n+    procedure run_bge1\n+    procedure run_bge2\n+    procedure run_bge4\n+    procedure run_bge8\n+  end interface\n+\n+  interface run_bgt\n+    procedure run_bgt1\n+    procedure run_bgt2\n+    procedure run_bgt4\n+    procedure run_bgt8\n+  end interface\n+\n+  interface run_ble\n+    procedure run_ble1\n+    procedure run_ble2\n+    procedure run_ble4\n+    procedure run_ble8\n+  end interface\n+\n+  interface run_blt\n+    procedure run_blt1\n+    procedure run_blt2\n+    procedure run_blt4\n+    procedure run_blt8\n+  end interface\n+\n+#define CHECK(I,J,RES) \\\n+  if (bge(I,J) .neqv. RES) call abort ; \\\n+  if (run_bge(I,J) .neqv. RES) call abort ; \\\n+  if (bgt(I,J) .neqv. (RES .and. (I/=J))) call abort ; \\\n+  if (run_bgt(I,J) .neqv. (RES .and. (I/=J))) call abort ; \\\n+  if (ble(J,I) .neqv. RES) call abort ; \\\n+  if (run_ble(J,I) .neqv. RES) call abort ; \\\n+  if (blt(J,I) .neqv. (RES .and. (I/=J))) call abort ; \\\n+  if (run_blt(J,I) .neqv. (RES .and. (I/=J))) call abort\n+\n+#define T .true.\n+#define F .false.\n+\n+  CHECK(0_1, 0_1, T)\n+  CHECK(1_1, 0_1, T)\n+  CHECK(0_1, 107_1, F)\n+  CHECK(5_1, huge(0_1) / 2_1, F)\n+  CHECK(5_1, huge(0_1), F)\n+  CHECK(-1_1, 0_1, T)\n+  CHECK(0_1, -19_1, F)\n+  CHECK(huge(0_1), -19_1, F)\n+\n+  CHECK(0_2, 0_2, T)\n+  CHECK(1_2, 0_2, T)\n+  CHECK(0_2, 107_2, F)\n+  CHECK(5_2, huge(0_2) / 2_2, F)\n+  CHECK(5_2, huge(0_2), F)\n+  CHECK(-1_2, 0_2, T)\n+  CHECK(0_2, -19_2, F)\n+  CHECK(huge(0_2), -19_2, F)\n+\n+  CHECK(0_4, 0_4, T)\n+  CHECK(1_4, 0_4, T)\n+  CHECK(0_4, 107_4, F)\n+  CHECK(5_4, huge(0_4) / 2_4, F)\n+  CHECK(5_4, huge(0_4), F)\n+  CHECK(-1_4, 0_4, T)\n+  CHECK(0_4, -19_4, F)\n+  CHECK(huge(0_4), -19_4, F)\n+\n+  CHECK(0_8, 0_8, T)\n+  CHECK(1_8, 0_8, T)\n+  CHECK(0_8, 107_8, F)\n+  CHECK(5_8, huge(0_8) / 2_8, F)\n+  CHECK(5_8, huge(0_8), F)\n+  CHECK(-1_8, 0_8, T)\n+  CHECK(0_8, -19_8, F)\n+  CHECK(huge(0_8), -19_8, F)\n+\n+contains\n+\n+  pure logical function run_bge1 (i, j) result(res)\n+    integer(kind=1), intent(in) :: i, j\n+    res = bge(i,j)\n+  end function\n+  pure logical function run_bgt1 (i, j) result(res)\n+    integer(kind=1), intent(in) :: i, j\n+    res = bgt(i,j)\n+  end function\n+  pure logical function run_ble1 (i, j) result(res)\n+    integer(kind=1), intent(in) :: i, j\n+    res = ble(i,j)\n+  end function\n+  pure logical function run_blt1 (i, j) result(res)\n+    integer(kind=1), intent(in) :: i, j\n+    res = blt(i,j)\n+  end function\n+\n+  pure logical function run_bge2 (i, j) result(res)\n+    integer(kind=2), intent(in) :: i, j\n+    res = bge(i,j)\n+  end function\n+  pure logical function run_bgt2 (i, j) result(res)\n+    integer(kind=2), intent(in) :: i, j\n+    res = bgt(i,j)\n+  end function\n+  pure logical function run_ble2 (i, j) result(res)\n+    integer(kind=2), intent(in) :: i, j\n+    res = ble(i,j)\n+  end function\n+  pure logical function run_blt2 (i, j) result(res)\n+    integer(kind=2), intent(in) :: i, j\n+    res = blt(i,j)\n+  end function\n+\n+  pure logical function run_bge4 (i, j) result(res)\n+    integer(kind=4), intent(in) :: i, j\n+    res = bge(i,j)\n+  end function\n+  pure logical function run_bgt4 (i, j) result(res)\n+    integer(kind=4), intent(in) :: i, j\n+    res = bgt(i,j)\n+  end function\n+  pure logical function run_ble4 (i, j) result(res)\n+    integer(kind=4), intent(in) :: i, j\n+    res = ble(i,j)\n+  end function\n+  pure logical function run_blt4 (i, j) result(res)\n+    integer(kind=4), intent(in) :: i, j\n+    res = blt(i,j)\n+  end function\n+\n+  pure logical function run_bge8 (i, j) result(res)\n+    integer(kind=8), intent(in) :: i, j\n+    res = bge(i,j)\n+  end function\n+  pure logical function run_bgt8 (i, j) result(res)\n+    integer(kind=8), intent(in) :: i, j\n+    res = bgt(i,j)\n+  end function\n+  pure logical function run_ble8 (i, j) result(res)\n+    integer(kind=8), intent(in) :: i, j\n+    res = ble(i,j)\n+  end function\n+  pure logical function run_blt8 (i, j) result(res)\n+    integer(kind=8), intent(in) :: i, j\n+    res = blt(i,j)\n+  end function\n+\n+end"}, {"sha": "73d0679d08896c8ba74ab9363ac3a4130a0b20cd", "filename": "gcc/testsuite/gfortran.dg/bit_comparison_2.F90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbit_comparison_2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbit_comparison_2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbit_comparison_2.F90?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -0,0 +1,48 @@\n+! Test the BGE, BGT, BLE and BLT intrinsics.\n+!\n+! { dg-do run }\n+! { dg-options \"-ffree-line-length-none\" }\n+! { dg-require-effective-target fortran_integer_16 }\n+\n+#define CHECK(I,J,RES) \\\n+  if (bge(I,J) .neqv. RES) call abort ; \\\n+  if (run_bge(I,J) .neqv. RES) call abort ; \\\n+  if (bgt(I,J) .neqv. (RES .and. (I/=J))) call abort ; \\\n+  if (run_bgt(I,J) .neqv. (RES .and. (I/=J))) call abort ; \\\n+  if (ble(J,I) .neqv. RES) call abort ; \\\n+  if (run_ble(J,I) .neqv. RES) call abort ; \\\n+  if (blt(J,I) .neqv. (RES .and. (I/=J))) call abort ; \\\n+  if (run_blt(J,I) .neqv. (RES .and. (I/=J))) call abort\n+\n+#define T .true.\n+#define F .false.\n+\n+  CHECK(0_16, 0_16, T)\n+  CHECK(1_16, 0_16, T)\n+  CHECK(0_16, 107_16, F)\n+  CHECK(5_16, huge(0_16) / 2_16, F)\n+  CHECK(5_16, huge(0_16), F)\n+  CHECK(-1_16, 0_16, T)\n+  CHECK(0_16, -19_16, F)\n+  CHECK(huge(0_16), -19_16, F)\n+\n+contains\n+\n+  pure logical function run_bge (i, j) result(res)\n+    integer(kind=16), intent(in) :: i, j\n+    res = bge(i,j)\n+  end function\n+  pure logical function run_bgt (i, j) result(res)\n+    integer(kind=16), intent(in) :: i, j\n+    res = bgt(i,j)\n+  end function\n+  pure logical function run_ble (i, j) result(res)\n+    integer(kind=16), intent(in) :: i, j\n+    res = ble(i,j)\n+  end function\n+  pure logical function run_blt (i, j) result(res)\n+    integer(kind=16), intent(in) :: i, j\n+    res = blt(i,j)\n+  end function\n+\n+end"}, {"sha": "ce2a5f4320494ffb4ee4306f82b4f195e937aec6", "filename": "gcc/testsuite/gfortran.dg/dshift_1.F90", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdshift_1.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdshift_1.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdshift_1.F90?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -0,0 +1,177 @@\n+! Test the DSHIFTL and DSHIFTR intrinsics.\n+!\n+! { dg-do run }\n+! { dg-options \"-ffree-line-length-none\" }\n+\n+  implicit none\n+\n+  interface run_dshiftl\n+    procedure dshiftl_1\n+    procedure dshiftl_2\n+    procedure dshiftl_4\n+    procedure dshiftl_8\n+  end interface\n+  interface run_dshiftr\n+    procedure dshiftr_1\n+    procedure dshiftr_2\n+    procedure dshiftr_4\n+    procedure dshiftr_8\n+  end interface\n+\n+#define RESL(I,J,SHIFT) \\\n+  IOR(SHIFTL(I,SHIFT),SHIFTR(J,BIT_SIZE(J)-SHIFT))\n+#define RESR(I,J,SHIFT) \\\n+  IOR(SHIFTL(I,BIT_SIZE(I)-SHIFT),SHIFTR(J,SHIFT))\n+\n+#define CHECK(I,J,SHIFT) \\\n+  if (dshiftl(I,J,SHIFT) /= RESL(I,J,SHIFT)) call abort ; \\\n+  if (dshiftr(I,J,SHIFT) /= RESR(I,J,SHIFT)) call abort ; \\\n+  if (run_dshiftl(I,J,SHIFT) /= RESL(I,J,SHIFT)) call abort ; \\\n+  if (run_dshiftr(I,J,SHIFT) /= RESR(I,J,SHIFT)) call abort\n+\n+  CHECK(0_1,0_1,0)\n+  CHECK(0_1,0_1,1)\n+  CHECK(0_1,0_1,7)\n+  CHECK(0_1,0_1,8)\n+  CHECK(28_1,79_1,0)\n+  CHECK(28_1,79_1,1)\n+  CHECK(28_1,79_1,5)\n+  CHECK(28_1,79_1,7)\n+  CHECK(28_1,79_1,8)\n+  CHECK(-28_1,79_1,0)\n+  CHECK(-28_1,79_1,1)\n+  CHECK(-28_1,79_1,5)\n+  CHECK(-28_1,79_1,7)\n+  CHECK(-28_1,79_1,8)\n+  CHECK(28_1,-79_1,0)\n+  CHECK(28_1,-79_1,1)\n+  CHECK(28_1,-79_1,5)\n+  CHECK(28_1,-79_1,7)\n+  CHECK(28_1,-79_1,8)\n+  CHECK(-28_1,-79_1,0)\n+  CHECK(-28_1,-79_1,1)\n+  CHECK(-28_1,-79_1,5)\n+  CHECK(-28_1,-79_1,7)\n+  CHECK(-28_1,-79_1,8)\n+\n+  CHECK(0_2,0_2,0)\n+  CHECK(0_2,0_2,1)\n+  CHECK(0_2,0_2,7)\n+  CHECK(0_2,0_2,8)\n+  CHECK(28_2,79_2,0)\n+  CHECK(28_2,79_2,1)\n+  CHECK(28_2,79_2,5)\n+  CHECK(28_2,79_2,7)\n+  CHECK(28_2,79_2,8)\n+  CHECK(-28_2,79_2,0)\n+  CHECK(-28_2,79_2,1)\n+  CHECK(-28_2,79_2,5)\n+  CHECK(-28_2,79_2,7)\n+  CHECK(-28_2,79_2,8)\n+  CHECK(28_2,-79_2,0)\n+  CHECK(28_2,-79_2,1)\n+  CHECK(28_2,-79_2,5)\n+  CHECK(28_2,-79_2,7)\n+  CHECK(28_2,-79_2,8)\n+  CHECK(-28_2,-79_2,0)\n+  CHECK(-28_2,-79_2,1)\n+  CHECK(-28_2,-79_2,5)\n+  CHECK(-28_2,-79_2,7)\n+  CHECK(-28_2,-79_2,8)\n+\n+  CHECK(0_4,0_4,0)\n+  CHECK(0_4,0_4,1)\n+  CHECK(0_4,0_4,7)\n+  CHECK(0_4,0_4,8)\n+  CHECK(28_4,79_4,0)\n+  CHECK(28_4,79_4,1)\n+  CHECK(28_4,79_4,5)\n+  CHECK(28_4,79_4,7)\n+  CHECK(28_4,79_4,8)\n+  CHECK(-28_4,79_4,0)\n+  CHECK(-28_4,79_4,1)\n+  CHECK(-28_4,79_4,5)\n+  CHECK(-28_4,79_4,7)\n+  CHECK(-28_4,79_4,8)\n+  CHECK(28_4,-79_4,0)\n+  CHECK(28_4,-79_4,1)\n+  CHECK(28_4,-79_4,5)\n+  CHECK(28_4,-79_4,7)\n+  CHECK(28_4,-79_4,8)\n+  CHECK(-28_4,-79_4,0)\n+  CHECK(-28_4,-79_4,1)\n+  CHECK(-28_4,-79_4,5)\n+  CHECK(-28_4,-79_4,7)\n+  CHECK(-28_4,-79_4,8)\n+\n+  CHECK(0_8,0_8,0)\n+  CHECK(0_8,0_8,1)\n+  CHECK(0_8,0_8,7)\n+  CHECK(0_8,0_8,8)\n+  CHECK(28_8,79_8,0)\n+  CHECK(28_8,79_8,1)\n+  CHECK(28_8,79_8,5)\n+  CHECK(28_8,79_8,7)\n+  CHECK(28_8,79_8,8)\n+  CHECK(-28_8,79_8,0)\n+  CHECK(-28_8,79_8,1)\n+  CHECK(-28_8,79_8,5)\n+  CHECK(-28_8,79_8,7)\n+  CHECK(-28_8,79_8,8)\n+  CHECK(28_8,-79_8,0)\n+  CHECK(28_8,-79_8,1)\n+  CHECK(28_8,-79_8,5)\n+  CHECK(28_8,-79_8,7)\n+  CHECK(28_8,-79_8,8)\n+  CHECK(-28_8,-79_8,0)\n+  CHECK(-28_8,-79_8,1)\n+  CHECK(-28_8,-79_8,5)\n+  CHECK(-28_8,-79_8,7)\n+  CHECK(-28_8,-79_8,8)\n+\n+\n+contains\n+\n+  function dshiftl_1 (i, j, shift) result(res)\n+    integer(kind=1) :: i, j, res\n+    integer :: shift\n+    res = dshiftl(i,j,shift)\n+  end function\n+  function dshiftl_2 (i, j, shift) result(res)\n+    integer(kind=2) :: i, j, res\n+    integer :: shift\n+    res = dshiftl(i,j,shift)\n+  end function\n+  function dshiftl_4 (i, j, shift) result(res)\n+    integer(kind=4) :: i, j, res\n+    integer :: shift\n+    res = dshiftl(i,j,shift)\n+  end function\n+  function dshiftl_8 (i, j, shift) result(res)\n+    integer(kind=8) :: i, j, res\n+    integer :: shift\n+    res = dshiftl(i,j,shift)\n+  end function\n+\n+  function dshiftr_1 (i, j, shift) result(res)\n+    integer(kind=1) :: i, j, res\n+    integer :: shift\n+    res = dshiftr(i,j,shift)\n+  end function\n+  function dshiftr_2 (i, j, shift) result(res)\n+    integer(kind=2) :: i, j, res\n+    integer :: shift\n+    res = dshiftr(i,j,shift)\n+  end function\n+  function dshiftr_4 (i, j, shift) result(res)\n+    integer(kind=4) :: i, j, res\n+    integer :: shift\n+    res = dshiftr(i,j,shift)\n+  end function\n+  function dshiftr_8 (i, j, shift) result(res)\n+    integer(kind=8) :: i, j, res\n+    integer :: shift\n+    res = dshiftr(i,j,shift)\n+  end function\n+\n+end"}, {"sha": "f0cfff68069e563c1024758d3d4a1541d99ec521", "filename": "gcc/testsuite/gfortran.dg/dshift_2.F90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdshift_2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdshift_2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdshift_2.F90?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -0,0 +1,59 @@\n+! Test the DSHIFTL and DSHIFTR intrinsics.\n+!\n+! { dg-do run }\n+! { dg-options \"-ffree-line-length-none\" }\n+! { dg-require-effective-target fortran_integer_16 }\n+\n+  implicit none\n+\n+#define RESL(I,J,SHIFT) \\\n+  IOR(SHIFTL(I,SHIFT),SHIFTR(J,BIT_SIZE(J)-SHIFT))\n+#define RESR(I,J,SHIFT) \\\n+  IOR(SHIFTL(I,BIT_SIZE(I)-SHIFT),SHIFTR(J,SHIFT))\n+\n+#define CHECK(I,J,SHIFT) \\\n+  if (dshiftl(I,J,SHIFT) /= RESL(I,J,SHIFT)) call abort ; \\\n+  if (dshiftr(I,J,SHIFT) /= RESR(I,J,SHIFT)) call abort ; \\\n+  if (run_dshiftl(I,J,SHIFT) /= RESL(I,J,SHIFT)) call abort ; \\\n+  if (run_dshiftr(I,J,SHIFT) /= RESR(I,J,SHIFT)) call abort\n+\n+  CHECK(0_16,0_16,0)\n+  CHECK(0_16,0_16,1)\n+  CHECK(0_16,0_16,7)\n+  CHECK(0_16,0_16,8)\n+  CHECK(28_16,79_16,0)\n+  CHECK(28_16,79_16,1)\n+  CHECK(28_16,79_16,5)\n+  CHECK(28_16,79_16,7)\n+  CHECK(28_16,79_16,8)\n+  CHECK(-28_16,79_16,0)\n+  CHECK(-28_16,79_16,1)\n+  CHECK(-28_16,79_16,5)\n+  CHECK(-28_16,79_16,7)\n+  CHECK(-28_16,79_16,8)\n+  CHECK(28_16,-79_16,0)\n+  CHECK(28_16,-79_16,1)\n+  CHECK(28_16,-79_16,5)\n+  CHECK(28_16,-79_16,7)\n+  CHECK(28_16,-79_16,8)\n+  CHECK(-28_16,-79_16,0)\n+  CHECK(-28_16,-79_16,1)\n+  CHECK(-28_16,-79_16,5)\n+  CHECK(-28_16,-79_16,7)\n+  CHECK(-28_16,-79_16,8)\n+\n+contains\n+\n+  function run_dshiftl (i, j, shift) result(res)\n+    integer(kind=16) :: i, j, res\n+    integer :: shift\n+    res = dshiftl(i,j,shift)\n+  end function\n+\n+  function run_dshiftr (i, j, shift) result(res)\n+    integer(kind=16) :: i, j, res\n+    integer :: shift\n+    res = dshiftr(i,j,shift)\n+  end function\n+\n+end"}, {"sha": "b54a11f63da5d51585a280d533e471d100042c43", "filename": "gcc/testsuite/gfortran.dg/leadz_trailz_3.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fleadz_trailz_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fleadz_trailz_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fleadz_trailz_3.f90?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -0,0 +1,30 @@\n+! We want to check that ISHFT evaluates its arguments only once\n+!\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+\n+program test\n+\n+  if (leadz (foo()) /= bit_size(0) - 1) call abort\n+  if (leadz (foo()) /= bit_size(0) - 2) call abort\n+  if (trailz (foo()) /= 0) call abort\n+  if (trailz (foo()) /= 2) call abort\n+  if (trailz (foo()) /= 0) call abort\n+  if (trailz (foo()) /= 1) call abort\n+\n+contains\n+  \n+  integer function foo ()\n+    integer, save :: i = 0\n+    i = i + 1\n+    foo = i\n+  end function\n+\n+end program\n+\n+! The regexp \"foo ()\" should be seen once in the dump:\n+!   -- once in the function definition itself\n+!   -- plus as many times as the function is called\n+!\n+! { dg-final { scan-tree-dump-times \"foo *\\\\\\(\\\\\\)\" 7 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "82472c571b402234c938af52f67305fc73707e76", "filename": "gcc/testsuite/gfortran.dg/masklr_1.F90", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmasklr_1.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmasklr_1.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmasklr_1.F90?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -0,0 +1,82 @@\n+! Test the MASKL and MASKR intrinsics.\n+!\n+! { dg-do run }\n+! { dg-options \"-ffree-line-length-none\" }\n+\n+#define CHECK(I,KIND,FUNCL,FUNCR,RESL,RESR) \\\n+  if (maskl(I,KIND) /= RESL) call abort ; \\\n+  if (FUNCL(I) /= RESL) call abort ; \\\n+  if (maskr(I,KIND) /= RESR) call abort ; \\\n+  if (FUNCR(I) /= RESR) call abort\n+\n+  CHECK(0,1,run_maskl1,run_maskr1,0_1,0_1)\n+  CHECK(1,1,run_maskl1,run_maskr1,-huge(0_1)-1_1,1_1)\n+  CHECK(2,1,run_maskl1,run_maskr1,(-huge(0_1)-1_1)/2_1,3_1)\n+  CHECK(3,1,run_maskl1,run_maskr1,(-huge(0_1)-1_1)/4_1,7_1)\n+  CHECK(int(bit_size(0_1))-2,1,run_maskl1,run_maskr1,-4_1,huge(0_1)/2_1)\n+  CHECK(int(bit_size(0_1))-1,1,run_maskl1,run_maskr1,-2_1,huge(0_1))\n+  CHECK(int(bit_size(0_1)),1,run_maskl1,run_maskr1,-1_1,-1_1)\n+\n+  CHECK(0,2,run_maskl2,run_maskr2,0_2,0_2)\n+  CHECK(1,2,run_maskl2,run_maskr2,-huge(0_2)-1_2,1_2)\n+  CHECK(2,2,run_maskl2,run_maskr2,(-huge(0_2)-1_2)/2_2,3_2)\n+  CHECK(3,2,run_maskl2,run_maskr2,(-huge(0_2)-1_2)/4_2,7_2)\n+  CHECK(int(bit_size(0_2))-2,2,run_maskl2,run_maskr2,-4_2,huge(0_2)/2_2)\n+  CHECK(int(bit_size(0_2))-1,2,run_maskl2,run_maskr2,-2_2,huge(0_2))\n+  CHECK(int(bit_size(0_2)),2,run_maskl2,run_maskr2,-1_2,-1_2)\n+\n+  CHECK(0,4,run_maskl4,run_maskr4,0_4,0_4)\n+  CHECK(1,4,run_maskl4,run_maskr4,-huge(0_4)-1_4,1_4)\n+  CHECK(2,4,run_maskl4,run_maskr4,(-huge(0_4)-1_4)/2_4,3_4)\n+  CHECK(3,4,run_maskl4,run_maskr4,(-huge(0_4)-1_4)/4_4,7_4)\n+  CHECK(int(bit_size(0_4))-2,4,run_maskl4,run_maskr4,-4_4,huge(0_4)/2_4)\n+  CHECK(int(bit_size(0_4))-1,4,run_maskl4,run_maskr4,-2_4,huge(0_4))\n+  CHECK(int(bit_size(0_4)),4,run_maskl4,run_maskr4,-1_4,-1_4)\n+\n+  CHECK(0,8,run_maskl8,run_maskr8,0_8,0_8)\n+  CHECK(1,8,run_maskl8,run_maskr8,-huge(0_8)-1_8,1_8)\n+  CHECK(2,8,run_maskl8,run_maskr8,(-huge(0_8)-1_8)/2_8,3_8)\n+  CHECK(3,8,run_maskl8,run_maskr8,(-huge(0_8)-1_8)/4_8,7_8)\n+  CHECK(int(bit_size(0_8))-2,8,run_maskl8,run_maskr8,-4_8,huge(0_8)/2_8)\n+  CHECK(int(bit_size(0_8))-1,8,run_maskl8,run_maskr8,-2_8,huge(0_8))\n+  CHECK(int(bit_size(0_8)),8,run_maskl8,run_maskr8,-1_8,-1_8)\n+\n+contains\n+\n+  pure integer(kind=1) function run_maskl1(i) result(res)\n+    integer, intent(in) :: i\n+    res = maskl(i,kind=1)\n+  end function\n+  pure integer(kind=1) function run_maskr1(i) result(res)\n+    integer, intent(in) :: i\n+    res = maskr(i,kind=1)\n+  end function\n+\n+  pure integer(kind=2) function run_maskl2(i) result(res)\n+    integer, intent(in) :: i\n+    res = maskl(i,kind=2)\n+  end function\n+  pure integer(kind=2) function run_maskr2(i) result(res)\n+    integer, intent(in) :: i\n+    res = maskr(i,kind=2)\n+  end function\n+\n+  pure integer(kind=4) function run_maskl4(i) result(res)\n+    integer, intent(in) :: i\n+    res = maskl(i,kind=4)\n+  end function\n+  pure integer(kind=4) function run_maskr4(i) result(res)\n+    integer, intent(in) :: i\n+    res = maskr(i,kind=4)\n+  end function\n+\n+  pure integer(kind=8) function run_maskl8(i) result(res)\n+    integer, intent(in) :: i\n+    res = maskl(i,kind=8)\n+  end function\n+  pure integer(kind=8) function run_maskr8(i) result(res)\n+    integer, intent(in) :: i\n+    res = maskr(i,kind=8)\n+  end function\n+\n+end"}, {"sha": "a7545a1881c92960dca85ca964111c5e3737ed16", "filename": "gcc/testsuite/gfortran.dg/masklr_2.F90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmasklr_2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmasklr_2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmasklr_2.F90?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -0,0 +1,32 @@\n+! Test the MASKL and MASKR intrinsics.\n+!\n+! { dg-do run }\n+! { dg-options \"-ffree-line-length-none\" }\n+! { dg-require-effective-target fortran_integer_16 }\n+\n+#define CHECK(I,KIND,FUNCL,FUNCR,RESL,RESR) \\\n+  if (maskl(I,KIND) /= RESL) call abort ; \\\n+  if (FUNCL(I) /= RESL) call abort ; \\\n+  if (maskr(I,KIND) /= RESR) call abort ; \\\n+  if (FUNCR(I) /= RESR) call abort\n+\n+  CHECK(0,16,run_maskl16,run_maskr16,0_16,0_16)\n+  CHECK(1,16,run_maskl16,run_maskr16,-huge(0_16)-1_16,1_16)\n+  CHECK(2,16,run_maskl16,run_maskr16,(-huge(0_16)-1_16)/2_16,3_16)\n+  CHECK(3,16,run_maskl16,run_maskr16,(-huge(0_16)-1_16)/4_16,7_16)\n+  CHECK(int(bit_size(0_16))-2,16,run_maskl16,run_maskr16,-4_16,huge(0_16)/2_16)\n+  CHECK(int(bit_size(0_16))-1,16,run_maskl16,run_maskr16,-2_16,huge(0_16))\n+  CHECK(int(bit_size(0_16)),16,run_maskl16,run_maskr16,-1_16,-1_16)\n+\n+contains\n+\n+  pure integer(kind=16) function run_maskl16(i) result(res)\n+    integer, intent(in) :: i\n+    res = maskl(i,kind=16)\n+  end function\n+  pure integer(kind=16) function run_maskr16(i) result(res)\n+    integer, intent(in) :: i\n+    res = maskr(i,kind=16)\n+  end function\n+\n+end"}, {"sha": "e8f5e2af4d766c97ef37cb7f1e91bc961f6485e8", "filename": "gcc/testsuite/gfortran.dg/merge_bits_1.F90", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_1.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_1.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_1.F90?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -0,0 +1,55 @@\n+! Test the MERGE_BITS intrinsic\n+!\n+! { dg-do run }\n+! { dg-options \"-ffree-line-length-none\" }\n+\n+  interface run_merge\n+    procedure run_merge_1\n+    procedure run_merge_2\n+    procedure run_merge_4\n+    procedure run_merge_8\n+  end interface\n+\n+#define CHECK(I,J,K) \\\n+  if (merge_bits(I,J,K) /= ior(iand(I,K),iand(J,not(K)))) call abort ; \\\n+  if (run_merge(I,J,K) /= merge_bits(I,J,K)) call abort\n+\n+  CHECK(13_1,18_1,22_1)\n+  CHECK(-13_1,18_1,22_1)\n+  CHECK(13_1,-18_1,22_1)\n+  CHECK(13_1,18_1,-22_1)\n+\n+  CHECK(13_2,18_2,22_2)\n+  CHECK(-13_2,18_2,22_2)\n+  CHECK(13_2,-18_2,22_2)\n+  CHECK(13_2,18_2,-22_2)\n+\n+  CHECK(13_4,18_4,22_4)\n+  CHECK(-13_4,18_4,22_4)\n+  CHECK(13_4,-18_4,22_4)\n+  CHECK(13_4,18_4,-22_4)\n+\n+  CHECK(13_8,18_8,22_8)\n+  CHECK(-13_8,18_8,22_8)\n+  CHECK(13_8,-18_8,22_8)\n+  CHECK(13_8,18_8,-22_8)\n+\n+contains\n+\n+  function run_merge_1 (i, j, k) result(res)\n+    integer(kind=1) :: i, j, k, res\n+    res = merge_bits(i,j,k)\n+  end function \n+  function run_merge_2 (i, j, k) result(res)\n+    integer(kind=2) :: i, j, k, res\n+    res = merge_bits(i,j,k)\n+  end function \n+  function run_merge_4 (i, j, k) result(res)\n+    integer(kind=4) :: i, j, k, res\n+    res = merge_bits(i,j,k)\n+  end function \n+  function run_merge_8 (i, j, k) result(res)\n+    integer(kind=8) :: i, j, k, res\n+    res = merge_bits(i,j,k)\n+  end function \n+end"}, {"sha": "4f2421e02aebbbb6eb9891187e2e68099f1e6697", "filename": "gcc/testsuite/gfortran.dg/merge_bits_2.F90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_2.F90?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -0,0 +1,22 @@\n+! Test the MERGE_BITS intrinsic\n+!\n+! { dg-do run }\n+! { dg-options \"-ffree-line-length-none\" }\n+! { dg-require-effective-target fortran_integer_16 }\n+\n+#define CHECK(I,J,K) \\\n+  if (merge_bits(I,J,K) /= ior(iand(I,K),iand(J,not(K)))) call abort ; \\\n+  if (run_merge(I,J,K) /= merge_bits(I,J,K)) call abort\n+\n+  CHECK(13_16,18_16,22_16)\n+  CHECK(-13_16,18_16,22_16)\n+  CHECK(13_16,-18_16,22_16)\n+  CHECK(13_16,18_16,-22_16)\n+\n+contains\n+\n+  function run_merge (i, j, k) result(res)\n+    integer(kind=16) :: i, j, k, res\n+    res = merge_bits(i,j,k)\n+  end function \n+end"}, {"sha": "9f2707bd96dab3cb3f1a6d4e59f4170d8d47fbca", "filename": "gcc/testsuite/gfortran.dg/shiftalr_1.F90", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fshiftalr_1.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fshiftalr_1.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fshiftalr_1.F90?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -0,0 +1,162 @@\n+! Test the SHIFTA, SHIFTL and SHIFTR intrinsics.\n+!\n+! { dg-do run }\n+! { dg-options \"-ffree-line-length-none\" }\n+\n+  interface run_shifta\n+    procedure shifta_1\n+    procedure shifta_2\n+    procedure shifta_4\n+    procedure shifta_8\n+  end interface\n+  interface run_shiftl\n+    procedure shiftl_1\n+    procedure shiftl_2\n+    procedure shiftl_4\n+    procedure shiftl_8\n+  end interface\n+  interface run_shiftr\n+    procedure shiftr_1\n+    procedure shiftr_2\n+    procedure shiftr_4\n+    procedure shiftr_8\n+  end interface\n+  interface run_ishft\n+    procedure ishft_1\n+    procedure ishft_2\n+    procedure ishft_4\n+    procedure ishft_8\n+  end interface\n+\n+#define CHECK(I,SHIFT,RESA,RESL,RESR) \\\n+  if (shifta(I,SHIFT) /= RESA) call abort ; \\\n+  if (shiftr(I,SHIFT) /= RESR) call abort ; \\\n+  if (shiftl(I,SHIFT) /= RESL) call abort ; \\\n+  if (run_shifta(I,SHIFT) /= RESA) call abort ; \\\n+  if (run_shiftr(I,SHIFT) /= RESR) call abort ; \\\n+  if (run_shiftl(I,SHIFT) /= RESL) call abort ; \\\n+  if (ishft(I,SHIFT) /= RESL) call abort ; \\\n+  if (ishft(I,-SHIFT) /= RESR) call abort ; \\\n+  if (run_ishft(I,SHIFT) /= RESL) call abort ; \\\n+  if (run_ishft(I,-SHIFT) /= RESR) call abort\n+\n+  CHECK(0_1,0,0_1,0_1,0_1)\n+  CHECK(11_1,0,11_1,11_1,11_1)\n+  CHECK(-11_1,0,-11_1,-11_1,-11_1)\n+  CHECK(0_1,1,0_1,0_1,0_1)\n+  CHECK(11_1,1,5_1,22_1,5_1)\n+  CHECK(11_1,2,2_1,44_1,2_1)\n+  CHECK(-11_1,1,-6_1,-22_1,huge(0_1)-5_1)\n+\n+  CHECK(0_2,0,0_2,0_2,0_2)\n+  CHECK(11_2,0,11_2,11_2,11_2)\n+  CHECK(-11_2,0,-11_2,-11_2,-11_2)\n+  CHECK(0_2,1,0_2,0_2,0_2)\n+  CHECK(11_2,1,5_2,22_2,5_2)\n+  CHECK(11_2,2,2_2,44_2,2_2)\n+  CHECK(-11_2,1,-6_2,-22_2,huge(0_2)-5_2)\n+\n+  CHECK(0_4,0,0_4,0_4,0_4)\n+  CHECK(11_4,0,11_4,11_4,11_4)\n+  CHECK(-11_4,0,-11_4,-11_4,-11_4)\n+  CHECK(0_4,1,0_4,0_4,0_4)\n+  CHECK(11_4,1,5_4,22_4,5_4)\n+  CHECK(11_4,2,2_4,44_4,2_4)\n+  CHECK(-11_4,1,-6_4,-22_4,huge(0_4)-5_4)\n+\n+  CHECK(0_8,0,0_8,0_8,0_8)\n+  CHECK(11_8,0,11_8,11_8,11_8)\n+  CHECK(-11_8,0,-11_8,-11_8,-11_8)\n+  CHECK(0_8,1,0_8,0_8,0_8)\n+  CHECK(11_8,1,5_8,22_8,5_8)\n+  CHECK(11_8,2,2_8,44_8,2_8)\n+  CHECK(-11_8,1,-6_8,-22_8,huge(0_8)-5_8)\n+\n+contains\n+\n+  function shifta_1 (i, shift) result(res)\n+    integer(kind=1) :: i, res\n+    integer :: shift\n+    res = shifta(i,shift)\n+  end function\n+  function shiftl_1 (i, shift) result(res)\n+    integer(kind=1) :: i, res\n+    integer :: shift\n+    res = shiftl(i,shift)\n+  end function\n+  function shiftr_1 (i, shift) result(res)\n+    integer(kind=1) :: i, res\n+    integer :: shift\n+    res = shiftr(i,shift)\n+  end function\n+\n+  function shifta_2 (i, shift) result(res)\n+    integer(kind=2) :: i, res\n+    integer :: shift\n+    res = shifta(i,shift)\n+  end function\n+  function shiftl_2 (i, shift) result(res)\n+    integer(kind=2) :: i, res\n+    integer :: shift\n+    res = shiftl(i,shift)\n+  end function\n+  function shiftr_2 (i, shift) result(res)\n+    integer(kind=2) :: i, res\n+    integer :: shift\n+    res = shiftr(i,shift)\n+  end function\n+\n+  function shifta_4 (i, shift) result(res)\n+    integer(kind=4) :: i, res\n+    integer :: shift\n+    res = shifta(i,shift)\n+  end function\n+  function shiftl_4 (i, shift) result(res)\n+    integer(kind=4) :: i, res\n+    integer :: shift\n+    res = shiftl(i,shift)\n+  end function\n+  function shiftr_4 (i, shift) result(res)\n+    integer(kind=4) :: i, res\n+    integer :: shift\n+    res = shiftr(i,shift)\n+  end function\n+\n+  function shifta_8 (i, shift) result(res)\n+    integer(kind=8) :: i, res\n+    integer :: shift\n+    res = shifta(i,shift)\n+  end function\n+  function shiftl_8 (i, shift) result(res)\n+    integer(kind=8) :: i, res\n+    integer :: shift\n+    res = shiftl(i,shift)\n+  end function\n+  function shiftr_8 (i, shift) result(res)\n+    integer(kind=8) :: i, res\n+    integer :: shift\n+    res = shiftr(i,shift)\n+  end function\n+\n+  function ishft_1 (i, shift) result(res)\n+    integer(kind=1) :: i, res\n+    integer :: shift\n+    res = ishft(i,shift)\n+  end function\n+  function ishft_2 (i, shift) result(res)\n+    integer(kind=2) :: i, res\n+    integer :: shift\n+    res = ishft(i,shift)\n+  end function\n+  function ishft_4 (i, shift) result(res)\n+    integer(kind=4) :: i, res\n+    integer :: shift\n+    res = ishft(i,shift)\n+  end function\n+  function ishft_8 (i, shift) result(res)\n+    integer(kind=8) :: i, res\n+    integer :: shift\n+    res = ishft(i,shift)\n+  end function\n+\n+end"}, {"sha": "0a34af5ec652adc9102351bf51ae920109b29372", "filename": "gcc/testsuite/gfortran.dg/shiftalr_2.F90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fshiftalr_2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a95a119b5cd953ecf8dedebe2008c4514cbc0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fshiftalr_2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fshiftalr_2.F90?ref=88a95a119b5cd953ecf8dedebe2008c4514cbc0c", "patch": "@@ -0,0 +1,52 @@\n+! Test the SHIFTA, SHIFTL and SHIFTR intrinsics.\n+!\n+! { dg-do run }\n+! { dg-options \"-ffree-line-length-none\" }\n+! { dg-require-effective-target fortran_integer_16 }\n+\n+  implicit none\n+\n+#define CHECK(I,SHIFT,RESA,RESL,RESR) \\\n+  if (shifta(I,SHIFT) /= RESA) call abort ; \\\n+  if (shiftr(I,SHIFT) /= RESR) call abort ; \\\n+  if (shiftl(I,SHIFT) /= RESL) call abort ; \\\n+  if (run_shifta(I,SHIFT) /= RESA) call abort ; \\\n+  if (run_shiftr(I,SHIFT) /= RESR) call abort ; \\\n+  if (run_shiftl(I,SHIFT) /= RESL) call abort ; \\\n+  if (ishft(I,SHIFT) /= RESL) call abort ; \\\n+  if (ishft(I,-SHIFT) /= RESR) call abort ; \\\n+  if (run_ishft(I,SHIFT) /= RESL) call abort ; \\\n+  if (run_ishft(I,-SHIFT) /= RESR) call abort\n+\n+  CHECK(0_16,0,0_16,0_16,0_16)\n+  CHECK(11_16,0,11_16,11_16,11_16)\n+  CHECK(-11_16,0,-11_16,-11_16,-11_16)\n+  CHECK(0_16,1,0_16,0_16,0_16)\n+  CHECK(11_16,1,5_16,22_16,5_16)\n+  CHECK(11_16,2,2_16,44_16,2_16)\n+  CHECK(-11_16,1,-6_16,-22_16,huge(0_16)-5_16)\n+\n+contains\n+\n+  function run_shifta (i, shift) result(res)\n+    integer(kind=16) :: i, res\n+    integer :: shift\n+    res = shifta(i,shift)\n+  end function\n+  function run_shiftl (i, shift) result(res)\n+    integer(kind=16) :: i, res\n+    integer :: shift\n+    res = shiftl(i,shift)\n+  end function\n+  function run_shiftr (i, shift) result(res)\n+    integer(kind=16) :: i, res\n+    integer :: shift\n+    res = shiftr(i,shift)\n+  end function\n+  function run_ishft (i, shift) result(res)\n+    integer(kind=16) :: i, res\n+    integer :: shift\n+    res = ishft(i,shift)\n+  end function\n+\n+end"}]}