{"sha": "e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNhOGE0ZWRhOWIxYjJlYjZhNDdmOTE1NjgzMGY2ZmJjNzBlYTc5NA==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2005-02-12T11:47:19Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-02-12T11:47:19Z"}, "message": "tree-data-ref.c (array_base_name_differ_p): Check that the bases exist and are objects.\n\n        * tree-data-ref.c (array_base_name_differ_p): Check that the bases\n        exist and are objects. Remove checks for pointer.\n        * tree-vectorizer.c (vect_create_addr_base_for_vector_ref): Use\n        STMT_VINFO_VECT_DR_BASE_ADDRESS instead of DR_BASE_NAME.\n        (vect_create_data_ref_ptr): Likewise.\n        (vect_base_addr_differ_p): New function.\n        (vect_analyze_data_ref_dependence): Call vect_base_addr_differ_p.\n        (vect_analyze_pointer_ref_access): Add output parameter - ptr_init.\n        Don't set the DR_BASE_NAME field of data-ref.\n        (vect_get_memtag_and_dr): Use ptr_init instead of DR_BASE_NAME.\n\nFrom-SVN: r94932", "tree": {"sha": "3e01db65e62fe15304ec53e6e8999fbfbd328c54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e01db65e62fe15304ec53e6e8999fbfbd328c54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c94a75af08ce77997d7566d5fcca097ca177a97f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94a75af08ce77997d7566d5fcca097ca177a97f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c94a75af08ce77997d7566d5fcca097ca177a97f"}], "stats": {"total": 174, "additions": 141, "deletions": 33}, "files": [{"sha": "ceebb3a45a1e25d3d7425b2dbcb3c4e3046b1bf9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794", "patch": "@@ -1,3 +1,16 @@\n+2005-02-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-data-ref.c (array_base_name_differ_p): Check that the bases\n+\texist and are objects. Remove checks for pointer.\n+\t* tree-vectorizer.c (vect_create_addr_base_for_vector_ref): Use\n+\tSTMT_VINFO_VECT_DR_BASE_ADDRESS instead of DR_BASE_NAME.\n+\t(vect_create_data_ref_ptr): Likewise.\n+\t(vect_base_addr_differ_p): New function.\n+\t(vect_analyze_data_ref_dependence): Call vect_base_addr_differ_p.\n+\t(vect_analyze_pointer_ref_access): Add output parameter - ptr_init.\n+\tDon't set the DR_BASE_NAME field of data-ref.\n+\t(vect_get_memtag_and_dr): Use ptr_init instead of DR_BASE_NAME.\n+\n 2005-02-12  Uros Bizjak  <uros@kss-loka.si>\n \n \t* optabs.h (enum optab_index): Add new OTI_ldexp.\n@@ -14,7 +27,7 @@\n \tto implement ldexpf, ldexp and ldexpl built-ins as inline x87\n \tintrinsics.\n \n-2005-02-13  Ira Rosen  <irar@il.ibm.com>\n+2005-02-12  Ira Rosen  <irar@il.ibm.com>\n \n \t* tree-vectorizer.h (struct _stmt_vec_info): Rename a field: base\n \tto base_address."}, {"sha": "7f518d0c110198b5737394525d50fab58eb94041", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794", "patch": "@@ -1,3 +1,7 @@\n+2005-02-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-96.c: New test.\n+\n 2005-02-12  Uros Bizjak  <uros@kss-loka.si>\n \n \t* gcc.dg/builtins-34.c: Also check ldexp*."}, {"sha": "c2960601f1067d652b41769166cc17c334fad063", "filename": "gcc/testsuite/gcc.dg/vect/vect-96.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c?ref=e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+struct tmp\n+{\n+     int x;\n+     int ia[N];\n+};\n+\n+int main1 (int off)\n+{\n+  struct tmp sb[N];\n+  struct tmp *pp = &sb[off];\n+  int i, ib[N];\n+\n+  for (i = 0; i < N; i++)\n+      pp->ia[i] = ib[i];\n+\n+  /* check results: */  \n+  for (i = 0; i < N; i++)\n+    {\n+       if (pp->ia[i] = ib[i])\n+         abort();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+\n+  return main1 (8);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */"}, {"sha": "55b34fbb73fb51c25e027074d596e608d4c83a1e", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794", "patch": "@@ -109,9 +109,15 @@ array_base_name_differ_p (struct data_reference *a,\n {\n   tree base_a = DR_BASE_NAME (a);\n   tree base_b = DR_BASE_NAME (b);\n-  tree ta = TREE_TYPE (base_a);\n-  tree tb = TREE_TYPE (base_b);\n+  tree ta, tb;\n \n+  if (!base_a || !base_b)\n+    return false;\n+\n+  ta = TREE_TYPE (base_a);\n+  tb = TREE_TYPE (base_b);\n+  \n+  gcc_assert (!POINTER_TYPE_P (ta) && !POINTER_TYPE_P (tb));\n \n   /* Determine if same base.  Example: for the array accesses\n      a[i], b[i] or pointer accesses *a, *b, bases are a, b.  */\n@@ -179,24 +185,6 @@ array_base_name_differ_p (struct data_reference *a,\n       return true;\n     }\n \n-  if (!alias_sets_conflict_p (get_alias_set (base_a), get_alias_set (base_b)))\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-\n-  /* An instruction writing through a restricted pointer is\n-     \"independent\" of any instruction reading or writing through a\n-     different pointer, in the same block/scope.  */\n-  if ((TREE_CODE (ta) == POINTER_TYPE && TYPE_RESTRICT (ta)\n-       && !DR_IS_READ(a))\n-      || (TREE_CODE (tb) == POINTER_TYPE && TYPE_RESTRICT (tb)\n-\t  && !DR_IS_READ(b)))\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-\n   return false;\n }\n "}, {"sha": "72fec3fdc8676d09b5d08807b59b0f9b4df0c734", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 73, "deletions": 12, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=e3a8a4eda9b1b2eb6a47f9156830f6fbc70ea794", "patch": "@@ -223,19 +223,20 @@ static bool vect_compute_data_ref_alignment (struct data_reference *);\n static bool vect_analyze_data_ref_access (struct data_reference *);\n static bool vect_can_force_dr_alignment_p (tree, unsigned int);\n static struct data_reference * vect_analyze_pointer_ref_access \n-  (tree, tree, bool);\n+  (tree, tree, bool, tree*);\n static bool vect_can_advance_ivs_p (loop_vec_info);\n static tree vect_get_base_and_offset (struct data_reference *, tree, tree, \n \t\t\t\t      loop_vec_info, tree *, tree *, tree *,\n \t\t\t\t      bool*);\n-static struct data_reference * vect_analyze_pointer_ref_access\n-  (tree, tree, bool);\n static tree vect_get_ptr_offset (tree, tree, tree *);\n static tree vect_get_memtag_and_dr\n   (tree, tree, bool, loop_vec_info, tree, struct data_reference **);\n static bool vect_analyze_offset_expr (tree, struct loop *, tree, tree *, \n \t\t\t\t      tree *, tree *);\n static tree vect_strip_conversion (tree);\n+static bool vect_base_addr_differ_p (struct data_reference *,\n+\t\t\t\t     struct data_reference *drb, bool *);\n+\n \n /* Utility functions for the code transformation.  */\n static tree vect_create_destination_var (tree, tree);\n@@ -1962,7 +1963,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree data_ref_base = \n     unshare_expr (STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info));\n-  tree base_name = unshare_expr (DR_BASE_NAME (dr));\n+  tree base_name = build_fold_indirect_ref (data_ref_base);\n   tree ref = DR_REF (dr);\n   tree scalar_type = TREE_TYPE (ref);\n   tree scalar_ptr_type = build_pointer_type (scalar_type);\n@@ -2132,7 +2133,6 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n {\n   tree base_name;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -2156,7 +2156,9 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   tree data_ref_ptr;\n   tree type, tmp, size;\n \n-  base_name = unshare_expr (DR_BASE_NAME (dr));\n+  base_name =  build_fold_indirect_ref (unshare_expr (\n+\t\t      STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info)));\n+\n   if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n       tree data_ref_base = base_name;\n@@ -4089,6 +4091,61 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n }\n \n \n+/* Function vect_base_addr_differ_p.\n+\n+   This is the simplest data dependence test: determines whether the\n+   data references A and B access the same array/region.  Returns\n+   false when the property is not computable at compile time.\n+   Otherwise return true, and DIFFER_P will record the result. This\n+   utility will not be necessary when alias_sets_conflict_p will be\n+   less conservative.  */\n+\n+\n+static bool\n+vect_base_addr_differ_p (struct data_reference *dra,\n+\t\t\t struct data_reference *drb,\n+\t\t\t bool *differ_p)\n+{\n+  tree stmt_a = DR_STMT (dra);\n+  stmt_vec_info stmt_info_a = vinfo_for_stmt (stmt_a);   \n+  tree stmt_b = DR_STMT (drb);\n+  stmt_vec_info stmt_info_b = vinfo_for_stmt (stmt_b);   \n+  tree addr_a = STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info_a);\n+  tree addr_b = STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info_b);\n+  tree type_a = TREE_TYPE (addr_a);\n+  tree type_b = TREE_TYPE (addr_b);\n+  HOST_WIDE_INT alias_set_a, alias_set_b;\n+\n+  gcc_assert (POINTER_TYPE_P (type_a) &&  POINTER_TYPE_P (type_b));\n+  \n+  /* Both references are ADDR_EXPR, i.e., we have the objects.  */\n+  if (TREE_CODE (addr_a) == ADDR_EXPR && TREE_CODE (addr_b) == ADDR_EXPR)\n+    return array_base_name_differ_p (dra, drb, differ_p);  \n+\n+  alias_set_a = (TREE_CODE (addr_a) == ADDR_EXPR) ? \n+    get_alias_set (TREE_OPERAND (addr_a, 0)) : get_alias_set (addr_a);\n+  alias_set_b = (TREE_CODE (addr_b) == ADDR_EXPR) ? \n+    get_alias_set (TREE_OPERAND (addr_b, 0)) : get_alias_set (addr_b);\n+\n+  if (!alias_sets_conflict_p (alias_set_a, alias_set_b))\n+    {\n+      *differ_p = true;\n+      return true;\n+    }\n+  \n+  /* An instruction writing through a restricted pointer is \"independent\" of any \n+     instruction reading or writing through a different pointer, in the same \n+     block/scope.  */\n+  else if ((TYPE_RESTRICT (type_a) && !DR_IS_READ (dra))\n+      || (TYPE_RESTRICT (type_b) && !DR_IS_READ (drb)))\n+    {\n+      *differ_p = true;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+\n /* Function vect_analyze_data_ref_dependence.\n \n    Return TRUE if there (might) exist a dependence between a memory-reference\n@@ -4102,7 +4159,7 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n   bool differ_p; \n   struct data_dependence_relation *ddr;\n   \n-  if (!array_base_name_differ_p (dra, drb, &differ_p))\n+  if (!vect_base_addr_differ_p (dra, drb, &differ_p))\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n \t\t\t\tLOOP_LOC (loop_vinfo)))\n@@ -4660,7 +4717,8 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n    that represents it (DR). Otherwise - return NULL.  */\n \n static struct data_reference *\n-vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n+vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read, \n+\t\t\t\t tree *ptr_init)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -4758,7 +4816,8 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n       fprintf (vect_dump, \"Access function of ptr indx: \");\n       print_generic_expr (vect_dump, indx_access_fn, TDF_SLIM);\n     }\n-  dr = init_data_ref (stmt, memref, init, indx_access_fn, is_read);\n+  dr = init_data_ref (stmt, memref, NULL_TREE, indx_access_fn, is_read);\n+  *ptr_init = init;\n   return dr;\n }\n \n@@ -4806,6 +4865,7 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n   tree ref_to_be_analyzed, tag, dr_base;\n   struct data_reference *new_dr;\n   bool base_aligned_p;\n+  tree ptr_init;\n \n   if (*dr)\n     {\n@@ -4889,12 +4949,13 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n       switch (TREE_CODE (memref))\n \t{      \n \tcase INDIRECT_REF:\n-\t  new_dr = vect_analyze_pointer_ref_access (memref, stmt, is_read);\n+\t  new_dr = vect_analyze_pointer_ref_access (memref, stmt, is_read, \n+\t\t\t\t\t\t    &ptr_init);\n \t  if (!new_dr)\n \t    return NULL_TREE; \n \t  *dr = new_dr;\n-\t  symbl = DR_BASE_NAME (new_dr);\n-\t  ref_to_be_analyzed = DR_BASE_NAME (new_dr);\n+\t  symbl = ptr_init;\n+\t  ref_to_be_analyzed = ptr_init;\n \t  break;\n       \n \tcase ARRAY_REF:"}]}