{"sha": "834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM0YzZkZmY3YmE3ODQ1YzdmYWJlZGE2N2Y3MTFiNWFhMGYzNDFkOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-03T02:27:15Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-03T02:27:15Z"}, "message": "* tree.h (TYPE_ALIGN_UNIT): New macro.\n\nFrom-SVN: r32302", "tree": {"sha": "db09bd0c5719c40d563da6f148b6e0c062ae1ce1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db09bd0c5719c40d563da6f148b6e0c062ae1ce1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/comments", "author": null, "committer": null, "parents": [{"sha": "a2b10a92a30b30c5f1fa5324daa7e41bc162db95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b10a92a30b30c5f1fa5324daa7e41bc162db95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b10a92a30b30c5f1fa5324daa7e41bc162db95"}], "stats": {"total": 652, "additions": 502, "deletions": 150}, "files": [{"sha": "d0eee38292489e519f28589de210b882668e6859", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -1,3 +1,7 @@\n+2000-03-02  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* tree.h (TYPE_ALIGN_UNIT): New macro.\n+\n 2000-03-02  Clinton Popetz  <cpopetz@cygnus.com>\n \n \t* config/i386/i386.c: (constant_call_address_operand): Reject"}, {"sha": "d9bb284df1ec103f9fc1ce67019ef5032033d8a9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -1,3 +1,64 @@\n+2000-03-02  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (TYPE_NEEDS_DESTRUCTOR): Rename to ...\n+\t(TYPE_HAS_NONTRIVIAL_DESTRUCTOR): ... this.\n+\t(TYPE_HAS_TRIVIAL_DESTRUCTOR): New macro.\n+\t(lang_type): Split gets_new into has_new and has_array_new.\n+\t(TYPE_VEC_NEW_USES_COOKIE): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR.\n+\t(TYPE_GETS_NEW): Split into ...\n+\t(TYPE_HAS_NEW_OPERATOR): ... this, and ...\n+\t(TYPE_HAS_ARRAY_NEW_OPERATOR): ... this.\n+\t(DECL_ARRAY_DELETE_OPERATOR_P): New macro\n+\t(build_op_new_call): Don't declare.\n+\t(build_new_1): Likewise.\n+\t* call.c (build_op_new_call): Remove.\n+\t* class.c (check_bases): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n+\tinstead of TYPE_NEEDS_DESTRUCTOR.\n+\t(finish_struct_bits): Likewise.\n+\t(add_implicitly_declared_members): Likewise.\n+\t(check_field_decl): Likewise.\n+\t(check_methods): Set TYPE_VEC_DELETE_TAKES_SIZE here, and set it\n+\tcorrectly under the new ABI.\n+\t* decl.c (start_decl_1): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n+\tinstead of TYPE_NEEDS_DESTRUCTOR.\n+\t(initialize_local_var): Likewise.\n+\t(destroy_local_var): Likewise.\n+\t(cp_finish_decl): Likewise.\n+\t(register_dtor_fn): Likewise.\n+\t(grok_op_properties): Set TYPE_HAS_NEW_OPERATOR and\n+\tTYPE_HAS_ARRAY_NEW_OPERATOR, not TYPE_HAS_NEW.  Don't set\n+\tTYPE_VEC_DELETE_TAKES_SIZE here.\n+\t(xref_basetypes): Set TYPE_HAS_NEW_OPERATOR and\n+\tTYPE_HAS_ARRAY_NEW_OPERATOR, not TYPE_HAS_NEW.\n+\t(store_parm_decls):  Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR.\n+\t(finish_destructor_body): Likewise.\n+\t(maybe_build_cleanup_1): Likewise.\n+\t* decl2.c (do_static_destruction): Likewise.\n+\t* init.c (build_new_1): Make it static.\n+\t(perform_member_init): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR.\n+\t(expand_cleanup_for_base): Likewise.\n+\t(get_cookie_size): New function.\n+\t(build_new_1): Handle array-new cookies correctly under the new\n+\tABI.\n+\t(build_vec_delete_1): Likewise.\n+\t(build_vec_init):  Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR.\n+\t(build_delete): Likewise.\n+\t(build_vec_delete): Handle array-new cookies correctly under the new\n+\tABI.\n+\t* lex.c (do_identifier): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR.\n+\t* pt.c (instantiate_class_template): Set TYPE_HAS_NEW_OPERATOR and\n+\tTYPE_HAS_ARRAY_NEW_OPERATOR.\n+\t* ptree.c (print_lang_type): Check them.\n+\t* search.c (context_for_name_lookup): Fix typo in comment.\n+\t(tree_has_any_destructor_p): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR.\n+\t* tree.c (break_out_cleanups): Likewise.\n+\t(build_cplus_array_test_1): Likewise.\n+\t(cp_build_qualified_type_real): Likewise.\n+\t* typeck.c (complete_type): Likewise.\n+\t\n+\t* g++spec.c (lang_specific_driver): Add -fnew-abi at the start of\n+\tthe command-line, not the end.\n+\t\n 2000-03-01  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* pt.c (instantiate_decl): Clear TI_PENDING_TEMPLATE_FLAG."}, {"sha": "72c4ccbd187a2f437c8507f8a0804b42b0d09dbf", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -3452,31 +3452,6 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     }\n }\n \n-/* Build up a call to operator new.  This has to be handled differently\n-   from other operators in the way lookup is handled; first members are\n-   considered, then globals.  CODE is either NEW_EXPR or VEC_NEW_EXPR.\n-   TYPE is the type to be created.  ARGS are any new-placement args.\n-   FLAGS are the usual overloading flags.  */\n-\n-tree\n-build_op_new_call (code, type, args, flags)\n-     enum tree_code code;\n-     tree type, args;\n-     int flags;\n-{\n-  tree fnname = ansi_opname[code];\n-\n-  if (IS_AGGR_TYPE (type) && ! (flags & LOOKUP_GLOBAL)\n-      && (TYPE_GETS_NEW (type) & (1 << (code == VEC_NEW_EXPR))))\n-    {\n-      return build_method_call (build_dummy_object (type),\n-\t\t\t\tfnname, args, NULL_TREE, flags);\n-    }\n-  else\n-    return build_new_function_call \n-      (lookup_function_nonclass (fnname, args), args);\n-}\n-\n /* Build a call to operator delete.  This has to be handled very specially,\n    because the restrictions on what signatures match are different from all\n    other call instances.  For a normal delete, only a delete taking (void *)"}, {"sha": "c76146ab00aa39fb640cdb6f90d135ff4f542a1c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -1934,7 +1934,8 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n       /* A lot of properties from the bases also apply to the derived\n \t class.  */\n       TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (basetype);\n-      TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_NEEDS_DESTRUCTOR (basetype);\n+      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) \n+\t|= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (basetype);\n       TYPE_HAS_COMPLEX_ASSIGN_REF (t) \n \t|= TYPE_HAS_COMPLEX_ASSIGN_REF (basetype);\n       TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (basetype);\n@@ -2079,7 +2080,8 @@ finish_struct_bits (t)\n       TYPE_HAS_CONSTRUCTOR (variants) = TYPE_HAS_CONSTRUCTOR (t);\n       TYPE_HAS_DESTRUCTOR (variants) = TYPE_HAS_DESTRUCTOR (t);\n       TYPE_NEEDS_CONSTRUCTING (variants) = TYPE_NEEDS_CONSTRUCTING (t);\n-      TYPE_NEEDS_DESTRUCTOR (variants) = TYPE_NEEDS_DESTRUCTOR (t);\n+      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (variants) \n+\t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t);\n \n       TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (variants) \n \t= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (t);\n@@ -3503,14 +3505,14 @@ add_implicitly_declared_members (t, cant_have_default_ctor,\n   tree *f;\n \n   /* Destructor.  */\n-  if (TYPE_NEEDS_DESTRUCTOR (t) && !TYPE_HAS_DESTRUCTOR (t))\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) && !TYPE_HAS_DESTRUCTOR (t))\n     {\n       default_fn = cons_up_default_function (t, name, 0);\n       check_for_override (default_fn, t);\n \n       /* If we couldn't make it work, then pretend we didn't need it.  */\n       if (default_fn == void_type_node)\n-\tTYPE_NEEDS_DESTRUCTOR (t) = 0;\n+\tTYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = 0;\n       else\n \t{\n \t  TREE_CHAIN (default_fn) = implicit_fns;\n@@ -3520,7 +3522,9 @@ add_implicitly_declared_members (t, cant_have_default_ctor,\n \t    virtual_dtor = default_fn;\n \t}\n     }\n-  TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n+  else\n+    /* Any non-implicit destructor is non-trivial.  */\n+    TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n \n   /* Default constructor.  */\n   if (! TYPE_HAS_CONSTRUCTOR (t) && ! cant_have_default_ctor)\n@@ -3744,7 +3748,7 @@ check_field_decl (field, t, cant_have_const_ctor,\n \t  if (TYPE_NEEDS_CONSTRUCTING (type))\n \t    cp_error_at (\"member `%#D' with constructor not allowed in union\",\n \t\t\t field);\n-\t  if (TYPE_NEEDS_DESTRUCTOR (type))\n+\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n \t    cp_error_at (\"member `%#D' with destructor not allowed in union\",\n \t\t\t field);\n \t  if (TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n@@ -3754,7 +3758,8 @@ check_field_decl (field, t, cant_have_const_ctor,\n       else\n \t{\n \t  TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (type);\n-\t  TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_NEEDS_DESTRUCTOR (type);\n+\t  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) \n+\t    |= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type);\n \t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_HAS_COMPLEX_ASSIGN_REF (type);\n \t  TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (type);\n \t}\n@@ -4268,6 +4273,7 @@ check_methods (t)\n      tree t;\n {\n   tree x;\n+  int seen_one_arg_array_delete_p = 0;\n \n   for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n     {\n@@ -4291,6 +4297,37 @@ check_methods (t)\n \t    CLASSTYPE_PURE_VIRTUALS (t)\n \t      = tree_cons (NULL_TREE, x, CLASSTYPE_PURE_VIRTUALS (t));\n \t}\n+\n+      if (DECL_ARRAY_DELETE_OPERATOR_P (x))\n+\t{\n+\t  tree second_parm;\n+\n+\t  /* When dynamically allocating an array of this type, we\n+\t     need a \"cookie\" to record how many elements we allocated,\n+\t     even if the array elements have no non-trivial\n+\t     destructor, if the usual array deallocation function\n+\t     takes a second argument of type size_t.  The standard (in\n+\t     [class.free]) requires that the second argument be set\n+\t     correctly.  */\n+\t  second_parm = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (x)));\n+\t  /* This is overly conservative, but we must maintain this\n+\t     behavior for backwards compatibility.  */\n+\t  if (!flag_new_abi && second_parm != void_list_node)\n+\t    TYPE_VEC_DELETE_TAKES_SIZE (t) = 1;\n+\t  /* Under the new ABI, we choose only those function that are\n+\t     explicitly declared as `operator delete[] (void *,\n+\t     size_t)'.  */\n+\t  else if (flag_new_abi \n+\t\t   && !seen_one_arg_array_delete_p\n+\t\t   && second_parm\n+\t\t   && TREE_CHAIN (second_parm) == void_list_node\n+\t\t   && same_type_p (TREE_VALUE (second_parm), sizetype))\n+\t    TYPE_VEC_DELETE_TAKES_SIZE (t) = 1;\n+\t  /* If there's no second parameter, then this is the usual\n+\t     deallocation function.  */\n+\t  else if (second_parm == void_list_node)\n+\t    seen_one_arg_array_delete_p = 1;\n+\t}\n     }\n }\n "}, {"sha": "ce2b94c639f2b97d5b6e7351a9af05e2beee1d71", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -81,7 +81,7 @@ Boston, MA 02111-1307, USA.  */\n    1: TYPE_HAS_CONSTRUCTOR.\n    2: TYPE_HAS_DESTRUCTOR.\n    3: TYPE_FOR_JAVA.\n-   4: TYPE_NEEDS_DESTRUCTOR.\n+   4: TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n    5: IS_AGGR_TYPE.\n    6: TYPE_BUILT_IN.\n \n@@ -1310,7 +1310,8 @@ struct lang_type\n   unsigned has_nonpublic_assign_ref : 2;\n   unsigned vtable_needs_writing : 1;\n   unsigned has_assign_ref : 1;\n-  unsigned gets_new : 2;\n+  unsigned has_new : 1;\n+  unsigned has_array_new : 1;\n \n   unsigned gets_delete : 2;\n   unsigned has_call_overloaded : 1;\n@@ -1391,19 +1392,23 @@ struct lang_type\n /* List of friends which were defined inline in this class definition.  */\n #define CLASSTYPE_INLINE_FRIENDS(NODE) (TYPE_NONCOPIED_PARTS (NODE))\n \n-/* Nonzero for _CLASSTYPE means that operator new and delete are defined,\n-   respectively.  */\n-#define TYPE_GETS_NEW(NODE) (TYPE_LANG_SPECIFIC(NODE)->gets_new)\n+/* Nonzero for _CLASSTYPE means that operator delete is defined.  */\n #define TYPE_GETS_DELETE(NODE) (TYPE_LANG_SPECIFIC(NODE)->gets_delete)\n #define TYPE_GETS_REG_DELETE(NODE) (TYPE_GETS_DELETE (NODE) & 1)\n \n /* Nonzero for _CLASSTYPE means that operator vec delete is defined and\n    takes the optional size_t argument.  */\n #define TYPE_VEC_DELETE_TAKES_SIZE(NODE) \\\n   (TYPE_LANG_SPECIFIC(NODE)->vec_delete_takes_size)\n-#define TYPE_VEC_NEW_USES_COOKIE(NODE) \\\n-  (TYPE_NEEDS_DESTRUCTOR (NODE) \\\n-   || (TYPE_LANG_SPECIFIC (NODE) && TYPE_VEC_DELETE_TAKES_SIZE (NODE)))\n+\n+/* Nonzero if `new NODE[x]' should cause the allocation of extra\n+   storage to indicate how many array elements are in use.  The old\n+   ABI had a bug in that we always allocate the extra storage if NODE\n+   has a two-argument array operator delete.  */\n+#define TYPE_VEC_NEW_USES_COOKIE(NODE)\t\t\\\n+  (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (NODE)\t\\\n+   || (TYPE_LANG_SPECIFIC (NODE) \t\t\\\n+       && TYPE_VEC_DELETE_TAKES_SIZE (NODE)))\n \n /* Nonzero means that this _CLASSTYPE node defines ways of converting\n    itself to other types.  */\n@@ -1417,6 +1422,15 @@ struct lang_type\n #define TYPE_HAS_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_init_ref)\n #define TYPE_HAS_CONST_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_const_init_ref)\n \n+/* Nonzero if this class defines an overloaded operator new.  (An\n+   operator new [] doesn't count.)  */\n+#define TYPE_HAS_NEW_OPERATOR(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->has_new)\n+\n+/* Nonzero if this class defines an overloaded operator new[].  */\n+#define TYPE_HAS_ARRAY_NEW_OPERATOR(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->has_array_new)\n+\n /* Nonzero means that this type is being defined.  I.e., the left brace\n    starting the definition of this type has been seen.  */\n #define TYPE_BEING_DEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->being_defined)\n@@ -1916,6 +1930,10 @@ struct lang_decl\n #define SET_DECL_TINFO_FN_P(NODE) \\\n   (DECL_LANG_SPECIFIC((NODE))->decl_flags.mutable_flag = 1)\n \n+/* Nonzero if NODE is an overloaded `operator delete[]' function.  */\n+#define DECL_ARRAY_DELETE_OPERATOR_P(NODE) \\\n+  (DECL_NAME (NODE) == ansi_opname[(int) VEC_DELETE_EXPR])\n+\n /* Nonzero for _DECL means that this decl appears in (or will appear\n    in) as a member in a RECORD_TYPE or UNION_TYPE node.  It is also for\n    detecting circularity in case members are multiply defined.  In the\n@@ -2410,10 +2428,26 @@ extern int flag_new_for_scope;\n #define TYPE_HAS_ABSTRACT_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_abstract_assign_ref)\n #define TYPE_HAS_COMPLEX_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_complex_init_ref)\n \n-/* Nonzero for _TYPE node means that destroying an object of this type\n-   will involve a call to a destructor.  This can apply to objects\n-   of ARRAY_TYPE is the type of the elements needs a destructor.  */\n-#define TYPE_NEEDS_DESTRUCTOR(NODE) (TYPE_LANG_FLAG_4(NODE))\n+/* Nonzero if TYPE has a trivial destructor.  From [class.dtor]:\n+   \n+     A destructor is trivial if it is an implicitly declared\n+     destructor and if:\n+\n+       - all of the direct base classes of its class have trivial\n+         destructors, \n+\n+       - for all of the non-static data members of its class that are\n+         of class type (or array thereof), each such class has a \n+\t trivial destructor.  */\n+#define TYPE_HAS_TRIVIAL_DESTRUCTOR(NODE) \\\n+  (!TYPE_HAS_NONTRIVIAL_DESTRUCTOR (NODE))\n+\n+/* Nonzero for _TYPE node means that this type does not have a trivial\n+   destructor.  Therefore, destroying an object of this type will\n+   involve a call to a destructor.  This can apply to objects of\n+   ARRAY_TYPE is the type of the elements needs a destructor.  */\n+#define TYPE_HAS_NONTRIVIAL_DESTRUCTOR(NODE) \\\n+  (TYPE_LANG_FLAG_4(NODE))\n \n /* Nonzero for class type means that initialization of this type can use\n    a bitwise copy.  */\n@@ -3578,7 +3612,6 @@ extern tree type_decays_to\t\t\tPARAMS ((tree));\n extern tree build_user_type_conversion\t\tPARAMS ((tree, tree, int));\n extern tree build_new_function_call\t\tPARAMS ((tree, tree));\n extern tree build_new_op\t\t\tPARAMS ((enum tree_code, int, tree, tree, tree));\n-extern tree build_op_new_call\t\t\tPARAMS ((enum tree_code, tree, tree, int));\n extern tree build_op_delete_call\t\tPARAMS ((enum tree_code, tree, tree, int, tree));\n extern int can_convert\t\t\t\tPARAMS ((tree, tree));\n extern int can_convert_arg\t\t\tPARAMS ((tree, tree, tree));\n@@ -3922,7 +3955,6 @@ extern tree build_offset_ref\t\t\tPARAMS ((tree, tree));\n extern tree resolve_offset_ref\t\t\tPARAMS ((tree));\n extern tree decl_constant_value\t\t\tPARAMS ((tree));\n extern tree build_new\t\t\t\tPARAMS ((tree, tree, tree, int));\n-extern tree build_new_1\t\t\t\tPARAMS ((tree));\n extern tree build_vec_init\t\t\tPARAMS ((tree, tree, tree, tree, int));\n extern tree build_x_delete\t\t\tPARAMS ((tree, int, tree));\n extern tree build_delete\t\t\tPARAMS ((tree, tree, tree, int, int));"}, {"sha": "df8e008fcadd7c54a7792503579d6f607ca113f5", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -6844,7 +6844,7 @@ start_decl_1 (decl)\n   /* If this type of object needs a cleanup, but we're not allowed to\n      add any more objects with cleanups to the current scope, create a\n      new binding level.  */\n-  if (TYPE_NEEDS_DESTRUCTOR (type)\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n       && current_binding_level->more_cleanups_ok == 0)\n     {\n       keep_next_level (2);\n@@ -7490,7 +7490,7 @@ initialize_local_var (decl, init, flags)\n   if (TREE_STATIC (decl))\n     {\n       if (TYPE_NEEDS_CONSTRUCTING (type) || init != NULL_TREE\n-\t  || TYPE_NEEDS_DESTRUCTOR (type))\n+\t  || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n \texpand_static_init (decl, init);\n       return;\n     }\n@@ -7522,7 +7522,7 @@ initialize_local_var (decl, init, flags)\n \t marked used. (see TREE_USED, above.)  */\n       if (TYPE_NEEDS_CONSTRUCTING (type)\n \t  && ! already_used\n-\t  && !TYPE_NEEDS_DESTRUCTOR (type)\n+\t  && TYPE_HAS_TRIVIAL_DESTRUCTOR (type)\n \t  && DECL_NAME (decl))\n \tTREE_USED (decl) = 0;\n       else if (already_used)\n@@ -7544,7 +7544,7 @@ destroy_local_var (decl)\n     return;\n \n   /* And only things with destructors need cleaning up.  */\n-  if (!TYPE_NEEDS_DESTRUCTOR (type))\n+  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n     return;\n \n   if (TREE_CODE (decl) == VAR_DECL &&\n@@ -7820,7 +7820,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \t{\n \t  /* Cleanups for static variables are handled by `finish_file'.  */\n \t  if (TYPE_NEEDS_CONSTRUCTING (type) || init != NULL_TREE\n-\t      || TYPE_NEEDS_DESTRUCTOR (type))\n+\t      || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n \t    expand_static_init (decl, init);\n \t}\n     finish_end0:\n@@ -8054,7 +8054,7 @@ register_dtor_fn (decl)\n \n   int saved_flag_access_control;\n \n-  if (!TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (decl)))\n+  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n     return;\n \n   /* Call build_cleanup before we enter the anonymous function so that\n@@ -11856,11 +11856,11 @@ grok_op_properties (decl, virtualp, friendp)\n \t       || name == ansi_opname[(int) MEMBER_REF])\n \tTYPE_OVERLOADS_ARROW (current_class_type) = 1;\n       else if (name == ansi_opname[(int) NEW_EXPR])\n-\tTYPE_GETS_NEW (current_class_type) |= 1;\n+\tTYPE_HAS_NEW_OPERATOR (current_class_type) = 1;\n       else if (name == ansi_opname[(int) DELETE_EXPR])\n \tTYPE_GETS_DELETE (current_class_type) |= 1;\n       else if (name == ansi_opname[(int) VEC_NEW_EXPR])\n-\tTYPE_GETS_NEW (current_class_type) |= 2;\n+\tTYPE_HAS_ARRAY_NEW_OPERATOR (current_class_type) = 1;\n       else if (name == ansi_opname[(int) VEC_DELETE_EXPR])\n \tTYPE_GETS_DELETE (current_class_type) |= 2;\n     }\n@@ -11894,14 +11894,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t\t\t\t hash_tree_chain (ptr_type_node,\n \t\t\t\t\t\t  void_list_node));\n       else\n-\t{\n-\t  TREE_TYPE (decl) = coerce_delete_type (TREE_TYPE (decl));\n-\n-\t  if (! friendp && name == ansi_opname[(int) VEC_DELETE_EXPR]\n-\t      && (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (decl)))\n-\t\t  != void_list_node))\n-\t    TYPE_VEC_DELETE_TAKES_SIZE (current_class_type) = 1;\n-\t}\n+\tTREE_TYPE (decl) = coerce_delete_type (TREE_TYPE (decl));\n     }\n   else\n     {\n@@ -12508,7 +12501,10 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \n \t  if (CLASS_TYPE_P (basetype))\n \t    {\n-\t      TYPE_GETS_NEW (ref) |= TYPE_GETS_NEW (basetype);\n+\t      TYPE_HAS_NEW_OPERATOR (ref) \n+\t\t|= TYPE_HAS_NEW_OPERATOR (basetype);\n+\t      TYPE_HAS_ARRAY_NEW_OPERATOR (ref) \n+\t\t|= TYPE_HAS_ARRAY_NEW_OPERATOR (basetype);\n \t      TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n \t      /* If the base-class uses multiple inheritance, so do we.  */\n \t      TYPE_USES_MULTIPLE_INHERITANCE (ref)\n@@ -13387,7 +13383,7 @@ store_parm_decls ()\n \t\t    cleanups = tree_cons (parm, cleanup, cleanups);\n \t\t}\n \t      else if (type != error_mark_node\n-\t\t       && TYPE_NEEDS_DESTRUCTOR (type))\n+\t\t       && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n \t\tparms_have_cleanups = 1;\n \t    }\n \t  else\n@@ -13603,7 +13599,7 @@ finish_destructor_body ()\n \n \t  while (vbases)\n \t    {\n-\t      if (TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (vbases)))\n+\t      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (vbases)))\n \t\t{\n \t\t  tree vb = get_vbase\n \t\t    (BINFO_TYPE (vbases),\n@@ -14286,7 +14282,7 @@ maybe_build_cleanup_1 (decl, auto_delete)\n      tree decl, auto_delete;\n {\n   tree type = TREE_TYPE (decl);\n-  if (type != error_mark_node && TYPE_NEEDS_DESTRUCTOR (type))\n+  if (type != error_mark_node && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n     {\n       int flags = LOOKUP_NORMAL|LOOKUP_DESTRUCTOR;\n       tree rval;"}, {"sha": "b961f26dc1399e4876084b89963599909ce8caf2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -3238,7 +3238,7 @@ do_static_destruction (decl)\n   my_friendly_assert (!flag_use_cxa_atexit, 20000121);\n \n   /* If we don't need a destructor, there's nothing to do.  */\n-  if (!TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (decl)))\n+  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n     return;\n \n   /* Actually do the destruction.  */"}, {"sha": "b3bab5a3a0c1671d0b6dfff552d9fdeb193f02b1", "filename": "gcc/cp/g++spec.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fg%2B%2Bspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fg%2B%2Bspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fg%2B%2Bspec.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -206,8 +206,21 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   real_arglist = (char **) xmalloc (num_args * sizeof (char *));\n   arglist = (const char **) real_arglist;\n \n+  i = 0;\n+  j = 0;\n+  \n+  /* Copy the 0th argument, i.e., the name of the program itself.  */\n+  arglist[i++] = arglist[j++];\n+\n+#if ENABLE_NEW_GXX_ABI\n+  /* If we should use the new ABI by default, add the appropriate flag\n+     to cc1plus here.  We put this first so that it can be overridden\n+     by other command-line options.  */\n+  arglist[j++] = \"-fnew-abi\";\n+#endif\n+\n   /* NOTE: We start at 1 now, not 0.  */\n-  for (i = 0, j = 0; i < argc; i++, j++)\n+  while (i < argc)\n     {\n       arglist[j] = argv[i];\n \n@@ -237,11 +250,10 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \t  arglist[j++] = argv[i];\n \t  arglist[j] = \"-xnone\";\n \t}\n-  }\n \n-#if ENABLE_NEW_GXX_ABI\n-  arglist[j++] = \"-fnew-abi\";\n-#endif\n+      i++;\n+      j++;\n+    }\n \n   /* Add `-lstdc++' if we haven't already done so.  */\n   if (library)"}, {"sha": "fb6c4e661da2273b2e175e0006dde810678a3c5b", "filename": "gcc/cp/init.c", "status": "modified", "additions": 164, "deletions": 62, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -49,6 +49,8 @@ static tree initializing_context PARAMS ((tree));\n static void expand_cleanup_for_base PARAMS ((tree, tree));\n static tree get_temp_regvar PARAMS ((tree, tree));\n static tree dfs_initialize_vtbl_ptrs PARAMS ((tree, void *));\n+static tree build_new_1\tPARAMS ((tree));\n+static tree get_cookie_size PARAMS ((tree));\n \n /* Set up local variable for this file.  MUST BE CALLED AFTER\n    INIT_DECL_PROCESSING.  */\n@@ -225,7 +227,7 @@ perform_member_init (member, name, init, explicit)\n \tfinish_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n     }\n \n-  if (TYPE_NEEDS_DESTRUCTOR (type))\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n     {\n       tree expr;\n \n@@ -701,7 +703,7 @@ expand_cleanup_for_base (binfo, flag)\n {\n   tree expr;\n \n-  if (!TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (binfo)))\n+  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (BINFO_TYPE (binfo)))\n     return;\n \n   /* Call the destructor.  */\n@@ -2101,10 +2103,40 @@ build_java_class_ref (type)\n   return class_decl;\n }\n \n+/* Returns teh size of the cookie to use when allocating an array\n+   whose elements have the indicated TYPE.  Assumes that it is already\n+   known that a cookie is needed.  */\n+\n+static tree\n+get_cookie_size (type)\n+     tree type;\n+{\n+  tree cookie_size;\n+\n+  if (flag_new_abi)\n+    {\n+      /* Under the new ABI, we need to allocate an additional max\n+\t (sizeof (size_t), alignof (true_type)) bytes.  */\n+      tree sizetype_size;\n+      tree type_align;\n+\n+      sizetype_size = size_in_bytes (sizetype);\n+      type_align = size_int (TYPE_ALIGN_UNIT (type));\n+      if (INT_CST_LT_UNSIGNED (type_align, sizetype_size))\n+\tcookie_size = sizetype_size;\n+      else\n+\tcookie_size = type_align;\n+    }\n+  else\n+    cookie_size = BI_header_size;\n+\n+  return cookie_size;\n+}\n+\n /* Called from cplus_expand_expr when expanding a NEW_EXPR.  The return\n    value is immediately handed to expand_expr.  */\n \n-tree\n+static tree\n build_new_1 (exp)\n      tree exp;\n {\n@@ -2113,15 +2145,23 @@ build_new_1 (exp)\n   tree nelts = NULL_TREE;\n   tree alloc_expr, alloc_node = NULL_TREE;\n   int has_array = 0;\n-  enum tree_code code = NEW_EXPR;\n+  enum tree_code code;\n   int use_cookie, nothrow, check_new;\n+  /* Nonzero if the user wrote `::new' rather than just `new'.  */\n+  int globally_qualified_p;\n+  /* Nonzero if we're going to call a global operator new, rather than\n+     a class-specific version.  */\n   int use_global_new;\n   int use_java_new = 0;\n+  /* If non-NULL, the number of extra bytes to allocate at the\n+     beginning of the storage allocated for an array-new expression in\n+     order to store the number of elements.  */\n+  tree cookie_size = NULL_TREE;\n \n   placement = TREE_OPERAND (exp, 0);\n   type = TREE_OPERAND (exp, 1);\n   init = TREE_OPERAND (exp, 2);\n-  use_global_new = NEW_EXPR_USE_GLOBAL (exp);\n+  globally_qualified_p = NEW_EXPR_USE_GLOBAL (exp);\n \n   if (TREE_CODE (type) == ARRAY_REF)\n     {\n@@ -2131,6 +2171,8 @@ build_new_1 (exp)\n     }\n   true_type = type;\n \n+  code = has_array ? VEC_NEW_EXPR : NEW_EXPR;\n+\n   if (CP_TYPE_QUALS (type))\n     type = TYPE_MAIN_VARIANT (type);\n \n@@ -2161,32 +2203,44 @@ build_new_1 (exp)\n   if (abstract_virtuals_error (NULL_TREE, true_type))\n     return error_mark_node;\n \n-  /* When we allocate an array, and the corresponding deallocation\n-     function takes a second argument of type size_t, and that's the\n-     \"usual deallocation function\", we allocate some extra space at\n-     the beginning of the array to store the size of the array.\n-\n-     Well, that's what we should do.  For backwards compatibility, we\n-     have to do this whenever there's a two-argument array-delete\n-     operator. \n-\n-     FIXME: For -fnew-abi, we don't have to maintain backwards\n-     compatibility and we should fix this.  */\n-  use_cookie = (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type)\n-\t\t&& ! (placement && ! TREE_CHAIN (placement)\n-\t\t      && TREE_TYPE (TREE_VALUE (placement)) == ptr_type_node));\n+  /* Figure out whether or not we're going to use the global operator\n+     new.  */\n+  if (!globally_qualified_p\n+      && IS_AGGR_TYPE (true_type)\n+      && ((!has_array && TYPE_HAS_NEW_OPERATOR (true_type))\n+\t  || (has_array && TYPE_HAS_ARRAY_NEW_OPERATOR (true_type))))\n+    use_global_new = 0;\n+  else\n+    use_global_new = 1;\n+\n+  /* We only need cookies for arrays containing types for which we\n+     need cookies.  */\n+  if (!has_array || !TYPE_VEC_NEW_USES_COOKIE (true_type))\n+    use_cookie = 0;\n+  /* When using placement new, users may not realize that they need\n+     the extra storage.  Under the old ABI, we don't allocate the\n+     cookie whenever they use one placement argument of type `void\n+     *'.  Under the new ABI, we require that the operator called be\n+     the global placement operator delete[].  */\n+  else if (placement && !TREE_CHAIN (placement) \n+\t   && same_type_p (TREE_TYPE (TREE_VALUE (placement)),\n+\t\t\t   ptr_type_node))\n+    use_cookie = (!flag_new_abi || !use_global_new);\n+  /* Otherwise, we need the cookie.  */\n+  else\n+    use_cookie = 1;\n \n+  /* Compute the number of extra bytes to allocate, now that we know\n+     whether or not we need the cookie.  */\n   if (use_cookie)\n-    size = size_binop (PLUS_EXPR, size, BI_header_size);\n-\n-  if (has_array)\n     {\n-      code = VEC_NEW_EXPR;\n-\n-      if (init && pedantic)\n-\tcp_pedwarn (\"initialization in array new\");\n+      cookie_size = get_cookie_size (true_type);\n+      size = size_binop (PLUS_EXPR, size, cookie_size);\n     }\n \n+  if (has_array && init && pedantic)\n+    cp_pedwarn (\"initialization in array new\");\n+\n   /* Allocate the object.  */\n   \n   if (! placement && TYPE_FOR_JAVA (true_type))\n@@ -2208,9 +2262,20 @@ build_new_1 (exp)\n     }\n   else\n     {\n-      rval = build_op_new_call\n-\t(code, true_type, tree_cons (NULL_TREE, size, placement),\n-\t LOOKUP_NORMAL | (use_global_new * LOOKUP_GLOBAL));\n+      tree fnname;\n+      tree args;\n+\n+      args = tree_cons (NULL_TREE, size, placement);\n+      fnname = ansi_opname[code];\n+\n+      if (use_global_new)\n+\trval = (build_new_function_call \n+\t\t(lookup_function_nonclass (fnname, args),\n+\t\t args));\n+      else\n+\trval = build_method_call (build_dummy_object (true_type),\n+\t\t\t\t  fnname, args, NULL_TREE,\n+\t\t\t\t  LOOKUP_NORMAL);\n       rval = cp_convert (build_pointer_type (true_type), rval);\n     }\n \n@@ -2249,18 +2314,36 @@ build_new_1 (exp)\n   /* Finish up some magic for new'ed arrays */\n   if (use_cookie && rval != NULL_TREE)\n     {\n-      tree extra = BI_header_size;\n       tree cookie, exp1;\n       rval = convert (string_type_node, rval); /* for ptr arithmetic */\n-      rval = save_expr (build_binary_op (PLUS_EXPR, rval, extra));\n-      /* Store header info.  */\n-      cookie = build_indirect_ref (build (MINUS_EXPR,\n-\t\t\t\t\t  build_pointer_type (BI_header_type),\n-\t\t\t\t\t  rval, extra), NULL_PTR);\n-      exp1 = build (MODIFY_EXPR, void_type_node,\n-\t\t    build_component_ref (cookie, nelts_identifier,\n-\t\t\t\t\t NULL_TREE, 0),\n-\t\t    nelts);\n+      rval = save_expr (build_binary_op (PLUS_EXPR, rval, cookie_size));\n+      /* Store the number of bytes allocated so that we can know how\n+\t many elements to destroy later.  */\n+      if (flag_new_abi)\n+\t{\n+\t  /* Under the new ABI, we use the last sizeof (size_t) bytes\n+\t     to store the number of elements.  */\n+\t  cookie = build_indirect_ref (build (MINUS_EXPR,\n+\t\t\t\t\t      build_pointer_type (sizetype),\n+\t\t\t\t\t      rval,\n+\t\t\t\t\t      size_in_bytes (sizetype)),\n+\t\t\t\t       NULL_PTR);\n+\t  exp1 = build (MODIFY_EXPR, void_type_node, cookie, nelts);\n+\t}\n+      else\n+\t{\n+\t  cookie \n+\t    = build_indirect_ref (build (MINUS_EXPR,\n+\t\t\t\t\t build_pointer_type (BI_header_type),\n+\t\t\t\t\t rval, cookie_size), NULL_PTR);\n+\t  exp1 = build (MODIFY_EXPR, void_type_node,\n+\t\t\tbuild_component_ref (cookie, nelts_identifier,\n+\t\t\t\t\t     NULL_TREE, 0),\n+\t\t\tnelts);\n+\t}\n+\n+      /* Build `(cookie = nelts, rval)' and use that as the complete\n+\t expression.  */\n       rval = cp_convert (build_pointer_type (true_type), rval);\n       rval = build_compound_expr\n \t(tree_cons (NULL_TREE, exp1,\n@@ -2372,7 +2455,8 @@ build_new_1 (exp)\n \t{\n \t  enum tree_code dcode = has_array ? VEC_DELETE_EXPR : DELETE_EXPR;\n \t  tree cleanup, fn = NULL_TREE;\n-\t  int flags = LOOKUP_NORMAL | (use_global_new * LOOKUP_GLOBAL);\n+\t  int flags = (LOOKUP_NORMAL \n+\t\t       | (globally_qualified_p * LOOKUP_GLOBAL));\n \n \t  /* The Standard is unclear here, but the right thing to do\n              is to use the same method for finding deallocation\n@@ -2475,7 +2559,7 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n      This is also the containing expression returned by this function.  */\n   tree controller = NULL_TREE;\n \n-  if (! IS_AGGR_TYPE (type) || ! TYPE_NEEDS_DESTRUCTOR (type))\n+  if (! IS_AGGR_TYPE (type) || TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n     {\n       loop = integer_zero_node;\n       goto no_destructor;\n@@ -2534,12 +2618,16 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n \tbase_tbd = base;\n       else\n \t{\n-\t  base_tbd = cp_convert (ptype,\n-\t\t\t\t build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t\t  cp_convert (string_type_node, base),\n-\t\t\t\t\t\t  BI_header_size));\n+\t  tree cookie_size;\n+\n+\t  cookie_size = get_cookie_size (type);\n+\t  base_tbd \n+\t    = cp_convert (ptype,\n+\t\t\t  build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t   cp_convert (string_type_node, base),\n+\t\t\t\t\t   cookie_size));\n \t  /* True size with header.  */\n-\t  virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n+\t  virtual_size = size_binop (PLUS_EXPR, virtual_size, cookie_size);\n \t}\n       deallocate_expr = build_x_delete (base_tbd,\n \t\t\t\t\t2 | use_global_delete,\n@@ -2708,7 +2796,7 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \n   /* Protect the entire array initialization so that we can destroy\n      the partially constructed array if an exception is thrown.  */\n-  if (flag_exceptions && TYPE_NEEDS_DESTRUCTOR (type))\n+  if (flag_exceptions && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n     {\n       try_block = begin_try_block ();\n       try_body = begin_compound_stmt (/*has_no_scope=*/1);\n@@ -2893,7 +2981,7 @@ build_vec_init (decl, base, maxindex, init, from_array)\n     }\n \n   /* Make sure to cleanup any partially constructed elements.  */\n-  if (flag_exceptions && TYPE_NEEDS_DESTRUCTOR (type))\n+  if (flag_exceptions && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n     {\n       tree e;\n \n@@ -3029,7 +3117,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n   my_friendly_assert (IS_AGGR_TYPE (type), 220);\n \n-  if (! TYPE_NEEDS_DESTRUCTOR (type))\n+  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n     {\n       if (auto_delete == integer_zero_node)\n \treturn void_zero_node;\n@@ -3105,7 +3193,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       if (auto_delete == integer_zero_node)\n \tcond = NULL_TREE;\n       else if (base_binfo == NULL_TREE\n-\t       || ! TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n+\t       || TYPE_HAS_TRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n \t{\n \t  cond = build (COND_EXPR, void_type_node,\n \t\t\tbuild (BIT_AND_EXPR, integer_type_node, auto_delete, integer_one_node),\n@@ -3120,7 +3208,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n       if (base_binfo\n \t  && ! TREE_VIA_VIRTUAL (base_binfo)\n-\t  && TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n+\t  && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n \t{\n \t  tree this_auto_delete;\n \n@@ -3139,7 +3227,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       for (i = 1; i < n_baseclasses; i++)\n \t{\n \t  base_binfo = TREE_VEC_ELT (binfos, i);\n-\t  if (! TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (base_binfo))\n+\t  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo))\n \t      || TREE_VIA_VIRTUAL (base_binfo))\n \t    continue;\n \n@@ -3154,7 +3242,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t{\n \t  if (TREE_CODE (member) != FIELD_DECL)\n \t    continue;\n-\t  if (TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (member)))\n+\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (member)))\n \t    {\n \t      tree this_member = build_component_ref (ref, DECL_NAME (member), NULL_TREE, 0);\n \t      tree this_type = TREE_TYPE (member);\n@@ -3234,20 +3322,34 @@ build_vec_delete (base, maxindex, auto_delete_vec, use_global_delete)\n   if (TREE_CODE (type) == POINTER_TYPE)\n     {\n       /* Step back one from start of vector, and read dimension.  */\n-      tree cookie_addr = build (MINUS_EXPR, build_pointer_type (BI_header_type),\n-\t\t\t\tbase, BI_header_size);\n-      tree cookie = build_indirect_ref (cookie_addr, NULL_PTR);\n-      maxindex = build_component_ref (cookie, nelts_identifier, NULL_TREE, 0);\n-      do\n-\ttype = TREE_TYPE (type);\n-      while (TREE_CODE (type) == ARRAY_TYPE);\n+      tree cookie_addr;\n+\n+      if (flag_new_abi)\n+\t{\n+\t  cookie_addr = build (MINUS_EXPR,\n+\t\t\t       build_pointer_type (sizetype),\n+\t\t\t       base,\n+\t\t\t       TYPE_SIZE_UNIT (sizetype));\n+\t  maxindex = build_indirect_ref (cookie_addr, NULL_PTR);\n+\t}\n+      else\n+\t{\n+\t  tree cookie;\n+\n+\t  cookie_addr = build (MINUS_EXPR, build_pointer_type (BI_header_type),\n+\t\t\t       base, BI_header_size);\n+\t  cookie = build_indirect_ref (cookie_addr, NULL_PTR);\n+\t  maxindex = build_component_ref (cookie, nelts_identifier, \n+\t\t\t\t\t  NULL_TREE, 0);\n+\t}\n+\n+      type = strip_array_types (TREE_TYPE (type));\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       /* get the total number of things in the array, maxindex is a bad name */\n       maxindex = array_type_nelts_total (type);\n-      while (TREE_CODE (type) == ARRAY_TYPE)\n-\ttype = TREE_TYPE (type);\n+      type = strip_array_types (type);\n       base = build_unary_op (ADDR_EXPR, base, 1);\n     }\n   else"}, {"sha": "5c42a414699233dc2ed4cf4668ead3009fd1ccc6", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -3147,7 +3147,7 @@ do_identifier (token, parsing, args)\n       else if (!DECL_ERROR_REPORTED (id))\n \t{\n \t  DECL_ERROR_REPORTED (id) = 1;\n-\t  if (TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (id)))\n+\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (id)))\n \t    {\n \t      error (\"name lookup of `%s' changed for new ISO `for' scoping\",\n \t\t     IDENTIFIER_POINTER (token));"}, {"sha": "e6e079ce8a1c12fb3604bfc3ee2ee4c6e19a2cf4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -4830,7 +4830,8 @@ instantiate_class_template (type)\n   TYPE_OVERLOADS_CALL_EXPR (type) = TYPE_OVERLOADS_CALL_EXPR (pattern);\n   TYPE_OVERLOADS_ARRAY_REF (type) = TYPE_OVERLOADS_ARRAY_REF (pattern);\n   TYPE_OVERLOADS_ARROW (type) = TYPE_OVERLOADS_ARROW (pattern);\n-  TYPE_GETS_NEW (type) = TYPE_GETS_NEW (pattern);\n+  TYPE_HAS_NEW_OPERATOR (type) = TYPE_HAS_NEW_OPERATOR (pattern);\n+  TYPE_HAS_ARRAY_NEW_OPERATOR (type) = TYPE_HAS_ARRAY_NEW_OPERATOR (pattern);\n   TYPE_GETS_DELETE (type) = TYPE_GETS_DELETE (pattern);\n   TYPE_VEC_DELETE_TAKES_SIZE (type) = TYPE_VEC_DELETE_TAKES_SIZE (pattern);\n   TYPE_HAS_ASSIGN_REF (type) = TYPE_HAS_ASSIGN_REF (pattern);"}, {"sha": "aa72384561674449fac40bb74e176cb6f2354442", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -113,7 +113,7 @@ print_lang_type (file, node, indent)\n \n   if (TYPE_NEEDS_CONSTRUCTING (node))\n     fputs ( \"needs-constructor\", file);\n-  if (TYPE_NEEDS_DESTRUCTOR (node))\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (node))\n     fputs (\" needs-destructor\", file);\n   if (TYPE_HAS_DESTRUCTOR (node))\n     fputs (\" ~X()\", file);\n@@ -128,9 +128,9 @@ print_lang_type (file, node, indent)\n       else\n \tfputs (\" X(X&)\", file);\n     }\n-  if (TYPE_GETS_NEW (node) & 1)\n+  if (TYPE_HAS_NEW_OPERATOR (node))\n     fputs (\" new\", file);\n-  if (TYPE_GETS_NEW (node) & 2)\n+  if (TYPE_HAS_ARRAY_NEW_OPERATOR (node))\n     fputs (\" new[]\", file);\n   if (TYPE_GETS_DELETE (node) & 1)\n     fputs (\" delete\", file);"}, {"sha": "bc0ab2609ed0db4fabc7a0522e5f095cc5751d48", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -725,7 +725,7 @@ context_for_name_lookup (decl)\n      \n      For the purposes of name lookup, after the anonymous union\n      definition, the members of the anonymous union are considered to\n-     have been defined in the scope in which teh anonymous union is\n+     have been defined in the scope in which the anonymous union is\n      declared.  */ \n   tree context = CP_DECL_CONTEXT (decl);\n \n@@ -1955,7 +1955,7 @@ tree_has_any_destructor_p (binfo, data)\n      void *data ATTRIBUTE_UNUSED;\n {\n   tree type = BINFO_TYPE (binfo);\n-  return TYPE_NEEDS_DESTRUCTOR (type) ? binfo : NULL_TREE;\n+  return TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type) ? binfo : NULL_TREE;\n }\n \n /* Returns > 0 if a function with type DRETTYPE overriding a function"}, {"sha": "57adf99b4a0552e17db0151dcc0dad2889af46b8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -322,15 +322,15 @@ break_out_cleanups (exp)\n   tree tmp = exp;\n \n   if (TREE_CODE (tmp) == CALL_EXPR\n-      && TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (tmp)))\n+      && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (tmp)))\n     return build_cplus_new (TREE_TYPE (tmp), tmp);\n \n   while (TREE_CODE (tmp) == NOP_EXPR\n \t || TREE_CODE (tmp) == CONVERT_EXPR\n \t || TREE_CODE (tmp) == NON_LVALUE_EXPR)\n     {\n       if (TREE_CODE (TREE_OPERAND (tmp, 0)) == CALL_EXPR\n-\t  && TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (TREE_OPERAND (tmp, 0))))\n+\t  && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (TREE_OPERAND (tmp, 0))))\n \t{\n \t  TREE_OPERAND (tmp, 0)\n \t    = build_cplus_new (TREE_TYPE (TREE_OPERAND (tmp, 0)),\n@@ -505,8 +505,8 @@ build_cplus_array_type_1 (elt_type, index_type)\n      more easily.  */\n   TYPE_NEEDS_CONSTRUCTING (t) \n     = TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (elt_type));\n-  TYPE_NEEDS_DESTRUCTOR (t) \n-    = TYPE_NEEDS_DESTRUCTOR (TYPE_MAIN_VARIANT (elt_type));\n+  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) \n+    = TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TYPE_MAIN_VARIANT (elt_type));\n   return t;\n }\n \n@@ -602,16 +602,16 @@ cp_build_qualified_type_real (type, type_quals, complain)\n \t}\n \n       /* Even if we already had this variant, we update\n-\t TYPE_NEEDS_CONSTRUCTING and TYPE_NEEDS_DESTRUCTOR in case\n+\t TYPE_NEEDS_CONSTRUCTING and TYPE_HAS_NONTRIVIAL_DESTRUCTOR in case\n \t they changed since the variant was originally created.  \n \t \n \t This seems hokey; if there is some way to use a previous\n \t variant *without* coming through here,\n \t TYPE_NEEDS_CONSTRUCTING will never be updated.  */\n       TYPE_NEEDS_CONSTRUCTING (t) \n \t= TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (element_type));\n-      TYPE_NEEDS_DESTRUCTOR (t) \n-\t= TYPE_NEEDS_DESTRUCTOR (TYPE_MAIN_VARIANT (element_type));\n+      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) \n+\t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TYPE_MAIN_VARIANT (element_type));\n       return t;\n     }\n   else if (TYPE_PTRMEMFUNC_P (type))"}, {"sha": "400d930b0d2edbfe0fa4d756fded7f2dd006ef5e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -155,8 +155,8 @@ complete_type (type)\n \tlayout_type (type);\n       TYPE_NEEDS_CONSTRUCTING (type)\n \t= TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (t));\n-      TYPE_NEEDS_DESTRUCTOR (type)\n-\t= TYPE_NEEDS_DESTRUCTOR (TYPE_MAIN_VARIANT (t));\n+      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n+\t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TYPE_MAIN_VARIANT (t));\n     }\n   else if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n     instantiate_class_template (TYPE_MAIN_VARIANT (type));"}, {"sha": "3e39e372f8d5f976071d136629bf907987ae970e", "filename": "gcc/testsuite/g++.old-deja/g++.abi/arraynew.C", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Farraynew.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Farraynew.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Farraynew.C?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -0,0 +1,127 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+#if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+\n+#include <cstdlib>\n+#include <new>\n+\n+extern \"C\" int printf (const char*, ...);\n+\n+void* p;\n+\n+void* operator new[](size_t s) throw (bad_alloc)\n+{\n+  // Record the base of the last array allocated.\n+  p = malloc (s);\n+  return p;\n+}\n+\n+template <typename T>\n+void check_no_cookie (int i)\n+{\n+  void* a = new T[7];\n+  if (p != a)\n+    exit (i);\n+}\n+\n+template <typename T>\n+void check_no_placement_cookie (int i)\n+{\n+  p = malloc (13 * sizeof (T));\n+  void* a = new (p) T[13];\n+  if (p != a)\n+    exit (i);\n+}\n+\n+template <typename T>\n+void check_cookie (int i)\n+{\n+  void* a = new T[11];\n+  \n+  // Compute the cookie location manually.\n+  size_t x = __alignof__ (T);\n+  if (x < sizeof (size_t))\n+    x = sizeof (size_t);\n+  if ((char *) a - x != (char *) p)\n+    exit (i);\n+\n+  // Check the cookie value.\n+  size_t *sp = ((size_t *) a) - 1;\n+  if (*sp != 11)\n+    exit (i);\n+}\n+\n+template <typename T>\n+void check_placement_cookie (int i)\n+{\n+  p = malloc (sizeof (T) * 11 + 100);\n+  void* a = new (p) T[11];\n+  \n+  printf (\"%x %x\\n\", a, p);\n+  // Compute the cookie location manually.\n+  size_t x = __alignof__ (T);\n+  if (x < sizeof (size_t))\n+    x = sizeof (size_t);\n+  if ((char *) a - x != (char *) p)\n+    exit (i);\n+\n+  // Check the cookie value.\n+  size_t *sp = ((size_t *) a) - 1;\n+  if (*sp != 11)\n+    exit (i);\n+}\n+\n+struct X {};\n+\n+template <typename T>\n+struct Y { int i; virtual void f () {}; };\n+\n+// A class with a non-trivial destructor -- it needs a cookie.\n+struct Z { ~Z () {}; };\n+// Likewise, but this class needs a bigger cookie so that the array\n+// elements are correctly aligned.\n+struct Z2 { ~Z2 () {}; long double d; };\n+  \n+struct W1 { void operator delete[] (void *, size_t) {}; };\n+struct W2 { void operator delete[] (void *) {}; \n+            void operator delete[] (void *, size_t) {}; };\n+\n+struct V { void *operator new[] (size_t s, void *p) \n+             { return p; }\n+           ~V () {}\n+         };\n+   \n+int main ()\n+{\n+  // There should be no cookies for types with trivial destructors.\n+  check_no_cookie<int> (1);\n+  check_no_cookie<X> (2);\n+  check_no_cookie<Y<double> > (3);\n+\n+  // There should be no cookies for allocations using global placement\n+  // new.\n+  check_no_placement_cookie<int> (4);\n+  check_no_placement_cookie<X> (5);\n+  check_no_placement_cookie<Z> (6);\n+\n+  // There should be a cookie when using a non-trivial destructor.\n+  check_cookie<Z> (7);\n+  check_cookie<Z2> (8);\n+  \n+  // There should be a cookie when using the two-argument array delete\n+  // operator.\n+  check_cookie<W1> (9);\n+  // But not when the one-argument version is also available.\n+  check_no_cookie<W2> (10);\n+\n+  // There should be a cookie when using a non-global placement new.\n+  check_placement_cookie<V> (11);\n+}\n+\n+#else /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */\n+\n+int main () \n+{\n+}\n+\n+#endif /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */"}, {"sha": "e6483ca6402fe6654934f746337df8997dd3047a", "filename": "gcc/testsuite/g++.old-deja/g++.other/inline7.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finline7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finline7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finline7.C?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -1,4 +1,5 @@\n // Origin: Mark Mitchell <mark@codesourcery.com>\n+// Special g++ Options: -O2\n \n #include <list>\n "}, {"sha": "a59b5d2b74380b1a804fe7222961df35beefd676", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834c6dff7ba7845c7fabeda67f711b5aa0f341d8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=834c6dff7ba7845c7fabeda67f711b5aa0f341d8", "patch": "@@ -880,6 +880,10 @@ struct tree_block\n    The value is an int, measured in bits.  */\n #define TYPE_ALIGN(NODE) (TYPE_CHECK (NODE)->type.align)\n \n+/* The alignment for NODE, in bytes.  */\n+#define TYPE_ALIGN_UNIT(NODE) \\\n+  (TYPE_ALIGN (NODE) / BITS_PER_UNIT)\n+\n #define TYPE_STUB_DECL(NODE) (TREE_CHAIN (NODE))\n \n /* In a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE, it means the type"}]}