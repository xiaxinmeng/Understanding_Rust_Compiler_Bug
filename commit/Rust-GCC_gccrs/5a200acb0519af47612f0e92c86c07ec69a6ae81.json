{"sha": "5a200acb0519af47612f0e92c86c07ec69a6ae81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEyMDBhY2IwNTE5YWY0NzYxMmYwZTkyYzg2YzA3ZWM2OWE2YWU4MQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2013-09-05T12:37:29Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2013-09-05T12:37:29Z"}, "message": "arm.c (thumb2_emit_strd_push): Rewrite to use pre-decrement on initial store.\n\n\t* arm.c (thumb2_emit_strd_push): Rewrite to use pre-decrement on\n\tinitial store.\n\t* thumb2.md (thumb2_storewb_parisi): New pattern.\n\nFrom-SVN: r202279", "tree": {"sha": "7c0becb6249263e5d8d23f7c4b98af7116008f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c0becb6249263e5d8d23f7c4b98af7116008f39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a200acb0519af47612f0e92c86c07ec69a6ae81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a200acb0519af47612f0e92c86c07ec69a6ae81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a200acb0519af47612f0e92c86c07ec69a6ae81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a200acb0519af47612f0e92c86c07ec69a6ae81/comments", "author": null, "committer": null, "parents": [{"sha": "5922847b1c0a2d90468a1cc75b25b190a6035d97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5922847b1c0a2d90468a1cc75b25b190a6035d97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5922847b1c0a2d90468a1cc75b25b190a6035d97"}], "stats": {"total": 253, "additions": 158, "deletions": 95}, "files": [{"sha": "46153b7edf0d021682c3718a882e3576c5dab4b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a200acb0519af47612f0e92c86c07ec69a6ae81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a200acb0519af47612f0e92c86c07ec69a6ae81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a200acb0519af47612f0e92c86c07ec69a6ae81", "patch": "@@ -1,3 +1,9 @@\n+2013-09-05  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (thumb2_emit_strd_push): Rewrite to use pre-decrement on\n+\tinitial store.\n+\t* thumb2.md (thumb2_storewb_parisi): New pattern.\n+\n 2013-09-05  Yufeng Zhang  <yufeng.zhang@arm.com>\n \n \t* config/aarch64/aarch64-option-extensions.def: Add"}, {"sha": "db34b961016516f124c425e15e3262060bef9073", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 137, "deletions": 95, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a200acb0519af47612f0e92c86c07ec69a6ae81/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a200acb0519af47612f0e92c86c07ec69a6ae81/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5a200acb0519af47612f0e92c86c07ec69a6ae81", "patch": "@@ -16814,123 +16814,165 @@ arm_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n     }\n }\n \n-/* Generate and emit a pattern that will be recognized as STRD pattern.  If even\n-   number of registers are being pushed, multiple STRD patterns are created for\n-   all register pairs.  If odd number of registers are pushed, emit a\n-   combination of STRDs and STR for the prologue saves.  */\n+/* Generate and emit a sequence of insns equivalent to PUSH, but using\n+   STR and STRD.  If an even number of registers are being pushed, one\n+   or more STRD patterns are created for each register pair.  If an\n+   odd number of registers are pushed, emit an initial STR followed by\n+   as many STRD instructions as are needed.  This works best when the\n+   stack is initially 64-bit aligned (the normal case), since it\n+   ensures that each STRD is also 64-bit aligned.  */\n static void\n thumb2_emit_strd_push (unsigned long saved_regs_mask)\n {\n   int num_regs = 0;\n-  int i, j;\n+  int i;\n+  int regno;\n   rtx par = NULL_RTX;\n-  rtx insn = NULL_RTX;\n   rtx dwarf = NULL_RTX;\n-  rtx tmp, reg, tmp1;\n+  rtx tmp;\n+  bool first = true;\n \n-  for (i = 0; i <= LAST_ARM_REGNUM; i++)\n-    if (saved_regs_mask & (1 << i))\n-      num_regs++;\n+  num_regs = bit_count (saved_regs_mask);\n \n-  gcc_assert (num_regs && num_regs <= 16);\n+  /* Must be at least one register to save, and can't save SP or PC.  */\n+  gcc_assert (num_regs > 0 && num_regs <= 14);\n+  gcc_assert (!(saved_regs_mask & (1 << SP_REGNUM)));\n+  gcc_assert (!(saved_regs_mask & (1 << PC_REGNUM)));\n \n-  /* Pre-decrement the stack pointer, based on there being num_regs 4-byte\n-     registers to push.  */\n+  /* Create sequence for DWARF info.  All the frame-related data for\n+     debugging is held in this wrapper.  */\n+  dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (num_regs + 1));\n+\n+  /* Describe the stack adjustment.  */\n   tmp = gen_rtx_SET (VOIDmode,\n-                     stack_pointer_rtx,\n-                     plus_constant (Pmode, stack_pointer_rtx, -4 * num_regs));\n+\t\t      stack_pointer_rtx,\n+\t\t      plus_constant (Pmode, stack_pointer_rtx, -4 * num_regs));\n   RTX_FRAME_RELATED_P (tmp) = 1;\n-  insn = emit_insn (tmp);\n-\n-  /* Create sequence for DWARF info.  */\n-  dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (num_regs + 1));\n+  XVECEXP (dwarf, 0, 0) = tmp;\n \n-  /* RTLs cannot be shared, hence create new copy for dwarf.  */\n-  tmp1 = gen_rtx_SET (VOIDmode,\n-                     stack_pointer_rtx,\n-                     plus_constant (Pmode, stack_pointer_rtx, -4 * num_regs));\n-  RTX_FRAME_RELATED_P (tmp1) = 1;\n-  XVECEXP (dwarf, 0, 0) = tmp1;\n+  /* Find the first register.  */\n+  for (regno = 0; (saved_regs_mask & (1 << regno)) == 0; regno++)\n+    ;\n \n-  gcc_assert (!(saved_regs_mask & (1 << SP_REGNUM)));\n-  gcc_assert (!(saved_regs_mask & (1 << PC_REGNUM)));\n+  i = 0;\n \n-  /* Var j iterates over all the registers to gather all the registers in\n-     saved_regs_mask.  Var i gives index of register R_j in stack frame.\n-     A PARALLEL RTX of register-pair is created here, so that pattern for\n-     STRD can be matched.  If num_regs is odd, 1st register will be pushed\n-     using STR and remaining registers will be pushed with STRD in pairs.\n-     If num_regs is even, all registers are pushed with STRD in pairs.\n-     Hence, skip first element for odd num_regs.  */\n-  for (i = num_regs - 1, j = LAST_ARM_REGNUM; i >= (num_regs % 2); j--)\n-    if (saved_regs_mask & (1 << j))\n-      {\n-        /* Create RTX for store.  New RTX is created for dwarf as\n-           they are not sharable.  */\n-        reg = gen_rtx_REG (SImode, j);\n-        tmp = gen_rtx_SET (SImode,\n-                           gen_frame_mem\n-                           (SImode,\n-                            plus_constant (Pmode, stack_pointer_rtx, 4 * i)),\n-                           reg);\n-\n-        tmp1 = gen_rtx_SET (SImode,\n-                           gen_frame_mem\n-                           (SImode,\n-                            plus_constant (Pmode, stack_pointer_rtx, 4 * i)),\n-                           reg);\n-        RTX_FRAME_RELATED_P (tmp) = 1;\n-        RTX_FRAME_RELATED_P (tmp1) = 1;\n-\n-        if (((i - (num_regs % 2)) % 2) == 1)\n-          /* When (i - (num_regs % 2)) is odd, the RTX to be emitted is yet to\n-             be created.  Hence create it first.  The STRD pattern we are\n-             generating is :\n-             [ (SET (MEM (PLUS (SP) (NUM))) (reg_t1))\n-               (SET (MEM (PLUS (SP) (NUM + 4))) (reg_t2)) ]\n-             where the target registers need not be consecutive.  */\n-          par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+  /* If there's an odd number of registers to push.  Start off by\n+     pushing a single register.  This ensures that subsequent strd\n+     operations are dword aligned (assuming that SP was originally\n+     64-bit aligned).  */\n+  if ((num_regs & 1) != 0)\n+    {\n+      rtx reg, mem, insn;\n \n-        /* Register R_j is added in PARALLEL RTX.  If (i - (num_regs % 2)) is\n-           even, the reg_j is added as 0th element and if it is odd, reg_i is\n-           added as 1st element of STRD pattern shown above.  */\n-        XVECEXP (par, 0, ((i - (num_regs % 2)) % 2)) = tmp;\n-        XVECEXP (dwarf, 0, (i + 1)) = tmp1;\n+      reg = gen_rtx_REG (SImode, regno);\n+      if (num_regs == 1)\n+\tmem = gen_frame_mem (Pmode, gen_rtx_PRE_DEC (Pmode,\n+\t\t\t\t\t\t     stack_pointer_rtx));\n+      else\n+\tmem = gen_frame_mem (Pmode,\n+\t\t\t     gen_rtx_PRE_MODIFY\n+\t\t\t     (Pmode, stack_pointer_rtx,\n+\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t     -4 * num_regs)));\n \n-        if (((i - (num_regs % 2)) % 2) == 0)\n-          /* When (i - (num_regs % 2)) is even, RTXs for both the registers\n-             to be loaded are generated in above given STRD pattern, and the\n-             pattern can be emitted now.  */\n-          emit_insn (par);\n+      tmp = gen_rtx_SET (VOIDmode, mem, reg);\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      insn = emit_insn (tmp);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n+      tmp = gen_rtx_SET (VOIDmode, gen_frame_mem (Pmode, stack_pointer_rtx),\n+\t\t\t reg);\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      i++;\n+      regno++;\n+      XVECEXP (dwarf, 0, i) = tmp;\n+      first = false;\n+    }\n \n-        i--;\n-      }\n+  while (i < num_regs)\n+    if (saved_regs_mask & (1 << regno))\n+      {\n+\trtx reg1, reg2, mem1, mem2;\n+\trtx tmp0, tmp1, tmp2;\n+\tint regno2;\n \n-  if ((num_regs % 2) == 1)\n-    {\n-      /* If odd number of registers are pushed, generate STR pattern to store\n-         lone register.  */\n-      for (; (saved_regs_mask & (1 << j)) == 0; j--);\n+\t/* Find the register to pair with this one.  */\n+\tfor (regno2 = regno + 1; (saved_regs_mask & (1 << regno2)) == 0;\n+\t     regno2++)\n+\t  ;\n \n-      tmp1 = gen_frame_mem (SImode, plus_constant (Pmode,\n-                                                   stack_pointer_rtx, 4 * i));\n-      reg = gen_rtx_REG (SImode, j);\n-      tmp = gen_rtx_SET (SImode, tmp1, reg);\n-      RTX_FRAME_RELATED_P (tmp) = 1;\n+\treg1 = gen_rtx_REG (SImode, regno);\n+\treg2 = gen_rtx_REG (SImode, regno2);\n \n-      emit_insn (tmp);\n+\tif (first)\n+\t  {\n+\t    rtx insn;\n+\n+\t    first = false;\n+\t    mem1 = gen_frame_mem (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\t\t-4 * num_regs));\n+\t    mem2 = gen_frame_mem (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\t\t-4 * (num_regs - 1)));\n+\t    tmp0 = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\tplus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t       -4 * (num_regs)));\n+\t    tmp1 = gen_rtx_SET (VOIDmode, mem1, reg1);\n+\t    tmp2 = gen_rtx_SET (VOIDmode, mem2, reg2);\n+\t    RTX_FRAME_RELATED_P (tmp0) = 1;\n+\t    RTX_FRAME_RELATED_P (tmp1) = 1;\n+\t    RTX_FRAME_RELATED_P (tmp2) = 1;\n+\t    par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (3));\n+\t    XVECEXP (par, 0, 0) = tmp0;\n+\t    XVECEXP (par, 0, 1) = tmp1;\n+\t    XVECEXP (par, 0, 2) = tmp2;\n+\t    insn = emit_insn (par);\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t    add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n+\t  }\n+\telse\n+\t  {\n+\t    mem1 = gen_frame_mem (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\t\t4 * i));\n+\t    mem2 = gen_frame_mem (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\t\t4 * (i + 1)));\n+\t    tmp1 = gen_rtx_SET (VOIDmode, mem1, reg1);\n+\t    tmp2 = gen_rtx_SET (VOIDmode, mem2, reg2);\n+\t    RTX_FRAME_RELATED_P (tmp1) = 1;\n+\t    RTX_FRAME_RELATED_P (tmp2) = 1;\n+\t    par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+\t    XVECEXP (par, 0, 0) = tmp1;\n+\t    XVECEXP (par, 0, 1) = tmp2;\n+\t    emit_insn (par);\n+\t  }\n \n-      tmp1 = gen_rtx_SET (SImode,\n-                         gen_frame_mem\n-                         (SImode,\n-                          plus_constant (Pmode, stack_pointer_rtx, 4 * i)),\n-                          reg);\n-      RTX_FRAME_RELATED_P (tmp1) = 1;\n-      XVECEXP (dwarf, 0, (i + 1)) = tmp1;\n-    }\n+\t/* Create unwind information.  This is an approximation.  */\n+\ttmp1 = gen_rtx_SET (VOIDmode,\n+\t\t\t    gen_frame_mem (Pmode,\n+\t\t\t\t\t   plus_constant (Pmode,\n+\t\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t\t  4 * i)),\n+\t\t\t    reg1);\n+\ttmp2 = gen_rtx_SET (VOIDmode,\n+\t\t\t    gen_frame_mem (Pmode,\n+\t\t\t\t\t   plus_constant (Pmode,\n+\t\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t\t  4 * (i + 1))),\n+\t\t\t    reg2);\n+\n+\tRTX_FRAME_RELATED_P (tmp1) = 1;\n+\tRTX_FRAME_RELATED_P (tmp2) = 1;\n+\tXVECEXP (dwarf, 0, i + 1) = tmp1;\n+\tXVECEXP (dwarf, 0, i + 2) = tmp2;\n+\ti += 2;\n+\tregno = regno2 + 1;\n+      }\n+    else\n+      regno++;\n \n-  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n-  RTX_FRAME_RELATED_P (insn) = 1;\n   return;\n }\n "}, {"sha": "ab46658edc046055e3cc3398fcdc88b321ae4235", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a200acb0519af47612f0e92c86c07ec69a6ae81/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a200acb0519af47612f0e92c86c07ec69a6ae81/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=5a200acb0519af47612f0e92c86c07ec69a6ae81", "patch": "@@ -325,6 +325,21 @@\n    (set_attr \"neg_pool_range\" \"*,*,*,250\")]\n )\n \n+(define_insn \"*thumb2_storewb_pairsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&kr\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))\n+   (set (mem:SI (plus:SI (match_dup 0) (match_dup 2)))\n+\t(match_operand:SI 3 \"register_operand\" \"r\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 5 \"const_int_operand\" \"n\")))\n+\t(match_operand:SI 4 \"register_operand\" \"r\"))]\n+  \"TARGET_THUMB2\n+   && INTVAL (operands[5]) == INTVAL (operands[2]) + 4\"\n+  \"strd\\\\t%3, %4, [%0, %2]!\"\n+  [(set_attr \"type\" \"store2\")]\n+)\n+\n (define_insn \"*thumb2_cmpsi_neg_shiftsi\"\n   [(set (reg:CC CC_REGNUM)\n \t(compare:CC (match_operand:SI 0 \"s_register_operand\" \"r\")"}]}