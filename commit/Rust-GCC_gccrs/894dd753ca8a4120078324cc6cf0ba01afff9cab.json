{"sha": "894dd753ca8a4120078324cc6cf0ba01afff9cab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk0ZGQ3NTNjYThhNDEyMDA3ODMyNGNjNmNmMGJhMDFhZmZmOWNhYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-06-30T12:46:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-06-30T12:46:36Z"}, "message": "[9a/n] PR85694: Reorder vect_is_simple_use arguments\n\nAs suggested by Richard B., this patch reorders the arguments to\nvect_is_simple_use so that def_stmt comes last and is optional.\nMany callers can then drop it, making it more obvious which of\nthe remaining calls would be affected by the next patch.\n\n2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vect_is_simple_use): Move the gimple ** to the\n\tend and default to null.\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction)\n\t(vectorizable_reduction): Update calls accordingly, dropping the\n\tgimple ** argument if the passed-back statement isn't needed.\n\t* tree-vect-patterns.c (vect_get_internal_def, type_conversion_p)\n\t(vect_recog_rotate_pattern): Likewise.\n\t(vect_recog_mask_conversion_pattern): Likewise.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Likewise.\n\t(vect_mask_constant_operand_p): Likewise.\n\t* tree-vect-stmts.c (is_simple_and_all_uses_invariant, process_use):\n\t(vect_model_simple_cost, vect_get_vec_def_for_operand): Likewise.\n\t(get_group_load_store_type, get_load_store_type): Likewise.\n\t(vect_check_load_store_mask, vect_check_store_rhs): Likewise.\n\t(vectorizable_call, vectorizable_simd_clone_call): Likewise.\n\t(vectorizable_conversion, vectorizable_assignment): Likewise.\n\t(vectorizable_shift, vectorizable_operation): Likewise.\n\t(vectorizable_store, vect_is_simple_cond): Likewise.\n\t(vectorizable_condition, vectorizable_comparison): Likewise.\n\t(get_same_sized_vectype, vect_get_mask_type_for_stmt): Likewise.\n\t(vect_is_simple_use): Rename the def_stmt argument to def_stmt_out\n\tand move it to the end.  Cope with null def_stmt_outs.\n\nFrom-SVN: r262272", "tree": {"sha": "52c54a7be96f86a3a5ec9e0e2a90772eb9d86ef5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52c54a7be96f86a3a5ec9e0e2a90772eb9d86ef5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/894dd753ca8a4120078324cc6cf0ba01afff9cab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894dd753ca8a4120078324cc6cf0ba01afff9cab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/894dd753ca8a4120078324cc6cf0ba01afff9cab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894dd753ca8a4120078324cc6cf0ba01afff9cab/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "55c8e04cb125e84e493b37ab66074e2d2f2dd889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55c8e04cb125e84e493b37ab66074e2d2f2dd889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55c8e04cb125e84e493b37ab66074e2d2f2dd889"}], "stats": {"total": 197, "additions": 95, "deletions": 102}, "files": [{"sha": "528bc4bde5c8b749990fc8e0d3ffc759ebdb6c30", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=894dd753ca8a4120078324cc6cf0ba01afff9cab", "patch": "@@ -1,3 +1,28 @@\n+2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vect_is_simple_use): Move the gimple ** to the\n+\tend and default to null.\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction)\n+\t(vectorizable_reduction): Update calls accordingly, dropping the\n+\tgimple ** argument if the passed-back statement isn't needed.\n+\t* tree-vect-patterns.c (vect_get_internal_def, type_conversion_p)\n+\t(vect_recog_rotate_pattern): Likewise.\n+\t(vect_recog_mask_conversion_pattern): Likewise.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Likewise.\n+\t(vect_mask_constant_operand_p): Likewise.\n+\t* tree-vect-stmts.c (is_simple_and_all_uses_invariant, process_use):\n+\t(vect_model_simple_cost, vect_get_vec_def_for_operand): Likewise.\n+\t(get_group_load_store_type, get_load_store_type): Likewise.\n+\t(vect_check_load_store_mask, vect_check_store_rhs): Likewise.\n+\t(vectorizable_call, vectorizable_simd_clone_call): Likewise.\n+\t(vectorizable_conversion, vectorizable_assignment): Likewise.\n+\t(vectorizable_shift, vectorizable_operation): Likewise.\n+\t(vectorizable_store, vect_is_simple_cond): Likewise.\n+\t(vectorizable_condition, vectorizable_comparison): Likewise.\n+\t(get_same_sized_vectype, vect_get_mask_type_for_stmt): Likewise.\n+\t(vect_is_simple_use): Rename the def_stmt argument to def_stmt_out\n+\tand move it to the end.  Cope with null def_stmt_outs.\n+\n 2018-06-30  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \t* Makefile.in (FLAGS_TO_PASS): Add RANLIB_FOR_TARGET."}, {"sha": "73a1a8f027c2ec2bbcdc919d86a34bb23e62ee8a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=894dd753ca8a4120078324cc6cf0ba01afff9cab", "patch": "@@ -4572,7 +4572,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n     {\n       /* Get at the scalar def before the loop, that defines the initial value\n \t of the reduction variable.  */\n-      gimple *def_stmt;\n       initial_def = PHI_ARG_DEF_FROM_EDGE (reduc_def_stmt,\n \t\t\t\t\t   loop_preheader_edge (loop));\n       /* Optimize: if initial_def is for REDUC_MAX smaller than the base\n@@ -4587,7 +4586,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t      || (induc_code == MIN_EXPR\n \t\t  && tree_int_cst_lt (induc_val, initial_def))))\n \tinduc_val = initial_def;\n-      vect_is_simple_use (initial_def, loop_vinfo, &def_stmt, &initial_def_dt);\n+      vect_is_simple_use (initial_def, loop_vinfo, &initial_def_dt);\n       vec_initial_def = get_initial_def_for_reduction (stmt, initial_def,\n \t\t\t\t\t\t       &adjustment_def);\n       vec_initial_defs.create (1);\n@@ -6396,7 +6395,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n         continue;\n \n       is_simple_use = vect_is_simple_use (ops[i], loop_vinfo,\n-\t\t\t\t\t  &def_stmt, &dts[i], &tem);\n+\t\t\t\t\t  &dts[i], &tem, &def_stmt);\n       dt = dts[i];\n       gcc_assert (is_simple_use);\n       if (dt == vect_reduction_def)\n@@ -6592,8 +6591,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    = PHI_ARG_DEF_FROM_EDGE (def_stmt, loop_preheader_edge (loop));\n \n \t  gcc_assert (cond_reduc_val != NULL_TREE);\n-\t  vect_is_simple_use (cond_initial_val, loop_vinfo,\n-\t\t\t      &def_stmt, &cond_initial_dt);\n+\t  vect_is_simple_use (cond_initial_val, loop_vinfo, &cond_initial_dt);\n \t  if (cond_initial_dt == vect_constant_def\n \t      && types_compatible_p (TREE_TYPE (cond_initial_val),\n \t\t\t\t     TREE_TYPE (cond_reduc_val)))"}, {"sha": "6fb07fd1265784f71869e22c29ada73c8261baad", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=894dd753ca8a4120078324cc6cf0ba01afff9cab", "patch": "@@ -160,7 +160,7 @@ vect_get_internal_def (vec_info *vinfo, tree op)\n   vect_def_type dt;\n   gimple *def_stmt;\n   if (TREE_CODE (op) != SSA_NAME\n-      || !vect_is_simple_use (op, vinfo, &def_stmt, &dt)\n+      || !vect_is_simple_use (op, vinfo, &dt, &def_stmt)\n       || dt != vect_internal_def)\n     return NULL;\n \n@@ -177,14 +177,13 @@ static bool\n type_conversion_p (tree name, gimple *use_stmt, bool check_sign,\n \t\t   tree *orig_type, gimple **def_stmt, bool *promotion)\n {\n-  gimple *dummy_gimple;\n   stmt_vec_info stmt_vinfo;\n   tree type = TREE_TYPE (name);\n   tree oprnd0;\n   enum vect_def_type dt;\n \n   stmt_vinfo = vinfo_for_stmt (use_stmt);\n-  if (!vect_is_simple_use (name, stmt_vinfo->vinfo, def_stmt, &dt))\n+  if (!vect_is_simple_use (name, stmt_vinfo->vinfo, &dt, def_stmt))\n     return false;\n \n   if (dt != vect_internal_def\n@@ -219,7 +218,7 @@ type_conversion_p (tree name, gimple *use_stmt, bool check_sign,\n   else\n     *promotion = false;\n \n-  if (!vect_is_simple_use (oprnd0, stmt_vinfo->vinfo, &dummy_gimple, &dt))\n+  if (!vect_is_simple_use (oprnd0, stmt_vinfo->vinfo, &dt))\n     return false;\n \n   return true;\n@@ -1795,7 +1794,7 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_out)\n       || !TYPE_UNSIGNED (type))\n     return NULL;\n \n-  if (!vect_is_simple_use (oprnd1, vinfo, &def_stmt, &dt))\n+  if (!vect_is_simple_use (oprnd1, vinfo, &dt, &def_stmt))\n     return NULL;\n \n   if (dt != vect_internal_def\n@@ -3930,13 +3929,10 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_out)\n \t  && known_le (TYPE_VECTOR_SUBPARTS (vectype1),\n \t\t       TYPE_VECTOR_SUBPARTS (vectype2)))\n \t{\n-\t  gimple *dummy;\n \t  enum vect_def_type dt;\n-\t  if (vect_is_simple_use (TREE_OPERAND (rhs1, 0), stmt_vinfo->vinfo,\n-\t\t\t\t  &dummy, &dt)\n+\t  if (vect_is_simple_use (TREE_OPERAND (rhs1, 0), vinfo, &dt)\n \t      && dt == vect_external_def\n-\t      && vect_is_simple_use (TREE_OPERAND (rhs1, 1), stmt_vinfo->vinfo,\n-\t\t\t\t     &dummy, &dt)\n+\t      && vect_is_simple_use (TREE_OPERAND (rhs1, 1), vinfo, &dt)\n \t      && (dt == vect_external_def\n \t\t  || dt == vect_constant_def))\n \t    {"}, {"sha": "573ed76f6546f1ff1b066e73e4ead4ad1e377118", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=894dd753ca8a4120078324cc6cf0ba01afff9cab", "patch": "@@ -348,7 +348,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \n       oprnd_info = (*oprnds_info)[i];\n \n-      if (!vect_is_simple_use (oprnd, vinfo, &def_stmt, &dt))\n+      if (!vect_is_simple_use (oprnd, vinfo, &dt, &def_stmt))\n \t{\n \t  if (dump_enabled_p ())\n \t    {\n@@ -3105,7 +3105,6 @@ vect_mask_constant_operand_p (gimple *stmt, int opnum)\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   enum tree_code code = gimple_expr_code (stmt);\n   tree op, vectype;\n-  gimple *def_stmt;\n   enum vect_def_type dt;\n \n   /* For comparison and COND_EXPR type is chosen depending\n@@ -3117,8 +3116,7 @@ vect_mask_constant_operand_p (gimple *stmt, int opnum)\n       else\n \top = gimple_assign_rhs2 (stmt);\n \n-      if (!vect_is_simple_use (op, stmt_vinfo->vinfo, &def_stmt,\n-\t\t\t       &dt, &vectype))\n+      if (!vect_is_simple_use (op, stmt_vinfo->vinfo, &dt, &vectype))\n \tgcc_unreachable ();\n \n       return !vectype || VECTOR_BOOLEAN_TYPE_P (vectype);\n@@ -3135,8 +3133,7 @@ vect_mask_constant_operand_p (gimple *stmt, int opnum)\n       else\n \top = TREE_OPERAND (cond, 0);\n \n-      if (!vect_is_simple_use (op, stmt_vinfo->vinfo, &def_stmt,\n-\t\t\t       &dt, &vectype))\n+      if (!vect_is_simple_use (op, stmt_vinfo->vinfo, &dt, &vectype))\n \tgcc_unreachable ();\n \n       return !vectype || VECTOR_BOOLEAN_TYPE_P (vectype);"}, {"sha": "c1c5410d46bb55d847cea1a60334794c150b2f2b", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 54, "deletions": 77, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=894dd753ca8a4120078324cc6cf0ba01afff9cab", "patch": "@@ -260,7 +260,6 @@ bool\n is_simple_and_all_uses_invariant (gimple *stmt, loop_vec_info loop_vinfo)\n {\n   tree op;\n-  gimple *def_stmt;\n   ssa_op_iter iter;\n \n   if (!is_gimple_assign (stmt))\n@@ -270,7 +269,7 @@ is_simple_and_all_uses_invariant (gimple *stmt, loop_vec_info loop_vinfo)\n     {\n       enum vect_def_type dt = vect_uninitialized_def;\n \n-      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &dt))\n+      if (!vect_is_simple_use (op, loop_vinfo, &dt))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -472,7 +471,7 @@ process_use (gimple *stmt, tree use, loop_vec_info loop_vinfo,\n   if (!force && !exist_non_indexing_operands_for_use_p (use, stmt))\n      return true;\n \n-  if (!vect_is_simple_use (use, loop_vinfo, &def_stmt, &dt))\n+  if (!vect_is_simple_use (use, loop_vinfo, &dt, &def_stmt))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -908,11 +907,10 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n       for (unsigned i = 0; i < gimple_num_ops (stmt); ++i)\n \t{\n \t  tree op = gimple_op (stmt, i);\n-\t  gimple *def_stmt;\n \t  enum vect_def_type dt;\n \t  if (!op || op == lhs)\n \t    continue;\n-\t  if (vect_is_simple_use (op, stmt_info->vinfo, &def_stmt, &dt)\n+\t  if (vect_is_simple_use (op, stmt_info->vinfo, &dt)\n \t      && (dt == vect_constant_def || dt == vect_external_def))\n \t    prologue_cost += vect_prologue_cost_for_slp_op (node, stmt_info,\n \t\t\t\t\t\t\t    i, dt, cost_vec);\n@@ -1567,7 +1565,7 @@ vect_get_vec_def_for_operand (tree op, gimple *stmt, tree vectype)\n       dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n-  is_simple_use = vect_is_simple_use (op, loop_vinfo, &def_stmt, &dt);\n+  is_simple_use = vect_is_simple_use (op, loop_vinfo, &dt, &def_stmt);\n   gcc_assert (is_simple_use);\n   if (def_stmt && dump_enabled_p ())\n     {\n@@ -2336,9 +2334,8 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n       while (next_stmt)\n \t{\n \t  tree op = vect_get_store_rhs (next_stmt);\n-\t  gimple *def_stmt;\n \t  enum vect_def_type dt;\n-\t  if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt))\n+\t  if (!vect_is_simple_use (op, vinfo, &dt))\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2436,10 +2433,9 @@ get_load_store_type (gimple *stmt, tree vectype, bool slp, bool masked_p,\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       *memory_access_type = VMAT_GATHER_SCATTER;\n-      gimple *def_stmt;\n       if (!vect_check_gather_scatter (stmt, loop_vinfo, gs_info))\n \tgcc_unreachable ();\n-      else if (!vect_is_simple_use (gs_info->offset, vinfo, &def_stmt,\n+      else if (!vect_is_simple_use (gs_info->offset, vinfo,\n \t\t\t\t    &gs_info->offset_dt,\n \t\t\t\t    &gs_info->offset_vectype))\n \t{\n@@ -2536,11 +2532,9 @@ vect_check_load_store_mask (gimple *stmt, tree mask,\n     }\n \n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  gimple *def_stmt;\n   enum vect_def_type mask_dt;\n   tree mask_vectype;\n-  if (!vect_is_simple_use (mask, stmt_info->vinfo, &def_stmt, &mask_dt,\n-\t\t\t   &mask_vectype))\n+  if (!vect_is_simple_use (mask, stmt_info->vinfo, &mask_dt, &mask_vectype))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2601,11 +2595,9 @@ vect_check_store_rhs (gimple *stmt, tree rhs, vect_def_type *rhs_dt_out,\n     }\n \n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  gimple *def_stmt;\n   enum vect_def_type rhs_dt;\n   tree rhs_vectype;\n-  if (!vect_is_simple_use (rhs, stmt_info->vinfo, &def_stmt, &rhs_dt,\n-\t\t\t   &rhs_vectype))\n+  if (!vect_is_simple_use (rhs, stmt_info->vinfo, &rhs_dt, &rhs_vectype))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -3136,7 +3128,6 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   vec_info *vinfo = stmt_info->vinfo;\n   tree fndecl, new_temp, rhs_type;\n-  gimple *def_stmt;\n   enum vect_def_type dt[3]\n     = {vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type};\n   int ndts = 3;\n@@ -3210,7 +3201,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       if (!rhs_type)\n \trhs_type = TREE_TYPE (op);\n \n-      if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt[i], &opvectype))\n+      if (!vect_is_simple_use (op, vinfo, &dt[i], &opvectype))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -3731,7 +3722,6 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n   vec_info *vinfo = stmt_info->vinfo;\n   struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n   tree fndecl, new_temp;\n-  gimple *def_stmt;\n   gimple *new_stmt = NULL;\n   int ncopies, j;\n   auto_vec<simd_call_arg_info> arginfo;\n@@ -3794,7 +3784,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n       thisarginfo.simd_lane_linear = false;\n \n       op = gimple_call_arg (stmt, i);\n-      if (!vect_is_simple_use (op, vinfo, &def_stmt, &thisarginfo.dt,\n+      if (!vect_is_simple_use (op, vinfo, &thisarginfo.dt,\n \t\t\t       &thisarginfo.vectype)\n \t  || thisarginfo.dt == vect_uninitialized_def)\n \t{\n@@ -4575,7 +4565,6 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n   enum tree_code codecvt1 = ERROR_MARK, codecvt2 = ERROR_MARK;\n   tree decl1 = NULL_TREE, decl2 = NULL_TREE;\n   tree new_temp;\n-  gimple *def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   int ndts = 2;\n   gimple *new_stmt = NULL;\n@@ -4651,7 +4640,7 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use (op0, vinfo, &def_stmt, &dt[0], &vectype_in))\n+  if (!vect_is_simple_use (op0, vinfo, &dt[0], &vectype_in))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -4667,9 +4656,9 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n       /* For WIDEN_MULT_EXPR, if OP0 is a constant, use the type of\n \t OP1.  */\n       if (CONSTANT_CLASS_P (op0))\n-\tok = vect_is_simple_use (op1, vinfo, &def_stmt, &dt[1], &vectype_in);\n+\tok = vect_is_simple_use (op1, vinfo, &dt[1], &vectype_in);\n       else\n-\tok = vect_is_simple_use (op1, vinfo, &def_stmt, &dt[1]);\n+\tok = vect_is_simple_use (op1, vinfo, &dt[1]);\n \n       if (!ok)\n \t{\n@@ -5171,7 +5160,6 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree new_temp;\n-  gimple *def_stmt;\n   enum vect_def_type dt[1] = {vect_unknown_def_type};\n   int ndts = 1;\n   int ncopies;\n@@ -5224,7 +5212,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   gcc_assert (ncopies >= 1);\n \n-  if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt[0], &vectype_in))\n+  if (!vect_is_simple_use (op, vinfo, &dt[0], &vectype_in))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5380,7 +5368,6 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n   optab optab;\n   int icode;\n   machine_mode optab_op2_mode;\n-  gimple *def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   int ndts = 2;\n   gimple *new_stmt = NULL;\n@@ -5430,7 +5417,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use (op0, vinfo, &def_stmt, &dt[0], &vectype))\n+  if (!vect_is_simple_use (op0, vinfo, &dt[0], &vectype))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5457,7 +5444,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   op1 = gimple_assign_rhs2 (stmt);\n-  if (!vect_is_simple_use (op1, vinfo, &def_stmt, &dt[1], &op1_vectype))\n+  if (!vect_is_simple_use (op1, vinfo, &dt[1], &op1_vectype))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5746,7 +5733,6 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   int op_type;\n   optab optab;\n   bool target_support_p;\n-  gimple *def_stmt;\n   enum vect_def_type dt[3]\n     = {vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type};\n   int ndts = 3;\n@@ -5817,7 +5803,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use (op0, vinfo, &def_stmt, &dt[0], &vectype))\n+  if (!vect_is_simple_use (op0, vinfo, &dt[0], &vectype))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5871,7 +5857,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (op_type == binary_op || op_type == ternary_op)\n     {\n       op1 = gimple_assign_rhs2 (stmt);\n-      if (!vect_is_simple_use (op1, vinfo, &def_stmt, &dt[1]))\n+      if (!vect_is_simple_use (op1, vinfo, &dt[1]))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5882,7 +5868,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (op_type == ternary_op)\n     {\n       op2 = gimple_assign_rhs3 (stmt);\n-      if (!vect_is_simple_use (op2, vinfo, &def_stmt, &dt[2]))\n+      if (!vect_is_simple_use (op2, vinfo, &dt[2]))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6196,7 +6182,6 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   machine_mode vec_mode;\n   tree dummy;\n   enum dr_alignment_support alignment_support_scheme;\n-  gimple *def_stmt;\n   enum vect_def_type rhs_dt = vect_unknown_def_type;\n   enum vect_def_type mask_dt = vect_unknown_def_type;\n   stmt_vec_info prev_stmt_info = NULL;\n@@ -6757,7 +6742,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    vec_oprnd = vec_oprnds[j];\n \t\t  else\n \t\t    {\n-\t\t      vect_is_simple_use (op, vinfo, &def_stmt, &rhs_dt);\n+\t\t      vect_is_simple_use (op, vinfo, &rhs_dt);\n \t\t      vec_oprnd = vect_get_vec_def_for_stmt_copy (rhs_dt,\n \t\t\t\t\t\t\t\t  vec_oprnd);\n \t\t    }\n@@ -7003,7 +6988,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  for (i = 0; i < group_size; i++)\n \t    {\n \t      op = oprnds[i];\n-\t      vect_is_simple_use (op, vinfo, &def_stmt, &rhs_dt);\n+\t      vect_is_simple_use (op, vinfo, &rhs_dt);\n \t      vec_oprnd = vect_get_vec_def_for_stmt_copy (rhs_dt, op);\n \t      dr_chain[i] = vec_oprnd;\n \t      oprnds[i] = vec_oprnd;\n@@ -8588,9 +8573,7 @@ vect_is_simple_cond (tree cond, vec_info *vinfo,\n   if (TREE_CODE (cond) == SSA_NAME\n       && VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (cond)))\n     {\n-      gimple *lhs_def_stmt = SSA_NAME_DEF_STMT (cond);\n-      if (!vect_is_simple_use (cond, vinfo, &lhs_def_stmt,\n-\t\t\t       &dts[0], comp_vectype)\n+      if (!vect_is_simple_use (cond, vinfo, &dts[0], comp_vectype)\n \t  || !*comp_vectype\n \t  || !VECTOR_BOOLEAN_TYPE_P (*comp_vectype))\n \treturn false;\n@@ -8605,8 +8588,7 @@ vect_is_simple_cond (tree cond, vec_info *vinfo,\n \n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n-      gimple *lhs_def_stmt = SSA_NAME_DEF_STMT (lhs);\n-      if (!vect_is_simple_use (lhs, vinfo, &lhs_def_stmt, &dts[0], &vectype1))\n+      if (!vect_is_simple_use (lhs, vinfo, &dts[0], &vectype1))\n \treturn false;\n     }\n   else if (TREE_CODE (lhs) == INTEGER_CST || TREE_CODE (lhs) == REAL_CST\n@@ -8617,8 +8599,7 @@ vect_is_simple_cond (tree cond, vec_info *vinfo,\n \n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n-      gimple *rhs_def_stmt = SSA_NAME_DEF_STMT (rhs);\n-      if (!vect_is_simple_use (rhs, vinfo, &rhs_def_stmt, &dts[1], &vectype2))\n+      if (!vect_is_simple_use (rhs, vinfo, &dts[1], &vectype2))\n \treturn false;\n     }\n   else if (TREE_CODE (rhs) == INTEGER_CST || TREE_CODE (rhs) == REAL_CST\n@@ -8750,12 +8731,9 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n       || !comp_vectype)\n     return false;\n \n-  gimple *def_stmt;\n-  if (!vect_is_simple_use (then_clause, stmt_info->vinfo, &def_stmt, &dts[2],\n-\t\t\t   &vectype1))\n+  if (!vect_is_simple_use (then_clause, stmt_info->vinfo, &dts[2], &vectype1))\n     return false;\n-  if (!vect_is_simple_use (else_clause, stmt_info->vinfo, &def_stmt, &dts[3],\n-\t\t\t   &vectype2))\n+  if (!vect_is_simple_use (else_clause, stmt_info->vinfo, &dts[3], &vectype2))\n     return false;\n \n   if (vectype1 && !useless_type_conversion_p (vectype, vectype1))\n@@ -8892,43 +8870,40 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n             }\n           else\n             {\n-\t      gimple *gtemp;\n \t      if (masked)\n \t\t{\n \t\t  vec_cond_lhs\n \t\t    = vect_get_vec_def_for_operand (cond_expr, stmt,\n \t\t\t\t\t\t    comp_vectype);\n-\t\t  vect_is_simple_use (cond_expr, stmt_info->vinfo,\n-\t\t\t\t      &gtemp, &dts[0]);\n+\t\t  vect_is_simple_use (cond_expr, stmt_info->vinfo, &dts[0]);\n \t\t}\n \t      else\n \t\t{\n \t\t  vec_cond_lhs\n \t\t    = vect_get_vec_def_for_operand (cond_expr0,\n \t\t\t\t\t\t    stmt, comp_vectype);\n-\t\t  vect_is_simple_use (cond_expr0, loop_vinfo, &gtemp, &dts[0]);\n+\t\t  vect_is_simple_use (cond_expr0, loop_vinfo, &dts[0]);\n \n \t\t  vec_cond_rhs\n \t\t    = vect_get_vec_def_for_operand (cond_expr1,\n \t\t\t\t\t\t    stmt, comp_vectype);\n-\t\t  vect_is_simple_use (cond_expr1, loop_vinfo, &gtemp, &dts[1]);\n+\t\t  vect_is_simple_use (cond_expr1, loop_vinfo, &dts[1]);\n \t\t}\n \t      if (reduc_index == 1)\n \t\tvec_then_clause = reduc_def;\n \t      else\n \t\t{\n \t\t  vec_then_clause = vect_get_vec_def_for_operand (then_clause,\n \t\t\t\t\t\t\t\t  stmt);\n-\t          vect_is_simple_use (then_clause, loop_vinfo,\n-\t\t\t\t      &gtemp, &dts[2]);\n+\t\t  vect_is_simple_use (then_clause, loop_vinfo, &dts[2]);\n \t\t}\n \t      if (reduc_index == 2)\n \t\tvec_else_clause = reduc_def;\n \t      else\n \t\t{\n \t\t  vec_else_clause = vect_get_vec_def_for_operand (else_clause,\n \t\t\t\t\t\t\t\t  stmt);\n-\t\t  vect_is_simple_use (else_clause, loop_vinfo, &gtemp, &dts[3]);\n+\t\t  vect_is_simple_use (else_clause, loop_vinfo, &dts[3]);\n \t\t}\n \t    }\n \t}\n@@ -9089,7 +9064,6 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   vec<tree> vec_oprnds0 = vNULL;\n   vec<tree> vec_oprnds1 = vNULL;\n-  gimple *def_stmt;\n   tree mask_type;\n   tree mask;\n \n@@ -9132,12 +9106,10 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n   rhs1 = gimple_assign_rhs1 (stmt);\n   rhs2 = gimple_assign_rhs2 (stmt);\n \n-  if (!vect_is_simple_use (rhs1, stmt_info->vinfo, &def_stmt,\n-\t\t\t   &dts[0], &vectype1))\n+  if (!vect_is_simple_use (rhs1, stmt_info->vinfo, &dts[0], &vectype1))\n     return false;\n \n-  if (!vect_is_simple_use (rhs2, stmt_info->vinfo, &def_stmt,\n-\t\t\t   &dts[1], &vectype2))\n+  if (!vect_is_simple_use (rhs2, stmt_info->vinfo, &dts[1], &vectype2))\n     return false;\n \n   if (vectype1 && vectype2\n@@ -10043,7 +10015,7 @@ get_same_sized_vectype (tree scalar_type, tree vector_type)\n    VINFO - the vect info of the loop or basic block that is being vectorized.\n    OPERAND - operand in the loop or bb.\n    Output:\n-   DEF_STMT - the defining stmt in case OPERAND is an SSA_NAME.\n+   DEF_STMT_OUT (optional) - the defining stmt in case OPERAND is an SSA_NAME.\n    DT - the type of definition\n \n    Returns whether a stmt with OPERAND can be vectorized.\n@@ -10055,10 +10027,11 @@ get_same_sized_vectype (tree scalar_type, tree vector_type)\n    For now, operands defined outside the basic block are not supported.  */\n \n bool\n-vect_is_simple_use (tree operand, vec_info *vinfo,\n-                    gimple **def_stmt, enum vect_def_type *dt)\n+vect_is_simple_use (tree operand, vec_info *vinfo, enum vect_def_type *dt,\n+\t\t    gimple **def_stmt_out)\n {\n-  *def_stmt = NULL;\n+  if (def_stmt_out)\n+    *def_stmt_out = NULL;\n   *dt = vect_unknown_def_type;\n \n   if (dump_enabled_p ())\n@@ -10095,18 +10068,20 @@ vect_is_simple_use (tree operand, vec_info *vinfo,\n       return true;\n     }\n \n-  *def_stmt = SSA_NAME_DEF_STMT (operand);\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (operand);\n+  if (def_stmt_out)\n+    *def_stmt_out = def_stmt;\n   if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"def_stmt: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, *def_stmt, 0);\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt, 0);\n     }\n \n-  if (! vect_stmt_in_region_p (vinfo, *def_stmt))\n+  if (! vect_stmt_in_region_p (vinfo, def_stmt))\n     *dt = vect_external_def;\n   else\n     {\n-      stmt_vec_info stmt_vinfo = vinfo_for_stmt (*def_stmt);\n+      stmt_vec_info stmt_vinfo = vinfo_for_stmt (def_stmt);\n       *dt = STMT_VINFO_DEF_TYPE (stmt_vinfo);\n     }\n \n@@ -10153,7 +10128,7 @@ vect_is_simple_use (tree operand, vec_info *vinfo,\n       return false;\n     }\n \n-  switch (gimple_code (*def_stmt))\n+  switch (gimple_code (def_stmt))\n     {\n     case GIMPLE_PHI:\n     case GIMPLE_ASSIGN:\n@@ -10179,12 +10154,16 @@ vect_is_simple_use (tree operand, vec_info *vinfo,\n    scalar operand.  */\n \n bool\n-vect_is_simple_use (tree operand, vec_info *vinfo,\n-\t\t    gimple **def_stmt, enum vect_def_type *dt, tree *vectype)\n+vect_is_simple_use (tree operand, vec_info *vinfo, enum vect_def_type *dt,\n+\t\t    tree *vectype, gimple **def_stmt_out)\n {\n-  if (!vect_is_simple_use (operand, vinfo, def_stmt, dt))\n+  gimple *def_stmt;\n+  if (!vect_is_simple_use (operand, vinfo, dt, &def_stmt))\n     return false;\n \n+  if (def_stmt_out)\n+    *def_stmt_out = def_stmt;\n+\n   /* Now get a vector type if the def is internal, otherwise supply\n      NULL_TREE and leave it up to the caller to figure out a proper\n      type for the use stmt.  */\n@@ -10194,7 +10173,7 @@ vect_is_simple_use (tree operand, vec_info *vinfo,\n       || *dt == vect_double_reduction_def\n       || *dt == vect_nested_cycle)\n     {\n-      stmt_vec_info stmt_info = vinfo_for_stmt (*def_stmt);\n+      stmt_vec_info stmt_info = vinfo_for_stmt (def_stmt);\n \n       if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n           && !STMT_VINFO_RELEVANT (stmt_info)\n@@ -10869,13 +10848,11 @@ vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n     {\n       tree rhs;\n       ssa_op_iter iter;\n-      gimple *def_stmt;\n       enum vect_def_type dt;\n \n       FOR_EACH_SSA_TREE_OPERAND (rhs, stmt, iter, SSA_OP_USE)\n \t{\n-\t  if (!vect_is_simple_use (rhs, stmt_info->vinfo,\n-\t\t\t\t   &def_stmt, &dt, &vectype))\n+\t  if (!vect_is_simple_use (rhs, stmt_info->vinfo, &dt, &vectype))\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{"}, {"sha": "2dac54e3e3275f0fbf7e0bf39e4e4427de36c0de", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894dd753ca8a4120078324cc6cf0ba01afff9cab/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=894dd753ca8a4120078324cc6cf0ba01afff9cab", "patch": "@@ -1477,10 +1477,10 @@ extern tree get_vectype_for_scalar_type_and_size (tree, poly_uint64);\n extern tree get_mask_type_for_scalar_type (tree);\n extern tree get_same_sized_vectype (tree, tree);\n extern bool vect_get_loop_mask_type (loop_vec_info);\n-extern bool vect_is_simple_use (tree, vec_info *, gimple **,\n-                                enum vect_def_type *);\n-extern bool vect_is_simple_use (tree, vec_info *, gimple **,\n-\t\t\t\tenum vect_def_type *, tree *);\n+extern bool vect_is_simple_use (tree, vec_info *, enum vect_def_type *,\n+\t\t\t\tgimple ** = NULL);\n+extern bool vect_is_simple_use (tree, vec_info *, enum vect_def_type *,\n+\t\t\t\ttree *, gimple ** = NULL);\n extern bool supportable_widening_operation (enum tree_code, gimple *, tree,\n \t\t\t\t\t    tree, enum tree_code *,\n \t\t\t\t\t    enum tree_code *, int *,"}]}