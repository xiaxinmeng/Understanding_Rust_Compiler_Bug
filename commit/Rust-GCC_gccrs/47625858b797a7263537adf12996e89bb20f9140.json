{"sha": "47625858b797a7263537adf12996e89bb20f9140", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc2MjU4NThiNzk3YTcyNjM1MzdhZGYxMjk5NmU4OWJiMjBmOTE0MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-02-06T13:19:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-02-06T13:19:20Z"}, "message": "Revert previous change, unintended.\n\nFrom-SVN: r195805", "tree": {"sha": "2cc5780b0e7e87bc528d73aa3ed90f7dcde02e60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cc5780b0e7e87bc528d73aa3ed90f7dcde02e60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47625858b797a7263537adf12996e89bb20f9140", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47625858b797a7263537adf12996e89bb20f9140", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47625858b797a7263537adf12996e89bb20f9140", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47625858b797a7263537adf12996e89bb20f9140/comments", "author": null, "committer": null, "parents": [{"sha": "a44bbd4889dc54e3f36ae97b16741ebb4378431f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a44bbd4889dc54e3f36ae97b16741ebb4378431f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a44bbd4889dc54e3f36ae97b16741ebb4378431f"}], "stats": {"total": 324, "additions": 68, "deletions": 256}, "files": [{"sha": "15d1cdd1e82c76bf4fb3206b3125e379e9c45854", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47625858b797a7263537adf12996e89bb20f9140/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47625858b797a7263537adf12996e89bb20f9140/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=47625858b797a7263537adf12996e89bb20f9140", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -507,5 +507,11 @@ do {\t\t\t\t\t\t   \\\n #define LOOP_STMT_BOTTOM_COND_P(NODE) TREE_LANG_FLAG_0 (LOOP_STMT_CHECK (NODE))\n #define LOOP_STMT_TOP_UPDATE_P(NODE)  TREE_LANG_FLAG_1 (LOOP_STMT_CHECK (NODE))\n \n+/* Optimization hints on loops.  */\n+#define LOOP_STMT_NO_UNROLL(NODE) TREE_LANG_FLAG_2 (LOOP_STMT_CHECK (NODE))\n+#define LOOP_STMT_UNROLL(NODE)    TREE_LANG_FLAG_3 (LOOP_STMT_CHECK (NODE))\n+#define LOOP_STMT_NO_VECTOR(NODE) TREE_LANG_FLAG_4 (LOOP_STMT_CHECK (NODE))\n+#define LOOP_STMT_VECTOR(NODE)    TREE_LANG_FLAG_5 (LOOP_STMT_CHECK (NODE))\n+\n #define EXIT_STMT_COND(NODE)     TREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 0)\n #define EXIT_STMT_LABEL(NODE)    TREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 1)"}, {"sha": "56b64a3c3436c3aa4f2aacdb270c5238730aedbe", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 19, "deletions": 69, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47625858b797a7263537adf12996e89bb20f9140/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47625858b797a7263537adf12996e89bb20f9140/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=47625858b797a7263537adf12996e89bb20f9140", "patch": "@@ -2908,12 +2908,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       {\n \tNode_Id full_definition = Declaration_Node (gnat_entity);\n \tNode_Id record_definition = Type_Definition (full_definition);\n-\tNode_Id gnat_constr;\n \tEntity_Id gnat_field;\n-\ttree gnu_field, gnu_field_list = NULL_TREE;\n-\ttree gnu_get_parent;\n+\ttree gnu_field, gnu_field_list = NULL_TREE, gnu_get_parent;\n \t/* Set PACKED in keeping with gnat_to_gnu_field.  */\n-\tconst int packed\n+\tint packed\n \t  = Is_Packed (gnat_entity)\n \t    ? 1\n \t    : Component_Alignment (gnat_entity) == Calign_Storage_Unit\n@@ -2923,13 +2921,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     && Known_RM_Size (gnat_entity)))\n \t\t? -2\n \t\t: 0;\n-\tconst bool has_discr = Has_Discriminants (gnat_entity);\n-\tconst bool has_rep = Has_Specified_Layout (gnat_entity);\n-\tconst bool is_extension\n+\tbool has_discr = Has_Discriminants (gnat_entity);\n+\tbool has_rep = Has_Specified_Layout (gnat_entity);\n+\tbool all_rep = has_rep;\n+\tbool is_extension\n \t  = (Is_Tagged_Type (gnat_entity)\n \t     && Nkind (record_definition) == N_Derived_Type_Definition);\n-\tconst bool is_unchecked_union = Is_Unchecked_Union (gnat_entity);\n-\tbool all_rep = has_rep;\n+\tbool is_unchecked_union = Is_Unchecked_Union (gnat_entity);\n \n \t/* See if all fields have a rep clause.  Stop when we find one\n \t   that doesn't.  */\n@@ -3168,51 +3166,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t}\n \t    }\n \n-\t/* If we have a derived untagged type that renames discriminants in\n-\t   the root type, the (stored) discriminants are a just copy of the\n-\t   discriminants of the root type.  This means that any constraints\n-\t   added by the renaming in the derivation are disregarded as far\n-\t   as the layout of the derived type is concerned.  To rescue them,\n-\t   we change the type of the (stored) discriminants to a subtype\n-\t   with the bounds of the type of the visible discriminants.  */\n-\tif (has_discr\n-\t    && !is_extension\n-\t    && Stored_Constraint (gnat_entity) != No_Elist)\n-\t  for (gnat_constr = First_Elmt (Stored_Constraint (gnat_entity));\n-\t       gnat_constr != No_Elmt;\n-\t       gnat_constr = Next_Elmt (gnat_constr))\n-\t    if (Nkind (Node (gnat_constr)) == N_Identifier\n-\t\t/* Ignore access discriminants.  */\n-\t\t&& !Is_Access_Type (Etype (Node (gnat_constr)))\n-\t\t&& Ekind (Entity (Node (gnat_constr))) == E_Discriminant)\n-\t      {\n-\t\tEntity_Id gnat_discr = Entity (Node (gnat_constr));\n-\t\ttree gnu_discr_type = gnat_to_gnu_type (Etype (gnat_discr));\n-\t\ttree gnu_ref\n-\t\t  = gnat_to_gnu_entity (Original_Record_Component (gnat_discr),\n-\t\t\t\t\tNULL_TREE, 0);\n-\n-\t\t/* GNU_REF must be an expression using a PLACEHOLDER_EXPR built\n-\t\t   just above for one of the stored discriminants.  */\n-\t\tgcc_assert (TREE_TYPE (TREE_OPERAND (gnu_ref, 0)) == gnu_type);\n-\n-\t\tif (gnu_discr_type != TREE_TYPE (gnu_ref))\n-\t\t  {\n-\t\t    const unsigned prec = TYPE_PRECISION (TREE_TYPE (gnu_ref));\n-\t\t    tree gnu_subtype\n-\t\t      = TYPE_UNSIGNED (TREE_TYPE (gnu_ref))\n-\t\t        ? make_unsigned_type (prec) : make_signed_type (prec);\n-\t\t    TREE_TYPE (gnu_subtype) = TREE_TYPE (gnu_ref);\n-\t\t    TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n-\t\t    SET_TYPE_RM_MIN_VALUE (gnu_subtype,\n-\t\t\t\t\t   TYPE_MIN_VALUE (gnu_discr_type));\n-\t\t    SET_TYPE_RM_MAX_VALUE (gnu_subtype,\n-\t\t\t\t\t   TYPE_MAX_VALUE (gnu_discr_type));\n-\t\t    TREE_TYPE (gnu_ref)\n-\t\t      = TREE_TYPE (TREE_OPERAND (gnu_ref, 1)) = gnu_subtype;\n-\t\t  }\n-\t      }\n-\n \t/* Add the fields into the record type and finish it up.  */\n \tcomponents_to_record (gnu_type, Component_List (record_definition),\n \t\t\t      gnu_field_list, packed, definition, false,\n@@ -4125,10 +4078,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttree gnu_stub_type = NULL_TREE, gnu_stub_name = NULL_TREE;\n \ttree gnu_ext_name = create_concat_name (gnat_entity, NULL);\n \tEntity_Id gnat_param;\n-\tenum inline_status_t inline_status\n-\t  = Has_Pragma_No_Inline (gnat_entity)\n-\t    ? is_suppressed\n-\t    : (Is_Inlined (gnat_entity) ? is_enabled : is_disabled);\n+\tbool inline_flag = Is_Inlined (gnat_entity);\n \tbool public_flag = Is_Public (gnat_entity) || imported_p;\n \tbool extern_flag\n \t  = (Is_Public (gnat_entity) && !definition) || imported_p;\n@@ -4684,15 +4634,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    gnu_decl\n \t      = create_subprog_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n-\t\t\t\t     gnu_param_list, inline_status,\n-\t\t\t\t     public_flag, extern_flag, artificial_flag,\n-\t\t\t\t     attr_list, gnat_entity);\n+\t\t\t\t     gnu_param_list, inline_flag, public_flag,\n+\t\t\t\t     extern_flag, artificial_flag, attr_list,\n+\t\t\t\t     gnat_entity);\n \t    if (has_stub)\n \t      {\n \t\ttree gnu_stub_decl\n \t\t  = create_subprog_decl (gnu_entity_name, gnu_stub_name,\n \t\t\t\t\t gnu_stub_type, gnu_stub_param_list,\n-\t\t\t\t\t inline_status, true, extern_flag,\n+\t\t\t\t\t inline_flag, true, extern_flag,\n \t\t\t\t\t false, attr_list, gnat_entity);\n \t\tSET_DECL_FUNCTION_STUB (gnu_decl, gnu_stub_decl);\n \t      }\n@@ -5425,7 +5375,7 @@ get_minimal_subprog_decl (Entity_Id gnat_entity)\n \n   return\n     create_subprog_decl (gnu_entity_name, gnu_ext_name, void_ftype, NULL_TREE,\n-\t\t\t is_disabled, true, true, true, attr_list, gnat_entity);\n+\t\t\t false, true, true, true, attr_list, gnat_entity);\n }\n \n /* Return whether the E_Subprogram_Type/E_Function/E_Procedure GNAT_ENTITY is\n@@ -6014,7 +5964,7 @@ elaborate_entity (Entity_Id gnat_entity)\n \t       Present (gnat_field);\n \t       gnat_field = Next_Discriminant (gnat_field),\n \t       gnat_discriminant_expr = Next_Elmt (gnat_discriminant_expr))\n-\t    /* Ignore access discriminants.  */\n+\t    /* ??? For now, ignore access discriminants.  */\n \t    if (!Is_Access_Type (Etype (Node (gnat_discriminant_expr))))\n \t      elaborate_expression (Node (gnat_discriminant_expr),\n \t\t\t\t    gnat_entity, get_entity_name (gnat_field),\n@@ -7660,20 +7610,20 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n {\n   vec<subst_pair> gnu_list = vNULL;\n   Entity_Id gnat_discrim;\n-  Node_Id gnat_constr;\n+  Node_Id gnat_value;\n \n   for (gnat_discrim = First_Stored_Discriminant (gnat_type),\n-       gnat_constr = First_Elmt (Stored_Constraint (gnat_subtype));\n+       gnat_value = First_Elmt (Stored_Constraint (gnat_subtype));\n        Present (gnat_discrim);\n        gnat_discrim = Next_Stored_Discriminant (gnat_discrim),\n-       gnat_constr = Next_Elmt (gnat_constr))\n+       gnat_value = Next_Elmt (gnat_value))\n     /* Ignore access discriminants.  */\n-    if (!Is_Access_Type (Etype (Node (gnat_constr))))\n+    if (!Is_Access_Type (Etype (Node (gnat_value))))\n       {\n \ttree gnu_field = gnat_to_gnu_field_decl (gnat_discrim);\n \ttree replacement = convert (TREE_TYPE (gnu_field),\n \t\t\t\t    elaborate_expression\n-\t\t\t\t    (Node (gnat_constr), gnat_subtype,\n+\t\t\t\t    (Node (gnat_value), gnat_subtype,\n \t\t\t\t     get_entity_name (gnat_discrim),\n \t\t\t\t     definition, true, false));\n \tsubst_pair s = {gnu_field, replacement};"}, {"sha": "6fc3f347ed31c986fc6e6de2ce79ade9c61813e5", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47625858b797a7263537adf12996e89bb20f9140/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47625858b797a7263537adf12996e89bb20f9140/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=47625858b797a7263537adf12996e89bb20f9140", "patch": "@@ -430,17 +430,6 @@ enum exception_info_kind\n   exception_column\n };\n \n-/* Define the inline status of a subprogram.  */\n-enum inline_status_t\n-{\n-  /* Inlining is suppressed for the subprogram.  */\n-  is_suppressed,\n-  /* No inlining is requested for the subprogram.  */\n-  is_disabled,\n-  /* Inlining is requested for the subprogram.  */\n-  is_enabled\n-};\n-\n extern GTY(()) tree gnat_std_decls[(int) ADT_LAST];\n extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n extern GTY(()) tree gnat_raise_decls_ext[(int) LAST_REASON_CODE + 1];\n@@ -729,14 +718,13 @@ extern tree create_label_decl (tree, Node_Id);\n    node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n    PARM_DECL nodes chained through the DECL_CHAIN field).\n \n-   INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n+   INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n    used to set the appropriate fields in the FUNCTION_DECL.  GNAT_NODE is\n    used for the position of the decl.  */\n extern tree create_subprog_decl (tree subprog_name, tree asm_name,\n \t\t\t\t tree subprog_type, tree param_decl_list,\n-\t\t\t\t enum inline_status_t inline_status,\n-\t\t\t\t bool public_flag, bool extern_flag,\n-\t\t\t\t bool artificial_flag,\n+\t\t\t\t bool inline_flag, bool public_flag,\n+\t\t\t\t bool extern_flag, bool artificial_flag,\n \t\t\t\t struct attrib *attr_list, Node_Id gnat_node);\n \n /* Set up the framework for generating code for SUBPROG_DECL, a subprogram"}, {"sha": "1d25b0f94a181e358e76d7f9a167a01d5775402f", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 32, "deletions": 148, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47625858b797a7263537adf12996e89bb20f9140/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47625858b797a7263537adf12996e89bb20f9140/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=47625858b797a7263537adf12996e89bb20f9140", "patch": "@@ -36,8 +36,6 @@\n #include \"gimple.h\"\n #include \"bitmap.h\"\n #include \"cgraph.h\"\n-#include \"diagnostic.h\"\n-#include \"opts.h\"\n #include \"target.h\"\n #include \"common/common-target.h\"\n \n@@ -212,7 +210,7 @@ typedef struct range_check_info_d *range_check_info;\n \n /* Structure used to record information for a loop.  */\n struct GTY(()) loop_info_d {\n-  tree stmt;\n+  tree label;\n   tree loop_var;\n   vec<range_check_info, va_gc> *checks;\n };\n@@ -413,16 +411,16 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n      memory.  */\n   malloc_decl\n     = create_subprog_decl (get_identifier (\"__gnat_malloc\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n-\t\t\t   NULL, Empty);\n+\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n+\t\t\t   Empty);\n   DECL_IS_MALLOC (malloc_decl) = 1;\n \n   /* malloc32 is a function declaration tree for a function to allocate\n      32-bit memory on a 64-bit system.  Needed only on 64-bit VMS.  */\n   malloc32_decl\n     = create_subprog_decl (get_identifier (\"__gnat_malloc32\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n-\t\t\t   NULL, Empty);\n+\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n+\t\t\t   Empty);\n   DECL_IS_MALLOC (malloc32_decl) = 1;\n \n   /* free is a function declaration tree for a function to free memory.  */\n@@ -431,16 +429,14 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \t\t\t   build_function_type_list (void_type_node,\n \t\t\t\t\t\t     ptr_void_type_node,\n \t\t\t\t\t\t     NULL_TREE),\n-\t\t\t   NULL_TREE, is_disabled, true, true, true, NULL,\n-\t\t\t   Empty);\n+\t\t\t   NULL_TREE, false, true, true, true, NULL, Empty);\n \n   /* This is used for 64-bit multiplication with overflow checking.  */\n   mulv64_decl\n     = create_subprog_decl (get_identifier (\"__gnat_mulv64\"), NULL_TREE,\n \t\t\t   build_function_type_list (int64_type, int64_type,\n \t\t\t\t\t\t     int64_type, NULL_TREE),\n-\t\t\t   NULL_TREE, is_disabled, true, true, true, NULL,\n-\t\t\t   Empty);\n+\t\t\t   NULL_TREE, false, true, true, true, NULL, Empty);\n \n   /* Name of the _Parent field in tagged record types.  */\n   parent_name_id = get_identifier (Get_Name_String (Name_uParent));\n@@ -461,15 +457,15 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n        NULL_TREE, build_function_type_list (jmpbuf_ptr_type, NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+       NULL_TREE, false, true, true, true, NULL, Empty);\n   DECL_IGNORED_P (get_jmpbuf_decl) = 1;\n \n   set_jmpbuf_decl\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__set_jmpbuf_address_soft\"),\n        NULL_TREE, build_function_type_list (void_type_node, jmpbuf_ptr_type,\n \t\t\t\t\t    NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+       NULL_TREE, false, true, true, true, NULL, Empty);\n   DECL_IGNORED_P (set_jmpbuf_decl) = 1;\n \n   /* setjmp returns an integer and has one operand, which is a pointer to\n@@ -479,7 +475,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n       (get_identifier (\"__builtin_setjmp\"), NULL_TREE,\n        build_function_type_list (integer_type_node, jmpbuf_ptr_type,\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+       NULL_TREE, false, true, true, true, NULL, Empty);\n   DECL_BUILT_IN_CLASS (setjmp_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n \n@@ -489,7 +485,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n     = create_subprog_decl\n       (get_identifier (\"__builtin_update_setjmp_buf\"), NULL_TREE,\n        build_function_type_list (void_type_node, jmpbuf_ptr_type, NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+       NULL_TREE, false, true, true, true, NULL, Empty);\n   DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n \n@@ -499,27 +495,27 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \n   begin_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_begin_handler\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n-\t\t\t   NULL, Empty);\n+\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n+\t\t\t   Empty);\n   DECL_IGNORED_P (begin_handler_decl) = 1;\n \n   end_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n-\t\t\t   NULL, Empty);\n+\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n+\t\t\t   Empty);\n   DECL_IGNORED_P (end_handler_decl) = 1;\n \n   unhandled_except_decl\n     = create_subprog_decl (get_identifier (\"__gnat_unhandled_except_handler\"),\n \t\t\t   NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n-\t\t\t   NULL, Empty);\n+\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n+\t\t\t   Empty);\n   DECL_IGNORED_P (unhandled_except_decl) = 1;\n \n   reraise_zcx_decl\n     = create_subprog_decl (get_identifier (\"__gnat_reraise_zcx\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n-\t\t\t   NULL, Empty);\n+\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n+\t\t\t   Empty);\n   /* Indicate that these never return.  */\n   DECL_IGNORED_P (reraise_zcx_decl) = 1;\n   TREE_THIS_VOLATILE (reraise_zcx_decl) = 1;\n@@ -539,7 +535,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \t\t\t\t     build_pointer_type\n \t\t\t\t     (unsigned_char_type_node),\n \t\t\t\t     integer_type_node, NULL_TREE),\n-\t   NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+\t   NULL_TREE, false, true, true, true, NULL, Empty);\n       TREE_THIS_VOLATILE (decl) = 1;\n       TREE_SIDE_EFFECTS (decl) = 1;\n       TREE_TYPE (decl)\n@@ -572,7 +568,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n       (get_identifier (\"system__soft_links__get_gnat_exception\"), NULL_TREE,\n        build_function_type_list (build_pointer_type (except_type_node),\n \t\t\t\t NULL_TREE),\n-     NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+     NULL_TREE, false, true, true, true, NULL, Empty);\n   DECL_IGNORED_P (get_excptr_decl) = 1;\n \n   raise_nodefer_decl\n@@ -581,7 +577,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n        build_function_type_list (void_type_node,\n \t\t\t\t build_pointer_type (except_type_node),\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+       NULL_TREE, false, true, true, true, NULL, Empty);\n \n   /* Indicate that it never returns.  */\n   TREE_THIS_VOLATILE (raise_nodefer_decl) = 1;\n@@ -754,7 +750,7 @@ build_raise_check (int check, enum exception_info_kind kind)\n   result\n     = create_subprog_decl (get_identifier (Name_Buffer),\n \t\t\t   NULL_TREE, ftype, NULL_TREE,\n-\t\t\t   is_disabled, true, true, true, NULL, Empty);\n+\t\t\t   false, true, true, true, NULL, Empty);\n \n   /* Indicate that it never returns.  */\n   TREE_THIS_VOLATILE (result) = 1;\n@@ -1188,11 +1184,11 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n static tree\n Pragma_to_gnu (Node_Id gnat_node)\n {\n-  tree gnu_result = alloc_stmt_list ();\n   Node_Id gnat_temp;\n+  tree gnu_result = alloc_stmt_list ();\n \n-  /* Do nothing if we are just annotating types and check for (and ignore)\n-     unrecognized pragmas.  */\n+  /* Check for (and ignore) unrecognized pragma and do nothing if we are just\n+     annotating types.  */\n   if (type_annotate_only\n       || !Is_Pragma_Name (Chars (Pragma_Identifier (gnat_node))))\n     return gnu_result;\n@@ -1254,37 +1250,6 @@ Pragma_to_gnu (Node_Id gnat_node)\n \t}\n       break;\n \n-    case Pragma_Loop_Optimize:\n-      for (gnat_temp = First (Pragma_Argument_Associations (gnat_node));\n-\t   Present (gnat_temp);\n-\t   gnat_temp = Next (gnat_temp))\n-\t{\n-\t  tree gnu_loop_stmt = gnu_loop_stack ->last ()->stmt;\n-\n-\t  switch (Chars (Expression (gnat_temp)))\n-\t    {\n-\t    case Name_No_Unroll:\n-\t      LOOP_STMT_NO_UNROLL (gnu_loop_stmt) = 1;\n-\t      break;\n-\n-\t    case Name_Unroll:\n-\t      LOOP_STMT_UNROLL (gnu_loop_stmt) = 1;\n-\t      break;\n-\n-\t    case Name_No_Vector:\n-\t      LOOP_STMT_NO_VECTOR (gnu_loop_stmt) = 1;\n-\t      break;\n-\n-\t    case Name_Vector:\n-\t      LOOP_STMT_VECTOR (gnu_loop_stmt) = 1;\n-\t      break;\n-\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n-      break;\n-\n     case Pragma_Optimize:\n       switch (Chars (Expression\n \t\t     (First (Pragma_Argument_Associations (gnat_node)))))\n@@ -1313,87 +1278,6 @@ Pragma_to_gnu (Node_Id gnat_node)\n       if (write_symbols == NO_DEBUG)\n \tpost_error (\"must specify -g?\", gnat_node);\n       break;\n-\n-    case Pragma_Warnings:\n-      {\n-\tNode_Id gnat_expr;\n-\t/* Preserve the location of the pragma.  */\n-\tconst location_t location = input_location;\n-\tstruct cl_option_handlers handlers;\n-\tunsigned int option_index;\n-\tdiagnostic_t kind;\n-\tbool imply;\n-\n-\tgnat_temp = First (Pragma_Argument_Associations (gnat_node));\n-\n-\t/* This is the String form: pragma Warnings (String).  */\n-\tif (Nkind (Expression (gnat_temp)) == N_String_Literal)\n-\t  {\n-\t    kind = DK_WARNING;\n-\t    gnat_expr = Expression (gnat_temp);\n-\t    imply = true;\n-\t  }\n-\n-\t/* This is the On/Off form: pragma Warnings (On | Off [,String]).  */\n-\telse if (Nkind (Expression (gnat_temp)) == N_Identifier)\n-\t  {\n-\t    switch (Chars (Expression (gnat_temp)))\n-\t      {\n-\t\tcase Name_Off:\n-\t\t  kind = DK_IGNORED;\n-\t\t  break;\n-\n-\t\tcase Name_On:\n-\t\t  kind = DK_WARNING;\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n-\t      }\n-\n-\t    if (Present (Next (gnat_temp)))\n-\t      {\n-\t\t/* pragma Warnings (On | Off, Name) is handled differently.  */\n-\t\tif (Nkind (Expression (Next (gnat_temp))) != N_String_Literal)\n-\t\t  break;\n-\n-\t        gnat_expr = Expression (Next (gnat_temp));\n-\t      }\n-\t    else\n-\t      gnat_expr = Empty;\n-\n-\t    imply = false;\n-\t  }\n-\n-\telse\n-\t  gcc_unreachable ();\n-\n-\t/* This is the same implementation as in the C family of compilers.  */\n-\tif (Present (gnat_expr))\n-\t  {\n-\t    tree gnu_expr = gnat_to_gnu (gnat_expr);\n-\t    const char *opt_string = TREE_STRING_POINTER (gnu_expr);\n-\t    const int len = TREE_STRING_LENGTH (gnu_expr);\n-\t    if (len < 3 || opt_string[0] != '-' || opt_string[1] != 'W')\n-\t      break;\n-\t    for (option_index = 0;\n-\t\t option_index < cl_options_count;\n-\t\t option_index++)\n-\t      if (strcmp (cl_options[option_index].opt_text, opt_string) == 0)\n-\t\tbreak;\n-\t  }\n-\telse\n-\t  option_index = 0;\n-\n-\tset_default_handlers (&handlers);\n-\tcontrol_warning_option (option_index, (int) kind, imply, location,\n-\t\t\t\tCL_Ada, &handlers, &global_options,\n-\t\t\t\t&global_options_set, global_dc);\n-      }\n-      break;\n-\n-    default:\n-      break;\n     }\n \n   return gnu_result;\n@@ -2460,8 +2344,8 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t\t &DECL_SOURCE_LOCATION (gnu_loop_label));\n   LOOP_STMT_LABEL (gnu_loop_stmt) = gnu_loop_label;\n \n-  /* Save the statement for later reuse.  */\n-  gnu_loop_info->stmt = gnu_loop_stmt;\n+  /* Save the label so that a corresponding N_Exit_Statement can find it.  */\n+  gnu_loop_info->label = gnu_loop_label;\n \n   /* Set the condition under which the loop must keep going.\n      For the case \"LOOP .... END LOOP;\" the condition is always true.  */\n@@ -2815,7 +2699,7 @@ establish_gnat_vms_condition_handler (void)\n \t\t\t\t\t\t\t ptr_void_type_node,\n \t\t\t\t\t\t\t ptr_void_type_node,\n \t\t\t\t\t\t\t NULL_TREE),\n-\t\t\t       NULL_TREE, is_disabled, true, true, true, NULL,\n+\t\t\t       NULL_TREE, false, true, true, true, NULL,\n \t\t\t       Empty);\n \n       /* ??? DECL_CONTEXT shouldn't have been set because of DECL_EXTERNAL.  */\n@@ -4869,7 +4753,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   tree gnu_elab_proc_decl\n     = create_subprog_decl\n       (create_concat_name (gnat_unit_entity, body_p ? \"elabb\" : \"elabs\"),\n-       NULL_TREE, void_ftype, NULL_TREE, is_disabled, true, false, true, NULL,\n+       NULL_TREE, void_ftype, NULL_TREE, false, true, false, true, NULL,\n        gnat_unit);\n   struct elab_info *info;\n \n@@ -5797,7 +5681,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    create_subprog_decl (create_concat_name\n \t\t\t\t (Entity (Prefix (gnat_node)),\n \t\t\t\t  attr == Attr_Elab_Body ? \"elabb\" : \"elabs\"),\n-\t\t\t\t NULL_TREE, void_ftype, NULL_TREE, is_disabled,\n+\t\t\t\t NULL_TREE, void_ftype, NULL_TREE, false,\n \t\t\t\t true, true, true, NULL, gnat_node);\n \n \tgnu_result = Attribute_to_gnu (gnat_node, &gnu_result_type, attr);\n@@ -6406,7 +6290,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   ? gnat_to_gnu (Condition (gnat_node)) : NULL_TREE),\n \t\t  (Present (Name (gnat_node))\n \t\t   ? get_gnu_tree (Entity (Name (gnat_node)))\n-\t\t   : LOOP_STMT_LABEL (gnu_loop_stack->last ()->stmt)));\n+\t\t   : gnu_loop_stack->last ()->label));\n       break;\n \n     case N_Simple_Return_Statement:"}, {"sha": "309cff6ad32c04bee12cbeced202afd934f443e1", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47625858b797a7263537adf12996e89bb20f9140/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47625858b797a7263537adf12996e89bb20f9140/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=47625858b797a7263537adf12996e89bb20f9140", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -2621,14 +2621,14 @@ create_label_decl (tree label_name, Node_Id gnat_node)\n    node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n    PARM_DECL nodes chained through the DECL_CHAIN field).\n \n-   INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n+   INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n    used to set the appropriate fields in the FUNCTION_DECL.  GNAT_NODE is\n    used for the position of the decl.  */\n \n tree\n create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n- \t\t     tree param_decl_list, enum inline_status_t inline_status,\n-\t\t     bool public_flag, bool extern_flag, bool artificial_flag,\n+\t\t     tree param_decl_list, bool inline_flag, bool public_flag,\n+\t\t     bool extern_flag, bool artificial_flag,\n \t\t     struct attrib *attr_list, Node_Id gnat_node)\n {\n   tree subprog_decl = build_decl (input_location, FUNCTION_DECL, subprog_name,\n@@ -2642,7 +2642,7 @@ create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n      function in the current unit since it is private to the other unit.\n      We could inline the nested function as well but it's probably better\n      to err on the side of too little inlining.  */\n-  if (inline_status != is_enabled\n+  if (!inline_flag\n       && !public_flag\n       && current_function_decl\n       && DECL_DECLARED_INLINE_P (current_function_decl)\n@@ -2651,24 +2651,8 @@ create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n \n   DECL_ARTIFICIAL (subprog_decl) = artificial_flag;\n   DECL_EXTERNAL (subprog_decl) = extern_flag;\n-\n-  switch (inline_status)\n-    {\n-    case is_suppressed:\n-      DECL_UNINLINABLE (subprog_decl) = 1;\n-      break;\n-\n-    case is_disabled:\n-      break;\n-\n-    case is_enabled:\n-      DECL_DECLARED_INLINE_P (subprog_decl) = 1;\n-      DECL_NO_INLINE_WARNING_P (subprog_decl) = artificial_flag;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+  DECL_DECLARED_INLINE_P (subprog_decl) = inline_flag;\n+  DECL_NO_INLINE_WARNING_P (subprog_decl) = inline_flag && artificial_flag;\n \n   TREE_PUBLIC (subprog_decl) = public_flag;\n   TREE_READONLY (subprog_decl) = TYPE_READONLY (subprog_type);"}]}