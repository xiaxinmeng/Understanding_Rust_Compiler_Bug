{"sha": "977b01e34d85c3612fa87d47e17bed0e3ac18d0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc3YjAxZTM0ZDg1YzM2MTJmYTg3ZDQ3ZTE3YmVkMGUzYWMxOGQwYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-04-23T14:55:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-04-23T14:55:07Z"}, "message": "ipa-icf.c (symbol_compare_collection::symbol_compare_collection): cleanup.\n\n\n\t* ipa-icf.c (symbol_compare_collection::symbol_compare_collection):\n\tcleanup.\n\t(sem_function::get_hash): Do not hash DECL_DISREGARD_INLINE_LIMITS,\n\tDECL_DECLARED_INLINE_P and DECL_IS_OPERATOR_NEW.\n\t(sem_item::compare_referenced_symbol_properties): New.\n\t(sem_item::hash_referenced_symbol_properties): New.\n\t(sem_item::compare_cgraph_references): Rename to ...\n\t(sem_item::compare_symbol_references): ... this one; use\n\tcompare_referenced_symbol_properties.\n\t(sem_function::equals_wpa): Do not compare\n\tDECL_DISREGARD_INLINE_LIMITS, DECL_DECLARED_INLINE_P,\n\tDECL_IS_OPERATOR_NEW; compare pointer sizes.\n\t(sem_item::update_hash_by_addr_refs): Call\n\thash_referenced_symbol_properties.\n\t(sem_item::update_hash_by_local_refs): Cleanup.\n\t(sem_function::merge): Do not mix up symbol properties.\n\t(sem_variable::equals_wpa): Use compare_symbol_references.\n\t* ipa-icf.h (sem_item::compare_referenced_symbol_properties): New.\n\t(sem_item::hash_referenced_symbol_properties): New.\n\t(sem_item::compare_symbol_references): New.\n\t(sem_item::compare_cgraph_references): Remove.\n\nFrom-SVN: r222372", "tree": {"sha": "41106bfa12032ca40e72a5e2225acb2794a48811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41106bfa12032ca40e72a5e2225acb2794a48811"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/977b01e34d85c3612fa87d47e17bed0e3ac18d0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/977b01e34d85c3612fa87d47e17bed0e3ac18d0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/977b01e34d85c3612fa87d47e17bed0e3ac18d0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/977b01e34d85c3612fa87d47e17bed0e3ac18d0b/comments", "author": null, "committer": null, "parents": [{"sha": "4cf022385365d3bbf1cfcf265dfd28a21a9be346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cf022385365d3bbf1cfcf265dfd28a21a9be346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cf022385365d3bbf1cfcf265dfd28a21a9be346"}], "stats": {"total": 247, "additions": 190, "deletions": 57}, "files": [{"sha": "5be1e9c3d34b8cb4c3be1619269b37f5635878c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/977b01e34d85c3612fa87d47e17bed0e3ac18d0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/977b01e34d85c3612fa87d47e17bed0e3ac18d0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=977b01e34d85c3612fa87d47e17bed0e3ac18d0b", "patch": "@@ -1,3 +1,27 @@\n+2015-04-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-icf.c (symbol_compare_collection::symbol_compare_collection):\n+\tcleanup.\n+\t(sem_function::get_hash): Do not hash DECL_DISREGARD_INLINE_LIMITS,\n+\tDECL_DECLARED_INLINE_P and DECL_IS_OPERATOR_NEW.\n+\t(sem_item::compare_referenced_symbol_properties): New.\n+\t(sem_item::hash_referenced_symbol_properties): New.\n+\t(sem_item::compare_cgraph_references): Rename to ...\n+\t(sem_item::compare_symbol_references): ... this one; use\n+\tcompare_referenced_symbol_properties.\n+\t(sem_function::equals_wpa): Do not compare\n+\tDECL_DISREGARD_INLINE_LIMITS, DECL_DECLARED_INLINE_P,\n+\tDECL_IS_OPERATOR_NEW; compare pointer sizes.\n+\t(sem_item::update_hash_by_addr_refs): Call\n+\thash_referenced_symbol_properties.\n+\t(sem_item::update_hash_by_local_refs): Cleanup.\n+\t(sem_function::merge): Do not mix up symbol properties.\n+\t(sem_variable::equals_wpa): Use compare_symbol_references.\n+\t* ipa-icf.h (sem_item::compare_referenced_symbol_properties): New.\n+\t(sem_item::hash_referenced_symbol_properties): New.\n+\t(sem_item::compare_symbol_references): New.\n+\t(sem_item::compare_cgraph_references): Remove.\n+\n 2015-04-23  Kwok Cheung Yeung  <kcy@codesourcery.com>\n \n \tPR target/26702"}, {"sha": "64fa4fa82b105514b947857cddf90c390a8cb2f6", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 152, "deletions": 56, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/977b01e34d85c3612fa87d47e17bed0e3ac18d0b/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/977b01e34d85c3612fa87d47e17bed0e3ac18d0b/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=977b01e34d85c3612fa87d47e17bed0e3ac18d0b", "patch": "@@ -145,9 +145,8 @@ symbol_compare_collection::symbol_compare_collection (symtab_node *node)\n   if (is_a <varpool_node *> (node) && DECL_VIRTUAL_P (node->decl))\n     return;\n \n-  for (unsigned i = 0; i < node->num_references (); i++)\n+  for (unsigned i = 0; node->iterate_reference (i, ref); i++)\n     {\n-      ref = node->iterate_reference (i, ref);\n       if (ref->address_matters_p ())\n \tm_references.safe_push (ref->referred);\n \n@@ -342,9 +341,6 @@ sem_function::get_hash (void)\n       if (DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl))\n \t (cl_optimization_hash\n \t   (TREE_OPTIMIZATION (DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl))));\n-      hstate.add_flag (DECL_DISREGARD_INLINE_LIMITS (decl));\n-      hstate.add_flag (DECL_DECLARED_INLINE_P (decl));\n-      hstate.add_flag (DECL_IS_OPERATOR_NEW (decl));\n       hstate.add_flag (DECL_CXX_CONSTRUCTOR_P (decl));\n       hstate.add_flag (DECL_CXX_DESTRUCTOR_P (decl));\n \n@@ -354,12 +350,117 @@ sem_function::get_hash (void)\n   return hash;\n }\n \n+/* Compare properties of symbols N1 and N2 that does not affect semantics of\n+   symbol itself but affects semantics of its references from USED_BY (which\n+   may be NULL if it is unknown).  If comparsion is false, symbols\n+   can still be merged but any symbols referring them can't.\n+\n+   If ADDRESS is true, do extra checking needed for IPA_REF_ADDR.\n+\n+   TODO: We can also split attributes to those that determine codegen of\n+   a function body/variable constructor itself and those that are used when\n+   referring to it.  */\n+\n+bool\n+sem_item::compare_referenced_symbol_properties (symtab_node *used_by,\n+\t\t\t\t\t\tsymtab_node *n1,\n+\t\t\t\t\t\tsymtab_node *n2,\n+\t\t\t\t\t\tbool address)\n+{\n+  if (is_a <cgraph_node *> (n1))\n+    {\n+      /* Inline properties matters: we do now want to merge uses of inline\n+\t function to uses of normal function because inline hint would be lost.\n+\t We however can merge inline function to noinline because the alias\n+\t will keep its DECL_DECLARED_INLINE flag.\n+\n+\t Also ignore inline flag when optimizing for size or when function\n+\t is known to not be inlinable.\n+\n+\t TODO: the optimize_size checks can also be assumed to be true if\n+\t unit has no !optimize_size functions. */\n+\n+      if ((!used_by || address || !is_a <cgraph_node *> (used_by)\n+\t   || !opt_for_fn (used_by->decl, optimize_size))\n+\t  && !opt_for_fn (n1->decl, optimize_size)\n+\t  && n1->get_availability () > AVAIL_INTERPOSABLE\n+\t  && (!DECL_UNINLINABLE (n1->decl) || !DECL_UNINLINABLE (n2->decl)))\n+\t{\n+\t  if (DECL_DISREGARD_INLINE_LIMITS (n1->decl)\n+\t      != DECL_DISREGARD_INLINE_LIMITS (n2->decl))\n+\t    return return_false_with_msg\n+\t\t     (\"DECL_DISREGARD_INLINE_LIMITS are different\");\n+\n+\t  if (DECL_DECLARED_INLINE_P (n1->decl)\n+\t      != DECL_DECLARED_INLINE_P (n2->decl))\n+\t    return return_false_with_msg (\"inline attributes are different\");\n+\t}\n+\n+      if (DECL_IS_OPERATOR_NEW (n1->decl)\n+\t  != DECL_IS_OPERATOR_NEW (n2->decl))\n+\treturn return_false_with_msg (\"operator new flags are different\");\n+    }\n+\n+  /* Merging two definitions with a reference to equivalent vtables, but\n+     belonging to a different type may result in ipa-polymorphic-call analysis\n+     giving a wrong answer about the dynamic type of instance.  */\n+  if (is_a <varpool_node *> (n1))\n+    {\n+      if ((DECL_VIRTUAL_P (n1->decl) || DECL_VIRTUAL_P (n2->decl))\n+\t  && (DECL_VIRTUAL_P (n1->decl) != DECL_VIRTUAL_P (n2->decl)\n+\t      || !types_must_be_same_for_odr (DECL_CONTEXT (n1->decl),\n+\t\t\t\t\t      DECL_CONTEXT (n2->decl)))\n+\t  && (!used_by || !is_a <cgraph_node *> (used_by) || address\n+\t      || opt_for_fn (used_by->decl, flag_devirtualize)))\n+\treturn return_false_with_msg\n+\t\t (\"references to virtual tables can not be merged\");\n+    }\n+\n+  /* When matching virtual tables, be sure to also match information\n+     relevant for polymorphic call analysis.  */\n+  if (used_by && is_a <varpool_node *> (used_by)\n+      && DECL_VIRTUAL_P (used_by->decl))\n+    {\n+      if (DECL_VIRTUAL_P (n1->decl) != DECL_VIRTUAL_P (n2->decl))\n+\treturn return_false_with_msg (\"virtual flag mismatch\");\n+      if (DECL_VIRTUAL_P (n1->decl) && is_a <cgraph_node *> (n1)\n+\t  && (DECL_FINAL_P (n1->decl) != DECL_FINAL_P (n2->decl)))\n+\treturn return_false_with_msg (\"final flag mismatch\");\n+    }\n+  return true;\n+}\n+\n+/* Hash properties that are compared by compare_referenced_symbol_properties. */\n+\n+void\n+sem_item::hash_referenced_symbol_properties (symtab_node *ref,\n+\t\t\t\t\t     inchash::hash &hstate,\n+\t\t\t\t\t     bool address)\n+{\n+  if (is_a <cgraph_node *> (ref))\n+    {\n+      if ((!type == FUNC || address || !opt_for_fn (decl, optimize_size))\n+\t  && !opt_for_fn (ref->decl, optimize_size)\n+\t  && !DECL_UNINLINABLE (ref->decl))\n+\t{\n+\t  hstate.add_flag (DECL_DISREGARD_INLINE_LIMITS (ref->decl));\n+\t  hstate.add_flag (DECL_DECLARED_INLINE_P (ref->decl));\n+\t}\n+      hstate.add_flag (DECL_IS_OPERATOR_NEW (ref->decl));\n+    }\n+  else if (is_a <varpool_node *> (ref))\n+    {\n+      hstate.add_flag (DECL_VIRTUAL_P (ref->decl));\n+    }\n+}\n+\n+\n /* For a given symbol table nodes N1 and N2, we check that FUNCTION_DECLs\n    point to a same function. Comparison can be skipped if IGNORED_NODES\n    contains these nodes.  ADDRESS indicate if address is taken.  */\n \n bool\n-sem_item::compare_cgraph_references (\n+sem_item::compare_symbol_references (\n     hash_map <symtab_node *, sem_item *> &ignored_nodes,\n     symtab_node *n1, symtab_node *n2, bool address)\n {\n@@ -372,17 +473,8 @@ sem_item::compare_cgraph_references (\n   if (is_a <varpool_node *> (n1) != is_a <varpool_node *> (n2))\n     return false;\n \n-  /* Merging two definitions with a reference to equivalent vtables, but\n-     belonging to a different type may result in ipa-polymorphic-call analysis\n-     giving a wrong answer about the dynamic type of instance.  */\n-  if (is_a <varpool_node *> (n1)\n-      && (DECL_VIRTUAL_P (n1->decl) || DECL_VIRTUAL_P (n2->decl))\n-      && (DECL_VIRTUAL_P (n1->decl) != DECL_VIRTUAL_P (n2->decl)\n-\t  || !types_must_be_same_for_odr (DECL_CONTEXT (n1->decl),\n-\t\t\t\t\t  DECL_CONTEXT (n2->decl))))\n-    return return_false_with_msg\n-\t     (\"references to virtual tables can not be merged\");\n-\n+  if (!compare_referenced_symbol_properties (node, n1, n2, address))\n+    return false;\n   if (address && n1->equal_address_to (n2) == 1)\n     return true;\n   if (!address && n1->semantically_equivalent_p (n2))\n@@ -435,16 +527,6 @@ sem_function::equals_wpa (sem_item *item,\n       != DECL_FUNCTION_PERSONALITY (item->decl))\n     return return_false_with_msg (\"function personalities are different\");\n \n-  if (DECL_DISREGARD_INLINE_LIMITS (decl)\n-      != DECL_DISREGARD_INLINE_LIMITS (item->decl))\n-    return return_false_with_msg (\"DECL_DISREGARD_INLINE_LIMITS are different\");\n-\n-  if (DECL_DECLARED_INLINE_P (decl) != DECL_DECLARED_INLINE_P (item->decl))\n-    return return_false_with_msg (\"inline attributes are different\");\n-\n-  if (DECL_IS_OPERATOR_NEW (decl) != DECL_IS_OPERATOR_NEW (item->decl))\n-    return return_false_with_msg (\"operator new flags are different\");\n-\n   if (DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl)\n        != DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (item->decl))\n     return return_false_with_msg (\"intrument function entry exit \"\n@@ -524,6 +606,12 @@ sem_function::equals_wpa (sem_item *item,\n \t  && (TYPE_RESTRICT (arg_types[i])\n \t      != TYPE_RESTRICT (m_compared_func->arg_types[i])))\n \treturn return_false_with_msg (\"argument restrict flag mismatch\");\n+      /* nonnull_arg_p implies non-zero range to REFERENCE types.  */\n+      if (POINTER_TYPE_P (arg_types[i])\n+\t  && TREE_CODE (arg_types[i])\n+\t     != TREE_CODE (m_compared_func->arg_types[i])\n+\t  && opt_for_fn (decl, flag_delete_null_pointer_checks))\n+\treturn return_false_with_msg (\"pointer wrt reference mismatch\");\n     }\n \n   if (node->num_references () != item->node->num_references ())\n@@ -557,7 +645,7 @@ sem_function::equals_wpa (sem_item *item,\n     {\n       item->node->iterate_reference (i, ref2);\n \n-      if (!compare_cgraph_references (ignored_nodes, ref->referred,\n+      if (!compare_symbol_references (ignored_nodes, ref->referred,\n \t\t\t\t      ref2->referred,\n \t\t\t\t      ref->address_matters_p ()))\n \treturn false;\n@@ -568,7 +656,7 @@ sem_function::equals_wpa (sem_item *item,\n \n   while (e1 && e2)\n     {\n-      if (!compare_cgraph_references (ignored_nodes, e1->callee,\n+      if (!compare_symbol_references (ignored_nodes, e1->callee,\n \t\t\t\t      e2->callee, false))\n \treturn false;\n \n@@ -585,17 +673,22 @@ sem_function::equals_wpa (sem_item *item,\n /* Update hash by address sensitive references. We iterate over all\n    sensitive references (address_matters_p) and we hash ultime alias\n    target of these nodes, which can improve a semantic item hash.\n-   TODO: stronger SCC based hashing would be desirable here.  */\n+\n+   Also hash in referenced symbols properties.  This can be done at any time\n+   (as the properties should not change), but it is convenient to do it here\n+   while we walk the references anyway.  */\n \n void\n sem_item::update_hash_by_addr_refs (hash_map <symtab_node *,\n \t\t\t\t    sem_item *> &m_symtab_node_map)\n {\n   ipa_ref* ref;\n   inchash::hash hstate (hash);\n-  for (unsigned i = 0; i < node->num_references (); i++)\n+\n+  for (unsigned i = 0; node->iterate_reference (i, ref); i++)\n     {\n-      ref = node->iterate_reference (i, ref);\n+      hash_referenced_symbol_properties (ref->referred, hstate,\n+\t\t\t\t\t ref->use == IPA_REF_ADDR);\n       if (ref->address_matters_p () || !m_symtab_node_map.get (ref->referred))\n \thstate.add_int (ref->referred->ultimate_alias_target ()->order);\n     }\n@@ -606,6 +699,7 @@ sem_item::update_hash_by_addr_refs (hash_map <symtab_node *,\n \t   e = e->next_caller)\n \t{\n \t  sem_item **result = m_symtab_node_map.get (e->callee);\n+\t  hash_referenced_symbol_properties (e->callee, hstate, false);\n \t  if (!result)\n \t    hstate.add_int (e->callee->ultimate_alias_target ()->order);\n \t}\n@@ -615,17 +709,18 @@ sem_item::update_hash_by_addr_refs (hash_map <symtab_node *,\n }\n \n /* Update hash by computed local hash values taken from different\n-   semantic items.  */\n+   semantic items.\n+   TODO: stronger SCC based hashing would be desirable here.  */\n \n void\n sem_item::update_hash_by_local_refs (hash_map <symtab_node *,\n \t\t\t\t     sem_item *> &m_symtab_node_map)\n {\n+  ipa_ref* ref;\n   inchash::hash state (hash);\n-  for (unsigned j = 0; j < node->num_references (); j++)\n+\n+  for (unsigned j = 0; node->iterate_reference (j, ref); j++)\n     {\n-      ipa_ref *ref;\n-      ref = node->iterate_reference (j, ref);\n       sem_item **result = m_symtab_node_map.get (ref->referring);\n       if (result)\n \tstate.merge_hash ((*result)->hash);\n@@ -967,13 +1062,25 @@ sem_function::merge (sem_item *alias_item)\n     {\n       /* First see if we can produce wrapper.  */\n \n+      /* Symbol properties that matter for references must be preserved.\n+\t TODO: We can produce wrapper, but we need to produce alias of ORIGINAL\n+\t with proper properties.  */\n+      if (!sem_item::compare_referenced_symbol_properties (NULL, original, alias,\n+\t\t\t\t\t\t\t   alias->address_taken))\n+        {\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Wrapper cannot be created because referenced symbol \"\n+\t\t     \"properties mismatch\\n\");\n+        }\n       /* Do not turn function in one comdat group into wrapper to another\n \t comdat group. Other compiler producing the body of the\n \t another comdat group may make opossite decision and with unfortunate\n \t linker choices this may close a loop.  */\n-      if (DECL_COMDAT_GROUP (original->decl) && DECL_COMDAT_GROUP (alias->decl)\n-\t  && (DECL_COMDAT_GROUP (alias->decl)\n-\t      != DECL_COMDAT_GROUP (original->decl)))\n+      else if (DECL_COMDAT_GROUP (original->decl)\n+\t       && DECL_COMDAT_GROUP (alias->decl)\n+\t       && (DECL_COMDAT_GROUP (alias->decl)\n+\t\t   != DECL_COMDAT_GROUP (original->decl)))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n@@ -1017,6 +1124,11 @@ sem_function::merge (sem_item *alias_item)\n \t= alias->get_availability () > AVAIL_INTERPOSABLE\n \t  && original->get_availability () > AVAIL_INTERPOSABLE\n \t  && !alias->instrumented_version;\n+      /* TODO: We can redirect, but we need to produce alias of ORIGINAL\n+\t with proper properties.  */\n+      if (!sem_item::compare_referenced_symbol_properties (NULL, original, alias,\n+\t\t\t\t\t\t\t   alias->address_taken))\n+\tredirect_callers = false;\n \n       if (!redirect_callers && !create_wrapper)\n \t{\n@@ -1663,33 +1775,17 @@ sem_variable::equals_wpa (sem_item *item,\n     {\n       item->node->iterate_reference (i, ref2);\n \n-      if (!compare_cgraph_references (ignored_nodes,\n+      if (!compare_symbol_references (ignored_nodes,\n \t\t\t\t      ref->referred, ref2->referred,\n \t\t\t\t      ref->address_matters_p ()))\n \treturn false;\n-\n-      /* When matching virtual tables, be sure to also match information\n- \t relevant for polymorphic call analysis.  */\n-      if (DECL_VIRTUAL_P (decl) || DECL_VIRTUAL_P (item->decl))\n-\t{\n-\t  if (DECL_VIRTUAL_P (ref->referred->decl)\n-\t      != DECL_VIRTUAL_P (ref2->referred->decl))\n-            return return_false_with_msg (\"virtual flag mismatch\");\n-\t  if (DECL_VIRTUAL_P (ref->referred->decl)\n-\t      && is_a <cgraph_node *> (ref->referred)\n-\t      && (DECL_FINAL_P (ref->referred->decl)\n-\t\t  != DECL_FINAL_P (ref2->referred->decl)))\n-            return return_false_with_msg (\"final flag mismatch\");\n-\t}\n     }\n \n   return true;\n }\n \n /* Returns true if the item equals to ITEM given as argument.  */\n \n-/* Returns true if the item equals to ITEM given as argument.  */\n-\n bool\n sem_variable::equals (sem_item *item,\n \t\t      hash_map <symtab_node *, sem_item *> &)"}, {"sha": "981952b3368c1c821fe4c44ec3bace69f84d5358", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/977b01e34d85c3612fa87d47e17bed0e3ac18d0b/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/977b01e34d85c3612fa87d47e17bed0e3ac18d0b/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=977b01e34d85c3612fa87d47e17bed0e3ac18d0b", "patch": "@@ -248,10 +248,23 @@ class sem_item\n   /* Accumulate to HSTATE a hash of type T.  */\n   static void add_type (const_tree t, inchash::hash &hstate);\n \n+  /* Compare properties of symbol that does not affect semantics of symbol\n+     itself but affects semantics of its references.\n+     If ADDRESS is true, do extra checking needed for IPA_REF_ADDR.  */\n+  static bool compare_referenced_symbol_properties (symtab_node *used_by,\n+\t\t\t\t\t\t    symtab_node *n1,\n+\t\t\t\t\t            symtab_node *n2,\n+\t\t\t\t\t            bool address);\n+\n+  /* Hash properties compared by compare_referenced_symbol_properties.  */\n+  void hash_referenced_symbol_properties (symtab_node *ref,\n+\t\t\t\t\t  inchash::hash &hstate,\n+\t\t\t\t\t  bool address);\n+\n   /* For a given symbol table nodes N1 and N2, we check that FUNCTION_DECLs\n      point to a same function. Comparison can be skipped if IGNORED_NODES\n      contains these nodes.  ADDRESS indicate if address is taken.  */\n-  bool compare_cgraph_references (hash_map <symtab_node *, sem_item *>\n+  bool compare_symbol_references (hash_map <symtab_node *, sem_item *>\n \t\t\t\t  &ignored_nodes,\n \t\t\t\t  symtab_node *n1, symtab_node *n2,\n \t\t\t\t  bool address);"}]}