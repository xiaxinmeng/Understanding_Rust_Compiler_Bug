{"sha": "b1474bb79e162bddd4b9bf13f6ace956b81d069f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE0NzRiYjc5ZTE2MmJkZGQ0YjliZjEzZjZhY2U5NTZiODFkMDY5Zg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-10-21T16:58:33Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-10-21T16:58:33Z"}, "message": "calls.c: Include tm_p.h later, so everything we need is defined.\n\n        * calls.c: Include tm_p.h later, so everything we need is defined.\n        * expr.c: Likewise.\n        * function.c: Likewise.\n\n        * except.c: Include tm_p.h.\n\n        * sparc.c: Likewise.\n        (dwarf2out_cfi_label): Don't prototype.\n        (check_return_regs, epilogue_renumber,\n        ultra_cmove_results_ready_p, ultra_fpmode_conflict_exists,\n        ultra_find_type, ultra_build_types_avail, ultra_flush_pipeline,\n        ultra_rescan_pipeline_state, set_extends, ultra_code_from_mask,\n        ultra_schedule_insn): Add static prototype.\n        (data_segment_operand, text_segment_operand): Call itself with the\n        proper number of arguments.\n        (sparc_flat_save_restore, sparc_v8plus_shift): Constify a char*.\n\n        * sparc.h: Move all declarations to sparc-protos.h.\n        (SELECT_RTX_SECTION):  Pass a missing MODE argument to\n        symbolic_operand.\n\n        * sparc/sysv4.h (SELECT_RTX_SECTION): Likewise.\n\n        * config/svr4.h (text_section, ctors_section, dtors_section): Add\n        Prototypes.\n        (ASM_OUTPUT_SECTION_NAME, UNIQUE_SECTION,\n        ASM_FINISH_DECLARE_OBJECT, ASM_OUTPUT_LIMITED_STRING,\n        ASM_OUTPUT_ASCII): Constify a char*.\n\n        * sparc-protos.h: New file for sparc prototypes.\n\ncp:\n        * expr.c: Include tm_p.h.\n\nFrom-SVN: r30122", "tree": {"sha": "b5d86503af13b1171adb59559442a63818b2595d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5d86503af13b1171adb59559442a63818b2595d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1474bb79e162bddd4b9bf13f6ace956b81d069f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1474bb79e162bddd4b9bf13f6ace956b81d069f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1474bb79e162bddd4b9bf13f6ace956b81d069f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1474bb79e162bddd4b9bf13f6ace956b81d069f/comments", "author": null, "committer": null, "parents": [{"sha": "ec97b83a1c851a56f911beda42d5ddb3806d5353", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec97b83a1c851a56f911beda42d5ddb3806d5353", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec97b83a1c851a56f911beda42d5ddb3806d5353"}], "stats": {"total": 387, "additions": 242, "deletions": 145}, "files": [{"sha": "48da7f8e1a2cf99805f45b3f74ee1d7accdfd671", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -1,3 +1,36 @@\n+Thu Oct 21 12:49:05 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* calls.c: Include tm_p.h later, so everything we need is defined.\n+\t* expr.c: Likewise.\n+\t* function.c: Likewise.\n+\n+\t* except.c: Include tm_p.h.\n+\n+\t* sparc.c: Likewise.\n+\t(dwarf2out_cfi_label): Don't prototype.\n+\t(check_return_regs, epilogue_renumber,\n+\tultra_cmove_results_ready_p, ultra_fpmode_conflict_exists,\n+\tultra_find_type, ultra_build_types_avail, ultra_flush_pipeline,\n+\tultra_rescan_pipeline_state, set_extends, ultra_code_from_mask,\n+\tultra_schedule_insn): Add static prototype.\n+\t(data_segment_operand, text_segment_operand): Call itself with the\n+\tproper number of arguments.\n+\t(sparc_flat_save_restore, sparc_v8plus_shift): Constify a char*.\n+\n+\t* sparc.h: Move all declarations to sparc-protos.h.\n+\t(SELECT_RTX_SECTION):  Pass a missing MODE argument to\n+\tsymbolic_operand.\n+\n+\t* sparc/sysv4.h (SELECT_RTX_SECTION): Likewise.\n+\n+\t* config/svr4.h (text_section, ctors_section, dtors_section): Add\n+\tPrototypes.\n+\t(ASM_OUTPUT_SECTION_NAME, UNIQUE_SECTION,\n+\tASM_FINISH_DECLARE_OBJECT, ASM_OUTPUT_LIMITED_STRING,\n+\tASM_OUTPUT_ASCII): Constify a char*.\n+\t\n+\t* sparc-protos.h: New file for sparc prototypes.\n+\t\n Thu Oct 21 12:23:40 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* function.c (record_insns, contains): Always declare and define."}, {"sha": "8113a919d7b3553e29fc33b28d346384a98e9025", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -22,14 +22,14 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n-#include \"tm_p.h\"\n #include \"flags.h\"\n #include \"expr.h\"\n #include \"function.h\"\n #include \"regs.h\"\n #include \"insn-flags.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n+#include \"tm_p.h\"\n \n #if !defined PREFERRED_STACK_BOUNDARY && defined STACK_BOUNDARY\n #define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY"}, {"sha": "7d4fdd4374984957c8c433ecf2816df7895b36f0", "filename": "gcc/config/sparc/sparc-protos.h", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -0,0 +1,163 @@\n+/* Prototypes of target machine for GNU compiler, for Sun SPARC.\n+   Copyright (C) 1987, 88, 89, 92, 94-98, 1999 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com).\n+   64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n+   at Cygnus Support.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef __SPARC_PROTOS_H__\n+#define __SPARC_PROTOS_H__\n+\n+#ifdef TREE_CODE\n+extern struct rtx_def *function_value PARAMS ((tree, enum machine_mode, int));\n+extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, tree, int));\n+extern void function_arg_advance PARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\t\t  enum machine_mode, tree, int));\n+extern struct rtx_def *function_arg PARAMS ((const CUMULATIVE_ARGS *,\n+\t\t\t\t\t     enum machine_mode,\n+\t\t\t\t\t     tree, int, int));\n+extern int function_arg_partial_nregs  PARAMS ((const CUMULATIVE_ARGS *,\n+\t\t\t\t\t\tenum machine_mode,\n+\t\t\t\t\t\ttree, int));\n+extern int function_arg_pass_by_reference PARAMS ((const CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t\t   tree, int));\n+extern struct rtx_def *sparc_builtin_saveregs PARAMS ((void));\n+#ifdef RTX_CODE\n+extern void sparc_va_start PARAMS ((int, tree, rtx));\n+#endif\n+extern struct rtx_def *sparc_va_arg PARAMS ((tree, tree));\n+extern unsigned long sparc_type_code PARAMS ((tree));\n+#ifdef ARGS_SIZE_RTX\n+/* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n+extern enum direction function_arg_padding PARAMS ((enum machine_mode, tree));\n+#endif /* ARGS_SIZE_RTX */\n+#endif /* TREE_CODE */\n+\n+extern void ultrasparc_sched_init PARAMS ((FILE *, int));\n+extern void finalize_pic PARAMS ((void));\n+extern void order_regs_for_local_alloc PARAMS ((void));\n+extern void output_function_epilogue PARAMS ((FILE *, int, int));\n+extern void output_function_prologue PARAMS ((FILE *, int, int));\n+extern void sparc_flat_output_function_epilogue PARAMS ((FILE *, int));\n+extern void sparc_flat_output_function_prologue PARAMS ((FILE *, int));\n+extern int compute_frame_size PARAMS ((int, int));\n+extern int check_pic PARAMS ((int));\n+extern int short_branch PARAMS ((int, int));\n+extern int sparc_flat_epilogue_delay_slots PARAMS ((void));\n+extern int sparc_issue_rate PARAMS ((void));\n+extern unsigned long sparc_flat_compute_frame_size PARAMS ((int));\n+extern void sparc_function_profiler PARAMS ((FILE *, int));\n+extern void sparc_function_block_profiler PARAMS ((FILE *, int));\n+extern void sparc_block_profiler PARAMS ((FILE *, int));\n+extern void sparc_function_block_profiler_exit PARAMS ((FILE *));\n+extern int compute_frame_size PARAMS ((int, int));\n+extern void sparc_override_options PARAMS ((void));\n+extern int leaf_return_peephole_ok PARAMS ((void));\n+extern void sparc_output_scratch_registers PARAMS ((FILE *));\n+extern void sparc_flat_save_restore PARAMS ((FILE *, const char *,\n+\t\t\t\t\t     unsigned int, unsigned long,\n+\t\t\t\t\t     unsigned long, const char *,\n+\t\t\t\t\t     const char *, unsigned long));\n+\n+#ifdef RTX_CODE\n+/* Define the function that build the compare insn for scc and bcc.  */\n+extern rtx gen_compare_reg PARAMS ((enum rtx_code code, rtx, rtx));\n+/* This function handles all v9 scc insns */\n+extern int gen_v9_scc PARAMS ((enum rtx_code, rtx *));\n+extern void sparc_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n+extern void sparc64_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n+extern rtx legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));\n+extern void ultrasparc_sched_reorder PARAMS ((FILE *, int, rtx *, int));\n+extern int ultrasparc_variable_issue PARAMS ((rtx));\n+extern void sparc_defer_case_vector PARAMS ((rtx, rtx, int));\n+extern void sparc_emit_set_const32 PARAMS ((rtx, rtx));\n+extern void sparc_emit_set_const64 PARAMS ((rtx, rtx));\n+extern void sparc_emit_set_symbolic_const64 PARAMS ((rtx, rtx, rtx));\n+extern int sparc_splitdi_legitimate PARAMS ((rtx, rtx));\n+extern int sparc_absnegfloat_split_legitimate PARAMS ((rtx, rtx));\n+extern char *output_cbranch PARAMS ((rtx, int, int, int, int, rtx));\n+extern const char *output_return PARAMS ((rtx *));\n+extern char *output_v9branch PARAMS ((rtx, int, int, int, int, int, rtx));\n+extern void emit_v9_brxx_insn PARAMS ((enum rtx_code, rtx, rtx));\n+extern void output_double_int PARAMS ((FILE *, rtx));\n+extern void print_operand PARAMS ((FILE *, rtx, int));\n+extern int addrs_ok_for_ldd_peep PARAMS ((rtx, rtx));\n+extern int arith10_double_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith10_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith11_double_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith11_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_double_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_double_4096_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_double_add_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_4096_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_add_operand PARAMS ((rtx, enum machine_mode));\n+extern int call_operand_address PARAMS ((rtx, enum machine_mode));\n+extern int input_operand PARAMS ((rtx, enum machine_mode));\n+extern int zero_operand PARAMS ((rtx, enum machine_mode));\n+extern int const64_operand PARAMS ((rtx, enum machine_mode));\n+extern int const64_high_operand PARAMS ((rtx, enum machine_mode));\n+extern int cc_arithop PARAMS ((rtx, enum machine_mode));\n+extern int cc_arithopn PARAMS ((rtx, enum machine_mode));\n+extern int data_segment_operand PARAMS ((rtx, enum machine_mode));\n+extern int eligible_for_epilogue_delay PARAMS ((rtx, int));\n+extern int eligible_for_return_delay PARAMS ((rtx));\n+extern int emit_move_sequence PARAMS ((rtx, enum machine_mode));\n+extern int extend_op PARAMS ((rtx, enum machine_mode));\n+extern int fcc_reg_operand PARAMS ((rtx, enum machine_mode));\n+extern int fp_zero_operand PARAMS ((rtx));\n+extern int icc_or_fcc_reg_operand PARAMS ((rtx, enum machine_mode));\n+extern int label_ref_operand PARAMS ((rtx, enum machine_mode));\n+extern int mem_min_alignment PARAMS ((rtx, int));\n+extern int noov_compare_op PARAMS ((rtx, enum machine_mode));\n+extern int pic_address_needs_scratch PARAMS ((rtx));\n+extern int reg_or_0_operand PARAMS ((rtx, enum machine_mode));\n+extern int reg_or_nonsymb_mem_operand PARAMS ((rtx, enum machine_mode));\n+extern int reg_unused_after PARAMS ((rtx, rtx));\n+extern int register_ok_for_ldd PARAMS ((rtx));\n+extern int registers_ok_for_ldd_peep PARAMS ((rtx, rtx));\n+extern int restore_operand PARAMS ((rtx, enum machine_mode));\n+extern int small_int PARAMS ((rtx, enum machine_mode));\n+extern int small_int_or_double PARAMS ((rtx, enum machine_mode));\n+extern int sp64_medium_pic_operand PARAMS ((rtx, enum machine_mode));\n+extern int sparc_flat_eligible_for_epilogue_delay PARAMS ((rtx, int));\n+extern int splittable_immediate_memory_operand PARAMS ((rtx, enum machine_mode));\n+extern int splittable_symbolic_memory_operand PARAMS ((rtx, enum machine_mode));\n+extern int sparc_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n+extern int symbolic_memory_operand PARAMS ((rtx, enum machine_mode));\n+extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int text_segment_operand PARAMS ((rtx, enum machine_mode));\n+extern int uns_small_int PARAMS ((rtx, enum machine_mode));\n+extern int v9_regcmp_op PARAMS ((rtx, enum machine_mode));\n+extern int v9_regcmp_p PARAMS ((enum rtx_code));\n+extern char *sparc_v8plus_shift PARAMS ((rtx *, rtx, const char *));\n+/* Function used for V8+ code generation.  Returns 1 if the high\n+   32 bits of REG are 0 before INSN.  */   \n+extern int sparc_check_64 PARAMS ((rtx, rtx));\n+extern int sparc_return_peephole_ok PARAMS ((rtx, rtx));\n+extern int intreg_operand PARAMS ((rtx, enum machine_mode));\n+extern int call_operand PARAMS ((rtx, enum machine_mode));\n+extern int eq_or_neq PARAMS ((rtx, enum machine_mode));\n+extern int normal_comp_operator PARAMS ((rtx, enum machine_mode));\n+extern int uns_arith_operand PARAMS ((rtx, enum machine_mode));\n+extern int clobbered_register PARAMS ((rtx, enum machine_mode));\n+#endif /* RTX_CODE */\n+\n+#endif /* __SPARC_PROTOS_H__ */"}, {"sha": "5c95702cbf50fe0d6c2ce64b7f9db3401ac550e7", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -39,6 +39,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n+#include \"tm_p.h\"\n \n /* 1 if the caller has placed an \"unimp\" insn immediately after the call.\n    This is used in v8 code when calling a function that returns a structure.\n@@ -122,10 +123,15 @@ static void sparc_output_addr_diff_vec PROTO((rtx));\n static void sparc_output_deferred_case_vectors PROTO((void));\n static void sparc_add_gc_roots    PROTO ((void));\n static void mark_ultrasparc_pipeline_state PROTO ((void *));\n-\n-#ifdef DWARF2_DEBUGGING_INFO\n-extern char *dwarf2out_cfi_label ();\n-#endif\n+static int check_return_regs PROTO ((rtx));\n+static void epilogue_renumber PROTO ((rtx *));\n+static int ultra_cmove_results_ready_p PROTO ((rtx));\n+static int ultra_fpmode_conflict_exists PROTO ((enum machine_mode));\n+static rtx *ultra_find_type PROTO ((int, rtx *, int));\n+static void ultra_build_types_avail PROTO ((rtx *, int));\n+static void ultra_flush_pipeline PROTO ((void));\n+static void ultra_rescan_pipeline_state PROTO ((rtx *, int));\n+static int set_extends PROTO ((rtx, rtx));\n \f\n /* Option handling.  */\n \n@@ -586,7 +592,7 @@ data_segment_operand (op, mode)\n       /* Assume canonical format of symbol + constant.\n \t Fall through.  */\n     case CONST :\n-      return data_segment_operand (XEXP (op, 0));\n+      return data_segment_operand (XEXP (op, 0), VOIDmode);\n     default :\n       return 0;\n     }\n@@ -610,7 +616,7 @@ text_segment_operand (op, mode)\n       /* Assume canonical format of symbol + constant.\n \t Fall through.  */\n     case CONST :\n-      return text_segment_operand (XEXP (op, 0));\n+      return text_segment_operand (XEXP (op, 0), VOIDmode);\n     default :\n       return 0;\n     }\n@@ -3615,6 +3621,8 @@ static void function_arg_record_value_3\n \tPROTO((int, struct function_arg_record_value_parms *));\n static void function_arg_record_value_2\n \tPROTO((tree, int, struct function_arg_record_value_parms *));\n+static void function_arg_record_value_1\n+        PROTO((tree, int, struct function_arg_record_value_parms *));\n static rtx function_arg_record_value\n \tPROTO((tree, enum machine_mode, int, int, int));\n \n@@ -5821,12 +5829,12 @@ void\n sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op,\n \t\t\t doubleword_op, base_offset)\n      FILE *file;\n-     char *base_reg;\n+     const char *base_reg;\n      unsigned int offset;\n      unsigned long gmask;\n      unsigned long fmask;\n-     char *word_op;\n-     char *doubleword_op;\n+     const char *word_op;\n+     const char *doubleword_op;\n      unsigned long base_offset;\n {\n   int regno;\n@@ -6632,6 +6640,9 @@ enum ultra_code { NONE=0, /* no insn at all\t\t\t\t*/\n \t\t  SINGLE, /* single issue instructions\t\t\t*/\n \t\t  NUM_ULTRA_CODES };\n \n+static enum ultra_code ultra_code_from_mask PROTO ((int));\n+static void ultra_schedule_insn PROTO ((rtx *, rtx *, int, enum ultra_code));\n+\n static const char *ultra_code_names[NUM_ULTRA_CODES] = {\n   \"NONE\", \"IEU0\", \"IEU1\", \"IEUN\", \"LSU\", \"CTI\",\n   \"FPM\", \"FPA\", \"SINGLE\" };\n@@ -7569,7 +7580,7 @@ char *\n sparc_v8plus_shift (operands, insn, opcode)\n      rtx *operands;\n      rtx insn;\n-     char *opcode;\n+     const char *opcode;\n {\n   static char asm_code[60];\n "}, {"sha": "0f7f086fca2e90c51b3dd8fd55f53a102ce8712f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 123, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -382,8 +382,6 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n    code into the rtl.  Also, if we are profiling, we cannot eliminate\n    the frame pointer (because the return address will get smashed).  */\n \n-void sparc_override_options ();\n-\n #define OVERRIDE_OPTIONS \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (profile_flag || profile_block_flag || profile_arc_flag)\t\t\\\n@@ -868,7 +866,7 @@ if (TARGET_ARCH64\t\t\t\t\\\n #define SELECT_RTX_SECTION(MODE, X)\t\t\\\n {\t\t\t\t\t\t\\\n   if (GET_MODE_BITSIZE (MODE) <= MAX_TEXT_ALIGN \\\n-      && ! (flag_pic && (symbolic_operand (X) || SUNOS4_SHARED_LIBRARIES)))  \\\n+      && ! (flag_pic && (symbolic_operand ((X), (MODE)) || SUNOS4_SHARED_LIBRARIES)))  \\\n     text_section ();\t\t\t\t\\\n   else\t\t\t\t\t\t\\\n     data_section ();\t\t\t\t\\\n@@ -1643,7 +1641,6 @@ extern char leaf_reg_remap[];\n \n /* On SPARC the value is found in the first \"output\" register.  */\n \n-extern struct rtx_def *function_value ();\n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n   function_value ((VALTYPE), TYPE_MODE (VALTYPE), 1)\n \n@@ -1702,15 +1699,13 @@ struct sparc_args {\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n \n-extern void init_cumulative_args ();\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT) \\\n init_cumulative_args (& (CUM), (FNTYPE), (LIBNAME), (INDIRECT));\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    TYPE is null for libcalls where that information may not be available.  */\n \n-extern void function_arg_advance ();\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n function_arg_advance (& (CUM), (MODE), (TYPE), (NAMED))\n \n@@ -1727,7 +1722,6 @@ function_arg_advance (& (CUM), (MODE), (TYPE), (NAMED))\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-extern struct rtx_def *function_arg ();\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n function_arg (& (CUM), (MODE), (TYPE), (NAMED), 0)\n \n@@ -1741,7 +1735,6 @@ function_arg (& (CUM), (MODE), (TYPE), (NAMED), 1)\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */\n \n-extern int function_arg_partial_nregs ();\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n function_arg_partial_nregs (& (CUM), (MODE), (TYPE), (NAMED))\n \n@@ -1751,7 +1744,6 @@ function_arg_partial_nregs (& (CUM), (MODE), (TYPE), (NAMED))\n    The pointer is passed in whatever way is appropriate for passing a pointer\n    to that type.  */\n \n-extern int function_arg_pass_by_reference ();\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n function_arg_pass_by_reference (& (CUM), (MODE), (TYPE), (NAMED))\n \n@@ -1780,13 +1772,6 @@ function_arg_padding ((MODE), (TYPE))\n \n extern struct rtx_def *sparc_compare_op0, *sparc_compare_op1;\n \n-/* Define the function that build the compare insn for scc and bcc.  */\n-\n-extern struct rtx_def *gen_compare_reg ();\n-\n-/* This function handles all v9 scc insns */\n-\n-extern int gen_v9_scc ();\n \f\n /* Generate the special assembly code needed to tell the assembler whatever\n    it might need to know about the return value of a function.\n@@ -2032,8 +2017,6 @@ LFLGRET\"ID\":\\n\\\n    FNADDR is an RTX for the address of the function's pure code.\n    CXT is an RTX for the static chain value for the function.  */\n \n-void sparc_initialize_trampoline ();\n-void sparc64_initialize_trampoline ();\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n     if (TARGET_ARCH64)\t\t\t\t\t\t\\\n       sparc64_initialize_trampoline (TRAMP, FNADDR, CXT);\t\\\n@@ -2042,15 +2025,12 @@ void sparc64_initialize_trampoline ();\n \f\n /* Generate necessary RTL for __builtin_saveregs().  */\n \n-extern struct rtx_def *sparc_builtin_saveregs ();\n #define EXPAND_BUILTIN_SAVEREGS() sparc_builtin_saveregs ()\n \n-extern void sparc_va_start ();\n /* Implement `va_start' for varargs and stdarg.  */\n #define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n   sparc_va_start (stdarg, valist, nextarg)\n \n-extern struct rtx_def *sparc_va_arg ();\n /* Implement `va_arg'.  */\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n   sparc_va_arg (valist, type)\n@@ -2385,7 +2365,6 @@ extern struct rtx_def *sparc_va_arg ();\n    opportunities to optimize the output.  */\n \n /* On SPARC, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n-extern struct rtx_def *legitimize_pic_address ();\n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n { rtx sparc_x = (X);\t\t\t\t\t\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n@@ -2745,10 +2724,6 @@ do {                                                                    \\\n #define ADJUST_COST(INSN,LINK,DEP,COST) \\\n   sparc_adjust_cost(INSN, LINK, DEP, COST)\n \n-extern void ultrasparc_sched_reorder ();\n-extern void ultrasparc_sched_init ();\n-extern int ultrasparc_variable_issue ();\n-\n #define MD_SCHED_INIT(DUMP, SCHED_VERBOSE)\t\t\t\t\\\n   if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\t\\\n     ultrasparc_sched_init (DUMP, SCHED_VERBOSE)\n@@ -2971,8 +2946,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* This is how we hook in and defer the case-vector until the end of\n    the function.  */\n-extern void sparc_defer_case_vector ();\n-\n #define ASM_OUTPUT_ADDR_VEC(LAB,VEC) \\\n   sparc_defer_case_vector ((LAB),(VEC), 0)\n \n@@ -3277,101 +3250,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define DONT_ACCESS_GBLS_AFTER_EPILOGUE (flag_pic)\n \n-/* Declare functions defined in sparc.c and used in templates.  */\n-\n-extern void sparc_emit_set_const32 ();\n-extern void sparc_emit_set_const64 ();\n-extern void sparc_emit_set_symbolic_const64 ();\n-extern int sparc_splitdi_legitimate ();\n-extern int sparc_absnegfloat_split_legitimate ();\n-\n-extern char *output_cbranch ();\n-extern const char *output_return ();\n-extern char *output_v9branch ();\n-\n-extern void emit_v9_brxx_insn ();\n-extern void finalize_pic ();\n-extern void order_regs_for_local_alloc ();\n-extern void output_double_int ();\n-extern void output_function_epilogue ();\n-extern void output_function_prologue ();\n-extern void print_operand ();\n-extern void sparc_flat_output_function_epilogue ();\n-extern void sparc_flat_output_function_prologue ();\n-\n-extern int addrs_ok_for_ldd_peep ();\n-extern int arith10_double_operand ();\n-extern int arith10_operand ();\n-extern int arith11_double_operand ();\n-extern int arith11_operand ();\n-extern int arith_double_operand ();\n-extern int arith_double_4096_operand ();\n-extern int arith_double_add_operand ();\n-extern int arith_operand ();\n-extern int arith_4096_operand ();\n-extern int arith_add_operand ();\n-extern int call_operand_address ();\n-extern int input_operand ();\n-extern int zero_operand ();\n-extern int const64_operand ();\n-extern int const64_high_operand ();\n-extern int cc_arithop ();\n-extern int cc_arithopn ();\n-extern int check_pic ();\n-extern int compute_frame_size ();\n-extern int data_segment_operand ();\n-extern int eligible_for_epilogue_delay ();\n-extern int eligible_for_return_delay ();\n-extern int emit_move_sequence ();\n-extern int extend_op ();\n-extern int fcc_reg_operand ();\n-extern int fp_zero_operand ();\n-extern int icc_or_fcc_reg_operand ();\n-extern int label_ref_operand ();\n-extern int mem_min_alignment ();\n-extern int noov_compare_op ();\n-extern int pic_address_needs_scratch ();\n-extern int reg_or_0_operand ();\n-extern int reg_or_nonsymb_mem_operand ();\n-extern int reg_unused_after ();\n-extern int register_ok_for_ldd ();\n-extern int registers_ok_for_ldd_peep ();\n-extern int restore_operand ();\n-extern int short_branch ();\n-extern int small_int ();\n-extern int small_int_or_double ();\n-extern int sp64_medium_pic_operand ();\n-extern int sparc_flat_eligible_for_epilogue_delay ();\n-extern int sparc_flat_epilogue_delay_slots ();\n-extern int sparc_issue_rate ();\n-extern int splittable_immediate_memory_operand ();\n-extern int splittable_symbolic_memory_operand ();\n-extern int sparc_adjust_cost ();\n-extern int symbolic_memory_operand ();\n-extern int symbolic_operand ();\n-extern int text_segment_operand ();\n-extern int uns_small_int ();\n-extern int v9_regcmp_op ();\n-extern int v9_regcmp_p ();\n-\n-extern unsigned long sparc_flat_compute_frame_size ();\n-extern unsigned long sparc_type_code ();\n-\n-extern void sparc_function_profiler ();\n-extern void sparc_function_block_profiler ();\n-extern void sparc_block_profiler ();\n-extern void sparc_function_block_profiler_exit ();\n-\n-extern char *sparc_v8plus_shift ();\n-\n-#ifdef __STDC__\n-/* Function used for V8+ code generation.  Returns 1 if the high\n-   32 bits of REG are 0 before INSN.  */   \n-extern int sparc_check_64 (struct rtx_def *, struct rtx_def *);\n-extern int sparc_return_peephole_ok (struct rtx_def *, struct rtx_def *);\n-extern int compute_frame_size (int, int);\n-#endif\n-\n /* Defined in flags.h, but insn-emit.c does not include flags.h.  */\n \n extern int flag_pic;"}, {"sha": "0263880d1f626c1810389ef4aed499cc823f2297", "filename": "gcc/config/sparc/sysv4.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsysv4.h?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -80,7 +80,7 @@ Boston, MA 02111-1307, USA.  */\n #undef SELECT_RTX_SECTION\n #define SELECT_RTX_SECTION(MODE,RTX)\t\t\\\n {\t\t\t\t\t\t\\\n-  if (flag_pic && symbolic_operand (RTX))\t\\\n+  if (flag_pic && symbolic_operand ((RTX), (MODE))) \\\n     data_section ();\t\t\t\t\\\n   else\t\t\t\t\t\t\\\n     const_section ();\t\t\t\t\\"}, {"sha": "3793b876589f13fb2777bb2d5d66bc839954580e", "filename": "gcc/config/svr4.h", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fconfig%2Fsvr4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fconfig%2Fsvr4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr4.h?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -486,8 +486,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define READONLY_DATA_SECTION() const_section ()\n \n-extern void text_section ();\n+extern void text_section PARAMS ((void));\n \n+extern void const_section PARAMS ((void));\n #define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n const_section ()\t\t\t\t\t\t\t\\\n@@ -501,6 +502,7 @@ const_section ()\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n+extern void ctors_section PARAMS ((void));\n #define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n ctors_section ()\t\t\t\t\t\t\t\\\n@@ -512,6 +514,7 @@ ctors_section ()\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n+extern void dtors_section PARAMS ((void));\n #define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n dtors_section ()\t\t\t\t\t\t\t\\\n@@ -542,7 +545,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n       enum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;\t\t\\\n     } *sections;\t\t\t\t\t\t\t\\\n   struct section_info *s;\t\t\t\t\t\t\\\n-  char *mode;\t\t\t\t\t\t\t\t\\\n+  const char *mode;\t\t\t\t\t\t\t\\\n   enum sect_enum type;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   for (s = sections; s; s = s->next)\t\t\t\t\t\\\n@@ -580,7 +583,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define UNIQUE_SECTION(DECL,RELOC)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n   int len;\t\t\t\t\t\t\t\\\n-  char *name, *string, *prefix;\t\t\t\t\t\\\n+  const char *name, *prefix;\t\t\t\t\t\\\n+  char *string;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));\t\\\n \t\t\t\t\t\t\t\t\\\n@@ -745,7 +749,7 @@ do {\t\t\t\t\t\t\t\t\\\n \n #define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n do {\t\t\t\t\t\t\t\t\t \\\n-     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t \\\n      if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n          && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n \t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n@@ -832,7 +836,8 @@ do {\t\t\t\t\t\t\t\t\t \\\n #define ASM_OUTPUT_LIMITED_STRING(FILE, STR)\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      register unsigned char *_limited_str = (unsigned char *) (STR);\t\\\n+      register const unsigned char *_limited_str =\t\t\t\\\n+\t(const unsigned char *) (STR);\t\t\t\t\t\\\n       register unsigned ch;\t\t\t\t\t\t\\\n       fprintf ((FILE), \"\\t%s\\t\\\"\", STRING_ASM_OP);\t\t\t\\\n       for (; (ch = *_limited_str); _limited_str++)\t\t\t\\\n@@ -867,12 +872,13 @@ do {\t\t\t\t\t\t\t\t\t \\\n #define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      register unsigned char *_ascii_bytes = (unsigned char *) (STR);\t\\\n-      register unsigned char *limit = _ascii_bytes + (LENGTH);\t\t\\\n+      register const unsigned char *_ascii_bytes =\t\t\t\\\n+\t(const unsigned char *) (STR);\t\t\t\t\t\\\n+      register const unsigned char *limit = _ascii_bytes + (LENGTH);\t\\\n       register unsigned bytes_in_chunk = 0;\t\t\t\t\\\n       for (; _ascii_bytes < limit; _ascii_bytes++)\t\t\t\\\n         {\t\t\t\t\t\t\t\t\\\n-\t  register unsigned char *p;\t\t\t\t\t\\\n+\t  register const unsigned char *p;\t\t\t\t\\\n \t  if (bytes_in_chunk >= 60)\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n \t      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\"}, {"sha": "f8b603639f342c4d164b0605be0dc7f1f7ed944a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -1,3 +1,7 @@\n+1999-10-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* expr.c: Include tm_p.h.\n+\n 1999-10-21  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (SCOPE_PARTIAL_P): New macro."}, {"sha": "6a3637b2dda7cf191ff31481d93c47f5835c155e", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -29,6 +29,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"cp-tree.h\"\n #include \"toplev.h\"\n #include \"except.h\"\n+#include \"tm_p.h\"\n \n #if 0\n static tree extract_aggr_init PROTO((tree, tree));"}, {"sha": "3c7692c4e90e3672494a03335787ba5f0c5a9648", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -409,6 +409,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #include \"obstack.h\"\n #include \"ggc.h\"\n+#include \"tm_p.h\"\n \n /* One to use setjmp/longjmp method of generating code for exception\n    handling.  */"}, {"sha": "e509ca4407342bcdba08b0c26b77979bd35e078e", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -24,7 +24,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"machmode.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n-#include \"tm_p.h\"\n #include \"obstack.h\"\n #include \"flags.h\"\n #include \"regs.h\"\n@@ -42,6 +41,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"defaults.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n+#include \"tm_p.h\"\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n "}, {"sha": "0fbbe6871fe77ab3e4fcf85e45093203512c9d7e", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1474bb79e162bddd4b9bf13f6ace956b81d069f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b1474bb79e162bddd4b9bf13f6ace956b81d069f", "patch": "@@ -42,7 +42,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n-#include \"tm_p.h\"\n #include \"flags.h\"\n #include \"except.h\"\n #include \"function.h\"\n@@ -59,6 +58,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"hash.h\"\n #include \"ggc.h\"\n+#include \"tm_p.h\"\n \n #ifndef TRAMPOLINE_ALIGNMENT\n #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY"}]}