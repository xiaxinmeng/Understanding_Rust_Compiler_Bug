{"sha": "95c68311b61f6bbb013d0eb2e4403f01c76bf622", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVjNjgzMTFiNjFmNmJiYjAxM2QwZWIyZTQ0MDNmMDFjNzZiZjYyMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:23:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:23:53Z"}, "message": "[25/46] Make get_earlier/later_stmt take and return stmt_vec_infos\n\n...and also make vect_find_last_scalar_stmt_in_slp return a stmt_vec_info.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (get_earlier_stmt, get_later_stmt): Take and\n\treturn stmt_vec_infos rather than gimple stmts.  Do not accept\n\tnull arguments.\n\t(vect_find_last_scalar_stmt_in_slp): Return a stmt_vec_info instead\n\tof a gimple stmt.\n\t* tree-vect-slp.c (vect_find_last_scalar_stmt_in_slp): Likewise.\n\tUpdate use of get_later_stmt.\n\t(vect_get_constant_vectors): Update call accordingly.\n\t(vect_schedule_slp_instance): Likewise\n\t* tree-vect-data-refs.c (vect_slp_analyze_node_dependences): Likewise.\n\t(vect_slp_analyze_instance_dependence): Likewise.\n\t(vect_preserves_scalar_order_p): Update use of get_earlier_stmt.\n\nFrom-SVN: r263140", "tree": {"sha": "23db27698d2e24d10d54f01b99a5c8a6b228410a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23db27698d2e24d10d54f01b99a5c8a6b228410a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95c68311b61f6bbb013d0eb2e4403f01c76bf622", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c68311b61f6bbb013d0eb2e4403f01c76bf622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95c68311b61f6bbb013d0eb2e4403f01c76bf622", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c68311b61f6bbb013d0eb2e4403f01c76bf622/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "211ee39b9d1d7d670dd4885bd1f4f038680a1e90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/211ee39b9d1d7d670dd4885bd1f4f038680a1e90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/211ee39b9d1d7d670dd4885bd1f4f038680a1e90"}], "stats": {"total": 122, "additions": 53, "deletions": 69}, "files": [{"sha": "5bb4f022aea4532c8eb1580c3182d2b0a76fbb6a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c68311b61f6bbb013d0eb2e4403f01c76bf622/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c68311b61f6bbb013d0eb2e4403f01c76bf622/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95c68311b61f6bbb013d0eb2e4403f01c76bf622", "patch": "@@ -1,3 +1,18 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (get_earlier_stmt, get_later_stmt): Take and\n+\treturn stmt_vec_infos rather than gimple stmts.  Do not accept\n+\tnull arguments.\n+\t(vect_find_last_scalar_stmt_in_slp): Return a stmt_vec_info instead\n+\tof a gimple stmt.\n+\t* tree-vect-slp.c (vect_find_last_scalar_stmt_in_slp): Likewise.\n+\tUpdate use of get_later_stmt.\n+\t(vect_get_constant_vectors): Update call accordingly.\n+\t(vect_schedule_slp_instance): Likewise\n+\t* tree-vect-data-refs.c (vect_slp_analyze_node_dependences): Likewise.\n+\t(vect_slp_analyze_instance_dependence): Likewise.\n+\t(vect_preserves_scalar_order_p): Update use of get_earlier_stmt.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (stmt_info_for_cost::stmt): Replace with..."}, {"sha": "81d2a581c8695bd397d8e83d1449bbf2c1e6d229", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c68311b61f6bbb013d0eb2e4403f01c76bf622/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c68311b61f6bbb013d0eb2e4403f01c76bf622/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=95c68311b61f6bbb013d0eb2e4403f01c76bf622", "patch": "@@ -216,8 +216,8 @@ vect_preserves_scalar_order_p (gimple *stmt_a, gimple *stmt_b)\n     stmtinfo_a = STMT_VINFO_RELATED_STMT (stmtinfo_a);\n   if (is_pattern_stmt_p (stmtinfo_b))\n     stmtinfo_b = STMT_VINFO_RELATED_STMT (stmtinfo_b);\n-  gimple *earlier_stmt = get_earlier_stmt (stmtinfo_a, stmtinfo_b);\n-  return !DR_IS_WRITE (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt)));\n+  stmt_vec_info earlier_stmt_info = get_earlier_stmt (stmtinfo_a, stmtinfo_b);\n+  return !DR_IS_WRITE (STMT_VINFO_DATA_REF (earlier_stmt_info));\n }\n \n /* A subroutine of vect_analyze_data_ref_dependence.  Handle\n@@ -671,17 +671,17 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n   /* This walks over all stmts involved in the SLP load/store done\n      in NODE verifying we can sink them up to the last stmt in the\n      group.  */\n-  gimple *last_access = vect_find_last_scalar_stmt_in_slp (node);\n+  stmt_vec_info last_access_info = vect_find_last_scalar_stmt_in_slp (node);\n   for (unsigned k = 0; k < SLP_INSTANCE_GROUP_SIZE (instance); ++k)\n     {\n       stmt_vec_info access_info = SLP_TREE_SCALAR_STMTS (node)[k];\n-      if (access_info == last_access)\n+      if (access_info == last_access_info)\n \tcontinue;\n       data_reference *dr_a = STMT_VINFO_DATA_REF (access_info);\n       ao_ref ref;\n       bool ref_initialized_p = false;\n       for (gimple_stmt_iterator gsi = gsi_for_stmt (access_info->stmt);\n-\t   gsi_stmt (gsi) != last_access; gsi_next (&gsi))\n+\t   gsi_stmt (gsi) != last_access_info->stmt; gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n \t  if (! gimple_vuse (stmt)\n@@ -757,14 +757,14 @@ vect_slp_analyze_instance_dependence (slp_instance instance)\n     store = NULL;\n \n   /* Verify we can sink stores to the vectorized stmt insert location.  */\n-  gimple *last_store = NULL;\n+  stmt_vec_info last_store_info = NULL;\n   if (store)\n     {\n       if (! vect_slp_analyze_node_dependences (instance, store, vNULL, NULL))\n \treturn false;\n \n       /* Mark stores in this instance and remember the last one.  */\n-      last_store = vect_find_last_scalar_stmt_in_slp (store);\n+      last_store_info = vect_find_last_scalar_stmt_in_slp (store);\n       for (unsigned k = 0; k < SLP_INSTANCE_GROUP_SIZE (instance); ++k)\n \tgimple_set_visited (SLP_TREE_SCALAR_STMTS (store)[k]->stmt, true);\n     }\n@@ -779,7 +779,7 @@ vect_slp_analyze_instance_dependence (slp_instance instance)\n     if (! vect_slp_analyze_node_dependences (instance, load,\n \t\t\t\t\t     store\n \t\t\t\t\t     ? SLP_TREE_SCALAR_STMTS (store)\n-\t\t\t\t\t     : vNULL, last_store))\n+\t\t\t\t\t     : vNULL, last_store_info))\n       {\n \tres = false;\n \tbreak;"}, {"sha": "45f806417aaf9e0d9d9dc9a3b3eef07542e161a0", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c68311b61f6bbb013d0eb2e4403f01c76bf622/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c68311b61f6bbb013d0eb2e4403f01c76bf622/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=95c68311b61f6bbb013d0eb2e4403f01c76bf622", "patch": "@@ -1838,18 +1838,17 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n \n /* Find the last store in SLP INSTANCE.  */\n \n-gimple *\n+stmt_vec_info\n vect_find_last_scalar_stmt_in_slp (slp_tree node)\n {\n-  gimple *last = NULL;\n+  stmt_vec_info last = NULL;\n   stmt_vec_info stmt_vinfo;\n \n   for (int i = 0; SLP_TREE_SCALAR_STMTS (node).iterate (i, &stmt_vinfo); i++)\n     {\n       if (is_pattern_stmt_p (stmt_vinfo))\n-\tlast = get_later_stmt (STMT_VINFO_RELATED_STMT (stmt_vinfo), last);\n-      else\n-\tlast = get_later_stmt (stmt_vinfo, last);\n+\tstmt_vinfo = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n+      last = last ? get_later_stmt (stmt_vinfo, last) : stmt_vinfo;\n     }\n \n   return last;\n@@ -3480,8 +3479,9 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \t      gimple_stmt_iterator gsi;\n \t      if (place_after_defs)\n \t\t{\n-\t\t  gsi = gsi_for_stmt\n-\t\t          (vect_find_last_scalar_stmt_in_slp (slp_node));\n+\t\t  stmt_vec_info last_stmt_info\n+\t\t    = vect_find_last_scalar_stmt_in_slp (slp_node);\n+\t\t  gsi = gsi_for_stmt (last_stmt_info->stmt);\n \t\t  init = vect_init_vector (stmt_vinfo, vec_cst, vector_type,\n \t\t\t\t\t   &gsi);\n \t\t}\n@@ -3910,7 +3910,8 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n \n   /* Vectorized stmts go before the last scalar stmt which is where\n      all uses are ready.  */\n-  si = gsi_for_stmt (vect_find_last_scalar_stmt_in_slp (node));\n+  stmt_vec_info last_stmt_info = vect_find_last_scalar_stmt_in_slp (node);\n+  si = gsi_for_stmt (last_stmt_info->stmt);\n \n   /* Mark the first element of the reduction chain as reduction to properly\n      transform the node.  In the analysis phase only the last element of the"}, {"sha": "733322a130ab82aae815dfe7ecb51cb33e6b0e73", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 21, "deletions": 53, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c68311b61f6bbb013d0eb2e4403f01c76bf622/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c68311b61f6bbb013d0eb2e4403f01c76bf622/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=95c68311b61f6bbb013d0eb2e4403f01c76bf622", "patch": "@@ -1119,68 +1119,36 @@ set_vinfo_for_stmt (gimple *stmt, stmt_vec_info info)\n     }\n }\n \n-/* Return the earlier statement between STMT1 and STMT2.  */\n+/* Return the earlier statement between STMT1_INFO and STMT2_INFO.  */\n \n-static inline gimple *\n-get_earlier_stmt (gimple *stmt1, gimple *stmt2)\n+static inline stmt_vec_info\n+get_earlier_stmt (stmt_vec_info stmt1_info, stmt_vec_info stmt2_info)\n {\n-  unsigned int uid1, uid2;\n-\n-  if (stmt1 == NULL)\n-    return stmt2;\n-\n-  if (stmt2 == NULL)\n-    return stmt1;\n-\n-  uid1 = gimple_uid (stmt1);\n-  uid2 = gimple_uid (stmt2);\n-\n-  if (uid1 == 0 || uid2 == 0)\n-    return NULL;\n-\n-  gcc_assert (uid1 <= stmt_vec_info_vec->length ()\n-\t      && uid2 <= stmt_vec_info_vec->length ());\n-  gcc_checking_assert ((STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (stmt1))\n-\t\t\t|| !STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt1)))\n-\t\t       && (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (stmt2))\n-\t\t\t   || !STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt2))));\n+  gcc_checking_assert ((STMT_VINFO_IN_PATTERN_P (stmt1_info)\n+\t\t\t|| !STMT_VINFO_RELATED_STMT (stmt1_info))\n+\t\t       && (STMT_VINFO_IN_PATTERN_P (stmt2_info)\n+\t\t\t   || !STMT_VINFO_RELATED_STMT (stmt2_info)));\n \n-  if (uid1 < uid2)\n-    return stmt1;\n+  if (gimple_uid (stmt1_info->stmt) < gimple_uid (stmt2_info->stmt))\n+    return stmt1_info;\n   else\n-    return stmt2;\n+    return stmt2_info;\n }\n \n-/* Return the later statement between STMT1 and STMT2.  */\n+/* Return the later statement between STMT1_INFO and STMT2_INFO.  */\n \n-static inline gimple *\n-get_later_stmt (gimple *stmt1, gimple *stmt2)\n+static inline stmt_vec_info\n+get_later_stmt (stmt_vec_info stmt1_info, stmt_vec_info stmt2_info)\n {\n-  unsigned int uid1, uid2;\n-\n-  if (stmt1 == NULL)\n-    return stmt2;\n-\n-  if (stmt2 == NULL)\n-    return stmt1;\n-\n-  uid1 = gimple_uid (stmt1);\n-  uid2 = gimple_uid (stmt2);\n-\n-  if (uid1 == 0 || uid2 == 0)\n-    return NULL;\n-\n-  gcc_assert (uid1 <= stmt_vec_info_vec->length ()\n-\t      && uid2 <= stmt_vec_info_vec->length ());\n-  gcc_checking_assert ((STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (stmt1))\n-\t\t\t|| !STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt1)))\n-\t\t       && (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (stmt2))\n-\t\t\t   || !STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt2))));\n+  gcc_checking_assert ((STMT_VINFO_IN_PATTERN_P (stmt1_info)\n+\t\t\t|| !STMT_VINFO_RELATED_STMT (stmt1_info))\n+\t\t       && (STMT_VINFO_IN_PATTERN_P (stmt2_info)\n+\t\t\t   || !STMT_VINFO_RELATED_STMT (stmt2_info)));\n \n-  if (uid1 > uid2)\n-    return stmt1;\n+  if (gimple_uid (stmt1_info->stmt) > gimple_uid (stmt2_info->stmt))\n+    return stmt1_info;\n   else\n-    return stmt2;\n+    return stmt2_info;\n }\n \n /* Return TRUE if a statement represented by STMT_INFO is a part of a\n@@ -1674,7 +1642,7 @@ extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n extern void vect_get_slp_defs (vec<tree> , slp_tree, vec<vec<tree> > *);\n extern bool vect_slp_bb (basic_block);\n-extern gimple *vect_find_last_scalar_stmt_in_slp (slp_tree);\n+extern stmt_vec_info vect_find_last_scalar_stmt_in_slp (slp_tree);\n extern bool is_simple_and_all_uses_invariant (gimple *, loop_vec_info);\n extern bool can_duplicate_and_interleave_p (unsigned int, machine_mode,\n \t\t\t\t\t    unsigned int * = NULL,"}]}