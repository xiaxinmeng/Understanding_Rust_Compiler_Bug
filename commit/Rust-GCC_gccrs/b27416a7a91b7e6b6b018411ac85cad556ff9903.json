{"sha": "b27416a7a91b7e6b6b018411ac85cad556ff9903", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI3NDE2YTdhOTFiN2U2YjZiMDE4NDExYWM4NWNhZDU1NmZmOTkwMw==", "commit": {"author": {"name": "Jeff Law", "email": "jlaw@localhost.localdomain", "date": "2021-09-05T04:08:34Z"}, "committer": {"name": "Jeff Law", "email": "jlaw@localhost.localdomain", "date": "2021-09-05T04:08:34Z"}, "message": "Improve handling of C bit for setcc insns\n\ngcc/\n\t* config/h8300/h8300.md (QHSI2 mode iterator): New mode iterator.\n\t* config/h8300/testcompare.md (store_c): Update name, use new\n\tQHSI2 iterator.\n\t(store_neg_c, store_shifted_c): New patterns.", "tree": {"sha": "65acb590556a4fe972029fd6e50c4f59e1afab2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65acb590556a4fe972029fd6e50c4f59e1afab2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b27416a7a91b7e6b6b018411ac85cad556ff9903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b27416a7a91b7e6b6b018411ac85cad556ff9903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b27416a7a91b7e6b6b018411ac85cad556ff9903", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b27416a7a91b7e6b6b018411ac85cad556ff9903/comments", "author": null, "committer": null, "parents": [{"sha": "617c9ce23293fce5aad7107058db50ac9df0c0c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617c9ce23293fce5aad7107058db50ac9df0c0c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617c9ce23293fce5aad7107058db50ac9df0c0c7"}], "stats": {"total": 123, "additions": 120, "deletions": 3}, "files": [{"sha": "e81e21b103e7bf0574c8ae657040da571fbcecab", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b27416a7a91b7e6b6b018411ac85cad556ff9903/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b27416a7a91b7e6b6b018411ac85cad556ff9903/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=b27416a7a91b7e6b6b018411ac85cad556ff9903", "patch": "@@ -223,6 +223,7 @@\n (define_mode_iterator HSI [HI SI])\n \n (define_mode_iterator QHSI [QI HI SI])\n+(define_mode_iterator QHSI2 [QI HI SI])\n \n (define_mode_iterator QHSIF [QI HI SI SF])\n "}, {"sha": "0ee3e360bea1caa2befdf942c1d737522a0073ca", "filename": "gcc/config/h8300/testcompare.md", "status": "modified", "additions": 119, "deletions": 3, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b27416a7a91b7e6b6b018411ac85cad556ff9903/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b27416a7a91b7e6b6b018411ac85cad556ff9903/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Ftestcompare.md?ref=b27416a7a91b7e6b6b018411ac85cad556ff9903", "patch": "@@ -212,15 +212,131 @@\n   }\n   [(set (attr \"length\") (symbol_ref \"<MODE>mode == SImode ? 6 : 4\"))])\n \n+;; Similarly, but with a negated result\n+(define_insn \"*store_neg_c_<mode>\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+\t(neg:QHSI (ne:QHSI (reg:CCC CC_REG) (const_int 0))))]\n+  \"reload_completed\"\n+  {\n+    if (<MODE>mode == QImode)\n+      return \"subx\\t%X0,%X0\";\n+    else if (<MODE>mode == HImode)\n+      return \"subx\\t%X0,%X0\\;exts.w\\t%T0\";\n+    else if (<MODE>mode == SImode)\n+      return \"subx\\t%X0,%X0\\;exts.w\\t%T0\\;exts.l\\t%S0\";\n+    gcc_unreachable ();\n+  }\n+  [(set\n+     (attr \"length\")\n+     (symbol_ref \"(<MODE>mode == SImode ? 6 : <MODE>mode == HImode ? 4 : 2)\"))])\n+\n+;; Using b[i]st we can store the C bit into any of the low 16 bits of\n+;; a destination.  We can also rotate it up into the high bit of a 32 bit\n+;; destination.\n+(define_insn \"*store_shifted_c<mode>\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+\t(ashift:QHSI (eqne:QHSI (reg:CCC CC_REG) (const_int 0))\n+\t\t     (match_operand 1 \"immediate_operand\" \"n\")))]\n+  \"(reload_completed\n+    && (INTVAL (operands[1]) == 31 || INTVAL (operands[1]) <= 15))\"\n+  {\n+    if (<CODE> == NE)\n+      {\n+\tif (<MODE>mode == QImode)\n+\t  return \"xor.b\\t%X0,%X0\\;bst\\t%1,%X0\";\n+\telse if (<MODE>mode == HImode && INTVAL (operands[1]) < 8)\n+\t  return \"xor.w\\t%T0,%T0\\;bst\\t%1,%X0\";\n+\telse if (<MODE>mode == HImode)\n+\t  {\n+\t    operands[1] = GEN_INT (INTVAL (operands[1]) - 8);\n+\t    output_asm_insn (\"xor.w\\t%T0,%T0\\;bst\\t%1,%t0\", operands);\n+\t    return \"\";\n+\t  }\n+\telse if (<MODE>mode == SImode && INTVAL (operands[1]) == 31)\n+\t  return \"xor.l\\t%S0,%S0\\;rotxr.l\\t%S0\";\n+\telse if (<MODE>mode == SImode && INTVAL (operands[1]) < 8)\n+\t  return \"xor.l\\t%S0,%S0\\;bst\\t%1,%X0\";\n+\telse if (<MODE>mode == SImode)\n+\t  {\n+\t    operands[1] = GEN_INT (INTVAL (operands[1]) - 8);\n+\t    output_asm_insn (\"xor.l\\t%S0,%S0\\;bst\\t%1,%t0\", operands);\n+\t    return \"\";\n+\t  }\n+\tgcc_unreachable ();\n+      }\n+    else if (<CODE> == EQ)\n+      {\n+\tif (<MODE>mode == QImode)\n+\t  return \"xor.b\\t%X0,%X0\\;bist\\t%1,%X0\";\n+\telse if (<MODE>mode == HImode && INTVAL (operands[1]) < 8)\n+\t  return \"xor.w\\t%T0,%T0\\;bist\\t%1,%X0\";\n+\telse if (<MODE>mode == HImode)\n+\t  {\n+\t    operands[1] = GEN_INT (INTVAL (operands[1]) - 8);\n+\t    output_asm_insn (\"xor.w\\t%T0,%T0\\;bist\\t%1,%t0\", operands);\n+\t    return \"\";\n+\t  }\n+\telse if (<MODE>mode == SImode && INTVAL (operands[1]) == 31)\n+\t  return \"xor.l\\t%S0,%S0\\;bixor\\t#0,%X0\\;rotxr.l\\t%S0\";\n+\telse if (<MODE>mode == SImode && INTVAL (operands[1]) < 8)\n+\t  return \"xor.l\\t%S0,%S0\\;bist\\t%1,%X0\";\n+\telse if (<MODE>mode == SImode)\n+\t  {\n+\t    operands[1] = GEN_INT (INTVAL (operands[1]) - 8);\n+\t    output_asm_insn (\"xor.l\\t%S0,%S0\\;bist\\t%1,%t0\", operands);\n+\t    return \"\";\n+\t  }\n+\tgcc_unreachable ();\n+      }\n+    gcc_unreachable ();\n+  }\n+  [(set\n+     (attr \"length\")\n+     (symbol_ref \"(<MODE>mode == QImode ? 4\n+\t\t   : <MODE>mode == HImode ? 4\n+\t\t   : <CODE> == NE ? 6\n+\t\t   : INTVAL (operands[1]) == 31 ? 8 : 6)\"))])\n+\n ;; Recognize this scc and generate code we can match\n-(define_insn_and_split \"*store_c_i_<mode>\"\n+(define_insn_and_split \"*store_c\"\n   [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n-\t(geultu:QHSI (match_operand:QHSI 1 \"register_operand\" \"r\")\n-\t\t     (match_operand:QHSI 2 \"register_operand\" \"r\")))]\n+\t(geultu:QHSI (match_operand:QHSI2 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:QHSI2 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (reg:CCC CC_REG)\n \t(ltu:CCC (match_dup 1) (match_dup 2)))\n    (set (match_dup 0)\n \t(<geultu_to_c>:QHSI (reg:CCC CC_REG) (const_int 0)))])\n+\n+;; We can fold in negation of the result and generate better code than\n+;; what the generic bits would do when testing for C == 1\n+(define_insn_and_split \"*store_neg_c\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+\t(neg:QHSI\n+\t  (ltu:QHSI (match_operand:QHSI2 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:QHSI2 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:CCC CC_REG)\n+\t(ltu:CCC (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(neg:QHSI (ne:QHSI (reg:CCC CC_REG) (const_int 0))))])\n+\n+;; We can use rotates and bst/bist to put the C bit into various places\n+;; in the destination.\n+(define_insn_and_split \"*store_shifted_c\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+       (ashift:QHSI (geultu:QHSI (match_operand:QHSI2 1 \"register_operand\" \"r\")\n+                                 (match_operand:QHSI2 2 \"register_operand\" \"r\"))\n+\t\t    (match_operand 3 \"immediate_operand\" \"n\")))]\n+  \"INTVAL (operands[3]) == 31 || INTVAL (operands[3]) <= 15\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:CCC CC_REG) (ltu:CCC (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(ashift:QHSI (<geultu_to_c>:QHSI (reg:CCC CC_REG) (const_int 0))\n+\t\t     (match_dup 3)))])\n+"}]}