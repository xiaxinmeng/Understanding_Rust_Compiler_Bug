{"sha": "2839c1513eda51e3992da102f1af6593231d10b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgzOWMxNTEzZWRhNTFlMzk5MmRhMTAyZjFhZjY1OTMyMzFkMTBiOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2007-11-25T18:09:31Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-11-25T18:09:31Z"}, "message": "unordered_map (__unordered_map<>::__unordered_map(__unordered_map&&), [...]): Add in C++0x.\n\n2007-11-25  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1_impl/unordered_map\n\t(__unordered_map<>::__unordered_map(__unordered_map&&),\n\t__unordered_multimap<>::__unordered_multimap(__unordered_multimap&&),\n\tunordered_map<>::unordered_map(unordered_map&&),\n\tunordered_multimap<>::unordered_multimap(unordered_multimap&&),\n\tunordered_map<>::operator=(unordered_map&&),\n\tunordered_multimap<>::operator=(unordered_multimap&&),\n\tswap(unordered_map<>&&, unordered_map<>&),\n\tswap(unordered_map<>&, unordered_map<>&&),\n\tswap(unordered_multimap<>&&, unordered_multimap<>&),\n\tswap(unordered_multimap<>&, unordered_multimap<>&&)): Add in C++0x.\n\t(swap(unordered_multimap<>&, unordered_multimap<>&),\n\tswap(unordered_multimap<>&, unordered_multimap<>&)): Add.\n\t* include/tr1_impl/unordered_set\n\t(__unordered_set<>::__unordered_set(__unordered_set&&),\n\t__unordered_multiset<>::__unordered_multiset(__unordered_multiset&&),\n\tunordered_set<>::unordered_set(unordered_setp&&),\n\tunordered_multiset<>::unordered_multiset(unordered_multiset&&),\n\tunordered_set<>::operator=(unordered_set&&),\n\tunordered_multiset<>::operator=(unordered_multiset&&),\n\tswap(unordered_set<>&&, unordered_set<>&),\n\tswap(unordered_set<>&, unordered_set<>&&),\n\tswap(unordered_multiset<>&&, unordered_multiset<>&),\n\tswap(unordered_multiset<>&, unordered_multiset<>&&)): Likewise.\n\t(swap(unordered_set<>&, unordered_set<>&),\n\tswap(unordered_multiset<>&, unordered_multiset<>&)): Add.\n\t* include/tr1_impl/hashtable (_Hashtable<>::_Hashtable(_Hashtable&&),\n\tswap(_Hashtable&&)): Add in C++0x.\n\t* testsuite/23_containers/unordered_map/moveable.cc: New.\n\t* testsuite/23_containers/unordered_set/moveable.cc: Likewise.\n\t* testsuite/23_containers/unordered_multimap/moveable.cc: Likewise.\n\t* testsuite/23_containers/unordered_multiset/moveable.cc: Likewise.\n\nFrom-SVN: r130412", "tree": {"sha": "0f7c79019493b4af335dc844537c9e9ec65d59be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f7c79019493b4af335dc844537c9e9ec65d59be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2839c1513eda51e3992da102f1af6593231d10b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2839c1513eda51e3992da102f1af6593231d10b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2839c1513eda51e3992da102f1af6593231d10b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2839c1513eda51e3992da102f1af6593231d10b8/comments", "author": null, "committer": null, "parents": [{"sha": "674cdfe554096ad0596ef0d88be678a556c3d438", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674cdfe554096ad0596ef0d88be678a556c3d438", "html_url": "https://github.com/Rust-GCC/gccrs/commit/674cdfe554096ad0596ef0d88be678a556c3d438"}], "stats": {"total": 435, "additions": 434, "deletions": 1}, "files": [{"sha": "fe86a8046909eadffc22a0fce940b4d006a1d503", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2839c1513eda51e3992da102f1af6593231d10b8", "patch": "@@ -1,3 +1,38 @@\n+2007-11-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1_impl/unordered_map\n+\t(__unordered_map<>::__unordered_map(__unordered_map&&),\n+\t__unordered_multimap<>::__unordered_multimap(__unordered_multimap&&),\n+\tunordered_map<>::unordered_map(unordered_map&&),\n+\tunordered_multimap<>::unordered_multimap(unordered_multimap&&),\n+\tunordered_map<>::operator=(unordered_map&&),\n+\tunordered_multimap<>::operator=(unordered_multimap&&),\n+\tswap(unordered_map<>&&, unordered_map<>&),\n+\tswap(unordered_map<>&, unordered_map<>&&),\n+\tswap(unordered_multimap<>&&, unordered_multimap<>&),\n+\tswap(unordered_multimap<>&, unordered_multimap<>&&)): Add in C++0x.\n+\t(swap(unordered_multimap<>&, unordered_multimap<>&),\n+\tswap(unordered_multimap<>&, unordered_multimap<>&)): Add.\n+\t* include/tr1_impl/unordered_set\n+\t(__unordered_set<>::__unordered_set(__unordered_set&&),\n+\t__unordered_multiset<>::__unordered_multiset(__unordered_multiset&&),\n+\tunordered_set<>::unordered_set(unordered_setp&&),\n+\tunordered_multiset<>::unordered_multiset(unordered_multiset&&),\n+\tunordered_set<>::operator=(unordered_set&&),\n+\tunordered_multiset<>::operator=(unordered_multiset&&),\n+\tswap(unordered_set<>&&, unordered_set<>&),\n+\tswap(unordered_set<>&, unordered_set<>&&),\n+\tswap(unordered_multiset<>&&, unordered_multiset<>&),\n+\tswap(unordered_multiset<>&, unordered_multiset<>&&)): Likewise.\n+\t(swap(unordered_set<>&, unordered_set<>&),\n+\tswap(unordered_multiset<>&, unordered_multiset<>&)): Add.\n+\t* include/tr1_impl/hashtable (_Hashtable<>::_Hashtable(_Hashtable&&),\n+\tswap(_Hashtable&&)): Add in C++0x.\n+\t* testsuite/23_containers/unordered_map/moveable.cc: New.\n+\t* testsuite/23_containers/unordered_set/moveable.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multimap/moveable.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multiset/moveable.cc: Likewise.\n+\n 2007-11-25  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1_impl/array (array<>::_M_check): Remove, not necessary"}, {"sha": "0efe6520a281e08d458cf07fc38fd9f84da95511", "filename": "libstdc++-v3/include/tr1_impl/hashtable", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable?ref=2839c1513eda51e3992da102f1af6593231d10b8", "patch": "@@ -217,13 +217,21 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t   const allocator_type&);\n   \n       _Hashtable(const _Hashtable&);\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      _Hashtable(_Hashtable&&);\n+#endif\n       \n       _Hashtable&\n       operator=(const _Hashtable&);\n-  \n+\n       ~_Hashtable();\n \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      void swap(_Hashtable&&);\n+#else\n       void swap(_Hashtable&);\n+#endif\n \n       // Basic container operations\n       iterator\n@@ -641,6 +649,32 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t}\n     }\n \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable(_Hashtable&& __ht)\n+    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),\n+      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t_H1, _H2, _Hash, __chc>(__ht),\n+      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n+      _M_node_allocator(__ht._M_node_allocator),\n+      _M_bucket_count(__ht._M_bucket_count),\n+      _M_element_count(__ht._M_element_count),\n+      _M_rehash_policy(__ht._M_rehash_policy),\n+      _M_buckets(__ht._M_buckets)\n+    {\n+      size_type __n_bkt = __ht._M_rehash_policy._M_next_bkt(0);\n+      __ht._M_buckets = __ht._M_allocate_buckets(__n_bkt);\n+      __ht._M_bucket_count = __n_bkt;\n+      __ht._M_element_count = 0;\n+      __ht._M_rehash_policy = _RehashPolicy();\n+    }\n+#endif\n+\n   template<typename _Key, typename _Value, \n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n@@ -675,7 +709,11 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n     void\n     _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+    swap(_Hashtable&& __x)\n+#else\n     swap(_Hashtable& __x)\n+#endif\n     {\n       // The only base class with member variables is hash_code_base.  We\n       // define _Hash_code_base::_M_swap because different specializations"}, {"sha": "5ecd5c0a9983b205b347f21cf40aef2000a7b134", "filename": "libstdc++-v3/include/tr1_impl/unordered_map", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_map?ref=2839c1513eda51e3992da102f1af6593231d10b8", "patch": "@@ -85,6 +85,11 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t__detail::_Default_ranged_hash(),\n \t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n \t{ }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      __unordered_map(__unordered_map&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+#endif\n     };\n   \n   template<class _Key, class _Tp,\n@@ -137,6 +142,11 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t__detail::_Default_ranged_hash(),\n \t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n         { }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      __unordered_multimap(__unordered_multimap&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+#endif\n     };\n \n   template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n@@ -189,6 +199,20 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t      const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n         { }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      unordered_map(unordered_map&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+\n+      unordered_map&\n+      operator=(unordered_map&& __x)\n+      {\n+\t// NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x); \n+\treturn *this;\t\n+      }\n+#endif\n     };\n   \n   template<class _Key, class _Tp,\n@@ -223,7 +247,59 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t\t   const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n         { }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      unordered_multimap(unordered_multimap&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+\n+      unordered_multimap&\n+      operator=(unordered_multimap&& __x)\n+      {\n+\t// NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x); \n+\treturn *this;\t\n+      }\n+#endif\n     };\n \n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&& __x,\n+\t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&& __x,\n+\t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&& __y)\n+    { __x.swap(__y); }\n+#endif\n+\n _GLIBCXX_END_NAMESPACE_TR1\n }"}, {"sha": "bdc1575a445b53a6b54cc414f60e64b1cbe6dcdc", "filename": "libstdc++-v3/include/tr1_impl/unordered_set", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_set?ref=2839c1513eda51e3992da102f1af6593231d10b8", "patch": "@@ -85,6 +85,11 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t__detail::_Default_ranged_hash(), __eql,\n \t\tstd::_Identity<_Value>(), __a)\n         { }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      __unordered_set(__unordered_set&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+#endif\n     };\n \n   template<class _Value,\n@@ -135,6 +140,11 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t__detail::_Default_ranged_hash(), __eql,\n \t\tstd::_Identity<_Value>(), __a)\n         { }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      __unordered_multiset(__unordered_multiset&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+#endif\n     };\n \n   template<class _Value, class _Hash, class _Pred, class _Alloc,\n@@ -187,6 +197,20 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t      const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n         { }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      unordered_set(unordered_set&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+\n+      unordered_set&\n+      operator=(unordered_set&& __x)\n+      {\n+\t// NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x); \n+\treturn *this;\t\n+      }\n+#endif\n     };\n \n   template<class _Value,\n@@ -221,7 +245,59 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t\t\t   const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n         { }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      unordered_multiset(unordered_multiset&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+\n+      unordered_multiset&\n+      operator=(unordered_multiset&& __x)\n+      {\n+\t// NB: DR 675.\n+\tthis->clear();\n+\tthis->swap(__x); \n+\treturn *this;\t\n+      }\n+#endif\n     };\n \n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>&& __x,\n+\t unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_set<_Value, _Hash, _Pred, _Alloc>&& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>&& __x,\n+\t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline void\n+    swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_multiset<_Value, _Hash, _Pred, _Alloc>&& __y)\n+    { __x.swap(__y); }\n+#endif\n+\n _GLIBCXX_END_NAMESPACE_TR1\n }"}, {"sha": "4032a74d342ab014bb1c31feb315c7a999d062d5", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/moveable.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmoveable.cc?ref=2839c1513eda51e3992da102f1af6593231d10b8", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// NOTE: This makes use of the fact that we know how moveable\n+// is implemented on map (via swap). If the implementation changed\n+// this test may begin to fail.\n+\n+#include <unordered_map>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unordered_map<int, int> a,b;\n+  a[2]=0;\n+  b[1]=0;\n+  b = std::move(a);\n+  VERIFY( b.find(2) != b.end() && a.find(1) == a.end() );\n+\n+  std::unordered_map<int, int> c(std::move(b));\n+  VERIFY( c.find(2) != c.end() );\n+  VERIFY( b.find(2) == b.end() );\n+  return 0;\n+}"}, {"sha": "96e420bc5aac40bd68915ee1ad0acbf2093c2795", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/moveable.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmoveable.cc?ref=2839c1513eda51e3992da102f1af6593231d10b8", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// NOTE: This makes use of the fact that we know how moveable\n+// is implemented on multimap (via swap). If the implementation changed\n+// this test may begin to fail.\n+\n+#include <unordered_map>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unordered_multimap<int, int> a,b;\n+  a.insert(std::make_pair(2,0));\n+  b.insert(std::make_pair(1,0));\n+  b = std::move(a);\n+  VERIFY( b.find(2) != b.end() && a.find(1) == a.end() );\n+\n+  std::unordered_multimap<int, int> c(std::move(b));\n+  VERIFY( c.find(2) != c.end() );\n+  VERIFY( b.find(2) == b.end() );\n+  return 0;\n+}"}, {"sha": "baa35a9653d87a916f311d1f82ddabc9004af4cb", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/moveable.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmoveable.cc?ref=2839c1513eda51e3992da102f1af6593231d10b8", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// NOTE: This makes use of the fact that we know how moveable\n+// is implemented on set (via swap). If the implementation changed\n+// this test may begin to fail.\n+\n+#include <unordered_set>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unordered_multiset<int> a,b;\n+  a.insert(2);\n+  b.insert(1);\n+  b = std::move(a);\n+  VERIFY( b.find(2) != b.end() && a.find(1) == a.end() );\n+\n+  std::unordered_multiset<int> c(std::move(b));\n+  VERIFY( c.find(2) != c.end() );\n+  VERIFY( b.find(2) == b.end() );\n+  return 0;\n+}"}, {"sha": "a67e9420089e105b53de5e46be3e763456a56620", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/moveable.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2839c1513eda51e3992da102f1af6593231d10b8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmoveable.cc?ref=2839c1513eda51e3992da102f1af6593231d10b8", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// NOTE: This makes use of the fact that we know how moveable\n+// is implemented on set (via swap). If the implementation changed\n+// this test may begin to fail.\n+\n+#include <unordered_set>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unordered_set<int> a,b;\n+  a.insert(2);\n+  b.insert(1);\n+  b = std::move(a);\n+  VERIFY( b.find(2) != b.end() && a.find(1) == a.end() );\n+\n+  std::unordered_set<int> c(std::move(b));\n+  VERIFY( c.find(2) != c.end() );\n+  VERIFY( b.find(2) == b.end() );\n+  return 0;\n+}"}]}