{"sha": "754e45a8679ad25d2f622919749497c16dc2ea4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU0ZTQ1YTg2NzlhZDI1ZDJmNjIyOTE5NzQ5NDk3YzE2ZGMyZWE0Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-02-27T17:26:26Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-02-27T17:26:26Z"}, "message": "re PR other/26208 (Serious problem with unwinding through signal frames)\n\n\tPR other/26208\n\t* unwind-dw2.c (struct _Unwind_Context): Add signal_frame field.\n\t(extract_cie_info): Handle S flag in augmentation string.\n\t(execute_cfa_program): If context->signal_frame, execute also\n\tfs->pc == context->ra instructions.\n\t(uw_frame_state_for): If context->signal_frame, don't subtract one\n\tfrom context->ra to find FDE.\n\t(uw_update_context_1): Set context->signal_frame to\n\tfs->signal_frame.\n\t(_Unwind_GetIPInfo): New function.\n\t* unwind-dw2.h (_Unwind_FrameState): Add signal_frame field.\n\t* unwind-c.c (PERSONALITY_FUNCTION): Use _Unwind_GetIPInfo instead\n\tof _Unwind_GetIP.\n\t* unwind-sjlj.c (_Unwind_GetIPInfo): New function.\n\t* unwind-generic.h (_Unwind_GetIPInfo): New prototype.\n\t* unwind-compat.c (_Unwind_GetIPInfo): New function.\n\t* libgcc-std.ver (_Unwind_GetIPInfo): Export @@GCC_4.2.0.\n\t* config/ia64/unwind-ia64.c (_Unwind_GetIPInfo): New function.\n\t* config/arm/unwind-arm.h (_Unwind_GetIPInfo): Define.\n\t* config/i386/linux-unwind.h (x86_fallback_frame_state,\n\tx86_64_fallback_frame_state): Set fs->signal_frame.\n\t* config/rs6000/linux-unwind.h (ppc_fallback_frame_state): Likewise.\n\t(MD_FROB_UPDATE_CONTEXT): Define unconditionally.\n\t(frob_update_context): Likewise.  Workaround missing S flag in\n\tLinux 2.6.12 - 2.6.16 kernel vDSOs.\n\t* config/s390/linux-unwind.h (s390_fallback_frame_state): Likewise.\n\tRemove the psw_addr + 1 hack.\nlibjava/\n\t* exception.cc (PERSONALITY_FUNCTION): Use _Unwind_GetIPInfo instead\n\tof _Unwind_GetIP.\n\t* include/i386-signal.h (MAKE_THROW_FRAME): Change into empty macro.\n\t(HANDLE_DIVIDE_OVERFLOW): Don't adjust _res->eip if falling through\n\tto throw.\n\t* include/x86_64-signal.h (MAKE_THROW_FRAME): Change into empty\n\tmacro.\n\t* include/powerpc-signal.h (MAKE_THROW_FRAME): Change into empty\n\tmacro.\nlibstdc++-v3/\n\t* libsupc++/eh_personality.cc (PERSONALITY_FUNCTION): Use\n\t_Unwind_GetIPInfo instead of _Unwind_GetIP.\n\nFrom-SVN: r111488", "tree": {"sha": "6984337363ffe60556818a17e48ceaa2283110bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6984337363ffe60556818a17e48ceaa2283110bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/754e45a8679ad25d2f622919749497c16dc2ea4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/754e45a8679ad25d2f622919749497c16dc2ea4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/754e45a8679ad25d2f622919749497c16dc2ea4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/754e45a8679ad25d2f622919749497c16dc2ea4c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6df11ca1befd286661b26a6a2a6774f4d4aa483c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df11ca1befd286661b26a6a2a6774f4d4aa483c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6df11ca1befd286661b26a6a2a6774f4d4aa483c"}], "stats": {"total": 287, "additions": 185, "deletions": 102}, "files": [{"sha": "baabf6a5f1a68b341fe1523f82aa9685dc2c3849", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,3 +1,33 @@\n+2006-02-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/26208\n+\t* unwind-dw2.c (struct _Unwind_Context): Add signal_frame field.\n+\t(extract_cie_info): Handle S flag in augmentation string.\n+\t(execute_cfa_program): If context->signal_frame, execute also\n+\tfs->pc == context->ra instructions.\n+\t(uw_frame_state_for): If context->signal_frame, don't subtract one\n+\tfrom context->ra to find FDE.\n+\t(uw_update_context_1): Set context->signal_frame to\n+\tfs->signal_frame.\n+\t(_Unwind_GetIPInfo): New function.\n+\t* unwind-dw2.h (_Unwind_FrameState): Add signal_frame field.\n+\t* unwind-c.c (PERSONALITY_FUNCTION): Use _Unwind_GetIPInfo instead\n+\tof _Unwind_GetIP.\n+\t* unwind-sjlj.c (_Unwind_GetIPInfo): New function.\n+\t* unwind-generic.h (_Unwind_GetIPInfo): New prototype.\n+\t* unwind-compat.c (_Unwind_GetIPInfo): New function.\n+\t* libgcc-std.ver (_Unwind_GetIPInfo): Export @@GCC_4.2.0.\n+\t* config/ia64/unwind-ia64.c (_Unwind_GetIPInfo): New function.\n+\t* config/arm/unwind-arm.h (_Unwind_GetIPInfo): Define.\n+\t* config/i386/linux-unwind.h (x86_fallback_frame_state,\n+\tx86_64_fallback_frame_state): Set fs->signal_frame.\n+\t* config/rs6000/linux-unwind.h (ppc_fallback_frame_state): Likewise.\n+\t(MD_FROB_UPDATE_CONTEXT): Define unconditionally.\n+\t(frob_update_context): Likewise.  Workaround missing S flag in\n+\tLinux 2.6.12 - 2.6.16 kernel vDSOs.\n+\t* config/s390/linux-unwind.h (s390_fallback_frame_state): Likewise.\n+\tRemove the psw_addr + 1 hack.\n+\n 2006-02-27  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-structalias.c (get_constraint_for): Move code to deal"}, {"sha": "f7cfcab88903e662f9e5aa4311037fe7531abd68", "filename": "gcc/config/arm/unwind-arm.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Fconfig%2Farm%2Funwind-arm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Fconfig%2Farm%2Funwind-arm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funwind-arm.h?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,5 +1,5 @@\n /* Header file for the ARM EABI unwinder\n-   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n    This file is free software; you can redistribute it and/or modify it\n@@ -250,6 +250,9 @@ extern \"C\" {\n #define _Unwind_GetIP(context) \\\n   (_Unwind_GetGR (context, 15) & ~(_Unwind_Word)1)\n \n+#define _Unwind_GetIP(context, ip_before_insn) \\\n+  (*ip_before_insn = 0, _Unwind_GetGR (context, 15) & ~(_Unwind_Word)1)\n+\n   static inline void\n   _Unwind_SetGR (_Unwind_Context *context, int regno, _Unwind_Word val)\n     {"}, {"sha": "07979d319b65767848585c5167854ab9afd1e28c", "filename": "gcc/config/i386/linux-unwind.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Fconfig%2Fi386%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Fconfig%2Fi386%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux-unwind.h?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,5 +1,5 @@\n /* DWARF2 EH unwinding support for AMD x86-64 and x86.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -100,6 +100,7 @@ x86_64_fallback_frame_state (struct _Unwind_Context *context,\n   fs->regs.reg[16].how = REG_SAVED_OFFSET;\n   fs->regs.reg[16].loc.offset = (long)&sc->rip - new_cfa;\n   fs->retaddr_column = 16;\n+  fs->signal_frame = 1;\n   return _URC_NO_REASON;\n }\n \n@@ -172,6 +173,7 @@ x86_fallback_frame_state (struct _Unwind_Context *context,\n   fs->regs.reg[8].how = REG_SAVED_OFFSET;\n   fs->regs.reg[8].loc.offset = (long)&sc->REG_NAME(eip) - new_cfa;\n   fs->retaddr_column = 8;\n+  fs->signal_frame = 1;\n   return _URC_NO_REASON;\n }\n #endif /* not glibc 2.0 */"}, {"sha": "fc7b20701cd6d990099b08be04fa443249ca6b74", "filename": "gcc/config/ia64/unwind-ia64.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1704,6 +1704,13 @@ _Unwind_GetIP (struct _Unwind_Context *context)\n   return context->rp;\n }\n \n+inline _Unwind_Ptr\n+_Unwind_GetIPInfo (struct _Unwind_Context *context, int *ip_before_insn)\n+{\n+  *ip_before_insn = 0;\n+  return context->rp;\n+}\n+\n /* Overwrite the return address for CONTEXT with VAL.  */\n \n inline void"}, {"sha": "d01e6b1fb329250d65244fefe578659f31a28c55", "filename": "gcc/config/rs6000/linux-unwind.h", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,5 +1,5 @@\n /* DWARF2 EH unwinding support for PowerPC and PowerPC64 Linux.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -89,26 +89,6 @@ struct gcc_ucontext\n \n enum { SIGNAL_FRAMESIZE = 128 };\n \n-/* If the current unwind info (FS) does not contain explicit info\n-   saving R2, then we have to do a minor amount of code reading to\n-   figure out if it was saved.  The big problem here is that the\n-   code that does the save/restore is generated by the linker, so\n-   we have no good way to determine at compile time what to do.  */\n-\n-#define MD_FROB_UPDATE_CONTEXT frob_update_context\n-\n-static void\n-frob_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n-{\n-  if (fs->regs.reg[2].how == REG_UNSAVED)\n-    {\n-      unsigned int *insn\n-\t= (unsigned int *) _Unwind_GetGR (context, LINK_REGISTER_REGNUM);\n-      if (*insn == 0xE8410028)\n-\t_Unwind_SetGRPtr (context, 2, context->cfa + 40);\n-    }\n-}\n-\n /* If PC is at a sigreturn trampoline, return a pointer to the\n    regs.  Otherwise return NULL.  */\n \n@@ -272,6 +252,7 @@ ppc_fallback_frame_state (struct _Unwind_Context *context,\n   fs->regs.reg[ARG_POINTER_REGNUM].how = REG_SAVED_OFFSET;\n   fs->regs.reg[ARG_POINTER_REGNUM].loc.offset = (long) &regs->nip - new_cfa;\n   fs->retaddr_column = ARG_POINTER_REGNUM;\n+  fs->signal_frame = 1;\n \n   if (hwcap == 0)\n     {\n@@ -322,3 +303,46 @@ ppc_fallback_frame_state (struct _Unwind_Context *context,\n \n   return _URC_NO_REASON;\n }\n+\n+#define MD_FROB_UPDATE_CONTEXT frob_update_context\n+\n+static void\n+frob_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  const unsigned int *pc = (const unsigned int *) context->ra;\n+\n+  /* Fix up for 2.6.12 - 2.6.16 Linux kernels that have vDSO, but don't\n+     have S flag in it.  */\n+#ifdef __powerpc64__\n+  /* addi r1, r1, 128; li r0, 0x0077; sc  (sigreturn) */\n+  /* addi r1, r1, 128; li r0, 0x00AC; sc  (rt_sigreturn) */\n+  if (pc[0] == 0x38210000 + SIGNAL_FRAMESIZE\n+      && (pc[1] == 0x38000077 || pc[1] == 0x380000AC)\n+      && pc[2] == 0x44000002)\n+    context->signal_frame = 1;\n+#else\n+  /* li r0, 0x7777; sc  (sigreturn old)  */\n+  /* li r0, 0x0077; sc  (sigreturn new)  */\n+  /* li r0, 0x6666; sc  (rt_sigreturn old)  */\n+  /* li r0, 0x00AC; sc  (rt_sigreturn new)  */\n+  if ((pc[0] == 0x38007777 || pc[0] == 0x38000077\n+       || pc[0] == 0x38006666 || pc[0] == 0x380000AC)\n+      && pc[1] == 0x44000002)\n+    context->signal_frame = 1;\n+#endif\n+\n+#ifdef __powerpc64__\n+  if (fs->regs.reg[2].how == REG_UNSAVED)\n+    {\n+      /* If the current unwind info (FS) does not contain explicit info\n+\t saving R2, then we have to do a minor amount of code reading to\n+\t figure out if it was saved.  The big problem here is that the\n+\t code that does the save/restore is generated by the linker, so\n+\t we have no good way to determine at compile time what to do.  */\n+      unsigned int *insn\n+\t= (unsigned int *) _Unwind_GetGR (context, LINK_REGISTER_REGNUM);\n+      if (*insn == 0xE8410028)\n+\t_Unwind_SetGRPtr (context, 2, context->cfa + 40);\n+    }\n+#endif\n+}"}, {"sha": "d1e9b735edbc14334aad5ced5357015ec2f7f5df", "filename": "gcc/config/s390/linux-unwind.h", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Fconfig%2Fs390%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Fconfig%2Fs390%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux-unwind.h?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,5 +1,5 @@\n /* DWARF2 EH unwinding support for S/390 Linux.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -113,27 +113,11 @@ s390_fallback_frame_state (struct _Unwind_Context *context,\n   fs->regs.reg[32].how = REG_SAVED_OFFSET;\n   fs->regs.reg[32].loc.offset = (long)&regs->psw_addr - new_cfa;\n   fs->retaddr_column = 32;\n-\n-  /* If we got a SIGSEGV or a SIGBUS, the PSW address points *to*\n-     the faulting instruction, not after it.  This causes the logic\n-     in unwind-dw2.c that decrements the RA to determine the correct\n-     CFI region to get confused.  To fix that, we *increment* the RA\n-     here in that case.  Note that we cannot modify the RA in place,\n-     and the frame state wants a *pointer*, not a value; thus we put\n-     the modified RA value into the unused register 33 slot of FS and\n-     have the register 32 save address point to that slot.\n-\n-     Unfortunately, for regular signals on old kernels, we don't know\n-     the signal number.  We default to not fiddling with the RA;\n-     that can fail in rare cases.  Upgrade your kernel.  */\n-\n-  if (signo && (*signo == 11 || *signo == 7))\n-    {\n-      fs->regs.reg[33].loc.exp =\n-\t(unsigned char *)regs->psw_addr + 1;\n-      fs->regs.reg[32].loc.offset =\n-\t(long)&fs->regs.reg[33].loc.exp - new_cfa;\n-    }\n+  /* SIGILL, SIGFPE and SIGTRAP are delivered with psw_addr\n+     after the faulting instruction rather than before it.\n+     Don't set FS->signal_frame in that case.  */\n+  if (!signo || (*signo != 4 && *signo != 5 && *signo != 8))\n+    fs->signal_frame = 1;\n \n   return _URC_NO_REASON;\n }"}, {"sha": "f8e9e52d0820d24ee70cbe6deebeff4dcb757fae", "filename": "gcc/libgcc-std.ver", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Flibgcc-std.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Flibgcc-std.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc-std.ver?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -272,4 +272,5 @@ GCC_4.2.0 {\n   __floatuntisf\n   __floatuntixf\n   __floatuntitf\n+  _Unwind_GetIPInfo\n }"}, {"sha": "cf17b6174d2c6c371613f86fbae03c652d92a6e3", "filename": "gcc/unwind-c.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-c.c?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -127,6 +127,7 @@ PERSONALITY_FUNCTION (int version,\n   lsda_header_info info;\n   const unsigned char *language_specific_data, *p, *action_record;\n   _Unwind_Ptr landing_pad, ip;\n+  int ip_before_insn = 0;\n \n #ifdef __ARM_EABI_UNWINDER__\n   if ((state & _US_ACTION_MASK) != _US_UNWIND_FRAME_STARTING)\n@@ -156,7 +157,9 @@ PERSONALITY_FUNCTION (int version,\n \n   /* Parse the LSDA header.  */\n   p = parse_lsda_header (context, language_specific_data, &info);\n-  ip = _Unwind_GetIP (context) - 1;\n+  ip = _Unwind_GetIPInfo (context, &ip_before_insn);\n+  if (! ip_before_insn)\n+    --ip;\n   landing_pad = 0;\n \n #ifdef __USING_SJLJ_EXCEPTIONS__"}, {"sha": "fa40ab27cba7bb569f3b1476978682694937ac3f", "filename": "gcc/unwind-compat.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-compat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-compat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-compat.c?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,5 +1,5 @@\n /* Backward compatibility unwind routines.\n-   Copyright (C) 2004, 2005\n+   Copyright (C) 2004, 2005, 2006\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -136,6 +136,13 @@ _Unwind_GetIP (struct _Unwind_Context *context)\n }\n symver (_Unwind_GetIP, GCC_3.0);\n \n+_Unwind_Ptr\n+_Unwind_GetIPInfo (struct _Unwind_Context *context, int *ip_before_insn)\n+{\n+  *ip_before_insn = 0;\n+  return __libunwind_Unwind_GetIP (context);\n+}\n+\n extern void *__libunwind_Unwind_GetLanguageSpecificData\n   (struct _Unwind_Context *);\n "}, {"sha": "8707391a86b1b2675d962ae26a09d10510bf2b7d", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,5 +1,5 @@\n /* DWARF2 exception handling and frame unwind runtime interface routines.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -71,6 +71,7 @@ struct _Unwind_Context\n   void *lsda;\n   struct dwarf_eh_bases bases;\n   _Unwind_Word args_size;\n+  char signal_frame;\n };\n \n /* Byte size of every register managed by these routines.  */\n@@ -207,6 +208,16 @@ _Unwind_GetIP (struct _Unwind_Context *context)\n   return (_Unwind_Ptr) context->ra;\n }\n \n+/* Retrieve the return address and flag whether that IP is before\n+   or after first not yet fully executed instruction.  */\n+\n+inline _Unwind_Ptr\n+_Unwind_GetIPInfo (struct _Unwind_Context *context, int *ip_before_insn)\n+{\n+  *ip_before_insn = context->signal_frame != 0;\n+  return (_Unwind_Ptr) context->ra;\n+}\n+\n /* Overwrite the return address for CONTEXT with VAL.  */\n \n inline void\n@@ -327,6 +338,13 @@ extract_cie_info (const struct dwarf_cie *cie, struct _Unwind_Context *context,\n \t  aug += 1;\n \t}\n \n+      /* \"S\" indicates a signal frame.  */\n+      else if (aug[0] == 'S')\n+\t{\n+\t  fs->signal_frame = 1;\n+\t  aug += 1;\n+\t}\n+\n       /* Otherwise we have an unknown augmentation string.\n \t Bail unless we saw a 'z' prefix.  */\n       else\n@@ -761,8 +779,10 @@ execute_cfa_program (const unsigned char *insn_ptr,\n      a different stack configuration that we are not interested in.  We\n      assume that the call itself is unwind info-neutral; if not, or if\n      there are delay instructions that adjust the stack, these must be\n-     reflected at the point immediately before the call insn.  */\n-  while (insn_ptr < insn_end && fs->pc < context->ra)\n+     reflected at the point immediately before the call insn.\n+     In signal frames, return address is after last completed instruction,\n+     so we add 1 to return address to make the comparison <=.  */\n+  while (insn_ptr < insn_end && fs->pc < context->ra + context->signal_frame)\n     {\n       unsigned char insn = *insn_ptr++;\n       _Unwind_Word reg, utmp;\n@@ -974,7 +994,8 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n   if (context->ra == 0)\n     return _URC_END_OF_STACK;\n \n-  fde = _Unwind_Find_FDE (context->ra - 1, &context->bases);\n+  fde = _Unwind_Find_FDE (context->ra + context->signal_frame - 1,\n+\t\t\t  &context->bases);\n   if (fde == NULL)\n     {\n #ifdef MD_FALLBACK_FRAME_STATE_FOR\n@@ -1192,6 +1213,8 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \tbreak;\n       }\n \n+  context->signal_frame = fs->signal_frame;\n+\n #ifdef MD_FROB_UPDATE_CONTEXT\n   MD_FROB_UPDATE_CONTEXT (context, fs);\n #endif"}, {"sha": "4851067fdfbc80e5e2d9e338eaa7475f7df08559", "filename": "gcc/unwind-dw2.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-dw2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-dw2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.h?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -83,6 +83,7 @@ typedef struct\n   unsigned char fde_encoding;\n   unsigned char lsda_encoding;\n   unsigned char saw_z;\n+  unsigned char signal_frame;\n   void *eh_ptr;\n } _Unwind_FrameState;\n "}, {"sha": "3f4c06530ce1e6ac9c09a66f0d51786e26f62d85", "filename": "gcc/unwind-generic.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-generic.h?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,5 +1,5 @@\n /* Exception handling and frame unwind runtime interface routines.\n-   Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003, 2004, 2006 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -155,6 +155,7 @@ extern _Unwind_Word _Unwind_GetGR (struct _Unwind_Context *, int);\n extern void _Unwind_SetGR (struct _Unwind_Context *, int, _Unwind_Word);\n \n extern _Unwind_Ptr _Unwind_GetIP (struct _Unwind_Context *);\n+extern _Unwind_Ptr _Unwind_GetIPInfo (struct _Unwind_Context *, int *);\n extern void _Unwind_SetIP (struct _Unwind_Context *, _Unwind_Ptr);\n \n /* @@@ Retrieve the CFA of the given context.  */"}, {"sha": "72c363c7af126d4166b7616b6673de1a34af4892", "filename": "gcc/unwind-sjlj.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-sjlj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/gcc%2Funwind-sjlj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-sjlj.c?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -214,6 +214,13 @@ _Unwind_GetIP (struct _Unwind_Context *context)\n   return context->fc->call_site + 1;\n }\n \n+_Unwind_Ptr\n+_Unwind_GetIPInfo (struct _Unwind_Context *context, int *ip_before_insn)\n+{\n+  *ip_before_insn = 0;\n+  return context->fc->call_site + 1;\n+}\n+\n /* Set the return landing pad index in CONTEXT.  */\n \n void"}, {"sha": "ba8b42b50c74ac5bc9a03334e11c008e46e9d997", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,3 +1,16 @@\n+2006-02-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/26208\n+\t* exception.cc (PERSONALITY_FUNCTION): Use _Unwind_GetIPInfo instead\n+\tof _Unwind_GetIP.\n+\t* include/i386-signal.h (MAKE_THROW_FRAME): Change into empty macro.\n+\t(HANDLE_DIVIDE_OVERFLOW): Don't adjust _res->eip if falling through\n+\tto throw.\n+\t* include/x86_64-signal.h (MAKE_THROW_FRAME): Change into empty\n+\tmacro.\n+\t* include/powerpc-signal.h (MAKE_THROW_FRAME): Change into empty\n+\tmacro.\n+\n 2006-02-23  Scott Gilbertson  <scottg@mantatest.com>\n \n \t* gnu/awt/j2d/IntegerGraphicsState.java (getClip): Clone clip"}, {"sha": "65bc4ed196bdbdf746596d7454ad34a2aff3e0d0", "filename": "libjava/exception.cc", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/libjava%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/libjava%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fexception.cc?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,6 +1,6 @@\n // Functions for Exception Support for Java.\n \n-/* Copyright (C) 1998, 1999, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2001, 2002, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -197,6 +197,7 @@ PERSONALITY_FUNCTION (int version,\n   int handler_switch_value;\n   bool saw_cleanup;\n   bool saw_handler;\n+  int ip_before_insn = 0;\n \n \n   // Interface version check.\n@@ -212,10 +213,10 @@ PERSONALITY_FUNCTION (int version,\n       goto install_context;\n     }\n \n-  // FIXME: In Phase 1, record _Unwind_GetIP in xh->obj as a part of\n+  // FIXME: In Phase 1, record _Unwind_GetIPInfo in xh->obj as a part of\n   // the stack trace for this exception.  This will only collect Java\n   // frames, but perhaps that is acceptable.\n-  // FIXME2: _Unwind_GetIP is nonsensical for SJLJ, being a call-site\n+  // FIXME2: _Unwind_GetIPInfo is nonsensical for SJLJ, being a call-site\n   // index instead of a PC value.  We could perhaps arrange for\n   // _Unwind_GetRegionStart to return context->fc->jbuf[1], which\n   // is the address of the handler label for __builtin_longjmp, but\n@@ -230,7 +231,9 @@ PERSONALITY_FUNCTION (int version,\n \n   // Parse the LSDA header.\n   p = parse_lsda_header (context, language_specific_data, &info);\n-  ip = _Unwind_GetIP (context) - 1;\n+  ip = _Unwind_GetIPInfo (context, &ip_before_insn);\n+  if (! ip_before_insn)\n+    --ip;\n   landing_pad = 0;\n   action_record = 0;\n   handler_switch_value = 0;"}, {"sha": "a30ceeb257f8176fc32fdd1fb09749c3417af1da", "filename": "libjava/include/i386-signal.h", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/libjava%2Finclude%2Fi386-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/libjava%2Finclude%2Fi386-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fi386-signal.h?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,7 +1,7 @@\n // i386-signal.h - Catch runtime signals and turn them into exceptions\n // on an i386 based Linux system.\n \n-/* Copyright (C) 1998, 1999, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2001, 2002, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -22,19 +22,7 @@ details.  */\n #define SIGNAL_HANDLER(_name)\t\\\n static void _name (int _dummy __attribute__ ((__unused__)))\n \n-#define MAKE_THROW_FRAME(_exception)\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  void **_p = (void **)&_dummy;\t\t\t\t\t\t\\\n-  volatile struct sigcontext_struct *_regs = (struct sigcontext_struct *)++_p;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* Advance the program counter so that it is after the start of the\t\\\n-     instruction:  the x86 exception handler expects\t\t\t\\\n-     the PC to point to the instruction after a call. */\t\t\\\n-  _regs->eip += 2;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+#define MAKE_THROW_FRAME(_exception)\n \n #define HANDLE_DIVIDE_OVERFLOW\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n@@ -91,14 +79,6 @@ do\t\t\t\t\t\t\t\t\t\\\n \t  _regs->eip = (unsigned long)_eip;\t\t\t\t\\\n \t  return;\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  /* Advance the program counter so that it is after the start\t\\\n-\t     of the instruction: this is because the x86 exception\t\\\n-\t     handler expects the PC to point to the instruction after a\t\\\n-\t     call. */\t\t\t\t\t\t\t\\\n-\t  _regs->eip += 2;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n while (0)"}, {"sha": "66133e96d0e9aca19607e9e4aa9bdc86980c9263", "filename": "libjava/include/powerpc-signal.h", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/libjava%2Finclude%2Fpowerpc-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/libjava%2Finclude%2Fpowerpc-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fpowerpc-signal.h?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,7 +1,7 @@\n // powerpc-signal.h - Catch runtime signals and turn them into exceptions\n // on a powerpc based Linux system.\n \n-/* Copyright (C) 2003  Free Software Foundation\n+/* Copyright (C) 2003, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -22,18 +22,12 @@ details.  */\n #define SIGNAL_HANDLER(_name)\t\t\t\t\t\t\\\n   static void _name (int /* _signal */, struct sigcontext *_sc)\n \n-/* PPC either leaves PC pointing at a faulting instruction or the\n-   following instruction, depending on the signal.  SEGV always does\n-   the former, so we adjust the saved PC to point to the following\n-   instruction. This is what the handler in libgcc expects.  */\n+/* MD_FALBACK_FRAME_STATE_FOR takes care of special casing PC\n+   before the faulting instruction, so we don't need to do anything\n+   here.  */\n+\n+#define MAKE_THROW_FRAME(_exception)\n \n-#define MAKE_THROW_FRAME(_exception)\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    _sc->regs->nip += 4;\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-  \n /* For an explanation why we cannot simply use sigaction to\n    install the handlers, see i386-signal.h.  */\n "}, {"sha": "b4b4c2b988cd1fb113079b7f78c44130e1737842", "filename": "libjava/include/x86_64-signal.h", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/libjava%2Finclude%2Fx86_64-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/libjava%2Finclude%2Fx86_64-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fx86_64-signal.h?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,7 +1,7 @@\n // x86_64-signal.h - Catch runtime signals and turn them into exceptions\n // on an x86_64 based GNU/Linux system.\n \n-/* Copyright (C) 2003  Free Software Foundation\n+/* Copyright (C) 2003, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -34,16 +34,7 @@ extern \"C\"\n   };\n }\n \n-#define MAKE_THROW_FRAME(_exception)\t\t\t\t\t     \\\n-do\t\t\t\t\t\t\t\t\t     \\\n-{\t\t\t\t\t\t\t\t\t     \\\n-  /* Advance the program counter so that it is after the start of the\t     \\\n-     instruction:  the x86_64 exception handler expects\t\t\t     \\\n-     the PC to point to the instruction after a call. */\t\t     \\\n-  struct ucontext *_uc = (struct ucontext *)_p;\t\t\t\t     \\\n-  _uc->uc_mcontext.gregs[REG_RIP] += 2;\t\t\t\t     \t     \\\n-}\t\t\t\t\t\t\t\t\t     \\\n-while (0)\n+#define MAKE_THROW_FRAME(_exception)\n \n #define RESTORE(name, syscall) RESTORE2 (name, syscall)\n #define RESTORE2(name, syscall)\t\t\t\\"}, {"sha": "1745127b84c2ac7c1ee39f76da32f9ba51ec806c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -1,3 +1,9 @@\n+2006-02-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/26208\n+\t* libsupc++/eh_personality.cc (PERSONALITY_FUNCTION): Use\n+\t_Unwind_GetIPInfo instead of _Unwind_GetIP.\n+\n 2006-02-27  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/14866"}, {"sha": "6832f7ceff143add2598737a152d9134a85fe722", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754e45a8679ad25d2f622919749497c16dc2ea4c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754e45a8679ad25d2f622919749497c16dc2ea4c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=754e45a8679ad25d2f622919749497c16dc2ea4c", "patch": "@@ -364,6 +364,7 @@ PERSONALITY_FUNCTION (int version,\n   int handler_switch_value;\n   void* thrown_ptr = ue_header + 1;\n   bool foreign_exception;\n+  int ip_before_insn = 0;\n \n #ifdef __ARM_EABI_UNWINDER__\n   _Unwind_Action actions;\n@@ -430,7 +431,9 @@ PERSONALITY_FUNCTION (int version,\n   // Parse the LSDA header.\n   p = parse_lsda_header (context, language_specific_data, &info);\n   info.ttype_base = base_of_encoded_value (info.ttype_encoding, context);\n-  ip = _Unwind_GetIP (context) - 1;\n+  ip = _Unwind_GetIPInfo (context, &ip_before_insn);\n+  if (! ip_before_insn)\n+    --ip;\n   landing_pad = 0;\n   action_record = 0;\n   handler_switch_value = 0;"}]}