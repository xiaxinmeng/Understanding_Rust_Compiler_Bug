{"sha": "b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhhMTgyMTYxNGNiZjdlNWMxMTdiZjBhN2EyMTVlM2MzYTgxZjhjMw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2015-10-20T09:40:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T09:40:24Z"}, "message": "sem_ch3.adb (Check_Nonoverridable_Aspects): New procedure within Analyze_Full_Type_ Declaration...\n\n2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Check_Nonoverridable_Aspects): New procedure within\n\tAnalyze_Full_Type_ Declaration, used to apply legality rules in\n\t13,1,1 (18.3.3) concerning aspects that cannot be overridden in\n\ta type extension.\n\t(Check_Duplicate_Aspects): It is not legal to specify the\n\tImplicit_Dereference aspect on a full view if partial view has\n\tknown discriminants.\n\t* sem_ch13.adb (Analyze_Aspect_Implicit_Dereference): Verify that\n\tthe specification of the aspect on a derived type confirms the\n\tvalue of the inherited one.\n\t* sem_util.adb (Reference_Discriminant): Return empty if none\n\tspecified.\n\nFrom-SVN: r229026", "tree": {"sha": "f18fb1840f423106114e1684348a5d6f055af675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f18fb1840f423106114e1684348a5d6f055af675"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d9147bb633645dc2e3844eee2d61217de5544a98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9147bb633645dc2e3844eee2d61217de5544a98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9147bb633645dc2e3844eee2d61217de5544a98"}], "stats": {"total": 211, "additions": 176, "deletions": 35}, "files": [{"sha": "2bfc5079f54c8ed0f14f3a190d93353288e6303b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3", "patch": "@@ -1,3 +1,18 @@\n+2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Check_Nonoverridable_Aspects): New procedure within\n+\tAnalyze_Full_Type_ Declaration, used to apply legality rules in\n+\t13,1,1 (18.3.3) concerning aspects that cannot be overridden in\n+\ta type extension.\n+\t(Check_Duplicate_Aspects): It is not legal to specify the\n+\tImplicit_Dereference aspect on a full view if partial view has\n+\tknown discriminants.\n+\t* sem_ch13.adb (Analyze_Aspect_Implicit_Dereference): Verify that\n+\tthe specification of the aspect on a derived type confirms the\n+\tvalue of the inherited one.\n+\t* sem_util.adb (Reference_Discriminant): Return empty if none\n+\tspecified.\n+\n 2015-10-20  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_ch5.adb, sem_ch3.adb: Minor reformatting."}, {"sha": "5de48ddbfaec6e3ff86adf87c4ff3c13885031e0", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3", "patch": "@@ -1444,35 +1444,56 @@ package body Sem_Ch13 is\n             -----------------------------------------\n \n             procedure Analyze_Aspect_Implicit_Dereference is\n+               Disc        : Entity_Id;\n+               Parent_Disc : Entity_Id;\n+\n+               --  For a type extension, check whether parent has a\n+               --  reference discriminant, to verify that use is proper.\n+\n             begin\n                if not Is_Type (E) or else not Has_Discriminants (E) then\n                   Error_Msg_N\n-                    (\"aspect must apply to a type with discriminants\", N);\n+                    (\"aspect must apply to a type with discriminants\", Expr);\n \n-               else\n-                  declare\n-                     Disc : Entity_Id;\n+               elsif not Is_Entity_Name (Expr) then\n+                  Error_Msg_N\n+                    (\"aspect must name a discriminant of current type\", Expr);\n \n-                  begin\n-                     Disc := First_Discriminant (E);\n-                     while Present (Disc) loop\n-                        if Chars (Expr) = Chars (Disc)\n-                          and then Ekind (Etype (Disc)) =\n-                                     E_Anonymous_Access_Type\n-                        then\n-                           Set_Has_Implicit_Dereference (E);\n-                           Set_Has_Implicit_Dereference (Disc);\n-                           return;\n-                        end if;\n+               else\n+                  Disc := First_Discriminant (E);\n+                  while Present (Disc) loop\n+                     if Chars (Expr) = Chars (Disc)\n+                       and then Ekind (Etype (Disc)) =\n+                                  E_Anonymous_Access_Type\n+                     then\n+                        Set_Has_Implicit_Dereference (E);\n+                        Set_Has_Implicit_Dereference (Disc);\n+                        exit;\n+                     end if;\n \n-                        Next_Discriminant (Disc);\n-                     end loop;\n+                     Next_Discriminant (Disc);\n+                  end loop;\n \n-                     --  Error if no proper access discriminant.\n+                  --  Error if no proper access discriminant.\n \n+                  if No (Disc) then\n                      Error_Msg_NE\n                       (\"not an access discriminant of&\", Expr, E);\n-                  end;\n+                     return;\n+                  end if;\n+               end if;\n+\n+               if Is_Derived_Type (E)\n+                 and then Has_Discriminants (Etype (E))\n+               then\n+                  Parent_Disc := Get_Reference_Discriminant (Etype (E));\n+\n+                  if Present (Parent_Disc)\n+                    and then Corresponding_Discriminant (Disc) /= Parent_Disc\n+                  then\n+                     Error_Msg_N (\"reference discriminant does not match \" &\n+                       \"discriminant of parent type\", Expr);\n+                  end if;\n                end if;\n             end Analyze_Aspect_Implicit_Dereference;\n "}, {"sha": "2000f425bfbe64a56658a528217c2fda2d7ac487", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 120, "deletions": 13, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3", "patch": "@@ -2567,6 +2567,10 @@ package body Sem_Ch3 is\n                       and then not (In_Private_Part (Current_Scope)\n                                      or else In_Package_Body (Current_Scope));\n \n+      procedure Check_Nonoverridable_Aspects;\n+      --  Apply the rule in RM 13.1.1(18.4/4) on iterator aspects that cannot\n+      --  be overridden, and can only be confirmed on derivation.\n+\n       procedure Check_Ops_From_Incomplete_Type;\n       --  If there is a tagged incomplete partial view of the type, traverse\n       --  the primitives of the incomplete view and change the type of any\n@@ -2575,6 +2579,90 @@ package body Sem_Ch3 is\n       --  list later in Sem_Disp.Check_Operation_From_Incomplete_Type (which\n       --  is called from Process_Incomplete_Dependents).\n \n+      ----------------------------------\n+      -- Check_Nonoverridable_Aspects --\n+      ----------------------------------\n+\n+      procedure Check_Nonoverridable_Aspects is\n+         Prev_Aspects   : constant List_Id :=\n+                            Aspect_Specifications (Parent (Def_Id));\n+         Par_Type       : Entity_Id;\n+\n+         function Has_Aspect_Spec\n+           (Specs : List_Id;\n+            Aspect_Name : Name_Id) return Boolean;\n+         --  Check whether a list of aspect specifications includes an entry\n+         --  for a specific aspect. The list is either that of a partial or\n+         --  a full view.\n+\n+         ---------------------\n+         -- Has_Aspect_Spec --\n+         ---------------------\n+\n+         function Has_Aspect_Spec\n+           (Specs : List_Id;\n+            Aspect_Name : Name_Id) return Boolean\n+         is\n+            Spec : Node_Id;\n+         begin\n+            Spec := First (Specs);\n+            while Present (Spec) loop\n+               if Chars (Identifier (Spec)) = Aspect_Name then\n+                  return True;\n+               end if;\n+               Next (Spec);\n+            end loop;\n+            return False;\n+         end Has_Aspect_Spec;\n+\n+         --  Start of processing for Check_Nonoverridable_Aspects\n+\n+      begin\n+\n+         --  Get parent type of derived type. Note that Prev is the entity\n+         --  in the partial declaration, but its contents are now those of\n+         --  full view, while Def_Id reflects the partial view.\n+\n+         if Is_Private_Type (Def_Id) then\n+            Par_Type := Etype (Full_View (Def_Id));\n+         else\n+            Par_Type := Etype (Def_Id);\n+         end if;\n+\n+         --  If there is an inherited Implicit_Dereference, verify that it is\n+         --  made explicit in the partial view.\n+\n+         if Has_Discriminants (Base_Type (Par_Type))\n+           and then Nkind (Parent (Prev)) = N_Full_Type_Declaration\n+           and then Present (Discriminant_Specifications (Parent (Prev)))\n+           and then Present (Get_Reference_Discriminant (Par_Type))\n+         then\n+            if\n+              not Has_Aspect_Spec (Prev_Aspects, Name_Implicit_Dereference)\n+            then\n+               Error_Msg_N\n+                 (\"type does not inherit implicit dereference\", Prev);\n+\n+            else\n+               --  If one of the views has the aspect specified, verify that it\n+               --  is consistent with that of the parent.\n+\n+               declare\n+                  Par_Discr : constant Entity_Id :=\n+                                Get_Reference_Discriminant (Par_Type);\n+                  Cur_Discr : constant Entity_Id :=\n+                                Get_Reference_Discriminant (Prev);\n+               begin\n+                  if Corresponding_Discriminant (Cur_Discr) /= Par_Discr then\n+                     Error_Msg_N (\"aspect incosistent with that of parent\", N);\n+                  end if;\n+               end;\n+            end if;\n+         end if;\n+\n+         --  TBD : other nonoverridable aspects.\n+      end Check_Nonoverridable_Aspects;\n+\n       ------------------------------------\n       -- Check_Ops_From_Incomplete_Type --\n       ------------------------------------\n@@ -2894,6 +2982,12 @@ package body Sem_Ch3 is\n             Analyze_Aspect_Specifications (N, Def_Id);\n          end if;\n       end if;\n+\n+      if Is_Derived_Type (Prev)\n+        and then Def_Id /= Prev\n+      then\n+         Check_Nonoverridable_Aspects;\n+      end if;\n    end Analyze_Full_Type_Declaration;\n \n    ----------------------------------\n@@ -16366,28 +16460,41 @@ package body Sem_Ch3 is\n       -----------------------------\n       -- Check_Duplicate_Aspects --\n       -----------------------------\n+\n       procedure Check_Duplicate_Aspects is\n          Prev_Aspects   : constant List_Id := Aspect_Specifications (Prev_Par);\n          Full_Aspects   : constant List_Id := Aspect_Specifications (N);\n          F_Spec, P_Spec : Node_Id;\n \n       begin\n-         if Present (Prev_Aspects) and then Present (Full_Aspects) then\n+         if Present (Full_Aspects) then\n             F_Spec := First (Full_Aspects);\n             while Present (F_Spec) loop\n-               P_Spec := First (Prev_Aspects);\n-               while Present (P_Spec) loop\n-                  if Chars (Identifier (P_Spec)) = Chars (Identifier (F_Spec))\n-                  then\n-                     Error_Msg_N\n-                       (\"aspect already specified in private declaration\",\n-                         F_Spec);\n-                     Remove (F_Spec);\n-                     return;\n-                  end if;\n+               if Present (Prev_Aspects) then\n+                  P_Spec := First (Prev_Aspects);\n+                  while Present (P_Spec) loop\n+                     if Chars (Identifier (P_Spec)) =\n+                       Chars (Identifier (F_Spec))\n+                     then\n+                        Error_Msg_N\n+                          (\"aspect already specified in private declaration\",\n+                            F_Spec);\n+                        Remove (F_Spec);\n+                        return;\n+                     end if;\n \n-                  Next (P_Spec);\n-               end loop;\n+                     Next (P_Spec);\n+                  end loop;\n+               end if;\n+\n+               if Has_Discriminants (Prev)\n+                 and then not Has_Unknown_Discriminants (Prev)\n+                 and then Chars (Identifier (F_Spec)) =\n+                   Name_Implicit_Dereference\n+               then\n+                  Error_Msg_N (\"cannot specify aspect \" &\n+                    \"if partial view has known discriminants\", F_Spec);\n+               end if;\n \n                Next (F_Spec);\n             end loop;"}, {"sha": "ce64755940d202778d3ce713dd1a0fc4f8b1a939", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b8a1821614cbf7e5c117bf0a7a215e3c3a81f8c3", "patch": "@@ -7812,9 +7812,7 @@ package body Sem_Util is\n          Next_Discriminant (D);\n       end loop;\n \n-      --  Type must have a proper access discriminant.\n-\n-      pragma Assert (False);\n+      return Empty;\n    end Get_Reference_Discriminant;\n \n    ---------------------------"}]}