{"sha": "5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU2YTQyZDllNDVmZDE5M2IzY2M2ZDFhNDFmNjYwNGI4MTQ3ZTZhZg==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-01-09T18:46:10Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-01-09T18:46:10Z"}, "message": "c4x.c: Include system.h.\n\n\t* config/c4x/c4x.c: Include system.h.\n \t(c4x_caller_save_map): Disable caller save for RC.\n\t(c4x_optimization_options): Disable scheduling before reload.\n\t(valid_parallel_load_store) : Define return type as int.\n\tRemove unused variable regs.\n\t* config/c4x/c4x.h (REGISTER_MOVE_COST): Make independent of register\n\tclass.\n\t* config/c4x/c4x.md (rotlqi3, rotrqi3): Fix up emitted RTL to\n\thandle rotations.\n\t(*db, decrement_and_branch_until_zero): Fix up constraints\n\tto keep reload happy.\n\nFrom-SVN: r24600", "tree": {"sha": "99736145687a806d69e0834746287f4e72a10354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99736145687a806d69e0834746287f4e72a10354"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af/comments", "author": null, "committer": null, "parents": [{"sha": "dfa27ef1db156b9c72a8f0a4164c507a613f5b6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfa27ef1db156b9c72a8f0a4164c507a613f5b6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfa27ef1db156b9c72a8f0a4164c507a613f5b6c"}], "stats": {"total": 96, "additions": 67, "deletions": 29}, "files": [{"sha": "6e510aa6f70a3feccde681e424ae7ef21401ae7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af", "patch": "@@ -1,3 +1,17 @@\n+Sun Jan 10 15:35:41 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c: Include system.h.\n+ \t(c4x_caller_save_map): Disable caller save for RC.\n+\t(c4x_optimization_options): Disable scheduling before reload.\n+\t(valid_parallel_load_store) : Define return type as int.  \n+\tRemove unused variable regs.\n+\t* config/c4x/c4x.h (REGISTER_MOVE_COST): Make independent of register\n+\tclass.\n+\t* config/c4x/c4x.md (rotlqi3, rotrqi3): Fix up emitted RTL to\n+\thandle rotations.\n+\t(*db, decrement_and_branch_until_zero): Fix up constraints\n+\tto keep reload happy.\n+\n Sat Jan  9 18:35:29 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* tree.c (make_node): Call bzero instead of inline clear."}, {"sha": "f8a643185009ca312b4ac0294a7c4faa57aeda53", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for assembler code output on the TMS320C[34]x\n-   Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1994-98, 1999 Free Software Foundation, Inc.\n \n    Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n               and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n@@ -22,10 +22,8 @@\n    Boston, MA 02111-1307, USA.  */\n \n /* Some output-actions in c4x.md need these.  */\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <stdarg.h>\n #include \"config.h\"\n+#include \"system.h\"\n #include \"toplev.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n@@ -121,7 +119,7 @@ enum machine_mode c4x_caller_save_map[FIRST_PSEUDO_REGISTER] =\n   VOIDmode,\t\t\t/* IIF/IOF                      No  */\n   QImode,\t\t\t/* RS           QI              No  */\n   QImode,\t\t\t/* RE           QI              No  */\n-  QImode,\t\t\t/* RC           QI              No  */\n+  VOIDmode,\t\t\t/* RC           QI              No  */\n   QFmode,\t\t\t/* R8           QI, QF, HF      QI  */\n   HFmode,\t\t\t/* R9           QI, QF, HF      No  */\n   HFmode,\t\t\t/* R10          QI, QF, HF      No  */\n@@ -202,11 +200,6 @@ c4x_override_options ()\n   /* Convert foo / 8.0 into foo * 0.125, etc.  */\n   flag_fast_math = 1;\n \n-  /* We should phase out the following at some stage.\n-     This provides compatibility with the old -mno-rptb option.  */\n-  if (! TARGET_RPTB && flag_branch_on_count_reg)\n-    flag_branch_on_count_reg = 0;\n-\n   /* We should phase out the following at some stage.\n      This provides compatibility with the old -mno-aliases option.  */\n   if (! TARGET_ALIASES && ! flag_argument_noalias)\n@@ -219,6 +212,12 @@ c4x_optimization_options (level, size)\n      int level;\n      int size ATTRIBUTE_UNUSED;\n {\n+  /* Scheduling before register allocation can screw up global\n+     register allocation, especially for functions that use MPY||ADD\n+     instructions.  The benefit we gain we get by scheduling before\n+     register allocation is probably marginal anyhow.  */\n+  flag_schedule_insns = 0;\n+\n   /* When optimizing, enable use of RPTB instruction.  */\n   if (level >= 1)\n     flag_branch_on_count_reg = 1;\n@@ -3194,6 +3193,7 @@ c4x_label_conflict (insn, jump, db)\n \n /* Validate combination of operands for parallel load/store instructions.  */\n \n+int\n valid_parallel_load_store (operands, mode)\n      rtx *operands;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n@@ -3254,7 +3254,6 @@ valid_parallel_operands_4 (operands, mode)\n      rtx *operands;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  int regs = 0;\n   rtx op0 = operands[0];\n   rtx op2 = operands[2];\n "}, {"sha": "2a0a7c045d480b4fb24dacd8bae2c4dbc51afef2", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  TMS320C[34]x\n-   Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1994-98, 1999 Free Software Foundation, Inc.\n \n    Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n               and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n@@ -1713,11 +1713,10 @@ if (REG_P (OP1) && ! REG_P (OP0))\t\t\t\\\n #define EXPENSIVE_CLASS_P(CLASS) (ADDR_CLASS_P(CLASS) \\\n                           || INDEX_CLASS_P(CLASS) || (CLASS) == SP_REG)\n \n-/* Make the Rx register a little easier to use so they are used for\n-   calculations and the ARx registers are used for addressing. */\n+/* Compute extra cost of moving data between one register class\n+   and another.  */\n \n-#define REGISTER_MOVE_COST(FROM, TO) \\\n-(EXPENSIVE_CLASS_P(TO) ? 5 : EXPENSIVE_CLASS_P(FROM) ? 4 : 3)\n+#define REGISTER_MOVE_COST(FROM, TO)\t2\n \n /* Memory move cost is same as fast register move.  Maybe this should\n    be bumped up? */"}, {"sha": "1e3d343eba4b33743ba8e8728c06e5d69406e2cb", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=5e6a42d9e45fd193b3cc6d1a41f6604b8147e6af", "patch": "@@ -1,7 +1,7 @@\n ;; Machine description for the TMS320C[34]x for GNU C compiler\n-;; Copyright (C) 1994, 95-98, 1999 Free Software Foundation, Inc.\n+;; Copyright (C) 1994-98, 1999 Free Software Foundation, Inc.\n \n-;; Contributed by Michael Hayes (m.hayes@elec.canterbury.cri.nz)\n+;; Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n ;;            and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl)\n \n ;; This file is part of GNU CC.\n@@ -369,7 +369,7 @@\n \n (define_attr \"in_annul_slot_3\" \"false,true\"\n   (if_then_else (and (eq_attr \"cpu\" \"c4x\")\n-\t\t     (eq_attr \"type\" \"!jump,call,rets,jmpc,db,dbc,repeat,repeat_top,laj,push,pop,multi\"))\n+\t\t     (eq_attr \"type\" \"!jump,call,rets,jmpc,unarycc,binarycc,db,dbc,repeat,repeat_top,laj,push,pop,multi\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n@@ -1458,19 +1458,26 @@\n                               (match_operand:QI 2 \"const_int_operand\" \"\")))\n               (clobber (reg:CC 21))])]\n   \"\"\n-  \"if (INTVAL (operands[2]) >= 4)\n+  \"if (INTVAL (operands[2]) > 4)\n      FAIL; /* Open code as two shifts and an or */\n    if (INTVAL (operands[2]) > 1)\n      {\n         int i;\n+\trtx tmp;\n \n         /* If we have 4 or fewer shifts, then it is probably faster\n            to emit separate ROL instructions.  A C3x requires\n            at least 4 instructions (a C4x requires at least 3), to\n            perform a rotation by shifts.  */\n \n-        for (i = 0; i < INTVAL (operands[2]); i++)\n-          emit_insn (gen_rotl_1_clobber (operands[0], operands[1]));\n+\ttmp = operands[1];\n+        for (i = 0; i < INTVAL (operands[2]) - 1; i++)\n+\t  {\n+   \t    tmp = gen_reg_rtx (QImode);\n+            emit_insn (gen_rotl_1_clobber (tmp, operands[1]));\n+\t    operands[1] = tmp;\n+\t  }\n+        emit_insn (gen_rotl_1_clobber (operands[0], tmp));\n         DONE;\n      }\")\n \n@@ -1493,19 +1500,26 @@\n                                 (match_operand:QI 2 \"const_int_operand\" \"\")))\n               (clobber (reg:CC 21))])]\n   \"\"\n-  \"if (INTVAL (operands[2]) >= 4)\n+  \"if (INTVAL (operands[2]) > 4)\n      FAIL; /* Open code as two shifts and an or */\n    if (INTVAL (operands[2]) > 1)\n      {\n         int i;\n+\trtx tmp;\n  \n         /* If we have 4 or fewer shifts, then it is probably faster\n            to emit separate ROL instructions.  A C3x requires\n            at least 4 instructions (a C4x requires at least 3), to\n            perform a rotation by shifts.  */\n  \n-        for (i = 0; i < INTVAL (operands[2]); i++)\n-          emit_insn (gen_rotr_1_clobber (operands[0], operands[1]));\n+\ttmp = operands[1];\n+        for (i = 0; i < INTVAL (operands[2]) - 1; i++)\n+\t  {\n+   \t    tmp = gen_reg_rtx (QImode);\n+            emit_insn (gen_rotr_1_clobber (tmp, operands[1]));\n+\t    operands[1] = tmp;\n+\t  }\n+        emit_insn (gen_rotr_1_clobber (operands[0], tmp));\n         DONE;\n      }\")\n \n@@ -4484,11 +4498,11 @@\n ; have an option to disable this instruction.\n (define_insn \"*db\"\n   [(set (pc)\n-        (if_then_else (ne (match_operand:QI 2 \"addr_reg_operand\" \"0,0,0,0\")\n+        (if_then_else (ne (match_operand:QI 0 \"addr_reg_operand\" \"+a,?*d,??*r,!m\")\n                           (const_int 0))\n                       (label_ref (match_operand 1 \"\" \"\"))\n                       (pc)))\n-   (set (match_operand:QI 0 \"addr_reg_operand\" \"+a,?*d,??*r,!m\")\n+   (set (match_dup 0)\n         (plus:QI (match_dup 0)\n                  (const_int -1)))\n    (clobber (reg:CC_NOOV 21))]\n@@ -4505,14 +4519,26 @@\n   \"\n   [(set_attr \"type\" \"db,jmpc,jmpc,jmpc\")])\n \n+\n+; This insn is used for some loop tests, typically loops reversed when\n+; strength reduction is used.  It is actually created when the instruction\n+; combination phase combines the special loop test.  Since this insn\n+; is both a jump insn and has an output, it must deal with its own\n+; reloads, hence the `m' constraints. \n+\n+; The C4x does the decrement and then compares the result against zero.\n+; It branches if the result was greater than or equal to zero.\n+; In the RTL the comparison and decrement are assumed to happen\n+; at the same time so we bias the iteration counter with by -1\n+; when we make the test.\n (define_insn \"decrement_and_branch_until_zero\"\n   [(set (pc)\n-        (if_then_else (ge (plus:QI (match_operand:QI 2 \"addr_reg_operand\" \"0,0,0,0\")\n+        (if_then_else (ge (plus:QI (match_operand:QI 0 \"addr_reg_operand\" \"+a,?*d,??*r,!m\")\n \t\t\t           (const_int -1))\n \t\t\t  (const_int 0))\n                       (label_ref (match_operand 1 \"\" \"\"))\n                       (pc)))\n-   (set (match_operand:QI 0 \"addr_reg_operand\" \"+a,?*d,??*r,!m\")\n+   (set (match_dup 0)\n         (plus:QI (match_dup 0)\n                  (const_int -1)))\n    (clobber (reg:CC_NOOV 21))]"}]}