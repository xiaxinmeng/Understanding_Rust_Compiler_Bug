{"sha": "74a15d1424da560bb599fe781ccbef070372a477", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRhMTVkMTQyNGRhNTYwYmI1OTlmZTc4MWNjYmVmMDcwMzcyYTQ3Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-02-08T09:21:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-02-08T09:21:57Z"}, "message": "re PR tree-optimization/79408 (Missed VRP optimization of integer modulo)\n\n\tPR tree-optimization/79408\n\t* tree-vrp.c (simplify_div_or_mod_using_ranges): If op1 is not\n\tconstant, but SSA_NAME with a known integer range, use the minimum\n\tof that range instead of op1 to determine if modulo can be replaced\n\twith its first operand.\n\n\t* gcc.dg/tree-ssa/pr79408.c: New test.\n\nFrom-SVN: r245273", "tree": {"sha": "ab1c196bea449e8d75b31dfc1fabc401ae65b2d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab1c196bea449e8d75b31dfc1fabc401ae65b2d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74a15d1424da560bb599fe781ccbef070372a477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74a15d1424da560bb599fe781ccbef070372a477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74a15d1424da560bb599fe781ccbef070372a477", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74a15d1424da560bb599fe781ccbef070372a477/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "01726bc97785f6e66d6d882bf2b81077391603c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01726bc97785f6e66d6d882bf2b81077391603c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01726bc97785f6e66d6d882bf2b81077391603c5"}], "stats": {"total": 81, "additions": 71, "deletions": 10}, "files": [{"sha": "67dc9b12badc0181198471b9b0ae19073b26496e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a15d1424da560bb599fe781ccbef070372a477/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a15d1424da560bb599fe781ccbef070372a477/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74a15d1424da560bb599fe781ccbef070372a477", "patch": "@@ -1,3 +1,11 @@\n+2017-02-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/79408\n+\t* tree-vrp.c (simplify_div_or_mod_using_ranges): If op1 is not\n+\tconstant, but SSA_NAME with a known integer range, use the minimum\n+\tof that range instead of op1 to determine if modulo can be replaced\n+\twith its first operand.\n+\n 2016-02-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/riscv/riscv.c (riscv_build_integer_1): Avoid use of INT16_MAX."}, {"sha": "0f0517de97a840070ae335f594f019c114adb1ae", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a15d1424da560bb599fe781ccbef070372a477/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a15d1424da560bb599fe781ccbef070372a477/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=74a15d1424da560bb599fe781ccbef070372a477", "patch": "@@ -1,3 +1,8 @@\n+2017-02-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/79408\n+\t* gcc.dg/tree-ssa/pr79408.c: New test.\n+\n 2017-02-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/71824"}, {"sha": "2ea24f432a6d9a07e80d8fb01e7fa33d2d23f789", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr79408.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a15d1424da560bb599fe781ccbef070372a477/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79408.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a15d1424da560bb599fe781ccbef070372a477/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79408.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79408.c?ref=74a15d1424da560bb599fe781ccbef070372a477", "patch": "@@ -0,0 +1,40 @@\n+/* PR tree-optimization/79408 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+void link_error (void);\n+\n+void\n+foo (unsigned int x, unsigned int y)\n+{\n+  if (x > 7312)\n+    return;\n+  if (y <= 7312)\n+    return;\n+  if (x % y != x)\n+    link_error ();\n+}\n+\n+void\n+bar (int x, int y)\n+{\n+  if (x > 7312 || x < 0)\n+    return;\n+  if (y <= 7312)\n+    return;\n+  if (x % y != x)\n+    link_error ();\n+}\n+\n+void\n+baz (int x, int y)\n+{\n+  if (x > 7312 || x < -7312)\n+    return;\n+  if (y <= 7312)\n+    return;\n+  if (x % y != x)\n+    link_error ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\"} } */"}, {"sha": "e058d8d0eff1cbbb2cf63a76fc63eebe81e213d5", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a15d1424da560bb599fe781ccbef070372a477/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a15d1424da560bb599fe781ccbef070372a477/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=74a15d1424da560bb599fe781ccbef070372a477", "patch": "@@ -9226,12 +9226,12 @@ simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n   return true;\n }\n \n-/* Simplify a division or modulo operator to a right shift or\n-   bitwise and if the first operand is unsigned or is greater\n-   than zero and the second operand is an exact power of two.\n-   For TRUNC_MOD_EXPR op0 % op1 with constant op1, optimize it\n-   into just op0 if op0's range is known to be a subset of\n-   [-op1 + 1, op1 - 1] for signed and [0, op1 - 1] for unsigned\n+/* Simplify a division or modulo operator to a right shift or bitwise and\n+   if the first operand is unsigned or is greater than zero and the second\n+   operand is an exact power of two.  For TRUNC_MOD_EXPR op0 % op1 with\n+   constant op1 (op1min = op1) or with op1 in [op1min, op1max] range,\n+   optimize it into just op0 if op0's range is known to be a subset of\n+   [-op1min + 1, op1min - 1] for signed and [0, op1min - 1] for unsigned\n    modulo.  */\n \n static bool\n@@ -9241,17 +9241,25 @@ simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n   tree val = NULL;\n   tree op0 = gimple_assign_rhs1 (stmt);\n   tree op1 = gimple_assign_rhs2 (stmt);\n+  tree op1min = op1;\n   value_range *vr = get_value_range (op0);\n \n   if (rhs_code == TRUNC_MOD_EXPR\n-      && TREE_CODE (op1) == INTEGER_CST\n-      && tree_int_cst_sgn (op1) == 1\n+      && TREE_CODE (op1) == SSA_NAME)\n+    {\n+      value_range *vr1 = get_value_range (op1);\n+      if (range_int_cst_p (vr1))\n+\top1min = vr1->min;\n+    }\n+  if (rhs_code == TRUNC_MOD_EXPR\n+      && TREE_CODE (op1min) == INTEGER_CST\n+      && tree_int_cst_sgn (op1min) == 1\n       && range_int_cst_p (vr)\n-      && tree_int_cst_lt (vr->max, op1))\n+      && tree_int_cst_lt (vr->max, op1min))\n     {\n       if (TYPE_UNSIGNED (TREE_TYPE (op0))\n \t  || tree_int_cst_sgn (vr->min) >= 0\n-\t  || tree_int_cst_lt (fold_unary (NEGATE_EXPR, TREE_TYPE (op1), op1),\n+\t  || tree_int_cst_lt (fold_unary (NEGATE_EXPR, TREE_TYPE (op1min), op1min),\n \t\t\t      vr->min))\n \t{\n \t  /* If op0 already has the range op0 % op1 has,"}]}