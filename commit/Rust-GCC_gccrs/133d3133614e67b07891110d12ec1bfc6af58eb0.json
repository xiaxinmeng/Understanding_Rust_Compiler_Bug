{"sha": "133d3133614e67b07891110d12ec1bfc6af58eb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMzZDMxMzM2MTRlNjdiMDc4OTExMTBkMTJlYzFiZmM2YWY1OGViMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-09-13T08:42:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-13T08:42:20Z"}, "message": "alpha.c (small_symbolic_operand): New.\n\n        * config/alpha/alpha.c (small_symbolic_operand): New.\n        (override_options): Set MASK_SMALL_DATA based on pic/PIC.\n        (some_operand, input_operand): Don't handle HIGH.\n        (alpha_legitimize_address): Use it.  Emit HIGH with PLUS gp.\n        (alpha_expand_mov): Likewise.\n        (print_operand) [H]: Just print HIGH symbol.\n        (print_operand_address): Handle small data.\n        * config/alpha/alpha.h (MASK_SMALL_DATA, TARGET_SMALL_DATA): New.\n        (TARGET_SWITCHES): Add -msmall-data/large-data.\n        (PIC_OFFSET_TABLE_REGNUM): New.\n        (PREFERRED_RELOAD_CLASS): Don't handle HIGH.\n        (PREDICATE_COES): Update.\n        * config/alpha/alpha.md (adddi_er_high): New.\n        (adddi_er_low): Handle small data.\n        * config/alpha/elf.h (DO_SELECT_SECTION): If SMALL_DATA,\n        prefer .sdata to .rodata.\n        (SELECT_RTX_SECTION): Likewise.\n\nFrom-SVN: r45576", "tree": {"sha": "6e0e7913cb4002941265bbd23d185d04c6625c63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e0e7913cb4002941265bbd23d185d04c6625c63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/133d3133614e67b07891110d12ec1bfc6af58eb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/133d3133614e67b07891110d12ec1bfc6af58eb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/133d3133614e67b07891110d12ec1bfc6af58eb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/133d3133614e67b07891110d12ec1bfc6af58eb0/comments", "author": null, "committer": null, "parents": [{"sha": "97f4007957cdf58a9cc7478fd62fb64b3c7b762e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97f4007957cdf58a9cc7478fd62fb64b3c7b762e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97f4007957cdf58a9cc7478fd62fb64b3c7b762e"}], "stats": {"total": 181, "additions": 154, "deletions": 27}, "files": [{"sha": "85e8c5b39fdd3a7e76e8bbbd7421871579390887", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133d3133614e67b07891110d12ec1bfc6af58eb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133d3133614e67b07891110d12ec1bfc6af58eb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=133d3133614e67b07891110d12ec1bfc6af58eb0", "patch": "@@ -1,3 +1,23 @@\n+2001-09-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (small_symbolic_operand): New.\n+\t(override_options): Set MASK_SMALL_DATA based on pic/PIC.\n+\t(some_operand, input_operand): Don't handle HIGH.\n+\t(alpha_legitimize_address): Use it.  Emit HIGH with PLUS gp.\n+\t(alpha_expand_mov): Likewise.\n+\t(print_operand) [H]: Just print HIGH symbol.\n+\t(print_operand_address): Handle small data.\n+\t* config/alpha/alpha.h (MASK_SMALL_DATA, TARGET_SMALL_DATA): New.\n+\t(TARGET_SWITCHES): Add -msmall-data/large-data.\n+\t(PIC_OFFSET_TABLE_REGNUM): New.\n+\t(PREFERRED_RELOAD_CLASS): Don't handle HIGH.\n+\t(PREDICATE_COES): Update.\n+\t* config/alpha/alpha.md (adddi_er_high): New.\n+\t(adddi_er_low): Handle small data.\n+\t* config/alpha/elf.h (DO_SELECT_SECTION): If SMALL_DATA,\n+\tprefer .sdata to .rodata.\n+\t(SELECT_RTX_SECTION): Likewise.\n+\n 2001-09-12  Josh Martin  <josh.martin@abq.sc.philips.com>\n \n \t* fixinc/inclhack.def(hpux11_size_t): Keep HP-UX headers from"}, {"sha": "9fd33a0ee717a8447a19a5b4acb27e526cd29f63", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 76, "deletions": 16, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133d3133614e67b07891110d12ec1bfc6af58eb0/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133d3133614e67b07891110d12ec1bfc6af58eb0/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=133d3133614e67b07891110d12ec1bfc6af58eb0", "patch": "@@ -448,6 +448,12 @@ override_options ()\n   if (!g_switch_set)\n     g_switch_value = 8;\n \n+  /* Infer TARGET_SMALL_DATA from -fpic/-fPIC.  */\n+  if (flag_pic == 1)\n+    target_flags |= MASK_SMALL_DATA;\n+  else if (flag_pic == 2)\n+    target_flags &= ~MASK_SMALL_DATA;\n+\n   /* Align labels and loops for optimal branching.  */\n   /* ??? Kludge these by not doing anything if we don't optimize and also if\n      we are writing ECOFF symbols to work around a bug in DEC's assembler. */\n@@ -742,7 +748,7 @@ some_operand (op, mode)\n   switch (GET_CODE (op))\n     {\n     case REG:  case MEM:  case CONST_DOUBLE:  case CONST_INT:  case LABEL_REF:\n-    case SYMBOL_REF:  case CONST:  case HIGH:\n+    case SYMBOL_REF:  case CONST:\n       return 1;\n \n     case SUBREG:\n@@ -813,10 +819,6 @@ input_operand (op, mode)\n     case CONSTANT_P_RTX:\n       return 1;\n \n-    case HIGH:\n-      return (TARGET_EXPLICIT_RELOCS\n-\t      && local_symbolic_operand (XEXP (op, 0), mode));\n-\n     default:\n       break;\n     }\n@@ -876,6 +878,36 @@ local_symbolic_operand (op, mode)\n \t  || (str[0] == '*' && str[1] == '$'));\n }\n \n+/* Return true if OP is a SYMBOL_REF or CONST referencing a variable\n+   known to be defined in this file in the small data area.  */\n+\n+int\n+small_symbolic_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  const char *str;\n+\n+  if (! TARGET_SMALL_DATA)\n+    return 0;\n+\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+    op = XEXP (XEXP (op, 0), 0);\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+\n+  if (CONSTANT_POOL_ADDRESS_P (op))\n+    return GET_MODE_SIZE (get_pool_mode (op)) <= g_switch_value;\n+  else\n+    {\n+      str = XSTR (op, 0);\n+      return str[0] == '@' && str[1] == 's';\n+    }\n+}\n+\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n \n int\n@@ -1563,9 +1595,24 @@ alpha_legitimize_address (x, oldx, mode)\n   /* If this is a local symbol, split the address into HIGH/LO_SUM parts.  */\n   if (TARGET_EXPLICIT_RELOCS && local_symbolic_operand (x, Pmode))\n     {\n-      rtx temp = gen_reg_rtx (Pmode);\n-      emit_insn (gen_rtx_SET (VOIDmode, temp, gen_rtx_HIGH (Pmode, x)));\n-      return gen_rtx_LO_SUM (Pmode, temp, x);\n+      rtx scratch;\n+\n+      if (small_symbolic_operand (x, Pmode))\n+\tscratch = pic_offset_table_rtx;\n+      else\n+\t{\n+\t  rtx insn, tmp;\n+\n+\t  scratch = gen_reg_rtx (Pmode);\n+\n+\t  tmp = gen_rtx_HIGH (Pmode, x);\n+\t  tmp = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmp);\n+          insn = emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp));\n+\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, tmp,\n+\t\t\t\t\t\tREG_NOTES (insn));\n+\t}\n+\n+      return gen_rtx_LO_SUM (Pmode, scratch, x);\n     }\n \n   return NULL;\n@@ -2127,9 +2174,23 @@ alpha_expand_mov (mode, operands)\n \n   if (TARGET_EXPLICIT_RELOCS && local_symbolic_operand (operands[1], mode))\n     {\n-      rtx scratch = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n-      emit_insn (gen_rtx_SET (VOIDmode, scratch,\n-\t\t\t      gen_rtx_HIGH (Pmode, operands[1])));\n+      rtx scratch;\n+\n+      if (small_symbolic_operand (operands[1], Pmode))\n+\tscratch = pic_offset_table_rtx;\n+      else\n+\t{\n+\t  rtx insn, tmp;\n+\n+\t  scratch = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+\n+\t  tmp = gen_rtx_HIGH (Pmode, operands[1]);\n+\t  tmp = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmp);\n+          insn = emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp));\n+\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, tmp,\n+\t\t\t\t\t\tREG_NOTES (insn));\n+\t}\n+\n       operands[1] = gen_rtx_LO_SUM (Pmode, scratch, operands[1]);\n       return false;\n     }\n@@ -4773,10 +4834,7 @@ print_operand (file, x, code)\n \n     case 'H':\n       if (GET_CODE (x) == HIGH)\n-\t{\n-\t  output_addr_const (file, XEXP (x, 0));\n-\t  fputs (\"($29)\\t\\t!gprelhigh\", file);\n-\t}\n+\toutput_addr_const (file, XEXP (x, 0));\n       else\n \toutput_operand_lossage (\"invalid %%H value\");\n       break;\n@@ -5056,7 +5114,9 @@ print_operand_address (file, addr)\n \tbasereg = subreg_regno (addr);\n       else\n \tabort ();\n-      fprintf (file, \"($%d)\\t\\t!gprellow\", basereg);\n+\n+      fprintf (file, \"($%d)\\t\\t!%s\", basereg,\n+\t       (basereg == 29 ? \"gprel\" : \"gprellow\"));\n       return;\n     }\n "}, {"sha": "b8db8d743527c91586cb072a4e428eec7b3f791a", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133d3133614e67b07891110d12ec1bfc6af58eb0/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133d3133614e67b07891110d12ec1bfc6af58eb0/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=133d3133614e67b07891110d12ec1bfc6af58eb0", "patch": "@@ -162,6 +162,10 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n #define MASK_EXPLICIT_RELOCS (1 << 12)\n #define TARGET_EXPLICIT_RELOCS (target_flags & MASK_EXPLICIT_RELOCS)\n \n+/* This means use 16-bit relocations to .sdata/.sbss.  */\n+#define MASK_SMALL_DATA (1 << 13)\n+#define TARGET_SMALL_DATA (target_flags & MASK_SMALL_DATA)\n+\n /* This means that the processor is an EV5, EV56, or PCA56.\n    Unlike alpha_cpu this is not affected by -mtune= setting.  */\n #define MASK_CPU_EV5\t(1 << 28)\n@@ -240,6 +244,10 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n     {\"explicit-relocs\", MASK_EXPLICIT_RELOCS,\t\t\t\t\\\n      N_(\"Emit code using explicit relocation directives\")},\t\t\\\n     {\"no-explicit-relocs\", -MASK_EXPLICIT_RELOCS, \"\"},\t\t\t\\\n+    {\"small-data\", MASK_SMALL_DATA,\t\t\t\t\t\\\n+     N_(\"Emit 16-bit relocations to the small data areas\")},\t\t\\\n+    {\"large-data\", -MASK_SMALL_DATA,\t\t\t\t\t\\\n+     N_(\"Emit 32-bit relocations to the small data areas\")},\t\t\\\n     {\"\", TARGET_DEFAULT | TARGET_CPU_DEFAULT, \"\"} }\n \n #define TARGET_DEFAULT MASK_FP|MASK_FPREGS\n@@ -684,6 +692,18 @@ extern const char *alpha_mlat_string;\t/* For -mmemory-latency= */\n    doesn't seem to specify this.  */\n #define STATIC_CHAIN_REGNUM 1\n \n+/* The register number of the register used to address a table of\n+   static data addresses in memory.  */\n+#define PIC_OFFSET_TABLE_REGNUM 29\n+\n+/* Define this macro if the register defined by `PIC_OFFSET_TABLE_REGNUM'\n+   is clobbered by calls.  */\n+/* ??? It is and it isn't.  It's required to be valid for a given\n+   function when the function returns.  It isn't clobbered by\n+   current_file functions.  Moreover, we do not expose the ldgp\n+   until after reload, so we're probably safe.  */\n+/* #define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED */\n+\n /* Register in which address to store a structure value\n    arrives in the function.  On the Alpha, the address is passed\n    as a hidden argument.  */\n@@ -821,8 +841,7 @@ enum reg_class { NO_REGS, PV_REG, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    register via memory.  */\n \n #define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\\\n-  (GET_CODE (X) == HIGH ? GENERAL_REGS\t\t\t\\\n-   : CONSTANT_P (X) && (X) != const0_rtx && (X) != CONST0_RTX (GET_MODE (X)) \\\n+   (CONSTANT_P (X) && (X) != const0_rtx && (X) != CONST0_RTX (GET_MODE (X)) \\\n    ? ((CLASS) == FLOAT_REGS || (CLASS) == NO_REGS ? NO_REGS : GENERAL_REGS) \\\n    : (CLASS))\n \n@@ -2172,9 +2191,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"local_symbolic_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\\\n   {\"call_operand\", {REG, SYMBOL_REF}},\t\t\t\t\t\\\n   {\"input_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t     SYMBOL_REF, CONST, LABEL_REF, HIGH, LO_SUM}},\t\\\n+\t\t     SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\\n   {\"some_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t    SYMBOL_REF, CONST, LABEL_REF, HIGH, LO_SUM}},\t\\\n+\t\t    SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\\n   {\"some_ni_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n   {\"aligned_memory_operand\", {MEM}},\t\t\t\t\t\\\n   {\"unaligned_memory_operand\", {MEM}},\t\t\t\t\t\\"}, {"sha": "9a25ef48c9db66bcf6e30c2b2d59a75d5ea1ca1e", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133d3133614e67b07891110d12ec1bfc6af58eb0/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133d3133614e67b07891110d12ec1bfc6af58eb0/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=133d3133614e67b07891110d12ec1bfc6af58eb0", "patch": "@@ -638,6 +638,13 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"\"\n   \"\")\n \n+(define_insn \"*adddi_er_high\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (high:DI (match_operand:DI 2 \"local_symbolic_operand\" \"\"))))]\n+  \"TARGET_EXPLICIT_RELOCS\"\n+  \"ldah %0,%2(%1)\\t\\t!gprelhigh\")\n+\n ;; We used to expend quite a lot of effort choosing addq/subq/lda.\n ;; With complications like\n ;;\n@@ -5298,7 +5305,12 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t   (match_operand:DI 2 \"local_symbolic_operand\" \"\")))]\n   \"TARGET_EXPLICIT_RELOCS\"\n-  \"lda %0,%2(%1)\\t\\t!gprellow\")\n+{\n+  if (true_regnum (operands[1]) == 29)\n+    return \"lda %0,%2(%1)\\t\\t!gprel\";\n+  else\n+    return \"lda %0,%2(%1)\\t\\t!gprellow\";\n+})\n \n (define_insn \"*movdi_er_nofix\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q\")"}, {"sha": "ddb781817f9ead04440545c41d55feb1061227fb", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133d3133614e67b07891110d12ec1bfc6af58eb0/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133d3133614e67b07891110d12ec1bfc6af58eb0/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=133d3133614e67b07891110d12ec1bfc6af58eb0", "patch": "@@ -302,15 +302,20 @@ void FN ()\t\t\t\t\t\\\n #define DO_SELECT_SECTION(SECNUM, DECL, RELOC)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\\\n+       HOST_WIDE_INT size;\t\t\t\t\t\\\n        SECNUM = 1;\t\t\t\t\t\t\\\n        if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n-\t SECNUM = 0;\t\t\t\t\t\t\\\n+\t {\t\t\t\t\t\t\t\\\n+\t   SECNUM = 0;\t\t\t\t\t\t\\\n+\t   break;\t\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\\\n        else if (TREE_CODE (DECL) == STRING_CST)\t\t\t\\\n \t {\t\t\t\t\t\t\t\\\n \t   if (flag_writable_strings)\t\t\t\t\\\n \t     SECNUM = 2;\t\t\t\t\t\\\n \t   else\t\t\t\t\t\t\t\\\n \t     SECNUM = 0x101;\t\t\t\t\t\\\n+\t   break;\t\t\t\t\t\t\\\n \t }\t\t\t\t\t\t\t\\\n        else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\\\n \t {\t\t\t\t\t\t\t\\\n@@ -344,11 +349,16 @@ void FN ()\t\t\t\t\t\\\n \t }\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n        /* Select small data sections based on size.  */\t\t\\\n-       if ((SECNUM & 0xff) >= 2)\t\t\t\t\\\n+       size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\\\n+       if (size >= 0 && size <= g_switch_value)\t\t\t\\\n \t {\t\t\t\t\t\t\t\\\n-\t   int size = int_size_in_bytes (TREE_TYPE (DECL));\t\\\n-\t   if (size >= 0 && size <= g_switch_value)\t\t\\\n+\t   if ((SECNUM & 0xff) >= 2)\t\t\t\t\\\n \t     SECNUM += 1;\t\t\t\t\t\\\n+\t   /* Move readonly data to .sdata only if -msmall-data.  */ \\\n+\t   /* ??? Consider .sdata.{lit4,lit8} as\t\t\\\n+\t      SHF_MERGE|SHF_ALPHA_GPREL.  */\t\t\t\\\n+\t   else if (TARGET_SMALL_DATA)\t\t\t\t\\\n+\t     SECNUM = 3;\t\t\t\t\t\\\n \t }\t\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\\\n    while (0)\n@@ -437,8 +447,14 @@ void FN ()\t\t\t\t\t\\\n    go into the const section.  */\n \n #undef  SELECT_RTX_SECTION\n-#define SELECT_RTX_SECTION(MODE, RTX, ALIGN) \\\n-   mergeable_constant_section((MODE), (ALIGN), 0)\n+#define SELECT_RTX_SECTION(MODE, RTX, ALIGN)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_SMALL_DATA && GET_MODE_SIZE (MODE) <= g_switch_value)\t\\\n+     /* ??? Consider .sdata.{lit4,lit8} as SHF_MERGE|SHF_ALPHA_GPREL.  */ \\\n+    sdata_section ();\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    mergeable_constant_section((MODE), (ALIGN), 0);\t\t\t\\\n+} while (0)\n \n /* Define the strings used for the special svr4 .type and .size directives.\n    These strings generally do not vary from one system running svr4 to"}]}