{"sha": "2f3d9104610cb2058cf091707a20c1c6eff8d470", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYzZDkxMDQ2MTBjYjIwNThjZjA5MTcwN2EyMGMxYzZlZmY4ZDQ3MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-07T14:21:56Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-07T14:21:56Z"}, "message": "vect: Restore variable-length SLP permutes [PR97513]\n\nMany of the gcc.target/sve/slp-perm*.c tests started failing\nafter the introduction of separate SLP permute nodes.\nThis patch adds variable-length support using a similar\ntechnique to vect_transform_slp_perm_load.\n\nAs there, the idea is to detect when every permute mask vector\nis the same and can be generated using a regular stepped sequence.\nWe can easily handle those cases for variable-length, but still\nneed to restrict the general case to constant-length.\n\nAgain copying vect_transform_slp_perm_load, the idea is to distinguish\nthe two cases regardless of whether the length is variable or not,\npartly to increase testing coverage and partly because it avoids\ngenerating redundant trees.\n\nDoing this means that we can also use SLP for the two-vector\npermute in pr88834.c, which we couldn't before VEC_PERM_EXPR\nnodes were introduced.  The patch therefore makes pr88834.c\ncheck that we don't regress back to not using SLP and adds\npr88834_ld3.c to check for the original problem in the PR.\n\ngcc/\n\tPR tree-optimization/97513\n\t* tree-vect-slp.c (vect_add_slp_permutation): New function,\n\tsplit out from...\n\t(vectorizable_slp_permutation): ...here.  Detect cases in which\n\tall VEC_PERM_EXPRs are guaranteed to have the same stepped\n\tpermute vector and only generate one permute vector for that case.\n\tExtend that case to handle variable-length vectors.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/pr88834.c: Expect the vectorizer to use SLP.\n\t* gcc.target/aarch64/sve/pr88834_ld3.c: New test.", "tree": {"sha": "5b58d63bb01dfc617a2946b020b656daa989c5fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b58d63bb01dfc617a2946b020b656daa989c5fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f3d9104610cb2058cf091707a20c1c6eff8d470", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3d9104610cb2058cf091707a20c1c6eff8d470", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f3d9104610cb2058cf091707a20c1c6eff8d470", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3d9104610cb2058cf091707a20c1c6eff8d470/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c5b31975e62b4c52d76dc5efd9dc717a361c710", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5b31975e62b4c52d76dc5efd9dc717a361c710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c5b31975e62b4c52d76dc5efd9dc717a361c710"}], "stats": {"total": 239, "additions": 167, "deletions": 72}, "files": [{"sha": "818291ea219e9c1bf464820a6e5b0679d3197818", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pr88834.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3d9104610cb2058cf091707a20c1c6eff8d470/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr88834.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3d9104610cb2058cf091707a20c1c6eff8d470/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr88834.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr88834.c?ref=2f3d9104610cb2058cf091707a20c1c6eff8d470", "patch": "@@ -11,5 +11,6 @@ f (int *restrict x, int *restrict y, int *restrict z, int n)\n     }\n }\n \n-/* { dg-final { scan-assembler-times {\\tld2w\\t{z[0-9]+.s - z[0-9]+.s}, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 2 } } */\n-/* { dg-final { scan-assembler-times {\\tst2w\\t{z[0-9]+.s - z[0-9]+.s}, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 1 } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.d, all\\n} } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+.s, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+.s, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 1 } } */"}, {"sha": "5936b878606681db8516e460edd5104e4c77723e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pr88834_ld3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3d9104610cb2058cf091707a20c1c6eff8d470/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr88834_ld3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3d9104610cb2058cf091707a20c1c6eff8d470/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr88834_ld3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr88834_ld3.c?ref=2f3d9104610cb2058cf091707a20c1c6eff8d470", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+void\n+f (int *restrict x, int *restrict y, int *restrict z, int n)\n+{\n+  for (int i = 0; i < n; i += 3)\n+    {\n+      x[i] = y[i] + z[i];\n+      x[i + 1] = y[i + 1] - z[i + 1];\n+      x[i + 2] = y[i + 2] | z[i + 2];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tld3w\\t{z[0-9]+.s - z[0-9]+.s}, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst3w\\t{z[0-9]+.s - z[0-9]+.s}, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 1 } } */"}, {"sha": "1c5b7ae84e247796cff284054b0b609c3137879b", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 148, "deletions": 70, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3d9104610cb2058cf091707a20c1c6eff8d470/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3d9104610cb2058cf091707a20c1c6eff8d470/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=2f3d9104610cb2058cf091707a20c1c6eff8d470", "patch": "@@ -5829,6 +5829,57 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n   return true;\n }\n \n+/* Produce the next vector result for SLP permutation NODE by adding a vector\n+   statement at GSI.  If MASK_VEC is nonnull, add:\n+\n+      <new SSA name> = VEC_PERM_EXPR <FIRST_DEF, SECOND_DEF, MASK_VEC>\n+\n+   otherwise add:\n+\n+      <new SSA name> = FIRST_DEF.  */\n+\n+static void\n+vect_add_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n+\t\t\t  slp_tree node, tree first_def, tree second_def,\n+\t\t\t  tree mask_vec)\n+{\n+  tree vectype = SLP_TREE_VECTYPE (node);\n+\n+  /* ???  We SLP match existing vector element extracts but\n+     allow punning which we need to re-instantiate at uses\n+     but have no good way of explicitly representing.  */\n+  if (!types_compatible_p (TREE_TYPE (first_def), vectype))\n+    {\n+      gassign *conv_stmt\n+\t= gimple_build_assign (make_ssa_name (vectype),\n+\t\t\t       build1 (VIEW_CONVERT_EXPR, vectype, first_def));\n+      vect_finish_stmt_generation (vinfo, NULL, conv_stmt, gsi);\n+      first_def = gimple_assign_lhs (conv_stmt);\n+    }\n+  gassign *perm_stmt;\n+  tree perm_dest = make_ssa_name (vectype);\n+  if (mask_vec)\n+    {\n+      if (!types_compatible_p (TREE_TYPE (second_def), vectype))\n+\t{\n+\t  gassign *conv_stmt\n+\t    = gimple_build_assign (make_ssa_name (vectype),\n+\t\t\t\t   build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t   vectype, second_def));\n+\t  vect_finish_stmt_generation (vinfo, NULL, conv_stmt, gsi);\n+\t  second_def = gimple_assign_lhs (conv_stmt);\n+\t}\n+      perm_stmt = gimple_build_assign (perm_dest, VEC_PERM_EXPR,\n+\t\t\t\t       first_def, second_def,\n+\t\t\t\t       mask_vec);\n+    }\n+  else\n+    /* We need a copy here in case the def was external.  */\n+    perm_stmt = gimple_build_assign (perm_dest, first_def);\n+  vect_finish_stmt_generation (vinfo, NULL, perm_stmt, gsi);\n+  /* Store the vector statement in NODE.  */\n+  SLP_TREE_VEC_STMTS (node).quick_push (perm_stmt);\n+}\n \n /* Vectorize the SLP permutations in NODE as specified\n    in SLP_TREE_LANE_PERMUTATION which is a vector of pairs of SLP\n@@ -5852,15 +5903,21 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n      arbitrary mismatches.  */\n   slp_tree child;\n   unsigned i;\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  bool repeating_p = multiple_p (nunits, SLP_TREE_LANES (node));\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (!vect_maybe_update_slp_op_vectype (child, vectype)\n-\t|| !types_compatible_p (SLP_TREE_VECTYPE (child), vectype))\n-      {\n-\tif (dump_enabled_p ())\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"Unsupported lane permutation\\n\");\n-\treturn false;\n-      }\n+    {\n+      if (!vect_maybe_update_slp_op_vectype (child, vectype)\n+\t  || !types_compatible_p (SLP_TREE_VECTYPE (child), vectype))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"Unsupported lane permutation\\n\");\n+\t  return false;\n+\t}\n+      if (SLP_TREE_LANES (child) != SLP_TREE_LANES (node))\n+\trepeating_p = false;\n+    }\n \n   vec<std::pair<unsigned, unsigned> > &perm = SLP_TREE_LANE_PERMUTATION (node);\n   gcc_assert (perm.length () == SLP_TREE_LANES (node));\n@@ -5870,18 +5927,58 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t\t       \"vectorizing permutation\");\n       for (unsigned i = 0; i < perm.length (); ++i)\n \tdump_printf (MSG_NOTE, \" op%u[%u]\", perm[i].first, perm[i].second);\n+      if (repeating_p)\n+\tdump_printf (MSG_NOTE, \" (repeat %d)\\n\", SLP_TREE_LANES (node));\n       dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n-  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  if (!nunits.is_constant ())\n-    return false;\n-  unsigned HOST_WIDE_INT vf = 1;\n-  if (loop_vec_info linfo = dyn_cast <loop_vec_info> (vinfo))\n-    if (!LOOP_VINFO_VECT_FACTOR (linfo).is_constant (&vf))\n-      return false;\n-  unsigned olanes = vf * SLP_TREE_LANES (node);\n-  gcc_assert (multiple_p (olanes, nunits));\n+  /* REPEATING_P is true if every output vector is guaranteed to use the\n+     same permute vector.  We can handle that case for both variable-length\n+     and constant-length vectors, but we only handle other cases for\n+     constant-length vectors.\n+\n+     Set:\n+\n+     - NPATTERNS and NELTS_PER_PATTERN to the encoding of the permute\n+       mask vector that we want to build.\n+\n+     - NCOPIES to the number of copies of PERM that we need in order\n+       to build the necessary permute mask vectors.\n+\n+     - NOUTPUTS_PER_MASK to the number of output vectors we want to create\n+       for each permute mask vector.  This is only relevant when GSI is\n+       nonnull.  */\n+  uint64_t npatterns;\n+  unsigned nelts_per_pattern;\n+  uint64_t ncopies;\n+  unsigned noutputs_per_mask;\n+  if (repeating_p)\n+    {\n+      /* We need a single permute mask vector that has the form:\n+\n+\t   { X1, ..., Xn, X1 + n, ..., Xn + n, X1 + 2n, ..., Xn + 2n, ... }\n+\n+\t In other words, the original n-element permute in PERM is\n+\t \"unrolled\" to fill a full vector.  The stepped vector encoding\n+\t that we use for permutes requires 3n elements.  */\n+      npatterns = SLP_TREE_LANES (node);\n+      nelts_per_pattern = ncopies = 3;\n+      noutputs_per_mask = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n+    }\n+  else\n+    {\n+      /* Calculate every element of every permute mask vector explicitly,\n+\t instead of relying on the pattern described above.  */\n+      if (!nunits.is_constant (&npatterns))\n+\treturn false;\n+      nelts_per_pattern = ncopies = 1;\n+      if (loop_vec_info linfo = dyn_cast <loop_vec_info> (vinfo))\n+\tif (!LOOP_VINFO_VECT_FACTOR (linfo).is_constant (&ncopies))\n+\t  return false;\n+      noutputs_per_mask = 1;\n+    }\n+  unsigned olanes = ncopies * SLP_TREE_LANES (node);\n+  gcc_assert (repeating_p || multiple_p (olanes, nunits));\n \n   /* Compute the { { SLP operand, vector index}, lane } permutation sequence\n      from the { SLP operand, scalar lane } permutation as recorded in the\n@@ -5891,16 +5988,22 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n   auto_vec<unsigned> active_lane;\n   vperm.create (olanes);\n   active_lane.safe_grow_cleared (SLP_TREE_CHILDREN (node).length (), true);\n-  for (unsigned i = 0; i < vf; ++i)\n+  for (unsigned i = 0; i < ncopies; ++i)\n     {\n       for (unsigned pi = 0; pi < perm.length (); ++pi)\n \t{\n \t  std::pair<unsigned, unsigned> p = perm[pi];\n \t  tree vtype = SLP_TREE_VECTYPE (SLP_TREE_CHILDREN (node)[p.first]);\n-\t  unsigned vnunits = TYPE_VECTOR_SUBPARTS (vtype).to_constant ();\n-\t  unsigned vi = (active_lane[p.first] + p.second) / vnunits;\n-\t  unsigned vl = (active_lane[p.first] + p.second) % vnunits;\n-\t  vperm.quick_push (std::make_pair (std::make_pair (p.first, vi), vl));\n+\t  if (repeating_p)\n+\t    vperm.quick_push ({{p.first, 0}, p.second + active_lane[p.first]});\n+\t  else\n+\t    {\n+\t      /* We checked above that the vectors are constant-length.  */\n+\t      unsigned vnunits = TYPE_VECTOR_SUBPARTS (vtype).to_constant ();\n+\t      unsigned vi = (active_lane[p.first] + p.second) / vnunits;\n+\t      unsigned vl = (active_lane[p.first] + p.second) % vnunits;\n+\t      vperm.quick_push ({{p.first, vi}, vl});\n+\t    }\n \t}\n       /* Advance to the next group.  */\n       for (unsigned j = 0; j < SLP_TREE_CHILDREN (node).length (); ++j)\n@@ -5912,7 +6015,10 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n       dump_printf_loc (MSG_NOTE, vect_location, \"as\");\n       for (unsigned i = 0; i < vperm.length (); ++i)\n \t{\n-\t  if (i != 0 && multiple_p (i, TYPE_VECTOR_SUBPARTS (vectype)))\n+\t  if (i != 0\n+\t      && (repeating_p\n+\t\t  ? multiple_p (i, npatterns)\n+\t\t  : multiple_p (i, TYPE_VECTOR_SUBPARTS (vectype))))\n \t    dump_printf (MSG_NOTE, \",\");\n \t  dump_printf (MSG_NOTE, \" vops%u[%u][%u]\",\n \t\t       vperm[i].first.first, vperm[i].first.second,\n@@ -5929,11 +6035,10 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n      somehow?  */\n   std::pair<unsigned, unsigned> first_vec = std::make_pair (-1U, -1U);\n   std::pair<unsigned, unsigned> second_vec = std::make_pair (-1U, -1U);\n-  unsigned int const_nunits = nunits.to_constant ();\n   unsigned int index = 0;\n-  unsigned int mask_element;\n+  poly_uint64 mask_element;\n   vec_perm_builder mask;\n-  mask.new_vector (const_nunits, const_nunits, 1);\n+  mask.new_vector (nunits, npatterns, nelts_per_pattern);\n   unsigned int count = mask.encoded_nelts ();\n   mask.quick_grow (count);\n   vec_perm_indices indices;\n@@ -5948,7 +6053,7 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t       || second_vec == vperm[i].first)\n \t{\n \t  second_vec = vperm[i].first;\n-\t  mask_element += const_nunits;\n+\t  mask_element += nunits;\n \t}\n       else\n \t{\n@@ -5964,8 +6069,7 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \n       if (index == count)\n \t{\n-\t  indices.new_vector (mask, second_vec.first == -1U ? 1 : 2,\n-\t\t\t      const_nunits);\n+\t  indices.new_vector (mask, second_vec.first == -1U ? 1 : 2, nunits);\n \t  bool identity_p = indices.series_p (0, 1, 0, 1);\n \t  if (!identity_p\n \t      && !can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n@@ -5993,51 +6097,25 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t      if (second_vec.first == -1U)\n \t\tsecond_vec = first_vec;\n \n-\t      /* Generate the permute statement if necessary.  */\n-\t      slp_tree first_node = SLP_TREE_CHILDREN (node)[first_vec.first];\n-\t      tree first_def\n-\t\t= vect_get_slp_vect_def (first_node, first_vec.second);\n-\t      /* ???  We SLP match existing vector element extracts but\n-\t\t allow punning which we need to re-instantiate at uses\n-\t\t but have no good way of explicitely representing.  */\n-\t      if (!types_compatible_p (TREE_TYPE (first_def), vectype))\n-\t\t{\n-\t\t  gassign *conv_stmt;\n-\t\t  conv_stmt = gimple_build_assign (make_ssa_name (vectype),\n-\t\t\t\t\t\t   build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t\t   vectype, first_def));\n-\t\t  vect_finish_stmt_generation (vinfo, NULL, conv_stmt, gsi);\n-\t\t  first_def = gimple_assign_lhs (conv_stmt);\n-\t\t}\n-\t      gassign *perm_stmt;\n-\t      tree perm_dest = make_ssa_name (vectype);\n+\t      slp_tree\n+\t\tfirst_node = SLP_TREE_CHILDREN (node)[first_vec.first],\n+\t\tsecond_node = SLP_TREE_CHILDREN (node)[second_vec.first];\n+\n+\t      tree mask_vec = NULL_TREE;\n \t      if (!identity_p)\n+\t\tmask_vec = vect_gen_perm_mask_checked (vectype, indices);\n+\n+\t      for (unsigned int vi = 0; vi < noutputs_per_mask; ++vi)\n \t\t{\n-\t\t  slp_tree second_node\n-\t\t    = SLP_TREE_CHILDREN (node)[second_vec.first];\n+\t\t  tree first_def\n+\t\t    = vect_get_slp_vect_def (first_node,\n+\t\t\t\t\t     first_vec.second + vi);\n \t\t  tree second_def\n-\t\t    = vect_get_slp_vect_def (second_node, second_vec.second);\n-\t\t  if (!types_compatible_p (TREE_TYPE (second_def), vectype))\n-\t\t    {\n-\t\t      gassign *conv_stmt;\n-\t\t      conv_stmt = gimple_build_assign (make_ssa_name (vectype),\n-\t\t\t\t\t\t       build1\n-\t\t\t\t\t\t\t (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t\t  vectype, second_def));\n-\t\t      vect_finish_stmt_generation (vinfo, NULL, conv_stmt, gsi);\n-\t\t      second_def = gimple_assign_lhs (conv_stmt);\n-\t\t    }\n-\t\t  tree mask_vec = vect_gen_perm_mask_checked (vectype, indices);\n-\t\t  perm_stmt = gimple_build_assign (perm_dest, VEC_PERM_EXPR,\n-\t\t\t\t\t\t   first_def, second_def,\n-\t\t\t\t\t\t   mask_vec);\n+\t\t    = vect_get_slp_vect_def (second_node,\n+\t\t\t\t\t     second_vec.second + vi);\n+\t\t  vect_add_slp_permutation (vinfo, gsi, node, first_def,\n+\t\t\t\t\t    second_def, mask_vec);\n \t\t}\n-\t      else\n-\t\t/* We need a copy here in case the def was external.  */\n-\t\tperm_stmt = gimple_build_assign (perm_dest, first_def);\n-\t      vect_finish_stmt_generation (vinfo, NULL, perm_stmt, gsi);\n-\t      /* Store the vector statement in NODE.  */\n-\t      SLP_TREE_VEC_STMTS (node).quick_push (perm_stmt);\n \t    }\n \n \t  index = 0;"}]}