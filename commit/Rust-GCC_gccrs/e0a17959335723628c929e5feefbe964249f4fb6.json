{"sha": "e0a17959335723628c929e5feefbe964249f4fb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBhMTc5NTkzMzU3MjM2MjhjOTI5ZTVmZWVmYmU5NjQyNDlmNGZiNg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2008-08-06T06:51:11Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2008-08-06T06:51:11Z"}, "message": "reload.c (find_reloads): Force constants into literal pool also if they are wrapped in a SUBREG.\n\n2008-08-06  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* reload.c (find_reloads): Force constants into literal pool\n\talso if they are wrapped in a SUBREG.\n\n2008-08-06  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n \t* gcc.c-torture/compile/20080806-1.c: New testcase.\n\nFrom-SVN: r138763", "tree": {"sha": "0813ab73429e00265c8dc79f46b2a719a885ac7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0813ab73429e00265c8dc79f46b2a719a885ac7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0a17959335723628c929e5feefbe964249f4fb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0a17959335723628c929e5feefbe964249f4fb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0a17959335723628c929e5feefbe964249f4fb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0a17959335723628c929e5feefbe964249f4fb6/comments", "author": null, "committer": null, "parents": [{"sha": "c275297bdd09468bb84ab839e89f585ca9541fee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c275297bdd09468bb84ab839e89f585ca9541fee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c275297bdd09468bb84ab839e89f585ca9541fee"}], "stats": {"total": 132, "additions": 93, "deletions": 39}, "files": [{"sha": "5ec9a6e1ad40a0ac43fc5f39075362d93032307e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a17959335723628c929e5feefbe964249f4fb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a17959335723628c929e5feefbe964249f4fb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0a17959335723628c929e5feefbe964249f4fb6", "patch": "@@ -1,3 +1,8 @@\n+2008-08-06  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* reload.c (find_reloads): Force constants into literal pool\n+\talso if they are wrapped in a SUBREG.\n+\n 2008-08-06  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \tPR target/35659"}, {"sha": "93fff40456985e8d35fb91e7800909682405d75a", "filename": "gcc/reload.c", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a17959335723628c929e5feefbe964249f4fb6/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a17959335723628c929e5feefbe964249f4fb6/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e0a17959335723628c929e5feefbe964249f4fb6", "patch": "@@ -3843,49 +3843,61 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   /* Any constants that aren't allowed and can't be reloaded\n      into registers are here changed into memory references.  */\n   for (i = 0; i < noperands; i++)\n-    if (! goal_alternative_win[i]\n-\t&& CONST_POOL_OK_P (recog_data.operand[i])\n-\t&& ((PREFERRED_RELOAD_CLASS (recog_data.operand[i],\n-\t\t\t\t     (enum reg_class) goal_alternative[i])\n-\t     == NO_REGS)\n-\t    || no_input_reloads)\n-\t&& operand_mode[i] != VOIDmode)\n+    if (! goal_alternative_win[i])\n       {\n-\tint this_address_reloaded;\n+\trtx op = recog_data.operand[i];\n+\trtx subreg = NULL_RTX;\n+\trtx plus = NULL_RTX;\n+\tenum machine_mode mode = operand_mode[i];\n+\n+\t/* Reloads of SUBREGs of CONSTANT RTXs are handled later in\n+\t   push_reload so we have to let them pass here.  */\n+\tif (GET_CODE (op) == SUBREG)\n+\t  {\n+\t    subreg = op;\n+\t    op = SUBREG_REG (op);\n+\t    mode = GET_MODE (op);\n+\t  }\n \n-\tthis_address_reloaded = 0;\n-\tsubsted_operand[i] = recog_data.operand[i]\n-\t  = find_reloads_toplev (force_const_mem (operand_mode[i],\n-\t\t\t\t\t\t  recog_data.operand[i]),\n-\t\t\t\t i, address_type[i], ind_levels, 0, insn,\n-\t\t\t\t &this_address_reloaded);\n-\tif (alternative_allows_const_pool_ref (this_address_reloaded == 0\n-\t\t\t\t\t       ? substed_operand[i]\n-\t\t\t\t\t       : NULL,\n-\t\t\t\t\t       recog_data.constraints[i],\n-\t\t\t\t\t       goal_alternative_number))\n-\t  goal_alternative_win[i] = 1;\n-      }\n+\tif (GET_CODE (op) == PLUS)\n+\t  {\n+\t    plus = op;\n+\t    op = XEXP (op, 1);\n+\t  }\n \n-  /* Likewise any invalid constants appearing as operand of a PLUS\n-     that is to be reloaded.  */\n-  for (i = 0; i < noperands; i++)\n-    if (! goal_alternative_win[i]\n-\t&& GET_CODE (recog_data.operand[i]) == PLUS\n-\t&& CONST_POOL_OK_P (XEXP (recog_data.operand[i], 1))\n-\t&& (PREFERRED_RELOAD_CLASS (XEXP (recog_data.operand[i], 1),\n-\t\t\t\t    (enum reg_class) goal_alternative[i])\n-\t     == NO_REGS)\n-\t&& operand_mode[i] != VOIDmode)\n-      {\n-\trtx tem = force_const_mem (operand_mode[i],\n-\t\t\t\t   XEXP (recog_data.operand[i], 1));\n-\ttem = gen_rtx_PLUS (operand_mode[i],\n-\t\t\t    XEXP (recog_data.operand[i], 0), tem);\n+\tif (CONST_POOL_OK_P (op)\n+\t    && ((PREFERRED_RELOAD_CLASS (op,\n+\t\t\t\t\t (enum reg_class) goal_alternative[i])\n+\t\t == NO_REGS)\n+\t\t|| no_input_reloads)\n+\t    && mode != VOIDmode)\n+\t  {\n+\t    int this_address_reloaded;\n+\t    rtx tem = force_const_mem (mode, op);\n \n-\tsubsted_operand[i] = recog_data.operand[i]\n-\t  = find_reloads_toplev (tem, i, address_type[i],\n-\t\t\t\t ind_levels, 0, insn, NULL);\n+\t    /* If we stripped a SUBREG or a PLUS above add it back.  */\n+\t    if (plus != NULL_RTX)\n+\t      tem = gen_rtx_PLUS (mode, XEXP (plus, 0), tem);\n+\n+\t    if (subreg != NULL_RTX)\n+\t      tem = gen_rtx_SUBREG (operand_mode[i], tem, SUBREG_BYTE (subreg));\n+\n+\t    this_address_reloaded = 0;\n+\t    substed_operand[i] = recog_data.operand[i]\n+\t      = find_reloads_toplev (tem, i, address_type[i], ind_levels,\n+\t\t\t\t     0, insn, &this_address_reloaded);\n+\n+\t    /* If the alternative accepts constant pool refs directly\n+\t       there will be no reload needed at all.  */\n+\t    if (plus == NULL_RTX\n+\t\t&& subreg == NULL_RTX\n+\t\t&& alternative_allows_const_pool_ref (this_address_reloaded == 0\n+\t\t\t\t\t\t      ? substed_operand[i]\n+\t\t\t\t\t\t      : NULL,\n+\t\t\t\t\t\t      recog_data.constraints[i],\n+\t\t\t\t\t\t      goal_alternative_number))\n+\t      goal_alternative_win[i] = 1;\n+\t  }\n       }\n \n   /* Record the values of the earlyclobber operands for the caller.  */"}, {"sha": "92c95cc547bbbce8e94da6b0379570c66f332f94", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a17959335723628c929e5feefbe964249f4fb6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a17959335723628c929e5feefbe964249f4fb6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e0a17959335723628c929e5feefbe964249f4fb6", "patch": "@@ -1,3 +1,7 @@\n+2008-08-06  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+ \t* gcc.c-torture/compile/20080806-1.c: New testcase.\n+\n 2008-08-06  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* gcc.target/ia64/20080802-1.c: New test."}, {"sha": "33f0857d5c2964821f721fc87e0c4efccdbef0ae", "filename": "gcc/testsuite/gcc.c-torture/compile/20080806-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a17959335723628c929e5feefbe964249f4fb6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20080806-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a17959335723628c929e5feefbe964249f4fb6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20080806-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20080806-1.c?ref=e0a17959335723628c929e5feefbe964249f4fb6", "patch": "@@ -0,0 +1,33 @@\n+int gl2;\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void *memcpy (void *dest, const void *src, size_t n);\n+\n+void\n+f1 ()\n+{\n+  int i2;\n+  unsigned char bf[64 * 1024 + 4];\n+\n+  for (i2 = 0; i2 < 3; i2++)\n+    {\n+      unsigned char *p2 = bf;\n+      unsigned char *p3 = ((void *) 0);\n+      unsigned short ctf2;\n+\n+      p2 += sizeof (short);\n+\n+      for (ctf2 = 0; ctf2 < 3; ctf2++)\n+\t{\n+\t  if (ctf2 == 1)\n+\t    {\n+\t      unsigned short of = p2 - bf - 6;\n+\t      unsigned short *ofp = (unsigned short *) &of;\n+\t      memcpy (p3, ofp, sizeof (short));\n+\t    }\n+\n+\t  if (gl2 == 1)\n+\t    p2 += 3;\n+\t}\n+    }\n+}"}]}