{"sha": "c39169c82c278bff88da0fcb05516420fbcf808a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM5MTY5YzgyYzI3OGJmZjg4ZGEwZmNiMDU1MTY0MjBmYmNmODA4YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-11-17T19:29:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-11-17T19:29:04Z"}, "message": "Unify implementations of __builtin_mem_*_fence and __sync_synchronize.\n\n\t* builtins.c (expand_builtin_mem_thread_fence): Remove.\n\t(expand_builtin_mem_signal_fence): Remove.\n\t(expand_builtin_atomic_thread_fence): Use expand_mem_thread_fence.\n\t(expand_builtin_sync_synchronize): Likewise.\n\t(expand_builtin_atomic_signal_fence): Use expand_mem_signal_fence.\n\t* optabs.c (expand_asm_memory_barrier): Split out from\n\texpand_builtin_mem_signal_fence.\n\t(expand_mem_thread_fence): New, a combination of code from\n\texpand_builtin_mem_thread_fence and expand_builtin_sync_synchronize.\n\t(expand_mem_signal_fence): Moved and renamed from\n\texpand_builtin_mem_signal_fence.\n\t(expand_atomic_exchange): Use expand_mem_thread_fence.\n\t(expand_atomic_load, expand_atomic_store): Likewise.\n\t* expr.h, optabs.h: Update decls.\n\nFrom-SVN: r181451", "tree": {"sha": "c5fe338ba828667922ef001c6df7a932a78412e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5fe338ba828667922ef001c6df7a932a78412e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c39169c82c278bff88da0fcb05516420fbcf808a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c39169c82c278bff88da0fcb05516420fbcf808a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c39169c82c278bff88da0fcb05516420fbcf808a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c39169c82c278bff88da0fcb05516420fbcf808a/comments", "author": null, "committer": null, "parents": [{"sha": "cfb9952179d2ea470461a0ea3ab64c53a9d27fb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfb9952179d2ea470461a0ea3ab64c53a9d27fb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfb9952179d2ea470461a0ea3ab64c53a9d27fb8"}], "stats": {"total": 197, "additions": 103, "deletions": 94}, "files": [{"sha": "95924c81ce21fd907478c3f9e015220a7ef6efde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c39169c82c278bff88da0fcb05516420fbcf808a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c39169c82c278bff88da0fcb05516420fbcf808a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c39169c82c278bff88da0fcb05516420fbcf808a", "patch": "@@ -1,3 +1,20 @@\n+2011-11-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* builtins.c (expand_builtin_mem_thread_fence): Remove.\n+\t(expand_builtin_mem_signal_fence): Remove.\n+\t(expand_builtin_atomic_thread_fence): Use expand_mem_thread_fence.\n+\t(expand_builtin_sync_synchronize): Likewise.\n+\t(expand_builtin_atomic_signal_fence): Use expand_mem_signal_fence.\n+\t* optabs.c (expand_asm_memory_barrier): Split out from\n+\texpand_builtin_mem_signal_fence.\n+\t(expand_mem_thread_fence): New, a combination of code from\n+\texpand_builtin_mem_thread_fence and expand_builtin_sync_synchronize.\n+\t(expand_mem_signal_fence): Moved and renamed from\n+\texpand_builtin_mem_signal_fence.\n+\t(expand_atomic_exchange): Use expand_mem_thread_fence.\n+\t(expand_atomic_load, expand_atomic_store): Likewise.\n+\t* expr.h, optabs.h: Update decls.\n+\n 2011-11-17  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR rtl-optimization/50663"}, {"sha": "fe0260ff33ef71583290e4e1b0a6acf605d2bae2", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 86, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c39169c82c278bff88da0fcb05516420fbcf808a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c39169c82c278bff88da0fcb05516420fbcf808a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c39169c82c278bff88da0fcb05516420fbcf808a", "patch": "@@ -5672,70 +5672,15 @@ expand_builtin_atomic_is_lock_free (tree exp)\n   return NULL_RTX;\n }\n \n-/* This routine will either emit the mem_thread_fence pattern or issue a \n-   sync_synchronize to generate a fence for memory model MEMMODEL.  */\n-\n-#ifndef HAVE_mem_thread_fence\n-# define HAVE_mem_thread_fence 0\n-# define gen_mem_thread_fence(x) (gcc_unreachable (), NULL_RTX)\n-#endif\n-\n-void\n-expand_builtin_mem_thread_fence (enum memmodel model)\n-{\n-  if (HAVE_mem_thread_fence)\n-    emit_insn (gen_mem_thread_fence (GEN_INT (model)));\n-  else if (model != MEMMODEL_RELAXED)\n-    expand_builtin_sync_synchronize ();\n-}\n-\n /* Expand the __atomic_thread_fence intrinsic:\n    \tvoid __atomic_thread_fence (enum memmodel)\n    EXP is the CALL_EXPR.  */\n \n static void\n expand_builtin_atomic_thread_fence (tree exp)\n {\n-  enum memmodel model;\n-  \n-  model = get_memmodel (CALL_EXPR_ARG (exp, 0));\n-  expand_builtin_mem_thread_fence (model);\n-}\n-\n-/* This routine will either emit the mem_signal_fence pattern or issue a \n-   sync_synchronize to generate a fence for memory model MEMMODEL.  */\n-\n-#ifndef HAVE_mem_signal_fence\n-# define HAVE_mem_signal_fence 0\n-# define gen_mem_signal_fence(x) (gcc_unreachable (), NULL_RTX)\n-#endif\n-\n-static void\n-expand_builtin_mem_signal_fence (enum memmodel model)\n-{\n-  if (HAVE_mem_signal_fence)\n-    emit_insn (gen_mem_signal_fence (GEN_INT (model)));\n-  else if (model != MEMMODEL_RELAXED)\n-    {\n-      rtx asm_op, clob;\n-\n-      /* By default targets are coherent between a thread and the signal\n-\t handler running on the same thread.  Thus this really becomes a\n-\t compiler barrier, in that stores must not be sunk past\n-\t (or raised above) a given point.  */\n-\n-      /* Generate asm volatile(\"\" : : : \"memory\") as the memory barrier.  */\n-      asm_op = gen_rtx_ASM_OPERANDS (VOIDmode, empty_string, empty_string, 0,\n-\t\t\t\t     rtvec_alloc (0), rtvec_alloc (0),\n-\t\t\t\t     rtvec_alloc (0), UNKNOWN_LOCATION);\n-      MEM_VOLATILE_P (asm_op) = 1;\n-\n-      clob = gen_rtx_SCRATCH (VOIDmode);\n-      clob = gen_rtx_MEM (BLKmode, clob);\n-      clob = gen_rtx_CLOBBER (VOIDmode, clob);\n-\n-      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, asm_op, clob)));\n-    }\n+  enum memmodel model = get_memmodel (CALL_EXPR_ARG (exp, 0));\n+  expand_mem_thread_fence (model);\n }\n \n /* Expand the __atomic_signal_fence intrinsic:\n@@ -5745,42 +5690,16 @@ expand_builtin_mem_signal_fence (enum memmodel model)\n static void\n expand_builtin_atomic_signal_fence (tree exp)\n {\n-  enum memmodel model;\n-\n-  model = get_memmodel (CALL_EXPR_ARG (exp, 0));\n-  expand_builtin_mem_signal_fence (model);\n+  enum memmodel model = get_memmodel (CALL_EXPR_ARG (exp, 0));\n+  expand_mem_signal_fence (model);\n }\n \n /* Expand the __sync_synchronize intrinsic.  */\n \n static void\n expand_builtin_sync_synchronize (void)\n {\n-  gimple x;\n-  VEC (tree, gc) *v_clobbers;\n-\n-#ifdef HAVE_memory_barrier\n-  if (HAVE_memory_barrier)\n-    {\n-      emit_insn (gen_memory_barrier ());\n-      return;\n-    }\n-#endif\n-\n-  if (synchronize_libfunc != NULL_RTX)\n-    {\n-      emit_library_call (synchronize_libfunc, LCT_NORMAL, VOIDmode, 0);\n-      return;\n-    }\n-\n-  /* If no explicit memory barrier instruction is available, create an\n-     empty asm stmt with a memory clobber.  */\n-  v_clobbers = VEC_alloc (tree, gc, 1);\n-  VEC_quick_push (tree, v_clobbers,\n-\t\t  tree_cons (NULL, build_string (6, \"memory\"), NULL));\n-  x = gimple_build_asm_vec (\"\", NULL, NULL, v_clobbers, NULL);\n-  gimple_asm_set_volatile (x, true);\n-  expand_asm_stmt (x);\n+  expand_mem_thread_fence (MEMMODEL_SEQ_CST);\n }\n \n \f"}, {"sha": "4b923a53e66c31354a55c3e5d6816a6de1ef9355", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c39169c82c278bff88da0fcb05516420fbcf808a/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c39169c82c278bff88da0fcb05516420fbcf808a/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=c39169c82c278bff88da0fcb05516420fbcf808a", "patch": "@@ -254,7 +254,6 @@ extern void expand_builtin_setjmp_receiver (rtx);\n extern rtx expand_builtin_saveregs (void);\n extern void expand_builtin_trap (void);\n extern rtx builtin_strncpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n-extern void expand_builtin_mem_thread_fence (enum memmodel);\n \f\n /* Functions from expr.c:  */\n "}, {"sha": "2468efd273b1045c0cd9f8424f36636fe54f2316", "filename": "gcc/optabs.c", "status": "modified", "additions": 77, "deletions": 7, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c39169c82c278bff88da0fcb05516420fbcf808a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c39169c82c278bff88da0fcb05516420fbcf808a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c39169c82c278bff88da0fcb05516420fbcf808a", "patch": "@@ -7378,7 +7378,7 @@ expand_atomic_exchange (rtx target, rtx mem, rtx val, enum memmodel model,\n \t  if (model == MEMMODEL_SEQ_CST\n \t      || model == MEMMODEL_RELEASE\n \t      || model == MEMMODEL_ACQ_REL)\n-\t    expand_builtin_mem_thread_fence (model);\n+\t    expand_mem_thread_fence (model);\n \n \t  create_output_operand (&ops[0], target, mode);\n \t  create_fixed_operand (&ops[1], mem);\n@@ -7403,7 +7403,7 @@ expand_atomic_exchange (rtx target, rtx mem, rtx val, enum memmodel model,\n \t      if (model == MEMMODEL_SEQ_CST\n \t\t  || model == MEMMODEL_RELEASE\n \t\t  || model == MEMMODEL_ACQ_REL)\n-\t\texpand_builtin_mem_thread_fence (model);\n+\t\texpand_mem_thread_fence (model);\n \n \t      addr = convert_memory_address (ptr_mode, XEXP (mem, 0));\n \t      return emit_library_call_value (libfunc, target, LCT_NORMAL,\n@@ -7556,6 +7556,76 @@ expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n   return true;\n }\n \n+/* Generate asm volatile(\"\" : : : \"memory\") as the memory barrier.  */\n+\n+static void\n+expand_asm_memory_barrier (void)\n+{\n+  rtx asm_op, clob;\n+\n+  asm_op = gen_rtx_ASM_OPERANDS (VOIDmode, empty_string, empty_string, 0,\n+\t\t\t\t rtvec_alloc (0), rtvec_alloc (0),\n+\t\t\t\t rtvec_alloc (0), UNKNOWN_LOCATION);\n+  MEM_VOLATILE_P (asm_op) = 1;\n+\n+  clob = gen_rtx_SCRATCH (VOIDmode);\n+  clob = gen_rtx_MEM (BLKmode, clob);\n+  clob = gen_rtx_CLOBBER (VOIDmode, clob);\n+\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, asm_op, clob)));\n+}\n+\n+/* This routine will either emit the mem_thread_fence pattern or issue a \n+   sync_synchronize to generate a fence for memory model MEMMODEL.  */\n+\n+#ifndef HAVE_mem_thread_fence\n+# define HAVE_mem_thread_fence 0\n+# define gen_mem_thread_fence(x) (gcc_unreachable (), NULL_RTX)\n+#endif\n+#ifndef HAVE_memory_barrier\n+# define HAVE_memory_barrier 0\n+# define gen_memory_barrier()  (gcc_unreachable (), NULL_RTX)\n+#endif\n+\n+void\n+expand_mem_thread_fence (enum memmodel model)\n+{\n+  if (HAVE_mem_thread_fence)\n+    emit_insn (gen_mem_thread_fence (GEN_INT (model)));\n+  else if (model != MEMMODEL_RELAXED)\n+    {\n+      if (HAVE_memory_barrier)\n+\temit_insn (gen_memory_barrier ());\n+      else if (synchronize_libfunc != NULL_RTX)\n+\temit_library_call (synchronize_libfunc, LCT_NORMAL, VOIDmode, 0);\n+      else\n+\texpand_asm_memory_barrier ();\n+    }\n+}\n+\n+/* This routine will either emit the mem_signal_fence pattern or issue a \n+   sync_synchronize to generate a fence for memory model MEMMODEL.  */\n+\n+#ifndef HAVE_mem_signal_fence\n+# define HAVE_mem_signal_fence 0\n+# define gen_mem_signal_fence(x) (gcc_unreachable (), NULL_RTX)\n+#endif\n+\n+void\n+expand_mem_signal_fence (enum memmodel model)\n+{\n+  if (HAVE_mem_signal_fence)\n+    emit_insn (gen_mem_signal_fence (GEN_INT (model)));\n+  else if (model != MEMMODEL_RELAXED)\n+    {\n+      /* By default targets are coherent between a thread and the signal\n+\t handler running on the same thread.  Thus this really becomes a\n+\t compiler barrier, in that stores must not be sunk past\n+\t (or raised above) a given point.  */\n+      expand_asm_memory_barrier ();\n+    }\n+}\n+\n /* This function expands the atomic load operation:\n    return the atomically loaded value in MEM.\n \n@@ -7598,13 +7668,13 @@ expand_atomic_load (rtx target, rtx mem, enum memmodel model)\n     target = gen_reg_rtx (mode);\n \n   /* Emit the appropriate barrier before the load.  */\n-  expand_builtin_mem_thread_fence (model);\n+  expand_mem_thread_fence (model);\n \n   emit_move_insn (target, mem);\n \n   /* For SEQ_CST, also emit a barrier after the load.  */\n   if (model == MEMMODEL_SEQ_CST)\n-    expand_builtin_mem_thread_fence (model);\n+    expand_mem_thread_fence (model);\n \n   return target;\n }\n@@ -7645,7 +7715,7 @@ expand_atomic_store (rtx mem, rtx val, enum memmodel model, bool use_release)\n \t    {\n \t      /* lock_release is only a release barrier.  */\n \t      if (model == MEMMODEL_SEQ_CST)\n-\t\texpand_builtin_mem_thread_fence (model);\n+\t\texpand_mem_thread_fence (model);\n \t      return const0_rtx;\n \t    }\n \t}\n@@ -7665,13 +7735,13 @@ expand_atomic_store (rtx mem, rtx val, enum memmodel model, bool use_release)\n \n   /* If there is no mem_store, default to a move with barriers */\n   if (model == MEMMODEL_SEQ_CST || model == MEMMODEL_RELEASE)\n-    expand_builtin_mem_thread_fence (model);\n+    expand_mem_thread_fence (model);\n \n   emit_move_insn (mem, val);\n \n   /* For SEQ_CST, also emit a barrier after the load.  */\n   if (model == MEMMODEL_SEQ_CST)\n-    expand_builtin_mem_thread_fence (model);\n+    expand_mem_thread_fence (model);\n \n   return const0_rtx;\n }"}, {"sha": "ec13f6ff3017d4c33912ed03ace710937a6d59d7", "filename": "gcc/optabs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c39169c82c278bff88da0fcb05516420fbcf808a/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c39169c82c278bff88da0fcb05516420fbcf808a/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=c39169c82c278bff88da0fcb05516420fbcf808a", "patch": "@@ -978,6 +978,10 @@ extern bool can_atomic_exchange_p (enum machine_mode, bool);\n extern bool expand_atomic_compare_and_swap (rtx *, rtx *, rtx, rtx, rtx, bool,\n \t\t\t\t\t    enum memmodel, enum memmodel);\n \n+/* Generate memory barriers.  */\n+extern void expand_mem_thread_fence (enum memmodel);\n+extern void expand_mem_signal_fence (enum memmodel);\n+\n /* Check whether an operation represented by the code CODE is a\n    convert operation that is supported by the target platform in\n    vector form */"}]}