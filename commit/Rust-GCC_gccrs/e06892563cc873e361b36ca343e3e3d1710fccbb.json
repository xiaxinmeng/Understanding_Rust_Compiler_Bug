{"sha": "e06892563cc873e361b36ca343e3e3d1710fccbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA2ODkyNTYzY2M4NzNlMzYxYjM2Y2EzNDNlM2UzZDE3MTBmY2NiYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-12-28T11:36:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-12-28T11:36:37Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r145", "tree": {"sha": "c171ecc29b653a6df5e85d33fe42ef4579ddb967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c171ecc29b653a6df5e85d33fe42ef4579ddb967"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e06892563cc873e361b36ca343e3e3d1710fccbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e06892563cc873e361b36ca343e3e3d1710fccbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e06892563cc873e361b36ca343e3e3d1710fccbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e06892563cc873e361b36ca343e3e3d1710fccbb/comments", "author": null, "committer": null, "parents": [{"sha": "97686cc90e05cc9bff96955336192a95fcfeffed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97686cc90e05cc9bff96955336192a95fcfeffed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97686cc90e05cc9bff96955336192a95fcfeffed"}], "stats": {"total": 1648, "additions": 1013, "deletions": 635}, "files": [{"sha": "15d77b973c765654e05cfab16a7068de266f5434", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1013, "deletions": 635, "changes": 1648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e06892563cc873e361b36ca343e3e3d1710fccbb/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e06892563cc873e361b36ca343e3e3d1710fccbb/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=e06892563cc873e361b36ca343e3e3d1710fccbb", "patch": "@@ -29,7 +29,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    which is the insn code number for the pattern that matched.\n    This is the same as the order in the machine description of the\n    entry that matched.  This number can be used as an index into various\n-   insn_* tables, such as insn_templates, insn_outfun, and insn_n_operands\n+   insn_* tables, such as insn_template, insn_outfun, and insn_n_operands\n    (found in insn-output.c).\n \n    The third argument to recog is an optional pointer to an int.\n@@ -58,37 +58,44 @@ struct obstack *rtl_obstack = &obstack;\n \n extern void free ();\n \n+/* Data structure for a listhead of decision trees.  The alternatives\n+   to a node are kept in a doublely-linked list so we can easily add nodes\n+   to the proper place when merging.  */\n+\n+struct decision_head { struct decision *first, *last; };\n+\n /* Data structure for decision tree for recognizing\n    legitimate instructions.  */\n \n struct decision\n {\n-  int number;\n-  char *position;\n-  RTX_CODE code;\n-  char *exact;\n-  enum machine_mode mode;\n-  char *tests;\n-  int insn_code_number;\n-  int num_clobbers_to_add;\n-  struct decision *next;\n-  struct decision *success;\n-  int opno;\n-  int dupno;\n-  int test_elt_zero_int;\n-  int elt_zero_int;\n-  int test_elt_one_int;\n-  int elt_one_int;\n-  int ignmode;\n-  struct decision *afterward;\n-  int label_needed;\n-  char *c_test;\n-  char enforce_mode;\n-  int veclen;\n-  int subroutine_number;\n-  /* Used for DEFINE_SPLITs.  */\n-  char *c_hook;\n-  rtx split_sequence;\n+  int number;\t\t\t/* Node number, used for labels */\n+  char *position;\t\t/* String denoting position in pattern */\n+  RTX_CODE code;\t\t/* Code to test for or UNKNOWN to suppress */\n+  char ignore_code;\t\t/* If non-zero, need not test code */\n+  char ignore_mode;\t\t/* If non-zero, need not test mode */\n+  int veclen;\t\t\t/* Length of vector, if nonzero */\n+  enum machine_mode mode;\t/* Machine mode of node */\n+  char enforce_mode;\t\t/* If non-zero, test `mode' */\n+  char retest_code, retest_mode; /* See write_tree_1 */\n+  int test_elt_zero_int;\t/* Nonzero if should test XINT (rtl, 0) */\n+  int elt_zero_int;\t\t/* Required value for XINT (rtl, 0) */\n+  int test_elt_one_int;\t\t/* Nonzero if should test XINT (rtl, 1) */\n+  int elt_one_int;\t\t/* Required value for XINT (rtl, 2) */\n+  char *tests;\t\t\t/* If nonzero predicate to call */\n+  int pred;\t\t\t/* `preds' index of predicate or -1 */\n+  char *c_test;\t\t\t/* Additional test to perform */\n+  struct decision_head success;\t/* Nodes to test on success */\n+  int insn_code_number;\t\t/* Insn number matched, if success */\n+  int num_clobbers_to_add;\t/* Number of CLOBBERs to be added to pattern */\n+  struct decision *next;\t/* Node to test on failure */\n+  struct decision *prev;\t/* Node whose failure tests us */\n+  struct decision *afterward;\t/* Node to test on success, but failure of\n+\t\t\t\t   successor nodes */\n+  int opno;\t\t\t/* Operand number, if >= 0 */\n+  int dupno;\t\t\t/* Number of operand to compare against */\n+  int label_needed;\t\t/* Nonzero if label needed when writing tree */\n+  int subroutine_number;\t/* Number of subroutine this node starts */\n };\n \n #define SUBROUTINE_THRESHOLD 50\n@@ -100,53 +107,67 @@ static int next_subroutine_number;\n \n enum routine_type {RECOG, SPLIT};\n \n-static int try_merge_1 ();\n-static int no_same_mode ();\n-static int same_codes ();\n-static int same_modes ();\n+/* Next available node number for tree nodes.  */\n \n-/*\n-static int\n-recognize (top)\n-{\n- staten:\n-  x = XVECEXP (top, 0, 3);\n-  if (test_code (GET_CODE (x))\n-      && test_mode (MODE (x))\n-      && whatever_else)\n-    goto statep;\n-  else if (next one...)\n-    goto statem:\n-  goto stater;\n-\n- statep:\n-  actions...;\n-  return 1;\n+static int next_number;\n \n- statem:\n-  x = stack[depth--];\n-  more tests...;\n+/* Next number to use as an insn_code.  */\n \n- stateq:\n-  stack[++depth] = x;\n-  x = XEXP (stack[depth], 0);\n-  more tests...;\n+static int next_insn_code;\n \n- stater:\n-  x = XEXP (stack[depth], 1);\n-}\n+/* Similar, but counts all expressions in the MD file; used for\n+   error messages. */\n \n-*/\n+static int next_index;\n \n-static int next_number;\n+/* Record the highest depth we ever have so we know how many variables to\n+   allocate in each subroutine we make.  */\n \n-static int next_insn_code;\n+static int max_depth;\n+\f\n+/* This table contains a list of the rtl codes that can possibly match a\n+   predicate defined in recog.c.  The function `not_both_true' uses it to\n+   deduce that there are no expressions that can be matches by certain pairs\n+   of tree nodes.  Also, if a predicate can match only one code, we can\n+   hardwire that code into the node testing the predicate.  */\n \n-static int next_index;\n+static struct pred_table\n+{\n+  char *name;\n+  RTX_CODE codes[NUM_RTX_CODE];\n+} preds[]\n+  = {{\"general_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n+\t\t\t  LABEL_REF, SUBREG, REG, MEM}},\n+#ifdef PREDICATE_CODES\n+     PREDICATE_CODES\n+#endif\n+     {\"address_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n+\t\t\t  LABEL_REF, SUBREG, REG, MEM, PLUS, MINUS, MULT}},\n+     {\"register_operand\", {SUBREG, REG}},\n+     {\"scratch_operand\", {SCRATCH, REG}},\n+     {\"immediate_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n+\t\t\t    LABEL_REF}},\n+     {\"const_int_operand\", {CONST_INT}},\n+     {\"const_double_operand\", {CONST_INT, CONST_DOUBLE}},\n+     {\"nonimmediate_operand\", {SUBREG, REG, MEM}},\n+     {\"nonmemory_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n+\t\t\t    LABEL_REF, SUBREG, REG}},\n+     {\"push_operand\", {MEM}},\n+     {\"memory_operand\", {SUBREG, MEM}},\n+     {\"indirect_operand\", {SUBREG, MEM}},\n+     {\"comparison_operation\", {EQ, NE, LE, LT, GE, LT, LEU, LTU, GEU, GTU}},\n+     {\"mode_independent_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n+\t\t\t\t   LABEL_REF, SUBREG, REG, MEM}}};\n+\n+#define NUM_KNOWN_PREDS (sizeof preds / sizeof preds[0])\n \n+static int try_merge_1 ();\n+static int no_same_mode ();\n+static int same_codes ();\n+static int same_modes ();\n char *xmalloc ();\n static struct decision *add_to_sequence ();\n-static struct decision *merge_trees ();\n+static struct decision_head merge_trees ();\n static struct decision *try_merge_2 ();\n static void write_subroutine ();\n static void print_code ();\n@@ -159,41 +180,44 @@ static char *concat ();\n static void fatal ();\n void fancy_abort ();\n static void mybzero ();\n+static void mybcopy ();\n \f\n-static struct decision *first;\n-\n /* Construct and return a sequence of decisions\n-   that will recognize INSN.  */\n+   that will recognize INSN.\n \n-static struct decision *\n-make_insn_sequence (insn)\n+   TYPE says what type of routine we are recognizing (RECOG or SPLIT).  */\n+\n+static struct decision_head\n+make_insn_sequence (insn, type)\n      rtx insn;\n+     enum routine_type type;\n {\n   rtx x;\n-  char *c_test = XSTR (insn, 2);\n+  char *c_test = XSTR (insn, type == RECOG ? 2 : 1);\n   struct decision *last;\n+  struct decision_head head;\n \n-  if (XVECLEN (insn, 1) == 1)\n-    x = XVECEXP (insn, 1, 0);\n+  if (XVECLEN (insn, type == RECOG) == 1)\n+    x = XVECEXP (insn, type == RECOG, 0);\n   else\n     {\n       x = rtx_alloc (PARALLEL);\n-      XVEC (x, 0) = XVEC (insn, 1);\n+      XVEC (x, 0) = XVEC (insn, type == RECOG);\n       PUT_MODE (x, VOIDmode);\n     }\n \n-  last = add_to_sequence (x, 0, \"\");\n+  last = add_to_sequence (x, &head, \"\");\n \n   if (c_test[0])\n     last->c_test = c_test;\n   last->insn_code_number = next_insn_code;\n   last->num_clobbers_to_add = 0;\n \n-  /* If X is a PARALLEL, see if it ends with a group of CLOBBERs of (hard)\n-     registers or MATCH_SCRATCHes.  If so, set up to recognize the pattern\n-     without these CLOBBERs.  */\n+  /* If this is not a DEFINE_SPLIT and X is a PARALLEL, see if it ends with a\n+     group of CLOBBERs of (hard) registers or MATCH_SCRATCHes.  If so, set up\n+     to recognize the pattern without these CLOBBERs.  */\n \n-  if (GET_CODE (x) == PARALLEL)\n+  if (type == RECOG && GET_CODE (x) == PARALLEL)\n     {\n       int i;\n \n@@ -206,7 +230,7 @@ make_insn_sequence (insn)\n       if (i != XVECLEN (x, 0))\n \t{\n \t  rtx new;\n-\t  struct decision *previous_first = first;\n+\t  struct decision_head clobber_head;\n \n \t  if (i == 1)\n \t    new = XVECEXP (x, 0, 0);\n@@ -220,57 +244,40 @@ make_insn_sequence (insn)\n \t\tXVECEXP (new, 0, j) = XVECEXP (x, 0, j);\n \t    }\n \n-\t  last = add_to_sequence (new, 0, \"\");\n+\t  last = add_to_sequence (new, &clobber_head, \"\");\n \n \t  if (c_test[0])\n \t    last->c_test = c_test;\n \t  last->insn_code_number = next_insn_code;\n \t  last->num_clobbers_to_add = XVECLEN (x, 0) - i;\n-\t  first = merge_trees (previous_first, first);\n+\n+\t  head = merge_trees (head, clobber_head);\n \t}\n     }\n \n   next_insn_code++;\n-  return first;\n-}\n \n-static struct decision *\n-make_split_sequence (insn)\n-     rtx insn;\n-{\n-  rtx x;\n-  char *c_test = XSTR (insn, 1);\n-  char *c_hook = XSTR (insn, 3);\n-  struct decision *last;\n-\n-  if (XVECLEN (insn, 0) == 1)\n-    x = XVECEXP (insn, 0, 0);\n-  else\n-    {\n-      x = rtx_alloc (PARALLEL);\n-      XVEC (x, 0) = XVEC (insn, 0);\n-      PUT_MODE (x, VOIDmode);\n-    }\n+  if (type == SPLIT)\n+    /* Define the subroutine we will call below and emit in genemit.  */\n+    printf (\"extern rtx gen_split_%d ();\\n\", last->insn_code_number);\n \n-  last = add_to_sequence (x, 0, \"\");\n+  return head;\n+}\n+\f\n+/* Create a chain of nodes to verify that an rtl expression matches\n+   PATTERN.\n \n-  if (c_test[0])\n-    last->c_test = c_test;\n-  if (c_hook != 0 && c_hook[0] != 0)\n-    last->c_hook = c_hook;\n-  last->split_sequence = XEXP (insn, 2);\n-  last->insn_code_number = next_insn_code++;\n+   LAST is a pointer to the listhead in the previous node in the chain (or\n+   in the calling function, for the first node).\n \n-  /* Define the subroutine we will call below and emit in genemit.  */\n-  printf (\"extern rtx gen_split_%d ();\\n\", last->insn_code_number);\n+   POSITION is the string representing the current position in the insn.\n \n-  return first;\n-}\n+   A pointer to the final node in the chain is returned.  */\n \n static struct decision *\n add_to_sequence (pattern, last, position)\n      rtx pattern;\n-     struct decision *last;\n+     struct decision_head *last;\n      char *position;\n {\n   register RTX_CODE code;\n@@ -280,102 +287,118 @@ add_to_sequence (pattern, last, position)\n   char *newpos;\n   register char *fmt;\n   register int i;\n-  int depth;\n+  int depth = strlen (position);\n   int len;\n \n+  if (depth > max_depth)\n+    max_depth = depth;\n+\n   new->number = next_number++;\n   new->position = copystr (position);\n-  new->exact = 0;\n-  new->next = 0;\n-  new->success = 0;\n-  new->insn_code_number = -1;\n-  new->num_clobbers_to_add = 0;\n-  new->tests = 0;\n-  new->opno = -1;\n-  new->dupno = -1;\n+  new->ignore_code = 0;\n+  new->ignore_mode = 0;\n+  new->enforce_mode = 1;\n+  new->retest_code = new->retest_mode = 0;\n+  new->veclen = 0;\n   new->test_elt_zero_int = 0;\n   new->test_elt_one_int = 0;\n   new->elt_zero_int = 0;\n   new->elt_one_int = 0;\n-  new->enforce_mode = 0;\n-  new->ignmode = 0;\n+  new->tests = 0;\n+  new->pred = -1;\n+  new->c_test = 0;\n+  new->success.first = new->success.last = 0;\n+  new->insn_code_number = -1;\n+  new->num_clobbers_to_add = 0;\n+  new->next = 0;\n+  new->prev = 0;\n   new->afterward = 0;\n+  new->opno = -1;\n+  new->dupno = -1;\n   new->label_needed = 0;\n-  new->c_test = 0;\n-  new->c_hook = 0;\n-  new->split_sequence = 0;\n-  new->veclen = 0;\n   new->subroutine_number = 0;\n \n   this = new;\n \n-  if (last == 0)\n-    first = new;\n-  else\n-    last->success = new;\n+  last->first = last->last = new;\n \n-  depth = strlen (position);\n   newpos = (char *) alloca (depth + 2);\n   strcpy (newpos, position);\n   newpos[depth + 1] = 0;\n \n  restart:\n \n-  if (pattern == 0)\n-    {\n-      new->exact = \"0\";\n-      new->code = UNKNOWN;\n-      new->mode = VOIDmode;\n-      return new;\n-    }\n-\n   new->mode = GET_MODE (pattern);\n   new->code = code = GET_CODE (pattern);\n \n   switch (code)\n     {\n     case MATCH_OPERAND:\n-      new->opno = XINT (pattern, 0);\n-      new->code = UNKNOWN;\n-      new->tests = XSTR (pattern, 1);\n-      if (*new->tests == 0)\n-\tnew->tests = 0;\n-      return new;\n-\n     case MATCH_SCRATCH:\n-      new->opno = XINT (pattern, 0);\n-      new->code = UNKNOWN;\n-      new->tests = \"scratch_operand\";\n-      if (*new->tests == 0)\n-\tnew->tests = 0;\n-      return new;\n-\n     case MATCH_OPERATOR:\n-      new->opno = XINT (pattern, 0);\n-      new->code = UNKNOWN;\n-      new->tests = XSTR (pattern, 1);\n-      if (*new->tests == 0)\n-\tnew->tests = 0;\n-      for (i = 0; i < XVECLEN (pattern, 2); i++)\n-\t{\n-\t  newpos[depth] = i + '0';\n-\t  new = add_to_sequence (XVECEXP (pattern, 2, i), new, newpos);\n-\t}\n-      this->success->enforce_mode = 0;\n-      return new;\n-\n     case MATCH_PARALLEL:\n       new->opno = XINT (pattern, 0);\n-      new->code = PARALLEL;\n-      new->tests = XSTR (pattern, 1);\n+      new->code = (code == MATCH_PARALLEL ? PARALLEL : UNKNOWN);\n+      new->enforce_mode = 0;\n+\n+      if (code == MATCH_SCRATCH)\n+\tnew->tests = \"scratch_operand\";\n+      else\n+\tnew->tests = XSTR (pattern, 1);\n+\n       if (*new->tests == 0)\n \tnew->tests = 0;\n-      for (i = 0; i < XVECLEN (pattern, 2); i++)\n+\n+      /* See if we know about this predicate and save its number.  If we do,\n+\t and it only accepts one code, note that fact.  The predicate\n+\t `const_int_operand' only tests for a CONST_INT, so if we do so we\n+\t can avoid calling it at all.\n+\n+\t Finally, if we know that the predicate does not allow CONST_INT, we\n+\t know that the only way the predicate can match is if the modes match\n+\t (here we use the kluge of relying on the fact that \"address_operand\"\n+\t accepts CONST_INT; otherwise, it would have to be a special case),\n+\t so we can test the mode (but we need not).  This fact should\n+\t considerably simplify the generated code.  */\n+\n+      if (new->tests)\n+\tfor (i = 0; i < NUM_KNOWN_PREDS; i++)\n+\t  if (! strcmp (preds[i].name, new->tests))\n+\t    {\n+\t      int j;\n+\t      int allows_const_int = 0;\n+\n+\t      new->pred = i;\n+\n+\t      if (preds[i].codes[1] == 0 && new->code == UNKNOWN)\n+\t\t{\n+\t\t  new->code = preds[i].codes[0];\n+\t\t  if (! strcmp (\"const_int_operand\", new->tests))\n+\t\t    new->tests = 0;\n+\t\t}\n+\n+\t      for (j = 0; j < NUM_RTX_CODE && preds[i].codes[j] != 0; j++)\n+\t\tif (preds[i].codes[j] == CONST_INT)\n+\t\t  allows_const_int = 1;\n+\n+\t      if (! allows_const_int)\n+\t\tnew->enforce_mode = new->ignore_mode= 1;\n+\n+\t      break;\n+\t    }\n+\n+      if (code == MATCH_OPERATOR || code == MATCH_PARALLEL)\n \t{\n-\t  newpos[depth] = i + 'a';\n-\t  new = add_to_sequence (XVECEXP (pattern, 2, i), new, newpos);\n+\t  for (i = 0; i < XVECLEN (pattern, 2); i++)\n+\t    {\n+\t      newpos[depth] = i + (code == MATCH_OPERATOR ? '0': 'a');\n+\t      new = add_to_sequence (XVECEXP (pattern, 2, i),\n+\t\t\t\t     &new->success, newpos);\n+\t    }\n+\n+\t  this->success.first->enforce_mode = 0;\n \t}\n-      this->success->enforce_mode = 0;\n+\n       return new;\n \n     case MATCH_OP_DUP:\n@@ -386,82 +409,79 @@ add_to_sequence (pattern, last, position)\n       for (i = 0; i < XVECLEN (pattern, 1); i++)\n \t{\n \t  newpos[depth] = i + '0';\n-\t  new = add_to_sequence (XVECEXP (pattern, 1, i), new, newpos);\n+\t  new = add_to_sequence (XVECEXP (pattern, 1, i),\n+\t\t\t\t &new->success, newpos);\n \t}\n-      this->success->enforce_mode = 0;\n+      this->success.first->enforce_mode = 0;\n       return new;\n \n     case MATCH_DUP:\n       new->dupno = XINT (pattern, 0);\n       new->code = UNKNOWN;\n+      new->enforce_mode = 0;\n       return new;\n \n     case ADDRESS:\n       pattern = XEXP (pattern, 0);\n       goto restart;\n \n-    case PC:\n-      new->exact = \"pc_rtx\";\n-      return new;\n-\n-    case CC0:\n-      new->exact = \"cc0_rtx\";\n-      return new;\n-\n-    case CONST_INT:\n-      if (INTVAL (pattern) == 0)\n-\t{\n-\t  new->exact = \"const0_rtx\";\n-\t  return new;\n-\t}\n-      if (INTVAL (pattern) == 1)\n-\t{\n-\t  new->exact = \"const1_rtx\";\n-\t  return new;\n-\t}\n-      if (INTVAL (pattern) == -1)\n-\t{\n-\t  new->exact = \"constm1_rtx\";\n-\t  return new;\n-\t}\n-      if (INTVAL (pattern) == STORE_FLAG_VALUE)\n-\t{\n-\t  new->exact = \"const_true_rtx\";\n-\t  return new;\n-\t}\n-      break;\n-\n     case SET:\n       newpos[depth] = '0';\n-      new = add_to_sequence (SET_DEST (pattern), new, newpos);\n-      this->success->enforce_mode = 1;\n+      new = add_to_sequence (SET_DEST (pattern), &new->success, newpos);\n+      this->success.first->enforce_mode = 1;\n       newpos[depth] = '1';\n-      new = add_to_sequence (SET_SRC (pattern), new, newpos);\n+      new = add_to_sequence (SET_SRC (pattern), &new->success, newpos);\n+\n+      /* If set are setting CC0 from anything other than a COMPARE, we\n+\t must enforce the mode so that we do not produce ambiguous insns.  */\n+      if (GET_CODE (SET_DEST (pattern)) == CC0\n+\t  && GET_CODE (SET_SRC (pattern)) != COMPARE)\n+\tthis->success.first->enforce_mode = 1;\n       return new;\n \n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n     case STRICT_LOW_PART:\n       newpos[depth] = '0';\n-      new = add_to_sequence (XEXP (pattern, 0), new, newpos);\n-      this->success->enforce_mode = 1;\n+      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos);\n+      this->success.first->enforce_mode = 1;\n       return new;\n \n     case SUBREG:\n       this->test_elt_one_int = 1;\n       this->elt_one_int = XINT (pattern, 1);\n       newpos[depth] = '0';\n-      new = add_to_sequence (XEXP (pattern, 0), new, newpos);\n-      this->success->enforce_mode = 1;\n+      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos);\n+      this->success.first->enforce_mode = 1;\n       return new;\n \n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n       newpos[depth] = '0';\n-      new = add_to_sequence (XEXP (pattern, 0), new, newpos);\n-      this->success->enforce_mode = 1;\n+      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos);\n+      this->success.first->enforce_mode = 1;\n       newpos[depth] = '1';\n-      new = add_to_sequence (XEXP (pattern, 1), new, newpos);\n+      new = add_to_sequence (XEXP (pattern, 1), &new->success, newpos);\n       newpos[depth] = '2';\n-      new = add_to_sequence (XEXP (pattern, 2), new, newpos);\n+      new = add_to_sequence (XEXP (pattern, 2), &new->success, newpos);\n+      return new;\n+\n+    case EQ:   case NE:   case LE:   case LT:   case GE:  case GT:\n+    case LEU:  case LTU:  case GEU:  case GTU:\n+      /* If the first operand is (cc0), we don't have to do anything\n+\t special.  */\n+      if (GET_CODE (XEXP (pattern, 0)) == CC0)\n+\tbreak;\n+\n+      /* ... fall through ... */\n+      \n+    case COMPARE:\n+      /* Enforce the mode on the first operand to avoid ambiguous insns.  */\n+      newpos[depth] = '0';\n+      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos);\n+      this->success.first->enforce_mode = 1;\n+      newpos[depth] = '1';\n+      new = add_to_sequence (XEXP (pattern, 1), &new->success, newpos);\n       return new;\n     }\n \n@@ -471,7 +491,7 @@ add_to_sequence (pattern, last, position)\n     {\n       newpos[depth] = '0' + i;\n       if (fmt[i] == 'e' || fmt[i] == 'u')\n-\tnew = add_to_sequence (XEXP (pattern, i), new, newpos);\n+\tnew = add_to_sequence (XEXP (pattern, i), &new->success, newpos);\n       else if (fmt[i] == 'i' && i == 0)\n \t{\n \t  this->test_elt_zero_int = 1;\n@@ -498,552 +518,863 @@ add_to_sequence (pattern, last, position)\n \t    {\n \t      newpos[depth] = 'a' + j;\n \t      new = add_to_sequence (XVECEXP (pattern, i, j),\n-\t\t\t\t     new, newpos);\n+\t\t\t\t     &new->success, newpos);\n \t    }\n \t}\n       else if (fmt[i] != '0')\n \tabort ();\n     }\n   return new;\n }\n+\f\n+/* Return 1 if we can prove that there is no RTL that can match both\n+   D1 and D2.  Otherwise, return 0 (it may be that there is an RTL that\n+   can match both or just that we couldn't prove there wasn't such an RTL).\n \n-/* Merge two decision trees OLD and ADD,\n-   modifying OLD destructively,\n-   and return the merged tree.  */\n+   TOPLEVEL is non-zero if we are to only look at the top level and not\n+   recursively descend.  */\n \n-static struct decision *\n-merge_trees (old, add)\n-     register struct decision *old, *add;\n+static int\n+not_both_true (d1, d2, toplevel)\n+     struct decision *d1, *d2;\n+     int toplevel;\n {\n-  while (add)\n-    {\n-      register struct decision *next = add->next;\n-      add->next = 0;\n-      if (!try_merge_1 (old, add))\n-\told = try_merge_2 (old, add);\n-      add = next;\n-    }\n-  return old;\n-}\n+  struct decision *p1, *p2;\n+\n+  /* If they are both to test modes and the modes are different, they aren't\n+     both true.  Similarly for codes, integer elements, and vector lengths. */\n+\n+  if ((d1->enforce_mode && d2->enforce_mode\n+       && d1->mode != VOIDmode && d2->mode != VOIDmode && d1->mode != d2->mode)\n+      || (d1->code != UNKNOWN && d2->code != UNKNOWN && d1->code != d2->code)\n+      || (d1->test_elt_zero_int && d2->test_elt_zero_int\n+\t  && d1->elt_zero_int != d2->elt_zero_int)\n+      || (d1->test_elt_one_int && d2->test_elt_one_int\n+\t  && d1->elt_one_int != d2->elt_one_int)\n+      || (d1->veclen && d2->veclen && d1->veclen != d2->veclen))\n+    return 1;\n+\n+  /* If either is a wild-card MATCH_OPERAND without a predicate, it can match\n+     absolutely anything, so we can't say that no intersection is possible.\n+     This case is detected by having a zero TESTS field with a code of\n+     UNKNOWN.  */\n+\n+  if ((d1->tests == 0 && d1->code == UNKNOWN)\n+      || (d2->tests == 0 && d2->code == UNKNOWN))\n+    return 0;\n \n-/* Merge ADD into the next-chain starting with OLD\n-   only if it overlaps a condition already tested in OLD.\n-   Returns 1 if successful (OLD is modified),\n-   0 if nothing has been done.  */\n+  /* If either has a predicate that we know something about, set things up so\n+     that D1 is the one that always has a known predicate.  Then see if they\n+     have any codes in common.  */\n \n-static int\n-try_merge_1 (old, add)\n-     register struct decision *old, *add;\n-{\n-  while (old)\n+  if (d1->pred >= 0 || d2->pred >= 0)\n     {\n-      if ((old->position == add->position\n-\t   || (old->position && add->position\n-\t       && !strcmp (old->position, add->position)))\n-\t  && (old->tests == add->tests\n-\t      || (old->tests && add->tests && !strcmp (old->tests, add->tests)))\n-\t  && (old->c_test == add->c_test\n-\t      || (old->c_test && add->c_test && !strcmp (old->c_test, add->c_test)))\n-\t  && (old->c_hook == add->c_hook\n-\t      || (old->c_hook && add->c_hook && !strcmp (old->c_hook, add->c_hook)))\n-\t  && old->test_elt_zero_int == add->test_elt_zero_int\n-\t  && old->elt_zero_int == add->elt_zero_int\n-\t  && old->test_elt_one_int == add->test_elt_one_int\n-\t  && old->elt_one_int == add->elt_one_int\n-\t  && old->veclen == add->veclen\n-\t  && old->dupno == add->dupno\n-\t  && old->opno == add->opno\n-/* In a collection of nodes that don't have predicates,\n-   we can always merge a new one with any node that matches it.\n-   This is because we know that two different nodes can't possibly match\n-   the same RTL object.  So we can reorder the tests to simplify the\n-   whole collection of them.\n-\n-   But when predicates are involved, we have to preserve the order of\n-   testing them.  This means that a new node can only be merged with the\n-   last existing node.\n-\n-   enforce_mode indicates that at this level each of the nodes\n-   requires a particular mode.  When this is true, then we know\n-   that two nodes with different modes can't possibly both match.\n-   Therefore, it is ok to merge a new node with the last node\n-   that wants the same mode, even if other nodes for different modes\n-   appear after it.  no_same_mode tests for this condition.  */\n-\t  && (old->tests == 0\n-\t      || (add->enforce_mode ? no_same_mode (old) : old->next == 0))\n-\t  && old->code == add->code\n-\t  && old->mode == add->mode\n-\t  && (old->exact == add->exact\n-\t      || (old->exact && add->exact && ! strcmp (old->exact, add->exact))))\n+      int i, j;\n+\n+      if (d2->pred >= 0)\n+\tp1 = d1, d1 = d2, d2 = p1;\n+\n+      /* If D2 tests an explicit code, see if it is in the list of valid codes\n+\t for D1's predicate.  */\n+      if (d2->code != UNKNOWN)\n \t{\n-\t  old->success = merge_trees (old->success, add->success);\n-\t  if (old->insn_code_number >= 0 && add->insn_code_number >= 0)\n-\t    fatal (\"Two actions at one point in tree\");\n-\t  if (old->insn_code_number == -1)\n-\t    old->insn_code_number = add->insn_code_number;\n-\t  return 1;\n+\t  for (i = 0; i < NUM_RTX_CODE && preds[d1->pred].codes[i]; i++)\n+\t    if (preds[d1->pred].codes[i] == d2->code)\n+\t      break;\n+\n+\t  if (preds[d1->pred].codes[i] == 0)\n+\t    return 1;\n+\t}\n+\n+      /* Otherwise see if the predicates have any codes in common.  */\n+\n+      else if (d2->pred >= 0)\n+\t{\n+\t  for (i = 0; i < NUM_RTX_CODE && preds[d1->pred].codes[i]; i++)\n+\t    {\n+\t      for (j = 0; j < NUM_RTX_CODE; j++)\n+\t\tif (preds[d2->pred].codes[j] == 0\n+\t\t    || preds[d2->pred].codes[j] == preds[d1->pred].codes[i])\n+\t\t  break;\n+\n+\t      if (preds[d2->pred].codes[j] != 0)\n+\t\tbreak;\n+\t    }\n+\n+\t  if (preds[d1->pred].codes[i] == 0)\n+\t    return 1;\n \t}\n-      old = old->next;\n     }\n-  return 0;\n-}\n \n-/* Merge ADD into the next-chain that starts with OLD,\n-   preferably after something that tests the same place\n-   that ADD does.\n-   The next-chain of ADD itself is ignored, and it is set\n-   up for entering ADD into the new chain.\n-   Returns the new chain.  */\n+  /* If we got here, we can't prove that D1 and D2 cannot both be true.\n+     If we are only to check the top level, return 0.  Otherwise, see if\n+     we can prove that all choices in both successors are mutually\n+     exclusive.  If either does not have any successors, we can't prove\n+     they can't both be true.  */\n \n-static struct decision *\n-try_merge_2 (old, add)\n-     struct decision *old, *add;\n+  if (toplevel || d1->success.first == 0 || d2->success.first == 0)\n+    return 0;\n+\n+  for (p1 = d1->success.first; p1; p1 = p1->next)\n+    for (p2 = d2->success.first; p2; p2 = p2->next)\n+      if (! not_both_true (p1, p2, 0))\n+\treturn 0;\n+\n+  return 1;\n+}\n+\f\n+/* Assuming that we can reorder all the alternatives at a specific point in\n+   the tree (see discussion in merge_trees), we would prefer an ordering of\n+   nodes where groups of consecutive nodes test the same mode and, within each\n+   mode, groups of nodes test the same code.  With this order, we can\n+   construct nested switch statements, the inner one to test the code and\n+   the outer one to test the mode.\n+\n+   We would like to list nodes testing for specific codes before those\n+   that test predicates to avoid unnecessary function calls.  Similarly,\n+   tests for specific modes should preceed nodes that allow any mode.\n+\n+   This function returns the merit (with 0 being the best) of inserting\n+   a test involving the specified MODE and CODE after node P.  If P is\n+   zero, we are to determine the merit of inserting the test at the front\n+   of the list.  */\n+\n+static int\n+position_merit (p, mode, code)\n+     struct decision *p;\n+     enum machine_mode mode;\n+     RTX_CODE code;\n {\n-  register struct decision *p;\n-  struct decision *last = 0;\n-  struct decision *last_same_place = 0;\n+  enum machine_mode p_mode;\n \n-  /* Put this in after the others that test the same place,\n-     if there are any.  If not, find the last chain element\n-     and insert there.\n+  /* The only time the front of the list is anything other than the worst\n+     position is if we are testing a mode that isn't VOIDmode.  */\n+  if (p == 0)\n+    return mode == VOIDmode ? 3 : 2;\n \n-     One modification: if this one is NOT a MATCH_OPERAND,\n-     put it before any MATCH_OPERANDS that test the same place.\n+  p_mode = p->enforce_mode ? p->mode : VOIDmode;\n \n-     Another: if enforce_mode (i.e. this is first operand of a SET),\n-     put this after the last thing that tests the same place for\n-     the same mode.  */\n+  /* The best case is if the codes and modes both match.  */\n+  if (p_mode == mode && p->code== code)\n+    return 0;\n \n-#if 0\n-  int operand = 0 != add->tests;\n-#endif\n+  /* If the codes don't match, the next best case is if the modes match.\n+     In that case, the best position for this node depends on whether\n+     we are testing for a specific code or not.  If we are, the best place\n+     is after some other test for an explicit code and our mode or after\n+     the last test in the previous mode if every test in our mode is for\n+     an unknown code.\n+\n+     If we are testing for UNKNOWN, then the next best case is at the end of\n+     our mode.  */\n+\n+  if ((code != UNKNOWN\n+       && ((p_mode == mode && p->code != UNKNOWN)\n+\t   || (p_mode != mode && p->next\n+\t       && (p->next->enforce_mode ? p->next->mode : VOIDmode) == mode\n+\t       && (p->next->code == UNKNOWN))))\n+      || (code == UNKNOWN && p_mode == mode\n+\t  && (p->next == 0\n+\t      || (p->next->enforce_mode ? p->next->mode : VOIDmode) != mode)))\n+    return 1;\n+\n+  /* The third best case occurs when nothing is testing MODE.  If MODE\n+     is not VOIDmode, then the third best case is after something of any\n+     mode that is not VOIDmode.  If we are testing VOIDmode, the third best\n+     place is the end of the list.  */\n+\n+  if (p_mode != mode\n+      && ((mode != VOIDmode && p_mode != VOIDmode)\n+\t  || (mode == VOIDmode && p->next == 0)))\n+    return 2;\n+\n+  /* Otherwise, we have the worst case.  */\n+  return 3;\n+}\n+\f\n+/* Merge two decision tree listheads OLDH and ADDH,\n+   modifying OLDH destructively, and return the merged tree.  */\n+\n+static struct decision_head\n+merge_trees (oldh, addh)\n+     register struct decision_head oldh, addh;\n+{\n+  struct decision *add, *next;\n+\n+  if (oldh.first == 0)\n+    return addh;\n+\n+  if (addh.first == 0)\n+    return oldh;\n \n-  for (p = old; p; p = p->next)\n+  /* If we are adding things at different positions, something is wrong.  */\n+  if (strcmp (oldh.first->position, addh.first->position))\n+    abort ();\n+\n+  for (add = addh.first; add; add = next)\n     {\n-      if (p->position == add->position\n-\t  || (p->position && add->position\n-\t      && !strcmp (p->position, add->position)))\n+      enum machine_mode add_mode = add->enforce_mode ? add->mode : VOIDmode;\n+      struct decision *best_position = 0;\n+      int best_merit = 4;\n+      struct decision *old;\n+\n+      next = add->next;\n+\n+      /* The semantics of pattern matching state that the tests are done in\n+\t the order given in the MD file so that if an insn matches two\n+\t patterns, the first one will be used.  However, in practice, most,\n+\t if not all, patterns are unambiguous so that their order is \n+\t independent.  In that case, we can merge identical tests and\n+\t group all similar modes and codes together.\n+\n+\t Scan starting from the end of OLDH until we reach a point\n+\t where we reach the head of the list or where we pass a pattern\n+\t that could also be true if NEW is true.  If we find an identical\n+\t pattern, we can merge them.  Also, record the last node that tests\n+\t the same code and mode and the last one that tests just the same mode.\n+\n+\t If we have no match, place NEW after the closest match we found.  */\n+\t \n+      for (old = oldh.last; old; old = old->prev)\n \t{\n-\t  last_same_place = p;\n-\t  /* If enforce_mode, segregate the modes in numerical order.  */\n-\t  if (p->enforce_mode && (int) add->mode < (int) p->mode)\n-\t    break;\n-#if 0\n-\t  /* Keep explicit decompositions before those that test predicates.\n-\t     If enforce_mode, do this separately within each mode.  */\n-\t  if (! p->enforce_mode || p->mode == add->mode)\n-\t    if (!operand && p->tests)\n+\t  int our_merit;\n+\n+\t  /* If we don't have anything to test except an additional test,\n+\t     do not consider the two nodes equal.  If we did, the test below\n+\t     would cause an infinite recursion.  */\n+\t  if (old->tests == 0 && old->test_elt_zero_int == 0\n+\t      && old->test_elt_one_int == 0 && old->veclen == 0\n+\t      && old->dupno == -1 && old->mode == VOIDmode\n+\t      && old->code == UNKNOWN\n+\t      && (old->c_test != 0 || add->c_test != 0))\n+\t    ;\n+\n+\t  else if ((old->tests == add->tests\n+\t\t    || (old->pred >= 0 && old->pred == add->pred)\n+\t\t    || (old->tests && add->tests\n+\t\t\t&& !strcmp (old->tests, add->tests)))\n+\t      && old->test_elt_zero_int == add->test_elt_zero_int\n+\t      && old->elt_zero_int == add->elt_zero_int\n+\t      && old->test_elt_one_int == add->test_elt_one_int\n+\t      && old->elt_one_int == add->elt_one_int\n+\t      && old->veclen == add->veclen\n+\t      && old->dupno == add->dupno\n+\t      && old->opno == add->opno\n+\t      && old->code == add->code\n+\t      && old->enforce_mode == add->enforce_mode\n+\t      && old->mode == add->mode)\n+\t    {\n+\t      /* If the additional test is not the same, split both nodes\n+\t\t into nodes that just contain all things tested before the\n+\t\t additional test and nodes that contain the additional test\n+\t\t and actions when it is true.  This optimization is important\n+\t\t because of the case where we have almost identical patterns\n+\t\t with different tests on target flags.  */\n+\n+\t      if (old->c_test != add->c_test\n+\t\t  && ! (old->c_test && add->c_test\n+\t\t\t&& !strcmp (old->c_test, add->c_test)))\n+\t\t{\n+\t\t  if (old->insn_code_number >= 0 || old->opno >= 0)\n+\t\t    {\n+\t\t      struct decision *split\n+\t\t\t= (struct decision *) xmalloc (sizeof (struct decision));\n+\n+\t\t      mybcopy (old, split, sizeof (struct decision));\n+\n+\t\t      old->success.first = old->success.last = split;\n+\t\t      old->c_test = 0;\n+\t\t      old->opno = -1;\n+\t\t      old->insn_code_number = -1;\n+\t\t      old->num_clobbers_to_add = 0;\n+\n+\t\t      split->number = next_number++;\n+\t\t      split->next = split->prev = 0;\n+\t\t      split->mode = VOIDmode;\n+\t\t      split->code = UNKNOWN;\n+\t\t      split->veclen = 0;\n+\t\t      split->test_elt_zero_int = 0;\n+\t\t      split->test_elt_one_int = 0;\n+\t\t      split->tests = 0;\n+\t\t      split->pred = -1;\n+\t\t    }\n+\n+\t\t  if (add->insn_code_number >= 0 || add->opno >= 0)\n+\t\t    {\n+\t\t      struct decision *split\n+\t\t\t= (struct decision *) xmalloc (sizeof (struct decision));\n+\n+\t\t      mybcopy (add, split, sizeof (struct decision));\n+\n+\t\t      add->success.first = add->success.last = split;\n+\t\t      add->c_test = 0;\n+\t\t      add->opno = -1;\n+\t\t      add->insn_code_number = -1;\n+\t\t      add->num_clobbers_to_add = 0;\n+\n+\t\t      split->number = next_number++;\n+\t\t      split->next = split->prev = 0;\n+\t\t      split->mode = VOIDmode;\n+\t\t      split->code = UNKNOWN;\n+\t\t      split->veclen = 0;\n+\t\t      split->test_elt_zero_int = 0;\n+\t\t      split->test_elt_one_int = 0;\n+\t\t      split->tests = 0;\n+\t\t      split->pred = -1;\n+\t\t    }\n+\t\t}\n+\n+\t      old->success = merge_trees (old->success, add->success);\n+\t      if (old->insn_code_number >= 0 && add->insn_code_number >= 0)\n+\t\tfatal (\"Two actions at one point in tree\");\n+\t      if (old->insn_code_number == -1)\n+\t\told->insn_code_number = add->insn_code_number;\n+\t      add = 0;\n \t      break;\n-#endif\n+\t    }\n+\n+\t  /* Unless we have already found the best possible insert point,\n+\t     see if this position is better.  If so, record it.  */\n+\n+\t  if (best_merit != 0\n+\t      && ((our_merit = position_merit (old, add_mode, add->code))\n+\t\t  < best_merit))\n+\t    best_merit = our_merit, best_position = old;\n+\n+\t  if (! not_both_true (old, add, 0))\n+\t    break;\n \t}\n-      /* If this is past the end of the decisions at the same place as ADD,\n-\t stop looking now; add ADD before here.  */\n-      else if (last_same_place)\n-\tbreak;\n-      last = p;\n-    }\n \n-  /* Insert before P, which means after LAST.  */\n+      /* If ADD was duplicate, we are done.  */\n+      if (add == 0)\n+\tcontinue;\n \n-  if (last)\n-    {\n-      add->next = last->next;\n-      last->next = add;\n-      return old;\n-    }\n+      /* Otherwise, find the best place to insert ADD.  Normally this is\n+\t BEST_POSITION.  However, if we went all the way to the top of\n+\t the list, it might be better to insert at the top.  */\n \n-  add->next = old;\n-  return add;\n-}\n+      if (best_position == 0)\n+\tabort ();\n \n-static int\n-no_same_mode (node)\n-     struct decision *node;\n-{\n-  register struct decision *p;\n-  register enum machine_mode mode = node->mode;\n+      if (old == 0 && position_merit (0, add_mode, add->code) < best_merit)\n+\t{\n+\t  add->prev = 0;\n+\t  add->next = oldh.first;\n+\t  oldh.first->prev = add;\n+\t  oldh.first = add;\n+\t}\n \n-  for (p = node->next; p; p = p->next)\n-    if (p->mode == mode)\n-      return 0;\n+      else\n+\t{\n+\t  add->prev = best_position;\n+\t  add->next = best_position->next;\n+\t  best_position->next = add;\n+\t  if (best_position == oldh.last)\n+\t    oldh.last = add;\n+\t  else\n+\t    add->next->prev = add;\n+\t}\n+    }\n \n-  return 1;\n+  return oldh;\n }\n \f\n-/* Count the number of subnodes of node NODE, assumed to be the start\n-   of a next-chain.  If the number is high enough, make NODE start\n-   a separate subroutine in the C code that is generated.\n+/* Count the number of subnodes of HEAD.  If the number is high enough,\n+   make the first node in HEAD start a separate subroutine in the C code\n+   that is generated.\n \n-   TYPE gives the type of routine we are writing.  */\n+   TYPE gives the type of routine we are writing.\n+\n+   INITIAL is non-zero if this is the highest-level node.  We never write\n+   it out here.  */\n \n static int\n-break_out_subroutines (node, type)\n-     struct decision *node;\n+break_out_subroutines (head, type, initial)\n+     struct decision_head head;\n      enum routine_type type;\n+     int initial;\n {\n   int size = 0;\n-  struct decision *sub;\n-  for (sub = node; sub; sub = sub->next)\n-    size += 1 + break_out_subroutines (sub->success, type);\n-  if (size > SUBROUTINE_THRESHOLD)\n+  struct decision *node, *sub;\n+\n+  for (sub = head.first; sub; sub = sub->next)\n+    size += 1 + break_out_subroutines (sub->success, type, 0);\n+\n+  if (size > SUBROUTINE_THRESHOLD && ! initial)\n     {\n-      node->subroutine_number = ++next_subroutine_number;\n-      write_subroutine (node, type);\n+      head.first->subroutine_number = ++next_subroutine_number;\n+      write_subroutine (head.first, type);\n       size = 1;\n     }\n   return size;\n }\n+\f\n+/* Write out a subroutine of type TYPE to do comparisons starting at node\n+   TREE.  */\n \n static void\n write_subroutine (tree, type)\n      struct decision *tree;\n      enum routine_type type;\n {\n-  char *return_type = (type == SPLIT ? \"rtx\" : \"int\");\n+  int i;\n \n   if (type == SPLIT)\n-    {\n-      printf (\"rtx\\nsplit_%d (x0, insn)\\n\", tree->subroutine_number);\n-      printf (\"     register rtx x0;\\n     rtx insn;\\n\");\n-    }\n+    printf (\"rtx\\nsplit\");\n   else\n-    {\n-      printf (\"int\\nrecog_%d (x0, insn, pnum_clobbers)\\n\",\n-\t      tree->subroutine_number);\n-      printf (\"     register rtx x0;\\n     rtx insn;\\n\");\n-      printf (\"     int *pnum_clobbers;\\n\");\n-    }\n+    printf (\"int\\nrecog\");\n+\n+  if (tree != 0 && tree->subroutine_number > 0)\n+    printf (\"_%d\", tree->subroutine_number);\n+  else if (type == SPLIT)\n+    printf (\"_insns\");\n+\n+  printf (\" (x0, insn\");\n+  if (type == RECOG)\n+    printf (\", pnum_clobbers\");\n+\n+  printf (\")\\n\");\n+  printf (\"     register rtx x0;\\n     rtx insn;\\n\");\n+  if (type == RECOG)\n+    printf (\"     int *pnum_clobbers;\\n\");\n \n   printf (\"{\\n\");\n   printf (\"  register rtx *ro = &recog_operand[0];\\n\");\n-  printf (\"  register rtx x1, x2, x3, x4, x5;\\n  rtx x6, x7, x8, x9, x10, x11;\\n\");\n-  printf (\"  %s tem;\\n\", return_type);\n-  write_tree (tree, \"\", 0, \"\", 1, type);\n+\n+  printf (\"  register rtx \");\n+  for (i = 1; i < max_depth; i++)\n+    printf (\"x%d, \", i);\n+\n+  printf (\"x%d;\\n\", max_depth);\n+  printf (\"  %s tem;\\n\", type == SPLIT ? \"rtx\" : \"int\");\n+  write_tree (tree, \"\", 0, 1, type);\n   printf (\" ret0: return %d;\\n}\\n\\n\", type == SPLIT ? 0 : -1);\n }\n \f\n-/* Write out C code to perform the decisions in the tree.  */\n+/* This table is used to indent the recog_* functions when we are inside\n+   conditions or switch statements.  We only support small indentations\n+   and always indent at least two spaces.  */\n+\n+static char *indents[]\n+  = {\"  \", \"  \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \",\n+     \"\\t\", \"\\t \", \"\\t  \", \"\\t   \", \"\\t    \", \"\\t     \", \"\\t      \",\n+     \"\\t\\t\", \"\\t\\t \", \"\\t\\t  \", \"\\t\\t   \", \"\\t\\t    \", \"\\t\\t     \"};\n+\n+/* Write out C code to perform the decisions in TREE for a subroutine of\n+   type TYPE.  If all of the choices fail, branch to node AFTERWARD, if\n+   non-zero, otherwise return.  PREVPOS is the position of the node that\n+   branched to this test.\n+\n+   When we merged all alternatives, we tried to set up a convenient order.\n+   Specifically, tests involving the same mode are all grouped together,\n+   followed by a group that does not contain a mode test.  Within each group\n+   of the same mode, we also group tests with the same code, followed by a\n+   group that does not test a code.\n+\n+   Occasionally, we cannot arbitarily reorder the tests so that multiple\n+   sequence of groups as described above are present.\n+\n+   We generate two nested switch statements, the outer statement for\n+   testing modes, and the inner switch for testing RTX codes.  It is\n+   not worth optimizing cases when only a small number of modes or \n+   codes is tested, since the compiler can do that when compiling the\n+   resulting function.   We do check for when every test is the same mode\n+   or code.  */\n \n-static char *\n-write_tree_1 (tree, prevpos, afterward, afterpos, initial, type)\n+void\n+write_tree_1 (tree, prevpos, afterward, type)\n      struct decision *tree;\n      char *prevpos;\n-     int afterward;\n-     char *afterpos;\n-     int initial;\n+     struct decision *afterward;\n      enum routine_type type;\n {\n   register struct decision *p, *p1;\n-  char *pos;\n-  register int depth;\n-  int ignmode;\n-  enum anon1 { NO_SWITCH, CODE_SWITCH, MODE_SWITCH } in_switch = NO_SWITCH;\n+  register int depth = tree ? strlen (tree->position) : 0;\n+  enum machine_mode switch_mode = VOIDmode;\n+  RTX_CODE switch_code = UNKNOWN;\n+  int uncond = 0;\n   char modemap[NUM_MACHINE_MODES];\n   char codemap[NUM_RTX_CODE];\n+  int indent = 2;\n+  int i;\n+\n+  /* One tricky area is what is the exact state when we branch to a\n+     node's label.  There are two cases where we branch: when looking at\n+     successors to a node, or when a set of tests fails.\n+\n+     In the former case, we are always branching to the first node in a\n+     decision list and we want all required tests to be performed.  We\n+     put the labels for such nodes in front of any switch or test statements.\n+     These branches are done without updating the position to that of the\n+     target node.\n+\n+     In the latter case, we are branching to a node that is not the first\n+     node in a decision list.  We have already checked that it is possible\n+     for both the node we originally tested at this level and the node we\n+     are branching to to be both match some pattern.  That means that they\n+     usually will be testing the same mode and code.  So it is normally safe\n+     for such labels to be inside switch statements, since the tests done\n+     by virtue of arriving at that label will usually already have been\n+     done.  The exception is a branch from a node that does not test a\n+     mode or code to one that does.  In such cases, we set the `retest_mode'\n+     or `retest_code' flags.  That will ensure that we start a new switch\n+     at that position and put the label before the switch. \n+\n+     The branches in the latter case must set the position to that of the\n+     target node.  */\n \n-  pos = prevpos;\n \n-  tree->label_needed = 1;\n+  printf (\"\\n\");\n+  if (tree && tree->subroutine_number == 0)\n+    {\n+      printf (\"  L%d:\\n\", tree->number);\n+      tree->label_needed = 0;\n+    }\n+\n+  if (tree)\n+    {\n+      change_state (prevpos, tree->position, 2);\n+      prevpos = tree->position;\n+    }\n+\n   for (p = tree; p; p = p->next)\n     {\n-      /* Find the next alternative to p\n-\t that might be true when p is true.\n-\t Test that one next if p's successors fail.\n-\t Note that when the `tests' field is nonzero\n-\t it is up to the specified test-function to compare machine modes\n-\t and some (such as general_operand) don't always do so.\n-\t But when inside a switch-on-modes we ignore this and\n-\t consider all modes mutually exclusive.  */\n-      for (p1 = p->next; p1; p1 = p1->next)\n-\tif (((p->code == UNKNOWN || p1->code == UNKNOWN || p->code == p1->code)\n-\t     && (p->mode == VOIDmode || p1->mode == VOIDmode\n-\t\t || p->mode == p1->mode\n-\t\t || (in_switch != MODE_SWITCH && (p->tests || p1->tests))))\n-\t    || strcmp (p1->position, p->position))\n-\t  break;\n+      enum machine_mode mode = p->enforce_mode ? p->mode : VOIDmode;\n+      int inner_indent;\n+\n+      if (p->success.first == 0 && p->insn_code_number < 0)\n+\tabort ();\n+\n+      /* Find the next alternative to p that might be true when p is true.\n+\t Test that one next if p's successors fail.  */\n+\n+      for (p1 = p->next; p1 && not_both_true (p, p1, 1); p1 = p1->next)\n+\t;\n       p->afterward = p1;\n-      if (p1) p1->label_needed = 1;\n \n-      if (in_switch == MODE_SWITCH\n-\t  && (p->mode == VOIDmode || (! p->enforce_mode && p->tests != 0)))\n+      if (p1)\n \t{\n-\t  in_switch = NO_SWITCH;\n-\t  printf (\"  }\\n\");\n+\t  if (mode == VOIDmode && p1->enforce_mode && p1->mode != VOIDmode)\n+\t    p1->retest_mode = 1;\n+\t  if (p->code == UNKNOWN && p1->code != UNKNOWN)\n+\t    p1->retest_code = 1;\n+\t  p1->label_needed = 1;\n \t}\n-      if (in_switch == CODE_SWITCH && p->code == UNKNOWN)\n+\n+      /* If we have a different code or mode than the last node and\n+\t are in a switch on codes, we must either end the switch or\n+\t go to another case.  We must also end the switch if this\n+\t node needs a label and to retest either the mode or code.  */\n+\n+      if (switch_code != UNKNOWN\n+\t  && (switch_code != p->code || switch_mode != mode\n+\t      || (p->label_needed && (p->retest_mode || p->retest_code))))\n \t{\n-\t  in_switch = NO_SWITCH;\n-\t  printf (\"  }\\n\");\n+\t  enum rtx_code code = p->code;\n+\n+\t  /* If P is testing a predicate that we know about and we haven't\n+\t     seen any of the codes that are valid for the predicate, we\n+\t     can write a series of \"case\" statement, one for each possible\n+\t     code.  Since we are already in a switch, these redundant tests\n+\t     are very cheap and will reduce the number of predicate called. */\n+\n+\t  if (p->pred >= 0)\n+\t    {\n+\t      for (i = 0; i < NUM_RTX_CODE && preds[p->pred].codes[i]; i++)\n+\t\tif (codemap[(int) preds[p->pred].codes[i]])\n+\t\t  break;\n+\n+\t      if (preds[p->pred].codes[i] == 0)\n+\t\tcode = MATCH_OPERAND;\n+\t    }\n+\n+\t  if (code == UNKNOWN || codemap[(int) code]\n+\t      || switch_mode != mode\n+\t      || (p->label_needed && (p->retest_mode || p->retest_code)))\n+\t    {\n+\t      printf (\"%s}\\n\", indents[indent - 2]);\n+\t      switch_code = UNKNOWN;\n+\t      indent -= 4;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (! uncond)\n+\t\tprintf (\"%sbreak;\\n\", indents[indent]);\n+\n+\t      if (code == MATCH_OPERAND)\n+\t\t{\n+\t\t  for (i = 0; i < NUM_RTX_CODE && preds[p->pred].codes[i]; i++)\n+\t\t    {\n+\t\t      printf (\"%scase \", indents[indent - 2]);\n+\t\t      print_code (preds[p->pred].codes[i]);\n+\t\t      printf (\":\\n\");\n+\t\t      codemap[(int) preds[p->pred].codes[i]] = 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  printf (\"%scase \", indents[indent - 2]);\n+\t\t  print_code (code);\n+\t\t  printf (\":\\n\");\n+\t\t  codemap[(int) p->code] = 1;\n+\t\t}\n+\n+\t      switch_code = code;\n+\t    }\n+\n+\t  uncond = 0;\n \t}\n \n-      if (p->label_needed)\n-\tprintf (\" L%d:\\n\", p->number);\n+      /* If we were previously in a switch on modes and now have a different\n+\t mode, end at least the case, and maybe end the switch if we are\n+\t not testing a mode or testing a mode whose case we already saw.  */\n \n-      if (p->success == 0 && p->insn_code_number < 0)\n+      if (switch_mode != VOIDmode\n+\t  && (switch_mode != mode || (p->label_needed && p->retest_mode)))\n+\t{\n+\t  if (mode == VOIDmode || modemap[(int) mode]\n+\t      || (p->label_needed && p->retest_mode))\n+\t    {\n+\t      printf (\"%s}\\n\", indents[indent - 2]);\n+\t      switch_mode = VOIDmode;\n+\t      indent -= 4;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (! uncond)\n+\t\tprintf (\"      break;\\n\");\n+\t      printf (\"    case %smode:\\n\", GET_MODE_NAME (mode));\n+\t      switch_mode = mode;\n+\t      modemap[(int) mode] = 1;\n+\t    }\n+\n+\t  uncond = 0;\n+\t}\n+\n+      /* If we are about to write dead code, something went wrong.  */\n+      if (! p->label_needed && uncond)\n \tabort ();\n \n-      change_state (pos, p->position);\n-      pos = p->position;\n-      depth = strlen (pos);\n+      /* If we need a label and we will want to retest the mode or code at\n+\t that label, write the label now.  We have already ensured that\n+\t things will be valid for the test.  */\n+\n+      if (p->label_needed && (p->retest_mode || p->retest_code))\n+\t{\n+\t  printf (\"%sL%d:\\n\", indents[indent - 2], p->number);\n+\t  p->label_needed = 0;\n+\t}\n+\n+      uncond = 0;\n \n-      ignmode = (p->ignmode || p->tests);\n+      /* If we are not in any switches, see if we can shortcut things\n+\t by checking for identical modes and codes.  */\n \n-      if (in_switch == NO_SWITCH)\n+      if (switch_mode == VOIDmode && switch_code == UNKNOWN)\n \t{\n \t  /* If p and its alternatives all want the same mode,\n \t     reject all others at once, first, then ignore the mode.  */\n-\t  if (!ignmode && p->mode != VOIDmode && p->next && same_modes (p, p->mode))\n+\n+\t  if (mode != VOIDmode && p->next && same_modes (p, mode))\n \t    {\n \t      printf (\"  if (GET_MODE (x%d) != %smode)\\n\",\n \t\t      depth, GET_MODE_NAME (p->mode));\n \t      if (afterward)\n \t\t{\n-\t\t  printf (\"    {\\n    \");\n-\t\t  change_state (pos, afterpos);\n-\t\t  printf (\"      goto L%d;\\n    }\\n\", afterward);\n+\t\t  printf (\"    {\\n\");\n+\t\t  change_state (p->position, afterward->position, 6);\n+\t\t  printf (\"      goto L%d;\\n    }\\n\", afterward->number);\n \t\t}\n \t      else\n \t\tprintf (\"    goto ret0;\\n\");\n \t      clear_modes (p);\n-\t      ignmode = 1;\n+\t      mode = VOIDmode;\n \t    }\n \n \t  /* If p and its alternatives all want the same code,\n \t     reject all others at once, first, then ignore the code.  */\n+\n \t  if (p->code != UNKNOWN && p->next && same_codes (p, p->code))\n \t    {\n \t      printf (\"  if (GET_CODE (x%d) != \", depth);\n \t      print_code (p->code);\n \t      printf (\")\\n\");\n \t      if (afterward)\n \t\t{\n-\t\t  printf (\"    {\");\n-\t\t  change_state (pos, afterpos);\n-\t\t  printf (\"    goto L%d; }\\n\", afterward);\n+\t\t  printf (\"    {\\n\");\n+\t\t  change_state (p->position, afterward->position, indent + 4);\n+\t\t  printf (\"    goto L%d;\\n    }\\n\", afterward->number);\n \t\t}\n \t      else\n \t\tprintf (\"    goto ret0;\\n\");\n \t      clear_codes (p);\n \t    }\n \t}\n \n-      /* If p and its alternatives all have different modes\n-\t and there are at least 4 of them, make a switch.  */\n-      if (in_switch == NO_SWITCH)\n-\t{\n-\t  register int i;\n-\t  int lose = 0;\n+      /* If we are not in a mode switch and we are testing for a specific\n+\t mode, start a mode switch unless we have just one node or the next\n+\t node is not testing a mode (we have already tested for the case of\n+\t more than one mode, but all of the same mode).  */\n \n+      if (switch_mode == VOIDmode && mode != VOIDmode && p->next != 0\n+\t  && p->next->enforce_mode && p->next->mode != VOIDmode)\n+\t{\n \t  mybzero (modemap, sizeof modemap);\n-\t  for (p1 = p, i = 0;\n-\t       (p1 && p1->mode != VOIDmode\n-\t\t&& (p1->tests == 0 || p1->enforce_mode));\n-\t       p1 = p1->next, i++)\n-\t    {\n-\t      if (! p->enforce_mode && modemap[(int) p1->mode])\n-\t\t{\n-\t\t  lose = 1;\n-\t\t  break;\n-\t\t}\n-\t      modemap[(int) p1->mode] = 1;\n-\t    }\n-\t  if (!lose && i >= 4)\n-\t    {\n-\t      in_switch = MODE_SWITCH;\n-\t      printf (\" switch (GET_MODE (x%d))\\n  {\\n\", depth);\n-\t    }\n+\t  printf (\"%sswitch (GET_MODE (x%d))\\n\", indents[indent], depth);\n+\t  printf (\"%s{\\n\", indents[indent + 2]);\n+\t  indent += 4;\n+\t  printf (\"%scase %smode:\\n\", indents[indent - 2],\n+\t\t  GET_MODE_NAME (mode));\n+\t  modemap[(int) mode] = 1;\n+\t  switch_mode = mode;\n \t}\n \n-      if (in_switch == NO_SWITCH)\n+      /* Similarly for testing codes.  */\n+\n+      if (switch_code == UNKNOWN && p->code != UNKNOWN && ! p->ignore_code\n+\t  && p->next != 0 && p->next->code != UNKNOWN)\n \t{\n-\t  register int i;\n \t  mybzero (codemap, sizeof codemap);\n-\t  for (p1 = p, i = 0; p1 && p1->code != UNKNOWN; p1 = p1->next, i++)\n-\t    {\n-\t      if (codemap[(int) p1->code])\n-\t\tbreak;\n-\t      codemap[(int) p1->code] = 1;\n-\t    }\n-\t  if ((p1 == 0 || p1->code == UNKNOWN) && i >= 4)\n-\t    {\n-\t      in_switch = CODE_SWITCH;\n-\t      printf (\" switch (GET_CODE (x%d))\\n  {\\n\", depth);\n-\t    }\n+\t  printf (\"%sswitch (GET_CODE (x%d))\\n\", indents[indent], depth);\n+\t  printf (\"%s{\\n\", indents[indent + 2]);\n+\t  indent += 4;\n+\t  printf (\"%scase \", indents[indent - 2]);\n+\t  print_code (p->code);\n+\t  printf (\":\\n\");\n+\t  codemap[(int) p->code] = 1;\n+\t  switch_code = p->code;\n \t}\n \n-      if (in_switch == MODE_SWITCH)\n-\t{\n-\t  if (modemap[(int) p->mode])\n-\t    {\n-\t      printf (\"  case %smode:\\n\", GET_MODE_NAME (p->mode));\n-\t      modemap[(int) p->mode] = 0;\n-\t    }\n-\t}\n-      if (in_switch == CODE_SWITCH)\n-\t{\n-\t  if (codemap[(int) p->code])\n-\t    {\n-\t      printf (\"  case \");\n-\t      print_code (p->code);\n-\t      printf (\":\\n\");\n-\t      codemap[(int) p->code] = 0;\n-\t    }\n-\t}\n+      /* Now that most mode and code tests have been done, we can write out\n+\t a label for an inner node, if we haven't already. */\n+      if (p->label_needed)\n+\tprintf (\"%sL%d:\\n\", indents[indent - 2], p->number);\n+\n+      inner_indent = indent;\n+\n+      /* The only way we can have to do a mode or code test here is if\n+\t this node needs such a test but is the only node to be tested.\n+\t In that case, we won't have started a switch.  Note that this is\n+\t the only way the switch and test modes can disagree.  */\n \n-      printf (\"  if (\");\n-      if (p->exact || (p->code != UNKNOWN && in_switch != CODE_SWITCH))\n+      if ((mode != switch_mode && ! p->ignore_mode)\n+\t  || (p->code != switch_code && p->code != UNKNOWN && ! p->ignore_code)\n+\t  || p->test_elt_zero_int || p->test_elt_one_int || p->veclen\n+\t  || p->dupno >= 0 || p->tests || p->num_clobbers_to_add)\n \t{\n-\t  if (p->exact)\n-\t    printf (\"x%d == %s\", depth, p->exact);\n-\t  else\n+\t  printf (\"%sif (\", indents[indent]);\n+\n+\t  if (mode != switch_mode && ! p->ignore_mode)\n+\t    printf (\"GET_MODE (x%d) == %smode && \",\n+\t\t    depth, GET_MODE_NAME (mode));\n+\t  if (p->code != switch_code && p->code != UNKNOWN && ! p->ignore_code)\n \t    {\n \t      printf (\"GET_CODE (x%d) == \", depth);\n \t      print_code (p->code);\n+\t      printf (\" && \");\n \t    }\n-\t  printf (\" && \");\n+\n+\t  if (p->test_elt_zero_int)\n+\t    printf (\"XINT (x%d, 0) == %d && \", depth, p->elt_zero_int);\n+\t  if (p->test_elt_one_int)\n+\t    printf (\"XINT (x%d, 1) == %d && \", depth, p->elt_one_int);\n+\t  if (p->veclen)\n+\t    printf (\"XVECLEN (x%d, 0) == %d && \", depth, p->veclen);\n+\t  if (p->dupno >= 0)\n+\t    printf (\"rtx_equal_p (x%d, ro[%d]) && \", depth, p->dupno);\n+\t  if (p->num_clobbers_to_add)\n+\t    printf (\"pnum_clobbers != 0 && \");\n+\t  if (p->tests)\n+\t    printf (\"%s (x%d, %smode)\", p->tests, depth,\n+\t\t    GET_MODE_NAME (p->mode));\n+\t  else\n+\t    printf (\"1\");\n+\n+\t  printf (\")\\n\");\n+\t  inner_indent += 2;\n \t}\n-      if (p->mode != VOIDmode && !ignmode && in_switch != MODE_SWITCH)\n-\tprintf (\"GET_MODE (x%d) == %smode && \",\n-\t\tdepth, GET_MODE_NAME (p->mode));\n-      if (p->test_elt_zero_int)\n-\tprintf (\"XINT (x%d, 0) == %d && \", depth, p->elt_zero_int);\n-      if (p->veclen)\n-\tprintf (\"XVECLEN (x%d, 0) == %d && \", depth, p->veclen);\n-      if (p->test_elt_one_int)\n-\tprintf (\"XINT (x%d, 1) == %d && \", depth, p->elt_one_int);\n-      if (p->dupno >= 0)\n-\tprintf (\"rtx_equal_p (x%d, ro[%d]) && \", depth, p->dupno);\n-      if (p->tests)\n-\tprintf (\"%s (x%d, %smode)\", p->tests, depth,\n-\t\tGET_MODE_NAME (p->mode));\n       else\n-\tprintf (\"1\");\n+\tuncond = 1;\n \n       if (p->opno >= 0)\n-\tprintf (\")\\n    { ro[%d] = x%d; \",\n-\t\tp->opno, depth);\n-      else\n-\tprintf (\")\\n    \");\n+\t{\n+\t  printf (\"%s{\\n%sro[%d] = x%d;\\n\",\n+\t\t  indents[inner_indent], indents[inner_indent + 2],\n+\t\t  p->opno, depth);\n+\t  inner_indent += 2;\n+\t}\n \n       if (p->c_test)\n-\tprintf (\"if (%s) \", p->c_test);\n+\t{\n+\t  printf (\"%sif (%s)\\n\", indents[inner_indent], p->c_test);\n+\t  inner_indent += 2;\n+\t  uncond = 0;\n+\t}\n \n       if (p->insn_code_number >= 0)\n \t{\n \t  if (type == SPLIT)\n-\t    printf (\"return gen_split_%d (operands);\", p->insn_code_number);\n+\t    printf (\"%sreturn gen_split_%d (operands);\\n\",\n+\t\t    indents[inner_indent], p->insn_code_number);\n \t  else\n \t    {\n \t      if (p->num_clobbers_to_add)\n \t\t{\n-\t\t  printf (\"\\n      {\\n\");\n-\t\t  printf (\"\\tif (pnum_clobbers == 0) goto ret0; \");\n-\t\t  printf (\"*pnum_clobbers = %d; \", p->num_clobbers_to_add);\n-\t\t  printf (\"return %d;\\n      }\", p->insn_code_number);\n+\t\t  if (p->opno < 0 || p->c_test)\n+\t\t    {\n+\t\t      printf (\"%s{\\n\", indents[inner_indent]);\n+\t\t      inner_indent += 2;\n+\t\t    }\n+\n+\t\t  printf (\"%s*pnum_clobbers = %d;\\n\",\n+\t\t\t  indents[inner_indent], p->num_clobbers_to_add);\n+\t\t  printf (\"%sreturn %d;\\n\",\n+\t\t\t  indents[inner_indent], p->insn_code_number);\n+\n+\t\t  if (p->opno < 0 || p->c_test)\n+\t\t    {\n+\t\t      inner_indent -= 2;\n+\t\t      printf (\"%s}\\n\", indents[inner_indent]);\n+\t\t    }\n \t\t}\n \t      else\n-\t\tprintf (\"return %d;\", p->insn_code_number);\n+\t\tprintf (\"%sreturn %d;\\n\",\n+\t\t\tindents[inner_indent], p->insn_code_number);\n \t    }\n \t}\n       else\n-\tprintf (\"goto L%d;\", p->success->number);\n+\tprintf (\"%sgoto L%d;\\n\", indents[inner_indent],\n+\t\tp->success.first->number);\n \n       if (p->opno >= 0)\n-\tprintf (\" }\\n\");\n-      else\n-\tprintf (\"\\n\");\n+\tprintf (\"%s}\\n\", indents[inner_indent - 2]);\n+    }\n \n-      /* Now, if inside a switch, branch to next switch member\n-\t that might also need to be tested if this one fails.  */\n+  /* We have now tested all alternatives.  End any switches we have open\n+     and branch to the alternative node.  */\n \n-      if (in_switch == CODE_SWITCH)\n-\t{\n-\t  /* Find the next alternative to p\n-\t     that might be applicable if p was applicable.  */\n-\t  for (p1 = p->next; p1; p1 = p1->next)\n-\t    if (p1->code == UNKNOWN || p->code == p1->code)\n-\t      break;\n-\t  if (p1 == 0 || p1->code == UNKNOWN)\n-\t    printf (\"  break;\\n\");\n-\t  else if (p1 != p->next)\n-\t    {\n-\t      printf (\" goto L%d;\\n\", p1->number);\n-\t      p1->label_needed = 1;\n-\t    }\n-\t}\n+  if (switch_code != UNKNOWN)\n+    {\n+      printf (\"%s}\\n\", indents[indent - 2]);\n+      indent -= 4;\n+    }\n \n-      if (in_switch == MODE_SWITCH)\n-\t{\n-\t  /* Find the next alternative to p\n-\t     that might be applicable if p was applicable.  */\n-\t  for (p1 = p->next; p1; p1 = p1->next)\n-\t    if (p1->mode == VOIDmode || p->mode == p1->mode)\n-\t      break;\n-\t  if (p1 == 0 || p1->mode == VOIDmode)\n-\t    printf (\"  break;\\n\");\n-\t  else if (p1 != p->next)\n-\t    {\n-\t      printf (\" goto L%d;\\n\", p1->number);\n-\t      p1->label_needed = 1;\n-\t    }\n-\t}\n+  if (switch_mode != VOIDmode)\n+    {\n+      printf (\"%s}\\n\", indents[indent - 2]);\n+      indent -= 4;\n     }\n \n-  if (in_switch != NO_SWITCH)\n-    printf (\"  }\\n\");\n+  if (indent != 2)\n+    abort ();\n \n   if (afterward)\n     {\n-      change_state (pos, afterpos);\n-      printf (\"  goto L%d;\\n\", afterward);\n+      change_state (prevpos, afterward->position, 2);\n+      printf (\"  goto L%d;\\n\", afterward->number);\n     }\n   else\n     printf (\"  goto ret0;\\n\");\n-  return pos;\n-}\n-\n-static void\n-write_tree (tree, prevpos, afterward, afterpos, initial, type)\n-     struct decision *tree;\n-     char *prevpos;\n-     int afterward;\n-     char *afterpos;\n-     int initial;\n-     enum routine_type type;\n-{\n-  register struct decision *p;\n-  char *pos = prevpos;\n-  char *name_prefix = (type == SPLIT ? \"split\" : \"recog\");\n-  char *call_suffix = (type == SPLIT ? \"\" : \", pnum_clobbers\");\n-\n-  if (tree->subroutine_number > 0 && ! initial)\n-    {\n-      printf (\" L%d:\\n\", tree->number);\n-\n-      if (afterward)\n-\t{\n-\t  printf (\"  tem = %s_%d (x0, insn%s);\\n\",\n-\t\t  name_prefix, tree->subroutine_number, call_suffix);\n-\t  printf (\"  if (tem >= 0) return tem;\\n\");\n-\t  change_state (pos, afterpos);\n-\t  printf (\"  goto L%d;\\n\", afterward);\n-\t}\n-      else\n-\tprintf (\"  return %s_%d (x0, insn%s);\\n\",\n-\t\tname_prefix, tree->subroutine_number, call_suffix);\n-      return;\n-    }\n-\n-  pos = write_tree_1 (tree, prevpos, afterward, afterpos, initial, type);\n-\n-  for (p = tree; p; p = p->next)\n-    if (p->success)\n-      {\n-\tpos = p->position;\n-\twrite_tree (p->success, pos,\n-\t\t    p->afterward ? p->afterward->number : afterward,\n-\t\t    p->afterward ? pos : afterpos, 0, type);\n-      }\n }\n \n static void\n@@ -1077,7 +1408,7 @@ clear_codes (p)\n      register struct decision *p;\n {\n   for (; p; p = p->next)\n-    p->code = UNKNOWN;\n+    p->ignore_code = 1;\n }\n \n static int\n@@ -1097,13 +1428,66 @@ clear_modes (p)\n      register struct decision *p;\n {\n   for (; p; p = p->next)\n-    p->ignmode = 1;\n+    p->enforce_mode = 0;\n }\n \f\n+/* Write out the decision tree starting at TREE for a subroutine of type TYPE.\n+\n+   PREVPOS is the position at the node that branched to this node.\n+\n+   INITIAL is nonzero if this is the first node we are writing in a subroutine.\n+\n+   If all nodes are false, branch to the node AFTERWARD.  */\n+\n+static void\n+write_tree (tree, prevpos, afterward, initial, type)\n+     struct decision *tree;\n+     char *prevpos;\n+     struct decision *afterward;\n+     int initial;\n+     enum routine_type type;\n+{\n+  register struct decision *p;\n+  char *name_prefix = (type == SPLIT ? \"split\" : \"recog\");\n+  char *call_suffix = (type == SPLIT ? \"\" : \", pnum_clobbers\");\n+\n+  if (! initial && tree->subroutine_number > 0)\n+    {\n+      printf (\" L%d:\\n\", tree->number);\n+\n+      if (afterward)\n+\t{\n+\t  printf (\"  tem = %s_%d (x0, insn%s);\\n\",\n+\t\t  name_prefix, tree->subroutine_number, call_suffix);\n+\t  printf (\"  if (tem >= 0) return tem;\\n\");\n+\t  change_state (tree->position, afterward->position, 2);\n+\t  printf (\"  goto L%d;\\n\", afterward->number);\n+\t}\n+      else\n+\tprintf (\"  return %s_%d (x0, insn%s);\\n\",\n+\t\tname_prefix, tree->subroutine_number, call_suffix);\n+      return;\n+    }\n+\n+  write_tree_1 (tree, prevpos, afterward, type);\n+\n+  for (p = tree; p; p = p->next)\n+    if (p->success.first)\n+      write_tree (p->success.first, p->position,\n+\t\t  p->afterward ? p->afterward : afterward, 0, type);\n+}\n+\n+\f\n+/* Assuming that the state of argument is denoted by OLDPOS, take whatever\n+   actions are necessary to move to NEWPOS.\n+\n+   INDENT says how many blanks to place at the front of lines.  */\n+\n static void\n-change_state (oldpos, newpos)\n+change_state (oldpos, newpos, indent)\n      char *oldpos;\n      char *newpos;\n+     int indent;\n {\n   int odepth = strlen (oldpos);\n   int depth = odepth;\n@@ -1119,11 +1503,11 @@ change_state (oldpos, newpos)\n   while (depth < ndepth)\n     {\n       if (newpos[depth] >= 'a' && newpos[depth] <= 'z')\n-\tprintf (\"  x%d = XVECEXP (x%d, 0, %d);\\n\",\n-\t\tdepth + 1, depth, newpos[depth] - 'a');\n+\tprintf (\"%sx%d = XVECEXP (x%d, 0, %d);\\n\",\n+\t\tindents[indent], depth + 1, depth, newpos[depth] - 'a');\n       else\n-\tprintf (\"  x%d = XEXP (x%d, %c);\\n\",\n-\t\tdepth + 1, depth, newpos[depth]);\n+\tprintf (\"%sx%d = XEXP (x%d, %c);\\n\",\n+\t\tindents[indent], depth + 1, depth, newpos[depth]);\n       ++depth;\n     }\n }\n@@ -1152,6 +1536,15 @@ mybzero (b, length)\n     *b++ = 0;\n }\n \n+static void\n+mybcopy (in, out, length)\n+     register char *in, *out;\n+     register unsigned length;\n+{\n+  while (length-- > 0)\n+    *out++ = *in++;\n+}\n+\n static char *\n concat (s1, s2)\n      char *s1, *s2;\n@@ -1219,13 +1612,14 @@ main (argc, argv)\n      char **argv;\n {\n   rtx desc;\n-  struct decision *tree = 0;\n-  struct decision *split_tree = 0;\n+  struct decision_head recog_tree;\n+  struct decision_head split_tree;\n   FILE *infile;\n   extern rtx read_rtx ();\n   register int c;\n \n   obstack_init (rtl_obstack);\n+  recog_tree.first = recog_tree.last = split_tree.first = split_tree.last = 0;\n \n   if (argc <= 1)\n     fatal (\"No input file name.\");\n@@ -1264,9 +1658,11 @@ from the machine description file `md'.  */\\n\\n\");\n \n       desc = read_rtx (infile);\n       if (GET_CODE (desc) == DEFINE_INSN)\n-\ttree = merge_trees (tree, make_insn_sequence (desc));\n+\trecog_tree = merge_trees (recog_tree,\n+\t\t\t\t  make_insn_sequence (desc, RECOG));\n       else if (GET_CODE (desc) == DEFINE_SPLIT)\n-\tsplit_tree = merge_trees (split_tree, make_split_sequence (desc));\n+\tsplit_tree = merge_trees (split_tree,\n+\t\t\t\t  make_insn_sequence (desc, SPLIT));\n       if (GET_CODE (desc) == DEFINE_PEEPHOLE\n \t  || GET_CODE (desc) == DEFINE_EXPAND)\n \tnext_insn_code++;\n@@ -1294,7 +1690,7 @@ from the machine description file `md'.  */\\n\\n\");\n    PARALLEL of the appropriate size, copy the initial entries, and call\\n\\\n    add_clobbers (found in insn-emit.c) to fill in the CLOBBERs.\");\n \n-  if (split_tree)\n+  if (split_tree.first)\n     printf (\"\\n\\n   The function split_insns returns 0 if the rtl could not\\n\\\n    be split or the split rtl in a SEQUENCE if it can be.\");\n \n@@ -1307,30 +1703,12 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#define operands recog_operand\\n\\n\");\n \n   next_subroutine_number = 0;\n-  break_out_subroutines (tree, RECOG);\n-\n-  printf (\"int\\nrecog (x0, insn, pnum_clobbers)\\n\");\n-  printf (\"     register rtx x0;\\n     rtx insn;\\n\");\n-  printf (\"     int *pnum_clobbers;\\n{\\n\");\n-  printf (\"  register rtx *ro = &recog_operand[0];\\n\");\n-  printf (\"  register rtx x1, x2, x3, x4, x5;\\n  rtx x6, x7, x8, x9, x10, x11;\\n\");\n-  printf (\"  int tem;\\n\");\n-\n-  if (tree)\n-    write_tree (tree, \"\", 0, \"\", 1, RECOG);\n-  printf (\" ret0: return -1;\\n}\\n\");\n+  break_out_subroutines (recog_tree, RECOG, 1);\n+  write_subroutine (recog_tree.first, RECOG);\n \n   next_subroutine_number = 0;\n-  break_out_subroutines (split_tree, SPLIT);\n-\n-  printf (\"rtx\\nsplit_insns (x0, insn)\\n     register rtx x0;\\n     rtx insn;\\n{\\n\");\n-  printf (\"  register rtx *ro = &recog_operand[0];\\n\");\n-  printf (\"  register rtx x1, x2, x3, x4, x5;\\n  rtx x6, x7, x8, x9, x10, x11;\\n\");\n-  printf (\"  rtx tem;\\n\");\n-\n-  if (split_tree)\n-    write_tree (split_tree, \"\", 0, \"\", 1, SPLIT);\n-  printf (\" ret0: return 0;\\n}\\n\");\n+  break_out_subroutines (split_tree, SPLIT, 1);\n+  write_subroutine (split_tree.first, SPLIT);\n \n   fflush (stdout);\n   exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);"}]}