{"sha": "0cd355fe9da1827a55ea871238a988adcadf6f93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNkMzU1ZmU5ZGExODI3YTU1ZWE4NzEyMzhhOTg4YWRjYWRmNmY5Mw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@cygnus.com", "date": "1998-04-20T11:54:40Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1998-04-20T11:54:40Z"}, "message": "For movsf/movdf splits, let movsi define_split handle subword moves\n\nFrom-SVN: r19340", "tree": {"sha": "411414c46ce5d5fa8adb71537bd9cb786d78fbd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/411414c46ce5d5fa8adb71537bd9cb786d78fbd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cd355fe9da1827a55ea871238a988adcadf6f93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cd355fe9da1827a55ea871238a988adcadf6f93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cd355fe9da1827a55ea871238a988adcadf6f93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cd355fe9da1827a55ea871238a988adcadf6f93/comments", "author": null, "committer": null, "parents": [{"sha": "a07987797e2c65810e5cde19b964cca1897e3288", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a07987797e2c65810e5cde19b964cca1897e3288", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a07987797e2c65810e5cde19b964cca1897e3288"}], "stats": {"total": 213, "additions": 13, "deletions": 200}, "files": [{"sha": "8466debe6617e0dcd0bd0849c46d596c204c0907", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd355fe9da1827a55ea871238a988adcadf6f93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd355fe9da1827a55ea871238a988adcadf6f93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0cd355fe9da1827a55ea871238a988adcadf6f93", "patch": "@@ -1,3 +1,10 @@\n+Mon Apr 20 14:48:29 1998  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* rs6000.md (mov{sf,df} define_splits): When splitting a move of\n+\ta constant to an integer register, don't split the insns that do\n+\tthe simple AND and OR operations, rather just split each word, and\n+\tlet the normal movsi define split handle it further.\n+\n Mon Apr 20 18:19:40 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* sh.c (find_barrier): Fix bug in ADDR_DIFF_VEC handling."}, {"sha": "b1714b72c36d858947b30d9d1d2e93a857d93667", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 6, "deletions": 200, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd355fe9da1827a55ea871238a988adcadf6f93/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd355fe9da1827a55ea871238a988adcadf6f93/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=0cd355fe9da1827a55ea871238a988adcadf6f93", "patch": "@@ -1,5 +1,5 @@\n ;; Machine description for IBM RISC System 6000 (POWER) for GNU C compiler\n-;; Copyright (C) 1990, 91-96, 1997 Free Software Foundation, Inc.\n+;; Copyright (C) 1990, 91-96, 1997, 1998 Free Software Foundation, Inc.\n ;; Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n ;; This file is part of GNU CC.\n@@ -5567,7 +5567,7 @@\n (define_split\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:SF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], SFmode) <= 1\n+  \"TARGET_32BIT && reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG\n \t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n@@ -5585,29 +5585,6 @@\n   operands[3] = GEN_INT(l);\n }\")\n \n-(define_split\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:SF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], SFmode) == 2\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 4)))]\n-  \"\n-{\n-  long l;\n-  REAL_VALUE_TYPE rv;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-  REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n-\n-  operands[2] = operand_subword (operands[0], 0, 0, SFmode);\n-  operands[3] = GEN_INT(l & 0xffff0000);\n-  operands[4] = GEN_INT(l & 0x0000ffff);\n-}\")\n-\n (define_insn \"*movsf_hardfloat\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,m,!r,!r\")\n \t(match_operand:SF 1 \"input_operand\" \"f,m,f,G,Fn\"))]\n@@ -5679,7 +5656,7 @@\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) <= 1\n+  \"TARGET_32BIT && reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG\n \t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n@@ -5694,32 +5671,10 @@\n   operands[4] = (INTVAL (operands[1]) & 0x80000000) ? constm1_rtx : const0_rtx;\n }\")\n \n-(define_split\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DF 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) >= 2\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n-  [(set (match_dup 3) (match_dup 5))\n-   (set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 6)))]\n-  \"\n-{\n-  HOST_WIDE_INT value = INTVAL (operands[1]);\n-  int endian = (WORDS_BIG_ENDIAN == 0);\n-  operands[2] = operand_subword (operands[0], endian, 0, DFmode);\n-  operands[3] = operand_subword (operands[0], 1 - endian, 0, DFmode);\n-  operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n-  operands[5] = GEN_INT (value & 0xffff0000);\n-  operands[6] = GEN_INT (value & 0x0000ffff);\n-}\")\n-\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) <= 2\n+  \"TARGET_32BIT && reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG\n \t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n@@ -5741,84 +5696,6 @@\n   operands[5] = GEN_INT (l[1 - endian]);\n }\")\n \n-(define_split\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) == 3\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))\n-   (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 6)))]\n-  \"\n-{\n-  HOST_WIDE_INT high;\n-  HOST_WIDE_INT low;\n-  int endian = (WORDS_BIG_ENDIAN == 0);\n-  long l[2];\n-  REAL_VALUE_TYPE rv;\n-  rtx high_reg = operand_subword (operands[0], endian, 0, DFmode);\n-  rtx low_reg  = operand_subword (operands[0], 1 - endian, 0, DFmode);\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-  REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n-  high = l[endian];\n-  low  = l[1 - endian];\n-\n-  if (((unsigned HOST_WIDE_INT) (low + 0x8000) < 0x10000)\n-      || (low & 0xffff) == 0)\n-    {\n-      operands[2] = high_reg;\n-      operands[3] = low_reg;\n-      operands[4] = GEN_INT (high & 0xffff0000);\n-      operands[5] = GEN_INT (low);\n-      operands[6] = GEN_INT (high & 0x0000ffff);\n-    }\n-  else\n-    {\n-      operands[2] = low_reg;\n-      operands[3] = high_reg;\n-      operands[4] = GEN_INT (low & 0xffff0000);\n-      operands[5] = GEN_INT (high);\n-      operands[6] = GEN_INT (low & 0x0000ffff);\n-    }\n-}\")\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) >= 4\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))\n-   (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 6)))\n-   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 7)))]\n-  \"\n-{\n-  HOST_WIDE_INT high;\n-  HOST_WIDE_INT low;\n-  long l[2];\n-  REAL_VALUE_TYPE rv;\n-  int endian = (WORDS_BIG_ENDIAN == 0);\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-  REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n-  high = l[endian];\n-  low  = l[1 - endian];\n-\n-  operands[2] = operand_subword (operands[0], endian, 0, DFmode);\n-  operands[3] = operand_subword (operands[0], 1 - endian, 0, DFmode);\n-  operands[4] = GEN_INT (high & 0xffff0000);\n-  operands[5] = GEN_INT (low  & 0xffff0000);\n-  operands[6] = GEN_INT (high & 0x0000ffff);\n-  operands[7] = GEN_INT (low  & 0x0000ffff);\n-}\")\n-\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"easy_fp_constant\" \"\"))]\n@@ -6078,7 +5955,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DImode) <= 1\"\n+  \"TARGET_32BIT && reload_completed\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 1))]\n   \"\n@@ -6088,27 +5965,10 @@\n   operands[4] = (INTVAL (operands[1]) & 0x80000000) ? constm1_rtx : const0_rtx;\n }\")\n \n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DImode) >= 2\"\n-  [(set (match_dup 3) (match_dup 5))\n-   (set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 6)))]\n-  \"\n-{\n-  HOST_WIDE_INT value = INTVAL (operands[1]);\n-  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n-  operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n-  operands[5] = GEN_INT (value & 0xffff0000);\n-  operands[6] = GEN_INT (value & 0x0000ffff);\n-}\")\n-\n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DImode) <= 2\"\n+  \"TARGET_32BIT && reload_completed\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n   \"\n@@ -6119,60 +5979,6 @@\n   operands[5] = GEN_INT (CONST_DOUBLE_LOW  (operands[1]));\n }\")\n \n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DImode) == 3\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))\n-   (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 6)))]\n-  \"\n-{\n-  HOST_WIDE_INT high = CONST_DOUBLE_HIGH (operands[1]);\n-  HOST_WIDE_INT low  = CONST_DOUBLE_LOW  (operands[1]);\n-  rtx high_reg = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  rtx low_reg  = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n-\n-  if (((unsigned HOST_WIDE_INT) (low + 0x8000) < 0x10000)\n-      || (low & 0xffff) == 0)\n-    {\n-      operands[2] = high_reg;\n-      operands[3] = low_reg;\n-      operands[4] = GEN_INT (high & 0xffff0000);\n-      operands[5] = GEN_INT (low);\n-      operands[6] = GEN_INT (high & 0x0000ffff);\n-    }\n-  else\n-    {\n-      operands[2] = low_reg;\n-      operands[3] = high_reg;\n-      operands[4] = GEN_INT (low & 0xffff0000);\n-      operands[5] = GEN_INT (high);\n-      operands[6] = GEN_INT (low & 0x0000ffff);\n-    }\n-}\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DImode) >= 4\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))\n-   (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 6)))\n-   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 7)))]\n-  \"\n-{\n-  HOST_WIDE_INT high = CONST_DOUBLE_HIGH (operands[1]);\n-  HOST_WIDE_INT low  = CONST_DOUBLE_LOW  (operands[1]);\n-\n-  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n-  operands[4] = GEN_INT (high & 0xffff0000);\n-  operands[5] = GEN_INT (low  & 0xffff0000);\n-  operands[6] = GEN_INT (high & 0x0000ffff);\n-  operands[7] = GEN_INT (low  & 0x0000ffff);\n-}\")\n-\n (define_insn \"*movdi_64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,r,f,f,m,r,*h,*h\")\n \t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,J,nF,R,f,m,f,*h,r,0\"))]"}]}