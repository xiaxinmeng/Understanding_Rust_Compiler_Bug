{"sha": "454e0249676efa5688841900b0447fe690fb8742", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU0ZTAyNDk2NzZlZmE1Njg4ODQxOTAwYjA0NDdmZTY5MGZiODc0Mg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-05-12T16:30:52Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-05-12T16:30:52Z"}, "message": "Initial revision\n\nFrom-SVN: r9645", "tree": {"sha": "c68c836b80705afa52d99765f19cd6791efca538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c68c836b80705afa52d99765f19cd6791efca538"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/454e0249676efa5688841900b0447fe690fb8742", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/454e0249676efa5688841900b0447fe690fb8742", "html_url": "https://github.com/Rust-GCC/gccrs/commit/454e0249676efa5688841900b0447fe690fb8742", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/454e0249676efa5688841900b0447fe690fb8742/comments", "author": null, "committer": null, "parents": [{"sha": "b6e2a70e206ee03378536ae03618d61fa11c1756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e2a70e206ee03378536ae03618d61fa11c1756", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6e2a70e206ee03378536ae03618d61fa11c1756"}], "stats": {"total": 1597, "additions": 1597, "deletions": 0}, "files": [{"sha": "c23683ec443a4d04efd0c822edceaa94e66570a6", "filename": "gcc/config/arm/lib1funcs.asm", "status": "added", "additions": 1597, "deletions": 0, "changes": 1597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/454e0249676efa5688841900b0447fe690fb8742/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/454e0249676efa5688841900b0447fe690fb8742/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=454e0249676efa5688841900b0447fe690fb8742", "patch": "@@ -0,0 +1,1597 @@\n+@ libgcc1 routines for ARM cpu.\n+@ Division and remainder, from Appendix E of the Sparc Version 8\n+@ Architecture Manual, with fixes from Gordon Irlam.\n+@ Rewritten for the ARM by Richard Earnshaw (rwe@pegasus.esprit.ec.org)\n+\n+/* Copyright (C) 1995 Free Software Foundation, Inc.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/*\n+ * Input: dividend and divisor in r0 and r1 respectively.\n+ *\n+ * m4 parameters:\n+ *  NAME\tname of function to generate\n+ *  OP\t\tOP=div => r0 / r1; OP=mod => r0 % r1\n+ *  S\t\tS=true => signed; S=false => unsigned\n+ *\n+ * Algorithm parameters:\n+ *  N\t\thow many bits per iteration we try to get (4)\n+ *  WORDSIZE\ttotal number of bits (32)\n+ *\n+ * Derived constants:\n+ *  TOPBITS\tnumber of bits in the top `decade' of a number\n+ *\n+ * Important variables:\n+ *  Q\t\tthe partial quotient under development (initially 0)\n+ *  R\t\tthe remainder so far, initially the dividend\n+ *  ITER\tnumber of main division loop iterations required;\n+ *\t\tequal to ceil(log2(quotient) / N).  Note that this\n+ *\t\tis the log base (2^N) of the quotient.\n+ *  V\t\tthe current comparand, initially divisor*2^(ITER*N-1)\n+ *\n+ * Cost:\n+ *  Current estimate for non-large dividend is\n+ *\tceil(log2(quotient) / N) * (10 + 7N/2) + C\n+ *  A large dividend is one greater than 2^(31-TOPBITS) and takes a\n+ *  different path, as the upper bits of the quotient must be developed\n+ *  one bit at a time.\n+ */\n+\n+/*\n+define(N, `4')dnl\n+define(WORDSIZE, `32')dnl\n+define(TOPBITS, eval(WORDSIZE - N*((WORDSIZE-1)/N)))dnl\n+dnl\n+define(dividend, `r0')dnl\n+define(divisor, `r1')dnl\n+define(Q, `r2')dnl\n+define(R, `r3')dnl\n+define(ITER, `ip')dnl\n+define(V, `lr')dnl\n+dnl\n+dnl m4 reminder: ifelse(a,b,c,d) => if a is b, then c, else d\n+define(T, `r4')dnl\n+define(SC, `r5')dnl\n+ifelse(S, `true', `define(SIGN, `r6')')dnl\n+define(REGLIST, `ifelse(S, `true', `{r4, r5, r6,', `{r4, r5,')')dnl\n+define(ret, `ldmia\tsp!, REGLIST pc}')dnl\n+dnl\n+dnl This is the recursive definition for developing quotient digits.\n+dnl\n+dnl Parameters:\n+dnl  $1\tthe current depth, 1 <= $1 <= N\n+dnl  $2\tthe current accumulation of quotient bits\n+dnl  N\tmax depth\n+dnl\n+dnl We add a new bit to $2 and either recurse or insert the bits in\n+dnl the quotient.  R, Q, and V are inputs and outputs as defined above;\n+dnl the condition codes are expected to reflect the input R, and are\n+dnl modified to reflect the output R.\n+dnl\n+define(DEVELOP_QUOTIENT_BITS,\n+`\t@ depth $1, accumulated bits $2\n+\tmov\tV, V, lsr #1\n+\tblt\tL.$1.eval(2^N+$2+999)\n+\t@ remainder is positive\n+\tsubs\tR, R, V\n+\tifelse($1, N,\n+\t`\tifelse(eval(2*$2+1<0), `0',\n+\t\t`add\tQ, Q, `#'eval($2*2+1)',\n+\t\t`sub\tQ, Q, `#'eval(-($2*2+1))')\n+\n+\t\tb\t9f\n+\t', `\tDEVELOP_QUOTIENT_BITS(incr($1), `eval(2*$2+1)')')\n+L.$1.eval(2^N+$2+999):\n+\t@ remainder is negative\n+\tadds\tR, R, V\n+\tifelse($1, N,\n+\t`\tifelse(eval(2*$2-1<0), `0',\n+\t\t`add\tQ, Q, `#'eval($2*2-1)',\n+\t\t`sub\tQ, Q, `#'eval(-($2*2-1))')\n+\t\tb\t9f\n+\n+\t', `\tDEVELOP_QUOTIENT_BITS(incr($1), `eval(2*$2-1)')')\n+\tifelse($1, 1, `9:')')dnl\n+\n+#include \"trap.h\"\n+\n+ip\t.req\tr12\n+sp\t.req\tr13\n+lr\t.req\tr14\n+pc\t.req\tr15\n+.text\n+\t.globl NAME\n+\t.align 0\n+NAME:\n+\tstmdb\tsp!, REGLIST lr}\n+ifelse(S, `true',\n+`\t@ compute sign of result; if neither is negative, no problem\n+\teor\tSIGN, divisor, dividend\t@ compute sign\n+\tcmp\tdivisor, #0\n+\trsbmi\tdivisor, divisor, #0\n+\tbeq\tLdiv_zero\n+\tmov\tV, divisor\n+\tmovs\tR, dividend\n+\trsbmi\tR, R, #0\t@ make dividend nonnegative\n+',\n+`\t@ Ready to divide.  Compute size of quotient; scale comparand.\n+\tmovs\tV, divisor\n+\tmov\tR, dividend\n+\tbeq\tLdiv_zero\n+')\n+\n+\tcmp\tR, V\t\t\t@ if divisor exceeds dividend, done\n+\tmov\tQ, #0\n+\tbcc\tLgot_result\t\t@ (and algorithm fails otherwise)\n+\tmov\tT, `#'(1 << (WORDSIZE - TOPBITS - 1))\n+\tcmp\tR, T\n+\tmov\tITER, #0\n+\tbcc\tLnot_really_big\n+\n+\t@ `Here the dividend is >= 2^(31-N) or so.  We must be careful here,\n+\t@ as our usual N-at-a-shot divide step will cause overflow and havoc.\n+\t@ The number of bits in the result here is N*ITER+SC, where SC <= N.\n+\t@ Compute ITER in an unorthodox manner: know we need to shift V into\n+\t@ the top decade: so do not even bother to compare to R.'\n+\t\tmov\tSC, #1\n+\t1:\n+\t\tcmp\tV, T\n+\t\tbcs\t3f\n+\t\tmov\tV, V, lsl `#'N\n+\t\tadd\tITER, ITER, #1\n+\t\tb\t1b\n+\n+\t@ Now compute SC.\n+\t2:\tadds\tV, V, V\n+\t\tadd\tSC, SC, #1\n+\t\tbcc\tLnot_too_big\n+\n+\t\t@ We get here if the divisor overflowed while shifting.\n+\t\t@ This means that R has the high-order bit set.\n+\t\t@ Restore V and subtract from R.\n+\t\tmov\tT, T, lsl `#'TOPBITS\n+\t\tmov\tV, V, lsr #1\n+\t\tadd\tV, T, V\n+\t\tsub\tSC, SC, #1\n+\t\tb\tLdo_single_div\n+\n+\tLnot_too_big:\n+\t3:\tcmp\tV, R\n+\t\tbcc\t2b\n+@\t\tbeq\tLdo_single_div\n+\n+\t/-* NB: these are commented out in the V8-Sparc manual as well *-/\n+\t/-* (I do not understand this) *-/\n+\t@ V > R: went too far: back up 1 step\n+\t@\tsrl\tV, 1, V\n+\t@\tdec\tSC\n+\t@ do single-bit divide steps\n+\t@\n+\t@ We have to be careful here.  We know that R >= V, so we can do the\n+\t@ first divide step without thinking.  BUT, the others are conditional,\n+\t@ and are only done if R >= 0.  Because both R and V may have the high-\n+\t@ order bit set in the first step, just falling into the regular\n+\t@ division loop will mess up the first time around.\n+\t@ So we unroll slightly...\n+\tLdo_single_div:\n+\t\tsubs\tSC, SC, #1\n+\t\tblt\tLend_regular_divide\n+\t\tsub\tR, R, V\n+\t\tmov\tQ, #1\n+\t\tb\tLend_single_divloop\n+\tLsingle_divloop:\n+\t\tcmp\tR, #0\n+\t\tmov\tQ, Q, lsl #1\n+\t\tmov\tV, V, lsr #1\n+\t\t@ R >= 0\n+\t\tsubpl\tR, R, V\n+\t\taddpl\tQ, Q, #1\n+\t\t@ R < 0\n+\t\taddmi\tR, R, V\n+\t\tsubmi\tQ, Q, #1\n+\tLend_single_divloop:\n+\t\tsubs\tSC, SC, #1\n+\t\tbge\tLsingle_divloop\n+\t\tb\tLend_regular_divide\n+\n+1:\n+\tadd\tITER, ITER, #1\n+Lnot_really_big:\n+\tmov\tV, V, lsl `#'N\n+\tcmp\tV, R\n+\tbls\t1b\n+\t@\n+\t@\tHOW CAN ITER EVER BE -1 HERE ?????\n+\t@\n+\tcmn\tITER, #1\n+\tbeq\tLgot_result\n+\n+Ldivloop:\n+\tcmp\tR, #0\t@ set up for initial iteration\n+\tmov\tQ, Q, lsl `#'N\n+\tDEVELOP_QUOTIENT_BITS(1, 0)\n+Lend_regular_divide:\n+\tsubs\tITER, ITER, #1\n+\tbge\tLdivloop\n+\tcmp\tR, #0\n+\t@ non-restoring fixup here (one instruction only!)\n+ifelse(OP, `div',\n+`\tsublt\tQ, Q, #1\n+', `\taddlt\tR, divisor, R\n+')\n+\n+Lgot_result:\n+ifelse(S, `true',\n+`\t@ check to see if answer should be < 0\n+\tcmp\tSIGN, #0\n+\tifelse(OP, `div', `rsbmi Q, Q, #0', `rsbmi R, R, #0')\n+')\n+\tifelse(OP, `div', `mov r0, Q', `mov r0, R')\n+\tret\n+\n+Ldiv_zero:\n+\t@ Divide by zero trap.  If it returns, return 0 (about as\n+\t@ wrong as possible, but that is what SunOS does...).\n+\tbl\t___div0\n+\tmov\tr0, #0\n+\tret\n+*/\n+\n+#ifdef L_udivsi3\n+\n+ip\t.req\tr12\n+sp\t.req\tr13\n+lr\t.req\tr14\n+pc\t.req\tr15\n+.text\n+\t.globl ___udivsi3\n+\t.align 0\n+___udivsi3:\n+\tstmdb\tsp!, {r4, r5, lr}\n+\t@ Ready to divide.  Compute size of quotient; scale comparand.\n+\tmovs\tlr, r1\n+\tmov\tr3, r0\n+\tbeq\tLdiv_zero\n+\n+\n+\tcmp\tr3, lr\t\t\t@ if r1 exceeds r0, done\n+\tmov\tr2, #0\n+\tbcc\tLgot_result\t\t@ (and algorithm fails otherwise)\n+\tmov\tr4, #(1 << (32 - 4 - 1))\n+\tcmp\tr3, r4\n+\tmov\tip, #0\n+\tbcc\tLnot_really_big\n+\n+\t@ Here the dividend is >= 2^(31-N) or so.  We must be careful here,\n+\t@ as our usual N-at-a-shot divide step will cause overflow and havoc.\n+\t@ The number of bits in the result here is N*ITER+SC, where SC <= N.\n+\t@ Compute ITER in an unorthodox manner: know we need to shift V into\n+\t@ the top decade: so do not even bother to compare to R.\n+\t\tmov\tr5, #1\n+\t1:\n+\t\tcmp\tlr, r4\n+\t\tbcs\t3f\n+\t\tmov\tlr, lr, lsl #4\n+\t\tadd\tip, ip, #1\n+\t\tb\t1b\n+\n+\t@ Now compute r5.\n+\t2:\tadds\tlr, lr, lr\n+\t\tadd\tr5, r5, #1\n+\t\tbcc\tLnot_too_big\n+\n+\t\t@ We get here if the r1 overflowed while shifting.\n+\t\t@ This means that r3 has the high-order bit set.\n+\t\t@ Restore lr and subtract from r3.\n+\t\tmov\tr4, r4, lsl #4\n+\t\tmov\tlr, lr, lsr #1\n+\t\tadd\tlr, r4, lr\n+\t\tsub\tr5, r5, #1\n+\t\tb\tLdo_single_div\n+\n+\tLnot_too_big:\n+\t3:\tcmp\tlr, r3\n+\t\tbcc\t2b\n+@\t\tbeq\tLdo_single_div\n+\n+\t/* NB: these are commented out in the V8-Sparc manual as well */\n+\t/* (I do not understand this) */\n+\t@ lr > r3: went too far: back up 1 step\n+\t@\tsrl\tlr, 1, lr\n+\t@\tdec\tr5\n+\t@ do single-bit divide steps\n+\t@\n+\t@ We have to be careful here.  We know that r3 >= lr, so we can do the\n+\t@ first divide step without thinking.  BUT, the others are conditional,\n+\t@ and are only done if r3 >= 0.  Because both r3 and lr may have the high-\n+\t@ order bit set in the first step, just falling into the regular\n+\t@ division loop will mess up the first time around.\n+\t@ So we unroll slightly...\n+\tLdo_single_div:\n+\t\tsubs\tr5, r5, #1\n+\t\tblt\tLend_regular_divide\n+\t\tsub\tr3, r3, lr\n+\t\tmov\tr2, #1\n+\t\tb\tLend_single_divloop\n+\tLsingle_divloop:\n+\t\tcmp\tr3, #0\n+\t\tmov\tr2, r2, lsl #1\n+\t\tmov\tlr, lr, lsr #1\n+\t\t@ r3 >= 0\n+\t\tsubpl\tr3, r3, lr\n+\t\taddpl\tr2, r2, #1\n+\t\t@ r3 < 0\n+\t\taddmi\tr3, r3, lr\n+\t\tsubmi\tr2, r2, #1\n+\tLend_single_divloop:\n+\t\tsubs\tr5, r5, #1\n+\t\tbge\tLsingle_divloop\n+\t\tb\tLend_regular_divide\n+\n+1:\n+\tadd\tip, ip, #1\n+Lnot_really_big:\n+\tmov\tlr, lr, lsl #4\n+\tcmp\tlr, r3\n+\tbls\t1b\n+\t@\n+\t@\tHOW CAN ip EVER BE -1 HERE ?????\n+\t@\n+\tcmn\tip, #1\n+\tbeq\tLgot_result\n+\n+Ldivloop:\n+\tcmp\tr3, #0\t@ set up for initial iteration\n+\tmov\tr2, r2, lsl #4\n+\t\t@ depth 1, accumulated bits 0\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.1.1015\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 2, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.2.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits 3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1018\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 7\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1022\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #15\n+\n+\t\tb\t9f\n+\t\n+L.4.1022:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #13\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1018:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 5\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1020\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #11\n+\n+\t\tb\t9f\n+\t\n+L.4.1020:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #9\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+L.2.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1018\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #7\n+\n+\t\tb\t9f\n+\t\n+L.4.1018:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #5\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #3\n+\n+\t\tb\t9f\n+\t\n+L.4.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #1\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+\t\n+L.1.1015:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 2, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.2.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #1\n+\n+\t\tb\t9f\n+\t\n+L.4.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #3\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1012\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #5\n+\n+\t\tb\t9f\n+\t\n+L.4.1012:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #7\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+L.2.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits -3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1012\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -5\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1010\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #9\n+\n+\t\tb\t9f\n+\t\n+L.4.1010:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #11\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1012:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -7\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1008\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #13\n+\n+\t\tb\t9f\n+\t\n+L.4.1008:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #15\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+\t\n+\t9:\n+Lend_regular_divide:\n+\tsubs\tip, ip, #1\n+\tbge\tLdivloop\n+\tcmp\tr3, #0\n+\t@ non-restoring fixup here (one instruction only!)\n+\tsublt\tr2, r2, #1\n+\n+\n+Lgot_result:\n+\n+\tmov r0, r2\n+\tldmia\tsp!, {r4, r5, pc}\n+\n+Ldiv_zero:\n+\t@ Divide by zero trap.  If it returns, return 0 (about as\n+\t@ wrong as possible, but that is what SunOS does...).\n+\tbl\t___div0\n+\tmov\tr0, #0\n+\tldmia\tsp!, {r4, r5, pc}\n+\n+#endif /* L_udivsi3 */\n+\n+#ifdef L_divsi3\n+\n+ip\t.req\tr12\n+sp\t.req\tr13\n+lr\t.req\tr14\n+pc\t.req\tr15\n+.text\n+\t.globl ___divsi3\n+\t.align 0\n+___divsi3:\n+\tstmdb\tsp!, {r4, r5, r6, lr}\n+\t@ compute sign of result; if neither is negative, no problem\n+\teor\tr6, r1, r0\t@ compute sign\n+\tcmp\tr1, #0\n+\trsbmi\tr1, r1, #0\n+\tbeq\tLdiv_zero\n+\tmov\tlr, r1\n+\tmovs\tr3, r0\n+\trsbmi\tr3, r3, #0\t@ make dividend nonnegative\n+\n+\n+\tcmp\tr3, lr\t\t\t@ if r1 exceeds r0, done\n+\tmov\tr2, #0\n+\tbcc\tLgot_result\t\t@ (and algorithm fails otherwise)\n+\tmov\tr4, #(1 << (32 - 4 - 1))\n+\tcmp\tr3, r4\n+\tmov\tip, #0\n+\tbcc\tLnot_really_big\n+\n+\t@ Here the dividend is >= 2^(31-N) or so.  We must be careful here,\n+\t@ as our usual N-at-a-shot divide step will cause overflow and havoc.\n+\t@ The number of bits in the result here is N*ITER+SC, where SC <= N.\n+\t@ Compute ITER in an unorthodox manner: know we need to shift V into\n+\t@ the top decade: so do not even bother to compare to R.\n+\t\tmov\tr5, #1\n+\t1:\n+\t\tcmp\tlr, r4\n+\t\tbcs\t3f\n+\t\tmov\tlr, lr, lsl #4\n+\t\tadd\tip, ip, #1\n+\t\tb\t1b\n+\n+\t@ Now compute r5.\n+\t2:\tadds\tlr, lr, lr\n+\t\tadd\tr5, r5, #1\n+\t\tbcc\tLnot_too_big\n+\n+\t\t@ We get here if the r1 overflowed while shifting.\n+\t\t@ This means that r3 has the high-order bit set.\n+\t\t@ Restore lr and subtract from r3.\n+\t\tmov\tr4, r4, lsl #4\n+\t\tmov\tlr, lr, lsr #1\n+\t\tadd\tlr, r4, lr\n+\t\tsub\tr5, r5, #1\n+\t\tb\tLdo_single_div\n+\n+\tLnot_too_big:\n+\t3:\tcmp\tlr, r3\n+\t\tbcc\t2b\n+@\t\tbeq\tLdo_single_div\n+\n+\t/* NB: these are commented out in the V8-Sparc manual as well */\n+\t/* (I do not understand this) */\n+\t@ lr > r3: went too far: back up 1 step\n+\t@\tsrl\tlr, 1, lr\n+\t@\tdec\tr5\n+\t@ do single-bit divide steps\n+\t@\n+\t@ We have to be careful here.  We know that r3 >= lr, so we can do the\n+\t@ first divide step without thinking.  BUT, the others are conditional,\n+\t@ and are only done if r3 >= 0.  Because both r3 and lr may have the high-\n+\t@ order bit set in the first step, just falling into the regular\n+\t@ division loop will mess up the first time around.\n+\t@ So we unroll slightly...\n+\tLdo_single_div:\n+\t\tsubs\tr5, r5, #1\n+\t\tblt\tLend_regular_divide\n+\t\tsub\tr3, r3, lr\n+\t\tmov\tr2, #1\n+\t\tb\tLend_single_divloop\n+\tLsingle_divloop:\n+\t\tcmp\tr3, #0\n+\t\tmov\tr2, r2, lsl #1\n+\t\tmov\tlr, lr, lsr #1\n+\t\t@ r3 >= 0\n+\t\tsubpl\tr3, r3, lr\n+\t\taddpl\tr2, r2, #1\n+\t\t@ r3 < 0\n+\t\taddmi\tr3, r3, lr\n+\t\tsubmi\tr2, r2, #1\n+\tLend_single_divloop:\n+\t\tsubs\tr5, r5, #1\n+\t\tbge\tLsingle_divloop\n+\t\tb\tLend_regular_divide\n+\n+1:\n+\tadd\tip, ip, #1\n+Lnot_really_big:\n+\tmov\tlr, lr, lsl #4\n+\tcmp\tlr, r3\n+\tbls\t1b\n+\t@\n+\t@\tHOW CAN ip EVER BE -1 HERE ?????\n+\t@\n+\tcmn\tip, #1\n+\tbeq\tLgot_result\n+\n+Ldivloop:\n+\tcmp\tr3, #0\t@ set up for initial iteration\n+\tmov\tr2, r2, lsl #4\n+\t\t@ depth 1, accumulated bits 0\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.1.1015\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 2, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.2.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits 3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1018\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 7\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1022\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #15\n+\n+\t\tb\t9f\n+\t\n+L.4.1022:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #13\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1018:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 5\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1020\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #11\n+\n+\t\tb\t9f\n+\t\n+L.4.1020:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #9\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+L.2.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1018\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #7\n+\n+\t\tb\t9f\n+\t\n+L.4.1018:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #5\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #3\n+\n+\t\tb\t9f\n+\t\n+L.4.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #1\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+\t\n+L.1.1015:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 2, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.2.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #1\n+\n+\t\tb\t9f\n+\t\n+L.4.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #3\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1012\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #5\n+\n+\t\tb\t9f\n+\t\n+L.4.1012:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #7\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+L.2.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits -3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1012\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -5\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1010\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #9\n+\n+\t\tb\t9f\n+\t\n+L.4.1010:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #11\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1012:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -7\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1008\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #13\n+\n+\t\tb\t9f\n+\t\n+L.4.1008:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #15\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+\t\n+\t9:\n+Lend_regular_divide:\n+\tsubs\tip, ip, #1\n+\tbge\tLdivloop\n+\tcmp\tr3, #0\n+\t@ non-restoring fixup here (one instruction only!)\n+\tsublt\tr2, r2, #1\n+\n+\n+Lgot_result:\n+\t@ check to see if answer should be < 0\n+\tcmp\tr6, #0\n+\trsbmi r2, r2, #0\n+\n+\tmov r0, r2\n+\tldmia\tsp!, {r4, r5, r6, pc}\n+\n+Ldiv_zero:\n+\t@ Divide by zero trap.  If it returns, return 0 (about as\n+\t@ wrong as possible, but that is what SunOS does...).\n+\tbl\t___div0\n+\tmov\tr0, #0\n+\tldmia\tsp!, {r4, r5, r6, pc}\n+\n+#endif /* L_divsi3 */\n+\n+#ifdef L_umodsi3\n+\n+ip\t.req\tr12\n+sp\t.req\tr13\n+lr\t.req\tr14\n+pc\t.req\tr15\n+.text\n+\t.globl ___umodsi3\n+\t.align 0\n+___umodsi3:\n+\tstmdb\tsp!, {r4, r5, lr}\n+\t@ Ready to divide.  Compute size of quotient; scale comparand.\n+\tmovs\tlr, r1\n+\tmov\tr3, r0\n+\tbeq\tLdiv_zero\n+\n+\n+\tcmp\tr3, lr\t\t\t@ if r1 exceeds r0, done\n+\tmov\tr2, #0\n+\tbcc\tLgot_result\t\t@ (and algorithm fails otherwise)\n+\tmov\tr4, #(1 << (32 - 4 - 1))\n+\tcmp\tr3, r4\n+\tmov\tip, #0\n+\tbcc\tLnot_really_big\n+\n+\t@ Here the dividend is >= 2^(31-N) or so.  We must be careful here,\n+\t@ as our usual N-at-a-shot divide step will cause overflow and havoc.\n+\t@ The number of bits in the result here is N*ITER+SC, where SC <= N.\n+\t@ Compute ITER in an unorthodox manner: know we need to shift V into\n+\t@ the top decade: so do not even bother to compare to R.\n+\t\tmov\tr5, #1\n+\t1:\n+\t\tcmp\tlr, r4\n+\t\tbcs\t3f\n+\t\tmov\tlr, lr, lsl #4\n+\t\tadd\tip, ip, #1\n+\t\tb\t1b\n+\n+\t@ Now compute r5.\n+\t2:\tadds\tlr, lr, lr\n+\t\tadd\tr5, r5, #1\n+\t\tbcc\tLnot_too_big\n+\n+\t\t@ We get here if the r1 overflowed while shifting.\n+\t\t@ This means that r3 has the high-order bit set.\n+\t\t@ Restore lr and subtract from r3.\n+\t\tmov\tr4, r4, lsl #4\n+\t\tmov\tlr, lr, lsr #1\n+\t\tadd\tlr, r4, lr\n+\t\tsub\tr5, r5, #1\n+\t\tb\tLdo_single_div\n+\n+\tLnot_too_big:\n+\t3:\tcmp\tlr, r3\n+\t\tbcc\t2b\n+@\t\tbeq\tLdo_single_div\n+\n+\t/* NB: these are commented out in the V8-Sparc manual as well */\n+\t/* (I do not understand this) */\n+\t@ lr > r3: went too far: back up 1 step\n+\t@\tsrl\tlr, 1, lr\n+\t@\tdec\tr5\n+\t@ do single-bit divide steps\n+\t@\n+\t@ We have to be careful here.  We know that r3 >= lr, so we can do the\n+\t@ first divide step without thinking.  BUT, the others are conditional,\n+\t@ and are only done if r3 >= 0.  Because both r3 and lr may have the high-\n+\t@ order bit set in the first step, just falling into the regular\n+\t@ division loop will mess up the first time around.\n+\t@ So we unroll slightly...\n+\tLdo_single_div:\n+\t\tsubs\tr5, r5, #1\n+\t\tblt\tLend_regular_divide\n+\t\tsub\tr3, r3, lr\n+\t\tmov\tr2, #1\n+\t\tb\tLend_single_divloop\n+\tLsingle_divloop:\n+\t\tcmp\tr3, #0\n+\t\tmov\tr2, r2, lsl #1\n+\t\tmov\tlr, lr, lsr #1\n+\t\t@ r3 >= 0\n+\t\tsubpl\tr3, r3, lr\n+\t\taddpl\tr2, r2, #1\n+\t\t@ r3 < 0\n+\t\taddmi\tr3, r3, lr\n+\t\tsubmi\tr2, r2, #1\n+\tLend_single_divloop:\n+\t\tsubs\tr5, r5, #1\n+\t\tbge\tLsingle_divloop\n+\t\tb\tLend_regular_divide\n+\n+1:\n+\tadd\tip, ip, #1\n+Lnot_really_big:\n+\tmov\tlr, lr, lsl #4\n+\tcmp\tlr, r3\n+\tbls\t1b\n+\t@\n+\t@\tHOW CAN ip EVER BE -1 HERE ?????\n+\t@\n+\tcmn\tip, #1\n+\tbeq\tLgot_result\n+\n+Ldivloop:\n+\tcmp\tr3, #0\t@ set up for initial iteration\n+\tmov\tr2, r2, lsl #4\n+\t\t@ depth 1, accumulated bits 0\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.1.1015\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 2, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.2.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits 3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1018\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 7\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1022\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #15\n+\n+\t\tb\t9f\n+\t\n+L.4.1022:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #13\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1018:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 5\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1020\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #11\n+\n+\t\tb\t9f\n+\t\n+L.4.1020:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #9\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+L.2.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1018\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #7\n+\n+\t\tb\t9f\n+\t\n+L.4.1018:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #5\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #3\n+\n+\t\tb\t9f\n+\t\n+L.4.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #1\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+\t\n+L.1.1015:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 2, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.2.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #1\n+\n+\t\tb\t9f\n+\t\n+L.4.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #3\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1012\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #5\n+\n+\t\tb\t9f\n+\t\n+L.4.1012:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #7\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+L.2.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits -3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1012\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -5\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1010\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #9\n+\n+\t\tb\t9f\n+\t\n+L.4.1010:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #11\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1012:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -7\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1008\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #13\n+\n+\t\tb\t9f\n+\t\n+L.4.1008:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #15\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+\t\n+\t9:\n+Lend_regular_divide:\n+\tsubs\tip, ip, #1\n+\tbge\tLdivloop\n+\tcmp\tr3, #0\n+\t@ non-restoring fixup here (one instruction only!)\n+\taddlt\tr3, r1, r3\n+\n+\n+Lgot_result:\n+\n+\tmov r0, r3\n+\tldmia\tsp!, {r4, r5, pc}\n+\n+Ldiv_zero:\n+\t@ Divide by zero trap.  If it returns, return 0 (about as\n+\t@ wrong as possible, but that is what SunOS does...).\n+\tbl\t___div0\n+\tmov\tr0, #0\n+\tldmia\tsp!, {r4, r5, pc}\n+\n+#endif /* L_umodsi3 */\n+\n+#ifdef L_modsi3\n+\n+ip\t.req\tr12\n+sp\t.req\tr13\n+lr\t.req\tr14\n+pc\t.req\tr15\n+.text\n+\t.globl ___modsi3\n+\t.align 0\n+___modsi3:\n+\tstmdb\tsp!, {r4, r5, r6, lr}\n+\t@ compute sign of result; if neither is negative, no problem\n+\teor\tr6, r1, r0\t@ compute sign\n+\tcmp\tr1, #0\n+\trsbmi\tr1, r1, #0\n+\tbeq\tLdiv_zero\n+\tmov\tlr, r1\n+\tmovs\tr3, r0\n+\trsbmi\tr3, r3, #0\t@ make dividend nonnegative\n+\n+\n+\tcmp\tr3, lr\t\t\t@ if r1 exceeds r0, done\n+\tmov\tr2, #0\n+\tbcc\tLgot_result\t\t@ (and algorithm fails otherwise)\n+\tmov\tr4, #(1 << (32 - 4 - 1))\n+\tcmp\tr3, r4\n+\tmov\tip, #0\n+\tbcc\tLnot_really_big\n+\n+\t@ Here the dividend is >= 2^(31-N) or so.  We must be careful here,\n+\t@ as our usual N-at-a-shot divide step will cause overflow and havoc.\n+\t@ The number of bits in the result here is N*ITER+SC, where SC <= N.\n+\t@ Compute ITER in an unorthodox manner: know we need to shift V into\n+\t@ the top decade: so do not even bother to compare to R.\n+\t\tmov\tr5, #1\n+\t1:\n+\t\tcmp\tlr, r4\n+\t\tbcs\t3f\n+\t\tmov\tlr, lr, lsl #4\n+\t\tadd\tip, ip, #1\n+\t\tb\t1b\n+\n+\t@ Now compute r5.\n+\t2:\tadds\tlr, lr, lr\n+\t\tadd\tr5, r5, #1\n+\t\tbcc\tLnot_too_big\n+\n+\t\t@ We get here if the r1 overflowed while shifting.\n+\t\t@ This means that r3 has the high-order bit set.\n+\t\t@ Restore lr and subtract from r3.\n+\t\tmov\tr4, r4, lsl #4\n+\t\tmov\tlr, lr, lsr #1\n+\t\tadd\tlr, r4, lr\n+\t\tsub\tr5, r5, #1\n+\t\tb\tLdo_single_div\n+\n+\tLnot_too_big:\n+\t3:\tcmp\tlr, r3\n+\t\tbcc\t2b\n+@\t\tbeq\tLdo_single_div\n+\n+\t/* NB: these are commented out in the V8-Sparc manual as well */\n+\t/* (I do not understand this) */\n+\t@ lr > r3: went too far: back up 1 step\n+\t@\tsrl\tlr, 1, lr\n+\t@\tdec\tr5\n+\t@ do single-bit divide steps\n+\t@\n+\t@ We have to be careful here.  We know that r3 >= lr, so we can do the\n+\t@ first divide step without thinking.  BUT, the others are conditional,\n+\t@ and are only done if r3 >= 0.  Because both r3 and lr may have the high-\n+\t@ order bit set in the first step, just falling into the regular\n+\t@ division loop will mess up the first time around.\n+\t@ So we unroll slightly...\n+\tLdo_single_div:\n+\t\tsubs\tr5, r5, #1\n+\t\tblt\tLend_regular_divide\n+\t\tsub\tr3, r3, lr\n+\t\tmov\tr2, #1\n+\t\tb\tLend_single_divloop\n+\tLsingle_divloop:\n+\t\tcmp\tr3, #0\n+\t\tmov\tr2, r2, lsl #1\n+\t\tmov\tlr, lr, lsr #1\n+\t\t@ r3 >= 0\n+\t\tsubpl\tr3, r3, lr\n+\t\taddpl\tr2, r2, #1\n+\t\t@ r3 < 0\n+\t\taddmi\tr3, r3, lr\n+\t\tsubmi\tr2, r2, #1\n+\tLend_single_divloop:\n+\t\tsubs\tr5, r5, #1\n+\t\tbge\tLsingle_divloop\n+\t\tb\tLend_regular_divide\n+\n+1:\n+\tadd\tip, ip, #1\n+Lnot_really_big:\n+\tmov\tlr, lr, lsl #4\n+\tcmp\tlr, r3\n+\tbls\t1b\n+\t@\n+\t@\tHOW CAN ip EVER BE -1 HERE ?????\n+\t@\n+\tcmn\tip, #1\n+\tbeq\tLgot_result\n+\n+Ldivloop:\n+\tcmp\tr3, #0\t@ set up for initial iteration\n+\tmov\tr2, r2, lsl #4\n+\t\t@ depth 1, accumulated bits 0\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.1.1015\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 2, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.2.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits 3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1018\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 7\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1022\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #15\n+\n+\t\tb\t9f\n+\t\n+L.4.1022:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #13\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1018:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 5\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1020\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #11\n+\n+\t\tb\t9f\n+\t\n+L.4.1020:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #9\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+L.2.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1018\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #7\n+\n+\t\tb\t9f\n+\t\n+L.4.1018:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #5\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits 1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1016\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tadd\tr2, r2, #3\n+\n+\t\tb\t9f\n+\t\n+L.4.1016:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tadd\tr2, r2, #1\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+\t\n+L.1.1015:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 2, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.2.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -1\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1014\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #1\n+\n+\t\tb\t9f\n+\t\n+L.4.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #3\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1012\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #5\n+\n+\t\tb\t9f\n+\t\n+L.4.1012:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #7\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+L.2.1014:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 3, accumulated bits -3\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.3.1012\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -5\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1010\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #9\n+\n+\t\tb\t9f\n+\t\n+L.4.1010:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #11\n+\t\tb\t9f\n+\n+\t\n+\t\n+L.3.1012:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\t\t@ depth 4, accumulated bits -7\n+\tmov\tlr, lr, lsr #1\n+\tblt\tL.4.1008\n+\t@ remainder is positive\n+\tsubs\tr3, r3, lr\n+\t\tsub\tr2, r2, #13\n+\n+\t\tb\t9f\n+\t\n+L.4.1008:\n+\t@ remainder is negative\n+\tadds\tr3, r3, lr\n+\t\tsub\tr2, r2, #15\n+\t\tb\t9f\n+\n+\t\n+\t\n+\t\n+\t\n+\t9:\n+Lend_regular_divide:\n+\tsubs\tip, ip, #1\n+\tbge\tLdivloop\n+\tcmp\tr3, #0\n+\t@ non-restoring fixup here (one instruction only!)\n+\taddlt\tr3, r1, r3\n+\n+\n+Lgot_result:\n+\t@ check to see if answer should be < 0\n+\tcmp\tr6, #0\n+\trsbmi r3, r3, #0\n+\n+\tmov r0, r3\n+\tldmia\tsp!, {r4, r5, r6, pc}\n+\n+Ldiv_zero:\n+\t@ Divide by zero trap.  If it returns, return 0 (about as\n+\t@ wrong as possible, but that is what SunOS does...).\n+\tbl\t___div0\n+\tmov\tr0, #0\n+\tldmia\tsp!, {r4, r5, r6, pc}\n+\n+#endif /* L_modsi3 */\n+\n+#ifdef L_divmodsi_tools\n+\n+\t.globl ___div0\n+\t.align 0\n+___div0:\n+\tmov\tpc, lr\n+\n+#endif /* L_divmodsi_tools */"}]}