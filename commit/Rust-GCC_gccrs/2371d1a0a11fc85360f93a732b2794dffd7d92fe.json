{"sha": "2371d1a0a11fc85360f93a732b2794dffd7d92fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM3MWQxYTBhMTFmYzg1MzYwZjkzYTczMmIyNzk0ZGZmZDdkOTJmZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-11-15T23:43:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-11-15T23:43:08Z"}, "message": "alpha: Convert to atomic optabs.\n\nFrom-SVN: r181395", "tree": {"sha": "c0fb259e8e28bd8177c369c261835664ce36ff6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0fb259e8e28bd8177c369c261835664ce36ff6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2371d1a0a11fc85360f93a732b2794dffd7d92fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2371d1a0a11fc85360f93a732b2794dffd7d92fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2371d1a0a11fc85360f93a732b2794dffd7d92fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2371d1a0a11fc85360f93a732b2794dffd7d92fe/comments", "author": null, "committer": null, "parents": [{"sha": "6dc88283f680c7cd54a5ff1713891d7c36ab7e17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc88283f680c7cd54a5ff1713891d7c36ab7e17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dc88283f680c7cd54a5ff1713891d7c36ab7e17"}], "stats": {"total": 640, "additions": 431, "deletions": 209}, "files": [{"sha": "75a9e2fbb5cc915c27605afe982223687c35b525", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2371d1a0a11fc85360f93a732b2794dffd7d92fe", "patch": "@@ -1,3 +1,29 @@\n+2011-11-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (alpha_pre_atomic_barrier): New.\n+\t(alpha_post_atomic_barrier): New.\n+\t(alpha_split_atomic_op): New memmodel argument; honor it.\n+\t(alpha_split_compare_and_swap): Take array of operands.  Honor\n+\tmemmodel; always set bool output\n+\t(alpha_expand_compare_and_swap_12): Similarly.\n+\t(alpha_split_compare_and_swap_12): Similarly.\n+\t(alpha_split_atomic_exchange): Similarly.  Rename from\n+\talpha_split_lock_test_and_set.\n+\t(alpha_expand_atomic_exchange_12): Similarly.  Rename from\n+\talpha_expand_lock_test_and_set_12.\n+\t(alpha_split_atomic_exchange_12): Similarly.  Rename from\n+\talpha_split_lock_test_and_set_12.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/alpha.md (UNSPECV_CMPXCHG): New.\n+\t* config/alpha/constraints.md (\"w\"): New.\n+\t* config/alpha/predicates.md (mem_noofs_operand): New.\n+\t* config/alpha/sync.md (atomic_compare_and_swap<mode>): Rename from\n+\tsync_compare_and_swap<mode>; add the new parameters.\n+\t(atomic_exchange<mode>): Update from sync_test_and_set<mode>.\n+\t(atomic_fetch_<op><mode>): Update from sync_old_<op><mode>.\n+\t(atomic_<op>_fetch<mode>): Update from sync_new_<op><mode>.\n+\t(atomic_<op><mode>): Update from sync_<op><mode>.\n+\n 2011-11-16  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-ssa-tail-merge.c (replace_block_by): Add frequency of bb2 to bb1."}, {"sha": "42b34d3a39cd8ffa2159077b1f12a8303850887f", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=2371d1a0a11fc85360f93a732b2794dffd7d92fe", "patch": "@@ -88,15 +88,14 @@ extern bool alpha_emit_setcc (rtx[], enum machine_mode);\n extern int alpha_split_conditional_move (enum rtx_code, rtx, rtx, rtx, rtx);\n extern void alpha_emit_xfloating_arith (enum rtx_code, rtx[]);\n extern void alpha_emit_xfloating_cvt (enum rtx_code, rtx[]);\n-extern void alpha_split_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n-extern void alpha_split_compare_and_swap (rtx, rtx, rtx, rtx, rtx);\n-extern void alpha_expand_compare_and_swap_12 (rtx, rtx, rtx, rtx);\n-extern void alpha_split_compare_and_swap_12 (enum machine_mode, rtx, rtx,\n-\t\t\t\t\t     rtx, rtx, rtx, rtx, rtx);\n-extern void alpha_split_lock_test_and_set (rtx, rtx, rtx, rtx);\n-extern void alpha_expand_lock_test_and_set_12 (rtx, rtx, rtx);\n-extern void alpha_split_lock_test_and_set_12 (enum machine_mode, rtx, rtx,\n-\t\t\t\t\t      rtx, rtx, rtx);\n+extern void alpha_split_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx,\n+\t\t\t\t   enum memmodel);\n+extern void alpha_split_compare_and_swap (rtx op[]);\n+extern void alpha_expand_compare_and_swap_12 (rtx op[]);\n+extern void alpha_split_compare_and_swap_12 (rtx op[]);\n+extern void alpha_split_atomic_exchange (rtx op[]);\n+extern void alpha_expand_atomic_exchange_12 (rtx op[]);\n+extern void alpha_split_atomic_exchange_12 (rtx op[]);\n #endif\n \n extern rtx alpha_use_linkage (rtx, bool, bool);"}, {"sha": "78717f96d16452958c06d2eaad9157c964633cf2", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 213, "deletions": 61, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=2371d1a0a11fc85360f93a732b2794dffd7d92fe", "patch": "@@ -4196,6 +4196,47 @@ emit_store_conditional (enum machine_mode mode, rtx res, rtx mem, rtx val)\n   emit_insn (fn (res, mem, val));\n }\n \n+/* Subroutines of the atomic operation splitters.  Emit barriers\n+   as needed for the memory MODEL.  */\n+\n+static void\n+alpha_pre_atomic_barrier (enum memmodel model)\n+{\n+  switch (model)\n+    {\n+    case MEMMODEL_RELAXED:\n+    case MEMMODEL_CONSUME:\n+    case MEMMODEL_ACQUIRE:\n+      break;\n+    case MEMMODEL_RELEASE:\n+    case MEMMODEL_ACQ_REL:\n+    case MEMMODEL_SEQ_CST:\n+      emit_insn (gen_memory_barrier ());\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static void\n+alpha_post_atomic_barrier (enum memmodel model)\n+{\n+  switch (model)\n+    {\n+    case MEMMODEL_RELAXED:\n+    case MEMMODEL_CONSUME:\n+    case MEMMODEL_RELEASE:\n+      break;\n+    case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_ACQ_REL:\n+    case MEMMODEL_SEQ_CST:\n+      emit_insn (gen_memory_barrier ());\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* A subroutine of the atomic operation splitters.  Emit an insxl\n    instruction in MODE.  */\n \n@@ -4236,13 +4277,13 @@ emit_insxl (enum machine_mode mode, rtx op1, rtx op2)\n    a scratch register.  */\n \n void\n-alpha_split_atomic_op (enum rtx_code code, rtx mem, rtx val,\n-\t\t       rtx before, rtx after, rtx scratch)\n+alpha_split_atomic_op (enum rtx_code code, rtx mem, rtx val, rtx before,\n+\t\t       rtx after, rtx scratch, enum memmodel model)\n {\n   enum machine_mode mode = GET_MODE (mem);\n   rtx label, x, cond = gen_rtx_REG (DImode, REGNO (scratch));\n \n-  emit_insn (gen_memory_barrier ());\n+  alpha_pre_atomic_barrier (model);\n \n   label = gen_label_rtx ();\n   emit_label (label);\n@@ -4270,29 +4311,48 @@ alpha_split_atomic_op (enum rtx_code code, rtx mem, rtx val,\n   x = gen_rtx_EQ (DImode, cond, const0_rtx);\n   emit_unlikely_jump (x, label);\n \n-  emit_insn (gen_memory_barrier ());\n+  alpha_post_atomic_barrier (model);\n }\n \n /* Expand a compare and swap operation.  */\n \n void\n-alpha_split_compare_and_swap (rtx retval, rtx mem, rtx oldval, rtx newval,\n-\t\t\t      rtx scratch)\n+alpha_split_compare_and_swap (rtx operands[])\n {\n-  enum machine_mode mode = GET_MODE (mem);\n-  rtx label1, label2, x, cond = gen_lowpart (DImode, scratch);\n+  rtx cond, retval, mem, oldval, newval;\n+  bool is_weak;\n+  enum memmodel mod_s, mod_f;\n+  enum machine_mode mode;\n+  rtx label1, label2, x;\n+\n+  cond = operands[0];\n+  retval = operands[1];\n+  mem = operands[2];\n+  oldval = operands[3];\n+  newval = operands[4];\n+  is_weak = (operands[5] != const0_rtx);\n+  mod_s = (enum memmodel) INTVAL (operands[6]);\n+  mod_f = (enum memmodel) INTVAL (operands[7]);\n+  mode = GET_MODE (mem);\n \n-  emit_insn (gen_memory_barrier ());\n+  alpha_pre_atomic_barrier (mod_s);\n \n-  label1 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  label1 = NULL_RTX;\n+  if (!is_weak)\n+    {\n+      label1 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+      emit_label (XEXP (label1, 0));\n+    }\n   label2 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n-  emit_label (XEXP (label1, 0));\n \n   emit_load_locked (mode, retval, mem);\n \n   x = gen_lowpart (DImode, retval);\n   if (oldval == const0_rtx)\n-    x = gen_rtx_NE (DImode, x, const0_rtx);\n+    {\n+      emit_move_insn (cond, const0_rtx);\n+      x = gen_rtx_NE (DImode, x, const0_rtx);\n+    }\n   else\n     {\n       x = gen_rtx_EQ (DImode, x, oldval);\n@@ -4301,54 +4361,99 @@ alpha_split_compare_and_swap (rtx retval, rtx mem, rtx oldval, rtx newval,\n     }\n   emit_unlikely_jump (x, label2);\n \n-  emit_move_insn (scratch, newval);\n-  emit_store_conditional (mode, cond, mem, scratch);\n+  emit_move_insn (cond, newval);\n+  emit_store_conditional (mode, cond, mem, gen_lowpart (mode, cond));\n \n-  x = gen_rtx_EQ (DImode, cond, const0_rtx);\n-  emit_unlikely_jump (x, label1);\n+  if (!is_weak)\n+    {\n+      x = gen_rtx_EQ (DImode, cond, const0_rtx);\n+      emit_unlikely_jump (x, label1);\n+    }\n+\n+  if (mod_f != MEMMODEL_RELAXED)\n+    emit_label (XEXP (label2, 0));\n \n-  emit_insn (gen_memory_barrier ());\n-  emit_label (XEXP (label2, 0));\n+  alpha_post_atomic_barrier (mod_s);\n+\n+  if (mod_f == MEMMODEL_RELAXED)\n+    emit_label (XEXP (label2, 0));\n }\n \n void\n-alpha_expand_compare_and_swap_12 (rtx dst, rtx mem, rtx oldval, rtx newval)\n+alpha_expand_compare_and_swap_12 (rtx operands[])\n {\n-  enum machine_mode mode = GET_MODE (mem);\n+  rtx cond, dst, mem, oldval, newval, is_weak, mod_s, mod_f;\n+  enum machine_mode mode;\n   rtx addr, align, wdst;\n-  rtx (*fn5) (rtx, rtx, rtx, rtx, rtx);\n+  rtx (*gen) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+\n+  cond = operands[0];\n+  dst = operands[1];\n+  mem = operands[2];\n+  oldval = operands[3];\n+  newval = operands[4];\n+  is_weak = operands[5];\n+  mod_s = operands[6];\n+  mod_f = operands[7];\n+  mode = GET_MODE (mem);\n+\n+  /* We forced the address into a register via mem_noofs_operand.  */\n+  addr = XEXP (mem, 0);\n+  gcc_assert (register_operand (addr, DImode));\n \n-  addr = force_reg (DImode, XEXP (mem, 0));\n   align = expand_simple_binop (Pmode, AND, addr, GEN_INT (-8),\n \t\t\t       NULL_RTX, 1, OPTAB_DIRECT);\n \n   oldval = convert_modes (DImode, mode, oldval, 1);\n-  newval = emit_insxl (mode, newval, addr);\n+\n+  if (newval != const0_rtx)\n+    newval = emit_insxl (mode, newval, addr);\n \n   wdst = gen_reg_rtx (DImode);\n   if (mode == QImode)\n-    fn5 = gen_sync_compare_and_swapqi_1;\n+    gen = gen_atomic_compare_and_swapqi_1;\n   else\n-    fn5 = gen_sync_compare_and_swaphi_1;\n-  emit_insn (fn5 (wdst, addr, oldval, newval, align));\n+    gen = gen_atomic_compare_and_swaphi_1;\n+  emit_insn (gen (cond, wdst, mem, oldval, newval, align,\n+\t\t  is_weak, mod_s, mod_f));\n \n   emit_move_insn (dst, gen_lowpart (mode, wdst));\n }\n \n void\n-alpha_split_compare_and_swap_12 (enum machine_mode mode, rtx dest, rtx addr,\n-\t\t\t\t rtx oldval, rtx newval, rtx align,\n-\t\t\t\t rtx scratch, rtx cond)\n+alpha_split_compare_and_swap_12 (rtx operands[])\n {\n-  rtx label1, label2, mem, width, mask, x;\n+  rtx cond, dest, orig_mem, oldval, newval, align, scratch;\n+  enum machine_mode mode;\n+  bool is_weak;\n+  enum memmodel mod_s, mod_f;\n+  rtx label1, label2, mem, addr, width, mask, x;\n+\n+  cond = operands[0];\n+  dest = operands[1];\n+  orig_mem = operands[2];\n+  oldval = operands[3];\n+  newval = operands[4];\n+  align = operands[5];\n+  is_weak = (operands[6] != const0_rtx);\n+  mod_s = (enum memmodel) INTVAL (operands[7]);\n+  mod_f = (enum memmodel) INTVAL (operands[8]);\n+  scratch = operands[9];\n+  mode = GET_MODE (orig_mem);\n+  addr = XEXP (orig_mem, 0);\n \n   mem = gen_rtx_MEM (DImode, align);\n-  MEM_VOLATILE_P (mem) = 1;\n+  MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (orig_mem);\n+\n+  alpha_pre_atomic_barrier (mod_s);\n \n-  emit_insn (gen_memory_barrier ());\n-  label1 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  label1 = NULL_RTX;\n+  if (!is_weak)\n+    {\n+      label1 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+      emit_label (XEXP (label1, 0));\n+    }\n   label2 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n-  emit_label (XEXP (label1, 0));\n \n   emit_load_locked (DImode, scratch, mem);\n   \n@@ -4357,7 +4462,10 @@ alpha_split_compare_and_swap_12 (enum machine_mode mode, rtx dest, rtx addr,\n   emit_insn (gen_extxl (dest, scratch, width, addr));\n \n   if (oldval == const0_rtx)\n-    x = gen_rtx_NE (DImode, dest, const0_rtx);\n+    {\n+      emit_move_insn (cond, const0_rtx);\n+      x = gen_rtx_NE (DImode, dest, const0_rtx);\n+    }\n   else\n     {\n       x = gen_rtx_EQ (DImode, dest, oldval);\n@@ -4366,25 +4474,47 @@ alpha_split_compare_and_swap_12 (enum machine_mode mode, rtx dest, rtx addr,\n     }\n   emit_unlikely_jump (x, label2);\n \n-  emit_insn (gen_mskxl (scratch, scratch, mask, addr));\n-  emit_insn (gen_iordi3 (scratch, scratch, newval));\n+  emit_insn (gen_mskxl (cond, scratch, mask, addr));\n \n-  emit_store_conditional (DImode, scratch, mem, scratch);\n+  if (newval != const0_rtx)\n+    emit_insn (gen_iordi3 (cond, cond, newval));\n \n-  x = gen_rtx_EQ (DImode, scratch, const0_rtx);\n-  emit_unlikely_jump (x, label1);\n+  emit_store_conditional (DImode, cond, mem, cond);\n \n-  emit_insn (gen_memory_barrier ());\n-  emit_label (XEXP (label2, 0));\n+  if (!is_weak)\n+    {\n+      x = gen_rtx_EQ (DImode, cond, const0_rtx);\n+      emit_unlikely_jump (x, label1);\n+    }\n+\n+  if (mod_f != MEMMODEL_RELAXED)\n+    emit_label (XEXP (label2, 0));\n+\n+  alpha_post_atomic_barrier (mod_s);\n+\n+  if (mod_f == MEMMODEL_RELAXED)\n+    emit_label (XEXP (label2, 0));\n }\n \n /* Expand an atomic exchange operation.  */\n \n void\n-alpha_split_lock_test_and_set (rtx retval, rtx mem, rtx val, rtx scratch)\n+alpha_split_atomic_exchange (rtx operands[])\n {\n-  enum machine_mode mode = GET_MODE (mem);\n-  rtx label, x, cond = gen_lowpart (DImode, scratch);\n+  rtx retval, mem, val, scratch;\n+  enum memmodel model;\n+  enum machine_mode mode;\n+  rtx label, x, cond;\n+\n+  retval = operands[0];\n+  mem = operands[1];\n+  val = operands[2];\n+  model = (enum memmodel) INTVAL (operands[3]);\n+  scratch = operands[4];\n+  mode = GET_MODE (mem);\n+  cond = gen_lowpart (DImode, scratch);\n+\n+  alpha_pre_atomic_barrier (model);\n \n   label = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n   emit_label (XEXP (label, 0));\n@@ -4396,44 +4526,65 @@ alpha_split_lock_test_and_set (rtx retval, rtx mem, rtx val, rtx scratch)\n   x = gen_rtx_EQ (DImode, cond, const0_rtx);\n   emit_unlikely_jump (x, label);\n \n-  emit_insn (gen_memory_barrier ());\n+  alpha_post_atomic_barrier (model);\n }\n \n void\n-alpha_expand_lock_test_and_set_12 (rtx dst, rtx mem, rtx val)\n+alpha_expand_atomic_exchange_12 (rtx operands[])\n {\n-  enum machine_mode mode = GET_MODE (mem);\n+  rtx dst, mem, val, model;\n+  enum machine_mode mode;\n   rtx addr, align, wdst;\n-  rtx (*fn4) (rtx, rtx, rtx, rtx);\n+  rtx (*gen) (rtx, rtx, rtx, rtx, rtx);\n+\n+  dst = operands[0];\n+  mem = operands[1];\n+  val = operands[2];\n+  model = operands[3];\n+  mode = GET_MODE (mem);\n \n-  /* Force the address into a register.  */\n-  addr = force_reg (DImode, XEXP (mem, 0));\n+  /* We forced the address into a register via mem_noofs_operand.  */\n+  addr = XEXP (mem, 0);\n+  gcc_assert (register_operand (addr, DImode));\n \n-  /* Align it to a multiple of 8.  */\n   align = expand_simple_binop (Pmode, AND, addr, GEN_INT (-8),\n \t\t\t       NULL_RTX, 1, OPTAB_DIRECT);\n \n   /* Insert val into the correct byte location within the word.  */\n-  val = emit_insxl (mode, val, addr);\n+  if (val != const0_rtx)\n+    val = emit_insxl (mode, val, addr);\n \n   wdst = gen_reg_rtx (DImode);\n   if (mode == QImode)\n-    fn4 = gen_sync_lock_test_and_setqi_1;\n+    gen = gen_atomic_exchangeqi_1;\n   else\n-    fn4 = gen_sync_lock_test_and_sethi_1;\n-  emit_insn (fn4 (wdst, addr, val, align));\n+    gen = gen_atomic_exchangehi_1;\n+  emit_insn (gen (wdst, mem, val, align, model));\n \n   emit_move_insn (dst, gen_lowpart (mode, wdst));\n }\n \n void\n-alpha_split_lock_test_and_set_12 (enum machine_mode mode, rtx dest, rtx addr,\n-\t\t\t\t  rtx val, rtx align, rtx scratch)\n+alpha_split_atomic_exchange_12 (rtx operands[])\n {\n+  rtx dest, orig_mem, addr, val, align, scratch;\n   rtx label, mem, width, mask, x;\n+  enum machine_mode mode;\n+  enum memmodel model;\n+\n+  dest = operands[0];\n+  orig_mem = operands[1];\n+  val = operands[2];\n+  align = operands[3];\n+  model = (enum memmodel) INTVAL (operands[4]);\n+  scratch = operands[5];\n+  mode = GET_MODE (orig_mem);\n+  addr = XEXP (orig_mem, 0);\n \n   mem = gen_rtx_MEM (DImode, align);\n-  MEM_VOLATILE_P (mem) = 1;\n+  MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (orig_mem);\n+\n+  alpha_pre_atomic_barrier (model);\n \n   label = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n   emit_label (XEXP (label, 0));\n@@ -4444,14 +4595,15 @@ alpha_split_lock_test_and_set_12 (enum machine_mode mode, rtx dest, rtx addr,\n   mask = GEN_INT (mode == QImode ? 0xff : 0xffff);\n   emit_insn (gen_extxl (dest, scratch, width, addr));\n   emit_insn (gen_mskxl (scratch, scratch, mask, addr));\n-  emit_insn (gen_iordi3 (scratch, scratch, val));\n+  if (val != const0_rtx)\n+    emit_insn (gen_iordi3 (scratch, scratch, val));\n \n   emit_store_conditional (DImode, scratch, mem, scratch);\n \n   x = gen_rtx_EQ (DImode, scratch, const0_rtx);\n   emit_unlikely_jump (x, label);\n \n-  emit_insn (gen_memory_barrier ());\n+  alpha_post_atomic_barrier (model);\n }\n \f\n /* Adjust the cost of a scheduling dependency.  Return the new cost of"}, {"sha": "e715cc86422c8c29f2d11ae29735b980857f1896", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=2371d1a0a11fc85360f93a732b2794dffd7d92fe", "patch": "@@ -81,6 +81,7 @@\n   UNSPECV_SETJMPR_ER\t; builtin_setjmp_receiver fragment\n   UNSPECV_LL\t\t; load-locked\n   UNSPECV_SC\t\t; store-conditional\n+  UNSPECV_CMPXCHG\n ])\n \n ;; On non-BWX targets, CQImode must be handled the similarly to HImode"}, {"sha": "62c7f9ae0c572490e1f21ac92fbabb5cca0af6da", "filename": "gcc/config/alpha/constraints.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fconstraints.md?ref=2371d1a0a11fc85360f93a732b2794dffd7d92fe", "patch": "@@ -19,7 +19,7 @@\n \n ;;; Unused letters:\n ;;;    ABCDEF               V  YZ\n-;;;       de ghijklmnopq stu wxyz\n+;;;       de ghijkl   pq  tu wxyz\n \n ;; Integer register constraints.\n \n@@ -38,6 +38,10 @@\n (define_register_constraint \"v\" \"R0_REG\"\n  \"General register 0, function value return address\")\n \n+(define_memory_constraint \"w\"\n+ \"A memory whose address is only a register\"\n+ (match_operand 0 \"mem_noofs_operand\"))\n+\n ;; Integer constant constraints.\n (define_constraint \"I\"\n   \"An unsigned 8 bit constant\""}, {"sha": "598742f81e7a652252c0820708d9dd1e514f2d3e", "filename": "gcc/config/alpha/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fpredicates.md?ref=2371d1a0a11fc85360f93a732b2794dffd7d92fe", "patch": "@@ -623,3 +623,8 @@\n   (ior (match_operand 0 \"register_operand\")\n        (and (match_test \"TARGET_BWX\")\n \t    (match_operand 0 \"memory_operand\"))))\n+\n+;; Accept a memory whose address is only a register.\n+(define_predicate \"mem_noofs_operand\"\n+  (and (match_code \"mem\")\n+       (match_code \"reg\" \"0\")))"}, {"sha": "90f6c5cd8d4c7513545107f1f03e561ec54faa7d", "filename": "gcc/config/alpha/sync.md", "status": "modified", "additions": 173, "deletions": 138, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2371d1a0a11fc85360f93a732b2794dffd7d92fe/gcc%2Fconfig%2Falpha%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fsync.md?ref=2371d1a0a11fc85360f93a732b2794dffd7d92fe", "patch": "@@ -1,5 +1,5 @@\n ;; GCC machine description for Alpha synchronization instructions.\n-;; Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.\n+;; Copyright (C) 2005, 2007, 2008, 2009, 2011 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -62,247 +62,282 @@\n   [(set_attr \"type\" \"st_c\")])\n \n ;; The Alpha Architecture Handbook says that it is UNPREDICTABLE whether\n-;; the lock is cleared by a TAKEN branch.  This means that we can not\n-;; expand a ll/sc sequence until after the final basic-block reordering pass.\n+;; the lock is cleared by a normal load or store.  This means we cannot\n+;; expand a ll/sc sequence before reload, lest a register spill is\n+;; inserted inside the sequence.  It is also UNPREDICTABLE whether the\n+;; lock is cleared by a TAKEN branch.  This means that we can not expand\n+;; a ll/sc sequence containing a branch (i.e. compare-and-swap) until after\n+;; the final basic-block reordering pass.\n \n-(define_insn_and_split \"sync_<fetchop_name><mode>\"\n-  [(set (match_operand:I48MODE 0 \"memory_operand\" \"+m\")\n-\t(unspec:I48MODE\n-\t  [(FETCHOP:I48MODE (match_dup 0)\n-\t     (match_operand:I48MODE 1 \"<fetchop_pred>\" \"<fetchop_constr>\"))]\n-\t  UNSPEC_ATOMIC))\n-   (clobber (match_scratch:I48MODE 2 \"=&r\"))]\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(parallel\n+     [(set (match_operand:DI 0 \"register_operand\" \"\")\t\t  ;; bool out\n+\t   (unspec_volatile:DI [(const_int 0)] UNSPECV_CMPXCHG))\n+      (set (match_operand:I48MODE 1 \"register_operand\" \"\")\t  ;; val out\n+\t   (unspec_volatile:I48MODE [(const_int 0)] UNSPECV_CMPXCHG))\n+      (set (match_operand:I48MODE 2 \"memory_operand\" \"\")\t  ;; memory\n+\t   (unspec_volatile:I48MODE\n+\t     [(match_dup 2)\n+\t      (match_operand:I48MODE 3 \"reg_or_8bit_operand\" \"\")  ;; expected\n+\t      (match_operand:I48MODE 4 \"add_operand\" \"\")\t  ;; desired\n+\t      (match_operand:SI 5 \"const_int_operand\" \"\")\t  ;; is_weak\n+\t      (match_operand:SI 6 \"const_int_operand\" \"\")\t  ;; succ model\n+\t      (match_operand:SI 7 \"const_int_operand\" \"\")]\t  ;; fail model\n+\t     UNSPECV_CMPXCHG))])]\n+  \"\"\n+{\n+  if (<MODE>mode == SImode)\n+    {\n+      operands[3] = convert_modes (DImode, SImode, operands[3], 0);\n+      operands[4] = convert_modes (DImode, SImode, operands[4], 0);\n+    }\n+})\n+\n+(define_insn_and_split \"*atomic_compare_and_swap<mode>\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\t\t;; bool out\n+\t(unspec_volatile:DI [(const_int 0)] UNSPECV_CMPXCHG))\n+   (set (match_operand:I48MODE 1 \"register_operand\" \"=&r\")\t;; val out\n+\t(unspec_volatile:I48MODE [(const_int 0)] UNSPECV_CMPXCHG))\n+   (set (match_operand:I48MODE 2 \"memory_operand\" \"+m\")\t\t;; memory\n+\t(unspec_volatile:I48MODE\n+\t  [(match_dup 2)\n+\t   (match_operand:DI 3 \"reg_or_8bit_operand\" \"rI\")\t;; expected\n+\t   (match_operand:DI 4 \"add_operand\" \"rKL\")\t\t;; desired\n+\t   (match_operand:SI 5 \"const_int_operand\" \"\")\t\t;; is_weak\n+\t   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; succ model\n+\t   (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t;; fail model\n+\t  UNSPECV_CMPXCHG))]\n   \"\"\n   \"#\"\n   \"epilogue_completed\"\n   [(const_int 0)]\n {\n-  alpha_split_atomic_op (<CODE>, operands[0], operands[1],\n-\t\t\t NULL, NULL, operands[2]);\n+  alpha_split_compare_and_swap (operands);\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])\n \n-(define_insn_and_split \"sync_nand<mode>\"\n-  [(set (match_operand:I48MODE 0 \"memory_operand\" \"+m\")\n-\t(unspec:I48MODE\n-\t  [(not:I48MODE\n-\t     (and:I48MODE (match_dup 0)\n-\t       (match_operand:I48MODE 1 \"register_operand\" \"r\")))]\n-\t  UNSPEC_ATOMIC))\n-   (clobber (match_scratch:I48MODE 2 \"=&r\"))]\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\t\t\t;; bool out\n+   (match_operand:I12MODE 1 \"register_operand\" \"\")\t\t;; val out\n+   (match_operand:I12MODE 2 \"mem_noofs_operand\" \"\")\t\t;; memory\n+   (match_operand:I12MODE 3 \"register_operand\" \"\")\t\t;; expected\n+   (match_operand:I12MODE 4 \"add_operand\" \"\")\t\t\t;; desired\n+   (match_operand:SI 5 \"const_int_operand\" \"\")\t\t\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t\t;; succ model\n+   (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t\t;; fail model\n+  \"\"\n+{\n+  alpha_expand_compare_and_swap_12 (operands);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"atomic_compare_and_swap<mode>_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\t\t;; bool out\n+\t(unspec_volatile:DI [(const_int 0)] UNSPECV_CMPXCHG))\n+   (set (match_operand:DI 1 \"register_operand\" \"=&r\")\t\t;; val out\n+\t(zero_extend:DI\n+\t  (unspec_volatile:I12MODE [(const_int 0)] UNSPECV_CMPXCHG)))\n+   (set (match_operand:I12MODE 2 \"mem_noofs_operand\" \"+w\")\t;; memory\n+\t(unspec_volatile:I12MODE\n+\t  [(match_dup 2)\n+\t   (match_operand:DI 3 \"reg_or_8bit_operand\" \"rI\")\t;; expected\n+\t   (match_operand:DI 4 \"reg_or_0_operand\" \"rJ\")\t\t;; desired\n+\t   (match_operand:DI 5 \"register_operand\" \"r\")\t\t;; align\n+\t   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; is_weak\n+\t   (match_operand:SI 7 \"const_int_operand\" \"\")\t\t;; succ model\n+\t   (match_operand:SI 8 \"const_int_operand\" \"\")]\t\t;; fail model\n+\t  UNSPECV_CMPXCHG))\n+   (clobber (match_scratch:DI 9 \"=&r\"))]\n   \"\"\n   \"#\"\n   \"epilogue_completed\"\n   [(const_int 0)]\n {\n-  alpha_split_atomic_op (NOT, operands[0], operands[1],\n-\t\t\t NULL, NULL, operands[2]);\n+  alpha_split_compare_and_swap_12 (operands);\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])\n \n-(define_insn_and_split \"sync_old_<fetchop_name><mode>\"\n-  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n-\t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n+(define_insn_and_split \"atomic_exchange<mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\t;; output\n+\t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\t;; memory\n    (set (match_dup 1)\n \t(unspec:I48MODE\n-\t  [(FETCHOP:I48MODE (match_dup 1)\n-\t     (match_operand:I48MODE 2 \"<fetchop_pred>\" \"<fetchop_constr>\"))]\n-\t  UNSPEC_ATOMIC))\n-   (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n+\t  [(match_operand:I48MODE 2 \"add_operand\" \"rKL\")\t;; input\n+\t   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n+\t  UNSPEC_XCHG))\n+   (clobber (match_scratch:I48MODE 4 \"=&r\"))]\n   \"\"\n   \"#\"\n   \"epilogue_completed\"\n   [(const_int 0)]\n {\n-  alpha_split_atomic_op (<CODE>, operands[1], operands[2],\n-\t\t\t operands[0], NULL, operands[3]);\n+  alpha_split_atomic_exchange (operands);\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])\n \n-(define_insn_and_split \"sync_old_nand<mode>\"\n-  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n-\t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n+(define_expand \"atomic_exchange<mode>\"\n+  [(match_operand:I12MODE 0 \"register_operand\" \"\")\t\t;; output\n+   (match_operand:I12MODE 1 \"mem_noofs_operand\" \"\")\t\t;; memory\n+   (match_operand:I12MODE 2 \"reg_or_0_operand\" \"\")\t\t;; input\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t\t;; model\n+  \"\"\n+{\n+  alpha_expand_atomic_exchange_12 (operands);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"atomic_exchange<mode>_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\t\t;; output\n+\t(zero_extend:DI\n+\t  (match_operand:I12MODE 1 \"mem_noofs_operand\" \"+w\")))\t;; memory\n    (set (match_dup 1)\n-\t(unspec:I48MODE\n-\t  [(not:I48MODE\n-\t     (and:I48MODE (match_dup 1)\n-\t       (match_operand:I48MODE 2 \"register_operand\" \"r\")))]\n-\t  UNSPEC_ATOMIC))\n-   (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n+\t(unspec:I12MODE\n+\t  [(match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\t;; input\n+\t   (match_operand:DI 3 \"register_operand\" \"r\")\t\t;; align\n+\t   (match_operand:SI 4 \"const_int_operand\" \"\")]\t\t;; model\n+\t  UNSPEC_XCHG))\n+   (clobber (match_scratch:DI 5 \"=&r\"))]\n   \"\"\n   \"#\"\n   \"epilogue_completed\"\n   [(const_int 0)]\n {\n-  alpha_split_atomic_op (NOT, operands[1], operands[2],\n-\t\t\t operands[0], NULL, operands[3]);\n+  alpha_split_atomic_exchange_12 (operands);\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])\n \n-(define_insn_and_split \"sync_new_<fetchop_name><mode>\"\n-  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n-\t(FETCHOP:I48MODE \n-\t  (match_operand:I48MODE 1 \"memory_operand\" \"+m\")\n-\t  (match_operand:I48MODE 2 \"<fetchop_pred>\" \"<fetchop_constr>\")))\n-   (set (match_dup 1)\n+(define_insn_and_split \"atomic_<fetchop_name><mode>\"\n+  [(set (match_operand:I48MODE 0 \"memory_operand\" \"+m\")\n \t(unspec:I48MODE\n-\t  [(FETCHOP:I48MODE (match_dup 1) (match_dup 2))]\n+\t  [(FETCHOP:I48MODE (match_dup 0)\n+\t     (match_operand:I48MODE 1 \"<fetchop_pred>\" \"<fetchop_constr>\"))\n+\t   (match_operand:SI 2 \"const_int_operand\" \"\")]\n \t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n   \"\"\n   \"#\"\n   \"epilogue_completed\"\n   [(const_int 0)]\n {\n-  alpha_split_atomic_op (<CODE>, operands[1], operands[2],\n-\t\t\t NULL, operands[0], operands[3]);\n+  alpha_split_atomic_op (<CODE>, operands[0], operands[1],\n+\t\t\t NULL, NULL, operands[3],\n+\t\t\t (enum memmodel) INTVAL (operands[2]));\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])\n \n-(define_insn_and_split \"sync_new_nand<mode>\"\n-  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n-\t(not:I48MODE\n-\t  (and:I48MODE (match_operand:I48MODE 1 \"memory_operand\" \"+m\")\n-\t    (match_operand:I48MODE 2 \"register_operand\" \"r\"))))\n-   (set (match_dup 1)\n+(define_insn_and_split \"atomic_nand<mode>\"\n+  [(set (match_operand:I48MODE 0 \"memory_operand\" \"+m\")\n \t(unspec:I48MODE\n-\t  [(not:I48MODE (and:I48MODE (match_dup 1) (match_dup 2)))]\n+\t  [(not:I48MODE\n+\t     (and:I48MODE (match_dup 0)\n+\t       (match_operand:I48MODE 1 \"register_operand\" \"r\")))\n+\t   (match_operand:SI 2 \"const_int_operand\" \"\")]\n \t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n   \"\"\n   \"#\"\n   \"epilogue_completed\"\n   [(const_int 0)]\n {\n-  alpha_split_atomic_op (NOT, operands[1], operands[2],\n-\t\t\t NULL, operands[0], operands[3]);\n+  alpha_split_atomic_op (NOT, operands[0], operands[1],\n+\t\t\t NULL, NULL, operands[3],\n+\t\t\t (enum memmodel) INTVAL (operands[2]));\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])\n \n-(define_expand \"sync_compare_and_swap<mode>\"\n-  [(match_operand:I12MODE 0 \"register_operand\" \"\")\n-   (match_operand:I12MODE 1 \"memory_operand\" \"\")\n-   (match_operand:I12MODE 2 \"register_operand\" \"\")\n-   (match_operand:I12MODE 3 \"add_operand\" \"\")]\n-  \"\"\n-{\n-  alpha_expand_compare_and_swap_12 (operands[0], operands[1],\n-\t\t\t\t    operands[2], operands[3]);\n-  DONE;\n-})\n-\n-(define_insn_and_split \"sync_compare_and_swap<mode>_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r,&r\")\n-\t(zero_extend:DI\n-\t  (mem:I12MODE (match_operand:DI 1 \"register_operand\" \"r,r\"))))\n-   (set (mem:I12MODE (match_dup 1))\n-\t(unspec:I12MODE\n-\t  [(match_operand:DI 2 \"reg_or_8bit_operand\" \"J,rI\")\n-\t   (match_operand:DI 3 \"register_operand\" \"r,r\")\n-\t   (match_operand:DI 4 \"register_operand\" \"r,r\")]\n-\t  UNSPEC_CMPXCHG))\n-   (clobber (match_scratch:DI 5 \"=&r,&r\"))\n-   (clobber (match_scratch:DI 6 \"=X,&r\"))]\n+(define_insn_and_split \"atomic_fetch_<fetchop_name><mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n+\t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n+   (set (match_dup 1)\n+\t(unspec:I48MODE\n+\t  [(FETCHOP:I48MODE (match_dup 1)\n+\t     (match_operand:I48MODE 2 \"<fetchop_pred>\" \"<fetchop_constr>\"))\n+\t   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:I48MODE 4 \"=&r\"))]\n   \"\"\n   \"#\"\n   \"epilogue_completed\"\n   [(const_int 0)]\n {\n-  alpha_split_compare_and_swap_12 (<MODE>mode, operands[0], operands[1],\n-\t\t\t\t   operands[2], operands[3], operands[4],\n-\t\t\t\t   operands[5], operands[6]);\n+  alpha_split_atomic_op (<CODE>, operands[1], operands[2],\n+\t\t\t operands[0], NULL, operands[4],\n+\t\t\t (enum memmodel) INTVAL (operands[3]));\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])\n \n-(define_expand \"sync_compare_and_swap<mode>\"\n-  [(parallel\n-     [(set (match_operand:I48MODE 0 \"register_operand\" \"\")\n-\t   (match_operand:I48MODE 1 \"memory_operand\" \"\"))\n-      (set (match_dup 1)\n-\t   (unspec:I48MODE\n-\t     [(match_operand:I48MODE 2 \"reg_or_8bit_operand\" \"\")\n-\t      (match_operand:I48MODE 3 \"add_operand\" \"rKL\")]\n-\t     UNSPEC_CMPXCHG))\n-      (clobber (match_scratch:I48MODE 4 \"=&r\"))])]\n-  \"\"\n-{\n-  if (<MODE>mode == SImode)\n-    operands[2] = convert_modes (DImode, SImode, operands[2], 0);\n-})\n-\n-(define_insn_and_split \"*sync_compare_and_swap<mode>\"\n+(define_insn_and_split \"atomic_fetch_nand<mode>\"\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n \t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n    (set (match_dup 1)\n \t(unspec:I48MODE\n-\t  [(match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n-\t   (match_operand:I48MODE 3 \"add_operand\" \"rKL\")]\n-\t  UNSPEC_CMPXCHG))\n+\t  [(not:I48MODE\n+\t     (and:I48MODE (match_dup 1)\n+\t       (match_operand:I48MODE 2 \"register_operand\" \"r\")))\n+\t   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+\t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:I48MODE 4 \"=&r\"))]\n   \"\"\n   \"#\"\n   \"epilogue_completed\"\n   [(const_int 0)]\n {\n-  alpha_split_compare_and_swap (operands[0], operands[1], operands[2],\n-\t\t\t\toperands[3], operands[4]);\n+  alpha_split_atomic_op (NOT, operands[1], operands[2],\n+\t\t\t operands[0], NULL, operands[4],\n+\t\t\t (enum memmodel) INTVAL (operands[3]));\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])\n \n-(define_expand \"sync_lock_test_and_set<mode>\"\n-  [(match_operand:I12MODE 0 \"register_operand\" \"\")\n-   (match_operand:I12MODE 1 \"memory_operand\" \"\")\n-   (match_operand:I12MODE 2 \"register_operand\" \"\")]\n-  \"\"\n-{\n-  alpha_expand_lock_test_and_set_12 (operands[0], operands[1], operands[2]);\n-  DONE;\n-})\n-\n-(define_insn_and_split \"sync_lock_test_and_set<mode>_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-\t(zero_extend:DI\n-\t  (mem:I12MODE (match_operand:DI 1 \"register_operand\" \"r\"))))\n-   (set (mem:I12MODE (match_dup 1))\n-\t(unspec:I12MODE\n-\t  [(match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n-\t   (match_operand:DI 3 \"register_operand\" \"r\")]\n-\t  UNSPEC_XCHG))\n-   (clobber (match_scratch:DI 4 \"=&r\"))]\n+(define_insn_and_split \"atomic_<fetchop_name>_fetch<mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n+\t(FETCHOP:I48MODE \n+\t  (match_operand:I48MODE 1 \"memory_operand\" \"+m\")\n+\t  (match_operand:I48MODE 2 \"<fetchop_pred>\" \"<fetchop_constr>\")))\n+   (set (match_dup 1)\n+\t(unspec:I48MODE\n+\t  [(FETCHOP:I48MODE (match_dup 1) (match_dup 2))\n+\t   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:I48MODE 4 \"=&r\"))]\n   \"\"\n   \"#\"\n   \"epilogue_completed\"\n   [(const_int 0)]\n {\n-  alpha_split_lock_test_and_set_12 (<MODE>mode, operands[0], operands[1],\n-\t\t\t\t    operands[2], operands[3], operands[4]);\n+  alpha_split_atomic_op (<CODE>, operands[1], operands[2],\n+\t\t\t NULL, operands[0], operands[4],\n+\t\t\t (enum memmodel) INTVAL (operands[3]));\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])\n \n-(define_insn_and_split \"sync_lock_test_and_set<mode>\"\n+(define_insn_and_split \"atomic_nand_fetch<mode>\"\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n-\t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n+\t(not:I48MODE\n+\t  (and:I48MODE (match_operand:I48MODE 1 \"memory_operand\" \"+m\")\n+\t    (match_operand:I48MODE 2 \"register_operand\" \"r\"))))\n    (set (match_dup 1)\n \t(unspec:I48MODE\n-\t  [(match_operand:I48MODE 2 \"add_operand\" \"rKL\")]\n-\t  UNSPEC_XCHG))\n-   (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n+\t  [(not:I48MODE (and:I48MODE (match_dup 1) (match_dup 2)))\n+\t   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:I48MODE 4 \"=&r\"))]\n   \"\"\n   \"#\"\n   \"epilogue_completed\"\n   [(const_int 0)]\n {\n-  alpha_split_lock_test_and_set (operands[0], operands[1],\n-\t\t\t\t operands[2], operands[3]);\n+  alpha_split_atomic_op (NOT, operands[1], operands[2],\n+\t\t\t NULL, operands[0], operands[4],\n+\t\t\t (enum memmodel) INTVAL (operands[3]));\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])"}]}