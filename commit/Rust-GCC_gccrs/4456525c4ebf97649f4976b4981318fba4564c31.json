{"sha": "4456525c4ebf97649f4976b4981318fba4564c31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ1NjUyNWM0ZWJmOTc2NDlmNDk3NmI0OTgxMzE4ZmJhNDU2NGMzMQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-05-09T16:00:23Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-05-09T16:00:23Z"}, "message": "[arm] PR target/90405 fix regression for thumb1 with -mtpcs-leaf-frame\n\n-mtpcs-leaf-frame causes an APCS-style backtrace frame to be created\non the stack.  This should probably be deprecated, but it did reveal\nan issue with the patch I committed previously to improve the code\ngeneration when pushing high registers, in that\nthumb_find_work_register had a different idea as to which registers\nwere available as scratch registers.\n\nThe new code actually does a better job of finding a viable work\nregister and doesn't rely so much on assumptions about the ABI, so it\nseems better to adapt thumb_find_work_register to the new approach.\nThis way we can eliminate some rather crufty code.\n\ngcc:\n\tPR target/90405\n\t* config/arm/arm.c (callee_saved_reg_p): Move before\n\tthumb_find_work_register.\n\t(thumb1_prologue_unused_call_clobbered_lo_regs): Move before\n\tthumb_find_work_register.  Only call df_get_live_out once.\n\t(thumb1_epilogue_unused_call_clobbered_lo_regs): Likewise.\n\t(thumb_find_work_register): Use\n\tthumb1_prologue_unused_call_clobbered_lo_regs instead of ad hoc\n\talgorithms to locate a spare call clobbered reg.\n\ngcc/testsuite:\n\tPR target/90405\n\t* gcc.target/arm/pr90405.c: New test.\n\nFrom-SVN: r271036", "tree": {"sha": "8c0fb9f89d43d84ba3d5a6052ee6623895abb4d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c0fb9f89d43d84ba3d5a6052ee6623895abb4d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4456525c4ebf97649f4976b4981318fba4564c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4456525c4ebf97649f4976b4981318fba4564c31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4456525c4ebf97649f4976b4981318fba4564c31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4456525c4ebf97649f4976b4981318fba4564c31/comments", "author": null, "committer": null, "parents": [{"sha": "fd4485aa04b5db3f0fc367ce7aefc8431112e1a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd4485aa04b5db3f0fc367ce7aefc8431112e1a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd4485aa04b5db3f0fc367ce7aefc8431112e1a1"}], "stats": {"total": 122, "additions": 52, "deletions": 70}, "files": [{"sha": "b761d0a478d548d687769e7beaf1d3c858147cd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4456525c4ebf97649f4976b4981318fba4564c31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4456525c4ebf97649f4976b4981318fba4564c31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4456525c4ebf97649f4976b4981318fba4564c31", "patch": "@@ -1,3 +1,15 @@\n+2019-05-09  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/90405\n+\t* config/arm/arm.c (callee_saved_reg_p): Move before\n+\tthumb_find_work_register.\n+\t(thumb1_prologue_unused_call_clobbered_lo_regs): Move before\n+\tthumb_find_work_register.  Only call df_get_live_out once.\n+\t(thumb1_epilogue_unused_call_clobbered_lo_regs): Likewise.\n+\t(thumb_find_work_register): Use\n+\tthumb1_prologue_unused_call_clobbered_lo_regs instead of ad hoc\n+\talgorithms to locate a spare call clobbered reg.\n+\n 2019-05-09  Martin Liska  <mliska@suse.cz>\n \n \t* gimple-pretty-print.c (dump_binary_rhs): Dump MIN_EXPR"}, {"sha": "528752ab01fee74198eee7210660d5baf5ca06c0", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 40, "deletions": 70, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4456525c4ebf97649f4976b4981318fba4564c31/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4456525c4ebf97649f4976b4981318fba4564c31/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4456525c4ebf97649f4976b4981318fba4564c31", "patch": "@@ -7638,52 +7638,58 @@ legitimize_pic_address (rtx orig, machine_mode mode, rtx reg, rtx pic_reg,\n }\n \n \n+/* Whether a register is callee saved or not.  This is necessary because high\n+   registers are marked as caller saved when optimizing for size on Thumb-1\n+   targets despite being callee saved in order to avoid using them.  */\n+#define callee_saved_reg_p(reg) \\\n+  (!call_used_regs[reg] \\\n+   || (TARGET_THUMB1 && optimize_size \\\n+       && reg >= FIRST_HI_REGNUM && reg <= LAST_HI_REGNUM))\n+\n+/* Return a mask for the call-clobbered low registers that are unused\n+   at the end of the prologue.  */\n+static unsigned long\n+thumb1_prologue_unused_call_clobbered_lo_regs (void)\n+{\n+  unsigned long mask = 0;\n+  bitmap prologue_live_out = df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\n+  for (int reg = FIRST_LO_REGNUM; reg <= LAST_LO_REGNUM; reg++)\n+    if (!callee_saved_reg_p (reg) && !REGNO_REG_SET_P (prologue_live_out, reg))\n+      mask |= 1 << (reg - FIRST_LO_REGNUM);\n+  return mask;\n+}\n+\n+/* Similarly for the start of the epilogue.  */\n+static unsigned long\n+thumb1_epilogue_unused_call_clobbered_lo_regs (void)\n+{\n+  unsigned long mask = 0;\n+  bitmap epilogue_live_in = df_get_live_in (EXIT_BLOCK_PTR_FOR_FN (cfun));\n+\n+  for (int reg = FIRST_LO_REGNUM; reg <= LAST_LO_REGNUM; reg++)\n+    if (!callee_saved_reg_p (reg) && !REGNO_REG_SET_P (epilogue_live_in, reg))\n+      mask |= 1 << (reg - FIRST_LO_REGNUM);\n+  return mask;\n+}\n+\n /* Find a spare register to use during the prolog of a function.  */\n \n static int\n thumb_find_work_register (unsigned long pushed_regs_mask)\n {\n   int reg;\n \n+  unsigned long unused_regs\n+    = thumb1_prologue_unused_call_clobbered_lo_regs ();\n+\n   /* Check the argument registers first as these are call-used.  The\n      register allocation order means that sometimes r3 might be used\n      but earlier argument registers might not, so check them all.  */\n-  for (reg = LAST_ARG_REGNUM; reg >= 0; reg --)\n-    if (!df_regs_ever_live_p (reg))\n+  for (reg = LAST_LO_REGNUM; reg >= FIRST_LO_REGNUM; reg--)\n+    if (unused_regs & (1 << (reg - FIRST_LO_REGNUM)))\n       return reg;\n \n-  /* Before going on to check the call-saved registers we can try a couple\n-     more ways of deducing that r3 is available.  The first is when we are\n-     pushing anonymous arguments onto the stack and we have less than 4\n-     registers worth of fixed arguments(*).  In this case r3 will be part of\n-     the variable argument list and so we can be sure that it will be\n-     pushed right at the start of the function.  Hence it will be available\n-     for the rest of the prologue.\n-     (*): ie crtl->args.pretend_args_size is greater than 0.  */\n-  if (cfun->machine->uses_anonymous_args\n-      && crtl->args.pretend_args_size > 0)\n-    return LAST_ARG_REGNUM;\n-\n-  /* The other case is when we have fixed arguments but less than 4 registers\n-     worth.  In this case r3 might be used in the body of the function, but\n-     it is not being used to convey an argument into the function.  In theory\n-     we could just check crtl->args.size to see how many bytes are\n-     being passed in argument registers, but it seems that it is unreliable.\n-     Sometimes it will have the value 0 when in fact arguments are being\n-     passed.  (See testcase execute/20021111-1.c for an example).  So we also\n-     check the args_info.nregs field as well.  The problem with this field is\n-     that it makes no allowances for arguments that are passed to the\n-     function but which are not used.  Hence we could miss an opportunity\n-     when a function has an unused argument in r3.  But it is better to be\n-     safe than to be sorry.  */\n-  if (! cfun->machine->uses_anonymous_args\n-      && crtl->args.size >= 0\n-      && crtl->args.size <= (LAST_ARG_REGNUM * UNITS_PER_WORD)\n-      && (TARGET_AAPCS_BASED\n-\t  ? crtl->args.info.aapcs_ncrn < 4\n-\t  : crtl->args.info.nregs < 4))\n-    return LAST_ARG_REGNUM;\n-\n   /* Otherwise look for a call-saved register that is going to be pushed.  */\n   for (reg = LAST_LO_REGNUM; reg > LAST_ARG_REGNUM; reg --)\n     if (pushed_regs_mask & (1 << reg))\n@@ -19441,13 +19447,6 @@ output_ascii_pseudo_op (FILE *stream, const unsigned char *p, int len)\n   fputs (\"\\\"\\n\", stream);\n }\n \f\n-/* Whether a register is callee saved or not.  This is necessary because high\n-   registers are marked as caller saved when optimizing for size on Thumb-1\n-   targets despite being callee saved in order to avoid using them.  */\n-#define callee_saved_reg_p(reg) \\\n-  (!call_used_regs[reg] \\\n-   || (TARGET_THUMB1 && optimize_size \\\n-       && reg >= FIRST_HI_REGNUM && reg <= LAST_HI_REGNUM))\n \n /* Compute the register save mask for registers 0 through 12\n    inclusive.  This code is used by arm_compute_save_core_reg_mask ().  */\n@@ -19670,35 +19669,6 @@ arm_compute_save_core_reg_mask (void)\n   return save_reg_mask;\n }\n \n-/* Return a mask for the call-clobbered low registers that are unused\n-   at the end of the prologue.  */\n-static unsigned long\n-thumb1_prologue_unused_call_clobbered_lo_regs (void)\n-{\n-  unsigned long mask = 0;\n-\n-  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)\n-    if (!callee_saved_reg_p (reg)\n-\t&& !REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n-\t\t\t     reg))\n-      mask |= 1 << reg;\n-  return mask;\n-}\n-\n-/* Similarly for the start of the epilogue.  */\n-static unsigned long\n-thumb1_epilogue_unused_call_clobbered_lo_regs (void)\n-{\n-  unsigned long mask = 0;\n-\n-  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)\n-    if (!callee_saved_reg_p (reg)\n-\t&& !REGNO_REG_SET_P (df_get_live_in (EXIT_BLOCK_PTR_FOR_FN (cfun)),\n-\t\t\t     reg))\n-      mask |= 1 << reg;\n-  return mask;\n-}\n-\n /* Compute a bit mask of which core registers need to be\n    saved on the stack for the current function.  */\n static unsigned long"}]}