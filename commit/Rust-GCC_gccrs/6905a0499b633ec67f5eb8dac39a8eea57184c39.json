{"sha": "6905a0499b633ec67f5eb8dac39a8eea57184c39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkwNWEwNDk5YjYzM2VjNjdmNWViOGRhYzM5YThlZWE1NzE4NGMzOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-20T10:56:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-20T10:56:12Z"}, "message": "[multiple changes]\n\n2016-04-20  Bob Duff  <duff@adacore.com>\n\n\t* s-os_lib.ads: Minor comment fix.\n\n2016-04-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): Do no generate\n\ta discriminant check for a type whose partial view has unknown\n\tdiscriminants when the full view has discriminants with defaults.\n\n2016-04-20  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_util.adb (Remove_Side_Effects): When generating C code\n\tremove side effect of type conversion of access to unconstrained\n\tarray type.\n\t(Side_Effect_Free): Return false for the type\n\tconversion of access to unconstrained array type when generating\n\tC code.\n\t* sem_res.adb (Resolved_Type_Conversion): Remove side effects\n\tof access to unconstrained array type conversion when generating\n\tC code.\n\n2016-04-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Build_Predicate_Function_Declaration): New\n\tfunction, to construct the declaration of a predicate function\n\tat the end of the current declarative part rather than at the\n\t(possibly later) freeze point of the type. This also allows uses\n\tof a type with predicates in instantiations elsewhere.\n\t(Resolve_Aspect_Expression): New procedure to detect visiblity\n\terrors in aspect expressions, at the end of the declarative part\n\tthat includes the type declaration.\n\t* sem_ch3.adb (Complete_Private_Subtype): Propagate properly the\n\tpredicate function from private to full view.\n\t* einfo.adb (Predicate_Function): Refine search for predicate\n\tfunction when type has a full view and predicate function may\n\tbe defined on either view.\n\n2016-04-20  Javier Miranda  <miranda@adacore.com>\n\n\t* frontend.adb: Passing the root of the tree to\n\tUnnest_Subprograms().\n\t* exp_ch6.adb (Expand_N_Subprogram_Body): Remove code that\n\ttook care of adding subprograms to the Unest_Bodies table since\n\tperforming such action too early disables the ability to process\n\tgeneric instantiations.\n\t(Unnest_Subprograms): Adding parameter.\n\t(Search_Unnesting_Subprograms): New subprogram.\n\t* exp_ch6.ads (Unnest_Subrograms): Update documentation.\n\nFrom-SVN: r235268", "tree": {"sha": "70b87b3bd9e50f2897bebe4996c3d9792d2a9b4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70b87b3bd9e50f2897bebe4996c3d9792d2a9b4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6905a0499b633ec67f5eb8dac39a8eea57184c39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6905a0499b633ec67f5eb8dac39a8eea57184c39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6905a0499b633ec67f5eb8dac39a8eea57184c39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6905a0499b633ec67f5eb8dac39a8eea57184c39/comments", "author": null, "committer": null, "parents": [{"sha": "268aeaa9023ec4e0d7770cbe1b9b4fd99374c2fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268aeaa9023ec4e0d7770cbe1b9b4fd99374c2fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/268aeaa9023ec4e0d7770cbe1b9b4fd99374c2fa"}], "stats": {"total": 438, "additions": 354, "deletions": 84}, "files": [{"sha": "17e8bdac36b82ce654fd3023407fc5d6389cddbb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6905a0499b633ec67f5eb8dac39a8eea57184c39", "patch": "@@ -1,3 +1,53 @@\n+2016-04-20  Bob Duff  <duff@adacore.com>\n+\n+\t* s-os_lib.ads: Minor comment fix.\n+\n+2016-04-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement): Do no generate\n+\ta discriminant check for a type whose partial view has unknown\n+\tdiscriminants when the full view has discriminants with defaults.\n+\n+2016-04-20  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_util.adb (Remove_Side_Effects): When generating C code\n+\tremove side effect of type conversion of access to unconstrained\n+\tarray type.\n+\t(Side_Effect_Free): Return false for the type\n+\tconversion of access to unconstrained array type when generating\n+\tC code.\n+\t* sem_res.adb (Resolved_Type_Conversion): Remove side effects\n+\tof access to unconstrained array type conversion when generating\n+\tC code.\n+\n+2016-04-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Build_Predicate_Function_Declaration): New\n+\tfunction, to construct the declaration of a predicate function\n+\tat the end of the current declarative part rather than at the\n+\t(possibly later) freeze point of the type. This also allows uses\n+\tof a type with predicates in instantiations elsewhere.\n+\t(Resolve_Aspect_Expression): New procedure to detect visiblity\n+\terrors in aspect expressions, at the end of the declarative part\n+\tthat includes the type declaration.\n+\t* sem_ch3.adb (Complete_Private_Subtype): Propagate properly the\n+\tpredicate function from private to full view.\n+\t* einfo.adb (Predicate_Function): Refine search for predicate\n+\tfunction when type has a full view and predicate function may\n+\tbe defined on either view.\n+\n+2016-04-20  Javier Miranda  <miranda@adacore.com>\n+\n+\t* frontend.adb: Passing the root of the tree to\n+\tUnnest_Subprograms().\n+\t* exp_ch6.adb (Expand_N_Subprogram_Body): Remove code that\n+\ttook care of adding subprograms to the Unest_Bodies table since\n+\tperforming such action too early disables the ability to process\n+\tgeneric instantiations.\n+\t(Unnest_Subprograms): Adding parameter.\n+\t(Search_Unnesting_Subprograms): New subprogram.\n+\t* exp_ch6.ads (Unnest_Subrograms): Update documentation.\n+\n 2016-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_util.adb, freeze.adb, sem_util.adb: Minor reformatting."}, {"sha": "9f1f3a9fe32681dc926d82cd24ccca92c468d698", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=6905a0499b633ec67f5eb8dac39a8eea57184c39", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -8213,8 +8213,13 @@ package body Einfo is\n       --  If type is private and has a completion, predicate may be defined\n       --  on the full view.\n \n-      if Is_Private_Type (Id) and then Present (Full_View (Id)) then\n+      if Is_Private_Type (Id)\n+         and then\n+           (not Has_Predicates (Id) or else No (Subprograms_For_Type (Id)))\n+         and then Present (Full_View (Id))\n+      then\n          T := Full_View (Id);\n+\n       else\n          T := Id;\n       end if;"}, {"sha": "139f5ca3ae24a6c539289997e098bf0e140e34ad", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=6905a0499b633ec67f5eb8dac39a8eea57184c39", "patch": "@@ -1946,10 +1946,12 @@ package body Exp_Ch5 is\n       --  have a full view with discriminants, but those are nameable only\n       --  in the underlying type, so convert the Rhs to it before potential\n       --  checking. Convert Lhs as well, otherwise the actual subtype might\n-      --  not be constructible.\n+      --  not be constructible. If the discriminants have defaults the type\n+      --  is unconstrained and there is nothing to check.\n \n       elsif Has_Unknown_Discriminants (Base_Type (Etype (Lhs)))\n         and then Has_Discriminants (Typ)\n+        and then not Has_Defaulted_Discriminants (Typ)\n       then\n          Rewrite (Rhs, OK_Convert_To (Base_Type (Typ), Rhs));\n          Rewrite (Lhs, OK_Convert_To (Base_Type (Typ), Lhs));"}, {"sha": "876aca98fd95efa7fd8f5fc3b1d5ad8e7c6b9a6a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 68, "deletions": 24, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6905a0499b633ec67f5eb8dac39a8eea57184c39", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -5491,28 +5491,6 @@ package body Exp_Ch6 is\n \n       Qualify_Entity_Names (N);\n \n-      --  If we are unnesting procedures, and this is an outer level procedure\n-      --  with nested subprograms, do the unnesting operation now.\n-\n-      if Opt.Unnest_Subprogram_Mode\n-\n-        --  We are only interested in subprograms (not generic subprograms)\n-\n-        and then Is_Subprogram (Spec_Id)\n-\n-        --  Only deal with outer level subprograms. Nested subprograms are\n-        --  handled as part of dealing with the outer level subprogram in\n-        --  which they are nested.\n-\n-        and then Enclosing_Subprogram (Spec_Id) = Empty\n-\n-        --  We are only interested in subprograms that have nested subprograms\n-\n-        and then Has_Nested_Subprogram (Spec_Id)\n-      then\n-         Unest_Bodies.Append ((Spec_Id, N));\n-      end if;\n-\n       Ghost_Mode := Save_Ghost_Mode;\n    end Expand_N_Subprogram_Body;\n \n@@ -8497,8 +8475,74 @@ package body Exp_Ch6 is\n    -- Unnest_Subprograms --\n    ------------------------\n \n-   procedure Unnest_Subprograms is\n+   procedure Unnest_Subprograms (N : Node_Id) is\n+\n+      procedure Search_Unnesting_Subprograms (N : Node_Id);\n+      --  Search for outer level procedures with nested subprograms and append\n+      --  them to the Unnest table.\n+\n+      ----------------------------------\n+      -- Search_Unnesting_Subprograms --\n+      ----------------------------------\n+\n+      procedure Search_Unnesting_Subprograms (N : Node_Id) is\n+\n+         function Search_Subprograms (N : Node_Id) return Traverse_Result;\n+         --  Tree visitor that search for outer level procedures with nested\n+         --  subprograms and adds them to the Unnest table.\n+\n+         ------------------------\n+         -- Search_Subprograms --\n+         ------------------------\n+\n+         function Search_Subprograms (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind_In (N, N_Subprogram_Body,\n+                            N_Subprogram_Body_Stub)\n+            then\n+               declare\n+                  Spec_Id : constant Entity_Id := Unique_Defining_Entity (N);\n+\n+               begin\n+                  --  We are only interested in subprograms (not generic\n+                  --  subprograms), that have nested subprograms.\n+\n+                  if Is_Subprogram (Spec_Id)\n+                    and then Has_Nested_Subprogram (Spec_Id)\n+                    and then Is_Library_Level_Entity (Spec_Id)\n+                  then\n+                     Unest_Bodies.Append ((Spec_Id, N));\n+                  end if;\n+               end;\n+            end if;\n+\n+            return OK;\n+         end Search_Subprograms;\n+\n+         ---------------\n+         -- Do_Search --\n+         ---------------\n+\n+         procedure Do_Search is new Traverse_Proc (Search_Subprograms);\n+         --  Subtree visitor instantiation\n+\n+      --  Start of processing for Search_Unnesting_Subprograms\n+\n+      begin\n+         if Opt.Unnest_Subprogram_Mode then\n+            Do_Search (N);\n+         end if;\n+      end Search_Unnesting_Subprograms;\n+\n+   --  Start of processing for Unnest_Subprograms\n+\n    begin\n+      if not Opt.Unnest_Subprogram_Mode then\n+         return;\n+      end if;\n+\n+      Search_Unnesting_Subprograms (N);\n+\n       for J in Unest_Bodies.First .. Unest_Bodies.Last loop\n          declare\n             UBJ : Unest_Entry renames Unest_Bodies.Table (J);"}, {"sha": "551cb1e6af1b71e4dea711767b0b7cd477dd7d4a", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=6905a0499b633ec67f5eb8dac39a8eea57184c39", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -212,9 +212,9 @@ package Exp_Ch6 is\n    --  parameter to identify the accessibility level of the function result\n    --  \"determined by the point of call\".\n \n-   procedure Unnest_Subprograms;\n-   --  Called to unnest subprograms. If we are in unnest subprogram mode, and\n-   --  subprograms have been gathered in the Unest_Bodies table, this is the\n-   --  call that causes them to be processed for unnesting.\n+   procedure Unnest_Subprograms (N : Node_Id);\n+   --  Called to unnest subprograms. If we are in unnest subprogram mode, this\n+   --  is the call that traverses the tree N and locates all the library level\n+   --  subprograms with nested subprograms to process them.\n \n end Exp_Ch6;"}, {"sha": "4b0f1f8fd9a2169a7ec8ad7ed34d680d2a403c84", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=6905a0499b633ec67f5eb8dac39a8eea57184c39", "patch": "@@ -7800,7 +7800,30 @@ package body Exp_Util is\n \n       elsif Nkind (Exp) = N_Type_Conversion then\n          Remove_Side_Effects (Expression (Exp), Name_Req, Variable_Ref);\n-         goto Leave;\n+\n+         --  Generating C code the type conversion of an access to constrained\n+         --  array type into an access to unconstrained array type involves\n+         --  initializing a fat pointer and the expression must be free of\n+         --  side effects to safely compute its bounds.\n+\n+         if Generate_C_Code\n+           and then Is_Access_Type (Etype (Exp))\n+           and then Is_Array_Type (Designated_Type (Etype (Exp)))\n+           and then not Is_Constrained (Designated_Type (Etype (Exp)))\n+         then\n+            Def_Id := Build_Temporary (Loc, 'R', Exp);\n+            Set_Etype (Def_Id, Exp_Type);\n+            Res := New_Occurrence_Of (Def_Id, Loc);\n+\n+            Insert_Action (Exp,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Def_Id,\n+                Object_Definition   => New_Occurrence_Of (Exp_Type, Loc),\n+                Constant_Present    => True,\n+                Expression          => Relocate_Node (Exp)));\n+         else\n+            goto Leave;\n+         end if;\n \n       --  If this is an unchecked conversion that Gigi can't handle, make\n       --  a copy or a use a renaming to capture the value.\n@@ -9076,6 +9099,19 @@ package body Exp_Util is\n         and then Is_Class_Wide_Type (Typ)\n       then\n          return True;\n+\n+      --  Generating C the type conversion of an access to constrained array\n+      --  type into an access to unconstrained array type involves initializing\n+      --  a fat pointer and the expression cannot be assumed to be free of side\n+      --  effects since it must referenced several times to compute its bounds.\n+\n+      elsif Generate_C_Code\n+        and then Nkind (N) = N_Type_Conversion\n+        and then Is_Access_Type (Typ)\n+        and then Is_Array_Type (Designated_Type (Typ))\n+        and then not Is_Constrained (Designated_Type (Typ))\n+      then\n+         return False;\n       end if;\n \n       --  For other than entity names and compile time known values,"}, {"sha": "8ed90b0999c2bcac02d421193839a04118db6887", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=6905a0499b633ec67f5eb8dac39a8eea57184c39", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -440,7 +440,7 @@ begin\n \n          --  At this stage we can unnest subprogram bodies if required\n \n-         Exp_Ch6.Unnest_Subprograms;\n+         Exp_Ch6.Unnest_Subprograms (Cunit (Main_Unit));\n \n          --  List library units if requested\n "}, {"sha": "dd0851ded7dab897110f9292c74c55876886aa07", "filename": "gcc/ada/s-os_lib.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=6905a0499b633ec67f5eb8dac39a8eea57184c39", "patch": "@@ -454,7 +454,7 @@ package System.OS_Lib is\n    --  that is writable. Returns True if so, False otherwise. Note that this\n    --  function simply interrogates the file attributes (e.g. using the C\n    --  function stat), so it does not indicate a situation in which a file may\n-   --  not actually be writeable due to some other process having exclusive\n+   --  not actually be writable due to some other process having exclusive\n    --  access.\n \n    function Locate_Exec_On_Path (Exec_Name : String) return String_Access;"}, {"sha": "57e4c8dcb81a24e5355a506bf2277ccae30aa8b5", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 154, "deletions": 47, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=6905a0499b633ec67f5eb8dac39a8eea57184c39", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -101,17 +101,24 @@ package body Sem_Ch13 is\n    --  list is stored in Static_Discrete_Predicate (Typ), and the Expr is\n    --  rewritten as a canonicalized membership operation.\n \n+   function Build_Predicate_Function_Declaration\n+      (Typ : Entity_Id) return Node_Id;\n+   --  Build the declaration for a predicate function. The declaration is built\n+   --  at the end of the declarative part containing the type definition, which\n+   --  may be before the freeze point of the type. The predicate expression is\n+   --  pre-analyzed at this point, to catch visibility errors.\n+\n    procedure Build_Predicate_Functions (Typ : Entity_Id; N : Node_Id);\n    --  If Typ has predicates (indicated by Has_Predicates being set for Typ),\n    --  then either there are pragma Predicate entries on the rep chain for the\n    --  type (note that Predicate aspects are converted to pragma Predicate), or\n    --  there are inherited aspects from a parent type, or ancestor subtypes.\n-   --  This procedure builds the spec and body for the Predicate function that\n-   --  tests these predicates. N is the freeze node for the type. The spec of\n-   --  the function is inserted before the freeze node, and the body of the\n-   --  function is inserted after the freeze node. If the predicate expression\n-   --  has at least one Raise_Expression, then this procedure also builds the\n-   --  M version of the predicate function for use in membership tests.\n+   --  This procedure builds body for the Predicate function that tests these\n+   --  predicates. N is the freeze node for the type. The spec of the function\n+   --  is inserted before the freeze node, and the body of the function is\n+   --  inserted after the freeze node. If the predicate expression has a least\n+   --  one Raise_Expression, then this procedure also builds the M version of\n+   --  the predicate function for use in membership tests.\n \n    procedure Check_Pool_Size_Clash (Ent : Entity_Id; SP, SS : Node_Id);\n    --  Called if both Storage_Pool and Storage_Size attribute definition\n@@ -8419,18 +8426,23 @@ package body Sem_Ch13 is\n       --  function. It differs in that raise expressions are marked for\n       --  special expansion (see Process_REs).\n \n-      Object_Name : constant Name_Id := New_Internal_Name ('I');\n+      Object_Name : Name_Id;\n       --  Name for argument of Predicate procedure. Note that we use the same\n       --  name for both predicate functions. That way the reference within the\n       --  predicate expression is the same in both functions.\n \n-      Object_Entity : constant Entity_Id :=\n-                        Make_Defining_Identifier (Loc, Chars => Object_Name);\n+      Object_Entity : Entity_Id;\n       --  Entity for argument of Predicate procedure\n \n-      Object_Entity_M : constant Entity_Id :=\n-                         Make_Defining_Identifier (Loc, Chars => Object_Name);\n-      --  Entity for argument of Predicate_M procedure\n+      Object_Entity_M : Entity_Id;\n+      --  Entity for argument of separate Predicate procedure when exceptions\n+      --  are present in expression.\n+\n+      FDecl         : Node_Id;\n+      --  The function declaration.\n+\n+      SId            : Entity_Id;\n+      --  Its entity.\n \n       Raise_Expression_Present : Boolean := False;\n       --  Set True if Expr has at least one Raise_Expression\n@@ -8669,8 +8681,9 @@ package body Sem_Ch13 is\n    begin\n       --  Return if already built or if type does not have predicates\n \n+      SId := Predicate_Function (Typ);\n       if not Has_Predicates (Typ)\n-        or else Present (Predicate_Function (Typ))\n+        or else (Present (SId) and then Has_Completion (SId))\n       then\n          return;\n       end if;\n@@ -8684,6 +8697,24 @@ package body Sem_Ch13 is\n \n       Expr := Empty;\n \n+      if Present (SId) then\n+         FDecl := Unit_Declaration_Node (SId);\n+\n+      else\n+         FDecl := Build_Predicate_Function_Declaration (Typ);\n+         SId   := Defining_Entity (FDecl);\n+      end if;\n+\n+      --  Recover name of formal parameter of function that replaces references\n+      --  to the type in predicate expressions.\n+\n+      Object_Entity :=\n+         Defining_Identifier\n+           (First (Parameter_Specifications (Specification (FDecl))));\n+\n+      Object_Name     := Chars (Object_Entity);\n+      Object_Entity_M := Make_Defining_Identifier (Loc, Chars => Object_Name);\n+\n       --  Add predicates for ancestor if present. These must come before the\n       --  ones for the current type, as required by AI12-0071-1.\n \n@@ -8694,7 +8725,6 @@ package body Sem_Ch13 is\n             Add_Call (Atyp);\n          end if;\n       end;\n-\n       --  Add Predicates for the current type\n \n       Add_Predicates;\n@@ -8757,27 +8787,15 @@ package body Sem_Ch13 is\n          --  Build the main predicate function\n \n          declare\n-            SId : constant Entity_Id :=\n-                    Make_Defining_Identifier (Loc,\n-                      Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n-            --  The entity for the function spec\n-\n             SIdB : constant Entity_Id :=\n               Make_Defining_Identifier (Loc,\n                 Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n             --  The entity for the function body\n \n             Spec  : Node_Id;\n-            FDecl : Node_Id;\n             FBody : Node_Id;\n \n          begin\n-            --  Build function declaration\n-\n-            Set_Ekind (SId, E_Function);\n-            Set_Is_Internal (SId);\n-            Set_Is_Predicate_Function (SId);\n-            Set_Predicate_Function (Typ, SId);\n \n             --  The predicate function is shared between views of a type\n \n@@ -8792,20 +8810,6 @@ package body Sem_Ch13 is\n                Set_Is_Ghost_Entity (SId);\n             end if;\n \n-            Spec :=\n-              Make_Function_Specification (Loc,\n-                Defining_Unit_Name       => SId,\n-                Parameter_Specifications => New_List (\n-                  Make_Parameter_Specification (Loc,\n-                    Defining_Identifier => Object_Entity,\n-                    Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n-                Result_Definition        =>\n-                  New_Occurrence_Of (Standard_Boolean, Loc));\n-\n-            FDecl :=\n-              Make_Subprogram_Declaration (Loc,\n-                Specification => Spec);\n-\n             --  Build function body\n \n             Spec :=\n@@ -8830,9 +8834,14 @@ package body Sem_Ch13 is\n                       Make_Simple_Return_Statement (Loc,\n                         Expression => Expr))));\n \n-            --  Insert declaration before freeze node and body after\n+            --  If declaration has not been analyzed yet, Insert declaration\n+            --  before freeze node.\n+            --  Insert body after freeze node.\n+\n+            if not Analyzed (FDecl) then\n+               Insert_Before_And_Analyze (N, FDecl);\n+            end if;\n \n-            Insert_Before_And_Analyze (N, FDecl);\n             Insert_After_And_Analyze  (N, FBody);\n \n             --  Static predicate functions are always side-effect free, and\n@@ -8863,8 +8872,8 @@ package body Sem_Ch13 is\n                --  The entity for the function body\n \n                Spec  : Node_Id;\n-               FDecl : Node_Id;\n                FBody : Node_Id;\n+               FDecl : Node_Id;\n                BTemp : Entity_Id;\n \n             begin\n@@ -9046,6 +9055,59 @@ package body Sem_Ch13 is\n       Ghost_Mode := Save_Ghost_Mode;\n    end Build_Predicate_Functions;\n \n+   ------------------------------------------\n+   -- Build_Predicate_Function_Declaration --\n+   ------------------------------------------\n+\n+   function Build_Predicate_Function_Declaration\n+     (Typ : Entity_Id) return Node_Id\n+   is\n+      Loc : constant Source_Ptr := Sloc (Typ);\n+\n+      Object_Entity : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc, Chars => New_Internal_Name ('I'));\n+\n+      --  The formal parameter of the function\n+\n+      SId : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+\n+      --  The entity for the function spec\n+\n+      FDecl : Node_Id;\n+      Spec  : Node_Id;\n+\n+   begin\n+      Spec :=\n+        Make_Function_Specification (Loc,\n+          Defining_Unit_Name       => SId,\n+          Parameter_Specifications => New_List (\n+            Make_Parameter_Specification (Loc,\n+              Defining_Identifier => Object_Entity,\n+              Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n+          Result_Definition        =>\n+            New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+      FDecl := Make_Subprogram_Declaration (Loc, Specification => Spec);\n+\n+      Set_Ekind (SId, E_Function);\n+      Set_Etype (SId, Standard_Boolean);\n+      Set_Is_Internal (SId);\n+      Set_Is_Predicate_Function (SId);\n+      Set_Predicate_Function (Typ, SId);\n+\n+      if Comes_From_Source (Typ) then\n+         Insert_After (Parent (Typ), FDecl);\n+      else\n+         Insert_After (Parent (Base_Type (Typ)), FDecl);\n+      end if;\n+\n+      Analyze (FDecl);\n+\n+      return FDecl;\n+   end Build_Predicate_Function_Declaration;\n+\n    -----------------------------------------\n    -- Check_Aspect_At_End_Of_Declarations --\n    -----------------------------------------\n@@ -12532,6 +12594,37 @@ package body Sem_Ch13 is\n       A_Id : Aspect_Id;\n       Expr : Node_Id;\n \n+      function Resolve_Name (N : Node_Id) return Traverse_Result;\n+      --  Verify that all identifiers in the expression, with the exception\n+      --  of references to the current entity, denote visible entities. This\n+      --  is done only to detect visibility errors, as the expression will be\n+      --  properly analyzed/expanded during analysis of the predicate function\n+      --  body.\n+\n+      ------------------\n+      -- Resolve_Name --\n+      ------------------\n+\n+      function Resolve_Name (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) = N_Selected_Component then\n+            if Nkind (Prefix (N)) = N_Identifier\n+              and then Chars (Prefix (N)) /= Chars (E)\n+            then\n+               Find_Selected_Component (Parent (N));\n+            end if;\n+            return Skip;\n+\n+         elsif Nkind (N) = N_Identifier and then  Chars (N) /= Chars (E) then\n+            Find_Direct_Name (N);\n+            Set_Entity (N, Empty);\n+         end if;\n+\n+         return OK;\n+      end Resolve_Name;\n+\n+      procedure Resolve_Aspect_Expression is new Traverse_Proc (Resolve_Name);\n+\n    begin\n       ASN := First_Rep_Item (E);\n       while Present (ASN) loop\n@@ -12546,11 +12639,25 @@ package body Sem_Ch13 is\n \n                when Aspect_Predicate |\n                     Aspect_Predicate_Failure |\n-                    Aspect_Invariant |\n-                    Aspect_Static_Predicate |\n-                    Aspect_Dynamic_Predicate =>\n+                    Aspect_Invariant =>\n                   null;\n \n+               when Aspect_Static_Predicate |\n+                    Aspect_Dynamic_Predicate =>\n+\n+                  --  build predicate function specification and preanalyze\n+                  --  expression after type replacement.\n+\n+                  if No (Predicate_Function (E)) then\n+                     declare\n+                        FDecl : constant Node_Id :=\n+                           Build_Predicate_Function_Declaration (E);\n+                        pragma Unreferenced (FDecl);\n+                     begin\n+                        Resolve_Aspect_Expression (Expr);\n+                     end;\n+                  end if;\n+\n                when Pre_Post_Aspects =>\n                   null;\n "}, {"sha": "71af299777db902b755b5a809921a036d6f0514f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=6905a0499b633ec67f5eb8dac39a8eea57184c39", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -11820,8 +11820,17 @@ package body Sem_Ch3 is\n       --  in particular when the full type is a scalar type for which an\n       --  anonymous base type is constructed.\n \n+      --  The predicate functions are generated either at the freeze point\n+      --  of the type or at the end of the visible part, and we must avoid\n+      --  generating them twice.\n+\n       if Has_Predicates (Priv) then\n          Set_Has_Predicates (Full);\n+         if Present (Predicate_Function (Priv))\n+            and then No (Predicate_Function (Full))\n+         then\n+            Set_Predicate_Function (Full, Predicate_Function (Priv));\n+         end if;\n       end if;\n \n       if Has_Delayed_Aspects (Priv) then"}, {"sha": "8957287dbfda2bd412796f4765492d4a8acccc0b", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905a0499b633ec67f5eb8dac39a8eea57184c39/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6905a0499b633ec67f5eb8dac39a8eea57184c39", "patch": "@@ -10847,6 +10847,23 @@ package body Sem_Res is\n       then\n          Set_Do_Range_Check (Operand);\n       end if;\n+\n+      --  Generating C code a type conversion of an access to constrained\n+      --  array type to access to unconstrained array type involves building\n+      --  a fat pointer which in general cannot be generated on the fly. We\n+      --  remove side effects in order to store the result of the conversion\n+      --  into a temporary.\n+\n+      if Generate_C_Code\n+        and then Nkind (N) = N_Type_Conversion\n+        and then Nkind (Parent (N)) /= N_Object_Declaration\n+        and then Is_Access_Type (Etype (N))\n+        and then Is_Array_Type (Designated_Type (Etype (N)))\n+        and then not Is_Constrained (Designated_Type (Etype (N)))\n+        and then Is_Constrained (Designated_Type (Etype (Expression (N))))\n+      then\n+         Remove_Side_Effects (N);\n+      end if;\n    end Resolve_Type_Conversion;\n \n    ----------------------"}]}