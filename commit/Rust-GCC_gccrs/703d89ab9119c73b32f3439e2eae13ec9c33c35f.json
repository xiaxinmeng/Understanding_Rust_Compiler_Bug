{"sha": "703d89ab9119c73b32f3439e2eae13ec9c33c35f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAzZDg5YWI5MTE5YzczYjMyZjM0MzllMmVhZTEzZWM5YzMzYzM1Zg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2007-03-26T22:23:50Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2007-03-26T22:23:50Z"}, "message": "Add file left out of prior commit, and regenerate the proper configure script\n\nFrom-SVN: r123242", "tree": {"sha": "ee6f78bb84c230d882f8d33601b86fecda984cf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee6f78bb84c230d882f8d33601b86fecda984cf1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/703d89ab9119c73b32f3439e2eae13ec9c33c35f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703d89ab9119c73b32f3439e2eae13ec9c33c35f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/703d89ab9119c73b32f3439e2eae13ec9c33c35f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703d89ab9119c73b32f3439e2eae13ec9c33c35f/comments", "author": null, "committer": null, "parents": [{"sha": "596438ca819090ac83159b4d068b78c17019c066", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/596438ca819090ac83159b4d068b78c17019c066", "html_url": "https://github.com/Rust-GCC/gccrs/commit/596438ca819090ac83159b4d068b78c17019c066"}], "stats": {"total": 11878, "additions": 6593, "deletions": 5285}, "files": [{"sha": "aab96bb9df9b129bf23fd2bfa86ae1415ef04f06", "filename": "gcc/configure", "status": "modified", "additions": 5664, "deletions": 5285, "changes": 10949, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703d89ab9119c73b32f3439e2eae13ec9c33c35f/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703d89ab9119c73b32f3439e2eae13ec9c33c35f/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=703d89ab9119c73b32f3439e2eae13ec9c33c35f"}, {"sha": "37366ad987d75042512a1474148fc796e8d9a5bb", "filename": "gcc/gengtype-parse.c", "status": "added", "additions": 929, "deletions": 0, "changes": 929, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703d89ab9119c73b32f3439e2eae13ec9c33c35f/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703d89ab9119c73b32f3439e2eae13ec9c33c35f/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=703d89ab9119c73b32f3439e2eae13ec9c33c35f", "patch": "@@ -0,0 +1,929 @@\n+/* Process source files and output type information.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bconfig.h\"\n+#include \"system.h\"\n+#include \"gengtype.h\"\n+\n+/* This is a simple recursive-descent parser which understands a subset of\n+   the C type grammar.\n+\n+   Rule functions are suffixed _seq if they scan a sequence of items;\n+   _opt if they may consume zero tokens; _seqopt if both are true.  The\n+   \"consume_\" prefix indicates that a sequence of tokens is parsed for\n+   syntactic correctness and then thrown away.  */\n+\n+/* Simple one-token lookahead mechanism.  */\n+\n+struct token\n+{\n+  const char *value;\n+  int code;\n+  bool valid;\n+};\n+static struct token T;\n+\n+/* Retrieve the code of the current token; if there is no current token,\n+   get the next one from the lexer.  */\n+static inline int\n+token (void)\n+{\n+  if (!T.valid)\n+    {\n+      T.code = yylex (&T.value);\n+      T.valid = true;\n+    }\n+  return T.code;\n+}\n+\n+/* Retrieve the value of the current token (if any) and mark it consumed.\n+   The next call to token() will get another token from the lexer.  */\n+static inline const char *\n+advance (void)\n+{\n+  T.valid = false;\n+  return T.value;\n+}\n+\n+/* Diagnostics.  */\n+\n+/* This array is indexed by the token code minus CHAR_TOKEN_OFFSET.  */\n+static const char *const token_names[] = {\n+  \"GTY\",\n+  \"typedef\",\n+  \"extern\",\n+  \"static\",\n+  \"union\",\n+  \"struct\",\n+  \"enum\",\n+  \"VEC\",\n+  \"DEF_VEC_[OP]\",\n+  \"DEF_VEC_I\",\n+  \"DEF_VEC_ALLOC_[IOP]\",\n+  \"...\",\n+  \"ptr_alias\",\n+  \"nested_ptr\",\n+  \"a param<N>_is option\",\n+  \"a number\",\n+  \"a scalar type\",\n+  \"an identifier\",\n+  \"a string constant\",\n+  \"a character constant\",\n+  \"an array declarator\",\n+};\n+\n+/* This array is indexed by token code minus FIRST_TOKEN_WITH_VALUE.  */\n+static const char *const token_value_format[] = {\n+  \"%s\",\n+  \"'%s'\",\n+  \"'%s'\",\n+  \"'%s'\",\n+  \"'\\\"%s\\\"'\",\n+  \"\\\"'%s'\\\"\",\n+  \"'[%s]'\",\n+};\n+\n+/* Produce a printable representation for a token defined by CODE and\n+   VALUE.  This sometimes returns pointers into malloc memory and\n+   sometimes not, therefore it is unsafe to free the pointer it\n+   returns, so that memory is leaked.  This does not matter, as this\n+   function is only used for diagnostics, and in a successful run of\n+   the program there will be none.  */\n+static const char *\n+print_token (int code, const char *value)\n+{\n+  if (code < CHAR_TOKEN_OFFSET)\n+    return xasprintf (\"'%c'\", code);\n+  else if (code < FIRST_TOKEN_WITH_VALUE)\n+    return xasprintf (\"'%s'\", token_names[code - CHAR_TOKEN_OFFSET]);\n+  else if (!value)\n+    return token_names[code - CHAR_TOKEN_OFFSET]; /* don't quote these */\n+  else\n+    return xasprintf (token_value_format[code - FIRST_TOKEN_WITH_VALUE],\n+\t\t      value);\n+}\n+\n+/* Convenience wrapper around print_token which produces the printable\n+   representation of the current token.  */\n+static inline const char *\n+print_cur_token (void)\n+{\n+  return print_token (T.code, T.value);\n+}\n+\n+/* Report a parse error on the current line, with diagnostic MSG.\n+   Behaves as standard printf with respect to additional arguments and\n+   format escapes.  */\n+static void ATTRIBUTE_PRINTF_1\n+parse_error (const char *msg, ...)\n+{\n+  va_list ap;\n+\n+  fprintf (stderr, \"%s:%d: parse error: \", lexer_line.file, lexer_line.line);\n+\n+  va_start (ap, msg);\n+  vfprintf (stderr, msg, ap);\n+  va_end (ap);\n+\n+  hit_error = true;\n+}\n+\n+/* If the next token does not have code T, report a parse error; otherwise\n+   return the token's value.  */\n+static const char *\n+require (int t)\n+{\n+  int u = token ();\n+  const char *v = advance ();\n+  if (u != t)\n+    {\n+      parse_error (\"expected %s, have %s\",\n+\t\t   print_token (t, 0), print_token (u, v));\n+      return 0;\n+    }\n+  return v;\n+}\n+\n+/* If the next token does not have one of the codes T1 or T2, report a\n+   parse error; otherwise return the token's value.  */\n+static const char *\n+require2 (int t1, int t2)\n+{\n+  int u = token ();\n+  const char *v = advance ();\n+  if (u != t1 && u != t2)\n+    {\n+      parse_error (\"expected %s or %s, have %s\",\n+\t\t   print_token (t1, 0), print_token (t2, 0),\n+\t\t   print_token (u, v));\n+      return 0;\n+    }\n+  return v;\n+}\n+\n+/* Near-terminals.  */\n+\n+/* C-style string constant concatenation: STRING+\n+   Bare STRING should appear nowhere else in this file.  */\n+static const char *\n+string_seq (void)\n+{\n+  const char *s1, *s2;\n+  size_t l1, l2;\n+  char *buf;\n+\n+  s1 = require (STRING);\n+  if (s1 == 0)\n+    return \"\";\n+  while (token () == STRING)\n+    {\n+      s2 = advance ();\n+\n+      l1 = strlen (s1);\n+      l2 = strlen (s2);\n+      buf = XRESIZEVEC (char, s1, l1 + l2 + 1);\n+      memcpy (buf + l1, s2, l2 + 1);\n+      XDELETE (s2);\n+      s1 = buf;\n+    }\n+  return s1;\n+}\n+\n+/* typedef_name: either an ID, or VEC(x,y) which is translated to VEC_x_y.\n+   Use only where VEC(x,y) is legitimate, i.e. in positions where a\n+   typedef name may appear.  */\n+static const char *\n+typedef_name (void)\n+{\n+  if (token () == VEC_TOKEN)\n+    {\n+      const char *c1, *c2, *r;\n+      advance ();\n+      require ('(');\n+      c1 = require2 (ID, SCALAR);\n+      require (',');\n+      c2 = require (ID);\n+      require (')');\n+      r = concat (\"VEC_\", c1, \"_\", c2, (char *)0);\n+      free ((void *)c1);\n+      free ((void *)c2);\n+      return r;\n+    }\n+  else\n+    return require (ID);\n+}\n+\n+/* Absorb a sequence of tokens delimited by balanced ()[]{}.  */\n+static void\n+consume_balanced (int opener, int closer)\n+{\n+  require (opener);\n+  for (;;)\n+    switch (token ())\n+      {\n+      default: advance (); break;\n+      case '(': consume_balanced ('(',')'); break;\n+      case '[': consume_balanced ('[',']'); break;\n+      case '{': consume_balanced ('{','}'); break;\n+\n+      case '}':\n+      case ']':\n+      case ')':\n+\tif (token () != closer)\n+\t  parse_error (\"unbalanced delimiters - expected '%c', have '%c'\",\n+\t\t       closer, token ());\n+\tadvance ();\n+\treturn;\n+\n+      case EOF_TOKEN:\n+\tparse_error (\"unexpected end of file within %c%c-delimited construct\",\n+\t\t     opener, closer);\n+\treturn;\n+      }\n+}\n+\n+/* Absorb a sequence of tokens, possibly including ()[]{}-delimited\n+   expressions, until we encounter a semicolon outside any such\n+   delimiters; absorb that too.  If IMMEDIATE is true, it is an error\n+   if the semicolon is not the first token encountered.  */\n+static void\n+consume_until_semi (bool immediate)\n+{\n+  if (immediate && token () != ';')\n+    require (';');\n+  for (;;)\n+    switch (token ())\n+      {\n+      case ';':\tadvance (); return;\n+      default:\tadvance (); break;\n+\n+      case '(':\tconsume_balanced ('(',')'); break;\n+      case '[': consume_balanced ('[',']'); break;\n+      case '{':\tconsume_balanced ('{','}'); break;\n+\n+      case '}':\n+      case ']':\n+      case ')':\n+\tparse_error (\"unmatched '%c' while scanning for ';'\", token ());\n+\treturn;\n+\n+      case EOF_TOKEN:\n+\tparse_error (\"unexpected end of file while scanning for ';'\");\n+\treturn;\n+      }\n+}\n+\n+/* Absorb a sequence of tokens, possibly including ()[]{}-delimited\n+   expressions, until we encounter a comma or semicolon outside any\n+   such delimiters; absorb that too.  If IMMEDIATE is true, it is an\n+   error if the comma or semicolon is not the first token encountered.\n+   Returns true if the loop ended with a comma.  */\n+static bool\n+consume_until_comma_or_semi (bool immediate)\n+{\n+  if (immediate && token () != ',' && token () != ';')\n+    require2 (',', ';');\n+  for (;;)\n+    switch (token ())\n+      {\n+      case ',':\tadvance (); return true;\n+      case ';':\tadvance (); return false;\n+      default:\tadvance (); break;\n+\n+      case '(':\tconsume_balanced ('(',')'); break;\n+      case '[': consume_balanced ('[',']'); break;\n+      case '{':\tconsume_balanced ('{','}'); break;\n+\n+      case '}':\n+      case ']':\n+      case ')':\n+\tparse_error (\"unmatched '%s' while scanning for ',' or ';'\",\n+\t\t     print_cur_token ());\n+\treturn false;\n+\n+      case EOF_TOKEN:\n+\tparse_error (\"unexpected end of file while scanning for ',' or ';'\");\n+\treturn false;\n+      }\n+}\n+\n+\f\n+/* GTY(()) option handling.  */\n+static type_p type (options_p *optsp, bool nested);\n+\n+/* Optional parenthesized string: ('(' string_seq ')')? */\n+static options_p\n+str_optvalue_opt (options_p prev)\n+{\n+  const char *name = advance ();\n+  const char *value = \"\";\n+  if (token () == '(')\n+    {\n+      advance ();\n+      value = string_seq ();\n+      require (')');\n+    }\n+  return create_option (prev, name, value);\n+}\n+\n+/* absdecl: type '*'*\n+   -- a vague approximation to what the C standard calls an abstract\n+   declarator.  The only kinds that are actually used are those that\n+   are just a bare type and those that have trailing pointer-stars.\n+   Further kinds should be implemented if and when they become\n+   necessary.  Used only within GTY(()) option values, therefore\n+   further GTY(()) tags within the type are invalid.  Note that the\n+   return value has already been run through adjust_field_type.  */\n+static type_p\n+absdecl (void)\n+{\n+  type_p ty;\n+  options_p opts;\n+\n+  ty = type (&opts, true);\n+  while (token () == '*')\n+    {\n+      ty = create_pointer (ty);\n+      advance ();\n+    }\n+\n+  if (opts)\n+    parse_error (\"nested GTY(()) options are invalid\");\n+\n+  return adjust_field_type (ty, 0);\n+}\n+\n+/* Type-option: '(' absdecl ')' */\n+static options_p\n+type_optvalue (options_p prev, const char *name)\n+{\n+  type_p ty;\n+  require ('(');\n+  ty = absdecl ();\n+  require (')');\n+  return create_option (prev, name, ty);\n+}\n+\n+/* Nested pointer data: '(' type '*'* ',' string_seq ',' string_seq ')' */\n+static options_p\n+nestedptr_optvalue (options_p prev)\n+{\n+  type_p ty;\n+  const char *from, *to;\n+\n+  require ('(');\n+  ty = absdecl ();\n+  require (',');\n+  to = string_seq ();\n+  require (',');\n+  from = string_seq ();\n+  require (')');\n+\n+  return create_nested_ptr_option (prev, ty, to, from);\n+}\n+\n+/* One GTY(()) option:\n+         ID str_optvalue_opt\n+       | PTR_ALIAS type_optvalue\n+       | PARAM_IS type_optvalue\n+       | NESTED_PTR nestedptr_optvalue\n+ */\n+static options_p\n+option (options_p prev)\n+{\n+  switch (token ())\n+    {\n+    case ID:\n+      return str_optvalue_opt (prev);\n+\n+    case PTR_ALIAS:\n+      advance ();\n+      return type_optvalue (prev, \"ptr_alias\");\n+\n+    case PARAM_IS:\n+      return type_optvalue (prev, advance ());\n+\n+    case NESTED_PTR:\n+      advance ();\n+      return nestedptr_optvalue (prev);\n+\n+    default:\n+      parse_error (\"expected an option keyword, have %s\",\n+\t\t   print_cur_token ());\n+      advance ();\n+      return create_option (prev, \"\", \"\");\n+    }\n+}\n+\n+/* One comma-separated list of options.  */\n+static options_p\n+option_seq (void)\n+{\n+  options_p o;\n+\n+  o = option (0);\n+  while (token () == ',')\n+    {\n+      advance ();\n+      o = option (o);\n+    }\n+  return o;\n+}\n+\n+/* GTY marker: 'GTY' '(' '(' option_seq? ')' ')' */\n+static options_p\n+gtymarker (void)\n+{\n+  options_p result = 0;\n+  require (GTY_TOKEN);\n+  require ('(');\n+  require ('(');\n+  if (token () != ')')\n+    result = option_seq ();\n+  require (')');\n+  require (')');\n+  return result;\n+}\n+\n+/* Optional GTY marker.  */\n+static options_p\n+gtymarker_opt (void)\n+{\n+  if (token () != GTY_TOKEN)\n+    return 0;\n+  return gtymarker ();\n+}\n+\f\n+/* Declarators. The logic here is largely lifted from c-parser.c.\n+   Note that we do not have to process abstract declarators, which can\n+   appear only in parameter type lists or casts (but see absdecl,\n+   above).  Also, type qualifiers are thrown out in gengtype-lex.l so\n+   we don't have to do it.  */\n+\n+/* array_and_function_declarators_opt:\n+      \\epsilon\n+      array_and_function_declarators_opt ARRAY\n+      array_and_function_declarators_opt '(' ... ')'\n+\n+   where '...' indicates stuff we ignore except insofar as grouping\n+   symbols ()[]{} must balance.\n+\n+   Subroutine of direct_declarator - do not use elsewhere. */\n+\n+static type_p\n+array_and_function_declarators_opt (type_p ty)\n+{\n+  if (token () == ARRAY)\n+    {\n+      const char *array = advance ();\n+      return create_array (array_and_function_declarators_opt (ty), array);\n+    }\n+  else if (token () == '(')\n+    {\n+      /* We don't need exact types for functions.  */\n+      consume_balanced ('(', ')');\n+      array_and_function_declarators_opt (ty);\n+      return create_scalar_type (\"function type\");\n+    }\n+  else\n+    return ty;\n+}\n+\n+static type_p inner_declarator (type_p, const char **, options_p *);\n+\n+/* direct_declarator:\n+      '(' inner_declarator ')'\n+      gtymarker_opt ID array_and_function_declarators_opt\n+\n+   Subroutine of declarator, mutually recursive with inner_declarator;\n+   do not use elsewhere.  */\n+static type_p\n+direct_declarator (type_p ty, const char **namep, options_p *optsp)\n+{\n+  /* The first token in a direct-declarator must be an ID, a\n+     GTY marker, or an open parenthesis.  */\n+  switch (token ())\n+    {\n+    case GTY_TOKEN:\n+      *optsp = gtymarker ();\n+      /* fall through */\n+    case ID:\n+      *namep = require (ID);\n+      break;\n+\n+    case '(':\n+      advance ();\n+      ty = inner_declarator (ty, namep, optsp);\n+      require (')');\n+      break;\n+\n+    default:\n+      parse_error (\"expected '(', 'GTY', or an identifier, have %s\",\n+\t\t   print_cur_token ());\n+      /* Do _not_ advance if what we have is a close squiggle brace, as\n+\t we will get much better error recovery that way.  */\n+      if (token () != '}')\n+\tadvance ();\n+      return 0;\n+    }\n+  return array_and_function_declarators_opt (ty);\n+}\n+\n+/* The difference between inner_declarator and declarator is in the\n+   handling of stars.  Consider this declaration:\n+\n+      char * (*pfc) (void)\n+\n+   It declares a pointer to a function that takes no arguments and\n+   returns a char*.  To construct the correct type for this\n+   declaration, the star outside the parentheses must be processed\n+   _before_ the function type, the star inside the parentheses must\n+   be processed _after_ the function type.  To accomplish this,\n+   declarator() creates pointers before recursing (it is actually\n+   coded as a while loop), whereas inner_declarator() recurses before\n+   creating pointers.  */\n+\n+/* inner_declarator:\n+     '*' inner_declarator\n+     direct_declarator\n+\n+   Mutually recursive subroutine of direct_declarator; do not use\n+   elsewhere.  */\n+\n+static type_p\n+inner_declarator (type_p ty, const char **namep, options_p *optsp)\n+{\n+  if (token () == '*')\n+    {\n+      type_p inner;\n+      advance ();\n+      inner = inner_declarator (ty, namep, optsp);\n+      if (inner == 0)\n+\treturn 0;\n+      else\n+\treturn create_pointer (ty);\n+    }\n+  else\n+    return direct_declarator (ty, namep, optsp);\n+}\n+\n+/* declarator: '*'+ direct_declarator\n+\n+   This is the sole public interface to this part of the grammar.\n+   Arguments are the type known so far, a pointer to where the name\n+   may be stored, and a pointer to where GTY options may be stored.\n+   Returns the final type. */\n+\n+static type_p\n+declarator (type_p ty, const char **namep, options_p *optsp)\n+{\n+  *namep = 0;\n+  *optsp = 0;\n+  while (token () == '*')\n+    {\n+      advance ();\n+      ty = create_pointer (ty);\n+    }\n+  return direct_declarator (ty, namep, optsp);\n+}\n+\f\n+/* Types and declarations.  */\n+\n+/* Structure field(s) declaration:\n+   (\n+       type bitfield ';'\n+     | type declarator bitfield? ( ',' declarator bitfield? )+ ';'\n+   )+\n+\n+   Knows that such declarations must end with a close brace (or,\n+   erroneously, at EOF).\n+ */\n+static pair_p\n+struct_field_seq (void)\n+{\n+  pair_p f = 0;\n+  type_p ty, dty;\n+  options_p opts, dopts;\n+  const char *name;\n+  bool another;\n+\n+  do\n+    {\n+      ty = type (&opts, true);\n+      /* Another piece of the IFCVT_EXTRA_FIELDS special case, see type().  */\n+      if (!ty && token () == '}')\n+\tbreak;\n+\n+      if (!ty || token () == ':')\n+\t{\n+\t  consume_until_semi (false);\n+\t  continue;\n+\t}\n+\n+      do\n+\t{\n+\t  dty = declarator (ty, &name, &dopts);\n+\t  /* There could be any number of weird things after the declarator,\n+\t     notably bitfield declarations and __attribute__s.  If this\n+\t     function returns true, the last thing was a comma, so we have\n+\t     more than one declarator paired with the current type.  */\n+\t  another = consume_until_comma_or_semi (false);\n+\n+\t  if (!dty)\n+\t    continue;\n+\n+\t  if (opts && dopts)\n+\t    parse_error (\"two GTY(()) options for field %s\", name);\n+\t  if (opts && !dopts)\n+\t    dopts = opts;\n+\n+\t  f = create_field_at (f, dty, name, dopts, &lexer_line);\n+\t}\n+      while (another);\n+    }\n+  while (token () != '}' && token () != EOF_TOKEN);\n+  return nreverse_pairs (f);\n+}\n+\n+/* This is called type(), but what it parses (sort of) is what C calls\n+   declaration-specifiers and specifier-qualifier-list:\n+\n+     SCALAR\n+   | ID     // typedef\n+   | (STRUCT|UNION) ID? gtymarker? ( '{' gtymarker? struct_field_seq '}' )?\n+   | ENUM ID ( '{' ... '}' )?\n+\n+   Returns a partial type; under some conditions (notably\n+   \"struct foo GTY((...)) thing;\") it may write an options\n+   structure to *OPTSP.\n+ */\n+static type_p\n+type (options_p *optsp, bool nested)\n+{\n+  const char *s;\n+  bool is_union;\n+  *optsp = 0;\n+  switch (token ())\n+    {\n+    case SCALAR:\n+      s = advance ();\n+      return create_scalar_type (s);\n+\n+    case ID:\n+    case VEC_TOKEN:\n+      s = typedef_name ();\n+      return resolve_typedef (s, &lexer_line);\n+\n+    case STRUCT:\n+    case UNION:\n+      {\n+\toptions_p opts = 0;\n+\n+\tis_union = (token() == UNION);\n+\tadvance ();\n+\n+\tif (token () == ID)\n+\t  s = advance ();\n+\telse\n+\t  s = xasprintf (\"anonymous:%s:%d\", lexer_line.file, lexer_line.line);\n+\n+\t/* Top-level structures that are not explicitly tagged GTY(())\n+\t   are treated as mere forward declarations.  This is because\n+\t   there are a lot of structures that we don't need to know\n+\t   about, and some of those have weird macro stuff in them\n+\t   that we can't handle.  */\n+\tif (nested || token () == GTY_TOKEN)\n+\t  {\n+\t    opts = gtymarker_opt ();\n+\t    if (token () == '{')\n+\t      {\n+\t\tpair_p fields;\n+\t\tadvance ();\n+\t\tfields = struct_field_seq ();\n+\t\trequire ('}');\n+\t\treturn new_structure (s, is_union, &lexer_line, fields, opts);\n+\t      }\n+\t  }\n+\telse if (token () == '{')\n+\t  consume_balanced ('{', '}');\n+\tif (opts)\n+\t  *optsp = opts;\n+\treturn find_structure (s, is_union);\n+      }\n+\n+    case ENUM:\n+      advance ();\n+\tif (token () == ID)\n+\t  s = advance ();\n+\telse\n+\t  s = xasprintf (\"anonymous:%s:%d\", lexer_line.file, lexer_line.line);\n+\n+      if (token () == '{')\n+\tconsume_balanced ('{','}');\n+      return create_scalar_type (s);\n+\n+    default:\n+      parse_error (\"expected a type specifier, have %s\", print_cur_token ());\n+      advance ();\n+      return create_scalar_type (\"erroneous type\");\n+    }\n+}\n+\f\n+/* Top level constructs.  */\n+\n+/* Dispatch declarations beginning with 'typedef'.  */\n+\n+static void\n+typedef_decl (void)\n+{\n+  type_p ty, dty;\n+  const char *name;\n+  options_p opts;\n+  bool another;\n+\n+  gcc_assert (token () == TYPEDEF);\n+  advance ();\n+\n+  ty = type (&opts, false);\n+  if (!ty)\n+    return;\n+  if (opts)\n+    parse_error (\"GTY((...)) cannot be applied to a typedef\");\n+  do\n+    {\n+      dty = declarator (ty, &name, &opts);\n+      if (opts)\n+\tparse_error (\"GTY((...)) cannot be applied to a typedef\");\n+\n+      /* Yet another place where we could have junk (notably attributes)\n+\t after the declarator.  */\n+      another = consume_until_comma_or_semi (false);\n+      if (dty)\n+\tdo_typedef (name, dty, &lexer_line);\n+    }\n+  while (another);\n+}\n+\n+/* Structure definition: type() does all the work.  */\n+\n+static void\n+struct_or_union (void)\n+{\n+  options_p dummy;\n+  type (&dummy, false);\n+  /* There may be junk after the type: notably, we cannot currently\n+     distinguish 'struct foo *function(prototype);' from 'struct foo;'\n+     ...  we could call declarator(), but it's a waste of time at\n+     present.  Instead, just eat whatever token is currently lookahead\n+     and go back to lexical skipping mode. */\n+  advance ();\n+}\n+\n+/* GC root declaration:\n+     (extern|static) gtymarker? type ID array_declarators_opt (';'|'=')\n+   If the gtymarker is not present, we ignore the rest of the declaration.  */\n+static void\n+extern_or_static (void)\n+{\n+  options_p opts, opts2, dopts;\n+  type_p ty, dty;\n+  const char *name;\n+  require2 (EXTERN, STATIC);\n+\n+  if (token () != GTY_TOKEN)\n+    {\n+      advance ();\n+      return;\n+    }\n+\n+  opts = gtymarker ();\n+  ty   = type (&opts2, true);  /* if we get here, it's got a GTY(()) */\n+  dty  = declarator (ty, &name, &dopts);\n+\n+  if ((opts && dopts) || (opts && opts2) || (opts2 && dopts))\n+    parse_error (\"GTY((...)) specified more than once for %s\", name);\n+  else if (opts2)\n+    opts = opts2;\n+  else if (dopts)\n+    opts = dopts;\n+\n+  if (dty)\n+    {\n+      note_variable (name, adjust_field_type (dty, opts), opts, &lexer_line);\n+      require2 (';', '=');\n+    }\n+}\n+\n+/* Definition of a generic VEC structure:\n+\n+   'DEF_VEC_[IPO]' '(' id ')' ';'\n+\n+   Scalar VECs require slightly different treatment than otherwise -\n+   that's handled in note_def_vec, we just pass it along.*/\n+static void\n+def_vec (void)\n+{\n+  bool is_scalar = (token() == DEFVEC_I);\n+  const char *type;\n+\n+  require2 (DEFVEC_OP, DEFVEC_I);\n+  require ('(');\n+  type = require2 (ID, SCALAR);\n+  require (')');\n+  require (';');\n+\n+  if (!type)\n+    return;\n+\n+  note_def_vec (type, is_scalar, &lexer_line);\n+  note_def_vec_alloc (type, \"none\", &lexer_line);\n+}\n+\n+/* Definition of an allocation strategy for a VEC structure:\n+\n+   'DEF_VEC_ALLOC_[IPO]' '(' id ',' id ')' ';'\n+\n+   For purposes of gengtype, this just declares a wrapper structure.  */\n+static void\n+def_vec_alloc (void)\n+{\n+  const char *type, *astrat;\n+\n+  require (DEFVEC_ALLOC);\n+  require ('(');\n+  type = require2 (ID, SCALAR);\n+  require (',');\n+  astrat = require (ID);\n+  require (')');\n+  require (';');\n+\n+  if (!type || !astrat)\n+    return;\n+\n+  note_def_vec_alloc (type, astrat, &lexer_line);\n+}\n+\n+/* Parse the file FNAME for GC-relevant declarations and definitions.\n+   This is the only entry point to this file.  */\n+void\n+parse_file (const char *fname)\n+{\n+  yybegin (fname);\n+  for (;;)\n+    {\n+      switch (token ())\n+\t{\n+\tcase EXTERN:\n+\tcase STATIC:\n+\t  extern_or_static ();\n+\t  break;\n+\n+\tcase STRUCT:\n+\tcase UNION:\n+\t  struct_or_union ();\n+\t  break;\n+\n+\tcase TYPEDEF:\n+\t  typedef_decl ();\n+\t  break;\n+\n+\tcase DEFVEC_OP:\n+\tcase DEFVEC_I:\n+\t  def_vec ();\n+\t  break;\n+\n+\tcase DEFVEC_ALLOC:\n+\t  def_vec_alloc ();\n+\t  break;\n+\n+\tcase EOF_TOKEN:\n+\t  goto eof;\n+\n+\tdefault:\n+\t  parse_error (\"unexpected top level token, %s\", print_cur_token ());\n+\t  goto eof;\n+\t}\n+      lexer_toplevel_done = 1;\n+    }\n+\n+ eof:\n+  advance ();\n+  yyend ();\n+}"}]}