{"sha": "4839de55e2c98619f4919254abb87e2f393aaead", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgzOWRlNTVlMmM5ODYxOWY0OTE5MjU0YWJiODdlMmYzOTNhYWVhZA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-17T18:27:22Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-17T18:27:22Z"}, "message": "c-family: Macro support in -Wmisleading-indentation [PR80076]\n\nCurrently the -Wmisleading-indentation warning doesn't do any analysis\nwhen the guarded statement or the statement after it is produced by a\nmacro.  This means we warn for:\n\n  if (flag)\n    foo ();\n    bar ();\n\nbut not for:\n\n  #define BAR bar\n  if (flag)\n    foo ();\n    BAR ();\n\nThis patch extends the -Wmisleading-indentation implementation to\nsupport analyzing such statements and their tokens.  This is done in the\n\"natural\" way by resolving the location of each of the three tokens to\nthe token's macro expansion point.  (Additionally, if the tokens all\nresolve to the same macro expansion point then we instead use their\nlocations within the macro definition.)  When these resolved locations\nare all different, then we can proceed with applying the warning\nheuristics to them as if no macros were involved.\n\ngcc/c-family/ChangeLog:\n\n\tPR c/80076\n\t* c-indentation.c (should_warn_for_misleading_indentation): Move\n\tdeclarations of local variables closer to their first use.\n\tHandle virtual token locations by resolving them to their\n\trespective macro expansion points.  If all three tokens are\n\tproduced from the same macro expansion, then instead use their\n\tloci within the macro definition.\n\ngcc/objc/ChangeLog:\n\n\tPR c/80076\n\t* objc-gnu-runtime-abi-01.c\n\t(gnu_runtime_abi_01_get_class_super_ref): Reduce indentation of\n\tmisleadingly indented return statements.\n\t* objc-next-runtime-abi-01.c\n\t(next_runtime_abi_01_get_class_super_ref): Likewise.\n\ngcc/ChangeLog:\n\n\tPR c/80076\n\t* gensupport.c (alter_attrs_for_subst_insn) <case SET_ATTR>:\n\tReduce indentation of misleadingly indented code fragment.\n\t* lra-constraints.c (multi_block_pseudo_p): Likewise.\n\t* sel-sched-ir.c (merge_fences): Likewise.\n\nlibcpp/ChangeLog:\n\n\tPR c/80076\n\t* include/line-map.h (first_map_in_common): Declare.\n\t* line-map.c (first_map_in_common): Remove static.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/80076\n\t* c-c++-common/Wmisleading-indentation-5.c: New test.", "tree": {"sha": "6b191cd26456d813b29ea6204c1730004879fa5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b191cd26456d813b29ea6204c1730004879fa5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4839de55e2c98619f4919254abb87e2f393aaead", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4839de55e2c98619f4919254abb87e2f393aaead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4839de55e2c98619f4919254abb87e2f393aaead", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4839de55e2c98619f4919254abb87e2f393aaead/comments", "author": null, "committer": null, "parents": [{"sha": "71e3d1970c00a74be16c0f5a3fcaced359077135", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71e3d1970c00a74be16c0f5a3fcaced359077135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71e3d1970c00a74be16c0f5a3fcaced359077135"}], "stats": {"total": 259, "additions": 178, "deletions": 81}, "files": [{"sha": "8b88a8adc7c843badfbfedb7b4a28092f1167a4c", "filename": "gcc/c-family/c-indentation.c", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Fc-family%2Fc-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Fc-family%2Fc-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.c?ref=4839de55e2c98619f4919254abb87e2f393aaead", "patch": "@@ -213,19 +213,6 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t\t\t\t\tconst token_indent_info &body_tinfo,\n \t\t\t\t\tconst token_indent_info &next_tinfo)\n {\n-  location_t guard_loc = guard_tinfo.location;\n-  location_t body_loc = body_tinfo.location;\n-  location_t next_stmt_loc = next_tinfo.location;\n-\n-  enum cpp_ttype body_type = body_tinfo.type;\n-  enum cpp_ttype next_tok_type = next_tinfo.type;\n-\n-  /* Don't attempt to compare the indentation of BODY_LOC and NEXT_STMT_LOC\n-     if either are within macros.  */\n-  if (linemap_location_from_macro_expansion_p (line_table, body_loc)\n-      || linemap_location_from_macro_expansion_p (line_table, next_stmt_loc))\n-    return false;\n-\n   /* Don't attempt to compare indentation if #line or # 44 \"file\"-style\n      directives are present, suggesting generated code.\n \n@@ -266,6 +253,7 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n      }            <- NEXT\n      baz ();\n   */\n+  enum cpp_ttype next_tok_type = next_tinfo.type;\n   if (next_tok_type == CPP_CLOSE_BRACE\n       || next_tinfo.keyword == RID_ELSE)\n     return false;\n@@ -287,13 +275,60 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n       bar (); <- BODY\n       baz (); <- NEXT\n   */\n+  enum cpp_ttype body_type = body_tinfo.type;\n   if (body_type == CPP_OPEN_BRACE)\n     return false;\n \n   /* Don't warn here about spurious semicolons.  */\n   if (next_tok_type == CPP_SEMICOLON)\n     return false;\n \n+  location_t guard_loc = guard_tinfo.location;\n+  location_t body_loc = body_tinfo.location;\n+  location_t next_stmt_loc = next_tinfo.location;\n+\n+  /* Resolve each token location to the respective macro expansion\n+     point that produced the token.  */\n+  if (linemap_location_from_macro_expansion_p (line_table, guard_loc))\n+    guard_loc = linemap_resolve_location (line_table, guard_loc,\n+\t\t\t\t\t  LRK_MACRO_EXPANSION_POINT, NULL);\n+  if (linemap_location_from_macro_expansion_p (line_table, body_loc))\n+    body_loc = linemap_resolve_location (line_table, body_loc,\n+\t\t\t\t\t LRK_MACRO_EXPANSION_POINT, NULL);\n+  if (linemap_location_from_macro_expansion_p (line_table, next_stmt_loc))\n+    next_stmt_loc = linemap_resolve_location (line_table, next_stmt_loc,\n+\t\t\t\t\t      LRK_MACRO_EXPANSION_POINT, NULL);\n+\n+  /* When all three tokens are produced from a single macro expansion, we\n+     instead consider their loci inside that macro's definition.  */\n+  if (guard_loc == body_loc && body_loc == next_stmt_loc)\n+    {\n+      const line_map *guard_body_common_map\n+\t= first_map_in_common (line_table,\n+\t\t\t       guard_tinfo.location, body_tinfo.location,\n+\t\t\t       &guard_loc, &body_loc);\n+      const line_map *body_next_common_map\n+\t= first_map_in_common (line_table,\n+\t\t\t       body_tinfo.location, next_tinfo.location,\n+\t\t\t       &body_loc, &next_stmt_loc);\n+\n+      /* Punt on complicated nesting of macros.  */\n+      if (guard_body_common_map != body_next_common_map)\n+\treturn false;\n+\n+      guard_loc = linemap_resolve_location (line_table, guard_loc,\n+\t\t\t\t\t    LRK_MACRO_DEFINITION_LOCATION, NULL);\n+      body_loc = linemap_resolve_location (line_table, body_loc,\n+\t\t\t\t\t   LRK_MACRO_DEFINITION_LOCATION, NULL);\n+      next_stmt_loc = linemap_resolve_location (line_table, next_stmt_loc,\n+\t\t\t\t\t\tLRK_MACRO_DEFINITION_LOCATION,\n+\t\t\t\t\t\tNULL);\n+    }\n+\n+  /* Give up if the loci are not all distinct.  */\n+  if (guard_loc == body_loc || body_loc == next_stmt_loc)\n+    return false;\n+\n   expanded_location body_exploc = expand_location (body_loc);\n   expanded_location next_stmt_exploc = expand_location (next_stmt_loc);\n   expanded_location guard_exploc = expand_location (guard_loc);"}, {"sha": "61691aadff1c9f7af28e1fddb840126c38c279b0", "filename": "gcc/gensupport.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=4839de55e2c98619f4919254abb87e2f393aaead", "patch": "@@ -1501,7 +1501,7 @@ alter_attrs_for_subst_insn (class queue_elem * elem, int n_dup)\n \tcase SET_ATTR:\n \t  if (strchr (XSTR (sub, 1), ',') != NULL)\n \t    XSTR (sub, 1) = duplicate_alternatives (XSTR (sub, 1), n_dup);\n-\t    break;\n+\t  break;\n \n \tcase SET_ATTR_ALTERNATIVE:\n \tcase SET:"}, {"sha": "301c912cb21afb223b0a342b5815083164379b2a", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=4839de55e2c98619f4919254abb87e2f393aaead", "patch": "@@ -4776,12 +4776,12 @@ multi_block_pseudo_p (int regno)\n   if (regno < FIRST_PSEUDO_REGISTER)\n     return false;\n \n-    EXECUTE_IF_SET_IN_BITMAP (&lra_reg_info[regno].insn_bitmap, 0, uid, bi)\n-      if (bb == NULL)\n-\tbb = BLOCK_FOR_INSN (lra_insn_recog_data[uid]->insn);\n-      else if (BLOCK_FOR_INSN (lra_insn_recog_data[uid]->insn) != bb)\n-\treturn true;\n-    return false;\n+  EXECUTE_IF_SET_IN_BITMAP (&lra_reg_info[regno].insn_bitmap, 0, uid, bi)\n+    if (bb == NULL)\n+      bb = BLOCK_FOR_INSN (lra_insn_recog_data[uid]->insn);\n+    else if (BLOCK_FOR_INSN (lra_insn_recog_data[uid]->insn) != bb)\n+      return true;\n+  return false;\n }\n \n /* Return true if LIST contains a deleted insn.  */"}, {"sha": "c9959a7e1e8fa22d7a1820ac32fc9b9ab91add0f", "filename": "gcc/objc/objc-gnu-runtime-abi-01.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c?ref=4839de55e2c98619f4919254abb87e2f393aaead", "patch": "@@ -821,15 +821,15 @@ gnu_runtime_abi_01_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED,\n \tucls_super_ref =\n \t\tobjc_build_component_ref (imp->class_decl,\n \t\t\t\t\t  get_identifier (\"super_class\"));\n-\treturn ucls_super_ref;\n+      return ucls_super_ref;\n     }\n   else\n     {\n       if (!uucls_super_ref)\n \tuucls_super_ref =\n \t\tobjc_build_component_ref (imp->meta_decl,\n \t\t\t\t\t  get_identifier (\"super_class\"));\n-\treturn uucls_super_ref;\n+      return uucls_super_ref;\n     }\n }\n "}, {"sha": "233d89e75b545b87c7f6a67c1e5288bef9918d55", "filename": "gcc/objc/objc-next-runtime-abi-01.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c?ref=4839de55e2c98619f4919254abb87e2f393aaead", "patch": "@@ -938,15 +938,15 @@ next_runtime_abi_01_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED,\n \tucls_super_ref =\n \t\tobjc_build_component_ref (imp->class_decl,\n \t\t\t\t\t  get_identifier (\"super_class\"));\n-\treturn ucls_super_ref;\n+      return ucls_super_ref;\n     }\n   else\n     {\n       if (!uucls_super_ref)\n \tuucls_super_ref =\n \t\tobjc_build_component_ref (imp->meta_decl,\n \t\t\t\t\t  get_identifier (\"super_class\"));\n-\treturn uucls_super_ref;\n+      return uucls_super_ref;\n     }\n }\n "}, {"sha": "c8e086e49507e0360079631b8f84a71a5760871f", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=4839de55e2c98619f4919254abb87e2f393aaead", "patch": "@@ -722,63 +722,63 @@ merge_fences (fence_t f, insn_t insn,\n                         != BLOCK_FOR_INSN (last_scheduled_insn));\n           }\n \n-        /* Find edge of first predecessor (last_scheduled_insn_old->insn).  */\n-        FOR_EACH_SUCC_1 (succ, si, last_scheduled_insn_old,\n-                         SUCCS_NORMAL | SUCCS_SKIP_TO_LOOP_EXITS)\n-          {\n-            if (succ == insn)\n-              {\n-                /* No same successor allowed from several edges.  */\n-                gcc_assert (!edge_old);\n-                edge_old = si.e1;\n-              }\n-          }\n-        /* Find edge of second predecessor (last_scheduled_insn->insn).  */\n-        FOR_EACH_SUCC_1 (succ, si, last_scheduled_insn,\n-                         SUCCS_NORMAL | SUCCS_SKIP_TO_LOOP_EXITS)\n-          {\n-            if (succ == insn)\n-              {\n-                /* No same successor allowed from several edges.  */\n-                gcc_assert (!edge_new);\n-                edge_new = si.e1;\n-              }\n-          }\n+      /* Find edge of first predecessor (last_scheduled_insn_old->insn).  */\n+      FOR_EACH_SUCC_1 (succ, si, last_scheduled_insn_old,\n+\t\t       SUCCS_NORMAL | SUCCS_SKIP_TO_LOOP_EXITS)\n+\t{\n+\t  if (succ == insn)\n+\t    {\n+\t      /* No same successor allowed from several edges.  */\n+\t      gcc_assert (!edge_old);\n+\t      edge_old = si.e1;\n+\t    }\n+\t}\n+      /* Find edge of second predecessor (last_scheduled_insn->insn).  */\n+      FOR_EACH_SUCC_1 (succ, si, last_scheduled_insn,\n+\t\t       SUCCS_NORMAL | SUCCS_SKIP_TO_LOOP_EXITS)\n+\t{\n+\t  if (succ == insn)\n+\t    {\n+\t      /* No same successor allowed from several edges.  */\n+\t      gcc_assert (!edge_new);\n+\t      edge_new = si.e1;\n+\t    }\n+\t}\n \n-        /* Check if we can choose most probable predecessor.  */\n-        if (edge_old == NULL || edge_new == NULL)\n-          {\n-            reset_deps_context (FENCE_DC (f));\n-            delete_deps_context (dc);\n-            vec_free (executing_insns);\n-            free (ready_ticks);\n-\n-            FENCE_CYCLE (f) = MAX (FENCE_CYCLE (f), cycle);\n-            if (FENCE_EXECUTING_INSNS (f))\n-              FENCE_EXECUTING_INSNS (f)->block_remove (0,\n-                                FENCE_EXECUTING_INSNS (f)->length ());\n-            if (FENCE_READY_TICKS (f))\n-              memset (FENCE_READY_TICKS (f), 0, FENCE_READY_TICKS_SIZE (f));\n-          }\n-        else\n-          if (edge_new->probability > edge_old->probability)\n-            {\n-              delete_deps_context (FENCE_DC (f));\n-              FENCE_DC (f) = dc;\n-              vec_free (FENCE_EXECUTING_INSNS (f));\n-              FENCE_EXECUTING_INSNS (f) = executing_insns;\n-              free (FENCE_READY_TICKS (f));\n-              FENCE_READY_TICKS (f) = ready_ticks;\n-              FENCE_READY_TICKS_SIZE (f) = ready_ticks_size;\n-              FENCE_CYCLE (f) = cycle;\n-            }\n-          else\n-            {\n-              /* Leave DC and CYCLE untouched.  */\n-              delete_deps_context (dc);\n-              vec_free (executing_insns);\n-              free (ready_ticks);\n-            }\n+      /* Check if we can choose most probable predecessor.  */\n+      if (edge_old == NULL || edge_new == NULL)\n+\t{\n+\t  reset_deps_context (FENCE_DC (f));\n+\t  delete_deps_context (dc);\n+\t  vec_free (executing_insns);\n+\t  free (ready_ticks);\n+\n+\t  FENCE_CYCLE (f) = MAX (FENCE_CYCLE (f), cycle);\n+\t  if (FENCE_EXECUTING_INSNS (f))\n+\t    FENCE_EXECUTING_INSNS (f)->block_remove (0,\n+\t\t\t      FENCE_EXECUTING_INSNS (f)->length ());\n+\t  if (FENCE_READY_TICKS (f))\n+\t    memset (FENCE_READY_TICKS (f), 0, FENCE_READY_TICKS_SIZE (f));\n+\t}\n+      else\n+\tif (edge_new->probability > edge_old->probability)\n+\t  {\n+\t    delete_deps_context (FENCE_DC (f));\n+\t    FENCE_DC (f) = dc;\n+\t    vec_free (FENCE_EXECUTING_INSNS (f));\n+\t    FENCE_EXECUTING_INSNS (f) = executing_insns;\n+\t    free (FENCE_READY_TICKS (f));\n+\t    FENCE_READY_TICKS (f) = ready_ticks;\n+\t    FENCE_READY_TICKS_SIZE (f) = ready_ticks_size;\n+\t    FENCE_CYCLE (f) = cycle;\n+\t  }\n+\telse\n+\t  {\n+\t    /* Leave DC and CYCLE untouched.  */\n+\t    delete_deps_context (dc);\n+\t    vec_free (executing_insns);\n+\t    free (ready_ticks);\n+\t  }\n     }\n \n   /* Fill remaining invariant fields.  */"}, {"sha": "12b53569ba7570c979246f4391901131523eefe4", "filename": "gcc/testsuite/c-c++-common/Wmisleading-indentation-5.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839de55e2c98619f4919254abb87e2f393aaead/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-5.c?ref=4839de55e2c98619f4919254abb87e2f393aaead", "patch": "@@ -0,0 +1,56 @@\n+/* PR c/80076  */\n+/* { dg-options \"-Wmisleading-indentation\" }  */\n+\n+void foo(void);\n+\n+void test01(int flag) {\n+#define bar() foo() /* { dg-message \"this statement\" }  */\n+  if (flag) /* { dg-warning \"does not guard\" }  */\n+    foo();\n+    bar(); /* { dg-message \"in expansion of macro\" }  */\n+#undef bar\n+}\n+\n+void test02(int flag) {\n+#define bar() foo()\n+  if (flag) /* { dg-warning \"does not guard\" }  */\n+    bar();\n+    foo(); /* { dg-message \"this statement\" }  */\n+#undef bar\n+}\n+\n+void test03(int flag) {\n+#define bar() foo() /* { dg-message \"this statement\" }  */\n+  if (flag) /* { dg-warning \"does not guard\" }  */\n+    bar();\n+    bar(); /* { dg-message \"in expansion of macro\" }  */\n+#undef bar\n+}\n+\n+void test04(int flag, int num) {\n+#define bar() \\\n+  {\t\t\\\n+    if (flag)\t\\\n+      num = 0;\t\\\n+      num = 1;\t\\\n+  }\n+  bar();\n+/* { dg-warning \"does not guard\" \"\" { target *-*-* } .-5 }  */\n+/* { dg-message \"this statement\" \"\" { target *-*-* } .-4 }  */\n+#undef bar\n+}\n+\n+void test05(int flag, int num) {\n+#define baz() (num = 1)\n+#define bar() \\\n+  {\t\t\\\n+    if (flag)\t\\\n+      num = 0;\t\\\n+      baz();\t\\\n+  }\n+#define wrapper bar\n+  wrapper();\n+/* { dg-warning \"does not guard\" \"\" { target *-*-* } .-6 }  */\n+/* { dg-message \"this statement\" \"\" { target *-*-* } .-10 }  */\n+#undef bar\n+}"}, {"sha": "44008be5c084db32182a024365d9078ab03df5c0", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839de55e2c98619f4919254abb87e2f393aaead/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839de55e2c98619f4919254abb87e2f393aaead/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=4839de55e2c98619f4919254abb87e2f393aaead", "patch": "@@ -1225,6 +1225,12 @@ LINEMAP_SYSP (const line_map_ordinary *ord_map)\n   return ord_map->sysp;\n }\n \n+const struct line_map *first_map_in_common (line_maps *set,\n+\t\t\t\t\t    location_t loc0,\n+\t\t\t\t\t    location_t loc1,\n+\t\t\t\t\t    location_t *res_loc0,\n+\t\t\t\t\t    location_t *res_loc1);\n+\n /* Return a positive value if PRE denotes the location of a token that\n    comes before the token of POST, 0 if PRE denotes the location of\n    the same token as the token for POST, and a negative value"}, {"sha": "5a74174579f7d4435d73429ca7e2aacafa116218", "filename": "libcpp/line-map.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839de55e2c98619f4919254abb87e2f393aaead/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839de55e2c98619f4919254abb87e2f393aaead/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=4839de55e2c98619f4919254abb87e2f393aaead", "patch": "@@ -1289,7 +1289,7 @@ first_map_in_common_1 (line_maps *set,\n    virtual location of the token inside the resulting macro, upon\n    return of a non-NULL result.  */\n \n-static const struct line_map*\n+const struct line_map*\n first_map_in_common (line_maps *set,\n \t\t     location_t loc0,\n \t\t     location_t loc1,"}]}