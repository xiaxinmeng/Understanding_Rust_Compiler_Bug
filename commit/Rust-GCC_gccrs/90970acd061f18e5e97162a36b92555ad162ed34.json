{"sha": "90970acd061f18e5e97162a36b92555ad162ed34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA5NzBhY2QwNjFmMThlNWU5NzE2MmEzNmI5MjU1NWFkMTYyZWQzNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:19:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:19:08Z"}, "message": "[63/77] Simplifications after type switch\n\nThis patch makes a few simplifications after the previous\nmechanical machine_mode->scalar_int_mode change.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* expmed.c (extract_high_half): Use scalar_int_mode and remove\n\tassertion.\n\t(expmed_mult_highpart_optab): Likewise.\n\t(expmed_mult_highpart): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251514", "tree": {"sha": "8c7c40e3f29c6df23347ac91df8c5aa0f8fa17c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c7c40e3f29c6df23347ac91df8c5aa0f8fa17c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90970acd061f18e5e97162a36b92555ad162ed34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90970acd061f18e5e97162a36b92555ad162ed34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90970acd061f18e5e97162a36b92555ad162ed34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90970acd061f18e5e97162a36b92555ad162ed34/comments", "author": null, "committer": null, "parents": [{"sha": "095a2d76a26fa4ee17fa56bff21bf4f269db2368", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095a2d76a26fa4ee17fa56bff21bf4f269db2368", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095a2d76a26fa4ee17fa56bff21bf4f269db2368"}], "stats": {"total": 21, "additions": 12, "deletions": 9}, "files": [{"sha": "0ddf5d9f85169ebea053a8e95f9dc3e25f2ecc3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90970acd061f18e5e97162a36b92555ad162ed34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90970acd061f18e5e97162a36b92555ad162ed34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90970acd061f18e5e97162a36b92555ad162ed34", "patch": "@@ -1,3 +1,12 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* expmed.c (extract_high_half): Use scalar_int_mode and remove\n+\tassertion.\n+\t(expmed_mult_highpart_optab): Likewise.\n+\t(expmed_mult_highpart): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "10cf59c5c2e2cf64761a2c8233dfc0f13fb83e5f", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90970acd061f18e5e97162a36b92555ad162ed34/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90970acd061f18e5e97162a36b92555ad162ed34/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=90970acd061f18e5e97162a36b92555ad162ed34", "patch": "@@ -3672,14 +3672,11 @@ expand_mult_highpart_adjust (scalar_int_mode mode, rtx adj_operand, rtx op0,\n static rtx\n extract_high_half (scalar_int_mode mode, rtx op)\n {\n-  machine_mode wider_mode;\n-\n   if (mode == word_mode)\n     return gen_highpart (mode, op);\n \n-  gcc_assert (!SCALAR_FLOAT_MODE_P (mode));\n+  scalar_int_mode wider_mode = GET_MODE_WIDER_MODE (mode).require ();\n \n-  wider_mode = GET_MODE_WIDER_MODE (mode).require ();\n   op = expand_shift (RSHIFT_EXPR, wider_mode, op,\n \t\t     GET_MODE_BITSIZE (mode), 0, 1);\n   return convert_modes (mode, wider_mode, op, 0);\n@@ -3693,15 +3690,13 @@ expmed_mult_highpart_optab (scalar_int_mode mode, rtx op0, rtx op1,\n \t\t\t    rtx target, int unsignedp, int max_cost)\n {\n   rtx narrow_op1 = gen_int_mode (INTVAL (op1), mode);\n-  machine_mode wider_mode;\n   optab moptab;\n   rtx tem;\n   int size;\n   bool speed = optimize_insn_for_speed_p ();\n \n-  gcc_assert (!SCALAR_FLOAT_MODE_P (mode));\n+  scalar_int_mode wider_mode = GET_MODE_WIDER_MODE (mode).require ();\n \n-  wider_mode = GET_MODE_WIDER_MODE (mode).require ();\n   size = GET_MODE_BITSIZE (mode);\n \n   /* Firstly, try using a multiplication insn that only generates the needed\n@@ -3807,7 +3802,6 @@ static rtx\n expmed_mult_highpart (scalar_int_mode mode, rtx op0, rtx op1,\n \t\t      rtx target, int unsignedp, int max_cost)\n {\n-  machine_mode wider_mode = GET_MODE_WIDER_MODE (mode).require ();\n   unsigned HOST_WIDE_INT cnst1;\n   int extra_cost;\n   bool sign_adjust = false;\n@@ -3816,7 +3810,6 @@ expmed_mult_highpart (scalar_int_mode mode, rtx op0, rtx op1,\n   rtx tem;\n   bool speed = optimize_insn_for_speed_p ();\n \n-  gcc_assert (!SCALAR_FLOAT_MODE_P (mode));\n   /* We can't support modes wider than HOST_BITS_PER_INT.  */\n   gcc_assert (HWI_COMPUTABLE_MODE_P (mode));\n \n@@ -3826,6 +3819,7 @@ expmed_mult_highpart (scalar_int_mode mode, rtx op0, rtx op1,\n      ??? We might be able to perform double-word arithmetic if\n      mode == word_mode, however all the cost calculations in\n      synth_mult etc. assume single-word operations.  */\n+  scalar_int_mode wider_mode = GET_MODE_WIDER_MODE (mode).require ();\n   if (GET_MODE_BITSIZE (wider_mode) > BITS_PER_WORD)\n     return expmed_mult_highpart_optab (mode, op0, op1, target,\n \t\t\t\t       unsignedp, max_cost);"}]}