{"sha": "2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI1ZTU2NDJlMzhlMTdkYzYwY2E2NDA4ZjRjMmJiYTY1MWUxYTlmNw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-02-19T00:14:14Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-02-19T00:14:14Z"}, "message": "builtins.c (fold_builtin_load_exponent): New.\n\n\t* builtins.c (fold_builtin_load_exponent): New.\n\t(fold_builtin_2): Use it.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-ldexp-1.c: New.\n\t* gcc.dg/torture/builtin-math-2.c: Add ldexp/scalbn/scalbln cases.\n\nFrom-SVN: r122110", "tree": {"sha": "babf6d5403706c64a7b61121e9130ad9e98c1c90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/babf6d5403706c64a7b61121e9130ad9e98c1c90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7/comments", "author": null, "committer": null, "parents": [{"sha": "278a7a38aec08c52f341a3632f0f772063629ecf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/278a7a38aec08c52f341a3632f0f772063629ecf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/278a7a38aec08c52f341a3632f0f772063629ecf"}], "stats": {"total": 349, "additions": 348, "deletions": 1}, "files": [{"sha": "ff24358403de985e4f0f15d7c51ef5436004501a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7", "patch": "@@ -1,3 +1,8 @@\n+2007-02-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (fold_builtin_load_exponent): New.\n+\t(fold_builtin_2): Use it.\n+\n 2007-02-18  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR rtl-optimization/30773"}, {"sha": "67d9bf63f2558501e33b4c84de53f998f1e5c8cc", "filename": "gcc/builtins.c", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7", "patch": "@@ -9000,6 +9000,67 @@ fold_builtin_carg (tree arg, tree type)\n   return NULL_TREE;\n }\n \n+/* Fold a call to builtin ldexp or scalbn/scalbln.  If LDEXP is true\n+   then we can assume the base is two.  If it's false, then we have to\n+   check the mode of the TYPE parameter in certain cases.  */\n+\n+static tree\n+fold_builtin_load_exponent (tree arg0, tree arg1, tree type, bool ldexp)\n+{\n+  if (validate_arg (arg0, REAL_TYPE) && validate_arg (arg1, INTEGER_TYPE))\n+    {\n+      STRIP_NOPS (arg0);\n+      STRIP_NOPS (arg1);\n+\n+      /* If arg0 is 0, Inf or NaN, or if arg1 is 0, then return arg0.  */\n+      if (real_zerop (arg0) || integer_zerop (arg1)\n+\t  || (TREE_CODE (arg0) == REAL_CST\n+\t      && (real_isnan (&TREE_REAL_CST (arg0))\n+\t\t  || real_isinf (&TREE_REAL_CST (arg0)))))\n+\treturn omit_one_operand (type, arg0, arg1);\n+      \n+      /* If both arguments are constant, then try to evaluate it.  */\n+      if ((ldexp || REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2)\n+\t  && TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0)\n+\t  && host_integerp (arg1, 0))\n+        {\n+\t  /* Bound the maximum adjustment to twice the range of the\n+\t     mode's valid exponents.  Use abs to ensure the range is\n+\t     positive as a sanity check.  */\n+\t  const long max_exp_adj = 2 * \n+\t    labs (REAL_MODE_FORMAT (TYPE_MODE (type))->emax\n+\t\t - REAL_MODE_FORMAT (TYPE_MODE (type))->emin);\n+\n+\t  /* Get the user-requested adjustment.  */\n+\t  const HOST_WIDE_INT req_exp_adj = tree_low_cst (arg1, 0);\n+\t  \n+\t  /* The requested adjustment must be inside this range.  This\n+\t     is a preliminary cap to avoid things like overflow, we\n+\t     may still fail to compute the result for other reasons.  */\n+\t  if (-max_exp_adj < req_exp_adj && req_exp_adj < max_exp_adj)\n+\t    {\n+\t      REAL_VALUE_TYPE initial_result;\n+\t      \n+\t      real_ldexp (&initial_result, &TREE_REAL_CST (arg0), req_exp_adj);\n+\n+\t      /* Ensure we didn't overflow.  */\n+\t      if (! real_isinf (&initial_result))\n+\t        {\n+\t\t  const REAL_VALUE_TYPE trunc_result\n+\t\t    = real_value_truncate (TYPE_MODE (type), initial_result);\n+\t\t  \n+\t\t  /* Only proceed if the target mode can hold the\n+\t\t     resulting value.  */\n+\t\t  if (REAL_VALUES_EQUAL (initial_result, trunc_result))\n+\t\t    return build_real (type, trunc_result);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Fold a call to __builtin_isnan(), __builtin_isinf, __builtin_finite.\n    ARG is the argument for the call.  */\n \n@@ -9460,6 +9521,12 @@ fold_builtin_2 (tree fndecl, tree arg0, tree arg1, bool ignore)\n     CASE_FLT_FN (BUILT_IN_HYPOT):\n       return fold_builtin_hypot (fndecl, arg0, arg1, type);\n \n+    CASE_FLT_FN (BUILT_IN_LDEXP):\n+      return fold_builtin_load_exponent (arg0, arg1, type, /*ldexp=*/true);\n+    CASE_FLT_FN (BUILT_IN_SCALBN):\n+    CASE_FLT_FN (BUILT_IN_SCALBLN):\n+      return fold_builtin_load_exponent (arg0, arg1, type, /*ldexp=*/false);\n+\n     case BUILT_IN_BZERO:\n       return fold_builtin_bzero (arg0, arg1, ignore);\n "}, {"sha": "06f560e7c779e85cf5c1d1f4efbb8d465d0d47da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7", "patch": "@@ -1,3 +1,8 @@\n+2007-02-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-ldexp-1.c: New.\n+\t* gcc.dg/torture/builtin-math-2.c: Add ldexp/scalbn/scalbln cases.\n+\n 2007-02-18  Roger Sayle  <roger@eyesopen.com>\n \n \t* gfortran.dg/array_constructor_15.f90: New test case."}, {"sha": "aa9906fb442d53b16d3568ebb6b2e4d1ed9dc809", "filename": "gcc/testsuite/gcc.dg/torture/builtin-ldexp-1.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-ldexp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-ldexp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-ldexp-1.c?ref=2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7", "patch": "@@ -0,0 +1,203 @@\n+/* Copyright (C) 2007  Free Software Foundation.\n+\n+   Verify that built-in folding of ldexp et al. is correctly performed\n+   by the compiler.\n+\n+   Origin: Kaveh R. Ghazi,  February 17, 2007.  */\n+\n+/* { dg-do link } */\n+\n+extern void link_error(int);\n+\n+/* Return TRUE if the sign of X != sign of Y.  This is important when\n+   comparing signed zeros.  */\n+#define CKSGN_F(X,Y) \\\n+  (__builtin_copysignf(1.0F,(X)) != __builtin_copysignf(1.0F,(Y)))\n+#define CKSGN(X,Y) \\\n+  (__builtin_copysign(1.0,(X)) != __builtin_copysign(1.0,(Y)))\n+#define CKSGN_L(X,Y) \\\n+  (__builtin_copysignl(1.0L,(X)) != __builtin_copysignl(1.0L,(Y)))\n+\n+/* Test that FUNC(ARG1,ARG2) == RES.  Check the sign for -0.0.  */\n+#define TESTIT(FUNC,ARG1,ARG2,RES) do { \\\n+  if (__builtin_##FUNC##f(ARG1##f,ARG2) != RES##f \\\n+      || CKSGN(__builtin_##FUNC##f(ARG1##f,ARG2),RES##f)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG1,ARG2) != RES \\\n+      || CKSGN(__builtin_##FUNC(ARG1,ARG2),RES)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG1##l,ARG2) != RES##l \\\n+      || CKSGN(__builtin_##FUNC##l(ARG1##l,ARG2),RES##l)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+/* Test that (long)FUNC(ARG1,ARG2) == (long)RES.  The cast is\n+   necessary when RES is not a constant.  */\n+#define TESTIT2(FUNC,ARG1,ARG2,RES) do { \\\n+  if ((long)__builtin_##FUNC##f(ARG1##f,ARG2) != (long)RES##f) \\\n+    link_error(__LINE__); \\\n+  if ((long)__builtin_##FUNC(ARG1,ARG2) != (long)RES) \\\n+    link_error(__LINE__); \\\n+  if ((long)__builtin_##FUNC##l(ARG1##l,ARG2) != (long)RES##l) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+/* Test that FUNCRES(FUNC(NEG FUNCARG(ARGARG),ARG2)) is false.  Check\n+   the sign as well.  */\n+#define TESTIT3(FUNC,NEG,FUNCARG,ARGARG,ARG2,FUNCRES) do { \\\n+  if (!__builtin_##FUNCRES##f(__builtin_##FUNC##f(NEG __builtin_##FUNCARG##f(ARGARG),ARG2)) \\\n+      || CKSGN(__builtin_##FUNC##f(NEG __builtin_##FUNCARG##f(ARGARG),ARG2), NEG __builtin_##FUNCARG##f(ARGARG))) \\\n+    link_error(__LINE__); \\\n+  if (!__builtin_##FUNCRES(__builtin_##FUNC(NEG __builtin_##FUNCARG(ARGARG),ARG2)) \\\n+      || CKSGN(__builtin_##FUNC(NEG __builtin_##FUNCARG(ARGARG),ARG2), NEG __builtin_##FUNCARG(ARGARG))) \\\n+    link_error(__LINE__); \\\n+  if (!__builtin_##FUNCRES##l(__builtin_##FUNC##l(NEG __builtin_##FUNCARG##l(ARGARG),ARG2)) \\\n+      || CKSGN(__builtin_##FUNC##l(NEG __builtin_##FUNCARG##l(ARGARG),ARG2), NEG __builtin_##FUNCARG##l(ARGARG))) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+/* Using foo==MIN/MAX float values, test that FUNC(foo,EXP) == foo*exp2(EXP),\n+   and also that FUNC(foo,-EXP) == foo*exp2(-EXP).  */\n+#define TESTIT4(FUNC,EXP) do { \\\n+  if (__builtin_##FUNC##f(__FLT_MIN__,EXP) != __FLT_MIN__*__builtin_exp2f(EXP)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##f(-__FLT_MIN__,EXP) != -__FLT_MIN__*__builtin_exp2f(EXP)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(__DBL_MIN__,EXP) != __DBL_MIN__*__builtin_exp2(EXP)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(-__DBL_MIN__,EXP) != -__DBL_MIN__*__builtin_exp2(EXP)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(__LDBL_MIN__,EXP) != __LDBL_MIN__*__builtin_exp2l(EXP)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(-__LDBL_MIN__,EXP) != -__LDBL_MIN__*__builtin_exp2l(EXP)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##f(__FLT_MAX__,-EXP) != __FLT_MAX__*__builtin_exp2f(-EXP)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##f(-__FLT_MAX__,-EXP) != -__FLT_MAX__*__builtin_exp2f(-EXP)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(__DBL_MAX__,-EXP) != __DBL_MAX__*__builtin_exp2(-EXP)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(-__DBL_MAX__,-EXP) != -__DBL_MAX__*__builtin_exp2(-EXP)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(__LDBL_MAX__,-EXP) != __LDBL_MAX__*__builtin_exp2l(-EXP)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(-__LDBL_MAX__,-EXP) != -__LDBL_MAX__*__builtin_exp2l(-EXP)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+void __attribute__ ((__noinline__))\n+foo(float xf, double x, long double xl, int i, long l)\n+{\n+  /* f(0.0, i) -> 0.0 and f(-0.0, i) -> -0.0.  */\n+  TESTIT (ldexp, 0.0, i, 0.0);\n+  TESTIT (ldexp, -0.0, i, -0.0);\n+  TESTIT (scalbn, 0.0, i, 0.0);\n+  TESTIT (scalbn, -0.0, i, -0.0);\n+  TESTIT (scalbln, 0.0, l, 0.0);\n+  TESTIT (scalbln, -0.0, l, -0.0);\n+  \n+  /* f(x,0) -> x.  */\n+  TESTIT2 (ldexp, x, 0, x);\n+  TESTIT2 (scalbn, x, 0, x);\n+  TESTIT2 (scalbln, x, 0, x);\n+\n+  /* f(Inf,i) -> Inf and f(NaN,i) -> NaN.  */\n+  TESTIT3 (ldexp, , inf, , i, isinf);\n+  TESTIT3 (ldexp, -, inf, , i, isinf);\n+  TESTIT3 (ldexp, , nan, \"\", i, isnan);\n+  TESTIT3 (ldexp, -, nan, \"\", i, isnan);\n+\n+  TESTIT3 (scalbn, , inf, , i, isinf);\n+  TESTIT3 (scalbn, -, inf, , i, isinf);\n+  TESTIT3 (scalbn, , nan, \"\", i, isnan);\n+  TESTIT3 (scalbn, -, nan, \"\", i, isnan);\n+\n+  TESTIT3 (scalbln, , inf, , i, isinf);\n+  TESTIT3 (scalbln, -, inf, , i, isinf);\n+  TESTIT3 (scalbln, , nan, \"\", i, isnan);\n+  TESTIT3 (scalbln, -, nan, \"\", i, isnan);\n+\n+  /* Evaluate when both arguments are constant.  */\n+  TESTIT (ldexp, 5.0, 3, 40.0);\n+  TESTIT (ldexp, -5.0, 3, -40.0);\n+  TESTIT (ldexp, 5.0, -3, 0.625);\n+  TESTIT (ldexp, -5.0, -3, -0.625);\n+\n+  TESTIT (ldexp, 1000.0, 5, 32000.0);\n+  TESTIT (ldexp, -1000.0, 5, -32000.0);\n+  TESTIT (ldexp, 1000.0, -5, 31.25);\n+  TESTIT (ldexp, -1000.0, -5, -31.25);\n+\n+  /* f(x,N) -> x*exp2(N), using MIN/MAX constants for x and constant N.  */\n+  TESTIT4 (ldexp, 1);\n+  TESTIT4 (ldexp, 2);\n+  TESTIT4 (ldexp, 3);\n+  TESTIT4 (ldexp, 5);\n+  TESTIT4 (ldexp, 9);\n+  TESTIT4 (ldexp, 10);\n+  TESTIT4 (ldexp, 12);\n+  TESTIT4 (ldexp, 18);\n+  TESTIT4 (ldexp, 25);\n+  TESTIT4 (ldexp, 50);\n+  TESTIT4 (ldexp, 75);\n+  TESTIT4 (ldexp, 100);\n+  TESTIT4 (ldexp, 123);\n+\n+  /* These are folded when float radix is two.  */\n+#if __FLT_RADIX__ == 2\n+  TESTIT (scalbn, 5.0, 3, 40.0);\n+  TESTIT (scalbn, -5.0, 3, -40.0);\n+  TESTIT (scalbn, 5.0, -3, 0.625);\n+  TESTIT (scalbn, -5.0, -3, -0.625);\n+\n+  TESTIT (scalbn, 1000.0, 5, 32000.0);\n+  TESTIT (scalbn, -1000.0, 5, -32000.0);\n+  TESTIT (scalbn, 1000.0, -5, 31.25);\n+  TESTIT (scalbn, -1000.0, -5, -31.25);\n+\n+  TESTIT4 (scalbn, 1);\n+  TESTIT4 (scalbn, 2);\n+  TESTIT4 (scalbn, 3);\n+  TESTIT4 (scalbn, 5);\n+  TESTIT4 (scalbn, 9);\n+  TESTIT4 (scalbn, 10);\n+  TESTIT4 (scalbn, 12);\n+  TESTIT4 (scalbn, 18);\n+  TESTIT4 (scalbn, 25);\n+  TESTIT4 (scalbn, 50);\n+  TESTIT4 (scalbn, 75);\n+  TESTIT4 (scalbn, 100);\n+  TESTIT4 (scalbn, 123);\n+\n+  TESTIT (scalbln, 5.0, 3, 40.0);\n+  TESTIT (scalbln, -5.0, 3, -40.0);\n+  TESTIT (scalbln, 5.0, -3, 0.625);\n+  TESTIT (scalbln, -5.0, -3, -0.625);\n+\n+  TESTIT (scalbln, 1000.0, 5, 32000.0);\n+  TESTIT (scalbln, -1000.0, 5, -32000.0);\n+  TESTIT (scalbln, 1000.0, -5, 31.25);\n+  TESTIT (scalbln, -1000.0, -5, -31.25);\n+\n+  TESTIT4 (scalbln, 1);\n+  TESTIT4 (scalbln, 2);\n+  TESTIT4 (scalbln, 3);\n+  TESTIT4 (scalbln, 5);\n+  TESTIT4 (scalbln, 9);\n+  TESTIT4 (scalbln, 10);\n+  TESTIT4 (scalbln, 12);\n+  TESTIT4 (scalbln, 18);\n+  TESTIT4 (scalbln, 25);\n+  TESTIT4 (scalbln, 50);\n+  TESTIT4 (scalbln, 75);\n+  TESTIT4 (scalbln, 100);\n+  TESTIT4 (scalbln, 123);\n+#endif\n+}\n+\n+int main()\n+{\n+  foo (0, 0, 0, 0, 0);\n+  \n+  return 0;\n+}"}, {"sha": "7c6fad0d6282abe8b37116c2bc59c0ceec832b26", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-2.c", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c?ref=2b5e5642e38e17dc60ca6408f4c2bba651e1a9f7", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2006  Free Software Foundation.\n+/* Copyright (C) 2006, 2007  Free Software Foundation.\n \n    Test things that should block GCC from optimizing compile-time\n    constants passed to a builtin transcendental function.\n@@ -24,6 +24,18 @@ extern void fool (long double);\n   fool (__builtin_##FUNC##l (ARG1##L, ARG2##L)); \\\n } while (0)\n \n+#define TESTIT2_I2ALL(FUNC, ARGF, MAXF, ARGD, MAXD, ARGLD, MAXLD) do { \\\n+  foof (__builtin_##FUNC##f (ARGF, MAXF)); \\\n+  foo (__builtin_##FUNC (ARGD, MAXD)); \\\n+  fool (__builtin_##FUNC##l (ARGLD, MAXLD)); \\\n+} while (0)\n+\n+#define TESTIT2_I2(FUNC, ARG1, ARG2) do { \\\n+  foof (__builtin_##FUNC##f (ARG1##F, ARG2)); \\\n+  foo (__builtin_##FUNC (ARG1, ARG2)); \\\n+  fool (__builtin_##FUNC##l (ARG1##L, ARG2)); \\\n+} while (0)\n+\n void bar()\n {\n   /* An argument of NaN is not evaluated at compile-time.  */\n@@ -150,6 +162,52 @@ void bar()\n   TESTIT (sqrt, -0.5);\n   TESTIT (sqrt, -0.0);\n   TESTIT (sqrt, 0.0);\n+\n+  /* Check for overflow/underflow.  */\n+\n+  /* These adjustments are too big.  */\n+#define FLT_EXP_ADJ (2*(__FLT_MAX_EXP__-__FLT_MIN_EXP__)+1)\n+#define DBL_EXP_ADJ (2*(__DBL_MAX_EXP__-__DBL_MIN_EXP__)+1)\n+#define LDBL_EXP_ADJ (2*(__LDBL_MAX_EXP__-__LDBL_MIN_EXP__)+1)\n+\n+  TESTIT2_I2 (ldexp, 1.0, __INT_MAX__);\n+  TESTIT2_I2 (ldexp, 1.0, -__INT_MAX__-1);\n+  TESTIT2_I2 (ldexp, -1.0, __INT_MAX__);\n+  TESTIT2_I2 (ldexp, -1.0, -__INT_MAX__-1);\n+  TESTIT2_I2ALL (ldexp, __FLT_MIN__, FLT_EXP_ADJ, __DBL_MIN__,\n+\t\t DBL_EXP_ADJ, __LDBL_MIN__, LDBL_EXP_ADJ);\n+  TESTIT2_I2ALL (ldexp, __FLT_MAX__, -FLT_EXP_ADJ, __DBL_MAX__,\n+\t\t -DBL_EXP_ADJ, __LDBL_MAX__, -LDBL_EXP_ADJ);\n+  TESTIT2_I2ALL (ldexp, __FLT_MIN__, __FLT_MIN_EXP__, __DBL_MIN__,\n+\t\t __DBL_MIN_EXP__, __LDBL_MIN__, __LDBL_MIN_EXP__);\n+  TESTIT2_I2ALL (ldexp, __FLT_MAX__, __FLT_MAX_EXP__, __DBL_MAX__,\n+\t\t __DBL_MAX_EXP__, __LDBL_MAX__, __LDBL_MAX_EXP__);\n+\n+  TESTIT2_I2 (scalbn, 1.0, __INT_MAX__);\n+  TESTIT2_I2 (scalbn, 1.0, -__INT_MAX__-1);\n+  TESTIT2_I2 (scalbn, -1.0, __INT_MAX__);\n+  TESTIT2_I2 (scalbn, -1.0, -__INT_MAX__-1);\n+  TESTIT2_I2ALL (scalbn, __FLT_MIN__, FLT_EXP_ADJ, __DBL_MIN__,\n+\t\t DBL_EXP_ADJ, __LDBL_MIN__, LDBL_EXP_ADJ);\n+  TESTIT2_I2ALL (scalbn, __FLT_MAX__, -FLT_EXP_ADJ, __DBL_MAX__,\n+\t\t -DBL_EXP_ADJ, __LDBL_MAX__, -LDBL_EXP_ADJ);\n+  TESTIT2_I2ALL (scalbn, __FLT_MIN__, __FLT_MIN_EXP__, __DBL_MIN__,\n+\t\t __DBL_MIN_EXP__, __LDBL_MIN__, __LDBL_MIN_EXP__);\n+  TESTIT2_I2ALL (scalbn, __FLT_MAX__, __FLT_MAX_EXP__, __DBL_MAX__,\n+\t\t __DBL_MAX_EXP__, __LDBL_MAX__, __LDBL_MAX_EXP__);\n+\n+  TESTIT2_I2 (scalbln, 1.0, __LONG_MAX__);\n+  TESTIT2_I2 (scalbln, 1.0, -__LONG_MAX__-1);\n+  TESTIT2_I2 (scalbln, -1.0, __LONG_MAX__);\n+  TESTIT2_I2 (scalbln, -1.0, -__LONG_MAX__-1);\n+  TESTIT2_I2ALL (scalbln, __FLT_MIN__, FLT_EXP_ADJ, __DBL_MIN__,\n+\t\t DBL_EXP_ADJ, __LDBL_MIN__, LDBL_EXP_ADJ);\n+  TESTIT2_I2ALL (scalbln, __FLT_MAX__, -FLT_EXP_ADJ, __DBL_MAX__,\n+\t\t -DBL_EXP_ADJ, __LDBL_MAX__, -LDBL_EXP_ADJ);\n+  TESTIT2_I2ALL (scalbln, __FLT_MIN__, __FLT_MIN_EXP__, __DBL_MIN__,\n+\t\t __DBL_MIN_EXP__, __LDBL_MIN__, __LDBL_MIN_EXP__);\n+  TESTIT2_I2ALL (scalbln, __FLT_MAX__, __FLT_MAX_EXP__, __DBL_MAX__,\n+\t\t __DBL_MAX_EXP__, __LDBL_MAX__, __LDBL_MAX_EXP__);\n }\n \n /* { dg-final { scan-tree-dump-times \"exp2 \" 9 \"original\" } } */\n@@ -191,4 +249,13 @@ void bar()\n /* { dg-final { scan-tree-dump-times \"sqrt \" 1 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"sqrtf\" 1 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"sqrtl\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"ldexp \" 8 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"ldexpf\" 8 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"ldexpl\" 8 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"scalbn \" 8 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"scalbnf\" 8 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"scalbnl\" 8 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"scalbln \" 8 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"scalblnf\" 8 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"scalblnl\" 8 \"original\" } } */\n /* { dg-final { cleanup-tree-dump \"original\" } } */"}]}