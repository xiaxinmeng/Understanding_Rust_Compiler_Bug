{"sha": "e3d51be28110e27f893dda4867542958706db1d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNkNTFiZTI4MTEwZTI3Zjg5M2RkYTQ4Njc1NDI5NTg3MDZkYjFkNg==", "commit": {"author": {"name": "Gawain Bolton", "email": "gp.bolton@computer.org", "date": "2003-07-06T00:58:52Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-07-06T00:58:52Z"}, "message": "stl_list.h: Performance and memory usage improvements.\n\n\n2003-07-05  Gawain Bolton  <gp.bolton@computer.org>\n\n\t* include/bits/stl_list.h: Performance and memory usage\n\timprovements.\n\t* include/bits/list.tcc: Likewise.\n\nFrom-SVN: r68987", "tree": {"sha": "f3916372f400bb1696c91447551c59618f31a9e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3916372f400bb1696c91447551c59618f31a9e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3d51be28110e27f893dda4867542958706db1d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d51be28110e27f893dda4867542958706db1d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3d51be28110e27f893dda4867542958706db1d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d51be28110e27f893dda4867542958706db1d6/comments", "author": null, "committer": null, "parents": [{"sha": "a045c794055ab801f3a0c774174c8cd2f1dd4c6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a045c794055ab801f3a0c774174c8cd2f1dd4c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a045c794055ab801f3a0c774174c8cd2f1dd4c6d"}], "stats": {"total": 88, "additions": 62, "deletions": 26}, "files": [{"sha": "7d1d6262861832a4ee1fbeb3d914c31bed1fe067", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3d51be28110e27f893dda4867542958706db1d6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3d51be28110e27f893dda4867542958706db1d6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e3d51be28110e27f893dda4867542958706db1d6", "patch": "@@ -1,3 +1,9 @@\n+2003-07-05  Gawain Bolton  <gp.bolton@computer.org>\n+\n+\t* include/bits/stl_list.h: Performance and memory usage\n+\timprovements.\n+\t* include/bits/list.tcc: Likewise.\n+\n 2003-07-05  Paolo Carlini  <pcarlini@unitus.it>\n \n \t* include/std/std_complex.h: Fully qualify standard"}, {"sha": "2afde96995a24796f9219f4712a742599ca4258b", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3d51be28110e27f893dda4867542958706db1d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3d51be28110e27f893dda4867542958706db1d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=e3d51be28110e27f893dda4867542958706db1d6", "patch": "@@ -69,18 +69,51 @@ namespace std\n     __clear()\n     {\n       typedef _List_node<_Tp>  _Node;\n-      _Node* __cur = static_cast<_Node*>(this->_M_node->_M_next);\n-      while (__cur != this->_M_node)\n+      _Node* __cur = static_cast<_Node*>(this->_M_node._M_next);\n+      while (__cur != &this->_M_node)\n       {\n         _Node* __tmp = __cur;\n         __cur = static_cast<_Node*>(__cur->_M_next);\n         std::_Destroy(&__tmp->_M_data);\n         _M_put_node(__tmp);\n       }\n-      this->_M_node->_M_next = this->_M_node;\n-      this->_M_node->_M_prev = this->_M_node;\n+      this->_M_node._M_next = &this->_M_node;\n+      this->_M_node._M_prev = &this->_M_node;\n     }\n   \n+  template<typename _Tp, typename _Alloc>\n+    void list<_Tp, _Alloc>::\n+    swap(list<_Tp, _Alloc>& __x)\n+    {\n+      if ( this->_M_node._M_next == &this->_M_node )\n+      {\n+        if ( __x._M_node._M_next != &__x._M_node )\n+        {\n+          this->_M_node._M_next = __x._M_node._M_next;\n+          this->_M_node._M_prev = __x._M_node._M_prev;\n+          \n+          this->_M_node._M_next->_M_prev = this->_M_node._M_prev->_M_next = &this->_M_node;\n+          __x._M_node._M_next = __x._M_node._M_prev = &__x._M_node;\n+        }\n+      }\n+      else if ( __x._M_node._M_next == &__x._M_node )\n+      {\n+        __x._M_node._M_next = this->_M_node._M_next;\n+        __x._M_node._M_prev = this->_M_node._M_prev;\n+        \n+        __x._M_node._M_next->_M_prev = __x._M_node._M_prev->_M_next = &__x._M_node;\n+        this->_M_node._M_next = this->_M_node._M_prev = &this->_M_node;\n+      }\n+      else\n+      {\n+        std::swap(this->_M_node._M_next,__x._M_node._M_next);\n+        std::swap(this->_M_node._M_prev,__x._M_node._M_prev);\n+      \n+        this->_M_node._M_next->_M_prev = this->_M_node._M_prev->_M_next = &this->_M_node;\n+        __x._M_node._M_next->_M_prev = __x._M_node._M_prev->_M_next = &__x._M_node;\n+      } \n+    }\n+ \n   template<typename _Tp, typename _Alloc>\n     typename list<_Tp,_Alloc>::iterator\n     list<_Tp,_Alloc>::\n@@ -250,8 +283,8 @@ namespace std\n     sort()\n     {\n       // Do nothing if the list has length 0 or 1.\n-      if (this->_M_node->_M_next != this->_M_node \n-\t  && this->_M_node->_M_next->_M_next != this->_M_node)\n+      if (this->_M_node._M_next != &this->_M_node \n+\t  && this->_M_node._M_next->_M_next != &this->_M_node)\n       {\n         list __carry;\n         list __counter[64];\n@@ -341,8 +374,8 @@ namespace std\n     sort(_StrictWeakOrdering __comp)\n     {\n       // Do nothing if the list has length 0 or 1.\n-      if (this->_M_node->_M_next != this->_M_node && \n-\t  this->_M_node->_M_next->_M_next != this->_M_node)\n+      if (this->_M_node._M_next != &this->_M_node && \n+\t  this->_M_node._M_next->_M_next != &this->_M_node)\n       {\n         list __carry;\n         list __counter[64];"}, {"sha": "6f5579e3770fab155c58e5f4964a8454fbd7a12f", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3d51be28110e27f893dda4867542958706db1d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3d51be28110e27f893dda4867542958706db1d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=e3d51be28110e27f893dda4867542958706db1d6", "patch": "@@ -247,7 +247,7 @@ namespace std\n     typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type\n              _M_node_allocator;\n   \n-    _List_node<_Tp>* _M_node;\n+    _List_node_base _M_node;\n   };\n   \n   /// @if maint Specialization for instanceless allocators.  @endif\n@@ -278,7 +278,7 @@ namespace std\n     _M_put_node(_List_node<_Tp>* __p)\n     { _Alloc_type::deallocate(__p, 1); }\n   \n-    _List_node<_Tp>* _M_node;\n+    _List_node_base _M_node;\n   };\n   \n   \n@@ -301,16 +301,14 @@ namespace std\n     _List_base(const allocator_type& __a)\n     : _Base(__a)\n     {\n-      this->_M_node = _M_get_node();\n-      this->_M_node->_M_next = this->_M_node;\n-      this->_M_node->_M_prev = this->_M_node;\n+      this->_M_node._M_next = &this->_M_node;\n+      this->_M_node._M_prev = &this->_M_node;\n     }\n   \n     // This is what actually destroys the list.\n     ~_List_base()\n     {\n       __clear();\n-      _M_put_node(this->_M_node);\n     }\n   \n     void\n@@ -376,8 +374,8 @@ namespace std\n     typedef const value_type*                             const_pointer;\n     typedef _List_iterator<_Tp,_Tp&,_Tp*>                 iterator;\n     typedef _List_iterator<_Tp,const _Tp&,const _Tp*>     const_iterator;\n-    typedef std::reverse_iterator<const_iterator>     const_reverse_iterator;\n-    typedef std::reverse_iterator<iterator>                 reverse_iterator;\n+    typedef std::reverse_iterator<const_iterator>         const_reverse_iterator;\n+    typedef std::reverse_iterator<iterator>               reverse_iterator;\n     typedef value_type&                                   reference;\n     typedef const value_type&                             const_reference;\n     typedef size_t                                        size_type;\n@@ -506,11 +504,11 @@ namespace std\n       { this->insert(begin(), __first, __last); }\n   \n     /**\n-     *  The dtor only erases the elements, and note that if the elements\n+     *  No explicit dtor needed as the _Base dtor takes care of things.\n+     *  The _Base dtor only erases the elements, and note that if the elements\n      *  themselves are pointers, the pointed-to memory is not touched in any\n      *  way.  Managing the pointer is the user's responsibilty.\n     */\n-    ~list() { }\n   \n     /**\n      *  @brief  %List assignment operator.\n@@ -566,28 +564,28 @@ namespace std\n      *  %list.  Iteration is done in ordinary element order.\n     */\n     iterator\n-    begin() { return static_cast<_Node*>(this->_M_node->_M_next); }\n+    begin() { return static_cast<_Node*>(this->_M_node._M_next); }\n   \n     /**\n      *  Returns a read-only (constant) iterator that points to the first element\n      *  in the %list.  Iteration is done in ordinary element order.\n     */\n     const_iterator\n-    begin() const { return static_cast<_Node*>(this->_M_node->_M_next); }\n+    begin() const { return static_cast<_Node*>(this->_M_node._M_next); }\n   \n     /**\n      *  Returns a read/write iterator that points one past the last element in\n      *  the %list.  Iteration is done in ordinary element order.\n     */\n     iterator\n-    end() { return this->_M_node; }\n+    end() { return static_cast<_Node*>(&this->_M_node); }\n   \n     /**\n      *  Returns a read-only (constant) iterator that points one past the last\n      *  element in the %list.  Iteration is done in ordinary element order.\n     */\n     const_iterator\n-    end() const { return this->_M_node; }\n+    end() const { return const_cast<_Node *>(static_cast<const _Node*>(&this->_M_node)); }\n   \n     /**\n      *  Returns a read/write reverse iterator that points to the last element in\n@@ -625,7 +623,7 @@ namespace std\n      *  Returns true if the %list is empty.  (Thus begin() would equal end().)\n     */\n     bool\n-    empty() const { return this->_M_node->_M_next == this->_M_node; }\n+    empty() const { return this->_M_node._M_next == &this->_M_node; }\n   \n     /**  Returns the number of elements in the %list.  */\n     size_type\n@@ -848,12 +846,11 @@ namespace std\n      *  @param  x  A %list of the same element and allocator types.\n      *\n      *  This exchanges the elements between two lists in constant time.\n-     *  (It is only swapping a single pointer, so it should be quite fast.)\n      *  Note that the global std::swap() function is specialized such that\n      *  std::swap(l1,l2) will feed to this function.\n     */\n     void\n-    swap(list& __x) { std::swap(this->_M_node, __x._M_node); }\n+    swap(list& __x);\n   \n     /**\n      *  Erases all the elements.  Note that this function only erases the\n@@ -940,7 +937,7 @@ namespace std\n      *  @doctodo\n     */\n     void\n-    reverse() { __List_base_reverse(this->_M_node); }\n+    reverse() { __List_base_reverse(&this->_M_node); }\n   \n     /**\n      *  @doctodo"}]}