{"sha": "ec0fb1631e33a2ff6d16e43379f221f01966d6da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMwZmIxNjMxZTMzYTJmZjZkMTZlNDMzNzlmMjIxZjAxOTY2ZDZkYQ==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1996-11-12T22:53:16Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1996-11-12T22:53:16Z"}, "message": "(zero_extendqidi2): Handle TARGET_BYTE_OPS.\n\n(zero_extendhidi2): Likewise.\n(zero_extendqisi2): Likewise.\n(zero_extendhisi2): Likewise.\n(extendqisi2): Use extendqidi2x if TARGET_BYTE_OPS.\n(extendqidi2): Likewise.\n(extendqidi2x): New pattern.\n(extendhisi2): Use extendhidi2x if TARGET_BYTE_OPS.\n(extendhidi2): Likewise.\n(extendhidi2x): New pattern.\n(movhi): Handle TARGET_BYTE_OPS.\n(movhi matcher): Output ldwu and stw.\n(movqi): Handle TARGET_BYTE_OPS.\n(movqi matcher): Output ldbu and stb.\n\nFrom-SVN: r13149", "tree": {"sha": "828b6c545d047c37e44c14c5eaab4f46dfbdc91a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/828b6c545d047c37e44c14c5eaab4f46dfbdc91a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec0fb1631e33a2ff6d16e43379f221f01966d6da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec0fb1631e33a2ff6d16e43379f221f01966d6da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec0fb1631e33a2ff6d16e43379f221f01966d6da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec0fb1631e33a2ff6d16e43379f221f01966d6da/comments", "author": null, "committer": null, "parents": [{"sha": "a2574dbebf114c81ce137b7caacbd628e99f6c4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2574dbebf114c81ce137b7caacbd628e99f6c4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2574dbebf114c81ce137b7caacbd628e99f6c4c"}], "stats": {"total": 141, "additions": 132, "deletions": 9}, "files": [{"sha": "b88ab9ccab829933da80b027ce59a8e1b0a77a90", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 132, "deletions": 9, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec0fb1631e33a2ff6d16e43379f221f01966d6da/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec0fb1631e33a2ff6d16e43379f221f01966d6da/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=ec0fb1631e33a2ff6d16e43379f221f01966d6da", "patch": "@@ -798,19 +798,46 @@\n   \"zapnot %1,1,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"TARGET_BYTE_OPS\"\n+  \"@\n+   zapnot %1,1,%0\n+   ldbu %0,%1\"\n+  [(set_attr \"type\" \"shift,ld\")])\n+\n (define_insn \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"zapnot %1,1,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"TARGET_BYTE_OPS\"\n+  \"@\n+   zapnot %1,1,%0\n+   ldbu %0,%1\"\n+  [(set_attr \"type\" \"shift,ld\")])\n+\n (define_insn \"zero_extendqidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (match_operand:QI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"zapnot %1,1,%0\"\n   [(set_attr \"type\" \"shift\")])\n+  \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"TARGET_BYTE_OPS\"\n+  \"@\n+   zapnot %1,3,%0\n+   ldwu %0,%1\"\n+  [(set_attr \"type\" \"shift,ld\")])\n \n (define_insn \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -819,6 +846,15 @@\n   \"zapnot %1,3,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"TARGET_BYTE_OPS\"\n+  \"@\n+   zapnot %1,3,%0\n+   ldwu %0,%1\"\n+  [(set_attr \"type\" \"shift,ld\")])\n+\n (define_insn \"zero_extendhidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (match_operand:HI 1 \"register_operand\" \"r\")))]\n@@ -952,7 +988,7 @@\n   \"\n {\n   /* If we have a MEM (must be unaligned), extend to DImode (which we do\n-\tspecially) and then copy to the result.  */\n+     specially) and then copy to the result.  */\n   if (GET_CODE (operands[1]) == MEM)\n     {\n       rtx temp = gen_reg_rtx (DImode);\n@@ -967,6 +1003,20 @@\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n+(define_insn \"extendqidi2x\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"r\")\n+\t(sign_extend:DI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_BYTE_OPS\"\n+  \"sextb %1,%0\"\n+  [(set_attr \"type\" \"shift\")])\t;; not sure what class this belongs to\n+\n+(define_insn \"extendhidi2x\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"r\")\n+\t(sign_extend:DI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_BYTE_OPS\"\n+  \"sextw %1,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n (define_expand \"extendqisi2\"\n   [(set (match_dup 2)\n \t(ashift:DI (match_operand:QI 1 \"reg_or_unaligned_mem_operand\" \"\")\n@@ -1003,6 +1053,21 @@\n   \"\"\n   \"\n { extern rtx get_unaligned_address ();\n+\n+  if (TARGET_BYTE_OPS)\n+    {\n+      rtx temp = operands[1];\n+\n+      if (GET_CODE (operands[1]) == MEM)\n+\t{\n+\t  temp = gen_reg_rtx (QImode);\n+\t  emit_insn (gen_movqi (temp, operands[1]));\n+\t}\n+\n+      emit_insn (gen_extendqidi2x (operands[0], temp));\n+      DONE;\n+    }\n+\n   if (GET_CODE (operands[1]) == MEM)\n     {\n       rtx seq\n@@ -1054,6 +1119,21 @@\n   \"\"\n   \"\n { extern rtx get_unaligned_address ();\n+\n+  if (TARGET_BYTE_OPS)\n+    {\n+      rtx temp = operands[1];\n+\n+      if (GET_CODE (operands[1]) == MEM)\n+\t{\n+\t  temp = gen_reg_rtx (HImode);\n+\t  emit_insn (gen_movhi (temp, operands[1]));\n+\t}\n+\n+      emit_insn (gen_extendhidi2x (operands[0], temp));\n+      DONE;\n+    }\n+\n   if (GET_CODE (operands[1]) == MEM)\n     {\n       rtx seq\n@@ -3367,32 +3447,36 @@\n   [(set_attr \"type\" \"ilog,ilog,ilog,iadd,iadd,ldsym,ld,st,fcpys,fcpys,ld,st\")])\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,r,f,f\")\n-\t(match_operand:HI 1 \"input_operand\" \"r,J,I,n,f,J\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,f,f\")\n+\t(match_operand:HI 1 \"input_operand\" \"r,J,I,n,m,rJ,f,J\"))]\n   \"register_operand (operands[0], HImode)\n-   || register_operand (operands[1], HImode)\"\n+   || reg_or_0_operand (operands[1], HImode)\"\n   \"@\n    bis %1,%1,%0\n    bis $31,$31,%0\n    bis $31,%1,%0\n    lda %0,%L1\n+   ldwu %0,%1\n+   stw %r1,%0\n    cpys %1,%1,%0\n    cpys $f31,$f31,%0\"\n-  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,fcpys,fcpys\")])\n+  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,ld,st,fcpys,fcpys\")])\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,r,r,f,f\")\n-\t(match_operand:QI 1 \"input_operand\" \"r,J,I,n,f,J\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,f,f\")\n+\t(match_operand:QI 1 \"input_operand\" \"r,J,I,n,m,rJ,f,J\"))]\n   \"register_operand (operands[0], QImode)\n-   || register_operand (operands[1], QImode)\"\n+   || reg_or_0_operand (operands[1], QImode)\"\n   \"@\n    bis %1,%1,%0\n    bis $31,$31,%0\n    bis $31,%1,%0\n    lda %0,%L1\n+   ldbu %0,%1\n+   stb %r1,%0\n    cpys %1,%1,%0\n    cpys $f31,$f31,%0\"\n-  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,fcpys,fcpys\")])\n+  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,ld,st,fcpys,fcpys\")])\n \n ;; We do two major things here: handle mem->mem and construct long\n ;; constants.\n@@ -3672,6 +3756,24 @@\n   \"\n { extern rtx get_unaligned_address ();\n \n+  if (TARGET_BYTE_OPS)\n+    {\n+      if (GET_CODE (operands[0]) == MEM\n+\t  && ! reg_or_0_operand (operands[1], QImode))\n+\toperands[1] = force_reg (QImode, operands[1]);\n+\n+      if (! CONSTANT_P (operands[1]) || input_operand (operands[1], QImode))\n+\t;\n+      else if (GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  operands[1]\n+\t    = alpha_emit_set_const (operands[0], QImode, INTVAL (operands[1]), 3);\n+\t  if (rtx_equal_p (operands[0], operands[1]))\n+\t    DONE;\n+\t}\n+      goto def;\n+    }\n+\n   /* If the output is not a register, the input must be.  */\n   if (GET_CODE (operands[0]) == MEM)\n     operands[1] = force_reg (QImode, operands[1]);\n@@ -3755,6 +3857,7 @@\n \t}\n       DONE;\n     }\n+ def:;\n }\")\n \n (define_expand \"movhi\"\n@@ -3764,6 +3867,25 @@\n   \"\n { extern rtx get_unaligned_address ();\n \n+  if (TARGET_BYTE_OPS)\n+    {\n+      if (GET_CODE (operands[0]) == MEM\n+\t  && ! reg_or_0_operand (operands[1], HImode))\n+\toperands[1] = force_reg (HImode, operands[1]);\n+\n+      if (! CONSTANT_P (operands[1]) || input_operand (operands[1], HImode))\n+\t;\n+      else if (GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  operands[1]\n+\t    = alpha_emit_set_const (operands[0], HImode, INTVAL (operands[1]), 3);\n+\t  if (rtx_equal_p (operands[0], operands[1]))\n+\t    DONE;\n+\t}\n+      goto def;\n+    }\n+\n+\n   /* If the output is not a register, the input must be.  */\n   if (GET_CODE (operands[0]) == MEM)\n     operands[1] = force_reg (HImode, operands[1]);\n@@ -3848,6 +3970,7 @@\n \n       DONE;\n     }\n+ def:;\n }\")\n \n ;; Here are the versions for reload.  Note that in the unaligned cases"}]}