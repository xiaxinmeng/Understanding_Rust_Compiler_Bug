{"sha": "08f1af2ed022e03c212779751c83ec8e2573a450", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhmMWFmMmVkMDIyZTAzYzIxMjc3OTc1MWM4M2VjOGUyNTczYTQ1MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-05-11T20:54:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-05-11T20:54:56Z"}, "message": "pr21829.c: Simplify matching since we now optimize better.\n\n\n\t* gcc.dg/tree-ssa/pr21829.c: Simplify matching since\n\twe now optimize better.\n\t* gcc.dg/Wunreachable-8.c: Bogus warnings now come\n\tout at different places.\n\t* gcc.dg/vect/vect-92.c: Increase loop iteration count to prevent\n\tunroling.\n\t* gcc.dg/vect/vect-76.c: Likewise.\n\t* gcc.dg/vect/vect-70.c: Likewise.\n\t* gcc.dg/vect/vect-66.c: Likewise.\n\t* gcc.dg/vect/no-section-anchors-vect-66.c: Likewise.\n\t* gcc.dg/vect/slp-3.c: One of loops gets now fully unrolled.\n\t* tree-ssa-loop-ivcanon.c: Include target.h\n\t(struct loop_size): new structure.\n\t(constant_after_peeling): New predicate.\n\t(tree_estimate_loop_size): New function.\n\t(estimated_unrolled_size): Rewrite for new estimates.\n\t(try_unroll_loop_completely): Use new estimates.\n\t* Makefile.in (tree-ssa-loop-ivcanon.o): Add dependenc on target.h\n\nFrom-SVN: r147395", "tree": {"sha": "80a513da7ccd914d65c08f77342649107a50930e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80a513da7ccd914d65c08f77342649107a50930e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08f1af2ed022e03c212779751c83ec8e2573a450", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08f1af2ed022e03c212779751c83ec8e2573a450", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08f1af2ed022e03c212779751c83ec8e2573a450", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08f1af2ed022e03c212779751c83ec8e2573a450/comments", "author": null, "committer": null, "parents": [{"sha": "a7d39bd39c8f3ad07e6688afe4b55d7d75ea5080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7d39bd39c8f3ad07e6688afe4b55d7d75ea5080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7d39bd39c8f3ad07e6688afe4b55d7d75ea5080"}], "stats": {"total": 289, "additions": 229, "deletions": 60}, "files": [{"sha": "809ff4792d11a146cf2377df16ea4e3ce49bec07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -1,3 +1,13 @@\n+2009-05-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssa-loop-ivcanon.c: Include target.h\n+\t(struct loop_size): new structure.\n+\t(constant_after_peeling): New predicate.\n+\t(tree_estimate_loop_size): New function.\n+\t(estimated_unrolled_size): Rewrite for new estimates.\n+\t(try_unroll_loop_completely): Use new estimates.\n+\t* Makefile.in (tree-ssa-loop-ivcanon.o): Add dependenc on target.h\n+\n 2009-05-11  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* config/spu/spu-c.c (spu_categorize_keyword): Update for recent"}, {"sha": "ab690282ea2eb895957e1727cf7177d0565f7079", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -2268,7 +2268,7 @@ tree-ssa-loop-ivcanon.o : tree-ssa-loop-ivcanon.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) \\\n    $(TREE_INLINE_H) output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(FLAGS_H) $(TREE_PASS_H) $(SCEV_H) $(BASIC_BLOCK_H) $(GGC_H) \\\n-   hard-reg-set.h tree-chrec.h\n+   hard-reg-set.h tree-chrec.h $(TARGET_H)\n tree-ssa-loop-ch.o : tree-ssa-loop-ch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(TREE_INLINE_H) \\\n    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\"}, {"sha": "f0f45fc2fa3d5c15b3b22e375092a57857ad4901", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -1,3 +1,17 @@\n+2009-05-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/pr21829.c: Simplify matching since\n+\twe now optimize better.\n+\t* gcc.dg/Wunreachable-8.c: Bogus warnings now come\n+\tout at different places.\n+\t* gcc.dg/vect/vect-92.c: Increase loop iteration count to prevent\n+\tunroling.\n+\t* gcc.dg/vect/vect-76.c: Likewise.\n+\t* gcc.dg/vect/vect-70.c: Likewise.\n+\t* gcc.dg/vect/vect-66.c: Likewise.\n+\t* gcc.dg/vect/no-section-anchors-vect-66.c: Likewise.\n+\t* gcc.dg/vect/slp-3.c: One of loops gets now fully unrolled.\n+\n 2009-05-11  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR middle-end/40080"}, {"sha": "55a8f9cca01fd80ed0b6a3b3d93e30e2f1ee6a8d", "filename": "gcc/testsuite/gcc.dg/Wunreachable-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2FWunreachable-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2FWunreachable-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWunreachable-2.c?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -9,8 +9,8 @@ void bar (void)\n {\n   int i;\n \n-  for (i = 0; i < 2; i++)\n-    if (! foo (a[i]))\n+  for (i = 0; i < 2; i++)  /* { dg-bogus \"will never be executed\" \"\" { xfail *-*-* } } */\n+    if (! foo (a[i]))  /* { dg-bogus \"will never be executed\" \"\" { xfail *-*-* } } */\n       return;\n \n   baz ();\t/* { dg-bogus \"will never be executed\" } */"}, {"sha": "1a13d64243e9930800df3ed5929ac1f65229d93d", "filename": "gcc/testsuite/gcc.dg/Wunreachable-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2FWunreachable-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2FWunreachable-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWunreachable-8.c?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -4,7 +4,7 @@ float Factorial(float X)\n {\n   float val = 1.0;\n   int k,j;\n-  for (k=1; k < 5; k++)\n+  for (k=1; k < 5; k++) /* { dg-bogus \"will never be executed\" \"\" { xfail *-*-* } } */\n     {\n       val += 1.0; /* { dg-bogus \"will never be executed\" \"\" { xfail *-*-* } } */\n     }"}, {"sha": "c95714ab9fb8196deb7ae8eef6fcf78d0c5712bf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21829.c", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21829.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21829.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21829.c?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-cddce2\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n \n int test(int v)\n {\n@@ -16,33 +16,7 @@ int test(int v)\n   return x;\n }\n \n-/* This should be optimized to\n+/* This should be unrolled and optimized into conditional set of return value \"v < 0\".  */\n \n-    if (v <= 0) goto <L1>; else goto <L3>;\n-\n-   <L1>:;\n-\n-    # x_1 = PHI <0(3), 1(1)>;\n-   <L3>:;\n-    return x_1;\n-\n-   retaining only a single conditional.  This doesn't work as nobody\n-   combines the two tests\n-\n-    if (v < 0) goto <bb 4>; else goto <bb 3>;\n-\n-   <bb 3>:\n-\n-    if (v <= 0) goto <bb 4>; else goto <bb 5>;\n-\n-   this late in the game.  tree-ssa-ifcombine.c would do it if we would\n-   unroll the loop during early loop unrolling though.\n-\n-   For now vrp2 does all the needed folding and threading and cddce2\n-   provides a nice IL to scan.  */\n-\n-/* { dg-final { scan-tree-dump-times \"if \" 1 \"optimized\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"if \" 2 \"cddce2\" } } */\n-/* { dg-final { scan-tree-dump \"x_. = PHI <0\\\\\\(.\\\\\\), 1\\\\\\(.\\\\\\)>\" \"cddce2\" } } */\n-/* { dg-final { cleanup-tree-dump \"cddce2\" } } */\n+/* { dg-final { scan-tree-dump-not \"if \\\\(\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "49a9098f79f69412cb1d4e36cc8162593a20544c", "filename": "gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-66.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-66.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-66.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-66.c?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -3,7 +3,7 @@\n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n-#define N 8\n+#define N 16\n \n int ia[8][5][N+2];\n int ic[16][16][5][N+2];"}, {"sha": "1bb9884a6449a37890635fe2835b099e820d5c2f", "filename": "gcc/testsuite/gcc.dg/vect/slp-3.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -142,7 +142,8 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" { xfail vect_no_align } } } */\n+/* One of the loops gets complettely unrolled.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n   "}, {"sha": "e0b23cd65509b580325f79dd3391421a14fba874", "filename": "gcc/testsuite/gcc.dg/vect/vect-66.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-66.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-66.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-66.c?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -3,7 +3,7 @@\n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n-#define N 8\n+#define N 16\n \n __attribute__ ((noinline))\n void main1 ()"}, {"sha": "23b1902e54fe518be21b3ed8b5650d56e4e2dd11", "filename": "gcc/testsuite/gcc.dg/vect/vect-70.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-70.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-70.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-70.c?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -3,7 +3,7 @@\n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n-#define N 12\n+#define N 24\n \n struct s{\n   int m;"}, {"sha": "7097e7a821ecfa82d692f7ef63cbb2c8308c4906", "filename": "gcc/testsuite/gcc.dg/vect/vect-76.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -3,7 +3,7 @@\n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n-#define N 12\n+#define N 24\n #define OFF 4\n \n /* Check handling of accesses for which the \"initial condition\" -"}, {"sha": "3a64e251cb2a9b94689fe2893e502d62d723705e", "filename": "gcc/testsuite/gcc.dg/vect/vect-92.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-92.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-92.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-92.c?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -22,13 +22,13 @@ main1 ()\n {\n   int i;\n \n-  for (i = 0; i < 5; i++)\n+  for (i = 0; i < 10; i++)\n     {\n       pa[i+1] = pb[i+1] * pc[i+1];\n     }\n \n   /* check results:  */\n-  for (i = 0; i < 5; i++)\n+  for (i = 0; i < 10; i++)\n     {\n       if (pa[i+1] != (pb[i+1] * pc[i+1]))\n \tabort ();\n@@ -42,13 +42,13 @@ main2 ()\n {\n   int i;\n \n-  for (i = 0; i < 6; i++)\n+  for (i = 0; i < 12; i++)\n     {\n       pa[i+1] = pb[i+1] * pc[i+1];\n     }\n \n   /* check results:  */\n-  for (i = 0; i < 6; i++)\n+  for (i = 0; i < 12; i++)\n     {\n       if (pa[i+1] != (pb[i+1] * pc[i+1]))\n \tabort ();"}, {"sha": "8e45bbb97e653cce5b3cec3884d5b3697e9c3ba5", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 187, "deletions": 17, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f1af2ed022e03c212779751c83ec8e2573a450/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=08f1af2ed022e03c212779751c83ec8e2573a450", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"flags.h\"\n #include \"tree-inline.h\"\n+#include \"target.h\"\n \n /* Specifies types of loops that may be unrolled.  */\n \n@@ -118,7 +119,7 @@ tree_num_loop_insns (struct loop *loop, eni_weights *weights)\n {\n   basic_block *body = get_loop_body (loop);\n   gimple_stmt_iterator gsi;\n-  unsigned size = 1, i;\n+  unsigned size = 0, i;\n \n   for (i = 0; i < loop->num_nodes; i++)\n     for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -128,28 +129,195 @@ tree_num_loop_insns (struct loop *loop, eni_weights *weights)\n   return size;\n }\n \n-/* Estimate number of insns of completely unrolled loop.  We assume\n-   that the size of the unrolled loop is decreased in the\n-   following way (the numbers of insns are based on what\n-   estimate_num_insns returns for appropriate statements):\n+/* Describe size of loop as detected by tree_estimate_loop_size.  */\n+struct loop_size\n+{\n+  /* Number of instructions in the loop.  */\n+  int overall;\n+\n+  /* Number of instructions that will be likely optimized out in\n+     peeled iterations of loop  (i.e. computation based on induction\n+     variable where induction variable starts at known constant.)  */\n+  int eliminated_by_peeling;\n+\n+  /* Same statistics for last iteration of loop: it is smaller because\n+     instructions after exit are not executed.  */\n+  int last_iteration;\n+  int last_iteration_eliminated_by_peeling;\n+};\n+\n+/* Return true if OP in STMT will be constant after peeling LOOP.  */\n+\n+static bool\n+constant_after_peeling (tree op, gimple stmt, struct loop *loop)\n+{\n+  affine_iv iv;\n+\n+  if (is_gimple_min_invariant (op))\n+    return true;\n+  \n+  /* We can still fold accesses to constant arrays when index is known.  */\n+  if (TREE_CODE (op) != SSA_NAME)\n+    {\n+      tree base = op;\n+\n+      /* First make fast look if we see constant array inside.  */\n+      while (handled_component_p (base))\n+\tbase = TREE_OPERAND (base, 0);\n+      if ((DECL_P (base)\n+      \t   && TREE_STATIC (base)\n+\t   && TREE_READONLY (base)\n+           && (DECL_INITIAL (base)\n+\t       || (!DECL_EXTERNAL (base)\n+\t\t   && targetm.binds_local_p (base))))\n+\t  || CONSTANT_CLASS_P (base))\n+\t{\n+\t  /* If so, see if we understand all the indices.  */\n+\t  base = op;\n+\t  while (handled_component_p (base))\n+\t    {\n+\t      if (TREE_CODE (base) == ARRAY_REF\n+\t\t  && !constant_after_peeling (TREE_OPERAND (base, 1), stmt, loop))\n+\t\treturn false;\n+\t      base = TREE_OPERAND (base, 0);\n+\t    }\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  /* Induction variables are constants.  */\n+  if (!simple_iv (loop, loop_containing_stmt (stmt), op, &iv, false))\n+    return false;\n+  if (!is_gimple_min_invariant (iv.base))\n+    return false;\n+  if (!is_gimple_min_invariant (iv.step))\n+    return false;\n+  return true;\n+}\n+\n+/* Computes an estimated number of insns in LOOP, weighted by WEIGHTS.\n+   Return results in SIZE, estimate benefits for complete unrolling exiting by EXIT.  */\n+\n+static void\n+tree_estimate_loop_size (struct loop *loop, edge exit, struct loop_size *size)\n+{\n+  basic_block *body = get_loop_body (loop);\n+  gimple_stmt_iterator gsi;\n+  unsigned int i;\n+  bool after_exit;\n+\n+  size->overall = 0;\n+  size->eliminated_by_peeling = 0;\n+  size->last_iteration = 0;\n+  size->last_iteration_eliminated_by_peeling = 0;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Estimating sizes for loop %i\\n\", loop->num);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      if (exit && body[i] != exit->src\n+\t  && dominated_by_p (CDI_DOMINATORS, body[i], exit->src))\n+\tafter_exit = true;\n+      else\n+\tafter_exit = false;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \" BB: %i, after_exit: %i\\n\", body[i]->index, after_exit);\n+\n+      for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  int num = estimate_num_insns (stmt, &eni_size_weights);\n+\t  bool likely_eliminated = false;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"  size: %3i \", num);\n+\t      print_gimple_stmt (dump_file, gsi_stmt (gsi), 0, 0);\n+\t    }\n+\n+\t  /* Look for reasons why we might optimize this stmt away. */\n+\n+\t  /* Exit conditional.  */\n+\t  if (body[i] == exit->src && stmt == last_stmt (exit->src))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t        fprintf (dump_file, \"   Exit condition will be eliminated.\\n\");\n+\t      likely_eliminated = true;\n+\t    }\n+\t  /* Sets of IV variables  */\n+\t  else if (gimple_code (stmt) == GIMPLE_ASSIGN\n+\t      && constant_after_peeling (gimple_assign_lhs (stmt), stmt, loop))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t        fprintf (dump_file, \"   Induction variable computation will\"\n+\t\t\t \" be folded away.\\n\");\n+\t      likely_eliminated = true;\n+\t    }\n+\t  /* Assignments of IV variables.  */\n+\t  else if (gimple_code (stmt) == GIMPLE_ASSIGN\n+\t\t   && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n+\t\t   && constant_after_peeling (gimple_assign_rhs1 (stmt), stmt,loop)\n+\t\t   && (gimple_assign_rhs_class (stmt) != GIMPLE_BINARY_RHS\n+\t\t       || constant_after_peeling (gimple_assign_rhs2 (stmt),\n+\t\t       \t\t\t\t  stmt, loop)))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t        fprintf (dump_file, \"   Constant expression will be folded away.\\n\");\n+\t      likely_eliminated = true;\n+\t    }\n+\t  /* Conditionals.  */\n+\t  else if (gimple_code (stmt) == GIMPLE_COND\n+\t\t   && constant_after_peeling (gimple_cond_lhs (stmt), stmt, loop)\n+\t\t   && constant_after_peeling (gimple_cond_rhs (stmt), stmt, loop))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t        fprintf (dump_file, \"   Constant conditional.\\n\");\n+\t      likely_eliminated = true;\n+\t    }\n+\n+\t  size->overall += num;\n+\t  if (likely_eliminated)\n+\t    size->eliminated_by_peeling += num;\n+\t  if (!after_exit)\n+\t    {\n+\t      size->last_iteration += num;\n+\t      if (likely_eliminated)\n+\t\tsize->last_iteration_eliminated_by_peeling += num;\n+\t    }\n+\t}\n+    }\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"size: %i-%i, last_iteration: %i-%i\\n\", size->overall,\n+    \t     size->eliminated_by_peeling, size->last_iteration,\n+\t     size->last_iteration_eliminated_by_peeling);\n+  \n+  free (body);\n+}\n \n-   1) exit condition gets removed (2 insns)\n-   2) increment of the control variable gets removed (2 insns)\n-   3) All remaining statements are likely to get simplified\n-      due to constant propagation.  Hard to estimate; just\n-      as a heuristics we decrease the rest by 1/3.\n+/* Estimate number of insns of completely unrolled loop.\n+   It is (NUNROLL + 1) * size of loop body with taking into account\n+   the fact that in last copy everything after exit conditional\n+   is dead and that some instructions will be eliminated after\n+   peeling.\n \n-   NINSNS is the number of insns in the loop before unrolling.\n-   NUNROLL is the number of times the loop is unrolled.  */\n+   Loop body is likely going to simplify futher, this is difficult\n+   to guess, we just decrease the result by 1/3.  */\n \n static unsigned HOST_WIDE_INT\n-estimated_unrolled_size (unsigned HOST_WIDE_INT ninsns,\n+estimated_unrolled_size (struct loop_size *size,\n \t\t\t unsigned HOST_WIDE_INT nunroll)\n {\n-  HOST_WIDE_INT unr_insns = 2 * ((HOST_WIDE_INT) ninsns - 4) / 3;\n+  HOST_WIDE_INT unr_insns = ((nunroll)\n+  \t\t\t     * (HOST_WIDE_INT) (size->overall\n+\t\t\t     \t\t\t- size->eliminated_by_peeling));\n+  if (!nunroll)\n+    unr_insns = 0;\n+  unr_insns += size->last_iteration - size->last_iteration_eliminated_by_peeling;\n+\n+  unr_insns = unr_insns * 2 / 3;\n   if (unr_insns <= 0)\n     unr_insns = 1;\n-  unr_insns *= (nunroll + 1);\n \n   return unr_insns;\n }\n@@ -165,6 +333,7 @@ try_unroll_loop_completely (struct loop *loop,\n {\n   unsigned HOST_WIDE_INT n_unroll, ninsns, max_unroll, unr_insns;\n   gimple cond;\n+  struct loop_size size;\n \n   if (loop->inner)\n     return false;\n@@ -182,9 +351,10 @@ try_unroll_loop_completely (struct loop *loop,\n       if (ul == UL_SINGLE_ITER)\n \treturn false;\n \n-      ninsns = tree_num_loop_insns (loop, &eni_size_weights);\n+      tree_estimate_loop_size (loop, exit, &size);\n+      ninsns = size.overall;\n \n-      unr_insns = estimated_unrolled_size (ninsns, n_unroll);\n+      unr_insns = estimated_unrolled_size (&size, n_unroll);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"  Loop size: %d\\n\", (int) ninsns);"}]}