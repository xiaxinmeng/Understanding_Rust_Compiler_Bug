{"sha": "c42e6724e10f71991cc5e01a4013d77036b06099", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQyZTY3MjRlMTBmNzE5OTFjYzVlMDFhNDAxM2Q3NzAzNmIwNjA5OQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2008-05-26T09:39:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-26T09:39:19Z"}, "message": "exp_ch3.adb (Build_Init_Statements): Alphabetize local variables.\n\n2008-05-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Build_Init_Statements): Alphabetize local variables.\n\tCreate the statements which map a string name to protected or task\n\tentry indix.\n\n\t* exp_ch9.adb: Add with and use clause for Stringt.\n\tMinor code reformatting.\n\t(Build_Entry_Names): New routine.\n\t(Make_Initialize_Protection, Make_Task_Create_Call): Generate a value\n\tfor flag Build_Entry_Names which controls the allocation of the data\n\tstructure for the string names of entries.\n\n\t* exp_ch9.ads (Build_Entry_Names): New subprogram.\n\n\t* exp_util.adb (Entry_Names_OK): New function.\n\n\t* exp_util.ads (Entry_Names_OK): New function.\n\n\t* rtsfind.ads: Add RO_PE_Set_Entry_Name and RO_TS_Set_Entry_Name to\n\tenumerations RE_Id and RE_Unit_Table.\n\n\t* s-taskin.adb Add with and use clause for Ada.Unchecked_Deallocation.\n\t(Free_Entry_Names_Array): New routine.\n\n\t* s-taskin.ads: Comment reformatting.\n\tAdd types String_Access, Entry_Names_Array, Entry_Names_Array_Access.\n\tAdd component Entry_Names to record Ada_Task_Control_Block.\n\t(Free_Entry_Names_Array): New routine.\n\n\t* s-tassta.adb (Create_Task): If flag Build_Entry_Names is set,\n\tdynamically allocate an array\n\tof string pointers. This structure holds string entry names.\n\t(Free_Entry_Names): New routine.\n\t(Free_Task, Vulnerable_Free_Task): Deallocate the entry names array.\n\t(Set_Entry_Names): New routine.\n\n\t* s-tassta.ads:\n\t(Create_Task): Add formal Build_Entry_Names. The flag is used to\n\tcontrol the allocation of the data structure which stores entry names.\n\t(Set_Entry_Name): New routine.\n\n\t* s-tpoben.adb:\n\tAdd with and use clause for Ada.Unchecked_Conversion.\n\t(Finalize): Deallocate the entry names array.\n\t(Free_Entry_Names): New routine.\n\t(Initialize_Protection_Entries): When flag Build_Entry_Names is set,\n\tcreate an array of string pointers to hold the entry names.\n\t(Set_Entry_Name): New routine.\n\n\t* s-tpoben.ads:\n\tAdd field Entry_Names to record Protection_Entries.\n\t(Initialize_Protection_Entries): Add formal Build_Entry_Names.\n\t(Set_Entry_Name): New routine.\n\nFrom-SVN: r135896", "tree": {"sha": "7e2f7cbd0136adaee94fd2b3f48e6fb17ffc5241", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e2f7cbd0136adaee94fd2b3f48e6fb17ffc5241"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c42e6724e10f71991cc5e01a4013d77036b06099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c42e6724e10f71991cc5e01a4013d77036b06099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c42e6724e10f71991cc5e01a4013d77036b06099", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c42e6724e10f71991cc5e01a4013d77036b06099/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a28e8f45c361a5c7799b59d9d38a5353d1a9bb6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28e8f45c361a5c7799b59d9d38a5353d1a9bb6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a28e8f45c361a5c7799b59d9d38a5353d1a9bb6a"}], "stats": {"total": 687, "additions": 626, "deletions": 61}, "files": [{"sha": "89ae08fdcdc1c93903afd7301dd39b1a44434e8d", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -2477,17 +2477,16 @@ package body Exp_Ch3 is\n       function Build_Init_Statements (Comp_List : Node_Id) return List_Id is\n          Check_List     : constant List_Id := New_List;\n          Alt_List       : List_Id;\n+         Decl           : Node_Id;\n+         Id             : Entity_Id;\n+         Names          : Node_Id;\n          Statement_List : List_Id;\n          Stmts          : List_Id;\n+         Typ            : Entity_Id;\n+         Variant        : Node_Id;\n \n          Per_Object_Constraint_Components : Boolean;\n \n-         Decl     : Node_Id;\n-         Variant  : Node_Id;\n-\n-         Id  : Entity_Id;\n-         Typ : Entity_Id;\n-\n          function Has_Access_Constraint (E : Entity_Id) return Boolean;\n          --  Components with access discriminants that depend on the current\n          --  instance must be initialized after all other components.\n@@ -2711,6 +2710,17 @@ package body Exp_Ch3 is\n \n             Append_To (Statement_List, Make_Task_Create_Call (Rec_Type));\n \n+            --  Generate the statements which map a string entry name to a\n+            --  task entry index. Note that the task may not have entries.\n+\n+            if Entry_Names_OK then\n+               Names := Build_Entry_Names (Rec_Type);\n+\n+               if Present (Names) then\n+                  Append_To (Statement_List, Names);\n+               end if;\n+            end if;\n+\n             declare\n                Task_Type : constant Entity_Id :=\n                              Corresponding_Concurrent_Type (Rec_Type);\n@@ -2761,6 +2771,18 @@ package body Exp_Ch3 is\n          if Is_Protected_Record_Type (Rec_Type) then\n             Append_List_To (Statement_List,\n               Make_Initialize_Protection (Rec_Type));\n+\n+            --  Generate the statements which map a string entry name to a\n+            --  protected entry index. Note that the protected type may not\n+            --  have entries.\n+\n+            if Entry_Names_OK then\n+               Names := Build_Entry_Names (Rec_Type);\n+\n+               if Present (Names) then\n+                  Append_To (Statement_List, Names);\n+               end if;\n+            end if;\n          end if;\n \n          --  If no initializations when generated for component declarations\n@@ -4494,15 +4516,16 @@ package body Exp_Ch3 is\n                end;\n             end if;\n \n-            --  If the type is controlled and not limited then the target is\n-            --  adjusted after the copy and attached to the finalization list.\n-            --  However, no adjustment is done in the case where the object was\n-            --  initialized by a call to a function whose result is built in\n-            --  place, since no copy occurred. (We eventually plan to support\n-            --  in-place function results for some nonlimited types. ???)\n+            --  If the type is controlled and not inherently limited, then\n+            --  the target is adjusted after the copy and attached to the\n+            --  finalization list. However, no adjustment is done in the case\n+            --  where the object was initialized by a call to a function whose\n+            --  result is built in place, since no copy occurred. (Eventually\n+            --  we plan to support in-place function results for some cases\n+            --  of nonlimited types. ???)\n \n             if Controlled_Type (Typ)\n-              and then not Is_Limited_Type (Typ)\n+              and then not Is_Inherently_Limited_Type (Typ)\n               and then not BIP_Call\n             then\n                Insert_Actions_After (Init_After,"}, {"sha": "33d129c39966b83b385ea212ffc9ce9583566b4b", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 367, "deletions": 8, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -56,6 +56,7 @@ with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n@@ -1106,6 +1107,334 @@ package body Exp_Ch9 is\n       return Ecount;\n    end Build_Entry_Count_Expression;\n \n+   -----------------------\n+   -- Build_Entry_Names --\n+   -----------------------\n+\n+   function Build_Entry_Names (Conc_Typ : Entity_Id) return Node_Id is\n+      Loc       : constant Source_Ptr := Sloc (Conc_Typ);\n+      B_Decls   : List_Id;\n+      B_Stmts   : List_Id;\n+      Comp      : Node_Id;\n+      Index     : Entity_Id;\n+      Index_Typ : RE_Id;\n+      Typ       : Entity_Id := Conc_Typ;\n+\n+      procedure Build_Entry_Family_Name (Id : Entity_Id);\n+      --  Generate:\n+      --    for Lnn in Family_Low .. Family_High loop\n+      --       Inn := Inn + 1;\n+      --       Set_Entry_Name\n+      --         (_init._object, Inn, new String (\"<Entry name> \" & Lnn'Img));\n+      --          _init._task_id\n+      --    end loop;\n+      --  Note that the bounds of the range may reference discriminants. The\n+      --  above construct is added directly to the statements of the block.\n+\n+      procedure Build_Entry_Name (Id : Entity_Id);\n+      --  Generate:\n+      --    Inn := Inn + 1;\n+      --    Set_Entry_Name (_init._task_id, Inn, new String (\"<Entry name>\");\n+      --                    _init._object\n+      --  The above construct is added directly to the statements of the block.\n+\n+      function Build_Set_Entry_Name_Call (Arg3 : Node_Id) return Node_Id;\n+      --  Generate the call to the runtime routine Set_Entry_Name with actuals\n+      --  _init._task_id or _init._object, Inn and Arg3.\n+\n+      function Find_Protection_Type (Conc_Typ : Entity_Id) return Entity_Id;\n+      --  Given a protected type or its corresponding record, find the type of\n+      --  field _object.\n+\n+      procedure Increment_Index (Stmts : List_Id);\n+      --  Generate the following and add it to Stmts\n+      --    Inn := Inn + 1;\n+\n+      -----------------------------\n+      -- Build_Entry_Family_Name --\n+      -----------------------------\n+\n+      procedure Build_Entry_Family_Name (Id : Entity_Id) is\n+         Def     : constant Node_Id :=\n+                     Discrete_Subtype_Definition (Parent (Id));\n+         L_Id    : constant Entity_Id :=\n+                     Make_Defining_Identifier (Loc, New_Internal_Name ('L'));\n+         L_Stmts : constant List_Id := New_List;\n+         Val     : Node_Id;\n+\n+         function Build_Range (Def : Node_Id) return Node_Id;\n+         --  Given a discrete subtype definition of an entry family, generate a\n+         --  range node which covers the range of Def's type.\n+\n+         -----------------\n+         -- Build_Range --\n+         -----------------\n+\n+         function Build_Range (Def : Node_Id) return Node_Id is\n+            High : Node_Id := Type_High_Bound (Etype (Def));\n+            Low  : Node_Id := Type_Low_Bound  (Etype (Def));\n+\n+         begin\n+            --  If a bound references a discriminant, generate an identifier\n+            --  with the same name. Resolution will map it to the formals of\n+            --  the init proc.\n+\n+            if Is_Entity_Name (Low)\n+              and then Ekind (Entity (Low)) = E_Discriminant\n+            then\n+               Low := Make_Identifier (Loc, Chars (Low));\n+            else\n+               Low := New_Copy_Tree (Low);\n+            end if;\n+\n+            if Is_Entity_Name (High)\n+              and then Ekind (Entity (High)) = E_Discriminant\n+            then\n+               High := Make_Identifier (Loc, Chars (High));\n+            else\n+               High := New_Copy_Tree (High);\n+            end if;\n+\n+            return\n+              Make_Range (Loc,\n+                Low_Bound  => Low,\n+                High_Bound => High);\n+         end Build_Range;\n+\n+      --  Start of processing for Build_Entry_Family_Name\n+\n+      begin\n+         Get_Name_String (Chars (Id));\n+\n+         if Is_Enumeration_Type (Etype (Def)) then\n+            Name_Len := Name_Len + 1;\n+            Name_Buffer (Name_Len) := ' ';\n+         end if;\n+\n+         --  Generate:\n+         --    new String'(\"<Entry name>\" & Lnn'Img);\n+\n+         Val :=\n+           Make_Allocator (Loc,\n+             Make_Qualified_Expression (Loc,\n+               Subtype_Mark =>\n+                 New_Reference_To (Standard_String, Loc),\n+               Expression =>\n+                 Make_Op_Concat (Loc,\n+                   Left_Opnd =>\n+                     Make_String_Literal (Loc,\n+                       String_From_Name_Buffer),\n+                   Right_Opnd =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix =>\n+                         New_Reference_To (L_Id, Loc),\n+                           Attribute_Name => Name_Img))));\n+\n+         Increment_Index (L_Stmts);\n+         Append_To (L_Stmts, Build_Set_Entry_Name_Call (Val));\n+\n+         --  Generate:\n+         --    for Lnn in Family_Low .. Family_High loop\n+         --       Inn := Inn + 1;\n+         --       Set_Entry_Name (_init._task_id, Inn, <Val>);\n+         --    end loop;\n+\n+         Append_To (B_Stmts,\n+           Make_Loop_Statement (Loc,\n+             Iteration_Scheme =>\n+               Make_Iteration_Scheme (Loc,\n+                 Loop_Parameter_Specification =>\n+                   Make_Loop_Parameter_Specification (Loc,\n+                    Defining_Identifier => L_Id,\n+                    Discrete_Subtype_Definition =>\n+                      Build_Range (Def))),\n+             Statements => L_Stmts,\n+             End_Label => Empty));\n+      end Build_Entry_Family_Name;\n+\n+      ----------------------\n+      -- Build_Entry_Name --\n+      ----------------------\n+\n+      procedure Build_Entry_Name (Id : Entity_Id) is\n+         Val : Node_Id;\n+\n+      begin\n+         Get_Name_String (Chars (Id));\n+         Val :=\n+           Make_Allocator (Loc,\n+             Make_Qualified_Expression (Loc,\n+               Subtype_Mark =>\n+                 New_Reference_To (Standard_String, Loc),\n+               Expression =>\n+                 Make_String_Literal (Loc,\n+                   String_From_Name_Buffer)));\n+\n+         Increment_Index (B_Stmts);\n+         Append_To (B_Stmts, Build_Set_Entry_Name_Call (Val));\n+      end Build_Entry_Name;\n+\n+      -------------------------------\n+      -- Build_Set_Entry_Name_Call --\n+      -------------------------------\n+\n+      function Build_Set_Entry_Name_Call (Arg3 : Node_Id) return Node_Id is\n+         Arg1 : Name_Id;\n+         Proc : RE_Id;\n+\n+      begin\n+         --  Determine the proper name for the first argument and the RTS\n+         --  routine to call.\n+\n+         if Is_Protected_Type (Typ) then\n+            Arg1 := Name_uObject;\n+            Proc := RO_PE_Set_Entry_Name;\n+\n+         else pragma Assert (Is_Task_Type (Typ));\n+            Arg1 := Name_uTask_Id;\n+            Proc := RO_TS_Set_Entry_Name;\n+         end if;\n+\n+         --  Generate:\n+         --    Set_Entry_Name (_init.Arg1, Inn, Arg3);\n+\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name =>\n+               New_Reference_To (RTE (Proc), Loc),\n+             Parameter_Associations => New_List (\n+               Make_Selected_Component (Loc,              --  _init._object\n+                 Prefix =>                                --  _init._task_id\n+                   Make_Identifier (Loc, Name_uInit),\n+                 Selector_Name =>\n+                   Make_Identifier (Loc, Arg1)),\n+               New_Reference_To (Index, Loc),             --  Inn\n+               Arg3));                                    --  Val\n+      end Build_Set_Entry_Name_Call;\n+\n+      --------------------------\n+      -- Find_Protection_Type --\n+      --------------------------\n+\n+      function Find_Protection_Type (Conc_Typ : Entity_Id) return Entity_Id is\n+         Comp : Entity_Id;\n+         Typ  : Entity_Id := Conc_Typ;\n+\n+      begin\n+         if Is_Concurrent_Type (Typ) then\n+            Typ := Corresponding_Record_Type (Typ);\n+         end if;\n+\n+         Comp := First_Component (Typ);\n+         while Present (Comp) loop\n+            if Chars (Comp) = Name_uObject then\n+               return Base_Type (Etype (Comp));\n+            end if;\n+\n+            Next_Component (Comp);\n+         end loop;\n+\n+         --  The corresponding record of a protected type should always have an\n+         --  _object field.\n+\n+         raise Program_Error;\n+      end Find_Protection_Type;\n+\n+      ---------------------\n+      -- Increment_Index --\n+      ---------------------\n+\n+      procedure Increment_Index (Stmts : List_Id) is\n+      begin\n+         --  Generate:\n+         --    Inn := Inn + 1;\n+\n+         Append_To (Stmts,\n+           Make_Assignment_Statement (Loc,\n+             Name =>\n+               New_Reference_To (Index, Loc),\n+             Expression =>\n+               Make_Op_Add (Loc,\n+                 Left_Opnd =>\n+                   New_Reference_To (Index, Loc),\n+                 Right_Opnd =>\n+                   Make_Integer_Literal (Loc, 1))));\n+      end Increment_Index;\n+\n+   --  Start of processing for Build_Entry_Names\n+\n+   begin\n+      --  Retrieve the original concurrent type\n+\n+      if Is_Concurrent_Record_Type (Typ) then\n+         Typ := Corresponding_Concurrent_Type (Typ);\n+      end if;\n+\n+      pragma Assert (Is_Protected_Type (Typ) or else Is_Task_Type (Typ));\n+\n+      --  Nothing to do if the type has no entries\n+\n+      if not Has_Entries (Typ) then\n+         return Empty;\n+      end if;\n+\n+      --  Avoid generating entry names for a protected type with only one entry\n+\n+      if Is_Protected_Type (Typ)\n+        and then Find_Protection_Type (Typ) /= RTE (RE_Protection_Entries)\n+      then\n+         return Empty;\n+      end if;\n+\n+      Index := Make_Defining_Identifier (Loc, New_Internal_Name ('I'));\n+\n+      --  Step 1: Generate the declaration of the index variable:\n+      --    Inn : Protected_Entry_Index := 0;\n+      --      or\n+      --    Inn : Task_Entry_Index := 0;\n+\n+      if Is_Protected_Type (Typ) then\n+         Index_Typ := RE_Protected_Entry_Index;\n+      else\n+         Index_Typ := RE_Task_Entry_Index;\n+      end if;\n+\n+      B_Decls := New_List;\n+      Append_To (B_Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Index,\n+          Object_Definition =>\n+            New_Reference_To (RTE (Index_Typ), Loc),\n+          Expression =>\n+            Make_Integer_Literal (Loc, 0)));\n+\n+      B_Stmts := New_List;\n+\n+      --  Step 2: Generate a call to Set_Entry_Name for each entry and entry\n+      --  family member.\n+\n+      Comp := First_Entity (Typ);\n+      while Present (Comp) loop\n+         if Ekind (Comp) = E_Entry then\n+            Build_Entry_Name (Comp);\n+\n+         elsif Ekind (Comp) = E_Entry_Family then\n+            Build_Entry_Family_Name (Comp);\n+         end if;\n+\n+         Next_Entity (Comp);\n+      end loop;\n+\n+      --  Step 3: Wrap the statements in a block\n+\n+      return\n+        Make_Block_Statement (Loc,\n+          Declarations => B_Decls,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => B_Stmts));\n+   end Build_Entry_Names;\n+\n    ---------------------------\n    -- Build_Parameter_Block --\n    ---------------------------\n@@ -11250,8 +11579,8 @@ package body Exp_Ch9 is\n         or else Has_Abstract_Interfaces (Protect_Rec)\n       then\n          declare\n-            Pkg_Id : constant RTU_Id := Corresponding_Runtime_Package (Ptyp);\n-\n+            Pkg_Id      : constant RTU_Id  :=\n+                            Corresponding_Runtime_Package (Ptyp);\n             Called_Subp : RE_Id;\n \n          begin\n@@ -11302,6 +11631,20 @@ package body Exp_Ch9 is\n                       Prefix =>\n                         New_Reference_To (P_Arr, Loc),\n                       Attribute_Name => Name_Unrestricted_Access));\n+\n+                  --  Build_Entry_Names generation flag. When set to true, the\n+                  --  runtime will allocate an array to hold the string names\n+                  --  of protected entries.\n+\n+                  if not Restricted_Profile then\n+                     if Entry_Names_OK then\n+                        Append_To (Args,\n+                          New_Reference_To (Standard_True, Loc));\n+                     else\n+                        Append_To (Args,\n+                          New_Reference_To (Standard_False, Loc));\n+                     end if;\n+                  end if;\n                end if;\n \n             elsif Pkg_Id = System_Tasking_Protected_Objects_Single_Entry then\n@@ -11310,6 +11653,7 @@ package body Exp_Ch9 is\n             elsif Pkg_Id = System_Tasking_Protected_Objects_Entries then\n                Append_To (Args, Make_Null (Loc));\n                Append_To (Args, Make_Null (Loc));\n+               Append_To (Args, New_Reference_To (Standard_False, Loc));\n             end if;\n \n             Append_To (L,\n@@ -11422,13 +11766,13 @@ package body Exp_Ch9 is\n \n    function Make_Task_Create_Call (Task_Rec : Entity_Id) return Node_Id is\n       Loc    : constant Source_Ptr := Sloc (Task_Rec);\n+      Args   : List_Id;\n+      Ecount : Node_Id;\n       Name   : Node_Id;\n-      Tdef   : Node_Id;\n       Tdec   : Node_Id;\n-      Ttyp   : Node_Id;\n+      Tdef   : Node_Id;\n       Tnam   : Name_Id;\n-      Args   : List_Id;\n-      Ecount : Node_Id;\n+      Ttyp   : Node_Id;\n \n    begin\n       Ttyp := Corresponding_Concurrent_Type (Task_Rec);\n@@ -11682,14 +12026,29 @@ package body Exp_Ch9 is\n           Prefix => Make_Identifier (Loc, Name_uInit),\n           Selector_Name => Make_Identifier (Loc, Name_uTask_Id)));\n \n+      --  Build_Entry_Names generation flag. When set to true, the runtime\n+      --  will allocate an array to hold the string names of task entries.\n+\n+      if not Restricted_Profile then\n+         if Has_Entries (Ttyp)\n+           and then Entry_Names_OK\n+         then\n+            Append_To (Args, New_Reference_To (Standard_True, Loc));\n+         else\n+            Append_To (Args, New_Reference_To (Standard_False, Loc));\n+         end if;\n+      end if;\n+\n       if Restricted_Profile then\n          Name := New_Reference_To (RTE (RE_Create_Restricted_Task), Loc);\n       else\n          Name := New_Reference_To (RTE (RE_Create_Task), Loc);\n       end if;\n \n-      return Make_Procedure_Call_Statement (Loc,\n-        Name => Name, Parameter_Associations => Args);\n+      return\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => Name,\n+          Parameter_Associations => Args);\n    end Make_Task_Create_Call;\n \n    ------------------------------"}, {"sha": "a4c618a61cb4250661d9452ef8fb5f9f60de0a31", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -58,6 +58,11 @@ package Exp_Ch9 is\n    --  build record declaration. N is the type declaration, Ctyp is the\n    --  concurrent entity (task type or protected type).\n \n+   function Build_Entry_Names (Conc_Typ : Entity_Id) return Node_Id;\n+   --  Create the statements which populate the entry names array of a task or\n+   --  protected type. The statements are wrapped inside a block due to a local\n+   --  declaration.\n+\n    procedure Build_Master_Entity (E : Entity_Id);\n    --  Given an entity E for the declaration of an object containing tasks\n    --  or of a type declaration for an allocator whose designated type is a"}, {"sha": "c6b61d551a06f154628259cbee7a24911fa254f6", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -1116,6 +1116,19 @@ package body Exp_Util is\n       end if;\n    end Ensure_Defined;\n \n+   --------------------\n+   -- Entry_Names_OK --\n+   --------------------\n+\n+   function Entry_Names_OK return Boolean is\n+   begin\n+      return\n+        not Restricted_Profile\n+          and then not Global_Discard_Names\n+          and then not Restriction_Active (No_Implicit_Heap_Allocations)\n+          and then not Restriction_Active (No_Local_Allocators);\n+   end Entry_Names_OK;\n+\n    ---------------------\n    -- Evolve_And_Then --\n    ---------------------"}, {"sha": "30d417f2c4f65cb79fd57c49a3863232e2f29db4", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -314,6 +314,11 @@ package Exp_Util is\n    --  used to ensure that an Itype is properly defined outside a conditional\n    --  construct when it is referenced in more than one branch.\n \n+   function Entry_Names_OK return Boolean;\n+   --  Determine whether it is appropriate to dynamically allocate strings\n+   --  which represent entry [family member] names. These strings are created\n+   --  by the compiler and used by GDB.\n+\n    procedure Evolve_And_Then (Cond : in out Node_Id; Cond1 : Node_Id);\n    --  Rewrites Cond with the expression: Cond and then Cond1. If Cond is\n    --  Empty, then simply returns Cond1 (this allows the use of Empty to"}, {"sha": "2c16961c009cc8c1e41e0b6ab855d763e5299a67", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -1516,7 +1516,9 @@ package Rtsfind is\n      RE_Lock_Entries,                    -- Tasking.Protected_Objects.Entries\n      RO_PE_Get_Ceiling,                  -- Tasking.Protected_Objects.Entries\n      RO_PE_Set_Ceiling,                  -- Tasking.Protected_Objects.Entries\n+     RO_PE_Set_Entry_Name,               -- Tasking.Protected_Objects.Entries\n      RE_Unlock_Entries,                  -- Tasking.Protected_Objects.Entries\n+\n      RE_Communication_Block,             -- Protected_Objects.Operations\n      RE_Protected_Entry_Call,            -- Protected_Objects.Operations\n      RE_Service_Entries,                 -- Protected_Objects.Operations\n@@ -1590,6 +1592,7 @@ package Rtsfind is\n      RE_Free_Task,                       -- System.Tasking.Stages\n      RE_Expunge_Unactivated_Tasks,       -- System.Tasking.Stages\n      RE_Move_Activation_Chain,           -- System_Tasking_Stages\n+     RO_TS_Set_Entry_Name,               -- System.Tasking.Stages\n      RE_Terminated);                     -- System.Tasking.Stages\n \n    --  The following declarations build a table that is indexed by the\n@@ -2652,8 +2655,11 @@ package Rtsfind is\n        System_Tasking_Protected_Objects_Entries,\n      RO_PE_Set_Ceiling                   =>\n        System_Tasking_Protected_Objects_Entries,\n+     RO_PE_Set_Entry_Name                =>\n+       System_Tasking_Protected_Objects_Entries,\n      RE_Unlock_Entries                   =>\n        System_Tasking_Protected_Objects_Entries,\n+\n      RE_Communication_Block              =>\n        System_Tasking_Protected_Objects_Operations,\n      RE_Protected_Entry_Call             =>\n@@ -2754,6 +2760,7 @@ package Rtsfind is\n      RE_Free_Task                        => System_Tasking_Stages,\n      RE_Expunge_Unactivated_Tasks        => System_Tasking_Stages,\n      RE_Move_Activation_Chain            => System_Tasking_Stages,\n+     RO_TS_Set_Entry_Name                => System_Tasking_Stages,\n      RE_Terminated                       => System_Tasking_Stages);\n \n    --------------------------------"}, {"sha": "822dc9320fcc58a315bb350eb94ccc095b648693", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -35,13 +35,28 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during tasking\n --  operations. It causes infinite loops and other problems.\n \n+with Ada.Unchecked_Deallocation;\n+\n with System.Task_Primitives.Operations;\n with System.Storage_Elements;\n \n package body System.Tasking is\n \n    package STPO renames System.Task_Primitives.Operations;\n \n+   ----------------------------\n+   -- Free_Entry_Names_Array --\n+   ----------------------------\n+\n+   procedure Free_Entry_Names_Array (Obj : in out Entry_Names_Array) is\n+      procedure Free_String is new\n+        Ada.Unchecked_Deallocation (String, String_Access);\n+   begin\n+      for Index in Obj'Range loop\n+         Free_String (Obj (Index));\n+      end loop;\n+   end Free_Entry_Names_Array;\n+\n    ---------------------\n    -- Detect_Blocking --\n    ---------------------"}, {"sha": "87afc802e54dff56d5feb1b1da9581f99280f3fc", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -237,6 +237,19 @@ package System.Tasking is\n    type Task_Entry_Queue_Array is\n      array (Task_Entry_Index range <>) of Entry_Queue;\n \n+   --  A data structure which contains the string names of entries and entry\n+   --  family members.\n+\n+   type String_Access is access all String;\n+\n+   type Entry_Names_Array is\n+     array (Entry_Index range <>) of String_Access;\n+\n+   type Entry_Names_Array_Access is access all Entry_Names_Array;\n+\n+   procedure Free_Entry_Names_Array (Obj : in out Entry_Names_Array);\n+   --  Deallocate all string names contained in an entry names array\n+\n    ----------------------------------\n    -- Entry_Call_Record definition --\n    ----------------------------------\n@@ -441,19 +454,17 @@ package System.Tasking is\n       --  and rendezvous.\n       --\n       --  Ada 95 notes: In Ada 95, this field will be transferred to the\n-      --  Priority field of an Entry_Calls component when an entry call\n-      --  is initiated. The Priority of the Entry_Calls component will not\n-      --  change for the duration of the call. The accepting task can\n-      --  use it to boost its own priority without fear of its changing in\n-      --  the meantime.\n+      --  Priority field of an Entry_Calls component when an entry call is\n+      --  initiated. The Priority of the Entry_Calls component will not change\n+      --  for the duration of the call. The accepting task can use it to boost\n+      --  its own priority without fear of its changing in the meantime.\n       --\n-      --  This can safely be used in the priority ordering\n-      --  of entry queues. Once a call is queued, its priority does not\n-      --  change.\n+      --  This can safely be used in the priority ordering of entry queues.\n+      --  Once a call is queued, its priority does not change.\n       --\n-      --  Since an entry call cannot be made while executing\n-      --  a protected action, the priority of a task will never reflect a\n-      --  priority ceiling change at the point of an entry call.\n+      --  Since an entry call cannot be made while executing a protected\n+      --  action, the priority of a task will never reflect a priority ceiling\n+      --  change at the point of an entry call.\n       --\n       --  Protection: Only written by Self, and only accessed when Acceptor\n       --  accepts an entry or when Created activates, at which points Self is\n@@ -467,8 +478,8 @@ package System.Tasking is\n       --  can be read/written from protected interrupt handlers.\n \n       Task_Image : String (1 .. System.Parameters.Max_Task_Image_Length);\n-      --  Hold a string that provides a readable id for task,\n-      --  built from the variable of which it is a value or component.\n+      --  Hold a string that provides a readable id for task, built from the\n+      --  variable of which it is a value or component.\n \n       Task_Image_Len : Natural;\n       --  Actual length of Task_Image\n@@ -489,7 +500,7 @@ package System.Tasking is\n \n       Task_Arg : System.Address;\n       --  The argument to task procedure. Provide a handle for discriminant\n-      --  information\n+      --  information.\n       --\n       --  Protection: Part of the synchronization between Self and Activator.\n       --  Activator writes it, once, before Self starts executing. Thereafter,\n@@ -605,10 +616,9 @@ package System.Tasking is\n    -- Restricted_Ada_Task_Control_Block --\n    ---------------------------------------\n \n-   --  This type should only be used by the restricted GNARLI and by\n-   --  restricted GNULL implementations to allocate an ATCB (see\n-   --  System.Task_Primitives.Operations.New_ATCB) that will take\n-   --  significantly less memory.\n+   --  This type should only be used by the restricted GNARLI and by restricted\n+   --  GNULL implementations to allocate an ATCB (see System.Task_Primitives.\n+   --  Operations.New_ATCB) that will take significantly less memory.\n \n    --  Note that the restricted GNARLI should only access fields that are\n    --  present in the Restricted_Ada_Task_Control_Block structure.\n@@ -855,6 +865,11 @@ package System.Tasking is\n       --  associated with protected objects or task entries, and are protected\n       --  by the protected object lock or Acceptor.L, respectively.\n \n+      Entry_Names : Entry_Names_Array_Access := null;\n+      --  An array of string names which denotes entry [family member] names.\n+      --  The structure is indexed by task entry index and contains Entry_Num\n+      --  components.\n+\n       New_Base_Priority : System.Any_Priority;\n       --  New value for Base_Priority (for dynamic priorities package)\n       --"}, {"sha": "09d9070cd4e85d675de019a64d1df0cfd83e7453", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -88,6 +88,9 @@ package body System.Tasking.Stages is\n    procedure Free is new\n      Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n+   procedure Free_Entry_Names (T : Task_Id);\n+   --  Deallocate all string names associated with task entries\n+\n    procedure Trace_Unhandled_Exception_In_Task (Self_Id : Task_Id);\n    --  This procedure outputs the task specific message for exception\n    --  tracing purposes.\n@@ -465,7 +468,8 @@ package body System.Tasking.Stages is\n       Elaborated        : Access_Boolean;\n       Chain             : in out Activation_Chain;\n       Task_Image        : String;\n-      Created_Task      : out Task_Id)\n+      Created_Task      : out Task_Id;\n+      Build_Entry_Names : Boolean)\n    is\n       T, P          : Task_Id;\n       Self_ID       : constant Task_Id := STPO.Self;\n@@ -605,6 +609,11 @@ package body System.Tasking.Stages is\n          T.Common.Task_Image_Len := Len;\n       end if;\n \n+      if Build_Entry_Names then\n+         T.Entry_Names :=\n+           new Entry_Names_Array (1 .. Entry_Index (Num_Entries));\n+      end if;\n+\n       Unlock (Self_ID);\n       Unlock_RTS;\n \n@@ -816,6 +825,26 @@ package body System.Tasking.Stages is\n \n    end Finalize_Global_Tasks;\n \n+   ----------------------\n+   -- Free_Entry_Names --\n+   ----------------------\n+\n+   procedure Free_Entry_Names (T : Task_Id) is\n+      Names : Entry_Names_Array_Access := T.Entry_Names;\n+\n+      procedure Free_Entry_Names_Array_Access is new\n+        Ada.Unchecked_Deallocation\n+          (Entry_Names_Array, Entry_Names_Array_Access);\n+\n+   begin\n+      if Names = null then\n+         return;\n+      end if;\n+\n+      Free_Entry_Names_Array (Names.all);\n+      Free_Entry_Names_Array_Access (Names);\n+   end Free_Entry_Names;\n+\n    ---------------\n    -- Free_Task --\n    ---------------\n@@ -837,6 +866,7 @@ package body System.Tasking.Stages is\n \n          Initialization.Task_Unlock (Self_Id);\n \n+         Free_Entry_Names (T);\n          System.Task_Primitives.Operations.Finalize_TCB (T);\n \n       --  If the task is not terminated, then we simply ignore the call. This\n@@ -895,6 +925,23 @@ package body System.Tasking.Stages is\n       Initialization.Undefer_Abort (Self_ID);\n    end Move_Activation_Chain;\n \n+   --  Compiler interface only. Do not call from within the RTS.\n+\n+   --------------------\n+   -- Set_Entry_Name --\n+   --------------------\n+\n+   procedure Set_Entry_Name\n+     (T   : Task_Id;\n+      Pos : Task_Entry_Index;\n+      Val : String_Access)\n+   is\n+   begin\n+      pragma Assert (T.Entry_Names /= null);\n+\n+      T.Entry_Names (Entry_Index (Pos)) := Val;\n+   end Set_Entry_Name;\n+\n    ------------------\n    -- Task_Wrapper --\n    ------------------\n@@ -1419,15 +1466,15 @@ package body System.Tasking.Stages is\n    --------------------------------\n \n    procedure Vulnerable_Complete_Master (Self_ID : Task_Id) is\n-      C      : Task_Id;\n-      P      : Task_Id;\n-      CM     : constant Master_Level := Self_ID.Master_Within;\n-      T      : aliased Task_Id;\n+      C  : Task_Id;\n+      P  : Task_Id;\n+      CM : constant Master_Level := Self_ID.Master_Within;\n+      T  : aliased Task_Id;\n \n       To_Be_Freed : Task_Id;\n-      --  This is a list of ATCBs to be freed, after we have released\n-      --  all RTS locks. This is necessary because of the locking order\n-      --  rules, since the storage manager uses Global_Task_Lock.\n+      --  This is a list of ATCBs to be freed, after we have released all RTS\n+      --  locks. This is necessary because of the locking order rules, since\n+      --  the storage manager uses Global_Task_Lock.\n \n       pragma Warnings (Off);\n       function Check_Unactivated_Tasks return Boolean;\n@@ -1877,6 +1924,7 @@ package body System.Tasking.Stages is\n          Unlock_RTS;\n       end if;\n \n+      Free_Entry_Names (T);\n       System.Task_Primitives.Operations.Finalize_TCB (T);\n    end Vulnerable_Free_Task;\n "}, {"sha": "cee2d3b958e2e78b42f56572395efb78cdbba46e", "filename": "gcc/ada/s-tassta.ads", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-tassta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-tassta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.ads?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -180,7 +180,8 @@ package System.Tasking.Stages is\n       Elaborated        : Access_Boolean;\n       Chain             : in out Activation_Chain;\n       Task_Image        : String;\n-      Created_Task      : out Task_Id);\n+      Created_Task      : out Task_Id;\n+      Build_Entry_Names : Boolean);\n    --  Compiler interface only. Do not call from within the RTS.\n    --  This must be called to create a new task.\n    --\n@@ -190,7 +191,7 @@ package System.Tasking.Stages is\n    --  Task_Info is the task info associated with the created task, or\n    --   Unspecified_Task_Info if none.\n    --  Relative_Deadline is the relative deadline associated with the created\n-   --  task by means of a pragma Relative_Deadline, or 0.0 if none.\n+   --   task by means of a pragma Relative_Deadline, or 0.0 if none.\n    --  State is the compiler generated task's procedure body\n    --  Discriminants is a pointer to a limited record whose discriminants\n    --   are those of the task to create. This parameter should be passed as\n@@ -205,6 +206,8 @@ package System.Tasking.Stages is\n    --   run time can store to ease the debugging and the\n    --   Ada.Task_Identification facility.\n    --  Created_Task is the resulting task.\n+   --  Build_Entry_Names is a flag which controls the allocation of the data\n+   --   structure which stores all entry names.\n    --\n    --  This procedure can raise Storage_Error if the task creation failed.\n \n@@ -276,6 +279,13 @@ package System.Tasking.Stages is\n    --  that doesn't happen, they will never be activated, and will become\n    --  terminated on leaving the return statement.\n \n+   procedure Set_Entry_Name\n+     (T   : Task_Id;\n+      Pos : Task_Entry_Index;\n+      Val : String_Access);\n+   --  This is called by the compiler to map a string which denotes an entry\n+   --  name to a task entry index.\n+\n    function Terminated (T : Task_Id) return Boolean;\n    --  This is called by the compiler to implement the 'Terminated attribute.\n    --  Though is not required to be so by the ARM, we choose to synchronize"}, {"sha": "38126956b9e1b15c91a2ed4cc3ad2c36c52e860b", "filename": "gcc/ada/s-tpoben.adb", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-tpoben.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-tpoben.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.adb?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -43,6 +43,8 @@\n \n --  Note: the compiler generates direct calls to this interface, via Rtsfind\n \n+with Ada.Unchecked_Deallocation;\n+\n with System.Task_Primitives.Operations;\n with System.Restrictions;\n with System.Parameters;\n@@ -58,6 +60,13 @@ package body System.Tasking.Protected_Objects.Entries is\n    use Parameters;\n    use Task_Primitives.Operations;\n \n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Free_Entry_Names (Object : Protection_Entries);\n+   --  Deallocate all string names associated with protected entries\n+\n    ----------------\n    -- Local Data --\n    ----------------\n@@ -134,6 +143,8 @@ package body System.Tasking.Protected_Objects.Entries is\n          end loop;\n       end loop;\n \n+      Free_Entry_Names (Object);\n+\n       Object.Finalized := True;\n \n       if Single_Lock then\n@@ -145,6 +156,26 @@ package body System.Tasking.Protected_Objects.Entries is\n       STPO.Finalize_Lock (Object.L'Unrestricted_Access);\n    end Finalize;\n \n+   ----------------------\n+   -- Free_Entry_Names --\n+   ----------------------\n+\n+   procedure Free_Entry_Names (Object : Protection_Entries) is\n+      Names : Entry_Names_Array_Access := Object.Entry_Names;\n+\n+      procedure Free_Entry_Names_Array_Access is new\n+        Ada.Unchecked_Deallocation\n+          (Entry_Names_Array, Entry_Names_Array_Access);\n+\n+   begin\n+      if Names = null then\n+         return;\n+      end if;\n+\n+      Free_Entry_Names_Array (Names.all);\n+      Free_Entry_Names_Array_Access (Names);\n+   end Free_Entry_Names;\n+\n    -----------------\n    -- Get_Ceiling --\n    -----------------\n@@ -177,14 +208,15 @@ package body System.Tasking.Protected_Objects.Entries is\n       Ceiling_Priority  : Integer;\n       Compiler_Info     : System.Address;\n       Entry_Bodies      : Protected_Entry_Body_Access;\n-      Find_Body_Index   : Find_Body_Index_Access)\n+      Find_Body_Index   : Find_Body_Index_Access;\n+      Build_Entry_Names : Boolean)\n    is\n       Init_Priority : Integer := Ceiling_Priority;\n       Self_ID       : constant Task_Id := STPO.Self;\n \n    begin\n       if Init_Priority = Unspecified_Priority then\n-         Init_Priority  := System.Priority'Last;\n+         Init_Priority := System.Priority'Last;\n       end if;\n \n       if Locking_Policy = 'C'\n@@ -213,6 +245,11 @@ package body System.Tasking.Protected_Objects.Entries is\n          Object.Entry_Queues (E).Head := null;\n          Object.Entry_Queues (E).Tail := null;\n       end loop;\n+\n+      if Build_Entry_Names then\n+         Object.Entry_Names :=\n+           new Entry_Names_Array (1 .. Entry_Index (Object.Num_Entries));\n+      end if;\n    end Initialize_Protection_Entries;\n \n    ------------------\n@@ -357,6 +394,21 @@ package body System.Tasking.Protected_Objects.Entries is\n       Object.New_Ceiling := Prio;\n    end Set_Ceiling;\n \n+   --------------------\n+   -- Set_Entry_Name --\n+   --------------------\n+\n+   procedure Set_Entry_Name\n+     (Object : Protection_Entries'Class;\n+      Pos    : Protected_Entry_Index;\n+      Val    : String_Access)\n+   is\n+   begin\n+      pragma Assert (Object.Entry_Names /= null);\n+\n+      Object.Entry_Names (Entry_Index (Pos)) := Val;\n+   end Set_Entry_Name;\n+\n    --------------------\n    -- Unlock_Entries --\n    --------------------"}, {"sha": "b3dea7b03d2229d07e3c5da19ca2b20654d02b8c", "filename": "gcc/ada/s-tpoben.ads", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-tpoben.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c42e6724e10f71991cc5e01a4013d77036b06099/gcc%2Fada%2Fs-tpoben.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.ads?ref=c42e6724e10f71991cc5e01a4013d77036b06099", "patch": "@@ -113,7 +113,7 @@ package System.Tasking.Protected_Objects.Entries is\n       Old_Base_Priority : System.Any_Priority;\n       --  Task's base priority when the protected operation was called\n \n-      Pending_Action  : Boolean;\n+      Pending_Action : Boolean;\n       --  Flag indicating that priority has been dipped temporarily in order\n       --  to avoid violating the priority ceiling of the lock associated with\n       --  this protected object, in Lock_Server. The flag tells Unlock_Server\n@@ -132,11 +132,16 @@ package System.Tasking.Protected_Objects.Entries is\n       --  Pointer to an array containing the executable code for all entry\n       --  bodies of a protected type.\n \n-      --  The following function maps the entry index in a call (which denotes\n-      --  the queue to the proper entry) into the body of the entry.\n-\n       Find_Body_Index : Find_Body_Index_Access;\n-      Entry_Queues      : Protected_Entry_Queue_Array (1 .. Num_Entries);\n+      --  A function which maps the entry index in a call (which denotes the\n+      --  queue of the proper entry) into the body of the entry.\n+\n+      Entry_Queues : Protected_Entry_Queue_Array (1 .. Num_Entries);\n+\n+      Entry_Names : Entry_Names_Array_Access := null;\n+      --  An array of string names which denotes entry [family member] names.\n+      --  The structure is indexed by protected entry index and contains Num_\n+      --  Entries components.\n    end record;\n \n    --  No default initial values for this type, since call records\n@@ -164,11 +169,12 @@ package System.Tasking.Protected_Objects.Entries is\n    --  System.Tasking.Protected_Objects.Initialize_Protection.\n \n    procedure Initialize_Protection_Entries\n-     (Object           : Protection_Entries_Access;\n-      Ceiling_Priority : Integer;\n-      Compiler_Info    : System.Address;\n-      Entry_Bodies     : Protected_Entry_Body_Access;\n-      Find_Body_Index  : Find_Body_Index_Access);\n+     (Object            : Protection_Entries_Access;\n+      Ceiling_Priority  : Integer;\n+      Compiler_Info     : System.Address;\n+      Entry_Bodies      : Protected_Entry_Body_Access;\n+      Find_Body_Index   : Find_Body_Index_Access;\n+      Build_Entry_Names : Boolean);\n    --  Initialize the Object parameter so that it can be used by the runtime\n    --  to keep track of the runtime state of a protected object.\n \n@@ -202,6 +208,13 @@ package System.Tasking.Protected_Objects.Entries is\n       Prio   : System.Any_Priority);\n    --  Sets the new ceiling priority of the protected object\n \n+   procedure Set_Entry_Name\n+     (Object : Protection_Entries'Class;\n+      Pos    : Protected_Entry_Index;\n+      Val    : String_Access);\n+   --  This is called by the compiler to map a string which denotes an entry\n+   --  name to a protected entry index.\n+\n    procedure Unlock_Entries (Object : Protection_Entries_Access);\n    --  Relinquish ownership of the lock for the object represented by the\n    --  Object parameter. If this ownership was for write access, or if it was"}]}