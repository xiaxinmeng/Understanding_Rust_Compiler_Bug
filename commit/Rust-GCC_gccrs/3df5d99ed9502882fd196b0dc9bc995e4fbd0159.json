{"sha": "3df5d99ed9502882fd196b0dc9bc995e4fbd0159", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RmNWQ5OWVkOTUwMjg4MmZkMTk2YjBkYzliYzk5NWU0ZmJkMDE1OQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "s.pop@laposte.net", "date": "2002-10-19T10:12:33Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2002-10-19T10:12:33Z"}, "message": "dependence.c: Removed.\n\n\n        * dependence.c : Removed.\n        * Makefile.in : Remove dependence.o.\n\nFrom-SVN: r58307", "tree": {"sha": "ae69863137cda23597e122f2805e810aae0e37fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae69863137cda23597e122f2805e810aae0e37fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3df5d99ed9502882fd196b0dc9bc995e4fbd0159", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3df5d99ed9502882fd196b0dc9bc995e4fbd0159", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3df5d99ed9502882fd196b0dc9bc995e4fbd0159", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3df5d99ed9502882fd196b0dc9bc995e4fbd0159/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "822eda12605c08abde5e4d3f388f3cd85b198412", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/822eda12605c08abde5e4d3f388f3cd85b198412", "html_url": "https://github.com/Rust-GCC/gccrs/commit/822eda12605c08abde5e4d3f388f3cd85b198412"}], "stats": {"total": 1476, "additions": 8, "deletions": 1468}, "files": [{"sha": "9274dd3bd7ecdcea00e496e9944cfe470757bc82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3df5d99ed9502882fd196b0dc9bc995e4fbd0159/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3df5d99ed9502882fd196b0dc9bc995e4fbd0159/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3df5d99ed9502882fd196b0dc9bc995e4fbd0159", "patch": "@@ -1,3 +1,8 @@\n+2002-10-19  Sebastian Pop  <s.pop@laposte.net>\n+\n+\t* dependence.c : Removed.\n+        * Makefile.in : Remove dependence.o.\n+\n Sat Oct 19 10:46:52 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* mmintrin.h (__m64): typedef it to v2si."}, {"sha": "eb4596e0083a858af9e3921ebd88f072d4c33f74", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3df5d99ed9502882fd196b0dc9bc995e4fbd0159/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3df5d99ed9502882fd196b0dc9bc995e4fbd0159/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3df5d99ed9502882fd196b0dc9bc995e4fbd0159", "patch": "@@ -735,7 +735,7 @@ C_OBJS = c-parse.o c-lang.o c-pretty-print.o $(C_AND_OBJC_OBJS)\n OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgrtl.o combine.o conflict.o convert.o cse.o cselib.o dbxout.o\t   \\\n- debug.o dependence.o df.o diagnostic.o doloop.o dominance.o\t\t   \\\n+ debug.o df.o diagnostic.o doloop.o dominance.o\t\t                   \\\n  dwarf2asm.o dwarf2out.o dwarfout.o emit-rtl.o except.o explow.o\t   \\\n  expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o\t\t   \\\n  genrtl.o ggc-common.o global.o graph.o gtype-desc.o\t\t\t   \\\n@@ -1638,8 +1638,6 @@ regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) insn-config.h \\\n ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) toplev.h \\\n    flags.h insn-config.h function.h $(RECOG_H) $(BASIC_BLOCK_H) $(EXPR_H) \\\n    output.h except.h $(TM_P_H) real.h\n-dependence.o : dependence.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n-   $(C_COMMON_H) flags.h varray.h $(EXPR_H) $(GGC_H) gt-dependence.h\n params.o : params.c $(CONFIG_H) $(SYSTEM_H) $(PARAMS_H) toplev.h\n hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) $(HOOKS_H)\n \n@@ -1842,7 +1840,7 @@ GTFILES = $(GCONFIG_H) $(srcdir)/location.h \\\n   $(srcdir)/c-common.h $(srcdir)/c-tree.h \\\n   $(srcdir)/basic-block.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c \\\n-  $(srcdir)/dependence.c $(srcdir)/dwarf2out.c $(srcdir)/emit-rtl.c \\\n+  $(srcdir)/dwarf2out.c $(srcdir)/emit-rtl.c \\\n   $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\\n   $(srcdir)/fold-const.c $(srcdir)/function.c \\\n   $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n@@ -1863,7 +1861,7 @@ gt-integrate.h gt-stmt.h gt-tree.h gt-varasm.h gt-emit-rtl.h : s-gtype; @true\n gt-explow.h gt-stor-layout.h gt-regclass.h gt-lists.h : s-gtype; @true\n gt-alias.h gt-cselib.h gt-fold-const.h gt-gcse.h gt-profile.h : s-gtype; @true\n gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dwarf2out.h : s-gtype ; @true\n-gt-ra-build.h gt-reg-stack.h gt-dependence.h : s-gtype ; @true\n+gt-ra-build.h gt-reg-stack.h : s-gtype ; @true\n gt-c-common.h gt-c-decl.h gt-c-parse.h gt-c-pragma.h : s-gtype; @true\n gt-c-objc-common.h gtype-c.h gt-location.h : s-gtype ; @true\n "}, {"sha": "ec46d988bf191c2ce312335172b0e41b614bf406", "filename": "gcc/dependence.c", "status": "removed", "additions": 0, "deletions": 1463, "changes": 1463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822eda12605c08abde5e4d3f388f3cd85b198412/gcc%2Fdependence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822eda12605c08abde5e4d3f388f3cd85b198412/gcc%2Fdependence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdependence.c?ref=822eda12605c08abde5e4d3f388f3cd85b198412", "patch": "@@ -1,1463 +0,0 @@\n-/* Analyze loop dependencies\n-   Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-/* References:\n-   Practical Dependence Testing, Goff, Kennedy, Tseng, PLDI, 1991\n-   High Performance Compilers for Parallel Computing, Wolfe\n-*/\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-\n-#include \"rtl.h\"\n-#include \"expr.h\"\n-#include \"tree.h\"\n-#include \"c-common.h\"\n-#include \"flags.h\"\n-#include \"ggc.h\"\n-#include \"varray.h\"\n-\n-#define MAX_SUBSCRIPTS 13\n-\n-/*\n-   We perform the following steps:\n-\n-   Build the data structures def_use_chain, loop_chain, and induction_chain.\n-\n-   Determine if a loop index is a normalized induction variable.\n-   A loop is currently considered to be a for loop having an index set to an\n-   initial value, conditional check of the index, and increment/decrement of\n-   the index.\n-\n-   Determine the distance and direction vectors.  Both are two dimensioned\n-   arrays where the first dimension represents a loop and the second\n-   dimension represents a subscript.  Dependencies are actually per loop, not\n-   per subscript.  So for:\n-   for (i = 0; i < 10; i++)\n-       for (j = 0; j < 10; j++)\n-           array [i][j] = array[i][j-1]\n-   We find the dependencies: loop1/sub_i, loop1/sub_j, loop2/sub_i, loop2/sub_j\n-   and then intersect loop1/sub_i V loop2/sub_i and loop1/sub_i V loop2/sub_j\n-   We determine the type of dependence, which determines which test we use.\n-   We then try to refine the type of dependence we have and add the\n-   dependence to the dep_chain\n-*/\n-\n-enum dependence_type {dt_flow, dt_anti, dt_output, dt_none};\n-#if 0\n-static const char *const dependence_string [] = {\"flow\", \"anti\", \"output\", \"none\"};\n-#endif\n-enum direction_type {lt, le, eq, gt, ge, star, independent, undef};\n-#if 0\n-static const char *const direction_string [] = {\"<\", \"<=\", \"=\", \">\", \">=\", \"*\",\n-\t\t\t\t\t   \"INDEPENDENT\", \"UNDEFINED\"};\n-#endif\n-enum def_use_type {def, use, init_def_use};\n-\n-enum du_status_type {seen, unseen};\n-\n-enum loop_status_type {normal, unnormal};\n-\n-enum complexity_type {ziv, strong_siv, weak_siv, weak_zero_siv,\n-\t\t      weak_crossing_siv, miv};\n-\n-/* Given a def/use one can chase the next chain to follow the def/use\n-   for that variable.  Alternately one can sequentially follow each\n-   element of def_use_chain.  */\n-\n-typedef struct def_use GTY(())\n-{\n-  /* outermost loop */\n-  tree outer_loop;\n-  /* loop containing this def/use */\n-  tree containing_loop;\n-  /* this expression */\n-  tree expression;\n-  /* our name */\n-  const char *variable;\n-  /* def or use */\n-  enum def_use_type type;\n-  /* status flags */\n-  enum du_status_type status;\n-  /* next def/use for this same name */\n-  struct def_use *next;\n-  /* dependencies for this def */\n-  struct dependence *dep;\n-} def_use;\n-\n-/* Given a loop* one can chase the next_nest chain to follow the nested\n-   loops for that loop.  Alternately one can sequentially follow each\n-   element of loop_chain and check outer_loop to get all loops\n-   contained within a certain loop.  */\n-\n-typedef struct loop GTY(())\n-{\n-  /* outermost loop containing this loop */\n-  tree outer_loop;\n-  /* this loop */\n-  tree containing_loop;\n-  /* nest level for this loop */\n-  int  depth;\n-  /* can loop be normalized? */\n-  enum loop_status_type status;\n-  /* loop* for loop contained in this loop */\n-  struct loop *next_nest;\n-  /* induction variables for this loop.  Currently only the index variable.  */\n-  struct induction *ind;\n-} loop;\n-\n-/* Pointed to by loop. One per induction variable.  */\n-\n-typedef struct induction GTY(())\n-{\n-  /* our name */\n-  const char *variable;\n-  /* increment.  Currently only +1 or -1 */\n-  int  increment;\n-  /* lower bound */\n-  int  low_bound;\n-  /* upper bound */\n-  int  high_bound;\n-  /* next induction variable for this loop.  Currently null.  */\n-  struct induction *next;\n-} induction;\n-\n-/* Pointed to by def/use.  One per dependence.  */\n-\n-typedef struct dependence GTY(())\n-{\n-  tree source;\n-  tree destination;\n-  enum dependence_type dependence;\n-  enum direction_type direction[MAX_SUBSCRIPTS];\n-  int distance[MAX_SUBSCRIPTS];\n-  struct dependence *next;\n-} dependence;\n-\n-/* subscripts are represented by an array of these.  Each reflects one\n-   X * i + Y term, where X and Y are constants.  */\n-\n-typedef struct subscript\n-{\n-  /* ordinal subscript number */\n-  int position;\n-  /* X in X * i + Y */\n-  int coefficient;\n-  /* Y in X * i + Y */\n-  int offset;\n-  /* our name */\n-  const char *variable;\n-  /* next subscript term.  Currently null.  */\n-  struct subscript *next;\n-} subscript;\n-\n-/* Remember the destination the front end encountered.  */\n-\n-static tree dest_to_remember;\n-\n-/* Chain for def_use */\n-static GTY ((param_is (def_use))) varray_type def_use_chain;\n-\n-/* Chain for dependence */\n-static GTY ((param_is (dependence))) varray_type dep_chain;\n-\n-/* Chain for loop */\n-static GTY ((param_is (loop))) varray_type loop_chain;\n-\n-/* Chain for induction */\n-static GTY ((param_is (induction))) varray_type induction_chain;\n-\n-void init_dependence_analysis PARAMS ((tree));\n-static void build_def_use PARAMS ((tree, enum def_use_type));\n-static loop* add_loop PARAMS ((tree, tree, int));\n-static int find_induction_variable PARAMS ((tree, tree, tree, loop*));\n-static int get_low_bound PARAMS ((tree, const char*));\n-static int have_induction_variable PARAMS ((tree, const char*));\n-static void link_loops PARAMS ((void));\n-static void get_node_dependence PARAMS ((void));\n-static void check_node_dependence PARAMS ((def_use*));\n-static int get_coefficients PARAMS ((def_use*, subscript[]));\n-static int get_one_coefficient PARAMS ((tree, subscript*, def_use*, enum tree_code*));\n-static void normalize_coefficients PARAMS ((subscript[], loop*, int));\n-static void classify_dependence PARAMS ((subscript[], subscript[],\n-\t\t\t\t enum complexity_type[], int*, int));\n-static void ziv_test PARAMS ((subscript[], subscript[],\n-\t\t\t      enum direction_type[][MAX_SUBSCRIPTS],\n-\t\t\t      int[][MAX_SUBSCRIPTS], loop*, int));\n-static void siv_test PARAMS ((subscript[], subscript[],\n-\t\t\t      enum direction_type[][MAX_SUBSCRIPTS],\n-\t\t\t      int[][MAX_SUBSCRIPTS], loop*, int));\n-static int check_subscript_induction PARAMS ((subscript*, subscript*, loop*));\n-static void gcd_test PARAMS ((subscript[], subscript[], enum\n-\t\t\t      direction_type[][MAX_SUBSCRIPTS],\n-\t\t\t      int[][MAX_SUBSCRIPTS], loop*, int));\n-static int find_gcd PARAMS ((int, int));\n-static void merge_dependencies PARAMS ((enum direction_type[][MAX_SUBSCRIPTS],\n-\t\t\t\t\tint[][MAX_SUBSCRIPTS], int, int));\n-static void dump_array_ref PARAMS ((tree));\n-#if 0\n-static void dump_one_node PARAMS ((def_use*, varray_type*));\n-static void dump_node_dependence PARAMS ((void));\n-#endif\n-int search_dependence PARAMS ((tree));\n-void remember_dest_for_dependence PARAMS ((tree));\n-int have_dependence_p PARAMS ((rtx, rtx, enum direction_type[], int[]));\n-void end_dependence_analysis PARAMS ((void));\n-\n-/* Build dependence chain 'dep_chain', which is used by have_dependence_p,\n-   for the function given by EXP.  */\n-\n-void\n-init_dependence_analysis (exp)\n-     tree exp;\n-{\n-  VARRAY_GENERIC_PTR_INIT (def_use_chain, 50, \"def_use_chain\");\n-  VARRAY_GENERIC_PTR_INIT (dep_chain, 50, \"dep_chain\");\n-  VARRAY_GENERIC_PTR_INIT (loop_chain, 50, \"loop_chain\");\n-  VARRAY_GENERIC_PTR_INIT (induction_chain, 50, \"induction_chain\");\n-\n-  build_def_use (exp, init_def_use);\n-\n-  link_loops ();\n-\n-  get_node_dependence ();\n-\n-  /* dump_node_dependence (&def_use_chain);*/\n-\n-  def_use_chain = 0;\n-  loop_chain = 0;\n-  induction_chain = 0;\n-}\n-\n-/* Build ARRAY_REF def/use info 'def_use_chain' starting at EXP which is a def\n-   or use DU_TYPE */\n-\n-static void\n-build_def_use (exp, du_type)\n-     tree exp;\n-     enum def_use_type du_type;\n-{\n-  static tree outer_loop;\n-  static int nloop;\n-  static tree current_loop;\n-  static int du_idx;\n-  static loop *loop_def;\n-  tree node = exp;\n-  tree array_ref;\n-  def_use *du_ptr;\n-\n-  if (du_type == init_def_use)\n-    {\n-      outer_loop = 0;\n-      nloop = 0;\n-      du_idx = 0;\n-    }\n-\n-  while (node)\n-    switch (TREE_CODE (node))\n-      {\n-      case COMPOUND_STMT:\n-\tnode = TREE_OPERAND (node, 0);\n-\tbreak;\n-      case TREE_LIST:\n-\tbuild_def_use (TREE_VALUE (node), 0);\n-\tnode = TREE_CHAIN (node);\n-\tbreak;\n-      case CALL_EXPR:\n-\tnode = TREE_CHAIN (node);\n-\tbreak;\n-      case FOR_STMT:\n-\tif (! nloop) outer_loop = node;\n-\tnloop++;\n-\tcurrent_loop = node;\n-\tloop_def = add_loop (node, outer_loop, nloop);\n-\tif (find_induction_variable (TREE_OPERAND (node, 0),\n-\t\t\t\t     TREE_OPERAND (node, 1),\n-\t\t\t\t     TREE_OPERAND (node, 2), loop_def)\n-\t    == 0)\n-\t  loop_def->status = unnormal;\n-\n-\tbuild_def_use (TREE_OPERAND (node, 3), 0);\n-\tnloop--;\n-\tcurrent_loop = 0;\n-\tnode = TREE_CHAIN (node);\n-\tbreak;\n-      case MODIFY_EXPR:\n-\t/* Is an induction variable modified? */\n-\tif (loop_def\n-\t    && TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL\n-\t    && have_induction_variable\n-\t       (loop_def->outer_loop,\n-\t\tIDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (node, 0)))) >= 0)\n-\t  loop_def->status = unnormal;\n-\n-\tif (TREE_CODE (TREE_OPERAND (node, 0)) == ARRAY_REF\n-\t    || TREE_CODE (TREE_OPERAND (node, 0)) == INDIRECT_REF)\n-\t  build_def_use (TREE_OPERAND (node, 0), def);\n-\n-\tbuild_def_use (TREE_OPERAND (node, 1), use);\n-\tnode = TREE_CHAIN (node);\n-\tbreak;\n-      case INDIRECT_REF:\n-\tif (! TREE_OPERAND (node, 1)\n-\t    || TREE_CODE (TREE_OPERAND (node, 1)) != ARRAY_REF)\n-\t  {\n-\t    node = 0;\n-\t    break;\n-\t  }\n-\tnode = TREE_OPERAND (node, 1);\n-      case ARRAY_REF:\n-\tif (nloop)\n-\t  {\n-\t    int i;\n-\t    char null_string = '\\0';\n-\n-\t    VARRAY_PUSH_GENERIC_PTR (def_use_chain, \n-\t\t\t\t     ggc_alloc (sizeof (def_use)));\n-\t    du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx++);\n-\t    du_ptr->type = du_type;\n-\t    du_ptr->status = unseen;\n-\t    du_ptr->outer_loop = outer_loop;\n-\t    du_ptr->containing_loop = current_loop;\n-\t    du_ptr->expression = node;\n-\t    du_ptr->variable = &null_string;\n-\t    du_ptr->next = 0;\n-\t    du_ptr->dep = 0;\n-\t    for (array_ref = node;\n-\t\t TREE_CODE (array_ref) == ARRAY_REF;\n-\t\t array_ref = TREE_OPERAND (array_ref, 0))\n-\t      ;\n-\n-\t    if (TREE_CODE (array_ref) == COMPONENT_REF)\n-\t      {\n-\t\tarray_ref = TREE_OPERAND (array_ref, 1);\n-\t\tif (! (TREE_CODE (array_ref) == FIELD_DECL\n-\t\t       && TREE_CODE (TREE_TYPE (array_ref)) == ARRAY_TYPE))\n-\t\t  {\n-\t\t    node = 0;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\n-\t    for (i = 0;\n-\t\t i < du_idx\n-\t\t   && strcmp (IDENTIFIER_POINTER (DECL_NAME (array_ref)),\n-\t\t\t      ((def_use*) (VARRAY_GENERIC_PTR\n-\t\t\t\t\t   (def_use_chain, i)))->variable);\n-\t\t i++)\n-\t      ;\n-\t    if (i != du_idx)\n-\t      {\n-\t\tdef_use *tmp_duc;\n-\t\tfor (tmp_duc = ((def_use*) (VARRAY_GENERIC_PTR (def_use_chain, i)));\n-\t\t     tmp_duc->next;\n-\t\t     tmp_duc = ((def_use*)tmp_duc->next));\n-\t\ttmp_duc->next = du_ptr;\n-\t      }\n-\t    else du_ptr->next = 0;\n-\t    du_ptr->variable = IDENTIFIER_POINTER (DECL_NAME (array_ref));\n-\t  }\n-\tnode = 0;\n-\tbreak;\n-\n-      case SCOPE_STMT:\n-      case DECL_STMT:\n-\tnode = TREE_CHAIN (node);\n-\tbreak;\n-\n-      case EXPR_STMT:\n-\tif (TREE_CODE (TREE_OPERAND (node, 0)) == MODIFY_EXPR)\n-\t  build_def_use (TREE_OPERAND (node, 0), def);\n-\tnode = TREE_CHAIN (node);\n-\tbreak;\n-\n-      default:\n-\tif (TREE_CODE_CLASS (TREE_CODE (node)) == '2')\n-\t  {\n-\t    build_def_use (TREE_OPERAND (node, 0), use);\n-\t    build_def_use (TREE_OPERAND (node, 1), use);\n-\t    node = TREE_CHAIN (node);\n-\t  }\n-\telse\n-\t  node = 0;\n-      }\n-}\n-\n-/* Add a loop to 'loop_chain' corresponding to for loop LOOP_NODE at depth\n-   NLOOP, whose outermost loop is OUTER_LOOP */\n-\n-static loop*\n-add_loop (loop_node, outer_loop, nloop)\n-     tree loop_node;\n-     tree outer_loop;\n-     int nloop;\n-{\n-  loop *loop_ptr;\n-\n-  VARRAY_PUSH_GENERIC_PTR (loop_chain, ggc_alloc (sizeof (loop)));\n-  loop_ptr = VARRAY_TOP (loop_chain, generic);\n-  loop_ptr->outer_loop = outer_loop;\n-  loop_ptr->containing_loop = loop_node;\n-  loop_ptr->depth = nloop;\n-  loop_ptr->status = normal;\n-  loop_ptr->next_nest = 0;\n-  loop_ptr->ind = 0;\n-  return loop_ptr;\n-}\n-\n-/* Update LOOP_DEF if for loop's COND_NODE and INCR_NODE define an index that\n-   is a normalized induction variable.  */\n-\n-static int\n-find_induction_variable (init_node, cond_node, incr_node, loop_def)\n-     tree init_node;\n-     tree cond_node;\n-     tree incr_node;\n-     loop *loop_def;\n-{\n-  induction *ind_ptr;\n-  enum tree_code incr_code;\n-  tree incr;\n-\n-  if (! init_node || ! incr_node || ! cond_node)\n-    return 0;\n-  /* Allow for ',' operator in increment expression of FOR */\n-\n-  incr = incr_node;\n-  while (TREE_CODE (incr) == COMPOUND_EXPR)\n-    {\n-      incr_code = TREE_CODE (TREE_OPERAND (incr, 0));\n-      if (incr_code == PREDECREMENT_EXPR || incr_code == POSTDECREMENT_EXPR\n-\t  || incr_code == PREINCREMENT_EXPR || incr_code == POSTINCREMENT_EXPR)\n-\t{\n-\t  incr_node = TREE_OPERAND (incr, 0);\n-\t  break;\n-\t}\n-      incr_code = TREE_CODE (TREE_OPERAND (incr, 1));\n-      if (incr_code == PREDECREMENT_EXPR || incr_code == POSTDECREMENT_EXPR\n-\t  || incr_code == PREINCREMENT_EXPR || incr_code == POSTINCREMENT_EXPR)\n-\t{\n-\t  incr_node = TREE_OPERAND (incr, 1);\n-\t  break;\n-\t}\n-      incr = TREE_OPERAND (incr, 1);\n-    }\n-\n-  /* Allow index condition to be part of logical expression */\n-  cond_node = TREE_VALUE (cond_node);\n-  incr = cond_node;\n-\n-#define INDEX_LIMIT_CHECK(NODE) \\\n-      (TREE_CODE_CLASS (TREE_CODE (NODE)) == '<') \\\n-\t&& (TREE_CODE (TREE_OPERAND (NODE, 0)) == VAR_DECL \\\n-\t    && (IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (NODE, 0))) \\\n-\t\t== IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (incr_node, 0))))) \\\n-      ? 1 : 0\n-\n-  while (TREE_CODE (incr) == TRUTH_ANDIF_EXPR\n-\t || TREE_CODE (incr) == TRUTH_ORIF_EXPR)\n-    {\n-      if (INDEX_LIMIT_CHECK (TREE_OPERAND (incr, 0)))\n-\t  {\n-\t    cond_node = TREE_OPERAND (incr, 0);\n-\t    break;\n-\t  }\n-      if (INDEX_LIMIT_CHECK (TREE_OPERAND (incr, 1)))\n-\t  {\n-\t    cond_node = TREE_OPERAND (incr, 1);\n-\t    break;\n-\t  }\n-      incr = TREE_OPERAND (incr, 0);\n-    }\n-\n-  incr_code = TREE_CODE (incr_node);\n-  if ((incr_code == PREDECREMENT_EXPR || incr_code == POSTDECREMENT_EXPR\n-       || incr_code == PREINCREMENT_EXPR || incr_code == POSTINCREMENT_EXPR)\n-      && TREE_CODE_CLASS (TREE_CODE (cond_node)) == '<')\n-    {\n-      if (!INDEX_LIMIT_CHECK (cond_node))\n-\treturn 0;\n-\n-      VARRAY_PUSH_GENERIC_PTR (induction_chain, \n-\t\t\t       ggc_alloc (sizeof (induction)));\n-      ind_ptr = VARRAY_TOP (induction_chain, generic);\n-      loop_def->ind = ind_ptr;\n-      ind_ptr->variable = IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND\n-\t\t\t\t\t\t\t (incr_node, 0)));\n-      ind_ptr->increment = TREE_INT_CST_LOW (TREE_OPERAND (incr_node, 1));\n-      if (TREE_CODE (incr_node) == PREDECREMENT_EXPR\n-\t  || TREE_CODE (incr_node) == POSTDECREMENT_EXPR)\n-\tind_ptr->increment = -ind_ptr->increment;\n-\n-      ind_ptr->low_bound = get_low_bound (init_node, ind_ptr->variable);\n-      if (TREE_CODE (TREE_OPERAND (cond_node, 0)) == VAR_DECL\n-\t  && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (cond_node, 0)))\n-\t     == ind_ptr->variable)\n-\t{\n-\t  if (TREE_CODE (TREE_OPERAND (cond_node, 1)) == INTEGER_CST)\n-\t    ind_ptr->high_bound =\n-\t      TREE_INT_CST_LOW (TREE_OPERAND (cond_node, 1));\n-\t  else\n-\t    ind_ptr->high_bound = ind_ptr->increment < 0 ? INT_MIN : INT_MAX;\n-\t}\n-      else if (TREE_CODE (TREE_OPERAND (cond_node, 1)) == VAR_DECL\n-\t  && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (cond_node, 1)))\n-\t       == ind_ptr->variable)\n-\t{\n-\t  if (TREE_CODE (TREE_OPERAND (cond_node, 0)) == INTEGER_CST)\n-\t    ind_ptr->high_bound =\n-\t      TREE_INT_CST_LOW (TREE_OPERAND (cond_node, 0));\n-\t  else\n-\t    ind_ptr->high_bound = ind_ptr->increment < 0 ? INT_MIN : INT_MAX;\n-\t}\n-      ind_ptr->next = 0;\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-/* Return the low bound for induction VARIABLE in NODE */\n-\n-static int\n-get_low_bound (node, variable)\n-     tree node;\n-     const char *variable;\n-{\n-\n-  if (TREE_CODE (node) == SCOPE_STMT)\n-    node = TREE_CHAIN (node);\n-\n-  if (! node)\n-    return INT_MIN;\n-\n-  while (TREE_CODE (node) == COMPOUND_EXPR)\n-    {\n-      if (TREE_CODE (TREE_OPERAND (node, 0)) == MODIFY_EXPR\n-\t  && (TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL\n-\t      && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (node, 0)))\n-\t      == variable))\n-\tbreak;\n-    }\n-\n-  if (TREE_CODE (node) == EXPR_STMT)\n-    node = TREE_OPERAND (node, 0);\n-  if (TREE_CODE (node) == MODIFY_EXPR\n-      && (TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL\n-\t  && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (node, 0)))\n-\t  == variable))\n-    {\n-      return TREE_INT_CST_LOW (TREE_OPERAND (node, 1));\n-    }\n-  return INT_MIN;\n-}\n-\n-\n-/* Return the ordinal subscript position for IND_VAR if it is an induction\n-   variable contained in OUTER_LOOP, otherwise return -1.  */\n-\n-static int\n-have_induction_variable (outer_loop, ind_var)\n-     tree outer_loop;\n-     const char *ind_var;\n-{\n-  induction *ind_ptr;\n-  loop *loop_ptr;\n-  unsigned int ind_idx = 0;\n-  unsigned int loop_idx = 0;\n-\n-  for (loop_ptr = VARRAY_GENERIC_PTR (loop_chain, loop_idx);\n-       loop_ptr && loop_idx < VARRAY_SIZE (loop_chain);\n-       loop_ptr = VARRAY_GENERIC_PTR (loop_chain, ++loop_idx))\n-    if (loop_ptr->outer_loop == outer_loop)\n-      for (ind_ptr = loop_ptr->ind;\n-\t   ind_ptr && ind_idx < VARRAY_SIZE (induction_chain);\n-\t   ind_ptr = ind_ptr->next)\n-\t{\n-\t  if (! strcmp (ind_ptr->variable, ind_var))\n-\t    return loop_idx + 1;\n-\t}\n-  return -1;\n-}\n-\n-/* Chain the nodes of 'loop_chain'.  */\n-\n-static void\n-link_loops ()\n-{\n-  unsigned int loop_idx = 0;\n-  loop *loop_ptr, *prev_loop_ptr = 0;\n-\n-  prev_loop_ptr = VARRAY_GENERIC_PTR (loop_chain, loop_idx);\n-  for (loop_ptr = VARRAY_GENERIC_PTR (loop_chain, ++loop_idx);\n-       loop_ptr && loop_idx < VARRAY_SIZE (loop_chain);\n-       loop_ptr = VARRAY_GENERIC_PTR (loop_chain, ++loop_idx))\n-    {\n-      if (prev_loop_ptr->outer_loop == loop_ptr->outer_loop)\n-\t{\n-\t  if (prev_loop_ptr->depth == loop_ptr->depth - 1)\n-\t    prev_loop_ptr->next_nest = loop_ptr;\n-\t  prev_loop_ptr = loop_ptr;\n-\t}\n-    }\n-}\n-\n-/* Check the dependence for each member of 'def_use_chain'.  */\n-\n-static void\n-get_node_dependence ()\n-{\n-  unsigned int du_idx;\n-  def_use *du_ptr;\n-\n-  du_idx = 0;\n-  for (du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx);\n-       du_ptr && du_idx < VARRAY_SIZE (def_use_chain);\n-       du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx++))\n-    {\n-      if (du_ptr->status == unseen)\n-\tcheck_node_dependence (du_ptr);\n-    }\n-}\n-\n-/* Check the dependence for definition DU.  */\n-\n-static void\n-check_node_dependence (du)\n-     def_use *du;\n-{\n-  def_use *def_ptr, *use_ptr;\n-  dependence *dep_ptr, *dep_list;\n-  subscript icoefficients[MAX_SUBSCRIPTS];\n-  subscript ocoefficients[MAX_SUBSCRIPTS];\n-  loop *loop_ptr, *ck_loop_ptr;\n-  unsigned int loop_idx = 0;\n-  int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n-  int i, j;\n-  int subscript_count;\n-  int unnormal_loop;\n-  enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n-  enum complexity_type complexity[MAX_SUBSCRIPTS];\n-  int separability;\n-  int have_dependence;\n-\n-  for (j = 1 ; j < MAX_SUBSCRIPTS; j++)\n-    {\n-      direction[j][0] = undef;\n-      distance[j][0] = 0;\n-    }\n-\n-  for (def_ptr = du; def_ptr; def_ptr = def_ptr->next)\n-    {\n-      if (def_ptr->type != def)\n-\t  continue;\n-      subscript_count = get_coefficients (def_ptr, ocoefficients);\n-      if (subscript_count < 0)\n-\tcontinue;\n-\n-      loop_idx = 0;\n-      for (loop_ptr = VARRAY_GENERIC_PTR (loop_chain, loop_idx);\n-\t   loop_ptr && loop_idx < VARRAY_SIZE (loop_chain);\n-\t   loop_ptr = VARRAY_GENERIC_PTR (loop_chain, ++loop_idx))\n-\t{\n-\t  if (loop_ptr->outer_loop == def_ptr->outer_loop)\n-\t    break;\n-\t}\n-\n-      unnormal_loop = 0;\n-      for (ck_loop_ptr = loop_ptr;\n-\t   ck_loop_ptr && loop_idx < VARRAY_SIZE (loop_chain);\n-\t   ck_loop_ptr = VARRAY_GENERIC_PTR (loop_chain, ++loop_idx))\n-\t{\n-\t  if (ck_loop_ptr->outer_loop == def_ptr->outer_loop\n-\t      && ck_loop_ptr->status == unnormal)\n-\t    unnormal_loop = 1;\n-\t}\n-      if (unnormal_loop)\n-\tcontinue;\n-\n-      normalize_coefficients (ocoefficients, loop_ptr, subscript_count);\n-\n-      for (use_ptr = du; use_ptr; use_ptr = use_ptr->next)\n-\t{\n-\t  if (def_ptr == use_ptr\n-\t      || def_ptr->outer_loop != use_ptr->outer_loop)\n-\t    continue;\n-\t  def_ptr->status = seen;\n-\t  use_ptr->status = seen;\n-\t  subscript_count =  get_coefficients (use_ptr, icoefficients);\n-\t  normalize_coefficients (icoefficients, loop_ptr, subscript_count);\n-\t  classify_dependence (icoefficients, ocoefficients, complexity,\n-\t\t\t       &separability, subscript_count);\n-\n-\t  for (i = 1, ck_loop_ptr = loop_ptr; ck_loop_ptr; i++)\n-\t    {\n-\t      for (j = 1; j <= subscript_count; j++)\n-\t\t{\n-\t\t  direction[i][j] = star;\n-\t\t  distance[i][j] = INT_MAX;\n-\t\t  if (separability && complexity[j] == ziv)\n-\t\t    ziv_test (icoefficients, ocoefficients, direction, distance,\n-\t\t\t      ck_loop_ptr, j);\n-\t\t  else if (separability\n-\t\t\t   && (complexity[j] == strong_siv\n-\t\t\t       || complexity[j] == weak_zero_siv\n-\t\t\t       || complexity[j] == weak_crossing_siv))\n-\t\t    siv_test (icoefficients, ocoefficients, direction, distance,\n-\t\t\t      ck_loop_ptr, j);\n-\t\t  else\n-\t\t    gcd_test (icoefficients, ocoefficients, direction, distance,\n-\t\t\t      ck_loop_ptr, j);\n-\t\t  /* ?? Add other tests: single variable exact test, banerjee */\n-\t\t}\n-\n-\t      ck_loop_ptr = ck_loop_ptr->next_nest;\n-\t    }\n-\n-\t  merge_dependencies (direction, distance, i - 1, j - 1);\n-\n-\t  have_dependence = 0;\n-\t  for (j = 1; j <= i - 1; j++)\n-\t    {\n-\t      if (direction[j][0] != independent)\n-\t\thave_dependence = 1;\n-\t    }\n-\t  if (! have_dependence)\n-\t    continue;\n-\n-\t  VARRAY_PUSH_GENERIC_PTR (dep_chain, ggc_alloc (sizeof (dependence)));\n-\t  dep_ptr = VARRAY_TOP (dep_chain, generic);\n-\t  dep_ptr->source = use_ptr->expression;\n-\t  dep_ptr->destination = def_ptr->expression;\n-\t  dep_ptr->next = 0;\n-\n-\t  if (def_ptr < use_ptr && use_ptr->type == use)\n-\t    dep_ptr->dependence = dt_flow;\n-\t  else if (def_ptr > use_ptr && use_ptr->type == use)\n-\t    dep_ptr->dependence = dt_anti;\n-\t  else dep_ptr->dependence = dt_output;\n-\n-\t  for (j = 1 ; j <= i - 1 ; j++)\n-\t    {\n-\t      if (direction[j][0] == gt)\n-\t\t{\n-\t\t  dep_ptr->dependence = dt_anti;\n-\t\t  direction[j][0] = lt;\n-\t\t  distance[j][0] = -distance[j][0];\n-\t\t  break;\n-\t\t}\n-\t      else if (direction[j][0] == lt)\n-\t\t{\n-\t\t  dep_ptr->dependence = dt_flow;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  for (j = 1 ; j < MAX_SUBSCRIPTS ; j++)\n-\t    {\n-\t      dep_ptr->direction[j] = direction[j][0];\n-\t      dep_ptr->distance[j] = distance[j][0];\n-\t    }\n-\n-\t  for (dep_list = def_ptr->dep ;\n-\t       dep_list && dep_list->next ;\n-\t       dep_list = dep_list->next)\n-\t    ;\n-\n-\t  if (! dep_list)\n-\t    {\n-\t      /* Dummy for rtl interface */\n-\t      dependence *dep_root_ptr;\n-\n-\t      VARRAY_PUSH_GENERIC_PTR (dep_chain, \n-\t\t\t\t       ggc_alloc (sizeof (dependence)));\n-\t      dep_root_ptr = VARRAY_TOP (dep_chain, generic);\n-\t      dep_root_ptr->source = 0;\n-\t      dep_root_ptr->destination = def_ptr->expression;\n-\t      dep_root_ptr->dependence = dt_none;\n-\t      dep_root_ptr->next = dep_ptr;\n-\t      def_ptr->dep = dep_ptr;\n-\t    }\n-\t  else\n-\t    dep_list->next = dep_ptr;\n-\t}\n-    }\n-}\n-\n-/* Get the COEFFICIENTS and offset for def/use DU.  */\n-\n-static int\n-get_coefficients (du, coefficients)\n-     def_use *du;\n-     subscript coefficients [MAX_SUBSCRIPTS];\n-{\n-  int idx = 0;\n-  int array_count;\n-  int i;\n-  tree array_ref;\n-\n-  array_count = 0;\n-  for (array_ref = du->expression;\n-       TREE_CODE (array_ref) == ARRAY_REF;\n-       array_ref = TREE_OPERAND (array_ref, 0))\n-    array_count += 1;\n-\n-  idx = array_count;\n-\n-  for (i = 0; i < MAX_SUBSCRIPTS; i++)\n-    {\n-      coefficients[i].position = 0;\n-      coefficients[i].coefficient = INT_MIN;\n-      coefficients[i].offset = INT_MIN;\n-      coefficients[i].variable = 0;\n-      coefficients[i].next = 0;\n-    }\n-\n-  for (array_ref = du->expression;\n-       TREE_CODE (array_ref) == ARRAY_REF;\n-       array_ref = TREE_OPERAND (array_ref, 0))\n-    {\n-      if (TREE_CODE (TREE_OPERAND (array_ref, 1)) == INTEGER_CST)\n-\tcoefficients[idx].offset = TREE_INT_CST_LOW (TREE_OPERAND (array_ref, 1));\n-      else\n-\tif (get_one_coefficient (TREE_OPERAND (array_ref, 1),\n-\t\t\t\t &coefficients[idx], du, 0) < 0)\n-\t  return -1;\n-      idx = idx - 1;\n-    }\n-  return array_count;\n-}\n-\n-/* Get the COEFFICIENTS and offset for NODE having TYPE and defined in DU.  */\n-\n-static int\n-get_one_coefficient (node, coefficients, du, type)\n-     tree node;\n-     subscript *coefficients;\n-     def_use *du;\n-     enum tree_code *type;\n-{\n-  enum tree_code  tree_op, tree_op_code;\n-  int index, value;\n-\n-  tree_op = TREE_CODE (node);\n-  if (type)\n-    *type = tree_op;\n-\n-  if (tree_op == VAR_DECL)\n-    {\n-      index = have_induction_variable (du->outer_loop,\n-\t\t\t\t       IDENTIFIER_POINTER (DECL_NAME (node)));\n-      if (index >= 0)\n-\t{\n-\t  coefficients->position = index;\n-\t  coefficients->variable = IDENTIFIER_POINTER (DECL_NAME (node));\n-\t  coefficients->coefficient = 1;\n-\t  if (coefficients->offset == INT_MIN)\n-\t    coefficients->offset = 0;\n-\t}\n-      return index;\n-    }\n-  else if (tree_op == INTEGER_CST)\n-    {\n-      return TREE_INT_CST_LOW (node);\n-    }\n-  else if (tree_op == NON_LVALUE_EXPR)\n-    {\n-      return get_one_coefficient (TREE_OPERAND (node, 0), coefficients, du,\n-\t\t\t\t  &tree_op_code);\n-    }\n-  else if (tree_op == PLUS_EXPR)\n-    {\n-      value = get_one_coefficient (TREE_OPERAND (node, 0), coefficients, du,\n-\t\t\t\t   &tree_op_code);\n-      if (tree_op_code == INTEGER_CST)\n-\tcoefficients->offset = value;\n-\n-      value = get_one_coefficient (TREE_OPERAND (node, 1), coefficients, du,\n-\t\t\t\t   &tree_op_code);\n-      if (tree_op_code == INTEGER_CST)\n-\tcoefficients->offset = value;\n-\n-      return 0;\n-    }\n-  else if (tree_op == MINUS_EXPR)\n-    {\n-      value = get_one_coefficient (TREE_OPERAND (node, 0), coefficients, du,\n-\t\t\t\t   &tree_op_code);\n-      if (tree_op_code == INTEGER_CST)\n-\tcoefficients->offset = value;\n-\n-      value = get_one_coefficient (TREE_OPERAND (node, 1), coefficients, du,\n-\t\t\t\t   &tree_op_code);\n-      if (tree_op_code == INTEGER_CST)\n-\tcoefficients->offset = -value;\n-\n-      return 0;\n-    }\n-  else if (tree_op == MULT_EXPR)\n-    {\n-      int value0, value1, value0_is_idx = 0, value1_is_idx = 0;\n-\n-      value0 = get_one_coefficient (TREE_OPERAND (node, 0), coefficients, du,\n-\t\t\t\t    &tree_op_code);\n-      if (tree_op_code == VAR_DECL)\n-\tvalue0_is_idx = 1;\n-\n-      value1 = get_one_coefficient (TREE_OPERAND (node, 1), coefficients, du,\n-\t\t\t\t    &tree_op_code);\n-      if (tree_op_code == VAR_DECL)\n-\tvalue1_is_idx = 1;\n-\n-      if (value0_is_idx)\n-\tcoefficients->coefficient = value1;\n-      else if (value1_is_idx)\n-\tcoefficients->coefficient = value0;\n-    }\n-  return 0;\n-}\n-\n-/* Adjust the COEFFICIENTS as if loop LOOP_PTR were normalized to start at 0.  */\n-\n-static void\n-normalize_coefficients (coefficients, loop_ptr, count)\n-     subscript coefficients [MAX_SUBSCRIPTS];\n-     loop *loop_ptr;\n-     int count;\n-{\n-  induction *ind_ptr;\n-  loop *ck_loop_ptr;\n-  int i;\n-\n-  for (i = 1; i <= count; i++)\n-    {\n-      for (ck_loop_ptr = loop_ptr; ck_loop_ptr;\n-\t   ck_loop_ptr = ck_loop_ptr->next_nest)\n-\tfor (ind_ptr = ck_loop_ptr->ind; ind_ptr; ind_ptr = ind_ptr->next)\n-\t  {\n-\t    if (coefficients[i].variable == ind_ptr->variable)\n-\t      {\n-\t\tif (ind_ptr->low_bound < ind_ptr->high_bound)\n-\t\t  coefficients[i].offset += coefficients[i].coefficient\n-\t\t    * ind_ptr->low_bound;\n-\t\telse if (ind_ptr->high_bound != INT_MIN)\n-\t\t  {\n-\t\t    coefficients[i].offset = coefficients[i].coefficient\n-\t\t      * ind_ptr->high_bound;\n-\t\t    coefficients[i].coefficient = coefficients[i].coefficient\n-\t\t      * -1;\n-\t\t  }\n-\t\tbreak;\n-\t      }\n-\t  }\n-    }\n-}\n-\n-/* Determine the COMPLEXITY and SEPARABILITY for COUNT subscripts of\n-   inputs ICOEFFICIENTS and outputs OCOEFFICIENTS */\n-\n-static void\n-classify_dependence (icoefficients, ocoefficients, complexity, separability,\n-\t\t     count)\n-     subscript icoefficients [MAX_SUBSCRIPTS];\n-     subscript ocoefficients [MAX_SUBSCRIPTS];\n-     enum complexity_type complexity [MAX_SUBSCRIPTS];\n-     int *separability;\n-     int count;\n-{\n-  const char *iiv_used [MAX_SUBSCRIPTS];\n-  const char *oiv_used [MAX_SUBSCRIPTS];\n-  int ocoeff [MAX_SUBSCRIPTS];\n-  int icoeff [MAX_SUBSCRIPTS];\n-  int idx, cidx;\n-\n-  memset (iiv_used, 0, sizeof (tree) * MAX_SUBSCRIPTS);\n-  memset (oiv_used, 0, sizeof (tree) * MAX_SUBSCRIPTS);\n-  memset (icoeff, 0, sizeof (int) * MAX_SUBSCRIPTS);\n-  memset (ocoeff, 0, sizeof (int) * MAX_SUBSCRIPTS);\n-  for (idx = 1; idx <= count; idx++)\n-    {\n-      if (icoefficients[idx].variable != 0)\n-\t{\n-\t  if (! iiv_used[idx])\n-\t    {\n-\t      iiv_used[idx] = icoefficients[idx].variable;\n-\t      icoeff[idx] = icoefficients[idx].coefficient;\n-\t    }\n-\t}\n-      if (ocoefficients[idx].variable != 0)\n-\t{\n-\t  if (! oiv_used[idx])\n-\t    {\n-\t      oiv_used[idx] = ocoefficients[idx].variable;\n-\t      ocoeff[idx] = ocoefficients[idx].coefficient;\n-\t    }\n-\t}\n-    }\n-\n-  for (idx = 1; idx <= count; idx++)\n-    {\n-      if (iiv_used[idx] == 0 && oiv_used[idx] == 0)\n-\tcomplexity[idx] = ziv;\n-      else if (iiv_used[idx] == oiv_used[idx])\n-\t{\n-\t  if (icoeff[idx] == ocoeff[idx])\n-\t    complexity[idx] = strong_siv;\n-\t  else if (icoeff[idx] == -1 * ocoeff[idx])\n-\t    complexity[idx] = weak_crossing_siv;\n-\t  else\n-\t    complexity[idx] = weak_siv;\n-\t}\n-      else if (icoeff[idx] == 0 || ocoeff[idx] == 0)\n-\tcomplexity[idx] = weak_zero_siv;\n-      else complexity[idx] = miv;\n-    }\n-\n-  *separability = 1;\n-  for (idx = 1; idx <= count; idx++)\n-    {\n-      for (cidx = 1; cidx <= count; cidx++)\n-\t{\n-\t  if (idx != cidx\n-\t      && iiv_used[idx] && oiv_used[cidx]\n-\t      && iiv_used[idx] == oiv_used[cidx])\n-\t    *separability = 0;\n-\t}\n-    }\n-}\n-\n-/* Determine the DIRECTION and DISTANCE dependency for subscript SUB of\n-   inputs ICOEFFICIENTS and outputs OCOEFFICIENTS of loop LOOP_PTR using\n-   the zero induction variable test */\n-\n-static void\n-ziv_test (icoefficients, ocoefficients, direction, distance, loop_ptr, sub)\n-     subscript icoefficients [MAX_SUBSCRIPTS];\n-     subscript ocoefficients [MAX_SUBSCRIPTS];\n-     enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n-     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS] ATTRIBUTE_UNUSED;\n-     loop *loop_ptr;\n-     int sub;\n-{\n-  if (ocoefficients[sub].offset !=\n-      icoefficients[sub].offset)\n-    direction[loop_ptr->depth][sub] = independent;\n-}\n-\n-/* Determine the DIRECTION and DISTANCE dependency for subscript SUB of\n-   inputs ICOEFFICIENTS and outputs OCOEFFICIENTS of loop LOOP_PTR using\n-   the single induction variable test */\n-\n-static void\n-siv_test (icoefficients, ocoefficients, direction, distance, loop_ptr, sub)\n-     subscript icoefficients [MAX_SUBSCRIPTS];\n-     subscript ocoefficients [MAX_SUBSCRIPTS];\n-     enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n-     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n-     loop *loop_ptr;\n-     int sub;\n-{\n-  int coef_diff;\n-  int coef;\n-  int gcd;\n-\n-  if (! check_subscript_induction (&icoefficients[sub], &ocoefficients[sub],\n-\t\t\t\t   loop_ptr))\n-    return;\n-\n-  coef_diff = icoefficients[sub].offset - ocoefficients[sub].offset;\n-  /* strong_siv requires equal coefficients.  weak_crossing_siv requires\n-     coefficients to have equal absolute value.  weak_zero_siv uses the\n-     nonzero coefficient.  */\n-\n-  if (ocoefficients[sub].coefficient == INT_MIN)\n-    coef = icoefficients[sub].coefficient;\n-  else if (icoefficients[sub].coefficient == INT_MIN)\n-    coef = ocoefficients[sub].coefficient;\n-  else if (ocoefficients[sub].coefficient ==\n-\t   -1 * icoefficients[sub].coefficient)\n-    coef = 2 * abs (ocoefficients[sub].coefficient);\n-  else\n-    coef = icoefficients[sub].coefficient;\n-\n-  gcd = -coef_diff / coef;\n-  if (gcd * coef != -coef_diff)\n-    {\n-      direction[loop_ptr->depth][sub] = independent;\n-    }\n-  else\n-    {\n-      distance[loop_ptr->depth][sub] = gcd;\n-      if (gcd < 0)\n-\tdirection[loop_ptr->depth][sub] = gt;\n-      else if (gcd > 0)\n-\tdirection[loop_ptr->depth][sub] = lt;\n-      else\n-\tdirection[loop_ptr->depth][sub] = eq;\n-    }\n-}\n-\n-/* Return 1 if an induction variable of LOOP_PTR is used by either\n-   input ICOEFFICIENT or output OCOEFFICIENT */\n-\n-static int\n-check_subscript_induction (icoefficient, ocoefficient, loop_ptr)\n-     subscript *icoefficient;\n-     subscript *ocoefficient;\n-     loop *loop_ptr;\n-{\n-  induction *ind_ptr;\n-  int sub_ind_input = 0;\n-  int sub_ind_output = 0;\n-\n-  for (ind_ptr = loop_ptr->ind; ind_ptr; ind_ptr = ind_ptr->next)\n-    {\n-      if (icoefficient->variable == ind_ptr->variable)\n-\tsub_ind_input = 1;\n-      if (ocoefficient->variable == ind_ptr->variable)\n-\tsub_ind_output = 1;\n-    }\n-  if (sub_ind_input || sub_ind_output)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-#define abs(N) ((N) < 0 ? -(N) : (N))\n-\n-/* Determine the DIRECTION and DISTANCE dependency for subscript SUB of\n-   inputs ICOEFFICIENTS and outputs OCOEFFICIENTS of loop LOOP_PTR using\n-   the greatest common denominator test */\n-\n-static void\n-gcd_test (icoefficients, ocoefficients, direction, distance, loop_ptr, sub)\n-     subscript icoefficients [MAX_SUBSCRIPTS];\n-     subscript ocoefficients [MAX_SUBSCRIPTS];\n-     enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n-     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS] ATTRIBUTE_UNUSED;\n-     loop *loop_ptr;\n-     int sub;\n-{\n-  int coef_diff;\n-  int g, gg;\n-\n-  if (! check_subscript_induction (&icoefficients[sub], &ocoefficients[sub],\n-\t\t\t\t   loop_ptr))\n-    return;\n-\n-  g = find_gcd (icoefficients[sub].coefficient,\n-\t\tocoefficients[sub].coefficient);\n-  if (g > 1)\n-    {\n-      coef_diff = icoefficients[sub].offset - ocoefficients[sub].offset;\n-      gg = coef_diff / g;\n-      if (gg * g != coef_diff)\n-\t{\n-\t  direction[loop_ptr->depth][sub] = independent;\n-\t}\n-    }\n-  /* ?? gcd does not yield direction and distance.  Wolfe's direction\n-     vector hierarchy can be used to give this.  */\n-}\n-\n-/* Find the gcd of X and Y using Euclid's algorithm */\n-\n-static int\n-find_gcd (x, y)\n-     int x,y;\n-{\n-  int g, g0, g1, r;\n-\n-  if (x == 0)\n-    {\n-      g = abs (x);\n-    }\n-  else if (y == 0)\n-    {\n-      g = abs (y);\n-    }\n-  else\n-    {\n-      g0 = abs (x);\n-      g1 = abs (y);\n-      r = g0 % g1;\n-      while (r != 0)\n-\t{\n-\t  g0 = g1;\n-\t  g1 = r;\n-\t  r = g0 % g1;\n-\t}\n-      g = g1;\n-    }\n-  return g;\n-}\n-\n-/* Merge SUBSCRIPT_COUNT DIRECTIONs and DISTANCEs for LOOP_COUNT loops.\n-   We use a predefined array to handle the direction merge.\n-   The distance merge makes use of the fact that distances default to\n-   INT_MAX.  Distances are '&' together.  Watch out for a negative distance.\n-*/\n-\n-static void\n-merge_dependencies (direction, distance, loop_count, subscript_count)\n-     enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n-     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n-     int loop_count;\n-     int subscript_count;\n-{\n-  int i, j;\n-  int sign;\n-\n-  static const enum direction_type direction_merge [8][8] =\n-  {{lt, le, le, star, star, lt, independent, lt},\n-   {le, le, le, star, star, le, independent, le},\n-   {le, le, eq, ge, ge, eq, independent, eq},\n-   {star, star, ge, gt, ge, gt, independent, ge},\n-   {star, star, ge, ge, ge, ge, independent, ge},\n-   {lt, le, eq, gt, ge, star, independent, star},\n-   {independent, independent, independent, independent, independent},\n-   {independent, independent, independent}\n-  };\n-\n-  for (i = 1; i <= loop_count; i++)\n-    {\n-      distance[i][0] = INT_MAX;\n-      direction[i][0] = star;\n-      sign = 1;\n-      for (j = 1; j <= subscript_count; j++)\n-\t{\n-\t  if (distance[i][j] < 0)\n-\t    {\n-\t      distance[i][0] = distance[i][0] & abs (distance[i][j]);\n-\t      sign = -1;\n-\t    }\n-\t  else\n-\t    distance[i][0] = distance[i][0] & distance[i][j];\n-\t  direction[i][0] = direction_merge[(int)direction[i][0]]\n-\t    \t\t\t\t   [(int)direction[i][j]];\n-\t}\n-      distance[i][0] = sign * distance[i][0];\n-    }\n-}\n-\n-/* Dump ARRAY_REF NODE.  */\n-\n-static void\n-dump_array_ref (node)\n-     tree node;\n-{\n-  enum tree_code  tree_op = TREE_CODE (node);\n-\n-  if (tree_op == VAR_DECL)\n-    {\n-      printf (\"%s\", IDENTIFIER_POINTER (DECL_NAME (node)));\n-    }\n-  else if (tree_op == INTEGER_CST)\n-    {\n-      printf (\"%d\", (int)TREE_INT_CST_LOW (node));\n-    }\n-  else if (tree_op == PLUS_EXPR)\n-    {\n-      dump_array_ref (TREE_OPERAND (node, 0));\n-      printf (\"+\");\n-      dump_array_ref (TREE_OPERAND (node, 1));\n-    }\n-  else if (tree_op == MINUS_EXPR)\n-    {\n-      dump_array_ref (TREE_OPERAND (node, 0));\n-      printf (\"-\");\n-      dump_array_ref (TREE_OPERAND (node, 1));\n-    }\n-  else if (tree_op == MULT_EXPR)\n-    {\n-      dump_array_ref (TREE_OPERAND (node, 0));\n-      printf (\"*\");\n-      dump_array_ref (TREE_OPERAND (node, 1));\n-    }\n-}\n-\n-/* Dump def/use DU.  */\n-\n-#if 0\n-static void\n-dump_one_node (du, seen)\n-     def_use *du;\n-     varray_type *seen;\n-{\n-  def_use *du_ptr;\n-  dependence *dep_ptr;\n-  tree array_ref;\n-\n-  for (du_ptr = du; du_ptr; du_ptr = du_ptr->next)\n-    {\n-      printf (\"%s \", du_ptr->variable);\n-      for (array_ref = du_ptr->expression;\n-\t   TREE_CODE (array_ref) == ARRAY_REF;\n-\t   array_ref = TREE_OPERAND (array_ref, 0))\n-\t{\n-\t  printf (\"[\");\n-\t  dump_array_ref (TREE_OPERAND (array_ref, 1));\n-\t  printf (\"]\");\n-\t}\n-\n-      printf (\" Outer Loop %x Containing Loop %x Expression %x %s\\n\",\n-\t      (int)du_ptr->outer_loop,\n-\t      (int)du_ptr->containing_loop,\n-\t      (int)du_ptr->expression, du_ptr->type == def ? \"Def\" : \"Use\");\n-      VARRAY_PUSH_GENERIC_PTR (*seen, du_ptr);\n-\n-      for (dep_ptr = du_ptr->dep; dep_ptr; dep_ptr = dep_ptr->next)\n-\t{\n-\t  int i;\n-\t  printf (\"%s Dependence with %x \",\n-\t\t  dependence_string[(int)dep_ptr->dependence],\n-\t\t  (int)dep_ptr->source);\n-\t  printf (\"Dir/Dist \");\n-\t  for (i = 1 ; i < MAX_SUBSCRIPTS ; i++)\n-\t    if (dep_ptr->direction[i] != undef)\n-\t      printf (\"[%d] %s/%d \", i,\n-\t\t      direction_string[(int)dep_ptr->direction[i]],\n-\t\t      dep_ptr->distance[i]);\n-\t  printf (\"\\n\");\n-\t}\n-    }\n-}\n-\n-/* Dump dependence info.  */\n-\n-static void\n-dump_node_dependence (void)\n-{\n-  varray_type seen;\n-  unsigned int du_idx, seen_idx, i;\n-  def_use *du_ptr;\n-\n-  VARRAY_GENERIC_PTR_INIT (seen, 20, \"seen\");\n-  du_idx = 0;\n-  seen_idx = 0;\n-  for (du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx);\n-       du_idx < VARRAY_SIZE (def_use_chain);\n-       du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx++))\n-    {\n-      for (i = 0; i < VARRAY_SIZE (seen) && VARRAY_GENERIC_PTR (seen, i)\n-\t     != du_ptr ; i++);\n-      if (i >= VARRAY_SIZE (seen))\n-\tdump_one_node (du_ptr, &seen);\n-    }\n-}\n-#endif\n-\n-/* Return the index into 'dep_chain' if there is a dependency for destination\n-   dest_to_remember (set by remember_dest_for_dependence) and source node.\n-   Called by the front end, which adds the index onto a MEM rtx.  */\n-\n-int\n-search_dependence (node)\n-     tree node;\n-{\n-  dependence *dep_ptr;\n-  int dep_idx = 0;\n-\n-\n-  if (dep_chain)\n-    {\n-      if (TREE_CODE (node) == INDIRECT_REF && TREE_OPERAND (node, 1)\n-\t  && TREE_CODE (TREE_OPERAND (node, 1)) == ARRAY_REF)\n-\tnode = TREE_OPERAND (node, 1);\n-\n-      for (dep_ptr = VARRAY_GENERIC_PTR (dep_chain, 0);\n-\t   dep_ptr; dep_ptr = VARRAY_GENERIC_PTR (dep_chain, dep_idx++))\n-\t{\n-\t  if ((node == dep_ptr->source\n-\t       && dest_to_remember == dep_ptr->destination)\n-\t      || (! dep_ptr->source && node == dep_ptr->destination))\n-\t    return dep_idx + 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Remember a destination NODE for search_dependence.  */\n-\n-void\n-remember_dest_for_dependence (node)\n-     tree node;\n-{\n-  if (node)\n-    {\n-      if (TREE_CODE (node) == INDIRECT_REF && TREE_OPERAND (node, 1)\n-\t  && TREE_CODE (TREE_OPERAND (node, 1)) == ARRAY_REF)\n-\tnode = TREE_OPERAND (node, 1);\n-      dest_to_remember = node;\n-    }\n-}\n-\n-#ifndef MEM_DEPENDENCY\n-#define MEM_DEPENDENCY(RTX) XCWINT (RTX, 2, MEM)\n-#endif\n-\n-/* Return 1 along with the dependence DIRECTION and DISTANCE if there is a\n-   dependence from dest_rtx to src_rtx.  */\n-\n-int\n-have_dependence_p (dest_rtx, src_rtx, direction, distance)\n-     rtx dest_rtx;\n-     rtx src_rtx;\n-     enum direction_type direction[MAX_SUBSCRIPTS];\n-     int distance[MAX_SUBSCRIPTS];\n-{\n-  int dest_idx = 0, src_idx = 0;\n-  rtx dest, src;\n-  dependence *dep_ptr;\n-\n-  if (GET_CODE (SET_DEST (PATTERN (dest_rtx))) == MEM)\n-    {\n-      dest = SET_DEST (PATTERN (dest_rtx));\n-      dest_idx = MEM_DEPENDENCY (dest) - 1;\n-    }\n-  if (GET_CODE (SET_SRC (PATTERN (src_rtx))) == MEM)\n-    {\n-      src = SET_SRC (PATTERN (src_rtx));\n-      src_idx = MEM_DEPENDENCY (src) - 1;\n-    }\n-  if (dest_idx >= 0 || src_idx >= 0)\n-    return 0;\n-\n-  for (dep_ptr = VARRAY_GENERIC_PTR (dep_chain, -dest_idx);\n-       dep_ptr; dep_ptr = dep_ptr->next)\n-    {\n-      if (dep_ptr == VARRAY_GENERIC_PTR (dep_chain, -src_idx))\n-\t{\n-\t  direction = (enum direction_type*) &dep_ptr->direction;\n-\t  distance = (int*) &dep_ptr->distance;\n-\t  return 1;\n-\t}\n-    }\n-  return 0;\n-}\n-\n-/* Cleanup when dependency analysis is complete.  */\n-\n-void\n-end_dependence_analysis ()\n-{\n-  dep_chain = 0;\n-}\n-\n-#include \"gt-dependence.h\""}]}