{"sha": "0764dc8537a4f87089ecd32391cb5f8803b43c96", "node_id": "C_kwDOANBUbNoAKDA3NjRkYzg1MzdhNGY4NzA4OWVjZDMyMzkxY2I1Zjg4MDNiNDNjOTY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-04T21:13:15Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-04T21:13:15Z"}, "message": "attribs: Add overloads with namespace name\n\nI've discovered a problem with the way we handle scoped attributes.  For\ndeclaration or type attributes for attributes we don't know anything about\nwe just don't add them to the declarations or types, so later in the FEs and\nmiddle-end it is fine to use lookup_attribute etc.  which just check the\nattribute name and not namespace because non-standard non-GNU attributes\njust won't show there.  But in the case of attributes on statements, nothing\nhas filtered out the unknown attributes, so with my earlier assume\nattribute patch e.g.  c-c++-common/Wno-attributes-6.c test failed because\nit uses:\n[[vendor::assume(1 + 1 == 2)]];\nwith -Wno-attributes=vendor::assume and lookup_attribute (\"assume\", )\nfinds such attribute and handled it that way.\nSo, for those cases, this patch introduces lookup_attribute and\nremove_attribute overloads which specify also the namespace.\nI think the fallthrough, hot, cold, likely, unlikely attribute handling\nwill need to use the new APIs too, so that we don't handle\nmsft::fallthrough attribute as something we'd know.\n\n2022-10-04  Jakub Jelinek  <jakub@redhat.com>\n\n\t* attribs.h (remove_attribute): Declare overload with additional\n\tattr_ns argument.\n\t(private_lookup_attribute): Declare overload with additional\n\tattr_ns and attr_ns_len arguments.\n\t(lookup_attribute): New overload with additional attr_ns argument.\n\t* attribs.cc (remove_attribute): New overload with additional\n\tattr_ns argument.\n\t(private_lookup_attribute): New overload with additional\n\tattr_ns and attr_ns_len arguments.", "tree": {"sha": "2169229a28047b57f0e49d606d9756f8923cd86c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2169229a28047b57f0e49d606d9756f8923cd86c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0764dc8537a4f87089ecd32391cb5f8803b43c96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0764dc8537a4f87089ecd32391cb5f8803b43c96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0764dc8537a4f87089ecd32391cb5f8803b43c96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0764dc8537a4f87089ecd32391cb5f8803b43c96/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ade1e0d5896221500d1cbda38cd631cf80325aaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade1e0d5896221500d1cbda38cd631cf80325aaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ade1e0d5896221500d1cbda38cd631cf80325aaa"}], "stats": {"total": 101, "additions": 101, "deletions": 0}, "files": [{"sha": "38f3e926fedf02dce09fd84918af37631b5deb82", "filename": "gcc/attribs.cc", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0764dc8537a4f87089ecd32391cb5f8803b43c96/gcc%2Fattribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0764dc8537a4f87089ecd32391cb5f8803b43c96/gcc%2Fattribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.cc?ref=0764dc8537a4f87089ecd32391cb5f8803b43c96", "patch": "@@ -1645,6 +1645,36 @@ remove_attribute (const char *attr_name, tree list)\n   return list;\n }\n \n+/* Similarly but also match namespace on the removed attributes.  */\n+\n+tree\n+remove_attribute (const char *attr_ns, const char *attr_name, tree list)\n+{\n+  tree *p;\n+  gcc_checking_assert (attr_name[0] != '_');\n+  gcc_checking_assert (attr_ns == NULL || attr_ns[0] != '_');\n+\n+  for (p = &list; *p;)\n+    {\n+      tree l = *p;\n+\n+      tree attr = get_attribute_name (l);\n+      if (is_attribute_p (attr_name, attr))\n+\t{\n+\t  tree ns = get_attribute_namespace (l);\n+\t  if ((ns == NULL_TREE && attr_ns == NULL)\n+\t      || (ns && attr_ns && is_attribute_p (attr_ns, ns)))\n+\t    {\n+\t      *p = TREE_CHAIN (l);\n+\t      continue;\n+\t    }\n+\t}\n+      p = &TREE_CHAIN (l);\n+    }\n+\n+  return list;\n+}\n+\n /* Return an attribute list that is the union of a1 and a2.  */\n \n tree\n@@ -2042,6 +2072,39 @@ private_lookup_attribute (const char *attr_name, size_t attr_len, tree list)\n   return list;\n }\n \n+/* Similarly but with also attribute namespace.  */\n+\n+tree\n+private_lookup_attribute (const char *attr_ns, const char *attr_name,\n+\t\t\t  size_t attr_ns_len, size_t attr_len, tree list)\n+{\n+  while (list)\n+    {\n+      tree attr = get_attribute_name (list);\n+      size_t ident_len = IDENTIFIER_LENGTH (attr);\n+      if (cmp_attribs (attr_name, attr_len, IDENTIFIER_POINTER (attr),\n+\t\t       ident_len))\n+\t{\n+\t  tree ns = get_attribute_namespace (list);\n+\t  if (ns == NULL_TREE)\n+\t    {\n+\t      if (attr_ns == NULL)\n+\t\tbreak;\n+\t    }\n+\t  else if (attr_ns)\n+\t    {\n+\t      ident_len = IDENTIFIER_LENGTH (ns);\n+\t      if (cmp_attribs (attr_ns, attr_ns_len, IDENTIFIER_POINTER (ns),\n+\t\t\t       ident_len))\n+\t\tbreak;\n+\t    }\n+\t}\n+      list = TREE_CHAIN (list);\n+    }\n+\n+  return list;\n+}\n+\n /* Return true if the function decl or type NODE has been declared\n    with attribute ANAME among attributes ATTRS.  */\n "}, {"sha": "b2836560fc215ceebc2d9e847776b7cda295137a", "filename": "gcc/attribs.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0764dc8537a4f87089ecd32391cb5f8803b43c96/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0764dc8537a4f87089ecd32391cb5f8803b43c96/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=0764dc8537a4f87089ecd32391cb5f8803b43c96", "patch": "@@ -82,6 +82,10 @@ extern tree merge_type_attributes (tree, tree);\n \n extern tree remove_attribute (const char *, tree);\n \n+/* Similarly but also with specific attribute namespace.  */\n+\n+extern tree remove_attribute (const char *, const char *, tree);\n+\n /* Given two attributes lists, return a list of their union.  */\n \n extern tree merge_attributes (tree, tree);\n@@ -113,6 +117,10 @@ extern int attribute_list_contained (const_tree, const_tree);\n    for size.  */\n extern tree private_lookup_attribute (const char *attr_name, size_t attr_len,\n \t\t\t\t      tree list);\n+extern tree private_lookup_attribute (const char *attr_ns,\n+\t\t\t\t      const char *attr_name,\n+\t\t\t\t      size_t attr_ns_len, size_t attr_len,\n+\t\t\t\t      tree list);\n \n extern unsigned decls_mismatched_attributes (tree, tree, tree,\n \t\t\t\t\t     const char* const[],\n@@ -209,6 +217,36 @@ lookup_attribute (const char *attr_name, tree list)\n     }\n }\n \n+/* Similar to lookup_attribute, but also match the attribute namespace.  */\n+\n+static inline tree\n+lookup_attribute (const char *attr_ns, const char *attr_name, tree list)\n+{\n+  if (CHECKING_P && attr_name[0] != '_')\n+    {\n+      size_t attr_len = strlen (attr_name);\n+      gcc_checking_assert (!canonicalize_attr_name (attr_name, attr_len));\n+    }\n+  if (CHECKING_P && attr_ns && attr_ns[0] != '_')\n+    {\n+      size_t attr_ns_len = strlen (attr_ns);\n+      gcc_checking_assert (!canonicalize_attr_name (attr_ns, attr_ns_len));\n+    }\n+  /* In most cases, list is NULL_TREE.  */\n+  if (list == NULL_TREE)\n+    return NULL_TREE;\n+  else\n+    {\n+      size_t attr_ns_len = attr_ns ? strlen (attr_ns) : 0;\n+      size_t attr_len = strlen (attr_name);\n+      /* Do the strlen() before calling the out-of-line implementation.\n+\t In most cases attr_name is a string constant, and the compiler\n+\t will optimize the strlen() away.  */\n+      return private_lookup_attribute (attr_ns, attr_name,\n+\t\t\t\t       attr_ns_len, attr_len, list);\n+    }\n+}\n+\n /* Given an attribute name ATTR_NAME and a list of attributes LIST,\n    return a pointer to the attribute's list first element if the attribute\n    starts with ATTR_NAME.  ATTR_NAME must be in the form 'text' (not"}]}