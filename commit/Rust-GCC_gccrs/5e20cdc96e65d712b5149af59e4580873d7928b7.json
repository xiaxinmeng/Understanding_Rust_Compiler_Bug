{"sha": "5e20cdc96e65d712b5149af59e4580873d7928b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUyMGNkYzk2ZTY1ZDcxMmI1MTQ5YWY1OWU0NTgwODczZDc5MjhiNw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-10-31T21:26:14Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-10-31T21:26:14Z"}, "message": "Automated part of renaming of symtab_node_base to symtab_node.\n\ngcc/\n\n\tPatch autogenerated by rename_symtab.py from\n\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n\twith ChangeLog entry fixed up by hand.\n\n\t* cgraph.c (x_cgraph_nodes_queue): Rename symtab_node_base to\n\tsymtab_node.\n\t(cgraph_node_for_asm): Likewise.\n\t* cgraph.h (symtab_node_base): Likewise.\n\t(cgraph_node): Likewise.\n\t(varpool_node): Likewise.\n\t(is_a_helper <cgraph_node>::test): Likewise.\n\t(is_a_helper <varpool_node>::test): Likewise.\n\t(symtab_nodes): Likewise.\n\t(symtab_register_node): Likewise.\n\t(symtab_unregister_node): Likewise.\n\t(symtab_remove_node): Likewise.\n\t(symtab_get_node): Likewise.\n\t(symtab_node_for_asm): Likewise.\n\t(symtab_node_asm_name): Likewise.\n\t(symtab_node_name): Likewise.\n\t(symtab_insert_node_to_hashtable): Likewise.\n\t(symtab_add_to_same_comdat_group): Likewise.\n\t(symtab_dissolve_same_comdat_group_list): Likewise.\n\t(dump_symtab_node): Likewise.\n\t(debug_symtab_node): Likewise.\n\t(dump_symtab_base): Likewise.\n\t(verify_symtab_node): Likewise.\n\t(verify_symtab_base): Likewise.\n\t(symtab_used_from_object_file_p): Likewise.\n\t(symtab_alias_ultimate_target): Likewise.\n\t(symtab_resolve_alias): Likewise.\n\t(fixup_same_cpp_alias_visibility): Likewise.\n\t(symtab_for_node_and_aliases): Likewise.\n\t(symtab_nonoverwritable_alias): Likewise.\n\t(availability symtab_node_availability): Likewise.\n\t(symtab_semantically_equivalent_p): Likewise.\n\t(fixup_same_cpp_alias_visibility): Likewise.\n\t(symtab_prevail_in_asm_name_hash): Likewise.\n\t(cgraph): Likewise.\n\t(varpool): Likewise.\n\t(varpool_first_variable): Likewise.\n\t(varpool_next_variable): Likewise.\n\t(varpool_first_static_initializer): Likewise.\n\t(varpool_next_static_initializer): Likewise.\n\t(varpool_first_defined_variable): Likewise.\n\t(varpool_next_defined_variable): Likewise.\n\t(cgraph_first_defined_function): Likewise.\n\t(cgraph_next_defined_function): Likewise.\n\t(cgraph_first_function): Likewise.\n\t(cgraph_next_function): Likewise.\n\t(cgraph_first_function_with_gimple_body): Likewise.\n\t(cgraph_next_function_with_gimple_body): Likewise.\n\t(symtab_alias_target): Likewise.\n\t(symtab_real_symbol_p): Likewise.\n\t(symtab_can_be_discarded): Likewise.\n\t* cgraphbuild.c (mark_address): Likewise.\n\t(mark_load): Likewise.\n\t(mark_store): Likewise.\n\t* cgraphunit.c (decide_is_symbol_needed): Likewise.\n\t(first): Likewise.\n\t(enqueue_node): Likewise.\n\t(referred_to_p): Likewise.\n\t(cgraph_process_same_body_aliases): Likewise.\n\t(analyze_functions): Likewise.\n\t(handle_alias_pairs): Likewise.\n\t(output_weakrefs): Likewise.\n\t(compile): Likewise.\n\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Likewise.\n\t* ipa-inline-analysis.c (inline_write_summary): Likewise.\n\t* ipa-prop.c (remove_described_reference): Likewise.\n\t(try_decrement_rdesc_refcount): Likewise.\n\t(ipa_edge_duplication_hook): Likewise.\n\t* ipa-ref.c (ipa_record_reference): Likewise.\n\t(ipa_maybe_record_reference): Likewise.\n\t(ipa_clone_ref): Likewise.\n\t(ipa_clone_references): Likewise.\n\t(ipa_clone_referring): Likewise.\n\t(ipa_find_reference): Likewise.\n\t(ipa_remove_stmt_references): Likewise.\n\t(ipa_clear_stmts_in_references): Likewise.\n\t* ipa-ref.h (symtab_node_base): Likewise.\n\t(ipa_ref): Likewise.\n\t(ipa_record_reference): Likewise.\n\t(ipa_maybe_record_reference): Likewise.\n\t(ipa_clone_references): Likewise.\n\t(ipa_clone_referring): Likewise.\n\t(ipa_clone_ref): Likewise.\n\t(ipa_find_reference): Likewise.\n\t(ipa_remove_stmt_references): Likewise.\n\t(ipa_clear_stmts_in_references): Likewise.\n\t* ipa-reference.c (ipa_reference_write_optimization_summary):\n\tLikewise.\n\t* ipa.c (enqueue_node): Likewise.\n\t(process_references): Likewise.\n\t(walk_polymorphic_call_targets): Likewise.\n\t(symtab_remove_unreachable_nodes): Likewise.\n\t(address_taken_from_non_vtable_p): Likewise.\n\t(comdat_can_be_unshared_p_1): Likewise.\n\t(comdat_can_be_unshared_p): Likewise.\n\t(can_replace_by_local_alias): Likewise.\n\t(function_and_variable_visibility): Likewise.\n\t* is-a.h: Likewise (within example in comment).\n\t* lto-cgraph.c (input_cgraph_opt_summary): Likewise.\n\t(lto_symtab_encoder_encode): Likewise.\n\t(lto_symtab_encoder_delete_node): Likewise.\n\t(lto_symtab_encoder_in_partition_p): Likewise.\n\t(lto_set_symtab_encoder_in_partition): Likewise.\n\t(output_refs): Likewise.\n\t(compute_ltrans_boundary): Likewise.\n\t(output_symtab): Likewise.\n\t(input_node): Likewise.\n\t(input_ref): Likewise.\n\t(input_edge): Likewise.\n\t(input_cgraph_1): Likewise.\n\t(input_refs): Likewise.\n\t(output_cgraph_opt_summary): Likewise.\n\t(input_node_opt_summary): Likewise.\n\t(input_cgraph_opt_section): Likewise.\n\t* lto-section-in.c (lto_free_function_in_decl_state_for_node):\n\tLikewise.\n\t* lto-streamer-out.c (lto_output): Likewise.\n\t(output_symbol_p): Likewise.\n\t(produce_symtab): Likewise.\n\t* lto-streamer.h (lto_encoder_entry): Likewise.\n\t(lto_free_function_in_decl_state_for_node): Likewise.\n\t(lto_symtab_encoder_encode): Likewise.\n\t(lto_symtab_encoder_delete_node): Likewise.\n\t(lto_symtab_encoder_in_partition_p): Likewise.\n\t(lto_set_symtab_encoder_in_partition): Likewise.\n\t(lto_symtab_encoder_lookup): Likewise.\n\t(lsei_node): Likewise.\n\t(lto_symtab_encoder_deref): Likewise.\n\t* symtab.c (symtab_hash): Likewise.\n\t(assembler_name_hash): Likewise.\n\t(symtab_nodes): Likewise.\n\t(hash_node): Likewise.\n\t(eq_node): Likewise.\n\t(hash_node_by_assembler_name): Likewise.\n\t(eq_assembler_name): Likewise.\n\t(insert_to_assembler_name_hash): Likewise.\n\t(unlink_from_assembler_name_hash): Likewise.\n\t(symtab_prevail_in_asm_name_hash): Likewise.\n\t(symtab_register_node): Likewise.\n\t(symtab_insert_node_to_hashtable): Likewise.\n\t(symtab_unregister_node): Likewise.\n\t(symtab_get_node): Likewise.\n\t(symtab_remove_node): Likewise.\n\t(symtab_initialize_asm_name_hash): Likewise.\n\t(symtab_node_for_asm): Likewise.\n\t(symtab_add_to_same_comdat_group): Likewise.\n\t(symtab_dissolve_same_comdat_group_list): Likewise.\n\t(symtab_node_asm_name): Likewise.\n\t(symtab_node_name): Likewise.\n\t(dump_symtab_base): Likewise.\n\t(dump_symtab_node): Likewise.\n\t(dump_symtab): Likewise.\n\t(debug_symtab_node): Likewise.\n\t(verify_symtab_base): Likewise.\n\t(verify_symtab_node): Likewise.\n\t(verify_symtab): Likewise.\n\t(symtab_used_from_object_file_p): Likewise.\n\t(symtab_node_availability): Likewise.\n\t(symtab_alias_ultimate_target): Likewise.\n\t(fixup_same_cpp_alias_visibility): Likewise.\n\t(symtab_resolve_alias): Likewise.\n\t(symtab_for_node_and_aliases): Likewise.\n\t(symtab_for_node_and_aliases): Likewise.\n\t(symtab_nonoverwritable_alias_1): Likewise.\n\t(symtab_nonoverwritable_alias): Likewise.\n\t(symtab_semantically_equivalent_p): Likewise.\n\t* value-prof.c (init_node_map): Likewise.\n\t* varasm.c (find_decl): Likewise.\n\t* varpool.c (varpool_node_for_asm): Likewise.\n\t(varpool_remove_unreferenced_decls): Likewise.\n\ngcc/c-family/\n\n\tPatch autogenerated by rename_symtab.py from\n\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n\n\t* c-pragma.c (maybe_apply_pending_pragma_weaks): Rename\n\tsymtab_node_base to symtab_node.\n\ngcc/lto/\n\n\tPatch autogenerated by rename_symtab.py from\n\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n\n\t* lto-partition.c (add_symbol_to_partition): Rename\n\tsymtab_node_base to symtab_node.\n\t(get_symbol_class): Likewise.\n\t(symbol_partitioned_p): Likewise.\n\t(add_references_to_partition): Likewise.\n\t(add_symbol_to_partition_1): Likewise.\n\t(contained_in_symbol): Likewise.\n\t(add_symbol_to_partition): Likewise.\n\t(lto_1_to_1_map): Likewise.\n\t(lto_max_map): Likewise.\n\t(lto_balanced_map): Likewise.\n\t(privatize_symbol_name): Likewise.\n\t(promote_symbol): Likewise.\n\t(may_need_named_section_p): Likewise.\n\t(rename_statics): Likewise.\n\t(lto_promote_statics_nonwpa): Likewise.\n\t* lto-symtab.c (lto_symtab_merge): Likewise.\n\t(lto_symtab_resolve_replaceable_p): Likewise.\n\t(lto_symtab_symbol_p): Likewise.\n\t(lto_symtab_resolve_can_prevail_p): Likewise.\n\t(lto_symtab_resolve_symbols): Likewise.\n\t(lto_symtab_merge_decls_2): Likewise.\n\t(lto_symtab_merge_decls_1): Likewise.\n\t(lto_symtab_merge_decls): Likewise.\n\t(lto_symtab_merge_symbols_1): Likewise.\n\t(lto_symtab_merge_symbols): Likewise.\n\t(lto_symtab_prevailing_decl): Likewise.\n\t* lto.c (lto_wpa_write_files): Likewise.\n\t(read_cgraph_and_symbols): Likewise.\n\t(do_whole_program_analysis): Likewise.\n\nFrom-SVN: r204279", "tree": {"sha": "f027b7dfe45942a8ae7ec9d539dbfe1b2330a706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f027b7dfe45942a8ae7ec9d539dbfe1b2330a706"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e20cdc96e65d712b5149af59e4580873d7928b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e20cdc96e65d712b5149af59e4580873d7928b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e20cdc96e65d712b5149af59e4580873d7928b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e20cdc96e65d712b5149af59e4580873d7928b7/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "64f37e9d425fc58e75724f4461431a30b5836403", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64f37e9d425fc58e75724f4461431a30b5836403", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64f37e9d425fc58e75724f4461431a30b5836403"}], "stats": {"total": 810, "additions": 520, "deletions": 290}, "files": [{"sha": "2a1b27130d6f1666f4d709fe004b76d97c512865", "filename": "gcc/ChangeLog", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -1,3 +1,183 @@\n+2013-10-31  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tAutomated part of renaming of symtab_node_base to symtab_node.\n+\n+\tPatch autogenerated by rename_symtab.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n+\twith ChangeLog entry fixed up by hand.\n+\n+\t* cgraph.c (x_cgraph_nodes_queue): Rename symtab_node_base to\n+\tsymtab_node.\n+\t(cgraph_node_for_asm): Likewise.\n+\t* cgraph.h (symtab_node_base): Likewise.\n+\t(cgraph_node): Likewise.\n+\t(varpool_node): Likewise.\n+\t(is_a_helper <cgraph_node>::test): Likewise.\n+\t(is_a_helper <varpool_node>::test): Likewise.\n+\t(symtab_nodes): Likewise.\n+\t(symtab_register_node): Likewise.\n+\t(symtab_unregister_node): Likewise.\n+\t(symtab_remove_node): Likewise.\n+\t(symtab_get_node): Likewise.\n+\t(symtab_node_for_asm): Likewise.\n+\t(symtab_node_asm_name): Likewise.\n+\t(symtab_node_name): Likewise.\n+\t(symtab_insert_node_to_hashtable): Likewise.\n+\t(symtab_add_to_same_comdat_group): Likewise.\n+\t(symtab_dissolve_same_comdat_group_list): Likewise.\n+\t(dump_symtab_node): Likewise.\n+\t(debug_symtab_node): Likewise.\n+\t(dump_symtab_base): Likewise.\n+\t(verify_symtab_node): Likewise.\n+\t(verify_symtab_base): Likewise.\n+\t(symtab_used_from_object_file_p): Likewise.\n+\t(symtab_alias_ultimate_target): Likewise.\n+\t(symtab_resolve_alias): Likewise.\n+\t(fixup_same_cpp_alias_visibility): Likewise.\n+\t(symtab_for_node_and_aliases): Likewise.\n+\t(symtab_nonoverwritable_alias): Likewise.\n+\t(availability symtab_node_availability): Likewise.\n+\t(symtab_semantically_equivalent_p): Likewise.\n+\t(fixup_same_cpp_alias_visibility): Likewise.\n+\t(symtab_prevail_in_asm_name_hash): Likewise.\n+\t(cgraph): Likewise.\n+\t(varpool): Likewise.\n+\t(varpool_first_variable): Likewise.\n+\t(varpool_next_variable): Likewise.\n+\t(varpool_first_static_initializer): Likewise.\n+\t(varpool_next_static_initializer): Likewise.\n+\t(varpool_first_defined_variable): Likewise.\n+\t(varpool_next_defined_variable): Likewise.\n+\t(cgraph_first_defined_function): Likewise.\n+\t(cgraph_next_defined_function): Likewise.\n+\t(cgraph_first_function): Likewise.\n+\t(cgraph_next_function): Likewise.\n+\t(cgraph_first_function_with_gimple_body): Likewise.\n+\t(cgraph_next_function_with_gimple_body): Likewise.\n+\t(symtab_alias_target): Likewise.\n+\t(symtab_real_symbol_p): Likewise.\n+\t(symtab_can_be_discarded): Likewise.\n+\t* cgraphbuild.c (mark_address): Likewise.\n+\t(mark_load): Likewise.\n+\t(mark_store): Likewise.\n+\t* cgraphunit.c (decide_is_symbol_needed): Likewise.\n+\t(first): Likewise.\n+\t(enqueue_node): Likewise.\n+\t(referred_to_p): Likewise.\n+\t(cgraph_process_same_body_aliases): Likewise.\n+\t(analyze_functions): Likewise.\n+\t(handle_alias_pairs): Likewise.\n+\t(output_weakrefs): Likewise.\n+\t(compile): Likewise.\n+\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Likewise.\n+\t* ipa-inline-analysis.c (inline_write_summary): Likewise.\n+\t* ipa-prop.c (remove_described_reference): Likewise.\n+\t(try_decrement_rdesc_refcount): Likewise.\n+\t(ipa_edge_duplication_hook): Likewise.\n+\t* ipa-ref.c (ipa_record_reference): Likewise.\n+\t(ipa_maybe_record_reference): Likewise.\n+\t(ipa_clone_ref): Likewise.\n+\t(ipa_clone_references): Likewise.\n+\t(ipa_clone_referring): Likewise.\n+\t(ipa_find_reference): Likewise.\n+\t(ipa_remove_stmt_references): Likewise.\n+\t(ipa_clear_stmts_in_references): Likewise.\n+\t* ipa-ref.h (symtab_node_base): Likewise.\n+\t(ipa_ref): Likewise.\n+\t(ipa_record_reference): Likewise.\n+\t(ipa_maybe_record_reference): Likewise.\n+\t(ipa_clone_references): Likewise.\n+\t(ipa_clone_referring): Likewise.\n+\t(ipa_clone_ref): Likewise.\n+\t(ipa_find_reference): Likewise.\n+\t(ipa_remove_stmt_references): Likewise.\n+\t(ipa_clear_stmts_in_references): Likewise.\n+\t* ipa-reference.c (ipa_reference_write_optimization_summary):\n+\tLikewise.\n+\t* ipa.c (enqueue_node): Likewise.\n+\t(process_references): Likewise.\n+\t(walk_polymorphic_call_targets): Likewise.\n+\t(symtab_remove_unreachable_nodes): Likewise.\n+\t(address_taken_from_non_vtable_p): Likewise.\n+\t(comdat_can_be_unshared_p_1): Likewise.\n+\t(comdat_can_be_unshared_p): Likewise.\n+\t(can_replace_by_local_alias): Likewise.\n+\t(function_and_variable_visibility): Likewise.\n+\t* is-a.h: Likewise (within example in comment).\n+\t* lto-cgraph.c (input_cgraph_opt_summary): Likewise.\n+\t(lto_symtab_encoder_encode): Likewise.\n+\t(lto_symtab_encoder_delete_node): Likewise.\n+\t(lto_symtab_encoder_in_partition_p): Likewise.\n+\t(lto_set_symtab_encoder_in_partition): Likewise.\n+\t(output_refs): Likewise.\n+\t(compute_ltrans_boundary): Likewise.\n+\t(output_symtab): Likewise.\n+\t(input_node): Likewise.\n+\t(input_ref): Likewise.\n+\t(input_edge): Likewise.\n+\t(input_cgraph_1): Likewise.\n+\t(input_refs): Likewise.\n+\t(output_cgraph_opt_summary): Likewise.\n+\t(input_node_opt_summary): Likewise.\n+\t(input_cgraph_opt_section): Likewise.\n+\t* lto-section-in.c (lto_free_function_in_decl_state_for_node):\n+\tLikewise.\n+\t* lto-streamer-out.c (lto_output): Likewise.\n+\t(output_symbol_p): Likewise.\n+\t(produce_symtab): Likewise.\n+\t* lto-streamer.h (lto_encoder_entry): Likewise.\n+\t(lto_free_function_in_decl_state_for_node): Likewise.\n+\t(lto_symtab_encoder_encode): Likewise.\n+\t(lto_symtab_encoder_delete_node): Likewise.\n+\t(lto_symtab_encoder_in_partition_p): Likewise.\n+\t(lto_set_symtab_encoder_in_partition): Likewise.\n+\t(lto_symtab_encoder_lookup): Likewise.\n+\t(lsei_node): Likewise.\n+\t(lto_symtab_encoder_deref): Likewise.\n+\t* symtab.c (symtab_hash): Likewise.\n+\t(assembler_name_hash): Likewise.\n+\t(symtab_nodes): Likewise.\n+\t(hash_node): Likewise.\n+\t(eq_node): Likewise.\n+\t(hash_node_by_assembler_name): Likewise.\n+\t(eq_assembler_name): Likewise.\n+\t(insert_to_assembler_name_hash): Likewise.\n+\t(unlink_from_assembler_name_hash): Likewise.\n+\t(symtab_prevail_in_asm_name_hash): Likewise.\n+\t(symtab_register_node): Likewise.\n+\t(symtab_insert_node_to_hashtable): Likewise.\n+\t(symtab_unregister_node): Likewise.\n+\t(symtab_get_node): Likewise.\n+\t(symtab_remove_node): Likewise.\n+\t(symtab_initialize_asm_name_hash): Likewise.\n+\t(symtab_node_for_asm): Likewise.\n+\t(symtab_add_to_same_comdat_group): Likewise.\n+\t(symtab_dissolve_same_comdat_group_list): Likewise.\n+\t(symtab_node_asm_name): Likewise.\n+\t(symtab_node_name): Likewise.\n+\t(dump_symtab_base): Likewise.\n+\t(dump_symtab_node): Likewise.\n+\t(dump_symtab): Likewise.\n+\t(debug_symtab_node): Likewise.\n+\t(verify_symtab_base): Likewise.\n+\t(verify_symtab_node): Likewise.\n+\t(verify_symtab): Likewise.\n+\t(symtab_used_from_object_file_p): Likewise.\n+\t(symtab_node_availability): Likewise.\n+\t(symtab_alias_ultimate_target): Likewise.\n+\t(fixup_same_cpp_alias_visibility): Likewise.\n+\t(symtab_resolve_alias): Likewise.\n+\t(symtab_for_node_and_aliases): Likewise.\n+\t(symtab_for_node_and_aliases): Likewise.\n+\t(symtab_nonoverwritable_alias_1): Likewise.\n+\t(symtab_nonoverwritable_alias): Likewise.\n+\t(symtab_semantically_equivalent_p): Likewise.\n+\t* value-prof.c (init_node_map): Likewise.\n+\t* varasm.c (find_decl): Likewise.\n+\t* varpool.c (varpool_node_for_asm): Likewise.\n+\t(varpool_remove_unreferenced_decls): Likewise.\n+\n 2013-10-31  David Malcolm  <dmalcolm@redhat.com>\n \n \tManual part of renaming of symtab_node_base to symtab_node."}, {"sha": "13a66871c3af48c76cbbd7b11a24b961ca04a8e3", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -1,3 +1,14 @@\n+2013-10-31  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tAutomated part of renaming of symtab_node_base to symtab_node.\n+\n+\tPatch autogenerated by rename_symtab.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n+\n+\t* c-pragma.c (maybe_apply_pending_pragma_weaks): Rename\n+\tsymtab_node_base to symtab_node.\n+\n 2013-10-31  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n         Implement C++14 digit separators."}, {"sha": "3ce77a2e91aabec6dfdd217e55cf255441588d5d", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -307,7 +307,7 @@ maybe_apply_pending_pragma_weaks (void)\n   tree alias_id, id, decl;\n   int i;\n   pending_weak *pe;\n-  symtab_node target;\n+  symtab_node *target;\n \n   if (!pending_weaks)\n     return;"}, {"sha": "f3666fab6dd4c160d17fd694ac18fb1b188ab089", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -64,7 +64,7 @@ static inline void cgraph_edge_remove_caller (struct cgraph_edge *e);\n static inline void cgraph_edge_remove_callee (struct cgraph_edge *e);\n \n /* Queue of cgraph nodes scheduled to be lowered.  */\n-symtab_node x_cgraph_nodes_queue;\n+symtab_node *x_cgraph_nodes_queue;\n #define cgraph_nodes_queue ((struct cgraph_node *)x_cgraph_nodes_queue)\n \n /* Number of nodes in existence.  */\n@@ -647,7 +647,7 @@ struct cgraph_node *\n cgraph_node_for_asm (tree asmname)\n {\n   /* We do not want to look at inline clones.  */\n-  for (symtab_node node = symtab_node_for_asm (asmname);\n+  for (symtab_node *node = symtab_node_for_asm (asmname);\n        node;\n        node = node->next_sharing_asm_name)\n     {"}, {"sha": "4f93713b889d846a91ef1a815b3d6c9fb5c0ab48", "filename": "gcc/cgraph.h", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -41,7 +41,7 @@ enum symtab_type\n    The symtab_node is inherited by cgraph and varpol nodes.  */\n class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \t   chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n-  symtab_node_base\n+  symtab_node\n {\n public:\n   /* Type of the symbol.  */\n@@ -113,8 +113,8 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   tree decl;\n \n   /* Linked list of symbol table entries starting with symtab_nodes.  */\n-  symtab_node next;\n-  symtab_node previous;\n+  symtab_node *next;\n+  symtab_node *previous;\n \n   /* Linked list of symbols with the same asm name.  There may be multiple\n      entries for single symbol name during LTO, because symbols are renamed\n@@ -125,11 +125,11 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \n      There are also several long standing bugs where frontends and builtin\n      code produce duplicated decls.  */\n-  symtab_node next_sharing_asm_name;\n-  symtab_node previous_sharing_asm_name;\n+  symtab_node *next_sharing_asm_name;\n+  symtab_node *previous_sharing_asm_name;\n \n   /* Circular list of nodes in the same comdat group if non-NULL.  */\n-  symtab_node same_comdat_group;\n+  symtab_node *same_comdat_group;\n \n   /* Vectors of referring and referenced entities.  */\n   struct ipa_ref_list ref_list;\n@@ -254,7 +254,7 @@ struct GTY(()) cgraph_clone_info\n /* The cgraph data structure.\n    Each function decl has assigned cgraph_node listing callees and callers.  */\n \n-struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node_base {\n+struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n public:\n   struct cgraph_edge *callees;\n   struct cgraph_edge *callers;\n@@ -514,7 +514,7 @@ typedef struct cgraph_edge *cgraph_edge_p;\n /* The varpool data structure.\n    Each static variable decl has assigned varpool_node.  */\n \n-class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node_base {\n+class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n public:\n   /* Set when variable is scheduled to be assembled.  */\n   unsigned output : 1;\n@@ -536,7 +536,7 @@ struct GTY(()) asm_node {\n template <>\n template <>\n inline bool\n-is_a_helper <cgraph_node>::test (symtab_node_base *p)\n+is_a_helper <cgraph_node>::test (symtab_node *p)\n {\n   return p->type == SYMTAB_FUNCTION;\n }\n@@ -546,12 +546,12 @@ is_a_helper <cgraph_node>::test (symtab_node_base *p)\n template <>\n template <>\n inline bool\n-is_a_helper <varpool_node>::test (symtab_node_base *p)\n+is_a_helper <varpool_node>::test (symtab_node *p)\n {\n   return p->type == SYMTAB_VARIABLE;\n }\n \n-extern GTY(()) symtab_node symtab_nodes;\n+extern GTY(()) symtab_node *symtab_nodes;\n extern GTY(()) int cgraph_n_nodes;\n extern GTY(()) int cgraph_max_uid;\n extern GTY(()) int cgraph_edge_max_uid;\n@@ -582,37 +582,37 @@ extern GTY(()) int symtab_order;\n extern bool cpp_implicit_aliases_done;\n \n /* In symtab.c  */\n-void symtab_register_node (symtab_node);\n-void symtab_unregister_node (symtab_node);\n-void symtab_remove_node (symtab_node);\n-symtab_node symtab_get_node (const_tree);\n-symtab_node symtab_node_for_asm (const_tree asmname);\n-const char * symtab_node_asm_name (symtab_node);\n-const char * symtab_node_name (symtab_node);\n-void symtab_insert_node_to_hashtable (symtab_node);\n-void symtab_add_to_same_comdat_group (symtab_node, symtab_node);\n-void symtab_dissolve_same_comdat_group_list (symtab_node node);\n+void symtab_register_node (symtab_node *);\n+void symtab_unregister_node (symtab_node *);\n+void symtab_remove_node (symtab_node *);\n+symtab_node *symtab_get_node (const_tree);\n+symtab_node *symtab_node_for_asm (const_tree asmname);\n+const char * symtab_node_asm_name (symtab_node *);\n+const char * symtab_node_name (symtab_node *);\n+void symtab_insert_node_to_hashtable (symtab_node *);\n+void symtab_add_to_same_comdat_group (symtab_node *, symtab_node *);\n+void symtab_dissolve_same_comdat_group_list (symtab_node *node);\n void dump_symtab (FILE *);\n void debug_symtab (void);\n-void dump_symtab_node (FILE *, symtab_node);\n-void debug_symtab_node (symtab_node);\n-void dump_symtab_base (FILE *, symtab_node);\n+void dump_symtab_node (FILE *, symtab_node *);\n+void debug_symtab_node (symtab_node *);\n+void dump_symtab_base (FILE *, symtab_node *);\n void verify_symtab (void);\n-void verify_symtab_node (symtab_node);\n-bool verify_symtab_base (symtab_node);\n-bool symtab_used_from_object_file_p (symtab_node);\n+void verify_symtab_node (symtab_node *);\n+bool verify_symtab_base (symtab_node *);\n+bool symtab_used_from_object_file_p (symtab_node *);\n void symtab_make_decl_local (tree);\n-symtab_node symtab_alias_ultimate_target (symtab_node,\n+symtab_node *symtab_alias_ultimate_target (symtab_node *,\n \t\t\t\t\t  enum availability *avail = NULL);\n-bool symtab_resolve_alias (symtab_node node, symtab_node target);\n-void fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target);\n-bool symtab_for_node_and_aliases (symtab_node,\n-\t\t\t\t  bool (*) (symtab_node, void *),\n+bool symtab_resolve_alias (symtab_node *node, symtab_node *target);\n+void fixup_same_cpp_alias_visibility (symtab_node *node, symtab_node *target);\n+bool symtab_for_node_and_aliases (symtab_node *,\n+\t\t\t\t  bool (*) (symtab_node *, void *),\n \t\t\t\t  void *,\n \t\t\t\t  bool);\n-symtab_node symtab_nonoverwritable_alias (symtab_node);\n-enum availability symtab_node_availability (symtab_node);\n-bool symtab_semantically_equivalent_p (symtab_node, symtab_node);\n+symtab_node *symtab_nonoverwritable_alias (symtab_node *);\n+enum availability symtab_node_availability (symtab_node *);\n+bool symtab_semantically_equivalent_p (symtab_node *, symtab_node *);\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n@@ -738,7 +738,7 @@ void compile (void);\n void init_cgraph (void);\n bool cgraph_process_new_functions (void);\n void cgraph_process_same_body_aliases (void);\n-void fixup_same_cpp_alias_visibility (symtab_node, symtab_node target, tree);\n+void fixup_same_cpp_alias_visibility (symtab_node *, symtab_node *target, tree);\n /*  Initialize datastructures so DECL is a function in lowered gimple form.\n     IN_SSA is true if the gimple is in SSA.  */\n basic_block init_lowered_empty_function (tree, bool);\n@@ -842,21 +842,21 @@ bool varpool_for_node_and_aliases (struct varpool_node *,\n \t\t\t           void *, bool);\n void varpool_add_new_variable (tree);\n void symtab_initialize_asm_name_hash (void);\n-void symtab_prevail_in_asm_name_hash (symtab_node node);\n+void symtab_prevail_in_asm_name_hash (symtab_node *node);\n void varpool_remove_initializer (struct varpool_node *);\n \n \n /* Return callgraph node for given symbol and check it is a function. */\n static inline struct cgraph_node *\n-cgraph (symtab_node node)\n+cgraph (symtab_node *node)\n {\n   gcc_checking_assert (!node || node->type == SYMTAB_FUNCTION);\n   return (struct cgraph_node *)node;\n }\n \n /* Return varpool node for given symbol and check it is a variable.  */\n static inline struct varpool_node *\n-varpool (symtab_node node)\n+varpool (symtab_node *node)\n {\n   gcc_checking_assert (!node || node->type == SYMTAB_VARIABLE);\n   return (struct varpool_node *)node;\n@@ -915,7 +915,7 @@ varpool_node_name (struct varpool_node *node)\n static inline struct varpool_node *\n varpool_first_variable (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n     if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n       return vnode;\n@@ -926,7 +926,7 @@ varpool_first_variable (void)\n static inline struct varpool_node *\n varpool_next_variable (struct varpool_node *node)\n {\n-  symtab_node node1 = node->next;\n+  symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     if (varpool_node *vnode1 = dyn_cast <varpool_node> (node1))\n       return vnode1;\n@@ -942,7 +942,7 @@ varpool_next_variable (struct varpool_node *node)\n static inline struct varpool_node *\n varpool_first_static_initializer (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n     {\n       varpool_node *vnode = dyn_cast <varpool_node> (node);\n@@ -956,7 +956,7 @@ varpool_first_static_initializer (void)\n static inline struct varpool_node *\n varpool_next_static_initializer (struct varpool_node *node)\n {\n-  symtab_node node1 = node->next;\n+  symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     {\n       varpool_node *vnode1 = dyn_cast <varpool_node> (node1);\n@@ -975,7 +975,7 @@ varpool_next_static_initializer (struct varpool_node *node)\n static inline struct varpool_node *\n varpool_first_defined_variable (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n     {\n       varpool_node *vnode = dyn_cast <varpool_node> (node);\n@@ -989,7 +989,7 @@ varpool_first_defined_variable (void)\n static inline struct varpool_node *\n varpool_next_defined_variable (struct varpool_node *node)\n {\n-  symtab_node node1 = node->next;\n+  symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     {\n       varpool_node *vnode1 = dyn_cast <varpool_node> (node1);\n@@ -1007,7 +1007,7 @@ varpool_next_defined_variable (struct varpool_node *node)\n static inline struct cgraph_node *\n cgraph_first_defined_function (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n     {\n       cgraph_node *cn = dyn_cast <cgraph_node> (node);\n@@ -1021,7 +1021,7 @@ cgraph_first_defined_function (void)\n static inline struct cgraph_node *\n cgraph_next_defined_function (struct cgraph_node *node)\n {\n-  symtab_node node1 = node->next;\n+  symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     {\n       cgraph_node *cn1 = dyn_cast <cgraph_node> (node1);\n@@ -1040,7 +1040,7 @@ cgraph_next_defined_function (struct cgraph_node *node)\n static inline struct cgraph_node *\n cgraph_first_function (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n     if (cgraph_node *cn = dyn_cast <cgraph_node> (node))\n       return cn;\n@@ -1051,7 +1051,7 @@ cgraph_first_function (void)\n static inline struct cgraph_node *\n cgraph_next_function (struct cgraph_node *node)\n {\n-  symtab_node node1 = node->next;\n+  symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     if (cgraph_node *cn1 = dyn_cast <cgraph_node> (node1))\n       return cn1;\n@@ -1078,7 +1078,7 @@ cgraph_function_with_gimple_body_p (struct cgraph_node *node)\n static inline struct cgraph_node *\n cgraph_first_function_with_gimple_body (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n     {\n       cgraph_node *cn = dyn_cast <cgraph_node> (node);\n@@ -1092,7 +1092,7 @@ cgraph_first_function_with_gimple_body (void)\n static inline struct cgraph_node *\n cgraph_next_function_with_gimple_body (struct cgraph_node *node)\n {\n-  symtab_node node1 = node->next;\n+  symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     {\n       cgraph_node *cn1 = dyn_cast <cgraph_node> (node1);\n@@ -1291,8 +1291,8 @@ htab_t constant_pool_htab (void);\n \n /* Return node that alias N is aliasing.  */\n \n-static inline symtab_node\n-symtab_alias_target (symtab_node n)\n+static inline symtab_node *\n+symtab_alias_target (symtab_node *n)\n {\n   struct ipa_ref *ref;\n   ipa_ref_list_reference_iterate (&n->ref_list, 0, ref);\n@@ -1380,7 +1380,7 @@ cgraph_mark_force_output_node (struct cgraph_node *node)\n    or abstract function kept for debug info purposes only.  */\n \n static inline bool\n-symtab_real_symbol_p (symtab_node node)\n+symtab_real_symbol_p (symtab_node *node)\n {\n   struct cgraph_node *cnode;\n \n@@ -1397,7 +1397,7 @@ symtab_real_symbol_p (symtab_node node)\n /* Return true if NODE can be discarded by linker from the binary.  */\n \n static inline bool\n-symtab_can_be_discarded (symtab_node node)\n+symtab_can_be_discarded (symtab_node *node)\n {\n   return (DECL_EXTERNAL (node->decl)\n \t  || (DECL_ONE_ONLY (node->decl)"}, {"sha": "87e06e37cbebb1a6ad1620e5c4f38777592f5146", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -223,7 +223,7 @@ mark_address (gimple stmt, tree addr, void *data)\n     {\n       struct cgraph_node *node = cgraph_get_create_real_symbol_node (addr);\n       cgraph_mark_address_taken_node (node);\n-      ipa_record_reference ((symtab_node)data,\n+      ipa_record_reference ((symtab_node *)data,\n \t\t\t    node,\n \t\t\t    IPA_REF_ADDR, stmt);\n     }\n@@ -232,7 +232,7 @@ mark_address (gimple stmt, tree addr, void *data)\n     {\n       struct varpool_node *vnode = varpool_node_for_decl (addr);\n \n-      ipa_record_reference ((symtab_node)data,\n+      ipa_record_reference ((symtab_node *)data,\n \t\t\t    vnode,\n \t\t\t    IPA_REF_ADDR, stmt);\n     }\n@@ -252,7 +252,7 @@ mark_load (gimple stmt, tree t, void *data)\n \t directly manipulated in the code.  Pretend that it's an address.  */\n       struct cgraph_node *node = cgraph_get_create_real_symbol_node (t);\n       cgraph_mark_address_taken_node (node);\n-      ipa_record_reference ((symtab_node)data,\n+      ipa_record_reference ((symtab_node *)data,\n \t\t\t    node,\n \t\t\t    IPA_REF_ADDR, stmt);\n     }\n@@ -261,7 +261,7 @@ mark_load (gimple stmt, tree t, void *data)\n     {\n       struct varpool_node *vnode = varpool_node_for_decl (t);\n \n-      ipa_record_reference ((symtab_node)data,\n+      ipa_record_reference ((symtab_node *)data,\n \t\t\t    vnode,\n \t\t\t    IPA_REF_LOAD, stmt);\n     }\n@@ -279,7 +279,7 @@ mark_store (gimple stmt, tree t, void *data)\n     {\n       struct varpool_node *vnode = varpool_node_for_decl (t);\n \n-      ipa_record_reference ((symtab_node)data,\n+      ipa_record_reference ((symtab_node *)data,\n \t\t\t    vnode,\n \t\t\t    IPA_REF_STORE, stmt);\n      }"}, {"sha": "c3a8967e843af60f9508e8431c1ecb6493cfe1f4", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -225,7 +225,7 @@ static GTY (()) tree vtable_entry_type;\n    either outside this translation unit, something magic in the system\n    configury */\n bool\n-decide_is_symbol_needed (symtab_node node)\n+decide_is_symbol_needed (symtab_node *node)\n {\n   tree decl = node->decl;\n \n@@ -263,13 +263,13 @@ decide_is_symbol_needed (symtab_node node)\n \n /* Head of the queue of nodes to be processed while building callgraph */\n \n-static symtab_node first = (symtab_node)(void *)1;\n+static symtab_node *first = (symtab_node *)(void *)1;\n \n /* Add NODE to queue starting at FIRST. \n    The queue is linked via AUX pointers and terminated by pointer to 1.  */\n \n static void\n-enqueue_node (symtab_node node)\n+enqueue_node (symtab_node *node)\n {\n   if (node->aux)\n     return;\n@@ -387,7 +387,7 @@ cgraph_reset_node (struct cgraph_node *node)\n /* Return true when there are references to NODE.  */\n \n static bool\n-referred_to_p (symtab_node node)\n+referred_to_p (symtab_node *node)\n {\n   struct ipa_ref *ref;\n \n@@ -671,14 +671,14 @@ analyze_function (struct cgraph_node *node)\n void\n cgraph_process_same_body_aliases (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   FOR_EACH_SYMBOL (node)\n     if (node->cpp_implicit_alias && !node->analyzed)\n       symtab_resolve_alias\n         (node,\n \t TREE_CODE (node->alias_target) == VAR_DECL\n-\t ? (symtab_node)varpool_node_for_decl (node->alias_target)\n-\t : (symtab_node)cgraph_get_create_node (node->alias_target));\n+\t ? (symtab_node *)varpool_node_for_decl (node->alias_target)\n+\t : (symtab_node *)cgraph_get_create_node (node->alias_target));\n   cpp_implicit_aliases_done = true;\n }\n \n@@ -920,8 +920,8 @@ analyze_functions (void)\n   struct varpool_node *first_handled_var = first_analyzed_var;\n   struct pointer_set_t *reachable_call_targets = pointer_set_create ();\n \n-  symtab_node node;\n-  symtab_node next;\n+  symtab_node *node;\n+  symtab_node *next;\n   int i;\n   struct ipa_ref *ref;\n   bool changed = true;\n@@ -977,11 +977,11 @@ analyze_functions (void)\n \n       /* Lower representation, build callgraph edges and references for all trivially\n          needed symbols and all symbols referred by them.  */\n-      while (first != (symtab_node)(void *)1)\n+      while (first != (symtab_node *)(void *)1)\n \t{\n \t  changed = true;\n \t  node = first;\n-\t  first = (symtab_node)first->aux;\n+\t  first = (symtab_node *)first->aux;\n \t  cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n \t  if (cnode && cnode->definition)\n \t    {\n@@ -1040,7 +1040,7 @@ analyze_functions (void)\n \n \t  if (node->same_comdat_group)\n \t    {\n-\t      symtab_node next;\n+\t      symtab_node *next;\n \t      for (next = node->same_comdat_group;\n \t\t   next != node;\n \t\t   next = next->same_comdat_group)\n@@ -1126,15 +1126,15 @@ handle_alias_pairs (void)\n   \n   for (i = 0; alias_pairs && alias_pairs->iterate (i, &p);)\n     {\n-      symtab_node target_node = symtab_node_for_asm (p->target);\n+      symtab_node *target_node = symtab_node_for_asm (p->target);\n \n       /* Weakrefs with target not defined in current unit are easy to handle:\n \t they behave just as external variables except we need to note the\n \t alias flag to later output the weakref pseudo op into asm file.  */\n       if (!target_node\n \t  && lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)) != NULL)\n \t{\n-\t  symtab_node node = symtab_get_node (p->decl);\n+\t  symtab_node *node = symtab_get_node (p->decl);\n \t  if (node)\n \t    {\n \t      node->alias_target = p->target;\n@@ -1147,7 +1147,7 @@ handle_alias_pairs (void)\n       else if (!target_node)\n \t{\n \t  error (\"%q+D aliased to undefined symbol %qE\", p->decl, p->target);\n-\t  symtab_node node = symtab_get_node (p->decl);\n+\t  symtab_node *node = symtab_get_node (p->decl);\n \t  if (node)\n \t    node->alias = false;\n \t  alias_pairs->unordered_remove (i);\n@@ -2049,7 +2049,7 @@ get_alias_symbol (tree decl)\n static void\n output_weakrefs (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   FOR_EACH_SYMBOL (node)\n     if (node->alias\n         && !TREE_ASM_WRITTEN (node->decl)\n@@ -2171,7 +2171,7 @@ compile (void)\n      level by physically rewritting the IL.  At the moment we can only redirect\n      calls, so we need infrastructure for renaming references as well.  */\n #ifndef ASM_OUTPUT_WEAKREF\n-  symtab_node node;\n+  symtab_node *node;\n \n   FOR_EACH_SYMBOL (node)\n     if (node->alias"}, {"sha": "b4da694b27bd1a74576ac2ebd99bdb6b267e2f2e", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -66,7 +66,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n {\n   struct varpool_node *vnode;\n   struct cgraph_node *node;\n-  symtab_node snode;\n+  symtab_node *snode;\n \n   if (DECL_ABSTRACT (decl))\n     return false;"}, {"sha": "445872387d850b0a78d58cdc4a81d56f753ad04e", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -4055,7 +4055,7 @@ inline_write_summary (void)\n \n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n       cgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n       if (cnode && cnode->definition && !cnode->alias)\n \tcount++;\n@@ -4064,7 +4064,7 @@ inline_write_summary (void)\n \n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n       cgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n       if (cnode && (node = cnode)->definition && !node->alias)\n \t{"}, {"sha": "d9ea5dc08bfff2cd313e59444c97e76b80f5e931", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -2512,7 +2512,7 @@ ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg,\n    successfully found and removed.  */\n \n static bool\n-remove_described_reference (symtab_node symbol, struct ipa_cst_ref_desc *rdesc)\n+remove_described_reference (symtab_node *symbol, struct ipa_cst_ref_desc *rdesc)\n {\n   struct ipa_ref *to_del;\n   struct cgraph_edge *origin;\n@@ -2577,7 +2577,7 @@ try_decrement_rdesc_refcount (struct ipa_jump_func *jfunc)\n       && (rdesc = jfunc_rdesc_usable (jfunc))\n       && --rdesc->refcount == 0)\n     {\n-      symtab_node symbol = cgraph_node_for_jfunc (jfunc);\n+      symtab_node *symbol = cgraph_node_for_jfunc (jfunc);\n       if (!symbol)\n \treturn false;\n \n@@ -3097,7 +3097,7 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \t  else if (src->caller == dst->caller)\n \t    {\n \t      struct ipa_ref *ref;\n-\t      symtab_node n = cgraph_node_for_jfunc (src_jf);\n+\t      symtab_node *n = cgraph_node_for_jfunc (src_jf);\n \t      gcc_checking_assert (n);\n \t      ref = ipa_find_reference (src->caller, n,\n \t\t\t\t\tsrc->call_stmt, src->lto_stmt_uid);"}, {"sha": "04ce9090dfe506f28ea11cb6fd327d43c5f2147c", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -34,8 +34,8 @@ static const char *ipa_ref_use_name[] = {\"read\",\"write\",\"addr\",\"alias\"};\n    of the use and STMT the statement (if it exists).  */\n \n struct ipa_ref *\n-ipa_record_reference (symtab_node referring_node,\n-\t\t      symtab_node referred_node,\n+ipa_record_reference (symtab_node *referring_node,\n+\t\t      symtab_node *referred_node,\n \t\t      enum ipa_ref_use use_type, gimple stmt)\n {\n   struct ipa_ref *ref, *ref2;\n@@ -76,7 +76,7 @@ ipa_record_reference (symtab_node referring_node,\n    reference or NULL if none was created.  */\n \n struct ipa_ref *\n-ipa_maybe_record_reference (symtab_node referring_node, tree val,\n+ipa_maybe_record_reference (symtab_node *referring_node, tree val,\n \t\t\t    enum ipa_ref_use use_type, gimple stmt)\n {\n   STRIP_NOPS (val);\n@@ -86,7 +86,7 @@ ipa_maybe_record_reference (symtab_node referring_node, tree val,\n   if (val && (TREE_CODE (val) == FUNCTION_DECL\n \t       || TREE_CODE (val) == VAR_DECL))\n     {\n-      symtab_node referred = symtab_get_node (val);\n+      symtab_node *referred = symtab_get_node (val);\n       gcc_checking_assert (referred);\n       return ipa_record_reference (referring_node, referred,\n \t\t\t\t   use_type, stmt);\n@@ -186,7 +186,7 @@ ipa_dump_referring (FILE * file, struct ipa_ref_list *list)\n \n struct ipa_ref *\n ipa_clone_ref (struct ipa_ref *ref,\n-\t       symtab_node dest_node,\n+\t       symtab_node *dest_node,\n \t       gimple stmt)\n {\n   bool speculative = ref->speculative;\n@@ -204,7 +204,7 @@ ipa_clone_ref (struct ipa_ref *ref,\n /* Clone all references from SRC to DEST_NODE or DEST_VARPOOL_NODE.  */\n \n void\n-ipa_clone_references (symtab_node dest_node,\n+ipa_clone_references (symtab_node *dest_node,\n \t\t      struct ipa_ref_list *src)\n {\n   struct ipa_ref *ref, *ref2;\n@@ -225,7 +225,7 @@ ipa_clone_references (symtab_node dest_node,\n /* Clone all referring from SRC to DEST_NODE or DEST_VARPOOL_NODE.  */\n \n void\n-ipa_clone_referring (symtab_node dest_node,\n+ipa_clone_referring (symtab_node *dest_node,\n \t\t    struct ipa_ref_list *src)\n {\n   struct ipa_ref *ref, *ref2;\n@@ -268,7 +268,7 @@ ipa_ref_has_aliases_p (struct ipa_ref_list *ref_list)\n    and associated with statement STMT.  */\n \n struct ipa_ref *\n-ipa_find_reference (symtab_node referring_node, symtab_node referred_node,\n+ipa_find_reference (symtab_node *referring_node, symtab_node *referred_node,\n \t\t    gimple stmt, unsigned int lto_stmt_uid)\n {\n   struct ipa_ref *r = NULL;\n@@ -288,7 +288,7 @@ ipa_find_reference (symtab_node referring_node, symtab_node referred_node,\n    STMT.  */\n \n void\n-ipa_remove_stmt_references (symtab_node referring_node, gimple stmt)\n+ipa_remove_stmt_references (symtab_node *referring_node, gimple stmt)\n {\n   struct ipa_ref *r = NULL;\n   int i;\n@@ -304,7 +304,7 @@ ipa_remove_stmt_references (symtab_node referring_node, gimple stmt)\n    with callgraph edges associated with them.  */\n \n void\n-ipa_clear_stmts_in_references (symtab_node referring_node)\n+ipa_clear_stmts_in_references (symtab_node *referring_node)\n {\n   struct ipa_ref *r = NULL;\n   int i;"}, {"sha": "9f392b41588b2b34af8e3f92ccd0e46730db66b1", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n \n struct cgraph_node;\n struct varpool_node;\n-class symtab_node_base;\n+class symtab_node;\n \n \n /* How the reference is done.  */\n@@ -35,8 +35,8 @@ enum GTY(()) ipa_ref_use\n /* Record of reference in callgraph or varpool.  */\n struct GTY(()) ipa_ref\n {\n-  symtab_node referring;\n-  symtab_node referred;\n+  symtab_node *referring;\n+  symtab_node *referred;\n   gimple stmt;\n   unsigned int lto_stmt_uid;\n   unsigned int referred_index;\n@@ -58,22 +58,22 @@ struct GTY(()) ipa_ref_list\n   vec<ipa_ref_ptr>  GTY((skip)) referring;\n };\n \n-struct ipa_ref * ipa_record_reference (symtab_node,\n-\t\t\t\t       symtab_node,\n+struct ipa_ref * ipa_record_reference (symtab_node *,\n+\t\t\t\t       symtab_node *,\n \t\t\t\t       enum ipa_ref_use, gimple);\n-struct ipa_ref * ipa_maybe_record_reference (symtab_node, tree,\n+struct ipa_ref * ipa_maybe_record_reference (symtab_node *, tree,\n \t\t\t\t\t     enum ipa_ref_use, gimple);\n \n void ipa_remove_reference (struct ipa_ref *);\n void ipa_remove_all_references (struct ipa_ref_list *);\n void ipa_remove_all_referring (struct ipa_ref_list *);\n void ipa_dump_references (FILE *, struct ipa_ref_list *);\n void ipa_dump_referring (FILE *, struct ipa_ref_list *);\n-void ipa_clone_references (symtab_node, struct ipa_ref_list *);\n-void ipa_clone_referring (symtab_node, struct ipa_ref_list *);\n-struct ipa_ref * ipa_clone_ref (struct ipa_ref *, symtab_node, gimple);\n+void ipa_clone_references (symtab_node *, struct ipa_ref_list *);\n+void ipa_clone_referring (symtab_node *, struct ipa_ref_list *);\n+struct ipa_ref * ipa_clone_ref (struct ipa_ref *, symtab_node *, gimple);\n bool ipa_ref_cannot_lead_to_return (struct ipa_ref *);\n bool ipa_ref_has_aliases_p (struct ipa_ref_list *);\n-struct ipa_ref * ipa_find_reference (symtab_node, symtab_node, gimple, unsigned int);\n-void ipa_remove_stmt_references (symtab_node, gimple);\n-void ipa_clear_stmts_in_references (symtab_node);\n+struct ipa_ref * ipa_find_reference (symtab_node *, symtab_node *, gimple, unsigned int);\n+void ipa_remove_stmt_references (symtab_node *, gimple);\n+void ipa_clear_stmts_in_references (symtab_node *);"}, {"sha": "ae8ba3c651fd4825e5aaf71a9edad37a0a1bfb2b", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -968,7 +968,7 @@ ipa_reference_write_optimization_summary (void)\n   /* See what variables we are interested in.  */\n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n       varpool_node *vnode = dyn_cast <varpool_node> (snode);\n       if (vnode\n \t  && bitmap_bit_p (all_module_statics, DECL_UID (vnode->decl))\n@@ -986,7 +986,7 @@ ipa_reference_write_optimization_summary (void)\n   if (ltrans_statics_bitcount)\n     for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n       {\n-\tsymtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+\tsymtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n \tcgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n \tif (cnode && write_node_summary_p (cnode, encoder, ltrans_statics))\n \t  count++;\n@@ -1001,7 +1001,7 @@ ipa_reference_write_optimization_summary (void)\n   if (ltrans_statics_bitcount)\n     for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n       {\n-\tsymtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+\tsymtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n \tcgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n \tif (cnode && write_node_summary_p (cnode, encoder, ltrans_statics))\n \t  {"}, {"sha": "aef437a46f51b7ffd35a41eaf8941d77cfb078ca", "filename": "gcc/ipa.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -107,7 +107,7 @@ update_inlined_to_pointer (struct cgraph_node *node, struct cgraph_node *inlined\n    reachable.  */\n \n static void\n-enqueue_node (symtab_node node, symtab_node *first,\n+enqueue_node (symtab_node *node, symtab_node **first,\n \t      struct pointer_set_t *reachable)\n {\n   /* Node is still in queue; do nothing.  */\n@@ -125,15 +125,15 @@ enqueue_node (symtab_node node, symtab_node *first,\n \n static void\n process_references (struct ipa_ref_list *list,\n-\t\t    symtab_node *first,\n+\t\t    symtab_node **first,\n \t\t    bool before_inlining_p,\n \t\t    struct pointer_set_t *reachable)\n {\n   int i;\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n     {\n-      symtab_node node = ref->referred;\n+      symtab_node *node = ref->referred;\n \n       if (node->definition && !node->in_other_partition\n \t  && ((!DECL_EXTERNAL (node->decl) || node->alias)\n@@ -161,7 +161,7 @@ process_references (struct ipa_ref_list *list,\n static void\n walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n \t\t\t       struct cgraph_edge *edge,\n-\t\t\t       symtab_node *first,\n+\t\t\t       symtab_node **first,\n \t\t\t       pointer_set_t *reachable, bool before_inlining_p)\n {\n   unsigned int i;\n@@ -287,7 +287,7 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n bool\n symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n {\n-  symtab_node first = (symtab_node) (void *) 1;\n+  symtab_node *first = (symtab_node *) (void *) 1;\n   struct cgraph_node *node, *next;\n   struct varpool_node *vnode, *vnext;\n   bool changed = false;\n@@ -339,12 +339,12 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       }\n \n   /* Perform reachability analysis.  */\n-  while (first != (symtab_node) (void *) 1)\n+  while (first != (symtab_node *) (void *) 1)\n     {\n       bool in_boundary_p = !pointer_set_contains (reachable, first);\n-      symtab_node node = first;\n+      symtab_node *node = first;\n \n-      first = (symtab_node)first->aux;\n+      first = (symtab_node *)first->aux;\n \n       /* If we are processing symbol in boundary, mark its AUX pointer for\n \t possible later re-processing in enqueue_node.  */\n@@ -363,7 +363,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t     all other in the same comdat group to be also reachable.  */\n \t  if (node->same_comdat_group)\n \t    {\n-\t      symtab_node next;\n+\t      symtab_node *next;\n \t      for (next = node->same_comdat_group;\n \t\t   next != node;\n \t\t   next = next->same_comdat_group)\n@@ -640,7 +640,7 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \n /* Return true when there is a reference to node and it is not vtable.  */\n static bool\n-address_taken_from_non_vtable_p (symtab_node node)\n+address_taken_from_non_vtable_p (symtab_node *node)\n {\n   int i;\n   struct ipa_ref *ref;\n@@ -661,7 +661,7 @@ address_taken_from_non_vtable_p (symtab_node node)\n /* A helper for comdat_can_be_unshared_p.  */\n \n static bool\n-comdat_can_be_unshared_p_1 (symtab_node node)\n+comdat_can_be_unshared_p_1 (symtab_node *node)\n {\n   /* When address is taken, we don't know if equality comparison won't\n      break eventually. Exception are virutal functions, C++\n@@ -704,13 +704,13 @@ comdat_can_be_unshared_p_1 (symtab_node node)\n    but in C++ there is no way to compare their addresses for equality.  */\n \n static bool\n-comdat_can_be_unshared_p (symtab_node node)\n+comdat_can_be_unshared_p (symtab_node *node)\n {\n   if (!comdat_can_be_unshared_p_1 (node))\n     return false;\n   if (node->same_comdat_group)\n     {\n-      symtab_node next;\n+      symtab_node *next;\n \n       /* If more than one function is in the same COMDAT group, it must\n          be shared even if just one function in the comdat group has\n@@ -859,7 +859,7 @@ varpool_externally_visible_p (struct varpool_node *vnode)\n  */\n \n bool\n-can_replace_by_local_alias (symtab_node node)\n+can_replace_by_local_alias (symtab_node *node)\n {\n   return (symtab_node_availability (node) > AVAIL_OVERWRITABLE\n \t  && !symtab_can_be_discarded (node));\n@@ -919,7 +919,7 @@ function_and_variable_visibility (bool whole_program)\n       if (node->same_comdat_group && DECL_EXTERNAL (node->decl))\n \t{\n #ifdef ENABLE_CHECKING\n-\t  symtab_node n;\n+\t  symtab_node *n;\n \n \t  for (n = node->same_comdat_group;\n \t       n != node;"}, {"sha": "c47d10f20f47fe1d1e4646319f9f2191b23fb317", "filename": "gcc/is-a.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fis-a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fis-a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fis-a.h?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -31,7 +31,7 @@ bool is_a <TYPE> (pointer)\n \n     Tests whether the pointer actually points to a more derived TYPE.\n \n-    Suppose you have a symtab_node_base *ptr, AKA symtab_node ptr.  You can test\n+    Suppose you have a symtab_node *ptr, AKA symtab_node *ptr.  You can test\n     whether it points to a 'derived' cgraph_node as follows.\n \n       if (is_a <cgraph_node> (ptr))\n@@ -110,7 +110,7 @@ example,\n   template <>\n   template <>\n   inline bool\n-  is_a_helper <cgraph_node>::test (symtab_node_base *p)\n+  is_a_helper <cgraph_node>::test (symtab_node *p)\n   {\n     return p->type == SYMTAB_FUNCTION;\n   }\n@@ -122,7 +122,7 @@ when needed may result in a crash.  For example,\n   template <>\n   template <>\n   inline bool\n-  is_a_helper <cgraph_node>::cast (symtab_node_base *p)\n+  is_a_helper <cgraph_node>::cast (symtab_node *p)\n   {\n     return &p->x_function;\n   }"}, {"sha": "6a52da8a66252579b572b77941903f01dc9df206", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -52,7 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n \n static void output_cgraph_opt_summary (void);\n-static void input_cgraph_opt_summary (vec<symtab_node>  nodes);\n+static void input_cgraph_opt_summary (vec<symtab_node *>  nodes);\n \n /* Number of LDPR values known to GCC.  */\n #define LDPR_NUM_KNOWN (LDPR_PREVAILING_DEF_IRONLY_EXP + 1)\n@@ -111,7 +111,7 @@ lto_symtab_encoder_delete (lto_symtab_encoder_t encoder)\n \n int\n lto_symtab_encoder_encode (lto_symtab_encoder_t encoder,\n-\t\t\t   symtab_node node)\n+\t\t\t   symtab_node *node)\n {\n   int ref;\n   void **slot;\n@@ -145,7 +145,7 @@ lto_symtab_encoder_encode (lto_symtab_encoder_t encoder,\n \n bool\n lto_symtab_encoder_delete_node (lto_symtab_encoder_t encoder,\n-\t\t\t        symtab_node node)\n+\t\t\t        symtab_node *node)\n {\n   void **slot, **last_slot;\n   int index;\n@@ -224,7 +224,7 @@ lto_set_symtab_encoder_encode_initializer (lto_symtab_encoder_t encoder,\n \n bool\n lto_symtab_encoder_in_partition_p (lto_symtab_encoder_t encoder,\n-\t\t\t\t   symtab_node node)\n+\t\t\t\t   symtab_node *node)\n {\n   int index = lto_symtab_encoder_lookup (encoder, node);\n   if (index == LCC_NOT_FOUND)\n@@ -236,7 +236,7 @@ lto_symtab_encoder_in_partition_p (lto_symtab_encoder_t encoder,\n \n void\n lto_set_symtab_encoder_in_partition (lto_symtab_encoder_t encoder,\n-\t\t\t\t     symtab_node node)\n+\t\t\t\t     symtab_node *node)\n {\n   int index = lto_symtab_encoder_encode (encoder, node);\n   encoder->nodes[index].in_partition = true;\n@@ -703,7 +703,7 @@ output_refs (lto_symtab_encoder_t encoder)\n   for (lsei = lsei_start_in_partition (encoder); !lsei_end_p (lsei);\n        lsei_next_in_partition (&lsei))\n     {\n-      symtab_node node = lsei_node (lsei);\n+      symtab_node *node = lsei_node (lsei);\n \n       count = ipa_ref_list_nreferences (&node->ref_list);\n       if (count)\n@@ -810,7 +810,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n      pickle those too.  */\n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      symtab_node node = lto_symtab_encoder_deref (encoder, i);\n+      symtab_node *node = lto_symtab_encoder_deref (encoder, i);\n       if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n \t{\n \t  if (!lto_symtab_encoder_encode_initializer_p (encoder,\n@@ -905,7 +905,7 @@ output_symtab (void)\n   n_nodes = lto_symtab_encoder_size (encoder);\n   for (i = 0; i < n_nodes; i++)\n     {\n-      symtab_node node = lto_symtab_encoder_deref (encoder, i);\n+      symtab_node *node = lto_symtab_encoder_deref (encoder, i);\n       if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n         lto_output_node (ob, cnode, encoder);\n       else\n@@ -1011,7 +1011,7 @@ static struct cgraph_node *\n input_node (struct lto_file_decl_data *file_data,\n \t    struct lto_input_block *ib,\n \t    enum LTO_symtab_tags tag,\n-\t    vec<symtab_node> nodes)\n+\t    vec<symtab_node *> nodes)\n {\n   gcc::pass_manager *passes = g->get_passes ();\n   tree fn_decl;\n@@ -1084,7 +1084,7 @@ input_node (struct lto_file_decl_data *file_data,\n   node->global.inlined_to = (cgraph_node_ptr) (intptr_t) ref;\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n-  node->same_comdat_group = (symtab_node) (intptr_t) ref2;\n+  node->same_comdat_group = (symtab_node *) (intptr_t) ref2;\n \n   if (node->thunk.thunk_p)\n     {\n@@ -1153,7 +1153,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n     node->alias_target = get_alias_symbol (node->decl);\n   ref = streamer_read_hwi (ib);\n   /* Store a reference for now, and fix up later to be a pointer.  */\n-  node->same_comdat_group = (symtab_node) (intptr_t) ref;\n+  node->same_comdat_group = (symtab_node *) (intptr_t) ref;\n   node->resolution = streamer_read_enum (ib, ld_plugin_symbol_resolution,\n \t\t\t\t\t        LDPR_NUM_KNOWN);\n \n@@ -1165,10 +1165,10 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n \n static void\n input_ref (struct lto_input_block *ib,\n-\t   symtab_node referring_node,\n-\t   vec<symtab_node> nodes)\n+\t   symtab_node *referring_node,\n+\t   vec<symtab_node *> nodes)\n {\n-  symtab_node node = NULL;\n+  symtab_node *node = NULL;\n   struct bitpack_d bp;\n   enum ipa_ref_use use;\n   bool speculative;\n@@ -1190,7 +1190,7 @@ input_ref (struct lto_input_block *ib,\n    indirect_unknown_callee set).  */\n \n static void\n-input_edge (struct lto_input_block *ib, vec<symtab_node> nodes,\n+input_edge (struct lto_input_block *ib, vec<symtab_node *> nodes,\n \t    bool indirect)\n {\n   struct cgraph_node *caller, *callee;\n@@ -1257,13 +1257,13 @@ input_edge (struct lto_input_block *ib, vec<symtab_node> nodes,\n \n /* Read a cgraph from IB using the info in FILE_DATA.  */\n \n-static vec<symtab_node> \n+static vec<symtab_node *> \n input_cgraph_1 (struct lto_file_decl_data *file_data,\n \t\tstruct lto_input_block *ib)\n {\n   enum LTO_symtab_tags tag;\n-  vec<symtab_node> nodes = vNULL;\n-  symtab_node node;\n+  vec<symtab_node *> nodes = vNULL;\n+  symtab_node *node;\n   unsigned i;\n \n   tag = streamer_read_enum (ib, LTO_symtab_tags, LTO_symtab_last_tag);\n@@ -1335,13 +1335,13 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \n static void\n input_refs (struct lto_input_block *ib,\n-\t    vec<symtab_node> nodes)\n+\t    vec<symtab_node *> nodes)\n {\n   int count;\n   int idx;\n   while (true)\n     {\n-      symtab_node node;\n+      symtab_node *node;\n       count = streamer_read_uhwi (ib);\n       if (!count)\n \tbreak;\n@@ -1545,7 +1545,7 @@ input_symtab (void)\n       const char *data;\n       size_t len;\n       struct lto_input_block *ib;\n-      vec<symtab_node> nodes;\n+      vec<symtab_node *> nodes;\n \n       ib = lto_create_simple_input_block (file_data, LTO_section_symtab_nodes,\n \t\t\t\t\t  &data, &len);\n@@ -1676,15 +1676,15 @@ output_cgraph_opt_summary (void)\n   n_nodes = lto_symtab_encoder_size (encoder);\n   for (i = 0; i < n_nodes; i++)\n     {\n-      symtab_node node = lto_symtab_encoder_deref (encoder, i);\n+      symtab_node *node = lto_symtab_encoder_deref (encoder, i);\n       cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n       if (cnode && output_cgraph_opt_summary_p (cnode))\n \tcount++;\n     }\n   streamer_write_uhwi (ob, count);\n   for (i = 0; i < n_nodes; i++)\n     {\n-      symtab_node node = lto_symtab_encoder_deref (encoder, i);\n+      symtab_node *node = lto_symtab_encoder_deref (encoder, i);\n       cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n       if (cnode && output_cgraph_opt_summary_p (cnode))\n \t{\n@@ -1757,7 +1757,7 @@ input_node_opt_summary (struct cgraph_node *node,\n static void\n input_cgraph_opt_section (struct lto_file_decl_data *file_data,\n \t\t\t  const char *data, size_t len,\n-\t\t\t  vec<symtab_node> nodes)\n+\t\t\t  vec<symtab_node *> nodes)\n {\n   const struct lto_function_header *header =\n     (const struct lto_function_header *) data;\n@@ -1791,7 +1791,7 @@ input_cgraph_opt_section (struct lto_file_decl_data *file_data,\n /* Input optimization summary of cgraph.  */\n \n static void\n-input_cgraph_opt_summary (vec<symtab_node> nodes)\n+input_cgraph_opt_summary (vec<symtab_node *> nodes)\n {\n   struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n   struct lto_file_decl_data *file_data;"}, {"sha": "e4f0aedfa0f7415f2dc4473d077d4d37a3736965", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -428,7 +428,7 @@ lto_free_function_in_decl_state (struct lto_in_decl_state *state)\n    release trees needed by the NODE's body.  */\n \n void\n-lto_free_function_in_decl_state_for_node (symtab_node node)\n+lto_free_function_in_decl_state_for_node (symtab_node *node)\n {\n   struct lto_in_decl_state temp;\n   void **slot;"}, {"sha": "55186234d8ca5133cfed439779d248bb07118a00", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -1982,7 +1982,7 @@ lto_output (void)\n   /* Process only the functions with bodies.  */\n   for (i = 0; i < n_nodes; i++)\n     {\n-      symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n       cgraph_node *node = dyn_cast <cgraph_node> (snode);\n       if (node\n \t  && lto_symtab_encoder_encode_body_p (encoder, node)\n@@ -2290,7 +2290,7 @@ write_symbol (struct streamer_tree_cache_d *cache,\n /* Return true if NODE should appear in the plugin symbol table.  */\n \n bool\n-output_symbol_p (symtab_node node)\n+output_symbol_p (symtab_node *node)\n {\n   struct cgraph_node *cnode;\n   if (!symtab_real_symbol_p (node))\n@@ -2352,7 +2352,7 @@ produce_symtab (struct output_block *ob)\n   for (lsei = lsei_start (encoder);\n        !lsei_end_p (lsei); lsei_next (&lsei))\n     {\n-      symtab_node node = lsei_node (lsei);\n+      symtab_node *node = lsei_node (lsei);\n \n       if (!output_symbol_p (node) || DECL_EXTERNAL (node->decl))\n \tcontinue;\n@@ -2361,7 +2361,7 @@ produce_symtab (struct output_block *ob)\n   for (lsei = lsei_start (encoder);\n        !lsei_end_p (lsei); lsei_next (&lsei))\n     {\n-      symtab_node node = lsei_node (lsei);\n+      symtab_node *node = lsei_node (lsei);\n \n       if (!output_symbol_p (node) || !DECL_EXTERNAL (node->decl))\n \tcontinue;"}, {"sha": "797e92e335bd49e905991f91b7bca50bd5246a9a", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -430,7 +430,7 @@ struct lto_stats_d\n /* Entry of LTO symtab encoder.  */\n typedef struct\n {\n-  symtab_node node;\n+  symtab_node *node;\n   /* Is the node in this partition (i.e. ltrans of this partition will\n      be responsible for outputting it)? */\n   unsigned int in_partition:1;\n@@ -773,7 +773,7 @@ extern int lto_eq_in_decl_state (const void *, const void *);\n extern struct lto_in_decl_state *lto_get_function_in_decl_state (\n \t\t\t\t      struct lto_file_decl_data *, tree);\n extern void lto_free_function_in_decl_state (struct lto_in_decl_state *);\n-extern void lto_free_function_in_decl_state_for_node (symtab_node);\n+extern void lto_free_function_in_decl_state_for_node (symtab_node *);\n extern void lto_section_overrun (struct lto_input_block *) ATTRIBUTE_NORETURN;\n extern void lto_value_range_error (const char *,\n \t\t\t\t   HOST_WIDE_INT, HOST_WIDE_INT,\n@@ -872,15 +872,15 @@ void lto_output_location (struct output_block *, struct bitpack_d *, location_t)\n \n /* In lto-cgraph.c  */\n lto_symtab_encoder_t lto_symtab_encoder_new (bool);\n-int lto_symtab_encoder_encode (lto_symtab_encoder_t, symtab_node);\n+int lto_symtab_encoder_encode (lto_symtab_encoder_t, symtab_node *);\n void lto_symtab_encoder_delete (lto_symtab_encoder_t);\n-bool lto_symtab_encoder_delete_node (lto_symtab_encoder_t, symtab_node);\n+bool lto_symtab_encoder_delete_node (lto_symtab_encoder_t, symtab_node *);\n bool lto_symtab_encoder_encode_body_p (lto_symtab_encoder_t,\n \t\t\t\t       struct cgraph_node *);\n bool lto_symtab_encoder_in_partition_p (lto_symtab_encoder_t,\n-\t\t\t\t\tsymtab_node);\n+\t\t\t\t\tsymtab_node *);\n void lto_set_symtab_encoder_in_partition (lto_symtab_encoder_t,\n-\t\t\t\t\t  symtab_node);\n+\t\t\t\t\t  symtab_node *);\n \n bool lto_symtab_encoder_encode_initializer_p (lto_symtab_encoder_t,\n \t\t\t\t\t      struct varpool_node *);\n@@ -1043,7 +1043,7 @@ lto_symtab_encoder_size (lto_symtab_encoder_t encoder)\n \n static inline int\n lto_symtab_encoder_lookup (lto_symtab_encoder_t encoder,\n-\t\t\t   symtab_node node)\n+\t\t\t   symtab_node *node)\n {\n   void **slot = pointer_map_contains (encoder->map, node);\n   return (slot && *slot ? (size_t) *(slot) - 1 : LCC_NOT_FOUND);\n@@ -1064,7 +1064,7 @@ lsei_next (lto_symtab_encoder_iterator *lsei)\n }\n \n /* Return the node pointed to by LSI.  */\n-static inline symtab_node\n+static inline symtab_node *\n lsei_node (lto_symtab_encoder_iterator lsei)\n {\n   return lsei.encoder->nodes[lsei.index].node;\n@@ -1086,7 +1086,7 @@ lsei_varpool_node (lto_symtab_encoder_iterator lsei)\n \n /* Return the cgraph node corresponding to REF using ENCODER.  */\n \n-static inline symtab_node\n+static inline symtab_node *\n lto_symtab_encoder_deref (lto_symtab_encoder_t encoder, int ref)\n {\n   if (ref == LCC_NOT_FOUND)"}, {"sha": "b3bed0b39210571d0813b47279f7b3c3e8cd73f6", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -1,3 +1,42 @@\n+2013-10-31  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tAutomated part of renaming of symtab_node_base to symtab_node.\n+\n+\tPatch autogenerated by rename_symtab.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n+\n+\t* lto-partition.c (add_symbol_to_partition): Rename\n+\tsymtab_node_base to symtab_node.\n+\t(get_symbol_class): Likewise.\n+\t(symbol_partitioned_p): Likewise.\n+\t(add_references_to_partition): Likewise.\n+\t(add_symbol_to_partition_1): Likewise.\n+\t(contained_in_symbol): Likewise.\n+\t(add_symbol_to_partition): Likewise.\n+\t(lto_1_to_1_map): Likewise.\n+\t(lto_max_map): Likewise.\n+\t(lto_balanced_map): Likewise.\n+\t(privatize_symbol_name): Likewise.\n+\t(promote_symbol): Likewise.\n+\t(may_need_named_section_p): Likewise.\n+\t(rename_statics): Likewise.\n+\t(lto_promote_statics_nonwpa): Likewise.\n+\t* lto-symtab.c (lto_symtab_merge): Likewise.\n+\t(lto_symtab_resolve_replaceable_p): Likewise.\n+\t(lto_symtab_symbol_p): Likewise.\n+\t(lto_symtab_resolve_can_prevail_p): Likewise.\n+\t(lto_symtab_resolve_symbols): Likewise.\n+\t(lto_symtab_merge_decls_2): Likewise.\n+\t(lto_symtab_merge_decls_1): Likewise.\n+\t(lto_symtab_merge_decls): Likewise.\n+\t(lto_symtab_merge_symbols_1): Likewise.\n+\t(lto_symtab_merge_symbols): Likewise.\n+\t(lto_symtab_prevailing_decl): Likewise.\n+\t* lto.c (lto_wpa_write_files): Likewise.\n+\t(read_cgraph_and_symbols): Likewise.\n+\t(do_whole_program_analysis): Likewise.\n+\n 2013-10-30  David Malcolm  <dmalcolm@redhat.com>\n \n \t* lto-symtab.c (lto_symtab_merge_decls_2): Split symtab_node"}, {"sha": "6a3d881acca2a3530126c370459dda7e87e305aa", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -47,12 +47,12 @@ enum symbol_class\n \n vec<ltrans_partition> ltrans_partitions;\n \n-static void add_symbol_to_partition (ltrans_partition part, symtab_node node);\n+static void add_symbol_to_partition (ltrans_partition part, symtab_node *node);\n \n /* Classify symbol NODE.  */\n \n enum symbol_class\n-get_symbol_class (symtab_node node)\n+get_symbol_class (symtab_node *node)\n {\n   /* Inline clones are always duplicated.\n      This include external delcarations.   */\n@@ -131,14 +131,14 @@ free_ltrans_partitions (void)\n /* Return true if symbol is already in some partition.  */\n \n static inline bool\n-symbol_partitioned_p (symtab_node node)\n+symbol_partitioned_p (symtab_node *node)\n {\n   return node->aux;\n }\n \n /* Add references into the partition.  */\n static void\n-add_references_to_partition (ltrans_partition part, symtab_node node)\n+add_references_to_partition (ltrans_partition part, symtab_node *node)\n {\n   int i;\n   struct ipa_ref *ref;\n@@ -165,12 +165,12 @@ add_references_to_partition (ltrans_partition part, symtab_node node)\n    of adding NODE to PART.  */\n \n static bool\n-add_symbol_to_partition_1 (ltrans_partition part, symtab_node node)\n+add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n {\n   enum symbol_class c = get_symbol_class (node);\n   int i;\n   struct ipa_ref *ref;\n-  symtab_node node1;\n+  symtab_node *node1;\n \n   /* If NODE is already there, we have nothing to do.  */\n   if (lto_symtab_encoder_in_partition_p (part->encoder, node))\n@@ -241,8 +241,8 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node node)\n    internal label, thunk, alias or so), return the outer symbol. \n    When add_symbol_to_partition_1 is called on the outer symbol it must\n    eventually add NODE, too.  */\n-static symtab_node\n-contained_in_symbol (symtab_node node)\n+static symtab_node *\n+contained_in_symbol (symtab_node *node)\n {\n   /* Weakrefs are never contained in anything.  */\n   if (node->weakref)\n@@ -263,9 +263,9 @@ contained_in_symbol (symtab_node node)\n    of other symbol definition, add the other symbol, too.  */\n \n static void\n-add_symbol_to_partition (ltrans_partition part, symtab_node node)\n+add_symbol_to_partition (ltrans_partition part, symtab_node *node)\n {\n-  symtab_node node1;\n+  symtab_node *node1;\n \n   /* Verify that we do not try to duplicate something that can not be.  */\n   gcc_checking_assert (get_symbol_class (node) == SYMBOL_DUPLICATE\n@@ -294,7 +294,7 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n {\n   while (lto_symtab_encoder_size (partition->encoder) > (int)n_nodes)\n     {\n-      symtab_node node = lto_symtab_encoder_deref (partition->encoder,\n+      symtab_node *node = lto_symtab_encoder_deref (partition->encoder,\n \t\t\t\t\t\t   n_nodes);\n \n       /* After UNDO we no longer know what was visited.  */\n@@ -315,7 +315,7 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n void\n lto_1_to_1_map (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   struct lto_file_decl_data *file_data;\n   struct pointer_map_t *pmap;\n   ltrans_partition partition;\n@@ -372,7 +372,7 @@ lto_1_to_1_map (void)\n void\n lto_max_map (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   ltrans_partition partition;\n   int npartitions = 0;\n \n@@ -545,7 +545,7 @@ lto_balanced_map (void)\n \t  struct ipa_ref_list *refs;\n \t  int j;\n \t  struct ipa_ref *ref;\n-\t  symtab_node snode = lto_symtab_encoder_deref (partition->encoder,\n+\t  symtab_node *snode = lto_symtab_encoder_deref (partition->encoder,\n \t\t\t\t\t\t\tlast_visited_node);\n \n \t  if (cgraph_node *node = dyn_cast <cgraph_node> (snode))\n@@ -763,7 +763,7 @@ lto_balanced_map (void)\n */\n \n static bool\n-privatize_symbol_name (symtab_node node)\n+privatize_symbol_name (symtab_node *node)\n {\n   tree decl = node->decl;\n   const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n@@ -806,7 +806,7 @@ privatize_symbol_name (symtab_node node)\n /* Promote variable VNODE to be static.  */\n \n static void\n-promote_symbol (symtab_node node)\n+promote_symbol (symtab_node *node)\n {\n   /* We already promoted ... */\n   if (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n@@ -832,7 +832,7 @@ promote_symbol (symtab_node node)\n    FIXME: we should really not use named sections for inline clones and master clones.  */\n \n static bool\n-may_need_named_section_p (lto_symtab_encoder_t encoder, symtab_node node)\n+may_need_named_section_p (lto_symtab_encoder_t encoder, symtab_node *node)\n {\n   struct cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n   if (!cnode)\n@@ -852,10 +852,10 @@ may_need_named_section_p (lto_symtab_encoder_t encoder, symtab_node node)\n    asm statemnets referring to them by symbol name.  */\n \n static void\n-rename_statics (lto_symtab_encoder_t encoder, symtab_node node)\n+rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)\n {\n   tree decl = node->decl;\n-  symtab_node s;\n+  symtab_node *s;\n   tree name = DECL_ASSEMBLER_NAME (decl);\n \n   /* See if this is static symbol. */\n@@ -935,7 +935,7 @@ lto_promote_cross_file_statics (void)\n       for (lsei = lsei_start (encoder); !lsei_end_p (lsei);\n \t   lsei_next (&lsei))\n         {\n-          symtab_node node = lsei_node (lsei);\n+          symtab_node *node = lsei_node (lsei);\n \n \t  /* If symbol is static, rename it if its assembler name clash with\n \t     anything else in this unit.  */\n@@ -961,7 +961,7 @@ lto_promote_cross_file_statics (void)\n void\n lto_promote_statics_nonwpa (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   FOR_EACH_SYMBOL (node)\n     rename_statics (NULL, node);\n }"}, {"sha": "ced6cf9790834f5cd0d936ea8450b0609494a3d4", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -113,7 +113,7 @@ lto_varpool_replace_node (struct varpool_node *vnode,\n    should be emitted.  */\n \n static bool\n-lto_symtab_merge (symtab_node prevailing, symtab_node entry)\n+lto_symtab_merge (symtab_node *prevailing, symtab_node *entry)\n {\n   tree prevailing_decl = prevailing->decl;\n   tree decl = entry->decl;\n@@ -216,7 +216,7 @@ lto_symtab_merge (symtab_node prevailing, symtab_node entry)\n    entry.  */\n \n static bool\n-lto_symtab_resolve_replaceable_p (symtab_node e)\n+lto_symtab_resolve_replaceable_p (symtab_node *e)\n {\n   if (DECL_EXTERNAL (e->decl)\n       || DECL_COMDAT (e->decl)\n@@ -236,7 +236,7 @@ lto_symtab_resolve_replaceable_p (symtab_node e)\n    handle renaming of static later in partitioning).  */\n \n static bool\n-lto_symtab_symbol_p (symtab_node e)\n+lto_symtab_symbol_p (symtab_node *e)\n {\n   if (!TREE_PUBLIC (e->decl) && !DECL_EXTERNAL (e->decl))\n     return false;\n@@ -246,7 +246,7 @@ lto_symtab_symbol_p (symtab_node e)\n /* Return true if the symtab entry E can be the prevailing one.  */\n \n static bool\n-lto_symtab_resolve_can_prevail_p (symtab_node e)\n+lto_symtab_resolve_can_prevail_p (symtab_node *e)\n {\n   if (!lto_symtab_symbol_p (e))\n     return false;\n@@ -263,11 +263,11 @@ lto_symtab_resolve_can_prevail_p (symtab_node e)\n /* Resolve the symbol with the candidates in the chain *SLOT and store\n    their resolutions.  */\n \n-static symtab_node\n-lto_symtab_resolve_symbols (symtab_node first)\n+static symtab_node *\n+lto_symtab_resolve_symbols (symtab_node *first)\n {\n-  symtab_node e;\n-  symtab_node prevailing = NULL;\n+  symtab_node *e;\n+  symtab_node *prevailing = NULL;\n \n   /* Always set e->node so that edges are updated to reflect decl merging. */\n   for (e = first; e; e = e->next_sharing_asm_name)\n@@ -359,10 +359,10 @@ lto_symtab_resolve_symbols (symtab_node first)\n    do not issue further diagnostics.*/\n \n static void\n-lto_symtab_merge_decls_2 (symtab_node first, bool diagnosed_p)\n+lto_symtab_merge_decls_2 (symtab_node *first, bool diagnosed_p)\n {\n-  symtab_node prevailing;\n-  symtab_node e;\n+  symtab_node *prevailing;\n+  symtab_node *e;\n   vec<tree> mismatches = vNULL;\n   unsigned i;\n   tree decl;\n@@ -412,10 +412,10 @@ lto_symtab_merge_decls_2 (symtab_node first, bool diagnosed_p)\n /* Helper to process the decl chain for the symbol table entry *SLOT.  */\n \n static void\n-lto_symtab_merge_decls_1 (symtab_node first)\n+lto_symtab_merge_decls_1 (symtab_node *first)\n {\n-  symtab_node e;\n-  symtab_node prevailing;\n+  symtab_node *e;\n+  symtab_node *prevailing;\n   bool diagnosed_p = false;\n \n   if (cgraph_dump_file)\n@@ -522,7 +522,7 @@ lto_symtab_merge_decls_1 (symtab_node first)\n void\n lto_symtab_merge_decls (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n \n   /* Populate assembler name hash.   */\n   symtab_initialize_asm_name_hash ();\n@@ -536,10 +536,10 @@ lto_symtab_merge_decls (void)\n /* Helper to process the decl chain for the symbol table entry *SLOT.  */\n \n static void\n-lto_symtab_merge_symbols_1 (symtab_node prevailing)\n+lto_symtab_merge_symbols_1 (symtab_node *prevailing)\n {\n-  symtab_node e;\n-  symtab_node next;\n+  symtab_node *e;\n+  symtab_node *next;\n \n   /* Replace the cgraph node of each entry with the prevailing one.  */\n   for (e = prevailing->next_sharing_asm_name; e;\n@@ -565,7 +565,7 @@ lto_symtab_merge_symbols_1 (symtab_node prevailing)\n void\n lto_symtab_merge_symbols (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n \n   if (!flag_ltrans)\n     {\n@@ -587,11 +587,11 @@ lto_symtab_merge_symbols (void)\n \t{\n \t  cgraph_node *cnode, *cnode2;\n \t  varpool_node *vnode;\n-\t  symtab_node node2;\n+\t  symtab_node *node2;\n \n \t  if (!node->analyzed && node->alias_target)\n \t    {\n-\t      symtab_node tgt = symtab_node_for_asm (node->alias_target);\n+\t      symtab_node *tgt = symtab_node_for_asm (node->alias_target);\n \t      gcc_assert (node->weakref);\n \t      if (tgt)\n \t\tsymtab_resolve_alias (node, tgt);\n@@ -639,7 +639,7 @@ lto_symtab_merge_symbols (void)\n tree\n lto_symtab_prevailing_decl (tree decl)\n {\n-  symtab_node ret;\n+  symtab_node *ret;\n \n   /* Builtins and local symbols are their own prevailing decl.  */\n   if ((!TREE_PUBLIC (decl) && !DECL_EXTERNAL (decl)) || is_builtin_fn (decl))"}, {"sha": "62856d085b7a6477d5ad5403f038c273c1c1ccdf", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -2479,14 +2479,14 @@ lto_wpa_write_files (void)\n \t  for (lsei = lsei_start_in_partition (part->encoder); !lsei_end_p (lsei);\n \t       lsei_next_in_partition (&lsei))\n \t    {\n-\t      symtab_node node = lsei_node (lsei);\n+\t      symtab_node *node = lsei_node (lsei);\n \t      fprintf (cgraph_dump_file, \"%s \", symtab_node_asm_name (node));\n \t    }\n \t  fprintf (cgraph_dump_file, \"\\n  Symbols in boundary: \");\n \t  for (lsei = lsei_start (part->encoder); !lsei_end_p (lsei);\n \t       lsei_next (&lsei))\n \t    {\n-\t      symtab_node node = lsei_node (lsei);\n+\t      symtab_node *node = lsei_node (lsei);\n \t      if (!lto_symtab_encoder_in_partition_p (part->encoder, node))\n \t\t{\n \t          fprintf (cgraph_dump_file, \"%s \", symtab_node_asm_name (node));\n@@ -2750,7 +2750,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   int count = 0;\n   struct lto_file_decl_data **decl_data;\n   void **res;\n-  symtab_node snode;\n+  symtab_node *snode;\n \n   init_cgraph ();\n \n@@ -3074,7 +3074,7 @@ print_lto_report_1 (void)\n static void\n do_whole_program_analysis (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n \n   timevar_start (TV_PHASE_OPT_GEN);\n "}, {"sha": "90924c3180365ffeec490914cb809199638bd4f8", "filename": "gcc/symtab.c", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -49,12 +49,12 @@ const char * const ld_plugin_symbol_resolution_names[]=\n };\n \n /* Hash table used to convert declarations into nodes.  */\n-static GTY((param_is (symtab_node_base))) htab_t symtab_hash;\n+static GTY((param_is (symtab_node))) htab_t symtab_hash;\n /* Hash table used to convert assembler names into nodes.  */\n-static GTY((param_is (symtab_node_base))) htab_t assembler_name_hash;\n+static GTY((param_is (symtab_node))) htab_t assembler_name_hash;\n \n /* Linked list of symbol table nodes.  */\n-symtab_node symtab_nodes;\n+symtab_node *symtab_nodes;\n \n /* The order index of the next symtab node to be created.  This is\n    used so that we can sort the cgraph nodes in order by when we saw\n@@ -66,7 +66,7 @@ int symtab_order;\n static hashval_t\n hash_node (const void *p)\n {\n-  const_symtab_node n = (const_symtab_node ) p;\n+  const symtab_node *n = (const symtab_node *) p;\n   return (hashval_t) DECL_UID (n->decl);\n }\n \n@@ -76,8 +76,8 @@ hash_node (const void *p)\n static int\n eq_node (const void *p1, const void *p2)\n {\n-  const_symtab_node n1 = (const_symtab_node) p1;\n-  const_symtab_node n2 = (const_symtab_node) p2;\n+  const symtab_node *n1 = (const symtab_node *) p1;\n+  const symtab_node *n2 = (const symtab_node *) p2;\n   return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n }\n \n@@ -86,7 +86,7 @@ eq_node (const void *p1, const void *p2)\n static hashval_t\n hash_node_by_assembler_name (const void *p)\n {\n-  const_symtab_node n = (const_symtab_node) p;\n+  const symtab_node *n = (const symtab_node *) p;\n   return (hashval_t) decl_assembler_name_hash (DECL_ASSEMBLER_NAME (n->decl));\n }\n \n@@ -95,15 +95,15 @@ hash_node_by_assembler_name (const void *p)\n static int\n eq_assembler_name (const void *p1, const void *p2)\n {\n-  const_symtab_node n1 = (const_symtab_node) p1;\n+  const symtab_node *n1 = (const symtab_node *) p1;\n   const_tree name = (const_tree)p2;\n   return (decl_assembler_name_equal (n1->decl, name));\n }\n \n /* Insert NODE to assembler name hash.  */\n \n static void\n-insert_to_assembler_name_hash (symtab_node node, bool with_clones)\n+insert_to_assembler_name_hash (symtab_node *node, bool with_clones)\n {\n   if (is_a <varpool_node> (node) && DECL_HARD_REGISTER (node->decl))\n     return;\n@@ -121,9 +121,9 @@ insert_to_assembler_name_hash (symtab_node node, bool with_clones)\n \t\t\t\t\tdecl_assembler_name_hash (name),\n \t\t\t\t\tINSERT);\n       gcc_assert (*aslot != node);\n-      node->next_sharing_asm_name = (symtab_node)*aslot;\n+      node->next_sharing_asm_name = (symtab_node *)*aslot;\n       if (*aslot != NULL)\n-\t((symtab_node)*aslot)->previous_sharing_asm_name = node;\n+\t((symtab_node *)*aslot)->previous_sharing_asm_name = node;\n       *aslot = node;\n \n       /* Update also possible inline clones sharing a decl.  */\n@@ -139,7 +139,7 @@ insert_to_assembler_name_hash (symtab_node node, bool with_clones)\n /* Remove NODE from assembler name hash.  */\n \n static void\n-unlink_from_assembler_name_hash (symtab_node node, bool with_clones)\n+unlink_from_assembler_name_hash (symtab_node *node, bool with_clones)\n {\n   if (assembler_name_hash)\n     {\n@@ -182,7 +182,7 @@ unlink_from_assembler_name_hash (symtab_node node, bool with_clones)\n /* Arrange node to be first in its entry of assembler_name_hash.  */\n \n void\n-symtab_prevail_in_asm_name_hash (symtab_node node)\n+symtab_prevail_in_asm_name_hash (symtab_node *node)\n {\n   unlink_from_assembler_name_hash (node, false);\n   insert_to_assembler_name_hash (node, false);\n@@ -193,10 +193,10 @@ symtab_prevail_in_asm_name_hash (symtab_node node)\n    cgraph/varpool node creation routines.  */\n \n void\n-symtab_register_node (symtab_node node)\n+symtab_register_node (symtab_node *node)\n {\n-  struct symtab_node_base key;\n-  symtab_node *slot;\n+  struct symtab_node key;\n+  symtab_node **slot;\n \n   node->next = symtab_nodes;\n   node->previous = NULL;\n@@ -207,7 +207,7 @@ symtab_register_node (symtab_node node)\n   if (!symtab_hash)\n     symtab_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n   key.decl = node->decl;\n-  slot = (symtab_node *) htab_find_slot (symtab_hash, &key, INSERT);\n+  slot = (symtab_node **) htab_find_slot (symtab_hash, &key, INSERT);\n   if (*slot == NULL)\n     *slot = node;\n \n@@ -224,31 +224,31 @@ symtab_register_node (symtab_node node)\n    of inline clones.  */\n \n void\n-symtab_insert_node_to_hashtable (symtab_node node)\n+symtab_insert_node_to_hashtable (symtab_node *node)\n {\n-  struct symtab_node_base key;\n-  symtab_node *slot;\n+  struct symtab_node key;\n+  symtab_node **slot;\n \n   if (!symtab_hash)\n     symtab_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n   key.decl = node->decl;\n-  slot = (symtab_node *) htab_find_slot (symtab_hash, &key, INSERT);\n+  slot = (symtab_node **) htab_find_slot (symtab_hash, &key, INSERT);\n   *slot = node;\n }\n \n /* Remove node from symbol table.  This function is not used directly, but via\n    cgraph/varpool node removal routines.  */\n \n void\n-symtab_unregister_node (symtab_node node)\n+symtab_unregister_node (symtab_node *node)\n {\n   void **slot;\n   ipa_remove_all_references (&node->ref_list);\n   ipa_remove_all_referring (&node->ref_list);\n \n   if (node->same_comdat_group)\n     {\n-      symtab_node prev;\n+      symtab_node *prev;\n       for (prev = node->same_comdat_group;\n \t   prev->same_comdat_group != node;\n \t   prev = prev->same_comdat_group)\n@@ -276,7 +276,7 @@ symtab_unregister_node (symtab_node node)\n   gcc_assert ((slot && *slot) || in_lto_p);\n   if (slot && *slot && *slot == node)\n     {\n-      symtab_node replacement_node = NULL;\n+      symtab_node *replacement_node = NULL;\n       if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n \treplacement_node = cgraph_find_replacement_node (cnode);\n       if (!replacement_node)\n@@ -291,11 +291,11 @@ symtab_unregister_node (symtab_node node)\n /* Return symbol table node associated with DECL, if any,\n    and NULL otherwise.  */\n \n-symtab_node\n+symtab_node *\n symtab_get_node (const_tree decl)\n {\n-  symtab_node *slot;\n-  struct symtab_node_base key;\n+  symtab_node **slot;\n+  struct symtab_node key;\n \n #ifdef ENABLE_CHECKING\n   /* Check that we are called for sane type of object - functions\n@@ -311,7 +311,7 @@ symtab_get_node (const_tree decl)\n \n   key.decl = CONST_CAST2 (tree, const_tree, decl);\n \n-  slot = (symtab_node *) htab_find_slot (symtab_hash, &key,\n+  slot = (symtab_node **) htab_find_slot (symtab_hash, &key,\n \t\t\t\t\t NO_INSERT);\n \n   if (slot)\n@@ -322,7 +322,7 @@ symtab_get_node (const_tree decl)\n /* Remove symtab NODE from the symbol table.  */\n \n void\n-symtab_remove_node (symtab_node node)\n+symtab_remove_node (symtab_node *node)\n {\n   if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n     cgraph_remove_node (cnode);\n@@ -335,7 +335,7 @@ symtab_remove_node (symtab_node node)\n void\n symtab_initialize_asm_name_hash (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   if (!assembler_name_hash)\n     {\n       assembler_name_hash =\n@@ -349,10 +349,10 @@ symtab_initialize_asm_name_hash (void)\n /* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n    Return NULL if there's no such node.  */\n \n-symtab_node\n+symtab_node *\n symtab_node_for_asm (const_tree asmname)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   void **slot;\n \n   symtab_initialize_asm_name_hash ();\n@@ -362,7 +362,7 @@ symtab_node_for_asm (const_tree asmname)\n \n   if (slot)\n     {\n-      node = (symtab_node) *slot;\n+      node = (symtab_node *) *slot;\n       return node;\n     }\n   return NULL;\n@@ -373,7 +373,7 @@ symtab_node_for_asm (const_tree asmname)\n void\n change_decl_assembler_name (tree decl, tree name)\n {\n-  symtab_node node = NULL;\n+  symtab_node *node = NULL;\n \n   /* We can have user ASM names on things, like global register variables, that\n      are not in the symbol table.  */\n@@ -415,8 +415,8 @@ change_decl_assembler_name (tree decl, tree name)\n /* Add NEW_ to the same comdat group that OLD is in.  */\n \n void\n-symtab_add_to_same_comdat_group (symtab_node new_node,\n-\t\t\t\t symtab_node old_node)\n+symtab_add_to_same_comdat_group (symtab_node *new_node,\n+\t\t\t\t symtab_node *old_node)\n {\n   gcc_assert (DECL_ONE_ONLY (old_node->decl));\n   gcc_assert (!new_node->same_comdat_group);\n@@ -428,7 +428,7 @@ symtab_add_to_same_comdat_group (symtab_node new_node,\n     old_node->same_comdat_group = new_node;\n   else\n     {\n-      symtab_node n;\n+      symtab_node *n;\n       for (n = old_node->same_comdat_group;\n \t   n->same_comdat_group != old_node;\n \t   n = n->same_comdat_group)\n@@ -440,10 +440,10 @@ symtab_add_to_same_comdat_group (symtab_node new_node,\n /* Dissolve the same_comdat_group list in which NODE resides.  */\n \n void\n-symtab_dissolve_same_comdat_group_list (symtab_node node)\n+symtab_dissolve_same_comdat_group_list (symtab_node *node)\n {\n-  symtab_node n = node;\n-  symtab_node next;\n+  symtab_node *n = node;\n+  symtab_node *next;\n \n   if (!node->same_comdat_group)\n     return;\n@@ -461,7 +461,7 @@ symtab_dissolve_same_comdat_group_list (symtab_node node)\n    is unknown go with identifier name.  */\n \n const char *\n-symtab_node_asm_name (symtab_node node)\n+symtab_node_asm_name (symtab_node *node)\n {\n   if (!DECL_ASSEMBLER_NAME_SET_P (node->decl))\n     return lang_hooks.decl_printable_name (node->decl, 2);\n@@ -471,7 +471,7 @@ symtab_node_asm_name (symtab_node node)\n /* Return printable identifier name.  */\n \n const char *\n-symtab_node_name (symtab_node node)\n+symtab_node_name (symtab_node *node)\n {\n   return lang_hooks.decl_printable_name (node->decl, 2);\n }\n@@ -481,7 +481,7 @@ static const char * const symtab_type_names[] = {\"symbol\", \"function\", \"variable\n /* Dump base fields of symtab nodes.  Not to be used directly.  */\n \n void\n-dump_symtab_base (FILE *f, symtab_node node)\n+dump_symtab_base (FILE *f, symtab_node *node)\n {\n   static const char * const visibility_types[] = {\n     \"default\", \"protected\", \"hidden\", \"internal\"\n@@ -595,7 +595,7 @@ dump_symtab_base (FILE *f, symtab_node node)\n /* Dump symtab node.  */\n \n void\n-dump_symtab_node (FILE *f, symtab_node node)\n+dump_symtab_node (FILE *f, symtab_node *node)\n {\n   if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n     dump_cgraph_node (f, cnode);\n@@ -608,7 +608,7 @@ dump_symtab_node (FILE *f, symtab_node node)\n void\n dump_symtab (FILE *f)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   fprintf (f, \"Symbol table:\\n\\n\");\n   FOR_EACH_SYMBOL (node)\n     dump_symtab_node (f, node);\n@@ -617,7 +617,7 @@ dump_symtab (FILE *f)\n /* Dump symtab node NODE to stderr.  */\n \n DEBUG_FUNCTION void\n-debug_symtab_node (symtab_node node)\n+debug_symtab_node (symtab_node *node)\n {\n   dump_symtab_node (stderr, node);\n }\n@@ -633,10 +633,10 @@ debug_symtab (void)\n /* Verify common part of symtab nodes.  */\n \n DEBUG_FUNCTION bool\n-verify_symtab_base (symtab_node node)\n+verify_symtab_base (symtab_node *node)\n {\n   bool error_found = false;\n-  symtab_node hashed_node;\n+  symtab_node *hashed_node;\n \n   if (is_a <cgraph_node> (node))\n     {\n@@ -729,7 +729,7 @@ verify_symtab_base (symtab_node node)\n     }\n   if (node->same_comdat_group)\n     {\n-      symtab_node n = node->same_comdat_group;\n+      symtab_node *n = node->same_comdat_group;\n \n       if (!DECL_ONE_ONLY (n->decl))\n \t{\n@@ -764,7 +764,7 @@ verify_symtab_base (symtab_node node)\n /* Verify consistency of NODE.  */\n \n DEBUG_FUNCTION void\n-verify_symtab_node (symtab_node node)\n+verify_symtab_node (symtab_node *node)\n {\n   if (seen_error ())\n     return;\n@@ -786,7 +786,7 @@ verify_symtab_node (symtab_node node)\n DEBUG_FUNCTION void\n verify_symtab (void)\n {\n-  symtab_node node;\n+  symtab_node *node;\n   FOR_EACH_SYMBOL (node)\n    verify_symtab_node (node);\n }\n@@ -807,7 +807,7 @@ resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)\n    Known only when doing LTO via linker plugin.  */\n \n bool\n-symtab_used_from_object_file_p (symtab_node node)\n+symtab_used_from_object_file_p (symtab_node *node)\n {\n   if (!TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl))\n     return false;\n@@ -859,7 +859,7 @@ symtab_make_decl_local (tree decl)\n /* Return availability of NODE.  */\n \n enum availability\n-symtab_node_availability (symtab_node node)\n+symtab_node_availability (symtab_node *node)\n {\n   if (is_a <cgraph_node> (node))\n     return cgraph_function_body_availability (cgraph (node));\n@@ -871,8 +871,8 @@ symtab_node_availability (symtab_node node)\n    If NODE is not an alias, return NODE.\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n-symtab_node\n-symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n+symtab_node *\n+symtab_alias_ultimate_target (symtab_node *node, enum availability *availability)\n {\n   bool weakref_p = false;\n \n@@ -947,7 +947,7 @@ symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n    copy the visibility from the target to get things right.  */\n \n void\n-fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target)\n+fixup_same_cpp_alias_visibility (symtab_node *node, symtab_node *target)\n {\n   if (is_a <cgraph_node> (node))\n     {\n@@ -983,9 +983,9 @@ fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target)\n    it returns false.  */\n \n bool\n-symtab_resolve_alias (symtab_node node, symtab_node target)\n+symtab_resolve_alias (symtab_node *node, symtab_node *target)\n {\n-  symtab_node n;\n+  symtab_node *n;\n \n   gcc_assert (!node->analyzed\n \t      && !vec_safe_length (node->ref_list.references));\n@@ -1031,8 +1031,8 @@ symtab_resolve_alias (symtab_node node, symtab_node target)\n    skipped. */\n \n bool\n-symtab_for_node_and_aliases (symtab_node node,\n-\t\t\t     bool (*callback) (symtab_node, void *),\n+symtab_for_node_and_aliases (symtab_node *node,\n+\t\t\t     bool (*callback) (symtab_node *, void *),\n \t\t\t     void *data,\n \t\t\t     bool include_overwritable)\n {\n@@ -1044,7 +1044,7 @@ symtab_for_node_and_aliases (symtab_node node,\n   for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tsymtab_node alias = ref->referring;\n+\tsymtab_node *alias = ref->referring;\n \tif (include_overwritable\n \t    || symtab_node_availability (alias) > AVAIL_OVERWRITABLE)\n           if (symtab_for_node_and_aliases (alias, callback, data,\n@@ -1057,11 +1057,11 @@ symtab_for_node_and_aliases (symtab_node node,\n /* Worker searching nonoverwritable alias.  */\n \n static bool\n-symtab_nonoverwritable_alias_1 (symtab_node node, void *data)\n+symtab_nonoverwritable_alias_1 (symtab_node *node, void *data)\n {\n   if (decl_binds_to_current_def_p (node->decl))\n     {\n-      *(symtab_node *)data = node;\n+      *(symtab_node **)data = node;\n       return true;\n     }\n   return false;\n@@ -1071,11 +1071,11 @@ symtab_nonoverwritable_alias_1 (symtab_node node, void *data)\n    definition, return NODE. Otherwise look for alias with such property and if\n    none exists, introduce new one.  */\n \n-symtab_node\n-symtab_nonoverwritable_alias (symtab_node node)\n+symtab_node *\n+symtab_nonoverwritable_alias (symtab_node *node)\n {\n   tree new_decl;\n-  symtab_node new_node = NULL;\n+  symtab_node *new_node = NULL;\n \n   /* First try to look up existing alias or base object\n      (if that is already non-overwritable).  */\n@@ -1126,12 +1126,12 @@ symtab_nonoverwritable_alias (symtab_node node)\n /* Return true if A and B represents semantically equivalent symbols.  */\n \n bool\n-symtab_semantically_equivalent_p (symtab_node a,\n-\t\t\t\t  symtab_node b)\n+symtab_semantically_equivalent_p (symtab_node *a,\n+\t\t\t\t  symtab_node *b)\n {\n   enum availability avail;\n-  symtab_node ba;\n-  symtab_node bb;\n+  symtab_node *ba;\n+  symtab_node *bb;\n \n   /* Equivalent functions are equivalent.  */\n   if (a->decl == b->decl)"}, {"sha": "0a9388285bb69b6515d76888f7b9155404b114dc", "filename": "gcc/value-prof.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -1209,8 +1209,8 @@ init_node_map (bool local)\n \t\t\t   n->profile_id,\n \t\t\t   cgraph_node_name (n),\n \t\t\t   n->order,\n-\t\t\t   symtab_node_name (*(symtab_node*)val),\n-\t\t\t   (*(symtab_node *)val)->order);\n+\t\t\t   symtab_node_name (*(symtab_node **)val),\n+\t\t\t   (*(symtab_node **)val)->order);\n \t\tn->profile_id = (n->profile_id + 1) & 0x7fffffff;\n \t      }\n \t  }"}, {"sha": "beafb558c9cc50b06429ac3470e132215a9197a5", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -5382,7 +5382,7 @@ weak_finish_1 (tree decl)\n static tree\n find_decl (tree target)\n {\n-  symtab_node node = symtab_node_for_asm (target);\n+  symtab_node *node = symtab_node_for_asm (target);\n   if (node)\n     return node->decl;\n   return NULL_TREE;"}, {"sha": "4f1658ea635894c4dace538e01c957cc8082459c", "filename": "gcc/varpool.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e20cdc96e65d712b5149af59e4580873d7928b7/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=5e20cdc96e65d712b5149af59e4580873d7928b7", "patch": "@@ -234,7 +234,7 @@ debug_varpool (void)\n struct varpool_node *\n varpool_node_for_asm (tree asmname)\n {\n-  if (symtab_node node = symtab_node_for_asm (asmname))\n+  if (symtab_node *node = symtab_node_for_asm (asmname))\n     return dyn_cast <varpool_node> (node);\n   else\n     return NULL;\n@@ -512,7 +512,7 @@ varpool_remove_unreferenced_decls (void)\n \n       if (node->same_comdat_group)\n \t{\n-\t  symtab_node next;\n+\t  symtab_node *next;\n \t  for (next = node->same_comdat_group;\n \t       next != node;\n \t       next = next->same_comdat_group)"}]}