{"sha": "99a593103f3c4665baccc27c935427e167a5cd83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlhNTkzMTAzZjNjNDY2NWJhY2NjMjdjOTM1NDI3ZTE2N2E1Y2Q4Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-25T23:06:57Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-25T23:06:57Z"}, "message": "(current_function_returns_real): Deleted (unused).\n\n(FP_mode_reg): Trimmed to a smaller size, less overhead.\n(FP_MODE_REG): New macro over which FP_mode_reg will be accessed.\n(mark_regs_pat, straighten_stack): New functions.\n(reg_to_stack): Amend initialisation of FP_mode_reg.\nMark FP registers mentioned in USE insns before NOTE_INSN_FUNCTION_BEG.\n(get_true_reg): Eliminate FP subreg accesses in favour of the actual FP\nregister in use.\n(record_reg_life_pat): Make it work on SUBREGs as well.  Make use of the new\nmark_regs_pat function.  Handle USE insns if called unnested.\n(record_reg_life): Don't check for QImode again, we know that it is there.\nProcess CALL_INSNs like all other insns, they might `use' some FP argument\nregisters if register passing.\n(stack_result_p): Changed in stack_result and returning an rtx.\n(stack_reg_life_analysis): Take a new stackentry state argument.\nUse stack_result and the rtx to mark using mark_regs_pat.  This ensures that\ntypes that need multiple FP registers are handled correctly\nDelete the no_live_regs shortcut to save space.\nUse stackentry state to determine filled registers.\n(replace_reg): Accept COMPLEX_FLOAT as well.\n(move_for_stack_reg): Optimise away some pointer dereferencing.\n(subst_stack_regs): Make sure the stack is in the right order and of the right\nsize for register passing.\n(goto_block_pat): Make sure the stack is in the right order to return possible\nmulti-register values from the function.\n(convert_regs): Fix comment about CALL_INSN, it's no longer valid.\nMake sure the stack is of the right size and in the right order to return\npossible multi-register values from the function.\n\nFrom-SVN: r9459", "tree": {"sha": "07e2e31b8acac457b6f22931a37ac1e81d4703d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07e2e31b8acac457b6f22931a37ac1e81d4703d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99a593103f3c4665baccc27c935427e167a5cd83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99a593103f3c4665baccc27c935427e167a5cd83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99a593103f3c4665baccc27c935427e167a5cd83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99a593103f3c4665baccc27c935427e167a5cd83/comments", "author": null, "committer": null, "parents": [{"sha": "f365e8f67311ac607a0f6045f8fd7f991c2d1060", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f365e8f67311ac607a0f6045f8fd7f991c2d1060", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f365e8f67311ac607a0f6045f8fd7f991c2d1060"}], "stats": {"total": 477, "additions": 302, "deletions": 175}, "files": [{"sha": "8dc4e75644f0959cadcd589b127358a088ffca36", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 302, "deletions": 175, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99a593103f3c4665baccc27c935427e167a5cd83/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99a593103f3c4665baccc27c935427e167a5cd83/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=99a593103f3c4665baccc27c935427e167a5cd83", "patch": "@@ -169,9 +169,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define REG_STACK_SIZE (LAST_STACK_REG - FIRST_STACK_REG + 1)\n \n-/* True if the current function returns a real value. */\n-static int current_function_returns_real;\n-\n /* This is the basic stack record.  TOP is an index into REG[] such\n    that REG[TOP] is the top of stack.  If TOP is -1 the stack is empty.\n \n@@ -219,7 +216,11 @@ static HARD_REG_SET *block_out_reg_set;\n static int *block_number;\n \n /* This is the register file for all register after conversion */\n-static rtx FP_mode_reg[FIRST_PSEUDO_REGISTER][(int) MAX_MACHINE_MODE];\n+static rtx\n+  FP_mode_reg[LAST_STACK_REG+1-FIRST_STACK_REG][(int) MAX_MACHINE_MODE];\n+\n+#define FP_MODE_REG(regno,mode)\t\\\n+  (FP_mode_reg[(regno)-FIRST_STACK_REG][(int)(mode)])\n \n /* Get the basic block number of an insn.  See note at block_number\n    definition are validity of this information. */\n@@ -240,10 +241,55 @@ extern rtx emit_label_after ();\n static void find_blocks ();\n static uses_reg_or_mem ();\n static void stack_reg_life_analysis ();\n+static void record_reg_life_pat ();\n static void change_stack ();\n static void convert_regs ();\n static void dump_stack_info ();\n \f\n+/* Mark all registers needed for this pattern.  */\n+\n+static void\n+mark_regs_pat (pat, set)\n+     rtx pat;\n+     HARD_REG_SET *set;\n+{\n+  enum machine_mode mode;\n+  register int regno;\n+  register int count;\n+\n+  if (GET_CODE (pat) == SUBREG)\n+   {\n+     mode = GET_MODE (pat);\n+     regno = SUBREG_WORD (pat);\n+     regno += REGNO (SUBREG_REG (pat));\n+   }\n+  else\n+     regno = REGNO (pat), mode = GET_MODE (pat);\n+\n+  for (count = HARD_REGNO_NREGS (regno, mode);\n+       count; count--, regno++)\n+     SET_HARD_REG_BIT (*set, regno);\n+}\n+\f\n+/* Reorganise the stack into ascending numbers,\n+   after this insn.  */\n+\n+static void\n+straighten_stack (insn, regstack)\n+     rtx insn;\n+     stack regstack;\n+{\n+  struct stack_def temp_stack;\n+  int top;\n+\n+  temp_stack.reg_set = regstack->reg_set;\n+\n+  for (top = temp_stack.top = regstack->top; top >= 0; top--)\n+     temp_stack.reg[top] = FIRST_STACK_REG + temp_stack.top - top;\n+  \n+  change_stack (insn, regstack, &temp_stack, emit_insn_after);\n+}\n+\f\n /* Return non-zero if any stack register is mentioned somewhere within PAT.  */\n \n int\n@@ -293,19 +339,37 @@ reg_to_stack (first, file)\n   register int i;\n   int stack_reg_seen = 0;\n   enum machine_mode mode;\n+  HARD_REG_SET stackentry;\n \n-  current_function_returns_real\n-    = TREE_CODE (TREE_TYPE (DECL_RESULT (current_function_decl))) == REAL_TYPE;\n+  CLEAR_HARD_REG_SET (stackentry);\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n-    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      FP_mode_reg[i][(int) mode] = gen_rtx (REG, mode, i);\n+   {\n+     static initialised;\n+     if (!initialised)\n+      {\n+#if 0\n+\tinitialised = 1;\t/* This array can not have been previously\n+\t\t\t\t   initialised, because the rtx's are\n+\t\t\t\t   thrown away between compilations of\n+\t\t\t\t   functions.  */\n+#endif\n+        for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n+         {\n+           for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n+               mode = GET_MODE_WIDER_MODE (mode))\n+              FP_MODE_REG (i, mode) = gen_rtx (REG, mode, i);\n+           for (mode = GET_CLASS_NARROWEST_MODE (MODE_COMPLEX_FLOAT); mode != VOIDmode;\n+               mode = GET_MODE_WIDER_MODE (mode))\n+              FP_MODE_REG (i, mode) = gen_rtx (REG, mode, i);\n+         }\n+      }\n+   }\n \n   /* Count the basic blocks.  Also find maximum insn uid.  */\n   {\n     register RTX_CODE prev_code = BARRIER;\n     register RTX_CODE code;\n+    register before_function_beg = 1;\n \n     max_uid = 0;\n     blocks = 0;\n@@ -327,14 +391,24 @@ reg_to_stack (first, file)\n \t\t&& GET_RTX_CLASS (code) == 'i'))\n \t  blocks++;\n \n+\tif (code == NOTE && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n+\t   before_function_beg = 0;\n+\n \t/* Remember whether or not this insn mentions an FP regs.\n \t   Check JUMP_INSNs too, in case someone creates a funny PARALLEL. */\n \n-\tif (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\tif (GET_RTX_CLASS (code) == 'i'\n \t    && stack_regs_mentioned_p (PATTERN (insn)))\n \t  {\n \t    stack_reg_seen = 1;\n \t    PUT_MODE (insn, QImode);\n+\n+\t    /* Note any register passing parameters.  */\n+\n+\t    if (before_function_beg && code == INSN\n+\t        && GET_CODE (PATTERN (insn)) == USE)\n+              record_reg_life_pat (PATTERN (insn), (HARD_REG_SET*) 0,\n+\t\t\t\t   &stackentry, 1);\n \t  }\n \telse\n \t  PUT_MODE (insn, VOIDmode);\n@@ -373,7 +447,7 @@ reg_to_stack (first, file)\n   block_number = (int *) alloca ((max_uid + 1) * sizeof (int));\n \n   find_blocks (first);\n-  stack_reg_life_analysis (first);\n+  stack_reg_life_analysis (first, &stackentry);\n \n   /* Dump the life analysis debug information before jump\n      optimization, as that will destroy the LABEL_REFS we keep the\n@@ -445,13 +519,27 @@ static rtx *\n get_true_reg (pat)\n      rtx *pat;\n {\n-  while (GET_CODE (*pat) == SUBREG\n-\t || GET_CODE (*pat) == FLOAT\n-\t || GET_CODE (*pat) == FIX\n-\t || GET_CODE (*pat) == FLOAT_EXTEND)\n-    pat = & XEXP (*pat, 0);\n-\n-  return pat;\n+  for (;;)\n+     switch (GET_CODE (*pat))\n+      {\n+\tcase SUBREG:\n+\t\t/* eliminate FP subregister accesses in favour of the\n+\t\t   actual FP register in use. */\n+\t {\n+\t   rtx subreg;\n+\t   if (FP_REG_P (subreg = SUBREG_REG (*pat)))\n+\t    {\n+\t      *pat = FP_MODE_REG (REGNO (subreg) + SUBREG_WORD (*pat),\n+\t\t\t\t  GET_MODE (subreg));\n+\tdefault:\n+\t      return pat;\n+\t    }\n+\t }\n+\tcase FLOAT:\n+\tcase FIX:\n+\tcase FLOAT_EXTEND:\n+\t   pat = & XEXP (*pat, 0);\n+      }\n }\n \f\n /* Scan the OPERANDS and OPERAND_CONSTRAINTS of an asm_operands.\n@@ -963,34 +1051,36 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n    This function does not know about SET_DESTs that are both input and\n    output (such as ZERO_EXTRACT) - this cannot happen on a 387. */\n \n-void\n-record_reg_life_pat (pat, src, dest)\n+static void\n+record_reg_life_pat (pat, src, dest, douse)\n      rtx pat;\n      HARD_REG_SET *src, *dest;\n+     int douse;\n {\n   register char *fmt;\n   register int i;\n \n-  if (STACK_REG_P (pat))\n+  if (STACK_REG_P (pat)\n+      || GET_CODE (pat) == SUBREG && STACK_REG_P (SUBREG_REG (pat)))\n     {\n       if (src)\n-\tSET_HARD_REG_BIT (*src, REGNO (pat));\n+\t mark_regs_pat (pat, src);\n \n       if (dest)\n-\tSET_HARD_REG_BIT (*dest, REGNO (pat));\n+\t mark_regs_pat (pat, dest);\n \n       return;\n     }\n \n   if (GET_CODE (pat) == SET)\n     {\n-      record_reg_life_pat (XEXP (pat, 0), NULL_PTR, dest);\n-      record_reg_life_pat (XEXP (pat, 1), src, NULL_PTR);\n+      record_reg_life_pat (XEXP (pat, 0), NULL_PTR, dest, 0);\n+      record_reg_life_pat (XEXP (pat, 1), src, NULL_PTR, 0);\n       return;\n     }\n \n   /* We don't need to consider either of these cases. */\n-  if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+  if (GET_CODE (pat) == USE && !douse || GET_CODE (pat) == CLOBBER)\n     return;\n \n   fmt = GET_RTX_FORMAT (GET_CODE (pat));\n@@ -1001,10 +1091,10 @@ record_reg_life_pat (pat, src, dest)\n \t  register int j;\n \n \t  for (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n-\t    record_reg_life_pat (XVECEXP (pat, i, j), src, dest);\n+\t    record_reg_life_pat (XVECEXP (pat, i, j), src, dest, 0);\n \t}\n       else if (fmt[i] == 'e')\n-\trecord_reg_life_pat (XEXP (pat, i), src, dest);\n+\trecord_reg_life_pat (XEXP (pat, i), src, dest, 0);\n     }\n }\n \f\n@@ -1094,75 +1184,74 @@ record_reg_life (insn, block, regstack)\n       return;\n     }\n \n-  /* An insn referencing a stack reg has a mode of QImode. */\n-  if (GET_MODE (insn) == QImode)\n     {\n       HARD_REG_SET src, dest;\n       int regno;\n \n       CLEAR_HARD_REG_SET (src);\n       CLEAR_HARD_REG_SET (dest);\n-      record_reg_life_pat (PATTERN (insn), &src, &dest);\n \n+      if (GET_CODE (insn) == CALL_INSN)\n+\t for (note = CALL_INSN_FUNCTION_USAGE (insn);\n+\t      note;\n+\t      note = XEXP (note, 1))\n+\t   if (GET_CODE (XEXP (note, 0)) == USE)\n+\t     record_reg_life_pat (SET_DEST (XEXP (note, 0)), &src, NULL_PTR, 0);\n+\n+      record_reg_life_pat (PATTERN (insn), &src, &dest, 1);\n       for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG; regno++)\n \tif (! TEST_HARD_REG_BIT (regstack->reg_set, regno))\n \t  {\n \t    if (TEST_HARD_REG_BIT (src, regno)\n \t\t&& ! TEST_HARD_REG_BIT (dest, regno))\n \t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t\t  FP_mode_reg[regno][(int) DFmode],\n+\t\t\t\t\t  FP_MODE_REG (regno, DFmode),\n \t\t\t\t\t  REG_NOTES (insn));\n \t    else if (TEST_HARD_REG_BIT (dest, regno))\n \t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_UNUSED,\n-\t\t\t\t\t  FP_mode_reg[regno][(int) DFmode],\n+\t\t\t\t\t  FP_MODE_REG (regno, DFmode),\n \t\t\t\t\t  REG_NOTES (insn));\n \t  }\n \n-      AND_COMPL_HARD_REG_SET (regstack->reg_set, dest);\n-      IOR_HARD_REG_SET (regstack->reg_set, src);\n-    }\n-\n-  /* There might be a reg that is live after a function call.\n-     Initialize it to zero so that the program does not crash.  See comment\n-     towards the end of stack_reg_life_analysis(). */\n-\n-  if (GET_CODE (insn) == CALL_INSN)\n-    {\n-      int reg = FIRST_FLOAT_REG;\n-\n-      /* If a stack reg is mentioned in a CALL_INSN, it must be as the\n-\t return value.  */\n+      if (GET_CODE (insn) == CALL_INSN)\n+        {\n+\t  int reg;\n \n-      if (stack_regs_mentioned_p (PATTERN (insn)))\n-\treg++;\n+          /* There might be a reg that is live after a function call.\n+             Initialize it to zero so that the program does not crash.  See\n+\t     comment towards the end of stack_reg_life_analysis(). */\n \n-      for (; reg <= LAST_STACK_REG; reg++)\n-\tif (TEST_HARD_REG_BIT (regstack->reg_set, reg))\n-\t  {\n-\t    rtx init, pat;\n+          for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n+\t    if (! TEST_HARD_REG_BIT (dest, reg)\n+\t        && TEST_HARD_REG_BIT (regstack->reg_set, reg))\n+\t      {\n+\t        rtx init, pat;\n \n-\t    /* The insn will use virtual register numbers, and so\n-\t       convert_regs is expected to process these.  But BLOCK_NUM\n-\t       cannot be used on these insns, because they do not appear in\n-\t       block_number[]. */\n+\t        /* The insn will use virtual register numbers, and so\n+\t           convert_regs is expected to process these.  But BLOCK_NUM\n+\t           cannot be used on these insns, because they do not appear in\n+\t           block_number[]. */\n \n-\t    pat = gen_rtx (SET, VOIDmode, FP_mode_reg[reg][(int) DFmode],\n-\t\t\t   CONST0_RTX (DFmode));\n-\t    init = emit_insn_after (pat, insn);\n-\t    PUT_MODE (init, QImode);\n+\t        pat = gen_rtx (SET, VOIDmode, FP_MODE_REG (reg, DFmode),\n+\t\t\t       CONST0_RTX (DFmode));\n+\t        init = emit_insn_after (pat, insn);\n+\t        PUT_MODE (init, QImode);\n \n-\t    CLEAR_HARD_REG_BIT (regstack->reg_set, reg);\n+\t        CLEAR_HARD_REG_BIT (regstack->reg_set, reg);\n \n-\t    /* If the CALL_INSN was the end of a block, move the\n-\t       block_end to point to the new insn. */\n+\t        /* If the CALL_INSN was the end of a block, move the\n+\t           block_end to point to the new insn. */\n \n-\t    if (block_end[block] == insn)\n-\t      block_end[block] = init;\n-\t  }\n+\t        if (block_end[block] == insn)\n+\t          block_end[block] = init;\n+\t      }\n \n-      /* Some regs do not survive a CALL */\n+\t  /* Some regs do not survive a CALL */\n+          AND_COMPL_HARD_REG_SET (regstack->reg_set, call_used_reg_set);\n+\t}\n \n-      AND_COMPL_HARD_REG_SET (regstack->reg_set, call_used_reg_set);\n+      AND_COMPL_HARD_REG_SET (regstack->reg_set, dest);\n+      IOR_HARD_REG_SET (regstack->reg_set, src);\n     }\n }\n \f\n@@ -1311,8 +1400,8 @@ uses_reg_or_mem (x)\n /* If current function returns its result in an fp stack register,\n    return the register number.  Otherwise return -1.  */\n \n-static int\n-stack_result_p (decl)\n+static rtx\n+stack_result (decl)\n      tree decl;\n {\n   rtx result = DECL_RTL (DECL_RESULT (decl));\n@@ -1329,7 +1418,7 @@ stack_result_p (decl)\n #endif\n     }\n \n-  return STACK_REG_P (result) ? REGNO (result) : -1;\n+  return STACK_REG_P (result) ? result : (rtx) 0;\n }\n \f\n /* Determine the which registers are live at the start of each basic\n@@ -1341,7 +1430,7 @@ stack_result_p (decl)\n \n    Then, start with the last block and work back to the first block.\n    Similarly, work backwards within each block, insn by insn, recording\n-   which regs are die and which are used (and therefore live) in the\n+   which regs are dead and which are used (and therefore live) in the\n    hard reg set of block_stack_in[].\n \n    After processing each basic block, if there is a label at the start\n@@ -1363,31 +1452,33 @@ stack_result_p (decl)\n    done after CALL_INSNs in record_reg_life. */\n \n static void\n-stack_reg_life_analysis (first)\n+stack_reg_life_analysis (first, stackentry)\n      rtx first;\n+     HARD_REG_SET *stackentry;\n {\n   int reg, block;\n   struct stack_def regstack;\n \n-  if (current_function_returns_real\n-      && stack_result_p (current_function_decl) >= 0)\n-    {\n-      /* Find all RETURN insns and mark them. */\n+   {\n+     rtx retvalue;\n \n-      int value_regno = stack_result_p (current_function_decl);\n+     if (retvalue = stack_result (current_function_decl))\n+      {\n+        /* Find all RETURN insns and mark them. */\n \n-      for (block = blocks - 1; block >= 0; block--)\n-\tif (GET_CODE (block_end[block]) == JUMP_INSN\n-\t    && GET_CODE (PATTERN (block_end[block])) == RETURN)\n-\t  SET_HARD_REG_BIT (block_out_reg_set[block], value_regno);\n+        for (block = blocks - 1; --block >= 0;)\n+\t   if (GET_CODE (block_end[block]) == JUMP_INSN\n+\t     && GET_CODE (PATTERN (block_end[block])) == RETURN)\n+\t      mark_regs_pat (retvalue, block_out_reg_set+block);\n \n-      /* Mark of the end of last block if we \"fall off\" the end of the\n-\t function into the epilogue. */\n+        /* Mark off the end of last block if we \"fall off\" the end of the\n+\t   function into the epilogue. */\n \n-      if (GET_CODE (block_end[blocks-1]) != JUMP_INSN\n-\t  || GET_CODE (PATTERN (block_end[blocks-1])) == RETURN)\n-\tSET_HARD_REG_BIT (block_out_reg_set[blocks-1], value_regno);\n-    }\n+        if (GET_CODE (block_end[blocks-1]) != JUMP_INSN\n+\t    || GET_CODE (PATTERN (block_end[blocks-1])) == RETURN)\n+\t  mark_regs_pat (retvalue, block_out_reg_set+blocks-1);\n+      }\n+   }\n \n   /* now scan all blocks backward for stack register use */\n \n@@ -1470,44 +1561,35 @@ stack_reg_life_analysis (first)\n       block -= 1;\n     }\n \n-  {\n     /* If any reg is live at the start of the first block of a\n        function, then we must guarantee that the reg holds some value by\n        generating our own \"load\" of that register.  Otherwise a 387 would\n        fault trying to access an empty register. */\n \n-    HARD_REG_SET empty_regs;\n-    CLEAR_HARD_REG_SET (empty_regs);\n-    GO_IF_HARD_REG_SUBSET (block_stack_in[0].reg_set, empty_regs,\n-\t\t\t   no_live_regs);\n-  }\n-\n   /* Load zero into each live register.  The fact that a register\n-     appears live at the function start does not necessarily imply an error\n-     in the user program: it merely means that we could not determine that\n-     there wasn't such an error, just as -Wunused sometimes gives\n-     \"incorrect\" warnings.  In those cases, these initializations will do\n-     no harm.\n+     appears live at the function start necessarily implies an error\n+     in the user program: it means that (unless the offending code is *never*\n+     executed) this program is using uninitialised floating point\n+     variables.  In order to keep broken code like this happy, we initialise\n+     those variables with zero.\n \n      Note that we are inserting virtual register references here:\n      these insns must be processed by convert_regs later.  Also, these\n      insns will not be in block_number, so BLOCK_NUM() will fail for them. */\n \n   for (reg = LAST_STACK_REG; reg >= FIRST_STACK_REG; reg--)\n-    if (TEST_HARD_REG_BIT (block_stack_in[0].reg_set, reg))\n+    if (TEST_HARD_REG_BIT (block_stack_in[0].reg_set, reg)\n+        && ! TEST_HARD_REG_BIT (*stackentry, reg))\n       {\n \trtx init_rtx;\n \n-\tinit_rtx = gen_rtx (SET, VOIDmode, FP_mode_reg[reg][(int) DFmode],\n+\tinit_rtx = gen_rtx (SET, VOIDmode, FP_MODE_REG(reg, DFmode),\n \t\t\t    CONST0_RTX (DFmode));\n \tblock_begin[0] = emit_insn_after (init_rtx, first);\n \tPUT_MODE (block_begin[0], QImode);\n \n \tCLEAR_HARD_REG_BIT (block_stack_in[0].reg_set, reg);\n       }\n-\n- no_live_regs:\n-  ;\n }\n \f\n /*****************************************************************************\n@@ -1527,10 +1609,14 @@ replace_reg (reg, regno)\n       || ! STACK_REG_P (*reg))\n     abort ();\n \n-  if (GET_MODE_CLASS (GET_MODE (*reg)) != MODE_FLOAT)\n-    abort ();\n+  switch (GET_MODE_CLASS (GET_MODE (*reg)))\n+   {\n+     default: abort ();\n+     case MODE_FLOAT:\n+     case MODE_COMPLEX_FLOAT:;\n+   }\n \n-  *reg = FP_mode_reg[regno][(int) GET_MODE (*reg)];\n+  *reg = FP_MODE_REG (regno, GET_MODE (*reg));\n }\n \n /* Remove a note of type NOTE, which must be found, for register\n@@ -1614,15 +1700,15 @@ emit_pop_insn (insn, regstack, reg, when)\n   if (hard_regno < FIRST_STACK_REG)\n     abort ();\n \n-  pop_rtx = gen_rtx (SET, VOIDmode, FP_mode_reg[hard_regno][(int) DFmode],\n-\t\t     FP_mode_reg[FIRST_STACK_REG][(int) DFmode]);\n+  pop_rtx = gen_rtx (SET, VOIDmode, FP_MODE_REG (hard_regno, DFmode),\n+\t\t     FP_MODE_REG (FIRST_STACK_REG, DFmode));\n \n   pop_insn = (*when) (pop_rtx, insn);\n   /* ??? This used to be VOIDmode, but that seems wrong. */\n   PUT_MODE (pop_insn, QImode);\n \n   REG_NOTES (pop_insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t  FP_mode_reg[FIRST_STACK_REG][(int) DFmode],\n+\t\t\t\t  FP_MODE_REG (FIRST_STACK_REG, DFmode),\n \t\t\t\t  REG_NOTES (pop_insn));\n \n   regstack->reg[regstack->top - (hard_regno - FIRST_STACK_REG)]\n@@ -1706,8 +1792,8 @@ emit_swap_insn (insn, regstack, reg)\n \tabort ();\n     }\n \n-  swap_rtx = gen_swapdf (FP_mode_reg[hard_regno][(int) DFmode],\n-\t\t\t FP_mode_reg[FIRST_STACK_REG][(int) DFmode]);\n+  swap_rtx = gen_swapdf (FP_MODE_REG (hard_regno, DFmode),\n+\t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n   swap_insn = emit_insn_after (swap_rtx, i1);\n   /* ??? This used to be VOIDmode, but that seems wrong. */\n   PUT_MODE (swap_insn, QImode);\n@@ -1722,47 +1808,50 @@ move_for_stack_reg (insn, regstack, pat)\n      stack regstack;\n      rtx pat;\n {\n-  rtx *src =  get_true_reg (&SET_SRC (pat));\n-  rtx *dest = get_true_reg (&SET_DEST (pat));\n+  rtx *psrc =  get_true_reg (&SET_SRC (pat));\n+  rtx *pdest = get_true_reg (&SET_DEST (pat));\n+  rtx src, dest;\n   rtx note;\n \n-  if (STACK_REG_P (*src) && STACK_REG_P (*dest))\n+  src = *psrc; dest = *pdest;\n+\n+  if (STACK_REG_P (src) && STACK_REG_P (dest))\n     {\n       /* Write from one stack reg to another.  If SRC dies here, then\n \t just change the register mapping and delete the insn. */\n \n-      note = find_regno_note (insn, REG_DEAD, REGNO (*src));\n+      note = find_regno_note (insn, REG_DEAD, REGNO (src));\n       if (note)\n \t{\n \t  int i;\n \n \t  /* If this is a no-op move, there must not be a REG_DEAD note. */\n-\t  if (REGNO (*src) == REGNO (*dest))\n+\t  if (REGNO (src) == REGNO (dest))\n \t    abort ();\n \n \t  for (i = regstack->top; i >= 0; i--)\n-\t    if (regstack->reg[i] == REGNO (*src))\n+\t    if (regstack->reg[i] == REGNO (src))\n \t      break;\n \n \t  /* The source must be live, and the dest must be dead. */\n-\t  if (i < 0 || get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG)\n+\t  if (i < 0 || get_hard_regnum (regstack, dest) >= FIRST_STACK_REG)\n \t    abort ();\n \n \t  /* It is possible that the dest is unused after this insn.\n \t     If so, just pop the src. */\n \n-\t  if (find_regno_note (insn, REG_UNUSED, REGNO (*dest)))\n+\t  if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n \t    {\n-\t      emit_pop_insn (insn, regstack, *src, emit_insn_after);\n+\t      emit_pop_insn (insn, regstack, src, emit_insn_after);\n \n \t      delete_insn_for_stacker (insn);\n \t      return;\n \t    }\n \n-\t  regstack->reg[i] = REGNO (*dest);\n+\t  regstack->reg[i] = REGNO (dest);\n \n-\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-\t  CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src));\n+\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (dest));\n+\t  CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (src));\n \n \t  delete_insn_for_stacker (insn);\n \n@@ -1776,41 +1865,41 @@ move_for_stack_reg (insn, regstack, pat)\n \t it is REG_UNUSED, we must pop the reg now, as per-insn processing\n \t for REG_UNUSED will not work for deleted insns. */\n \n-      if (REGNO (*src) == REGNO (*dest))\n+      if (REGNO (src) == REGNO (dest))\n \t{\n-\t  if (find_regno_note (insn, REG_UNUSED, REGNO (*dest)))\n-\t    emit_pop_insn (insn, regstack, *dest, emit_insn_after);\n+\t  if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n+\t    emit_pop_insn (insn, regstack, dest, emit_insn_after);\n \n \t  delete_insn_for_stacker (insn);\n \t  return;\n \t}\n \n       /* The destination ought to be dead */\n-      if (get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG)\n+      if (get_hard_regnum (regstack, dest) >= FIRST_STACK_REG)\n \tabort ();\n \n-      replace_reg (src, get_hard_regnum (regstack, *src));\n+      replace_reg (psrc, get_hard_regnum (regstack, src));\n \n-      regstack->reg[++regstack->top] = REGNO (*dest);\n-      SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-      replace_reg (dest, FIRST_STACK_REG);\n+      regstack->reg[++regstack->top] = REGNO (dest);\n+      SET_HARD_REG_BIT (regstack->reg_set, REGNO (dest));\n+      replace_reg (pdest, FIRST_STACK_REG);\n     }\n-  else if (STACK_REG_P (*src))\n+  else if (STACK_REG_P (src))\n     {\n       /* Save from a stack reg to MEM, or possibly integer reg.  Since\n \t only top of stack may be saved, emit an exchange first if\n \t needs be. */\n \n-      emit_swap_insn (insn, regstack, *src);\n+      emit_swap_insn (insn, regstack, src);\n \n-      note = find_regno_note (insn, REG_DEAD, REGNO (*src));\n+      note = find_regno_note (insn, REG_DEAD, REGNO (src));\n       if (note)\n \t{\n \t  replace_reg (&XEXP (note, 0), FIRST_STACK_REG);\n \t  regstack->top--;\n-\t  CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src));\n+\t  CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (src));\n \t}\n-      else if (GET_MODE (*src) == XFmode && regstack->top != REG_STACK_SIZE)\n+      else if (GET_MODE (src) == XFmode && regstack->top != REG_STACK_SIZE)\n \t{\n \t  /* A 387 cannot write an XFmode value to a MEM without\n \t     clobbering the source reg.  The output code can handle\n@@ -1820,7 +1909,7 @@ move_for_stack_reg (insn, regstack, pat)\n \t     stack is not full, and then write the value to memory via\n \t     a pop.  */\n \t  rtx push_rtx, push_insn;\n-\t  rtx top_stack_reg = FP_mode_reg[FIRST_STACK_REG][(int) XFmode];\n+\t  rtx top_stack_reg = FP_MODE_REG (FIRST_STACK_REG, XFmode);\n \n \t  push_rtx = gen_movxf (top_stack_reg, top_stack_reg);\n \t  push_insn = emit_insn_before (push_rtx, insn);\n@@ -1829,25 +1918,25 @@ move_for_stack_reg (insn, regstack, pat)\n \t\t\t\t      REG_NOTES (insn));\n \t}\n \n-      replace_reg (src, FIRST_STACK_REG);\n+      replace_reg (psrc, FIRST_STACK_REG);\n     }\n-  else if (STACK_REG_P (*dest))\n+  else if (STACK_REG_P (dest))\n     {\n       /* Load from MEM, or possibly integer REG or constant, into the\n \t stack regs.  The actual target is always the top of the\n \t stack. The stack mapping is changed to reflect that DEST is\n \t now at top of stack.  */\n \n       /* The destination ought to be dead */\n-      if (get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG)\n+      if (get_hard_regnum (regstack, dest) >= FIRST_STACK_REG)\n \tabort ();\n \n       if (regstack->top >= REG_STACK_SIZE)\n \tabort ();\n \n-      regstack->reg[++regstack->top] = REGNO (*dest);\n-      SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-      replace_reg (dest, FIRST_STACK_REG);\n+      regstack->reg[++regstack->top] = REGNO (dest);\n+      SET_HARD_REG_BIT (regstack->reg_set, REGNO (dest));\n+      replace_reg (pdest, FIRST_STACK_REG);\n     }\n   else\n     abort ();\n@@ -2019,8 +2108,15 @@ subst_stack_regs_pat (insn, regstack, pat)\n \tbreak;\n \n       case CALL:\n-\tregstack->reg[++regstack->top] = REGNO (*dest);\n-\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t {\n+\t   int count;\n+\t   for (count = HARD_REGNO_NREGS (REGNO (*dest), GET_MODE (*dest));\n+              --count >= 0;)\n+\t    {\n+\t      regstack->reg[++regstack->top] = REGNO (*dest) + count;\n+\t      SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest) + count);\n+\t    }\n+\t }\n \treplace_reg (dest, FIRST_STACK_REG);\n \tbreak;\n \n@@ -2422,7 +2518,7 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \t     that these regs can't be MODE_INT and will abort.  Just put\n \t     the right reg there without calling replace_reg.  */\n \n-\t  *clobber_loc[i] = FP_mode_reg[regnum][(int) DFmode];\n+\t  *clobber_loc[i] = FP_MODE_REG (regnum, DFmode);\n \t}\n     }\n \n@@ -2524,16 +2620,27 @@ subst_stack_regs (insn, regstack)\n   register int i;\n   int n_operands;\n \n-  if ((GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n-      || INSN_DELETED_P (insn))\n-    return;\n+  if (GET_CODE (insn) == CALL_INSN)\n+   {\n+     int top = regstack->top;\n \n-  /* The stack should be empty at a call. */\n+     /* If there are any floating point parameters to be passed in\n+\tregisters for this call, make sure they are in the right\n+\torder.  */\n \n-  if (GET_CODE (insn) == CALL_INSN)\n-    for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n-      if (TEST_HARD_REG_BIT (regstack->reg_set, i))\n-\tabort ();\n+     if (top >= 0)\n+      {\n+\tstraighten_stack (PREV_INSN (insn), regstack);\n+\n+\t/* Now mark the arguments as dead after the call.  */\n+\n+        while (regstack->top >= 0)\n+         {\n+           CLEAR_HARD_REG_BIT (regstack->reg_set, FIRST_STACK_REG + regstack->top);\n+\t   regstack->top--;\n+         }\n+      }\n+   }\n \n   /* Do the actual substitution if any stack regs are mentioned.\n      Since we only record whether entire insn mentions stack regs, and\n@@ -2630,7 +2737,7 @@ change_stack (insn, old, new, when)\n \n   for (reg = old->top; reg >= 0; reg--)\n     if (! TEST_HARD_REG_BIT (new->reg_set, old->reg[reg]))\n-      emit_pop_insn (insn, old, FP_mode_reg[old->reg[reg]][(int) DFmode],\n+      emit_pop_insn (insn, old, FP_MODE_REG (old->reg[reg], DFmode),\n \t\t     emit_insn_before);\n \n   if (new->top == -2)\n@@ -2680,7 +2787,7 @@ change_stack (insn, old, new, when)\n \t\tabort ();\n \n \t      emit_swap_insn (insn, old,\n-\t\t\t      FP_mode_reg[old->reg[reg]][(int) DFmode]);\n+\t\t\t      FP_MODE_REG (old->reg[reg], DFmode));\n \t    }\n \n \t  /* See if any regs remain incorrect.  If so, bring an\n@@ -2691,7 +2798,7 @@ change_stack (insn, old, new, when)\n \t    if (new->reg[reg] != old->reg[reg])\n \t      {\n \t\temit_swap_insn (insn, old,\n-\t\t\t\tFP_mode_reg[old->reg[reg]][(int) DFmode]);\n+\t\t\t\tFP_MODE_REG (old->reg[reg], DFmode));\n \t\tbreak;\n \t      }\n \t} while (reg >= 0);\n@@ -2727,8 +2834,13 @@ goto_block_pat (insn, regstack, pat)\n   struct stack_def temp_stack;\n   int reg;\n \n-  if (GET_CODE (pat) != LABEL_REF)\n-    {\n+  switch (GET_CODE (pat))\n+   {\n+     case RETURN:\n+\tstraighten_stack (PREV_INSN (insn), regstack);\n+\treturn;\n+     default:\n+     {\n       int i, j;\n       char *fmt = GET_RTX_FORMAT (GET_CODE (pat));\n \n@@ -2741,7 +2853,9 @@ goto_block_pat (insn, regstack, pat)\n \t      goto_block_pat (insn, regstack, XVECEXP (pat, i, j));\n \t}\n       return;\n-    }\n+     }\n+     case LABEL_REF:;\n+   }\n \n   label = XEXP (pat, 0);\n   if (GET_CODE (label) != CODE_LABEL)\n@@ -2858,10 +2972,8 @@ convert_regs ()\n \t  next = NEXT_INSN (insn);\n \n \t  /* Don't bother processing unless there is a stack reg\n-\t     mentioned.\n-\n-\t     ??? For now, process CALL_INSNs too to make sure that the\n-\t     stack regs are dead after a call.  Remove this eventually. */\n+\t     mentioned or if it's a CALL_INSN (register passing of\n+\t     floating point values). */\n \n \t  if (GET_MODE (insn) == QImode || GET_CODE (insn) == CALL_INSN)\n \t    subst_stack_regs (insn, &regstack);\n@@ -2895,12 +3007,27 @@ convert_regs ()\n      regs live at its start, then the last basic block will have regs live\n      at its end that need to be popped before the function returns. */\n \n-  for (reg = regstack.top; reg >= 0; reg--)\n-    if (! current_function_returns_real\n-\t|| regstack.reg[reg] != FIRST_STACK_REG)\n-      insn = emit_pop_insn (insn, &regstack,\n-\t\t\t    FP_mode_reg[regstack.reg[reg]][(int) DFmode],\n+   {\n+     int value_reg_low, value_reg_high;\n+     value_reg_low = value_reg_high = -1;\n+      {\n+        rtx retvalue;\n+        if (retvalue = stack_result (current_function_decl))\n+\t {\n+\t   value_reg_low = REGNO (retvalue);\n+\t   value_reg_high = value_reg_low +\n+\t    HARD_REGNO_NREGS (value_reg_low, GET_MODE (retvalue)) - 1;\n+\t }\n+\n+      }\n+     for (reg = regstack.top; reg >= 0; reg--)\n+        if (regstack.reg[reg] < value_reg_low ||\n+            regstack.reg[reg] > value_reg_high)\n+           insn = emit_pop_insn (insn, &regstack,\n+\t\t\t    FP_MODE_REG (regstack.reg[reg], DFmode),\n \t\t\t    emit_insn_after);\n+   }\n+  straighten_stack (insn, &regstack);\n }\n \f\n /* Check expression PAT, which is in INSN, for label references.  if\n@@ -2974,14 +3101,14 @@ dump_stack_info (file)\n \tfprintf (file, \" previous\");\n \n       fprintf (file, \"\\nlive stack registers on block entry: \");\n-      for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG ; regno++)\n+      for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG; regno++)\n \t{\n \t  if (TEST_HARD_REG_BIT (block_stack_in[block].reg_set, regno))\n \t    fprintf (file, \"%d \", regno);\n \t}\n \n       fprintf (file, \"\\nlive stack registers on block exit: \");\n-      for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG ; regno++)\n+      for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG; regno++)\n \t{\n \t  if (TEST_HARD_REG_BIT (block_out_reg_set[block], regno))\n \t    fprintf (file, \"%d \", regno);"}]}