{"sha": "0524d2d6623eb2ab287f464e05c206ceeb3839bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUyNGQyZDY2MjNlYjJhYjI4N2Y0NjRlMDVjMjA2Y2VlYjM4MzliZg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-08-19T17:31:57Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-08-19T17:31:57Z"}, "message": "re PR tree-optimization/42172 (inefficient bit fields assignments)\n\n\tPR target/42172\n\t* combine.c (combine_validate_cost): New arg I0.  All callers changed.\n\tTake its cost into account if nonnull.\n\t(insn_a_feeds_b): New static function.\n\t(combine_instructions): Look for four-insn combinations.\n\t(can_combine_p): New args PRED2, SUCC2.  All callers changed.  Take\n\tthem into account when computing all_adjacent and looking for other\n\tuses.\n\t(combinable_i3pat): New args I0DEST, I0_NOT_IN_SRC.  All callers\n\tchanged.  Treat them like I1DEST and I1_NOT_IN_SRC.\n\t(try_combine): New arg I0.  Handle four-insn combinations.\n\t(distribute_notes): New arg ELIM_I0.  All callers changed.  Treat it\n\tlike ELIM_I1.\n\nFrom-SVN: r163383", "tree": {"sha": "9de8d43f5bf7c9cbeb9e5e6bbf8c0c6dfbb0c5d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9de8d43f5bf7c9cbeb9e5e6bbf8c0c6dfbb0c5d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0524d2d6623eb2ab287f464e05c206ceeb3839bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0524d2d6623eb2ab287f464e05c206ceeb3839bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0524d2d6623eb2ab287f464e05c206ceeb3839bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0524d2d6623eb2ab287f464e05c206ceeb3839bf/comments", "author": null, "committer": null, "parents": [{"sha": "f0d9b83660897011cb4325beb1239b5c76d9d685", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d9b83660897011cb4325beb1239b5c76d9d685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0d9b83660897011cb4325beb1239b5c76d9d685"}], "stats": {"total": 605, "additions": 458, "deletions": 147}, "files": [{"sha": "3065cc260f51862d528bee1ee5b9b2bb86344b63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0524d2d6623eb2ab287f464e05c206ceeb3839bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0524d2d6623eb2ab287f464e05c206ceeb3839bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0524d2d6623eb2ab287f464e05c206ceeb3839bf", "patch": "@@ -1,3 +1,19 @@\n+2010-08-19  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR target/42172\n+\t* combine.c (combine_validate_cost): New arg I0.  All callers changed.\n+\tTake its cost into account if nonnull.\n+\t(insn_a_feeds_b): New static function.\n+\t(combine_instructions): Look for four-insn combinations.\n+\t(can_combine_p): New args PRED2, SUCC2.  All callers changed.  Take\n+\tthem into account when computing all_adjacent and looking for other\n+\tuses.\n+\t(combinable_i3pat): New args I0DEST, I0_NOT_IN_SRC.  All callers\n+\tchanged.  Treat them like I1DEST and I1_NOT_IN_SRC.\n+\t(try_combine): New arg I0.  Handle four-insn combinations.\n+\t(distribute_notes): New arg ELIM_I0.  All callers changed.  Treat it\n+\tlike ELIM_I1.\n+\n 2010-08-19  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/45307"}, {"sha": "6a2aa8ae41754bac7a47037dd69fc4dd238ea50a", "filename": "gcc/combine.c", "status": "modified", "additions": 442, "deletions": 147, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0524d2d6623eb2ab287f464e05c206ceeb3839bf/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0524d2d6623eb2ab287f464e05c206ceeb3839bf/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0524d2d6623eb2ab287f464e05c206ceeb3839bf", "patch": "@@ -385,10 +385,10 @@ static void init_reg_last (void);\n static void setup_incoming_promotions (rtx);\n static void set_nonzero_bits_and_sign_copies (rtx, const_rtx, void *);\n static int cant_combine_insn_p (rtx);\n-static int can_combine_p (rtx, rtx, rtx, rtx, rtx *, rtx *);\n-static int combinable_i3pat (rtx, rtx *, rtx, rtx, int, rtx *);\n+static int can_combine_p (rtx, rtx, rtx, rtx, rtx, rtx, rtx *, rtx *);\n+static int combinable_i3pat (rtx, rtx *, rtx, rtx, rtx, int, int, rtx *);\n static int contains_muldiv (rtx);\n-static rtx try_combine (rtx, rtx, rtx, int *);\n+static rtx try_combine (rtx, rtx, rtx, rtx, int *);\n static void undo_all (void);\n static void undo_commit (void);\n static rtx *find_split_point (rtx *, rtx, bool);\n@@ -438,7 +438,7 @@ static void reg_dead_at_p_1 (rtx, const_rtx, void *);\n static int reg_dead_at_p (rtx, rtx);\n static void move_deaths (rtx, rtx, int, rtx, rtx *);\n static int reg_bitfield_target_p (rtx, rtx);\n-static void distribute_notes (rtx, rtx, rtx, rtx, rtx, rtx);\n+static void distribute_notes (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n static void distribute_links (rtx);\n static void mark_used_regs_combine (rtx);\n static void record_promoted_value (rtx, rtx);\n@@ -766,18 +766,18 @@ do_SUBST_MODE (rtx *into, enum machine_mode newval)\n \f\n /* Subroutine of try_combine.  Determine whether the combine replacement\n    patterns NEWPAT, NEWI2PAT and NEWOTHERPAT are cheaper according to\n-   insn_rtx_cost that the original instruction sequence I1, I2, I3 and\n+   insn_rtx_cost that the original instruction sequence I0, I1, I2, I3 and\n    undobuf.other_insn.  Note that I1 and/or NEWI2PAT may be NULL_RTX.\n    NEWOTHERPAT and undobuf.other_insn may also both be NULL_RTX.  This\n    function returns false, if the costs of all instructions can be\n    estimated, and the replacements are more expensive than the original\n    sequence.  */\n \n static bool\n-combine_validate_cost (rtx i1, rtx i2, rtx i3, rtx newpat, rtx newi2pat,\n-\t\t       rtx newotherpat)\n+combine_validate_cost (rtx i0, rtx i1, rtx i2, rtx i3, rtx newpat,\n+\t\t       rtx newi2pat, rtx newotherpat)\n {\n-  int i1_cost, i2_cost, i3_cost;\n+  int i0_cost, i1_cost, i2_cost, i3_cost;\n   int new_i2_cost, new_i3_cost;\n   int old_cost, new_cost;\n \n@@ -788,13 +788,23 @@ combine_validate_cost (rtx i1, rtx i2, rtx i3, rtx newpat, rtx newi2pat,\n   if (i1)\n     {\n       i1_cost = INSN_COST (i1);\n-      old_cost = (i1_cost > 0 && i2_cost > 0 && i3_cost > 0)\n-\t\t ? i1_cost + i2_cost + i3_cost : 0;\n+      if (i0)\n+\t{\n+\t  i0_cost = INSN_COST (i0);\n+\t  old_cost = (i0_cost > 0 && i1_cost > 0 && i2_cost > 0 && i3_cost > 0\n+\t\t      ? i0_cost + i1_cost + i2_cost + i3_cost : 0);\n+\t}\n+      else\n+\t{\n+\t  old_cost = (i1_cost > 0 && i2_cost > 0 && i3_cost > 0\n+\t\t      ? i1_cost + i2_cost + i3_cost : 0);\n+\t  i0_cost = 0;\n+\t}\n     }\n   else\n     {\n       old_cost = (i2_cost > 0 && i3_cost > 0) ? i2_cost + i3_cost : 0;\n-      i1_cost = 0;\n+      i1_cost = i0_cost = 0;\n     }\n \n   /* Calculate the replacement insn_rtx_costs.  */\n@@ -833,7 +843,16 @@ combine_validate_cost (rtx i1, rtx i2, rtx i3, rtx newpat, rtx newi2pat,\n     {\n       if (dump_file)\n \t{\n-\t  if (i1)\n+\t  if (i0)\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"rejecting combination of insns %d, %d, %d and %d\\n\",\n+\t\t       INSN_UID (i0), INSN_UID (i1), INSN_UID (i2),\n+\t\t       INSN_UID (i3));\n+\t      fprintf (dump_file, \"original costs %d + %d + %d + %d = %d\\n\",\n+\t\t       i0_cost, i1_cost, i2_cost, i3_cost, old_cost);\n+\t    }\n+\t  else if (i1)\n \t    {\n \t      fprintf (dump_file,\n \t\t       \"rejecting combination of insns %d, %d and %d\\n\",\n@@ -1010,6 +1029,21 @@ clear_log_links (void)\n     if (INSN_P (insn))\n       free_INSN_LIST_list (&LOG_LINKS (insn));\n }\n+\n+/* Walk the LOG_LINKS of insn B to see if we find a reference to A.  Return\n+   true if we found a LOG_LINK that proves that A feeds B.  This only works\n+   if there are no instructions between A and B which could have a link\n+   depending on A, since in that case we would not record a link for B.  */\n+\n+static bool\n+insn_a_feeds_b (rtx a, rtx b)\n+{\n+  rtx links;\n+  for (links = LOG_LINKS (b); links; links = XEXP (links, 1))\n+    if (XEXP (links, 0) == a)\n+      return true;\n+  return false;\n+}\n \f\n /* Main entry point for combiner.  F is the first insn of the function.\n    NREGS is the first unused pseudo-reg number.\n@@ -1150,7 +1184,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t      /* Try this insn with each insn it links back to.  */\n \n \t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n-\t\tif ((next = try_combine (insn, XEXP (links, 0),\n+\t\tif ((next = try_combine (insn, XEXP (links, 0), NULL_RTX,\n \t\t\t\t\t NULL_RTX, &new_direct_jump_p)) != 0)\n \t\t  goto retry;\n \n@@ -1168,8 +1202,8 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t  for (nextlinks = LOG_LINKS (link);\n \t\t       nextlinks;\n \t\t       nextlinks = XEXP (nextlinks, 1))\n-\t\t    if ((next = try_combine (insn, link,\n-\t\t\t\t\t     XEXP (nextlinks, 0),\n+\t\t    if ((next = try_combine (insn, link, XEXP (nextlinks, 0),\n+\t\t\t\t\t     NULL_RTX,\n \t\t\t\t\t     &new_direct_jump_p)) != 0)\n \t\t      goto retry;\n \t\t}\n@@ -1187,14 +1221,14 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t  && NONJUMP_INSN_P (prev)\n \t\t  && sets_cc0_p (PATTERN (prev)))\n \t\t{\n-\t\t  if ((next = try_combine (insn, prev,\n-\t\t\t\t\t   NULL_RTX, &new_direct_jump_p)) != 0)\n+\t\t  if ((next = try_combine (insn, prev, NULL_RTX, NULL_RTX,\n+\t\t\t\t\t   &new_direct_jump_p)) != 0)\n \t\t    goto retry;\n \n \t\t  for (nextlinks = LOG_LINKS (prev); nextlinks;\n \t\t       nextlinks = XEXP (nextlinks, 1))\n-\t\t    if ((next = try_combine (insn, prev,\n-\t\t\t\t\t     XEXP (nextlinks, 0),\n+\t\t    if ((next = try_combine (insn, prev, XEXP (nextlinks, 0),\n+\t\t\t\t\t     NULL_RTX,\n \t\t\t\t\t     &new_direct_jump_p)) != 0)\n \t\t      goto retry;\n \t\t}\n@@ -1207,14 +1241,14 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t  && GET_CODE (PATTERN (insn)) == SET\n \t\t  && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (insn))))\n \t\t{\n-\t\t  if ((next = try_combine (insn, prev,\n-\t\t\t\t\t   NULL_RTX, &new_direct_jump_p)) != 0)\n+\t\t  if ((next = try_combine (insn, prev, NULL_RTX, NULL_RTX,\n+\t\t\t\t\t   &new_direct_jump_p)) != 0)\n \t\t    goto retry;\n \n \t\t  for (nextlinks = LOG_LINKS (prev); nextlinks;\n \t\t       nextlinks = XEXP (nextlinks, 1))\n-\t\t    if ((next = try_combine (insn, prev,\n-\t\t\t\t\t     XEXP (nextlinks, 0),\n+\t\t    if ((next = try_combine (insn, prev, XEXP (nextlinks, 0),\n+\t\t\t\t\t     NULL_RTX,\n \t\t\t\t\t     &new_direct_jump_p)) != 0)\n \t\t      goto retry;\n \t\t}\n@@ -1230,7 +1264,8 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t    && NONJUMP_INSN_P (prev)\n \t\t    && sets_cc0_p (PATTERN (prev))\n \t\t    && (next = try_combine (insn, XEXP (links, 0),\n-\t\t\t\t\t    prev, &new_direct_jump_p)) != 0)\n+\t\t\t\t\t    prev, NULL_RTX,\n+\t\t\t\t\t    &new_direct_jump_p)) != 0)\n \t\t  goto retry;\n #endif\n \n@@ -1240,10 +1275,64 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\tfor (nextlinks = XEXP (links, 1); nextlinks;\n \t\t     nextlinks = XEXP (nextlinks, 1))\n \t\t  if ((next = try_combine (insn, XEXP (links, 0),\n-\t\t\t\t\t   XEXP (nextlinks, 0),\n+\t\t\t\t\t   XEXP (nextlinks, 0), NULL_RTX,\n \t\t\t\t\t   &new_direct_jump_p)) != 0)\n \t\t    goto retry;\n \n+\t      /* Try four-instruction combinations.  */\n+\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n+\t\t{\n+\t\t  rtx next1;\n+\t\t  rtx link = XEXP (links, 0);\n+\n+\t\t  /* If the linked insn has been replaced by a note, then there\n+\t\t     is no point in pursuing this chain any further.  */\n+\t\t  if (NOTE_P (link))\n+\t\t    continue;\n+\n+\t\t  for (next1 = LOG_LINKS (link); next1; next1 = XEXP (next1, 1))\n+\t\t    {\n+\t\t      rtx link1 = XEXP (next1, 0);\n+\t\t      if (NOTE_P (link1))\n+\t\t\tcontinue;\n+\t\t      /* I0 -> I1 -> I2 -> I3.  */\n+\t\t      for (nextlinks = LOG_LINKS (link1); nextlinks;\n+\t\t\t   nextlinks = XEXP (nextlinks, 1))\n+\t\t\tif ((next = try_combine (insn, link, link1,\n+\t\t\t\t\t\t XEXP (nextlinks, 0),\n+\t\t\t\t\t\t &new_direct_jump_p)) != 0)\n+\t\t\t  goto retry;\n+\t\t      /* I0, I1 -> I2, I2 -> I3.  */\n+\t\t      for (nextlinks = XEXP (next1, 1); nextlinks;\n+\t\t\t   nextlinks = XEXP (nextlinks, 1))\n+\t\t\tif ((next = try_combine (insn, link, link1,\n+\t\t\t\t\t\t XEXP (nextlinks, 0),\n+\t\t\t\t\t\t &new_direct_jump_p)) != 0)\n+\t\t\t  goto retry;\n+\t\t    }\n+\n+\t\t  for (next1 = XEXP (links, 1); next1; next1 = XEXP (next1, 1))\n+\t\t    {\n+\t\t      rtx link1 = XEXP (next1, 0);\n+\t\t      if (NOTE_P (link1))\n+\t\t\tcontinue;\n+\t\t      /* I0 -> I2; I1, I2 -> I3.  */\n+\t\t      for (nextlinks = LOG_LINKS (link); nextlinks;\n+\t\t\t   nextlinks = XEXP (nextlinks, 1))\n+\t\t\tif ((next = try_combine (insn, link, link1,\n+\t\t\t\t\t\t XEXP (nextlinks, 0),\n+\t\t\t\t\t\t &new_direct_jump_p)) != 0)\n+\t\t\t  goto retry;\n+\t\t      /* I0 -> I1; I1, I2 -> I3.  */\n+\t\t      for (nextlinks = LOG_LINKS (link1); nextlinks;\n+\t\t\t   nextlinks = XEXP (nextlinks, 1))\n+\t\t\tif ((next = try_combine (insn, link, link1,\n+\t\t\t\t\t\t XEXP (nextlinks, 0),\n+\t\t\t\t\t\t &new_direct_jump_p)) != 0)\n+\t\t\t  goto retry;\n+\t\t    }\n+\t\t}\n+\n \t      /* Try this insn with each REG_EQUAL note it links back to.  */\n \t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n \t\t{\n@@ -1267,7 +1356,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t      i2mod = temp;\n \t\t      i2mod_old_rhs = copy_rtx (orig);\n \t\t      i2mod_new_rhs = copy_rtx (note);\n-\t\t      next = try_combine (insn, i2mod, NULL_RTX,\n+\t\t      next = try_combine (insn, i2mod, NULL_RTX, NULL_RTX,\n \t\t\t\t\t  &new_direct_jump_p);\n \t\t      i2mod = NULL_RTX;\n \t\t      if (next)\n@@ -1529,9 +1618,10 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n     }\n }\n \f\n-/* See if INSN can be combined into I3.  PRED and SUCC are optionally\n-   insns that were previously combined into I3 or that will be combined\n-   into the merger of INSN and I3.\n+/* See if INSN can be combined into I3.  PRED, PRED2, SUCC and SUCC2 are\n+   optionally insns that were previously combined into I3 or that will be\n+   combined into the merger of INSN and I3.  The order is PRED, PRED2,\n+   INSN, SUCC, SUCC2, I3.\n \n    Return 0 if the combination is not allowed for any reason.\n \n@@ -1540,7 +1630,8 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n    will return 1.  */\n \n static int\n-can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n+can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED,\n+\t       rtx pred2 ATTRIBUTE_UNUSED, rtx succ, rtx succ2,\n \t       rtx *pdest, rtx *psrc)\n {\n   int i;\n@@ -1550,10 +1641,25 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n #ifdef AUTO_INC_DEC\n   rtx link;\n #endif\n-  int all_adjacent = (succ ? (next_active_insn (insn) == succ\n-\t\t\t      && next_active_insn (succ) == i3)\n-\t\t      : next_active_insn (insn) == i3);\n+  bool all_adjacent = true;\n \n+  if (succ)\n+    {\n+      if (succ2)\n+\t{\n+\t  if (next_active_insn (succ2) != i3)\n+\t    all_adjacent = false;\n+\t  if (next_active_insn (succ) != succ2)\n+\t    all_adjacent = false;\n+\t}\n+      else if (next_active_insn (succ) != i3)\n+\tall_adjacent = false;\n+      if (next_active_insn (insn) != succ)\n+\tall_adjacent = false;\n+    }\n+  else if (next_active_insn (insn) != i3)\n+    all_adjacent = false;\n+    \n   /* Can combine only if previous insn is a SET of a REG, a SUBREG or CC0.\n      or a PARALLEL consisting of such a SET and CLOBBERs.\n \n@@ -1678,11 +1784,15 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n       /* Don't substitute into an incremented register.  */\n       || FIND_REG_INC_NOTE (i3, dest)\n       || (succ && FIND_REG_INC_NOTE (succ, dest))\n+      || (succ2 && FIND_REG_INC_NOTE (succ2, dest))\n       /* Don't substitute into a non-local goto, this confuses CFG.  */\n       || (JUMP_P (i3) && find_reg_note (i3, REG_NON_LOCAL_GOTO, NULL_RTX))\n       /* Make sure that DEST is not used after SUCC but before I3.  */\n-      || (succ && ! all_adjacent\n-\t  && reg_used_between_p (dest, succ, i3))\n+      || (!all_adjacent\n+\t  && ((succ2\n+\t       && (reg_used_between_p (dest, succ2, i3)\n+\t\t   || reg_used_between_p (dest, succ, succ2)))\n+\t      || (!succ2 && succ && reg_used_between_p (dest, succ, i3))))\n       /* Make sure that the value that is to be substituted for the register\n \t does not use any registers whose values alter in between.  However,\n \t If the insns are adjacent, a use can't cross a set even though we\n@@ -1765,13 +1875,12 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \n   if (GET_CODE (src) == ASM_OPERANDS || volatile_refs_p (src))\n     {\n-      /* Make sure succ doesn't contain a volatile reference.  */\n+      /* Make sure neither succ nor succ2 contains a volatile reference.  */\n+      if (succ2 != 0 && volatile_refs_p (PATTERN (succ2)))\n+\treturn 0;\n       if (succ != 0 && volatile_refs_p (PATTERN (succ)))\n \treturn 0;\n-\n-      for (p = NEXT_INSN (insn); p != i3; p = NEXT_INSN (p))\n-\tif (INSN_P (p) && p != succ && volatile_refs_p (PATTERN (p)))\n-\t  return 0;\n+      /* We'll check insns between INSN and I3 below.  */\n     }\n \n   /* If INSN is an asm, and DEST is a hard register, reject, since it has\n@@ -1785,7 +1894,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n      they might affect machine state.  */\n \n   for (p = NEXT_INSN (insn); p != i3; p = NEXT_INSN (p))\n-    if (INSN_P (p) && p != succ && volatile_insn_p (PATTERN (p)))\n+    if (INSN_P (p) && p != succ && p != succ2 && volatile_insn_p (PATTERN (p)))\n       return 0;\n \n   /* If INSN contains an autoincrement or autodecrement, make sure that\n@@ -1801,8 +1910,12 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \t    || reg_used_between_p (XEXP (link, 0), insn, i3)\n \t    || (pred != NULL_RTX\n \t\t&& reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (pred)))\n+\t    || (pred2 != NULL_RTX\n+\t\t&& reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (pred2)))\n \t    || (succ != NULL_RTX\n \t\t&& reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (succ)))\n+\t    || (succ2 != NULL_RTX\n+\t\t&& reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (succ2)))\n \t    || reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (i3))))\n       return 0;\n #endif\n@@ -1836,8 +1949,8 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n    of a PARALLEL of the pattern.  We validate that it is valid for combining.\n \n    One problem is if I3 modifies its output, as opposed to replacing it\n-   entirely, we can't allow the output to contain I2DEST or I1DEST as doing\n-   so would produce an insn that is not equivalent to the original insns.\n+   entirely, we can't allow the output to contain I2DEST, I1DEST or I0DEST as\n+   doing so would produce an insn that is not equivalent to the original insns.\n \n    Consider:\n \n@@ -1858,7 +1971,8 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n    must reject the combination.  This case occurs when I2 and I1 both\n    feed into I3, rather than when I1 feeds into I2, which feeds into I3.\n    If I1_NOT_IN_SRC is nonzero, it means that finding I1 in the source\n-   of a SET must prevent combination from occurring.\n+   of a SET must prevent combination from occurring.  The same situation\n+   can occur for I0, in which case I0_NOT_IN_SRC is set.\n \n    Before doing the above check, we first try to expand a field assignment\n    into a set of logical operations.\n@@ -1870,8 +1984,8 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n    Return 1 if the combination is valid, zero otherwise.  */\n \n static int\n-combinable_i3pat (rtx i3, rtx *loc, rtx i2dest, rtx i1dest,\n-\t\t  int i1_not_in_src, rtx *pi3dest_killed)\n+combinable_i3pat (rtx i3, rtx *loc, rtx i2dest, rtx i1dest, rtx i0dest,\n+\t\t  int i1_not_in_src, int i0_not_in_src, rtx *pi3dest_killed)\n {\n   rtx x = *loc;\n \n@@ -1895,9 +2009,11 @@ combinable_i3pat (rtx i3, rtx *loc, rtx i2dest, rtx i1dest,\n       if ((inner_dest != dest &&\n \t   (!MEM_P (inner_dest)\n \t    || rtx_equal_p (i2dest, inner_dest)\n-\t    || (i1dest && rtx_equal_p (i1dest, inner_dest)))\n+\t    || (i1dest && rtx_equal_p (i1dest, inner_dest))\n+\t    || (i0dest && rtx_equal_p (i0dest, inner_dest)))\n \t   && (reg_overlap_mentioned_p (i2dest, inner_dest)\n-\t       || (i1dest && reg_overlap_mentioned_p (i1dest, inner_dest))))\n+\t       || (i1dest && reg_overlap_mentioned_p (i1dest, inner_dest))\n+\t       || (i0dest && reg_overlap_mentioned_p (i0dest, inner_dest))))\n \n \t  /* This is the same test done in can_combine_p except we can't test\n \t     all_adjacent; we don't have to, since this instruction will stay\n@@ -1913,7 +2029,8 @@ combinable_i3pat (rtx i3, rtx *loc, rtx i2dest, rtx i1dest,\n \t      && REGNO (inner_dest) < FIRST_PSEUDO_REGISTER\n \t      && (! HARD_REGNO_MODE_OK (REGNO (inner_dest),\n \t\t\t\t\tGET_MODE (inner_dest))))\n-\t  || (i1_not_in_src && reg_overlap_mentioned_p (i1dest, src)))\n+\t  || (i1_not_in_src && reg_overlap_mentioned_p (i1dest, src))\n+\t  || (i0_not_in_src && reg_overlap_mentioned_p (i0dest, src)))\n \treturn 0;\n \n       /* If DEST is used in I3, it is being killed in this insn, so\n@@ -1953,8 +2070,8 @@ combinable_i3pat (rtx i3, rtx *loc, rtx i2dest, rtx i1dest,\n       int i;\n \n       for (i = 0; i < XVECLEN (x, 0); i++)\n-\tif (! combinable_i3pat (i3, &XVECEXP (x, 0, i), i2dest, i1dest,\n-\t\t\t\ti1_not_in_src, pi3dest_killed))\n+\tif (! combinable_i3pat (i3, &XVECEXP (x, 0, i), i2dest, i1dest, i0dest,\n+\t\t\t\ti1_not_in_src, i0_not_in_src, pi3dest_killed))\n \t  return 0;\n     }\n \n@@ -2364,15 +2481,15 @@ update_cfg_for_uncondjump (rtx insn)\n     single_succ_edge (bb)->flags |= EDGE_FALLTHRU;\n }\n \n+/* Try to combine the insns I0, I1 and I2 into I3.\n+   Here I0, I1 and I2 appear earlier than I3.\n+   I0 and I1 can be zero; then we combine just I2 into I3, or I1 and I2 into\n+   I3.\n \n-/* Try to combine the insns I1 and I2 into I3.\n-   Here I1 and I2 appear earlier than I3.\n-   I1 can be zero; then we combine just I2 into I3.\n-\n-   If we are combining three insns and the resulting insn is not recognized,\n-   try splitting it into two insns.  If that happens, I2 and I3 are retained\n-   and I1 is pseudo-deleted by turning it into a NOTE.  Otherwise, I1 and I2\n-   are pseudo-deleted.\n+   If we are combining more than two insns and the resulting insn is not\n+   recognized, try splitting it into two insns.  If that happens, I2 and I3\n+   are retained and I1/I0 are pseudo-deleted by turning them into a NOTE.\n+   Otherwise, I0, I1 and I2 are pseudo-deleted.\n \n    Return 0 if the combination does not work.  Then nothing is changed.\n    If we did the combination, return the insn at which combine should\n@@ -2382,34 +2499,36 @@ update_cfg_for_uncondjump (rtx insn)\n    new direct jump instruction.  */\n \n static rtx\n-try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n+try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n {\n   /* New patterns for I3 and I2, respectively.  */\n   rtx newpat, newi2pat = 0;\n   rtvec newpat_vec_with_clobbers = 0;\n-  int substed_i2 = 0, substed_i1 = 0;\n-  /* Indicates need to preserve SET in I1 or I2 in I3 if it is not dead.  */\n-  int added_sets_1, added_sets_2;\n+  int substed_i2 = 0, substed_i1 = 0, substed_i0 = 0;\n+  /* Indicates need to preserve SET in I0, I1 or I2 in I3 if it is not\n+     dead.  */\n+  int added_sets_0, added_sets_1, added_sets_2;\n   /* Total number of SETs to put into I3.  */\n   int total_sets;\n-  /* Nonzero if I2's body now appears in I3.  */\n-  int i2_is_used;\n+  /* Nonzero if I2's or I1's body now appears in I3.  */\n+  int i2_is_used, i1_is_used;\n   /* INSN_CODEs for new I3, new I2, and user of condition code.  */\n   int insn_code_number, i2_code_number = 0, other_code_number = 0;\n   /* Contains I3 if the destination of I3 is used in its source, which means\n      that the old life of I3 is being killed.  If that usage is placed into\n      I2 and not in I3, a REG_DEAD note must be made.  */\n   rtx i3dest_killed = 0;\n-  /* SET_DEST and SET_SRC of I2 and I1.  */\n-  rtx i2dest = 0, i2src = 0, i1dest = 0, i1src = 0;\n+  /* SET_DEST and SET_SRC of I2, I1 and I0.  */\n+  rtx i2dest = 0, i2src = 0, i1dest = 0, i1src = 0, i0dest = 0, i0src = 0;\n   /* Set if I2DEST was reused as a scratch register.  */\n   bool i2scratch = false;\n-  /* PATTERN (I1) and PATTERN (I2), or a copy of it in certain cases.  */\n-  rtx i1pat = 0, i2pat = 0;\n+  /* The PATTERNs of I0, I1, and I2, or a copy of them in certain cases.  */\n+  rtx i0pat = 0, i1pat = 0, i2pat = 0;\n   /* Indicates if I2DEST or I1DEST is in I2SRC or I1_SRC.  */\n   int i2dest_in_i2src = 0, i1dest_in_i1src = 0, i2dest_in_i1src = 0;\n-  int i2dest_killed = 0, i1dest_killed = 0;\n-  int i1_feeds_i3 = 0;\n+  int i0dest_in_i0src = 0, i1dest_in_i0src = 0, i2dest_in_i0src = 0;\n+  int i2dest_killed = 0, i1dest_killed = 0, i0dest_killed = 0;\n+  int i1_feeds_i2_n = 0, i0_feeds_i2_n = 0, i0_feeds_i1_n = 0;\n   /* Notes that must be added to REG_NOTES in I3 and I2.  */\n   rtx new_i3_notes, new_i2_notes;\n   /* Notes that we substituted I3 into I2 instead of the normal case.  */\n@@ -2426,11 +2545,47 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n   rtx new_other_notes;\n   int i;\n \n+  /* Only try four-insn combinations when there's high likelihood of\n+     success.  Look for simple insns, such as loads of constants, unary\n+     operations, or binary operations involving a constant.  */\n+  if (i0)\n+    {\n+      int i;\n+      int ngood = 0;\n+      int nshift = 0;\n+\n+      if (!flag_expensive_optimizations)\n+\treturn 0;\n+\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  rtx insn = i == 0 ? i0 : i == 1 ? i1 : i == 2 ? i2 : i3;\n+\t  rtx set = single_set (insn);\n+\t  rtx src;\n+\t  if (!set)\n+\t    continue;\n+\t  src = SET_SRC (set);\n+\t  if (CONSTANT_P (src))\n+\t    {\n+\t      ngood += 2;\n+\t      break;\n+\t    }\n+\t  else if (BINARY_P (src) && CONSTANT_P (XEXP (src, 1)))\n+\t    ngood++;\n+\t  else if (GET_CODE (src) == ASHIFT || GET_CODE (src) == ASHIFTRT\n+\t\t   || GET_CODE (src) == LSHIFTRT)\n+\t    nshift++;\n+\t}\n+      if (ngood < 2 && nshift < 2)\n+\treturn 0;\n+    }\n+\n   /* Exit early if one of the insns involved can't be used for\n      combinations.  */\n   if (cant_combine_insn_p (i3)\n       || cant_combine_insn_p (i2)\n       || (i1 && cant_combine_insn_p (i1))\n+      || (i0 && cant_combine_insn_p (i0))\n       || likely_spilled_retval_p (i3))\n     return 0;\n \n@@ -2442,16 +2597,23 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      if (i1)\n+      if (i0)\n+\tfprintf (dump_file, \"\\nTrying %d, %d, %d -> %d:\\n\",\n+\t\t INSN_UID (i0), INSN_UID (i1), INSN_UID (i2), INSN_UID (i3));\n+      else if (i1)\n \tfprintf (dump_file, \"\\nTrying %d, %d -> %d:\\n\",\n \t\t INSN_UID (i1), INSN_UID (i2), INSN_UID (i3));\n       else\n \tfprintf (dump_file, \"\\nTrying %d -> %d:\\n\",\n \t\t INSN_UID (i2), INSN_UID (i3));\n     }\n \n-  /* If I1 and I2 both feed I3, they can be in any order.  To simplify the\n-     code below, set I1 to be the earlier of the two insns.  */\n+  /* If multiple insns feed into one of I2 or I3, they can be in any\n+     order.  To simplify the code below, reorder them in sequence.  */\n+  if (i0 && DF_INSN_LUID (i0) > DF_INSN_LUID (i2))\n+    temp = i2, i2 = i0, i0 = temp;\n+  if (i0 && DF_INSN_LUID (i0) > DF_INSN_LUID (i1))\n+    temp = i1, i1 = i0, i0 = temp;\n   if (i1 && DF_INSN_LUID (i1) > DF_INSN_LUID (i2))\n     temp = i1, i1 = i2, i2 = temp;\n \n@@ -2519,7 +2681,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t      subst_insn = i3;\n \t      subst_low_luid = DF_INSN_LUID (i2);\n \n-\t      added_sets_2 = added_sets_1 = 0;\n+\t      added_sets_2 = added_sets_1 = added_sets_0 = 0;\n \t      i2src = SET_DEST (PATTERN (i3));\n \t      i2dest = SET_SRC (PATTERN (i3));\n \t      i2dest_killed = dead_or_set_p (i2, i2dest);\n@@ -2606,7 +2768,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  combine_merges++;\n \t  subst_insn = i3;\n \t  subst_low_luid = DF_INSN_LUID (i2);\n-\t  added_sets_2 = added_sets_1 = 0;\n+\t  added_sets_2 = added_sets_1 = added_sets_0 = 0;\n \t  i2dest = SET_DEST (temp);\n \t  i2dest_killed = dead_or_set_p (i2, i2dest);\n \n@@ -2673,8 +2835,11 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n #endif\n \n   /* Verify that I2 and I1 are valid for combining.  */\n-  if (! can_combine_p (i2, i3, i1, NULL_RTX, &i2dest, &i2src)\n-      || (i1 && ! can_combine_p (i1, i3, NULL_RTX, i2, &i1dest, &i1src)))\n+  if (! can_combine_p (i2, i3, i0, i1, NULL_RTX, NULL_RTX, &i2dest, &i2src)\n+      || (i1 && ! can_combine_p (i1, i3, i0, NULL_RTX, i2, NULL_RTX,\n+\t\t\t\t &i1dest, &i1src))\n+      || (i0 && ! can_combine_p (i0, i3, NULL_RTX, NULL_RTX, i1, i2,\n+\t\t\t\t &i0dest, &i0src)))\n     {\n       undo_all ();\n       return 0;\n@@ -2685,16 +2850,26 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n   i2dest_in_i2src = reg_overlap_mentioned_p (i2dest, i2src);\n   i1dest_in_i1src = i1 && reg_overlap_mentioned_p (i1dest, i1src);\n   i2dest_in_i1src = i1 && reg_overlap_mentioned_p (i2dest, i1src);\n+  i0dest_in_i0src = i0 && reg_overlap_mentioned_p (i0dest, i0src);\n+  i1dest_in_i0src = i0 && reg_overlap_mentioned_p (i1dest, i0src);\n+  i2dest_in_i0src = i0 && reg_overlap_mentioned_p (i2dest, i0src);\n   i2dest_killed = dead_or_set_p (i2, i2dest);\n   i1dest_killed = i1 && dead_or_set_p (i1, i1dest);\n+  i0dest_killed = i0 && dead_or_set_p (i0, i0dest);\n \n-  /* See if I1 directly feeds into I3.  It does if I1DEST is not used\n-     in I2SRC.  */\n-  i1_feeds_i3 = i1 && ! reg_overlap_mentioned_p (i1dest, i2src);\n+  /* For the earlier insns, determine which of the subsequent ones they\n+     feed.  */\n+  i1_feeds_i2_n = i1 && insn_a_feeds_b (i1, i2);\n+  i0_feeds_i1_n = i0 && insn_a_feeds_b (i0, i1);\n+  i0_feeds_i2_n = (i0 && (!i0_feeds_i1_n ? insn_a_feeds_b (i0, i2)\n+\t\t\t  : (!dead_or_set_p (i1, i0dest)\n+\t\t\t     && reg_overlap_mentioned_p (i0dest, i2src))));\n \n   /* Ensure that I3's pattern can be the destination of combines.  */\n-  if (! combinable_i3pat (i3, &PATTERN (i3), i2dest, i1dest,\n-\t\t\t  i1 && i2dest_in_i1src && i1_feeds_i3,\n+  if (! combinable_i3pat (i3, &PATTERN (i3), i2dest, i1dest, i0dest,\n+\t\t\t  i1 && i2dest_in_i1src && !i1_feeds_i2_n,\n+\t\t\t  i0 && ((i2dest_in_i0src && !i0_feeds_i2_n)\n+\t\t\t\t || (i1dest_in_i0src && !i0_feeds_i1_n)),\n \t\t\t  &i3dest_killed))\n     {\n       undo_all ();\n@@ -2706,6 +2881,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n      here.  */\n   if (GET_CODE (i2src) == MULT\n       || (i1 != 0 && GET_CODE (i1src) == MULT)\n+      || (i0 != 0 && GET_CODE (i0src) == MULT)\n       || (GET_CODE (PATTERN (i3)) == SET\n \t  && GET_CODE (SET_SRC (PATTERN (i3))) == MULT))\n     have_mult = 1;\n@@ -2745,14 +2921,22 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n      feed into I3, the set in I1 needs to be kept around if I1DEST dies\n      or is set in I3.  Otherwise (if I1 feeds I2 which feeds I3), the set\n      in I1 needs to be kept around unless I1DEST dies or is set in either\n-     I2 or I3.  We can distinguish these cases by seeing if I2SRC mentions\n-     I1DEST.  If so, we know I1 feeds into I2.  */\n+     I2 or I3.  The same consideration applies to I0.  */\n+\n+  added_sets_2 = !dead_or_set_p (i3, i2dest);\n \n-  added_sets_2 = ! dead_or_set_p (i3, i2dest);\n+  if (i1)\n+    added_sets_1 = !(dead_or_set_p (i3, i1dest)\n+\t\t     || (i1_feeds_i2_n && dead_or_set_p (i2, i1dest)));\n+  else\n+    added_sets_1 = 0;\n \n-  added_sets_1\n-    = i1 && ! (i1_feeds_i3 ? dead_or_set_p (i3, i1dest)\n-\t       : (dead_or_set_p (i3, i1dest) || dead_or_set_p (i2, i1dest)));\n+  if (i0)\n+    added_sets_0 =  !(dead_or_set_p (i3, i0dest)\n+\t\t      || (i0_feeds_i2_n && dead_or_set_p (i2, i0dest))\n+\t\t      || (i0_feeds_i1_n && dead_or_set_p (i1, i0dest)));\n+  else\n+    added_sets_0 = 0;\n \n   /* If the set in I2 needs to be kept around, we must make a copy of\n      PATTERN (I2), so that when we substitute I1SRC for I1DEST in\n@@ -2777,6 +2961,14 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \ti1pat = copy_rtx (PATTERN (i1));\n     }\n \n+  if (added_sets_0)\n+    {\n+      if (GET_CODE (PATTERN (i0)) == PARALLEL)\n+\ti0pat = gen_rtx_SET (VOIDmode, i0dest, copy_rtx (i0src));\n+      else\n+\ti0pat = copy_rtx (PATTERN (i0));\n+    }\n+\n   combine_merges++;\n \n   /* Substitute in the latest insn for the regs set by the earlier ones.  */\n@@ -2825,8 +3017,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t\t\t\t\t      i2src, const0_rtx))\n \t      != GET_MODE (SET_DEST (newpat))))\n \t{\n-\t  if (can_change_dest_mode(SET_DEST (newpat), added_sets_2,\n-\t\t\t\t   compare_mode))\n+\t  if (can_change_dest_mode (SET_DEST (newpat), added_sets_2,\n+\t\t\t\t    compare_mode))\n \t    {\n \t      unsigned int regno = REGNO (SET_DEST (newpat));\n \t      rtx new_dest;\n@@ -2889,13 +3081,14 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n       n_occurrences = 0;\t\t/* `subst' counts here */\n \n-      /* If I1 feeds into I2 (not into I3) and I1DEST is in I1SRC, we\n-\t need to make a unique copy of I2SRC each time we substitute it\n-\t to avoid self-referential rtl.  */\n+      /* If I1 feeds into I2 and I1DEST is in I1SRC, we need to make a\n+\t unique copy of I2SRC each time we substitute it to avoid\n+\t self-referential rtl.  */\n \n       subst_low_luid = DF_INSN_LUID (i2);\n       newpat = subst (PATTERN (i3), i2dest, i2src, 0,\n-\t\t      ! i1_feeds_i3 && i1dest_in_i1src);\n+\t\t      ((i1_feeds_i2_n && i1dest_in_i1src)\n+\t\t       || (i0_feeds_i2_n && i0dest_in_i0src)));\n       substed_i2 = 1;\n \n       /* Record whether i2's body now appears within i3's body.  */\n@@ -2911,30 +3104,57 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t This happens if I1DEST is mentioned in I2 and dies there, and\n \t has disappeared from the new pattern.  */\n       if ((FIND_REG_INC_NOTE (i1, NULL_RTX) != 0\n-\t   && !i1_feeds_i3\n+\t   && i1_feeds_i2_n\n \t   && dead_or_set_p (i2, i1dest)\n \t   && !reg_overlap_mentioned_p (i1dest, newpat))\n \t  /* Before we can do this substitution, we must redo the test done\n \t     above (see detailed comments there) that ensures  that I1DEST\n \t     isn't mentioned in any SETs in NEWPAT that are field assignments.  */\n-          || !combinable_i3pat (NULL_RTX, &newpat, i1dest, NULL_RTX, 0, 0))\n+          || !combinable_i3pat (NULL_RTX, &newpat, i1dest, NULL_RTX, NULL_RTX,\n+\t\t\t\t0, 0, 0))\n \t{\n \t  undo_all ();\n \t  return 0;\n \t}\n \n       n_occurrences = 0;\n       subst_low_luid = DF_INSN_LUID (i1);\n-      newpat = subst (newpat, i1dest, i1src, 0, 0);\n+      newpat = subst (newpat, i1dest, i1src, 0,\n+\t\t      i0_feeds_i1_n && i0dest_in_i0src);\n       substed_i1 = 1;\n+      i1_is_used = n_occurrences;\n+    }\n+  if (i0 && GET_CODE (newpat) != CLOBBER)\n+    {\n+      if ((FIND_REG_INC_NOTE (i0, NULL_RTX) != 0\n+\t   && ((i0_feeds_i2_n && dead_or_set_p (i2, i0dest))\n+\t       || (i0_feeds_i1_n && dead_or_set_p (i1, i0dest)))\n+\t   && !reg_overlap_mentioned_p (i0dest, newpat))\n+          || !combinable_i3pat (NULL_RTX, &newpat, i0dest, NULL_RTX, NULL_RTX,\n+\t\t\t\t0, 0, 0))\n+\t{\n+\t  undo_all ();\n+\t  return 0;\n+\t}\n+\n+      n_occurrences = 0;\n+      subst_low_luid = DF_INSN_LUID (i1);\n+      newpat = subst (newpat, i0dest, i0src, 0,\n+\t\t      i0_feeds_i1_n && i0dest_in_i0src);\n+      substed_i0 = 1;\n     }\n \n   /* Fail if an autoincrement side-effect has been duplicated.  Be careful\n      to count all the ways that I2SRC and I1SRC can be used.  */\n   if ((FIND_REG_INC_NOTE (i2, NULL_RTX) != 0\n        && i2_is_used + added_sets_2 > 1)\n       || (i1 != 0 && FIND_REG_INC_NOTE (i1, NULL_RTX) != 0\n-\t  && (n_occurrences + added_sets_1 + (added_sets_2 && ! i1_feeds_i3)\n+\t  && (i1_is_used + added_sets_1 + (added_sets_2 && i1_feeds_i2_n)\n+\t      > 1))\n+      || (i0 != 0 && FIND_REG_INC_NOTE (i0, NULL_RTX) != 0\n+\t  && (n_occurrences + added_sets_0\n+\t      + (added_sets_1 && i0_feeds_i1_n)\n+\t      + (added_sets_2 && i0_feeds_i2_n)\n \t      > 1))\n       /* Fail if we tried to make a new register.  */\n       || max_reg_num () != maxreg\n@@ -2954,40 +3174,47 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n      we must make a new PARALLEL for the latest insn\n      to hold additional the SETs.  */\n \n-  if (added_sets_1 || added_sets_2)\n+  if (added_sets_0 || added_sets_1 || added_sets_2)\n     {\n+      int extra_sets = added_sets_0 + added_sets_1 + added_sets_2;\n       combine_extras++;\n \n       if (GET_CODE (newpat) == PARALLEL)\n \t{\n \t  rtvec old = XVEC (newpat, 0);\n-\t  total_sets = XVECLEN (newpat, 0) + added_sets_1 + added_sets_2;\n+\t  total_sets = XVECLEN (newpat, 0) + extra_sets;\n \t  newpat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (total_sets));\n \t  memcpy (XVEC (newpat, 0)->elem, &old->elem[0],\n \t\t  sizeof (old->elem[0]) * old->num_elem);\n \t}\n       else\n \t{\n \t  rtx old = newpat;\n-\t  total_sets = 1 + added_sets_1 + added_sets_2;\n+\t  total_sets = 1 + extra_sets;\n \t  newpat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (total_sets));\n \t  XVECEXP (newpat, 0, 0) = old;\n \t}\n \n+      if (added_sets_0)\n+\tXVECEXP (newpat, 0, --total_sets) = i0pat;\n+\n       if (added_sets_1)\n-\tXVECEXP (newpat, 0, --total_sets) = i1pat;\n+\t{\n+\t  rtx t = i1pat;\n+\t  if (i0_feeds_i1_n)\n+\t    t = subst (t, i0dest, i0src, 0, 0);\n \n+\t  XVECEXP (newpat, 0, --total_sets) = t;\n+\t}\n       if (added_sets_2)\n \t{\n-\t  /* If there is no I1, use I2's body as is.  We used to also not do\n-\t     the subst call below if I2 was substituted into I3,\n-\t     but that could lose a simplification.  */\n-\t  if (i1 == 0)\n-\t    XVECEXP (newpat, 0, --total_sets) = i2pat;\n-\t  else\n-\t    /* See comment where i2pat is assigned.  */\n-\t    XVECEXP (newpat, 0, --total_sets)\n-\t      = subst (i2pat, i1dest, i1src, 0, 0);\n+\t  rtx t = i2pat;\n+\t  if (i0_feeds_i2_n)\n+\t    t = subst (t, i0dest, i0src, 0, 0);\n+\t  if (i1_feeds_i2_n)\n+\t    t = subst (t, i1dest, i1src, 0, 0);\n+\n+\t  XVECEXP (newpat, 0, --total_sets) = t;\n \t}\n     }\n \n@@ -3543,7 +3770,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n   /* Only allow this combination if insn_rtx_costs reports that the\n      replacement instructions are cheaper than the originals.  */\n-  if (!combine_validate_cost (i1, i2, i3, newpat, newi2pat, other_pat))\n+  if (!combine_validate_cost (i0, i1, i2, i3, newpat, newi2pat, other_pat))\n     {\n       undo_all ();\n       return 0;\n@@ -3642,7 +3869,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t}\n \n       distribute_notes (new_other_notes, undobuf.other_insn,\n-\t\t\tundobuf.other_insn, NULL_RTX, NULL_RTX, NULL_RTX);\n+\t\t\tundobuf.other_insn, NULL_RTX, NULL_RTX, NULL_RTX,\n+\t\t\tNULL_RTX);\n     }\n \n   if (swap_i2i3)\n@@ -3689,28 +3917,35 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n     }\n \n   {\n-    rtx i3notes, i2notes, i1notes = 0;\n-    rtx i3links, i2links, i1links = 0;\n+    rtx i3notes, i2notes, i1notes = 0, i0notes = 0;\n+    rtx i3links, i2links, i1links = 0, i0links = 0;\n     rtx midnotes = 0;\n+    int from_luid;\n     unsigned int regno;\n     /* Compute which registers we expect to eliminate.  newi2pat may be setting\n        either i3dest or i2dest, so we must check it.  Also, i1dest may be the\n        same as i3dest, in which case newi2pat may be setting i1dest.  */\n     rtx elim_i2 = ((newi2pat && reg_set_p (i2dest, newi2pat))\n-\t\t   || i2dest_in_i2src || i2dest_in_i1src\n+\t\t   || i2dest_in_i2src || i2dest_in_i1src || i2dest_in_i0src\n \t\t   || !i2dest_killed\n \t\t   ? 0 : i2dest);\n-    rtx elim_i1 = (i1 == 0 || i1dest_in_i1src\n+    rtx elim_i1 = (i1 == 0 || i1dest_in_i1src || i1dest_in_i0src\n \t\t   || (newi2pat && reg_set_p (i1dest, newi2pat))\n \t\t   || !i1dest_killed\n \t\t   ? 0 : i1dest);\n+    rtx elim_i0 = (i0 == 0 || i0dest_in_i0src\n+\t\t   || (newi2pat && reg_set_p (i0dest, newi2pat))\n+\t\t   || !i0dest_killed\n+\t\t   ? 0 : i0dest);\n \n     /* Get the old REG_NOTES and LOG_LINKS from all our insns and\n        clear them.  */\n     i3notes = REG_NOTES (i3), i3links = LOG_LINKS (i3);\n     i2notes = REG_NOTES (i2), i2links = LOG_LINKS (i2);\n     if (i1)\n       i1notes = REG_NOTES (i1), i1links = LOG_LINKS (i1);\n+    if (i0)\n+      i0notes = REG_NOTES (i0), i0links = LOG_LINKS (i0);\n \n     /* Ensure that we do not have something that should not be shared but\n        occurs multiple times in the new insns.  Check this by first\n@@ -3719,6 +3954,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n     reset_used_flags (i3notes);\n     reset_used_flags (i2notes);\n     reset_used_flags (i1notes);\n+    reset_used_flags (i0notes);\n     reset_used_flags (newpat);\n     reset_used_flags (newi2pat);\n     if (undobuf.other_insn)\n@@ -3727,6 +3963,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n     i3notes = copy_rtx_if_shared (i3notes);\n     i2notes = copy_rtx_if_shared (i2notes);\n     i1notes = copy_rtx_if_shared (i1notes);\n+    i0notes = copy_rtx_if_shared (i0notes);\n     newpat = copy_rtx_if_shared (newpat);\n     newi2pat = copy_rtx_if_shared (newi2pat);\n     if (undobuf.other_insn)\n@@ -3753,6 +3990,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n \tif (substed_i1)\n \t  replace_rtx (call_usage, i1dest, i1src);\n+\tif (substed_i0)\n+\t  replace_rtx (call_usage, i0dest, i0src);\n \n \tCALL_INSN_FUNCTION_USAGE (i3) = call_usage;\n       }\n@@ -3827,43 +4066,58 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \tSET_INSN_DELETED (i1);\n       }\n \n+    if (i0)\n+      {\n+\tLOG_LINKS (i0) = 0;\n+\tREG_NOTES (i0) = 0;\n+\tif (MAY_HAVE_DEBUG_INSNS)\n+\t  propagate_for_debug (i0, i3, i0dest, i0src, false);\n+\tSET_INSN_DELETED (i0);\n+      }\n+\n     /* Get death notes for everything that is now used in either I3 or\n        I2 and used to die in a previous insn.  If we built two new\n        patterns, move from I1 to I2 then I2 to I3 so that we get the\n        proper movement on registers that I2 modifies.  */\n \n-    if (newi2pat)\n-      {\n-\tmove_deaths (newi2pat, NULL_RTX, DF_INSN_LUID (i1), i2, &midnotes);\n-\tmove_deaths (newpat, newi2pat, DF_INSN_LUID (i1), i3, &midnotes);\n-      }\n+    if (i0)\n+      from_luid = DF_INSN_LUID (i0);\n+    else if (i1)\n+      from_luid = DF_INSN_LUID (i1);\n     else\n-      move_deaths (newpat, NULL_RTX, i1 ? DF_INSN_LUID (i1) : DF_INSN_LUID (i2),\n-\t\t   i3, &midnotes);\n+      from_luid = DF_INSN_LUID (i2);\n+    if (newi2pat)\n+      move_deaths (newi2pat, NULL_RTX, from_luid, i2, &midnotes);\n+    move_deaths (newpat, newi2pat, from_luid, i3, &midnotes);\n \n     /* Distribute all the LOG_LINKS and REG_NOTES from I1, I2, and I3.  */\n     if (i3notes)\n       distribute_notes (i3notes, i3, i3, newi2pat ? i2 : NULL_RTX,\n-\t\t\telim_i2, elim_i1);\n+\t\t\telim_i2, elim_i1, elim_i0);\n     if (i2notes)\n       distribute_notes (i2notes, i2, i3, newi2pat ? i2 : NULL_RTX,\n-\t\t\telim_i2, elim_i1);\n+\t\t\telim_i2, elim_i1, elim_i0);\n     if (i1notes)\n       distribute_notes (i1notes, i1, i3, newi2pat ? i2 : NULL_RTX,\n-\t\t\telim_i2, elim_i1);\n+\t\t\telim_i2, elim_i1, elim_i0);\n+    if (i0notes)\n+      distribute_notes (i0notes, i0, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\telim_i2, elim_i1, elim_i0);\n     if (midnotes)\n       distribute_notes (midnotes, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n-\t\t\telim_i2, elim_i1);\n+\t\t\telim_i2, elim_i1, elim_i0);\n \n     /* Distribute any notes added to I2 or I3 by recog_for_combine.  We\n        know these are REG_UNUSED and want them to go to the desired insn,\n        so we always pass it as i3.  */\n \n     if (newi2pat && new_i2_notes)\n-      distribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n+      distribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX,\n+\t\t\tNULL_RTX);\n \n     if (new_i3_notes)\n-      distribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX);\n+      distribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX,\n+\t\t\tNULL_RTX);\n \n     /* If I3DEST was used in I3SRC, it really died in I3.  We may need to\n        put a REG_DEAD note for it somewhere.  If NEWI2PAT exists and sets\n@@ -3877,39 +4131,51 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \tif (newi2pat && reg_set_p (i3dest_killed, newi2pat))\n \t  distribute_notes (alloc_reg_note (REG_DEAD, i3dest_killed,\n \t\t\t\t\t    NULL_RTX),\n-\t\t\t    NULL_RTX, i2, NULL_RTX, elim_i2, elim_i1);\n+\t\t\t    NULL_RTX, i2, NULL_RTX, elim_i2, elim_i1, elim_i0);\n \telse\n \t  distribute_notes (alloc_reg_note (REG_DEAD, i3dest_killed,\n \t\t\t\t\t    NULL_RTX),\n \t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n-\t\t\t    elim_i2, elim_i1);\n+\t\t\t    elim_i2, elim_i1, elim_i0);\n       }\n \n     if (i2dest_in_i2src)\n       {\n+\trtx new_note = alloc_reg_note (REG_DEAD, i2dest, NULL_RTX);\n \tif (newi2pat && reg_set_p (i2dest, newi2pat))\n-\t  distribute_notes (alloc_reg_note (REG_DEAD, i2dest, NULL_RTX),\n-\t\t\t    NULL_RTX, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n-\telse\n-\t  distribute_notes (alloc_reg_note (REG_DEAD, i2dest, NULL_RTX),\n-\t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t  distribute_notes (new_note,  NULL_RTX, i2, NULL_RTX, NULL_RTX,\n \t\t\t    NULL_RTX, NULL_RTX);\n+\telse\n+\t  distribute_notes (new_note, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n \n     if (i1dest_in_i1src)\n       {\n+\trtx new_note = alloc_reg_note (REG_DEAD, i1dest, NULL_RTX);\n \tif (newi2pat && reg_set_p (i1dest, newi2pat))\n-\t  distribute_notes (alloc_reg_note (REG_DEAD, i1dest, NULL_RTX),\n-\t\t\t    NULL_RTX, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n+\t  distribute_notes (new_note, NULL_RTX, i2, NULL_RTX, NULL_RTX,\n+\t\t\t    NULL_RTX, NULL_RTX);\n \telse\n-\t  distribute_notes (alloc_reg_note (REG_DEAD, i1dest, NULL_RTX),\n-\t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t  distribute_notes (new_note, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n+      }\n+\n+    if (i0dest_in_i0src)\n+      {\n+\trtx new_note = alloc_reg_note (REG_DEAD, i0dest, NULL_RTX);\n+\tif (newi2pat && reg_set_p (i0dest, newi2pat))\n+\t  distribute_notes (new_note, NULL_RTX, i2, NULL_RTX, NULL_RTX,\n \t\t\t    NULL_RTX, NULL_RTX);\n+\telse\n+\t  distribute_notes (new_note, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n \n     distribute_links (i3links);\n     distribute_links (i2links);\n     distribute_links (i1links);\n+    distribute_links (i0links);\n \n     if (REG_P (i2dest))\n       {\n@@ -3959,6 +4225,23 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  INC_REG_N_SETS (regno, -1);\n       }\n \n+    if (i0 && REG_P (i0dest))\n+      {\n+\trtx link;\n+\trtx i0_insn = 0, i0_val = 0, set;\n+\n+\tfor (link = LOG_LINKS (i3); link; link = XEXP (link, 1))\n+\t  if ((set = single_set (XEXP (link, 0))) != 0\n+\t      && rtx_equal_p (i0dest, SET_DEST (set)))\n+\t    i0_insn = XEXP (link, 0), i0_val = SET_SRC (set);\n+\n+\trecord_value_for_reg (i0dest, i0_insn, i0_val);\n+\n+\tregno = REGNO (i0dest);\n+\tif (! added_sets_0 && ! i0dest_in_i0src)\n+\t  INC_REG_N_SETS (regno, -1);\n+      }\n+\n     /* Update reg_stat[].nonzero_bits et al for any changes that may have\n        been made to this insn.  The order of\n        set_nonzero_bits_and_sign_copies() is important.  Because newi2pat\n@@ -3978,6 +4261,16 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       df_insn_rescan (undobuf.other_insn);\n     }\n \n+  if (i0 && !(NOTE_P(i0) && (NOTE_KIND (i0) == NOTE_INSN_DELETED)))\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"modifying insn i1 \");\n+\t  dump_insn_slim (dump_file, i0);\n+\t}\n+      df_insn_rescan (i0);\n+    }\n+\n   if (i1 && !(NOTE_P(i1) && (NOTE_KIND (i1) == NOTE_INSN_DELETED)))\n     {\n       if (dump_file)\n@@ -12737,7 +13030,7 @@ reg_bitfield_target_p (rtx x, rtx body)\n \n static void\n distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n-\t\t  rtx elim_i1)\n+\t\t  rtx elim_i1, rtx elim_i0)\n {\n   rtx note, next_note;\n   rtx tem;\n@@ -12983,7 +13276,8 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t&& !(i2mod\n \t\t\t     && reg_overlap_mentioned_p (XEXP (note, 0),\n \t\t\t\t\t\t\t i2mod_old_rhs)))\n-\t\t       || rtx_equal_p (XEXP (note, 0), elim_i1))\n+\t\t       || rtx_equal_p (XEXP (note, 0), elim_i1)\n+\t\t       || rtx_equal_p (XEXP (note, 0), elim_i0))\n \t\tbreak;\n \t      tem = i3;\n \t    }\n@@ -13050,7 +13344,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t  REG_NOTES (tem) = NULL;\n \n \t\t\t  distribute_notes (old_notes, tem, tem, NULL_RTX,\n-\t\t\t\t\t    NULL_RTX, NULL_RTX);\n+\t\t\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n \t\t\t  distribute_links (LOG_LINKS (tem));\n \n \t\t\t  SET_INSN_DELETED (tem);\n@@ -13067,7 +13361,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \n \t\t\t      distribute_notes (old_notes, cc0_setter,\n \t\t\t\t\t\tcc0_setter, NULL_RTX,\n-\t\t\t\t\t\tNULL_RTX, NULL_RTX);\n+\t\t\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX);\n \t\t\t      distribute_links (LOG_LINKS (cc0_setter));\n \n \t\t\t      SET_INSN_DELETED (cc0_setter);\n@@ -13187,7 +13481,8 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t\t\t\t\t     NULL_RTX);\n \n \t\t\t      distribute_notes (new_note, place, place,\n-\t\t\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX);\n+\t\t\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX,\n+\t\t\t\t\t\tNULL_RTX);\n \t\t\t    }\n \t\t\t  else if (! refers_to_regno_p (i, i + 1,\n \t\t\t\t\t\t\tPATTERN (place), 0)"}]}