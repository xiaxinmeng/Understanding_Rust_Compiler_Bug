{"sha": "0b97b8f84a904dff92284e9899f53f9a1dbc177b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI5N2I4Zjg0YTkwNGRmZjkyMjg0ZTk4OTlmNTNmOWExZGJjMTc3Yg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2017-06-16T21:04:02Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2017-06-16T21:04:02Z"}, "message": "[arm] Generate a canonical form for -march\n\n\nThis patch uses the driver and some spec rewrite rules to generate a\ncanonicalized form of the -march= option.  We want to do this for\nseveral reasons, all relating to making multi-lib selection sane.\n\n1) It can remove redundant extension options to produce a minimal\nlist.\n\n2) The general syntax of the option permits a plethora of features,\nthese are permitted in any order.  Canonicalization ensures that there\nis a single ordering of the options that are needed.\n\n3) It can use additional options to remove extensions that aren't\nrelevant, such as removing all features that relate to the FPU when\nuse of that is disabled.\n\nOnce we have this information in a sensible form the multilib rules\ncan be vastly simplified making for much more understandable Makefile\nfragments.\n\n\t* common/config/arm/arm-common.c: Define INCLUDE_LIST.\n\t(configargs.h): Include it.\n\t(arm_print_hint_for_fpu_option): New function.\n\t(arm_parse_fpu_option): New function.\n\t(candidate_extension): New class.\n\t(arm_canon_for_multilib): New function.\n\t* config/arm/arm.h (CANON_ARCH_SPEC_FUNCTION): New macro.\n\t(EXTRA_SPEC_FUNCTIONS): Add CANON_ARCH_SPEC_FUNCTION.\n\t(ARCH_CANONICAL_SPECS): New macro.\n\t(DRIVER_SELF_SPECS): Add ARCH_CANONICAL_SPECS.\n\nFrom-SVN: r249292", "tree": {"sha": "b92f389b79477164f5ea6568c20ac00a7b18b139", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b92f389b79477164f5ea6568c20ac00a7b18b139"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b97b8f84a904dff92284e9899f53f9a1dbc177b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b97b8f84a904dff92284e9899f53f9a1dbc177b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b97b8f84a904dff92284e9899f53f9a1dbc177b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b97b8f84a904dff92284e9899f53f9a1dbc177b/comments", "author": null, "committer": null, "parents": [{"sha": "a4af8a1046d3c77ee1152c9dad08329a0dd51f49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4af8a1046d3c77ee1152c9dad08329a0dd51f49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4af8a1046d3c77ee1152c9dad08329a0dd51f49"}], "stats": {"total": 387, "additions": 386, "deletions": 1}, "files": [{"sha": "d1abcce666bd5994502e52583a3fe160dd5947a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b97b8f84a904dff92284e9899f53f9a1dbc177b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b97b8f84a904dff92284e9899f53f9a1dbc177b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b97b8f84a904dff92284e9899f53f9a1dbc177b", "patch": "@@ -1,3 +1,16 @@\n+2017-06-16  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* common/config/arm/arm-common.c: Define INCLUDE_LIST.\n+\t(configargs.h): Include it.\n+\t(arm_print_hint_for_fpu_option): New function.\n+\t(arm_parse_fpu_option): New function.\n+\t(candidate_extension): New class.\n+\t(arm_canon_for_multilib): New function.\n+\t* config/arm/arm.h (CANON_ARCH_SPEC_FUNCTION): New macro.\n+\t(EXTRA_SPEC_FUNCTIONS): Add CANON_ARCH_SPEC_FUNCTION.\n+\t(ARCH_CANONICAL_SPECS): New macro.\n+\t(DRIVER_SELF_SPECS): Add ARCH_CANONICAL_SPECS.\n+\n 2017-06-16  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config.gcc (arm*-*-*): Ensure both target_cpu_cname and with_cpu"}, {"sha": "30cb61e51ee69adde42329019bd696c50ec72a39", "filename": "gcc/common/config/arm/arm-common.c", "status": "modified", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b97b8f84a904dff92284e9899f53f9a1dbc177b/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b97b8f84a904dff92284e9899f53f9a1dbc177b/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c?ref=0b97b8f84a904dff92284e9899f53f9a1dbc177b", "patch": "@@ -17,6 +17,7 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n+#define INCLUDE_LIST\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -305,6 +306,41 @@ arm_parse_arch_option_name (const arch_option *list, const char *optname,\n   return NULL;\n }\n \n+/* List the permitted architecture option names.  If TARGET is a near\n+   miss for an entry, print out the suggested alternative.  */\n+static void\n+arm_print_hint_for_fpu_option (const char *target)\n+{\n+  auto_vec<const char*> candidates;\n+  for (int i = 0; i < TARGET_FPU_auto; i++)\n+    candidates.safe_push (all_fpus[i].name);\n+  char *s;\n+  const char *hint = candidates_list_and_hint (target, s, candidates);\n+  if (hint)\n+    inform (input_location, \"valid arguments are: %s; did you mean %qs?\",\n+\t    s, hint);\n+  else\n+    inform (input_location, \"valid arguments are: %s\", s);\n+\n+  XDELETEVEC (s);\n+}\n+\n+static const arm_fpu_desc *\n+arm_parse_fpu_option (const char *opt)\n+{\n+  int i;\n+\n+  for (i = 0; i < TARGET_FPU_auto; i++)\n+    {\n+      if (strcmp (all_fpus[i].name, opt) == 0)\n+\treturn all_fpus + i;\n+    }\n+\n+  error_at (input_location, \"unrecognized -mfpu target: %s\", opt);\n+  arm_print_hint_for_fpu_option (opt);\n+  return NULL;\n+}\n+\n /* Convert a static initializer array of feature bits to sbitmap\n    representation.  */\n void\n@@ -405,6 +441,324 @@ arm_parse_option_features (sbitmap isa, const cpu_arch_option *target,\n     }\n }\n \n+class candidate_extension\n+{\n+public:\n+  const cpu_arch_extension *extension;\n+  sbitmap isa_bits;\n+  bool required;\n+\n+  candidate_extension (const cpu_arch_extension *ext, sbitmap bits)\n+    : extension (ext), isa_bits (bits), required (true)\n+    {}\n+  ~candidate_extension ()\n+    {\n+      sbitmap_free (isa_bits);\n+    }\n+};\n+\n+/* Generate a canonical representation of the -march option from the\n+   current -march string (if given) and other options on the command\n+   line that might affect the architecture.  This aids multilib selection\n+   by ensuring that:\n+   a) the option is always present\n+   b) only the minimal set of options are used\n+   c) when there are multiple extensions, they are in a consistent order.\n+\n+   The options array consists of couplets of information where the\n+   first item in each couplet is the string describing which option\n+   name was selected (arch, cpu, fpu) and the second is the value\n+   passed for that option.  */\n+const char *\n+arm_canon_arch_option (int argc, const char **argv)\n+{\n+  const char *arch = NULL;\n+  const char *cpu = NULL;\n+  const char *fpu = NULL;\n+  const char *abi = NULL;\n+  static char *canonical_arch = NULL;\n+\n+  /* Just in case we're called more than once.  */\n+  if (canonical_arch)\n+    {\n+      free (canonical_arch);\n+      canonical_arch = NULL;\n+    }\n+\n+  if (argc & 1)\n+    fatal_error (input_location,\n+\t\t \"%%:canon_for_mlib takes 1 or more pairs of parameters\");\n+\n+  while (argc)\n+    {\n+      if (strcmp (argv[0], \"arch\") == 0)\n+\tarch = argv[1];\n+      else if (strcmp (argv[0], \"cpu\") == 0)\n+\tcpu = argv[1];\n+      else if (strcmp (argv[0], \"fpu\") == 0)\n+\tfpu = argv[1];\n+      else if (strcmp (argv[0], \"abi\") == 0)\n+\tabi = argv[1];\n+      else\n+\tfatal_error (input_location,\n+\t\t     \"unrecognized operand to %%:canon_for_mlib\");\n+\n+      argc -= 2;\n+      argv += 2;\n+    }\n+\n+  auto_sbitmap target_isa (isa_num_bits);\n+  auto_sbitmap base_isa (isa_num_bits);\n+  auto_sbitmap fpu_isa (isa_num_bits);\n+\n+  bitmap_clear (fpu_isa);\n+\n+  const arch_option *selected_arch = NULL;\n+\n+  /* At least one of these must be defined by either the specs or the\n+     user.  */\n+  gcc_assert (cpu || arch);\n+\n+  if (!fpu)\n+    fpu = FPUTYPE_DEFAULT;\n+\n+  if (!abi)\n+    {\n+      if (TARGET_DEFAULT_FLOAT_ABI == ARM_FLOAT_ABI_SOFT)\n+\tabi = \"soft\";\n+      else if (TARGET_DEFAULT_FLOAT_ABI == ARM_FLOAT_ABI_SOFTFP)\n+\tabi = \"softfp\";\n+      else if (TARGET_DEFAULT_FLOAT_ABI == ARM_FLOAT_ABI_HARD)\n+\tabi = \"hard\";\n+    }\n+\n+  /* First build up a bitmap describing the target architecture.  */\n+  if (arch)\n+    {\n+      selected_arch = arm_parse_arch_option_name (all_architectures,\n+\t\t\t\t\t\t  \"-march\", arch);\n+\n+      if (selected_arch == NULL)\n+\treturn \"\";\n+\n+      arm_initialize_isa (target_isa, selected_arch->common.isa_bits);\n+      arm_parse_option_features (target_isa, &selected_arch->common,\n+\t\t\t\t strchr (arch, '+'));\n+      if (fpu && strcmp (fpu, \"auto\") != 0)\n+\t{\n+\t  /* We assume that architectures do not have any FPU bits\n+\t     enabled by default.  If they did, we would need to strip\n+\t     these out first.  */\n+\t  const arm_fpu_desc *target_fpu = arm_parse_fpu_option (fpu);\n+\t  if (target_fpu == NULL)\n+\t    return \"\";\n+\n+\t  arm_initialize_isa (fpu_isa, target_fpu->isa_bits);\n+\t  bitmap_ior (target_isa, target_isa, fpu_isa);\n+\t}\n+    }\n+  else if (cpu)\n+    {\n+      const cpu_option *selected_cpu\n+\t= arm_parse_cpu_option_name (all_cores, \"-mcpu\", cpu);\n+\n+      if (selected_cpu == NULL)\n+\treturn \"\";\n+\n+      arm_initialize_isa (target_isa, selected_cpu->common.isa_bits);\n+      arm_parse_option_features (target_isa, &selected_cpu->common,\n+\t\t\t\t strchr (cpu, '+'));\n+      if (fpu && strcmp (fpu, \"auto\") != 0)\n+\t{\n+\t  /* The easiest and safest way to remove the default fpu\n+\t     capabilities is to look for a '+no..' option that removes\n+\t     the base FPU bit (isa_bit_VFPv2).  If that doesn't exist\n+\t     then the best we can do is strip out all the bits that\n+\t     might be part of the most capable FPU we know about,\n+\t     which is \"crypto-neon-fp-armv8\".  */\n+\t  bool default_fpu_found = false;\n+\t  if (selected_cpu->common.extensions)\n+\t    {\n+\t      const cpu_arch_extension *ext;\n+\t      for (ext = selected_cpu->common.extensions; ext->name != NULL;\n+\t\t   ++ext)\n+\t\t{\n+\t\t  if (ext->remove\n+\t\t      && check_isa_bits_for (ext->isa_bits, isa_bit_VFPv2))\n+\t\t    {\n+\t\t      arm_initialize_isa (fpu_isa, ext->isa_bits);\n+\t\t      bitmap_and_compl (target_isa, target_isa, fpu_isa);\n+\t\t      default_fpu_found = true;\n+\t\t    }\n+\t\t}\n+\n+\t    }\n+\n+\t  if (!default_fpu_found)\n+\t    {\n+\t      arm_initialize_isa\n+\t\t(fpu_isa,\n+\t\t all_fpus[TARGET_FPU_crypto_neon_fp_armv8].isa_bits);\n+\t      bitmap_and_compl (target_isa, target_isa, fpu_isa);\n+\t    }\n+\n+\t  const arm_fpu_desc *target_fpu = arm_parse_fpu_option (fpu);\n+\t  if (target_fpu == NULL)\n+\t    return \"\";\n+\n+\t  arm_initialize_isa (fpu_isa, target_fpu->isa_bits);\n+\t  bitmap_ior (target_isa, target_isa, fpu_isa);\n+\t}\n+\n+      selected_arch = all_architectures + selected_cpu->arch;\n+    }\n+\n+  /* If we have a soft-float ABI, disable the FPU.  */\n+  if (abi && strcmp (abi, \"soft\") == 0)\n+    {\n+      /* Clearing the VFPv2 bit is sufficient to stop any extention that\n+\t builds on the FPU from matching.  */\n+      bitmap_clear_bit (target_isa, isa_bit_VFPv2);\n+    }\n+\n+  /* If we don't have a selected architecture by now, something's\n+     badly wrong.  */\n+  gcc_assert (selected_arch);\n+\n+  arm_initialize_isa (base_isa, selected_arch->common.isa_bits);\n+\n+  /* Architecture has no extension options, so just return the canonical\n+     architecture name.  */\n+  if (selected_arch->common.extensions == NULL)\n+    return selected_arch->common.name;\n+\n+  /* We're only interested in extension bits.  */\n+  bitmap_and_compl (target_isa, target_isa, base_isa);\n+\n+  /* There are no extensions needed.  Just return the canonical architecture\n+     name.  */\n+  if (bitmap_empty_p (target_isa))\n+    return selected_arch->common.name;\n+\n+  /* What is left is the architecture that the compiler will target.  We\n+     now need to map that back into a suitable option+features list.\n+\n+     The list is built in two passes.  First we scan every additive\n+     option feature supported by the architecture.  If the option\n+     provides a subset of the features we need we add it to the list\n+     of candidates.  We then scan backwards over the list of\n+     candidates and if we find a feature that adds nothing to one that\n+     was later in the list we mark it as redundant.  The result is a\n+     minimal list of required features for the target\n+     architecture.  */\n+\n+  std::list<candidate_extension *> extensions;\n+\n+  auto_sbitmap target_isa_unsatisfied (isa_num_bits);\n+  bitmap_copy (target_isa_unsatisfied, target_isa);\n+\n+  sbitmap isa_bits = NULL;\n+  for (const cpu_arch_extension *cand = selected_arch->common.extensions;\n+       cand->name != NULL;\n+       cand++)\n+    {\n+      if (cand->remove || cand->alias)\n+\tcontinue;\n+\n+      if (isa_bits == NULL)\n+\tisa_bits = sbitmap_alloc (isa_num_bits);\n+\n+      arm_initialize_isa (isa_bits, cand->isa_bits);\n+      if (bitmap_subset_p (isa_bits, target_isa))\n+\t{\n+\t  extensions.push_back (new candidate_extension (cand, isa_bits));\n+\t  bitmap_and_compl (target_isa_unsatisfied, target_isa_unsatisfied,\n+\t\t\t    isa_bits);\n+\t  isa_bits = NULL;\n+\t}\n+    }\n+\n+  /* There's one extra case to consider, which is that the user has\n+     specified an FPU that is less capable than this architecture\n+     supports.  In that case the code above will fail to find a\n+     suitable feature.  We handle this by scanning the list of options\n+     again, matching the first option that provides an FPU that is\n+     more capable than the selected FPU.\n+\n+     Note that the other case (user specified a more capable FPU than\n+     this architecture supports) should end up selecting the most\n+     capable FPU variant that we do support.  This is sufficient for\n+     multilib selection.  */\n+\n+  if (bitmap_bit_p (target_isa_unsatisfied, isa_bit_VFPv2)\n+      && bitmap_bit_p (fpu_isa, isa_bit_VFPv2))\n+    {\n+      std::list<candidate_extension *>::iterator ipoint = extensions.begin ();\n+\n+      for (const cpu_arch_extension *cand = selected_arch->common.extensions;\n+\t   cand->name != NULL;\n+\t   cand++)\n+\t{\n+\t  if (cand->remove || cand->alias)\n+\t    continue;\n+\n+\t  if (isa_bits == NULL)\n+\t    isa_bits = sbitmap_alloc (isa_num_bits);\n+\n+\t  /* We need to keep the features in canonical order, so move the\n+\t     insertion point if this feature is a candidate.  */\n+\t  if (ipoint != extensions.end ()\n+\t      && (*ipoint)->extension == cand)\n+\t    ++ipoint;\n+\n+\t  arm_initialize_isa (isa_bits, cand->isa_bits);\n+\t  if (bitmap_subset_p (fpu_isa, isa_bits))\n+\t    {\n+\t      extensions.insert (ipoint,\n+\t\t\t\t new candidate_extension (cand, isa_bits));\n+\t      isa_bits = NULL;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (isa_bits)\n+    sbitmap_free (isa_bits);\n+\n+  bitmap_clear (target_isa);\n+  size_t len = 1;\n+  for (std::list<candidate_extension *>::reverse_iterator riter\n+\t = extensions.rbegin ();\n+       riter != extensions.rend (); ++riter)\n+    {\n+      if (bitmap_subset_p ((*riter)->isa_bits, target_isa))\n+\t(*riter)->required = false;\n+      else\n+\t{\n+\t  bitmap_ior (target_isa, target_isa, (*riter)->isa_bits);\n+\t  len += strlen ((*riter)->extension->name) + 1;\n+\t}\n+    }\n+\n+  canonical_arch\n+    = (char *) xmalloc (len + strlen (selected_arch->common.name));\n+\n+  strcpy (canonical_arch, selected_arch->common.name);\n+\n+  for (std::list<candidate_extension *>::iterator iter = extensions.begin ();\n+       iter != extensions.end (); ++iter)\n+    {\n+      if ((*iter)->required)\n+\t{\n+\t  strcat (canonical_arch, \"+\");\n+\t  strcat (canonical_arch, (*iter)->extension->name);\n+\t}\n+      delete (*iter);\n+    }\n+\n+  return canonical_arch;\n+}\n+\n #undef ARM_CPU_NAME_LENGTH\n \n "}, {"sha": "57f4958e2b5dae0d06ff9e8e307b345a91a70549", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b97b8f84a904dff92284e9899f53f9a1dbc177b/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b97b8f84a904dff92284e9899f53f9a1dbc177b/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=0b97b8f84a904dff92284e9899f53f9a1dbc177b", "patch": "@@ -2250,9 +2250,15 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n # define MCPU_MTUNE_NATIVE_SPECS \"\"\n #endif\n \n+const char *arm_canon_arch_option (int argc, const char **argv);\n+\n+#define CANON_ARCH_SPEC_FUNCTION\t\t\\\n+  { \"canon_arch\", arm_canon_arch_option },\n+\n # define EXTRA_SPEC_FUNCTIONS\t\t\t\\\n   MCPU_MTUNE_NATIVE_FUNCTIONS\t\t\t\\\n   ASM_CPU_SPEC_FUNCTIONS\t\t\t\\\n+  CANON_ARCH_SPEC_FUNCTION\t\t\t\\\n   TARGET_MODE_SPEC_FUNCTIONS\n \n /* Automatically add -mthumb for Thumb-only targets if mode isn't specified\n@@ -2264,7 +2270,19 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define TARGET_MODE_SPECS\t\t\t\t\t\t\\\n   \" %{!marm:%{!mthumb:%:target_mode_check(%{march=*:arch %*;mcpu=*:cpu %*;:})}}\"\n \n-#define DRIVER_SELF_SPECS MCPU_MTUNE_NATIVE_SPECS TARGET_MODE_SPECS\n+/* Generate a canonical string to represent the architecture selected.  */\n+#define ARCH_CANONICAL_SPECS\t\t\t\t\\\n+  \" -march=%:canon_arch(%{mcpu=*: cpu %*} \"\t\t\\\n+  \"                     %{march=*: arch %*} \"\t\t\\\n+  \"                     %{mfpu=*: fpu %*} \"\t\t\\\n+  \"                     %{mfloat-abi=*: abi %*}\"\t\\\n+  \"                     %<march=*) \"\n+\n+#define DRIVER_SELF_SPECS\t\t\t\\\n+  MCPU_MTUNE_NATIVE_SPECS\t\t\t\\\n+  TARGET_MODE_SPECS\t\t\t\t\\\n+  ARCH_CANONICAL_SPECS\n+\n #define TARGET_SUPPORTS_WIDE_INT 1\n \n /* For switching between functions with different target attributes.  */"}]}