{"sha": "3a6d28d6853d77eec9414692ca62a990609f8dba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E2ZDI4ZDY4NTNkNzdlZWM5NDE0NjkyY2E2MmE5OTA2MDlmOGRiYQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2015-07-25T12:47:35Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-07-25T12:47:35Z"}, "message": "i386.c: Use SUBREG_P predicate.\n\n\t* config/i386/i386.c: Use SUBREG_P predicate.\n\t* config/i386/i386.md: Ditto.\n\t* config/i386/sse.md: Ditto.\n\t* config/i386/predicates.md: Ditto.\n\nFrom-SVN: r226216", "tree": {"sha": "98938176d649c9057685d6ed6daae4af9ea0271f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98938176d649c9057685d6ed6daae4af9ea0271f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a6d28d6853d77eec9414692ca62a990609f8dba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a6d28d6853d77eec9414692ca62a990609f8dba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a6d28d6853d77eec9414692ca62a990609f8dba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a6d28d6853d77eec9414692ca62a990609f8dba/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0453025d3fbe3223a98cc2b95b53048e44b1ad5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0453025d3fbe3223a98cc2b95b53048e44b1ad5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0453025d3fbe3223a98cc2b95b53048e44b1ad5b"}], "stats": {"total": 73, "additions": 40, "deletions": 33}, "files": [{"sha": "b8745cccc22e2c8363165dd8e1f77cbbb3ef9631", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a6d28d6853d77eec9414692ca62a990609f8dba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a6d28d6853d77eec9414692ca62a990609f8dba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a6d28d6853d77eec9414692ca62a990609f8dba", "patch": "@@ -1,3 +1,10 @@\n+2015-07-25  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c: Use SUBREG_P predicate.\n+\t* config/i386/i386.md: Ditto.\n+\t* config/i386/sse.md: Ditto.\n+\t* config/i386/predicates.md: Ditto.\n+\n 2015-07-25  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/67004"}, {"sha": "9413c87bdb3e61f5bb30b77407ef9c21d6cfa1fb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a6d28d6853d77eec9414692ca62a990609f8dba/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a6d28d6853d77eec9414692ca62a990609f8dba/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3a6d28d6853d77eec9414692ca62a990609f8dba", "patch": "@@ -6180,7 +6180,7 @@ ix86_legitimate_combined_insn (rtx_insn *insn)\n \t  if (UNARY_P (op))\n \t    op = XEXP (op, 0);\n \n-\t  if (GET_CODE (op) == SUBREG)\n+\t  if (SUBREG_P (op))\n \t    {\n \t      if (REG_P (SUBREG_REG (op))\n \t\t  && REGNO (SUBREG_REG (op)) < FIRST_PSEUDO_REGISTER)\n@@ -9477,7 +9477,7 @@ ix86_check_movabs (rtx insn, int opnum)\n     set = XVECEXP (set, 0, 0);\n   gcc_assert (GET_CODE (set) == SET);\n   mem = XEXP (set, opnum);\n-  while (GET_CODE (mem) == SUBREG)\n+  while (SUBREG_P (mem))\n     mem = SUBREG_REG (mem);\n   gcc_assert (MEM_P (mem));\n   return volatile_ok || !MEM_VOLATILE_P (mem);\n@@ -12895,7 +12895,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n      they will be emitted with addr32 prefix.  */\n   if (TARGET_64BIT && GET_MODE (addr) == SImode)\n     {\n-      if (GET_CODE (addr) == SUBREG\n+      if (SUBREG_P (addr)\n \t  && GET_MODE (SUBREG_REG (addr)) == DImode)\n \t{\n \t  addr = SUBREG_REG (addr);\n@@ -12906,7 +12906,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n \n   if (REG_P (addr))\n     base = addr;\n-  else if (GET_CODE (addr) == SUBREG)\n+  else if (SUBREG_P (addr))\n     {\n       if (REG_P (SUBREG_REG (addr)))\n \tbase = addr;\n@@ -13024,7 +13024,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n     {\n       if (REG_P (index))\n \t;\n-      else if (GET_CODE (index) == SUBREG\n+      else if (SUBREG_P (index)\n \t       && REG_P (SUBREG_REG (index)))\n \t;\n       else\n@@ -13039,8 +13039,8 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n       scale = INTVAL (scale_rtx);\n     }\n \n-  base_reg = base && GET_CODE (base) == SUBREG ? SUBREG_REG (base) : base;\n-  index_reg = index && GET_CODE (index) == SUBREG ? SUBREG_REG (index) : index;\n+  base_reg = base && SUBREG_P (base) ? SUBREG_REG (base) : base;\n+  index_reg = index && SUBREG_P (index) ? SUBREG_REG (index) : index;\n \n   /* Avoid useless 0 displacement.  */\n   if (disp == const0_rtx && (base || index))\n@@ -13108,9 +13108,9 @@ ix86_address_cost (rtx x, machine_mode, addr_space_t, bool)\n \n   gcc_assert (ok);\n \n-  if (parts.base && GET_CODE (parts.base) == SUBREG)\n+  if (parts.base && SUBREG_P (parts.base))\n     parts.base = SUBREG_REG (parts.base);\n-  if (parts.index && GET_CODE (parts.index) == SUBREG)\n+  if (parts.index && SUBREG_P (parts.index))\n     parts.index = SUBREG_REG (parts.index);\n \n   /* Attempt to minimize number of registers in the address by increasing\n@@ -13515,7 +13515,7 @@ ix86_validate_address_register (rtx op)\n \n   if (REG_P (op))\n     return op;\n-  else if (GET_CODE (op) == SUBREG)\n+  else if (SUBREG_P (op))\n     {\n       rtx reg = SUBREG_REG (op);\n \n@@ -16727,7 +16727,7 @@ output_387_binary_op (rtx insn, rtx *operands)\n static bool\n ix86_check_avx256_register (const_rtx exp)\n {\n-  if (GET_CODE (exp) == SUBREG)\n+  if (SUBREG_P (exp))\n     exp = SUBREG_REG (exp);\n \n   return (REG_P (exp)\n@@ -17555,7 +17555,7 @@ ix86_expand_vector_move (machine_mode mode, rtx operands[])\n   if (can_create_pseudo_p ()\n       && register_operand (op0, mode)\n       && (CONSTANT_P (op1)\n-\t  || (GET_CODE (op1) == SUBREG\n+\t  || (SUBREG_P (op1)\n \t      && CONSTANT_P (SUBREG_REG (op1))))\n       && !standard_sse_constant_p (op1))\n     op1 = validize_mem (force_const_mem (mode, op1));\n@@ -17571,7 +17571,7 @@ ix86_expand_vector_move (machine_mode mode, rtx operands[])\n \n       /* ix86_expand_vector_move_misalign() does not like constants ... */\n       if (CONSTANT_P (op1)\n-\t  || (GET_CODE (op1) == SUBREG\n+\t  || (SUBREG_P (op1)\n \t      && CONSTANT_P (SUBREG_REG (op1))))\n \top1 = validize_mem (force_const_mem (mode, op1));\n \n@@ -18129,12 +18129,12 @@ ix86_expand_vector_logical_operator (enum rtx_code code, machine_mode mode,\n \t\t\t\t     rtx operands[])\n {\n   rtx op1 = NULL_RTX, op2 = NULL_RTX;\n-  if (GET_CODE (operands[1]) == SUBREG)\n+  if (SUBREG_P (operands[1]))\n     {\n       op1 = operands[1];\n       op2 = operands[2];\n     }\n-  else if (GET_CODE (operands[2]) == SUBREG)\n+  else if (SUBREG_P (operands[2]))\n     {\n       op1 = operands[2];\n       op2 = operands[1];\n@@ -18146,7 +18146,7 @@ ix86_expand_vector_logical_operator (enum rtx_code code, machine_mode mode,\n      to cast them temporarily to integer vectors.  */\n   if (op1\n       && !TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\n-      && ((GET_CODE (op2) == SUBREG || GET_CODE (op2) == CONST_VECTOR))\n+      && (SUBREG_P (op2) || GET_CODE (op2) == CONST_VECTOR)\n       && GET_MODE_CLASS (GET_MODE (SUBREG_REG (op1))) == MODE_VECTOR_FLOAT\n       && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op1))) == GET_MODE_SIZE (mode)\n       && SUBREG_BYTE (op1) == 0\n@@ -25972,9 +25972,9 @@ memory_address_length (rtx addr, bool lea)\n   index = parts.index;\n   disp = parts.disp;\n \n-  if (base && GET_CODE (base) == SUBREG)\n+  if (base && SUBREG_P (base))\n     base = SUBREG_REG (base);\n-  if (index && GET_CODE (index) == SUBREG)\n+  if (index && SUBREG_P (index))\n     index = SUBREG_REG (index);\n \n   gcc_assert (base == NULL_RTX || REG_P (base));\n@@ -41617,7 +41617,7 @@ ix86_secondary_reload (bool in_p, rtx x, reg_class_t rclass,\n       else\n \tregno = -1;\n \n-      if (regno >= FIRST_PSEUDO_REGISTER || GET_CODE (x) == SUBREG)\n+      if (regno >= FIRST_PSEUDO_REGISTER || SUBREG_P (x))\n \tregno = true_regnum (x);\n \n       /* Return Q_REGS if the operand is in memory.  */\n@@ -42404,7 +42404,7 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t{\n \t  if (CONST_INT_P (XEXP (x, 1)))\n \t    *total = cost->shift_const;\n-\t  else if (GET_CODE (XEXP (x, 1)) == SUBREG\n+\t  else if (SUBREG_P (XEXP (x, 1))\n \t\t   && GET_CODE (XEXP (XEXP (x, 1), 0)) == AND)\n \t    {\n \t      /* Return the cost after shift-and truncation.  */\n@@ -50512,15 +50512,15 @@ ix86_expand_pextr (rtx *operands)\n   unsigned int size = INTVAL (operands[2]);\n   unsigned int pos = INTVAL (operands[3]);\n \n-  if (GET_CODE (dst) == SUBREG)\n+  if (SUBREG_P (dst))\n     {\n       /* Reject non-lowpart subregs.  */\n       if (SUBREG_BYTE (dst) > 0)\n \treturn false;\n       dst = SUBREG_REG (dst);\n     }\n \t\n-  if (GET_CODE (src) == SUBREG)\n+  if (SUBREG_P (src))\n     {\n       pos += SUBREG_BYTE (src) * BITS_PER_UNIT;\n       src = SUBREG_REG (src);\n@@ -50615,7 +50615,7 @@ ix86_expand_pinsr (rtx *operands)\n   unsigned int size = INTVAL (operands[1]);\n   unsigned int pos = INTVAL (operands[2]);\n \n-  if (GET_CODE (dst) == SUBREG)\n+  if (SUBREG_P (dst))\n     {\n       pos += SUBREG_BYTE (dst) * BITS_PER_UNIT;\n       dst = SUBREG_REG (dst);\n@@ -50675,7 +50675,7 @@ ix86_expand_pinsr (rtx *operands)\n \tif (pos & (size-1))\n \t  return false;\n \n-\tif (GET_CODE (src) == SUBREG)\n+\tif (SUBREG_P (src))\n \t  {\n \t    unsigned int srcpos = SUBREG_BYTE (src);\n "}, {"sha": "5c5c1fc01db7d242e92a77526bd478562caa5370", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a6d28d6853d77eec9414692ca62a990609f8dba/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a6d28d6853d77eec9414692ca62a990609f8dba/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3a6d28d6853d77eec9414692ca62a990609f8dba", "patch": "@@ -2643,7 +2643,7 @@\n {\n   if (TARGET_PARTIAL_REG_STALL && optimize_function_for_speed_p (cfun))\n     FAIL;\n-  if (GET_CODE (operands[0]) == SUBREG\n+  if (SUBREG_P (operands[0])\n       && GET_MODE_CLASS (GET_MODE (SUBREG_REG (operands[0]))) != MODE_INT)\n     FAIL;\n   /* Don't generate memory->memory moves, go through a register */\n@@ -7740,7 +7740,7 @@\n \t  val = adjust_address (val, mode, 0);\n \t}\n     }\n-  else if (GET_CODE (val) == SUBREG\n+  else if (SUBREG_P (val)\n \t   && (submode = GET_MODE (SUBREG_REG (val)),\n \t       GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (submode))\n \t   && pos + len <= GET_MODE_BITSIZE (submode)"}, {"sha": "a9c8623ada25bf14ed5013f2c6fa57fdee80469b", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a6d28d6853d77eec9414692ca62a990609f8dba/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a6d28d6853d77eec9414692ca62a990609f8dba/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=3a6d28d6853d77eec9414692ca62a990609f8dba", "patch": "@@ -101,7 +101,7 @@\n   if ((!TARGET_64BIT || GET_MODE (op) != DImode)\n       && GET_MODE (op) != SImode && GET_MODE (op) != HImode)\n     return false;\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n \n   /* Be careful to accept only registers having upper parts.  */\n@@ -537,7 +537,7 @@\n (define_predicate \"call_register_no_elim_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n \n   if (!TARGET_64BIT && op == stack_pointer_rtx)\n@@ -551,7 +551,7 @@\n (define_predicate \"register_no_elim_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n   return !(op == arg_pointer_rtx\n \t   || op == frame_pointer_rtx\n@@ -564,7 +564,7 @@\n (define_predicate \"index_register_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n   if (reload_completed)\n     return REG_OK_FOR_INDEX_STRICT_P (op);\n@@ -1126,9 +1126,9 @@\n   ok = ix86_decompose_address (op, &parts);\n   gcc_assert (ok);\n \n-  if (parts.base && GET_CODE (parts.base) == SUBREG)\n+  if (parts.base && SUBREG_P (parts.base))\n     parts.base = SUBREG_REG (parts.base);\n-  if (parts.index && GET_CODE (parts.index) == SUBREG)\n+  if (parts.index && SUBREG_P (parts.index))\n     parts.index = SUBREG_REG (parts.index);\n \n   /* Look for some component that isn't known to be aligned.  */"}, {"sha": "200013a019b193f88b26d1e2127410123686b8d8", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a6d28d6853d77eec9414692ca62a990609f8dba/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a6d28d6853d77eec9414692ca62a990609f8dba/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=3a6d28d6853d77eec9414692ca62a990609f8dba", "patch": "@@ -12971,7 +12971,7 @@\n   [(set (match_operand:SWI48x 0 \"nonimmediate_operand\")\n \t(match_operand:SWI48x 1 \"register_operand\"))]\n   \"can_create_pseudo_p ()\n-   && GET_CODE (operands[1]) == SUBREG\n+   && SUBREG_P (operands[1])\n    && REG_P (SUBREG_REG (operands[1]))\n    && (GET_MODE_CLASS (GET_MODE (SUBREG_REG (operands[1]))) == MODE_VECTOR_INT\n        || (GET_MODE_CLASS (GET_MODE (SUBREG_REG (operands[1])))"}]}