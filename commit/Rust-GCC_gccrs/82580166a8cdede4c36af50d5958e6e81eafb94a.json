{"sha": "82580166a8cdede4c36af50d5958e6e81eafb94a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI1ODAxNjZhOGNkZWRlNGMzNmFmNTBkNTk1OGU2ZTgxZWFmYjk0YQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@cygnus.com", "date": "1995-06-08T23:07:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-08T23:07:04Z"}, "message": "Change all callers of finish_decl to cp_finish_decl.\n\n(finish_decl): New routine to handle call backs from the mid\nend (declare_hidden_char_array).\n\nFrom-SVN: r9908", "tree": {"sha": "47beb16164a001e8093f3dbe7570089e90646d0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47beb16164a001e8093f3dbe7570089e90646d0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82580166a8cdede4c36af50d5958e6e81eafb94a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82580166a8cdede4c36af50d5958e6e81eafb94a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82580166a8cdede4c36af50d5958e6e81eafb94a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82580166a8cdede4c36af50d5958e6e81eafb94a/comments", "author": null, "committer": null, "parents": [{"sha": "b3417a046428f30f5e9be25bb24b03334a1f556b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3417a046428f30f5e9be25bb24b03334a1f556b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3417a046428f30f5e9be25bb24b03334a1f556b"}], "stats": {"total": 39, "additions": 24, "deletions": 15}, "files": [{"sha": "b7793e7a1cbd29b3dcccd8b17a42ed43531b14fb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82580166a8cdede4c36af50d5958e6e81eafb94a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82580166a8cdede4c36af50d5958e6e81eafb94a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=82580166a8cdede4c36af50d5958e6e81eafb94a", "patch": "@@ -5638,7 +5638,7 @@ groktypename (typename)\n    The ..._DECL node is returned as the value.\n \n    Exception: for arrays where the length is not specified,\n-   the type is left null, to be filled in by `finish_decl'.\n+   the type is left null, to be filled in by `cp_finish_decl'.\n \n    Function definitions do not come here; they go to start_function\n    instead.  However, external and forward declarations of functions\n@@ -5697,7 +5697,7 @@ start_decl (declarator, declspecs, initialized, raises)\n       pop_obstacks ();\n     }\n \n-  /* Corresponding pop_obstacks is done in `finish_decl'.  */\n+  /* Corresponding pop_obstacks is done in `cp_finish_decl'.  */\n   push_obstacks_nochange ();\n \n   context\n@@ -5755,12 +5755,12 @@ start_decl (declarator, declspecs, initialized, raises)\n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?\n        If not, set INITIALIZED to zero, which will indirectly\n-       tell `finish_decl' to ignore the initializer once it is parsed.  */\n+       tell `cp_finish_decl' to ignore the initializer once it is parsed.  */\n     switch (TREE_CODE (decl))\n       {\n       case TYPE_DECL:\n \t/* typedef foo = bar  means give foo the same type as bar.\n-\t   We haven't parsed bar yet, so `finish_decl' will fix that up.\n+\t   We haven't parsed bar yet, so `cp_finish_decl' will fix that up.\n \t   Any other case of an initialization in a TYPE_DECL is an error.  */\n \tif (pedantic || list_length (declspecs) > 1)\n \t  {\n@@ -5832,7 +5832,7 @@ start_decl (declarator, declspecs, initialized, raises)\n \n       /* Tell `pushdecl' this is an initialized decl\n \t even though we don't yet have the initializer expression.\n-\t Also tell `finish_decl' it may store the real initializer.  */\n+\t Also tell `cp_finish_decl' it may store the real initializer.  */\n       DECL_INITIAL (decl) = error_mark_node;\n     }\n \n@@ -6027,15 +6027,15 @@ make_temporary_for_reference (decl, ctor_call, init, cleanupp)\n     {\n       DECL_INITIAL (tmp) = init;\n       TREE_STATIC (tmp) = toplevel_bindings_p ();\n-      finish_decl (tmp, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n+      cp_finish_decl (tmp, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n   if (TREE_STATIC (tmp))\n     preserve_initializer ();\n }\n #endif\n \n /* Handle initialization of references.\n-   These three arguments from from `finish_decl', and have the\n+   These three arguments from from `cp_finish_decl', and have the\n    same meaning here that they do there.  */\n /* quotes on semantics can be found in ARM 8.4.3. */\n static void\n@@ -6178,7 +6178,7 @@ obscure_complex_init (decl, init)\n \n    Call `pop_obstacks' iff NEED_POP is nonzero.\n \n-   For C++, `finish_decl' must be fairly evasive:  it must keep initializers\n+   For C++, `cp_finish_decl' must be fairly evasive:  it must keep initializers\n    for aggregates that have constructors alive on the permanent obstack,\n    so that the global initializing functions can be written at the end.\n \n@@ -6189,12 +6189,12 @@ obscure_complex_init (decl, init)\n    if the (init) syntax was used.\n \n    For functions that take default parameters, DECL points to its\n-   \"maximal\" instantiation.  `finish_decl' must then also declared its\n+   \"maximal\" instantiation.  `cp_finish_decl' must then also declared its\n    subsequently lower and lower forms of instantiation, checking for\n    ambiguity as it goes.  This can be sped up later.  */\n \n void\n-finish_decl (decl, init, asmspec_tree, need_pop, flags)\n+cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n      tree decl, init;\n      tree asmspec_tree;\n      int need_pop;\n@@ -6833,6 +6833,15 @@ finish_decl (decl, init, asmspec_tree, need_pop, flags)\n     cadillac_finish_decl (decl);\n }\n \n+/* This is here for a midend callback from c-common.c */\n+void\n+finish_decl (decl, init, asmspec_tree)\n+     tree decl, init;\n+     tree asmspec_tree;\n+{\n+  cp_finish_decl (decl, init, asmspec_tree, 1, 0);\n+}\n+\n void\n expand_static_init (decl, init)\n      tree decl;\n@@ -7535,7 +7544,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  if (parmlist_is_exprlist (TREE_OPERAND (decl, 1)))\n \t    {\n \t      /* This is actually a variable declaration using constructor\n-\t\t syntax.  We need to call start_decl and finish_decl so we\n+\t\t syntax.  We need to call start_decl and cp_finish_decl so we\n \t\t can get the variable initialized...  */\n \n \t      if (last)\n@@ -7548,7 +7557,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t      init = TREE_OPERAND (decl, 1);\n \n \t      decl = start_decl (declarator, declspecs, 1, NULL_TREE);\n-\t      finish_decl (decl, init, NULL_TREE, 1, 0);\n+\t      finish_decl (decl, init, NULL_TREE);\n \t      return 0;\n \t    }\n \t  innermost_code = TREE_CODE (decl);\n@@ -11497,10 +11506,10 @@ store_return_init (return_id, init)\n \t  DECL_RTL (decl) = gen_reg_rtx (DECL_MODE (decl));\n \t}\n \n-      /* Let `finish_decl' know that this initializer is ok.  */\n+      /* Let `cp_finish_decl' know that this initializer is ok.  */\n       DECL_INITIAL (decl) = init;\n       pushdecl (decl);\n-      finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n+      cp_finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n }\n \n@@ -12143,7 +12152,7 @@ start_method (declspecs, declarator, raises)\n \tgrok_op_properties (fndecl, DECL_VIRTUAL_P (fndecl), 0);\n     }\n \n-  finish_decl (fndecl, NULL_TREE, NULL_TREE, 0, 0);\n+  cp_finish_decl (fndecl, NULL_TREE, NULL_TREE, 0, 0);\n \n   /* Make a place for the parms */\n   pushlevel (0);"}]}