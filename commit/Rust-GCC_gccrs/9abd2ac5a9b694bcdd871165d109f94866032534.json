{"sha": "9abd2ac5a9b694bcdd871165d109f94866032534", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFiZDJhYzVhOWI2OTRiY2RkODcxMTY1ZDEwOWY5NDg2NjAzMjUzNA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-16T16:21:08Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-16T16:52:39Z"}, "message": "rs6000: Add helper functions for parsing\n\n2021-07-16  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-gen-builtins.c (consume_whitespace): New\n\tfunction.\n\t(advance_line): Likewise.\n\t(safe_inc_pos): Likewise.\n\t(match_identifier): Likewise.\n\t(match_integer): Likewise.\n\t(match_to_right_bracket): Likewise.", "tree": {"sha": "6a1709e37f7f683f85957f7b00d9091950f37013", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a1709e37f7f683f85957f7b00d9091950f37013"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9abd2ac5a9b694bcdd871165d109f94866032534", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abd2ac5a9b694bcdd871165d109f94866032534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9abd2ac5a9b694bcdd871165d109f94866032534", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abd2ac5a9b694bcdd871165d109f94866032534/comments", "author": null, "committer": null, "parents": [{"sha": "43fa306f1d723d9d6c0884e38b102b954d3a4c30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43fa306f1d723d9d6c0884e38b102b954d3a4c30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43fa306f1d723d9d6c0884e38b102b954d3a4c30"}], "stats": {"total": 110, "additions": 110, "deletions": 0}, "files": [{"sha": "7923cc4f9fa9554938e1cb1f3505daf013350113", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abd2ac5a9b694bcdd871165d109f94866032534/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abd2ac5a9b694bcdd871165d109f94866032534/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=9abd2ac5a9b694bcdd871165d109f94866032534", "patch": "@@ -210,3 +210,113 @@ ovld_diag (const char * fmt, ...)\n   vfprintf (stderr, fmt, args);\n   va_end (args);\n }\n+\n+/* Pass over whitespace (other than a newline, which terminates the scan).  */\n+static void\n+consume_whitespace (void)\n+{\n+  while (pos < LINELEN && isspace(linebuf[pos]) && linebuf[pos] != '\\n')\n+    pos++;\n+  return;\n+}\n+\n+/* Get the next nonblank, noncomment line, returning 0 on EOF, 1 otherwise.  */\n+static int\n+advance_line (FILE *file)\n+{\n+  while (1)\n+    {\n+      /* Read ahead one line and check for EOF.  */\n+      if (!fgets (linebuf, sizeof linebuf, file))\n+\treturn 0;\n+      line++;\n+      size_t len = strlen (linebuf);\n+      if (linebuf[len - 1] != '\\n')\n+\t(*diag) (\"line doesn't terminate with newline\\n\");\n+      pos = 0;\n+      consume_whitespace ();\n+      if (linebuf[pos] != '\\n' && linebuf[pos] != ';')\n+\treturn 1;\n+    }\n+}\n+\n+static inline void\n+safe_inc_pos (void)\n+{\n+  if (pos++ >= LINELEN)\n+    {\n+      (*diag) (\"line length overrun.\\n\");\n+      exit (1);\n+    }\n+}\n+\n+/* Match an identifier, returning NULL on failure, else a pointer to a\n+   buffer containing the identifier.  */\n+static char *\n+match_identifier (void)\n+{\n+  int lastpos = pos - 1;\n+  while (isalnum (linebuf[lastpos + 1]) || linebuf[lastpos + 1] == '_')\n+    ++lastpos;\n+\n+  if (lastpos < pos)\n+    return 0;\n+\n+  char *buf = (char *) malloc (lastpos - pos + 2);\n+  memcpy (buf, &linebuf[pos], lastpos - pos + 1);\n+  buf[lastpos - pos + 1] = '\\0';\n+\n+  pos = lastpos + 1;\n+  return buf;\n+}\n+\n+/* Match an integer and return the string representing its value,\n+   or a null string on failure.  */\n+static char *\n+match_integer (void)\n+{\n+  int startpos = pos;\n+  if (linebuf[pos] == '-')\n+    safe_inc_pos ();\n+\n+  int lastpos = pos - 1;\n+  while (isdigit (linebuf[lastpos + 1]))\n+    ++lastpos;\n+\n+  if (lastpos < pos)\n+    return NULL;\n+\n+  pos = lastpos + 1;\n+  char *buf = (char *) malloc (lastpos - startpos + 2);\n+  memcpy (buf, &linebuf[startpos], lastpos - startpos + 1);\n+  buf[lastpos - startpos + 1] = '\\0';\n+  return buf;\n+}\n+\n+/* Match a string up to but not including a ']', and return its value,\n+   or zero if there is nothing before the ']'.  Error if we don't find\n+   such a character.  */\n+static const char *\n+match_to_right_bracket (void)\n+{\n+  int lastpos = pos - 1;\n+  while (linebuf[lastpos + 1] != ']')\n+    {\n+      if (linebuf[lastpos + 1] == '\\n')\n+\t{\n+\t  (*diag) (\"no ']' found before end of line.\\n\");\n+\t  exit (1);\n+\t}\n+      ++lastpos;\n+    }\n+\n+  if (lastpos < pos)\n+    return 0;\n+\n+  char *buf = (char *) malloc (lastpos - pos + 2);\n+  memcpy (buf, &linebuf[pos], lastpos - pos + 1);\n+  buf[lastpos - pos + 1] = '\\0';\n+\n+  pos = lastpos + 1;\n+  return buf;\n+}"}]}