{"sha": "781634daea8cb788efb33994f4a19df76598542e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgxNjM0ZGFlYThjYjc4OGVmYjMzOTk0ZjRhMTlkZjc2NTk4NTQyZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-09T08:19:16Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-09T08:19:16Z"}, "message": "vrp: Fix up gcc.target/aarch64/pr90838.c [PR97312, PR94801]\n\n> Perhaps another way out of this would be document and enforce that\n> __builtin_c[lt]z{,l,ll} etc calls are undefined at zero, but C[TL]Z ifn\n> calls are defined there based on *_DEFINED_VALUE_AT_ZERO (*) == 2\n\nThe following patch implements that, i.e. __builtin_c?z* now take full\nadvantage of them being UB at zero, while the ifns are well defined at zero\nif *_DEFINED_VALUE_AT_ZERO (*) == 2.  That is what fixes PR94801.\n\nFurthermore, to fix PR97312, if it is well defined at zero and the value at\nzero is prec, we don't lower the maximum unless the argument is known to be\nnon-zero.\nFor gimple-range.cc I guess we could improve it if needed e.g. by returning\na [0,7][32,32] range for .CTZ of e.g. [0,137], but for now it (roughly)\nmatches what vr-values.c does.\n\n2020-10-09  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/94801\n\tPR target/97312\n\t* vr-values.c (vr_values::extract_range_basic) <CASE_CFN_CLZ,\n\tCASE_CFN_CTZ>: When stmt is not an internal-fn call or\n\tC?Z_DEFINED_VALUE_AT_ZERO is not 2, assume argument is not zero\n\tand thus use [0, prec-1] range unless it can be further improved.\n\tFor CTZ, don't update maxi from upper bound if it was previously prec.\n\t* gimple-range.cc (gimple_ranger::range_of_builtin_call) <CASE_CFN_CLZ,\n\tCASE_CFN_CTZ>: Likewise.\n\n\t* gcc.dg/tree-ssa/pr94801.c: New test.", "tree": {"sha": "ad884bc76509088a42cd3c583ca2f97941fe5cbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad884bc76509088a42cd3c583ca2f97941fe5cbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/781634daea8cb788efb33994f4a19df76598542e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/781634daea8cb788efb33994f4a19df76598542e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/781634daea8cb788efb33994f4a19df76598542e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/781634daea8cb788efb33994f4a19df76598542e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "600cf1128e49f086522bfddc54490b4e39e30383", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600cf1128e49f086522bfddc54490b4e39e30383", "html_url": "https://github.com/Rust-GCC/gccrs/commit/600cf1128e49f086522bfddc54490b4e39e30383"}], "stats": {"total": 202, "additions": 136, "deletions": 66}, "files": [{"sha": "2ca86ed0e4c7153ca274d3b4f26ea53be30f96d5", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 63, "deletions": 31, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781634daea8cb788efb33994f4a19df76598542e/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781634daea8cb788efb33994f4a19df76598542e/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=781634daea8cb788efb33994f4a19df76598542e", "patch": "@@ -636,28 +636,38 @@ gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n       // __builtin_c[lt]z* return [0, prec-1], except when the\n       // argument is 0, but that is undefined behavior.\n       //\n-      // On many targets where the CLZ RTL or optab value is defined\n-      // for 0, the value is prec, so include that in the range by\n-      // default.\n+      // For __builtin_c[lt]z* consider argument of 0 always undefined\n+      // behavior, for internal fns depending on C?Z_DEFINED_VALUE_AT_ZERO.\n       arg = gimple_call_arg (call, 0);\n       prec = TYPE_PRECISION (TREE_TYPE (arg));\n       mini = 0;\n-      maxi = prec;\n+      maxi = prec - 1;\n       mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-      if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n-\t  && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov)\n-\t  // Only handle the single common value.\n-\t  && zerov != prec)\n-\t// Magic value to give up, unless we can prove arg is non-zero.\n-\tmini = -2;\n+      if (gimple_call_internal_p (call))\n+\t{\n+\t  if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n+\t      && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n+\t    {\n+\t      // Only handle the single common value.\n+\t      if (zerov == prec)\n+\t\tmaxi = prec;\n+\t      else\n+\t\t// Magic value to give up, unless we can prove arg is non-zero.\n+\t\tmini = -2;\n+\t    }\n+\t}\n \n       gcc_assert (range_of_expr (r, arg, call));\n       // From clz of minimum we can compute result maximum.\n       if (r.constant_p ())\n \t{\n-\t  maxi = prec - 1 - wi::floor_log2 (r.lower_bound ());\n-\t  if (maxi != prec)\n-\t    mini = 0;\n+\t  int newmaxi = prec - 1 - wi::floor_log2 (r.lower_bound ());\n+\t  // Argument is unsigned, so do nothing if it is [0, ...] range.\n+\t  if (newmaxi != prec)\n+\t    {\n+\t      mini = 0;\n+\t      maxi = newmaxi;\n+\t    }\n \t}\n       else if (!range_includes_zero_p (&r))\n \t{\n@@ -669,9 +679,17 @@ gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n       // From clz of maximum we can compute result minimum.\n       if (r.constant_p ())\n \t{\n-\t  mini = prec - 1 - wi::floor_log2 (r.upper_bound ());\n-\t  if (mini == prec)\n-\t    break;\n+\t  int newmini = prec - 1 - wi::floor_log2 (r.upper_bound ());\n+\t  if (newmini == prec)\n+\t    {\n+\t      // Argument range is [0, 0].  If CLZ_DEFINED_VALUE_AT_ZERO\n+\t      // is 2 with VALUE of prec, return [prec, prec], otherwise\n+\t      // ignore the range.\n+\t      if (maxi == prec)\n+\t\tmini = prec;\n+\t    }\n+\t  else\n+\t    mini = newmini;\n \t}\n       if (mini == -2)\n \tbreak;\n@@ -682,25 +700,27 @@ gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n       // __builtin_ctz* return [0, prec-1], except for when the\n       // argument is 0, but that is undefined behavior.\n       //\n-      // If there is a ctz optab for this mode and\n-      // CTZ_DEFINED_VALUE_AT_ZERO, include that in the range,\n-      // otherwise just assume 0 won't be seen.\n+      // For __builtin_ctz* consider argument of 0 always undefined\n+      // behavior, for internal fns depending on CTZ_DEFINED_VALUE_AT_ZERO.\n       arg = gimple_call_arg (call, 0);\n       prec = TYPE_PRECISION (TREE_TYPE (arg));\n       mini = 0;\n       maxi = prec - 1;\n       mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-      if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n-\t  && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov))\n+      if (gimple_call_internal_p (call))\n \t{\n-\t  // Handle only the two common values.\n-\t  if (zerov == -1)\n-\t    mini = -1;\n-\t  else if (zerov == prec)\n-\t    maxi = prec;\n-\t  else\n-\t    // Magic value to give up, unless we can prove arg is non-zero.\n-\t    mini = -2;\n+\t  if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n+\t      && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n+\t    {\n+\t      // Handle only the two common values.\n+\t      if (zerov == -1)\n+\t\tmini = -1;\n+\t      else if (zerov == prec)\n+\t\tmaxi = prec;\n+\t      else\n+\t\t// Magic value to give up, unless we can prove arg is non-zero.\n+\t\tmini = -2;\n+\t    }\n \t}\n       gcc_assert (range_of_expr (r, arg, call));\n       if (!r.undefined_p ())\n@@ -714,8 +734,20 @@ gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n \t  // the maximum.\n \t  wide_int max = r.upper_bound ();\n \t  if (max == 0)\n-\t    break;\n-\t  maxi = wi::floor_log2 (max);\n+\t    {\n+\t      // Argument is [0, 0].  If CTZ_DEFINED_VALUE_AT_ZERO\n+\t      // is 2 with value -1 or prec, return [-1, -1] or [prec, prec].\n+\t      // Otherwise ignore the range.\n+\t      if (mini == -1)\n+\t\tmaxi = -1;\n+\t      else if (maxi == prec)\n+\t\tmini = prec;\n+\t    }\n+\t  // If value at zero is prec and 0 is in the range, we can't lower\n+\t  // the upper bound.  We could create two separate ranges though,\n+\t  // [0,floor_log2(max)][prec,prec] though.\n+\t  else if (maxi != prec)\n+\t    maxi = wi::floor_log2 (max);\n \t}\n       if (mini == -2)\n \tbreak;"}, {"sha": "5382e5ee9600738840eda4f297e7b2f1f30a0e4e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr94801.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781634daea8cb788efb33994f4a19df76598542e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr94801.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781634daea8cb788efb33994f4a19df76598542e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr94801.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr94801.c?ref=781634daea8cb788efb33994f4a19df76598542e", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/94801 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \"return 0;\" 2 \"optimized\" } } */\n+\n+int\n+foo (int a)\n+{\n+  return __builtin_clz (a) >> 5;\n+}\n+\n+int\n+bar (int a)\n+{\n+  return __builtin_ctz (a) >> 5;\n+}"}, {"sha": "da0b249278b8ec19a0f034c3437fe7a503fadc0e", "filename": "gcc/vr-values.c", "status": "modified", "additions": 57, "deletions": 35, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781634daea8cb788efb33994f4a19df76598542e/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781634daea8cb788efb33994f4a19df76598542e/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=781634daea8cb788efb33994f4a19df76598542e", "patch": "@@ -1208,34 +1208,42 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t  mini = 0;\n \t  maxi = 1;\n \t  goto bitop_builtin;\n-\t  /* __builtin_c[lt]z* return [0, prec-1], except for\n+\t  /* __builtin_clz* return [0, prec-1], except for\n \t     when the argument is 0, but that is undefined behavior.\n-\t     On many targets where the CLZ RTL or optab value is defined\n-\t     for 0 the value is prec, so include that in the range\n-\t     by default.  */\n+\t     Always handle __builtin_clz* which can be only written\n+\t     by user as UB on 0 and so [0, prec-1] range, and the internal-fn\n+\t     calls depending on how CLZ_DEFINED_VALUE_AT_ZERO is defined.  */\n \tCASE_CFN_CLZ:\n \t  arg = gimple_call_arg (stmt, 0);\n \t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n \t  mini = 0;\n-\t  maxi = prec;\n+\t  maxi = prec - 1;\n \t  mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-\t  if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n-\t      && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov)\n-\t      /* Handle only the single common value.  */\n-\t      && zerov != prec)\n-\t    /* Magic value to give up, unless vr0 proves\n-\t       arg is non-zero.  */\n-\t    mini = -2;\n+\t  if (gimple_call_internal_p (stmt))\n+\t    {\n+\t      if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n+\t\t  && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n+\t\t{\n+\t\t  /* Handle only the single common value.  */\n+\t\t  if (zerov == prec)\n+\t\t    maxi = prec;\n+\t\t  /* Magic value to give up, unless vr0 proves\n+\t\t     arg is non-zero.  */\n+\t\t  else\n+\t\t    mini = -2;\n+\t\t}\n+\t    }\n \t  if (TREE_CODE (arg) == SSA_NAME)\n \t    {\n \t      const value_range_equiv *vr0 = get_value_range (arg);\n \t      /* From clz of VR_RANGE minimum we can compute\n \t\t result maximum.  */\n \t      if (vr0->kind () == VR_RANGE\n-\t\t  && TREE_CODE (vr0->min ()) == INTEGER_CST)\n+\t\t  && TREE_CODE (vr0->min ()) == INTEGER_CST\n+\t\t  && integer_nonzerop (vr0->min ()))\n \t\t{\n \t\t  maxi = prec - 1 - tree_floor_log2 (vr0->min ());\n-\t\t  if (maxi != prec)\n+\t\t  if (mini == -2)\n \t\t    mini = 0;\n \t\t}\n \t      else if (vr0->kind () == VR_ANTI_RANGE\n@@ -1251,37 +1259,45 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t      if (vr0->kind () == VR_RANGE\n \t\t  && TREE_CODE (vr0->max ()) == INTEGER_CST)\n \t\t{\n-\t\t  mini = prec - 1 - tree_floor_log2 (vr0->max ());\n-\t\t  if (mini == prec)\n-\t\t    break;\n+\t\t  int newmini = prec - 1 - tree_floor_log2 (vr0->max ());\n+\t\t  if (newmini == prec)\n+\t\t    {\n+\t\t      if (maxi == prec)\n+\t\t\tmini = prec;\n+\t\t    }\n+\t\t  else\n+\t\t    mini = newmini;\n \t\t}\n \t    }\n \t  if (mini == -2)\n \t    break;\n \t  goto bitop_builtin;\n \t  /* __builtin_ctz* return [0, prec-1], except for\n \t     when the argument is 0, but that is undefined behavior.\n-\t     If there is a ctz optab for this mode and\n-\t     CTZ_DEFINED_VALUE_AT_ZERO, include that in the range,\n-\t     otherwise just assume 0 won't be seen.  */\n+\t     Always handle __builtin_ctz* which can be only written\n+\t     by user as UB on 0 and so [0, prec-1] range, and the internal-fn\n+\t     calls depending on how CTZ_DEFINED_VALUE_AT_ZERO is defined.  */\n \tCASE_CFN_CTZ:\n \t  arg = gimple_call_arg (stmt, 0);\n \t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n \t  mini = 0;\n \t  maxi = prec - 1;\n \t  mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-\t  if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n-\t      && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov))\n+\t  if (gimple_call_internal_p (stmt))\n \t    {\n-\t      /* Handle only the two common values.  */\n-\t      if (zerov == -1)\n-\t\tmini = -1;\n-\t      else if (zerov == prec)\n-\t\tmaxi = prec;\n-\t      else\n-\t\t/* Magic value to give up, unless vr0 proves\n-\t\t   arg is non-zero.  */\n-\t\tmini = -2;\n+\t      if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n+\t\t  && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n+\t\t{\n+\t\t  /* Handle only the two common values.  */\n+\t\t  if (zerov == -1)\n+\t\t    mini = -1;\n+\t\t  else if (zerov == prec)\n+\t\t    maxi = prec;\n+\t\t  else\n+\t\t    /* Magic value to give up, unless vr0 proves\n+\t\t       arg is non-zero.  */\n+\t\t    mini = -2;\n+\t\t}\n \t    }\n \t  if (TREE_CODE (arg) == SSA_NAME)\n \t    {\n@@ -1300,10 +1316,16 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t      if (vr0->kind () == VR_RANGE\n \t\t  && TREE_CODE (vr0->max ()) == INTEGER_CST)\n \t\t{\n-\t\t  maxi = tree_floor_log2 (vr0->max ());\n-\t\t  /* For vr0 [0, 0] give up.  */\n-\t\t  if (maxi == -1)\n-\t\t    break;\n+\t\t  int newmaxi = tree_floor_log2 (vr0->max ());\n+\t\t  if (newmaxi == -1)\n+\t\t    {\n+\t\t      if (mini == -1)\n+\t\t\tmaxi = -1;\n+\t\t      else if (maxi == prec)\n+\t\t\tmini = prec;\n+\t\t    }\n+\t\t  else if (maxi != prec)\n+\t\t    maxi = newmaxi;\n \t\t}\n \t    }\n \t  if (mini == -2)"}]}