{"sha": "c2b6b9a1d96a199e7b77aae54b4054e95c5a544a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJiNmI5YTFkOTZhMTk5ZTdiNzdhYWU1NGI0MDU0ZTk1YzVhNTQ0YQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-20T21:33:01Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-20T21:33:01Z"}, "message": "(inf_size):  Move decl inside main.\n\n(strdup):  Use xmalloc rathern than malloc.\nDon't use the return value of strcpy.\n(INF_UNGET):  Take parameter;  do nothing if EOF.\n(strcpy): Declaration deleted.\n\nFrom-SVN: r5834", "tree": {"sha": "b5ea7af5329159bfcdc6980764c6b465fc460691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5ea7af5329159bfcdc6980764c6b465fc460691"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2b6b9a1d96a199e7b77aae54b4054e95c5a544a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b6b9a1d96a199e7b77aae54b4054e95c5a544a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b6b9a1d96a199e7b77aae54b4054e95c5a544a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b6b9a1d96a199e7b77aae54b4054e95c5a544a/comments", "author": null, "committer": null, "parents": [{"sha": "928eb3809f3473fe601bf5f917790b642a120132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928eb3809f3473fe601bf5f917790b642a120132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/928eb3809f3473fe601bf5f917790b642a120132"}], "stats": {"total": 90, "additions": 47, "deletions": 43}, "files": [{"sha": "96f18847a87ba707d05150d1a20fa6a4ddadbc5c", "filename": "gcc/fix-header.c", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b6b9a1d96a199e7b77aae54b4054e95c5a544a/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b6b9a1d96a199e7b77aae54b4054e95c5a544a/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=c2b6b9a1d96a199e7b77aae54b4054e95c5a544a", "patch": "@@ -81,7 +81,6 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"obstack.h\"\n #include \"scan.h\"\n \n-extern char *strcpy();\n sstring buf;\n int verbose = 0;\n int partial_count = 0;\n@@ -93,7 +92,6 @@ int missing_extra_stuff = 0;\n char *inf_buffer;\n char *inf_limit;\n char *inf_ptr;\n-long int inf_size;\n \n /* Certain standard files get extra treatment */\n \n@@ -123,7 +121,7 @@ int seen_errno = 0;\n void xfree (ptr)\n      char *ptr;\n {\n-  free(ptr);\n+  free (ptr);\n }\n \n #define obstack_chunk_alloc xmalloc\n@@ -135,7 +133,7 @@ struct fn_decl *\n lookup_std_proto (name)\n      char *name;\n {\n-  int i = hash(name) % HASH_SIZE;\n+  int i = hash (name) % HASH_SIZE;\n   int i0 = i;\n   for (;;)\n     {\n@@ -147,7 +145,7 @@ lookup_std_proto (name)\n \treturn fn;\n       i = (i+1) % HASH_SIZE;\n       if (i == i0)\n-\tabort();\n+\tabort ();\n     }\n }\n \n@@ -205,7 +203,7 @@ recognized_macro (fname)\n   /* Since fname is a macro, don't require a prototype for it. */\n   if (fn && REQUIRED (fn))\n     {\n-      CLEAR_REQUIRED(fn);\n+      CLEAR_REQUIRED (fn);\n       required_unseen_count--;\n     }\n \n@@ -274,7 +272,7 @@ recognized_function (fname, kind, rtype, args, file_seen, line_seen)\n   /* Remove the function from the list of required function. */\n   if (fn && REQUIRED (fn))\n     {\n-      CLEAR_REQUIRED(fn);\n+      CLEAR_REQUIRED (fn);\n       required_unseen_count--;\n     }\n \n@@ -294,17 +292,17 @@ recognized_function (fname, kind, rtype, args, file_seen, line_seen)\n \n   if (fn == NULL)\n     return;\n-  if (fn->params[0] == '\\0' || strcmp(fn->params, \"void\") == 0)\n+  if (fn->params[0] == '\\0' || strcmp (fn->params, \"void\") == 0)\n     return;\n \n   /* We only have a partial function declaration,\n      so remember that we have to add a complete prototype. */\n   partial_count++;\n   partial = (struct partial_proto*)\n-    obstack_alloc (&scan_file_obstack, sizeof(struct partial_proto));\n-  partial->fname = obstack_alloc (&scan_file_obstack, strlen(fname) + 1);\n+    obstack_alloc (&scan_file_obstack, sizeof (struct partial_proto));\n+  partial->fname = obstack_alloc (&scan_file_obstack, strlen (fname) + 1);\n   strcpy (partial->fname, fname);\n-  partial->rtype = obstack_alloc (&scan_file_obstack, strlen(rtype) + 1);\n+  partial->rtype = obstack_alloc (&scan_file_obstack, strlen (rtype) + 1);\n   strcpy (partial->rtype, rtype);\n   partial->line_seen = line_seen;\n   partial->fn = fn;\n@@ -323,7 +321,7 @@ read_scan_file (scan_file)\n      FILE *scan_file;\n {\n   char **rptr;\n-  obstack_init(&scan_file_obstack); \n+  obstack_init (&scan_file_obstack); \n \n   scan_decls (scan_file);\n \n@@ -409,7 +407,9 @@ char *\n strdup (str)\n      char *str;\n {\n-  return strcpy((char*)malloc (strlen (str) + 1), str);\n+  char *copy = (char *) xmalloc (strlen (str) + 1);\n+  strcpy (copy, str);\n+  return copy;\n }\n \n /* Returns 1 iff the file is properly protected from multiple inclusion:\n@@ -420,7 +420,7 @@ strdup (str)\n  */\n \n #define INF_GET() (inf_ptr < inf_limit ? *(unsigned char*)inf_ptr++ : EOF)\n-#define INF_UNGET() inf_ptr--\n+#define INF_UNGET(c) ((c)!=EOF && inf_ptr--)\n \n int\n inf_skip_spaces (c)\n@@ -429,16 +429,16 @@ inf_skip_spaces (c)\n   for (;;)\n     {\n       if (c == ' ' || c == '\\t')\n-\tc = INF_GET();\n+\tc = INF_GET ();\n       else if (c == '/')\n \t{\n-\t  c = INF_GET();\n+\t  c = INF_GET ();\n \t  if (c != '*')\n \t    {\n-\t      INF_UNGET();\n+\t      INF_UNGET (c);\n \t      return '/';\n \t    }\n-\t  c = INF_GET();\n+\t  c = INF_GET ();\n \t  for (;;)\n \t    {\n \t      if (c == EOF)\n@@ -449,8 +449,8 @@ inf_skip_spaces (c)\n \t\t    source_lineno++, lineno++;\n \t\t  c = INF_GET ();\n \t\t}\n-\t      else if ((c = INF_GET()) == '/')\n-\t\treturn INF_GET();\n+\t      else if ((c = INF_GET ()) == '/')\n+\t\treturn INF_GET ();\n \t    }\n \t}\n       else\n@@ -472,9 +472,9 @@ inf_read_upto (str, delim)\n       ch = INF_GET ();\n       if (ch == EOF || ch == delim)\n \tbreak;\n-      SSTRING_PUT(str, ch);\n+      SSTRING_PUT (str, ch);\n     }\n-  MAKE_SSTRING_SPACE(str, 1);\n+  MAKE_SSTRING_SPACE (str, 1);\n   *str->ptr = 0;\n   return ch;\n }\n@@ -485,17 +485,17 @@ inf_scan_ident (s, c)\n      int c;\n {\n   s->ptr = s->base;\n-  if (isalpha(c) || c == '_')\n+  if (isalpha (c) || c == '_')\n     {\n       for (;;)\n \t{\n-\t  SSTRING_PUT(s, c);\n+\t  SSTRING_PUT (s, c);\n \t  c = INF_GET ();\n-\t  if (c == EOF || !(isalnum(c) || c == '_'))\n+\t  if (c == EOF || !(isalnum (c) || c == '_'))\n \t    break;\n \t}\n     }\n-  MAKE_SSTRING_SPACE(s, 1);\n+  MAKE_SSTRING_SPACE (s, 1);\n   *s->ptr = 0;\n   return c;\n }\n@@ -526,25 +526,25 @@ check_protection (ifndef_line, endif_line)\n   if (c != '#')\n     return 0;\n   c = inf_scan_ident (&buf, inf_skip_spaces (' '));\n-  if (SSTRING_LENGTH(&buf) == 0 || strcmp (buf.base, \"ifndef\") != 0)\n+  if (SSTRING_LENGTH (&buf) == 0 || strcmp (buf.base, \"ifndef\") != 0)\n     return 0;\n \n   /* So far so good: We've seen an initial #ifndef. */\n   *ifndef_line = lineno;\n   c = inf_scan_ident (&buf, inf_skip_spaces (c));\n-  if (SSTRING_LENGTH(&buf) == 0 || c == EOF)\n+  if (SSTRING_LENGTH (&buf) == 0 || c == EOF)\n     return 0;\n   protect_name = strdup (buf.base);\n \n-  INF_UNGET();\n+  INF_UNGET (c);\n   c = inf_read_upto (&buf, '\\n');\n   if (c == EOF)\n     return 0;\n   lineno++;\n \n   for (;;)\n     {\n-      c = inf_skip_spaces(' ');\n+      c = inf_skip_spaces (' ');\n       if (c == EOF)\n \treturn 0;\n       if (c == '\\n')\n@@ -555,7 +555,7 @@ check_protection (ifndef_line, endif_line)\n       if (c != '#')\n \tgoto skip_to_eol;\n       c = inf_scan_ident (&buf, inf_skip_spaces (' '));\n-      if (SSTRING_LENGTH(&buf) == 0)\n+      if (SSTRING_LENGTH (&buf) == 0)\n \t;\n       else if (!strcmp (buf.base, \"ifndef\")\n \t  || !strcmp (buf.base, \"ifdef\") || !strcmp (buf.base, \"if\"))\n@@ -579,15 +579,15 @@ check_protection (ifndef_line, endif_line)\n \t    goto skip_to_eol;\n \t  c = inf_skip_spaces (c);\n \t  c = inf_scan_ident (&buf, c);\n-\t  if (buf.base[0] > 0 && strcmp(buf.base, protect_name) == 0)\n+\t  if (buf.base[0] > 0 && strcmp (buf.base, protect_name) == 0)\n \t    define_seen = 1;\n \t}\n     skip_to_eol:\n       for (;;)\n \t{\n \t  if (c == '\\n' || c == EOF)\n \t    break;\n-\t  c = INF_GET();\n+\t  c = INF_GET ();\n \t}\n       if (c == EOF)\n \treturn 0;\n@@ -611,7 +611,7 @@ check_protection (ifndef_line, endif_line)\n }\n \n int\n-main(argc, argv)\n+main (argc, argv)\n      int argc;\n      char **argv;\n {\n@@ -623,7 +623,7 @@ main(argc, argv)\n   int ifndef_line;\n   int endif_line;\n   long to_read;\n-\n+  long int inf_size;\n \n   if (argv[0] && argv[0][0])\n     progname = argv[0];\n@@ -646,7 +646,7 @@ main(argc, argv)\n   for (i = 1, cptr = argv[4]; *cptr; cptr++)\n     if (*cptr == ' ') i++;\n   /* Find the list of prototypes required for this include file. */ \n-  required_functions = (char**)xmalloc((i+1) * sizeof(char*));\n+  required_functions = (char**)xmalloc ((i+1) * sizeof (char*));\n   for (cptr = argv[4], cptr0 = cptr, pptr = required_functions, done = 0; \n        !done; cptr++)\n     {\n@@ -656,13 +656,13 @@ main(argc, argv)\n \t  *cptr = '\\0';\n \t  if (cptr > cptr0)\n \t    {\n-\t      struct fn_decl *fn = lookup_std_proto(cptr0);\n+\t      struct fn_decl *fn = lookup_std_proto (cptr0);\n \t      *pptr++ = cptr0;\n \t      if (fn == NULL)\n \t\tfprintf (stderr, \"Internal error:  No prototype for %s\\n\",\n \t\t\t cptr0);\n \t      else\n-\t\tSET_REQUIRED(fn);\n+\t\tSET_REQUIRED (fn);\n \t    }\n \t  cptr0 = cptr + 1;\n \t}\n@@ -713,6 +713,10 @@ main(argc, argv)\n \n   close (inf_fd);\n \n+  /* If file doesn't end with '\\n', add one. */\n+  if (inf_limit > inf_buffer && inf_limit[-1] != '\\n')\n+    inf_limit++;\n+\n   outf = fopen (argv[3], \"w\");\n   if (outf == NULL)\n     {\n@@ -727,8 +731,8 @@ main(argc, argv)\n   if (check_protection (&ifndef_line, &endif_line))\n     {\n #if 0\n-      fprintf(stderr, \"#ifndef %s on line %d; #endif on line %d\\n\",\n-\t     protect_name, ifndef_line, endif_line);\n+      fprintf (stderr, \"#ifndef %s on line %d; #endif on line %d\\n\",\n+\t       protect_name, ifndef_line, endif_line);\n #endif\n       lbrac_line = ifndef_line+1;\n       rbrac_line = endif_line;\n@@ -752,14 +756,14 @@ main(argc, argv)\n       for (;;)\n \t{\n \t  struct fn_decl *fn;\n-\t  c = INF_GET();\n+\t  c = INF_GET ();\n \t  if (c == EOF)\n \t    break;\n \t  if (isalpha (c) || c == '_')\n \t    {\n \t      struct partial_proto *partial;\n \t      c = inf_scan_ident (&buf, c);\n-\t      INF_UNGET();\n+\t      INF_UNGET (c);\n \t      fputs (buf.base, outf);\n \t      fn = lookup_std_proto (buf.base);\n \t      /* We only want to edit the declaration matching the one\n@@ -780,7 +784,7 @@ main(argc, argv)\n \t\t      else\n \t\t\t{\n \t\t\t  putc ('(', outf);\n-\t\t\t  INF_UNGET();\n+\t\t\t  INF_UNGET (c);\n \t\t\t}\n \t\t    }\n \t\t  else"}]}