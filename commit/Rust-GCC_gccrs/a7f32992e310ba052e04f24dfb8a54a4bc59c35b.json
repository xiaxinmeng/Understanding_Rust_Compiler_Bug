{"sha": "a7f32992e310ba052e04f24dfb8a54a4bc59c35b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdmMzI5OTJlMzEwYmEwNTJlMDRmMjRkZmI4YTU0YTRiYzU5YzM1Yg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-09-03T20:12:27Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-09-03T20:12:27Z"}, "message": "re PR middle-end/37243 (IRA causes wrong code generation)\n\n2008-09-03  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-opt/37243\n\t\n\t* ira-conflicts.c (REG_SUBREG_P, go_through_subreg): New.\n\t(process_regs_for_copy): Process subregs.  Refine check when cost\n\tis taken into account in ira-costs.c.\n\t(process_reg_shuffles): Use REG_SUBREG_P.\n\t(add_insn_allocno_copies): Ditto.  Ignore modes.\n\n\t* ira-color.c (conflict_allocno_vec): New.\n\t(COST_HOP_DIVISOR): New macro.\n\t(update_copy_costs_1): Use it.\n\t(update_conflict_hard_regno_costs): New function.\n\t(assign_hard_reg): Use it.\n\t(ira_color): Allocate and free conflict_allocno_vec.\n\nFrom-SVN: r139949", "tree": {"sha": "34828625de041218e77c7e6a51d132f68ec870bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34828625de041218e77c7e6a51d132f68ec870bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7f32992e310ba052e04f24dfb8a54a4bc59c35b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f32992e310ba052e04f24dfb8a54a4bc59c35b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7f32992e310ba052e04f24dfb8a54a4bc59c35b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f32992e310ba052e04f24dfb8a54a4bc59c35b/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "204853a7651de3a2590daf4139cc65d6b6cc814d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204853a7651de3a2590daf4139cc65d6b6cc814d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/204853a7651de3a2590daf4139cc65d6b6cc814d"}], "stats": {"total": 217, "additions": 172, "deletions": 45}, "files": [{"sha": "87e5fcc2d494b933bd3d59e63d588f15d60c246d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f32992e310ba052e04f24dfb8a54a4bc59c35b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f32992e310ba052e04f24dfb8a54a4bc59c35b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7f32992e310ba052e04f24dfb8a54a4bc59c35b", "patch": "@@ -1,3 +1,20 @@\n+2008-09-03  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-opt/37243\n+\t\n+\t* ira-conflicts.c (REG_SUBREG_P, go_through_subreg): New.\n+\t(process_regs_for_copy): Process subregs.  Refine check when cost\n+\tis taken into account in ira-costs.c.\n+\t(process_reg_shuffles): Use REG_SUBREG_P.\n+\t(add_insn_allocno_copies): Ditto.  Ignore modes.\n+\n+\t* ira-color.c (conflict_allocno_vec): New.\n+\t(COST_HOP_DIVISOR): New macro.\n+\t(update_copy_costs_1): Use it.\n+\t(update_conflict_hard_regno_costs): New function.\n+\t(assign_hard_reg): Use it.\n+\t(ira_color): Allocate and free conflict_allocno_vec.\n+ \n 2008-09-03  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-opt/37296"}, {"sha": "71e3f68aca078405129fb282652e5dba091659f7", "filename": "gcc/ira-color.c", "status": "modified", "additions": 105, "deletions": 31, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f32992e310ba052e04f24dfb8a54a4bc59c35b/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f32992e310ba052e04f24dfb8a54a4bc59c35b/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=a7f32992e310ba052e04f24dfb8a54a4bc59c35b", "patch": "@@ -68,6 +68,9 @@ static ira_allocno_t *sorted_allocnos;\n /* Vec representing the stack of allocnos used during coloring.  */\n static VEC(ira_allocno_t,heap) *allocno_stack_vec;\n \n+/* Vec representing conflict allocnos used during assigning.  */\n+static VEC(ira_allocno_t,heap) *conflict_allocno_vec;\n+\n /* Array used to choose an allocno for spilling.  */\n static ira_allocno_t *allocnos_for_spilling;\n \n@@ -116,6 +119,11 @@ finish_cost_update (void)\n   ira_free (allocno_update_cost_check);\n }\n \n+/* When we traverse allocnos to update hard register costs, the cost\n+   divisor will be multiplied by the following macro value for each\n+   hop from given allocno to directly connected allocnos.  */\n+#define COST_HOP_DIVISOR 4\n+\n /* This recursive function updates costs (decrease if DECR_P) of the\n    unassigned allocnos connected by copies with ALLOCNO.  This update\n    increases chances to remove some copies.  Copy cost is proportional\n@@ -180,7 +188,7 @@ update_copy_costs_1 (ira_allocno_t allocno, int hard_regno,\n \t+= update_cost;\n       if (update_cost != 0)\n \tupdate_copy_costs_1 (another_allocno, hard_regno,\n-\t\t\t     decr_p, divisor * 4);\n+\t\t\t     decr_p, divisor * COST_HOP_DIVISOR);\n     }\n }\n \n@@ -193,6 +201,84 @@ update_copy_costs (ira_allocno_t allocno, bool decr_p)\n   update_copy_costs_1 (allocno, ALLOCNO_HARD_REGNO (allocno), decr_p, 1);\n }\n \n+/* This recursive function updates COSTS (decrease if DECR_P) by\n+   conflict costs of the unassigned allocnos connected by copies with\n+   ALLOCNO.  This update increases chances to remove some copies.\n+   Copy cost is proportional to the copy frequency divided by\n+   DIVISOR.  */\n+static void\n+update_conflict_hard_regno_costs (int *costs, ira_allocno_t allocno,\n+\t\t\t\t  int divisor, bool decr_p)\n+{\n+  int i, cost, class_size, mult, div;\n+  int *conflict_costs;\n+  bool cont_p;\n+  enum machine_mode mode;\n+  enum reg_class cover_class;\n+  ira_allocno_t another_allocno;\n+  ira_copy_t cp, next_cp;\n+\n+  cover_class = ALLOCNO_COVER_CLASS (allocno);\n+  /* Probably 5 hops will be enough.  */\n+  if (divisor > (COST_HOP_DIVISOR * COST_HOP_DIVISOR\n+\t\t * COST_HOP_DIVISOR * COST_HOP_DIVISOR * COST_HOP_DIVISOR))\n+    return;\n+  if (cover_class == NO_REGS)\n+    return;\n+  /* Check that it was already visited.  */\n+  if (allocno_update_cost_check[ALLOCNO_NUM (allocno)] == update_cost_check)\n+    return;\n+  allocno_update_cost_check[ALLOCNO_NUM (allocno)] = update_cost_check;\n+  mode = ALLOCNO_MODE (allocno);\n+  class_size = ira_class_hard_regs_num[cover_class];\n+  for (cp = ALLOCNO_COPIES (allocno); cp != NULL; cp = next_cp)\n+    {\n+      if (cp->first == allocno)\n+\t{\n+\t  next_cp = cp->next_first_allocno_copy;\n+\t  another_allocno = cp->second;\n+\t}\n+      else if (cp->second == allocno)\n+\t{\n+\t  next_cp = cp->next_second_allocno_copy;\n+\t  another_allocno = cp->first;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+      if (cover_class != ALLOCNO_COVER_CLASS (another_allocno)\n+\t  || ALLOCNO_ASSIGNED_P (another_allocno)\n+\t  || ALLOCNO_MAY_BE_SPILLED_P (another_allocno))\n+\tcontinue;\n+      ira_allocate_and_copy_costs\n+\t(&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno),\n+\t cover_class, ALLOCNO_CONFLICT_HARD_REG_COSTS (another_allocno));\n+      conflict_costs\n+\t= ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno);\n+      if (conflict_costs == NULL)\n+\tcont_p = true;\n+      else\n+\t{\n+\t  ira_assert (ALLOCNO_FREQ (another_allocno) != 0);\n+\t  mult = cp->freq;\n+\t  div = ALLOCNO_FREQ (another_allocno) * divisor;\n+\t  cont_p = false;\n+\t  for (i = class_size - 1; i >= 0; i--)\n+\t    {\n+\t      cost = conflict_costs [i] * mult / div;\n+\t      if (cost == 0)\n+\t\tcontinue;\n+\t      cont_p = true;\n+\t      if (decr_p)\n+\t\tcost = -cost;\n+\t      costs[i] += cost;\n+\t    }\n+\t}\n+      if (cont_p)\n+\tupdate_conflict_hard_regno_costs (costs, another_allocno,\n+\t\t\t\t\t  divisor * COST_HOP_DIVISOR, decr_p);\n+    }\n+}\n+\n /* Sort allocnos according to the profit of usage of a hard register\n    instead of memory for them. */\n static int\n@@ -246,9 +332,7 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n   enum reg_class cover_class, rclass;\n   enum machine_mode mode;\n   ira_allocno_t a, conflict_allocno;\n-  ira_allocno_t another_allocno;\n   ira_allocno_conflict_iterator aci;\n-  ira_copy_t cp, next_cp;\n   static int costs[FIRST_PSEUDO_REGISTER], full_costs[FIRST_PSEUDO_REGISTER];\n #ifdef STACK_REGS\n   bool no_stack_reg_p;\n@@ -333,42 +417,30 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n \t\tif (conflict_costs != NULL)\n \t\t  for (j = class_size - 1; j >= 0; j--)\n \t\t    full_costs[j] -= conflict_costs[j];\n+\t\tVEC_safe_push (ira_allocno_t, heap, conflict_allocno_vec,\n+\t\t\t       conflict_allocno);\n \t      }\n \t  }\n       if (a == allocno)\n \tbreak;\n     }\n-  /* Take copies into account.  */\n+  /* Take into account preferences of allocnos connected by copies to\n+     the conflict allocnos.  */\n+  update_cost_check++;\n+  while (VEC_length (ira_allocno_t, conflict_allocno_vec) != 0)\n+    {\n+      conflict_allocno = VEC_pop (ira_allocno_t, conflict_allocno_vec);\n+      update_conflict_hard_regno_costs (full_costs, conflict_allocno,\n+\t\t\t\t\tCOST_HOP_DIVISOR, true);\n+    }\n+  update_cost_check++;\n+  /* Take preferences of allocnos connected by copies into\n+     account.  */\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n-      for (cp = ALLOCNO_COPIES (a); cp != NULL; cp = next_cp)\n-\t{\n-\t  if (cp->first == a)\n-\t    {\n-\t      next_cp = cp->next_first_allocno_copy;\n-\t      another_allocno = cp->second;\n-\t    }\n-\t  else if (cp->second == a)\n-\t    {\n-\t      next_cp = cp->next_second_allocno_copy;\n-\t      another_allocno = cp->first;\n-\t    }\n-\t  else\n-\t    gcc_unreachable ();\n-\t  if (cover_class != ALLOCNO_COVER_CLASS (another_allocno)\n-\t      || ALLOCNO_ASSIGNED_P (another_allocno))\n-\t    continue;\n-\t  ira_allocate_and_copy_costs\n-\t    (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno),\n-\t     cover_class, ALLOCNO_CONFLICT_HARD_REG_COSTS (another_allocno));\n-\t  conflict_costs\n-\t    = ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno);\n-\t  if (conflict_costs != NULL\n-\t      && ! ALLOCNO_MAY_BE_SPILLED_P (another_allocno))\n-\t    for (j = class_size - 1; j >= 0; j--)\n-\t      full_costs[j] += conflict_costs[j];\n-\t}\n+      update_conflict_hard_regno_costs (full_costs, a,\n+\t\t\t\t\tCOST_HOP_DIVISOR, false);\n       if (a == allocno)\n \tbreak;\n     }\n@@ -2853,13 +2925,15 @@ void\n ira_color (void)\n {\n   allocno_stack_vec = VEC_alloc (ira_allocno_t, heap, ira_allocnos_num);\n+  conflict_allocno_vec = VEC_alloc (ira_allocno_t, heap, ira_allocnos_num);\n   removed_splay_allocno_vec\n     = VEC_alloc (ira_allocno_t, heap, ira_allocnos_num);\n   memset (allocated_hardreg_p, 0, sizeof (allocated_hardreg_p));\n   ira_initiate_assign ();\n   do_coloring ();\n   ira_finish_assign ();\n   VEC_free (ira_allocno_t, heap, removed_splay_allocno_vec);\n+  VEC_free (ira_allocno_t, heap, conflict_allocno_vec);\n   VEC_free (ira_allocno_t, heap, allocno_stack_vec);\n   move_spill_restore ();\n }"}, {"sha": "97da7c563dfca907bb84f2d59ba31d49d9a1a26a", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 50, "deletions": 14, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f32992e310ba052e04f24dfb8a54a4bc59c35b/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f32992e310ba052e04f24dfb8a54a4bc59c35b/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=a7f32992e310ba052e04f24dfb8a54a4bc59c35b", "patch": "@@ -181,7 +181,6 @@ get_dup_num (int op_num, bool use_commut_op_p)\n   if (op_num < 0 || recog_data.n_alternatives == 0)\n     return -1;\n   op = recog_data.operand[op_num];\n-  ira_assert (REG_P (op));\n   commut_op_used_p = true;\n   if (use_commut_op_p)\n     {\n@@ -295,6 +294,32 @@ get_dup (int op_num, bool use_commut_op_p)\n     return recog_data.operand[n];\n }\n \n+/* Check that X is REG or SUBREG of REG.  */\n+#define REG_SUBREG_P(x)\t\t\t\t\t\t\t\\\n+   (REG_P (x) || (GET_CODE (x) == SUBREG && REG_P (SUBREG_REG (x))))\n+\n+/* Return X if X is a REG, otherwise it should be SUBREG of REG and\n+   the function returns the reg in this case.  *OFFSET will be set to\n+   0 in the first case or the regno offset in the first case.  */\n+static rtx\n+go_through_subreg (rtx x, int *offset)\n+{\n+  rtx reg;\n+\n+  *offset = 0;\n+  if (REG_P (x))\n+    return x;\n+  ira_assert (GET_CODE (x) == SUBREG);\n+  reg = SUBREG_REG (x);\n+  ira_assert (REG_P (reg));\n+  if (REGNO (reg) < FIRST_PSEUDO_REGISTER)\n+    *offset = subreg_regno_offset (REGNO (reg), GET_MODE (reg),\n+\t\t\t\t   SUBREG_BYTE (x), GET_MODE (x));\n+  else\n+    *offset = (SUBREG_BYTE (x) / REGMODE_NATURAL_SIZE (GET_MODE (x)));\n+  return reg;\n+}\n+\n /* Process registers REG1 and REG2 in move INSN with execution\n    frequency FREQ.  The function also processes the registers in a\n    potential move insn (INSN == NULL in this case) with frequency\n@@ -306,27 +331,32 @@ get_dup (int op_num, bool use_commut_op_p)\n static bool\n process_regs_for_copy (rtx reg1, rtx reg2, rtx insn, int freq)\n {\n-  int hard_regno, cost, index;\n+  int hard_regno, cost, index, offset1, offset2;\n+  bool only_regs_p;\n   ira_allocno_t a;\n   enum reg_class rclass, cover_class;\n   enum machine_mode mode;\n   ira_copy_t cp;\n \n-  gcc_assert (REG_P (reg1) && REG_P (reg2));\n+  gcc_assert (REG_SUBREG_P (reg1) && REG_SUBREG_P (reg2));\n+  only_regs_p = REG_P (reg1) && REG_P (reg2);\n+  reg1 = go_through_subreg (reg1, &offset1);\n+  reg2 = go_through_subreg (reg2, &offset2);\n   if (HARD_REGISTER_P (reg1))\n     {\n       if (HARD_REGISTER_P (reg2))\n \treturn false;\n-      hard_regno = REGNO (reg1);\n+      hard_regno = REGNO (reg1) + offset1 - offset2;\n       a = ira_curr_regno_allocno_map[REGNO (reg2)];\n     }\n   else if (HARD_REGISTER_P (reg2))\n     {\n-      hard_regno = REGNO (reg2);\n+      hard_regno = REGNO (reg2) + offset2 - offset1;\n       a = ira_curr_regno_allocno_map[REGNO (reg1)];\n     }\n   else if (!CONFLICT_ALLOCNO_P (ira_curr_regno_allocno_map[REGNO (reg1)],\n-\t\t\t\tira_curr_regno_allocno_map[REGNO (reg2)]))\n+\t\t\t\tira_curr_regno_allocno_map[REGNO (reg2)])\n+\t   && offset1 == offset2)\n     {\n       cp = ira_add_allocno_copy (ira_curr_regno_allocno_map[REGNO (reg1)],\n \t\t\t\t ira_curr_regno_allocno_map[REGNO (reg2)],\n@@ -341,7 +371,8 @@ process_regs_for_copy (rtx reg1, rtx reg2, rtx insn, int freq)\n   cover_class = ALLOCNO_COVER_CLASS (a);\n   if (! ira_class_subset_p[rclass][cover_class])\n     return false;\n-  if (reg_class_size[rclass] <= (unsigned) CLASS_MAX_NREGS (rclass, mode))\n+  if (reg_class_size[rclass] <= (unsigned) CLASS_MAX_NREGS (rclass, mode)\n+      && only_regs_p)\n     /* It is already taken into account in ira-costs.c.  */\n     return false;\n   index = ira_class_hard_reg_index[cover_class][hard_regno];\n@@ -371,12 +402,12 @@ process_reg_shuffles (rtx reg, int op_num, int freq)\n   int i;\n   rtx another_reg;\n \n-  gcc_assert (REG_P (reg));\n+  gcc_assert (REG_SUBREG_P (reg));\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       another_reg = recog_data.operand[i];\n       \n-      if (!REG_P (another_reg) || op_num == i\n+      if (!REG_SUBREG_P (another_reg) || op_num == i\n \t  || recog_data.operand_type[i] != OP_OUT)\n \tcontinue;\n       \n@@ -399,26 +430,31 @@ add_insn_allocno_copies (rtx insn)\n   if (freq == 0)\n     freq = 1;\n   if ((set = single_set (insn)) != NULL_RTX\n-      && REG_P (SET_DEST (set)) && REG_P (SET_SRC (set))\n+      && REG_SUBREG_P (SET_DEST (set)) && REG_SUBREG_P (SET_SRC (set))\n       && ! side_effects_p (set)\n-      && find_reg_note (insn, REG_DEAD, SET_SRC (set)) != NULL_RTX)\n+      && find_reg_note (insn, REG_DEAD,\n+\t\t\tREG_P (SET_SRC (set))\n+\t\t\t? SET_SRC (set)\n+\t\t\t: SUBREG_REG (SET_SRC (set))) != NULL_RTX)\n     process_regs_for_copy (SET_DEST (set), SET_SRC (set), insn, freq);\n   else\n     {\n       extract_insn (insn);\n       for (i = 0; i < recog_data.n_operands; i++)\n \t{\n \t  operand = recog_data.operand[i];\n-\t  if (REG_P (operand)\n-\t      && find_reg_note (insn, REG_DEAD, operand) != NULL_RTX)\n+\t  if (REG_SUBREG_P (operand)\n+\t      && find_reg_note (insn, REG_DEAD,\n+\t\t\t\tREG_P (operand)\n+\t\t\t\t? operand : SUBREG_REG (operand)) != NULL_RTX)\n \t    {\n \t      str = recog_data.constraints[i];\n \t      while (*str == ' ' && *str == '\\t')\n \t\tstr++;\n \t      bound_p = false;\n \t      for (j = 0, commut_p = false; j < 2; j++, commut_p = true)\n \t\tif ((dup = get_dup (i, commut_p)) != NULL_RTX\n-\t\t    && REG_P (dup) && GET_MODE (operand) == GET_MODE (dup)\n+\t\t    && REG_SUBREG_P (dup)\n \t\t    && process_regs_for_copy (operand, dup, NULL_RTX, freq))\n \t\t  bound_p = true;\n \t      if (bound_p)"}]}