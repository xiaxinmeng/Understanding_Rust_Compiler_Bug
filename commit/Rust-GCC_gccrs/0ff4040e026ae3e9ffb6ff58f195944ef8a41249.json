{"sha": "0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZmNDA0MGUwMjZhZTNlOWZmYjZmZjU4ZjE5NTk0NGVmOGE0MTI0OQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2006-02-20T20:25:54Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2006-02-20T20:25:54Z"}, "message": "tree-chrec.c (eq_evolutions_p): New.\n\n\t* tree-chrec.c (eq_evolutions_p): New.\n\t* tree-chrec.h (eq_evolutions_p): Declared.\n\t* tree-data-ref.c: Fix formatting.\n\t(datadep_stats, dependence_stats): New.\n\t(gcd): Moved...\n\t(print_direction_vector): New.\n\t(dump_data_dependence_relation): Use print_direction_vector.\n\t(object_analysis, create_data_ref): Handle COMPONENT_REF.\n\t(compute_subscript_distance): Static.\n\t(initialize_data_dependence_relation): Static.  Get the number\n\tof loops surrounding the references from the callers, and initialize\n\tDDR_SIZE_VECT to nb_loops.  Use both base_addr_differ_p and\n\tbase_object_differ_p analyzers.\n\t(analyze_ziv_subscript, analyze_siv_subscript_cst_affine, \n\tcompute_overlap_steps_for_affine_1_2,\n\tanalyze_subscript_affine_affine): Count the classified dependences.\n\tPrint a message when a test failed.\n\t(can_use_analyze_subscript_affine_affine): New.\t\n\t(analyze_siv_subscript): Compute the data dependences on symbolic\n\tscevs that verify can_use_analyze_subscript_affine_affine.\n\t(chrec_steps_divide_constant_p): Returns true, false, or unknown.\n\t(analyze_miv_subscript): Update use of chrec_steps_divide_constant_p.\n\tHandle symbolic scevs.\n\t(analyze_overlapping_iterations): Let symbolic affine scevs to be\n\tanalyzed.\n\t(subscript_dependence_tester): Moved...\n\t(build_classic_dist_vector, build_classic_dir_vector): Don't use \n\tlambda_vector_clear on newly allocated vectors.  Get nb_loops from\n\tDDR_SIZE_VECT instead of getting it in parameter.\n\t(subscript_dependence_tester): ... here.  Take as a parameter \n\tloop_nest_depth.  Call build_classic_dist_vector and\n\tbuild_classic_dir_vector.\n\t(compute_affine_dependence): Update subscript_dependence_tester \n\tparameters.  Update datadep_stats counters.  Call \n\tcompute_subscript_distance.\n\t(compute_self_dependence): Save the dist and dir vectors.  Call \n\tcompute_subscript_distance.\n\t(ddr_p, DEF_VEC_P(ddr_p), DEF_VEC_ALLOC_P(ddr_p,heap)): Moved...\n\t(compute_all_dependences): Reorder parameters as they were before\n\tconversion to VEC.  Pass nb_loops and loop_nest_depth.  Don't call\n\tcompute_subscript_distance.  Update the use of \n\tcompute_affine_dependence and initialize_data_dependence_relation.\n\t(find_data_references_in_loop): Handle COMPONENT_REF.\n\t(compute_data_dependences_for_loop): Initialize dependence_stats.\n\tDon't call build_classic_dist_vector and build_classic_dir_vector.\n\tUpdate the parameters of initialize_data_dependence_relation and \n\tcompute_all_dependences.  Print the statistics from datadep_stats.\n\t(analyze_all_data_dependences): Static.  Not used until the pass for\n\tchecking the data dependences is contributed.\n\t* tree-data-ref.h (ddr_p, DEF_VEC_P(ddr_p),\n\tDEF_VEC_ALLOC_P(ddr_p,heap)): ... here.\n\t(initialize_data_dependence_relation, compute_affine_dependence, \n\tanalyze_all_data_dependences, compute_subscript_distance): Removed.\n\t(print_direction_vector): New.\n\t* lambda.h (gcd): ... here.\n\t(lambda_vector_gcd): Moved here from gcd_vector.\n\t* lambda-code.c (gcd, gcd_vector): Removed.\n\t(lambda_compute_target_space): Use lambda_vector_gcd.  Fix formatting.\n\t* Makefile.in (tree-vect-patterns.o): Depends on TREE_DATA_REF_H.\n\nFrom-SVN: r111312", "tree": {"sha": "45b8c5480ee9c4ad169479540e3dedfe214df603", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45b8c5480ee9c4ad169479540e3dedfe214df603"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "643519b778286cad4430d0eb4b7a7082120a5fdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/643519b778286cad4430d0eb4b7a7082120a5fdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/643519b778286cad4430d0eb4b7a7082120a5fdb"}], "stats": {"total": 977, "additions": 702, "deletions": 275}, "files": [{"sha": "acd83523c66891425072f9bf30015c3cac5744ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "patch": "@@ -1,3 +1,65 @@\n+2006-02-20  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* tree-chrec.c (eq_evolutions_p): New.\n+\t* tree-chrec.h (eq_evolutions_p): Declared.\n+\t* tree-data-ref.c: Fix formatting.\n+\t(datadep_stats, dependence_stats): New.\n+\t(gcd): Moved...\n+\t(print_direction_vector): New.\n+\t(dump_data_dependence_relation): Use print_direction_vector.\n+\t(object_analysis, create_data_ref): Handle COMPONENT_REF.\n+\t(compute_subscript_distance): Static.\n+\t(initialize_data_dependence_relation): Static.  Get the number\n+\tof loops surrounding the references from the callers, and initialize\n+\tDDR_SIZE_VECT to nb_loops.  Use both base_addr_differ_p and\n+\tbase_object_differ_p analyzers.\n+\t(analyze_ziv_subscript, analyze_siv_subscript_cst_affine, \n+\tcompute_overlap_steps_for_affine_1_2,\n+\tanalyze_subscript_affine_affine): Count the classified dependences.\n+\tPrint a message when a test failed.\n+\t(can_use_analyze_subscript_affine_affine): New.\t\n+\t(analyze_siv_subscript): Compute the data dependences on symbolic\n+\tscevs that verify can_use_analyze_subscript_affine_affine.\n+\t(chrec_steps_divide_constant_p): Returns true, false, or unknown.\n+\t(analyze_miv_subscript): Update use of chrec_steps_divide_constant_p.\n+\tHandle symbolic scevs.\n+\t(analyze_overlapping_iterations): Let symbolic affine scevs to be\n+\tanalyzed.\n+\t(subscript_dependence_tester): Moved...\n+\t(build_classic_dist_vector, build_classic_dir_vector): Don't use \n+\tlambda_vector_clear on newly allocated vectors.  Get nb_loops from\n+\tDDR_SIZE_VECT instead of getting it in parameter.\n+\t(subscript_dependence_tester): ... here.  Take as a parameter \n+\tloop_nest_depth.  Call build_classic_dist_vector and\n+\tbuild_classic_dir_vector.\n+\t(compute_affine_dependence): Update subscript_dependence_tester \n+\tparameters.  Update datadep_stats counters.  Call \n+\tcompute_subscript_distance.\n+\t(compute_self_dependence): Save the dist and dir vectors.  Call \n+\tcompute_subscript_distance.\n+\t(ddr_p, DEF_VEC_P(ddr_p), DEF_VEC_ALLOC_P(ddr_p,heap)): Moved...\n+\t(compute_all_dependences): Reorder parameters as they were before\n+\tconversion to VEC.  Pass nb_loops and loop_nest_depth.  Don't call\n+\tcompute_subscript_distance.  Update the use of \n+\tcompute_affine_dependence and initialize_data_dependence_relation.\n+\t(find_data_references_in_loop): Handle COMPONENT_REF.\n+\t(compute_data_dependences_for_loop): Initialize dependence_stats.\n+\tDon't call build_classic_dist_vector and build_classic_dir_vector.\n+\tUpdate the parameters of initialize_data_dependence_relation and \n+\tcompute_all_dependences.  Print the statistics from datadep_stats.\n+\t(analyze_all_data_dependences): Static.  Not used until the pass for\n+\tchecking the data dependences is contributed.\n+\t* tree-data-ref.h (ddr_p, DEF_VEC_P(ddr_p),\n+\tDEF_VEC_ALLOC_P(ddr_p,heap)): ... here.\n+\t(initialize_data_dependence_relation, compute_affine_dependence, \n+\tanalyze_all_data_dependences, compute_subscript_distance): Removed.\n+\t(print_direction_vector): New.\n+\t* lambda.h (gcd): ... here.\n+\t(lambda_vector_gcd): Moved here from gcd_vector.\n+\t* lambda-code.c (gcd, gcd_vector): Removed.\n+\t(lambda_compute_target_space): Use lambda_vector_gcd.  Fix formatting.\n+\t* Makefile.in (tree-vect-patterns.o): Depends on TREE_DATA_REF_H.\n+\n 2006-02-20  Diego Novillo  <dnovillo@redhat.com>\n \n \t* ipa-type-escape.c: Tidy some comments and white space."}, {"sha": "002b1c941518464ce34342186feca0304580c3e3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "patch": "@@ -2057,7 +2057,7 @@ tree-vect-analyze.o: tree-vect-analyze.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n tree-vect-patterns.o: tree-vect-patterns.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) errors.h $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    diagnostic.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) cfgloop.h \\\n-   tree-vectorizer.h tree-data-ref.h $(EXPR_H)\n+   tree-vectorizer.h $(TREE_DATA_REF_H) $(EXPR_H)\n tree-vect-transform.o: tree-vect-transform.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(GGC_H) $(OPTABS_H) $(RECOG_H) $(TREE_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \\"}, {"sha": "9d61c774231e3fdb261e26260b2c3f1ea2e899b4", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 8, "deletions": 47, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "patch": "@@ -1,5 +1,5 @@\n /*  Loop transformation code generation\n-    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+    Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n     Contributed by Daniel Berlin <dberlin@dberlin.org>\n \n     This file is part of GCC.\n@@ -441,45 +441,6 @@ lambda_lattice_compute_base (lambda_loopnest nest)\n   return ret;\n }\n \n-/* Compute the greatest common denominator of two numbers (A and B) using\n-   Euclid's algorithm.  */\n-\n-static int\n-gcd (int a, int b)\n-{\n-\n-  int x, y, z;\n-\n-  x = abs (a);\n-  y = abs (b);\n-\n-  while (x > 0)\n-    {\n-      z = y % x;\n-      y = x;\n-      x = z;\n-    }\n-\n-  return (y);\n-}\n-\n-/* Compute the greatest common denominator of a VECTOR of SIZE numbers.  */\n-\n-static int\n-gcd_vector (lambda_vector vector, int size)\n-{\n-  int i;\n-  int gcd1 = 0;\n-\n-  if (size > 0)\n-    {\n-      gcd1 = vector[0];\n-      for (i = 1; i < size; i++)\n-\tgcd1 = gcd (gcd1, vector[i]);\n-    }\n-  return gcd1;\n-}\n-\n /* Compute the least common multiple of two numbers A and B .  */\n \n static int\n@@ -848,7 +809,7 @@ lambda_compute_target_space (lambda_loopnest auxillary_nest,\n       LN_LOOPS (target_nest)[i] = target_loop;\n \n       /* Computes the gcd of the coefficients of the linear part.  */\n-      gcd1 = gcd_vector (target[i], i);\n+      gcd1 = lambda_vector_gcd (target[i], i);\n \n       /* Include the denominator in the GCD.  */\n       gcd1 = gcd (gcd1, determinant);\n@@ -911,9 +872,9 @@ lambda_compute_target_space (lambda_loopnest auxillary_nest,\n \t    }\n \t  /* Find the gcd and divide by it here, rather than doing it\n \t     at the tree level.  */\n-\t  gcd1 = gcd_vector (LLE_COEFFICIENTS (target_expr), depth);\n-\t  gcd2 = gcd_vector (LLE_INVARIANT_COEFFICIENTS (target_expr),\n-\t\t\t     invariants);\n+\t  gcd1 = lambda_vector_gcd (LLE_COEFFICIENTS (target_expr), depth);\n+\t  gcd2 = lambda_vector_gcd (LLE_INVARIANT_COEFFICIENTS (target_expr),\n+\t\t\t\t    invariants);\n \t  gcd1 = gcd (gcd1, gcd2);\n \t  gcd1 = gcd (gcd1, LLE_CONSTANT (target_expr));\n \t  gcd1 = gcd (gcd1, LLE_DENOMINATOR (target_expr));\n@@ -967,9 +928,9 @@ lambda_compute_target_space (lambda_loopnest auxillary_nest,\n \t    }\n \t  /* Find the gcd and divide by it here, instead of at the\n \t     tree level.  */\n-\t  gcd1 = gcd_vector (LLE_COEFFICIENTS (target_expr), depth);\n-\t  gcd2 = gcd_vector (LLE_INVARIANT_COEFFICIENTS (target_expr),\n-\t\t\t     invariants);\n+\t  gcd1 = lambda_vector_gcd (LLE_COEFFICIENTS (target_expr), depth);\n+\t  gcd2 = lambda_vector_gcd (LLE_INVARIANT_COEFFICIENTS (target_expr),\n+\t\t\t\t    invariants);\n \t  gcd1 = gcd (gcd1, gcd2);\n \t  gcd1 = gcd (gcd1, LLE_CONSTANT (target_expr));\n \t  gcd1 = gcd (gcd1, LLE_DENOMINATOR (target_expr));"}, {"sha": "7a43be29b5987932a881f19c4427becff13f0d5d", "filename": "gcc/lambda.h", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "patch": "@@ -1,5 +1,5 @@\n /* Lambda matrix and vector interface.\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Daniel Berlin <dberlin@dberlin.org>\n \n This file is part of GCC.\n@@ -380,6 +380,44 @@ print_lambda_vector (FILE * outfile, lambda_vector vector, int n)\n   fprintf (outfile, \"\\n\");\n }\n \n+/* Compute the greatest common divisor of two numbers using\n+   Euclid's algorithm.  */\n+\n+static inline int \n+gcd (int a, int b)\n+{\n+  int x, y, z;\n+\n+  x = abs (a);\n+  y = abs (b);\n+\n+  while (x > 0)\n+    {\n+      z = y % x;\n+      y = x;\n+      x = z;\n+    }\n+\n+  return y;\n+}\n+\n+/* Compute the greatest common divisor of a VECTOR of SIZE numbers.  */\n+\n+static inline int\n+lambda_vector_gcd (lambda_vector vector, int size)\n+{\n+  int i;\n+  int gcd1 = 0;\n+\n+  if (size > 0)\n+    {\n+      gcd1 = vector[0];\n+      for (i = 1; i < size; i++)\n+\tgcd1 = gcd (gcd1, vector[i]);\n+    }\n+  return gcd1;\n+}\n+\n /* Returns true when the vector V is lexicographically positive, in\n    other words, when the first nonzero element is positive.  */\n "}, {"sha": "b1587a5f91d3070107d9dd203c1312394b62c2a3", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "patch": "@@ -1,6 +1,6 @@\n /* Chains of recurrences.\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <s.pop@laposte.net>\n+   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <pop@cri.ensmp.fr>\n \n This file is part of GCC.\n \n@@ -1232,3 +1232,32 @@ chrec_type (tree chrec)\n   \n   return TREE_TYPE (chrec);\n }\n+\n+/* Returns true when CHREC0 == CHREC1.  */\n+\n+bool \n+eq_evolutions_p (tree chrec0, \n+\t\t tree chrec1)\n+{\n+  if (chrec0 == NULL_TREE\n+      || chrec1 == NULL_TREE\n+      || TREE_CODE (chrec0) != TREE_CODE (chrec1))\n+    return false;\n+\n+  if (chrec0 == chrec1)\n+    return true;\n+\n+  switch (TREE_CODE (chrec0))\n+    {\n+    case INTEGER_CST:\n+      return integer_zerop (fold (build2 (MINUS_EXPR, TREE_TYPE (chrec0), \n+\t\t\t\t\t chrec0, chrec1)));\n+    case POLYNOMIAL_CHREC:\n+      return (CHREC_VARIABLE (chrec0) == CHREC_VARIABLE (chrec1)\n+\t      && eq_evolutions_p (CHREC_LEFT (chrec0), CHREC_LEFT (chrec1))\n+\t      && eq_evolutions_p (CHREC_RIGHT (chrec0), CHREC_RIGHT (chrec1)));\n+    default:\n+      return false;\n+    }  \n+}\n+"}, {"sha": "55f6e978545721d768e44c413ea370fa42e077ae", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "patch": "@@ -1,6 +1,6 @@\n /* Chains of recurrences.\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <s.pop@laposte.net>\n+   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <pop@cri.ensmp.fr>\n \n This file is part of GCC.\n \n@@ -82,6 +82,7 @@ extern tree reset_evolution_in_loop (unsigned, tree, tree);\n extern tree chrec_merge (tree, tree);\n \n /* Observers.  */\n+extern bool eq_evolutions_p (tree, tree);\n extern bool is_multivariate_chrec (tree);\n extern bool chrec_is_positive (tree, bool *);\n extern bool chrec_contains_symbols (tree);"}, {"sha": "d243e45ad1654d5ce6ed7c499dc611f4af6b7a9f", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 551, "deletions": 213, "changes": 764, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "patch": "@@ -1,6 +1,6 @@\n /* Data references and dependences detectors.\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <s.pop@laposte.net>\n+   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <pop@cri.ensmp.fr>\n \n This file is part of GCC.\n \n@@ -94,6 +94,33 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n \n+static struct datadep_stats\n+{\n+  int num_dependence_tests;\n+  int num_dependence_dependent;\n+  int num_dependence_independent;\n+  int num_dependence_undetermined;\n+\n+  int num_subscript_tests;\n+  int num_subscript_undetermined;\n+  int num_same_subscript_function;\n+\n+  int num_ziv;\n+  int num_ziv_independent;\n+  int num_ziv_dependent;\n+  int num_ziv_unimplemented;\n+\n+  int num_siv;\n+  int num_siv_independent;\n+  int num_siv_dependent;\n+  int num_siv_unimplemented;\n+\n+  int num_miv;\n+  int num_miv_independent;\n+  int num_miv_dependent;\n+  int num_miv_unimplemented;\n+} dependence_stats;\n+\n static tree object_analysis (tree, tree, bool, struct data_reference **, \n \t\t\t     tree *, tree *, tree *, tree *, tree *,\n \t\t\t     struct ptr_info_def **, subvar_t *);\n@@ -397,7 +424,6 @@ base_object_differ_p (struct data_reference *a,\n           only try to prove that the bases are surely different\n */\n \n-\n static bool\n base_addr_differ_p (struct data_reference *dra,\n \t\t    struct data_reference *drb,\n@@ -415,13 +441,12 @@ base_addr_differ_p (struct data_reference *dra,\n   type_b = TREE_TYPE (addr_b);\n \n   gcc_assert (POINTER_TYPE_P (type_a) &&  POINTER_TYPE_P (type_b));\n-  \n+\n   /* 1. if (both DRA and DRB are represented as arrays)\n             compare DRA.BASE_OBJECT and DRB.BASE_OBJECT.  */\n   if (DR_TYPE (dra) == ARRAY_REF_TYPE && DR_TYPE (drb) == ARRAY_REF_TYPE)\n     return base_object_differ_p (dra, drb, differ_p);\n \n-\n   /* 2. else if (both DRA and DRB are represented as pointers)\n \t    try to prove that DRA.FIRST_LOCATION == DRB.FIRST_LOCATION.  */\n   /* If base addresses are the same, we check the offsets, since the access of \n@@ -442,7 +467,7 @@ base_addr_differ_p (struct data_reference *dra,\n \n       /* FORNOW: we only compare offsets that are MULT_EXPR, i.e., we don't handle\n \t PLUS_EXPR.  */\n-      if ((offset_a == offset_b)\n+      if (offset_a == offset_b\n \t  || (TREE_CODE (offset_a) == MULT_EXPR \n \t      && TREE_CODE (offset_b) == MULT_EXPR\n \t      && TREE_OPERAND (offset_a, 0) == TREE_OPERAND (offset_b, 0)\n@@ -475,7 +500,6 @@ base_addr_differ_p (struct data_reference *dra,\n   return false;\n }\n \n-\n /* Returns true iff A divides B.  */\n \n static inline bool \n@@ -486,28 +510,6 @@ tree_fold_divides_p (tree a,\n   return tree_int_cst_equal (a, tree_fold_gcd (a, b));\n }\n \n-/* Compute the greatest common denominator of two numbers using\n-   Euclid's algorithm.  */\n-\n-static int \n-gcd (int a, int b)\n-{\n-  \n-  int x, y, z;\n-  \n-  x = abs (a);\n-  y = abs (b);\n-\n-  while (x>0)\n-    {\n-      z = y % x;\n-      y = x;\n-      x = z;\n-    }\n-\n-  return (y);\n-}\n-\n /* Returns true iff A divides B.  */\n \n static inline bool \n@@ -554,7 +556,7 @@ dump_data_reference (FILE *outf,\n   print_generic_stmt (outf, DR_STMT (dr), 0);\n   fprintf (outf, \"  ref: \");\n   print_generic_stmt (outf, DR_REF (dr), 0);\n-  fprintf (outf, \"  base_name: \");\n+  fprintf (outf, \"  base_object: \");\n   print_generic_stmt (outf, DR_BASE_OBJECT (dr), 0);\n   \n   for (i = 0; i < DR_NUM_DIMENSIONS (dr); i++)\n@@ -606,6 +608,50 @@ dump_subscript (FILE *outf, struct subscript *subscript)\n   fprintf (outf, \" )\\n\");\n }\n \n+/* Print the classic direction vector DIRV to OUTF.  */\n+\n+void\n+print_direction_vector (FILE *outf,\n+\t\t\tlambda_vector dirv,\n+\t\t\tint length)\n+{\n+  int eq;\n+\n+  for (eq = 0; eq < length; eq++)\n+    {\n+      enum data_dependence_direction dir = dirv[eq];\n+\n+      switch (dir)\n+\t{\n+\tcase dir_positive:\n+\t  fprintf (outf, \"    +\");\n+\t  break;\n+\tcase dir_negative:\n+\t  fprintf (outf, \"    -\");\n+\t  break;\n+\tcase dir_equal:\n+\t  fprintf (outf, \"    =\");\n+\t  break;\n+\tcase dir_positive_or_equal:\n+\t  fprintf (outf, \"   +=\");\n+\t  break;\n+\tcase dir_positive_or_negative:\n+\t  fprintf (outf, \"   +-\");\n+\t  break;\n+\tcase dir_negative_or_equal:\n+\t  fprintf (outf, \"   -=\");\n+\t  break;\n+\tcase dir_star:\n+\t  fprintf (outf, \"    *\");\n+\t  break;\n+\tdefault:\n+\t  fprintf (outf, \"indep\");\n+\t  break;\n+\t}\n+    }\n+  fprintf (outf, \"\\n\");\n+}\n+\n /* Dump function for a DATA_DEPENDENCE_RELATION structure.  */\n \n void \n@@ -646,16 +692,14 @@ dump_data_dependence_relation (FILE *outf,\n       for (i = 0; i < DDR_NUM_DIR_VECTS (ddr); i++)\n \t{\n \t  fprintf (outf, \"  direction_vector: \");\n-\t  print_lambda_vector (outf, DDR_DIR_VECT (ddr, i),\n-\t\t\t       DDR_SIZE_VECT (ddr));\n+\t  print_direction_vector (outf, DDR_DIR_VECT (ddr, i),\n+\t\t\t\t  DDR_SIZE_VECT (ddr));\n \t}\n     }\n \n   fprintf (outf, \")\\n\");\n }\n \n-\n-\n /* Dump function for a DATA_DEPENDENCE_DIRECTION structure.  */\n \n void\n@@ -726,8 +770,8 @@ dump_dist_dir_vectors (FILE *file, varray_type ddrs)\n \t  for (j = 0; j < DDR_NUM_DIR_VECTS (ddr); j++)\n \t    {\n \t      fprintf (file, \"DIRECTION_V (\");\n-\t      print_lambda_vector (file, DDR_DIR_VECT (ddr, j),\n-\t\t\t\t   DDR_SIZE_VECT (ddr));\n+\t      print_direction_vector (file, DDR_DIR_VECT (ddr, j),\n+\t\t\t\t      DDR_SIZE_VECT (ddr));\n \t      fprintf (file, \")\\n\");\n \t    }\n \t}\n@@ -826,15 +870,15 @@ analyze_array_indexes (struct loop *loop,\n {\n   tree opnd0, opnd1;\n   tree access_fn;\n-  \n+\n   opnd0 = TREE_OPERAND (ref, 0);\n   opnd1 = TREE_OPERAND (ref, 1);\n-  \n+\n   /* The detection of the evolution function for this data access is\n      postponed until the dependence test.  This lazy strategy avoids\n      the computation of access functions that are of no interest for\n      the optimizers.  */\n-  access_fn = instantiate_parameters \n+  access_fn = instantiate_parameters\n     (loop, analyze_scalar_evolution (loop, opnd1));\n \n   if (estimate_only \n@@ -847,7 +891,7 @@ analyze_array_indexes (struct loop *loop,\n   /* Recursively record other array access functions.  */\n   if (TREE_CODE (opnd0) == ARRAY_REF)\n     return analyze_array_indexes (loop, access_fns, opnd0, stmt, estimate_only);\n-  \n+\n   /* Return the base name of the data access.  */\n   else\n     return opnd0;\n@@ -881,13 +925,13 @@ analyze_array (tree stmt, tree ref, bool is_read)\n       print_generic_stmt (dump_file, ref, 0);\n       fprintf (dump_file, \")\\n\");\n     }\n-  \n+\n   res = XNEW (struct data_reference);\n-  \n+\n   DR_STMT (res) = stmt;\n   DR_REF (res) = ref;\n   acc_fns = VEC_alloc (tree, heap, 3);\n-  DR_BASE_OBJECT (res) = analyze_array_indexes \n+  DR_BASE_OBJECT (res) = analyze_array_indexes\n     (loop_containing_stmt (stmt), &acc_fns, ref, stmt, false);\n   DR_TYPE (res) = ARRAY_REF_TYPE;\n   DR_SET_ACCESS_FNS (res, acc_fns);\n@@ -899,22 +943,21 @@ analyze_array (tree stmt, tree ref, bool is_read)\n   DR_OFFSET_MISALIGNMENT (res) = NULL_TREE;\n   DR_MEMTAG (res) = NULL_TREE;\n   DR_PTR_INFO (res) = NULL;\n-  \n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \")\\n\");\n-  \n+\n   return res;\n }\n \n-\n /* Analyze an indirect memory reference, REF, that comes from STMT.\n    IS_READ is true if this is an indirect load, and false if it is\n    an indirect store.\n    Return a new data reference structure representing the indirect_ref, or\n    NULL if we cannot describe the access function.  */\n-  \n+\n static struct data_reference *\n-analyze_indirect_ref (tree stmt, tree ref, bool is_read) \n+analyze_indirect_ref (tree stmt, tree ref, bool is_read)\n {\n   struct loop *loop = loop_containing_stmt (stmt);\n   tree ptr_ref = TREE_OPERAND (ref, 0);\n@@ -926,7 +969,7 @@ analyze_indirect_ref (tree stmt, tree ref, bool is_read)\n   if (TREE_CODE (ptr_ref) == SSA_NAME)\n     ptr_info = SSA_NAME_PTR_INFO (ptr_ref);\n \n-  STRIP_NOPS (init);   \n+  STRIP_NOPS (init);\n   if (access_fn == chrec_dont_know || !init || init == chrec_dont_know)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1003,9 +1046,9 @@ init_data_ref (tree stmt,\n       print_generic_stmt (dump_file, ref, 0);\n       fprintf (dump_file, \")\\n\");\n     }\n-  \n+\n   res = XNEW (struct data_reference);\n-  \n+\n   DR_STMT (res) = stmt;\n   DR_REF (res) = ref;\n   DR_BASE_OBJECT (res) = base;\n@@ -1021,15 +1064,13 @@ init_data_ref (tree stmt,\n   DR_OFFSET_MISALIGNMENT (res) = misalign;\n   DR_MEMTAG (res) = memtag;\n   DR_PTR_INFO (res) = ptr_info;\n-  \n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \")\\n\");\n-  \n+\n   return res;\n }\n \n-\f\n-\n /* Function strip_conversions\n \n    Strip conversions that don't narrow the mode.  */\n@@ -1472,6 +1513,7 @@ object_analysis (tree memref, tree stmt, bool is_read,\n   struct loop *loop = loop_containing_stmt (stmt);\n   struct data_reference *ptr_dr = NULL;\n   tree object_aligned_to = NULL_TREE, address_aligned_to = NULL_TREE;\n+  tree comp_ref = NULL_TREE;\n \n  *ptr_info = NULL;\n \n@@ -1480,14 +1522,14 @@ object_analysis (tree memref, tree stmt, bool is_read,\n   if (handled_component_p (memref))\n     {\n       /* 1.1 build data-reference structure for MEMREF.  */\n-      /* TODO: handle COMPONENT_REFs.  */\n       if (!(*dr))\n \t{ \n \t  if (TREE_CODE (memref) == ARRAY_REF)\n \t    *dr = analyze_array (stmt, memref, is_read);\t  \n-\t  else\n+\t  else if (TREE_CODE (memref) == COMPONENT_REF)\n+\t    comp_ref = memref;\n+\t  else  \n \t    {\n-\t      /* FORNOW.  */\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n \t\t  fprintf (dump_file, \"\\ndata-ref of unsupported type \");\n@@ -1550,16 +1592,34 @@ object_analysis (tree memref, tree stmt, bool is_read,\n   /*  Part 1: Case 2. Declarations.  */ \n   if (DECL_P (memref))\n     {\n-      /* We expect to get a decl only if we already have a DR.  */\n+      /* We expect to get a decl only if we already have a DR, or with \n+\t COMPONENT_REFs of type 'a[i].b'.  */\n       if (!(*dr))\n \t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t  if (comp_ref && TREE_CODE (TREE_OPERAND (comp_ref, 0)) == ARRAY_REF)\n \t    {\n-\t      fprintf (dump_file, \"\\nunhandled decl \");\n-\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n+\t      *dr = analyze_array (stmt, TREE_OPERAND (comp_ref, 0), is_read);\t      \t      \n+\t      if (DR_NUM_DIMENSIONS (*dr) != 1)\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"\\n multidimensional component ref \");\n+\t\t      print_generic_expr (dump_file, comp_ref, TDF_SLIM);\n+\t\t      fprintf (dump_file, \"\\n\");\n+\t\t    }\n+\t\t  return NULL_TREE;\n+\t\t}\n+\t    }\n+\t  else \n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"\\nunhandled decl \");\n+\t\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      return NULL_TREE;\n \t    }\n-\t  return NULL_TREE;\n \t}\n \n       /* TODO: if during the analysis of INDIRECT_REF we get to an object, put \n@@ -1684,6 +1744,9 @@ object_analysis (tree memref, tree stmt, bool is_read,\n       return NULL_TREE;\n     }\n \n+  if (comp_ref)\n+    DR_REF (*dr) = comp_ref;\n+\n   if (SSA_VAR_P (*memtag) && var_can_have_subvars (*memtag))\n     *subvars = get_subvars_for_var (*memtag);\n \t\n@@ -1781,7 +1844,7 @@ create_data_ref (tree memref, tree stmt, bool is_read)\n   tree type_size, init_cond;\n   struct ptr_info_def *ptr_info;\n   subvar_t subvars = NULL;\n-  tree aligned_to;\n+  tree aligned_to, type = NULL_TREE, orig_offset;\n \n   if (!memref)\n     return NULL;\n@@ -1812,6 +1875,32 @@ create_data_ref (tree memref, tree stmt, bool is_read)\n   \n   type_size = fold_convert (ssizetype, TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr))));\n \n+  /* Extract CONSTANT and INVARIANT from OFFSET.  */\n+  /* Remove cast from OFFSET and restore it for INVARIANT part.  */\n+  orig_offset = offset;\n+  STRIP_NOPS (offset);\n+  if (offset != orig_offset)\n+    type = TREE_TYPE (orig_offset);\n+  analyze_offset (offset, &invariant, &constant);\n+  if (type && invariant)\n+    invariant = fold_convert (type, invariant);\n+\n+  /* Put CONSTANT part of OFFSET in DR_INIT and INVARIANT in DR_OFFSET field\n+     of DR.  */\n+  if (constant)\n+    {\n+      DR_INIT (dr) = fold_convert (ssizetype, constant);\n+      init_cond = fold_build2 (TRUNC_DIV_EXPR, TREE_TYPE (constant), \n+\t\t\t       constant, type_size);\n+    }\n+  else\n+    DR_INIT (dr) = init_cond = ssize_int (0);;\n+  \n+  if (invariant)\n+    DR_OFFSET (dr) = invariant;\n+  else\n+    DR_OFFSET (dr) = ssize_int (0);\n+\n   /* Change the access function for INIDIRECT_REFs, according to \n      DR_BASE_ADDRESS.  Analyze OFFSET calculated in object_analysis. OFFSET is \n      an expression that can contain loop invariant expressions and constants.\n@@ -1821,28 +1910,12 @@ create_data_ref (tree memref, tree stmt, bool is_read)\n      The evolution part of the access function is STEP calculated in\n      object_analysis divided by the size of data type.\n   */\n-  if (!DR_BASE_OBJECT (dr))\n+  if (!DR_BASE_OBJECT (dr)\n+      || (TREE_CODE (memref) == COMPONENT_REF && DR_NUM_DIMENSIONS (dr) == 1))\n     {\n       tree access_fn;\n       tree new_step;\n \n-      /* Extract CONSTANT and INVARIANT from OFFSET, and put them in DR_INIT and\n-\t DR_OFFSET fields of DR.  */\n-      analyze_offset (offset, &invariant, &constant); \n-      if (constant)\n-\t{\n-\t  DR_INIT (dr) = fold_convert (ssizetype, constant);\n-\t  init_cond = fold_build2 (TRUNC_DIV_EXPR, TREE_TYPE (constant), \n-\t\t\t\t   constant, type_size);\n-\t}\n-      else\n-\tDR_INIT (dr) = init_cond = ssize_int (0);;\n-\n-      if (invariant)\n-\tDR_OFFSET (dr) = invariant;\n-      else\n-\tDR_OFFSET (dr) = ssize_int (0);\n-\n       /* Update access function.  */\n       access_fn = DR_ACCESS_FN (dr, 0);\n       new_step = size_binop (TRUNC_DIV_EXPR,  \n@@ -1916,7 +1989,7 @@ all_chrecs_equal_p (tree chrec)\n /* Determine for each subscript in the data dependence relation DDR\n    the distance.  */\n \n-void\n+static void\n compute_subscript_distance (struct data_dependence_relation *ddr)\n {\n   if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n@@ -1966,15 +2039,18 @@ compute_subscript_distance (struct data_dependence_relation *ddr)\n     }\n }\n \n-/* Initialize a ddr.  */\n+/* Initialize a data dependence relation between data accesses A and\n+   B.  NB_LOOPS is the number of loops surrounding the references: the\n+   size of the classic distance/direction vectors.  */\n \n-struct data_dependence_relation *\n+static struct data_dependence_relation *\n initialize_data_dependence_relation (struct data_reference *a, \n-\t\t\t\t     struct data_reference *b)\n+\t\t\t\t     struct data_reference *b,\n+\t\t\t\t     int nb_loops)\n {\n   struct data_dependence_relation *res;\n-  bool differ_p;\n-  unsigned int i;  \n+  bool differ_p, known_dependence;\n+  unsigned int i;\n   \n   res = XNEW (struct data_dependence_relation);\n   DDR_A (res) = a;\n@@ -1995,24 +2071,29 @@ initialize_data_dependence_relation (struct data_reference *a,\n       return res;\n     }\n \n-    /* Compare the bases of the data-refs.  */\n-  if (!base_addr_differ_p (a, b, &differ_p))\n+  if (DR_BASE_ADDRESS (a) && DR_BASE_ADDRESS (b))\n+    known_dependence = base_addr_differ_p (a, b, &differ_p);\n+  else \n+    known_dependence = base_object_differ_p (a, b, &differ_p);\n+\n+  if (!known_dependence)\n     {\n       /* Can't determine whether the data-refs access the same memory \n \t region.  */\n       DDR_ARE_DEPENDENT (res) = chrec_dont_know;    \n       return res;\n     }\n+\n   if (differ_p)\n     {\n       DDR_ARE_DEPENDENT (res) = chrec_known;    \n       return res;\n     }\n-  \n+\n   DDR_AFFINE_P (res) = true;\n   DDR_ARE_DEPENDENT (res) = NULL_TREE;\n   DDR_SUBSCRIPTS_VECTOR_INIT (res, DR_NUM_DIMENSIONS (a));\n-  DDR_SIZE_VECT (res) = 0;\n+  DDR_SIZE_VECT (res) = nb_loops;\n   DDR_DIR_VECTS (res) = NULL;\n   DDR_DIST_VECTS (res) = NULL;\n \n@@ -2128,6 +2209,7 @@ analyze_ziv_subscript (tree chrec_a,\n \t\t       tree *last_conflicts)\n {\n   tree difference;\n+  dependence_stats.num_ziv++;\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(analyze_ziv_subscript \\n\");\n@@ -2144,22 +2226,28 @@ analyze_ziv_subscript (tree chrec_a,\n \t  *overlaps_a = integer_zero_node;\n \t  *overlaps_b = integer_zero_node;\n \t  *last_conflicts = chrec_dont_know;\n+\t  dependence_stats.num_ziv_dependent++;\n \t}\n       else\n \t{\n \t  /* The accesses do not overlap.  */\n \t  *overlaps_a = chrec_known;\n \t  *overlaps_b = chrec_known;\n \t  *last_conflicts = integer_zero_node;\n+\t  dependence_stats.num_ziv_independent++;\n \t}\n       break;\n       \n     default:\n       /* We're not sure whether the indexes overlap.  For the moment, \n \t conservatively answer \"don't know\".  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"ziv test failed: difference is non-integer.\\n\");\n+\n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n       *last_conflicts = chrec_dont_know;\n+      dependence_stats.num_ziv_unimplemented++;\n       break;\n     }\n   \n@@ -2204,6 +2292,10 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n   \n   if (!chrec_is_positive (initial_condition (difference), &value0))\n     {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"siv test failed: chrec is not positive.\\n\"); \n+\n+      dependence_stats.num_siv_unimplemented++;\n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n       *last_conflicts = chrec_dont_know;\n@@ -2215,9 +2307,13 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t{\n \t  if (!chrec_is_positive (CHREC_RIGHT (chrec_b), &value1))\n \t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"siv test failed: chrec not positive.\\n\");\n+\n \t      *overlaps_a = chrec_dont_know;\n \t      *overlaps_b = chrec_dont_know;      \n \t      *last_conflicts = chrec_dont_know;\n+\t      dependence_stats.num_siv_unimplemented++;\n \t      return;\n \t    }\n \t  else\n@@ -2254,8 +2350,10 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t\t  *overlaps_a = chrec_known;\n \t\t\t  *overlaps_b = chrec_known;\n \t\t\t  *last_conflicts = integer_zero_node;\n+\t\t\t  dependence_stats.num_siv_independent++;\n \t\t\t  return;\n \t\t\t}\t\t\n+\t\t      dependence_stats.num_siv_dependent++;\n \t\t      return;\n \t\t    }\n \t\t  \n@@ -2266,6 +2364,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t      *overlaps_a = chrec_known;\n \t\t      *overlaps_b = chrec_known;      \n \t\t      *last_conflicts = integer_zero_node;\n+\t\t      dependence_stats.num_siv_independent++;\n \t\t      return;\n \t\t    }\n \t\t}\n@@ -2280,6 +2379,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t  *overlaps_a = chrec_known;\n \t\t  *overlaps_b = chrec_known;\n \t\t  *last_conflicts = integer_zero_node;\n+\t\t  dependence_stats.num_siv_independent++;\n \t\t  return;\n \t\t}\n \t    }\n@@ -2288,9 +2388,13 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t{\n \t  if (!chrec_is_positive (CHREC_RIGHT (chrec_b), &value2))\n \t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"siv test failed: chrec not positive.\\n\");\n+\n \t      *overlaps_a = chrec_dont_know;\n \t      *overlaps_b = chrec_dont_know;      \n \t      *last_conflicts = chrec_dont_know;\n+\t      dependence_stats.num_siv_unimplemented++;\n \t      return;\n \t    }\n \t  else\n@@ -2323,8 +2427,10 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t\t  *overlaps_a = chrec_known;\n \t\t\t  *overlaps_b = chrec_known;\n \t\t\t  *last_conflicts = integer_zero_node;\n+\t\t\t  dependence_stats.num_siv_independent++;\n \t\t\t  return;\n \t\t\t}\t\n+\t\t      dependence_stats.num_siv_dependent++;\n \t\t      return;\n \t\t    }\n \t\t  \n@@ -2335,6 +2441,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t      *overlaps_a = chrec_known;\n \t\t      *overlaps_b = chrec_known;      \n \t\t      *last_conflicts = integer_zero_node;\n+\t\t      dependence_stats.num_siv_independent++;\n \t\t      return;\n \t\t    }\n \t\t}\n@@ -2348,6 +2455,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t  *overlaps_a = chrec_known;\n \t\t  *overlaps_b = chrec_known;\n \t\t  *last_conflicts = integer_zero_node;\n+\t\t  dependence_stats.num_siv_independent++;\n \t\t  return;\n \t\t}\n \t    }\n@@ -2455,6 +2563,9 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n   if (numiter_x == NULL_TREE || numiter_y == NULL_TREE \n       || numiter_z == NULL_TREE)\n     {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"overlap steps test failed: no iteration counts.\\n\");\n+\t   \n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n       *last_conflicts = chrec_dont_know;\n@@ -2532,8 +2643,9 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n }\n \n /* Determines the overlapping elements due to accesses CHREC_A and\n-   CHREC_B, that are affine functions.  This is a part of the\n-   subscript analyzer.  */\n+   CHREC_B, that are affine functions.  This function cannot handle\n+   symbolic evolution functions, ie. when initial conditions are\n+   parameters, because it uses lambda matrices of integers.  */\n \n static void\n analyze_subscript_affine_affine (tree chrec_a, \n@@ -2604,10 +2716,12 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t  numiter_b = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_b));\n \t  if (numiter_a == NULL_TREE || numiter_b == NULL_TREE)\n \t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"affine-affine test failed: missing iteration counts.\\n\");\n \t      *overlaps_a = chrec_dont_know;\n \t      *overlaps_b = chrec_dont_know;\n \t      *last_conflicts = chrec_dont_know;\n-\t      return;\n+\t      goto end_analyze_subs_aa;\n \t    }\n \n \t  niter_a = int_cst_value (numiter_a);\n@@ -2632,11 +2746,13 @@ analyze_subscript_affine_affine (tree chrec_a,\n \n       else\n \t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"affine-affine test failed: too many variables.\\n\");\n \t  *overlaps_a = chrec_dont_know;\n \t  *overlaps_b = chrec_dont_know;\n \t  *last_conflicts = chrec_dont_know;\n \t}\n-      return;\n+      goto end_analyze_subs_aa;\n     }\n \n   /* U.A = S */\n@@ -2697,10 +2813,12 @@ analyze_subscript_affine_affine (tree chrec_a,\n \n \t  if (numiter_a == NULL_TREE || numiter_b == NULL_TREE)\n \t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"affine-affine test failed: missing iteration counts.\\n\");\n \t      *overlaps_a = chrec_dont_know;\n \t      *overlaps_b = chrec_dont_know;\n \t      *last_conflicts = chrec_dont_know;\n-\t      return;\n+\t      goto end_analyze_subs_aa;\n \t    }\n \n \t  niter_a = int_cst_value (numiter_a);\n@@ -2754,7 +2872,6 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t\t      /* If the overlap occurs outside of the bounds of the\n \t\t\t loop, there is no dependence.  */\n \t\t      if (x0 > niter || y0  > niter)\n-\n \t\t\t{\n \t\t\t  *overlaps_a = chrec_known;\n \t\t\t  *overlaps_b = chrec_known;\n@@ -2777,6 +2894,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t\t    {\n \t\t      /* FIXME: For the moment, the upper bound of the\n \t\t\t iteration domain for j is not checked.  */\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\tfprintf (dump_file, \"affine-affine test failed: unimplemented.\\n\");\n \t\t      *overlaps_a = chrec_dont_know;\n \t\t      *overlaps_b = chrec_dont_know;\n \t\t      *last_conflicts = chrec_dont_know;\n@@ -2787,6 +2906,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t\t{\n \t\t  /* FIXME: For the moment, the upper bound of the\n \t\t     iteration domain for i is not checked.  */\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"affine-affine test failed: unimplemented.\\n\");\n \t\t  *overlaps_a = chrec_dont_know;\n \t\t  *overlaps_b = chrec_dont_know;\n \t\t  *last_conflicts = chrec_dont_know;\n@@ -2795,6 +2916,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t}\n       else\n \t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"affine-affine test failed: unimplemented.\\n\");\n \t  *overlaps_a = chrec_dont_know;\n \t  *overlaps_b = chrec_dont_know;\n \t  *last_conflicts = chrec_dont_know;\n@@ -2803,23 +2926,63 @@ analyze_subscript_affine_affine (tree chrec_a,\n \n   else\n     {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"affine-affine test failed: unimplemented.\\n\");\n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n       *last_conflicts = chrec_dont_know;\n     }\n \n-\n+end_analyze_subs_aa:  \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"  (overlaps_a = \");\n       print_generic_expr (dump_file, *overlaps_a, 0);\n       fprintf (dump_file, \")\\n  (overlaps_b = \");\n       print_generic_expr (dump_file, *overlaps_b, 0);\n       fprintf (dump_file, \")\\n\");\n+      fprintf (dump_file, \")\\n\");\n     }\n-  \n+}\n+\n+/* Returns true when analyze_subscript_affine_affine can be used for\n+   determining the dependence relation between chrec_a and chrec_b,\n+   that contain symbols.  This function modifies chrec_a and chrec_b\n+   such that the analysis result is the same, and such that they don't\n+   contain symbols, and then can safely be passed to the analyzer.  \n+\n+   Example: The analysis of the following tuples of evolutions produce\n+   the same results: {x+1, +, 1}_1 vs. {x+3, +, 1}_1, and {-2, +, 1}_1\n+   vs. {0, +, 1}_1\n+   \n+   {x+1, +, 1}_1 ({2, +, 1}_1) = {x+3, +, 1}_1 ({0, +, 1}_1)\n+   {-2, +, 1}_1 ({2, +, 1}_1) = {0, +, 1}_1 ({0, +, 1}_1)\n+*/\n+\n+static bool\n+can_use_analyze_subscript_affine_affine (tree *chrec_a, tree *chrec_b)\n+{\n+  tree diff;\n+\n+  if (chrec_contains_symbols (CHREC_RIGHT (*chrec_a))\n+      || chrec_contains_symbols (CHREC_RIGHT (*chrec_b)))\n+    /* FIXME: For the moment not handled.  Might be refined later.  */\n+    return false;\n+\n+  diff = chrec_fold_minus (chrec_type (*chrec_a), CHREC_LEFT (*chrec_a), \n+\t\t\t   CHREC_LEFT (*chrec_b));\n+  if (!evolution_function_is_constant_p (diff))\n+    return false;\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \")\\n\");\n+    fprintf (dump_file, \"can_use_subscript_aff_aff_for_symbolic \\n\");\n+\n+  *chrec_a = build_polynomial_chrec (CHREC_VARIABLE (*chrec_a), \n+\t\t\t\t     diff, CHREC_RIGHT (*chrec_a));\n+  *chrec_b = build_polynomial_chrec (CHREC_VARIABLE (*chrec_b),\n+\t\t\t\t     integer_zero_node, \n+\t\t\t\t     CHREC_RIGHT (*chrec_b));\n+  return true;\n }\n \n /* Analyze a SIV (Single Index Variable) subscript.  *OVERLAPS_A and\n@@ -2836,6 +2999,8 @@ analyze_siv_subscript (tree chrec_a,\n \t\t       tree *overlaps_b, \n \t\t       tree *last_conflicts)\n {\n+  dependence_stats.num_siv++;\n+  \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(analyze_siv_subscript \\n\");\n   \n@@ -2851,32 +3016,87 @@ analyze_siv_subscript (tree chrec_a,\n   \n   else if (evolution_function_is_affine_p (chrec_a)\n \t   && evolution_function_is_affine_p (chrec_b))\n-    analyze_subscript_affine_affine (chrec_a, chrec_b, \n-\t\t\t\t     overlaps_a, overlaps_b, last_conflicts);\n+    {\n+      if (!chrec_contains_symbols (chrec_a)\n+\t  && !chrec_contains_symbols (chrec_b))\n+\t{\n+\t  analyze_subscript_affine_affine (chrec_a, chrec_b, \n+\t\t\t\t\t   overlaps_a, overlaps_b, \n+\t\t\t\t\t   last_conflicts);\n+\n+\t  if (*overlaps_a == chrec_dont_know\n+\t      || *overlaps_b == chrec_dont_know)\n+\t    dependence_stats.num_siv_unimplemented++;\n+\t  else if (*overlaps_a == chrec_known\n+\t\t   || *overlaps_b == chrec_known)\n+\t    dependence_stats.num_siv_independent++;\n+\t  else\n+\t    dependence_stats.num_siv_dependent++;\n+\t}\n+      else if (can_use_analyze_subscript_affine_affine (&chrec_a, \n+\t\t\t\t\t\t\t&chrec_b))\n+\t{\n+\t  analyze_subscript_affine_affine (chrec_a, chrec_b, \n+\t\t\t\t\t   overlaps_a, overlaps_b, \n+\t\t\t\t\t   last_conflicts);\n+\t  /* FIXME: The number of iterations is a symbolic expression.\n+\t     Compute it properly.  */\n+\t  *last_conflicts = chrec_dont_know;\n+\n+\t  if (*overlaps_a == chrec_dont_know\n+\t      || *overlaps_b == chrec_dont_know)\n+\t    dependence_stats.num_siv_unimplemented++;\n+\t  else if (*overlaps_a == chrec_known\n+\t\t   || *overlaps_b == chrec_known)\n+\t    dependence_stats.num_siv_independent++;\n+\t  else\n+\t    dependence_stats.num_siv_dependent++;\n+\t}\n+      else\n+\tgoto siv_subscript_dontknow;\n+    }\n+\n   else\n     {\n+    siv_subscript_dontknow:;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"siv test failed: unimplemented.\\n\");\n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n       *last_conflicts = chrec_dont_know;\n+      dependence_stats.num_siv_unimplemented++;\n     }\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \")\\n\");\n }\n \n-/* Return true when the evolution steps of an affine CHREC divide the\n-   constant CST.  */\n+/* Return true when the property can be computed.  RES should contain\n+   true when calling the first time this function, then it is set to\n+   false when one of the evolution steps of an affine CHREC does not\n+   divide the constant CST.  */\n \n static bool\n chrec_steps_divide_constant_p (tree chrec, \n-\t\t\t       tree cst)\n+\t\t\t       tree cst, \n+\t\t\t       bool *res)\n {\n   switch (TREE_CODE (chrec))\n     {\n     case POLYNOMIAL_CHREC:\n-      return (tree_fold_divides_p (CHREC_RIGHT (chrec), cst)\n-\t      && chrec_steps_divide_constant_p (CHREC_LEFT (chrec), cst));\n-      \n+      if (evolution_function_is_constant_p (CHREC_RIGHT (chrec)))\n+\t{\n+\t  if (tree_fold_divides_p (CHREC_RIGHT (chrec), cst))\n+\t    /* Keep RES to true, and iterate on other dimensions.  */\n+\t    return chrec_steps_divide_constant_p (CHREC_LEFT (chrec), cst, res);\n+\t  \n+\t  *res = false;\n+\t  return true;\n+\t}\n+      else\n+\t/* When the step is a parameter the result is undetermined.  */\n+\treturn false;\n+\n     default:\n       /* On the initial condition, return true.  */\n       return true;\n@@ -2905,8 +3125,9 @@ analyze_miv_subscript (tree chrec_a,\n      variables.  In the MIV case we have to solve a Diophantine\n      equation with 2*n variables (if the subscript uses n IVs).\n   */\n+  bool divide_p = true;\n   tree difference;\n-  \n+  dependence_stats.num_miv++;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(analyze_miv_subscript \\n\");\n   \n@@ -2919,26 +3140,30 @@ analyze_miv_subscript (tree chrec_a,\n       *overlaps_a = integer_zero_node;\n       *overlaps_b = integer_zero_node;\n       *last_conflicts = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_a));\n-      \n+      dependence_stats.num_miv_dependent++;\n     }\n   \n   else if (evolution_function_is_constant_p (difference)\n \t   /* For the moment, the following is verified:\n \t      evolution_function_is_affine_multivariate_p (chrec_a) */\n-\t   && !chrec_steps_divide_constant_p (chrec_a, difference))\n+\t   && chrec_steps_divide_constant_p (chrec_a, difference, &divide_p)\n+\t   && !divide_p)\n     {\n       /* testsuite/.../ssa-chrec-33.c\n \t {{21, +, 2}_1, +, -2}_2  vs.  {{20, +, 2}_1, +, -2}_2 \n-        \n+\t \n \t The difference is 1, and the evolution steps are equal to 2,\n \t consequently there are no overlapping elements.  */\n       *overlaps_a = chrec_known;\n       *overlaps_b = chrec_known;\n       *last_conflicts = integer_zero_node;\n+      dependence_stats.num_miv_independent++;\n     }\n   \n   else if (evolution_function_is_affine_multivariate_p (chrec_a)\n-\t   && evolution_function_is_affine_multivariate_p (chrec_b))\n+\t   && !chrec_contains_symbols (chrec_a)\n+\t   && evolution_function_is_affine_multivariate_p (chrec_b)\n+\t   && !chrec_contains_symbols (chrec_b))\n     {\n       /* testsuite/.../ssa-chrec-35.c\n \t {0, +, 1}_2  vs.  {0, +, 1}_3\n@@ -2956,14 +3181,27 @@ analyze_miv_subscript (tree chrec_a,\n       */\n       analyze_subscript_affine_affine (chrec_a, chrec_b, \n \t\t\t\t       overlaps_a, overlaps_b, last_conflicts);\n+\n+      if (*overlaps_a == chrec_dont_know\n+\t  || *overlaps_b == chrec_dont_know)\n+\tdependence_stats.num_miv_unimplemented++;\n+      else if (*overlaps_a == chrec_known\n+\t       || *overlaps_b == chrec_known)\n+\tdependence_stats.num_miv_independent++;\n+      else\n+\tdependence_stats.num_miv_dependent++;\n     }\n   \n   else\n     {\n       /* When the analysis is too difficult, answer \"don't know\".  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"analyze_miv_subscript test failed: unimplemented.\\n\");\n+\n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n       *last_conflicts = chrec_dont_know;\n+      dependence_stats.num_miv_unimplemented++;\n     }\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2987,27 +3225,52 @@ analyze_overlapping_iterations (tree chrec_a,\n \t\t\t\ttree *overlap_iterations_b, \n \t\t\t\ttree *last_conflicts)\n {\n+  dependence_stats.num_subscript_tests++;\n+  \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"(analyze_overlapping_iterations \\n\");\n       fprintf (dump_file, \"  (chrec_a = \");\n       print_generic_expr (dump_file, chrec_a, 0);\n-      fprintf (dump_file, \")\\n  chrec_b = \");\n+      fprintf (dump_file, \")\\n  (chrec_b = \");\n       print_generic_expr (dump_file, chrec_b, 0);\n       fprintf (dump_file, \")\\n\");\n     }\n-  \n+\n   if (chrec_a == NULL_TREE\n       || chrec_b == NULL_TREE\n       || chrec_contains_undetermined (chrec_a)\n-      || chrec_contains_undetermined (chrec_b)\n-      || chrec_contains_symbols (chrec_a)\n-      || chrec_contains_symbols (chrec_b))\n+      || chrec_contains_undetermined (chrec_b))\n     {\n+      dependence_stats.num_subscript_undetermined++;\n+      \n       *overlap_iterations_a = chrec_dont_know;\n       *overlap_iterations_b = chrec_dont_know;\n     }\n-  \n+\n+  /* If they are the same chrec, and are affine, they overlap \n+     on every iteration.  */\n+  else if (eq_evolutions_p (chrec_a, chrec_b)\n+\t   && evolution_function_is_affine_multivariate_p (chrec_a))\n+    {\n+      dependence_stats.num_same_subscript_function++;\n+      *overlap_iterations_a = integer_zero_node;\n+      *overlap_iterations_b = integer_zero_node;\n+      *last_conflicts = chrec_dont_know;\n+    }\n+\n+  /* If they aren't the same, and aren't affine, we can't do anything\n+     yet. */\n+  else if ((chrec_contains_symbols (chrec_a) \n+\t    || chrec_contains_symbols (chrec_b))\n+\t   && (!evolution_function_is_affine_multivariate_p (chrec_a)\n+\t       || !evolution_function_is_affine_multivariate_p (chrec_b)))\n+    {\n+      dependence_stats.num_subscript_undetermined++;\n+      *overlap_iterations_a = chrec_dont_know;\n+      *overlap_iterations_b = chrec_dont_know;\n+    }\n+\n   else if (ziv_subscript_p (chrec_a, chrec_b))\n     analyze_ziv_subscript (chrec_a, chrec_b, \n \t\t\t   overlap_iterations_a, overlap_iterations_b,\n@@ -3030,62 +3293,14 @@ analyze_overlapping_iterations (tree chrec_a,\n       fprintf (dump_file, \")\\n  (overlap_iterations_b = \");\n       print_generic_expr (dump_file, *overlap_iterations_b, 0);\n       fprintf (dump_file, \")\\n\");\n+      fprintf (dump_file, \")\\n\");\n     }\n }\n \n \f\n \n /* This section contains the affine functions dependences detector.  */\n \n-/* Computes the conflicting iterations, and initialize DDR.  */\n-\n-static void\n-subscript_dependence_tester (struct data_dependence_relation *ddr)\n-{\n-  unsigned int i;\n-  struct data_reference *dra = DDR_A (ddr);\n-  struct data_reference *drb = DDR_B (ddr);\n-  tree last_conflicts;\n-  \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"(subscript_dependence_tester \\n\");\n-  \n-  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n-    {\n-      tree overlaps_a, overlaps_b;\n-      struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n-      \n-      analyze_overlapping_iterations (DR_ACCESS_FN (dra, i), \n-\t\t\t\t      DR_ACCESS_FN (drb, i),\n-\t\t\t\t      &overlaps_a, &overlaps_b, \n-\t\t\t\t      &last_conflicts);\n-      \n-      if (chrec_contains_undetermined (overlaps_a)\n- \t  || chrec_contains_undetermined (overlaps_b))\n- \t{\n- \t  finalize_ddr_dependent (ddr, chrec_dont_know);\n-\t  break;\n- \t}\n-      \n-      else if (overlaps_a == chrec_known\n- \t       || overlaps_b == chrec_known)\n- \t{\n- \t  finalize_ddr_dependent (ddr, chrec_known);\n- \t  break;\n- \t}\n-      \n-      else\n- \t{\n- \t  SUB_CONFLICTS_IN_A (subscript) = overlaps_a;\n- \t  SUB_CONFLICTS_IN_B (subscript) = overlaps_b;\n-\t  SUB_LAST_CONFLICT (subscript) = last_conflicts;\n- \t}\n-    }\n-  \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \")\\n\");\n-}\n-\n /* Compute the classic per loop distance vector.\n \n    DDR is the data dependence relation to build a vector from.\n@@ -3098,21 +3313,20 @@ subscript_dependence_tester (struct data_dependence_relation *ddr)\n \n static bool\n build_classic_dist_vector (struct data_dependence_relation *ddr, \n-\t\t\t   int nb_loops, int first_loop_depth)\n+\t\t\t   int first_loop_depth)\n {\n   unsigned i;\n   lambda_vector dist_v, init_v;\n+  int nb_loops = DDR_SIZE_VECT (ddr);\n   bool init_b = false;\n   \n   DDR_SIZE_VECT (ddr) = nb_loops;\n   dist_v = lambda_vector_new (nb_loops);\n   init_v = lambda_vector_new (nb_loops);\n-  lambda_vector_clear (dist_v, nb_loops);\n-  lambda_vector_clear (init_v, nb_loops);\n-  \n+\n   if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE)\n     return true;\n-  \n+\n   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n       tree access_fn_a, access_fn_b;\n@@ -3325,16 +3539,15 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \n static bool\n build_classic_dir_vector (struct data_dependence_relation *ddr, \n-\t\t\t  int nb_loops, int first_loop_depth)\n+\t\t\t  int first_loop_depth)\n {\n   unsigned i;\n   lambda_vector dir_v, init_v;\n+  int nb_loops = DDR_SIZE_VECT (ddr);\n   bool init_b = false;\n   \n   dir_v = lambda_vector_new (nb_loops);\n   init_v = lambda_vector_new (nb_loops);\n-  lambda_vector_clear (dir_v, nb_loops);\n-  lambda_vector_clear (init_v, nb_loops);\n \n   DDR_SIZE_VECT (ddr) = nb_loops;\n   \n@@ -3495,13 +3708,71 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \n \tlca = lca->outer;\n \tlca_depth = lca->depth - first_loop_depth;\n-\t   \n       }\n   }\n \n   return true;\n }\n \n+/* Computes the conflicting iterations, and initialize DDR.  */\n+\n+static void\n+subscript_dependence_tester (struct data_dependence_relation *ddr,\n+\t\t\t     int loop_nest_depth)\n+{\n+  unsigned int i;\n+  struct data_reference *dra = DDR_A (ddr);\n+  struct data_reference *drb = DDR_B (ddr);\n+  tree last_conflicts;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"(subscript_dependence_tester \\n\");\n+  \n+  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+    {\n+      tree overlaps_a, overlaps_b;\n+      struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n+      \n+      analyze_overlapping_iterations (DR_ACCESS_FN (dra, i), \n+\t\t\t\t      DR_ACCESS_FN (drb, i),\n+\t\t\t\t      &overlaps_a, &overlaps_b, \n+\t\t\t\t      &last_conflicts);\n+      \n+      if (chrec_contains_undetermined (overlaps_a)\n+ \t  || chrec_contains_undetermined (overlaps_b))\n+ \t{\n+ \t  finalize_ddr_dependent (ddr, chrec_dont_know);\n+\t  dependence_stats.num_dependence_undetermined++;\n+\t  goto subs_test_end;\n+ \t}\n+      \n+      else if (overlaps_a == chrec_known\n+ \t       || overlaps_b == chrec_known)\n+ \t{\n+ \t  finalize_ddr_dependent (ddr, chrec_known);\n+\t  dependence_stats.num_dependence_independent++;\n+\t  goto subs_test_end;\n+ \t}\n+      \n+      else\n+ \t{\n+ \t  SUB_CONFLICTS_IN_A (subscript) = overlaps_a;\n+ \t  SUB_CONFLICTS_IN_B (subscript) = overlaps_b;\n+\t  SUB_LAST_CONFLICT (subscript) = last_conflicts;\n+ \t}\n+    }\n+\n+  dependence_stats.num_dependence_dependent++;\n+\n+ subs_test_end:;\n+  compute_subscript_distance (ddr);\n+  if (build_classic_dist_vector (ddr, loop_nest_depth))\n+    build_classic_dir_vector (ddr, loop_nest_depth);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \")\\n\");\n+}\n+\n /* Returns true when all the access functions of A are affine or\n    constant.  */\n \n@@ -3529,8 +3800,9 @@ access_functions_are_affine_or_constant_p (struct data_reference *a)\n    relation the first time we detect a CHREC_KNOWN element for a given\n    subscript.  */\n \n-void\n-compute_affine_dependence (struct data_dependence_relation *ddr)\n+static void\n+compute_affine_dependence (struct data_dependence_relation *ddr,\n+\t\t\t   int loop_nest_depth)\n {\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n@@ -3544,19 +3816,33 @@ compute_affine_dependence (struct data_dependence_relation *ddr)\n       print_generic_expr (dump_file, DR_STMT (drb), 0);\n       fprintf (dump_file, \")\\n\");\n     }\n-  \n+\n   /* Analyze only when the dependence relation is not yet known.  */\n   if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n     {\n+      dependence_stats.num_dependence_tests++;\n+\n       if (access_functions_are_affine_or_constant_p (dra)\n \t  && access_functions_are_affine_or_constant_p (drb))\n-\tsubscript_dependence_tester (ddr);\n+\tsubscript_dependence_tester (ddr, loop_nest_depth);\n       \n       /* As a last case, if the dependence cannot be determined, or if\n \t the dependence is considered too difficult to determine, answer\n \t \"don't know\".  */\n       else\n-\tfinalize_ddr_dependent (ddr, chrec_dont_know);\n+\t{\n+\t  dependence_stats.num_dependence_undetermined++;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Data ref a:\\n\");\n+\t      dump_data_reference (dump_file, dra);\n+\t      fprintf (dump_file, \"Data ref b:\\n\");\n+\t      dump_data_reference (dump_file, drb);\n+\t      fprintf (dump_file, \"affine dependence test not usable: access function not affine or constant.\\n\");\n+\t    }\n+\t  finalize_ddr_dependent (ddr, chrec_dont_know);\n+\t}\n     }\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3570,6 +3856,7 @@ static void\n compute_self_dependence (struct data_dependence_relation *ddr)\n {\n   unsigned int i;\n+  lambda_vector dir_v, dist_v;\n \n   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n@@ -3580,12 +3867,16 @@ compute_self_dependence (struct data_dependence_relation *ddr)\n       SUB_CONFLICTS_IN_B (subscript) = integer_zero_node;\n       SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n     }\n-}\n \n+  /* The distance vector is the zero vector.  */\n+  dist_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n+  dir_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n+\n+  VEC_safe_push (lambda_vector, heap, DDR_DIST_VECTS (ddr), dist_v);\n+  VEC_safe_push (lambda_vector, heap, DDR_DIR_VECTS (ddr), dir_v);\n \n-typedef struct data_dependence_relation *ddr_p;\n-DEF_VEC_P(ddr_p);\n-DEF_VEC_ALLOC_P(ddr_p,heap);\n+  compute_subscript_distance (ddr);\n+}\n \n /* Compute a subset of the data dependence relation graph.  Don't\n    compute read-read and self relations if \n@@ -3595,9 +3886,10 @@ DEF_VEC_ALLOC_P(ddr_p,heap);\n    in DEPENDENCE_RELATIONS.  */\n \n static void \n-compute_all_dependences (varray_type datarefs, \n+compute_all_dependences (varray_type datarefs,\n+\t\t\t VEC(ddr_p,heap) **dependence_relations,\n \t\t\t bool compute_self_and_read_read_dependences,\n-\t\t\t VEC(ddr_p,heap) **dependence_relations)\n+\t\t\t unsigned nb_loops, unsigned loop_nest_depth)\n {\n   unsigned int i, j, N;\n \n@@ -3614,32 +3906,30 @@ compute_all_dependences (varray_type datarefs,\n \n \ta = VARRAY_GENERIC_PTR (datarefs, i);\n \tb = VARRAY_GENERIC_PTR (datarefs, j);\n+\n \tif (DR_IS_READ (a) && DR_IS_READ (b)\n             && !compute_self_and_read_read_dependences)\n \t  continue;\n-\tddr = initialize_data_dependence_relation (a, b);\n \n+\tddr = initialize_data_dependence_relation (a, b, nb_loops);\n \tVEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n-\tcompute_affine_dependence (ddr);\n-\tcompute_subscript_distance (ddr);\n+\tcompute_affine_dependence (ddr, loop_nest_depth);\n       }\n+\n   if (!compute_self_and_read_read_dependences)\n     return;\n \n   /* Compute self dependence relation of each dataref to itself.  */\n-\n   for (i = 0; i < N; i++)\n     {\n       struct data_reference *a, *b;\n       struct data_dependence_relation *ddr;\n \n       a = VARRAY_GENERIC_PTR (datarefs, i);\n       b = VARRAY_GENERIC_PTR (datarefs, i);\n-      ddr = initialize_data_dependence_relation (a, b);\n-\n+      ddr = initialize_data_dependence_relation (a, b, nb_loops);\n       VEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n       compute_self_dependence (ddr);\n-      compute_subscript_distance (ddr);\n     }\n }\n \n@@ -3689,7 +3979,8 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t\ttree opnd1 = TREE_OPERAND (stmt, 1);\n \t\t\n \t\tif (TREE_CODE (opnd0) == ARRAY_REF \n-\t\t    || TREE_CODE (opnd0) == INDIRECT_REF)\n+\t\t    || TREE_CODE (opnd0) == INDIRECT_REF\n+                    || TREE_CODE (opnd0) == COMPONENT_REF)\n \t\t  {\n \t\t    dr = create_data_ref (opnd0, stmt, false);\n \t\t    if (dr) \n@@ -3700,7 +3991,8 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t\t  }\n \n \t\tif (TREE_CODE (opnd1) == ARRAY_REF \n-\t\t    || TREE_CODE (opnd1) == INDIRECT_REF)\n+\t\t    || TREE_CODE (opnd1) == INDIRECT_REF\n+\t\t    || TREE_CODE (opnd1) == COMPONENT_REF)\n \t\t  {\n \t\t    dr = create_data_ref (opnd1, stmt, true);\n \t\t    if (dr) \n@@ -3724,7 +4016,8 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t\tfor (args = TREE_OPERAND (stmt, 1); args; \n \t\t     args = TREE_CHAIN (args))\n \t\t  if (TREE_CODE (TREE_VALUE (args)) == ARRAY_REF\n-\t\t      || TREE_CODE (TREE_VALUE (args)) == INDIRECT_REF)\n+\t\t      || TREE_CODE (TREE_VALUE (args)) == INDIRECT_REF\n+\t\t      || TREE_CODE (TREE_VALUE (args)) == COMPONENT_REF)\n \t\t    {\n \t\t      dr = create_data_ref (TREE_VALUE (args), stmt, true);\n \t\t      if (dr)\n@@ -3803,6 +4096,7 @@ compute_data_dependences_for_loop (struct loop *loop,\n     loop_nest = loop_nest->outer;\n \n   nb_loops = loop_nest->level;\n+  memset (&dependence_stats, 0, sizeof (dependence_stats));\n \n   /* If one of the data references is not computable, give up without\n      spending time to compute other dependences.  */\n@@ -3812,25 +4106,68 @@ compute_data_dependences_for_loop (struct loop *loop,\n \n       /* Insert a single relation into dependence_relations:\n \t chrec_dont_know.  */\n-      ddr = initialize_data_dependence_relation (NULL, NULL);\n+      ddr = initialize_data_dependence_relation (NULL, NULL, nb_loops);\n       VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n-      build_classic_dist_vector (ddr, nb_loops, loop->depth);\n-      build_classic_dir_vector (ddr, nb_loops, loop->depth);\n       return;\n     }\n \n   allrelations = NULL;\n-  compute_all_dependences (*datarefs, compute_self_and_read_read_dependences,\n-\t\t\t   &allrelations);\n+  compute_all_dependences (*datarefs, &allrelations,\n+\t\t\t   compute_self_and_read_read_dependences,\n+\t\t\t   nb_loops, loop_nest->depth);\n \n+  /* FIXME: We copy the contents of allrelations back to a VARRAY\n+     because the vectorizer has not yet been converted to use VECs.  */\n   for (i = 0; VEC_iterate (ddr_p, allrelations, i, ddr); i++)\n+    VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n+\n+  if (dump_file && (dump_flags & TDF_STATS))\n     {\n-      if (build_classic_dist_vector (ddr, nb_loops, loop_nest->depth))\n-\t{\n-\t  VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n-\t  build_classic_dir_vector (ddr, nb_loops, loop_nest->depth);\n-\t}\n-    }\n+      fprintf (dump_file, \"Dependence tester statistics:\\n\");\n+\n+      fprintf (dump_file, \"Number of dependence tests: %d\\n\", \n+\t       dependence_stats.num_dependence_tests);\n+      fprintf (dump_file, \"Number of dependence tests classified dependent: %d\\n\", \n+\t       dependence_stats.num_dependence_dependent);\n+      fprintf (dump_file, \"Number of dependence tests classified independent: %d\\n\", \n+\t       dependence_stats.num_dependence_independent);\n+      fprintf (dump_file, \"Number of undetermined dependence tests: %d\\n\", \n+\t       dependence_stats.num_dependence_undetermined);\n+\n+      fprintf (dump_file, \"Number of subscript tests: %d\\n\", \n+\t       dependence_stats.num_subscript_tests);\n+      fprintf (dump_file, \"Number of undetermined subscript tests: %d\\n\", \n+\t       dependence_stats.num_subscript_undetermined);\n+      fprintf (dump_file, \"Number of same subscript function: %d\\n\", \n+\t       dependence_stats.num_same_subscript_function);\n+\n+      fprintf (dump_file, \"Number of ziv tests: %d\\n\",\n+\t       dependence_stats.num_ziv);\n+      fprintf (dump_file, \"Number of ziv tests returning dependent: %d\\n\",\n+\t       dependence_stats.num_ziv_dependent);\n+      fprintf (dump_file, \"Number of ziv tests returning independent: %d\\n\",\n+\t       dependence_stats.num_ziv_independent);\n+      fprintf (dump_file, \"Number of ziv tests unimplemented: %d\\n\",\n+\t       dependence_stats.num_ziv_unimplemented);      \n+\n+      fprintf (dump_file, \"Number of siv tests: %d\\n\", \n+\t       dependence_stats.num_siv);\n+      fprintf (dump_file, \"Number of siv tests returning dependent: %d\\n\",\n+\t       dependence_stats.num_siv_dependent);\n+      fprintf (dump_file, \"Number of siv tests returning independent: %d\\n\",\n+\t       dependence_stats.num_siv_independent);\n+      fprintf (dump_file, \"Number of siv tests unimplemented: %d\\n\",\n+\t       dependence_stats.num_siv_unimplemented);\n+\n+      fprintf (dump_file, \"Number of miv tests: %d\\n\", \n+\t       dependence_stats.num_miv);\n+      fprintf (dump_file, \"Number of miv tests returning dependent: %d\\n\",\n+\t       dependence_stats.num_miv_dependent);\n+      fprintf (dump_file, \"Number of miv tests returning independent: %d\\n\",\n+\t       dependence_stats.num_miv_independent);\n+      fprintf (dump_file, \"Number of miv tests unimplemented: %d\\n\",\n+\t       dependence_stats.num_miv_unimplemented);\n+    }    \n }\n \n /* Entry point (for testing only).  Analyze all the data references\n@@ -3854,8 +4191,8 @@ compute_data_dependences_for_loop (struct loop *loop,\n    recompute the same information.  The implementation of this KB is\n    transparent to the optimizer, and thus the KB can be changed with a\n    more efficient implementation, or the KB could be disabled.  */\n-\n-void \n+#if 0\n+static void \n analyze_all_data_dependences (struct loops *loops)\n {\n   unsigned int i;\n@@ -3921,6 +4258,7 @@ analyze_all_data_dependences (struct loops *loops)\n   free_dependence_relations (dependence_relations);\n   free_data_refs (datarefs);\n }\n+#endif\n \n /* Free the memory used by a data dependence relation DDR.  */\n "}, {"sha": "2c246df0660c56afe617dad7a8c458e201e07539", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff4040e026ae3e9ffb6ff58f195944ef8a41249/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=0ff4040e026ae3e9ffb6ff58f195944ef8a41249", "patch": "@@ -1,6 +1,6 @@\n /* Data references and dependences detectors. \n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <s.pop@laposte.net>\n+   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <pop@cri.ensmp.fr>\n \n This file is part of GCC.\n \n@@ -228,6 +228,10 @@ struct data_dependence_relation\n   VEC(lambda_vector,heap) *dist_vects;\n };\n \n+typedef struct data_dependence_relation *ddr_p;\n+DEF_VEC_P(ddr_p);\n+DEF_VEC_ALLOC_P(ddr_p,heap);\n+\n #define DDR_A(DDR) DDR->a\n #define DDR_B(DDR) DDR->b\n #define DDR_AFFINE_P(DDR) DDR->affine_p\n@@ -253,13 +257,9 @@ struct data_dependence_relation\n \f\n \n extern tree find_data_references_in_loop (struct loop *, varray_type *);\n-extern struct data_dependence_relation *initialize_data_dependence_relation \n-(struct data_reference *, struct data_reference *);\n-extern void compute_affine_dependence (struct data_dependence_relation *);\n-extern void analyze_all_data_dependences (struct loops *);\n extern void compute_data_dependences_for_loop (struct loop *, bool,\n \t\t\t\t\t       varray_type *, varray_type *);\n-\n+extern void print_direction_vector (FILE *, lambda_vector, int);\n extern void dump_subscript (FILE *, struct subscript *);\n extern void dump_ddrs (FILE *, varray_type);\n extern void dump_dist_dir_vectors (FILE *, varray_type);\n@@ -273,11 +273,9 @@ extern void dump_data_dependence_direction (FILE *,\n extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (varray_type);\n extern void free_data_refs (varray_type);\n-extern void compute_subscript_distance (struct data_dependence_relation *);\n extern struct data_reference *analyze_array (tree, tree, bool);\n extern void estimate_iters_using_array (tree, tree);\n \n-\n \f\n \n #endif  /* GCC_TREE_DATA_REF_H  */"}]}