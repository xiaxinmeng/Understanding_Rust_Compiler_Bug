{"sha": "0228d06bca95f3605ab1a1558a6ca9e3aa88c028", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIyOGQwNmJjYTk1ZjM2MDVhYjFhMTU1OGE2Y2E5ZTNhYTg4YzAyOA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2002-06-24T02:16:42Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2002-06-24T02:16:42Z"}, "message": "doloop.c (doloop_valid_p): Correct comment.\n\n\t* doloop.c (doloop_valid_p): Correct comment.\n\t(doloop_modify_runtime <abs_inc != 1>): Simplify.\n\t(doloop_modify_runtime <do-while>): Don't emit code when NE.\n\nFrom-SVN: r54938", "tree": {"sha": "01411c204559a7b25819c92b3f56e0a36f0233e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01411c204559a7b25819c92b3f56e0a36f0233e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0228d06bca95f3605ab1a1558a6ca9e3aa88c028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0228d06bca95f3605ab1a1558a6ca9e3aa88c028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0228d06bca95f3605ab1a1558a6ca9e3aa88c028", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0228d06bca95f3605ab1a1558a6ca9e3aa88c028/comments", "author": null, "committer": null, "parents": [{"sha": "17ba19fe451119f57fc499b06bff45c53251a7db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17ba19fe451119f57fc499b06bff45c53251a7db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17ba19fe451119f57fc499b06bff45c53251a7db"}], "stats": {"total": 75, "additions": 30, "deletions": 45}, "files": [{"sha": "25a13a3627c297b2a0cf5648c86df6797f87f081", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0228d06bca95f3605ab1a1558a6ca9e3aa88c028/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0228d06bca95f3605ab1a1558a6ca9e3aa88c028/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0228d06bca95f3605ab1a1558a6ca9e3aa88c028", "patch": "@@ -1,3 +1,9 @@\n+2002-06-24  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* doloop.c (doloop_valid_p): Correct comment.\n+\t(doloop_modify_runtime <abs_inc != 1>): Simplify.\n+\t(doloop_modify_runtime <do-while>): Don't emit code when NE.\n+\n Thu Jun 20 00:26:53 2002  Denis Chertykov  <denisc@overta.ru>\n \n \t* config.gcc: Add support for ip2k."}, {"sha": "ee5b788a911c6507f02dd0013eb563e9029968b2", "filename": "gcc/doloop.c", "status": "modified", "additions": 24, "deletions": 45, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0228d06bca95f3605ab1a1558a6ca9e3aa88c028/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0228d06bca95f3605ab1a1558a6ca9e3aa88c028/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=0228d06bca95f3605ab1a1558a6ca9e3aa88c028", "patch": "@@ -361,8 +361,8 @@ doloop_valid_p (loop, jump_insn)\n     {\n       /* If the comparison is LEU and the comparison value is UINT_MAX\n \t then the loop will not terminate.  Similarly, if the\n-\t comparison code is GEU and the initial value is 0, the loop\n-\t will not terminate.\n+\t comparison code is GEU and the comparison value is 0, the\n+\t loop will not terminate.\n \n \t If the absolute increment is not 1, the loop can be infinite\n \t even with LTU/GTU, e.g. for (i = 3; i > 0; i -= 2)\n@@ -591,6 +591,10 @@ doloop_modify_runtime (loop, iterations_max,\n        n = abs (final - initial) / abs_inc;\n        n += (abs (final - initial) % abs_inc) != 0;\n \n+     But when abs_inc is a power of two, the summation won't overflow\n+     except in cases where the loop never terminates.  So we don't\n+     need to use this more costly calculation.\n+\n      If the loop has been unrolled, then the loop body has been\n      preconditioned to iterate a multiple of unroll_number times.  If\n      abs_inc is != 1, the full calculation is\n@@ -666,50 +670,22 @@ doloop_modify_runtime (loop, iterations_max,\n   if (abs_inc * loop_info->unroll_number != 1)\n     {\n       int shift_count;\n-      rtx extra;\n-      rtx label;\n-      unsigned HOST_WIDE_INT limit;\n \n       shift_count = exact_log2 (abs_inc * loop_info->unroll_number);\n       if (shift_count < 0)\n \tabort ();\n \n-      /* abs (final - initial) / (abs_inc * unroll_number)  */\n-      iterations = expand_simple_binop (GET_MODE (diff), LSHIFTRT,\n-\t\t\t\t\tdiff, GEN_INT (shift_count),\n-\t\t\t\t\tNULL_RTX, 1,\n-\t\t\t\t\tOPTAB_LIB_WIDEN);\n-\n       if (abs_inc != 1)\n-\t{\n-\t  /* abs (final - initial) % (abs_inc * unroll_number)  */\n-\t  rtx count = GEN_INT (abs_inc * loop_info->unroll_number - 1);\n-\t  extra = expand_simple_binop (GET_MODE (iterations), AND,\n-\t\t\t\t       diff, count, NULL_RTX, 1,\n-\t\t\t\t       OPTAB_LIB_WIDEN);\n-\n-\t  /* If (abs (final - initial) % (abs_inc * unroll_number)\n-\t       <= abs_inc * (unroll - 1)),\n-\t     jump past following increment instruction.  */\n-\t  label = gen_label_rtx ();\n-\t  limit = abs_inc * (loop_info->unroll_number - 1);\n-\t  emit_cmp_and_jump_insns (extra, GEN_INT (limit),\n-\t\t\t\t   limit == 0 ? EQ : LEU, NULL_RTX,\n-\t\t\t\t   GET_MODE (extra), 0, label);\n-\t  JUMP_LABEL (get_last_insn ()) = label;\n-\t  LABEL_NUSES (label)++;\n-\n-\t  /* Increment the iteration count by one.  */\n-\t  iterations = expand_simple_binop (GET_MODE (iterations), PLUS,\n-\t\t\t\t\t    iterations, GEN_INT (1),\n-\t\t\t\t\t    iterations, 1,\n-\t\t\t\t\t    OPTAB_LIB_WIDEN);\n-\n-\t  emit_label (label);\n-\t}\n+\tdiff = expand_simple_binop (GET_MODE (diff), PLUS,\n+\t\t\t\t    diff, GEN_INT (abs_inc - 1),\n+\t\t\t\t    diff, 1, OPTAB_LIB_WIDEN);\n+\n+      /* (abs (final - initial) + abs_inc - 1) / (abs_inc * unroll_number)  */\n+      diff = expand_simple_binop (GET_MODE (diff), LSHIFTRT,\n+\t\t\t\t  diff, GEN_INT (shift_count),\n+\t\t\t\t  diff, 1, OPTAB_LIB_WIDEN);\n     }\n-  else\n-    iterations = diff;\n+  iterations = diff;\n \n   /* If there is a NOTE_INSN_LOOP_VTOP, we have a `for' or `while'\n      style loop, with a loop exit test at the start.  Thus, we can\n@@ -722,17 +698,20 @@ doloop_modify_runtime (loop, iterations_max,\n      iteration count to one if necessary.  */\n   if (! loop->vtop)\n     {\n-      rtx label;\n-\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream, \"Doloop: Do-while loop.\\n\");\n \n-      /* A `do-while' loop must iterate at least once.  If the\n-\t iteration count is bogus, we set the iteration count to 1.\n+      /* A `do-while' loop must iterate at least once.  For code like\n+\t i = initial; do { ... } while (++i < final);\n+\t we will calculate a bogus iteration count if initial > final.\n+\t So detect this and set the iteration count to 1.\n \t Note that if the loop has been unrolled, then the loop body\n-\t is guaranteed to execute at least once.  */\n-      if (loop_info->unroll_number == 1)\n+\t is guaranteed to execute at least once.  Also, when the\n+\t comparison is NE, our calculated count will be OK.  */\n+      if (loop_info->unroll_number == 1 && comparison_code != NE)\n \t{\n+\t  rtx label;\n+\n \t  /*  Emit insns to test if the loop will immediately\n \t      terminate and to set the iteration count to 1 if true.  */\n \t  label = gen_label_rtx();"}]}