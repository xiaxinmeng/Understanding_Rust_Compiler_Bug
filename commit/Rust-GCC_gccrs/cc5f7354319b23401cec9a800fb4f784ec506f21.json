{"sha": "cc5f7354319b23401cec9a800fb4f784ec506f21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M1ZjczNTQzMTliMjM0MDFjZWM5YTgwMGZiNGY3ODRlYzUwNmYyMQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2016-04-30T00:35:39Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2016-04-30T00:35:39Z"}, "message": "[RS6000] Allow saving of fixed regs.\n\nAs I noted a long time ago in the comment on fixed_reg_p, the real\nproblem with saving fixed/global regs is that exception frame\nunwinding might restore them.  So don't emit eh_frame info for any\nsuch reg, and the unwinder won't restore them.\n\nAlso, tidy rs6000_savres_strategy.  Delaying some checks means we\nwon't iterate over regs quite so often.\n\n\t* config/rs6000/rs6000.c (rs6000_savres_strategy): Force inline\n\trestoring when fixed_reg_p, but allow out-of-line or stmw save.\n\tCheck for user regs later to avoid unnecessary looping over regs.\n\tMerge user reg check with non-saved reg check.  Don't force\n\tinline VR restore when static chain used.\n\t(rs6000_frame_related): Omit eh_frame info for user regs when\n\tsaving.\n\t(fixed_regs_p): Delete.\n\nFrom-SVN: r235672", "tree": {"sha": "9bb07d742197b0598fadbc998abb013b7307d453", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bb07d742197b0598fadbc998abb013b7307d453"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc5f7354319b23401cec9a800fb4f784ec506f21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc5f7354319b23401cec9a800fb4f784ec506f21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc5f7354319b23401cec9a800fb4f784ec506f21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc5f7354319b23401cec9a800fb4f784ec506f21/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8cd5d1f46ced83c462e6ababeff4b139da889fab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd5d1f46ced83c462e6ababeff4b139da889fab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd5d1f46ced83c462e6ababeff4b139da889fab"}], "stats": {"total": 178, "additions": 98, "deletions": 80}, "files": [{"sha": "65c5d3f575861570d61cbef16cd0b7f166d8ee18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc5f7354319b23401cec9a800fb4f784ec506f21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc5f7354319b23401cec9a800fb4f784ec506f21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc5f7354319b23401cec9a800fb4f784ec506f21", "patch": "@@ -1,3 +1,14 @@\n+2016-04-30  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_savres_strategy): Force inline\n+\trestoring when fixed_reg_p, but allow out-of-line or stmw save.\n+\tCheck for user regs later to avoid unnecessary looping over regs.\n+\tMerge user reg check with non-saved reg check.  Don't force\n+\tinline VR restore when static chain used.\n+\t(rs6000_frame_related): Omit eh_frame info for user regs when\n+\tsaving.\n+\t(fixed_regs_p): Delete.\n+\n 2016-04-30  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (SAVRES_MULTIPLE): Replace with.."}, {"sha": "0ddb31dc8f90898cc4963fc5ba2e2837d937f1c8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 87, "deletions": 80, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc5f7354319b23401cec9a800fb4f784ec506f21/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc5f7354319b23401cec9a800fb4f784ec506f21/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=cc5f7354319b23401cec9a800fb4f784ec506f21", "patch": "@@ -23231,7 +23231,10 @@ is_altivec_return_reg (rtx reg, void *xyes)\n \n \f\n /* Return whether REG is a global user reg or has been specifed by\n-   -ffixed-REG.  */\n+   -ffixed-REG.  We should not restore these, and so cannot use\n+   lmw or out-of-line restore functions if there are any.  We also\n+   can't save them (well, emit frame notes for them), because frame\n+   unwinding during exception handling will restore saved registers.  */\n \n static bool\n fixed_reg_p (int reg)\n@@ -23247,21 +23250,6 @@ fixed_reg_p (int reg)\n   return fixed_regs[reg];\n }\n \n-/* Look for user-defined global regs or -ffixed-<reg> in the range\n-   FIRST to LAST-1.  We should not restore these, and so cannot use\n-   lmw or out-of-line restore functions if there are any.  We also\n-   can't save them (well, emit frame notes for them), because frame\n-   unwinding during exception handling will restore saved registers.  */\n-\n-static bool\n-fixed_regs_p (unsigned first, unsigned last)\n-{\n-  while (first < last)\n-    if (fixed_reg_p (first++))\n-      return true;\n-  return false;\n-}\n-\n /* Determine the strategy for savings/restoring registers.  */\n \n enum {\n@@ -23283,35 +23271,25 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \t\t\tbool using_static_chain_p)\n {\n   int strategy = 0;\n-  bool lr_save_p;\n-\n-  if (TARGET_MULTIPLE\n-      && !TARGET_POWERPC64\n-      && !(TARGET_SPE_ABI && info->spe_64bit_regs_used)\n-      && info->first_gp_reg_save < 31\n-      && !fixed_regs_p (info->first_gp_reg_save, 32))\n-    strategy |= SAVE_MULTIPLE | REST_MULTIPLE;\n \n+  /* Select between in-line and out-of-line save and restore of regs.\n+     First, all the obvious cases where we don't use out-of-line.  */\n   if (crtl->calls_eh_return\n       || cfun->machine->ra_need_lr)\n     strategy |= (SAVE_INLINE_FPRS | REST_INLINE_FPRS\n \t\t | SAVE_INLINE_GPRS | REST_INLINE_GPRS\n \t\t | SAVE_INLINE_VRS | REST_INLINE_VRS);\n \n+  if (info->first_gp_reg_save == 32)\n+    strategy |= SAVE_INLINE_GPRS | REST_INLINE_GPRS;\n+\n   if (info->first_fp_reg_save == 64\n       /* The out-of-line FP routines use double-precision stores;\n \t we can't use those routines if we don't have such stores.  */\n-      || (TARGET_HARD_FLOAT && !TARGET_DOUBLE_FLOAT)\n-      || fixed_regs_p (info->first_fp_reg_save, 64))\n+      || (TARGET_HARD_FLOAT && !TARGET_DOUBLE_FLOAT))\n     strategy |= SAVE_INLINE_FPRS | REST_INLINE_FPRS;\n \n-  if (info->first_gp_reg_save == 32\n-      || (!(strategy & (SAVE_MULTIPLE | REST_MULTIPLE))\n-\t  && fixed_regs_p (info->first_gp_reg_save, 32)))\n-    strategy |= SAVE_INLINE_GPRS | REST_INLINE_GPRS;\n-\n-  if (info->first_altivec_reg_save == LAST_ALTIVEC_REGNO + 1\n-      || fixed_regs_p (info->first_altivec_reg_save, LAST_ALTIVEC_REGNO + 1))\n+  if (info->first_altivec_reg_save == LAST_ALTIVEC_REGNO + 1)\n     strategy |= SAVE_INLINE_VRS | REST_INLINE_VRS;\n \n   /* Define cutoff for using out-of-line functions to save registers.  */\n@@ -23364,72 +23342,91 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n       && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_DARWIN))\n     strategy |= ((DEFAULT_ABI == ABI_DARWIN ? 0 : SAVE_INLINE_FPRS)\n \t\t | SAVE_INLINE_GPRS\n-\t\t | SAVE_INLINE_VRS | REST_INLINE_VRS);\n+\t\t | SAVE_INLINE_VRS);\n \n-  /* We can only use the out-of-line routines to restore if we've\n+  /* Saving CR interferes with the exit routines used on the SPE, so\n+     just punt here.  */\n+  if (TARGET_SPE_ABI\n+      && info->spe_64bit_regs_used\n+      && info->cr_save_p)\n+    strategy |= REST_INLINE_GPRS;\n+\n+  /* We can only use the out-of-line routines to restore fprs if we've\n      saved all the registers from first_fp_reg_save in the prologue.\n-     Otherwise, we risk loading garbage.  */\n-  if ((strategy & (SAVE_INLINE_FPRS | REST_INLINE_FPRS)) == SAVE_INLINE_FPRS)\n+     Otherwise, we risk loading garbage.  Of course, if we have saved\n+     out-of-line then we know we haven't skipped any fprs.  */\n+  if ((strategy & SAVE_INLINE_FPRS)\n+      && !(strategy & REST_INLINE_FPRS))\n     {\n       int i;\n \n       for (i = info->first_fp_reg_save; i < 64; i++)\n-\tif (!save_reg_p (i))\n+\tif (fixed_regs[i] || !save_reg_p (i))\n \t  {\n \t    strategy |= REST_INLINE_FPRS;\n \t    break;\n \t  }\n     }\n \n-  /* If we are going to use store multiple, then don't even bother\n-     with the out-of-line routines, since the store-multiple\n-     instruction will always be smaller.  */\n-  if ((strategy & (SAVE_MULTIPLE | REST_MULTIPLE)))\n-    strategy |= SAVE_INLINE_GPRS;\n-\n-  /* info->lr_save_p isn't yet set if the only reason lr needs to be\n-     saved is an out-of-line save or restore.  Set up the value for\n-     the next test (excluding out-of-line gpr restore).  */\n-  lr_save_p = (info->lr_save_p\n-\t       || !(strategy & SAVE_INLINE_GPRS)\n-\t       || !(strategy & SAVE_INLINE_FPRS)\n-\t       || !(strategy & SAVE_INLINE_VRS)\n-\t       || !(strategy & REST_INLINE_FPRS)\n-\t       || !(strategy & REST_INLINE_VRS));\n-\n-  /* The situation is more complicated with load multiple.  We'd\n-     prefer to use the out-of-line routines for restores, since the\n-     \"exit\" out-of-line routines can handle the restore of LR and the\n-     frame teardown.  However if doesn't make sense to use the\n-     out-of-line routine if that is the only reason we'd need to save\n-     LR, and we can't use the \"exit\" out-of-line gpr restore if we\n-     have saved some fprs; In those cases it is advantageous to use\n-     load multiple when available.  */\n-  if ((strategy & (SAVE_MULTIPLE | REST_MULTIPLE))\n-      && (!lr_save_p\n-\t  || info->first_fp_reg_save != 64))\n-    strategy |= REST_INLINE_GPRS;\n+  /* Similarly, for altivec regs.  */\n+  if ((strategy & SAVE_INLINE_VRS)\n+      && !(strategy & REST_INLINE_VRS))\n+    {\n+      int i;\n \n-  /* Saving CR interferes with the exit routines used on the SPE, so\n-     just punt here.  */\n-  if (TARGET_SPE_ABI\n-      && info->spe_64bit_regs_used\n-      && info->cr_save_p)\n-    strategy |= REST_INLINE_GPRS;\n+      for (i = info->first_altivec_reg_save; i < LAST_ALTIVEC_REGNO + 1; i++)\n+\tif (fixed_regs[i] || !save_reg_p (i))\n+\t  {\n+\t    strategy |= REST_INLINE_VRS;\n+\t    break;\n+\t  }\n+    }\n+\n+  if (TARGET_MULTIPLE\n+      && !TARGET_POWERPC64\n+      && !(TARGET_SPE_ABI && info->spe_64bit_regs_used)\n+      && info->first_gp_reg_save != 32)\n+    {\n+      /* Prefer store multiple for saves over out-of-line routines,\n+\t since the store-multiple instruction will always be smaller.  */\n+      strategy |= SAVE_INLINE_GPRS | SAVE_MULTIPLE;\n+\n+      /* info->lr_save_p isn't yet set if the only reason lr needs to be\n+\t saved is an out-of-line save or restore.  Set up the value for\n+\t the next test (excluding out-of-line gprs).  */\n+      bool lr_save_p = (info->lr_save_p\n+\t\t\t|| !(strategy & SAVE_INLINE_FPRS)\n+\t\t\t|| !(strategy & SAVE_INLINE_VRS)\n+\t\t\t|| !(strategy & REST_INLINE_FPRS)\n+\t\t\t|| !(strategy & REST_INLINE_VRS));\n+\n+      /* The situation is more complicated with load multiple.  We'd\n+\t prefer to use the out-of-line routines for restores, since the\n+\t \"exit\" out-of-line routines can handle the restore of LR and the\n+\t frame teardown.  However if doesn't make sense to use the\n+\t out-of-line routine if that is the only reason we'd need to save\n+\t LR, and we can't use the \"exit\" out-of-line gpr restore if we\n+\t have saved some fprs; In those cases it is advantageous to use\n+\t load multiple when available.  */\n+      if (info->first_fp_reg_save != 64 || !lr_save_p)\n+\tstrategy |= REST_INLINE_GPRS | REST_MULTIPLE;\n+    }\n \n   /* We can only use load multiple or the out-of-line routines to\n-     restore if we've used store multiple or out-of-line routines\n-     in the prologue, i.e. if we've saved all the registers from\n-     first_gp_reg_save.  Otherwise, we risk loading garbage.  */\n-  if ((strategy & (SAVE_INLINE_GPRS | REST_INLINE_GPRS | SAVE_MULTIPLE | REST_MULTIPLE))\n-      == SAVE_INLINE_GPRS)\n+     restore gprs if we've saved all the registers from\n+     first_gp_reg_save.  Otherwise, we risk loading garbage.\n+     Of course, if we have saved out-of-line or used stmw then we know\n+     we haven't skipped any gprs.  */\n+  if ((strategy & (SAVE_INLINE_GPRS | SAVE_MULTIPLE)) == SAVE_INLINE_GPRS\n+      && (strategy & (REST_INLINE_GPRS | REST_MULTIPLE)) != REST_INLINE_GPRS)\n     {\n       int i;\n \n       for (i = info->first_gp_reg_save; i < 32; i++)\n-\tif (!save_reg_p (i))\n+\tif (fixed_reg_p (i) || !save_reg_p (i))\n \t  {\n \t    strategy |= REST_INLINE_GPRS;\n+\t    strategy &= ~REST_MULTIPLE;\n \t    break;\n \t  }\n     }\n@@ -24702,7 +24699,14 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \t    {\n \t      rtx set = XVECEXP (real, 0, i);\n \n-\t      RTX_FRAME_RELATED_P (set) = 1;\n+\t      /* If this PARALLEL has been emitted for out-of-line\n+\t\t register save functions, or store multiple, then omit\n+\t\t eh_frame info for any user-defined global regs.  If\n+\t\t eh_frame info is supplied, frame unwinding will\n+\t\t restore a user reg.  */\n+\t      if (!REG_P (SET_SRC (set))\n+\t\t  || !fixed_reg_p (REGNO (SET_SRC (set))))\n+\t\tRTX_FRAME_RELATED_P (set) = 1;\n \t    }\n       RTX_FRAME_RELATED_P (insn) = 1;\n       return insn;\n@@ -24772,7 +24776,10 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \t\tif (temp)\n \t\t  XEXP (SET_DEST (set), 0) = temp;\n \t      }\n-\t    RTX_FRAME_RELATED_P (set) = 1;\n+\t    /* Omit eh_frame info for any user-defined global regs.  */\n+\t    if (!REG_P (SET_SRC (set))\n+\t\t|| !fixed_reg_p (REGNO (SET_SRC (set))))\n+\t      RTX_FRAME_RELATED_P (set) = 1;\n \t  }\n     }\n "}]}