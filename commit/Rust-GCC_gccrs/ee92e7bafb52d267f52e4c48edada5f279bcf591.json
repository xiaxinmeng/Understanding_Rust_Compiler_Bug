{"sha": "ee92e7bafb52d267f52e4c48edada5f279bcf591", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU5MmU3YmFmYjUyZDI2N2Y1MmU0YzQ4ZWRhZGE1ZjI3OWJjZjU5MQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-12-08T00:01:33Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-12-08T00:01:33Z"}, "message": "PR c/53562 - Add -Werror= support for -D_FORTIFY_SOURCE / __builtin___memcpy_chk\n\nPR c/53562 - Add -Werror= support for -D_FORTIFY_SOURCE / __builtin___memcpy_chk\nPR middle-end/77784 - duplicate warning for snprintf when n > object size\nPR middle-end/78149 - missing warning on strncpy buffer overflow due to an excessive bound\nPR middle-end/78138 - missing warnings on buffer overflow with non-constant source length\n\ngcc/c-family/ChangeLog:\n\n\tPR c/53562\n\tPR middle-end/77784\n\tPR middle-end/78149\n\tPR middle-end/78138\n\t* c.opt (-Wstringop-overflow): New option.\n\ngcc/ChangeLog:\n\n\tPR middle-end/77784\n\tPR middle-end/78149\n\tPR middle-end/78138\n\t\n\t* builtins.c (expand_builtin_strcat, expand_builtin_strncat): New\n\tfunctions.\n\t(compute_dest_size, get_size_range, check_sizes, check_strncat_sizes)\n\t(check_memop_sizes): Same.\n\t(expand_builtin_memcpy): Call check memop_sizes.\n\t(expand_builtin_mempcpy): Same.\n\t(expand_builtin_memset): Same,\n\t(expand_builtin_bzero): Same.\n\t(expand_builtin_memory_chk): Call check_sizes.\n\t(expand_builtin_strcpy): Same.\n\t(expand_builtin_strncpy): Same.\n\t(maybe_emit_sprintf_chk_warning): Same.\n\t(expand_builtin): Handle strcat and strncat.\n\t(fini_object_sizes): Reset pointers.\n\t(compute_object_size): New function.\n\t* gimple-ssa-sprintf.c (pass_sprintf_length::handle_gimple_call):\n\tAvoid issuing warnings also issued during built-in expansion.\n\t* doc/invoke.texi (Warning Options): Document -Wstringop-overflow.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/77784\n\tPR middle-end/78149\n\tPR middle-end/78138\n\n\t* c-c++-common/Wsizeof-pointer-memaccess2.c: Adjust expected diagnostic.\n\t* g++.dg/ext/builtin-object-size3.C (bar): Same.\n\t* g++.dg/ext/strncpy-chk1.C: Same.\n\t* g++.dg/opt/memcpy1.C: Same.\n\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: Same.\n\t* gcc.c-torture/compile/pr55569.c: Disable -Wstringop-overflow.\n\t* gcc.dg/Wobjsize-1.c: Adjust expected diagnostic.\n\t* gcc.dg/attr-alloc_size.c: Same.\n\t* gcc.dg/builtin-stringop-chk-1.c: Adjust expected diagnostic.\n\t* gcc.dg/builtin-stringop-chk-2.c: Same.\n\t* gcc.dg/builtin-stringop-chk-4.c: New test.\n\t* gcc.dg/builtin-strncat-chk-1.c: Adjust expected diagnostic.\n\t* gcc.dg/memcpy-2.c: Same.\n\t* gcc.dg/pr40340-1.c: Same.\n\t* gcc.dg/pr40340-2.c (main): Same.\n\t* gcc.dg/pr40340-5.c (main): Same.\n\t* gcc.dg/torture/Wsizeof-pointer-memaccess1.c: Same.\n\t* gcc.dg/torture/pr71132.c: Disable -Wstringop-overflow.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Adjust text of expected\n\twarning.\n\t* gfortran.dg/char_length_3.f90: Prune expected warnings.\n\t* gfortran.dg/pr38868.f: Add expected warnings.\n\nFrom-SVN: r243419", "tree": {"sha": "1468c5482ab4b2c6c5a92894f2e96f47a742b995", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1468c5482ab4b2c6c5a92894f2e96f47a742b995"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee92e7bafb52d267f52e4c48edada5f279bcf591", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee92e7bafb52d267f52e4c48edada5f279bcf591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee92e7bafb52d267f52e4c48edada5f279bcf591", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee92e7bafb52d267f52e4c48edada5f279bcf591/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc3f36f9a1642338da8c0428ea5dc140402556c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc3f36f9a1642338da8c0428ea5dc140402556c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc3f36f9a1642338da8c0428ea5dc140402556c9"}], "stats": {"total": 1970, "additions": 1779, "deletions": 191}, "files": [{"sha": "6372ff43f190c96c2eea25813665672e491e4df6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -1,3 +1,28 @@\n+2016-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/77784\n+\tPR middle-end/78149\n+\tPR middle-end/78138\n+\t\n+\t* builtins.c (expand_builtin_strcat, expand_builtin_strncat): New\n+\tfunctions.\n+\t(compute_dest_size, get_size_range, check_sizes, check_strncat_sizes)\n+\t(check_memop_sizes): Same.\n+\t(expand_builtin_memcpy): Call check memop_sizes.\n+\t(expand_builtin_mempcpy): Same.\n+\t(expand_builtin_memset): Same,\n+\t(expand_builtin_bzero): Same.\n+\t(expand_builtin_memory_chk): Call check_sizes.\n+\t(expand_builtin_strcpy): Same.\n+\t(expand_builtin_strncpy): Same.\n+\t(maybe_emit_sprintf_chk_warning): Same.\n+\t(expand_builtin): Handle strcat and strncat.\n+\t(fini_object_sizes): Reset pointers.\n+\t(compute_object_size): New function.\n+\t* gimple-ssa-sprintf.c (pass_sprintf_length::handle_gimple_call):\n+\tAvoid issuing warnings also issued during built-in expansion.\n+\t* doc/invoke.texi (Warning Options): Document -Wstringop-overflow.\n+\n 2016-12-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/72717"}, {"sha": "b58056cf334467cac0512f62d20bf4ffb0671f30", "filename": "gcc/builtins.c", "status": "modified", "additions": 582, "deletions": 91, "changes": 673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -67,7 +67,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"internal-fn.h\"\n #include \"case-cfn-macros.h\"\n #include \"gimple-fold.h\"\n-\n+#include \"intl.h\"\n \n struct target_builtins default_target_builtins;\n #if SWITCHABLE_TARGET\n@@ -125,9 +125,11 @@ static rtx expand_builtin_mempcpy (tree, rtx, machine_mode);\n static rtx expand_builtin_mempcpy_with_bounds (tree, rtx, machine_mode);\n static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx,\n \t\t\t\t\tmachine_mode, int, tree);\n+static rtx expand_builtin_strcat (tree, rtx);\n static rtx expand_builtin_strcpy (tree, rtx);\n static rtx expand_builtin_strcpy_args (tree, tree, rtx);\n static rtx expand_builtin_stpcpy (tree, rtx, machine_mode);\n+static rtx expand_builtin_strncat (tree, rtx);\n static rtx expand_builtin_strncpy (tree, rtx);\n static rtx builtin_memset_gen_str (void *, HOST_WIDE_INT, machine_mode);\n static rtx expand_builtin_memset (tree, rtx, machine_mode);\n@@ -3010,6 +3012,292 @@ expand_builtin_memcpy_args (tree dest, tree src, tree len, rtx target, tree exp)\n   return dest_addr;\n }\n \n+/* Fill the 2-element RANGE array with the minimum and maximum values\n+   EXP is known to have and return true, otherwise null and return\n+   false.  */\n+\n+static bool\n+get_size_range (tree exp, tree range[2])\n+{\n+  if (tree_fits_uhwi_p (exp))\n+    {\n+      range[0] = range[1] = exp;\n+      return true;\n+    }\n+\n+  if (TREE_CODE (exp) == SSA_NAME)\n+    {\n+      wide_int min, max;\n+      enum value_range_type range_type = get_range_info (exp, &min, &max);\n+\n+      if (range_type == VR_RANGE)\n+\t{\n+\t  /* Interpret the bound in the variable's type.  */\n+\t  range[0] = wide_int_to_tree (TREE_TYPE (exp), min);\n+\t  range[1] = wide_int_to_tree (TREE_TYPE (exp), max);\n+\t  return true;\n+\t}\n+      else if (range_type == VR_ANTI_RANGE)\n+\t{\n+\t  /* FIXME: Handle anti-ranges.  */\n+\t}\n+    }\n+\n+  range[0] = NULL_TREE;\n+  range[1] = NULL_TREE;\n+  return false;\n+}\n+\n+/* Try to verify that the sizes and lengths of the arguments to a string\n+   manipulation function given by EXP are within valid bounds and that\n+   the operation does not lead to buffer overflow.  Arguments other than\n+   EXP may be null.  When non-null, the arguments have the following\n+   meaning:\n+   SIZE is the user-supplied size argument to the function (such as in\n+   memcpy(d, s, SIZE) or strncpy(d, s, SIZE).  It specifies the exact\n+   number of bytes to write.\n+   MAXLEN is the user-supplied bound on the length of the source sequence\n+   (such as in strncat(d, s, N).  It specifies the upper limit on the number\n+   of bytes to write.\n+   STR is the source string (such as in strcpy(d, s)) when the epxression\n+   EXP is a string function call (as opposed to a memory call like memcpy).\n+   As an exception, STR can also be an integer denoting the precomputed\n+   length of the source string.\n+   OBJSIZE is the size of the destination object specified by the last\n+   argument to the _chk builtins, typically resulting from the expansion\n+   of __builtin_object_size (such as in __builtin___strcpy_chk(d, s,\n+   OBJSIZE).\n+\n+   When SIZE is null LEN is checked to verify that it doesn't exceed\n+   SIZE_MAX.\n+\n+   If the call is successfully verified as safe from buffer overflow\n+   the function returns true, otherwise false..  */\n+\n+static bool\n+check_sizes (int opt, tree exp, tree size, tree maxlen, tree str, tree objsize)\n+{\n+  /* The size of the largest object is half the address space, or\n+     SSIZE_MAX.  (This is way too permissive.)  */\n+  tree maxobjsize = TYPE_MAX_VALUE (ssizetype);\n+\n+  tree slen = NULL_TREE;\n+\n+  /* Set to true when the exact number of bytes written by a string\n+     function like strcpy is not known and the only thing that is\n+     known is that it must be at least one (for the terminating nul).  */\n+  bool at_least_one = false;\n+  if (str)\n+    {\n+      /* STR is normally a pointer to string but as a special case\n+\t it can be an integer denoting the length of a string.  */\n+      if (TREE_CODE (TREE_TYPE (str)) == POINTER_TYPE)\n+\t{\n+\t  /* Try to determine the range of lengths the source string\n+\t     refers to.  If it can be determined add one to it for\n+\t     the terminating nul.  Otherwise, set it to one for\n+\t     the same reason.  */\n+\t  tree lenrange[2];\n+\t  get_range_strlen (str, lenrange);\n+\t  if (lenrange[0])\n+\t    slen = fold_build2 (PLUS_EXPR, size_type_node, lenrange[0],\n+\t\t\t\tsize_one_node);\n+\t  else\n+\t    {\n+\t      at_least_one = true;\n+\t      slen = size_one_node;\n+\t    }\n+\t}\n+      else\n+\tslen = str;\n+    }\n+\n+  if (!size && !maxlen)\n+    {\n+      /* When the only available piece of data is the object size\n+\t there is nothing to do.  */\n+      if (!slen)\n+\treturn true;\n+\n+      /* Otherwise, when the length of the source sequence is known\n+\t (as with with strlen), set SIZE to it.  */\n+      size = slen;\n+    }\n+\n+  if (!objsize)\n+    objsize = maxobjsize;\n+\n+  /* The SIZE is exact if it's non-null, constant, and in range of\n+     unsigned HOST_WIDE_INT.  */\n+  bool exactsize = size && tree_fits_uhwi_p (size);\n+\n+  tree range[2] = { NULL_TREE, NULL_TREE };\n+  if (size)\n+    get_size_range (size, range);\n+\n+  /* First check the number of bytes to be written against the maximum\n+     object size.  */\n+  if (range[0] && tree_int_cst_lt (maxobjsize, range[0]))\n+    {\n+      location_t loc = tree_nonartificial_location (exp);\n+\n+      if (range[0] == range[1])\n+\twarning_at (loc, opt,\n+\t\t    \"%K%qD: specified size %wu \"\n+\t\t    \"exceeds maximum object size %wu\",\n+\t\t    exp, get_callee_fndecl (exp),\n+\t\t    tree_to_uhwi (range[0]),\n+\t\t    tree_to_uhwi (maxobjsize));\n+\t  else\n+\t    warning_at (loc, opt,\n+\t\t\t\"%K%qD: specified size between %wu and %wu \"\n+\t\t\t\"exceeds maximum object size %wu\",\n+\t\t\texp, get_callee_fndecl (exp),\n+\t\t\ttree_to_uhwi (range[0]),\n+\t\t\ttree_to_uhwi (range[1]),\n+\t\t\ttree_to_uhwi (maxobjsize));\n+      return false;\n+    }\n+\n+  /* Next check the number of bytes to be written against the destination\n+     object size.  */\n+  if (range[0] || !exactsize || integer_all_onesp (size))\n+    {\n+      if (range[0]\n+\t  && ((tree_fits_uhwi_p (objsize)\n+\t       && tree_int_cst_lt (objsize, range[0]))\n+\t      || (tree_fits_uhwi_p (size)\n+\t\t  && tree_int_cst_lt (size, range[0]))))\n+\t{\n+\t  unsigned HOST_WIDE_INT uwir0 = tree_to_uhwi (range[0]);\n+\n+\t  location_t loc = tree_nonartificial_location (exp);\n+\n+\t  if (at_least_one)\n+\t    warning_at (loc, opt,\n+\t\t\t\"%K%qD: writing at least %wu byte into a region \"\n+\t\t\t\"of size %wu overflows the destination\",\n+\t\t\texp, get_callee_fndecl (exp), uwir0,\n+\t\t\ttree_to_uhwi (objsize));\n+\t  else if (range[0] == range[1])\n+\t    warning_at (loc, opt,\n+\t\t\t(uwir0 == 1\n+\t\t\t ? G_(\"%K%qD: writing %wu byte into a region \"\n+\t\t\t      \"of size %wu overflows the destination\")\n+\t\t\t : G_(\"%K%qD writing %wu bytes into a region \"\n+\t\t\t      \"of size %wu overflows the destination\")),\n+\t\t\texp, get_callee_fndecl (exp), uwir0,\n+\t\t\ttree_to_uhwi (objsize));\n+\t  else\n+\t    warning_at (loc, opt,\n+\t\t\t\"%K%qD: writing between %wu and %wu bytes \"\n+\t\t\t\"into a region of size %wu overflows \"\n+\t\t\t\"the destination\",\n+\t\t\texp, get_callee_fndecl (exp), uwir0,\n+\t\t\ttree_to_uhwi (range[1]), tree_to_uhwi (objsize));\n+\n+\t  /* Return error when an overflow has been detected.  */\n+\t  return false;\n+\t}\n+    }\n+\n+  /* Check the maximum length of the source sequence against the size\n+     of the destination object if known, or against the maximum size\n+     of an object.  */\n+  if (maxlen)\n+    {\n+      get_size_range (maxlen, range);\n+\n+      if (range[0] && objsize && tree_fits_uhwi_p (objsize))\n+\t{\n+\t  location_t loc = tree_nonartificial_location (exp);\n+\n+\t  if (tree_int_cst_lt (maxobjsize, range[0]))\n+\t    {\n+\t      /* Warn about crazy big sizes first since that's more\n+\t\t likely to be meaningful than saying that the bound\n+\t\t is greater than the object size if both are big.  */\n+\t      if (range[0] == range[1])\n+\t\twarning_at (loc, opt,\n+\t\t\t    \"%K%qD: specified bound %wu \"\n+\t\t\t    \"exceeds maximum object size %wu\",\n+\t\t\t    exp, get_callee_fndecl (exp),\n+\t\t\t    tree_to_uhwi (range[0]),\n+\t\t\t    tree_to_uhwi (maxobjsize));\n+\t      else\n+\t\twarning_at (loc, opt,\n+\t\t\t    \"%K%qD: specified bound between %wu and %wu \"\n+\t\t\t    \" exceeds maximum object size %wu\",\n+\t\t\t    exp, get_callee_fndecl (exp),\n+\t\t\t    tree_to_uhwi (range[0]),\n+\t\t\t    tree_to_uhwi (range[1]),\n+\t\t\t    tree_to_uhwi (maxobjsize));\n+\n+\t      return false;\n+\t    }\n+\n+\t  if (objsize != maxobjsize && tree_int_cst_lt (objsize, range[0]))\n+\t    {\n+\t      if (range[0] == range[1])\n+\t\twarning_at (loc, opt,\n+\t\t\t    \"%K%qD: specified bound %wu \"\n+\t\t\t    \"exceeds the size %wu of the destination\",\n+\t\t\t    exp, get_callee_fndecl (exp),\n+\t\t\t    tree_to_uhwi (range[0]),\n+\t\t\t    tree_to_uhwi (objsize));\n+\t      else\n+\t\twarning_at (loc, opt,\n+\t\t\t    \"%K%qD: specified bound between %wu and %wu \"\n+\t\t\t    \" exceeds the size %wu of the destination\",\n+\t\t\t    exp, get_callee_fndecl (exp),\n+\t\t\t    tree_to_uhwi (range[0]),\n+\t\t\t    tree_to_uhwi (range[1]),\n+\t\t\t    tree_to_uhwi (objsize));\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Helper to compute the size of the object referenced by the DEST\n+   expression which must of of pointer type, using Object Size type\n+   OSTYPE (only the least significant 2 bits are used).  Return\n+   the size of the object if successful or NULL when the size cannot\n+   be determined.  */\n+\n+static inline tree\n+compute_dest_size (tree dest, int ostype)\n+{\n+  unsigned HOST_WIDE_INT size;\n+  if (compute_builtin_object_size (dest, ostype & 3, &size))\n+    return build_int_cst (sizetype, size);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Helper to determine and check the sizes of the source and the destination\n+   of calls to __builtin_{bzero,memcpy,memset} calls.  Use Object Size type-0\n+   regardless of the OPT_Wstringop_overflow_ setting.  Returns true on success\n+   (no overflow or invalid sizes), false otherwise.  */\n+\n+static bool\n+check_memop_sizes (tree exp, tree dest, tree size)\n+{\n+  if (!warn_stringop_overflow)\n+    return true;\n+\n+  /* For functions like memset and memcpy that operate on raw memory\n+     try to determine the size of the largest destination object using\n+     type-0 Object Size regardless of the object size type specified\n+     by the option.  */\n+  tree objsize = compute_dest_size (dest, 0);\n+\n+  return check_sizes (OPT_Wstringop_overflow_, exp,\n+\t\t      size, /*maxlen=*/NULL_TREE, /*str=*/NULL_TREE, objsize);\n+}\n+\n /* Expand a call EXP to the memcpy builtin.\n    Return NULL_RTX if we failed, the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient (and in\n@@ -3021,13 +3309,14 @@ expand_builtin_memcpy (tree exp, rtx target)\n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n-  else\n-    {\n-      tree dest = CALL_EXPR_ARG (exp, 0);\n-      tree src = CALL_EXPR_ARG (exp, 1);\n-      tree len = CALL_EXPR_ARG (exp, 2);\n-      return expand_builtin_memcpy_args (dest, src, len, target, exp);\n-    }\n+\n+  tree dest = CALL_EXPR_ARG (exp, 0);\n+  tree src = CALL_EXPR_ARG (exp, 1);\n+  tree len = CALL_EXPR_ARG (exp, 2);\n+\n+  check_memop_sizes (exp, dest, len);\n+\n+  return expand_builtin_memcpy_args (dest, src, len, target, exp);\n }\n \n /* Expand an instrumented call EXP to the memcpy builtin.\n@@ -3075,15 +3364,20 @@ expand_builtin_mempcpy (tree exp, rtx target, machine_mode mode)\n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n-  else\n-    {\n-      tree dest = CALL_EXPR_ARG (exp, 0);\n-      tree src = CALL_EXPR_ARG (exp, 1);\n-      tree len = CALL_EXPR_ARG (exp, 2);\n-      return expand_builtin_mempcpy_args (dest, src, len,\n-\t\t\t\t\t  target, mode, /*endp=*/ 1,\n-\t\t\t\t\t  exp);\n-    }\n+\n+  tree dest = CALL_EXPR_ARG (exp, 0);\n+  tree src = CALL_EXPR_ARG (exp, 1);\n+  tree len = CALL_EXPR_ARG (exp, 2);\n+\n+  /* Avoid expanding mempcpy into memcpy when the call is determined\n+     to overflow the buffer.  This also prevents the same overflow\n+     from being diagnosed again when expanding memcpy.  */\n+  if (!check_memop_sizes (exp, dest, len))\n+    return NULL_RTX;\n+\n+  return expand_builtin_mempcpy_args (dest, src, len,\n+\t\t\t\t      target, mode, /*endp=*/ 1,\n+\t\t\t\t      exp);\n }\n \n /* Expand an instrumented call EXP to the mempcpy builtin.\n@@ -3255,6 +3549,33 @@ expand_movstr (tree dest, tree src, rtx target, int endp)\n   return target;\n }\n \n+/* Do some very basic size validation of a call to the strcpy builtin\n+   given by EXP.  Return NULL_RTX to have the built-in expand to a call\n+   to the library function.  */\n+\n+static rtx\n+expand_builtin_strcat (tree exp, rtx)\n+{\n+  if (!validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE)\n+      || !warn_stringop_overflow)\n+    return NULL_RTX;\n+\n+  tree dest = CALL_EXPR_ARG (exp, 0);\n+  tree src = CALL_EXPR_ARG (exp, 1);\n+\n+  /* There is no way here to determine the length of the string in\n+     the destination to which the SRC string is being appended so\n+     just diagnose cases when the souce string is longer than\n+     the destination object.  */\n+\n+  tree destsize = compute_dest_size (dest, warn_stringop_overflow - 1);\n+\n+  check_sizes (OPT_Wstringop_overflow_,\n+\t       exp, /*size=*/NULL_TREE, /*maxlen=*/NULL_TREE, src, destsize);\n+\n+  return NULL_RTX;\n+}\n+\n /* Expand expression EXP, which is a call to the strcpy builtin.  Return\n    NULL_RTX if we failed the caller should emit a normal call, otherwise\n    try to get the result in TARGET, if convenient (and in mode MODE if that's\n@@ -3263,13 +3584,20 @@ expand_movstr (tree dest, tree src, rtx target, int endp)\n static rtx\n expand_builtin_strcpy (tree exp, rtx target)\n {\n-  if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-   {\n-     tree dest = CALL_EXPR_ARG (exp, 0);\n-     tree src = CALL_EXPR_ARG (exp, 1);\n-     return expand_builtin_strcpy_args (dest, src, target);\n-   }\n-   return NULL_RTX;\n+  if (!validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  tree dest = CALL_EXPR_ARG (exp, 0);\n+  tree src = CALL_EXPR_ARG (exp, 1);\n+\n+  if (warn_stringop_overflow)\n+    {\n+      tree destsize = compute_dest_size (dest, warn_stringop_overflow - 1);\n+      check_sizes (OPT_Wstringop_overflow_,\n+\t\t   exp, /*size=*/NULL_TREE, /*maxlen=*/NULL_TREE, src, destsize);\n+    }\n+\n+  return expand_builtin_strcpy_args (dest, src, target);\n }\n \n /* Helper function to do the actual work for expand_builtin_strcpy.  The\n@@ -3377,6 +3705,131 @@ builtin_strncpy_read_str (void *data, HOST_WIDE_INT offset,\n   return c_readstr (str + offset, mode);\n }\n \n+/* Helper to check the sizes of sequences and the destination of calls\n+   to __builtin_strncat and __builtin___strncat_chk.  Returns true on\n+   success (no overflow or invalid sizes), false otherwise.  */\n+\n+static bool\n+check_strncat_sizes (tree exp, tree objsize)\n+{\n+  tree dest = CALL_EXPR_ARG (exp, 0);\n+  tree src = CALL_EXPR_ARG (exp, 1);\n+  tree maxlen = CALL_EXPR_ARG (exp, 2);\n+\n+  /* Try to determine the range of lengths that the source expression\n+     refers to.  */\n+  tree lenrange[2];\n+  get_range_strlen (src, lenrange);\n+\n+  /* Try to verify that the destination is big enough for the shortest\n+     string.  */\n+\n+  if (!objsize && warn_stringop_overflow)\n+    {\n+      /* If it hasn't been provided by __strncat_chk, try to determine\n+\t the size of the destination object into which the source is\n+\t being copied.  */\n+      objsize = compute_dest_size (dest, warn_stringop_overflow - 1);\n+    }\n+\n+  /* Add one for the terminating nul.  */\n+  tree srclen = (lenrange[0]\n+\t\t ? fold_build2 (PLUS_EXPR, size_type_node, lenrange[0],\n+\t\t\t\tsize_one_node)\n+\t\t : NULL_TREE);\n+\n+  /* Strncat copies at most MAXLEN bytes and always appends the terminating\n+     nul so the specified upper bound should never be equal to (or greater\n+     than) the size of the destination.  */\n+  if (tree_fits_uhwi_p (maxlen) && tree_fits_uhwi_p (objsize)\n+      && tree_int_cst_equal (objsize, maxlen))\n+    {\n+      warning_at (EXPR_LOCATION (exp), OPT_Wstringop_overflow_,\n+\t\t  \"specified bound %wu \"\n+\t\t  \"equals the size of the destination\",\n+\t\t  tree_to_uhwi (maxlen));\n+\n+      return false;\n+    }\n+\n+  if (!srclen\n+      || (maxlen && tree_fits_uhwi_p (maxlen)\n+\t  && tree_fits_uhwi_p (srclen)\n+\t  && tree_int_cst_lt (maxlen, srclen)))\n+    srclen = maxlen;\n+\n+  /* The number of bytes to write is LEN but check_sizes will also\n+     check SRCLEN if LEN's value isn't known.  */\n+  return check_sizes (OPT_Wstringop_overflow_,\n+\t\t      exp, /*size=*/NULL_TREE, maxlen, srclen, objsize);\n+}\n+\n+/* Similar to expand_builtin_strcat, do some very basic size validation\n+   of a call to the strcpy builtin given by EXP.  Return NULL_RTX to have\n+   the built-in expand to a call to the library function.  */\n+\n+static rtx\n+expand_builtin_strncat (tree exp, rtx)\n+{\n+  if (!validate_arglist (exp,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE)\n+      || !warn_stringop_overflow)\n+    return NULL_RTX;\n+\n+  tree dest = CALL_EXPR_ARG (exp, 0);\n+  tree src = CALL_EXPR_ARG (exp, 1);\n+  /* The upper bound on the number of bytes to write.  */\n+  tree maxlen = CALL_EXPR_ARG (exp, 2);\n+  /* The length of the source sequence.  */\n+  tree slen = c_strlen (src, 1);\n+\n+  /* Try to determine the range of lengths that the source expression\n+     refers to.  */\n+  tree lenrange[2];\n+  if (slen)\n+    lenrange[0] = lenrange[1] = slen;\n+  else\n+    get_range_strlen (src, lenrange);\n+\n+  /* Try to verify that the destination is big enough for the shortest\n+     string.  First try to determine the size of the destination object\n+     into which the source is being copied.  */\n+  tree destsize = compute_dest_size (dest, warn_stringop_overflow - 1);\n+\n+  /* Add one for the terminating nul.  */\n+  tree srclen = (lenrange[0]\n+\t\t ? fold_build2 (PLUS_EXPR, size_type_node, lenrange[0],\n+\t\t\t\tsize_one_node)\n+\t\t : NULL_TREE);\n+\n+  /* Strncat copies at most MAXLEN bytes and always appends the terminating\n+     nul so the specified upper bound should never be equal to (or greater\n+     than) the size of the destination.  */\n+  if (tree_fits_uhwi_p (maxlen) && tree_fits_uhwi_p (destsize)\n+      && tree_int_cst_equal (destsize, maxlen))\n+    {\n+      warning_at (EXPR_LOCATION (exp), OPT_Wstringop_overflow_,\n+\t\t  \"specified bound %wu \"\n+\t\t  \"equals the size of the destination\",\n+\t\t  tree_to_uhwi (maxlen));\n+\n+      return NULL_RTX;\n+    }\n+\n+  if (!srclen\n+      || (maxlen && tree_fits_uhwi_p (maxlen)\n+\t  && tree_fits_uhwi_p (srclen)\n+\t  && tree_int_cst_lt (maxlen, srclen)))\n+    srclen = maxlen;\n+\n+  /* The number of bytes to write is LEN but check_sizes will also\n+     check SRCLEN if LEN's value isn't known.  */\n+  check_sizes (OPT_Wstringop_overflow_,\n+\t       exp, /*size=*/NULL_TREE, maxlen, srclen, destsize);\n+\n+  return NULL_RTX;\n+}\n+\n /* Expand expression EXP, which is a call to the strncpy builtin.  Return\n    NULL_RTX if we failed the caller should emit a normal call.  */\n \n@@ -3390,9 +3843,33 @@ expand_builtin_strncpy (tree exp, rtx target)\n     {\n       tree dest = CALL_EXPR_ARG (exp, 0);\n       tree src = CALL_EXPR_ARG (exp, 1);\n+      /* The number of bytes to write (not the maximum).  */\n       tree len = CALL_EXPR_ARG (exp, 2);\n+      /* The length of the source sequence.  */\n       tree slen = c_strlen (src, 1);\n \n+      if (warn_stringop_overflow)\n+\t{\n+\t  /* Try to determine the range of lengths that the source expression\n+\t     refers to.  */\n+\t  tree lenrange[2];\n+\t  if (slen)\n+\t    lenrange[0] = lenrange[1] = slen;\n+\t  else\n+\t    {\n+\t      get_range_strlen (src, lenrange);\n+\t      slen = lenrange[0];\n+\t    }\n+\n+\t  tree destsize = compute_dest_size (dest,\n+\t\t\t\t\t     warn_stringop_overflow - 1);\n+\n+\t  /* The number of bytes to write is LEN but check_sizes will also\n+\t     check SLEN if LEN's value isn't known.  */\n+\t  check_sizes (OPT_Wstringop_overflow_,\n+\t\t       exp, len, /*maxlen=*/NULL_TREE, slen, destsize);\n+\t}\n+\n       /* We must be passed a constant len and src parameter.  */\n       if (!tree_fits_uhwi_p (len) || !slen || !tree_fits_uhwi_p (slen))\n \treturn NULL_RTX;\n@@ -3480,13 +3957,14 @@ expand_builtin_memset (tree exp, rtx target, machine_mode mode)\n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n-  else\n-    {\n-      tree dest = CALL_EXPR_ARG (exp, 0);\n-      tree val = CALL_EXPR_ARG (exp, 1);\n-      tree len = CALL_EXPR_ARG (exp, 2);\n-      return expand_builtin_memset_args (dest, val, len, target, mode, exp);\n-    }\n+\n+  tree dest = CALL_EXPR_ARG (exp, 0);\n+  tree val = CALL_EXPR_ARG (exp, 1);\n+  tree len = CALL_EXPR_ARG (exp, 2);\n+\n+  check_memop_sizes (exp, dest, len);\n+\n+  return expand_builtin_memset_args (dest, val, len, target, mode, exp);\n }\n \n /* Expand expression EXP, which is an instrumented call to the memset builtin.\n@@ -3667,20 +4145,21 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n static rtx\n expand_builtin_bzero (tree exp)\n {\n-  tree dest, size;\n-  location_t loc = EXPR_LOCATION (exp);\n-\n   if (!validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n \n-  dest = CALL_EXPR_ARG (exp, 0);\n-  size = CALL_EXPR_ARG (exp, 1);\n+  tree dest = CALL_EXPR_ARG (exp, 0);\n+  tree size = CALL_EXPR_ARG (exp, 1);\n+\n+  check_memop_sizes (exp, dest, size);\n \n   /* New argument list transforming bzero(ptr x, int y) to\n      memset(ptr x, int 0, size_t y).   This is done this way\n      so that if it isn't expanded inline, we fallback to\n      calling bzero instead of memset.  */\n \n+  location_t loc = EXPR_LOCATION (exp);\n+\n   return expand_builtin_memset_args (dest, integer_zero_node,\n \t\t\t\t     fold_convert_loc (loc,\n \t\t\t\t\t\t       size_type_node, size),\n@@ -6205,12 +6684,24 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \treturn target;\n       break;\n \n+    case BUILT_IN_STRCAT:\n+      target = expand_builtin_strcat (exp, target);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     case BUILT_IN_STRCPY:\n       target = expand_builtin_strcpy (exp, target);\n       if (target)\n \treturn target;\n       break;\n \n+    case BUILT_IN_STRNCAT:\n+      target = expand_builtin_strncat (exp, target);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     case BUILT_IN_STRNCPY:\n       target = expand_builtin_strncpy (exp, target);\n       if (target)\n@@ -9052,22 +9543,22 @@ expand_builtin_memory_chk (tree exp, rtx target, machine_mode mode,\n   len = CALL_EXPR_ARG (exp, 2);\n   size = CALL_EXPR_ARG (exp, 3);\n \n-  if (! tree_fits_uhwi_p (size))\n+  bool sizes_ok = check_sizes (OPT_Wstringop_overflow_,\n+\t\t\t       exp, len, /*maxlen=*/NULL_TREE,\n+\t\t\t       /*str=*/NULL_TREE, size);\n+\n+  if (!tree_fits_uhwi_p (size))\n     return NULL_RTX;\n \n   if (tree_fits_uhwi_p (len) || integer_all_onesp (size))\n     {\n-      tree fn;\n-\n-      if (! integer_all_onesp (size) && tree_int_cst_lt (size, len))\n-\t{\n-\t  warning_at (tree_nonartificial_location (exp),\n-\t\t      0, \"%Kcall to %D will always overflow destination buffer\",\n-\t\t      exp, get_callee_fndecl (exp));\n-\t  return NULL_RTX;\n-\t}\n+      /* Avoid transforming the checking call to an ordinary one when\n+\t an overflow has been detected or when the call couldn't be\n+\t validated because the size is not constant.  */\n+      if (!sizes_ok && !integer_all_onesp (size) && tree_int_cst_lt (size, len))\n+\treturn NULL_RTX;\n \n-      fn = NULL_TREE;\n+      tree fn = NULL_TREE;\n       /* If __builtin_mem{cpy,pcpy,move,set}_chk is used, assume\n \t mem{cpy,pcpy,move,set} is available.  */\n       switch (fcode)\n@@ -9153,68 +9644,68 @@ expand_builtin_memory_chk (tree exp, rtx target, machine_mode mode,\n static void\n maybe_emit_chk_warning (tree exp, enum built_in_function fcode)\n {\n-  int is_strlen = 0;\n-  tree len, size;\n-  location_t loc = tree_nonartificial_location (exp);\n+  /* The source string.  */\n+  tree srcstr = NULL_TREE;\n+  /* The size of the destination object.  */\n+  tree objsize = NULL_TREE;\n+  /* The string that is being concatenated with (as in __strcat_chk)\n+     or null if it isn't.  */\n+  tree catstr = NULL_TREE;\n+  /* The maximum length of the source sequence in a bounded operation\n+     (such as __strncat_chk) or null if the operation isn't bounded\n+     (such as __strcat_chk).  */\n+  tree maxlen = NULL_TREE;\n \n   switch (fcode)\n     {\n     case BUILT_IN_STRCPY_CHK:\n     case BUILT_IN_STPCPY_CHK:\n-    /* For __strcat_chk the warning will be emitted only if overflowing\n-       by at least strlen (dest) + 1 bytes.  */\n+      srcstr = CALL_EXPR_ARG (exp, 1);\n+      objsize = CALL_EXPR_ARG (exp, 2);\n+      break;\n+\n     case BUILT_IN_STRCAT_CHK:\n-      len = CALL_EXPR_ARG (exp, 1);\n-      size = CALL_EXPR_ARG (exp, 2);\n-      is_strlen = 1;\n+      /* For __strcat_chk the warning will be emitted only if overflowing\n+\t by at least strlen (dest) + 1 bytes.  */\n+      catstr = CALL_EXPR_ARG (exp, 0);\n+      srcstr = CALL_EXPR_ARG (exp, 1);\n+      objsize = CALL_EXPR_ARG (exp, 2);\n       break;\n+\n     case BUILT_IN_STRNCAT_CHK:\n+      catstr = CALL_EXPR_ARG (exp, 0);\n+      srcstr = CALL_EXPR_ARG (exp, 1);\n+      maxlen = CALL_EXPR_ARG (exp, 2);\n+      objsize = CALL_EXPR_ARG (exp, 3);\n+      break;\n+\n     case BUILT_IN_STRNCPY_CHK:\n     case BUILT_IN_STPNCPY_CHK:\n-      len = CALL_EXPR_ARG (exp, 2);\n-      size = CALL_EXPR_ARG (exp, 3);\n+      srcstr = CALL_EXPR_ARG (exp, 1);\n+      maxlen = CALL_EXPR_ARG (exp, 2);\n+      objsize = CALL_EXPR_ARG (exp, 3);\n       break;\n+\n     case BUILT_IN_SNPRINTF_CHK:\n     case BUILT_IN_VSNPRINTF_CHK:\n-      len = CALL_EXPR_ARG (exp, 1);\n-      size = CALL_EXPR_ARG (exp, 3);\n+      maxlen = CALL_EXPR_ARG (exp, 1);\n+      objsize = CALL_EXPR_ARG (exp, 3);\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n-  if (!len || !size)\n-    return;\n-\n-  if (! tree_fits_uhwi_p (size) || integer_all_onesp (size))\n-    return;\n-\n-  if (is_strlen)\n+  if (catstr && maxlen)\n     {\n-      len = c_strlen (len, 1);\n-      if (! len || ! tree_fits_uhwi_p (len) || tree_int_cst_lt (len, size))\n+      /* Check __strncat_chk.  There is no way to determine the length\n+\t of the string to which the source string is being appended so\n+\t just warn when the length of the source string is not known.  */\n+      if (!check_strncat_sizes (exp, objsize))\n \treturn;\n     }\n-  else if (fcode == BUILT_IN_STRNCAT_CHK)\n-    {\n-      tree src = CALL_EXPR_ARG (exp, 1);\n-      if (! src || ! tree_fits_uhwi_p (len) || tree_int_cst_lt (len, size))\n-\treturn;\n-      src = c_strlen (src, 1);\n-      if (! src || ! tree_fits_uhwi_p (src))\n-\t{\n-\t  warning_at (loc, 0, \"%Kcall to %D might overflow destination buffer\",\n-\t\t      exp, get_callee_fndecl (exp));\n-\t  return;\n-\t}\n-      else if (tree_int_cst_lt (src, size))\n-\treturn;\n-    }\n-  else if (! tree_fits_uhwi_p (len) || ! tree_int_cst_lt (size, len))\n-    return;\n \n-  warning_at (loc, 0, \"%Kcall to %D will always overflow destination buffer\",\n-\t      exp, get_callee_fndecl (exp));\n+  check_sizes (OPT_Wstringop_overflow_, exp,\n+\t       /*size=*/NULL_TREE, maxlen, srcstr, objsize);\n }\n \n /* Emit warning if a buffer overflow is detected at compile time\n@@ -9268,10 +9759,10 @@ maybe_emit_sprintf_chk_warning (tree exp, enum built_in_function fcode)\n   else\n     return;\n \n-  if (! tree_int_cst_lt (len, size))\n-    warning_at (tree_nonartificial_location (exp),\n-\t\t0, \"%Kcall to %D will always overflow destination buffer\",\n-\t\texp, get_callee_fndecl (exp));\n+  /* Add one for the terminating nul.  */\n+  len = fold_build2 (PLUS_EXPR, TREE_TYPE (len), len, size_one_node);\n+  check_sizes (OPT_Wstringop_overflow_,\n+\t       exp, /*size=*/NULL_TREE, /*maxlen=*/NULL_TREE, len, size);\n }\n \n /* Emit warning if a free is called with address of a variable.  */"}, {"sha": "aba0b14fa2688973dca664ad57a1e2958b9fa179", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -1,3 +1,11 @@\n+2016-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/53562\n+\tPR middle-end/77784\n+\tPR middle-end/78149\n+\tPR middle-end/78138\n+\t* c.opt (-Wstringop-overflow): New option.\n+\n 2016-12-02  Maxim Ostapenko  <m.ostapenko@samsung.com>\n \n \t* c-attribs.c (asan odr indicator): New attribute."}, {"sha": "288e4ce12fbf760e92e6ca4e60270c7c2279ba91", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -684,6 +684,16 @@ Wsizeof-array-argument\n C ObjC C++ ObjC++ Var(warn_sizeof_array_argument) Warning Init(1)\n Warn when sizeof is applied on a parameter declared as an array.\n \n+Wstringop-overflow\n+C ObjC C++ ObjC++ Warning Alias(Wstringop-overflow=, 2, 0)\n+Warn about buffer overflow in string manipulation functions like memcpy\n+and strcpy.\n+\n+Wstringop-overflow=\n+C ObjC C++ ObjC++ Joined RejectNegative UInteger Var(warn_stringop_overflow) Init(2) Warning\n+Under the control of Object Size type, warn about buffer overflow in string\n+manipulation functions like memcpy and strcpy.\n+\n Wsuggest-attribute=format\n C ObjC C++ ObjC++ Var(warn_suggest_attribute_format) Warning\n Warn about functions which might be candidates for format attributes."}, {"sha": "5622c0f107e191c6d70f17d5876443d7a6e109ab", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -304,6 +304,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wsizeof-pointer-memaccess  -Wsizeof-array-argument @gol\n -Wstack-protector -Wstack-usage=@var{len} -Wstrict-aliasing @gol\n -Wstrict-aliasing=n -Wstrict-overflow -Wstrict-overflow=@var{n} @gol\n+-Wstringop-overflow=@var{n} @gol\n -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{]} @gol\n -Wsuggest-final-types @gol -Wsuggest-final-methods -Wsuggest-override @gol\n -Wmissing-format-attribute -Wsubobject-linkage @gol\n@@ -4936,6 +4937,86 @@ comparisons, so this warning level gives a very large number of\n false positives.\n @end table\n \n+@item -Wstringop-overflow\n+@itemx -Wstringop-overflow=@var{type}\n+@opindex Wstringop-overflow\n+@opindex Wno-stringop-overflow\n+Warn for calls to string manipulation functions such as @code{memcpy} and\n+@code{strcpy} that are determined to overflow the destination buffer.  The\n+optional argument is one greater than the type of Object Size Checking to\n+perform to determine the size of the destination.  @xref{Object Size Checking}.\n+The argument is meaningful only for functions that operate on character arrays\n+but not for raw memory functions like @code{memcpy} which always make use\n+of Object Size type-0.  The option also warns for calls that specify a size\n+in excess of the largest possible object or at most @code{SIZE_MAX / 2} bytes.\n+The option produces the best results with optimization enabled but can detect\n+a small subset of simple buffer overflows even without optimization in\n+calls to the GCC built-in functions like @code{__builtin_memcpy} that\n+correspond to the standard functions.  In any case, the option warns about\n+just a subset of buffer overflows detected by the corresponding overflow\n+checking built-ins.  For example, the option will issue a warning for\n+the @code{strcpy} call below because it copies at least 5 characters\n+(the string @code{\"blue\"} including the terminating NUL) into the buffer\n+of size 4.\n+\n+@smallexample\n+enum Color @{ blue, purple, yellow @};\n+const char* f (enum Color clr)\n+@{\n+  static char buf [4];\n+  const char *str;\n+  switch (clr)\n+    @{\n+      case blue: str = \"blue\"; break;\n+      case purple: str = \"purple\"; break;\n+      case yellow: str = \"yellow\"; break;\n+    @}\n+\n+  return strcpy (buf, str);   // warning here\n+@}\n+@end smallexample\n+\n+Option @option{-Wstringop-overflow=2} is enabled by default.\n+\n+@table @gcctabopt\n+@item -Wstringop-overflow\n+@item -Wstringop-overflow=1\n+@opindex Wstringop-overflow\n+@opindex Wno-stringop-overflow\n+The @option{-Wstringop-overflow=1} option uses type-zero Object Size Checking\n+to determine the sizes of destination objects.  This is the default setting\n+of the option.  At this setting the option will not warn for writes past\n+the end of subobjects of larger objects accessed by pointers unless the\n+size of the largest surrounding object is known.  When the destination may\n+be one of several objects it is assumed to be the largest one of them.  On\n+Linux systems, when optimization is enabled at this setting the option warns\n+for the same code as when the @code{_FORTIFY_SOURCE} macro is defined to\n+a non-zero value.\n+\n+@item -Wstringop-overflow=2\n+The @option{-Wstringop-overflow=2} option uses type-one Object Size Checking\n+to determine the sizes of destination objects.  At this setting the option\n+will warn about overflows when writing to members of the largest complete\n+objects whose exact size is known.  It will, however, not warn for excessive\n+writes to the same members of unknown objects referenced by pointers since\n+they may point to arrays containing unknown numbers of elements.\n+\n+@item -Wstringop-overflow=3\n+The @option{-Wstringop-overflow=3} option uses type-two Object Size Checking\n+to determine the sizes of destination objects.  At this setting the option\n+warns about overflowing the smallest object or data member.  This is the\n+most restrictive setting of the option that may result in warnings for safe\n+code.\n+\n+@item -Wstringop-overflow=4\n+The @option{-Wstringop-overflow=4} option uses type-three Object Size Checking\n+to determine the sizes of destination objects.  At this setting the option\n+will warn about overflowing any data members, and when the destination is\n+one of several objects it uses the size of the largest of them to decide\n+whether to issue a warning.  Similarly to @option{-Wstringop-overflow=3} this\n+setting of the option may result in warnings for benign code.\n+@end table\n+\n @item -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{]}\n @opindex Wsuggest-attribute=\n @opindex Wno-suggest-attribute="}, {"sha": "8de9a1e31d2c2d44d920d5102171b25ebfc376b1", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -774,7 +774,23 @@ get_width_and_precision (const conversion_spec &spec,\n   if (spec.star_width)\n     {\n       if (TREE_CODE (spec.star_width) == INTEGER_CST)\n-\twidth = abs (tree_to_shwi (spec.star_width));\n+\t{\n+\t  width = tree_to_shwi (spec.star_width);\n+\t  if (width < 0)\n+\t    {\n+\t      if (width == HOST_WIDE_INT_MIN)\n+\t\t{\n+\t\t  /* Avoid undefined behavior due to negating a minimum.\n+\t\t     This case will be diagnosed since it will result in\n+\t\t     more than INT_MAX bytes on output, either by the\n+\t\t     directive itself (when INT_MAX < HOST_WIDE_INT_MAX)\n+\t\t     or by the format function itself.  */\n+\t\t  width = HOST_WIDE_INT_MAX;\n+\t\t}\n+\t      else\n+\t\twidth = -width;\n+\t    }\n+\t}\n       else\n \twidth = HOST_WIDE_INT_MIN;\n     }\n@@ -1261,9 +1277,9 @@ format_floating (const conversion_spec &spec, int width, int prec)\n \tres.range.min = 2 + (prec < 0 ? 6 : prec);\n \n \t/* Compute the maximum just once.  */\n-\tstatic const int f_max[] = {\n-\t  format_floating_max (double_type_node, 'f'),\n-\t  format_floating_max (long_double_type_node, 'f')\n+\tconst int f_max[] = {\n+\t  format_floating_max (double_type_node, 'f', prec),\n+\t  format_floating_max (long_double_type_node, 'f', prec)\n \t};\n \tres.range.max = width == INT_MIN ? HOST_WIDE_INT_MAX : f_max [ldbl];\n \n@@ -1279,9 +1295,9 @@ format_floating (const conversion_spec &spec, int width, int prec)\n \tres.range.min = 2 + (prec < 0 ? 6 : prec);\n \n \t/* Compute the maximum just once.  */\n-\tstatic const int g_max[] = {\n-\t  format_floating_max (double_type_node, 'g'),\n-\t  format_floating_max (long_double_type_node, 'g')\n+\tconst int g_max[] = {\n+\t  format_floating_max (double_type_node, 'g', prec),\n+\t  format_floating_max (long_double_type_node, 'g', prec)\n \t};\n \tres.range.max = width == INT_MIN ? HOST_WIDE_INT_MAX : g_max [ldbl];\n \n@@ -2743,19 +2759,27 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator *gsi)\n \t{\n \t  dstsize = tree_to_uhwi (size);\n \t  /* No object can be larger than SIZE_MAX bytes (half the address\n-\t     space) on the target.  This imposes a limit that's one byte\n-\t     less than that.\n+\t     space) on the target.\n \t     The functions are defined only for output of at most INT_MAX\n \t     bytes.  Specifying a bound in excess of that limit effectively\n \t     defeats the bounds checking (and on some implementations such\n \t     as Solaris cause the function to fail with EINVAL).  */\n-\t  if (dstsize >= target_size_max () / 2)\n-\t    warning_at (gimple_location (info.callstmt), OPT_Wformat_length_,\n-\t\t\t\"specified destination size %wu is too large\",\n-\t\t\tdstsize);\n+\t  if (dstsize > target_size_max () / 2)\n+\t    {\n+\t      /* Avoid warning if -Wstringop-overflow is specified since\n+\t\t it also warns for the same thing though only for the\n+\t\t checking built-ins.  */\n+\t      if ((idx_objsize == HOST_WIDE_INT_M1U\n+\t\t   || !warn_stringop_overflow))\n+\t\twarning_at (gimple_location (info.callstmt),\n+\t\t\t    OPT_Wformat_length_,\n+\t\t\t    \"specified bound %wu exceeds maximum object size \"\n+\t\t\t    \"%wu\",\n+\t\t\t    dstsize, target_size_max () / 2);\n+\t    }\n \t  else if (dstsize > target_int_max ())\n \t    warning_at (gimple_location (info.callstmt), OPT_Wformat_length_,\n-\t\t\t\"specified destination size %wu exceeds %<INT_MAX %>\",\n+\t\t\t\"specified bound %wu exceeds %<INT_MAX %>\",\n \t\t\tdstsize);\n \t}\n       else if (TREE_CODE (size) == SSA_NAME)\n@@ -2800,10 +2824,15 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator *gsi)\n       info.objsize = dstsize < objsize ? dstsize : objsize;\n \n       if (info.bounded\n-\t  && dstsize < target_size_max () / 2 && objsize < dstsize)\n+\t  && dstsize < target_size_max () / 2 && objsize < dstsize\n+\t  /* Avoid warning if -Wstringop-overflow is specified since\n+\t     it also warns for the same thing though only for the\n+\t     checking built-ins.  */\n+\t  && (idx_objsize == HOST_WIDE_INT_M1U\n+\t      || !warn_stringop_overflow))\n \t{\n \t  warning_at (gimple_location (info.callstmt), OPT_Wformat_length_,\n-\t\t      \"specified size %wu exceeds the size %wu \"\n+\t\t      \"specified bound %wu exceeds the size %wu \"\n \t\t      \"of the destination object\", dstsize, objsize);\n \t}\n     }"}, {"sha": "27225c2483759b37d120b305fd1e0a97ae32c991", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -1,3 +1,32 @@\n+2016-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/77784\n+\tPR middle-end/78149\n+\tPR middle-end/78138\n+\n+\t* c-c++-common/Wsizeof-pointer-memaccess2.c: Adjust expected diagnostic.\n+\t* g++.dg/ext/builtin-object-size3.C (bar): Same.\n+\t* g++.dg/ext/strncpy-chk1.C: Same.\n+\t* g++.dg/opt/memcpy1.C: Same.\n+\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: Same.\n+\t* gcc.c-torture/compile/pr55569.c: Disable -Wstringop-overflow.\n+\t* gcc.dg/Wobjsize-1.c: Adjust expected diagnostic.\n+\t* gcc.dg/attr-alloc_size.c: Same.\n+\t* gcc.dg/builtin-stringop-chk-1.c: Adjust expected diagnostic.\n+\t* gcc.dg/builtin-stringop-chk-2.c: Same.\n+\t* gcc.dg/builtin-stringop-chk-4.c: New test.\n+\t* gcc.dg/builtin-strncat-chk-1.c: Adjust expected diagnostic.\n+\t* gcc.dg/memcpy-2.c: Same.\n+\t* gcc.dg/pr40340-1.c: Same.\n+\t* gcc.dg/pr40340-2.c (main): Same.\n+\t* gcc.dg/pr40340-5.c (main): Same.\n+\t* gcc.dg/torture/Wsizeof-pointer-memaccess1.c: Same.\n+\t* gcc.dg/torture/pr71132.c: Disable -Wstringop-overflow.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Adjust text of expected\n+\twarning.\n+\t* gfortran.dg/char_length_3.f90: Prune expected warnings.\n+\t* gfortran.dg/pr38868.f: Add expected warnings.\n+\n 2016-12-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/72717"}, {"sha": "9a02373970927125e4def4ad4e483e7df03fa09e", "filename": "gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -481,4 +481,4 @@ f4 (char *x, char **y, int z, char w[64])\n   stpncpy (x, s3, sizeof (s3));\n }\n \n-/* { dg-prune-output \"\\[\\n\\r\\]*will always overflow\\[\\n\\r\\]*\" } */\n+/* { dg-prune-output \"\\[\\n\\r\\]*writing\\[\\n\\r\\]*\" } */"}, {"sha": "0207f9ab667acffae40068dc51791cf789ad58ea", "filename": "gcc/testsuite/g++.dg/ext/builtin-object-size3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin-object-size3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin-object-size3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin-object-size3.C?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -20,7 +20,7 @@ bar ()\n {\n   int *p = new int;\n   int *q = new int[4];\n-  MEMCPY (p, \"abcdefghijklmnopqrstuvwxyz\", sizeof (int) + 1);\t\t// { dg-warning \"will always overflow destination buffer\" }\n-  MEMCPY (q, \"abcdefghijklmnopqrstuvwxyz\", 4 * sizeof (int) + 1);\t// { dg-warning \"will always overflow destination buffer\" }\n+  MEMCPY (p, \"abcdefghijklmnopqrstuvwxyz\", sizeof (int) + 1);\t\t// { dg-warning \"writing\" }\n+  MEMCPY (q, \"abcdefghijklmnopqrstuvwxyz\", 4 * sizeof (int) + 1);\t// { dg-warning \"writing\" }\n   baz (p, q);\n }"}, {"sha": "d67d6bfea4536a91118d3d6000377b6c1a08f562", "filename": "gcc/testsuite/g++.dg/ext/strncpy-chk1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstrncpy-chk1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstrncpy-chk1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstrncpy-chk1.C?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -9,7 +9,7 @@ struct B { char z[50]; };\n inline void\n foo (char *dest, const char *__restrict src, __SIZE_TYPE__ n)\n {\n-  __builtin___strncpy_chk (dest, src, n, __builtin_object_size (dest, 0));\t// { dg-warning \"will always overflow\" }\n+  __builtin___strncpy_chk (dest, src, n, __builtin_object_size (dest, 0));\t// { dg-warning \"specified bound 36 exceeds the size 35 of the destination\" }\n }\n \n void bar (const char *, int);"}, {"sha": "e2b1dd2cdf0cf88897c652604041968df0af87d4", "filename": "gcc/testsuite/g++.dg/opt/memcpy1.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fmemcpy1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fmemcpy1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fmemcpy1.C?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -59,7 +59,10 @@ namespace CS\n     }\n     uint8 Clip ()\n     {\n-      __builtin_memcpy (this->OutP, InP, OutV * sizeof (csVector2));\n+      // OutV is initialized to SIZE_MAX in the ctor above causing\n+      // the multiplication below to produce a very large number\n+      // in excess of the maximum possible object size (SIZE_MAX/2).\n+      __builtin_memcpy (this->OutP, InP, OutV * sizeof (csVector2));   // { dg-warning \"specified size \\[0-9\\]+ exceeds maximum object size\" }\n     }\n   };\n }"}, {"sha": "2e6189b31476f5e19adba3273b7f9889ddbc3c48", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -713,4 +713,4 @@ f4 (char *x, char **y, int z, char w[64])\n   return z;\n }\n \n-// { dg-prune-output \"\\[\\n\\r\\]*will always overflow\\[\\n\\r\\]*\" }\n+// { dg-prune-output \"\\[\\n\\r\\]*overflows\\[\\n\\r\\]*\" }"}, {"sha": "a216f47033353ac7ebaa5d9522aa52792608dc2f", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess2.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -1,7 +1,8 @@\n // Test -Wsizeof-pointer-memaccess warnings.\n // { dg-do compile }\n-// { dg-options \"-Wall -Wno-sizeof-array-argument\" }\n-// Test just twice, once with -O0 non-fortified, once with -O2 fortified.\n+// { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow\" }\n+// Test just twice, once with -O0 non-fortified, once with -O2 fortified,\n+// suppressing buffer overflow warnings.\n // { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } }\n // { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } }\n "}, {"sha": "cf274cdbb99a44195a19ed23a343479529287fe8", "filename": "gcc/testsuite/gcc.c-torture/compile/pr55569.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr55569.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr55569.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr55569.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -1,11 +1,15 @@\n-/* { dg-options \"-ftree-vectorize\" } */\n+/* { dg-options \"-Wno-stringop-overflow -ftree-vectorize\" } */\n int *bar (void);\n \n void\n foo (void)\n {\n   long x;\n   int *y = bar ();\n-    for (x = -1 / sizeof (int); x; --x, ++y)\n-       *y = 0;\n+\n+  /* The loop below may be optimized to a call to memset with a size\n+     that's in excess of the maximum object size.  This is diagnosed\n+     by the -Wstringop-overflow option.  */\n+  for (x = -1 / sizeof (int); x; --x, ++y)\n+    *y = 0;\n }"}, {"sha": "211e0680a1d8b87d99cdcb9ab03c8137b5d45085", "filename": "gcc/testsuite/gcc.dg/Wobjsize-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -10,6 +10,6 @@ int main(int argc, char **argv)\n   return 0;\n }\n \n-/* { dg-warning \"will always overflow destination buffer\" \"\" { target *-*-* } 6 } */\n+/* { dg-warning \"writing\" \"\" { target *-*-* } 6 } */\n /* { dg-message \"file included\" \"included\" { target *-*-* } 0 } */\n /* { dg-message \"inlined from\" \"inlined\" { target *-*-* } 0 } */"}, {"sha": "f50ba7c53db642d24cfdfbf25e90716cbe4581d3", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -22,15 +22,15 @@ test (void)\n   strcpy (p, \"Hello\");\n   p = malloc1 (6);\n   strcpy (p, \"Hello\");\n-  strcpy (p, \"Hello World\"); /* { dg-warning \"will always overflow\" \"strcpy\" } */\n+  strcpy (p, \"Hello World\"); /* { dg-warning \"writing\" \"strcpy\" } */\n   p = malloc2 (__INT_MAX__ >= 1700000 ? 424242 : __INT_MAX__ / 4, 6);\n   strcpy (p, \"World\");\n-  strcpy (p, \"Hello World\"); /* { dg-warning \"will always overflow\" \"strcpy\" } */\n+  strcpy (p, \"Hello World\"); /* { dg-warning \"writing\" \"strcpy\" } */\n   p = calloc1 (2, 5);\n   strcpy (p, \"World\");\n-  strcpy (p, \"Hello World\"); /* { dg-warning \"will always overflow\" \"strcpy\" } */\n+  strcpy (p, \"Hello World\"); /* { dg-warning \"writing\" \"strcpy\" } */\n   p = calloc2 (2, __INT_MAX__ >= 1700000 ? 424242 : __INT_MAX__ / 4, 5);\n   strcpy (p, \"World\");\n-  strcpy (p, \"Hello World\"); /* { dg-warning \"will always overflow\" \"strcpy\" } */\n+  strcpy (p, \"Hello World\"); /* { dg-warning \"writing\" \"strcpy\" } */\n }\n "}, {"sha": "7689287cb1e3247bc5390a5b2a70af438b310764", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-1.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -8,7 +8,10 @@\n extern void abort (void);\n \n #include \"../gcc.c-torture/execute/builtins/chk.h\"\n-#include <stdarg.h>\n+\n+#define va_list    __builtin_va_list\n+#define va_start   __builtin_va_start\n+#define va_end     __builtin_va_end\n \n volatile void *vx;\n char buf1[20];\n@@ -22,60 +25,61 @@ test (int arg, ...)\n   char *p = &buf1[10], *q;\n \n   memcpy (&buf2[19], \"ab\", 1);\n-  memcpy (&buf2[19], \"ab\", 2); /* { dg-warning \"will always overflow\" \"memcpy\" } */\n+  memcpy (&buf2[19], \"ab\", 2); /* { dg-warning \"writing 2 bytes into a region of size 1\" \"memcpy\" } */\n   vx = mempcpy (&buf2[19], \"ab\", 1);\n-  vx = mempcpy (&buf2[19], \"ab\", 2); /* { dg-warning \"will always overflow\" \"mempcpy\" } */\n+  vx = mempcpy (&buf2[19], \"ab\", 2); /* { dg-warning \"writing 2 \" \"mempcpy\" } */\n   memmove (&buf2[18], &buf1[10], 2);\n-  memmove (&buf2[18], &buf1[10], 3); /* { dg-warning \"will always overflow\" \"memmove\" } */\n+  memmove (&buf2[18], &buf1[10], 3); /* { dg-warning \"writing 3 \" \"memmove\" } */\n   memset (&buf2[16], 'a', 4);\n-  memset (&buf2[15], 'b', 6); /* { dg-warning \"will always overflow\" \"memset\" } */\n+  memset (&buf2[15], 'b', 6); /* { dg-warning \"writing 6 \" \"memset\" } */\n   strcpy (&buf2[18], \"a\");\n-  strcpy (&buf2[18], \"ab\"); /* { dg-warning \"will always overflow\" \"strcpy\" } */\n+  strcpy (&buf2[18], \"ab\"); /* { dg-warning \"writing 3 \" \"strcpy\" } */\n   vx = stpcpy (&buf2[18], \"a\");\n-  vx = stpcpy (&buf2[18], \"ab\"); /* { dg-warning \"will always overflow\" \"stpcpy\" } */\n+  vx = stpcpy (&buf2[18], \"ab\"); /* { dg-warning \"writing 3\" \"stpcpy\" } */\n   strncpy (&buf2[18], \"a\", 2);\n-  strncpy (&buf2[18], \"a\", 3); /* { dg-warning \"will always overflow\" \"strncpy\" } */\n+  strncpy (&buf2[18], \"a\", 3); /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" \"strncpy\" } */\n   strncpy (&buf2[18], \"abc\", 2);\n-  strncpy (&buf2[18], \"abc\", 3); /* { dg-warning \"will always overflow\" \"strncpy\" } */\n+  strncpy (&buf2[18], \"abc\", 3); /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" \"strncpy\" } */\n   memset (buf2, '\\0', sizeof (buf2));\n   strcat (&buf2[18], \"a\");\n   memset (buf2, '\\0', sizeof (buf2));\n-  strcat (&buf2[18], \"ab\"); /* { dg-warning \"will always overflow\" \"strcat\" } */\n+  strcat (&buf2[18], \"ab\"); /* { dg-warning \"writing 3 \" \"strcat\" } */\n   sprintf (&buf2[18], \"%s\", buf1);\n   sprintf (&buf2[18], \"%s\", \"a\");\n-  sprintf (&buf2[18], \"%s\", \"ab\"); /* { dg-warning \"will always overflow\" \"sprintf\" } */\n+  sprintf (&buf2[18], \"%s\", \"ab\"); /* { dg-warning \"writing 3 \" \"sprintf\" } */\n   sprintf (&buf2[18], \"a\");\n-  sprintf (&buf2[18], \"ab\"); /* { dg-warning \"will always overflow\" \"sprintf\" } */\n+  sprintf (&buf2[18], \"ab\"); /* { dg-warning \"writing 3 \" \"sprintf\" } */\n   snprintf (&buf2[18], 2, \"%d\", x);\n   /* N argument to snprintf is the size of the buffer.\n      Although this particular call wouldn't overflow buf2,\n      incorrect buffer size was passed to it and therefore\n      we want a warning and runtime failure.  */\n-  snprintf (&buf2[18], 3, \"%d\", x); /* { dg-warning \"will always overflow\" \"snprintf\" } */\n+  snprintf (&buf2[18], 3, \"%d\", x); /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" \"snprintf\" } */\n   va_start (ap, arg);\n   vsprintf (&buf2[18], \"a\", ap);\n   va_end (ap);\n+\n   va_start (ap, arg);\n-  vsprintf (&buf2[18], \"ab\", ap); /* { dg-warning \"will always overflow\" \"vsprintf\" } */\n+  vsprintf (&buf2[18], \"ab\", ap); /* { dg-warning \"writing 3\" \"vsprintf\" } */\n   va_end (ap);\n   va_start (ap, arg);\n   vsnprintf (&buf2[18], 2, \"%s\", ap);\n   va_end (ap);\n   va_start (ap, arg);\n   /* See snprintf above.  */\n-  vsnprintf (&buf2[18], 3, \"%s\", ap); /* { dg-warning \"will always overflow\" \"vsnprintf\" } */\n+  vsnprintf (&buf2[18], 3, \"%s\", ap); /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" \"vsnprintf\" } */\n   va_end (ap);\n \n   p = p + 10;\n   memset (p, 'd', 0);\n-  q = strcpy (p, \"\"); /* { dg-warning \"will always overflow\" \"strcpy\" } */\n+  q = strcpy (p, \"\"); /* { dg-warning \"writing 1 \" \"strcpy\" } */\n \n   /* This invokes undefined behavior, since we are past the end of buf1.  */\n   p = p + 10;\n-  memset (p, 'd', 1); /* { dg-warning \"will always overflow\" \"memset\" } */\n+  memset (p, 'd', 1); /* { dg-warning \"writing 1 \" \"memset\" } */\n \n   memset (q, 'd', 0);\n-  memset (q, 'd', 1); /* { dg-warning \"will always overflow\" \"memset\" } */\n+  memset (q, 'd', 1); /* { dg-warning \"writing 1 \" \"memset\" } */\n   q = q - 10;\n   memset (q, 'd', 10);\n }\n@@ -90,26 +94,26 @@ void\n test2 (const H h)\n {\n   char c;\n-  strncpy (&c, str, 3); /* { dg-warning \"will always overflow\" \"strncpy\" } */\n+  strncpy (&c, str, 3); /* { dg-warning \"specified bound 3 exceeds the size 1 of the destination\" \"strncpy\" } */\n \n   struct { char b[4]; } x;\n-  sprintf (x.b, \"%s\", \"ABCD\"); /* { dg-warning \"will always overflow\" \"sprintf\" } */\n+  sprintf (x.b, \"%s\", \"ABCD\"); /* { dg-warning \"writing 5\" \"sprintf\" } */\n \n   unsigned int i;\n-  memcpy (&i, &h, sizeof (h)); /* { dg-warning \"will always overflow\" \"memcpy\" } */\n+  memcpy (&i, &h, sizeof (h)); /* { dg-warning \"writing 16 \" \"memcpy\" } */\n \n   unsigned char buf[21];\n-  memset (buf + 16, 0, 8); /* { dg-warning \"will always overflow\" \"memset\" } */\n+  memset (buf + 16, 0, 8); /* { dg-warning \"writing 8 \" \"memset\" } */\n \n   typedef struct { int i, j, k, l; } S;\n   S *s[3];\n-  memset (s, 0, sizeof (S) * 3); /* { dg-warning \"will always overflow\" \"memset\" } */\n+  memset (s, 0, sizeof (S) * 3); /* { dg-warning \"writing 48 \" \"memset\" } */\n \n   struct T { char a[8]; char b[4]; char c[10]; } t;\n-  stpcpy (t.c,\"Testing...\"); /* { dg-warning \"will always overflow\" \"stpcpy\" } */\n+  stpcpy (t.c,\"Testing...\"); /* { dg-warning \"writing\" \"stpcpy\" } */\n \n   char b1[7];\n   char b2[4];\n   memset (b1, 0, sizeof (b1));\n-  memset (b2, 0, sizeof (b1)); /* { dg-warning \"will always overflow\" \"memset\" } */\n+  memset (b2, 0, sizeof (b1)); /* { dg-warning \"writing 7\" \"memset\" } */\n }"}, {"sha": "d537fb040c1c4135e406db322e0924e5eca8678f", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-2.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -6,7 +6,7 @@\n /* { dg-options \"-O2 -ftrack-macro-expansion=0\" } */\n \n #include \"../gcc.c-torture/execute/builtins/chk.h\"\n-   \n+\n void *bar (int);\n extern void *malloc (__SIZE_TYPE__);\n \n@@ -115,7 +115,7 @@ baz (const struct A *x, const unsigned char *z)\n \t  else\n \t    do\n \t      {\n-\t\tmemcpy (e, d, 513); /* { dg-warning \"will always overflow\" \"memcpy\" } */\n+\t\tmemcpy (e, d, 513); /* { dg-warning \"writing\" \"memcpy\" } */\n \t\te += 4;\n \t      }\n \t    while (--h);"}, {"sha": "4857bdaa73b2c39fafe374c381b0224377f7ce3d", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-4.c", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-4.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -0,0 +1,525 @@\n+/* Test exercising buffer overflow warnings emitted for raw memory and\n+   string manipulation builtins involving ranges of sizes and strings\n+   of varying lengths.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftrack-macro-expansion=0\" } */\n+\n+#define INT_MAX      __INT_MAX__\n+#define PTRDIFF_MAX  __PTRDIFF_MAX__\n+#define SIZE_MAX     __SIZE_MAX__\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__    size_t;\n+\n+static const size_t ssize_max = SIZE_MAX / 2;\n+static const size_t size_max = SIZE_MAX;\n+\n+extern signed char    schar_val;\n+extern signed short   sshrt_val;\n+extern signed int     sint_val;\n+extern signed long    slong_val;\n+extern unsigned char  uchar_val;\n+extern unsigned short ushrt_val;\n+extern unsigned int   uint_val;\n+extern unsigned long  ulong_val;\n+\n+#define memcpy(d, s, n) (memcpy ((d), (s), (n)), sink ((d)))\n+extern void* (memcpy)(void*, const void*, size_t);\n+\n+#define mempcpy(d, s, n) (mempcpy ((d), (s), (n)), sink ((d)))\n+extern void* (mempcpy)(void*, const void*, size_t);\n+\n+#define memset(d, c, n) (memset ((d), (c), (n)), sink ((d)))\n+extern void* (memset)(void*, int, size_t);\n+\n+#define bzero(d, n) (bzero ((d), (n)), sink ((d)))\n+extern void (bzero)(void*, size_t);\n+\n+#define strcat(d, s) (strcat ((d), (s)), sink ((d)))\n+extern char* (strcat)(char*, const char*);\n+\n+#define strncat(d, s, n) (strncat ((d), (s), (n)), sink ((d)))\n+extern char* (strncat)(char*, const char*, size_t);\n+\n+#define strcpy(d, s) (strcpy ((d), (s)), sink ((d)))\n+extern char* (strcpy)(char*, const char*);\n+\n+#define strncpy(d, s, n) (strncpy ((d), (s), (n)), sink ((d)))\n+extern char* (strncpy)(char*, const char*, size_t);\n+\n+void sink (void*);\n+\n+/* Function to \"generate\" a random number each time it's called.  Declared\n+   (but not defined) and used to prevent GCC from making assumptions about\n+   their values based on the variables uses in the tested expressions.  */\n+size_t random_unsigned_value (void);\n+ptrdiff_t random_signed_value (void);\n+\n+/* Return a random unsigned value between MIN and MAX.  */\n+\n+static inline size_t\n+unsigned_range (size_t min, size_t max)\n+{\n+  const size_t val = random_unsigned_value ();\n+  return val < min || max < val ? min : val;\n+}\n+\n+/* Return a random signed value between MIN and MAX.  */\n+\n+static inline ptrdiff_t\n+signed_range (ptrdiff_t min, ptrdiff_t max)\n+{\n+  const ptrdiff_t val = random_signed_value ();\n+  return val < min || max < val ? min : val;\n+}\n+\n+/* For brevity.  */\n+#define UR(min, max)   unsigned_range (min, max)\n+#define SR(min, max)   signed_range (min, max)\n+\n+/* UReturn a pointer to constant string whose length is at least MINLEN\n+   and at most 10.  */\n+static inline const char*\n+string_range (size_t minlen)\n+{\n+  static const char str[] = \"0123456789\";\n+\n+  const size_t len = unsigned_range (minlen, sizeof str - 1);\n+\n+  switch (len)\n+    {\n+    case 10: return \"0123456789\";\n+    case  9: return \"012345678\";\n+    case  8: return \"01234567\";\n+    case  7: return \"0123456\";\n+    case  6: return \"012345\";\n+    case  5: return \"01234\";\n+    case  4: return \"0123\";\n+    case  3: return \"012\";\n+    case  2: return \"01\";\n+    case  1: return \"0\";\n+    case  0: return \"\";\n+    }\n+}\n+\n+#define S(minlen)   string_range (minlen)\n+\n+/* Test memcpy with a number of bytes bounded by a known range.  */\n+\n+void test_memcpy_range (void *d, const void *s)\n+{\n+  char buf[5];\n+\n+  memcpy (buf, s, UR (0, 5));\n+  memcpy (buf, s, UR (1, 5));\n+  memcpy (buf, s, UR (2, 5));\n+  memcpy (buf, s, UR (3, 5));\n+  memcpy (buf, s, UR (4, 5));\n+\n+  memcpy (buf, s, UR (6, 7));  /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 overflows the destination\" } */\n+\n+  memcpy (buf + 5, s, UR (1, 2));  /* { dg-warning \"writing between 1 and 2 bytes into a region of size 0 overflows the destination\" } */\n+\n+  memcpy (buf + size_max, s, UR (1, 2));  /* { dg-warning \"writing between 1 and 2 bytes into a region of size 0 overflows the destination\" \"excessive pointer offset\" { xfail *-*-* } } */\n+\n+  memcpy (buf, s, UR (ssize_max, size_max));   /* { dg-warning \"writing between \\[0-9\\]+ and \\[0-9\\]+ bytes into a region of size 5 overflows the destination\" } */\n+  memcpy (buf, s, UR (ssize_max + 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+  memcpy (buf, s, UR (size_max - 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+\n+  /* Exercise memcpy into a destination of unknown size with excessive\n+     number of bytes.  */\n+  memcpy (d, s, UR (ssize_max, size_max));\n+  memcpy (d, s, UR (ssize_max + 1, size_max));   /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+\n+  memcpy (buf, s, SR (-1, 1));\n+  memcpy (buf, s, SR (-3, 2));\n+  memcpy (buf, s, SR (-5, 3));\n+  memcpy (buf, s, SR (-7, 4));\n+  memcpy (buf, s, SR (-9, 5));\n+  memcpy (buf, s, SR (-11, 6));\n+\n+  memcpy (d, s, SR (-1, 1));\n+  memcpy (d, s, SR (-3, 2));\n+  memcpy (d, s, SR (-5, 3));\n+  memcpy (d, s, SR (-7, 4));\n+  memcpy (d, s, SR (-9, 5));\n+  memcpy (d, s, SR (-11, 6));\n+\n+  memcpy (buf, s, SR (-2, -1));   /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+  memcpy (d, s, SR (-2, -1));   /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+\n+  /* Even though the following calls are bounded by the range of N's\n+     type they must not cause a warning for obvious reasons.  */\n+  memcpy (buf, s, schar_val);\n+  memcpy (buf, s, sshrt_val);\n+  memcpy (buf, s, sint_val);\n+  memcpy (buf, s, slong_val);\n+\n+  memcpy (buf, s, uchar_val);\n+  memcpy (buf, s, ushrt_val);\n+  memcpy (buf, s, uint_val);\n+  memcpy (buf, s, ulong_val);\n+\n+  memcpy (buf, s, schar_val + 1);\n+  memcpy (buf, s, sshrt_val + 2);\n+  memcpy (buf, s, sint_val + 3);\n+  memcpy (buf, s, slong_val + 4);\n+\n+  memcpy (d, s, uchar_val + 5);\n+  memcpy (d, s, ushrt_val + 6);\n+  memcpy (d, s, uint_val + 7);\n+  memcpy (d, s, ulong_val + 8);\n+\n+  memcpy (d, s, schar_val);\n+  memcpy (d, s, sshrt_val);\n+  memcpy (d, s, sint_val);\n+  memcpy (d, s, slong_val);\n+\n+  memcpy (d, s, uchar_val);\n+  memcpy (d, s, ushrt_val);\n+  memcpy (d, s, uint_val);\n+  memcpy (d, s, ulong_val);\n+\n+  memcpy (d, s, schar_val + 1);\n+  memcpy (d, s, sshrt_val + 2);\n+  memcpy (d, s, sint_val + 3);\n+  memcpy (d, s, slong_val + 4);\n+\n+  memcpy (d, s, uchar_val + 5);\n+  memcpy (d, s, ushrt_val + 6);\n+  memcpy (d, s, uint_val + 7);\n+  memcpy (d, s, ulong_val + 8);\n+}\n+\n+/* Test mempcpy with a number of bytes bounded by a known range.  */\n+\n+void test_mempcpy_range (void *d, const void *s)\n+{\n+  char buf[5];\n+\n+  mempcpy (buf, s, UR (0, 5));\n+  mempcpy (buf, s, UR (1, 5));\n+  mempcpy (buf, s, UR (2, 5));\n+  mempcpy (buf, s, UR (3, 5));\n+  mempcpy (buf, s, UR (4, 5));\n+\n+  mempcpy (buf, s, UR (6, 7));  /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 overflows the destination\" } */\n+\n+  mempcpy (buf, s, UR (6, 7));  /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 overflows the destination\" } */\n+\n+  mempcpy (buf, s, UR (ssize_max, size_max));   /* { dg-warning \"writing between \\[0-9\\]+ and \\[0-9\\]+ bytes into a region of size 5 overflows the destination\" } */\n+  mempcpy (buf, s, UR (ssize_max + 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+  mempcpy (buf, s, UR (size_max - 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+\n+  /* Exercise mempcpy into a destination of unknown size with excessive\n+     number of bytes.  */\n+  mempcpy (d, s, UR (ssize_max, size_max));\n+  mempcpy (d, s, UR (ssize_max + 1, size_max));   /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+}\n+\n+/* Test memset with a number of bytes bounded by a known range.  */\n+\n+void test_memset_range (void *d)\n+{\n+  char buf[5];\n+\n+  memset (buf, 0, UR (0, 5));\n+  memset (buf, 0, UR (1, 5));\n+  memset (buf, 0, UR (2, 5));\n+  memset (buf, 0, UR (3, 5));\n+  memset (buf, 0, UR (4, 5));\n+\n+  memset (buf, 0, UR (6, 7));  /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 overflows the destination\" } */\n+\n+  memset (buf, 0, UR (6, 7));  /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 overflows the destination\" } */\n+\n+  memset (buf, 0, UR (ssize_max, size_max));   /* { dg-warning \"writing between \\[0-9\\]+ and \\[0-9\\]+ bytes into a region of size 5 overflows the destination\" } */\n+  memset (buf, 0, UR (ssize_max + 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+  memset (buf, 0, UR (size_max - 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+\n+  /* Exercise memset into a destination of unknown size with excessive\n+     number of bytes.  */\n+  memset (d, 0, UR (ssize_max, size_max));\n+  memset (d, 0, UR (ssize_max + 1, size_max));   /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+}\n+\n+/* Test bzero with a number of bytes bounded by a known range.  */\n+\n+void test_bzero_range (void *d)\n+{\n+  char buf[5];\n+\n+  bzero (buf, UR (0, 5));\n+  bzero (buf, UR (1, 5));\n+  bzero (buf, UR (2, 5));\n+  bzero (buf, UR (3, 5));\n+  bzero (buf, UR (4, 5));\n+\n+  bzero (buf, UR (6, 7));  /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 overflows the destination\" } */\n+\n+  bzero (buf, UR (6, 7));  /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 overflows the destination\" } */\n+\n+  bzero (buf, UR (ssize_max, size_max));   /* { dg-warning \"writing between \\[0-9\\]+ and \\[0-9\\]+ bytes into a region of size 5 overflows the destination\" } */\n+  bzero (buf, UR (ssize_max + 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+  bzero (buf, UR (size_max - 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+\n+  /* Exercise bzero into a destination of unknown size with excessive\n+     number of bytes.  */\n+  bzero (d, UR (ssize_max, size_max));\n+  bzero (d, UR (ssize_max + 1, size_max));   /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+}\n+\n+/* Test strcat with an argument referencing a non-constant string of\n+   lengths in a known range.  */\n+\n+void test_strcat_range (void)\n+{\n+  char buf[5] = \"\";\n+\n+  strcat (buf, S (0));\n+  strcat (buf, S (1));\n+  strcat (buf, S (2));\n+  strcat (buf, S (3));\n+  strcat (buf, S (4));\n+  strcat (buf, S (5));   /* { dg-warning \"writing 6 bytes into a region of size 5 \" } */\n+\n+  {\n+    /* The implementation of the warning isn't smart enough to determine\n+       the length of the string in the buffer so it assumes it's empty\n+       and issues the warning basically for the same cases as strcat.  */\n+    char buf2[5] = \"12\";\n+    strcat (buf2, S (4));   /* { dg-warning \"writing 5 bytes into a region of size 3\" \"strcat to a non-empty string\" { xfail *-*-* } } */\n+  }\n+}\n+\n+/* Verify that strcpy with an unknown source string doesn't cause\n+   warnings unless the destination has zero size.  */\n+\n+void test_strcpy (const char *src)\n+{\n+  struct A { char a[2]; char b[3]; } a;\n+\n+  strcpy (a.a, src);\n+  strcpy (a.a + 1, src);\n+\n+  /* There must be enough room in the destination for the terminating\n+     nul, otherwise verify that a warning is issued.\n+     The following works as expected with __builtin___strcpy_chk and\n+     __builtin_object_size because they see that the offset is from\n+     the a.a array.  When optimization is enabled, it isn't detected\n+     by __bultin_strcpy (when __builtin_object_size isn't called\n+     explicitly) because by the time it's seen the offset has been\n+     transformed to one from the beginning of the whole object, i.e.,\n+     as if it had been written as (char*)&a + 2 .  Then the destination\n+     size is taken to be the rest of the whole object.  It is detected\n+     by __builtin_strcpy when optimization is not enabled because then\n+     the &a.a + 2 expression is preserved.  But without optimization\n+     an ordinary call to strcpy isn't transformed to __builtin_strcpy\n+     and so it can't be detected here (since the rest of the test\n+     relies on optimization).  */\n+  strcpy (a.a + 2, src);    /* { dg-warning \"writing at least 1 byte into a region of size 0 \" \"strcpy into empty substring\" { xfail *-*-* } } */\n+\n+  /* This does work.  */\n+  strcpy (a.a + 5, src);    /* { dg-warning \"writing at least 1 byte into a region of size 0 \" } */\n+\n+  /* As does this.  */\n+  strcpy (a.a + 17, src);    /* { dg-warning \"writing at least 1 byte into a region of size 0 \" } */\n+}\n+\n+/* Test strcpy with a non-constant source string of length in a known\n+   range.  */\n+\n+void test_strcpy_range (void)\n+{\n+  char buf[5];\n+\n+  strcpy (buf, S (0));\n+  strcpy (buf, S (1));\n+  strcpy (buf, S (2));\n+  strcpy (buf, S (4));\n+  strcpy (buf, S (5));   /* { dg-warning \"writing 6 bytes into a region of size 5 \" } */\n+  strcpy (buf, S (6));   /* { dg-warning \"writing 7 bytes into a region of size 5 \" } */\n+  strcpy (buf, S (7));   /* { dg-warning \"writing 8 bytes into a region of size 5 \" } */\n+  strcpy (buf, S (8));   /* { dg-warning \"writing 9 bytes into a region of size 5 \" } */\n+  strcpy (buf, S (9));   /* { dg-warning \"writing 10 bytes into a region of size 5 \" } */\n+  strcpy (buf, S (10));   /* { dg-warning \"writing 11 bytes into a region of size 5 \" } */\n+\n+  strcpy (buf + 5, S (0));   /* { dg-warning \"writing 1 byte into a region of size 0 \" } */\n+\n+  strcpy (buf + 17, S (0));   /* { dg-warning \"writing 1 byte into a region of size 0 \" } */\n+}\n+\n+/* Test strncat with an argument referencing a non-constant string of\n+   lengths in a known range.  */\n+\n+void test_strncat_range (void)\n+{\n+  char buf[5] = \"\";\n+\n+  strncat (buf, S (0), 0);\n+  strncat (buf, S (0), 1);\n+  strncat (buf, S (0), 2);\n+  strncat (buf, S (0), 3);\n+  strncat (buf, S (0), 4);\n+\n+  strncat (buf + 5, S (0), 0);\n+\n+  strncat (buf + 5, S (0), 1);   /* { dg-warning \"specified bound 1 exceeds the size 0 of the destination \" } */\n+  strncat (buf + 5, S (1), 1);   /* { dg-warning \"specified bound 1 exceeds the size 0 of the destination \" } */\n+\n+  /* Strncat always appends a terminating null after copying the N\n+     characters so the following triggers a warning pointing out\n+     that specifying sizeof(buf) as the upper bound may cause\n+     the nul to overflow the destination.  */\n+  strncat (buf, S (0), 5);   /* { dg-warning \"specified bound 5 equals the size of the destination\" } */\n+  strncat (buf, S (0), 6);   /* { dg-warning \"specified bound 6 exceeds the size 5 of the destination\" } */\n+\n+  strncat (buf, S (1), 0);\n+  strncat (buf, S (1), 1);\n+  strncat (buf, S (1), 2);\n+  strncat (buf, S (1), 3);\n+  strncat (buf, S (1), 4);\n+  strncat (buf, S (1), 5);   /* { dg-warning \"specified bound 5 equals the size of the destination\" } */\n+  strncat (buf, S (1), 6);   /* { dg-warning \"specified bound 6 exceeds the size 5 of the destination\" } */\n+  strncat (buf, S (2), 6);   /* { dg-warning \"specified bound 6 exceeds the size 5 of the destination\" } */\n+\n+  /* The following could just as well say \"writing 6 bytes into a region\n+     of size 5.  Either would be correct and probably equally as clear\n+     in this case.  But when the length of the source string is not known\n+     at all then the bound warning seems clearer.  */\n+  strncat (buf, S (5), 6);   /* { dg-warning \"specified bound 6 exceeds the size 5 of the destination \" } */\n+  strncat (buf, S (7), 6);   /* { dg-warning \"specified bound 6 exceeds the size 5 of the destination\" } */\n+\n+  {\n+    /* The implementation of the warning isn't smart enough to determine\n+       the length of the string in the buffer so it assumes it's empty\n+       and issues the warning basically for the same cases as strncpy.  */\n+    char buf2[5] = \"12\";\n+    strncat (buf2, S (4), 4);   /* { dg-warning \"writing 5 bytes into a region of size 3\" \"strncat to a non-empty string\" { xfail *-*-* } } */\n+  }\n+}\n+\n+/* Test strncat_chk with an argument referencing a non-constant string\n+   of lengths in a known range.  */\n+\n+void test_strncat_chk_range (char *d)\n+{\n+  char buf[5] = \"\";\n+\n+#define strncat_chk(d, s, n) \\\n+  __builtin___strncat_chk ((d), (s), (n), __builtin_object_size (d, 1));\n+\n+  strncat_chk (buf, S (0), 1);\n+  strncat_chk (buf, S (0), 2);\n+  strncat_chk (buf, S (0), 3);\n+  strncat_chk (buf, S (0), 4);\n+  strncat_chk (buf, S (0), 5);   /* { dg-warning \"specified bound 5 equals the size of the destination \" } */\n+\n+  strncat_chk (buf, S (5), 1);\n+  strncat_chk (buf, S (5), 2);\n+  strncat_chk (buf, S (5), 3);\n+  strncat_chk (buf, S (5), 4);\n+  strncat_chk (buf, S (5), 5);   /* { dg-warning \"specified bound 5 equals the size of the destination \" } */\n+\n+  strncat_chk (buf, S (5), 10);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds the size 5 of the destination \" } */\n+\n+  strncat_chk (d, S (5), size_max);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \" } */\n+}\n+\n+/* Test strncpy with a non-constant source string of length in a known\n+   range and a constant number of bytes.  */\n+\n+void test_strncpy_string_range (char *d)\n+{\n+  char buf[5];\n+\n+  strncpy (buf, S (0), 0);\n+  strncpy (buf, S (0), 1);\n+  strncpy (buf, S (0), 2);\n+  strncpy (buf, S (0), 3);\n+  strncpy (buf, S (0), 4);\n+  strncpy (buf, S (0), 5);\n+  strncpy (buf, S (0), 6);   /* { dg-warning \"writing 6 bytes into a region of size 5 \" } */\n+\n+  strncpy (buf, S (6), 4);\n+  strncpy (buf, S (7), 5);\n+  strncpy (buf, S (8), 6);   /* { dg-warning \"writing 6 bytes into a region of size 5 \" } */\n+\n+  strncpy (buf, S (1), ssize_max - 1);   /* { dg-warning \"writing \\[0-9\\]+ bytes into a region of size 5\" } */\n+  strncpy (buf, S (2), ssize_max);   /* { dg-warning \"writing \\[0-9\\]+ bytes into a region of size 5\" } */\n+  strncpy (buf, S (3), ssize_max + 1);   /* { dg-warning \"specified size \\[0-9\\]+ exceeds maximum object size\" } */\n+  strncpy (buf, S (4), size_max);   /* { dg-warning \"specified size \\[0-9\\]+ exceeds maximum object size\" } */\n+\n+  /* Exercise strncpy into a destination of unknown size with a valid\n+     and invalid constant number of bytes.  */\n+  strncpy (d, S (1), ssize_max - 1);\n+  strncpy (d, S (2), ssize_max);\n+  strncpy (d, S (3), ssize_max + 1);   /* { dg-warning \"specified size \\[0-9\\]+ exceeds maximum object size\" } */\n+  strncpy (d, S (4), size_max);   /* { dg-warning \"specified size \\[0-9\\]+ exceeds maximum object size\" } */\n+}\n+\n+/* Test strncpy with a non-constant source string of length in a known\n+   range and a non-constant number of bytes also in a known range.  */\n+\n+void test_strncpy_string_count_range (char *dst, const char *src)\n+{\n+  char buf[5];\n+\n+  strncpy (buf, S (0), UR (0, 1));\n+  strncpy (buf, S (0), UR (0, 2));\n+  strncpy (buf, S (0), UR (0, 3));\n+  strncpy (buf, S (0), UR (0, 4));\n+  strncpy (buf, S (0), UR (0, 5));\n+  strncpy (buf, S (0), UR (0, 6));\n+  strncpy (buf, S (0), UR (1, 6));\n+  strncpy (buf, S (0), UR (2, 6));\n+  strncpy (buf, S (0), UR (3, 6));\n+  strncpy (buf, S (0), UR (4, 6));\n+  strncpy (buf, S (0), UR (5, 6));\n+\n+  strncpy (buf, S (9), UR (0, 1));\n+  strncpy (buf, S (8), UR (0, 2));\n+  strncpy (buf, S (7), UR (0, 3));\n+  strncpy (buf, S (6), UR (0, 4));\n+  strncpy (buf, S (8), UR (0, 5));\n+  strncpy (buf, S (7), UR (0, 6));\n+  strncpy (buf, S (6), UR (1, 6));\n+  strncpy (buf, S (5), UR (2, 6));\n+  strncpy (buf, S (9), UR (3, 6));\n+  strncpy (buf, S (8), UR (4, 6));\n+  strncpy (buf, S (7), UR (5, 6));\n+\n+  strncpy (buf, S (0), UR (6, 7));   /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 \" } */\n+  strncpy (buf, S (1), UR (7, 8));   /* { dg-warning \"writing between 7 and 8 bytes into a region of size 5 \" } */\n+  strncpy (buf, S (2), UR (ssize_max, ssize_max + 1));   /* { dg-warning \"writing between \\[0-9\\]+ and \\[0-9\\]+ bytes into a region of size 5 \" } */\n+\n+  strncpy (buf, S (2), UR (ssize_max + 1, ssize_max + 2));   /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+\n+  strncpy (buf + 5, S (0), UR (0, 1));\n+  strncpy (buf + 5, S (1), UR (0, 1));\n+  strncpy (buf + 5, S (0), UR (1, 2));   /* { dg-warning \"writing between 1 and 2 bytes into a region of size 0 \" } */\n+  strncpy (buf + 5, S (1), UR (1, 2));   /* { dg-warning \"writing between 1 and 2 bytes into a region of size 0 \" } */\n+\n+  strncpy (buf, src, UR (0, 1));\n+  strncpy (buf, src, UR (0, 2));\n+  strncpy (buf, src, UR (0, 3));\n+  strncpy (buf, src, UR (0, 4));\n+  strncpy (buf, src, UR (0, 5));\n+  strncpy (buf, src, UR (0, 6));\n+  strncpy (buf, src, UR (1, 6));\n+  strncpy (buf, src, UR (2, 6));\n+  strncpy (buf, src, UR (3, 6));\n+  strncpy (buf, src, UR (4, 6));\n+  strncpy (buf, src, UR (5, 6));\n+  strncpy (buf, src, UR (6, 7));   /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 \" } */\n+\n+  /* Exercise strncpy into a destination of unknown size  with a valid\n+     and invalid constant number of bytes.  */\n+  strncpy (dst, S (0), UR (5, 6));\n+  strncpy (dst, S (1), UR (6, 7));\n+  strncpy (dst, S (2), UR (7, 8));\n+\n+  strncpy (dst, S (3), UR (ssize_max, ssize_max + 1));\n+\n+  strncpy (dst, S (4), UR (ssize_max + 1, ssize_max + 2));   /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n+}"}, {"sha": "489f88077d44f7db0ed5f0e5df33f22878a5287b", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-5.c", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -0,0 +1,260 @@\n+/* Test exercising -Wrawmem-overflow and -Wstringop-overflow warnings.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstringop-overflow=1\" } */\n+\n+#define offsetof(type, mem)   __builtin_offsetof (type, mem)\n+\n+/* Return the number of bytes from member MEM of TYPE to the end\n+   of object OBJ.  */\n+#define offsetfrom(type, obj, mem) (sizeof (obj) - offsetof (type, mem))\n+\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void* memcpy (void*, const void*, size_t);\n+extern void* memset (void*, int, __SIZE_TYPE__);\n+\n+\n+struct A { char a, b; };\n+struct B { struct A a; char c, d; };\n+\n+/* Function to call to \"escape\" pointers from tests below to prevent\n+   GCC from assuming the values of the objects they point to stay\n+   the unchanged.  */\n+void escape (void*, ...);\n+\n+/* Function to \"generate\" a random number each time it's called.  Declared\n+   (but not defined) and used to prevent GCC from making assumptions about\n+   their values based on the variables uses in the tested expressions.  */\n+size_t random_unsigned_value (void);\n+\n+/* Return a random unsigned value between MIN and MAX.  */\n+\n+static inline size_t\n+range (size_t min, size_t max)\n+{\n+  const size_t val = random_unsigned_value ();\n+  return val < min || max < val ? min : val;\n+}\n+\n+/* Verify that writing past the end of a local array is diagnosed.  */\n+\n+void test_memop_warn_local (const void *src)\n+{\n+  size_t n;\n+\n+  n = range (8, 32);\n+\n+  struct A a[2];\n+\n+  memcpy (a, src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" } */\n+  escape (a, src);\n+\n+  /* At -Wrawmem-overflow=1 the destination is considered to be\n+     the whole array and its size is therefore sizeof a.  */\n+  memcpy (&a[0], src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" } */\n+  escape (a, src);\n+\n+  /* Verify the same as above but by writing into the first mmeber\n+     of the first element of the array.  */\n+  memcpy (&a[0].a, src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" } */\n+  escape (a, src);\n+\n+  n = range (12, 32);\n+\n+  struct B b[2];\n+\n+  memcpy (&b[0], src, n);   /* { dg-warning \"writing between 12 and 32 bytes into a region of size 8 overflows the destination\" } */\n+  escape (b);\n+\n+  /* The following idiom of clearing multiple members of a struct is\n+     used in a few places in the Linux kernel.  Verify that a warning\n+     is issued for it when it writes past the end of the array object.  */\n+  memset (&b[0].a.b, 0, offsetfrom (struct B, b, a.b) + 1);   /* { dg-warning \"writing 8 bytes into a region of size 7\" } */\n+  escape (b);\n+\n+  memset (&b->a.b, 0, offsetfrom (struct B, b, a.b) + 1);   /* { dg-warning \"writing 8 bytes into a region of size 7\" } */\n+  escape (b);\n+\n+  memset (&b[0].c, 0, offsetfrom (struct B, b, c) + 1);   /* { dg-warning \"writing 7 bytes into a region of size 6\" } */\n+  escape (b);\n+\n+  memset (&b->c, 0, offsetfrom (struct B, b, c) + 1);   /* { dg-warning \"writing 7 bytes into a region of size 6\" } */\n+  escape (b);\n+\n+  memset (&b[0].d, 0, offsetfrom (struct B, b, d) + 1);   /* { dg-warning \"writing 6 bytes into a region of size 5\" } */\n+  escape (b);\n+\n+  memset (&b->d, 0, offsetfrom (struct B, b, d) + 1);   /* { dg-warning \"writing 6 bytes into a region of size 5\" } */\n+  escape (b);\n+\n+  /* Same as above but clearing just elements of the second element\n+     of the array.  */\n+  memset (&b[1].a.b, 0, offsetfrom (struct B, b[1], a.b) + 1);   /* { dg-warning \"writing 4 bytes into a region of size 3\" } */\n+  escape (b);\n+\n+  memset (&b[1].c, 0, offsetfrom (struct B, b[1], c) + 1);   /* { dg-warning \"writing 3 bytes into a region of size 2\" } */\n+  escape (b);\n+\n+  memset (&b[1].d, 0, offsetfrom (struct B, b[1], d) + 1);   /* { dg-warning \"writing 2 bytes into a region of size 1\" } */\n+  escape (b);\n+}\n+\n+/* Verify that writing past the end of a dynamically allocated array\n+   of known size is diagnosed.  */\n+\n+void test_memop_warn_alloc (const void *src)\n+{\n+  size_t n;\n+\n+  n = range (8, 32);\n+\n+  struct A *a = __builtin_malloc (sizeof *a * 2);\n+\n+  memcpy (a, src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (a, src);\n+\n+  /* At -Wrawmem-overflow=1 the destination is considered to be\n+     the whole array and its size is therefore sizeof a.  */\n+  memcpy (&a[0], src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (a, src);\n+\n+  /* Verify the same as above but by writing into the first mmeber\n+     of the first element of the array.  */\n+  memcpy (&a[0].a, src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (a, src);\n+\n+  n = range (12, 32);\n+\n+  struct B *b = __builtin_malloc (sizeof *b * 2);\n+\n+  memcpy (&b[0], src, n);   /* { dg-warning \"writing between 12 and 32 bytes into a region of size 8 overflows the destination\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (b);\n+\n+  /* The following idiom of clearing multiple members of a struct is\n+     used in a few places in the Linux kernel.  Verify that a warning\n+     is issued for it when it writes past the end of the array object.  */\n+  memset (&b[0].a.b, 0, offsetfrom (struct B, b, a.b) + 1);   /* { dg-warning \"writing 8 bytes into a region of size 7\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (b);\n+\n+  memset (&b->a.b, 0, offsetfrom (struct B, b, a.b) + 1);   /* { dg-warning \"writing 8 bytes into a region of size 7\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (b);\n+\n+  memset (&b[0].c, 0, offsetfrom (struct B, b, c) + 1);   /* { dg-warning \"writing 7 bytes into a region of size 6\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (b);\n+\n+  memset (&b->c, 0, offsetfrom (struct B, b, c) + 1);   /* { dg-warning \"writing 7 bytes into a region of size 6\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (b);\n+\n+  memset (&b[0].d, 0, offsetfrom (struct B, b, d) + 1);   /* { dg-warning \"writing 6 bytes into a region of size 5\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (b);\n+\n+  memset (&b->d, 0, offsetfrom (struct B, b, d) + 1);   /* { dg-warning \"writing 6 bytes into a region of size 5\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (b);\n+\n+  /* Same as above but clearing just elements of the second element\n+     of the array.  */\n+  memset (&b[1].a.b, 0, offsetfrom (struct B, b[1], a.b) + 1);   /* { dg-warning \"writing 4 bytes into a region of size 3\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (b);\n+\n+  memset (&b[1].c, 0, offsetfrom (struct B, b[1], c) + 1);   /* { dg-warning \"writing 3 bytes into a region of size 2\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (b);\n+\n+  memset (&b[1].d, 0, offsetfrom (struct B, b[1], d) + 1);   /* { dg-warning \"writing 2 bytes into a region of size 1\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  escape (b);\n+}\n+\n+\n+void test_memop_nowarn (const void *src)\n+{\n+  struct B b[2];\n+\n+  size_t n = range (sizeof b, 32);\n+\n+  /* Verify that clearing the whole array is not diagnosed regardless\n+     of whether the expression pointing to its beginning is obtained\n+     from the array itself or its first member(s).  */\n+  memcpy (b, src, n);\n+  escape (b);\n+\n+  memcpy (&b[0], src, n);\n+  escape (b);\n+\n+  memcpy (&b[0].a, src, n);\n+  escape (b, src);\n+\n+  memcpy (&b[0].a.a, src, n);\n+  escape (b, src);\n+\n+  /* Clearing multiple elements of an array of structs.  */\n+  memset (&b[0].a.b, 0, sizeof b - offsetof (struct B, a.b));\n+  escape (b);\n+\n+  memset (&b->a.b, 0, sizeof b - offsetof (struct B, a.b));\n+  escape (b);\n+\n+  memset (&b[0].c, 0, sizeof b - offsetof (struct B, c));\n+  escape (b);\n+\n+  memset (&b->c, 0, sizeof b - offsetof (struct B, c));\n+  escape (b);\n+\n+  memset (&b[0].d, 0, sizeof b - offsetof (struct B, d));\n+  escape (b);\n+\n+  memset (&b->d, 0, sizeof b - offsetof (struct B, d));\n+  escape (b);\n+\n+  /* Same as above but clearing just elements of the second element\n+     of the array.  */\n+  memset (&b[1].a.b, 0, sizeof b[1] - offsetof (struct B, a.b));\n+  escape (b);\n+\n+  memset (&b[1].c, 0, sizeof b[1] - offsetof (struct B, c));\n+  escape (b);\n+\n+  memset (&b[1].d, 0, sizeof b[1] - offsetof (struct B, d));\n+  escape (b);\n+}\n+\n+\n+/* The foollowing function could specify in its API that it takes\n+   an array of exactly two elements, as shown below.  Verify that\n+   writing into both elements is not diagnosed.  */\n+void test_memop_nowarn_arg (struct A[2], const void*);\n+\n+void test_memop_nowarn_arg (struct A *a, const void *src)\n+{\n+  memcpy (a, src, 2 * sizeof *a);\n+  escape (a, src);\n+\n+  memcpy (a, src, range (2 * sizeof *a, 123));\n+  escape (a, src);\n+}\n+\n+\n+struct C { char a[3], b; };\n+struct D { struct C c; char d, e; };\n+\n+extern char* strncpy (char*, const char*, __SIZE_TYPE__);\n+\n+void test_stringop_warn (void)\n+{\n+  size_t n = range (2 * sizeof (struct D) + 1, 33);\n+\n+  struct C c[2];\n+\n+  /* Similarly, at -Wstringop-overflow=1 the destination is considered\n+     to be the whole array and its size is therefore sizeof c.  */\n+  strncpy (c[0].a, \"123\", n);   /* { dg-warning \"writing between 13 and 33 bytes into a region of size 8 overflows the destination\" } */\n+\n+  escape (c);\n+}\n+\n+\n+void test_stringop_nowarn (void)\n+{\n+  struct D d[2];\n+\n+  strncpy (d[0].c.a, \"123\", range (sizeof d, 32));\n+  escape (d);\n+}"}, {"sha": "9572ce15cbb8d6be9ca8e370ec6e229d23cba352", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-6.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-6.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -0,0 +1,112 @@\n+/* Test exercising -Wrawmem-overflow and -Wstringop-overflow warnings.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstringop-overflow=2\" } */\n+\n+#define offsetof(type, mem)   __builtin_offsetof (type, mem)\n+\n+/* Return the number of bytes from member MEM of TYPE to the end\n+   of object OBJ.  */\n+#define offsetfrom(type, obj, mem) (sizeof (obj) - offsetof (type, mem))\n+\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void* memcpy (void*, const void*, size_t);\n+extern void* memset (void*, int, __SIZE_TYPE__);\n+\n+\n+struct A { char a, b; };\n+struct B { struct A a; char c, d; };\n+\n+/* Function to call to \"escape\" pointers from tests below to prevent\n+   GCC from assuming the values of the objects they point to stay\n+   the unchanged.  */\n+void escape (void*, ...);\n+\n+/* Function to \"generate\" a random number each time it's called.  Declared\n+   (but not defined) and used to prevent GCC from making assumptions about\n+   their values based on the variables uses in the tested expressions.  */\n+size_t random_unsigned_value (void);\n+\n+/* Return a random unsigned value between MIN and MAX.  */\n+\n+static inline size_t\n+range (size_t min, size_t max)\n+{\n+  const size_t val = random_unsigned_value ();\n+  return val < min || max < val ? min : val;\n+}\n+\n+\n+void test_memop_warn_object (const void *src)\n+{\n+  unsigned n = range (17, 29);\n+\n+  struct A a[2];\n+\n+  /* At both -Wstringop-overflow=2, like at 1, the destination of functions\n+     that operate on raw memory is considered to be the whole array and its\n+     size is therefore sizeof a.  */\n+  memcpy (&a[0], src, n);   /* { dg-warning \"writing between 17 and 29 bytes into a region of size 4 overflows the destination\" } */\n+  escape (a);\n+}\n+\n+void test_memop_warn_subobject (const void *src)\n+{\n+  unsigned n = range (17, 31);\n+\n+  struct B b[2];\n+\n+  /* At -Wrawmem-overflow=2 the destination is considered to be\n+     the member sobobject of the first array element and its size\n+     is therefore sizeof b[0].a.  */\n+  memcpy (&b[0].a, src, n);   /* { dg-warning \"writing between 17 and 31 bytes into a region of size 8 overflows the destination\" } */\n+\n+  escape (b);\n+}\n+\n+void test_memop_nowarn_subobject (void)\n+{\n+  struct B b[2];\n+\n+  /* The following idiom of clearing multiple members of a struct\n+     has been seen in a few places in the Linux kernel.  Verify\n+     that a warning is not issued for it.  */\n+  memset (&b[0].c, 0, sizeof b[0] - offsetof (struct B, c));\n+\n+  escape (b);\n+}\n+\n+struct C { char a[3], b; };\n+struct D { struct C c; char d, e; };\n+\n+extern char* strncpy (char*, const char*, __SIZE_TYPE__);\n+\n+void test_stringop_warn_object (const char *str)\n+{\n+  unsigned n = range (2 * sizeof (struct D), 32);\n+\n+  struct C c[2];\n+\n+  /* Similarly, at -Wstringop-overflow=2 the destination is considered\n+     to be the array member of the first element of the array c and its\n+     size is therefore sizeof c[0].a.  */\n+  strncpy (c[0].a, \"123\", n);   /* { dg-warning \"writing between 12 and 32 bytes into a region of size 3 overflows the destination\" } */\n+  escape (c);\n+\n+  strncpy (c[0].a, str, n);   /* { dg-warning \"writing between 12 and 32 bytes into a region of size 3 overflows the destination\" } */\n+  escape (c);\n+}\n+\n+void test_stringop_warn_subobject (const char *src)\n+{\n+  unsigned n = range (2 * sizeof (struct D), 32);\n+\n+  struct D d[2];\n+\n+  /* Same as above.  */\n+  strncpy (d[0].c.a, \"123\", n);   /* { dg-warning \"writing between 12 and 32 bytes into a region of size 3 overflows the destination\" } */\n+  escape (d);\n+\n+  strncpy (d[0].c.a, src, n);   /* { dg-warning \"writing between 12 and 32 bytes into a region of size 3 overflows the destination\" } */\n+  escape (d);\n+}"}, {"sha": "daff6801eea98bc2348a86f40d02e96b882c0a02", "filename": "gcc/testsuite/gcc.dg/builtin-strncat-chk-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-strncat-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-strncat-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-strncat-chk-1.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -24,15 +24,15 @@ test (int arg, ...)\n   *p = 0;\n   strncat (p, \"abcdefghi\", 10);\n   *p = 0;\n-  strncat (p, \"abcdefghij\", 10); /* { dg-warning \"will always overflow\" } */\n+  strncat (p, \"abcdefghij\", 10); /* { dg-warning \"writing 11 bytes into a region of size 10 overflows the destination\" } */\n   *p = 0;\n   strncat (p, \"abcdefgh\", 11);\n   *p = 0;\n-  strncat (p, \"abcdefghijkl\", 11); /* { dg-warning \"will always overflow\" } */\n+  strncat (p, \"abcdefghijkl\", 11); /* { dg-warning \"specified bound 11 exceeds the size 10 of the destination\" } */\n   *p = 0;\n   strncat (p, q, 9);\n   *p = 0;\n-  strncat (p, q, 10); /* { dg-warning \"might overflow\" } */\n+  strncat (p, q, 10); /* { dg-warning \"specified bound 10 equals the size of the destination\" } */\n   *p = 0;\n-  strncat (p, q, 11); /* { dg-warning \"might overflow\" } */\n+  strncat (p, q, 11); /* { dg-warning \"specified bound 11 exceeds the size 10 of the destination\" } */\n }"}, {"sha": "94dc3508f1adb46678271e466c2f566e8a34a8f5", "filename": "gcc/testsuite/gcc.dg/fstack-protector-strong.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Ffstack-protector-strong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Ffstack-protector-strong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffstack-protector-strong.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -106,7 +106,7 @@ int\n foo8 ()\n {\n   char base[100];\n-  memcpy ((void *)base, (const void *)pg0, 105);\n+  memcpy ((void *)base, (const void *)pg0, 105);   /* { dg-warning \"writing 105 bytes into a region of size 100\" } */\n   return (int)(base[32]);\n }\n "}, {"sha": "7f839d27abde09668a9e7620c36bc8e951957e52", "filename": "gcc/testsuite/gcc.dg/memcpy-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-2.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -7,7 +7,7 @@ typedef __SIZE_TYPE__ size_t;\n extern inline __attribute__((gnu_inline, always_inline, artificial)) void *\n memcpy (void *__restrict dest, const void *__restrict src, size_t len)\n {\n-  return __builtin___memcpy_chk (dest, /* { dg-warning \"will always overflow destination buffer\" } */\n+  return __builtin___memcpy_chk (dest, /* { dg-warning \"writing\" } */\n \t\t\t\t src, len, __builtin_object_size (dest, 0));\n }\n "}, {"sha": "78540a252128fb75d12704e457f573fb53567518", "filename": "gcc/testsuite/gcc.dg/pr40340-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-1.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -20,5 +20,5 @@ main (void)\n   return 0;\n }\n \n-/* { dg-warning \"will always overflow destination buffer\" \"\" { target *-*-* } 10 } */\n+/* { dg-warning \"writing\" \"\" { target *-*-* } 10 } */\n /* { dg-message \"file included\" \"In file included\" { target *-*-* } 0 } */"}, {"sha": "1dc21d1bb62e2f39218252f6615deae0cddd5834", "filename": "gcc/testsuite/gcc.dg/pr40340-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-2.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -12,5 +12,5 @@ main (void)\n   return 0;\n }\n \n-/* { dg-warning \"will always overflow destination buffer\" \"\" { target *-*-* } 10 } */\n+/* { dg-warning \"writing\" \"\" { target *-*-* } 10 } */\n /* { dg-message \"file included\" \"In file included\" { target *-*-* } 0 } */"}, {"sha": "e51714737161d5ce58434284ef88e116217543b1", "filename": "gcc/testsuite/gcc.dg/pr40340-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-5.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -13,5 +13,5 @@ main (void)\n   return 0;\n }\n \n-/* { dg-warning \"will always overflow destination buffer\" \"\" { target *-*-* } 10 } */\n+/* { dg-warning \"writing\" \"\" { target *-*-* } 10 } */\n /* { dg-message \"file included\" \"In file included\" { target *-*-* } 0 } */"}, {"sha": "b5a59f4d0ba5705a065b2477e6c94d479e86fa31", "filename": "gcc/testsuite/gcc.dg/torture/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -710,4 +710,4 @@ f4 (char *x, char **y, int z, char w[64])\n   return z;\n }\n \n-/* { dg-prune-output \"\\[\\n\\r\\]*will always overflow\\[\\n\\r\\]*\" } */\n+/* { dg-prune-output \"\\[\\n\\r\\]*writing\\[\\n\\r\\]*\" } */"}, {"sha": "2544eb14292a62620cf41410ba86798a3bbea525", "filename": "gcc/testsuite/gcc.dg/torture/pr71132.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71132.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71132.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71132.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -1,4 +1,9 @@\n /* { dg-do compile } */\n+/* { dg-additional-options \"-Wno-stringop-overflow\" } */\n+/* The loop below writes past the end of the global object a.\n+   When the loop is transformed into a call to memcpy the buffer\n+   overflow is detected and diagnosed by the -Wstringop-overflow\n+   option enabled by default.  */\n \n typedef unsigned size_t;\n struct {"}, {"sha": "a551e23c25154222cc88df5df2e63ee6a2d19b35", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-1.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-std=c99 -Wformat -Wformat-length=1 -ftrack-macro-expansion=0\" } */\n+/* { dg-options \"-Wformat -Wformat-length=1 -ftrack-macro-expansion=0\" } */\n /* { dg-require-effective-target int32plus } */\n \n /* When debugging, define LINE to the line number of the test case to exercise\n@@ -1456,9 +1456,7 @@ void test_vsprintf_chk_int (__builtin_va_list va)\n \n void test_snprintf_c_const (char *d)\n {\n-  T (-1, \"%c\",    0);            /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" } */\n-\n-  __builtin_snprintf (d, INT_MAX, \"%c\", 0);   /* { dg-warning \"specified destination size 2147483647 is too large\" \"ilp32\" { target { ilp32 } } } */\n+  T (-1, \"%c\",    0);            /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n   /* Verify the full text of the diagnostic for just the distinct messages\n      and use abbreviations in subsequent test cases.  */\n@@ -1506,9 +1504,9 @@ void test_snprintf_chk_c_const (void)\n   /* Verify that specifying a size of the destination buffer that's\n      bigger than its actual size (normally determined and passed to\n      the function by __builtin_object_size) is diagnosed.  */\n-  __builtin___snprintf_chk (buffer, 3, 0, 2, \" \");   /* { dg-warning \"always overflow|specified size 3 exceeds the size 2 of the destination\" } */\n+  __builtin___snprintf_chk (buffer, 3, 0, 2, \" \");   /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" } */\n \n-  T (-1, \"%c\",    0);           /* { dg-warning \"specified destination size \\[^ \\]* is too large\" } */\n+  T (-1, \"%c\",    0);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n   T (0, \"%c\",     0);\n   T (0, \"%c%c\",   0, 0);\n@@ -1619,7 +1617,7 @@ void test_vsprintf_int (__builtin_va_list va)\n \n void test_vsnprintf_s (__builtin_va_list va)\n {\n-  T (-1, \"%s\");             /* { dg-warning \"specified destination size \\[^ \\]* is too large\" } */\n+  T (-1, \"%s\");             /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n   T (0, \"%s\");\n   T (1, \"%s\");\n@@ -1642,9 +1640,9 @@ void test_vsnprintf_chk_s (__builtin_va_list va)\n   /* Verify that specifying a size of the destination buffer that's\n      bigger than its actual size (normally determined and passed to\n      the function by __builtin_object_size) is diagnosed.  */\n-  __builtin___vsnprintf_chk (buffer, 123, 0, 122, \"%-s\", va);   /* { dg-warning \"always overflow|specified size 123 exceeds the size 122 of the destination object\" } */\n+  __builtin___vsnprintf_chk (buffer, 123, 0, 122, \"%-s\", va);   /* { dg-warning \"specified bound 123 exceeds the size 122 of the destination\" } */\n \n-  __builtin___vsnprintf_chk (buffer, __SIZE_MAX__, 0, 2, \"%-s\", va);   /* { dg-warning \"always overflow|destination size .\\[0-9\\]+. is too large\" } */\n+  __builtin___vsnprintf_chk (buffer, __SIZE_MAX__, 0, 2, \"%-s\", va);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n   T (0, \"%s\");\n   T (1, \"%s\");"}, {"sha": "57fea66d69e7c6c2f4a48b681f5862269c3d0426", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-std=c99 -O2 -Wformat -Wformat-length=1 -ftrack-macro-expansion=0\" } */\n+/* { dg-options \"-O2 -Wformat -Wformat-length=1 -ftrack-macro-expansion=0\" } */\n \n typedef __SIZE_TYPE__ size_t;\n \n@@ -248,34 +248,34 @@ void test_too_large (char *d, int x, __builtin_va_list va)\n   const size_t imax = __INT_MAX__;\n   const size_t imax_p1 = imax + 1;\n \n-  __builtin_snprintf (d, imax,    \"%c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"INT_MAX\" { target ilp32 } } */\n-  __builtin_snprintf (d, imax_p1, \"%c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"INT_MAX + 1\" { target lp64 } } */\n-  /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"\" { target { ilp32 } } .-1 } */\n+  __builtin_snprintf (d, imax,    \"%c\", x);\n+  __builtin_snprintf (d, imax_p1, \"%c\", x);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"INT_MAX + 1\" { target lp64 } } */\n+  /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size\" \"INT_MAX + 1\" { target { ilp32 } } .-1 } */\n \n-  __builtin_vsnprintf (d, imax,    \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"INT_MAX\" { target ilp32 } } */\n-  __builtin_vsnprintf (d, imax_p1, \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"INT_MAX + 1\" { target lp64 } } */\n-  /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"\" { target { ilp32 } } .-1 } */\n+  __builtin_vsnprintf (d, imax,    \"%c\", va);\n+  __builtin_vsnprintf (d, imax_p1, \"%c\", va);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"INT_MAX + 1\" { target lp64 } } */\n+  /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size\" \"INT_MAX + 1\" { target { ilp32 } } .-1 } */\n \n-  __builtin___snprintf_chk (d, imax,    0, imax,    \"%c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"INT_MAX\" { target ilp32 } } */\n-  __builtin___snprintf_chk (d, imax_p1, 0, imax_p1, \"%c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"INT_MAX + 1\" { target lp64 } } */\n-  /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"INT_MAX + 1\" { target { ilp32 } } .-1 } */\n+  __builtin___snprintf_chk (d, imax,    0, imax,    \"%c\", x);\n+  __builtin___snprintf_chk (d, imax_p1, 0, imax_p1, \"%c\", x);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"INT_MAX + 1\" { target lp64 } } */\n+  /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size\" \"INT_MAX + 1\" { target { ilp32 } } .-1 } */\n \n-  __builtin___vsnprintf_chk (d, imax,    0, imax,    \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"INT_MAX\" { target ilp32 } } */\n-  __builtin___vsnprintf_chk (d, imax_p1, 0, imax_p1, \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"INT_MAX + 1\" { target lp64 } } */\n-  /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"\" { target { ilp32 } } .-1 } */\n+  __builtin___vsnprintf_chk (d, imax,    0, imax,    \"%c\", va);\n+  __builtin___vsnprintf_chk (d, imax_p1, 0, imax_p1, \"%c\", va);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"INT_MAX + 1\" { target lp64 } } */\n+  /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size\" \"INT_MAX + 1\" { target { ilp32 } } .-1 } */\n \n   const size_t ptrmax = __PTRDIFF_MAX__;\n   const size_t ptrmax_m1 = ptrmax - 1;\n \n-  __builtin_snprintf (d, ptrmax_m1, \"%c\", x);  /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX - 1\" { target lp64 } } */\n-  __builtin_snprintf (d, ptrmax, \"  %c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" } */\n+  __builtin_snprintf (d, ptrmax_m1, \"%c\", x);  /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX - 1\" { target lp64 } } */\n+  __builtin_snprintf (d, ptrmax, \"  %c\", x);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX\" { target lp64 } } */\n \n-  __builtin_vsnprintf (d, ptrmax_m1, \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX - 1\" { target lp64 } } */\n-  __builtin_vsnprintf (d, ptrmax,    \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" } */\n+  __builtin_vsnprintf (d, ptrmax_m1, \"%c\", va);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX - 1\" { target lp64 } } */\n+  __builtin_vsnprintf (d, ptrmax,    \"%c\", va);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX\" { target lp64 } } */\n \n-  __builtin___snprintf_chk (d, ptrmax_m1, 0, ptrmax_m1, \"%c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX - 1\" { target lp64 } } */\n-  __builtin___snprintf_chk (d, ptrmax,    0, ptrmax,    \"%c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" } */\n+  __builtin___snprintf_chk (d, ptrmax_m1, 0, ptrmax_m1, \"%c\", x);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX - 1\" { target lp64 } } */\n+  __builtin___snprintf_chk (d, ptrmax,    0, ptrmax,    \"%c\", x);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX\" { target lp64 } } */\n \n-  __builtin___vsnprintf_chk (d, ptrmax_m1, 0, ptrmax_m1, \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX - 1\" { target lp64 } } */\n-  __builtin___vsnprintf_chk (d, ptrmax,    0, ptrmax,    \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" } */\n+  __builtin___vsnprintf_chk (d, ptrmax_m1, 0, ptrmax_m1, \"%c\", va);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX - 1\" { target lp64 } } */\n+  __builtin___vsnprintf_chk (d, ptrmax,    0, ptrmax,    \"%c\", va);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds .INT_MAX.\" \"PTRDIFF_MAX\" { target lp64 } } */\n }"}, {"sha": "6529a77ff0489a183762faa3a1436e877a05993a", "filename": "gcc/testsuite/gfortran.dg/char_length_3.f90", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_3.f90?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -47,3 +47,6 @@ subroutine arr(y)\n            y(1) = 'hello world'\n         end subroutine\n        end\n+\n+ ! Remove -Wstringop-overflow warnings.\n+ ! { dg-prune-output \"overflows the destination\" }"}, {"sha": "583bf901b4ef733867bece84e000dcfa22964775", "filename": "gcc/testsuite/gfortran.dg/pr38868.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr38868.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee92e7bafb52d267f52e4c48edada5f279bcf591/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr38868.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr38868.f?ref=ee92e7bafb52d267f52e4c48edada5f279bcf591", "patch": "@@ -9,7 +9,7 @@ PROGRAM testcase\n       ANER(1)='A   '\n       ANER(2)='    '\n       LINE=' '\n-      LINE(78:80)='xyz'\n+      LINE(78:80)='xyz'   ! { dg-warning \"writing 3 bytes into a region of size 2\" }\n       WRITE(*,'(A82)') \"'\"//LINE//\"'\"\n       END\n "}]}