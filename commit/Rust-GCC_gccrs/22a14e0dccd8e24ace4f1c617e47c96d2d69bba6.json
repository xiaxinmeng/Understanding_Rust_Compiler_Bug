{"sha": "22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJhMTRlMGRjY2Q4ZTI0YWNlNGYxYzYxN2U0N2M5NmQyZDY5YmJhNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-18T18:05:54Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2005-03-18T18:05:54Z"}, "message": "config/m32r/m32r-protos.h...\n\nconfig/m32r/m32r-protos.h: Remove the prototypes for\n\tcall_address_operand, symbolic_operand, seth_add3_operand,\n\tcmp_int16_operand, uint16_operand, reg_or_int16_operand,\n\treg_or_uint16_operand, reg_or_cmp_int16_operand,\n\ttwo_insn_const_operand, move_src_operand,\n\tmove_double_src_operand, move_dest_operand,\n\teqne_comparison_operator, signed_comparison_operator,\n\tlarge_insn_p, conditional_move_operand, carry_compare_operand,\n\tm32r_block_immediate_operand, extend_operand,\n\treg_or_eq_int16_operand, int8_operand, and\n\treg_or_zero_operand.\n* config/m32r/m32r.c (call_address_operand, symbolic_operand,\n\tseth_add3_operand, int8_operand, cmp_int16_operand,\n\tuint16_operand, reg_or_int16_operand, reg_or_uint16_operand,\n\treg_or_eq_int16_operand, reg_or_cmp_int16_operand,\n\treg_or_zero_operand, two_insn_const_operand, move_src_operand,\n\tmove_double_src_operand, move_dest_operand,\n\teqne_comparison_operator, signed_comparison_operator,\n\textend_operand, small_insn_p, large_insn_p,\n\tconditional_move_operand, carry_compare_operand,\n\tm32r_block_immediate_operand): Move to predicates.md.\n\t(MAX_MOVE_BYTES): Move to m32r.h.\n* config/m32r/m32r.h (PREDICATE_CODES): Remove.\n* config/m32r/m32r.md: Include predicates.md.\n* config/m32r/predicates.md: New.\n\nFrom-SVN: r96691", "tree": {"sha": "ad8f63003bb950c0a16efe355b5e656c1bf0865b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad8f63003bb950c0a16efe355b5e656c1bf0865b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/comments", "author": null, "committer": null, "parents": [{"sha": "0a1948ed7bfda7c4e3ca6504727b129f000be860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a1948ed7bfda7c4e3ca6504727b129f000be860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a1948ed7bfda7c4e3ca6504727b129f000be860"}], "stats": {"total": 971, "additions": 483, "deletions": 488}, "files": [{"sha": "6adc260cdf6aaa2e9f3c9c08e6ff1eb162907ec6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "patch": "@@ -1,3 +1,31 @@\n+2005-03-18  2005-03-18  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/m32r/m32r-protos.h: Remove the prototypes for\n+\tcall_address_operand, symbolic_operand, seth_add3_operand,\n+\tcmp_int16_operand, uint16_operand, reg_or_int16_operand,\n+\treg_or_uint16_operand, reg_or_cmp_int16_operand,\n+\ttwo_insn_const_operand, move_src_operand,\n+\tmove_double_src_operand, move_dest_operand,\n+\teqne_comparison_operator, signed_comparison_operator,\n+\tlarge_insn_p, conditional_move_operand, carry_compare_operand,\n+\tm32r_block_immediate_operand, extend_operand,\n+\treg_or_eq_int16_operand, int8_operand, and\n+\treg_or_zero_operand.\n+\t* config/m32r/m32r.c (call_address_operand, symbolic_operand,\n+\tseth_add3_operand, int8_operand, cmp_int16_operand,\n+\tuint16_operand, reg_or_int16_operand, reg_or_uint16_operand,\n+\treg_or_eq_int16_operand, reg_or_cmp_int16_operand,\n+\treg_or_zero_operand, two_insn_const_operand, move_src_operand,\n+\tmove_double_src_operand, move_dest_operand,\n+\teqne_comparison_operator, signed_comparison_operator,\n+\textend_operand, small_insn_p, large_insn_p,\n+\tconditional_move_operand, carry_compare_operand,\n+\tm32r_block_immediate_operand): Move to predicates.md.\n+\t(MAX_MOVE_BYTES): Move to m32r.h.\n+\t* config/m32r/m32r.h (PREDICATE_CODES): Remove.\n+\t* config/m32r/m32r.md: Include predicates.md.\n+\t* config/m32r/predicates.md: New.\n+\n 2005-03-18  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* hooks.c, hooks.h, intl.c, opts.h, prefix.c, tree-gimple.c,"}, {"sha": "0f72bd7521f06949e32943808cca2c7d360d7b31", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes for m32r.c functions used in the md file & elsewhere.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -58,35 +58,13 @@ extern rtx    m32r_return_addr (int);\n extern rtx    m32r_function_symbol (const char *);\n \n #ifdef HAVE_MACHINE_MODES\n-extern int    call_address_operand (rtx, Mmode);\n extern int    call_operand (rtx, Mmode);\n-extern int    symbolic_operand (rtx, Mmode);\n extern int    small_data_operand (rtx, Mmode);\n extern int    addr24_operand (rtx, Mmode);\n extern int    addr32_operand (rtx, Mmode);\n extern int    call26_operand (rtx, Mmode);\n-extern int    seth_add3_operand (rtx, Mmode);\n-extern int    cmp_int16_operand (rtx, Mmode);\n-extern int    uint16_operand (rtx, Mmode);\n-extern int    reg_or_int16_operand (rtx, Mmode);\n-extern int    reg_or_uint16_operand (rtx, Mmode);\n-extern int    reg_or_cmp_int16_operand (rtx, Mmode);\n-extern int    two_insn_const_operand (rtx, Mmode);\n-extern int    move_src_operand (rtx, Mmode);\n-extern int    move_double_src_operand (rtx, Mmode);\n-extern int    move_dest_operand (rtx, Mmode);\n-extern int    eqne_comparison_operator (rtx, Mmode);\n-extern int    signed_comparison_operator (rtx, Mmode);\n extern int    memreg_operand (rtx, Mmode);\n extern int    small_insn_p (rtx, Mmode);\n-extern int    large_insn_p (rtx, Mmode);\n-extern int    conditional_move_operand (rtx, Mmode);\n-extern int    carry_compare_operand (rtx, Mmode);\n-extern int    m32r_block_immediate_operand (rtx, Mmode);\n-extern int    extend_operand (rtx, Mmode);\n-extern int    reg_or_eq_int16_operand (rtx, Mmode);\n-extern int    int8_operand (rtx, Mmode);\n-extern int    reg_or_zero_operand (rtx, Mmode);\n \n #endif /* HAVE_MACHINE_MODES */\n "}, {"sha": "dd86186d56d3c5a34134ba15e1a70adf16302913", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 2, "deletions": 428, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on the Renesas M32R cpu.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+   2005 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -472,17 +472,6 @@ m32r_init_expanders (void)\n      to make it easy to experiment.  */\n }\n \f\n-/* Acceptable arguments to the call insn.  */\n-\n-int\n-call_address_operand (rtx op, enum machine_mode mode)\n-{\n-  return symbolic_operand (op, mode);\n-\n-/* Constants and values in registers are not OK, because\n-   the m32r BL instruction can only support PC relative branching.  */ \n-}\n-\n int\n call_operand (rtx op, enum machine_mode mode)\n {\n@@ -492,23 +481,6 @@ call_operand (rtx op, enum machine_mode mode)\n   return call_address_operand (op, mode);\n }\n \n-/* Returns 1 if OP is a symbol reference.  */\n-\n-int\n-symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case CONST :\n-      return 1;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n /* Return 1 if OP is a reference to an object in .sdata/.sbss.  */\n \n int\n@@ -604,256 +576,6 @@ call26_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return TARGET_CALL26;\n }\n \n-/* Returns 1 if OP is an acceptable operand for seth/add3.  */\n-\n-int\n-seth_add3_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (flag_pic)\n-    return 0;\n-\n-  if (GET_CODE (op) == SYMBOL_REF\n-      || GET_CODE (op) == LABEL_REF)\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n-      && INT16_P (INTVAL (XEXP (XEXP (op, 0), 1))))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return true if OP is a signed 8 bit immediate value.  */\n-\n-int\n-int8_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return INT8_P (INTVAL (op));\n-}\n-\n-/* Return true if OP is a signed 16 bit immediate value\n-   useful in comparisons.  */\n-\n-int\n-cmp_int16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return CMP_INT16_P (INTVAL (op));\n-}\n-\n-/* Return true if OP is an unsigned 16 bit immediate value.  */\n-\n-int\n-uint16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return UINT16_P (INTVAL (op));\n-}\n-\n-/* Return true if OP is a register or signed 16 bit value.  */\n-\n-int\n-reg_or_int16_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n-    return register_operand (op, mode);\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return INT16_P (INTVAL (op));\n-}\n-\n-/* Return true if OP is a register or an unsigned 16 bit value.  */\n-\n-int\n-reg_or_uint16_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n-    return register_operand (op, mode);\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return UINT16_P (INTVAL (op));\n-}\n-\n-/* Return true if OP is a register or an integer value that can be\n-   used is SEQ/SNE.  We can use either XOR of the value or ADD of\n-   the negative of the value for the constant.  Don't allow 0,\n-   because that is special cased.  */\n-\n-int\n-reg_or_eq_int16_operand (rtx op, enum machine_mode mode)\n-{\n-  HOST_WIDE_INT value;\n-\n-  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n-    return register_operand (op, mode);\n-\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  value = INTVAL (op);\n-  return (value != 0) && (UINT16_P (value) || CMP_INT16_P (-value));\n-}\n-\n-/* Return true if OP is a register or signed 16 bit value for compares.  */\n-\n-int\n-reg_or_cmp_int16_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n-    return register_operand (op, mode);\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return CMP_INT16_P (INTVAL (op));\n-}\n-\n-/* Return true if OP is a register or the constant 0.  */\n-\n-int\n-reg_or_zero_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n-    return register_operand (op, mode);\n-\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  return INTVAL (op) == 0;\n-}\n-\n-/* Return true if OP is a const_int requiring two instructions to load.  */\n-\n-int\n-two_insn_const_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  if (INT16_P (INTVAL (op))\n-      || UINT24_P (INTVAL (op))\n-      || UPPER16_P (INTVAL (op)))\n-    return 0;\n-  return 1;\n-}\n-\n-/* Return true if OP is an acceptable argument for a single word\n-   move source.  */\n-\n-int\n-move_src_operand (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case LABEL_REF :\n-    case SYMBOL_REF :\n-    case CONST :\n-      return addr24_operand (op, mode);\n-    case CONST_INT :\n-      /* ??? We allow more cse opportunities if we only allow constants\n-\t loadable with one insn, and split the rest into two.  The instances\n-\t where this would help should be rare and the current way is\n-\t simpler.  */\n-      if (HOST_BITS_PER_WIDE_INT > 32)\n-\t{\n-\t  HOST_WIDE_INT rest = INTVAL (op) >> 31;\n-\t  return (rest == 0 || rest == -1);\n-\t}\n-      else\n-\treturn 1;\n-    case CONST_DOUBLE :\n-      if (mode == SFmode)\n-\treturn 1;\n-      else if (mode == SImode)\n-\t{\n-\t  /* Large unsigned constants are represented as const_double's.  */\n-\t  unsigned HOST_WIDE_INT low, high;\n-\n-\t  low = CONST_DOUBLE_LOW (op);\n-\t  high = CONST_DOUBLE_HIGH (op);\n-\t  return high == 0 && low <= (unsigned) 0xffffffff;\n-\t}\n-      else\n-\treturn 0;\n-    case REG :\n-      return register_operand (op, mode);\n-    case SUBREG :\n-      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n-\t pseudo-reg and is now a stack slot.  */\n-      if (GET_CODE (SUBREG_REG (op)) == MEM)\n-\treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n-      else\n-\treturn register_operand (op, mode);\n-    case MEM :\n-      if (GET_CODE (XEXP (op, 0)) == PRE_INC\n-\t  || GET_CODE (XEXP (op, 0)) == PRE_DEC)\n-\treturn 0;\t\t/* loads can't do pre-{inc,dec} */\n-      return address_operand (XEXP (op, 0), mode);\n-    default :\n-      return 0;\n-    }\n-}\n-\n-/* Return true if OP is an acceptable argument for a double word\n-   move source.  */\n-\n-int\n-move_double_src_operand (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_INT :\n-    case CONST_DOUBLE :\n-      return 1;\n-    case REG :\n-      return register_operand (op, mode);\n-    case SUBREG :\n-      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n-\t pseudo-reg and is now a stack slot.  */\n-      if (GET_CODE (SUBREG_REG (op)) == MEM)\n-\treturn move_double_src_operand (SUBREG_REG (op), mode);\n-      else\n-\treturn register_operand (op, mode);\n-    case MEM :\n-      /* Disallow auto inc/dec for now.  */\n-      if (GET_CODE (XEXP (op, 0)) == PRE_DEC\n-\t  || GET_CODE (XEXP (op, 0)) == PRE_INC)\n-\treturn 0;\n-      return address_operand (XEXP (op, 0), mode);\n-    default :\n-      return 0;\n-    }\n-}\n-\n-/* Return true if OP is an acceptable argument for a move destination.  */\n-\n-int\n-move_dest_operand (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case REG :\n-      return register_operand (op, mode);\n-    case SUBREG :\n-      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n-\t pseudo-reg and is now a stack slot.  */\n-      if (GET_CODE (SUBREG_REG (op)) == MEM)\n-\treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n-      else\n-\treturn register_operand (op, mode);\n-    case MEM :\n-      if (GET_CODE (XEXP (op, 0)) == POST_INC)\n-\treturn 0;\t\t/* stores can't do post inc */\n-      return address_operand (XEXP (op, 0), mode);\n-    default :\n-      return 0;\n-    }\n-}\n-\n /* Return 1 if OP is a DImode const we want to handle inline.\n    This must match the code in the movdi pattern.\n    It is used by the 'G' CONST_DOUBLE_OK_FOR_LETTER.  */\n@@ -893,28 +615,6 @@ easy_df_const (rtx op)\n   return 0;\n }\n \n-/* Return 1 if OP is an EQ or NE comparison operator.  */\n-\n-int\n-eqne_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-\n-  return (code == EQ || code == NE);\n-}\n-\n-/* Return 1 if OP is a signed comparison operator.  */\n-\n-int\n-signed_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-\n-  return (COMPARISON_P (op)\n-  \t  && (code == EQ || code == NE\n-\t      || code == LT || code == LE || code == GT || code == GE));\n-}\n-\n /* Return 1 if OP is (mem (reg ...)).\n    This is used in insn length calcs.  */\n \n@@ -924,58 +624,6 @@ memreg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == REG;\n }\n \n-/* Return true if OP is an acceptable input argument for a zero/sign extend\n-   operation.  */\n-\n-int\n-extend_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx addr;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case REG :\n-    case SUBREG :\n-      return register_operand (op, mode);\n-\n-    case MEM :\n-      addr = XEXP (op, 0);\n-      if (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)\n-\treturn 0;\t\t/* loads can't do pre inc/pre dec */\n-\n-      return address_operand (addr, mode);\n-\n-    default :\n-      return 0;\n-    }\n-}\n-\n-/* Return nonzero if the operand is an insn that is a small insn.\n-   Allow const_int 0 as well, which is a placeholder for NOP slots.  */\n-\n-int\n-small_insn_p (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == CONST_INT && INTVAL (op) == 0)\n-    return 1;\n-\n-  if (! INSN_P (op))\n-    return 0;\n-\n-  return get_attr_length (op) == 2;\n-}\n-\n-/* Return nonzero if the operand is an insn that is a large insn.  */\n-\n-int\n-large_insn_p (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (! INSN_P (op))\n-    return 0;\n-\n-  return get_attr_length (op) != 2;\n-}\n-\n /* Return nonzero if TYPE must be passed by indirect reference.  */\n \n static bool\n@@ -2424,59 +2072,6 @@ zero_and_one (rtx operand1, rtx operand2)\n \t||((INTVAL (operand1) == 1) && (INTVAL (operand2) == 0)));\n }\n \n-/* Return nonzero if the operand is suitable for use in a conditional move sequence.  */\n-\n-int\n-conditional_move_operand (rtx operand, enum machine_mode mode)\n-{\n-  /* Only defined for simple integers so far...  */\n-  if (mode != SImode && mode != HImode && mode != QImode)\n-    return FALSE;\n-\n-  /* At the moment we can handle moving registers and loading constants.  */\n-  /* To be added: Addition/subtraction/bitops/multiplication of registers.  */\n-\n-  switch (GET_CODE (operand))\n-    {\n-    case REG:\n-      return 1;\n-\n-    case CONST_INT:\n-      return INT8_P (INTVAL (operand));\n-\n-    default:\n-#if 0\n-      fprintf (stderr, \"Test for cond move op of type: %s\\n\",\n-\t       GET_RTX_NAME (GET_CODE (operand)));\n-#endif\n-      return 0;\n-    }\n-}\n-\n-/* Return true if the code is a test of the carry bit.  */\n-\n-int\n-carry_compare_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  rtx x;\n-\n-  if (GET_MODE (op) != CCmode && GET_MODE (op) != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != NE && GET_CODE (op) != EQ)\n-    return FALSE;\n-\n-  x = XEXP (op, 0);\n-  if (GET_CODE (x) != REG || REGNO (x) != CARRY_REGNUM)\n-    return FALSE;\n-\n-  x = XEXP (op, 1);\n-  if (GET_CODE (x) != CONST_INT || INTVAL (x) != 0)\n-    return FALSE;\n-\n-  return TRUE;\n-}\n-\n /* Generate the correct assembler code to handle the conditional loading of a\n    value into a register.  It is known that the operands satisfy the\n    conditional_move_operand() function above.  The destination is operand[0].\n@@ -2583,13 +2178,6 @@ block_move_call (rtx dest_reg, rtx src_reg, rtx bytes_rtx)\n \t\t     TYPE_MODE (sizetype));\n }\n \n-/* The maximum number of bytes to copy using pairs of load/store instructions.\n-   If a block is larger than this then a loop will be generated to copy\n-   MAX_MOVE_BYTES chunks at a time.  The value of 32 is a semi-arbitrary choice.\n-   A customer uses Dhrystome as their benchmark, and Dhrystone has a 31 byte\n-   string copy in it.  */\n-#define MAX_MOVE_BYTES 32\n-\n /* Expand string/block move operations.\n \n    operands[0] is the pointer to the destination.\n@@ -2836,20 +2424,6 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n     }\n }\n \n-/* Return true if op is an integer constant, less than or equal to\n-   MAX_MOVE_BYTES.  */\n-\n-int\n-m32r_block_immediate_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != CONST_INT\n-      || INTVAL (op) > MAX_MOVE_BYTES\n-      || INTVAL (op) <= 0)\n-    return 0;\n-\n-  return 1;\n-}\n-\n /* Return true if using NEW_REG in place of OLD_REG is ok.  */\n \n int"}, {"sha": "82c1564466962fa9685969edfc4c7680d0475775", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, Renesas M32R cpu.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+   2005 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -1740,38 +1740,9 @@ enum m32r_function_type\n \n #define M32R_INTERRUPT_P(TYPE) ((TYPE) == M32R_FUNCTION_INTERRUPT)\n \n-/* Define this if you have defined special-purpose predicates in the\n-   file `MACHINE.c'.  This macro is called within an initializer of an\n-   array of structures.  The first field in the structure is the name\n-   of a predicate and the second field is an array of rtl codes.  For\n-   each predicate, list all rtl codes that can be in expressions\n-   matched by the predicate.  The list should have a trailing comma.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-{ \"reg_or_zero_operand\",        { REG, SUBREG, CONST_INT }},            \\\n-{ \"conditional_move_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n-{ \"carry_compare_operand\",\t{ EQ, NE }},\t\t\t\t\\\n-{ \"eqne_comparison_operator\",\t{ EQ, NE }},\t\t\t\t\\\n-{ \"signed_comparison_operator\", { EQ, NE, LT, LE, GT, GE }},\t\t\\\n-{ \"move_dest_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\t\\\n-{ \"move_src_operand\",\t\t{ REG, SUBREG, MEM, CONST_INT,\t\t\\\n-\t\t\t\t  CONST_DOUBLE, LABEL_REF, CONST,\t\\\n-\t\t\t\t  SYMBOL_REF }},\t\t\t\\\n-{ \"move_double_src_operand\",\t{ REG, SUBREG, MEM, CONST_INT,\t\t\\\n-\t\t\t\t  CONST_DOUBLE }},\t\t\t\\\n-{ \"two_insn_const_operand\",\t{ CONST_INT }},\t\t\t\t\\\n-{ \"symbolic_operand\",\t\t{ SYMBOL_REF, LABEL_REF, CONST }},\t\\\n-{ \"int8_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n-{ \"uint16_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n-{ \"reg_or_int16_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n-{ \"reg_or_uint16_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n-{ \"reg_or_cmp_int16_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n-{ \"reg_or_eq_int16_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n-{ \"cmp_int16_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n-{ \"call_address_operand\",\t{ SYMBOL_REF, LABEL_REF, CONST }},\t\\\n-{ \"extend_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\t\\\n-{ \"small_insn_p\",\t\t{ INSN, CALL_INSN, JUMP_INSN }},\t\\\n-{ \"m32r_block_immediate_operand\",{ CONST_INT }},\t\t\t\\\n-{ \"large_insn_p\",\t\t{ INSN, CALL_INSN, JUMP_INSN }},\t\\\n-{ \"seth_add3_operand\",\t\t{ SYMBOL_REF, LABEL_REF, CONST }},\n-\n+/* The maximum number of bytes to copy using pairs of load/store instructions.\n+   If a block is larger than this then a loop will be generated to copy\n+   MAX_MOVE_BYTES chunks at a time.  The value of 32 is a semi-arbitrary choice.\n+   A customer uses Dhrystome as their benchmark, and Dhrystone has a 31 byte\n+   string copy in it.  */\n+#define MAX_MOVE_BYTES 32"}, {"sha": "6b799709dbab0870bfcde2620c8369851414b68a", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "patch": "@@ -199,6 +199,8 @@\n   \"long_IF,long_E,memory*2\")\n \n \f\n+(include \"predicates.md\")\n+  \n ;; Expand prologue as RTL\n (define_expand \"prologue\"\n   [(const_int 1)]"}, {"sha": "d8561d69e89cc8ad4c4188d7d3eb965f57feed49", "filename": "gcc/config/m32r/predicates.md", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2Fconfig%2Fm32r%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6/gcc%2Fconfig%2Fm32r%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fpredicates.md?ref=22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "patch": "@@ -0,0 +1,442 @@\n+;; Predicate definitions for Renesas M32R.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Return true if OP is a register or the constant 0.\n+\n+(define_predicate \"reg_or_zero_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  return INTVAL (op) == 0;\n+})\n+\n+;; Return nonzero if the operand is suitable for use in a conditional\n+;; move sequence.\n+\n+(define_predicate \"conditional_move_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  /* Only defined for simple integers so far...  */\n+  if (mode != SImode && mode != HImode && mode != QImode)\n+    return FALSE;\n+\n+  /* At the moment we can handle moving registers and loading constants.  */\n+  /* To be added: Addition/subtraction/bitops/multiplication of registers.  */\n+\n+  switch (GET_CODE (op))\n+    {\n+    case REG:\n+      return 1;\n+\n+    case CONST_INT:\n+      return INT8_P (INTVAL (op));\n+\n+    default:\n+#if 0\n+      fprintf (stderr, \"Test for cond move op of type: %s\\n\",\n+\t       GET_RTX_NAME (GET_CODE (op)));\n+#endif\n+      return 0;\n+    }\n+})\n+\n+;; Return true if the code is a test of the carry bit.\n+\n+(define_predicate \"carry_compare_operand\"\n+  (match_code \"eq,ne\")\n+{\n+  rtx x;\n+\n+  if (GET_MODE (op) != CCmode && GET_MODE (op) != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != NE && GET_CODE (op) != EQ)\n+    return FALSE;\n+\n+  x = XEXP (op, 0);\n+  if (GET_CODE (x) != REG || REGNO (x) != CARRY_REGNUM)\n+    return FALSE;\n+\n+  x = XEXP (op, 1);\n+  if (GET_CODE (x) != CONST_INT || INTVAL (x) != 0)\n+    return FALSE;\n+\n+  return TRUE;\n+})\n+\n+;; Return 1 if OP is an EQ or NE comparison operator.\n+\n+(define_predicate \"eqne_comparison_operator\"\n+  (match_code \"eq,ne\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  return (code == EQ || code == NE);\n+})\n+\n+;; Return 1 if OP is a signed comparison operator.\n+\n+(define_predicate \"signed_comparison_operator\"\n+  (match_code \"eq,ne,lt,le,gt,ge\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  return (COMPARISON_P (op)\n+  \t  && (code == EQ || code == NE\n+\t      || code == LT || code == LE || code == GT || code == GE));\n+})\n+\n+;; Return true if OP is an acceptable argument for a move destination.\n+\n+(define_predicate \"move_dest_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case REG :\n+      return register_operand (op, mode);\n+    case SUBREG :\n+      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n+\t pseudo-reg and is now a stack slot.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n+      else\n+\treturn register_operand (op, mode);\n+    case MEM :\n+      if (GET_CODE (XEXP (op, 0)) == POST_INC)\n+\treturn 0;\t\t/* stores can't do post inc */\n+      return address_operand (XEXP (op, 0), mode);\n+    default :\n+      return 0;\n+    }\n+})\n+\n+;; Return true if OP is an acceptable argument for a single word move\n+;; source.\n+\n+(define_predicate \"move_src_operand\"\n+  (match_code \"reg,subreg,mem,const_int,const_double,label_ref,const,symbol_ref\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case LABEL_REF :\n+    case SYMBOL_REF :\n+    case CONST :\n+      return addr24_operand (op, mode);\n+    case CONST_INT :\n+      /* ??? We allow more cse opportunities if we only allow constants\n+\t loadable with one insn, and split the rest into two.  The instances\n+\t where this would help should be rare and the current way is\n+\t simpler.  */\n+      if (HOST_BITS_PER_WIDE_INT > 32)\n+\t{\n+\t  HOST_WIDE_INT rest = INTVAL (op) >> 31;\n+\t  return (rest == 0 || rest == -1);\n+\t}\n+      else\n+\treturn 1;\n+    case CONST_DOUBLE :\n+      if (mode == SFmode)\n+\treturn 1;\n+      else if (mode == SImode)\n+\t{\n+\t  /* Large unsigned constants are represented as const_double's.  */\n+\t  unsigned HOST_WIDE_INT low, high;\n+\n+\t  low = CONST_DOUBLE_LOW (op);\n+\t  high = CONST_DOUBLE_HIGH (op);\n+\t  return high == 0 && low <= (unsigned) 0xffffffff;\n+\t}\n+      else\n+\treturn 0;\n+    case REG :\n+      return register_operand (op, mode);\n+    case SUBREG :\n+      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n+\t pseudo-reg and is now a stack slot.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n+      else\n+\treturn register_operand (op, mode);\n+    case MEM :\n+      if (GET_CODE (XEXP (op, 0)) == PRE_INC\n+\t  || GET_CODE (XEXP (op, 0)) == PRE_DEC)\n+\treturn 0;\t\t/* loads can't do pre-{inc,dec} */\n+      return address_operand (XEXP (op, 0), mode);\n+    default :\n+      return 0;\n+    }\n+})\n+\n+;; Return true if OP is an acceptable argument for a double word move\n+;; source.\n+\n+(define_predicate \"move_double_src_operand\"\n+  (match_code \"reg,subreg,mem,const_int,const_double\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT :\n+    case CONST_DOUBLE :\n+      return 1;\n+    case REG :\n+      return register_operand (op, mode);\n+    case SUBREG :\n+      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n+\t pseudo-reg and is now a stack slot.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn move_double_src_operand (SUBREG_REG (op), mode);\n+      else\n+\treturn register_operand (op, mode);\n+    case MEM :\n+      /* Disallow auto inc/dec for now.  */\n+      if (GET_CODE (XEXP (op, 0)) == PRE_DEC\n+\t  || GET_CODE (XEXP (op, 0)) == PRE_INC)\n+\treturn 0;\n+      return address_operand (XEXP (op, 0), mode);\n+    default :\n+      return 0;\n+    }\n+})\n+\n+;; Return true if OP is a const_int requiring two instructions to\n+;; load.\n+\n+(define_predicate \"two_insn_const_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  if (INT16_P (INTVAL (op))\n+      || UINT24_P (INTVAL (op))\n+      || UPPER16_P (INTVAL (op)))\n+    return 0;\n+  return 1;\n+})\n+\n+;; Returns 1 if OP is a symbol reference.\n+\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"symbol_ref,label_ref,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CONST :\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+})\n+\n+;; Return true if OP is a signed 8 bit immediate value.\n+\n+(define_predicate \"int8_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return INT8_P (INTVAL (op));\n+})\n+\n+;; Return true if OP is an unsigned 16 bit immediate value.\n+\n+(define_predicate \"uint16_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return UINT16_P (INTVAL (op));\n+})\n+\n+;; Return true if OP is a register or signed 16 bit value.\n+\n+(define_predicate \"reg_or_int16_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return INT16_P (INTVAL (op));\n+})\n+\n+;; Return true if OP is a register or an unsigned 16 bit value.\n+\n+(define_predicate \"reg_or_uint16_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return UINT16_P (INTVAL (op));\n+})\n+\n+;; Return true if OP is a register or signed 16 bit value for\n+;; compares.\n+\n+(define_predicate \"reg_or_cmp_int16_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return CMP_INT16_P (INTVAL (op));\n+})\n+\n+;; Return true if OP is a register or an integer value that can be\n+;; used is SEQ/SNE.  We can use either XOR of the value or ADD of the\n+;; negative of the value for the constant.  Don't allow 0, because\n+;; that is special cased.\n+\n+(define_predicate \"reg_or_eq_int16_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  HOST_WIDE_INT value;\n+\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  value = INTVAL (op);\n+  return (value != 0) && (UINT16_P (value) || CMP_INT16_P (-value));\n+})\n+\n+;; Return true if OP is a signed 16 bit immediate value useful in\n+;; comparisons.\n+\n+(define_predicate \"cmp_int16_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return CMP_INT16_P (INTVAL (op));\n+})\n+\n+;; Acceptable arguments to the call insn.\n+\n+(define_predicate \"call_address_operand\"\n+  (match_code \"symbol_ref,label_ref,const\")\n+{\n+  return symbolic_operand (op, mode);\n+\n+/* Constants and values in registers are not OK, because\n+   the m32r BL instruction can only support PC relative branching.  */\n+})\n+\n+;; Return true if OP is an acceptable input argument for a zero/sign\n+;; extend operation.\n+\n+(define_predicate \"extend_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  rtx addr;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case REG :\n+    case SUBREG :\n+      return register_operand (op, mode);\n+\n+    case MEM :\n+      addr = XEXP (op, 0);\n+      if (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)\n+\treturn 0;\t\t/* loads can't do pre inc/pre dec */\n+\n+      return address_operand (addr, mode);\n+\n+    default :\n+      return 0;\n+    }\n+})\n+\n+;; Return nonzero if the operand is an insn that is a small\n+;; insn. Allow const_int 0 as well, which is a placeholder for NOP\n+;; slots.\n+\n+(define_predicate \"small_insn_p\"\n+  (match_code \"insn,call_insn,jump_insn\")\n+{\n+  if (GET_CODE (op) == CONST_INT && INTVAL (op) == 0)\n+    return 1;\n+\n+  if (! INSN_P (op))\n+    return 0;\n+\n+  return get_attr_length (op) == 2;\n+})\n+\n+;; Return true if op is an integer constant, less than or equal to\n+;; MAX_MOVE_BYTES.\n+\n+(define_predicate \"m32r_block_immediate_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_INT\n+      || INTVAL (op) > MAX_MOVE_BYTES\n+      || INTVAL (op) <= 0)\n+    return 0;\n+\n+  return 1;\n+})\n+\n+;; Return nonzero if the operand is an insn that is a large insn.\n+\n+(define_predicate \"large_insn_p\"\n+  (match_code \"insn,call_insn,jump_insn\")\n+{\n+  if (! INSN_P (op))\n+    return 0;\n+\n+  return get_attr_length (op) != 2;\n+})\n+\n+;; Returns 1 if OP is an acceptable operand for seth/add3.\n+\n+(define_predicate \"seth_add3_operand\"\n+  (match_code \"symbol_ref,label_ref,const\")\n+{\n+  if (flag_pic)\n+    return 0;\n+\n+  if (GET_CODE (op) == SYMBOL_REF\n+      || GET_CODE (op) == LABEL_REF)\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+      && INT16_P (INTVAL (XEXP (XEXP (op, 0), 1))))\n+    return 1;\n+\n+  return 0;\n+})"}]}