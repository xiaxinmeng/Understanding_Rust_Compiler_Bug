{"sha": "86d7f2db057abae09db4208bf0578f6e9a0da17b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZkN2YyZGIwNTdhYmFlMDlkYjQyMDhiZjA1NzhmNmU5YTBkYTE3Yg==", "commit": {"author": {"name": "Jan Brittenson", "email": "bson@gnu.org", "date": "1993-09-21T21:25:11Z"}, "committer": {"name": "Jan Brittenson", "email": "bson@gnu.org", "date": "1993-09-21T21:25:11Z"}, "message": "Initial revision\n\nFrom-SVN: r5378", "tree": {"sha": "7eef27115be0e72f2683c69931b5dbb0eed65696", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7eef27115be0e72f2683c69931b5dbb0eed65696"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86d7f2db057abae09db4208bf0578f6e9a0da17b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86d7f2db057abae09db4208bf0578f6e9a0da17b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86d7f2db057abae09db4208bf0578f6e9a0da17b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86d7f2db057abae09db4208bf0578f6e9a0da17b/comments", "author": null, "committer": null, "parents": [{"sha": "e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e72498e1630e39ccb38cc3fcb1d8c7fa240eaec3"}], "stats": {"total": 2357, "additions": 2357, "deletions": 0}, "files": [{"sha": "d820c542c02540ff5db42940f2ffb5f8f11da421", "filename": "gcc/bc-emit.c", "status": "added", "additions": 978, "deletions": 0, "changes": 978, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbc-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbc-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-emit.c?ref=86d7f2db057abae09db4208bf0578f6e9a0da17b", "patch": "@@ -0,0 +1,978 @@\n+/* Output bytecodes for GNU C-compiler.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include <varargs.h>\n+#include <string.h>\n+#include \"config.h\"\n+#include \"machmode.h\"\n+#include \"rtl.h\"\n+#include \"real.h\"\n+#include \"obstack.h\"\n+#include \"bytecode.h\"\n+#include \"bc-emit.h\"\n+#include \"bc-opcode.h\"\n+#include \"bc-typecd.h\"\n+#include \"bi-run.h\"\n+\n+extern char *xmalloc(), *xrealloc();\n+extern void free();\n+\n+extern struct obstack *rtl_obstack;\n+\n+REAL_VALUE_TYPE dconst0;\n+REAL_VALUE_TYPE dconst1;\n+REAL_VALUE_TYPE dconst2;\n+REAL_VALUE_TYPE dconstm1;\n+\n+\n+/* Indexed by mode class, gives the narrowest mode for each class.  */\n+\n+enum machine_mode class_narrowest_mode[(int) MAX_MODE_CLASS];\n+\n+/* Commonly used modes.  */\n+/* Mode whose width is BITS_PER_UNIT */\n+enum machine_mode byte_mode;\n+\n+/* Mode whose width is BITS_PER_WORD */\n+enum machine_mode word_mode;\n+\n+/* Vector indexed by opcode giving info about the args for each opcode. */\n+static struct arityvec arityvec[] = {\n+#include \"bc-arity.h\"\n+};\n+\n+/* How to print a symbol name for the assembler.  */\n+static void\n+prsym (file, s)\n+     FILE *file;\n+     char *s;\n+{\n+  if (*s == '*')\n+    fprintf (file, \"%s\", s + 1);\n+  else\n+\n+#ifdef NAMES_HAVE_UNDERSCORES\n+    fprintf (file, \"_%s\", s);\n+#else\n+    fprintf (file, \"%s\", s);\n+#endif\n+\n+}\n+\n+/* Maintain a bucket hash table for symbol names. */\n+\n+#define HASH_BITS 32\n+#define HASH_SIZE 509\n+\n+static struct bc_sym *hashtab[HASH_SIZE];\n+\n+static unsigned int\n+hash (name)\n+     char *name;\n+{\n+  unsigned int hash = 0;\n+\n+  while (*name)\n+    {\n+      hash = hash << 3 | hash >> HASH_BITS - 3;\n+      hash += *name++;\n+    }\n+\n+  return hash % HASH_SIZE;\n+}\n+\n+\n+/* Look up the named symbol, creating it if it doesn't exist. */\n+static struct bc_sym *\n+sym_lookup (name)\n+     char *name;\n+{\n+  int i;\n+  struct bc_sym *s;\n+\n+  i = hash(name);\n+  for (s = hashtab[i]; s; s = s->next)\n+    if (!strcmp (s->name, name))\n+      return s;\n+\n+  s = (struct bc_sym *) xmalloc (sizeof (struct bc_sym));\n+  s->name = xmalloc (strlen (name) + 1);\n+  strcpy (s->name, name);\n+  s->defined = s->global = s->common = 0;\n+  s->val = 0;\n+  s->next = hashtab[i];\n+  hashtab[i] = s;\n+  return s;\n+}\n+\n+\n+/* Write out .globl and common symbols to the named file.  */\n+static void\n+bc_sym_write (file)\n+     FILE *file;\n+{\n+  int i;\n+  struct bc_sym *s;\n+\n+  for (i = 0; i < HASH_SIZE; ++i)\n+    for (s = hashtab[i]; s; s = s->next)\n+      {\n+\tif (s->global)\n+\t  {\n+\t    fprintf (file, \"\\n\\t.globl \");\n+\t    prsym (file, s->name);\n+\t    putc ('\\n', file);\n+\t    if (s->common)\n+\t      {\n+\t\tfprintf (file, \"\\n\\t.comm \");\n+\t\tprsym (file, s->name);\n+\t\tfprintf (file, \", %d\\n\", s->val);\n+\t      }\n+\t  }\n+\telse if (s->common)\n+\t  {\n+\t    fprintf (file, \"\\n\\t.lcomm \");\n+\t    prsym (file, s->name);\n+\t    fprintf (file, \", %d\\n\", s->val);\n+\t  }\n+      }\n+}\n+\n+\f\n+\n+\n+/* Create and initialize a new segment. */\n+static struct bc_seg *\n+seg_create ()\n+{\n+  struct bc_seg *result;\n+\n+  result = (struct bc_seg *) xmalloc(sizeof (struct bc_seg));\n+  result->alloc = 256;\n+  result->data = xmalloc(result->alloc);\n+  result->size = 0;\n+  result->syms = 0;\n+  result->relocs = 0;\n+  return result;\n+}\n+\n+\n+/* Advance the segment index to the next alignment boundary. */\n+static void\n+seg_align (seg, log)\n+     struct bc_seg *seg;\n+     int log;\n+{\n+  unsigned int oldsize = seg->size;\n+\n+  seg->size = seg->size + (1 << log) - 1 & ~((1 << log) - 1);\n+  if (seg->size > seg->alloc)\n+    {\n+      while (seg->size > seg->alloc)\n+\tseg->alloc *= 2;\n+      seg->data = xrealloc(seg->data, seg->alloc);\n+    }\n+  memset(seg->data + oldsize, 0, seg->size - oldsize);\n+}\n+\n+\n+/* Append the given data to the given segment. */\n+static void\n+seg_data (seg, data, size)\n+     struct bc_seg *seg;\n+     char *data;\n+     unsigned int size;\n+{\n+  if (seg->size + size > seg->alloc)\n+    {\n+      while (seg->size + size > seg->alloc)\n+\tseg->alloc *= 2;\n+      seg->data = xrealloc (seg->data, seg->alloc);\n+    }\n+\n+  memcpy (seg->data + seg->size, data, size);\n+  seg->size += size;\n+}\n+\n+\n+/* Append a zero-filled skip to the given segment.  */\n+static void\n+seg_skip (seg, size)\n+     struct bc_seg *seg;\n+     unsigned int size;\n+{\n+  if (seg->size + size > seg->alloc)\n+    {\n+      while (seg->size + size > seg->alloc)\n+\tseg->alloc *= 2;\n+      seg->data = xrealloc (seg->data, seg->alloc);\n+    }\n+\n+  memset (seg->data + seg->size, 0, size);\n+  seg->size += size;\n+}\n+\n+\n+/* Define the given name as the current offset in the given segment.  It\n+   is an error if the name is already defined.  Return 0 or 1 indicating\n+   failure or success respectively. */\n+static int\n+seg_defsym (seg, name)\n+     struct bc_seg *seg;\n+     char *name;\n+{\n+  struct bc_sym *sym;\n+  struct bc_segsym *segsym;\n+\n+  sym = sym_lookup(name);\n+  if (sym->defined)\n+    return 0;\n+\n+  sym->defined = 1;\n+  sym->val = seg->size;\n+  segsym = (struct bc_segsym *) xmalloc(sizeof (struct bc_segsym));\n+  segsym->sym = sym;\n+  segsym->next = seg->syms;\n+  seg->syms = segsym;\n+  return 1;\n+}\n+\n+\n+/* Generate in seg's data a reference to the given sym, adjusted by\n+   the given offset. */\n+static void\n+seg_refsym (seg, name, offset)\n+     struct bc_seg *seg;\n+     char *name;\n+     int offset;\n+{\n+  struct bc_sym *sym;\n+  struct bc_segreloc *segreloc;\n+\n+  sym = sym_lookup(name);\n+  segreloc = (struct bc_segreloc *) xmalloc(sizeof (struct bc_segreloc));\n+  segreloc->offset = seg->size;\n+  segreloc->sym = sym;\n+  segreloc->next = seg->relocs;\n+  seg->relocs = segreloc;\n+  seg_data(seg, (char *) &offset, sizeof offset);\n+}\n+\n+\n+/* Concatenate the contents of given segments into the first argument. */\n+static void\n+seg_concat (result, seg)\n+     struct bc_seg *result, *seg;\n+{\n+  unsigned int fix;\n+  struct bc_segsym *segsym;\n+  struct bc_segreloc *segreloc;\n+\n+  seg_align(result, MACHINE_SEG_ALIGN);\n+  fix = result->size;\n+  seg_data(result, seg->data, seg->size);\n+  free(seg->data);\n+\n+  /* Go through the symbols and relocs of SEG, adjusting their offsets\n+     for their new location in RESULT. */\n+  if (seg->syms)\n+    {\n+      segsym = seg->syms;\n+      do\n+\tsegsym->sym->val += fix;\n+      while (segsym->next && (segsym = segsym->next));\n+      segsym->next = result->syms;\n+      result->syms = seg->syms;\n+    }\n+  if (seg->relocs)\n+    {\n+      segreloc = seg->relocs;\n+      do\n+\tsegreloc->offset += fix;\n+      while (segreloc->next && (segreloc = segreloc->next));\n+      segreloc->next = result->relocs;\n+      result->relocs = seg->relocs;\n+    }\n+\n+  free((char *) seg);\n+}\n+\n+/* Write a segment to a file.  */\n+static void\n+bc_seg_write (seg, file)\n+     struct bc_seg *seg;\n+     FILE *file;\n+{\n+  struct bc_segsym *segsym, *nsegsym, *psegsym;\n+  struct bc_segreloc *segreloc, *nsegreloc, *psegreloc;\n+  int i, offset, flag;\n+\n+  /* Reverse the list of symbols.  */\n+  for (psegsym = 0, segsym = seg->syms; segsym; segsym = nsegsym)\n+    {\n+      nsegsym = segsym->next;\n+      segsym->next = psegsym;\n+      psegsym = segsym;\n+    }\n+  seg->syms = psegsym;\n+\n+  /* Reverse the list of relocs.  */\n+  for (psegreloc = 0, segreloc = seg->relocs; segreloc; segreloc = nsegreloc)\n+    {\n+      nsegreloc = segreloc->next;\n+      segreloc->next = psegreloc;\n+      psegreloc = segreloc;\n+    }\n+  seg->relocs = psegreloc;\n+\n+  /* Output each byte of the segment.  */\n+  for (i = 0, segsym = seg->syms, segreloc = seg->relocs; i < seg->size; ++i)\n+    {\n+      while (segsym && segsym->sym->val == i)\n+\t{\n+\t  if (i % 8 != 0)\n+\t    putc('\\n', file);\n+\n+\t  BC_WRITE_SEGSYM (segsym, file);\n+\t  segsym = segsym->next;\n+\t  flag = 1;\n+\t}\n+      if (segreloc && segreloc->offset == i)\n+\t{\n+\t  if (i % 8 != 0)\n+\t    putc ('\\n', file);\n+\n+\t  offset = *(int *) (seg->data + i);\n+\t  i += sizeof (int) - 1;\n+\n+\t  BC_WRITE_RELOC_ENTRY (segreloc, file, offset);\n+\t  segreloc = segreloc->next;\n+\t  flag = 1;\n+\t}\n+      else\n+\t{\n+\t  if (i % 8 == 0 || flag)\n+\t    BC_START_BYTECODE_LINE (file);\n+\n+\t  BC_WRITE_BYTECODE (i % 8 == 0 || flag ? ' ' : ',',\n+\t\t\t     seg->data[i] & 0xFF,\n+\t\t\t     file);\n+\t  flag = 0;\n+\t  if (i % 8 == 7)\n+\t    putc ('\\n', file);\n+\t}\n+    }\n+\n+  /* Paranoia check--we should have visited all syms and relocs during\n+     the output pass.  */\n+\n+  if (segsym || segreloc)\n+    abort ();\n+}\n+\n+\f\n+\n+/* Text and data segments of the object file in making. */\n+static struct bc_seg *bc_text_seg;\n+static struct bc_seg *bc_data_seg;\n+\n+/* Called before anything else in this module. */\n+void\n+bc_initialize ()\n+{\n+  int min_class_size[(int) MAX_MODE_CLASS];\n+  enum machine_mode mode;\n+  int i;\n+\n+  bc_init_mode_to_code_map ();\n+\n+  bc_text_seg = seg_create ();\n+  bc_data_seg = seg_create ();\n+\n+  dconst0 = REAL_VALUE_ATOF (\"0\");\n+  dconst1 = REAL_VALUE_ATOF (\"1\");\n+  dconst2 = REAL_VALUE_ATOF (\"2\");\n+  dconstm1 = REAL_VALUE_ATOF (\"-1\");\n+\n+  /* Find the narrowest mode for each class and compute the word and byte\n+     modes.  */\n+\n+  for (i = 0; i < (int) MAX_MODE_CLASS; i++)\n+    min_class_size[i] = 1000;\n+\n+  for (mode = VOIDmode; (int) mode < (int) MAX_MACHINE_MODE;\n+       mode = (enum machine_mode) ((int) mode + 1))\n+    {\n+      if (GET_MODE_SIZE (mode) < min_class_size[(int) GET_MODE_CLASS (mode)])\n+\t{\n+\t  class_narrowest_mode[(int) GET_MODE_CLASS (mode)] = mode;\n+\t  min_class_size[(int) GET_MODE_CLASS (mode)] = GET_MODE_SIZE (mode);\n+\t}\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_MODE_BITSIZE (mode) == BITS_PER_UNIT)\n+\tbyte_mode = mode;\n+\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_MODE_BITSIZE (mode) == BITS_PER_WORD)\n+\tword_mode = mode;\n+    }\n+}\n+\n+\n+/* External addresses referenced in a function.  Rather than trying to\n+   work relocatable address directly into bytecoded functions (which would\n+   require us to provide hairy location info and possibly obey alignment\n+   rules imposed by the architecture) we build an auxilary table of\n+   pointer constants, and encode just offsets into this table into the\n+   actual bytecode. */\n+static struct bc_seg *ptrconsts;\n+\n+/* Trampoline code for the function entry.  */\n+struct bc_seg *trampoline;\n+\n+/* Actual byte code of the function. */\n+struct bc_seg *bytecode;\n+\n+/* List of labels defined in the function. */\n+struct bc_label *labels;\n+\n+/* List of label references in the function. */\n+struct bc_labelref *labelrefs;\n+\n+\n+/* Add symbol to pointer table.  Return offset into table where\n+   pointer was stored.  The offset usually goes into the bytecode\n+   stream as a constP literal. */\n+int\n+bc_define_pointer (p)\n+     char *p;\n+{\n+  int offset = ptrconsts->size;\n+\n+  seg_refsym (ptrconsts, p, 0);\n+  return offset;\n+}\n+\n+\n+/* Begin a bytecoded function.  */\n+int\n+bc_begin_function (name)\n+    char *name;\n+{\n+  ptrconsts = seg_create ();\n+  trampoline = seg_create ();\n+  bytecode = seg_create ();\n+  return seg_defsym (trampoline, name);\n+}\n+\n+\n+/* Force alignment in inline bytecode.  */\n+void\n+bc_align_bytecode (align)\n+    int align;\n+{\n+  seg_align (bytecode, align);\n+}\n+\n+\n+/* Emit data inline into bytecode.  */\n+void\n+bc_emit_bytecode_const (data, size)\n+     char *data;\n+     unsigned int size;\n+{\n+  if (bytecode)\n+    seg_data (bytecode, data, size);\n+}\n+\n+\n+/* Create a new \"bytecode label\", to have its value defined later.\n+   Bytecode labels have nothing to do with the object file symbol table,\n+   and are purely local to a given bytecoded function. */\n+struct bc_label *\n+bc_get_bytecode_label ()\n+{\n+  struct bc_label *result;\n+\n+  result = (struct bc_label *) xmalloc (sizeof (struct bc_label));\n+  result->defined = 0;\n+  result->next = labels;\n+  result->uid = 0;\n+  labels = result;\n+  return result;\n+}\n+\n+\n+/* Define the given label with the current location counter. */\n+int\n+bc_emit_bytecode_labeldef (label)\n+     struct bc_label *label;\n+{\n+  extern int bc_new_uid ();\n+\n+  if (!label || label->defined)\n+    return 0;\n+\n+  label->offset = bytecode->size;\n+  label->defined = 1;\n+  label->uid = bc_new_uid ();\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fprintf (stderr, \"$%lx:\\n\", label);\n+#endif\n+\n+  return 1;\n+}\n+\n+\n+/* Generate a location-relative reference to the given bytecode label.\n+   It need not be defined yet; label references will be backpatched later. */\n+void\n+bc_emit_bytecode_labelref (label)\n+     struct bc_label *label;\n+{\n+  struct bc_labelref *labelref;\n+  static int zero;\n+\n+  labelref = (struct bc_labelref *) xmalloc (sizeof (struct bc_labelref));\n+  labelref->label = label;\n+  labelref->offset = bytecode->size;\n+  labelref->next = labelrefs;\n+  labelrefs = labelref;\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fprintf (stderr, \" $%lx\", label);\n+#endif\n+\n+  seg_data (bytecode, (char *) &zero, sizeof zero);\n+}\n+\n+\n+/* Emit a reference to an external address; generate the reference in the\n+   ptrconst area, and emit an offset in the bytecode. */\n+void\n+bc_emit_code_labelref (name, offset)\n+     char *name;\n+     int offset;\n+{\n+  int ptroff;\n+\n+  ptroff = ptrconsts->size / sizeof (char *);\n+  seg_data (bytecode, (char *) &ptroff, sizeof ptroff);\n+  seg_refsym (ptrconsts, name, offset);\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fprintf (stderr, \" [external <%x> %s]\", ptroff, name);\n+#endif\n+}\n+\n+\n+/* Backpatch label references in the byte code, and concatenate the bytecode\n+   and pointer constant segments to the cumulative text for the object file.\n+   Return a label name for the pointer constants region.  */\n+char *\n+bc_end_function ()\n+{\n+  int addr;\n+  struct bc_label *label, *next;\n+  struct bc_labelref *ref, *nextref;\n+  char ptrconsts_label[20];\n+  static int nlab;\n+\n+  /* Backpatch bytecode label references. */\n+  for (ref = labelrefs; ref; ref = ref->next)\n+    if (ref->label->defined)\n+      {\n+\taddr = ref->label->offset;\n+\tmemcpy (bytecode->data + ref->offset, /* incest */\n+\t\t(char *) &addr, sizeof addr);\n+      }\n+\n+  /* Free the chains of labelrefs and labeldefs. */\n+  for (ref = labelrefs; ref; ref = nextref)\n+    {\n+      nextref = ref->next;\n+      free ((char *) ref);\n+    }\n+\n+  for (label = labels; label; label = next)\n+    {\n+      next = label->next;\n+      free ((char *) label);\n+    }\n+\n+  seg_concat (trampoline, bytecode);\n+  seg_align (trampoline, MACHINE_SEG_ALIGN);\n+  sprintf (ptrconsts_label, \"*LP%d\", nlab++);\n+  seg_defsym (trampoline, ptrconsts_label);\n+  seg_concat (trampoline, ptrconsts);\n+  seg_concat (bc_text_seg, trampoline);\n+\n+  labels = 0;\n+  labelrefs = 0;\n+  trampoline = 0;\n+  bytecode = 0;\n+  ptrconsts = 0;\n+\n+  return sym_lookup (ptrconsts_label)->name;\n+}\n+\n+/* Force alignment in const data. */\n+void\n+bc_align_const (align)\n+     int align;\n+{\n+  seg_align (bc_text_seg, align);\n+}\n+\n+/* Emit const data. */\n+void\n+bc_emit_const (data, size)\n+     char *data;\n+     unsigned int size;\n+{\n+  seg_data (bc_text_seg, data, size);\n+}\n+\n+/* Emit a zero-filled constant skip. */\n+void\n+bc_emit_const_skip (size)\n+     unsigned int size;\n+{\n+  seg_skip (bc_text_seg, size);\n+}\n+\n+/* Emit a label definition in const data. */\n+int\n+bc_emit_const_labeldef (name)\n+     char *name;\n+{\n+  return seg_defsym (bc_text_seg, name);\n+}\n+\n+/* Emit a label reference in const data. */\n+void\n+bc_emit_const_labelref (name, offset)\n+     char *name;\n+     int offset;\n+{\n+  seg_refsym (bc_text_seg, name, offset);\n+}\n+\n+/* Force alignment in data. */\n+void\n+bc_align_data (align)\n+     int align;\n+{\n+  seg_align (bc_data_seg, align);\n+}\n+\n+/* Emit data. */\n+void\n+bc_emit_data(data, size)\n+     char *data;\n+     unsigned int size;\n+{\n+  seg_data (bc_data_seg, data, size);\n+}\n+\n+/* Emit a zero-filled data skip.  */\n+void\n+bc_emit_data_skip (size)\n+     unsigned int size;\n+{\n+  seg_skip(bc_data_seg, size);\n+}\n+\n+/* Emit label definition in data. */\n+int\n+bc_emit_data_labeldef(name)\n+     char *name;\n+{\n+  return seg_defsym(bc_data_seg, name);\n+}\n+\n+/* Emit label reference in data. */\n+void\n+bc_emit_data_labelref(name, offset)\n+     char *name;\n+     int offset;\n+{\n+  seg_refsym(bc_data_seg, name, offset);\n+}\n+\n+/* Emit a common block of the given name and size.  Note that\n+   when the .o file is actually written non-global \"common\"\n+   blocks will have to be turned into space in the data section.  */\n+int\n+bc_emit_common(name, size)\n+     char *name;\n+     unsigned int size;\n+{\n+  struct bc_sym *sym;\n+\n+  sym = sym_lookup(name);\n+  if (sym->defined)\n+    return 0;\n+\n+  sym->defined = 1;\n+  sym->common = 1;\n+  sym->val = size;\n+  return 1;\n+}\n+\n+/* Globalize the given label. */\n+void\n+bc_globalize_label(name)\n+     char *name;\n+{\n+  struct bc_sym *sym;\n+\n+  sym = sym_lookup(name);\n+  sym->global = 1;\n+}\n+\n+static enum { in_text, in_data } section = in_text;\n+\n+void\n+bc_text ()\n+{\n+  section = in_text;\n+}\n+\n+void\n+bc_data ()\n+{\n+  section = in_data;\n+}\n+\n+void\n+bc_align (align)\n+     int align;\n+{\n+  if (section == in_text)\n+    bc_align_const (align);\n+  else\n+    bc_align_data (align);\n+}\n+\n+void\n+bc_emit (data, size)\n+     char *data;\n+     unsigned int size;\n+{\n+  if (section == in_text)\n+    bc_emit_const (data, size);\n+  else\n+    bc_emit_data (data, size);\n+}\n+\n+void\n+bc_emit_skip (size)\n+     unsigned int size;\n+{\n+  if (section == in_text)\n+    bc_emit_const_skip (size);\n+  else\n+    bc_emit_data_skip (size);\n+}\n+\n+int\n+bc_emit_labeldef (name)\n+     char *name;\n+{\n+  if (section == in_text)\n+    return bc_emit_const_labeldef (name);\n+  else\n+    return bc_emit_data_labeldef (name);\n+}\n+\n+void\n+bc_emit_labelref (name, offset)\n+     char *name;\n+     int offset;\n+{\n+  if (section == in_text)\n+    bc_emit_const_labelref (name, offset);\n+  else\n+    bc_emit_data_labelref (name, offset);\n+}\n+\n+void\n+bc_write_file (file)\n+     FILE *file;\n+{\n+  BC_WRITE_FILE (file);\n+}\n+\n+\n+/* Allocate a new bytecode rtx. */\n+rtx\n+bc_gen_rtx (label, offset, bc_label)\n+     char *label;\n+     int offset;\n+     struct bc_label *bc_label;\n+{\n+  rtx r;\n+\n+  r = (rtx) obstack_alloc (rtl_obstack, sizeof (struct rtx_def));\n+  r->label = label;\t\t/* FIXME: Do we need to copy here?  */\n+  r->offset = offset;\n+  r->bc_label = bc_label;\n+  return r;\n+}\n+\n+\n+/* Print bytecode rtx */\n+void\n+bc_print_rtl (fp, r)\n+     FILE *fp;\n+     rtx r;\n+{\n+  BC_WRITE_RTL (r, fp);\n+}\n+\n+\n+/* Emit a bytecode, keeping a running tally of the stack depth.  */\n+void\n+bc_emit_bytecode (bytecode)\n+     enum bytecode_opcode bytecode;\n+{\n+  char byte;\n+  int npushes = arityvec[bytecode].noutputs - arityvec[bytecode].ninputs;\n+  static int prev_lineno = -1;\n+\n+  byte = bytecode;\n+\n+#ifdef BCDEBUG_PRINT_CODE\n+  if (lineno != prev_lineno)\n+    {\n+      fprintf (stderr, \"<line %d>\\n\", lineno);\n+      prev_lineno = lineno;\n+    }\n+\n+  fputs (opcode_name[(unsigned int) bytecode], stderr);\n+#endif\n+\n+  /* Due to errors we are often requested to output bytecodes that\n+     will cause an interpreter stack undeflow when executed.  Instead of\n+     dumping core on such occasions, we omit the bytecode.  Erroneous code\n+     should not be executed, regardless.  This makes life much easier, since\n+     we don't have to deceive ourselves about the known stack depth. */\n+\n+  bc_emit_bytecode_const (&byte, 1);\n+\n+  if ((stack_depth -= arityvec[bytecode].ninputs) >= 0)\n+    {\n+      if ((stack_depth += arityvec[bytecode].noutputs) > max_stack_depth)\n+\tmax_stack_depth = stack_depth;\n+    }\n+\n+#ifdef VALIDATE_STACK\n+  VALIDATE_STACK ();\n+#endif\n+}\n+\n+\n+#ifdef BCDEBUG_PRINT_CODE\n+#define PRLIT(TYPE, PTR)  fprintf (stderr, \" [%x]\", *(TYPE *) PTR)\n+#else\n+#define PRLIT(X,Y)\n+#endif\n+\n+/* Emit a complete bytecode instruction, expecting the correct number\n+   of literal values in the call.  First argument is the instruction, the\n+   remaining arguments are literals of size HOST_WIDE_INT or smaller. */\n+void\n+bc_emit_instruction (va_alist)\n+     va_dcl\n+{\n+  va_list arguments;\n+  enum bytecode_opcode opcode;\n+  int nliteral, instruction;\n+\n+\n+  va_start (arguments);\n+\n+  /* Emit instruction bytecode */\n+  opcode = va_arg (arguments, enum bytecode_opcode);\n+  bc_emit_bytecode (opcode);\n+  instruction = (int) opcode;\n+\n+  /* Loop literals and emit as bytecode constants */\n+  for (nliteral = 0; nliteral < arityvec[instruction].nliterals; nliteral++)\n+    {\n+      HOST_WIDE_INT literal;\n+\n+      switch (arityvec[instruction].literals[nliteral])\n+\t{\n+\t  /* Expand definitions into case statements */\n+#define DEFTYPECODE(CODE, NAME, MODE, TYPE)\t\t\t\t\\\n+\tcase CODE:\t\t\t\t\t\t\t\\\n+\t  { TYPE temp = va_arg (arguments, TYPE); \t\t\t\\\n+\t    bc_emit_bytecode_const ((void *) &temp, sizeof temp); \t\\\n+\t    PRLIT (TYPE, &temp); }\t\t\t\t\t\\\n+\t  break;\n+\n+#include \"bc-typecd.def\"\n+\n+#undef DEFTYPECODE\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n+#ifdef BCDEBUG_PRINT_CODE\n+  fputc ('\\n', stderr);\n+#endif\n+}\n+\f\n+/* Emit the machine-code interface trampoline at the beginning of a byte\n+   coded function.  The argument is a label name of the interpreter\n+   bytecode callinfo structure; the return value is a label name for\n+   the beginning of the actual bytecode.  */\n+char *\n+bc_emit_trampoline (callinfo)\n+     char *callinfo;\n+{\n+  char mylab[20];\n+  static int n;\n+\n+  sprintf (mylab, \"*LB%d\", n++);\n+  \n+  BC_EMIT_TRAMPOLINE (trampoline, callinfo);\n+\n+  seg_defsym (bytecode, mylab);\n+  return sym_lookup (mylab)->name;\n+}\n+\n+\n+/* Simple strdup */\n+char *\n+bc_xstrdup (str)\n+     char *str;\n+{\n+  char *tmp = xmalloc (strlen (str) + 1);\n+\n+  strcpy (tmp, str);\n+  return tmp;\n+}"}, {"sha": "57771fcdc25caf2d1d95fc052254c88d0a31b267", "filename": "gcc/bc-optab.c", "status": "added", "additions": 786, "deletions": 0, "changes": 786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbc-optab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbc-optab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-optab.c?ref=86d7f2db057abae09db4208bf0578f6e9a0da17b", "patch": "@@ -0,0 +1,786 @@\n+/* Bytecode conversion definitions for GNU C-compiler.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"machmode.h\"\n+#include \"obstack.h\"\n+#include \"bytecode.h\"\n+#include \"bc-typecd.h\"\n+#include \"bc-opcode.h\"\n+#include \"bc-optab.h\"\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern char *xmalloc ();\n+extern void free ();\n+\n+/* Table relating interpreter typecodes to machine modes.  */\n+#define GET_TYPECODE_MODE(CODE) (typecode_mode[((int) CODE)])\n+enum machine_mode typecode_mode[] = {\n+#define DEFTYPECODE(CODE, NAME, MODE, TYPE) MODE,\n+#include \"bc-typecd.def\"\n+#undef DEFTYPECODE\n+};\n+\n+/* Machine mode to type code map */\n+static enum typecode signed_mode_to_code_map[MAX_MACHINE_MODE+1];\n+static enum typecode unsigned_mode_to_code_map[MAX_MACHINE_MODE+1];\n+\n+#define GET_TYPECODE_SIZE(CODE) GET_MODE_SIZE (GET_TYPECODE_MODE (CODE))\n+\n+#define BIG_ARBITRARY_NUMBER 100000\n+\n+/* Table of recipes for conversions among scalar types, to be filled\n+   in as needed at run time.  */\n+static struct conversion_recipe\n+{\n+  unsigned char *opcodes;\t/* Bytecodes to emit in order.  */\n+  int nopcodes;\t\t\t/* Count of bytecodes. */\n+  int cost;\t\t\t/* A rather arbitrary cost function. */\n+} conversion_recipe[NUM_TYPECODES][NUM_TYPECODES];\n+\n+/* Binary operator tables.  */\n+struct binary_operator optab_plus_expr[] = {\n+  { addSI, SIcode, SIcode, SIcode },\n+  { addDI, DIcode, DIcode, DIcode },\n+  { addSF, SFcode, SFcode, SFcode },\n+  { addDF, DFcode, DFcode, DFcode },\n+  { addXF, XFcode, XFcode, XFcode },\n+  { addPSI, Pcode, Pcode, SIcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_minus_expr[] = {\n+  { subSI, SIcode, SIcode, SIcode },\n+  { subDI, DIcode, DIcode, DIcode },\n+  { subSF, SFcode, SFcode, SFcode },\n+  { subDF, DFcode, DFcode, DFcode },\n+  { subXF, XFcode, XFcode, XFcode },\n+  { subPP, SIcode, Pcode, Pcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+/* The ordering of the tables for multiplicative operators\n+   is such that unsigned operations will be preferred to signed\n+   operations when one argument is unsigned.  */\n+\n+struct binary_operator optab_mult_expr[] = {\n+  { mulSU, SUcode, SUcode, SUcode },\n+  { mulDU, DUcode, DUcode, DUcode },\n+  { mulSI, SIcode, SIcode, SIcode },\n+  { mulDI, DIcode, DIcode, DIcode },\n+  { mulSF, SFcode, SFcode, SFcode },\n+  { mulDF, DFcode, DFcode, DFcode },\n+  { mulXF, XFcode, XFcode, XFcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_trunc_div_expr[] = {\n+  { divSU, SUcode, SUcode, SUcode },\n+  { divDU, DUcode, DUcode, DUcode },\n+  { divSI, SIcode, SIcode, SIcode },\n+  { divDI, DIcode, DIcode, DIcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_trunc_mod_expr[] = {\n+  { modSU, SUcode, SUcode, SUcode },\n+  { modDU, DUcode, DUcode, DUcode },\n+  { modSI, SIcode, SIcode, SIcode },\n+  { modDI, DIcode, DIcode, DIcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_rdiv_expr[] = {\n+  { divSF, SFcode, SFcode, SFcode },\n+  { divDF, DFcode, DFcode, DFcode },\n+  { divXF, XFcode, XFcode, XFcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_bit_and_expr[] = {\n+  { andSI, SIcode, SIcode, SIcode },\n+  { andDI, DIcode, DIcode, DIcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_bit_ior_expr[] = {\n+  { iorSI, SIcode, SIcode, SIcode },\n+  { iorDI, DIcode, DIcode, DIcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_bit_xor_expr[] = {\n+  { xorSI, SIcode, SIcode, SIcode },\n+  { xorDI, DIcode, DIcode, DIcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_lshift_expr[] = {\n+  { lshiftSI, SIcode, SIcode, SIcode },\n+  { lshiftSU, SUcode, SUcode, SIcode },\n+  { lshiftDI, DIcode, DIcode, SIcode },\n+  { lshiftDU, DUcode, DUcode, SIcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_rshift_expr[] = {\n+  { rshiftSI, SIcode, SIcode, SIcode },\n+  { rshiftSU, SUcode, SUcode, SIcode },\n+  { rshiftDI, DIcode, DIcode, SIcode },\n+  { rshiftDU, DUcode, DUcode, SIcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_truth_and_expr[] = {\n+  { andSI, SIcode, Tcode, Tcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_truth_or_expr[] = {\n+  { iorSI, SIcode, Tcode, Tcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_lt_expr[] = {\n+  { ltSI, Tcode, SIcode, SIcode },\n+  { ltSU, Tcode, SUcode, SUcode },\n+  { ltDI, Tcode, DIcode, DIcode },\n+  { ltDU, Tcode, DUcode, DUcode },\n+  { ltSF, Tcode, SFcode, SFcode },\n+  { ltDF, Tcode, DFcode, DFcode },\n+  { ltXF, Tcode, XFcode, XFcode },\n+  { ltP, Tcode, Pcode, Pcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_le_expr[] = {\n+  { leSI, Tcode, SIcode, SIcode },\n+  { leSU, Tcode, SUcode, SUcode },\n+  { leDI, Tcode, DIcode, DIcode },\n+  { leDU, Tcode, DUcode, DUcode },\n+  { leSF, Tcode, SFcode, SFcode },\n+  { leDF, Tcode, DFcode, DFcode },\n+  { leXF, Tcode, XFcode, XFcode },\n+  { leP, Tcode, Pcode, Pcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_ge_expr[] = {\n+  { geSI, Tcode, SIcode, SIcode },\n+  { geSU, Tcode, SUcode, SUcode },\n+  { geDI, Tcode, DIcode, DIcode },\n+  { geDU, Tcode, DUcode, DUcode },\n+  { geSF, Tcode, SFcode, SFcode },\n+  { geDF, Tcode, DFcode, DFcode },\n+  { geXF, Tcode, XFcode, XFcode },\n+  { geP, Tcode, Pcode, Pcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_gt_expr[] = {\n+  { gtSI, Tcode, SIcode, SIcode },\n+  { gtSU, Tcode, SUcode, SUcode },\n+  { gtDI, Tcode, DIcode, DIcode },\n+  { gtDU, Tcode, DUcode, DUcode },\n+  { gtSF, Tcode, SFcode, SFcode },\n+  { gtDF, Tcode, DFcode, DFcode },\n+  { gtXF, Tcode, XFcode, XFcode },\n+  { gtP, Tcode, Pcode, Pcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_eq_expr[] = {\n+  { eqSI, Tcode, SIcode, SIcode },\n+  { eqDI, Tcode, DIcode, DIcode },\n+  { eqSF, Tcode, SFcode, SFcode },\n+  { eqDF, Tcode, DFcode, DFcode },\n+  { eqXF, Tcode, XFcode, XFcode },\n+  { eqP, Tcode, Pcode, Pcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+struct binary_operator optab_ne_expr[] = {\n+  { neSI, Tcode, SIcode, SIcode },\n+  { neDI, Tcode, DIcode, DIcode },\n+  { neSF, Tcode, SFcode, SFcode },\n+  { neDF, Tcode, DFcode, DFcode },\n+  { neXF, Tcode, XFcode, XFcode },\n+  { neP, Tcode, Pcode, Pcode },\n+  { -1, -1, -1, -1 },\n+};\n+\n+/* Unary operator tables.  */\n+struct unary_operator optab_negate_expr[] = {\n+  { negSI, SIcode, SIcode },\n+  { negDI, DIcode, DIcode },\n+  { negSF, SFcode, SFcode },\n+  { negDF, DFcode, DFcode },\n+  { negXF, XFcode, XFcode },\n+  { -1, -1, -1 },\n+};\n+\n+struct unary_operator optab_bit_not_expr[] = {\n+  { notSI, SIcode, SIcode },\n+  { notDI, DIcode, DIcode },\n+  { -1, -1, -1 },\n+};\n+\n+struct unary_operator optab_truth_not_expr[] = {\n+  { notT, SIcode, SIcode },\n+  { -1, -1, -1 },\n+};\n+\n+/* Increment operator tables.  */\n+struct increment_operator optab_predecrement_expr[] = {\n+  { predecQI, QIcode },\n+  { predecQI, QUcode },\n+  { predecHI, HIcode },\n+  { predecHI, HUcode },\n+  { predecSI, SIcode },\n+  { predecSI, SUcode },\n+  { predecDI, DIcode },\n+  { predecDI, DUcode },\n+  { predecP, Pcode },\n+  { predecSF, SFcode },\n+  { predecDF, DFcode },\n+  { predecXF, XFcode },\n+  { -1, -1 },\n+};\n+\n+struct increment_operator optab_preincrement_expr[] = {\n+  { preincQI, QIcode },\n+  { preincQI, QUcode },\n+  { preincHI, HIcode },\n+  { preincHI, HUcode },\n+  { preincSI, SIcode },\n+  { preincSI, SUcode },\n+  { preincDI, DIcode },\n+  { preincDI, DUcode },\n+  { preincP, Pcode },\n+  { preincSF, SFcode },\n+  { preincDF, DFcode },\n+  { preincXF, XFcode },\n+  { -1, -1 },\n+};\n+\n+struct increment_operator optab_postdecrement_expr[] = {\n+  { postdecQI, QIcode },\n+  { postdecQI, QUcode },\n+  { postdecHI, HIcode },\n+  { postdecHI, HUcode },\n+  { postdecSI, SIcode },\n+  { postdecSI, SUcode },\n+  { postdecDI, DIcode },\n+  { postdecDI, DUcode },\n+  { postdecP, Pcode },\n+  { postdecSF, SFcode },\n+  { postdecDF, DFcode },\n+  { postdecXF, XFcode },\n+  { -1, -1 },\n+};\n+\n+struct increment_operator optab_postincrement_expr[] = {\n+  { postincQI, QIcode },\n+  { postincQI, QUcode },\n+  { postincHI, HIcode },\n+  { postincHI, HUcode },\n+  { postincSI, SIcode },\n+  { postincSI, SUcode },\n+  { postincDI, DIcode },\n+  { postincDI, DUcode },\n+  { postincP, Pcode },\n+  { postincSF, SFcode },\n+  { postincDF, DFcode },\n+  { postincXF, XFcode },\n+  { -1, -1 },\n+};\n+\n+/* Table of conversions supported by the interpreter.  */\n+static struct conversion_info\n+{\n+  enum bytecode_opcode opcode;\t/*  here indicates the conversion needs no opcode.  */\n+  enum typecode from;\n+  enum typecode to;\n+  int cost;\t\t\t/* 1 for no-op conversions, 2 for widening conversions,\n+\t\t\t\t   4 for int/float conversions, 8 for narrowing conversions.  */\n+} conversion_info[] = {\n+  { -1, QIcode, QUcode, 1 },\n+  { -1, HIcode, HUcode, 1 },\n+  { -1, SIcode, SUcode, 1 },\n+  { -1, DIcode, DUcode, 1 },\n+  { -1, QUcode, QIcode, 1 },\n+  { -1, HUcode, HIcode, 1 },\n+  { -1, SUcode, SIcode, 1 },\n+  { -1, DUcode, DIcode, 1 },\n+  { -1, Tcode, SIcode, 1 },\n+  { convertQIHI, QIcode, HIcode, 2 },\n+  { convertQUHU, QUcode, HUcode, 2 },\n+  { convertQUSU, QUcode, SUcode, 2 },\n+  { convertHISI, HIcode, SIcode, 2 },\n+  { convertHUSU, HUcode, SUcode, 2 },\n+  { convertSIDI, SIcode, DIcode, 2 },\n+  { convertSUDU, SUcode, DUcode, 2 },\n+  { convertSFDF, SFcode, DFcode, 2 },\n+  { convertDFXF, DFcode, XFcode, 2 },\n+  { convertHIQI, HIcode, QIcode, 8 },\n+  { convertSIQI, SIcode, QIcode, 8 },\n+  { convertSIHI, SIcode, HIcode, 8 },\n+  { convertSUQU, SUcode, QUcode, 8 },\n+  { convertDISI, DIcode, SIcode, 8 },\n+  { convertDFSF, DFcode, SFcode, 8 },\n+  { convertXFDF, XFcode, DFcode, 8 },\n+  { convertPSI, Pcode, SIcode, 2 },\n+  { convertSIP, SIcode, Pcode, 2 },\n+  { convertSIT, SIcode, Tcode, 2 },\n+  { convertDIT, DIcode, Tcode, 2 },\n+  { convertSFT, SFcode, Tcode, 2 },\n+  { convertDFT, DFcode, Tcode, 2 },\n+  { convertXFT, XFcode, Tcode, 2 },\n+  { convertQISI, QIcode, SIcode, 2 },\n+  { convertPT, Pcode, Tcode, 2 },\n+  { convertSISF, SIcode, SFcode, 4 },\n+  { convertSIDF, SIcode, DFcode, 4 },\n+  { convertSIXF, SIcode, XFcode, 4 },\n+  { convertSUSF, SUcode, SFcode, 4 },\n+  { convertSUDF, SUcode, DFcode, 4 },\n+  { convertSUXF, SUcode, XFcode, 4 },\n+  { convertDISF, DIcode, SFcode, 4 },\n+  { convertDIDF, DIcode, DFcode, 4 },\n+  { convertDIXF, DIcode, XFcode, 4 },\n+  { convertDUSF, DUcode, SFcode, 4 },\n+  { convertDUDF, DUcode, DFcode, 4 },\n+  { convertDUXF, DUcode, XFcode, 4 },\n+  { convertSFSI, SFcode, SIcode, 4 },\n+  { convertDFSI, DFcode, SIcode, 4 },\n+  { convertXFSI, XFcode, SIcode, 4 },\n+  { convertSFSU, SFcode, SUcode, 4 },\n+  { convertDFSU, DFcode, SUcode, 4 },\n+  { convertXFSU, XFcode, SUcode, 4 },\n+  { convertSFDI, SFcode, DIcode, 4 },\n+  { convertDFDI, DFcode, DIcode, 4 },\n+  { convertXFDI, XFcode, DIcode, 4 },\n+  { convertSFDU, SFcode, DUcode, 4 },\n+  { convertDFDU, DFcode, DUcode, 4 },\n+  { convertXFDU, XFcode, DUcode, 4 },\n+  { convertSIQI, SIcode, QIcode, 8 },\n+};\n+\n+#define NUM_CONVERSIONS (sizeof conversion_info / sizeof (struct conversion_info))\n+\n+/* List form of a conversion recipe.  */\n+struct conversion_list\n+{\n+  enum bytecode_opcode opcode;\n+  enum typecode to;\n+  int cost;\n+  struct conversion_list *prev;\n+};\n+\n+/* Determine if it is \"reasonable\" to add a given conversion to\n+   a given list of conversions.  The following criteria define\n+   \"reasonable\" conversion lists:\n+   * No typecode appears more than once in the sequence (no loops).\n+   * At most one conversion from integer to float or vice versa is present.\n+   * Either sign extensions or zero extensions may be present, but not both.\n+   * No widening conversions occur after a signed/unsigned conversion.\n+   * The sequence of sizes must be strict nonincreasing or nondecreasing.  */\n+static int\n+conversion_reasonable_p (conversion, list)\n+     struct conversion_info *conversion;\n+     struct conversion_list *list;\n+{\n+  struct conversion_list *curr;\n+  int curr_size, prev_size;\n+  int has_int_float, has_float_int;\n+  int has_sign_extend, has_zero_extend;\n+  int has_signed_unsigned, has_unsigned_signed;\n+\n+  has_int_float = 0;\n+  has_float_int = 0;\n+  has_sign_extend = 0;\n+  has_zero_extend = 0;\n+  has_signed_unsigned = 0;\n+  has_unsigned_signed = 0;\n+\n+  /* Make sure the destination typecode doesn't already appear in\n+     the list.  */\n+  for (curr = list; curr; curr = curr->prev)\n+    if (conversion->to == curr->to)\n+      return 0;\n+\n+  /* Check for certain kinds of conversions.  */\n+  if (TYPECODE_INTEGER_P (conversion->from)\n+      && TYPECODE_FLOAT_P (conversion->to))\n+    has_int_float = 1;\n+  if (TYPECODE_FLOAT_P (conversion->from)\n+      && TYPECODE_INTEGER_P (conversion->to))\n+    has_float_int = 1;\n+  if (TYPECODE_SIGNED_P (conversion->from)\n+      && TYPECODE_SIGNED_P (conversion->to)\n+      && GET_TYPECODE_SIZE (conversion->from)\n+      < GET_TYPECODE_SIZE (conversion->to))\n+    has_sign_extend = 1;\n+  if (TYPECODE_UNSIGNED_P (conversion->from)\n+      && TYPECODE_UNSIGNED_P (conversion->to)\n+      && GET_TYPECODE_SIZE (conversion->from)\n+      < GET_TYPECODE_SIZE (conversion->to))\n+    has_zero_extend = 1;\n+\n+  for (curr = list; curr && curr->prev; curr = curr->prev)\n+    {\n+      if (TYPECODE_INTEGER_P (curr->prev->to)\n+\t  && TYPECODE_FLOAT_P (curr->to))\n+\thas_int_float = 1;\n+      if (TYPECODE_FLOAT_P (curr->prev->to)\n+\t  && TYPECODE_INTEGER_P (curr->to))\n+\thas_float_int = 1;\n+      if (TYPECODE_SIGNED_P (curr->prev->to)\n+\t  && TYPECODE_SIGNED_P (curr->to)\n+\t  && GET_TYPECODE_SIZE (curr->prev->to)\n+\t  < GET_TYPECODE_SIZE (curr->to))\n+\thas_sign_extend = 1;\n+      if (TYPECODE_UNSIGNED_P (curr->prev->to)\n+\t  && TYPECODE_UNSIGNED_P (curr->to)\n+\t  && GET_TYPECODE_SIZE (curr->prev->to)\n+\t  < GET_TYPECODE_SIZE (curr->to))\n+\thas_zero_extend = 1;\n+      if (TYPECODE_SIGNED_P (curr->prev->to)\n+\t  && TYPECODE_UNSIGNED_P (curr->to))\n+\thas_signed_unsigned = 1;\n+      if (TYPECODE_UNSIGNED_P (curr->prev->to)\n+\t  && TYPECODE_SIGNED_P (curr->to))\n+\thas_unsigned_signed = 1;\n+    }\n+\n+  if (TYPECODE_INTEGER_P (conversion->from)\n+      && TYPECODE_INTEGER_P (conversion->to)\n+      && GET_TYPECODE_SIZE (conversion->to)\n+      > GET_TYPECODE_SIZE (conversion->from)\n+      && (has_signed_unsigned || has_unsigned_signed))\n+    return 0;\n+\n+  if (has_float_int && has_int_float || has_sign_extend && has_zero_extend)\n+    return 0;\n+\n+  /* Make sure the sequence of destination typecode sizes is\n+     strictly nondecreasing or strictly nonincreasing.  */\n+  prev_size = GET_TYPECODE_SIZE (conversion->to);\n+  for (curr = list; curr; curr = curr->prev)\n+    {\n+      curr_size = GET_TYPECODE_SIZE (curr->to);\n+      if (curr_size != prev_size)\n+\tbreak;\n+    }\n+  if (!curr)\n+    return 1;\n+\n+  if (curr_size < prev_size)\n+    for (prev_size = curr_size; curr; curr = curr->prev)\n+      {\n+\tcurr_size = GET_TYPECODE_SIZE (curr->to);\n+\tif (curr_size > prev_size)\n+\t  return 0;\n+\tprev_size = curr_size;\n+      }\n+  else\n+    for (prev_size = curr_size; curr; curr = curr->prev)\n+      {\n+\tcurr_size = GET_TYPECODE_SIZE (curr->to);\n+\tif (curr_size < prev_size)\n+\t  return 0;\n+\tprev_size = curr_size;\n+      }\n+  return 1;\n+}\n+\n+\n+/* Exhaustively search all reasonable conversions to find one to\n+   convert the given types.  */\n+static struct conversion_recipe\n+deduce_conversion (from, to)\n+     enum typecode from, to;\n+{\n+  struct rl\n+    {\n+      struct conversion_list *list;\n+      struct rl *next;\n+    } *prev, curr, *good, *temp;\n+  struct conversion_list *conv, *best;\n+  int i, cost, bestcost;\n+  struct conversion_recipe result;\n+  struct obstack recipe_obstack;\n+\n+\n+  obstack_init (&recipe_obstack);\n+  curr.next = (struct rl *) obstack_alloc (&recipe_obstack, sizeof (struct rl));\n+  curr.next->list =\n+    (struct conversion_list *) obstack_alloc (&recipe_obstack,\n+\t\t\t\t\t      sizeof (struct conversion_list));\n+  curr.next->list->opcode = -1;\n+  curr.next->list->to = from;\n+  curr.next->list->cost = 0;\n+  curr.next->list->prev = 0;\n+  curr.next->next = 0;\n+  good = 0;\n+\n+  while (curr.next)\n+    {\n+      /* Remove successful conversions from further consideration.  */\n+      for (prev = &curr; prev; prev = prev->next)\n+\tif (prev->next && prev->next->list->to == to)\n+\t  {\n+\t    temp = prev->next->next;\n+\t    prev->next->next = good;\n+\t    good = prev->next;\n+\t    prev->next = temp;\n+\t  }\n+\n+      /* Go through each of the pending conversion chains, trying\n+\t all possible candidate conversions on them.  */\n+      for (prev = curr.next, curr.next = 0; prev; prev = prev->next)\n+\tfor (i = 0; i < NUM_CONVERSIONS; ++i)\n+\t  if (conversion_info[i].from == prev->list->to\n+\t      && conversion_reasonable_p (&conversion_info[i], prev->list))\n+\t    {\n+\t      temp = (struct rl *) obstack_alloc (&recipe_obstack,\n+\t\t\t\t\t\t  sizeof (struct rl));\n+\t      temp->list = (struct conversion_list *)\n+\t\tobstack_alloc (&recipe_obstack,\n+\t\t\t       sizeof (struct conversion_list));\n+\t      temp->list->opcode = conversion_info[i].opcode;\n+\t      temp->list->to = conversion_info[i].to;\n+\t      temp->list->cost = conversion_info[i].cost;\n+\t      temp->list->prev = prev->list;\n+\t      temp->next = curr.next;\n+\t      curr.next = temp;\n+\t    }\n+    }\n+\n+  bestcost = BIG_ARBITRARY_NUMBER;\n+  best = 0;\n+  for (temp = good; temp; temp = temp->next)\n+    {\n+      for (conv = temp->list, cost = 0; conv; conv = conv->prev)\n+\tcost += conv->cost;\n+      if (cost < bestcost)\n+\t{\n+\t  bestcost = cost;\n+\t  best = temp->list;\n+\t}\n+    }\n+\n+  if (!best)\n+    abort ();\n+\n+  for (i = 0, conv = best; conv; conv = conv->prev)\n+    if (conv->opcode != -1)\n+      ++i;\n+\n+  result.opcodes = (unsigned char *) xmalloc (i);\n+  result.nopcodes = i;\n+  for (conv = best; conv; conv = conv->prev)\n+    if (conv->opcode != -1)\n+      result.opcodes[--i] = conv->opcode;\n+  result.cost = bestcost;\n+  obstack_free (&recipe_obstack, 0);\n+  return result;\n+}\n+\n+#define DEDUCE_CONVERSION(FROM, TO)\t\t\t\t\t      \\\n+  (conversion_recipe[FROM][TO].opcodes ? 0\t\t\t\t      \\\n+   : (conversion_recipe[FROM][TO] = deduce_conversion (FROM, TO), 0))\n+\n+\n+/* Emit a conversion between the given scalar types.  */\n+void\n+emit_typecode_conversion (from, to)\n+     enum typecode from, to;\n+{\n+  int i;\n+\n+  DEDUCE_CONVERSION (from, to);\n+  for (i = 0; i < conversion_recipe[from][to].nopcodes; ++i)\n+    bc_emit_instruction (conversion_recipe[from][to].opcodes[i]);\n+}\n+\n+\n+/* Initialize mode_to_code_map[] */\n+void\n+bc_init_mode_to_code_map ()\n+{\n+  int mode;\n+\n+  for (mode = 0; mode < MAX_MACHINE_MODE + 1; mode++)\n+    {\n+      signed_mode_to_code_map[mode] = \n+\tunsigned_mode_to_code_map[mode] =\n+\t  LAST_AND_UNUSED_TYPECODE;\n+    }\n+\n+#define DEF_MODEMAP(SYM, CODE, UCODE, CONST, LOAD, STORE) \\\n+  { signed_mode_to_code_map[(enum machine_mode) SYM] = CODE; \\\n+    unsigned_mode_to_code_map[(enum machine_mode) SYM] = UCODE; }\n+#include \"modemap.def\"\n+#undef DEF_MODEMAP\n+\n+  /* Initialize opcode maps for const, load, and store */\n+  bc_init_mode_to_opcode_maps ();\n+}\n+\n+/* Given a machine mode return the preferred typecode.  */\n+enum typecode\n+preferred_typecode (mode, unsignedp)\n+     enum machine_mode mode;\n+     int unsignedp;\n+{\n+  enum typecode code = (unsignedp\n+\t\t\t? unsigned_mode_to_code_map\n+\t\t\t: signed_mode_to_code_map) [MIN (mode, MAX_MACHINE_MODE)];\n+\n+  if (code == LAST_AND_UNUSED_TYPECODE)\n+    abort ();\n+\n+  return code;\n+}\n+\n+\n+/* Expand a conversion between the given types.  */\n+void\n+bc_expand_conversion (from, to)\n+     tree from, to;\n+{\n+  enum typecode fcode, tcode;\n+\n+  fcode = preferred_typecode (TYPE_MODE (from), TREE_UNSIGNED (from));\n+  tcode = preferred_typecode (TYPE_MODE (to), TREE_UNSIGNED (to));\n+\n+  emit_typecode_conversion (fcode, tcode);\n+}\n+\n+/* Expand a conversion of the given type to a truth value.  */\n+void\n+bc_expand_truth_conversion (from)\n+     tree from;\n+{\n+  enum typecode fcode;\n+\n+  fcode = preferred_typecode (TYPE_MODE (from), TREE_UNSIGNED (from));\n+  emit_typecode_conversion (fcode, Tcode);\n+}\n+\n+/* Emit an appropriate binary operation.  */\n+void\n+bc_expand_binary_operation (optab, resulttype, arg0, arg1)\n+     struct binary_operator optab[];\n+     tree resulttype, arg0, arg1;\n+{\n+  int i, besti, cost, bestcost;\n+  enum typecode resultcode, arg0code, arg1code;\n+  \n+  resultcode = preferred_typecode (TYPE_MODE (resulttype), TREE_UNSIGNED (resulttype));\n+  arg0code = preferred_typecode (TYPE_MODE (TREE_TYPE (arg0)), TREE_UNSIGNED (resulttype));\n+  arg1code = preferred_typecode (TYPE_MODE (TREE_TYPE (arg1)), TREE_UNSIGNED (resulttype));\n+\n+  besti = -1;\n+  bestcost = BIG_ARBITRARY_NUMBER;\n+\n+  for (i = 0; optab[i].opcode != -1; ++i)\n+    {\n+      cost = 0;\n+      DEDUCE_CONVERSION (arg0code, optab[i].arg0);\n+      cost += conversion_recipe[arg0code][optab[i].arg0].cost;\n+      DEDUCE_CONVERSION (arg1code, optab[i].arg1);\n+      cost += conversion_recipe[arg1code][optab[i].arg1].cost;\n+      if (cost < bestcost)\n+\t{\n+\t  besti = i;\n+\t  bestcost = cost;\n+\t}\n+    }\n+\n+  if (besti == -1)\n+    abort ();\n+\n+  expand_expr (arg1);\n+  emit_typecode_conversion (arg1code, optab[besti].arg1);\n+  expand_expr (arg0);\n+  emit_typecode_conversion (arg0code, optab[besti].arg0);\n+  bc_emit_instruction (optab[besti].opcode);\n+  emit_typecode_conversion (optab[besti].result, resultcode);\n+}\n+\n+/* Emit an appropriate unary operation.  */\n+void\n+bc_expand_unary_operation (optab, resulttype, arg0)\n+     struct unary_operator optab[];\n+     tree resulttype, arg0;\n+{\n+  int i, besti, cost, bestcost;\n+  enum typecode resultcode, arg0code;\n+  \n+  resultcode = preferred_typecode (TYPE_MODE (resulttype), TREE_UNSIGNED (resulttype));\n+  arg0code = preferred_typecode (TYPE_MODE (TREE_TYPE (arg0)), TREE_UNSIGNED (TREE_TYPE (arg0)));\n+\n+  besti = -1;\n+  bestcost = BIG_ARBITRARY_NUMBER;\n+\n+  for (i = 0; optab[i].opcode != -1; ++i)\n+    {\n+      DEDUCE_CONVERSION (arg0code, optab[i].arg0);\n+      cost = conversion_recipe[arg0code][optab[i].arg0].cost;\n+      if (cost < bestcost)\n+\t{\n+\t  besti = i;\n+\t  bestcost = cost;\n+\t}\n+    }\n+\n+  if (besti == -1)\n+    abort ();\n+\n+  expand_expr (arg0);\n+  emit_typecode_conversion (arg0code, optab[besti].arg0);\n+  bc_emit_instruction (optab[besti].opcode);\n+  emit_typecode_conversion (optab[besti].result, resultcode);\n+}\n+\n+\n+/* Emit an appropriate increment.  */\n+void\n+bc_expand_increment (optab, type)\n+     struct increment_operator optab[];\n+     tree type;\n+{\n+  enum typecode code;\n+  int i;\n+\n+  code = preferred_typecode (TYPE_MODE (type), TREE_UNSIGNED (type));\n+  for (i = 0; optab[i].opcode >= 0; ++i)\n+    if (code == optab[i].arg)\n+      {\n+\tbc_emit_instruction (optab[i].opcode);\n+\treturn;\n+      }\n+  abort ();\n+}"}, {"sha": "243cd3dea63d136fad96dba565f0313511aa304c", "filename": "gcc/bc-typecd.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbc-typecd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbc-typecd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-typecd.h?ref=86d7f2db057abae09db4208bf0578f6e9a0da17b", "patch": "@@ -0,0 +1,53 @@\n+/* Typecode definitions for Bytecode Interpreter.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef TYPECODE_H\n+#define TYPECODE_H\n+\n+enum typecode\n+{\n+#define DEFTYPECODE(CODE, NAME, MACHMODE, TYPE) CODE,\n+#include \"bc-typecd.def\"\n+#undef DEFTYPECODE\n+\n+  LAST_AND_UNUSED_TYPECODE\n+};\n+\n+/* Determine if a given type is integer.  */\n+#define TYPECODE_INTEGER_P(TYPECODE) ((TYPECODE) < SFcode)\n+\n+/* Determine if a given type is unsigned.  */\n+#define TYPECODE_UNSIGNED_P(TYPECODE) \\\n+  (TYPECODE_INTEGER_P(TYPECODE) && (TYPECODE) & 1)\n+\n+/* Determine if a given type is signed.  */\n+#define TYPECODE_SIGNED_P(TYPECODE) \\\n+  (TYPECODE_INTEGER_P(TYPECODE) && !((TYPECODE) & 1))\n+\n+/* Determine if a given type is floating.  */\n+#define TYPECODE_FLOAT_P(TYPECODE) \\\n+  ((TYPECODE) < Pcode && !TYPECODE_INTEGER_P(TYPECODE))\n+\n+/* Determine if the given type is arithmetic. */\n+#define TYPECODE_ARITH_P(TYPECODE) \\\n+  (TYPECODE_INTEGER_P(TYPECODE) || TYPECODE_FLOAT_P(TYPECODE))\n+\n+#define NUM_TYPECODES ((int) LAST_AND_UNUSED_TYPECODE)\n+\n+#endif"}, {"sha": "772b1fed3add8ffcbdfc346836800f520fd87778", "filename": "gcc/bi-opcode.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbi-opcode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbi-opcode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-opcode.c?ref=86d7f2db057abae09db4208bf0578f6e9a0da17b", "patch": "@@ -0,0 +1,53 @@\n+/* Utility to generate opcode list from bytecode definition.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"bi-defs.h\"\n+\n+int\n+main(argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  struct def *d;\n+  struct variation *v;\n+  int i;\n+\n+  yyparse();\n+  reverse();\n+\n+\n+  puts (\"/* This file is automatically generated from bytecode.def, do not make\\n\\\n+any changes here. Instead edit bytecode.def and type ``make''. */\\n\\\n+enum bytecode_opcode\\n{\");\n+\n+  i = 0;\n+  for (d = defs; d; d = d->next)\n+    for (v = d->variations; v; v = v->next)\n+      printf (\"  %s%s,\\n\", d->basename, v->name, i++);\n+\n+  puts (\"  LAST_AND_UNUSED_OPCODE\\n};\");\n+\n+  if (i > 256)\n+    fprintf (stderr, \"%s: warning, number of opcodes is %d\\n\", *argv, i);\n+  else\n+    fprintf (stderr, \"(Number of opcodes is %d)\\n\", i);\n+\n+  return 0;\n+}"}, {"sha": "07d1319cb95e6bd8a905a8d2ffe2dd5f2310f1b3", "filename": "gcc/bi-parser.y", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbi-parser.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbi-parser.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-parser.y?ref=86d7f2db057abae09db4208bf0578f6e9a0da17b", "patch": "@@ -0,0 +1,168 @@\n+/* Bytecode definition file parser.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+%{\n+\n+#include <stdio.h>\n+#include \"bi-defs.h\"\n+\n+extern char yytext[];\n+extern int yyleng;\n+\n+extern char *malloc();\n+\n+\n+/* Chain of all defs built by the parser. */\n+struct def *defs;\n+int ndefs;\n+\n+static struct node *makenode();\n+static struct variation *makevar();\n+static struct def *makedef();\n+\n+%}\n+\n+%union{\n+  char *string;\n+  struct def *def;\n+  struct variation *variation;\n+  struct node *node;\n+}\n+\n+%token <string> DEFOP STRING\n+%type <string> opt_string\n+%type <def> defs def\n+%type <variation> variations variation\n+%type <node> list items item\n+\n+%%\n+\n+top: \n+  defs\n+    { defs = $1; }\n+  ;\n+\n+defs:\n+  def\n+  | defs def\n+    { $2->next = $1; $$ = $2; }\n+  ;\n+\n+def:\n+  DEFOP '(' STRING ',' opt_string ',' '(' variations ')' ')'\n+    { $$ = makedef($3, $5, $8); }\n+  ;\n+\n+variations:\n+  variation\n+  | variations ',' variation\n+    { $3->next = $1; $$ = $3; }\n+  ;\n+\n+variation:\n+  '(' opt_string ')'\n+    { $$ = makevar($2, (struct node *) NULL, (struct node *) NULL, (struct node *) NULL); }\n+  | '(' opt_string ',' list ')'\n+    { $$ = makevar($2, $4, (struct node *) NULL, (struct node *) NULL); }\n+  | '(' opt_string ',' list ',' list ')'\n+    { $$ = makevar($2, $4, $6, (struct node *) NULL); }\n+  | '(' opt_string ',' list ',' list ',' list ')'\n+    { $$ = makevar($2, $4, $6, $8); }\n+  ;\n+\n+opt_string:\n+  /* empty */ { $$ = \"\"; }\n+  | STRING { $$ = $1; }\n+  ;\n+\n+list:\n+  '(' items ')'\n+    { $$ = $2; }\n+  | /* empty */\n+    { $$ = NULL; }\n+  ;\n+\n+items:\n+  item\n+  /* Note right recursion. */\n+  | item ',' items\n+    { $1->next = $3; $$ = $1; }\n+  ;\n+\n+item:\n+  STRING\n+    { $$ = makenode($1); }\n+  ;\n+\n+%%\n+\n+static struct node *\n+makenode(s)\n+     char *s;\n+{\n+  struct node *n;\n+\n+  n = (struct node *) malloc(sizeof (struct node));\n+  n->text = s;\n+  n->next = NULL;\n+  return n;\n+}\n+\n+static struct variation *\n+makevar(name, inputs, outputs, literals)\n+     char *name;\n+     struct node *inputs, *outputs, *literals;\n+{\n+  struct variation *v;\n+\n+  v = (struct variation *) malloc(sizeof (struct variation));\n+  v->name = name;\n+  v->code = ndefs++;\n+  v->inputs = inputs;\n+  v->outputs = outputs;\n+  v->literals = literals;\n+  v->next = NULL;\n+  return v;\n+}\n+\n+static struct def *\n+makedef(name, template, vars)\n+     char *name, *template;\n+     struct variation *vars;\n+{\n+  struct def *d;\n+\n+  d = (struct def *) malloc(sizeof (struct def));\n+  d->basename = name;\n+  d->template = template;\n+  d->variations = vars;\n+  d->next = NULL;\n+  return d;\n+}\n+\n+void\n+yyerror(s)\n+     char *s;\n+{\n+  extern int yylineno;\n+\n+  fprintf(stderr, \"syntax error in line %d\\n\", yylineno);\n+  exit(1);\n+}"}, {"sha": "4c413ebef982be8df58b19930593b86108bf11c1", "filename": "gcc/bi-run.h", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbi-run.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbi-run.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-run.h?ref=86d7f2db057abae09db4208bf0578f6e9a0da17b", "patch": "@@ -0,0 +1,184 @@\n+/* Definitions for Bytecode Interpreter.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+typedef union stacktype\n+{\n+  QItype QIval;\n+  QUtype QUval;\n+  HItype HIval;\n+  HUtype HUval;\n+  SItype SIval;\n+  SUtype SUval;\n+  DItype DIval;\n+  DUtype DUval;\n+  SFtype SFval;\n+  DFtype DFval;\n+  XFtype XFval;\n+  Ptype Pval;\n+  Ttype Tval;\n+} stacktype;\n+  \n+#define MAXLITERALS 5\n+\n+struct arityvec\n+{\n+  char ninputs;\n+  char noutputs;\n+  char nliterals;\n+  char literals[MAXLITERALS];\n+};\n+\n+struct argtype\n+{\n+  int modealign;\t\t/* Argument mode:alignment */\n+  int size;\t\t\t/* Argument size, in bytes */\n+};\n+\n+struct callinfo\n+{\n+  int nargs;\t\t\t/* Number of arguments in call */\n+  struct argtype retvaltype;\t/* Type of return value */\n+  struct argtype argtypes[1];\t/* Argument types */\n+};\n+  \n+/* Structure describing a bytecode function.  If this changes, we also\n+   need to change expand_function_end () in bc-trans.c  */\n+struct bytecode\n+{\n+  int stacksize;\t\t/* Depth required of evaluation stack.  */\n+  int localsize;\t\t/* Size in bytes of local variables.  */\n+  unsigned char *pc0;\t\t/* Initial program counter. */\n+  void **ptrlit;\t\t/* Vector of (relocatable) pointer literals. */\n+  struct callinfo *callinfo;\t/* Vector of procedure call type info. */\n+};\n+\n+\n+#define INTERP_BPC 8\t\t/* Bits per char */\n+#define INTERP_BPI \\\n+  (sizeof (int) * INTERP_BPC)\t/* Bits per int */\n+\n+\n+#ifndef min\n+#define min(L, R)  ((L) < (R) ? (L) : (R))\n+#endif\n+\n+\n+/* bit field operations. */\n+\n+/* Low (high) mask: int with low (high) N bits set */\n+\n+#define LM(N)   ((1 << (N)) - 1)\n+#define HM(N)\t((~LM (INTERP_BPI - (N))))\n+\n+\n+/* Sign-extend SIZE low bits of VALUE to integer (typeof VALUE)\n+   Signed bitfields are loaded from memory by the sxloadBI instruction,\n+   which first retrieves the bitfield with XFIELD and then sign extends\n+   it to an SItype. */\n+\n+#define EXTEND(SIZE, VALUE)\t\t\t\t\t\t      \\\n+  ({ SUtype value = (SUtype) (VALUE);\t\t\t\t\t      \\\n+    (value & (1 << ((SIZE) - 1)) ? value | ~LM (SIZE) : value); })\n+\n+\n+/* Given OFFSET:SIZE for  a bitfield, calculate:\n+\n+   [1] BYTE_OFFSET  = the byte offset of the bit field.\n+   [2] BIT_OFFSET   = the bit offset of the bit field (less than INTERP_BPC).\n+   [3] NBYTES       = the number of integral bytes in the bit field.\n+   [4] TRAILING_BITS= the number of trailing bits (less than INTERP_BPC).\n+\n+\n+   ,        ,        ,        ,        ,    (memory bytes)\n+                    ----------------        (bitfield)\n+   |        |       ||        |    |        (divisions)\n+        ^         ^       ^      ^\n+        |         |       |      |__ [4]  (bits)\n+        |         |       |_________ [3]  (bytes)\n+        |         |_________________ [2]  (bits)\n+        |___________________________ [1]  (bytes)\n+\n+\n+   The above applies to BYTE_LOW_ENDIAN machines. In BYTE_BIG_ENDIAN machines, the\n+   bit numbering is reversed (i.e. bit 0 is the sign bit).\n+\n+   (Alright, so I drew this to keep my tongue in cheek while writing the code below,\n+    not because I'm into ASCII art.) */\n+\n+\n+#define BI_PARAMS(OFFSET, SIZE, BYTE_OFFSET,\t\t\t\t\\\n+\t\t  BIT_OFFSET, NBYTES, TRAILING_BITS )\t\t\t\\\n+\\\n+  { BYTE_OFFSET = (OFFSET) / (INTERP_BPC);\t\t\t\t\\\n+    BIT_OFFSET = (OFFSET) % (INTERP_BPC);\t\t\t\t\\\n+    NBYTES = ((SIZE) - (INTERP_BPC - (BIT_OFFSET))) / INTERP_BPC;\t\\\n+    if ((NBYTES) < 0 || ((NBYTES) > 64)) \t\t\t\t\\\n+      NBYTES = 0;\t\t\t\t \t\t\t\\\n+    if ((SIZE) + (BIT_OFFSET) <= INTERP_BPC)\t\t\t\t\\\n+      TRAILING_BITS = 0;\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      TRAILING_BITS = ((SIZE) - (INTERP_BPC - (BIT_OFFSET))) % INTERP_BPC; }\n+\n+\n+/* SHIFT_IN_BITS retrieves NBITS bits from SOURCE and shifts into\n+   DEST. The bit field starts OFFSET bits into SOURCE.\n+\n+   OR_IN_BITS copies the NBITS low bits from VALUE into a the bitfield in\n+   DEST offset by OFFSET bits. */\n+\n+\n+#ifdef BYTES_BIG_ENDIAN\n+\n+#define SHIFT_IN_BITS(DEST, SOURCE, OFFSET, NBITS)\t\t\\\n+  (DEST = ((DEST) << (NBITS))\t\t\t\t\t\\\n+   | (LM ((NBITS))\t\t\t\t\t\t\\\n+      & ((SOURCE) >> (INTERP_BPC - (OFFSET) - (NBITS)))))\n+\n+#define OR_IN_BITS(DEST, VALUE, OFFSET, NBITS)\t\t\t\\\n+  (DEST = ((DEST) & ~(LM ((NBITS)) << (INTERP_BPC - (OFFSET) - (NBITS))))\t\\\n+   | (((VALUE) & LM ((NBITS))) << (INTERP_BPC - (OFFSET) - (NBITS))))\n+\n+#else\n+\n+#define SHIFT_IN_BITS(DEST, SOURCE, OFFSET, NBITS)\t\t\\\n+  (DEST = ((DEST) << (NBITS))\t\t\t\t\t\\\n+   | (LM ((NBITS))\t\t\t\t\t\t\\\n+      & ((SOURCE) >> (OFFSET))))\n+\n+#define OR_IN_BITS(DEST, VALUE, OFFSET, NBITS)\t\t\t\\\n+  (DEST = ((DEST) & ~(LM ((NBITS)) << (OFFSET)))\t\t\\\n+   | (((VALUE) & LM ((NBITS))) << (OFFSET)))\n+\n+#endif\n+\n+\n+/* Procedure call; arguments are a pointer to the function to be called,\n+   a pointer to a place to store the return value, a pointer to a vector\n+   describing the type of procedure call, and the interpreter's stack pointer,\n+   which will point to the first of the arguments at this point.  */\n+\n+#define CALL(FUNC, CALLDESC, RETVAL, SP) __call(FUNC, CALLDESC, RETVAL, SP)\n+\n+\n+/* Procedure return; arguments are a pointer to the calldesc for this\n+   function, and a pointer to the place where the value to be returned\n+   may be found.  Generally the MACHARGS above contain a machine dependent\n+   cookie that is used to determine where to jump to.  */\n+\n+#define PROCRET(CALLDESC, RETVAL) return"}, {"sha": "6e9731254c8d0cb50b0b0811260076d9eb80af8f", "filename": "gcc/bytecode.h", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbytecode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fbytecode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbytecode.h?ref=86d7f2db057abae09db4208bf0578f6e9a0da17b", "patch": "@@ -0,0 +1,105 @@\n+/* Bytecode definitions for GNU C-compiler.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* These should come from genemit */\n+typedef signed char QItype;\n+typedef unsigned char QUtype;\n+typedef signed short int HItype;\n+typedef unsigned short int HUtype;\n+typedef signed long int SItype;\n+typedef unsigned long int SUtype;\n+typedef signed long long int DItype;\n+typedef unsigned long long int DUtype;\n+typedef float SFtype;\n+typedef double DFtype;\n+typedef long double XFtype;\n+typedef char *Ptype;\n+typedef int Ttype;\n+\n+extern int output_bytecode;\n+extern int stack_depth;\n+extern int max_stack_depth;\n+\n+/* Emit DI constant according to target machine word ordering */\n+\n+#ifdef WORD_HIGH_ENDIAN\n+\n+#define bc_emit_bytecode_DI_const(CST) \t\t\t\t\\\n+{ int opcode;\t\t\t\t\t\t\t\\\n+  opcode = TREE_INT_CST_HIGH (CST); \t\t\t\t\\\n+  bc_emit_bytecode_const ((char *) &opcode, sizeof opcode); \t\\\n+  opcode = TREE_INT_CST_LOW (CST); \t\t\t\t\\\n+  bc_emit_bytecode_const ((char *) &opcode, sizeof opcode);\t\\\n+}\n+\t  \n+#else\n+\n+#define bc_emit_bytecode_DI_const(CST)\t \t\t\t\\\n+{ int opcode;\t\t\t\t\t\t\t\\\n+  opcode = TREE_INT_CST_LOW (CST); \t\t\t\t\\\n+  bc_emit_bytecode_const ((char *) &opcode, sizeof opcode); \t\\\n+  opcode = TREE_INT_CST_HIGH (CST); \t\t\t\t\\\n+  bc_emit_bytecode_const ((char *) &opcode, sizeof opcode);\t\\\n+}\n+\t  \n+#endif\n+\n+\n+extern void bc_expand_expr ();\n+extern void bc_output_data_constructor ();\n+extern void bc_store_field ();\n+extern void bc_load_bit_field ();\n+extern void bc_store_bit_field ();\n+extern void bc_push_offset_and_size ();\n+extern void bc_init_mode_to_code_map ();\n+\n+/* These are just stubs, so the compiler will compile for targets\n+   that aren't yet supported by the bytecode generator. */\n+\n+#ifndef TARGET_SUPPORTS_BYTECODE\n+\n+#define MACHINE_SEG_ALIGN 1\n+#define INT_ALIGN 1\n+#define PTR_ALIGN 1\n+#define NAMES_HAVE_UNDERSCORES\n+#define BC_NOP   (0)\n+#define BC_GLOBALIZE_LABEL(FP, NAME) BC_NOP\n+#define BC_OUTPUT_COMMON(FP, NAME, SIZE, ROUNDED) BC_NOP\n+#define BC_OUTPUT_LOCAL(FP, NAME, SIZE, ROUNDED)  BC_NOP\n+#define BC_OUTPUT_ALIGN(FP, ALIGN)   BC_NOP\n+#define BC_OUTPUT_LABEL(FP, NAME)    BC_NOP\n+#define BC_OUTPUT_SKIP(FP, SIZE)     BC_NOP\n+#define BC_OUTPUT_LABELREF(FP, NAME) BC_NOP\n+#define BC_OUTPUT_FLOAT(FP, VAL)     BC_NOP\n+#define BC_OUTPUT_DOUBLE(FP, VAL)    BC_NOP\n+#define BC_OUTPUT_BYTE(FP, VAL)      BC_NOP\n+#define BC_OUTPUT_FILE ASM_OUTPUT_FILE\n+#define BC_OUTPUT_ASCII ASM_OUTPUT_ASCII\n+#define BC_OUTPUT_IDENT ASM_OUTPUT_IDENT\n+#define BCXSTR(RTX)  ((RTX)->bc_label)\n+#define BC_WRITE_FILE(FP)            BC_NOP\n+#define BC_WRITE_SEGSYM(SEGSYM, FP)  BC_NOP\n+#define BC_WRITE_RELOC_ENTRY(SEGRELOC, FP, OFFSET) BC_NOP\n+#define BC_START_BYTECODE_LINE(FP)   BC_NOP\n+#define BC_WRITE_BYTECODE(SEP, VAL, FP) BC_NOP\n+#define BC_WRITE_RTL(R, FP)          BC_NOP\n+#define BC_EMIT_TRAMPOLINE(TRAMPSEG, CALLINFO) BC_NOP\n+#define VALIDATE_STACK               BC_NOP\n+\n+#endif /* !TARGET_SUPPORTS_BYTECODE */"}, {"sha": "32576403ef93a46aad2957b1ce0f9433e22ddacb", "filename": "gcc/modemap.def", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fmodemap.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d7f2db057abae09db4208bf0578f6e9a0da17b/gcc%2Fmodemap.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodemap.def?ref=86d7f2db057abae09db4208bf0578f6e9a0da17b", "patch": "@@ -0,0 +1,30 @@\n+/* Bytecode specific machine mode info for GNU C-compiler.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Map mode to signed, unsigned typecodes, bytecode to push const,\n+   to load, to store */\n+DEF_MODEMAP(QImode, QIcode, QUcode, constQI, loadQI, storeQI)\n+DEF_MODEMAP(HImode, HIcode, HUcode, constHI, loadHI, storeHI)\n+DEF_MODEMAP(VOIDmode, SIcode, SUcode, constSI, loadSI, storeSI)\n+DEF_MODEMAP(SImode, SIcode, SUcode, constSI, loadSI, storeSI)\n+DEF_MODEMAP(DImode, DIcode, DUcode, constDI, loadDI, storeDI)\n+DEF_MODEMAP(PSImode, Pcode, Pcode, constP, loadP, storeP)\n+DEF_MODEMAP(BLKmode, Pcode, Pcode, constP, loadP, neverneverland)\n+DEF_MODEMAP(SFmode, SFcode, SFcode, constSF, loadSF, storeSF)\n+DEF_MODEMAP(DFmode, DFcode, DFcode, constDF, loadDF, storeDF)"}]}