{"sha": "9187e02deb92bfe982c845a682468fce39c8bf9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE4N2UwMmRlYjkyYmZlOTgyYzg0NWE2ODI0NjhmY2UzOWM4YmY5Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-05-08T19:19:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-05-08T19:19:51Z"}, "message": "cgraphbuild.c (compute_call_stmt_bb_frequency): Accept function argument; handle correctly when profile is absent.\n\n\t* cgraphbuild.c (compute_call_stmt_bb_frequency): Accept function argument;\n\thandle correctly when profile is absent.\n\t(build_cgraph_edges): Update.\n\t(rebuild_cgraph_edges): Update.\n\t* cgraph.c: Do not include varrau.h \n\t(cgraph_set_call_stmt_including_clones, cgraph_create_edge_including_clones):\n\tNew function\n\t(cgraph_update_edges_for_call_stmt_node): New stati cfunction.\n\t(cgraph_update_edges_for_call_stmt): Handle clones.\n\t(cgraph_remove_node): Handle clone tree.\n\t(cgraph_remove_node_and_inline_clones): New function.\n\t(dump_cgraph_node): Dump clone tree.\n\t(cgraph_clone_node): Handle clone tree.\n\t(clone_function_name): Bring here from tree-inline.c\n\t(cgraph_create_virtual_clone): New function.\n\t* cgraph.h (ipa_replace_map): Move ehre from ipa.h\n\t(cgraph_clone_info): New function\n\t(strut cgraph_node): Add clone_info and new clone tree pointers.\n\t(cgraph_remove_node_and_inline_clones, cgraph_set_call_stmt_including_clones,\n\tcgraph_create_edge_including_clones, cgraph_create_virtual_clone): Declare.\n\t(cgraph_function_versioning): Use VEC argument.\n\t(compute_call_stmt_bb_frequency): Update prototype.\n\t(cgraph_materialize_all_clones): New function.\n\t* ipa-cp.c (ipcp_update_cloned_node): Remove.\n\t(ipcp_create_replace_map): Update to VECtors.\n\t(ipcp_update_callgraph): Use virtual clones.\n\t(ipcp_update_bb_counts, ipcp_update_edges_counts): Remove.\n\t(ipcp_update_profiling): Do not update local profiling.\n\t(ipcp_insert_stage): Use VECtors and virtual clones.\n\t* cgraphunit.c (verify_cgraph_node): Verify clone tree.\n\t(clone_of_p): New function.\n\t(cgraph_preserve_function_body_p): Use clone tree.\n\t(cgraph_optimize): Materialize clones.\n\t(cgraph_function_versioning): Update for VECtors.\n\t(save_inline_function_body): Use clone tree.\n\t(cgraph_materialize_clone, cgraph_materialize_all_clones): New functions.\n\t* ipa-inline.c (cgraph_default_inline_p): Use analyzed flags.\n\t* ipa.c: Include gimple.h.\n\t(cgraph_remove_unreachable_nodes): Use clone tree.\n\t* ipa-prop.c (ipa_note_param_call): Update call of compute_call_stmt_bb_frequency.\n\t* ipa-prop.h (ipa_replace_map): Move to cgraph.h.\n\t* tree-inline.c: Do not include varray.h; do not include gt-tree-inline.h\n\t(copy_bb): Handle updating of clone tree; add new edge when new call\n\tappears.\n\t(expand_call_inline): Be strict about every call having edge.\n\t(clone_fn_id_num, clone_function_name): Move to cgraph.c.\n\t(delete_unreachable_blocks_update_callgraph): New function.\n\t(tree_function_versioning): Use VECtors; always remove unreachable blocks\n\tand fold conditionals.\n\t* tree-inline.h: Do not include varray.h\n\t(tree_function_versioning): Remove.\n\t* Makefile.in (GTFILES): Remove tree-inline.c\n\t* passes.c (do_per_function): Do only functions having body.\n\t* ipa-struct-reorg.c (do_reorg_1, collect_data_accesses): Handle cone tree.\n\nFrom-SVN: r147294", "tree": {"sha": "c97ec571988fc2c7380db58cdf7ad61782d357bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c97ec571988fc2c7380db58cdf7ad61782d357bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9187e02deb92bfe982c845a682468fce39c8bf9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9187e02deb92bfe982c845a682468fce39c8bf9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9187e02deb92bfe982c845a682468fce39c8bf9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9187e02deb92bfe982c845a682468fce39c8bf9b/comments", "author": null, "committer": null, "parents": [{"sha": "9b86d6bb25587db93a322bf5778e9892aaa8b776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b86d6bb25587db93a322bf5778e9892aaa8b776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b86d6bb25587db93a322bf5778e9892aaa8b776"}], "stats": {"total": 1184, "additions": 839, "deletions": 345}, "files": [{"sha": "508436b9677585337749d588cca21e9c70885b04", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -1,3 +1,60 @@\n+2009-05-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphbuild.c (compute_call_stmt_bb_frequency): Accept function argument;\n+\thandle correctly when profile is absent.\n+\t(build_cgraph_edges): Update.\n+\t(rebuild_cgraph_edges): Update.\n+\t* cgraph.c: Do not include varrau.h \n+\t(cgraph_set_call_stmt_including_clones, cgraph_create_edge_including_clones):\n+\tNew function\n+\t(cgraph_update_edges_for_call_stmt_node): New stati cfunction.\n+\t(cgraph_update_edges_for_call_stmt): Handle clones.\n+\t(cgraph_remove_node): Handle clone tree.\n+\t(cgraph_remove_node_and_inline_clones): New function.\n+\t(dump_cgraph_node): Dump clone tree.\n+\t(cgraph_clone_node): Handle clone tree.\n+\t(clone_function_name): Bring here from tree-inline.c\n+\t(cgraph_create_virtual_clone): New function.\n+\t* cgraph.h (ipa_replace_map): Move ehre from ipa.h\n+\t(cgraph_clone_info): New function\n+\t(strut cgraph_node): Add clone_info and new clone tree pointers.\n+\t(cgraph_remove_node_and_inline_clones, cgraph_set_call_stmt_including_clones,\n+\tcgraph_create_edge_including_clones, cgraph_create_virtual_clone): Declare.\n+\t(cgraph_function_versioning): Use VEC argument.\n+\t(compute_call_stmt_bb_frequency): Update prototype.\n+\t(cgraph_materialize_all_clones): New function.\n+\t* ipa-cp.c (ipcp_update_cloned_node): Remove.\n+\t(ipcp_create_replace_map): Update to VECtors.\n+\t(ipcp_update_callgraph): Use virtual clones.\n+\t(ipcp_update_bb_counts, ipcp_update_edges_counts): Remove.\n+\t(ipcp_update_profiling): Do not update local profiling.\n+\t(ipcp_insert_stage): Use VECtors and virtual clones.\n+\t* cgraphunit.c (verify_cgraph_node): Verify clone tree.\n+\t(clone_of_p): New function.\n+\t(cgraph_preserve_function_body_p): Use clone tree.\n+\t(cgraph_optimize): Materialize clones.\n+\t(cgraph_function_versioning): Update for VECtors.\n+\t(save_inline_function_body): Use clone tree.\n+\t(cgraph_materialize_clone, cgraph_materialize_all_clones): New functions.\n+\t* ipa-inline.c (cgraph_default_inline_p): Use analyzed flags.\n+\t* ipa.c: Include gimple.h.\n+\t(cgraph_remove_unreachable_nodes): Use clone tree.\n+\t* ipa-prop.c (ipa_note_param_call): Update call of compute_call_stmt_bb_frequency.\n+\t* ipa-prop.h (ipa_replace_map): Move to cgraph.h.\n+\t* tree-inline.c: Do not include varray.h; do not include gt-tree-inline.h\n+\t(copy_bb): Handle updating of clone tree; add new edge when new call\n+\tappears.\n+\t(expand_call_inline): Be strict about every call having edge.\n+\t(clone_fn_id_num, clone_function_name): Move to cgraph.c.\n+\t(delete_unreachable_blocks_update_callgraph): New function.\n+\t(tree_function_versioning): Use VECtors; always remove unreachable blocks\n+\tand fold conditionals.\n+\t* tree-inline.h: Do not include varray.h\n+\t(tree_function_versioning): Remove.\n+\t* Makefile.in (GTFILES): Remove tree-inline.c\n+\t* passes.c (do_per_function): Do only functions having body.\n+\t* ipa-struct-reorg.c (do_reorg_1, collect_data_accesses): Handle cone tree.\n+\n 2009-05-08  H.J. Lu  <hongjiu.lu@intel.com>\n \t    Andrew Morrow  <acm@google.com>\n "}, {"sha": "9a4d62b007a1882f6142c6797c9357a96fd0e6b9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -3342,7 +3342,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-ssa-propagate.c \\\n   $(srcdir)/tree-phinodes.c \\\n   $(srcdir)/ipa-reference.c \\\n-  $(srcdir)/tree-ssa-structalias.c $(srcdir)/tree-inline.c \\\n+  $(srcdir)/tree-ssa-structalias.c \\\n   $(srcdir)/tree-ssa-alias.h \\\n   @all_gtfiles@\n "}, {"sha": "2f68d94e3dd4960000ccb5fbd6063d9ff86d2023", "filename": "gcc/cgraph.c", "status": "modified", "additions": 317, "deletions": 20, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -78,7 +78,6 @@ The callgraph:\n #include \"target.h\"\n #include \"basic-block.h\"\n #include \"cgraph.h\"\n-#include \"varray.h\"\n #include \"output.h\"\n #include \"intl.h\"\n #include \"gimple.h\"\n@@ -628,7 +627,7 @@ cgraph_edge (struct cgraph_node *node, gimple call_stmt)\n }\n \n \n-/* Change field call_smt of edge E to NEW_STMT.  */\n+/* Change field call_stmt of edge E to NEW_STMT.  */\n \n void\n cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n@@ -655,6 +654,79 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n     }\n }\n \n+/* Like cgraph_set_call_stmt but walk the clone tree and update all clones sharing\n+   same function body.  */\n+\n+void\n+cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n+\t\t\t\t       gimple old_stmt, gimple new_stmt)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *edge = cgraph_edge (orig, old_stmt);\n+\n+  if (edge)\n+    cgraph_set_call_stmt (edge, new_stmt);\n+  if (orig->clones)\n+    for (node = orig->clones; node != orig;)\n+      {\n+\tstruct cgraph_edge *edge = cgraph_edge (node, old_stmt);\n+\tif (edge)\n+\t  cgraph_set_call_stmt (edge, new_stmt);\n+\tif (node->clones)\n+\t  node = node->clones;\n+\telse if (node->next_sibling_clone)\n+\t  node = node->next_sibling_clone;\n+\telse\n+\t  {\n+\t    while (node != orig && !node->next_sibling_clone)\n+\t      node = node->clone_of;\n+\t    if (node != orig)\n+\t      node = node->next_sibling_clone;\n+\t  }\n+      }\n+}\n+\n+/* Like cgraph_create_edge walk the clone tree and update all clones sharing\n+   same function body.  \n+   \n+   TODO: COUNT and LOOP_DEPTH should be properly distributed based on relative\n+   frequencies of the clones.\n+   */\n+\n+void\n+cgraph_create_edge_including_clones (struct cgraph_node *orig, struct cgraph_node *callee,\n+\t\t\t\t     gimple stmt, gcov_type count, int freq,\n+\t\t\t\t     int loop_depth,\n+\t\t\t\t     cgraph_inline_failed_t reason)\n+{\n+  struct cgraph_node *node;\n+\n+  cgraph_create_edge (orig, callee, stmt, count, freq, loop_depth)->inline_failed =\n+    reason;\n+\n+  if (orig->clones)\n+    for (node = orig->clones; node != orig;)\n+      {\n+        /* It is possible that we already constant propagated into the clone\n+\t   and turned indirect call into dirrect call.  */\n+        if (!cgraph_edge (node, stmt))\n+\t  cgraph_create_edge (node, callee, stmt, count, freq,\n+\t\t\t      loop_depth)->inline_failed = reason;\n+\n+\tif (node->clones)\n+\t  node = node->clones;\n+\telse if (node->next_sibling_clone)\n+\t  node = node->next_sibling_clone;\n+\telse\n+\t  {\n+\t    while (node != orig && !node->next_sibling_clone)\n+\t      node = node->clone_of;\n+\t    if (node != orig)\n+\t      node = node->next_sibling_clone;\n+\t  }\n+      }\n+}\n+\n /* Give initial reasons why inlining would fail on EDGE.  This gets either\n    nullified or usually overwritten by more precise reasons later.  */\n \n@@ -828,12 +900,12 @@ cgraph_redirect_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n /* Update or remove the corresponding cgraph edge if a GIMPLE_CALL\n    OLD_STMT changed into NEW_STMT.  */\n \n-void\n-cgraph_update_edges_for_call_stmt (gimple old_stmt, gimple new_stmt)\n+static void\n+cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n+\t\t\t\t\tgimple old_stmt, gimple new_stmt)\n {\n   tree new_call = (is_gimple_call (new_stmt)) ? gimple_call_fn (new_stmt) : 0;\n   tree old_call = (is_gimple_call (old_stmt)) ? gimple_call_fn (old_stmt) : 0;\n-  struct cgraph_node *node = cgraph_node (cfun->decl);\n \n   if (old_call != new_call)\n     {\n@@ -870,6 +942,34 @@ cgraph_update_edges_for_call_stmt (gimple old_stmt, gimple new_stmt)\n     }\n }\n \n+/* Update or remove the corresponding cgraph edge if a GIMPLE_CALL\n+   OLD_STMT changed into NEW_STMT.  */\n+\n+void\n+cgraph_update_edges_for_call_stmt (gimple old_stmt, gimple new_stmt)\n+{\n+  struct cgraph_node *orig = cgraph_node (cfun->decl);\n+  struct cgraph_node *node;\n+\n+  cgraph_update_edges_for_call_stmt_node (orig, old_stmt, new_stmt);\n+  if (orig->clones)\n+    for (node = orig->clones; node != orig;)\n+      {\n+        cgraph_update_edges_for_call_stmt_node (node, old_stmt, new_stmt);\n+\tif (node->clones)\n+\t  node = node->clones;\n+\telse if (node->next_sibling_clone)\n+\t  node = node->next_sibling_clone;\n+\telse\n+\t  {\n+\t    while (node != orig && !node->next_sibling_clone)\n+\t      node = node->clone_of;\n+\t    if (node != orig)\n+\t      node = node->next_sibling_clone;\n+\t  }\n+      }\n+}\n+\n \n /* Remove all callees from the node.  */\n \n@@ -998,24 +1098,100 @@ cgraph_remove_node (struct cgraph_node *node)\n   slot = htab_find_slot (cgraph_hash, node, NO_INSERT);\n   if (*slot == node)\n     {\n-      if (node->next_clone)\n-      {\n-\tstruct cgraph_node *new_node = node->next_clone;\n+      struct cgraph_node *next_inline_clone;\n \n-\t*slot = new_node;\n-\tnode->next_clone->prev_clone = NULL;\n-      }\n+      for (next_inline_clone = node->clones;\n+      \t   next_inline_clone && next_inline_clone->decl != node->decl;\n+\t   next_inline_clone = next_inline_clone->next_sibling_clone)\n+\t;\n+\n+      /* If there is inline clone of the node being removed, we need\n+         to put it into the position of removed node and reorganize all\n+\t other clones to be based on it.  */\n+      if (next_inline_clone)\n+\t{\n+\t  struct cgraph_node *n;\n+\t  struct cgraph_node *new_clones;\n+\n+\t  *slot = next_inline_clone;\n+\n+\t  /* Unlink inline clone from the list of clones of removed node.  */\n+\t  if (next_inline_clone->next_sibling_clone)\n+\t    next_inline_clone->next_sibling_clone->prev_sibling_clone\n+\t      = next_inline_clone->prev_sibling_clone;\n+\t  if (next_inline_clone->prev_sibling_clone)\n+\t    {\n+\t      next_inline_clone->prev_sibling_clone->next_sibling_clone\n+\t        = next_inline_clone->next_sibling_clone;\n+\t    }\n+\t  else\n+\t   node->clones = next_inline_clone->next_sibling_clone;\n+\n+\t  new_clones = node->clones;\n+\t  node->clones = NULL;\n+\n+\t  /* Copy clone info.  */\n+\t  next_inline_clone->clone = node->clone;\n+\n+\t  /* Now place it into clone tree at same level at NODE.  */\n+\t  next_inline_clone->clone_of = node->clone_of;\n+\t  next_inline_clone->prev_sibling_clone = NULL;\n+\t  next_inline_clone->next_sibling_clone = NULL;\n+\t  if (node->clone_of)\n+\t    {\n+\t      next_inline_clone->next_sibling_clone = node->clone_of->clones;\n+\t      node->clone_of->clones = next_inline_clone;\n+\t    }\n+\n+\t  /* Merge the clone list.  */\n+\t  if (new_clones)\n+\t    {\n+\t      if (!next_inline_clone->clones)\n+\t\tnext_inline_clone->clones = new_clones;\n+\t      else\n+\t\t{\n+\t\t  n = next_inline_clone->clones;\n+\t\t  while (n->next_sibling_clone)\n+\t\t    n =  n->next_sibling_clone;\n+\t\t  n->next_sibling_clone = new_clones;\n+\t\t  new_clones->prev_sibling_clone = n;\n+\t\t}\n+\t    }\n+\n+\t  /* Update clone_of pointers.  */\n+\t  n = new_clones;\n+\t  while (n)\n+\t    {\n+\t      n->clone_of = next_inline_clone;\n+\t      n = n->next_sibling_clone;\n+\t    }\n+\t}\n       else\n \t{\n \t  htab_clear_slot (cgraph_hash, slot);\n \t  kill_body = true;\n \t}\n+\n     }\n   else\n+    gcc_assert (node->clone_of);\n+  if (node->prev_sibling_clone)\n+    node->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n+  else if (node->clone_of)\n+    node->clone_of->clones = node->next_sibling_clone;\n+  if (node->next_sibling_clone)\n+    node->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n+  if (node->clones)\n     {\n-      node->prev_clone->next_clone = node->next_clone;\n-      if (node->next_clone)\n-\tnode->next_clone->prev_clone = node->prev_clone;\n+      struct cgraph_node *n;\n+\n+      for (n = node->clones; n->next_sibling_clone; n = n->next_sibling_clone)\n+\tn->clone_of = node->clone_of;\n+      n->clone_of = node->clone_of;\n+      n->next_sibling_clone = node->clone_of->clones;\n+      if (node->clone_of->clones)\n+\tnode->clone_of->clones->prev_sibling_clone = n;\n+      node->clone_of->clones = node->clones;\n     }\n \n   /* While all the clones are removed after being proceeded, the function\n@@ -1025,7 +1201,7 @@ cgraph_remove_node (struct cgraph_node *node)\n   if (!kill_body && *slot)\n     {\n       struct cgraph_node *n = (struct cgraph_node *) *slot;\n-      if (!n->next_clone && !n->global.inlined_to\n+      if (!n->clones && !n->clone_of && !n->global.inlined_to\n \t  && (cgraph_global_info_ready\n \t      && (TREE_ASM_WRITTEN (n->decl) || DECL_EXTERNAL (n->decl))))\n \tkill_body = true;\n@@ -1059,6 +1235,21 @@ cgraph_remove_node (struct cgraph_node *node)\n   free_nodes = node;\n }\n \n+/* Remove the node from cgraph.  */\n+\n+void\n+cgraph_remove_node_and_inline_clones (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e, *next;\n+  for (e = node->callees; e; e = next)\n+    {\n+      next = e->next_callee;\n+      if (!e->inline_failed)\n+        cgraph_remove_node_and_inline_clones (e->callee);\n+    }\n+  cgraph_remove_node (node);\n+}\n+\n /* Notify finalize_compilation_unit that given node is reachable.  */\n \n void\n@@ -1166,6 +1357,10 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" (inline copy in %s/%i)\",\n \t     cgraph_node_name (node->global.inlined_to),\n \t     node->global.inlined_to->uid);\n+  if (node->clone_of)\n+    fprintf (f, \" (clone of %s/%i)\",\n+\t     cgraph_node_name (node->clone_of),\n+\t     node->clone_of->uid);\n   if (cgraph_function_flags_ready)\n     fprintf (f, \" availability:%s\",\n \t     cgraph_availability_names [cgraph_function_body_availability (node)]);\n@@ -1382,6 +1577,7 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n   new_node->global = n->global;\n   new_node->rtl = n->rtl;\n   new_node->count = count;\n+  new_node->clone = n->clone;\n   if (n->count)\n     {\n       if (new_node->count > n->count)\n@@ -1402,16 +1598,117 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n     cgraph_clone_edge (e, new_node, e->call_stmt, count_scale, freq, loop_nest,\n \t\t       update_original);\n \n-  new_node->next_clone = n->next_clone;\n-  new_node->prev_clone = n;\n-  n->next_clone = new_node;\n-  if (new_node->next_clone)\n-    new_node->next_clone->prev_clone = new_node;\n+  new_node->next_sibling_clone = n->clones;\n+  if (n->clones)\n+    n->clones->prev_sibling_clone = new_node;\n+  n->clones = new_node;\n+  new_node->clone_of = n;\n \n   cgraph_call_node_duplication_hooks (n, new_node);\n   return new_node;\n }\n \n+/* Create a new name for omp child function.  Returns an identifier.  */\n+\n+static GTY(()) unsigned int clone_fn_id_num;\n+\n+static tree\n+clone_function_name (tree decl)\n+{\n+  tree name = DECL_ASSEMBLER_NAME (decl);\n+  size_t len = IDENTIFIER_LENGTH (name);\n+  char *tmp_name, *prefix;\n+\n+  prefix = XALLOCAVEC (char, len + strlen (\"_clone\") + 1);\n+  memcpy (prefix, IDENTIFIER_POINTER (name), len);\n+  strcpy (prefix + len, \"_clone\");\n+#ifndef NO_DOT_IN_LABEL\n+  prefix[len] = '.';\n+#elif !defined NO_DOLLAR_IN_LABEL\n+  prefix[len] = '$';\n+#endif\n+  ASM_FORMAT_PRIVATE_NAME (tmp_name, prefix, clone_fn_id_num++);\n+  return get_identifier (tmp_name);\n+}\n+\n+/* Create callgraph node clone with new declaration.  The actual body will\n+   be copied later at compilation stage.  \n+\n+   TODO: after merging in ipa-sra use function call notes instead of args_to_skip\n+   bitmap interface.\n+   */\n+struct cgraph_node *\n+cgraph_create_virtual_clone (struct cgraph_node *old_node,\n+\t\t\t     VEC(cgraph_edge_p,heap) *redirect_callers,\n+\t\t\t     VEC(ipa_replace_map_p,gc) *tree_map,\n+\t\t\t     bitmap args_to_skip)\n+{\n+  tree old_decl = old_node->decl;\n+  struct cgraph_node *new_node = NULL;\n+  tree new_decl;\n+  struct cgraph_node key, **slot;\n+  unsigned i;\n+  struct cgraph_edge *e;\n+\n+  gcc_assert  (tree_versionable_function_p (old_decl));\n+\n+  /* Make a new FUNCTION_DECL tree node */\n+  if (!args_to_skip)\n+    new_decl = copy_node (old_decl);\n+  else\n+    new_decl = build_function_decl_skip_args (old_decl, args_to_skip);\n+  DECL_STRUCT_FUNCTION (new_decl) = NULL;\n+\n+  /* Generate a new name for the new version. */\n+  DECL_NAME (new_decl) = clone_function_name (old_decl);\n+  SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n+  SET_DECL_RTL (new_decl, NULL);\n+\n+  new_node = cgraph_clone_node (old_node, old_node->count,\n+  \t\t\t\tCGRAPH_FREQ_BASE, 0, false);\n+  new_node->decl = new_decl;\n+  /* Update the properties.\n+     Make clone visible only within this translation unit.  Make sure\n+     that is not weak also.\n+     ??? We cannot use COMDAT linkage because there is no\n+     ABI support for this.  */\n+  DECL_EXTERNAL (new_node->decl) = 0;\n+  DECL_ONE_ONLY (new_node->decl) = 0;\n+  TREE_PUBLIC (new_node->decl) = 0;\n+  DECL_COMDAT (new_node->decl) = 0;\n+  DECL_WEAK (new_node->decl) = 0;\n+  new_node->clone.tree_map = tree_map;\n+  new_node->clone.args_to_skip = args_to_skip;\n+  new_node->local.externally_visible = 0;\n+  new_node->local.local = 1;\n+  new_node->lowered = true;\n+  new_node->reachable = true;\n+\n+  key.decl = new_decl;\n+  slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key, INSERT);\n+  gcc_assert (!*slot);\n+  *slot = new_node;\n+  if (assembler_name_hash)\n+    {\n+      void **aslot;\n+      tree name = DECL_ASSEMBLER_NAME (new_decl);\n+\n+      aslot = htab_find_slot_with_hash (assembler_name_hash, name,\n+\t\t\t\t\tdecl_assembler_name_hash (name),\n+\t\t\t\t\tINSERT);\n+      gcc_assert (!*aslot);\n+      *aslot = new_node;\n+    }\n+   for (i = 0; VEC_iterate (cgraph_edge_p, redirect_callers, i, e); i++)\n+     {\n+       /* Redirect calls to the old version node to point to its new\n+\t  version.  */\n+       cgraph_redirect_edge_callee (e, new_node);\n+     }\n+  \n+  return new_node;\n+}\n+\n /* NODE is no longer nested function; update cgraph accordingly.  */\n void\n cgraph_unnest_node (struct cgraph_node *node)"}, {"sha": "b94fcffbc77ae04447ffd9ad6aa4dda3a26654f5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -119,6 +119,29 @@ struct GTY(()) cgraph_rtl_info {\n    unsigned int preferred_incoming_stack_boundary;\n };\n \n+/* Represent which DECL tree (or reference to such tree)\n+   will be replaced by another tree while versioning.  */\n+struct GTY(()) ipa_replace_map\n+{\n+  /* The tree that will be replaced.  */\n+  tree old_tree;\n+  /* The new (replacing) tree.  */\n+  tree new_tree;\n+  /* True when a substitution should be done, false otherwise.  */\n+  bool replace_p;\n+  /* True when we replace a reference to old_tree.  */\n+  bool ref_p;\n+};\n+typedef struct ipa_replace_map *ipa_replace_map_p;\n+DEF_VEC_P(ipa_replace_map_p);\n+DEF_VEC_ALLOC_P(ipa_replace_map_p,gc);\n+\n+struct GTY(()) cgraph_clone_info\n+{\n+  VEC(ipa_replace_map_p,gc)* tree_map;\n+  bitmap args_to_skip;\n+};\n+\n /* The cgraph data structure.\n    Each function decl has assigned cgraph_node listing callees and callers.  */\n \n@@ -137,8 +160,10 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   /* Pointer to the next function in cgraph_nodes_queue.  */\n   struct cgraph_node *next_needed;\n   /* Pointer to the next clone.  */\n-  struct cgraph_node *next_clone;\n-  struct cgraph_node *prev_clone;\n+  struct cgraph_node *next_sibling_clone;\n+  struct cgraph_node *prev_sibling_clone;\n+  struct cgraph_node *clones;\n+  struct cgraph_node *clone_of;\n   /* For functions with many calls sites it holds map from call expression\n      to the edge to speed up cgraph_edge function.  */\n   htab_t GTY((param_is (struct cgraph_edge))) call_site_hash;\n@@ -148,6 +173,7 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   struct cgraph_local_info local;\n   struct cgraph_global_info global;\n   struct cgraph_rtl_info rtl;\n+  struct cgraph_clone_info clone;\n \n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n@@ -344,6 +370,7 @@ void debug_cgraph_node (struct cgraph_node *);\n void cgraph_insert_node_to_hashtable (struct cgraph_node *node);\n void cgraph_remove_edge (struct cgraph_edge *);\n void cgraph_remove_node (struct cgraph_node *);\n+void cgraph_remove_node_and_inline_clones (struct cgraph_node *);\n void cgraph_release_function_body (struct cgraph_node *);\n void cgraph_node_remove_callees (struct cgraph_node *node);\n struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n@@ -353,6 +380,11 @@ struct cgraph_node *cgraph_node (tree);\n struct cgraph_node *cgraph_node_for_asm (tree asmname);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, gimple);\n void cgraph_set_call_stmt (struct cgraph_edge *, gimple);\n+void cgraph_set_call_stmt_including_clones (struct cgraph_node *, gimple, gimple);\n+void cgraph_create_edge_including_clones (struct cgraph_node *,\n+\t\t\t\t\t  struct cgraph_node *,\n+\t\t\t\t\t  gimple, gcov_type, int, int,\n+\t\t\t\t\t  cgraph_inline_failed_t);\n void cgraph_update_edges_for_call_stmt (gimple, gimple);\n struct cgraph_local_info *cgraph_local_info (tree);\n struct cgraph_global_info *cgraph_global_info (tree);\n@@ -374,6 +406,10 @@ void cgraph_unnest_node (struct cgraph_node *);\n enum availability cgraph_function_body_availability (struct cgraph_node *);\n void cgraph_add_new_function (tree, bool);\n const char* cgraph_inline_failed_string (cgraph_inline_failed_t);\n+struct cgraph_node * cgraph_create_virtual_clone (struct cgraph_node *old_node,\n+\t\t\t                          VEC(cgraph_edge_p,heap)*,\n+\t\t\t                          VEC(ipa_replace_map_p,gc)* tree_map,\n+\t\t\t                          bitmap args_to_skip);\n \n /* In cgraphunit.c  */\n void cgraph_finalize_function (tree, bool);\n@@ -391,8 +427,9 @@ void cgraph_reset_static_var_maps (void);\n void init_cgraph (void);\n struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n \t\t\t\t\t\tVEC(cgraph_edge_p,heap)*,\n-\t\t\t\t\t\tvarray_type,\n+\t\t\t\t\t\tVEC(ipa_replace_map_p,gc)*,\n \t\t\t\t\t\tbitmap);\n+void tree_function_versioning (tree, tree, VEC (ipa_replace_map_p,gc)*, bool, bitmap);\n void cgraph_analyze_function (struct cgraph_node *);\n struct cgraph_node *save_inline_function_body (struct cgraph_node *);\n void record_references_in_initializer (tree);\n@@ -421,10 +458,11 @@ struct cgraph_2edge_hook_list *cgraph_add_edge_duplication_hook (cgraph_2edge_ho\n void cgraph_remove_edge_duplication_hook (struct cgraph_2edge_hook_list *);\n struct cgraph_2node_hook_list *cgraph_add_node_duplication_hook (cgraph_2node_hook, void *);\n void cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *);\n+void cgraph_materialize_all_clones (void);\n \n /* In cgraphbuild.c  */\n unsigned int rebuild_cgraph_edges (void);\n-int compute_call_stmt_bb_frequency (basic_block bb);\n+int compute_call_stmt_bb_frequency (tree, basic_block bb);\n \n /* In ipa.c  */\n bool cgraph_remove_unreachable_nodes (bool, FILE *);"}, {"sha": "fb56ce5354ae3b0a45c3fbd480b8933989bb383d", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -81,11 +81,14 @@ record_reference (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n /* Computes the frequency of the call statement so that it can be stored in\n    cgraph_edge.  BB is the basic block of the call statement.  */\n int\n-compute_call_stmt_bb_frequency (basic_block bb)\n+compute_call_stmt_bb_frequency (tree decl, basic_block bb)\n {\n   int entry_freq = ENTRY_BLOCK_PTR->frequency;\n   int freq = bb->frequency;\n \n+  if (profile_status_for_function (DECL_STRUCT_FUNCTION (decl)) == PROFILE_ABSENT)\n+    return CGRAPH_FREQ_BASE;\n+\n   if (!entry_freq)\n     entry_freq = 1, freq++;\n \n@@ -121,7 +124,7 @@ build_cgraph_edges (void)\n \t    size_t i;\n \t    size_t n = gimple_call_num_args (stmt);\n \t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t\tbb->count, compute_call_stmt_bb_frequency (bb),\n+\t\t\t\tbb->count, compute_call_stmt_bb_frequency (current_function_decl, bb),\n \t\t\t\tbb->loop_depth);\n \t    for (i = 0; i < n; i++)\n \t      walk_tree (gimple_call_arg_ptr (stmt, i), record_reference,\n@@ -224,7 +227,9 @@ rebuild_cgraph_edges (void)\n \n \tif (is_gimple_call (stmt) && (decl = gimple_call_fndecl (stmt)))\n \t  cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t      bb->count, compute_call_stmt_bb_frequency (bb),\n+\t\t\t      bb->count,\n+\t\t\t      compute_call_stmt_bb_frequency\n+\t\t\t        (current_function_decl, bb),\n \t\t\t      bb->loop_depth);\n \n       }"}, {"sha": "9366ebe28693dff44767dc9f351cd9568d671f68", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 218, "deletions": 18, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -548,12 +548,20 @@ cgraph_mark_if_needed (tree decl)\n     cgraph_mark_needed_node (node);\n }\n \n+/* Return TRUE if NODE2 is equivalent to NODE or its clone.  */\n+static bool\n+clone_of_p (struct cgraph_node *node, struct cgraph_node *node2)\n+{\n+  while (node != node2 && node2)\n+    node2 = node2->clone_of;\n+  return node2 != NULL;\n+}\n+\n /* Verify cgraph nodes of given cgraph node.  */\n void\n verify_cgraph_node (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n-  struct cgraph_node *main_clone;\n   struct function *this_cfun = DECL_STRUCT_FUNCTION (node->decl);\n   struct function *saved_cfun = cfun;\n   basic_block this_block;\n@@ -629,17 +637,53 @@ verify_cgraph_node (struct cgraph_node *node)\n       error_found = true;\n     }\n \n-  for (main_clone = cgraph_node (node->decl); main_clone;\n-       main_clone = main_clone->next_clone)\n-    if (main_clone == node)\n-      break;\n   if (!cgraph_node (node->decl))\n     {\n       error (\"node not found in cgraph_hash\");\n       error_found = true;\n     }\n \n-  if (node->analyzed\n+  if (node->clone_of)\n+    {\n+      struct cgraph_node *n;\n+      for (n = node->clone_of->clones; n; n = n->next_sibling_clone)\n+        if (n == node)\n+\t  break;\n+      if (!n)\n+\t{\n+\t  error (\"node has wrong clone_of\");\n+\t  error_found = true;\n+\t}\n+    }\n+  if (node->clones)\n+    {\n+      struct cgraph_node *n;\n+      for (n = node->clones; n; n = n->next_sibling_clone)\n+        if (n->clone_of != node)\n+\t  break;\n+      if (n)\n+\t{\n+\t  error (\"node has wrong clone list\");\n+\t  error_found = true;\n+\t}\n+    }\n+  if ((node->prev_sibling_clone || node->next_sibling_clone) && !node->clone_of)\n+    {\n+       error (\"node is in clone list but it is not clone\");\n+       error_found = true;\n+    }\n+  if (!node->prev_sibling_clone && node->clone_of && node->clone_of->clones != node)\n+    {\n+      error (\"node has wrong prev_clone pointer\");\n+      error_found = true;\n+    }\n+  if (node->prev_sibling_clone && node->prev_sibling_clone->next_sibling_clone != node)\n+    {\n+      error (\"double linked list of clones corrupted\");\n+      error_found = true;\n+    }\n+\n+  if (node->analyzed && gimple_has_body_p (node->decl)\n       && !TREE_ASM_WRITTEN (node->decl)\n       && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to))\n     {\n@@ -668,8 +712,8 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t    debug_gimple_stmt (stmt);\n \t\t\t    error_found = true;\n \t\t\t  }\n-\t\t\tif (e->callee->decl != cgraph_node (decl)->decl\n-\t\t\t    && e->inline_failed)\n+\t\t\tif (!clone_of_p (cgraph_node (decl), e->callee)\n+\t\t\t    && !e->callee->global.inlined_to)\n \t\t\t  {\n \t\t\t    error (\"edge points to wrong declaration:\");\n \t\t\t    debug_tree (e->callee->decl);\n@@ -1227,9 +1271,9 @@ cgraph_preserve_function_body_p (tree decl)\n \n   gcc_assert (cgraph_global_info_ready);\n   /* Look if there is any clone around.  */\n-  for (node = cgraph_node (decl); node; node = node->next_clone)\n-    if (node->global.inlined_to)\n-      return true;\n+  node = cgraph_node (decl);\n+  if (node->clones)\n+    return true;\n   return false;\n }\n \n@@ -1312,6 +1356,7 @@ cgraph_optimize (void)\n   verify_cgraph ();\n #endif\n \n+  cgraph_materialize_all_clones ();\n   cgraph_mark_functions_to_output ();\n \n   cgraph_state = CGRAPH_STATE_EXPANSION;\n@@ -1528,7 +1573,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n struct cgraph_node *\n cgraph_function_versioning (struct cgraph_node *old_version_node,\n \t\t\t    VEC(cgraph_edge_p,heap) *redirect_callers,\n-\t\t\t    varray_type tree_map,\n+\t\t\t    VEC (ipa_replace_map_p,gc)* tree_map,\n \t\t\t    bitmap args_to_skip)\n {\n   tree old_decl = old_version_node->decl;\n@@ -1581,19 +1626,50 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n struct cgraph_node *\n save_inline_function_body (struct cgraph_node *node)\n {\n-  struct cgraph_node *first_clone;\n+  struct cgraph_node *first_clone, *n;\n \n   gcc_assert (node == cgraph_node (node->decl));\n \n   cgraph_lower_function (node);\n \n-  first_clone = node->next_clone;\n+  first_clone = node->clones;\n \n   first_clone->decl = copy_node (node->decl);\n-  node->next_clone = NULL;\n-  first_clone->prev_clone = NULL;\n   cgraph_insert_node_to_hashtable (first_clone);\n   gcc_assert (first_clone == cgraph_node (first_clone->decl));\n+  if (first_clone->next_sibling_clone)\n+    {\n+      for (n = first_clone->next_sibling_clone; n->next_sibling_clone; n = n->next_sibling_clone)\n+        n->clone_of = first_clone;\n+      n->clone_of = first_clone;\n+      n->next_sibling_clone = first_clone->clones;\n+      if (first_clone->clones)\n+        first_clone->clones->prev_sibling_clone = n;\n+      first_clone->clones = first_clone->next_sibling_clone;\n+      first_clone->next_sibling_clone->prev_sibling_clone = NULL;\n+      first_clone->next_sibling_clone = NULL;\n+      gcc_assert (!first_clone->prev_sibling_clone);\n+    }\n+  first_clone->clone_of = NULL;\n+  node->clones = NULL;\n+\n+  if (first_clone->clones)\n+    for (n = first_clone->clones; n != first_clone;)\n+      {\n+        gcc_assert (n->decl == node->decl);\n+\tn->decl = first_clone->decl;\n+\tif (n->clones)\n+\t  n = n->clones;\n+\telse if (n->next_sibling_clone)\n+\t  n = n->next_sibling_clone;\n+\telse\n+\t  {\n+\t    while (n != first_clone && !n->next_sibling_clone)\n+\t      n = n->clone_of;\n+\t    if (n != first_clone)\n+\t      n = n->next_sibling_clone;\n+\t  }\n+      }\n \n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n   tree_function_versioning (node->decl, first_clone->decl, NULL, true, NULL);\n@@ -1603,12 +1679,136 @@ save_inline_function_body (struct cgraph_node *node)\n   TREE_PUBLIC (first_clone->decl) = 0;\n   DECL_COMDAT (first_clone->decl) = 0;\n \n-  for (node = first_clone->next_clone; node; node = node->next_clone)\n-    node->decl = first_clone->decl;\n #ifdef ENABLE_CHECKING\n   verify_cgraph_node (first_clone);\n #endif\n   return first_clone;\n }\n \n+/* Given virtual clone, turn it into actual clone.  */\n+static void\n+cgraph_materialize_clone (struct cgraph_node *node)\n+{\n+  bitmap_obstack_initialize (NULL);\n+  /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n+  tree_function_versioning (node->clone_of->decl, node->decl,\n+  \t\t\t    node->clone.tree_map, true,\n+\t\t\t    node->clone.args_to_skip);\n+\n+  /* Function is no longer clone.  */\n+  if (node->next_sibling_clone)\n+    node->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n+  if (node->prev_sibling_clone)\n+    node->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n+  else\n+    node->clone_of->clones = node->next_sibling_clone;\n+  node->next_sibling_clone = NULL;\n+  node->prev_sibling_clone = NULL;\n+  node->clone_of = NULL;\n+  bitmap_obstack_release (NULL);\n+}\n+\n+/* Once all functions from compilation unit are in memory, produce all clones\n+   and update all calls.\n+   We might also do this on demand if we don't want to bring all functions to\n+   memory prior compilation, but current WHOPR implementation does that and it is\n+   is bit easier to keep everything right in this order.  */\n+void\n+cgraph_materialize_all_clones (void)\n+{\n+  struct cgraph_node *node;\n+  bool stabilized = false;\n+\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"Materializing clones\\n\");\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n+\n+  /* We can also do topological order, but number of iterations should be\n+     bounded by number of IPA passes since single IPA pass is probably not\n+     going to create clones of clones it created itself.  */\n+  while (!stabilized)\n+    {\n+      stabilized = true;\n+      for (node = cgraph_nodes; node; node = node->next)\n+        {\n+\t  if (node->clone_of && node->decl != node->clone_of->decl\n+\t      && !gimple_has_body_p (node->decl))\n+\t    {\n+\t      if (gimple_has_body_p (node->clone_of->decl))\n+\t        {\n+\t\t  if (cgraph_dump_file)\n+\t\t    fprintf (cgraph_dump_file, \"  clonning %s to %s\",\n+\t\t\t     cgraph_node_name (node->clone_of),\n+\t\t\t     cgraph_node_name (node));\n+\t\t  cgraph_materialize_clone (node);\n+\t        }\n+\t      else\n+\t\tstabilized = false;\n+\t    }\n+\t}\n+    }\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"Updating call sites\\n\");\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->analyzed && gimple_has_body_p (node->decl)\n+        && (!node->clone_of || node->clone_of->decl != node->decl))\n+      {\n+        struct cgraph_edge *e;\n+\n+\tcurrent_function_decl = node->decl;\n+        push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\tfor (e = node->callees; e; e = e->next_callee)\n+\t  {\n+\t    tree decl = gimple_call_fndecl (e->call_stmt);\n+\t    if (decl != e->callee->decl)\n+\t      {\n+\t\tgimple new_stmt;\n+\t\tgimple_stmt_iterator gsi;\n+\t\t\n+\t\tif (cgraph_dump_file)\n+\t\t  {\n+\t\t    fprintf (cgraph_dump_file, \"updating call of %s in %s:\",\n+\t\t             cgraph_node_name (node),\n+\t\t\t     cgraph_node_name (e->callee));\n+      \t\t    print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n+\t\t  }\n+\n+\t\tif (e->callee->clone.args_to_skip)\n+\t\t  new_stmt = gimple_call_copy_skip_args (e->call_stmt,\n+\t\t\t\t\t\t\t e->callee->clone.args_to_skip);\n+\t\telse\n+\t\t  new_stmt = e->call_stmt;\n+\t\tif (gimple_vdef (new_stmt)\n+\t\t    && TREE_CODE (gimple_vdef (new_stmt)) == SSA_NAME)\n+\t\t  SSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n+                gimple_call_set_fndecl (new_stmt, e->callee->decl);\n+\n+\t\tgsi = gsi_for_stmt (e->call_stmt);\n+\t\tgsi_replace (&gsi, new_stmt, true);\n+\n+\t\t/* Update EH information too, just in case.  */\n+\t\tif (!stmt_could_throw_p (new_stmt)\n+\t\t    && lookup_stmt_eh_region (new_stmt))\n+\t\t  remove_stmt_from_eh_region (new_stmt);\n+\n+\t\tcgraph_set_call_stmt_including_clones (node, e->call_stmt, new_stmt);\n+\n+\t\tif (cgraph_dump_file)\n+\t\t  {\n+\t\t    fprintf (cgraph_dump_file, \"  updated to:\");\n+      \t\t    print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n+\t\t  }\n+\t      }\n+\t  }\n+\tpop_cfun ();\n+\tcurrent_function_decl = NULL;\n+#ifdef ENABLE_CHECKING\n+        verify_cgraph_node (node);\n+#endif\n+      }\n+  cgraph_remove_unreachable_nodes (false, cgraph_dump_file);\n+}\n+\n #include \"gt-cgraphunit.h\""}, {"sha": "d6390b089a90a7ba2fb614869668b68497a924c1", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 22, "deletions": 192, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -186,34 +186,6 @@ ipcp_analyze_node (struct cgraph_node *node)\n   ipa_detect_param_modifications (node);\n }\n \n-/* Recompute all local information since node might've got new\n-   direct calls after cloning.  */\n-static void\n-ipcp_update_cloned_node (struct cgraph_node *new_node)\n-{\n-  /* We might've introduced new direct calls.  */\n-  push_cfun (DECL_STRUCT_FUNCTION (new_node->decl));\n-  current_function_decl = new_node->decl;\n-  rebuild_cgraph_edges ();\n-\n-  /* Indirect inlinng rely on fact that we've already analyzed\n-     the body..  */\n-  if (flag_indirect_inlining)\n-    {\n-      struct cgraph_edge *cs;\n-\n-      ipcp_analyze_node (new_node);\n-\n-      for (cs = new_node->callees; cs; cs = cs->next_callee)\n-\t{\n-\t  ipa_count_arguments (cs);\n-\t  ipa_compute_jump_functions (cs);\n-\t}\n-    }\n-  pop_cfun ();\n-  current_function_decl = NULL;\n-}\n-\n /* Return scale for NODE.  */\n static inline gcov_type\n ipcp_get_node_scale (struct cgraph_node *node)\n@@ -756,98 +728,6 @@ ipcp_print_call_profile_counts (FILE * f)\n     }\n }\n \n-/* Print all counts and probabilities of cfg edges of all functions.  */\n-static void\n-ipcp_print_edge_profiles (FILE * f)\n-{\n-  struct cgraph_node *node;\n-  basic_block bb;\n-  edge_iterator ei;\n-  edge e;\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      fprintf (f, \"function %s: \\n\", cgraph_node_name (node));\n-      if (node->analyzed)\n-\t{\n-\t  bb =\n-\t    ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (node->decl));\n-\t  fprintf (f, \"ENTRY: \");\n-\t  fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n-\t\t   \" %d\\n\", (HOST_WIDE_INT) bb->count, bb->frequency);\n-\n-\t  if (bb->succs)\n-\t    FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    {\n-\t      if (e->dest ==\n-\t\t  EXIT_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION\n-\t\t\t\t\t       (node->decl)))\n-\t\tfprintf (f, \"edge ENTRY -> EXIT,  Count\");\n-\t      else\n-\t\tfprintf (f, \"edge ENTRY -> %d,  Count\", e->dest->index);\n-\t      fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n-\t\t       \" Prob %d\\n\", (HOST_WIDE_INT) e->count,\n-\t\t       e->probability);\n-\t    }\n-\t  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n-\t  {\n-\t    fprintf (f, \"bb[%d]: \", bb->index);\n-\t    fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n-\t\t     \" %d\\n\", (HOST_WIDE_INT) bb->count, bb->frequency);\n-\t    FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    {\n-\t      if (e->dest ==\n-\t\t  EXIT_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION\n-\t\t\t\t\t       (node->decl)))\n-\t\tfprintf (f, \"edge %d -> EXIT,  Count\", e->src->index);\n-\t      else\n-\t\tfprintf (f, \"edge %d -> %d,  Count\", e->src->index,\n-\t\t\t e->dest->index);\n-\t      fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC \" Prob %d\\n\",\n-\t\t       (HOST_WIDE_INT) e->count, e->probability);\n-\t    }\n-\t  }\n-\t}\n-    }\n-}\n-\n-/* Print counts and frequencies for all basic blocks of all functions.  */\n-static void\n-ipcp_print_bb_profiles (FILE * f)\n-{\n-  basic_block bb;\n-  struct cgraph_node *node;\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      fprintf (f, \"function %s: \\n\", cgraph_node_name (node));\n-      if (node->analyzed)\n-\t{\n-\t  bb =\n-\t    ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (node->decl));\n-\t  fprintf (f, \"ENTRY: Count\");\n-\t  fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n-\t\t   \" Frequency  %d\\n\", (HOST_WIDE_INT) bb->count,\n-\t\t   bb->frequency);\n-\n-\t  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n-\t  {\n-\t    fprintf (f, \"bb[%d]: Count\", bb->index);\n-\t    fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n-\t\t     \" Frequency %d\\n\", (HOST_WIDE_INT) bb->count,\n-\t\t     bb->frequency);\n-\t  }\n-\t  bb =\n-\t    EXIT_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (node->decl));\n-\t  fprintf (f, \"EXIT: Count\");\n-\t  fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n-\t\t   \" Frequency %d\\n\", (HOST_WIDE_INT) bb->count,\n-\t\t   bb->frequency);\n-\n-\t}\n-    }\n-}\n-\n /* Print profile info for all functions.  */\n static void\n ipcp_print_profile_data (FILE * f)\n@@ -856,10 +736,6 @@ ipcp_print_profile_data (FILE * f)\n   ipcp_print_func_profile_counts (f);\n   fprintf (f, \"\\nCS COUNTS stage:\\n\");\n   ipcp_print_call_profile_counts (f);\n-  fprintf (f, \"\\nBB COUNTS and FREQUENCIES :\\n\");\n-  ipcp_print_bb_profiles (f);\n-  fprintf (f, \"\\nCFG EDGES COUNTS and PROBABILITIES :\\n\");\n-  ipcp_print_edge_profiles (f);\n }\n \n /* Build and initialize ipa_replace_map struct according to LAT. This struct is\n@@ -872,7 +748,7 @@ ipcp_create_replace_map (tree parm_tree, struct ipcp_lattice *lat)\n   struct ipa_replace_map *replace_map;\n   tree const_val;\n \n-  replace_map = XCNEW (struct ipa_replace_map);\n+  replace_map = GGC_NEW (struct ipa_replace_map);\n   const_val = build_const_val (lat, TREE_TYPE (parm_tree));\n   if (dump_file)\n     {\n@@ -959,25 +835,7 @@ ipcp_update_callgraph (void)\n \tfor (cs = node->callers; cs; cs = next)\n \t  {\n \t    next = cs->next_caller;\n-\t    if (ipcp_node_is_clone (cs->caller) || !ipcp_need_redirect_p (cs))\n-\t      {\n-\t\tgimple new_stmt;\n-\t\tgimple_stmt_iterator gsi;\n-\n-\t\tcurrent_function_decl = cs->caller->decl;\n-\t        push_cfun (DECL_STRUCT_FUNCTION (cs->caller->decl));\n-\t\t\n-\t\tnew_stmt = gimple_call_copy_skip_args (cs->call_stmt,\n-\t\t\t\t\t\t       args_to_skip);\n-\t\tif (gimple_vdef (new_stmt))\n-\t\t  SSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n-\t\tgsi = gsi_for_stmt (cs->call_stmt);\n-\t\tgsi_replace (&gsi, new_stmt, true);\n-\t\tcgraph_set_call_stmt (cs, new_stmt);\n-\t        pop_cfun ();\n-\t\tcurrent_function_decl = NULL;\n-\t      }\n-\t    else\n+\t    if (!ipcp_node_is_clone (cs->caller) && ipcp_need_redirect_p (cs))\n \t      {\n \t\tcgraph_redirect_edge_callee (cs, orig_node);\n \t\tgimple_call_set_fndecl (cs->call_stmt, orig_node->decl);\n@@ -986,29 +844,6 @@ ipcp_update_callgraph (void)\n       }\n }\n \n-/* Update all cfg basic blocks in NODE according to SCALE.  */\n-static void\n-ipcp_update_bb_counts (struct cgraph_node *node, gcov_type scale)\n-{\n-  basic_block bb;\n-\n-  FOR_ALL_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n-    bb->count = bb->count * scale / REG_BR_PROB_BASE;\n-}\n-\n-/* Update all cfg edges in NODE according to SCALE.  */\n-static void\n-ipcp_update_edges_counts (struct cgraph_node *node, gcov_type scale)\n-{\n-  basic_block bb;\n-  edge_iterator ei;\n-  edge e;\n-\n-  FOR_ALL_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n-    FOR_EACH_EDGE (e, ei, bb->succs)\n-    e->count = e->count * scale / REG_BR_PROB_BASE;\n-}\n-\n /* Update profiling info for versioned functions and the functions they were\n    versioned from.  */\n static void\n@@ -1032,10 +867,6 @@ ipcp_update_profiling (void)\n \t    cs->count = cs->count * scale / REG_BR_PROB_BASE;\n \t  for (cs = orig_node->callees; cs; cs = cs->next_callee)\n \t    cs->count = cs->count * scale_complement / REG_BR_PROB_BASE;\n-\t  ipcp_update_bb_counts (node, scale);\n-\t  ipcp_update_bb_counts (orig_node, scale_complement);\n-\t  ipcp_update_edges_counts (node, scale);\n-\t  ipcp_update_edges_counts (orig_node, scale_complement);\n \t}\n     }\n }\n@@ -1160,13 +991,13 @@ ipcp_insert_stage (void)\n   struct cgraph_node *node, *node1 = NULL;\n   int i;\n   VEC (cgraph_edge_p, heap) * redirect_callers;\n-  varray_type replace_trees;\n+  VEC (ipa_replace_map_p,gc)* replace_trees;\n   int node_callers, count;\n   tree parm_tree;\n   struct ipa_replace_map *replace_param;\n   fibheap_t heap;\n-  long overall_insns = 0, new_insns = 0;\n-  long max_new_insns;\n+  long overall_size = 0, new_size = 0;\n+  long max_new_size;\n \n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n@@ -1180,13 +1011,13 @@ ipcp_insert_stage (void)\n       {\n \tif (node->count > max_count)\n \t  max_count = node->count;\n-\toverall_insns += node->local.inline_summary.self_insns;\n+\toverall_size += node->local.inline_summary.self_insns;\n       }\n \n-  max_new_insns = overall_insns;\n-  if (max_new_insns < PARAM_VALUE (PARAM_LARGE_UNIT_INSNS))\n-    max_new_insns = PARAM_VALUE (PARAM_LARGE_UNIT_INSNS);\n-  max_new_insns = max_new_insns * PARAM_VALUE (PARAM_IPCP_UNIT_GROWTH) / 100 + 1;\n+  max_new_size = overall_size;\n+  if (max_new_size < PARAM_VALUE (PARAM_LARGE_UNIT_INSNS))\n+    max_new_size = PARAM_VALUE (PARAM_LARGE_UNIT_INSNS);\n+  max_new_size = max_new_size * PARAM_VALUE (PARAM_IPCP_UNIT_GROWTH) / 100 + 1;\n \n   /* First collect all functions we proved to have constant arguments to heap.  */\n   heap = fibheap_new ();\n@@ -1220,7 +1051,7 @@ ipcp_insert_stage (void)\n \n       growth = ipcp_estimate_growth (node);\n \n-      if (new_insns + growth > max_new_insns)\n+      if (new_size + growth > max_new_size)\n \tbreak;\n       if (growth\n \t  && optimize_function_for_size_p (DECL_STRUCT_FUNCTION (node->decl)))\n@@ -1230,7 +1061,7 @@ ipcp_insert_stage (void)\n \t  continue;\n \t}\n \n-      new_insns += growth;\n+      new_size += growth;\n \n       /* Look if original function becomes dead after clonning.  */\n       for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n@@ -1242,9 +1073,8 @@ ipcp_insert_stage (void)\n       info = IPA_NODE_REF (node);\n       count = ipa_get_param_count (info);\n \n-      VARRAY_GENERIC_PTR_INIT (replace_trees, ipcp_const_param_count (node),\n-\t\t\t\t\"replace_trees\");\n-      args_to_skip = BITMAP_ALLOC (NULL);\n+      replace_trees = VEC_alloc (ipa_replace_map_p, gc, 1);\n+      args_to_skip = BITMAP_GGC_ALLOC ();\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n@@ -1263,7 +1093,7 @@ ipcp_insert_stage (void)\n \t    {\n \t      replace_param =\n \t\tipcp_create_replace_map (parm_tree, lat);\n-\t      VARRAY_PUSH_GENERIC_PTR (replace_trees, replace_param);\n+\t      VEC_safe_push (ipa_replace_map_p, gc, replace_trees, replace_param);\n \t      bitmap_set_bit (args_to_skip, i);\n \t    }\n \t}\n@@ -1279,20 +1109,20 @@ ipcp_insert_stage (void)\n       /* Redirecting all the callers of the node to the\n          new versioned node.  */\n       node1 =\n-\tcgraph_function_versioning (node, redirect_callers, replace_trees,\n-\t\t\t\t    args_to_skip);\n-      BITMAP_FREE (args_to_skip);\n+\tcgraph_create_virtual_clone (node, redirect_callers, replace_trees,\n+\t\t\t\t     args_to_skip);\n+      args_to_skip = NULL;\n       VEC_free (cgraph_edge_p, heap, redirect_callers);\n-      VARRAY_CLEAR (replace_trees);\n+      replace_trees = NULL;\n+\n       if (node1 == NULL)\n \tcontinue;\n       if (dump_file)\n \tfprintf (dump_file, \"versioned function %s with growth %i, overall %i\\n\",\n-\t\t cgraph_node_name (node), (int)growth, (int)new_insns);\n+\t\t cgraph_node_name (node), (int)growth, (int)new_size);\n       ipcp_init_cloned_node (node, node1);\n \n-      /* We've possibly introduced direct calls.  */\n-      ipcp_update_cloned_node (node1);\n+      /* TODO: We can use indirect inlning info to produce new calls.  */\n \n       if (dump_file)\n \tdump_function_to_file (node1->decl, dump_file, dump_flags);"}, {"sha": "99640bfdb552ca7c085ebb1c867efd0d76dad5a0", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -433,7 +433,7 @@ cgraph_default_inline_p (struct cgraph_node *n, cgraph_inline_failed_t *reason)\n       return false;\n     }\n \n-  if (!DECL_STRUCT_FUNCTION (decl)->cfg)\n+  if (!n->analyzed)\n     {\n       if (reason)\n \t*reason = CIF_BODY_NOT_AVAILABLE;"}, {"sha": "f4fa37d5a05dfb8e29f167480b0e799f021add18", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -653,7 +653,7 @@ ipa_note_param_call (struct ipa_node_params *info, int formal_id,\n   note->formal_id = formal_id;\n   note->stmt = stmt;\n   note->count = bb->count;\n-  note->frequency = compute_call_stmt_bb_frequency (bb);\n+  note->frequency = compute_call_stmt_bb_frequency (current_function_decl, bb);\n \n   note->next = info->param_calls;\n   info->param_calls = note;"}, {"sha": "c4c1ccc162aba43a4623f9a9d8277f9ba0b03af9", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -99,20 +99,6 @@ struct ipcp_lattice\n   tree constant;\n };\n \n-/* Represent which DECL tree (or reference to such tree)\n-   will be replaced by another tree while versioning.  */\n-struct ipa_replace_map\n-{\n-  /* The tree that will be replaced.  */\n-  tree old_tree;\n-  /* The new (replacing) tree.  */\n-  tree new_tree;\n-  /* True when a substitution should be done, false otherwise.  */\n-  bool replace_p;\n-  /* True when we replace a reference to old_tree.  */\n-  bool ref_p;\n-};\n-\n /* Each instance of the following  structure describes a statement that calls a\n    function parameter.  Those referring  to statements within the same function\n    are linked in a list.  */"}, {"sha": "6468d77f06a4abec16dbe00a50958ce4eb828044", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -3641,7 +3641,7 @@ do_reorg_1 (void)\n   bitmap_obstack_initialize (NULL);\n \n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed && node->decl && !node->next_clone)\n+    if (node->analyzed && node->decl)\n       {\n \tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \tcurrent_function_decl = node->decl;\n@@ -3809,8 +3809,7 @@ collect_data_accesses (void)\n \t{\n \t  struct function *func = DECL_STRUCT_FUNCTION (c_node->decl);\n \n-\t  if (!c_node->next_clone)\n-\t    collect_accesses_in_func (func);\n+\t  collect_accesses_in_func (func);\n \t  exclude_alloc_and_field_accs (c_node);\n \t}\n     }"}, {"sha": "686ca9e1348085a1af5fbd589a86d5c04e08ab3f", "filename": "gcc/ipa.c", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"tree-pass.h\"\n #include \"timevar.h\"\n+#include \"gimple.h\"\n #include \"ggc.h\"\n \n /* Fill array order with all nodes with output flag set in the reverse\n@@ -143,6 +144,12 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t    e->callee->aux = first;\n \t    first = e->callee;\n \t  }\n+      while (node->clone_of && !node->clone_of->aux && !gimple_has_body_p (node->decl))\n+        {\n+\t  node = node->clone_of;\n+\t  node->aux = first;\n+\t  first = node;\n+\t}\n     }\n \n   /* Remove unreachable nodes.  Extern inline functions need special care;\n@@ -168,25 +175,29 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t    {\n \t      struct cgraph_edge *e;\n \n+\t      /* See if there is reachable caller.  */\n \t      for (e = node->callers; e; e = e->next_caller)\n \t\tif (e->caller->aux)\n \t\t  break;\n+\n+\t      /* If so, we need to keep node in the callgraph.  */\n \t      if (e || node->needed)\n \t\t{\n \t\t  struct cgraph_node *clone;\n \n-\t\t  for (clone = node->next_clone; clone;\n-\t\t       clone = clone->next_clone)\n+\t\t  /* If there are still clones, we must keep body around.\n+\t\t     Otherwise we can just remove the body but keep the clone.  */\n+\t\t  for (clone = node->clones; clone;\n+\t\t       clone = clone->next_sibling_clone)\n \t\t    if (clone->aux)\n \t\t      break;\n \t\t  if (!clone)\n \t\t    {\n \t\t      cgraph_release_function_body (node);\n+\t\t      cgraph_node_remove_callees (node);\n \t\t      node->analyzed = false;\n+\t\t      node->local.inlinable = false;\n \t\t    }\n-\t\t  cgraph_node_remove_callees (node);\n-\t\t  node->analyzed = false;\n-\t\t  node->local.inlinable = false;\n \t\t}\n \t      else\n \t\tcgraph_remove_node (node);\n@@ -195,7 +206,18 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t}\n     }\n   for (node = cgraph_nodes; node; node = node->next)\n-    node->aux = NULL;\n+    {\n+      /* Inline clones might be kept around so their materializing allows further\n+         cloning.  If the function the clone is inlined into is removed, we need\n+         to turn it into normal cone.  */\n+      if (node->global.inlined_to\n+\t  && !node->callers)\n+\t{\n+\t  gcc_assert (node->clones);\n+\t  node->global.inlined_to = false;\n+\t}\n+      node->aux = NULL;\n+    }\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();\n #endif"}, {"sha": "7a39ac70bc18417c2c36c488a2fb8fdb8f8cfa8f", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -846,7 +846,7 @@ do_per_function (void (*callback) (void *data), void *data)\n     {\n       struct cgraph_node *node;\n       for (node = cgraph_nodes; node; node = node->next)\n-\tif (node->analyzed)\n+\tif (node->analyzed && gimple_has_body_p (node->decl))\n \t  {\n \t    push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \t    current_function_decl = node->decl;"}, {"sha": "077f9d602d7ae88ac523c6e7b48fc6a1f8a81d85", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -7074,7 +7074,7 @@ struct gimple_opt_pass pass_split_crit_edges =\n   PROP_no_crit_edges,            /* properties_provided */\n   0,                             /* properties_destroyed */\n   0,                             /* todo_flags_start */\n-  TODO_dump_func                 /* todo_flags_finish */\n+  TODO_dump_func | TODO_verify_flow  /* todo_flags_finish */\n  }\n };\n "}, {"sha": "0a383768b043284bae5967a33da2b2ee4a5194fb", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 140, "deletions": 78, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -32,7 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"input.h\"\n #include \"insn-config.h\"\n-#include \"varray.h\"\n #include \"hashtab.h\"\n #include \"langhooks.h\"\n #include \"basic-block.h\"\n@@ -1393,6 +1392,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t need to process all of them.  */\n       do\n \t{\n+\t  tree fn;\n+\n \t  stmt = gsi_stmt (copy_gsi);\n \t  if (is_gimple_call (stmt)\n \t      && gimple_call_va_arg_pack_p (stmt)\n@@ -1481,41 +1482,61 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t     callgraph edges and update or duplicate them.  */\n \t  if (is_gimple_call (stmt))\n \t    {\n-\t      struct cgraph_node *node;\n-\t      struct cgraph_edge *edge;\n+\t      struct cgraph_edge *edge = cgraph_edge (id->src_node, orig_stmt);\n \t      int flags;\n \n \t      switch (id->transform_call_graph_edges)\n \t\t{\n \t      case CB_CGE_DUPLICATE:\n-\t\tedge = cgraph_edge (id->src_node, orig_stmt);\n-\t\tif (edge)\n+\t        if (edge)\n \t\t  cgraph_clone_edge (edge, id->dst_node, stmt,\n \t\t\t\t\t   REG_BR_PROB_BASE, 1,\n \t\t\t\t\t   edge->frequency, true);\n \t\tbreak;\n \n \t      case CB_CGE_MOVE_CLONES:\n-\t\tfor (node = id->dst_node->next_clone;\n-\t\t    node;\n-\t\t    node = node->next_clone)\n-\t\t  {\n-\t\t    edge = cgraph_edge (node, orig_stmt);\n-\t\t\t  if (edge)\n-\t\t\t    cgraph_set_call_stmt (edge, stmt);\n-\t\t  }\n-\t\t/* FALLTHRU */\n+\t\tcgraph_set_call_stmt_including_clones (id->dst_node, orig_stmt, stmt);\n+\t\tbreak;\n \n \t      case CB_CGE_MOVE:\n-\t\tedge = cgraph_edge (id->dst_node, orig_stmt);\n-\t\tif (edge)\n+\t        if (edge)\n \t\t  cgraph_set_call_stmt (edge, stmt);\n \t\tbreak;\n \n \t      default:\n \t\tgcc_unreachable ();\n \t\t}\n \n+\t    /* Constant propagation on argument done during inlining\n+\t       may create new direct call.  Produce an edge for it.  */\n+\t    if (!edge && is_gimple_call (stmt)\n+\t\t&& (fn = gimple_call_fndecl (stmt)) != NULL\n+\t\t&& !cgraph_edge (id->dst_node, stmt))\n+\t      {\n+\t\tstruct cgraph_node *dest = cgraph_node (fn);\n+\n+\t\t/* We have missing edge in the callgraph.  This can happen in one case\n+\t\t   where previous inlining turned indirect call into direct call by\n+\t\t   constant propagating arguments.  In all other cases we hit a bug\n+\t\t   (incorrect node sharing is most common reason for missing edges.  */\n+\t\tgcc_assert (dest->needed || !dest->analyzed);\n+\t\tif (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n+\t\t  cgraph_create_edge_including_clones (id->dst_node, dest, stmt,\n+\t\t\t\t\t\t       bb->count, CGRAPH_FREQ_BASE,\n+\t\t\t\t\t\t       bb->loop_depth,\n+\t\t\t\t\t\t       CIF_ORIGINALLY_INDIRECT_CALL);\n+\t\telse\n+\t\t  cgraph_create_edge (id->dst_node, dest, stmt,\n+\t\t\t\t      bb->count, CGRAPH_FREQ_BASE,\n+\t\t\t\t      bb->loop_depth)->inline_failed\n+\t\t    = CIF_ORIGINALLY_INDIRECT_CALL;\n+\t\tif (dump_file)\n+\t\t  {\n+\t\t     fprintf (dump_file, \"Created new direct edge to %s\",\n+\t\t\t      cgraph_node_name (dest));\n+\t\t  }\n+\t      }\n+\n \t      flags = gimple_call_flags (stmt);\n \n \t      if (flags & ECF_MAY_BE_ALLOCA)\n@@ -3221,29 +3242,6 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \n   cg_edge = cgraph_edge (id->dst_node, stmt);\n \n-  /* Constant propagation on argument done during previous inlining\n-     may create new direct call.  Produce an edge for it.  */\n-  if (!cg_edge)\n-    {\n-      struct cgraph_node *dest = cgraph_node (fn);\n-\n-      /* We have missing edge in the callgraph.  This can happen in one case\n-         where previous inlining turned indirect call into direct call by\n-         constant propagating arguments.  In all other cases we hit a bug\n-         (incorrect node sharing is most common reason for missing edges.  */\n-      gcc_assert (dest->needed);\n-      cgraph_create_edge (id->dst_node, dest, stmt,\n-\t\t\t  bb->count, CGRAPH_FREQ_BASE,\n-\t\t\t  bb->loop_depth)->inline_failed\n-\t= CIF_ORIGINALLY_INDIRECT_CALL;\n-      if (dump_file)\n-\t{\n-\t   fprintf (dump_file, \"Created new direct edge to %s\",\n-\t\t    cgraph_node_name (dest));\n-\t}\n-      goto egress;\n-    }\n-\n   /* Don't try to inline functions that are not well-suited to\n      inlining.  */\n   if (!cgraph_inline_p (cg_edge, &reason))\n@@ -4281,27 +4279,98 @@ tree_versionable_function_p (tree fndecl)\n   return true;\n }\n \n-/* Create a new name for omp child function.  Returns an identifier.  */\n-\n-static GTY(()) unsigned int clone_fn_id_num;\n+/* Delete all unreachable basic blocks and update callgraph.\n+   Doing so is somewhat nontrivial because we need to update all clones and\n+   remove inline function that become unreachable.  */\n \n-static tree\n-clone_function_name (tree decl)\n+static bool\n+delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n {\n-  tree name = DECL_ASSEMBLER_NAME (decl);\n-  size_t len = IDENTIFIER_LENGTH (name);\n-  char *tmp_name, *prefix;\n-\n-  prefix = XALLOCAVEC (char, len + strlen (\"_clone\") + 1);\n-  memcpy (prefix, IDENTIFIER_POINTER (name), len);\n-  strcpy (prefix + len, \"_clone\");\n-#ifndef NO_DOT_IN_LABEL\n-  prefix[len] = '.';\n-#elif !defined NO_DOLLAR_IN_LABEL\n-  prefix[len] = '$';\n+  bool changed = false;\n+  basic_block b, next_bb;\n+\n+  find_unreachable_blocks ();\n+\n+  /* Delete all unreachable basic blocks.  */\n+\n+  for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR; b = next_bb)\n+    {\n+      next_bb = b->next_bb;\n+\n+      if (!(b->flags & BB_REACHABLE))\n+\t{\n+          gimple_stmt_iterator bsi;\n+\n+          for (bsi = gsi_start_bb (b); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL)\n+\t      {\n+\t        struct cgraph_edge *e;\n+\t\tstruct cgraph_node *node;\n+\n+\t        if ((e = cgraph_edge (id->dst_node, gsi_stmt (bsi))) != NULL)\n+\t\t  {\n+\t\t    if (!e->inline_failed)\n+\t\t      cgraph_remove_node_and_inline_clones (e->callee);\n+\t\t    else\n+\t              cgraph_remove_edge (e);\n+\t\t  }\n+\t\tif (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES\n+\t\t    && id->dst_node->clones)\n+     \t\t  for (node = id->dst_node->clones; node != id->dst_node;)\n+\t\t    {\n+\t              if ((e = cgraph_edge (node, gsi_stmt (bsi))) != NULL)\n+\t\t\t{\n+\t\t          if (!e->inline_failed)\n+\t\t            cgraph_remove_node_and_inline_clones (e->callee);\n+\t\t\t  else\n+\t                    cgraph_remove_edge (e);\n+\t\t\t}\n+\t\t       \n+\t\t      if (node->clones)\n+\t\t\tnode = node->clones;\n+\t\t      else if (node->next_sibling_clone)\n+\t\t\tnode = node->next_sibling_clone;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  while (node != id->dst_node && !node->next_sibling_clone)\n+\t\t\t    node = node->clone_of;\n+\t\t\t  if (node != id->dst_node)\n+\t\t\t    node = node->next_sibling_clone;\n+\t\t\t}\n+\t\t    }\n+\t      }\n+\t  delete_basic_block (b);\n+\t  changed = true;\n+\t}\n+    }\n+\n+  if (changed)\n+    tidy_fallthru_edges ();\n+#ifdef ENABLE_CHECKING0\n+  verify_cgraph_node (id->dst_node);\n+  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES\n+      && id->dst_node->clones)\n+    {\n+      struct cgraph_node *node;\n+      for (node = id->dst_node->clones; node != id->dst_node;)\n+\t{\n+\t  verify_cgraph_node (node);\n+\t   \n+\t  if (node->clones)\n+\t    node = node->clones;\n+\t  else if (node->next_sibling_clone)\n+\t    node = node->next_sibling_clone;\n+\t  else\n+\t    {\n+\t      while (node != id->dst_node && !node->next_sibling_clone)\n+\t\tnode = node->clone_of;\n+\t      if (node != id->dst_node)\n+\t\tnode = node->next_sibling_clone;\n+\t    }\n+\t}\n+     }\n #endif\n-  ASM_FORMAT_PRIVATE_NAME (tmp_name, prefix, clone_fn_id_num++);\n-  return get_identifier (tmp_name);\n+  return changed;\n }\n \n /* Create a copy of a function's tree.\n@@ -4313,7 +4382,7 @@ clone_function_name (tree decl)\n    trees. If UPDATE_CLONES is set, the call_stmt fields\n    of edges of clones of the function will be updated.  */\n void\n-tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n+tree_function_versioning (tree old_decl, tree new_decl, VEC(ipa_replace_map_p,gc)* tree_map,\n \t\t\t  bool update_clones, bitmap args_to_skip)\n {\n   struct cgraph_node *old_version_node;\n@@ -4349,13 +4418,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   memset (&id, 0, sizeof (id));\n \n   /* Generate a new name for the new version. */\n-  if (!update_clones)\n-    {\n-      DECL_NAME (new_decl) = clone_function_name (old_decl);\n-      SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n-      SET_DECL_RTL (new_decl, NULL_RTX);\n-      id.statements_to_fold = pointer_set_create ();\n-    }\n+  id.statements_to_fold = pointer_set_create ();\n   \n   id.decl_map = pointer_map_create ();\n   id.src_fn = old_decl;\n@@ -4388,11 +4451,10 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   \n   /* If there's a tree_map, prepare for substitution.  */\n   if (tree_map)\n-    for (i = 0; i < VARRAY_ACTIVE_SIZE (tree_map); i++)\n+    for (i = 0; i < VEC_length (ipa_replace_map_p, tree_map); i++)\n       {\n \tgimple init;\n-\treplace_info\n-\t  = (struct ipa_replace_map *) VARRAY_GENERIC_PTR (tree_map, i);\n+\treplace_info = VEC_index (ipa_replace_map_p, tree_map, i);\n \tif (replace_info->replace_p)\n \t  {\n \t    tree op = replace_info->new_tree;\n@@ -4431,6 +4493,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   number_blocks (id.dst_fn);\n   \n   declare_inline_vars (DECL_INITIAL (new_decl), vars);\n+\n   if (DECL_STRUCT_FUNCTION (old_decl)->local_decls != NULL_TREE)\n     /* Add local vars.  */\n     for (t_step = DECL_STRUCT_FUNCTION (old_decl)->local_decls;\n@@ -4469,14 +4532,15 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   pointer_map_destroy (id.decl_map);\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n-  if (!update_clones)\n-    {\n-      fold_marked_statements (0, id.statements_to_fold);\n-      pointer_set_destroy (id.statements_to_fold);\n-      fold_cond_expr_cond ();\n-      delete_unreachable_blocks ();\n-      update_ssa (TODO_update_ssa);\n-    }\n+\n+  fold_marked_statements (0, id.statements_to_fold);\n+  pointer_set_destroy (id.statements_to_fold);\n+  fold_cond_expr_cond ();\n+  delete_unreachable_blocks_update_callgraph (&id);\n+  update_ssa (TODO_update_ssa);\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n   VEC_free (gimple, heap, init_stmts);\n   pop_cfun ();\n   current_function_decl = old_current_function_decl;\n@@ -4544,5 +4608,3 @@ tree_can_inline_p (tree caller, tree callee)\n   /* Allow the backend to decide if inlining is ok.  */\n   return targetm.target_option.can_inline_p (caller, callee);\n }\n-\n-#include \"gt-tree-inline.h\""}, {"sha": "d55f84a14d453d56766ae6f536962bd17aff0dd1", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9187e02deb92bfe982c845a682468fce39c8bf9b/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=9187e02deb92bfe982c845a682468fce39c8bf9b", "patch": "@@ -21,7 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_INLINE_H\n #define GCC_TREE_INLINE_H\n \n-#include \"varray.h\"\n #include \"pointer-set.h\"\n \n \n@@ -156,7 +155,6 @@ int estimate_num_insns (gimple, eni_weights *);\n int estimate_num_insns_fn (tree, eni_weights *);\n int count_insns_seq (gimple_seq, eni_weights *);\n bool tree_versionable_function_p (tree);\n-void tree_function_versioning (tree, tree, varray_type, bool, bitmap);\n bool tree_can_inline_p (tree, tree);\n \n extern gimple_seq remap_gimple_seq (gimple_seq, copy_body_data *);"}]}