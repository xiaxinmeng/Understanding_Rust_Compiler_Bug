{"sha": "53dc5044ed4fde8b489ba024923f49720db8129d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNkYzUwNDRlZDRmZGU4YjQ4OWJhMDI0OTIzZjQ5NzIwZGI4MTI5ZA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2010-11-02T18:51:23Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-11-02T18:51:23Z"}, "message": "cinttypes: Remove, move contents to C++0x and TR1 headers.\n\n2010-11-02  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/tr1_impl/cinttypes: Remove, move contents to C++0x\n\tand TR1 headers.\n\t* include/tr1_impl/cstdlib: Likewise.\n\t* include/tr1_impl/cstdio: Likewise.\n\t* include/tr1_impl/cctype: Likewise.\n\t* include/tr1_impl/boost_sp_counted_base.h: Likewise.\n\t* include/tr1_impl/cmath: Likewise.\n\t* include/tr1_impl/cfenv: Likewise.\n\t* include/tr1_impl/utility: Likewise.\n\t* include/tr1_impl/complex: Likewise.\n\t* include/tr1_impl/cwchar: Likewise.\n\t* include/tr1_impl/type_traits: Likewise.\n\t* include/tr1_impl/cstdint: Likewise.\n\t* include/tr1_impl/regex: Likewise.\n\t* include/tr1_impl/array: Likewise.\n\t* include/tr1_impl/cwctype: Likewise.\n\t* include/Makefile.am: Adjust.\n\t* include/Makefile.in: Regenerate.\n\t* src/condition_variable.cc: Adjust; consistently use\n\t_GLIBCXX_BEGIN_NAMESPACE and _GLIBCXX_END_NAMESPACE.\n\t* src/mutex.cc: Likewise.\n\t* src/future.cc: Likewise.\n\t* src/atomic.cc: Likewise.\n\t* src/chrono.cc: Likewise.\n\t* src/thread.cc: Likewise.\n\t* include/std/tuple: Likewise.\n\t* include/std/utility: Likewise.\n\t* include/std/thread: Likewise.: Likewise.\n\t* include/std/type_traits: Likewise.\n\t* include/std/memory: Likewise.\n\t* include/std/future: Likewise.\n\t* include/std/ratio: Likewise.\n\t* include/std/chrono: Likewise.\n\t* include/std/condition_variable: Likewise.\n\t* include/std/mutex: Likewise.\n\t* include/std/functional: Likewise.\n\t* include/std/complex: Likewise.\n\t* include/std/typeindex: Likewise.\n\t* include/std/array: Likewise.\n\t* include/bits/regex_compiler.h: Likewise.\n\t* include/bits/regex_grep_matcher.tcc: Likewise.\n\t* include/bits/regex_grep_matcher.h: Likewise.\n\t* include/bits/regex_constants.h: Likewise.\n\t* include/bits/regex_cursor.h: Likewise.\n\t* include/bits/regex_nfa.tcc: Likewise.\n\t* include/bits/shared_ptr_base.h: Likewise.\n\t* include/bits/regex_nfa.h: Likewise.\n\t* include/bits/random.tcc: Likewise.\n\t* include/bits/regex.h: Likewise.\n\t* include/bits/random.h: Likewise.\n\t* include/bits/regex_error.h: Likewise.\n\t* include/c_global/cinttypes: Likewise.\n\t* include/c_global/cstdlib: Likewise.\n\t* include/c_global/cstdio: Likewise.\n\t* include/c_global/cctype: Likewise.\n\t* include/c_global/cmath: Likewise.\n\t* include/c_global/cfenv: Likewise.\n\t* include/c_global/cwchar: Likewise.\n\t* include/c_global/cstdint: Likewise.\n\t* include/c_global/cwctype: Likewise.\n\t* include/tr1/shared_ptr.h: Likewise.\n\t* include/tr1/cinttypes: Likewise.\n\t* include/tr1/cstdio: Likewise.\n\t* include/tr1/cfenv: Likewise.\n\t* include/tr1/utility: Likewise.\n\t* include/tr1/cwchar: Likewise.\n\t* include/tr1/type_traits: Likewise.\n\t* include/tr1/memory: Likewise.\n\t* include/tr1/cstdint: Likewise.\n\t* include/tr1/regex: Likewise.\n\t* include/tr1/cwctype: Likewise.\n\t* include/tr1/cstdlib: Likewise.\n\t* include/tr1/cctype: Likewise.\n\t* include/tr1/cmath: Likewise.\n\t* include/tr1/complex: Likewise.\n\t* include/tr1/array: Likewise.\n\t* include/c_compatibility/fenv.h: Likewise.\n\t* include/c_compatibility/stdint.h: Likewise.\n\t* include/c_compatibility/inttypes.h: Likewise.\n\t* testsuite/tr1/2_general_utilities/shared_ptr/cons/43820.cc: Adjust\n\tdg-error line numbers.\n\t* testsuite/20_util/duration/requirements/typedefs_neg1.cc: Likewise.\n\t* testsuite/20_util/duration/requirements/typedefs_neg2.cc: Likewise.\n\t* testsuite/20_util/duration/requirements/typedefs_neg3.cc: Likewise.\n\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Likewise.\n\t* testsuite/20_util/make_unsigned/requirements/\n\ttypedefs_neg.cc: Likewise.\n\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/cons/43820.cc: Likewise.\n\t* testsuite/20_util/weak_ptr/comparison/cmp_neg.cc: Likewise.\n\nFrom-SVN: r166211", "tree": {"sha": "f32ef83a6c9e3e08f28de6c5c9acb9beae030e04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f32ef83a6c9e3e08f28de6c5c9acb9beae030e04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53dc5044ed4fde8b489ba024923f49720db8129d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53dc5044ed4fde8b489ba024923f49720db8129d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53dc5044ed4fde8b489ba024923f49720db8129d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53dc5044ed4fde8b489ba024923f49720db8129d/comments", "author": null, "committer": null, "parents": [{"sha": "a9992f7f6b00e697f46913fdf809366522118b6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9992f7f6b00e697f46913fdf809366522118b6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9992f7f6b00e697f46913fdf809366522118b6b"}], "stats": {"total": 14272, "additions": 7843, "deletions": 6429}, "files": [{"sha": "651861d77f2bf4e14c05040f56535e6259c64195", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -1,3 +1,96 @@\n+2010-11-02  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/tr1_impl/cinttypes: Remove, move contents to C++0x\n+\tand TR1 headers.\n+\t* include/tr1_impl/cstdlib: Likewise.\n+\t* include/tr1_impl/cstdio: Likewise.\n+\t* include/tr1_impl/cctype: Likewise.\n+\t* include/tr1_impl/boost_sp_counted_base.h: Likewise.\n+\t* include/tr1_impl/cmath: Likewise.\n+\t* include/tr1_impl/cfenv: Likewise.\n+\t* include/tr1_impl/utility: Likewise.\n+\t* include/tr1_impl/complex: Likewise.\n+\t* include/tr1_impl/cwchar: Likewise.\n+\t* include/tr1_impl/type_traits: Likewise.\n+\t* include/tr1_impl/cstdint: Likewise.\n+\t* include/tr1_impl/regex: Likewise.\n+\t* include/tr1_impl/array: Likewise.\n+\t* include/tr1_impl/cwctype: Likewise.\n+\t* include/Makefile.am: Adjust.\n+\t* include/Makefile.in: Regenerate.\n+\t* src/condition_variable.cc: Adjust; consistently use\n+\t_GLIBCXX_BEGIN_NAMESPACE and _GLIBCXX_END_NAMESPACE.\n+\t* src/mutex.cc: Likewise.\n+\t* src/future.cc: Likewise.\n+\t* src/atomic.cc: Likewise.\n+\t* src/chrono.cc: Likewise.\n+\t* src/thread.cc: Likewise.\n+\t* include/std/tuple: Likewise.\n+\t* include/std/utility: Likewise.\n+\t* include/std/thread: Likewise.: Likewise.\n+\t* include/std/type_traits: Likewise.\n+\t* include/std/memory: Likewise.\n+\t* include/std/future: Likewise.\n+\t* include/std/ratio: Likewise.\n+\t* include/std/chrono: Likewise.\n+\t* include/std/condition_variable: Likewise.\n+\t* include/std/mutex: Likewise.\n+\t* include/std/functional: Likewise.\n+\t* include/std/complex: Likewise.\n+\t* include/std/typeindex: Likewise.\n+\t* include/std/array: Likewise.\n+\t* include/bits/regex_compiler.h: Likewise.\n+\t* include/bits/regex_grep_matcher.tcc: Likewise.\n+\t* include/bits/regex_grep_matcher.h: Likewise.\n+\t* include/bits/regex_constants.h: Likewise.\n+\t* include/bits/regex_cursor.h: Likewise.\n+\t* include/bits/regex_nfa.tcc: Likewise.\n+\t* include/bits/shared_ptr_base.h: Likewise.\n+\t* include/bits/regex_nfa.h: Likewise.\n+\t* include/bits/random.tcc: Likewise.\n+\t* include/bits/regex.h: Likewise.\n+\t* include/bits/random.h: Likewise.\n+\t* include/bits/regex_error.h: Likewise.\n+\t* include/c_global/cinttypes: Likewise.\n+\t* include/c_global/cstdlib: Likewise.\n+\t* include/c_global/cstdio: Likewise.\n+\t* include/c_global/cctype: Likewise.\n+\t* include/c_global/cmath: Likewise.\n+\t* include/c_global/cfenv: Likewise.\n+\t* include/c_global/cwchar: Likewise.\n+\t* include/c_global/cstdint: Likewise.\n+\t* include/c_global/cwctype: Likewise.\n+\t* include/tr1/shared_ptr.h: Likewise.\n+\t* include/tr1/cinttypes: Likewise.\n+\t* include/tr1/cstdio: Likewise.\n+\t* include/tr1/cfenv: Likewise.\n+\t* include/tr1/utility: Likewise.\n+\t* include/tr1/cwchar: Likewise.\n+\t* include/tr1/type_traits: Likewise.\n+\t* include/tr1/memory: Likewise.\n+\t* include/tr1/cstdint: Likewise.\n+\t* include/tr1/regex: Likewise.\n+\t* include/tr1/cwctype: Likewise.\n+\t* include/tr1/cstdlib: Likewise.\n+\t* include/tr1/cctype: Likewise.\n+\t* include/tr1/cmath: Likewise.\n+\t* include/tr1/complex: Likewise.\n+\t* include/tr1/array: Likewise.\n+\t* include/c_compatibility/fenv.h: Likewise.\n+\t* include/c_compatibility/stdint.h: Likewise.\n+\t* include/c_compatibility/inttypes.h: Likewise.\n+\t* testsuite/tr1/2_general_utilities/shared_ptr/cons/43820.cc: Adjust\n+\tdg-error line numbers.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg1.cc: Likewise.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg2.cc: Likewise.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg3.cc: Likewise.\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Likewise.\n+\t* testsuite/20_util/make_unsigned/requirements/\n+\ttypedefs_neg.cc: Likewise.\n+\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n+\t* testsuite/20_util/shared_ptr/cons/43820.cc: Likewise.\n+\t* testsuite/20_util/weak_ptr/comparison/cmp_neg.cc: Likewise.\n+\n 2010-11-02  Paolo Carlini  <paolo.carlini@oracle.com\n \n \t* testsuite/28_regex/05_constants/syntax_option_type.cc: Avoid"}, {"sha": "3fb1876fb4776ce8a591c414d5b8c064599d3b26", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -610,26 +610,6 @@ tr1_headers = \\\n \t${tr1_srcdir}/wchar.h \\\n \t${tr1_srcdir}/wctype.h\n \n-\n-tr1_impl_srcdir = ${glibcxx_srcdir}/include/tr1_impl\n-tr1_impl_builddir = ./tr1_impl\n-tr1_impl_headers = \\\n-\t${tr1_impl_srcdir}/array \\\n-\t${tr1_impl_srcdir}/boost_sp_counted_base.h \\\n-\t${tr1_impl_srcdir}/cctype \\\n-\t${tr1_impl_srcdir}/cfenv \\\n-\t${tr1_impl_srcdir}/cinttypes \\\n-\t${tr1_impl_srcdir}/cmath \\\n-\t${tr1_impl_srcdir}/complex \\\n-\t${tr1_impl_srcdir}/cstdint \\\n-\t${tr1_impl_srcdir}/cstdio \\\n-\t${tr1_impl_srcdir}/cstdlib \\\n-\t${tr1_impl_srcdir}/cwchar \\\n-\t${tr1_impl_srcdir}/cwctype \\\n-\t${tr1_impl_srcdir}/regex \\\n-\t${tr1_impl_srcdir}/type_traits \\\n-\t${tr1_impl_srcdir}/utility\n-\n decimal_srcdir = ${glibcxx_srcdir}/include/decimal\n decimal_builddir = ./decimal\n decimal_headers = \\\n@@ -908,9 +888,9 @@ endif\n # CLEANFILES and all-local are kept up-to-date.\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_compatibility \\\n-\tstamp-backward stamp-ext stamp-pb stamp-tr1 stamp-tr1-impl \\\n-\tstamp-decimal stamp-debug stamp-parallel stamp-profile \\\n-\tstamp-profile-impl stamp-host \n+\tstamp-backward stamp-ext stamp-pb stamp-tr1 stamp-decimal \\\n+\tstamp-debug stamp-parallel stamp-profile stamp-profile-impl \\\n+\tstamp-host \n \n # List of all files that are created by explicit building, editing, or\n # catenation.\n@@ -1019,11 +999,6 @@ stamp-tr1: ${tr1_headers}\n \t@-cd ${tr1_builddir} && $(LN_S) $? . 2>/dev/null\n \t@$(STAMP) stamp-tr1\n \n-stamp-tr1-impl: ${tr1_impl_headers}\n-\t@-mkdir -p ${tr1_impl_builddir}\n-\t@-cd ${tr1_impl_builddir} && $(LN_S) $? . 2>/dev/null\n-\t@$(STAMP) stamp-tr1-impl\n-\n stamp-decimal: ${decimal_headers}\n \t@-mkdir -p ${decimal_builddir}\n \t@-cd ${decimal_builddir} && $(LN_S) $? . 2>/dev/null\n@@ -1254,9 +1229,6 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${tr1_builddir}\n \tfor file in ${tr1_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${tr1_builddir}; done\n-\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${tr1_impl_builddir}\n-\tfor file in ${tr1_impl_headers}; do \\\n-\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${tr1_impl_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${decimal_builddir}\n \tfor file in ${decimal_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${decimal_builddir}; done\n@@ -1303,11 +1275,10 @@ clean-local:\n # developer tries to create them via make in the include build\n # directory. (This is more of an example of how this kind of rule can\n # be made.)\n-.PRECIOUS: $(std_headers) $(c_base_headers) $(tr1_headers) $(tr1_impl_headers)\n+.PRECIOUS: $(std_headers) $(c_base_headers) $(tr1_headers)\n \t   $(decimal_headers) $(ext_headers)\n $(std_headers): ; @:\n $(c_base_headers): ; @:\n $(tr1_headers): ; @:\n-$(tr1_impl_headers): ; @:\n $(decimal_headers): ; @:\n $(ext_headers): ; @:"}, {"sha": "82cdd92204981cf9f5466b4982c869b8ad220a41", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -848,25 +848,6 @@ tr1_headers = \\\n \t${tr1_srcdir}/wchar.h \\\n \t${tr1_srcdir}/wctype.h\n \n-tr1_impl_srcdir = ${glibcxx_srcdir}/include/tr1_impl\n-tr1_impl_builddir = ./tr1_impl\n-tr1_impl_headers = \\\n-\t${tr1_impl_srcdir}/array \\\n-\t${tr1_impl_srcdir}/boost_sp_counted_base.h \\\n-\t${tr1_impl_srcdir}/cctype \\\n-\t${tr1_impl_srcdir}/cfenv \\\n-\t${tr1_impl_srcdir}/cinttypes \\\n-\t${tr1_impl_srcdir}/cmath \\\n-\t${tr1_impl_srcdir}/complex \\\n-\t${tr1_impl_srcdir}/cstdint \\\n-\t${tr1_impl_srcdir}/cstdio \\\n-\t${tr1_impl_srcdir}/cstdlib \\\n-\t${tr1_impl_srcdir}/cwchar \\\n-\t${tr1_impl_srcdir}/cwctype \\\n-\t${tr1_impl_srcdir}/regex \\\n-\t${tr1_impl_srcdir}/type_traits \\\n-\t${tr1_impl_srcdir}/utility\n-\n decimal_srcdir = ${glibcxx_srcdir}/include/decimal\n decimal_builddir = ./decimal\n decimal_headers = \\\n@@ -1133,9 +1114,9 @@ PCHFLAGS = -x c++-header -nostdinc++ $(CXXFLAGS)\n # CLEANFILES and all-local are kept up-to-date.\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_compatibility \\\n-\tstamp-backward stamp-ext stamp-pb stamp-tr1 stamp-tr1-impl \\\n-\tstamp-decimal stamp-debug stamp-parallel stamp-profile \\\n-\tstamp-profile-impl stamp-host \n+\tstamp-backward stamp-ext stamp-pb stamp-tr1 stamp-decimal \\\n+\tstamp-debug stamp-parallel stamp-profile stamp-profile-impl \\\n+\tstamp-host \n \n \n # List of all files that are created by explicit building, editing, or\n@@ -1406,11 +1387,6 @@ stamp-tr1: ${tr1_headers}\n \t@-cd ${tr1_builddir} && $(LN_S) $? . 2>/dev/null\n \t@$(STAMP) stamp-tr1\n \n-stamp-tr1-impl: ${tr1_impl_headers}\n-\t@-mkdir -p ${tr1_impl_builddir}\n-\t@-cd ${tr1_impl_builddir} && $(LN_S) $? . 2>/dev/null\n-\t@$(STAMP) stamp-tr1-impl\n-\n stamp-decimal: ${decimal_headers}\n \t@-mkdir -p ${decimal_builddir}\n \t@-cd ${decimal_builddir} && $(LN_S) $? . 2>/dev/null\n@@ -1629,9 +1605,6 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${tr1_builddir}\n \tfor file in ${tr1_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${tr1_builddir}; done\n-\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${tr1_impl_builddir}\n-\tfor file in ${tr1_impl_headers}; do \\\n-\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${tr1_impl_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${decimal_builddir}\n \tfor file in ${decimal_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${decimal_builddir}; done\n@@ -1675,12 +1648,11 @@ clean-local:\n # developer tries to create them via make in the include build\n # directory. (This is more of an example of how this kind of rule can\n # be made.)\n-.PRECIOUS: $(std_headers) $(c_base_headers) $(tr1_headers) $(tr1_impl_headers)\n+.PRECIOUS: $(std_headers) $(c_base_headers) $(tr1_headers)\n \t   $(decimal_headers) $(ext_headers)\n $(std_headers): ; @:\n $(c_base_headers): ; @:\n $(tr1_headers): ; @:\n-$(tr1_impl_headers): ; @:\n $(decimal_headers): ; @:\n $(ext_headers): ; @:\n "}, {"sha": "2fa8e6c35a1b719bf8dda7bffd1b3882fed47c1d", "filename": "libstdc++-v3/include/bits/random.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -33,8 +33,8 @@\n \n #include <vector>\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   // [26.4] Random number generation\n \n   /**\n@@ -5376,6 +5376,6 @@ namespace std\n   /* @} */ // group random_utilities\n \n   /* @} */ // group random\n-}\n+_GLIBCXX_END_NAMESPACE\n \n #endif"}, {"sha": "323741d25db4917de04e4cda443608916bcf2d46", "filename": "libstdc++-v3/include/bits/random.tcc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.tcc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -32,8 +32,8 @@\n \n #include <numeric> // std::accumulate and std::partial_sum\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   /*\n    * (Further) implementation-space details.\n    */\n@@ -2818,6 +2818,6 @@ namespace std\n \t}\n       return __sum / __tmp;\n     }\n-}\n+_GLIBCXX_END_NAMESPACE\n \n #endif"}, {"sha": "807bf0dda69fae6da8f37fed998b8742e2e5d434", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -28,8 +28,7 @@\n  *  You should not attempt to use it directly.\n  */\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n \n /**\n  * @defgroup regex Regular Expressions\n@@ -2422,6 +2421,5 @@ namespace std\n #endif\n   \n   //@} // group regex\n-  \n-}\n+_GLIBCXX_END_NAMESPACE\n "}, {"sha": "90c96ff93ea834971cff4dcfedf905986d75f7f8", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -28,8 +28,8 @@\n  * You should not attempt to use it directly.\n  */\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n namespace __regex\n {\n   struct _Scanner_base\n@@ -1110,6 +1110,7 @@ namespace __regex\n                                         __f)._M_nfa())); }\n \n } // namespace __regex\n-} // namespace std\n+\n+_GLIBCXX_END_NAMESPACE\n \n /* vim: set ts=8 sw=2 sts=2: */"}, {"sha": "15e29532c5195cf679c21b24f51d3a56d68b9135", "filename": "libstdc++-v3/include/bits/regex_constants.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -30,8 +30,7 @@\n  *  You should not attempt to use it directly.\n  */\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n \n /**\n  * @namespace std::regex_constants\n@@ -295,5 +294,6 @@ namespace regex_constants\n   //@}\n \n } // namespace regex_constants\n-} // namespace std\n+\n+_GLIBCXX_END_NAMESPACE\n "}, {"sha": "32ea8c97d857561f73a3b3d2ac27b3795f37d3ea", "filename": "libstdc++-v3/include/bits/regex_cursor.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -28,8 +28,8 @@\n  * You should not attempt to use it directly.\n  */\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n namespace __regex\n {\n   // ABC for pattern matching\n@@ -87,6 +87,5 @@ namespace __regex\n     { return _SpecializedCursor<_FwdIterT>(__b, __e); }\n \n } // namespace __regex\n-} // namespace std\n \n-/* vim: set ts=8 sw=2 sts=2: */\n+_GLIBCXX_END_NAMESPACE"}, {"sha": "91dd59778fcbc9742180a2c1daf0ef17a9f51c0c", "filename": "libstdc++-v3/include/bits/regex_error.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_error.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_error.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_error.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -30,8 +30,7 @@\n  *  You should not attempt to use it directly.\n  */\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n \n namespace regex_constants\n {\n@@ -156,5 +155,4 @@ namespace regex_constants\n   __throw_regex_error(regex_constants::error_type __ecode)\n   { throw regex_error(__ecode); }\n \n-} // namespace std\n-\n+_GLIBCXX_END_NAMESPACE"}, {"sha": "470e6297f3928087e51a69bd2c8876f165998bad", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -28,9 +28,8 @@\n  * You should not attempt to use it directly.\n  */\n \n+_GLIBCXX_BEGIN_NAMESPACE(std)\n \n-namespace std\n-{\n   template<typename _BiIter>\n     class sub_match;\n \n@@ -124,8 +123,7 @@ namespace __regex\n   };\n \n } // namespace __regex\n-} // namespace std\n \n-#include <bits/regex_grep_matcher.tcc>\n+_GLIBCXX_END_NAMESPACE\n \n-/* vim: set ts=8 sw=2 sts=2: */\n+#include <bits/regex_grep_matcher.tcc>"}, {"sha": "48e7482b2ed74920905a4c83ead96bdcea28ce5a", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.tcc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -25,10 +25,10 @@\n /**\n  * @file bits/regex_grep_matcher.tcc\n  */\n+\n #include <regex>\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n \n namespace\n {\n@@ -172,6 +172,5 @@ namespace __regex\n   }\n \n } // namespace __regex\n-} // namespace std\n \n-/* vim: set ts=8 sw=2 sts=2: */\n+_GLIBCXX_END_NAMESPACE"}, {"sha": "0a412891311f5ed1d885072d4c688b7d96c3b907", "filename": "libstdc++-v3/include/bits/regex_nfa.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -28,8 +28,8 @@\n  * You should not attempt to use it directly.\n  */\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n namespace __regex\n {\n \n@@ -397,7 +397,8 @@ namespace __regex\n   };\n \n } // namespace __regex\n-} // namespace std\n+\n+_GLIBCXX_END_NAMESPACE\n \n #include <bits/regex_nfa.tcc>\n "}, {"sha": "4a5d5ffd12013e57f578811e59664a6ed6539a13", "filename": "libstdc++-v3/include/bits/regex_nfa.tcc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -27,8 +27,8 @@\n  */\n #include <regex>\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n namespace __regex\n {\n #ifdef _GLIBCXX_DEBUG\n@@ -166,5 +166,5 @@ _M_clone()\n { return 0; }\n \n } // namespace __regex\n-} // namespace std\n \n+_GLIBCXX_END_NAMESPACE"}, {"sha": "4a30ea4da6a2e8400a2a2f7a47f7fd5e11bfbc4c", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -51,6 +51,202 @@\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n+ /**\n+   *  @brief  Exception possibly thrown by @c shared_ptr.\n+   *  @ingroup exceptions\n+   */\n+  class bad_weak_ptr : public std::exception\n+  {\n+  public:\n+    virtual char const*\n+    what() const throw()\n+    { return \"std::bad_weak_ptr\"; }\n+  };\n+\n+  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n+  inline void\n+  __throw_bad_weak_ptr()\n+  {\n+#if __EXCEPTIONS\n+    throw bad_weak_ptr();\n+#else\n+    __builtin_abort();\n+#endif\n+  }\n+\n+  using __gnu_cxx::_Lock_policy;\n+  using __gnu_cxx::__default_lock_policy;\n+  using __gnu_cxx::_S_single;\n+  using __gnu_cxx::_S_mutex;\n+  using __gnu_cxx::_S_atomic;\n+\n+  // Empty helper class except when the template argument is _S_mutex.\n+  template<_Lock_policy _Lp>\n+    class _Mutex_base\n+    {\n+    protected:\n+      // The atomic policy uses fully-fenced builtins, single doesn't care.\n+      enum { _S_need_barriers = 0 };\n+    };\n+\n+  template<>\n+    class _Mutex_base<_S_mutex>\n+    : public __gnu_cxx::__mutex\n+    {\n+    protected:\n+      // This policy is used when atomic builtins are not available.\n+      // The replacement atomic operations might not have the necessary\n+      // memory barriers.\n+      enum { _S_need_barriers = 1 };\n+    };\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class _Sp_counted_base\n+    : public _Mutex_base<_Lp>\n+    {\n+    public:  \n+      _Sp_counted_base()\n+      : _M_use_count(1), _M_weak_count(1) { }\n+      \n+      virtual\n+      ~_Sp_counted_base() // nothrow \n+      { }\n+  \n+      // Called when _M_use_count drops to zero, to release the resources\n+      // managed by *this.\n+      virtual void\n+      _M_dispose() = 0; // nothrow\n+      \n+      // Called when _M_weak_count drops to zero.\n+      virtual void\n+      _M_destroy() // nothrow\n+      { delete this; }\n+      \n+      virtual void*\n+      _M_get_deleter(const std::type_info&) = 0;\n+\n+      void\n+      _M_add_ref_copy()\n+      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }\n+  \n+      void\n+      _M_add_ref_lock();\n+      \n+      void\n+      _M_release() // nothrow\n+      {\n+        // Be race-detector-friendly.  For more info see bits/c++config.\n+        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);\n+\tif (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)\n+\t  {\n+            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);\n+\t    _M_dispose();\n+\t    // There must be a memory barrier between dispose() and destroy()\n+\t    // to ensure that the effects of dispose() are observed in the\n+\t    // thread that runs destroy().\n+\t    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html\n+\t    if (_Mutex_base<_Lp>::_S_need_barriers)\n+\t      {\n+\t        _GLIBCXX_READ_MEM_BARRIER;\n+\t        _GLIBCXX_WRITE_MEM_BARRIER;\n+\t      }\n+\n+            // Be race-detector-friendly.  For more info see bits/c++config.\n+            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);\n+\t    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,\n+\t\t\t\t\t\t       -1) == 1)\n+              {\n+                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);\n+\t        _M_destroy();\n+              }\n+\t  }\n+      }\n+  \n+      void\n+      _M_weak_add_ref() // nothrow\n+      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }\n+\n+      void\n+      _M_weak_release() // nothrow\n+      {\n+        // Be race-detector-friendly. For more info see bits/c++config.\n+        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);\n+\tif (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)\n+\t  {\n+            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);\n+\t    if (_Mutex_base<_Lp>::_S_need_barriers)\n+\t      {\n+\t        // See _M_release(),\n+\t        // destroy() must observe results of dispose()\n+\t        _GLIBCXX_READ_MEM_BARRIER;\n+\t        _GLIBCXX_WRITE_MEM_BARRIER;\n+\t      }\n+\t    _M_destroy();\n+\t  }\n+      }\n+  \n+      long\n+      _M_get_use_count() const // nothrow\n+      {\n+        // No memory barrier is used here so there is no synchronization\n+        // with other threads.\n+        return const_cast<const volatile _Atomic_word&>(_M_use_count);\n+      }\n+\n+    private:  \n+      _Sp_counted_base(_Sp_counted_base const&);\n+      _Sp_counted_base& operator=(_Sp_counted_base const&);\n+\n+      _Atomic_word  _M_use_count;     // #shared\n+      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)\n+    };\n+\n+  template<>\n+    inline void\n+    _Sp_counted_base<_S_single>::\n+    _M_add_ref_lock()\n+    {\n+      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n+\t{\n+\t  _M_use_count = 0;\n+\t  __throw_bad_weak_ptr();\n+\t}\n+    }\n+\n+  template<>\n+    inline void\n+    _Sp_counted_base<_S_mutex>::\n+    _M_add_ref_lock()\n+    {\n+      __gnu_cxx::__scoped_lock sentry(*this);\n+      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n+\t{\n+\t  _M_use_count = 0;\n+\t  __throw_bad_weak_ptr();\n+\t}\n+    }\n+\n+  template<> \n+    inline void\n+    _Sp_counted_base<_S_atomic>::\n+    _M_add_ref_lock()\n+    {\n+      // Perform lock-free add-if-not-zero operation.\n+      _Atomic_word __count;\n+      do\n+\t{\n+\t  __count = _M_use_count;\n+\t  if (__count == 0)\n+\t    __throw_bad_weak_ptr();\n+\t  \n+\t  // Replace the current counter value with the old value + 1, as\n+\t  // long as it's not changed meanwhile. \n+\t}\n+      while (!__sync_bool_compare_and_swap(&_M_use_count, __count,\n+\t\t\t\t\t   __count + 1));\n+    }\n+\n+\n   // Forward declarations.\n   template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n     class __shared_ptr;"}, {"sha": "3eb5b207d7a6caa1f22a071770e623ee44106e1a", "filename": "libstdc++-v3/include/c_compatibility/fenv.h", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Ffenv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Ffenv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Ffenv.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -37,22 +37,46 @@\n #endif\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#    error C++0x header cannot be included from TR1 header\n-#  endif\n-#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#    include <tr1_impl/cfenv>\n-#  else\n-#    define _GLIBCXX_INCLUDE_AS_CXX0X\n-#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    define _GLIBCXX_END_NAMESPACE_TR1\n-#    define _GLIBCXX_TR1\n-#    include <tr1_impl/cfenv>\n-#    undef _GLIBCXX_TR1\n-#    undef _GLIBCXX_END_NAMESPACE_TR1\n-#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#  endif\n-#endif\n+\n+#if _GLIBCXX_USE_C99_FENV_TR1\n+\n+#undef feclearexcept\n+#undef fegetexceptflag\n+#undef feraiseexcept\n+#undef fesetexceptflag\n+#undef fetestexcept\n+#undef fegetround\n+#undef fesetround\n+#undef fegetenv\n+#undef feholdexcept\n+#undef fesetenv\n+#undef feupdateenv\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  // types\n+  using ::fenv_t;\n+  using ::fexcept_t;\n+\n+  // functions\n+  using ::feclearexcept;\n+  using ::fegetexceptflag;\n+  using ::feraiseexcept;\n+  using ::fesetexceptflag;\n+  using ::fetestexcept;\n+\n+  using ::fegetround;\n+  using ::fesetround;\n+\n+  using ::fegetenv;\n+  using ::feholdexcept;\n+  using ::fesetenv;\n+  using ::feupdateenv;\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif // _GLIBCXX_USE_C99_FENV_TR1\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n \n #endif // _GLIBCXX_FENV_H"}, {"sha": "2273dfe652ecb6f8bb8dbbd1c9e93de5d0fd499f", "filename": "libstdc++-v3/include/c_compatibility/inttypes.h", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Finttypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Finttypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Finttypes.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -48,22 +48,38 @@\n #  endif\n # endif\n \n-# if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-# endif\n-# if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/cinttypes>\n-# else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n-#  include <tr1_impl/cinttypes>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n-# endif\n+#ifdef _GLIBCXX_USE_C99_INTTYPES_TR1\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  // types\n+  using ::imaxdiv_t;\n+\n+  // functions\n+  using ::imaxabs;\n+\n+  // May collide with _Longlong abs(_Longlong), and is not described\n+  // anywhere outside the synopsis.  Likely, a defect.\n+  //\n+  // intmax_t abs(intmax_t)\n+\n+  using ::imaxdiv;\n+\n+  // Likewise, with lldiv_t div(_Longlong, _Longlong).\n+  //\n+  // imaxdiv_t div(intmax_t, intmax_t)\n+\n+  using ::strtoimax;\n+  using ::strtoumax;\n+\n+#if defined(_GLIBCXX_USE_WCHAR_T) && _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1\n+  using ::wcstoimax;\n+  using ::wcstoumax;\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif _GLIBCXX_USE_C99_INTTYPES_TR1\n \n #else\n "}, {"sha": "9f3a65bbe463ffc2de4c8ef92e024778b73569bb", "filename": "libstdc++-v3/include/c_compatibility/stdint.h", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Fstdint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Fstdint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Fstdint.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -56,22 +56,49 @@\n #  endif\n # endif\n \n-# if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-# endif\n-# if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/cstdint>\n-# else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n-#  include <tr1_impl/cstdint>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n-# endif\n+#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  using ::int8_t;\n+  using ::int16_t;\n+  using ::int32_t;\n+  using ::int64_t;\n+\n+  using ::int_fast8_t;\n+  using ::int_fast16_t;\n+  using ::int_fast32_t;\n+  using ::int_fast64_t;\n+\n+  using ::int_least8_t;\n+  using ::int_least16_t;\n+  using ::int_least32_t;\n+  using ::int_least64_t;\n+\n+  using ::intmax_t;\n+  using ::intptr_t;\n+  \n+  using ::uint8_t;\n+  using ::uint16_t;\n+  using ::uint32_t;\n+  using ::uint64_t;\n+\n+  using ::uint_fast8_t;\n+  using ::uint_fast16_t;\n+  using ::uint_fast32_t;\n+  using ::uint_fast64_t;\n+\n+  using ::uint_least8_t;\n+  using ::uint_least16_t;\n+  using ::uint_least32_t;\n+  using ::uint_least64_t;\n+\n+  using ::uintmax_t;\n+  using ::uintptr_t;\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif // _GLIBCXX_USE_C99_STDINT_TR1\n \n #else\n "}, {"sha": "cab2a5089f686e346259f27527d9d937d92723bf", "filename": "libstdc++-v3/include/c_global/cctype", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcctype?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -80,22 +80,19 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n _GLIBCXX_END_NAMESPACE\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#    error C++0x header cannot be included from TR1 header\n-#  endif\n-#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#    include <tr1_impl/cctype>\n-#  else\n-#    define _GLIBCXX_INCLUDE_AS_CXX0X\n-#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    define _GLIBCXX_END_NAMESPACE_TR1\n-#    define _GLIBCXX_TR1\n-#    include <tr1_impl/cctype>\n-#    undef _GLIBCXX_TR1\n-#    undef _GLIBCXX_END_NAMESPACE_TR1\n-#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#  endif\n-#endif\n+\n+#ifdef _GLIBCXX_USE_C99_CTYPE_TR1\n+\n+#undef isblank\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  using ::isblank;\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif // _GLIBCXX_USE_C99_CTYPE_TR1\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n \n #endif"}, {"sha": "9686e8d35ec02bb4b70eeedcf5786ddfa68afd24", "filename": "libstdc++-v3/include/c_global/cfenv", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfenv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfenv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfenv?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -33,29 +33,53 @@\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <bits/c++0x_warning.h>\n-#endif\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n+#else\n \n #include <bits/c++config.h>\n+\n #if _GLIBCXX_HAVE_FENV_H\n # include <fenv.h>\n #endif\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/cfenv>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n-#  include <tr1_impl/cfenv>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#endif\n+#ifdef _GLIBCXX_USE_C99_FENV_TR1\n+\n+#undef feclearexcept\n+#undef fegetexceptflag\n+#undef feraiseexcept\n+#undef fesetexceptflag\n+#undef fetestexcept\n+#undef fegetround\n+#undef fesetround\n+#undef fegetenv\n+#undef feholdexcept\n+#undef fesetenv\n+#undef feupdateenv\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  // types\n+  using ::fenv_t;\n+  using ::fexcept_t;\n+\n+  // functions\n+  using ::feclearexcept;\n+  using ::fegetexceptflag;\n+  using ::feraiseexcept;\n+  using ::fesetexceptflag;\n+  using ::fetestexcept;\n+\n+  using ::fegetround;\n+  using ::fesetround;\n+\n+  using ::fegetenv;\n+  using ::feholdexcept;\n+  using ::fesetenv;\n+  using ::feupdateenv;\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif // _GLIBCXX_USE_C99_FENV_TR1\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n \n #endif // _GLIBCXX_CFENV"}, {"sha": "0017e75d5091e5a0f5f4dab8065bcadef98d0003", "filename": "libstdc++-v3/include/c_global/cinttypes", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcinttypes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcinttypes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcinttypes?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -33,11 +33,7 @@\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <bits/c++0x_warning.h>\n-#endif\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n+#else\n \n #include <cstdint>\n \n@@ -54,18 +50,39 @@\n # endif\n #endif\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/cinttypes>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n-#  include <tr1_impl/cinttypes>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#ifdef _GLIBCXX_USE_C99_INTTYPES_TR1\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  // types\n+  using ::imaxdiv_t;\n+\n+  // functions\n+  using ::imaxabs;\n+\n+  // May collide with _Longlong abs(_Longlong), and is not described\n+  // anywhere outside the synopsis.  Likely, a defect.\n+  //\n+  // intmax_t abs(intmax_t)\n+\n+  using ::imaxdiv;\n+\n+  // Likewise, with lldiv_t div(_Longlong, _Longlong).\n+  //\n+  // imaxdiv_t div(intmax_t, intmax_t)\n+\n+  using ::strtoimax;\n+  using ::strtoumax;\n+\n+#if defined(_GLIBCXX_USE_WCHAR_T) && _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1\n+  using ::wcstoimax;\n+  using ::wcstoumax;\n #endif\n \n+_GLIBCXX_END_NAMESPACE\n+\n+#endif // _GLIBCXX_USE_C99_INTTYPES_TR1\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n+\n #endif // _GLIBCXX_CINTTYPES"}, {"sha": "b1b6e2d29e279167580573171de6ce3cb82317d8", "filename": "libstdc++-v3/include/c_global/cmath", "status": "modified", "additions": 922, "deletions": 16, "changes": 938, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -846,22 +846,928 @@ _GLIBCXX_END_NAMESPACE\n #endif\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#    error C++0x header cannot be included from TR1 header\n-#  endif\n-#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#    include <tr1_impl/cmath>\n-#  else\n-#    define _GLIBCXX_INCLUDE_AS_CXX0X\n-#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    define _GLIBCXX_END_NAMESPACE_TR1\n-#    define _GLIBCXX_TR1\n-#    include <tr1_impl/cmath>\n-#    undef _GLIBCXX_TR1\n-#    undef _GLIBCXX_END_NAMESPACE_TR1\n-#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#  endif\n+\n+#ifdef _GLIBCXX_USE_C99_MATH_TR1\n+\n+#undef acosh\n+#undef acoshf\n+#undef acoshl\n+#undef asinh\n+#undef asinhf\n+#undef asinhl\n+#undef atanh\n+#undef atanhf\n+#undef atanhl\n+#undef cbrt\n+#undef cbrtf\n+#undef cbrtl\n+#undef copysign\n+#undef copysignf\n+#undef copysignl\n+#undef erf\n+#undef erff\n+#undef erfl\n+#undef erfc\n+#undef erfcf\n+#undef erfcl\n+#undef exp2\n+#undef exp2f\n+#undef exp2l\n+#undef expm1\n+#undef expm1f\n+#undef expm1l\n+#undef fdim\n+#undef fdimf\n+#undef fdiml\n+#undef fma\n+#undef fmaf\n+#undef fmal\n+#undef fmax\n+#undef fmaxf\n+#undef fmaxl\n+#undef fmin\n+#undef fminf\n+#undef fminl\n+#undef hypot\n+#undef hypotf\n+#undef hypotl\n+#undef ilogb\n+#undef ilogbf\n+#undef ilogbl\n+#undef lgamma\n+#undef lgammaf\n+#undef lgammal\n+#undef llrint\n+#undef llrintf\n+#undef llrintl\n+#undef llround\n+#undef llroundf\n+#undef llroundl\n+#undef log1p\n+#undef log1pf\n+#undef log1pl\n+#undef log2\n+#undef log2f\n+#undef log2l\n+#undef logb\n+#undef logbf\n+#undef logbl\n+#undef lrint\n+#undef lrintf\n+#undef lrintl\n+#undef lround\n+#undef lroundf\n+#undef lroundl\n+#undef nan\n+#undef nanf\n+#undef nanl\n+#undef nearbyint\n+#undef nearbyintf\n+#undef nearbyintl\n+#undef nextafter\n+#undef nextafterf\n+#undef nextafterl\n+#undef nexttoward\n+#undef nexttowardf\n+#undef nexttowardl\n+#undef remainder\n+#undef remainderf\n+#undef remainderl\n+#undef remquo\n+#undef remquof\n+#undef remquol\n+#undef rint\n+#undef rintf\n+#undef rintl\n+#undef round\n+#undef roundf\n+#undef roundl\n+#undef scalbln\n+#undef scalblnf\n+#undef scalblnl\n+#undef scalbn\n+#undef scalbnf\n+#undef scalbnl\n+#undef tgamma\n+#undef tgammaf\n+#undef tgammal\n+#undef trunc\n+#undef truncf\n+#undef truncl\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  // types\n+  using ::double_t;\n+  using ::float_t;\n+\n+  // functions\n+  using ::acosh;\n+  using ::acoshf;\n+  using ::acoshl;\n+\n+  using ::asinh;\n+  using ::asinhf;\n+  using ::asinhl;\n+\n+  using ::atanh;\n+  using ::atanhf;\n+  using ::atanhl;\n+\n+  using ::cbrt;\n+  using ::cbrtf;\n+  using ::cbrtl;\n+\n+  using ::copysign;\n+  using ::copysignf;\n+  using ::copysignl;\n+\n+  using ::erf;\n+  using ::erff;\n+  using ::erfl;\n+\n+  using ::erfc;\n+  using ::erfcf;\n+  using ::erfcl;\n+\n+  using ::exp2;\n+  using ::exp2f;\n+  using ::exp2l;\n+\n+  using ::expm1;\n+  using ::expm1f;\n+  using ::expm1l;\n+\n+  using ::fdim;\n+  using ::fdimf;\n+  using ::fdiml;\n+\n+  using ::fma;\n+  using ::fmaf;\n+  using ::fmal;\n+\n+  using ::fmax;\n+  using ::fmaxf;\n+  using ::fmaxl;\n+\n+  using ::fmin;\n+  using ::fminf;\n+  using ::fminl;\n+\n+  using ::hypot;\n+  using ::hypotf;\n+  using ::hypotl;\n+\n+  using ::ilogb;\n+  using ::ilogbf;\n+  using ::ilogbl;\n+\n+  using ::lgamma;\n+  using ::lgammaf;\n+  using ::lgammal;\n+\n+  using ::llrint;\n+  using ::llrintf;\n+  using ::llrintl;\n+\n+  using ::llround;\n+  using ::llroundf;\n+  using ::llroundl;\n+\n+  using ::log1p;\n+  using ::log1pf;\n+  using ::log1pl;\n+\n+  using ::log2;\n+  using ::log2f;\n+  using ::log2l;\n+\n+  using ::logb;\n+  using ::logbf;\n+  using ::logbl;\n+\n+  using ::lrint;\n+  using ::lrintf;\n+  using ::lrintl;\n+\n+  using ::lround;\n+  using ::lroundf;\n+  using ::lroundl;\n+\n+  using ::nan;\n+  using ::nanf;\n+  using ::nanl;\n+\n+  using ::nearbyint;\n+  using ::nearbyintf;\n+  using ::nearbyintl;\n+\n+  using ::nextafter;\n+  using ::nextafterf;\n+  using ::nextafterl;\n+\n+  using ::nexttoward;\n+  using ::nexttowardf;\n+  using ::nexttowardl;\n+\n+  using ::remainder;\n+  using ::remainderf;\n+  using ::remainderl;\n+\n+  using ::remquo;\n+  using ::remquof;\n+  using ::remquol;\n+\n+  using ::rint;\n+  using ::rintf;\n+  using ::rintl;\n+\n+  using ::round;\n+  using ::roundf;\n+  using ::roundl;\n+\n+  using ::scalbln;\n+  using ::scalblnf;\n+  using ::scalblnl;\n+\n+  using ::scalbn;\n+  using ::scalbnf;\n+  using ::scalbnl;\n+\n+  using ::tgamma;\n+  using ::tgammaf;\n+  using ::tgammal;\n+\n+  using ::trunc;\n+  using ::truncf;\n+  using ::truncl;\n+\n+#if _GLIBCXX_USE_C99_MATH\n+#if !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC\n+\n+  /// Function template definitions [8.16.3].\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    fpclassify(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n+\t\t\t\t  FP_SUBNORMAL, FP_ZERO, __type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isfinite(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isfinite(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isinf(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isinf(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isnan(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isnan(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isnormal(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isnormal(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    signbit(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_signbit(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isgreater(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isgreater(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isgreaterequal(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isgreaterequal(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isless(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isless(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    islessequal(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_islessequal(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    islessgreater(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_islessgreater(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isunordered(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isunordered(__type(__f1), __type(__f2));\n+    }\n+\n+#endif\n #endif\n \n+  /// Additional overloads [8.16.4].\n+  inline float\n+  acosh(float __x)\n+  { return __builtin_acoshf(__x); }\n+\n+  inline long double\n+  acosh(long double __x)\n+  { return __builtin_acoshl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    acosh(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return acosh(__type(__x));\n+    }\n+\n+  inline float\n+  asinh(float __x)\n+  { return __builtin_asinhf(__x); }\n+\n+  inline long double\n+  asinh(long double __x)\n+  { return __builtin_asinhl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    asinh(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return asinh(__type(__x));\n+    }\n+\n+  inline float\n+  atanh(float __x)\n+  { return __builtin_atanhf(__x); }\n+\n+  inline long double\n+  atanh(long double __x)\n+  { return __builtin_atanhl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    atanh(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return atanh(__type(__x));\n+    }\n+\n+  inline float\n+  cbrt(float __x)\n+  { return __builtin_cbrtf(__x); }\n+\n+  inline long double\n+  cbrt(long double __x)\n+  { return __builtin_cbrtl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    cbrt(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return cbrt(__type(__x));\n+    }\n+\n+  inline float\n+  copysign(float __x, float __y)\n+  { return __builtin_copysignf(__x, __y); }\n+\n+  inline long double\n+  copysign(long double __x, long double __y)\n+  { return __builtin_copysignl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    copysign(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return copysign(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  erf(float __x)\n+  { return __builtin_erff(__x); }\n+\n+  inline long double\n+  erf(long double __x)\n+  { return __builtin_erfl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    erf(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return erf(__type(__x));\n+    }\n+\n+  inline float\n+  erfc(float __x)\n+  { return __builtin_erfcf(__x); }\n+\n+  inline long double\n+  erfc(long double __x)\n+  { return __builtin_erfcl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    erfc(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return erfc(__type(__x));\n+    }\n+\n+  inline float\n+  exp2(float __x)\n+  { return __builtin_exp2f(__x); }\n+\n+  inline long double\n+  exp2(long double __x)\n+  { return __builtin_exp2l(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    exp2(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return exp2(__type(__x));\n+    }\n+\n+  inline float\n+  expm1(float __x)\n+  { return __builtin_expm1f(__x); }\n+\n+  inline long double\n+  expm1(long double __x)\n+  { return __builtin_expm1l(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    expm1(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return expm1(__type(__x));\n+    }\n+\n+  inline float\n+  fdim(float __x, float __y)\n+  { return __builtin_fdimf(__x, __y); }\n+\n+  inline long double\n+  fdim(long double __x, long double __y)\n+  { return __builtin_fdiml(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    fdim(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return fdim(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  fma(float __x, float __y, float __z)\n+  { return __builtin_fmaf(__x, __y, __z); }\n+\n+  inline long double\n+  fma(long double __x, long double __y, long double __z)\n+  { return __builtin_fmal(__x, __y, __z); }\n+\n+  template<typename _Tp, typename _Up, typename _Vp>\n+    inline typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type\n+    fma(_Tp __x, _Up __y, _Vp __z)\n+    {\n+      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;\n+      return fma(__type(__x), __type(__y), __type(__z));\n+    }\n+\n+  inline float\n+  fmax(float __x, float __y)\n+  { return __builtin_fmaxf(__x, __y); }\n+\n+  inline long double\n+  fmax(long double __x, long double __y)\n+  { return __builtin_fmaxl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    fmax(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return fmax(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  fmin(float __x, float __y)\n+  { return __builtin_fminf(__x, __y); }\n+\n+  inline long double\n+  fmin(long double __x, long double __y)\n+  { return __builtin_fminl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    fmin(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return fmin(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  hypot(float __x, float __y)\n+  { return __builtin_hypotf(__x, __y); }\n+\n+  inline long double\n+  hypot(long double __x, long double __y)\n+  { return __builtin_hypotl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    hypot(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return hypot(__type(__x), __type(__y));\n+    }\n+\n+  inline int\n+  ilogb(float __x)\n+  { return __builtin_ilogbf(__x); }\n+\n+  inline int\n+  ilogb(long double __x)\n+  { return __builtin_ilogbl(__x); }\n+\n+  template<typename _Tp>\n+    inline int\n+    ilogb(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return ilogb(__type(__x));\n+    }\n+\n+  inline float\n+  lgamma(float __x)\n+  { return __builtin_lgammaf(__x); }\n+\n+  inline long double\n+  lgamma(long double __x)\n+  { return __builtin_lgammal(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    lgamma(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return lgamma(__type(__x));\n+    }\n+\n+  inline long long\n+  llrint(float __x)\n+  { return __builtin_llrintf(__x); }\n+\n+  inline long long\n+  llrint(long double __x)\n+  { return __builtin_llrintl(__x); }\n+\n+  template<typename _Tp>\n+    inline long long\n+    llrint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return llrint(__type(__x));\n+    }\n+\n+  inline long long\n+  llround(float __x)\n+  { return __builtin_llroundf(__x); }\n+\n+  inline long long\n+  llround(long double __x)\n+  { return __builtin_llroundl(__x); }\n+\n+  template<typename _Tp>\n+    inline long long\n+    llround(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return llround(__type(__x));\n+    }\n+\n+  inline float\n+  log1p(float __x)\n+  { return __builtin_log1pf(__x); }\n+\n+  inline long double\n+  log1p(long double __x)\n+  { return __builtin_log1pl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    log1p(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return log1p(__type(__x));\n+    }\n+\n+  // DR 568.\n+  inline float\n+  log2(float __x)\n+  { return __builtin_log2f(__x); }\n+\n+  inline long double\n+  log2(long double __x)\n+  { return __builtin_log2l(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    log2(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return log2(__type(__x));\n+    }\n+\n+  inline float\n+  logb(float __x)\n+  { return __builtin_logbf(__x); }\n+\n+  inline long double\n+  logb(long double __x)\n+  { return __builtin_logbl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    logb(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return logb(__type(__x));\n+    }\n+\n+  inline long\n+  lrint(float __x)\n+  { return __builtin_lrintf(__x); }\n+\n+  inline long\n+  lrint(long double __x)\n+  { return __builtin_lrintl(__x); }\n+\n+  template<typename _Tp>\n+    inline long\n+    lrint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return lrint(__type(__x));\n+    }\n+\n+  inline long\n+  lround(float __x)\n+  { return __builtin_lroundf(__x); }\n+\n+  inline long\n+  lround(long double __x)\n+  { return __builtin_lroundl(__x); }\n+\n+  template<typename _Tp>\n+    inline long\n+    lround(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return lround(__type(__x));\n+    }\n+\n+  inline float\n+  nearbyint(float __x)\n+  { return __builtin_nearbyintf(__x); }\n+\n+  inline long double\n+  nearbyint(long double __x)\n+  { return __builtin_nearbyintl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    nearbyint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return nearbyint(__type(__x));\n+    }\n+\n+  inline float\n+  nextafter(float __x, float __y)\n+  { return __builtin_nextafterf(__x, __y); }\n+\n+  inline long double\n+  nextafter(long double __x, long double __y)\n+  { return __builtin_nextafterl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    nextafter(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return nextafter(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  nexttoward(float __x, long double __y)\n+  { return __builtin_nexttowardf(__x, __y); }\n+\n+  inline long double\n+  nexttoward(long double __x, long double __y)\n+  { return __builtin_nexttowardl(__x, __y); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    nexttoward(_Tp __x, long double __y)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return nexttoward(__type(__x), __y);\n+    }\n+\n+  inline float\n+  remainder(float __x, float __y)\n+  { return __builtin_remainderf(__x, __y); }\n+\n+  inline long double\n+  remainder(long double __x, long double __y)\n+  { return __builtin_remainderl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    remainder(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return remainder(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  remquo(float __x, float __y, int* __pquo)\n+  { return __builtin_remquof(__x, __y, __pquo); }\n+\n+  inline long double\n+  remquo(long double __x, long double __y, int* __pquo)\n+  { return __builtin_remquol(__x, __y, __pquo); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    remquo(_Tp __x, _Up __y, int* __pquo)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return remquo(__type(__x), __type(__y), __pquo);\n+    }\n+\n+  inline float\n+  rint(float __x)\n+  { return __builtin_rintf(__x); }\n+\n+  inline long double\n+  rint(long double __x)\n+  { return __builtin_rintl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    rint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return rint(__type(__x));\n+    }\n+\n+  inline float\n+  round(float __x)\n+  { return __builtin_roundf(__x); }\n+\n+  inline long double\n+  round(long double __x)\n+  { return __builtin_roundl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    round(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return round(__type(__x));\n+    }\n+\n+  inline float\n+  scalbln(float __x, long __ex)\n+  { return __builtin_scalblnf(__x, __ex); }\n+\n+  inline long double\n+  scalbln(long double __x, long __ex)\n+  { return __builtin_scalblnl(__x, __ex); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    scalbln(_Tp __x, long __ex)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return scalbln(__type(__x), __ex);\n+    }\n+ \n+  inline float\n+  scalbn(float __x, int __ex)\n+  { return __builtin_scalbnf(__x, __ex); }\n+\n+  inline long double\n+  scalbn(long double __x, int __ex)\n+  { return __builtin_scalbnl(__x, __ex); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    scalbn(_Tp __x, int __ex)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return scalbn(__type(__x), __ex);\n+    }\n+\n+  inline float\n+  tgamma(float __x)\n+  { return __builtin_tgammaf(__x); }\n+\n+  inline long double\n+  tgamma(long double __x)\n+  { return __builtin_tgammal(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    tgamma(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return tgamma(__type(__x));\n+    }\n+ \n+  inline float\n+  trunc(float __x)\n+  { return __builtin_truncf(__x); }\n+\n+  inline long double\n+  trunc(long double __x)\n+  { return __builtin_truncl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    trunc(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return trunc(__type(__x));\n+    }\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif // _GLIBCXX_USE_C99_MATH_TR1\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n+\n #endif"}, {"sha": "45aa7fa84f09dc9d6496e9118c43fd4761e2f477", "filename": "libstdc++-v3/include/c_global/cstdint", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdint", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdint", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdint?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -33,11 +33,7 @@\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <bits/c++0x_warning.h>\n-#endif\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n+#else\n \n #include <bits/c++config.h>\n \n@@ -62,18 +58,50 @@\n # endif\n #endif\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/cstdint>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n-#  include <tr1_impl/cstdint>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#endif\n+#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  using ::int8_t;\n+  using ::int16_t;\n+  using ::int32_t;\n+  using ::int64_t;\n+\n+  using ::int_fast8_t;\n+  using ::int_fast16_t;\n+  using ::int_fast32_t;\n+  using ::int_fast64_t;\n+\n+  using ::int_least8_t;\n+  using ::int_least16_t;\n+  using ::int_least32_t;\n+  using ::int_least64_t;\n+\n+  using ::intmax_t;\n+  using ::intptr_t;\n+  \n+  using ::uint8_t;\n+  using ::uint16_t;\n+  using ::uint32_t;\n+  using ::uint64_t;\n+\n+  using ::uint_fast8_t;\n+  using ::uint_fast16_t;\n+  using ::uint_fast32_t;\n+  using ::uint_fast64_t;\n+\n+  using ::uint_least8_t;\n+  using ::uint_least16_t;\n+  using ::uint_least32_t;\n+  using ::uint_least64_t;\n+\n+  using ::uintmax_t;\n+  using ::uintptr_t;\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif // _GLIBCXX_USE_C99_STDINT_TR1\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n \n #endif // _GLIBCXX_CSTDINT"}, {"sha": "c7eb129cc5fd3bbe2c4bf0d7b49b88c1822e4477", "filename": "libstdc++-v3/include/c_global/cstdio", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdio?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -185,23 +185,4 @@ _GLIBCXX_END_NAMESPACE\n \n #endif // _GLIBCXX_USE_C99\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#    error C++0x header cannot be included from TR1 header\n-#  endif\n-#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#    include <tr1_impl/cstdio>\n-#  else\n-#    define _GLIBCXX_INCLUDE_AS_CXX0X\n-#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    define _GLIBCXX_END_NAMESPACE_TR1\n-#    define _GLIBCXX_TR1\n-#    include <tr1_impl/cstdio>\n-#    undef _GLIBCXX_TR1\n-#    undef _GLIBCXX_END_NAMESPACE_TR1\n-#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#  endif\n-#endif\n-\n #endif"}, {"sha": "31fad41bdd6d3e266ed3909eee9c433b4cbecdfa", "filename": "libstdc++-v3/include/c_global/cstdlib", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -215,27 +215,38 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n _GLIBCXX_END_NAMESPACE\n \n-#endif // _GLIBCXX_USE_C99\n-\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#    error C++0x header cannot be included from TR1 header\n-#  endif\n-#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#    include <tr1_impl/cstdlib>\n-#  else\n-#    define _GLIBCXX_INCLUDE_AS_CXX0X\n-#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    define _GLIBCXX_END_NAMESPACE_TR1\n-#    define _GLIBCXX_TR1\n-#    include <tr1_impl/cstdlib>\n-#    undef _GLIBCXX_TR1\n-#    undef _GLIBCXX_END_NAMESPACE_TR1\n-#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#  endif\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC\n+  // types\n+  using std::lldiv_t;\n+\n+  // functions\n+  using std::llabs;\n+  using std::lldiv;\n #endif\n \n+  using std::atoll;\n+  using std::strtoll;\n+  using std::strtoull;\n+\n+  using std::strtof;\n+  using std::strtold;\n+\n+  // overloads\n+  using std::abs;\n+#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC\n+  using std::div;\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n+\n+#endif // _GLIBCXX_USE_C99\n+\n #endif // !_GLIBCXX_HOSTED\n \n #endif"}, {"sha": "bbfcb64cb4416c6a0946d978789bdd68cf434357", "filename": "libstdc++-v3/include/c_global/cwchar", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwchar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwchar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwchar?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -273,22 +273,34 @@ _GLIBCXX_END_NAMESPACE\n #endif //_GLIBCXX_USE_WCHAR_T\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#    error C++0x header cannot be included from TR1 header\n-#  endif\n-#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#    include <tr1_impl/cwchar>\n-#  else\n-#    define _GLIBCXX_INCLUDE_AS_CXX0X\n-#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    define _GLIBCXX_END_NAMESPACE_TR1\n-#    define _GLIBCXX_TR1\n-#    include <tr1_impl/cwchar>\n-#    undef _GLIBCXX_TR1\n-#    undef _GLIBCXX_END_NAMESPACE_TR1\n-#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#  endif\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+#if _GLIBCXX_HAVE_WCSTOF\n+  using std::wcstof;\n+#endif\n+#if _GLIBCXX_HAVE_VFWSCANF\n+  using std::vfwscanf;\n+#endif\n+#if _GLIBCXX_HAVE_VSWSCANF\n+  using std::vswscanf;\n #endif\n+#if _GLIBCXX_HAVE_VWSCANF\n+  using std::vwscanf;\n+#endif\n+\n+#if _GLIBCXX_USE_C99\n+  using std::wcstold;\n+  using std::wcstoll;\n+  using std::wcstoull;\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif // _GLIBCXX_USE_WCHAR_T\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n \n #endif"}, {"sha": "ff196434c8216f17385a1cb2d6389df8f19ec819", "filename": "libstdc++-v3/include/c_global/cwctype", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwctype?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -111,22 +111,19 @@ _GLIBCXX_END_NAMESPACE\n #endif //_GLIBCXX_USE_WCHAR_T\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#    error C++0x header cannot be included from TR1 header\n-#  endif\n-#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#    include <tr1_impl/cwctype>\n-#  else\n-#    define _GLIBCXX_INCLUDE_AS_CXX0X\n-#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    define _GLIBCXX_END_NAMESPACE_TR1\n-#    define _GLIBCXX_TR1\n-#    include <tr1_impl/cwctype>\n-#    undef _GLIBCXX_TR1\n-#    undef _GLIBCXX_END_NAMESPACE_TR1\n-#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#  endif\n-#endif\n \n-#endif\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+#if _GLIBCXX_HAVE_ISWBLANK\n+  using std::iswblank;\n+#endif  \n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif // _GLIBCXX_USE_WCHAR_T\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n+\n+#endif // _GLIBCXX_CWCTYPE"}, {"sha": "3cad7e8f5add90ffaabea1c7a05d203acac8c6ee", "filename": "libstdc++-v3/include/std/array", "status": "modified", "additions": 227, "deletions": 17, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -35,26 +35,236 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n-\n #include <bits/stl_algobase.h>\n #include <bits/range_access.h>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/array>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n-#  include <tr1_impl/array>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#endif\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  /**\n+   *  @brief A standard container for storing a fixed size sequence of elements.\n+   *\n+   *  @ingroup sequences\n+   *\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+   *  <a href=\"tables.html#66\">reversible container</a>, and a\n+   *  <a href=\"tables.html#67\">sequence</a>.\n+   *\n+   *  Sets support random access iterators.\n+   *\n+   *  @param  Tp  Type of element. Required to be a complete type.\n+   *  @param  N  Number of elements.\n+  */\n+  template<typename _Tp, std::size_t _Nm>\n+    struct array\n+    {\n+      typedef _Tp \t    \t\t\t      value_type;\n+      typedef _Tp*                                    pointer;\n+      typedef const _Tp*                              const_pointer;\n+      typedef value_type&                   \t      reference;\n+      typedef const value_type&             \t      const_reference;\n+      typedef value_type*          \t\t      iterator;\n+      typedef const value_type*\t\t\t      const_iterator;\n+      typedef std::size_t                    \t      size_type;\n+      typedef std::ptrdiff_t                   \t      difference_type;\n+      typedef std::reverse_iterator<iterator>\t      reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;\n+\n+      // Support for zero-sized arrays mandatory.\n+      value_type _M_instance[_Nm ? _Nm : 1];\n+\n+      // No explicit construct/copy/destroy for aggregate type.\n+\n+      // DR 776.\n+      void\n+      fill(const value_type& __u)\n+      { std::fill_n(begin(), size(), __u); }\n+\n+      void\n+      swap(array& __other)\n+      { std::swap_ranges(begin(), end(), __other.begin()); }\n+\n+      // Iterators.\n+      iterator\n+      begin()\n+      { return iterator(std::__addressof(_M_instance[0])); }\n+\n+      const_iterator\n+      begin() const \n+      { return const_iterator(std::__addressof(_M_instance[0])); }\n+\n+      iterator\n+      end()\n+      { return iterator(std::__addressof(_M_instance[_Nm])); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(std::__addressof(_M_instance[_Nm])); }\n+\n+      reverse_iterator \n+      rbegin()\n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator \n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator \n+      rend()\n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator \n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+\n+      const_iterator\n+      cbegin() const \n+      { return const_iterator(std::__addressof(_M_instance[0])); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(std::__addressof(_M_instance[_Nm])); }\n+\n+      const_reverse_iterator \n+      crbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      const_reverse_iterator \n+      crend() const\n+      { return const_reverse_iterator(begin()); }\n+\n+      // Capacity.\n+      constexpr size_type \n+      size() const { return _Nm; }\n+\n+      constexpr size_type \n+      max_size() const { return _Nm; }\n+\n+      constexpr bool \n+      empty() const { return size() == 0; }\n+\n+      // Element access.\n+      reference\n+      operator[](size_type __n)\n+      { return _M_instance[__n]; }\n+\n+      const_reference\n+      operator[](size_type __n) const\n+      { return _M_instance[__n]; }\n+\n+      reference\n+      at(size_type __n)\n+      {\n+\tif (__n >= _Nm)\n+\t  std::__throw_out_of_range(__N(\"array::at\"));\n+\treturn _M_instance[__n];\n+      }\n+\n+      const_reference\n+      at(size_type __n) const\n+      {\n+\tif (__n >= _Nm)\n+\t  std::__throw_out_of_range(__N(\"array::at\"));\n+\treturn _M_instance[__n];\n+      }\n+\n+      reference \n+      front()\n+      { return *begin(); }\n+\n+      const_reference \n+      front() const\n+      { return *begin(); }\n+\n+      reference \n+      back()\n+      { return _Nm ? *(end() - 1) : *end(); }\n+\n+      const_reference \n+      back() const\n+      { return _Nm ? *(end() - 1) : *end(); }\n+\n+      _Tp*\n+      data()\n+      { return std::__addressof(_M_instance[0]); }\n+\n+      const _Tp*\n+      data() const\n+      { return std::__addressof(_M_instance[0]); }\n+    };\n+\n+  // Array comparisons.\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool \n+    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return std::equal(__one.begin(), __one.end(), __two.begin()); }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return !(__one == __two); }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)\n+    { \n+      return std::lexicographical_compare(__a.begin(), __a.end(),\n+\t\t\t\t\t  __b.begin(), __b.end()); \n+    }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return __two < __one; }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return !(__one > __two); }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return !(__one < __two); }\n+\n+  // Specialized algorithms [6.2.2.2].\n+  template<typename _Tp, std::size_t _Nm>\n+    inline void\n+    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)\n+    { __one.swap(__two); }\n+\n+  // Tuple interface to class template array [6.2.2.5].\n+\n+  /// tuple_size\n+  template<typename _Tp> \n+    class tuple_size;\n+\n+  /// tuple_element\n+  template<std::size_t _Int, typename _Tp>\n+    class tuple_element;\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    struct tuple_size<array<_Tp, _Nm> >\n+    { static const std::size_t value = _Nm; };\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    const std::size_t\n+    tuple_size<array<_Tp, _Nm> >::value;  \n+\n+  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n+    struct tuple_element<_Int, array<_Tp, _Nm> >\n+    { typedef _Tp type; };\n+\n+  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n+    inline _Tp&\n+    get(array<_Tp, _Nm>& __arr)\n+    { return __arr[_Int]; }\n+\n+  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n+    inline const _Tp&\n+    get(const array<_Tp, _Nm>& __arr)\n+    { return __arr[_Int]; }\n+\n+_GLIBCXX_END_NAMESPACE\n \n #endif // __GXX_EXPERIMENTAL_CXX0X__\n "}, {"sha": "6361fdac95bfd75ca8b02c21baf6ee363c8d2e56", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -35,19 +35,15 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#ifdef _GLIBCXX_INCLUDE_AS_TR1\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n-\n #include <ratio>\n #include <type_traits>\n #include <limits>\n #include <ctime>\n \n #ifdef _GLIBCXX_USE_C99_STDINT_TR1\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   /**\n    * @defgroup chrono Time\n    * @ingroup utilities\n@@ -689,7 +685,7 @@ namespace std\n   } // namespace chrono\n \n   // @} group chrono\n-} // namespace std\n+_GLIBCXX_END_NAMESPACE\n \n #endif //_GLIBCXX_USE_C99_STDINT_TR1\n "}, {"sha": "46a198c7e92e4b3c26e5697d36abfa7ffc418e23", "filename": "libstdc++-v3/include/std/complex", "status": "modified", "additions": 316, "deletions": 18, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -1523,25 +1523,323 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n _GLIBCXX_END_NAMESPACE\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#    error C++0x header cannot be included from TR1 header\n-#  endif\n-#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#    include <tr1_impl/complex>\n-#  else\n-#    define _GLIBCXX_INCLUDE_AS_CXX0X\n-#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    define _GLIBCXX_END_NAMESPACE_TR1\n-#    define _GLIBCXX_TR1\n-#    include <tr1_impl/complex>\n-#    undef _GLIBCXX_TR1\n-#    undef _GLIBCXX_END_NAMESPACE_TR1\n-#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#  endif\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n+  // Forward declarations.\n+  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);\n+\n+  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);\n+  // DR 595.\n+  template<typename _Tp> _Tp               fabs(const std::complex<_Tp>&);\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    __complex_acos(const std::complex<_Tp>& __z)\n+    {\n+      const std::complex<_Tp> __t = std::asin(__z);\n+      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;\n+      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_acos(__complex__ float __z)\n+  { return __builtin_cacosf(__z); }\n+\n+  inline __complex__ double\n+  __complex_acos(__complex__ double __z)\n+  { return __builtin_cacos(__z); }\n+\n+  inline __complex__ long double\n+  __complex_acos(const __complex__ long double& __z)\n+  { return __builtin_cacosl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acos(const std::complex<_Tp>& __z)\n+    { return __complex_acos(__z.__rep()); }\n+#else\n+  /// acos(__z) [8.1.2].\n+  //  Effects:  Behaves the same as C99 function cacos, defined\n+  //            in subclause 7.3.5.1.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acos(const std::complex<_Tp>& __z)\n+    { return __complex_acos(__z); }\n+#endif\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    __complex_asin(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t(-__z.imag(), __z.real());\n+      __t = std::asinh(__t);\n+      return std::complex<_Tp>(__t.imag(), -__t.real());\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_asin(__complex__ float __z)\n+  { return __builtin_casinf(__z); }\n+\n+  inline __complex__ double\n+  __complex_asin(__complex__ double __z)\n+  { return __builtin_casin(__z); }\n+\n+  inline __complex__ long double\n+  __complex_asin(const __complex__ long double& __z)\n+  { return __builtin_casinl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asin(const std::complex<_Tp>& __z)\n+    { return __complex_asin(__z.__rep()); }\n+#else\n+  /// asin(__z) [8.1.3].\n+  //  Effects:  Behaves the same as C99 function casin, defined\n+  //            in subclause 7.3.5.2.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asin(const std::complex<_Tp>& __z)\n+    { return __complex_asin(__z); }\n+#endif\n+  \n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_atan(const std::complex<_Tp>& __z)\n+    {\n+      const _Tp __r2 = __z.real() * __z.real();\n+      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();\n+\n+      _Tp __num = __z.imag() + _Tp(1.0);\n+      _Tp __den = __z.imag() - _Tp(1.0);\n+\n+      __num = __r2 + __num * __num;\n+      __den = __r2 + __den * __den;\n+\n+      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),\n+\t\t\t       _Tp(0.25) * log(__num / __den));\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_atan(__complex__ float __z)\n+  { return __builtin_catanf(__z); }\n+\n+  inline __complex__ double\n+  __complex_atan(__complex__ double __z)\n+  { return __builtin_catan(__z); }\n+\n+  inline __complex__ long double\n+  __complex_atan(const __complex__ long double& __z)\n+  { return __builtin_catanl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atan(const std::complex<_Tp>& __z)\n+    { return __complex_atan(__z.__rep()); }\n+#else\n+  /// atan(__z) [8.1.4].\n+  //  Effects:  Behaves the same as C99 function catan, defined\n+  //            in subclause 7.3.5.3.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atan(const std::complex<_Tp>& __z)\n+    { return __complex_atan(__z); }\n+#endif\n+\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_acosh(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t((__z.real() - __z.imag())\n+\t\t\t    * (__z.real() + __z.imag()) - _Tp(1.0),\n+\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n+      __t = std::sqrt(__t);\n+\n+      return std::log(__t + __z);\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_acosh(__complex__ float __z)\n+  { return __builtin_cacoshf(__z); }\n+\n+  inline __complex__ double\n+  __complex_acosh(__complex__ double __z)\n+  { return __builtin_cacosh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_acosh(const __complex__ long double& __z)\n+  { return __builtin_cacoshl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acosh(const std::complex<_Tp>& __z)\n+    { return __complex_acosh(__z.__rep()); }\n+#else\n+  /// acosh(__z) [8.1.5].\n+  //  Effects:  Behaves the same as C99 function cacosh, defined\n+  //            in subclause 7.3.6.1.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acosh(const std::complex<_Tp>& __z)\n+    { return __complex_acosh(__z); }\n+#endif\n+\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_asinh(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t((__z.real() - __z.imag())\n+\t\t\t    * (__z.real() + __z.imag()) + _Tp(1.0),\n+\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n+      __t = std::sqrt(__t);\n+\n+      return std::log(__t + __z);\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_asinh(__complex__ float __z)\n+  { return __builtin_casinhf(__z); }\n+\n+  inline __complex__ double\n+  __complex_asinh(__complex__ double __z)\n+  { return __builtin_casinh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_asinh(const __complex__ long double& __z)\n+  { return __builtin_casinhl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asinh(const std::complex<_Tp>& __z)\n+    { return __complex_asinh(__z.__rep()); }\n+#else\n+  /// asinh(__z) [8.1.6].\n+  //  Effects:  Behaves the same as C99 function casin, defined\n+  //            in subclause 7.3.6.2.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asinh(const std::complex<_Tp>& __z)\n+    { return __complex_asinh(__z); }\n+#endif\n+\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_atanh(const std::complex<_Tp>& __z)\n+    {\n+      const _Tp __i2 = __z.imag() * __z.imag();\n+      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();\n+\n+      _Tp __num = _Tp(1.0) + __z.real();\n+      _Tp __den = _Tp(1.0) - __z.real();\n+\n+      __num = __i2 + __num * __num;\n+      __den = __i2 + __den * __den;\n+\n+      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),\n+\t\t\t       _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_atanh(__complex__ float __z)\n+  { return __builtin_catanhf(__z); }\n+\n+  inline __complex__ double\n+  __complex_atanh(__complex__ double __z)\n+  { return __builtin_catanh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_atanh(const __complex__ long double& __z)\n+  { return __builtin_catanhl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atanh(const std::complex<_Tp>& __z)\n+    { return __complex_atanh(__z.__rep()); }\n+#else\n+  /// atanh(__z) [8.1.7].\n+  //  Effects:  Behaves the same as C99 function catanh, defined\n+  //            in subclause 7.3.6.3.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atanh(const std::complex<_Tp>& __z)\n+    { return __complex_atanh(__z); }\n+#endif\n+\n+  template<typename _Tp>\n+    inline _Tp\n+    /// fabs(__z) [8.1.8].\n+    //  Effects:  Behaves the same as C99 function cabs, defined\n+    //            in subclause 7.3.8.1.\n+    fabs(const std::complex<_Tp>& __z)\n+    { return std::abs(__z); }\n+\n+  /// Additional overloads [8.1.9].\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    arg(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+#if (_GLIBCXX_USE_C99_MATH && !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC)\n+      return std::signbit(__x) ? __type(3.1415926535897932384626433832795029L)\n+\t                       : __type();\n+#else\n+      return std::arg(std::complex<__type>(__x));\n+#endif\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    imag(_Tp)\n+    { return _Tp(); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    norm(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __type(__x) * __type(__x);\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    real(_Tp __x)\n+    { return __x; }\n+\n+  template<typename _Tp, typename _Up>\n+    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n+    pow(const std::complex<_Tp>& __x, const _Up& __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return std::pow(std::complex<__type>(__x), __type(__y));\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n+    pow(const _Tp& __x, const std::complex<_Up>& __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return std::pow(__type(__x), std::complex<__type>(__y));\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n+    pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return std::pow(std::complex<__type>(__x),\n+\t\t      std::complex<__type>(__y));\n+    }\n+\n   // Forward declarations.\n   // DR 781.\n   template<typename _Tp> std::complex<_Tp> proj(const std::complex<_Tp>&);\n@@ -1594,6 +1892,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n _GLIBCXX_END_NAMESPACE\n \n-#endif\n+#endif  // __GXX_EXPERIMENTAL_CXX0X__\n \n-#endif\t/* _GLIBCXX_COMPLEX */\n+#endif  /* _GLIBCXX_COMPLEX */"}, {"sha": "71d2133a6e8509b7a587c1e216aff76cb3780698", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -40,8 +40,8 @@\n \n #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   /**\n    * @defgroup condition_variables Condition Variables\n    * @ingroup concurrency\n@@ -254,7 +254,7 @@ namespace std\n   };\n \n   // @} group condition_variables\n-}\n+_GLIBCXX_END_NAMESPACE\n \n #endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1\n "}, {"sha": "0c37ccc0e9fbdb6dd84021ac429643341a8b41d0", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -58,8 +58,8 @@\n #include <bits/functexcept.h>\n #include <bits/functional_hash.h>\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n   /// If we have found a result_type, extract it.\n@@ -2244,7 +2244,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     inline void\n     swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)\n     { __x.swap(__y); }\n-}\n+\n+_GLIBCXX_END_NAMESPACE\n \n #endif // __GXX_EXPERIMENTAL_CXX0X__\n "}, {"sha": "0c3679559148465aa9f95a6306594e7b9e9965b2", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -45,8 +45,8 @@\n #include <atomic>\n #include <bits/functexcept.h>\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   /**\n    * @defgroup futures Futures\n    * @ingroup concurrency\n@@ -1364,7 +1364,7 @@ namespace std\n        // && _GLIBCXX_ATOMIC_BUILTINS_4\n \n   // @} group futures\n-}\n+_GLIBCXX_END_NAMESPACE\n \n #endif // __GXX_EXPERIMENTAL_CXX0X__\n "}, {"sha": "bfc038de32665c129120c5a06fac78e09f8ab8ca", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -69,9 +69,6 @@\n #include <bits/stl_raw_storage_iter.h>\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#    error C++0x header cannot be included from TR1 header\n-#  endif\n #  include <exception>        \t  // std::exception\n #  include <typeinfo>         \t  // std::type_info in get_deleter\n #  include <iosfwd>           \t  // std::basic_ostream\n@@ -86,19 +83,6 @@\n #    include <backward/auto_ptr.h>\n #  endif\n #  include <bits/unique_ptr.h>\n-#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#    include <tr1_impl/boost_sp_counted_base.h>\n-#  else\n-#    define _GLIBCXX_INCLUDE_AS_CXX0X\n-#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    define _GLIBCXX_END_NAMESPACE_TR1\n-#    define _GLIBCXX_TR1\n-#    include <tr1_impl/boost_sp_counted_base.h>\n-#    undef _GLIBCXX_TR1\n-#    undef _GLIBCXX_END_NAMESPACE_TR1\n-#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#  endif\n #  include <bits/shared_ptr.h>\n #else\n #  include <backward/auto_ptr.h>"}, {"sha": "6d86cde8c5d266263ec807df94b031a3e591d04a", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -48,8 +48,8 @@\n \n #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   /**\n    * @defgroup mutexes Mutexes\n    * @ingroup concurrency\n@@ -739,7 +739,7 @@ namespace std\n     }\n \n   // @} group mutexes\n-}\n+_GLIBCXX_END_NAMESPACE\n \n #endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1\n "}, {"sha": "b424ef341a4ac044c97c48c68e54f1fee05461ac", "filename": "libstdc++-v3/include/std/ratio", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -40,8 +40,8 @@\n \n #ifdef _GLIBCXX_USE_C99_STDINT_TR1\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   /**\n    * @defgroup ratio Rational Arithmetic\n    * @ingroup utilities\n@@ -339,7 +339,7 @@ namespace std\n   typedef ratio<      1000000000000000000, 1> exa;\n \n   // @} group ratio\n-}\n+_GLIBCXX_END_NAMESPACE\n \n #endif //_GLIBCXX_USE_C99_STDINT_TR1\n "}, {"sha": "944d0a8a5b289951ed5a7459daecf1d698d99a9b", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -46,8 +46,8 @@\n \n #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   /**\n    * @defgroup threads Threads\n    * @ingroup concurrency\n@@ -283,7 +283,7 @@ namespace std\n   }\n \n   // @} group threads\n-}\n+_GLIBCXX_END_NAMESPACE\n \n #endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1\n "}, {"sha": "302d0f50895969be49dfbb1223ef593d2ff79927", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -37,8 +37,8 @@\n \n #include <utility>\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   // Adds a const reference to a non-reference type.\n   template<typename _Tp>\n     struct __add_c_ref\n@@ -791,7 +791,8 @@ namespace std\n       __do_cons(tuple<_Args...>&& __tuple,\n \t\tconst _Index_tuple<_Indexes...>&)\n       { return _Tp(std::forward<_Args>(get<_Indexes>(__tuple))...); }\n-}\n+\n+_GLIBCXX_END_NAMESPACE\n \n #endif // __GXX_EXPERIMENTAL_CXX0X__\n "}, {"sha": "fe84a6f92acb02904442658f30c671fe1aeb9539", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 456, "deletions": 20, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -35,32 +35,463 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n-\n #include <bits/c++config.h>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/type_traits>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n-#  include <tr1_impl/type_traits>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#endif\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n \n-namespace std\n-{\n   /**\n    * @addtogroup metaprogramming\n    * @{\n    */\n+  struct __sfinae_types\n+  {\n+    typedef char __one;\n+    typedef struct { char __arr[2]; } __two;\n+  };\n+\n+#define _DEFINE_SPEC_0_HELPER                          \\\n+  template<>\n+\n+#define _DEFINE_SPEC_1_HELPER                          \\\n+  template<typename _Tp>\n+\n+#define _DEFINE_SPEC_2_HELPER                          \\\n+  template<typename _Tp, typename _Cp>\n+\n+#define _DEFINE_SPEC(_Order, _Trait, _Type, _Value)    \\\n+  _DEFINE_SPEC_##_Order##_HELPER                       \\\n+    struct _Trait<_Type>                               \\\n+    : public integral_constant<bool, _Value> { };\n+\n+  // helper classes.\n+\n+  /// integral_constant\n+  template<typename _Tp, _Tp __v>\n+    struct integral_constant\n+    {\n+      static constexpr _Tp                  value = __v;\n+      typedef _Tp                           value_type;\n+      typedef integral_constant<_Tp, __v>   type;\n+      constexpr operator value_type() { return value; }\n+    };\n+  \n+  /// typedef for true_type\n+  typedef integral_constant<bool, true>     true_type;\n+\n+  /// typedef for false_type\n+  typedef integral_constant<bool, false>    false_type;\n+\n+  template<typename _Tp, _Tp __v>\n+    constexpr _Tp integral_constant<_Tp, __v>::value;\n+\n+  /// remove_cv\n+  template<typename>\n+    struct remove_cv;\n+\n+  template<typename>\n+    struct __is_void_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(0, __is_void_helper, void, true)\n+\n+  // primary type categories.\n+\n+  /// is_void\n+  template<typename _Tp>\n+    struct is_void\n+    : public integral_constant<bool, (__is_void_helper<typename\n+\t\t\t\t      remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  template<typename>\n+    struct __is_integral_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(0, __is_integral_helper, bool, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, char, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, signed char, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, unsigned char, true)\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  _DEFINE_SPEC(0, __is_integral_helper, wchar_t, true)\n+#endif\n+  _DEFINE_SPEC(0, __is_integral_helper, char16_t, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, char32_t, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, short, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, unsigned short, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, int, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, unsigned int, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, long, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, unsigned long, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, long long, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, unsigned long long, true)\n+\n+  /// is_integral\n+  template<typename _Tp>\n+    struct is_integral\n+    : public integral_constant<bool, (__is_integral_helper<typename\n+\t\t\t\t      remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  template<typename>\n+    struct __is_floating_point_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(0, __is_floating_point_helper, float, true)\n+  _DEFINE_SPEC(0, __is_floating_point_helper, double, true)\n+  _DEFINE_SPEC(0, __is_floating_point_helper, long double, true)\n+\n+  /// is_floating_point\n+  template<typename _Tp>\n+    struct is_floating_point\n+    : public integral_constant<bool, (__is_floating_point_helper<typename\n+\t\t\t\t      remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  /// is_array\n+  template<typename>\n+    struct is_array\n+    : public false_type { };\n+\n+  template<typename _Tp, std::size_t _Size>\n+    struct is_array<_Tp[_Size]>\n+    : public true_type { };\n+\n+  template<typename _Tp>\n+    struct is_array<_Tp[]>\n+    : public true_type { };\n+\n+  template<typename>\n+    struct __is_pointer_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(1, __is_pointer_helper, _Tp*, true)\n+\n+  /// is_pointer\n+  template<typename _Tp>\n+    struct is_pointer\n+    : public integral_constant<bool, (__is_pointer_helper<typename\n+\t\t\t\t      remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  /// is_reference\n+  template<typename _Tp>\n+    struct is_reference;\n+\n+  /// is_function\n+  template<typename _Tp>\n+    struct is_function;\n+\n+  template<typename>\n+    struct __is_member_object_pointer_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(2, __is_member_object_pointer_helper, _Tp _Cp::*,\n+\t       !is_function<_Tp>::value)\n+\n+  /// is_member_object_pointer\n+  template<typename _Tp>\n+    struct is_member_object_pointer\n+    : public integral_constant<bool, (__is_member_object_pointer_helper<\n+\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  template<typename>\n+    struct __is_member_function_pointer_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(2, __is_member_function_pointer_helper, _Tp _Cp::*,\n+\t       is_function<_Tp>::value)\n+\n+  /// is_member_function_pointer\n+  template<typename _Tp>\n+    struct is_member_function_pointer\n+    : public integral_constant<bool, (__is_member_function_pointer_helper<\n+\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  /// is_enum\n+  template<typename _Tp>\n+    struct is_enum\n+    : public integral_constant<bool, __is_enum(_Tp)>\n+    { };\n+\n+  /// is_union\n+  template<typename _Tp>\n+    struct is_union\n+    : public integral_constant<bool, __is_union(_Tp)>\n+    { };\n+\n+  /// is_class\n+  template<typename _Tp>\n+    struct is_class\n+    : public integral_constant<bool, __is_class(_Tp)>\n+    { };\n+\n+  /// is_function\n+  template<typename>\n+    struct is_function\n+    : public false_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes...)>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes......)>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes...) const>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes......) const>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes...) volatile>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes......) volatile>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes...) const volatile>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes......) const volatile>\n+    : public true_type { };\n+\n+  // composite type traits.\n+  \n+  /// is_arithmetic\n+  template<typename _Tp>\n+    struct is_arithmetic\n+    : public integral_constant<bool, (is_integral<_Tp>::value\n+\t\t\t\t      || is_floating_point<_Tp>::value)>\n+    { };\n+\n+  /// is_fundamental\n+  template<typename _Tp>\n+    struct is_fundamental\n+    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n+\t\t\t\t      || is_void<_Tp>::value)>\n+    { };\n+\n+  /// is_object\n+  template<typename _Tp>\n+    struct is_object\n+    : public integral_constant<bool, !(is_function<_Tp>::value\n+\t\t\t\t       || is_reference<_Tp>::value\n+\t\t\t\t       || is_void<_Tp>::value)>\n+    { };\n+\n+  /// is_member_pointer\n+  template<typename _Tp>\n+    struct is_member_pointer;\n+\n+  /// is_scalar\n+  template<typename _Tp>\n+    struct is_scalar\n+    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n+\t\t\t\t      || is_enum<_Tp>::value\n+\t\t\t\t      || is_pointer<_Tp>::value\n+\t\t\t\t      || is_member_pointer<_Tp>::value)>\n+    { };\n+\n+  /// is_compound\n+  template<typename _Tp>\n+    struct is_compound\n+    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };\n+\n+  /// is_member_pointer\n+  template<typename _Tp>\n+    struct __is_member_pointer_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(2, __is_member_pointer_helper, _Tp _Cp::*, true)\n+\n+  template<typename _Tp>\n+  struct is_member_pointer\n+    : public integral_constant<bool, (__is_member_pointer_helper<\n+\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  // type properties.\n+  /// is_const\n+  template<typename>\n+    struct is_const\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct is_const<_Tp const>\n+    : public true_type { };\n+  \n+  /// is_volatile\n+  template<typename>\n+    struct is_volatile\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct is_volatile<_Tp volatile>\n+    : public true_type { };\n+\n+  /// is_empty\n+  template<typename _Tp>\n+    struct is_empty\n+    : public integral_constant<bool, __is_empty(_Tp)>\n+    { };\n+\n+  /// is_polymorphic\n+  template<typename _Tp>\n+    struct is_polymorphic\n+    : public integral_constant<bool, __is_polymorphic(_Tp)>\n+    { };\n+\n+  /// is_abstract\n+  template<typename _Tp>\n+    struct is_abstract\n+    : public integral_constant<bool, __is_abstract(_Tp)>\n+    { };\n+\n+  /// has_virtual_destructor\n+  template<typename _Tp>\n+    struct has_virtual_destructor\n+    : public integral_constant<bool, __has_virtual_destructor(_Tp)>\n+    { };\n+\n+  /// alignment_of\n+  template<typename _Tp>\n+    struct alignment_of\n+    : public integral_constant<std::size_t, __alignof__(_Tp)> { };\n+  \n+  /// rank\n+  template<typename>\n+    struct rank\n+    : public integral_constant<std::size_t, 0> { };\n+   \n+  template<typename _Tp, std::size_t _Size>\n+    struct rank<_Tp[_Size]>\n+    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n+\n+  template<typename _Tp>\n+    struct rank<_Tp[]>\n+    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n+\n+  /// extent\n+  template<typename, unsigned _Uint = 0>\n+    struct extent\n+    : public integral_constant<std::size_t, 0> { };\n+  \n+  template<typename _Tp, unsigned _Uint, std::size_t _Size>\n+    struct extent<_Tp[_Size], _Uint>\n+    : public integral_constant<std::size_t,\n+\t\t\t       _Uint == 0 ? _Size : extent<_Tp,\n+\t\t\t\t\t\t\t   _Uint - 1>::value>\n+    { };\n+\n+  template<typename _Tp, unsigned _Uint>\n+    struct extent<_Tp[], _Uint>\n+    : public integral_constant<std::size_t,\n+\t\t\t       _Uint == 0 ? 0 : extent<_Tp,\n+\t\t\t\t\t\t       _Uint - 1>::value>\n+    { };\n+\n+  // relationships between types [4.6].\n+\n+  /// is_same\n+  template<typename, typename>\n+    struct is_same\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct is_same<_Tp, _Tp>\n+    : public true_type { };\n+\n+  // const-volatile modifications [4.7.1].\n+\n+  /// remove_const\n+  template<typename _Tp>\n+    struct remove_const\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp>\n+    struct remove_const<_Tp const>\n+    { typedef _Tp     type; };\n+  \n+  /// remove_volatile\n+  template<typename _Tp>\n+    struct remove_volatile\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp>\n+    struct remove_volatile<_Tp volatile>\n+    { typedef _Tp     type; };\n+  \n+  /// remove_cv\n+  template<typename _Tp>\n+    struct remove_cv\n+    {\n+      typedef typename\n+      remove_const<typename remove_volatile<_Tp>::type>::type     type;\n+    };\n+  \n+  /// add_const\n+  template<typename _Tp>\n+    struct add_const\n+    { typedef _Tp const     type; };\n+   \n+  /// add_volatile\n+  template<typename _Tp>\n+    struct add_volatile\n+    { typedef _Tp volatile     type; };\n+  \n+  /// add_cv\n+  template<typename _Tp>\n+    struct add_cv\n+    {\n+      typedef typename\n+      add_const<typename add_volatile<_Tp>::type>::type     type;\n+    };\n+\n+  // array modifications.\n+\n+  /// remove_extent\n+  template<typename _Tp>\n+    struct remove_extent\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp, std::size_t _Size>\n+    struct remove_extent<_Tp[_Size]>\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp>\n+    struct remove_extent<_Tp[]>\n+    { typedef _Tp     type; };\n+\n+  /// remove_all_extents\n+  template<typename _Tp>\n+    struct remove_all_extents\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp, std::size_t _Size>\n+    struct remove_all_extents<_Tp[_Size]>\n+    { typedef typename remove_all_extents<_Tp>::type     type; };\n+\n+  template<typename _Tp>\n+    struct remove_all_extents<_Tp[]>\n+    { typedef typename remove_all_extents<_Tp>::type     type; };\n+\n+  // pointer modifications.\n+\n+  template<typename _Tp, typename>\n+    struct __remove_pointer_helper\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp, typename _Up>\n+    struct __remove_pointer_helper<_Tp, _Up*>\n+    { typedef _Up     type; };\n+\n+  /// remove_pointer\n+  template<typename _Tp>\n+    struct remove_pointer\n+    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>\n+    { };\n+\n+  template<typename>\n+    struct remove_reference;\n+\n+  /// add_pointer\n+  template<typename _Tp>\n+    struct add_pointer\n+    { typedef typename remove_reference<_Tp>::type*     type; };\n \n   // Primary classification traits.\n \n@@ -731,8 +1162,13 @@ namespace std\n \t\t\t<typename remove_cv<_Tp>::type>::value>  \\\n     { };\n \n+#undef _DEFINE_SPEC_0_HELPER\n+#undef _DEFINE_SPEC_1_HELPER\n+#undef _DEFINE_SPEC_2_HELPER\n+#undef _DEFINE_SPEC\n+\n   // @} group metaprogramming\n-}\n+_GLIBCXX_END_NAMESPACE\n \n #endif  // __GXX_EXPERIMENTAL_CXX0X__\n "}, {"sha": "d40306421d41f1e674f65e40ab7632cb71682b56", "filename": "libstdc++-v3/include/std/typeindex", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftypeindex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftypeindex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftypeindex?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -37,8 +37,8 @@\n \n #include <typeinfo>\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   /**\n      @brief The class type_index provides a simple wrapper for type_info\n      which can be used as an index type in associative containers (23.6)\n@@ -98,7 +98,8 @@ namespace std\n       operator()(const type_index& __ti) const\n       { return __ti.hash_code(); }\n     };\n-}\n+\n+_GLIBCXX_END_NAMESPACE\n \n #endif  // __GXX_EXPERIMENTAL_CXX0X__\n "}, {"sha": "e54a5868c9076e05513d4fce67fb0f99b649fafe", "filename": "libstdc++-v3/include/std/utility", "status": "modified", "additions": 68, "deletions": 19, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -1,6 +1,6 @@\n // <utility> -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -71,24 +71,73 @@\n #include <bits/stl_pair.h>\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#    error C++0x header cannot be included from TR1 header\n-#  endif\n-#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#    include <tr1_impl/utility>\n-#  else\n-#    define _GLIBCXX_INCLUDE_AS_CXX0X\n-#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    define _GLIBCXX_END_NAMESPACE_TR1\n-#    define _GLIBCXX_TR1\n-#    include <tr1_impl/utility>\n-#    undef _GLIBCXX_TR1\n-#    undef _GLIBCXX_END_NAMESPACE_TR1\n-#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#  endif\n-#  include <bits/move.h>\n-#  include <initializer_list>\n+#include <bits/move.h>\n+#include <initializer_list>\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  template<class _Tp>\n+    class tuple_size;\n+\n+  template<std::size_t _Int, class _Tp>\n+    class tuple_element;\n+\n+   // Various functions which give std::pair a tuple-like interface.\n+  template<class _Tp1, class _Tp2>\n+    struct tuple_size<std::pair<_Tp1, _Tp2> >\n+    { static const std::size_t value = 2; };\n+\n+  template<class _Tp1, class _Tp2>\n+    const std::size_t\n+    tuple_size<std::pair<_Tp1, _Tp2> >::value;\n+\n+  template<class _Tp1, class _Tp2>\n+    struct tuple_element<0, std::pair<_Tp1, _Tp2> >\n+    { typedef _Tp1 type; };\n+ \n+  template<class _Tp1, class _Tp2>\n+    struct tuple_element<1, std::pair<_Tp1, _Tp2> >\n+    { typedef _Tp2 type; };\n+\n+  template<std::size_t _Int>\n+    struct __pair_get;\n+\n+  template<>\n+    struct __pair_get<0>\n+    {\n+      template<typename _Tp1, typename _Tp2>\n+      static _Tp1& __get(std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.first; }\n+\n+      template<typename _Tp1, typename _Tp2>\n+      static const _Tp1& __const_get(const std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.first; }\n+    };\n+\n+  template<>\n+    struct __pair_get<1>\n+    {\n+      template<typename _Tp1, typename _Tp2>\n+      static _Tp2& __get(std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.second; }\n+\n+      template<typename _Tp1, typename _Tp2>\n+      static const _Tp2& __const_get(const std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.second; }\n+    };\n+\n+  template<std::size_t _Int, class _Tp1, class _Tp2>\n+    inline typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n+    get(std::pair<_Tp1, _Tp2>& __in)\n+    { return __pair_get<_Int>::__get(__in); }\n+\n+  template<std::size_t _Int, class _Tp1, class _Tp2>\n+    inline const typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n+    get(const std::pair<_Tp1, _Tp2>& __in)\n+    { return __pair_get<_Int>::__const_get(__in); }\n+\n+_GLIBCXX_END_NAMESPACE\n+\n #endif\n \n #endif /* _GLIBCXX_UTILITY */"}, {"sha": "3a1ff4caa8c79dae82eb2b9c99a7a58c389400a2", "filename": "libstdc++-v3/include/tr1/array", "status": "modified", "additions": 212, "deletions": 18, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Farray?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -1,6 +1,7 @@\n // class template array -*- C++ -*-\n \n-// Copyright (C) 2004, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,24 +32,217 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <bits/stl_algobase.h>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/array>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/array>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n+namespace std\n+{\n+namespace tr1\n+{\n+  /**\n+   *  @brief A standard container for storing a fixed size sequence of elements.\n+   *\n+   *  @ingroup sequences\n+   *\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+   *  <a href=\"tables.html#66\">reversible container</a>, and a\n+   *  <a href=\"tables.html#67\">sequence</a>.\n+   *\n+   *  Sets support random access iterators.\n+   *\n+   *  @param  Tp  Type of element. Required to be a complete type.\n+   *  @param  N  Number of elements.\n+  */\n+  template<typename _Tp, std::size_t _Nm>\n+    struct array\n+    {\n+      typedef _Tp \t    \t\t\t      value_type;\n+      typedef value_type&                   \t      reference;\n+      typedef const value_type&             \t      const_reference;\n+      typedef value_type*          \t\t      iterator;\n+      typedef const value_type*\t\t\t      const_iterator;\n+      typedef std::size_t                    \t      size_type;\n+      typedef std::ptrdiff_t                   \t      difference_type;\n+      typedef std::reverse_iterator<iterator>\t      reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;\n+\n+      // Support for zero-sized arrays mandatory.\n+      value_type _M_instance[_Nm ? _Nm : 1];\n+\n+      // No explicit construct/copy/destroy for aggregate type.\n+\n+      void\n+      assign(const value_type& __u)\n+      { std::fill_n(begin(), size(), __u); }\n+\n+      void\n+      swap(array& __other)\n+      { std::swap_ranges(begin(), end(), __other.begin()); }\n+\n+      // Iterators.\n+      iterator\n+      begin()\n+      { return iterator(std::__addressof(_M_instance[0])); }\n+\n+      const_iterator\n+      begin() const \n+      { return const_iterator(std::__addressof(_M_instance[0])); }\n+\n+      iterator\n+      end()\n+      { return iterator(std::__addressof(_M_instance[_Nm])); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(std::__addressof(_M_instance[_Nm])); }\n+\n+      reverse_iterator \n+      rbegin()\n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator \n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator \n+      rend()\n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator \n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+\n+      // Capacity.\n+      size_type \n+      size() const { return _Nm; }\n+\n+      size_type \n+      max_size() const { return _Nm; }\n+\n+      bool \n+      empty() const { return size() == 0; }\n+\n+      // Element access.\n+      reference\n+      operator[](size_type __n)\n+      { return _M_instance[__n]; }\n+\n+      const_reference\n+      operator[](size_type __n) const\n+      { return _M_instance[__n]; }\n+\n+      reference\n+      at(size_type __n)\n+      {\n+\tif (__n >= _Nm)\n+\t  std::__throw_out_of_range(__N(\"array::at\"));\n+\treturn _M_instance[__n];\n+      }\n+\n+      const_reference\n+      at(size_type __n) const\n+      {\n+\tif (__n >= _Nm)\n+\t  std::__throw_out_of_range(__N(\"array::at\"));\n+\treturn _M_instance[__n];\n+      }\n+\n+      reference \n+      front()\n+      { return *begin(); }\n+\n+      const_reference \n+      front() const\n+      { return *begin(); }\n+\n+      reference \n+      back()\n+      { return _Nm ? *(end() - 1) : *end(); }\n+\n+      const_reference \n+      back() const\n+      { return _Nm ? *(end() - 1) : *end(); }\n+\n+      _Tp*\n+      data()\n+      { return std::__addressof(_M_instance[0]); }\n+\n+      const _Tp*\n+      data() const\n+      { return std::__addressof(_M_instance[0]); }\n+    };\n+\n+  // Array comparisons.\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool \n+    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return std::equal(__one.begin(), __one.end(), __two.begin()); }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return !(__one == __two); }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)\n+    { \n+      return std::lexicographical_compare(__a.begin(), __a.end(),\n+\t\t\t\t\t  __b.begin(), __b.end()); \n+    }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return __two < __one; }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return !(__one > __two); }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return !(__one < __two); }\n+\n+  // Specialized algorithms [6.2.2.2].\n+  template<typename _Tp, std::size_t _Nm>\n+    inline void\n+    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)\n+    { __one.swap(__two); }\n+\n+  // Tuple interface to class template array [6.2.2.5].\n+\n+  /// tuple_size\n+  template<typename _Tp> \n+    class tuple_size;\n+\n+  /// tuple_element\n+  template<int _Int, typename _Tp>\n+    class tuple_element;\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    struct tuple_size<array<_Tp, _Nm> >\n+    { static const int value = _Nm; };\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    const int\n+    tuple_size<array<_Tp, _Nm> >::value;  \n+\n+  template<int _Int, typename _Tp, std::size_t _Nm>\n+    struct tuple_element<_Int, array<_Tp, _Nm> >\n+    { typedef _Tp type; };\n+\n+  template<int _Int, typename _Tp, std::size_t _Nm>\n+    inline _Tp&\n+    get(array<_Tp, _Nm>& __arr)\n+    { return __arr[_Int]; }\n+\n+  template<int _Int, typename _Tp, std::size_t _Nm>\n+    inline const _Tp&\n+    get(const array<_Tp, _Nm>& __arr)\n+    { return __arr[_Int]; }\n+}\n+}\n \n #endif // _GLIBCXX_TR1_ARRAY"}, {"sha": "ecdb0833fc668f7c5a6113519e6b8f07ae6cd941", "filename": "libstdc++-v3/include/tr1/cctype", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcctype?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -32,18 +32,18 @@\n #include <bits/c++config.h>\n #include <cctype>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/cctype>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/cctype>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n+#ifdef _GLIBCXX_USE_C99_CTYPE_TR1\n+\n+#undef isblank\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+  using ::isblank;\n+}\n+}\n+\n #endif\n \n #endif // _GLIBCXX_TR1_CCTYPE"}, {"sha": "14db2ca3f75f2909097c41f1bc157f66437ed7fc", "filename": "libstdc++-v3/include/tr1/cfenv", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcfenv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcfenv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcfenv?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -1,6 +1,6 @@\n // TR1 cfenv -*- C++ -*-\n \n-// Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,22 +32,50 @@\n #pragma GCC system_header\n \n #include <bits/c++config.h>\n+\n #if _GLIBCXX_HAVE_FENV_H\n # include <fenv.h>\n #endif\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/cfenv>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/cfenv>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n+#ifdef _GLIBCXX_USE_C99_FENV_TR1\n+\n+#undef feclearexcept\n+#undef fegetexceptflag\n+#undef feraiseexcept\n+#undef fesetexceptflag\n+#undef fetestexcept\n+#undef fegetround\n+#undef fesetround\n+#undef fegetenv\n+#undef feholdexcept\n+#undef fesetenv\n+#undef feupdateenv\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+  // types\n+  using ::fenv_t;\n+  using ::fexcept_t;\n+\n+  // functions\n+  using ::feclearexcept;\n+  using ::fegetexceptflag;\n+  using ::feraiseexcept;\n+  using ::fesetexceptflag;\n+  using ::fetestexcept;\n+\n+  using ::fegetround;\n+  using ::fesetround;\n+\n+  using ::fegetenv;\n+  using ::feholdexcept;\n+  using ::fesetenv;\n+  using ::feupdateenv;\n+}\n+}\n+\n+#endif // _GLIBCXX_USE_C99_FENV_TR1\n \n #endif // _GLIBCXX_TR1_CFENV"}, {"sha": "e0cd1718e6de13a628b0ffb40ebea27ef41fb1d5", "filename": "libstdc++-v3/include/tr1/cinttypes", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcinttypes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcinttypes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcinttypes?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -1,6 +1,6 @@\n // TR1 cinttypes -*- C++ -*-\n \n-// Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -46,18 +46,39 @@\n # endif\n #endif\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/cinttypes>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/cinttypes>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n+#ifdef _GLIBCXX_USE_C99_INTTYPES_TR1\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+  // types\n+  using ::imaxdiv_t;\n+\n+  // functions\n+  using ::imaxabs;\n+\n+  // May collide with _Longlong abs(_Longlong), and is not described\n+  // anywhere outside the synopsis.  Likely, a defect.\n+  //\n+  // intmax_t abs(intmax_t)\n+\n+  using ::imaxdiv;\n+\n+  // Likewise, with lldiv_t div(_Longlong, _Longlong).\n+  //\n+  // imaxdiv_t div(intmax_t, intmax_t)\n+\n+  using ::strtoimax;\n+  using ::strtoumax;\n+\n+#if defined(_GLIBCXX_USE_WCHAR_T) && _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1\n+  using ::wcstoimax;\n+  using ::wcstoumax;\n #endif\n+}\n+}\n+\n+#endif // _GLIBCXX_USE_C99_INTTYPES_TR1\n \n #endif // _GLIBCXX_TR1_CINTTYPES"}, {"sha": "4c6e4c1ece779e3ca883ffd8db9221e67c9f3a16", "filename": "libstdc++-v3/include/tr1/cmath", "status": "modified", "additions": 965, "deletions": 12, "changes": 977, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -37,20 +37,973 @@\n \n #include <cmath>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/cmath>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/cmath>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n+#ifdef _GLIBCXX_USE_C99_MATH_TR1\n+\n+#undef acosh\n+#undef acoshf\n+#undef acoshl\n+#undef asinh\n+#undef asinhf\n+#undef asinhl\n+#undef atanh\n+#undef atanhf\n+#undef atanhl\n+#undef cbrt\n+#undef cbrtf\n+#undef cbrtl\n+#undef copysign\n+#undef copysignf\n+#undef copysignl\n+#undef erf\n+#undef erff\n+#undef erfl\n+#undef erfc\n+#undef erfcf\n+#undef erfcl\n+#undef exp2\n+#undef exp2f\n+#undef exp2l\n+#undef expm1\n+#undef expm1f\n+#undef expm1l\n+#undef fdim\n+#undef fdimf\n+#undef fdiml\n+#undef fma\n+#undef fmaf\n+#undef fmal\n+#undef fmax\n+#undef fmaxf\n+#undef fmaxl\n+#undef fmin\n+#undef fminf\n+#undef fminl\n+#undef hypot\n+#undef hypotf\n+#undef hypotl\n+#undef ilogb\n+#undef ilogbf\n+#undef ilogbl\n+#undef lgamma\n+#undef lgammaf\n+#undef lgammal\n+#undef llrint\n+#undef llrintf\n+#undef llrintl\n+#undef llround\n+#undef llroundf\n+#undef llroundl\n+#undef log1p\n+#undef log1pf\n+#undef log1pl\n+#undef log2\n+#undef log2f\n+#undef log2l\n+#undef logb\n+#undef logbf\n+#undef logbl\n+#undef lrint\n+#undef lrintf\n+#undef lrintl\n+#undef lround\n+#undef lroundf\n+#undef lroundl\n+#undef nan\n+#undef nanf\n+#undef nanl\n+#undef nearbyint\n+#undef nearbyintf\n+#undef nearbyintl\n+#undef nextafter\n+#undef nextafterf\n+#undef nextafterl\n+#undef nexttoward\n+#undef nexttowardf\n+#undef nexttowardl\n+#undef remainder\n+#undef remainderf\n+#undef remainderl\n+#undef remquo\n+#undef remquof\n+#undef remquol\n+#undef rint\n+#undef rintf\n+#undef rintl\n+#undef round\n+#undef roundf\n+#undef roundl\n+#undef scalbln\n+#undef scalblnf\n+#undef scalblnl\n+#undef scalbn\n+#undef scalbnf\n+#undef scalbnl\n+#undef tgamma\n+#undef tgammaf\n+#undef tgammal\n+#undef trunc\n+#undef truncf\n+#undef truncl\n+\n+#endif\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+\n+  // types\n+  using ::double_t;\n+  using ::float_t;\n+\n+  // functions\n+  using ::acosh;\n+  using ::acoshf;\n+  using ::acoshl;\n+\n+  using ::asinh;\n+  using ::asinhf;\n+  using ::asinhl;\n+\n+  using ::atanh;\n+  using ::atanhf;\n+  using ::atanhl;\n+\n+  using ::cbrt;\n+  using ::cbrtf;\n+  using ::cbrtl;\n+\n+  using ::copysign;\n+  using ::copysignf;\n+  using ::copysignl;\n+\n+  using ::erf;\n+  using ::erff;\n+  using ::erfl;\n+\n+  using ::erfc;\n+  using ::erfcf;\n+  using ::erfcl;\n+\n+  using ::exp2;\n+  using ::exp2f;\n+  using ::exp2l;\n+\n+  using ::expm1;\n+  using ::expm1f;\n+  using ::expm1l;\n+\n+  using ::fdim;\n+  using ::fdimf;\n+  using ::fdiml;\n+\n+  using ::fma;\n+  using ::fmaf;\n+  using ::fmal;\n+\n+  using ::fmax;\n+  using ::fmaxf;\n+  using ::fmaxl;\n+\n+  using ::fmin;\n+  using ::fminf;\n+  using ::fminl;\n+\n+  using ::hypot;\n+  using ::hypotf;\n+  using ::hypotl;\n+\n+  using ::ilogb;\n+  using ::ilogbf;\n+  using ::ilogbl;\n+\n+  using ::lgamma;\n+  using ::lgammaf;\n+  using ::lgammal;\n+\n+  using ::llrint;\n+  using ::llrintf;\n+  using ::llrintl;\n+\n+  using ::llround;\n+  using ::llroundf;\n+  using ::llroundl;\n+\n+  using ::log1p;\n+  using ::log1pf;\n+  using ::log1pl;\n+\n+  using ::log2;\n+  using ::log2f;\n+  using ::log2l;\n+\n+  using ::logb;\n+  using ::logbf;\n+  using ::logbl;\n+\n+  using ::lrint;\n+  using ::lrintf;\n+  using ::lrintl;\n+\n+  using ::lround;\n+  using ::lroundf;\n+  using ::lroundl;\n+\n+  using ::nan;\n+  using ::nanf;\n+  using ::nanl;\n+\n+  using ::nearbyint;\n+  using ::nearbyintf;\n+  using ::nearbyintl;\n+\n+  using ::nextafter;\n+  using ::nextafterf;\n+  using ::nextafterl;\n+\n+  using ::nexttoward;\n+  using ::nexttowardf;\n+  using ::nexttowardl;\n+\n+  using ::remainder;\n+  using ::remainderf;\n+  using ::remainderl;\n+\n+  using ::remquo;\n+  using ::remquof;\n+  using ::remquol;\n+\n+  using ::rint;\n+  using ::rintf;\n+  using ::rintl;\n+\n+  using ::round;\n+  using ::roundf;\n+  using ::roundl;\n+\n+  using ::scalbln;\n+  using ::scalblnf;\n+  using ::scalblnl;\n+\n+  using ::scalbn;\n+  using ::scalbnf;\n+  using ::scalbnl;\n+\n+  using ::tgamma;\n+  using ::tgammaf;\n+  using ::tgammal;\n+\n+  using ::trunc;\n+  using ::truncf;\n+  using ::truncl;\n+\n+#endif\n+\n+#if _GLIBCXX_USE_C99_MATH\n+#if !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC\n+\n+  /// Function template definitions [8.16.3].\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    fpclassify(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n+\t\t\t\t  FP_SUBNORMAL, FP_ZERO, __type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isfinite(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isfinite(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isinf(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isinf(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isnan(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isnan(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isnormal(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isnormal(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    signbit(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_signbit(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isgreater(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isgreater(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isgreaterequal(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isgreaterequal(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isless(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isless(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    islessequal(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_islessequal(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    islessgreater(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_islessgreater(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isunordered(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isunordered(__type(__f1), __type(__f2));\n+    }\n+\n+#endif\n #endif\n \n+#if _GLIBCXX_USE_C99_MATH_TR1\n+\n+  /// Additional overloads [8.16.4].\n+  using std::acos;\n+\n+  inline float\n+  acosh(float __x)\n+  { return __builtin_acoshf(__x); }\n+\n+  inline long double\n+  acosh(long double __x)\n+  { return __builtin_acoshl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    acosh(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return acosh(__type(__x));\n+    }\n+\n+  using std::asin;\n+\n+  inline float\n+  asinh(float __x)\n+  { return __builtin_asinhf(__x); }\n+\n+  inline long double\n+  asinh(long double __x)\n+  { return __builtin_asinhl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    asinh(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return asinh(__type(__x));\n+    }\n+\n+  using std::atan;\n+  using std::atan2;\n+\n+  inline float\n+  atanh(float __x)\n+  { return __builtin_atanhf(__x); }\n+\n+  inline long double\n+  atanh(long double __x)\n+  { return __builtin_atanhl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    atanh(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return atanh(__type(__x));\n+    }\n+\n+  inline float\n+  cbrt(float __x)\n+  { return __builtin_cbrtf(__x); }\n+\n+  inline long double\n+  cbrt(long double __x)\n+  { return __builtin_cbrtl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    cbrt(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return cbrt(__type(__x));\n+    }\n+\n+  using std::ceil;\n+\n+  inline float\n+  copysign(float __x, float __y)\n+  { return __builtin_copysignf(__x, __y); }\n+\n+  inline long double\n+  copysign(long double __x, long double __y)\n+  { return __builtin_copysignl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    copysign(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return copysign(__type(__x), __type(__y));\n+    }\n+\n+  using std::cos;\n+  using std::cosh;  \n+\n+  inline float\n+  erf(float __x)\n+  { return __builtin_erff(__x); }\n+\n+  inline long double\n+  erf(long double __x)\n+  { return __builtin_erfl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    erf(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return erf(__type(__x));\n+    }\n+\n+  inline float\n+  erfc(float __x)\n+  { return __builtin_erfcf(__x); }\n+\n+  inline long double\n+  erfc(long double __x)\n+  { return __builtin_erfcl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    erfc(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return erfc(__type(__x));\n+    }\n+\n+  using std::exp;\n+\n+  inline float\n+  exp2(float __x)\n+  { return __builtin_exp2f(__x); }\n+\n+  inline long double\n+  exp2(long double __x)\n+  { return __builtin_exp2l(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    exp2(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return exp2(__type(__x));\n+    }\n+\n+  inline float\n+  expm1(float __x)\n+  { return __builtin_expm1f(__x); }\n+\n+  inline long double\n+  expm1(long double __x)\n+  { return __builtin_expm1l(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    expm1(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return expm1(__type(__x));\n+    }\n+\n+  using std::fabs;\n+\n+  inline float\n+  fdim(float __x, float __y)\n+  { return __builtin_fdimf(__x, __y); }\n+\n+  inline long double\n+  fdim(long double __x, long double __y)\n+  { return __builtin_fdiml(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    fdim(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return fdim(__type(__x), __type(__y));\n+    }\n+\n+  using std::floor;\n+\n+  inline float\n+  fma(float __x, float __y, float __z)\n+  { return __builtin_fmaf(__x, __y, __z); }\n+\n+  inline long double\n+  fma(long double __x, long double __y, long double __z)\n+  { return __builtin_fmal(__x, __y, __z); }\n+\n+  template<typename _Tp, typename _Up, typename _Vp>\n+    inline typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type\n+    fma(_Tp __x, _Up __y, _Vp __z)\n+    {\n+      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;\n+      return fma(__type(__x), __type(__y), __type(__z));\n+    }\n+\n+  inline float\n+  fmax(float __x, float __y)\n+  { return __builtin_fmaxf(__x, __y); }\n+\n+  inline long double\n+  fmax(long double __x, long double __y)\n+  { return __builtin_fmaxl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    fmax(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return fmax(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  fmin(float __x, float __y)\n+  { return __builtin_fminf(__x, __y); }\n+\n+  inline long double\n+  fmin(long double __x, long double __y)\n+  { return __builtin_fminl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    fmin(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return fmin(__type(__x), __type(__y));\n+    }\n+\n+  using std::fmod;\n+  using std::frexp;\n+\n+  inline float\n+  hypot(float __x, float __y)\n+  { return __builtin_hypotf(__x, __y); }\n+\n+  inline long double\n+  hypot(long double __x, long double __y)\n+  { return __builtin_hypotl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    hypot(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return hypot(__type(__x), __type(__y));\n+    }\n+\n+  inline int\n+  ilogb(float __x)\n+  { return __builtin_ilogbf(__x); }\n+\n+  inline int\n+  ilogb(long double __x)\n+  { return __builtin_ilogbl(__x); }\n+\n+  template<typename _Tp>\n+    inline int\n+    ilogb(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return ilogb(__type(__x));\n+    }\n+\n+  using std::ldexp;\n+\n+  inline float\n+  lgamma(float __x)\n+  { return __builtin_lgammaf(__x); }\n+\n+  inline long double\n+  lgamma(long double __x)\n+  { return __builtin_lgammal(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    lgamma(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return lgamma(__type(__x));\n+    }\n+\n+  inline long long\n+  llrint(float __x)\n+  { return __builtin_llrintf(__x); }\n+\n+  inline long long\n+  llrint(long double __x)\n+  { return __builtin_llrintl(__x); }\n+\n+  template<typename _Tp>\n+    inline long long\n+    llrint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return llrint(__type(__x));\n+    }\n+\n+  inline long long\n+  llround(float __x)\n+  { return __builtin_llroundf(__x); }\n+\n+  inline long long\n+  llround(long double __x)\n+  { return __builtin_llroundl(__x); }\n+\n+  template<typename _Tp>\n+    inline long long\n+    llround(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return llround(__type(__x));\n+    }\n+\n+  using std::log;\n+  using std::log10;\n+\n+  inline float\n+  log1p(float __x)\n+  { return __builtin_log1pf(__x); }\n+\n+  inline long double\n+  log1p(long double __x)\n+  { return __builtin_log1pl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    log1p(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return log1p(__type(__x));\n+    }\n+\n+  // DR 568.\n+  inline float\n+  log2(float __x)\n+  { return __builtin_log2f(__x); }\n+\n+  inline long double\n+  log2(long double __x)\n+  { return __builtin_log2l(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    log2(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return log2(__type(__x));\n+    }\n+\n+  inline float\n+  logb(float __x)\n+  { return __builtin_logbf(__x); }\n+\n+  inline long double\n+  logb(long double __x)\n+  { return __builtin_logbl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    logb(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return logb(__type(__x));\n+    }\n+\n+  inline long\n+  lrint(float __x)\n+  { return __builtin_lrintf(__x); }\n+\n+  inline long\n+  lrint(long double __x)\n+  { return __builtin_lrintl(__x); }\n+\n+  template<typename _Tp>\n+    inline long\n+    lrint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return lrint(__type(__x));\n+    }\n+\n+  inline long\n+  lround(float __x)\n+  { return __builtin_lroundf(__x); }\n+\n+  inline long\n+  lround(long double __x)\n+  { return __builtin_lroundl(__x); }\n+\n+  template<typename _Tp>\n+    inline long\n+    lround(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return lround(__type(__x));\n+    }\n+\n+  inline float\n+  nearbyint(float __x)\n+  { return __builtin_nearbyintf(__x); }\n+\n+  inline long double\n+  nearbyint(long double __x)\n+  { return __builtin_nearbyintl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    nearbyint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return nearbyint(__type(__x));\n+    }\n+\n+  inline float\n+  nextafter(float __x, float __y)\n+  { return __builtin_nextafterf(__x, __y); }\n+\n+  inline long double\n+  nextafter(long double __x, long double __y)\n+  { return __builtin_nextafterl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    nextafter(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return nextafter(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  nexttoward(float __x, long double __y)\n+  { return __builtin_nexttowardf(__x, __y); }\n+\n+  inline long double\n+  nexttoward(long double __x, long double __y)\n+  { return __builtin_nexttowardl(__x, __y); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    nexttoward(_Tp __x, long double __y)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return nexttoward(__type(__x), __y);\n+    }\n+\n+  // DR 550. What should the return type of pow(float,int) be?\n+  // NB: C++0x and TR1 != C++03.\n+  //   using std::pow;\n+\n+  inline float\n+  remainder(float __x, float __y)\n+  { return __builtin_remainderf(__x, __y); }\n+\n+  inline long double\n+  remainder(long double __x, long double __y)\n+  { return __builtin_remainderl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    remainder(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return remainder(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  remquo(float __x, float __y, int* __pquo)\n+  { return __builtin_remquof(__x, __y, __pquo); }\n+\n+  inline long double\n+  remquo(long double __x, long double __y, int* __pquo)\n+  { return __builtin_remquol(__x, __y, __pquo); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    remquo(_Tp __x, _Up __y, int* __pquo)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return remquo(__type(__x), __type(__y), __pquo);\n+    }\n+\n+  inline float\n+  rint(float __x)\n+  { return __builtin_rintf(__x); }\n+\n+  inline long double\n+  rint(long double __x)\n+  { return __builtin_rintl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    rint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return rint(__type(__x));\n+    }\n+\n+  inline float\n+  round(float __x)\n+  { return __builtin_roundf(__x); }\n+\n+  inline long double\n+  round(long double __x)\n+  { return __builtin_roundl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    round(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return round(__type(__x));\n+    }\n+\n+  inline float\n+  scalbln(float __x, long __ex)\n+  { return __builtin_scalblnf(__x, __ex); }\n+\n+  inline long double\n+  scalbln(long double __x, long __ex)\n+  { return __builtin_scalblnl(__x, __ex); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    scalbln(_Tp __x, long __ex)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return scalbln(__type(__x), __ex);\n+    }\n+ \n+  inline float\n+  scalbn(float __x, int __ex)\n+  { return __builtin_scalbnf(__x, __ex); }\n+\n+  inline long double\n+  scalbn(long double __x, int __ex)\n+  { return __builtin_scalbnl(__x, __ex); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    scalbn(_Tp __x, int __ex)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return scalbn(__type(__x), __ex);\n+    }\n+\n+  using std::sin;\n+  using std::sinh;\n+  using std::sqrt;\n+  using std::tan;\n+  using std::tanh;\n+\n+  inline float\n+  tgamma(float __x)\n+  { return __builtin_tgammaf(__x); }\n+\n+  inline long double\n+  tgamma(long double __x)\n+  { return __builtin_tgammal(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    tgamma(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return tgamma(__type(__x));\n+    }\n+ \n+  inline float\n+  trunc(float __x)\n+  { return __builtin_truncf(__x); }\n+\n+  inline long double\n+  trunc(long double __x)\n+  { return __builtin_truncl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    trunc(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return trunc(__type(__x));\n+    }\n+\n+#endif\n+}\n+}\n+\n namespace std\n {\n namespace tr1"}, {"sha": "8cec0b11d8e06a46bf065f4102504a65c486b7a4", "filename": "libstdc++-v3/include/tr1/complex", "status": "modified", "additions": 324, "deletions": 18, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -31,30 +31,334 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <complex>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/complex>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/complex>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n-\n namespace std\n {\n namespace tr1\n {\n+  /**\n+   * @addtogroup complex_numbers\n+   * @{\n+   */\n+\n+  // Forward declarations.\n+  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);\n+\n+  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> fabs(const std::complex<_Tp>&);\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    __complex_acos(const std::complex<_Tp>& __z)\n+    {\n+      const std::complex<_Tp> __t = std::tr1::asin(__z);\n+      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;\n+      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_acos(__complex__ float __z)\n+  { return __builtin_cacosf(__z); }\n+\n+  inline __complex__ double\n+  __complex_acos(__complex__ double __z)\n+  { return __builtin_cacos(__z); }\n+\n+  inline __complex__ long double\n+  __complex_acos(const __complex__ long double& __z)\n+  { return __builtin_cacosl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acos(const std::complex<_Tp>& __z)\n+    { return __complex_acos(__z.__rep()); }\n+#else\n+  /// acos(__z) [8.1.2].\n+  //  Effects:  Behaves the same as C99 function cacos, defined\n+  //            in subclause 7.3.5.1.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acos(const std::complex<_Tp>& __z)\n+    { return __complex_acos(__z); }\n+#endif\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    __complex_asin(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t(-__z.imag(), __z.real());\n+      __t = std::tr1::asinh(__t);\n+      return std::complex<_Tp>(__t.imag(), -__t.real());\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_asin(__complex__ float __z)\n+  { return __builtin_casinf(__z); }\n+\n+  inline __complex__ double\n+  __complex_asin(__complex__ double __z)\n+  { return __builtin_casin(__z); }\n+\n+  inline __complex__ long double\n+  __complex_asin(const __complex__ long double& __z)\n+  { return __builtin_casinl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asin(const std::complex<_Tp>& __z)\n+    { return __complex_asin(__z.__rep()); }\n+#else\n+  /// asin(__z) [8.1.3].\n+  //  Effects:  Behaves the same as C99 function casin, defined\n+  //            in subclause 7.3.5.2.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asin(const std::complex<_Tp>& __z)\n+    { return __complex_asin(__z); }\n+#endif\n+  \n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_atan(const std::complex<_Tp>& __z)\n+    {\n+      const _Tp __r2 = __z.real() * __z.real();\n+      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();\n+\n+      _Tp __num = __z.imag() + _Tp(1.0);\n+      _Tp __den = __z.imag() - _Tp(1.0);\n+\n+      __num = __r2 + __num * __num;\n+      __den = __r2 + __den * __den;\n+\n+      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),\n+\t\t\t       _Tp(0.25) * log(__num / __den));\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_atan(__complex__ float __z)\n+  { return __builtin_catanf(__z); }\n+\n+  inline __complex__ double\n+  __complex_atan(__complex__ double __z)\n+  { return __builtin_catan(__z); }\n+\n+  inline __complex__ long double\n+  __complex_atan(const __complex__ long double& __z)\n+  { return __builtin_catanl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atan(const std::complex<_Tp>& __z)\n+    { return __complex_atan(__z.__rep()); }\n+#else\n+  /// atan(__z) [8.1.4].\n+  //  Effects:  Behaves the same as C99 function catan, defined\n+  //            in subclause 7.3.5.3.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atan(const std::complex<_Tp>& __z)\n+    { return __complex_atan(__z); }\n+#endif\n+\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_acosh(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t((__z.real() - __z.imag())\n+\t\t\t    * (__z.real() + __z.imag()) - _Tp(1.0),\n+\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n+      __t = std::sqrt(__t);\n+\n+      return std::log(__t + __z);\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_acosh(__complex__ float __z)\n+  { return __builtin_cacoshf(__z); }\n+\n+  inline __complex__ double\n+  __complex_acosh(__complex__ double __z)\n+  { return __builtin_cacosh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_acosh(const __complex__ long double& __z)\n+  { return __builtin_cacoshl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acosh(const std::complex<_Tp>& __z)\n+    { return __complex_acosh(__z.__rep()); }\n+#else\n+  /// acosh(__z) [8.1.5].\n+  //  Effects:  Behaves the same as C99 function cacosh, defined\n+  //            in subclause 7.3.6.1.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acosh(const std::complex<_Tp>& __z)\n+    { return __complex_acosh(__z); }\n+#endif\n+\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_asinh(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t((__z.real() - __z.imag())\n+\t\t\t    * (__z.real() + __z.imag()) + _Tp(1.0),\n+\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n+      __t = std::sqrt(__t);\n+\n+      return std::log(__t + __z);\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_asinh(__complex__ float __z)\n+  { return __builtin_casinhf(__z); }\n+\n+  inline __complex__ double\n+  __complex_asinh(__complex__ double __z)\n+  { return __builtin_casinh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_asinh(const __complex__ long double& __z)\n+  { return __builtin_casinhl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asinh(const std::complex<_Tp>& __z)\n+    { return __complex_asinh(__z.__rep()); }\n+#else\n+  /// asinh(__z) [8.1.6].\n+  //  Effects:  Behaves the same as C99 function casin, defined\n+  //            in subclause 7.3.6.2.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asinh(const std::complex<_Tp>& __z)\n+    { return __complex_asinh(__z); }\n+#endif\n+\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_atanh(const std::complex<_Tp>& __z)\n+    {\n+      const _Tp __i2 = __z.imag() * __z.imag();\n+      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();\n+\n+      _Tp __num = _Tp(1.0) + __z.real();\n+      _Tp __den = _Tp(1.0) - __z.real();\n+\n+      __num = __i2 + __num * __num;\n+      __den = __i2 + __den * __den;\n+\n+      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),\n+\t\t\t       _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_atanh(__complex__ float __z)\n+  { return __builtin_catanhf(__z); }\n+\n+  inline __complex__ double\n+  __complex_atanh(__complex__ double __z)\n+  { return __builtin_catanh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_atanh(const __complex__ long double& __z)\n+  { return __builtin_catanhl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atanh(const std::complex<_Tp>& __z)\n+    { return __complex_atanh(__z.__rep()); }\n+#else\n+  /// atanh(__z) [8.1.7].\n+  //  Effects:  Behaves the same as C99 function catanh, defined\n+  //            in subclause 7.3.6.3.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atanh(const std::complex<_Tp>& __z)\n+    { return __complex_atanh(__z); }\n+#endif\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    /// fabs(__z) [8.1.8].\n+    //  Effects:  Behaves the same as C99 function cabs, defined\n+    //            in subclause 7.3.8.1.\n+    fabs(const std::complex<_Tp>& __z)\n+    { return std::abs(__z); }\n+\n+  /// Additional overloads [8.1.9].\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    arg(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+#if (_GLIBCXX_USE_C99_MATH && !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC)\n+      return std::signbit(__x) ? __type(3.1415926535897932384626433832795029L)\n+\t                       : __type();\n+#else\n+      return std::arg(std::complex<__type>(__x));\n+#endif\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    imag(_Tp)\n+    { return _Tp(); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    norm(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __type(__x) * __type(__x);\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    real(_Tp __x)\n+    { return __x; }\n+\n+#endif\n+\n+  template<typename _Tp, typename _Up>\n+    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n+    pow(const std::complex<_Tp>& __x, const _Up& __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return std::pow(std::complex<__type>(__x), __type(__y));\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n+    pow(const _Tp& __x, const std::complex<_Up>& __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return std::pow(__type(__x), std::complex<__type>(__y));\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n+    pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return std::pow(std::complex<__type>(__x),\n+\t\t      std::complex<__type>(__y));\n+    }\n+\n   using std::arg;\n \n   template<typename _Tp>\n@@ -95,6 +399,8 @@ namespace tr1\n     inline std::complex<_Tp>\n     pow(const std::complex<_Tp>& __x, const std::complex<_Tp>& __y)\n     { return std::pow(__x, __y); }\n+\n+// @} group complex_numbers\n }\n }\n "}, {"sha": "c143bd279f44b3ddf27a6688ab4042e1e08e13a5", "filename": "libstdc++-v3/include/tr1/cstdint", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdint", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdint", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdint?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -31,10 +31,6 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <bits/c++config.h>\n \n // For 8.22.1/1 (see C99, Notes 219, 220, 222)\n@@ -58,19 +54,51 @@\n #  endif\n # endif\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/cstdint>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/cstdint>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n+#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+  using ::int8_t;\n+  using ::int16_t;\n+  using ::int32_t;\n+  using ::int64_t;\n+\n+  using ::int_fast8_t;\n+  using ::int_fast16_t;\n+  using ::int_fast32_t;\n+  using ::int_fast64_t;\n+\n+  using ::int_least8_t;\n+  using ::int_least16_t;\n+  using ::int_least32_t;\n+  using ::int_least64_t;\n+\n+  using ::intmax_t;\n+  using ::intptr_t;\n+  \n+  using ::uint8_t;\n+  using ::uint16_t;\n+  using ::uint32_t;\n+  using ::uint64_t;\n+\n+  using ::uint_fast8_t;\n+  using ::uint_fast16_t;\n+  using ::uint_fast32_t;\n+  using ::uint_fast64_t;\n+\n+  using ::uint_least8_t;\n+  using ::uint_least16_t;\n+  using ::uint_least32_t;\n+  using ::uint_least64_t;\n+\n+  using ::uintmax_t;\n+  using ::uintptr_t;\n+}\n+}\n+\n+#endif // _GLIBCXX_USE_C99_STDINT_TR1\n \n #endif // _GLIBCXX_TR1_CSTDINT\n "}, {"sha": "bd52aa2292de99b72866ac9e26cf28d9608982f3", "filename": "libstdc++-v3/include/tr1/cstdio", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdio?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -31,24 +31,23 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <cstdio>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/cstdio>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/cstdio>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n+#if _GLIBCXX_USE_C99\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+  using std::snprintf;\n+  using std::vsnprintf;\n+\n+  using std::vfscanf;\n+  using std::vscanf;\n+  using std::vsscanf;\n+}\n+}\n+\n #endif\n \n #endif // _GLIBCXX_TR1_CSTDIO"}, {"sha": "a4b8eb1c0d68d4ba3652cc0c12aea4fe9c79f9da", "filename": "libstdc++-v3/include/tr1/cstdlib", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdlib?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -1,6 +1,6 @@\n // TR1 cstdlib -*- C++ -*-\n \n-// Copyright (C) 2006, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,24 +31,42 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n+#include <cstdlib>\n+\n+#if _GLIBCXX_HOSTED\n+\n+#if _GLIBCXX_USE_C99\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC\n+  // types\n+  using std::lldiv_t;\n+\n+  // functions\n+  using std::llabs;\n+  using std::lldiv;\n #endif\n \n-#include <cstdlib>\n+  using std::atoll;\n+  using std::strtoll;\n+  using std::strtoull;\n+\n+  using std::strtof;\n+  using std::strtold;\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/cstdlib>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/cstdlib>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n+  // overloads\n+  using std::abs;\n+#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC\n+  using std::div;\n #endif\n+}\n+}\n+\n+#endif // _GLIBCXX_USE_C99 \n+\n+#endif // _GLIBCXX_HOSTED\n \n #endif // _GLIBCXX_TR1_CSTDLIB"}, {"sha": "c14111b0cf67ba09b1dfe97cc3f67218374864c8", "filename": "libstdc++-v3/include/tr1/cwchar", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwchar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwchar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwchar?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -1,6 +1,6 @@\n // TR1 cwchar -*- C++ -*-\n \n-// Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,24 +31,35 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <cwchar>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/cwchar>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/cwchar>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+#if _GLIBCXX_HAVE_WCSTOF\n+  using std::wcstof;\n+#endif\n+#if _GLIBCXX_HAVE_VFWSCANF\n+  using std::vfwscanf;\n+#endif\n+#if _GLIBCXX_HAVE_VSWSCANF\n+  using std::vswscanf;\n #endif\n+#if _GLIBCXX_HAVE_VWSCANF\n+  using std::vwscanf;\n+#endif\n+\n+#if _GLIBCXX_USE_C99\n+  using std::wcstold;\n+  using std::wcstoll;\n+  using std::wcstoull;\n+#endif\n+}\n+}\n+\n+#endif // _GLIBCXX_USE_WCHAR_T\n \n #endif // _GLIBCXX_TR1_CWCHAR"}, {"sha": "71da0bede003136ed8f3ac495fc156fb790be7c0", "filename": "libstdc++-v3/include/tr1/cwctype", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwctype?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -31,24 +31,20 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <cwctype>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/cwctype>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/cwctype>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+#if _GLIBCXX_HAVE_ISWBLANK\n+  using std::iswblank;\n+#endif  \n+}\n+}\n+\n+#endif // _GLIBCXX_USE_WCHAR_T\n \n #endif // _GLIBCXX_TR1_CWCTYPE"}, {"sha": "eaf4932e5b5d764356689985c4a2d5a77c4d37ab", "filename": "libstdc++-v3/include/tr1/memory", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -1,6 +1,7 @@\n // <tr1/memory> -*- C++ -*-\n \n-// Copyright (C) 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -47,21 +48,6 @@\n #include <bits/stl_function.h> \t// std::less\n #include <debug/debug.h>\n #include <tr1/type_traits>\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/boost_sp_counted_base.h>\n-#  include <tr1/shared_ptr.h>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/boost_sp_counted_base.h>\n-#  include <tr1/shared_ptr.h>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n+#include <tr1/shared_ptr.h>\n \n #endif // _GLIBCXX_TR1_MEMORY"}, {"sha": "d69844c2cd9737d19415d1a5e7360030fe281cc8", "filename": "libstdc++-v3/include/tr1/regex", "status": "modified", "additions": 2676, "deletions": 16, "changes": 2692, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fregex?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -33,10 +33,6 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <algorithm>\n #include <bitset>\n #include <iterator>\n@@ -47,18 +43,2682 @@\n #include <utility>\n #include <sstream>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/regex>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/regex>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n+namespace std\n+{\n+namespace tr1\n+{\n+/**\n+ * @defgroup tr1_regex Regular Expressions\n+ * A facility for performing regular expression pattern matching.\n+ */\n+ //@{\n+\n+/** @namespace std::regex_constants\n+ *  @brief ISO C++ 0x entities sub namespace for regex.\n+ */\n+namespace regex_constants\n+{\n+  /**\n+   * @name 5.1 Regular Expression Syntax Options\n+   */\n+  //@{\n+  enum __syntax_option\n+    {\n+      _S_icase,\n+      _S_nosubs,\n+      _S_optimize,\n+      _S_collate,\n+      _S_ECMAScript,\n+      _S_basic,\n+      _S_extended,\n+      _S_awk,\n+      _S_grep,\n+      _S_egrep,\n+      _S_syntax_last\n+    };\n+\n+  /**\n+   * @brief This is a bitmask type indicating how to interpret the regex.\n+   *\n+   * The @c syntax_option_type is implementation defined but it is valid to\n+   * perform bitwise operations on these values and expect the right thing to\n+   * happen.\n+   *\n+   * A valid value of type syntax_option_type shall have exactly one of the\n+   * elements @c ECMAScript, @c basic, @c extended, @c awk, @c grep, @c egrep\n+   * %set.\n+   */\n+  typedef unsigned int syntax_option_type;\n+\n+  /** \n+   * Specifies that the matching of regular expressions against a character\n+   * sequence shall be performed without regard to case.\n+   */\n+  static const syntax_option_type icase      = 1 << _S_icase;\n+\n+  /**\n+   * Specifies that when a regular expression is matched against a character\n+   * container sequence, no sub-expression matches are to be stored in the\n+   * supplied match_results structure.\n+   */\n+  static const syntax_option_type nosubs     = 1 << _S_nosubs;\n+\n+  /**\n+   * Specifies that the regular expression engine should pay more attention to\n+   * the speed with which regular expressions are matched, and less to the\n+   * speed with which regular expression objects are constructed. Otherwise\n+   * it has no detectable effect on the program output.\n+   */\n+  static const syntax_option_type optimize   = 1 << _S_optimize;\n+\n+  /**\n+   * Specifies that character ranges of the form [a-b] should be locale\n+   * sensitive.\n+   */\n+  static const syntax_option_type collate    = 1 << _S_collate;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by ECMAScript in ECMA-262 [Ecma International, ECMAScript\n+   * Language Specification, Standard Ecma-262, third edition, 1999], as\n+   * modified in tr1 section [7.13].  This grammar is similar to that defined\n+   * in the PERL scripting language but extended with elements found in the\n+   * POSIX regular expression grammar.\n+   */\n+  static const syntax_option_type ECMAScript = 1 << _S_ECMAScript;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by POSIX basic regular expressions in IEEE Std 1003.1-2001,\n+   * Portable Operating System Interface (POSIX), Base Definitions and\n+   * Headers, Section 9, Regular Expressions [IEEE, Information Technology --\n+   * Portable Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n+   */\n+  static const syntax_option_type basic      = 1 << _S_basic;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by POSIX extended regular expressions in IEEE Std 1003.1-2001,\n+   * Portable Operating System Interface (POSIX), Base Definitions and Headers,\n+   * Section 9, Regular Expressions.\n+   */\n+  static const syntax_option_type extended   = 1 << _S_extended;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by POSIX utility awk in IEEE Std 1003.1-2001.  This option is\n+   * identical to syntax_option_type extended, except that C-style escape\n+   * sequences are supported.  These sequences are: \n+   * \\\\\\\\, \\\\a, \\\\b, \\\\f, \n+   * \\\\n, \\\\r, \\\\t , \\\\v, \n+   * \\\\&apos;, &apos;, and \\\\ddd \n+   * (where ddd is one, two, or three octal digits).  \n+   */\n+  static const syntax_option_type awk        = 1 << _S_awk;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by POSIX utility grep in IEEE Std 1003.1-2001.  This option is\n+   * identical to syntax_option_type basic, except that newlines are treated\n+   * as whitespace.\n+   */\n+  static const syntax_option_type grep       = 1 << _S_grep;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by POSIX utility grep when given the -E option in\n+   * IEEE Std 1003.1-2001.  This option is identical to syntax_option_type \n+   * extended, except that newlines are treated as whitespace.\n+   */\n+  static const syntax_option_type egrep      = 1 << _S_egrep;\n+\n+  //@}\n+\n+  /**\n+   * @name 5.2 Matching Rules\n+   *\n+   * Matching a regular expression against a sequence of characters [first,\n+   * last) proceeds according to the rules of the grammar specified for the\n+   * regular expression object, modified according to the effects listed\n+   * below for any bitmask elements set.\n+   *\n+   */\n+  //@{\n+\n+  enum __match_flag\n+    {\n+      _S_not_bol,\n+      _S_not_eol,\n+      _S_not_bow,\n+      _S_not_eow,\n+      _S_any,\n+      _S_not_null,\n+      _S_continuous,\n+      _S_prev_avail,\n+      _S_sed,\n+      _S_no_copy,\n+      _S_first_only,\n+      _S_match_flag_last\n+    };\n+\n+  /**\n+   * @brief This is a bitmask type indicating regex matching rules.\n+   *\n+   * The @c match_flag_type is implementation defined but it is valid to\n+   * perform bitwise operations on these values and expect the right thing to\n+   * happen.\n+   */\n+  typedef std::bitset<_S_match_flag_last> match_flag_type;\n+\n+  /**\n+   * The default matching rules.\n+   */\n+  static const match_flag_type match_default     = 0;\n+\n+  /**\n+   * The first character in the sequence [first, last) is treated as though it\n+   * is not at the beginning of a line, so the character (^) in the regular\n+   * expression shall not match [first, first).\n+   */\n+  static const match_flag_type match_not_bol     = 1 << _S_not_bol;\n+\n+  /**\n+   * The last character in the sequence [first, last) is treated as though it\n+   * is not at the end of a line, so the character ($) in the regular\n+   * expression shall not match [last, last).\n+   */\n+  static const match_flag_type match_not_eol     = 1 << _S_not_eol;\n+   \n+  /**\n+   * The expression \\\\b is not matched against the sub-sequence\n+   * [first,first).\n+   */\n+  static const match_flag_type match_not_bow     = 1 << _S_not_bow;\n+   \n+  /**\n+   * The expression \\\\b should not be matched against the sub-sequence\n+   * [last,last).\n+   */\n+  static const match_flag_type match_not_eow     = 1 << _S_not_eow;\n+   \n+  /**\n+   * If more than one match is possible then any match is an acceptable\n+   * result.\n+   */\n+  static const match_flag_type match_any         = 1 << _S_any;\n+   \n+  /**\n+   * The expression does not match an empty sequence.\n+   */\n+  static const match_flag_type match_not_null    = 1 << _S_not_null;\n+   \n+  /**\n+   * The expression only matches a sub-sequence that begins at first .\n+   */\n+  static const match_flag_type match_continuous  = 1 << _S_continuous;\n+   \n+  /**\n+   * --first is a valid iterator position.  When this flag is set then the\n+   * flags match_not_bol and match_not_bow are ignored by the regular\n+   * expression algorithms 7.11 and iterators 7.12.\n+   */\n+  static const match_flag_type match_prev_avail  = 1 << _S_prev_avail;\n+\n+  /**\n+   * When a regular expression match is to be replaced by a new string, the\n+   * new string is constructed using the rules used by the ECMAScript replace\n+   * function in ECMA- 262 [Ecma International, ECMAScript Language\n+   * Specification, Standard Ecma-262, third edition, 1999], part 15.5.4.11\n+   * String.prototype.replace. In addition, during search and replace\n+   * operations all non-overlapping occurrences of the regular expression\n+   * are located and replaced, and sections of the input that did not match\n+   * the expression are copied unchanged to the output string.\n+   * \n+   * Format strings (from ECMA-262 [15.5.4.11]):\n+   * @li $$  The dollar-sign itself ($)\n+   * @li $&  The matched substring.\n+   * @li $`  The portion of @a string that precedes the matched substring.\n+   *         This would be match_results::prefix().\n+   * @li $'  The portion of @a string that follows the matched substring.\n+   *         This would be match_results::suffix().\n+   * @li $n  The nth capture, where n is in [1,9] and $n is not followed by a\n+   *         decimal digit.  If n <= match_results::size() and the nth capture\n+   *         is undefined, use the empty string instead.  If n >\n+   *         match_results::size(), the result is implementation-defined.\n+   * @li $nn The nnth capture, where nn is a two-digit decimal number on\n+   *         [01, 99].  If nn <= match_results::size() and the nth capture is\n+   *         undefined, use the empty string instead. If\n+   *         nn > match_results::size(), the result is implementation-defined.\n+   */\n+  static const match_flag_type format_default    = 0;\n+\n+  /**\n+   * When a regular expression match is to be replaced by a new string, the\n+   * new string is constructed using the rules used by the POSIX sed utility\n+   * in IEEE Std 1003.1- 2001 [IEEE, Information Technology -- Portable\n+   * Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n+   */\n+  static const match_flag_type format_sed        = 1 << _S_sed;\n+\n+  /**\n+   * During a search and replace operation, sections of the character\n+   * container sequence being searched that do not match the regular\n+   * expression shall not be copied to the output string.\n+   */\n+  static const match_flag_type format_no_copy    = 1 << _S_no_copy;\n+\n+  /**\n+   * When specified during a search and replace operation, only the first\n+   * occurrence of the regular expression shall be replaced.\n+   */\n+  static const match_flag_type format_first_only = 1 << _S_first_only;\n+\n+  //@}\n+\n+  /**\n+   * @name 5.3 Error Types\n+   */\n+  //@{\n+ \n+  enum error_type\n+    {\n+      _S_error_collate,\n+      _S_error_ctype,\n+      _S_error_escape,\n+      _S_error_backref,\n+      _S_error_brack,\n+      _S_error_paren,\n+      _S_error_brace,\n+      _S_error_badbrace,\n+      _S_error_range,\n+      _S_error_space,\n+      _S_error_badrepeat,\n+      _S_error_complexity,\n+      _S_error_stack,\n+      _S_error_last\n+    };\n+\n+  /** The expression contained an invalid collating element name. */\n+  static const error_type error_collate(_S_error_collate);\n+\n+  /** The expression contained an invalid character class name. */\n+  static const error_type error_ctype(_S_error_ctype);\n+\n+  /**\n+   * The expression contained an invalid escaped character, or a trailing\n+   * escape.\n+   */\n+  static const error_type error_escape(_S_error_escape);\n+\n+  /** The expression contained an invalid back reference. */\n+  static const error_type error_backref(_S_error_backref);\n+\n+  /** The expression contained mismatched [ and ]. */\n+  static const error_type error_brack(_S_error_brack);\n+\n+  /** The expression contained mismatched ( and ). */\n+  static const error_type error_paren(_S_error_paren);\n+\n+  /** The expression contained mismatched { and } */\n+  static const error_type error_brace(_S_error_brace);\n+\n+  /** The expression contained an invalid range in a {} expression. */\n+  static const error_type error_badbrace(_S_error_badbrace);\n+\n+  /**\n+   * The expression contained an invalid character range,\n+   * such as [b-a] in most encodings.\n+   */\n+  static const error_type error_range(_S_error_range);\n+\n+  /**\n+   * There was insufficient memory to convert the expression into a\n+   * finite state machine.\n+   */\n+  static const error_type error_space(_S_error_space);\n+\n+  /**\n+   * One of <em>*?+{</em> was not preceded by a valid regular expression.\n+   */\n+  static const error_type error_badrepeat(_S_error_badrepeat);\n+\n+  /**\n+   * The complexity of an attempted match against a regular expression\n+   * exceeded a pre-set level.\n+   */\n+  static const error_type error_complexity(_S_error_complexity);\n+\n+  /**\n+   * There was insufficient memory to determine whether the\n+   * regular expression could match the specified character sequence.\n+   */\n+  static const error_type error_stack(_S_error_stack);\n+\n+  //@}\n+}\n+\n+\n+  // [7.8] Class regex_error\n+  /**\n+   *  @brief A regular expression exception class.\n+   *  @ingroup exceptions\n+   *\n+   *  The regular expression library throws objects of this class on error.\n+   */\n+  class regex_error\n+  : public std::runtime_error\n+  {\n+  public:\n+    /**\n+     * @brief Constructs a regex_error object.\n+     *\n+     * @param ecode the regex error code.\n+     */\n+    explicit\n+    regex_error(regex_constants::error_type __ecode)\n+    : std::runtime_error(\"regex_error\"), _M_code(__ecode)\n+    { }\n+\n+    /**\n+     * @brief Gets the regex error code.\n+     *\n+     * @returns the regex error code.\n+     */\n+    regex_constants::error_type\n+    code() const\n+    { return _M_code; }\n+\n+  protected:\n+    regex_constants::error_type _M_code;\n+  };\n+\n+  // [7.7] Class regex_traits\n+  /**\n+   * @brief Describes aspects of a regular expression.\n+   *\n+   * A regular expression traits class that satisfies the requirements of tr1\n+   * section [7.2].\n+   *\n+   * The class %regex is parameterized around a set of related types and\n+   * functions used to complete the definition of its semantics.  This class\n+   * satisfies the requirements of such a traits class.\n+   */\n+  template<typename _Ch_type>\n+    struct regex_traits\n+    {\n+    public:\n+      typedef _Ch_type                     char_type;\n+      typedef std::basic_string<char_type> string_type;\n+      typedef std::locale                  locale_type;\n+      typedef std::ctype_base::mask        char_class_type;\n+\n+    public:\n+      /**\n+       * @brief Constructs a default traits object.\n+       */\n+      regex_traits()\n+      { }\n+      \n+      /**\n+       * @brief Gives the length of a C-style string starting at @p __p.\n+       *\n+       * @param __p a pointer to the start of a character sequence.\n+       *\n+       * @returns the number of characters between @p *__p and the first\n+       * default-initialized value of type @p char_type.  In other words, uses\n+       * the C-string algorithm for determining the length of a sequence of\n+       * characters.\n+       */\n+      static std::size_t\n+      length(const char_type* __p)\n+      { return string_type::traits_type::length(__p); }\n+\n+      /**\n+       * @brief Performs the identity translation.\n+       *\n+       * @param c A character to the locale-specific character set.\n+       *\n+       * @returns c.\n+       */\n+      char_type\n+      translate(char_type __c) const\n+      { return __c; }\n+      \n+      /**\n+       * @brief Translates a character into a case-insensitive equivalent.\n+       *\n+       * @param c A character to the locale-specific character set.\n+       *\n+       * @returns the locale-specific lower-case equivalent of c.\n+       * @throws std::bad_cast if the imbued locale does not support the ctype\n+       *         facet.\n+       */\n+      char_type\n+      translate_nocase(char_type __c) const\n+      {\n+\tusing std::ctype;\n+\tusing std::use_facet;\n+\treturn use_facet<ctype<char_type> >(_M_locale).tolower(__c);\n+      }\n+      \n+      /**\n+       * @brief Gets a sort key for a character sequence.\n+       *\n+       * @param first beginning of the character sequence.\n+       * @param last  one-past-the-end of the character sequence.\n+       *\n+       * Returns a sort key for the character sequence designated by the\n+       * iterator range [F1, F2) such that if the character sequence [G1, G2)\n+       * sorts before the character sequence [H1, H2) then\n+       * v.transform(G1, G2) < v.transform(H1, H2).\n+       *\n+       * What this really does is provide a more efficient way to compare a\n+       * string to multiple other strings in locales with fancy collation\n+       * rules and equivalence classes.\n+       *\n+       * @returns a locale-specific sort key equivalent to the input range.\n+       *\n+       * @throws std::bad_cast if the current locale does not have a collate\n+       *         facet.\n+       */\n+      template<typename _Fwd_iter>\n+        string_type\n+        transform(_Fwd_iter __first, _Fwd_iter __last) const\n+        {\n+\t  using std::collate;\n+\t  using std::use_facet;\n+\t  const collate<_Ch_type>& __c(use_facet<\n+\t\t\t\t       collate<_Ch_type> >(_M_locale));\n+\t  string_type __s(__first, __last);\n+\t  return __c.transform(__s.data(), __s.data() + __s.size());\n+\t}\n+\n+      /**\n+       * @brief Dunno.\n+       *\n+       * @param first beginning of the character sequence.\n+       * @param last  one-past-the-end of the character sequence.\n+       *\n+       * Effects: if typeid(use_facet<collate<_Ch_type> >) ==\n+       * typeid(collate_byname<_Ch_type>) and the form of the sort key\n+       * returned by collate_byname<_Ch_type>::transform(first, last) is known\n+       * and can be converted into a primary sort key then returns that key,\n+       * otherwise returns an empty string. WTF??\n+       *\n+       * @todo Implement this function.\n+       */\n+      template<typename _Fwd_iter>\n+        string_type\n+        transform_primary(_Fwd_iter __first, _Fwd_iter __last) const;\n+\n+      /**\n+       * @brief Gets a collation element by name.\n+       *\n+       * @param first beginning of the collation element name.\n+       * @param last  one-past-the-end of the collation element name.\n+       * \n+       * @returns a sequence of one or more characters that represents the\n+       * collating element consisting of the character sequence designated by\n+       * the iterator range [first, last). Returns an empty string if the\n+       * character sequence is not a valid collating element.\n+       *\n+       * @todo Implement this function.\n+       */\n+      template<typename _Fwd_iter>\n+        string_type\n+        lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const;\n+\n+      /**\n+       * @brief Maps one or more characters to a named character\n+       *        classification.\n+       *\n+       * @param first beginning of the character sequence.\n+       * @param last  one-past-the-end of the character sequence.\n+       *\n+       * @returns an unspecified value that represents the character\n+       * classification named by the character sequence designated by the\n+       * iterator range [first, last). The value returned shall be independent\n+       * of the case of the characters in the character sequence. If the name\n+       * is not recognized then returns a value that compares equal to 0.\n+       *\n+       * At least the following names (or their wide-character equivalent) are\n+       * supported.\n+       * - d\n+       * - w\n+       * - s\n+       * - alnum\n+       * - alpha\n+       * - blank\n+       * - cntrl\n+       * - digit\n+       * - graph\n+       * - lower\n+       * - print\n+       * - punct\n+       * - space\n+       * - upper\n+       * - xdigit\n+       *\n+       * @todo Implement this function.\n+       */\n+      template<typename _Fwd_iter>\n+        char_class_type\n+        lookup_classname(_Fwd_iter __first, _Fwd_iter __last) const;\n+\n+      /**\n+       * @brief Determines if @p c is a member of an identified class.\n+       *\n+       * @param c a character.\n+       * @param f a class type (as returned from lookup_classname).\n+       *\n+       * @returns true if the character @p c is a member of the classification\n+       * represented by @p f, false otherwise.\n+       *\n+       * @throws std::bad_cast if the current locale does not have a ctype\n+       *         facet.\n+       */\n+      bool\n+      isctype(_Ch_type __c, char_class_type __f) const;\n+\n+      /**\n+       * @brief Converts a digit to an int.\n+       *\n+       * @param ch    a character representing a digit.\n+       * @param radix the radix if the numeric conversion (limited to 8, 10,\n+       *              or 16).\n+       * \n+       * @returns the value represented by the digit ch in base radix if the\n+       * character ch is a valid digit in base radix; otherwise returns -1.\n+       */\n+      int\n+      value(_Ch_type __ch, int __radix) const;\n+      \n+      /**\n+       * @brief Imbues the regex_traits object with a copy of a new locale.\n+       *\n+       * @param loc A locale.\n+       *\n+       * @returns a copy of the previous locale in use by the regex_traits\n+       *          object.\n+       *\n+       * @note Calling imbue with a different locale than the one currently in\n+       *       use invalidates all cached data held by *this.\n+       */\n+      locale_type\n+      imbue(locale_type __loc)\n+      {\n+\tstd::swap(_M_locale, __loc);\n+\treturn __loc;\n+      }\n+      \n+      /**\n+       * @brief Gets a copy of the current locale in use by the regex_traits\n+       * object.\n+       */\n+      locale_type\n+      getloc() const\n+      { return _M_locale; }\n+      \n+    protected:\n+      locale_type _M_locale;\n+    };\n+\n+  template<typename _Ch_type>\n+    bool regex_traits<_Ch_type>::\n+    isctype(_Ch_type __c, char_class_type __f) const\n+    {\n+      using std::ctype;\n+      using std::use_facet;\n+      const ctype<_Ch_type>& __ctype(use_facet<\n+\t\t\t\t     ctype<_Ch_type> >(_M_locale));\n+      \n+      if (__ctype.is(__c, __f))\n+\treturn true;\n+      \n+      // special case of underscore in [[:w:]]\n+      if (__c == __ctype.widen('_'))\n+\t{\n+\t  const char* const __wb[] = \"w\";\n+\t  char_class_type __wt = this->lookup_classname(__wb,\n+\t\t\t\t\t\t\t__wb + sizeof(__wb));\n+\t  if (__f | __wt)\n+\t    return true;\n+\t}\n+    \n+      // special case of [[:space:]] in [[:blank:]]\n+      if (__c == __ctype.isspace(__c))\n+\t{\n+\t  const char* const __bb[] = \"blank\";\n+\t  char_class_type __bt = this->lookup_classname(__bb,\n+\t\t\t\t\t\t\t__bb + sizeof(__bb));\n+\t  if (__f | __bt)\n+\t    return true;\n+\t}\n+      \n+      return false;\n+    }\n+\n+  template<typename _Ch_type>\n+    int regex_traits<_Ch_type>::\n+    value(_Ch_type __ch, int __radix) const\n+    {\n+      std::basic_istringstream<_Ch_type> __is(string_type(1, __ch));\n+      int __v;\n+      if (__radix == 8)\n+\t__is >> std::oct;\n+      else if (__radix == 16)\n+\t__is >> std::hex;\n+      __is >> __v;\n+      return __is.fail() ? -1 : __v;\n+    }\n+\n+  // [7.8] Class basic_regex\n+  /**\n+   * Objects of specializations of this class represent regular expressions\n+   * constructed from sequences of character type @p _Ch_type.\n+   *\n+   * Storage for the regular expression is allocated and deallocated as\n+   * necessary by the member functions of this class.\n+   */\n+  template<typename _Ch_type, typename _Rx_traits = regex_traits<_Ch_type> >\n+    class basic_regex\n+    {\n+    public:\n+      // types:\n+      typedef _Ch_type                              value_type;\n+      typedef regex_constants::syntax_option_type flag_type;\n+      typedef typename _Rx_traits::locale_type  locale_type;\n+      typedef typename _Rx_traits::string_type  string_type;\n+\n+      /**\n+       * @name Constants\n+       * tr1 [7.8.1] std [28.8.1]\n+       */\n+      //@{\n+      static const regex_constants::syntax_option_type icase\n+        = regex_constants::icase;\n+      static const regex_constants::syntax_option_type nosubs\n+        = regex_constants::nosubs;\n+      static const regex_constants::syntax_option_type optimize\n+        = regex_constants::optimize;\n+      static const regex_constants::syntax_option_type collate\n+        = regex_constants::collate;\n+      static const regex_constants::syntax_option_type ECMAScript\n+        = regex_constants::ECMAScript;\n+      static const regex_constants::syntax_option_type basic\n+        = regex_constants::basic;\n+      static const regex_constants::syntax_option_type extended\n+        = regex_constants::extended;\n+      static const regex_constants::syntax_option_type awk\n+        = regex_constants::awk;\n+      static const regex_constants::syntax_option_type grep\n+        = regex_constants::grep;\n+      static const regex_constants::syntax_option_type egrep\n+        = regex_constants::egrep;\n+      //@}\n+\n+      // [7.8.2] construct/copy/destroy\n+      /**\n+       * Constructs a basic regular expression that does not match any\n+       * character sequence.\n+       */\n+      basic_regex()\n+      : _M_flags(regex_constants::ECMAScript), _M_pattern(), _M_mark_count(0)\n+      { _M_compile(); }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the sequence\n+       * [p, p + char_traits<_Ch_type>::length(p)) interpreted according to the\n+       * flags in @p f.\n+       *\n+       * @param p A pointer to the start of a C-style null-terminated string\n+       *          containing a regular expression.\n+       * @param f Flags indicating the syntax rules and options.\n+       *\n+       * @throws regex_error if @p p is not a valid regular expression.\n+       */\n+      explicit\n+      basic_regex(const _Ch_type* __p,\n+\t\t  flag_type __f = regex_constants::ECMAScript)\n+      : _M_flags(__f), _M_pattern(__p), _M_mark_count(0)\n+      { _M_compile(); }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the sequence\n+       * [p, p + len) interpreted according to the flags in @p f.\n+       *\n+       * @param p   A pointer to the start of a string containing a regular\n+       *            expression.\n+       * @param len The length of the string containing the regular expression.\n+       * @param f   Flags indicating the syntax rules and options.\n+       *\n+       * @throws regex_error if @p p is not a valid regular expression.\n+       */\n+      basic_regex(const _Ch_type* __p, std::size_t __len, flag_type __f)\n+      : _M_flags(__f) , _M_pattern(__p, __len), _M_mark_count(0)\n+      { _M_compile(); }\n+\n+      /**\n+       * @brief Copy-constructs a basic regular expression.\n+       *\n+       * @param rhs A @p regex object.\n+     */\n+      basic_regex(const basic_regex& __rhs)\n+      : _M_flags(__rhs._M_flags), _M_pattern(__rhs._M_pattern),\n+\t_M_mark_count(__rhs._M_mark_count)\n+      { _M_compile(); }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the string\n+       * @p s interpreted according to the flags in @p f.\n+       *\n+       * @param s A string containing a regular expression.\n+       * @param f Flags indicating the syntax rules and options.\n+       *\n+       * @throws regex_error if @p s is not a valid regular expression.\n+       */\n+      template<typename _Ch_traits, typename _Ch_alloc>\n+        explicit\n+        basic_regex(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n+\t\t    flag_type __f = regex_constants::ECMAScript)\n+\t: _M_flags(__f), _M_pattern(__s.begin(), __s.end()), _M_mark_count(0)\n+        { _M_compile(); }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the range\n+       * [first, last) interpreted according to the flags in @p f.\n+       *\n+       * @param first The start of a range containing a valid regular\n+       *              expression.\n+       * @param last  The end of a range containing a valid regular\n+       *              expression.\n+       * @param f     The format flags of the regular expression.\n+       *\n+       * @throws regex_error if @p [first, last) is not a valid regular\n+       *         expression.\n+       */\n+      template<typename _InputIterator>\n+        basic_regex(_InputIterator __first, _InputIterator __last, \n+\t\t    flag_type __f = regex_constants::ECMAScript)\n+\t: _M_flags(__f), _M_pattern(__first, __last), _M_mark_count(0)\n+        { _M_compile(); }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      /**\n+       * @brief Constructs a basic regular expression from an initializer list.\n+       *\n+       * @param l  The initializer list.\n+       * @param f  The format flags of the regular expression.\n+       *\n+       * @throws regex_error if @p l is not a valid regular expression.\n+       */\n+      basic_regex(initializer_list<_Ch_type> __l,\n+\t\t  flag_type __f = regex_constants::ECMAScript)\n+\t: _M_flags(__f), _M_pattern(__l.begin(), __l.end()), _M_mark_count(0)\n+        { _M_compile(); }\n+#endif\n+\n+      /**\n+       * @brief Destroys a basic regular expression.\n+       */\n+      ~basic_regex()\n+      { }\n+      \n+      /**\n+       * @brief Assigns one regular expression to another.\n+       */\n+      basic_regex&\n+      operator=(const basic_regex& __rhs)\n+      { return this->assign(__rhs); }\n+\n+      /**\n+       * @brief Replaces a regular expression with a new one constructed from\n+       * a C-style null-terminated string.\n+       *\n+       * @param A pointer to the start of a null-terminated C-style string\n+       *        containing a regular expression.\n+       */\n+      basic_regex&\n+      operator=(const _Ch_type* __p)\n+      { return this->assign(__p, flags()); }\n+      \n+      /**\n+       * @brief Replaces a regular expression with a new one constructed from\n+       * a string.\n+       *\n+       * @param A pointer to a string containing a regular expression.\n+       */\n+      template<typename _Ch_typeraits, typename _Allocator>\n+        basic_regex&\n+        operator=(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s)\n+        { return this->assign(__s, flags()); }\n+\n+      // [7.8.3] assign\n+      /**\n+       * @brief the real assignment operator.\n+       *\n+       * @param that Another regular expression object.\n+       */\n+      basic_regex&\n+      assign(const basic_regex& __that)\n+      {\n+\tbasic_regex __tmp(__that);\n+\tthis->swap(__tmp);\n+\treturn *this;\n+      }\n+      \n+      /**\n+       * @brief Assigns a new regular expression to a regex object from a\n+       * C-style null-terminated string containing a regular expression\n+       * pattern.\n+       *\n+       * @param p     A pointer to a C-style null-terminated string containing\n+       *              a regular expression pattern.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * *this remains unchanged.\n+       */\n+      basic_regex&\n+      assign(const _Ch_type* __p,\n+\t     flag_type __flags = regex_constants::ECMAScript)\n+      { return this->assign(string_type(__p), __flags); }\n+\n+      /**\n+       * @brief Assigns a new regular expression to a regex object from a\n+       * C-style string containing a regular expression pattern.\n+       *\n+       * @param p     A pointer to a C-style string containing a\n+       *              regular expression pattern.\n+       * @param len   The length of the regular expression pattern string.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * *this remains unchanged.\n+       */\n+      basic_regex&\n+      assign(const _Ch_type* __p, std::size_t __len, flag_type __flags)\n+      { return this->assign(string_type(__p, __len), __flags); }\n+\n+      /**\n+       * @brief Assigns a new regular expression to a regex object from a \n+       * string containing a regular expression pattern.\n+       *\n+       * @param s     A string containing a regular expression pattern.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * *this remains unchanged.\n+       */\n+      template<typename _Ch_typeraits, typename _Allocator>\n+        basic_regex&\n+        assign(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s,\n+\t       flag_type __f = regex_constants::ECMAScript)\n+        { \n+\t  basic_regex __tmp(__s, __f);\n+\t  this->swap(__tmp);\n+\t  return *this;\n+\t}\n+\n+      /**\n+       * @brief Assigns a new regular expression to a regex object.\n+       *\n+       * @param first The start of a range containing a valid regular\n+       *              expression.\n+       * @param last  The end of a range containing a valid regular\n+       *              expression.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * the object remains unchanged.\n+       */\n+      template<typename _InputIterator>\n+        basic_regex&\n+        assign(_InputIterator __first, _InputIterator __last,\n+\t       flag_type __flags = regex_constants::ECMAScript)\n+        { return this->assign(string_type(__first, __last), __flags); }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      /**\n+       * @brief Assigns a new regular expression to a regex object.\n+       *\n+       * @param l     An initializer list representing a regular expression.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if @p l does not contain a valid regular\n+       * expression pattern interpreted according to @p flags.  If regex_error\n+       * is thrown, the object remains unchanged.\n+       */\n+      basic_regex&\n+      assign(initializer_list<_Ch_type> __l,\n+\t     flag_type __f = regex_constants::ECMAScript)\n+      { return this->assign(__l.begin(), __l.end(), __f); }\n+#endif\n+\n+      // [7.8.4] const operations\n+      /**\n+       * @brief Gets the number of marked subexpressions within the regular\n+       * expression.\n+       */\n+      unsigned int\n+      mark_count() const\n+      { return _M_mark_count; }\n+      \n+      /**\n+       * @brief Gets the flags used to construct the regular expression\n+       * or in the last call to assign().\n+       */\n+      flag_type\n+      flags() const\n+      { return _M_flags; }\n+      \n+      // [7.8.5] locale\n+      /**\n+       * @brief Imbues the regular expression object with the given locale.\n+       *\n+       * @param loc A locale.\n+       */\n+      locale_type\n+      imbue(locale_type __loc)\n+      { return _M_traits.imbue(__loc); }\n+      \n+      /**\n+       * @brief Gets the locale currently imbued in the regular expression\n+       *        object.\n+       */\n+      locale_type\n+      getloc() const\n+      { return _M_traits.getloc(); }\n+      \n+      // [7.8.6] swap\n+      /**\n+       * @brief Swaps the contents of two regular expression objects.\n+       *\n+       * @param rhs Another regular expression object.\n+       */\n+      void\n+      swap(basic_regex& __rhs)\n+      {\n+\tstd::swap(_M_flags,      __rhs._M_flags);\n+\tstd::swap(_M_pattern,    __rhs._M_pattern);\n+\tstd::swap(_M_mark_count, __rhs._M_mark_count);\n+\tstd::swap(_M_traits,     __rhs._M_traits);\n+      }\n+      \n+    private:\n+      /**\n+       * @brief Compiles a regular expression pattern into a NFA.\n+       * @todo Implement this function.\n+       */\n+      void _M_compile();\n+\n+    protected:\n+      flag_type    _M_flags;\n+      string_type  _M_pattern;\n+      unsigned int _M_mark_count;\n+      _Rx_traits   _M_traits;\n+    };\n+  \n+  /** @brief Standard regular expressions. */\n+  typedef basic_regex<char>    regex;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  /** @brief Standard wide-character regular expressions. */\n+  typedef basic_regex<wchar_t> wregex;\n+#endif\n+\n+\n+  // [7.8.6] basic_regex swap\n+  /**\n+   * @brief Swaps the contents of two regular expression objects.\n+   * @param lhs First regular expression.\n+   * @param rhs Second regular expression.\n+   */\n+  template<typename _Ch_type, typename _Rx_traits>\n+    inline void\n+    swap(basic_regex<_Ch_type, _Rx_traits>& __lhs,\n+\t basic_regex<_Ch_type, _Rx_traits>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+\n+  // [7.9] Class template sub_match\n+  /**\n+   * A sequence of characters matched by a particular marked sub-expression.\n+   *\n+   * An object of this class is essentially a pair of iterators marking a\n+   * matched subexpression within a regular expression pattern match. Such\n+   * objects can be converted to and compared with std::basic_string objects\n+   * of a similar base character type as the pattern matched by the regular\n+   * expression.\n+   *\n+   * The iterators that make up the pair are the usual half-open interval\n+   * referencing the actual original pattern matched.\n+   */\n+  template<typename _BiIter>\n+    class sub_match : public std::pair<_BiIter, _BiIter>\n+    {\n+    public:\n+      typedef typename iterator_traits<_BiIter>::value_type      value_type;\n+      typedef typename iterator_traits<_BiIter>::difference_type\n+                                                            difference_type;\n+      typedef _BiIter                                              iterator;\n+\n+    public:\n+      bool matched;\n+      \n+      /**\n+       * Gets the length of the matching sequence.\n+       */\n+      difference_type\n+      length() const\n+      { return this->matched ? std::distance(this->first, this->second) : 0; }\n+\n+      /**\n+       * @brief Gets the matching sequence as a string.\n+       *\n+       * @returns the matching sequence as a string.\n+       *\n+       * This is the implicit conversion operator.  It is identical to the\n+       * str() member function except that it will want to pop up in\n+       * unexpected places and cause a great deal of confusion and cursing\n+       * from the unwary.\n+       */\n+      operator basic_string<value_type>() const\n+      {\n+\treturn this->matched\n+\t  ? std::basic_string<value_type>(this->first, this->second)\n+\t  : std::basic_string<value_type>();\n+      }\n+      \n+      /**\n+       * @brief Gets the matching sequence as a string.\n+       *\n+       * @returns the matching sequence as a string.\n+       */\n+      basic_string<value_type>\n+      str() const\n+      {\n+\treturn this->matched\n+\t  ? std::basic_string<value_type>(this->first, this->second)\n+\t  : std::basic_string<value_type>();\n+      }\n+      \n+      /**\n+       * @brief Compares this and another matched sequence.\n+       *\n+       * @param s Another matched sequence to compare to this one.\n+       *\n+       * @retval <0 this matched sequence will collate before @p s.\n+       * @retval =0 this matched sequence is equivalent to @p s.\n+       * @retval <0 this matched sequence will collate after @p s.\n+       */\n+      int\n+      compare(const sub_match& __s) const\n+      { return this->str().compare(__s.str()); }\n+\n+      /**\n+       * @brief Compares this sub_match to a string.\n+       *\n+       * @param s A string to compare to this sub_match.\n+       *\n+       * @retval <0 this matched sequence will collate before @p s.\n+       * @retval =0 this matched sequence is equivalent to @p s.\n+       * @retval <0 this matched sequence will collate after @p s.\n+       */\n+      int\n+      compare(const basic_string<value_type>& __s) const\n+      { return this->str().compare(__s); }\n+      \n+      /**\n+       * @brief Compares this sub_match to a C-style string.\n+       *\n+       * @param s A C-style string to compare to this sub_match.\n+       *\n+       * @retval <0 this matched sequence will collate before @p s.\n+       * @retval =0 this matched sequence is equivalent to @p s.\n+       * @retval <0 this matched sequence will collate after @p s.\n+       */\n+      int\n+      compare(const value_type* __s) const\n+      { return this->str().compare(__s); }\n+    };\n+  \n+  \n+  /** @brief Standard regex submatch over a C-style null-terminated string. */\n+  typedef sub_match<const char*>             csub_match;\n+  /** @brief Standard regex submatch over a standard string. */\n+  typedef sub_match<string::const_iterator>  ssub_match;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  /** @brief Regex submatch over a C-style null-terminated wide string. */\n+  typedef sub_match<const wchar_t*>          wcsub_match;\n+  /** @brief Regex submatch over a standard wide string. */\n+  typedef sub_match<wstring::const_iterator> wssub_match;\n+#endif\n+\n+  // [7.9.2] sub_match non-member operators\n+  \n+  /**\n+   * @brief Tests the equivalence of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator==(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) == 0; }\n+\n+  /**\n+   * @brief Tests the inequivalence of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator!=(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) != 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator<(const sub_match<_BiIter>& __lhs,\n+\t      const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) < 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator<=(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) <= 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator>=(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) >= 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator>(const sub_match<_BiIter>& __lhs,\n+\t      const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) > 0; }\n+\n+  /**\n+   * @brief Tests the equivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator==(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs == __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the inequivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator!=(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs != __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator<(const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type,\n+\t      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+     { return __lhs < __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator>(const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type, \n+\t      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs > __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator>=(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs >= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator<=(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs <= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the equivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator==(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() == __rhs; }\n+\n+  /**\n+   * @brief Tests the inequivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator!=(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() != __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator<(const sub_match<_Bi_iter>& __lhs,\n+\t      const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type,\n+\t      _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() < __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator>(const sub_match<_Bi_iter>& __lhs,\n+\t      const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type,\n+\t      _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() > __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator>=(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() >= __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator<=(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() <= __rhs; }\n+\n+  /**\n+   * @brief Tests the equivalence of a C string and a regular expression\n+   *        submatch.\n+   * @param lhs A C string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs == __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the inequivalence of an iterator value and a regular\n+   *        expression submatch.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs != __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs < __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs > __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs >= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs <= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the equivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A pointer to a string?\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() == __rhs; }\n+\n+  /**\n+   * @brief Tests the inequivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A pointer to a string.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() != __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() < __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() > __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() >= __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() <= __rhs; }\n+\n+  /**\n+   * @brief Tests the equivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs == __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the inequivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs != __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs < __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs > __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs >= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs <= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the equivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() == __rhs; }\n+\n+  /**\n+   * @brief Tests the inequivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() != __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() < __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() > __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() >= __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() <= __rhs; }\n+\n+  /**\n+   * @brief Inserts a matched string into an output stream.\n+   *\n+   * @param os The output stream.\n+   * @param m  A submatch string.\n+   *\n+   * @returns the output stream with the submatch string inserted.\n+   */\n+  template<typename _Ch_type, typename _Ch_traits, typename _Bi_iter>\n+    inline\n+    basic_ostream<_Ch_type, _Ch_traits>&\n+    operator<<(basic_ostream<_Ch_type, _Ch_traits>& __os,\n+\t       const sub_match<_Bi_iter>& __m)\n+    { return __os << __m.str(); }\n+\n+  // [7.10] Class template match_results\n+  /**\n+   * @brief The results of a match or search operation.\n+   *\n+   * A collection of character sequences representing the result of a regular\n+   * expression match.  Storage for the collection is allocated and freed as\n+   * necessary by the member functions of class template match_results.\n+   *\n+   * This class satisfies the Sequence requirements, with the exception that\n+   * only the operations defined for a const-qualified Sequence are supported.\n+   *\n+   * The sub_match object stored at index 0 represents sub-expression 0, i.e.\n+   * the whole match. In this case the sub_match member matched is always true.\n+   * The sub_match object stored at index n denotes what matched the marked\n+   * sub-expression n within the matched expression. If the sub-expression n\n+   * participated in a regular expression match then the sub_match member\n+   * matched evaluates to true, and members first and second denote the range\n+   * of characters [first, second) which formed that match. Otherwise matched\n+   * is false, and members first and second point to the end of the sequence\n+   * that was searched.\n+   *\n+   * @nosubgrouping\n+   */\n+  template<typename _Bi_iter,\n+\t   typename _Allocator = allocator<sub_match<_Bi_iter> > >\n+    class match_results\n+    : private std::vector<std::tr1::sub_match<_Bi_iter>, _Allocator>\n+    {\n+    private:\n+      typedef std::vector<std::tr1::sub_match<_Bi_iter>, _Allocator>\n+                                                              _Base_type;\n+\n+    public:\n+      /**\n+       * @name 10.? Public Types\n+       */\n+      //@{\n+      typedef sub_match<_Bi_iter>                             value_type;\n+      typedef typename _Allocator::const_reference            const_reference;\n+      typedef const_reference                                 reference;\n+      typedef typename _Base_type::const_iterator             const_iterator;\n+      typedef const_iterator                                  iterator;\n+      typedef typename iterator_traits<_Bi_iter>::difference_type\n+                                                              difference_type;\n+      typedef typename _Allocator::size_type                  size_type;\n+      typedef _Allocator                                      allocator_type;\n+      typedef typename iterator_traits<_Bi_iter>::value_type  char_type;\n+      typedef basic_string<char_type>                         string_type;\n+      //@}\n+  \n+    public:\n+      /**\n+       * @name 10.1 Construction, Copying, and Destruction\n+       */\n+      //@{\n+\n+      /**\n+       * @brief Constructs a default %match_results container.\n+       * @post size() returns 0 and str() returns an empty string.\n+       */\n+      explicit\n+      match_results(const _Allocator& __a = _Allocator())\n+      : _Base_type(__a), _M_matched(false)\n+      { }\n+\n+      /**\n+       * @brief Copy constructs a %match_results.\n+       */\n+      match_results(const match_results& __rhs)\n+      : _Base_type(__rhs), _M_matched(__rhs._M_matched),\n+\t_M_prefix(__rhs._M_prefix), _M_suffix(__rhs._M_suffix)\n+      { }\n+\n+      /**\n+       * @brief Assigns rhs to *this.\n+       */\n+      match_results&\n+      operator=(const match_results& __rhs)\n+      {\n+\tmatch_results __tmp(__rhs);\n+\tthis->swap(__tmp);\n+\treturn *this;\n+      }\n+\n+      /**\n+       * @brief Destroys a %match_results object.\n+       */\n+      ~match_results()\n+      { }\n+      \n+      //@}\n+\n+      /**\n+       * @name 10.2 Size\n+       */\n+      //@{\n+\n+      /**\n+       * @brief Gets the number of matches and submatches.\n+       *\n+       * The number of matches for a given regular expression will be either 0\n+       * if there was no match or mark_count() + 1 if a match was successful.\n+       * Some matches may be empty.\n+       *\n+       * @returns the number of matches found.\n+       */\n+      size_type\n+      size() const\n+      { return _M_matched ? _Base_type::size() + 1 : 0; }\n+      \n+      //size_type\n+      //max_size() const;\n+      using _Base_type::max_size;\n+\n+      /**\n+       * @brief Indicates if the %match_results contains no results.\n+       * @retval true The %match_results object is empty.\n+       * @retval false The %match_results object is not empty.\n+       */\n+      bool\n+      empty() const\n+      { return size() == 0; }\n+      \n+      //@}\n+\n+      /**\n+       * @name 10.3 Element Access\n+       */\n+      //@{\n+\n+      /**\n+       * @brief Gets the length of the indicated submatch.\n+       * @param sub indicates the submatch.\n+       *\n+       * This function returns the length of the indicated submatch, or the\n+       * length of the entire match if @p sub is zero (the default).\n+       */\n+      difference_type\n+      length(size_type __sub = 0) const\n+      { return _M_matched ? this->str(__sub).length() : 0; }\n+\n+      /**\n+       * @brief Gets the offset of the beginning of the indicated submatch.\n+       * @param sub indicates the submatch.\n+       *\n+       * This function returns the offset from the beginning of the target\n+       * sequence to the beginning of the submatch, unless the value of @p sub\n+       * is zero (the default), in which case this function returns the offset\n+       * from the beginning of the target sequence to the beginning of the\n+       * match.\n+       */\n+      difference_type\n+      position(size_type __sub = 0) const\n+      {\n+\treturn _M_matched ? std::distance(this->prefix().first,\n+\t\t\t\t\t  (*this)[__sub].first) : 0;\n+      }\n+\n+      /**\n+       * @brief Gets the match or submatch converted to a string type.\n+       * @param sub indicates the submatch.\n+       *\n+       * This function gets the submatch (or match, if @p sub is zero) extracted\n+       * from the target range and converted to the associated string type.\n+       */\n+      string_type\n+      str(size_type __sub = 0) const\n+      { return _M_matched ? (*this)[__sub].str() : string_type(); }\n+      \n+      /**\n+       * @brief Gets a %sub_match reference for the match or submatch.\n+       * @param sub indicates the submatch.\n+       *\n+       * This function gets a reference to the indicated submatch, or the entire\n+       * match if @p sub is zero.\n+       *\n+       * If @p sub >= size() then this function returns a %sub_match with a\n+       * special value indicating no submatch.\n+       */\n+      const_reference\n+      operator[](size_type __sub) const\n+      { return _Base_type::operator[](__sub); }\n+\n+      /**\n+       * @brief Gets a %sub_match representing the match prefix.\n+       *\n+       * This function gets a reference to a %sub_match object representing the\n+       * part of the target range between the start of the target range and the\n+       * start of the match.\n+       */\n+      const_reference\n+      prefix() const\n+      { return _M_prefix; }\n+\n+      /**\n+       * @brief Gets a %sub_match representing the match suffix.\n+       *\n+       * This function gets a reference to a %sub_match object representing the\n+       * part of the target range between the end of the match and the end of\n+       * the target range.\n+       */\n+      const_reference\n+      suffix() const\n+      { return _M_suffix; }\n+\n+      /**\n+       * @brief Gets an iterator to the start of the %sub_match collection.\n+       */\n+      const_iterator\n+      begin() const\n+      { return _Base_type::begin(); }\n+      \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      /**\n+       * @brief Gets an iterator to the start of the %sub_match collection.\n+       */\n+      const_iterator\n+      cbegin() const\n+      { return _Base_type::begin(); }\n+#endif\n+\n+      /**\n+       * @brief Gets an iterator to one-past-the-end of the collection.\n+       */\n+      const_iterator\n+      end() const\n+      { return _Base_type::end(); }\n+      \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      /**\n+       * @brief Gets an iterator to one-past-the-end of the collection.\n+       */\n+      const_iterator\n+      cend() const\n+      { return _Base_type::end(); }\n+#endif\n+\n+      //@}\n+\n+      /**\n+       * @name 10.4 Formatting\n+       *\n+       * These functions perform formatted substitution of the matched character\n+       * sequences into their target.  The format specifiers and escape sequences\n+       * accepted by these functions are determined by their @p flags parameter \n+       * as documented above.\n+       */\n+       //@{\n+\n+      /**\n+       * @todo Implement this function.\n+       */\n+      template<typename _Out_iter>\n+        _Out_iter\n+        format(_Out_iter __out, const string_type& __fmt,\n+\t       regex_constants::match_flag_type __flags\n+\t       = regex_constants::format_default) const;\n+\n+      /**\n+       * @todo Implement this function.\n+       */\n+      string_type\n+      format(const string_type& __fmt,\n+\t     regex_constants::match_flag_type __flags\n+\t     = regex_constants::format_default) const;\n+\n+      //@} \n+\n+      /**\n+       * @name 10.5 Allocator\n+       */\n+      //@{ \n+\n+      /**\n+       * @brief Gets a copy of the allocator.\n+       */\n+      //allocator_type\n+      //get_allocator() const;\n+      using _Base_type::get_allocator;\n+      \n+      //@} \n+\n+      /**\n+       * @name 10.6 Swap\n+       */\n+       //@{ \n+\n+      /**\n+       * @brief Swaps the contents of two match_results.\n+       */\n+      void\n+      swap(match_results& __that)\n+      {\n+\t_Base_type::swap(__that);\n+\tstd::swap(_M_matched, __that._M_matched);\n+\tstd::swap(_M_prefix,  __that._M_prefix);\n+\tstd::swap(_M_suffix,  __that._M_suffix);\n+      }\n+      //@} \n+      \n+    private:\n+      bool       _M_matched;\n+      value_type _M_prefix;\n+      value_type _M_suffix;\n+    };\n+  \n+  typedef match_results<const char*>             cmatch;\n+  typedef match_results<string::const_iterator>  smatch;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef match_results<const wchar_t*>          wcmatch;\n+  typedef match_results<wstring::const_iterator> wsmatch;\n+#endif\n+\n+  // match_results comparisons\n+  /**\n+   * @brief Compares two match_results for equality.\n+   * @returns true if the two objects refer to the same match,\n+   * false otherwise.\n+   * @todo Implement this function.\n+   */\n+  template<typename _Bi_iter, typename _Allocator>\n+    inline bool\n+    operator==(const match_results<_Bi_iter, _Allocator>& __m1,\n+\t       const match_results<_Bi_iter, _Allocator>& __m2);\n+\n+  /**\n+   * @brief Compares two match_results for inequality.\n+   * @returns true if the two objects do not refer to the same match,\n+   * false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Allocator>\n+    inline bool\n+    operator!=(const match_results<_Bi_iter, _Allocator>& __m1,\n+\t       const match_results<_Bi_iter, _Allocator>& __m2)\n+    { return !(__m1 == __m2); }\n+\n+  // [7.10.6] match_results swap\n+  /**\n+   * @brief Swaps two match results.\n+   * @param lhs A match result.\n+   * @param rhs A match result.\n+   *\n+   * The contents of the two match_results objects are swapped.\n+   */\n+  template<typename _Bi_iter, typename _Allocator>\n+    inline void\n+    swap(match_results<_Bi_iter, _Allocator>& __lhs,\n+\t match_results<_Bi_iter, _Allocator>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+  // [7.11.2] Function template regex_match\n+  /**\n+   * @name Matching, Searching, and Replacing\n+   */\n+  //@{\n+\n+  /**\n+   * @brief Determines if there is a match between the regular expression @p e\n+   * and all of the character sequence [first, last).\n+   *\n+   * @param first Beginning of the character sequence to match.\n+   * @param last  One-past-the-end of the character sequence to match.\n+   * @param m     The match results.\n+   * @param re    The regular expression.\n+   * @param flags Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   *\n+   * @todo Implement this function.\n+   */\n+  template<typename _Bi_iter, typename _Allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    bool\n+    regex_match(_Bi_iter __first, _Bi_iter __last,\n+\t\tmatch_results<_Bi_iter, _Allocator>& __m,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __flags\n+\t\t= regex_constants::match_default);\n+\n+  /**\n+   * @brief Indicates if there is a match between the regular expression @p e\n+   * and all of the character sequence [first, last).\n+   *\n+   * @param first Beginning of the character sequence to match.\n+   * @param last  One-past-the-end of the character sequence to match.\n+   * @param re    The regular expression.\n+   * @param flags Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>\n+    bool\n+    regex_match(_Bi_iter __first, _Bi_iter __last,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __flags\n+\t\t= regex_constants::match_default)\n+    { \n+      match_results<_Bi_iter> __what;\n+      return regex_match(__first, __last, __what, __re, __flags);\n+    }\n+\n+  /**\n+   * @brief Determines if there is a match between the regular expression @p e\n+   * and a C-style null-terminated string.\n+   *\n+   * @param s  The C-style null-terminated string to match.\n+   * @param m  The match results.\n+   * @param re The regular expression.\n+   * @param f  Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_type, typename _Allocator, typename _Rx_traits>\n+    inline bool\n+    regex_match(const _Ch_type* __s,\n+\t\tmatch_results<const _Ch_type*, _Allocator>& __m,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __f\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s, __s + _Rx_traits::length(__s), __m, __re, __f); }\n+\n+  /**\n+   * @brief Determines if there is a match between the regular expression @p e\n+   * and a string.\n+   *\n+   * @param s     The string to match.\n+   * @param m     The match results.\n+   * @param re    The regular expression.\n+   * @param flags Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_traits, typename _Ch_alloc,\n+\t   typename _Allocator, typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n+\t\tmatch_results<typename basic_string<_Ch_type, \n+\t\t_Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __flags\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s.begin(), __s.end(), __m, __re, __flags); }\n+\n+  /**\n+   * @brief Indicates if there is a match between the regular expression @p e\n+   * and a C-style null-terminated string.\n+   *\n+   * @param s  The C-style null-terminated string to match.\n+   * @param re The regular expression.\n+   * @param f  Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_type, class _Rx_traits>\n+    inline bool\n+    regex_match(const _Ch_type* __s,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __f\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s, __s + _Rx_traits::length(__s), __re, __f); }\n+\n+  /**\n+   * @brief Indicates if there is a match between the regular expression @p e\n+   * and a string.\n+   *\n+   * @param s     [IN] The string to match.\n+   * @param re    [IN] The regular expression.\n+   * @param flags [IN] Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_traits, typename _Str_allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_match(const basic_string<_Ch_type, _Ch_traits, _Str_allocator>& __s,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __flags\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s.begin(), __s.end(), __re, __flags); }\n+\n+  // [7.11.3] Function template regex_search\n+  /**\n+   * Searches for a regular expression within a range.\n+   * @param first [IN]  The start of the string to search.\n+   * @param last  [IN]  One-past-the-end of the string to search.\n+   * @param m     [OUT] The match results.\n+   * @param re    [IN]  The regular expression to search for.\n+   * @param flags [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string, the content of %m is\n+   *               undefined.\n+   *\n+   * @throws an exception of type regex_error.\n+   *\n+   * @todo Implement this function.\n+   */\n+  template<typename _Bi_iter, typename _Allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(_Bi_iter __first, _Bi_iter __last,\n+\t\t match_results<_Bi_iter, _Allocator>& __m,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\t regex_constants::match_flag_type __flags\n+\t\t = regex_constants::match_default);\n+\n+  /**\n+   * Searches for a regular expression within a range.\n+   * @param first [IN]  The start of the string to search.\n+   * @param last  [IN]  One-past-the-end of the string to search.\n+   * @param re    [IN]  The regular expression to search for.\n+   * @param flags [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string.\n+   * @doctodo\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(_Bi_iter __first, _Bi_iter __last,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\t regex_constants::match_flag_type __flags\n+\t\t = regex_constants::match_default)\n+    {\n+      match_results<_Bi_iter> __what;\n+      return regex_search(__first, __last, __what, __re, __flags);\n+    }\n+\n+  /**\n+   * @brief Searches for a regular expression within a C-string.\n+   * @param s [IN]  A C-string to search for the regex.\n+   * @param m [OUT] The set of regex matches.\n+   * @param e [IN]  The regex to search for in @p s.\n+   * @param f [IN]  The search flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string, the content of %m is\n+   *               undefined.\n+   * @doctodo\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_type, class _Allocator, class _Rx_traits>\n+    inline bool\n+    regex_search(const _Ch_type* __s,\n+\t\t match_results<const _Ch_type*, _Allocator>& __m,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __f\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s, __s + _Rx_traits::length(__s), __m, __e, __f); }\n+\n+  /**\n+   * @brief Searches for a regular expression within a C-string.\n+   * @param s [IN]  The C-string to search.\n+   * @param e [IN]  The regular expression to search for.\n+   * @param f [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string.\n+   * @doctodo\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(const _Ch_type* __s,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __f\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s, __s + _Rx_traits::length(__s), __e, __f); }\n+\n+  /**\n+   * @brief Searches for a regular expression within a string.\n+   * @param s     [IN]  The string to search.\n+   * @param e     [IN]  The regular expression to search for.\n+   * @param flags [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string.\n+   * @doctodo\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_traits, typename _String_allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(const basic_string<_Ch_type, _Ch_traits,\n+\t\t _String_allocator>& __s,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __flags\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s.begin(), __s.end(), __e, __flags); }\n+\n+  /**\n+   * @brief Searches for a regular expression within a string.\n+   * @param s [IN]  A C++ string to search for the regex.\n+   * @param m [OUT] The set of regex matches.\n+   * @param e [IN]  The regex to search for in @p s.\n+   * @param f [IN]  The search flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string, the content of %m is\n+   *               undefined.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_traits, typename _Ch_alloc,\n+\t   typename _Allocator, typename _Ch_type,\n+\t   typename _Rx_traits>\n+    inline bool\n+    regex_search(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n+\t\t match_results<typename basic_string<_Ch_type,\n+\t\t _Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __f\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s.begin(), __s.end(), __m, __e, __f); }\n+\n+  // tr1 [7.11.4] std [28.11.4] Function template regex_replace\n+  /**\n+   * @doctodo\n+   * @param out\n+   * @param first\n+   * @param last\n+   * @param e\n+   * @param fmt\n+   * @param flags\n+   *\n+   * @returns out\n+   * @throws an exception of type regex_error.\n+   *\n+   * @todo Implement this function.\n+   */\n+  template<typename _Out_iter, typename _Bi_iter,\n+\t   typename _Rx_traits, typename _Ch_type>\n+    inline _Out_iter\n+    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,\n+\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t  const basic_string<_Ch_type>& __fmt,\n+\t\t  regex_constants::match_flag_type __flags\n+\t\t  = regex_constants::match_default);\n+\n+  /**\n+   * @doctodo\n+   * @param s\n+   * @param e\n+   * @param fmt\n+   * @param flags\n+   *\n+   * @returns a copy of string @p s with replacements.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Rx_traits, typename _Ch_type>\n+    inline basic_string<_Ch_type>\n+    regex_replace(const basic_string<_Ch_type>& __s,\n+\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t  const basic_string<_Ch_type>& __fmt,\n+\t\t  regex_constants::match_flag_type __flags\n+\t\t  = regex_constants::match_default)\n+    {\n+      std::string __result;\n+      regex_replace(std::back_inserter(__result),\n+\t\t    __s.begin(), __s.end(), __e, __fmt, __flags);\n+      return __result;\n+    }\n+\n+  //@}\n+\n+  // tr1 [7.12.1] std [28.12] Class template regex_iterator\n+  /**\n+   * An iterator adaptor that will provide repeated calls of regex_search over \n+   * a range until no more matches remain.\n+   */\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n+\t   typename _Rx_traits = regex_traits<_Ch_type> >\n+    class regex_iterator\n+    {\n+    public:\n+      typedef basic_regex<_Ch_type, _Rx_traits>  regex_type;\n+      typedef match_results<_Bi_iter>            value_type;\n+      typedef std::ptrdiff_t                     difference_type;\n+      typedef const value_type*                  pointer;\n+      typedef const value_type&                  reference;\n+      typedef std::forward_iterator_tag          iterator_category;\n+\n+    public:\n+      /**\n+       * @brief Provides a singular iterator, useful for indicating\n+       * one-past-the-end of a range.\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator();\n+      \n+      /**\n+       * Constructs a %regex_iterator...\n+       * @param a  [IN] The start of a text range to search.\n+       * @param b  [IN] One-past-the-end of the text range to search.\n+       * @param re [IN] The regular expression to match.\n+       * @param m  [IN] Policy flags for match rules.\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n+\t\t     regex_constants::match_flag_type __m\n+\t\t     = regex_constants::match_default);\n+\n+      /**\n+       * Copy constructs a %regex_iterator.\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator&\n+      operator=(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      bool\n+      operator==(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      bool\n+      operator!=(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      const value_type&\n+      operator*();\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      const value_type*\n+      operator->();\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator&\n+      operator++();\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator\n+      operator++(int);\n+      \n+    private:\n+      // these members are shown for exposition only:\n+      _Bi_iter                         begin;\n+      _Bi_iter                         end;\n+      const regex_type*                pregex;\n+      regex_constants::match_flag_type flags;\n+      match_results<_Bi_iter>          match;\n+    };\n+  \n+  typedef regex_iterator<const char*>             cregex_iterator;\n+  typedef regex_iterator<string::const_iterator>  sregex_iterator;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef regex_iterator<const wchar_t*>          wcregex_iterator;\n+  typedef regex_iterator<wstring::const_iterator> wsregex_iterator;\n+#endif\n+\n+  // [7.12.2] Class template regex_token_iterator\n+  /**\n+   * Iterates over submatches in a range (or @a splits a text string).\n+   *\n+   * The purpose of this iterator is to enumerate all, or all specified,\n+   * matches of a regular expression within a text range.  The dereferenced\n+   * value of an iterator of this class is a std::tr1::sub_match object.\n+   */\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n+\t   typename _Rx_traits = regex_traits<_Ch_type> >\n+    class regex_token_iterator\n+    {\n+    public:\n+      typedef basic_regex<_Ch_type, _Rx_traits> regex_type;\n+      typedef sub_match<_Bi_iter>               value_type;\n+      typedef std::ptrdiff_t                    difference_type;\n+      typedef const value_type*                 pointer;\n+      typedef const value_type&                 reference;\n+      typedef std::forward_iterator_tag         iterator_category;\n+      \n+    public:\n+      /**\n+       * @brief Default constructs a %regex_token_iterator.\n+       * @todo Implement this function.\n+       * \n+       * A default-constructed %regex_token_iterator is a singular iterator\n+       * that will compare equal to the one-past-the-end value for any\n+       * iterator of the same type.\n+       */\n+      regex_token_iterator();\n+      \n+      /**\n+       * Constructs a %regex_token_iterator...\n+       * @param a          [IN] The start of the text to search.\n+       * @param b          [IN] One-past-the-end of the text to search.\n+       * @param re         [IN] The regular expression to search for.\n+       * @param submatch   [IN] Which submatch to return.  There are some\n+       *                        special values for this parameter:\n+       *                        - -1 each enumerated subexpression does NOT\n+       *                          match the regular expression (aka field\n+       *                          splitting)\n+       *                        - 0 the entire string matching the\n+       *                          subexpression is returned for each match\n+       *                          within the text.\n+       *                        - >0 enumerates only the indicated\n+       *                          subexpression from a match within the text.\n+       * @param m          [IN] Policy flags for match rules.\n+       *\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_token_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n+\t\t\t   int __submatch = 0,\n+\t\t\t   regex_constants::match_flag_type __m\n+\t\t\t   = regex_constants::match_default);\n+\n+      /**\n+       * Constructs a %regex_token_iterator...\n+       * @param a          [IN] The start of the text to search.\n+       * @param b          [IN] One-past-the-end of the text to search.\n+       * @param re         [IN] The regular expression to search for.\n+       * @param submatches [IN] A list of subexpressions to return for each\n+       *                        regular expression match within the text.\n+       * @param m          [IN] Policy flags for match rules.\n+       *\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n+\t\t\t   const regex_type& __re,\n+\t\t\t   const std::vector<int>& __submatches,\n+\t\t\t   regex_constants::match_flag_type __m\n+\t\t\t     = regex_constants::match_default);\n+\n+      /**\n+       * Constructs a %regex_token_iterator...\n+       * @param a          [IN] The start of the text to search.\n+       * @param b          [IN] One-past-the-end of the text to search.\n+       * @param re         [IN] The regular expression to search for.\n+       * @param submatches [IN] A list of subexpressions to return for each\n+       *                        regular expression match within the text.\n+       * @param m          [IN] Policy flags for match rules.\n+       \n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      template<std::size_t _Nm>\n+        regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n+\t\t\t     const regex_type& __re,\n+\t\t\t     const int (&__submatches)[_Nm],\n+\t\t\t     regex_constants::match_flag_type __m\n+\t\t\t     = regex_constants::match_default);\n+\n+      /**\n+       * @brief Copy constructs a %regex_token_iterator.\n+       * @param rhs [IN] A %regex_token_iterator to copy.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Assigns a %regex_token_iterator to another.\n+       * @param rhs [IN] A %regex_token_iterator to copy.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator&\n+      operator=(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Compares a %regex_token_iterator to another for equality.\n+       * @todo Implement this function.\n+       */\n+      bool\n+      operator==(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Compares a %regex_token_iterator to another for inequality.\n+       * @todo Implement this function.\n+       */\n+      bool\n+      operator!=(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Dereferences a %regex_token_iterator.\n+       * @todo Implement this function.\n+       */\n+      const value_type&\n+      operator*();\n+      \n+      /**\n+       * @brief Selects a %regex_token_iterator member.\n+       * @todo Implement this function.\n+       */\n+      const value_type*\n+      operator->();\n+      \n+      /**\n+       * @brief Increments a %regex_token_iterator.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator&\n+      operator++();\n+      \n+      /**\n+       * @brief Postincrements a %regex_token_iterator.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator\n+      operator++(int);\n+      \n+    private: // data members for exposition only:\n+      typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> position_iterator;\n+\n+      position_iterator __position;\n+      const value_type* __result;\n+      value_type        __suffix;\n+      std::size_t       __n;\n+      std::vector<int>  __subs;\n+    };\n+\n+  /** @brief Token iterator for C-style NULL-terminated strings. */\n+  typedef regex_token_iterator<const char*>             cregex_token_iterator;\n+  /** @brief Token iterator for standard strings. */\n+  typedef regex_token_iterator<string::const_iterator>  sregex_token_iterator;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  /** @brief Token iterator for C-style NULL-terminated wide strings. */\n+  typedef regex_token_iterator<const wchar_t*>          wcregex_token_iterator;\n+  /** @brief Token iterator for standard wide-character strings. */\n+  typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;\n #endif\n+  \n+  //@}\n+}\n+}\n \n #endif // _GLIBCXX_TR1_REGEX"}, {"sha": "947ee7f32c1f8b666c4e8041a79c5f61a291fa8b", "filename": "libstdc++-v3/include/tr1/shared_ptr.h", "status": "modified", "additions": 195, "deletions": 4, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fshared_ptr.h?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -49,14 +49,205 @@\n #ifndef _TR1_SHARED_PTR_H\n #define _TR1_SHARED_PTR_H 1\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n namespace std\n {\n namespace tr1\n {\n+ /**\n+   *  @brief  Exception possibly thrown by @c shared_ptr.\n+   *  @ingroup exceptions\n+   */\n+  class bad_weak_ptr : public std::exception\n+  {\n+  public:\n+    virtual char const*\n+    what() const throw()\n+    { return \"tr1::bad_weak_ptr\"; }\n+  };\n+\n+  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n+  inline void\n+  __throw_bad_weak_ptr()\n+  {\n+#if __EXCEPTIONS\n+    throw bad_weak_ptr();\n+#else\n+    __builtin_abort();\n+#endif\n+  }\n+\n+  using __gnu_cxx::_Lock_policy;\n+  using __gnu_cxx::__default_lock_policy;\n+  using __gnu_cxx::_S_single;\n+  using __gnu_cxx::_S_mutex;\n+  using __gnu_cxx::_S_atomic;\n+\n+  // Empty helper class except when the template argument is _S_mutex.\n+  template<_Lock_policy _Lp>\n+    class _Mutex_base\n+    {\n+    protected:\n+      // The atomic policy uses fully-fenced builtins, single doesn't care.\n+      enum { _S_need_barriers = 0 };\n+    };\n+\n+  template<>\n+    class _Mutex_base<_S_mutex>\n+    : public __gnu_cxx::__mutex\n+    {\n+    protected:\n+      // This policy is used when atomic builtins are not available.\n+      // The replacement atomic operations might not have the necessary\n+      // memory barriers.\n+      enum { _S_need_barriers = 1 };\n+    };\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class _Sp_counted_base\n+    : public _Mutex_base<_Lp>\n+    {\n+    public:  \n+      _Sp_counted_base()\n+      : _M_use_count(1), _M_weak_count(1) { }\n+      \n+      virtual\n+      ~_Sp_counted_base() // nothrow \n+      { }\n+  \n+      // Called when _M_use_count drops to zero, to release the resources\n+      // managed by *this.\n+      virtual void\n+      _M_dispose() = 0; // nothrow\n+      \n+      // Called when _M_weak_count drops to zero.\n+      virtual void\n+      _M_destroy() // nothrow\n+      { delete this; }\n+      \n+      virtual void*\n+      _M_get_deleter(const std::type_info&) = 0;\n+\n+      void\n+      _M_add_ref_copy()\n+      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }\n+  \n+      void\n+      _M_add_ref_lock();\n+      \n+      void\n+      _M_release() // nothrow\n+      {\n+        // Be race-detector-friendly.  For more info see bits/c++config.\n+        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);\n+\tif (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)\n+\t  {\n+            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);\n+\t    _M_dispose();\n+\t    // There must be a memory barrier between dispose() and destroy()\n+\t    // to ensure that the effects of dispose() are observed in the\n+\t    // thread that runs destroy().\n+\t    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html\n+\t    if (_Mutex_base<_Lp>::_S_need_barriers)\n+\t      {\n+\t        _GLIBCXX_READ_MEM_BARRIER;\n+\t        _GLIBCXX_WRITE_MEM_BARRIER;\n+\t      }\n+\n+            // Be race-detector-friendly.  For more info see bits/c++config.\n+            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);\n+\t    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,\n+\t\t\t\t\t\t       -1) == 1)\n+              {\n+                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);\n+\t        _M_destroy();\n+              }\n+\t  }\n+      }\n+  \n+      void\n+      _M_weak_add_ref() // nothrow\n+      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }\n+\n+      void\n+      _M_weak_release() // nothrow\n+      {\n+        // Be race-detector-friendly. For more info see bits/c++config.\n+        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);\n+\tif (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)\n+\t  {\n+            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);\n+\t    if (_Mutex_base<_Lp>::_S_need_barriers)\n+\t      {\n+\t        // See _M_release(),\n+\t        // destroy() must observe results of dispose()\n+\t        _GLIBCXX_READ_MEM_BARRIER;\n+\t        _GLIBCXX_WRITE_MEM_BARRIER;\n+\t      }\n+\t    _M_destroy();\n+\t  }\n+      }\n+  \n+      long\n+      _M_get_use_count() const // nothrow\n+      {\n+        // No memory barrier is used here so there is no synchronization\n+        // with other threads.\n+        return const_cast<const volatile _Atomic_word&>(_M_use_count);\n+      }\n+\n+    private:  \n+      _Sp_counted_base(_Sp_counted_base const&);\n+      _Sp_counted_base& operator=(_Sp_counted_base const&);\n+\n+      _Atomic_word  _M_use_count;     // #shared\n+      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)\n+    };\n+\n+  template<>\n+    inline void\n+    _Sp_counted_base<_S_single>::\n+    _M_add_ref_lock()\n+    {\n+      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n+\t{\n+\t  _M_use_count = 0;\n+\t  __throw_bad_weak_ptr();\n+\t}\n+    }\n+\n+  template<>\n+    inline void\n+    _Sp_counted_base<_S_mutex>::\n+    _M_add_ref_lock()\n+    {\n+      __gnu_cxx::__scoped_lock sentry(*this);\n+      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n+\t{\n+\t  _M_use_count = 0;\n+\t  __throw_bad_weak_ptr();\n+\t}\n+    }\n+\n+  template<> \n+    inline void\n+    _Sp_counted_base<_S_atomic>::\n+    _M_add_ref_lock()\n+    {\n+      // Perform lock-free add-if-not-zero operation.\n+      _Atomic_word __count;\n+      do\n+\t{\n+\t  __count = _M_use_count;\n+\t  if (__count == 0)\n+\t    __throw_bad_weak_ptr();\n+\t  \n+\t  // Replace the current counter value with the old value + 1, as\n+\t  // long as it's not changed meanwhile. \n+\t}\n+      while (!__sync_bool_compare_and_swap(&_M_use_count, __count,\n+\t\t\t\t\t   __count + 1));\n+    }\n+\n   template<typename _Ptr, typename _Deleter, _Lock_policy _Lp>\n     class _Sp_counted_base_impl\n     : public _Sp_counted_base<_Lp>"}, {"sha": "88aae7ad8b1b49d139f3c2eb88a63123bd6f9ff6", "filename": "libstdc++-v3/include/tr1/type_traits", "status": "modified", "additions": 466, "deletions": 31, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -32,35 +32,467 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <bits/c++config.h>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/type_traits>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/type_traits>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n-\n namespace std\n {\n namespace tr1\n {\n-#define _DEFINE_SPEC(_Trait, _Type)    \\\n-  template<>                           \\\n-    struct _Trait<_Type>\t       \\\n+  /**\n+   * @defgroup metaprogramming Type Traits\n+   * @ingroup utilities\n+   *\n+   * Compile time type transformation and information.\n+   * @{\n+   */\n+\n+  struct __sfinae_types\n+  {\n+    typedef char __one;\n+    typedef struct { char __arr[2]; } __two;\n+  };\n+\n+#define _DEFINE_SPEC_0_HELPER                          \\\n+  template<>\n+\n+#define _DEFINE_SPEC_1_HELPER                          \\\n+  template<typename _Tp>\n+\n+#define _DEFINE_SPEC_2_HELPER                          \\\n+  template<typename _Tp, typename _Cp>\n+\n+#define _DEFINE_SPEC(_Order, _Trait, _Type, _Value)    \\\n+  _DEFINE_SPEC_##_Order##_HELPER                       \\\n+    struct _Trait<_Type>                               \\\n+    : public integral_constant<bool, _Value> { };\n+\n+  // helper classes [4.3].\n+\n+  /// integral_constant\n+  template<typename _Tp, _Tp __v>\n+    struct integral_constant\n+    {\n+      static const _Tp                      value = __v;\n+      typedef _Tp                           value_type;\n+      typedef integral_constant<_Tp, __v>   type;\n+    };\n+  \n+  /// typedef for true_type\n+  typedef integral_constant<bool, true>     true_type;\n+\n+  /// typedef for false_type\n+  typedef integral_constant<bool, false>    false_type;\n+\n+  template<typename _Tp, _Tp __v>\n+    const _Tp integral_constant<_Tp, __v>::value;\n+\n+  /// remove_cv\n+  template<typename>\n+    struct remove_cv;\n+\n+  template<typename>\n+    struct __is_void_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(0, __is_void_helper, void, true)\n+\n+  // primary type categories [4.5.1].\n+\n+  /// is_void\n+  template<typename _Tp>\n+    struct is_void\n+    : public integral_constant<bool, (__is_void_helper<typename\n+\t\t\t\t      remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  template<typename>\n+    struct __is_integral_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(0, __is_integral_helper, bool, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, char, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, signed char, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, unsigned char, true)\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  _DEFINE_SPEC(0, __is_integral_helper, wchar_t, true)\n+#endif\n+  _DEFINE_SPEC(0, __is_integral_helper, short, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, unsigned short, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, int, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, unsigned int, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, long, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, unsigned long, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, long long, true)\n+  _DEFINE_SPEC(0, __is_integral_helper, unsigned long long, true)\n+\n+  /// is_integral\n+  template<typename _Tp>\n+    struct is_integral\n+    : public integral_constant<bool, (__is_integral_helper<typename\n+\t\t\t\t      remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  template<typename>\n+    struct __is_floating_point_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(0, __is_floating_point_helper, float, true)\n+  _DEFINE_SPEC(0, __is_floating_point_helper, double, true)\n+  _DEFINE_SPEC(0, __is_floating_point_helper, long double, true)\n+\n+  /// is_floating_point\n+  template<typename _Tp>\n+    struct is_floating_point\n+    : public integral_constant<bool, (__is_floating_point_helper<typename\n+\t\t\t\t      remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  /// is_array\n+  template<typename>\n+    struct is_array\n+    : public false_type { };\n+\n+  template<typename _Tp, std::size_t _Size>\n+    struct is_array<_Tp[_Size]>\n+    : public true_type { };\n+\n+  template<typename _Tp>\n+    struct is_array<_Tp[]>\n+    : public true_type { };\n+\n+  template<typename>\n+    struct __is_pointer_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(1, __is_pointer_helper, _Tp*, true)\n+\n+  /// is_pointer\n+  template<typename _Tp>\n+    struct is_pointer\n+    : public integral_constant<bool, (__is_pointer_helper<typename\n+\t\t\t\t      remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  /// is_reference\n+  template<typename _Tp>\n+    struct is_reference;\n+\n+  /// is_function\n+  template<typename _Tp>\n+    struct is_function;\n+\n+  template<typename>\n+    struct __is_member_object_pointer_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(2, __is_member_object_pointer_helper, _Tp _Cp::*,\n+\t       !is_function<_Tp>::value)\n+\n+  /// is_member_object_pointer\n+  template<typename _Tp>\n+    struct is_member_object_pointer\n+    : public integral_constant<bool, (__is_member_object_pointer_helper<\n+\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  template<typename>\n+    struct __is_member_function_pointer_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(2, __is_member_function_pointer_helper, _Tp _Cp::*,\n+\t       is_function<_Tp>::value)\n+\n+  /// is_member_function_pointer\n+  template<typename _Tp>\n+    struct is_member_function_pointer\n+    : public integral_constant<bool, (__is_member_function_pointer_helper<\n+\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  /// is_enum\n+  template<typename _Tp>\n+    struct is_enum\n+    : public integral_constant<bool, __is_enum(_Tp)>\n+    { };\n+\n+  /// is_union\n+  template<typename _Tp>\n+    struct is_union\n+    : public integral_constant<bool, __is_union(_Tp)>\n+    { };\n+\n+  /// is_class\n+  template<typename _Tp>\n+    struct is_class\n+    : public integral_constant<bool, __is_class(_Tp)>\n+    { };\n+\n+  /// is_function\n+  template<typename>\n+    struct is_function\n+    : public false_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes...)>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes......)>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes...) const>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes......) const>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes...) volatile>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes......) volatile>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes...) const volatile>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes......) const volatile>\n+    : public true_type { };\n+\n+  // composite type traits [4.5.2].\n+  \n+  /// is_arithmetic\n+  template<typename _Tp>\n+    struct is_arithmetic\n+    : public integral_constant<bool, (is_integral<_Tp>::value\n+\t\t\t\t      || is_floating_point<_Tp>::value)>\n+    { };\n+\n+  /// is_fundamental\n+  template<typename _Tp>\n+    struct is_fundamental\n+    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n+\t\t\t\t      || is_void<_Tp>::value)>\n+    { };\n+\n+  /// is_object\n+  template<typename _Tp>\n+    struct is_object\n+    : public integral_constant<bool, !(is_function<_Tp>::value\n+\t\t\t\t       || is_reference<_Tp>::value\n+\t\t\t\t       || is_void<_Tp>::value)>\n+    { };\n+\n+  /// is_member_pointer\n+  template<typename _Tp>\n+    struct is_member_pointer;\n+\n+  /// is_scalar\n+  template<typename _Tp>\n+    struct is_scalar\n+    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n+\t\t\t\t      || is_enum<_Tp>::value\n+\t\t\t\t      || is_pointer<_Tp>::value\n+\t\t\t\t      || is_member_pointer<_Tp>::value)>\n+    { };\n+\n+  /// is_compound\n+  template<typename _Tp>\n+    struct is_compound\n+    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };\n+\n+  /// is_member_pointer\n+  template<typename _Tp>\n+    struct __is_member_pointer_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(2, __is_member_pointer_helper, _Tp _Cp::*, true)\n+\n+  template<typename _Tp>\n+  struct is_member_pointer\n+    : public integral_constant<bool, (__is_member_pointer_helper<\n+\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n+    { };\n+\n+  // type properties [4.5.3].\n+  /// is_const\n+  template<typename>\n+    struct is_const\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct is_const<_Tp const>\n+    : public true_type { };\n+  \n+  /// is_volatile\n+  template<typename>\n+    struct is_volatile\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct is_volatile<_Tp volatile>\n+    : public true_type { };\n+\n+  /// is_empty\n+  template<typename _Tp>\n+    struct is_empty\n+    : public integral_constant<bool, __is_empty(_Tp)>\n+    { };\n+\n+  /// is_polymorphic\n+  template<typename _Tp>\n+    struct is_polymorphic\n+    : public integral_constant<bool, __is_polymorphic(_Tp)>\n+    { };\n+\n+  /// is_abstract\n+  template<typename _Tp>\n+    struct is_abstract\n+    : public integral_constant<bool, __is_abstract(_Tp)>\n+    { };\n+\n+  /// has_virtual_destructor\n+  template<typename _Tp>\n+    struct has_virtual_destructor\n+    : public integral_constant<bool, __has_virtual_destructor(_Tp)>\n+    { };\n+\n+  /// alignment_of\n+  template<typename _Tp>\n+    struct alignment_of\n+    : public integral_constant<std::size_t, __alignof__(_Tp)> { };\n+  \n+  /// rank\n+  template<typename>\n+    struct rank\n+    : public integral_constant<std::size_t, 0> { };\n+   \n+  template<typename _Tp, std::size_t _Size>\n+    struct rank<_Tp[_Size]>\n+    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n+\n+  template<typename _Tp>\n+    struct rank<_Tp[]>\n+    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n+\n+  /// extent\n+  template<typename, unsigned _Uint = 0>\n+    struct extent\n+    : public integral_constant<std::size_t, 0> { };\n+  \n+  template<typename _Tp, unsigned _Uint, std::size_t _Size>\n+    struct extent<_Tp[_Size], _Uint>\n+    : public integral_constant<std::size_t,\n+\t\t\t       _Uint == 0 ? _Size : extent<_Tp,\n+\t\t\t\t\t\t\t   _Uint - 1>::value>\n+    { };\n+\n+  template<typename _Tp, unsigned _Uint>\n+    struct extent<_Tp[], _Uint>\n+    : public integral_constant<std::size_t,\n+\t\t\t       _Uint == 0 ? 0 : extent<_Tp,\n+\t\t\t\t\t\t       _Uint - 1>::value>\n+    { };\n+\n+  // relationships between types [4.6].\n+\n+  /// is_same\n+  template<typename, typename>\n+    struct is_same\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct is_same<_Tp, _Tp>\n     : public true_type { };\n \n+  // const-volatile modifications [4.7.1].\n+\n+  /// remove_const\n+  template<typename _Tp>\n+    struct remove_const\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp>\n+    struct remove_const<_Tp const>\n+    { typedef _Tp     type; };\n+  \n+  /// remove_volatile\n+  template<typename _Tp>\n+    struct remove_volatile\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp>\n+    struct remove_volatile<_Tp volatile>\n+    { typedef _Tp     type; };\n+  \n+  /// remove_cv\n+  template<typename _Tp>\n+    struct remove_cv\n+    {\n+      typedef typename\n+      remove_const<typename remove_volatile<_Tp>::type>::type     type;\n+    };\n+  \n+  /// add_const\n+  template<typename _Tp>\n+    struct add_const\n+    { typedef _Tp const     type; };\n+   \n+  /// add_volatile\n+  template<typename _Tp>\n+    struct add_volatile\n+    { typedef _Tp volatile     type; };\n+  \n+  /// add_cv\n+  template<typename _Tp>\n+    struct add_cv\n+    {\n+      typedef typename\n+      add_const<typename add_volatile<_Tp>::type>::type     type;\n+    };\n+\n+  // array modifications [4.7.3].\n+\n+  /// remove_extent\n+  template<typename _Tp>\n+    struct remove_extent\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp, std::size_t _Size>\n+    struct remove_extent<_Tp[_Size]>\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp>\n+    struct remove_extent<_Tp[]>\n+    { typedef _Tp     type; };\n+\n+  /// remove_all_extents\n+  template<typename _Tp>\n+    struct remove_all_extents\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp, std::size_t _Size>\n+    struct remove_all_extents<_Tp[_Size]>\n+    { typedef typename remove_all_extents<_Tp>::type     type; };\n+\n+  template<typename _Tp>\n+    struct remove_all_extents<_Tp[]>\n+    { typedef typename remove_all_extents<_Tp>::type     type; };\n+\n+  // pointer modifications [4.7.4].\n+\n+  template<typename _Tp, typename>\n+    struct __remove_pointer_helper\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp, typename _Up>\n+    struct __remove_pointer_helper<_Tp, _Up*>\n+    { typedef _Up     type; };\n+\n+  /// remove_pointer\n+  template<typename _Tp>\n+    struct remove_pointer\n+    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>\n+    { };\n+\n+  template<typename>\n+    struct remove_reference;\n+\n+  /// add_pointer\n+  template<typename _Tp>\n+    struct add_pointer\n+    { typedef typename remove_reference<_Tp>::type*     type; };\n+\n   template<typename>\n     struct is_reference\n     : public false_type { };\n@@ -112,11 +544,11 @@ namespace tr1\n   template<typename>\n     struct __is_signed_helper\n     : public false_type { };\n-  _DEFINE_SPEC(__is_signed_helper, signed char)\n-  _DEFINE_SPEC(__is_signed_helper, short)\n-  _DEFINE_SPEC(__is_signed_helper, int)\n-  _DEFINE_SPEC(__is_signed_helper, long)\n-  _DEFINE_SPEC(__is_signed_helper, long long)\n+  _DEFINE_SPEC(0, __is_signed_helper, signed char, true)\n+  _DEFINE_SPEC(0, __is_signed_helper, short, true)\n+  _DEFINE_SPEC(0, __is_signed_helper, int, true)\n+  _DEFINE_SPEC(0, __is_signed_helper, long, true)\n+  _DEFINE_SPEC(0, __is_signed_helper, long long, true)\n \n   template<typename _Tp>\n     struct is_signed\n@@ -127,11 +559,11 @@ namespace tr1\n   template<typename>\n     struct __is_unsigned_helper\n     : public false_type { };\n-  _DEFINE_SPEC(__is_unsigned_helper, unsigned char)\n-  _DEFINE_SPEC(__is_unsigned_helper, unsigned short)\n-  _DEFINE_SPEC(__is_unsigned_helper, unsigned int)\n-  _DEFINE_SPEC(__is_unsigned_helper, unsigned long)\n-  _DEFINE_SPEC(__is_unsigned_helper, unsigned long long)\n+  _DEFINE_SPEC(0, __is_unsigned_helper, unsigned char, true)\n+  _DEFINE_SPEC(0, __is_unsigned_helper, unsigned short, true)\n+  _DEFINE_SPEC(0, __is_unsigned_helper, unsigned int, true)\n+  _DEFINE_SPEC(0, __is_unsigned_helper, unsigned long, true)\n+  _DEFINE_SPEC(0, __is_unsigned_helper, unsigned long long, true)\n \n   template<typename _Tp>\n     struct is_unsigned\n@@ -243,6 +675,9 @@ namespace tr1\n       };\n     };\n \n+#undef _DEFINE_SPEC_0_HELPER\n+#undef _DEFINE_SPEC_1_HELPER\n+#undef _DEFINE_SPEC_2_HELPER\n #undef _DEFINE_SPEC\n }\n }"}, {"sha": "04ff67a3f8f061dbe736189f1767762e4d5c8cd9", "filename": "libstdc++-v3/include/tr1/utility", "status": "modified", "additions": 67, "deletions": 18, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Futility?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -1,6 +1,7 @@\n // TR1 utility -*- C++ -*-\n \n-// Copyright (C) 2004, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2005, 2006, 2007, 2008. 2009, 2010\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,26 +32,74 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <bits/c++config.h>\n #include <bits/stl_relops.h>\n #include <bits/stl_pair.h>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/utility>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/utility>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n+namespace std\n+{\n+namespace tr1\n+{\n+  template<class _Tp>\n+    class tuple_size;\n+\n+  template<int _Int, class _Tp>\n+    class tuple_element;\n+\n+   // Various functions which give std::pair a tuple-like interface.\n+  template<class _Tp1, class _Tp2>\n+    struct tuple_size<std::pair<_Tp1, _Tp2> >\n+    { static const int value = 2; };\n+\n+  template<class _Tp1, class _Tp2>\n+    const int\n+    tuple_size<std::pair<_Tp1, _Tp2> >::value;\n+\n+  template<class _Tp1, class _Tp2>\n+    struct tuple_element<0, std::pair<_Tp1, _Tp2> >\n+    { typedef _Tp1 type; };\n+ \n+  template<class _Tp1, class _Tp2>\n+    struct tuple_element<1, std::pair<_Tp1, _Tp2> >\n+    { typedef _Tp2 type; };\n+\n+  template<int _Int>\n+    struct __pair_get;\n+\n+  template<>\n+    struct __pair_get<0>\n+    {\n+      template<typename _Tp1, typename _Tp2>\n+      static _Tp1& __get(std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.first; }\n+\n+      template<typename _Tp1, typename _Tp2>\n+      static const _Tp1& __const_get(const std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.first; }\n+    };\n+\n+  template<>\n+    struct __pair_get<1>\n+    {\n+      template<typename _Tp1, typename _Tp2>\n+      static _Tp2& __get(std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.second; }\n+\n+      template<typename _Tp1, typename _Tp2>\n+      static const _Tp2& __const_get(const std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.second; }\n+    };\n+\n+  template<int _Int, class _Tp1, class _Tp2>\n+    inline typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n+    get(std::pair<_Tp1, _Tp2>& __in)\n+    { return __pair_get<_Int>::__get(__in); }\n+\n+  template<int _Int, class _Tp1, class _Tp2>\n+    inline const typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n+    get(const std::pair<_Tp1, _Tp2>& __in)\n+    { return __pair_get<_Int>::__const_get(__in); }\n+}\n+}\n \n #endif // _GLIBCXX_TR1_UTILITY"}, {"sha": "a4c20edf7266e785811a9fa21f5ebb7ea2a4d115", "filename": "libstdc++-v3/include/tr1_impl/array", "status": "removed", "additions": 0, "deletions": 291, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,291 +0,0 @@\n-// class template array -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/array\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-  /**\n-   *  @brief A standard container for storing a fixed size sequence of elements.\n-   *\n-   *  @ingroup sequences\n-   *\n-   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n-   *  <a href=\"tables.html#66\">reversible container</a>, and a\n-   *  <a href=\"tables.html#67\">sequence</a>.\n-   *\n-   *  Sets support random access iterators.\n-   *\n-   *  @param  Tp  Type of element. Required to be a complete type.\n-   *  @param  N  Number of elements.\n-  */\n-  template<typename _Tp, std::size_t _Nm>\n-    struct array\n-    {\n-      typedef _Tp \t    \t\t\t      value_type;\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      typedef _Tp*                                    pointer;\n-      typedef const _Tp*                              const_pointer;\n-#endif\n-      typedef value_type&                   \t      reference;\n-      typedef const value_type&             \t      const_reference;\n-      typedef value_type*          \t\t      iterator;\n-      typedef const value_type*\t\t\t      const_iterator;\n-      typedef std::size_t                    \t      size_type;\n-      typedef std::ptrdiff_t                   \t      difference_type;\n-      typedef std::reverse_iterator<iterator>\t      reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;\n-\n-      // Support for zero-sized arrays mandatory.\n-      value_type _M_instance[_Nm ? _Nm : 1];\n-\n-      // No explicit construct/copy/destroy for aggregate type.\n-\n-      void\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      // DR 776.\n-      fill(const value_type& __u)\n-#else\n-      assign(const value_type& __u)\n-#endif\n-      { std::fill_n(begin(), size(), __u); }\n-\n-      void\n-      swap(array& __other)\n-      { std::swap_ranges(begin(), end(), __other.begin()); }\n-\n-      // Iterators.\n-      iterator\n-      begin()\n-      { return iterator(std::__addressof(_M_instance[0])); }\n-\n-      const_iterator\n-      begin() const \n-      { return const_iterator(std::__addressof(_M_instance[0])); }\n-\n-      iterator\n-      end()\n-      { return iterator(std::__addressof(_M_instance[_Nm])); }\n-\n-      const_iterator\n-      end() const\n-      { return const_iterator(std::__addressof(_M_instance[_Nm])); }\n-\n-      reverse_iterator \n-      rbegin()\n-      { return reverse_iterator(end()); }\n-\n-      const_reverse_iterator \n-      rbegin() const\n-      { return const_reverse_iterator(end()); }\n-\n-      reverse_iterator \n-      rend()\n-      { return reverse_iterator(begin()); }\n-\n-      const_reverse_iterator \n-      rend() const\n-      { return const_reverse_iterator(begin()); }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      const_iterator\n-      cbegin() const \n-      { return const_iterator(std::__addressof(_M_instance[0])); }\n-\n-      const_iterator\n-      cend() const\n-      { return const_iterator(std::__addressof(_M_instance[_Nm])); }\n-\n-      const_reverse_iterator \n-      crbegin() const\n-      { return const_reverse_iterator(end()); }\n-\n-      const_reverse_iterator \n-      crend() const\n-      { return const_reverse_iterator(begin()); }\n-#endif\n-\n-      // Capacity.\n-      _GLIBCXX_CONSTEXPR size_type \n-      size() const { return _Nm; }\n-\n-      _GLIBCXX_CONSTEXPR size_type \n-      max_size() const { return _Nm; }\n-\n-      _GLIBCXX_CONSTEXPR bool \n-      empty() const { return size() == 0; }\n-\n-      // Element access.\n-      reference\n-      operator[](size_type __n)\n-      { return _M_instance[__n]; }\n-\n-      const_reference\n-      operator[](size_type __n) const\n-      { return _M_instance[__n]; }\n-\n-      reference\n-      at(size_type __n)\n-      {\n-\tif (__n >= _Nm)\n-\t  std::__throw_out_of_range(__N(\"array::at\"));\n-\treturn _M_instance[__n];\n-      }\n-\n-      const_reference\n-      at(size_type __n) const\n-      {\n-\tif (__n >= _Nm)\n-\t  std::__throw_out_of_range(__N(\"array::at\"));\n-\treturn _M_instance[__n];\n-      }\n-\n-      reference \n-      front()\n-      { return *begin(); }\n-\n-      const_reference \n-      front() const\n-      { return *begin(); }\n-\n-      reference \n-      back()\n-      { return _Nm ? *(end() - 1) : *end(); }\n-\n-      const_reference \n-      back() const\n-      { return _Nm ? *(end() - 1) : *end(); }\n-\n-      _Tp*\n-      data()\n-      { return std::__addressof(_M_instance[0]); }\n-\n-      const _Tp*\n-      data() const\n-      { return std::__addressof(_M_instance[0]); }\n-    };\n-\n-  // Array comparisons.\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool \n-    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n-    { return std::equal(__one.begin(), __one.end(), __two.begin()); }\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool\n-    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n-    { return !(__one == __two); }\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool\n-    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)\n-    { \n-      return std::lexicographical_compare(__a.begin(), __a.end(),\n-\t\t\t\t\t  __b.begin(), __b.end()); \n-    }\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool\n-    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n-    { return __two < __one; }\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool\n-    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n-    { return !(__one > __two); }\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool\n-    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n-    { return !(__one < __two); }\n-\n-  // Specialized algorithms [6.2.2.2].\n-  template<typename _Tp, std::size_t _Nm>\n-    inline void\n-    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)\n-    { __one.swap(__two); }\n-\n-  // Tuple interface to class template array [6.2.2.5].\n-\n-  /// tuple_size\n-  template<typename _Tp> \n-    class tuple_size;\n-\n-  /// tuple_element\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  template<std::size_t _Int, typename _Tp>\n-#else\n-  template<int _Int, typename _Tp>\n-#endif\n-    class tuple_element;\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    struct tuple_size<array<_Tp, _Nm> >\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-    { static const std::size_t value = _Nm; };\n-#else\n-    { static const int value = _Nm; };\n-#endif\n-\n-  template<typename _Tp, std::size_t _Nm>\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-    const std::size_t\n-#else\n-    const int\n-#endif\n-    tuple_size<array<_Tp, _Nm> >::value;  \n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n-#else\n-  template<int _Int, typename _Tp, std::size_t _Nm>\n-#endif\n-    struct tuple_element<_Int, array<_Tp, _Nm> >\n-    { typedef _Tp type; };\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n-#else\n-  template<int _Int, typename _Tp, std::size_t _Nm>\n-#endif\n-    inline _Tp&\n-    get(array<_Tp, _Nm>& __arr)\n-    { return __arr[_Int]; }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n-#else\n-  template<int _Int, typename _Tp, std::size_t _Nm>\n-#endif\n-    inline const _Tp&\n-    get(const array<_Tp, _Nm>& __arr)\n-    { return __arr[_Int]; }\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}"}, {"sha": "11a2d052dfc569f59c4389d19884384fd0ecbf71", "filename": "libstdc++-v3/include/tr1_impl/boost_sp_counted_base.h", "status": "removed", "additions": 0, "deletions": 254, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_sp_counted_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_sp_counted_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_sp_counted_base.h?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,254 +0,0 @@\n-// <tr1_impl/boost_sp_counted_base.h> -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-//  shared_count.hpp\n-//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n-\n-//  shared_ptr.hpp\n-//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n-//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n-\n-//  weak_ptr.hpp\n-//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n-\n-//  enable_shared_from_this.hpp\n-//  Copyright (C) 2002 Peter Dimov\n-\n-// Distributed under the Boost Software License, Version 1.0. (See\n-// accompanying file LICENSE_1_0.txt or copy at\n-// http://www.boost.org/LICENSE_1_0.txt)\n-\n-// GCC Note:  based on version 1.32.0 of the Boost library.\n-\n-/** @file tr1_impl/boost_sp_counted_base.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n- /**\n-   *  @brief  Exception possibly thrown by @c shared_ptr.\n-   *  @ingroup exceptions\n-   */\n-  class bad_weak_ptr : public std::exception\n-  {\n-  public:\n-    virtual char const*\n-    what() const throw()\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-    { return \"std::bad_weak_ptr\"; }\n-#else\n-    { return \"tr1::bad_weak_ptr\"; }\n-#endif\n-  };\n-\n-  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n-  inline void\n-  __throw_bad_weak_ptr()\n-  {\n-#if __EXCEPTIONS\n-    throw bad_weak_ptr();\n-#else\n-    __builtin_abort();\n-#endif\n-  }\n-\n-  using __gnu_cxx::_Lock_policy;\n-  using __gnu_cxx::__default_lock_policy;\n-  using __gnu_cxx::_S_single;\n-  using __gnu_cxx::_S_mutex;\n-  using __gnu_cxx::_S_atomic;\n-\n-  // Empty helper class except when the template argument is _S_mutex.\n-  template<_Lock_policy _Lp>\n-    class _Mutex_base\n-    {\n-    protected:\n-      // The atomic policy uses fully-fenced builtins, single doesn't care.\n-      enum { _S_need_barriers = 0 };\n-    };\n-\n-  template<>\n-    class _Mutex_base<_S_mutex>\n-    : public __gnu_cxx::__mutex\n-    {\n-    protected:\n-      // This policy is used when atomic builtins are not available.\n-      // The replacement atomic operations might not have the necessary\n-      // memory barriers.\n-      enum { _S_need_barriers = 1 };\n-    };\n-\n-  template<_Lock_policy _Lp = __default_lock_policy>\n-    class _Sp_counted_base\n-    : public _Mutex_base<_Lp>\n-    {\n-    public:  \n-      _Sp_counted_base()\n-      : _M_use_count(1), _M_weak_count(1) { }\n-      \n-      virtual\n-      ~_Sp_counted_base() // nothrow \n-      { }\n-  \n-      // Called when _M_use_count drops to zero, to release the resources\n-      // managed by *this.\n-      virtual void\n-      _M_dispose() = 0; // nothrow\n-      \n-      // Called when _M_weak_count drops to zero.\n-      virtual void\n-      _M_destroy() // nothrow\n-      { delete this; }\n-      \n-      virtual void*\n-      _M_get_deleter(const std::type_info&) = 0;\n-\n-      void\n-      _M_add_ref_copy()\n-      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }\n-  \n-      void\n-      _M_add_ref_lock();\n-      \n-      void\n-      _M_release() // nothrow\n-      {\n-        // Be race-detector-friendly.  For more info see bits/c++config.\n-        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);\n-\tif (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)\n-\t  {\n-            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);\n-\t    _M_dispose();\n-\t    // There must be a memory barrier between dispose() and destroy()\n-\t    // to ensure that the effects of dispose() are observed in the\n-\t    // thread that runs destroy().\n-\t    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html\n-\t    if (_Mutex_base<_Lp>::_S_need_barriers)\n-\t      {\n-\t        _GLIBCXX_READ_MEM_BARRIER;\n-\t        _GLIBCXX_WRITE_MEM_BARRIER;\n-\t      }\n-\n-            // Be race-detector-friendly.  For more info see bits/c++config.\n-            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);\n-\t    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,\n-\t\t\t\t\t\t       -1) == 1)\n-              {\n-                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);\n-\t        _M_destroy();\n-              }\n-\t  }\n-      }\n-  \n-      void\n-      _M_weak_add_ref() // nothrow\n-      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }\n-\n-      void\n-      _M_weak_release() // nothrow\n-      {\n-        // Be race-detector-friendly. For more info see bits/c++config.\n-        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);\n-\tif (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)\n-\t  {\n-            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);\n-\t    if (_Mutex_base<_Lp>::_S_need_barriers)\n-\t      {\n-\t        // See _M_release(),\n-\t        // destroy() must observe results of dispose()\n-\t        _GLIBCXX_READ_MEM_BARRIER;\n-\t        _GLIBCXX_WRITE_MEM_BARRIER;\n-\t      }\n-\t    _M_destroy();\n-\t  }\n-      }\n-  \n-      long\n-      _M_get_use_count() const // nothrow\n-      {\n-        // No memory barrier is used here so there is no synchronization\n-        // with other threads.\n-        return const_cast<const volatile _Atomic_word&>(_M_use_count);\n-      }\n-\n-    private:  \n-      _Sp_counted_base(_Sp_counted_base const&);\n-      _Sp_counted_base& operator=(_Sp_counted_base const&);\n-\n-      _Atomic_word  _M_use_count;     // #shared\n-      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)\n-    };\n-\n-  template<>\n-    inline void\n-    _Sp_counted_base<_S_single>::\n-    _M_add_ref_lock()\n-    {\n-      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n-\t{\n-\t  _M_use_count = 0;\n-\t  __throw_bad_weak_ptr();\n-\t}\n-    }\n-\n-  template<>\n-    inline void\n-    _Sp_counted_base<_S_mutex>::\n-    _M_add_ref_lock()\n-    {\n-      __gnu_cxx::__scoped_lock sentry(*this);\n-      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n-\t{\n-\t  _M_use_count = 0;\n-\t  __throw_bad_weak_ptr();\n-\t}\n-    }\n-\n-  template<> \n-    inline void\n-    _Sp_counted_base<_S_atomic>::\n-    _M_add_ref_lock()\n-    {\n-      // Perform lock-free add-if-not-zero operation.\n-      _Atomic_word __count;\n-      do\n-\t{\n-\t  __count = _M_use_count;\n-\t  if (__count == 0)\n-\t    __throw_bad_weak_ptr();\n-\t  \n-\t  // Replace the current counter value with the old value + 1, as\n-\t  // long as it's not changed meanwhile. \n-\t}\n-      while (!__sync_bool_compare_and_swap(&_M_use_count, __count,\n-\t\t\t\t\t   __count + 1));\n-    }\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}"}, {"sha": "c76d38c8782785bf879bd3d677a4bfe1b8261600", "filename": "libstdc++-v3/include/tr1_impl/cctype", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcctype?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,43 +0,0 @@\n-// TR1 cctype -*- C++ -*-\n-\n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/cctype\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#if _GLIBCXX_USE_C99_CTYPE_TR1\n-\n-#undef isblank\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-  using ::isblank;\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}\n-\n-#endif"}, {"sha": "3078c7de64a361c57f6760251c5198b9062b41e6", "filename": "libstdc++-v3/include/tr1_impl/cfenv", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcfenv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcfenv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcfenv?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,70 +0,0 @@\n-// TR1 cfenv -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/cfenv\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#if _GLIBCXX_USE_C99_FENV_TR1\n-\n-#undef feclearexcept\n-#undef fegetexceptflag\n-#undef feraiseexcept\n-#undef fesetexceptflag\n-#undef fetestexcept\n-#undef fegetround\n-#undef fesetround\n-#undef fegetenv\n-#undef feholdexcept\n-#undef fesetenv\n-#undef feupdateenv\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-  // types\n-  using ::fenv_t;\n-  using ::fexcept_t;\n-\n-  // functions\n-  using ::feclearexcept;\n-  using ::fegetexceptflag;\n-  using ::feraiseexcept;\n-  using ::fesetexceptflag;\n-  using ::fetestexcept;\n-\n-  using ::fegetround;\n-  using ::fesetround;\n-\n-  using ::fegetenv;\n-  using ::feholdexcept;\n-  using ::fesetenv;\n-  using ::feupdateenv;\n-  \n-_GLIBCXX_END_NAMESPACE_TR1\n-}\n-\n-#endif"}, {"sha": "4a0f9f19dec2ab0512f86117f03611c310ddd54e", "filename": "libstdc++-v3/include/tr1_impl/cinttypes", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcinttypes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcinttypes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcinttypes?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,64 +0,0 @@\n-// TR1 cinttypes -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/cinttypes\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#if _GLIBCXX_USE_C99_INTTYPES_TR1\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-  // types\n-  using ::imaxdiv_t;\n-\n-  // functions\n-  using ::imaxabs;\n-\n-  // May collide with _Longlong abs(_Longlong), and is not described\n-  // anywhere outside the synopsis.  Likely, a defect.\n-  //\n-  // intmax_t abs(intmax_t)\n-\n-  using ::imaxdiv;\n-\n-  // Likewise, with lldiv_t div(_Longlong, _Longlong).\n-  //\n-  // imaxdiv_t div(intmax_t, intmax_t)\n-\n-  using ::strtoimax;\n-  using ::strtoumax;\n-\n-#if defined(_GLIBCXX_USE_WCHAR_T) && _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1\n-  using ::wcstoimax;\n-  using ::wcstoumax;\n-#endif\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}\n-\n-#endif"}, {"sha": "cf460dd7c9532c1f467cda49dcf22455e9f1b9a9", "filename": "libstdc++-v3/include/tr1_impl/cmath", "status": "removed", "additions": 0, "deletions": 996, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcmath?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,996 +0,0 @@\n-// TR1 cmath -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/cmath\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#if _GLIBCXX_USE_C99_MATH_TR1\n-\n-#undef acosh\n-#undef acoshf\n-#undef acoshl\n-#undef asinh\n-#undef asinhf\n-#undef asinhl\n-#undef atanh\n-#undef atanhf\n-#undef atanhl\n-#undef cbrt\n-#undef cbrtf\n-#undef cbrtl\n-#undef copysign\n-#undef copysignf\n-#undef copysignl\n-#undef erf\n-#undef erff\n-#undef erfl\n-#undef erfc\n-#undef erfcf\n-#undef erfcl\n-#undef exp2\n-#undef exp2f\n-#undef exp2l\n-#undef expm1\n-#undef expm1f\n-#undef expm1l\n-#undef fdim\n-#undef fdimf\n-#undef fdiml\n-#undef fma\n-#undef fmaf\n-#undef fmal\n-#undef fmax\n-#undef fmaxf\n-#undef fmaxl\n-#undef fmin\n-#undef fminf\n-#undef fminl\n-#undef hypot\n-#undef hypotf\n-#undef hypotl\n-#undef ilogb\n-#undef ilogbf\n-#undef ilogbl\n-#undef lgamma\n-#undef lgammaf\n-#undef lgammal\n-#undef llrint\n-#undef llrintf\n-#undef llrintl\n-#undef llround\n-#undef llroundf\n-#undef llroundl\n-#undef log1p\n-#undef log1pf\n-#undef log1pl\n-#undef log2\n-#undef log2f\n-#undef log2l\n-#undef logb\n-#undef logbf\n-#undef logbl\n-#undef lrint\n-#undef lrintf\n-#undef lrintl\n-#undef lround\n-#undef lroundf\n-#undef lroundl\n-#undef nan\n-#undef nanf\n-#undef nanl\n-#undef nearbyint\n-#undef nearbyintf\n-#undef nearbyintl\n-#undef nextafter\n-#undef nextafterf\n-#undef nextafterl\n-#undef nexttoward\n-#undef nexttowardf\n-#undef nexttowardl\n-#undef remainder\n-#undef remainderf\n-#undef remainderl\n-#undef remquo\n-#undef remquof\n-#undef remquol\n-#undef rint\n-#undef rintf\n-#undef rintl\n-#undef round\n-#undef roundf\n-#undef roundl\n-#undef scalbln\n-#undef scalblnf\n-#undef scalblnl\n-#undef scalbn\n-#undef scalbnf\n-#undef scalbnl\n-#undef tgamma\n-#undef tgammaf\n-#undef tgammal\n-#undef trunc\n-#undef truncf\n-#undef truncl\n-\n-#endif\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-#if _GLIBCXX_USE_C99_MATH_TR1\n-\n-  // types\n-  using ::double_t;\n-  using ::float_t;\n-\n-  // functions\n-  using ::acosh;\n-  using ::acoshf;\n-  using ::acoshl;\n-\n-  using ::asinh;\n-  using ::asinhf;\n-  using ::asinhl;\n-\n-  using ::atanh;\n-  using ::atanhf;\n-  using ::atanhl;\n-\n-  using ::cbrt;\n-  using ::cbrtf;\n-  using ::cbrtl;\n-\n-  using ::copysign;\n-  using ::copysignf;\n-  using ::copysignl;\n-\n-  using ::erf;\n-  using ::erff;\n-  using ::erfl;\n-\n-  using ::erfc;\n-  using ::erfcf;\n-  using ::erfcl;\n-\n-  using ::exp2;\n-  using ::exp2f;\n-  using ::exp2l;\n-\n-  using ::expm1;\n-  using ::expm1f;\n-  using ::expm1l;\n-\n-  using ::fdim;\n-  using ::fdimf;\n-  using ::fdiml;\n-\n-  using ::fma;\n-  using ::fmaf;\n-  using ::fmal;\n-\n-  using ::fmax;\n-  using ::fmaxf;\n-  using ::fmaxl;\n-\n-  using ::fmin;\n-  using ::fminf;\n-  using ::fminl;\n-\n-  using ::hypot;\n-  using ::hypotf;\n-  using ::hypotl;\n-\n-  using ::ilogb;\n-  using ::ilogbf;\n-  using ::ilogbl;\n-\n-  using ::lgamma;\n-  using ::lgammaf;\n-  using ::lgammal;\n-\n-  using ::llrint;\n-  using ::llrintf;\n-  using ::llrintl;\n-\n-  using ::llround;\n-  using ::llroundf;\n-  using ::llroundl;\n-\n-  using ::log1p;\n-  using ::log1pf;\n-  using ::log1pl;\n-\n-  using ::log2;\n-  using ::log2f;\n-  using ::log2l;\n-\n-  using ::logb;\n-  using ::logbf;\n-  using ::logbl;\n-\n-  using ::lrint;\n-  using ::lrintf;\n-  using ::lrintl;\n-\n-  using ::lround;\n-  using ::lroundf;\n-  using ::lroundl;\n-\n-  using ::nan;\n-  using ::nanf;\n-  using ::nanl;\n-\n-  using ::nearbyint;\n-  using ::nearbyintf;\n-  using ::nearbyintl;\n-\n-  using ::nextafter;\n-  using ::nextafterf;\n-  using ::nextafterl;\n-\n-  using ::nexttoward;\n-  using ::nexttowardf;\n-  using ::nexttowardl;\n-\n-  using ::remainder;\n-  using ::remainderf;\n-  using ::remainderl;\n-\n-  using ::remquo;\n-  using ::remquof;\n-  using ::remquol;\n-\n-  using ::rint;\n-  using ::rintf;\n-  using ::rintl;\n-\n-  using ::round;\n-  using ::roundf;\n-  using ::roundl;\n-\n-  using ::scalbln;\n-  using ::scalblnf;\n-  using ::scalblnl;\n-\n-  using ::scalbn;\n-  using ::scalbnf;\n-  using ::scalbnl;\n-\n-  using ::tgamma;\n-  using ::tgammaf;\n-  using ::tgammal;\n-\n-  using ::trunc;\n-  using ::truncf;\n-  using ::truncl;\n-\n-#endif\n-\n-#if _GLIBCXX_USE_C99_MATH\n-#if !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC\n-\n-  /// Function template definitions [8.16.3].\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    fpclassify(_Tp __f)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n-\t\t\t\t  FP_SUBNORMAL, FP_ZERO, __type(__f));\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    isfinite(_Tp __f)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_isfinite(__type(__f));\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    isinf(_Tp __f)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_isinf(__type(__f));\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    isnan(_Tp __f)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_isnan(__type(__f));\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    isnormal(_Tp __f)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_isnormal(__type(__f));\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    signbit(_Tp __f)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_signbit(__type(__f));\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    isgreater(_Tp __f1, _Tp __f2)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_isgreater(__type(__f1), __type(__f2));\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    isgreaterequal(_Tp __f1, _Tp __f2)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_isgreaterequal(__type(__f1), __type(__f2));\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    isless(_Tp __f1, _Tp __f2)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_isless(__type(__f1), __type(__f2));\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    islessequal(_Tp __f1, _Tp __f2)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_islessequal(__type(__f1), __type(__f2));\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    islessgreater(_Tp __f1, _Tp __f2)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_islessgreater(__type(__f1), __type(__f2));\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n-\t\t\t\t\t   int>::__type\n-    isunordered(_Tp __f1, _Tp __f2)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __builtin_isunordered(__type(__f1), __type(__f2));\n-    }\n-\n-#endif\n-#endif\n-\n-#if _GLIBCXX_USE_C99_MATH_TR1\n-\n-  /// Additional overloads [8.16.4].\n-  using std::acos;\n-\n-  inline float\n-  acosh(float __x)\n-  { return __builtin_acoshf(__x); }\n-\n-  inline long double\n-  acosh(long double __x)\n-  { return __builtin_acoshl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    acosh(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return acosh(__type(__x));\n-    }\n-\n-  using std::asin;\n-\n-  inline float\n-  asinh(float __x)\n-  { return __builtin_asinhf(__x); }\n-\n-  inline long double\n-  asinh(long double __x)\n-  { return __builtin_asinhl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    asinh(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return asinh(__type(__x));\n-    }\n-\n-  using std::atan;\n-  using std::atan2;\n-\n-  inline float\n-  atanh(float __x)\n-  { return __builtin_atanhf(__x); }\n-\n-  inline long double\n-  atanh(long double __x)\n-  { return __builtin_atanhl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    atanh(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return atanh(__type(__x));\n-    }\n-\n-  inline float\n-  cbrt(float __x)\n-  { return __builtin_cbrtf(__x); }\n-\n-  inline long double\n-  cbrt(long double __x)\n-  { return __builtin_cbrtl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    cbrt(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return cbrt(__type(__x));\n-    }\n-\n-  using std::ceil;\n-\n-  inline float\n-  copysign(float __x, float __y)\n-  { return __builtin_copysignf(__x, __y); }\n-\n-  inline long double\n-  copysign(long double __x, long double __y)\n-  { return __builtin_copysignl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n-    copysign(_Tp __x, _Up __y)\n-    {\n-      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n-      return copysign(__type(__x), __type(__y));\n-    }\n-\n-  using std::cos;\n-  using std::cosh;  \n-\n-  inline float\n-  erf(float __x)\n-  { return __builtin_erff(__x); }\n-\n-  inline long double\n-  erf(long double __x)\n-  { return __builtin_erfl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    erf(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return erf(__type(__x));\n-    }\n-\n-  inline float\n-  erfc(float __x)\n-  { return __builtin_erfcf(__x); }\n-\n-  inline long double\n-  erfc(long double __x)\n-  { return __builtin_erfcl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    erfc(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return erfc(__type(__x));\n-    }\n-\n-  using std::exp;\n-\n-  inline float\n-  exp2(float __x)\n-  { return __builtin_exp2f(__x); }\n-\n-  inline long double\n-  exp2(long double __x)\n-  { return __builtin_exp2l(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    exp2(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return exp2(__type(__x));\n-    }\n-\n-  inline float\n-  expm1(float __x)\n-  { return __builtin_expm1f(__x); }\n-\n-  inline long double\n-  expm1(long double __x)\n-  { return __builtin_expm1l(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    expm1(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return expm1(__type(__x));\n-    }\n-\n-  using std::fabs;\n-\n-  inline float\n-  fdim(float __x, float __y)\n-  { return __builtin_fdimf(__x, __y); }\n-\n-  inline long double\n-  fdim(long double __x, long double __y)\n-  { return __builtin_fdiml(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n-    fdim(_Tp __x, _Up __y)\n-    {\n-      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n-      return fdim(__type(__x), __type(__y));\n-    }\n-\n-  using std::floor;\n-\n-  inline float\n-  fma(float __x, float __y, float __z)\n-  { return __builtin_fmaf(__x, __y, __z); }\n-\n-  inline long double\n-  fma(long double __x, long double __y, long double __z)\n-  { return __builtin_fmal(__x, __y, __z); }\n-\n-  template<typename _Tp, typename _Up, typename _Vp>\n-    inline typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type\n-    fma(_Tp __x, _Up __y, _Vp __z)\n-    {\n-      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;\n-      return fma(__type(__x), __type(__y), __type(__z));\n-    }\n-\n-  inline float\n-  fmax(float __x, float __y)\n-  { return __builtin_fmaxf(__x, __y); }\n-\n-  inline long double\n-  fmax(long double __x, long double __y)\n-  { return __builtin_fmaxl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n-    fmax(_Tp __x, _Up __y)\n-    {\n-      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n-      return fmax(__type(__x), __type(__y));\n-    }\n-\n-  inline float\n-  fmin(float __x, float __y)\n-  { return __builtin_fminf(__x, __y); }\n-\n-  inline long double\n-  fmin(long double __x, long double __y)\n-  { return __builtin_fminl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n-    fmin(_Tp __x, _Up __y)\n-    {\n-      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n-      return fmin(__type(__x), __type(__y));\n-    }\n-\n-  using std::fmod;\n-  using std::frexp;\n-\n-  inline float\n-  hypot(float __x, float __y)\n-  { return __builtin_hypotf(__x, __y); }\n-\n-  inline long double\n-  hypot(long double __x, long double __y)\n-  { return __builtin_hypotl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n-    hypot(_Tp __x, _Up __y)\n-    {\n-      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n-      return hypot(__type(__x), __type(__y));\n-    }\n-\n-  inline int\n-  ilogb(float __x)\n-  { return __builtin_ilogbf(__x); }\n-\n-  inline int\n-  ilogb(long double __x)\n-  { return __builtin_ilogbl(__x); }\n-\n-  template<typename _Tp>\n-    inline int\n-    ilogb(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return ilogb(__type(__x));\n-    }\n-\n-  using std::ldexp;\n-\n-  inline float\n-  lgamma(float __x)\n-  { return __builtin_lgammaf(__x); }\n-\n-  inline long double\n-  lgamma(long double __x)\n-  { return __builtin_lgammal(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    lgamma(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return lgamma(__type(__x));\n-    }\n-\n-  inline long long\n-  llrint(float __x)\n-  { return __builtin_llrintf(__x); }\n-\n-  inline long long\n-  llrint(long double __x)\n-  { return __builtin_llrintl(__x); }\n-\n-  template<typename _Tp>\n-    inline long long\n-    llrint(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return llrint(__type(__x));\n-    }\n-\n-  inline long long\n-  llround(float __x)\n-  { return __builtin_llroundf(__x); }\n-\n-  inline long long\n-  llround(long double __x)\n-  { return __builtin_llroundl(__x); }\n-\n-  template<typename _Tp>\n-    inline long long\n-    llround(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return llround(__type(__x));\n-    }\n-\n-  using std::log;\n-  using std::log10;\n-\n-  inline float\n-  log1p(float __x)\n-  { return __builtin_log1pf(__x); }\n-\n-  inline long double\n-  log1p(long double __x)\n-  { return __builtin_log1pl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    log1p(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return log1p(__type(__x));\n-    }\n-\n-  // DR 568.\n-  inline float\n-  log2(float __x)\n-  { return __builtin_log2f(__x); }\n-\n-  inline long double\n-  log2(long double __x)\n-  { return __builtin_log2l(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    log2(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return log2(__type(__x));\n-    }\n-\n-  inline float\n-  logb(float __x)\n-  { return __builtin_logbf(__x); }\n-\n-  inline long double\n-  logb(long double __x)\n-  { return __builtin_logbl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    logb(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return logb(__type(__x));\n-    }\n-\n-  inline long\n-  lrint(float __x)\n-  { return __builtin_lrintf(__x); }\n-\n-  inline long\n-  lrint(long double __x)\n-  { return __builtin_lrintl(__x); }\n-\n-  template<typename _Tp>\n-    inline long\n-    lrint(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return lrint(__type(__x));\n-    }\n-\n-  inline long\n-  lround(float __x)\n-  { return __builtin_lroundf(__x); }\n-\n-  inline long\n-  lround(long double __x)\n-  { return __builtin_lroundl(__x); }\n-\n-  template<typename _Tp>\n-    inline long\n-    lround(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return lround(__type(__x));\n-    }\n-\n-  inline float\n-  nearbyint(float __x)\n-  { return __builtin_nearbyintf(__x); }\n-\n-  inline long double\n-  nearbyint(long double __x)\n-  { return __builtin_nearbyintl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    nearbyint(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return nearbyint(__type(__x));\n-    }\n-\n-  inline float\n-  nextafter(float __x, float __y)\n-  { return __builtin_nextafterf(__x, __y); }\n-\n-  inline long double\n-  nextafter(long double __x, long double __y)\n-  { return __builtin_nextafterl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n-    nextafter(_Tp __x, _Up __y)\n-    {\n-      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n-      return nextafter(__type(__x), __type(__y));\n-    }\n-\n-  inline float\n-  nexttoward(float __x, long double __y)\n-  { return __builtin_nexttowardf(__x, __y); }\n-\n-  inline long double\n-  nexttoward(long double __x, long double __y)\n-  { return __builtin_nexttowardl(__x, __y); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type\n-    nexttoward(_Tp __x, long double __y)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return nexttoward(__type(__x), __y);\n-    }\n-\n-  // DR 550. What should the return type of pow(float,int) be?\n-  // NB: C++0x and TR1 != C++03.\n-  //   using std::pow;\n-\n-  inline float\n-  remainder(float __x, float __y)\n-  { return __builtin_remainderf(__x, __y); }\n-\n-  inline long double\n-  remainder(long double __x, long double __y)\n-  { return __builtin_remainderl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n-    remainder(_Tp __x, _Up __y)\n-    {\n-      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n-      return remainder(__type(__x), __type(__y));\n-    }\n-\n-  inline float\n-  remquo(float __x, float __y, int* __pquo)\n-  { return __builtin_remquof(__x, __y, __pquo); }\n-\n-  inline long double\n-  remquo(long double __x, long double __y, int* __pquo)\n-  { return __builtin_remquol(__x, __y, __pquo); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n-    remquo(_Tp __x, _Up __y, int* __pquo)\n-    {\n-      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n-      return remquo(__type(__x), __type(__y), __pquo);\n-    }\n-\n-  inline float\n-  rint(float __x)\n-  { return __builtin_rintf(__x); }\n-\n-  inline long double\n-  rint(long double __x)\n-  { return __builtin_rintl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type\n-    rint(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return rint(__type(__x));\n-    }\n-\n-  inline float\n-  round(float __x)\n-  { return __builtin_roundf(__x); }\n-\n-  inline long double\n-  round(long double __x)\n-  { return __builtin_roundl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type\n-    round(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return round(__type(__x));\n-    }\n-\n-  inline float\n-  scalbln(float __x, long __ex)\n-  { return __builtin_scalblnf(__x, __ex); }\n-\n-  inline long double\n-  scalbln(long double __x, long __ex)\n-  { return __builtin_scalblnl(__x, __ex); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    scalbln(_Tp __x, long __ex)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return scalbln(__type(__x), __ex);\n-    }\n- \n-  inline float\n-  scalbn(float __x, int __ex)\n-  { return __builtin_scalbnf(__x, __ex); }\n-\n-  inline long double\n-  scalbn(long double __x, int __ex)\n-  { return __builtin_scalbnl(__x, __ex); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    scalbn(_Tp __x, int __ex)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return scalbn(__type(__x), __ex);\n-    }\n-\n-  using std::sin;\n-  using std::sinh;\n-  using std::sqrt;\n-  using std::tan;\n-  using std::tanh;\n-\n-  inline float\n-  tgamma(float __x)\n-  { return __builtin_tgammaf(__x); }\n-\n-  inline long double\n-  tgamma(long double __x)\n-  { return __builtin_tgammal(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    tgamma(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return tgamma(__type(__x));\n-    }\n- \n-  inline float\n-  trunc(float __x)\n-  { return __builtin_truncf(__x); }\n-\n-  inline long double\n-  trunc(long double __x)\n-  { return __builtin_truncl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type \n-    trunc(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return trunc(__type(__x));\n-    }\n-\n-#endif\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}"}, {"sha": "aae4a1381ad5ba0629d0ac45ef2abf9fb5b4d4d1", "filename": "libstdc++-v3/include/tr1_impl/complex", "status": "removed", "additions": 0, "deletions": 370, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcomplex?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,370 +0,0 @@\n-// TR1 complex -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/complex\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-  /**\n-   * @addtogroup complex_numbers\n-   * @{\n-   */\n-\n-  // Forward declarations.\n-  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);\n-\n-  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  // DR 595.\n-  template<typename _Tp> _Tp               fabs(const std::complex<_Tp>&);\n-#else\n-  template<typename _Tp> std::complex<_Tp> fabs(const std::complex<_Tp>&);\n-#endif\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    __complex_acos(const std::complex<_Tp>& __z)\n-    {\n-      const std::complex<_Tp> __t = std::_GLIBCXX_TR1 asin(__z);\n-      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;\n-      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_acos(__complex__ float __z)\n-  { return __builtin_cacosf(__z); }\n-\n-  inline __complex__ double\n-  __complex_acos(__complex__ double __z)\n-  { return __builtin_cacos(__z); }\n-\n-  inline __complex__ long double\n-  __complex_acos(const __complex__ long double& __z)\n-  { return __builtin_cacosl(__z); }\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    acos(const std::complex<_Tp>& __z)\n-    { return __complex_acos(__z.__rep()); }\n-#else\n-  /// acos(__z) [8.1.2].\n-  //  Effects:  Behaves the same as C99 function cacos, defined\n-  //            in subclause 7.3.5.1.\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    acos(const std::complex<_Tp>& __z)\n-    { return __complex_acos(__z); }\n-#endif\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    __complex_asin(const std::complex<_Tp>& __z)\n-    {\n-      std::complex<_Tp> __t(-__z.imag(), __z.real());\n-      __t = std::_GLIBCXX_TR1 asinh(__t);\n-      return std::complex<_Tp>(__t.imag(), -__t.real());\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_asin(__complex__ float __z)\n-  { return __builtin_casinf(__z); }\n-\n-  inline __complex__ double\n-  __complex_asin(__complex__ double __z)\n-  { return __builtin_casin(__z); }\n-\n-  inline __complex__ long double\n-  __complex_asin(const __complex__ long double& __z)\n-  { return __builtin_casinl(__z); }\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    asin(const std::complex<_Tp>& __z)\n-    { return __complex_asin(__z.__rep()); }\n-#else\n-  /// asin(__z) [8.1.3].\n-  //  Effects:  Behaves the same as C99 function casin, defined\n-  //            in subclause 7.3.5.2.\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    asin(const std::complex<_Tp>& __z)\n-    { return __complex_asin(__z); }\n-#endif\n-  \n-  template<typename _Tp>\n-    std::complex<_Tp>\n-    __complex_atan(const std::complex<_Tp>& __z)\n-    {\n-      const _Tp __r2 = __z.real() * __z.real();\n-      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();\n-\n-      _Tp __num = __z.imag() + _Tp(1.0);\n-      _Tp __den = __z.imag() - _Tp(1.0);\n-\n-      __num = __r2 + __num * __num;\n-      __den = __r2 + __den * __den;\n-\n-      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),\n-\t\t\t       _Tp(0.25) * log(__num / __den));\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_atan(__complex__ float __z)\n-  { return __builtin_catanf(__z); }\n-\n-  inline __complex__ double\n-  __complex_atan(__complex__ double __z)\n-  { return __builtin_catan(__z); }\n-\n-  inline __complex__ long double\n-  __complex_atan(const __complex__ long double& __z)\n-  { return __builtin_catanl(__z); }\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    atan(const std::complex<_Tp>& __z)\n-    { return __complex_atan(__z.__rep()); }\n-#else\n-  /// atan(__z) [8.1.4].\n-  //  Effects:  Behaves the same as C99 function catan, defined\n-  //            in subclause 7.3.5.3.\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    atan(const std::complex<_Tp>& __z)\n-    { return __complex_atan(__z); }\n-#endif\n-\n-  template<typename _Tp>\n-    std::complex<_Tp>\n-    __complex_acosh(const std::complex<_Tp>& __z)\n-    {\n-      std::complex<_Tp> __t((__z.real() - __z.imag())\n-\t\t\t    * (__z.real() + __z.imag()) - _Tp(1.0),\n-\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n-      __t = std::sqrt(__t);\n-\n-      return std::log(__t + __z);\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_acosh(__complex__ float __z)\n-  { return __builtin_cacoshf(__z); }\n-\n-  inline __complex__ double\n-  __complex_acosh(__complex__ double __z)\n-  { return __builtin_cacosh(__z); }\n-\n-  inline __complex__ long double\n-  __complex_acosh(const __complex__ long double& __z)\n-  { return __builtin_cacoshl(__z); }\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    acosh(const std::complex<_Tp>& __z)\n-    { return __complex_acosh(__z.__rep()); }\n-#else\n-  /// acosh(__z) [8.1.5].\n-  //  Effects:  Behaves the same as C99 function cacosh, defined\n-  //            in subclause 7.3.6.1.\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    acosh(const std::complex<_Tp>& __z)\n-    { return __complex_acosh(__z); }\n-#endif\n-\n-  template<typename _Tp>\n-    std::complex<_Tp>\n-    __complex_asinh(const std::complex<_Tp>& __z)\n-    {\n-      std::complex<_Tp> __t((__z.real() - __z.imag())\n-\t\t\t    * (__z.real() + __z.imag()) + _Tp(1.0),\n-\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n-      __t = std::sqrt(__t);\n-\n-      return std::log(__t + __z);\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_asinh(__complex__ float __z)\n-  { return __builtin_casinhf(__z); }\n-\n-  inline __complex__ double\n-  __complex_asinh(__complex__ double __z)\n-  { return __builtin_casinh(__z); }\n-\n-  inline __complex__ long double\n-  __complex_asinh(const __complex__ long double& __z)\n-  { return __builtin_casinhl(__z); }\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    asinh(const std::complex<_Tp>& __z)\n-    { return __complex_asinh(__z.__rep()); }\n-#else\n-  /// asinh(__z) [8.1.6].\n-  //  Effects:  Behaves the same as C99 function casin, defined\n-  //            in subclause 7.3.6.2.\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    asinh(const std::complex<_Tp>& __z)\n-    { return __complex_asinh(__z); }\n-#endif\n-\n-  template<typename _Tp>\n-    std::complex<_Tp>\n-    __complex_atanh(const std::complex<_Tp>& __z)\n-    {\n-      const _Tp __i2 = __z.imag() * __z.imag();\n-      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();\n-\n-      _Tp __num = _Tp(1.0) + __z.real();\n-      _Tp __den = _Tp(1.0) - __z.real();\n-\n-      __num = __i2 + __num * __num;\n-      __den = __i2 + __den * __den;\n-\n-      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),\n-\t\t\t       _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_atanh(__complex__ float __z)\n-  { return __builtin_catanhf(__z); }\n-\n-  inline __complex__ double\n-  __complex_atanh(__complex__ double __z)\n-  { return __builtin_catanh(__z); }\n-\n-  inline __complex__ long double\n-  __complex_atanh(const __complex__ long double& __z)\n-  { return __builtin_catanhl(__z); }\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    atanh(const std::complex<_Tp>& __z)\n-    { return __complex_atanh(__z.__rep()); }\n-#else\n-  /// atanh(__z) [8.1.7].\n-  //  Effects:  Behaves the same as C99 function catanh, defined\n-  //            in subclause 7.3.6.3.\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    atanh(const std::complex<_Tp>& __z)\n-    { return __complex_atanh(__z); }\n-#endif\n-\n-  template<typename _Tp>\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-    inline _Tp\n-#else\n-    inline std::complex<_Tp>\n-#endif\n-    /// fabs(__z) [8.1.8].\n-    //  Effects:  Behaves the same as C99 function cabs, defined\n-    //            in subclause 7.3.8.1.\n-    fabs(const std::complex<_Tp>& __z)\n-    { return std::abs(__z); }\n-\n-  /// Additional overloads [8.1.9].\n-#if (defined(_GLIBCXX_INCLUDE_AS_CXX0X) \\\n-     || (defined(_GLIBCXX_INCLUDE_AS_TR1) \\\n-\t && !defined(__GXX_EXPERIMENTAL_CXX0X__)))\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type\n-    arg(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-#if (_GLIBCXX_USE_C99_MATH && !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC)\n-      return std::signbit(__x) ? __type(3.1415926535897932384626433832795029L)\n-\t                       : __type();\n-#else\n-      return std::arg(std::complex<__type>(__x));\n-#endif\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type\n-    imag(_Tp)\n-    { return _Tp(); }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type\n-    norm(_Tp __x)\n-    {\n-      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __type(__x) * __type(__x);\n-    }\n-\n-  template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type\n-    real(_Tp __x)\n-    { return __x; }\n-\n-#endif\n-\n-  template<typename _Tp, typename _Up>\n-    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n-    pow(const std::complex<_Tp>& __x, const _Up& __y)\n-    {\n-      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n-      return std::pow(std::complex<__type>(__x), __type(__y));\n-    }\n-\n-  template<typename _Tp, typename _Up>\n-    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n-    pow(const _Tp& __x, const std::complex<_Up>& __y)\n-    {\n-      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n-      return std::pow(__type(__x), std::complex<__type>(__y));\n-    }\n-\n-  template<typename _Tp, typename _Up>\n-    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n-    pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)\n-    {\n-      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n-      return std::pow(std::complex<__type>(__x),\n-\t\t      std::complex<__type>(__y));\n-    }\n-\n-  // @} group complex_numbers\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}"}, {"sha": "d1403887a7106987ccf60c5710912ebe22b2abef", "filename": "libstdc++-v3/include/tr1_impl/cstdint", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdint", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdint", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdint?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,75 +0,0 @@\n-// TR1 cstdint -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/cstdint\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#if _GLIBCXX_USE_C99_STDINT_TR1\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-  using ::int8_t;\n-  using ::int16_t;\n-  using ::int32_t;\n-  using ::int64_t;\n-\n-  using ::int_fast8_t;\n-  using ::int_fast16_t;\n-  using ::int_fast32_t;\n-  using ::int_fast64_t;\n-\n-  using ::int_least8_t;\n-  using ::int_least16_t;\n-  using ::int_least32_t;\n-  using ::int_least64_t;\n-\n-  using ::intmax_t;\n-  using ::intptr_t;\n-  \n-  using ::uint8_t;\n-  using ::uint16_t;\n-  using ::uint32_t;\n-  using ::uint64_t;\n-\n-  using ::uint_fast8_t;\n-  using ::uint_fast16_t;\n-  using ::uint_fast32_t;\n-  using ::uint_fast64_t;\n-\n-  using ::uint_least8_t;\n-  using ::uint_least16_t;\n-  using ::uint_least32_t;\n-  using ::uint_least64_t;\n-\n-  using ::uintmax_t;\n-  using ::uintptr_t;\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}\n-\n-#endif"}, {"sha": "8b100ccebc69efd6d4f7bda42c59451adbc5e1cb", "filename": "libstdc++-v3/include/tr1_impl/cstdio", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdio?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,44 +0,0 @@\n-// TR1 cstdio -*- C++ -*-\n-\n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/cstdio\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-#if _GLIBCXX_USE_C99\n-  using std::snprintf;\n-  using std::vsnprintf;\n-\n-  using std::vfscanf;\n-  using std::vscanf;\n-  using std::vsscanf;\n-#endif\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}"}, {"sha": "e9a590f0b58d93d8507c1851a060a60f4ff9c361", "filename": "libstdc++-v3/include/tr1_impl/cstdlib", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdlib?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,65 +0,0 @@\n-// TR1 cstdlib -*- C++ -*-\n-\n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/cstdlib\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#if _GLIBCXX_HOSTED\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-#if _GLIBCXX_USE_C99\n-\n-#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC\n-  // types\n-  using std::lldiv_t;\n-\n-  // functions\n-  using std::llabs;\n-  using std::lldiv;\n-#endif\n-\n-  using std::atoll;\n-  using std::strtoll;\n-  using std::strtoull;\n-\n-  using std::strtof;\n-  using std::strtold;\n-\n-  // overloads\n-  using std::abs;\n-#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC\n-  using std::div;\n-#endif\n-\n-#endif\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}\n-\n-#endif"}, {"sha": "2a9004d40d4095afdbddd3a2ff4c48c3ba33d4bc", "filename": "libstdc++-v3/include/tr1_impl/cwchar", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwchar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwchar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwchar?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,58 +0,0 @@\n-// TR1 cwchar -*- C++ -*-\n-\n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/cwchar\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#if _GLIBCXX_USE_WCHAR_T\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-#if _GLIBCXX_HAVE_WCSTOF\n-  using std::wcstof;\n-#endif\n-#if _GLIBCXX_HAVE_VFWSCANF\n-  using std::vfwscanf;\n-#endif\n-#if _GLIBCXX_HAVE_VSWSCANF\n-  using std::vswscanf;\n-#endif\n-#if _GLIBCXX_HAVE_VWSCANF\n-  using std::vwscanf;\n-#endif\n-\n-#if _GLIBCXX_USE_C99\n-  using std::wcstold;\n-  using std::wcstoll;\n-  using std::wcstoull;\n-#endif\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}\n-\n-#endif"}, {"sha": "3135d3641194cc5923232c82b76d2cf972b734da", "filename": "libstdc++-v3/include/tr1_impl/cwctype", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwctype?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,43 +0,0 @@\n-// TR1 cwctype -*- C++ -*-\n-\n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/cwctype\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#if _GLIBCXX_USE_WCHAR_T\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-#if _GLIBCXX_HAVE_ISWBLANK\n-  using std::iswblank;\n-#endif  \n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}\n-\n-#endif"}, {"sha": "efe79e954770bc4a78612edca591c71bc2fae2c2", "filename": "libstdc++-v3/include/tr1_impl/regex", "status": "removed", "additions": 0, "deletions": 2710, "changes": 2710, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fregex?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,2710 +0,0 @@\n-// class template regex -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/**\n- * @file tr1_impl/regex\n- * @brief The common implementation file for tr1 and std regular expressions.\n- *\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-/**\n- * @defgroup tr1_regex Regular Expressions\n- * A facility for performing regular expression pattern matching.\n- */\n- //@{\n-\n-/** @namespace std::regex_constants\n- *  @brief ISO C++ 0x entities sub namespace for regex.\n- */\n-namespace regex_constants\n-{\n-  /**\n-   * @name 5.1 Regular Expression Syntax Options\n-   */\n-  //@{\n-  enum __syntax_option\n-    {\n-      _S_icase,\n-      _S_nosubs,\n-      _S_optimize,\n-      _S_collate,\n-      _S_ECMAScript,\n-      _S_basic,\n-      _S_extended,\n-      _S_awk,\n-      _S_grep,\n-      _S_egrep,\n-      _S_syntax_last\n-    };\n-\n-  /**\n-   * @brief This is a bitmask type indicating how to interpret the regex.\n-   *\n-   * The @c syntax_option_type is implementation defined but it is valid to\n-   * perform bitwise operations on these values and expect the right thing to\n-   * happen.\n-   *\n-   * A valid value of type syntax_option_type shall have exactly one of the\n-   * elements @c ECMAScript, @c basic, @c extended, @c awk, @c grep, @c egrep\n-   * %set.\n-   */\n-  typedef unsigned int syntax_option_type;\n-\n-  /** \n-   * Specifies that the matching of regular expressions against a character\n-   * sequence shall be performed without regard to case.\n-   */\n-  static const syntax_option_type icase      = 1 << _S_icase;\n-\n-  /**\n-   * Specifies that when a regular expression is matched against a character\n-   * container sequence, no sub-expression matches are to be stored in the\n-   * supplied match_results structure.\n-   */\n-  static const syntax_option_type nosubs     = 1 << _S_nosubs;\n-\n-  /**\n-   * Specifies that the regular expression engine should pay more attention to\n-   * the speed with which regular expressions are matched, and less to the\n-   * speed with which regular expression objects are constructed. Otherwise\n-   * it has no detectable effect on the program output.\n-   */\n-  static const syntax_option_type optimize   = 1 << _S_optimize;\n-\n-  /**\n-   * Specifies that character ranges of the form [a-b] should be locale\n-   * sensitive.\n-   */\n-  static const syntax_option_type collate    = 1 << _S_collate;\n-\n-  /**\n-   * Specifies that the grammar recognized by the regular expression engine is\n-   * that used by ECMAScript in ECMA-262 [Ecma International, ECMAScript\n-   * Language Specification, Standard Ecma-262, third edition, 1999], as\n-   * modified in tr1 section [7.13].  This grammar is similar to that defined\n-   * in the PERL scripting language but extended with elements found in the\n-   * POSIX regular expression grammar.\n-   */\n-  static const syntax_option_type ECMAScript = 1 << _S_ECMAScript;\n-\n-  /**\n-   * Specifies that the grammar recognized by the regular expression engine is\n-   * that used by POSIX basic regular expressions in IEEE Std 1003.1-2001,\n-   * Portable Operating System Interface (POSIX), Base Definitions and\n-   * Headers, Section 9, Regular Expressions [IEEE, Information Technology --\n-   * Portable Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n-   */\n-  static const syntax_option_type basic      = 1 << _S_basic;\n-\n-  /**\n-   * Specifies that the grammar recognized by the regular expression engine is\n-   * that used by POSIX extended regular expressions in IEEE Std 1003.1-2001,\n-   * Portable Operating System Interface (POSIX), Base Definitions and Headers,\n-   * Section 9, Regular Expressions.\n-   */\n-  static const syntax_option_type extended   = 1 << _S_extended;\n-\n-  /**\n-   * Specifies that the grammar recognized by the regular expression engine is\n-   * that used by POSIX utility awk in IEEE Std 1003.1-2001.  This option is\n-   * identical to syntax_option_type extended, except that C-style escape\n-   * sequences are supported.  These sequences are: \n-   * \\\\\\\\, \\\\a, \\\\b, \\\\f, \n-   * \\\\n, \\\\r, \\\\t , \\\\v, \n-   * \\\\&apos;, &apos;, and \\\\ddd \n-   * (where ddd is one, two, or three octal digits).  \n-   */\n-  static const syntax_option_type awk        = 1 << _S_awk;\n-\n-  /**\n-   * Specifies that the grammar recognized by the regular expression engine is\n-   * that used by POSIX utility grep in IEEE Std 1003.1-2001.  This option is\n-   * identical to syntax_option_type basic, except that newlines are treated\n-   * as whitespace.\n-   */\n-  static const syntax_option_type grep       = 1 << _S_grep;\n-\n-  /**\n-   * Specifies that the grammar recognized by the regular expression engine is\n-   * that used by POSIX utility grep when given the -E option in\n-   * IEEE Std 1003.1-2001.  This option is identical to syntax_option_type \n-   * extended, except that newlines are treated as whitespace.\n-   */\n-  static const syntax_option_type egrep      = 1 << _S_egrep;\n-\n-  //@}\n-\n-  /**\n-   * @name 5.2 Matching Rules\n-   *\n-   * Matching a regular expression against a sequence of characters [first,\n-   * last) proceeds according to the rules of the grammar specified for the\n-   * regular expression object, modified according to the effects listed\n-   * below for any bitmask elements set.\n-   *\n-   */\n-  //@{\n-\n-  enum __match_flag\n-    {\n-      _S_not_bol,\n-      _S_not_eol,\n-      _S_not_bow,\n-      _S_not_eow,\n-      _S_any,\n-      _S_not_null,\n-      _S_continuous,\n-      _S_prev_avail,\n-      _S_sed,\n-      _S_no_copy,\n-      _S_first_only,\n-      _S_match_flag_last\n-    };\n-\n-  /**\n-   * @brief This is a bitmask type indicating regex matching rules.\n-   *\n-   * The @c match_flag_type is implementation defined but it is valid to\n-   * perform bitwise operations on these values and expect the right thing to\n-   * happen.\n-   */\n-  typedef std::bitset<_S_match_flag_last> match_flag_type;\n-\n-  /**\n-   * The default matching rules.\n-   */\n-  static const match_flag_type match_default     = 0;\n-\n-  /**\n-   * The first character in the sequence [first, last) is treated as though it\n-   * is not at the beginning of a line, so the character (^) in the regular\n-   * expression shall not match [first, first).\n-   */\n-  static const match_flag_type match_not_bol     = 1 << _S_not_bol;\n-\n-  /**\n-   * The last character in the sequence [first, last) is treated as though it\n-   * is not at the end of a line, so the character ($) in the regular\n-   * expression shall not match [last, last).\n-   */\n-  static const match_flag_type match_not_eol     = 1 << _S_not_eol;\n-   \n-  /**\n-   * The expression \\\\b is not matched against the sub-sequence\n-   * [first,first).\n-   */\n-  static const match_flag_type match_not_bow     = 1 << _S_not_bow;\n-   \n-  /**\n-   * The expression \\\\b should not be matched against the sub-sequence\n-   * [last,last).\n-   */\n-  static const match_flag_type match_not_eow     = 1 << _S_not_eow;\n-   \n-  /**\n-   * If more than one match is possible then any match is an acceptable\n-   * result.\n-   */\n-  static const match_flag_type match_any         = 1 << _S_any;\n-   \n-  /**\n-   * The expression does not match an empty sequence.\n-   */\n-  static const match_flag_type match_not_null    = 1 << _S_not_null;\n-   \n-  /**\n-   * The expression only matches a sub-sequence that begins at first .\n-   */\n-  static const match_flag_type match_continuous  = 1 << _S_continuous;\n-   \n-  /**\n-   * --first is a valid iterator position.  When this flag is set then the\n-   * flags match_not_bol and match_not_bow are ignored by the regular\n-   * expression algorithms 7.11 and iterators 7.12.\n-   */\n-  static const match_flag_type match_prev_avail  = 1 << _S_prev_avail;\n-\n-  /**\n-   * When a regular expression match is to be replaced by a new string, the\n-   * new string is constructed using the rules used by the ECMAScript replace\n-   * function in ECMA- 262 [Ecma International, ECMAScript Language\n-   * Specification, Standard Ecma-262, third edition, 1999], part 15.5.4.11\n-   * String.prototype.replace. In addition, during search and replace\n-   * operations all non-overlapping occurrences of the regular expression\n-   * are located and replaced, and sections of the input that did not match\n-   * the expression are copied unchanged to the output string.\n-   * \n-   * Format strings (from ECMA-262 [15.5.4.11]):\n-   * @li $$  The dollar-sign itself ($)\n-   * @li $&  The matched substring.\n-   * @li $`  The portion of @a string that precedes the matched substring.\n-   *         This would be match_results::prefix().\n-   * @li $'  The portion of @a string that follows the matched substring.\n-   *         This would be match_results::suffix().\n-   * @li $n  The nth capture, where n is in [1,9] and $n is not followed by a\n-   *         decimal digit.  If n <= match_results::size() and the nth capture\n-   *         is undefined, use the empty string instead.  If n >\n-   *         match_results::size(), the result is implementation-defined.\n-   * @li $nn The nnth capture, where nn is a two-digit decimal number on\n-   *         [01, 99].  If nn <= match_results::size() and the nth capture is\n-   *         undefined, use the empty string instead. If\n-   *         nn > match_results::size(), the result is implementation-defined.\n-   */\n-  static const match_flag_type format_default    = 0;\n-\n-  /**\n-   * When a regular expression match is to be replaced by a new string, the\n-   * new string is constructed using the rules used by the POSIX sed utility\n-   * in IEEE Std 1003.1- 2001 [IEEE, Information Technology -- Portable\n-   * Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n-   */\n-  static const match_flag_type format_sed        = 1 << _S_sed;\n-\n-  /**\n-   * During a search and replace operation, sections of the character\n-   * container sequence being searched that do not match the regular\n-   * expression shall not be copied to the output string.\n-   */\n-  static const match_flag_type format_no_copy    = 1 << _S_no_copy;\n-\n-  /**\n-   * When specified during a search and replace operation, only the first\n-   * occurrence of the regular expression shall be replaced.\n-   */\n-  static const match_flag_type format_first_only = 1 << _S_first_only;\n-\n-  //@}\n-\n-  /**\n-   * @name 5.3 Error Types\n-   */\n-  //@{\n- \n-  enum error_type\n-    {\n-      _S_error_collate,\n-      _S_error_ctype,\n-      _S_error_escape,\n-      _S_error_backref,\n-      _S_error_brack,\n-      _S_error_paren,\n-      _S_error_brace,\n-      _S_error_badbrace,\n-      _S_error_range,\n-      _S_error_space,\n-      _S_error_badrepeat,\n-      _S_error_complexity,\n-      _S_error_stack,\n-      _S_error_last\n-    };\n-\n-  /** The expression contained an invalid collating element name. */\n-  static const error_type error_collate(_S_error_collate);\n-\n-  /** The expression contained an invalid character class name. */\n-  static const error_type error_ctype(_S_error_ctype);\n-\n-  /**\n-   * The expression contained an invalid escaped character, or a trailing\n-   * escape.\n-   */\n-  static const error_type error_escape(_S_error_escape);\n-\n-  /** The expression contained an invalid back reference. */\n-  static const error_type error_backref(_S_error_backref);\n-\n-  /** The expression contained mismatched [ and ]. */\n-  static const error_type error_brack(_S_error_brack);\n-\n-  /** The expression contained mismatched ( and ). */\n-  static const error_type error_paren(_S_error_paren);\n-\n-  /** The expression contained mismatched { and } */\n-  static const error_type error_brace(_S_error_brace);\n-\n-  /** The expression contained an invalid range in a {} expression. */\n-  static const error_type error_badbrace(_S_error_badbrace);\n-\n-  /**\n-   * The expression contained an invalid character range,\n-   * such as [b-a] in most encodings.\n-   */\n-  static const error_type error_range(_S_error_range);\n-\n-  /**\n-   * There was insufficient memory to convert the expression into a\n-   * finite state machine.\n-   */\n-  static const error_type error_space(_S_error_space);\n-\n-  /**\n-   * One of <em>*?+{</em> was not preceded by a valid regular expression.\n-   */\n-  static const error_type error_badrepeat(_S_error_badrepeat);\n-\n-  /**\n-   * The complexity of an attempted match against a regular expression\n-   * exceeded a pre-set level.\n-   */\n-  static const error_type error_complexity(_S_error_complexity);\n-\n-  /**\n-   * There was insufficient memory to determine whether the\n-   * regular expression could match the specified character sequence.\n-   */\n-  static const error_type error_stack(_S_error_stack);\n-\n-  //@}\n-}\n-\n-\n-  // [7.8] Class regex_error\n-  /**\n-   *  @brief A regular expression exception class.\n-   *  @ingroup exceptions\n-   *\n-   *  The regular expression library throws objects of this class on error.\n-   */\n-  class regex_error\n-  : public std::runtime_error\n-  {\n-  public:\n-    /**\n-     * @brief Constructs a regex_error object.\n-     *\n-     * @param ecode the regex error code.\n-     */\n-    explicit\n-    regex_error(regex_constants::error_type __ecode)\n-    : std::runtime_error(\"regex_error\"), _M_code(__ecode)\n-    { }\n-\n-    /**\n-     * @brief Gets the regex error code.\n-     *\n-     * @returns the regex error code.\n-     */\n-    regex_constants::error_type\n-    code() const\n-    { return _M_code; }\n-\n-  protected:\n-    regex_constants::error_type _M_code;\n-  };\n-\n-  // [7.7] Class regex_traits\n-  /**\n-   * @brief Describes aspects of a regular expression.\n-   *\n-   * A regular expression traits class that satisfies the requirements of tr1\n-   * section [7.2].\n-   *\n-   * The class %regex is parameterized around a set of related types and\n-   * functions used to complete the definition of its semantics.  This class\n-   * satisfies the requirements of such a traits class.\n-   */\n-  template<typename _Ch_type>\n-    struct regex_traits\n-    {\n-    public:\n-      typedef _Ch_type                     char_type;\n-      typedef std::basic_string<char_type> string_type;\n-      typedef std::locale                  locale_type;\n-      typedef std::ctype_base::mask        char_class_type;\n-\n-    public:\n-      /**\n-       * @brief Constructs a default traits object.\n-       */\n-      regex_traits()\n-      { }\n-      \n-      /**\n-       * @brief Gives the length of a C-style string starting at @p __p.\n-       *\n-       * @param __p a pointer to the start of a character sequence.\n-       *\n-       * @returns the number of characters between @p *__p and the first\n-       * default-initialized value of type @p char_type.  In other words, uses\n-       * the C-string algorithm for determining the length of a sequence of\n-       * characters.\n-       */\n-      static std::size_t\n-      length(const char_type* __p)\n-      { return string_type::traits_type::length(__p); }\n-\n-      /**\n-       * @brief Performs the identity translation.\n-       *\n-       * @param c A character to the locale-specific character set.\n-       *\n-       * @returns c.\n-       */\n-      char_type\n-      translate(char_type __c) const\n-      { return __c; }\n-      \n-      /**\n-       * @brief Translates a character into a case-insensitive equivalent.\n-       *\n-       * @param c A character to the locale-specific character set.\n-       *\n-       * @returns the locale-specific lower-case equivalent of c.\n-       * @throws std::bad_cast if the imbued locale does not support the ctype\n-       *         facet.\n-       */\n-      char_type\n-      translate_nocase(char_type __c) const\n-      {\n-\tusing std::ctype;\n-\tusing std::use_facet;\n-\treturn use_facet<ctype<char_type> >(_M_locale).tolower(__c);\n-      }\n-      \n-      /**\n-       * @brief Gets a sort key for a character sequence.\n-       *\n-       * @param first beginning of the character sequence.\n-       * @param last  one-past-the-end of the character sequence.\n-       *\n-       * Returns a sort key for the character sequence designated by the\n-       * iterator range [F1, F2) such that if the character sequence [G1, G2)\n-       * sorts before the character sequence [H1, H2) then\n-       * v.transform(G1, G2) < v.transform(H1, H2).\n-       *\n-       * What this really does is provide a more efficient way to compare a\n-       * string to multiple other strings in locales with fancy collation\n-       * rules and equivalence classes.\n-       *\n-       * @returns a locale-specific sort key equivalent to the input range.\n-       *\n-       * @throws std::bad_cast if the current locale does not have a collate\n-       *         facet.\n-       */\n-      template<typename _Fwd_iter>\n-        string_type\n-        transform(_Fwd_iter __first, _Fwd_iter __last) const\n-        {\n-\t  using std::collate;\n-\t  using std::use_facet;\n-\t  const collate<_Ch_type>& __c(use_facet<\n-\t\t\t\t       collate<_Ch_type> >(_M_locale));\n-\t  string_type __s(__first, __last);\n-\t  return __c.transform(__s.data(), __s.data() + __s.size());\n-\t}\n-\n-      /**\n-       * @brief Dunno.\n-       *\n-       * @param first beginning of the character sequence.\n-       * @param last  one-past-the-end of the character sequence.\n-       *\n-       * Effects: if typeid(use_facet<collate<_Ch_type> >) ==\n-       * typeid(collate_byname<_Ch_type>) and the form of the sort key\n-       * returned by collate_byname<_Ch_type>::transform(first, last) is known\n-       * and can be converted into a primary sort key then returns that key,\n-       * otherwise returns an empty string. WTF??\n-       *\n-       * @todo Implement this function.\n-       */\n-      template<typename _Fwd_iter>\n-        string_type\n-        transform_primary(_Fwd_iter __first, _Fwd_iter __last) const;\n-\n-      /**\n-       * @brief Gets a collation element by name.\n-       *\n-       * @param first beginning of the collation element name.\n-       * @param last  one-past-the-end of the collation element name.\n-       * \n-       * @returns a sequence of one or more characters that represents the\n-       * collating element consisting of the character sequence designated by\n-       * the iterator range [first, last). Returns an empty string if the\n-       * character sequence is not a valid collating element.\n-       *\n-       * @todo Implement this function.\n-       */\n-      template<typename _Fwd_iter>\n-        string_type\n-        lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const;\n-\n-      /**\n-       * @brief Maps one or more characters to a named character\n-       *        classification.\n-       *\n-       * @param first beginning of the character sequence.\n-       * @param last  one-past-the-end of the character sequence.\n-       *\n-       * @returns an unspecified value that represents the character\n-       * classification named by the character sequence designated by the\n-       * iterator range [first, last). The value returned shall be independent\n-       * of the case of the characters in the character sequence. If the name\n-       * is not recognized then returns a value that compares equal to 0.\n-       *\n-       * At least the following names (or their wide-character equivalent) are\n-       * supported.\n-       * - d\n-       * - w\n-       * - s\n-       * - alnum\n-       * - alpha\n-       * - blank\n-       * - cntrl\n-       * - digit\n-       * - graph\n-       * - lower\n-       * - print\n-       * - punct\n-       * - space\n-       * - upper\n-       * - xdigit\n-       *\n-       * @todo Implement this function.\n-       */\n-      template<typename _Fwd_iter>\n-        char_class_type\n-        lookup_classname(_Fwd_iter __first, _Fwd_iter __last) const;\n-\n-      /**\n-       * @brief Determines if @p c is a member of an identified class.\n-       *\n-       * @param c a character.\n-       * @param f a class type (as returned from lookup_classname).\n-       *\n-       * @returns true if the character @p c is a member of the classification\n-       * represented by @p f, false otherwise.\n-       *\n-       * @throws std::bad_cast if the current locale does not have a ctype\n-       *         facet.\n-       */\n-      bool\n-      isctype(_Ch_type __c, char_class_type __f) const;\n-\n-      /**\n-       * @brief Converts a digit to an int.\n-       *\n-       * @param ch    a character representing a digit.\n-       * @param radix the radix if the numeric conversion (limited to 8, 10,\n-       *              or 16).\n-       * \n-       * @returns the value represented by the digit ch in base radix if the\n-       * character ch is a valid digit in base radix; otherwise returns -1.\n-       */\n-      int\n-      value(_Ch_type __ch, int __radix) const;\n-      \n-      /**\n-       * @brief Imbues the regex_traits object with a copy of a new locale.\n-       *\n-       * @param loc A locale.\n-       *\n-       * @returns a copy of the previous locale in use by the regex_traits\n-       *          object.\n-       *\n-       * @note Calling imbue with a different locale than the one currently in\n-       *       use invalidates all cached data held by *this.\n-       */\n-      locale_type\n-      imbue(locale_type __loc)\n-      {\n-\tstd::swap(_M_locale, __loc);\n-\treturn __loc;\n-      }\n-      \n-      /**\n-       * @brief Gets a copy of the current locale in use by the regex_traits\n-       * object.\n-       */\n-      locale_type\n-      getloc() const\n-      { return _M_locale; }\n-      \n-    protected:\n-      locale_type _M_locale;\n-    };\n-\n-  template<typename _Ch_type>\n-    bool regex_traits<_Ch_type>::\n-    isctype(_Ch_type __c, char_class_type __f) const\n-    {\n-      using std::ctype;\n-      using std::use_facet;\n-      const ctype<_Ch_type>& __ctype(use_facet<\n-\t\t\t\t     ctype<_Ch_type> >(_M_locale));\n-      \n-      if (__ctype.is(__c, __f))\n-\treturn true;\n-      \n-      // special case of underscore in [[:w:]]\n-      if (__c == __ctype.widen('_'))\n-\t{\n-\t  const char* const __wb[] = \"w\";\n-\t  char_class_type __wt = this->lookup_classname(__wb,\n-\t\t\t\t\t\t\t__wb + sizeof(__wb));\n-\t  if (__f | __wt)\n-\t    return true;\n-\t}\n-    \n-      // special case of [[:space:]] in [[:blank:]]\n-      if (__c == __ctype.isspace(__c))\n-\t{\n-\t  const char* const __bb[] = \"blank\";\n-\t  char_class_type __bt = this->lookup_classname(__bb,\n-\t\t\t\t\t\t\t__bb + sizeof(__bb));\n-\t  if (__f | __bt)\n-\t    return true;\n-\t}\n-      \n-      return false;\n-    }\n-\n-  template<typename _Ch_type>\n-    int regex_traits<_Ch_type>::\n-    value(_Ch_type __ch, int __radix) const\n-    {\n-      std::basic_istringstream<_Ch_type> __is(string_type(1, __ch));\n-      int __v;\n-      if (__radix == 8)\n-\t__is >> std::oct;\n-      else if (__radix == 16)\n-\t__is >> std::hex;\n-      __is >> __v;\n-      return __is.fail() ? -1 : __v;\n-    }\n-\n-  // [7.8] Class basic_regex\n-  /**\n-   * Objects of specializations of this class represent regular expressions\n-   * constructed from sequences of character type @p _Ch_type.\n-   *\n-   * Storage for the regular expression is allocated and deallocated as\n-   * necessary by the member functions of this class.\n-   */\n-  template<typename _Ch_type, typename _Rx_traits = regex_traits<_Ch_type> >\n-    class basic_regex\n-    {\n-    public:\n-      // types:\n-      typedef _Ch_type                              value_type;\n-      typedef regex_constants::syntax_option_type flag_type;\n-      typedef typename _Rx_traits::locale_type  locale_type;\n-      typedef typename _Rx_traits::string_type  string_type;\n-\n-      /**\n-       * @name Constants\n-       * tr1 [7.8.1] std [28.8.1]\n-       */\n-      //@{\n-      static const regex_constants::syntax_option_type icase\n-        = regex_constants::icase;\n-      static const regex_constants::syntax_option_type nosubs\n-        = regex_constants::nosubs;\n-      static const regex_constants::syntax_option_type optimize\n-        = regex_constants::optimize;\n-      static const regex_constants::syntax_option_type collate\n-        = regex_constants::collate;\n-      static const regex_constants::syntax_option_type ECMAScript\n-        = regex_constants::ECMAScript;\n-      static const regex_constants::syntax_option_type basic\n-        = regex_constants::basic;\n-      static const regex_constants::syntax_option_type extended\n-        = regex_constants::extended;\n-      static const regex_constants::syntax_option_type awk\n-        = regex_constants::awk;\n-      static const regex_constants::syntax_option_type grep\n-        = regex_constants::grep;\n-      static const regex_constants::syntax_option_type egrep\n-        = regex_constants::egrep;\n-      //@}\n-\n-      // [7.8.2] construct/copy/destroy\n-      /**\n-       * Constructs a basic regular expression that does not match any\n-       * character sequence.\n-       */\n-      basic_regex()\n-      : _M_flags(regex_constants::ECMAScript), _M_pattern(), _M_mark_count(0)\n-      { _M_compile(); }\n-\n-      /**\n-       * @brief Constructs a basic regular expression from the sequence\n-       * [p, p + char_traits<_Ch_type>::length(p)) interpreted according to the\n-       * flags in @p f.\n-       *\n-       * @param p A pointer to the start of a C-style null-terminated string\n-       *          containing a regular expression.\n-       * @param f Flags indicating the syntax rules and options.\n-       *\n-       * @throws regex_error if @p p is not a valid regular expression.\n-       */\n-      explicit\n-      basic_regex(const _Ch_type* __p,\n-\t\t  flag_type __f = regex_constants::ECMAScript)\n-      : _M_flags(__f), _M_pattern(__p), _M_mark_count(0)\n-      { _M_compile(); }\n-\n-      /**\n-       * @brief Constructs a basic regular expression from the sequence\n-       * [p, p + len) interpreted according to the flags in @p f.\n-       *\n-       * @param p   A pointer to the start of a string containing a regular\n-       *            expression.\n-       * @param len The length of the string containing the regular expression.\n-       * @param f   Flags indicating the syntax rules and options.\n-       *\n-       * @throws regex_error if @p p is not a valid regular expression.\n-       */\n-      basic_regex(const _Ch_type* __p, std::size_t __len, flag_type __f)\n-      : _M_flags(__f) , _M_pattern(__p, __len), _M_mark_count(0)\n-      { _M_compile(); }\n-\n-      /**\n-       * @brief Copy-constructs a basic regular expression.\n-       *\n-       * @param rhs A @p regex object.\n-     */\n-      basic_regex(const basic_regex& __rhs)\n-      : _M_flags(__rhs._M_flags), _M_pattern(__rhs._M_pattern),\n-\t_M_mark_count(__rhs._M_mark_count)\n-      { _M_compile(); }\n-\n-      /**\n-       * @brief Constructs a basic regular expression from the string\n-       * @p s interpreted according to the flags in @p f.\n-       *\n-       * @param s A string containing a regular expression.\n-       * @param f Flags indicating the syntax rules and options.\n-       *\n-       * @throws regex_error if @p s is not a valid regular expression.\n-       */\n-      template<typename _Ch_traits, typename _Ch_alloc>\n-        explicit\n-        basic_regex(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n-\t\t    flag_type __f = regex_constants::ECMAScript)\n-\t: _M_flags(__f), _M_pattern(__s.begin(), __s.end()), _M_mark_count(0)\n-        { _M_compile(); }\n-\n-      /**\n-       * @brief Constructs a basic regular expression from the range\n-       * [first, last) interpreted according to the flags in @p f.\n-       *\n-       * @param first The start of a range containing a valid regular\n-       *              expression.\n-       * @param last  The end of a range containing a valid regular\n-       *              expression.\n-       * @param f     The format flags of the regular expression.\n-       *\n-       * @throws regex_error if @p [first, last) is not a valid regular\n-       *         expression.\n-       */\n-      template<typename _InputIterator>\n-        basic_regex(_InputIterator __first, _InputIterator __last, \n-\t\t    flag_type __f = regex_constants::ECMAScript)\n-\t: _M_flags(__f), _M_pattern(__first, __last), _M_mark_count(0)\n-        { _M_compile(); }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      /**\n-       * @brief Constructs a basic regular expression from an initializer list.\n-       *\n-       * @param l  The initializer list.\n-       * @param f  The format flags of the regular expression.\n-       *\n-       * @throws regex_error if @p l is not a valid regular expression.\n-       */\n-      basic_regex(initializer_list<_Ch_type> __l,\n-\t\t  flag_type __f = regex_constants::ECMAScript)\n-\t: _M_flags(__f), _M_pattern(__l.begin(), __l.end()), _M_mark_count(0)\n-        { _M_compile(); }\n-#endif\n-\n-      /**\n-       * @brief Destroys a basic regular expression.\n-       */\n-      ~basic_regex()\n-      { }\n-      \n-      /**\n-       * @brief Assigns one regular expression to another.\n-       */\n-      basic_regex&\n-      operator=(const basic_regex& __rhs)\n-      { return this->assign(__rhs); }\n-\n-      /**\n-       * @brief Replaces a regular expression with a new one constructed from\n-       * a C-style null-terminated string.\n-       *\n-       * @param A pointer to the start of a null-terminated C-style string\n-       *        containing a regular expression.\n-       */\n-      basic_regex&\n-      operator=(const _Ch_type* __p)\n-      { return this->assign(__p, flags()); }\n-      \n-      /**\n-       * @brief Replaces a regular expression with a new one constructed from\n-       * a string.\n-       *\n-       * @param A pointer to a string containing a regular expression.\n-       */\n-      template<typename _Ch_typeraits, typename _Allocator>\n-        basic_regex&\n-        operator=(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s)\n-        { return this->assign(__s, flags()); }\n-\n-      // [7.8.3] assign\n-      /**\n-       * @brief the real assignment operator.\n-       *\n-       * @param that Another regular expression object.\n-       */\n-      basic_regex&\n-      assign(const basic_regex& __that)\n-      {\n-\tbasic_regex __tmp(__that);\n-\tthis->swap(__tmp);\n-\treturn *this;\n-      }\n-      \n-      /**\n-       * @brief Assigns a new regular expression to a regex object from a\n-       * C-style null-terminated string containing a regular expression\n-       * pattern.\n-       *\n-       * @param p     A pointer to a C-style null-terminated string containing\n-       *              a regular expression pattern.\n-       * @param flags Syntax option flags.\n-       *\n-       * @throws regex_error if p does not contain a valid regular expression\n-       * pattern interpreted according to @p flags.  If regex_error is thrown,\n-       * *this remains unchanged.\n-       */\n-      basic_regex&\n-      assign(const _Ch_type* __p,\n-\t     flag_type __flags = regex_constants::ECMAScript)\n-      { return this->assign(string_type(__p), __flags); }\n-\n-      /**\n-       * @brief Assigns a new regular expression to a regex object from a\n-       * C-style string containing a regular expression pattern.\n-       *\n-       * @param p     A pointer to a C-style string containing a\n-       *              regular expression pattern.\n-       * @param len   The length of the regular expression pattern string.\n-       * @param flags Syntax option flags.\n-       *\n-       * @throws regex_error if p does not contain a valid regular expression\n-       * pattern interpreted according to @p flags.  If regex_error is thrown,\n-       * *this remains unchanged.\n-       */\n-      basic_regex&\n-      assign(const _Ch_type* __p, std::size_t __len, flag_type __flags)\n-      { return this->assign(string_type(__p, __len), __flags); }\n-\n-      /**\n-       * @brief Assigns a new regular expression to a regex object from a \n-       * string containing a regular expression pattern.\n-       *\n-       * @param s     A string containing a regular expression pattern.\n-       * @param flags Syntax option flags.\n-       *\n-       * @throws regex_error if p does not contain a valid regular expression\n-       * pattern interpreted according to @p flags.  If regex_error is thrown,\n-       * *this remains unchanged.\n-       */\n-      template<typename _Ch_typeraits, typename _Allocator>\n-        basic_regex&\n-        assign(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s,\n-\t       flag_type __f = regex_constants::ECMAScript)\n-        { \n-\t  basic_regex __tmp(__s, __f);\n-\t  this->swap(__tmp);\n-\t  return *this;\n-\t}\n-\n-      /**\n-       * @brief Assigns a new regular expression to a regex object.\n-       *\n-       * @param first The start of a range containing a valid regular\n-       *              expression.\n-       * @param last  The end of a range containing a valid regular\n-       *              expression.\n-       * @param flags Syntax option flags.\n-       *\n-       * @throws regex_error if p does not contain a valid regular expression\n-       * pattern interpreted according to @p flags.  If regex_error is thrown,\n-       * the object remains unchanged.\n-       */\n-      template<typename _InputIterator>\n-        basic_regex&\n-        assign(_InputIterator __first, _InputIterator __last,\n-\t       flag_type __flags = regex_constants::ECMAScript)\n-        { return this->assign(string_type(__first, __last), __flags); }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      /**\n-       * @brief Assigns a new regular expression to a regex object.\n-       *\n-       * @param l     An initializer list representing a regular expression.\n-       * @param flags Syntax option flags.\n-       *\n-       * @throws regex_error if @p l does not contain a valid regular\n-       * expression pattern interpreted according to @p flags.  If regex_error\n-       * is thrown, the object remains unchanged.\n-       */\n-      basic_regex&\n-      assign(initializer_list<_Ch_type> __l,\n-\t     flag_type __f = regex_constants::ECMAScript)\n-      { return this->assign(__l.begin(), __l.end(), __f); }\n-#endif\n-\n-      // [7.8.4] const operations\n-      /**\n-       * @brief Gets the number of marked subexpressions within the regular\n-       * expression.\n-       */\n-      unsigned int\n-      mark_count() const\n-      { return _M_mark_count; }\n-      \n-      /**\n-       * @brief Gets the flags used to construct the regular expression\n-       * or in the last call to assign().\n-       */\n-      flag_type\n-      flags() const\n-      { return _M_flags; }\n-      \n-      // [7.8.5] locale\n-      /**\n-       * @brief Imbues the regular expression object with the given locale.\n-       *\n-       * @param loc A locale.\n-       */\n-      locale_type\n-      imbue(locale_type __loc)\n-      { return _M_traits.imbue(__loc); }\n-      \n-      /**\n-       * @brief Gets the locale currently imbued in the regular expression\n-       *        object.\n-       */\n-      locale_type\n-      getloc() const\n-      { return _M_traits.getloc(); }\n-      \n-      // [7.8.6] swap\n-      /**\n-       * @brief Swaps the contents of two regular expression objects.\n-       *\n-       * @param rhs Another regular expression object.\n-       */\n-      void\n-      swap(basic_regex& __rhs)\n-      {\n-\tstd::swap(_M_flags,      __rhs._M_flags);\n-\tstd::swap(_M_pattern,    __rhs._M_pattern);\n-\tstd::swap(_M_mark_count, __rhs._M_mark_count);\n-\tstd::swap(_M_traits,     __rhs._M_traits);\n-      }\n-      \n-    private:\n-      /**\n-       * @brief Compiles a regular expression pattern into a NFA.\n-       * @todo Implement this function.\n-       */\n-      void _M_compile();\n-\n-    protected:\n-      flag_type    _M_flags;\n-      string_type  _M_pattern;\n-      unsigned int _M_mark_count;\n-      _Rx_traits   _M_traits;\n-    };\n-  \n-  /** @brief Standard regular expressions. */\n-  typedef basic_regex<char>    regex;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  /** @brief Standard wide-character regular expressions. */\n-  typedef basic_regex<wchar_t> wregex;\n-#endif\n-\n-\n-  // [7.8.6] basic_regex swap\n-  /**\n-   * @brief Swaps the contents of two regular expression objects.\n-   * @param lhs First regular expression.\n-   * @param rhs Second regular expression.\n-   */\n-  template<typename _Ch_type, typename _Rx_traits>\n-    inline void\n-    swap(basic_regex<_Ch_type, _Rx_traits>& __lhs,\n-\t basic_regex<_Ch_type, _Rx_traits>& __rhs)\n-    { __lhs.swap(__rhs); }\n-\n-\n-  // [7.9] Class template sub_match\n-  /**\n-   * A sequence of characters matched by a particular marked sub-expression.\n-   *\n-   * An object of this class is essentially a pair of iterators marking a\n-   * matched subexpression within a regular expression pattern match. Such\n-   * objects can be converted to and compared with std::basic_string objects\n-   * of a similar base character type as the pattern matched by the regular\n-   * expression.\n-   *\n-   * The iterators that make up the pair are the usual half-open interval\n-   * referencing the actual original pattern matched.\n-   */\n-  template<typename _BiIter>\n-    class sub_match : public std::pair<_BiIter, _BiIter>\n-    {\n-    public:\n-      typedef typename iterator_traits<_BiIter>::value_type      value_type;\n-      typedef typename iterator_traits<_BiIter>::difference_type\n-                                                            difference_type;\n-      typedef _BiIter                                              iterator;\n-\n-    public:\n-      bool matched;\n-      \n-      /**\n-       * Gets the length of the matching sequence.\n-       */\n-      difference_type\n-      length() const\n-      { return this->matched ? std::distance(this->first, this->second) : 0; }\n-\n-      /**\n-       * @brief Gets the matching sequence as a string.\n-       *\n-       * @returns the matching sequence as a string.\n-       *\n-       * This is the implicit conversion operator.  It is identical to the\n-       * str() member function except that it will want to pop up in\n-       * unexpected places and cause a great deal of confusion and cursing\n-       * from the unwary.\n-       */\n-      operator basic_string<value_type>() const\n-      {\n-\treturn this->matched\n-\t  ? std::basic_string<value_type>(this->first, this->second)\n-\t  : std::basic_string<value_type>();\n-      }\n-      \n-      /**\n-       * @brief Gets the matching sequence as a string.\n-       *\n-       * @returns the matching sequence as a string.\n-       */\n-      basic_string<value_type>\n-      str() const\n-      {\n-\treturn this->matched\n-\t  ? std::basic_string<value_type>(this->first, this->second)\n-\t  : std::basic_string<value_type>();\n-      }\n-      \n-      /**\n-       * @brief Compares this and another matched sequence.\n-       *\n-       * @param s Another matched sequence to compare to this one.\n-       *\n-       * @retval <0 this matched sequence will collate before @p s.\n-       * @retval =0 this matched sequence is equivalent to @p s.\n-       * @retval <0 this matched sequence will collate after @p s.\n-       */\n-      int\n-      compare(const sub_match& __s) const\n-      { return this->str().compare(__s.str()); }\n-\n-      /**\n-       * @brief Compares this sub_match to a string.\n-       *\n-       * @param s A string to compare to this sub_match.\n-       *\n-       * @retval <0 this matched sequence will collate before @p s.\n-       * @retval =0 this matched sequence is equivalent to @p s.\n-       * @retval <0 this matched sequence will collate after @p s.\n-       */\n-      int\n-      compare(const basic_string<value_type>& __s) const\n-      { return this->str().compare(__s); }\n-      \n-      /**\n-       * @brief Compares this sub_match to a C-style string.\n-       *\n-       * @param s A C-style string to compare to this sub_match.\n-       *\n-       * @retval <0 this matched sequence will collate before @p s.\n-       * @retval =0 this matched sequence is equivalent to @p s.\n-       * @retval <0 this matched sequence will collate after @p s.\n-       */\n-      int\n-      compare(const value_type* __s) const\n-      { return this->str().compare(__s); }\n-    };\n-  \n-  \n-  /** @brief Standard regex submatch over a C-style null-terminated string. */\n-  typedef sub_match<const char*>             csub_match;\n-  /** @brief Standard regex submatch over a standard string. */\n-  typedef sub_match<string::const_iterator>  ssub_match;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  /** @brief Regex submatch over a C-style null-terminated wide string. */\n-  typedef sub_match<const wchar_t*>          wcsub_match;\n-  /** @brief Regex submatch over a standard wide string. */\n-  typedef sub_match<wstring::const_iterator> wssub_match;\n-#endif\n-\n-  // [7.9.2] sub_match non-member operators\n-  \n-  /**\n-   * @brief Tests the equivalence of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator==(const sub_match<_BiIter>& __lhs,\n-\t       const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) == 0; }\n-\n-  /**\n-   * @brief Tests the inequivalence of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator!=(const sub_match<_BiIter>& __lhs,\n-\t       const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) != 0; }\n-\n-  /**\n-   * @brief Tests the ordering of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator<(const sub_match<_BiIter>& __lhs,\n-\t      const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) < 0; }\n-\n-  /**\n-   * @brief Tests the ordering of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator<=(const sub_match<_BiIter>& __lhs,\n-\t       const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) <= 0; }\n-\n-  /**\n-   * @brief Tests the ordering of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator>=(const sub_match<_BiIter>& __lhs,\n-\t       const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) >= 0; }\n-\n-  /**\n-   * @brief Tests the ordering of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator>(const sub_match<_BiIter>& __lhs,\n-\t      const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) > 0; }\n-\n-  /**\n-   * @brief Tests the equivalence of a string and a regular expression\n-   *        submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator==(const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs == __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the inequivalence of a string and a regular expression\n-   *        submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator!=(const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs != __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator<(const basic_string<\n-\t      typename iterator_traits<_Bi_iter>::value_type,\n-\t      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n-     { return __lhs < __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator>(const basic_string<\n-\t      typename iterator_traits<_Bi_iter>::value_type, \n-\t      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs > __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator>=(const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs >= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator<=(const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs <= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the equivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator==(const sub_match<_Bi_iter>& __lhs,\n-\t       const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() == __rhs; }\n-\n-  /**\n-   * @brief Tests the inequivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator!=(const sub_match<_Bi_iter>& __lhs,\n-\t       const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() != __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n-    inline bool\n-    operator<(const sub_match<_Bi_iter>& __lhs,\n-\t      const basic_string<\n-\t      typename iterator_traits<_Bi_iter>::value_type,\n-\t      _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() < __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n-    inline bool\n-    operator>(const sub_match<_Bi_iter>& __lhs,\n-\t      const basic_string<\n-\t      typename iterator_traits<_Bi_iter>::value_type,\n-\t      _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() > __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n-    inline bool\n-    operator>=(const sub_match<_Bi_iter>& __lhs,\n-\t       const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() >= __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n-    inline bool\n-    operator<=(const sub_match<_Bi_iter>& __lhs,\n-\t       const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() <= __rhs; }\n-\n-  /**\n-   * @brief Tests the equivalence of a C string and a regular expression\n-   *        submatch.\n-   * @param lhs A C string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator==(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs == __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the inequivalence of an iterator value and a regular\n-   *        expression submatch.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator!=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs != __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t      const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs < __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t      const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs > __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs >= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs <= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the equivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A pointer to a string?\n-   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator==(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() == __rhs; }\n-\n-  /**\n-   * @brief Tests the inequivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A pointer to a string.\n-   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator!=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() != __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<(const sub_match<_Bi_iter>& __lhs,\n-\t      typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() < __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>(const sub_match<_Bi_iter>& __lhs,\n-\t      typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() > __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() >= __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() <= __rhs; }\n-\n-  /**\n-   * @brief Tests the equivalence of a string and a regular expression\n-   *        submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator==(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs == __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the inequivalence of a string and a regular expression\n-   *        submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator!=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs != __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t      const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs < __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t      const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs > __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs >= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs <= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the equivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator==(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() == __rhs; }\n-\n-  /**\n-   * @brief Tests the inequivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator!=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() != __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<(const sub_match<_Bi_iter>& __lhs,\n-\t      typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() < __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>(const sub_match<_Bi_iter>& __lhs,\n-\t      typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() > __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() >= __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() <= __rhs; }\n-\n-  /**\n-   * @brief Inserts a matched string into an output stream.\n-   *\n-   * @param os The output stream.\n-   * @param m  A submatch string.\n-   *\n-   * @returns the output stream with the submatch string inserted.\n-   */\n-  template<typename _Ch_type, typename _Ch_traits, typename _Bi_iter>\n-    inline\n-    basic_ostream<_Ch_type, _Ch_traits>&\n-    operator<<(basic_ostream<_Ch_type, _Ch_traits>& __os,\n-\t       const sub_match<_Bi_iter>& __m)\n-    { return __os << __m.str(); }\n-\n-  // [7.10] Class template match_results\n-  /**\n-   * @brief The results of a match or search operation.\n-   *\n-   * A collection of character sequences representing the result of a regular\n-   * expression match.  Storage for the collection is allocated and freed as\n-   * necessary by the member functions of class template match_results.\n-   *\n-   * This class satisfies the Sequence requirements, with the exception that\n-   * only the operations defined for a const-qualified Sequence are supported.\n-   *\n-   * The sub_match object stored at index 0 represents sub-expression 0, i.e.\n-   * the whole match. In this case the sub_match member matched is always true.\n-   * The sub_match object stored at index n denotes what matched the marked\n-   * sub-expression n within the matched expression. If the sub-expression n\n-   * participated in a regular expression match then the sub_match member\n-   * matched evaluates to true, and members first and second denote the range\n-   * of characters [first, second) which formed that match. Otherwise matched\n-   * is false, and members first and second point to the end of the sequence\n-   * that was searched.\n-   *\n-   * @nosubgrouping\n-   */\n-  template<typename _Bi_iter,\n-\t   typename _Allocator = allocator<sub_match<_Bi_iter> > >\n-    class match_results\n-    : private std::vector<std::_GLIBCXX_TR1 sub_match<_Bi_iter>, _Allocator>\n-    {\n-    private:\n-      typedef std::vector<std::_GLIBCXX_TR1 sub_match<_Bi_iter>, _Allocator>\n-                                                              _Base_type;\n-\n-    public:\n-      /**\n-       * @name 10.? Public Types\n-       */\n-      //@{\n-      typedef sub_match<_Bi_iter>                             value_type;\n-      typedef typename _Allocator::const_reference            const_reference;\n-      typedef const_reference                                 reference;\n-      typedef typename _Base_type::const_iterator             const_iterator;\n-      typedef const_iterator                                  iterator;\n-      typedef typename iterator_traits<_Bi_iter>::difference_type\n-                                                              difference_type;\n-      typedef typename _Allocator::size_type                  size_type;\n-      typedef _Allocator                                      allocator_type;\n-      typedef typename iterator_traits<_Bi_iter>::value_type  char_type;\n-      typedef basic_string<char_type>                         string_type;\n-      //@}\n-  \n-    public:\n-      /**\n-       * @name 10.1 Construction, Copying, and Destruction\n-       */\n-      //@{\n-\n-      /**\n-       * @brief Constructs a default %match_results container.\n-       * @post size() returns 0 and str() returns an empty string.\n-       */\n-      explicit\n-      match_results(const _Allocator& __a = _Allocator())\n-      : _Base_type(__a), _M_matched(false)\n-      { }\n-\n-      /**\n-       * @brief Copy constructs a %match_results.\n-       */\n-      match_results(const match_results& __rhs)\n-      : _Base_type(__rhs), _M_matched(__rhs._M_matched),\n-\t_M_prefix(__rhs._M_prefix), _M_suffix(__rhs._M_suffix)\n-      { }\n-\n-      /**\n-       * @brief Assigns rhs to *this.\n-       */\n-      match_results&\n-      operator=(const match_results& __rhs)\n-      {\n-\tmatch_results __tmp(__rhs);\n-\tthis->swap(__tmp);\n-\treturn *this;\n-      }\n-\n-      /**\n-       * @brief Destroys a %match_results object.\n-       */\n-      ~match_results()\n-      { }\n-      \n-      //@}\n-\n-      /**\n-       * @name 10.2 Size\n-       */\n-      //@{\n-\n-      /**\n-       * @brief Gets the number of matches and submatches.\n-       *\n-       * The number of matches for a given regular expression will be either 0\n-       * if there was no match or mark_count() + 1 if a match was successful.\n-       * Some matches may be empty.\n-       *\n-       * @returns the number of matches found.\n-       */\n-      size_type\n-      size() const\n-      { return _M_matched ? _Base_type::size() + 1 : 0; }\n-      \n-      //size_type\n-      //max_size() const;\n-      using _Base_type::max_size;\n-\n-      /**\n-       * @brief Indicates if the %match_results contains no results.\n-       * @retval true The %match_results object is empty.\n-       * @retval false The %match_results object is not empty.\n-       */\n-      bool\n-      empty() const\n-      { return size() == 0; }\n-      \n-      //@}\n-\n-      /**\n-       * @name 10.3 Element Access\n-       */\n-      //@{\n-\n-      /**\n-       * @brief Gets the length of the indicated submatch.\n-       * @param sub indicates the submatch.\n-       *\n-       * This function returns the length of the indicated submatch, or the\n-       * length of the entire match if @p sub is zero (the default).\n-       */\n-      difference_type\n-      length(size_type __sub = 0) const\n-      { return _M_matched ? this->str(__sub).length() : 0; }\n-\n-      /**\n-       * @brief Gets the offset of the beginning of the indicated submatch.\n-       * @param sub indicates the submatch.\n-       *\n-       * This function returns the offset from the beginning of the target\n-       * sequence to the beginning of the submatch, unless the value of @p sub\n-       * is zero (the default), in which case this function returns the offset\n-       * from the beginning of the target sequence to the beginning of the\n-       * match.\n-       */\n-      difference_type\n-      position(size_type __sub = 0) const\n-      {\n-\treturn _M_matched ? std::distance(this->prefix().first,\n-\t\t\t\t\t  (*this)[__sub].first) : 0;\n-      }\n-\n-      /**\n-       * @brief Gets the match or submatch converted to a string type.\n-       * @param sub indicates the submatch.\n-       *\n-       * This function gets the submatch (or match, if @p sub is zero) extracted\n-       * from the target range and converted to the associated string type.\n-       */\n-      string_type\n-      str(size_type __sub = 0) const\n-      { return _M_matched ? (*this)[__sub].str() : string_type(); }\n-      \n-      /**\n-       * @brief Gets a %sub_match reference for the match or submatch.\n-       * @param sub indicates the submatch.\n-       *\n-       * This function gets a reference to the indicated submatch, or the entire\n-       * match if @p sub is zero.\n-       *\n-       * If @p sub >= size() then this function returns a %sub_match with a\n-       * special value indicating no submatch.\n-       */\n-      const_reference\n-      operator[](size_type __sub) const\n-      { return _Base_type::operator[](__sub); }\n-\n-      /**\n-       * @brief Gets a %sub_match representing the match prefix.\n-       *\n-       * This function gets a reference to a %sub_match object representing the\n-       * part of the target range between the start of the target range and the\n-       * start of the match.\n-       */\n-      const_reference\n-      prefix() const\n-      { return _M_prefix; }\n-\n-      /**\n-       * @brief Gets a %sub_match representing the match suffix.\n-       *\n-       * This function gets a reference to a %sub_match object representing the\n-       * part of the target range between the end of the match and the end of\n-       * the target range.\n-       */\n-      const_reference\n-      suffix() const\n-      { return _M_suffix; }\n-\n-      /**\n-       * @brief Gets an iterator to the start of the %sub_match collection.\n-       */\n-      const_iterator\n-      begin() const\n-      { return _Base_type::begin(); }\n-      \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      /**\n-       * @brief Gets an iterator to the start of the %sub_match collection.\n-       */\n-      const_iterator\n-      cbegin() const\n-      { return _Base_type::begin(); }\n-#endif\n-\n-      /**\n-       * @brief Gets an iterator to one-past-the-end of the collection.\n-       */\n-      const_iterator\n-      end() const\n-      { return _Base_type::end(); }\n-      \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      /**\n-       * @brief Gets an iterator to one-past-the-end of the collection.\n-       */\n-      const_iterator\n-      cend() const\n-      { return _Base_type::end(); }\n-#endif\n-\n-      //@}\n-\n-      /**\n-       * @name 10.4 Formatting\n-       *\n-       * These functions perform formatted substitution of the matched character\n-       * sequences into their target.  The format specifiers and escape sequences\n-       * accepted by these functions are determined by their @p flags parameter \n-       * as documented above.\n-       */\n-       //@{\n-\n-      /**\n-       * @todo Implement this function.\n-       */\n-      template<typename _Out_iter>\n-        _Out_iter\n-        format(_Out_iter __out, const string_type& __fmt,\n-\t       regex_constants::match_flag_type __flags\n-\t       = regex_constants::format_default) const;\n-\n-      /**\n-       * @todo Implement this function.\n-       */\n-      string_type\n-      format(const string_type& __fmt,\n-\t     regex_constants::match_flag_type __flags\n-\t     = regex_constants::format_default) const;\n-\n-      //@} \n-\n-      /**\n-       * @name 10.5 Allocator\n-       */\n-      //@{ \n-\n-      /**\n-       * @brief Gets a copy of the allocator.\n-       */\n-      //allocator_type\n-      //get_allocator() const;\n-      using _Base_type::get_allocator;\n-      \n-      //@} \n-\n-      /**\n-       * @name 10.6 Swap\n-       */\n-       //@{ \n-\n-      /**\n-       * @brief Swaps the contents of two match_results.\n-       */\n-      void\n-      swap(match_results& __that)\n-      {\n-\t_Base_type::swap(__that);\n-\tstd::swap(_M_matched, __that._M_matched);\n-\tstd::swap(_M_prefix,  __that._M_prefix);\n-\tstd::swap(_M_suffix,  __that._M_suffix);\n-      }\n-      //@} \n-      \n-    private:\n-      bool       _M_matched;\n-      value_type _M_prefix;\n-      value_type _M_suffix;\n-    };\n-  \n-  typedef match_results<const char*>             cmatch;\n-  typedef match_results<string::const_iterator>  smatch;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  typedef match_results<const wchar_t*>          wcmatch;\n-  typedef match_results<wstring::const_iterator> wsmatch;\n-#endif\n-\n-  // match_results comparisons\n-  /**\n-   * @brief Compares two match_results for equality.\n-   * @returns true if the two objects refer to the same match,\n-   * false otherwise.\n-   * @todo Implement this function.\n-   */\n-  template<typename _Bi_iter, typename _Allocator>\n-    inline bool\n-    operator==(const match_results<_Bi_iter, _Allocator>& __m1,\n-\t       const match_results<_Bi_iter, _Allocator>& __m2);\n-\n-  /**\n-   * @brief Compares two match_results for inequality.\n-   * @returns true if the two objects do not refer to the same match,\n-   * false otherwise.\n-   */\n-  template<typename _Bi_iter, class _Allocator>\n-    inline bool\n-    operator!=(const match_results<_Bi_iter, _Allocator>& __m1,\n-\t       const match_results<_Bi_iter, _Allocator>& __m2)\n-    { return !(__m1 == __m2); }\n-\n-  // [7.10.6] match_results swap\n-  /**\n-   * @brief Swaps two match results.\n-   * @param lhs A match result.\n-   * @param rhs A match result.\n-   *\n-   * The contents of the two match_results objects are swapped.\n-   */\n-  template<typename _Bi_iter, typename _Allocator>\n-    inline void\n-    swap(match_results<_Bi_iter, _Allocator>& __lhs,\n-\t match_results<_Bi_iter, _Allocator>& __rhs)\n-    { __lhs.swap(__rhs); }\n-\n-  // [7.11.2] Function template regex_match\n-  /**\n-   * @name Matching, Searching, and Replacing\n-   */\n-  //@{\n-\n-  /**\n-   * @brief Determines if there is a match between the regular expression @p e\n-   * and all of the character sequence [first, last).\n-   *\n-   * @param first Beginning of the character sequence to match.\n-   * @param last  One-past-the-end of the character sequence to match.\n-   * @param m     The match results.\n-   * @param re    The regular expression.\n-   * @param flags Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   *\n-   * @throws an exception of type regex_error.\n-   *\n-   * @todo Implement this function.\n-   */\n-  template<typename _Bi_iter, typename _Allocator,\n-\t   typename _Ch_type, typename _Rx_traits>\n-    bool\n-    regex_match(_Bi_iter __first, _Bi_iter __last,\n-\t\tmatch_results<_Bi_iter, _Allocator>& __m,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __flags\n-\t\t= regex_constants::match_default);\n-\n-  /**\n-   * @brief Indicates if there is a match between the regular expression @p e\n-   * and all of the character sequence [first, last).\n-   *\n-   * @param first Beginning of the character sequence to match.\n-   * @param last  One-past-the-end of the character sequence to match.\n-   * @param re    The regular expression.\n-   * @param flags Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   *\n-   * @throws an exception of type regex_error.\n-   */\n-  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>\n-    bool\n-    regex_match(_Bi_iter __first, _Bi_iter __last,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __flags\n-\t\t= regex_constants::match_default)\n-    { \n-      match_results<_Bi_iter> __what;\n-      return regex_match(__first, __last, __what, __re, __flags);\n-    }\n-\n-  /**\n-   * @brief Determines if there is a match between the regular expression @p e\n-   * and a C-style null-terminated string.\n-   *\n-   * @param s  The C-style null-terminated string to match.\n-   * @param m  The match results.\n-   * @param re The regular expression.\n-   * @param f  Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   *\n-   * @throws an exception of type regex_error.\n-   */\n-  template<typename _Ch_type, typename _Allocator, typename _Rx_traits>\n-    inline bool\n-    regex_match(const _Ch_type* __s,\n-\t\tmatch_results<const _Ch_type*, _Allocator>& __m,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __f\n-\t\t= regex_constants::match_default)\n-    { return regex_match(__s, __s + _Rx_traits::length(__s), __m, __re, __f); }\n-\n-  /**\n-   * @brief Determines if there is a match between the regular expression @p e\n-   * and a string.\n-   *\n-   * @param s     The string to match.\n-   * @param m     The match results.\n-   * @param re    The regular expression.\n-   * @param flags Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   *\n-   * @throws an exception of type regex_error.\n-   */\n-  template<typename _Ch_traits, typename _Ch_alloc,\n-\t   typename _Allocator, typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n-\t\tmatch_results<typename basic_string<_Ch_type, \n-\t\t_Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __flags\n-\t\t= regex_constants::match_default)\n-    { return regex_match(__s.begin(), __s.end(), __m, __re, __flags); }\n-\n-  /**\n-   * @brief Indicates if there is a match between the regular expression @p e\n-   * and a C-style null-terminated string.\n-   *\n-   * @param s  The C-style null-terminated string to match.\n-   * @param re The regular expression.\n-   * @param f  Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   *\n-   * @throws an exception of type regex_error.\n-   */\n-  template<typename _Ch_type, class _Rx_traits>\n-    inline bool\n-    regex_match(const _Ch_type* __s,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __f\n-\t\t= regex_constants::match_default)\n-    { return regex_match(__s, __s + _Rx_traits::length(__s), __re, __f); }\n-\n-  /**\n-   * @brief Indicates if there is a match between the regular expression @p e\n-   * and a string.\n-   *\n-   * @param s     [IN] The string to match.\n-   * @param re    [IN] The regular expression.\n-   * @param flags [IN] Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   *\n-   * @throws an exception of type regex_error.\n-   */\n-  template<typename _Ch_traits, typename _Str_allocator,\n-\t   typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_match(const basic_string<_Ch_type, _Ch_traits, _Str_allocator>& __s,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __flags\n-\t\t= regex_constants::match_default)\n-    { return regex_match(__s.begin(), __s.end(), __re, __flags); }\n-\n-  // [7.11.3] Function template regex_search\n-  /**\n-   * Searches for a regular expression within a range.\n-   * @param first [IN]  The start of the string to search.\n-   * @param last  [IN]  One-past-the-end of the string to search.\n-   * @param m     [OUT] The match results.\n-   * @param re    [IN]  The regular expression to search for.\n-   * @param flags [IN]  Search policy flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string, the content of %m is\n-   *               undefined.\n-   *\n-   * @throws an exception of type regex_error.\n-   *\n-   * @todo Implement this function.\n-   */\n-  template<typename _Bi_iter, typename _Allocator,\n-\t   typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_search(_Bi_iter __first, _Bi_iter __last,\n-\t\t match_results<_Bi_iter, _Allocator>& __m,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\t regex_constants::match_flag_type __flags\n-\t\t = regex_constants::match_default);\n-\n-  /**\n-   * Searches for a regular expression within a range.\n-   * @param first [IN]  The start of the string to search.\n-   * @param last  [IN]  One-past-the-end of the string to search.\n-   * @param re    [IN]  The regular expression to search for.\n-   * @param flags [IN]  Search policy flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string.\n-   * @doctodo\n-   *\n-   * @throws an exception of type regex_error.\n-   */\n-  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_search(_Bi_iter __first, _Bi_iter __last,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\t regex_constants::match_flag_type __flags\n-\t\t = regex_constants::match_default)\n-    {\n-      match_results<_Bi_iter> __what;\n-      return regex_search(__first, __last, __what, __re, __flags);\n-    }\n-\n-  /**\n-   * @brief Searches for a regular expression within a C-string.\n-   * @param s [IN]  A C-string to search for the regex.\n-   * @param m [OUT] The set of regex matches.\n-   * @param e [IN]  The regex to search for in @p s.\n-   * @param f [IN]  The search flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string, the content of %m is\n-   *               undefined.\n-   * @doctodo\n-   *\n-   * @throws an exception of type regex_error.\n-   */\n-  template<typename _Ch_type, class _Allocator, class _Rx_traits>\n-    inline bool\n-    regex_search(const _Ch_type* __s,\n-\t\t match_results<const _Ch_type*, _Allocator>& __m,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t regex_constants::match_flag_type __f\n-\t\t = regex_constants::match_default)\n-    { return regex_search(__s, __s + _Rx_traits::length(__s), __m, __e, __f); }\n-\n-  /**\n-   * @brief Searches for a regular expression within a C-string.\n-   * @param s [IN]  The C-string to search.\n-   * @param e [IN]  The regular expression to search for.\n-   * @param f [IN]  Search policy flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string.\n-   * @doctodo\n-   *\n-   * @throws an exception of type regex_error.\n-   */\n-  template<typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_search(const _Ch_type* __s,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t regex_constants::match_flag_type __f\n-\t\t = regex_constants::match_default)\n-    { return regex_search(__s, __s + _Rx_traits::length(__s), __e, __f); }\n-\n-  /**\n-   * @brief Searches for a regular expression within a string.\n-   * @param s     [IN]  The string to search.\n-   * @param e     [IN]  The regular expression to search for.\n-   * @param flags [IN]  Search policy flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string.\n-   * @doctodo\n-   *\n-   * @throws an exception of type regex_error.\n-   */\n-  template<typename _Ch_traits, typename _String_allocator,\n-\t   typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_search(const basic_string<_Ch_type, _Ch_traits,\n-\t\t _String_allocator>& __s,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t regex_constants::match_flag_type __flags\n-\t\t = regex_constants::match_default)\n-    { return regex_search(__s.begin(), __s.end(), __e, __flags); }\n-\n-  /**\n-   * @brief Searches for a regular expression within a string.\n-   * @param s [IN]  A C++ string to search for the regex.\n-   * @param m [OUT] The set of regex matches.\n-   * @param e [IN]  The regex to search for in @p s.\n-   * @param f [IN]  The search flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string, the content of %m is\n-   *               undefined.\n-   *\n-   * @throws an exception of type regex_error.\n-   */\n-  template<typename _Ch_traits, typename _Ch_alloc,\n-\t   typename _Allocator, typename _Ch_type,\n-\t   typename _Rx_traits>\n-    inline bool\n-    regex_search(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n-\t\t match_results<typename basic_string<_Ch_type,\n-\t\t _Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t regex_constants::match_flag_type __f\n-\t\t = regex_constants::match_default)\n-    { return regex_search(__s.begin(), __s.end(), __m, __e, __f); }\n-\n-  // tr1 [7.11.4] std [28.11.4] Function template regex_replace\n-  /**\n-   * @doctodo\n-   * @param out\n-   * @param first\n-   * @param last\n-   * @param e\n-   * @param fmt\n-   * @param flags\n-   *\n-   * @returns out\n-   * @throws an exception of type regex_error.\n-   *\n-   * @todo Implement this function.\n-   */\n-  template<typename _Out_iter, typename _Bi_iter,\n-\t   typename _Rx_traits, typename _Ch_type>\n-    inline _Out_iter\n-    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,\n-\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t  const basic_string<_Ch_type>& __fmt,\n-\t\t  regex_constants::match_flag_type __flags\n-\t\t  = regex_constants::match_default);\n-\n-  /**\n-   * @doctodo\n-   * @param s\n-   * @param e\n-   * @param fmt\n-   * @param flags\n-   *\n-   * @returns a copy of string @p s with replacements.\n-   *\n-   * @throws an exception of type regex_error.\n-   */\n-  template<typename _Rx_traits, typename _Ch_type>\n-    inline basic_string<_Ch_type>\n-    regex_replace(const basic_string<_Ch_type>& __s,\n-\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t  const basic_string<_Ch_type>& __fmt,\n-\t\t  regex_constants::match_flag_type __flags\n-\t\t  = regex_constants::match_default)\n-    {\n-      std::string __result;\n-      regex_replace(std::back_inserter(__result),\n-\t\t    __s.begin(), __s.end(), __e, __fmt, __flags);\n-      return __result;\n-    }\n-\n-  //@}\n-\n-  // tr1 [7.12.1] std [28.12] Class template regex_iterator\n-  /**\n-   * An iterator adaptor that will provide repeated calls of regex_search over \n-   * a range until no more matches remain.\n-   */\n-  template<typename _Bi_iter,\n-\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n-\t   typename _Rx_traits = regex_traits<_Ch_type> >\n-    class regex_iterator\n-    {\n-    public:\n-      typedef basic_regex<_Ch_type, _Rx_traits>  regex_type;\n-      typedef match_results<_Bi_iter>            value_type;\n-      typedef std::ptrdiff_t                     difference_type;\n-      typedef const value_type*                  pointer;\n-      typedef const value_type&                  reference;\n-      typedef std::forward_iterator_tag          iterator_category;\n-\n-    public:\n-      /**\n-       * @brief Provides a singular iterator, useful for indicating\n-       * one-past-the-end of a range.\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      regex_iterator();\n-      \n-      /**\n-       * Constructs a %regex_iterator...\n-       * @param a  [IN] The start of a text range to search.\n-       * @param b  [IN] One-past-the-end of the text range to search.\n-       * @param re [IN] The regular expression to match.\n-       * @param m  [IN] Policy flags for match rules.\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n-\t\t     regex_constants::match_flag_type __m\n-\t\t     = regex_constants::match_default);\n-\n-      /**\n-       * Copy constructs a %regex_iterator.\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      regex_iterator(const regex_iterator& __rhs);\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      regex_iterator&\n-      operator=(const regex_iterator& __rhs);\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      bool\n-      operator==(const regex_iterator& __rhs);\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      bool\n-      operator!=(const regex_iterator& __rhs);\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      const value_type&\n-      operator*();\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      const value_type*\n-      operator->();\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      regex_iterator&\n-      operator++();\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      regex_iterator\n-      operator++(int);\n-      \n-    private:\n-      // these members are shown for exposition only:\n-      _Bi_iter                         begin;\n-      _Bi_iter                         end;\n-      const regex_type*                pregex;\n-      regex_constants::match_flag_type flags;\n-      match_results<_Bi_iter>          match;\n-    };\n-  \n-  typedef regex_iterator<const char*>             cregex_iterator;\n-  typedef regex_iterator<string::const_iterator>  sregex_iterator;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  typedef regex_iterator<const wchar_t*>          wcregex_iterator;\n-  typedef regex_iterator<wstring::const_iterator> wsregex_iterator;\n-#endif\n-\n-  // [7.12.2] Class template regex_token_iterator\n-  /**\n-   * Iterates over submatches in a range (or @a splits a text string).\n-   *\n-   * The purpose of this iterator is to enumerate all, or all specified,\n-   * matches of a regular expression within a text range.  The dereferenced\n-   * value of an iterator of this class is a std::tr1::sub_match object.\n-   */\n-  template<typename _Bi_iter,\n-\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n-\t   typename _Rx_traits = regex_traits<_Ch_type> >\n-    class regex_token_iterator\n-    {\n-    public:\n-      typedef basic_regex<_Ch_type, _Rx_traits> regex_type;\n-      typedef sub_match<_Bi_iter>               value_type;\n-      typedef std::ptrdiff_t                    difference_type;\n-      typedef const value_type*                 pointer;\n-      typedef const value_type&                 reference;\n-      typedef std::forward_iterator_tag         iterator_category;\n-      \n-    public:\n-      /**\n-       * @brief Default constructs a %regex_token_iterator.\n-       * @todo Implement this function.\n-       * \n-       * A default-constructed %regex_token_iterator is a singular iterator\n-       * that will compare equal to the one-past-the-end value for any\n-       * iterator of the same type.\n-       */\n-      regex_token_iterator();\n-      \n-      /**\n-       * Constructs a %regex_token_iterator...\n-       * @param a          [IN] The start of the text to search.\n-       * @param b          [IN] One-past-the-end of the text to search.\n-       * @param re         [IN] The regular expression to search for.\n-       * @param submatch   [IN] Which submatch to return.  There are some\n-       *                        special values for this parameter:\n-       *                        - -1 each enumerated subexpression does NOT\n-       *                          match the regular expression (aka field\n-       *                          splitting)\n-       *                        - 0 the entire string matching the\n-       *                          subexpression is returned for each match\n-       *                          within the text.\n-       *                        - >0 enumerates only the indicated\n-       *                          subexpression from a match within the text.\n-       * @param m          [IN] Policy flags for match rules.\n-       *\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      regex_token_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n-\t\t\t   int __submatch = 0,\n-\t\t\t   regex_constants::match_flag_type __m\n-\t\t\t   = regex_constants::match_default);\n-\n-      /**\n-       * Constructs a %regex_token_iterator...\n-       * @param a          [IN] The start of the text to search.\n-       * @param b          [IN] One-past-the-end of the text to search.\n-       * @param re         [IN] The regular expression to search for.\n-       * @param submatches [IN] A list of subexpressions to return for each\n-       *                        regular expression match within the text.\n-       * @param m          [IN] Policy flags for match rules.\n-       *\n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n-\t\t\t   const regex_type& __re,\n-\t\t\t   const std::vector<int>& __submatches,\n-\t\t\t   regex_constants::match_flag_type __m\n-\t\t\t     = regex_constants::match_default);\n-\n-      /**\n-       * Constructs a %regex_token_iterator...\n-       * @param a          [IN] The start of the text to search.\n-       * @param b          [IN] One-past-the-end of the text to search.\n-       * @param re         [IN] The regular expression to search for.\n-       * @param submatches [IN] A list of subexpressions to return for each\n-       *                        regular expression match within the text.\n-       * @param m          [IN] Policy flags for match rules.\n-       \n-       * @todo Implement this function.\n-       * @doctodo\n-       */\n-      template<std::size_t _Nm>\n-        regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n-\t\t\t     const regex_type& __re,\n-\t\t\t     const int (&__submatches)[_Nm],\n-\t\t\t     regex_constants::match_flag_type __m\n-\t\t\t     = regex_constants::match_default);\n-\n-      /**\n-       * @brief Copy constructs a %regex_token_iterator.\n-       * @param rhs [IN] A %regex_token_iterator to copy.\n-       * @todo Implement this function.\n-       */\n-      regex_token_iterator(const regex_token_iterator& __rhs);\n-      \n-      /**\n-       * @brief Assigns a %regex_token_iterator to another.\n-       * @param rhs [IN] A %regex_token_iterator to copy.\n-       * @todo Implement this function.\n-       */\n-      regex_token_iterator&\n-      operator=(const regex_token_iterator& __rhs);\n-      \n-      /**\n-       * @brief Compares a %regex_token_iterator to another for equality.\n-       * @todo Implement this function.\n-       */\n-      bool\n-      operator==(const regex_token_iterator& __rhs);\n-      \n-      /**\n-       * @brief Compares a %regex_token_iterator to another for inequality.\n-       * @todo Implement this function.\n-       */\n-      bool\n-      operator!=(const regex_token_iterator& __rhs);\n-      \n-      /**\n-       * @brief Dereferences a %regex_token_iterator.\n-       * @todo Implement this function.\n-       */\n-      const value_type&\n-      operator*();\n-      \n-      /**\n-       * @brief Selects a %regex_token_iterator member.\n-       * @todo Implement this function.\n-       */\n-      const value_type*\n-      operator->();\n-      \n-      /**\n-       * @brief Increments a %regex_token_iterator.\n-       * @todo Implement this function.\n-       */\n-      regex_token_iterator&\n-      operator++();\n-      \n-      /**\n-       * @brief Postincrements a %regex_token_iterator.\n-       * @todo Implement this function.\n-       */\n-      regex_token_iterator\n-      operator++(int);\n-      \n-    private: // data members for exposition only:\n-      typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> position_iterator;\n-\n-      position_iterator __position;\n-      const value_type* __result;\n-      value_type        __suffix;\n-      std::size_t       __n;\n-      std::vector<int>  __subs;\n-    };\n-\n-  /** @brief Token iterator for C-style NULL-terminated strings. */\n-  typedef regex_token_iterator<const char*>             cregex_token_iterator;\n-  /** @brief Token iterator for standard strings. */\n-  typedef regex_token_iterator<string::const_iterator>  sregex_token_iterator;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  /** @brief Token iterator for C-style NULL-terminated wide strings. */\n-  typedef regex_token_iterator<const wchar_t*>          wcregex_token_iterator;\n-  /** @brief Token iterator for standard wide-character strings. */\n-  typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;\n-#endif\n-  \n-  //@} \n-  \n-_GLIBCXX_END_NAMESPACE_TR1\n-}"}, {"sha": "2f6080a19bf1866cc9b5e830417aa63b30fc5321", "filename": "libstdc++-v3/include/tr1_impl/type_traits", "status": "removed", "additions": 0, "deletions": 506, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,506 +0,0 @@\n-// TR1 type_traits -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/type_traits\n-*  This is an internal header file, included by other library headers.\n-*  You should not attempt to use it directly.\n-*/\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-  /**\n-   * @defgroup metaprogramming Type Traits\n-   * @ingroup utilities\n-   *\n-   * Compile time type transformation and information.\n-   * @{\n-   */\n-\n-  // For use in __is_convertible_simple.\n-  struct __sfinae_types\n-  {\n-    typedef char __one;\n-    typedef struct { char __arr[2]; } __two;\n-  };\n-\n-#define _DEFINE_SPEC_0_HELPER                          \\\n-  template<>\n-\n-#define _DEFINE_SPEC_1_HELPER                          \\\n-  template<typename _Tp>\n-\n-#define _DEFINE_SPEC_2_HELPER                          \\\n-  template<typename _Tp, typename _Cp>\n-\n-#define _DEFINE_SPEC(_Order, _Trait, _Type, _Value)    \\\n-  _DEFINE_SPEC_##_Order##_HELPER                       \\\n-    struct _Trait<_Type>                               \\\n-    : public integral_constant<bool, _Value> { };\n-\n-  // helper classes [4.3].\n-\n-  /// integral_constant\n-  template<typename _Tp, _Tp __v>\n-    struct integral_constant\n-    {\n-      static _GLIBCXX_USE_CONSTEXPR  _Tp    value = __v;\n-      typedef _Tp                           value_type;\n-      typedef integral_constant<_Tp, __v>   type;\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      constexpr operator value_type() { return value; }\n-#endif\n-    };\n-  \n-  /// typedef for true_type\n-  typedef integral_constant<bool, true>     true_type;\n-\n-  /// typedef for false_type\n-  typedef integral_constant<bool, false>    false_type;\n-\n-  template<typename _Tp, _Tp __v>\n-    _GLIBCXX_USE_CONSTEXPR _Tp integral_constant<_Tp, __v>::value;\n-\n-  /// remove_cv\n-  template<typename>\n-    struct remove_cv;\n-\n-  template<typename>\n-    struct __is_void_helper\n-    : public false_type { };\n-  _DEFINE_SPEC(0, __is_void_helper, void, true)\n-\n-  // primary type categories [4.5.1].\n-\n-  /// is_void\n-  template<typename _Tp>\n-    struct is_void\n-    : public integral_constant<bool, (__is_void_helper<typename\n-\t\t\t\t      remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  template<typename>\n-    struct __is_integral_helper\n-    : public false_type { };\n-  _DEFINE_SPEC(0, __is_integral_helper, bool, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, char, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, signed char, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, unsigned char, true)\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  _DEFINE_SPEC(0, __is_integral_helper, wchar_t, true)\n-#endif\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  _DEFINE_SPEC(0, __is_integral_helper, char16_t, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, char32_t, true)\n-#endif\n-  _DEFINE_SPEC(0, __is_integral_helper, short, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, unsigned short, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, int, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, unsigned int, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, long, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, unsigned long, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, long long, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, unsigned long long, true)\n-\n-  /// is_integral\n-  template<typename _Tp>\n-    struct is_integral\n-    : public integral_constant<bool, (__is_integral_helper<typename\n-\t\t\t\t      remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  template<typename>\n-    struct __is_floating_point_helper\n-    : public false_type { };\n-  _DEFINE_SPEC(0, __is_floating_point_helper, float, true)\n-  _DEFINE_SPEC(0, __is_floating_point_helper, double, true)\n-  _DEFINE_SPEC(0, __is_floating_point_helper, long double, true)\n-\n-  /// is_floating_point\n-  template<typename _Tp>\n-    struct is_floating_point\n-    : public integral_constant<bool, (__is_floating_point_helper<typename\n-\t\t\t\t      remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  /// is_array\n-  template<typename>\n-    struct is_array\n-    : public false_type { };\n-\n-  template<typename _Tp, std::size_t _Size>\n-    struct is_array<_Tp[_Size]>\n-    : public true_type { };\n-\n-  template<typename _Tp>\n-    struct is_array<_Tp[]>\n-    : public true_type { };\n-\n-  template<typename>\n-    struct __is_pointer_helper\n-    : public false_type { };\n-  _DEFINE_SPEC(1, __is_pointer_helper, _Tp*, true)\n-\n-  /// is_pointer\n-  template<typename _Tp>\n-    struct is_pointer\n-    : public integral_constant<bool, (__is_pointer_helper<typename\n-\t\t\t\t      remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  /// is_reference\n-  template<typename _Tp>\n-    struct is_reference;\n-\n-  /// is_function\n-  template<typename _Tp>\n-    struct is_function;\n-\n-  template<typename>\n-    struct __is_member_object_pointer_helper\n-    : public false_type { };\n-  _DEFINE_SPEC(2, __is_member_object_pointer_helper, _Tp _Cp::*,\n-\t       !is_function<_Tp>::value)\n-\n-  /// is_member_object_pointer\n-  template<typename _Tp>\n-    struct is_member_object_pointer\n-    : public integral_constant<bool, (__is_member_object_pointer_helper<\n-\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  template<typename>\n-    struct __is_member_function_pointer_helper\n-    : public false_type { };\n-  _DEFINE_SPEC(2, __is_member_function_pointer_helper, _Tp _Cp::*,\n-\t       is_function<_Tp>::value)\n-\n-  /// is_member_function_pointer\n-  template<typename _Tp>\n-    struct is_member_function_pointer\n-    : public integral_constant<bool, (__is_member_function_pointer_helper<\n-\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  /// is_enum\n-  template<typename _Tp>\n-    struct is_enum\n-    : public integral_constant<bool, __is_enum(_Tp)>\n-    { };\n-\n-  /// is_union\n-  template<typename _Tp>\n-    struct is_union\n-    : public integral_constant<bool, __is_union(_Tp)>\n-    { };\n-\n-  /// is_class\n-  template<typename _Tp>\n-    struct is_class\n-    : public integral_constant<bool, __is_class(_Tp)>\n-    { };\n-\n-  /// is_function\n-  template<typename>\n-    struct is_function\n-    : public false_type { };\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...)>\n-    : public true_type { };\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......)>\n-    : public true_type { };\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) const>\n-    : public true_type { };\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) const>\n-    : public true_type { };\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) volatile>\n-    : public true_type { };\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) volatile>\n-    : public true_type { };\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) const volatile>\n-    : public true_type { };\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) const volatile>\n-    : public true_type { };\n-\n-  // composite type traits [4.5.2].\n-  \n-  /// is_arithmetic\n-  template<typename _Tp>\n-    struct is_arithmetic\n-    : public integral_constant<bool, (is_integral<_Tp>::value\n-\t\t\t\t      || is_floating_point<_Tp>::value)>\n-    { };\n-\n-  /// is_fundamental\n-  template<typename _Tp>\n-    struct is_fundamental\n-    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n-\t\t\t\t      || is_void<_Tp>::value)>\n-    { };\n-\n-  /// is_object\n-  template<typename _Tp>\n-    struct is_object\n-    : public integral_constant<bool, !(is_function<_Tp>::value\n-\t\t\t\t       || is_reference<_Tp>::value\n-\t\t\t\t       || is_void<_Tp>::value)>\n-    { };\n-\n-  /// is_member_pointer\n-  template<typename _Tp>\n-    struct is_member_pointer;\n-\n-  /// is_scalar\n-  template<typename _Tp>\n-    struct is_scalar\n-    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n-\t\t\t\t      || is_enum<_Tp>::value\n-\t\t\t\t      || is_pointer<_Tp>::value\n-\t\t\t\t      || is_member_pointer<_Tp>::value)>\n-    { };\n-\n-  /// is_compound\n-  template<typename _Tp>\n-    struct is_compound\n-    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };\n-\n-  /// is_member_pointer\n-  template<typename _Tp>\n-    struct __is_member_pointer_helper\n-    : public false_type { };\n-  _DEFINE_SPEC(2, __is_member_pointer_helper, _Tp _Cp::*, true)\n-\n-  template<typename _Tp>\n-  struct is_member_pointer\n-    : public integral_constant<bool, (__is_member_pointer_helper<\n-\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  // type properties [4.5.3].\n-  /// is_const\n-  template<typename>\n-    struct is_const\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct is_const<_Tp const>\n-    : public true_type { };\n-  \n-  /// is_volatile\n-  template<typename>\n-    struct is_volatile\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct is_volatile<_Tp volatile>\n-    : public true_type { };\n-\n-  /// is_empty\n-  template<typename _Tp>\n-    struct is_empty\n-    : public integral_constant<bool, __is_empty(_Tp)>\n-    { };\n-\n-  /// is_polymorphic\n-  template<typename _Tp>\n-    struct is_polymorphic\n-    : public integral_constant<bool, __is_polymorphic(_Tp)>\n-    { };\n-\n-  /// is_abstract\n-  template<typename _Tp>\n-    struct is_abstract\n-    : public integral_constant<bool, __is_abstract(_Tp)>\n-    { };\n-\n-  /// has_virtual_destructor\n-  template<typename _Tp>\n-    struct has_virtual_destructor\n-    : public integral_constant<bool, __has_virtual_destructor(_Tp)>\n-    { };\n-\n-  /// alignment_of\n-  template<typename _Tp>\n-    struct alignment_of\n-    : public integral_constant<std::size_t, __alignof__(_Tp)> { };\n-  \n-  /// rank\n-  template<typename>\n-    struct rank\n-    : public integral_constant<std::size_t, 0> { };\n-   \n-  template<typename _Tp, std::size_t _Size>\n-    struct rank<_Tp[_Size]>\n-    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n-\n-  template<typename _Tp>\n-    struct rank<_Tp[]>\n-    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n-\n-  /// extent\n-  template<typename, unsigned _Uint = 0>\n-    struct extent\n-    : public integral_constant<std::size_t, 0> { };\n-  \n-  template<typename _Tp, unsigned _Uint, std::size_t _Size>\n-    struct extent<_Tp[_Size], _Uint>\n-    : public integral_constant<std::size_t,\n-\t\t\t       _Uint == 0 ? _Size : extent<_Tp,\n-\t\t\t\t\t\t\t   _Uint - 1>::value>\n-    { };\n-\n-  template<typename _Tp, unsigned _Uint>\n-    struct extent<_Tp[], _Uint>\n-    : public integral_constant<std::size_t,\n-\t\t\t       _Uint == 0 ? 0 : extent<_Tp,\n-\t\t\t\t\t\t       _Uint - 1>::value>\n-    { };\n-\n-  // relationships between types [4.6].\n-\n-  /// is_same\n-  template<typename, typename>\n-    struct is_same\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct is_same<_Tp, _Tp>\n-    : public true_type { };\n-\n-  // const-volatile modifications [4.7.1].\n-\n-  /// remove_const\n-  template<typename _Tp>\n-    struct remove_const\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_const<_Tp const>\n-    { typedef _Tp     type; };\n-  \n-  /// remove_volatile\n-  template<typename _Tp>\n-    struct remove_volatile\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_volatile<_Tp volatile>\n-    { typedef _Tp     type; };\n-  \n-  /// remove_cv\n-  template<typename _Tp>\n-    struct remove_cv\n-    {\n-      typedef typename\n-      remove_const<typename remove_volatile<_Tp>::type>::type     type;\n-    };\n-  \n-  /// add_const\n-  template<typename _Tp>\n-    struct add_const\n-    { typedef _Tp const     type; };\n-   \n-  /// add_volatile\n-  template<typename _Tp>\n-    struct add_volatile\n-    { typedef _Tp volatile     type; };\n-  \n-  /// add_cv\n-  template<typename _Tp>\n-    struct add_cv\n-    {\n-      typedef typename\n-      add_const<typename add_volatile<_Tp>::type>::type     type;\n-    };\n-\n-  // array modifications [4.7.3].\n-\n-  /// remove_extent\n-  template<typename _Tp>\n-    struct remove_extent\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp, std::size_t _Size>\n-    struct remove_extent<_Tp[_Size]>\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_extent<_Tp[]>\n-    { typedef _Tp     type; };\n-\n-  /// remove_all_extents\n-  template<typename _Tp>\n-    struct remove_all_extents\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp, std::size_t _Size>\n-    struct remove_all_extents<_Tp[_Size]>\n-    { typedef typename remove_all_extents<_Tp>::type     type; };\n-\n-  template<typename _Tp>\n-    struct remove_all_extents<_Tp[]>\n-    { typedef typename remove_all_extents<_Tp>::type     type; };\n-\n-  // pointer modifications [4.7.4].\n-\n-  template<typename _Tp, typename>\n-    struct __remove_pointer_helper\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp, typename _Up>\n-    struct __remove_pointer_helper<_Tp, _Up*>\n-    { typedef _Up     type; };\n-\n-  /// remove_pointer\n-  template<typename _Tp>\n-    struct remove_pointer\n-    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>\n-    { };\n-\n-  template<typename>\n-    struct remove_reference;\n-\n-  /// add_pointer\n-  template<typename _Tp>\n-    struct add_pointer\n-    { typedef typename remove_reference<_Tp>::type*     type; };\n-\n-#undef _DEFINE_SPEC_0_HELPER\n-#undef _DEFINE_SPEC_1_HELPER\n-#undef _DEFINE_SPEC_2_HELPER\n-#undef _DEFINE_SPEC\n-\n-  // @} group metaprogramming\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}"}, {"sha": "71b8719f5ff62b82d789f2f413ee56f771cd4ad3", "filename": "libstdc++-v3/include/tr1_impl/utility", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9992f7f6b00e697f46913fdf809366522118b6b/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Futility?ref=a9992f7f6b00e697f46913fdf809366522118b6b", "patch": "@@ -1,120 +0,0 @@\n-// TR1 utility -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/utility\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-  template<class _Tp>\n-    class tuple_size;\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  template<std::size_t _Int, class _Tp>\n-#else\n-  template<int _Int, class _Tp>\n-#endif\n-    class tuple_element;\n-\n-   // Various functions which give std::pair a tuple-like interface.\n-  template<class _Tp1, class _Tp2>\n-    struct tuple_size<std::pair<_Tp1, _Tp2> >\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-    { static const std::size_t value = 2; };\n-#else\n-    { static const int value = 2; };\n-#endif\n-\n-  template<class _Tp1, class _Tp2>\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-    const std::size_t\n-#else\n-    const int\n-#endif\n-    tuple_size<std::pair<_Tp1, _Tp2> >::value;\n-\n-  template<class _Tp1, class _Tp2>\n-    struct tuple_element<0, std::pair<_Tp1, _Tp2> >\n-    { typedef _Tp1 type; };\n- \n-  template<class _Tp1, class _Tp2>\n-    struct tuple_element<1, std::pair<_Tp1, _Tp2> >\n-    { typedef _Tp2 type; };\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  template<std::size_t _Int>\n-#else\n-  template<int _Int>\n-#endif\n-    struct __pair_get;\n-\n-  template<>\n-    struct __pair_get<0>\n-    {\n-      template<typename _Tp1, typename _Tp2>\n-      static _Tp1& __get(std::pair<_Tp1, _Tp2>& __pair)\n-      { return __pair.first; }\n-\n-      template<typename _Tp1, typename _Tp2>\n-      static const _Tp1& __const_get(const std::pair<_Tp1, _Tp2>& __pair)\n-      { return __pair.first; }\n-    };\n-\n-  template<>\n-    struct __pair_get<1>\n-    {\n-      template<typename _Tp1, typename _Tp2>\n-      static _Tp2& __get(std::pair<_Tp1, _Tp2>& __pair)\n-      { return __pair.second; }\n-\n-      template<typename _Tp1, typename _Tp2>\n-      static const _Tp2& __const_get(const std::pair<_Tp1, _Tp2>& __pair)\n-      { return __pair.second; }\n-    };\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  template<std::size_t _Int, class _Tp1, class _Tp2>\n-#else\n-  template<int _Int, class _Tp1, class _Tp2>\n-#endif\n-    inline typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n-    get(std::pair<_Tp1, _Tp2>& __in)\n-    { return __pair_get<_Int>::__get(__in); }\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  template<std::size_t _Int, class _Tp1, class _Tp2>\n-#else\n-  template<int _Int, class _Tp1, class _Tp2>\n-#endif\n-    inline const typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n-    get(const std::pair<_Tp1, _Tp2>& __in)\n-    { return __pair_get<_Int>::__const_get(__in); }\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}\n-"}, {"sha": "822e022b7e589bda66053ea3f915919e1fea5169", "filename": "libstdc++-v3/src/atomic.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -49,8 +49,8 @@ namespace\n     };\n } // anonymous namespace\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   namespace __atomic0\n   {\n     bool\n@@ -115,7 +115,8 @@ namespace std\n   _GLIBCXX_END_EXTERN_C\n \n   } // namespace __atomic0\n-} // namespace std\n+\n+_GLIBCXX_END_NAMESPACE\n \n \n // XXX GLIBCXX_ABI Deprecated"}, {"sha": "699a10a7253670e3a93af936548696edc68de189", "filename": "libstdc++-v3/src/chrono.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Fchrono.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Fchrono.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fchrono.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -33,8 +33,8 @@\n #include <sys/time.h>\n #endif\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   namespace chrono\n   {\n     const bool system_clock::is_monotonic;\n@@ -74,6 +74,7 @@ namespace std\n     }\n #endif\n   }\n-}\n+\n+_GLIBCXX_END_NAMESPACE\n \n #endif // _GLIBCXX_USE_C99_STDINT_TR1"}, {"sha": "e7adb5251bed50a7cb3348a569c42f53800869d7", "filename": "libstdc++-v3/src/condition_variable.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Fcondition_variable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Fcondition_variable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcondition_variable.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -26,8 +26,8 @@\n \n #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   condition_variable::condition_variable() throw ()\n   {\n #ifdef __GTHREAD_COND_INIT\n@@ -84,6 +84,7 @@ namespace std\n \n   condition_variable_any::~condition_variable_any() throw ()\n   { }\n-}\n+\n+_GLIBCXX_END_NAMESPACE\n \n #endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1"}, {"sha": "ed3088d87d6200e0fae97f9bc14e19feae35169f", "filename": "libstdc++-v3/src/future.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Ffuture.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Ffuture.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffuture.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -64,13 +64,14 @@ namespace\n   }\n }\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   const error_category& future_category()\n   { return __future_category_instance(); }\n \n   future_error::~future_error() throw() { }\n \n   const char* \n   future_error::what() const throw() { return _M_code.message().c_str(); }\n-}\n+\n+_GLIBCXX_END_NAMESPACE"}, {"sha": "e6eb6d28a7290359e0e8cb351889f33e2aa929fb", "filename": "libstdc++-v3/src/mutex.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Fmutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Fmutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmutex.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -37,8 +37,8 @@ namespace\n }\n #endif\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n #ifdef _GLIBCXX_HAVE_TLS\n   __thread void* __once_callable;\n   __thread void (*__once_call)();\n@@ -88,7 +88,8 @@ namespace std\n       __once_call();\n     }\n   }\n-}\n+\n+_GLIBCXX_END_NAMESPACE\n \n // XXX GLIBCXX_ABI Deprecated\n // gcc-4.6.0"}, {"sha": "acc6c0385319ca09fa50e2ec014c9c3ada376329", "filename": "libstdc++-v3/src/thread.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Fthread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Fsrc%2Fthread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fthread.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -28,8 +28,8 @@\n \n #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)\n \n-namespace std\n-{\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n   namespace\n   {\n     extern \"C\" void*\n@@ -95,6 +95,7 @@ namespace std\n       __throw_system_error(__e);\n     }\n   }\n-}\n+\n+_GLIBCXX_END_NAMESPACE\n \n #endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1"}, {"sha": "65516cca23008e4a878d1c06d22285da4feb8386", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 688 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1119 }\n \n #include <utility>\n "}, {"sha": "aae7e04c86103dafc225dc2f9a18e04357e52c71", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/typedefs_neg1.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg1.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -31,5 +31,5 @@ void test01()\n   test_type d;\n }\n \n-// { dg-error \"rep cannot be a duration\" \"\" { target *-*-* } 210 }\n+// { dg-error \"rep cannot be a duration\" \"\" { target *-*-* } 206 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 31 }"}, {"sha": "33ae9d57d003a59ca824c3e0136c712d6b9b4484", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/typedefs_neg2.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg2.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -3,7 +3,7 @@\n // { dg-require-cstdint \"\" }\n // 2008-07-31 Chris Fairles <chris.fairles@gmail.com>\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,6 +32,6 @@ void test01()\n   test_type d;\n }\n \n-// { dg-error \"must be a specialization of ratio\" \"\" { target *-*-* } 211 }\n+// { dg-error \"must be a specialization of ratio\" \"\" { target *-*-* } 207 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 32 }\n // { dg-excess-errors \"In instantiation of\" }"}, {"sha": "4faf93a48731fda478884343b4659269cc4c1860", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/typedefs_neg3.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg3.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -3,7 +3,7 @@\n // { dg-require-cstdint \"\" }\n // 2008-07-31 Chris Fairles <chris.fairles@gmail.com>\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -33,5 +33,5 @@ void test01()\n   test_type d;\n }\n \n-// { dg-error \"period must be positive\" \"\" { target *-*-* } 213 }\n+// { dg-error \"period must be positive\" \"\" { target *-*-* } 209 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 33 }"}, {"sha": "fc5744083c9b18ab119264cfe034a62b3d12371f", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 651 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 615 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1082 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1046 }"}, {"sha": "abbaefd65a7c4f746daf5ff89476e75a41661993", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 574 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 538 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1005 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 969 }"}, {"sha": "fb6cc8f5b7212e56f6e0ddb1e91160812f652667", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/43820.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -32,9 +32,9 @@ void test01()\n {\n   X* px = 0;\n   std::shared_ptr<X> p1(px);   // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 566 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 762 }\n \n   std::shared_ptr<X> p9(ap());  // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 658 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 854 }\n \n }"}, {"sha": "42a4da992a4bdb9917019c36801be77b135b8656", "filename": "libstdc++-v3/testsuite/20_util/weak_ptr/comparison/cmp_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -42,8 +42,8 @@ main()\n }\n \n // { dg-warning \"note\" \"\" { target *-*-* } 347 }\n+// { dg-warning \"note\" \"\" { target *-*-* } 1079 }\n // { dg-warning \"note\" \"\" { target *-*-* } 465 }\n-// { dg-warning \"note\" \"\" { target *-*-* } 883 }\n // { dg-warning \"note\" \"\" { target *-*-* } 580 }\n // { dg-warning \"note\" \"\" { target *-*-* } 1027 }\n // { dg-warning \"note\" \"\" { target *-*-* } 340 }"}, {"sha": "73a0f9e276ba7c03a07bd7324146f4f3569f43eb", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/shared_ptr/cons/43820.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fshared_ptr%2Fcons%2F43820.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc5044ed4fde8b489ba024923f49720db8129d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fshared_ptr%2Fcons%2F43820.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fshared_ptr%2Fcons%2F43820.cc?ref=53dc5044ed4fde8b489ba024923f49720db8129d", "patch": "@@ -30,9 +30,9 @@ void test01()\n {\n   X* px = 0;\n   std::tr1::shared_ptr<X> p1(px);   // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 370 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 561 }\n \n   std::tr1::shared_ptr<X> p9(ap());  // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 409 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 600 }\n \n }"}]}