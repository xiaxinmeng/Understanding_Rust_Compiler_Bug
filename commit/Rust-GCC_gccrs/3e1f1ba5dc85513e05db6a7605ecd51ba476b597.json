{"sha": "3e1f1ba5dc85513e05db6a7605ecd51ba476b597", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UxZjFiYTVkYzg1NTEzZTA1ZGI2YTc2MDVlY2Q1MWJhNDc2YjU5Nw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-06-28T15:06:06Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-06-28T15:06:06Z"}, "message": "cp-tree.h (struct deferred_access): Move to ...\n\n\t* cp-tree.h (struct deferred_access): Move to ...\n\t* semantics.c (struct deferred_access): ... here. Adjust.\n\t(deferred_access_stack): Make a VEC(deferred_access),\n\t(deferred_access_free_list): Remove.\n\t(deferred_access_no_check): New.\n\t(push_deferring_access_checks, resume_deferring_access_checks,\n\tstop_deferring_access_checks, pop_deferring_access_checks,\n\tget_deferred_access_checks, pop_to_parent_deferring_access_checks,\n\tperform_deferred_access_checks, perform_or_defer_access_check): Adjust.\n\nFrom-SVN: r83790", "tree": {"sha": "567d2eb2f5efbe94ad86b984d8c1ee8f056b20dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/567d2eb2f5efbe94ad86b984d8c1ee8f056b20dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e1f1ba5dc85513e05db6a7605ecd51ba476b597", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e1f1ba5dc85513e05db6a7605ecd51ba476b597", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e1f1ba5dc85513e05db6a7605ecd51ba476b597", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e1f1ba5dc85513e05db6a7605ecd51ba476b597/comments", "author": null, "committer": null, "parents": [{"sha": "246d2ceb324bb3483062b211a262aa290f5ecf41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/246d2ceb324bb3483062b211a262aa290f5ecf41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/246d2ceb324bb3483062b211a262aa290f5ecf41"}], "stats": {"total": 206, "additions": 120, "deletions": 86}, "files": [{"sha": "66019074e6554d43fe7ce495fdd52baaff01cd95", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e1f1ba5dc85513e05db6a7605ecd51ba476b597/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e1f1ba5dc85513e05db6a7605ecd51ba476b597/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3e1f1ba5dc85513e05db6a7605ecd51ba476b597", "patch": "@@ -1,3 +1,15 @@\n+2004-06-28  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (struct deferred_access): Move to ...\n+\t* semantics.c (struct deferred_access): ... here. Adjust.\n+\t(deferred_access_stack): Make a VEC(deferred_access),\n+\t(deferred_access_free_list): Remove.\n+\t(deferred_access_no_check): New.\n+\t(push_deferring_access_checks, resume_deferring_access_checks,\n+\tstop_deferring_access_checks, pop_deferring_access_checks,\n+\tget_deferred_access_checks, pop_to_parent_deferring_access_checks,\n+\tperform_deferred_access_checks, perform_or_defer_access_check): Adjust.\n+\n 2004-06-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR C++/16174\n@@ -10,6 +22,8 @@\n \t* cp-tree.h (LOOKUP_CONSTRUCTOR_CALLABLE): New.\n \t(LOOKUP_*): Renumber.\n \n+2004-06-28  Nathan Sidwell  <nathan@codesourcery.com>\n+\n \t* friend.c (add_friend): Only perform access checks when context\n \tis a class.\n \t* lex.c (cxx_make_type): Only create a binfo for aggregate types."}, {"sha": "71f4f9a99f75ba2909dcca867f6429a310476be9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e1f1ba5dc85513e05db6a7605ecd51ba476b597/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e1f1ba5dc85513e05db6a7605ecd51ba476b597/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3e1f1ba5dc85513e05db6a7605ecd51ba476b597", "patch": "@@ -3102,32 +3102,6 @@ extern GTY(()) tree integer_three_node;\n    function, two inside the body of a function in a local class, etc.)  */\n extern int function_depth;\n \n-typedef struct deferred_access GTY(())\n-{\n-  /* A TREE_LIST representing name-lookups for which we have deferred\n-     checking access controls.  We cannot check the accessibility of\n-     names used in a decl-specifier-seq until we know what is being\n-     declared because code like:\n-\n-       class A { \n-         class B {};\n-         B* f();\n-       }\n-\n-       A::B* A::f() { return 0; }\n-\n-     is valid, even though `A::B' is not generally accessible.  \n-\n-     The TREE_PURPOSE of each node is the scope used to qualify the\n-     name being looked up; the TREE_VALUE is the DECL to which the\n-     name was resolved.  */\n-  tree deferred_access_checks;\n-  /* The current mode of access checks.  */\n-  enum deferring_kind deferring_access_checks_kind;\n-  /* The next deferred access data in stack or linked-list.  */\n-  struct deferred_access *next;\n-} deferred_access;\n-\n /* in pt.c  */\n \n /* These values are used for the `STRICT' parameter to type_unification and"}, {"sha": "5974a7a66837c56ab2fce37a7fc5fc4e3b78d903", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 106, "deletions": 60, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e1f1ba5dc85513e05db6a7605ecd51ba476b597/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e1f1ba5dc85513e05db6a7605ecd51ba476b597/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3e1f1ba5dc85513e05db6a7605ecd51ba476b597", "patch": "@@ -44,6 +44,7 @@\n #include \"diagnostic.h\"\n #include \"cgraph.h\"\n #include \"tree-iterator.h\"\n+#include \"vec.h\"\n \n /* There routines provide a modular interface to perform many parsing\n    operations.  They may therefore be used during actual parsing, or\n@@ -111,37 +112,55 @@ static tree finalize_nrv_r (tree *, int *, void *);\n       In case of parsing error, we simply call `pop_deferring_access_checks'\n       without `perform_deferred_access_checks'.  */\n \n+typedef struct deferred_access GTY(())\n+{\n+  /* A TREE_LIST representing name-lookups for which we have deferred\n+     checking access controls.  We cannot check the accessibility of\n+     names used in a decl-specifier-seq until we know what is being\n+     declared because code like:\n+\n+       class A { \n+         class B {};\n+         B* f();\n+       }\n+\n+       A::B* A::f() { return 0; }\n+\n+     is valid, even though `A::B' is not generally accessible.  \n+\n+     The TREE_PURPOSE of each node is the scope used to qualify the\n+     name being looked up; the TREE_VALUE is the DECL to which the\n+     name was resolved.  */\n+  tree deferred_access_checks;\n+  \n+  /* The current mode of access checks.  */\n+  enum deferring_kind deferring_access_checks_kind;\n+  \n+} deferred_access;\n+DEF_VEC_O (deferred_access);\n+\n /* Data for deferred access checking.  */\n-static GTY(()) deferred_access *deferred_access_stack;\n-static GTY(()) deferred_access *deferred_access_free_list;\n+static GTY(()) VEC (deferred_access) *deferred_access_stack;\n+static GTY(()) unsigned deferred_access_no_check;\n \n /* Save the current deferred access states and start deferred\n    access checking iff DEFER_P is true.  */\n \n void\n push_deferring_access_checks (deferring_kind deferring)\n {\n-  deferred_access *d;\n-\n   /* For context like template instantiation, access checking\n      disabling applies to all nested context.  */\n-  if (deferred_access_stack\n-      && deferred_access_stack->deferring_access_checks_kind == dk_no_check)\n-    deferring = dk_no_check;\n-\n-  /* Recycle previously used free store if available.  */\n-  if (deferred_access_free_list)\n-    {\n-      d = deferred_access_free_list;\n-      deferred_access_free_list = d->next;\n-    }\n+  if (deferred_access_no_check || deferring == dk_no_check)\n+    deferred_access_no_check++;\n   else\n-    d = ggc_alloc (sizeof (deferred_access));\n+    {\n+      deferred_access *ptr;\n \n-  d->next = deferred_access_stack;\n-  d->deferred_access_checks = NULL_TREE;\n-  d->deferring_access_checks_kind = deferring;\n-  deferred_access_stack = d;\n+      ptr = VEC_safe_push (deferred_access, deferred_access_stack, NULL);\n+      ptr->deferred_access_checks = NULL_TREE;\n+      ptr->deferring_access_checks_kind = deferring;\n+    }\n }\n \n /* Resume deferring access checks again after we stopped doing\n@@ -150,17 +169,19 @@ push_deferring_access_checks (deferring_kind deferring)\n void\n resume_deferring_access_checks (void)\n {\n-  if (deferred_access_stack->deferring_access_checks_kind == dk_no_deferred)\n-    deferred_access_stack->deferring_access_checks_kind = dk_deferred;\n+  if (!deferred_access_no_check)\n+    VEC_last (deferred_access, deferred_access_stack)\n+      ->deferring_access_checks_kind = dk_deferred;\n }\n \n /* Stop deferring access checks.  */\n \n void\n stop_deferring_access_checks (void)\n {\n-  if (deferred_access_stack->deferring_access_checks_kind == dk_deferred)\n-    deferred_access_stack->deferring_access_checks_kind = dk_no_deferred;\n+  if (!deferred_access_no_check)\n+    VEC_last (deferred_access, deferred_access_stack)\n+      ->deferring_access_checks_kind = dk_no_deferred;\n }\n \n /* Discard the current deferred access checks and restore the\n@@ -169,15 +190,10 @@ stop_deferring_access_checks (void)\n void\n pop_deferring_access_checks (void)\n {\n-  deferred_access *d = deferred_access_stack;\n-  deferred_access_stack = d->next;\n-\n-  /* Remove references to access checks TREE_LIST.  */\n-  d->deferred_access_checks = NULL_TREE;\n-\n-  /* Store in free list for later use.  */\n-  d->next = deferred_access_free_list;\n-  deferred_access_free_list = d;\n+  if (deferred_access_no_check)\n+    deferred_access_no_check--;\n+  else\n+    VEC_pop (deferred_access, deferred_access_stack);\n }\n \n /* Returns a TREE_LIST representing the deferred checks.  \n@@ -188,7 +204,11 @@ pop_deferring_access_checks (void)\n tree\n get_deferred_access_checks (void)\n {\n-  return deferred_access_stack->deferred_access_checks;\n+  if (deferred_access_no_check)\n+    return NULL;\n+  else\n+    return (VEC_last (deferred_access, deferred_access_stack)\n+\t    ->deferred_access_checks);\n }\n \n /* Take current deferred checks and combine with the\n@@ -198,27 +218,48 @@ get_deferred_access_checks (void)\n void\n pop_to_parent_deferring_access_checks (void)\n {\n-  tree deferred_check = get_deferred_access_checks ();\n-  deferred_access *d1 = deferred_access_stack;\n-  deferred_access *d2 = deferred_access_stack->next;\n-  deferred_access *d3 = deferred_access_stack->next->next;\n-\n-  /* Temporary swap the order of the top two states, just to make\n-     sure the garbage collector will not reclaim the memory during \n-     processing below.  */\n-  deferred_access_stack = d2;\n-  d2->next = d1;\n-  d1->next = d3;\n+  if (deferred_access_no_check)\n+    deferred_access_no_check--;\n+  else\n+    {\n+      tree checks;\n+      deferred_access *ptr;\n \n-  for ( ; deferred_check; deferred_check = TREE_CHAIN (deferred_check))\n-    /* Perform deferred check if required.  */\n-    perform_or_defer_access_check (TREE_PURPOSE (deferred_check), \n-\t\t\t\t   TREE_VALUE (deferred_check));\n+      checks = (VEC_last (deferred_access, deferred_access_stack)\n+\t\t->deferred_access_checks);\n \n-  deferred_access_stack = d1;\n-  d1->next = d2;\n-  d2->next = d3;\n-  pop_deferring_access_checks ();\n+      VEC_pop (deferred_access, deferred_access_stack);\n+      ptr = VEC_last (deferred_access, deferred_access_stack);\n+      if (ptr->deferring_access_checks_kind == dk_no_deferred)\n+\t{\n+\t  /* Check access.  */\n+\t  for (; checks; checks = TREE_CHAIN (checks)) \n+\t    enforce_access (TREE_PURPOSE (checks), \n+\t\t\t    TREE_VALUE (checks));\n+\t}\n+      else\n+\t{\n+\t  /* Merge with parent.  */\n+\t  tree next;\n+\t  tree original = ptr->deferred_access_checks;\n+\t  \n+\t  for (; checks; checks = next)\n+\t    {\n+\t      tree probe;\n+\t      \n+\t      next = TREE_CHAIN (checks);\n+\n+\t      for (probe = original; probe; probe = TREE_CHAIN (probe))\n+\t\tif (TREE_VALUE (probe) == TREE_VALUE (checks)\n+\t\t    && TREE_PURPOSE (probe) == TREE_PURPOSE (checks))\n+\t\t  goto found;\n+\t      /* Insert into parent's checks.  */\n+\t      TREE_CHAIN (checks) = ptr->deferred_access_checks;\n+\t      ptr->deferred_access_checks = checks;\n+\t    found:;\n+\t    }\n+\t}\n+    }\n }\n \n /* Perform the deferred access checks.\n@@ -241,7 +282,9 @@ void\n perform_deferred_access_checks (void)\n {\n   tree deferred_check;\n-  for (deferred_check = deferred_access_stack->deferred_access_checks;\n+\n+  for (deferred_check = (VEC_last (deferred_access, deferred_access_stack)\n+\t\t\t ->deferred_access_checks);\n        deferred_check;\n        deferred_check = TREE_CHAIN (deferred_check))\n     /* Check access.  */\n@@ -256,30 +299,33 @@ void\n perform_or_defer_access_check (tree binfo, tree decl)\n {\n   tree check;\n+  deferred_access *ptr;\n \n-  /* Exit if we are in a context that no access checking is performed.  */\n-  if (deferred_access_stack->deferring_access_checks_kind == dk_no_check)\n+  /* Exit if we are in a context that no access checking is performed.\n+     */\n+  if (deferred_access_no_check)\n     return;\n   \n   my_friendly_assert (TREE_CODE (binfo) == TREE_VEC, 20030623);\n \n+  ptr = VEC_last (deferred_access, deferred_access_stack);\n+  \n   /* If we are not supposed to defer access checks, just check now.  */\n-  if (deferred_access_stack->deferring_access_checks_kind == dk_no_deferred)\n+  if (ptr->deferring_access_checks_kind == dk_no_deferred)\n     {\n       enforce_access (binfo, decl);\n       return;\n     }\n   \n   /* See if we are already going to perform this check.  */\n-  for (check = deferred_access_stack->deferred_access_checks;\n+  for (check = ptr->deferred_access_checks;\n        check;\n        check = TREE_CHAIN (check))\n     if (TREE_VALUE (check) == decl && TREE_PURPOSE (check) == binfo)\n       return;\n   /* If not, record the check.  */\n-  deferred_access_stack->deferred_access_checks\n-    = tree_cons (binfo, decl,\n-\t\t deferred_access_stack->deferred_access_checks);\n+  ptr->deferred_access_checks\n+    = tree_cons (binfo, decl, ptr->deferred_access_checks);\n }\n \n /* Returns nonzero if the current statement is a full expression,"}]}