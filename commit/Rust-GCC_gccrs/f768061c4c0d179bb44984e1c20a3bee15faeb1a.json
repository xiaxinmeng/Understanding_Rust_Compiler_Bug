{"sha": "f768061c4c0d179bb44984e1c20a3bee15faeb1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc2ODA2MWM0YzBkMTc5YmI0NDk4NGUxYzIwYTNiZWUxNWZhZWIxYQ==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2014-08-01T02:51:57Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2014-08-01T02:51:57Z"}, "message": "RTL & dwarf2out changes\n\nConvert dwarf2out and rtl.c to the new inchash interface.\n\ngcc/:\n\n2014-07-31  Andi Kleen  <ak@linux.intel.com>\n\n\t* Makefile.in (OBJS): Add rtlhash.o\n\t* dwarf2out.c (addr_table_entry_do_hash): Convert to inchash.\n\t(loc_checksum): Dito.\n\t(loc_checksum_ordered): Dito.\n\t(hash_loc_operands): Dito.\n\t(hash_locs): Dito.\n\t(hash_loc_list): Dito.\n\t* rtl.c (iterative_hash_rtx): Moved to rtlhash.c\n\t* rtl.h (iterative_hash_rtx): Moved to rtlhash.h\n\t* rtlhash.c: New file.\n\t* rtlhash.h: New file.\n\nFrom-SVN: r213395", "tree": {"sha": "e3029eaf9c62844fda4c9e4772c56a84c9882344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3029eaf9c62844fda4c9e4772c56a84c9882344"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f768061c4c0d179bb44984e1c20a3bee15faeb1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f768061c4c0d179bb44984e1c20a3bee15faeb1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f768061c4c0d179bb44984e1c20a3bee15faeb1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f768061c4c0d179bb44984e1c20a3bee15faeb1a/comments", "author": null, "committer": null, "parents": [{"sha": "50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50de5793fc6004bb8bf6f00e0f02e318f242ca2d"}], "stats": {"total": 359, "additions": 220, "deletions": 139}, "files": [{"sha": "de07350b8385bd0d2661d150ef15796c02cfa81d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f768061c4c0d179bb44984e1c20a3bee15faeb1a", "patch": "@@ -1,3 +1,17 @@\n+2014-07-31  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* Makefile.in (OBJS): Add rtlhash.o\n+\t* dwarf2out.c (addr_table_entry_do_hash): Convert to inchash.\n+\t(loc_checksum): Dito.\n+\t(loc_checksum_ordered): Dito.\n+\t(hash_loc_operands): Dito.\n+\t(hash_locs): Dito.\n+\t(hash_loc_list): Dito.\n+\t* rtl.c (iterative_hash_rtx): Moved to rtlhash.c\n+\t* rtl.h (iterative_hash_rtx): Moved to rtlhash.h\n+\t* rtlhash.c: New file.\n+\t* rtlhash.h: New file.\n+\n 2014-07-31  Andi Kleen  <ak@linux.intel.com>\n \n \t* inchash.h (inchash): Change inchash class to namespace."}, {"sha": "a2fb5f5b47fa5b16a27a08019bf296e2e54a1437", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f768061c4c0d179bb44984e1c20a3bee15faeb1a", "patch": "@@ -1350,6 +1350,7 @@ OBJS = \\\n \tresource.o \\\n \trtl-error.o \\\n \trtl.o \\\n+\trtlhash.o \\\n \trtlanal.o \\\n \trtlhooks.o \\\n \tsbitmap.o \\"}, {"sha": "f90329b00cf1af9cd4b4c4367b38592038cc9119", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f768061c4c0d179bb44984e1c20a3bee15faeb1a", "patch": "@@ -71,6 +71,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"hard-reg-set.h\"\n #include \"regs.h\"\n+#include \"rtlhash.h\"\n #include \"insn-config.h\"\n #include \"reload.h\"\n #include \"function.h\"\n@@ -3277,7 +3278,7 @@ static void gen_scheduled_generic_parms_dies (void);\n \n static const char *comp_dir_string (void);\n \n-static hashval_t hash_loc_operands (dw_loc_descr_ref, hashval_t);\n+static void hash_loc_operands (dw_loc_descr_ref, inchash::hash &);\n \n /* enum for tracking thread-local variables whose address is really an offset\n    relative to the TLS pointer, which will need link-time relocation, but will\n@@ -4190,17 +4191,22 @@ static hashval_t\n addr_table_entry_do_hash (const void *x)\n {\n   const addr_table_entry *a = (const addr_table_entry *) x;\n+  inchash::hash hstate;\n   switch (a->kind)\n     {\n       case ate_kind_rtx:\n-        return iterative_hash_rtx (a->addr.rtl, 0);\n+\thstate.add_int (0);\n+\tbreak;\n       case ate_kind_rtx_dtprel:\n-        return iterative_hash_rtx (a->addr.rtl, 1);\n+\thstate.add_int (1);\n+\tbreak;\n       case ate_kind_label:\n         return htab_hash_string (a->addr.label);\n       default:\n         gcc_unreachable ();\n     }\n+  inchash::add_rtx (a->addr.rtl, hstate);\n+  return hstate.end ();\n }\n \n /* Determine equality for two address_table_entries.  */\n@@ -5544,11 +5550,13 @@ static inline void\n loc_checksum (dw_loc_descr_ref loc, struct md5_ctx *ctx)\n {\n   int tem;\n-  hashval_t hash = 0;\n+  inchash::hash hstate;\n+  hashval_t hash;\n \n   tem = (loc->dtprel << 8) | ((unsigned int) loc->dw_loc_opc);\n   CHECKSUM (tem);\n-  hash = hash_loc_operands (loc, hash);\n+  hash_loc_operands (loc, hstate);\n+  hash = hstate.end();\n   CHECKSUM (hash);\n }\n \n@@ -5758,11 +5766,13 @@ loc_checksum_ordered (dw_loc_descr_ref loc, struct md5_ctx *ctx)\n   /* Otherwise, just checksum the raw location expression.  */\n   while (loc != NULL)\n     {\n-      hashval_t hash = 0;\n+      inchash::hash hstate;\n+      hashval_t hash;\n \n       CHECKSUM_ULEB128 (loc->dtprel);\n       CHECKSUM_ULEB128 (loc->dw_loc_opc);\n-      hash = hash_loc_operands (loc, hash);\n+      hash_loc_operands (loc, hstate);\n+      hash = hstate.end ();\n       CHECKSUM (hash);\n       loc = loc->dw_loc_next;\n     }\n@@ -23619,10 +23629,10 @@ resolve_addr (dw_die_ref die)\n    This pass tries to share identical local lists in .debug_loc\n    section.  */\n \n-/* Iteratively hash operands of LOC opcode.  */\n+/* Iteratively hash operands of LOC opcode into HSTATE.  */\n \n-static hashval_t\n-hash_loc_operands (dw_loc_descr_ref loc, hashval_t hash)\n+static void\n+hash_loc_operands (dw_loc_descr_ref loc, inchash::hash &hstate)\n {\n   dw_val_ref val1 = &loc->dw_loc_oprnd1;\n   dw_val_ref val2 = &loc->dw_loc_oprnd2;\n@@ -23681,7 +23691,7 @@ hash_loc_operands (dw_loc_descr_ref loc, hashval_t hash)\n     case DW_OP_piece:\n     case DW_OP_deref_size:\n     case DW_OP_xderef_size:\n-      hash = iterative_hash_object (val1->v.val_int, hash);\n+      hstate.add_object (val1->v.val_int);\n       break;\n     case DW_OP_skip:\n     case DW_OP_bra:\n@@ -23690,71 +23700,70 @@ hash_loc_operands (dw_loc_descr_ref loc, hashval_t hash)\n \n \tgcc_assert (val1->val_class == dw_val_class_loc);\n \toffset = val1->v.val_loc->dw_loc_addr - (loc->dw_loc_addr + 3);\n-\thash = iterative_hash_object (offset, hash);\n+\thstate.add_object (offset);\n       }\n       break;\n     case DW_OP_implicit_value:\n-      hash = iterative_hash_object (val1->v.val_unsigned, hash);\n+      hstate.add_object (val1->v.val_unsigned);\n       switch (val2->val_class)\n \t{\n \tcase dw_val_class_const:\n-\t  hash = iterative_hash_object (val2->v.val_int, hash);\n+\t  hstate.add_object (val2->v.val_int);\n \t  break;\n \tcase dw_val_class_vec:\n \t  {\n \t    unsigned int elt_size = val2->v.val_vec.elt_size;\n \t    unsigned int len = val2->v.val_vec.length;\n \n-\t    hash = iterative_hash_object (elt_size, hash);\n-\t    hash = iterative_hash_object (len, hash);\n-\t    hash = iterative_hash (val2->v.val_vec.array,\n-\t\t\t\t   len * elt_size, hash);\n+\t    hstate.add_int (elt_size);\n+\t    hstate.add_int (len);\n+\t    hstate.add (val2->v.val_vec.array, len * elt_size);\n \t  }\n \t  break;\n \tcase dw_val_class_const_double:\n-\t  hash = iterative_hash_object (val2->v.val_double.low, hash);\n-\t  hash = iterative_hash_object (val2->v.val_double.high, hash);\n+\t  hstate.add_object (val2->v.val_double.low);\n+\t  hstate.add_object (val2->v.val_double.high);\n \t  break;\n \tcase dw_val_class_wide_int:\n-\t  hash = iterative_hash_object (*val2->v.val_wide, hash);\n+\t  hstate.add_object (*val2->v.val_wide);\n \t  break;\n-\tcase dw_val_class_addr:\n-\t  hash = iterative_hash_rtx (val2->v.val_addr, hash);\n+\tcase dw_val_class_addr:\t\n+\t  inchash::add_rtx (val2->v.val_addr, hstate);\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n       break;\n     case DW_OP_bregx:\n     case DW_OP_bit_piece:\n-      hash = iterative_hash_object (val1->v.val_int, hash);\n-      hash = iterative_hash_object (val2->v.val_int, hash);\n+      hstate.add_object (val1->v.val_int);\n+      hstate.add_object (val2->v.val_int);\n       break;\n     case DW_OP_addr:\n     hash_addr:\n       if (loc->dtprel)\n \t{\n \t  unsigned char dtprel = 0xd1;\n-\t  hash = iterative_hash_object (dtprel, hash);\n+\t  hstate.add_object (dtprel);\n \t}\n-      hash = iterative_hash_rtx (val1->v.val_addr, hash);\n+      inchash::add_rtx (val1->v.val_addr, hstate);\n       break;\n     case DW_OP_GNU_addr_index:\n     case DW_OP_GNU_const_index:\n       {\n         if (loc->dtprel)\n           {\n             unsigned char dtprel = 0xd1;\n-            hash = iterative_hash_object (dtprel, hash);\n+\t    hstate.add_object (dtprel);\n           }\n-        hash = iterative_hash_rtx (val1->val_entry->addr.rtl, hash);\n+        inchash::add_rtx (val1->val_entry->addr.rtl, hstate);\n       }\n       break;\n     case DW_OP_GNU_implicit_pointer:\n-      hash = iterative_hash_object (val2->v.val_int, hash);\n+      hstate.add_int (val2->v.val_int);\n       break;\n     case DW_OP_GNU_entry_value:\n-      hash = hash_loc_operands (val1->v.val_loc, hash);\n+      hstate.add_object (val1->v.val_loc);\n       break;\n     case DW_OP_GNU_regval_type:\n     case DW_OP_GNU_deref_type:\n@@ -23763,16 +23772,16 @@ hash_loc_operands (dw_loc_descr_ref loc, hashval_t hash)\n \t  = get_AT_unsigned (val2->v.val_die_ref.die, DW_AT_byte_size);\n \tunsigned int encoding\n \t  = get_AT_unsigned (val2->v.val_die_ref.die, DW_AT_encoding);\n-\thash = iterative_hash_object (val1->v.val_int, hash);\n-\thash = iterative_hash_object (byte_size, hash);\n-\thash = iterative_hash_object (encoding, hash);\n+\thstate.add_object (val1->v.val_int);\n+\thstate.add_object (byte_size);\n+\thstate.add_object (encoding);\n       }\n       break;\n     case DW_OP_GNU_convert:\n     case DW_OP_GNU_reinterpret:\n       if (val1->val_class == dw_val_class_unsigned_const)\n \t{\n-\t  hash = iterative_hash_object (val1->v.val_unsigned, hash);\n+\t  hstate.add_object (val1->v.val_unsigned);\n \t  break;\n \t}\n       /* FALLTHRU */\n@@ -23782,33 +23791,32 @@ hash_loc_operands (dw_loc_descr_ref loc, hashval_t hash)\n \t  = get_AT_unsigned (val1->v.val_die_ref.die, DW_AT_byte_size);\n \tunsigned int encoding\n \t  = get_AT_unsigned (val1->v.val_die_ref.die, DW_AT_encoding);\n-\thash = iterative_hash_object (byte_size, hash);\n-\thash = iterative_hash_object (encoding, hash);\n+\thstate.add_object (byte_size);\n+\thstate.add_object (encoding);\n \tif (loc->dw_loc_opc != DW_OP_GNU_const_type)\n \t  break;\n-\thash = iterative_hash_object (val2->val_class, hash);\n+\thstate.add_object (val2->val_class);\n \tswitch (val2->val_class)\n \t  {\n \t  case dw_val_class_const:\n-\t    hash = iterative_hash_object (val2->v.val_int, hash);\n+\t    hstate.add_object (val2->v.val_int);\n \t    break;\n \t  case dw_val_class_vec:\n \t    {\n \t      unsigned int elt_size = val2->v.val_vec.elt_size;\n \t      unsigned int len = val2->v.val_vec.length;\n \n-\t      hash = iterative_hash_object (elt_size, hash);\n-\t      hash = iterative_hash_object (len, hash);\n-\t      hash = iterative_hash (val2->v.val_vec.array,\n-\t\t\t\t     len * elt_size, hash);\n+\t      hstate.add_object (elt_size);\n+\t      hstate.add_object (len);\n+\t      hstate.add (val2->v.val_vec.array, len * elt_size);\n \t    }\n \t    break;\n \t  case dw_val_class_const_double:\n-\t    hash = iterative_hash_object (val2->v.val_double.low, hash);\n-\t    hash = iterative_hash_object (val2->v.val_double.high, hash);\n+\t    hstate.add_object (val2->v.val_double.low);\n+\t    hstate.add_object (val2->v.val_double.high);\n \t    break;\n \t  case dw_val_class_wide_int:\n-\t    hash = iterative_hash_object (*val2->v.val_wide, hash);\n+\t    hstate.add_object (*val2->v.val_wide);\n \t    break;\n \t  default:\n \t    gcc_unreachable ();\n@@ -23820,13 +23828,12 @@ hash_loc_operands (dw_loc_descr_ref loc, hashval_t hash)\n       /* Other codes have no operands.  */\n       break;\n     }\n-  return hash;\n }\n \n-/* Iteratively hash the whole DWARF location expression LOC.  */\n+/* Iteratively hash the whole DWARF location expression LOC into HSTATE.  */\n \n-static inline hashval_t\n-hash_locs (dw_loc_descr_ref loc, hashval_t hash)\n+static inline void\n+hash_locs (dw_loc_descr_ref loc, inchash::hash &hstate)\n {\n   dw_loc_descr_ref l;\n   bool sizes_computed = false;\n@@ -23836,15 +23843,14 @@ hash_locs (dw_loc_descr_ref loc, hashval_t hash)\n   for (l = loc; l != NULL; l = l->dw_loc_next)\n     {\n       enum dwarf_location_atom opc = l->dw_loc_opc;\n-      hash = iterative_hash_object (opc, hash);\n+      hstate.add_object (opc);\n       if ((opc == DW_OP_skip || opc == DW_OP_bra) && !sizes_computed)\n \t{\n \t  size_of_locs (loc);\n \t  sizes_computed = true;\n \t}\n-      hash = hash_loc_operands (l, hash);\n+      hash_loc_operands (l, hstate);\n     }\n-  return hash;\n }\n \n /* Compute hash of the whole location list LIST_HEAD.  */\n@@ -23853,18 +23859,17 @@ static inline void\n hash_loc_list (dw_loc_list_ref list_head)\n {\n   dw_loc_list_ref curr = list_head;\n-  hashval_t hash = 0;\n+  inchash::hash hstate;\n \n   for (curr = list_head; curr != NULL; curr = curr->dw_loc_next)\n     {\n-      hash = iterative_hash (curr->begin, strlen (curr->begin) + 1, hash);\n-      hash = iterative_hash (curr->end, strlen (curr->end) + 1, hash);\n+      hstate.add (curr->begin, strlen (curr->begin) + 1);\n+      hstate.add (curr->end, strlen (curr->end) + 1);\n       if (curr->section)\n-\thash = iterative_hash (curr->section, strlen (curr->section) + 1,\n-\t\t\t       hash);\n-      hash = hash_locs (curr->expr, hash);\n+\thstate.add (curr->section, strlen (curr->section) + 1);\n+      hash_locs (curr->expr, hstate);\n     }\n-  list_head->hash = hash;\n+  list_head->hash = hstate.end ();\n }\n \n /* Return true if X and Y opcodes have the same operands.  */"}, {"sha": "3363eebdbb6c6cb43f76cca9073cdd909dd64257", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 78, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=f768061c4c0d179bb44984e1c20a3bee15faeb1a", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifdef GENERATOR_FILE\n # include \"errors.h\"\n #else\n+# include \"rtlhash.h\"\n # include \"diagnostic-core.h\"\n #endif\n \n@@ -654,84 +655,6 @@ rtx_equal_p (const_rtx x, const_rtx y)\n   return 1;\n }\n \n-/* Iteratively hash rtx X.  */\n-\n-hashval_t\n-iterative_hash_rtx (const_rtx x, hashval_t hash)\n-{\n-  enum rtx_code code;\n-  enum machine_mode mode;\n-  int i, j;\n-  const char *fmt;\n-\n-  if (x == NULL_RTX)\n-    return hash;\n-  code = GET_CODE (x);\n-  hash = iterative_hash_object (code, hash);\n-  mode = GET_MODE (x);\n-  hash = iterative_hash_object (mode, hash);\n-  switch (code)\n-    {\n-    case REG:\n-      i = REGNO (x);\n-      return iterative_hash_object (i, hash);\n-    case CONST_INT:\n-      return iterative_hash_object (INTVAL (x), hash);\n-    case CONST_WIDE_INT:\n-      for (i = 0; i < CONST_WIDE_INT_NUNITS (x); i++)\n-\thash = iterative_hash_object (CONST_WIDE_INT_ELT (x, i), hash);\n-      return hash;\n-    case SYMBOL_REF:\n-      if (XSTR (x, 0))\n-\treturn iterative_hash (XSTR (x, 0), strlen (XSTR (x, 0)) + 1,\n-\t\t\t       hash);\n-      return hash;\n-    case LABEL_REF:\n-    case DEBUG_EXPR:\n-    case VALUE:\n-    case SCRATCH:\n-    case CONST_DOUBLE:\n-    case CONST_FIXED:\n-    case DEBUG_IMPLICIT_PTR:\n-    case DEBUG_PARAMETER_REF:\n-      return hash;\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    switch (fmt[i])\n-      {\n-      case 'w':\n-\thash = iterative_hash_object (XWINT (x, i), hash);\n-\tbreak;\n-      case 'n':\n-      case 'i':\n-\thash = iterative_hash_object (XINT (x, i), hash);\n-\tbreak;\n-      case 'V':\n-      case 'E':\n-\tj = XVECLEN (x, i);\n-\thash = iterative_hash_object (j, hash);\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  hash = iterative_hash_rtx (XVECEXP (x, i, j), hash);\n-\tbreak;\n-      case 'e':\n-\thash = iterative_hash_rtx (XEXP (x, i), hash);\n-\tbreak;\n-      case 'S':\n-      case 's':\n-\tif (XSTR (x, i))\n-\t  hash = iterative_hash (XSTR (x, 0), strlen (XSTR (x, 0)) + 1,\n-\t\t\t\t hash);\n-\tbreak;\n-      default:\n-\tbreak;\n-      }\n-  return hash;\n-}\n-\n void\n dump_rtx_statistics (void)\n {"}, {"sha": "2fb0c5c4f68f48e3d7ff59fce1d7f580f342e9fe", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f768061c4c0d179bb44984e1c20a3bee15faeb1a", "patch": "@@ -1983,7 +1983,6 @@ extern unsigned int rtx_size (const_rtx);\n extern rtx shallow_copy_rtx_stat (const_rtx MEM_STAT_DECL);\n #define shallow_copy_rtx(a) shallow_copy_rtx_stat (a MEM_STAT_INFO)\n extern int rtx_equal_p (const_rtx, const_rtx);\n-extern hashval_t iterative_hash_rtx (const_rtx, hashval_t);\n \n /* In emit-rtl.c */\n extern rtvec gen_rtvec_v (int, rtx *);"}, {"sha": "ed4ee7a74b5dcabe495930c55e3e2ee430db3d0b", "filename": "gcc/rtlhash.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2Frtlhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2Frtlhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhash.c?ref=f768061c4c0d179bb44984e1c20a3bee15faeb1a", "patch": "@@ -0,0 +1,107 @@\n+/* RTL hash functions.\n+   Copyright (C) 1987-2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"rtl.h\"\n+#include \"rtlhash.h\"\n+\n+namespace inchash\n+{\n+\n+/* Iteratively hash rtx X into HSTATE.  */\n+\n+void\n+add_rtx (const_rtx x, hash &hstate)\n+{\n+  enum rtx_code code;\n+  enum machine_mode mode;\n+  int i, j;\n+  const char *fmt;\n+\n+  if (x == NULL_RTX)\n+    return;\n+  code = GET_CODE (x);\n+  hstate.add_object (code);\n+  mode = GET_MODE (x);\n+  hstate.add_object (mode);\n+  switch (code)\n+    {\n+    case REG:\n+      hstate.add_int (REGNO (x));\n+      return;\n+    case CONST_INT:\n+      hstate.add_object (INTVAL (x));\n+      return;\n+    case CONST_WIDE_INT:\n+      for (i = 0; i < CONST_WIDE_INT_NUNITS (x); i++)\n+\thstate.add_object (CONST_WIDE_INT_ELT (x, i));\n+      return;\n+    case SYMBOL_REF:\n+      if (XSTR (x, 0))\n+\thstate.add (XSTR (x, 0), strlen (XSTR (x, 0)) + 1);\n+      return;\n+    case LABEL_REF:\n+    case DEBUG_EXPR:\n+    case VALUE:\n+    case SCRATCH:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case DEBUG_IMPLICIT_PTR:\n+    case DEBUG_PARAMETER_REF:\n+      return;\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    switch (fmt[i])\n+      {\n+      case 'w':\n+\thstate.add_object (XWINT (x, i));\n+\tbreak;\n+      case 'n':\n+      case 'i':\n+\thstate.add_object (XINT (x, i));\n+\tbreak;\n+      case 'V':\n+      case 'E':\n+\tj = XVECLEN (x, i);\n+\thstate.add_int (j);\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  inchash::add_rtx (XVECEXP (x, i, j), hstate);\n+\tbreak;\n+      case 'e':\n+\tinchash::add_rtx (XEXP (x, i), hstate);\n+\tbreak;\n+      case 'S':\n+      case 's':\n+\tif (XSTR (x, i))\n+\t  hstate.add (XSTR (x, 0), strlen (XSTR (x, 0)) + 1);\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+}\n+\n+}"}, {"sha": "158a2c2563bbb4e05eeb008e2bbe4376a047621e", "filename": "gcc/rtlhash.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2Frtlhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f768061c4c0d179bb44984e1c20a3bee15faeb1a/gcc%2Frtlhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhash.h?ref=f768061c4c0d179bb44984e1c20a3bee15faeb1a", "patch": "@@ -0,0 +1,32 @@\n+/* Register Transfer Language (RTL) hash functions.\n+   Copyright (C) 1987-2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef RTL_HASH_H\n+#define RTL_HASH_H 1\n+\n+#include \"inchash.h\"\n+\n+namespace inchash\n+{\n+\n+extern void add_rtx (const_rtx, hash &);\n+\n+}\n+\n+#endif"}]}