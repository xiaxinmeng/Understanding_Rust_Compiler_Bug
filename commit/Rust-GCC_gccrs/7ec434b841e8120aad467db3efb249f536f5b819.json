{"sha": "7ec434b841e8120aad467db3efb249f536f5b819", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VjNDM0Yjg0MWU4MTIwYWFkNDY3ZGIzZWZiMjQ5ZjUzNmY1YjgxOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2006-06-04T12:59:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2006-06-04T12:59:40Z"}, "message": "re PR tree-optimization/27039 (Unable to determine # of iterations for a simple loop)\n\n2006-06-04  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/27039\n\t* fold-const.c (fold_comparison): Handle pointer comparison\n\tagain for all comparison codes.  Compare offsets in signed\n\tsize type.\n\t(fold_binary): Move code from here.\n\n\t* gcc.dg/tree-ssa/loop-17.c: New testcase.\n\nFrom-SVN: r114357", "tree": {"sha": "6ce8c8a0ac7594c99d0fe4bff2ae7f32c2e68e90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ce8c8a0ac7594c99d0fe4bff2ae7f32c2e68e90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ec434b841e8120aad467db3efb249f536f5b819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec434b841e8120aad467db3efb249f536f5b819", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ec434b841e8120aad467db3efb249f536f5b819", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec434b841e8120aad467db3efb249f536f5b819/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0701ea2e186419367a5698ea73dad8a12466ff63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0701ea2e186419367a5698ea73dad8a12466ff63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0701ea2e186419367a5698ea73dad8a12466ff63"}], "stats": {"total": 95, "additions": 67, "deletions": 28}, "files": [{"sha": "fd3d122112a03b9f69829280340b305a5f1e15ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec434b841e8120aad467db3efb249f536f5b819/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec434b841e8120aad467db3efb249f536f5b819/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ec434b841e8120aad467db3efb249f536f5b819", "patch": "@@ -1,3 +1,11 @@\n+2006-06-04  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/27039\n+\t* fold-const.c (fold_comparison): Handle pointer comparison\n+\tagain for all comparison codes.  Compare offsets in signed\n+\tsize type.\n+\t(fold_binary): Move code from here.\n+\n 2006-06-03  Roger Sayle  <roger@eyesopen.com>\n \n \tPR target/26223"}, {"sha": "3c8575e60e32252dc1d949a10e26146b82223ec7", "filename": "gcc/fold-const.c", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec434b841e8120aad467db3efb249f536f5b819/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec434b841e8120aad467db3efb249f536f5b819/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7ec434b841e8120aad467db3efb249f536f5b819", "patch": "@@ -7764,6 +7764,41 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \treturn fold_build2 (code, type, variable, lhs);\n     }\n \n+  /* If this is a comparison of two exprs that look like an ARRAY_REF of the\n+     same object, then we can fold this to a comparison of the two offsets in\n+     signed size type.  This is possible because pointer arithmetic is\n+     restricted to retain within an object and overflow on pointer differences\n+     is undefined as of 6.5.6/8 and /9 with respect to the signed ptrdiff_t.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (arg0))\n+      && !flag_wrapv && !flag_trapv)\n+    {\n+      tree base0, offset0, base1, offset1;\n+\n+      if (extract_array_ref (arg0, &base0, &offset0)\n+\t  && extract_array_ref (arg1, &base1, &offset1)\n+\t  && operand_equal_p (base0, base1, 0))\n+        {\n+\t  tree signed_size_type_node;\n+\t  signed_size_type_node = signed_type_for (size_type_node);\n+\n+\t  /* By converting to signed size type we cover middle-end pointer\n+\t     arithmetic which operates on unsigned pointer types of size\n+\t     type size and ARRAY_REF offsets which are properly sign or\n+\t     zero extended from their type in case it is narrower than\n+\t     size type.  */\n+\t  if (offset0 == NULL_TREE)\n+\t    offset0 = build_int_cst (signed_size_type_node, 0);\n+\t  else\n+\t    offset0 = fold_convert (signed_size_type_node, offset0);\n+\t  if (offset1 == NULL_TREE)\n+\t    offset1 = build_int_cst (signed_size_type_node, 0);\n+\t  else\n+\t    offset1 = fold_convert (signed_size_type_node, offset1);\n+\n+\t  return fold_build2 (code, type, offset0, offset1);\n+\t}\n+    }\n+\n   if (FLOAT_TYPE_P (TREE_TYPE (arg0)))\n     {\n       tree targ0 = strip_float_extensions (arg0);\n@@ -10539,34 +10574,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t      tem, build_int_cst (TREE_TYPE (tem), 0));\n \t}\n \n-      /* If this is a comparison of two exprs that look like an\n-\t ARRAY_REF of the same object, then we can fold this to a\n-\t comparison of the two offsets.  This is only safe for\n-\t EQ_EXPR and NE_EXPR because of overflow issues.  */\n-      {\n-\ttree base0, offset0, base1, offset1;\n-\n-\tif (extract_array_ref (arg0, &base0, &offset0)\n-\t    && extract_array_ref (arg1, &base1, &offset1)\n-\t    && operand_equal_p (base0, base1, 0))\n-          {\n-\t    /* Handle no offsets on both sides specially.  */\n-\t    if (offset0 == NULL_TREE && offset1 == NULL_TREE)\n-\t      return fold_build2 (code, type, integer_zero_node,\n-\t\t\t\t  integer_zero_node);\n-\n-\t    if (!offset0 || !offset1\n-\t\t|| TREE_TYPE (offset0) == TREE_TYPE (offset1))\n-\t      {\n-\t        if (offset0 == NULL_TREE)\n-\t\t  offset0 = build_int_cst (TREE_TYPE (offset1), 0);\n-\t\tif (offset1 == NULL_TREE)\n-\t          offset1 = build_int_cst (TREE_TYPE (offset0), 0);\n-\t\treturn fold_build2 (code, type, offset0, offset1);\n-\t      }\n-\t  }\n-      }\n-\n       if (integer_zerop (arg1)\n \t  && tree_expr_nonzero_p (arg0))\n         {"}, {"sha": "21fa2734273435cba91411d999a3c485a91fa45c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec434b841e8120aad467db3efb249f536f5b819/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec434b841e8120aad467db3efb249f536f5b819/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7ec434b841e8120aad467db3efb249f536f5b819", "patch": "@@ -1,3 +1,8 @@\n+2006-06-04  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/27039\n+\t* gcc.dg/tree-ssa/loop-17.c: New testcase.\n+\n 2006-06-03  Roger Sayle  <roger@eyesopen.com>\n \n \tPR target/26223"}, {"sha": "26e49862091972e8215c584dbf951986687402d3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-17.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec434b841e8120aad467db3efb249f536f5b819/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec434b841e8120aad467db3efb249f536f5b819/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-17.c?ref=7ec434b841e8120aad467db3efb249f536f5b819", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-sccp-details\" } */\n+\n+/* To determine the number of iterations in this loop we need to fold\n+   p_4 + 4B > p_4 + 8B to false.  This transformation has caused\n+   troubles in the past due to overflow issues.  */\n+\n+int foo (int *p)\n+{\n+  int i = 0, *x;\n+\n+  for (x = p; x < p + 2; x++)\n+    i++;\n+\n+  return i;\n+}\n+\n+/* { dg-final { scan-tree-dump \"set_nb_iterations_in_loop = 2\" \"sccp\" } } */\n+/* { dg-final { cleanup-tree-dump \"sccp\" } } */"}]}