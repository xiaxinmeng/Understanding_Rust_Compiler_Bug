{"sha": "badea87de498912a933a33931e632eb98f5fdfe3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFkZWE4N2RlNDk4OTEyYTkzM2EzMzkzMWU2MzJlYjk4ZjVmZGZlMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2005-06-03T09:55:28Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2005-06-03T09:55:28Z"}, "message": "Revert my previous patch.\n\nFrom-SVN: r100536", "tree": {"sha": "9a007a73332492ade9946acd2795c2a31dd70a8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a007a73332492ade9946acd2795c2a31dd70a8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/badea87de498912a933a33931e632eb98f5fdfe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/badea87de498912a933a33931e632eb98f5fdfe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/badea87de498912a933a33931e632eb98f5fdfe3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/badea87de498912a933a33931e632eb98f5fdfe3/comments", "author": null, "committer": null, "parents": [{"sha": "b956116ebf3235acf5a6b8f94451de7020dfc804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b956116ebf3235acf5a6b8f94451de7020dfc804", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b956116ebf3235acf5a6b8f94451de7020dfc804"}], "stats": {"total": 23, "additions": 15, "deletions": 8}, "files": [{"sha": "b2b7575840e50c257fd6dd4d51208e13976147c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badea87de498912a933a33931e632eb98f5fdfe3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badea87de498912a933a33931e632eb98f5fdfe3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=badea87de498912a933a33931e632eb98f5fdfe3", "patch": "@@ -1,3 +1,7 @@\n+2005-06-02  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* reload1.c (reload): Revert my previous patch.\n+\n 2005-06-03  Nick Clifton  <nickc@redhat.com>\n \n \t* config/arm/semi.h (ASM_SPEC): Fix typo passing -mfloat-abi to"}, {"sha": "0caa411fb4b67c61f11709ab253148bdd754352b", "filename": "gcc/reload1.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badea87de498912a933a33931e632eb98f5fdfe3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badea87de498912a933a33931e632eb98f5fdfe3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=badea87de498912a933a33931e632eb98f5fdfe3", "patch": "@@ -752,7 +752,7 @@ reload (rtx first, int global)\n \t\t     for equivalences.  This is overly conservative as\n \t\t     we could find all sets of the destination pseudo\n \t\t     and remove them as they should be redundant.  */\n-\t\t  if (memory_operand (x, VOIDmode))\n+\t\t  if (memory_operand (x, VOIDmode) && ! MEM_READONLY_P (x))\n \t\t    {\n \t\t      /* Always unshare the equivalence, so we can\n \t\t\t substitute into this insn without touching the\n@@ -787,8 +787,14 @@ reload (rtx first, int global)\n \t\t  else\n \t\t    continue;\n \n-\t\t  reg_equiv_init[i]\n-\t\t    = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[i]);\n+\t\t  /* If this register is being made equivalent to a MEM\n+\t\t     and the MEM is not SET_SRC, the equivalencing insn\n+\t\t     is one with the MEM as a SET_DEST and it occurs later.\n+\t\t     So don't mark this insn now.  */\n+\t\t  if (!MEM_P (x)\n+\t\t      || rtx_equal_p (SET_SRC (set), x))\n+\t\t    reg_equiv_init[i]\n+\t\t      = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[i]);\n \t\t}\n \t    }\n \t}\n@@ -800,12 +806,9 @@ reload (rtx first, int global)\n \t       && reg_equiv_memory_loc[REGNO (SET_SRC (set))]\n \t       && rtx_equal_p (SET_DEST (set),\n \t\t\t       reg_equiv_memory_loc[REGNO (SET_SRC (set))]))\n-\t/* Equivalences made this way only have one initializing insn.\n-\t   Previously, we may have set reg_equiv_init when encountering a\n-\t   SET of this pseudo; discard that insn since it does not set up\n-\t   an equivalence.  */\n \treg_equiv_init[REGNO (SET_SRC (set))]\n-\t  = gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n+\t  = gen_rtx_INSN_LIST (VOIDmode, insn,\n+\t\t\t       reg_equiv_init[REGNO (SET_SRC (set))]);\n \n       if (INSN_P (insn))\n \tscan_paradoxical_subregs (PATTERN (insn));"}]}