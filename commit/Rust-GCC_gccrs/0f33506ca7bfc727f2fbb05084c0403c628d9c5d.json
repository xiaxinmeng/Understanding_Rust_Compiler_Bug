{"sha": "0f33506ca7bfc727f2fbb05084c0403c628d9c5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYzMzUwNmNhN2JmYzcyN2YyZmJiMDUwODRjMDQwM2M2MjhkOWM1ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-10T21:13:53Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-10T21:13:53Z"}, "message": "(version_string): Declare.\n\n(current_file_function_operand): New function, replaces\ncurrent_function_operand.\n(print_operand, case 'F'): Case deleted.\n(alpha_builtin_saveregs): Reworked to use homed arglists, as recommended in\nthe calling standard.\n(alpha_need_gp): Deleted, code moved into output_prolog.\n(alpha_gp_dead_after): Deleted; optimization is not safe.\n(alpha_write_verstamp): New function.\n(output_prolog, output_epilog): Major rework to update to current\ncalling standard.\n\nFrom-SVN: r3459", "tree": {"sha": "a3f6a9d78cb33109ee66119841b07610a2a5a5c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3f6a9d78cb33109ee66119841b07610a2a5a5c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f33506ca7bfc727f2fbb05084c0403c628d9c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f33506ca7bfc727f2fbb05084c0403c628d9c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f33506ca7bfc727f2fbb05084c0403c628d9c5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f33506ca7bfc727f2fbb05084c0403c628d9c5d/comments", "author": null, "committer": null, "parents": [{"sha": "4ba7b922dd2f6d22a009352d85223d0e44283d02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba7b922dd2f6d22a009352d85223d0e44283d02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ba7b922dd2f6d22a009352d85223d0e44283d02"}], "stats": {"total": 386, "additions": 119, "deletions": 267}, "files": [{"sha": "e87229925527c3597efa470b190427c09fa3da06", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 119, "deletions": 267, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f33506ca7bfc727f2fbb05084c0403c628d9c5d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f33506ca7bfc727f2fbb05084c0403c628d9c5d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=0f33506ca7bfc727f2fbb05084c0403c628d9c5d", "patch": "@@ -51,6 +51,8 @@ char *alpha_function_name;\n /* Nonzero if the current function needs gp.  */\n \n int alpha_function_needs_gp;\n+\n+extern char *version_string;\n \f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n \n@@ -270,15 +272,17 @@ input_operand (op, mode)\n   return 0;\n }\n \n-/* Return 1 if OP is a SYMBOL_REF for the current function.  */\n+/* Return 1 if OP is a SYMBOL_REF for a function known to be in this\n+   file.  */\n \n int\n-current_function_operand (op, mode)\n+current_file_function_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n   return (GET_CODE (op) == SYMBOL_REF\n-\t  && ! strcmp (XSTR (op, 0), current_function_name));\n+\t  && (SYMBOL_REF_FLAG (op)\n+\t      || op == XEXP (DECL_RTL (current_function_decl), 0)));\n }\n \n /* Return 1 if OP is a valid Alpha comparison operator.  Here we know which\n@@ -981,17 +985,6 @@ print_operand (file, x, code)\n \t}\n       break;\n \n-    case 'F':\n-      /* Write the symbol; if the current function uses GP, write a\n-\t modified version.  */\n-      if (GET_CODE (x) != SYMBOL_REF)\n-\toutput_operand_lossage (\"invalid %%F value\");\n-\n-      output_addr_const (file, x);\n-      if (alpha_function_needs_gp)\n-\tfprintf (file, \"..ng\");\n-      break;\n-\n     case 'A':\n       /* Write \"_u\" for unaligned access.  */\n       if (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == AND)\n@@ -1026,94 +1019,35 @@ alpha_builtin_saveregs (arglist)\n   int stdarg = (TYPE_ARG_TYPES (fntype) != 0\n \t\t&& (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n \t\t    != void_type_node));\n-  int nregs = current_function_args_info;\n \n-  /* If we have a variable-sized argument already, we will have used all\n-     the registers, so set up to indicate that.  */\n+  /* Compute the current position into the args, taking into account\n+     both registers and memory.  */\n \n-  if (GET_CODE (current_function_arg_offset_rtx) != CONST_INT)\n-    {\n-      argsize = plus_constant (current_function_arg_offset_rtx,\n-\t\t\t       (6 * UNITS_PER_WORD + UNITS_PER_WORD - 1));\n-      argsize = expand_shift (RSHIFT_EXPR, Pmode, argsize,\n-\t\t\t      build_int_2 (3, 0), argsize, 0);\n-    }\n-  else\n-    {\n-      /* Compute the number of args in memory and number of arguments already\n-\t processed.  Then adjust the number of registers if this is stdarg.  */\n-      int memargs = ((INTVAL (current_function_arg_offset_rtx)\n-\t\t      + UNITS_PER_WORD - 1)\n-\t\t     / UNITS_PER_WORD);\n-\n-      argsize = GEN_INT (MIN (nregs, 6) + memargs);\n-\n-      if (nregs <= 6)\n-\tnregs -= stdarg;\n-    }\n+  argsize = plus_constant (current_function_arg_offset_rtx,\n+\t\t\t   current_function_args_info * UNITS_PER_WORD);\n \n   /* Allocate the va_list constructor */\n-  block = assign_stack_local (BLKmode, 4 * UNITS_PER_WORD, BITS_PER_WORD);\n+  block = assign_stack_local (BLKmode, 2 * UNITS_PER_WORD, BITS_PER_WORD);\n   RTX_UNCHANGING_P (block) = 1;\n   RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n \n-  /* Store the argsize as the __va_arg member.  */\n+  /* Store the address of the first integer register in the\n+     __va_base member.   */\n+\n   emit_move_insn (change_address (block, DImode, XEXP (block, 0)),\n-\t\t  argsize);\n+\t\t  force_operand (plus_constant (virtual_incoming_args_rtx,\n+\t\t\t\t\t\t-6 * UNITS_PER_WORD),\n+\t\t\t\t NULL_RTX));\n \n-  /* Store the arg pointer in the __va_stack member.  */\n+  /* Store the argsize as the __va_offset member.  */\n   emit_move_insn (change_address (block, Pmode,\n \t\t\t\t  plus_constant (XEXP (block, 0),\n \t\t\t\t\t\t UNITS_PER_WORD)),\n-\t\t  virtual_incoming_args_rtx);\n-\n-  /* Allocate the integer register space, and store it as the\n-     __va_ireg member.  */\n-  addr = assign_stack_local (BLKmode, 6 * UNITS_PER_WORD, -1);\n-  MEM_IN_STRUCT_P (addr) = 1;\n-  RTX_UNCHANGING_P (addr) = 1;\n-  RTX_UNCHANGING_P (XEXP (addr, 0)) = 1;\n-\n-  emit_move_insn (change_address (block, Pmode,\n-\t\t\t\t  plus_constant (XEXP (block, 0),\n-\t\t\t\t\t\t 2 * UNITS_PER_WORD)),\n-\t\t  copy_to_reg (XEXP (addr, 0)));\n-\n-  /* Now store the incoming integer registers.  */\n-  if (nregs < 6)\n-      move_block_from_reg\n-\t(16 + nregs,\n-\t change_address (addr, Pmode,\n-\t\t\t plus_constant (XEXP (addr, 0),\n-\t\t\t\t\tnregs * UNITS_PER_WORD)),\n-\t 6 - nregs);\n-\n-  /* Allocate the FP register space, and store it as the\n-     __va_freg member.  */\n-  addr = assign_stack_local (BLKmode, 6 * UNITS_PER_WORD, -1);\n-  MEM_IN_STRUCT_P (addr) = 1;\n-  RTX_UNCHANGING_P (addr) = 1;\n-  RTX_UNCHANGING_P (XEXP (addr, 0)) = 1;\n-\n-  emit_move_insn (change_address (block, Pmode,\n-\t\t\t\t  plus_constant (XEXP (block, 0),\n-\t\t\t\t\t\t 3 * UNITS_PER_WORD)),\n-\t\t  copy_to_reg (XEXP (addr, 0)));\n-\n-  /* Now store the incoming floating-point registers.   If we are not\n-     to use the floating-point registers, store the integer registers\n-     in those locations too.  */\n-  if (nregs < 6)\n-      move_block_from_reg\n-\t(16 + 32 * (TARGET_FPREGS != 0) + nregs,\n-\t change_address (addr, Pmode,\n-\t\t\t plus_constant (XEXP (addr, 0),\n-\t\t\t\t\tnregs * UNITS_PER_WORD)),\n-\t 6 - nregs);\n+\t\t  force_operand (argsize, NULL_RTX));\n \n   /* Return the address of the va_list constructor, but don't put it in a\n-     register.  This fails when not optimizing and produces worse code when\n-     optimizing.  */\n+     register.  Doing so would fail when not optimizing and produce worse\n+     code when optimizing.  */\n   return XEXP (block, 0);\n }\n \f\n@@ -1132,77 +1066,15 @@ alpha_sa_size ()\n     if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i])\n       size++;\n \n-  return size * 8;\n-}\n-\n-/* Return non-zero if this function needs gp.  It does if it has\n-   an LDSYM insn.  */\n-\n-int\n-alpha_need_gp ()\n-{\n-  rtx insn;\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t&& GET_CODE (PATTERN (insn)) != USE\n-\t&& GET_CODE (PATTERN (insn)) != CLOBBER\n-\t&& get_attr_type (insn) == TYPE_LDSYM)\n-      return 1;\n-\n-  return 0;\n-}\n-\n-/* Return 1 if GP is dead at after INSN.  */\n-\n-int\n-alpha_gp_dead_after (insn)\n-     rtx insn;\n-{\n-  int jump_count = 0;\n-  int found = 0;\n-  rtx p;\n-\n-  /* If we aren't optimizing, don't do this optimization.  More importantly,\n-     JUMP_LABEL isn't properly set when not optimizing.  */\n-\n-  if (optimize == 0)\n-    return 0;\n-\n-  /* If we are followed by a BARRIER, we don't return.  */\n-  if (NEXT_INSN (insn) && GET_CODE (NEXT_INSN (insn)) == BARRIER)\n-    return 1;\n-\n-  /* Otherwise search for a use of GP before a return.  */\n-\n-  for (p = next_active_insn (insn); p; p = next_active_insn (p))\n-    {\n-      if (get_attr_type (p) == TYPE_LDSYM\n-\t  || get_attr_type (p) == TYPE_JSR)\n-\t{\n-\t  found = 1;\n-\t  break;\n-\t}\n-\n-      if (GET_CODE (p) == JUMP_INSN)\n-\t{\n-\t  if (GET_CODE (PATTERN (p)) == RETURN)\n-\t    break;\n-\n-\t  if (! simplejump_p (p) || jump_count++ > 10)\n-\t    {\n-\t      found = 1;\n-\t      break;\n-\t    }\n+  /* If we are going to need a frame, we MUST save $26.  */\n+  if (! regs_ever_live[26]\n+      && (size != 0\n+\t  || get_frame_size () != 0\n+\t  || current_function_outgoing_args_size != 0\n+\t  || current_function_pretend_args_size != 0))\n+    size++;\n \n-\t  p = JUMP_LABEL (p);\n-\t}\n-    }\n-\n-  /* Restore any operands destroyed by the attribute calls above.  */\n-  insn_extract (insn);\n-\n-  return ! found;\n+  return size * 8;\n }\n \n /* Return 1 if this function can directly return via $26.  */\n@@ -1215,6 +1087,27 @@ direct_return ()\n \t  && current_function_pretend_args_size == 0);\n }\n \n+/* Write a version stamp.  Don't write anything if we are running as a\n+   cross-compiler.  Otherwise, use the versions in /usr/include/stamp.h.  */\n+\n+#ifndef CROSS_COMPILE\n+#include <stamp.h>\n+#endif\n+\n+void\n+alpha_write_verstamp (file)\n+     FILE *file;\n+{\n+#ifdef MS_STAMP\n+  char *p;\n+\n+  fprintf (file, \"\\t.verstamp %d %d \", MS_STAMP, LS_STAMP);\n+  for (p = version_string; *p != ' ' && *p != 0; p++)\n+    fprintf (file, \"%c\", *p == '.' ? ' ' : *p);\n+  fprintf (file, \"\\n\");\n+#endif\n+}\n+\n /* Write function prologue.  */\n \n void\n@@ -1225,29 +1118,33 @@ output_prolog (file, size)\n   HOST_WIDE_INT frame_size = ((size + current_function_outgoing_args_size\n \t\t\t       + current_function_pretend_args_size\n \t\t\t       + alpha_sa_size () + 15) & ~15);\n-  int reg_offset = current_function_outgoing_args_size;\n+  int reg_offset = size + current_function_outgoing_args_size;\n+  rtx insn;\n   int start_reg_offset = reg_offset;\n   unsigned reg_mask = 0;\n   int i;\n \n-  /* If we need a GP, load it first.  */\n-  alpha_function_needs_gp = alpha_need_gp ();\n+  /* If we need a GP (we have a LDSYM insn or a CALL_INSN) and we are not\n+     a static function), load it first.  */\n+\n+  alpha_function_needs_gp = 0;\n+  if (TREE_PUBLIC (current_function_decl))\n+    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+      if ((GET_CODE (insn) == CALL_INSN)\n+\t  || (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t      && GET_CODE (PATTERN (insn)) != USE\n+\t      && GET_CODE (PATTERN (insn)) != CLOBBER\n+\t      && get_attr_type (insn) == TYPE_LDSYM))\n+\t{\n+\t  alpha_function_needs_gp = 1;\n+\t  break;\n+\t}\n \n   if (alpha_function_needs_gp)\n-    {\n-      rtx insn;\n+    fprintf (file, \"\\tldgp $29,0($27)\\n\");\n \n-      fprintf (file, \"\\tldgp $29,0($27)\\n\");\n-\n-      /* If we have a recursive call, put a special label here.  */\n-      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == CALL_INSN\n-\t    && get_attr_type (insn) != TYPE_JSR)\n-\t  {\n-\t    fprintf (file, \"%s..ng:\\n\", current_function_name);\n-\t    break;\n-\t  }\n-    }\n+  /* Put a label after the GP load so we can enter the function at it.  */\n+  fprintf (file, \"%s..ng:\\n\", alpha_function_name);\n \n   /* Adjust the stack by the frame size.  If the frame size is > 32768\n      bytes, we have to load it into a register first and then subtract\n@@ -1290,30 +1187,25 @@ output_prolog (file, size)\n \t}\n \n       fprintf (file, \"\\tldah $28,%d($%d)\\n\", high, in_reg);\n-\n       fprintf (file, \"\\tsubq $30,$28,$30\\n\");\n     }\n   else if (frame_size)\n     fprintf (file, \"\\tlda $30,-%d($30)\\n\", frame_size);\n \n-  /* Write out the .frame line.  If we need a frame pointer, we use\n-     an offset of zero.  */\n-\n-  if (frame_pointer_needed)\n-    fprintf (file, \"\\t.frame $15,0,$26\\n\");\n-  else\n-    fprintf (file, \"\\t.frame $30,%d,$26\\n\", frame_size);\n-\n+  /* Describe our frame.  */\n+  fprintf (file, \"\\t.frame $%d,%d,$26,%d\\n\", \n+\t   frame_pointer_needed ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM,\n+\t   frame_size, current_function_pretend_args_size);\n     \n-  /* Save register 26 if it is used.  */\n-  if (regs_ever_live[26])\n+  /* Save register 26 if we have a frame.  */\n+  if (frame_size != 0)\n     {\n       reg_mask |= 1 << 26;\n       fprintf (file, \"\\tstq $26,%d($30)\\n\", reg_offset);\n       reg_offset += 8;\n     }\n \n-  /* Now save any other used register that are required to be saved.  */\n+  /* Now save any other used integer registers required to be saved.  */\n   for (i = 0; i < 32; i++)\n     if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i] && i != 26)\n       {\n@@ -1343,21 +1235,13 @@ output_prolog (file, size)\n   if (reg_mask)\n     fprintf (file, \"\\t.fmask 0x%x,%d\\n\", reg_mask, start_reg_offset);\n \n-  /* If we need a frame pointer, set it to the value of incoming stack\n-     which we compute by adding back the frame size pointer.  Because we\n-     can subtract one more than we can add, we have to special-case\n-     frame sizes of 32K.  Note that there is no restriction that the frame\n-     pointer be updated in one instruction.  */\n-\n+  /* If we need a frame pointer, set it from the stack pointer.  Note that\n+     this must always be the last instruction in the prologue.  */\n   if (frame_pointer_needed)\n-    {\n-      if (frame_size == 32768)\n-\tfprintf (file, \"\\tlda $15,16384($30)\\n\\tlda $15,16384($15)\\n\");\n-      else if (frame_size > 32768)\n-\tfprintf (file, \"\\taddq $30,$28,$15\\n\");\n-      else\n-\tfprintf (file, \"\\tlda $15,%d($30)\\n\", frame_size);\n-    }\n+    fprintf (file, \"\\tbis $30,$30,$15\\n\");\n+\n+  /* End the prologue and say if we used gp.  */\n+  fprintf (file, \"\\t.prologue %d\\n\", alpha_function_needs_gp);\n }\n \n /* Write function epilogue.  */\n@@ -1371,8 +1255,7 @@ output_epilog (file, size)\n   HOST_WIDE_INT frame_size = ((size + current_function_outgoing_args_size\n \t\t\t       + current_function_pretend_args_size\n \t\t\t       + alpha_sa_size () + 15) & ~15);\n-  int reg_offset = current_function_outgoing_args_size;\n-  int reg_offset_from = STACK_POINTER_REGNUM;\n+  int reg_offset = size + current_function_outgoing_args_size;\n   int i;\n \n   /* If the last insn was a BARRIER, we don't have to write anything except\n@@ -1381,90 +1264,47 @@ output_epilog (file, size)\n     insn = prev_nonnote_insn (insn);\n   if (insn == 0 || GET_CODE (insn) != BARRIER)\n     {\n-      /* If we have a frame pointer, we restore the registers from an\n-\t offset from it, assuming that we can reach the offset.  If not,\n-\t we have to compute the address using a scratch register.  This is\n-\t messy, but should not be common.  We have to copy the frame\n-\t pointer elsewhere here since we will be restoring it before we can\n-\t use it to restore the stack pointer.  We use $25.  */\n+      int fp_offset;\n \n+      /* If we have a frame pointer, restore SP from it.  */\n       if (frame_pointer_needed)\n-\t{\n-\t  fprintf (file, \"\\tbis $15,$15,$25\\n\");\n-\n-\t  if (frame_size < 32768)\n-\t    reg_offset -= frame_size, reg_offset_from = 25;\n-\t  else\n-\t    {\n-\t      HOST_WIDE_INT low\n-\t\t= (frame_size & 0xffff) - 2 * (frame_size & 0x8000);\n-\t      HOST_WIDE_INT tmp1 = frame_size - low;\n-\t      HOST_WIDE_INT high\n-\t\t= ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n-\t      HOST_WIDE_INT tmp2 = frame_size - (high << 16) - low;\n-\t      int extra = 0;\n-\t      int in_reg = 31;\n-\n-\t      if (tmp2)\n-\t\t{\n-\t\t  extra = 0x4000;\n-\t\t  tmp1 -= 0x40000000;\t\n-\t\t  high = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n-\t\t}\n-\n-\t      if (low != 0)\n-\t\t{\n-\t\t  fprintf (file, \"\\tlda $28,%d($%d)\\n\", low, in_reg);\n-\t\t  in_reg = 28;\n-\t\t}\n-\n-\t      if (extra)\n-\t\t{\n-\t\t  fprintf (file, \"\\tldah $28,%d($%d)\\n\", extra, in_reg);\n-\t\t  in_reg = 28;\n-\t\t}\n-\n-\t      fprintf (file, \"\\tldah $28,%d($%d)\\n\", high, in_reg);\n-\n-\t      fprintf (file, \"\\tsubq $25,$28,$28\\n\");\n-\n-\t      reg_offset_from = 28;\n-\t    }\n-\t}\n+\tfprintf (file, \"\\tbis $15,$15,$30\\n\");\n \n       /* Restore all the registers, starting with the return address\n \t register.  */\n-      if (regs_ever_live[26])\n+      if (frame_size != 0)\n \t{\n-\t  fprintf (file, \"\\tldq $26,%d($%d)\\n\", reg_offset, reg_offset_from);\n+\t  fprintf (file, \"\\tldq $26,%d($30)\\n\", reg_offset);\n \t  reg_offset += 8;\n \t}\n \n-      /* Now restore any other used register that that we saved.  */\n+      /* Now restore any other used integer registers that that we saved,\n+\t except for FP if it is being used as FP, since it must be\n+\t restored last.  */\n+\n       for (i = 0; i < 32; i++)\n \tif (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i]\n \t    && i != 26)\n \t  {\n-\t    fprintf (file, \"\\tldq $%d,%d($%d)\\n\",\n-\t\t     i, reg_offset, reg_offset_from);\n+\t    if (i == FRAME_POINTER_REGNUM && frame_pointer_needed)\n+\t      fp_offset = reg_offset;\n+\t    else\n+\t      fprintf (file, \"\\tldq $%d,%d($30)\\n\", i, reg_offset);\n \t    reg_offset += 8;\n \t  }\n \n       for (i = 0; i < 32; i++)\n \tif (! fixed_regs[i + 32] && ! call_used_regs[i + 32]\n \t    && regs_ever_live[i + 32])\n \t  {\n-\t    fprintf (file, \"\\tldt $f%d,%d($%d)\\n\",\n-\t\t     i, reg_offset, reg_offset_from);\n+\t    fprintf (file, \"\\tldt $f%d,%d($30)\\n\", i, reg_offset);\n \t    reg_offset += 8;\n \t  }\n \n-      /* Restore the stack.  If we have a frame pointer, use it.  Otherwise,\n-\t add the size back into the stack, handling the large frame size.  */\n-\n-      if (frame_pointer_needed)\n-\tfprintf (file, \"\\tbis $25,$25,$30\\n\");\n-      else if (frame_size > 32767)\n+      /* If the stack size is large, compute the size of the stack into\n+\t a register because the old FP restore, stack pointer adjust,\n+\t and return are required to be consecutive instructions.  */\n+      if (frame_size > 32767)\n \t{\n \t  HOST_WIDE_INT low\n \t    = (frame_size & 0xffff) - 2 * (frame_size & 0x8000);\n@@ -1501,16 +1341,28 @@ output_epilog (file, size)\n \t    }\n \n \t  fprintf (file, \"\\tldah $28,%d($%d)\\n\", high, in_reg);\n-\n-\t  fprintf (file, \"\\taddq $30,$28,$30\\n\");\n \t}\n-      else if (frame_size)\n+\n+      /* If we needed a frame pointer and we have to restore it, do it\n+\t now.  */\n+\n+      if (frame_pointer_needed && regs_ever_live[FRAME_POINTER_REGNUM])\n+\tfprintf (file, \"\\tldq $15,%d($30)\\n\", fp_offset);\n+\n+      /* Now update the stack pointer, if needed.  This must be done in\n+\t one, styalized, instruction.  */\n+      if (frame_size > 32768)\n+\tfprintf (file, \"\\taddq $28,$30,$30\\n\");\n+      else\n \tfprintf (file, \"\\tlda $30,%d($30)\\n\", frame_size);\n \n-      /* Now return to the caller.  */\n+      /* Finally return to the caller.  */\n       fprintf (file, \"\\tret $31,($26),1\\n\");\n     }\n \n   /* End the function.  */\n   fprintf (file, \"\\t.end %s\\n\", alpha_function_name);\n+\n+  /* Show that we know this function if it is called again.  */\n+  SYMBOL_REF_FLAG (XEXP (DECL_RTL (current_function_decl), 0)) = 1;\n }"}]}