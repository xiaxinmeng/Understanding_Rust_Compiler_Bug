{"sha": "98af7219f2d5178717e39895abf3e95087a11eb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThhZjcyMTlmMmQ1MTc4NzE3ZTM5ODk1YWJmM2U5NTA4N2ExMWViNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-23T00:39:48Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-23T00:39:48Z"}, "message": "reload1.c (indirect_symref_ok): Make it global.\n\n\t* reload1.c (indirect_symref_ok): Make it global.\n\t* reload.h: Add a prototype for indirect_symref_ok.\n\nFrom-SVN: r96913", "tree": {"sha": "ff2a0daa2058ddde99f262974dba16f1a1aac9cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff2a0daa2058ddde99f262974dba16f1a1aac9cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98af7219f2d5178717e39895abf3e95087a11eb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98af7219f2d5178717e39895abf3e95087a11eb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98af7219f2d5178717e39895abf3e95087a11eb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98af7219f2d5178717e39895abf3e95087a11eb4/comments", "author": null, "committer": null, "parents": [{"sha": "5983a90e8e796765f599f65e5ed763a8013703af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5983a90e8e796765f599f65e5ed763a8013703af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5983a90e8e796765f599f65e5ed763a8013703af"}], "stats": {"total": 11, "additions": 10, "deletions": 1}, "files": [{"sha": "e3dbd08a533974248ccdeab6f75252a526bd3fa9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af7219f2d5178717e39895abf3e95087a11eb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af7219f2d5178717e39895abf3e95087a11eb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98af7219f2d5178717e39895abf3e95087a11eb4", "patch": "@@ -4,6 +4,9 @@\n \tstatic.\n \t* reload.h: Remove the prototype for indirect_symref_ok.\n \n+\t* reload1.c (indirect_symref_ok): Make it global.\n+\t* reload.h: Add a prototype for indirect_symref_ok.\n+\n 2005-03-22  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.md (ashlhi3): Rename to *ashlhi3_n and add a new"}, {"sha": "1c5463d3d5bcc289b0d889367c6d9abbd9d37e8c", "filename": "gcc/reload.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af7219f2d5178717e39895abf3e95087a11eb4/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af7219f2d5178717e39895abf3e95087a11eb4/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=98af7219f2d5178717e39895abf3e95087a11eb4", "patch": "@@ -182,6 +182,12 @@ extern int reload_n_operands;\n    Used in find_equiv_reg.  */\n extern int reload_first_uid;\n \n+/* Nonzero if indirect addressing is supported when the innermost MEM is\n+   of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to\n+   which these are valid is the same as spill_indirect_levels, above.  */\n+\n+extern char indirect_symref_ok;\n+\n /* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\n extern char double_reg_address_ok;\n "}, {"sha": "41a2f02f9a74a75fde4a082c444e183aac78fe2a", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af7219f2d5178717e39895abf3e95087a11eb4/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af7219f2d5178717e39895abf3e95087a11eb4/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=98af7219f2d5178717e39895abf3e95087a11eb4", "patch": "@@ -229,7 +229,7 @@ static char spill_indirect_levels;\n /* Nonzero if indirect addressing is supported when the innermost MEM is\n    of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to\n    which these are valid is the same as spill_indirect_levels, above.  */\n-static char indirect_symref_ok;\n+char indirect_symref_ok;\n \n /* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\n char double_reg_address_ok;"}]}