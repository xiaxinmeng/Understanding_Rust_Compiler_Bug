{"sha": "352a77c8dc72715bbe230e04cd72583d5a900291", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUyYTc3YzhkYzcyNzE1YmJlMjMwZTA0Y2Q3MjU4M2Q1YTkwMDI5MQ==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2004-08-08T04:47:17Z"}, "committer": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2004-08-08T04:47:17Z"}, "message": "Make-lang.in (TREE_BE_LIBS): Remove.\n\n\ntreelang:\n2004-08-01  James A. Morrison  <phython@gcc.gnu.org>\n\n        * Make-lang.in (TREE_BE_LIBS): Remove.\n        (tree1): Depend on BACKEND and LIBDEPS.  Use BACKEND and LIBS instead\n        of TREE_BE_LIBS.\n        * parse.y: Add variable_defs_opt before statements_opt.\n        Use tree_code_get_type instead of get_type_for_numeric_type.\n        Reformat long lines.\n        (parameters_opt): New rule.\n        (function_prototype): Use parameters_opt.\n        (return): Remove calls to print_token in error cases.  Use VOID_TYPE.\n        (check_type_match): Use VOID_TYPE.\n        * lex.l (update_lineno_charno): Ensure INPUT_LINE starts at 1.\n        * tree1.c: Include version.h and cgraph.h\n        (treelang_parse_file): Call cgraph_finalize_compilation_unit and\n        cgraph_optimize.\n        * treelang.h (item): Remove extraneous GTY.\n        * treetree.h (get_type_for_numeric_type): Remove.\n        * treetree.c: Include tree-dump.h, tree-iterator.h, tree-gimple.h,\n        function.h, and cgraph.h.  Don't include rtl.h\n        (keep_level_p): Remove.\n        (tree_push_atomic_type_decl): Remove.\n         (get_type_for_numeric_type): Remove.\n        (tree_code_get_numeric_type): Remove.\n        (global_bindings_p): Make static.\n        (getdecls): Likewise.\n        (insert_block): Likewise.\n        (tree_code_if_start): Create a COND_EXPR and add it to the tree\n        instead of creating rtl.\n        (tree_code_if_else): Create a BIND_EXPR if any variables were created\n        in the if statement.\n        (tree_code_end_if): Likewise.\n        (tree_code_create_function_prototype): Use tree_code_get_type.\n        Don't use SET_DECL_ASSEMBLER_NAME.\n        (tree_code_create_function_initial): Set DECL_ARTIFICIAL and\n        DECL_IGNORING_P on RESULT_DECL.  Use tree_code_get_type.  Don't call\n        layout_decl on RESULT_DECL.  Don't call rtl expand functions.\n        (tree_code_create_function_wrapup): Don't call rtl expand functions.\n        Create a BIND_EXPR for each function.  Dump original and gimplified\n        copies of the function tree.  Gimplify function.\n        (tree_code_create_variable): Use tree_code_get_type.  Don't call\n        layout_decl or expand_decl.  Fold CONVERT_EXPRs.\n        (tree_code_generate_return): Fold CONVERT_EXPRs and MODIFY_EXPRs.\n        Add RETURN_EXPR to the current statement list.  Don't call rtl expand\n        functions.\n        (tree_code_output_expression_statement): Append CODE to current\n        statement list.\n        (tree_code_get_expression): Fold expressions.  Build a pointer to\n        a FUNCTION_TYPE intead of the called functions return type.\n        (struct binding_level): Add statement list STMTS.\n        (getstmtlist): New Function.\n        (pushlevel): Make static.  Allocate an empty statement list.\n        (poplevel): Make static.  Don't clear BLOCK_NODE's BLOCK_VARS.\n        Don't use DECL_ASSEMBLER_NAME.\n        (tree_push_type_decl): Set TYPE_NAME of TYPE_NODE to ID.\n        (treelang_init_decl_processing): Define basic types after unused types.\n        Don't call tree_push_atomic_type_decl.\n        (builtin_function): Don't call make_decl_rtl.\n        (treelang_expand_function). New Function.\n\ntestsuite/treelang:\n        * compile/vars_def.tree: New File.\n        * compile/badreturn.tree: New File.\n\nFrom-SVN: r85684", "tree": {"sha": "664241e1e8c5de43d446667d9fa32444b7f9d395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/664241e1e8c5de43d446667d9fa32444b7f9d395"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/352a77c8dc72715bbe230e04cd72583d5a900291", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/352a77c8dc72715bbe230e04cd72583d5a900291", "html_url": "https://github.com/Rust-GCC/gccrs/commit/352a77c8dc72715bbe230e04cd72583d5a900291", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/352a77c8dc72715bbe230e04cd72583d5a900291/comments", "author": null, "committer": null, "parents": [{"sha": "c30ff96bd5accd7eca47ee060ee1e7f1f702cc11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c30ff96bd5accd7eca47ee060ee1e7f1f702cc11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c30ff96bd5accd7eca47ee060ee1e7f1f702cc11"}], "stats": {"total": 714, "additions": 406, "deletions": 308}, "files": [{"sha": "e0e38637a60fb7b468351724ef34fcdfd4954551", "filename": "gcc/testsuite/treelang/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2FChangeLog?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -1,3 +1,8 @@\n+2004-07-31  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\t* compile/vars_def.tree: New File.\n+\t* compile/badreturn.tree: New File.\n+\n 2004-01-18  James A. Morrison  <ja2morri@uwaterloo.ca>\n \n         * compile/compile.exp: New File."}, {"sha": "b7140199d4d88b4aaaf108ff5d01eb6023dfc791", "filename": "gcc/testsuite/treelang/a01gcci01.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fa01gcci01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fa01gcci01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fa01gcci01.c?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -27,6 +27,7 @@\n int add(int, int);\n int subtract(int, int);\n int first_nonzero(int, int);\n+extern int printf(char *template, ...);\n \n int \n main (int argc, char *argv[])"}, {"sha": "60d3b120c5db985ae74ed0442529359500d153d3", "filename": "gcc/testsuite/treelang/compile/badreturn.tree", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fbadreturn.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fbadreturn.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fbadreturn.tree?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+\n+external_definition void bar ();\n+external_definition int gar (int arg0);\n+\n+bar\n+{\n+\treturn 0; // { dg-warning \"return\" }\n+}\n+\n+gar\n+{\n+\treturn; // { dg-error \"return\" }\n+}"}, {"sha": "836c3251099c89801b3765d904f8c1b3062c524c", "filename": "gcc/testsuite/treelang/compile/compile.exp", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fcompile.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fcompile.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fcompile.exp?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -0,0 +1,31 @@\n+# Tests for treelang; run from gcc/treelang/Make-lang.in => gcc/Makefile\n+\n+# Copyright (C) 2004 by The Free Software Foundation\n+\n+# This program is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+#\n+# In other words, you are welcome to use, share and improve this program.\n+# You are forbidden to forbid anyone else to use, share and improve\n+# what you give them.   Help stamp out software-hoarding!\n+\n+# Treelang tests that only need to compile.\n+\n+# Load support procs.\n+load_lib treelang-dg.exp\n+\n+dg-init\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.tree]] \"\" \"\"\n+dg-finish"}, {"sha": "2d50323303fbbb1ec53b23bf5d931930dd527444", "filename": "gcc/testsuite/treelang/compile/full_unit.tree", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Ffull_unit.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Ffull_unit.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Ffull_unit.tree?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+// { dg-options \"-funit-at-a-time\" }\n+external_definition int add (int arga, int argb);\n+external_definition char sub (char argc, char argd);\n+\n+add\n+{\n+\treturn arga + argb + +3;\n+}\n+\n+sub\n+{\n+\treturn argd - argc + +2;\n+}\n+// { dg-final { scan-assembler \"add\" } }\n+// { dg-final { scan-assembler \"sub\" } }"}, {"sha": "6294c15c49ab565580a41b7e91f8ef993ef163d6", "filename": "gcc/testsuite/treelang/compile/tabs.tree", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Ftabs.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Ftabs.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Ftabs.tree?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+external_definition int main(int argc);\n+\n+main {\n+\tautomatic int v1;\n+\tautomatic int v2;\n+\tv1 = argc;\n+\tv2 = 3;\n+\n+        return v2;\n+}"}, {"sha": "ed03b6223e7640e8c83fd09e9ac1a6499d4e2f6f", "filename": "gcc/testsuite/treelang/compile/var_defs.tree", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fvar_defs.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fvar_defs.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fvar_defs.tree?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile }\n+external_definition void boring (int arg0);\n+external_definition char condition (char arg1, char arg2);\n+external_definition int first_nonzero (int arg5, int arg6);\n+\n+boring\n+{\n+  arg0 = +5  + +3;  // Force 3 and 5 to be signed numbers.\n+  arg0 = arg0 + +3;\n+}\n+\n+condition\n+{\n+  if (arg1)\n+    {\n+      automatic int i;\n+      return arg1;\n+    }\n+  else\n+    {\n+      return 0;\n+    }\n+}\n+\n+first_nonzero\n+{\n+  if (arg5)\n+    {\n+      return arg5;\n+    }\n+  else\n+    {\n+      automatic int j;\n+      j = arg6;\n+      return j;\n+    }\n+  return arg6;\n+}\n+"}, {"sha": "73d367fe2e75b667463d51e1618706dbd9026f9f", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -1,3 +1,63 @@\n+2004-07-31  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\t* Make-lang.in (TREE_BE_LIBS): Remove.\n+\t(tree1): Depend on BACKEND and LIBDEPS.  Use BACKEND and LIBS instead\n+\tof TREE_BE_LIBS.\n+\t* parse.y: Add variable_defs_opt before statements_opt.\n+\tUse tree_code_get_type instead of get_type_for_numeric_type.\n+\tReformat long lines.\n+\t(parameters_opt): New rule.\n+\t(function_prototype): Use parameters_opt.\n+\t(return): Remove calls to print_token in error cases.  Use VOID_TYPE.\n+\t(check_type_match): Use VOID_TYPE.\n+\t* lex.l (update_lineno_charno): Ensure INPUT_LINE starts at 1.\n+\t* tree1.c: Include version.h and cgraph.h\n+\t(treelang_parse_file): Call cgraph_finalize_compilation_unit and\n+\tcgraph_optimize.\n+\t* treelang.h (item): Remove extraneous GTY.\n+\t* treetree.h (get_type_for_numeric_type): Remove.\n+\t* treetree.c: Include tree-dump.h, tree-iterator.h, tree-gimple.h,\n+\tfunction.h, and cgraph.h.  Don't include rtl.h\n+\t(keep_level_p): Remove.\n+\t(tree_push_atomic_type_decl): Remove.\n+\t(get_type_for_numeric_type): Remove.\n+\t(tree_code_get_numeric_type): Remove.\n+\t(global_bindings_p): Make static.\n+\t(getdecls): Likewise.\n+\t(insert_block): Likewise.\n+\t(tree_code_if_start): Create a COND_EXPR and add it to the tree\n+\tinstead of creating rtl.\n+\t(tree_code_if_else): Create a BIND_EXPR if any variables were created\n+\tin the if statement.\n+\t(tree_code_end_if): Likewise.\n+\t(tree_code_create_function_prototype): Use tree_code_get_type.\n+\tDon't use SET_DECL_ASSEMBLER_NAME.\n+\t(tree_code_create_function_initial): Set DECL_ARTIFICIAL and\n+\tDECL_IGNORING_P on RESULT_DECL.  Use tree_code_get_type.  Don't call\n+\tlayout_decl on RESULT_DECL.  Don't call rtl expand functions.\n+\t(tree_code_create_function_wrapup): Don't call rtl expand functions.\n+\tCreate a BIND_EXPR for each function.  Dump original and gimplified\n+\tcopies of the function tree.  Gimplify function.\n+\t(tree_code_create_variable): Use tree_code_get_type.  Don't call\n+\tlayout_decl or expand_decl.  Fold CONVERT_EXPRs.\n+\t(tree_code_generate_return): Fold CONVERT_EXPRs and MODIFY_EXPRs.\n+\tAdd RETURN_EXPR to the current statement list.  Don't call rtl expand\n+\tfunctions.\n+\t(tree_code_output_expression_statement): Append CODE to current\n+\tstatement list.\n+\t(tree_code_get_expression): Fold expressions.  Build a pointer to\n+\ta FUNCTION_TYPE intead of the called functions return type.\n+\t(struct binding_level): Add statement list STMTS.\n+\t(getstmtlist): New Function.\n+\t(pushlevel): Make static.  Allocate an empty statement list.\n+\t(poplevel): Make static.  Don't clear BLOCK_NODE's BLOCK_VARS.\n+\tDon't use DECL_ASSEMBLER_NAME.\n+\t(tree_push_type_decl): Set TYPE_NAME of TYPE_NODE to ID.\n+\t(treelang_init_decl_processing): Define basic types after unused types.\n+\tDon't call tree_push_atomic_type_decl.\n+\t(builtin_function): Don't call make_decl_rtl.\n+\t(treelang_expand_function). New Function.\n+\n 2004-07-11  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* treetree.c (set_block): Remove."}, {"sha": "2ea3b656c3868a2643ea3e455a016a347e9d745d", "filename": "gcc/treelang/Make-lang.in", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FMake-lang.in?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -45,10 +45,6 @@\n TREELANGSED = sed\n TREELANGSEDFLAGS = -n\n \n-# back end compiler libraries etc\n-TREE_BE_LIBS = $(BACKEND) $(LIBIBERTY) $(INTLIBS) $(LIBS) $(LIBDEPS)\n-\n-\n GCC_EXTRAS = -B./ -B$(build_tooldir)/bin/ -isystem $(build_tooldir)/include\n \n # ./xgcc is the just built compiler. See GCC_FOR_TARGET in the GCC Makefile.in.\n@@ -83,11 +79,11 @@ treelang.done: tree1$(exeext)\n # core compiler\n tree1$(exeext): treelang/tree1.o treelang/treetree.o treelang/tree-convert.o \\\n \ttreelang/lex.o treelang/parse.o \\\n-\t$(TREE_BE_LIBS) attribs.o\n+\t$(BACKEND) $(LIBSDEPS) attribs.o\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n \ttreelang/tree1.o treelang/treetree.o treelang/tree-convert.o \\\n \ttreelang/lex.o treelang/parse.o \\\n-\t$(TREE_BE_LIBS) attribs.o\n+\t$(BACKEND) $(LIBS) attribs.o\n \n #\f\n # Compiling object files from source files."}, {"sha": "a93432f94bac4a22630bc61e411390bef7f45bae", "filename": "gcc/treelang/lex.l", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Flex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Flex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Flex.l?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -4,7 +4,7 @@\n \n    ---------------------------------------------------------------------\n \n-   Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002, 2003\n+   Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n    \n    This program is free software; you can redistribute it and/or modify it \n@@ -233,6 +233,9 @@ update_lineno_charno (void)\n    int yyl;\n    ((struct prod_token_parm_item *)yylval)->tp.tok.location = input_location;\n    ((struct prod_token_parm_item *)yylval)->tp.tok.charno = next_tree_charno;\n+   if (input_line == 0)\n+     input_line = 1;\n+\n    for ( yyl = 0; yyl < yyleng; ++yyl ) \n       {\n          if ( yytext[yyl] == '\\n' ) "}, {"sha": "29da1629b34efa186a5f2daf493789e7217d78b5", "filename": "gcc/treelang/parse.y", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fparse.y?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -5,7 +5,8 @@\n \n      ---------------------------------------------------------------------\n \n-     Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+     Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n+     Free Software Foundation, Inc.\n \n      This program is free software; you can redistribute it and/or modify it\n      under the terms of the GNU General Public License as published by the\n@@ -254,7 +255,7 @@ typename NAME {\n ;\n \n function_prototype:\n-storage typename NAME LEFT_PARENTHESIS parameters RIGHT_PARENTHESIS SEMICOLON {\n+storage typename NAME LEFT_PARENTHESIS parameters_opt RIGHT_PARENTHESIS SEMICOLON {\n   struct prod_token_parm_item* tok;\n   struct prod_token_parm_item *prod;\n   struct prod_token_parm_item *type;\n@@ -450,6 +451,14 @@ INT {\n }\n ;\n \n+parameters_opt:\n+/* Nothing to do.  */ {\n+ $$ = 0;\n+}\n+| parameters {\n+ $$ = $1;\n+}\n+\n parameters:\n parameter {\n   /* Nothing to do.  */\n@@ -496,15 +505,15 @@ IF LEFT_PARENTHESIS expression RIGHT_PARENTHESIS {\n   ensure_not_void (NUMERIC_TYPE (exp), exp->tp.pro.main_token);\n   tree_code_if_start (exp->tp.pro.code, tok->tp.tok.location);\n }\n-LEFT_BRACE statements_opt RIGHT_BRACE {\n+LEFT_BRACE variable_defs_opt statements_opt RIGHT_BRACE {\n   /* Just let the statements flow.  */\n }\n ELSE {\n   struct prod_token_parm_item* tok;\n   tok = $1;\n   tree_code_if_else (tok->tp.tok.location);\n }\n-LEFT_BRACE statements_opt RIGHT_BRACE {\n+LEFT_BRACE variable_defs_opt statements_opt RIGHT_BRACE {\n   struct prod_token_parm_item* tok;\n   tok = $12;\n   tree_code_if_end (tok->tp.tok.location);\n@@ -518,25 +527,23 @@ tl_RETURN expression_opt {\n   struct prod_token_parm_item* ret_tok;\n   ret_tok = $1;\n   type_prod = EXPRESSION_TYPE (current_function);\n-  if (NUMERIC_TYPE (type_prod) == VOID)\n+  if (NUMERIC_TYPE (type_prod) == VOID_TYPE)\n     if ($2 == NULL)\n       tree_code_generate_return (type_prod->tp.pro.code, NULL);\n     else\n       {\n         fprintf (stderr, \"%s:%i:%i: Redundant expression in return\\n\",\n-\t\t ret_tok->tp.tok.location.file,\n-\t\t ret_tok->tp.tok.location.line, ret_tok->tp.tok.charno);\n-        print_token (stderr, 0, ret_tok);\n+                ret_tok->tp.tok.location.file,\n+                ret_tok->tp.tok.location.line, ret_tok->tp.tok.charno);\n         errorcount++;\n         tree_code_generate_return (type_prod->tp.pro.code, NULL);\n-      }\n+       }\n   else\n     if ($2 == NULL)\n       {\n         fprintf (stderr, \"%s:%i:%i: Expression missing in return\\n\",\n-\t\t ret_tok->tp.tok.location.file,\n-\t\t ret_tok->tp.tok.location.line, ret_tok->tp.tok.charno); \n-        print_token (stderr, 0, ret_tok);\n+                ret_tok->tp.tok.location.file,\n+                ret_tok->tp.tok.location.line, ret_tok->tp.tok.charno);\n         errorcount++;\n       }\n     else\n@@ -687,7 +694,7 @@ NAME LEFT_PARENTHESIS expressions_with_commas RIGHT_PARENTHESIS {\n       abort ();\n     parms = tree_code_add_parameter (parms, var->tp.pro.code, exp->tp.pro.code);\n   }\n-  type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n+  type = tree_code_get_type (NUMERIC_TYPE (prod));\n   prod->tp.pro.code = tree_code_get_expression\n     (EXP_FUNCTION_INVOCATION, type, proto->tp.pro.code, parms, NULL);\n   $$ = prod;\n@@ -734,7 +741,7 @@ NAME {\n \n   prod = make_production (PROD_VARIABLE_REFERENCE_EXPRESSION, tok);\n   NUMERIC_TYPE (prod) = NUMERIC_TYPE (symbol_table_entry);\n-  type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n+  type = tree_code_get_type (NUMERIC_TYPE (prod));\n   if (!NUMERIC_TYPE (prod))\n     YYERROR;\n   OP1 (prod) = $1;\n@@ -832,7 +839,7 @@ reverse_prod_list (struct prod_token_parm_item *old_first)\n static void\n ensure_not_void (unsigned int type, struct prod_token_parm_item* name)\n {\n-  if (type == VOID)\n+  if (type == VOID_TYPE)\n     {\n       fprintf (stderr, \"%s:%i:%i: Type must not be void in this context\\n\",\n \t       name->tp.tok.location.file,\n@@ -877,15 +884,15 @@ check_type_match (int type_num, struct prod_token_parm_item *exp)\n         case UNSIGNED_CHAR:\n           return 1;\n           \n-        case VOID:\n+        case VOID_TYPE:\n           abort ();\n       \n         default: \n           abort ();\n         }\n       break;\n       \n-    case VOID:\n+    case VOID_TYPE:\n       abort ();\n       \n     default:\n@@ -903,7 +910,8 @@ make_integer_constant (struct prod_token_parm_item* value)\n   struct prod_token_parm_item *prod;\n   tok = value;\n   prod = make_production (PROD_INTEGER_CONSTANT, tok);\n-  if ((tok->tp.tok.chars[0] == (unsigned char)'-')|| (tok->tp.tok.chars[0] == (unsigned char)'+'))\n+  if ((tok->tp.tok.chars[0] == (unsigned char)'-')\n+      || (tok->tp.tok.chars[0] == (unsigned char)'+'))\n     NUMERIC_TYPE (prod) = SIGNED_INT;\n   else\n     NUMERIC_TYPE (prod) = UNSIGNED_INT;\n@@ -930,7 +938,7 @@ make_plus_expression (struct prod_token_parm_item* tok,\n   prod = make_production (PROD_PLUS_EXPRESSION, tok);\n \n   NUMERIC_TYPE (prod) = type_code;\n-  type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n+  type = tree_code_get_type (type_code);\n   if (!type)\n     abort ();\n   OP1 (prod) = op1;"}, {"sha": "4ce2c76a79da8f48c3b87f13685910c158500808", "filename": "gcc/treelang/tree1.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Ftree1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Ftree1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftree1.c?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -3,7 +3,8 @@\n     TREELANG Compiler almost main (tree1)\n     Called by GCC's toplev.c\n \n-    Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+    Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002, 2003, 2004\n+    Free Software Foundation, Inc.\n \n     This program is free software; you can redistribute it and/or modify it\n     under the terms of the GNU General Public License as published by the\n@@ -37,9 +38,11 @@\n #include \"tm.h\"\n #include \"flags.h\"\n #include \"toplev.h\"\n+#include \"version.h\"\n \n #include \"ggc.h\"\n #include \"tree.h\"\n+#include \"cgraph.h\"\n #include \"diagnostic.h\"\n \n #include \"treelang.h\"\n@@ -141,7 +144,7 @@ bool\n treelang_init (void)\n {\n   input_filename = main_input_filename;\n-  input_line = 0;\n+  input_line = 1;\n \n   /* Init decls etc.  */\n \n@@ -185,6 +188,8 @@ treelang_parse_file (int debug_flag ATTRIBUTE_UNUSED)\n {\n   treelang_debug ();\n   yyparse ();\n+  cgraph_finalize_compilation_unit ();\n+  cgraph_optimize ();\n }\n \n /* Allocate SIZE bytes and clear them.  Not to be used for strings"}, {"sha": "c0d85de1090ec71a2faba5ff0bee3aa62c1d28f2", "filename": "gcc/treelang/treelang.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Ftreelang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Ftreelang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreelang.h?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -2,7 +2,8 @@\n \n     TREELANG Compiler common definitions (treelang.h)\n \n-    Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+    Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002, 2003, 2004\n+    Free Software Foundation, Inc.\n \n     This program is free software; you can redistribute it and/or modify it\n     under the terms of the GNU General Public License as published by the\n@@ -48,7 +49,7 @@ extern FILE* yyin;\n struct token_part;\n struct production_part;\n struct prod_token_parm_item;\n-typedef struct GTY(()) prod_token_parm_item item;\n+typedef struct prod_token_parm_item item;\n \n /* A token from the input file.  */\n "}, {"sha": "9e5bca244e63c057d60e93d2216c9a5049a86792", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 184, "deletions": 276, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -1,13 +1,13 @@\n /*\n \n-    TREELANG Compiler back end interface (treetree.c)\n+    TREELANG Compiler interface to GCC's middle end (treetree.c)\n     Called by the parser.\n \n     If you want a working example of how to write a front end to GCC,\n     you are in the right place.\n \n     Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-    1999, 2000, 2001, 2002, 2003, Free Software Foundation, Inc.\n+    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n     This code is based on toy.c written by Richard Kenner.\n \n@@ -19,6 +19,8 @@\n \n     It was adapted to TREELANG by Tim Josling 2001.\n \n+    Updated to function-at-a-time by James A. Morrison, 2004.\n+\n     ---------------------------------------------------------------------------\n \n     This program is free software; you can redistribute it and/or modify it\n@@ -51,8 +53,8 @@\n   need for a *lot* of bother to ensure everything is in the mark trees\n   at all times.  */\n \n-  /* Note it is OK to use GCC extensions such as long long in a compiler front end.\n-     This is because the GCC front ends are built using GCC. */\n+/* Note, it is OK to use GCC extensions such as long long in a compiler front\n+   end.  This is because the GCC front ends are built using GCC.   */\n \n /* GCC headers.  */\n \n@@ -61,16 +63,21 @@\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-iterator.h\"\n+#include \"tree-gimple.h\"\n+#include \"function.h\"\n #include \"flags.h\"\n #include \"output.h\"\n-#include \"rtl.h\"\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"varray.h\"\n #include \"langhooks-def.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n \n+#include \"cgraph.h\"\n+\n #include \"treelang.h\"\n #include \"treetree.h\"\n #include \"opts.h\"\n@@ -130,17 +137,22 @@ static tree tree_lang_unsigned_type (tree type_node);\n static tree tree_lang_signed_type (tree type_node);\n static tree tree_lang_signed_or_unsigned_type (int unsignedp, tree type);\n \n-/* XXX these should be static */\n-void pushlevel (int ignore);\n-tree poplevel (int keep, int reverse, int functionbody);\n-int global_bindings_p (void);\n-void insert_block (tree block);\n-tree pushdecl (tree decl);\n-tree getdecls (void);\n-int kept_level_p (void);\n+/* Functions to keep track of the current scope.  */\n+static void pushlevel (int ignore);\n+static tree poplevel (int keep, int reverse, int functionbody);\n+static tree pushdecl (tree decl);\n+static tree* getstmtlist (void);\n+\n+/* Langhooks.  */\n+static tree builtin_function (const char *name, tree type, int function_code,\n+\t\t  enum built_in_class class, const char *library_name,\n+\t\t  tree attrs);\n+static tree getdecls (void);\n+static int global_bindings_p (void);\n+static void insert_block (tree);\n \n static void tree_push_type_decl (tree id, tree type_node);\n-static void tree_push_atomic_type_decl (tree id, tree type_node);\n+static void treelang_expand_function (tree fndecl);\n \n /* The front end language hooks (addresses of code for this front\n    end).  These are not really very language-dependent, i.e.\n@@ -163,6 +175,12 @@ static void tree_push_atomic_type_decl (tree id, tree type_node);\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE treelang_parse_file\n \n+#undef LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n+#define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION treelang_expand_function\n+\n+/* #undef LANG_HOOKS_TYPES_COMPATIBLE_P\n+#define LANG_HOOKS_TYPES_COMPATIBLE_P hook_bool_tree_tree_true\n+*/\n /* Hook routines and data unique to treelang.  */\n \n #undef LANG_HOOKS_INIT\n@@ -243,33 +261,54 @@ tree_code_get_type (int type_num)\n void\n tree_code_if_start (tree exp, location_t loc)\n {\n-  tree cond_exp;\n-  cond_exp = build (NE_EXPR,\n-                 TREE_TYPE (exp),\n-                 exp,\n-                 build1 (CONVERT_EXPR, TREE_TYPE (exp), integer_zero_node));\n-  emit_line_note (loc); /* Output the line number information.  */\n-  expand_start_cond (cond_exp, /* Exit-able if nonzero.  */ 0);\n+  tree cond_exp, cond;\n+  cond_exp = fold (build2 (NE_EXPR, boolean_type_node, exp,\n+                     fold (build1 (CONVERT_EXPR, TREE_TYPE (exp), integer_zero_node))));\n+  SET_EXPR_LOCATION (cond_exp, loc);\n+  cond = build3 (COND_EXPR, void_type_node, cond_exp, NULL_TREE,\n+                 NULL_TREE);\n+  SET_EXPR_LOCATION (cond, loc);\n+  append_to_statement_list_force (cond, getstmtlist ());\n+  pushlevel (0);\n }\n \n /* Output the code for the else of an if statement.  The else occurred\n    at line LINENO in file FILENAME.  */\n \n void\n-tree_code_if_else (location_t loc)\n+tree_code_if_else (location_t loc ATTRIBUTE_UNUSED)\n {\n-  emit_line_note (loc); /* Output the line number information.  */\n-  expand_start_else ();\n+  tree stmts = *getstmtlist ();\n+  tree block = poplevel (1, 0, 0);\n+  if (BLOCK_VARS (block))\n+    {\n+      tree bindexpr = build3 (BIND_EXPR, void_type_node, BLOCK_VARS (block),\n+                              stmts, block);\n+      stmts = alloc_stmt_list ();\n+      append_to_statement_list (bindexpr, &stmts);\n+    }\n+\n+  TREE_OPERAND (STATEMENT_LIST_TAIL (*getstmtlist ())->stmt, 1) = stmts;\n+  pushlevel (0);\n }\n \n-/* Output the code for the end_if an if statement.  The end_if (final brace) occurred\n-   at line LINENO in file FILENAME.  */\n+/* Output the code for the end_if an if statement.  The end_if (final brace)\n+   occurred at line LINENO in file FILENAME.  */\n \n void\n-tree_code_if_end (location_t loc)\n+tree_code_if_end (location_t loc ATTRIBUTE_UNUSED)\n {\n-  emit_line_note (loc); /* Output the line number information.  */\n-  expand_end_cond ();\n+  tree stmts = *getstmtlist ();\n+  tree block = poplevel (1, 0, 0);\n+  if (BLOCK_VARS (block))\n+    {\n+       tree bindexpr = build3 (BIND_EXPR, void_type_node, BLOCK_VARS (block),\n+                               stmts, block);\n+       stmts = alloc_stmt_list ();\n+       append_to_statement_list (bindexpr, &stmts);\n+    }\n+\n+  TREE_OPERAND (STATEMENT_LIST_TAIL (*getstmtlist ())->stmt, 2) = stmts;\n }\n \n /* Create a function.  The prototype name is NAME, storage class is\n@@ -297,7 +336,7 @@ tree_code_create_function_prototype (unsigned char* chars,\n     {\n       if (parm->category != parameter_category)\n         abort ();\n-      type_node = get_type_for_numeric_type (parm->type);\n+      type_node = tree_code_get_type (parm->type);\n       type_list = tree_cons (NULL_TREE, type_node, type_list);\n     }\n   /* Last parm if void indicates fixed length list (as opposed to\n@@ -306,20 +345,18 @@ tree_code_create_function_prototype (unsigned char* chars,\n   /* The back end needs them in reverse order.  */\n   type_list = nreverse (type_list);\n \n-  type_node = get_type_for_numeric_type (ret_type);\n+  type_node = tree_code_get_type (ret_type);\n   fn_type = build_function_type (type_node, type_list);\n \n   id = get_identifier ((const char*)chars);\n   fn_decl = build_decl (FUNCTION_DECL, id, fn_type);\n \n-  DECL_CONTEXT (fn_decl) = NULL_TREE; /* Nested functions not supported here.  */\n+  /* Nested functions not supported here.  */\n+  DECL_CONTEXT (fn_decl) = NULL_TREE;\n   DECL_SOURCE_LOCATION (fn_decl) = loc;\n \n   TREE_USED (fn_decl) = 1;\n \n-  /* Real name (optional).  */\n-  SET_DECL_ASSEMBLER_NAME (fn_decl, DECL_NAME (fn_decl));\n-\n   TREE_PUBLIC (fn_decl) = 0;\n   DECL_EXTERNAL (fn_decl) = 0;\n   TREE_STATIC (fn_decl) = 0;\n@@ -340,7 +377,6 @@ tree_code_create_function_prototype (unsigned char* chars,\n       DECL_EXTERNAL (fn_decl) = 1;\n       break;\n \n-\n     case AUTOMATIC_STORAGE:\n     default:\n       abort ();\n@@ -364,8 +400,6 @@ tree_code_create_function_initial (tree prev_saved,\n {\n   tree fn_decl;\n   tree param_decl;\n-  tree next_param;\n-  tree first_param;\n   tree parm_decl;\n   tree parm_list;\n   tree resultdecl;\n@@ -388,23 +422,22 @@ tree_code_create_function_initial (tree prev_saved,\n \n   DECL_SOURCE_LOCATION (fn_decl) = loc;\n \n-  /* Prepare creation of rtl for a new function.  */\n-\n-  resultdecl = DECL_RESULT (fn_decl) \n-    = build_decl (RESULT_DECL, NULL_TREE, TREE_TYPE (TREE_TYPE (fn_decl)));\n-  DECL_CONTEXT (DECL_RESULT (fn_decl)) = fn_decl;\n+  /* Create a DECL for the functions result.  */\n+  resultdecl =\n+    build_decl (RESULT_DECL, NULL_TREE, TREE_TYPE (TREE_TYPE (fn_decl)));\n+  DECL_CONTEXT (resultdecl) = fn_decl;\n+  DECL_ARTIFICIAL (resultdecl) = 1;\n+  DECL_IGNORED_P (resultdecl) = 1;\n   DECL_SOURCE_LOCATION (resultdecl) = loc;\n-\n-  /* Work out the size. ??? is this needed.  */\n-  layout_decl (DECL_RESULT (fn_decl), 0);\n+  DECL_RESULT (fn_decl) = resultdecl;\n \n   /* Make the argument variable decls.  */\n   parm_list = NULL_TREE;\n   for (parm = parms; parm; parm = parm->tp.par.next)\n     {\n       parm_decl = build_decl (PARM_DECL, get_identifier\n                               ((const char*) (parm->tp.par.variable_name)),\n-                              get_type_for_numeric_type (parm->type));\n+                              tree_code_get_type (parm->type));\n \n       /* Some languages have different nominal and real types.  */\n       DECL_ARG_TYPE (parm_decl) = TREE_TYPE (parm_decl);\n@@ -436,58 +469,15 @@ tree_code_create_function_initial (tree prev_saved,\n   if (this_parm)\n     abort (); /* Too many.  */\n \n-  /* Output the decl rtl (not the rtl for the function code).  ???.\n-     If the function is not defined in this file, when should you\n-     execute this?  */\n-  make_decl_rtl (fn_decl);\n-\n-  init_function_start (fn_decl);\n-\n-  /* Create rtl for startup code of function, such as saving registers.  */\n-\n-  expand_function_start (fn_decl, 0);\n-\n-  /* Function.c requires a push at the start of the function. that\n-     looks like a bug to me but let's make it happy.  */\n+  /* Create a new level at the start of the function.  */\n \n   pushlevel (0);\n \n-  /* Create rtl for the start of a new scope.  */\n-\n-  expand_start_bindings (2);\n-\n-  /* Put the parameters into the symbol table.  */\n-\n-  for (first_param = param_decl = nreverse (DECL_ARGUMENTS (fn_decl));\n-       param_decl;\n-       param_decl = next_param)\n-    {\n-      next_param = TREE_CHAIN (param_decl);\n-      TREE_CHAIN (param_decl) = NULL;\n-      /* layout_decl (param_decl, 0);  Already done in build_decl tej 13/4/2002.  */\n-      pushdecl (param_decl);\n-      if (DECL_CONTEXT (param_decl) != current_function_decl)\n-        abort ();\n-    }\n-\n-  /* Store back the PARM_DECL nodes.  They appear in the right order.  */\n-  DECL_ARGUMENTS (fn_decl) = getdecls ();\n-\n   /* Force it to be output, else may be solely inlined.  */\n   TREE_ADDRESSABLE (fn_decl) = 1;\n \n   /* Stop -O3 from deleting it.  */\n   TREE_USED (fn_decl) = 1;\n-\n-  /* Add a new level to the debugger symbol table.  */\n-\n-  pushlevel (0);\n-\n-  /* Create rtl for the start of a new scope.  */\n-\n-  expand_start_bindings (0);\n-\n-  emit_line_note (loc); /* Output the line number information.  */\n }\n \n /* Wrapup a function contained in file FILENAME, ending at line LINENO.  */\n@@ -496,42 +486,38 @@ tree_code_create_function_wrapup (location_t loc)\n {\n   tree block;\n   tree fn_decl;\n+  tree stmts = *getstmtlist ();\n \n   fn_decl = current_function_decl;\n \n-  emit_line_note (loc); /* Output the line number information.  */\n-\n-  /* Get completely built level from debugger symbol table.  */\n-\n-  block = poplevel (1, 0, 0);\n-\n-  /* Emit rtl for end of scope.  */\n-\n-  expand_end_bindings (block, 0, 1);\n-\n-  /* Emit rtl for end of function.  */\n-\n-  expand_function_end ();\n-\n   /* Pop the level.  */\n \n   block = poplevel (1, 0, 1);\n \n   /* And attach it to the function.  */\n \n-  DECL_INITIAL (fn_decl) = block;\n+  DECL_SAVED_TREE (fn_decl) = build3 (BIND_EXPR, void_type_node,\n+                                      BLOCK_VARS (block),\n+\t\t\t              stmts, block);\n \n-  /* Emit rtl for end of scope.  */\n+  allocate_struct_function (fn_decl);\n+  cfun->function_end_locus = loc;\n \n-  expand_end_bindings (block, 0, 1);\n \n-  /* Call optimization and convert optimized rtl to assembly code.  */\n+  /* Dump the original tree to a file.  */\n+  dump_function (TDI_original, fn_decl);\n \n-  rest_of_compilation (fn_decl);\n+  /* Convert current function to GIMPLE for the middle end.  */\n+  gimplify_function_tree (fn_decl);\n+  dump_function (TDI_generic, fn_decl);\n \n   /* We are not inside of any scope now.  */\n-\n   current_function_decl = NULL_TREE;\n+  cfun = NULL;\n+\n+  /* Pass the current function off to the middle end.  */\n+  (void)cgraph_node (fn_decl);\n+  cgraph_finalize_function (fn_decl, false);\n }\n \n /*\n@@ -556,7 +542,7 @@ tree_code_create_variable (unsigned int storage_class,\n   tree var_decl;\n \n   /* 1. Build the type.  */\n-  var_type = get_type_for_numeric_type (expression_type);\n+  var_type = tree_code_get_type (expression_type);\n \n   /* 2. Build the name.  */\n   if (chars[length] != 0)\n@@ -569,13 +555,10 @@ tree_code_create_variable (unsigned int storage_class,\n \n   /* 3a. Initialization.  */\n   if (init)\n-    DECL_INITIAL (var_decl) = build1 (CONVERT_EXPR, var_type, init);\n+    DECL_INITIAL (var_decl) = fold (build1 (CONVERT_EXPR, var_type, init));\n   else\n     DECL_INITIAL (var_decl) = NULL_TREE;\n \n-  /* 4. Compute size etc.  */\n-  layout_decl (var_decl, 0);\n-\n   if (TYPE_SIZE (var_type) == 0)\n     abort (); /* Did not calculate size.  */\n \n@@ -617,13 +600,8 @@ tree_code_create_variable (unsigned int storage_class,\n \n   if (TREE_STATIC (var_decl))\n     rest_of_decl_compilation (var_decl, 0, 0);\n-  else\n-    {\n-      expand_decl (var_decl);\n-      if (DECL_INITIAL (var_decl))\n-        expand_decl_init (var_decl);\n-    }\n \n+  TYPE_NAME (TREE_TYPE (var_decl)) = TYPE_NAME (var_type);\n   return pushdecl (copy_node (var_decl));\n \n }\n@@ -646,28 +624,33 @@ tree_code_generate_return (tree type, tree exp)\n         abort ();\n     }\n \n-  if (exp)\n+  if (exp && TREE_TYPE (TREE_TYPE (current_function_decl)) != void_type_node)\n     {\n-      setret = build (MODIFY_EXPR, type, DECL_RESULT (current_function_decl),\n-                     build1 (CONVERT_EXPR, type, exp));\n+      setret = fold (build2 (MODIFY_EXPR, type, \n+                             DECL_RESULT (current_function_decl),\n+                             fold (build1 (CONVERT_EXPR, type, exp))));\n       TREE_SIDE_EFFECTS (setret) = 1;\n       TREE_USED (setret) = 1;\n-      expand_expr_stmt (setret);\n+      setret = build1 (RETURN_EXPR, type, setret);\n     }\n-  expand_return (DECL_RESULT (current_function_decl));\n+   else\n+     setret = build1 (RETURN_EXPR, type, NULL_TREE);\n+\n+   append_to_statement_list_force (setret, getstmtlist ());\n }\n \n-/* Output the code for this expression statement CODE.  */\n \n+/* Output the code for this expression statement CODE.  */\n \n void\n tree_code_output_expression_statement (tree code, location_t loc)\n {\n   /* Output the line number information.  */\n-  emit_line_note (loc);\n+  SET_EXPR_LOCATION (code, loc);\n   TREE_USED (code) = 1;\n   TREE_SIDE_EFFECTS (code) = 1;\n-  expand_expr_stmt (code);\n+  /* put CODE into the code list.  */\n+  append_to_statement_list_force (code, getstmtlist ());\n }\n \n /* Return a tree for a constant integer value in the token TOK.  No\n@@ -716,9 +699,8 @@ tree_code_get_expression (unsigned int exp_type,\n       if (!op1 || !op2)\n         abort ();\n       operator = MODIFY_EXPR;\n-      ret1 = build (operator, type,\n-                 op1,\n-                 build1 (CONVERT_EXPR, type, op2));\n+      ret1 = fold (build2 (operator, void_type_node, op1,\n+                           fold (build1 (CONVERT_EXPR, TREE_TYPE (op1), op2))));\n \n       break;\n \n@@ -734,13 +716,13 @@ tree_code_get_expression (unsigned int exp_type,\n       operator = EQ_EXPR;\n       goto binary_expression;\n \n-      /* Expand a binary expression.  Ensure the operands are the right type.  */\n+    /* Expand a binary expression.  Ensure the operands are the right type.  */\n     binary_expression:\n       if (!op1 || !op2)\n         abort ();\n-      ret1  =  build (operator, type,\n-                   build1 (CONVERT_EXPR, type, op1),\n-                   build1 (CONVERT_EXPR, type, op2));\n+      ret1  =  fold (build2 (operator, type,\n+                       fold (build1 (CONVERT_EXPR, type, op1)),\n+                       fold (build1 (CONVERT_EXPR, type, op2))));\n       break;\n \n       /* Reference to a variable.  This is dead easy, just return the\n@@ -752,16 +734,18 @@ tree_code_get_expression (unsigned int exp_type,\n       if (type == TREE_TYPE (op1))\n         ret1 = op1;\n       else\n-        ret1 = build1 (CONVERT_EXPR, type, op1);\n+        ret1 = fold (build1 (CONVERT_EXPR, type, op1));\n       break;\n \n     case EXP_FUNCTION_INVOCATION:\n       if (!op1 || !op2)\n         abort ();\n+\n       {\n         tree fun_ptr;\n-        fun_ptr = build1 (ADDR_EXPR, build_pointer_type (type), op1);\n-        ret1 = build (CALL_EXPR, type, fun_ptr, nreverse (op2));\n+        fun_ptr = fold (build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (op1)),\n+                                op1));\n+        ret1 = build3 (CALL_EXPR, type, fun_ptr, nreverse (op2), NULL_TREE);\n       }\n       break;\n \n@@ -788,83 +772,13 @@ tree_code_add_parameter (tree list, tree proto_exp, tree exp)\n {\n   tree new_exp;\n   new_exp = tree_cons (NULL_TREE,\n-                    build1 (CONVERT_EXPR, TREE_TYPE (proto_exp), exp),\n-                    NULL_TREE);\n+                       fold (build1 (CONVERT_EXPR, TREE_TYPE (proto_exp), exp)),\n+                       NULL_TREE);\n   if (!list)\n     return new_exp;\n   return chainon (new_exp, list);\n }\n \n-/* Get the tree type for this type whose number is NUMERIC_TYPE.  */\n-\n-tree\n-get_type_for_numeric_type (unsigned int numeric_type)\n-{\n-\n-  int size1;\n-  int sign1;\n-  switch (numeric_type)\n-    {\n-    case VOID_TYPE:\n-      return void_type_node;\n-\n-    case SIGNED_INT:\n-      size1 = tree_code_int_size;\n-      sign1 = 1;\n-      break;\n-\n-    case UNSIGNED_INT:\n-      size1 = tree_code_int_size;\n-      sign1 = 0;\n-      break;\n-\n-    case SIGNED_CHAR:\n-      size1 = tree_code_char_size;\n-      sign1 = 1;\n-      break;\n-\n-    case UNSIGNED_CHAR:\n-      size1 = tree_code_char_size;\n-      sign1 = 0;\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  return tree_code_get_numeric_type (size1, sign1);\n-\n-}\n-\n-/* Return tree representing a numeric type of size SIZE1 bits and\n-   signed if SIGN1 !=  0.  */\n-tree\n-tree_code_get_numeric_type (unsigned int size1, unsigned int sign1)\n-{\n-  tree ret1;\n-  if (!size1)\n-    abort ();\n-  if (size1 == tree_code_int_size)\n-    {\n-      if (sign1)\n-        ret1 = integer_type_node;\n-      else\n-        ret1 = unsigned_type_node;\n-    }\n-  else\n-    if (size1 == tree_code_char_size)\n-      {\n-        if (sign1)\n-          ret1 = signed_char_type_node;\n-        else\n-          ret1 = unsigned_char_type_node;\n-      }\n-    else\n-      abort ();\n-\n-  return ret1;\n-}\n-\n /* Get a stringpool entry for a string S of length L.  This is needed\n    because the GTY routines don't mark strings, forcing you to put\n    them into stringpool, which is never freed.  */\n@@ -1056,6 +970,8 @@ struct binding_level\n   /* For each level (except the global one), a chain of BLOCK nodes for all\n      the levels that were entered and exited one level down from this one.  */\n   tree blocks;\n+\n+  tree stmts;\n   /* The binding level containing this one (the enclosing binding level). */\n   struct binding_level *level_chain;\n };\n@@ -1068,37 +984,38 @@ static struct binding_level *current_binding_level = NULL;\n static struct binding_level *global_binding_level;\n \n /* Binding level structures are initialized by copying this one.  */\n-static struct binding_level clear_binding_level = {NULL, NULL, NULL };\n+static struct binding_level clear_binding_level = {NULL, NULL, NULL, NULL };\n \f\n /* Return non-zero if we are currently in the global binding level.  */\n \n-int\n+static int\n global_bindings_p (void)\n {\n   return current_binding_level == global_binding_level ? -1 : 0;\n }\n \n+\n /* Return the list of declarations in the current level. Note that this list\n    is in reverse order (it has to be so for back-end compatibility).  */\n \n-tree\n+static tree\n getdecls (void)\n {\n   return current_binding_level->names;\n }\n \n-/* Nonzero if the current level needs to have a BLOCK made.  */\n+/* Return a STATMENT_LIST for the current block.  */\n \n-int\n-kept_level_p (void)\n+static tree*\n+getstmtlist (void)\n {\n-  return (current_binding_level->names != 0);\n+  return &current_binding_level->stmts;\n }\n \n /* Enter a new binding level. The input parameter is ignored, but has to be\n    specified for back-end compatibility.  */\n \n-void\n+static void\n pushlevel (int ignore ATTRIBUTE_UNUSED)\n {\n   struct binding_level *newlevel = xmalloc (sizeof (struct binding_level));\n@@ -1109,6 +1026,7 @@ pushlevel (int ignore ATTRIBUTE_UNUSED)\n      active.  */\n   newlevel->level_chain = current_binding_level;\n   current_binding_level = newlevel;\n+  current_binding_level->stmts = alloc_stmt_list ();\n }\n \n /* Exit a binding level.\n@@ -1126,7 +1044,7 @@ pushlevel (int ignore ATTRIBUTE_UNUSED)\n    If REVERSE is nonzero, reverse the order of decls before putting\n    them into the BLOCK.  */\n \n-tree\n+static tree\n poplevel (int keep, int reverse, int functionbody)\n {\n   /* Points to a BLOCK tree node. This is the BLOCK node construted for the\n@@ -1166,21 +1084,15 @@ poplevel (int keep, int reverse, int functionbody)\n \t{\n \t  if (TREE_USED (subblock_node))\n \t    TREE_USED (DECL_NAME (subblock_node)) = 1;\n-\t  if (TREE_ADDRESSABLE (subblock_node))\n-\t    TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (subblock_node)) = 1;\n \t}\n \n   /* Pop the current level.  */\n   current_binding_level = current_binding_level->level_chain;\n \n   if (functionbody)\n     {\n-      /* This is the top level block of a function. The ..._DECL chain stored\n-\t in BLOCK_VARS are the function's parameters (PARM_DECL nodes). Don't\n-\t leave them in the BLOCK because they are found in the FUNCTION_DECL\n-\t instead.  */\n+      /* This is the top level block of a function.  */\n       DECL_INITIAL (current_function_decl) = block_node;\n-      BLOCK_VARS (block_node) = 0;\n     }\n   else if (block_node)\n     {\n@@ -1205,14 +1117,15 @@ poplevel (int keep, int reverse, int functionbody)\n    current binding level.  This is used when a BIND_EXPR is expanded,\n    to handle the BLOCK node inside the BIND_EXPR.  */\n \n-void\n+static void\n insert_block (tree block)\n {\n   TREE_USED (block) = 1;\n   current_binding_level->blocks\n     = chainon (current_binding_level->blocks, block);\n }\n \n+\n /* Records a ..._DECL node DECL as belonging to the current lexical scope.\n    Returns the ..._DECL node. */\n \n@@ -1247,22 +1160,10 @@ static void\n tree_push_type_decl(tree id, tree type_node)\n {\n   tree decl = build_decl (TYPE_DECL, id, type_node);\n-  TYPE_NAME (type_node) = decl;\n-  TYPE_STUB_DECL (type_node) = decl;\n+  TYPE_NAME (type_node) = id;\n   pushdecl (decl);\n }\n \n-/* push_atomic_type_decl() ensures that the type's type is itself. \n-   Needed for DBX.  Must only be used for atomic types,\n-   not for e.g. pointer or array types.  */\n-\n-static void\n-tree_push_atomic_type_decl(tree id, tree type_node)\n-{\n-  TREE_TYPE (type_node) = type_node;\n-  tree_push_type_decl (id, type_node);\n-}\n-\n #define NULL_BINDING_LEVEL (struct binding_level *) NULL                        \n \n /* Create the predefined scalar types of C,\n@@ -1282,53 +1183,52 @@ treelang_init_decl_processing (void)\n \n   /* set standard type names */\n \n-  /* Define `int' and `char' first so that dbx will output them first.  */\n+  /* Define `int' and `char' last so that they are not overwritten.  */\n+  tree_push_type_decl (NULL_TREE, intQI_type_node);\n+  tree_push_type_decl (NULL_TREE, intHI_type_node);\n+  tree_push_type_decl (NULL_TREE, intSI_type_node);\n+  tree_push_type_decl (NULL_TREE, intDI_type_node);\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  tree_push_type_decl (NULL_TREE, intTI_type_node);\n+#endif\n+  tree_push_type_decl (NULL_TREE, unsigned_intQI_type_node);\n+  tree_push_type_decl (NULL_TREE, unsigned_intHI_type_node);\n+  tree_push_type_decl (NULL_TREE, unsigned_intSI_type_node);\n+  tree_push_type_decl (NULL_TREE, unsigned_intDI_type_node);\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  tree_push_type_decl (NULL_TREE, unsigned_intTI_type_node);\n+#endif\n \n-  tree_push_atomic_type_decl (get_identifier (\"int\"), integer_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"char\"), char_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"long int\"),\n+  tree_push_type_decl (get_identifier (\"int\"), integer_type_node);\n+  tree_push_type_decl (get_identifier (\"char\"), char_type_node);\n+  tree_push_type_decl (get_identifier (\"long int\"),\n \t\t\t      long_integer_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"unsigned int\"),\n+  tree_push_type_decl (get_identifier (\"unsigned int\"),\n \t\t\t      unsigned_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"long unsigned int\"),\n+  tree_push_type_decl (get_identifier (\"long unsigned int\"),\n \t\t\t      long_unsigned_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"long long int\"),\n+  tree_push_type_decl (get_identifier (\"long long int\"),\n \t\t\t      long_long_integer_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"long long unsigned int\"),\n+  tree_push_type_decl (get_identifier (\"long long unsigned int\"),\n \t\t\t      long_long_unsigned_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"short int\"),\n+  tree_push_type_decl (get_identifier (\"short int\"),\n \t\t\t      short_integer_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"short unsigned int\"),\n+  tree_push_type_decl (get_identifier (\"short unsigned int\"),\n \t\t\t      short_unsigned_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"signed char\"),\n+  tree_push_type_decl (get_identifier (\"signed char\"),\n \t\t\t      signed_char_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"unsigned char\"),\n+  tree_push_type_decl (get_identifier (\"unsigned char\"),\n \t\t\t      unsigned_char_type_node);\n-  tree_push_atomic_type_decl (NULL_TREE, intQI_type_node);\n-  tree_push_atomic_type_decl (NULL_TREE, intHI_type_node);\n-  tree_push_atomic_type_decl (NULL_TREE, intSI_type_node);\n-  tree_push_atomic_type_decl (NULL_TREE, intDI_type_node);\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  tree_push_atomic_type_decl (NULL_TREE, intTI_type_node);\n-#endif\n-  tree_push_atomic_type_decl (NULL_TREE, unsigned_intQI_type_node);\n-  tree_push_atomic_type_decl (NULL_TREE, unsigned_intHI_type_node);\n-  tree_push_atomic_type_decl (NULL_TREE, unsigned_intSI_type_node);\n-  tree_push_atomic_type_decl (NULL_TREE, unsigned_intDI_type_node);\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  tree_push_atomic_type_decl (NULL_TREE, unsigned_intTI_type_node);\n-#endif\n-  \n   size_type_node = make_unsigned_type (POINTER_SIZE);\n-  tree_push_atomic_type_decl (get_identifier (\"size_t\"), size_type_node);\n+  tree_push_type_decl (get_identifier (\"size_t\"), size_type_node);\n   set_sizetype (size_type_node);\n \n   build_common_tree_nodes_2 (/* short_double= */ 0);\n \n-  tree_push_atomic_type_decl (get_identifier (\"float\"), float_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"double\"), double_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"long double\"), long_double_type_node);\n-  tree_push_atomic_type_decl (get_identifier (\"void\"), void_type_node);\n+  tree_push_type_decl (get_identifier (\"float\"), float_type_node);\n+  tree_push_type_decl (get_identifier (\"double\"), double_type_node);\n+  tree_push_type_decl (get_identifier (\"long double\"), long_double_type_node);\n+  tree_push_type_decl (get_identifier (\"void\"), void_type_node);\n \n   /* Add any target-specific builtin functions.  */\n   (*targetm.init_builtins) ();\n@@ -1348,7 +1248,7 @@ treelang_init_decl_processing (void)\n    copied from gcc/c-decl.c\n */\n \n-tree\n+static tree\n builtin_function (const char *name, tree type, int function_code,\n \t\t  enum built_in_class class, const char *library_name,\n \t\t  tree attrs)\n@@ -1358,7 +1258,6 @@ builtin_function (const char *name, tree type, int function_code,\n   TREE_PUBLIC (decl) = 1;\n   if (library_name)\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n-  make_decl_rtl (decl);\n   pushdecl (decl);\n   DECL_BUILT_IN_CLASS (decl) = class;\n   DECL_FUNCTION_CODE (decl) = function_code;\n@@ -1372,5 +1271,14 @@ builtin_function (const char *name, tree type, int function_code,\n   return decl;\n }\n \n+/* Treelang expand function langhook.  */\n+\n+static void\n+treelang_expand_function (tree fndecl)\n+{\n+  /* We have nothing special to do while expanding functions for treelang.  */\n+  tree_rest_of_compilation (fndecl, 0);\n+}\n+\n #include \"debug.h\" /* for debug_hooks, needed by gt-treelang-treetree.h */\n #include \"gt-treelang-treetree.h\""}, {"sha": "ac75d8c87d71800b91f44d37c9445aeeb442c003", "filename": "gcc/treelang/treetree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Ftreetree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/352a77c8dc72715bbe230e04cd72583d5a900291/gcc%2Ftreelang%2Ftreetree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.h?ref=352a77c8dc72715bbe230e04cd72583d5a900291", "patch": "@@ -3,7 +3,8 @@\n     TREELANG Compiler definitions for interfacing to treetree.c\n     (compiler back end interface).\n \n-    Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+    Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002, 2003, 2004\n+    Free Software Foundation, Inc.\n \n     This program is free software; you can redistribute it and/or modify it\n     under the terms of the GNU General Public License as published by the\n@@ -55,7 +56,6 @@ tree tree_code_create_variable (unsigned int storage_class,\n \t\t\t\tlocation_t loc);\n void tree_code_output_expression_statement (tree code,\n \t\t\t\t\t    location_t loc);\n-tree get_type_for_numeric_type (unsigned int numeric_type);\n void tree_code_if_start (tree exp, location_t loc);\n void tree_code_if_else (location_t loc);\n void tree_code_if_end (location_t loc);"}]}