{"sha": "1e3e6c700f04fe6992b9077541e434172c1cbdae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUzZTZjNzAwZjA0ZmU2OTkyYjkwNzc1NDFlNDM0MTcyYzFjYmRhZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-17T16:13:02Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-17T22:38:49Z"}, "message": "libstdc++: Revert changes for SYS_clock_gettime64 [PR 93421]\n\nAs discussed in the PR, it's incredibly unlikely that a system that\nneeds to use the SYS_clock_gettime syscall (e.g. glibc 2.16 or older) is\ngoing to define the SYS_clock_gettime64 macro. Ancient systems that need\nto use the syscall aren't going to have time64 support.\n\nThis reverts the recent changes to try and make clock_gettime syscalls\nbe compatible with systems that have been updated for time64 (those\nchanges were wrong anyway as they misspelled the SYS_clock_gettime64\nmacro). The changes for futex syscalls are retained, because we still\nuse them on modern systems that might be using time64.\n\nTo ensure that the clock_gettime syscalls are safe, configure will fail\nif SYS_clock_gettime is needed, and SYS_clock_gettime64 is also defined\n(but to a distinct value from SYS_clock_gettime), and the tv_sec member\nof timespec is larger than long. This means we will be unable to build\non a hypothetical system where we need the time32 version of\nSYS_clock_gettime but where userspace is using a time64 struct timespec.\nIn the unlikely event that this failure is triggered on any real\nsystems, we can fix it later. But we probably won't need to.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/93421\n\t* acinclude.m4 (GLIBCXX_ENABLE_LIBSTDCXX_TIME): Fail if struct\n\ttimespec isn't compatible with SYS_clock_gettime.\n\t* configure: Regenerate.\n\t* src/c++11/chrono.cc: Revert changes for time64 compatibility.\n\tAdd static_assert instead.\n\t* src/c++11/futex.cc (_M_futex_wait_until_steady): Assume\n\tSYS_clock_gettime can use struct timespec.", "tree": {"sha": "f5fe26e1f78055d0ccd01c0e2987d270099ffc3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5fe26e1f78055d0ccd01c0e2987d270099ffc3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e3e6c700f04fe6992b9077541e434172c1cbdae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3e6c700f04fe6992b9077541e434172c1cbdae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e3e6c700f04fe6992b9077541e434172c1cbdae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3e6c700f04fe6992b9077541e434172c1cbdae/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61ef34c503443dadc0744c5150256b90d138db0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ef34c503443dadc0744c5150256b90d138db0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ef34c503443dadc0744c5150256b90d138db0a"}], "stats": {"total": 98, "additions": 70, "deletions": 28}, "files": [{"sha": "486347b34d9469b4fb085e0a74e66e1d34ed1713", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3e6c700f04fe6992b9077541e434172c1cbdae/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3e6c700f04fe6992b9077541e434172c1cbdae/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=1e3e6c700f04fe6992b9077541e434172c1cbdae", "patch": "@@ -1561,13 +1561,34 @@ AC_DEFUN([GLIBCXX_ENABLE_LIBSTDCXX_TIME], [\n \t   #endif\n \t   syscall(SYS_clock_gettime, CLOCK_MONOTONIC, &tp);\n \t   syscall(SYS_clock_gettime, CLOCK_REALTIME, &tp);\n-\t  ], [ac_has_clock_monotonic_syscall=yes], [ac_has_clock_monotonic_syscall=no])\n-\tAC_MSG_RESULT($ac_has_clock_monotonic_syscall)\n-\tif test x\"$ac_has_clock_monotonic_syscall\" = x\"yes\"; then\n+\t  ], [ac_has_clock_gettime_syscall=yes], [ac_has_clock_gettime_syscall=no])\n+\tAC_MSG_RESULT($ac_has_clock_gettime_syscall)\n+\tif test x\"$ac_has_clock_gettime_syscall\" = x\"yes\"; then\n \t  AC_DEFINE(_GLIBCXX_USE_CLOCK_GETTIME_SYSCALL, 1,\n-\t  [ Defined if clock_gettime syscall has monotonic and realtime clock support. ])\n+\t  [Defined if clock_gettime syscall has monotonic and realtime clock support. ])\n \t  ac_has_clock_monotonic=yes\n \t  ac_has_clock_realtime=yes\n+\t  AC_MSG_CHECKING([for struct timespec that matches syscall])\n+\t  AC_TRY_COMPILE(\n+\t    [#include <time.h>\n+\t     #include <sys/syscall.h>\n+\t    ],\n+\t    [#ifdef SYS_clock_gettime64\n+\t     #if SYS_clock_gettime64 != SYS_clock_gettime\n+\t     // We need to use SYS_clock_gettime and libc appears to\n+\t     // also know about the SYS_clock_gettime64 syscall.\n+\t     // Check that userspace doesn't use time64 version of timespec.\n+\t     static_assert(sizeof(timespec::tv_sec) == sizeof(long),\n+\t       \"struct timespec must be compatible with SYS_clock_gettime\");\n+\t     #endif\n+\t     #endif\n+\t    ],\n+\t    [ac_timespec_matches_syscall=yes],\n+\t    [ac_timespec_matches_syscall=no])\n+\t  AC_MSG_RESULT($ac_timespec_matches_syscall)\n+\t  if test x\"$ac_timespec_matches_syscall\" = no; then\n+\t    AC_MSG_ERROR([struct timespec is not compatible with SYS_clock_gettime, please report a bug to http://gcc.gnu.org/bugzilla])\n+\t  fi\n \tfi;;\n     esac\n   fi"}, {"sha": "d9ed414cc773bcc5fe3806f545c489948ae0e3a8", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3e6c700f04fe6992b9077541e434172c1cbdae/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3e6c700f04fe6992b9077541e434172c1cbdae/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=1e3e6c700f04fe6992b9077541e434172c1cbdae", "patch": "@@ -21661,19 +21661,54 @@ main ()\n }\n _ACEOF\n if ac_fn_cxx_try_compile \"$LINENO\"; then :\n-  ac_has_clock_monotonic_syscall=yes\n+  ac_has_clock_gettime_syscall=yes\n else\n-  ac_has_clock_monotonic_syscall=no\n+  ac_has_clock_gettime_syscall=no\n fi\n rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-\t{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_has_clock_monotonic_syscall\" >&5\n-$as_echo \"$ac_has_clock_monotonic_syscall\" >&6; }\n-\tif test x\"$ac_has_clock_monotonic_syscall\" = x\"yes\"; then\n+\t{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_has_clock_gettime_syscall\" >&5\n+$as_echo \"$ac_has_clock_gettime_syscall\" >&6; }\n+\tif test x\"$ac_has_clock_gettime_syscall\" = x\"yes\"; then\n \n $as_echo \"#define _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL 1\" >>confdefs.h\n \n \t  ac_has_clock_monotonic=yes\n \t  ac_has_clock_realtime=yes\n+\t  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for struct timespec that matches syscall\" >&5\n+$as_echo_n \"checking for struct timespec that matches syscall... \" >&6; }\n+\t  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <time.h>\n+\t     #include <sys/syscall.h>\n+\n+int\n+main ()\n+{\n+#ifdef SYS_clock_gettime64\n+\t     #if SYS_clock_gettime64 != SYS_clock_gettime\n+\t     // We need to use SYS_clock_gettime and libc appears to\n+\t     // also know about the SYS_clock_gettime64 syscall.\n+\t     // Check that userspace doesn't use time64 version of timespec.\n+\t     static_assert(sizeof(timespec::tv_sec) == sizeof(long),\n+\t       \"struct timespec must be compatible with SYS_clock_gettime\");\n+\t     #endif\n+\t     #endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  ac_timespec_matches_syscall=yes\n+else\n+  ac_timespec_matches_syscall=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+\t  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_timespec_matches_syscall\" >&5\n+$as_echo \"$ac_timespec_matches_syscall\" >&6; }\n+\t  if test x\"$ac_timespec_matches_syscall\" = no; then\n+\t    as_fn_error $? \"struct timespec is not compatible with SYS_clock_gettime, please report a bug to http://gcc.gnu.org/bugzilla\" \"$LINENO\" 5\n+\t  fi\n \tfi;;\n     esac\n   fi"}, {"sha": "723f3002d11a138d14df42b3d43e9007ece7f1fd", "filename": "libstdc++-v3/src/c++11/chrono.cc", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3e6c700f04fe6992b9077541e434172c1cbdae/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fchrono.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3e6c700f04fe6992b9077541e434172c1cbdae/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fchrono.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fchrono.cc?ref=1e3e6c700f04fe6992b9077541e434172c1cbdae", "patch": "@@ -35,17 +35,6 @@\n #ifdef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n #include <unistd.h>\n #include <sys/syscall.h>\n-\n-# if defined(SYS_clock_gettime_time64) \\\n-  && SYS_clock_gettime_time64 != SYS_clock_gettime\n-  // Userspace knows about the new time64 syscalls, so it's possible that\n-  // userspace has also updated timespec to use a 64-bit tv_sec.\n-  // The SYS_clock_gettime syscall still uses the old definition\n-  // of timespec where tv_sec is 32 bits, so define a type that matches that.\n-  struct syscall_timespec { long tv_sec; long tv_nsec; };\n-# else\n-  using syscall_timespec = ::timespec;\n-# endif\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -63,12 +52,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     system_clock::now() noexcept\n     {\n #ifdef _GLIBCXX_USE_CLOCK_REALTIME\n+      timespec tp;\n       // -EINVAL, -EFAULT\n #ifdef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n-      syscall_timespec tp;\n       syscall(SYS_clock_gettime, CLOCK_REALTIME, &tp);\n #else\n-      timespec tp;\n       clock_gettime(CLOCK_REALTIME, &tp);\n #endif\n       return time_point(duration(chrono::seconds(tp.tv_sec)\n@@ -92,12 +80,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     steady_clock::now() noexcept\n     {\n #ifdef _GLIBCXX_USE_CLOCK_MONOTONIC\n+      timespec tp;\n       // -EINVAL, -EFAULT\n #ifdef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n-      syscall_timespec tp;\n       syscall(SYS_clock_gettime, CLOCK_MONOTONIC, &tp);\n #else\n-      timespec tp;\n       clock_gettime(CLOCK_MONOTONIC, &tp);\n #endif\n       return time_point(duration(chrono::seconds(tp.tv_sec)"}, {"sha": "33e2097e19cfa38863e773f08eb1e8c2904faf17", "filename": "libstdc++-v3/src/c++11/futex.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3e6c700f04fe6992b9077541e434172c1cbdae/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3e6c700f04fe6992b9077541e434172c1cbdae/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc?ref=1e3e6c700f04fe6992b9077541e434172c1cbdae", "patch": "@@ -61,8 +61,8 @@ namespace\n #if defined(SYS_futex_time64) && SYS_futex_time64 != SYS_futex\n   // Userspace knows about the new time64 syscalls, so it's possible that\n   // userspace has also updated timespec to use a 64-bit tv_sec.\n-  // The SYS_futex and SYS_clock_gettime syscalls still use the old definition\n-  // of timespec where tv_sec is 32 bits, so define a type that matches that.\n+  // The SYS_futex syscall still uses the old definition of timespec\n+  // where tv_sec is 32 bits, so define a type that matches that.\n   struct syscall_timespec { long tv_sec; long tv_nsec; };\n #else\n   using syscall_timespec = ::timespec;\n@@ -234,11 +234,10 @@ namespace\n \n \t// We only get to here if futex_clock_monotonic_unavailable was\n \t// true or has just been set to true.\n+\tstruct timespec ts;\n #ifdef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n-\tsyscall_timespec ts;\n \tsyscall(SYS_clock_gettime, CLOCK_MONOTONIC, &ts);\n #else\n-\tstruct timespec ts;\n \tclock_gettime(CLOCK_MONOTONIC, &ts);\n #endif\n "}]}