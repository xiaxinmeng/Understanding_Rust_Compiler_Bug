{"sha": "ddd69607433a8cd05cf50c524746bea197205b6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRkNjk2MDc0MzNhOGNkMDVjZjUwYzUyNDc0NmJlYTE5NzIwNWI2ZA==", "commit": {"author": {"name": "Loren J. Rittle", "email": "ljrittle@acm.org", "date": "2002-01-24T07:35:11Z"}, "committer": {"name": "Loren J. Rittle", "email": "ljrittle@gcc.gnu.org", "date": "2002-01-24T07:35:11Z"}, "message": "pthread1.cc: New test.\n\n\t* testsuite/thread/pthread1.cc: New test.\n\t* testsuite/thread/pthread2.cc: New test adapted from libstdc++/5347.\n\t* testsuite/thread/pthread3.cc: Likewise.\n\t* testsuite/thread/pthread4.cc: New test adapted from\n\thttp://gcc.gnu.org/ml/gcc-bugs/2002-01/msg00679.html\n\t* testsuite/thread/pthread5.cc: New test adapted from libstdc++/5464.\n\t* testsuite/thread/pthread6.cc: New test adapted from libstdc++/5444.\n\nFrom-SVN: r49173", "tree": {"sha": "39d12dfc931d30e8177044ca0cefa54cc5b6b7b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39d12dfc931d30e8177044ca0cefa54cc5b6b7b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddd69607433a8cd05cf50c524746bea197205b6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddd69607433a8cd05cf50c524746bea197205b6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddd69607433a8cd05cf50c524746bea197205b6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddd69607433a8cd05cf50c524746bea197205b6d/comments", "author": null, "committer": null, "parents": [{"sha": "619e2b8493d26a33ff458b307bdcd1b08e1c63c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/619e2b8493d26a33ff458b307bdcd1b08e1c63c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/619e2b8493d26a33ff458b307bdcd1b08e1c63c5"}], "stats": {"total": 598, "additions": 598, "deletions": 0}, "files": [{"sha": "b13f96516974ead256a7a4b34dfe6f953bef890f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ddd69607433a8cd05cf50c524746bea197205b6d", "patch": "@@ -1,3 +1,13 @@\n+2002-01-23  Loren Rittle <ljrittle@acm.org>\n+\n+\t* testsuite/thread/pthread1.cc: New test.\n+\t* testsuite/thread/pthread2.cc: New test adapted from libstdc++/5347.\n+\t* testsuite/thread/pthread3.cc: Likewise.\n+\t* testsuite/thread/pthread4.cc: New test adapted from\n+\thttp://gcc.gnu.org/ml/gcc-bugs/2002-01/msg00679.html\n+\t* testsuite/thread/pthread5.cc: New test adapted from libstdc++/5464.\n+\t* testsuite/thread/pthread6.cc: New test adapted from libstdc++/5444.\n+\n 2002-01-23  Richard Henderson  <rth@redhat.com>\n \n \tPR libstdc++/5198"}, {"sha": "f51881a903652fb6ad58cca22442324954897f54", "filename": "libstdc++-v3/testsuite/thread/pthread1.cc", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread1.cc?ref=ddd69607433a8cd05cf50c524746bea197205b6d", "patch": "@@ -0,0 +1,143 @@\n+// 2002-01-23  Loren J. Rittle <rittle@labs.mot.com> <ljrittle@acm.org>\n+//\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// { dg-do run { target *-*-freebsd* *-*-linux* *-*-solaris* } }\n+// { dg-options \"-pthread\" { target *-*-freebsd* *-*-linux* } }\n+// { dg-options \"-pthreads\" { target *-*-solaris* } }\n+\n+// This multi-threading C++/STL/POSIX code adheres to rules outlined here:\n+// http://www.sgi.com/tech/stl/thread_safety.html\n+//\n+// It is believed to exercise the allocation code in a manner that\n+// should reveal memory leaks (and, under rare cases, race conditions,\n+// if the STL threading support is fubar'd).\n+\n+#include <list>\n+\n+// Do not include <pthread.h> explicitly; if threads are properly\n+// configured for the port, then it is picked up free from STL headers.\n+\n+#if __GTHREADS\n+using namespace std;\n+\n+const int thread_cycles = 10;\n+const int thread_pairs = 10;\n+const unsigned max_size = 100;\n+const int iters = 10000;\n+\n+class task_queue\n+{\n+public:\n+  task_queue ()\n+  {\n+    pthread_mutex_init (&fooLock, NULL);\n+    pthread_cond_init (&fooCond, NULL);\n+  }\n+  ~task_queue ()\n+  {\n+    pthread_mutex_destroy (&fooLock);\n+    pthread_cond_destroy (&fooCond);\n+  }\n+  list<int> foo;\n+  pthread_mutex_t fooLock;\n+  // This code uses a special case that allows us to use just one\n+  // condition variable - in general, don't use this idiom unless you\n+  // know what you are doing. ;-)\n+  pthread_cond_t fooCond;\n+};\n+\n+void*\n+produce (void* t)\n+{\n+  task_queue& tq = *(static_cast<task_queue*> (t));\n+  int num = 0;\n+  while (num < iters)\n+    {\n+      pthread_mutex_lock (&tq.fooLock);\n+      while (tq.foo.size () >= max_size)\n+\tpthread_cond_wait (&tq.fooCond, &tq.fooLock);\n+      tq.foo.push_back (num++);\n+      pthread_cond_signal (&tq.fooCond);\n+      pthread_mutex_unlock (&tq.fooLock);\n+    }\n+  return 0;\n+}\n+\n+void*\n+consume (void* t)\n+{\n+  task_queue& tq = *(static_cast<task_queue*> (t));\n+  int num = 0;\n+  while (num < iters)\n+    {\n+      pthread_mutex_lock (&tq.fooLock);\n+      while (tq.foo.size () == 0)\n+\tpthread_cond_wait (&tq.fooCond, &tq.fooLock);\n+      if (tq.foo.front () != num++)\n+\tabort ();\n+      tq.foo.pop_front ();\n+      pthread_cond_signal (&tq.fooCond);\n+      pthread_mutex_unlock (&tq.fooLock);\n+    }\n+  return 0;\n+}\n+\n+int\n+main (int argc, char** argv)\n+{\n+  pthread_t prod[thread_pairs];\n+  pthread_t cons[thread_pairs];\n+\n+  task_queue* tq[thread_pairs];\n+\n+#if defined(__sun) && defined(__svr4__)\n+  pthread_setconcurrency (thread_pairs * 2);\n+#endif\n+\n+  for (int j = 0; j < thread_cycles; j++)\n+    {\n+      for (int i = 0; i < thread_pairs; i++)\n+\t{\n+\t  tq[i] = new task_queue;\n+\t  pthread_create (&prod[i], NULL, produce, static_cast<void*> (tq[i]));\n+\t  pthread_create (&cons[i], NULL, consume, static_cast<void*> (tq[i]));\n+\t}\n+\n+      for (int i = 0; i < thread_pairs; i++)\n+\t{\n+\t  pthread_join (prod[i], NULL);\n+\t  pthread_join (cons[i], NULL);\n+#if defined(__FreeBSD__)\n+\t  // These lines are not required by POSIX since a successful\n+\t  // join is suppose to detach as well...\n+\t  pthread_detach (prod[i]);\n+\t  pthread_detach (cons[i]);\n+\t  // ...but they are according to the FreeBSD 4.X code base\n+\t  // or else you get a memory leak.\n+#endif\n+\t  delete tq[i];\n+\t}\n+    }\n+\n+  return 0;\n+}\n+#else\n+int main (void) {}\n+#endif"}, {"sha": "3ffba23f21d89c8e8115aae57fc7f661359306af", "filename": "libstdc++-v3/testsuite/thread/pthread2.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread2.cc?ref=ddd69607433a8cd05cf50c524746bea197205b6d", "patch": "@@ -0,0 +1,67 @@\n+// 2002-01-23  Loren J. Rittle <rittle@labs.mot.com> <ljrittle@acm.org>\n+// Adpated from libstdc++/5347 submitted by markus.breuer@materna.de\n+//\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// { dg-do run { target *-*-freebsd* *-*-linux* *-*-solaris* } }\n+// { dg-options \"-pthread\" { target *-*-freebsd* *-*-linux* } }\n+// { dg-options \"-pthreads\" { target *-*-solaris* } }\n+\n+#include <fstream>\n+\n+// Do not include <pthread.h> explicitly; if threads are properly\n+// configured for the port, then it is picked up free from STL headers.\n+\n+#if __GTHREADS\n+\n+const int max_thread_count = 2;\n+const int max_loop_count = 1000000;\n+\n+void*\n+thread_main (void *)\n+{\n+   for (int i = 0; i < max_loop_count; i++)\n+   {\n+      std::ofstream* pos1 = new std::ofstream;\n+      delete pos1;\n+   }\n+\n+   return 0;\n+}\n+\n+int\n+main()\n+{\n+  pthread_t tid[max_thread_count];\n+\n+#if defined(__sun) && defined(__svr4__)\n+  pthread_setconcurrency (max_thread_count);\n+#endif\n+\n+  for (int i = 0; i < max_thread_count; i++)\n+    pthread_create (&tid[i], NULL, thread_main, 0);\n+\n+  for (int i = 0; i < max_thread_count; i++)\n+    pthread_join (tid[i], NULL);\n+\n+  return 0;\n+}\n+#else\n+int main (void) {}\n+#endif"}, {"sha": "d029f3b5c976d0dc3c9bad9a049346a271a7650b", "filename": "libstdc++-v3/testsuite/thread/pthread3.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread3.cc?ref=ddd69607433a8cd05cf50c524746bea197205b6d", "patch": "@@ -0,0 +1,64 @@\n+// 2002-01-23  Loren J. Rittle <rittle@labs.mot.com> <ljrittle@acm.org>\n+// Adpated from libstdc++/5347 submitted by markus.breuer@materna.de\n+//\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// { dg-do run { target *-*-freebsd* *-*-linux* *-*-solaris* } }\n+// { dg-options \"-pthread\" { target *-*-freebsd* *-*-linux* } }\n+// { dg-options \"-pthreads\" { target *-*-solaris* } }\n+\n+#include <sstream>\n+\n+// Do not include <pthread.h> explicitly; if threads are properly\n+// configured for the port, then it is picked up free from STL headers.\n+\n+#if __GTHREADS\n+\n+const int max_thread_count = 2;\n+const int max_loop_count = 1000000;\n+\n+void*\n+thread_main (void *)\n+{\n+   for (int i = 0; i < max_loop_count; i++)\n+     std::ostringstream oss;\n+\n+   return 0;\n+}\n+\n+int\n+main()\n+{\n+  pthread_t tid[max_thread_count];\n+\n+#if defined(__sun) && defined(__svr4__)\n+  pthread_setconcurrency (max_thread_count);\n+#endif\n+\n+  for (int i = 0; i < max_thread_count; i++)\n+    pthread_create (&tid[i], NULL, thread_main, 0);\n+\n+  for (int i = 0; i < max_thread_count; i++)\n+    pthread_join (tid[i], NULL);\n+\n+  return 0;\n+}\n+#else\n+int main (void) {}\n+#endif"}, {"sha": "b6d70c9d775bbf02c6596adbd70fd65ecaffd756", "filename": "libstdc++-v3/testsuite/thread/pthread4.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread4.cc?ref=ddd69607433a8cd05cf50c524746bea197205b6d", "patch": "@@ -0,0 +1,97 @@\n+// 2002-01-23  Loren J. Rittle <rittle@labs.mot.com> <ljrittle@acm.org>\n+// Adapted from http://gcc.gnu.org/ml/gcc-bugs/2002-01/msg00679.html\n+// which was adapted from pthread1.cc by Mike Lu <MLu@dynamicsoft.com>\n+//\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// { dg-do run { target *-*-freebsd* *-*-linux* *-*-solaris* } }\n+// { dg-options \"-pthread\" { target *-*-freebsd* *-*-linux* } }\n+// { dg-options \"-pthreads\" { target *-*-solaris* } }\n+\n+#include <string>\n+#include <list>\n+\n+// Do not include <pthread.h> explicitly; if threads are properly\n+// configured for the port, then it is picked up free from STL headers.\n+\n+#if __GTHREADS\n+using namespace std;\n+\n+static list<string> foo;\n+static pthread_mutex_t fooLock = PTHREAD_MUTEX_INITIALIZER;\n+static unsigned max_size = 10;\n+static int iters = 1000000;\n+\n+void*\n+produce (void*)\n+{\n+  for (int num = 0; num < iters; )\n+    {\n+      string str (\"test string\");\n+\n+      pthread_mutex_lock (&fooLock);\n+      if (foo.size () < max_size)\n+\t{\n+\t  foo.push_back (str);\n+\t  num++;\n+\t}\n+      pthread_mutex_unlock (&fooLock);\n+    }\n+\n+  return 0;\n+}\n+\n+void*\n+consume (void*)\n+{\n+  for (int num = 0; num < iters; )\n+    {\n+      pthread_mutex_lock (&fooLock);\n+      while (foo.size () > 0)\n+\t{\n+\t  string str = foo.back ();\n+\t  foo.pop_back ();\n+\t  num++;\n+\t}\n+      pthread_mutex_unlock (&fooLock);\n+    }\n+\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+#if defined(__sun) && defined(__svr4__)\n+  pthread_setconcurrency (2);\n+#endif\n+\n+  pthread_t prod;\n+  pthread_create (&prod, NULL, produce, NULL);\n+  pthread_t cons;\n+  pthread_create (&cons, NULL, consume, NULL);\n+\n+  pthread_join (prod, NULL);\n+  pthread_join (cons, NULL);\n+\n+  return 0;\n+}\n+#else\n+int main (void) {}\n+#endif"}, {"sha": "fcd491d967ca1556bb6535bbd12e89ab0c2f2ecf", "filename": "libstdc++-v3/testsuite/thread/pthread5.cc", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread5.cc?ref=ddd69607433a8cd05cf50c524746bea197205b6d", "patch": "@@ -0,0 +1,123 @@\n+// 2002-01-23  Loren J. Rittle <rittle@labs.mot.com> <ljrittle@acm.org>\n+// Adpated from libstdc++/5464 submitted by jjessel@amadeus.net\n+// Jean-Francois JESSEL (Amadeus SAS Development) \n+//\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// { dg-do run { target *-*-freebsd* *-*-linux* *-*-solaris* } }\n+// { dg-options \"-pthread\" { target *-*-freebsd* *-*-linux* } }\n+// { dg-options \"-pthreads\" { target *-*-solaris* } }\n+\n+#include <vector>\n+#include <list>\n+#include <string>\n+\n+// Do not include <pthread.h> explicitly; if threads are properly\n+// configured for the port, then it is picked up free from STL headers.\n+\n+#if __GTHREADS\n+using namespace std;\n+\n+#define NTHREADS 8\n+#define LOOPS 20\n+\n+struct tt_t\n+{\n+  char buf[100];\n+  int  i;\n+};\n+\n+void*\n+thread_function (void* arg)\n+{\n+  int myid = *(int*) arg;\n+  for (int i = 0; i < LOOPS; i++)\n+    {\n+      vector<tt_t> myvect1;\n+\n+      for (int j = 0; j < 2000; j++)\n+\t{\n+\t  vector<tt_t> myvect2;\n+\t  tt_t v;\n+\t  v.i = j;\n+\t  myvect1.push_back (v);\n+\t  myvect2.push_back (v);\n+\t  list<std::string *> mylist;\n+\t  std::string string_array[4];\n+\t  string_array[0] = \"toto\";\n+\t  string_array[1] = \"titi\";\n+\t  string_array[2] = \"tata\";\n+\t  string_array[3] = \"tutu\";\n+\t  for (int k = 0; k < 4; k++)\n+\t    {\n+\t      if (mylist.size ())\n+\t\t{\n+\t\t  list<std::string *>::iterator aIt;\n+\t\t  for (aIt = mylist.begin (); aIt != mylist.end (); ++aIt)\n+\t\t    {\n+\t\t      if ((*aIt) == &(string_array[k]))\n+\t\t\tabort ();\n+\t\t    }\n+\t\t}\n+\t      mylist.push_back (&(string_array[k]));\n+\t    }\n+\t}\n+    }\n+\n+  return arg;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int worker;\n+  pthread_t threads[NTHREADS];\n+  int ids[NTHREADS];\n+  void* status;\n+\n+#if defined(__sun) && defined(__svr4__)\n+  pthread_setconcurrency (NTHREADS);\n+#endif\n+\n+  pthread_attr_t tattr;\n+  int ret = pthread_attr_init (&tattr);\n+  ret = pthread_attr_setscope(&tattr, PTHREAD_SCOPE_SYSTEM);\n+\n+  for (worker = 0; worker < NTHREADS; worker++)\n+    {\n+      ids[worker] = worker;\n+      if (pthread_create(&threads[worker], &tattr,\n+\t\t\t thread_function, &ids[worker]))\n+\tabort ();\n+    }\n+\n+  for (worker = 0; worker < NTHREADS; worker++)\n+    {\n+      if (pthread_join(threads[worker], static_cast<void **>(&status)))\n+\tabort ();\n+\n+      if (*((int *)status) != worker)\n+\tabort ();\n+    }\n+\n+  return (0);\n+}\n+#else\n+int main (void) {}\n+#endif"}, {"sha": "d0bd82f1b39572b817314cfb785037c36489c719", "filename": "libstdc++-v3/testsuite/thread/pthread6.cc", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd69607433a8cd05cf50c524746bea197205b6d/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fpthread6.cc?ref=ddd69607433a8cd05cf50c524746bea197205b6d", "patch": "@@ -0,0 +1,94 @@\n+// 2002-01-23  Loren J. Rittle <rittle@labs.mot.com> <ljrittle@acm.org>\n+// Adpated from libstdc++/5444 submitted by markus.breuer@materna.de\n+//\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// { dg-do run { target *-*-freebsd* *-*-linux* *-*-solaris* } }\n+// { dg-options \"-pthread\" { target *-*-freebsd* *-*-linux* } }\n+// { dg-options \"-pthreads\" { target *-*-solaris* } }\n+\n+#include <string>\n+#include <map>\n+#include <vector>\n+\n+// Do not include <pthread.h> explicitly; if threads are properly\n+// configured for the port, then it is picked up free from STL headers.\n+\n+#if __GTHREADS\n+\n+const int max_thread_count = 8;\n+const int loops = 100000;\n+\n+const char* my_default = \"Hallo Welt!\";\n+\n+const int upper_limit = 2500;\n+const int lower_limit = 1000;\n+\n+typedef char charT;\n+\n+typedef std::string String;\n+\n+typedef String MyType;\n+\n+void*\n+thread_main (void*)\n+{\n+  typedef std::map<unsigned int,MyType> Map;\n+  typedef Map::value_type Value_Pair;\n+  Map myMap;\n+\n+  for (int loop = 0; loop < loops; loop++)\n+    {\n+      String& str = myMap[loop];\n+      str.append (my_default);\n+      myMap.insert (Value_Pair (loop, str));\n+      \n+      if (myMap.size () > upper_limit)\n+\t{\n+\t  while (myMap.size () > lower_limit)\n+\t    {\n+\t      Map::iterator it = myMap.begin ();\n+\t      myMap.erase (it);\n+\t    }\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  pthread_t tid[max_thread_count];\n+\n+#if defined(__sun) && defined(__svr4__)\n+  pthread_setconcurrency (max_thread_count);\n+#endif\n+\n+  for (int i = 0; i < max_thread_count; i++)\n+    pthread_create (&tid[i], NULL, thread_main, 0);\n+\n+  for (int i = 0; i < max_thread_count; i++)\n+    pthread_join (tid[i], NULL);\n+\n+  return 0;\n+}\n+#else\n+int main (void) {}\n+#endif"}]}