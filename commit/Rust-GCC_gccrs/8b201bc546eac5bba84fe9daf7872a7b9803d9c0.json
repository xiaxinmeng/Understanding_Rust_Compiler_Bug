{"sha": "8b201bc546eac5bba84fe9daf7872a7b9803d9c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIyMDFiYzU0NmVhYzViYmE4NGZlOWRhZjc4NzJhN2I5ODAzZDljMA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-08-05T07:33:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-05T07:33:09Z"}, "message": "tree-vrp.c (zero_nonzero_bits_from_vr): Make sure to always return true for constant integer ranges.\n\n2011-08-05  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (zero_nonzero_bits_from_vr): Make sure to always\n\treturn true for constant integer ranges.\n\t(extract_range_from_binary_expr_1): Simplify BIT_AND_EXPR and\n\tBIT_IOR_EXPR handling.\n\n\t* gcc.dg/tree-ssa/vrp51.c: Disable CCP.\n\t* gcc.dg/tree-ssa/vrp52.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp53.c: Likewise.\n\nFrom-SVN: r177423", "tree": {"sha": "8e3eb958094c78323b96a3c4e79bb3662e9d36d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e3eb958094c78323b96a3c4e79bb3662e9d36d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b201bc546eac5bba84fe9daf7872a7b9803d9c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b201bc546eac5bba84fe9daf7872a7b9803d9c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b201bc546eac5bba84fe9daf7872a7b9803d9c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "44997fe47870ee693dfda30d818d5aeee8a32b9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44997fe47870ee693dfda30d818d5aeee8a32b9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44997fe47870ee693dfda30d818d5aeee8a32b9b"}], "stats": {"total": 111, "additions": 41, "deletions": 70}, "files": [{"sha": "5859bea2c350d69962fa58282871e3486bf3555a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b201bc546eac5bba84fe9daf7872a7b9803d9c0", "patch": "@@ -1,3 +1,10 @@\n+2011-08-05  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (zero_nonzero_bits_from_vr): Make sure to always\n+\treturn true for constant integer ranges.\n+\t(extract_range_from_binary_expr_1): Simplify BIT_AND_EXPR and\n+\tBIT_IOR_EXPR handling.\n+\n 2011-08-04  Kai Tietz  <ktietz@redhat.com>\n \n \t* config/i386/i386.c (setup_incoming_varargs_ms_64): Set"}, {"sha": "666fcd6a1676df35bb363609534f545e7067f876", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b201bc546eac5bba84fe9daf7872a7b9803d9c0", "patch": "@@ -1,3 +1,9 @@\n+2011-08-05  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/vrp51.c: Disable CCP.\n+\t* gcc.dg/tree-ssa/vrp52.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp53.c: Likewise.\n+\n 2011-08-04  Mikael Morin  <mikael.morin@sfr.fr>\n \n \t* gfortran.dg/dependency_26.f90: Add a module to the cleanup directive."}, {"sha": "94b29766a4509aebb5b47b06475573138bfb6080", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp51.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp51.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp51.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp51.c?ref=8b201bc546eac5bba84fe9daf7872a7b9803d9c0", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/28632 */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-vrp\" } */\n+/* { dg-options \"-O2 -ftree-vrp -fno-tree-ccp\" } */\n /* { dg-require-effective-target int32plus } */\n \n void"}, {"sha": "52ceea6bef59232cfc3dfdb1a83a68d77b9d6bfc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp52.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp52.c?ref=8b201bc546eac5bba84fe9daf7872a7b9803d9c0", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1 -fno-tree-ccp\" } */\n \n int\n foo (unsigned int i, unsigned int j)"}, {"sha": "4bcd299eedeb0d027356842ea1d23b0513b73d98", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp53.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp53.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp53.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp53.c?ref=8b201bc546eac5bba84fe9daf7872a7b9803d9c0", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1 -fno-tree-ccp\" } */\n \n int\n f1 (int x)"}, {"sha": "121746efab677f55ca3c4d6d4e2f4c9201252f7c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 25, "deletions": 67, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b201bc546eac5bba84fe9daf7872a7b9803d9c0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=8b201bc546eac5bba84fe9daf7872a7b9803d9c0", "patch": "@@ -2141,15 +2141,18 @@ static bool\n zero_nonzero_bits_from_vr (value_range_t *vr, double_int *may_be_nonzero,\n \t\t\t   double_int *must_be_nonzero)\n {\n+  may_be_nonzero->low = ALL_ONES;\n+  may_be_nonzero->high = ALL_ONES;\n+  must_be_nonzero->low = 0;\n+  must_be_nonzero->high = 0;\n   if (range_int_cst_p (vr))\n     {\n       if (range_int_cst_singleton_p (vr))\n \t{\n \t  *may_be_nonzero = tree_to_double_int (vr->min);\n \t  *must_be_nonzero = *may_be_nonzero;\n-\t  return true;\n \t}\n-      if (tree_int_cst_sgn (vr->min) >= 0)\n+      else if (tree_int_cst_sgn (vr->min) >= 0)\n \t{\n \t  double_int dmin = tree_to_double_int (vr->min);\n \t  double_int dmax = tree_to_double_int (vr->max);\n@@ -2174,13 +2177,9 @@ zero_nonzero_bits_from_vr (value_range_t *vr, double_int *may_be_nonzero,\n \t      may_be_nonzero->low |= mask;\n \t      must_be_nonzero->low &= ~mask;\n \t    }\n-\t  return true;\n \t}\n+      return true;\n     }\n-  may_be_nonzero->low = ALL_ONES;\n-  may_be_nonzero->high = ALL_ONES;\n-  must_be_nonzero->low = 0;\n-  must_be_nonzero->high = 0;\n   return false;\n }\n \n@@ -2638,69 +2637,27 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n     }\n   else if (code == BIT_AND_EXPR || code == BIT_IOR_EXPR)\n     {\n-      bool vr0_int_cst_singleton_p, vr1_int_cst_singleton_p;\n       bool int_cst_range0, int_cst_range1;\n       double_int may_be_nonzero0, may_be_nonzero1;\n       double_int must_be_nonzero0, must_be_nonzero1;\n-      value_range_t *non_singleton_vr;\n-      tree singleton_val;\n \n-      vr0_int_cst_singleton_p = range_int_cst_singleton_p (&vr0);\n-      vr1_int_cst_singleton_p = range_int_cst_singleton_p (&vr1);\n       int_cst_range0 = zero_nonzero_bits_from_vr (&vr0, &may_be_nonzero0,\n \t\t\t\t\t\t  &must_be_nonzero0);\n       int_cst_range1 = zero_nonzero_bits_from_vr (&vr1, &may_be_nonzero1,\n \t\t\t\t\t\t  &must_be_nonzero1);\n \n-      singleton_val = (vr0_int_cst_singleton_p ? vr0.min : vr1.min);\n-      non_singleton_vr = (vr0_int_cst_singleton_p ? &vr1 : &vr0);\n-\n       type = VR_RANGE;\n-      if (vr0_int_cst_singleton_p && vr1_int_cst_singleton_p)\n-\tmin = max = int_const_binop (code, vr0.max, vr1.max);\n-      else if ((vr0_int_cst_singleton_p || vr1_int_cst_singleton_p)\n-      \t       && (integer_zerop (singleton_val)\n-      \t           || integer_all_onesp (singleton_val)))\n-\t{\n-\t  /* If one of the operands is zero for and-case, we know that\n- * \t     the whole expression evaluates zero.\n-\t     If one of the operands has all bits set to one for\n-\t     or-case, we know that the whole expression evaluates\n-\t     to this one.  */\n-\t   min = max = singleton_val;\n-\t   if ((code == BIT_IOR_EXPR\n-\t\t&& integer_zerop (singleton_val))\n-\t       || (code == BIT_AND_EXPR\n-\t\t   && integer_all_onesp (singleton_val)))\n-\t  /* If one of the operands has all bits set to one, we know\n-\t     that the whole expression evaluates to the other one for\n-\t     the and-case.\n-\t     If one of the operands is zero, we know that the whole\n-\t     expression evaluates to the other one for the or-case.  */\n-\t    {\n-\t      type = non_singleton_vr->type;\n-\t      min = non_singleton_vr->min;\n-\t      max = non_singleton_vr->max;\n-\t    }\n-\t  set_value_range (vr, type, min, max, NULL);\n-\t  return;\n-\t}\n-      else if (!int_cst_range0 && !int_cst_range1)\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-      else if (code == BIT_AND_EXPR)\n+      if (code == BIT_AND_EXPR)\n \t{\n \t  min = double_int_to_tree (expr_type,\n \t\t\t\t    double_int_and (must_be_nonzero0,\n \t\t\t\t\t\t    must_be_nonzero1));\n \t  max = double_int_to_tree (expr_type,\n \t\t\t\t    double_int_and (may_be_nonzero0,\n \t\t\t\t\t\t    may_be_nonzero1));\n-\t  if (TREE_OVERFLOW (min) || tree_int_cst_sgn (min) < 0)\n+\t  if (tree_int_cst_sgn (min) < 0)\n \t    min = NULL_TREE;\n-\t  if (TREE_OVERFLOW (max) || tree_int_cst_sgn (max) < 0)\n+\t  if (tree_int_cst_sgn (max) < 0)\n \t    max = NULL_TREE;\n \t  if (int_cst_range0 && tree_int_cst_sgn (vr0.min) >= 0)\n \t    {\n@@ -2717,29 +2674,30 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t\tmax = vr1.max;\n \t    }\n \t}\n-      else if (!int_cst_range0\n-\t       || !int_cst_range1\n-\t       || tree_int_cst_sgn (vr0.min) < 0\n-\t       || tree_int_cst_sgn (vr1.min) < 0)\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-      else\n+      else if (code == BIT_IOR_EXPR)\n \t{\n \t  min = double_int_to_tree (expr_type,\n \t\t\t\t    double_int_ior (must_be_nonzero0,\n \t\t\t\t\t\t    must_be_nonzero1));\n \t  max = double_int_to_tree (expr_type,\n \t\t\t\t    double_int_ior (may_be_nonzero0,\n \t\t\t\t\t\t    may_be_nonzero1));\n-\t  if (TREE_OVERFLOW (min) || tree_int_cst_sgn (min) < 0)\n-\t    min = vr0.min;\n-\t  else\n-\t    min = vrp_int_const_binop (MAX_EXPR, min, vr0.min);\n-\t  if (TREE_OVERFLOW (max) || tree_int_cst_sgn (max) < 0)\n+\t  if (tree_int_cst_sgn (max) < 0)\n \t    max = NULL_TREE;\n-\t  min = vrp_int_const_binop (MAX_EXPR, min, vr1.min);\n+\t  if (int_cst_range0)\n+\t    {\n+\t      if (tree_int_cst_sgn (min) < 0)\n+\t\tmin = vr0.min;\n+\t      else\n+\t\tmin = vrp_int_const_binop (MAX_EXPR, min, vr0.min);\n+\t    }\n+\t  if (int_cst_range1)\n+\t    min = vrp_int_const_binop (MAX_EXPR, min, vr1.min);\n+\t}\n+      else\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n \t}\n     }\n   else"}]}