{"sha": "8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNkYThhZDNkMDU4NWQzNmZlMDdjM2Q1ZDI4YmZiZDZmNDc0NDA3NA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-06-13T21:43:51Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-06-13T21:43:51Z"}, "message": "re PR debug/49888 (VTA: -O2 -g variable value changes, it does not change in the source)\n\ngcc/ChangeLog:\nPR debug/49888\n* var-tracking.c: Include alias.h.\n(overlapping_mems): New struct.\n(drop_overlapping_mem_locs): New.\n(clobber_overlapping_mems): New.\n(var_mem_delete_and_set, var_mem_delete): Call it.\n(val_bind): Likewise, but only if modified.\n(compute_bb_dataflow, emit_notes_in_bb): Call it on MEMs.\n* Makefile.in (var-tracking.o): Depend in $(ALIAS_H).\ngcc/testsuite/ChangeLog:\nPR debug/49888\n* gcc.dg/guality/pr49888.c: New.\n\nFrom-SVN: r188531", "tree": {"sha": "7982d2fb9294759c59c13fbc2cce57088cbedbff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7982d2fb9294759c59c13fbc2cce57088cbedbff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074/comments", "author": null, "committer": null, "parents": [{"sha": "d05cae4a9778e74240058e0343dc257f188b4859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05cae4a9778e74240058e0343dc257f188b4859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d05cae4a9778e74240058e0343dc257f188b4859"}], "stats": {"total": 161, "additions": 159, "deletions": 2}, "files": [{"sha": "c6bf75be581fbadb15008418da5748abb59da685", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074", "patch": "@@ -1,3 +1,15 @@\n+2012-06-13  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/49888\n+\t* var-tracking.c: Include alias.h.\n+\t(overlapping_mems): New struct.\n+\t(drop_overlapping_mem_locs): New.\n+\t(clobber_overlapping_mems): New.\n+\t(var_mem_delete_and_set, var_mem_delete): Call it.\n+\t(val_bind): Likewise, but only if modified.\n+\t(compute_bb_dataflow, emit_notes_in_bb): Call it on MEMs.\n+\t* Makefile.in (var-tracking.o): Depend in $(ALIAS_H).\n+\n 2012-06-13  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/47624"}, {"sha": "9107a32ead3e4dd879b7649cfbc4a811eb8bb6bc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074", "patch": "@@ -3131,8 +3131,8 @@ var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) bitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n    $(REGS_H) $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H) $(TREE_FLOW_H) \\\n-   cselib.h $(TARGET_H) $(DIAGNOSTIC_CORE_H) $(PARAMS_H) $(DIAGNOSTIC_H) pointer-set.h \\\n-   $(RECOG_H) $(TM_P_H) $(TREE_PRETTY_PRINT_H)\n+   cselib.h $(TARGET_H) $(DIAGNOSTIC_CORE_H) $(PARAMS_H) $(DIAGNOSTIC_H) \\\n+   pointer-set.h $(RECOG_H) $(TM_P_H) $(TREE_PRETTY_PRINT_H) $(ALIAS_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(REGS_H) $(EXPR_H) $(FUNCTION_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_CORE_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \\"}, {"sha": "fb9b69c3df7790a3811b9809148c09b7650505e1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074", "patch": "@@ -1,3 +1,8 @@\n+2012-06-13  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/49888\n+\t* gcc.dg/guality/pr49888.c: New.\n+\n 2012-06-13  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* g++.dg/tree-ssa/ivopts-2.C: Adjust for coalescing."}, {"sha": "3d1e65321efdb4f9e1c681a998064749ebeb9cc1", "filename": "gcc/testsuite/gcc.dg/guality/pr49888.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr49888.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr49888.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr49888.c?ref=8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074", "patch": "@@ -0,0 +1,25 @@\n+/* PR debug/49888 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+static int v;\n+\n+static void __attribute__((noinline, noclone))\n+f (int *p)\n+{\n+  int c = *p;\n+  v = c;\n+  *p = 1; /* { dg-final { gdb-test 12 \"c\" \"0\" } } */\n+  /* c may very well be optimized out at this point, so we test !c,\n+     which will evaluate to the expected value.  We just want to make\n+     sure it doesn't remain bound to *p as it did before, in which\n+     case !c would evaluate to 0.  */\n+  v = 0; /* { dg-final { gdb-test 17 \"!c\" \"1\" } } */\n+}\n+int\n+main ()\n+{\n+  int a = 0;\n+  f (&a);\n+  return 0;\n+}"}, {"sha": "e1fed62830937dfc73a3959deb60b7d352abfb3a", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=8cda8ad3d0585d36fe07c3d5d28bfbd6f4744074", "patch": "@@ -115,6 +115,7 @@\n #include \"pointer-set.h\"\n #include \"recog.h\"\n #include \"tm_p.h\"\n+#include \"alias.h\"\n \n /* var-tracking.c assumes that tree code with the same value as VALUE rtx code\n    has no chance to appear in REG_EXPR/MEM_EXPRs and isn't a decl.\n@@ -1954,6 +1955,111 @@ var_regno_delete (dataflow_set *set, int regno)\n   *reg = NULL;\n }\n \n+/* Hold parameters for the hashtab traversal function\n+   drop_overlapping_mem_locs, see below.  */\n+\n+struct overlapping_mems\n+{\n+  dataflow_set *set;\n+  rtx loc, addr;\n+};\n+\n+/* Remove all MEMs that overlap with COMS->LOC from the location list\n+   of a hash table entry for a value.  COMS->ADDR must be a\n+   canonicalized form of COMS->LOC's address, and COMS->LOC must be\n+   canonicalized itself.  */\n+\n+static int\n+drop_overlapping_mem_locs (void **slot, void *data)\n+{\n+  struct overlapping_mems *coms = (struct overlapping_mems *)data;\n+  dataflow_set *set = coms->set;\n+  rtx mloc = coms->loc, addr = coms->addr;\n+  variable var = (variable) *slot;\n+\n+  if (var->onepart == ONEPART_VALUE)\n+    {\n+      location_chain loc, *locp;\n+      bool changed = false;\n+      rtx cur_loc;\n+\n+      gcc_assert (var->n_var_parts == 1);\n+\n+      if (shared_var_p (var, set->vars))\n+\t{\n+\t  for (loc = var->var_part[0].loc_chain; loc; loc = loc->next)\n+\t    if (GET_CODE (loc->loc) == MEM\n+\t\t&& canon_true_dependence (mloc, GET_MODE (mloc), addr,\n+\t\t\t\t\t  loc->loc, NULL))\n+\t      break;\n+\n+\t  if (!loc)\n+\t    return 1;\n+\n+\t  slot = unshare_variable (set, slot, var, VAR_INIT_STATUS_UNKNOWN);\n+\t  var = (variable)*slot;\n+\t  gcc_assert (var->n_var_parts == 1);\n+\t}\n+\n+      if (VAR_LOC_1PAUX (var))\n+\tcur_loc = VAR_LOC_FROM (var);\n+      else\n+\tcur_loc = var->var_part[0].cur_loc;\n+\n+      for (locp = &var->var_part[0].loc_chain, loc = *locp;\n+\t   loc; loc = *locp)\n+\t{\n+\t  if (GET_CODE (loc->loc) != MEM\n+\t      || !canon_true_dependence (mloc, GET_MODE (mloc), addr,\n+\t\t\t\t\t loc->loc, NULL))\n+\t    {\n+\t      locp = &loc->next;\n+\t      continue;\n+\t    }\n+\n+\t  *locp = loc->next;\n+\t  /* If we have deleted the location which was last emitted\n+\t     we have to emit new location so add the variable to set\n+\t     of changed variables.  */\n+\t  if (cur_loc == loc->loc)\n+\t    {\n+\t      changed = true;\n+\t      var->var_part[0].cur_loc = NULL;\n+\t      if (VAR_LOC_1PAUX (var))\n+\t\tVAR_LOC_FROM (var) = NULL;\n+\t    }\n+\t  pool_free (loc_chain_pool, loc);\n+\t}\n+\n+      if (!var->var_part[0].loc_chain)\n+\t{\n+\t  var->n_var_parts--;\n+\t  changed = true;\n+\t}\n+      if (changed)\n+\tvariable_was_changed (var, set);\n+    }\n+\n+  return 1;\n+}\n+\n+/* Remove from SET all VALUE bindings to MEMs that overlap with LOC.  */\n+\n+static void\n+clobber_overlapping_mems (dataflow_set *set, rtx loc)\n+{\n+  struct overlapping_mems coms;\n+\n+  coms.set = set;\n+  coms.loc = canon_rtx (loc);\n+  coms.addr = canon_rtx (get_addr (XEXP (loc, 0)));\n+\n+  set->traversed_vars = set->vars;\n+  htab_traverse (shared_hash_htab (set->vars),\n+\t\t drop_overlapping_mem_locs, &coms);\n+  set->traversed_vars = NULL;\n+}\n+\n /* Set the location of DV, OFFSET as the MEM LOC.  */\n \n static void\n@@ -1996,6 +2102,7 @@ var_mem_delete_and_set (dataflow_set *set, rtx loc, bool modify,\n   tree decl = MEM_EXPR (loc);\n   HOST_WIDE_INT offset = INT_MEM_OFFSET (loc);\n \n+  clobber_overlapping_mems (set, loc);\n   decl = var_debug_decl (decl);\n \n   if (initialized == VAR_INIT_STATUS_UNKNOWN)\n@@ -2016,6 +2123,7 @@ var_mem_delete (dataflow_set *set, rtx loc, bool clobber)\n   tree decl = MEM_EXPR (loc);\n   HOST_WIDE_INT offset = INT_MEM_OFFSET (loc);\n \n+  clobber_overlapping_mems (set, loc);\n   decl = var_debug_decl (decl);\n   if (clobber)\n     clobber_variable_part (set, NULL, dv_from_decl (decl), offset, NULL);\n@@ -2059,6 +2167,9 @@ val_bind (dataflow_set *set, rtx val, rtx loc, bool modified)\n     {\n       struct elt_loc_list *l = CSELIB_VAL_PTR (val)->locs;\n \n+      if (modified)\n+\tclobber_overlapping_mems (set, loc);\n+\n       if (l && GET_CODE (l->loc) == VALUE)\n \tl = canonical_cselib_val (CSELIB_VAL_PTR (l->loc))->locs;\n \n@@ -6371,6 +6482,8 @@ compute_bb_dataflow (basic_block bb)\n \t\t}\n \t      else if (REG_P (uloc))\n \t\tvar_regno_delete (out, REGNO (uloc));\n+\t      else if (MEM_P (uloc))\n+\t\tclobber_overlapping_mems (out, uloc);\n \n \t      val_store (out, val, dstv, insn, true);\n \t    }\n@@ -8870,6 +8983,8 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t\t}\n \t      else if (REG_P (uloc))\n \t\tvar_regno_delete (set, REGNO (uloc));\n+\t      else if (MEM_P (uloc))\n+\t\tclobber_overlapping_mems (set, uloc);\n \n \t      val_store (set, val, dstv, insn, true);\n "}]}