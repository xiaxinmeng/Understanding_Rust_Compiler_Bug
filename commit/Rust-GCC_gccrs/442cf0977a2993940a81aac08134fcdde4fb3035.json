{"sha": "442cf0977a2993940a81aac08134fcdde4fb3035", "node_id": "C_kwDOANBUbNoAKDQ0MmNmMDk3N2EyOTkzOTQwYTgxYWFjMDgxMzRmY2RkZTRmYjMwMzU", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-05-24T13:07:22Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-05-24T13:07:22Z"}, "message": "d: add 'final' and 'override' to gcc/d/*.cc 'visit' impls\n\ngcc/d/ChangeLog:\n\t* decl.cc: Add \"final\" and \"override\" to all \"visit\" vfunc decls\n\tas appropriate.\n\t* expr.cc: Likewise.\n\t* toir.cc: Likewise.\n\t* typeinfo.cc: Likewise.\n\t* types.cc: Likewise.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "248de6a6b1b04853f08ffd11ed66d16fb3a3849a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/248de6a6b1b04853f08ffd11ed66d16fb3a3849a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/442cf0977a2993940a81aac08134fcdde4fb3035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442cf0977a2993940a81aac08134fcdde4fb3035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442cf0977a2993940a81aac08134fcdde4fb3035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442cf0977a2993940a81aac08134fcdde4fb3035/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d44e471cf041d5a304f2b2bbc7d104fa17f0e9da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d44e471cf041d5a304f2b2bbc7d104fa17f0e9da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d44e471cf041d5a304f2b2bbc7d104fa17f0e9da"}], "stats": {"total": 166, "additions": 83, "deletions": 83}, "files": [{"sha": "5d850065bf0fb9bb1b759dcdc52cfa3beebc5321", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442cf0977a2993940a81aac08134fcdde4fb3035/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442cf0977a2993940a81aac08134fcdde4fb3035/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=442cf0977a2993940a81aac08134fcdde4fb3035", "patch": "@@ -149,13 +149,13 @@ class DeclVisitor : public Visitor\n \n   /* This should be overridden by each declaration class.  */\n \n-  void visit (Dsymbol *)\n+  void visit (Dsymbol *) final override\n   {\n   }\n \n   /* Compile a D module, and all members of it.  */\n \n-  void visit (Module *d)\n+  void visit (Module *d) final override\n   {\n     if (d->semanticRun >= PASS::obj)\n       return;\n@@ -166,7 +166,7 @@ class DeclVisitor : public Visitor\n \n   /* Write the imported symbol to debug.  */\n \n-  void visit (Import *d)\n+  void visit (Import *d) final override\n   {\n     if (d->semanticRun >= PASS::obj)\n       return;\n@@ -218,7 +218,7 @@ class DeclVisitor : public Visitor\n \n   /* Expand any local variables found in tuples.  */\n \n-  void visit (TupleDeclaration *d)\n+  void visit (TupleDeclaration *d) final override\n   {\n     for (size_t i = 0; i < d->objects->length; i++)\n       {\n@@ -234,7 +234,7 @@ class DeclVisitor : public Visitor\n \n   /* Walk over all declarations in the attribute scope.  */\n \n-  void visit (AttribDeclaration *d)\n+  void visit (AttribDeclaration *d) final override\n   {\n     Dsymbols *ds = d->include (NULL);\n \n@@ -248,7 +248,7 @@ class DeclVisitor : public Visitor\n   /* Pragmas are a way to pass special information to the compiler and to add\n      vendor specific extensions to D.  */\n \n-  void visit (PragmaDeclaration *d)\n+  void visit (PragmaDeclaration *d) final override\n   {\n     if (d->ident == Identifier::idPool (\"lib\")\n \t|| d->ident == Identifier::idPool (\"startaddress\"))\n@@ -266,7 +266,7 @@ class DeclVisitor : public Visitor\n   /* Conditional compilation is the process of selecting which code to compile\n      and which code to not compile.  Look for version conditions that may  */\n \n-  void visit (ConditionalDeclaration *d)\n+  void visit (ConditionalDeclaration *d) final override\n   {\n     bool old_condition = this->in_version_unittest_;\n \n@@ -284,7 +284,7 @@ class DeclVisitor : public Visitor\n \n   /* Walk over all members in the namespace scope.  */\n \n-  void visit (Nspace *d)\n+  void visit (Nspace *d) final override\n   {\n     if (isError (d) || !d->members)\n       return;\n@@ -298,7 +298,7 @@ class DeclVisitor : public Visitor\n      voldemort type, then it's members must be compiled before the parent\n      function finishes.  */\n \n-  void visit (TemplateDeclaration *d)\n+  void visit (TemplateDeclaration *d) final override\n   {\n     /* Type cannot be directly named outside of the scope it's declared in, so\n        the only way it can be escaped is if the function has auto return.  */\n@@ -329,7 +329,7 @@ class DeclVisitor : public Visitor\n \n   /* Walk over all members in the instantiated template.  */\n \n-  void visit (TemplateInstance *d)\n+  void visit (TemplateInstance *d) final override\n   {\n     if (isError (d)|| !d->members)\n       return;\n@@ -343,7 +343,7 @@ class DeclVisitor : public Visitor\n \n   /* Walk over all members in the mixin template scope.  */\n \n-  void visit (TemplateMixin *d)\n+  void visit (TemplateMixin *d) final override\n   {\n     if (isError (d)|| !d->members)\n       return;\n@@ -355,7 +355,7 @@ class DeclVisitor : public Visitor\n   /* Write out compiler generated TypeInfo, initializer and functions for the\n      given struct declaration, walking over all static members.  */\n \n-  void visit (StructDeclaration *d)\n+  void visit (StructDeclaration *d) final override\n   {\n     if (d->semanticRun >= PASS::obj)\n       return;\n@@ -470,7 +470,7 @@ class DeclVisitor : public Visitor\n   /* Write out compiler generated TypeInfo, initializer and vtables for the\n      given class declaration, walking over all static members.  */\n \n-  void visit (ClassDeclaration *d)\n+  void visit (ClassDeclaration *d) final override\n   {\n     if (d->semanticRun >= PASS::obj)\n       return;\n@@ -544,7 +544,7 @@ class DeclVisitor : public Visitor\n   /* Write out compiler generated TypeInfo and vtables for the given interface\n      declaration, walking over all static members.  */\n \n-  void visit (InterfaceDeclaration *d)\n+  void visit (InterfaceDeclaration *d) final override\n   {\n     if (d->semanticRun >= PASS::obj)\n       return;\n@@ -587,7 +587,7 @@ class DeclVisitor : public Visitor\n   /* Write out compiler generated TypeInfo and initializer for the given\n      enum declaration.  */\n \n-  void visit (EnumDeclaration *d)\n+  void visit (EnumDeclaration *d) final override\n   {\n     if (d->semanticRun >= PASS::obj)\n       return;\n@@ -626,7 +626,7 @@ class DeclVisitor : public Visitor\n   /* Finish up a variable declaration and push it into the current scope.\n      This can either be a static, local or manifest constant.  */\n \n-  void visit (VarDeclaration *d)\n+  void visit (VarDeclaration *d) final override\n   {\n     if (d->semanticRun >= PASS::obj)\n       return;\n@@ -753,7 +753,7 @@ class DeclVisitor : public Visitor\n   /* Generate and compile a static TypeInfo declaration, but only if it is\n      needed in the current compilation.  */\n \n-  void visit (TypeInfoDeclaration *d)\n+  void visit (TypeInfoDeclaration *d) final override\n   {\n     if (d->semanticRun >= PASS::obj)\n       return;\n@@ -770,7 +770,7 @@ class DeclVisitor : public Visitor\n   /* Finish up a function declaration and compile it all the way\n      down to assembler language output.  */\n \n-  void visit (FuncDeclaration *d)\n+  void visit (FuncDeclaration *d) final override\n   {\n     /* Already generated the function.  */\n     if (d->semanticRun >= PASS::obj)"}, {"sha": "c259e7df6d5a50445aea894b4e3755c0f904d9d8", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442cf0977a2993940a81aac08134fcdde4fb3035/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442cf0977a2993940a81aac08134fcdde4fb3035/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=442cf0977a2993940a81aac08134fcdde4fb3035", "patch": "@@ -2556,7 +2556,7 @@ class ExprVisitor : public Visitor\n   /* Build a tuple literal.  Just an argument list that may have\n      side effects that need evaluation.  */\n \n-  void visit (TupleExp *e)\n+  void visit (TupleExp *e) final override\n   {\n     tree result = NULL_TREE;\n "}, {"sha": "50d44156cca0336f0422c735e0f18366c7f89a9c", "filename": "gcc/d/toir.cc", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442cf0977a2993940a81aac08134fcdde4fb3035/gcc%2Fd%2Ftoir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442cf0977a2993940a81aac08134fcdde4fb3035/gcc%2Fd%2Ftoir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftoir.cc?ref=442cf0977a2993940a81aac08134fcdde4fb3035", "patch": "@@ -534,7 +534,7 @@ class IRVisitor : public Visitor\n \n   /* This should be overridden by each statement class.  */\n \n-  void visit (Statement *)\n+  void visit (Statement *) final override\n   {\n     gcc_unreachable ();\n   }\n@@ -543,13 +543,13 @@ class IRVisitor : public Visitor\n      try/catch/finally.  At this point, this statement is just an empty\n      placeholder.  Maybe the frontend shouldn't leak these.  */\n \n-  void visit (ScopeGuardStatement *)\n+  void visit (ScopeGuardStatement *) final override\n   {\n   }\n \n   /* If statements provide simple conditional execution of statements.  */\n \n-  void visit (IfStatement *s)\n+  void visit (IfStatement *s) final override\n   {\n     this->start_scope (level_cond);\n \n@@ -588,23 +588,23 @@ class IRVisitor : public Visitor\n      here would be the place to do it.  For now, all pragmas are handled\n      by the frontend.  */\n \n-  void visit (PragmaStatement *)\n+  void visit (PragmaStatement *) final override\n   {\n   }\n \n   /* The frontend lowers `while (...)' statements as `for (...)' loops.\n      This visitor is not strictly required other than to enforce that\n      these kinds of statements never reach here.  */\n \n-  void visit (WhileStatement *)\n+  void visit (WhileStatement *) final override\n   {\n     gcc_unreachable ();\n   }\n \n   /* Do while statments implement simple loops.  The body is executed, then\n      the condition is evaluated.  */\n \n-  void visit (DoStatement *s)\n+  void visit (DoStatement *s) final override\n   {\n     tree lbreak = this->push_break_label (s);\n \n@@ -633,7 +633,7 @@ class IRVisitor : public Visitor\n   /* For statements implement loops with initialization, test, and\n      increment clauses.  */\n \n-  void visit (ForStatement *s)\n+  void visit (ForStatement *s) final override\n   {\n     tree lbreak = this->push_break_label (s);\n     this->start_scope (level_loop);\n@@ -674,7 +674,7 @@ class IRVisitor : public Visitor\n      This visitor is not strictly required other than to enforce that\n      these kinds of statements never reach here.  */\n \n-  void visit (ForeachStatement *)\n+  void visit (ForeachStatement *) final override\n   {\n     gcc_unreachable ();\n   }\n@@ -683,15 +683,15 @@ class IRVisitor : public Visitor\n      loops.  This visitor is not strictly required other than to enforce that\n      these kinds of statements never reach here.  */\n \n-  void visit (ForeachRangeStatement *)\n+  void visit (ForeachRangeStatement *) final override\n   {\n     gcc_unreachable ();\n   }\n \n   /* Jump to the associated exit label for the current loop.  If IDENT\n      for the Statement is not null, then the label is user defined.  */\n \n-  void visit (BreakStatement *s)\n+  void visit (BreakStatement *s) final override\n   {\n     if (s->ident)\n       {\n@@ -710,7 +710,7 @@ class IRVisitor : public Visitor\n   /* Jump to the associated continue label for the current loop.  If IDENT\n      for the Statement is not null, then the label is user defined.  */\n \n-  void visit (ContinueStatement *s)\n+  void visit (ContinueStatement *s) final override\n   {\n     if (s->ident)\n       {\n@@ -726,7 +726,7 @@ class IRVisitor : public Visitor\n \n   /* A goto statement jumps to the statement identified by the given label.  */\n \n-  void visit (GotoStatement *s)\n+  void visit (GotoStatement *s) final override\n   {\n     gcc_assert (s->label->statement != NULL);\n     gcc_assert (s->tf == s->label->statement->tf);\n@@ -742,7 +742,7 @@ class IRVisitor : public Visitor\n   /* Statements can be labeled.  A label is an identifier that precedes\n      a statement.  */\n \n-  void visit (LabelStatement *s)\n+  void visit (LabelStatement *s) final override\n   {\n     LabelDsymbol *sym;\n \n@@ -766,7 +766,7 @@ class IRVisitor : public Visitor\n   /* A switch statement goes to one of a collection of case statements\n      depending on the value of the switch expression.  */\n \n-  void visit (SwitchStatement *s)\n+  void visit (SwitchStatement *s) final override\n   {\n     this->start_scope (level_switch);\n     tree lbreak = this->push_break_label (s);\n@@ -855,7 +855,7 @@ class IRVisitor : public Visitor\n \n   /* Declare the case label associated with the current SwitchStatement.  */\n \n-  void visit (CaseStatement *s)\n+  void visit (CaseStatement *s) final override\n   {\n     /* Emit the case label.  */\n     tree label = this->define_label (s);\n@@ -881,7 +881,7 @@ class IRVisitor : public Visitor\n \n   /* Declare the default label associated with the current SwitchStatement.  */\n \n-  void visit (DefaultStatement *s)\n+  void visit (DefaultStatement *s) final override\n   {\n     /* Emit the default case label.  */\n     tree label = this->define_label (s);\n@@ -902,7 +902,7 @@ class IRVisitor : public Visitor\n   /* Implements `goto default' by jumping to the label associated with\n      the DefaultStatement in a switch block.  */\n \n-  void visit (GotoDefaultStatement *s)\n+  void visit (GotoDefaultStatement *s) final override\n   {\n     tree label = this->lookup_label (s->sw->sdefault);\n     this->do_jump (label);\n@@ -911,7 +911,7 @@ class IRVisitor : public Visitor\n   /* Implements `goto case' by jumping to the label associated with the\n      CaseStatement in a switch block.  */\n \n-  void visit (GotoCaseStatement *s)\n+  void visit (GotoCaseStatement *s) final override\n   {\n     tree label = this->lookup_label (s->cs);\n     this->do_jump (label);\n@@ -920,7 +920,7 @@ class IRVisitor : public Visitor\n   /* Throw a SwitchError exception, called when a switch statement has\n      no DefaultStatement, yet none of the cases match.  */\n \n-  void visit (SwitchErrorStatement *s)\n+  void visit (SwitchErrorStatement *s) final override\n   {\n     /* A throw SwitchError statement gets turned into a library call.\n        The call is wrapped in the enclosed expression.  */\n@@ -931,7 +931,7 @@ class IRVisitor : public Visitor\n   /* A return statement exits the current function and supplies its return\n      value, if the return type is not void.  */\n \n-  void visit (ReturnStatement *s)\n+  void visit (ReturnStatement *s) final override\n   {\n     if (s->exp == NULL || s->exp->type->toBasetype ()->ty == TY::Tvoid)\n       {\n@@ -1044,7 +1044,7 @@ class IRVisitor : public Visitor\n \n   /* Evaluate the enclosed expression, and add it to the statement list.  */\n \n-  void visit (ExpStatement *s)\n+  void visit (ExpStatement *s) final override\n   {\n     if (s->exp)\n       {\n@@ -1056,7 +1056,7 @@ class IRVisitor : public Visitor\n \n   /* Evaluate all enclosed statements.  */\n \n-  void visit (CompoundStatement *s)\n+  void visit (CompoundStatement *s) final override\n   {\n     if (s->statements == NULL)\n       return;\n@@ -1074,7 +1074,7 @@ class IRVisitor : public Visitor\n      These are compiled down as a `do ... while (0)', where each unrolled loop\n      is nested inside and given their own continue label to jump to.  */\n \n-  void visit (UnrolledLoopStatement *s)\n+  void visit (UnrolledLoopStatement *s) final override\n   {\n     if (s->statements == NULL)\n       return;\n@@ -1105,7 +1105,7 @@ class IRVisitor : public Visitor\n   /* Start a new scope and visit all nested statements, wrapping\n      them up into a BIND_EXPR at the end of the scope.  */\n \n-  void visit (ScopeStatement *s)\n+  void visit (ScopeStatement *s) final override\n   {\n     if (s->statement == NULL)\n       return;\n@@ -1118,7 +1118,7 @@ class IRVisitor : public Visitor\n   /* A with statement is a way to simplify repeated references to the same\n      object, where the handle is either a class or struct instance.  */\n \n-  void visit (WithStatement *s)\n+  void visit (WithStatement *s) final override\n   {\n     this->start_scope (level_with);\n \n@@ -1143,7 +1143,7 @@ class IRVisitor : public Visitor\n      thrown is a class type, but does not check if it is derived from\n      Object.  Foreign objects are not currently supported at run-time.  */\n \n-  void visit (ThrowStatement *s)\n+  void visit (ThrowStatement *s) final override\n   {\n     ClassDeclaration *cd = s->exp->type->toBasetype ()->isClassHandle ();\n     InterfaceDeclaration *id = cd->isInterfaceDeclaration ();\n@@ -1174,7 +1174,7 @@ class IRVisitor : public Visitor\n      handling generated by the frontend.  This is also used to implement\n      `scope (failure)' statements.  */\n \n-  void visit (TryCatchStatement *s)\n+  void visit (TryCatchStatement *s) final override\n   {\n     this->start_scope (level_try);\n     if (s->_body)\n@@ -1263,7 +1263,7 @@ class IRVisitor : public Visitor\n      handling generated by the frontend.  This is also used to implement\n      `scope (exit)' statements.  */\n \n-  void visit (TryFinallyStatement *s)\n+  void visit (TryFinallyStatement *s) final override\n   {\n     this->start_scope (level_try);\n     if (s->_body)\n@@ -1285,7 +1285,7 @@ class IRVisitor : public Visitor\n      This visitor is not strictly required other than to enforce that\n      these kinds of statements never reach here.  */\n \n-  void visit (SynchronizedStatement *)\n+  void visit (SynchronizedStatement *) final override\n   {\n     gcc_unreachable ();\n   }\n@@ -1294,15 +1294,15 @@ class IRVisitor : public Visitor\n      an assembly parser for each supported target.  Instead we leverage\n      GCC extended assembler using the GccAsmStatement class.  */\n \n-  void visit (AsmStatement *)\n+  void visit (AsmStatement *) final override\n   {\n     sorry (\"D inline assembler statements are not supported in GDC.\");\n   }\n \n   /* Build a GCC extended assembler expression, whose components are\n      an INSN string, some OUTPUTS, some INPUTS, and some CLOBBERS.  */\n \n-  void visit (GccAsmStatement *s)\n+  void visit (GccAsmStatement *s) final override\n   {\n     StringExp *insn = s->insn->toStringExp ();\n     tree outputs = NULL_TREE;\n@@ -1454,7 +1454,7 @@ class IRVisitor : public Visitor\n \n   /* Import symbols from another module.  */\n \n-  void visit (ImportStatement *s)\n+  void visit (ImportStatement *s) final override\n   {\n     if (s->imports == NULL)\n       return;"}, {"sha": "a31762fe27091a0ec048207d978fa1436bf96750", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442cf0977a2993940a81aac08134fcdde4fb3035/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442cf0977a2993940a81aac08134fcdde4fb3035/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=442cf0977a2993940a81aac08134fcdde4fb3035", "patch": "@@ -556,7 +556,7 @@ class TypeInfoVisitor : public Visitor\n \tvoid **__vptr;\n \tvoid *__monitor;  */\n \n-  void visit (TypeInfoDeclaration *)\n+  void visit (TypeInfoDeclaration *) final override\n   {\n     /* The vtable for TypeInfo.  */\n     this->layout_base (Type::dtypeinfo);\n@@ -567,7 +567,7 @@ class TypeInfoVisitor : public Visitor\n \tvoid *__monitor;\n \tTypeInfo base;  */\n \n-  void visit (TypeInfoConstDeclaration *d)\n+  void visit (TypeInfoConstDeclaration *d) final override\n   {\n     Type *tm = d->tinfo->mutableOf ();\n     tm = tm->merge2 ();\n@@ -584,7 +584,7 @@ class TypeInfoVisitor : public Visitor\n \tvoid *__monitor;\n \tTypeInfo base;  */\n \n-  void visit (TypeInfoInvariantDeclaration *d)\n+  void visit (TypeInfoInvariantDeclaration *d) final override\n   {\n     Type *tm = d->tinfo->mutableOf ();\n     tm = tm->merge2 ();\n@@ -601,7 +601,7 @@ class TypeInfoVisitor : public Visitor\n \tvoid *__monitor;\n \tTypeInfo base;  */\n \n-  void visit (TypeInfoSharedDeclaration *d)\n+  void visit (TypeInfoSharedDeclaration *d) final override\n   {\n     Type *tm = d->tinfo->unSharedOf ();\n     tm = tm->merge2 ();\n@@ -618,7 +618,7 @@ class TypeInfoVisitor : public Visitor\n \tvoid *__monitor;\n \tTypeInfo base;  */\n \n-  void visit (TypeInfoWildDeclaration *d)\n+  void visit (TypeInfoWildDeclaration *d) final override\n   {\n     Type *tm = d->tinfo->mutableOf ();\n     tm = tm->merge2 ();\n@@ -637,7 +637,7 @@ class TypeInfoVisitor : public Visitor\n \tstring name;\n \tvoid[] m_init;  */\n \n-  void visit (TypeInfoEnumDeclaration *d)\n+  void visit (TypeInfoEnumDeclaration *d) final override\n   {\n     TypeEnum *ti = d->tinfo->isTypeEnum ();\n     EnumDeclaration *ed = ti->sym;\n@@ -669,7 +669,7 @@ class TypeInfoVisitor : public Visitor\n \tvoid *__monitor;\n \tTypeInfo m_next;  */\n \n-  void visit (TypeInfoPointerDeclaration *d)\n+  void visit (TypeInfoPointerDeclaration *d) final override\n   {\n     TypePointer *ti = d->tinfo->isTypePointer ();\n \n@@ -685,7 +685,7 @@ class TypeInfoVisitor : public Visitor\n \tvoid *__monitor;\n \tTypeInfo value;  */\n \n-  void visit (TypeInfoArrayDeclaration *d)\n+  void visit (TypeInfoArrayDeclaration *d) final override\n   {\n     TypeDArray *ti = d->tinfo->isTypeDArray ();\n \n@@ -702,7 +702,7 @@ class TypeInfoVisitor : public Visitor\n \tTypeInfo value;\n \tsize_t len;  */\n \n-  void visit (TypeInfoStaticArrayDeclaration *d)\n+  void visit (TypeInfoStaticArrayDeclaration *d) final override\n   {\n     TypeSArray *ti = d->tinfo->isTypeSArray ();\n \n@@ -722,7 +722,7 @@ class TypeInfoVisitor : public Visitor\n \tTypeInfo value;\n \tTypeInfo key;  */\n \n-  void visit (TypeInfoAssociativeArrayDeclaration *d)\n+  void visit (TypeInfoAssociativeArrayDeclaration *d) final override\n   {\n     TypeAArray *ti = d->tinfo->isTypeAArray ();\n \n@@ -741,7 +741,7 @@ class TypeInfoVisitor : public Visitor\n \tvoid *__monitor;\n \tTypeInfo base;  */\n \n-  void visit (TypeInfoVectorDeclaration *d)\n+  void visit (TypeInfoVectorDeclaration *d) final override\n   {\n     TypeVector *ti = d->tinfo->isTypeVector ();\n \n@@ -758,7 +758,7 @@ class TypeInfoVisitor : public Visitor\n \tTypeInfo next;\n \tstring deco;  */\n \n-  void visit (TypeInfoFunctionDeclaration *d)\n+  void visit (TypeInfoFunctionDeclaration *d) final override\n   {\n     TypeFunction *ti = d->tinfo->isTypeFunction ();\n     gcc_assert (ti->deco != NULL);\n@@ -779,7 +779,7 @@ class TypeInfoVisitor : public Visitor\n \tTypeInfo next;\n \tstring deco;  */\n \n-  void visit (TypeInfoDelegateDeclaration *d)\n+  void visit (TypeInfoDelegateDeclaration *d) final override\n   {\n     TypeDelegate *ti = d->tinfo->isTypeDelegate ();\n     gcc_assert (ti->deco != NULL);\n@@ -813,7 +813,7 @@ class TypeInfoVisitor : public Visitor\n      Information relating to interfaces, and their vtables are laid out\n      immediately after the named fields, if there is anything to write.  */\n \n-  void visit (TypeInfoClassDeclaration *d)\n+  void visit (TypeInfoClassDeclaration *d) final override\n   {\n     TypeClass *ti = d->tinfo->isTypeClass ();\n     ClassDeclaration *cd = ti->sym;\n@@ -1004,7 +1004,7 @@ class TypeInfoVisitor : public Visitor\n \tvoid *__monitor;\n \tTypeInfo_Class info;  */\n \n-  void visit (TypeInfoInterfaceDeclaration *d)\n+  void visit (TypeInfoInterfaceDeclaration *d) final override\n   {\n     TypeClass *ti = d->tinfo->isTypeClass ();\n \n@@ -1034,7 +1034,7 @@ class TypeInfoVisitor : public Visitor\n \tuint m_align;\n \timmutable(void)* xgetRTInfo;  */\n \n-  void visit (TypeInfoStructDeclaration *d)\n+  void visit (TypeInfoStructDeclaration *d) final override\n   {\n     TypeStruct *ti = d->tinfo->isTypeStruct ();\n     StructDeclaration *sd = ti->sym;\n@@ -1119,7 +1119,7 @@ class TypeInfoVisitor : public Visitor\n \tvoid *__monitor;\n \tTypeInfo[] elements;  */\n \n-  void visit (TypeInfoTupleDeclaration *d)\n+  void visit (TypeInfoTupleDeclaration *d) final override\n   {\n     TypeTuple *ti = d->tinfo->isTypeTuple ();\n "}, {"sha": "b17b15359c8f68f27516df4f96df1c2a7283acbb", "filename": "gcc/d/types.cc", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442cf0977a2993940a81aac08134fcdde4fb3035/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442cf0977a2993940a81aac08134fcdde4fb3035/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=442cf0977a2993940a81aac08134fcdde4fb3035", "patch": "@@ -665,37 +665,37 @@ class TypeVisitor : public Visitor\n \n   /* This should be overridden by each type class.  */\n \n-  void visit (Type *)\n+  void visit (Type *) final override\n   {\n     gcc_unreachable ();\n   }\n \n   /* Type assigned to erroneous expressions or constructs that\n      failed during the semantic stage.  */\n \n-  void visit (TypeError *t)\n+  void visit (TypeError *t) final override\n   {\n     t->ctype = error_mark_node;\n   }\n \n   /* Type assigned to generic nullable types.  */\n \n-  void visit (TypeNull *t)\n+  void visit (TypeNull *t) final override\n   {\n     t->ctype = ptr_type_node;\n   }\n \n   /* Bottom type used for functions that never return.  */\n \n-  void visit (TypeNoreturn *t)\n+  void visit (TypeNoreturn *t) final override\n   {\n     t->ctype = noreturn_type_node;\n     TYPE_NAME (t->ctype) = get_identifier (t->toChars ());\n   }\n \n   /* Basic Data Types.  */\n \n-  void visit (TypeBasic *t)\n+  void visit (TypeBasic *t) final override\n   {\n     /* [type/basic-data-types]\n \n@@ -761,15 +761,15 @@ class TypeVisitor : public Visitor\n \n   /* Build a simple pointer to data type, analogous to C pointers.  */\n \n-  void visit (TypePointer *t)\n+  void visit (TypePointer *t) final override\n   {\n     t->ctype = build_pointer_type (build_ctype (t->next));\n   }\n \n   /* Build a dynamic array type, consisting of a length and a pointer\n      to the array data.  */\n \n-  void visit (TypeDArray *t)\n+  void visit (TypeDArray *t) final override\n   {\n     /* In [abi/arrays], dynamic array layout is:\n \t.length\tarray dimension.\n@@ -787,7 +787,7 @@ class TypeVisitor : public Visitor\n   /* Build a static array type, distinguished from dynamic arrays by\n      having a length fixed at compile-time, analogous to C arrays.  */\n \n-  void visit (TypeSArray *t)\n+  void visit (TypeSArray *t) final override\n   {\n     if (t->dim->isConst () && t->dim->type->isintegral ())\n       {\n@@ -804,7 +804,7 @@ class TypeVisitor : public Visitor\n \n   /* Build a vector type, a fixed array of floating or integer types.  */\n \n-  void visit (TypeVector *t)\n+  void visit (TypeVector *t) final override\n   {\n     int nunits = t->basetype->isTypeSArray ()->dim->toUInteger ();\n     tree inner = build_ctype (t->elementType ());\n@@ -821,7 +821,7 @@ class TypeVisitor : public Visitor\n   /* Build an associative array type, distinguished from arrays by having an\n      index that's not necessarily an integer, and can be sparsely populated.  */\n \n-  void visit (TypeAArray *t)\n+  void visit (TypeAArray *t) final override\n   {\n     /* In [abi/associative-arrays], associative arrays are a struct that only\n        consist of a pointer to an opaque, implementation defined type.  */\n@@ -835,7 +835,7 @@ class TypeVisitor : public Visitor\n   /* Build type for a function declaration, which consists of a return type,\n      and a list of parameter types, and a linkage attribute.  */\n \n-  void visit (TypeFunction *t)\n+  void visit (TypeFunction *t) final override\n   {\n     tree fnparams = NULL_TREE;\n     tree fntype;\n@@ -925,7 +925,7 @@ class TypeVisitor : public Visitor\n      reference and a pointer to a non-static member function, or a pointer\n      to a closure and a pointer to a nested function.  */\n \n-  void visit (TypeDelegate *t)\n+  void visit (TypeDelegate *t) final override\n   {\n     /* In [abi/delegates], delegate layout is:\n \t.ptr\t    context pointer.\n@@ -952,7 +952,7 @@ class TypeVisitor : public Visitor\n   /* Build a named enum type, a distinct value whose values are restrict to\n      a group of constants of the same underlying base type.  */\n \n-  void visit (TypeEnum *t)\n+  void visit (TypeEnum *t) final override\n   {\n     tree basetype = (t->sym->memtype)\n       ? build_ctype (t->sym->memtype) : void_type_node;\n@@ -1067,7 +1067,7 @@ class TypeVisitor : public Visitor\n   /* Build a struct or union type.  Layout should be exactly represented\n      as an equivalent C struct, except for non-POD or nested structs.  */\n \n-  void visit (TypeStruct *t)\n+  void visit (TypeStruct *t) final override\n   {\n     /* Merge types in the back-end if the front-end did not itself do so.  */\n     tree deco = get_identifier (d_mangle_decl (t->sym));\n@@ -1123,7 +1123,7 @@ class TypeVisitor : public Visitor\n   /* Build a class type.  Whereas structs are value types, classes are\n      reference types, with all the object-orientated features.  */\n \n-  void visit (TypeClass *t)\n+  void visit (TypeClass *t) final override\n   {\n     /* Merge types in the back-end if the front-end did not itself do so.  */\n     tree deco = get_identifier (d_mangle_decl (t->sym));"}]}