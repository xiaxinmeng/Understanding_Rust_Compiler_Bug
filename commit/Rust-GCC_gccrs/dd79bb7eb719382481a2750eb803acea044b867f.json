{"sha": "dd79bb7eb719382481a2750eb803acea044b867f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ3OWJiN2ViNzE5MzgyNDgxYTI3NTBlYjgwM2FjZWEwNDRiODY3Zg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2005-06-07T08:18:15Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2005-06-07T08:18:15Z"}, "message": "rtlanal.c (subreg_offset_representable_p): Handle objects with holes.\n\n\t* rtlanal.c (subreg_offset_representable_p): Handle objects\n\twith holes.\n\nFrom-SVN: r100700", "tree": {"sha": "e66ecc876326d432072b4f5ec6681ed9fe84bfde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e66ecc876326d432072b4f5ec6681ed9fe84bfde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd79bb7eb719382481a2750eb803acea044b867f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd79bb7eb719382481a2750eb803acea044b867f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd79bb7eb719382481a2750eb803acea044b867f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd79bb7eb719382481a2750eb803acea044b867f/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd127a751553d5b4a97784a2e6d903415366bcdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd127a751553d5b4a97784a2e6d903415366bcdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd127a751553d5b4a97784a2e6d903415366bcdd"}], "stats": {"total": 101, "additions": 88, "deletions": 13}, "files": [{"sha": "c5d60e8902533d76cf6dbd0b88ed3db3a454db5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd79bb7eb719382481a2750eb803acea044b867f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd79bb7eb719382481a2750eb803acea044b867f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd79bb7eb719382481a2750eb803acea044b867f", "patch": "@@ -1,3 +1,8 @@\n+2005-06-07  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* rtlanal.c (subreg_offset_representable_p): Handle objects\n+\twith holes.\n+\n 2005-06-06  Uros Bizjak  <uros@kss-loka.si>\n \n \t* mode-switching.c (optimize_mode_switching): Fix n_exprs parameter"}, {"sha": "0bdcbbadbcf8344fc40d06551eb24a0dc96b435c", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 83, "deletions": 13, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd79bb7eb719382481a2750eb803acea044b867f/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd79bb7eb719382481a2750eb803acea044b867f/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=dd79bb7eb719382481a2750eb803acea044b867f", "patch": "@@ -3033,13 +3033,37 @@ unsigned int\n subreg_regno_offset (unsigned int xregno, enum machine_mode xmode,\n \t\t     unsigned int offset, enum machine_mode ymode)\n {\n-  int nregs_xmode, nregs_ymode;\n+  int nregs_xmode, nregs_ymode, nregs_xmode_unit_int;\n   int mode_multiple, nregs_multiple;\n   int y_offset;\n+  enum machine_mode xmode_unit, xmode_unit_int;\n \n   gcc_assert (xregno < FIRST_PSEUDO_REGISTER);\n \n-  nregs_xmode = hard_regno_nregs[xregno][xmode];\n+  if (GET_MODE_INNER (xmode) == VOIDmode)\n+    xmode_unit = xmode;\n+  else\n+    xmode_unit = GET_MODE_INNER (xmode);\n+  \n+  if (FLOAT_MODE_P (xmode_unit))\n+    {\n+      xmode_unit_int = int_mode_for_mode (xmode_unit);\n+      if (xmode_unit_int == BLKmode)\n+\t/* It's probably bad to be here; a port should have an integer mode\n+\t   that's the same size as anything of which it takes a SUBREG.  */\n+\txmode_unit_int = xmode_unit;\n+    }\n+  else\n+    xmode_unit_int = xmode_unit;\n+\n+  nregs_xmode_unit_int = hard_regno_nregs[xregno][xmode_unit_int];\n+\n+  /* Adjust nregs_xmode to allow for 'holes'.  */\n+  if (nregs_xmode_unit_int != hard_regno_nregs[xregno][xmode_unit])\n+    nregs_xmode = nregs_xmode_unit_int * GET_MODE_NUNITS (xmode);\n+  else\n+    nregs_xmode = hard_regno_nregs[xregno][xmode];\n+    \n   nregs_ymode = hard_regno_nregs[xregno][ymode];\n \n   /* If this is a big endian paradoxical subreg, which uses more actual\n@@ -3054,7 +3078,7 @@ subreg_regno_offset (unsigned int xregno, enum machine_mode xmode,\n   if (offset == 0 || nregs_xmode == nregs_ymode)\n     return 0;\n \n-  /* size of ymode must not be greater than the size of xmode.  */\n+  /* Size of ymode must not be greater than the size of xmode.  */\n   mode_multiple = GET_MODE_SIZE (xmode) / GET_MODE_SIZE (ymode);\n   gcc_assert (mode_multiple != 0);\n \n@@ -3069,36 +3093,82 @@ subreg_regno_offset (unsigned int xregno, enum machine_mode xmode,\n    xmode  - The mode of xregno.\n    offset - The byte offset.\n    ymode  - The mode of a top level SUBREG (or what may become one).\n-   RETURN - The regno offset which would be used.  */\n+   RETURN - Whether the offset is representable.  */\n bool\n subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n \t\t\t       unsigned int offset, enum machine_mode ymode)\n {\n-  int nregs_xmode, nregs_ymode;\n+  int nregs_xmode, nregs_ymode, nregs_xmode_unit, nregs_xmode_unit_int;\n   int mode_multiple, nregs_multiple;\n   int y_offset;\n+  enum machine_mode xmode_unit, xmode_unit_int;\n \n   gcc_assert (xregno < FIRST_PSEUDO_REGISTER);\n \n-  nregs_xmode = hard_regno_nregs[xregno][xmode];\n+  if (GET_MODE_INNER (xmode) == VOIDmode)\n+    xmode_unit = xmode;\n+  else\n+    xmode_unit = GET_MODE_INNER (xmode);\n+  \n+  if (FLOAT_MODE_P (xmode_unit))\n+    {\n+      xmode_unit_int = int_mode_for_mode (xmode_unit);\n+      if (xmode_unit_int == BLKmode)\n+\t/* It's probably bad to be here; a port should have an integer mode\n+\t   that's the same size as anything of which it takes a SUBREG.  */\n+\txmode_unit_int = xmode_unit;\n+    }\n+  else\n+    xmode_unit_int = xmode_unit;\n+\n+  nregs_xmode_unit = hard_regno_nregs[xregno][xmode_unit];\n+  nregs_xmode_unit_int = hard_regno_nregs[xregno][xmode_unit_int];\n+\n+  /* If there are holes in a non-scalar mode in registers, we expect\n+     that it is made up of its units concatenated together.  */\n+  if (nregs_xmode_unit != nregs_xmode_unit_int)\n+    {\n+      gcc_assert (nregs_xmode_unit * GET_MODE_NUNITS (xmode)\n+\t\t  == hard_regno_nregs[xregno][xmode]);\n+\n+      /* You can only ask for a SUBREG of a value with holes in the middle\n+\t if you don't cross the holes.  (Such a SUBREG should be done by\n+\t picking a different register class, or doing it in memory if\n+\t necessary.)  An example of a value with holes is XCmode on 32-bit\n+\t x86 with -m128bit-long-double; it's represented in 6 32-bit registers,\n+\t 3 for each part, but in memory it's two 128-bit parts.  \n+\t Padding is assumed to be at the end (not necessarily the 'high part')\n+\t of each unit.  */\n+      if (nregs_xmode_unit != nregs_xmode_unit_int\n+\t  && (offset / GET_MODE_SIZE (xmode_unit_int) + 1 \n+\t      < GET_MODE_NUNITS (xmode))\n+\t  && (offset / GET_MODE_SIZE (xmode_unit_int) \n+\t      != ((offset + GET_MODE_SIZE (ymode) - 1)\n+\t\t  / GET_MODE_SIZE (xmode_unit_int))))\n+\treturn false;\n+\n+      nregs_xmode = nregs_xmode_unit_int * GET_MODE_NUNITS (xmode);\n+    }\n+  else\n+    nregs_xmode = hard_regno_nregs[xregno][xmode];\n+  \n   nregs_ymode = hard_regno_nregs[xregno][ymode];\n \n-  /* Paradoxical subregs are always valid.  */\n+  /* Paradoxical subregs are otherwise valid.  */\n   if (offset == 0\n       && nregs_ymode > nregs_xmode\n       && (GET_MODE_SIZE (ymode) > UNITS_PER_WORD\n \t  ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n     return true;\n \n-  /* Lowpart subregs are always valid.  */\n+  /* Lowpart subregs are otherwise valid.  */\n   if (offset == subreg_lowpart_offset (ymode, xmode))\n     return true;\n \n-  /* This should always pass, otherwise we don't know how to verify the\n-     constraint.  These conditions may be relaxed but subreg_offset would\n-     need to be redesigned.  */\n+  /* This should always pass, otherwise we don't know how to verify\n+     the constraint.  These conditions may be relaxed but\n+     subreg_regno_offset would need to be redesigned.  */\n   gcc_assert ((GET_MODE_SIZE (xmode) % GET_MODE_SIZE (ymode)) == 0);\n-  gcc_assert ((GET_MODE_SIZE (ymode) % nregs_ymode) == 0);\n   gcc_assert ((nregs_xmode % nregs_ymode) == 0);\n \n   /* The XMODE value can be seen as a vector of NREGS_XMODE\n@@ -3109,7 +3179,7 @@ subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n \t\t\t\t\t\t  / nregs_xmode,\n \t\t\t\t\t\t  MODE_INT, 0));\n \n-  /* size of ymode must not be greater than the size of xmode.  */\n+  /* Size of ymode must not be greater than the size of xmode.  */\n   mode_multiple = GET_MODE_SIZE (xmode) / GET_MODE_SIZE (ymode);\n   gcc_assert (mode_multiple != 0);\n "}]}