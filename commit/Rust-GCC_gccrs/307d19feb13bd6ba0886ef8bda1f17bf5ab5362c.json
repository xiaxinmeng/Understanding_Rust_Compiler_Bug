{"sha": "307d19feb13bd6ba0886ef8bda1f17bf5ab5362c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA3ZDE5ZmViMTNiZDZiYTA4ODZlZjhiZGExZjE3YmY1YWI1MzYyYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2006-01-19T16:30:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2006-01-19T16:30:59Z"}, "message": "tree-vrp.c (extract_range_from_assert): Refine the result range if the variable referenced by the ASSERT_EXPR has a...\n\n\n\t* tree-vrp.c (extract_range_from_assert): Refine the result range\n\tif the variable referenced by the ASSERT_EXPR has a range and\n\teither the tentative result range or the previous range is a \n\tVR_ANTI_RANGE.\n\n\t* gcc.dg/tree-ssa/vrp25.c: New test.\n\nFrom-SVN: r109968", "tree": {"sha": "0314e41a5ca217936798a6d6277c096007ed8adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0314e41a5ca217936798a6d6277c096007ed8adf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c/comments", "author": null, "committer": null, "parents": [{"sha": "2e6f91e35ad631b4dc460990919282f4d20c84dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e6f91e35ad631b4dc460990919282f4d20c84dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e6f91e35ad631b4dc460990919282f4d20c84dc"}], "stats": {"total": 153, "additions": 153, "deletions": 0}, "files": [{"sha": "8da8006782b8b7262b149171084bcd790a3137de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=307d19feb13bd6ba0886ef8bda1f17bf5ab5362c", "patch": "@@ -1,3 +1,10 @@\n+2006-01-19  Jeff Law  <law@redhat.com>\n+\n+\t* tree-vrp.c (extract_range_from_assert): Refine the result range\n+\tif the variable referenced by the ASSERT_EXPR has a range and\n+\teither the tentative result range or the previous range is a \n+\tVR_ANTI_RANGE.\n+\n 2006-01-19  Richard Sandiford  <richard@codesourcery.com>\n \n \t* c-decl.c (add_flexible_array_elts_to_size): Simplify vector accesses."}, {"sha": "ab86c53c028597459ce53396801151c71f4d5cf2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=307d19feb13bd6ba0886ef8bda1f17bf5ab5362c", "patch": "@@ -1,3 +1,7 @@\n+2006-01-18  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/vrp25.c: New test.\n+\n 2006-01-19  Richard Sandiford  <richard@codesourcery.com>\n \n \t* gcc.dg/pr25805.c: Fix misapplied patch."}, {"sha": "52f9ea2fea54b9c5dcd2137ea4aa7d16fb014112", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp25.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp25.c?ref=307d19feb13bd6ba0886ef8bda1f17bf5ab5362c", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp-details\" } */\n+\n+extern void abort ();\n+int tree_code_length[100];\n+\n+blah (int code1)\n+{\n+  unsigned char D18670;\n+\n+  if (code1 != 53) goto L0; else goto L1;\n+\n+L0:\n+  abort ();\n+\n+L1:\n+  D18670 = tree_code_length[53];\n+  if (D18670 <= 1) goto L2; else goto L3;\n+\n+L2:\n+  abort ();\n+\n+L3:\n+  if (D18670 == 2) goto L4; else goto L5;\n+\n+L4:\n+  abort ();\n+\n+L5:\n+  arf ();\n+  if (code1 != 53) goto L6; else goto L7;\n+\n+L6:\n+  abort ();\n+\n+L7:\n+  if (D18670 <= 2) goto L8; else goto L9;\n+\n+L8:\n+  abort ();\n+\n+L9:\n+  return;\n+\n+}\n+\n+/* The second test of (code1 != 53) and the test (D18670 <= 2) are\n+   both totally subsumed by earlier tests and thus should be folded\n+   away using VRP.  */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate\" 2 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+"}, {"sha": "c4a921c50a9aea4c505b9fb2ca8961d5a3c31e3f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=307d19feb13bd6ba0886ef8bda1f17bf5ab5362c", "patch": "@@ -1048,6 +1048,96 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n       if (compare_values (var_vr->min, vr_p->min) == 0\n \t  && compare_values (var_vr->max, vr_p->max) == 0)\n \tset_value_range_to_varying (vr_p);\n+      else\n+\t{\n+\t  tree min, max, anti_min, anti_max, real_min, real_max;\n+\n+\t  /* We want to compute the logical AND of the two ranges;\n+\t     there are three cases to consider.\n+\n+\n+\t     1. The VR_ANTI_RANGE range is competely within the \n+\t\tVR_RANGE and the endpoints of the ranges are\n+\t\tdifferent.  In that case the resulting range\n+\t\tshould be the VR_ANTI_RANGE.\n+\n+\t     2. The VR_ANTI_RANGE is completely disjoint from\n+\t\tthe VR_RANGE.  In this case the resulting range\n+\t\tshould be the VR_RANGE.\n+\n+\t     3. There is some overlap between the VR_ANTI_RANGE\n+\t\tand the VR_RANGE.\n+\n+\t\t3a. If the high limit of the VR_ANTI_RANGE resides\n+\t\t    within the VR_RANGE, then the result is a new\n+\t\t    VR_RANGE starting at the high limit of the\n+\t\t    the VR_ANTI_RANGE + 1 and extending to the\n+\t\t    high limit of the original VR_RANGE.\n+\n+\t\t3b. If the low limit of the VR_ANTI_RANGE resides\n+\t\t    within the VR_RANGE, then the result is a new\n+\t\t    VR_RANGE starting at the low limit of the original\n+\t\t    VR_RANGE and extending to the low limit of the\n+\t\t    VR_ANTI_RANGE - 1.  */\n+\t  if (vr_p->type == VR_ANTI_RANGE)\n+\t    {\n+\t      anti_min = vr_p->min;\n+\t      anti_max = vr_p->max;\n+\t      real_min = var_vr->min;\n+\t      real_max = var_vr->max;\n+\t    }\n+\t  else\n+\t    {\n+\t      anti_min = var_vr->min;\n+\t      anti_max = var_vr->max;\n+\t      real_min = vr_p->min;\n+\t      real_max = vr_p->max;\n+\t    }\n+\n+\n+\t  /* Case 1, VR_ANTI_RANGE completely within VR_RANGE,\n+\t     not including any endpoints.  */\n+\t  if (compare_values (anti_max, real_max) == -1\n+\t      && compare_values (anti_min, real_min) == 1)\n+\t    {\n+\t      set_value_range (vr_p, VR_ANTI_RANGE, anti_min,\n+\t\t\t       anti_max, vr_p->equiv);\n+\t    }\n+\t  /* Case 2, VR_ANTI_RANGE completely disjoint from\n+\t     VR_RANGE.  */\n+\t  else if (compare_values (anti_min, real_max) == 1\n+\t\t   || compare_values (anti_max, real_min) == -1)\n+\t    {\n+\t      set_value_range (vr_p, VR_RANGE, real_min,\n+\t\t\t       real_max, vr_p->equiv);\n+\t    }\n+\t  /* Case 3a, the anti-range extends into the low\n+\t     part of the real range.  Thus creating a new\n+\t     low for the real reange.  */\n+\t  else if ((compare_values (anti_max, real_min) == 1\n+\t\t    || compare_values (anti_max, real_min) == 0)\n+\t\t   && compare_values (anti_max, real_max) == -1)\n+\t    {\n+\t      min = fold_build2 (PLUS_EXPR, TREE_TYPE (var_vr->min),\n+\t\t\t\t anti_max,\n+\t\t\t\t build_int_cst (TREE_TYPE (var_vr->min), 1));\n+\t      max = real_max;\n+\t      set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n+\t    }\n+\t  /* Case 3b, the anti-range extends into the high\n+\t     part of the real range.  Thus creating a new\n+\t     higher for the real reange.  */\n+\t  else if (compare_values (anti_min, real_min) == 1\n+\t\t   && (compare_values (anti_min, real_max) == -1\n+\t\t       || compare_values (anti_min, real_max) == 0))\n+\t    {\n+\t      max = fold_build2 (MINUS_EXPR, TREE_TYPE (var_vr->min),\n+\t\t\t\t anti_min,\n+\t\t\t\t build_int_cst (TREE_TYPE (var_vr->min), 1));\n+\t      min = real_min;\n+\t      set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n+\t    }\n+\t}\n     }\n \n   /* Remove names from the equivalence set that have ranges"}]}