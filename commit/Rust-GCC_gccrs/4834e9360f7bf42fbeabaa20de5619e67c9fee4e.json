{"sha": "4834e9360f7bf42fbeabaa20de5619e67c9fee4e", "node_id": "C_kwDOANBUbNoAKDQ4MzRlOTM2MGY3YmY0MmZiZWFiYWEyMGRlNTYxOWU2N2M5ZmVlNGU", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:33:05Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:57:56Z"}, "message": "ipa: Better way of applying both IPA-CP and IPA-SRA (PR 103227)\n\nThis is basically a better fix for PR 103227.  The one currently in\nuse, rushed in late at stage3, which means that IPA-CP transformation\nsimply does a replacement of default-definition of IPA-SRA-created\nscalar parameters with a constant, meant that IPA-SRA actually often\nled to creation of a bunch of unused parameters, which was rather\nironic and sub-optimal.\n\nThis patch rips that old way out and makes sure the clash is resolved\nat clone-materialization time.  What happens is that:\n\n1) IPA-SRA IPA analysis (decision) stage recognizes the clash and does\n   not create a param adjustment entry for such a scalar component.\n\n2) Clone materialization code checks the IPA-CP transformation\n   summary and when it realizes that it is removing a parameter that\n   is a base for a discovered IPA-CP aggregate constant, and:\n\n   a) the value is passed by reference, it internally records that any\n      load of the value is replaced directly with the known constant\n      value.  IPA-SRA will not attempt to split values passed by\n      reference when there is a write to it so we know such a load\n      won't be on a a LHS.\n\n   b) the value is passed by value, there can be stores to the\n      corresponding bit of the aggregate and so all accesses are\n      replaced with a new decl and an assignment of the constant to\n      this decl is generated at the beginning of the function.\n\nThe new testcase contains an xfail as the patch does not fix PR 107640\nbut it is one that ICEs when one is not careful about remapping\nindices of parameters, so I'd like to have it in testsuite/gcc.gd/ipa/\neven now.\n\nI don't think that PR 107640 should be attempted through\nipa-param-manipulation replacements because the information is not\nreally there any more and we'd either need to do the replacements\nearlier or dig deep into the clone parent info.  Instead, we should\nrecord somewhere that at the beginning of the function the bits of the\nglobal decl have known values and use that in the value numbering.\nThat way we could one day encode also known constants in globals that\ndo not come through parameters.\n\ngcc/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103227\n\t* ipa-param-manipulation.h (class ipa_param_adjustments): Removed\n\tmember function get_updated_index_or_split.\n\t(class ipa_param_body_adjustments): New overload of\n\tregister_replacement, new member function append_init_stmts, new\n\tmember m_split_agg_csts_inits.\n\t* ipa-param-manipulation.cc: Include ipa-prop.h.\n\t(ipa_param_adjustments::get_updated_index_or_split): Removed.\n\t(ipa_param_body_adjustments::register_replacement): New overload, use\n\tit from the older one.\n\t(ipa_param_body_adjustments::common_initialization): Added the\n\tcapability to create replacements for conflicting IPA-CP discovered\n\tconstants.\n\t(ipa_param_body_adjustments::ipa_param_body_adjustments): Construct\n\tthe new member.\n\t(ipa_param_body_adjustments::append_init_stmts): New function.\n\t* ipa-sra.cc: Include ipa-prop.h.\n\t(push_param_adjustments_for_index): Require IPA-CP transformation\n\tsummary as a parameter, do not create replacements which are known to\n\thave constant values.\n\t(process_isra_node_results): Find and pass to the above function the\n\tIPA-CP transformation summary.\n\t* ipa-prop.cc (adjust_agg_replacement_values): Remove the\n\tfunctionality replacing IPA-SRA created scalar parameters with\n\tconstants.  Simplify, do not require parameter descriptors, do not\n\treturn anything.\n\t(ipcp_transform_function): Simplify now that\n\tadjust_agg_replacement_values does not change cfg.  Move definition\n\tand initialization of descriptors lower.\n\t* tree-inline.cc (tree_function_versioning): Call append_init_stmts of\n\tparam_body_adjs, if there are any.\n\ngcc/testsuite/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103227\n\tPR ipa/107640\n\t* gcc.dg/ipa/pr107640-2.c: New test.", "tree": {"sha": "6bb304e99178459067145b3d893080baf76f5cb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bb304e99178459067145b3d893080baf76f5cb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4834e9360f7bf42fbeabaa20de5619e67c9fee4e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmOZEYQACgkQv2PBvD+k\nNUBVmQ/+OhrjTBWKP8JGuGBytR4WmmVFoEZnnshCjWCabsvXd7X9ImOd34vxYTlf\nLVno0aPGKAlErIQzvkd1R2VnDqiDazyRCuXfabd1FXUL9/cnphqPuZSwlaUYXlPD\nrqauY7oit7ORSDyZ9Cj1oxMzNnScabdlItAMGD9civWeJzBo7dQwxsdxkYXCGgex\nG1o+L1Dt4L/c4Eq04+6Newzt5qsuz+WMI4VzQ21IMq745eaz+/aFqhAr28xxJVJc\n2qNzL6fEx6nVre6AyyVLhIP1rRtM2byTFI8iH/14Yefg+cKxJf7YxIjyNdhjwg8G\n+QT7RXZYanupkSDuNsgbl9O985hkBDGWquGtiJ7vTucpPfwAMICHr6YDstTCzmoV\nXdzCI02evDsrZDejIfXm2ANYnYnl7N4h+aAGQX8ls5TQ+n5iuykxVbdXbwep/Py/\n0CZDWGfYPNzpcxDP8UPf9BaZkzm6aT5kY/EVJ8lx4ChmF0bqBh9LcHjYlIYB8rKr\nWYq9sZTx0vhQhqRXuJw9DQ/xsOocYZajPe2jJfnqtiumdH5mE0fWtwtdgX83u227\n4jEIaHjA6txy6tPsFAikkcb4wkfwMi8Mq5s77Aqe2LJ5OFykL5DihI4YxVL76qrN\n3Wf47dyihrPq4KahEAKFciWvAhNjDo32j79bhm/VIk72UYudhz0=\n=Gtjt\n-----END PGP SIGNATURE-----", "payload": "tree 6bb304e99178459067145b3d893080baf76f5cb4\nparent 7450b25566b7a738edff6f554d97ba6e3dd95ac9\nauthor Martin Jambor <mjambor@suse.cz> 1670974385 +0100\ncommitter Martin Jambor <mjambor@suse.cz> 1670975876 +0100\n\nipa: Better way of applying both IPA-CP and IPA-SRA (PR 103227)\n\nThis is basically a better fix for PR 103227.  The one currently in\nuse, rushed in late at stage3, which means that IPA-CP transformation\nsimply does a replacement of default-definition of IPA-SRA-created\nscalar parameters with a constant, meant that IPA-SRA actually often\nled to creation of a bunch of unused parameters, which was rather\nironic and sub-optimal.\n\nThis patch rips that old way out and makes sure the clash is resolved\nat clone-materialization time.  What happens is that:\n\n1) IPA-SRA IPA analysis (decision) stage recognizes the clash and does\n   not create a param adjustment entry for such a scalar component.\n\n2) Clone materialization code checks the IPA-CP transformation\n   summary and when it realizes that it is removing a parameter that\n   is a base for a discovered IPA-CP aggregate constant, and:\n\n   a) the value is passed by reference, it internally records that any\n      load of the value is replaced directly with the known constant\n      value.  IPA-SRA will not attempt to split values passed by\n      reference when there is a write to it so we know such a load\n      won't be on a a LHS.\n\n   b) the value is passed by value, there can be stores to the\n      corresponding bit of the aggregate and so all accesses are\n      replaced with a new decl and an assignment of the constant to\n      this decl is generated at the beginning of the function.\n\nThe new testcase contains an xfail as the patch does not fix PR 107640\nbut it is one that ICEs when one is not careful about remapping\nindices of parameters, so I'd like to have it in testsuite/gcc.gd/ipa/\neven now.\n\nI don't think that PR 107640 should be attempted through\nipa-param-manipulation replacements because the information is not\nreally there any more and we'd either need to do the replacements\nearlier or dig deep into the clone parent info.  Instead, we should\nrecord somewhere that at the beginning of the function the bits of the\nglobal decl have known values and use that in the value numbering.\nThat way we could one day encode also known constants in globals that\ndo not come through parameters.\n\ngcc/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103227\n\t* ipa-param-manipulation.h (class ipa_param_adjustments): Removed\n\tmember function get_updated_index_or_split.\n\t(class ipa_param_body_adjustments): New overload of\n\tregister_replacement, new member function append_init_stmts, new\n\tmember m_split_agg_csts_inits.\n\t* ipa-param-manipulation.cc: Include ipa-prop.h.\n\t(ipa_param_adjustments::get_updated_index_or_split): Removed.\n\t(ipa_param_body_adjustments::register_replacement): New overload, use\n\tit from the older one.\n\t(ipa_param_body_adjustments::common_initialization): Added the\n\tcapability to create replacements for conflicting IPA-CP discovered\n\tconstants.\n\t(ipa_param_body_adjustments::ipa_param_body_adjustments): Construct\n\tthe new member.\n\t(ipa_param_body_adjustments::append_init_stmts): New function.\n\t* ipa-sra.cc: Include ipa-prop.h.\n\t(push_param_adjustments_for_index): Require IPA-CP transformation\n\tsummary as a parameter, do not create replacements which are known to\n\thave constant values.\n\t(process_isra_node_results): Find and pass to the above function the\n\tIPA-CP transformation summary.\n\t* ipa-prop.cc (adjust_agg_replacement_values): Remove the\n\tfunctionality replacing IPA-SRA created scalar parameters with\n\tconstants.  Simplify, do not require parameter descriptors, do not\n\treturn anything.\n\t(ipcp_transform_function): Simplify now that\n\tadjust_agg_replacement_values does not change cfg.  Move definition\n\tand initialization of descriptors lower.\n\t* tree-inline.cc (tree_function_versioning): Call append_init_stmts of\n\tparam_body_adjs, if there are any.\n\ngcc/testsuite/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103227\n\tPR ipa/107640\n\t* gcc.dg/ipa/pr107640-2.c: New test.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4834e9360f7bf42fbeabaa20de5619e67c9fee4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4834e9360f7bf42fbeabaa20de5619e67c9fee4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7450b25566b7a738edff6f554d97ba6e3dd95ac9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7450b25566b7a738edff6f554d97ba6e3dd95ac9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7450b25566b7a738edff6f554d97ba6e3dd95ac9"}], "stats": {"total": 316, "additions": 205, "deletions": 111}, "files": [{"sha": "e92cfc0b6d53358fecb6f5b749fb4b1c303835c7", "filename": "gcc/ipa-param-manipulation.cc", "status": "modified", "additions": 95, "deletions": 54, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Fipa-param-manipulation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Fipa-param-manipulation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.cc?ref=4834e9360f7bf42fbeabaa20de5619e67c9fee4e", "patch": "@@ -46,7 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-phinodes.h\"\n #include \"cfgexpand.h\"\n #include \"attribs.h\"\n-\n+#include \"ipa-prop.h\"\n \n /* Actual prefixes of different newly synthetized parameters.  Keep in sync\n    with IPA_PARAM_PREFIX_* defines.  */\n@@ -449,39 +449,6 @@ ipa_param_adjustments::get_updated_indices (vec<int> *new_indices)\n     }\n }\n \n-/* If a parameter with original INDEX has survived intact, return its new\n-   index.  Otherwise return -1.  In that case, if it has been split and there\n-   is a new parameter representing a portion at unit OFFSET for which a value\n-   of a TYPE can be substituted, store its new index into SPLIT_INDEX,\n-   otherwise store -1 there.  */\n-int\n-ipa_param_adjustments::get_updated_index_or_split (int index,\n-\t\t\t\t\t\t   unsigned unit_offset,\n-\t\t\t\t\t\t   tree type, int *split_index)\n-{\n-  unsigned adj_len = vec_safe_length (m_adj_params);\n-  for (unsigned i = 0; i < adj_len ; i++)\n-    {\n-      ipa_adjusted_param *apm = &(*m_adj_params)[i];\n-      if (apm->base_index != index)\n-\tcontinue;\n-      if (apm->op == IPA_PARAM_OP_COPY)\n-\treturn i;\n-      if (apm->op == IPA_PARAM_OP_SPLIT\n-\t  && apm->unit_offset == unit_offset)\n-\t{\n-\t  if (useless_type_conversion_p (apm->type, type))\n-\t    *split_index = i;\n-\t  else\n-\t    *split_index = -1;\n-\t  return -1;\n-\t}\n-    }\n-\n-  *split_index = -1;\n-  return -1;\n-}\n-\n /* Return the original index for the given new parameter index.  Return a\n    negative number if not available.  */\n \n@@ -1020,6 +987,21 @@ ipa_param_adjustments::debug ()\n   dump (stderr);\n }\n \n+/* Register a REPLACEMENT for accesses to BASE at UNIT_OFFSET.  */\n+\n+void\n+ipa_param_body_adjustments::register_replacement (tree base,\n+\t\t\t\t\t\t  unsigned unit_offset,\n+\t\t\t\t\t\t  tree replacement)\n+{\n+  ipa_param_body_replacement psr;\n+  psr.base = base;\n+  psr.repl = replacement;\n+  psr.dummy = NULL_TREE;\n+  psr.unit_offset = unit_offset;\n+  m_replacements.safe_push (psr);\n+}\n+\n /* Register that REPLACEMENT should replace parameter described in APM.  */\n \n void\n@@ -1029,12 +1011,8 @@ ipa_param_body_adjustments::register_replacement (ipa_adjusted_param *apm,\n   gcc_checking_assert (apm->op == IPA_PARAM_OP_SPLIT\n \t\t       || apm->op == IPA_PARAM_OP_NEW);\n   gcc_checking_assert (!apm->prev_clone_adjustment);\n-  ipa_param_body_replacement psr;\n-  psr.base = m_oparms[apm->prev_clone_index];\n-  psr.repl = replacement;\n-  psr.dummy = NULL_TREE;\n-  psr.unit_offset = apm->unit_offset;\n-  m_replacements.safe_push (psr);\n+  register_replacement (m_oparms[apm->prev_clone_index], apm->unit_offset,\n+\t\t\treplacement);\n }\n \n /* Copy or not, as appropriate given m_id and decl context, a pre-existing\n@@ -1386,23 +1364,73 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n \tgcc_unreachable ();\n     }\n \n-  if (tree_map)\n+  auto_vec <int, 16> index_mapping;\n+  bool need_remap = false;\n+  if (m_id)\n     {\n-      /* Do not treat parameters which were replaced with a constant as\n-\t completely vanished.  */\n-      auto_vec <int, 16> index_mapping;\n-      bool need_remap = false;\n+      clone_info *cinfo = clone_info::get (m_id->src_node);\n+      if (cinfo && cinfo->param_adjustments)\n+\t{\n+\t  cinfo->param_adjustments->get_updated_indices (&index_mapping);\n+\t  need_remap = true;\n+\t}\n \n-      if (m_id)\n+      if (ipcp_transformation *ipcp_ts\n+\t  = ipcp_get_transformation_summary (m_id->src_node))\n \t{\n-\t  clone_info *cinfo = clone_info::get (m_id->src_node);\n-\t  if (cinfo && cinfo->param_adjustments)\n+\t  for (const ipa_argagg_value &av : ipcp_ts->m_agg_values)\n \t    {\n-\t      cinfo->param_adjustments->get_updated_indices (&index_mapping);\n-\t      need_remap = true;\n+\t      int parm_num = av.index;\n+\n+\t      if (need_remap)\n+\t\t{\n+\t\t  /* FIXME: We cannot handle the situation when IPA-CP\n+\t\t     identified that a parameter is a pointer to a global\n+\t\t     variable and at the same time the variable has some known\n+\t\t     constant contents (PR 107640).  The best place to make\n+\t\t     sure we don't drop such constants on the floor probably is\n+\t\t     not here, but we have to make sure that it does not\n+\t\t     confuse the remapping.  */\n+\t\t  if (parm_num >= (int) index_mapping.length ())\n+\t\t    continue;\n+\t\t  parm_num = index_mapping[parm_num];\n+\t\t  if (parm_num < 0)\n+\t\t    continue;\n+\t\t}\n+\n+\t      if (!kept[parm_num])\n+\t\t{\n+\t\t  /* IPA-CP has detected an aggregate constant in a parameter\n+\t\t     that will not be kept, which means that IPA-SRA would have\n+\t\t     split it if there wasn't a constant.  Because we are about\n+\t\t     to remove the original, this is the last chance where we\n+\t\t     can substitute the uses with a constant (for values passed\n+\t\t     by reference) or do the split but initialize the\n+\t\t     replacement with a constant (for split aggregates passed\n+\t\t     by value).  */\n+\n+\t\t  tree repl;\n+\t\t  if (av.by_ref)\n+\t\t    repl = av.value;\n+\t\t  else\n+\t\t    {\n+\t\t      repl = create_tmp_var (TREE_TYPE (av.value),\n+\t\t\t\t\t     \"removed_ipa_cp\");\n+\t\t      gimple *init_stmt = gimple_build_assign (repl, av.value);\n+\t\t      m_split_agg_csts_inits.safe_push (init_stmt);\n+\t\t    }\n+\t\t  register_replacement (m_oparms[parm_num], av.unit_offset,\n+\t\t\t\t\trepl);\n+\t\t  split[parm_num] = true;\n+\t\t}\n \t    }\n \t}\n+    }\n \n+  if (tree_map)\n+    {\n+      /* Do not treat parameters which were replaced with a constant as\n+\t completely vanished.  */\n       for (unsigned i = 0; i < tree_map->length (); i++)\n \t{\n \t  int parm_num = (*tree_map)[i]->parm_num;\n@@ -1473,8 +1501,9 @@ ::ipa_param_body_adjustments (vec<ipa_adjusted_param, va_gc> *adj_params,\n   : m_adj_params (adj_params), m_adjustments (NULL), m_reset_debug_decls (),\n     m_dead_stmts (), m_dead_ssas (), m_dead_ssa_debug_equiv (),\n     m_dead_stmt_debug_equiv (), m_fndecl (fndecl), m_id (NULL), m_oparms (),\n-    m_new_decls (), m_new_types (), m_replacements (), m_removed_decls (),\n-    m_removed_map (), m_method2func (false)\n+    m_new_decls (), m_new_types (), m_replacements (),\n+    m_split_agg_csts_inits (), m_removed_decls (), m_removed_map (),\n+    m_method2func (false)\n {\n   common_initialization (fndecl, NULL, NULL);\n }\n@@ -1491,7 +1520,8 @@ ::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n     m_reset_debug_decls (), m_dead_stmts (), m_dead_ssas (),\n     m_dead_ssa_debug_equiv (), m_dead_stmt_debug_equiv (), m_fndecl (fndecl),\n     m_id (NULL), m_oparms (), m_new_decls (), m_new_types (), m_replacements (),\n-    m_removed_decls (), m_removed_map (), m_method2func (false)\n+    m_split_agg_csts_inits (), m_removed_decls (), m_removed_map (),\n+    m_method2func (false)\n {\n   common_initialization (fndecl, NULL, NULL);\n }\n@@ -1514,7 +1544,8 @@ ::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n     m_reset_debug_decls (), m_dead_stmts (), m_dead_ssas (),\n     m_dead_ssa_debug_equiv (), m_dead_stmt_debug_equiv (), m_fndecl (fndecl),\n     m_id (id), m_oparms (), m_new_decls (), m_new_types (), m_replacements (),\n-    m_removed_decls (), m_removed_map (), m_method2func (false)\n+    m_split_agg_csts_inits (), m_removed_decls (), m_removed_map (),\n+    m_method2func (false)\n {\n   common_initialization (old_fndecl, vars, tree_map);\n }\n@@ -2383,6 +2414,16 @@ ipa_param_body_adjustments::perform_cfun_body_modifications ()\n }\n \n \n+/* If there are any initialization statements that need to be emitted into\n+   the basic block BB right at ther start of the new function, do so.  */\n+void\n+ipa_param_body_adjustments::append_init_stmts (basic_block bb)\n+{\n+  gimple_stmt_iterator si = gsi_last_bb (bb);\n+  while (!m_split_agg_csts_inits.is_empty ())\n+    gsi_insert_after (&si, m_split_agg_csts_inits.pop (), GSI_NEW_STMT);\n+}\n+\n /* Deallocate summaries which otherwise stay alive until the end of\n    compilation.  */\n "}, {"sha": "e20d34918b30ba8aa32ffbd17bee16550a007aba", "filename": "gcc/ipa-param-manipulation.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Fipa-param-manipulation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Fipa-param-manipulation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.h?ref=4834e9360f7bf42fbeabaa20de5619e67c9fee4e", "patch": "@@ -236,13 +236,6 @@ class GTY(()) ipa_param_adjustments\n   void get_surviving_params (vec<bool> *surviving_params);\n   /* Fill a vector with new indices of surviving original parameters.  */\n   void get_updated_indices (vec<int> *new_indices);\n-  /* If a parameter with original INDEX has survived intact, return its new\n-     index.  Otherwise return -1.  In that case, if it has been split and there\n-     is a new parameter representing a portion at UNIT_OFFSET for which a value\n-     of a TYPE can be substituted, store its new index into SPLIT_INDEX,\n-     otherwise store -1 there.  */\n-  int get_updated_index_or_split (int index, unsigned unit_offset, tree type,\n-\t\t\t\t  int *split_index);\n   /* Return the original index for the given new parameter index.  Return a\n      negative number if not available.  */\n   int get_original_index (int newidx);\n@@ -321,6 +314,8 @@ class ipa_param_body_adjustments\n \n   /* Change the PARM_DECLs.  */\n   void modify_formal_parameters ();\n+  /* Register a REPLACEMENT for accesses to BASE at UNIT_OFFSET.  */\n+  void register_replacement (tree base, unsigned unit_offset, tree replacement);\n   /* Register a replacement decl for the transformation done in APM.  */\n   void register_replacement (ipa_adjusted_param *apm, tree replacement);\n   /* Lookup a replacement for a given offset within a given parameter.  */\n@@ -340,6 +335,10 @@ class ipa_param_body_adjustments\n      they are mapped to.  */\n   void remap_with_debug_expressions (tree *t);\n \n+  /* If there are any initialization statements that need to be emitted into\n+     the basic block BB right at ther start of the new function, do so.  */\n+  void append_init_stmts (basic_block bb);\n+\n   /* Pointers to data structures defining how the function should be\n      modified.  */\n   vec<ipa_adjusted_param, va_gc> *m_adj_params;\n@@ -405,6 +404,12 @@ class ipa_param_body_adjustments\n \n   auto_vec<ipa_param_body_replacement, 16> m_replacements;\n \n+  /* List of initialization assignments to be put at the beginning of the\n+     cloned function to deal with split aggregates which however have known\n+     constant value and so their PARM_DECL disappears.  */\n+\n+  auto_vec<gimple *, 8> m_split_agg_csts_inits;\n+\n   /* Vector for remapping SSA_BASES from old parameter declarations that are\n      being removed as a part of the transformation.  Before a new VAR_DECL is\n      created, it holds the old PARM_DECL, once the variable is built it is"}, {"sha": "08c7f97efb9642bc47145636f02ee9abee7c8886", "filename": "gcc/ipa-prop.cc", "status": "modified", "additions": 20, "deletions": 46, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Fipa-prop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Fipa-prop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.cc?ref=4834e9360f7bf42fbeabaa20de5619e67c9fee4e", "patch": "@@ -5518,43 +5518,32 @@ ipcp_read_transformation_summaries (void)\n     }\n }\n \n-/* Adjust the aggregate replacements in TS to reflect parameters skipped in\n-   NODE but also if any parameter was IPA-SRAed into a scalar go ahead with\n-   substitution of the default_definitions of that new param with the\n-   appropriate constant.\n+/* Adjust the aggregate replacements in TS to reflect any parameter removals\n+   which might have already taken place.  If after adjustments there are no\n+   aggregate replacements left, the m_agg_values will be set to NULL.  In other\n+   cases, it may be shrunk.  */\n \n-   If after adjustments there are no aggregate replacements left, the\n-   m_agg_values will be set to NULL.  In other cases, it may be shrunk.\n-\n-   Return true if any values were already substituted for scalarized parameters\n-   and update_cfg shuld be run after replace_uses_by.  */\n-\n-static bool\n-adjust_agg_replacement_values (cgraph_node *node,\n-\t\t\t       ipcp_transformation *ts,\n-\t\t\t       const vec<ipa_param_descriptor, va_gc>\n-\t\t\t         &descriptors)\n+static void\n+adjust_agg_replacement_values (cgraph_node *node, ipcp_transformation *ts)\n {\n   clone_info *cinfo = clone_info::get (node);\n   if (!cinfo || !cinfo->param_adjustments)\n-    return false;\n+    return;\n \n+  auto_vec<int, 16> new_indices;\n+  cinfo->param_adjustments->get_updated_indices (&new_indices);\n   bool removed_item = false;\n-  bool done_replacement = false;\n   unsigned dst_index = 0;\n   unsigned count = ts->m_agg_values->length ();\n   for (unsigned i = 0; i < count; i++)\n     {\n       ipa_argagg_value *v = &(*ts->m_agg_values)[i];\n       gcc_checking_assert (v->index >= 0);\n \n-      tree cst_type = TREE_TYPE (v->value);\n-      int split_idx;\n-      int new_idx\n-\t= cinfo->param_adjustments->get_updated_index_or_split (v->index,\n-\t\t\t\t\t\t\t\tv->unit_offset,\n-\t\t\t\t\t\t\t\tcst_type,\n-\t\t\t\t\t\t\t\t&split_idx);\n+      int new_idx = -1;\n+      if ((unsigned) v->index < new_indices.length ())\n+\tnew_idx = new_indices[v->index];\n+\n       if (new_idx >= 0)\n \t{\n \t  v->index = new_idx;\n@@ -5563,19 +5552,7 @@ adjust_agg_replacement_values (cgraph_node *node,\n \t  dst_index++;\n \t}\n       else\n-\t{\n-\t  removed_item = true;\n-\t  if (split_idx >= 0)\n-\t    {\n-\t      tree parm = ipa_get_param (descriptors, split_idx);\n-\t      tree ddef = ssa_default_def (cfun, parm);\n-\t      if (ddef)\n-\t\t{\n-\t\t  replace_uses_by (ddef, v->value);\n-\t\t  done_replacement = true;\n-\t\t}\n-\t    }\n-\t}\n+\tremoved_item = true;\n     }\n \n   if (dst_index == 0)\n@@ -5586,7 +5563,7 @@ adjust_agg_replacement_values (cgraph_node *node,\n   else if (removed_item)\n     ts->m_agg_values->truncate (dst_index);\n \n-  return done_replacement;\n+  return;\n }\n \n /* Dominator walker driving the ipcp modification phase.  */\n@@ -5955,7 +5932,6 @@ ipcp_update_vr (struct cgraph_node *node)\n unsigned int\n ipcp_transform_function (struct cgraph_node *node)\n {\n-  vec<ipa_param_descriptor, va_gc> *descriptors = NULL;\n   struct ipa_func_body_info fbi;\n   int param_count;\n \n@@ -5974,18 +5950,13 @@ ipcp_transform_function (struct cgraph_node *node)\n   param_count = count_formal_params (node->decl);\n   if (param_count == 0)\n     return 0;\n-  vec_safe_grow_cleared (descriptors, param_count, true);\n-  ipa_populate_param_decls (node, *descriptors);\n \n-  bool cfg_changed = adjust_agg_replacement_values (node, ts, *descriptors);\n+  adjust_agg_replacement_values (node, ts);\n   if (vec_safe_is_empty (ts->m_agg_values))\n     {\n-      vec_free (descriptors);\n       if (dump_file)\n \tfprintf (dump_file, \"  All affected aggregate parameters were either \"\n \t\t \"removed or converted into scalars, phase done.\\n\");\n-      if (cfg_changed)\n-\tdelete_unreachable_blocks_update_callgraph (node, false);\n       return 0;\n     }\n   if (dump_file)\n@@ -6002,12 +5973,15 @@ ipcp_transform_function (struct cgraph_node *node)\n   fbi.param_count = param_count;\n   fbi.aa_walk_budget = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n \n+  vec<ipa_param_descriptor, va_gc> *descriptors = NULL;\n+  vec_safe_grow_cleared (descriptors, param_count, true);\n+  ipa_populate_param_decls (node, *descriptors);\n   bool modified_mem_access = false;\n   calculate_dominance_info (CDI_DOMINATORS);\n   ipcp_modif_dom_walker walker (&fbi, descriptors, ts, &modified_mem_access);\n   walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   free_dominance_info (CDI_DOMINATORS);\n-  cfg_changed |= walker.cleanup_eh ();\n+  bool cfg_changed = walker.cleanup_eh ();\n \n   int i;\n   struct ipa_bb_info *bi;"}, {"sha": "0f137e810febf0eb22598e50957b49ab998248ab", "filename": "gcc/ipa-sra.cc", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Fipa-sra.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Fipa-sra.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.cc?ref=4834e9360f7bf42fbeabaa20de5619e67c9fee4e", "patch": "@@ -84,6 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"internal-fn.h\"\n #include \"symtab-clones.h\"\n #include \"attribs.h\"\n+#include \"ipa-prop.h\"\n \n static void ipa_sra_summarize_function (cgraph_node *);\n \n@@ -3605,13 +3606,16 @@ retval_used_p (cgraph_node *node, void *)\n /* Push into NEW_PARAMS all required parameter adjustment entries to copy or\n    modify parameter which originally had index BASE_INDEX, in the adjustment\n    vector of parent clone (if any) had PREV_CLONE_INDEX and was described by\n-   PREV_ADJUSTMENT.  If the parent clone is the original function,\n-   PREV_ADJUSTMENT is NULL and PREV_CLONE_INDEX is equal to BASE_INDEX.  */\n+   PREV_ADJUSTMENT.  If IPA-CP has created a transformation summary for the\n+   original node, it needs to be passed in IPCP_TS, otherwise it should be\n+   NULL.  If the parent clone is the original function, PREV_ADJUSTMENT is NULL\n+   and PREV_CLONE_INDEX is equal to BASE_INDEX.  */\n \n static void\n push_param_adjustments_for_index (isra_func_summary *ifs, unsigned base_index,\n \t\t\t\t  unsigned prev_clone_index,\n \t\t\t\t  ipa_adjusted_param *prev_adjustment,\n+\t\t\t\t  ipcp_transformation *ipcp_ts,\n \t\t\t\t  vec<ipa_adjusted_param, va_gc> **new_params)\n {\n   isra_param_desc *desc = &(*ifs->m_parameters)[base_index];\n@@ -3652,6 +3656,23 @@ push_param_adjustments_for_index (isra_func_summary *ifs, unsigned base_index,\n       param_access *pa = (*desc->accesses)[j];\n       if (!pa->certain)\n \tcontinue;\n+\n+      if (ipcp_ts)\n+\t{\n+\t  ipa_argagg_value_list avl (ipcp_ts);\n+\t  tree value = avl.get_value (base_index, pa->unit_offset);\n+\t  if (value\n+\t      && (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (value))) / BITS_PER_UNIT\n+\t\t  == pa->unit_size))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"    - omitting component at byte \"\n+\t\t\t \"offset %u which is known to have a constant value\\n \",\n+\t\t\t pa->unit_offset);\n+\t      continue;\n+\t    }\n+\t}\n+\n       if (dump_file)\n \tfprintf (dump_file, \"    - component at byte offset %u, \"\n \t\t \"size %u\\n\", pa->unit_offset, pa->unit_size);\n@@ -3732,6 +3753,7 @@ process_isra_node_results (cgraph_node *node,\n \tfprintf (dump_file, \"  Will remove return value.\\n\");\n     }\n \n+  ipcp_transformation *ipcp_ts = ipcp_get_transformation_summary (node);\n   vec<ipa_adjusted_param, va_gc> *new_params = NULL;\n   if (ipa_param_adjustments *old_adjustments\n \t = cinfo ? cinfo->param_adjustments : NULL)\n@@ -3741,12 +3763,12 @@ process_isra_node_results (cgraph_node *node,\n \t{\n \t  ipa_adjusted_param *old_adj = &(*old_adjustments->m_adj_params)[i];\n \t  push_param_adjustments_for_index (ifs, old_adj->base_index, i,\n-\t\t\t\t\t    old_adj, &new_params);\n+\t\t\t\t\t    old_adj, ipcp_ts, &new_params);\n \t}\n     }\n   else\n     for (unsigned i = 0; i < param_count; i++)\n-      push_param_adjustments_for_index (ifs, i, i, NULL, &new_params);\n+      push_param_adjustments_for_index (ifs, i, i, NULL, ipcp_ts, &new_params);\n \n   ipa_param_adjustments *new_adjustments\n     = (new (ggc_alloc <ipa_param_adjustments> ())"}, {"sha": "94cbe02860d30233f9dc859354081cc9cd17968b", "filename": "gcc/testsuite/gcc.dg/ipa/pr107640-2.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr107640-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr107640-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr107640-2.c?ref=4834e9360f7bf42fbeabaa20de5619e67c9fee4e", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized-slim\"  } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+int ellide (int c);\n+volatile short gi;\n+\n+void __attribute__((noipa))\n+consume_s (struct S *p)\n+{\n+  gi = p->a;\n+}\n+\n+static void __attribute__((noinline))\n+foo (struct S *p, short *r)\n+{\n+  gi = *r;\n+  if (!__builtin_constant_p (p->b))\n+    ellide (1);\n+  consume_s (p);\n+}\n+\n+static void __attribute__((noinline))\n+bar (short *r, struct S *p)\n+{\n+  gi = *r;\n+  if (!__builtin_constant_p (p->c))\n+    ellide (2);\n+  consume_s (p);\n+}\n+\n+struct S gs;\n+\n+int main (int argc, char *argv[])\n+{\n+  short i = 42;\n+  gs.a = 10;\n+  gs.b = 20;\n+  foo (&gs, &i);\n+  gs.b = 30;\n+  gs.c = 40;\n+  bar (&i, &gs);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"ellide\" \"optimized\" { xfail *-*-* } } } */"}, {"sha": "15a1a3894931456b67cd8ff47b30bb848893b8b0", "filename": "gcc/tree-inline.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Ftree-inline.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4834e9360f7bf42fbeabaa20de5619e67c9fee4e/gcc%2Ftree-inline.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.cc?ref=4834e9360f7bf42fbeabaa20de5619e67c9fee4e", "patch": "@@ -6377,6 +6377,8 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   bb = split_edge (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n   while (init_stmts.length ())\n     insert_init_stmt (&id, bb, init_stmts.pop ());\n+  if (param_body_adjs)\n+    param_body_adjs->append_init_stmts (bb);\n   update_clone_info (&id);\n \n   /* Remap the nonlocal_goto_save_area, if any.  */"}]}