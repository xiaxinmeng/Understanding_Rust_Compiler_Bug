{"sha": "40bd439555a80db149bf2f286621c36603b2c85c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBiZDQzOTU1NWE4MGRiMTQ5YmYyZjI4NjYyMWMzNjYwM2IyYzg1Yw==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-11-28T19:14:16Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-28T19:14:16Z"}, "message": "tradcpp.c (enum node_type): New hash types T_ASSERT, T_UNASSERT.\n\n        * tradcpp.c (enum node_type): New hash types T_ASSERT, T_UNASSERT.\n        (struct directive): Drop 4th argument from handlers.\n        (do_define, do_line, do_include, do_undef, do_else, do_elif,\n        do_endif): Similarly.\n        (do_assert, do_unassert, do_ifdef, do_ifndef): New handlers.\n        (do_ifxdef): Update as common handler of do_ifdef and do_ifndef.\n        (make_definition, make_undef): Take a const char*.\n        (make_assertion): New function.\n        (struct directive_table): Update.\n        (main): Handle -A command line argument.\n        (handle_directive): Drop fourth handler argument.\n\nFrom-SVN: r37820", "tree": {"sha": "b64552d298b268caaa573d41efddc985d737dffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b64552d298b268caaa573d41efddc985d737dffe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40bd439555a80db149bf2f286621c36603b2c85c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40bd439555a80db149bf2f286621c36603b2c85c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40bd439555a80db149bf2f286621c36603b2c85c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40bd439555a80db149bf2f286621c36603b2c85c/comments", "author": null, "committer": null, "parents": [{"sha": "77ea49a4945586becd775f3051bdfa93e617204c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77ea49a4945586becd775f3051bdfa93e617204c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77ea49a4945586becd775f3051bdfa93e617204c"}], "stats": {"total": 265, "additions": 172, "deletions": 93}, "files": [{"sha": "e471fe3eedd0ee3fe6fa2553722e20b3aaecae4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bd439555a80db149bf2f286621c36603b2c85c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bd439555a80db149bf2f286621c36603b2c85c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40bd439555a80db149bf2f286621c36603b2c85c", "patch": "@@ -1,3 +1,17 @@\n+2000-11-28  Neil Booth  <neilb@earthling.net>\n+\n+        * tradcpp.c (enum node_type): New hash types T_ASSERT, T_UNASSERT.\n+        (struct directive): Drop 4th argument from handlers.\n+        (do_define, do_line, do_include, do_undef, do_else, do_elif,\n+        do_endif): Similarly.\n+        (do_assert, do_unassert, do_ifdef, do_ifndef): New handlers.\n+        (do_ifxdef): Update as common handler of do_ifdef and do_ifndef.\n+        (make_definition, make_undef): Take a const char*.\n+        (make_assertion): New function.\n+        (struct directive_table): Update.\n+        (main): Handle -A command line argument.\n+        (handle_directive): Drop fourth handler argument.\n+\n 2000-11-28  Bernd Schmidt  <bernds@redhat.co.uk>\n \n \t* simplify-rtx.c (cselib_record_sets): Ignore sets whose destination"}, {"sha": "3b79a20b5bd67a994222d1108a950073749af8f7", "filename": "gcc/tradcpp.c", "status": "modified", "additions": 158, "deletions": 93, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bd439555a80db149bf2f286621c36603b2c85c/gcc%2Ftradcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bd439555a80db149bf2f286621c36603b2c85c/gcc%2Ftradcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcpp.c?ref=40bd439555a80db149bf2f286621c36603b2c85c", "patch": "@@ -215,6 +215,8 @@ enum node_type {\n  T_UNDEF,\t/* `#undef' */\n  T_LINE,\t/* `#line' */\n  T_ENDIF,\t/* `#endif' */\n+ T_ASSERT,\t/* `#assert' */\n+ T_UNASSERT,\t/* `#unassert' */\n  T_SPECLINE,\t/* special symbol `__LINE__' */\n  T_DATE,\t/* `__DATE__' */\n  T_FILE,\t/* `__FILE__' */\n@@ -258,7 +260,7 @@ HASHNODE *hashtab[HASHSIZE];\n \n struct directive {\n   int length;\t\t\t/* Length of name */\n-  void (*func) PARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+  void (*func) PARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n   \t\t\t\t/* Function to handle directive */\n   const char *name;\t\t/* Name of directive */\n   enum node_type type;\t\t/* Code which describes which directive. */\n@@ -305,15 +307,19 @@ struct arglist {\n \n /* Function prototypes.  */\n \n-static void do_define\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-static void do_line\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-static void do_include\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-static void do_undef\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-static void do_if\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-static void do_xifdef\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-static void do_else\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-static void do_elif\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-static void do_endif\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+static void do_define\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_line\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_include\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_undef\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_if\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_ifdef\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_ifndef\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_else\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_elif\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_endif\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_assert\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_unassert\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void do_xifdef\tPARAMS ((U_CHAR *, U_CHAR *, enum node_type));\n \n static struct hashnode *install PARAMS ((const U_CHAR *, int, enum node_type, int));\n static int hashf\t\t PARAMS ((const U_CHAR *, int, int));\n@@ -353,8 +359,11 @@ static int eval_if_expression\tPARAMS ((const U_CHAR *, int));\n \n static void initialize_char_syntax\tPARAMS ((void));\n static void initialize_builtins\tPARAMS ((void));\n-static void make_definition\tPARAMS ((const U_CHAR *));\n-static void make_undef\t\tPARAMS ((U_CHAR *));\n+static void run_directive\tPARAMS ((const char *, size_t,\n+\t\t\t\t\t enum node_type));\n+static void make_definition\tPARAMS ((const char *));\n+static void make_undef\t\tPARAMS ((const char *));\n+static void make_assertion\tPARAMS ((const char *));\n \n static void grow_outbuf \tPARAMS ((FILE_BUF *, int));\n static int handle_directive \tPARAMS ((FILE_BUF *, FILE_BUF *));\n@@ -384,13 +393,15 @@ struct directive directive_table[] = {\n   {  6, do_define,  \"define\",  T_DEFINE  },\n   {  7, do_include, \"include\", T_INCLUDE },\n   {  5, do_endif,   \"endif\",   T_ENDIF   },\n-  {  5, do_xifdef,  \"ifdef\",   T_IFDEF   },\n+  {  5, do_ifdef,   \"ifdef\",   T_IFDEF   },\n   {  2, do_if,      \"if\",      T_IF,     },\n   {  4, do_else,    \"else\",    T_ELSE    },\n-  {  6, do_xifdef,  \"ifndef\",  T_IFNDEF  },\n+  {  6, do_ifndef,  \"ifndef\",  T_IFNDEF  },\n   {  5, do_undef,   \"undef\",   T_UNDEF   },\n   {  4, do_line,    \"line\",    T_LINE    },\n   {  4, do_elif,    \"elif\",    T_ELIF    },\n+  {  6, do_assert,  \"assert\",  T_ASSERT  },\n+  {  8, do_unassert,\"unassert\",T_UNASSERT},\n   {  -1, 0, \"\", T_UNUSED},\n };\n \n@@ -515,7 +526,6 @@ main (argc, argv)\n       int c = argv[i][1];\n \n       switch (c) {\n-      case 'A':\n       case 'E':\n       case '$':\n       case 'g':\n@@ -604,6 +614,7 @@ main (argc, argv)\n \n       case 'D':\n       case 'U':\n+      case 'A':\n \t{\n \t  char *p;\n \n@@ -614,7 +625,12 @@ main (argc, argv)\n \t  else\n \t    p = argv[++i];\n \n-\t  pend[i].type = c == 'D' ? PD_DEFINE: PD_UNDEF;\n+\t  if (c == 'D')\n+\t    pend[i].type = PD_DEFINE;\n+\t  else if (c == 'U')\n+\t    pend[i].type = PD_UNDEF;\n+\t  else\n+\t    pend[i].type = PD_ASSERTION;\n \t  pend[i].arg = p;\n \t}\n \tbreak;\n@@ -701,9 +717,11 @@ main (argc, argv)\n   /* Do defines specified with -D and undefines specified with -U.  */\n   for (i = 1; i < argc; i++)\n     if (pend[i].type == PD_DEFINE)\n-      make_definition ((const U_CHAR *) pend[i].arg);\n+      make_definition (pend[i].arg);\n     else if (pend[i].type == PD_UNDEF)\n-      make_undef ((U_CHAR *) pend[i].arg);\n+      make_undef (pend[i].arg);\n+    else if (pend[i].type == PD_ASSERTION)\n+      make_assertion (pend[i].arg);\n \n   /* Unless -fnostdinc,\n      tack on the standard include file dirs to the specified list */\n@@ -2011,7 +2029,7 @@ handle_directive (ip, op)\n \t the temp buffer if it was necessary to make one.  cp\n \t points to the first char after the contents of the (possibly\n \t copied) command, in either case. */\n-      (*kt->func) (buf, cp, op, kt);\n+      (*kt->func) (buf, cp, op);\n       check_expand (op, ip->length - (ip->bufp - ip->buf));\n \n       return 1;\n@@ -2172,10 +2190,9 @@ special_symbol (hp, op)\n  * Expects to see \"fname\" or <fname> on the input.\n  */\n static void\n-do_include (buf, limit, op, keyword)\n+do_include (buf, limit, op)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   char *fname;\t\t/* Dynamically allocated fname buffer */\n   U_CHAR *fbeg, *fend;\t\t/* Beginning and end of fname */\n@@ -2463,10 +2480,9 @@ LIMIT points to the first character past the end of the definition.\n KEYWORD is the keyword-table entry for #define.  */\n \n static void\n-do_define (buf, limit, op, keyword)\n+do_define (buf, limit, op)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   U_CHAR *bp;\t\t\t/* temp ptr into input buffer */\n   U_CHAR *symname;\t\t/* remember where symbol name starts */\n@@ -2874,10 +2890,9 @@ collect_expansion (buf, end, nargs, arglist)\n  */\n #define FNAME_HASHSIZE 37\n static void\n-do_line (buf, limit, op, keyword)\n+do_line (buf, limit, op)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   register U_CHAR *bp;\n   FILE_BUF *ip = &instack[indepth];\n@@ -2987,11 +3002,10 @@ do_line (buf, limit, op, keyword)\n  * something that has no definitions, so it isn't one here either.\n  */\n static void\n-do_undef (buf, limit, op, keyword)\n+do_undef (buf, limit, op)\n      U_CHAR *buf;\n      U_CHAR *limit ATTRIBUTE_UNUSED;\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   HASHNODE *hp;\n \n@@ -3007,6 +3021,24 @@ do_undef (buf, limit, op, keyword)\n   }\n }\n \n+/* Function body to be provided later.  */\n+static void\n+do_assert (buf, limit, op)\n+     U_CHAR *buf ATTRIBUTE_UNUSED;\n+     U_CHAR *limit ATTRIBUTE_UNUSED;\n+     FILE_BUF *op ATTRIBUTE_UNUSED;\n+{\n+}\n+\n+/* Function body to be provided later.  */\n+static void\n+do_unassert (buf, limit, op)\n+     U_CHAR *buf ATTRIBUTE_UNUSED;\n+     U_CHAR *limit ATTRIBUTE_UNUSED;\n+     FILE_BUF *op ATTRIBUTE_UNUSED;\n+{\n+}\n+\n /*\n  * handle #if command by\n  *   1) inserting special `defined' keyword into the hash table\n@@ -3020,10 +3052,9 @@ do_undef (buf, limit, op, keyword)\n  *      or not, depending on the value from step 3.\n  */\n static void\n-do_if (buf, limit, op, keyword)\n+do_if (buf, limit, op)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   int value;\n   FILE_BUF *ip = &instack[indepth];\n@@ -3037,10 +3068,9 @@ do_if (buf, limit, op, keyword)\n  * see the comment above do_else.\n  */\n static void\n-do_elif (buf, limit, op, keyword)\n+do_elif (buf, limit, op)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   int value;\n   FILE_BUF *ip = &instack[indepth];\n@@ -3103,10 +3133,9 @@ eval_if_expression (buf, length)\n  * on what directive is actually being processed.\n  */\n static void\n-do_xifdef (buf, limit, op, keyword)\n+do_xifdef (buf, limit, type)\n      U_CHAR *buf, *limit;\n-     FILE_BUF *op ATTRIBUTE_UNUSED;\n-     struct directive *keyword;\n+     enum node_type type;     \n {\n   int skip;\n   FILE_BUF *ip = &instack[indepth];\n@@ -3119,15 +3148,30 @@ do_xifdef (buf, limit, op, keyword)\n   /* Find the end of the identifier at the beginning.  */\n   for (end = buf; is_idchar[*end]; end++);\n \n-  if (end == buf) {\n-    skip = (keyword->type == T_IFDEF);\n-  } else {\n-    skip = (lookup (buf, end-buf, -1) == NULL) ^ (keyword->type == T_IFNDEF);\n-  }\n+  if (end == buf)\n+    skip = (type == T_IFDEF);\n+  else\n+    skip = (lookup (buf, end-buf, -1) == NULL) ^ (type == T_IFNDEF);\n \n   conditional_skip (ip, skip, T_IF);\n }\n \n+static void\n+do_ifdef (buf, limit, op)\n+     U_CHAR *buf, *limit;\n+     FILE_BUF *op ATTRIBUTE_UNUSED;\n+{\n+  do_xifdef (buf, limit, T_IFDEF);\n+}\n+\n+static void\n+do_ifndef (buf, limit, op)\n+     U_CHAR *buf, *limit;\n+     FILE_BUF *op ATTRIBUTE_UNUSED;\n+{\n+  do_xifdef (buf, limit, T_IFNDEF);\n+}\n+\n /*\n  * push TYPE on stack; then, if SKIP is nonzero, skip ahead.\n  */\n@@ -3329,11 +3373,10 @@ skip_if_group (ip, any)\n  * is possible that something different would be better.\n  */\n static void\n-do_else (buf, limit, op, keyword)\n+do_else (buf, limit, op)\n      U_CHAR *buf ATTRIBUTE_UNUSED;\n      U_CHAR *limit ATTRIBUTE_UNUSED;\n      FILE_BUF *op;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   FILE_BUF *ip = &instack[indepth];\n \n@@ -3363,11 +3406,10 @@ do_else (buf, limit, op, keyword)\n  * unstack after #endif command\n  */\n static void\n-do_endif (buf, limit, op, keyword)\n+do_endif (buf, limit, op)\n      U_CHAR *buf ATTRIBUTE_UNUSED;\n      U_CHAR *limit ATTRIBUTE_UNUSED;\n      FILE_BUF *op;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   if (if_stack == instack[indepth].if_stack)\n     error (\"unbalanced #endif\");\n@@ -4663,77 +4705,100 @@ initialize_builtins ()\n #undef install_spec\n #undef install_value\n \f\n-/*\n- * process a given definition string, for initialization\n- * If STR is just an identifier, define it with value 1.\n- * If STR has anything after the identifier, then it should\n- * be identifier-space-definition.\n- */\n+/* Common handler of command line directives -U, -D and -A.  */\n static void\n-make_definition (str)\n-     const U_CHAR *str;\n+run_directive (str, len, type)\n+     const char *str;\n+     size_t len;\n+     enum node_type type;\n {\n-  FILE_BUF *ip;\n   struct directive *kt;\n-  U_CHAR *buf;\n-  const U_CHAR *p;\n-  size_t len = strlen ((const char *)str);\n-\n-  p = (const U_CHAR *) strchr ((const char *)str, '=');\n-  if (p == NULL) {\n-    /* Change -DFOO into #define FOO 1 */\n-    buf = (U_CHAR *) alloca (len + 3);\n-    memcpy (buf, str, len);\n-    memcpy (buf + len, \" 1\", 3);\n-    len += 2;\n-  } else {\n-    buf = (U_CHAR *) alloca (len + 1);\n-    memcpy (buf, str, len + 1);\n-    buf[p - str] = ' ';\n-  }\n-  \n-  ip = &instack[++indepth];\n-  ip->fname = \"*Initialization*\";\n+  FILE_BUF *ip = &instack[++indepth];\n+  ip->fname = \"*command line*\";\n \n-  ip->buf = ip->bufp = buf;\n+  ip->buf = ip->bufp = (U_CHAR *) str;\n   ip->length = len;\n   ip->lineno = 1;\n   ip->macro = 0;\n   ip->free_ptr = 0;\n   ip->if_stack = if_stack;\n \n-  for (kt = directive_table; kt->type != T_DEFINE; kt++)\n+  for (kt = directive_table; kt->type != type; kt++)\n     ;\n \n-  /* pass NULL as output ptr to do_define since we KNOW it never\n-     does any output.... */\n-  do_define (buf, buf + ip->length, NULL, kt);\n+  (*kt->func) ((U_CHAR *) str, (U_CHAR *) str + len, NULL);\n   --indepth;\n }\n \n-/* JF, this does the work for the -U option */\n+/* Handle the -D option.  If STR is just an identifier, define it with\n+ * value 1.  If STR has anything after the identifier, then it should\n+ * be identifier-space-definition.  */\n static void\n-make_undef (str)\n-     U_CHAR *str;\n+make_definition (str)\n+     const char *str;\n {\n-  FILE_BUF *ip;\n-  struct directive *kt;\n+  char *buf, *p;\n+  size_t count;\n \n-  ip = &instack[++indepth];\n-  ip->fname = \"*undef*\";\n+  /* Copy the entire option so we can modify it. \n+     Change the first \"=\" in the string to a space.  If there is none,\n+     tack \" 1\" on the end.  */\n \n-  ip->buf = ip->bufp = str;\n-  ip->length = strlen ((const char *)str);\n-  ip->lineno = 1;\n-  ip->macro = 0;\n-  ip->free_ptr = 0;\n-  ip->if_stack = if_stack;\n+  /* Length including the null.  */  \n+  count = strlen (str);\n+  buf = (char *) alloca (count + 2);\n+  memcpy (buf, str, count);\n \n-  for (kt = directive_table; kt->type != T_UNDEF; kt++)\n-    ;\n+  p = strchr (str, '=');\n+  if (p)\n+    buf[p - str] = ' ';\n+  else\n+    {\n+      buf[count++] = ' ';\n+      buf[count++] = '1';\n+    }\n \n-  do_undef (str, str + ip->length, NULL, kt);\n-  --indepth;\n+  run_directive (buf, count, T_DEFINE);\n+}\n+\n+/* Handle the -U option.  */\n+static void\n+make_undef (str)\n+     const char *str;\n+{\n+  run_directive (str, strlen (str), T_UNDEF);\n+}\n+\n+/* Handles the #assert (-A) and #unassert (-A-) command line options.  */\n+static void\n+make_assertion (str)\n+     const char *str;\n+{\n+  enum node_type type = T_ASSERT;\n+  size_t count;\n+  const char *p;\n+\n+  if (*str == '-')\n+    {\n+      str++;\n+      type = T_UNASSERT;\n+    }\n+  \n+  count = strlen (str);\n+  p = strchr (str, '=');\n+  if (p)\n+    {\n+      /* Copy the entire option so we can modify it.  Change the first\n+\t \"=\" in the string to a '(', and tack a ')' on the end.  */\n+      char *buf = (char *) alloca (count + 1);\n+\n+      memcpy (buf, str, count);\n+      buf[p - str] = '(';\n+      buf[count++] = ')';\n+      str = buf;\n+    }\n+\n+  run_directive (str, count, type);\n }\n \f\n /* Add output to `deps_buffer' for the -M switch."}]}