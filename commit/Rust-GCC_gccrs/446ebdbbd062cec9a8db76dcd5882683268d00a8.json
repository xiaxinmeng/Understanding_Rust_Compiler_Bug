{"sha": "446ebdbbd062cec9a8db76dcd5882683268d00a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ2ZWJkYmJkMDYyY2VjOWE4ZGI3NmRjZDU4ODI2ODMyNjhkMDBhOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-06-13T10:03:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-06-13T10:03:43Z"}, "message": "[multiple changes]\n\n2014-06-13  Robert Dewar  <dewar@adacore.com>\n\n\t* layout.adb (Layout_Type): Anonymous access types designating\n\tunconstrained arrays are always thin pointers.\n\t* sem_ch3.adb (Replace_Type): Anonymous access types designating\n\tunconstrained arrays are always thin pointers.\n\n2014-06-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): Use Check_Parameterless_Call\n\tto resolve the prefix of an attribute that is an entity name\n\tand may be a parameterless call.  Minor code reorganization.\n\nFrom-SVN: r211618", "tree": {"sha": "78623ddf8772ac78c5814c15f74fe937c361bd95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78623ddf8772ac78c5814c15f74fe937c361bd95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/446ebdbbd062cec9a8db76dcd5882683268d00a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/446ebdbbd062cec9a8db76dcd5882683268d00a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/446ebdbbd062cec9a8db76dcd5882683268d00a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/446ebdbbd062cec9a8db76dcd5882683268d00a8/comments", "author": null, "committer": null, "parents": [{"sha": "c86cf71483eb73bf8d637e4c9d6caef3b67b09a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c86cf71483eb73bf8d637e4c9d6caef3b67b09a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c86cf71483eb73bf8d637e4c9d6caef3b67b09a2"}], "stats": {"total": 137, "additions": 77, "deletions": 60}, "files": [{"sha": "3d1113cfe20f71b68da25b373eba6387f3ee1d04", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/446ebdbbd062cec9a8db76dcd5882683268d00a8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/446ebdbbd062cec9a8db76dcd5882683268d00a8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=446ebdbbd062cec9a8db76dcd5882683268d00a8", "patch": "@@ -1,3 +1,16 @@\n+2014-06-13  Robert Dewar  <dewar@adacore.com>\n+\n+\t* layout.adb (Layout_Type): Anonymous access types designating\n+\tunconstrained arrays are always thin pointers.\n+\t* sem_ch3.adb (Replace_Type): Anonymous access types designating\n+\tunconstrained arrays are always thin pointers.\n+\n+2014-06-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute): Use Check_Parameterless_Call\n+\tto resolve the prefix of an attribute that is an entity name\n+\tand may be a parameterless call.  Minor code reorganization.\n+\n 2014-06-13  Robert Dewar  <dewar@adacore.com>\n \n \t* lib.ads, lib.adb, lib-writ.adb, lib-load.adb (Is_Compiler_Unit):"}, {"sha": "618b0f8d78f648a3ecf48cdd001a237e639b17cc", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/446ebdbbd062cec9a8db76dcd5882683268d00a8/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/446ebdbbd062cec9a8db76dcd5882683268d00a8/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=446ebdbbd062cec9a8db76dcd5882683268d00a8", "patch": "@@ -2462,19 +2462,11 @@ package body Layout is\n             Set_Size_Info (E, Base_Type (E));\n             Set_RM_Size   (E, RM_Size (Base_Type (E)));\n \n-         --  Anonymous access types in subprogram specifications are always\n-         --  thin. In the unconstrained case we always use thin pointers for\n-         --  anonymous access types, because otherwise we get into strange\n-         --  conformance problems between two types, one of which can see\n-         --  that something is unconstrained and one of which cannot. The\n-         --  object of an extended return is treated similarly.\n-\n-         elsif Ekind (E) = E_Anonymous_Access_Type\n-           and then (Nkind_In (Associated_Node_For_Itype (E),\n-                               N_Function_Specification,\n-                               N_Procedure_Specification)\n-                      or else Ekind (Scope (E))  = E_Return_Statement)\n-         then\n+         --  Anonymous access types are always thin, because otherwise we get\n+         --  into strange conformance problems between two types, one of which\n+         --  can see that something is unconstrained and one of which cannot.\n+\n+         elsif Ekind (E) = E_Anonymous_Access_Type then\n             Init_Size (E, System_Address_Size);\n \n          --  For other access types, we use either address size, or, if a fat"}, {"sha": "fa667991748bcb2c5bede194a2e41d1d17063897", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 47, "deletions": 38, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/446ebdbbd062cec9a8db76dcd5882683268d00a8/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/446ebdbbd062cec9a8db76dcd5882683268d00a8/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=446ebdbbd062cec9a8db76dcd5882683268d00a8", "patch": "@@ -2412,66 +2412,75 @@ package body Sem_Attr is\n       --  Ada 2005 (AI-345): Ensure that the compiler gives exactly the current\n       --  output compiling in Ada 95 mode for the case of ambiguous prefixes.\n \n-      if Ada_Version < Ada_2005\n-        and then Is_Overloaded (P)\n-        and then Aname /= Name_Access\n-        and then Aname /= Name_Address\n-        and then Aname /= Name_Code_Address\n-        and then Aname /= Name_Count\n-        and then Aname /= Name_Result\n-        and then Aname /= Name_Unchecked_Access\n-      then\n-         Error_Attr (\"ambiguous prefix for % attribute\", P);\n+      --  Is this comment right??? What is \"the current output\"??? If this\n+      --  is only about Ada 95 mode, why no test for Ada 95 at this point???\n \n-      elsif Ada_Version >= Ada_2005\n-        and then Is_Overloaded (P)\n+      if Is_Overloaded (P)\n         and then Aname /= Name_Access\n         and then Aname /= Name_Address\n         and then Aname /= Name_Code_Address\n         and then Aname /= Name_Result\n         and then Aname /= Name_Unchecked_Access\n       then\n-         --  Ada 2005 (AI-345): Since protected and task types have primitive\n-         --  entry wrappers, the attributes Count, Caller and AST_Entry require\n-         --  a context check\n+         --  The prefix must be resolvble by itself, without reference to the\n+         --  attribute. One case that requires special handling is a prefix\n+         --  that is a function name, where one interpretation may be a\n+         --  parameterless call. Entry attributes are handled specially below.\n \n-         if Ada_Version >= Ada_2005\n-           and then Nam_In (Aname, Name_Count, Name_Caller, Name_AST_Entry)\n+         if Is_Entity_Name (P)\n+           and then not Nam_In (Aname, Name_Count, Name_Caller, Name_AST_Entry)\n          then\n-            declare\n-               Count : Natural := 0;\n-               I     : Interp_Index;\n-               It    : Interp;\n+            Check_Parameterless_Call (P);\n+         end if;\n \n-            begin\n-               Get_First_Interp (P, I, It);\n-               while Present (It.Nam) loop\n-                  if Comes_From_Source (It.Nam) then\n-                     Count := Count + 1;\n-                  else\n-                     Remove_Interp (I);\n-                  end if;\n+         if Ada_Version < Ada_2005 then\n+            if Is_Overloaded (P) then\n \n-                  Get_Next_Interp (I, It);\n-               end loop;\n+               --  Ada 2005 (AI-345): Since protected and task types have\n+               --  primitive entry wrappers, the attributes Count, Caller and\n+               --  AST_Entry require a context check\n \n-               if Count > 1 then\n-                  Error_Attr (\"ambiguous prefix for % attribute\", P);\n+               if Nam_In (Aname, Name_Count, Name_Caller, Name_AST_Entry) then\n+                  declare\n+                     Count : Natural := 0;\n+                     I     : Interp_Index;\n+                     It    : Interp;\n+\n+                  begin\n+                     Get_First_Interp (P, I, It);\n+                     while Present (It.Nam) loop\n+                        if Comes_From_Source (It.Nam) then\n+                           Count := Count + 1;\n+                        else\n+                           Remove_Interp (I);\n+                        end if;\n+\n+                        Get_Next_Interp (I, It);\n+                     end loop;\n+\n+                     if Count > 1 then\n+                        Error_Attr (\"ambiguous prefix for % attribute\", P);\n+                     else\n+                        Set_Is_Overloaded (P, False);\n+                     end if;\n+                  end;\n                else\n-                  Set_Is_Overloaded (P, False);\n+                  Error_Attr (\"ambiguous prefix for % attribute\", P);\n                end if;\n-            end;\n+            end if;\n \n-         else\n+         elsif Is_Overloaded (P) then\n             Error_Attr (\"ambiguous prefix for % attribute\", P);\n          end if;\n       end if;\n \n       --  In SPARK, attributes of private types are only allowed if the full\n       --  type declaration is visible.\n \n-      if Is_Entity_Name (P)\n-        and then Present (Entity (P))  --  needed in some cases\n+      --  Note: the check for Present (Entity (P)) defends against some error\n+      --  conditions where the Entity field is not set.\n+\n+      if Is_Entity_Name (P) and then Present (Entity (P))\n         and then Is_Type (Entity (P))\n         and then Is_Private_Type (P_Type)\n         and then not In_Open_Scopes (Scope (P_Type))"}, {"sha": "938c28ea6b1185de93681e6578574668005f1fdf", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/446ebdbbd062cec9a8db76dcd5882683268d00a8/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/446ebdbbd062cec9a8db76dcd5882683268d00a8/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=446ebdbbd062cec9a8db76dcd5882683268d00a8", "patch": "@@ -13562,21 +13562,23 @@ package body Sem_Ch3 is\n                   --  interface primitives.\n \n                  or else (Is_Interface (Desig_Typ)\n-                          and then not Is_Class_Wide_Type (Desig_Typ))\n+                           and then not Is_Class_Wide_Type (Desig_Typ))\n                then\n                   Acc_Type := New_Copy (Etype (Id));\n                   Set_Etype (Acc_Type, Acc_Type);\n                   Set_Scope (Acc_Type, New_Subp);\n \n-                  --  Compute size of anonymous access type\n+                  --  Set size of anonymous access type. Note that anonymous\n+                  --  access to Unconstrained always uses thin pointers. This\n+                  --  avoids confusion for the case where two types that should\n+                  --  conform but end up differning, because in one case we can\n+                  --  see the unconstrained designated type, and in the other\n+                  --  case we can't see it yet (full type declaration not seen\n+                  --  yet), so we default to thin in that case anyway.\n \n-                  if Is_Array_Type (Desig_Typ)\n-                    and then not Is_Constrained (Desig_Typ)\n-                  then\n-                     Init_Size (Acc_Type, 2 * System_Address_Size);\n-                  else\n-                     Init_Size (Acc_Type, System_Address_Size);\n-                  end if;\n+                  Init_Size (Acc_Type, System_Address_Size);\n+\n+                  --  Set remaining characterstics of anonymous access type\n \n                   Init_Alignment (Acc_Type);\n                   Set_Directly_Designated_Type (Acc_Type, Derived_Type);\n@@ -13585,6 +13587,7 @@ package body Sem_Ch3 is\n                   Set_Scope (New_Id, New_Subp);\n \n                   --  Create a reference to it\n+\n                   Build_Itype_Reference (Acc_Type, Parent (Derived_Type));\n \n                else"}]}