{"sha": "c0ccddb46c11be096ab3b843b5b48104a11a7485", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBjY2RkYjQ2YzExYmUwOTZhYjNiODQzYjViNDgxMDRhMTFhNzQ4NQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-08-23T17:45:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-08-23T17:45:45Z"}, "message": "compiler: revamp scheme for ordering calls to import init fcns.\n\n    \n    Switch to a new method for determining the order in which import init\n    functions are invoked: build an init fcn dependence DAG and walk the DAG\n    to rewrite/adjust priorities to account for discrepancies introduced by\n    \"go test\".\n    \n    This patch includes a change to the export data format generated\n    by gccgo. Older versions of gccgo will not be able to read object files\n    produced by a newer gccgo, but the new gcc will still be able to read\n    old object files.\n    \n    Fixes golang/go#15738.\n    \n    Reviewed-on: https://go-review.googlesource.com/25301\n\nFrom-SVN: r239708", "tree": {"sha": "b09b5f5c15b7583876d0ec58d11c369aa49f6315", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b09b5f5c15b7583876d0ec58d11c369aa49f6315"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0ccddb46c11be096ab3b843b5b48104a11a7485", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0ccddb46c11be096ab3b843b5b48104a11a7485", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0ccddb46c11be096ab3b843b5b48104a11a7485", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0ccddb46c11be096ab3b843b5b48104a11a7485/comments", "author": null, "committer": null, "parents": [{"sha": "9f5897866862e760d8276fc1ef7979852f83a86a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f5897866862e760d8276fc1ef7979852f83a86a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f5897866862e760d8276fc1ef7979852f83a86a"}], "stats": {"total": 698, "additions": 538, "deletions": 160}, "files": [{"sha": "f73d5dd51ac1071b1e823b2b5dc56969d7fa6791", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=c0ccddb46c11be096ab3b843b5b48104a11a7485", "patch": "@@ -1,4 +1,4 @@\n-0476944600d456b2616981fff90c77be5e06edd5\n+0e505f5d191182abd8beb9b4c8232174bc116f97\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e9040efeda9f54f138f7e781de2b7e6437b6bfbd", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 231, "deletions": 49, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=c0ccddb46c11be096ab3b843b5b48104a11a7485", "patch": "@@ -19,16 +19,21 @@\n \n // Class Export.\n \n-// Version 1 magic number.\n+const int Export::magic_len;\n \n-const int Export::v1_magic_len;\n+// Current version magic string.\n+const char Export::cur_magic[Export::magic_len] =\n+  {\n+    'v', '2', ';', '\\n'\n+  };\n \n-const char Export::v1_magic[Export::v1_magic_len] =\n+// Magic string for previous version (still supported)\n+const char Export::v1_magic[Export::magic_len] =\n   {\n     'v', '1', ';', '\\n'\n   };\n \n-const int Export::v1_checksum_len;\n+const int Export::checksum_len;\n \n // Constructor.\n \n@@ -93,11 +98,10 @@ void\n Export::export_globals(const std::string& package_name,\n \t\t       const std::string& prefix,\n \t\t       const std::string& pkgpath,\n-\t\t       int package_priority,\n \t\t       const std::map<std::string, Package*>& packages,\n \t\t       const std::map<std::string, Package*>& imports,\n \t\t       const std::string& import_init_fn,\n-\t\t       const std::set<Import_init>& imported_init_fns,\n+                       const Import_init_set& imported_init_fns,\n \t\t       const Bindings* bindings)\n {\n   // If there have been any errors so far, don't try to export\n@@ -134,8 +138,8 @@ Export::export_globals(const std::string& package_name,\n \n   // Although the export data is readable, at least this version is,\n   // it is conceptually a binary format.  Start with a four byte\n-  // verison number.\n-  this->write_bytes(Export::v1_magic, Export::v1_magic_len);\n+  // version number.\n+  this->write_bytes(Export::cur_magic, Export::magic_len);\n \n   // The package name.\n   this->write_c_string(\"package \");\n@@ -156,16 +160,11 @@ Export::export_globals(const std::string& package_name,\n     }\n   this->write_c_string(\";\\n\");\n \n-  // The package priority.\n-  char buf[100];\n-  snprintf(buf, sizeof buf, \"priority %d;\\n\", package_priority);\n-  this->write_c_string(buf);\n-\n   this->write_packages(packages);\n \n   this->write_imports(imports);\n \n-  this->write_imported_init_fns(package_name, package_priority, import_init_fn,\n+  this->write_imported_init_fns(package_name, import_init_fn,\n \t\t\t\timported_init_fns);\n \n   // FIXME: It might be clever to add something about the processor\n@@ -250,17 +249,17 @@ void\n Export::write_imports(const std::map<std::string, Package*>& imports)\n {\n   // Sort the imports for more consistent output.\n-  std::vector<std::pair<std::string, Package*> > imp;\n+  std::vector<std::pair<std::string, Package*> > sorted_imports;\n   for (std::map<std::string, Package*>::const_iterator p = imports.begin();\n        p != imports.end();\n        ++p)\n-    imp.push_back(std::make_pair(p->first, p->second));\n+    sorted_imports.push_back(std::make_pair(p->first, p->second));\n \n-  std::sort(imp.begin(), imp.end(), import_compare);\n+  std::sort(sorted_imports.begin(), sorted_imports.end(), import_compare);\n \n   for (std::vector<std::pair<std::string, Package*> >::const_iterator p =\n-\t imp.begin();\n-       p != imp.end();\n+\t sorted_imports.begin();\n+       p != sorted_imports.end();\n        ++p)\n     {\n       this->write_c_string(\"import \");\n@@ -275,18 +274,62 @@ Export::write_imports(const std::map<std::string, Package*>& imports)\n     }\n }\n \n+void\n+Export::add_init_graph_edge(Init_graph* init_graph, unsigned src, unsigned sink)\n+{\n+  Init_graph::iterator it = init_graph->find(src);\n+  if (it != init_graph->end())\n+    it->second.insert(sink);\n+  else\n+    {\n+      std::set<unsigned> succs;\n+      succs.insert(sink);\n+      (*init_graph)[src] = succs;\n+    }\n+}\n+\n+// Constructs the imported portion of the init graph, e.g. those\n+// edges that we read from imported packages.\n+\n+void\n+Export::populate_init_graph(Init_graph* init_graph,\n+                            const Import_init_set& imported_init_fns,\n+                            const std::map<std::string, unsigned>& init_idx)\n+{\n+  for (Import_init_set::const_iterator p = imported_init_fns.begin();\n+       p != imported_init_fns.end();\n+       ++p)\n+    {\n+      const Import_init* ii = *p;\n+      std::map<std::string, unsigned>::const_iterator srcit =\n+          init_idx.find(ii->init_name());\n+      go_assert(srcit != init_idx.end());\n+      unsigned src = srcit->second;\n+      for (std::set<std::string>::const_iterator pci = ii->precursors().begin();\n+           pci != ii->precursors().end();\n+           ++pci)\n+\t{\n+\t  std::map<std::string, unsigned>::const_iterator it =\n+\t      init_idx.find(*pci);\n+\t  go_assert(it != init_idx.end());\n+\t  unsigned sink = it->second;\n+\t  add_init_graph_edge(init_graph, src, sink);\n+\t}\n+    }\n+}\n+\n // Write out the initialization functions which need to run for this\n // package.\n \n void\n-Export::write_imported_init_fns(\n-    const std::string& package_name,\n-    int priority,\n-    const std::string& import_init_fn,\n-    const std::set<Import_init>& imported_init_fns)\n+Export::write_imported_init_fns(const std::string& package_name,\n+                                const std::string& import_init_fn,\n+                                const Import_init_set& imported_init_fns)\n {\n-  if (import_init_fn.empty() && imported_init_fns.empty())\n-    return;\n+  if (import_init_fn.empty() && imported_init_fns.empty()) return;\n+\n+  // Maps a given init function to the its index in the exported \"init\" clause.\n+  std::map<std::string, unsigned> init_idx;\n \n   this->write_c_string(\"init\");\n \n@@ -296,35 +339,154 @@ Export::write_imported_init_fns(\n       this->write_string(package_name);\n       this->write_c_string(\" \");\n       this->write_string(import_init_fn);\n-      char buf[100];\n-      snprintf(buf, sizeof buf, \" %d\", priority);\n-      this->write_c_string(buf);\n+      init_idx[import_init_fn] = 0;\n     }\n \n-  if (!imported_init_fns.empty())\n+  if (imported_init_fns.empty())\n     {\n-      // Sort the list of functions for more consistent output.\n-      std::vector<Import_init> v;\n-      for (std::set<Import_init>::const_iterator p = imported_init_fns.begin();\n-\t   p != imported_init_fns.end();\n-\t   ++p)\n-\tv.push_back(*p);\n-      std::sort(v.begin(), v.end());\n-\n-      for (std::vector<Import_init>::const_iterator p = v.begin();\n-\t   p != v.end();\n-\t   ++p)\n+      this->write_c_string(\";\\n\");\n+      return;\n+    }\n+\n+  typedef std::map<int, std::vector<std::string> > level_map;\n+  Init_graph init_graph;\n+  level_map inits_at_level;\n+\n+  // Walk through the set of import inits (already sorted by\n+  // init fcn name) and write them out to the exports.\n+  for (Import_init_set::const_iterator p = imported_init_fns.begin();\n+       p != imported_init_fns.end();\n+       ++p)\n+    {\n+      const Import_init* ii = *p;\n+      this->write_c_string(\" \");\n+      this->write_string(ii->package_name());\n+      this->write_c_string(\" \");\n+      this->write_string(ii->init_name());\n+\n+      // Populate init_idx.\n+      go_assert(init_idx.find(ii->init_name()) == init_idx.end());\n+      unsigned idx = init_idx.size();\n+      init_idx[ii->init_name()] = idx;\n+\n+      // If the init function has a non-negative priority value, this\n+      // is an indication that it was referred to in an older version\n+      // export data section (e.g. we read a legacy object\n+      // file). Record such init fcns so that we can fix up the graph\n+      // for them (handled later in this function).\n+      if (ii->priority() > 0)\n+\t{\n+\t  level_map::iterator it = inits_at_level.find(ii->priority());\n+\t  if (it == inits_at_level.end())\n+\t    {\n+\t      std::vector<std::string> l;\n+\t      l.push_back(ii->init_name());\n+\t      inits_at_level[ii->priority()] = l;\n+\t    }\n+\t  else\n+\t    it->second.push_back(ii->init_name());\n+\t}\n+    }\n+  this->write_c_string(\";\\n\");\n+\n+  // Create the init graph. Start by populating the graph with\n+  // all the edges we inherited from imported packages.\n+  populate_init_graph(&init_graph, imported_init_fns, init_idx);\n+\n+  // Now add edges from the local init function to each of the\n+  // imported fcns.\n+  if (!import_init_fn.empty())\n+    {\n+      unsigned src = 0;\n+      go_assert(init_idx[import_init_fn] == 0);\n+      for (Import_init_set::const_iterator p = imported_init_fns.begin();\n+           p != imported_init_fns.end();\n+           ++p)\n+\t{\n+          const Import_init* ii = *p;\n+\t  unsigned sink = init_idx[ii->init_name()];\n+\t  add_init_graph_edge(&init_graph, src, sink);\n+\t}\n+    }\n+\n+  // In the scenario where one or more of the packages we imported\n+  // was written with the legacy export data format, add dummy edges\n+  // to capture the priority relationships. Here is a package import\n+  // graph as an example:\n+  //\n+  //       *A\n+  //       /|\n+  //      / |\n+  //     B  *C\n+  //       /|\n+  //      / |\n+  //    *D *E\n+  //     | /|\n+  //     |/ |\n+  //    *F  *G\n+  //\n+  // Let's suppose that the object for package \"C\" is from an old\n+  // gccgo, e.g. it has the old export data format. All other\n+  // packages are compiled with the new compiler and have the new\n+  // format. Packages with *'s have init functions. The scenario is\n+  // that we're compiling a package \"A\"; during this process we'll\n+  // read the export data for \"C\". It should look something like\n+  //\n+  //   init F F..import 1 G G..import 1 D D..import 2 E E..import 2;\n+  //\n+  // To capture this information and convey it to the consumers of\n+  // \"A\", the code below adds edges to the graph from each priority K\n+  // function to every priority K-1 function for appropriate values\n+  // of K. This will potentially add more edges than we need (for\n+  // example, an edge from D to G), but given that we don't expect\n+  // to see large numbers of old objects, this will hopefully be OK.\n+\n+  if (inits_at_level.size() > 0)\n+    {\n+      for (level_map::reverse_iterator it = inits_at_level.rbegin();\n+           it != inits_at_level.rend(); ++it)\n+\t{\n+\t  int level = it->first;\n+\t  if (level < 2) break;\n+\t  const std::vector<std::string>& fcns_at_level = it->second;\n+\t  for (std::vector<std::string>::const_iterator sit =\n+\t           fcns_at_level.begin();\n+\t       sit != fcns_at_level.end(); ++sit)\n+\t    {\n+\t      unsigned src = init_idx[*sit];\n+\t      level_map::iterator it2 = inits_at_level.find(level - 1);\n+\t      if (it2 != inits_at_level.end())\n+\t\t{\n+\t\t  const std::vector<std::string> fcns_at_lm1 = it2->second;\n+\t\t  for (std::vector<std::string>::const_iterator mit =\n+\t\t           fcns_at_lm1.begin();\n+\t\t       mit != fcns_at_lm1.end(); ++mit)\n+\t\t    {\n+\t\t      unsigned sink = init_idx[*mit];\n+\t\t      add_init_graph_edge(&init_graph, src, sink);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  // Write out the resulting graph.\n+  this->write_c_string(\"init_graph\");\n+  for (Init_graph::const_iterator ki = init_graph.begin();\n+       ki != init_graph.end(); ++ki)\n+    {\n+      unsigned src = ki->first;\n+      const std::set<unsigned>& successors = ki->second;\n+      for (std::set<unsigned>::const_iterator vi = successors.begin();\n+           vi != successors.end(); ++vi)\n \t{\n \t  this->write_c_string(\" \");\n-\t  this->write_string(p->package_name());\n+\t  this->write_unsigned(src);\n+\t  unsigned sink = (*vi);\n \t  this->write_c_string(\" \");\n-\t  this->write_string(p->init_name());\n-\t  char buf[100];\n-\t  snprintf(buf, sizeof buf, \" %d\", p->priority());\n-\t  this->write_c_string(buf);\n+\t  this->write_unsigned(sink);\n \t}\n     }\n-\n   this->write_c_string(\";\\n\");\n }\n \n@@ -339,6 +501,26 @@ Export::write_name(const std::string& name)\n     this->write_string(Gogo::message_name(name));\n }\n \n+// Write an integer value to the export stream.\n+\n+void\n+Export::write_int(int value)\n+{\n+  char buf[100];\n+  snprintf(buf, sizeof buf, \"%d\", value);\n+  this->write_c_string(buf);\n+}\n+\n+// Write an integer value to the export stream.\n+\n+void\n+Export::write_unsigned(unsigned value)\n+{\n+  char buf[100];\n+  snprintf(buf, sizeof buf, \"%u\", value);\n+  this->write_c_string(buf);\n+}\n+\n // Export a type.  We have to ensure that on import we create a single\n // Named_type node for each named type.  We do this by keeping a hash\n // table mapping named types to reference numbers.  The first time we\n@@ -531,11 +713,11 @@ Export::Stream::checksum()\n   // Use a union to provide the required alignment.\n   union\n   {\n-    char checksum[Export::v1_checksum_len];\n+    char checksum[Export::checksum_len];\n     long align;\n   } u;\n   sha1_finish_ctx(this->checksum_, u.checksum);\n-  return std::string(u.checksum, Export::v1_checksum_len);\n+  return std::string(u.checksum, Export::checksum_len);\n }\n \n // Write the checksum string to the export data."}, {"sha": "ee61d2752de480397d5cc12eddcefcea5cdc1216", "filename": "gcc/go/gofrontend/export.h", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=c0ccddb46c11be096ab3b843b5b48104a11a7485", "patch": "@@ -15,6 +15,7 @@ class Import_init;\n class Bindings;\n class Type;\n class Package;\n+class Import_init_set;\n \n // Codes used for the builtin types.  These are all negative to make\n // them easily distinct from the codes assigned by Export::write_type.\n@@ -47,6 +48,17 @@ enum Builtin_code\n   SMALLEST_BUILTIN_CODE = -21\n };\n \n+// Export data version number. New export data is written with the\n+// \"current\" version, but there is support for reading files with\n+// older version export data (at least for now).\n+\n+enum Export_data_version {\n+  EXPORT_FORMAT_UNKNOWN = 0,\n+  EXPORT_FORMAT_V1 = 1,\n+  EXPORT_FORMAT_V2 = 2,\n+  EXPORT_FORMAT_CURRENT = EXPORT_FORMAT_V2\n+};\n+\n // This class manages exporting Go declarations.  It handles the main\n // loop of exporting.  A pointer to this class is also passed to the\n // various specific export implementations.\n@@ -103,12 +115,15 @@ class Export : public String_dump\n \n   Export(Stream*);\n \n-  // The magic code for version 1 export data.\n-  static const int v1_magic_len = 4;\n-  static const char v1_magic[v1_magic_len];\n+  // Size of export data magic string (which includes version number).\n+  static const int magic_len = 4;\n \n-  // The length of the v1 checksum string.\n-  static const int v1_checksum_len = 20;\n+  // Magic strings (current version and older v1 version).\n+  static const char cur_magic[magic_len];\n+  static const char v1_magic[magic_len];\n+\n+  // The length of the checksum string.\n+  static const int checksum_len = 20;\n \n   // Register the builtin types.\n   void\n@@ -119,7 +134,6 @@ class Export : public String_dump\n   // is nothing to export, this->stream_->write will not be called.\n   // PREFIX is the package prefix.  PKGPATH is the package path.\n   // Only one of PREFIX and PKGPATH will be non-empty.\n-  // PACKAGE_PRIORITY is the priority to use for this package.\n   // PACKAGES is all the packages we have seen.\n   // IMPORTS is the explicitly imported packages.\n   // IMPORT_INIT_FN is the name of the import initialization function\n@@ -130,11 +144,10 @@ class Export : public String_dump\n   export_globals(const std::string& package_name,\n \t\t const std::string& prefix,\n \t\t const std::string& pkgpath,\n-\t\t int package_priority,\n \t\t const std::map<std::string, Package*>& packages,\n \t\t const std::map<std::string, Package*>& imports,\n \t\t const std::string& import_init_fn,\n-\t\t const std::set<Import_init>& imported_init_fns,\n+\t\t const Import_init_set& imported_init_fns,\n \t\t const Bindings* bindings);\n \n   // Write a string to the export stream.\n@@ -166,6 +179,14 @@ class Export : public String_dump\n   void\n   write_escape(std::string* note);\n \n+  // Write an integer value.\n+  void\n+  write_int(int);\n+\n+  // Write an unsigned value.\n+  void\n+  write_unsigned(unsigned);\n+\n  private:\n   Export(const Export&);\n   Export& operator=(const Export&);\n@@ -174,14 +195,24 @@ class Export : public String_dump\n   void\n   write_packages(const std::map<std::string, Package*>& packages);\n \n+  typedef std::map<unsigned, std::set<unsigned> > Init_graph;\n+\n+  static void\n+  add_init_graph_edge(Init_graph* init_graph, unsigned src, unsigned sink);\n+\n+  static void\n+  populate_init_graph(Init_graph* init_graph,\n+                      const Import_init_set& imported_init_fns,\n+                      const std::map<std::string, unsigned>& init_idx);\n+\n   // Write out the imported packages.\n   void\n   write_imports(const std::map<std::string, Package*>& imports);\n \n-  // Write out the imported initialization functions.\n+  // Write out the imported initialization functions and init graph.\n   void\n-  write_imported_init_fns(const std::string& package_name, int priority,\n-\t\t\t  const std::string&, const std::set<Import_init>&);\n+  write_imported_init_fns(const std::string& package_name,\n+\t\t\t  const std::string&, const Import_init_set&);\n \n   // Register one builtin type.\n   void"}, {"sha": "e1ebd6524d77537a59204be1e1bcbef0b0cb1f0e", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 87, "deletions": 45, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=c0ccddb46c11be096ab3b843b5b48104a11a7485", "patch": "@@ -513,40 +513,49 @@ Gogo::import_package(const std::string& filename,\n   delete stream;\n }\n \n+Import_init *\n+Gogo::lookup_init(const std::string& init_name)\n+{\n+  Import_init tmp(\"\", init_name, -1);\n+  Import_init_set::iterator it = this->imported_init_fns_.find(&tmp);\n+  return (it != this->imported_init_fns_.end()) ? *it : NULL;\n+}\n+\n // Add an import control function for an imported package to the list.\n \n void\n Gogo::add_import_init_fn(const std::string& package_name,\n \t\t\t const std::string& init_name, int prio)\n {\n-  for (std::set<Import_init>::const_iterator p =\n+  for (Import_init_set::iterator p =\n \t this->imported_init_fns_.begin();\n        p != this->imported_init_fns_.end();\n        ++p)\n     {\n-      if (p->init_name() == init_name)\n+      Import_init *ii = (*p);\n+      if (ii->init_name() == init_name)\n \t{\n \t  // If a test of package P1, built as part of package P1,\n \t  // imports package P2, and P2 imports P1 (perhaps\n \t  // indirectly), then we will see the same import name with\n \t  // different import priorities.  That is OK, so don't give\n \t  // an error about it.\n-\t  if (p->package_name() != package_name)\n+\t  if (ii->package_name() != package_name)\n \t    {\n \t      error(\"duplicate package initialization name %qs\",\n \t\t    Gogo::message_name(init_name).c_str());\n-\t      inform(UNKNOWN_LOCATION, \"used by package %qs at priority %d\",\n-\t\t     Gogo::message_name(p->package_name()).c_str(),\n-\t\t     p->priority());\n-\t      inform(UNKNOWN_LOCATION, \" and by package %qs at priority %d\",\n-\t\t     Gogo::message_name(package_name).c_str(), prio);\n+\t      inform(UNKNOWN_LOCATION, \"used by package %qs\",\n+\t\t     Gogo::message_name(ii->package_name()).c_str());\n+\t      inform(UNKNOWN_LOCATION, \" and by package %qs\",\n+\t\t     Gogo::message_name(package_name).c_str());\n \t    }\n-\t  return;\n+          ii->set_priority(prio);\n+          return;\n \t}\n     }\n \n-  this->imported_init_fns_.insert(Import_init(package_name, init_name,\n-\t\t\t\t\t      prio));\n+  Import_init* nii = new Import_init(package_name, init_name, prio);\n+  this->imported_init_fns_.insert(nii);\n }\n \n // Return whether we are at the global binding level.\n@@ -581,6 +590,62 @@ Gogo::current_bindings() const\n     return this->globals_;\n }\n \n+void\n+Gogo::update_init_priority(Import_init* ii,\n+                           std::set<const Import_init *>* visited)\n+{\n+  visited->insert(ii);\n+  int succ_prior = -1;\n+\n+  for (std::set<std::string>::const_iterator pci =\n+           ii->precursors().begin();\n+       pci != ii->precursors().end();\n+       ++pci)\n+    {\n+      Import_init* succ = this->lookup_init(*pci);\n+      if (visited->find(succ) == visited->end())\n+        update_init_priority(succ, visited);\n+      succ_prior = std::max(succ_prior, succ->priority());\n+    }\n+  if (ii->priority() <= succ_prior)\n+    ii->set_priority(succ_prior + 1);\n+}\n+\n+void\n+Gogo::recompute_init_priorities()\n+{\n+  std::set<Import_init *> nonroots;\n+\n+  for (Import_init_set::const_iterator p =\n+           this->imported_init_fns_.begin();\n+       p != this->imported_init_fns_.end();\n+       ++p)\n+    {\n+      const Import_init *ii = *p;\n+      for (std::set<std::string>::const_iterator pci =\n+               ii->precursors().begin();\n+           pci != ii->precursors().end();\n+           ++pci)\n+        {\n+          Import_init* ii = this->lookup_init(*pci);\n+          nonroots.insert(ii);\n+        }\n+    }\n+\n+  // Recursively update priorities starting at roots.\n+  std::set<const Import_init*> visited;\n+  for (Import_init_set::iterator p =\n+           this->imported_init_fns_.begin();\n+       p != this->imported_init_fns_.end();\n+       ++p)\n+    {\n+      Import_init* ii = *p;\n+      if (nonroots.find(ii) != nonroots.end())\n+        continue;\n+      update_init_priority(ii, &visited);\n+    }\n+}\n+\n // Add statements to INIT_STMTS which run the initialization\n // functions for imported packages.  This is only used for the \"main\"\n // package.\n@@ -598,23 +663,27 @@ Gogo::init_imports(std::vector<Bstatement*>& init_stmts)\n       Type::make_function_type(NULL, NULL, NULL, unknown_loc);\n   Btype* fntype = func_type->get_backend_fntype(this);\n \n+  // Recompute init priorities based on a walk of the init graph.\n+  recompute_init_priorities();\n+\n   // We must call them in increasing priority order.\n-  std::vector<Import_init> v;\n-  for (std::set<Import_init>::const_iterator p =\n+  std::vector<const Import_init*> v;\n+  for (Import_init_set::const_iterator p =\n \t this->imported_init_fns_.begin();\n        p != this->imported_init_fns_.end();\n        ++p)\n     v.push_back(*p);\n-  std::sort(v.begin(), v.end());\n+  std::sort(v.begin(), v.end(), priority_compare);\n \n   // We build calls to the init functions, which take no arguments.\n   std::vector<Bexpression*> empty_args;\n-  for (std::vector<Import_init>::const_iterator p = v.begin();\n+  for (std::vector<const Import_init*>::const_iterator p = v.begin();\n        p != v.end();\n        ++p)\n     {\n-      std::string user_name = p->package_name() + \".init\";\n-      const std::string& init_name(p->init_name());\n+      const Import_init* ii = *p;\n+      std::string user_name = ii->package_name() + \".init\";\n+      const std::string& init_name(ii->init_name());\n \n       Bfunction* pfunc = this->backend()->function(fntype, user_name, init_name,\n                                                    true, true, true, false,\n@@ -4326,21 +4395,6 @@ Gogo::check_return_statements()\n   this->traverse(&traverse);\n }\n \n-// Work out the package priority.  It is one more than the maximum\n-// priority of an imported package.\n-\n-int\n-Gogo::package_priority() const\n-{\n-  int priority = 0;\n-  for (Packages::const_iterator p = this->packages_.begin();\n-       p != this->packages_.end();\n-       ++p)\n-    if (p->second->priority() > priority)\n-      priority = p->second->priority();\n-  return priority + 1;\n-}\n-\n // Export identifiers as requested.\n \n void\n@@ -4368,7 +4422,6 @@ Gogo::do_exports()\n   exp.export_globals(this->package_name(),\n \t\t     prefix,\n \t\t     pkgpath,\n-\t\t     this->package_priority(),\n \t\t     this->packages_,\n \t\t     this->imports_,\n \t\t     (this->need_init_fn_ && !this->is_main_package()\n@@ -7595,11 +7648,10 @@ Unnamed_label::get_goto(Translate_context* context, Location location)\n Package::Package(const std::string& pkgpath,\n \t\t const std::string& pkgpath_symbol, Location location)\n   : pkgpath_(pkgpath), pkgpath_symbol_(pkgpath_symbol),\n-    package_name_(), bindings_(new Bindings(NULL)), priority_(0),\n+    package_name_(), bindings_(new Bindings(NULL)),\n     location_(location)\n {\n   go_assert(!pkgpath.empty());\n-  \n }\n \n // Set the package name.\n@@ -7640,16 +7692,6 @@ Package::set_pkgpath_symbol(const std::string& pkgpath_symbol)\n     go_assert(this->pkgpath_symbol_ == pkgpath_symbol);\n }\n \n-// Set the priority.  We may see multiple priorities for an imported\n-// package; we want to use the largest one.\n-\n-void\n-Package::set_priority(int priority)\n-{\n-  if (priority > this->priority_)\n-    this->priority_ = priority;\n-}\n-\n // Note that symbol from this package was and qualified by ALIAS.\n \n void"}, {"sha": "0c45443d3f1c7ff7ddda73875651bf8d5c207ceb", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 54, "deletions": 31, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=c0ccddb46c11be096ab3b843b5b48104a11a7485", "patch": "@@ -78,33 +78,64 @@ class Import_init\n   init_name() const\n   { return this->init_name_; }\n \n-  // The priority of the initialization function.  Functions with a\n-  // lower priority number must be run first.\n+  // Older V1 export data uses a priority scheme to order\n+  // initialization functions; functions with a lower priority number\n+  // must be run first. This value will be set to -1 for current\n+  // generation objects, and will take on a non-negative value only\n+  // when importing a V1-vintage object.\n   int\n   priority() const\n   { return this->priority_; }\n \n+  // Reset priority.\n+  void\n+  set_priority(int new_priority)\n+  { this->priority_ = new_priority; }\n+\n+  // Record the fact that some other init fcn must be run before this init fcn.\n+  void\n+  record_precursor_fcn(std::string init_fcn_name)\n+  { this->precursor_functions_.insert(init_fcn_name); }\n+\n+  // Return the list of precursor fcns for this fcn (must be run before it).\n+  const std::set<std::string>&\n+  precursors() const\n+  { return this->precursor_functions_; }\n+\n  private:\n   // The name of the package being imported.\n   std::string package_name_;\n   // The name of the package's init function.\n   std::string init_name_;\n-  // The priority.\n+  // Names of init functions that must be run before this fcn.\n+  std::set<std::string> precursor_functions_;\n+  // Priority for this function. See note above on obsolescence.\n   int priority_;\n };\n \n // For sorting purposes.\n \n+struct Import_init_lt {\n+  bool operator()(const Import_init* i1, const Import_init* i2)\n+  {\n+    return i1->init_name() < i2->init_name();\n+  }\n+};\n+\n+// Set of import init objects.\n+class Import_init_set : public std::set<Import_init*, Import_init_lt> {\n+};\n+\n inline bool\n-operator<(const Import_init& i1, const Import_init& i2)\n+priority_compare(const Import_init* i1, const Import_init* i2)\n {\n-  if (i1.priority() < i2.priority())\n+  if (i1->priority() < i2->priority())\n     return true;\n-  if (i1.priority() > i2.priority())\n+  if (i1->priority() > i2->priority())\n     return false;\n-  if (i1.package_name() != i2.package_name())\n-    return i1.package_name() < i2.package_name();\n-  return i1.init_name() < i2.init_name();\n+  if (i1->package_name() != i2->package_name())\n+    return i1->package_name() < i2->package_name();\n+  return i1->init_name() < i2->init_name();\n }\n \n // The holder for the internal representation of the entire\n@@ -249,12 +280,6 @@ class Gogo\n   set_debug_escape_level(int level)\n   { this->debug_escape_level_ = level; }\n \n-  // Return the priority to use for the package we are compiling.\n-  // This is two more than the largest priority of any package we\n-  // import.\n-  int\n-  package_priority() const;\n-\n   // Import a package.  FILENAME is the file name argument, LOCAL_NAME\n   // is the local name to give to the package.  If LOCAL_NAME is empty\n   // the declarations are added to the global scope.\n@@ -609,6 +634,10 @@ class Gogo\n   add_import_init_fn(const std::string& package_name,\n \t\t     const std::string& init_name, int prio);\n \n+  // Return the Import_init for a given init name.\n+  Import_init*\n+  lookup_init(const std::string& init_name);\n+\n   // Turn short-cut operators (&&, ||) into explicit if statements.\n   void\n   remove_shortcuts();\n@@ -754,6 +783,15 @@ class Gogo\n     { }\n   };\n \n+  // Recompute init priorities.\n+  void\n+  recompute_init_priorities();\n+\n+  // Recursive helper used by the routine above.\n+  void\n+  update_init_priority(Import_init* ii,\n+                       std::set<const Import_init *>* visited);\n+\n   // The backend generator.\n   Backend* backend_;\n   // The object used to keep track of file names and line numbers.\n@@ -787,7 +825,7 @@ class Gogo\n   // The name of the magic initialization function.\n   std::string init_fn_name_;\n   // A list of import control variables for packages that we import.\n-  std::set<Import_init> imported_init_fns_;\n+  Import_init_set imported_init_fns_;\n   // The package path used for reflection data.\n   std::string pkgpath_;\n   // The package path to use for a symbol name.\n@@ -2875,17 +2913,6 @@ class Package\n     return this->package_name_;\n   }\n \n-  // The priority of this package.  The init function of packages with\n-  // lower priority must be run before the init function of packages\n-  // with higher priority.\n-  int\n-  priority() const\n-  { return this->priority_; }\n-\n-  // Set the priority.\n-  void\n-  set_priority(int priority);\n-\n   // Return the bindings.\n   Bindings*\n   bindings()\n@@ -2977,10 +3004,6 @@ class Package\n   std::string package_name_;\n   // The names in this package.\n   Bindings* bindings_;\n-  // The priority of this package.  A package has a priority higher\n-  // than the priority of all of the packages that it imports.  This\n-  // is used to run init functions in the right order.\n-  int priority_;\n   // The location of the most recent import statement.\n   Location location_;\n   // The set of aliases associated with this package."}, {"sha": "54fd4c95719023bcd2aaa6314029bd2dcea16e2d", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 105, "deletions": 22, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=c0ccddb46c11be096ab3b843b5b48104a11a7485", "patch": "@@ -200,16 +200,15 @@ Import::try_suffixes(std::string* pfilename)\n // Look for export data in the file descriptor FD.\n \n Import::Stream*\n-Import::find_export_data(const std::string& filename, int fd,\n-\t\t\t Location location)\n+Import::find_export_data(const std::string& filename, int fd, Location location)\n {\n   // See if we can read this as an object file.\n   Import::Stream* stream = Import::find_object_export_data(filename, fd, 0,\n \t\t\t\t\t\t\t   location);\n   if (stream != NULL)\n     return stream;\n \n-  const int len = MAX(Export::v1_magic_len, Import::archive_magic_len);\n+  const int len = MAX(Export::magic_len, Import::archive_magic_len);\n \n   if (lseek(fd, 0, SEEK_SET) < 0)\n     {\n@@ -223,7 +222,8 @@ Import::find_export_data(const std::string& filename, int fd,\n     return NULL;\n \n   // Check for a file containing nothing but Go export data.\n-  if (memcmp(buf, Export::v1_magic, Export::v1_magic_len) == 0)\n+  if (memcmp(buf, Export::cur_magic, Export::magic_len) == 0 ||\n+      memcmp(buf, Export::v1_magic, Export::magic_len) == 0)\n     return new Stream_from_file(fd);\n \n   // See if we can read this as an archive.\n@@ -270,7 +270,7 @@ Import::Import(Stream* stream, Location location)\n   : gogo_(NULL), stream_(stream), location_(location), package_(NULL),\n     add_to_globals_(false),\n     builtin_types_((- SMALLEST_BUILTIN_CODE) + 1),\n-    types_()\n+    types_(), version_(EXPORT_FORMAT_UNKNOWN)\n {\n }\n \n@@ -293,8 +293,26 @@ Import::import(Gogo* gogo, const std::string& local_name,\n       // The vector of types is package specific.\n       this->types_.clear();\n \n-      stream->require_bytes(this->location_, Export::v1_magic,\n-\t\t\t    Export::v1_magic_len);\n+      // Check magic string / version number.\n+      if (stream->match_bytes(Export::cur_magic, Export::magic_len))\n+\t{\n+\t  stream->require_bytes(this->location_, Export::cur_magic,\n+\t                        Export::magic_len);\n+\t  this->version_ = EXPORT_FORMAT_CURRENT;\n+\t}\n+      else if (stream->match_bytes(Export::v1_magic, Export::magic_len))\n+\t{\n+\t  stream->require_bytes(this->location_, Export::v1_magic,\n+\t                        Export::magic_len);\n+\t  this->version_ = EXPORT_FORMAT_V1;\n+\t}\n+      else\n+\t{\n+\t  error_at(this->location_,\n+\t           (\"error in import data at %d: invalid magic string\"),\n+\t           stream->pos());\n+\t  return NULL;\n+\t}\n \n       this->require_c_string(\"package \");\n       std::string package_name = this->read_identifier();\n@@ -330,13 +348,16 @@ Import::import(Gogo* gogo, const std::string& local_name,\n \t  return NULL;\n \t}\n \n-      this->require_c_string(\"priority \");\n-      std::string priority_string = this->read_identifier();\n-      int prio;\n-      if (!this->string_to_int(priority_string, false, &prio))\n-\treturn NULL;\n-      this->package_->set_priority(prio);\n-      this->require_c_string(\";\\n\");\n+      // Read and discard priority if older V1 export data format.\n+      if (version() == EXPORT_FORMAT_V1)\n+\t{\n+\t  this->require_c_string(\"priority \");\n+\t  std::string priority_string = this->read_identifier();\n+\t  int prio;\n+\t  if (!this->string_to_int(priority_string, false, &prio))\n+\t    return NULL;\n+\t  this->require_c_string(\";\\n\");\n+\t}\n \n       while (stream->match_c_string(\"package\"))\n \tthis->read_one_package();\n@@ -377,7 +398,7 @@ Import::import(Gogo* gogo, const std::string& local_name,\n       // verify that the checksum matches at link time or at dynamic\n       // load time.\n       this->require_c_string(\"checksum \");\n-      stream->advance(Export::v1_checksum_len * 2);\n+      stream->advance(Export::checksum_len * 2);\n       this->require_c_string(\";\\n\");\n     }\n \n@@ -423,26 +444,88 @@ Import::read_one_import()\n   p->set_package_name(package_name, this->location());\n }\n \n-// Read the list of import control functions.\n+// Read the list of import control functions and/or init graph.\n \n void\n Import::read_import_init_fns(Gogo* gogo)\n {\n   this->require_c_string(\"init\");\n+\n+  // Maps init function to index in the \"init\" clause; needed\n+  // to read the init_graph section.\n+  std::map<std::string, unsigned> init_idx;\n+\n   while (!this->match_c_string(\";\"))\n     {\n+      int priority = -1;\n+\n       this->require_c_string(\" \");\n       std::string package_name = this->read_identifier();\n       this->require_c_string(\" \");\n       std::string init_name = this->read_identifier();\n-      this->require_c_string(\" \");\n-      std::string prio_string = this->read_identifier();\n-      int prio;\n-      if (!this->string_to_int(prio_string, false, &prio))\n-\treturn;\n-      gogo->add_import_init_fn(package_name, init_name, prio);\n+      if (this->version_ == EXPORT_FORMAT_V1)\n+        {\n+          // Older version 1 init fcn export data format is:\n+          //\n+          //   <packname> <fcn> <priority>\n+          this->require_c_string(\" \");\n+          std::string prio_string = this->read_identifier();\n+          if (!this->string_to_int(prio_string, false, &priority))\n+            return;\n+        }\n+      gogo->add_import_init_fn(package_name, init_name, priority);\n+\n+      // Record the index of this init fcn so that we can look it\n+      // up by index in the subsequent init_graph section.\n+      unsigned idx = init_idx.size();\n+      init_idx[init_name] = idx;\n     }\n   this->require_c_string(\";\\n\");\n+\n+  if (this->match_c_string(\"init_graph\"))\n+    {\n+      this->require_c_string(\"init_graph\");\n+\n+      // Build a vector mapping init fcn slot to Import_init pointer.\n+      go_assert(init_idx.size() > 0);\n+      std::vector<Import_init*> import_initvec;\n+      import_initvec.resize(init_idx.size());\n+      for (std::map<std::string, unsigned>::const_iterator it =\n+               init_idx.begin();\n+           it != init_idx.end(); ++it)\n+\t{\n+\t  const std::string& init_name = it->first;\n+\t  Import_init* ii = gogo->lookup_init(init_name);\n+\t  import_initvec[it->second] = ii;\n+\t}\n+\n+      // Init graph format is:\n+      //\n+      //    init_graph <src1> <sink1> <src2> <sink2> ... ;\n+      //\n+      // where src + sink are init functions indices.\n+\n+      while (!this->match_c_string(\";\"))\n+\t{\n+\t  this->require_c_string(\" \");\n+\t  std::string src_string = this->read_identifier();\n+\t  unsigned src;\n+\t  if (!this->string_to_unsigned(src_string, &src)) return;\n+\n+\t  this->require_c_string(\" \");\n+\t  std::string sink_string = this->read_identifier();\n+\t  unsigned sink;\n+\t  if (!this->string_to_unsigned(sink_string, &sink)) return;\n+\n+\t  go_assert(src < import_initvec.size());\n+\t  Import_init* ii_src = import_initvec[src];\n+\t  go_assert(sink < import_initvec.size());\n+\t  Import_init* ii_sink = import_initvec[sink];\n+\n+\t  ii_src->record_precursor_fcn(ii_sink->init_name());\n+\t}\n+      this->require_c_string(\";\\n\");\n+    }\n }\n \n // Import a constant."}, {"sha": "aab4b899ca2d821c4c7e1965adf1767f32b7ce52", "filename": "gcc/go/gofrontend/import.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ccddb46c11be096ab3b843b5b48104a11a7485/gcc%2Fgo%2Fgofrontend%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.h?ref=c0ccddb46c11be096ab3b843b5b48104a11a7485", "patch": "@@ -232,7 +232,7 @@ class Import\n   void\n   read_one_import();\n \n-  // Read the import control functions.\n+  // Read the import control functions and init graph.\n   void\n   read_import_init_fns(Gogo*);\n \n@@ -260,6 +260,21 @@ class Import\n   bool\n   string_to_int(const std::string&, bool is_neg_ok, int* ret);\n \n+  // Get an unsigned integer from a string.\n+  bool\n+  string_to_unsigned(const std::string& s, unsigned* ret)\n+  {\n+    int ivalue;\n+    if (!this->string_to_int(s, false, &ivalue))\n+      return false;\n+    *ret = static_cast<unsigned>(ivalue);\n+    return true;\n+  }\n+\n+  // Return the version number of the export data we're reading.\n+  Export_data_version\n+  version() const { return this->version_; }\n+\n   // The general IR.\n   Gogo* gogo_;\n   // The stream from which to read import data.\n@@ -275,6 +290,8 @@ class Import\n   std::vector<Named_type*> builtin_types_;\n   // Mapping from exported type codes to Type structures.\n   std::vector<Type*> types_;\n+  // Version of export data we're reading.\n+  Export_data_version version_;\n };\n \n // Read import data from a string."}]}