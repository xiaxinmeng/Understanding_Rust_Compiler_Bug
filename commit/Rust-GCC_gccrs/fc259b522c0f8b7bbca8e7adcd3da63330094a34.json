{"sha": "fc259b522c0f8b7bbca8e7adcd3da63330094a34", "node_id": "C_kwDOANBUbNoAKGZjMjU5YjUyMmMwZjhiN2JiY2E4ZTdhZGNkM2RhNjMzMzAwOTRhMzQ", "commit": {"author": {"name": "Jeff Law", "email": "jeffreyalaw@gmail.com", "date": "2022-06-25T16:36:55Z"}, "committer": {"name": "Jeff Law", "email": "jeffreyalaw@gmail.com", "date": "2022-06-25T17:55:21Z"}, "message": "Remove long deprecated tilegx and tilepro ports\n\n/\n\t* MAINTAINERS: Remove tilegx and tilepro entries.\n\t* configure.ac: Remove tilegx and tilepro stanzas.\n\t* configure: Rebuilt.\n\ncontrib/\n\t* config-list.mk: Remove tilegx and tilepro entries.\n\t* gcc_update: Remove tilegx and tilepro entries.\n\ngcc/\n\t* common/config/tilegx/tilegx-common.cc: Removed.\n\t* common/config/tilepro/tilepro-common.cc: Removed.\n\t* config.gcc: Remove tilegx and tilepro entries.\n\t* config/tilegx/constraints.md: Removed.\n\t* config/tilegx/feedback.h: Removed.\n\t* config/tilegx/linux.h: Removed.\n\t* config/tilegx/mul-tables.cc: Removed.\n\t* config/tilegx/predicates.md: Removed.\n\t* config/tilegx/sync.md: Removed.\n\t* config/tilegx/t-tilegx: Removed.\n\t* config/tilegx/tilegx-builtins.h: Removed.\n\t* config/tilegx/tilegx-c.cc: Removed.\n\t* config/tilegx/tilegx-generic.md: Removed.\n\t* config/tilegx/tilegx-modes.def: Removed.\n\t* config/tilegx/tilegx-multiply.h: Removed.\n\t* config/tilegx/tilegx-opts.h: Removed.\n\t* config/tilegx/tilegx-protos.h: Removed.\n\t* config/tilegx/tilegx.cc: Removed.\n\t* config/tilegx/tilegx.h: Removed.\n\t* config/tilegx/tilegx.md: Removed.\n\t* config/tilegx/tilegx.opt: Removed.\n\t* config/tilepro/constraints.md: Removed.\n\t* config/tilepro/feedback.h: Removed.\n\t* config/tilepro/gen-mul-tables.cc: Removed.\n\t* config/tilepro/linux.h: Removed.\n\t* config/tilepro/mul-tables.cc: Removed.\n\t* config/tilepro/predicates.md: Removed.\n\t* config/tilepro/t-tilepro: Removed.\n\t* config/tilepro/tilepro-builtins.h: Removed.\n\t* config/tilepro/tilepro-c.cc: Removed.\n\t* config/tilepro/tilepro-generic.md: Removed.\n\t* config/tilepro/tilepro-modes.def: Removed.\n\t* config/tilepro/tilepro-multiply.h: Removed.\n\t* config/tilepro/tilepro-protos.h: Removed.\n\t* config/tilepro/tilepro.cc: Removed.\n\t* config/tilepro/tilepro.h: Removed.\n\t* config/tilepro/tilepro.md: Removed.\n\t* config/tilepro/tilepro.opt: Removed.\n\t* configure.ac: Remove tilegx and tilepro entries.\n\t* configure: Rebuilt.\n\t* doc/extend.texi: Remove tilegx and tilepro entries.\n\t* doc/install.texi: Remove tilegx and tilepro entries.\n\t* doc/invoke.texi: Remove tilegx and tilepro entries.\n\t* doc/md.texi: Remove tilegx and tilepro entries.\n\ngcc/testsuite/\n\t* gcc.dg/lower-subreg-1.c: Remove tilegx and tilepro entries.\n\t* gcc.misc-tests/linkage.exp: Remove tilegx and\n\ttilepro entries.\n\nlibgcc/\n\t* config.host: Removed tilegx and tilepro entries.\n\t* config/tilegx/sfp-machine.h: Removed.\n\t* config/tilegx/sfp-machine32.h: Removed.\n\t* config/tilegx/sfp-machine64.h: Removed.\n\t* config/tilegx/t-crtstuff: Removed.\n\t* config/tilegx/t-softfp: Removed.\n\t* config/tilegx/t-tilegx: Removed.\n\t* config/tilepro/atomic.c: Removed.\n\t* config/tilepro/atomic.h: Removed.\n\t* config/tilepro/linux-unwind.h: Removed.\n\t* config/tilepro/sfp-machine.h: Removed.\n\t* config/tilepro/softdivide.c: Removed.\n\t* config/tilepro/softmpy.S: Removed.\n\t* config/tilepro/t-crtstuff: Removed.\n\t* config/tilepro/t-tilepro: Removed.", "tree": {"sha": "7644716a05ad6b5875d7b7d7832767af1ce35c24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7644716a05ad6b5875d7b7d7832767af1ce35c24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc259b522c0f8b7bbca8e7adcd3da63330094a34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc259b522c0f8b7bbca8e7adcd3da63330094a34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc259b522c0f8b7bbca8e7adcd3da63330094a34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc259b522c0f8b7bbca8e7adcd3da63330094a34/comments", "author": {"login": "JeffreyALaw", "id": 14062506, "node_id": "MDQ6VXNlcjE0MDYyNTA2", "avatar_url": "https://avatars.githubusercontent.com/u/14062506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeffreyALaw", "html_url": "https://github.com/JeffreyALaw", "followers_url": "https://api.github.com/users/JeffreyALaw/followers", "following_url": "https://api.github.com/users/JeffreyALaw/following{/other_user}", "gists_url": "https://api.github.com/users/JeffreyALaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeffreyALaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeffreyALaw/subscriptions", "organizations_url": "https://api.github.com/users/JeffreyALaw/orgs", "repos_url": "https://api.github.com/users/JeffreyALaw/repos", "events_url": "https://api.github.com/users/JeffreyALaw/events{/privacy}", "received_events_url": "https://api.github.com/users/JeffreyALaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JeffreyALaw", "id": 14062506, "node_id": "MDQ6VXNlcjE0MDYyNTA2", "avatar_url": "https://avatars.githubusercontent.com/u/14062506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeffreyALaw", "html_url": "https://github.com/JeffreyALaw", "followers_url": "https://api.github.com/users/JeffreyALaw/followers", "following_url": "https://api.github.com/users/JeffreyALaw/following{/other_user}", "gists_url": "https://api.github.com/users/JeffreyALaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeffreyALaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeffreyALaw/subscriptions", "organizations_url": "https://api.github.com/users/JeffreyALaw/orgs", "repos_url": "https://api.github.com/users/JeffreyALaw/repos", "events_url": "https://api.github.com/users/JeffreyALaw/events{/privacy}", "received_events_url": "https://api.github.com/users/JeffreyALaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54a5f478487a955c3ffaec3e9164a72599bc1cfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54a5f478487a955c3ffaec3e9164a72599bc1cfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54a5f478487a955c3ffaec3e9164a72599bc1cfb"}], "stats": {"total": 72549, "additions": 7, "deletions": 72542}, "files": [{"sha": "54d8ad41a6f0d392d37e5c61252f0dbe4f186e47", "filename": "MAINTAINERS", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -121,8 +121,6 @@ sh port\t\t\tAlexandre Oliva\t\t<aoliva@gcc.gnu.org>\n sh port\t\t\tOleg Endo\t\t<olegendo@gcc.gnu.org>\n sparc port\t\tDavid S. Miller\t\t<davem@redhat.com>\n sparc port\t\tEric Botcazou\t\t<ebotcazou@libertysurf.fr>\n-tilegx port\t\tWalter Lee\t\t<walt@tilera.com>\n-tilepro port\t\tWalter Lee\t\t<walt@tilera.com>\n v850 port\t\tNick Clifton\t\t<nickc@redhat.com>\n vax port\t\tMatt Thomas\t\t<matt@3am-software.com>\n vax port\t\tMaciej W. Rozycki\t<macro@embecosm.com>"}, {"sha": "097527b8cc0afd38c14c9c60ab775e8a0c3e8b2e", "filename": "configure", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -3056,7 +3056,7 @@ case \"${ENABLE_GOLD}\" in\n       # Check for target supported by gold.\n       case \"${target}\" in\n         i?86-*-* | x86_64-*-* | sparc*-*-* | powerpc*-*-* | arm*-*-* \\\n-        | aarch64*-*-* | tilegx*-*-* | mips*-*-* | s390*-*-* | loongarch*-*-*)\n+        | aarch64*-*-* | mips*-*-* | s390*-*-* | loongarch*-*-*)\n \t  configdirs=\"$configdirs gold\"\n \t  if test x${ENABLE_GOLD} = xdefault; then\n \t    default_ld=gold\n@@ -4017,9 +4017,6 @@ case \"${target}\" in\n   tic6x-*-*)\n     noconfigdirs=\"$noconfigdirs sim\"\n     ;;\n-  tilepro*-*-* | tilegx*-*-*)\n-    noconfigdirs=\"$noconfigdirs sim\"\n-    ;;\n   v810-*-*)\n     noconfigdirs=\"$noconfigdirs bfd binutils gas gdb ld opcodes target-libgloss\"\n     ;;"}, {"sha": "f941b81af7f215e1a909210ce96dc71cc88a5d32", "filename": "configure.ac", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -353,7 +353,7 @@ case \"${ENABLE_GOLD}\" in\n       # Check for target supported by gold.\n       case \"${target}\" in\n         i?86-*-* | x86_64-*-* | sparc*-*-* | powerpc*-*-* | arm*-*-* \\\n-        | aarch64*-*-* | tilegx*-*-* | mips*-*-* | s390*-*-* | loongarch*-*-*)\n+        | aarch64*-*-* | mips*-*-* | s390*-*-* | loongarch*-*-*)\n \t  configdirs=\"$configdirs gold\"\n \t  if test x${ENABLE_GOLD} = xdefault; then\n \t    default_ld=gold\n@@ -1274,9 +1274,6 @@ case \"${target}\" in\n   tic6x-*-*)\n     noconfigdirs=\"$noconfigdirs sim\"\n     ;;\n-  tilepro*-*-* | tilegx*-*-*)\n-    noconfigdirs=\"$noconfigdirs sim\"\n-    ;;\n   v810-*-*)\n     noconfigdirs=\"$noconfigdirs bfd binutils gas gdb ld opcodes target-libgloss\"\n     ;;"}, {"sha": "c4db8dc849a1e073abb3d457e6e9b87beb2cbb15", "filename": "contrib/config-list.mk", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -96,8 +96,6 @@ LIST = aarch64-elf aarch64-linux-gnu aarch64-rtems \\\n   sparc64-sun-solaris2.11OPT-with-gnu-ldOPT-with-gnu-asOPT-enable-threads=posix \\\n   sparc-wrs-vxworks sparc64-elf sparc64-rtems sparc64-linux sparc64-freebsd6 \\\n   sparc64-netbsd sparc64-openbsd \\\n-  tilegx-linux-gnuOPT-enable-obsolete tilegxbe-linux-gnuOPT-enable-obsolete \\\n-  tilepro-linux-gnuOPT-enable-obsolete \\\n   v850e1-elf v850e-elf v850-elf v850-rtems vax-linux-gnu \\\n   vax-netbsdelf visium-elf x86_64-apple-darwin \\\n   x86_64-pc-linux-gnuOPT-with-fpmath=avx \\"}, {"sha": "2ee1bc131674a73350c556e936e74b36afda39a9", "filename": "contrib/gcc_update", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -92,8 +92,6 @@ gcc/config/m68k/m68k-tables.opt: gcc/config/m68k/m68k-devices.def gcc/config/m68\n gcc/config/mips/mips-tables.opt: gcc/config/mips/mips-cpus.def gcc/config/mips/genopt.sh\n gcc/config/rs6000/rs6000-tables.opt: gcc/config/rs6000/rs6000-cpus.def gcc/config/rs6000/genopt.sh\n gcc/config/rs6000/fusion.md: gcc/config/rs6000/genfusion.pl\n-gcc/config/tilegx/mul-tables.cc: gcc/config/tilepro/gen-mul-tables.cc\n-gcc/config/tilepro/mul-tables.cc: gcc/config/tilepro/gen-mul-tables.cc\n # And then, language-specific files\n gcc/cp/cfns.h: gcc/cp/cfns.gperf\n # testsuite"}, {"sha": "3d33b7b0966f878e5ce3b51d7ffbe4466fc22659", "filename": "gcc/common/config/tilegx/tilegx-common.cc", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fcommon%2Fconfig%2Ftilegx%2Ftilegx-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fcommon%2Fconfig%2Ftilegx%2Ftilegx-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Ftilegx%2Ftilegx-common.cc?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,58 +0,0 @@\n-/* Common hooks for TILE-Gx.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"diagnostic-core.h\"\n-#include \"tm.h\"\n-#include \"common/common-target.h\"\n-#include \"common/common-target-def.h\"\n-#include \"opts.h\"\n-#include \"flags.h\"\n-\n-static const struct default_options tilegx_option_optimization_table[] = {\n-  /* Scheduling and bundling are super important for our architecture, so\n-     enable them at -O1. */\n-  {OPT_LEVELS_1_PLUS, OPT_fschedule_insns, NULL, 1},\n-  {OPT_LEVELS_1_PLUS, OPT_fschedule_insns2, NULL, 1},\n-  {OPT_LEVELS_NONE, 0, NULL, 0}\n-};\n-\n-\n-static void\n-tilegx_option_init_struct (struct gcc_options *opts)\n-{\n-  opts->x_flag_asynchronous_unwind_tables = 1;\n-}\n-\n-\n-#undef  TARGET_DEFAULT_TARGET_FLAGS\n-#define TARGET_DEFAULT_TARGET_FLAGS \\\n-  (TARGET_DEFAULT\t\t    \\\n-   | TARGET_ENDIAN_DEFAULT)\n-\n-#undef  TARGET_OPTION_OPTIMIZATION_TABLE\n-#define TARGET_OPTION_OPTIMIZATION_TABLE tilegx_option_optimization_table\n-\n-#undef  TARGET_OPTION_INIT_STRUCT\n-#define TARGET_OPTION_INIT_STRUCT tilegx_option_init_struct\n-\n-struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "8e097362b31fce23aa4c676ab8e94b9b68acef2f", "filename": "gcc/common/config/tilepro/tilepro-common.cc", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fcommon%2Fconfig%2Ftilepro%2Ftilepro-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fcommon%2Fconfig%2Ftilepro%2Ftilepro-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Ftilepro%2Ftilepro-common.cc?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,54 +0,0 @@\n-/* Common hooks for TILEPro.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"diagnostic-core.h\"\n-#include \"tm.h\"\n-#include \"common/common-target.h\"\n-#include \"common/common-target-def.h\"\n-#include \"opts.h\"\n-#include \"flags.h\"\n-\n-static const struct default_options tilepro_option_optimization_table[] = {\n-  /* Scheduling and bundling are super important for our architecture, so\n-     enable them at -O1. */\n-  {OPT_LEVELS_1_PLUS, OPT_fschedule_insns, NULL, 1},\n-  {OPT_LEVELS_1_PLUS, OPT_fschedule_insns2, NULL, 1},\n-  {OPT_LEVELS_NONE, 0, NULL, 0}\n-};\n-\n-\n-static void\n-tilepro_option_init_struct (struct gcc_options *opts)\n-{\n-  opts->x_flag_asynchronous_unwind_tables = 1;\n-}\n-\n-\n-\n-#undef  TARGET_OPTION_OPTIMIZATION_TABLE\n-#define TARGET_OPTION_OPTIMIZATION_TABLE tilepro_option_optimization_table\n-\n-#undef  TARGET_OPTION_INIT_STRUCT\n-#define TARGET_OPTION_INIT_STRUCT tilepro_option_init_struct\n-\n-struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "4e3b15bb5e952d0b39429ae1e8f3ebe89a8347ce", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -248,8 +248,7 @@ md_file=\n \n # Obsolete configurations.\n case ${target} in\n-  tile*-*-*\t\t\t\t\\\n- | cr16-*-*\t\t\t\t\\\n+ cr16-*-*\t\t\t\t\\\n  | hppa[12]*-*-hpux10*\t\t\t\\\n  | hppa[12]*-*-hpux11*\t\t\t\\\n  | m32c-*-rtems*\t\t\t\\\n@@ -557,12 +556,6 @@ tic6x-*-*)\n xtensa*-*-*)\n \textra_options=\"${extra_options} fused-madd.opt\"\n \t;;\n-tilegx*-*-*)\n-\tcpu_type=tilegx\n-\t;;\n-tilepro*-*-*)\n-\tcpu_type=tilepro\n-\t;;\n esac\n \n tm_file=${cpu_type}/${cpu_type}.h\n@@ -3477,27 +3470,6 @@ tic6x-*-uclinux)\n \ttmake_file=\"${tmake_file} c6x/t-c6x c6x/t-c6x-elf c6x/t-c6x-uclinux\"\n \tuse_collect2=no\n \t;;\n-tilegx*-*-linux*)\n-\ttm_file=\"elfos.h gnu-user.h linux.h glibc-stdint.h tilegx/linux.h ${tm_file}\"\n-        tmake_file=\"${tmake_file} tilegx/t-tilegx\"\n-\textra_objs=\"${extra_objs} mul-tables.o\"\n-\tc_target_objs=\"${c_target_objs} tilegx-c.o\"\n-\tcxx_target_objs=\"${cxx_target_objs} tilegx-c.o\"\n-\textra_headers=\"feedback.h\"\n-\tcase $target in\n-\ttilegxbe-*)\n-\t\ttm_defines=\"${tm_defines} TARGET_BIG_ENDIAN_DEFAULT=1\"\n- \t\t;;\n-\tesac\n-\t;;\n-tilepro*-*-linux*)\n-\ttm_file=\"elfos.h gnu-user.h linux.h glibc-stdint.h tilepro/linux.h ${tm_file}\"\n-        tmake_file=\"${tmake_file} tilepro/t-tilepro\"\n-\textra_objs=\"${extra_objs} mul-tables.o\"\n-\tc_target_objs=\"${c_target_objs} tilepro-c.o\"\n-\tcxx_target_objs=\"${cxx_target_objs} tilepro-c.o\"\n-\textra_headers=\"feedback.h\"\n-\t;;\n v850-*-rtems*)\n \ttarget_cpu_default=\"TARGET_CPU_generic\"\n \ttm_file=\"elfos.h v850/v850.h\""}, {"sha": "dee57d8a74813b1d345e1e4946998f4b4317ba35", "filename": "gcc/config/tilegx/constraints.md", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Fconstraints.md?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,115 +0,0 @@\n-;; Constraint definitions for Tilera TILE-Gx.\n-;; Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-;; Contributed by Walter Lee (walt@tilera.com)\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify it\n-;; under the terms of the GNU General Public License as published\n-;; by the Free Software Foundation; either version 3, or (at your\n-;; option) any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-;; License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-(define_register_constraint \"R00\" \"R0_REGS\"  \"r0\")\n-(define_register_constraint \"R01\" \"R1_REGS\"  \"r1\")\n-(define_register_constraint \"R02\" \"R2_REGS\"  \"r2\")\n-(define_register_constraint \"R03\" \"R3_REGS\"  \"r3\")\n-(define_register_constraint \"R04\" \"R4_REGS\"  \"r4\")\n-(define_register_constraint \"R05\" \"R5_REGS\"  \"r5\")\n-(define_register_constraint \"R06\" \"R6_REGS\"  \"r6\")\n-(define_register_constraint \"R07\" \"R7_REGS\"  \"r7\")\n-(define_register_constraint \"R08\" \"R8_REGS\"  \"r8\")\n-(define_register_constraint \"R09\" \"R9_REGS\"  \"r9\")\n-(define_register_constraint \"R10\" \"R10_REGS\" \"r10\")\n-\n-(define_constraint \"I\"\n-  \"A signed 8 bit constant\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -128 && ival <= 127\")))\n-\n-(define_constraint \"J\"\n-  \"Signed 16-bit integer constant\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -32768 && ival <= 32767\")))\n-\n-(define_constraint \"K\"\n-  \"Unsigned 16-bit integer constant\"\n-  (and (match_code \"const_int\")\n-       (match_test \"(ival >= 0 && ival <= 65535)\")))\n-\n-(define_constraint \"L\"\n-  \"Integer constant that fits in one signed byte when incremented\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -129 && ival <= 126\")))\n-\n-(define_constraint \"M\"\n-  \"A bit mask suitable for 'bfins'\"\n-  (and (match_code \"const_int\")\n-       (match_test \"tilegx_bitfield_operand_p (ival, NULL, NULL)\")))\n-\n-(define_constraint \"N\"\n-  \"Integer constant that is a byte tiled out eight times\"\n-  (and (match_code \"const_int\")\n-       (match_test \"(ival == (ival & 0xFF) * 0x0101010101010101LL)\")))\n-\n-(define_constraint \"O\"\n- \"The integer zero constant\"\n- (and (match_code \"const_int\")\n-      (match_test \"ival == 0\")))\n-\n-(define_constraint \"P\"\n-  \"Integer constant that is a sign-extended byte tiled out as four shorts\"\n-  (and (match_code \"const_int\")\n-       (match_test \"(ival\n-                     == ((trunc_int_for_mode (ival, QImode) & 0xFFFF)\n-                         * 0x0001000100010001LL))\")))\n-\n-(define_constraint \"Q\"\n-  \"Integer constant that fits in one signed byte when incremented, but not -1\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -129 && ival <= 126 && ival != -1\")))\n-\n-(define_constraint \"S\"\n-  \"Integer constant that has all 1 bits consecutive and starting at bit 0\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival != 0 && (ival & (ival + 1)) == 0\")))\n-\n-(define_constraint \"T\"\n-  \"An unspec wrapper for a symbolc operand\"\n-  (ior (match_operand 0 \"const_last_symbolic_operand\")\n-       (match_operand 0 \"const_symbolic_operand\")))\n-\n-(define_memory_constraint \"U\"\n-  \"Non-auto-incrementing memory\"\n-  (and (match_code \"mem\")\n-       (match_test \"GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC\")))\n-\n-(define_constraint \"W\"\n-  \"An 8-element vector constant with identical elements\"\n-  (and (match_code \"const_vector\")\n-       (match_test \"CONST_VECTOR_NUNITS (op) == 8\")\n-       (match_test \"const_vec_duplicate_p (op)\")))\n-\n-(define_constraint \"Y\"\n-  \"A 4-element vector constant with identical elements\"\n-  (and (match_code \"const_vector\")\n-       (match_test \"CONST_VECTOR_NUNITS (op) == 4\")\n-       (match_test \"const_vec_duplicate_p (op)\")))\n-\n-(define_constraint \"Z0\"\n- \"The integer constant 0xffffffff\"\n- (and (match_code \"const_int\")\n-      (match_test \"ival == 0xffffffff\")))\n-\n-(define_constraint \"Z1\"\n- \"The integer constant 0xffffffff00000000\"\n- (and (match_code \"const_int\")\n-      (match_test \"ival == (HOST_WIDE_INT)0xffffffff00000000LL\")))"}, {"sha": "34e48ed8895c277dd5ed5c629ff2418ebe0106e7", "filename": "gcc/config/tilegx/feedback.h", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ffeedback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ffeedback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ffeedback.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,14 +0,0 @@\n-#ifndef _FEEDBACK_H\n-#define _FEEDBACK_H 1\n-\n-#ifdef __ASSEMBLER__\n-\n-/* Stub defines for feedback instrumentation.  */\n-#define FEEDBACK_ENTER_EXPLICIT(FUNCNAME, SECNAME, SIZE)\n-#define FEEDBACK_ENTER(FUNCNAME)\n-#define FEEDBACK_REENTER(FUNCNAME)\n-#define FEEDBACK_ENTRY(FUNCNAME, SECNAME, SIZE)\n-\n-#endif /* __ASSEMBLER__ */\n-\n-#endif /* _FEEDBACK_H */"}, {"sha": "aae1f9520997040171cf49189bab42f9dd9414b7", "filename": "gcc/config/tilegx/linux.h", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Flinux.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,83 +0,0 @@\n-/* Definitions for TILE-Gx running Linux-based GNU systems with ELF.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC \"%{pthread:-D_REENTRANT}\"\n-\n-#undef ASM_SPEC\n-#define ASM_SPEC \"%(endian_spec) %{m32:--32} %{m64:--64}\"\n-\n-#undef\tLINK_SPEC\n-#define LINK_SPEC \"%(endian_spec) \\\n-  %{m64:-m elf64tilegx} %{m32:-m elf32tilegx} \\\n-  %{shared:-shared} \\\n-  %{!shared: \\\n-    %{!static: \\\n-      %{rdynamic:-export-dynamic} \\\n-      -dynamic-linker \\\n-        %{ m32: /lib32/ld.so.1} \\\n-        %{!m32: /lib/ld.so.1}} \\\n-    %{static:-static}}\"\n-\n-#define MULTILIB_DEFAULTS { \"m64\" }\n-\n-#define NO_PROFILE_COUNTERS\t1\n-\n-#undef MCOUNT_NAME\n-#define MCOUNT_NAME \"__mcount\"\n-\n-#undef NEED_INDICATE_EXEC_STACK\n-#define NEED_INDICATE_EXEC_STACK 1\n-\n-#ifdef TARGET_LIBC_PROVIDES_SSP\n-/* TILE-Gx glibc provides __stack_chk_guard two pointer-size words before\n-   tp. */\n-#define TARGET_THREAD_SSP_OFFSET (-2 * GET_MODE_SIZE (ptr_mode))\n-#endif\n-\n-/* For __clear_cache in libgcc2.c.  */\n-#ifdef IN_LIBGCC2\n-\n-/* Use the minimum page size of 4K.  Alternatively we can call\n-   getpagesize() but it introduces a libc dependence.\n-   See Linux arch/tile/include/uapi/arch/icache.h for more commentary.  */\n-#undef CLEAR_INSN_CACHE\n-#define CLEAR_INSN_CACHE(BEG, END)                                      \\\n-{                                                                       \\\n-  long size = (long) (END) - (long) (BEG);                              \\\n-  if (size)                                                             \\\n-    {                                                                   \\\n-      const char *p = (const char *) ((unsigned long) (BEG) & -64L);    \\\n-      const char *end = p + (size < 4096 ? size : 4096) - 1;            \\\n-      __insn_mf ();                                                     \\\n-      for (; p <= end; p += 64)                                         \\\n-        __insn_icoh (p);                                                \\\n-      __insn_drain ();                                                  \\\n-    }                                                                   \\\n-}\n-\n-#else\n-\n-/* define CLEAR_INSN_CACHE so that gcc knows to expand __builtin__clear_cache\n-   to the libraray call.  */\n-#undef CLEAR_INSN_CACHE\n-#define CLEAR_INSN_CACHE 1\n-\n-#endif"}, {"sha": "67f85ce70e85412d5096a17398459178578d1192", "filename": "gcc/config/tilegx/mul-tables.cc", "status": "removed", "additions": 0, "deletions": 27249, "changes": 27249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Fmul-tables.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Fmul-tables.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Fmul-tables.cc?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb"}, {"sha": "f21ddabbe2ce9158e4573f8a902cd0247a99b216", "filename": "gcc/config/tilegx/predicates.md", "status": "removed", "additions": 0, "deletions": 290, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Fpredicates.md?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,290 +0,0 @@\n-;; Predicate definitions for Tilera TILE-Gx.\n-;; Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-;; Contributed by Walter Lee (walt@tilera.com)\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify it\n-;; under the terms of the GNU General Public License as published\n-;; by the Free Software Foundation; either version 3, or (at your\n-;; option) any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-;; License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-;; Return true if OP is the zero constant for MODE.\n-(define_predicate \"const_zero_operand\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"op == CONST0_RTX (mode)\")))\n-\n-;; Returns true if OP is either the constant zero or a register.\n-(define_predicate \"reg_or_0_operand\"\n-  (and (ior (match_operand 0 \"register_operand\")\n-\t    (match_operand 0 \"const_zero_operand\"))\n-       (match_test \"GET_MODE_SIZE (mode) <= UNITS_PER_WORD\")))\n-\n-; Return 1 if OP is a valid Pmode pointer.\n-(define_predicate \"pointer_operand\"\n-  (and (match_operand 0 \"address_operand\")\n-       (ior (match_operand 0 \"pmode_register_operand\")\n-\t    (match_operand 0 \"const_zero_operand\"))))\n-\n-; Return 1 if OP is a network register identifier.\n-(define_predicate \"netreg_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"IN_RANGE (INTVAL (op), 0, 5)\")))\n-\n-; Return 1 if OP is an unsigned 6-bit constant.\n-(define_predicate \"u6bit_cint_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"INTVAL (op) == (INTVAL (op) & 0x3F)\")))\n-\n-;; Return 1 if OP is an unsigned 16-bit constant.\n-(define_predicate \"u16bit_cint_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"(unsigned HOST_WIDE_INT)INTVAL (op) < (1U << 16)\")))\n-\n-;; Return 1 if OP is a signed 8-bit constant.\n-(define_predicate \"s8bit_cint_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"satisfies_constraint_I (op)\")))\n-\n-;; Return 1 if OP is a signed 16-bit constant.\n-(define_predicate \"s16bit_cint_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"satisfies_constraint_J (op)\")))\n-\n-;; Return 1 if OP is an unsigned 14-bit constant.\n-(define_predicate \"u14bit_cint_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"(unsigned HOST_WIDE_INT)INTVAL (op) < (1U << 14)\")))\n-\n-;; Return 1 if OP is a constant or any register.\n-(define_predicate \"reg_or_cint_operand\"\n-  (ior (match_operand 0 \"register_operand\")\n-       (match_operand 0 \"const_int_operand\")))\n-\n-;; Returns 1 if OP is a \"last\" unspec wrapper for a symbol, got, or\n-;; tls reference.\n-(define_predicate \"const_last_symbolic_operand\"\n-  (and (match_code \"const\")\n-       (match_test \"GET_CODE (XEXP (op,0)) == UNSPEC\")\n-       (ior (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_LAST\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW2_LAST\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_PCREL\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW2_LAST_PCREL\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_LAST_GOT\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_GOT\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_TLS_GD\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_TLS_IE\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_TLS_LE\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_PLT_PCREL\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW2_LAST_PLT_PCREL\"))))\n-\n-;; Returns 1 if OP is an unspec wrapper for a symbol, got, or tls\n-;; reference.\n-(define_predicate \"const_symbolic_operand\"\n-  (and (match_code \"const\")\n-       (match_test \"GET_CODE (XEXP (op,0)) == UNSPEC\")\n-       (ior (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW2\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW3\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_PCREL\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_PCREL\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_GOT\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_TLS_GD\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_TLS_IE\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_TLS_LE\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_PLT_PCREL\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_PLT_PCREL\"))))\n-\n-;; Return 1 if OP is a 8-element vector constant with identical signed\n-;; 8-bit elements or any register.\n-(define_predicate \"reg_or_v8s8bit_operand\"\n-  (ior (match_operand 0 \"register_operand\")\n-       (and (match_code \"const_vector\")\n-\t    (match_test \"CONST_VECTOR_NUNITS (op) == 8\n-                         && (satisfies_constraint_I\n-\t\t\t     (unwrap_const_vec_duplicate (op)))\"))))\n-\n-;; Return 1 if OP is a 4-element vector constant with identical signed\n-;; 8-bit elements or any register.\n-(define_predicate \"reg_or_v4s8bit_operand\"\n-  (ior (match_operand 0 \"register_operand\")\n-       (and (match_code \"const_vector\")\n-\t    (match_test \"CONST_VECTOR_NUNITS (op) == 4\n-                         && (satisfies_constraint_I\n-\t\t\t     (unwrap_const_vec_duplicate (op)))\"))))\n-\n-;; Return 1 if the operand is a valid second operand to an add insn.\n-(define_predicate \"add_operand\"\n-  (if_then_else (match_code \"const_int\")\n-    (match_test \"satisfies_constraint_J (op)\")\n-    (ior (match_operand 0 \"register_operand\")\n-\t (match_operand 0 \"const_last_symbolic_operand\"))))\n-\n-;; Return 1 if the operand is a register or signed 8-bit immediate operand.\n-(define_predicate \"reg_or_s8bit_operand\"\n-  (if_then_else (match_code \"const_int\")\n-    (match_test \"satisfies_constraint_I (op)\")\n-    (match_operand 0 \"register_operand\")))\n-\n-;; Return 1 if the operand is a register or unsigned 5-bit immediate operand.\n-(define_predicate \"reg_or_u5bit_operand\"\n-  (if_then_else (match_code \"const_int\")\n-    (match_test \"INTVAL (op) == (INTVAL (op) & 0x1F)\")\n-    (match_operand 0 \"register_operand\")))\n-\n-;; Return 1 if the operand is a register or unsigned 6-bit immediate operand.\n-(define_predicate \"reg_or_u6bit_operand\"\n-  (if_then_else (match_code \"const_int\")\n-    (match_test \"INTVAL (op) == (INTVAL (op) & 0x3F)\")\n-    (match_operand 0 \"register_operand\")))\n-\n-;; Return 1 for an operand suitable for ANDing with a register.\n-(define_predicate \"and_operand\"\n-  (if_then_else (match_code \"const_int\")\n-    (match_test \"satisfies_constraint_I (op) || satisfies_constraint_M (op)\")\n-    (match_operand 0 \"register_operand\")))\n-\n-; Return 1 if the operand is 2, 4 or 8.\n-(define_predicate \"cint_248_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test\n-        \"INTVAL (op) == 2 || INTVAL (op) == 4 || INTVAL (op) == 8\")))\n-\n-;; Return true if OP is a TLS symbolic operand.\n-(define_predicate \"tls_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) !=  TLS_MODEL_NONE\")))\n-\n-;; Return true if OP is a symbolic operand for the TLS Global Dynamic model.\n-(define_predicate \"tls_gd_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_GLOBAL_DYNAMIC\")))\n-\n-;; Return true if OP is a symbolic operand for the TLS Local Dynamic model.\n-(define_predicate \"tls_ld_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_DYNAMIC\")))\n-\n-;; Return true if OP is a symbolic operand that can be used for the\n-;; TLS Initial Exec model.\n-(define_predicate \"tls_ie_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (ior (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_INITIAL_EXEC\")\n-            (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC\"))))\n-\n-;; Return true if OP is a symbolic operand for the TLS Local Exec model.\n-(define_predicate \"tls_le_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC\")))\n-\n-;; Returns true if OP is any general operand except for an\n-;; auto-incrementing address operand.\n-(define_predicate \"nonautoinc_operand\"\n-  (and (match_operand 0 \"general_operand\")\n-       (not (ior (match_code \"pre_dec\") (match_code \"pre_inc\")\n-\t\t (match_code \"post_dec\") (match_code \"post_inc\")\n-\t\t (match_code \"post_modify\") (match_code \"pre_modify\")))))\n- \n-;; Returns true if OP is a non-auto-incrementing memory operand.\n-(define_predicate \"nonautoincmem_operand\"\n-  (match_operand 0 \"memory_operand\")\n-{\n-  return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n-})\n-\n-;; Returns true if OP is a non-auto-incrementing memory, general\n-;; operand.\n-(define_predicate \"nonautoincmem_general_operand\"\n-  (match_operand 0 \"general_operand\")\n-{\n-  if (memory_operand (op, mode))\n-    return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n-  else\n-    return true;\n-})\n- \n-;; Returns true if OP is a non-auto-incrementing memory, non-immediate\n-;; operand.\n-(define_predicate \"nonautoincmem_nonimmediate_operand\"\n-  (match_operand 0 \"nonimmediate_operand\")\n-{\n-  if (memory_operand (op, mode))\n-    return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n-  else\n-    return true;\n-})\n- \n-;; Return true if OP is a valid operand for the source of a move insn.\n-(define_predicate \"move_operand\"\n-  (match_operand 0 \"general_operand\")\n-{\n-  /* If both modes are non-void they must be the same.  */\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return false;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_INT:\n-      return (satisfies_constraint_J (op)\n-              || satisfies_constraint_K (op)\n-              || (mode == DImode &&\n-                  (satisfies_constraint_N (op)\n-                   || satisfies_constraint_P (op))));\n-\n-    case MEM:\n-      return memory_address_p (mode, XEXP (op, 0));\n-\n-    case CONST:\n-      return const_last_symbolic_operand (op, mode);\n-\n-    default:\n-      return register_operand (op, mode);\n-    }\n-})\n-\n-;; Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n-;; possibly with an offset.\n-(define_predicate \"symbolic_operand\"\n-  (ior (match_code \"symbol_ref,label_ref\")\n-       (and (match_code \"const\")\n-\t    (match_test \"GET_CODE (XEXP (op,0)) == PLUS\n-\t\t\t && (GET_CODE (XEXP (XEXP (op,0), 0)) == SYMBOL_REF\n-\t\t\t     || GET_CODE (XEXP (XEXP (op,0), 0)) == LABEL_REF)\n-\t\t\t && CONST_INT_P (XEXP (XEXP (op,0), 1))\"))))\n-\n-;; Return 1 for an unsigned 16 bit or a const symbolc operand.\n-(define_predicate \"u16bit_or_const_symbolic_operand\"\n-  (ior (match_operand 0 \"u16bit_cint_operand\")\n-       (match_operand 0 \"const_symbolic_operand\")))\n-\n-;; Return true if OP is an address suitable for a call insn.\n-;; Call insn on TILE can take a PC-relative constant address\n-;; or any regular memory address.\n-(define_predicate \"call_address_operand\"\n-  (ior (match_operand 0 \"symbolic_operand\")\n-       (match_test \"memory_address_p (Pmode, op)\")))\n-\n-;; Return true if OP is an operand suitable for a call insn.\n-(define_predicate \"call_operand\"\n-  (and (match_code \"mem\")\n-       (match_test \"call_address_operand (XEXP (op, 0), mode)\")))\n-\n-;; Return 1 if OP is a signed comparison operation.\n-;; We can use these directly in compares against zero.\n-(define_predicate \"signed_comparison_operator\"\n-  (match_code \"eq,ne,le,lt,ge,gt\"))\n-\n-;; Return 1 if OP is a equal or not-equal operation.\n-(define_predicate \"eqne_operator\"\n-  (match_code \"eq,ne\"))"}, {"sha": "74be4c906ee23d09bfaa681e815babf95b8e3b13", "filename": "gcc/config/tilegx/sync.md", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Fsync.md?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,227 +0,0 @@\n-;; GCC machine description for Tilera TILE-Gx synchronization\n-;; instructions.\n-;; Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-;; Contributed by Walter Lee (walt@tilera.com)\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify it\n-;; under the terms of the GNU General Public License as published\n-;; by the Free Software Foundation; either version 3, or (at your\n-;; option) any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-;; License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-(define_code_iterator fetchop [plus ior and])\n-(define_code_attr fetchop_name [(plus \"add\") (ior \"or\") (and \"and\")])\n-\n-(define_insn \"mtspr_cmpexch<mode>\"\n-  [(set (reg:I48MODE TILEGX_CMPEXCH_REG)\n-        (unspec_volatile:I48MODE\n-         [(match_operand:I48MODE 0 \"reg_or_0_operand\" \"rO\")]\n-         UNSPEC_SPR_MOVE))]\n-  \"\"\n-  \"mtspr\\tCMPEXCH_VALUE, %r0\"\n-  [(set_attr \"type\" \"X1\")])\n-\n-\n-(define_expand \"atomic_compare_and_swap<mode>\"\n-  [(match_operand:DI 0 \"register_operand\" \"\")\t\t;; bool output\n-   (match_operand:I48MODE 1 \"register_operand\" \"\")\t;; val output\n-   (match_operand:I48MODE 2 \"nonautoincmem_operand\" \"\") ;; memory\n-   (match_operand:I48MODE 3 \"reg_or_0_operand\" \"\")\t;; expected value\n-   (match_operand:I48MODE 4 \"reg_or_0_operand\" \"\")\t;; desired value\n-   (match_operand:SI 5 \"const_int_operand\" \"\")\t\t;; is_weak\n-   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; mod_s\n-   (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t;; mod_f\n-  \"\"\n-{\n-  enum memmodel mod_s = (enum memmodel) INTVAL (operands[6]);\n-\n-  if (operands[3] != const0_rtx)\n-    operands[3] = force_reg (<MODE>mode, operands[3]);\n-  if (operands[4] != const0_rtx)\n-    operands[4] = force_reg (<MODE>mode, operands[4]);\n-\n-  tilegx_pre_atomic_barrier (mod_s);\n-  emit_insn (gen_mtspr_cmpexch<mode> (operands[3]));\n-  emit_insn (gen_atomic_compare_and_swap_bare<mode> (operands[1], operands[2],\n-                                                   operands[4]));\n-  tilegx_post_atomic_barrier (mod_s);\n-  emit_insn (gen_insn_cmpeq_<mode>di (operands[0], operands[1], operands[3]));\n-  DONE;\n-})\n-\n-\n-(define_insn \"atomic_compare_and_swap_bare<mode>\"\n-  [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n-        (match_operand:I48MODE 1 \"nonautoincmem_operand\" \"+U\"))\n-   (set (match_dup 1)\n-        (unspec_volatile:I48MODE\n-         [(match_dup 1)\n-         (reg:I48MODE TILEGX_CMPEXCH_REG)\n-         (match_operand:I48MODE 2 \"reg_or_0_operand\" \"rO\")]\n-         UNSPEC_CMPXCHG))]\n-  \"\"\n-  \"cmpexch<four_if_si>\\t%0, %1, %r2\"\n-  [(set_attr \"type\" \"X1_remote\")])\n-\n-\n-(define_expand \"atomic_exchange<mode>\"\n-  [(match_operand:I48MODE 0 \"register_operand\" \"\")      ;; result\n-   (match_operand:I48MODE 1 \"nonautoincmem_operand\" \"\") ;; memory\n-   (match_operand:I48MODE 2 \"reg_or_0_operand\" \"\")      ;; input\n-   (match_operand:SI 3 \"const_int_operand\" \"\")]         ;; model\n-  \"\"\n-{\n-  enum memmodel model = (enum memmodel) INTVAL (operands[3]);\n-\n-  tilegx_pre_atomic_barrier (model);\n-  emit_insn (gen_atomic_exchange_bare<mode> (operands[0], operands[1],\n-                                             operands[2]));\n-  tilegx_post_atomic_barrier (model);\n-  DONE;\n-})\n-\n-\n-(define_insn \"atomic_exchange_bare<mode>\"\n-  [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n-\t(match_operand:I48MODE 1 \"nonautoincmem_operand\" \"+U\"))\n-   (set (match_dup 1)\n-\t(unspec_volatile:I48MODE\n-\t [(match_operand:I48MODE 2 \"reg_or_0_operand\" \"rO\")]\n-\t UNSPEC_XCHG))]\n-  \"\"\n-  \"exch<four_if_si>\\t%0, %1, %r2\"\n-  [(set_attr \"type\" \"X1_remote\")])\n-\n-\n-(define_expand \"atomic_fetch_<fetchop_name><mode>\"\n-  [(match_operand:I48MODE 0 \"register_operand\" \"\")      ;; result\n-   (match_operand:I48MODE 1 \"nonautoincmem_operand\" \"\") ;; memory\n-   (unspec_volatile:I48MODE\n-    [(fetchop:I48MODE\n-      (match_dup 1)\n-      (match_operand:I48MODE 2 \"reg_or_0_operand\" \"\"))] ;; value\n-    UNSPEC_ATOMIC)\n-   (match_operand:SI 3 \"const_int_operand\" \"\")]         ;; model\n-  \"\"\n-{\n-  enum memmodel model = (enum memmodel) INTVAL (operands[3]);\n-\n-  tilegx_pre_atomic_barrier (model);\n-  emit_insn (gen_atomic_fetch_<fetchop_name>_bare<mode> (operands[0],\n-                                                         operands[1],\n-                                                         operands[2]));\n-  tilegx_post_atomic_barrier (model);\n-  DONE;\n-})\n-\n-\n-(define_insn \"atomic_fetch_<fetchop_name>_bare<mode>\"\n-  [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n-\t(match_operand:I48MODE 1 \"nonautoincmem_operand\" \"+U\"))\n-   (set (match_dup 1)\n-\t(unspec_volatile:I48MODE\n-\t [(fetchop:I48MODE\n-\t   (match_dup 1)\n-\t   (match_operand:I48MODE 2 \"reg_or_0_operand\" \"rO\"))]\n-\t   UNSPEC_ATOMIC))]\n-  \"\"\n-  \"fetch<fetchop_name><four_if_si>\\t%0, %1, %r2\"\n-  [(set_attr \"type\" \"X1_remote\")])\n-\n-\n-(define_expand \"atomic_fetch_sub<mode>\"\n-  [(match_operand:I48MODE 0 \"register_operand\" \"\")      ;; result\n-   (match_operand:I48MODE 1 \"nonautoincmem_operand\" \"\") ;; memory\n-   (unspec_volatile:I48MODE\n-    [(minus:I48MODE\n-      (match_dup 1)\n-      (match_operand:I48MODE 2 \"reg_or_0_operand\" \"\"))] ;; value\n-    UNSPEC_ATOMIC)\n-   (match_operand:SI 3 \"const_int_operand\" \"\")]         ;; model\n-  \"\"\n-{\n-  rtx addend;\n-  enum memmodel model = (enum memmodel) INTVAL (operands[3]);\n-\n-  if (operands[2] != const0_rtx)\n-    {\n-       addend = gen_reg_rtx (<MODE>mode);\n-       emit_move_insn (addend,\n-                       gen_rtx_MINUS (<MODE>mode, const0_rtx, operands[2]));\n-    }\n-  else\n-    addend = operands[2];\n-\n-  tilegx_pre_atomic_barrier (model);\n-  emit_insn (gen_atomic_fetch_add_bare<mode> (operands[0],\n-                                              operands[1],\n-                                              addend));\n-  tilegx_post_atomic_barrier (model);\n-  DONE;\n-})\n-\n-\n-(define_expand \"atomic_test_and_set\"\n-  [(match_operand:QI 0 \"register_operand\" \"\")           ;; bool output\n-   (match_operand:QI 1 \"nonautoincmem_operand\" \"+U\")    ;; memory\n-   (match_operand:SI 2 \"const_int_operand\" \"\")]         ;; model\n-  \"\"\n-{\n-  rtx addr, aligned_addr, aligned_mem, offset, word, shmt, tmp;\n-  rtx result = operands[0];\n-  rtx mem = operands[1];\n-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n-\n-  addr = force_reg (Pmode, XEXP (mem, 0));\n-\n-  aligned_addr = gen_reg_rtx (Pmode);\n-  emit_move_insn (aligned_addr, gen_rtx_AND (Pmode, addr, GEN_INT (-8)));\n-\n-  aligned_mem = change_address (mem, DImode, aligned_addr);\n-  set_mem_alias_set (aligned_mem, 0);\n-\n-  tmp = gen_reg_rtx (Pmode);\n-  if (BYTES_BIG_ENDIAN)\n-    {\n-      emit_move_insn (gen_lowpart (DImode, tmp),\n-                      gen_rtx_NOT (DImode, gen_lowpart (DImode, addr)));\n-    }\n-  else\n-    {\n-      tmp = addr;\n-    }\n-\n-  offset = gen_reg_rtx (DImode);\n-  emit_move_insn (offset, gen_rtx_AND (DImode, gen_lowpart (DImode, tmp),\n-                                       GEN_INT (7)));\n-\n-  tmp = gen_reg_rtx (DImode);\n-  emit_move_insn (tmp, GEN_INT (1));\n-\n-  shmt = gen_reg_rtx (DImode);\n-  emit_move_insn (shmt, gen_rtx_ASHIFT (DImode, offset, GEN_INT (3)));\n-\n-  word = gen_reg_rtx (DImode);\n-  emit_move_insn (word, gen_rtx_ASHIFT (DImode, tmp,\n-                                        gen_lowpart (SImode, shmt)));\n-\n-  tmp = gen_reg_rtx (DImode);\n-  tilegx_pre_atomic_barrier (model);\n-  emit_insn (gen_atomic_fetch_or_baredi (tmp, aligned_mem, word));\n-  tilegx_post_atomic_barrier (model);\n-\n-  emit_move_insn (gen_lowpart (DImode, result),\n-                  gen_rtx_LSHIFTRT (DImode, tmp,\n-                                    gen_lowpart (SImode, shmt)));\n-  DONE;\n-})"}, {"sha": "f35719494aa8d0e2f0fc1fd5e91d68eb88882cc6", "filename": "gcc/config/tilegx/t-tilegx", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ft-tilegx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ft-tilegx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ft-tilegx?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,21 +0,0 @@\n-MULTILIB_OPTIONS = m64/m32\n-MULTILIB_DIRNAMES = 64 32\n-MULTILIB_OSDIRNAMES = ../lib ../lib32\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-\n-tilegx-c.o: $(srcdir)/config/tilegx/tilegx-c.cc \\\n-    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(MACHMODE_H) \\\n-    $(TM_H) $(TM_P_H) $(CPPLIB_H) $(TREE_H) $(C_COMMON_H)\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n-\n-$(srcdir)/config/tilegx/mul-tables.cc: \\\n-    $(srcdir)/config/tilepro/gen-mul-tables.cc\n-\t$(CXX_FOR_BUILD) $(BUILD_CPPFLAGS) -O2 -o gen-mul-tables $<;\n-\t./gen-mul-tables > $@\n-\n-mul-tables.o: $(srcdir)/config/tilegx/mul-tables.cc \\\n-    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(EXPR_H) $(OPTABS_H) \\\n-    $(srcdir)/config/tilegx/tilegx-multiply.h\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<"}, {"sha": "22fdf847445c38f9638b2a058da396e337e4d823", "filename": "gcc/config/tilegx/tilegx-builtins.h", "status": "removed", "additions": 0, "deletions": 325, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-builtins.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,325 +0,0 @@\n-/* Enum for builtin intrinsics for TILE-Gx.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_TILEGX_BUILTINS_H\n-#define GCC_TILEGX_BUILTINS_H\n-\n-enum tilegx_builtin\n-{\n-  TILEGX_INSN_ADD,\n-  TILEGX_INSN_ADDX,\n-  TILEGX_INSN_ADDXSC,\n-  TILEGX_INSN_AND,\n-  TILEGX_INSN_BFEXTS,\n-  TILEGX_INSN_BFEXTU,\n-  TILEGX_INSN_BFINS,\n-  TILEGX_INSN_CLZ,\n-  TILEGX_INSN_CMOVEQZ,\n-  TILEGX_INSN_CMOVNEZ,\n-  TILEGX_INSN_CMPEQ,\n-  TILEGX_INSN_CMPEXCH,\n-  TILEGX_INSN_CMPEXCH4,\n-  TILEGX_INSN_CMPLES,\n-  TILEGX_INSN_CMPLEU,\n-  TILEGX_INSN_CMPLTS,\n-  TILEGX_INSN_CMPLTU,\n-  TILEGX_INSN_CMPNE,\n-  TILEGX_INSN_CMUL,\n-  TILEGX_INSN_CMULA,\n-  TILEGX_INSN_CMULAF,\n-  TILEGX_INSN_CMULF,\n-  TILEGX_INSN_CMULFR,\n-  TILEGX_INSN_CMULH,\n-  TILEGX_INSN_CMULHR,\n-  TILEGX_INSN_CRC32_32,\n-  TILEGX_INSN_CRC32_8,\n-  TILEGX_INSN_CTZ,\n-  TILEGX_INSN_DBLALIGN,\n-  TILEGX_INSN_DBLALIGN2,\n-  TILEGX_INSN_DBLALIGN4,\n-  TILEGX_INSN_DBLALIGN6,\n-  TILEGX_INSN_DRAIN,\n-  TILEGX_INSN_DTLBPR,\n-  TILEGX_INSN_EXCH,\n-  TILEGX_INSN_EXCH4,\n-  TILEGX_INSN_FDOUBLE_ADD_FLAGS,\n-  TILEGX_INSN_FDOUBLE_ADDSUB,\n-  TILEGX_INSN_FDOUBLE_MUL_FLAGS,\n-  TILEGX_INSN_FDOUBLE_PACK1,\n-  TILEGX_INSN_FDOUBLE_PACK2,\n-  TILEGX_INSN_FDOUBLE_SUB_FLAGS,\n-  TILEGX_INSN_FDOUBLE_UNPACK_MAX,\n-  TILEGX_INSN_FDOUBLE_UNPACK_MIN,\n-  TILEGX_INSN_FETCHADD,\n-  TILEGX_INSN_FETCHADD4,\n-  TILEGX_INSN_FETCHADDGEZ,\n-  TILEGX_INSN_FETCHADDGEZ4,\n-  TILEGX_INSN_FETCHAND,\n-  TILEGX_INSN_FETCHAND4,\n-  TILEGX_INSN_FETCHOR,\n-  TILEGX_INSN_FETCHOR4,\n-  TILEGX_INSN_FINV,\n-  TILEGX_INSN_FLUSH,\n-  TILEGX_INSN_FLUSHWB,\n-  TILEGX_INSN_FNOP,\n-  TILEGX_INSN_FSINGLE_ADD1,\n-  TILEGX_INSN_FSINGLE_ADDSUB2,\n-  TILEGX_INSN_FSINGLE_MUL1,\n-  TILEGX_INSN_FSINGLE_MUL2,\n-  TILEGX_INSN_FSINGLE_PACK1,\n-  TILEGX_INSN_FSINGLE_PACK2,\n-  TILEGX_INSN_FSINGLE_SUB1,\n-  TILEGX_INSN_ICOH,\n-  TILEGX_INSN_ILL,\n-  TILEGX_INSN_INFO,\n-  TILEGX_INSN_INFOL,\n-  TILEGX_INSN_INV,\n-  TILEGX_INSN_LD,\n-  TILEGX_INSN_LD1S,\n-  TILEGX_INSN_LD1U,\n-  TILEGX_INSN_LD2S,\n-  TILEGX_INSN_LD2U,\n-  TILEGX_INSN_LD4S,\n-  TILEGX_INSN_LD4U,\n-  TILEGX_INSN_LDNA,\n-  TILEGX_INSN_LDNT,\n-  TILEGX_INSN_LDNT1S,\n-  TILEGX_INSN_LDNT1U,\n-  TILEGX_INSN_LDNT2S,\n-  TILEGX_INSN_LDNT2U,\n-  TILEGX_INSN_LDNT4S,\n-  TILEGX_INSN_LDNT4U,\n-  TILEGX_INSN_LD_L2,\n-  TILEGX_INSN_LD1S_L2,\n-  TILEGX_INSN_LD1U_L2,\n-  TILEGX_INSN_LD2S_L2,\n-  TILEGX_INSN_LD2U_L2,\n-  TILEGX_INSN_LD4S_L2,\n-  TILEGX_INSN_LD4U_L2,\n-  TILEGX_INSN_LDNA_L2,\n-  TILEGX_INSN_LDNT_L2,\n-  TILEGX_INSN_LDNT1S_L2,\n-  TILEGX_INSN_LDNT1U_L2,\n-  TILEGX_INSN_LDNT2S_L2,\n-  TILEGX_INSN_LDNT2U_L2,\n-  TILEGX_INSN_LDNT4S_L2,\n-  TILEGX_INSN_LDNT4U_L2,\n-  TILEGX_INSN_LD_MISS,\n-  TILEGX_INSN_LD1S_MISS,\n-  TILEGX_INSN_LD1U_MISS,\n-  TILEGX_INSN_LD2S_MISS,\n-  TILEGX_INSN_LD2U_MISS,\n-  TILEGX_INSN_LD4S_MISS,\n-  TILEGX_INSN_LD4U_MISS,\n-  TILEGX_INSN_LDNA_MISS,\n-  TILEGX_INSN_LDNT_MISS,\n-  TILEGX_INSN_LDNT1S_MISS,\n-  TILEGX_INSN_LDNT1U_MISS,\n-  TILEGX_INSN_LDNT2S_MISS,\n-  TILEGX_INSN_LDNT2U_MISS,\n-  TILEGX_INSN_LDNT4S_MISS,\n-  TILEGX_INSN_LDNT4U_MISS,\n-  TILEGX_INSN_LNK,\n-  TILEGX_INSN_MF,\n-  TILEGX_INSN_MFSPR,\n-  TILEGX_INSN_MM,\n-  TILEGX_INSN_MNZ,\n-  TILEGX_INSN_MOVE,\n-  TILEGX_INSN_MTSPR,\n-  TILEGX_INSN_MUL_HS_HS,\n-  TILEGX_INSN_MUL_HS_HU,\n-  TILEGX_INSN_MUL_HS_LS,\n-  TILEGX_INSN_MUL_HS_LU,\n-  TILEGX_INSN_MUL_HU_HU,\n-  TILEGX_INSN_MUL_HU_LS,\n-  TILEGX_INSN_MUL_HU_LU,\n-  TILEGX_INSN_MUL_LS_LS,\n-  TILEGX_INSN_MUL_LS_LU,\n-  TILEGX_INSN_MUL_LU_LU,\n-  TILEGX_INSN_MULA_HS_HS,\n-  TILEGX_INSN_MULA_HS_HU,\n-  TILEGX_INSN_MULA_HS_LS,\n-  TILEGX_INSN_MULA_HS_LU,\n-  TILEGX_INSN_MULA_HU_HU,\n-  TILEGX_INSN_MULA_HU_LS,\n-  TILEGX_INSN_MULA_HU_LU,\n-  TILEGX_INSN_MULA_LS_LS,\n-  TILEGX_INSN_MULA_LS_LU,\n-  TILEGX_INSN_MULA_LU_LU,\n-  TILEGX_INSN_MULAX,\n-  TILEGX_INSN_MULX,\n-  TILEGX_INSN_MZ,\n-  TILEGX_INSN_NAP,\n-  TILEGX_INSN_NOP,\n-  TILEGX_INSN_NOR,\n-  TILEGX_INSN_OR,\n-  TILEGX_INSN_PCNT,\n-  TILEGX_INSN_PREFETCH_L1,\n-  TILEGX_INSN_PREFETCH_L1_FAULT,\n-  TILEGX_INSN_PREFETCH_L2,\n-  TILEGX_INSN_PREFETCH_L2_FAULT,\n-  TILEGX_INSN_PREFETCH_L3,\n-  TILEGX_INSN_PREFETCH_L3_FAULT,\n-  TILEGX_INSN_REVBITS,\n-  TILEGX_INSN_REVBYTES,\n-  TILEGX_INSN_ROTL,\n-  TILEGX_INSN_SHL,\n-  TILEGX_INSN_SHL16INSLI,\n-  TILEGX_INSN_SHL1ADD,\n-  TILEGX_INSN_SHL1ADDX,\n-  TILEGX_INSN_SHL2ADD,\n-  TILEGX_INSN_SHL2ADDX,\n-  TILEGX_INSN_SHL3ADD,\n-  TILEGX_INSN_SHL3ADDX,\n-  TILEGX_INSN_SHLX,\n-  TILEGX_INSN_SHRS,\n-  TILEGX_INSN_SHRU,\n-  TILEGX_INSN_SHRUX,\n-  TILEGX_INSN_SHUFFLEBYTES,\n-  TILEGX_INSN_SHUFFLEBYTES1,\n-  TILEGX_INSN_ST,\n-  TILEGX_INSN_ST1,\n-  TILEGX_INSN_ST2,\n-  TILEGX_INSN_ST4,\n-  TILEGX_INSN_STNT,\n-  TILEGX_INSN_STNT1,\n-  TILEGX_INSN_STNT2,\n-  TILEGX_INSN_STNT4,\n-  TILEGX_INSN_SUB,\n-  TILEGX_INSN_SUBX,\n-  TILEGX_INSN_SUBXSC,\n-  TILEGX_INSN_TBLIDXB0,\n-  TILEGX_INSN_TBLIDXB1,\n-  TILEGX_INSN_TBLIDXB2,\n-  TILEGX_INSN_TBLIDXB3,\n-  TILEGX_INSN_V1ADD,\n-  TILEGX_INSN_V1ADDI,\n-  TILEGX_INSN_V1ADDUC,\n-  TILEGX_INSN_V1ADIFFU,\n-  TILEGX_INSN_V1AVGU,\n-  TILEGX_INSN_V1CMPEQ,\n-  TILEGX_INSN_V1CMPEQI,\n-  TILEGX_INSN_V1CMPLES,\n-  TILEGX_INSN_V1CMPLEU,\n-  TILEGX_INSN_V1CMPLTS,\n-  TILEGX_INSN_V1CMPLTSI,\n-  TILEGX_INSN_V1CMPLTU,\n-  TILEGX_INSN_V1CMPLTUI,\n-  TILEGX_INSN_V1CMPNE,\n-  TILEGX_INSN_V1DDOTPU,\n-  TILEGX_INSN_V1DDOTPUA,\n-  TILEGX_INSN_V1DDOTPUS,\n-  TILEGX_INSN_V1DDOTPUSA,\n-  TILEGX_INSN_V1DOTP,\n-  TILEGX_INSN_V1DOTPA,\n-  TILEGX_INSN_V1DOTPU,\n-  TILEGX_INSN_V1DOTPUA,\n-  TILEGX_INSN_V1DOTPUS,\n-  TILEGX_INSN_V1DOTPUSA,\n-  TILEGX_INSN_V1INT_H,\n-  TILEGX_INSN_V1INT_L,\n-  TILEGX_INSN_V1MAXU,\n-  TILEGX_INSN_V1MAXUI,\n-  TILEGX_INSN_V1MINU,\n-  TILEGX_INSN_V1MINUI,\n-  TILEGX_INSN_V1MNZ,\n-  TILEGX_INSN_V1MULTU,\n-  TILEGX_INSN_V1MULU,\n-  TILEGX_INSN_V1MULUS,\n-  TILEGX_INSN_V1MZ,\n-  TILEGX_INSN_V1SADAU,\n-  TILEGX_INSN_V1SADU,\n-  TILEGX_INSN_V1SHL,\n-  TILEGX_INSN_V1SHLI,\n-  TILEGX_INSN_V1SHRS,\n-  TILEGX_INSN_V1SHRSI,\n-  TILEGX_INSN_V1SHRU,\n-  TILEGX_INSN_V1SHRUI,\n-  TILEGX_INSN_V1SUB,\n-  TILEGX_INSN_V1SUBUC,\n-  TILEGX_INSN_V2ADD,\n-  TILEGX_INSN_V2ADDI,\n-  TILEGX_INSN_V2ADDSC,\n-  TILEGX_INSN_V2ADIFFS,\n-  TILEGX_INSN_V2AVGS,\n-  TILEGX_INSN_V2CMPEQ,\n-  TILEGX_INSN_V2CMPEQI,\n-  TILEGX_INSN_V2CMPLES,\n-  TILEGX_INSN_V2CMPLEU,\n-  TILEGX_INSN_V2CMPLTS,\n-  TILEGX_INSN_V2CMPLTSI,\n-  TILEGX_INSN_V2CMPLTU,\n-  TILEGX_INSN_V2CMPLTUI,\n-  TILEGX_INSN_V2CMPNE,\n-  TILEGX_INSN_V2DOTP,\n-  TILEGX_INSN_V2DOTPA,\n-  TILEGX_INSN_V2INT_H,\n-  TILEGX_INSN_V2INT_L,\n-  TILEGX_INSN_V2MAXS,\n-  TILEGX_INSN_V2MAXSI,\n-  TILEGX_INSN_V2MINS,\n-  TILEGX_INSN_V2MINSI,\n-  TILEGX_INSN_V2MNZ,\n-  TILEGX_INSN_V2MULFSC,\n-  TILEGX_INSN_V2MULS,\n-  TILEGX_INSN_V2MULTS,\n-  TILEGX_INSN_V2MZ,\n-  TILEGX_INSN_V2PACKH,\n-  TILEGX_INSN_V2PACKL,\n-  TILEGX_INSN_V2PACKUC,\n-  TILEGX_INSN_V2SADAS,\n-  TILEGX_INSN_V2SADAU,\n-  TILEGX_INSN_V2SADS,\n-  TILEGX_INSN_V2SADU,\n-  TILEGX_INSN_V2SHL,\n-  TILEGX_INSN_V2SHLI,\n-  TILEGX_INSN_V2SHLSC,\n-  TILEGX_INSN_V2SHRS,\n-  TILEGX_INSN_V2SHRSI,\n-  TILEGX_INSN_V2SHRU,\n-  TILEGX_INSN_V2SHRUI,\n-  TILEGX_INSN_V2SUB,\n-  TILEGX_INSN_V2SUBSC,\n-  TILEGX_INSN_V4ADD,\n-  TILEGX_INSN_V4ADDSC,\n-  TILEGX_INSN_V4INT_H,\n-  TILEGX_INSN_V4INT_L,\n-  TILEGX_INSN_V4PACKSC,\n-  TILEGX_INSN_V4SHL,\n-  TILEGX_INSN_V4SHLSC,\n-  TILEGX_INSN_V4SHRS,\n-  TILEGX_INSN_V4SHRU,\n-  TILEGX_INSN_V4SUB,\n-  TILEGX_INSN_V4SUBSC,\n-  TILEGX_INSN_WH64,\n-  TILEGX_INSN_XOR,\n-  TILEGX_NETWORK_BARRIER,\n-  TILEGX_IDN0_RECEIVE,\n-  TILEGX_IDN1_RECEIVE,\n-  TILEGX_IDN_SEND,\n-  TILEGX_UDN0_RECEIVE,\n-  TILEGX_UDN1_RECEIVE,\n-  TILEGX_UDN2_RECEIVE,\n-  TILEGX_UDN3_RECEIVE,\n-  TILEGX_UDN_SEND,\n-  TILEGX_BUILTIN_max\n-};\n-\n-#endif /* !GCC_TILEGX_BUILTINS_H */"}, {"sha": "6ef68081e0070b760dec9ee99da18dbedf46f03e", "filename": "gcc/config/tilegx/tilegx-c.cc", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-c.cc?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,55 +0,0 @@\n-/* Definitions of C specific functions for TILE-Gx.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#define IN_TARGET_CODE 1\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"c-family/c-common.h\"\n-\n-/* copy defines in c-cppbuiltin.cc */\n-# define builtin_define(TXT) cpp_define (pfile, TXT)\n-# define builtin_assert(TXT) cpp_assert (pfile, TXT)\n-\n-\n-/* Implement TARGET_CPU_CPP_BUILTINS.  */\n-void\n-tilegx_cpu_cpp_builtins (struct cpp_reader *pfile)\n-{\n-  builtin_define (\"__tile__\");\n-  builtin_define (\"__tilegx__\");\n-  builtin_define (\"__tile_chip__=10\");\n-  builtin_define (\"__tile_chip_rev__=0\");\n-  builtin_assert (\"cpu=tilegx\");\n-  builtin_assert (\"machine=tilegx\");\n-\n-  if (TARGET_32BIT)\n-    builtin_define (\"__tilegx32__\");\n-\n-  builtin_define (\"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1\");\n-  builtin_define (\"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2\");\n-\n-  TILEGX_CPU_CPP_ENDIAN_BUILTINS ();\n-  GNU_USER_TARGET_OS_CPP_BUILTINS ();\n-}\n-\n-"}, {"sha": "debfe9d4ca93d388b2ff92892e5db4c14354658a", "filename": "gcc/config/tilegx/tilegx-generic.md", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-generic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-generic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-generic.md?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,115 +0,0 @@\n-;; Scheduling description for Tilera TILE-Gx chip.\n-;; Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-;; Contributed by Walter Lee (walt@tilera.com)\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify it\n-;; under the terms of the GNU General Public License as published\n-;; by the Free Software Foundation; either version 3, or (at your\n-;; option) any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-;; License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-(define_automaton \"tile\")\n-\n-; Make the scheduling automaton an ndfa.\n-(automata_option \"ndfa\")\n-\n-; Name the three pipes.\n-(define_cpu_unit \"X0\" \"tile\")\n-(define_cpu_unit \"X1\" \"tile\")\n-(define_cpu_unit \"Y0\" \"tile\")\n-(define_cpu_unit \"Y1\" \"tile\")\n-(define_cpu_unit \"Y2\" \"tile\")\n-\n-(define_insn_reservation \"X0\" 1\n-  (eq_attr \"type\" \"X0\")\n-  \"X0\")\n-\n-(define_insn_reservation \"X0_2cycle\" 2\n-  (eq_attr \"type\" \"X0_2cycle\")\n-  \"X0,nothing\")\n-\n-(define_insn_reservation \"X1\" 1\n-  (eq_attr \"type\" \"X1,X1_branch\")\n-  \"X1\")\n-\n-(define_insn_reservation \"X1_2cycle\" 2\n-  (eq_attr \"type\" \"X1_2cycle\")\n-  \"X1,nothing\")\n-\n-(define_insn_reservation \"X1_L2\" 11\n-  (eq_attr \"type\" \"X1_L2\")\n-  \"X1\")\n-\n-(define_insn_reservation \"X1_remote\" 50\n-  (eq_attr \"type\" \"X1_remote\")\n-  \"X1\")\n-\n-(define_insn_reservation \"X1_miss\" 80\n-  (eq_attr \"type\" \"X1_miss\")\n-  \"X1\")\n-\n-(define_insn_reservation \"X01\" 1\n-  (eq_attr \"type\" \"X01\")\n-  \"X0|X1\")\n-\n-(define_insn_reservation \"Y0\" 1\n-  (eq_attr \"type\" \"Y0\")\n-  \"Y0|X0\")\n-\n-(define_insn_reservation \"Y0_2cycle\" 2\n-  (eq_attr \"type\" \"Y0_2cycle\")\n-  \"Y0|X0,nothing\")\n-\n-(define_insn_reservation \"Y1\" 1\n-  (eq_attr \"type\" \"Y1\")\n-  \"Y1|X1\")\n-\n-(define_insn_reservation \"Y2\" 1\n-  (eq_attr \"type\" \"Y2\")\n-  \"Y2|X1\")\n-\n-(define_insn_reservation \"Y2_2cycle\" 2\n-  (eq_attr \"type\" \"Y2_2cycle\")\n-  \"Y2|X1,nothing\")\n-\n-(define_insn_reservation \"Y2_L2\" 11\n-  (eq_attr \"type\" \"Y2_L2\")\n-  \"Y2|X1\")\n-\n-(define_insn_reservation \"Y2_miss\" 80\n-  (eq_attr \"type\" \"Y2_miss\")\n-  \"Y2|X1\")\n-\n-(define_insn_reservation \"Y01\" 1\n-  (eq_attr \"type\" \"Y01\")\n-  \"Y0|Y1|X0|X1\")\n-\n-(define_insn_reservation \"nothing\" 0\n-  (eq_attr \"type\" \"nothing\")\n-  \"nothing\")\n-\n-(define_insn_reservation \"cannot_bundle\" 1\n-  (eq_attr \"type\" \"cannot_bundle\")\n-  \"X0+X1\")\n-\n-(define_insn_reservation \"cannot_bundle_3cycle\" 3\n-  (eq_attr \"type\" \"cannot_bundle_3cycle\")\n-  \"X0+X1\")\n-\n-(define_insn_reservation \"cannot_bundle_4cycle\" 4\n-  (eq_attr \"type\" \"cannot_bundle_4cycle\")\n-  \"X0+X1\")\n-\n-\n-; A bundle must be in either X format or Y format.\n-(exclusion_set \"X0,X1\" \"Y0,Y1,Y2\")"}, {"sha": "d5fa23a7e5bb6c94507b52f07bd3adce612aeaad", "filename": "gcc/config/tilegx/tilegx-modes.def", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-modes.def?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,37 +0,0 @@\n-/* TILE-Gx extra machine modes. \n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Extra modes for handling struct returns in up to 10 registers. */\n-INT_MODE (R3I, 24);\n-INT_MODE (R5I, 40);\n-INT_MODE (R6I, 48);\n-INT_MODE (R7I, 56);\n-INT_MODE (R8I, 64);\n-INT_MODE (R9I, 72);\n-INT_MODE (R10I, 80);\n-\n-/* Vector modes.  */\n-VECTOR_MODES (INT, 8);     /* V8QI V4HI V2SI */\n-VECTOR_MODE (INT, QI, 16); /* V16QI */\n-VECTOR_MODE (INT, HI, 8);  /* V8HI */\n-VECTOR_MODE (INT, SI, 4);  /* V4SI */\n-VECTOR_MODE (INT, HI, 2);  /* V2HI */\n-\n-VECTOR_MODE (INT, QI, 4);  /* V4QI */"}, {"sha": "766a6388d467c2112e1a13c79a627add7e44af55", "filename": "gcc/config/tilegx/tilegx-multiply.h", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-multiply.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-multiply.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-multiply.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,78 +0,0 @@\n-/* Header for constant multiple table for TILE-Gx.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_TILEGX_MULTIPLY_H\n-#define GCC_TILEGX_MULTIPLY_H\n-\n-/* A node of a tilegx_multiply_insn_seq, corresponding to a single\n-   machine instruction such as 'add', 's1a', or an shl by a constant.  */\n-struct tilegx_multiply_insn_seq_entry\n-{\n-  /* Which operation this node performs (e.g. an add or sub).\n-     Don't use this directly, call get_opcode() table to get a insn_code.  */\n-  unsigned char compressed_opcode;\n-\n-  /* The left-hand side of this expression tree.\n-     If equal to 0, it refers to 'zero'.\n-     If equal to 1, it refers to the original input to the multiply operation.\n-     Otherwise, subtract two and it is an index into the containing\n-     tilegx_multiply_insn_seq's 'op' array. Since it can only point to some\n-     value that has already been computed it will always point to an\n-     earlier entry in the array.  */\n-  unsigned char lhs;\n-\n-  /* This is like lhs, but for the right-hand side. However, for shift\n-     opcodes this is a shift count rather than an operand index.  */\n-  unsigned char rhs;\n-};\n-\n-/* Maximum size of op array.  */\n-#define tilegx_multiply_insn_seq_MAX_OPERATIONS 4\n-\n-/* This defines a DAG describing how to multiply by a constant in\n-   terms of one or more machine instructions.  */\n-struct tilegx_multiply_insn_seq\n-{\n-  /* The constant factor by which this expression tree multiplies its input.  */\n-  long long multiplier;\n-\n-  /* The nodes of the parse tree. These are ordered so that instructions\n-     can be emitted in the same order that they appear in this array.\n-     Entry entry in this array can only refer to earlier entries in\n-     the array.  */\n-  struct tilegx_multiply_insn_seq_entry\n-    op[tilegx_multiply_insn_seq_MAX_OPERATIONS];\n-\n-};\n-\n-/* A mapping from the compressed opcode to the corresponding enum\n-   insn_code.  */\n-extern const enum insn_code tilegx_multiply_insn_seq_decode_opcode[];\n-\n-/* Table mapping constant int multipliers to an expression\n-   tree that efficiently performs that multiplication.\n-   This is sorted by its 'multiplier' field so a binary search\n-   can look for matches.  */\n-extern const struct tilegx_multiply_insn_seq tilegx_multiply_insn_seq_table[];\n-\n-/* The number of elements in multiply_insn_seq_table.  */\n-extern const int tilegx_multiply_insn_seq_table_size;\n-\n-#endif /* !GCC_TILEGX_MULTIPLY_H */"}, {"sha": "ecc06e2dd240301765f959efe519e406d63ea2b5", "filename": "gcc/config/tilegx/tilegx-opts.h", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-opts.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,33 +0,0 @@\n-/* Definitions for option handling for TILE-Gx.\n-   Copyright (C) 2012-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef TILEGX_OPTS_H\n-#define TILEGX_OPTS_H\n-\n-enum cmodel {\n-  CM_SMALL,\t/* Makes various assumpation about sizes of code and\n-\t\t   data fits.  */\n-  CM_LARGE,\t/* No assumptions.  */\n-  CM_SMALL_PIC,\t/* Makes various assumpation about sizes of code and\n-\t\t   data fits.  */\n-  CM_LARGE_PIC\t/* No assumptions.  */\n-};\n-\n-#endif"}, {"sha": "72635242a7af5f187602887ebac110e134fd7915", "filename": "gcc/config/tilegx/tilegx-protos.h", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,75 +0,0 @@\n-/* Prototypes of target machine for TILE-Gx.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_TILEGX_PROTOS_H\n-#define GCC_TILEGX_PROTOS_H\n-\n-extern void tilegx_init_expanders (void);\n-extern void tilegx_compute_pcrel_address (rtx, rtx);\n-extern void tilegx_compute_pcrel_plt_address (rtx, rtx);\n-extern bool tilegx_legitimate_pic_operand_p (rtx);\n-extern rtx tilegx_simd_int (rtx, machine_mode);\n-\n-#ifdef RTX_CODE\n-extern bool tilegx_bitfield_operand_p (HOST_WIDE_INT, int *, int *);\n-extern void tilegx_expand_set_const64 (rtx, rtx);\n-extern bool tilegx_expand_mov (machine_mode, rtx *);\n-extern void tilegx_expand_unaligned_load (rtx, rtx, HOST_WIDE_INT,\n-\t\t\t\t\t  HOST_WIDE_INT, bool);\n-extern void tilegx_expand_movmisalign (machine_mode, rtx *);\n-extern void tilegx_allocate_stack (rtx, rtx);\n-extern bool tilegx_expand_muldi (rtx, rtx, rtx);\n-extern void tilegx_expand_smuldi3_highpart (rtx, rtx, rtx);\n-extern void tilegx_expand_umuldi3_highpart (rtx, rtx, rtx);\n-\n-extern bool tilegx_emit_setcc (rtx[], machine_mode);\n-extern void tilegx_emit_conditional_branch (rtx[], machine_mode);\n-extern rtx tilegx_emit_conditional_move (rtx);\n-extern const char *tilegx_output_cbranch_with_opcode (rtx_insn *, rtx *,\n-\t\t\t\t\t\t      const char *,\n-\t\t\t\t\t\t      const char *, int);\n-extern const char *tilegx_output_cbranch (rtx_insn *, rtx *, bool);\n-extern void tilegx_expand_tablejump (rtx, rtx);\n-extern void tilegx_expand_builtin_vector_binop (rtx (*)(rtx, rtx, rtx),\n-\t\t\t\t\t\tmachine_mode, rtx,\n-\t\t\t\t\t\tmachine_mode, rtx, rtx,\n-\t\t\t\t\t\tbool);\n-extern void tilegx_pre_atomic_barrier (enum memmodel);\n-extern void tilegx_post_atomic_barrier (enum memmodel);\n-#endif /* RTX_CODE */\n-\n-extern bool tilegx_can_use_return_insn_p (void);\n-extern void tilegx_expand_prologue (void);\n-extern void tilegx_expand_epilogue (bool);\n-extern int tilegx_initial_elimination_offset (int, int);\n-extern rtx tilegx_return_addr (int, rtx);\n-extern rtx tilegx_eh_return_handler_rtx (void);\n-extern int tilegx_adjust_insn_length (rtx_insn *, int);\n-\n-extern int tilegx_asm_preferred_eh_data_format (int, int);\n-extern void tilegx_final_prescan_insn (rtx_insn *);\n-extern const char *tilegx_asm_output_opcode (FILE *, const char *);\n-extern void tilegx_function_profiler (FILE *, int);\n-\n-/* Declare functions in tilegx-c.cc */\n-\n-extern void tilegx_cpu_cpp_builtins (struct cpp_reader *);\n-\n-#endif /* GCC_TILEGX_PROTOS_H */"}, {"sha": "c40fc7401e3e444e74d44f9cc1e3105e8edc11e8", "filename": "gcc/config/tilegx/tilegx.cc", "status": "removed", "additions": 0, "deletions": 5728, "changes": 5728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.cc?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb"}, {"sha": "3f1c25de4185ac79e6934d3bf0af193716b90fb2", "filename": "gcc/config/tilegx/tilegx.h", "status": "removed", "additions": 0, "deletions": 530, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,530 +0,0 @@\n-/* Definitions of target machine for GNU compiler for TILE-Gx.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Default target_flags if no switches are specified  */\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT 0\n-#endif\n-\n-#ifndef TARGET_BIG_ENDIAN_DEFAULT\n-#define TARGET_BIG_ENDIAN_DEFAULT 0\n-#endif\n-\n-#ifndef TARGET_ENDIAN_DEFAULT\n-#if TARGET_BIG_ENDIAN_DEFAULT\n-#define TARGET_ENDIAN_DEFAULT MASK_BIG_ENDIAN\n-#else\n-#define TARGET_ENDIAN_DEFAULT 0\n-#endif\n-#endif\n-\n-/* This is used by tilegx_cpu_cpp_builtins to indicate the byte order\n-   we're compiling for.  */\n-#define TILEGX_CPU_CPP_ENDIAN_BUILTINS()\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      if (TARGET_BIG_ENDIAN)\t\t\t\\\n-\tbuiltin_define (\"__BIG_ENDIAN__\");\t\\\n-      else\t\t\t\t\t\\\n-\tbuiltin_define (\"__LITTLE_ENDIAN__\");\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#include \"config/tilegx/tilegx-opts.h\"\n-\n-\n-/* Target CPU builtins.  */\n-#define TARGET_CPU_CPP_BUILTINS() \\\n-  tilegx_cpu_cpp_builtins (pfile)\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE (TARGET_32BIT ? \"int\" : \"long int\")\n-\n-#undef SIZE_TYPE\n-#define SIZE_TYPE (TARGET_32BIT ? \"unsigned int\" : \"long unsigned int\")\n-\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"int\"\n-\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE 32\n-\f\n-\n-/* Target machine storage layout */\n-\n-#define BITS_BIG_ENDIAN 0\n-#define BYTES_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n-#define WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n-#define FLOAT_WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n-\n-#define UNITS_PER_WORD 8\n-#define PARM_BOUNDARY BITS_PER_WORD\n-#define STACK_BOUNDARY 128\n-#define FUNCTION_BOUNDARY 64\n-#define BIGGEST_ALIGNMENT 128\n-#define STRICT_ALIGNMENT 1\n-\n-#define INT_TYPE_SIZE         32\n-#define LONG_TYPE_SIZE        (TARGET_32BIT ? 32 : 64)\n-#define LONG_LONG_TYPE_SIZE   64\n-#define FLOAT_TYPE_SIZE       32\n-#define DOUBLE_TYPE_SIZE      64\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-#define POINTER_SIZE          LONG_TYPE_SIZE\n-\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-#define FASTEST_ALIGNMENT 64\n-#define BIGGEST_FIELD_ALIGNMENT 128\n-#define WIDEST_HARDWARE_FP_SIZE 64\n-\n-/* Make arrays of chars word-aligned for the same reasons.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n-\n-/* Make local arrays of chars word-aligned for the same reasons.  */\n-#define LOCAL_ALIGNMENT(TYPE, ALIGN) DATA_ALIGNMENT (TYPE, ALIGN)\n-\f\n-\n-/* Standard register usage.  */\n-\n-#define FIRST_PSEUDO_REGISTER (64 + 4)\n-\n-#define FIXED_REGISTERS \\\n- {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1}\n-#define CALL_REALLY_USED_REGISTERS \\\n- {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1}\n-\n-#define REG_ALLOC_ORDER {\t\t\t\t\\\n-      10, 11, 12, 13, 14, /* call used */\t\t\\\n-      15, 16, 17, 18, 19,\t\t\t\t\\\n-      20, 21, 22, 23, 24,\t\t\t\t\\\n-      25, 26, 27, 28, 29,\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      9, 8, 7, 6, 5,      /* argument */\t\t\\\n-      4, 3, 2, 1, 0,\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      55,\t          /* return address */\t\t\\\n-\t\t\t\t\t\t\t\\\n-      30, 31, 32, 33, 34, /* call saved registers */\t\\\n-      35, 36, 37, 38, 39,\t\t\t\t\\\n-      40, 41, 42, 43, 44,\t\t\t\t\\\n-      45, 46, 47, 48, 49,\t\t\t\t\\\n-      50, 51,\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      52, \t\t  /* hard frame pointer */\t\\\n-      53, 54, \t\t  /* tp, sp */\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      56, 57, 58, 59, 60, /* special purpose */\t\t\\\n-      61, 62, 63, 64, 65, /* or fake registers */\t\\\n-      66, 67\t\t\t\t\t\t\\\n-}\n-\n-/* Register that holds an address into the text segment that can be\n-   used by pic code.  */\n-#define TILEGX_PIC_TEXT_LABEL_REGNUM (flag_pic ? 50 : INVALID_REGNUM)\n-#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 51 : INVALID_REGNUM)\n-#define HARD_FRAME_POINTER_REGNUM 52\n-#define THREAD_POINTER_REGNUM 53\n-#define STACK_POINTER_REGNUM 54\n-#define TILEGX_LINK_REGNUM 55\n-#define FRAME_POINTER_REGNUM 64\n-#define ARG_POINTER_REGNUM 65\n-/* SPR storing the comparison value for compare and exchange.  */\n-#define TILEGX_CMPEXCH_REGNUM 66\n-/* Pseudo registers used to enforce order between instructions that\n-   touch the networks.  */\n-#define TILEGX_NETORDER_REGNUM 67\n-#define STATIC_CHAIN_REGNUM 10\n-\f\n-\n-enum reg_class\n-{\n-  NO_REGS,\n-  R0_REGS,\n-  R1_REGS,\n-  R2_REGS,\n-  R3_REGS,\n-  R4_REGS,\n-  R5_REGS,\n-  R6_REGS,\n-  R7_REGS,\n-  R8_REGS,\n-  R9_REGS,\n-  R10_REGS,\n-  ALL_REGS,\n-  LIM_REG_CLASSES\n-};\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Since GENERAL_REGS is the same class as ALL_REGS, don't give it a \n-   different class number; just make it an alias.  */\n-#define GENERAL_REGS ALL_REGS\n-\n-#define REG_CLASS_NAMES\t\\\n-  { \\\n-    \"NO_REGS\", \\\n-    \"R0_REGS\", \\\n-    \"R1_REGS\", \\\n-    \"R2_REGS\", \\\n-    \"R3_REGS\", \\\n-    \"R4_REGS\", \\\n-    \"R5_REGS\", \\\n-    \"R6_REGS\", \\\n-    \"R7_REGS\", \\\n-    \"R8_REGS\", \\\n-    \"R9_REGS\", \\\n-    \"R10_REGS\", \\\n-    \"ALL_REGS\" \\\n-  }\n-\n-#define REG_CLASS_CONTENTS \\\n-  { \\\n-    { 0 }, \\\n-    { 1 << 0 }, \\\n-    { 1 << 1 }, \\\n-    { 1 << 2 }, \\\n-    { 1 << 3 }, \\\n-    { 1 << 4 }, \\\n-    { 1 << 5 }, \\\n-    { 1 << 6 }, \\\n-    { 1 << 7 }, \\\n-    { 1 << 8 }, \\\n-    { 1 << 9 }, \\\n-    { 1 << 10 }, \\\n-    { 0xffffffff, 0xffffffff } \\\n-  }\n-\n-#define REGNO_REG_CLASS(REGNO) \\\n-  ((unsigned)(REGNO) <= 10 ? \\\n-   (enum reg_class)(R0_REGS + (REGNO)) : ALL_REGS)\n-\n-#define INDEX_REG_CLASS NO_REGS\n-#define BASE_REG_CLASS ALL_REGS\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\f\n-\n-/* Stack layout; function entry, exit and calling.  */\n-\n-#define STACK_GROWS_DOWNWARD 1\n-#define FRAME_GROWS_DOWNWARD 1\n-\n-#define DYNAMIC_CHAIN_ADDRESS(FRAME) \\\n-  plus_constant (Pmode, (FRAME), UNITS_PER_WORD)\n-\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n-\n-#define INCOMING_FRAME_SP_OFFSET 0\n-\n-#define STACK_POINTER_OFFSET (2 * UNITS_PER_WORD)\n-\n-#define ARG_POINTER_CFA_OFFSET(FNDECL) (-STACK_POINTER_OFFSET)\n-\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/* The first 10 registers may hold return value.  */\n-#define TILEGX_NUM_RETURN_REGS 10\n-\n-/* The first 10 registers hold function arguments.  */\n-#define TILEGX_NUM_ARG_REGS 10\n-\n-#define FUNCTION_ARG_REGNO_P(N) ((N) < TILEGX_NUM_ARG_REGS)\n-\n-/* The type used to store the number of words of arguments scanned so\n-   far during argument scanning.  This includes any space that is\n-   skipped.  */\n-#define CUMULATIVE_ARGS int\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n- ((CUM) = 0)\n-\f\n-\n-#define ELIMINABLE_REGS\t\t\t\t\t\\\n-  {{ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM},\t\t\\\n-  {ARG_POINTER_REGNUM,\t HARD_FRAME_POINTER_REGNUM},\t\\\n-  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n-  {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n-  ((OFFSET) = tilegx_initial_elimination_offset((FROM),(TO)))\n-\n-#define PROFILE_BEFORE_PROLOGUE 1\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO) \\\n-  tilegx_function_profiler (FILE, LABELNO)\n-\n-#define TRAMPOLINE_SIZE (TARGET_32BIT ? 48 : 56)\n-#define TRAMPOLINE_ALIGNMENT 64\n-#define TRAMPOLINE_SECTION text_section\n-\f\n-\n-/* Call frame debugging information.  */\n-\n-#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, TILEGX_LINK_REGNUM)\n-\n-#define RETURN_ADDR_RTX tilegx_return_addr\n-\n-#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (TILEGX_LINK_REGNUM)\n-\n-#define DWARF_ZERO_REG 63\n-\n-#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N + 12) : INVALID_REGNUM)\n-#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 11)\n-#define EH_RETURN_HANDLER_RTX tilegx_eh_return_handler_rtx ()\n-\n-#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL) \\\n-  tilegx_asm_preferred_eh_data_format ((CODE), (GLOBAL))\n-\f\n-\n-/* Addressing modes, and classification of registers for them.  */\n-\n-#define HAVE_POST_INCREMENT 1\n-#define HAVE_POST_DECREMENT 1\n-#define HAVE_POST_MODIFY_DISP 1\n-\n-#define REGNO_OK_FOR_INDEX_P(regno) 0\n-#define REGNO_OK_FOR_BASE_P(regno)\t\\\n-  ((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n-\n-#define MAX_REGS_PER_ADDRESS 1\n-\n-#define CONSTANT_ADDRESS_P(X) 0\n-\n-#define LEGITIMATE_PIC_OPERAND_P(X) tilegx_legitimate_pic_operand_p (X)\n-\f\n-\n-#define CASE_VECTOR_MODE Pmode\n-#define CASE_VECTOR_PC_RELATIVE 0\n-#define JUMP_TABLES_IN_TEXT_SECTION 0\n-\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-#define MOVE_MAX UNITS_PER_WORD\n-\n-/* Use a value of 11 for MOVE_RATIO and friends, because TILEPro\n-   returns structs as large as 10 words in registers.  Because of some\n-   some code generation inefficiency, we never get smaller code for\n-   turning that into a memcpy, so pick a value that guarantees this\n-   doesn't happen.  */\n-#define TILEGX_CALL_RATIO 11\n-#define MOVE_RATIO(speed) ((speed) ? 15 : TILEGX_CALL_RATIO)\n-#define CLEAR_RATIO(speed) ((speed) ? 15 : TILEGX_CALL_RATIO)\n-#define SET_RATIO(speed) ((speed) ? 15 : TILEGX_CALL_RATIO)\n-\n-#define WORD_REGISTER_OPERATIONS 1\n-\n-#define LOAD_EXTEND_OP(MODE) ((MODE) == SImode ? SIGN_EXTEND : ZERO_EXTEND)\n-\n-#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n-      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\\n-    {                                           \\\n-      if ((MODE) == SImode)                     \\\n-        (UNSIGNEDP) = 0;                        \\\n-      (MODE) = DImode;                          \\\n-    }\n-\n-/* Define SLOW_BYTE_ACCESS to avoid making a QI or HI mode\n-   register.  */\n-#define SLOW_BYTE_ACCESS 1\n-\n-#define SHIFT_COUNT_TRUNCATED 0\n-\n-#define SHORT_IMMEDIATES_SIGN_EXTEND 1\n-\n-#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = 64, 1)\n-#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = 64, 1)\n-\n-#define Pmode (TARGET_32BIT ? SImode : DImode)\n-\n-#define STACK_SIZE_MODE Pmode\n-\n-#define STORE_FLAG_VALUE 1\n-\n-#define FUNCTION_MODE DImode\n-\n-#define NO_FUNCTION_CSE 1\n-\n-#define ADJUST_INSN_LENGTH(INSN, LENGTH) \\\n-  ((LENGTH) = tilegx_adjust_insn_length ((INSN), (LENGTH)))\n-\n-#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n-\n-#define BRANCH_COST(speed_p, predictable_p) ((predictable_p) ? 2 : 6)\n-\f\n-\n-/* Control the assembler format that we output.  */\n-\n-#undef NO_DOLLAR_IN_LABEL\n-\n-#define ASM_COMMENT_START \"##\"\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-#undef READONLY_DATA_SECTION_ASM_OP\n-#define READONLY_DATA_SECTION_ASM_OP \"\\t.section\\t.rodata, \\\"a\\\"\"\n-\n-#undef BSS_SECTION_ASM_OP\n-#define BSS_SECTION_ASM_OP\t\"\\t.section\\t.bss, \\\"wa\\\"\"\n-\n-#undef INIT_SECTION_ASM_OP\n-#define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init, \\\"ax\\\"\"\n-\n-#undef FINI_SECTION_ASM_OP\n-#define FINI_SECTION_ASM_OP\t\"\\t.section\\t.fini, \\\"ax\\\"\"\n-\n-#define GLOBAL_ASM_OP \".global \"\n-\n-#define SUPPORTS_WEAK 1\n-\n-#define USER_LABEL_PREFIX \"\"\n-\n-#define REGISTER_PREFIX \"\"\n-#define REGISTER_NAMES                                                  \\\n-  { \"r0\",   \"r1\",   \"r2\",   \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\",       \\\n-    \"r8\",   \"r9\",   \"r10\",  \"r11\",  \"r12\",  \"r13\",  \"r14\",  \"r15\",      \\\n-    \"r16\",  \"r17\",  \"r18\",  \"r19\",  \"r20\",  \"r21\",  \"r22\",  \"r23\",      \\\n-    \"r24\",  \"r25\",  \"r26\",  \"r27\",  \"r28\",  \"r29\",  \"r30\",  \"r31\",      \\\n-    \"r32\",  \"r33\",  \"r34\",  \"r35\",  \"r36\",  \"r37\",  \"r38\",  \"r39\",      \\\n-    \"r40\",  \"r41\",  \"r42\",  \"r43\",  \"r44\",  \"r45\",  \"r46\",  \"r47\",      \\\n-    \"r48\",  \"r49\",  \"r50\",  \"r51\",  \"r52\",  \"tp\",   \"sp\",   \"lr\",       \\\n-    \"?r56?\",\"idn0\", \"idn1\", \"udn0\", \"udn1\", \"udn2\", \"udn3\", \"zero\",     \\\n-    \"?FRAME?\", \"?ARG?\", \"?CMPEXCH?\", \"?NET?\" }\n-\n-#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n-  tilegx_final_prescan_insn (insn)\n-\n-#define ASM_OUTPUT_OPCODE(STREAM, PTR)\t\\\n-  (PTR = tilegx_asm_output_opcode (STREAM, PTR))\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      char label[256];\t\t\t\t\t\t\\\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (VALUE));\t\\\n-      fprintf (FILE, \"%s \",\t\t\t\t\t\\\n-               integer_asm_op (GET_MODE_SIZE (Pmode), TRUE));\t\\\n-      assemble_name (FILE, label);\t\t\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      char label[256];\t\t\t\t\t\t\\\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (VALUE));\t\\\n-      fprintf (FILE, \"%s \", \t\t\t\t\t\\\n-               integer_asm_op (GET_MODE_SIZE (Pmode), TRUE));\t\\\n-      assemble_name (FILE, label);\t\t\t\t\\\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (REL));\t\t\\\n-      fprintf (FILE, \"-\");\t\t\t\t\t\\\n-      assemble_name (FILE, label);\t\t\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n-  do { if ((LOG) != 0) fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG)); } while (0)\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n-  ( fputs (\".comm \", (FILE)),\t\t\t\t\\\n-    assemble_name ((FILE), (NAME)),\t\t\t\\\n-    fprintf ((FILE), \",%u\\n\", (unsigned int)(ROUNDED)))\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n-  ( fputs (\".lcomm \", (FILE)),\t\t\t\t\\\n-    assemble_name ((FILE), (NAME)),\t\t\t\\\n-    fprintf ((FILE), \",%u\\n\", (unsigned int)(ROUNDED)))\n-\n-#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)\t\t\\\n-static void __attribute__((__used__))\t\t\t\t\\\n-call_ ## FUNC (void)\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  asm (SECTION_OP);\t\t\t\t\t\t\\\n-  asm (\"{ moveli r0, hw2_last(\" #FUNC \" - . - 8); lnk r1 }\\n\");\t\\\n-  asm (\"shl16insli r0, r0, hw1(\" #FUNC \" - .)\\n\");\t\t\\\n-  asm (\"shl16insli r0, r0, hw0(\" #FUNC \" - . + 8)\\n\");\t\t\\\n-  asm (\"add r0, r1, r0\\n\");\t\t\t\t\t\\\n-  asm (\"jalr r0\\n\");\t\t\t\t\t\t\\\n-  asm (TEXT_SECTION_ASM_OP);\t\t\t\t\t\\\n-}\n-\n-\f\n-\n-#define INIT_EXPANDERS tilegx_init_expanders ()\n-\n-/* A C structure for machine-specific, per-function data.  This is\n-   added to the cfun structure.  */\n-typedef struct GTY(()) machine_function\n-{\n-  /* Symbol for the text label used for pic.  */\n-  rtx text_label_symbol;\n-\n-  /* Register for the text label.  */\n-  rtx text_label_rtx;\n-\n-  /* Register for the pic offset table.  */\n-  rtx got_rtx;\n-\n-  /* The function calls tls_get_addr.  */\n-  int calls_tls_get_addr;\n-} machine_function;\n-\n-#ifndef HAVE_AS_TLS\n-#define HAVE_AS_TLS 0\n-#endif\n-\n-#ifndef ENDIAN_SPEC\n-#if TARGET_BIG_ENDIAN_DEFAULT\n-#define ENDIAN_SPEC \\\n-  \"%{!mlittle-endian:-EB} \\\n-   %{mlittle-endian:%{mbig-endian: \\\n-     %e-mbig-endian and -mlittle-endian may not be used together}-EL}\"\n-#else\n-#define ENDIAN_SPEC \\\n-  \"%{!mbig-endian:-EL} \\\n-   %{mbig-endian:%{mlittle-endian: \\\n-    %e-mbig-endian and -mlittle-endian may not be used together}-EB}\"\n-#endif\n-#endif\n-\n-#define EXTRA_SPECS\t\t\\\n-  { \"endian_spec\", ENDIAN_SPEC }"}, {"sha": "7f89ae5e9356f14ee24354c86aa104508600eaed", "filename": "gcc/config/tilegx/tilegx.md", "status": "removed", "additions": 0, "deletions": 5664, "changes": 5664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.md?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb"}, {"sha": "6a01aea2662aace83b17a70100a80e56d7dbabea", "filename": "gcc/config/tilegx/tilegx.opt", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,63 +0,0 @@\n-; Options for the TILE-Gx port of the compiler.\n-; Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-; Contributed by Walter Lee (walt@tilera.com)\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-HeaderInclude\n-config/tilegx/tilegx-opts.h\n-\n-mcpu=\n-Target RejectNegative Joined Enum(tilegx_cpu) Var(tilegx_cpu) Init(0)\n--mcpu=CPU\tUse features of and schedule code for given CPU.\n-\n-Enum\n-Name(tilegx_cpu) Type(int)\n-Known TILE-Gx CPUs (for use with the -mcpu= option):\n-\n-EnumValue\n-Enum(tilegx_cpu) String(tilegx) Value(0)\n-\n-m32\n-Target RejectNegative Negative(m64) Mask(32BIT)\n-Compile with 32 bit longs and pointers.\n-\n-m64\n-Target RejectNegative Negative(m32) InverseMask(32BIT, 64BIT)\n-Compile with 64 bit longs and pointers.\n-\n-mbig-endian\n-Target RejectNegative Mask(BIG_ENDIAN)\n-Use big-endian byte order.\n-\n-mlittle-endian\n-Target RejectNegative InverseMask(BIG_ENDIAN)\n-Use little-endian byte order.\n-\n-mcmodel=\n-Target RejectNegative Joined Enum(cmodel) Var(tilegx_cmodel) Init(CM_SMALL)\n-Use given TILE-Gx code model.\n-\n-Enum\n-Name(cmodel) Type(enum cmodel)\n-Known code models (for use with the -mcmodel= option):\n-\n-EnumValue\n-Enum(cmodel) String(small) Value(CM_SMALL)\n-\n-EnumValue\n-Enum(cmodel) String(large) Value(CM_LARGE)"}, {"sha": "6976aeda40ce9e74ab27b7c924453393d0e83784", "filename": "gcc/config/tilepro/constraints.md", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Fconstraints.md?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,99 +0,0 @@\n-;; Constraint definitions for Tilera TILEPro chip.\n-;; Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-;; Contributed by Walter Lee (walt@tilera.com)\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify it\n-;; under the terms of the GNU General Public License as published\n-;; by the Free Software Foundation; either version 3, or (at your\n-;; option) any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-;; License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-(define_register_constraint \"R00\" \"R0_REGS\"  \"r0\")\n-(define_register_constraint \"R01\" \"R1_REGS\"  \"r1\")\n-(define_register_constraint \"R02\" \"R2_REGS\"  \"r2\")\n-(define_register_constraint \"R03\" \"R3_REGS\"  \"r3\")\n-(define_register_constraint \"R04\" \"R4_REGS\"  \"r4\")\n-(define_register_constraint \"R05\" \"R5_REGS\"  \"r5\")\n-(define_register_constraint \"R06\" \"R6_REGS\"  \"r6\")\n-(define_register_constraint \"R07\" \"R7_REGS\"  \"r7\")\n-(define_register_constraint \"R08\" \"R8_REGS\"  \"r8\")\n-(define_register_constraint \"R09\" \"R9_REGS\"  \"r9\")\n-(define_register_constraint \"R10\" \"R10_REGS\" \"r10\")\n-\n-(define_constraint \"I\"\n-  \"A signed 8 bit constant\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -128 && ival <= 127\")))\n-\n-(define_constraint \"J\"\n-  \"Signed 16-bit integer constant\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -32768 && ival <= 32767\")))\n-\n-(define_constraint \"K\"\n-  \"Nonzero integer constant with low 16 bits zero\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival && (ival & 0xFFFF) == 0\")))\n-\n-(define_constraint \"L\"\n-  \"Integer constant that fits in one signed byte when incremented\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -129 && ival <= 126\")))\n-\n-(define_constraint \"M\"\n-  \"A bit mask suitable for 'mm'\"\n-  (and (match_code \"const_int\")\n-       (match_test \"tilepro_bitfield_operand_p (ival, NULL, NULL)\")))\n-\n-(define_constraint \"N\"\n-  \"Integer constant that is a byte tiled out four times\"\n-  (and (match_code \"const_int\")\n-       (match_test \"(ival & 0xFFFFFFFF) == (ival & 0xFF) * 0x01010101\")))\n-\n-(define_constraint \"O\"\n- \"The integer zero constant\"\n- (and (match_code \"const_int\")\n-      (match_test \"ival == 0\")))\n-\n-(define_constraint \"P\"\n-  \"Integer constant that is a sign-extended byte tiled out as two shorts\"\n-  (and (match_code \"const_int\")\n-       (match_test \"((ival & 0xFFFFFFFF)\n-                     == ((trunc_int_for_mode (ival, QImode) & 0xFFFF)\n-                         * 0x00010001))\")))\n-\n-(define_constraint \"Q\"\n-  \"Integer constant that fits in one signed byte when incremented, but not -1\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -129 && ival <= 126 && ival != -1\")))\n-\n-(define_constraint \"T\"\n-  \"A const symbolc operand\"\n-  (match_operand 0 \"const_symbolic_operand\"))\n-\n-(define_memory_constraint \"U\"\n-  \"Non-auto-incrementing memory\"\n-  (and (match_code \"mem\")\n-       (match_test \"GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC\")))\n-\n-(define_constraint \"W\"\n-  \"A 4-element vector constant with identical elements\"\n-  (and (match_code \"const_vector\")\n-       (match_test \"CONST_VECTOR_NUNITS (op) == 4\")\n-       (match_test \"const_vec_duplicate_p (op)\")))\n-\n-(define_constraint \"Y\"\n-  \"A 2-element vector constant with identical elements\"\n-  (and (match_code \"const_vector\")\n-       (match_test \"CONST_VECTOR_NUNITS (op) == 2\")\n-       (match_test \"const_vec_duplicate_p (op)\")))"}, {"sha": "34e48ed8895c277dd5ed5c629ff2418ebe0106e7", "filename": "gcc/config/tilepro/feedback.h", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ffeedback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ffeedback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ffeedback.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,14 +0,0 @@\n-#ifndef _FEEDBACK_H\n-#define _FEEDBACK_H 1\n-\n-#ifdef __ASSEMBLER__\n-\n-/* Stub defines for feedback instrumentation.  */\n-#define FEEDBACK_ENTER_EXPLICIT(FUNCNAME, SECNAME, SIZE)\n-#define FEEDBACK_ENTER(FUNCNAME)\n-#define FEEDBACK_REENTER(FUNCNAME)\n-#define FEEDBACK_ENTRY(FUNCNAME, SECNAME, SIZE)\n-\n-#endif /* __ASSEMBLER__ */\n-\n-#endif /* _FEEDBACK_H */"}, {"sha": "c125748a328e3d2b0b263be245f607a7c95de102", "filename": "gcc/config/tilepro/gen-mul-tables.cc", "status": "removed", "additions": 0, "deletions": 1369, "changes": 1369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Fgen-mul-tables.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Fgen-mul-tables.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Fgen-mul-tables.cc?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,1369 +0,0 @@\n-/* Multiply table generator for tile.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* This program creates a table used to compile multiply by constant\n-   efficiently.\n-\n-   This program should be compiled by a c++ compiler.  If it's\n-   compiled with -DTILEPRO, it generates the multiply table for\n-   TILEPro; otherwise it generates the multiply table for TILE-Gx.\n-   Running the program produces the table in stdout.\n-\n-   The program works by generating every possible combination of up to\n-   MAX_INSTRUCTIONS linear operators (such as add, sub, s2a, left\n-   shift) and computing the multiplier computed by those instructions.\n-   For example,\n-\n-   s2a r2,r1,r1\n-   s2a r3,r2,r2\n-\n-   multiplies r1 by 25.\n-\n-   There are usually multiple instruction sequences to multiply by a\n-   given constant. This program keeps only the cheapest one.\n-   \"Cheapest\" is defined first by the minimum theoretical schedule\n-   length, and if those are equal then by the number of instructions,\n-   and if those are equal then by which instructions we \"prefer\"\n-   (e.g. because we think one might take infinitesimally less power\n-   than another, or simply because we arbitrarily pick one to be more\n-   canonical).\n-\n-   Once this program has determined the best instruction sequence for\n-   each multiplier, it emits them in a table sorted by the multiplier\n-   so the user can binary-search it to look for a match.  The table is\n-   pruned based on various criteria to keep its sizes reasonable.  */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <assert.h>\n-#include <string.h>\n-#define __STDC_LIMIT_MACROS\n-#include <stdint.h>\n-\n-#include <map>\n-\n-#ifdef TILEPRO\n-\n-/* The string representing the architecture.  */\n-#define ARCH \"tilepro\"\n-\n-/* The type for the multiplication.  */\n-typedef int MUL_TYPE;\n-\n-#else\n-\n-/* The string representing the architecture.  */\n-#define ARCH \"tilegx\"\n-\n-/* The type for the multiplication.  */\n-typedef long long MUL_TYPE;\n-\n-#endif\n-\n-/* Longest instruction sequence this will produce. With the current\n-   stupid algorithm runtime grows very quickly with this number.  */\n-#define MAX_INSTRUCTIONS 4\n-\n-/* Maximum number of subexpressions in the expression DAG being\n-   generated.  This is the same as the number of instructions, except\n-   that zero and the original register we'd like to multiply by a\n-   constant are also thrown into the mix.  */\n-#define MAX_SUBEXPRS (2 + MAX_INSTRUCTIONS)\n-\n-#define MIN(x, y)  ((x) <= (y) ? (x) : (y))\n-#define MAX(x, y)  ((x) >= (y) ? (x) : (y))\n-\n-#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))\n-\n-/* For this program a unary op is one which has only one nonconstant\n-   operand.  So shift left by 5 is considered unary.  */\n-typedef MUL_TYPE (*unary_op_func) (MUL_TYPE);\n-typedef MUL_TYPE (*binary_op_func) (MUL_TYPE, MUL_TYPE);\n-\n-/* This describes an operation like 'add two registers' or 'left-shift\n-   by 7'.\n-\n-   We call something a 'unary' operator if it only takes in one\n-   register as input, even though it might have an implicit second\n-   constant operand.  Currently this is used for left-shift by\n-   constant.  */\n-class Operator\n-{\n-public:\n-  /* Construct for a binary operator.  */\n-  Operator (const char *pattern, const char *name, binary_op_func func,\n-\t    int cost)\n-    : m_pattern (pattern), m_name (name), m_top_index (-1),\n-      m_unary_func (0), m_binary_func (func), m_cost (cost),\n-      m_rhs_if_unary (0)\n-  {\n-  }\n-\n-  /* Construct for a unary operator.  */\n-  Operator (const char *pattern, const char *name, unary_op_func func,\n-\t    int rhs_if_unary, int cost)\n-    : m_pattern (pattern), m_name (name), m_top_index (-1),\n-      m_unary_func (func), m_binary_func (0), m_cost (cost),\n-      m_rhs_if_unary (rhs_if_unary)\n-  {\n-  }\n-\n-  bool is_unary () const\n-  {\n-    return m_binary_func == NULL;\n-  }\n-\n-  /* Name of the pattern for this operation, e.g. CODE_FOR_addsi3.  */\n-  const char *m_pattern;\n-\n-  /* Name of the opcode for this operation, e.g. add.  */\n-  const char *m_name;\n-\n-  /* We don't have enough bits in our output representation to store\n-     the original insn_code value, so we store a compressed form\n-     instead.  These values are decoded back into insn_code via the\n-     machine-generated multiply_insn_seq_decode_opcode lookup\n-     table.  */\n-  int m_top_index;\n-\n-  /* Unary operator to apply, or NULL if this is a binary operator.  */\n-  unary_op_func m_unary_func;\n-\n-  /* Binary operator to apply, or NULL if this is a unary operator.  */\n-  binary_op_func m_binary_func;\n-\n-  /* Function of how expensive we consider this operator. Higher is\n-     worse.  */\n-  int m_cost;\n-\n-  /* the RHS value to write into the C file if unary; used for shift\n-     count.  */\n-  int m_rhs_if_unary;\n-};\n-\n-\n-/* An entry in an expression DAG.  */\n-class Expr\n-{\n-public:\n-  Expr () : m_op (NULL), m_lhs (0), m_rhs (0), m_produced_val (0),\n-    m_critical_path_length (0)\n-  {\n-  }\n-\n-  /* The operator being applied to the operands.  */\n-  const Operator *m_op;\n-\n-  /* The index of the left-hand operand in the array of subexpressions\n-     already computed.  */\n-  int m_lhs;\n-\n-  /* For binary ops ,this is the index of the left-hand operand in the\n-     array of subexpressions already computed. For unary ops, it is\n-     specific to the op (e.g. it might hold a constant shift\n-     count).  */\n-  int m_rhs;\n-\n-  /* The multiplier produced by this expression tree. For example, for\n-     the tree ((x << 5) + x), the value would be 33.  */\n-  MUL_TYPE m_produced_val;\n-\n-  /* How far is this expression from the root, i.e. how many cycles\n-     minimum will it take to compute this?  */\n-  int m_critical_path_length;\n-};\n-\n-\n-/* Make function pointers for the various linear operators we can\n-   apply to compute a multiplicative value.  */\n-\n-static MUL_TYPE\n-add (MUL_TYPE n1, MUL_TYPE n2)\n-{\n-  return n1 + n2;\n-}\n-\n-static MUL_TYPE\n-sub (MUL_TYPE n1, MUL_TYPE n2)\n-{\n-  return n1 - n2;\n-}\n-\n-static MUL_TYPE\n-s1a (MUL_TYPE n1, MUL_TYPE n2)\n-{\n-  return n1 * 2 + n2;\n-}\n-\n-static MUL_TYPE\n-s2a (MUL_TYPE n1, MUL_TYPE n2)\n-{\n-  return n1 * 4 + n2;\n-}\n-\n-static MUL_TYPE\n-s3a (MUL_TYPE n1, MUL_TYPE n2)\n-{\n-  return n1 * 8 + n2;\n-}\n-\n-#define SHIFT(count)                            \\\n-static MUL_TYPE                                 \\\n-shift##count(MUL_TYPE n)                        \\\n-{                                               \\\n-  return n << (count);                          \\\n-}\n-\n-SHIFT (1);\n-SHIFT (2);\n-SHIFT (3);\n-SHIFT (4);\n-SHIFT (5);\n-SHIFT (6);\n-SHIFT (7);\n-SHIFT (8);\n-SHIFT (9);\n-SHIFT (10);\n-SHIFT (11);\n-SHIFT (12);\n-SHIFT (13);\n-SHIFT (14);\n-SHIFT (15);\n-SHIFT (16);\n-SHIFT (17);\n-SHIFT (18);\n-SHIFT (19);\n-SHIFT (20);\n-SHIFT (21);\n-SHIFT (22);\n-SHIFT (23);\n-SHIFT (24);\n-SHIFT (25);\n-SHIFT (26);\n-SHIFT (27);\n-SHIFT (28);\n-SHIFT (29);\n-SHIFT (30);\n-SHIFT (31);\n-#ifndef TILEPRO\n-SHIFT (32);\n-SHIFT (33);\n-SHIFT (34);\n-SHIFT (35);\n-SHIFT (36);\n-SHIFT (37);\n-SHIFT (38);\n-SHIFT (39);\n-SHIFT (40);\n-SHIFT (41);\n-SHIFT (42);\n-SHIFT (43);\n-SHIFT (44);\n-SHIFT (45);\n-SHIFT (46);\n-SHIFT (47);\n-SHIFT (48);\n-SHIFT (49);\n-SHIFT (50);\n-SHIFT (51);\n-SHIFT (52);\n-SHIFT (53);\n-SHIFT (54);\n-SHIFT (55);\n-SHIFT (56);\n-SHIFT (57);\n-SHIFT (58);\n-SHIFT (59);\n-SHIFT (60);\n-SHIFT (61);\n-SHIFT (62);\n-SHIFT (63);\n-#endif\n-\n-#ifdef TILEPRO\n-static Operator ops[] = {\n-  Operator (\"CODE_FOR_addsi3\", \"add\", add, 1040),\n-  Operator (\"CODE_FOR_subsi3\", \"sub\", sub, 1041),\n-  Operator (\"CODE_FOR_insn_s1a\", \"s1a\", s1a, 1042),\n-  Operator (\"CODE_FOR_insn_s2a\", \"s2a\", s2a, 1043),\n-  Operator (\"CODE_FOR_insn_s3a\", \"s3a\", s3a, 1044),\n-  /* Note: shl by 1 is not necessary, since adding a value to itself\n-     produces the same result. But the architecture team thinks\n-     left-shift may use slightly less power, so we might as well\n-     prefer it.  */\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift1, 1, 1001),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift2, 2, 1002),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift3, 3, 1003),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift4, 4, 1004),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift5, 5, 1005),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift6, 6, 1006),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift7, 7, 1007),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift8, 8, 1008),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift9, 9, 1009),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift10, 10, 1010),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift11, 11, 1011),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift12, 12, 1012),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift13, 13, 1013),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift14, 14, 1014),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift15, 15, 1015),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift16, 16, 1016),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift17, 17, 1017),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift18, 18, 1018),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift19, 19, 1019),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift20, 20, 1020),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift21, 21, 1021),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift22, 22, 1022),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift23, 23, 1023),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift24, 24, 1024),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift25, 25, 1025),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift26, 26, 1026),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift27, 27, 1027),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift28, 28, 1028),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift29, 29, 1029),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift30, 30, 1030),\n-  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift31, 31, 1031)\n-};\n-#else\n-static Operator ops[] = {\n-  Operator (\"CODE_FOR_adddi3\", \"add\", add, 1070),\n-  Operator (\"CODE_FOR_subdi3\", \"sub\", sub, 1071),\n-  Operator (\"CODE_FOR_insn_shl1add\", \"shl1add\", s1a, 1072),\n-  Operator (\"CODE_FOR_insn_shl2add\", \"shl2add\", s2a, 1073),\n-  Operator (\"CODE_FOR_insn_shl3add\", \"shl3add\", s3a, 1074),\n-  // Note: shl by 1 is not necessary, since adding a value to itself\n-  // produces the same result. But the architecture team thinks left-shift\n-  // may use slightly less power, so we might as well prefer it.\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift1, 1, 1001),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift2, 2, 1002),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift3, 3, 1003),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift4, 4, 1004),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift5, 5, 1005),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift6, 6, 1006),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift7, 7, 1007),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift8, 8, 1008),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift9, 9, 1009),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift10, 10, 1010),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift11, 11, 1011),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift12, 12, 1012),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift13, 13, 1013),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift14, 14, 1014),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift15, 15, 1015),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift16, 16, 1016),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift17, 17, 1017),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift18, 18, 1018),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift19, 19, 1019),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift20, 20, 1020),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift21, 21, 1021),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift22, 22, 1022),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift23, 23, 1023),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift24, 24, 1024),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift25, 25, 1025),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift26, 26, 1026),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift27, 27, 1027),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift28, 28, 1028),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift29, 29, 1029),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift30, 30, 1030),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift31, 31, 1031),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift32, 32, 1032),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift33, 33, 1033),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift34, 34, 1034),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift35, 35, 1035),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift36, 36, 1036),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift37, 37, 1037),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift38, 38, 1038),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift39, 39, 1039),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift40, 40, 1040),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift41, 41, 1041),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift42, 42, 1042),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift43, 43, 1043),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift44, 44, 1044),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift45, 45, 1045),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift46, 46, 1046),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift47, 47, 1047),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift48, 48, 1048),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift49, 49, 1049),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift50, 50, 1050),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift51, 51, 1051),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift52, 52, 1052),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift53, 53, 1053),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift54, 54, 1054),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift55, 55, 1055),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift56, 56, 1056),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift57, 57, 1057),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift58, 58, 1058),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift59, 59, 1059),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift60, 60, 1060),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift61, 61, 1061),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift62, 62, 1062),\n-  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift63, 63, 1063)\n-};\n-#endif\n-\n-/* An ExpressionTree is an expression DAG.  */\n-class ExpressionTree\n-{\n-public:\n-  ExpressionTree () : m_num_vals (2)\n-  {\n-    m_exprs[0].m_produced_val = 0;\n-    m_exprs[1].m_produced_val = 1;\n-  }\n-\n-  void copy_technique_from (ExpressionTree * other)\n-  {\n-    /* TODO: write this; other can compute the same products with less\n-       cost.  We update this ExpressionTree object because some int is\n-       already mapped to it.  */\n-  }\n-\n-  int m_num_vals;\n-  Expr m_exprs[MAX_SUBEXPRS];\n-\n-  int cost () const\n-  {\n-    int cost = 0;\n-    for (int j = 2; j < m_num_vals; j++)\n-        cost += m_exprs[j].m_op->m_cost;\n-      return cost + m_exprs[m_num_vals - 1].m_critical_path_length * 1000000;\n-  }\n-};\n-\n-\n-typedef std::map<MUL_TYPE, ExpressionTree *> ExpressionTreeMap;\n-\n-\n-static void\n-find_sequences (ExpressionTree &s, ExpressionTreeMap &best_solution)\n-{\n-  /* Don't look more if we can't add any new values to the expression\n-     tree.  */\n-  const int num_vals = s.m_num_vals;\n-  if (num_vals == MAX_SUBEXPRS)\n-    return;\n-\n-  /* Grow array to make room for new values added as we loop.  */\n-  s.m_num_vals = num_vals + 1;\n-\n-  const Operator *const prev_op = s.m_exprs[num_vals - 1].m_op;\n-  const int prev_top_index = (prev_op != NULL) ? prev_op->m_top_index : -1;\n-\n-  for (size_t f = 0; f < ARRAY_SIZE (ops); f++)\n-    {\n-      const Operator *const op = &ops[f];\n-\n-      for (int i = 0; i < num_vals; i++)\n-\t{\n-\t  /* Only allow zero as the first operand to sub, otherwise\n-\t     it is useless.  */\n-\t  if (i == 0 && op->m_binary_func != sub)\n-\t    continue;\n-\n-\t  /* Unary ops don't actually use the second operand, so as a\n-\t     big hack we trick it into only looping once in the inner\n-\t     loop.  */\n-\t  const int j_end = op->is_unary () ? 2 : num_vals;\n-\n-\t  /* We never allow zero as the second operand, as it is\n-\t     always useless.  */\n-\t  for (int j = 1; j < j_end; j++)\n-\t    {\n-\t      /* Does this expression use the immediately previous\n-\t\t expression?  */\n-\t      const bool uses_prev_value =\n-\t\t(i == num_vals - 1\n-\t\t || (!op->is_unary () && j == num_vals - 1));\n-\n-\t      if (!uses_prev_value)\n-\t\t{\n-\t\t  /* For search efficiency, prune redundant\n-\t\t     instruction orderings.\n-\n-\t\t     This op does not take the immediately preceding\n-\t\t     value as input, which means we could have done it\n-\t\t     in the previous slot. If its opcode is less than\n-\t\t     the previous instruction's, we'll declare this\n-\t\t     instruction order non-canonical and not pursue\n-\t\t     this branch of the search.  */\n-\t\t  if (op->m_top_index < prev_top_index)\n-\t\t    continue;\n-\t\t}\n-\n-\t      MUL_TYPE n;\n-\t      if (op->is_unary ())\n-\t\t{\n-\t\t  n = op->m_unary_func (s.m_exprs[i].m_produced_val);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  n = op->m_binary_func (s.m_exprs[i].m_produced_val,\n-\t\t\t\t\t s.m_exprs[j].m_produced_val);\n-\t\t}\n-\n-\t      bool duplicate = false;\n-\t      for (int k = 0; k < num_vals; k++)\n-\t\tif (n == s.m_exprs[j].m_produced_val)\n-\t\t  {\n-\t\t    duplicate = true;\n-\t\t    break;\n-\t\t  }\n-\n-\t      if (duplicate)\n-\t\tcontinue;\n-\n-\t      /* See if we found the best solution for n.  */\n-\t      Expr *e = &s.m_exprs[num_vals];\n-\t      e->m_op = op;\n-\t      e->m_lhs = i;\n-\t      e->m_rhs = op->is_unary () ? op->m_rhs_if_unary : j;\n-\t      e->m_produced_val = n;\n-\t      e->m_critical_path_length =\n-\t\t1 + MAX (s.m_exprs[i].m_critical_path_length,\n-\t\t\t s.m_exprs[j].m_critical_path_length);\n-\n-\t      ExpressionTreeMap::iterator best (best_solution.find (n));\n-\t      if (best == best_solution.end ()\n-\t\t  || (*best).second->cost () > s.cost ())\n-\t\tbest_solution[n] = new ExpressionTree (s);\n-\n-\t      /* Recurse and find more.  */\n-\t      find_sequences (s, best_solution);\n-\t    }\n-\t}\n-    }\n-\n-  /* Restore old size.  */\n-  s.m_num_vals = num_vals;\n-}\n-\n-\n-/* For each insn_code used by an operator, choose a compact number so\n-   it takes less space in the output data structure. This prints out a\n-   lookup table used to map the compactified number back to an\n-   insn_code.  */\n-static void\n-create_insn_code_compression_table ()\n-{\n-  int next_index = 1;\n-\n-  /* Entry 0 must hold CODE_FOR_nothing to mean \"end of array\".  */\n-  printf (\"const enum insn_code %s_multiply_insn_seq_decode_opcode[] = {\\n\"\n-\t  \"  CODE_FOR_nothing /* must be first */ \", ARCH);\n-\n-  for (size_t i = 0; i < ARRAY_SIZE (ops); i++)\n-    {\n-      Operator *op = &ops[i];\n-      int index = -1;\n-\n-      /* See if some previous Operator was using the same insn_code.\n-\t If so, reuse its table entry.  */\n-      for (size_t j = 0; j < i; j++)\n-\t{\n-\t  Operator *old = &ops[j];\n-\t  if (strcmp (old->m_pattern, op->m_pattern) == 0)\n-\t    {\n-\t      index = old->m_top_index;\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (index == -1)\n-\t{\n-\t  /* We need to make a new entry in the table.  */\n-\t  printf (\",\\n  %s\", op->m_pattern);\n-\t  index = next_index++;\n-\t}\n-\n-      op->m_top_index = index;\n-    }\n-\n-  printf (\"\\n};\\n\\n\");\n-}\n-\n-\n-/* These are constants we've seen in code, that we want to keep table\n-   entries for.  */\n-static int multiply_constants_used[] = {\n-  -11796480,\n-  -27439,\n-  -25148,\n-  -22820,\n-  -21709,\n-  -20995,\n-  -20284,\n-  -20239,\n-  -19595,\n-  -19447,\n-  -19183,\n-  -19165,\n-  -18730,\n-  -17828,\n-  -17799,\n-  -17237,\n-  -17036,\n-  -16549,\n-  -16423,\n-  -16294,\n-  -16244,\n-  -16069,\n-  -15137,\n-  -15083,\n-  -15038,\n-  -14924,\n-  -14905,\n-  -14752,\n-  -14731,\n-  -14529,\n-  -14273,\n-  -14090,\n-  -14084,\n-  -14043,\n-  -13850,\n-  -13802,\n-  -13631,\n-  -13455,\n-  -13275,\n-  -12879,\n-  -12700,\n-  -12534,\n-  -12399,\n-  -12131,\n-  -12112,\n-  -12054,\n-  -12019,\n-  -11759,\n-  -11585,\n-  -11467,\n-  -11395,\n-  -11295,\n-  -11248,\n-  -11148,\n-  -11116,\n-  -11086,\n-  -11059,\n-  -11018,\n-  -10811,\n-  -10538,\n-  -10258,\n-  -10217,\n-  -10033,\n-  -9766,\n-  -9754,\n-  -9534,\n-  -9527,\n-  -9467,\n-  -9262,\n-  -9232,\n-  -9222,\n-  -9198,\n-  -9191,\n-  -9113,\n-  -8825,\n-  -8756,\n-  -8697,\n-  -8693,\n-  -8565,\n-  -8342,\n-  -8208,\n-  -8200,\n-  -8170,\n-  -8102,\n-  -7770,\n-  -7678,\n-  -7562,\n-  -7376,\n-  -7373,\n-  -7221,\n-  -7121,\n-  -6835,\n-  -6810,\n-  -6626,\n-  -6581,\n-  -6461,\n-  -6278,\n-  -6263,\n-  -6163,\n-  -6029,\n-  -5816,\n-  -5540,\n-  -5461,\n-  -5384,\n-  -5329,\n-  -4985,\n-  -4926,\n-  -4815,\n-  -4788,\n-  -4758,\n-  -4433,\n-  -4229,\n-  -4209,\n-  -4176,\n-  -4104,\n-  -4095,\n-  -4078,\n-  -3941,\n-  -3818,\n-  -3600,\n-  -3474,\n-  -3314,\n-  -3264,\n-  -3196,\n-  -3072,\n-  -2912,\n-  -2836,\n-  -2773,\n-  -2269,\n-  -2184,\n-  -2100,\n-  -1730,\n-  -1512,\n-  -1500,\n-  -1396,\n-  -1344,\n-  -1312,\n-  -1297,\n-  -1059,\n-  -1058,\n-  1027,\n-  1049,\n-  1059,\n-  1100,\n-  1104,\n-  1108,\n-  1136,\n-  1200,\n-  1204,\n-  1242,\n-  1292,\n-  1304,\n-  1312,\n-  1320,\n-  1336,\n-  1344,\n-  1348,\n-  1360,\n-  1364,\n-  1395,\n-  1448,\n-  1460,\n-  1461,\n-  1472,\n-  1488,\n-  1500,\n-  1512,\n-  1568,\n-  1576,\n-  1649,\n-  1664,\n-  1684,\n-  1696,\n-  1744,\n-  1812,\n-  1822,\n-  1884,\n-  1963,\n-  1978,\n-  2000,\n-  2012,\n-  2014,\n-  2037,\n-  2039,\n-  2100,\n-  2139,\n-  2144,\n-  2184,\n-  2237,\n-  2260,\n-  2320,\n-  2408,\n-  2446,\n-  2447,\n-  2499,\n-  2531,\n-  2578,\n-  2592,\n-  2611,\n-  2633,\n-  2704,\n-  2730,\n-  2773,\n-  2880,\n-  2896,\n-  2998,\n-  3000,\n-  3001,\n-  3021,\n-  3079,\n-  3112,\n-  3150,\n-  3179,\n-  3192,\n-  3240,\n-  3264,\n-  3271,\n-  3283,\n-  3328,\n-  3363,\n-  3367,\n-  3453,\n-  3529,\n-  3570,\n-  3580,\n-  3600,\n-  3624,\n-  3707,\n-  3783,\n-  3826,\n-  3897,\n-  3941,\n-  3962,\n-  3989,\n-  4000,\n-  4025,\n-  4073,\n-  4093,\n-  4099,\n-  4108,\n-  4184,\n-  4209,\n-  4369,\n-  4376,\n-  4416,\n-  4433,\n-  4434,\n-  4482,\n-  4582,\n-  4712,\n-  4717,\n-  4813,\n-  4815,\n-  4864,\n-  5000,\n-  5027,\n-  5040,\n-  5091,\n-  5195,\n-  5243,\n-  5260,\n-  5285,\n-  5329,\n-  5331,\n-  5350,\n-  5361,\n-  5387,\n-  5461,\n-  5492,\n-  5529,\n-  5573,\n-  5793,\n-  5819,\n-  5915,\n-  5946,\n-  5992,\n-  6000,\n-  6164,\n-  6205,\n-  6262,\n-  6263,\n-  6269,\n-  6270,\n-  6387,\n-  6400,\n-  6406,\n-  6476,\n-  6541,\n-  6565,\n-  6568,\n-  6626,\n-  6656,\n-  6732,\n-  6810,\n-  6817,\n-  6859,\n-  7040,\n-  7053,\n-  7141,\n-  7169,\n-  7221,\n-  7223,\n-  7274,\n-  7282,\n-  7350,\n-  7369,\n-  7373,\n-  7442,\n-  7447,\n-  7471,\n-  7518,\n-  7542,\n-  7566,\n-  7587,\n-  7663,\n-  7678,\n-  7682,\n-  7748,\n-  7752,\n-  7791,\n-  8000,\n-  8026,\n-  8048,\n-  8170,\n-  8203,\n-  8204,\n-  8290,\n-  8368,\n-  8520,\n-  8640,\n-  8666,\n-  8672,\n-  8697,\n-  8716,\n-  8728,\n-  8756,\n-  8820,\n-  8875,\n-  8918,\n-  8956,\n-  9058,\n-  9154,\n-  9175,\n-  9191,\n-  9217,\n-  9262,\n-  9321,\n-  9373,\n-  9434,\n-  9465,\n-  9514,\n-  9534,\n-  9633,\n-  9746,\n-  9810,\n-  9850,\n-  9947,\n-  9973,\n-  10000,\n-  10009,\n-  10033,\n-  10055,\n-  10217,\n-  10248,\n-  10298,\n-  10310,\n-  10323,\n-  10368,\n-  10438,\n-  10456,\n-  10486,\n-  10538,\n-  10664,\n-  10695,\n-  10700,\n-  10703,\n-  10832,\n-  10887,\n-  10935,\n-  10958,\n-  11018,\n-  11059,\n-  11061,\n-  11086,\n-  11116,\n-  11148,\n-  11190,\n-  11249,\n-  11314,\n-  11332,\n-  11363,\n-  11409,\n-  11415,\n-  11443,\n-  11467,\n-  11512,\n-  11522,\n-  11529,\n-  11585,\n-  11759,\n-  11768,\n-  11795,\n-  11893,\n-  11997,\n-  12131,\n-  12299,\n-  12536,\n-  12543,\n-  12893,\n-  12945,\n-  12998,\n-  13109,\n-  13213,\n-  13685,\n-  13930,\n-  14023,\n-  14024,\n-  14271,\n-  14564,\n-  14647,\n-  15326,\n-  15850,\n-  15855,\n-  15929,\n-  16000,\n-  16154,\n-  16496,\n-  16807,\n-  16819,\n-  16984,\n-  17203,\n-  17223,\n-  17333,\n-  17760,\n-  17799,\n-  17837,\n-  18029,\n-  18068,\n-  18336,\n-  18515,\n-  19595,\n-  20017,\n-  20131,\n-  20862,\n-  20995,\n-  21709,\n-  22554,\n-  25000,\n-  25172,\n-  25600,\n-  25733,\n-  27439,\n-  38470,\n-  46802,\n-  50000,\n-  11796480,\n-  16843009,\n-  23592960,\n-};\n-\n-\n-const int num_mult_constants_used =\n-  (int)(sizeof multiply_constants_used\n-\t/ sizeof multiply_constants_used[0]);\n-\n-\n-#define XSIZE (sizeof multiply_constants_used / \\\n-\t       sizeof multiply_constants_used[0] + 32) / 32\n-unsigned multiply_constants_avail[XSIZE];\n-#undef XSIZE\n-\n-\n-/* bsearch helper function.  */\n-static int\n-compare_constants (const void *key, const void *t)\n-{\n-  return (*(int*)key) - *((int*)t);\n-}\n-\n-\n-static int *\n-find_mult_constants_used (int multiplier)\n-{\n-  return (int *) bsearch (&multiplier, multiply_constants_used,\n-\t\t\t  num_mult_constants_used,\n-\t\t\t  sizeof multiply_constants_used[0],\n-\t\t\t  compare_constants);\n-}\n-\n-\n-int num_ops (ExpressionTree *s)\n-{\n-  int n = 0;\n-  for (int i = 0; i < s->m_num_vals; i++)\n-    {\n-      Expr *e = &s->m_exprs[i];\n-      if (e->m_op != NULL)\n-\tn++;\n-    }\n-  return n;\n-}\n-\n-\n-#ifdef TILEPRO\n-bool\n-tilepro_emit (int multiplier, int num_ops)\n-{\n-  int abs_multiplier = (multiplier >= 0) ? multiplier : -multiplier;\n-\n-  /* Keep constants in range [-1024, 1024].  */\n-  if (abs_multiplier <= 1024)\n-    return true;\n-\n-  /* Keep constants near powers of two.  */\n-  int prev_pow2 = 1 << (31 - __builtin_clz (abs_multiplier));\n-  int next_pow2 = prev_pow2 << 1;\n-\n-  if ((abs_multiplier - prev_pow2 <= 10)\n-      || (next_pow2 - abs_multiplier <= 10))\n-    return true;\n-\n-  /* Keep constants near powers of ten.  */\n-  {\n-    long long j = 1;\n-    long long prev_pow10;\n-    long long next_pow10;\n-\n-    while (((j * 10) < abs_multiplier)\n-\t   && (j < (j * 10)))\n-      j = j * 10;\n-\n-    prev_pow10 = j;\n-    next_pow10 = j * 10;\n-\n-    if ((abs_multiplier - prev_pow10 <= 10)\n-\t|| (next_pow10 - abs_multiplier <= 10))\n-      return true;\n-  }\n-\n-  /* Keep short sequences that have two or fewer ops.  */\n-  if (num_ops <= 2)\n-    return true;\n-\n-  /* Keep constants that are mostly 0's or mostly 1's.  */\n-  if (__builtin_popcount (multiplier) <= 2 ||\n-      __builtin_popcount (multiplier) >= 30)\n-    return true;\n-\n-  /* Keep constants seen in actual code.  */\n-  if ((find_mult_constants_used (multiplier)))\n-    return true;\n-\n-  return false;\n-}\n-#else\n-bool\n-tilegx_emit (long long multiplier, int num_ops)\n-{\n-  long long abs_multiplier = (multiplier >= 0) ? multiplier : - multiplier;\n-\n-  /* Keep constants in range [-1024, 1024].  */\n-  if (abs_multiplier <= 1024)\n-    return true;\n-\n-  /* Otherwise exclude sequences with four ops.  */\n-  if (num_ops > 3)\n-    return false;\n-\n-  /* Keep constants near powers of two.  */\n-  {\n-    unsigned long long prev_pow2 =\n-      1LL << (63 - __builtin_clzll (abs_multiplier));\n-    unsigned long long next_pow2 = prev_pow2 << 1;\n-\n-    /* handle overflow case. */\n-    if (next_pow2 == 0)\n-      {\n-\tif (prev_pow2 - abs_multiplier <= 10)\n-\t  return true;\n-      }\n-    else if ((abs_multiplier - prev_pow2 <= 10)\n-\t     || (next_pow2 - abs_multiplier <= 10))\n-      return true;\n-  }\n-\n-  /* Keep constants near powers of ten.  */\n-  {\n-    long long j = 1;\n-    long long prev_pow10;\n-    long long next_pow10;\n-\n-    while (((j * 10) < abs_multiplier)\n-\t   && (j < (j * 10)))\n-      j = j * 10;\n-\n-    prev_pow10 = j;\n-    next_pow10 = j * 10;\n-\n-    if ((abs_multiplier - prev_pow10 <= 100)\n-\t|| (next_pow10\n-\t    && (next_pow10 - abs_multiplier <= 100)))\n-      return true;\n-  }\n-\n-  if (num_ops <= 2)\n-    return true;\n-\n-  /* Keep constants that are mostly 0's or mostly 1's.  */\n-  if (__builtin_popcountll (multiplier) <= 2 ||\n-      __builtin_popcountll (multiplier) >= 62)\n-    return true;\n-\n-  /* Keep constants seen in actual code.  */\n-  if (find_mult_constants_used (multiplier))\n-    return true;\n-\n-  return false;\n-}\n-#endif\n-\n-\n-int\n-main ()\n-{\n-  ExpressionTreeMap best_solution;\n-  ExpressionTree s;\n-\n-#ifdef TILEPRO\n-  printf (\"/* Constant multiply table for TILEPro.\\n\");\n-#else\n-  printf (\"/* Constant multiply table for TILE-Gx.\\n\");\n-#endif\n-  printf (\"   Copyright (C) 2011-2022 Free Software Foundation, Inc.\\n\");\n-  printf (\"   Contributed by Walter Lee (walt@tilera.com)\\n\");\n-  printf (\"\\n\");\n-  printf (\"   This file is part of GCC.\\n\");\n-  printf (\"\\n\");\n-  printf (\"   GCC is free software; you can redistribute it and/or modify it\\n\");\n-  printf (\"   under the terms of the GNU General Public License as published\\n\");\n-  printf (\"   by the Free Software Foundation; either version 3, or (at your\\n\");\n-  printf (\"   option) any later version.\\n\");\n-  printf (\"\\n\");\n-  printf (\"   GCC is distributed in the hope that it will be useful, but WITHOUT\\n\");\n-  printf (\"   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\\n\");\n-  printf (\"   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\\n\");\n-  printf (\"   License for more details.\\n\");\n-  printf (\"\\n\");\n-  printf (\"   You should have received a copy of the GNU General Public License\\n\");\n-  printf (\"   along with GCC; see the file COPYING3.  If not see\\n\");\n-  printf (\"   <http://www.gnu.org/licenses/>.  */\\n\");\n-  printf (\"\\n\");\n-  printf (\"/* Note this file is auto-generated from gen-mul-tables.cc.\\n\");\n-  printf (\"   Make any required changes there.  */\\n\");\n-  printf (\"\\n\");\n-  printf (\"#define IN_TARGET_CODE 1\\n\");\n-  printf (\"\\n\");\n-  printf (\"#include \\\"config.h\\\"\\n\");\n-  printf (\"#include \\\"system.h\\\"\\n\");\n-  printf (\"#include \\\"coretypes.h\\\"\\n\");\n-  printf (\"#include \\\"backend.h\\\"\\n\");\n-  printf (\"#include \\\"rtl.h\\\"\\n\");\n-  printf (\"#include \\\"expmed.h\\\"\\n\");\n-  printf (\"#include \\\"%s-multiply.h\\\"\\n\\n\", ARCH);\n-  create_insn_code_compression_table ();\n-\n-  /* Try all combinations of operators and see what constants we\n-     produce.  For each possible constant, record the most efficient\n-     way to generate it.  */\n-  find_sequences (s, best_solution);\n-\n-  printf (\"const struct %s_multiply_insn_seq \"\n-\t  \"%s_multiply_insn_seq_table[] = {\\n\",\n-\t  ARCH, ARCH);\n-\n-  const char *comma_separator = \"\";\n-\n-  ExpressionTreeMap::iterator i (best_solution.begin ());\n-  for (; i != best_solution.end (); ++i)\n-    {\n-      ExpressionTree *s = (*i).second;\n-      const MUL_TYPE n = (*i).first;\n-\n-      if (n == 0 || n == 1)\n-\t{\n-\t  /* Both of these require zero operations, so these entries\n-\t     are bogus and should never be used.  */\n-\t  continue;\n-\t}\n-\n-      /* Prune the list of entries to keep the table to a reasonable\n-\t size.  */\n-#ifdef TILEPRO\n-      if (!tilepro_emit (n, num_ops (s)))\n-\tcontinue;\n-#else\n-      if (!tilegx_emit (n, num_ops (s)))\n-\tcontinue;\n-#endif\n-\n-      printf (\"%s\", comma_separator);\n-\n-#ifdef TILEPRO\n-      const MUL_TYPE int_min = INT32_MIN;\n-#else\n-      const MUL_TYPE int_min = INT64_MIN;\n-#endif\n-      if (n == int_min)\n-\t{\n-\t  /* Handle C's woeful lack of unary negation. Without this,\n-\t     printing out INT_MIN in decimal will yield an unsigned\n-\t     int which could generate a compiler warning.  */\n-#ifdef TILEPRO\n-\t  printf (\"  {%d - 1 /* 0x%x */ ,\\n   {\", n + 1,\n-\t\t  (unsigned) n);\n-#else\n-\t  printf (\"  {%lldll - 1 /* 0x%llx */ ,\\n   {\", n + 1,\n-\t\t  (unsigned MUL_TYPE) n);\n-#endif\n-\t}\n-      else\n-\t{\n-#ifdef TILEPRO\n-\t  printf (\"  {%d /* 0x%x */ ,\\n   {\", n, (unsigned) n);\n-#else\n-\t  printf (\"  {%lldll /* 0x%llx */ ,\\n   {\", n, (unsigned MUL_TYPE) n);\n-#endif\n-\t}\n-\n-      bool first = true;\n-      for (int j = 0; j < s->m_num_vals; j++)\n-\t{\n-\t  Expr *e = &s->m_exprs[j];\n-\n-\t  const Operator *op = e->m_op;\n-\t  if (op == NULL)\n-\t    continue;\n-\n-\t  char buf[1024];\n-\t  snprintf (buf, sizeof buf, \"%s{%d, %d, %d}%s\",\n-\t\t    first ? \"\" : \"    \",\n-\t\t    op->m_top_index,\n-\t\t    e->m_lhs, e->m_rhs, (j + 1) == s->m_num_vals ? \"}\" : \",\");\n-\n-\t  char opnd0[10];\n-\t  if (e->m_lhs)\n-\t    snprintf (opnd0, sizeof opnd0, \"r%d\", e->m_lhs);\n-\t  else\n-\t    snprintf (opnd0, sizeof opnd0, \"zero\");\n-\n-\t  printf (\"%s\\t\\t\\t/* %s r%d, %s, %s%d */\\n\",\n-\t\t  buf, op->m_name, j, opnd0,\n-\t\t  op->is_unary () ? \"\" : \"r\", e->m_rhs);\n-\n-\t  first = false;\n-\t}\n-      printf (\"   }\");\n-      comma_separator = \",\\n\";\n-    }\n-\n-  printf (\"\\n};\\n\\n\");\n-  printf (\"const int %s_multiply_insn_seq_table_size =\\n\"\n-\t  \"  (int) (sizeof %s_multiply_insn_seq_table\\n\"\n-\t  \"         / sizeof %s_multiply_insn_seq_table[0]);\\n\",\n-\t  ARCH, ARCH, ARCH);\n-\n-  return EXIT_SUCCESS;\n-}"}, {"sha": "65a411e109f2eca07d8960be7f4e6a6a73d24ee7", "filename": "gcc/config/tilepro/linux.h", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Flinux.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,83 +0,0 @@\n-/* Definitions for TILEPro running Linux-based GNU systems with ELF.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC \"%{pthread:-D_REENTRANT}\"\n-\n-#undef\tLINK_SPEC\n-#define LINK_SPEC \"\\\n-  %{shared:-shared} \\\n-  %{!shared: \\\n-    %{!static: \\\n-      %{rdynamic:-export-dynamic} \\\n-      -dynamic-linker /lib/ld.so.1} \\\n-    %{static:-static}}\"\n-\n-#define NO_PROFILE_COUNTERS\t1\n-\n-#undef MCOUNT_NAME\n-#define MCOUNT_NAME \"__mcount\"\n-\n-#undef NEED_INDICATE_EXEC_STACK\n-#define NEED_INDICATE_EXEC_STACK 1\n-\n-#ifdef TARGET_LIBC_PROVIDES_SSP\n-/* TILEPro glibc provides __stack_chk_guard two pointer-size words before\n-   tp. */\n-#define TARGET_THREAD_SSP_OFFSET (-2 * GET_MODE_SIZE (ptr_mode))\n-#endif\n-\n-/* For __clear_cache in libgcc2.c.  */\n-#ifdef IN_LIBGCC2\n-\n-/* Use the minimum page size of 4K.  Alternatively we can call\n-   getpagesize() but it introduces a libc dependence.\n-   See Linux arch/tile/include/uapi/arch/icache.h for more commentary.  */\n-#undef CLEAR_INSN_CACHE\n-#define CLEAR_INSN_CACHE(BEG, END)                                      \\\n-{                                                                       \\\n-  long size = (long) (END) - (long) (BEG);                              \\\n-  if (size)                                                             \\\n-    {                                                                   \\\n-      const char *start = (const char *) ((unsigned long) (BEG) & -64L);\\\n-      const char *end =  start + (size < 16384 ? size : 16384) - 1;     \\\n-      long num_passes = 4;                                              \\\n-      __insn_mf ();                                                     \\\n-      do                                                                \\\n-      {                                                                 \\\n-        const char *p;                                                  \\\n-        for (p = start; p <= end; p += 64)                              \\\n-          __insn_icoh (p);                                              \\\n-        start += 4096;                                                  \\\n-        end += 4096;                                                    \\\n-      }                                                                 \\\n-      while (--num_passes > 0);                                         \\\n-      __insn_drain ();                                                  \\\n-    }                                                                   \\\n-}\n-\n-#else\n-\n-/* define CLEAR_INSN_CACHE so that gcc knows to expand __builtin__clear_cache\n-   to the libraray call.  */\n-#undef CLEAR_INSN_CACHE\n-#define CLEAR_INSN_CACHE 1\n-\n-#endif"}, {"sha": "35867b3737a3c72ef65f699df60c199dc2e91da5", "filename": "gcc/config/tilepro/mul-tables.cc", "status": "removed", "additions": 0, "deletions": 17837, "changes": 17837, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Fmul-tables.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Fmul-tables.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Fmul-tables.cc?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb"}, {"sha": "bc368c032c5fc3b9c7c9558be867b6589737fa99", "filename": "gcc/config/tilepro/predicates.md", "status": "removed", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Fpredicates.md?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,258 +0,0 @@\n-;; Predicate definitions for Tilera TILEPro chip.\n-;; Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-;; Contributed by Walter Lee (walt@tilera.com)\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify it\n-;; under the terms of the GNU General Public License as published\n-;; by the Free Software Foundation; either version 3, or (at your\n-;; option) any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-;; License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-;; Return true if OP is the zero constant for MODE.\n-(define_predicate \"const_zero_operand\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"op == CONST0_RTX (mode)\")))\n-\n-;; Returns true if OP is either the constant zero or a register.\n-(define_predicate \"reg_or_0_operand\"\n-  (and (ior (match_operand 0 \"register_operand\")\n-\t    (match_operand 0 \"const_zero_operand\"))\n-       (match_test \"GET_MODE_SIZE (mode) <= UNITS_PER_WORD\")))\n-\n-; Return 1 if OP is a network register identifier.\n-(define_predicate \"netreg_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"IN_RANGE (INTVAL (op), 0, 6)\")))\n-\n-; Return 1 if OP is an unsigned 5-bit constant.\n-(define_predicate \"u5bit_cint_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"INTVAL (op) == (INTVAL (op) & 0x1F)\")))\n-\n-;; Return 1 if OP is an unsigned 16-bit constant.\n-(define_predicate \"u16bit_cint_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"(unsigned HOST_WIDE_INT)INTVAL (op) < (1U << 16)\")))\n-\n-;; Return 1 if OP is a signed 8-bit constant.\n-(define_predicate \"s8bit_cint_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"satisfies_constraint_I (op)\")))\n-\n-;; Return 1 if OP is a signed 16-bit constant.\n-(define_predicate \"s16bit_cint_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"satisfies_constraint_J (op)\")))\n-\n-;; Return 1 if OP is a nonzero integer constant whose low 16 bits are zero.\n-(define_predicate \"auli_cint_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"satisfies_constraint_K (op)\")))\n-\n-;; Return 1 if OP is an unsigned 15-bit constant.\n-(define_predicate \"u15bit_cint_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"(unsigned HOST_WIDE_INT)INTVAL (op) < (1U << 15)\")))\n-\n-;; Return 1 if OP is a constant or any register.\n-(define_predicate \"reg_or_cint_operand\"\n-  (ior (match_operand 0 \"register_operand\")\n-       (match_operand 0 \"const_int_operand\")))\n-\n-;; Return 1 if OP is a 4-element vector constant with identical signed\n-;; 8-bit elements or any register.\n-(define_predicate \"reg_or_v4s8bit_operand\"\n-  (ior (match_operand 0 \"register_operand\")\n-       (and (match_code \"const_vector\")\n-\t    (match_test \"CONST_VECTOR_NUNITS (op) == 4\n-                         && (satisfies_constraint_I\n-\t\t\t     (unwrap_const_vec_duplicate (op)))\"))))\n-\n-;; Return 1 if OP is a 2-element vector constant with identical signed\n-;; 8-bit elements or any register.\n-(define_predicate \"reg_or_v2s8bit_operand\"\n-  (ior (match_operand 0 \"register_operand\")\n-       (and (match_code \"const_vector\")\n-\t    (match_test \"CONST_VECTOR_NUNITS (op) == 2\n-                         && (satisfies_constraint_I\n-\t\t\t     (unwrap_const_vec_duplicate (op)))\"))))\n-\n-;; Return 1 if the operand is a valid second operand to an add insn.\n-(define_predicate \"add_operand\"\n-  (if_then_else (match_code \"const_int\")\n-    (match_test \"satisfies_constraint_J (op) || satisfies_constraint_K (op)\")\n-    (match_operand 0 \"register_operand\")))\n-\n-;; Return 1 if the operand is a register or signed 8-bit immediate operand.\n-(define_predicate \"reg_or_s8bit_operand\"\n-  (if_then_else (match_code \"const_int\")\n-    (match_test \"satisfies_constraint_I (op)\")\n-    (match_operand 0 \"register_operand\")))\n-\n-;; Return 1 for an operand suitable for ANDing with a register.\n-(define_predicate \"and_operand\"\n-  (if_then_else (match_code \"const_int\")\n-    (match_test \"satisfies_constraint_I (op) || satisfies_constraint_M (op)\")\n-    (match_operand 0 \"register_operand\")))\n-\n-;; Return 1 if the operand is a register or unsigned 5-bit immediate operand.\n-(define_predicate \"reg_or_u5bit_operand\"\n-  (if_then_else (match_code \"const_int\")\n-    (match_test \"INTVAL (op) == (INTVAL (op) & 0x1F)\")\n-    (match_operand 0 \"register_operand\")))\n-\n-; Return 1 if the operand is 2, 4 or 8.\n-(define_predicate \"cint_248_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test\n-        \"INTVAL (op) == 2 || INTVAL (op) == 4 || INTVAL (op) == 8\")))\n-\n-\n-;; Return true if OP is a TLS symbolic operand.\n-(define_predicate \"tls_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) !=  TLS_MODEL_NONE\")))\n-\n-;; Return true if OP is a symbolic operand for the TLS Global Dynamic model.\n-(define_predicate \"tls_gd_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_GLOBAL_DYNAMIC\")))\n-\n-;; Return true if OP is a symbolic operand for the TLS Local Dynamic model.\n-(define_predicate \"tls_ld_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_DYNAMIC\")))\n-\n-;; Return true if OP is a symbolic operand that can be used for the\n-;; TLS Initial Exec model.\n-(define_predicate \"tls_ie_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (ior (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_INITIAL_EXEC\")\n-            (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC\"))))\n-\n-;; Return true if OP is a symbolic operand for the TLS Local Exec model.\n-(define_predicate \"tls_le_symbolic_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC\")))\n-\n-;; Returns true if OP is any general operand except for an\n-;; auto-incrementing address operand.\n-(define_predicate \"nonautoinc_operand\"\n-  (and (match_operand 0 \"general_operand\")\n-       (not (ior (match_code \"pre_dec\") (match_code \"pre_inc\")\n-\t\t (match_code \"post_dec\") (match_code \"post_inc\")\n-\t\t (match_code \"post_modify\") (match_code \"pre_modify\")))))\n-\n-;; Returns true if OP is a non-auto-incrementing memory operand.\n-(define_predicate \"nonautoincmem_operand\"\n-  (match_operand 0 \"memory_operand\")\n-{\n-  return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n-})\n-\n-;; Returns true if OP is a non-auto-incrementing memory, general\n-;; operand.\n-(define_predicate \"nonautoincmem_general_operand\"\n-  (match_operand 0 \"general_operand\")\n-{\n-  if (memory_operand (op, mode))\n-    return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n-  else\n-    return true;\n-})\n- \n-;; Returns true if OP is a non-auto-incrementing memory, non-immediate\n-;; operand.\n-(define_predicate \"nonautoincmem_nonimmediate_operand\"\n-  (match_operand 0 \"nonimmediate_operand\")\n-{\n-  if (memory_operand (op, mode))\n-    return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n-  else\n-    return true;\n-})\n- \n-;; Return true if OP is a valid operand for the source of a move insn.\n-(define_predicate \"move_operand\"\n-  (match_operand 0 \"general_operand\")\n-{\n-  /* If both modes are non-void they must be the same.  */\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return false;\n-\n-  if (GET_MODE_SIZE (mode) > 4)\n-    return false;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_INT:\n-      return (satisfies_constraint_J (op)\n-              || satisfies_constraint_K (op)\n-              || satisfies_constraint_N (op)\n-              || satisfies_constraint_P (op));\n-\n-    case HIGH:\n-      return true;\n-\n-    case MEM:\n-      return memory_address_p (mode, XEXP (op, 0));\n-\n-    default:\n-      return register_operand (op, mode);\n-    }\n-})\n-\n-;; Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n-;; possibly with an offset.\n-(define_predicate \"symbolic_operand\"\n-  (ior (match_code \"symbol_ref,label_ref\")\n-       (and (match_code \"const\")\n-\t    (match_test \"GET_CODE (XEXP (op,0)) == PLUS\n-\t\t\t && (GET_CODE (XEXP (XEXP (op,0), 0)) == SYMBOL_REF\n-\t\t\t     || GET_CODE (XEXP (XEXP (op,0), 0)) == LABEL_REF)\n-\t\t\t && CONST_INT_P (XEXP (XEXP (op,0), 1))\"))))\n-\n-;; Returns 1 if OP is a symbolic operand, or a const unspec wrapper\n-;; representing a got reference, a tls reference, or pc-relative\n-;; reference.\n-(define_predicate \"const_symbolic_operand\"\n-  (ior (match_operand 0 \"symbolic_operand\")\n-       (and (match_code \"const\")\n-\t    (match_test \"GET_CODE (XEXP (op,0)) == UNSPEC\")\n-\t    (ior (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_GOT16_SYM\")\n-\t\t (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_GOT32_SYM\")\n-\t\t (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_PCREL_SYM\")\n-\t\t (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_TLS_GD\")\n-\t\t (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_TLS_IE\")\n-\t\t (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_TLS_LE\")))))\n-\n-;; Return true if OP is an address suitable for a call insn.\n-;; Call insn on TILE can take a PC-relative constant address\n-;; or any regular memory address.\n-(define_predicate \"call_address_operand\"\n-  (ior (match_operand 0 \"symbolic_operand\")\n-       (match_test \"memory_address_p (Pmode, op)\")))\n-\n-;; Return true if OP is an operand suitable for a call insn.\n-(define_predicate \"call_operand\"\n-  (and (match_code \"mem\")\n-       (match_test \"call_address_operand (XEXP (op, 0), mode)\")))\n-\n-;; Return 1 if OP is a signed comparison operation.\n-;; We can use these directly in compares against zero.\n-(define_predicate \"signed_comparison_operator\"\n-  (match_code \"eq,ne,le,lt,ge,gt\"))\n-\n-;; Return 1 if OP is a equal or not-equal operation.\n-(define_predicate \"eqne_operator\"\n-  (match_code \"eq,ne\"))"}, {"sha": "f64fd129d9b7e652e9c490a6a117e7122e0798cf", "filename": "gcc/config/tilepro/t-tilepro", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ft-tilepro", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ft-tilepro", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ft-tilepro?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,15 +0,0 @@\n-tilepro-c.o: $(srcdir)/config/tilepro/tilepro-c.cc \\\n-    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(MACHMODE_H) \\\n-    $(TM_H) $(TM_P_H) $(CPPLIB_H) $(TREE_H) $(C_COMMON_H)\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n-\n-$(srcdir)/config/tilepro/mul-tables.cc: \\\n-    $(srcdir)/config/tilepro/gen-mul-tables.cc\n-\t$(CXX_FOR_BUILD) $(BUILD_CPPFLAGS) -O2 -DTILEPRO \\\n-\t  -o gen-mul-tables $<;\n-\t./gen-mul-tables > $@\n-\n-mul-tables.o: $(srcdir)/config/tilepro/mul-tables.cc \\\n-    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(EXPR_H) $(OPTABS_H) \\\n-    $(srcdir)/config/tilepro/tilepro-multiply.h\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<"}, {"sha": "f18bdb5f3faffe4367790e7f5eef8c384b2f665f", "filename": "gcc/config/tilepro/tilepro-builtins.h", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-builtins.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,216 +0,0 @@\n-/* Enum for builtin intrinsics for TILEPro.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_TILEPRO_BUILTINS_H\n-#define GCC_TILEPRO_BUILTINS_H\n-\n-enum tilepro_builtin\n-{\n-  TILEPRO_INSN_ADD,\n-  TILEPRO_INSN_ADDB,\n-  TILEPRO_INSN_ADDBS_U,\n-  TILEPRO_INSN_ADDH,\n-  TILEPRO_INSN_ADDHS,\n-  TILEPRO_INSN_ADDIB,\n-  TILEPRO_INSN_ADDIH,\n-  TILEPRO_INSN_ADDLIS,\n-  TILEPRO_INSN_ADDS,\n-  TILEPRO_INSN_ADIFFB_U,\n-  TILEPRO_INSN_ADIFFH,\n-  TILEPRO_INSN_AND,\n-  TILEPRO_INSN_AULI,\n-  TILEPRO_INSN_AVGB_U,\n-  TILEPRO_INSN_AVGH,\n-  TILEPRO_INSN_BITX,\n-  TILEPRO_INSN_BYTEX,\n-  TILEPRO_INSN_CLZ,\n-  TILEPRO_INSN_CRC32_32,\n-  TILEPRO_INSN_CRC32_8,\n-  TILEPRO_INSN_CTZ,\n-  TILEPRO_INSN_DRAIN,\n-  TILEPRO_INSN_DTLBPR,\n-  TILEPRO_INSN_DWORD_ALIGN,\n-  TILEPRO_INSN_FINV,\n-  TILEPRO_INSN_FLUSH,\n-  TILEPRO_INSN_FNOP,\n-  TILEPRO_INSN_ICOH,\n-  TILEPRO_INSN_ILL,\n-  TILEPRO_INSN_INFO,\n-  TILEPRO_INSN_INFOL,\n-  TILEPRO_INSN_INTHB,\n-  TILEPRO_INSN_INTHH,\n-  TILEPRO_INSN_INTLB,\n-  TILEPRO_INSN_INTLH,\n-  TILEPRO_INSN_INV,\n-  TILEPRO_INSN_LB,\n-  TILEPRO_INSN_LB_U,\n-  TILEPRO_INSN_LH,\n-  TILEPRO_INSN_LH_U,\n-  TILEPRO_INSN_LNK,\n-  TILEPRO_INSN_LW,\n-  TILEPRO_INSN_LW_NA,\n-  TILEPRO_INSN_LB_L2,\n-  TILEPRO_INSN_LB_U_L2,\n-  TILEPRO_INSN_LH_L2,\n-  TILEPRO_INSN_LH_U_L2,\n-  TILEPRO_INSN_LW_L2,\n-  TILEPRO_INSN_LW_NA_L2,\n-  TILEPRO_INSN_LB_MISS,\n-  TILEPRO_INSN_LB_U_MISS,\n-  TILEPRO_INSN_LH_MISS,\n-  TILEPRO_INSN_LH_U_MISS,\n-  TILEPRO_INSN_LW_MISS,\n-  TILEPRO_INSN_LW_NA_MISS,\n-  TILEPRO_INSN_MAXB_U,\n-  TILEPRO_INSN_MAXH,\n-  TILEPRO_INSN_MAXIB_U,\n-  TILEPRO_INSN_MAXIH,\n-  TILEPRO_INSN_MF,\n-  TILEPRO_INSN_MFSPR,\n-  TILEPRO_INSN_MINB_U,\n-  TILEPRO_INSN_MINH,\n-  TILEPRO_INSN_MINIB_U,\n-  TILEPRO_INSN_MINIH,\n-  TILEPRO_INSN_MM,\n-  TILEPRO_INSN_MNZ,\n-  TILEPRO_INSN_MNZB,\n-  TILEPRO_INSN_MNZH,\n-  TILEPRO_INSN_MOVE,\n-  TILEPRO_INSN_MOVELIS,\n-  TILEPRO_INSN_MTSPR,\n-  TILEPRO_INSN_MULHH_SS,\n-  TILEPRO_INSN_MULHH_SU,\n-  TILEPRO_INSN_MULHH_UU,\n-  TILEPRO_INSN_MULHHA_SS,\n-  TILEPRO_INSN_MULHHA_SU,\n-  TILEPRO_INSN_MULHHA_UU,\n-  TILEPRO_INSN_MULHHSA_UU,\n-  TILEPRO_INSN_MULHL_SS,\n-  TILEPRO_INSN_MULHL_SU,\n-  TILEPRO_INSN_MULHL_US,\n-  TILEPRO_INSN_MULHL_UU,\n-  TILEPRO_INSN_MULHLA_SS,\n-  TILEPRO_INSN_MULHLA_SU,\n-  TILEPRO_INSN_MULHLA_US,\n-  TILEPRO_INSN_MULHLA_UU,\n-  TILEPRO_INSN_MULHLSA_UU,\n-  TILEPRO_INSN_MULLL_SS,\n-  TILEPRO_INSN_MULLL_SU,\n-  TILEPRO_INSN_MULLL_UU,\n-  TILEPRO_INSN_MULLLA_SS,\n-  TILEPRO_INSN_MULLLA_SU,\n-  TILEPRO_INSN_MULLLA_UU,\n-  TILEPRO_INSN_MULLLSA_UU,\n-  TILEPRO_INSN_MVNZ,\n-  TILEPRO_INSN_MVZ,\n-  TILEPRO_INSN_MZ,\n-  TILEPRO_INSN_MZB,\n-  TILEPRO_INSN_MZH,\n-  TILEPRO_INSN_NAP,\n-  TILEPRO_INSN_NOP,\n-  TILEPRO_INSN_NOR,\n-  TILEPRO_INSN_OR,\n-  TILEPRO_INSN_PACKBS_U,\n-  TILEPRO_INSN_PACKHB,\n-  TILEPRO_INSN_PACKHS,\n-  TILEPRO_INSN_PACKLB,\n-  TILEPRO_INSN_PCNT,\n-  TILEPRO_INSN_PREFETCH,\n-  TILEPRO_INSN_PREFETCH_L1,\n-  TILEPRO_INSN_RL,\n-  TILEPRO_INSN_S1A,\n-  TILEPRO_INSN_S2A,\n-  TILEPRO_INSN_S3A,\n-  TILEPRO_INSN_SADAB_U,\n-  TILEPRO_INSN_SADAH,\n-  TILEPRO_INSN_SADAH_U,\n-  TILEPRO_INSN_SADB_U,\n-  TILEPRO_INSN_SADH,\n-  TILEPRO_INSN_SADH_U,\n-  TILEPRO_INSN_SB,\n-  TILEPRO_INSN_SEQ,\n-  TILEPRO_INSN_SEQB,\n-  TILEPRO_INSN_SEQH,\n-  TILEPRO_INSN_SEQIB,\n-  TILEPRO_INSN_SEQIH,\n-  TILEPRO_INSN_SH,\n-  TILEPRO_INSN_SHL,\n-  TILEPRO_INSN_SHLB,\n-  TILEPRO_INSN_SHLH,\n-  TILEPRO_INSN_SHLIB,\n-  TILEPRO_INSN_SHLIH,\n-  TILEPRO_INSN_SHR,\n-  TILEPRO_INSN_SHRB,\n-  TILEPRO_INSN_SHRH,\n-  TILEPRO_INSN_SHRIB,\n-  TILEPRO_INSN_SHRIH,\n-  TILEPRO_INSN_SLT,\n-  TILEPRO_INSN_SLT_U,\n-  TILEPRO_INSN_SLTB,\n-  TILEPRO_INSN_SLTB_U,\n-  TILEPRO_INSN_SLTE,\n-  TILEPRO_INSN_SLTE_U,\n-  TILEPRO_INSN_SLTEB,\n-  TILEPRO_INSN_SLTEB_U,\n-  TILEPRO_INSN_SLTEH,\n-  TILEPRO_INSN_SLTEH_U,\n-  TILEPRO_INSN_SLTH,\n-  TILEPRO_INSN_SLTH_U,\n-  TILEPRO_INSN_SLTIB,\n-  TILEPRO_INSN_SLTIB_U,\n-  TILEPRO_INSN_SLTIH,\n-  TILEPRO_INSN_SLTIH_U,\n-  TILEPRO_INSN_SNE,\n-  TILEPRO_INSN_SNEB,\n-  TILEPRO_INSN_SNEH,\n-  TILEPRO_INSN_SRA,\n-  TILEPRO_INSN_SRAB,\n-  TILEPRO_INSN_SRAH,\n-  TILEPRO_INSN_SRAIB,\n-  TILEPRO_INSN_SRAIH,\n-  TILEPRO_INSN_SUB,\n-  TILEPRO_INSN_SUBB,\n-  TILEPRO_INSN_SUBBS_U,\n-  TILEPRO_INSN_SUBH,\n-  TILEPRO_INSN_SUBHS,\n-  TILEPRO_INSN_SUBS,\n-  TILEPRO_INSN_SW,\n-  TILEPRO_INSN_TBLIDXB0,\n-  TILEPRO_INSN_TBLIDXB1,\n-  TILEPRO_INSN_TBLIDXB2,\n-  TILEPRO_INSN_TBLIDXB3,\n-  TILEPRO_INSN_TNS,\n-  TILEPRO_INSN_WH64,\n-  TILEPRO_INSN_XOR,\n-  TILEPRO_NETWORK_BARRIER,\n-  TILEPRO_IDN0_RECEIVE,\n-  TILEPRO_IDN1_RECEIVE,\n-  TILEPRO_IDN_SEND,\n-  TILEPRO_SN_RECEIVE,\n-  TILEPRO_SN_SEND,\n-  TILEPRO_UDN0_RECEIVE,\n-  TILEPRO_UDN1_RECEIVE,\n-  TILEPRO_UDN2_RECEIVE,\n-  TILEPRO_UDN3_RECEIVE,\n-  TILEPRO_UDN_SEND,\n-  TILEPRO_BUILTIN_max\n-};\n-\n-#endif /* !GCC_TILEPRO_BUILTINS_H */"}, {"sha": "ed91e710854b9732cb2185c78104020f4b66f7ae", "filename": "gcc/config/tilepro/tilepro-c.cc", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-c.cc?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,54 +0,0 @@\n-/* Definitions of C specific functions for TILEPro.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#define IN_TARGET_CODE 1\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"c-family/c-common.h\"\n-\n-/* copy defines in c-cppbuiltin.cc */\n-# define builtin_define(TXT) cpp_define (pfile, TXT)\n-# define builtin_assert(TXT) cpp_assert (pfile, TXT)\n-\n-\n-/* Implement TARGET_CPU_CPP_BUILTINS.  */\n-void\n-tilepro_cpu_cpp_builtins (struct cpp_reader *pfile)\n-{\n-  builtin_define (\"__tile__\");\n-  builtin_define (\"__tilepro__\");\n-  builtin_assert (\"cpu=tile\");\n-  builtin_assert (\"machine=tile\");\n-  builtin_define (\"__tile_chip__=1\");\n-  builtin_define (\"__tile_chip_rev__=0\");\n-\n-  builtin_define (\"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1\");\n-  builtin_define (\"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2\");\n-  builtin_define (\"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\");\n-  builtin_define (\"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8\");\n-\n-  TILEPRO_CPU_CPP_ENDIAN_BUILTINS ();\n-  GNU_USER_TARGET_OS_CPP_BUILTINS ();\n-}\n-\n-"}, {"sha": "438c4d94bf072e84a00eb3bcb7d6079d9ddcc38e", "filename": "gcc/config/tilepro/tilepro-generic.md", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-generic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-generic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-generic.md?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,107 +0,0 @@\n-;; Scheduling description for Tilera TILEPro chip.\n-;; Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-;; Contributed by Walter Lee (walt@tilera.com)\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify it\n-;; under the terms of the GNU General Public License as published\n-;; by the Free Software Foundation; either version 3, or (at your\n-;; option) any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-;; License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-(define_automaton \"tile\")\n-\n-; Make the scheduling automaton an ndfa.\n-(automata_option \"ndfa\")\n-\n-; Name the three pipes.\n-(define_cpu_unit \"X0\" \"tile\")\n-(define_cpu_unit \"X1\" \"tile\")\n-(define_cpu_unit \"Y0\" \"tile\")\n-(define_cpu_unit \"Y1\" \"tile\")\n-(define_cpu_unit \"Y2\" \"tile\")\n-\n-(define_insn_reservation \"X0\" 1\n-  (eq_attr \"type\" \"X0\")\n-  \"X0\")\n-\n-(define_insn_reservation \"X0_2cycle\" 2\n-  (eq_attr \"type\" \"X0_2cycle\")\n-  \"X0,nothing\")\n-\n-(define_insn_reservation \"X1\" 1\n-  (eq_attr \"type\" \"X1,X1_branch\")\n-  \"X1\")\n-\n-(define_insn_reservation \"X1_2cycle\" 2\n-  (eq_attr \"type\" \"X1_2cycle\")\n-  \"X1,nothing\")\n-\n-(define_insn_reservation \"X1_L2\" 8\n-  (eq_attr \"type\" \"X1_L2\")\n-  \"X1\")\n-\n-(define_insn_reservation \"X1_miss\" 80\n-  (eq_attr \"type\" \"X1_miss\")\n-  \"X1\")\n-\n-(define_insn_reservation \"X01\" 1\n-  (eq_attr \"type\" \"X01\")\n-  \"X0|X1\")\n-\n-(define_insn_reservation \"Y0\" 1\n-  (eq_attr \"type\" \"Y0\")\n-  \"Y0|X0\")\n-\n-(define_insn_reservation \"Y0_2cycle\" 2\n-  (eq_attr \"type\" \"Y0_2cycle\")\n-  \"Y0|X0,nothing\")\n-\n-(define_insn_reservation \"Y2\" 1\n-  (eq_attr \"type\" \"Y2\")\n-  \"Y2|X1\")\n-\n-(define_insn_reservation \"Y2_2cycle\" 2\n-  (eq_attr \"type\" \"Y2_2cycle\")\n-  \"Y2|X1,nothing\")\n-\n-(define_insn_reservation \"Y2_L2\" 8\n-  (eq_attr \"type\" \"Y2_L2\")\n-  \"Y2|X1\")\n-\n-(define_insn_reservation \"Y2_miss\" 80\n-  (eq_attr \"type\" \"Y2_miss\")\n-  \"Y2|X1\")\n-\n-(define_insn_reservation \"Y01\" 1\n-  (eq_attr \"type\" \"Y01\")\n-  \"Y0|Y1|X0|X1\")\n-\n-(define_insn_reservation \"nothing\" 0\n-  (eq_attr \"type\" \"nothing\")\n-  \"nothing\")\n-\n-(define_insn_reservation \"cannot_bundle\" 1\n-  (eq_attr \"type\" \"cannot_bundle\")\n-  \"X0+X1\")\n-\n-(define_insn_reservation \"cannot_bundle_3cycle\" 3\n-  (eq_attr \"type\" \"cannot_bundle_3cycle\")\n-  \"X0+X1\")\n-\n-(define_insn_reservation \"cannot_bundle_4cycle\" 4\n-  (eq_attr \"type\" \"cannot_bundle_4cycle\")\n-  \"X0+X1\")\n-\n-\n-; A bundle must be in either X format or Y format.\n-(exclusion_set \"X0,X1\" \"Y0,Y1,Y2\")"}, {"sha": "16478951c0f50fa20237c1657898a84f4611573e", "filename": "gcc/config/tilepro/tilepro-modes.def", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-modes.def?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,34 +0,0 @@\n-/* TILEPro extra machine modes.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Extra modes for handling struct returns in up to 10 registers. */\n-INT_MODE (R3I, 12);\n-INT_MODE (R5I, 20);\n-INT_MODE (R6I, 24);\n-INT_MODE (R7I, 28);\n-INT_MODE (R8I, 32);\n-INT_MODE (R9I, 36);\n-INT_MODE (R10I, 40);\n-\n-/* Vector modes.  */\n-VECTOR_MODES (INT, 4);    /* V4QI V2HI */\n-VECTOR_MODE (INT, QI, 8); /* V8QI */\n-VECTOR_MODE (INT, HI, 4); /* V4HI */\n-VECTOR_MODE (INT, QI, 2); /* V2QI */"}, {"sha": "dde904826cafba17a30512f816ba35b3fa3b7b60", "filename": "gcc/config/tilepro/tilepro-multiply.h", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-multiply.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-multiply.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-multiply.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,82 +0,0 @@\n-/* Header for constant multiple table for TILEPro.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_TILEPRO_MULTIPLY_H\n-#define GCC_TILEPRO_MULTIPLY_H\n-\n-/* A node of a tilepro_multiply_insn_seq, corresponding to a single\n-   machine instruction such as 'add', 's1a', or an shl by a\n-   constant.  */\n-struct tilepro_multiply_insn_seq_entry\n-{\n-  /* Which operation this node performs (e.g. an add or sub).  Don't\n-     use this directly, call get_opcode() table to get a\n-     insn_code.  */\n-  unsigned char compressed_opcode;\n-\n-  /* The left-hand side of this expression tree.\n-     If equal to 0, it refers to 'zero'.\n-     If equal to 1, it refers to the original input to the multiply\n-     operation.\n-     Otherwise, subtract two and it is an index into the containing\n-     tilepro_multiply_insn_seq's 'op' array. Since it can only point\n-     to some value that has already been computed it will always point\n-     to an earlier entry in the array.  */\n-  unsigned char lhs;\n-\n-  /* This is like lhs, but for the right-hand side. However, for shift\n-     opcodes this is a shift count rather than an operand index.  */\n-  unsigned char rhs;\n-};\n-\n-/* Maximum size of op array.  */\n-#define tilepro_multiply_insn_seq_MAX_OPERATIONS 4\n-\n-/* This defines a DAG describing how to multiply by a constant in\n-   terms of one or more machine instructions.  */\n-struct tilepro_multiply_insn_seq\n-{\n-  /* The constant factor by which this expression tree multiplies its\n-     input.  */\n-  int multiplier;\n-\n-  /* The nodes of the parse tree. These are ordered so that\n-     instructions can be emitted in the same order that they appear in\n-     this array.  Entry entry in this array can only refer to earlier\n-     entries in the array.  */\n-  struct tilepro_multiply_insn_seq_entry\n-    op[tilepro_multiply_insn_seq_MAX_OPERATIONS];\n-\n-};\n-\n-/* A mapping from the compressed opcode to the corresponding enum\n-   insn_code.  */\n-extern const enum insn_code tilepro_multiply_insn_seq_decode_opcode[];\n-\n-/* Table mapping constant int multipliers to an expression tree that\n-   efficiently performs that multiplication.  This is sorted by its\n-   'multiplier' field so a binary search can look for matches.  */\n-extern const struct tilepro_multiply_insn_seq\n-  tilepro_multiply_insn_seq_table[];\n-\n-/* The number of elements in multiply_insn_seq_table.  */\n-extern const int tilepro_multiply_insn_seq_table_size;\n-\n-#endif /* !GCC_TILEPRO_MULTIPLY_H */"}, {"sha": "ba09fdd4127992bf42ae2ca0639e1772c812267a", "filename": "gcc/config/tilepro/tilepro-protos.h", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-protos.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,76 +0,0 @@\n-/* Prototypes of target machine for TILEPro.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC__TILEPRO_PROTOS_H\n-#define GCC__TILEPRO_PROTOS_H\n-\n-\n-extern void tilepro_init_expanders (void);\n-extern bool tilepro_legitimate_pic_operand_p (rtx);\n-extern rtx tilepro_simd_int (rtx, machine_mode);\n-\n-#ifdef RTX_CODE\n-extern void split_di (rtx[], int, rtx[], rtx[]);\n-extern bool tilepro_bitfield_operand_p (HOST_WIDE_INT, int *, int *);\n-extern void tilepro_expand_set_const32 (rtx, rtx);\n-extern bool tilepro_expand_mov (machine_mode, rtx *);\n-extern void tilepro_expand_insv (rtx operands[4]);\n-extern void tilepro_expand_unaligned_load (rtx, rtx, HOST_WIDE_INT,\n-\t\t\t\t\t   HOST_WIDE_INT, bool);\n-extern void tilepro_expand_movmisalign (machine_mode, rtx *);\n-extern bool tilepro_expand_addsi (rtx, rtx, rtx);\n-extern void tilepro_allocate_stack (rtx, rtx);\n-extern bool tilepro_expand_mulsi (rtx, rtx, rtx);\n-extern void tilepro_expand_smulsi3_highpart (rtx, rtx, rtx);\n-extern void tilepro_expand_umulsi3_highpart (rtx, rtx, rtx);\n-\n-extern bool tilepro_emit_setcc (rtx[], machine_mode);\n-extern void tilepro_emit_conditional_branch (rtx[], machine_mode);\n-extern rtx tilepro_emit_conditional_move (rtx);\n-extern const char *tilepro_output_cbranch_with_opcode (rtx_insn *, rtx *,\n-\t\t\t\t\t\t       const char *,\n-\t\t\t\t\t\t       const char *, int,\n-\t\t\t\t\t\t       bool);\n-extern const char *tilepro_output_cbranch (rtx_insn *, rtx *, bool);\n-extern void tilepro_expand_tablejump (rtx, rtx);\n-extern void tilepro_expand_builtin_vector_binop (rtx (*)(rtx, rtx, rtx),\n-\t\t\t\t\t\t machine_mode, rtx,\n-\t\t\t\t\t\t machine_mode, rtx, rtx,\n-\t\t\t\t\t\t bool);\n-#endif /* RTX_CODE */\n-\n-extern bool tilepro_can_use_return_insn_p (void);\n-extern void tilepro_expand_prologue (void);\n-extern void tilepro_expand_epilogue (bool);\n-extern int tilepro_initial_elimination_offset (int, int);\n-extern rtx tilepro_return_addr (int, rtx);\n-extern rtx tilepro_eh_return_handler_rtx (void);\n-extern int tilepro_adjust_insn_length (rtx_insn *, int);\n-\n-extern int tilepro_asm_preferred_eh_data_format (int, int);\n-extern void tilepro_final_prescan_insn (rtx_insn *);\n-extern const char *tilepro_asm_output_opcode (FILE *, const char *);\n-extern void tilepro_function_profiler (FILE *, int);\n-\n-/* Declare functions in tile-c.c */\n-\n-extern void tilepro_cpu_cpp_builtins (struct cpp_reader *);\n-\n-#endif /* GCC_TILEPRO_PROTOS_H */"}, {"sha": "35a6b8ce61fd20f5caff7ea417aaccc57c8a373d", "filename": "gcc/config/tilepro/tilepro.cc", "status": "removed", "additions": 0, "deletions": 5083, "changes": 5083, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.cc?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb"}, {"sha": "6c37aba9c44eb810312319c90ee0030d722bfdee", "filename": "gcc/config/tilepro/tilepro.h", "status": "removed", "additions": 0, "deletions": 457, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,457 +0,0 @@\n-/* Definitions of target machine for GNU compiler for TILEPro.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* This is used by tilepro_cpu_cpp_builtins to indicate the byte order\n-   we're compiling for.  */\n-#define TILEPRO_CPU_CPP_ENDIAN_BUILTINS()\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      if (BYTES_BIG_ENDIAN)\t\t\t\\\n-\tbuiltin_define (\"__BIG_ENDIAN__\");\t\\\n-      else\t\t\t\t\t\\\n-\tbuiltin_define (\"__LITTLE_ENDIAN__\");\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Target CPU builtins.  */\n-#define TARGET_CPU_CPP_BUILTINS() \\\n-  tilepro_cpu_cpp_builtins (pfile)\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\f\n-\n-/* Target machine storage layout */\n-\n-#define BITS_BIG_ENDIAN 0\n-#define BYTES_BIG_ENDIAN 0\n-#define WORDS_BIG_ENDIAN 0\n-\n-#define UNITS_PER_WORD 4\n-#define PARM_BOUNDARY 32\n-#define STACK_BOUNDARY 64\n-#define FUNCTION_BOUNDARY 64\n-#define BIGGEST_ALIGNMENT 64\n-#define STRICT_ALIGNMENT 1\n-\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-#define FASTEST_ALIGNMENT 32\n-#define BIGGEST_FIELD_ALIGNMENT 64\n-\n-/* Make arrays of chars word-aligned for the same reasons.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n-\n-/* Make local arrays of chars word-aligned for the same reasons.  */\n-#define LOCAL_ALIGNMENT(TYPE, ALIGN) DATA_ALIGNMENT (TYPE, ALIGN)\n-\f\n-\n-/* Standard register usage.  */\n-\n-#define FIRST_PSEUDO_REGISTER (64 + 3)\n-\n-#define FIXED_REGISTERS \\\n- {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1}\n-\n-#define CALL_REALLY_USED_REGISTERS \\\n- {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1}\n-\n-#define REG_ALLOC_ORDER {\t\t\t\t\\\n-      10, 11, 12, 13, 14, /* call used */\t\t\\\n-      15, 16, 17, 18, 19,\t\t\t\t\\\n-      20, 21, 22, 23, 24,\t\t\t\t\\\n-      25, 26, 27, 28, 29,\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      9, 8, 7, 6, 5,      /* argument */\t\t\\\n-      4, 3, 2, 1, 0,\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      55,\t          /* return address */\t\t\\\n-\t\t\t\t\t\t\t\\\n-      30, 31, 32, 33, 34, /* call saved registers */\t\\\n-      35, 36, 37, 38, 39,\t\t\t\t\\\n-      40, 41, 42, 43, 44,\t\t\t\t\\\n-      45, 46, 47, 48, 49,\t\t\t\t\\\n-      50, 51,\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      52, \t\t  /* hard frame pointer */\t\\\n-      53, 54, \t\t  /* tp, sp */\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      56, 57, 58, 59, 60, /* special purpose */\t\t\\\n-      61, 62, 63, 64, 65, /* or fake registers */\t\\\n-      66\t\t\t\t\t\t\\\n-}\n-\n-/* Register that holds an address into the text segment that can be\n-   used by pic code.  */\n-#define TILEPRO_PIC_TEXT_LABEL_REGNUM (flag_pic ? 50 : INVALID_REGNUM)\n-#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 51 : INVALID_REGNUM)\n-#define HARD_FRAME_POINTER_REGNUM 52\n-#define THREAD_POINTER_REGNUM 53\n-#define STACK_POINTER_REGNUM 54\n-#define TILEPRO_LINK_REGNUM 55\n-#define FRAME_POINTER_REGNUM 64\n-#define ARG_POINTER_REGNUM 65\n-/* Pseudo register used to enforce order between instructions that\n-   touch the networks.  */\n-#define TILEPRO_NETORDER_REGNUM 66\n-#define STATIC_CHAIN_REGNUM 10\n-\f\n-\n-enum reg_class\n-{\n-  NO_REGS,\n-  R0_REGS,\n-  R1_REGS,\n-  R2_REGS,\n-  R3_REGS,\n-  R4_REGS,\n-  R5_REGS,\n-  R6_REGS,\n-  R7_REGS,\n-  R8_REGS,\n-  R9_REGS,\n-  R10_REGS,\n-  ALL_REGS,\n-  LIM_REG_CLASSES\n-};\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Since GENERAL_REGS is the same class as ALL_REGS, don't give it a\n-   different class number; just make it an alias.  */\n-#define GENERAL_REGS ALL_REGS\n-\n-#define REG_CLASS_NAMES\t\\\n-  { \\\n-    \"NO_REGS\", \\\n-    \"R0_REGS\", \\\n-    \"R1_REGS\", \\\n-    \"R2_REGS\", \\\n-    \"R3_REGS\", \\\n-    \"R4_REGS\", \\\n-    \"R5_REGS\", \\\n-    \"R6_REGS\", \\\n-    \"R7_REGS\", \\\n-    \"R8_REGS\", \\\n-    \"R9_REGS\", \\\n-    \"R10_REGS\", \\\n-    \"ALL_REGS\" \\\n-  }\n-\n-#define REG_CLASS_CONTENTS \\\n-  { \\\n-    { 0 }, \\\n-    { 1 << 0 }, \\\n-    { 1 << 1 }, \\\n-    { 1 << 2 }, \\\n-    { 1 << 3 }, \\\n-    { 1 << 4 }, \\\n-    { 1 << 5 }, \\\n-    { 1 << 6 }, \\\n-    { 1 << 7 }, \\\n-    { 1 << 8 }, \\\n-    { 1 << 9 }, \\\n-    { 1 << 10 }, \\\n-    { 0xffffffff, 0xffffffff } \\\n-  }\n-\n-#define REGNO_REG_CLASS(REGNO) \\\n-  ((unsigned)(REGNO) <= 10 ? \\\n-   (enum reg_class)(R0_REGS + (REGNO)) : ALL_REGS)\n-\n-#define INDEX_REG_CLASS NO_REGS\n-#define BASE_REG_CLASS ALL_REGS\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\f\n-\n-/* Stack layout; function entry, exit and calling.  */\n-\n-#define STACK_GROWS_DOWNWARD 1\n-#define FRAME_GROWS_DOWNWARD 1\n-\n-#define DYNAMIC_CHAIN_ADDRESS(FRAME) \\\n-  plus_constant (Pmode, (FRAME), UNITS_PER_WORD)\n-\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n-\n-#define INCOMING_FRAME_SP_OFFSET 0\n-\n-#define STACK_POINTER_OFFSET (2 * UNITS_PER_WORD)\n-\n-#define ARG_POINTER_CFA_OFFSET(FNDECL) (-STACK_POINTER_OFFSET)\n-\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/* The first 10 registers may hold return value.  */\n-#define TILEPRO_NUM_RETURN_REGS 10\n-\n-/* The first 10 registers hold function arguments.  */\n-#define TILEPRO_NUM_ARG_REGS 10\n-\n-#define FUNCTION_ARG_REGNO_P(N) ((N) < TILEPRO_NUM_ARG_REGS)\n-\n-/* The type used to store the number of words of arguments scanned so\n-   far during argument scanning.  This includes any space that is\n-   skipped.  */\n-#define CUMULATIVE_ARGS int\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n- ((CUM) = 0)\n-\f\n-\n-#define ELIMINABLE_REGS\t\t\t\t\t\\\n-  {{ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM},\t\t\\\n-  {ARG_POINTER_REGNUM,\t HARD_FRAME_POINTER_REGNUM},\t\\\n-  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n-  {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n-  ((OFFSET) = tilepro_initial_elimination_offset((FROM),(TO)))\n-\n-#define PROFILE_BEFORE_PROLOGUE 1\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO) \\\n-  tilepro_function_profiler (FILE, LABELNO)\n-\n-#define TRAMPOLINE_SIZE 48\n-#define TRAMPOLINE_ALIGNMENT 64\n-#define TRAMPOLINE_SECTION text_section\n-\f\n-\n-/* Call frame debugging information.  */\n-\n-#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, TILEPRO_LINK_REGNUM)\n-\n-#define RETURN_ADDR_RTX tilepro_return_addr\n-\n-#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (TILEPRO_LINK_REGNUM)\n-\n-#define DWARF_ZERO_REG 63\n-\n-#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N + 12) : INVALID_REGNUM)\n-#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 11)\n-#define EH_RETURN_HANDLER_RTX tilepro_eh_return_handler_rtx ()\n-\n-#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL) \\\n-  tilepro_asm_preferred_eh_data_format ((CODE), (GLOBAL))\n-\f\n-\n-/* Addressing modes, and classification of registers for them.  */\n-\n-#define HAVE_POST_INCREMENT 1\n-#define HAVE_POST_DECREMENT 1\n-#define HAVE_POST_MODIFY_DISP 1\n-\n-#define REGNO_OK_FOR_INDEX_P(regno) 0\n-#define REGNO_OK_FOR_BASE_P(regno)\t\\\n-  ((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n-\n-#define MAX_REGS_PER_ADDRESS 1\n-\n-#define CONSTANT_ADDRESS_P(X) 0\n-\n-#define LEGITIMATE_PIC_OPERAND_P(X) tilepro_legitimate_pic_operand_p (X)\n-\f\n-\n-#define CASE_VECTOR_MODE SImode\n-#define CASE_VECTOR_PC_RELATIVE 0\n-#define JUMP_TABLES_IN_TEXT_SECTION 0\n-\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-#define MOVE_MAX UNITS_PER_WORD\n-\n-/* Use a value of 11 for MOVE_RATIO and friends, because TILEPro\n-   returns structs as large as 10 words in registers.  Because of some\n-   some code generation inefficiency, we never get smaller code for\n-   turning that into a memcpy, so pick a value that guarantees this\n-   doesn't happen.  */\n-#define TILEPRO_CALL_RATIO 11\n-#define MOVE_RATIO(speed) ((speed) ? 15 : TILEPRO_CALL_RATIO)\n-#define CLEAR_RATIO(speed) ((speed) ? 15 : TILEPRO_CALL_RATIO)\n-#define SET_RATIO(speed) ((speed) ? 15 : TILEPRO_CALL_RATIO)\n-\n-#define WORD_REGISTER_OPERATIONS 1\n-\n-#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n-\n-#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n-      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\\n-    (MODE) = SImode;\n-\n-/* Define SLOW_BYTE_ACCESS to avoid making a QI or HI mode\n-   register.  */\n-#define SLOW_BYTE_ACCESS 1\n-\n-#define SHIFT_COUNT_TRUNCATED 1\n-\n-#define SHORT_IMMEDIATES_SIGN_EXTEND 1\n-\n-#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = 32, 1)\n-#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = 32, 1)\n-\n-#define Pmode SImode\n-\n-#define STORE_FLAG_VALUE 1\n-\n-#define FUNCTION_MODE SImode\n-\n-#define NO_FUNCTION_CSE 1\n-\n-#define ADJUST_INSN_LENGTH(INSN, LENGTH) \\\n-  ((LENGTH) = tilepro_adjust_insn_length ((INSN), (LENGTH)))\n-\n-#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n-\n-#define BRANCH_COST(speed_p, predictable_p) ((predictable_p) ? 2 : 6)\n-\f\n-\n-/* Control the assembler format that we output.  */\n-\n-#undef NO_DOLLAR_IN_LABEL\n-\n-#define ASM_COMMENT_START \"##\"\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-#undef READONLY_DATA_SECTION_ASM_OP\n-#define READONLY_DATA_SECTION_ASM_OP \"\\t.section\\t.rodata, \\\"a\\\"\"\n-\n-#undef BSS_SECTION_ASM_OP\n-#define BSS_SECTION_ASM_OP\t\"\\t.section\\t.bss, \\\"wa\\\"\"\n-\n-#undef INIT_SECTION_ASM_OP\n-#define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init, \\\"ax\\\"\"\n-\n-#undef FINI_SECTION_ASM_OP\n-#define FINI_SECTION_ASM_OP\t\"\\t.section\\t.fini, \\\"ax\\\"\"\n-\n-#define GLOBAL_ASM_OP \".global \"\n-\n-#define SUPPORTS_WEAK 1\n-\n-#define USER_LABEL_PREFIX \"\"\n-\n-#define REGISTER_PREFIX \"\"\n-#define REGISTER_NAMES                                                  \\\n-  { \"r0\",   \"r1\",   \"r2\",   \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\",       \\\n-    \"r8\",   \"r9\",   \"r10\",  \"r11\",  \"r12\",  \"r13\",  \"r14\",  \"r15\",      \\\n-    \"r16\",  \"r17\",  \"r18\",  \"r19\",  \"r20\",  \"r21\",  \"r22\",  \"r23\",      \\\n-    \"r24\",  \"r25\",  \"r26\",  \"r27\",  \"r28\",  \"r29\",  \"r30\",  \"r31\",      \\\n-    \"r32\",  \"r33\",  \"r34\",  \"r35\",  \"r36\",  \"r37\",  \"r38\",  \"r39\",      \\\n-    \"r40\",  \"r41\",  \"r42\",  \"r43\",  \"r44\",  \"r45\",  \"r46\",  \"r47\",      \\\n-    \"r48\",  \"r49\",  \"r50\",  \"r51\",  \"r52\",  \"tp\",   \"sp\",   \"lr\",       \\\n-    \"sn\",   \"idn0\", \"idn1\", \"udn0\", \"udn1\", \"udn2\", \"udn3\", \"zero\",     \\\n-    \"?FRAME?\", \"?ARG?\", \"?NET?\" }\n-\n-/* This is used to help emit bundles.  */\n-#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n-  tilepro_final_prescan_insn (insn)\n-\n-/* This is used to help emit bundles.  */\n-#define ASM_OUTPUT_OPCODE(STREAM, PTR)\t\\\n-  (PTR = tilepro_asm_output_opcode (STREAM, PTR))\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      char label[256];\t\t\t\t\t\\\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (VALUE));\\\n-      fprintf (FILE, \"\\t.word \");\t\t\t\\\n-      assemble_name (FILE, label);\t\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      char label[256];\t\t\t\t\t\t\\\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (VALUE));\t\\\n-      fprintf (FILE, \"\\t.word \");\t\t\t\t\\\n-      assemble_name (FILE, label);\t\t\t\t\\\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (REL));\t\t\\\n-      fprintf (FILE, \"-\");\t\t\t\t\t\\\n-      assemble_name (FILE, label);\t\t\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n-  do { if ((LOG) != 0) fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG)); } while (0)\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n-  ( fputs (\".comm \", (FILE)),\t\t\t\t\\\n-    assemble_name ((FILE), (NAME)),\t\t\t\\\n-    fprintf ((FILE), \",%u\\n\", (unsigned int)(ROUNDED)))\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n-  ( fputs (\".lcomm \", (FILE)),\t\t\t\t\\\n-    assemble_name ((FILE), (NAME)),\t\t\t\\\n-    fprintf ((FILE), \",%u\\n\", (unsigned int)(ROUNDED)))\n-\n-\f\n-\n-#define INIT_EXPANDERS tilepro_init_expanders ()\n-\n-/* A C structure for machine-specific, per-function data.  This is\n-   added to the cfun structure.  */\n-typedef struct GTY(()) machine_function\n-{\n-  /* Symbol for the text label used for pic.  */\n-  rtx text_label_symbol;\n-\n-  /* Register for the text label.  */\n-  rtx text_label_rtx;\n-\n-  /* Register for the pic offset table.  */\n-  rtx got_rtx;\n-\n-  /* The function calls tls_get_addr.  */\n-  int calls_tls_get_addr;\n-} machine_function;\n-\n-#ifndef HAVE_AS_TLS\n-#define HAVE_AS_TLS 0\n-#endif"}, {"sha": "d5d362c6413d0f5ae1e7e1748c65acbfc8805cca", "filename": "gcc/config/tilepro/tilepro.md", "status": "removed", "additions": 0, "deletions": 3816, "changes": 3816, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.md?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb"}, {"sha": "74ba0f3f4f39c6caaa1585ac1afdd7f260b3d952", "filename": "gcc/config/tilepro/tilepro.opt", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/gcc%2Fconfig%2Ftilepro%2Ftilepro.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.opt?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,36 +0,0 @@\n-; Options for the TILEPro port of the compiler.\n-; Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-; Contributed by Walter Lee (walt@tilera.com)\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-m32\n-Target RejectNegative\n-Compile with 32 bit longs and pointers, which is the only supported\n-behavior and thus the flag is ignored.\n-\n-mcpu=\n-Target RejectNegative Joined Enum(tilepro_cpu) Var(tilepro_cpu) Init(0)\n--mcpu=CPU\tUse features of and schedule code for given CPU.\n-\n-Enum\n-Name(tilepro_cpu) Type(int)\n-Known TILEPro CPUs (for use with the -mcpu= option):\n-\n-EnumValue\n-Enum(tilepro_cpu) String(tilepro) Value(0)\n-"}, {"sha": "62872d132ea2d13cb88566cecae3c828c4fd2d60", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -25804,33 +25804,6 @@ foo:\t.long\t25\n \txor\t%l1, %tle_lox10(foo), %o5\n \tld\t[%g7 + %o5], %o1\"\n \t;;\n-  tilepro*-*-*)\n-      conftest_s='\n-\t.section \".tdata\",\"awT\",@progbits\n-foo:\t.long\t25\n-\t.text\n-\taddli\tr0, zero, tls_gd(foo)\n-\tauli\tr0, zero, tls_gd_ha16(foo)\n-\taddli\tr0, r0, tls_gd_lo16(foo)\n-\tjal\t__tls_get_addr\n-\taddli\tr0, zero, tls_ie(foo)\n-\tauli\tr0, r0, tls_ie_ha16(foo)\n-\taddli\tr0, r0, tls_ie_lo16(foo)'\n-\ttls_as_opt=\"--fatal-warnings\"\n-\t;;\n-  tilegx*-*-*)\n-      conftest_s='\n-\t.section \".tdata\",\"awT\",@progbits\n-foo:\t.long\t25\n-\t.text\n-\tshl16insli r0, zero, hw0_last_tls_gd(foo)\n-\tshl16insli r0, zero, hw1_last_tls_gd(foo)\n-\tshl16insli r0, r0,   hw0_tls_gd(foo)\n-\tjal\t   __tls_get_addr\n-\tshl16insli r0, zero, hw1_last_tls_ie(foo)\n-\tshl16insli r0, r0,   hw0_tls_ie(foo)'\n-\ttls_as_opt=\"--fatal-warnings\"\n-\t;;\n   xtensa*-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits\n@@ -29086,7 +29059,7 @@ esac\n case \"$cpu_type\" in\n   aarch64 | alpha | arc | arm | avr | bfin | cris | csky | i386 | loongarch | m32c \\\n   | m68k | microblaze | mips | nds32 | nios2 | pa | riscv | rs6000 | score | sparc \\\n-  | tilegx | tilepro | visium | xstormy16 | xtensa)\n+  | visium | xstormy16 | xtensa)\n     insn=\"nop\"\n     ;;\n   ia64 | s390)"}, {"sha": "446747311a6aec3c810ad6aa4190f7bd383b94f7", "filename": "gcc/configure.ac", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -4082,33 +4082,6 @@ foo:\t.long\t25\n \txor\t%l1, %tle_lox10(foo), %o5\n \tld\t[%g7 + %o5], %o1\"\n \t;;\n-  tilepro*-*-*)\n-      conftest_s='\n-\t.section \".tdata\",\"awT\",@progbits\n-foo:\t.long\t25\n-\t.text\n-\taddli\tr0, zero, tls_gd(foo)\n-\tauli\tr0, zero, tls_gd_ha16(foo)\n-\taddli\tr0, r0, tls_gd_lo16(foo)\n-\tjal\t__tls_get_addr\n-\taddli\tr0, zero, tls_ie(foo)\n-\tauli\tr0, r0, tls_ie_ha16(foo)\n-\taddli\tr0, r0, tls_ie_lo16(foo)'\n-\ttls_as_opt=\"--fatal-warnings\"\n-\t;;\n-  tilegx*-*-*)\n-      conftest_s='\n-\t.section \".tdata\",\"awT\",@progbits\n-foo:\t.long\t25\n-\t.text\n-\tshl16insli r0, zero, hw0_last_tls_gd(foo)\n-\tshl16insli r0, zero, hw1_last_tls_gd(foo)\n-\tshl16insli r0, r0,   hw0_tls_gd(foo)\n-\tjal\t   __tls_get_addr\n-\tshl16insli r0, zero, hw1_last_tls_ie(foo)\n-\tshl16insli r0, r0,   hw0_tls_ie(foo)'\n-\ttls_as_opt=\"--fatal-warnings\"\n-\t;;\n   xtensa*-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits\n@@ -5419,7 +5392,7 @@ esac\n case \"$cpu_type\" in\n   aarch64 | alpha | arc | arm | avr | bfin | cris | csky | i386 | loongarch | m32c \\\n   | m68k | microblaze | mips | nds32 | nios2 | pa | riscv | rs6000 | score | sparc \\\n-  | tilegx | tilepro | visium | xstormy16 | xtensa)\n+  | visium | xstormy16 | xtensa)\n     insn=\"nop\"\n     ;;\n   ia64 | s390)"}, {"sha": "dfbe33ac652f8d179864956f72baa4fd10bd915d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -14638,8 +14638,6 @@ instructions, but allow the compiler to schedule those calls.\n * SH Built-in Functions::\n * SPARC VIS Built-in Functions::\n * TI C6X Built-in Functions::\n-* TILE-Gx Built-in Functions::\n-* TILEPro Built-in Functions::\n * x86 Built-in Functions::\n * x86 transactional memory intrinsics::\n * x86 control-flow protection intrinsics::\n@@ -21572,75 +21570,6 @@ int _abs (int);\n int _abs2 (int);\n @end smallexample\n \n-@node TILE-Gx Built-in Functions\n-@subsection TILE-Gx Built-in Functions\n-\n-GCC provides intrinsics to access every instruction of the TILE-Gx\n-processor.  The intrinsics are of the form:\n-\n-@smallexample\n-\n-unsigned long long __insn_@var{op} (...)\n-\n-@end smallexample\n-\n-Where @var{op} is the name of the instruction.  Refer to the ISA manual\n-for the complete list of instructions.\n-\n-GCC also provides intrinsics to directly access the network registers.\n-The intrinsics are:\n-\n-@smallexample\n-unsigned long long __tile_idn0_receive (void);\n-unsigned long long __tile_idn1_receive (void);\n-unsigned long long __tile_udn0_receive (void);\n-unsigned long long __tile_udn1_receive (void);\n-unsigned long long __tile_udn2_receive (void);\n-unsigned long long __tile_udn3_receive (void);\n-void __tile_idn_send (unsigned long long);\n-void __tile_udn_send (unsigned long long);\n-@end smallexample\n-\n-The intrinsic @code{void __tile_network_barrier (void)} is used to\n-guarantee that no network operations before it are reordered with\n-those after it.\n-\n-@node TILEPro Built-in Functions\n-@subsection TILEPro Built-in Functions\n-\n-GCC provides intrinsics to access every instruction of the TILEPro\n-processor.  The intrinsics are of the form:\n-\n-@smallexample\n-\n-unsigned __insn_@var{op} (...)\n-\n-@end smallexample\n-\n-@noindent\n-where @var{op} is the name of the instruction.  Refer to the ISA manual\n-for the complete list of instructions.\n-\n-GCC also provides intrinsics to directly access the network registers.\n-The intrinsics are:\n-\n-@smallexample\n-unsigned __tile_idn0_receive (void);\n-unsigned __tile_idn1_receive (void);\n-unsigned __tile_sn_receive (void);\n-unsigned __tile_udn0_receive (void);\n-unsigned __tile_udn1_receive (void);\n-unsigned __tile_udn2_receive (void);\n-unsigned __tile_udn3_receive (void);\n-void __tile_idn_send (unsigned);\n-void __tile_sn_send (unsigned);\n-void __tile_udn_send (unsigned);\n-@end smallexample\n-\n-The intrinsic @code{void __tile_network_barrier (void)} is used to\n-guarantee that no network operations before it are reordered with\n-those after it.\n-\n @node x86 Built-in Functions\n @subsection x86 Built-in Functions\n "}, {"sha": "460da3a0fd512242afc5d05f2c2f75ef4b2a45d7", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -758,7 +758,7 @@ mips64orion, mips64vr, mipsel, mipsisa32, mipsisa32r2, mipsisa64, mipsisa64r2,\n mipsisa64r2el, mipsisa64sb1, mipsisa64sr71k, mipstx39, mmix, mn10300, moxie,\n msp430, nds32be, nds32le, nios2, nvptx, or1k, pdp11, powerpc, powerpc64,\n powerpc64le, powerpcle, pru, riscv32, riscv32be, riscv64, riscv64be, rl78, rx,\n-s390, s390x, sh, shle, sparc, sparc64, tic6x, tilegx, tilegxbe, tilepro, v850,\n+s390, s390x, sh, shle, sparc, sparc64, tic6x, v850,\n v850e, v850e1, vax, visium, x86_64, xstormy16, xtensa\n @end quotation\n \n@@ -3675,12 +3675,6 @@ information have to.\n @item\n @uref{#c6x-x-x,,c6x-*-*}\n @item\n-@uref{#tilegx-x-linux,,tilegx-*-linux*}\n-@item\n-@uref{#tilegxbe-x-linux,,tilegxbe-*-linux*}\n-@item\n-@uref{#tilepro-x-linux,,tilepro-*-linux*}\n-@item\n @uref{#visium-x-elf, visium-*-elf}\n @item\n @uref{#x-x-vxworks,,*-*-vxworks*}\n@@ -4978,30 +4972,6 @@ This is a synonym for @samp{sparc64-*-solaris2*}.\n @heading c6x-*-*\n The C6X family of processors. This port requires binutils-2.22 or newer.\n \n-@html\n-<hr />\n-@end html\n-@anchor{tilegx-*-linux}\n-@heading tilegx-*-linux*\n-The TILE-Gx processor in little endian mode, running GNU/Linux.  This\n-port requires binutils-2.22 or newer.\n-\n-@html\n-<hr />\n-@end html\n-@anchor{tilegxbe-*-linux}\n-@heading tilegxbe-*-linux*\n-The TILE-Gx processor in big endian mode, running GNU/Linux.  This\n-port requires binutils-2.23 or newer.\n-\n-@html\n-<hr />\n-@end html\n-@anchor{tilepro-*-linux}\n-@heading tilepro-*-linux*\n-The TILEPro processor running GNU/Linux.  This port requires\n-binutils-2.22 or newer.\n-\n @html\n <hr />\n @end html"}, {"sha": "bde59ff047249f46dd4370aaf1c57eefe41d33f5", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -1368,13 +1368,6 @@ See RS/6000 and PowerPC Options.\n @emph{System V Options}\n @gccoptlist{-Qy  -Qn  -YP,@var{paths}  -Ym,@var{dir}}\n \n-@emph{TILE-Gx Options}\n-@gccoptlist{-mcpu=CPU  -m32  -m64  -mbig-endian  -mlittle-endian @gol\n--mcmodel=@var{code-model}}\n-\n-@emph{TILEPro Options}\n-@gccoptlist{-mcpu=@var{cpu}  -m32}\n-\n @emph{V850 Options}\n @gccoptlist{-mlong-calls  -mno-long-calls  -mep  -mno-ep @gol\n -mprolog-function  -mno-prolog-function  -mspace @gol\n@@ -19174,8 +19167,6 @@ platform.\n * Solaris 2 Options::\n * SPARC Options::\n * System V Options::\n-* TILE-Gx Options::\n-* TILEPro Options::\n * V850 Options::\n * VAX Options::\n * Visium Options::\n@@ -31068,63 +31059,6 @@ The assembler uses this option.\n @c the generic assembler that comes with Solaris takes just -Ym.\n @end table\n \n-@node TILE-Gx Options\n-@subsection TILE-Gx Options\n-@cindex TILE-Gx options\n-\n-These @samp{-m} options are supported on the TILE-Gx:\n-\n-@table @gcctabopt\n-@item -mcmodel=small\n-@opindex mcmodel=small\n-Generate code for the small model.  The distance for direct calls is\n-limited to 500M in either direction.  PC-relative addresses are 32\n-bits.  Absolute addresses support the full address range.\n-\n-@item -mcmodel=large\n-@opindex mcmodel=large\n-Generate code for the large model.  There is no limitation on call\n-distance, pc-relative addresses, or absolute addresses.\n-\n-@item -mcpu=@var{name}\n-@opindex mcpu\n-Selects the type of CPU to be targeted.  Currently the only supported\n-type is @samp{tilegx}.\n-\n-@item -m32\n-@itemx -m64\n-@opindex m32\n-@opindex m64\n-Generate code for a 32-bit or 64-bit environment.  The 32-bit\n-environment sets int, long, and pointer to 32 bits.  The 64-bit\n-environment sets int to 32 bits and long and pointer to 64 bits.\n-\n-@item -mbig-endian\n-@itemx -mlittle-endian\n-@opindex mbig-endian\n-@opindex mlittle-endian\n-Generate code in big/little endian mode, respectively.\n-@end table\n-\n-@node TILEPro Options\n-@subsection TILEPro Options\n-@cindex TILEPro options\n-\n-These @samp{-m} options are supported on the TILEPro:\n-\n-@table @gcctabopt\n-@item -mcpu=@var{name}\n-@opindex mcpu\n-Selects the type of CPU to be targeted.  Currently the only supported\n-type is @samp{tilepro}.\n-\n-@item -m32\n-@opindex m32\n-Generate code for a 32-bit environment, which sets int, long, and\n-pointer to 32 bits.  This is the only supported behavior so the flag\n-is essentially ignored.\n-@end table\n-\n @node V850 Options\n @subsection V850 Options\n @cindex V850 Options"}, {"sha": "04aedfadbd11275899e2161de5810507ba83a3d9", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -3859,154 +3859,6 @@ Register B14 (aka DP).\n \n @end table\n \n-@item TILE-Gx---@file{config/tilegx/constraints.md}\n-@table @code\n-@item R00\n-@itemx R01\n-@itemx R02\n-@itemx R03\n-@itemx R04\n-@itemx R05\n-@itemx R06\n-@itemx R07\n-@itemx R08\n-@itemx R09\n-@itemx R10\n-Each of these represents a register constraint for an individual\n-register, from r0 to r10.\n-\n-@item I\n-Signed 8-bit integer constant.\n-\n-@item J\n-Signed 16-bit integer constant.\n-\n-@item K\n-Unsigned 16-bit integer constant.\n-\n-@item L\n-Integer constant that fits in one signed byte when incremented by one\n-(@minus{}129 @dots{} 126).\n-\n-@item m\n-Memory operand.  If used together with @samp{<} or @samp{>}, the\n-operand can have postincrement which requires printing with @samp{%In}\n-and @samp{%in} on TILE-Gx.  For example:\n-\n-@smallexample\n-asm (\"st_add %I0,%1,%i0\" : \"=m<>\" (*mem) : \"r\" (val));\n-@end smallexample\n-\n-@item M\n-A bit mask suitable for the BFINS instruction.\n-\n-@item N\n-Integer constant that is a byte tiled out eight times.\n-\n-@item O\n-The integer zero constant.\n-\n-@item P\n-Integer constant that is a sign-extended byte tiled out as four shorts.\n-\n-@item Q\n-Integer constant that fits in one signed byte when incremented\n-(@minus{}129 @dots{} 126), but excluding -1.\n-\n-@item S\n-Integer constant that has all 1 bits consecutive and starting at bit 0.\n-\n-@item T\n-A 16-bit fragment of a got, tls, or pc-relative reference.\n-\n-@item U\n-Memory operand except postincrement.  This is roughly the same as\n-@samp{m} when not used together with @samp{<} or @samp{>}.\n-\n-@item W\n-An 8-element vector constant with identical elements.\n-\n-@item Y\n-A 4-element vector constant with identical elements.\n-\n-@item Z0\n-The integer constant 0xffffffff.\n-\n-@item Z1\n-The integer constant 0xffffffff00000000.\n-\n-@end table\n-\n-@item TILEPro---@file{config/tilepro/constraints.md}\n-@table @code\n-@item R00\n-@itemx R01\n-@itemx R02\n-@itemx R03\n-@itemx R04\n-@itemx R05\n-@itemx R06\n-@itemx R07\n-@itemx R08\n-@itemx R09\n-@itemx R10\n-Each of these represents a register constraint for an individual\n-register, from r0 to r10.\n-\n-@item I\n-Signed 8-bit integer constant.\n-\n-@item J\n-Signed 16-bit integer constant.\n-\n-@item K\n-Nonzero integer constant with low 16 bits zero.\n-\n-@item L\n-Integer constant that fits in one signed byte when incremented by one\n-(@minus{}129 @dots{} 126).\n-\n-@item m\n-Memory operand.  If used together with @samp{<} or @samp{>}, the\n-operand can have postincrement which requires printing with @samp{%In}\n-and @samp{%in} on TILEPro.  For example:\n-\n-@smallexample\n-asm (\"swadd %I0,%1,%i0\" : \"=m<>\" (mem) : \"r\" (val));\n-@end smallexample\n-\n-@item M\n-A bit mask suitable for the MM instruction.\n-\n-@item N\n-Integer constant that is a byte tiled out four times.\n-\n-@item O\n-The integer zero constant.\n-\n-@item P\n-Integer constant that is a sign-extended byte tiled out as two shorts.\n-\n-@item Q\n-Integer constant that fits in one signed byte when incremented\n-(@minus{}129 @dots{} 126), but excluding -1.\n-\n-@item T\n-A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative\n-reference.\n-\n-@item U\n-Memory operand except postincrement.  This is roughly the same as\n-@samp{m} when not used together with @samp{<} or @samp{>}.\n-\n-@item W\n-A 4-element vector constant with identical elements.\n-\n-@item Y\n-A 2-element vector constant with identical elements.\n-\n-@end table\n-\n @item Visium---@file{config/visium/constraints.md}\n @table @code\n @item b"}, {"sha": "c62db2c466c04ab2deca49f57d1b27cdf0117aa7", "filename": "gcc/testsuite/gcc.dg/lower-subreg-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do compile { target { ! { mips64 || { aarch64*-*-* arm*-*-* i?86-*-* ia64-*-* pru-*-* sparc*-*-* tilegx-*-* x86_64-*-* } } } } } */\n+/* { dg-do compile { target { ! { mips64 || { aarch64*-*-* arm*-*-* i?86-*-* ia64-*-* pru-*-* sparc*-*-* x86_64-*-* } } } } } */\n /* { dg-options \"-O -fdump-rtl-subreg1\" } */\n /* { dg-require-effective-target ilp32 } */\n "}, {"sha": "64da5d1c58e1028f62537122321b5245413ccc2f", "filename": "gcc/testsuite/gcc.misc-tests/linkage.exp", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Ftestsuite%2Fgcc.misc-tests%2Flinkage.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/gcc%2Ftestsuite%2Fgcc.misc-tests%2Flinkage.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Flinkage.exp?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -98,13 +98,6 @@ if { [isnative] && ![is_remote host] } then {\n             } elseif [ string match \"*ppc\" $file_string ] {\n                 set native_cflags \"-m32\"\n             }\n-        } elseif [istarget \"tilegx-*-linux*\"] {\n-\t    set file_string [exec file \"linkage-x.o\"]\n-\t    if [ string match \"*64-bit*\" $file_string ] {\n-\t\tset native_cflags \"-m64\"\n-\t    } elseif [ string match \"*32-bit*\" $file_string ] {\n-\t\tset native_cflags \"-m32\"\n-\t    }\n         } elseif [istarget \"*86*-*-darwin*\"] {\n \t   set file_string [exec file \"linkage-x.o\"]\n \t   if [ string match \"*64*\" $file_string ] {"}, {"sha": "b2a0a8e1aa9f50e10ecbda7cf285ad708c5c3bc0", "filename": "libgcc/config.host", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc259b522c0f8b7bbca8e7adcd3da63330094a34/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc259b522c0f8b7bbca8e7adcd3da63330094a34/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=fc259b522c0f8b7bbca8e7adcd3da63330094a34", "patch": "@@ -212,12 +212,6 @@ s390*-*-*)\n sh[123456789lbe]*-*-*)\n \tcpu_type=sh\n \t;;\n-tilegx*-*-*)\n-\tcpu_type=tilegx\n-\t;;\n-tilepro*-*-*)\n-\tcpu_type=tilepro\n-\t;;\n v850*-*-*)\n \tcpu_type=v850\n \t;;\n@@ -1487,17 +1481,6 @@ tic6x-*-elf)\n \textra_parts=\"$extra_parts crtbeginS.o crtendS.o crti.o crtn.o\"\n \tunwind_header=config/c6x/unwind-c6x.h\n \t;;\n-tilegx*-*-linux*)\n-\tif test \"${host_address}\" = 64; then\n-\t\ttmake_file=\"${tmake_file} tilegx/t-softfp\"\n-\tfi\n-\ttmake_file=\"${tmake_file} tilegx/t-crtstuff t-softfp-sfdf t-softfp tilegx/t-tilegx\"\n-\tmd_unwind_header=tilepro/linux-unwind.h\n-        ;;\n-tilepro*-*-linux*)\n-\ttmake_file=\"${tmake_file} tilepro/t-crtstuff t-softfp-sfdf t-softfp tilepro/t-tilepro t-slibgcc-libgcc\"\n-\tmd_unwind_header=tilepro/linux-unwind.h\n-        ;;\n v850*-*-*)\n \ttmake_file=\"${tmake_file} v850/t-v850 t-fdpbit\"\n \t;;"}, {"sha": "1ce84e10943e35fdf0cab82751e1cf57674403ed", "filename": "libgcc/config/tilegx/sfp-machine.h", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,5 +0,0 @@\n-#ifdef __tilegx32__\n-#include \"config/tilegx/sfp-machine32.h\"\n-#else\n-#include \"config/tilegx/sfp-machine64.h\"\n-#endif"}, {"sha": "9fc281cc8ed91720c635c3f907f86f32aa19f9d3", "filename": "libgcc/config/tilegx/sfp-machine32.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine32.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,68 +0,0 @@\n-#define _FP_W_TYPE_SIZE\t\t32\n-#define _FP_W_TYPE\t\tunsigned long\n-#define _FP_WS_TYPE\t\tsigned long\n-#define _FP_I_TYPE\t\tlong\n-\n-typedef int TItype __attribute__ ((mode (TI)));\n-typedef unsigned int UTItype __attribute__ ((mode (TI)));\n-\n-#define TI_BITS (__CHAR_BIT__ * (int)sizeof(TItype))\n-\n-/* The type of the result of a floating point comparison.  This must\n-   match `__libgcc_cmp_return__' in GCC for the target.  */\n-typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n-#define CMPtype __gcc_CMPtype\n-\n-#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n-  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n-#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n-  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n-#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n-  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n-\n-#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n-#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n-#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n-\n-#define _FP_NANFRAC_S\t\t_FP_QNANBIT_S\n-#define _FP_NANFRAC_D\t\t_FP_QNANBIT_D, 0\n-#define _FP_NANFRAC_Q\t\t_FP_QNANBIT_Q, 0, 0, 0\n-#define _FP_NANSIGN_S\t\t1\n-#define _FP_NANSIGN_D\t\t1\n-#define _FP_NANSIGN_Q\t\t1\n-\n-#define _FP_KEEPNANFRACP 1\n-#define _FP_QNANNEGATEDP 0\n-\n-#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n-\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tR##_s = Y##_s;\t\t\t\t\t\t\\\n-\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tR##_s = X##_s;\t\t\t\t\t\t\\\n-\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define _FP_TININESS_AFTER_ROUNDING 0\n-\n-#define\t__LITTLE_ENDIAN\t1234\n-#define\t__BIG_ENDIAN\t4321\n-\n-#if defined __BIG_ENDIAN__\n-#define __BYTE_ORDER __BIG_ENDIAN\n-#else\n-#define __BYTE_ORDER __LITTLE_ENDIAN\n-#endif\n-\n-/* Define ALIASNAME as a strong alias for NAME.  */\n-# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n-# define _strong_alias(name, aliasname) \\\n-  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n-"}, {"sha": "5dbbe60c46b8014aae27fab465982ff9ad4470bc", "filename": "libgcc/config/tilegx/sfp-machine64.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine64.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,68 +0,0 @@\n-#define _FP_W_TYPE_SIZE\t\t64\n-#define _FP_W_TYPE\t\tunsigned long\n-#define _FP_WS_TYPE\t\tsigned long\n-#define _FP_I_TYPE\t\tlong\n-\n-typedef int TItype __attribute__ ((mode (TI)));\n-typedef unsigned int UTItype __attribute__ ((mode (TI)));\n-\n-#define TI_BITS (__CHAR_BIT__ * (int)sizeof(TItype))\n-\n-/* The type of the result of a floating point comparison.  This must\n-   match `__libgcc_cmp_return__' in GCC for the target.  */\n-typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n-#define CMPtype __gcc_CMPtype\n-\n-#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n-  _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S,R,X,Y)\n-#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n-  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n-#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n-  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n-\n-#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_imm(S,R,X,Y,_FP_DIV_HELP_imm)\n-#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_1_udiv_norm(D,R,X,Y)\n-#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_2_udiv(Q,R,X,Y)\n-\n-#define _FP_NANFRAC_S\t\t_FP_QNANBIT_S\n-#define _FP_NANFRAC_D\t\t_FP_QNANBIT_D\n-#define _FP_NANFRAC_Q\t\t_FP_QNANBIT_Q, 0\n-#define _FP_NANSIGN_S\t\t1\n-#define _FP_NANSIGN_D\t\t1\n-#define _FP_NANSIGN_Q\t\t1\n-\n-#define _FP_KEEPNANFRACP 1\n-#define _FP_QNANNEGATEDP 0\n-\n-#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n-\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tR##_s = Y##_s;\t\t\t\t\t\t\\\n-\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tR##_s = X##_s;\t\t\t\t\t\t\\\n-\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define _FP_TININESS_AFTER_ROUNDING 0\n-\n-#define\t__LITTLE_ENDIAN\t1234\n-#define\t__BIG_ENDIAN\t4321\n-\n-#if defined __BIG_ENDIAN__\n-#define __BYTE_ORDER __BIG_ENDIAN\n-#else\n-#define __BYTE_ORDER __LITTLE_ENDIAN\n-#endif\n-\n-/* Define ALIASNAME as a strong alias for NAME.  */\n-# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n-# define _strong_alias(name, aliasname) \\\n-  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n-"}, {"sha": "870318ceb8e9d6452ba7e46e0df8e4ee670ae363", "filename": "libgcc/config/tilegx/t-crtstuff", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Ft-crtstuff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Ft-crtstuff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Ft-crtstuff?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,8 +0,0 @@\n-# crtend*.o cannot be compiled without -fno-asynchronous-unwind-tables,\n-# because then __FRAME_END__ might not be the last thing in .eh_frame\n-# section.\n-CRTSTUFF_T_CFLAGS += -fno-asynchronous-unwind-tables\n-CRTSTUFF_T_CFLAGS_S += -fno-asynchronous-unwind-tables\n-\n-# Compile crtbeginS.o and crtendS.o with -mcmodel=large\n-CRTSTUFF_T_CFLAGS_S += -mcmodel=large"}, {"sha": "a1e3513e2884ffa856cc2d41670f150a27e87553", "filename": "libgcc/config/tilegx/t-softfp", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Ft-softfp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Ft-softfp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Ft-softfp?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1 +0,0 @@\n-softfp_int_modes += ti"}, {"sha": "2fb64454c3686c9322ab7f60f23dd27b95289485", "filename": "libgcc/config/tilegx/t-tilegx", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Ft-tilegx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilegx%2Ft-tilegx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Ft-tilegx?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,26 +0,0 @@\n-LIB2ADD += \\\n-  $(srcdir)/config/tilepro/atomic.c\n-\n-SOFTDIVIDE_FUNCS := \\\n-  _tile_udivsi3 \\\n-  _tile_divsi3 \\\n-  _tile_udivdi3 \\\n-  _tile_divdi3 \\\n-  _tile_umodsi3 \\\n-  _tile_modsi3 \\\n-  _tile_umoddi3 \\\n-  _tile_moddi3\n-\n-softdivide-o = $(patsubst %,%$(objext),$(SOFTDIVIDE_FUNCS))\n-$(softdivide-o): %$(objext): $(srcdir)/config/tilepro/softdivide.c\n-\t$(gcc_compile) -ffunction-sections -DMAYBE_STATIC= -DL$* -c $< \\\n-\t  $(vis_hide)\n-libgcc-objects += $(softdivide-o)\n-\n-ifeq ($(enable_shared),yes)\n-softdivide-s-o = $(patsubst %,%_s$(objext),$(SOFTDIVIDE_FUNCS))\n-$(softdivide-s-o): %_s$(objext): $(srcdir)/config/tilepro/softdivide.c\n-\t$(gcc_s_compile) -ffunction-sections -DMAYBE_STATIC= -DL$* -c $<\n-libgcc-s-objects += $(softdivide-s-o)\n-libgcc-eh-objects += _tile_divdi3.o _tile_umoddi3.o\n-endif"}, {"sha": "5de2b7c28a0ab7ebe13248fc00a8d372ff6e1ebe", "filename": "libgcc/config/tilepro/atomic.c", "status": "removed", "additions": 0, "deletions": 397, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fatomic.c?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,397 +0,0 @@\n-/* TILE atomics.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by the\n-   Free Software Foundation; either version 3, or (at your option) any\n-   later version.\n-\n-   This file is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"tconfig.h\"\n-#include \"coretypes.h\"\n-#include \"atomic.h\"\n-\n-#define bool unsigned char\n-\n-/* This code should be inlined by the compiler, but for now support\n-   it as out-of-line methods in libgcc.  */\n-\n-static inline void\n-pre_atomic_barrier (int model)\n-{\n-  switch (model)\n-    {\n-    case __ATOMIC_RELEASE:\n-    case __ATOMIC_ACQ_REL:\n-    case __ATOMIC_SEQ_CST:\n-      __atomic_thread_fence (model);\n-      break;\n-    default:\n-      break;\n-    }\n-  return;\n-}\n-\n-static inline void\n-post_atomic_barrier (int model)\n-{\n-  switch (model)\n-    {\n-    case __ATOMIC_ACQUIRE:\n-    case __ATOMIC_ACQ_REL:\n-    case __ATOMIC_SEQ_CST:\n-      __atomic_thread_fence (model);\n-      break;\n-    default:\n-      break;\n-    }\n-  return;\n-}\n-\n-#define __unused __attribute__((unused))\n-\n-#define __fetch_and_do(proto, type, size, opname, top, bottom)\t\\\n-proto\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  top;\t\t\t\t\t\t\t\t\\\n-  type rv = arch_atomic_##opname(p, i);\t\t\t\t\\\n-  bottom;\t\t\t\t\t\t\t\\\n-  return rv;\t\t\t\t\t\t\t\\\n-}\n-\n-#define __atomic_fetch_and_do(type, size, opname)\t\t\t\\\n-  __fetch_and_do(type __atomic_fetch_##opname##_##size(type* p, type i, int model), \\\n-\t\t type, size, opname,\t\t\t\t\t\\\n-\t\t pre_atomic_barrier(model),\t\t\t\t\\\n-\t\t post_atomic_barrier(model))\t\t\t\t\\\n-\n-__atomic_fetch_and_do (int, 4, add)\n-__atomic_fetch_and_do (int, 4, sub)\n-__atomic_fetch_and_do (int, 4, or)\n-__atomic_fetch_and_do (int, 4, and)\n-__atomic_fetch_and_do (int, 4, xor)\n-__atomic_fetch_and_do (int, 4, nand)\n-__atomic_fetch_and_do (long long, 8, add)\n-__atomic_fetch_and_do (long long, 8, sub)\n-__atomic_fetch_and_do (long long, 8, or)\n-__atomic_fetch_and_do (long long, 8, and)\n-__atomic_fetch_and_do (long long, 8, xor)\n-__atomic_fetch_and_do (long long, 8, nand)\n-\n-#define __sync_fetch_and_do(type, size, opname)\t\t\t\t\\\n-  __fetch_and_do(type __sync_fetch_and_##opname##_##size(type* p, type i), \\\n-\t\t type, size, opname,\t\t\t\t\t\\\n-\t\t arch_atomic_write_barrier(),\t\t\t\t\\\n-\t\t arch_atomic_read_barrier())\n-\n-__sync_fetch_and_do (int, 4, add)\n-__sync_fetch_and_do (int, 4, sub)\n-__sync_fetch_and_do (int, 4, or)\n-__sync_fetch_and_do (int, 4, and)\n-__sync_fetch_and_do (int, 4, xor)\n-__sync_fetch_and_do (int, 4, nand)\n-__sync_fetch_and_do (long long, 8, add)\n-__sync_fetch_and_do (long long, 8, sub)\n-__sync_fetch_and_do (long long, 8, or)\n-__sync_fetch_and_do (long long, 8, and)\n-__sync_fetch_and_do (long long, 8, xor)\n-__sync_fetch_and_do (long long, 8, nand)\n-\n-#define __do_and_fetch(proto, type, size, opname, op, op2, top, bottom)\t\\\n-proto\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  top;\t\t\t\t\t\t\t\t\t\\\n-  type rv = op2 (arch_atomic_##opname(p, i) op i);\t\t\t\\\n-  bottom;\t\t\t\t\t\t\t\t\\\n-  return rv;\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define __atomic_do_and_fetch(type, size, opname, op, op2)\t\t\\\n-  __do_and_fetch(type __atomic_##opname##_fetch_##size(type* p, type i, int model), \\\n-\t\t type, size, opname, op, op2,\t\t\t\t\\\n-\t\t pre_atomic_barrier(model),\t\t\t\t\\\n-\t\t post_atomic_barrier(model))\t\t\t\t\\\n-\n-__atomic_do_and_fetch (int, 4, add, +, )\n-__atomic_do_and_fetch (int, 4, sub, -, )\n-__atomic_do_and_fetch (int, 4, or, |, )\n-__atomic_do_and_fetch (int, 4, and, &, )\n-__atomic_do_and_fetch (int, 4, xor, |, )\n-__atomic_do_and_fetch (int, 4, nand, &, ~)\n-__atomic_do_and_fetch (long long, 8, add, +, )\n-__atomic_do_and_fetch (long long, 8, sub, -, )\n-__atomic_do_and_fetch (long long, 8, or, |, )\n-__atomic_do_and_fetch (long long, 8, and, &, )\n-__atomic_do_and_fetch (long long, 8, xor, |, )\n-__atomic_do_and_fetch (long long, 8, nand, &, ~)\n-\n-#define __sync_do_and_fetch(type, size, opname, op, op2)\t\t\\\n-  __do_and_fetch(type __sync_##opname##_and_fetch_##size(type* p, type i), \\\n-\t\t type, size, opname, op, op2,\t\t\t\t\\\n-\t\t arch_atomic_write_barrier(),\t\t\t\t\\\n-\t\t arch_atomic_read_barrier())\t\t\t\t\\\n-\n-__sync_do_and_fetch (int, 4, add, +, )\n-__sync_do_and_fetch (int, 4, sub, -, )\n-__sync_do_and_fetch (int, 4, or, |, )\n-__sync_do_and_fetch (int, 4, and, &, )\n-__sync_do_and_fetch (int, 4, xor, |, )\n-__sync_do_and_fetch (int, 4, nand, &, ~)\n-__sync_do_and_fetch (long long, 8, add, +, )\n-__sync_do_and_fetch (long long, 8, sub, -, )\n-__sync_do_and_fetch (long long, 8, or, |, )\n-__sync_do_and_fetch (long long, 8, and, &, )\n-__sync_do_and_fetch (long long, 8, xor, |, )\n-__sync_do_and_fetch (long long, 8, nand, &, ~)\n-\n-#define __atomic_exchange_methods(type, size)\t\t\t\t\\\n-bool\t\t\t\t\t\t\t\t\t\\\n-__atomic_compare_exchange_##size(volatile type* ptr, type* oldvalp,\t\\\n-\t\t\t\t type newval, bool weak __unused,\t\\\n-\t\t\t\t int models, int modelf __unused)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  type oldval = *oldvalp;\t\t\t\t\t\t\\\n-  pre_atomic_barrier(models);\t\t\t\t\t\t\\\n-  type retval = arch_atomic_val_compare_and_exchange(ptr, oldval, newval); \\\n-  post_atomic_barrier(models);\t\t\t\t\t\t\\\n-  bool success = (retval == oldval);\t\t\t\t\t\\\n-  *oldvalp = retval;\t\t\t\t\t\t\t\\\n-  return success;\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-type\t\t\t\t\t\t\t\t\t\\\n-__atomic_exchange_##size(volatile type* ptr, type val, int model)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  pre_atomic_barrier(model);\t\t\t\t\t\t\\\n-  type retval = arch_atomic_exchange(ptr, val);\t\t\t\t\\\n-  post_atomic_barrier(model);\t\t\t\t\t\t\\\n-  return retval;\t\t\t\t\t\t\t\\\n-}\n-\n-__atomic_exchange_methods (int, 4)\n-__atomic_exchange_methods (long long, 8)\n-\n-#define __sync_exchange_methods(type, size)\t\t\t\t\\\n-type\t\t\t\t\t\t\t\t\t\\\n-__sync_val_compare_and_swap_##size(type* ptr, type oldval, type newval)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  arch_atomic_write_barrier();\t\t\t\t\t\t\\\n-  type retval = arch_atomic_val_compare_and_exchange(ptr, oldval, newval); \\\n-  arch_atomic_read_barrier();\t\t\t\t\t\t\\\n-  return retval;\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-bool\t\t\t\t\t\t\t\t\t\\\n-__sync_bool_compare_and_swap_##size(type* ptr, type oldval, type newval) \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  arch_atomic_write_barrier();\t\t\t\t\t\t\\\n-  bool retval = arch_atomic_bool_compare_and_exchange(ptr, oldval, newval); \\\n-  arch_atomic_read_barrier();\t\t\t\t\t\t\\\n-  return retval;\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-type\t\t\t\t\t\t\t\t\t\\\n-__sync_lock_test_and_set_##size(type* ptr, type val)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  type retval = arch_atomic_exchange(ptr, val);\t\t\t\t\\\n-  arch_atomic_acquire_barrier_value(retval);\t\t\t\t\\\n-  return retval;\t\t\t\t\t\t\t\\\n-}\n-\n-__sync_exchange_methods (int, 4)\n-__sync_exchange_methods (long long, 8)\n-\n-#ifdef __LITTLE_ENDIAN__\n-#define BIT_OFFSET(n, type) ((n) * 8)\n-#else\n-#define BIT_OFFSET(n, type) ((4 - sizeof(type) - (n)) * 8)\n-#endif\n-\n-/* Subword methods require the same approach for both TILEPro and\n-   TILE-Gx.  We load the background data for the word, insert the\n-   desired subword piece, then compare-and-exchange it into place.  */\n-#define u8 unsigned char\n-#define u16 unsigned short\n-\n-#define __subword_cmpxchg_body(type, size, ptr, guess, val)\t\t\\\n-  ({\t\t\t\t\t\t\t\t\t\\\n-    unsigned int *p = (unsigned int *)((unsigned long)ptr & ~3UL);\t\\\n-    const int shift = BIT_OFFSET((unsigned long)ptr & 3UL, type);\t\\\n-    const unsigned int valmask = (1 << (sizeof(type) * 8)) - 1;\t\t\\\n-    const unsigned int bgmask = ~(valmask << shift);\t\t\t\\\n-    unsigned int oldword = *p;\t\t\t\t\t\t\\\n-    type oldval = (oldword >> shift) & valmask;\t\t\t\t\\\n-    if (__builtin_expect((oldval == guess), 1)) {\t\t\t\\\n-      unsigned int word = (oldword & bgmask) | ((val & valmask) << shift); \\\n-      oldword = arch_atomic_val_compare_and_exchange(p, oldword, word);\t\\\n-      oldval = (oldword >> shift) & valmask;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    oldval;\t\t\t\t\t\t\t\t\\\n-  })\t\t\t\t\t\t\t\t\t\\\n-\n-#define __atomic_subword_cmpxchg(type, size)\t\t\t\t\\\n-  \t\t\t\t\t\t\t\t\t\\\n-bool\t\t\t\t\t\t\t\t\t\\\n-__atomic_compare_exchange_##size(volatile type* ptr, type* guess_ptr,\t\\\n-\t\t\t\t type val, bool weak __unused, int models, \\\n-\t\t\t\t int modelf __unused)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  pre_atomic_barrier(models);\t\t\t\t\t\t\\\n-  type guess = *guess_ptr;\t\t\t\t\t\t\\\n-  type oldval = __subword_cmpxchg_body(type, size, ptr, guess, val);\t\\\n-  post_atomic_barrier(models);\t\t\t\t\t\t\\\n-  bool success = (oldval == guess);\t\t\t\t\t\\\n-  *guess_ptr = oldval;\t\t\t\t\t\t\t\\\n-  return success;\t\t\t\t\t\t\t\\\n-}\n-\n-__atomic_subword_cmpxchg (u8, 1)\n-__atomic_subword_cmpxchg (u16, 2)\n-\n-#define __sync_subword_cmpxchg(type, size)\t\t\t\t\\\n-  \t\t\t\t\t\t\t\t\t\\\n-type\t\t\t\t\t\t\t\t\t\\\n-__sync_val_compare_and_swap_##size(type* ptr, type guess, type val)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  arch_atomic_write_barrier();\t\t\t\t\t\t\\\n-  type oldval = __subword_cmpxchg_body(type, size, ptr, guess, val);\t\\\n-  arch_atomic_read_barrier();\t\t\t\t\t\t\\\n-  return oldval;\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-bool\t\t\t\t\t\t\t\t\t\\\n-__sync_bool_compare_and_swap_##size(type* ptr, type guess, type val)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  type oldval = __sync_val_compare_and_swap_##size(ptr, guess, val);\t\\\n-  return oldval == guess;\t\t\t\t\t\t\\\n-}\n-\n-__sync_subword_cmpxchg (u8, 1)\n-__sync_subword_cmpxchg (u16, 2)\n-\n-/* For the atomic-update subword methods, we use the same approach as\n-   above, but we retry until we succeed if the compare-and-exchange\n-   fails.  */\n-#define __subword(type, proto, top, expr, bottom)\t\t\t\\\n-proto\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  top\t\t\t\t\t\t\t\t\t\\\n-  unsigned int *p = (unsigned int *)((unsigned long)ptr & ~3UL);\t\\\n-  const int shift = BIT_OFFSET((unsigned long)ptr & 3UL, type);\t\t\\\n-  const unsigned int valmask = (1 << (sizeof(type) * 8)) - 1;\t\t\\\n-  const unsigned int bgmask = ~(valmask << shift);\t\t\t\\\n-  unsigned int oldword, xword = *p;\t\t\t\t\t\\\n-  type val, oldval;\t\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    oldword = xword;\t\t\t\t\t\t\t\\\n-    oldval = (oldword >> shift) & valmask;\t\t\t\t\\\n-    val = expr;\t\t\t\t\t\t\t\t\\\n-    unsigned int word = (oldword & bgmask) | ((val & valmask) << shift); \\\n-    xword = arch_atomic_val_compare_and_exchange(p, oldword, word);\t\\\n-  } while (__builtin_expect(xword != oldword, 0));\t\t\t\\\n-  bottom\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define __atomic_subword_fetch(type, funcname, expr, retval)\t\t\\\n-  __subword(type,\t\t\t\t\t\t\t\\\n-\t    type __atomic_ ## funcname(volatile type *ptr, type i, int model), \\\n-\t    pre_atomic_barrier(model);,\t\t\t\t\t\\\n-\t    expr,\t\t\t\t\t\t\t\\\n-\t    post_atomic_barrier(model); return retval;)\n-\n-__atomic_subword_fetch (u8, fetch_add_1, oldval + i, oldval)\n-__atomic_subword_fetch (u8, fetch_sub_1, oldval - i, oldval)\n-__atomic_subword_fetch (u8, fetch_or_1, oldval | i, oldval)\n-__atomic_subword_fetch (u8, fetch_and_1, oldval & i, oldval)\n-__atomic_subword_fetch (u8, fetch_xor_1, oldval ^ i, oldval)\n-__atomic_subword_fetch (u8, fetch_nand_1, ~(oldval & i), oldval)\n-\n-__atomic_subword_fetch (u16, fetch_add_2, oldval + i, oldval)\n-__atomic_subword_fetch (u16, fetch_sub_2, oldval - i, oldval)\n-__atomic_subword_fetch (u16, fetch_or_2, oldval | i, oldval)\n-__atomic_subword_fetch (u16, fetch_and_2, oldval & i, oldval)\n-__atomic_subword_fetch (u16, fetch_xor_2, oldval ^ i, oldval)\n-__atomic_subword_fetch (u16, fetch_nand_2, ~(oldval & i), oldval)\n-\n-__atomic_subword_fetch (u8, add_fetch_1, oldval + i, val)\n-__atomic_subword_fetch (u8, sub_fetch_1, oldval - i, val)\n-__atomic_subword_fetch (u8, or_fetch_1, oldval | i, val)\n-__atomic_subword_fetch (u8, and_fetch_1, oldval & i, val)\n-__atomic_subword_fetch (u8, xor_fetch_1, oldval ^ i, val)\n-__atomic_subword_fetch (u8, nand_fetch_1, ~(oldval & i), val)\n-\n-__atomic_subword_fetch (u16, add_fetch_2, oldval + i, val)\n-__atomic_subword_fetch (u16, sub_fetch_2, oldval - i, val)\n-__atomic_subword_fetch (u16, or_fetch_2, oldval | i, val)\n-__atomic_subword_fetch (u16, and_fetch_2, oldval & i, val)\n-__atomic_subword_fetch (u16, xor_fetch_2, oldval ^ i, val)\n-__atomic_subword_fetch (u16, nand_fetch_2, ~(oldval & i), val)\n-\n-#define __sync_subword_fetch(type, funcname, expr, retval)\t\\\n-  __subword(type,\t\t\t\t\t\t\\\n-\t    type __sync_ ## funcname(type *ptr, type i),\t\\\n-\t    arch_atomic_read_barrier();,\t\t\t\\\n-\t    expr,\t\t\t\t\t\t\\\n-\t    arch_atomic_write_barrier(); return retval;)\n-\n-__sync_subword_fetch (u8, fetch_and_add_1, oldval + i, oldval)\n-__sync_subword_fetch (u8, fetch_and_sub_1, oldval - i, oldval)\n-__sync_subword_fetch (u8, fetch_and_or_1, oldval | i, oldval)\n-__sync_subword_fetch (u8, fetch_and_and_1, oldval & i, oldval)\n-__sync_subword_fetch (u8, fetch_and_xor_1, oldval ^ i, oldval)\n-__sync_subword_fetch (u8, fetch_and_nand_1, ~(oldval & i), oldval)\n-\n-__sync_subword_fetch (u16, fetch_and_add_2, oldval + i, oldval)\n-__sync_subword_fetch (u16, fetch_and_sub_2, oldval - i, oldval)\n-__sync_subword_fetch (u16, fetch_and_or_2, oldval | i, oldval)\n-__sync_subword_fetch (u16, fetch_and_and_2, oldval & i, oldval)\n-__sync_subword_fetch (u16, fetch_and_xor_2, oldval ^ i, oldval)\n-__sync_subword_fetch (u16, fetch_and_nand_2, ~(oldval & i), oldval)\n-\n-__sync_subword_fetch (u8, add_and_fetch_1, oldval + i, val)\n-__sync_subword_fetch (u8, sub_and_fetch_1, oldval - i, val)\n-__sync_subword_fetch (u8, or_and_fetch_1, oldval | i, val)\n-__sync_subword_fetch (u8, and_and_fetch_1, oldval & i, val)\n-__sync_subword_fetch (u8, xor_and_fetch_1, oldval ^ i, val)\n-__sync_subword_fetch (u8, nand_and_fetch_1, ~(oldval & i), val)\n-\n-__sync_subword_fetch (u16, add_and_fetch_2, oldval + i, val)\n-__sync_subword_fetch (u16, sub_and_fetch_2, oldval - i, val)\n-__sync_subword_fetch (u16, or_and_fetch_2, oldval | i, val)\n-__sync_subword_fetch (u16, and_and_fetch_2, oldval & i, val)\n-__sync_subword_fetch (u16, xor_and_fetch_2, oldval ^ i, val)\n-__sync_subword_fetch (u16, nand_and_fetch_2, ~(oldval & i), val)\n-\n-#define __atomic_subword_lock(type, size)\t\t\t\t\\\n-  __subword(type,\t\t\t\t\t\t\t\\\n-\t    type __atomic_exchange_##size(volatile type* ptr, type nval, int model), \\\n-\t    pre_atomic_barrier(model);,\t\t\t\t\t\\\n-\t    nval,\t\t\t\t\t\t\t\\\n-\t    post_atomic_barrier(model); return oldval;)\n-\n-__atomic_subword_lock (u8, 1)\n-__atomic_subword_lock (u16, 2)\n-\n-#define __sync_subword_lock(type, size)\t\t\t\t\t\\\n-  __subword(type,\t\t\t\t\t\t\t\\\n-\t    type __sync_lock_test_and_set_##size(type* ptr, type nval), \\\n-\t    ,\t\t\t\t\t\t\t\t\\\n-\t    nval,\t\t\t\t\t\t\t\\\n-\t    arch_atomic_acquire_barrier_value(oldval); return oldval;)\n-\n-__sync_subword_lock (u8, 1)\n-__sync_subword_lock (u16, 2)"}, {"sha": "34547bbb6e0dc7a46c03b2dc858911ce70c53e63", "filename": "libgcc/config/tilepro/atomic.h", "status": "removed", "additions": 0, "deletions": 437, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Fatomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Fatomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fatomic.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,437 +0,0 @@\n-/* Macros for atomic functionality for tile.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by the\n-   Free Software Foundation; either version 3, or (at your option) any\n-   later version.\n-\n-   This file is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-\n-/* Provides macros for common atomic functionality.  */\n-\n-#ifndef _ATOMIC_H_\n-#define _ATOMIC_H_\n-\n-#ifdef __tilegx__\n-/* Atomic instruction macros\n-\n-   The macros provided by atomic.h simplify access to the TILE-Gx\n-   architecture's atomic instructions.  The architecture provides a\n-   variety of atomic instructions, including \"exchange\", \"compare and\n-   exchange\", \"fetch and ADD\", \"fetch and AND\", \"fetch and OR\", and\n-   \"fetch and ADD if greater than or equal to zero\".\n-\n-   No barrier or fence semantics are implied by any of the atomic\n-   instructions for manipulating memory; you must specify the barriers\n-   that you wish explicitly, using the provided macros.\n-\n-   Any integral 32- or 64-bit value can be used as the argument\n-   to these macros, such as \"int\", \"long long\", \"unsigned long\", etc.\n-   The pointers must be aligned to 4 or 8 bytes for 32- or 64-bit data.\n-   The \"exchange\" and \"compare and exchange\" macros may also take\n-   pointer values.  We use the pseudo-type \"VAL\" in the documentation\n-   to indicate the use of an appropriate type.  */\n-#else\n-/* Atomic instruction macros\n-\n-   The macros provided by atomic.h simplify access to the Tile\n-   architecture's atomic instructions.  Since the architecture\n-   supports test-and-set as its only in-silicon atomic operation, many\n-   of the operations provided by this header are implemented as\n-   fast-path calls to Linux emulation routines.\n-\n-   Using the kernel for atomic operations allows userspace to take\n-   advantage of the kernel's existing atomic-integer support (managed\n-   by a distributed array of locks).  The kernel provides proper\n-   ordering among simultaneous atomic operations on different cores,\n-   and guarantees a process cannot be context-switched part way\n-   through an atomic operation.  By virtue of sharing the kernel\n-   atomic implementation, the userspace atomic operations\n-   are compatible with the atomic methods provided by the kernel's\n-   futex() syscall API.  Note that these operations never cause Linux\n-   kernel scheduling, and are in fact invisible to the kernel; they\n-   simply act as regular function calls but with an elevated privilege\n-   level.  Note that the kernel's distributed lock array is hashed by\n-   using only VA bits from the atomic value's address (to avoid the\n-   performance hit of page table locking and multiple page-table\n-   lookups to get the PA) and only the VA bits that are below page\n-   granularity (to properly lock simultaneous accesses to the same\n-   page mapped at different VAs).  As a result, simultaneous atomic\n-   operations on values whose addresses are at the same offset on a\n-   page will contend in the kernel for the same lock array element.\n-\n-   No barrier or fence semantics are implied by any of the atomic\n-   instructions for manipulating memory; you must specify the barriers\n-   that you wish explicitly, using the provided macros.\n-\n-   Any integral 32- or 64-bit value can be used as the argument\n-   to these macros, such as \"int\", \"long long\", \"unsigned long\", etc.\n-   The pointers must be aligned to 4 or 8 bytes for 32- or 64-bit data.\n-   The \"exchange\" and \"compare and exchange\" macros may also take\n-   pointer values.  We use the pseudo-type \"VAL\" in the documentation\n-   to indicate the use of an appropriate type.\n-\n-   The 32-bit routines are implemented using a single kernel fast\n-   syscall, as is the 64-bit compare-and-exchange.  The other 64-bit\n-   routines are implemented by looping over the 64-bit\n-   compare-and-exchange routine, so may be potentially less efficient.  */\n-#endif\n-\n-#ifdef __tilegx__\n-#define SPR_CMPEXCH_VALUE 0x2780\n-#else\n-#define __NR_FAST_cmpxchg\t-1\n-#define __NR_FAST_atomic_update\t-2\n-#define __NR_FAST_cmpxchg64\t-3\n-#endif\n-\n-\n-/* 32-bit integer compare-and-exchange.  */\n-static __inline __attribute__ ((always_inline))\n-     int arch_atomic_val_compare_and_exchange_4 (volatile int *mem,\n-\t\t\t\t\t\t int oldval, int newval)\n-{\n-#ifdef __tilegx__\n-  __insn_mtspr (SPR_CMPEXCH_VALUE, oldval);\n-  return __insn_cmpexch4 (mem, newval);\n-#else\n-  int result;\n-  __asm__ __volatile__ (\"swint1\":\"=R00\" (result),\n-\t\t\t\"=m\" (*mem):\"R10\" (__NR_FAST_cmpxchg), \"R00\" (mem),\n-\t\t\t\"R01\" (oldval), \"R02\" (newval), \"m\" (*mem):\"r20\",\n-\t\t\t\"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\",\n-\t\t\t\"r28\", \"r29\", \"memory\");\n-  return result;\n-#endif\n-}\n-\n-/* 64-bit integer compare-and-exchange.  */\n-static __inline __attribute__ ((always_inline))\n-     long long arch_atomic_val_compare_and_exchange_8 (volatile long long\n-\t\t\t\t\t\t       *mem, long long oldval,\n-\t\t\t\t\t\t       long long newval)\n-{\n-#ifdef __tilegx__\n-  __insn_mtspr (SPR_CMPEXCH_VALUE, oldval);\n-  return __insn_cmpexch (mem, newval);\n-#else\n-  unsigned int result_lo, result_hi;\n-  unsigned int oldval_lo = oldval & 0xffffffffu, oldval_hi = oldval >> 32;\n-  unsigned int newval_lo = newval & 0xffffffffu, newval_hi = newval >> 32;\n-  __asm__ __volatile__ (\"swint1\":\"=R00\" (result_lo), \"=R01\" (result_hi),\n-\t\t\t\"=m\" (*mem):\"R10\" (__NR_FAST_cmpxchg64), \"R00\" (mem),\n-\t\t\t\"R02\" (oldval_lo), \"R03\" (oldval_hi),\n-\t\t\t\"R04\" (newval_lo), \"R05\" (newval_hi),\n-\t\t\t\"m\" (*mem):\"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\",\n-\t\t\t\"r26\", \"r27\", \"r28\", \"r29\", \"memory\");\n-  return ((long long) result_hi) << 32 | result_lo;\n-#endif\n-}\n-\n-/* This non-existent symbol is called for sizes other than \"4\" and \"8\",\n-   indicating a bug in the caller.  */\n-extern int __arch_atomic_error_bad_argument_size (void)\n-  __attribute__ ((warning (\"sizeof atomic argument not 4 or 8\")));\n-\n-\n-#define arch_atomic_val_compare_and_exchange(mem, o, n)                 \\\n-  __extension__ ({                                                      \\\n-    (__typeof(*(mem)))(__typeof(*(mem)-*(mem)))                         \\\n-      ((sizeof(*(mem)) == 8) ?                                          \\\n-       arch_atomic_val_compare_and_exchange_8(                          \\\n-         (volatile long long*)(mem), (__typeof((o)-(o)))(o),            \\\n-         (__typeof((n)-(n)))(n)) :                                      \\\n-       (sizeof(*(mem)) == 4) ?                                          \\\n-       arch_atomic_val_compare_and_exchange_4(                          \\\n-         (volatile int*)(mem), (__typeof((o)-(o)))(o),                  \\\n-         (__typeof((n)-(n)))(n)) :                                      \\\n-       __arch_atomic_error_bad_argument_size());                        \\\n-  })\n-\n-#define arch_atomic_bool_compare_and_exchange(mem, o, n)                \\\n-  __extension__ ({                                                      \\\n-    __typeof(o) __o = (o);                                              \\\n-    __builtin_expect(                                                   \\\n-      __o == arch_atomic_val_compare_and_exchange((mem), __o, (n)), 1); \\\n-  })\n-\n-\n-/* Loop with compare_and_exchange until we guess the correct value.\n-   Normally \"expr\" will be an expression using __old and __value.  */\n-#define __arch_atomic_update_cmpxchg(mem, value, expr)                  \\\n-  __extension__ ({                                                      \\\n-    __typeof(value) __value = (value);                                  \\\n-    __typeof(*(mem)) *__mem = (mem), __old = *__mem, __guess;           \\\n-    do {                                                                \\\n-      __guess = __old;                                                  \\\n-      __old = arch_atomic_val_compare_and_exchange(__mem, __old, (expr));    \\\n-    } while (__builtin_expect(__old != __guess, 0));                    \\\n-    __old;                                                              \\\n-  })\n-\n-#ifdef __tilegx__\n-\n-/* Generic atomic op with 8- or 4-byte variant.\n-   The _mask, _addend, and _expr arguments are ignored on tilegx.  */\n-#define __arch_atomic_update(mem, value, op, _mask, _addend, _expr)     \\\n-  __extension__ ({                                                      \\\n-    ((__typeof(*(mem)))                                                 \\\n-     ((sizeof(*(mem)) == 8) ? (__typeof(*(mem)-*(mem)))__insn_##op(     \\\n-        (volatile void *)(mem),                                         \\\n-        (long long)(__typeof((value)-(value)))(value)) :                \\\n-      (sizeof(*(mem)) == 4) ? (int)__insn_##op##4(                      \\\n-        (volatile void *)(mem),                                         \\\n-        (int)(__typeof((value)-(value)))(value)) :                      \\\n-      __arch_atomic_error_bad_argument_size()));                        \\\n-  })\n-\n-#else\n-\n-/* This uses TILEPro's fast syscall support to atomically compute:\n-\n-   int old = *ptr;\n-   *ptr = (old & mask) + addend;\n-   return old;\n-\n-   This primitive can be used for atomic exchange, add, or, and.\n-   Only 32-bit support is provided.  */\n-static __inline __attribute__ ((always_inline))\n-     int\n-     __arch_atomic_update_4 (volatile int *mem, int mask, int addend)\n-{\n-  int result;\n-  __asm__ __volatile__ (\"swint1\":\"=R00\" (result),\n-\t\t\t\"=m\" (*mem):\"R10\" (__NR_FAST_atomic_update),\n-\t\t\t\"R00\" (mem), \"R01\" (mask), \"R02\" (addend),\n-\t\t\t\"m\" (*mem):\"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\",\n-\t\t\t\"r26\", \"r27\", \"r28\", \"r29\", \"memory\");\n-  return result;\n-}\n-\n-/* Generic atomic op with 8- or 4-byte variant.\n-   The _op argument is ignored on tilepro.  */\n-#define __arch_atomic_update(mem, value, _op, mask, addend, expr)       \\\n-  __extension__ ({                                                      \\\n-    (__typeof(*(mem)))(__typeof(*(mem)-*(mem)))                         \\\n-      ((sizeof(*(mem)) == 8) ?                                          \\\n-       __arch_atomic_update_cmpxchg((mem), (value), (expr)) :           \\\n-       (sizeof(*(mem)) == 4) ?                                          \\\n-       __arch_atomic_update_4((volatile int*)(mem),                     \\\n-                              (__typeof((mask)-(mask)))(mask),          \\\n-                              (__typeof((addend)-(addend)))(addend)) :  \\\n-       __arch_atomic_error_bad_argument_size());                        \\\n-  })\n-\n-#endif /* __tilegx__ */\n-\n-\n-#define arch_atomic_exchange(mem, newvalue) \\\n-  __arch_atomic_update(mem, newvalue, exch, 0, newvalue, __value)\n-\n-#define arch_atomic_add(mem, value) \\\n-  __arch_atomic_update(mem, value, fetchadd, -1, value, __old + __value)\n-\n-#define arch_atomic_sub(mem, value) arch_atomic_add((mem), -(value))\n-\n-#define arch_atomic_increment(mem) arch_atomic_add((mem), 1)\n-\n-#define arch_atomic_decrement(mem) arch_atomic_add((mem), -1)\n-\n-#define arch_atomic_and(mem, mask) \\\n-  __arch_atomic_update(mem, mask, fetchand, mask, 0, __old & __value)\n-\n-#define arch_atomic_or(mem, mask) \\\n-  __arch_atomic_update(mem, mask, fetchor, ~mask, mask, __old | __value)\n-\n-#define arch_atomic_xor(mem, mask) \\\n-  __arch_atomic_update_cmpxchg(mem, mask, __old ^ __value)\n-\n-#define arch_atomic_nand(mem, mask) \\\n-  __arch_atomic_update_cmpxchg(mem, mask, ~(__old & __value))\n-\n-#define arch_atomic_bit_set(mem, bit)                                   \\\n-  __extension__ ({                                                      \\\n-    __typeof(*(mem)) __mask = (__typeof(*(mem)))1 << (bit);             \\\n-    __mask & arch_atomic_or((mem), __mask);                             \\\n-  })\n-\n-#define arch_atomic_bit_clear(mem, bit)                                 \\\n-  __extension__ ({                                                      \\\n-    __typeof(*(mem)) __mask = (__typeof(*(mem)))1 << (bit);             \\\n-    __mask & arch_atomic_and((mem), ~__mask);                           \\\n-  })\n-\n-#ifdef __tilegx__\n-/* Atomically store a new value to memory.\n-   Note that you can freely use types of any size here, unlike the\n-   other atomic routines, which require 32- or 64-bit types.\n-   This accessor is provided for compatibility with TILEPro, which\n-   required an explicit atomic operation for stores that needed\n-   to be atomic with respect to other atomic methods in this header.  */\n-#define arch_atomic_write(mem, value) ((void) (*(mem) = (value)))\n-#else\n-#define arch_atomic_write(mem, value)                                   \\\n-  do {                                                                  \\\n-    __typeof(mem) __aw_mem = (mem);                                     \\\n-    __typeof(value) __aw_val = (value);                                 \\\n-    unsigned int *__aw_mem32, __aw_intval, __aw_val32, __aw_off, __aw_mask; \\\n-    __aw_intval = (__typeof((value) - (value)))__aw_val;                \\\n-    switch (sizeof(*__aw_mem)) {                                        \\\n-    case 8:                                                             \\\n-      __arch_atomic_update_cmpxchg(__aw_mem, __aw_val, __value);        \\\n-      break;                                                            \\\n-    case 4:                                                             \\\n-      __arch_atomic_update_4((int *)__aw_mem, 0, __aw_intval);          \\\n-      break;                                                            \\\n-    case 2:                                                             \\\n-      __aw_off = 8 * ((long)__aw_mem & 0x2);                            \\\n-      __aw_mask = 0xffffU << __aw_off;                                  \\\n-      __aw_mem32 = (unsigned int *)((long)__aw_mem & ~0x2);             \\\n-      __aw_val32 = (__aw_intval << __aw_off) & __aw_mask;               \\\n-      __arch_atomic_update_cmpxchg(__aw_mem32, __aw_val32,              \\\n-                                   (__old & ~__aw_mask) | __value);     \\\n-      break;                                                            \\\n-    case 1:                                                             \\\n-      __aw_off = 8 * ((long)__aw_mem & 0x3);                            \\\n-      __aw_mask = 0xffU << __aw_off;                                    \\\n-      __aw_mem32 = (unsigned int *)((long)__aw_mem & ~0x3);             \\\n-      __aw_val32 = (__aw_intval << __aw_off) & __aw_mask;               \\\n-      __arch_atomic_update_cmpxchg(__aw_mem32, __aw_val32,              \\\n-                                   (__old & ~__aw_mask) | __value);     \\\n-      break;                                                            \\\n-    }                                                                   \\\n-  } while (0)\n-#endif\n-\n-/* Compiler barrier.\n-\n-   This macro prevents loads or stores from being moved by the compiler\n-   across the macro.  Any loaded value that was loaded before this\n-   macro must then be reloaded by the compiler.  */\n-#define arch_atomic_compiler_barrier() __asm__ __volatile__(\"\" ::: \"memory\")\n-\n-/* Full memory barrier.\n-\n-   This macro has the semantics of arch_atomic_compiler_barrer(), but also\n-   ensures that previous stores are visible to other cores, and that\n-   all previous loaded values have been placed into their target\n-   register on this core.  */\n-#define arch_atomic_full_barrier() __insn_mf()\n-\n-/* Read memory barrier.\n-\n-   Ensure that all reads by this processor that occurred prior to the\n-   read memory barrier have completed, and that no reads that occur\n-   after the read memory barrier on this processor are initiated\n-   before the barrier.\n-\n-   On current TILE chips a read barrier is implemented as a full barrier,\n-   but this may not be true in later versions of the architecture.\n-\n-   See also arch_atomic_acquire_barrier() for the appropriate idiom to use\n-   to ensure no reads are lifted above an atomic lock instruction.  */\n-#define arch_atomic_read_barrier() arch_atomic_full_barrier()\n-\n-/* Write memory barrier.\n-\n-   Ensure that all writes by this processor that occurred prior to the\n-   write memory barrier have completed, and that no writes that occur\n-   after the write memory barrier on this processor are initiated\n-   before the barrier.\n-\n-   On current TILE chips a write barrier is implemented as a full barrier,\n-   but this may not be true in later versions of the architecture.\n-\n-   See also arch_atomic_release_barrier() for the appropriate idiom to use\n-   to ensure all writes are complete prior to an atomic unlock instruction.  */\n-#define arch_atomic_write_barrier() arch_atomic_full_barrier()\n-\n-/* Lock acquisition barrier.\n-\n-   Ensure that no load operations that follow this macro in the\n-   program can issue prior to the barrier.  Without such a barrier,\n-   the compiler can reorder them to issue earlier, or the hardware can\n-   issue them speculatively.  The latter is not currently done in the\n-   Tile microarchitecture, but using this operation improves\n-   portability to future implementations.\n-\n-   This operation is intended to be used as part of the \"acquire\"\n-   path for locking, that is, when entering a critical section.\n-   This should be done after the atomic operation that actually\n-   acquires the lock, and in conjunction with a \"control dependency\"\n-   that checks the atomic operation result to see if the lock was\n-   in fact acquired.  See the arch_atomic_read_barrier() macro\n-   for a heavier-weight barrier to use in certain unusual constructs,\n-   or arch_atomic_acquire_barrier_value() if no control dependency exists.  */\n-#define arch_atomic_acquire_barrier() arch_atomic_compiler_barrier()\n-\n-/* Lock release barrier.\n-\n-   Ensure that no store operations that precede this macro in the\n-   program complete subsequent to the barrier.  Without such a\n-   barrier, the compiler can reorder stores to issue later, or stores\n-   can be still outstanding in the memory network.\n-\n-   This operation is intended to be used as part of the \"release\" path\n-   for locking, that is, when leaving a critical section.  This should\n-   be done before the operation (such as a store of zero) that\n-   actually releases the lock.  */\n-#define arch_atomic_release_barrier() arch_atomic_write_barrier()\n-\n-/* Barrier until the read of a particular value is complete.\n-\n-   This is occasionally useful when constructing certain locking\n-   scenarios.  For example, you might write a routine that issues an\n-   atomic instruction to enter a critical section, then reads one or\n-   more values within the critical section without checking to see if\n-   the critical section was in fact acquired, and only later checks\n-   the atomic instruction result to see if the lock was acquired.  If\n-   so the routine could properly release the lock and know that the\n-   values that were read were valid.\n-\n-   In this scenario, it is required to wait for the result of the\n-   atomic instruction, even if the value itself is not checked.  This\n-   guarantees that if the atomic instruction succeeded in taking the lock,\n-   the lock was held before any reads in the critical section issued.  */\n-#define arch_atomic_acquire_barrier_value(val) \\\n-  __asm__ __volatile__(\"move %0, %0\" :: \"r\"(val))\n-\n-/* Access the given variable in memory exactly once.\n-\n-   In some contexts, an algorithm may need to force access to memory,\n-   since otherwise the compiler may think it can optimize away a\n-   memory load or store; for example, in a loop when polling memory to\n-   see if another cpu has updated it yet.  Generally this is only\n-   required for certain very carefully hand-tuned algorithms; using it\n-   unnecessarily may result in performance losses.\n-\n-   A related use of this macro is to ensure that the compiler does not\n-   rematerialize the value of \"x\" by reloading it from memory\n-   unexpectedly; the \"volatile\" marking will prevent the compiler from\n-   being able to rematerialize.  This is helpful if an algorithm needs\n-   to read a variable without locking, but needs it to have the same\n-   value if it ends up being used several times within the algorithm.\n-\n-   Note that multiple uses of this macro are guaranteed to be ordered,\n-   i.e. the compiler will not reorder stores or loads that are wrapped\n-   in arch_atomic_access_once().  */\n-#define arch_atomic_access_once(x) (*(volatile __typeof(x) *)&(x))\n-\n-\n-\n-#endif /* !_ATOMIC_H_ */"}, {"sha": "a6874e8e47a4ff0ce2bd646090814fb773e7c50e", "filename": "libgcc/config/tilepro/linux-unwind.h", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Flinux-unwind.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,99 +0,0 @@\n-/* DWARF2 EH unwinding support for TILEPro.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef inhibit_libc\n-\n-#include <arch/abi.h>\n-#include <signal.h>\n-#include <sys/ucontext.h>\n-#include <linux/unistd.h>\n-\n-/* Macro to define a copy of the kernel's __rt_sigreturn function\n-   (in arch/tile/kernel/entry.S).  If that function is changed,\n-   this one needs to be changed to match it.  */\n-#define _sigreturn_asm(REG, NR) asm(                    \\\n-    \".pushsection .text.__rt_sigreturn,\\\"a\\\"\\n\"         \\\n-    \".global __rt_sigreturn\\n\"                          \\\n-    \".type __rt_sigreturn,@function\\n\"                  \\\n-    \"__rt_sigreturn:\\n\"                                 \\\n-    \"moveli \" #REG \", \" #NR \"\\n\"                        \\\n-    \"swint1\\n\"                                          \\\n-    \".size __rt_sigreturn, . - __rt_sigreturn\\n\"        \\\n-    \".popsection\")\n-#define sigreturn_asm(REG, NR) _sigreturn_asm(REG, NR)\n-sigreturn_asm (TREG_SYSCALL_NR_NAME, __NR_rt_sigreturn);\n-#define SIGRETURN_LEN 16\n-extern char __rt_sigreturn[];\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR tile_fallback_frame_state\n-\n-static _Unwind_Reason_Code\n-tile_fallback_frame_state (struct _Unwind_Context *context,\n-\t\t\t      _Unwind_FrameState *fs)\n-{\n-  unsigned char *pc = context->ra;\n-  struct sigcontext *sc;\n-  long new_cfa;\n-  int i;\n-\n-  struct rt_sigframe {\n-    unsigned char save_area[C_ABI_SAVE_AREA_SIZE];\n-    siginfo_t info;\n-    ucontext_t uc;\n-  } *rt_;\n-\n-  /* Return if this is not a signal handler.  */\n-  if (memcmp (pc, __rt_sigreturn, SIGRETURN_LEN) != 0)\n-    return _URC_END_OF_STACK;\n-\n-  /* It was a signal handler; update the reported PC to point to our\n-     copy, since that will be findable with dladdr() and therefore\n-     somewhat easier to help understand what actually happened. */\n-  context->ra = __rt_sigreturn;\n-\n-  rt_ = context->cfa;\n-  sc = &rt_->uc.uc_mcontext;\n-\n-  new_cfa = sc->sp;\n-  fs->regs.cfa_how = CFA_REG_OFFSET;\n-  fs->regs.cfa_reg = __LIBGCC_STACK_POINTER_REGNUM__;\n-  fs->regs.cfa_offset = new_cfa - (long) context->cfa;\n-\n-  for (i = 0; i < 56; ++i)\n-    {\n-      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[i].loc.offset\n-\t= (long)&sc->gregs[i] - new_cfa;\n-    }\n-\n-  fs->regs.reg[56].how = REG_SAVED_OFFSET;\n-  fs->regs.reg[56].loc.offset = (long)&sc->pc - new_cfa;\n-  fs->retaddr_column = 56;\n-  fs->signal_frame = 1;\n-\n-  return _URC_NO_REASON;\n-}\n-\n-#endif /* ifdef inhibit_libc  */"}, {"sha": "6953d8d8db7ae17a1398890641222be4cf07b108", "filename": "libgcc/config/tilepro/sfp-machine.h", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fsfp-machine.h?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,59 +0,0 @@\n-#define _FP_W_TYPE_SIZE\t\t32\n-#define _FP_W_TYPE\t\tunsigned long\n-#define _FP_WS_TYPE\t\tsigned long\n-#define _FP_I_TYPE\t\tlong\n-\n-/* The type of the result of a floating point comparison.  This must\n-   match `__libgcc_cmp_return__' in GCC for the target.  */\n-typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n-#define CMPtype __gcc_CMPtype\n-\n-#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n-  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n-#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n-  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n-#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n-  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n-\n-#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n-#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n-#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n-\n-#define _FP_NANFRAC_S\t\t_FP_QNANBIT_S\n-#define _FP_NANFRAC_D\t\t_FP_QNANBIT_D, 0\n-#define _FP_NANFRAC_Q\t\t_FP_QNANBIT_Q, 0, 0, 0\n-#define _FP_NANSIGN_S\t\t1\n-#define _FP_NANSIGN_D\t\t1\n-#define _FP_NANSIGN_Q\t\t1\n-\n-#define _FP_KEEPNANFRACP 1\n-#define _FP_QNANNEGATEDP 0\n-\n-#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n-\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tR##_s = Y##_s;\t\t\t\t\t\t\\\n-\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tR##_s = X##_s;\t\t\t\t\t\t\\\n-\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define _FP_TININESS_AFTER_ROUNDING 0\n-\n-#define\t__LITTLE_ENDIAN\t1234\n-#define\t__BIG_ENDIAN\t4321\n-\n-#define __BYTE_ORDER __LITTLE_ENDIAN\n-\n-/* Define ALIASNAME as a strong alias for NAME.  */\n-# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n-# define _strong_alias(name, aliasname) \\\n-  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n-"}, {"sha": "fea45bd8e566d825f0ee0d2dd85aec8a35ff6fab", "filename": "libgcc/config/tilepro/softdivide.c", "status": "removed", "additions": 0, "deletions": 353, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Fsoftdivide.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Fsoftdivide.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fsoftdivide.c?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,353 +0,0 @@\n-/* Division and remainder routines for Tile.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by the\n-   Free Software Foundation; either version 3, or (at your option) any\n-   later version.\n-\n-   This file is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-typedef int int32_t;\n-typedef unsigned uint32_t;\n-typedef long long int64_t;\n-typedef unsigned long long uint64_t;\n-\n-/* Raise signal 8 (SIGFPE) with code 1 (FPE_INTDIV).  */\n-static inline void\n-raise_intdiv (void)\n-{\n-  asm (\"{ raise; moveli zero, 8 + (1 << 6) }\");\n-}\n-\n-\n-#ifndef __tilegx__\n-/*__udivsi3 - 32 bit integer unsigned divide  */\n-static inline uint32_t __attribute__ ((always_inline))\n-__udivsi3_inline (uint32_t dividend, uint32_t divisor)\n-{\n-  /* Divide out any power of two factor from dividend and divisor.\n-     Note that when dividing by zero the divisor will remain zero,\n-     which is all we need to detect that case below.  */\n-  const int power_of_two_factor = __insn_ctz (divisor);\n-  divisor >>= power_of_two_factor;\n-  dividend >>= power_of_two_factor;\n-\n-  /* Checks for division by power of two or division by zero.  */\n-  if (divisor <= 1)\n-    {\n-      if (divisor == 0)\n-\t{\n-\t  raise_intdiv ();\n-\t  return 0;\n-\t}\n-      return dividend;\n-    }\n-\n-  /* Compute (a / b) by repeatedly finding the largest N\n-     such that (b << N) <= a. For each such N, set bit N in the\n-     quotient, subtract (b << N) from a, and keep going. Think of this as\n-     the reverse of the \"shift-and-add\" that a multiply does. The values\n-     of N are precisely those shift counts.\n-\n-     Finding N is easy. First, use clz(b) - clz(a) to find the N\n-     that lines up the high bit of (b << N) with the high bit of a.\n-     Any larger value of N would definitely make (b << N) > a,\n-     which is too big.\n-\n-     Then, if (b << N) > a (because it has larger low bits), decrement\n-     N by one.  This adjustment will definitely make (b << N) less\n-     than a, because a's high bit is now one higher than b's.  */\n-\n-  /* Precomputing the max_ values allows us to avoid a subtract\n-     in the inner loop and just right shift by clz(remainder).  */\n-  const int divisor_clz = __insn_clz (divisor);\n-  const uint32_t max_divisor = divisor << divisor_clz;\n-  const uint32_t max_qbit = 1 << divisor_clz;\n-\n-  uint32_t quotient = 0;\n-  uint32_t remainder = dividend;\n-\n-  while (remainder >= divisor)\n-    {\n-      int shift = __insn_clz (remainder);\n-      uint32_t scaled_divisor = max_divisor >> shift;\n-      uint32_t quotient_bit = max_qbit >> shift;\n-\n-      int too_big = (scaled_divisor > remainder);\n-      scaled_divisor >>= too_big;\n-      quotient_bit >>= too_big;\n-      remainder -= scaled_divisor;\n-      quotient |= quotient_bit;\n-    }\n-  return quotient;\n-}\n-#endif /* !__tilegx__ */\n-\n-\n-/* __udivdi3 - 64 bit integer unsigned divide  */\n-static inline uint64_t __attribute__ ((always_inline))\n-__udivdi3_inline (uint64_t dividend, uint64_t divisor)\n-{\n-  /* Divide out any power of two factor from dividend and divisor.\n-     Note that when dividing by zero the divisor will remain zero,\n-     which is all we need to detect that case below.  */\n-  const int power_of_two_factor = __builtin_ctzll (divisor);\n-  divisor >>= power_of_two_factor;\n-  dividend >>= power_of_two_factor;\n-\n-  /* Checks for division by power of two or division by zero.  */\n-  if (divisor <= 1)\n-    {\n-      if (divisor == 0)\n-\t{\n-\t  raise_intdiv ();\n-\t  return 0;\n-\t}\n-      return dividend;\n-    }\n-\n-#ifndef __tilegx__\n-  if (((uint32_t) (dividend >> 32) | ((uint32_t) (divisor >> 32))) == 0)\n-    {\n-      /* Operands both fit in 32 bits, so use faster 32 bit algorithm.  */\n-      return __udivsi3_inline ((uint32_t) dividend, (uint32_t) divisor);\n-    }\n-#endif /* !__tilegx__ */\n-\n-  /* See algorithm description in __udivsi3  */\n-\n-  const int divisor_clz = __builtin_clzll (divisor);\n-  const uint64_t max_divisor = divisor << divisor_clz;\n-  const uint64_t max_qbit = 1ULL << divisor_clz;\n-\n-  uint64_t quotient = 0;\n-  uint64_t remainder = dividend;\n-\n-  while (remainder >= divisor)\n-    {\n-      int shift = __builtin_clzll (remainder);\n-      uint64_t scaled_divisor = max_divisor >> shift;\n-      uint64_t quotient_bit = max_qbit >> shift;\n-\n-      int too_big = (scaled_divisor > remainder);\n-      scaled_divisor >>= too_big;\n-      quotient_bit >>= too_big;\n-      remainder -= scaled_divisor;\n-      quotient |= quotient_bit;\n-    }\n-  return quotient;\n-}\n-\n-\n-#ifndef __tilegx__\n-/* __umodsi3 - 32 bit integer unsigned modulo  */\n-static inline uint32_t __attribute__ ((always_inline))\n-__umodsi3_inline (uint32_t dividend, uint32_t divisor)\n-{\n-  /* Shortcircuit mod by a power of two (and catch mod by zero).  */\n-  const uint32_t mask = divisor - 1;\n-  if ((divisor & mask) == 0)\n-    {\n-      if (divisor == 0)\n-\t{\n-\t  raise_intdiv ();\n-\t  return 0;\n-\t}\n-      return dividend & mask;\n-    }\n-\n-  /* We compute the remainder (a % b) by repeatedly subtracting off\n-     multiples of b from a until a < b. The key is that subtracting\n-     off a multiple of b does not affect the result mod b.\n-\n-     To make the algorithm run efficiently, we need to subtract\n-     off a large multiple of b at each step. We subtract the largest\n-     (b << N) that is <= a.\n-\n-     Finding N is easy. First, use clz(b) - clz(a) to find the N\n-     that lines up the high bit of (b << N) with the high bit of a.\n-     Any larger value of N would definitely make (b << N) > a,\n-     which is too big.\n-\n-     Then, if (b << N) > a (because it has larger low bits), decrement\n-     N by one.  This adjustment will definitely make (b << N) less\n-     than a, because a's high bit is now one higher than b's.  */\n-  const uint32_t max_divisor = divisor << __insn_clz (divisor);\n-\n-  uint32_t remainder = dividend;\n-  while (remainder >= divisor)\n-    {\n-      const int shift = __insn_clz (remainder);\n-      uint32_t scaled_divisor = max_divisor >> shift;\n-      scaled_divisor >>= (scaled_divisor > remainder);\n-      remainder -= scaled_divisor;\n-    }\n-\n-  return remainder;\n-}\n-#endif /* !__tilegx__ */\n-\n-\n-/* __umoddi3 - 64 bit integer unsigned modulo  */\n-static inline uint64_t __attribute__ ((always_inline))\n-__umoddi3_inline (uint64_t dividend, uint64_t divisor)\n-{\n-#ifndef __tilegx__\n-  if (((uint32_t) (dividend >> 32) | ((uint32_t) (divisor >> 32))) == 0)\n-    {\n-      /* Operands both fit in 32 bits, so use faster 32 bit algorithm.  */\n-      return __umodsi3_inline ((uint32_t) dividend, (uint32_t) divisor);\n-    }\n-#endif /* !__tilegx__ */\n-\n-  /* Shortcircuit mod by a power of two (and catch mod by zero).  */\n-  const uint64_t mask = divisor - 1;\n-  if ((divisor & mask) == 0)\n-    {\n-      if (divisor == 0)\n-\t{\n-\t  raise_intdiv ();\n-\t  return 0;\n-\t}\n-      return dividend & mask;\n-    }\n-\n-  /* See algorithm description in __umodsi3  */\n-  const uint64_t max_divisor = divisor << __builtin_clzll (divisor);\n-\n-  uint64_t remainder = dividend;\n-  while (remainder >= divisor)\n-    {\n-      const int shift = __builtin_clzll (remainder);\n-      uint64_t scaled_divisor = max_divisor >> shift;\n-      scaled_divisor >>= (scaled_divisor > remainder);\n-      remainder -= scaled_divisor;\n-    }\n-\n-  return remainder;\n-}\n-\n-\n-uint32_t __udivsi3 (uint32_t dividend, uint32_t divisor);\n-#ifdef L_tile_udivsi3\n-uint32_t\n-__udivsi3 (uint32_t dividend, uint32_t divisor)\n-{\n-#ifndef __tilegx__\n-  return __udivsi3_inline (dividend, divisor);\n-#else /* !__tilegx__ */\n-  uint64_t n = __udivdi3_inline (((uint64_t) dividend), ((uint64_t) divisor));\n-  return (uint32_t) n;\n-#endif /* !__tilegx__ */\n-}\n-#endif\n-\n-#define ABS(x) ((x) >= 0 ? (x) : -(x))\n-\n-int32_t __divsi3 (int32_t dividend, int32_t divisor);\n-#ifdef L_tile_divsi3\n-/* __divsi3 - 32 bit integer signed divide  */\n-int32_t\n-__divsi3 (int32_t dividend, int32_t divisor)\n-{\n-#ifndef __tilegx__\n-  uint32_t n = __udivsi3_inline (ABS (dividend), ABS (divisor));\n-#else /* !__tilegx__ */\n-  uint64_t n =\n-    __udivdi3_inline (ABS ((int64_t) dividend), ABS ((int64_t) divisor));\n-#endif /* !__tilegx__ */\n-  if ((dividend ^ divisor) < 0)\n-    n = -n;\n-  return (int32_t) n;\n-}\n-#endif\n-\n-\n-uint64_t __udivdi3 (uint64_t dividend, uint64_t divisor);\n-#ifdef L_tile_udivdi3\n-uint64_t\n-__udivdi3 (uint64_t dividend, uint64_t divisor)\n-{\n-  return __udivdi3_inline (dividend, divisor);\n-}\n-#endif\n-\n-/*__divdi3 - 64 bit integer signed divide  */\n-int64_t __divdi3 (int64_t dividend, int64_t divisor);\n-#ifdef L_tile_divdi3\n-int64_t\n-__divdi3 (int64_t dividend, int64_t divisor)\n-{\n-  uint64_t n = __udivdi3_inline (ABS (dividend), ABS (divisor));\n-  if ((dividend ^ divisor) < 0)\n-    n = -n;\n-  return (int64_t) n;\n-}\n-#endif\n-\n-\n-uint32_t __umodsi3 (uint32_t dividend, uint32_t divisor);\n-#ifdef L_tile_umodsi3\n-uint32_t\n-__umodsi3 (uint32_t dividend, uint32_t divisor)\n-{\n-#ifndef __tilegx__\n-  return __umodsi3_inline (dividend, divisor);\n-#else /* !__tilegx__ */\n-  return __umoddi3_inline ((uint64_t) dividend, (uint64_t) divisor);\n-#endif /* !__tilegx__ */\n-}\n-#endif\n-\n-\n-/* __modsi3 - 32 bit integer signed modulo  */\n-int32_t __modsi3 (int32_t dividend, int32_t divisor);\n-#ifdef L_tile_modsi3\n-int32_t\n-__modsi3 (int32_t dividend, int32_t divisor)\n-{\n-#ifndef __tilegx__\n-  uint32_t remainder = __umodsi3_inline (ABS (dividend), ABS (divisor));\n-#else /* !__tilegx__ */\n-  uint64_t remainder =\n-    __umoddi3_inline (ABS ((int64_t) dividend), ABS ((int64_t) divisor));\n-#endif /* !__tilegx__ */\n-  return (int32_t) ((dividend >= 0) ? remainder : -remainder);\n-}\n-#endif\n-\n-\n-uint64_t __umoddi3 (uint64_t dividend, uint64_t divisor);\n-#ifdef L_tile_umoddi3\n-uint64_t\n-__umoddi3 (uint64_t dividend, uint64_t divisor)\n-{\n-  return __umoddi3_inline (dividend, divisor);\n-}\n-#endif\n-\n-\n-/* __moddi3 - 64 bit integer signed modulo  */\n-int64_t __moddi3 (int64_t dividend, int64_t divisor);\n-#ifdef L_tile_moddi3\n-int64_t\n-__moddi3 (int64_t dividend, int64_t divisor)\n-{\n-  uint64_t remainder = __umoddi3_inline (ABS (dividend), ABS (divisor));\n-  return (int64_t) ((dividend >= 0) ? remainder : -remainder);\n-}\n-#endif"}, {"sha": "0554a6f9cb5196cffee4b47ae264eba45dbc3048", "filename": "libgcc/config/tilepro/softmpy.S", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Fsoftmpy.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Fsoftmpy.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fsoftmpy.S?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,94 +0,0 @@\n-/* 64-bit multiplication support for TILEPro.\n-   Copyright (C) 2011-2022 Free Software Foundation, Inc.\n-   Contributed by Walter Lee (walt@tilera.com)\n-\n-   This file is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by the\n-   Free Software Foundation; either version 3, or (at your option) any\n-   later version.\n-\n-   This file is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* 64-bit multiplication support.  */\n-\n-\t.file \"softmpy.S\"\n-\n-/* Parameters */\n-#define lo0             r9   /* low 32 bits of n0  */\n-#define hi0             r1   /* high 32 bits of n0 */\n-#define lo1             r2   /* low 32 bits of n1  */\n-#define hi1             r3   /* high 32 bits of n1 */\n-\n-/* temps */\n-#define result1_a       r4\n-#define result1_b       r5\n-\n-#define tmp0            r6\n-#define tmp0_left_16    r7\n-#define tmp1            r8\n-\n-\t.section .text.__muldi3, \"ax\"\n-\t.align 8\n-\t.globl __muldi3\n-\t.type __muldi3, @function\n-__muldi3:\n-\t{\n-\t move\t     lo0, r0 /* so we can write \"out r0\" while \"in r0\" alive */\n-\t mulhl_uu    tmp0, lo1, r0\n-\t}\n-\t{\n-\t mulll_uu    result1_a, lo1, hi0\n-\t}\n-\t{\n-\t move        tmp1, tmp0\n-\t mulhla_uu   tmp0, lo0, lo1\n-\t}\n-\t{\n-\t mulhlsa_uu  result1_a, lo1, hi0\n-\t}\n-\t{\n-\t mulll_uu    result1_b, lo0, hi1\n-\t slt_u       tmp1, tmp0, tmp1\n-\t}\n-\t{\n-\t mulhlsa_uu  result1_a, lo0, hi1\n-\t shli        r0, tmp0, 16\n-\t}\n-\t{\n-\t move        tmp0_left_16, r0\n-\t mulhha_uu   result1_b, lo0, lo1\n-\t}\n-\t{\n-\t mullla_uu   r0, lo1, lo0\n-\t shli        tmp1, tmp1, 16\n-\t}\n-\t{\n-\t mulhlsa_uu  result1_b, hi0, lo1\n-\t inthh       tmp1, tmp1, tmp0\n-\t}\n-\t{\n-\t mulhlsa_uu  result1_a, hi1, lo0\n-\t slt_u       tmp0, r0, tmp0_left_16\n-\t}\n-\t/* NOTE: this will stall for a cycle here. Oh well. */\n-\t{\n-\t add         r1, tmp0, tmp1\n-\t add         result1_a, result1_a, result1_b\n-\t}\n-\t{\n-\t add         r1, r1, result1_a\n-\t jrp         lr\n-\t}\n-\t.size __muldi3,.-__muldi3"}, {"sha": "eddc45ce9d8774c36547c0d2db8185b4ea53bcf8", "filename": "libgcc/config/tilepro/t-crtstuff", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Ft-crtstuff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Ft-crtstuff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Ft-crtstuff?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,4 +0,0 @@\n-# crtend*.o cannot be compiled without -fno-asynchronous-unwind-tables,\n-# because then __FRAME_END__ might not be the last thing in .eh_frame\n-# section.\n-CRTSTUFF_T_CFLAGS += -fno-asynchronous-unwind-tables"}, {"sha": "eb6894ce115b0d6d8672f3a60f19a1ca471f459b", "filename": "libgcc/config/tilepro/t-tilepro", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Ft-tilepro", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a5f478487a955c3ffaec3e9164a72599bc1cfb/libgcc%2Fconfig%2Ftilepro%2Ft-tilepro", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Ft-tilepro?ref=54a5f478487a955c3ffaec3e9164a72599bc1cfb", "patch": "@@ -1,33 +0,0 @@\n-LIB2ADD += \\\n-  $(srcdir)/config/tilepro/softmpy.S \\\n-  $(srcdir)/config/tilepro/atomic.c\n-\n-LIB2FUNCS_EXCLUDE += \\\n-  _divdi3 \\\n-  _moddi3 \\\n-  _muldi3 \\\n-  _udivdi3 \\\n-  _umoddi3\n-\n-SOFTDIVIDE_FUNCS := \\\n-  _tile_udivsi3 \\\n-  _tile_divsi3 \\\n-  _tile_udivdi3 \\\n-  _tile_divdi3 \\\n-  _tile_umodsi3 \\\n-  _tile_modsi3 \\\n-  _tile_umoddi3 \\\n-  _tile_moddi3\n-\n-softdivide-o = $(patsubst %,%$(objext),$(SOFTDIVIDE_FUNCS))\n-$(softdivide-o): %$(objext): $(srcdir)/config/tilepro/softdivide.c\n-\t$(gcc_compile) -ffunction-sections -DMAYBE_STATIC= -DL$* -c $< \\\n-\t  $(vis_hide)\n-libgcc-objects += $(softdivide-o)\n-\n-ifeq ($(enable_shared),yes)\n-softdivide-s-o = $(patsubst %,%_s$(objext),$(SOFTDIVIDE_FUNCS))\n-$(softdivide-s-o): %_s$(objext): $(srcdir)/config/tilepro/softdivide.c\n-\t$(gcc_s_compile) -ffunction-sections -DMAYBE_STATIC= -DL$* -c $<\n-libgcc-s-objects += $(softdivide-s-o)\n-endif"}]}