{"sha": "878aa8171752ad29ae47099e31fbe3df1dcf3133", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc4YWE4MTcxNzUyYWQyOWFlNDcwOTllMzFmYmUzZGYxZGNmMzEzMw==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-01-16T08:26:03Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-01-16T08:26:03Z"}, "message": "tree-vectorizer.h (is_pattern_stmt_p): New.\n\n        * tree-vectorizer.h (is_pattern_stmt_p): New.\n        * tree-vect-analyze.c (vect_determine_vectorization_factor): Fix\n        formatting (tabs instead of spaces). Cleanup and clarify setting\n        of STMT_VINFO_VECTYPE. Call is_pattern_stmt_p.\n        * tree-vect-transform.c (vect_get_vec_def_for_operand): Fix typo.\n        (vectorizable_type_demotion): Check that types are integral.\n        (vectorizable_type_promotion): Likewise.\n        (vectorizable_store): Fix typo.  Eliminate new-line at end of\n        comments.\n\n\nCo-Authored-By: Tehila Meyzels <tehila@il.ibm.com>\n\nFrom-SVN: r120825", "tree": {"sha": "7eb41b628f9d5b93cf6e2d18085f834a813d19e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7eb41b628f9d5b93cf6e2d18085f834a813d19e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/878aa8171752ad29ae47099e31fbe3df1dcf3133", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878aa8171752ad29ae47099e31fbe3df1dcf3133", "html_url": "https://github.com/Rust-GCC/gccrs/commit/878aa8171752ad29ae47099e31fbe3df1dcf3133", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878aa8171752ad29ae47099e31fbe3df1dcf3133/comments", "author": null, "committer": null, "parents": [{"sha": "03b1d1341cd8640cf83eeadba4c0616cbb916211", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b1d1341cd8640cf83eeadba4c0616cbb916211", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b1d1341cd8640cf83eeadba4c0616cbb916211"}], "stats": {"total": 152, "additions": 100, "deletions": 52}, "files": [{"sha": "45029c3f3eeb4032dc5cc23e6455a8d073a61fe3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878aa8171752ad29ae47099e31fbe3df1dcf3133/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878aa8171752ad29ae47099e31fbe3df1dcf3133/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=878aa8171752ad29ae47099e31fbe3df1dcf3133", "patch": "@@ -1,3 +1,16 @@\n+2007-01-16  Dorit Nuzman  <dorit@il.ibm.com>\n+            Tehila Meyzels  <tehila@il.ibm.com>\n+\n+\t* tree-vectorizer.h (is_pattern_stmt_p): New.\n+\t* tree-vect-analyze.c (vect_determine_vectorization_factor): Fix\n+\tformatting (tabs instead of spaces). Cleanup and clarify setting\n+\tof STMT_VINFO_VECTYPE. Call is_pattern_stmt_p.\n+\t* tree-vect-transform.c (vect_get_vec_def_for_operand): Fix typo.\n+\t(vectorizable_type_demotion): Check that types are integral.\n+\t(vectorizable_type_promotion): Likewise.\n+\t(vectorizable_store): Fix typo.  Eliminate new-line at end of\n+\tcomments.\n+\n 2007-01-16  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssanames.c (release_dead_ssa_names): Remove invalidated"}, {"sha": "114f8236a6c69b439cda9ac7c1eaca1a91ba64f6", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 58, "deletions": 43, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878aa8171752ad29ae47099e31fbe3df1dcf3133/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878aa8171752ad29ae47099e31fbe3df1dcf3133/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=878aa8171752ad29ae47099e31fbe3df1dcf3133", "patch": "@@ -109,52 +109,67 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n         {\n-          tree stmt = bsi_stmt (si);\n-          unsigned int nunits;\n-          stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-          tree vectype;\n+\t  tree stmt = bsi_stmt (si);\n+\t  unsigned int nunits;\n+\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  tree vectype;\n \n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            {\n-              fprintf (vect_dump, \"==> examining statement: \");\n-              print_generic_expr (vect_dump, stmt, TDF_SLIM);\n-            }\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"==> examining statement: \");\n+\t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t    }\n+\n+\t  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+\t    continue;\n+\n+\t  gcc_assert (stmt_info);\n \n-          gcc_assert (stmt_info);\n-          /* skip stmts which do not need to be vectorized.  */\n-          if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+\t  /* skip stmts which do not need to be vectorized.  */\n+\t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n \t      && !STMT_VINFO_LIVE_P (stmt_info))\n-            {\n-              if (vect_print_dump_info (REPORT_DETAILS))\n-                fprintf (vect_dump, \"skip.\");\n-              continue;\n-            }\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t        fprintf (vect_dump, \"skip.\");\n+\t      continue;\n+\t    }\n \n-          if (!GIMPLE_STMT_P (stmt)\n+\t  if (!GIMPLE_STMT_P (stmt)\n \t      && VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))))\n-            {\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-                {\n-                  fprintf (vect_dump, \"not vectorized: vector stmt in loop:\");\n-                  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n-                }\n-              return false;\n-            }\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\t        {\n+\t          fprintf (vect_dump, \"not vectorized: vector stmt in loop:\");\n+\t          print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t        }\n+\t      return false;\n+\t    }\n \n \t  if (STMT_VINFO_VECTYPE (stmt_info))\n \t    {\n+\t      /* The only case when a vectype had been already set is for stmts \n+\t         that contain a dataref, or for \"pattern-stmts\" (stmts generated\n+\t\t by the vectorizer to represent/replace a certain idiom).  */\n+\t      gcc_assert (STMT_VINFO_DATA_REF (stmt_info) \n+\t\t\t  || is_pattern_stmt_p (stmt_info));\n \t      vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\t      scalar_type = TREE_TYPE (vectype);\n \t    }\n \t  else\n \t    {\n-\t      if (STMT_VINFO_DATA_REF (stmt_info))\n-\t\tscalar_type = \n-\t\t\tTREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (stmt_info)));\n-\t      else if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n-\t\tscalar_type = TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 0));\n-\t      else\n-\t\tscalar_type = TREE_TYPE (stmt);\n+\t      gcc_assert (! STMT_VINFO_DATA_REF (stmt_info)\n+\t\t\t  && !is_pattern_stmt_p (stmt_info));\n+\n+\t      /* We set the vectype according to the type of the result (lhs).\n+\t\t For stmts whose result-type is different than the type of the\n+\t\t arguments (e.g. demotion, promotion), vectype will be reset \n+\t\t appropriately (later).  Note that we have to visit the smallest \n+\t\t datatype in this function, because that determines the VF.  \n+\t\t If the samallest datatype in the loop is present only as the \n+\t\t rhs of a promotion operation - we'd miss it here.\n+\t\t However, in such a case, that a variable of this datatype\n+\t\t does not appear in the lhs anywhere in the loop, it shouldn't\n+\t\t affect the vectorization factor.   */\n+\t      scalar_type = TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 0));\n \n \t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\t{\n@@ -176,17 +191,17 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      STMT_VINFO_VECTYPE (stmt_info) = vectype;\n             }\n \n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            {\n-              fprintf (vect_dump, \"vectype: \");\n-              print_generic_expr (vect_dump, vectype, TDF_SLIM);\n-            }\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"vectype: \");\n+\t      print_generic_expr (vect_dump, vectype, TDF_SLIM);\n+\t    }\n \n-          nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"nunits = %d\", nunits);\n+\t  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"nunits = %d\", nunits);\n \n-          if (!vectorization_factor\n+\t  if (!vectorization_factor\n \t      || (nunits > vectorization_factor))\n \t    vectorization_factor = nunits;\n "}, {"sha": "846d52bf90cac03642898a1b4ce1ef1f8dd02c98", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878aa8171752ad29ae47099e31fbe3df1dcf3133/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878aa8171752ad29ae47099e31fbe3df1dcf3133/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=878aa8171752ad29ae47099e31fbe3df1dcf3133", "patch": "@@ -665,7 +665,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n    vector stmt (each computing a vector of 'nunits' results, and together\n    computing 'VF' results in each iteration).  This function is called when \n    vectorizing such a stmt (e.g. vectorizing S2 in the illustration below, in\n-   which VF=16 and nuniti=4, so the number of copies required is 4):\n+   which VF=16 and nunits=4, so the number of copies required is 4):\n \n    scalar stmt:         vectorized into:        STMT_VINFO_RELATED_STMT\n  \n@@ -2171,6 +2171,10 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n                                                                                 \n   ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n   gcc_assert (ncopies >= 1);\n+\n+  if (! INTEGRAL_TYPE_P (scalar_type)\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n+    return false;\n                                                                                 \n   /* Check the operands of the operation.  */\n   if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n@@ -2377,6 +2381,10 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n   if (nunits_out != nunits_in / 2) /* FORNOW */\n     return false;\n \n+  if (! INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (op0))) \n+    return false;\n+\n   /* Check the operands of the operation.  */\n   if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n     {\n@@ -2772,7 +2780,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n         S3:  &base + 1 = x1\n         S4:  &base + 3 = x3\n \n-     We create vectorized storess starting from base address (the access of the\n+     We create vectorized stores starting from base address (the access of the\n      first stmt in the chain (S2 in the above example), when the last store stmt\n      of the chain (S4) is reached:\n \n@@ -2811,17 +2819,15 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t     as an input to vect_permute_store_chain(), and OPRNDS as an input\n \t     to vect_get_vec_def_for_stmt_copy() for the next copy.\n \t     If the store is not strided, GROUP_SIZE is 1, and DR_CHAIN and\n-\t     OPRNDS are of size 1.\n-\t  */\n+\t     OPRNDS are of size 1.  */\n \t  next_stmt = first_stmt;\t  \n \t  for (i = 0; i < group_size; i++)\n \t    {\n \t      /* Since gaps are not supported for interleaved stores, GROUP_SIZE\n \t\t is the exact number of stmts in the chain. Therefore, NEXT_STMT\n \t\t can't be NULL_TREE.  In case that there is no interleaving, \n \t\t GROUP_SIZE is 1, and only one iteration of the loop will be \n-\t\t executed.\n-\t      */\n+\t\t executed.  */\n \t      gcc_assert (next_stmt);\n \t      op = GIMPLE_STMT_OPERAND (next_stmt, 1);\n \t      vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt, NULL);\n@@ -2841,8 +2847,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t     and OPRNDS as an input to vect_get_vec_def_for_stmt_copy() for the \n \t     next copy.\n \t     If the store is not strided, GROUP_SIZE is 1, and DR_CHAIN and\n-\t     OPRNDS are of size 1.\n-\t  */\n+\t     OPRNDS are of size 1.  */\n \t  for (i = 0; i < group_size; i++)\n \t    {\n \t      vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, \n@@ -2907,7 +2912,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t    }\n \n \t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n-\t  \t  next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+\t  next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n \t  if (!next_stmt)\n \t    break;\n \t  /* Bump the vector pointer.  */"}, {"sha": "f3234032611d59c83c76ae09561511a3ebbbb2cb", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878aa8171752ad29ae47099e31fbe3df1dcf3133/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878aa8171752ad29ae47099e31fbe3df1dcf3133/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=878aa8171752ad29ae47099e31fbe3df1dcf3133", "patch": "@@ -300,6 +300,21 @@ vinfo_for_stmt (tree stmt)\n   return ann ? (stmt_vec_info) ann->common.aux : NULL;\n }\n \n+static inline bool\n+is_pattern_stmt_p (stmt_vec_info stmt_info)\n+{\n+  tree related_stmt;\n+  stmt_vec_info related_stmt_info;\n+\n+  related_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+  if (related_stmt\n+      && (related_stmt_info = vinfo_for_stmt (related_stmt))\n+      && STMT_VINFO_IN_PATTERN_P (related_stmt_info))\n+    return true;\n+\n+  return false;\n+}\n+\n /*-----------------------------------------------------------------*/\n /* Info on data references alignment.                              */\n /*-----------------------------------------------------------------*/"}]}