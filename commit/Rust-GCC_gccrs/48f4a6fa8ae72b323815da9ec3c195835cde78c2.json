{"sha": "48f4a6fa8ae72b323815da9ec3c195835cde78c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhmNGE2ZmE4YWU3MmIzMjM4MTVkYTllYzNjMTk1ODM1Y2RlNzhjMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-03-17T15:43:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-03-17T15:43:13Z"}, "message": "cgraph.h (cgraph_get_create_real_symbol_node): Declare.\n\n\n\t* cgraph.h (cgraph_get_create_real_symbol_node): Declare.\n\t* cgraph.c (cgraph_get_create_real_symbol_node): New function.\n\t* cgrpahbuild.c: Use cgraph_get_create_real_symbol_node instead\n\tof cgraph_get_create_node.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Likewise.\n\nFrom-SVN: r196750", "tree": {"sha": "93a222cca92de488bfe4665abb660d563af4a5ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93a222cca92de488bfe4665abb660d563af4a5ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48f4a6fa8ae72b323815da9ec3c195835cde78c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f4a6fa8ae72b323815da9ec3c195835cde78c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48f4a6fa8ae72b323815da9ec3c195835cde78c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f4a6fa8ae72b323815da9ec3c195835cde78c2/comments", "author": null, "committer": null, "parents": [{"sha": "d1f45df55be8f73a75b878aa409aae1d8786759e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1f45df55be8f73a75b878aa409aae1d8786759e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1f45df55be8f73a75b878aa409aae1d8786759e"}], "stats": {"total": 93, "additions": 60, "deletions": 33}, "files": [{"sha": "0a4e45a4872e51328bfcd915aa61607428f6fd15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f4a6fa8ae72b323815da9ec3c195835cde78c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f4a6fa8ae72b323815da9ec3c195835cde78c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48f4a6fa8ae72b323815da9ec3c195835cde78c2", "patch": "@@ -1,3 +1,11 @@\n+2013-03-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (cgraph_get_create_real_symbol_node): Declare.\n+\t* cgraph.c (cgraph_get_create_real_symbol_node): New function.\n+\t* cgrpahbuild.c: Use cgraph_get_create_real_symbol_node instead\n+\tof cgraph_get_create_node.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Likewise.\n+\n 2013-03-16  Jason Merrill  <jason@redhat.com>\n \n \tPR debug/49090"}, {"sha": "930ccd862fe3a0828b14c67cebf533a28d6032b8", "filename": "gcc/cgraph.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f4a6fa8ae72b323815da9ec3c195835cde78c2/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f4a6fa8ae72b323815da9ec3c195835cde78c2/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=48f4a6fa8ae72b323815da9ec3c195835cde78c2", "patch": "@@ -2595,4 +2595,47 @@ verify_cgraph (void)\n   FOR_EACH_FUNCTION (node)\n     verify_cgraph_node (node);\n }\n+\n+/* Create external decl node for DECL.\n+   The difference i nbetween cgraph_get_create_node and\n+   cgraph_get_create_real_symbol_node is that cgraph_get_create_node\n+   may return inline clone, while cgraph_get_create_real_symbol_node\n+   will create a new node in this case.\n+   FIXME: This function should be removed once clones are put out of decl\n+   hash.  */\n+\n+struct cgraph_node *\n+cgraph_get_create_real_symbol_node (tree decl)\n+{\n+  struct cgraph_node *first_clone = cgraph_get_node (decl);\n+  struct cgraph_node *node;\n+  /* create symbol table node.  even if inline clone exists, we can not take\n+     it as a target of non-inlined call.  */\n+  node = cgraph_get_node (decl);\n+  if (node && !node->global.inlined_to)\n+    return node;\n+\n+  node = cgraph_create_node (decl);\n+\n+  /* ok, we previously inlined the function, then removed the offline copy and\n+     now we want it back for external call.  this can happen when devirtualizing\n+     while inlining function called once that happens after extern inlined and\n+     virtuals are already removed.  in this case introduce the external node\n+     and make it available for call.  */\n+  if (first_clone)\n+    {\n+      first_clone->clone_of = node;\n+      node->clones = first_clone;\n+      symtab_prevail_in_asm_name_hash ((symtab_node) node);\n+      symtab_insert_node_to_hashtable ((symtab_node) node);\n+      if (dump_file)\n+\tfprintf (dump_file, \"Introduced new external node \"\n+\t\t \"(%s/%i) and turned into root of the clone tree.\\n\",\n+\t\t xstrdup (cgraph_node_name (node)), node->uid);\n+    }\n+  else if (dump_file)\n+    fprintf (dump_file, \"Introduced new external node \"\n+\t     \"(%s/%i).\\n\", xstrdup (cgraph_node_name (node)), node->uid);\n+  return node;\n+}\n #include \"gt-cgraph.h\""}, {"sha": "8ab7ae1810281565dfcd3271d24e2b0a62dbaf7f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f4a6fa8ae72b323815da9ec3c195835cde78c2/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f4a6fa8ae72b323815da9ec3c195835cde78c2/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=48f4a6fa8ae72b323815da9ec3c195835cde78c2", "patch": "@@ -575,6 +575,7 @@ struct cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n struct cgraph_node * cgraph_create_node (tree);\n struct cgraph_node * cgraph_create_empty_node (void);\n struct cgraph_node * cgraph_get_create_node (tree);\n+struct cgraph_node * cgraph_get_create_real_symbol_node (tree);\n struct cgraph_node * cgraph_same_body_alias (struct cgraph_node *, tree, tree);\n struct cgraph_node * cgraph_add_thunk (struct cgraph_node *, tree, tree, bool, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, tree, tree);"}, {"sha": "a74a4c043e36721cdb6109458b4e087d67cc0b13", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f4a6fa8ae72b323815da9ec3c195835cde78c2/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f4a6fa8ae72b323815da9ec3c195835cde78c2/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=48f4a6fa8ae72b323815da9ec3c195835cde78c2", "patch": "@@ -73,7 +73,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n       decl = get_base_var (*tp);\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t{\n-\t  struct cgraph_node *node = cgraph_get_create_node (decl);\n+\t  struct cgraph_node *node = cgraph_get_create_real_symbol_node (decl);\n \t  if (!ctx->only_vars)\n \t    cgraph_mark_address_taken_node (node);\n \t  ipa_record_reference ((symtab_node)ctx->varpool_node,\n@@ -143,7 +143,7 @@ record_eh_tables (struct cgraph_node *node, struct function *fun)\n     {\n       struct cgraph_node *per_node;\n \n-      per_node = cgraph_get_create_node (DECL_FUNCTION_PERSONALITY (node->symbol.decl));\n+      per_node = cgraph_get_create_real_symbol_node (DECL_FUNCTION_PERSONALITY (node->symbol.decl));\n       ipa_record_reference ((symtab_node)node, (symtab_node)per_node, IPA_REF_ADDR, NULL);\n       cgraph_mark_address_taken_node (per_node);\n     }\n@@ -223,7 +223,7 @@ mark_address (gimple stmt, tree addr, void *data)\n   addr = get_base_address (addr);\n   if (TREE_CODE (addr) == FUNCTION_DECL)\n     {\n-      struct cgraph_node *node = cgraph_get_create_node (addr);\n+      struct cgraph_node *node = cgraph_get_create_real_symbol_node (addr);\n       cgraph_mark_address_taken_node (node);\n       ipa_record_reference ((symtab_node)data,\n \t\t\t    (symtab_node)node,\n@@ -252,7 +252,7 @@ mark_load (gimple stmt, tree t, void *data)\n     {\n       /* ??? This can happen on platforms with descriptors when these are\n \t directly manipulated in the code.  Pretend that it's an address.  */\n-      struct cgraph_node *node = cgraph_get_create_node (t);\n+      struct cgraph_node *node = cgraph_get_create_real_symbol_node (t);\n       cgraph_mark_address_taken_node (node);\n       ipa_record_reference ((symtab_node)data,\n \t\t\t    (symtab_node)node,\n@@ -330,20 +330,20 @@ build_cgraph_edges (void)\n \t    {\n \t      tree fn = gimple_omp_parallel_child_fn (stmt);\n \t      ipa_record_reference ((symtab_node)node,\n-\t\t\t\t    (symtab_node)cgraph_get_create_node (fn),\n+\t\t\t\t    (symtab_node)cgraph_get_create_real_symbol_node (fn),\n \t\t\t\t    IPA_REF_ADDR, stmt);\n \t    }\n \t  if (gimple_code (stmt) == GIMPLE_OMP_TASK)\n \t    {\n \t      tree fn = gimple_omp_task_child_fn (stmt);\n \t      if (fn)\n \t\tipa_record_reference ((symtab_node)node,\n-\t\t\t\t      (symtab_node) cgraph_get_create_node (fn),\n+\t\t\t\t      (symtab_node) cgraph_get_create_real_symbol_node (fn),\n \t\t\t\t      IPA_REF_ADDR, stmt);\n \t      fn = gimple_omp_task_copy_fn (stmt);\n \t      if (fn)\n \t\tipa_record_reference ((symtab_node)node,\n-\t\t\t\t      (symtab_node)cgraph_get_create_node (fn),\n+\t\t\t\t      (symtab_node)cgraph_get_create_real_symbol_node (fn),\n \t\t\t\t      IPA_REF_ADDR, stmt);\n \t    }\n \t}"}, {"sha": "2b293a995c1955a01695c435ba6868689b2ef589", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f4a6fa8ae72b323815da9ec3c195835cde78c2/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f4a6fa8ae72b323815da9ec3c195835cde78c2/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=48f4a6fa8ae72b323815da9ec3c195835cde78c2", "patch": "@@ -2117,7 +2117,6 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n      we may create the first reference to the object in the unit.  */\n   if (!callee || callee->global.inlined_to)\n     {\n-      struct cgraph_node *first_clone = callee;\n \n       /* We are better to ensure we can refer to it.\n \t In the case of static functions we are out of luck, since we already\t\n@@ -2133,31 +2132,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \t\t     xstrdup (cgraph_node_name (ie->callee)), ie->callee->uid);\n \t  return NULL;\n \t}\n-\n-      /* Create symbol table node.  Even if inline clone exists, we can not take\n-\t it as a target of non-inlined call.  */\n-      callee = cgraph_create_node (target);\n-\n-      /* OK, we previously inlined the function, then removed the offline copy and\n-\t now we want it back for external call.  This can happen when devirtualizing\n-\t while inlining function called once that happens after extern inlined and\n-\t virtuals are already removed.  In this case introduce the external node\n-\t and make it available for call.  */\n-      if (first_clone)\n-\t{\n-\t  first_clone->clone_of = callee;\n-\t  callee->clones = first_clone;\n-\t  symtab_prevail_in_asm_name_hash ((symtab_node)callee);\n-\t  symtab_insert_node_to_hashtable ((symtab_node)callee);\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"ipa-prop: Introduced new external node \"\n-\t\t     \"(%s/%i) and turned into root of the clone tree.\\n\",\n-\t\t     xstrdup (cgraph_node_name (callee)), callee->uid);\n-\t}\n-      else if (dump_file)\n-\tfprintf (dump_file, \"ipa-prop: Introduced new external node \"\n-\t\t \"(%s/%i).\\n\",\n-\t\t xstrdup (cgraph_node_name (callee)), callee->uid);\n+      callee = cgraph_get_create_real_symbol_node (target);\n     }\n   ipa_check_create_node_params ();\n "}]}