{"sha": "715e7fbc831af02e80acc60be2fa19208ab62dfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE1ZTdmYmM4MzFhZjAyZTgwYWNjNjBiZTJmYTE5MjA4YWI2MmRmYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-10T23:34:17Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-10T23:34:17Z"}, "message": "combine.c (refresh_blocks, [...]): New.\n\n        * combine.c (refresh_blocks, need_refresh): New.\n        (combine_instructions): Allocate refresh_blocks.  Invoke\n        update_life_info if needed.\n        (distribute_notes): Mark refresh_blocks instead of installing\n        USE insns.\n        * flow.c (update_life_info): Remove notes if GLOBAL_RM_NOTES.\n        * basic_block.h (enum update_life_extent): Add GLOBAL_RM_NOTES.\n\n        * Makefile.in (recog.o): Depend on basic-block.h.\n\nFrom-SVN: r29893", "tree": {"sha": "ba7b0b84a68f9ed2f41f5b4352349cfa71aae6ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba7b0b84a68f9ed2f41f5b4352349cfa71aae6ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/715e7fbc831af02e80acc60be2fa19208ab62dfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/715e7fbc831af02e80acc60be2fa19208ab62dfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/715e7fbc831af02e80acc60be2fa19208ab62dfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/715e7fbc831af02e80acc60be2fa19208ab62dfc/comments", "author": null, "committer": null, "parents": [{"sha": "07b983cd7142b619b990d572a89a3370ae12f7a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b983cd7142b619b990d572a89a3370ae12f7a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b983cd7142b619b990d572a89a3370ae12f7a6"}], "stats": {"total": 72, "additions": 45, "deletions": 27}, "files": [{"sha": "32b6b35bcb64a9dbb3f595af8ad918ba569b27b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/715e7fbc831af02e80acc60be2fa19208ab62dfc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/715e7fbc831af02e80acc60be2fa19208ab62dfc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=715e7fbc831af02e80acc60be2fa19208ab62dfc", "patch": "@@ -1,3 +1,15 @@\n+Sun Oct 10 16:14:16 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* combine.c (refresh_blocks, need_refresh): New.\n+\t(combine_instructions): Allocate refresh_blocks.  Invoke\n+\tupdate_life_info if needed.\n+\t(distribute_notes): Mark refresh_blocks instead of installing\n+\tUSE insns.\n+\t* flow.c (update_life_info): Remove notes if GLOBAL_RM_NOTES.\n+\t* basic_block.h (enum update_life_extent): Add GLOBAL_RM_NOTES.\n+\n+\t* Makefile.in (recog.o): Depend on basic-block.h.\n+\n Sun Oct 10 12:03:21 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* genrecog.c (add_to_sequence): Thinko last change: delete"}, {"sha": "fcfa047c34de6c1eb72aed1c8d31d031fc149422", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/715e7fbc831af02e80acc60be2fa19208ab62dfc/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/715e7fbc831af02e80acc60be2fa19208ab62dfc/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=715e7fbc831af02e80acc60be2fa19208ab62dfc", "patch": "@@ -1593,7 +1593,7 @@ final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h intl.h \\\n    dbxout.h\n recog.o : recog.c $(CONFIG_H) system.h $(RTL_H) function.h \\\n    $(REGS_H) $(RECOG_H) hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n-   insn-flags.h insn-codes.h real.h toplev.h output.h resource.h\n+   insn-flags.h insn-codes.h real.h toplev.h output.h resource.h basic-block.h\n reg-stack.o : reg-stack.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) recog.h \\\n    $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-flags.h toplev.h \\\n    varray.h function.h"}, {"sha": "e7c5dfc630810d0f53cb3d48255c2c1ba6199100", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/715e7fbc831af02e80acc60be2fa19208ab62dfc/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/715e7fbc831af02e80acc60be2fa19208ab62dfc/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=715e7fbc831af02e80acc60be2fa19208ab62dfc", "patch": "@@ -301,8 +301,9 @@ extern void compute_immediate_dominators\tPROTO ((int *, sbitmap *));\n \n enum update_life_extent\n {\n-  UPDATE_LIFE_GLOBAL = 0,\n-  UPDATE_LIFE_LOCAL = 1\n+  UPDATE_LIFE_LOCAL = 0,\n+  UPDATE_LIFE_GLOBAL = 1,\n+  UPDATE_LIFE_GLOBAL_RM_NOTES = 2,\n };\n \n extern void update_life_info\tPROTO ((sbitmap, enum update_life_extent));"}, {"sha": "c63bf3998b08abe339eabd8fb2ce4f793c183bfa", "filename": "gcc/combine.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/715e7fbc831af02e80acc60be2fa19208ab62dfc/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/715e7fbc831af02e80acc60be2fa19208ab62dfc/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=715e7fbc831af02e80acc60be2fa19208ab62dfc", "patch": "@@ -196,6 +196,12 @@ static rtx added_links_insn;\n \n /* Basic block number of the block in which we are performing combines.  */\n static int this_basic_block;\n+\n+/* A bitmap indicating which blocks had registers go dead at entry.  \n+   After combine, we'll need to re-do global life analysis with \n+   those blocks as starting points.  */\n+static sbitmap refresh_blocks;\n+static int need_refresh;\n \f\n /* The next group of arrays allows the recording of the last value assigned\n    to (hard or pseudo) register n.  We use this information to see if a\n@@ -551,6 +557,10 @@ combine_instructions (f, nregs)\n \n   setup_incoming_promotions ();\n \n+  refresh_blocks = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (refresh_blocks);\n+  need_refresh = 0;\n+\n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n     {\n       uid_cuid[INSN_UID (insn)] = ++i;\n@@ -685,6 +695,10 @@ combine_instructions (f, nregs)\n \t}\n     }\n \n+  if (need_refresh)\n+    update_life_info (refresh_blocks, UPDATE_LIFE_GLOBAL_RM_NOTES);\n+  sbitmap_free (refresh_blocks);\n+\n   total_attempts += combine_attempts;\n   total_merges += combine_merges;\n   total_extras += combine_extras;\n@@ -11858,30 +11872,15 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t      /* We haven't found an insn for the death note and it\n \t\t is still a REG_DEAD note, but we have hit the beginning\n \t\t of the block.  If the existing life info says the reg\n-\t\t was dead, there's nothing left to do.\n-\n-\t\t ??? If the register was live, we ought to mark for later\n-\t\t global life update.  Cop out like the previous code and\n-\t\t just add a hook for the death note to live on.  */\n+\t\t was dead, there's nothing left to do.  Otherwise, we'll\n+\t\t need to do a global life update after combine.  */\n \t      if (REG_NOTE_KIND (note) == REG_DEAD && place == 0)\n \t\t{\n \t\t  int regno = REGNO (XEXP (note, 0));\n-\n \t\t  if (REGNO_REG_SET_P (bb->global_live_at_start, regno))\n \t\t    {\n-\t\t      rtx die = gen_rtx_USE (VOIDmode, XEXP (note, 0));\n-\n-\t\t      place = bb->head;\n-\t\t      if (GET_CODE (place) != CODE_LABEL\n-\t\t\t  && GET_CODE (place) != NOTE)\n-\t\t\t{\n-\t\t\t  place = emit_insn_before (die, place);\n-\t\t\t  bb->head = place;\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  place = emit_insn_after (die, place);\n-\t\t\t}\n+\t\t      SET_BIT (refresh_blocks, this_basic_block);\n+\t\t      need_refresh = 1;\n \t\t    }\n \t\t}\n \t    }"}, {"sha": "3619e28334120cc63880ef75031c2bc6a4c18740", "filename": "gcc/flow.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/715e7fbc831af02e80acc60be2fa19208ab62dfc/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/715e7fbc831af02e80acc60be2fa19208ab62dfc/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=715e7fbc831af02e80acc60be2fa19208ab62dfc", "patch": "@@ -2554,9 +2554,9 @@ verify_local_live_at_start (new_live_at_start, bb)\n    lose the kill.  So we _can_ have a pseudo go live.  How irritating.  */\n \n void\n-update_life_info (blocks, local_only)\n+update_life_info (blocks, extent)\n      sbitmap blocks;\n-     enum update_life_extent local_only;\n+     enum update_life_extent extent;\n {\n   regset tmp;\n   int i;\n@@ -2565,8 +2565,14 @@ update_life_info (blocks, local_only)\n   tmp = ALLOCA_REG_SET ();\n \n   /* For a global update, we go through the relaxation process again.  */\n-  if (! local_only)\n-    calculate_global_regs_live (blocks, blocks, 0);\n+  if (extent != UPDATE_LIFE_LOCAL)\n+    {\n+      calculate_global_regs_live (blocks, blocks, 0);\n+\n+      /* If asked, remove notes from the blocks we'll update.  */\n+      if (extent == UPDATE_LIFE_GLOBAL_RM_NOTES)\n+\tcount_or_remove_death_notes (blocks, 1);\n+    }\n \n   EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n     {\n@@ -2576,7 +2582,7 @@ update_life_info (blocks, local_only)\n       propagate_block (tmp, bb->head, bb->end, (regset) NULL, i,\n \t\t       PROP_DEATH_NOTES);\n \n-      if (local_only)\n+      if (extent == UPDATE_LIFE_LOCAL)\n \tverify_local_live_at_start (tmp, bb);\n \n       CLEAN_ALLOCA;"}]}