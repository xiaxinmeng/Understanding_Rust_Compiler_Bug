{"sha": "d9f21f6acb3aa615834e855e16b6311cd18c5668", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDlmMjFmNmFjYjNhYTYxNTgzNGU4NTVlMTZiNjMxMWNkMThjNTY2OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:14:07Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:14:07Z"}, "message": "poly_int: vectoriser vf and uf\n\nThis patch changes the type of the vectorisation factor and SLP\nunrolling factor to poly_uint64.  This in turn required some knock-on\nchanges in signedness elsewhere.\n\nCost decisions are generally based on estimated_poly_value,\nwhich for VF is wrapped up as vect_vf_for_cost.\n\nThe patch doesn't on its own enable variable-length vectorisation.\nIt just makes the minimum changes necessary for the code to build\nwith the new VF and UF types.  Later patches also make the\nvectoriser cope with variable TYPE_VECTOR_SUBPARTS and variable\nGET_MODE_NUNITS, at which point the code really does handle\nvariable-length vectors.\n\nThe patch also changes MAX_VECTORIZATION_FACTOR to INT_MAX,\nto avoid hard-coding a particular architectural limit.\n\nThe patch includes a new test because a development version of the patch\naccidentally used file print routines instead of dump_*, which would\nfail with -fopt-info.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (_slp_instance::unrolling_factor): Change\n\tfrom an unsigned int to a poly_uint64.\n\t(_loop_vec_info::slp_unrolling_factor): Likewise.\n\t(_loop_vec_info::vectorization_factor): Change from an int\n\tto a poly_uint64.\n\t(MAX_VECTORIZATION_FACTOR): Bump from 64 to INT_MAX.\n\t(vect_get_num_vectors): New function.\n\t(vect_update_max_nunits, vect_vf_for_cost): Likewise.\n\t(vect_get_num_copies): Use vect_get_num_vectors.\n\t(vect_analyze_data_ref_dependences): Change max_vf from an int *\n\tto an unsigned int *.\n\t(vect_analyze_data_refs): Change min_vf from an int * to a\n\tpoly_uint64 *.\n\t(vect_transform_slp_perm_load): Take the vf as a poly_uint64 rather\n\tthan an unsigned HOST_WIDE_INT.\n\t* tree-vect-data-refs.c (vect_analyze_possibly_independent_ddr)\n\t(vect_analyze_data_ref_dependence): Change max_vf from an int *\n\tto an unsigned int *.\n\t(vect_analyze_data_ref_dependences): Likewise.\n\t(vect_compute_data_ref_alignment): Handle polynomial vf.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\t(vect_prune_runtime_alias_test_list): Likewise.\n\t(vect_shift_permute_load_chain): Likewise.\n\t(vect_supportable_dr_alignment): Likewise.\n\t(dependence_distance_ge_vf): Take the vectorization factor as a\n\tpoly_uint64 rather than an unsigned HOST_WIDE_INT.\n\t(vect_analyze_data_refs): Change min_vf from an int * to a\n\tpoly_uint64 *.\n\t* tree-vect-loop-manip.c (vect_gen_scalar_loop_niters): Take\n\tvfm1 as a poly_uint64 rather than an int.  Make the same change\n\tfor the returned bound_scalar.\n\t(vect_gen_vector_loop_niters): Handle polynomial vf.\n\t(vect_do_peeling): Likewise.  Update call to\n\tvect_gen_scalar_loop_niters and handle polynomial bound_scalars.\n\t(vect_gen_vector_loop_niters_mult_vf): Assert that the vf must\n\tbe constant.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor)\n\t(vect_update_vf_for_slp, vect_analyze_loop_2): Handle polynomial vf.\n\t(vect_get_known_peeling_cost): Likewise.\n\t(vect_estimate_min_profitable_iters, vectorizable_reduction): Likewise.\n\t(vect_worthwhile_without_simd_p, vectorizable_induction): Likewise.\n\t(vect_transform_loop): Likewise.  Use the lowest possible VF when\n\tupdating the upper bounds of the loop.\n\t(vect_min_worthwhile_factor): Make static.  Return an unsigned int\n\trather than an int.\n\t* tree-vect-slp.c (vect_attempt_slp_rearrange_stmts): Cope with\n\tpolynomial unroll factors.\n\t(vect_analyze_slp_cost_1, vect_analyze_slp_instance): Likewise.\n\t(vect_make_slp_decision): Likewise.\n\t(vect_supported_load_permutation_p): Likewise, and polynomial\n\tvf too.\n\t(vect_analyze_slp_cost): Handle polynomial vf.\n\t(vect_slp_analyze_node_operations): Likewise.\n\t(vect_slp_analyze_bb_1): Likewise.\n\t(vect_transform_slp_perm_load): Take the vf as a poly_uint64 rather\n\tthan an unsigned HOST_WIDE_INT.\n\t* tree-vect-stmts.c (vectorizable_simd_clone_call, vectorizable_store)\n\t(vectorizable_load): Handle polynomial vf.\n\t* tree-vectorizer.c (simduid_to_vf::vf): Change from an int to\n\ta poly_uint64.\n\t(adjust_simduid_builtins, shrink_simd_arrays): Update accordingly.\n\ngcc/testsuite/\n\t* gcc.dg/vect-opt-info-1.c: New test.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256126", "tree": {"sha": "8200866be9cf8f8f2c40f1a190b6dc611888dd8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8200866be9cf8f8f2c40f1a190b6dc611888dd8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9f21f6acb3aa615834e855e16b6311cd18c5668", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9f21f6acb3aa615834e855e16b6311cd18c5668", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9f21f6acb3aa615834e855e16b6311cd18c5668", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9f21f6acb3aa615834e855e16b6311cd18c5668/comments", "author": null, "committer": null, "parents": [{"sha": "fba05d9e9a0321c812ddbda7b4caa3977e1db4ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba05d9e9a0321c812ddbda7b4caa3977e1db4ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fba05d9e9a0321c812ddbda7b4caa3977e1db4ef"}], "stats": {"total": 665, "additions": 432, "deletions": 233}, "files": [{"sha": "cfe632c4ed6f924fe6336dddf1aa774ba5e8d843", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9f21f6acb3aa615834e855e16b6311cd18c5668", "patch": "@@ -1,3 +1,69 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vectorizer.h (_slp_instance::unrolling_factor): Change\n+\tfrom an unsigned int to a poly_uint64.\n+\t(_loop_vec_info::slp_unrolling_factor): Likewise.\n+\t(_loop_vec_info::vectorization_factor): Change from an int\n+\tto a poly_uint64.\n+\t(MAX_VECTORIZATION_FACTOR): Bump from 64 to INT_MAX.\n+\t(vect_get_num_vectors): New function.\n+\t(vect_update_max_nunits, vect_vf_for_cost): Likewise.\n+\t(vect_get_num_copies): Use vect_get_num_vectors.\n+\t(vect_analyze_data_ref_dependences): Change max_vf from an int *\n+\tto an unsigned int *.\n+\t(vect_analyze_data_refs): Change min_vf from an int * to a\n+\tpoly_uint64 *.\n+\t(vect_transform_slp_perm_load): Take the vf as a poly_uint64 rather\n+\tthan an unsigned HOST_WIDE_INT.\n+\t* tree-vect-data-refs.c (vect_analyze_possibly_independent_ddr)\n+\t(vect_analyze_data_ref_dependence): Change max_vf from an int *\n+\tto an unsigned int *.\n+\t(vect_analyze_data_ref_dependences): Likewise.\n+\t(vect_compute_data_ref_alignment): Handle polynomial vf.\n+\t(vect_enhance_data_refs_alignment): Likewise.\n+\t(vect_prune_runtime_alias_test_list): Likewise.\n+\t(vect_shift_permute_load_chain): Likewise.\n+\t(vect_supportable_dr_alignment): Likewise.\n+\t(dependence_distance_ge_vf): Take the vectorization factor as a\n+\tpoly_uint64 rather than an unsigned HOST_WIDE_INT.\n+\t(vect_analyze_data_refs): Change min_vf from an int * to a\n+\tpoly_uint64 *.\n+\t* tree-vect-loop-manip.c (vect_gen_scalar_loop_niters): Take\n+\tvfm1 as a poly_uint64 rather than an int.  Make the same change\n+\tfor the returned bound_scalar.\n+\t(vect_gen_vector_loop_niters): Handle polynomial vf.\n+\t(vect_do_peeling): Likewise.  Update call to\n+\tvect_gen_scalar_loop_niters and handle polynomial bound_scalars.\n+\t(vect_gen_vector_loop_niters_mult_vf): Assert that the vf must\n+\tbe constant.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor)\n+\t(vect_update_vf_for_slp, vect_analyze_loop_2): Handle polynomial vf.\n+\t(vect_get_known_peeling_cost): Likewise.\n+\t(vect_estimate_min_profitable_iters, vectorizable_reduction): Likewise.\n+\t(vect_worthwhile_without_simd_p, vectorizable_induction): Likewise.\n+\t(vect_transform_loop): Likewise.  Use the lowest possible VF when\n+\tupdating the upper bounds of the loop.\n+\t(vect_min_worthwhile_factor): Make static.  Return an unsigned int\n+\trather than an int.\n+\t* tree-vect-slp.c (vect_attempt_slp_rearrange_stmts): Cope with\n+\tpolynomial unroll factors.\n+\t(vect_analyze_slp_cost_1, vect_analyze_slp_instance): Likewise.\n+\t(vect_make_slp_decision): Likewise.\n+\t(vect_supported_load_permutation_p): Likewise, and polynomial\n+\tvf too.\n+\t(vect_analyze_slp_cost): Handle polynomial vf.\n+\t(vect_slp_analyze_node_operations): Likewise.\n+\t(vect_slp_analyze_bb_1): Likewise.\n+\t(vect_transform_slp_perm_load): Take the vf as a poly_uint64 rather\n+\tthan an unsigned HOST_WIDE_INT.\n+\t* tree-vect-stmts.c (vectorizable_simd_clone_call, vectorizable_store)\n+\t(vectorizable_load): Handle polynomial vf.\n+\t* tree-vectorizer.c (simduid_to_vf::vf): Change from an int to\n+\ta poly_uint64.\n+\t(adjust_simduid_builtins, shrink_simd_arrays): Update accordingly.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "a61567618cce55f634cefff8b8f6ee776355d327", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d9f21f6acb3aa615834e855e16b6311cd18c5668", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.dg/vect-opt-info-1.c: New test.\n+\n 2018-01-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/float128-hw2.c: Add tests for ceilf128,"}, {"sha": "913b0138085ff9f21acbe61cadafcee124a7526a", "filename": "gcc/testsuite/gcc.dg/vect-opt-info-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftestsuite%2Fgcc.dg%2Fvect-opt-info-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftestsuite%2Fgcc.dg%2Fvect-opt-info-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect-opt-info-1.c?ref=d9f21f6acb3aa615834e855e16b6311cd18c5668", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-options \"-std=c99 -fopt-info -O3\" } */\n+\n+void\n+vadd (int *dst, int *op1, int *op2, int count)\n+{\n+  for (int i = 0; i < count; ++i)\n+    dst[i] = op1[i] + op2[i];\n+}\n+\n+/* { dg-message \"loop vectorized\" \"\" { target *-*-* } 6 } */\n+/* { dg-message \"loop versioned for vectorization because of possible aliasing\" \"\" { target *-*-* } 6 } */"}, {"sha": "02a32950ee34fc12a42a0c7b759c06a3555b6cf8", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 48, "deletions": 41, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=d9f21f6acb3aa615834e855e16b6311cd18c5668", "patch": "@@ -180,7 +180,7 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n static bool\n vect_analyze_possibly_independent_ddr (data_dependence_relation *ddr,\n \t\t\t\t       loop_vec_info loop_vinfo,\n-\t\t\t\t       int loop_depth, int *max_vf)\n+\t\t\t\t       int loop_depth, unsigned int *max_vf)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   lambda_vector dist_v;\n@@ -200,7 +200,7 @@ vect_analyze_possibly_independent_ddr (data_dependence_relation *ddr,\n \t     would be a win.  */\n \t  if (loop->safelen >= 2 && abs_hwi (dist) <= loop->safelen)\n \t    {\n-\t      if (loop->safelen < *max_vf)\n+\t      if ((unsigned int) loop->safelen < *max_vf)\n \t\t*max_vf = loop->safelen;\n \t      LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo) = false;\n \t      continue;\n@@ -229,7 +229,8 @@ vect_analyze_possibly_independent_ddr (data_dependence_relation *ddr,\n \n static bool\n vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n-                                  loop_vec_info loop_vinfo, int *max_vf)\n+\t\t\t\t  loop_vec_info loop_vinfo,\n+\t\t\t\t  unsigned int *max_vf)\n {\n   unsigned int i;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -278,7 +279,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t executed concurrently, assume independence.  */\n       if (loop->safelen >= 2)\n \t{\n-\t  if (loop->safelen < *max_vf)\n+\t  if ((unsigned int) loop->safelen < *max_vf)\n \t    *max_vf = loop->safelen;\n \t  LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo) = false;\n \t  return false;\n@@ -326,7 +327,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t executed concurrently, assume independence.  */\n       if (loop->safelen >= 2)\n \t{\n-\t  if (loop->safelen < *max_vf)\n+\t  if ((unsigned int) loop->safelen < *max_vf)\n \t    *max_vf = loop->safelen;\n \t  LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo) = false;\n \t  return false;\n@@ -446,8 +447,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  continue;\n \t}\n \n-      if (abs (dist) >= 2\n-\t  && abs (dist) < *max_vf)\n+      unsigned int abs_dist = abs (dist);\n+      if (abs_dist >= 2 && abs_dist < *max_vf)\n \t{\n \t  /* The dependence distance requires reduction of the maximal\n \t     vectorization factor.  */\n@@ -458,7 +459,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t                     *max_vf);\n \t}\n \n-      if (abs (dist) >= *max_vf)\n+      if (abs_dist >= *max_vf)\n \t{\n \t  /* Dependence distance does not create dependence, as far as\n \t     vectorization is concerned, in this case.  */\n@@ -492,7 +493,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n    the maximum vectorization factor the data dependences allow.  */\n \n bool\n-vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo, int *max_vf)\n+vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n+\t\t\t\t   unsigned int *max_vf)\n {\n   unsigned int i;\n   struct data_dependence_relation *ddr;\n@@ -863,9 +865,9 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n      the dataref evenly divides by the alignment.  */\n   else\n     {\n-      unsigned vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+      poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       step_preserves_misalignment_p\n-\t= ((DR_STEP_ALIGNMENT (dr) * vf) % vector_alignment) == 0;\n+\t= multiple_p (DR_STEP_ALIGNMENT (dr) * vf, vector_alignment);\n \n       if (!step_preserves_misalignment_p && dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1611,10 +1613,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   bool one_misalignment_unknown = false;\n   bool one_dr_unsupportable = false;\n   struct data_reference *unsupportable_dr = NULL;\n-  unsigned int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   unsigned possible_npeel_number = 1;\n   tree vectype;\n-  unsigned int nelements, mis, same_align_drs_max = 0;\n+  unsigned int mis, same_align_drs_max = 0;\n   hash_table<peel_info_hasher> peeling_htab (1);\n \n   if (dump_enabled_p ())\n@@ -1692,7 +1694,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t\t\t\t\t    size_zero_node) < 0;\n \n \t      vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\t      nelements = TYPE_VECTOR_SUBPARTS (vectype);\n \t      unsigned int target_align = DR_TARGET_ALIGNMENT (dr);\n \t      unsigned int dr_size = vect_get_scalar_dr_size (dr);\n \t      mis = (negative ? DR_MISALIGNMENT (dr) : -DR_MISALIGNMENT (dr));\n@@ -1714,11 +1715,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t cost for every peeling option.  */\n               if (unlimited_cost_model (LOOP_VINFO_LOOP (loop_vinfo)))\n \t\t{\n-\t\t  if (STMT_SLP_TYPE (stmt_info))\n-\t\t    possible_npeel_number\n-\t\t      = (vf * GROUP_SIZE (stmt_info)) / nelements;\n-\t\t  else\n-\t\t    possible_npeel_number = vf / nelements;\n+\t\t  poly_uint64 nscalars = (STMT_SLP_TYPE (stmt_info)\n+\t\t\t\t\t  ? vf * GROUP_SIZE (stmt_info) : vf);\n+\t\t  possible_npeel_number\n+\t\t    = vect_get_num_vectors (nscalars, vectype);\n \n \t\t  /* NPEEL_TMP is 0 when there is no misalignment, but also\n \t\t     allow peeling NELEMENTS.  */\n@@ -1817,13 +1817,14 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       unsigned int load_outside_cost = 0;\n       unsigned int store_inside_cost = 0;\n       unsigned int store_outside_cost = 0;\n+      unsigned int estimated_npeels = vect_vf_for_cost (loop_vinfo) / 2;\n \n       stmt_vector_for_cost dummy;\n       dummy.create (2);\n       vect_get_peeling_costs_all_drs (datarefs, dr0,\n \t\t\t\t      &load_inside_cost,\n \t\t\t\t      &load_outside_cost,\n-\t\t\t\t      &dummy, vf / 2, true);\n+\t\t\t\t      &dummy, estimated_npeels, true);\n       dummy.release ();\n \n       if (first_store)\n@@ -1832,7 +1833,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  vect_get_peeling_costs_all_drs (datarefs, first_store,\n \t\t\t\t\t  &store_inside_cost,\n \t\t\t\t\t  &store_outside_cost,\n-\t\t\t\t\t  &dummy, vf / 2, true);\n+\t\t\t\t\t  &dummy, estimated_npeels, true);\n \t  dummy.release ();\n \t}\n       else\n@@ -1861,7 +1862,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       int dummy2;\n       peel_for_unknown_alignment.outside_cost += vect_get_known_peeling_cost\n-\t(loop_vinfo, vf / 2, &dummy2,\n+\t(loop_vinfo, estimated_npeels, &dummy2,\n \t &LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n \t &prologue_cost_vec, &epilogue_cost_vec);\n \n@@ -2021,14 +2022,16 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         }\n \n       /* Cost model #2 - if peeling may result in a remaining loop not\n-\t iterating enough to be vectorized then do not peel.  */\n+\t iterating enough to be vectorized then do not peel.  Since this\n+\t is a cost heuristic rather than a correctness decision, use the\n+\t most likely runtime value for variable vectorization factors.  */\n       if (do_peeling\n \t  && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n \t{\n-\t  unsigned max_peel\n-\t    = npeel == 0 ? LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1 : npeel;\n-\t  if (LOOP_VINFO_INT_NITERS (loop_vinfo)\n-\t      < LOOP_VINFO_VECT_FACTOR (loop_vinfo) + max_peel)\n+\t  unsigned int assumed_vf = vect_vf_for_cost (loop_vinfo);\n+\t  unsigned int max_peel = npeel == 0 ? assumed_vf - 1 : npeel;\n+\t  if ((unsigned HOST_WIDE_INT) LOOP_VINFO_INT_NITERS (loop_vinfo)\n+\t      < assumed_vf + max_peel)\n \t    do_peeling = false;\n \t}\n \n@@ -3050,7 +3053,7 @@ vect_no_alias_p (struct data_reference *a, struct data_reference *b,\n \n static bool\n dependence_distance_ge_vf (data_dependence_relation *ddr,\n-\t\t\t   unsigned int loop_depth, unsigned HOST_WIDE_INT vf)\n+\t\t\t   unsigned int loop_depth, poly_uint64 vf)\n {\n   if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE\n       || DDR_NUM_DIST_VECTS (ddr) == 0)\n@@ -3066,7 +3069,7 @@ dependence_distance_ge_vf (data_dependence_relation *ddr,\n       HOST_WIDE_INT dist = dist_v[loop_depth];\n       if (dist != 0\n \t  && !(dist > 0 && DDR_REVERSED_P (ddr))\n-\t  && (unsigned HOST_WIDE_INT) abs_hwi (dist) < vf)\n+\t  && maybe_lt ((unsigned HOST_WIDE_INT) abs_hwi (dist), vf))\n \treturn false;\n     }\n \n@@ -3101,7 +3104,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n     = LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo);\n   vec<vec_object_pair> &check_unequal_addrs\n     = LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo);\n-  int vect_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  poly_uint64 vect_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   tree scalar_loop_iters = LOOP_VINFO_NITERS (loop_vinfo);\n \n   ddr_p ddr;\n@@ -3212,8 +3215,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n       comp_alias_ddrs.safe_push (dr_with_seg_len_pair);\n     }\n \n-  prune_runtime_alias_test_list (&comp_alias_ddrs,\n-\t\t\t\t (unsigned HOST_WIDE_INT) vect_factor);\n+  prune_runtime_alias_test_list (&comp_alias_ddrs, vect_factor);\n \n   unsigned int count = (comp_alias_ddrs.length ()\n \t\t\t+ check_unequal_addrs.length ());\n@@ -3465,7 +3467,7 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n */\n \n bool\n-vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n+vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n {\n   struct loop *loop = NULL;\n   unsigned int i;\n@@ -3490,7 +3492,7 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n       tree base, offset, init;\n       enum { SG_NONE, GATHER, SCATTER } gatherscatter = SG_NONE;\n       bool simd_lane_access = false;\n-      int vf;\n+      poly_uint64 vf;\n \n again:\n       if (!dr || !DR_REF (dr))\n@@ -3874,8 +3876,7 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n       /* Adjust the minimal vectorization factor according to the\n \t vector type.  */\n       vf = TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n-      if (vf > *min_vf)\n-\t*min_vf = vf;\n+      *min_vf = upper_bound (*min_vf, vf);\n \n       if (gatherscatter != SG_NONE)\n \t{\n@@ -5556,14 +5557,19 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n \n+  unsigned HOST_WIDE_INT vf;\n+  if (!LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&vf))\n+    /* Not supported for variable-length vectors.  */\n+    return false;\n+\n   vec_perm_builder sel (nelt, nelt, 1);\n   sel.quick_grow (nelt);\n \n   result_chain->quick_grow (length);\n   memcpy (result_chain->address (), dr_chain.address (),\n \t  length * sizeof (tree));\n \n-  if (pow2p_hwi (length) && LOOP_VINFO_VECT_FACTOR (loop_vinfo) > 4)\n+  if (pow2p_hwi (length) && vf > 4)\n     {\n       unsigned int j, log_length = exact_log2 (length);\n       for (i = 0; i < nelt / 2; ++i)\n@@ -5664,7 +5670,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t}\n       return true;\n     }\n-  if (length == 3 && LOOP_VINFO_VECT_FACTOR (loop_vinfo) > 2)\n+  if (length == 3 && vf > 2)\n     {\n       unsigned int k = 0, l = 0;\n \n@@ -6037,9 +6043,10 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n \t     same alignment, instead it depends on the SLP group size.  */\n \t  if (loop_vinfo\n \t      && STMT_SLP_TYPE (stmt_info)\n-\t      && (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t\t  * GROUP_SIZE (vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info)))\n-\t\t  % TYPE_VECTOR_SUBPARTS (vectype) != 0))\n+\t      && !multiple_p (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t\t\t      * GROUP_SIZE (vinfo_for_stmt\n+\t\t\t\t\t    (GROUP_FIRST_ELEMENT (stmt_info))),\n+\t\t\t      TYPE_VECTOR_SUBPARTS (vectype)))\n \t    ;\n \t  else if (!loop_vinfo\n \t\t   || (nested_in_vect_loop"}, {"sha": "c8ee22985368e6825f13792f40697434985b3f4c", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 45, "deletions": 29, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=d9f21f6acb3aa615834e855e16b6311cd18c5668", "patch": "@@ -1234,8 +1234,9 @@ vect_build_loop_niters (loop_vec_info loop_vinfo, bool *new_var_p)\n \n static tree\n vect_gen_scalar_loop_niters (tree niters_prolog, int int_niters_prolog,\n-\t\t\t     int bound_prolog, int vfm1, int th,\n-\t\t\t     int *bound_scalar, bool check_profitability)\n+\t\t\t     int bound_prolog, poly_int64 vfm1, int th,\n+\t\t\t     poly_uint64 *bound_scalar,\n+\t\t\t     bool check_profitability)\n {\n   tree type = TREE_TYPE (niters_prolog);\n   tree niters = fold_build2 (PLUS_EXPR, type, niters_prolog,\n@@ -1250,21 +1251,23 @@ vect_gen_scalar_loop_niters (tree niters_prolog, int int_niters_prolog,\n       /* Peeling for constant times.  */\n       if (int_niters_prolog >= 0)\n \t{\n-\t  *bound_scalar = (int_niters_prolog + vfm1 < th\n-\t\t\t    ? th\n-\t\t\t    : vfm1 + int_niters_prolog);\n+\t  *bound_scalar = upper_bound (int_niters_prolog + vfm1, th);\n \t  return build_int_cst (type, *bound_scalar);\n \t}\n       /* Peeling for unknown times.  Note BOUND_PROLOG is the upper\n \t bound (inlcuded) of niters of prolog loop.  */\n-      if (th >=  vfm1 + bound_prolog)\n+      if (known_ge (th, vfm1 + bound_prolog))\n \t{\n \t  *bound_scalar = th;\n \t  return build_int_cst (type, th);\n \t}\n-      /* Need to do runtime comparison, but BOUND_SCALAR remains the same.  */\n-      else if (th > vfm1)\n-\treturn fold_build2 (MAX_EXPR, type, build_int_cst (type, th), niters);\n+      /* Need to do runtime comparison.  */\n+      else if (maybe_gt (th, vfm1))\n+\t{\n+\t  *bound_scalar = upper_bound (*bound_scalar, th);\n+\t  return fold_build2 (MAX_EXPR, type,\n+\t\t\t      build_int_cst (type, th), niters);\n+\t}\n     }\n   return niters;\n }\n@@ -1292,7 +1295,7 @@ vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,\n {\n   tree ni_minus_gap, var;\n   tree niters_vector, step_vector, type = TREE_TYPE (niters);\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n   tree log_vf = NULL_TREE;\n \n@@ -1315,14 +1318,15 @@ vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,\n   else\n     ni_minus_gap = niters;\n \n-  if (1)\n+  unsigned HOST_WIDE_INT const_vf;\n+  if (vf.is_constant (&const_vf))\n     {\n       /* Create: niters >> log2(vf) */\n       /* If it's known that niters == number of latch executions + 1 doesn't\n \t overflow, we can generate niters >> log2(vf); otherwise we generate\n \t (niters - vf) >> log2(vf) + 1 by using the fact that we know ratio\n \t will be at least one.  */\n-      log_vf = build_int_cst (type, exact_log2 (vf));\n+      log_vf = build_int_cst (type, exact_log2 (const_vf));\n       if (niters_no_overflow)\n \tniters_vector = fold_build2 (RSHIFT_EXPR, type, ni_minus_gap, log_vf);\n       else\n@@ -1373,7 +1377,8 @@ vect_gen_vector_loop_niters_mult_vf (loop_vec_info loop_vinfo,\n \t\t\t\t     tree niters_vector,\n \t\t\t\t     tree *niters_vector_mult_vf_ptr)\n {\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  /* We should be using a step_vector of VF if VF is variable.  */\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo).to_constant ();\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree type = TREE_TYPE (niters_vector);\n   tree log_vf = build_int_cst (type, exact_log2 (vf));\n@@ -1790,8 +1795,9 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   tree type = TREE_TYPE (niters), guard_cond;\n   basic_block guard_bb, guard_to;\n   profile_probability prob_prolog, prob_vector, prob_epilog;\n-  int bound_prolog = 0, bound_scalar = 0, bound = 0;\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  int bound_prolog = 0;\n+  poly_uint64 bound_scalar = 0;\n+  int estimated_vf;\n   int prolog_peeling = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n   bool epilog_peeling = (LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo)\n \t\t\t || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo));\n@@ -1800,11 +1806,12 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n     return NULL;\n \n   prob_vector = profile_probability::guessed_always ().apply_scale (9, 10);\n-  if ((vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo)) == 2)\n-    vf = 3;\n+  estimated_vf = vect_vf_for_cost (loop_vinfo);\n+  if (estimated_vf == 2)\n+    estimated_vf = 3;\n   prob_prolog = prob_epilog = profile_probability::guessed_always ()\n-\t\t\t.apply_scale (vf - 1, vf);\n-  vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\t\t\t.apply_scale (estimated_vf - 1, estimated_vf);\n+  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n   struct loop *prolog, *epilog = NULL, *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct loop *first_loop = loop;\n@@ -1824,13 +1831,15 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   /* Skip to epilog if scalar loop may be preferred.  It's only needed\n      when we peel for epilog loop and when it hasn't been checked with\n      loop versioning.  */\n-  bool skip_vector = (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t\t      && !LOOP_REQUIRES_VERSIONING (loop_vinfo));\n+  bool skip_vector = ((!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+\t\t       && !LOOP_REQUIRES_VERSIONING (loop_vinfo))\n+\t\t      || !vf.is_constant ());\n   /* Epilog loop must be executed if the number of iterations for epilog\n      loop is known at compile time, otherwise we need to add a check at\n      the end of vector loop and skip to the end of epilog loop.  */\n   bool skip_epilog = (prolog_peeling < 0\n-\t\t      || !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo));\n+\t\t      || !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+\t\t      || !vf.is_constant ());\n   /* PEELING_FOR_GAPS is special because epilog loop must be executed.  */\n   if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n     skip_epilog = false;\n@@ -1849,8 +1858,10 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t needs to be scaled back later.  */\n       basic_block bb_before_loop = loop_preheader_edge (loop)->src;\n       if (prob_vector.initialized_p ())\n-      scale_bbs_frequencies (&bb_before_loop, 1, prob_vector);\n-      scale_loop_profile (loop, prob_vector, bound);\n+\t{\n+\t  scale_bbs_frequencies (&bb_before_loop, 1, prob_vector);\n+\t  scale_loop_profile (loop, prob_vector, 0);\n+\t}\n     }\n \n   tree niters_prolog = build_int_cst (type, 0);\n@@ -2036,15 +2047,20 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \n \t      scale_bbs_frequencies (&bb_before_epilog, 1, prob_epilog);\n \t    }\n-\t  scale_loop_profile (epilog, prob_epilog, bound);\n+\t  scale_loop_profile (epilog, prob_epilog, 0);\n \t}\n       else\n \tslpeel_update_phi_nodes_for_lcssa (epilog);\n \n-      bound = LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) ? vf - 1 : vf - 2;\n-      /* We share epilog loop with scalar version loop.  */\n-      bound = MAX (bound, bound_scalar - 1);\n-      record_niter_bound (epilog, bound, false, true);\n+      unsigned HOST_WIDE_INT bound1, bound2;\n+      if (vf.is_constant (&bound1) && bound_scalar.is_constant (&bound2))\n+\t{\n+\t  bound1 -= LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) ? 1 : 2;\n+\t  if (bound2)\n+\t    /* We share epilog loop with scalar version loop.  */\n+\t    bound1 = MAX (bound1, bound2 - 1);\n+\t  record_niter_bound (epilog, bound1, false, true);\n+\t}\n \n       delete_update_ssa ();\n       adjust_vec_debug_stmts ();"}, {"sha": "4c5729796ef583b793763863e27d2d74760fce03", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 124, "deletions": 99, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=d9f21f6acb3aa615834e855e16b6311cd18c5668", "patch": "@@ -185,11 +185,10 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   unsigned nbbs = loop->num_nodes;\n-  unsigned int vectorization_factor = 0;\n+  poly_uint64 vectorization_factor = 1;\n   tree scalar_type = NULL_TREE;\n   gphi *phi;\n   tree vectype;\n-  unsigned int nunits;\n   stmt_vec_info stmt_info;\n   unsigned i;\n   HOST_WIDE_INT dummy;\n@@ -258,14 +257,12 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                   dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n \n-\t      nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, vect_location, \"nunits = %d\\n\",\n-                                 nunits);\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"nunits = \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t\t\t TYPE_VECTOR_SUBPARTS (vectype));\n \n-\t      if (!vectorization_factor\n-\t\t  || (nunits > vectorization_factor))\n-\t\tvectorization_factor = nunits;\n+\t      vect_update_max_nunits (&vectorization_factor, vectype);\n \t    }\n \t}\n \n@@ -553,12 +550,12 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n               dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n-\t  nunits = TYPE_VECTOR_SUBPARTS (vf_vectype);\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location, \"nunits = %d\\n\", nunits);\n-\t  if (!vectorization_factor\n-\t      || (nunits > vectorization_factor))\n-\t    vectorization_factor = nunits;\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"nunits = \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t\t     TYPE_VECTOR_SUBPARTS (vf_vectype));\n+\n+\t  vect_update_max_nunits (&vectorization_factor, vf_vectype);\n \n \t  if (!analyze_pattern_stmt && gsi_end_p (pattern_def_si))\n \t    {\n@@ -570,9 +567,13 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n   /* TODO: Analyze cost. Decide if worth while to vectorize.  */\n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"vectorization factor = %d\\n\",\n-                     vectorization_factor);\n-  if (vectorization_factor <= 1)\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"vectorization factor = \");\n+      dump_dec (MSG_NOTE, vectorization_factor);\n+      dump_printf (MSG_NOTE, \"\\n\");\n+    }\n+\n+  if (known_le (vectorization_factor, 1U))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1564,15 +1565,15 @@ vect_update_vf_for_slp (loop_vec_info loop_vinfo)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n-  unsigned int vectorization_factor;\n+  poly_uint64 vectorization_factor;\n   int i;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== vect_update_vf_for_slp ===\\n\");\n \n   vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  gcc_assert (vectorization_factor != 0);\n+  gcc_assert (known_ne (vectorization_factor, 0U));\n \n   /* If all the stmts in the loop can be SLPed, we perform only SLP, and\n      vectorization factor of the loop is the unrolling factor required by\n@@ -1612,16 +1613,22 @@ vect_update_vf_for_slp (loop_vec_info loop_vinfo)\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t       \"Loop contains SLP and non-SLP stmts\\n\");\n+      /* Both the vectorization factor and unroll factor have the form\n+\t current_vector_size * X for some rational X, so they must have\n+\t a common multiple.  */\n       vectorization_factor\n-\t= least_common_multiple (vectorization_factor,\n+\t= force_common_multiple (vectorization_factor,\n \t\t\t\t LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n     }\n \n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"Updating vectorization factor to %d\\n\",\n-\t\t     vectorization_factor);\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"Updating vectorization factor to \");\n+      dump_dec (MSG_NOTE, vectorization_factor);\n+      dump_printf (MSG_NOTE, \".\\n\");\n+    }\n }\n \n /* Function vect_analyze_loop_operations.\n@@ -1792,8 +1799,8 @@ static bool\n vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n {\n   bool ok;\n-  int max_vf = MAX_VECTORIZATION_FACTOR;\n-  int min_vf = 2;\n+  unsigned int max_vf = MAX_VECTORIZATION_FACTOR;\n+  poly_uint64 min_vf = 2;\n   unsigned int n_stmts = 0;\n \n   /* The first group of checks is independent of the vector size.  */\n@@ -1918,7 +1925,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \n   ok = vect_analyze_data_ref_dependences (loop_vinfo, &max_vf);\n   if (!ok\n-      || max_vf < min_vf)\n+      || (max_vf != MAX_VECTORIZATION_FACTOR\n+\t  && maybe_lt (max_vf, min_vf)))\n     {\n       if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1935,7 +1943,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \t\t\t \"can't determine vectorization factor.\\n\");\n       return false;\n     }\n-  if (max_vf < LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n+  if (max_vf != MAX_VECTORIZATION_FACTOR\n+      && maybe_lt (max_vf, LOOP_VINFO_VECT_FACTOR (loop_vinfo)))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1946,7 +1955,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n   /* Compute the scalar iteration cost.  */\n   vect_compute_single_scalar_iteration_cost (loop_vinfo);\n \n-  int saved_vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  poly_uint64 saved_vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   HOST_WIDE_INT estimated_niter;\n   unsigned th;\n   int min_scalar_loop_bound;\n@@ -1971,21 +1980,25 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n start_over:\n \n   /* Now the vectorization factor is final.  */\n-  unsigned vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  gcc_assert (vectorization_factor != 0);\n+  poly_uint64 vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  gcc_assert (known_ne (vectorization_factor, 0U));\n+  unsigned int assumed_vf = vect_vf_for_cost (loop_vinfo);\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"vectorization_factor = %d, niters = \"\n-\t\t     HOST_WIDE_INT_PRINT_DEC \"\\n\", vectorization_factor,\n-\t\t     LOOP_VINFO_INT_NITERS (loop_vinfo));\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"vectorization_factor = \");\n+      dump_dec (MSG_NOTE, vectorization_factor);\n+      dump_printf (MSG_NOTE, \", niters = \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t   LOOP_VINFO_INT_NITERS (loop_vinfo));\n+    }\n \n   HOST_WIDE_INT max_niter\n     = likely_max_stmt_executions_int (LOOP_VINFO_LOOP (loop_vinfo));\n   if ((LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-       && (LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor))\n+       && (LOOP_VINFO_INT_NITERS (loop_vinfo) < assumed_vf))\n       || (max_niter != -1\n-\t  && (unsigned HOST_WIDE_INT) max_niter < vectorization_factor))\n+\t  && (unsigned HOST_WIDE_INT) max_niter < assumed_vf))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2057,10 +2070,10 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n   if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n       && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n-      int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+      poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       tree scalar_niters = LOOP_VINFO_NITERSM1 (loop_vinfo);\n \n-      if (wi::to_widest (scalar_niters) < vf)\n+      if (known_lt (wi::to_widest (scalar_niters), vf))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2088,7 +2101,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n     }\n \n   min_scalar_loop_bound = (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n-\t\t\t   * vectorization_factor);\n+\t\t\t   * assumed_vf);\n \n   /* Use the cost model only if it is more conservative than user specified\n      threshold.  */\n@@ -2133,26 +2146,27 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \n   /* Decide whether we need to create an epilogue loop to handle\n      remaining scalar iterations.  */\n-  th = ((LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo)\n-\t / LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n-\t* LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+  th = LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo);\n \n+  unsigned HOST_WIDE_INT const_vf;\n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n     {\n-      if (ctz_hwi (LOOP_VINFO_INT_NITERS (loop_vinfo)\n-\t\t   - LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo))\n-\t  < exact_log2 (LOOP_VINFO_VECT_FACTOR (loop_vinfo)))\n+      if (!multiple_p (LOOP_VINFO_INT_NITERS (loop_vinfo)\n+\t\t       - LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo),\n+\t\t       LOOP_VINFO_VECT_FACTOR (loop_vinfo)))\n \tLOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = true;\n     }\n   else if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo)\n-\t   || (tree_ctz (LOOP_VINFO_NITERS (loop_vinfo))\n-\t       < (unsigned)exact_log2 (LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n-               /* In case of versioning, check if the maximum number of\n-                  iterations is greater than th.  If they are identical,\n-                  the epilogue is unnecessary.  */\n+\t   || !LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&const_vf)\n+\t   || ((tree_ctz (LOOP_VINFO_NITERS (loop_vinfo))\n+\t\t< (unsigned) exact_log2 (const_vf))\n+\t       /* In case of versioning, check if the maximum number of\n+\t\t  iterations is greater than th.  If they are identical,\n+\t\t  the epilogue is unnecessary.  */\n \t       && (!LOOP_REQUIRES_VERSIONING (loop_vinfo)\n-                   || (unsigned HOST_WIDE_INT) max_niter > th)))\n+\t\t   || ((unsigned HOST_WIDE_INT) max_niter\n+\t\t       > (th / const_vf) * const_vf))))\n     LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = true;\n \n   /* If an epilogue loop is required make sure we can create one.  */\n@@ -2201,8 +2215,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       LOOP_VINFO_VERSIONING_THRESHOLD (loop_vinfo) = niters_th;\n     }\n \n-  gcc_assert (vectorization_factor\n-\t      == (unsigned)LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+  gcc_assert (known_eq (vectorization_factor,\n+\t\t\tLOOP_VINFO_VECT_FACTOR (loop_vinfo)));\n \n   /* Ok to vectorize!  */\n   return true;\n@@ -3283,11 +3297,11 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n \t\t\t     stmt_vector_for_cost *epilogue_cost_vec)\n {\n   int retval = 0;\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  int assumed_vf = vect_vf_for_cost (loop_vinfo);\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n-      *peel_iters_epilogue = vf/2;\n+      *peel_iters_epilogue = assumed_vf / 2;\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"cost model: epilogue peel iters set to vf/2 \"\n@@ -3305,11 +3319,11 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n       int niters = LOOP_VINFO_INT_NITERS (loop_vinfo);\n       peel_iters_prologue = niters < peel_iters_prologue ?\n                             niters : peel_iters_prologue;\n-      *peel_iters_epilogue = (niters - peel_iters_prologue) % vf;\n+      *peel_iters_epilogue = (niters - peel_iters_prologue) % assumed_vf;\n       /* If we need to peel for gaps, but no peeling is required, we have to\n \t peel VF iterations.  */\n       if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) && !*peel_iters_epilogue)\n-        *peel_iters_epilogue = vf;\n+\t*peel_iters_epilogue = assumed_vf;\n     }\n \n   stmt_info_for_cost *si;\n@@ -3367,7 +3381,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   unsigned vec_epilogue_cost = 0;\n   int scalar_single_iter_cost = 0;\n   int scalar_outside_cost = 0;\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  int assumed_vf = vect_vf_for_cost (loop_vinfo);\n   int npeel = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n   void *target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n \n@@ -3446,13 +3460,13 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \n   if (npeel  < 0)\n     {\n-      peel_iters_prologue = vf/2;\n+      peel_iters_prologue = assumed_vf / 2;\n       dump_printf (MSG_NOTE, \"cost model: \"\n                    \"prologue peel iters set to vf/2.\\n\");\n \n       /* If peeling for alignment is unknown, loop bound of main loop becomes\n          unknown.  */\n-      peel_iters_epilogue = vf/2;\n+      peel_iters_epilogue = assumed_vf / 2;\n       dump_printf (MSG_NOTE, \"cost model: \"\n                    \"epilogue peel iters set to vf/2 because \"\n                    \"peeling for alignment is unknown.\\n\");\n@@ -3631,22 +3645,24 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n      PL_ITERS = prologue iterations, EP_ITERS= epilogue iterations\n      SOC = scalar outside cost for run time cost model check.  */\n \n-  if ((scalar_single_iter_cost * vf) > (int) vec_inside_cost)\n+  if ((scalar_single_iter_cost * assumed_vf) > (int) vec_inside_cost)\n     {\n       if (vec_outside_cost <= 0)\n         min_profitable_iters = 0;\n       else\n         {\n-          min_profitable_iters = ((vec_outside_cost - scalar_outside_cost) * vf\n+\t  min_profitable_iters = ((vec_outside_cost - scalar_outside_cost)\n+\t\t\t\t  * assumed_vf\n \t\t\t\t  - vec_inside_cost * peel_iters_prologue\n-                                  - vec_inside_cost * peel_iters_epilogue)\n-                                 / ((scalar_single_iter_cost * vf)\n-                                    - vec_inside_cost);\n-\n-          if ((scalar_single_iter_cost * vf * min_profitable_iters)\n-              <= (((int) vec_inside_cost * min_profitable_iters)\n-                  + (((int) vec_outside_cost - scalar_outside_cost) * vf)))\n-            min_profitable_iters++;\n+\t\t\t\t  - vec_inside_cost * peel_iters_epilogue)\n+\t\t\t\t / ((scalar_single_iter_cost * assumed_vf)\n+\t\t\t\t    - vec_inside_cost);\n+\n+\t  if ((scalar_single_iter_cost * assumed_vf * min_profitable_iters)\n+\t      <= (((int) vec_inside_cost * min_profitable_iters)\n+\t\t  + (((int) vec_outside_cost - scalar_outside_cost)\n+\t\t     * assumed_vf)))\n+\t    min_profitable_iters++;\n         }\n     }\n   /* vector version will never be profitable.  */\n@@ -3662,7 +3678,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t\t\t \"divided by the scalar iteration cost = %d \"\n \t\t\t \"is greater or equal to the vectorization factor = %d\"\n                          \".\\n\",\n-\t\t\t vec_inside_cost, scalar_single_iter_cost, vf);\n+\t\t\t vec_inside_cost, scalar_single_iter_cost, assumed_vf);\n       *ret_min_profitable_niters = -1;\n       *ret_min_profitable_estimate = -1;\n       return;\n@@ -3673,8 +3689,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t       min_profitable_iters);\n \n   /* We want the vectorized loop to execute at least once.  */\n-  if (min_profitable_iters < (vf + peel_iters_prologue))\n-    min_profitable_iters = vf + peel_iters_prologue;\n+  if (min_profitable_iters < (assumed_vf + peel_iters_prologue))\n+    min_profitable_iters = assumed_vf + peel_iters_prologue;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -3694,10 +3710,11 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n     min_profitable_estimate = 0;\n   else\n     {\n-      min_profitable_estimate = ((vec_outside_cost + scalar_outside_cost) * vf\n+      min_profitable_estimate = ((vec_outside_cost + scalar_outside_cost)\n+\t\t\t\t * assumed_vf\n \t\t\t\t - vec_inside_cost * peel_iters_prologue\n \t\t\t\t - vec_inside_cost * peel_iters_epilogue)\n-\t\t\t\t / ((scalar_single_iter_cost * vf)\n+\t\t\t\t / ((scalar_single_iter_cost * assumed_vf)\n \t\t\t\t   - vec_inside_cost);\n     }\n   min_profitable_estimate = MAX (min_profitable_estimate, min_profitable_iters);\n@@ -5742,9 +5759,10 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n       if (slp_node)\n \t/* The size vect_schedule_slp_instance computes is off for us.  */\n-\tvec_num = ((LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t\t    * SLP_TREE_SCALAR_STMTS (slp_node).length ())\n-\t\t   / TYPE_VECTOR_SUBPARTS (vectype_in));\n+\tvec_num = vect_get_num_vectors\n+\t  (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t   * SLP_TREE_SCALAR_STMTS (slp_node).length (),\n+\t   vectype_in);\n       else\n \tvec_num = 1;\n \n@@ -6540,7 +6558,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n    For a loop where we could vectorize the operation indicated by CODE,\n    return the minimum vectorization factor that makes it worthwhile\n    to use generic vectors.  */\n-int\n+static unsigned int\n vect_min_worthwhile_factor (enum tree_code code)\n {\n   switch (code)\n@@ -6569,9 +6587,10 @@ bool\n vect_worthwhile_without_simd_p (vec_info *vinfo, tree_code code)\n {\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n+  unsigned HOST_WIDE_INT value;\n   return (loop_vinfo\n-\t  && (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t      >= vect_min_worthwhile_factor (code)));\n+\t  && LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&value)\n+\t  && value >= vect_min_worthwhile_factor (code));\n }\n \n /* Function vectorizable_induction\n@@ -6601,7 +6620,7 @@ vectorizable_induction (gimple *phi,\n   gphi *induction_phi;\n   tree induc_def, vec_dest;\n   tree init_expr, step_expr;\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   unsigned i;\n   tree expr;\n   gimple_seq stmts;\n@@ -7337,26 +7356,27 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   tree niters_vector = NULL_TREE;\n   tree step_vector = NULL_TREE;\n   tree niters_vector_mult_vf = NULL_TREE;\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  unsigned int lowest_vf = constant_lower_bound (vf);\n   bool grouped_store;\n   bool slp_scheduled = false;\n   gimple *stmt, *pattern_stmt;\n   gimple_seq pattern_def_seq = NULL;\n   gimple_stmt_iterator pattern_def_si = gsi_none ();\n   bool transform_pattern_stmt = false;\n   bool check_profitability = false;\n-  int th;\n+  unsigned int th;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"=== vec_transform_loop ===\\n\");\n \n   /* Use the more conservative vectorization threshold.  If the number\n      of iterations is constant assume the cost check has been performed\n      by our caller.  If the threshold makes all loops profitable that\n-     run at least the vectorization factor number of times checking\n-     is pointless, too.  */\n+     run at least the (estimated) vectorization factor number of times\n+     checking is pointless, too.  */\n   th = LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo);\n-  if (th >= LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+  if (th >= vect_vf_for_cost (loop_vinfo)\n       && !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n       if (dump_enabled_p ())\n@@ -7420,11 +7440,11 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t\t      check_profitability, niters_no_overflow);\n   if (niters_vector == NULL_TREE)\n     {\n-      if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+      if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && known_eq (lowest_vf, vf))\n \t{\n \t  niters_vector\n \t    = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n-\t\t\t     LOOP_VINFO_INT_NITERS (loop_vinfo) / vf);\n+\t\t\t     LOOP_VINFO_INT_NITERS (loop_vinfo) / lowest_vf);\n \t  step_vector = build_one_cst (TREE_TYPE (niters));\n \t}\n       else\n@@ -7471,8 +7491,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t    continue;\n \n \t  if (STMT_VINFO_VECTYPE (stmt_info)\n-\t      && (TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info))\n-\t\t  != (unsigned HOST_WIDE_INT) vf)\n+\t      && (maybe_ne\n+\t\t  (TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info)), vf))\n \t      && dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location, \"multiple-types.\\n\");\n \n@@ -7608,7 +7628,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t= (unsigned int)\n \t\t  TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n \t      if (!STMT_SLP_TYPE (stmt_info)\n-\t\t  && nunits != (unsigned int) vf\n+\t\t  && maybe_ne (nunits, vf)\n \t\t  && dump_enabled_p ())\n \t\t  /* For SLP VF is set according to unrolling factor, and not\n \t\t     to vector size, hence for SLP this print is not valid.  */\n@@ -7688,7 +7708,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t\t\t   niters_vector_mult_vf,\n \t\t\t\t   !niters_no_overflow);\n \n-  scale_profile_for_vect_loop (loop, vf);\n+  unsigned int assumed_vf = vect_vf_for_cost (loop_vinfo);\n+  scale_profile_for_vect_loop (loop, assumed_vf);\n \n   /* The minimum number of iterations performed by the epilogue.  This\n      is 1 when peeling for gaps because we always need a final scalar\n@@ -7702,13 +7723,16 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      back to latch counts.  */\n   if (loop->any_upper_bound)\n     loop->nb_iterations_upper_bound\n-      = wi::udiv_floor (loop->nb_iterations_upper_bound + bias, vf) - 1;\n+      = wi::udiv_floor (loop->nb_iterations_upper_bound + bias,\n+\t\t\tlowest_vf) - 1;\n   if (loop->any_likely_upper_bound)\n     loop->nb_iterations_likely_upper_bound\n-      = wi::udiv_floor (loop->nb_iterations_likely_upper_bound + bias, vf) - 1;\n+      = wi::udiv_floor (loop->nb_iterations_likely_upper_bound + bias,\n+\t\t\tlowest_vf) - 1;\n   if (loop->any_estimate)\n     loop->nb_iterations_estimate\n-      = wi::udiv_floor (loop->nb_iterations_estimate + bias, vf) - 1;\n+      = wi::udiv_floor (loop->nb_iterations_estimate + bias,\n+\t\t\tassumed_vf) - 1;\n \n   if (dump_enabled_p ())\n     {\n@@ -7752,17 +7776,18 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \telse if (!vector_sizes)\n \t  epilogue = NULL;\n \telse if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t\t && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) >= 0)\n+\t\t && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) >= 0\n+\t\t && known_eq (vf, lowest_vf))\n \t  {\n \t    int smallest_vec_size = 1 << ctz_hwi (vector_sizes);\n \t    int ratio = current_vector_size / smallest_vec_size;\n-\t    int eiters = LOOP_VINFO_INT_NITERS (loop_vinfo)\n+\t    unsigned HOST_WIDE_INT eiters = LOOP_VINFO_INT_NITERS (loop_vinfo)\n \t      - LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n-\t    eiters = eiters % vf;\n+\t    eiters = eiters % lowest_vf;\n \n \t    epilogue->nb_iterations_upper_bound = eiters - 1;\n \n-\t    if (eiters < vf / ratio)\n+\t    if (eiters < lowest_vf / ratio)\n \t      epilogue = NULL;\n \t    }\n     }"}, {"sha": "4f12995f8496cc21a48e50680a481b1863b4768e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 45, "deletions": 26, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=d9f21f6acb3aa615834e855e16b6311cd18c5668", "patch": "@@ -1505,14 +1505,14 @@ vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n \t\t\t    node->load_permutation);\n \n   /* We are done, no actual permutations need to be generated.  */\n-  unsigned int unrolling_factor = SLP_INSTANCE_UNROLLING_FACTOR (slp_instn);\n+  poly_uint64 unrolling_factor = SLP_INSTANCE_UNROLLING_FACTOR (slp_instn);\n   FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n     {\n       gimple *first_stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n       first_stmt = GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_stmt));\n       /* But we have to keep those permutations that are required because\n          of handling of gaps.  */\n-      if (unrolling_factor == 1\n+      if (known_eq (unrolling_factor, 1U)\n \t  || (group_size == GROUP_SIZE (vinfo_for_stmt (first_stmt))\n \t      && GROUP_GAP (vinfo_for_stmt (first_stmt)) == 0))\n \tSLP_TREE_LOAD_PERMUTATION (node).release ();\n@@ -1639,10 +1639,10 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n      and the vectorization factor is not yet final.\n      ???  The SLP instance unrolling factor might not be the maximum one.  */\n   unsigned n_perms;\n-  unsigned test_vf\n-    = least_common_multiple (SLP_INSTANCE_UNROLLING_FACTOR (slp_instn),\n+  poly_uint64 test_vf\n+    = force_common_multiple (SLP_INSTANCE_UNROLLING_FACTOR (slp_instn),\n \t\t\t     LOOP_VINFO_VECT_FACTOR\n-\t\t\t       (STMT_VINFO_LOOP_VINFO (vinfo_for_stmt (stmt))));\n+\t\t\t     (STMT_VINFO_LOOP_VINFO (vinfo_for_stmt (stmt))));\n   FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n     if (node->load_permutation.exists ()\n \t&& !vect_transform_slp_perm_load (node, vNULL, NULL, test_vf,\n@@ -1755,7 +1755,8 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n \t      gcc_assert (ncopies_for_cost\n \t\t\t  <= (GROUP_SIZE (stmt_info) - GROUP_GAP (stmt_info)\n \t\t\t      + nunits - 1) / nunits);\n-\t      ncopies_for_cost *= SLP_INSTANCE_UNROLLING_FACTOR (instance);\n+\t      poly_uint64 uf = SLP_INSTANCE_UNROLLING_FACTOR (instance);\n+\t      ncopies_for_cost *= estimated_poly_value (uf);\n \t    }\n \t  /* Record the cost for the vector loads.  */\n \t  vect_model_load_cost (stmt_info, ncopies_for_cost,\n@@ -1859,10 +1860,13 @@ vect_analyze_slp_cost (slp_instance instance, void *data)\n   unsigned group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n   slp_tree node = SLP_INSTANCE_TREE (instance);\n   stmt_vec_info stmt_info = vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]);\n-  /* Adjust the group_size by the vectorization factor which is always one\n-     for basic-block vectorization.  */\n+  /* Get the estimated vectorization factor, which is always one for\n+     basic-block vectorization.  */\n+  unsigned int assumed_vf;\n   if (STMT_VINFO_LOOP_VINFO (stmt_info))\n-    group_size *= LOOP_VINFO_VECT_FACTOR (STMT_VINFO_LOOP_VINFO (stmt_info));\n+    assumed_vf = vect_vf_for_cost (STMT_VINFO_LOOP_VINFO (stmt_info));\n+  else\n+    assumed_vf = 1;\n   unsigned nunits = TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n   /* For reductions look at a reduction operand in case the reduction\n      operation is widening like DOT_PROD or SAD.  */\n@@ -1879,7 +1883,8 @@ vect_analyze_slp_cost (slp_instance instance, void *data)\n \tdefault:;\n \t}\n     }\n-  ncopies_for_cost = least_common_multiple (nunits, group_size) / nunits;\n+  ncopies_for_cost = least_common_multiple (nunits,\n+\t\t\t\t\t    group_size * assumed_vf) / nunits;\n \n   prologue_cost_vec.create (10);\n   body_cost_vec.create (10);\n@@ -1971,7 +1976,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   slp_instance new_instance;\n   slp_tree node;\n   unsigned int group_size = GROUP_SIZE (vinfo_for_stmt (stmt));\n-  unsigned int unrolling_factor = 1, nunits;\n+  unsigned int nunits;\n   tree vectype, scalar_type = NULL_TREE;\n   gimple *next;\n   unsigned int i;\n@@ -2059,10 +2064,10 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   if (node != NULL)\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */\n-      unrolling_factor\n+      poly_uint64 unrolling_factor\n \t= least_common_multiple (max_nunits, group_size) / group_size;\n \n-      if (unrolling_factor != 1\n+      if (maybe_ne (unrolling_factor, 1U)\n \t  && is_a <bb_vec_info> (vinfo))\n \t{\n \n@@ -2115,7 +2120,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t      /* The load requires permutation when unrolling exposes\n \t         a gap either because the group is larger than the SLP\n \t\t group-size or because there is a gap between the groups.  */\n-\t      && (unrolling_factor == 1\n+\t      && (known_eq (unrolling_factor, 1U)\n \t\t  || (group_size == GROUP_SIZE (vinfo_for_stmt (first_stmt))\n \t\t      && GROUP_GAP (vinfo_for_stmt (first_stmt)) == 0)))\n \t    {\n@@ -2290,7 +2295,8 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n bool\n vect_make_slp_decision (loop_vec_info loop_vinfo)\n {\n-  unsigned int i, unrolling_factor = 1;\n+  unsigned int i;\n+  poly_uint64 unrolling_factor = 1;\n   vec<slp_instance> slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n   slp_instance instance;\n   int decided_to_slp = 0;\n@@ -2302,8 +2308,11 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       /* FORNOW: SLP if you can.  */\n-      if (unrolling_factor < SLP_INSTANCE_UNROLLING_FACTOR (instance))\n-\tunrolling_factor = SLP_INSTANCE_UNROLLING_FACTOR (instance);\n+      /* All unroll factors have the form current_vector_size * X for some\n+\t rational X, so they must have a common multiple.  */\n+      unrolling_factor\n+\t= force_common_multiple (unrolling_factor,\n+\t\t\t\t SLP_INSTANCE_UNROLLING_FACTOR (instance));\n \n       /* Mark all the stmts that belong to INSTANCE as PURE_SLP stmts.  Later we\n \t call vect_detect_hybrid_slp () to find stmts that need hybrid SLP and\n@@ -2315,9 +2324,13 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n   LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo) = unrolling_factor;\n \n   if (decided_to_slp && dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"Decided to SLP %d instances. Unrolling factor %d\\n\",\n-\t\t     decided_to_slp, unrolling_factor);\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"Decided to SLP %d instances. Unrolling factor \",\n+\t\t       decided_to_slp);\n+      dump_dec (MSG_NOTE, unrolling_factor);\n+      dump_printf (MSG_NOTE, \"\\n\");\n+    }\n \n   return (decided_to_slp > 0);\n }\n@@ -2627,15 +2640,15 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n       = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_CHILDREN (node)[0]);\n   else\n     {\n-      int vf;\n+      poly_uint64 vf;\n       if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n \tvf = loop_vinfo->vectorization_factor;\n       else\n \tvf = 1;\n       unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (node_instance);\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n       SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n-\t= vf * group_size / TYPE_VECTOR_SUBPARTS (vectype);\n+\t= vect_get_num_vectors (vf * group_size, vectype);\n     }\n \n   /* Push SLP node def-type to stmt operands.  */\n@@ -2841,7 +2854,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n   bb_vec_info bb_vinfo;\n   slp_instance instance;\n   int i;\n-  int min_vf = 2;\n+  poly_uint64 min_vf = 2;\n \n   /* The first group of checks is independent of the vector size.  */\n   fatal = true;\n@@ -3545,8 +3558,8 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n \n bool\n vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n-                              gimple_stmt_iterator *gsi, int vf,\n-                              slp_instance slp_node_instance, bool analyze_only,\n+\t\t\t      gimple_stmt_iterator *gsi, poly_uint64 vf,\n+\t\t\t      slp_instance slp_node_instance, bool analyze_only,\n \t\t\t      unsigned *n_perms)\n {\n   gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n@@ -3557,6 +3570,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n   int mask_element;\n   machine_mode mode;\n+  unsigned HOST_WIDE_INT const_vf;\n \n   if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     return false;\n@@ -3565,6 +3579,11 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \n   mode = TYPE_MODE (vectype);\n \n+  /* At the moment, all permutations are represented using per-element\n+     indices, so we can't cope with variable vectorization factors.  */\n+  if (!vf.is_constant (&const_vf))\n+    return false;\n+\n   /* The generic VEC_PERM_EXPR code always uses an integral type of the\n      same size as the vector element being permuted.  */\n   mask_element_type = lang_hooks.types.type_for_mode\n@@ -3607,7 +3626,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   bool noop_p = true;\n   *n_perms = 0;\n \n-  for (int j = 0; j < vf; j++)\n+  for (unsigned int j = 0; j < const_vf; j++)\n     {\n       for (int k = 0; k < group_size; k++)\n \t{"}, {"sha": "bae72d098549e318a4df6fba6ebbd5aea9748a56", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=d9f21f6acb3aa615834e855e16b6311cd18c5668", "patch": "@@ -3361,6 +3361,16 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n       arginfo.quick_push (thisarginfo);\n     }\n \n+  unsigned HOST_WIDE_INT vf;\n+  if (!LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&vf))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not considering SIMD clones; not yet supported\"\n+\t\t\t \" for variable-width vectors.\\n\");\n+      return NULL;\n+    }\n+\n   unsigned int badness = 0;\n   struct cgraph_node *bestn = NULL;\n   if (STMT_VINFO_SIMD_CLONE_INFO (stmt_info).exists ())\n@@ -3370,13 +3380,11 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t n = n->simdclone->next_clone)\n       {\n \tunsigned int this_badness = 0;\n-\tif (n->simdclone->simdlen\n-\t    > (unsigned) LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\tif (n->simdclone->simdlen > vf\n \t    || n->simdclone->nargs != nargs)\n \t  continue;\n-\tif (n->simdclone->simdlen\n-\t    < (unsigned) LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n-\t  this_badness += (exact_log2 (LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n+\tif (n->simdclone->simdlen < vf)\n+\t  this_badness += (exact_log2 (vf)\n \t\t\t   - exact_log2 (n->simdclone->simdlen)) * 1024;\n \tif (n->simdclone->inbranch)\n \t  this_badness += 2048;\n@@ -3465,7 +3473,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   fndecl = bestn->decl;\n   nunits = bestn->simdclone->simdlen;\n-  ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  ncopies = vf / nunits;\n \n   /* If the function isn't const, only allow it in simd loops where user\n      has asserted that at least nunits consecutive iterations can be\n@@ -5694,7 +5702,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   gather_scatter_info gs_info;\n   enum vect_def_type scatter_src_dt = vect_unknown_def_type;\n   gimple *new_stmt;\n-  int vf;\n+  poly_uint64 vf;\n   vec_load_store_type vls_type;\n   tree ref_type;\n \n@@ -6664,7 +6672,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   tree dataref_offset = NULL_TREE;\n   gimple *ptr_incr = NULL;\n   int ncopies;\n-  int i, j, group_size, group_gap_adj;\n+  int i, j, group_size;\n+  poly_int64 group_gap_adj;\n   tree msq = NULL_TREE, lsq;\n   tree offset = NULL_TREE;\n   tree byte_offset = NULL_TREE;\n@@ -6682,7 +6691,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   bool slp_perm = false;\n   enum tree_code code;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n-  int vf;\n+  poly_uint64 vf;\n   tree aggr_type;\n   gather_scatter_info gs_info;\n   vec_info *vinfo = stmt_info->vinfo;\n@@ -6752,8 +6761,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n      on the unrolled body effectively re-orders stmts.  */\n   if (ncopies > 1\n       && STMT_VINFO_MIN_NEG_DIST (stmt_info) != 0\n-      && ((unsigned)LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t  > STMT_VINFO_MIN_NEG_DIST (stmt_info)))\n+      && maybe_gt (LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n+\t\t   STMT_VINFO_MIN_NEG_DIST (stmt_info)))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6793,8 +6802,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t on the unrolled body effectively re-orders stmts.  */\n       if (!PURE_SLP_STMT (stmt_info)\n \t  && STMT_VINFO_MIN_NEG_DIST (stmt_info) != 0\n-\t  && ((unsigned)LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t      > STMT_VINFO_MIN_NEG_DIST (stmt_info)))\n+\t  && maybe_gt (LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n+\t\t       STMT_VINFO_MIN_NEG_DIST (stmt_info)))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -7156,7 +7165,10 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t     fits in.  */\n \t  if (slp_perm)\n \t    {\n-\t      ncopies = (group_size * vf + nunits - 1) / nunits;\n+\t      /* We don't yet generate SLP_TREE_LOAD_PERMUTATIONs for\n+\t\t variable VF.  */\n+\t      unsigned int const_vf = vf.to_constant ();\n+\t      ncopies = (group_size * const_vf + nunits - 1) / nunits;\n \t      dr_chain.create (ncopies);\n \t    }\n \t  else\n@@ -7274,7 +7286,10 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t     fits in.  */\n \t  if (slp_perm)\n \t    {\n-\t      vec_num = (group_size * vf + nunits - 1) / nunits;\n+\t      /* We don't yet generate SLP_TREE_LOAD_PERMUTATIONs for\n+\t\t variable VF.  */\n+\t      unsigned int const_vf = vf.to_constant ();\n+\t      vec_num = (group_size * const_vf + nunits - 1) / nunits;\n \t      group_gap_adj = vf * group_size - nunits * vec_num;\n \t    }\n \t  else\n@@ -7740,11 +7755,13 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t         we need to skip the gaps after we manage to fully load\n \t\t all elements.  group_gap_adj is GROUP_SIZE here.  */\n \t      group_elt += nunits;\n-\t      if (group_gap_adj != 0 && ! slp_perm\n-\t\t  && group_elt == group_size - group_gap_adj)\n+\t      if (maybe_ne (group_gap_adj, 0U)\n+\t\t  && !slp_perm\n+\t\t  && known_eq (group_elt, group_size - group_gap_adj))\n \t\t{\n-\t\t  wide_int bump_val = (wi::to_wide (TYPE_SIZE_UNIT (elem_type))\n-\t\t\t\t       * group_gap_adj);\n+\t\t  poly_wide_int bump_val\n+\t\t    = (wi::to_wide (TYPE_SIZE_UNIT (elem_type))\n+\t\t       * group_gap_adj);\n \t\t  tree bump = wide_int_to_tree (sizetype, bump_val);\n \t\t  dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n \t\t\t\t\t\t stmt, bump);\n@@ -7753,10 +7770,11 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    }\n \t  /* Bump the vector pointer to account for a gap or for excess\n \t     elements loaded for a permuted SLP load.  */\n-\t  if (group_gap_adj != 0 && slp_perm)\n+\t  if (maybe_ne (group_gap_adj, 0U) && slp_perm)\n \t    {\n-\t      wide_int bump_val = (wi::to_wide (TYPE_SIZE_UNIT (elem_type))\n-\t\t\t\t   * group_gap_adj);\n+\t      poly_wide_int bump_val\n+\t\t= (wi::to_wide (TYPE_SIZE_UNIT (elem_type))\n+\t\t   * group_gap_adj);\n \t      tree bump = wide_int_to_tree (sizetype, bump_val);\n \t      dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n \t\t\t\t\t     stmt, bump);"}, {"sha": "8ddfdc2ce26086efe8df41dac21cf9ad3c2964b2", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=d9f21f6acb3aa615834e855e16b6311cd18c5668", "patch": "@@ -91,7 +91,7 @@ vec<stmt_vec_info> stmt_vec_info_vec;\n struct simduid_to_vf : free_ptr_hash<simduid_to_vf>\n {\n   unsigned int simduid;\n-  int vf;\n+  poly_uint64 vf;\n \n   /* hash_table support.  */\n   static inline hashval_t hash (const simduid_to_vf *);\n@@ -161,7 +161,7 @@ adjust_simduid_builtins (hash_table<simduid_to_vf> *htab)\n \n       for (i = gsi_start_bb (bb); !gsi_end_p (i); )\n \t{\n-\t  unsigned int vf = 1;\n+\t  poly_uint64 vf = 1;\n \t  enum internal_fn ifn;\n \t  gimple *stmt = gsi_stmt (i);\n \t  tree t;\n@@ -338,7 +338,7 @@ shrink_simd_arrays\n     if ((*iter)->simduid != -1U)\n       {\n \ttree decl = (*iter)->decl;\n-\tint vf = 1;\n+\tpoly_uint64 vf = 1;\n \tif (simduid_to_vf_htab)\n \t  {\n \t    simduid_to_vf *p = NULL, data;"}, {"sha": "9619286ed34b94798539fd733eabd3876e4eef91", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9f21f6acb3aa615834e855e16b6311cd18c5668/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=d9f21f6acb3aa615834e855e16b6311cd18c5668", "patch": "@@ -129,7 +129,7 @@ typedef struct _slp_instance {\n   unsigned int group_size;\n \n   /* The unrolling factor required to vectorized this SLP instance.  */\n-  unsigned int unrolling_factor;\n+  poly_uint64 unrolling_factor;\n \n   /* The group of nodes that contain loads of this SLP instance.  */\n   vec<slp_tree> loads;\n@@ -245,7 +245,7 @@ typedef struct _loop_vec_info : public vec_info {\n   poly_uint64 versioning_threshold;\n \n   /* Unrolling factor  */\n-  int vectorization_factor;\n+  poly_uint64 vectorization_factor;\n \n   /* Maximum runtime vectorization factor, or MAX_VECTORIZATION_FACTOR\n      if there is no particular limit.  */\n@@ -297,7 +297,7 @@ typedef struct _loop_vec_info : public vec_info {\n \n   /* The unrolling factor needed to SLP the loop. In case of that pure SLP is\n      applied to the loop, i.e., no unrolling is needed, this is 1.  */\n-  unsigned slp_unrolling_factor;\n+  poly_uint64 slp_unrolling_factor;\n \n   /* Cost of a single scalar iteration.  */\n   int single_scalar_iteration_cost;\n@@ -815,8 +815,7 @@ struct dataref_aux {\n    conversion.  */\n #define MAX_INTERM_CVT_STEPS         3\n \n-/* The maximum vectorization factor supported by any target (V64QI).  */\n-#define MAX_VECTORIZATION_FACTOR 64\n+#define MAX_VECTORIZATION_FACTOR INT_MAX\n \n /* Nonzero if TYPE represents a (scalar) boolean type or type\n    in the middle-end compatible with it (unsigned precision 1 integral\n@@ -1109,6 +1108,16 @@ unlimited_cost_model (loop_p loop)\n   return (flag_vect_cost_model == VECT_COST_MODEL_UNLIMITED);\n }\n \n+/* Return the number of vectors of type VECTYPE that are needed to get\n+   NUNITS elements.  NUNITS should be based on the vectorization factor,\n+   so it is always a known multiple of the number of elements in VECTYPE.  */\n+\n+static inline unsigned int\n+vect_get_num_vectors (poly_uint64 nunits, tree vectype)\n+{\n+  return exact_div (nunits, TYPE_VECTOR_SUBPARTS (vectype)).to_constant ();\n+}\n+\n /* Return the number of copies needed for loop vectorization when\n    a statement operates on vectors of type VECTYPE.  This is the\n    vectorization factor divided by the number of elements in\n@@ -1117,10 +1126,32 @@ unlimited_cost_model (loop_p loop)\n static inline unsigned int\n vect_get_num_copies (loop_vec_info loop_vinfo, tree vectype)\n {\n-  gcc_checking_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t\t       % TYPE_VECTOR_SUBPARTS (vectype) == 0);\n-  return (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t  / TYPE_VECTOR_SUBPARTS (vectype));\n+  return vect_get_num_vectors (LOOP_VINFO_VECT_FACTOR (loop_vinfo), vectype);\n+}\n+\n+/* Update maximum unit count *MAX_NUNITS so that it accounts for\n+   the number of units in vector type VECTYPE.  *MAX_NUNITS can be 1\n+   if we haven't yet recorded any vector types.  */\n+\n+static inline void\n+vect_update_max_nunits (poly_uint64 *max_nunits, tree vectype)\n+{\n+  /* All unit counts have the form current_vector_size * X for some\n+     rational X, so two unit sizes must have a common multiple.\n+     Everything is a multiple of the initial value of 1.  */\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  *max_nunits = force_common_multiple (*max_nunits, nunits);\n+}\n+\n+/* Return the vectorization factor that should be used for costing\n+   purposes while vectorizing the loop described by LOOP_VINFO.\n+   Pick a reasonable estimate if the vectorization factor isn't\n+   known at compile time.  */\n+\n+static inline unsigned int\n+vect_vf_for_cost (loop_vec_info loop_vinfo)\n+{\n+  return estimated_poly_value (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n }\n \n /* Return the size of the value accessed by unvectorized data reference DR.\n@@ -1223,7 +1254,7 @@ extern enum dr_alignment_support vect_supportable_dr_alignment\n                                            (struct data_reference *, bool);\n extern tree vect_get_smallest_scalar_type (gimple *, HOST_WIDE_INT *,\n                                            HOST_WIDE_INT *);\n-extern bool vect_analyze_data_ref_dependences (loop_vec_info, int *);\n+extern bool vect_analyze_data_ref_dependences (loop_vec_info, unsigned int *);\n extern bool vect_slp_analyze_instance_dependence (slp_instance);\n extern bool vect_enhance_data_refs_alignment (loop_vec_info);\n extern bool vect_analyze_data_refs_alignment (loop_vec_info);\n@@ -1233,7 +1264,7 @@ extern bool vect_analyze_data_ref_accesses (vec_info *);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n extern bool vect_check_gather_scatter (gimple *, loop_vec_info,\n \t\t\t\t       gather_scatter_info *);\n-extern bool vect_analyze_data_refs (vec_info *, int *);\n+extern bool vect_analyze_data_refs (vec_info *, poly_uint64 *);\n extern void vect_record_base_alignments (vec_info *);\n extern tree vect_create_data_ref_ptr (gimple *, tree, struct loop *, tree,\n \t\t\t\t      tree *, gimple_stmt_iterator *,\n@@ -1291,8 +1322,8 @@ extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,\n /* In tree-vect-slp.c.  */\n extern void vect_free_slp_instance (slp_instance);\n extern bool vect_transform_slp_perm_load (slp_tree, vec<tree> ,\n-                                          gimple_stmt_iterator *, int,\n-                                          slp_instance, bool, unsigned *);\n+\t\t\t\t\t  gimple_stmt_iterator *, poly_uint64,\n+\t\t\t\t\t  slp_instance, bool, unsigned *);\n extern bool vect_slp_analyze_operations (vec_info *);\n extern bool vect_schedule_slp (vec_info *);\n extern bool vect_analyze_slp (vec_info *, unsigned);"}]}