{"sha": "b789efeae8c0620b83f25e4a0757c4871e02ab5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4OWVmZWFlOGMwNjIwYjgzZjI1ZTRhMDc1N2M0ODcxZTAyYWI1Zg==", "commit": {"author": {"name": "Mike Crowe", "email": "mac@mcrowe.com", "date": "2019-12-02T16:23:14Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-12-02T16:23:14Z"}, "message": "libstdc++: Fix try_lock_until and try_lock_shared_until on arbitrary clock\n\nThis is the equivalent to PR libstdc++/91906, but for shared_mutex.\n\nA non-standard clock may tick more slowly than std::chrono::steady_clock.\nThis means that we risk returning false early when the specified timeout\nmay not have expired. This can be avoided by looping until the timeout time\nas reported by the non-standard clock has been reached.\n\nUnfortunately, we have no way to tell whether the non-standard clock ticks\nmore quickly that std::chrono::steady_clock. If it does then we risk\nreturning later than would be expected, but that is unavoidable without\nwaking up periodically to check, which would be rather too expensive.\n\nFran\u00e7ois Dumont pointed out[1] a flaw in an earlier version of this patch\nthat revealed a hole in the test coverage, so I've added a new test that\ntry_lock_until acts as try_lock if the timeout has already expired.\n\n[1] https://gcc.gnu.org/ml/libstdc++/2019-10/msg00021.html\n\n2019-12-02  Mike Crowe  <mac@mcrowe.com>\n\n\tFix try_lock_until and try_lock_shared_until on arbitrary clock\n\t* include/std/shared_mutex (shared_timed_mutex::try_lock_until)\n\t(shared_timed_mutex::try_lock_shared_until): Loop until the absolute\n\ttimeout time is reached as measured against the appropriate clock.\n\t* testsuite/30_threads/shared_timed_mutex/try_lock_until/1.cc: New\n\tfile. Test try_lock_until and try_lock_shared_until timeouts against\n\tvarious clocks.\n\t* testsuite/30_threads/shared_timed_mutex/try_lock_until/1.cc: New\n\tfile. Test try_lock_until and try_lock_shared_until timeouts against\n\tvarious clocks.\n\nFrom-SVN: r278904", "tree": {"sha": "33974ad951234d737787249a54996711a12b0ce7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33974ad951234d737787249a54996711a12b0ce7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b789efeae8c0620b83f25e4a0757c4871e02ab5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b789efeae8c0620b83f25e4a0757c4871e02ab5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b789efeae8c0620b83f25e4a0757c4871e02ab5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b789efeae8c0620b83f25e4a0757c4871e02ab5f/comments", "author": {"login": "mikecrowe", "id": 93615, "node_id": "MDQ6VXNlcjkzNjE1", "avatar_url": "https://avatars.githubusercontent.com/u/93615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikecrowe", "html_url": "https://github.com/mikecrowe", "followers_url": "https://api.github.com/users/mikecrowe/followers", "following_url": "https://api.github.com/users/mikecrowe/following{/other_user}", "gists_url": "https://api.github.com/users/mikecrowe/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikecrowe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikecrowe/subscriptions", "organizations_url": "https://api.github.com/users/mikecrowe/orgs", "repos_url": "https://api.github.com/users/mikecrowe/repos", "events_url": "https://api.github.com/users/mikecrowe/events{/privacy}", "received_events_url": "https://api.github.com/users/mikecrowe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab40695a46c6649bac40f4251e37993d73fa7a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab40695a46c6649bac40f4251e37993d73fa7a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab40695a46c6649bac40f4251e37993d73fa7a13"}], "stats": {"total": 35, "additions": 31, "deletions": 4}, "files": [{"sha": "b39855d3f58085f4ec422d8c443a2acdfe28b3de", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b789efeae8c0620b83f25e4a0757c4871e02ab5f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b789efeae8c0620b83f25e4a0757c4871e02ab5f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b789efeae8c0620b83f25e4a0757c4871e02ab5f", "patch": "@@ -1,5 +1,16 @@\n 2019-12-02  Mike Crowe  <mac@mcrowe.com>\n \n+\tFix try_lock_until and try_lock_shared_until on arbitrary clock\n+\t* include/std/shared_mutex (shared_timed_mutex::try_lock_until)\n+\t(shared_timed_mutex::try_lock_shared_until): Loop until the absolute\n+\ttimeout time is reached as measured against the appropriate clock.\n+\t* testsuite/30_threads/shared_timed_mutex/try_lock_until/1.cc: New\n+\tfile. Test try_lock_until and try_lock_shared_until timeouts against\n+\tvarious clocks.\n+\t* testsuite/30_threads/shared_timed_mutex/try_lock_until/1.cc: New\n+\tfile. Test try_lock_until and try_lock_shared_until timeouts against\n+\tvarious clocks.\n+\n \tAdd full steady_clock support to shared_timed_mutex\n \t* acinclude.m4 (GLIBCXX_CHECK_PTHREAD_RWLOCK_CLOCKLOCK): Define\n \tto check for the presence of both pthread_rwlock_clockrdlock and"}, {"sha": "f6cf7e759675d5da72f753a33c13300449b5dbd3", "filename": "libstdc++-v3/include/std/shared_mutex", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b789efeae8c0620b83f25e4a0757c4871e02ab5f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b789efeae8c0620b83f25e4a0757c4871e02ab5f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex?ref=b789efeae8c0620b83f25e4a0757c4871e02ab5f", "patch": "@@ -554,9 +554,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)\n       {\n+\t// The user-supplied clock may not tick at the same rate as\n+\t// steady_clock, so we must loop in order to guarantee that\n+\t// the timeout has expired before returning false.\n \ttypename _Clock::time_point __now = _Clock::now();\n-\tauto __rtime = __atime - __now;\n-\treturn try_lock_for(__rtime);\n+\tdo {\n+\t    auto __rtime = __atime - __now;\n+\t    if (try_lock_for(__rtime))\n+\t      return true;\n+\t    __now = _Clock::now();\n+\t} while (__atime > __now);\n+\treturn false;\n       }\n \n     // Shared ownership\n@@ -631,9 +639,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       try_lock_shared_until(const chrono::time_point<_Clock,\n \t\t\t\t\t\t     _Duration>& __atime)\n       {\n+\t// The user-supplied clock may not tick at the same rate as\n+\t// steady_clock, so we must loop in order to guarantee that\n+\t// the timeout has expired before returning false.\n \ttypename _Clock::time_point __now = _Clock::now();\n-\tauto __rtime = __atime - __now;\n-\treturn try_lock_shared_for(__rtime);\n+\tdo {\n+\t    auto __rtime = __atime - __now;\n+\t    if (try_lock_shared_for(__rtime))\n+\t      return true;\n+\t    __now = _Clock::now();\n+\t} while (__atime > __now);\n+\treturn false;\n       }\n \n #else // ! (_GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK)"}]}