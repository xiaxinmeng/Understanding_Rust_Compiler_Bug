{"sha": "6566b0fb86addb5c28d3ff8b2631f7f9516d4054", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU2NmIwZmI4NmFkZGI1YzI4ZDNmZjhiMjYzMWY3Zjk1MTZkNDA1NA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-11-17T17:34:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-11-17T17:34:36Z"}, "message": "gimple-ssa-evrp.c (class evrp_range_analyzer): New class extracted from evrp_dom_walker class.\n\n\t* gimple-ssa-evrp.c (class evrp_range_analyzer): New class extracted\n\tfrom evrp_dom_walker class.  Various methods moved into new class.\n\t(evrp_range_analyzer::evrp_range_analyzer): Constructor for new class.\n\t(evrp_range_analyzer::enter): New method.\n\t(evrp_range_analyzer::leave): New method.\n\t(evrp_dom_walker): Remove delegators no longer needed by this class.\n\tReplace vr_values data member with evrp_range_analyzer\n\nFrom-SVN: r254884", "tree": {"sha": "f111146e0fbe90f8ede7faf03954bc0be8a5f69d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f111146e0fbe90f8ede7faf03954bc0be8a5f69d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6566b0fb86addb5c28d3ff8b2631f7f9516d4054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6566b0fb86addb5c28d3ff8b2631f7f9516d4054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6566b0fb86addb5c28d3ff8b2631f7f9516d4054", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6566b0fb86addb5c28d3ff8b2631f7f9516d4054/comments", "author": null, "committer": null, "parents": [{"sha": "0dee5a2a29183210dc989b0cfc2870dccab7c071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dee5a2a29183210dc989b0cfc2870dccab7c071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dee5a2a29183210dc989b0cfc2870dccab7c071"}], "stats": {"total": 187, "additions": 109, "deletions": 78}, "files": [{"sha": "8dde55ce2f23aaf89c1e396848ad84a94763fa0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6566b0fb86addb5c28d3ff8b2631f7f9516d4054/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6566b0fb86addb5c28d3ff8b2631f7f9516d4054/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6566b0fb86addb5c28d3ff8b2631f7f9516d4054", "patch": "@@ -1,5 +1,13 @@\n 2017-11-17  Jeff Law  <law@redhat.com>\n \n+\t* gimple-ssa-evrp.c (class evrp_range_analyzer): New class extracted\n+\tfrom evrp_dom_walker class.  Various methods moved into new class.\n+\t(evrp_range_analyzer::evrp_range_analyzer): Constructor for new class.\n+\t(evrp_range_analyzer::enter): New method.\n+\t(evrp_range_analyzer::leave): New method.\n+\t(evrp_dom_walker): Remove delegators no longer needed by this class.\n+\tReplace vr_values data member with evrp_range_analyzer\n+\n \t* gimple-ssa-evrp.c (evrp_dom_walker::record_ranges_from_phis): New\n \tmethod extracted from evrp_dom_walker::before_dom_children.\n \t(evrp_dom_walker::record_ranges_from_stmt): Likewise."}, {"sha": "76eeb13c63e8a9d75fdd2b908489898a9206d41d", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 101, "deletions": 78, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6566b0fb86addb5c28d3ff8b2631f7f9516d4054/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6566b0fb86addb5c28d3ff8b2631f7f9516d4054/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=6566b0fb86addb5c28d3ff8b2631f7f9516d4054", "patch": "@@ -55,15 +55,77 @@ evrp_folder::get_value (tree op)\n   return vr_values->op_with_constant_singleton_value_range (op);\n }\n \n+class evrp_range_analyzer\n+{\n+ public:\n+  evrp_range_analyzer (void);\n+  ~evrp_range_analyzer (void) { stack.release (); }\n+\n+  void enter (basic_block);\n+  void leave (basic_block);\n+  void record_ranges_from_stmt (gimple *);\n+\n+  class vr_values vr_values;\n+\n+ private:\n+  DISABLE_COPY_AND_ASSIGN (evrp_range_analyzer);\n+  void push_value_range (tree var, value_range *vr);\n+  value_range *pop_value_range (tree var);\n+  value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n+  void record_ranges_from_incoming_edge (basic_block);\n+  void record_ranges_from_phis (basic_block);\n+\n+  /* STACK holds the old VR.  */\n+  auto_vec<std::pair <tree, value_range*> > stack;\n+\n+  /* Temporary delegators.  */\n+  value_range *get_value_range (const_tree op)\n+    { return vr_values.get_value_range (op); }\n+  bool update_value_range (const_tree op, value_range *vr)\n+    { return vr_values.update_value_range (op, vr); }\n+  void extract_range_from_phi_node (gphi *phi, value_range *vr)\n+    { vr_values.extract_range_from_phi_node (phi, vr); }\n+  void adjust_range_with_scev (value_range *vr, struct loop *loop,\n+                               gimple *stmt, tree var)\n+    { vr_values.adjust_range_with_scev (vr, loop, stmt, var); }\n+  void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n+                                tree *output_p, value_range *vr)\n+    { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n+  void set_defs_to_varying (gimple *stmt)\n+    { return vr_values.set_defs_to_varying (stmt); }\n+  void set_vr_value (tree name, value_range *vr)\n+    { vr_values.set_vr_value (name, vr); }\n+  void extract_range_for_var_from_comparison_expr (tree var,\n+\t\t\t\t\t\t   enum tree_code cond_code,\n+\t\t\t\t\t\t   tree op, tree limit,\n+\t\t\t\t\t\t   value_range *vr_p)\n+    { vr_values.extract_range_for_var_from_comparison_expr (var, cond_code,\n+\t\t\t\t\t\t\t    op, limit, vr_p); }\n+};\n+\n+evrp_range_analyzer::evrp_range_analyzer () : stack (10)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      bb->flags &= ~BB_VISITED;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\te->flags |= EDGE_EXECUTABLE;\n+    }\n+}\n+\n+\n /* evrp_dom_walker visits the basic blocks in the dominance order and set\n    the Value Ranges (VR) for SSA_NAMEs in the scope.  Use this VR to\n    discover more VRs.  */\n \n class evrp_dom_walker : public dom_walker\n {\n public:\n-  evrp_dom_walker ()\n-    : dom_walker (CDI_DOMINATORS), stack (10)\n+  evrp_dom_walker () : dom_walker (CDI_DOMINATORS)\n     {\n       need_eh_cleanup = BITMAP_ALLOC (NULL);\n     }\n@@ -77,58 +139,33 @@ class evrp_dom_walker : public dom_walker\n \n  private:\n   DISABLE_COPY_AND_ASSIGN (evrp_dom_walker);\n-  void push_value_range (tree var, value_range *vr);\n-  value_range *pop_value_range (tree var);\n-  value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n-\n-  void record_ranges_from_incoming_edge (basic_block);\n-  void record_ranges_from_phis (basic_block);\n-  void record_ranges_from_stmt (gimple *);\n-\n-  /* STACK holds the old VR.  */\n-  auto_vec<std::pair <tree, value_range*> > stack;\n   bitmap need_eh_cleanup;\n   auto_vec<gimple *> stmts_to_fixup;\n   auto_vec<gimple *> stmts_to_remove;\n \n-  class vr_values vr_values;\n+  class evrp_range_analyzer evrp_range_analyzer;\n \n   /* Temporary delegators.  */\n   value_range *get_value_range (const_tree op)\n-    { return vr_values.get_value_range (op); }\n-  bool update_value_range (const_tree op, value_range *vr)\n-    { return vr_values.update_value_range (op, vr); }\n-  void extract_range_from_phi_node (gphi *phi, value_range *vr)\n-    { vr_values.extract_range_from_phi_node (phi, vr); }\n-  void extract_range_for_var_from_comparison_expr (tree var,\n-\t\t\t\t\t\t   enum tree_code cond_code,\n-\t\t\t\t\t\t   tree op, tree limit,\n-\t\t\t\t\t\t   value_range *vr_p)\n-    { vr_values.extract_range_for_var_from_comparison_expr (var, cond_code,\n-\t\t\t\t\t\t\t    op, limit, vr_p); }\n-  void adjust_range_with_scev (value_range *vr, struct loop *loop,\n-\t\t\t       gimple *stmt, tree var)\n-    { vr_values.adjust_range_with_scev (vr, loop, stmt, var); }\n+    { return evrp_range_analyzer.vr_values.get_value_range (op); }\n   tree op_with_constant_singleton_value_range (tree op)\n-    { return vr_values.op_with_constant_singleton_value_range (op); }\n-  void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n-\t\t\t\ttree *output_p, value_range *vr)\n-    { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n-  void set_defs_to_varying (gimple *stmt)\n-    { return vr_values.set_defs_to_varying (stmt); }\n-  void set_vr_value (tree name, value_range *vr)\n-    { vr_values.set_vr_value (name, vr); }\n-  void simplify_cond_using_ranges_2 (gcond *stmt)\n-    { vr_values.simplify_cond_using_ranges_2 (stmt); }\n+    { return evrp_range_analyzer.vr_values.op_with_constant_singleton_value_range (op); }\n   void vrp_visit_cond_stmt (gcond *cond, edge *e)\n-    { vr_values.vrp_visit_cond_stmt (cond, e); }\n+    { evrp_range_analyzer.vr_values.vrp_visit_cond_stmt (cond, e); }\n };\n \n-/*  Find new range for NAME such that (OP CODE LIMIT) is true.  */\n+void\n+evrp_range_analyzer::enter (basic_block bb)\n+{\n+  stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));\n+  record_ranges_from_incoming_edge (bb);\n+  record_ranges_from_phis (bb);\n+}\n \n+/* Find new range for NAME such that (OP CODE LIMIT) is true.  */\n value_range *\n-evrp_dom_walker::try_find_new_range (tree name,\n-\t\t\t\t     tree op, tree_code code, tree limit)\n+evrp_range_analyzer::try_find_new_range (tree name,\n+\t\t\t\t    tree op, tree_code code, tree limit)\n {\n   value_range vr = VR_INITIALIZER;\n   value_range *old_vr = get_value_range (name);\n@@ -155,10 +192,8 @@ evrp_dom_walker::try_find_new_range (tree name,\n    then derive ranges implied by traversing that edge.  */\n \n void\n-evrp_dom_walker::record_ranges_from_incoming_edge (basic_block bb)\n+evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)\n {\n-/* See if there is any new scope is entered with new VR and set that VR to\n-   ssa_name before visiting the statements in the scope.  */\n   edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n   if (pred_e)\n     {\n@@ -207,10 +242,8 @@ evrp_dom_walker::record_ranges_from_incoming_edge (basic_block bb)\n     }\n }\n \n-/* Record ranges from any PHI nodes at the start of basic block BB.  */\n-\n void\n-evrp_dom_walker::record_ranges_from_phis (basic_block bb)\n+evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n {\n   /* Visit PHI stmts and discover any new VRs possible.  */\n   bool has_unvisited_preds = false;\n@@ -231,15 +264,10 @@ evrp_dom_walker::record_ranges_from_phis (basic_block bb)\n       tree lhs = PHI_RESULT (phi);\n       if (virtual_operand_p (lhs))\n \tcontinue;\n+\n       value_range vr_result = VR_INITIALIZER;\n       bool interesting = stmt_interesting_for_vrp (phi);\n-      if (interesting && dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Visiting PHI node \");\n-\t  print_gimple_stmt (dump_file, phi, 0);\n-\t}\n-      if (!has_unvisited_preds\n-\t  && interesting)\n+      if (!has_unvisited_preds && interesting)\n \textract_range_from_phi_node (phi, &vr_result);\n       else\n \t{\n@@ -252,7 +280,7 @@ evrp_dom_walker::record_ranges_from_phis (basic_block bb)\n \t  if (interesting\n \t      && (l = loop_containing_stmt (phi))\n \t      && l->header == gimple_bb (phi))\n-\t    adjust_range_with_scev (&vr_result, l, phi, lhs);\n+\t  adjust_range_with_scev (&vr_result, l, phi, lhs);\n \t}\n       update_value_range (lhs, &vr_result);\n \n@@ -281,7 +309,7 @@ evrp_dom_walker::record_ranges_from_phis (basic_block bb)\n /* Record any ranges created by statement STMT.  */\n \n void\n-evrp_dom_walker::record_ranges_from_stmt (gimple *stmt)\n+evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt)\n {\n   tree output = NULL_TREE;\n \n@@ -300,8 +328,8 @@ evrp_dom_walker::record_ranges_from_stmt (gimple *stmt)\n \t  if (INTEGRAL_TYPE_P (TREE_TYPE (output)))\n \t    {\n \t      if ((vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n-\t\t   && (TREE_CODE (vr.min) == INTEGER_CST)\n-\t\t   && (TREE_CODE (vr.max) == INTEGER_CST))\n+\t\t  && (TREE_CODE (vr.min) == INTEGER_CST)\n+\t\t  && (TREE_CODE (vr.max) == INTEGER_CST))\n \t\tset_range_info (output, vr.type,\n \t\t\t\twi::to_wide (vr.min),\n \t\t\t\twi::to_wide (vr.max));\n@@ -372,9 +400,7 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Visiting BB%d\\n\", bb->index);\n \n-  stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));\n-  record_ranges_from_incoming_edge (bb);\n-  record_ranges_from_phis (bb);\n+  evrp_range_analyzer.enter (bb);\n \n   for (gphi_iterator gpi = gsi_start_phis (bb);\n        !gsi_end_p (gpi); gsi_next (&gpi))\n@@ -411,7 +437,8 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t  print_gimple_stmt (dump_file, stmt, 0);\n \t}\n \n-      record_ranges_from_stmt (stmt);\n+      evrp_range_analyzer.record_ranges_from_stmt (stmt);\n+\n       if (gcond *cond = dyn_cast <gcond *> (stmt))\n \t{\n \t  vrp_visit_cond_stmt (cond, &taken_edge);\n@@ -432,10 +459,10 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t  output = get_output_for_vrp (stmt);\n \t  if (output)\n \t    {\n+\t      tree val;\n \t      vr = *get_value_range (output);\n \n \t      /* Mark stmts whose output we fully propagate for removal.  */\n-\t      tree val;\n \t      if ((vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n \t\t  && (val = op_with_constant_singleton_value_range (output))\n \t\t  && may_propagate_copy (output, val)\n@@ -450,7 +477,7 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \n       /* Try folding stmts with the VR discovered.  */\n       class evrp_folder evrp_folder;\n-      evrp_folder.vr_values = &vr_values;\n+      evrp_folder.vr_values = &evrp_range_analyzer.vr_values;\n       bool did_replace = evrp_folder.replace_uses_in (stmt);\n       if (fold_stmt (&gsi, follow_single_use_edges)\n \t  || did_replace)\n@@ -508,10 +535,16 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n   return taken_edge;\n }\n \n+void\n+evrp_dom_walker::after_dom_children (basic_block bb)\n+{\n+  evrp_range_analyzer.leave (bb);\n+}\n+\n /* Restore/pop VRs valid only for BB when we leave BB.  */\n \n void\n-evrp_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n+evrp_range_analyzer::leave (basic_block bb ATTRIBUTE_UNUSED)\n {\n   gcc_checking_assert (!stack.is_empty ());\n   while (stack.last ().first != NULL_TREE)\n@@ -522,7 +555,7 @@ evrp_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n /* Push the Value Range of VAR to the stack and update it with new VR.  */\n \n void\n-evrp_dom_walker::push_value_range (tree var, value_range *vr)\n+evrp_range_analyzer::push_value_range (tree var, value_range *vr)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -539,7 +572,7 @@ evrp_dom_walker::push_value_range (tree var, value_range *vr)\n /* Pop the Value Range from the vrp_stack and update VAR with it.  */\n \n value_range *\n-evrp_dom_walker::pop_value_range (tree var)\n+evrp_range_analyzer::pop_value_range (tree var)\n {\n   value_range *vr = stack.last ().second;\n   gcc_checking_assert (var == stack.last ().first);\n@@ -564,7 +597,7 @@ evrp_dom_walker::cleanup (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nValue ranges after Early VRP:\\n\\n\");\n-      vr_values.dump_all_value_ranges (dump_file);\n+      evrp_range_analyzer.vr_values.dump_all_value_ranges (dump_file);\n       fprintf (dump_file, \"\\n\");\n     }\n \n@@ -610,10 +643,6 @@ evrp_dom_walker::cleanup (void)\n static unsigned int\n execute_early_vrp ()\n {\n-  edge e;\n-  edge_iterator ei;\n-  basic_block bb;\n-\n   /* Ideally this setup code would move into the ctor for the dominator\n      walk.  However, this setup can change the number of blocks which\n      invalidates the internal arrays that are set up by the dominator\n@@ -622,12 +651,6 @@ execute_early_vrp ()\n   rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n   scev_initialize ();\n   calculate_dominance_info (CDI_DOMINATORS);\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      bb->flags &= ~BB_VISITED;\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\te->flags |= EDGE_EXECUTABLE;\n-    }\n \n   /* Walk stmts in dominance order and propagate VRP.  */\n   evrp_dom_walker walker;"}]}