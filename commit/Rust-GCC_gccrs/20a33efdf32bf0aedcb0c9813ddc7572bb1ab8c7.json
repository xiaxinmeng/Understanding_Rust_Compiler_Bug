{"sha": "20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "node_id": "C_kwDOANBUbNoAKDIwYTMzZWZkZjMyYmYwYWVkY2IwYzk4MTNkZGM3NTcyYmIxYWI4Yzc", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-02-18T21:10:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-02-18T21:12:08Z"}, "message": "libgo: update to Go1.18rc1 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/386594", "tree": {"sha": "94aec72c2092a11fa49f0b45da8e036f13416209", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94aec72c2092a11fa49f0b45da8e036f13416209"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1931cbad498e625b1e24452dcfffe02539b12224", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1931cbad498e625b1e24452dcfffe02539b12224", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1931cbad498e625b1e24452dcfffe02539b12224"}], "stats": {"total": 6676, "additions": 3700, "deletions": 2976}, "files": [{"sha": "073fb4b50a88cc29dbf2dd30ab71d78b033048ad", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -1,4 +1,4 @@\n-90ed127ef053b758288af9c4e43473e257770bc3\n+fade776395ffe5497d8aae5c0e6bd6d15e09e04a\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "11da9a29dd01bf4fdf3a9786a80614a97a720f17", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -1,4 +1,4 @@\n-41f485b9a7d8fd647c415be1d11b612063dff21c\n+cb5a598d7f2ebd276686403d141a97c026d33458\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "e0a1eec52a22a60346c49254e67226c14ac5d225", "filename": "libgo/Makefile.am", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -817,6 +817,7 @@ libgo_go_objs = \\\n \tsyscall/errno.lo \\\n \tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n+\truntime/internal/syscall/errno.lo \\\n \tos/dir_gccgo_c.lo \\\n \t$(golangorg_x_net_lif_lo) \\\n \t$(golangorg_x_net_route_lo) \\\n@@ -1180,6 +1181,11 @@ syscall/wait.lo: go/syscall/wait.c runtime.inc\n \t@$(MKDIR_P) syscall\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/syscall/wait.c\n \n+# Some runtime/internal/syscall functions are written in C.\n+runtime/internal/syscall/errno.lo: go/runtime/internal/syscall/errno.c runtime.inc\n+\t@$(MKDIR_P) runtime/internal/syscall\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/runtime/internal/syscall/errno.c\n+\n # An os function is written in C.\n os/dir_gccgo_c.lo: go/os/dir_gccgo_c.c runtime.inc\n \t@$(MKDIR_P) os"}, {"sha": "7bef5df90d1bf92afbe41ab8e71cc62089e22625", "filename": "libgo/Makefile.in", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -225,7 +225,8 @@ LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_3 = $(addsuffix .lo,$(PACKAGES)) \\\n \tinternal/bytealg/bytealg.lo reflect/makefunc_ffi_c.lo \\\n \t$(am__DEPENDENCIES_1) syscall/errno.lo syscall/signame.lo \\\n-\tsyscall/wait.lo os/dir_gccgo_c.lo $(golangorg_x_net_lif_lo) \\\n+\tsyscall/wait.lo runtime/internal/syscall/errno.lo \\\n+\tos/dir_gccgo_c.lo $(golangorg_x_net_lif_lo) \\\n \t$(golangorg_x_net_route_lo) log/syslog/syslog_c.lo \\\n \truntime/internal/atomic_c.lo sync/atomic_c.lo \\\n \tinternal/cpu/cpu_gccgo.lo $(am__DEPENDENCIES_2)\n@@ -955,6 +956,7 @@ libgo_go_objs = \\\n \tsyscall/errno.lo \\\n \tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n+\truntime/internal/syscall/errno.lo \\\n \tos/dir_gccgo_c.lo \\\n \t$(golangorg_x_net_lif_lo) \\\n \t$(golangorg_x_net_route_lo) \\\n@@ -3091,6 +3093,11 @@ syscall/wait.lo: go/syscall/wait.c runtime.inc\n \t@$(MKDIR_P) syscall\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/syscall/wait.c\n \n+# Some runtime/internal/syscall functions are written in C.\n+runtime/internal/syscall/errno.lo: go/runtime/internal/syscall/errno.c runtime.inc\n+\t@$(MKDIR_P) runtime/internal/syscall\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/runtime/internal/syscall/errno.c\n+\n # An os function is written in C.\n os/dir_gccgo_c.lo: go/os/dir_gccgo_c.c runtime.inc\n \t@$(MKDIR_P) os"}, {"sha": "6a12199bd2175dac675f6cc66a8600f5ffe7a9f9", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -1 +1 @@\n-go1.18beta2\n+go1.18rc1"}, {"sha": "5657be45642f33450aab1d6507bea0f3c9fa22a9", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -95,11 +95,11 @@ type rune = int32\n type any = interface{}\n \n // comparable is an interface that is implemented by all comparable types\n-// (booleans, numbers, strings, pointers, channels, interfaces,\n-// arrays of comparable types, structs whose fields are all comparable types).\n+// (booleans, numbers, strings, pointers, channels, arrays of comparable types,\n+// structs whose fields are all comparable types).\n // The comparable interface may only be used as a type parameter constraint,\n // not as the type of a variable.\n-type comparable comparable\n+type comparable interface{ comparable }\n \n // iota is a predeclared identifier representing the untyped integer ordinal\n // number of the current const specification in a (usually parenthesized)"}, {"sha": "41323ad549bba92c5399dc071e8670de14053814", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -372,6 +372,8 @@ func genSplit(s, sep []byte, sepSave, n int) [][]byte {\n //   n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n //   n == 0: the result is nil (zero subslices)\n //   n < 0: all subslices\n+//\n+// To split around the first instance of a separator, see Cut.\n func SplitN(s, sep []byte, n int) [][]byte { return genSplit(s, sep, 0, n) }\n \n // SplitAfterN slices s into subslices after each instance of sep and\n@@ -389,6 +391,8 @@ func SplitAfterN(s, sep []byte, n int) [][]byte {\n // the subslices between those separators.\n // If sep is empty, Split splits after each UTF-8 sequence.\n // It is equivalent to SplitN with a count of -1.\n+//\n+// To split around the first instance of a separator, see Cut.\n func Split(s, sep []byte) [][]byte { return genSplit(s, sep, 0, -1) }\n \n // SplitAfter slices s into all subslices after each instance of sep and"}, {"sha": "63e7900e02f473877912fdf4c3aa02c928d78554", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -177,14 +177,6 @@\n // \t\tdirectory, but it is not accessed. When -modfile is specified, an\n // \t\talternate go.sum file is also used: its path is derived from the\n // \t\t-modfile flag by trimming the \".mod\" extension and appending \".sum\".\n-// \t-workfile file\n-// \t\tin module aware mode, use the given go.work file as a workspace file.\n-// \t\tBy default or when -workfile is \"auto\", the go command searches for a\n-// \t\tfile named go.work in the current directory and then containing directories\n-// \t\tuntil one is found. If a valid go.work file is found, the modules\n-// \t\tspecified will collectively be used as the main modules. If -workfile\n-// \t\tis \"off\", or a go.work file is not found in \"auto\" mode, workspace\n-// \t\tmode is disabled.\n // \t-overlay file\n // \t\tread a JSON config file that provides an overlay for build operations.\n // \t\tThe file is a JSON struct with a single field, named 'Replace', that\n@@ -1379,7 +1371,7 @@\n // builds from local modules.\n //\n // go.work files are line-oriented. Each line holds a single directive,\n-// made up of a keyword followed by aruments. For example:\n+// made up of a keyword followed by arguments. For example:\n //\n // \tgo 1.18\n //\n@@ -1472,19 +1464,14 @@\n // The -json flag prints the final go.work file in JSON format instead of\n // writing it back to go.mod. The JSON output corresponds to these Go types:\n //\n-// \ttype Module struct {\n-// \t\tPath    string\n-// \t\tVersion string\n-// \t}\n-//\n // \ttype GoWork struct {\n-// \t\tGo        string\n-// \t\tDirectory []Directory\n-// \t\tReplace   []Replace\n+// \t\tGo      string\n+// \t\tUse     []Use\n+// \t\tReplace []Replace\n // \t}\n //\n // \ttype Use struct {\n-// \t\tPath       string\n+// \t\tDiskPath   string\n // \t\tModulePath string\n // \t}\n //\n@@ -1493,6 +1480,11 @@\n // \t\tNew Module\n // \t}\n //\n+// \ttype Module struct {\n+// \t\tPath    string\n+// \t\tVersion string\n+// \t}\n+//\n // See the workspaces design proposal at\n // https://go.googlesource.com/proposal/+/master/design/45713-workspace.md for\n // more information.\n@@ -2036,6 +2028,8 @@\n // \tGOENV\n // \t\tThe location of the Go environment configuration file.\n // \t\tCannot be set using 'go env -w'.\n+// \t\tSetting GOENV=off in the environment disables the use of the\n+// \t\tdefault configuration file.\n // \tGOFLAGS\n // \t\tA space-separated list of -flag=value settings to apply\n // \t\tto go commands by default, when the given flag is known by\n@@ -2073,6 +2067,14 @@\n // \tGOVCS\n // \t\tLists version control commands that may be used with matching servers.\n // \t\tSee 'go help vcs'.\n+// \tGOWORK\n+// \t\tIn module aware mode, use the given go.work file as a workspace file.\n+// \t\tBy default or when GOWORK is \"auto\", the go command searches for a\n+// \t\tfile named go.work in the current directory and then containing directories\n+// \t\tuntil one is found. If a valid go.work file is found, the modules\n+// \t\tspecified will collectively be used as the main modules. If GOWORK\n+// \t\tis \"off\", or a go.work file is not found in \"auto\" mode, workspace\n+// \t\tmode is disabled.\n //\n // Environment variables for use with cgo:\n //"}, {"sha": "1ea347ca6e5dbd2d7a8cabf362c3586bd4583bcd", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -133,7 +133,7 @@ func TestMain(m *testing.M) {\n \t\t}\n \t\tgotool, err := testenv.GoTool()\n \t\tif err != nil {\n-\t\t\tfmt.Fprintln(os.Stderr, err)\n+\t\t\tfmt.Fprintln(os.Stderr, \"locating go tool: \", err)\n \t\t\tos.Exit(2)\n \t\t}\n "}, {"sha": "120420a1265598f9a6e56084abe314cbc512eebc", "filename": "libgo/go/cmd/go/internal/base/flag.go", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -62,13 +62,6 @@ func AddModFlag(flags *flag.FlagSet) {\n \tflags.Var(explicitStringFlag{value: &cfg.BuildMod, explicit: &cfg.BuildModExplicit}, \"mod\", \"\")\n }\n \n-// AddWorkfileFlag adds the workfile flag to the flag set. It enables workspace\n-// mode for commands that support it by resetting the cfg.WorkFile variable\n-// to \"\" (equivalent to auto) rather than off.\n-func AddWorkfileFlag(flags *flag.FlagSet) {\n-\tflags.Var(explicitStringFlag{value: &cfg.WorkFile, explicit: &cfg.WorkFileExplicit}, \"workfile\", \"\")\n-}\n-\n // AddModCommonFlags adds the module-related flags common to build commands\n // and 'go mod' subcommands.\n func AddModCommonFlags(flags *flag.FlagSet) {"}, {"sha": "deab3dddd0dbeaa94e136422d750a8a42bd2c03e", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -49,10 +49,8 @@ var (\n \tBuildWork              bool // -work flag\n \tBuildX                 bool // -x flag\n \n-\tModCacheRW       bool   // -modcacherw flag\n-\tModFile          string // -modfile flag\n-\tWorkFile         string // -workfile flag\n-\tWorkFileExplicit bool   // whether -workfile was set explicitly\n+\tModCacheRW bool   // -modcacherw flag\n+\tModFile    string // -modfile flag\n \n \tCmdName string // \"build\", \"install\", \"list\", \"mod tidy\", etc.\n "}, {"sha": "c1adf8cef4ca1b386042ff17c0da3d9245c9cfb8", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -154,6 +154,10 @@ func ExtraEnvVars() []cfg.EnvVar {\n \t}\n \tmodload.InitWorkfile()\n \tgowork := modload.WorkFilePath()\n+\t// As a special case, if a user set off explicitly, report that in GOWORK.\n+\tif cfg.Getenv(\"GOWORK\") == \"off\" {\n+\t\tgowork = \"off\"\n+\t}\n \treturn []cfg.EnvVar{\n \t\t{Name: \"GOMOD\", Value: gomod},\n \t\t{Name: \"GOWORK\", Value: gowork},"}, {"sha": "28ddaac8f172f62a4fe8368524c57c4946bb1d7b", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -506,6 +506,8 @@ General-purpose environment variables:\n \tGOENV\n \t\tThe location of the Go environment configuration file.\n \t\tCannot be set using 'go env -w'.\n+\t\tSetting GOENV=off in the environment disables the use of the\n+\t\tdefault configuration file.\n \tGOFLAGS\n \t\tA space-separated list of -flag=value settings to apply\n \t\tto go commands by default, when the given flag is known by\n@@ -543,6 +545,14 @@ General-purpose environment variables:\n \tGOVCS\n \t\tLists version control commands that may be used with matching servers.\n \t\tSee 'go help vcs'.\n+\tGOWORK\n+\t\tIn module aware mode, use the given go.work file as a workspace file.\n+\t\tBy default or when GOWORK is \"auto\", the go command searches for a\n+\t\tfile named go.work in the current directory and then containing directories\n+\t\tuntil one is found. If a valid go.work file is found, the modules\n+\t\tspecified will collectively be used as the main modules. If GOWORK\n+\t\tis \"off\", or a go.work file is not found in \"auto\" mode, workspace\n+\t\tmode is disabled.\n \n Environment variables for use with cgo:\n "}, {"sha": "8be921193525cf78c6cd1296f62d13badf1ee432", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -316,7 +316,6 @@ For more about modules, see https://golang.org/ref/mod.\n func init() {\n \tCmdList.Run = runList // break init cycle\n \twork.AddBuildFlags(CmdList, work.DefaultBuildFlags)\n-\tbase.AddWorkfileFlag(&CmdList.Flag)\n }\n \n var ("}, {"sha": "44bd61caea79489e01ada3bdff382fa93d671ad4", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -819,11 +819,11 @@ func loadPackageData(ctx context.Context, path, parentPath, parentDir, parentRoo\n \t}\n \tr := resolvedImportCache.Do(importKey, func() any {\n \t\tvar r resolvedImport\n-\t\tif build.IsLocalImport(path) {\n+\t\tif cfg.ModulesEnabled {\n+\t\t\tr.dir, r.path, r.err = modload.Lookup(parentPath, parentIsStd, path)\n+\t\t} else if build.IsLocalImport(path) {\n \t\t\tr.dir = filepath.Join(parentDir, path)\n \t\t\tr.path = dirToImportPath(r.dir)\n-\t\t} else if cfg.ModulesEnabled {\n-\t\t\tr.dir, r.path, r.err = modload.Lookup(parentPath, parentIsStd, path)\n \t\t} else if mode&ResolveImport != 0 {\n \t\t\t// We do our own path resolution, because we want to\n \t\t\t// find out the key to use in packageCache without the\n@@ -1113,6 +1113,7 @@ func dirAndRoot(path string, dir, root string) (string, string) {\n \t}\n \n \tif !str.HasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator || path != \"command-line-arguments\" && !build.IsLocalImport(path) && filepath.Join(root, path) != dir {\n+\t\tdebug.PrintStack()\n \t\tbase.Fatalf(\"unexpected directory layout:\\n\"+\n \t\t\t\"\timport path: %s\\n\"+\n \t\t\t\"\troot: %s\\n\"+\n@@ -2235,13 +2236,17 @@ func (p *Package) setBuildInfo() {\n \n \tvar debugModFromModinfo func(*modinfo.ModulePublic) *debug.Module\n \tdebugModFromModinfo = func(mi *modinfo.ModulePublic) *debug.Module {\n+\t\tversion := mi.Version\n+\t\tif version == \"\" {\n+\t\t\tversion = \"(devel)\"\n+\t\t}\n \t\tdm := &debug.Module{\n \t\t\tPath:    mi.Path,\n-\t\t\tVersion: mi.Version,\n+\t\t\tVersion: version,\n \t\t}\n \t\tif mi.Replace != nil {\n \t\t\tdm.Replace = debugModFromModinfo(mi.Replace)\n-\t\t} else {\n+\t\t} else if mi.Version != \"\" {\n \t\t\tdm.Sum = modfetch.Sum(module.Version{Path: mi.Path, Version: mi.Version})\n \t\t}\n \t\treturn dm\n@@ -2424,12 +2429,7 @@ func (p *Package) setBuildInfo() {\n \t\tappendSetting(\"vcs.modified\", strconv.FormatBool(st.Uncommitted))\n \t}\n \n-\ttext, err := info.MarshalText()\n-\tif err != nil {\n-\t\tsetPkgErrorf(\"error formatting build info: %v\", err)\n-\t\treturn\n-\t}\n-\tp.Internal.BuildInfo = string(text)\n+\tp.Internal.BuildInfo = info.String()\n }\n \n // SafeArg reports whether arg is a \"safe\" command-line argument,"}, {"sha": "5bc6cbc4bb54124547d61dc14dd566f9afb019eb", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -70,7 +70,6 @@ func init() {\n \t// TODO(jayconrod): https://golang.org/issue/35849 Apply -x to other 'go mod' commands.\n \tcmdDownload.Flag.BoolVar(&cfg.BuildX, \"x\", false, \"\")\n \tbase.AddModCommonFlags(&cmdDownload.Flag)\n-\tbase.AddWorkfileFlag(&cmdDownload.Flag)\n }\n \n type moduleJSON struct {"}, {"sha": "9568c6574044399c6813383625bc932f8eaebfdd", "filename": "libgo/go/cmd/go/internal/modcmd/graph.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -42,7 +42,6 @@ var (\n func init() {\n \tcmdGraph.Flag.Var(&graphGo, \"go\", \"\")\n \tbase.AddModCommonFlags(&cmdGraph.Flag)\n-\tbase.AddWorkfileFlag(&cmdGraph.Flag)\n }\n \n func runGraph(ctx context.Context, cmd *base.Command, args []string) {"}, {"sha": "459bf5d070060fa372bf2291699943b06e122ebe", "filename": "libgo/go/cmd/go/internal/modcmd/verify.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -39,7 +39,6 @@ See https://golang.org/ref/mod#go-mod-verify for more about 'go mod verify'.\n \n func init() {\n \tbase.AddModCommonFlags(&cmdVerify.Flag)\n-\tbase.AddWorkfileFlag(&cmdVerify.Flag)\n }\n \n func runVerify(ctx context.Context, cmd *base.Command, args []string) {"}, {"sha": "2d3f1eb05bcd56065230ce381e8c062546181260", "filename": "libgo/go/cmd/go/internal/modcmd/why.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -59,7 +59,6 @@ var (\n func init() {\n \tcmdWhy.Run = runWhy // break init cycle\n \tbase.AddModCommonFlags(&cmdWhy.Flag)\n-\tbase.AddWorkfileFlag(&cmdWhy.Flag)\n }\n \n func runWhy(ctx context.Context, cmd *base.Command, args []string) {"}, {"sha": "2206c7c8401451a87bdb935e4eb9a3133e7d4381", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 105, "deletions": 111, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -298,16 +298,13 @@ func (r *codeRepo) Latest() (*RevInfo, error) {\n // If statVers is a valid module version, it is used for the Version field.\n // Otherwise, the Version is derived from the passed-in info and recent tags.\n func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, error) {\n-\tinfo2 := &RevInfo{\n-\t\tName:  info.Name,\n-\t\tShort: info.Short,\n-\t\tTime:  info.Time,\n-\t}\n-\n \t// If this is a plain tag (no dir/ prefix)\n \t// and the module path is unversioned,\n \t// and if the underlying file tree has no go.mod,\n \t// then allow using the tag with a +incompatible suffix.\n+\t//\n+\t// (If the version is +incompatible, then the go.mod file must not exist:\n+\t// +incompatible is not an ongoing opt-out from semantic import versioning.)\n \tvar canUseIncompatible func() bool\n \tcanUseIncompatible = func() bool {\n \t\tvar ok bool\n@@ -321,19 +318,12 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\treturn ok\n \t}\n \n-\tinvalidf := func(format string, args ...any) error {\n-\t\treturn &module.ModuleError{\n-\t\t\tPath: r.modPath,\n-\t\t\tErr: &module.InvalidVersionError{\n-\t\t\t\tVersion: info2.Version,\n-\t\t\t\tErr:     fmt.Errorf(format, args...),\n-\t\t\t},\n-\t\t}\n-\t}\n-\n-\t// checkGoMod verifies that the go.mod file for the module exists or does not\n-\t// exist as required by info2.Version and the module path represented by r.\n-\tcheckGoMod := func() (*RevInfo, error) {\n+\t// checkCanonical verifies that the canonical version v is compatible with the\n+\t// module path represented by r, adding a \"+incompatible\" suffix if needed.\n+\t//\n+\t// If statVers is also canonical, checkCanonical also verifies that v is\n+\t// either statVers or statVers with the added \"+incompatible\" suffix.\n+\tcheckCanonical := func(v string) (*RevInfo, error) {\n \t\t// If r.codeDir is non-empty, then the go.mod file must exist: the module\n \t\t// author \u2014 not the module consumer, \u2014 gets to decide how to carve up the repo\n \t\t// into modules.\n@@ -344,73 +334,91 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\t// r.findDir verifies both of these conditions. Execute it now so that\n \t\t// r.Stat will correctly return a notExistError if the go.mod location or\n \t\t// declared module path doesn't match.\n-\t\t_, _, _, err := r.findDir(info2.Version)\n+\t\t_, _, _, err := r.findDir(v)\n \t\tif err != nil {\n \t\t\t// TODO: It would be nice to return an error like \"not a module\".\n \t\t\t// Right now we return \"missing go.mod\", which is a little confusing.\n \t\t\treturn nil, &module.ModuleError{\n \t\t\t\tPath: r.modPath,\n \t\t\t\tErr: &module.InvalidVersionError{\n-\t\t\t\t\tVersion: info2.Version,\n+\t\t\t\t\tVersion: v,\n \t\t\t\t\tErr:     notExistError{err: err},\n \t\t\t\t},\n \t\t\t}\n \t\t}\n \n-\t\t// If the version is +incompatible, then the go.mod file must not exist:\n-\t\t// +incompatible is not an ongoing opt-out from semantic import versioning.\n-\t\tif strings.HasSuffix(info2.Version, \"+incompatible\") {\n-\t\t\tif !canUseIncompatible() {\n+\t\tinvalidf := func(format string, args ...any) error {\n+\t\t\treturn &module.ModuleError{\n+\t\t\t\tPath: r.modPath,\n+\t\t\t\tErr: &module.InvalidVersionError{\n+\t\t\t\t\tVersion: v,\n+\t\t\t\t\tErr:     fmt.Errorf(format, args...),\n+\t\t\t\t},\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Add the +incompatible suffix if needed or requested explicitly, and\n+\t\t// verify that its presence or absence is appropriate for this version\n+\t\t// (which depends on whether it has an explicit go.mod file).\n+\n+\t\tif v == strings.TrimSuffix(statVers, \"+incompatible\") {\n+\t\t\tv = statVers\n+\t\t}\n+\t\tbase := strings.TrimSuffix(v, \"+incompatible\")\n+\t\tvar errIncompatible error\n+\t\tif !module.MatchPathMajor(base, r.pathMajor) {\n+\t\t\tif canUseIncompatible() {\n+\t\t\t\tv = base + \"+incompatible\"\n+\t\t\t} else {\n \t\t\t\tif r.pathMajor != \"\" {\n-\t\t\t\t\treturn nil, invalidf(\"+incompatible suffix not allowed: module path includes a major version suffix, so major version must match\")\n+\t\t\t\t\terrIncompatible = invalidf(\"module path includes a major version suffix, so major version must match\")\n \t\t\t\t} else {\n-\t\t\t\t\treturn nil, invalidf(\"+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required\")\n+\t\t\t\t\terrIncompatible = invalidf(\"module contains a go.mod file, so module path must match major version (%q)\", path.Join(r.pathPrefix, semver.Major(v)))\n \t\t\t\t}\n \t\t\t}\n+\t\t} else if strings.HasSuffix(v, \"+incompatible\") {\n+\t\t\terrIncompatible = invalidf(\"+incompatible suffix not allowed: major version %s is compatible\", semver.Major(v))\n+\t\t}\n \n-\t\t\tif err := module.CheckPathMajor(strings.TrimSuffix(info2.Version, \"+incompatible\"), r.pathMajor); err == nil {\n-\t\t\t\treturn nil, invalidf(\"+incompatible suffix not allowed: major version %s is compatible\", semver.Major(info2.Version))\n+\t\tif statVers != \"\" && statVers == module.CanonicalVersion(statVers) {\n+\t\t\t// Since the caller-requested version is canonical, it would be very\n+\t\t\t// confusing to resolve it to anything but itself, possibly with a\n+\t\t\t// \"+incompatible\" suffix. Error out explicitly.\n+\t\t\tif statBase := strings.TrimSuffix(statVers, \"+incompatible\"); statBase != base {\n+\t\t\t\treturn nil, &module.ModuleError{\n+\t\t\t\t\tPath: r.modPath,\n+\t\t\t\t\tErr: &module.InvalidVersionError{\n+\t\t\t\t\t\tVersion: statVers,\n+\t\t\t\t\t\tErr:     fmt.Errorf(\"resolves to version %v (%s is not a tag)\", v, statBase),\n+\t\t\t\t\t},\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\treturn info2, nil\n+\t\tif errIncompatible != nil {\n+\t\t\treturn nil, errIncompatible\n+\t\t}\n+\n+\t\treturn &RevInfo{\n+\t\t\tName:    info.Name,\n+\t\t\tShort:   info.Short,\n+\t\t\tTime:    info.Time,\n+\t\t\tVersion: v,\n+\t\t}, nil\n \t}\n \n \t// Determine version.\n-\t//\n-\t// If statVers is canonical, then the original call was repo.Stat(statVers).\n-\t// Since the version is canonical, we must not resolve it to anything but\n-\t// itself, possibly with a '+incompatible' annotation: we do not need to do\n-\t// the work required to look for an arbitrary pseudo-version.\n-\tif statVers != \"\" && statVers == module.CanonicalVersion(statVers) {\n-\t\tinfo2.Version = statVers\n-\n-\t\tif module.IsPseudoVersion(info2.Version) {\n-\t\t\tif err := r.validatePseudoVersion(info, info2.Version); err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\treturn checkGoMod()\n-\t\t}\n \n-\t\tif err := module.CheckPathMajor(info2.Version, r.pathMajor); err != nil {\n-\t\t\tif canUseIncompatible() {\n-\t\t\t\tinfo2.Version += \"+incompatible\"\n-\t\t\t\treturn checkGoMod()\n-\t\t\t} else {\n-\t\t\t\tif vErr, ok := err.(*module.InvalidVersionError); ok {\n-\t\t\t\t\t// We're going to describe why the version is invalid in more detail,\n-\t\t\t\t\t// so strip out the existing \u201cinvalid version\u201d wrapper.\n-\t\t\t\t\terr = vErr.Err\n-\t\t\t\t}\n-\t\t\t\treturn nil, invalidf(\"module contains a go.mod file, so major version must be compatible: %v\", err)\n-\t\t\t}\n+\tif module.IsPseudoVersion(statVers) {\n+\t\tif err := r.validatePseudoVersion(info, statVers); err != nil {\n+\t\t\treturn nil, err\n \t\t}\n-\n-\t\treturn checkGoMod()\n+\t\treturn checkCanonical(statVers)\n \t}\n \n-\t// statVers is empty or non-canonical, so we need to resolve it to a canonical\n-\t// version or pseudo-version.\n+\t// statVers is not a pseudo-version, so we need to either resolve it to a\n+\t// canonical version or verify that it is already a canonical tag\n+\t// (not a branch).\n \n \t// Derive or verify a version from a code repo tag.\n \t// Tag must have a prefix matching codeDir.\n@@ -441,71 +449,62 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\tif v == \"\" || !strings.HasPrefix(trimmed, v) {\n \t\t\treturn \"\", false // Invalid or incomplete version (just vX or vX.Y).\n \t\t}\n-\t\tif isRetracted(v) {\n-\t\t\treturn \"\", false\n-\t\t}\n \t\tif v == trimmed {\n \t\t\ttagIsCanonical = true\n \t\t}\n-\n-\t\tif err := module.CheckPathMajor(v, r.pathMajor); err != nil {\n-\t\t\tif canUseIncompatible() {\n-\t\t\t\treturn v + \"+incompatible\", tagIsCanonical\n-\t\t\t}\n-\t\t\treturn \"\", false\n-\t\t}\n-\n \t\treturn v, tagIsCanonical\n \t}\n \n \t// If the VCS gave us a valid version, use that.\n \tif v, tagIsCanonical := tagToVersion(info.Version); tagIsCanonical {\n-\t\tinfo2.Version = v\n-\t\treturn checkGoMod()\n+\t\tif info, err := checkCanonical(v); err == nil {\n+\t\t\treturn info, err\n+\t\t}\n \t}\n \n \t// Look through the tags on the revision for either a usable canonical version\n \t// or an appropriate base for a pseudo-version.\n-\tvar pseudoBase string\n+\tvar (\n+\t\thighestCanonical string\n+\t\tpseudoBase       string\n+\t)\n \tfor _, pathTag := range info.Tags {\n \t\tv, tagIsCanonical := tagToVersion(pathTag)\n-\t\tif tagIsCanonical {\n-\t\t\tif statVers != \"\" && semver.Compare(v, statVers) == 0 {\n-\t\t\t\t// The user requested a non-canonical version, but the tag for the\n-\t\t\t\t// canonical equivalent refers to the same revision. Use it.\n-\t\t\t\tinfo2.Version = v\n-\t\t\t\treturn checkGoMod()\n+\t\tif statVers != \"\" && semver.Compare(v, statVers) == 0 {\n+\t\t\t// The tag is equivalent to the version requested by the user.\n+\t\t\tif tagIsCanonical {\n+\t\t\t\t// This tag is the canonical form of the requested version,\n+\t\t\t\t// not some other form with extra build metadata.\n+\t\t\t\t// Use this tag so that the resolved version will match exactly.\n+\t\t\t\t// (If it isn't actually allowed, we'll error out in checkCanonical.)\n+\t\t\t\treturn checkCanonical(v)\n \t\t\t} else {\n-\t\t\t\t// Save the highest canonical tag for the revision. If we don't find a\n-\t\t\t\t// better match, we'll use it as the canonical version.\n+\t\t\t\t// The user explicitly requested something equivalent to this tag. We\n+\t\t\t\t// can't use the version from the tag directly: since the tag is not\n+\t\t\t\t// canonical, it could be ambiguous. For example, tags v0.0.1+a and\n+\t\t\t\t// v0.0.1+b might both exist and refer to different revisions.\n \t\t\t\t//\n-\t\t\t\t// NOTE: Do not replace this with semver.Max. Despite the name,\n-\t\t\t\t// semver.Max *also* canonicalizes its arguments, which uses\n-\t\t\t\t// semver.Canonical instead of module.CanonicalVersion and thereby\n-\t\t\t\t// strips our \"+incompatible\" suffix.\n-\t\t\t\tif semver.Compare(info2.Version, v) < 0 {\n-\t\t\t\t\tinfo2.Version = v\n-\t\t\t\t}\n+\t\t\t\t// The tag is otherwise valid for the module, so we can at least use it as\n+\t\t\t\t// the base of an unambiguous pseudo-version.\n+\t\t\t\t//\n+\t\t\t\t// If multiple tags match, tagToVersion will canonicalize them to the same\n+\t\t\t\t// base version.\n+\t\t\t\tpseudoBase = v\n+\t\t\t}\n+\t\t}\n+\t\t// Save the highest non-retracted canonical tag for the revision.\n+\t\t// If we don't find a better match, we'll use it as the canonical version.\n+\t\tif tagIsCanonical && semver.Compare(highestCanonical, v) < 0 && !isRetracted(v) {\n+\t\t\tif module.MatchPathMajor(v, r.pathMajor) || canUseIncompatible() {\n+\t\t\t\thighestCanonical = v\n \t\t\t}\n-\t\t} else if v != \"\" && semver.Compare(v, statVers) == 0 {\n-\t\t\t// The user explicitly requested something equivalent to this tag. We\n-\t\t\t// can't use the version from the tag directly: since the tag is not\n-\t\t\t// canonical, it could be ambiguous. For example, tags v0.0.1+a and\n-\t\t\t// v0.0.1+b might both exist and refer to different revisions.\n-\t\t\t//\n-\t\t\t// The tag is otherwise valid for the module, so we can at least use it as\n-\t\t\t// the base of an unambiguous pseudo-version.\n-\t\t\t//\n-\t\t\t// If multiple tags match, tagToVersion will canonicalize them to the same\n-\t\t\t// base version.\n-\t\t\tpseudoBase = v\n \t\t}\n \t}\n \n-\t// If we found any canonical tag for the revision, return it.\n+\t// If we found a valid canonical tag for the revision, return it.\n \t// Even if we found a good pseudo-version base, a canonical version is better.\n-\tif info2.Version != \"\" {\n-\t\treturn checkGoMod()\n+\tif highestCanonical != \"\" {\n+\t\treturn checkCanonical(highestCanonical)\n \t}\n \n \t// Find the highest tagged version in the revision's history, subject to\n@@ -528,11 +527,10 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\t\t\ttag, _ = r.code.RecentTag(info.Name, tagPrefix, allowedMajor(\"v0\"))\n \t\t\t}\n \t\t}\n-\t\tpseudoBase, _ = tagToVersion(tag) // empty if the tag is invalid\n+\t\tpseudoBase, _ = tagToVersion(tag)\n \t}\n \n-\tinfo2.Version = module.PseudoVersion(r.pseudoMajor, pseudoBase, info.Time, info.Short)\n-\treturn checkGoMod()\n+\treturn checkCanonical(module.PseudoVersion(r.pseudoMajor, pseudoBase, info.Time, info.Short))\n }\n \n // validatePseudoVersion checks that version has a major version compatible with\n@@ -556,10 +554,6 @@ func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)\n \t\t}\n \t}()\n \n-\tif err := module.CheckPathMajor(version, r.pathMajor); err != nil {\n-\t\treturn err\n-\t}\n-\n \trev, err := module.PseudoVersionRev(version)\n \tif err != nil {\n \t\treturn err"}, {"sha": "d98ea87da2c3dfe36a7448eee0ca3cc087784a75", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo_test.go", "status": "modified", "additions": 167, "deletions": 134, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -418,171 +418,204 @@ var codeRepoTests = []codeRepoTest{\n \t\tzipSum:      \"h1:JItBZ+gwA5WvtZEGEbuDL4lUttGtLrs53lmdurq3bOg=\",\n \t\tzipFileHash: \"9ea9ae1673cffcc44b7fdd3cc89953d68c102449b46c982dbf085e4f2e394da5\",\n \t},\n+\t{\n+\t\t// Git branch with a semver name, +incompatible version, and no go.mod file.\n+\t\tvcs:  \"git\",\n+\t\tpath: \"vcs-test.golang.org/go/mod/gitrepo1\",\n+\t\trev:  \"v2.3.4+incompatible\",\n+\t\terr:  `resolves to version v2.0.1+incompatible (v2.3.4 is not a tag)`,\n+\t},\n+\t{\n+\t\t// Git branch with a semver name, matching go.mod file, and compatible version.\n+\t\tvcs:  \"git\",\n+\t\tpath: \"vcs-test.golang.org/git/semver-branch.git\",\n+\t\trev:  \"v1.0.0\",\n+\t\terr:  `resolves to version v0.1.1-0.20220202191944-09c4d8f6938c (v1.0.0 is not a tag)`,\n+\t},\n+\t{\n+\t\t// Git branch with a semver name, matching go.mod file, and disallowed +incompatible version.\n+\t\t// The version/tag mismatch takes precedence over the +incompatible mismatched.\n+\t\tvcs:  \"git\",\n+\t\tpath: \"vcs-test.golang.org/git/semver-branch.git\",\n+\t\trev:  \"v2.0.0+incompatible\",\n+\t\terr:  `resolves to version v0.1.0 (v2.0.0 is not a tag)`,\n+\t},\n+\t{\n+\t\t// Git branch with a semver name, matching go.mod file, and mismatched version.\n+\t\t// The version/tag mismatch takes precedence over the +incompatible mismatched.\n+\t\tvcs:  \"git\",\n+\t\tpath: \"vcs-test.golang.org/git/semver-branch.git\",\n+\t\trev:  \"v2.0.0\",\n+\t\terr:  `resolves to version v0.1.0 (v2.0.0 is not a tag)`,\n+\t},\n+\t{\n+\t\t// v3.0.0-devel is the same as tag v4.0.0-beta.1, but v4.0.0-beta.1 would\n+\t\t// not be allowed because it is incompatible and a go.mod file exists.\n+\t\t// The error message should refer to a valid pseudo-version, not the\n+\t\t// unusable semver tag.\n+\t\tvcs:  \"git\",\n+\t\tpath: \"vcs-test.golang.org/git/semver-branch.git\",\n+\t\trev:  \"v3.0.0-devel\",\n+\t\terr:  `resolves to version v0.1.1-0.20220203155313-d59622f6e4d7 (v3.0.0-devel is not a tag)`,\n+\t},\n }\n \n func TestCodeRepo(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttmpdir := t.TempDir()\n \n-\ttmpdir, err := os.MkdirTemp(\"\", \"modfetch-test-\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer os.RemoveAll(tmpdir)\n+\tfor _, tt := range codeRepoTests {\n+\t\tf := func(tt codeRepoTest) func(t *testing.T) {\n+\t\t\treturn func(t *testing.T) {\n+\t\t\t\tt.Parallel()\n+\t\t\t\tif tt.vcs != \"mod\" {\n+\t\t\t\t\ttestenv.MustHaveExecPath(t, tt.vcs)\n+\t\t\t\t}\n \n-\tt.Run(\"parallel\", func(t *testing.T) {\n-\t\tfor _, tt := range codeRepoTests {\n-\t\t\tf := func(tt codeRepoTest) func(t *testing.T) {\n-\t\t\t\treturn func(t *testing.T) {\n-\t\t\t\t\tt.Parallel()\n-\t\t\t\t\tif tt.vcs != \"mod\" {\n-\t\t\t\t\t\ttestenv.MustHaveExecPath(t, tt.vcs)\n-\t\t\t\t\t}\n+\t\t\t\trepo := Lookup(\"direct\", tt.path)\n \n-\t\t\t\t\trepo := Lookup(\"direct\", tt.path)\n+\t\t\t\tif tt.mpath == \"\" {\n+\t\t\t\t\ttt.mpath = tt.path\n+\t\t\t\t}\n+\t\t\t\tif mpath := repo.ModulePath(); mpath != tt.mpath {\n+\t\t\t\t\tt.Errorf(\"repo.ModulePath() = %q, want %q\", mpath, tt.mpath)\n+\t\t\t\t}\n \n-\t\t\t\t\tif tt.mpath == \"\" {\n-\t\t\t\t\t\ttt.mpath = tt.path\n-\t\t\t\t\t}\n-\t\t\t\t\tif mpath := repo.ModulePath(); mpath != tt.mpath {\n-\t\t\t\t\t\tt.Errorf(\"repo.ModulePath() = %q, want %q\", mpath, tt.mpath)\n+\t\t\t\tinfo, err := repo.Stat(tt.rev)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tif tt.err != \"\" {\n+\t\t\t\t\t\tif !strings.Contains(err.Error(), tt.err) {\n+\t\t\t\t\t\t\tt.Fatalf(\"repoStat(%q): %v, wanted %q\", tt.rev, err, tt.err)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n \t\t\t\t\t}\n+\t\t\t\t\tt.Fatalf(\"repo.Stat(%q): %v\", tt.rev, err)\n+\t\t\t\t}\n+\t\t\t\tif tt.err != \"\" {\n+\t\t\t\t\tt.Errorf(\"repo.Stat(%q): success, wanted error\", tt.rev)\n+\t\t\t\t}\n+\t\t\t\tif info.Version != tt.version {\n+\t\t\t\t\tt.Errorf(\"info.Version = %q, want %q\", info.Version, tt.version)\n+\t\t\t\t}\n+\t\t\t\tif info.Name != tt.name {\n+\t\t\t\t\tt.Errorf(\"info.Name = %q, want %q\", info.Name, tt.name)\n+\t\t\t\t}\n+\t\t\t\tif info.Short != tt.short {\n+\t\t\t\t\tt.Errorf(\"info.Short = %q, want %q\", info.Short, tt.short)\n+\t\t\t\t}\n+\t\t\t\tif !info.Time.Equal(tt.time) {\n+\t\t\t\t\tt.Errorf(\"info.Time = %v, want %v\", info.Time, tt.time)\n+\t\t\t\t}\n \n-\t\t\t\t\tinfo, err := repo.Stat(tt.rev)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tif tt.err != \"\" {\n-\t\t\t\t\t\t\tif !strings.Contains(err.Error(), tt.err) {\n-\t\t\t\t\t\t\t\tt.Fatalf(\"repoStat(%q): %v, wanted %q\", tt.rev, err, tt.err)\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\treturn\n+\t\t\t\tif tt.gomod != \"\" || tt.gomodErr != \"\" {\n+\t\t\t\t\tdata, err := repo.GoMod(tt.version)\n+\t\t\t\t\tif err != nil && tt.gomodErr == \"\" {\n+\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q): %v\", tt.version, err)\n+\t\t\t\t\t} else if err != nil && tt.gomodErr != \"\" {\n+\t\t\t\t\t\tif err.Error() != tt.gomodErr {\n+\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q): %v, want %q\", tt.version, err, tt.gomodErr)\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tt.Fatalf(\"repo.Stat(%q): %v\", tt.rev, err)\n-\t\t\t\t\t}\n-\t\t\t\t\tif tt.err != \"\" {\n-\t\t\t\t\t\tt.Errorf(\"repo.Stat(%q): success, wanted error\", tt.rev)\n-\t\t\t\t\t}\n-\t\t\t\t\tif info.Version != tt.version {\n-\t\t\t\t\t\tt.Errorf(\"info.Version = %q, want %q\", info.Version, tt.version)\n+\t\t\t\t\t} else if tt.gomodErr != \"\" {\n+\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q) = %q, want error %q\", tt.version, data, tt.gomodErr)\n+\t\t\t\t\t} else if string(data) != tt.gomod {\n+\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q) = %q, want %q\", tt.version, data, tt.gomod)\n \t\t\t\t\t}\n-\t\t\t\t\tif info.Name != tt.name {\n-\t\t\t\t\t\tt.Errorf(\"info.Name = %q, want %q\", info.Name, tt.name)\n-\t\t\t\t\t}\n-\t\t\t\t\tif info.Short != tt.short {\n-\t\t\t\t\t\tt.Errorf(\"info.Short = %q, want %q\", info.Short, tt.short)\n+\t\t\t\t}\n+\n+\t\t\t\tneedHash := !testing.Short() && (tt.zipFileHash != \"\" || tt.zipSum != \"\")\n+\t\t\t\tif tt.zip != nil || tt.zipErr != \"\" || needHash {\n+\t\t\t\t\tf, err := os.CreateTemp(tmpdir, tt.version+\".zip.\")\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tt.Fatalf(\"os.CreateTemp: %v\", err)\n \t\t\t\t\t}\n-\t\t\t\t\tif !info.Time.Equal(tt.time) {\n-\t\t\t\t\t\tt.Errorf(\"info.Time = %v, want %v\", info.Time, tt.time)\n+\t\t\t\t\tzipfile := f.Name()\n+\t\t\t\t\tdefer func() {\n+\t\t\t\t\t\tf.Close()\n+\t\t\t\t\t\tos.Remove(zipfile)\n+\t\t\t\t\t}()\n+\n+\t\t\t\t\tvar w io.Writer\n+\t\t\t\t\tvar h hash.Hash\n+\t\t\t\t\tif needHash {\n+\t\t\t\t\t\th = sha256.New()\n+\t\t\t\t\t\tw = io.MultiWriter(f, h)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tw = f\n \t\t\t\t\t}\n-\n-\t\t\t\t\tif tt.gomod != \"\" || tt.gomodErr != \"\" {\n-\t\t\t\t\t\tdata, err := repo.GoMod(tt.version)\n-\t\t\t\t\t\tif err != nil && tt.gomodErr == \"\" {\n-\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q): %v\", tt.version, err)\n-\t\t\t\t\t\t} else if err != nil && tt.gomodErr != \"\" {\n-\t\t\t\t\t\t\tif err.Error() != tt.gomodErr {\n-\t\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q): %v, want %q\", tt.version, err, tt.gomodErr)\n+\t\t\t\t\terr = repo.Zip(w, tt.version)\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tif tt.zipErr != \"\" {\n+\t\t\t\t\t\t\tif err.Error() == tt.zipErr {\n+\t\t\t\t\t\t\t\treturn\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else if tt.gomodErr != \"\" {\n-\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q) = %q, want error %q\", tt.version, data, tt.gomodErr)\n-\t\t\t\t\t\t} else if string(data) != tt.gomod {\n-\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q) = %q, want %q\", tt.version, data, tt.gomod)\n+\t\t\t\t\t\t\tt.Fatalf(\"repo.Zip(%q): %v, want error %q\", tt.version, err, tt.zipErr)\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tt.Fatalf(\"repo.Zip(%q): %v\", tt.version, err)\n+\t\t\t\t\t}\n+\t\t\t\t\tif tt.zipErr != \"\" {\n+\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): success, want error %q\", tt.version, tt.zipErr)\n \t\t\t\t\t}\n \n-\t\t\t\t\tneedHash := !testing.Short() && (tt.zipFileHash != \"\" || tt.zipSum != \"\")\n-\t\t\t\t\tif tt.zip != nil || tt.zipErr != \"\" || needHash {\n-\t\t\t\t\t\tf, err := os.CreateTemp(tmpdir, tt.version+\".zip.\")\n+\t\t\t\t\tif tt.zip != nil {\n+\t\t\t\t\t\tprefix := tt.path + \"@\" + tt.version + \"/\"\n+\t\t\t\t\t\tz, err := zip.OpenReader(zipfile)\n \t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\tt.Fatalf(\"os.CreateTemp: %v\", err)\n+\t\t\t\t\t\t\tt.Fatalf(\"open zip %s: %v\", zipfile, err)\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tzipfile := f.Name()\n-\t\t\t\t\t\tdefer func() {\n-\t\t\t\t\t\t\tf.Close()\n-\t\t\t\t\t\t\tos.Remove(zipfile)\n-\t\t\t\t\t\t}()\n-\n-\t\t\t\t\t\tvar w io.Writer\n-\t\t\t\t\t\tvar h hash.Hash\n-\t\t\t\t\t\tif needHash {\n-\t\t\t\t\t\t\th = sha256.New()\n-\t\t\t\t\t\t\tw = io.MultiWriter(f, h)\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tw = f\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\terr = repo.Zip(w, tt.version)\n-\t\t\t\t\t\tf.Close()\n-\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\tif tt.zipErr != \"\" {\n-\t\t\t\t\t\t\t\tif err.Error() == tt.zipErr {\n-\t\t\t\t\t\t\t\t\treturn\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tt.Fatalf(\"repo.Zip(%q): %v, want error %q\", tt.version, err, tt.zipErr)\n+\t\t\t\t\t\tvar names []string\n+\t\t\t\t\t\tfor _, file := range z.File {\n+\t\t\t\t\t\t\tif !strings.HasPrefix(file.Name, prefix) {\n+\t\t\t\t\t\t\t\tt.Errorf(\"zip entry %v does not start with prefix %v\", file.Name, prefix)\n+\t\t\t\t\t\t\t\tcontinue\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tt.Fatalf(\"repo.Zip(%q): %v\", tt.version, err)\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif tt.zipErr != \"\" {\n-\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): success, want error %q\", tt.version, tt.zipErr)\n+\t\t\t\t\t\t\tnames = append(names, file.Name[len(prefix):])\n \t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif tt.zip != nil {\n-\t\t\t\t\t\t\tprefix := tt.path + \"@\" + tt.version + \"/\"\n-\t\t\t\t\t\t\tz, err := zip.OpenReader(zipfile)\n-\t\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\t\tt.Fatalf(\"open zip %s: %v\", zipfile, err)\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tvar names []string\n-\t\t\t\t\t\t\tfor _, file := range z.File {\n-\t\t\t\t\t\t\t\tif !strings.HasPrefix(file.Name, prefix) {\n-\t\t\t\t\t\t\t\t\tt.Errorf(\"zip entry %v does not start with prefix %v\", file.Name, prefix)\n-\t\t\t\t\t\t\t\t\tcontinue\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tnames = append(names, file.Name[len(prefix):])\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tz.Close()\n-\t\t\t\t\t\t\tif !reflect.DeepEqual(names, tt.zip) {\n-\t\t\t\t\t\t\t\tt.Fatalf(\"zip = %v\\nwant %v\\n\", names, tt.zip)\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\tz.Close()\n+\t\t\t\t\t\tif !reflect.DeepEqual(names, tt.zip) {\n+\t\t\t\t\t\t\tt.Fatalf(\"zip = %v\\nwant %v\\n\", names, tt.zip)\n \t\t\t\t\t\t}\n+\t\t\t\t\t}\n \n-\t\t\t\t\t\tif needHash {\n-\t\t\t\t\t\t\tsum, err := dirhash.HashZip(zipfile, dirhash.Hash1)\n-\t\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): %v\", tt.version, err)\n-\t\t\t\t\t\t\t} else if sum != tt.zipSum {\n-\t\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): got file with sum %q, want %q\", tt.version, sum, tt.zipSum)\n-\t\t\t\t\t\t\t} else if zipFileHash := hex.EncodeToString(h.Sum(nil)); zipFileHash != tt.zipFileHash {\n-\t\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): got file with hash %q, want %q (but content has correct sum)\", tt.version, zipFileHash, tt.zipFileHash)\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\tif needHash {\n+\t\t\t\t\t\tsum, err := dirhash.HashZip(zipfile, dirhash.Hash1)\n+\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): %v\", tt.version, err)\n+\t\t\t\t\t\t} else if sum != tt.zipSum {\n+\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): got file with sum %q, want %q\", tt.version, sum, tt.zipSum)\n+\t\t\t\t\t\t} else if zipFileHash := hex.EncodeToString(h.Sum(nil)); zipFileHash != tt.zipFileHash {\n+\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): got file with hash %q, want %q (but content has correct sum)\", tt.version, zipFileHash, tt.zipFileHash)\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.rev, f(tt))\n-\t\t\tif strings.HasPrefix(tt.path, vgotest1git) {\n-\t\t\t\tfor vcs, alt := range altVgotests {\n-\t\t\t\t\taltTest := tt\n-\t\t\t\t\taltTest.vcs = vcs\n-\t\t\t\t\taltTest.path = alt + strings.TrimPrefix(altTest.path, vgotest1git)\n-\t\t\t\t\tif strings.HasPrefix(altTest.mpath, vgotest1git) {\n-\t\t\t\t\t\taltTest.mpath = alt + strings.TrimPrefix(altTest.mpath, vgotest1git)\n-\t\t\t\t\t}\n-\t\t\t\t\tvar m map[string]string\n-\t\t\t\t\tif alt == vgotest1hg {\n-\t\t\t\t\t\tm = hgmap\n-\t\t\t\t\t}\n-\t\t\t\t\taltTest.version = remap(altTest.version, m)\n-\t\t\t\t\taltTest.name = remap(altTest.name, m)\n-\t\t\t\t\taltTest.short = remap(altTest.short, m)\n-\t\t\t\t\taltTest.rev = remap(altTest.rev, m)\n-\t\t\t\t\taltTest.err = remap(altTest.err, m)\n-\t\t\t\t\taltTest.gomodErr = remap(altTest.gomodErr, m)\n-\t\t\t\t\taltTest.zipErr = remap(altTest.zipErr, m)\n-\t\t\t\t\taltTest.zipSum = \"\"\n-\t\t\t\t\taltTest.zipFileHash = \"\"\n-\t\t\t\t\tt.Run(strings.ReplaceAll(altTest.path, \"/\", \"_\")+\"/\"+altTest.rev, f(altTest))\n+\t\t}\n+\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.rev, f(tt))\n+\t\tif strings.HasPrefix(tt.path, vgotest1git) {\n+\t\t\tfor vcs, alt := range altVgotests {\n+\t\t\t\taltTest := tt\n+\t\t\t\taltTest.vcs = vcs\n+\t\t\t\taltTest.path = alt + strings.TrimPrefix(altTest.path, vgotest1git)\n+\t\t\t\tif strings.HasPrefix(altTest.mpath, vgotest1git) {\n+\t\t\t\t\taltTest.mpath = alt + strings.TrimPrefix(altTest.mpath, vgotest1git)\n+\t\t\t\t}\n+\t\t\t\tvar m map[string]string\n+\t\t\t\tif alt == vgotest1hg {\n+\t\t\t\t\tm = hgmap\n \t\t\t\t}\n+\t\t\t\taltTest.version = remap(altTest.version, m)\n+\t\t\t\taltTest.name = remap(altTest.name, m)\n+\t\t\t\taltTest.short = remap(altTest.short, m)\n+\t\t\t\taltTest.rev = remap(altTest.rev, m)\n+\t\t\t\taltTest.err = remap(altTest.err, m)\n+\t\t\t\taltTest.gomodErr = remap(altTest.gomodErr, m)\n+\t\t\t\taltTest.zipErr = remap(altTest.zipErr, m)\n+\t\t\t\taltTest.zipSum = \"\"\n+\t\t\t\taltTest.zipFileHash = \"\"\n+\t\t\t\tt.Run(strings.ReplaceAll(altTest.path, \"/\", \"_\")+\"/\"+altTest.rev, f(altTest))\n \t\t\t}\n \t\t}\n-\t})\n+\t}\n }\n \n var hgmap = map[string]string{"}, {"sha": "21d5f54688fe7f465ba6da1330212b9f2c23eff2", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -319,7 +319,7 @@ func downloadZip(ctx context.Context, mod module.Version, zipfile string) (err e\n //\n // If the hash does not match go.sum (or the sumdb if enabled), hashZip returns\n // an error and does not write ziphashfile.\n-func hashZip(mod module.Version, zipfile, ziphashfile string) error {\n+func hashZip(mod module.Version, zipfile, ziphashfile string) (err error) {\n \thash, err := dirhash.HashZip(zipfile, dirhash.DefaultHash)\n \tif err != nil {\n \t\treturn err\n@@ -331,16 +331,17 @@ func hashZip(mod module.Version, zipfile, ziphashfile string) error {\n \tif err != nil {\n \t\treturn err\n \t}\n+\tdefer func() {\n+\t\tif closeErr := hf.Close(); err == nil && closeErr != nil {\n+\t\t\terr = closeErr\n+\t\t}\n+\t}()\n \tif err := hf.Truncate(int64(len(hash))); err != nil {\n \t\treturn err\n \t}\n \tif _, err := hf.WriteAt([]byte(hash), 0); err != nil {\n \t\treturn err\n \t}\n-\tif err := hf.Close(); err != nil {\n-\t\treturn err\n-\t}\n-\n \treturn nil\n }\n "}, {"sha": "4862f625b48ed99a9158f7a8fe3feaa5936139f9", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -248,12 +248,26 @@ func (e *invalidImportError) Unwrap() error {\n // return the module, its root directory, and a list of other modules that\n // lexically could have provided the package but did not.\n func importFromModules(ctx context.Context, path string, rs *Requirements, mg *ModuleGraph) (m module.Version, dir string, altMods []module.Version, err error) {\n+\tinvalidf := func(format string, args ...interface{}) (module.Version, string, []module.Version, error) {\n+\t\treturn module.Version{}, \"\", nil, &invalidImportError{\n+\t\t\timportPath: path,\n+\t\t\terr:        fmt.Errorf(format, args...),\n+\t\t}\n+\t}\n+\n \tif strings.Contains(path, \"@\") {\n-\t\treturn module.Version{}, \"\", nil, fmt.Errorf(\"import path should not have @version\")\n+\t\treturn invalidf(\"import path %q should not have @version\", path)\n \t}\n \tif build.IsLocalImport(path) {\n-\t\treturn module.Version{}, \"\", nil, fmt.Errorf(\"relative import not supported\")\n+\t\treturn invalidf(\"%q is relative, but relative import paths are not supported in module mode\", path)\n \t}\n+\tif filepath.IsAbs(path) {\n+\t\treturn invalidf(\"%q is not a package path; see 'go help packages'\", path)\n+\t}\n+\tif search.IsMetaPackage(path) {\n+\t\treturn invalidf(\"%q is not an importable package; see 'go help packages'\", path)\n+\t}\n+\n \tif path == \"C\" {\n \t\t// There's no directory for import \"C\".\n \t\treturn module.Version{}, \"\", nil, nil"}, {"sha": "a07066696e8ab7bd4d971ae9950c0843dc3da8c4", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -288,20 +288,20 @@ func BinDir() string {\n // operate in workspace mode. It should not be called by other commands,\n // for example 'go mod tidy', that don't operate in workspace mode.\n func InitWorkfile() {\n-\tswitch cfg.WorkFile {\n+\tswitch gowork := cfg.Getenv(\"GOWORK\"); gowork {\n \tcase \"off\":\n \t\tworkFilePath = \"\"\n \tcase \"\", \"auto\":\n \t\tworkFilePath = findWorkspaceFile(base.Cwd())\n \tdefault:\n-\t\tif !filepath.IsAbs(cfg.WorkFile) {\n-\t\t\tbase.Fatalf(\"the path provided to -workfile must be an absolute path\")\n+\t\tif !filepath.IsAbs(gowork) {\n+\t\t\tbase.Fatalf(\"the path provided to GOWORK must be an absolute path\")\n \t\t}\n-\t\tworkFilePath = cfg.WorkFile\n+\t\tworkFilePath = gowork\n \t}\n }\n \n-// WorkFilePath returns the path of the go.work file, or \"\" if not in\n+// WorkFilePath returns the absolute path of the go.work file, or \"\" if not in\n // workspace mode. WorkFilePath must be called after InitWorkfile.\n func WorkFilePath() string {\n \treturn workFilePath\n@@ -610,6 +610,9 @@ func UpdateWorkFile(wf *modfile.WorkFile) {\n \tmissingModulePaths := map[string]string{} // module directory listed in file -> abspath modroot\n \n \tfor _, d := range wf.Use {\n+\t\tif d.Path == \"\" {\n+\t\t\tcontinue // d is marked for deletion.\n+\t\t}\n \t\tmodRoot := d.Path\n \t\tif d.ModulePath == \"\" {\n \t\t\tmissingModulePaths[d.Path] = modRoot\n@@ -1030,11 +1033,25 @@ func makeMainModules(ms []module.Version, rootDirs []string, modFiles []*modfile\n \t\t\tfor _, r := range modFiles[i].Replace {\n \t\t\t\tif replacedByWorkFile[r.Old.Path] {\n \t\t\t\t\tcontinue\n-\t\t\t\t} else if prev, ok := replacements[r.Old]; ok && !curModuleReplaces[r.Old] && prev != r.New {\n-\t\t\t\t\tbase.Fatalf(\"go: conflicting replacements for %v:\\n\\t%v\\n\\t%v\\nuse \\\"go work edit -replace %v=[override]\\\" to resolve\", r.Old, prev, r.New, r.Old)\n+\t\t\t\t}\n+\t\t\t\tvar newV module.Version = r.New\n+\t\t\t\tif WorkFilePath() != \"\" && newV.Version == \"\" && !filepath.IsAbs(newV.Path) {\n+\t\t\t\t\t// Since we are in a workspace, we may be loading replacements from\n+\t\t\t\t\t// multiple go.mod files. Relative paths in those replacement are\n+\t\t\t\t\t// relative to the go.mod file, not the workspace, so the same string\n+\t\t\t\t\t// may refer to two different paths and different strings may refer to\n+\t\t\t\t\t// the same path. Convert them all to be absolute instead.\n+\t\t\t\t\t//\n+\t\t\t\t\t// (We could do this outside of a workspace too, but it would mean that\n+\t\t\t\t\t// replacement paths in error strings needlessly differ from what's in\n+\t\t\t\t\t// the go.mod file.)\n+\t\t\t\t\tnewV.Path = filepath.Join(rootDirs[i], newV.Path)\n+\t\t\t\t}\n+\t\t\t\tif prev, ok := replacements[r.Old]; ok && !curModuleReplaces[r.Old] && prev != newV {\n+\t\t\t\t\tbase.Fatalf(\"go: conflicting replacements for %v:\\n\\t%v\\n\\t%v\\nuse \\\"go work edit -replace %v=[override]\\\" to resolve\", r.Old, prev, newV, r.Old)\n \t\t\t\t}\n \t\t\t\tcurModuleReplaces[r.Old] = true\n-\t\t\t\treplacements[r.Old] = r.New\n+\t\t\t\treplacements[r.Old] = newV\n \n \t\t\t\tv, ok := mainModules.highestReplaced[r.Old.Path]\n \t\t\t\tif !ok || semver.Compare(r.Old.Version, v) > 0 {\n@@ -1092,7 +1109,7 @@ func setDefaultBuildMod() {\n \t\tif inWorkspaceMode() && cfg.BuildMod != \"readonly\" {\n \t\t\tbase.Fatalf(\"go: -mod may only be set to readonly when in workspace mode, but it is set to %q\"+\n \t\t\t\t\"\\n\\tRemove the -mod flag to use the default readonly value,\"+\n-\t\t\t\t\"\\n\\tor set -workfile=off to disable workspace mode.\", cfg.BuildMod)\n+\t\t\t\t\"\\n\\tor set GOWORK=off to disable workspace mode.\", cfg.BuildMod)\n \t\t}\n \t\t// Don't override an explicit '-mod=' argument.\n \t\treturn"}, {"sha": "d4847efb9880b0365af3e5374692333d5b105043", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -479,7 +479,11 @@ func matchLocalDirs(ctx context.Context, modRoots []string, m *search.Match, rs\n \t\t}\n \t\tif !found && search.InDir(absDir, cfg.GOROOTsrc) == \"\" && pathInModuleCache(ctx, absDir, rs) == \"\" {\n \t\t\tm.Dirs = []string{}\n-\t\t\tm.AddError(fmt.Errorf(\"directory prefix %s outside available modules\", base.ShortPath(absDir)))\n+\t\t\tscope := \"main module or its selected dependencies\"\n+\t\t\tif inWorkspaceMode() {\n+\t\t\t\tscope = \"modules listed in go.work or their selected dependencies\"\n+\t\t\t}\n+\t\t\tm.AddError(fmt.Errorf(\"directory prefix %s does not contain %s\", base.ShortPath(absDir), scope))\n \t\t\treturn\n \t\t}\n \t}\n@@ -601,7 +605,11 @@ func resolveLocalPackage(ctx context.Context, dir string, rs *Requirements) (str\n \n \tpkg := pathInModuleCache(ctx, absDir, rs)\n \tif pkg == \"\" {\n-\t\treturn \"\", fmt.Errorf(\"directory %s outside available modules\", base.ShortPath(absDir))\n+\t\tscope := \"main module or its selected dependencies\"\n+\t\tif inWorkspaceMode() {\n+\t\t\tscope = \"modules listed in go.work or their selected dependencies\"\n+\t\t}\n+\t\treturn \"\", fmt.Errorf(\"directory %s outside %s\", base.ShortPath(absDir), scope)\n \t}\n \treturn pkg, nil\n }\n@@ -1667,24 +1675,6 @@ func (ld *loader) preloadRootModules(ctx context.Context, rootPkgs []string) (ch\n \n // load loads an individual package.\n func (ld *loader) load(ctx context.Context, pkg *loadPkg) {\n-\tif strings.Contains(pkg.path, \"@\") {\n-\t\t// Leave for error during load.\n-\t\treturn\n-\t}\n-\tif build.IsLocalImport(pkg.path) || filepath.IsAbs(pkg.path) {\n-\t\t// Leave for error during load.\n-\t\t// (Module mode does not allow local imports.)\n-\t\treturn\n-\t}\n-\n-\tif search.IsMetaPackage(pkg.path) {\n-\t\tpkg.err = &invalidImportError{\n-\t\t\timportPath: pkg.path,\n-\t\t\terr:        fmt.Errorf(\"%q is not an importable package; see 'go help packages'\", pkg.path),\n-\t\t}\n-\t\treturn\n-\t}\n-\n \tvar mg *ModuleGraph\n \tif ld.requirements.pruning == unpruned {\n \t\tvar err error"}, {"sha": "00a3e4b332f781c2d1f1171da7e93bdfb71fef7a", "filename": "libgo/go/cmd/go/internal/run/run.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -65,7 +65,6 @@ func init() {\n \tCmdRun.Run = runRun // break init loop\n \n \twork.AddBuildFlags(CmdRun, work.DefaultBuildFlags)\n-\tbase.AddWorkfileFlag(&CmdRun.Flag)\n \tCmdRun.Flag.Var((*base.StringsFlag)(&work.ExecCmd), \"exec\", \"\")\n }\n "}, {"sha": "c046caca25d598bd22e78a8c6b051d217da680ae", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -28,7 +28,6 @@ import (\n \n func init() {\n \twork.AddBuildFlags(CmdTest, work.OmitVFlag)\n-\tbase.AddWorkfileFlag(&CmdTest.Flag)\n \n \tcf := CmdTest.Flag\n \tcf.BoolVar(&testC, \"c\", false, \"\")"}, {"sha": "1c0eb5407d960d78ae725c3371d459d617a64467", "filename": "libgo/go/cmd/go/internal/version/version.go", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -6,7 +6,6 @@\n package version\n \n import (\n-\t\"bytes\"\n \t\"context\"\n \t\"debug/buildinfo\"\n \t\"errors\"\n@@ -156,12 +155,8 @@ func scanFile(file string, info fs.FileInfo, mustPrint bool) {\n \n \tfmt.Printf(\"%s: %s\\n\", file, bi.GoVersion)\n \tbi.GoVersion = \"\" // suppress printing go version again\n-\tmod, err := bi.MarshalText()\n-\tif err != nil {\n-\t\tfmt.Fprintf(os.Stderr, \"%s: formatting build info: %v\\n\", file, err)\n-\t\treturn\n-\t}\n+\tmod := bi.String()\n \tif *versionM && len(mod) > 0 {\n-\t\tfmt.Printf(\"\\t%s\\n\", bytes.ReplaceAll(mod[:len(mod)-1], []byte(\"\\n\"), []byte(\"\\n\\t\")))\n+\t\tfmt.Printf(\"\\t%s\\n\", strings.ReplaceAll(mod[:len(mod)-1], \"\\n\", \"\\n\\t\"))\n \t}\n }"}, {"sha": "d3e0dd8116f481ef4d8e72e5c467a75110cde9bc", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/trace\"\n \t\"cmd/go/internal/work\"\n )\n@@ -54,6 +55,7 @@ See also: go fmt, go fix.\n \n func runVet(ctx context.Context, cmd *base.Command, args []string) {\n \tvetFlags, pkgArgs := vetFlags(args)\n+\tmodload.InitWorkfile() // The vet command does custom flag processing; initialize workspaces after that.\n \n \tif cfg.DebugTrace != \"\" {\n \t\tvar close func() error"}, {"sha": "0b5848a77da8edcc059b0c9420c6fa6d14e3a568", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -130,14 +130,6 @@ and test commands:\n \t\tdirectory, but it is not accessed. When -modfile is specified, an\n \t\talternate go.sum file is also used: its path is derived from the\n \t\t-modfile flag by trimming the \".mod\" extension and appending \".sum\".\n-\t-workfile file\n-\t\tin module aware mode, use the given go.work file as a workspace file.\n-\t\tBy default or when -workfile is \"auto\", the go command searches for a\n-\t\tfile named go.work in the current directory and then containing directories\n-\t\tuntil one is found. If a valid go.work file is found, the modules\n-\t\tspecified will collectively be used as the main modules. If -workfile\n-\t\tis \"off\", or a go.work file is not found in \"auto\" mode, workspace\n-\t\tmode is disabled.\n \t-overlay file\n \t\tread a JSON config file that provides an overlay for build operations.\n \t\tThe file is a JSON struct with a single field, named 'Replace', that\n@@ -217,7 +209,6 @@ func init() {\n \n \tAddBuildFlags(CmdBuild, DefaultBuildFlags)\n \tAddBuildFlags(CmdInstall, DefaultBuildFlags)\n-\tbase.AddWorkfileFlag(&CmdBuild.Flag)\n }\n \n // Note that flags consulted by other parts of the code"}, {"sha": "a4ab060c18e0d8723288e23b2113840776fbf407", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -2015,6 +2015,7 @@ func (b *Builder) showOutput(a *Action, dir, desc, out string) {\n \tif reldir := base.ShortPath(dir); reldir != dir {\n \t\tsuffix = strings.ReplaceAll(suffix, \" \"+dir, \" \"+reldir)\n \t\tsuffix = strings.ReplaceAll(suffix, \"\\n\"+dir, \"\\n\"+reldir)\n+\t\tsuffix = strings.ReplaceAll(suffix, \"\\n\\t\"+dir, \"\\n\\t\"+reldir)\n \t}\n \tsuffix = strings.ReplaceAll(suffix, \" \"+b.WorkDir, \" $WORK\")\n "}, {"sha": "d1e2c673fadd8ef629514e56773bffc38122fbcc", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -131,6 +131,7 @@ var validCompilerFlagsWithNextArg = []string{\n \t\"-D\",\n \t\"-U\",\n \t\"-I\",\n+\t\"-F\",\n \t\"-framework\",\n \t\"-include\",\n \t\"-isysroot\","}, {"sha": "d2aeb54e0cea144155a0beba516be273418aabe6", "filename": "libgo/go/cmd/go/internal/work/security_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -15,6 +15,7 @@ var goodCompilerFlags = [][]string{\n \t{\"-Ufoo\"},\n \t{\"-Ufoo1\"},\n \t{\"-F/Qt\"},\n+\t{\"-F\", \"/Qt\"},\n \t{\"-I/\"},\n \t{\"-I/etc/passwd\"},\n \t{\"-I.\"},"}, {"sha": "05f4f3dddfc49fb0cd35fd7d21a18be876bd7b4a", "filename": "libgo/go/cmd/go/internal/workcmd/edit.go", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fedit.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -63,19 +63,14 @@ writing it back to go.mod.\n The -json flag prints the final go.work file in JSON format instead of\n writing it back to go.mod. The JSON output corresponds to these Go types:\n \n-\ttype Module struct {\n-\t\tPath    string\n-\t\tVersion string\n-\t}\n-\n \ttype GoWork struct {\n-\t\tGo        string\n-\t\tDirectory []Directory\n-\t\tReplace   []Replace\n+\t\tGo      string\n+\t\tUse     []Use\n+\t\tReplace []Replace\n \t}\n \n \ttype Use struct {\n-\t\tPath       string\n+\t\tDiskPath   string\n \t\tModulePath string\n \t}\n \n@@ -84,6 +79,11 @@ writing it back to go.mod. The JSON output corresponds to these Go types:\n \t\tNew Module\n \t}\n \n+\ttype Module struct {\n+\t\tPath    string\n+\t\tVersion string\n+\t}\n+\n See the workspaces design proposal at\n https://go.googlesource.com/proposal/+/master/design/45713-workspace.md for\n more information.\n@@ -110,22 +110,9 @@ func init() {\n \tcmdEdit.Flag.Var(flagFunc(flagEditworkDropUse), \"dropuse\", \"\")\n \tcmdEdit.Flag.Var(flagFunc(flagEditworkReplace), \"replace\", \"\")\n \tcmdEdit.Flag.Var(flagFunc(flagEditworkDropReplace), \"dropreplace\", \"\")\n-\n-\tbase.AddWorkfileFlag(&cmdEdit.Flag)\n }\n \n func runEditwork(ctx context.Context, cmd *base.Command, args []string) {\n-\tanyFlags :=\n-\t\t*editGo != \"\" ||\n-\t\t\t*editJSON ||\n-\t\t\t*editPrint ||\n-\t\t\t*editFmt ||\n-\t\t\tlen(workedits) > 0\n-\n-\tif !anyFlags {\n-\t\tbase.Fatalf(\"go: no flags specified (see 'go help work edit').\")\n-\t}\n-\n \tif *editJSON && *editPrint {\n \t\tbase.Fatalf(\"go: cannot use both -json and -print\")\n \t}\n@@ -147,6 +134,21 @@ func runEditwork(ctx context.Context, cmd *base.Command, args []string) {\n \t\t}\n \t}\n \n+\tif gowork == \"\" {\n+\t\tbase.Fatalf(\"go: no go.work file found\\n\\t(run 'go work init' first or specify path using GOWORK environment variable)\")\n+\t}\n+\n+\tanyFlags :=\n+\t\t*editGo != \"\" ||\n+\t\t\t*editJSON ||\n+\t\t\t*editPrint ||\n+\t\t\t*editFmt ||\n+\t\t\tlen(workedits) > 0\n+\n+\tif !anyFlags {\n+\t\tbase.Fatalf(\"go: no flags specified (see 'go help work edit').\")\n+\t}\n+\n \tworkFile, err := modload.ReadWorkFile(gowork)\n \tif err != nil {\n \t\tbase.Fatalf(\"go: errors parsing %s:\\n%s\", base.ShortPath(gowork), err)"}, {"sha": "63bee6e4f50be99778b61ddb1630f8642435b030", "filename": "libgo/go/cmd/go/internal/workcmd/init.go", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Finit.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -33,20 +33,17 @@ current go version will also be listed in the go.work file.\n \n func init() {\n \tbase.AddModCommonFlags(&cmdInit.Flag)\n-\tbase.AddWorkfileFlag(&cmdInit.Flag)\n }\n \n func runInit(ctx context.Context, cmd *base.Command, args []string) {\n \tmodload.InitWorkfile()\n \n \tmodload.ForceUseModules = true\n \n-\t// TODO(matloob): support using the -workfile path\n-\t// To do that properly, we'll have to make the module directories\n-\t// make dirs relative to workFile path before adding the paths to\n-\t// the directory entries\n-\n-\tworkFile := filepath.Join(base.Cwd(), \"go.work\")\n+\tworkFile := modload.WorkFilePath()\n+\tif workFile == \"\" {\n+\t\tworkFile = filepath.Join(base.Cwd(), \"go.work\")\n+\t}\n \n \tmodload.CreateWorkFile(ctx, workFile, args)\n }"}, {"sha": "b0f61c5fa247c04e203347536b305a61ed0b41a8", "filename": "libgo/go/cmd/go/internal/workcmd/sync.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fsync.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fsync.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fsync.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -39,13 +39,14 @@ that in each workspace module.\n \n func init() {\n \tbase.AddModCommonFlags(&cmdSync.Flag)\n-\tbase.AddWorkfileFlag(&cmdSync.Flag)\n }\n \n func runSync(ctx context.Context, cmd *base.Command, args []string) {\n-\tmodload.InitWorkfile()\n-\n \tmodload.ForceUseModules = true\n+\tmodload.InitWorkfile()\n+\tif modload.WorkFilePath() == \"\" {\n+\t\tbase.Fatalf(\"go: no go.work file found\\n\\t(run 'go work init' first or specify path using GOWORK environment variable)\")\n+\t}\n \n \tworkGraph := modload.LoadModGraph(ctx, \"\")\n \t_ = workGraph"}, {"sha": "1ee2d4e3c4d81567b7ce6bcb8ad3cdd8c97921a1", "filename": "libgo/go/cmd/go/internal/workcmd/use.go", "status": "modified", "additions": 109, "deletions": 38, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fuse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fuse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fuse.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -10,7 +10,10 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/str\"\n \t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n \t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -39,47 +42,50 @@ func init() {\n \tcmdUse.Run = runUse // break init cycle\n \n \tbase.AddModCommonFlags(&cmdUse.Flag)\n-\tbase.AddWorkfileFlag(&cmdUse.Flag)\n }\n \n func runUse(ctx context.Context, cmd *base.Command, args []string) {\n-\tmodload.InitWorkfile()\n-\n \tmodload.ForceUseModules = true\n \n \tvar gowork string\n \tmodload.InitWorkfile()\n \tgowork = modload.WorkFilePath()\n \n+\tif gowork == \"\" {\n+\t\tbase.Fatalf(\"go: no go.work file found\\n\\t(run 'go work init' first or specify path using GOWORK environment variable)\")\n+\t}\n \tworkFile, err := modload.ReadWorkFile(gowork)\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n-\n-\thaveDirs := make(map[string]bool)\n-\tfor _, dir := range workFile.Use {\n-\t\thaveDirs[filepath.Join(filepath.Dir(gowork), filepath.FromSlash(dir.Path))] = true\n+\tworkDir := filepath.Dir(gowork) // Absolute, since gowork itself is absolute.\n+\n+\thaveDirs := make(map[string][]string) // absolute \u2192 original(s)\n+\tfor _, use := range workFile.Use {\n+\t\tvar abs string\n+\t\tif filepath.IsAbs(use.Path) {\n+\t\t\tabs = filepath.Clean(use.Path)\n+\t\t} else {\n+\t\t\tabs = filepath.Join(workDir, use.Path)\n+\t\t}\n+\t\thaveDirs[abs] = append(haveDirs[abs], use.Path)\n \t}\n \n-\taddDirs := make(map[string]bool)\n-\tremoveDirs := make(map[string]bool)\n+\t// keepDirs maps each absolute path to keep to the literal string to use for\n+\t// that path (either an absolute or a relative path), or the empty string if\n+\t// all entries for the absolute path should be removed.\n+\tkeepDirs := make(map[string]string)\n+\n+\t// lookDir updates the entry in keepDirs for the directory dir,\n+\t// which is either absolute or relative to the current working directory\n+\t// (not necessarily the directory containing the workfile).\n \tlookDir := func(dir string) {\n-\t\tabsDir := filepath.Join(base.Cwd(), dir)\n-\t\t// If the path is absolute, keep it absolute. If it's relative,\n-\t\t// make it relative to the go.work file rather than the working directory.\n-\t\tif !filepath.IsAbs(dir) {\n-\t\t\trel, err := filepath.Rel(filepath.Dir(gowork), absDir)\n-\t\t\tif err == nil {\n-\t\t\t\tdir = rel\n-\t\t\t}\n-\t\t}\n-\t\tfi, err := os.Stat(filepath.Join(dir, \"go.mod\"))\n+\t\tabsDir, dir := pathRel(workDir, dir)\n+\n+\t\tfi, err := os.Stat(filepath.Join(absDir, \"go.mod\"))\n \t\tif err != nil {\n \t\t\tif os.IsNotExist(err) {\n-\n-\t\t\t\tif haveDirs[absDir] {\n-\t\t\t\t\tremoveDirs[dir] = true\n-\t\t\t\t}\n+\t\t\t\tkeepDirs[absDir] = \"\"\n \t\t\t\treturn\n \t\t\t}\n \t\t\tbase.Errorf(\"go: %v\", err)\n@@ -89,31 +95,96 @@ func runUse(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\tbase.Errorf(\"go: %v is not regular\", filepath.Join(dir, \"go.mod\"))\n \t\t}\n \n-\t\tif !haveDirs[absDir] {\n-\t\t\taddDirs[dir] = true\n+\t\tif dup := keepDirs[absDir]; dup != \"\" && dup != dir {\n+\t\t\tbase.Errorf(`go: already added \"%s\" as \"%s\"`, dir, dup)\n \t\t}\n+\t\tkeepDirs[absDir] = dir\n \t}\n \n \tfor _, useDir := range args {\n-\t\tif *useR {\n-\t\t\tfsys.Walk(useDir, func(path string, info fs.FileInfo, err error) error {\n-\t\t\t\tif !info.IsDir() {\n-\t\t\t\t\treturn nil\n+\t\tif !*useR {\n+\t\t\tlookDir(useDir)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Add or remove entries for any subdirectories that still exist.\n+\t\terr := fsys.Walk(useDir, func(path string, info fs.FileInfo, err error) error {\n+\t\t\tif !info.IsDir() {\n+\t\t\t\tif info.Mode()&fs.ModeSymlink != 0 {\n+\t\t\t\t\tif target, err := fsys.Stat(path); err == nil && target.IsDir() {\n+\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: ignoring symlink %s\\n\", path)\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tlookDir(path)\n \t\t\t\treturn nil\n-\t\t\t})\n-\t\t\tcontinue\n+\t\t\t}\n+\t\t\tlookDir(path)\n+\t\t\treturn nil\n+\t\t})\n+\t\tif err != nil && !errors.Is(err, os.ErrNotExist) {\n+\t\t\tbase.Errorf(\"go: %v\", err)\n \t\t}\n-\t\tlookDir(useDir)\n-\t}\n \n-\tfor dir := range removeDirs {\n-\t\tworkFile.DropUse(filepath.ToSlash(dir))\n+\t\t// Remove entries for subdirectories that no longer exist.\n+\t\t// Because they don't exist, they will be skipped by Walk.\n+\t\tabsArg, _ := pathRel(workDir, useDir)\n+\t\tfor absDir, _ := range haveDirs {\n+\t\t\tif str.HasFilePathPrefix(absDir, absArg) {\n+\t\t\t\tif _, ok := keepDirs[absDir]; !ok {\n+\t\t\t\t\tkeepDirs[absDir] = \"\" // Mark for deletion.\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n-\tfor dir := range addDirs {\n-\t\tworkFile.AddUse(filepath.ToSlash(dir), \"\")\n+\n+\tbase.ExitIfErrors()\n+\n+\tfor absDir, keepDir := range keepDirs {\n+\t\tnKept := 0\n+\t\tfor _, dir := range haveDirs[absDir] {\n+\t\t\tif dir == keepDir { // (note that dir is always non-empty)\n+\t\t\t\tnKept++\n+\t\t\t} else {\n+\t\t\t\tworkFile.DropUse(dir)\n+\t\t\t}\n+\t\t}\n+\t\tif keepDir != \"\" && nKept != 1 {\n+\t\t\t// If we kept more than one copy, delete them all.\n+\t\t\t// We'll recreate a unique copy with AddUse.\n+\t\t\tif nKept > 1 {\n+\t\t\t\tworkFile.DropUse(keepDir)\n+\t\t\t}\n+\t\t\tworkFile.AddUse(keepDir, \"\")\n+\t\t}\n \t}\n \tmodload.UpdateWorkFile(workFile)\n \tmodload.WriteWorkFile(gowork, workFile)\n }\n+\n+// pathRel returns the absolute and canonical forms of dir for use in a\n+// go.work file located in directory workDir.\n+//\n+// If dir is relative, it is intepreted relative to base.Cwd()\n+// and its canonical form is relative to workDir if possible.\n+// If dir is absolute or cannot be made relative to workDir,\n+// its canonical form is absolute.\n+//\n+// Canonical absolute paths are clean.\n+// Canonical relative paths are clean and slash-separated.\n+func pathRel(workDir, dir string) (abs, canonical string) {\n+\tif filepath.IsAbs(dir) {\n+\t\tabs = filepath.Clean(dir)\n+\t\treturn abs, abs\n+\t}\n+\n+\tabs = filepath.Join(base.Cwd(), dir)\n+\trel, err := filepath.Rel(workDir, abs)\n+\tif err != nil {\n+\t\t// The path can't be made relative to the go.work file,\n+\t\t// so it must be kept absolute instead.\n+\t\treturn abs, abs\n+\t}\n+\n+\t// Normalize relative paths to use slashes, so that checked-in go.work\n+\t// files with relative paths within the repo are platform-independent.\n+\treturn abs, filepath.ToSlash(rel)\n+}"}, {"sha": "d3cc250231ab7e325423da801283ef58bfe3c5d2", "filename": "libgo/go/cmd/go/internal/workcmd/work.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fwork.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fwork.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fwork.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -27,7 +27,7 @@ workspace that does not specify modules to be used cannot be used to do\n builds from local modules.\n \n go.work files are line-oriented. Each line holds a single directive,\n-made up of a keyword followed by aruments. For example:\n+made up of a keyword followed by arguments. For example:\n \n \tgo 1.18\n "}, {"sha": "55a88e0e0b03e23ac34dc7e6e6b5db2d46abe0b3", "filename": "libgo/go/cmd/go/script_test.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -142,6 +142,8 @@ var extraEnvKeys = []string{\n \t\"SYSTEMROOT\",         // must be preserved on Windows to find DLLs; golang.org/issue/25210\n \t\"WINDIR\",             // must be preserved on Windows to be able to run PowerShell command; golang.org/issue/30711\n \t\"LD_LIBRARY_PATH\",    // must be preserved on Unix systems to find shared libraries\n+\t\"LIBRARY_PATH\",       // allow override of non-standard static library paths\n+\t\"C_INCLUDE_PATH\",     // allow override non-standard include paths\n \t\"CC\",                 // don't lose user settings when invoking cgo\n \t\"GO_TESTING_GOTOOLS\", // for gccgo testing\n \t\"GCCGO\",              // for gccgo testing\n@@ -648,9 +650,9 @@ func (ts *testScript) doCmdCmp(want simpleStatus, args []string, env, quiet bool\n \t\t}\n \tcase successOrFailure:\n \t\tif eq {\n-\t\t\tfmt.Fprintf(&ts.log, \"%s and %s do not differ\", name1, name2)\n+\t\t\tfmt.Fprintf(&ts.log, \"%s and %s do not differ\\n\", name1, name2)\n \t\t} else {\n-\t\t\tfmt.Fprintf(&ts.log, \"%s and %s differ\", name1, name2)\n+\t\t\tfmt.Fprintf(&ts.log, \"%s and %s differ\\n\", name1, name2)\n \t\t}\n \tdefault:\n \t\tts.fatalf(\"unsupported: %v cmp\", want)\n@@ -902,7 +904,7 @@ func (ts *testScript) cmdStale(want simpleStatus, args []string) {\n \ttmpl := \"{{if .Error}}{{.ImportPath}}: {{.Error.Err}}{{else}}\"\n \tswitch want {\n \tcase failure:\n-\t\ttmpl += \"{{if .Stale}}{{.ImportPath}} is unexpectedly stale{{end}}\"\n+\t\ttmpl += \"{{if .Stale}}{{.ImportPath}} is unexpectedly stale: {{.StaleReason}}{{end}}\"\n \tcase success:\n \t\ttmpl += \"{{if not .Stale}}{{.ImportPath}} is unexpectedly NOT stale{{end}}\"\n \tdefault:"}, {"sha": "5b786f2fbce509d86ebac1515ce5845db6ef2aef", "filename": "libgo/go/cmd/go/testdata/script/build_internal.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_internal.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_internal.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_internal.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -10,8 +10,10 @@ stderr 'internal'\n \n # Test internal packages outside GOROOT are respected\n cd ../testinternal2\n+env GO111MODULE=off\n ! go build -v .\n stderr 'p\\.go:3:8: use of internal package .*internal/w not allowed'\n+env GO111MODULE=''\n \n [gccgo] skip # gccgo does not have GOROOT\n cd ../testinternal"}, {"sha": "617b1fd8e363e3bb98a605a021024677d5e507d5", "filename": "libgo/go/cmd/go/testdata/script/mod_download_partial.txt", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_partial.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_partial.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_partial.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -15,12 +15,13 @@ cp empty $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.partial\n go mod verify\n \n # 'go list' should not load packages from the directory.\n-# NOTE: the message \"directory $dir outside available modules\" is reported\n-# for directories not in the main module, active modules in the module cache,\n-# or local replacements. In this case, the directory is in the right place,\n-# but it's incomplete, so 'go list' acts as if it's not an active module.\n+# NOTE: the message \"directory $dir outside main module or its selected dependencies\"\n+# is reported for directories not in the main module, active modules in the\n+# module cache, or local replacements. In this case, the directory is in the\n+# right place, but it's incomplete, so 'go list' acts as if it's not an\n+# active module.\n ! go list $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n-stderr 'outside available modules'\n+stderr 'outside main module or its selected dependencies'\n \n # 'go list -m' should not print the directory.\n go list -m -f '{{.Dir}}' rsc.io/quote"}, {"sha": "276d04e538e0b10945b74c317f55076040d36e81", "filename": "libgo/go/cmd/go/testdata/script/mod_fs_patterns.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -51,11 +51,11 @@ stdout '^at$'\n # a package path.\n cd ../badat/bad@\n ! go list .\n-stderr 'directory . outside available modules'\n+stderr 'directory . outside main module or its selected dependencies'\n ! go list $PWD\n-stderr 'directory . outside available modules'\n+stderr 'directory . outside main module or its selected dependencies'\n ! go list $PWD/...\n-stderr 'directory . outside available modules'\n+stderr 'directory . outside main module or its selected dependencies'\n \n -- x/go.mod --\n module m"}, {"sha": "8385b08d95f105c061e2b395705f55cbd2016e7b", "filename": "libgo/go/cmd/go/testdata/script/mod_invalid_version.txt", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -194,10 +194,10 @@ cp go.mod.orig go.mod\n go mod edit -require github.com/pierrec/lz4@v2.0.9-0.20190209155647-9a39efadad3d+incompatible\n cd outside\n ! go list -m github.com/pierrec/lz4\n-stderr 'go: example.com@v0.0.0 requires\\n\\tgithub.com/pierrec/lz4@v2.0.9-0.20190209155647-9a39efadad3d\\+incompatible: invalid version: \\+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required'\n+stderr '^go: example.com@v0.0.0 requires\\n\\tgithub.com/pierrec/lz4@v2.0.9-0.20190209155647-9a39efadad3d\\+incompatible: invalid version: module contains a go.mod file, so module path must match major version \\(\"github.com/pierrec/lz4/v2\"\\)$'\n cd ..\n ! go list -m github.com/pierrec/lz4\n-stderr 'github.com/pierrec/lz4@v2.0.9-0.20190209155647-9a39efadad3d\\+incompatible: invalid version: \\+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required'\n+stderr '^go: github.com/pierrec/lz4@v2.0.9-0.20190209155647-9a39efadad3d\\+incompatible: invalid version: module contains a go.mod file, so module path must match major version \\(\"github.com/pierrec/lz4/v2\"\\)$'\n \n # A +incompatible pseudo-version is valid for a revision of the module\n # that lacks a go.mod file.\n@@ -222,7 +222,7 @@ stdout 'github.com/pierrec/lz4 v2.0.5\\+incompatible'\n # not resolve to a pseudo-version with a different major version.\n cp go.mod.orig go.mod\n ! go get github.com/pierrec/lz4@v2.0.8\n-stderr 'go: github.com/pierrec/lz4@v2.0.8: invalid version: module contains a go.mod file, so major version must be compatible: should be v0 or v1, not v2'\n+stderr 'go: github.com/pierrec/lz4@v2.0.8: invalid version: module contains a go.mod file, so module path must match major version \\(\"github.com/pierrec/lz4/v2\"\\)$'\n \n # An invalid +incompatible suffix for a canonical version should error out,\n # not resolve to a pseudo-version.\n@@ -233,10 +233,10 @@ cp go.mod.orig go.mod\n go mod edit -require github.com/pierrec/lz4@v2.0.8+incompatible\n cd outside\n ! go list -m github.com/pierrec/lz4\n-stderr 'github.com/pierrec/lz4@v2.0.8\\+incompatible: invalid version: \\+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required'\n+stderr '^go: github.com/pierrec/lz4@v2.0.8\\+incompatible: invalid version: module contains a go.mod file, so module path must match major version \\(\"github.com/pierrec/lz4/v2\"\\)$'\n cd ..\n ! go list -m github.com/pierrec/lz4\n-stderr 'github.com/pierrec/lz4@v2.0.8\\+incompatible: invalid version: \\+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required'\n+stderr '^go: github.com/pierrec/lz4@v2.0.8\\+incompatible: invalid version: module contains a go.mod file, so module path must match major version \\(\"github.com/pierrec/lz4/v2\"\\)$'\n \n -- go.mod.orig --\n module example.com"}, {"sha": "157d3b6a8a66721d1db65b4329b3ae64a9c6d935", "filename": "libgo/go/cmd/go/testdata/script/mod_list_dir.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -24,7 +24,7 @@ go get rsc.io/sampler@v1.3.1\n go list -f '{{.ImportPath}}' $GOPATH/pkg/mod/rsc.io/sampler@v1.3.1\n stdout '^rsc.io/sampler$'\n ! go list -f '{{.ImportPath}}' $GOPATH/pkg/mod/rsc.io/sampler@v1.3.0\n-stderr 'outside available modules'\n+stderr 'outside main module or its selected dependencies'\n \n -- go.mod --\n module x"}, {"sha": "b446543916f53bd04dc8bd4704059a62fb7a3bdc", "filename": "libgo/go/cmd/go/testdata/script/mod_list_replace_dir.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -9,7 +9,7 @@ go get\n go mod download rsc.io/quote@v1.5.2\n \n ! go list $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n-stderr '^directory ..[/\\\\]pkg[/\\\\]mod[/\\\\]rsc.io[/\\\\]quote@v1.5.2 outside available modules$'\n+stderr '^directory ..[/\\\\]pkg[/\\\\]mod[/\\\\]rsc.io[/\\\\]quote@v1.5.2 outside main module or its selected dependencies$'\n \n go list $GOPATH/pkg/mod/rsc.io/quote@v1.5.1\n stdout 'rsc.io/quote'"}, {"sha": "8fa4486ca4186d375087edba0b4c2ce6c04eae21", "filename": "libgo/go/cmd/go/testdata/script/run_issue51125.txt", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Frun_issue51125.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Frun_issue51125.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Frun_issue51125.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,54 @@\n+# Regression test for https://go.dev/issue/51125:\n+# Relative import paths (a holdover from GOPATH) were accidentally allowed in module mode.\n+\n+cd $WORK\n+\n+# Relative imports should not be allowed with a go.mod file.\n+\n+! go run driver.go\n+stderr '^driver.go:3:8: \"./mypkg\" is relative, but relative import paths are not supported in module mode$'\n+\n+go list -e -f '{{with .Error}}{{.}}{{end}}' -deps driver.go\n+stdout '^driver.go:3:8: \"./mypkg\" is relative, but relative import paths are not supported in module mode$'\n+! stderr .\n+\n+\n+# Relative imports should not be allowed in module mode even without a go.mod file.\n+rm go.mod\n+\n+! go run driver.go\n+stderr '^driver.go:3:8: \"./mypkg\" is relative, but relative import paths are not supported in module mode$'\n+\n+go list -e -f '{{with .Error}}{{.}}{{end}}' -deps driver.go\n+stdout '^driver.go:3:8: \"./mypkg\" is relative, but relative import paths are not supported in module mode$'\n+! stderr .\n+\n+\n+# In GOPATH mode, they're still allowed (but only outside of GOPATH/src).\n+env GO111MODULE=off\n+\n+[!short] go run driver.go\n+\n+go list -deps driver.go\n+\n+\n+-- $WORK/go.mod --\n+module example\n+\n+go 1.17\n+-- $WORK/driver.go --\n+package main\n+\n+import \"./mypkg\"\n+\n+func main() {\n+\tmypkg.MyFunc()\n+}\n+-- $WORK/mypkg/code.go --\n+package mypkg\n+\n+import \"fmt\"\n+\n+func MyFunc() {\n+\tfmt.Println(\"Hello, world!\")\n+}"}, {"sha": "52d44a26ff8c827a5a2a4f642696f9861a02a34c", "filename": "libgo/go/cmd/go/testdata/script/test_fuzz_dup_cache.txt", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_dup_cache.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_dup_cache.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_dup_cache.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,52 @@\n+[!fuzz] skip\n+[short] skip\n+\n+# This test checks that cached corpus loading properly handles duplicate entries (this can\n+# happen when a f.Add value has a duplicate entry in the cached corpus.) Duplicate entries\n+# should be discarded, and the rest of the cache should be loaded as normal.\n+\n+env GOCACHE=$WORK/cache\n+env GODEBUG=fuzzdebug=1\n+\n+mkdir -p $GOCACHE/fuzz/fuzztest/FuzzTarget\n+go run ./populate $GOCACHE/fuzz/fuzztest/FuzzTarget\n+\n+go test -fuzz=FuzzTarget -fuzztime=10x .\n+stdout 'entries: 5'\n+\n+-- go.mod --\n+module fuzztest\n+\n+go 1.17\n+\n+-- fuzz_test.go --\n+package fuzz\n+\n+import \"testing\"\n+\n+func FuzzTarget(f *testing.F) {\n+    f.Add(int(0))\n+    f.Fuzz(func(t *testing.T, _ int) {})\n+}\n+\n+-- populate/main.go --\n+package main\n+\n+import (\n+    \"path/filepath\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+func main() {\n+\tfor i := 0; i < 10; i++ {\n+\t\tb := byte(0)\n+\t\tif i > 5 {\n+\t\t\tb = byte(i)\n+\t\t}\n+        tmpl := \"go test fuzz v1\\nint(%d)\\n\"\n+\t\tif err := os.WriteFile(filepath.Join(os.Args[1], fmt.Sprint(i)), []byte(fmt.Sprintf(tmpl, b)), 0777); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+}\n\\ No newline at end of file"}, {"sha": "63275aad01d64843f3fcab6d4b6800d18cb7d883", "filename": "libgo/go/cmd/go/testdata/script/test_fuzz_return.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_return.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_return.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_return.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,19 @@\n+[short] skip\n+\n+! go test .\n+stdout '^panic: testing: fuzz target must not return a value \\[recovered\\]$'\n+\n+-- go.mod --\n+module test\n+go 1.18\n+-- x_test.go --\n+package test\n+\n+import \"testing\"\n+\n+func FuzzReturnErr(f *testing.F) {\n+\tf.Add(\"hello, validation!\")\n+\tf.Fuzz(func(t *testing.T, in string) string {\n+\t\treturn in\n+\t})\n+}"}, {"sha": "4c1fdf990221ab27574a2b41936032ae24cfa81a", "filename": "libgo/go/cmd/go/testdata/script/test_relative_cmdline.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_relative_cmdline.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_relative_cmdline.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_relative_cmdline.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -1,5 +1,7 @@\n # Relative imports in command line package\n \n+env GO111MODULE=off\n+\n # Run tests outside GOPATH.\n env GO111MODULE=off\n env GOPATH=$WORK/tmp"}, {"sha": "a10bf5a1c355dfb5227713be4cb91cf5126cbdda", "filename": "libgo/go/cmd/go/testdata/script/work.txt", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -32,7 +32,9 @@ stdout 'example.com/b'\n go list -mod=readonly all\n ! go list -mod=mod all\n stderr '^go: -mod may only be set to readonly when in workspace mode'\n-go list -mod=mod -workfile=off all\n+env GOWORK=off\n+go list -mod=mod all\n+env GOWORK=\n \n # Test that duplicates in the use list return an error\n cp go.work go.work.backup\n@@ -53,7 +55,9 @@ go run example.com/d\n # This exercises the code that determines which module command-line-arguments\n # belongs to.\n go list ./b/main.go\n-go build -n -workfile=off -o foo foo.go\n+env GOWORK=off\n+go build -n -o foo foo.go\n+env GOWORK=\n go build -n -o foo foo.go\n \n -- go.work.dup --"}, {"sha": "71959ca0dd7e17eb651942afd1de98e08d256de6", "filename": "libgo/go/cmd/go/testdata/script/work_edit.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_edit.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_edit.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_edit.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -30,7 +30,8 @@ cmp stdout go.work.want_print\n go work edit -json -go 1.19 -use b -dropuse c -replace 'x.1@v1.4.0 = ../z' -dropreplace x.1 -dropreplace x.1@v1.3.0\n cmp stdout go.work.want_json\n \n-go work edit -print -fmt -workfile $GOPATH/src/unformatted\n+env GOWORK=$GOPATH/src/unformatted\n+go work edit -print -fmt\n cmp stdout formatted\n \n -- m/go.mod --"}, {"sha": "511bb4e2cb62ea9abb7b995cf2516babe02fa38c", "filename": "libgo/go/cmd/go/testdata/script/work_env.txt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_env.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_env.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_env.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -13,6 +13,10 @@ cd src\n go env GOWORK\n stdout 'go.work'\n \n+env GOWORK='off'\n+go env GOWORK\n+stdout 'off'\n+\n ! go env -w GOWORK=off\n stderr '^go: GOWORK cannot be modified$'\n "}, {"sha": "1cfbf0ca18fac3a6086fa6382a81740c7e24fd46", "filename": "libgo/go/cmd/go/testdata/script/work_gowork.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_gowork.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_gowork.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_gowork.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,24 @@\n+env GOWORK=stop.work\n+! go list a # require absolute path\n+! stderr panic\n+env GOWORK=doesnotexist\n+! go list a\n+! stderr panic\n+\n+env GOWORK=$GOPATH/src/stop.work\n+go list -n a\n+go build -n a\n+go test -n a\n+\n+-- stop.work --\n+go 1.18\n+\n+use ./a\n+-- a/a.go --\n+package a\n+-- a/a_test.go --\n+package a\n+-- a/go.mod --\n+module a\n+\n+go 1.18\n\\ No newline at end of file"}, {"sha": "55ac99b8c009dc8479215c96447c190018d53a4d", "filename": "libgo/go/cmd/go/testdata/script/work_init_gowork.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_init_gowork.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_init_gowork.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_init_gowork.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,19 @@\n+# Test that the GOWORK environment variable flag is used by go work init.\n+\n+! exists go.work\n+go work init\n+exists go.work\n+\n+env GOWORK=$GOPATH/src/foo/foo.work\n+! exists foo/foo.work\n+go work init\n+exists foo/foo.work\n+\n+env GOWORK=\n+cd foo/bar\n+! go work init\n+stderr 'already exists'\n+\n+# Create directories to make go.work files in.\n+-- foo/dummy.txt --\n+-- foo/bar/dummy.txt --"}, {"sha": "d48300206074ebb48f6a06b3fa043fa846995748", "filename": "libgo/go/cmd/go/testdata/script/work_issue51204.txt", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_issue51204.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_issue51204.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_issue51204.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,57 @@\n+go work sync\n+\n+go list -f '{{.Dir}}' example.com/test\n+stdout '^'$PWD${/}test'$'\n+\n+-- go.work --\n+go 1.18\n+\n+use (\n+\t./test2\n+\t./test2/sub\n+)\n+-- test/go.mod --\n+module example.com/test\n+\n+go 1.18\n+-- test/file.go --\n+package test\n+\n+func DoSomething() {\n+}\n+-- test2/go.mod --\n+module example.com/test2\n+\n+go 1.18\n+\n+replace example.com/test => ../test\n+\n+require example.com/test v0.0.0-00010101000000-000000000000\n+-- test2/file.go --\n+package test2\n+\n+import (\n+\t\"example.com/test\"\n+)\n+\n+func DoSomething() {\n+\ttest.DoSomething()\n+}\n+-- test2/sub/go.mod --\n+module example.com/test2/sub\n+\n+go 1.18\n+\n+replace example.com/test => ../../test\n+\n+require example.com/test v0.0.0\n+-- test2/sub/file.go --\n+package test2\n+\n+import (\n+\t\"example.com/test\"\n+)\n+\n+func DoSomething() {\n+\ttest.DoSomething()\n+}"}, {"sha": "23d908c3022441934dc287b33d7441c73c66239f", "filename": "libgo/go/cmd/go/testdata/script/work_module_not_in_go_work.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_module_not_in_go_work.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_module_not_in_go_work.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_module_not_in_go_work.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,25 @@\n+# This is a regression test for issue #49632.\n+# The Go command should mention go.work if the user\n+# tries to load a local package that's in a module\n+# that's not in go.work and can't be resolved.\n+\n+! go list ./...\n+stderr 'pattern ./...: directory prefix . does not contain modules listed in go.work or their selected dependencies'\n+\n+! go list ./a\n+stderr 'directory a outside modules listed in go.work'\n+\n+-- go.work --\n+go 1.18\n+\n+use ./b\n+-- a/go.mod --\n+module example.com/a\n+\n+go 1.18\n+-- a/a.go --\n+package a\n+-- b/go.mod --\n+module example.com/b\n+\n+go 1.18"}, {"sha": "b4c9b1d9cf3dc927bd8bbfbf3d92a21353e103e2", "filename": "libgo/go/cmd/go/testdata/script/work_nowork.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_nowork.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_nowork.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_nowork.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,20 @@\n+! go work use\n+stderr '^go: no go\\.work file found\\n\\t\\(run ''go work init'' first or specify path using GOWORK environment variable\\)$'\n+\n+! go work use .\n+stderr '^go: no go\\.work file found\\n\\t\\(run ''go work init'' first or specify path using GOWORK environment variable\\)$'\n+\n+! go work edit\n+stderr '^go: no go\\.work file found\\n\\t\\(run ''go work init'' first or specify path using GOWORK environment variable\\)$'\n+\n+! go work edit -go=1.18\n+stderr '^go: no go\\.work file found\\n\\t\\(run ''go work init'' first or specify path using GOWORK environment variable\\)$'\n+\n+! go work sync\n+stderr '^go: no go\\.work file found\\n\\t\\(run ''go work init'' first or specify path using GOWORK environment variable\\)$'\n+\n+-- go.mod --\n+module example\n+go 1.18\n+-- README.txt --\n+There is no go.work file here."}, {"sha": "7b71b0fbd78cfa8148bc64cebd145b8520e09900", "filename": "libgo/go/cmd/go/testdata/script/work_replace_conflict.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_replace_conflict.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_replace_conflict.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_replace_conflict.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -2,7 +2,7 @@\n # overriding it in the go.work file.\n \n ! go list -m example.com/dep\n-stderr 'go: conflicting replacements for example.com/dep@v1.0.0:\\n\\t./dep1\\n\\t./dep2\\nuse \"go work edit -replace example.com/dep@v1.0.0=\\[override\\]\" to resolve'\n+stderr 'go: conflicting replacements for example.com/dep@v1.0.0:\\n\\t'$PWD${/}'dep1\\n\\t'$PWD${/}'dep2\\nuse \"go work edit -replace example.com/dep@v1.0.0=\\[override\\]\" to resolve'\n go work edit -replace example.com/dep@v1.0.0=./dep1\n go list -m example.com/dep\n stdout 'example.com/dep v1.0.0 => ./dep1'\n@@ -15,7 +15,7 @@ use n\n module example.com/m\n \n require example.com/dep v1.0.0\n-replace example.com/dep v1.0.0 => ./dep1\n+replace example.com/dep v1.0.0 => ../dep1\n -- m/m.go --\n package m\n \n@@ -28,7 +28,7 @@ func F() {\n module example.com/n\n \n require example.com/dep v1.0.0\n-replace example.com/dep v1.0.0 => ./dep2\n+replace example.com/dep v1.0.0 => ../dep2\n -- n/n.go --\n package n\n "}, {"sha": "660eb56e2ddf7cbb14562a0e3bd34e3f3015a0a4", "filename": "libgo/go/cmd/go/testdata/script/work_use_deleted.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_deleted.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_deleted.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_deleted.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,22 @@\n+go work use -r .\n+cmp go.work go.work.want\n+\n+-- go.work --\n+go 1.18\n+\n+use (\n+\t.\n+\tsub\n+\tsub/dir/deleted\n+)\n+-- go.work.want --\n+go 1.18\n+\n+use sub/dir\n+-- sub/README.txt --\n+A go.mod file has been deleted from this directory.\n+In addition, the entire subdirectory sub/dir/deleted\n+has been deleted, along with sub/dir/deleted/go.mod.\n+-- sub/dir/go.mod --\n+module example/sub/dir\n+go 1.18"}, {"sha": "ccd83d6a61a6c32c5b497733ce5cbf19fa2bb9f7", "filename": "libgo/go/cmd/go/testdata/script/work_use_dot.txt", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_dot.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_dot.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_dot.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,49 @@\n+cp go.work go.work.orig\n+\n+# If the current directory contains a go.mod file,\n+# 'go work use .' should add an entry for it.\n+cd bar/baz\n+go work use .\n+cmp ../../go.work ../../go.work.rel\n+\n+# If the current directory lacks a go.mod file, 'go work use .'\n+# should remove its entry.\n+mv go.mod go.mod.bak\n+go work use .\n+cmp ../../go.work ../../go.work.orig\n+\n+# If the path is absolute, it should remain absolute.\n+mv go.mod.bak go.mod\n+go work use $PWD\n+grep -count=1 '^use ' ../../go.work\n+grep '^use [\"]?'$PWD'[\"]?$' ../../go.work\n+\n+# An absolute path should replace an entry for the corresponding relative path\n+# and vice-versa.\n+go work use .\n+cmp ../../go.work ../../go.work.rel\n+go work use $PWD\n+grep -count=1 '^use ' ../../go.work\n+grep '^use [\"]?'$PWD'[\"]?$' ../../go.work\n+\n+# If both the absolute and relative paths are named, 'go work use' should error\n+# out: we don't know which one to use, and shouldn't add both because the\n+# resulting workspace would contain a duplicate module.\n+cp ../../go.work.orig ../../go.work\n+! go work use $PWD .\n+stderr '^go: already added \"bar/baz\" as \"'$PWD'\"$'\n+cmp ../../go.work ../../go.work.orig\n+\n+\n+-- go.mod --\n+module example\n+go 1.18\n+-- go.work --\n+go 1.18\n+-- go.work.rel --\n+go 1.18\n+\n+use bar/baz\n+-- bar/baz/go.mod --\n+module example/bar/baz\n+go 1.18"}, {"sha": "7a25531f3d1cd20715d615aa9ab53a1ec51695b1", "filename": "libgo/go/cmd/go/testdata/script/work_use_issue50958.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_issue50958.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_issue50958.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_issue50958.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,17 @@\n+go work use -r .\n+cmp go.work go.work.want\n+\n+-- go.mod --\n+module example\n+go 1.18\n+-- go.work --\n+go 1.18\n+\n+use sub\n+-- go.work.want --\n+go 1.18\n+\n+use .\n+-- sub/README.txt --\n+This directory no longer contains a go.mod file.\n+"}, {"sha": "e258fc03946a82ae065b114a1d0e3e5546eb24d4", "filename": "libgo/go/cmd/go/testdata/script/work_vet.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_vet.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_vet.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_vet.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,19 @@\n+! go vet ./a\n+stderr 'fmt.Println call has possible formatting directive'\n+\n+-- go.work --\n+go 1.18\n+\n+use ./a\n+-- a/go.mod --\n+module example.com/a\n+\n+go 1.18\n+-- a/a.go --\n+package a\n+\n+import \"fmt\"\n+\n+func A() {\n+    fmt.Println(\"%s\")\n+}\n\\ No newline at end of file"}, {"sha": "b62918147efb71a1e6abc31bac23a940ea93ea78", "filename": "libgo/go/cmd/go/testdata/script/work_workfile.txt", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1931cbad498e625b1e24452dcfffe02539b12224/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_workfile.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1931cbad498e625b1e24452dcfffe02539b12224/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_workfile.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_workfile.txt?ref=1931cbad498e625b1e24452dcfffe02539b12224", "patch": "@@ -1,21 +0,0 @@\n-! go list -workfile=stop.work a # require absolute path\n-! stderr panic\n-! go list -workfile=doesnotexist a\n-! stderr panic\n-\n-go list -n -workfile=$GOPATH/src/stop.work a\n-go build -n -workfile=$GOPATH/src/stop.work a\n-go test -n -workfile=$GOPATH/src/stop.work a\n-\n--- stop.work --\n-go 1.18\n-\n-use ./a\n--- a/a.go --\n-package a\n--- a/a_test.go --\n-package a\n--- a/go.mod --\n-module a\n-\n-go 1.18\n\\ No newline at end of file"}, {"sha": "4280ed44590faef84278cabbbf32f9d80bfb109a", "filename": "libgo/go/cmd/gofmt/gofmt.go", "status": "modified", "additions": 82, "deletions": 46, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -52,6 +52,16 @@ const (\n \tprinterNormalizeNumbers = 1 << 30\n )\n \n+// fdSem guards the number of concurrently-open file descriptors.\n+//\n+// For now, this is arbitrarily set to 200, based on the observation that many\n+// platforms default to a kernel limit of 256. Ideally, perhaps we should derive\n+// it from rlimit on platforms that support that system call.\n+//\n+// File descriptors opened from outside of this package are not tracked,\n+// so this limit may be approximate.\n+var fdSem = make(chan bool, 200)\n+\n var (\n \trewrite    func(*token.FileSet, *ast.File) *ast.File\n \tparserMode parser.Mode\n@@ -213,51 +223,9 @@ func (r *reporter) ExitCode() int {\n // If info == nil, we are formatting stdin instead of a file.\n // If in == nil, the source is the contents of the file with the given filename.\n func processFile(filename string, info fs.FileInfo, in io.Reader, r *reporter) error {\n-\tif in == nil {\n-\t\tvar err error\n-\t\tin, err = os.Open(filename)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\n-\t// Compute the file's size and read its contents with minimal allocations.\n-\t//\n-\t// If the size is unknown (or bogus, or overflows an int), fall back to\n-\t// a size-independent ReadAll.\n-\tvar src []byte\n-\tsize := -1\n-\tif info != nil && info.Mode().IsRegular() && int64(int(info.Size())) == info.Size() {\n-\t\tsize = int(info.Size())\n-\t}\n-\tif size+1 > 0 {\n-\t\t// If we have the FileInfo from filepath.WalkDir, use it to make\n-\t\t// a buffer of the right size and avoid ReadAll's reallocations.\n-\t\t//\n-\t\t// We try to read size+1 bytes so that we can detect modifications: if we\n-\t\t// read more than size bytes, then the file was modified concurrently.\n-\t\t// (If that happens, we could, say, append to src to finish the read, or\n-\t\t// proceed with a truncated buffer \u2014 but the fact that it changed at all\n-\t\t// indicates a possible race with someone editing the file, so we prefer to\n-\t\t// stop to avoid corrupting it.)\n-\t\tsrc = make([]byte, size+1)\n-\t\tn, err := io.ReadFull(in, src)\n-\t\tif err != nil && err != io.ErrUnexpectedEOF {\n-\t\t\treturn err\n-\t\t}\n-\t\tif n < size {\n-\t\t\treturn fmt.Errorf(\"error: size of %s changed during reading (from %d to %d bytes)\", filename, size, n)\n-\t\t} else if n > size {\n-\t\t\treturn fmt.Errorf(\"error: size of %s changed during reading (from %d to >=%d bytes)\", filename, size, len(src))\n-\t\t}\n-\t\tsrc = src[:n]\n-\t} else {\n-\t\t// The file is not known to be regular, so we don't have a reliable size for it.\n-\t\tvar err error\n-\t\tsrc, err = io.ReadAll(in)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\tsrc, err := readFile(filename, info, in)\n+\tif err != nil {\n+\t\treturn err\n \t}\n \n \tfileSet := token.NewFileSet()\n@@ -306,7 +274,9 @@ func processFile(filename string, info fs.FileInfo, in io.Reader, r *reporter) e\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n+\t\t\tfdSem <- true\n \t\t\terr = os.WriteFile(filename, res, perm)\n+\t\t\t<-fdSem\n \t\t\tif err != nil {\n \t\t\t\tos.Rename(bakname, filename)\n \t\t\t\treturn err\n@@ -333,6 +303,65 @@ func processFile(filename string, info fs.FileInfo, in io.Reader, r *reporter) e\n \treturn err\n }\n \n+// readFile reads the contents of filename, described by info.\n+// If in is non-nil, readFile reads directly from it.\n+// Otherwise, readFile opens and reads the file itself,\n+// with the number of concurrently-open files limited by fdSem.\n+func readFile(filename string, info fs.FileInfo, in io.Reader) ([]byte, error) {\n+\tif in == nil {\n+\t\tfdSem <- true\n+\t\tvar err error\n+\t\tf, err := os.Open(filename)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tin = f\n+\t\tdefer func() {\n+\t\t\tf.Close()\n+\t\t\t<-fdSem\n+\t\t}()\n+\t}\n+\n+\t// Compute the file's size and read its contents with minimal allocations.\n+\t//\n+\t// If we have the FileInfo from filepath.WalkDir, use it to make\n+\t// a buffer of the right size and avoid ReadAll's reallocations.\n+\t//\n+\t// If the size is unknown (or bogus, or overflows an int), fall back to\n+\t// a size-independent ReadAll.\n+\tsize := -1\n+\tif info != nil && info.Mode().IsRegular() && int64(int(info.Size())) == info.Size() {\n+\t\tsize = int(info.Size())\n+\t}\n+\tif size+1 <= 0 {\n+\t\t// The file is not known to be regular, so we don't have a reliable size for it.\n+\t\tvar err error\n+\t\tsrc, err := io.ReadAll(in)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn src, nil\n+\t}\n+\n+\t// We try to read size+1 bytes so that we can detect modifications: if we\n+\t// read more than size bytes, then the file was modified concurrently.\n+\t// (If that happens, we could, say, append to src to finish the read, or\n+\t// proceed with a truncated buffer \u2014 but the fact that it changed at all\n+\t// indicates a possible race with someone editing the file, so we prefer to\n+\t// stop to avoid corrupting it.)\n+\tsrc := make([]byte, size+1)\n+\tn, err := io.ReadFull(in, src)\n+\tif err != nil && err != io.ErrUnexpectedEOF {\n+\t\treturn nil, err\n+\t}\n+\tif n < size {\n+\t\treturn nil, fmt.Errorf(\"error: size of %s changed during reading (from %d to %d bytes)\", filename, size, n)\n+\t} else if n > size {\n+\t\treturn nil, fmt.Errorf(\"error: size of %s changed during reading (from %d to >=%d bytes)\", filename, size, len(src))\n+\t}\n+\treturn src[:n], nil\n+}\n+\n func main() {\n \t// Arbitrarily limit in-flight work to 2MiB times the number of threads.\n \t//\n@@ -354,12 +383,16 @@ func gofmtMain(s *sequencer) {\n \tflag.Parse()\n \n \tif *cpuprofile != \"\" {\n+\t\tfdSem <- true\n \t\tf, err := os.Create(*cpuprofile)\n \t\tif err != nil {\n \t\t\ts.AddReport(fmt.Errorf(\"creating cpu profile: %s\", err))\n \t\t\treturn\n \t\t}\n-\t\tdefer f.Close()\n+\t\tdefer func() {\n+\t\t\tf.Close()\n+\t\t\t<-fdSem\n+\t\t}()\n \t\tpprof.StartCPUProfile(f)\n \t\tdefer pprof.StopCPUProfile()\n \t}\n@@ -474,6 +507,9 @@ const chmodSupported = runtime.GOOS != \"windows\"\n // with <number randomly chosen such that the file name is unique. backupFile returns\n // the chosen file name.\n func backupFile(filename string, data []byte, perm fs.FileMode) (string, error) {\n+\tfdSem <- true\n+\tdefer func() { <-fdSem }()\n+\n \t// create backup file\n \tf, err := os.CreateTemp(filepath.Dir(filename), filepath.Base(filename))\n \tif err != nil {"}, {"sha": "05a1d49decbf68c5453004533b97a610e0072c80", "filename": "libgo/go/cmd/internal/objabi/funcdata.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -23,6 +23,7 @@ const (\n \tFUNCDATA_OpenCodedDeferInfo = 4\n \tFUNCDATA_ArgInfo            = 5\n \tFUNCDATA_ArgLiveInfo        = 6\n+\tFUNCDATA_WrapInfo           = 7\n \n \t// ArgsSizeUnknown is set in Func.argsize to mark all functions\n \t// whose argument size is unknown (C vararg functions, and"}, {"sha": "9f9a09a8842f3172b0c11aae171871db6c0f3921", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 50, "deletions": 45, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -3,28 +3,21 @@\n // license that can be found in the LICENSE file.\n \n // Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as\n-// defined in FIPS 186-3.\n+// defined in FIPS 186-4 and SEC 1, Version 2.0.\n //\n-// This implementation derives the nonce from an AES-CTR CSPRNG keyed by:\n-//\n-// SHA2-512(priv.D || entropy || hash)[:32]\n-//\n-// The CSPRNG key is indifferentiable from a random oracle as shown in\n-// [Coron], the AES-CTR stream is indifferentiable from a random oracle\n-// under standard cryptographic assumptions (see [Larsson] for examples).\n-//\n-// References:\n-//   [Coron]\n-//     https://cs.nyu.edu/~dodis/ps/merkle.pdf\n-//   [Larsson]\n-//     https://web.archive.org/web/20040719170906/https://www.nada.kth.se/kurser/kth/2D1441/semteo03/lecturenotes/assump.pdf\n+// Signatures generated by this package are not deterministic, but entropy is\n+// mixed with the private key and the message, achieving the same level of\n+// security in case of randomness source failure.\n package ecdsa\n \n-// Further references:\n-//   [NSA]: Suite B implementer's guide to FIPS 186-3\n-//     https://apps.nsa.gov/iaarchive/library/ia-guidance/ia-solutions-for-classified/algorithm-guidance/suite-b-implementers-guide-to-fips-186-3-ecdsa.cfm\n-//   [SECG]: SECG, SEC1\n-//     http://www.secg.org/sec1-v2.pdf\n+// [FIPS 186-4] references ANSI X9.62-2005 for the bulk of the ECDSA algorithm.\n+// That standard is not freely available, which is a problem in an open source\n+// implementation, because not only the implementer, but also any maintainer,\n+// contributor, reviewer, auditor, and learner needs access to it. Instead, this\n+// package references and follows the equivalent [SEC 1, Version 2.0].\n+//\n+// [FIPS 186-4]: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n+// [SEC 1, Version 2.0]: https://www.secg.org/sec1-v2.pdf\n \n import (\n \t\"crypto\"\n@@ -41,15 +34,16 @@ import (\n \t\"golang.org/x/crypto/cryptobyte/asn1\"\n )\n \n-// A invertible implements fast inverse mod Curve.Params().N\n+// A invertible implements fast inverse in GF(N).\n type invertible interface {\n-\t// Inverse returns the inverse of k in GF(P)\n+\t// Inverse returns the inverse of k mod Params().N.\n \tInverse(k *big.Int) *big.Int\n }\n \n-// combinedMult implements fast multiplication S1*g + S2*p (g - generator, p - arbitrary point)\n+// A combinedMult implements fast combined multiplication for verification.\n type combinedMult interface {\n-\tCombinedMult(bigX, bigY *big.Int, baseScalar, scalar []byte) (x, y *big.Int)\n+\t// CombinedMult returns [s1]G + [s2]P where G is the generator.\n+\tCombinedMult(Px, Py *big.Int, s1, s2 []byte) (x, y *big.Int)\n }\n \n const (\n@@ -111,7 +105,7 @@ func (priv *PrivateKey) Equal(x crypto.PrivateKey) bool {\n //\n // This method implements crypto.Signer, which is an interface to support keys\n // where the private part is kept in, for example, a hardware module. Common\n-// uses should use the Sign function in this package directly.\n+// uses can use the SignASN1 function in this package directly.\n func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error) {\n \tr, s, err := Sign(rand, priv, digest)\n \tif err != nil {\n@@ -128,11 +122,13 @@ func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOp\n \n var one = new(big.Int).SetInt64(1)\n \n-// randFieldElement returns a random element of the field underlying the given\n-// curve using the procedure given in [NSA] A.2.1.\n+// randFieldElement returns a random element of the order of the given\n+// curve using the procedure given in FIPS 186-4, Appendix B.5.1.\n func randFieldElement(c elliptic.Curve, rand io.Reader) (k *big.Int, err error) {\n \tparams := c.Params()\n-\tb := make([]byte, params.BitSize/8+8)\n+\t// Note that for P-521 this will actually be 63 bits more than the order, as\n+\t// division rounds down, but the extra bit is inconsequential.\n+\tb := make([]byte, params.BitSize/8+8) // TODO: use params.N.BitLen()\n \t_, err = io.ReadFull(rand, b)\n \tif err != nil {\n \t\treturn\n@@ -159,12 +155,9 @@ func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error) {\n \treturn priv, nil\n }\n \n-// hashToInt converts a hash value to an integer. There is some disagreement\n-// about how this is done. [NSA] suggests that this is done in the obvious\n-// manner, but [SECG] truncates the hash to the bit-length of the curve order\n-// first. We follow [SECG] because that's what OpenSSL does. Additionally,\n-// OpenSSL right shifts excess bits from the number if the hash is too large\n-// and we mirror that too.\n+// hashToInt converts a hash value to an integer. Per FIPS 186-4, Section 6.4,\n+// we use the left-most bits of the hash to match the bit-length of the order of\n+// the curve. This also performs Step 5 of SEC 1, Version 2.0, Section 4.1.3.\n func hashToInt(hash []byte, c elliptic.Curve) *big.Int {\n \torderBits := c.Params().N.BitLen()\n \torderBytes := (orderBits + 7) / 8\n@@ -180,10 +173,11 @@ func hashToInt(hash []byte, c elliptic.Curve) *big.Int {\n \treturn ret\n }\n \n-// fermatInverse calculates the inverse of k in GF(P) using Fermat's method.\n-// This has better constant-time properties than Euclid's method (implemented\n-// in math/big.Int.ModInverse) although math/big itself isn't strictly\n-// constant-time so it's not perfect.\n+// fermatInverse calculates the inverse of k in GF(P) using Fermat's method\n+// (exponentiation modulo P - 2, per Euler's theorem). This has better\n+// constant-time properties than Euclid's method (implemented in\n+// math/big.Int.ModInverse and FIPS 186-4, Appendix C.1) although math/big\n+// itself isn't strictly constant-time so it's not perfect.\n func fermatInverse(k, N *big.Int) *big.Int {\n \ttwo := big.NewInt(2)\n \tnMinus2 := new(big.Int).Sub(N, two)\n@@ -195,19 +189,30 @@ var errZeroParam = errors.New(\"zero parameter\")\n // Sign signs a hash (which should be the result of hashing a larger message)\n // using the private key, priv. If the hash is longer than the bit-length of the\n // private key's curve order, the hash will be truncated to that length. It\n-// returns the signature as a pair of integers. The security of the private key\n-// depends on the entropy of rand.\n+// returns the signature as a pair of integers. Most applications should use\n+// SignASN1 instead of dealing directly with r, s.\n func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {\n \trandutil.MaybeReadByte(rand)\n \n+\t// This implementation derives the nonce from an AES-CTR CSPRNG keyed by:\n+\t//\n+\t//    SHA2-512(priv.D || entropy || hash)[:32]\n+\t//\n+\t// The CSPRNG key is indifferentiable from a random oracle as shown in\n+\t// [Coron], the AES-CTR stream is indifferentiable from a random oracle\n+\t// under standard cryptographic assumptions (see [Larsson] for examples).\n+\t//\n+\t// [Coron]: https://cs.nyu.edu/~dodis/ps/merkle.pdf\n+\t// [Larsson]: https://web.archive.org/web/20040719170906/https://www.nada.kth.se/kurser/kth/2D1441/semteo03/lecturenotes/assump.pdf\n+\n \t// Get 256 bits of entropy from rand.\n \tentropy := make([]byte, 32)\n \t_, err = io.ReadFull(rand, entropy)\n \tif err != nil {\n \t\treturn\n \t}\n \n-\t// Initialize an SHA-512 hash context; digest ...\n+\t// Initialize an SHA-512 hash context; digest...\n \tmd := sha512.New()\n \tmd.Write(priv.D.Bytes()) // the private key,\n \tmd.Write(entropy)        // the entropy,\n@@ -228,12 +233,12 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err\n \t\tS: cipher.NewCTR(block, []byte(aesIV)),\n \t}\n \n-\t// See [NSA] 3.4.1\n \tc := priv.PublicKey.Curve\n \treturn sign(priv, &csprng, c, hash)\n }\n \n func signGeneric(priv *PrivateKey, csprng *cipher.StreamReader, c elliptic.Curve, hash []byte) (r, s *big.Int, err error) {\n+\t// SEC 1, Version 2.0, Section 4.1.3\n \tN := c.Params().N\n \tif N.Sign() == 0 {\n \t\treturn nil, nil, errZeroParam\n@@ -276,16 +281,15 @@ func signGeneric(priv *PrivateKey, csprng *cipher.StreamReader, c elliptic.Curve\n // SignASN1 signs a hash (which should be the result of hashing a larger message)\n // using the private key, priv. If the hash is longer than the bit-length of the\n // private key's curve order, the hash will be truncated to that length. It\n-// returns the ASN.1 encoded signature. The security of the private key\n-// depends on the entropy of rand.\n+// returns the ASN.1 encoded signature.\n func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error) {\n \treturn priv.Sign(rand, hash, nil)\n }\n \n // Verify verifies the signature in r, s of hash using the public key, pub. Its\n-// return value records whether the signature is valid.\n+// return value records whether the signature is valid. Most applications should\n+// use VerifyASN1 instead of dealing directly with r, s.\n func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n-\t// See [NSA] 3.4.2\n \tc := pub.Curve\n \tN := c.Params().N\n \n@@ -299,6 +303,7 @@ func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n }\n \n func verifyGeneric(pub *PublicKey, c elliptic.Curve, hash []byte, r, s *big.Int) bool {\n+\t// SEC 1, Version 2.0, Section 4.1.4\n \te := hashToInt(hash, c)\n \tvar w *big.Int\n \tN := c.Params().N"}, {"sha": "7ead09f8d3fd39129b2d1901f6b76eecb7c31240", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -2,17 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package elliptic implements several standard elliptic curves over prime\n-// fields.\n+// Package elliptic implements the standard NIST P-224, P-256, P-384, and P-521\n+// elliptic curves over prime fields.\n package elliptic\n \n-// This package operates, internally, on Jacobian coordinates. For a given\n-// (x, y) position on the curve, the Jacobian coordinates are (x1, y1, z1)\n-// where x = x1/z1\u00b2 and y = y1/z1\u00b3. The greatest speedups come when the whole\n-// calculation can be performed within the transform (as in ScalarMult and\n-// ScalarBaseMult). But even for Add and Double, it's faster to apply and\n-// reverse the transform than to operate in affine coordinates.\n-\n import (\n \t\"io\"\n \t\"math/big\"\n@@ -21,12 +14,12 @@ import (\n \n // A Curve represents a short-form Weierstrass curve with a=-3.\n //\n-// The output of Add, Double, and ScalarMult when the input is not a point on\n+// The behavior of Add, Double, and ScalarMult when the input is not a point on\n // the curve is undefined.\n //\n // Note that the conventional point at infinity (0, 0) is not considered on the\n // curve, although it can be returned by Add, Double, ScalarMult, or\n-// ScalarBaseMult (but not Unmarshal or UnmarshalCompressed).\n+// ScalarBaseMult (but not the Unmarshal or UnmarshalCompressed functions).\n type Curve interface {\n \t// Params returns the parameters for the curve.\n \tParams() *CurveParams\n@@ -67,6 +60,13 @@ func (curve *CurveParams) Params() *CurveParams {\n \treturn curve\n }\n \n+// CurveParams operates, internally, on Jacobian coordinates. For a given\n+// (x, y) position on the curve, the Jacobian coordinates are (x1, y1, z1)\n+// where x = x1/z1\u00b2 and y = y1/z1\u00b3. The greatest speedups come when the whole\n+// calculation can be performed within the transform (as in ScalarMult and\n+// ScalarBaseMult). But even for Add and Double, it's faster to apply and\n+// reverse the transform than to operate in affine coordinates.\n+\n // polynomial returns x\u00b3 - 3x + b.\n func (curve *CurveParams) polynomial(x *big.Int) *big.Int {\n \tx3 := new(big.Int).Mul(x, x)\n@@ -89,6 +89,11 @@ func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool {\n \t\treturn specific.IsOnCurve(x, y)\n \t}\n \n+\tif x.Sign() < 0 || x.Cmp(curve.P) >= 0 ||\n+\t\ty.Sign() < 0 || y.Cmp(curve.P) >= 0 {\n+\t\treturn false\n+\t}\n+\n \t// y\u00b2 = x\u00b3 - 3x + b\n \ty2 := new(big.Int).Mul(y, y)\n \ty2.Mod(y2, curve.P)\n@@ -353,7 +358,8 @@ func GenerateKey(curve Curve, rand io.Reader) (priv []byte, x, y *big.Int, err e\n }\n \n // Marshal converts a point on the curve into the uncompressed form specified in\n-// section 4.3.6 of ANSI X9.62.\n+// SEC 1, Version 2.0, Section 2.3.3. If the point is not on the curve (or is\n+// the conventional point at infinity), the behavior is undefined.\n func Marshal(curve Curve, x, y *big.Int) []byte {\n \tbyteLen := (curve.Params().BitSize + 7) / 8\n \n@@ -367,7 +373,8 @@ func Marshal(curve Curve, x, y *big.Int) []byte {\n }\n \n // MarshalCompressed converts a point on the curve into the compressed form\n-// specified in section 4.3.6 of ANSI X9.62.\n+// specified in SEC 1, Version 2.0, Section 2.3.3. If the point is not on the\n+// curve (or is the conventional point at infinity), the behavior is undefined.\n func MarshalCompressed(curve Curve, x, y *big.Int) []byte {\n \tbyteLen := (curve.Params().BitSize + 7) / 8\n \tcompressed := make([]byte, 1+byteLen)\n@@ -376,9 +383,9 @@ func MarshalCompressed(curve Curve, x, y *big.Int) []byte {\n \treturn compressed\n }\n \n-// Unmarshal converts a point, serialized by Marshal, into an x, y pair.\n-// It is an error if the point is not in uncompressed form or is not on the curve.\n-// On error, x = nil.\n+// Unmarshal converts a point, serialized by Marshal, into an x, y pair. It is\n+// an error if the point is not in uncompressed form, is not on the curve, or is\n+// the point at infinity. On error, x = nil.\n func Unmarshal(curve Curve, data []byte) (x, y *big.Int) {\n \tbyteLen := (curve.Params().BitSize + 7) / 8\n \tif len(data) != 1+2*byteLen {\n@@ -399,9 +406,9 @@ func Unmarshal(curve Curve, data []byte) (x, y *big.Int) {\n \treturn\n }\n \n-// UnmarshalCompressed converts a point, serialized by MarshalCompressed, into an x, y pair.\n-// It is an error if the point is not in compressed form or is not on the curve.\n-// On error, x = nil.\n+// UnmarshalCompressed converts a point, serialized by MarshalCompressed, into\n+// an x, y pair. It is an error if the point is not in compressed form, is not\n+// on the curve, or is the point at infinity. On error, x = nil.\n func UnmarshalCompressed(curve Curve, data []byte) (x, y *big.Int) {\n \tbyteLen := (curve.Params().BitSize + 7) / 8\n \tif len(data) != 1+byteLen {"}, {"sha": "5481929db1540d6e5d6da33cba7a6eabf2870a56", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -182,6 +182,61 @@ func testUnmarshalToLargeCoordinates(t *testing.T, curve Curve) {\n \t}\n }\n \n+// TestInvalidCoordinates tests big.Int values that are not valid field elements\n+// (negative or bigger than P). They are expected to return false from\n+// IsOnCurve, all other behavior is undefined.\n+func TestInvalidCoordinates(t *testing.T) {\n+\ttestAllCurves(t, testInvalidCoordinates)\n+}\n+\n+func testInvalidCoordinates(t *testing.T, curve Curve) {\n+\tcheckIsOnCurveFalse := func(name string, x, y *big.Int) {\n+\t\tif curve.IsOnCurve(x, y) {\n+\t\t\tt.Errorf(\"IsOnCurve(%s) unexpectedly returned true\", name)\n+\t\t}\n+\t}\n+\n+\tp := curve.Params().P\n+\t_, x, y, _ := GenerateKey(curve, rand.Reader)\n+\txx, yy := new(big.Int), new(big.Int)\n+\n+\t// Check if the sign is getting dropped.\n+\txx.Neg(x)\n+\tcheckIsOnCurveFalse(\"-x, y\", xx, y)\n+\tyy.Neg(y)\n+\tcheckIsOnCurveFalse(\"x, -y\", x, yy)\n+\n+\t// Check if negative values are reduced modulo P.\n+\txx.Sub(x, p)\n+\tcheckIsOnCurveFalse(\"x-P, y\", xx, y)\n+\tyy.Sub(y, p)\n+\tcheckIsOnCurveFalse(\"x, y-P\", x, yy)\n+\n+\t// Check if positive values are reduced modulo P.\n+\txx.Add(x, p)\n+\tcheckIsOnCurveFalse(\"x+P, y\", xx, y)\n+\tyy.Add(y, p)\n+\tcheckIsOnCurveFalse(\"x, y+P\", x, yy)\n+\n+\t// Check if the overflow is dropped.\n+\txx.Add(x, new(big.Int).Lsh(big.NewInt(1), 535))\n+\tcheckIsOnCurveFalse(\"x+2\u2075\u00b3\u2075, y\", xx, y)\n+\tyy.Add(y, new(big.Int).Lsh(big.NewInt(1), 535))\n+\tcheckIsOnCurveFalse(\"x, y+2\u2075\u00b3\u2075\", x, yy)\n+\n+\t// Check if P is treated like zero (if possible).\n+\t// y^2 = x^3 - 3x + B\n+\t// y = mod_sqrt(x^3 - 3x + B)\n+\t// y = mod_sqrt(B) if x = 0\n+\t// If there is no modsqrt, there is no point with x = 0, can't test x = P.\n+\tif yy := new(big.Int).ModSqrt(curve.Params().B, p); yy != nil {\n+\t\tif !curve.IsOnCurve(big.NewInt(0), yy) {\n+\t\t\tt.Fatal(\"(0, mod_sqrt(B)) is not on the curve?\")\n+\t\t}\n+\t\tcheckIsOnCurveFalse(\"P, y\", p, yy)\n+\t}\n+}\n+\n func TestMarshalCompressed(t *testing.T) {\n \tt.Run(\"P-256/03\", func(t *testing.T) {\n \t\tdata, _ := hex.DecodeString(\"031e3987d9f9ea9d7dd7155a56a86b2009e1e0ab332f962d10d8beb6406ab1ad79\")"}, {"sha": "0ebbc6649451e70c7b93d911a70418fe1c6e7ab1", "filename": "libgo/go/crypto/elliptic/gen_p256_table.go", "status": "modified", "additions": 5, "deletions": 42, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fgen_p256_table.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fgen_p256_table.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fgen_p256_table.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -7,30 +7,13 @@\n package main\n \n import (\n-\t\"bytes\"\n \t\"crypto/elliptic\"\n \t\"encoding/binary\"\n-\t\"fmt\"\n-\t\"go/format\"\n \t\"log\"\n \t\"os\"\n )\n \n func main() {\n-\tbuf := new(bytes.Buffer)\n-\tfmt.Fprint(buf, `\n-// Copyright 2021 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Generated by gen_p256_table.go. DO NOT EDIT.\n-\n-//go:build amd64 || arm64\n-\n-package elliptic\n-\n-`[1:])\n-\n \t// Generate precomputed p256 tables.\n \tvar pre [43][32 * 8]uint64\n \tbasePoint := []uint64{\n@@ -70,41 +53,21 @@ package elliptic\n \t\t}\n \t}\n \n-\tfmt.Fprint(buf, \"const p256Precomputed = \\\"\\\" +\\n\\n\")\n+\tvar bin []byte\n \n \t// Dump the precomputed tables, flattened, little-endian.\n \t// These tables are used directly by assembly on little-endian platforms.\n-\t// Putting the data in a const string lets it be stored readonly.\n+\t// go:embedding the data into a string lets it be stored readonly.\n \tfor i := range &pre {\n-\t\tfor j, v := range &pre[i] {\n-\t\t\tfmt.Fprintf(buf, \"\\\"\")\n+\t\tfor _, v := range &pre[i] {\n \t\t\tvar u8 [8]byte\n \t\t\tbinary.LittleEndian.PutUint64(u8[:], v)\n-\t\t\tfor _, b := range &u8 {\n-\t\t\t\tfmt.Fprintf(buf, \"\\\\x%02x\", b)\n-\t\t\t}\n-\t\t\tfmt.Fprintf(buf, \"\\\"\")\n-\t\t\tif i < len(pre)-1 || j < len(pre[i])-1 {\n-\t\t\t\tfmt.Fprint(buf, \"+\")\n-\t\t\t}\n-\t\t\tif j%8 == 7 {\n-\t\t\t\tfmt.Fprint(buf, \"\\n\")\n-\t\t\t}\n+\t\t\tbin = append(bin, u8[:]...)\n \t\t}\n-\t\tfmt.Fprint(buf, \"\\n\")\n \t}\n \n-\tsrc := buf.Bytes()\n-\tfmtsrc, fmterr := format.Source(src)\n-\t// If formatting failed, keep the original source for debugging.\n-\tif fmterr == nil {\n-\t\tsrc = fmtsrc\n-\t}\n-\terr := os.WriteFile(\"p256_asm_table.go\", src, 0644)\n+\terr := os.WriteFile(\"p256_asm_table.bin\", bin, 0644)\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n-\tif fmterr != nil {\n-\t\tlog.Fatal(fmterr)\n-\t}\n }"}, {"sha": "8a431c47692e05294147adf0e010efe7e6b83430", "filename": "libgo/go/crypto/elliptic/p224.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -61,6 +61,9 @@ func p224PointFromAffine(x, y *big.Int) (p *nistec.P224Point, ok bool) {\n \tif x.Sign() == 0 && y.Sign() == 0 {\n \t\treturn nistec.NewP224Point(), true\n \t}\n+\tif x.Sign() < 0 || y.Sign() < 0 {\n+\t\treturn nil, false\n+\t}\n \tif x.BitLen() > 224 || y.BitLen() > 224 {\n \t\treturn nil, false\n \t}"}, {"sha": "a2d00a39b1a4540a24b40a690767e651dd6021de", "filename": "libgo/go/crypto/elliptic/p256.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -6,11 +6,11 @@\n \n package elliptic\n \n-// This file contains a constant-time, 32-bit implementation of P256.\n+// P-256 is implemented by various different backends, including a generic\n+// 32-bit constant-time one in this file, which is used when assembly\n+// implementations are not available, or not appropriate for the hardware.\n \n-import (\n-\t\"math/big\"\n-)\n+import \"math/big\"\n \n type p256Curve struct {\n \t*CurveParams"}, {"sha": "63c3606ce52020185ec29ae28a973a71ac372346", "filename": "libgo/go/crypto/elliptic/p256_asm.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_asm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_asm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_asm.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -15,11 +15,15 @@\n package elliptic\n \n import (\n+\t_ \"embed\"\n \t\"math/big\"\n )\n \n //go:generate go run -tags=tablegen gen_p256_table.go\n \n+//go:embed p256_asm_table.bin\n+var p256Precomputed string\n+\n type (\n \tp256Curve struct {\n \t\t*CurveParams"}, {"sha": "c0814ba5a38ec52a796c0ca9a36d25776e7547e6", "filename": "libgo/go/crypto/elliptic/p256_asm_table.go", "status": "removed", "additions": 0, "deletions": 1430, "changes": 1430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1931cbad498e625b1e24452dcfffe02539b12224/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_asm_table.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1931cbad498e625b1e24452dcfffe02539b12224/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_asm_table.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_asm_table.go?ref=1931cbad498e625b1e24452dcfffe02539b12224"}, {"sha": "33a441d090037bbea509faa958d7e4f8570e9db9", "filename": "libgo/go/crypto/elliptic/p384.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp384.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp384.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp384.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -66,6 +66,9 @@ func p384PointFromAffine(x, y *big.Int) (p *nistec.P384Point, ok bool) {\n \tif x.Sign() == 0 && y.Sign() == 0 {\n \t\treturn nistec.NewP384Point(), true\n \t}\n+\tif x.Sign() < 0 || y.Sign() < 0 {\n+\t\treturn nil, false\n+\t}\n \tif x.BitLen() > 384 || y.BitLen() > 384 {\n \t\treturn nil, false\n \t}"}, {"sha": "6a3ade3c3670d54caa44f1840eacbba50e363022", "filename": "libgo/go/crypto/elliptic/p521.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp521.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp521.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp521.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -71,6 +71,9 @@ func p521PointFromAffine(x, y *big.Int) (p *nistec.P521Point, ok bool) {\n \tif x.Sign() == 0 && y.Sign() == 0 {\n \t\treturn nistec.NewP521Point(), true\n \t}\n+\tif x.Sign() < 0 || y.Sign() < 0 {\n+\t\treturn nil, false\n+\t}\n \tif x.BitLen() > 521 || y.BitLen() > 521 {\n \t\treturn nil, false\n \t}"}, {"sha": "a32a973c68eed5f8644eff61f1f8e54a6a7e4027", "filename": "libgo/go/crypto/x509/parser.go", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Fx509%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Fx509%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fparser.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -51,9 +51,9 @@ func isPrintable(b byte) bool {\n }\n \n // parseASN1String parses the ASN.1 string types T61String, PrintableString,\n-// UTF8String, BMPString, and IA5String. This is mostly copied from the\n-// respective encoding/asn1.parse... methods, rather than just increasing\n-// the API surface of that package.\n+// UTF8String, BMPString, IA5String, and NumericString. This is mostly copied\n+// from the respective encoding/asn1.parse... methods, rather than just\n+// increasing the API surface of that package.\n func parseASN1String(tag cryptobyte_asn1.Tag, value []byte) (string, error) {\n \tswitch tag {\n \tcase cryptobyte_asn1.T61String:\n@@ -93,6 +93,13 @@ func parseASN1String(tag cryptobyte_asn1.Tag, value []byte) (string, error) {\n \t\t\treturn \"\", errors.New(\"invalid IA5String\")\n \t\t}\n \t\treturn s, nil\n+\tcase cryptobyte_asn1.Tag(asn1.TagNumericString):\n+\t\tfor _, b := range value {\n+\t\t\tif !('0' <= b && b <= '9' || b == ' ') {\n+\t\t\t\treturn \"\", errors.New(\"invalid NumericString\")\n+\t\t\t}\n+\t\t}\n+\t\treturn string(value), nil\n \t}\n \treturn \"\", fmt.Errorf(\"unsupported string type: %v\", tag)\n }"}, {"sha": "d7cf7ea758a5e67e3329d47bf79189d0089265ce", "filename": "libgo/go/crypto/x509/parser_test.go", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Fx509%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fcrypto%2Fx509%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fparser_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+package x509\n+\n+import (\n+\t\"encoding/asn1\"\n+\t\"testing\"\n+\n+\tcryptobyte_asn1 \"golang.org/x/crypto/cryptobyte/asn1\"\n+)\n+\n+func TestParseASN1String(t *testing.T) {\n+\ttests := []struct {\n+\t\tname        string\n+\t\ttag         cryptobyte_asn1.Tag\n+\t\tvalue       []byte\n+\t\texpected    string\n+\t\texpectedErr string\n+\t}{\n+\t\t{\n+\t\t\tname:     \"T61String\",\n+\t\t\ttag:      cryptobyte_asn1.T61String,\n+\t\t\tvalue:    []byte{80, 81, 82},\n+\t\t\texpected: string(\"PQR\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"PrintableString\",\n+\t\t\ttag:      cryptobyte_asn1.PrintableString,\n+\t\t\tvalue:    []byte{80, 81, 82},\n+\t\t\texpected: string(\"PQR\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"PrintableString (invalid)\",\n+\t\t\ttag:         cryptobyte_asn1.PrintableString,\n+\t\t\tvalue:       []byte{1, 2, 3},\n+\t\t\texpectedErr: \"invalid PrintableString\",\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"UTF8String\",\n+\t\t\ttag:      cryptobyte_asn1.UTF8String,\n+\t\t\tvalue:    []byte{80, 81, 82},\n+\t\t\texpected: string(\"PQR\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"UTF8String (invalid)\",\n+\t\t\ttag:         cryptobyte_asn1.UTF8String,\n+\t\t\tvalue:       []byte{255},\n+\t\t\texpectedErr: \"invalid UTF-8 string\",\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"BMPString\",\n+\t\t\ttag:      cryptobyte_asn1.Tag(asn1.TagBMPString),\n+\t\t\tvalue:    []byte{80, 81},\n+\t\t\texpected: string(\"\u5051\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"BMPString (invalid length)\",\n+\t\t\ttag:         cryptobyte_asn1.Tag(asn1.TagBMPString),\n+\t\t\tvalue:       []byte{255},\n+\t\t\texpectedErr: \"invalid BMPString\",\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"IA5String\",\n+\t\t\ttag:      cryptobyte_asn1.IA5String,\n+\t\t\tvalue:    []byte{80, 81},\n+\t\t\texpected: string(\"PQ\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"IA5String (invalid)\",\n+\t\t\ttag:         cryptobyte_asn1.IA5String,\n+\t\t\tvalue:       []byte{255},\n+\t\t\texpectedErr: \"invalid IA5String\",\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"NumericString\",\n+\t\t\ttag:      cryptobyte_asn1.Tag(asn1.TagNumericString),\n+\t\t\tvalue:    []byte{49, 50},\n+\t\t\texpected: string(\"12\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"NumericString (invalid)\",\n+\t\t\ttag:         cryptobyte_asn1.Tag(asn1.TagNumericString),\n+\t\t\tvalue:       []byte{80},\n+\t\t\texpectedErr: \"invalid NumericString\",\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range tests {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tout, err := parseASN1String(tc.tag, tc.value)\n+\t\t\tif err != nil && err.Error() != tc.expectedErr {\n+\t\t\t\tt.Fatalf(\"parseASN1String returned unexpected error: got %q, want %q\", err, tc.expectedErr)\n+\t\t\t} else if err == nil && tc.expectedErr != \"\" {\n+\t\t\t\tt.Fatalf(\"parseASN1String didn't fail, expected: %s\", tc.expectedErr)\n+\t\t\t}\n+\t\t\tif out != tc.expected {\n+\t\t\t\tt.Fatalf(\"parseASN1String returned unexpected value: got %q, want %q\", out, tc.expected)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"}, {"sha": "d1edcb8c482dc9daaa112474fc4606386fef68c6", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -676,6 +676,9 @@ func (c *fakeConn) PrepareContext(ctx context.Context, query string) (driver.Stm\n \n \t\tif c.waiter != nil {\n \t\t\tc.waiter(ctx)\n+\t\t\tif err := ctx.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n \t\t}\n \n \t\tif stmt.wait > 0 {"}, {"sha": "a921dd5a849b13d359e59f8af355563beb785af5", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -418,26 +418,31 @@ func TestQueryContextWait(t *testing.T) {\n \tdefer closeDB(t, db)\n \tprepares0 := numPrepares(t, db)\n \n-\t// TODO(kardianos): convert this from using a timeout to using an explicit\n-\t// cancel when the query signals that it is \"executing\" the query.\n-\tctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond)\n+\tctx, cancel := context.WithCancel(context.Background())\n \tdefer cancel()\n \n \t// This will trigger the *fakeConn.Prepare method which will take time\n \t// performing the query. The ctxDriverPrepare func will check the context\n \t// after this and close the rows and return an error.\n-\t_, err := db.QueryContext(ctx, \"WAIT|1s|SELECT|people|age,name|\")\n-\tif err != context.DeadlineExceeded {\n+\tc, err := db.Conn(ctx)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tc.dc.ci.(*fakeConn).waiter = func(c context.Context) {\n+\t\tcancel()\n+\t\t<-ctx.Done()\n+\t}\n+\t_, err = c.QueryContext(ctx, \"SELECT|people|age,name|\")\n+\tc.Close()\n+\tif err != context.Canceled {\n \t\tt.Fatalf(\"expected QueryContext to error with context deadline exceeded but returned %v\", err)\n \t}\n \n \t// Verify closed rows connection after error condition.\n \twaitForFree(t, db, 1)\n \tif prepares := numPrepares(t, db) - prepares0; prepares != 1 {\n-\t\t// TODO(kardianos): if the context timeouts before the db.QueryContext\n-\t\t// executes this check may fail. After adjusting how the context\n-\t\t// is canceled above revert this back to a Fatal error.\n-\t\tt.Logf(\"executed %d Prepare statements; want 1\", prepares)\n+\t\tt.Fatalf(\"executed %d Prepare statements; want 1\", prepares)\n \t}\n }\n \n@@ -455,14 +460,14 @@ func TestTxContextWait(t *testing.T) {\n \t}\n \ttx.keepConnOnRollback = false\n \n-\tgo func() {\n-\t\ttime.Sleep(15 * time.Millisecond)\n+\ttx.dc.ci.(*fakeConn).waiter = func(c context.Context) {\n \t\tcancel()\n-\t}()\n+\t\t<-ctx.Done()\n+\t}\n \t// This will trigger the *fakeConn.Prepare method which will take time\n \t// performing the query. The ctxDriverPrepare func will check the context\n \t// after this and close the rows and return an error.\n-\t_, err = tx.QueryContext(ctx, \"WAIT|1s|SELECT|people|age,name|\")\n+\t_, err = tx.QueryContext(ctx, \"SELECT|people|age,name|\")\n \tif err != context.Canceled {\n \t\tt.Fatalf(\"expected QueryContext to error with context canceled but returned %v\", err)\n \t}"}, {"sha": "8de03ff1063ffb1feb34d09ffd8f774e9fce303d", "filename": "libgo/go/debug/buildinfo/buildinfo.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fdebug%2Fbuildinfo%2Fbuildinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fdebug%2Fbuildinfo%2Fbuildinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fbuildinfo%2Fbuildinfo.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -75,8 +75,8 @@ func Read(r io.ReaderAt) (*BuildInfo, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tbi := &BuildInfo{}\n-\tif err := bi.UnmarshalText([]byte(mod)); err != nil {\n+\tbi, err := debug.ParseBuildInfo(mod)\n+\tif err != nil {\n \t\treturn nil, err\n \t}\n \tbi.GoVersion = vers"}, {"sha": "ac71626fda1dfb74be7f869053e548b9b7e9403a", "filename": "libgo/go/debug/buildinfo/buildinfo_test.go", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fdebug%2Fbuildinfo%2Fbuildinfo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fdebug%2Fbuildinfo%2Fbuildinfo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fbuildinfo%2Fbuildinfo_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -212,12 +212,10 @@ func TestReadFile(t *testing.T) {\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif tc.wantErr != \"\" {\n \t\t\t\t\t\t\tt.Fatalf(\"unexpected success; want error containing %q\", tc.wantErr)\n-\t\t\t\t\t\t} else if got, err := info.MarshalText(); err != nil {\n-\t\t\t\t\t\t\tt.Fatalf(\"unexpected error marshaling BuildInfo: %v\", err)\n-\t\t\t\t\t\t} else if got := cleanOutputForComparison(string(got)); got != tc.want {\n-\t\t\t\t\t\t\tif got != tc.want {\n-\t\t\t\t\t\t\t\tt.Fatalf(\"got:\\n%s\\nwant:\\n%s\", got, tc.want)\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tgot := info.String()\n+\t\t\t\t\t\tif clean := cleanOutputForComparison(string(got)); got != tc.want && clean != tc.want {\n+\t\t\t\t\t\t\tt.Fatalf(\"got:\\n%s\\nwant:\\n%s\", got, tc.want)\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t})"}, {"sha": "ce1fbc2b2a5136a0c449d65f6b0518f40c246377", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -88,6 +88,7 @@ var depsRules = `\n \t< internal/itoa\n \t< internal/unsafeheader\n \t< runtime/internal/sys\n+\t< runtime/internal/syscall\n \t< runtime/internal/atomic\n \t< runtime/internal/math\n \t< runtime\n@@ -418,7 +419,7 @@ var depsRules = `\n \tCGO, fmt, net !< CRYPTO;\n \n \t# CRYPTO-MATH is core bignum-based crypto - no cgo, net; fmt now ok.\n-\tCRYPTO, FMT, math/big\n+\tCRYPTO, FMT, math/big, embed\n \t< crypto/rand\n \t< crypto/internal/randutil\n \t< crypto/ed25519"}, {"sha": "d9e721d01b001deb0e25d8d584da41f0acd4016e", "filename": "libgo/go/go/doc/reader.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -927,6 +927,7 @@ var predeclaredTypes = map[string]bool{\n \t\"any\":        true,\n \t\"bool\":       true,\n \t\"byte\":       true,\n+\t\"comparable\": true,\n \t\"complex64\":  true,\n \t\"complex128\": true,\n \t\"error\":      true,"}, {"sha": "c06246a7b11875505f3006686016b08e58075353", "filename": "libgo/go/go/doc/testdata/b.0.golden", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.0.golden?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -46,6 +46,9 @@ VARIABLES\n \n \n FUNCTIONS\n+\t// Associated with comparable type if AllDecls is set. \n+\tfunc ComparableFactory() comparable\n+\n \t// \n \tfunc F(x int) int\n "}, {"sha": "2b62c3400c39f098bd5f0ca2f74d394b0cdcae6c", "filename": "libgo/go/go/doc/testdata/b.1.golden", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.1.golden?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -38,6 +38,12 @@ TYPES\n \t// \n \tfunc (x *T) M()\n \n+\t// Should only appear if AllDecls is set. \n+\ttype comparable struct{}\t// overrides a predeclared type comparable\n+\n+\t// Associated with comparable type if AllDecls is set. \n+\tfunc ComparableFactory() comparable\n+\n \t// \n \ttype notExported int\n "}, {"sha": "c06246a7b11875505f3006686016b08e58075353", "filename": "libgo/go/go/doc/testdata/b.2.golden", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.2.golden?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -46,6 +46,9 @@ VARIABLES\n \n \n FUNCTIONS\n+\t// Associated with comparable type if AllDecls is set. \n+\tfunc ComparableFactory() comparable\n+\n \t// \n \tfunc F(x int) int\n "}, {"sha": "61b512bc8a97d89e72131698ee4d4b54e516abac", "filename": "libgo/go/go/doc/testdata/b.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -27,9 +27,15 @@ func UintFactory() uint {}\n // Associated with uint type if AllDecls is set.\n func uintFactory() uint {}\n \n+// Associated with comparable type if AllDecls is set.\n+func ComparableFactory() comparable {}\n+\n // Should only appear if AllDecls is set.\n type uint struct{} // overrides a predeclared type uint\n \n+// Should only appear if AllDecls is set.\n+type comparable struct{} // overrides a predeclared type comparable\n+\n // ----------------------------------------------------------------------------\n // Exported declarations associated with non-exported types must always be shown.\n "}, {"sha": "51a3c3e67f9d8dbe9733a449c96f6475715530fe", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 152, "deletions": 32, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -543,6 +543,13 @@ func (p *parser) parseArrayType(lbrack token.Pos, len ast.Expr) *ast.ArrayType {\n \t\t}\n \t\tp.exprLev--\n \t}\n+\tif p.tok == token.COMMA {\n+\t\t// Trailing commas are accepted in type parameter\n+\t\t// lists but not in array type declarations.\n+\t\t// Accept for better error handling but complain.\n+\t\tp.error(p.pos, \"unexpected comma; expecting ]\")\n+\t\tp.next()\n+\t}\n \tp.expect(token.RBRACK)\n \telt := p.parseType()\n \treturn &ast.ArrayType{Lbrack: lbrack, Len: len, Elt: elt}\n@@ -797,7 +804,7 @@ func (p *parser) parseParamDecl(name *ast.Ident, typeSetsOK bool) (f field) {\n \treturn\n }\n \n-func (p *parser) parseParameterList(name0 *ast.Ident, closing token.Token) (params []*ast.Field) {\n+func (p *parser) parseParameterList(name0 *ast.Ident, typ0 ast.Expr, closing token.Token) (params []*ast.Field) {\n \tif p.trace {\n \t\tdefer un(trace(p, \"ParameterList\"))\n \t}\n@@ -816,8 +823,17 @@ func (p *parser) parseParameterList(name0 *ast.Ident, closing token.Token) (para\n \tvar named int // number of parameters that have an explicit name and type\n \n \tfor name0 != nil || p.tok != closing && p.tok != token.EOF {\n-\t\tpar := p.parseParamDecl(name0, typeSetsOK)\n+\t\tvar par field\n+\t\tif typ0 != nil {\n+\t\t\tif typeSetsOK {\n+\t\t\t\ttyp0 = p.embeddedElem(typ0)\n+\t\t\t}\n+\t\t\tpar = field{name0, typ0}\n+\t\t} else {\n+\t\t\tpar = p.parseParamDecl(name0, typeSetsOK)\n+\t\t}\n \t\tname0 = nil // 1st name was consumed if present\n+\t\ttyp0 = nil  // 1st typ was consumed if present\n \t\tif par.name != nil || par.typ != nil {\n \t\t\tlist = append(list, par)\n \t\t\tif par.name != nil && par.typ != nil {\n@@ -926,7 +942,7 @@ func (p *parser) parseParameters(acceptTParams bool) (tparams, params *ast.Field\n \t\topening := p.pos\n \t\tp.next()\n \t\t// [T any](params) syntax\n-\t\tlist := p.parseParameterList(nil, token.RBRACK)\n+\t\tlist := p.parseParameterList(nil, nil, token.RBRACK)\n \t\trbrack := p.expect(token.RBRACK)\n \t\ttparams = &ast.FieldList{Opening: opening, List: list, Closing: rbrack}\n \t\t// Type parameter lists must not be empty.\n@@ -940,7 +956,7 @@ func (p *parser) parseParameters(acceptTParams bool) (tparams, params *ast.Field\n \n \tvar fields []*ast.Field\n \tif p.tok != token.RPAREN {\n-\t\tfields = p.parseParameterList(nil, token.RPAREN)\n+\t\tfields = p.parseParameterList(nil, nil, token.RPAREN)\n \t}\n \n \trparen := p.expect(token.RPAREN)\n@@ -977,7 +993,7 @@ func (p *parser) parseFuncType() *ast.FuncType {\n \tpos := p.expect(token.FUNC)\n \ttparams, params := p.parseParameters(true)\n \tif tparams != nil {\n-\t\tp.error(tparams.Pos(), \"function type cannot have type parameters\")\n+\t\tp.error(tparams.Pos(), \"function type must have no type parameters\")\n \t}\n \tresults := p.parseResult()\n \n@@ -1004,18 +1020,21 @@ func (p *parser) parseMethodSpec() *ast.Field {\n \t\t\tp.exprLev--\n \t\t\tif name0, _ := x.(*ast.Ident); name0 != nil && p.tok != token.COMMA && p.tok != token.RBRACK {\n \t\t\t\t// generic method m[T any]\n-\t\t\t\tlist := p.parseParameterList(name0, token.RBRACK)\n-\t\t\t\trbrack := p.expect(token.RBRACK)\n-\t\t\t\ttparams := &ast.FieldList{Opening: lbrack, List: list, Closing: rbrack}\n+\t\t\t\t//\n+\t\t\t\t// Interface methods do not have type parameters. We parse them for a\n+\t\t\t\t// better error message and improved error recovery.\n+\t\t\t\t_ = p.parseParameterList(name0, nil, token.RBRACK)\n+\t\t\t\t_ = p.expect(token.RBRACK)\n+\t\t\t\tp.error(lbrack, \"interface method must have no type parameters\")\n+\n \t\t\t\t// TODO(rfindley) refactor to share code with parseFuncType.\n \t\t\t\t_, params := p.parseParameters(false)\n \t\t\t\tresults := p.parseResult()\n \t\t\t\tidents = []*ast.Ident{ident}\n \t\t\t\ttyp = &ast.FuncType{\n-\t\t\t\t\tFunc:       token.NoPos,\n-\t\t\t\t\tTypeParams: tparams,\n-\t\t\t\t\tParams:     params,\n-\t\t\t\t\tResults:    results,\n+\t\t\t\t\tFunc:    token.NoPos,\n+\t\t\t\t\tParams:  params,\n+\t\t\t\t\tResults: results,\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// embedded instantiated type\n@@ -1781,7 +1800,12 @@ func (p *parser) tokPrec() (token.Token, int) {\n \treturn tok, tok.Precedence()\n }\n \n-func (p *parser) parseBinaryExpr(x ast.Expr, prec1 int) ast.Expr {\n+// parseBinaryExpr parses a (possibly) binary expression.\n+// If x is non-nil, it is used as the left operand.\n+// If check is true, operands are checked to be valid expressions.\n+//\n+// TODO(rfindley): parseBinaryExpr has become overloaded. Consider refactoring.\n+func (p *parser) parseBinaryExpr(x ast.Expr, prec1 int, check bool) ast.Expr {\n \tif p.trace {\n \t\tdefer un(trace(p, \"BinaryExpr\"))\n \t}\n@@ -1795,9 +1819,30 @@ func (p *parser) parseBinaryExpr(x ast.Expr, prec1 int) ast.Expr {\n \t\t\treturn x\n \t\t}\n \t\tpos := p.expect(op)\n-\t\ty := p.parseBinaryExpr(nil, oprec+1)\n-\t\tx = &ast.BinaryExpr{X: p.checkExpr(x), OpPos: pos, Op: op, Y: p.checkExpr(y)}\n+\t\ty := p.parseBinaryExpr(nil, oprec+1, check)\n+\t\tif check {\n+\t\t\tx = p.checkExpr(x)\n+\t\t\ty = p.checkExpr(y)\n+\t\t}\n+\t\tx = &ast.BinaryExpr{X: x, OpPos: pos, Op: op, Y: y}\n+\t}\n+}\n+\n+// checkBinaryExpr checks binary expressions that were not already checked by\n+// parseBinaryExpr, because the latter was called with check=false.\n+func (p *parser) checkBinaryExpr(x ast.Expr) {\n+\tbx, ok := x.(*ast.BinaryExpr)\n+\tif !ok {\n+\t\treturn\n \t}\n+\n+\tbx.X = p.checkExpr(bx.X)\n+\tbx.Y = p.checkExpr(bx.Y)\n+\n+\t// parseBinaryExpr checks x and y for each binary expr in a tree, so we\n+\t// traverse the tree of binary exprs starting from x.\n+\tp.checkBinaryExpr(bx.X)\n+\tp.checkBinaryExpr(bx.Y)\n }\n \n // The result may be a type or even a raw type ([...]int). Callers must\n@@ -1808,7 +1853,7 @@ func (p *parser) parseExpr() ast.Expr {\n \t\tdefer un(trace(p, \"Expression\"))\n \t}\n \n-\treturn p.parseBinaryExpr(nil, token.LowestPrec+1)\n+\treturn p.parseBinaryExpr(nil, token.LowestPrec+1, true)\n }\n \n func (p *parser) parseRhs() ast.Expr {\n@@ -2531,12 +2576,12 @@ func (p *parser) parseValueSpec(doc *ast.CommentGroup, _ token.Pos, keyword toke\n \treturn spec\n }\n \n-func (p *parser) parseGenericType(spec *ast.TypeSpec, openPos token.Pos, name0 *ast.Ident) {\n+func (p *parser) parseGenericType(spec *ast.TypeSpec, openPos token.Pos, name0 *ast.Ident, typ0 ast.Expr) {\n \tif p.trace {\n \t\tdefer un(trace(p, \"parseGenericType\"))\n \t}\n \n-\tlist := p.parseParameterList(name0, token.RBRACK)\n+\tlist := p.parseParameterList(name0, typ0, token.RBRACK)\n \tclosePos := p.expect(token.RBRACK)\n \tspec.TypeParams = &ast.FieldList{Opening: openPos, List: list, Closing: closePos}\n \t// Let the type checker decide whether to accept type parameters on aliases:\n@@ -2561,31 +2606,85 @@ func (p *parser) parseTypeSpec(doc *ast.CommentGroup, _ token.Pos, _ token.Token\n \t\tlbrack := p.pos\n \t\tp.next()\n \t\tif p.tok == token.IDENT {\n-\t\t\t// array type or generic type: [name0...\n-\t\t\tname0 := p.parseIdent()\n+\t\t\t// We may have an array type or a type parameter list.\n+\t\t\t// In either case we expect an expression x (which may\n+\t\t\t// just be a name, or a more complex expression) which\n+\t\t\t// we can analyze further.\n+\t\t\t//\n+\t\t\t// A type parameter list may have a type bound starting\n+\t\t\t// with a \"[\" as in: P []E. In that case, simply parsing\n+\t\t\t// an expression would lead to an error: P[] is invalid.\n+\t\t\t// But since index or slice expressions are never constant\n+\t\t\t// and thus invalid array length expressions, if we see a\n+\t\t\t// \"[\" following a name it must be the start of an array\n+\t\t\t// or slice constraint. Only if we don't see a \"[\" do we\n+\t\t\t// need to parse a full expression.\n \n \t\t\t// Index or slice expressions are never constant and thus invalid\n \t\t\t// array length expressions. Thus, if we see a \"[\" following name\n \t\t\t// we can safely assume that \"[\" name starts a type parameter list.\n-\t\t\tvar x ast.Expr // x != nil means x is the array length expression\n+\t\t\tvar x ast.Expr = p.parseIdent()\n \t\t\tif p.tok != token.LBRACK {\n-\t\t\t\t// We may still have either an array type or generic type -- check if\n-\t\t\t\t// name0 is the entire expr.\n+\t\t\t\t// To parse the expression starting with name, expand\n+\t\t\t\t// the call sequence we would get by passing in name\n+\t\t\t\t// to parser.expr, and pass in name to parsePrimaryExpr.\n \t\t\t\tp.exprLev++\n-\t\t\t\tlhs := p.parsePrimaryExpr(name0)\n-\t\t\t\tx = p.parseBinaryExpr(lhs, token.LowestPrec+1)\n+\t\t\t\tlhs := p.parsePrimaryExpr(x)\n+\t\t\t\tx = p.parseBinaryExpr(lhs, token.LowestPrec+1, false)\n \t\t\t\tp.exprLev--\n-\t\t\t\tif x == name0 && p.tok != token.RBRACK {\n-\t\t\t\t\tx = nil\n+\t\t\t}\n+\n+\t\t\t// analyze the cases\n+\t\t\tvar pname *ast.Ident // pname != nil means pname is the type parameter name\n+\t\t\tvar ptype ast.Expr   // ptype != nil means ptype is the type parameter type; pname != nil in this case\n+\n+\t\t\tswitch t := x.(type) {\n+\t\t\tcase *ast.Ident:\n+\t\t\t\t// Unless we see a \"]\", we are at the start of a type parameter list.\n+\t\t\t\tif p.tok != token.RBRACK {\n+\t\t\t\t\t// d.Name \"[\" name ...\n+\t\t\t\t\tpname = t\n+\t\t\t\t\t// no ptype\n+\t\t\t\t}\n+\t\t\tcase *ast.BinaryExpr:\n+\t\t\t\t// If we have an expression of the form name*T, and T is a (possibly\n+\t\t\t\t// parenthesized) type literal or the next token is a comma, we are\n+\t\t\t\t// at the start of a type parameter list.\n+\t\t\t\tif name, _ := t.X.(*ast.Ident); name != nil {\n+\t\t\t\t\tif t.Op == token.MUL && (isTypeLit(t.Y) || p.tok == token.COMMA) {\n+\t\t\t\t\t\t// d.Name \"[\" name \"*\" t.Y\n+\t\t\t\t\t\t// d.Name \"[\" name \"*\" t.Y \",\"\n+\t\t\t\t\t\t// convert t into unary *t.Y\n+\t\t\t\t\t\tpname = name\n+\t\t\t\t\t\tptype = &ast.StarExpr{Star: t.OpPos, X: t.Y}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif pname == nil {\n+\t\t\t\t\t// A normal binary expression. Since we passed check=false, we must\n+\t\t\t\t\t// now check its operands.\n+\t\t\t\t\tp.checkBinaryExpr(t)\n+\t\t\t\t}\n+\t\t\tcase *ast.CallExpr:\n+\t\t\t\t// If we have an expression of the form name(T), and T is a (possibly\n+\t\t\t\t// parenthesized) type literal or the next token is a comma, we are\n+\t\t\t\t// at the start of a type parameter list.\n+\t\t\t\tif name, _ := t.Fun.(*ast.Ident); name != nil {\n+\t\t\t\t\tif len(t.Args) == 1 && !t.Ellipsis.IsValid() && (isTypeLit(t.Args[0]) || p.tok == token.COMMA) {\n+\t\t\t\t\t\t// d.Name \"[\" name \"(\" t.ArgList[0] \")\"\n+\t\t\t\t\t\t// d.Name \"[\" name \"(\" t.ArgList[0] \")\" \",\"\n+\t\t\t\t\t\tpname = name\n+\t\t\t\t\t\tptype = t.Args[0]\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif x == nil {\n-\t\t\t\t// generic type [T any];\n-\t\t\t\tp.parseGenericType(spec, lbrack, name0)\n+\t\t\tif pname != nil {\n+\t\t\t\t// d.Name \"[\" pname ...\n+\t\t\t\t// d.Name \"[\" pname ptype ...\n+\t\t\t\t// d.Name \"[\" pname ptype \",\" ...\n+\t\t\t\tp.parseGenericType(spec, lbrack, pname, ptype)\n \t\t\t} else {\n-\t\t\t\t// array type\n-\t\t\t\t// TODO(rfindley) should resolve all identifiers in x.\n+\t\t\t\t// d.Name \"[\" x ...\n \t\t\t\tspec.Type = p.parseArrayType(lbrack, x)\n \t\t\t}\n \t\t} else {\n@@ -2608,6 +2707,21 @@ func (p *parser) parseTypeSpec(doc *ast.CommentGroup, _ token.Pos, _ token.Token\n \treturn spec\n }\n \n+// isTypeLit reports whether x is a (possibly parenthesized) type literal.\n+func isTypeLit(x ast.Expr) bool {\n+\tswitch x := x.(type) {\n+\tcase *ast.ArrayType, *ast.StructType, *ast.FuncType, *ast.InterfaceType, *ast.MapType, *ast.ChanType:\n+\t\treturn true\n+\tcase *ast.StarExpr:\n+\t\t// *T may be a pointer dereferenciation.\n+\t\t// Only consider *T as type literal if T is a type literal.\n+\t\treturn isTypeLit(x.X)\n+\tcase *ast.ParenExpr:\n+\t\treturn isTypeLit(x.X)\n+\t}\n+\treturn false\n+}\n+\n func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction) *ast.GenDecl {\n \tif p.trace {\n \t\tdefer un(trace(p, \"GenDecl(\"+keyword.String()+\")\"))\n@@ -2655,6 +2769,12 @@ func (p *parser) parseFuncDecl() *ast.FuncDecl {\n \tident := p.parseIdent()\n \n \ttparams, params := p.parseParameters(true)\n+\tif recv != nil && tparams != nil {\n+\t\t// Method declarations do not have type parameters. We parse them for a\n+\t\t// better error message and improved error recovery.\n+\t\tp.error(tparams.Opening, \"method must have no type parameters\")\n+\t\ttparams = nil\n+\t}\n \tresults := p.parseResult()\n \n \tvar body *ast.BlockStmt"}, {"sha": "d66a194c12bb0b589050583121e8956f5a22e6e2", "filename": "libgo/go/go/parser/resolver.go", "status": "modified", "additions": 78, "deletions": 15, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fparser%2Fresolver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fparser%2Fresolver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fresolver.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"fmt\"\n \t\"go/ast\"\n \t\"go/token\"\n+\t\"strings\"\n )\n \n const debugResolve = false\n@@ -24,6 +25,7 @@ func resolveFile(file *ast.File, handle *token.File, declErr func(token.Pos, str\n \t\tdeclErr:  declErr,\n \t\ttopScope: pkgScope,\n \t\tpkgScope: pkgScope,\n+\t\tdepth:    1,\n \t}\n \n \tfor _, decl := range file.Decls {\n@@ -45,7 +47,7 @@ func resolveFile(file *ast.File, handle *token.File, declErr func(token.Pos, str\n \t\t\ti++\n \t\t} else if debugResolve {\n \t\t\tpos := ident.Obj.Decl.(interface{ Pos() token.Pos }).Pos()\n-\t\t\tr.dump(\"resolved %s@%v to package object %v\", ident.Name, ident.Pos(), pos)\n+\t\t\tr.trace(\"resolved %s@%v to package object %v\", ident.Name, ident.Pos(), pos)\n \t\t}\n \t}\n \tfile.Scope = r.pkgScope\n@@ -60,15 +62,16 @@ type resolver struct {\n \tpkgScope   *ast.Scope   // pkgScope.Outer == nil\n \ttopScope   *ast.Scope   // top-most scope; may be pkgScope\n \tunresolved []*ast.Ident // unresolved identifiers\n+\tdepth      int          // scope depth\n \n \t// Label scopes\n \t// (maintained by open/close LabelScope)\n \tlabelScope  *ast.Scope     // label scope for current function\n \ttargetStack [][]*ast.Ident // stack of unresolved labels\n }\n \n-func (r *resolver) dump(format string, args ...any) {\n-\tfmt.Println(\">>> \" + r.sprintf(format, args...))\n+func (r *resolver) trace(format string, args ...any) {\n+\tfmt.Println(strings.Repeat(\". \", r.depth) + r.sprintf(format, args...))\n }\n \n func (r *resolver) sprintf(format string, args ...any) string {\n@@ -83,14 +86,16 @@ func (r *resolver) sprintf(format string, args ...any) string {\n \n func (r *resolver) openScope(pos token.Pos) {\n \tif debugResolve {\n-\t\tr.dump(\"opening scope @%v\", pos)\n+\t\tr.trace(\"opening scope @%v\", pos)\n+\t\tr.depth++\n \t}\n \tr.topScope = ast.NewScope(r.topScope)\n }\n \n func (r *resolver) closeScope() {\n \tif debugResolve {\n-\t\tr.dump(\"closing scope\")\n+\t\tr.depth--\n+\t\tr.trace(\"closing scope\")\n \t}\n \tr.topScope = r.topScope.Outer\n }\n@@ -117,21 +122,27 @@ func (r *resolver) closeLabelScope() {\n \n func (r *resolver) declare(decl, data any, scope *ast.Scope, kind ast.ObjKind, idents ...*ast.Ident) {\n \tfor _, ident := range idents {\n-\t\tassert(ident.Obj == nil, \"identifier already declared or resolved\")\n+\t\tif ident.Obj != nil {\n+\t\t\tpanic(fmt.Sprintf(\"%v: identifier %s already declared or resolved\", ident.Pos(), ident.Name))\n+\t\t}\n \t\tobj := ast.NewObj(kind, ident.Name)\n \t\t// remember the corresponding declaration for redeclaration\n \t\t// errors and global variable resolution/typechecking phase\n \t\tobj.Decl = decl\n \t\tobj.Data = data\n-\t\tident.Obj = obj\n+\t\t// Identifiers (for receiver type parameters) are written to the scope, but\n+\t\t// never set as the resolved object. See issue #50956.\n+\t\tif _, ok := decl.(*ast.Ident); !ok {\n+\t\t\tident.Obj = obj\n+\t\t}\n \t\tif ident.Name != \"_\" {\n \t\t\tif debugResolve {\n-\t\t\t\tr.dump(\"declaring %s@%v\", ident.Name, ident.Pos())\n+\t\t\t\tr.trace(\"declaring %s@%v\", ident.Name, ident.Pos())\n \t\t\t}\n \t\t\tif alt := scope.Insert(obj); alt != nil && r.declErr != nil {\n \t\t\t\tprevDecl := \"\"\n \t\t\t\tif pos := alt.Pos(); pos.IsValid() {\n-\t\t\t\t\tprevDecl = fmt.Sprintf(\"\\n\\tprevious declaration at %s\", r.handle.Position(pos))\n+\t\t\t\t\tprevDecl = r.sprintf(\"\\n\\tprevious declaration at %v\", pos)\n \t\t\t\t}\n \t\t\t\tr.declErr(ident.Pos(), fmt.Sprintf(\"%s redeclared in this block%s\", ident.Name, prevDecl))\n \t\t\t}\n@@ -153,7 +164,7 @@ func (r *resolver) shortVarDecl(decl *ast.AssignStmt) {\n \t\t\tident.Obj = obj\n \t\t\tif ident.Name != \"_\" {\n \t\t\t\tif debugResolve {\n-\t\t\t\t\tr.dump(\"declaring %s@%v\", ident.Name, ident.Pos())\n+\t\t\t\t\tr.trace(\"declaring %s@%v\", ident.Name, ident.Pos())\n \t\t\t\t}\n \t\t\t\tif alt := r.topScope.Insert(obj); alt != nil {\n \t\t\t\t\tident.Obj = alt // redeclaration\n@@ -180,7 +191,7 @@ var unresolved = new(ast.Object)\n //\n func (r *resolver) resolve(ident *ast.Ident, collectUnresolved bool) {\n \tif ident.Obj != nil {\n-\t\tpanic(fmt.Sprintf(\"%s: identifier %s already declared or resolved\", r.handle.Position(ident.Pos()), ident.Name))\n+\t\tpanic(r.sprintf(\"%v: identifier %s already declared or resolved\", ident.Pos(), ident.Name))\n \t}\n \t// '_' should never refer to existing declarations, because it has special\n \t// handling in the spec.\n@@ -189,8 +200,15 @@ func (r *resolver) resolve(ident *ast.Ident, collectUnresolved bool) {\n \t}\n \tfor s := r.topScope; s != nil; s = s.Outer {\n \t\tif obj := s.Lookup(ident.Name); obj != nil {\n+\t\t\tif debugResolve {\n+\t\t\t\tr.trace(\"resolved %v:%s to %v\", ident.Pos(), ident.Name, obj)\n+\t\t\t}\n \t\t\tassert(obj.Name != \"\", \"obj with no name\")\n-\t\t\tident.Obj = obj\n+\t\t\t// Identifiers (for receiver type parameters) are written to the scope,\n+\t\t\t// but never set as the resolved object. See issue #50956.\n+\t\t\tif _, ok := obj.Decl.(*ast.Ident); !ok {\n+\t\t\t\tident.Obj = obj\n+\t\t\t}\n \t\t\treturn\n \t\t}\n \t}\n@@ -227,7 +245,7 @@ func (r *resolver) walkStmts(list []ast.Stmt) {\n \n func (r *resolver) Visit(node ast.Node) ast.Visitor {\n \tif debugResolve && node != nil {\n-\t\tr.dump(\"node %T@%v\", node, node.Pos())\n+\t\tr.trace(\"node %T@%v\", node, node.Pos())\n \t}\n \n \tswitch n := node.(type) {\n@@ -461,8 +479,7 @@ func (r *resolver) Visit(node ast.Node) ast.Visitor {\n \t\tr.openScope(n.Pos())\n \t\tdefer r.closeScope()\n \n-\t\t// Resolve the receiver first, without declaring.\n-\t\tr.resolveList(n.Recv)\n+\t\tr.walkRecv(n.Recv)\n \n \t\t// Type parameters are walked normally: they can reference each other, and\n \t\t// can be referenced by normal parameters.\n@@ -519,6 +536,52 @@ func (r *resolver) declareList(list *ast.FieldList, kind ast.ObjKind) {\n \t}\n }\n \n+func (r *resolver) walkRecv(recv *ast.FieldList) {\n+\t// If our receiver has receiver type parameters, we must declare them before\n+\t// trying to resolve the rest of the receiver, and avoid re-resolving the\n+\t// type parameter identifiers.\n+\tif recv == nil || len(recv.List) == 0 {\n+\t\treturn // nothing to do\n+\t}\n+\ttyp := recv.List[0].Type\n+\tif ptr, ok := typ.(*ast.StarExpr); ok {\n+\t\ttyp = ptr.X\n+\t}\n+\n+\tvar declareExprs []ast.Expr // exprs to declare\n+\tvar resolveExprs []ast.Expr // exprs to resolve\n+\tswitch typ := typ.(type) {\n+\tcase *ast.IndexExpr:\n+\t\tdeclareExprs = []ast.Expr{typ.Index}\n+\t\tresolveExprs = append(resolveExprs, typ.X)\n+\tcase *ast.IndexListExpr:\n+\t\tdeclareExprs = typ.Indices\n+\t\tresolveExprs = append(resolveExprs, typ.X)\n+\tdefault:\n+\t\tresolveExprs = append(resolveExprs, typ)\n+\t}\n+\tfor _, expr := range declareExprs {\n+\t\tif id, _ := expr.(*ast.Ident); id != nil {\n+\t\t\tr.declare(expr, nil, r.topScope, ast.Typ, id)\n+\t\t} else {\n+\t\t\t// The receiver type parameter expression is invalid, but try to resolve\n+\t\t\t// it anyway for consistency.\n+\t\t\tresolveExprs = append(resolveExprs, expr)\n+\t\t}\n+\t}\n+\tfor _, expr := range resolveExprs {\n+\t\tif expr != nil {\n+\t\t\tast.Walk(r, expr)\n+\t\t}\n+\t}\n+\t// The receiver is invalid, but try to resolve it anyway for consistency.\n+\tfor _, f := range recv.List[1:] {\n+\t\tif f.Type != nil {\n+\t\t\tast.Walk(r, f.Type)\n+\t\t}\n+\t}\n+}\n+\n func (r *resolver) walkFieldList(list *ast.FieldList, kind ast.ObjKind) {\n \tif list == nil {\n \t\treturn"}, {"sha": "d117f0d3815aad7913b0eb71068e6276f84572a0", "filename": "libgo/go/go/parser/short_test.go", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -74,7 +74,7 @@ var validWithTParamsOnly = []string{\n \t`package p; type T[P any /* ERROR \"expected ']', found any\" */ ] struct { P }`,\n \t`package p; type T[P comparable /* ERROR \"expected ']', found comparable\" */ ] struct { P }`,\n \t`package p; type T[P comparable /* ERROR \"expected ']', found comparable\" */ [P]] struct { P }`,\n-\t`package p; type T[P1, /* ERROR \"expected ']', found ','\" */ P2 any] struct { P1; f []P2 }`,\n+\t`package p; type T[P1, /* ERROR \"unexpected comma\" */ P2 any] struct { P1; f []P2 }`,\n \t`package p; func _[ /* ERROR \"expected '\\(', found '\\['\" */ T any]()()`,\n \t`package p; func _(T (P))`,\n \t`package p; func f[ /* ERROR \"expected '\\(', found '\\['\" */ A, B any](); func _() { _ = f[int, int] }`,\n@@ -83,8 +83,8 @@ var validWithTParamsOnly = []string{\n \t`package p; func _(p.T[ /* ERROR \"missing ',' in parameter list\" */ Q])`,\n \t`package p; type _[A interface /* ERROR \"expected ']', found 'interface'\" */ {},] struct{}`,\n \t`package p; type _[A interface /* ERROR \"expected ']', found 'interface'\" */ {}] struct{}`,\n-\t`package p; type _[A, /* ERROR \"expected ']', found ','\" */  B any,] struct{}`,\n-\t`package p; type _[A, /* ERROR \"expected ']', found ','\" */ B any] struct{}`,\n+\t`package p; type _[A, /* ERROR \"unexpected comma\" */  B any,] struct{}`,\n+\t`package p; type _[A, /* ERROR \"unexpected comma\" */ B any] struct{}`,\n \t`package p; type _[A any /* ERROR \"expected ']', found any\" */,] struct{}`,\n \t`package p; type _[A any /* ERROR \"expected ']', found any\" */ ]struct{}`,\n \t`package p; type _[A any /* ERROR \"expected ']', found any\" */ ] struct{ A }`,\n@@ -94,11 +94,9 @@ var validWithTParamsOnly = []string{\n \t`package p; func _[ /* ERROR \"expected '\\(', found '\\['\" */ A, B any](a A) B`,\n \t`package p; func _[ /* ERROR \"expected '\\(', found '\\['\" */ A, B C](a A) B`,\n \t`package p; func _[ /* ERROR \"expected '\\(', found '\\['\" */ A, B C[A, B]](a A) B`,\n-\t`package p; func (T) _[ /* ERROR \"expected '\\(', found '\\['\" */ A, B any](a A) B`,\n-\t`package p; func (T) _[ /* ERROR \"expected '\\(', found '\\['\" */ A, B C](a A) B`,\n-\t`package p; func (T) _[ /* ERROR \"expected '\\(', found '\\['\" */ A, B C[A, B]](a A) B`,\n-\t`package p; type _[A, /* ERROR \"expected ']', found ','\" */ B any] interface { _(a A) B }`,\n-\t`package p; type _[A, /* ERROR \"expected ']', found ','\" */ B C[A, B]] interface { _(a A) B }`,\n+\n+\t`package p; type _[A, /* ERROR \"unexpected comma\" */ B any] interface { _(a A) B }`,\n+\t`package p; type _[A, /* ERROR \"unexpected comma\" */ B C[A, B]] interface { _(a A) B }`,\n \t`package p; func _[ /* ERROR \"expected '\\(', found '\\['\" */ T1, T2 interface{}](x T1) T2`,\n \t`package p; func _[ /* ERROR \"expected '\\(', found '\\['\" */ T1 interface{ m() }, T2, T3 interface{}](x T1, y T3) T2`,\n \t`package p; var _ = [ /* ERROR \"expected expression\" */ ]T[int]{}`,\n@@ -110,10 +108,10 @@ var validWithTParamsOnly = []string{\n \t`package p; var _ T[ /* ERROR \"expected ';', found '\\['\" */ chan int]`,\n \n \t// TODO(rfindley) this error message could be improved.\n-\t`package p; func (_ /* ERROR \"mixed named and unnamed parameters\" */ R[P]) _[T any](x T)`,\n-\t`package p; func (_ /* ERROR \"mixed named and unnamed parameters\" */ R[ P, Q]) _[T1, T2 any](x T)`,\n+\t`package p; func (_ /* ERROR \"mixed named and unnamed parameters\" */ R[P]) _(x T)`,\n+\t`package p; func (_ /* ERROR \"mixed named and unnamed parameters\" */ R[ P, Q]) _(x T)`,\n \n-\t`package p; func (R[P] /* ERROR \"missing element type\" */ ) _[T any]()`,\n+\t`package p; func (R[P] /* ERROR \"missing element type\" */ ) _()`,\n \t`package p; func _(T[P] /* ERROR \"missing element type\" */ )`,\n \t`package p; func _(T[P1, /* ERROR \"expected ']', found ','\" */ P2, P3 ])`,\n \t`package p; func _(T[P] /* ERROR \"missing element type\" */ ) T[P]`,\n@@ -122,7 +120,7 @@ var validWithTParamsOnly = []string{\n \t`package p; type _ interface{int| /* ERROR \"expected ';'\" */ float32; bool; m(); string;}`,\n \t`package p; type I1[T any /* ERROR \"expected ']', found any\" */ ] interface{}; type I2 interface{ I1[int] }`,\n \t`package p; type I1[T any /* ERROR \"expected ']', found any\" */ ] interface{}; type I2[T any] interface{ I1[T] }`,\n-\t`package p; type _ interface { f[ /* ERROR \"expected ';', found '\\['\" */ T any]() }`,\n+\t`package p; type _ interface { N[ /* ERROR \"expected ';', found '\\['\" */ T] }`,\n \t`package p; type T[P any /* ERROR \"expected ']'\" */ ] = T0`,\n }\n \n@@ -195,7 +193,7 @@ var invalids = []string{\n \t`package p; func f() { go func() { func() { f(x func /* ERROR \"missing ','\" */ (){}) } } }`,\n \t`package p; func _() (type /* ERROR \"found 'type'\" */ T)(T)`,\n \t`package p; func (type /* ERROR \"found 'type'\" */ T)(T) _()`,\n-\t`package p; type _[A+B, /* ERROR \"expected ']'\" */ ] int`,\n+\t`package p; type _[A+B, /* ERROR \"unexpected comma\" */ ] int`,\n \n \t// TODO(rfindley): this error should be positioned on the ':'\n \t`package p; var a = a[[]int:[ /* ERROR \"expected expression\" */ ]int];`,\n@@ -233,22 +231,34 @@ var invalidNoTParamErrs = []string{\n \t`package p; type T[P any /* ERROR \"expected ']', found any\" */ ] = T0`,\n \t`package p; var _ func[ /* ERROR \"expected '\\(', found '\\['\" */ T any](T)`,\n \t`package p; func _[ /* ERROR \"expected '\\(', found '\\['\" */ ]()`,\n-\t`package p; type _[A, /* ERROR \"expected ']', found ','\" */] struct{ A }`,\n+\t`package p; type _[A, /* ERROR \"unexpected comma\" */] struct{ A }`,\n \t`package p; func _[ /* ERROR \"expected '\\(', found '\\['\" */ type P, *Q interface{}]()`,\n+\n+\t`package p; func (T) _[ /* ERROR \"expected '\\(', found '\\['\" */ A, B any](a A) B`,\n+\t`package p; func (T) _[ /* ERROR \"expected '\\(', found '\\['\" */ A, B C](a A) B`,\n+\t`package p; func (T) _[ /* ERROR \"expected '\\(', found '\\['\" */ A, B C[A, B]](a A) B`,\n+\n+\t`package p; func(*T[ /* ERROR \"missing ',' in parameter list\" */ e, e]) _()`,\n }\n \n // invalidTParamErrs holds invalid source code examples annotated with the\n // error messages produced when ParseTypeParams is set.\n var invalidTParamErrs = []string{\n \t`package p; type _[_ any] int; var _ = T[] /* ERROR \"expected operand\" */ {}`,\n-\t`package p; var _ func[ /* ERROR \"cannot have type parameters\" */ T any](T)`,\n+\t`package p; var _ func[ /* ERROR \"must have no type parameters\" */ T any](T)`,\n \t`package p; func _[]/* ERROR \"empty type parameter list\" */()`,\n \n \t// TODO(rfindley) a better location would be after the ']'\n-\t`package p; type _[A/* ERROR \"all type parameters must be named\" */,] struct{ A }`,\n+\t`package p; type _[A /* ERROR \"all type parameters must be named\" */ ,] struct{ A }`,\n \n \t// TODO(rfindley) this error is confusing.\n-\t`package p; func _[type /* ERROR \"all type parameters must be named\" */P, *Q interface{}]()`,\n+\t`package p; func _[type /* ERROR \"all type parameters must be named\" */ P, *Q interface{}]()`,\n+\n+\t`package p; func (T) _[ /* ERROR \"must have no type parameters\" */ A, B any](a A) B`,\n+\t`package p; func (T) _[ /* ERROR \"must have no type parameters\" */ A, B C](a A) B`,\n+\t`package p; func (T) _[ /* ERROR \"must have no type parameters\" */ A, B C[A, B]](a A) B`,\n+\n+\t`package p; func(*T[e, e /* ERROR \"e redeclared\" */ ]) _()`,\n }\n \n func TestInvalid(t *testing.T) {"}, {"sha": "7395ca2a34493cfaf93e9c4dd8795410f9fa5242", "filename": "libgo/go/go/parser/testdata/resolution/typeparams.go2", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Fresolution%2Ftypeparams.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Fresolution%2Ftypeparams.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Fresolution%2Ftypeparams.go2?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -25,10 +25,15 @@ func Add /* =@AddDecl */[T /* =@T */ Addable /* @Addable */](l /* =@l */, r /* =\n \n type Receiver /* =@Receiver */[P /* =@P */ any] struct {}\n \n+type RP /* =@RP1 */ struct{}\n+\n // TODO(rFindley): make a decision on how/whether to resolve identifiers that\n // refer to receiver type parameters, as is the case for the 'P' result\n // parameter below.\n-func (r /* =@recv */ Receiver /* @Receiver */ [P]) m() P {}\n+//\n+// For now, we ensure that types are not incorrectly resolved when receiver\n+// type parameters are in scope.\n+func (r /* =@recv */ Receiver /* @Receiver */ [RP]) m(RP) RP {}\n \n func f /* =@f */[T1 /* =@T1 */ interface{~[]T2 /* @T2 */}, T2 /* =@T2 */ any](\n   x /* =@x */ T1 /* @T1 */, T1 /* =@T1_duplicate */ y,  // Note that this is a bug:\n@@ -41,3 +46,6 @@ func f /* =@f */[T1 /* =@T1 */ interface{~[]T2 /* @T2 */}, T2 /* =@T2 */ any](\n   T1 /* @T1 */ := 0\n   var t1var /* =@t1var */ T1 /* @T1 */\n }\n+\n+// From issue #39634\n+func(*ph1[e, e])h(d)"}, {"sha": "479cb968714a250c18cfe8edbaadfaf7537a2602", "filename": "libgo/go/go/parser/testdata/typeparams.src", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Ftypeparams.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Ftypeparams.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Ftypeparams.src?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -9,7 +9,7 @@ package p\n \n type List[E any /* ERROR \"expected ']', found any\" */ ] []E\n \n-type Pair[L, /* ERROR \"expected ']', found ','\" */ R any] struct {\n+type Pair[L, /* ERROR \"unexpected comma\" */ R any] struct {\n \tLeft L\n \tRight R\n }"}, {"sha": "f2170dbc4f31c1ecd57660dd93867729001ab1c8", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -367,20 +367,48 @@ func (p *printer) parameters(fields *ast.FieldList, isTypeParam bool) {\n \t\t\tp.expr(stripParensAlways(par.Type))\n \t\t\tprevLine = parLineEnd\n \t\t}\n+\n \t\t// if the closing \")\" is on a separate line from the last parameter,\n \t\t// print an additional \",\" and line break\n \t\tif closing := p.lineFor(fields.Closing); 0 < prevLine && prevLine < closing {\n \t\t\tp.print(token.COMMA)\n \t\t\tp.linebreak(closing, 0, ignore, true)\n+\t\t} else if isTypeParam && fields.NumFields() == 1 {\n+\t\t\t// Otherwise, if we are in a type parameter list that could be confused\n+\t\t\t// with the constant array length expression [P*C], print a comma so that\n+\t\t\t// parsing is unambiguous.\n+\t\t\t//\n+\t\t\t// Note that while ParenExprs can also be ambiguous (issue #49482), the\n+\t\t\t// printed type is never parenthesized (stripParensAlways is used above).\n+\t\t\tif t, _ := fields.List[0].Type.(*ast.StarExpr); t != nil && !isTypeLit(t.X) {\n+\t\t\t\tp.print(token.COMMA)\n+\t\t\t}\n \t\t}\n+\n \t\t// unindent if we indented\n \t\tif ws == ignore {\n \t\t\tp.print(unindent)\n \t\t}\n \t}\n+\n \tp.print(fields.Closing, closeTok)\n }\n \n+// isTypeLit reports whether x is a (possibly parenthesized) type literal.\n+func isTypeLit(x ast.Expr) bool {\n+\tswitch x := x.(type) {\n+\tcase *ast.ArrayType, *ast.StructType, *ast.FuncType, *ast.InterfaceType, *ast.MapType, *ast.ChanType:\n+\t\treturn true\n+\tcase *ast.StarExpr:\n+\t\t// *T may be a pointer dereferenciation.\n+\t\t// Only consider *T as type literal if T is a type literal.\n+\t\treturn isTypeLit(x.X)\n+\tcase *ast.ParenExpr:\n+\t\treturn isTypeLit(x.X)\n+\t}\n+\treturn false\n+}\n+\n func (p *printer) signature(sig *ast.FuncType) {\n \tif sig.TypeParams != nil {\n \t\tp.parameters(sig.TypeParams, true)"}, {"sha": "4fac2c9c580b159d0a61c8e01859962e9c5d2a7e", "filename": "libgo/go/go/printer/testdata/generics.golden", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.golden?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -38,3 +38,29 @@ func _() {\n // type constraint literals with elided interfaces\n func _[P ~int, Q int | string]()\t{}\n func _[P struct{ f int }, Q *P]()\t{}\n+\n+// various potentially ambiguous type parameter lists (issue #49482)\n+type _[P *T,] struct{}\n+type _[P *T, _ any] struct{}\n+type _[P *T,] struct{}\n+type _[P *T, _ any] struct{}\n+type _[P T] struct{}\n+type _[P T, _ any] struct{}\n+\n+type _[P *struct{}] struct{}\n+type _[P *struct{}] struct{}\n+type _[P []int] struct{}\n+\n+// array type declarations\n+type _ [P(T)]struct{}\n+type _ [P((T))]struct{}\n+type _ [P * *T]struct{}\n+type _ [P * T]struct{}\n+type _ [P(*T)]struct{}\n+type _ [P(**T)]struct{}\n+type _ [P * T]struct{}\n+type _ [P*T - T]struct{}\n+\n+type _[\n+\tP *T,\n+] struct{}"}, {"sha": "fde9d32ef04844f1b46bfb229776932f29e21f7d", "filename": "libgo/go/go/printer/testdata/generics.input", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.input?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -35,3 +35,29 @@ func _() {\n // type constraint literals with elided interfaces\n func _[P ~int, Q int | string]() {}\n func _[P struct{f int}, Q *P]() {}\n+\n+// various potentially ambiguous type parameter lists (issue #49482)\n+type _[P *T,] struct{}\n+type _[P *T, _ any] struct{}\n+type _[P (*T),] struct{}\n+type _[P (*T), _ any] struct{}\n+type _[P (T),] struct{}\n+type _[P (T), _ any] struct{}\n+\n+type _[P *struct{}] struct{}\n+type _[P (*struct{})] struct{}\n+type _[P ([]int)] struct{}\n+\n+// array type declarations\n+type _ [P(T)]struct{}\n+type _ [P((T))]struct{}\n+type _ [P * *T]struct{}\n+type _ [P * T]struct{}\n+type _ [P(*T)]struct{}\n+type _ [P(**T)]struct{}\n+type _ [P * T]struct{}\n+type _ [P * T - T]struct{}\n+\n+type _[\n+\tP *T,\n+] struct{}"}, {"sha": "e5ae2402c91a9f05196d25aa7b320a420be63851", "filename": "libgo/go/go/types/api.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -419,9 +419,15 @@ func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, i\n }\n \n // AssertableTo reports whether a value of type V can be asserted to have type T.\n+// The behavior of AssertableTo is undefined if V is a generalized interface; i.e.,\n+// an interface that may only be used as a type constraint in Go code.\n func AssertableTo(V *Interface, T Type) bool {\n-\tm, _ := (*Checker)(nil).assertableTo(V, T)\n-\treturn m == nil\n+\t// Checker.newAssertableTo suppresses errors for invalid types, so we need special\n+\t// handling here.\n+\tif T.Underlying() == Typ[Invalid] {\n+\t\treturn false\n+\t}\n+\treturn (*Checker)(nil).newAssertableTo(V, T) == nil\n }\n \n // AssignableTo reports whether a value of type V is assignable to a variable of type T."}, {"sha": "b67af8c06e12eb0c8308a0ab660d4e76b634194a", "filename": "libgo/go/go/types/api_test.go", "status": "modified", "additions": 85, "deletions": 15, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -2308,27 +2308,27 @@ type Bad Bad // invalid type\n \tconf := Config{Error: func(error) {}}\n \tpkg, _ := conf.Check(f.Name.Name, fset, []*ast.File{f}, nil)\n \n-\tscope := pkg.Scope()\n+\tlookup := func(tname string) Type { return pkg.Scope().Lookup(tname).Type() }\n \tvar (\n-\t\tEmptyIface   = scope.Lookup(\"EmptyIface\").Type().Underlying().(*Interface)\n-\t\tI            = scope.Lookup(\"I\").Type().(*Named)\n+\t\tEmptyIface   = lookup(\"EmptyIface\").Underlying().(*Interface)\n+\t\tI            = lookup(\"I\").(*Named)\n \t\tII           = I.Underlying().(*Interface)\n-\t\tC            = scope.Lookup(\"C\").Type().(*Named)\n+\t\tC            = lookup(\"C\").(*Named)\n \t\tCI           = C.Underlying().(*Interface)\n-\t\tInteger      = scope.Lookup(\"Integer\").Type().Underlying().(*Interface)\n-\t\tEmptyTypeSet = scope.Lookup(\"EmptyTypeSet\").Type().Underlying().(*Interface)\n-\t\tN1           = scope.Lookup(\"N1\").Type()\n+\t\tInteger      = lookup(\"Integer\").Underlying().(*Interface)\n+\t\tEmptyTypeSet = lookup(\"EmptyTypeSet\").Underlying().(*Interface)\n+\t\tN1           = lookup(\"N1\")\n \t\tN1p          = NewPointer(N1)\n-\t\tN2           = scope.Lookup(\"N2\").Type()\n+\t\tN2           = lookup(\"N2\")\n \t\tN2p          = NewPointer(N2)\n-\t\tN3           = scope.Lookup(\"N3\").Type()\n-\t\tN4           = scope.Lookup(\"N4\").Type()\n-\t\tBad          = scope.Lookup(\"Bad\").Type()\n+\t\tN3           = lookup(\"N3\")\n+\t\tN4           = lookup(\"N4\")\n+\t\tBad          = lookup(\"Bad\")\n \t)\n \n \ttests := []struct {\n-\t\tt    Type\n-\t\ti    *Interface\n+\t\tV    Type\n+\t\tT    *Interface\n \t\twant bool\n \t}{\n \t\t{I, II, true},\n@@ -2359,8 +2359,78 @@ type Bad Bad // invalid type\n \t}\n \n \tfor _, test := range tests {\n-\t\tif got := Implements(test.t, test.i); got != test.want {\n-\t\t\tt.Errorf(\"Implements(%s, %s) = %t, want %t\", test.t, test.i, got, test.want)\n+\t\tif got := Implements(test.V, test.T); got != test.want {\n+\t\t\tt.Errorf(\"Implements(%s, %s) = %t, want %t\", test.V, test.T, got, test.want)\n \t\t}\n+\n+\t\t// The type assertion x.(T) is valid if T is an interface or if T implements the type of x.\n+\t\t// The assertion is never valid if T is a bad type.\n+\t\tV := test.T\n+\t\tT := test.V\n+\t\twant := false\n+\t\tif _, ok := T.Underlying().(*Interface); (ok || Implements(T, V)) && T != Bad {\n+\t\t\twant = true\n+\t\t}\n+\t\tif got := AssertableTo(V, T); got != want {\n+\t\t\tt.Errorf(\"AssertableTo(%s, %s) = %t, want %t\", V, T, got, want)\n+\t\t}\n+\t}\n+}\n+\n+func TestMissingMethodAlternative(t *testing.T) {\n+\tconst src = `\n+package p\n+type T interface {\n+\tm()\n+}\n+\n+type V0 struct{}\n+func (V0) m() {}\n+\n+type V1 struct{}\n+\n+type V2 struct{}\n+func (V2) m() int\n+\n+type V3 struct{}\n+func (*V3) m()\n+\n+type V4 struct{}\n+func (V4) M()\n+`\n+\n+\tpkg, err := pkgFor(\"p.go\", src, nil)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tT := pkg.Scope().Lookup(\"T\").Type().Underlying().(*Interface)\n+\tlookup := func(name string) (*Func, bool) {\n+\t\treturn MissingMethod(pkg.Scope().Lookup(name).Type(), T, true)\n+\t}\n+\n+\t// V0 has method m with correct signature. Should not report wrongType.\n+\tmethod, wrongType := lookup(\"V0\")\n+\tif method != nil || wrongType {\n+\t\tt.Fatalf(\"V0: got method = %v, wrongType = %v\", method, wrongType)\n \t}\n+\n+\tcheckMissingMethod := func(tname string, reportWrongType bool) {\n+\t\tmethod, wrongType := lookup(tname)\n+\t\tif method == nil || method.Name() != \"m\" || wrongType != reportWrongType {\n+\t\t\tt.Fatalf(\"%s: got method = %v, wrongType = %v\", tname, method, wrongType)\n+\t\t}\n+\t}\n+\n+\t// V1 has no method m. Should not report wrongType.\n+\tcheckMissingMethod(\"V1\", false)\n+\n+\t// V2 has method m with wrong signature type (ignoring receiver). Should report wrongType.\n+\tcheckMissingMethod(\"V2\", true)\n+\n+\t// V3 has no method m but it exists on *V3. Should report wrongType.\n+\tcheckMissingMethod(\"V3\", true)\n+\n+\t// V4 has no method m but has M. Should not report wrongType.\n+\tcheckMissingMethod(\"V4\", false)\n }"}, {"sha": "c81e73c828840f76d97062330176497af9d1ec47", "filename": "libgo/go/go/types/builtins.go", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -83,10 +83,24 @@ func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ b\n \t\t// of S and the respective parameter passing rules apply.\"\n \t\tS := x.typ\n \t\tvar T Type\n-\t\tif s, _ := structuralType(S).(*Slice); s != nil {\n+\t\tif s, _ := coreType(S).(*Slice); s != nil {\n \t\t\tT = s.elem\n \t\t} else {\n-\t\t\tcheck.invalidArg(x, _InvalidAppend, \"%s is not a slice\", x)\n+\t\t\tvar cause string\n+\t\t\tswitch {\n+\t\t\tcase x.isNil():\n+\t\t\t\tcause = \"have untyped nil\"\n+\t\t\tcase isTypeParam(S):\n+\t\t\t\tif u := coreType(S); u != nil {\n+\t\t\t\t\tcause = check.sprintf(\"%s has core type %s\", x, u)\n+\t\t\t\t} else {\n+\t\t\t\t\tcause = check.sprintf(\"%s has no core type\", x)\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tcause = check.sprintf(\"have %s\", x)\n+\t\t\t}\n+\t\t\t// don't use Checker.invalidArg here as it would repeat \"argument\" in the error message\n+\t\t\tcheck.errorf(x, _InvalidAppend, \"first argument to append must be a slice; %s\", cause)\n \t\t\treturn\n \t\t}\n \n@@ -102,7 +116,7 @@ func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ b\n \t\t\t\tif x.mode == invalid {\n \t\t\t\t\treturn\n \t\t\t\t}\n-\t\t\t\tif t := structuralString(x.typ); t != nil && isString(t) {\n+\t\t\t\tif t := coreString(x.typ); t != nil && isString(t) {\n \t\t\t\t\tif check.Types != nil {\n \t\t\t\t\t\tsig := makeSig(S, S, x.typ)\n \t\t\t\t\t\tsig.variadic = true\n@@ -143,9 +157,8 @@ func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ b\n \t\t// cap(x)\n \t\t// len(x)\n \t\tmode := invalid\n-\t\tvar typ Type\n \t\tvar val constant.Value\n-\t\tswitch typ = arrayPtrDeref(under(x.typ)); t := typ.(type) {\n+\t\tswitch t := arrayPtrDeref(under(x.typ)).(type) {\n \t\tcase *Basic:\n \t\t\tif isString(t) && id == _Len {\n \t\t\t\tif x.mode == constant_ {\n@@ -202,7 +215,7 @@ func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ b\n \t\t\t}\n \t\t}\n \n-\t\tif mode == invalid && typ != Typ[Invalid] {\n+\t\tif mode == invalid && under(x.typ) != Typ[Invalid] {\n \t\t\tcode := _InvalidCap\n \t\t\tif id == _Len {\n \t\t\t\tcode = _InvalidLen\n@@ -211,12 +224,14 @@ func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ b\n \t\t\treturn\n \t\t}\n \n+\t\t// record the signature before changing x.typ\n+\t\tif check.Types != nil && mode != constant_ {\n+\t\t\tcheck.recordBuiltinType(call.Fun, makeSig(Typ[Int], x.typ))\n+\t\t}\n+\n \t\tx.mode = mode\n \t\tx.typ = Typ[Int]\n \t\tx.val = val\n-\t\tif check.Types != nil && mode != constant_ {\n-\t\t\tcheck.recordBuiltinType(call.Fun, makeSig(x.typ, typ))\n-\t\t}\n \n \tcase _Close:\n \t\t// close(c)\n@@ -314,7 +329,7 @@ func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ b\n \t\t\t}\n \t\t\treturn nil\n \t\t}\n-\t\tresTyp := check.applyTypeFunc(f, x.typ)\n+\t\tresTyp := check.applyTypeFunc(f, x, id)\n \t\tif resTyp == nil {\n \t\t\tcheck.invalidArg(x, _InvalidComplex, \"arguments have type %s, expected floating-point\", x.typ)\n \t\t\treturn\n@@ -335,14 +350,14 @@ func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ b\n \n \tcase _Copy:\n \t\t// copy(x, y []T) int\n-\t\tdst, _ := structuralType(x.typ).(*Slice)\n+\t\tdst, _ := coreType(x.typ).(*Slice)\n \n \t\tvar y operand\n \t\targ(&y, 1)\n \t\tif y.mode == invalid {\n \t\t\treturn\n \t\t}\n-\t\tsrc0 := structuralString(y.typ)\n+\t\tsrc0 := coreString(y.typ)\n \t\tif src0 != nil && isString(src0) {\n \t\t\tsrc0 = NewSlice(universeByte)\n \t\t}\n@@ -442,7 +457,7 @@ func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ b\n \t\t\t}\n \t\t\treturn nil\n \t\t}\n-\t\tresTyp := check.applyTypeFunc(f, x.typ)\n+\t\tresTyp := check.applyTypeFunc(f, x, id)\n \t\tif resTyp == nil {\n \t\t\tcode := _InvalidImag\n \t\t\tif id == _Real {\n@@ -480,13 +495,13 @@ func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ b\n \t\t}\n \n \t\tvar min int // minimum number of arguments\n-\t\tswitch structuralType(T).(type) {\n+\t\tswitch coreType(T).(type) {\n \t\tcase *Slice:\n \t\t\tmin = 2\n \t\tcase *Map, *Chan:\n \t\t\tmin = 1\n \t\tcase nil:\n-\t\t\tcheck.errorf(arg0, _InvalidMake, \"cannot make %s: no structural type\", arg0)\n+\t\t\tcheck.errorf(arg0, _InvalidMake, \"cannot make %s: no core type\", arg0)\n \t\t\treturn\n \t\tdefault:\n \t\t\tcheck.invalidArg(arg0, _InvalidMake, \"cannot make %s; type must be slice, map, or channel\", arg0)\n@@ -809,8 +824,8 @@ func hasVarSize(t Type) bool {\n // of x. If any of these applications of f return nil,\n // applyTypeFunc returns nil.\n // If x is not a type parameter, the result is f(x).\n-func (check *Checker) applyTypeFunc(f func(Type) Type, x Type) Type {\n-\tif tp, _ := x.(*TypeParam); tp != nil {\n+func (check *Checker) applyTypeFunc(f func(Type) Type, x *operand, id builtinId) Type {\n+\tif tp, _ := x.typ.(*TypeParam); tp != nil {\n \t\t// Test if t satisfies the requirements for the argument\n \t\t// type and collect possible result types at the same time.\n \t\tvar terms []*Term\n@@ -827,17 +842,34 @@ func (check *Checker) applyTypeFunc(f func(Type) Type, x Type) Type {\n \t\t\treturn nil\n \t\t}\n \n+\t\t// We can type-check this fine but we're introducing a synthetic\n+\t\t// type parameter for the result. It's not clear what the API\n+\t\t// implications are here. Report an error for 1.18 (see #50912),\n+\t\t// but continue type-checking.\n+\t\tvar code errorCode\n+\t\tswitch id {\n+\t\tcase _Real:\n+\t\t\tcode = _InvalidReal\n+\t\tcase _Imag:\n+\t\t\tcode = _InvalidImag\n+\t\tcase _Complex:\n+\t\t\tcode = _InvalidComplex\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n+\t\tcheck.softErrorf(x, code, \"%s not supported as argument to %s for go1.18 (see issue #50937)\", x, predeclaredFuncs[id].name)\n+\n \t\t// Construct a suitable new type parameter for the result type.\n \t\t// The type parameter is placed in the current package so export/import\n \t\t// works as expected.\n-\t\ttpar := NewTypeName(token.NoPos, check.pkg, \"<type parameter>\", nil)\n+\t\ttpar := NewTypeName(token.NoPos, check.pkg, tp.obj.name, nil)\n \t\tptyp := check.newTypeParam(tpar, NewInterfaceType(nil, []Type{NewUnion(terms)})) // assigns type to tpar as a side-effect\n \t\tptyp.index = tp.index\n \n \t\treturn ptyp\n \t}\n \n-\treturn f(x)\n+\treturn f(x.typ)\n }\n \n // makeSig makes a signature for the given argument and result types."}, {"sha": "ce9db69a4a4ddded4a44c50c8efabec790dabe91", "filename": "libgo/go/go/types/builtins_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -29,6 +29,8 @@ var builtinCalls = []struct {\n \t{\"cap\", `var s [10]int; _ = cap(&s)`, `invalid type`}, // constant\n \t{\"cap\", `var s []int64; _ = cap(s)`, `func([]int64) int`},\n \t{\"cap\", `var c chan<-bool; _ = cap(c)`, `func(chan<- bool) int`},\n+\t{\"cap\", `type S []byte; var s S; _ = cap(s)`, `func(p.S) int`},\n+\t{\"cap\", `var s P; _ = cap(s)`, `func(P) int`},\n \n \t{\"len\", `_ = len(\"foo\")`, `invalid type`}, // constant\n \t{\"len\", `var s string; _ = len(s)`, `func(string) int`},\n@@ -37,6 +39,8 @@ var builtinCalls = []struct {\n \t{\"len\", `var s []int64; _ = len(s)`, `func([]int64) int`},\n \t{\"len\", `var c chan<-bool; _ = len(c)`, `func(chan<- bool) int`},\n \t{\"len\", `var m map[string]float32; _ = len(m)`, `func(map[string]float32) int`},\n+\t{\"len\", `type S []byte; var s S; _ = len(s)`, `func(p.S) int`},\n+\t{\"len\", `var s P; _ = len(s)`, `func(P) int`},\n \n \t{\"close\", `var c chan int; close(c)`, `func(chan int)`},\n \t{\"close\", `var c chan<- chan string; close(c)`, `func(chan<- chan string)`},\n@@ -159,7 +163,7 @@ func TestBuiltinSignatures(t *testing.T) {\n func testBuiltinSignature(t *testing.T, name, src0, want string) {\n \tt.Skip(\"skipping for gccgo--no default importer\")\n \n-\tsrc := fmt.Sprintf(`package p; import \"unsafe\"; type _ unsafe.Pointer /* use unsafe */; func _[P any]() { %s }`, src0)\n+\tsrc := fmt.Sprintf(`package p; import \"unsafe\"; type _ unsafe.Pointer /* use unsafe */; func _[P ~[]byte]() { %s }`, src0)\n \tf, err := parser.ParseFile(fset, \"\", src, 0)\n \tif err != nil {\n \t\tt.Errorf(\"%s: %s\", src0, err)"}, {"sha": "3dab28445965facc07b5deb95fce1bb860279b36", "filename": "libgo/go/go/types/call.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -171,7 +171,7 @@ func (check *Checker) callExpr(x *operand, call *ast.CallExpr) exprKind {\n \tcgocall := x.mode == cgofunc\n \n \t// a type parameter may be \"called\" if all types have the same signature\n-\tsig, _ := structuralType(x.typ).(*Signature)\n+\tsig, _ := coreType(x.typ).(*Signature)\n \tif sig == nil {\n \t\tcheck.invalidOp(x, _InvalidCall, \"cannot call non-function %s\", x)\n \t\tx.mode = invalid"}, {"sha": "6e1da04b9fcc88cb08fca7ab6b98813aea3a585c", "filename": "libgo/go/go/types/check.go", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -24,19 +24,6 @@ const (\n \tcompilerErrorMessages = false // match compiler error messages\n )\n \n-// If forceStrict is set, the type-checker enforces additional\n-// rules not specified by the Go 1 spec, but which will\n-// catch guaranteed run-time errors if the respective\n-// code is executed. In other words, programs passing in\n-// strict mode are Go 1 compliant, but not all Go 1 programs\n-// will pass in strict mode. The additional rules are:\n-//\n-// - A type assertion x.(T) where T is an interface type\n-//   is invalid if any (statically known) method that exists\n-//   for both x and T have different signatures.\n-//\n-const forceStrict = false\n-\n // exprInfo stores information about an untyped expression.\n type exprInfo struct {\n \tisLhs bool // expression is lhs operand of a shift with delayed type-check"}, {"sha": "a7514b317a0ce11ff3953cf634df1419511edcf1", "filename": "libgo/go/go/types/errorcodes.go", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ferrorcodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ferrorcodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ferrorcodes.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -98,13 +98,10 @@ const (\n \t// _InvalidDeclCycle occurs when a declaration cycle is not valid.\n \t//\n \t// Example:\n-\t//  import \"unsafe\"\n-\t//\n-\t//  type T struct {\n-\t//  \ta [n]int\n+\t//  type S struct {\n+\t//  \tS\n \t//  }\n \t//\n-\t//  var n = unsafe.Sizeof(T{})\n \t_InvalidDeclCycle\n \n \t// _InvalidTypeCycle occurs when a cycle in type definitions results in a\n@@ -1385,10 +1382,7 @@ const (\n \n \t// _InvalidMethodTypeParams occurs when methods have type parameters.\n \t//\n-\t// Example:\n-\t//  type T int\n-\t//\n-\t//  func (T) m[P any]() {}\n+\t// It cannot be encountered with an AST parsed using go/parser.\n \t_InvalidMethodTypeParams\n \n \t// _MisplacedTypeParam occurs when a type parameter is used in a place where"}, {"sha": "fade8630e092c174ecaae3673ffe99b068e3c03c", "filename": "libgo/go/go/types/errors.go", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ferrors.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -63,8 +63,15 @@ func (check *Checker) markImports(pkg *Package) {\n \t}\n }\n \n+// check may be nil.\n func (check *Checker) sprintf(format string, args ...any) string {\n-\treturn sprintf(check.fset, check.qualifier, false, format, args...)\n+\tvar fset *token.FileSet\n+\tvar qf Qualifier\n+\tif check != nil {\n+\t\tfset = check.fset\n+\t\tqf = check.qualifier\n+\t}\n+\treturn sprintf(fset, qf, false, format, args...)\n }\n \n func sprintf(fset *token.FileSet, qf Qualifier, debug bool, format string, args ...any) string {\n@@ -103,6 +110,17 @@ func sprintf(fset *token.FileSet, qf Qualifier, debug bool, format string, args\n \t\t\t}\n \t\t\tbuf.WriteByte(']')\n \t\t\targ = buf.String()\n+\t\tcase []*TypeParam:\n+\t\t\tvar buf bytes.Buffer\n+\t\t\tbuf.WriteByte('[')\n+\t\t\tfor i, x := range a {\n+\t\t\t\tif i > 0 {\n+\t\t\t\t\tbuf.WriteString(\", \")\n+\t\t\t\t}\n+\t\t\t\tbuf.WriteString(typeString(x, qf, debug)) // use typeString so we get subscripts when debugging\n+\t\t\t}\n+\t\t\tbuf.WriteByte(']')\n+\t\t\targ = buf.String()\n \t\t}\n \t\targs[i] = arg\n \t}"}, {"sha": "56e945a7c6c8b9070db2b6330adbc496911b6914", "filename": "libgo/go/go/types/example_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fexample_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -279,7 +279,7 @@ func fib(x int) int {\n \t//\n \t// Types and Values of each expression:\n \t//  4: 8 | string              | type    : string\n-\t//  6:15 | len                 | builtin : func(string) int\n+\t//  6:15 | len                 | builtin : func(fib.S) int\n \t//  6:15 | len(b)              | value   : int\n \t//  6:19 | b                   | var     : fib.S\n \t//  6:23 | S                   | type    : fib.S"}, {"sha": "8747838c4bd9247cdce06e92c50746f79b3ee1d0", "filename": "libgo/go/go/types/expr.go", "status": "modified", "additions": 157, "deletions": 63, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -173,9 +173,9 @@ func (check *Checker) unary(x *operand, e *ast.UnaryExpr) {\n \t\treturn\n \n \tcase token.ARROW:\n-\t\tu := structuralType(x.typ)\n+\t\tu := coreType(x.typ)\n \t\tif u == nil {\n-\t\t\tcheck.invalidOp(x, _InvalidReceive, \"cannot receive from %s: no structural type\", x)\n+\t\t\tcheck.invalidOp(x, _InvalidReceive, \"cannot receive from %s: no core type\", x)\n \t\t\tx.mode = invalid\n \t\t\treturn\n \t\t}\n@@ -728,54 +728,84 @@ func (check *Checker) implicitTypeAndValue(x *operand, target Type) (Type, const\n \treturn target, nil, 0\n }\n \n-func (check *Checker) comparison(x, y *operand, op token.Token) {\n+// If switchCase is true, the operator op is ignored.\n+func (check *Checker) comparison(x, y *operand, op token.Token, switchCase bool) {\n+\tif switchCase {\n+\t\top = token.EQL\n+\t}\n+\n+\terrOp := x  // operand for which error is reported, if any\n+\tcause := \"\" // specific error cause, if any\n+\n \t// spec: \"In any comparison, the first operand must be assignable\n \t// to the type of the second operand, or vice versa.\"\n-\terr := \"\"\n-\tvar code errorCode\n-\txok, _ := x.assignableTo(check, y.typ, nil)\n-\tyok, _ := y.assignableTo(check, x.typ, nil)\n-\tif xok || yok {\n-\t\tequality := false\n-\t\tdefined := false\n-\t\tswitch op {\n-\t\tcase token.EQL, token.NEQ:\n-\t\t\t// spec: \"The equality operators == and != apply to operands that are comparable.\"\n-\t\t\tequality = true\n-\t\t\tdefined = Comparable(x.typ) && Comparable(y.typ) || x.isNil() && hasNil(y.typ) || y.isNil() && hasNil(x.typ)\n-\t\tcase token.LSS, token.LEQ, token.GTR, token.GEQ:\n-\t\t\t// spec: The ordering operators <, <=, >, and >= apply to operands that are ordered.\"\n-\t\t\tdefined = allOrdered(x.typ) && allOrdered(y.typ)\n-\t\tdefault:\n-\t\t\tunreachable()\n-\t\t}\n-\t\tif !defined {\n-\t\t\tif equality && (isTypeParam(x.typ) || isTypeParam(y.typ)) {\n-\t\t\t\ttyp := x.typ\n-\t\t\t\tif isTypeParam(y.typ) {\n-\t\t\t\t\ttyp = y.typ\n-\t\t\t\t}\n-\t\t\t\terr = check.sprintf(\"%s is not comparable\", typ)\n-\t\t\t} else {\n-\t\t\t\ttyp := x.typ\n-\t\t\t\tif x.isNil() {\n-\t\t\t\t\ttyp = y.typ\n-\t\t\t\t}\n-\t\t\t\terr = check.sprintf(\"operator %s not defined on %s\", op, typ)\n+\tcode := _MismatchedTypes\n+\tok, _ := x.assignableTo(check, y.typ, nil)\n+\tif !ok {\n+\t\tok, _ = y.assignableTo(check, x.typ, nil)\n+\t}\n+\tif !ok {\n+\t\t// Report the error on the 2nd operand since we only\n+\t\t// know after seeing the 2nd operand whether we have\n+\t\t// a type mismatch.\n+\t\terrOp = y\n+\t\t// For now, if we're not running the compiler, use the\n+\t\t// position of x to minimize changes to existing tests.\n+\t\tif !compilerErrorMessages {\n+\t\t\terrOp = x\n+\t\t}\n+\t\tcause = check.sprintf(\"mismatched types %s and %s\", x.typ, y.typ)\n+\t\tgoto Error\n+\t}\n+\n+\t// check if comparison is defined for operands\n+\tcode = _UndefinedOp\n+\tswitch op {\n+\tcase token.EQL, token.NEQ:\n+\t\t// spec: \"The equality operators == and != apply to operands that are comparable.\"\n+\t\tswitch {\n+\t\tcase x.isNil() || y.isNil():\n+\t\t\t// Comparison against nil requires that the other operand type has nil.\n+\t\t\ttyp := x.typ\n+\t\t\tif x.isNil() {\n+\t\t\t\ttyp = y.typ\n \t\t\t}\n-\t\t\tcode = _UndefinedOp\n+\t\t\tif !hasNil(typ) {\n+\t\t\t\t// This case should only be possible for \"nil == nil\".\n+\t\t\t\t// Report the error on the 2nd operand since we only\n+\t\t\t\t// know after seeing the 2nd operand whether we have\n+\t\t\t\t// an invalid comparison.\n+\t\t\t\terrOp = y\n+\t\t\t\tgoto Error\n+\t\t\t}\n+\n+\t\tcase !Comparable(x.typ):\n+\t\t\terrOp = x\n+\t\t\tcause = check.incomparableCause(x.typ)\n+\t\t\tgoto Error\n+\n+\t\tcase !Comparable(y.typ):\n+\t\t\terrOp = y\n+\t\t\tcause = check.incomparableCause(y.typ)\n+\t\t\tgoto Error\n \t\t}\n-\t} else {\n-\t\terr = check.sprintf(\"mismatched types %s and %s\", x.typ, y.typ)\n-\t\tcode = _MismatchedTypes\n-\t}\n \n-\tif err != \"\" {\n-\t\tcheck.errorf(x, code, \"cannot compare %s %s %s (%s)\", x.expr, op, y.expr, err)\n-\t\tx.mode = invalid\n-\t\treturn\n+\tcase token.LSS, token.LEQ, token.GTR, token.GEQ:\n+\t\t// spec: The ordering operators <, <=, >, and >= apply to operands that are ordered.\"\n+\t\tswitch {\n+\t\tcase !allOrdered(x.typ):\n+\t\t\terrOp = x\n+\t\t\tgoto Error\n+\t\tcase !allOrdered(y.typ):\n+\t\t\terrOp = y\n+\t\t\tgoto Error\n+\t\t}\n+\n+\tdefault:\n+\t\tunreachable()\n \t}\n \n+\t// comparison is ok\n \tif x.mode == constant_ && y.mode == constant_ {\n \t\tx.val = constant.MakeBool(constant.Compare(x.val, op, y.val))\n \t\t// The operands are never materialized; no need to update\n@@ -793,6 +823,73 @@ func (check *Checker) comparison(x, y *operand, op token.Token) {\n \t// spec: \"Comparison operators compare two operands and yield\n \t//        an untyped boolean value.\"\n \tx.typ = Typ[UntypedBool]\n+\treturn\n+\n+Error:\n+\t// We have an offending operand errOp and possibly an error cause.\n+\tif cause == \"\" {\n+\t\tif isTypeParam(x.typ) || isTypeParam(y.typ) {\n+\t\t\t// TODO(gri) should report the specific type causing the problem, if any\n+\t\t\tif !isTypeParam(x.typ) {\n+\t\t\t\terrOp = y\n+\t\t\t}\n+\t\t\tcause = check.sprintf(\"type parameter %s is not comparable with %s\", errOp.typ, op)\n+\t\t} else {\n+\t\t\tcause = check.sprintf(\"operator %s not defined on %s\", op, check.kindString(errOp.typ)) // catch-all\n+\t\t}\n+\t}\n+\tif switchCase {\n+\t\tcheck.errorf(x, code, \"invalid case %s in switch on %s (%s)\", x.expr, y.expr, cause) // error position always at 1st operand\n+\t} else {\n+\t\tif compilerErrorMessages {\n+\t\t\tcheck.invalidOp(errOp, code, \"%s %s %s (%s)\", x.expr, op, y.expr, cause)\n+\t\t} else {\n+\t\t\tcheck.invalidOp(errOp, code, \"cannot compare %s %s %s (%s)\", x.expr, op, y.expr, cause)\n+\t\t}\n+\t}\n+\tx.mode = invalid\n+}\n+\n+// incomparableCause returns a more specific cause why typ is not comparable.\n+// If there is no more specific cause, the result is \"\".\n+func (check *Checker) incomparableCause(typ Type) string {\n+\tswitch under(typ).(type) {\n+\tcase *Slice, *Signature, *Map:\n+\t\treturn check.kindString(typ) + \" can only be compared to nil\"\n+\t}\n+\t// see if we can extract a more specific error\n+\tvar cause string\n+\tcomparable(typ, nil, func(format string, args ...interface{}) {\n+\t\tcause = check.sprintf(format, args...)\n+\t})\n+\treturn cause\n+}\n+\n+// kindString returns the type kind as a string.\n+func (check *Checker) kindString(typ Type) string {\n+\tswitch under(typ).(type) {\n+\tcase *Array:\n+\t\treturn \"array\"\n+\tcase *Slice:\n+\t\treturn \"slice\"\n+\tcase *Struct:\n+\t\treturn \"struct\"\n+\tcase *Pointer:\n+\t\treturn \"pointer\"\n+\tcase *Signature:\n+\t\treturn \"func\"\n+\tcase *Interface:\n+\t\tif isTypeParam(typ) {\n+\t\t\treturn check.sprintf(\"type parameter %s\", typ)\n+\t\t}\n+\t\treturn \"interface\"\n+\tcase *Map:\n+\t\treturn \"map\"\n+\tcase *Chan:\n+\t\treturn \"chan\"\n+\tdefault:\n+\t\treturn check.sprintf(\"%s\", typ) // catch-all\n+\t}\n }\n \n // If e != nil, it must be the shift expression; it may be nil for non-constant shifts.\n@@ -1014,7 +1111,7 @@ func (check *Checker) binary(x *operand, e ast.Expr, lhs, rhs ast.Expr, op token\n \t}\n \n \tif isComparison(op) {\n-\t\tcheck.comparison(x, &y, op)\n+\t\tcheck.comparison(x, &y, op, false)\n \t\treturn\n \t}\n \n@@ -1241,15 +1338,15 @@ func (check *Checker) exprInternal(x *operand, e ast.Expr, hint Type) exprKind {\n \t\tcase hint != nil:\n \t\t\t// no composite literal type present - use hint (element type of enclosing type)\n \t\t\ttyp = hint\n-\t\t\tbase, _ = deref(structuralType(typ)) // *T implies &T{}\n+\t\t\tbase, _ = deref(coreType(typ)) // *T implies &T{}\n \n \t\tdefault:\n \t\t\t// TODO(gri) provide better error messages depending on context\n \t\t\tcheck.error(e, _UntypedLit, \"missing type in composite literal\")\n \t\t\tgoto Error\n \t\t}\n \n-\t\tswitch utyp := structuralType(base).(type) {\n+\t\tswitch utyp := coreType(base).(type) {\n \t\tcase *Struct:\n \t\t\t// Prevent crash if the struct referred to is not yet set up.\n \t\t\t// See analogous comment for *Array.\n@@ -1459,8 +1556,7 @@ func (check *Checker) exprInternal(x *operand, e ast.Expr, hint Type) exprKind {\n \t\t\tcheck.invalidOp(x, _InvalidAssert, \"cannot use type assertion on type parameter value %s\", x)\n \t\t\tgoto Error\n \t\t}\n-\t\txtyp, _ := under(x.typ).(*Interface)\n-\t\tif xtyp == nil {\n+\t\tif _, ok := under(x.typ).(*Interface); !ok {\n \t\t\tcheck.invalidOp(x, _InvalidAssert, \"%s is not an interface\", x)\n \t\t\tgoto Error\n \t\t}\n@@ -1475,7 +1571,7 @@ func (check *Checker) exprInternal(x *operand, e ast.Expr, hint Type) exprKind {\n \t\tif T == Typ[Invalid] {\n \t\t\tgoto Error\n \t\t}\n-\t\tcheck.typeAssertion(x, x, xtyp, T)\n+\t\tcheck.typeAssertion(e, x, T, false)\n \t\tx.mode = commaok\n \t\tx.typ = T\n \n@@ -1579,23 +1675,21 @@ func keyVal(x constant.Value) any {\n \treturn x\n }\n \n-// typeAssertion checks that x.(T) is legal; xtyp must be the type of x.\n-func (check *Checker) typeAssertion(at positioner, x *operand, xtyp *Interface, T Type) {\n-\tmethod, wrongType := check.assertableTo(xtyp, T)\n+// typeAssertion checks x.(T). The type of x must be an interface.\n+func (check *Checker) typeAssertion(e ast.Expr, x *operand, T Type, typeSwitch bool) {\n+\tmethod, alt := check.assertableTo(under(x.typ).(*Interface), T)\n \tif method == nil {\n-\t\treturn\n+\t\treturn // success\n \t}\n-\tvar msg string\n-\tif wrongType != nil {\n-\t\tif Identical(method.typ, wrongType.typ) {\n-\t\t\tmsg = fmt.Sprintf(\"missing method %s (%s has pointer receiver)\", method.name, method.name)\n-\t\t} else {\n-\t\t\tmsg = fmt.Sprintf(\"wrong type for method %s (have %s, want %s)\", method.name, wrongType.typ, method.typ)\n-\t\t}\n-\t} else {\n-\t\tmsg = \"missing method \" + method.name\n+\n+\tcause := check.missingMethodReason(T, x.typ, method, alt)\n+\n+\tif typeSwitch {\n+\t\tcheck.errorf(e, _ImpossibleAssert, \"impossible type switch case: %s\\n\\t%s cannot have dynamic type %s %s\", e, x, T, cause)\n+\t\treturn\n \t}\n-\tcheck.errorf(at, _ImpossibleAssert, \"%s cannot have dynamic type %s (%s)\", x, T, msg)\n+\n+\tcheck.errorf(e, _ImpossibleAssert, \"impossible type assertion: %s\\n\\t%s does not implement %s %s\", e, T, x.typ, cause)\n }\n \n // expr typechecks expression e and initializes x with the expression value."}, {"sha": "eac6017ba2154eeadf203839943493df0529d944", "filename": "libgo/go/go/types/index.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Findex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Findex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Findex.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -214,9 +214,9 @@ func (check *Checker) sliceExpr(x *operand, e *ast.SliceExpr) {\n \n \tvalid := false\n \tlength := int64(-1) // valid if >= 0\n-\tswitch u := structuralString(x.typ).(type) {\n+\tswitch u := coreString(x.typ).(type) {\n \tcase nil:\n-\t\tcheck.invalidOp(x, _NonSliceableOperand, \"cannot slice %s: %s has no structural type\", x, x.typ)\n+\t\tcheck.invalidOp(x, _NonSliceableOperand, \"cannot slice %s: %s has no core type\", x, x.typ)\n \t\tx.mode = invalid\n \t\treturn\n "}, {"sha": "8f22144c839128f1995ac36da9741c4a36296202", "filename": "libgo/go/go/types/infer.go", "status": "modified", "additions": 105, "deletions": 24, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Finfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Finfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Finfer.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -40,6 +40,13 @@ func (check *Checker) infer(posn positioner, tparams []*TypeParam, targs []Type,\n \t\t}()\n \t}\n \n+\tif traceInference {\n+\t\tcheck.dump(\"-- inferA %s%s \u279e %s\", tparams, params, targs)\n+\t\tdefer func() {\n+\t\t\tcheck.dump(\"=> inferA %s \u279e %s\", tparams, result)\n+\t\t}()\n+\t}\n+\n \t// There must be at least one type parameter, and no more type arguments than type parameters.\n \tn := len(tparams)\n \tassert(n > 0 && len(targs) <= n)\n@@ -53,6 +60,64 @@ func (check *Checker) infer(posn positioner, tparams []*TypeParam, targs []Type,\n \t}\n \t// len(targs) < n\n \n+\tconst enableTparamRenaming = true\n+\tif enableTparamRenaming {\n+\t\t// For the purpose of type inference we must differentiate type parameters\n+\t\t// occurring in explicit type or value function arguments from the type\n+\t\t// parameters we are solving for via unification, because they may be the\n+\t\t// same in self-recursive calls. For example:\n+\t\t//\n+\t\t//  func f[P *Q, Q any](p P, q Q) {\n+\t\t//    f(p)\n+\t\t//  }\n+\t\t//\n+\t\t// In this example, the fact that the P used in the instantation f[P] has\n+\t\t// the same pointer identity as the P we are trying to solve for via\n+\t\t// unification is coincidental: there is nothing special about recursive\n+\t\t// calls that should cause them to conflate the identity of type arguments\n+\t\t// with type parameters. To put it another way: any such self-recursive\n+\t\t// call is equivalent to a mutually recursive call, which does not run into\n+\t\t// any problems of type parameter identity. For example, the following code\n+\t\t// is equivalent to the code above.\n+\t\t//\n+\t\t//  func f[P interface{*Q}, Q any](p P, q Q) {\n+\t\t//    f2(p)\n+\t\t//  }\n+\t\t//\n+\t\t//  func f2[P interface{*Q}, Q any](p P, q Q) {\n+\t\t//    f(p)\n+\t\t//  }\n+\t\t//\n+\t\t// We can turn the first example into the second example by renaming type\n+\t\t// parameters in the original signature to give them a new identity. As an\n+\t\t// optimization, we do this only for self-recursive calls.\n+\n+\t\t// We can detect if we are in a self-recursive call by comparing the\n+\t\t// identity of the first type parameter in the current function with the\n+\t\t// first type parameter in tparams. This works because type parameters are\n+\t\t// unique to their type parameter list.\n+\t\tselfRecursive := check.sig != nil && check.sig.tparams.Len() > 0 && tparams[0] == check.sig.tparams.At(0)\n+\n+\t\tif selfRecursive {\n+\t\t\t// In self-recursive inference, rename the type parameters with new type\n+\t\t\t// parameters that are the same but for their pointer identity.\n+\t\t\ttparams2 := make([]*TypeParam, len(tparams))\n+\t\t\tfor i, tparam := range tparams {\n+\t\t\t\ttname := NewTypeName(tparam.Obj().Pos(), tparam.Obj().Pkg(), tparam.Obj().Name(), nil)\n+\t\t\t\ttparams2[i] = NewTypeParam(tname, nil)\n+\t\t\t\ttparams2[i].index = tparam.index // == i\n+\t\t\t}\n+\n+\t\t\trenameMap := makeRenameMap(tparams, tparams2)\n+\t\t\tfor i, tparam := range tparams {\n+\t\t\t\ttparams2[i].bound = check.subst(posn.Pos(), tparam.bound, renameMap, nil)\n+\t\t\t}\n+\n+\t\t\ttparams = tparams2\n+\t\t\tparams = check.subst(posn.Pos(), params, renameMap, nil).(*Tuple)\n+\t\t}\n+\t}\n+\n \t// If we have more than 2 arguments, we may have arguments with named and unnamed types.\n \t// If that is the case, permutate params and args such that the arguments with named\n \t// types are first in the list. This doesn't affect type inference if all types are taken\n@@ -183,7 +248,7 @@ func (check *Checker) infer(posn positioner, tparams []*TypeParam, targs []Type,\n \t\t\tif arg.mode == invalid {\n \t\t\t\t// An error was reported earlier. Ignore this targ\n \t\t\t\t// and continue, we may still be able to infer all\n-\t\t\t\t// targs resulting in fewer follon-on errors.\n+\t\t\t\t// targs resulting in fewer follow-on errors.\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif targ := arg.typ; isTyped(targ) {\n@@ -194,7 +259,12 @@ func (check *Checker) infer(posn positioner, tparams []*TypeParam, targs []Type,\n \t\t\t\t\terrorf(\"type\", par.typ, targ, arg)\n \t\t\t\t\treturn nil\n \t\t\t\t}\n-\t\t\t} else {\n+\t\t\t} else if _, ok := par.typ.(*TypeParam); ok {\n+\t\t\t\t// Since default types are all basic (i.e., non-composite) types, an\n+\t\t\t\t// untyped argument will never match a composite parameter type; the\n+\t\t\t\t// only parameter type it can possibly match against is a *TypeParam.\n+\t\t\t\t// Thus, for untyped arguments we only need to look at parameter types\n+\t\t\t\t// that are single type parameters.\n \t\t\t\tindices = append(indices, i)\n \t\t\t}\n \t\t}\n@@ -221,20 +291,17 @@ func (check *Checker) infer(posn positioner, tparams []*TypeParam, targs []Type,\n \t// Some generic parameters with untyped arguments may have been given\n \t// a type by now, we can ignore them.\n \tfor _, i := range indices {\n-\t\tpar := params.At(i)\n-\t\t// Since untyped types are all basic (i.e., non-composite) types, an\n-\t\t// untyped argument will never match a composite parameter type; the\n-\t\t// only parameter type it can possibly match against is a *TypeParam.\n-\t\t// Thus, only consider untyped arguments for generic parameters that\n-\t\t// are not of composite types and which don't have a type inferred yet.\n-\t\tif tpar, _ := par.typ.(*TypeParam); tpar != nil && targs[tpar.index] == nil {\n+\t\ttpar := params.At(i).typ.(*TypeParam) // is type parameter by construction of indices\n+\t\t// Only consider untyped arguments for which the corresponding type\n+\t\t// parameter doesn't have an inferred type yet.\n+\t\tif targs[tpar.index] == nil {\n \t\t\targ := args[i]\n \t\t\ttarg := Default(arg.typ)\n \t\t\t// The default type for an untyped nil is untyped nil. We must not\n \t\t\t// infer an untyped nil type as type parameter type. Ignore untyped\n \t\t\t// nil by making sure all default argument types are typed.\n-\t\t\tif isTyped(targ) && !u.unify(par.typ, targ) {\n-\t\t\t\terrorf(\"default type\", par.typ, targ, arg)\n+\t\t\tif isTyped(targ) && !u.unify(tpar, targ) {\n+\t\t\t\terrorf(\"default type\", tpar, targ, arg)\n \t\t\t\treturn nil\n \t\t\t}\n \t\t}\n@@ -400,6 +467,13 @@ func (w *tpWalker) isParameterizedTypeList(list []Type) bool {\n func (check *Checker) inferB(posn positioner, tparams []*TypeParam, targs []Type) (types []Type, index int) {\n \tassert(len(tparams) >= len(targs) && len(targs) > 0)\n \n+\tif traceInference {\n+\t\tcheck.dump(\"-- inferB %s \u279e %s\", tparams, targs)\n+\t\tdefer func() {\n+\t\t\tcheck.dump(\"=> inferB %s \u279e %s\", tparams, types)\n+\t\t}()\n+\t}\n+\n \t// Setup bidirectional unification between constraints\n \t// and the corresponding type arguments (which may be nil!).\n \tu := newUnifier(false)\n@@ -413,26 +487,20 @@ func (check *Checker) inferB(posn positioner, tparams []*TypeParam, targs []Type\n \t\t}\n \t}\n \n-\t// If a constraint has a structural type, unify the corresponding type parameter with it.\n+\t// If a constraint has a core type, unify the corresponding type parameter with it.\n \tfor _, tpar := range tparams {\n-\t\tsbound := structuralType(tpar)\n-\t\tif sbound != nil {\n-\t\t\t// If the structural type is the underlying type of a single\n-\t\t\t// defined type in the constraint, use that defined type instead.\n-\t\t\tif named, _ := tpar.singleType().(*Named); named != nil {\n-\t\t\t\tsbound = named\n-\t\t\t}\n-\t\t\tif !u.unify(tpar, sbound) {\n+\t\tif ctype := adjCoreType(tpar); ctype != nil {\n+\t\t\tif !u.unify(tpar, ctype) {\n \t\t\t\t// TODO(gri) improve error message by providing the type arguments\n \t\t\t\t//           which we know already\n-\t\t\t\tcheck.errorf(posn, _InvalidTypeArg, \"%s does not match %s\", tpar, sbound)\n+\t\t\t\tcheck.errorf(posn, _InvalidTypeArg, \"%s does not match %s\", tpar, ctype)\n \t\t\t\treturn nil, 0\n \t\t\t}\n \t\t}\n \t}\n \n \t// u.x.types() now contains the incoming type arguments plus any additional type\n-\t// arguments which were inferred from structural types. The newly inferred non-\n+\t// arguments which were inferred from core types. The newly inferred non-\n \t// nil entries may still contain references to other type parameters.\n \t// For instance, for [A any, B interface{ []C }, C interface{ *A }], if A == int\n \t// was given, unification produced the type list [int, []C, *A]. We eliminate the\n@@ -501,8 +569,8 @@ func (check *Checker) inferB(posn positioner, tparams []*TypeParam, targs []Type\n \t}\n \n \t// Once nothing changes anymore, we may still have type parameters left;\n-\t// e.g., a structural constraint *P may match a type parameter Q but we\n-\t// don't have any type arguments to fill in for *P or Q (issue #45548).\n+\t// e.g., a constraint with core type *P may match a type parameter Q but\n+\t// we don't have any type arguments to fill in for *P or Q (issue #45548).\n \t// Don't let such inferences escape, instead nil them out.\n \tfor i, typ := range types {\n \t\tif typ != nil && isParameterized(tparams, typ) {\n@@ -522,6 +590,19 @@ func (check *Checker) inferB(posn positioner, tparams []*TypeParam, targs []Type\n \treturn\n }\n \n+func adjCoreType(tpar *TypeParam) Type {\n+\t// If the type parameter embeds a single, possibly named\n+\t// type, use that one instead of the core type (which is\n+\t// always the underlying type of that single type).\n+\tif single := tpar.singleType(); single != nil {\n+\t\tif debug {\n+\t\t\tassert(under(single) == coreType(tpar))\n+\t\t}\n+\t\treturn single\n+\t}\n+\treturn coreType(tpar)\n+}\n+\n type cycleFinder struct {\n \ttparams []*TypeParam\n \ttypes   []Type"}, {"sha": "4aeaeb7f1169ca91d5424718fed63a810329e268", "filename": "libgo/go/go/types/instantiate.go", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Finstantiate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Finstantiate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Finstantiate.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -135,6 +135,8 @@ func (check *Checker) validateTArgLen(pos token.Pos, ntparams, ntargs int) bool\n func (check *Checker) verify(pos token.Pos, tparams []*TypeParam, targs []Type) (int, error) {\n \tsmap := makeSubstMap(tparams, targs)\n \tfor i, tpar := range tparams {\n+\t\t// Ensure that we have a (possibly implicit) interface as type bound (issue #51048).\n+\t\ttpar.iface()\n \t\t// The type parameter bound is parameterized with the same type parameters\n \t\t// as the instantiated type; before we can use it for bounds checking we\n \t\t// need to instantiate it with the type arguments with which we instantiated\n@@ -160,25 +162,17 @@ func (check *Checker) implements(V, T Type) error {\n \t\treturn nil // avoid follow-on errors (see issue #49541 for an example)\n \t}\n \n-\tvar qf Qualifier\n-\tif check != nil {\n-\t\tqf = check.qualifier\n-\t}\n \terrorf := func(format string, args ...any) error {\n-\t\treturn errors.New(sprintf(nil, qf, false, format, args...))\n+\t\treturn errors.New(check.sprintf(format, args...))\n \t}\n \n \tTi, _ := Tu.(*Interface)\n \tif Ti == nil {\n-\t\tvar fset *token.FileSet\n-\t\tif check != nil {\n-\t\t\tfset = check.fset\n-\t\t}\n \t\tvar cause string\n \t\tif isInterfacePtr(Tu) {\n-\t\t\tcause = sprintf(fset, qf, false, \"type %s is pointer to interface, not interface\", T)\n+\t\t\tcause = check.sprintf(\"type %s is pointer to interface, not interface\", T)\n \t\t} else {\n-\t\t\tcause = sprintf(fset, qf, false, \"%s is not an interface\", T)\n+\t\t\tcause = check.sprintf(\"%s is not an interface\", T)\n \t\t}\n \t\treturn errorf(\"%s does not implement %s (%s)\", V, T, cause)\n \t}\n@@ -203,29 +197,14 @@ func (check *Checker) implements(V, T Type) error {\n \t}\n \n \t// V must implement T's methods, if any.\n-\tif Ti.NumMethods() > 0 {\n-\t\tif m, wrong := check.missingMethod(V, Ti, true); m != nil /* !Implements(V, Ti) */ {\n-\t\t\tif check != nil && compilerErrorMessages {\n-\t\t\t\treturn errorf(\"%s does not implement %s %s\", V, T, check.missingMethodReason(V, T, m, wrong))\n-\t\t\t}\n-\t\t\tvar cause string\n-\t\t\tif wrong != nil {\n-\t\t\t\tif Identical(m.typ, wrong.typ) {\n-\t\t\t\t\tcause = fmt.Sprintf(\"missing method %s (%s has pointer receiver)\", m.name, m.name)\n-\t\t\t\t} else {\n-\t\t\t\t\tcause = fmt.Sprintf(\"wrong type for method %s (have %s, want %s)\", m.Name(), wrong.typ, m.typ)\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tcause = \"missing method \" + m.Name()\n-\t\t\t}\n-\t\t\treturn errorf(\"%s does not implement %s: %s\", V, T, cause)\n-\t\t}\n+\tif m, wrong := check.missingMethod(V, Ti, true); m != nil /* !Implements(V, Ti) */ {\n+\t\treturn errorf(\"%s does not implement %s %s\", V, T, check.missingMethodReason(V, T, m, wrong))\n \t}\n \n \t// If T is comparable, V must be comparable.\n \t// Remember as a pending error and report only if we don't have a more specific error.\n \tvar pending error\n-\tif Ti.IsComparable() && !Comparable(V) {\n+\tif Ti.IsComparable() && ((Vi != nil && !Vi.IsComparable()) || (Vi == nil && !Comparable(V))) {\n \t\tpending = errorf(\"%s does not implement comparable\", V)\n \t}\n "}, {"sha": "e03712a892aa50a903f6b6210eacf04e5ca57a4e", "filename": "libgo/go/go/types/issues_test.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fissues_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fissues_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fissues_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -652,16 +652,15 @@ func TestIssue50646(t *testing.T) {\n \t\tt.Errorf(\"comparable is not a comparable type\")\n \t}\n \n-\t// TODO(gri) should comparable be an alias, like any? (see #50791)\n-\tif !Implements(anyType, comparableType.Underlying().(*Interface)) {\n-\t\tt.Errorf(\"any does not implement comparable\")\n+\tif Implements(anyType, comparableType.Underlying().(*Interface)) {\n+\t\tt.Errorf(\"any implements comparable\")\n \t}\n \tif !Implements(comparableType, anyType.(*Interface)) {\n \t\tt.Errorf(\"comparable does not implement any\")\n \t}\n \n-\tif !AssignableTo(anyType, comparableType) {\n-\t\tt.Errorf(\"any not assignable to comparable\")\n+\tif AssignableTo(anyType, comparableType) {\n+\t\tt.Errorf(\"any assignable to comparable\")\n \t}\n \tif !AssignableTo(comparableType, anyType) {\n \t\tt.Errorf(\"comparable not assignable to any\")"}, {"sha": "501c230357b5014ea6b17a26b5985143d1daf77c", "filename": "libgo/go/go/types/lookup.go", "status": "modified", "additions": 102, "deletions": 107, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -7,6 +7,7 @@\n package types\n \n import (\n+\t\"bytes\"\n \t\"strings\"\n )\n \n@@ -55,23 +56,23 @@ func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (o\n \t// not have found it for T (see also issue 8590).\n \tif t, _ := T.(*Named); t != nil {\n \t\tif p, _ := t.Underlying().(*Pointer); p != nil {\n-\t\t\tobj, index, indirect = lookupFieldOrMethod(p, false, pkg, name)\n+\t\t\tobj, index, indirect = lookupFieldOrMethod(p, false, pkg, name, false)\n \t\t\tif _, ok := obj.(*Func); ok {\n \t\t\t\treturn nil, nil, false\n \t\t\t}\n \t\t\treturn\n \t\t}\n \t}\n \n-\tobj, index, indirect = lookupFieldOrMethod(T, addressable, pkg, name)\n+\tobj, index, indirect = lookupFieldOrMethod(T, addressable, pkg, name, false)\n \n-\t// If we didn't find anything and if we have a type parameter with a structural constraint,\n-\t// see if there is a matching field (but not a method, those need to be declared explicitly\n-\t// in the constraint). If the structural constraint is a named pointer type (see above), we\n-\t// are ok here because only fields are accepted as results.\n+\t// If we didn't find anything and if we have a type parameter with a core type,\n+\t// see if there is a matching field (but not a method, those need to be declared\n+\t// explicitly in the constraint). If the constraint is a named pointer type (see\n+\t// above), we are ok here because only fields are accepted as results.\n \tif obj == nil && isTypeParam(T) {\n-\t\tif t := structuralType(T); t != nil {\n-\t\t\tobj, index, indirect = lookupFieldOrMethod(t, addressable, pkg, name)\n+\t\tif t := coreType(T); t != nil {\n+\t\t\tobj, index, indirect = lookupFieldOrMethod(t, addressable, pkg, name, false)\n \t\t\tif _, ok := obj.(*Var); !ok {\n \t\t\t\tobj, index, indirect = nil, nil, false // accept fields (variables) only\n \t\t\t}\n@@ -86,9 +87,11 @@ func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (o\n //           indirectly via different packages.)\n \n // lookupFieldOrMethod should only be called by LookupFieldOrMethod and missingMethod.\n+// If foldCase is true, the lookup for methods will include looking for any method\n+// which case-folds to the same as 'name' (used for giving helpful error messages).\n //\n // The resulting object may not be fully type-checked.\n-func lookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool) {\n+func lookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string, foldCase bool) (obj Object, index []int, indirect bool) {\n \t// WARNING: The code in this function is extremely subtle - do not modify casually!\n \n \tif name == \"_\" {\n@@ -142,7 +145,7 @@ func lookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (o\n \n \t\t\t\t// look for a matching attached method\n \t\t\t\tnamed.resolve(nil)\n-\t\t\t\tif i, m := named.lookupMethod(pkg, name); m != nil {\n+\t\t\t\tif i, m := named.lookupMethod(pkg, name, foldCase); m != nil {\n \t\t\t\t\t// potential match\n \t\t\t\t\t// caution: method may not have a proper signature yet\n \t\t\t\t\tindex = concat(e.index, i)\n@@ -189,7 +192,7 @@ func lookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (o\n \n \t\t\tcase *Interface:\n \t\t\t\t// look for a matching method (interface may be a type parameter)\n-\t\t\t\tif i, m := t.typeSet().LookupMethod(pkg, name); m != nil {\n+\t\t\t\tif i, m := t.typeSet().LookupMethod(pkg, name, foldCase); m != nil {\n \t\t\t\t\tassert(m.typ != nil)\n \t\t\t\t\tindex = concat(e.index, i)\n \t\t\t\t\tif obj != nil || e.multiples {\n@@ -279,75 +282,61 @@ func lookupType(m map[Type]int, typ Type) (int, bool) {\n // x is of interface type V).\n //\n func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool) {\n-\tm, typ := (*Checker)(nil).missingMethod(V, T, static)\n-\treturn m, typ != nil\n+\tm, alt := (*Checker)(nil).missingMethod(V, T, static)\n+\t// Only report a wrong type if the alternative method has the same name as m.\n+\treturn m, alt != nil && alt.name == m.name // alt != nil implies m != nil\n }\n \n-// missingMethod is like MissingMethod but accepts a *Checker as\n-// receiver and an addressable flag.\n-// The receiver may be nil if missingMethod is invoked through\n-// an exported API call (such as MissingMethod), i.e., when all\n-// methods have been type-checked.\n-// If the type has the correctly named method, but with the wrong\n-// signature, the existing method is returned as well.\n-// To improve error messages, also report the wrong signature\n-// when the method exists on *V instead of V.\n-func (check *Checker) missingMethod(V Type, T *Interface, static bool) (method, wrongType *Func) {\n-\t// fast path for common case\n-\tif T.Empty() {\n+// missingMethod is like MissingMethod but accepts a *Checker as receiver.\n+// The receiver may be nil if missingMethod is invoked through an exported\n+// API call (such as MissingMethod), i.e., when all methods have been type-\n+// checked.\n+//\n+// If a method is missing on T but is found on *T, or if a method is found\n+// on T when looked up with case-folding, this alternative method is returned\n+// as the second result.\n+func (check *Checker) missingMethod(V Type, T *Interface, static bool) (method, alt *Func) {\n+\tif T.NumMethods() == 0 {\n \t\treturn\n \t}\n \n-\tif ityp, _ := under(V).(*Interface); ityp != nil {\n-\t\t// TODO(gri) the methods are sorted - could do this more efficiently\n+\t// V is an interface\n+\tif u, _ := under(V).(*Interface); u != nil {\n+\t\ttset := u.typeSet()\n \t\tfor _, m := range T.typeSet().methods {\n-\t\t\t_, f := ityp.typeSet().LookupMethod(m.pkg, m.name)\n+\t\t\t_, f := tset.LookupMethod(m.pkg, m.name, false)\n \n \t\t\tif f == nil {\n \t\t\t\tif !static {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\treturn m, f\n-\t\t\t}\n-\n-\t\t\t// both methods must have the same number of type parameters\n-\t\t\tftyp := f.typ.(*Signature)\n-\t\t\tmtyp := m.typ.(*Signature)\n-\t\t\tif ftyp.TypeParams().Len() != mtyp.TypeParams().Len() {\n-\t\t\t\treturn m, f\n-\t\t\t}\n-\t\t\tif ftyp.TypeParams().Len() > 0 {\n-\t\t\t\tpanic(\"method with type parameters\")\n+\t\t\t\treturn m, nil\n \t\t\t}\n \n-\t\t\tif !Identical(ftyp, mtyp) {\n+\t\t\tif !Identical(f.typ, m.typ) {\n \t\t\t\treturn m, f\n \t\t\t}\n \t\t}\n \n \t\treturn\n \t}\n \n-\t// A concrete type implements T if it implements all methods of T.\n+\t// V is not an interface\n \tfor _, m := range T.typeSet().methods {\n-\t\t// TODO(gri) should this be calling lookupFieldOrMethod instead (and why not)?\n-\t\tobj, _, _ := lookupFieldOrMethod(V, false, m.pkg, m.name)\n-\n-\t\t// Check if *V implements this method of T.\n-\t\tif obj == nil {\n-\t\t\tptr := NewPointer(V)\n-\t\t\tobj, _, _ = lookupFieldOrMethod(ptr, false, m.pkg, m.name)\n-\n-\t\t\tif obj != nil {\n-\t\t\t\t// methods may not have a fully set up signature yet\n-\t\t\t\tif check != nil {\n-\t\t\t\t\tcheck.objDecl(obj, nil)\n-\t\t\t\t}\n-\t\t\t\treturn m, obj.(*Func)\n+\t\t// TODO(gri) should this be calling LookupFieldOrMethod instead (and why not)?\n+\t\tobj, _, _ := lookupFieldOrMethod(V, false, m.pkg, m.name, false)\n+\n+\t\t// check if m is on *V, or on V with case-folding\n+\t\tfound := obj != nil\n+\t\tif !found {\n+\t\t\t// TODO(gri) Instead of NewPointer(V) below, can we just set the \"addressable\" argument?\n+\t\t\tobj, _, _ = lookupFieldOrMethod(NewPointer(V), false, m.pkg, m.name, false)\n+\t\t\tif obj == nil {\n+\t\t\t\tobj, _, _ = lookupFieldOrMethod(V, false, m.pkg, m.name, true /* fold case */)\n \t\t\t}\n \t\t}\n \n-\t\t// we must have a method (not a field of matching function type)\n+\t\t// we must have a method (not a struct field)\n \t\tf, _ := obj.(*Func)\n \t\tif f == nil {\n \t\t\treturn m, nil\n@@ -358,17 +347,7 @@ func (check *Checker) missingMethod(V Type, T *Interface, static bool) (method,\n \t\t\tcheck.objDecl(f, nil)\n \t\t}\n \n-\t\t// both methods must have the same number of type parameters\n-\t\tftyp := f.typ.(*Signature)\n-\t\tmtyp := m.typ.(*Signature)\n-\t\tif ftyp.TypeParams().Len() != mtyp.TypeParams().Len() {\n-\t\t\treturn m, f\n-\t\t}\n-\t\tif ftyp.TypeParams().Len() > 0 {\n-\t\t\tpanic(\"method with type parameters\")\n-\t\t}\n-\n-\t\tif !Identical(ftyp, mtyp) {\n+\t\tif !found || !Identical(f.typ, m.typ) {\n \t\t\treturn m, f\n \t\t}\n \t}\n@@ -378,58 +357,49 @@ func (check *Checker) missingMethod(V Type, T *Interface, static bool) (method,\n \n // missingMethodReason returns a string giving the detailed reason for a missing method m,\n // where m is missing from V, but required by T. It puts the reason in parentheses,\n-// and may include more have/want info after that. If non-nil, wrongType is a relevant\n+// and may include more have/want info after that. If non-nil, alt is a relevant\n // method that matches in some way. It may have the correct name, but wrong type, or\n-// it may have a pointer receiver.\n-func (check *Checker) missingMethodReason(V, T Type, m, wrongType *Func) string {\n-\tvar r string\n+// it may have a pointer receiver, or it may have the correct name except wrong case.\n+// check may be nil.\n+func (check *Checker) missingMethodReason(V, T Type, m, alt *Func) string {\n \tvar mname string\n-\tif compilerErrorMessages {\n+\tif check != nil && compilerErrorMessages {\n \t\tmname = m.Name() + \" method\"\n \t} else {\n \t\tmname = \"method \" + m.Name()\n \t}\n-\tif wrongType != nil {\n-\t\tpos := check.fset.Position(wrongType.Pos())\n-\t\tif Identical(m.typ, wrongType.typ) {\n-\t\t\tif m.Name() == wrongType.Name() {\n-\t\t\t\tr = check.sprintf(\"(%s has pointer receiver) at %s\", mname, pos)\n-\t\t\t} else {\n-\t\t\t\tr = check.sprintf(\"(missing %s)\\n\\t\\thave %s^^%s at %s\\n\\t\\twant %s^^%s\",\n-\t\t\t\t\tmname, wrongType.Name(), wrongType.typ, pos, m.Name(), m.typ)\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif compilerErrorMessages {\n-\t\t\t\tr = check.sprintf(\"(wrong type for %s)\\n\\t\\thave %s^^%s at %s\\n\\t\\twant %s^^%s\",\n-\t\t\t\t\tmname, wrongType.Name(), wrongType.typ, pos, m.Name(), m.typ)\n-\t\t\t} else {\n-\t\t\t\tr = check.sprintf(\"(wrong type for %s)\\n\\thave %s at %s\\nwant %s\",\n-\t\t\t\t\tmname, wrongType.typ, pos, m.typ)\n-\t\t\t}\n+\n+\tif alt != nil {\n+\t\tif m.Name() != alt.Name() {\n+\t\t\treturn check.sprintf(\"(missing %s)\\n\\t\\thave %s\\n\\t\\twant %s\",\n+\t\t\t\tmname, check.funcString(alt), check.funcString(m))\n \t\t}\n-\t\t// This is a hack to print the function type without the leading\n-\t\t// 'func' keyword in the have/want printouts. We could change to have\n-\t\t// an extra formatting option for types2.Type that doesn't print out\n-\t\t// 'func'.\n-\t\tr = strings.Replace(r, \"^^func\", \"\", -1)\n-\t} else if IsInterface(T) {\n-\t\tif isInterfacePtr(V) {\n-\t\t\tr = \"(\" + check.interfacePtrError(V) + \")\"\n+\n+\t\tif Identical(m.typ, alt.typ) {\n+\t\t\treturn check.sprintf(\"(%s has pointer receiver)\", mname)\n \t\t}\n-\t} else if isInterfacePtr(T) {\n-\t\tr = \"(\" + check.interfacePtrError(T) + \")\"\n+\n+\t\treturn check.sprintf(\"(wrong type for %s)\\n\\t\\thave %s\\n\\t\\twant %s\",\n+\t\t\tmname, check.funcString(alt), check.funcString(m))\n+\t}\n+\n+\tif isInterfacePtr(V) {\n+\t\treturn \"(\" + check.interfacePtrError(V) + \")\"\n \t}\n-\tif r == \"\" {\n-\t\tr = check.sprintf(\"(missing %s)\", mname)\n+\n+\tif isInterfacePtr(T) {\n+\t\treturn \"(\" + check.interfacePtrError(T) + \")\"\n \t}\n-\treturn r\n+\n+\treturn check.sprintf(\"(missing %s)\", mname)\n }\n \n func isInterfacePtr(T Type) bool {\n \tp, _ := under(T).(*Pointer)\n \treturn p != nil && IsInterface(p.base)\n }\n \n+// check may be nil.\n func (check *Checker) interfacePtrError(T Type) string {\n \tassert(isInterfacePtr(T))\n \tif p, _ := under(T).(*Pointer); isTypeParam(p.base) {\n@@ -438,23 +408,47 @@ func (check *Checker) interfacePtrError(T Type) string {\n \treturn check.sprintf(\"type %s is pointer to interface, not interface\", T)\n }\n \n+// check may be nil.\n+func (check *Checker) funcString(f *Func) string {\n+\tbuf := bytes.NewBufferString(f.name)\n+\tvar qf Qualifier\n+\tif check != nil {\n+\t\tqf = check.qualifier\n+\t}\n+\tWriteSignature(buf, f.typ.(*Signature), qf)\n+\treturn buf.String()\n+}\n+\n // assertableTo reports whether a value of type V can be asserted to have type T.\n // It returns (nil, false) as affirmative answer. Otherwise it returns a missing\n // method required by V and whether it is missing or just has the wrong type.\n // The receiver may be nil if assertableTo is invoked through an exported API call\n // (such as AssertableTo), i.e., when all methods have been type-checked.\n-// If the global constant forceStrict is set, assertions that are known to fail\n-// are not permitted.\n+// TODO(gri) replace calls to this function with calls to newAssertableTo.\n func (check *Checker) assertableTo(V *Interface, T Type) (method, wrongType *Func) {\n \t// no static check is required if T is an interface\n \t// spec: \"If T is an interface type, x.(T) asserts that the\n \t//        dynamic type of x implements the interface T.\"\n-\tif IsInterface(T) && !forceStrict {\n+\tif IsInterface(T) {\n \t\treturn\n \t}\n+\t// TODO(gri) fix this for generalized interfaces\n \treturn check.missingMethod(T, V, false)\n }\n \n+// newAssertableTo reports whether a value of type V can be asserted to have type T.\n+// It also implements behavior for interfaces that currently are only permitted\n+// in constraint position (we have not yet defined that behavior in the spec).\n+func (check *Checker) newAssertableTo(V *Interface, T Type) error {\n+\t// no static check is required if T is an interface\n+\t// spec: \"If T is an interface type, x.(T) asserts that the\n+\t//        dynamic type of x implements the interface T.\"\n+\tif IsInterface(T) {\n+\t\treturn nil\n+\t}\n+\treturn check.implements(T, V)\n+}\n+\n // deref dereferences typ if it is a *Pointer and returns its base and true.\n // Otherwise it returns (typ, false).\n func deref(typ Type) (Type, bool) {\n@@ -503,10 +497,11 @@ func fieldIndex(fields []*Var, pkg *Package, name string) int {\n }\n \n // lookupMethod returns the index of and method with matching package and name, or (-1, nil).\n-func lookupMethod(methods []*Func, pkg *Package, name string) (int, *Func) {\n+// If foldCase is true, method names are considered equal if they are equal with case folding.\n+func lookupMethod(methods []*Func, pkg *Package, name string, foldCase bool) (int, *Func) {\n \tif name != \"_\" {\n \t\tfor i, m := range methods {\n-\t\t\tif m.sameId(pkg, name) {\n+\t\t\tif (m.name == name || foldCase && strings.EqualFold(m.name, name)) && m.sameId(pkg, m.name) {\n \t\t\t\treturn i, m\n \t\t\t}\n \t\t}"}, {"sha": "afe919013d92c0519e923973879960b9956d2d1e", "filename": "libgo/go/go/types/methodlist.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fmethodlist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fmethodlist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fmethodlist.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -41,19 +41,20 @@ func (l *methodList) isLazy() bool {\n // panics if the receiver is lazy.\n func (l *methodList) Add(m *Func) {\n \tassert(!l.isLazy())\n-\tif i, _ := lookupMethod(l.methods, m.pkg, m.name); i < 0 {\n+\tif i, _ := lookupMethod(l.methods, m.pkg, m.name, false); i < 0 {\n \t\tl.methods = append(l.methods, m)\n \t}\n }\n \n // Lookup looks up the method identified by pkg and name in the receiver.\n-// Lookup panics if the receiver is lazy.\n-func (l *methodList) Lookup(pkg *Package, name string) (int, *Func) {\n+// Lookup panics if the receiver is lazy. If foldCase is true, method names\n+// are considered equal if they are equal with case folding.\n+func (l *methodList) Lookup(pkg *Package, name string, foldCase bool) (int, *Func) {\n \tassert(!l.isLazy())\n \tif l == nil {\n \t\treturn -1, nil\n \t}\n-\treturn lookupMethod(l.methods, pkg, name)\n+\treturn lookupMethod(l.methods, pkg, name, foldCase)\n }\n \n // Len returns the length of the method list."}, {"sha": "5e84c39776ccb48bab4b07da7fe3856a04f74b12", "filename": "libgo/go/go/types/named.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fnamed.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fnamed.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fnamed.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -299,12 +299,12 @@ func (n *Named) setUnderlying(typ Type) {\n \t}\n }\n \n-func (n *Named) lookupMethod(pkg *Package, name string) (int, *Func) {\n+func (n *Named) lookupMethod(pkg *Package, name string, foldCase bool) (int, *Func) {\n \tn.resolve(nil)\n \t// If n is an instance, we may not have yet instantiated all of its methods.\n \t// Look up the method index in orig, and only instantiate method at the\n \t// matching index (if any).\n-\ti, _ := n.orig.methods.Lookup(pkg, name)\n+\ti, _ := n.orig.methods.Lookup(pkg, name, foldCase)\n \tif i < 0 {\n \t\treturn -1, nil\n \t}"}, {"sha": "14e99bf42640bb87bfec099e5b7007f4cf767e22", "filename": "libgo/go/go/types/predicates.go", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -33,7 +33,7 @@ func isBasic(t Type, info BasicInfo) bool {\n // The allX predicates below report whether t is an X.\n // If t is a type parameter the result is true if isX is true\n // for all specified types of the type parameter's type set.\n-// allX is an optimized version of isX(structuralType(t)) (which\n+// allX is an optimized version of isX(coreType(t)) (which\n // is the same as underIs(t, isX)).\n \n func allBoolean(typ Type) bool         { return allBasic(typ, IsBoolean) }\n@@ -47,7 +47,7 @@ func allNumericOrString(typ Type) bool { return allBasic(typ, IsNumeric|IsString\n // allBasic reports whether under(t) is a basic type with the specified info.\n // If t is a type parameter, the result is true if isBasic(t, info) is true\n // for all specific types of the type parameter's type set.\n-// allBasic(t, info) is an optimized version of isBasic(structuralType(t), info).\n+// allBasic(t, info) is an optimized version of isBasic(coreType(t), info).\n func allBasic(t Type, info BasicInfo) bool {\n \tif tpar, _ := t.(*TypeParam); tpar != nil {\n \t\treturn tpar.is(func(t *term) bool { return t != nil && isBasic(t.typ, info) })\n@@ -104,10 +104,11 @@ func isGeneric(t Type) bool {\n \n // Comparable reports whether values of type T are comparable.\n func Comparable(T Type) bool {\n-\treturn comparable(T, nil)\n+\treturn comparable(T, nil, nil)\n }\n \n-func comparable(T Type, seen map[Type]bool) bool {\n+// If reportf != nil, it may be used to report why T is not comparable.\n+func comparable(T Type, seen map[Type]bool, reportf func(string, ...interface{})) bool {\n \tif seen[T] {\n \t\treturn true\n \t}\n@@ -125,13 +126,22 @@ func comparable(T Type, seen map[Type]bool) bool {\n \t\treturn true\n \tcase *Struct:\n \t\tfor _, f := range t.fields {\n-\t\t\tif !comparable(f.typ, seen) {\n+\t\t\tif !comparable(f.typ, seen, nil) {\n+\t\t\t\tif reportf != nil {\n+\t\t\t\t\treportf(\"struct containing %s cannot be compared\", f.typ)\n+\t\t\t\t}\n \t\t\t\treturn false\n \t\t\t}\n \t\t}\n \t\treturn true\n \tcase *Array:\n-\t\treturn comparable(t.elem, seen)\n+\t\tif !comparable(t.elem, seen, nil) {\n+\t\t\tif reportf != nil {\n+\t\t\t\treportf(\"%s cannot be compared\", t)\n+\t\t\t}\n+\t\t\treturn false\n+\t\t}\n+\t\treturn true\n \tcase *Interface:\n \t\treturn !isTypeParam(T) || t.typeSet().IsComparable(seen)\n \t}\n@@ -308,6 +318,9 @@ func identical(x, y Type, cmpTags bool, p *ifacePair) bool {\n \t\tif y, ok := y.(*Interface); ok {\n \t\t\txset := x.typeSet()\n \t\t\tyset := y.typeSet()\n+\t\t\tif xset.comparable != yset.comparable {\n+\t\t\t\treturn false\n+\t\t\t}\n \t\t\tif !xset.terms.equal(yset.terms) {\n \t\t\t\treturn false\n \t\t\t}"}, {"sha": "a5aee482ac144c89672b56db96279df6dc36affe", "filename": "libgo/go/go/types/stmt.go", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -248,7 +248,7 @@ L:\n \t\t}\n \t\t// Order matters: By comparing v against x, error positions are at the case values.\n \t\tres := v // keep original v unchanged\n-\t\tcheck.comparison(&res, x, token.EQL)\n+\t\tcheck.comparison(&res, x, token.EQL, true)\n \t\tif res.mode == invalid {\n \t\t\tcontinue L\n \t\t}\n@@ -281,7 +281,8 @@ func (check *Checker) isNil(e ast.Expr) bool {\n \treturn false\n }\n \n-func (check *Checker) caseTypes(x *operand, xtyp *Interface, types []ast.Expr, seen map[Type]ast.Expr) (T Type) {\n+// If the type switch expression is invalid, x is nil.\n+func (check *Checker) caseTypes(x *operand, types []ast.Expr, seen map[Type]ast.Expr) (T Type) {\n \tvar dummy operand\n L:\n \tfor _, e := range types {\n@@ -310,8 +311,8 @@ L:\n \t\t\t}\n \t\t}\n \t\tseen[T] = e\n-\t\tif T != nil && xtyp != nil {\n-\t\t\tcheck.typeAssertion(e, x, xtyp, T)\n+\t\tif x != nil && T != nil {\n+\t\t\tcheck.typeAssertion(e, x, T, true)\n \t\t}\n \t}\n \treturn\n@@ -417,9 +418,9 @@ func (check *Checker) stmt(ctxt stmtContext, s ast.Stmt) {\n \t\tif ch.mode == invalid || val.mode == invalid {\n \t\t\treturn\n \t\t}\n-\t\tu := structuralType(ch.typ)\n+\t\tu := coreType(ch.typ)\n \t\tif u == nil {\n-\t\t\tcheck.invalidOp(inNode(s, s.Arrow), _InvalidSend, \"cannot send to %s: no structural type\", &ch)\n+\t\t\tcheck.invalidOp(inNode(s, s.Arrow), _InvalidSend, \"cannot send to %s: no core type\", &ch)\n \t\t\treturn\n \t\t}\n \t\tuch, _ := u.(*Chan)\n@@ -684,12 +685,13 @@ func (check *Checker) stmt(ctxt stmtContext, s ast.Stmt) {\n \t\t\treturn\n \t\t}\n \t\t// TODO(gri) we may want to permit type switches on type parameter values at some point\n-\t\tvar xtyp *Interface\n+\t\tvar sx *operand // switch expression against which cases are compared against; nil if invalid\n \t\tif isTypeParam(x.typ) {\n \t\t\tcheck.errorf(&x, _InvalidTypeSwitch, \"cannot use type switch on type parameter value %s\", &x)\n \t\t} else {\n-\t\t\txtyp, _ = under(x.typ).(*Interface)\n-\t\t\tif xtyp == nil {\n+\t\t\tif _, ok := under(x.typ).(*Interface); ok {\n+\t\t\t\tsx = &x\n+\t\t\t} else {\n \t\t\t\tcheck.errorf(&x, _InvalidTypeSwitch, \"%s is not an interface\", &x)\n \t\t\t}\n \t\t}\n@@ -705,7 +707,7 @@ func (check *Checker) stmt(ctxt stmtContext, s ast.Stmt) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// Check each type in this type switch case.\n-\t\t\tT := check.caseTypes(&x, xtyp, clause.List, seen)\n+\t\t\tT := check.caseTypes(sx, clause.List, seen)\n \t\t\tcheck.openScope(clause, \"case\")\n \t\t\t// If lhs exists, declare a corresponding variable in the case-local scope.\n \t\t\tif lhs != nil {\n@@ -829,12 +831,12 @@ func (check *Checker) stmt(ctxt stmtContext, s ast.Stmt) {\n \t\t// determine key/value types\n \t\tvar key, val Type\n \t\tif x.mode != invalid {\n-\t\t\t// Ranging over a type parameter is permitted if it has a structural type.\n+\t\t\t// Ranging over a type parameter is permitted if it has a core type.\n \t\t\tvar cause string\n-\t\t\tu := structuralType(x.typ)\n+\t\t\tu := coreType(x.typ)\n \t\t\tswitch t := u.(type) {\n \t\t\tcase nil:\n-\t\t\t\tcause = check.sprintf(\"%s has no structural type\", x.typ)\n+\t\t\t\tcause = check.sprintf(\"%s has no core type\", x.typ)\n \t\t\tcase *Chan:\n \t\t\t\tif s.Value != nil {\n \t\t\t\t\tcheck.softErrorf(s.Value, _InvalidIterVar, \"range over %s permits only one iteration variable\", &x)"}, {"sha": "53247a35851d0f0bc0912ca1c23263bbff6647bb", "filename": "libgo/go/go/types/subst.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fsubst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Fsubst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fsubst.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -21,6 +21,17 @@ func makeSubstMap(tpars []*TypeParam, targs []Type) substMap {\n \treturn proj\n }\n \n+// makeRenameMap is like makeSubstMap, but creates a map used to rename type\n+// parameters in from with the type parameters in to.\n+func makeRenameMap(from, to []*TypeParam) substMap {\n+\tassert(len(from) == len(to))\n+\tproj := make(substMap, len(from))\n+\tfor i, tpar := range from {\n+\t\tproj[tpar] = to[i]\n+\t}\n+\treturn proj\n+}\n+\n func (m substMap) empty() bool {\n \treturn len(m) == 0\n }"}, {"sha": "861597399e3b1f0865de38a7f5bc3ed9310ef5dd", "filename": "libgo/go/go/types/testdata/check/builtins.go2", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fbuiltins.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fbuiltins.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fbuiltins.go2?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -148,23 +148,23 @@ func _[\n \t_ = make /* ERROR expects 2 or 3 arguments */ (S1)\n \t_ = make(S1, 10, 20)\n \t_ = make /* ERROR expects 2 or 3 arguments */ (S1, 10, 20, 30)\n-\t_ = make(S2 /* ERROR cannot make S2: no structural type */ , 10)\n+\t_ = make(S2 /* ERROR cannot make S2: no core type */ , 10)\n \n \ttype M0 map[string]int\n \t_ = make(map[string]int)\n \t_ = make(M0)\n \t_ = make(M1)\n \t_ = make(M1, 10)\n \t_ = make/* ERROR expects 1 or 2 arguments */(M1, 10, 20)\n-\t_ = make(M2 /* ERROR cannot make M2: no structural type */ )\n+\t_ = make(M2 /* ERROR cannot make M2: no core type */ )\n \n \ttype C0 chan int\n \t_ = make(chan int)\n \t_ = make(C0)\n \t_ = make(C1)\n \t_ = make(C1, 10)\n \t_ = make/* ERROR expects 1 or 2 arguments */(C1, 10, 20)\n-\t_ = make(C2 /* ERROR cannot make C2: no structural type */ )\n+\t_ = make(C2 /* ERROR cannot make C2: no core type */ )\n \t_ = make(C3)\n }\n "}, {"sha": "8a4c207a05d66398fac2f4eb2c6dafcba95d5866", "filename": "libgo/go/go/types/testdata/check/builtins.src", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fbuiltins.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fbuiltins.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fbuiltins.src?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -15,9 +15,9 @@ func append1() {\n \tvar x int\n \tvar s []byte\n \t_ = append() // ERROR not enough arguments\n-\t_ = append(\"foo\" /* ERROR not a slice */ )\n-\t_ = append(nil /* ERROR not a slice */ , s)\n-\t_ = append(x /* ERROR not a slice */ , s)\n+\t_ = append(\"foo\" /* ERROR must be a slice */ )\n+\t_ = append(nil /* ERROR must be a slice */ , s)\n+\t_ = append(x /* ERROR must be a slice */ , s)\n \t_ = append(s)\n \t_ = append(s, nil...)\n \tappend /* ERROR not used */ (s)\n@@ -77,7 +77,7 @@ func append3() {\n \t_ = append(f2())\n \t_ = append(f3())\n \t_ = append(f5())\n-\t_ = append(ff /* ERROR not a slice */ ()) // TODO(gri) better error message\n+\t_ = append(ff /* ERROR must be a slice */ ()) // TODO(gri) better error message\n }\n \n func cap1() {"}, {"sha": "6133dbb42bfeda72b062dd51c732e545801f2773", "filename": "libgo/go/go/types/testdata/check/expr2.src", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fexpr2.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fexpr2.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fexpr2.src?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -9,8 +9,8 @@ package expr2\n func _bool() {\n \tconst t = true == true\n \tconst f = true == false\n-\t_ = t /* ERROR \"cannot compare\" */ < f\n-\t_ = 0 /* ERROR \"mismatched types untyped int and untyped bool\" */ == t\n+\t_ = t /* ERROR cannot compare */ < f\n+\t_ = 0 /* ERROR mismatched types untyped int and untyped bool */ == t\n \tvar b bool\n \tvar x, y float32\n \tb = x < y\n@@ -20,7 +20,7 @@ func _bool() {\n \n // corner cases\n var (\n-\tv0 = nil /* ERROR \"cannot compare\" */ == nil\n+\tv0 = nil == nil // ERROR operator == not defined on untyped nil\n )\n \n func arrays() {\n@@ -40,7 +40,7 @@ func arrays() {\n \t_ = c /* ERROR mismatched types */ == d\n \n \tvar e [10]func() int\n-\t_ = e /* ERROR == not defined */ == e\n+\t_ = e /* ERROR \\[10\\]func\\(\\) int cannot be compared */ == e\n }\n \n func structs() {\n@@ -79,8 +79,8 @@ func structs() {\n \n func pointers() {\n \t// nil\n-\t_ = nil /* ERROR == not defined */ == nil\n-\t_ = nil /* ERROR != not defined */ != nil\n+\t_ = nil == nil // ERROR operator == not defined on untyped nil\n+\t_ = nil != nil // ERROR operator != not defined on untyped nil\n \t_ = nil /* ERROR < not defined */ < nil\n \t_ = nil /* ERROR <= not defined */ <= nil\n \t_ = nil /* ERROR > not defined */ > nil\n@@ -211,16 +211,16 @@ func interfaces() {\n \n \t// issue #28164\n \t// testcase from issue\n-\t_ = interface /* ERROR cannot compare */ {}(nil) == []int(nil)\n+\t_ = interface{}(nil) == [ /* ERROR slice can only be compared to nil */ ]int(nil)\n \n \t// related cases\n \tvar e interface{}\n \tvar s []int\n \tvar x int\n-\t_ = e /* ERROR cannot compare */ == s\n-\t_ = s /* ERROR cannot compare */ == e\n-\t_ = e /* ERROR cannot compare */ < x\n-\t_ = x /* ERROR cannot compare */ < e\n+\t_ = e == s // ERROR slice can only be compared to nil\n+\t_ = s /* ERROR slice can only be compared to nil */ == e\n+\t_ = e /* ERROR operator < not defined on interface */ < x\n+\t_ = x < e // ERROR operator < not defined on interface\n }\n \n func slices() {\n@@ -231,7 +231,7 @@ func slices() {\n \t_ = s /* ERROR < not defined */ < nil\n \n \t// slices are not otherwise comparable\n-\t_ = s /* ERROR == not defined */ == s\n+\t_ = s /* ERROR slice can only be compared to nil */ == s\n \t_ = s /* ERROR < not defined */ < s\n }\n \n@@ -243,7 +243,7 @@ func maps() {\n \t_ = m /* ERROR < not defined */ < nil\n \n \t// maps are not otherwise comparable\n-\t_ = m /* ERROR == not defined */ == m\n+\t_ = m /* ERROR map can only be compared to nil */ == m\n \t_ = m /* ERROR < not defined */ < m\n }\n \n@@ -255,6 +255,6 @@ func funcs() {\n \t_ = f /* ERROR < not defined */ < nil\n \n \t// funcs are not otherwise comparable\n-\t_ = f /* ERROR == not defined */ == f\n+\t_ = f /* ERROR func can only be compared to nil */ == f\n \t_ = f /* ERROR < not defined */ < f\n }"}, {"sha": "8291852a49962eb4276a23cd17d2715604a38805", "filename": "libgo/go/go/types/testdata/check/issues.go2", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fissues.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fissues.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fissues.go2?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -9,19 +9,18 @@ package p\n import \"io\"\n import \"context\"\n \n-// Interfaces are always comparable (though the comparison may panic at runtime).\n func eql[T comparable](x, y T) bool {\n \treturn x == y\n }\n \n-func _() {\n-\tvar x interface{}\n-\tvar y interface{ m() }\n+func _[X comparable, Y interface{comparable; m()}]() {\n+\tvar x X\n+\tvar y Y\n \teql(x, y /* ERROR does not match */ ) // interfaces of different types\n \teql(x, x)\n \teql(y, y)\n-\teql(y, nil)\n-\teql[io.Reader](nil, nil)\n+\teql(y, nil /* ERROR cannot use nil as Y value in argument to eql */ )\n+\teql[io /* ERROR does not implement comparable */ .Reader](nil, nil)\n }\n \n // If we have a receiver of pointer to type parameter type (below: *T)"}, {"sha": "8bb4c8c5cae088a55cb8b772e7c37ff620a71cb0", "filename": "libgo/go/go/types/testdata/check/issues.src", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fissues.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fissues.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fissues.src?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -131,42 +131,42 @@ func issue10260() {\n \t)\n \n \tvar x I1\n-\tx = T1 /* ERROR cannot use .*: missing method foo \\(foo has pointer receiver\\) */ {}\n-\t_ = x /* ERROR .* cannot have dynamic type T1 \\(missing method foo \\(foo has pointer receiver\\)\\) */ .(T1)\n+\tx = T1 /* ERROR cannot use \\(T1 literal\\) .* as I1 value in assignment: T1 does not implement I1 \\(method foo has pointer receiver\\) */ {}\n+\t_ = x /* ERROR impossible type assertion: x\\.\\(T1\\)\\n\\tT1 does not implement I1 \\(method foo has pointer receiver\\) */ .(T1)\n \n \tT1{}.foo /* ERROR cannot call pointer method foo on T1 */ ()\n \tx.Foo /* ERROR \"x.Foo undefined \\(type I1 has no field or method Foo, but does have foo\\)\" */ ()\n \n-\t_ = i2 /* ERROR i2 .* cannot have dynamic type \\*T1 \\(wrong type for method foo \\(have func\\(\\), want func\\(x int\\)\\)\\) */ .(*T1)\n+\t_ = i2 /* ERROR impossible type assertion: i2\\.\\(\\*T1\\)\\n\\t\\*T1 does not implement I2 \\(wrong type for method foo\\)\\n\\t\\thave foo\\(\\)\\n\\t\\twant foo\\(x int\\) */ .(*T1)\n \n-\ti1 = i0 /* ERROR cannot use .* missing method foo */\n-\ti1 = t0 /* ERROR cannot use .* missing method foo */\n-\ti1 = i2 /* ERROR cannot use .* wrong type for method foo */\n-\ti1 = t2 /* ERROR cannot use .* wrong type for method foo */\n-\ti2 = i1 /* ERROR cannot use .* wrong type for method foo */\n-\ti2 = t1 /* ERROR cannot use .* wrong type for method foo */\n+\ti1 = i0 /* ERROR cannot use i0 .* as I1 value in assignment: I0 does not implement I1 \\(missing method foo\\) */\n+\ti1 = t0 /* ERROR .* t0 .* as I1 .*: \\*T0 does not implement I1 \\(missing method foo\\) */\n+\ti1 = i2 /* ERROR .* i2 .* as I1 .*: I2 does not implement I1 \\(wrong type for method foo\\)\\n\\t\\thave foo\\(x int\\)\\n\\t\\twant foo\\(\\) */\n+\ti1 = t2 /* ERROR .* t2 .* as I1 .*: \\*T2 does not implement I1 \\(wrong type for method foo\\)\\n\\t\\thave foo\\(x int\\)\\n\\t\\twant foo\\(\\) */\n+\ti2 = i1 /* ERROR .* i1 .* as I2 .*: I1 does not implement I2 \\(wrong type for method foo\\)\\n\\t\\thave foo\\(\\)\\n\\t\\twant foo\\(x int\\) */\n+\ti2 = t1 /* ERROR .* t1 .* as I2 .*: \\*T1 does not implement I2 \\(wrong type for method foo\\)\\n\\t\\thave foo\\(\\)\\n\\t\\twant foo\\(x int\\) */\n \n-\t_ = func() I1 { return i0 /* ERROR cannot use .* missing method foo */ }\n-\t_ = func() I1 { return t0 /* ERROR cannot use .* missing method foo */ }\n-\t_ = func() I1 { return i2 /* ERROR cannot use .* wrong type for method foo */ }\n-\t_ = func() I1 { return t2 /* ERROR cannot use .* wrong type for method foo */ }\n-\t_ = func() I2 { return i1 /* ERROR cannot use .* wrong type for method foo */ }\n-\t_ = func() I2 { return t1 /* ERROR cannot use .* wrong type for method foo */ }\n+\t_ = func() I1 { return i0 /* ERROR cannot use i0 .* as I1 value in return statement: I0 does not implement I1 \\(missing method foo\\) */ }\n+\t_ = func() I1 { return t0 /* ERROR .* t0 .* as I1 .*: \\*T0 does not implement I1 \\(missing method foo\\) */ }\n+\t_ = func() I1 { return i2 /* ERROR .* i2 .* as I1 .*: I2 does not implement I1 \\(wrong type for method foo\\)\\n\\t\\thave foo\\(x int\\)\\n\\t\\twant foo\\(\\) */ }\n+\t_ = func() I1 { return t2 /* ERROR .* t2 .* as I1 .*: \\*T2 does not implement I1 \\(wrong type for method foo\\)\\n\\t\\thave foo\\(x int\\)\\n\\t\\twant foo\\(\\) */ }\n+\t_ = func() I2 { return i1 /* ERROR .* i1 .* as I2 .*: I1 does not implement I2 \\(wrong type for method foo\\)\\n\\t\\thave foo\\(\\)\\n\\t\\twant foo\\(x int\\) */ }\n+\t_ = func() I2 { return t1 /* ERROR .* t1 .* as I2 .*: \\*T1 does not implement I2 \\(wrong type for method foo\\)\\n\\t\\thave foo\\(\\)\\n\\t\\twant foo\\(x int\\) */ }\n \n \t// a few more - less exhaustive now\n \n \tf := func(I1, I2){}\n-\tf(i0 /* ERROR cannot use .* missing method foo */ , i1 /* ERROR cannot use .* wrong type for method foo \\(have func\\(\\), want func\\(x int\\)\\) */ )\n+\tf(i0 /* ERROR missing method foo */ , i1 /* ERROR wrong type for method foo */ )\n \n-\t_ = [...]I1{i0 /* ERROR cannot use .* missing method foo */ }\n-\t_ = [...]I1{i2 /* ERROR cannot use .* wrong type for method foo */ }\n-\t_ = []I1{i0 /* ERROR cannot use .* missing method foo */ }\n-\t_ = []I1{i2 /* ERROR cannot use .* wrong type for method foo */ }\n-\t_ = map[int]I1{0: i0 /* ERROR cannot use .* missing method foo */ }\n-\t_ = map[int]I1{0: i2 /* ERROR cannot use .* wrong type for method foo */ }\n+\t_ = [...]I1{i0 /* ERROR cannot use i0 .* as I1 value in array or slice literal: I0 does not implement I1 \\(missing method foo\\) */ }\n+\t_ = [...]I1{i2 /* ERROR cannot use i2 .* as I1 value in array or slice literal: I2 does not implement I1 \\(wrong type for method foo\\)\\n\\t\\thave foo\\(x int\\)\\n\\t\\twant foo\\(\\) */ }\n+\t_ = []I1{i0 /* ERROR missing method foo */ }\n+\t_ = []I1{i2 /* ERROR wrong type for method foo */ }\n+\t_ = map[int]I1{0: i0 /* ERROR missing method foo */ }\n+\t_ = map[int]I1{0: i2 /* ERROR wrong type for method foo */ }\n \n-\tmake(chan I1) <- i0 /* ERROR I0 does not implement I1: missing method foo */\n-\tmake(chan I1) <- i2 /* ERROR wrong type for method foo \\(have func\\(x int\\), want func\\(\\)\\) */\n+\tmake(chan I1) <- i0 /* ERROR missing method foo */\n+\tmake(chan I1) <- i2 /* ERROR wrong type for method foo */\n }\n \n // Check that constants representable as integers are in integer form"}, {"sha": "7795a442aae73d8bc1b80bb2846f9b4de97f22d4", "filename": "libgo/go/go/types/testdata/check/stmt0.src", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fstmt0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fstmt0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Fstmt0.src?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -429,7 +429,7 @@ func switches0() {\n \n \tswitch int32(x) {\n \tcase 1, 2:\n-\tcase x /* ERROR \"cannot compare\" */ :\n+\tcase x /* ERROR \"invalid case x in switch on int32\\(x\\) \\(mismatched types int and int32\\)\" */ :\n \t}\n \n \tswitch x {"}, {"sha": "29a3b16cd65535890fd6f49d4f1600cc0b3da42e", "filename": "libgo/go/go/types/testdata/check/typeparams.go2", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Ftypeparams.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Ftypeparams.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fcheck%2Ftypeparams.go2?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -134,11 +134,11 @@ func _[T interface{ ~string }] (x T, i, j, k int) { var _ T = x[i:j:k /* ERROR 3\n type myByte1 []byte\n type myByte2 []byte\n func _[T interface{ []byte | myByte1 | myByte2 }] (x T, i, j, k int) { var _ T = x[i:j:k] }\n-func _[T interface{ []byte | myByte1 | []int }] (x T, i, j, k int) { var _ T = x /* ERROR no structural type */ [i:j:k] }\n+func _[T interface{ []byte | myByte1 | []int }] (x T, i, j, k int) { var _ T = x /* ERROR no core type */ [i:j:k] }\n \n func _[T interface{ []byte | myByte1 | myByte2 | string }] (x T, i, j, k int) { var _ T = x[i:j] }\n func _[T interface{ []byte | myByte1 | myByte2 | string }] (x T, i, j, k int) { var _ T = x[i:j:k /* ERROR 3-index slice of string */ ] }\n-func _[T interface{ []byte | myByte1 | []int | string }] (x T, i, j, k int) { var _ T = x /* ERROR no structural type */ [i:j] }\n+func _[T interface{ []byte | myByte1 | []int | string }] (x T, i, j, k int) { var _ T = x /* ERROR no core type */ [i:j] }\n \n // len/cap built-ins\n \n@@ -230,7 +230,7 @@ func _[\n         for _, _ = range s1 {}\n \n         var s2 S2\n-        for range s2 /* ERROR cannot range over s2.*no structural type */ {}\n+        for range s2 /* ERROR cannot range over s2.*no core type */ {}\n \n         var a0 []int\n         for range a0 {}\n@@ -243,7 +243,7 @@ func _[\n         for _, _ = range a1 {}\n \n         var a2 A2\n-        for range a2 /* ERROR cannot range over a2.*no structural type */ {}\n+        for range a2 /* ERROR cannot range over a2.*no core type */ {}\n \n         var p0 *[10]int\n         for range p0 {}\n@@ -256,7 +256,7 @@ func _[\n         for _, _ = range p1 {}\n \n         var p2 P2\n-        for range p2 /* ERROR cannot range over p2.*no structural type */ {}\n+        for range p2 /* ERROR cannot range over p2.*no core type */ {}\n \n         var m0 map[string]int\n         for range m0 {}\n@@ -269,7 +269,7 @@ func _[\n         for _, _ = range m1 {}\n \n         var m2 M2\n-        for range m2 /* ERROR cannot range over m2.*no structural type */ {}\n+        for range m2 /* ERROR cannot range over m2.*no core type */ {}\n }\n \n // type inference checks\n@@ -329,8 +329,8 @@ func init[P /* ERROR func init must have no type parameters */ any]() {}\n type T struct {}\n \n func (T) m1() {}\n-func (T) m2[ /* ERROR methods cannot have type parameters */ _ any]() {}\n-func (T) m3[ /* ERROR methods cannot have type parameters */ P any]() {}\n+func (T) m2[ /* ERROR method must have no type parameters */ _ any]() {}\n+func (T) m3[ /* ERROR method must have no type parameters */ P any]() {}\n \n // type inference across parameterized types\n \n@@ -391,25 +391,28 @@ func _[T any] (x T) {\n \n // type parameters in methods (generalization)\n \n-type R0 struct{}\n+// Type Parameter lists are not allowed on methods, and are not produced by\n+// go/parser. The test cases below are preserved for consistency with types2,\n+// which produces an error but stores type parameters.\n+// type R0 struct{}\n \n-func (R0) _[ /* ERROR methods cannot have type parameters */ T any](x T) {}\n-func (R0 /* ERROR invalid receiver */ ) _[ /* ERROR methods cannot have type parameters */ R0 any]() {} // scope of type parameters starts at \"func\"\n+// func (R0) _[ /* ERROR methods cannot have type parameters */ T any](x T) {}\n+// func (R0 /* ERROR invalid receiver */ ) _[ /* ERROR methods cannot have type parameters */ R0 any]() {} // scope of type parameters starts at \"func\"\n \n-type R1[A, B any] struct{}\n+// type R1[A, B any] struct{}\n \n-func (_ R1[A, B]) m0(A, B)\n-func (_ R1[A, B]) m1[ /* ERROR methods cannot have type parameters */ T any](A, B, T) T  { panic(0) }\n-func (_ R1 /* ERROR not a generic type */ [R1, _]) _()\n-func (_ R1[A, B]) _[ /* ERROR methods cannot have type parameters */ A /* ERROR redeclared */ any](B) {}\n+// func (_ R1[A, B]) m0(A, B)\n+// func (_ R1[A, B]) m1[ /* ERROR methods cannot have type parameters */ T any](A, B, T) T  { panic(0) }\n+// func (_ R1 /* ERROR not a generic type */ [R1, _]) _()\n+// func (_ R1[A, B]) _[ /* ERROR methods cannot have type parameters */ A /* ERROR redeclared */ any](B) {}\n \n-func _() {\n-        var r R1[int, string]\n-        r.m1[rune](42, \"foo\", 'a')\n-        r.m1[rune](42, \"foo\", 1.2 /* ERROR cannot use .* as rune .* \\(truncated\\) */)\n-        r.m1(42, \"foo\", 1.2) // using type inference\n-        var _ float64 = r.m1(42, \"foo\", 1.2)\n-}\n+// func _() {\n+//         var r R1[int, string]\n+//         r.m1[rune](42, \"foo\", 'a')\n+//         r.m1[rune](42, \"foo\", 1.2 /* ERROR cannot use .* as rune .* \\(truncated\\) */)\n+//         r.m1(42, \"foo\", 1.2) // using type inference\n+//         var _ float64 = r.m1(42, \"foo\", 1.2)\n+// }\n \n type I1[A any] interface {\n         m1(A)"}, {"sha": "70d393b45551f9dd397c0d6b73dbcdbe91a2dd0d", "filename": "libgo/go/go/types/testdata/examples/inference.go2", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Finference.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Finference.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Finference.go2?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -113,7 +113,7 @@ func _() {\n \t// from the first one through constraint type inference.\n \trelated3[int]()\n \n-\t// The inferred type is the structural type of the Slice\n+\t// The inferred type is the core type of the Slice\n \t// type parameter.\n \tvar _ []int = related3[int]()\n "}, {"sha": "1e83f898836f094f00310a7bfee29141d954becc", "filename": "libgo/go/go/types/testdata/examples/types.go2", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Ftypes.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Ftypes.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Ftypes.go2?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -298,7 +298,7 @@ func _[T interface {~int|~float64}]() {\n \n // It is possible to create composite literals of type parameter\n // type as long as it's possible to create a composite literal\n-// of the structural type of the type parameter's constraint.\n+// of the core type of the type parameter's constraint.\n func _[P interface{ ~[]int }]() P {\n \treturn P{}\n \treturn P{1, 2, 3}\n@@ -313,7 +313,7 @@ func _[P interface{ ~[]E }, E interface{ map[string]P } ]() P {\n }\n \n // This is a degenerate case with a singleton type set, but we can create\n-// composite literals even if the structural type is a defined type.\n+// composite literals even if the core type is a defined type.\n type MyInts []int\n \n func _[P MyInts]() P {"}, {"sha": "8cba2e735a00d8848e98157fd06ca8c969f15334", "filename": "libgo/go/go/types/testdata/fixedbugs/issue39634.go2", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue39634.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue39634.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue39634.go2?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -85,7 +85,7 @@ func (t T25[A]) m1() {}\n var x T25 /* ERROR without instantiation */ .m1\n \n // crash 26\n-type T26 = interface{ F26[ /* ERROR methods cannot have type parameters */ Z any]() }\n+type T26 = interface{ F26[ /* ERROR interface method must have no type parameters */ Z any]() }\n // The error messages on the line below differ from types2 because for backward\n // compatibility go/parser must produce an IndexExpr with BadExpr index for the\n // expression F26[]."}, {"sha": "8d5c983fd507aa8690ebcdc2ee3a4d363166628e", "filename": "libgo/go/go/types/testdata/fixedbugs/issue43110.src", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue43110.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue43110.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue43110.src?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -30,7 +30,7 @@ func _() {\n \t}\n \n \tswitch (func())(nil) {\n-\tcase f /* ERROR cannot compare */ :\n+\tcase f /* ERROR invalid case f in switch on .* \\(func can only be compared to nil\\) */ :\n \t}\n \n \tswitch nil /* ERROR use of untyped nil in switch expression */ {"}, {"sha": "7083dc9eef569b0d574d833a6a28c05d334df500", "filename": "libgo/go/go/types/testdata/fixedbugs/issue49005.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue49005.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue49005.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue49005.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+type T1 interface{ M() }\n+\n+func F1() T1\n+\n+var _ = F1().(*X1 /* ERROR undeclared name: X1 */)\n+\n+func _() {\n+\tswitch F1().(type) {\n+\tcase *X1 /* ERROR undeclared name: X1 */ :\n+\t}\n+}\n+\n+type T2 interface{ M() }\n+\n+func F2() T2\n+\n+var _ = F2 /* ERROR impossible type assertion: F2\\(\\)\\.\\(\\*X2\\)\\n\\t\\*X2 does not implement T2 \\(missing method M\\) */ ().(*X2)\n+\n+type X2 struct{}\n+\n+func _() {\n+\tswitch F2().(type) {\n+\tcase * /* ERROR impossible type switch case: \\*X2\\n\\tF2\\(\\) \\(value of type T2\\) cannot have dynamic type \\*X2 \\(missing method M\\) */ X2:\n+\t}\n+}"}, {"sha": "41604b8bad9cd189733f81c2d87f5a2dc401dfb6", "filename": "libgo/go/go/types/testdata/fixedbugs/issue50918.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue50918.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue50918.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue50918.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+type thing1 struct {\n+\tthings []string\n+}\n+\n+type thing2 struct {\n+\tthings []thing1\n+}\n+\n+func _() {\n+\tvar a1, b1 thing1\n+\t_ = a1 /* ERROR struct containing \\[\\]string cannot be compared */ == b1\n+\n+\tvar a2, b2 thing2\n+\t_ = a2 /* ERROR struct containing \\[\\]thing1 cannot be compared */ == b2\n+}"}, {"sha": "bf2dcc93d02e6fe0ba6c282b6a7d2e7fb0817111", "filename": "libgo/go/go/types/testdata/fixedbugs/issue50965.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue50965.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue50965.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue50965.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+func _(x int, c string) {\n+\tswitch x {\n+\tcase c /* ERROR invalid case c in switch on x \\(mismatched types string and int\\) */ :\n+\t}\n+}\n+\n+func _(x, c []int) {\n+\tswitch x {\n+\tcase c /* ERROR invalid case c in switch on x \\(slice can only be compared to nil\\) */ :\n+\t}\n+}"}, {"sha": "b84391df19793db075d5d5e90abccca1c3a27a27", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51145.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51145.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51145.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51145.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+import \"fmt\"\n+\n+type (\n+\t_ [fmt /* ERROR invalid array length fmt */ ]int\n+\t_ [float64 /* ERROR invalid array length float64 */ ]int\n+\t_ [f /* ERROR invalid array length f */ ]int\n+\t_ [nil /* ERROR invalid array length nil */ ]int\n+)\n+\n+func f()\n+\n+var _ fmt.Stringer // use fmt"}, {"sha": "323365aefe356d287f230a471dcce9eb6a68e669", "filename": "libgo/go/go/types/type.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftype.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -27,13 +27,13 @@ func under(t Type) Type {\n \treturn t.Underlying()\n }\n \n-// If t is not a type parameter, structuralType returns the underlying type.\n-// If t is a type parameter, structuralType returns the single underlying\n+// If t is not a type parameter, coreType returns the underlying type.\n+// If t is a type parameter, coreType returns the single underlying\n // type of all types in its type set if it exists, or nil otherwise. If the\n // type set contains only unrestricted and restricted channel types (with\n // identical element types), the single underlying type is the restricted\n // channel type if the restrictions are always the same, or nil otherwise.\n-func structuralType(t Type) Type {\n+func coreType(t Type) Type {\n \ttpar, _ := t.(*TypeParam)\n \tif tpar == nil {\n \t\treturn under(t)\n@@ -59,10 +59,10 @@ func structuralType(t Type) Type {\n \treturn nil\n }\n \n-// structuralString is like structuralType but also considers []byte\n+// coreString is like coreType but also considers []byte\n // and strings as identical. In this case, if successful and we saw\n // a string, the result is of type (possibly untyped) string.\n-func structuralString(t Type) Type {\n+func coreString(t Type) Type {\n \ttpar, _ := t.(*TypeParam)\n \tif tpar == nil {\n \t\treturn under(t) // string or untyped string"}, {"sha": "71e6861b87f40fe1c84cc3a18ff0bdc4a1db218f", "filename": "libgo/go/go/types/typeparam.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeparam.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeparam.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeparam.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -5,7 +5,6 @@\n package types\n \n import (\n-\t\"go/token\"\n \t\"sync/atomic\"\n )\n \n@@ -127,8 +126,9 @@ func (t *TypeParam) iface() *Interface {\n \n \t// compute type set if necessary\n \tif ityp.tset == nil {\n-\t\t// use the (original) type bound position if we have one\n-\t\tpos := token.NoPos\n+\t\t// pos is used for tracing output; start with the type parameter position.\n+\t\tpos := t.obj.pos\n+\t\t// use the (original or possibly instantiated) type bound position if we have one\n \t\tif n, _ := bound.(*Named); n != nil {\n \t\t\tpos = n.obj.pos\n \t\t}"}, {"sha": "e1f73015b93a738a2e5e0e538d471619fb6baa87", "filename": "libgo/go/go/types/typeset.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeset.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeset.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeset.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -37,7 +37,7 @@ func (s *_TypeSet) IsComparable(seen map[Type]bool) bool {\n \t\treturn s.comparable\n \t}\n \treturn s.is(func(t *term) bool {\n-\t\treturn t != nil && comparable(t.typ, seen)\n+\t\treturn t != nil && comparable(t.typ, seen, nil)\n \t})\n }\n \n@@ -56,9 +56,8 @@ func (s *_TypeSet) NumMethods() int { return len(s.methods) }\n func (s *_TypeSet) Method(i int) *Func { return s.methods[i] }\n \n // LookupMethod returns the index of and method with matching package and name, or (-1, nil).\n-func (s *_TypeSet) LookupMethod(pkg *Package, name string) (int, *Func) {\n-\t// TODO(gri) s.methods is sorted - consider binary search\n-\treturn lookupMethod(s.methods, pkg, name)\n+func (s *_TypeSet) LookupMethod(pkg *Package, name string, foldCase bool) (int, *Func) {\n+\treturn lookupMethod(s.methods, pkg, name, foldCase)\n }\n \n func (s *_TypeSet) String() string {"}, {"sha": "db6a904aaa50e73bf82fc65d2eec926d4d735216", "filename": "libgo/go/go/types/typexpr.go", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftypexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Ftypexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypexpr.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -487,12 +487,20 @@ func (check *Checker) instantiatedType(ix *typeparams.IndexExpr, def *Named) (re\n // and returns the constant length >= 0, or a value < 0\n // to indicate an error (and thus an unknown length).\n func (check *Checker) arrayLength(e ast.Expr) int64 {\n-\t// If e is an undeclared identifier, the array declaration might be an\n-\t// attempt at a parameterized type declaration with missing constraint.\n-\t// Provide a better error message than just \"undeclared name: X\".\n-\tif name, _ := e.(*ast.Ident); name != nil && check.lookup(name.Name) == nil {\n-\t\tcheck.errorf(name, _InvalidArrayLen, \"undeclared name %s for array length\", name.Name)\n-\t\treturn -1\n+\t// If e is an identifier, the array declaration might be an\n+\t// attempt at a parameterized type declaration with missing\n+\t// constraint. Provide an error message that mentions array\n+\t// length.\n+\tif name, _ := e.(*ast.Ident); name != nil {\n+\t\tobj := check.lookup(name.Name)\n+\t\tif obj == nil {\n+\t\t\tcheck.errorf(name, _InvalidArrayLen, \"undeclared name %s for array length\", name.Name)\n+\t\t\treturn -1\n+\t\t}\n+\t\tif _, ok := obj.(*Const); !ok {\n+\t\t\tcheck.errorf(name, _InvalidArrayLen, \"invalid array length %s\", name.Name)\n+\t\t\treturn -1\n+\t\t}\n \t}\n \n \tvar x operand"}, {"sha": "ac904d6d6bf6bc5b8edcde8d5e17d7f016b54256", "filename": "libgo/go/go/types/unify.go", "status": "modified", "additions": 91, "deletions": 9, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Funify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fgo%2Ftypes%2Funify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Funify.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -9,6 +9,7 @@ package types\n import (\n \t\"bytes\"\n \t\"fmt\"\n+\t\"strings\"\n )\n \n // The unifier maintains two separate sets of type parameters x and y\n@@ -26,16 +27,35 @@ import (\n // parameter P (\"x\" side), but the argument type P must be left alone so\n // that unification resolves the type parameter P to P.\n //\n-// For bidirection unification, both sets are provided. This enables\n+// For bidirectional unification, both sets are provided. This enables\n // unification to go from argument to parameter type and vice versa.\n // For constraint type inference, we use bidirectional unification\n // where both the x and y type parameters are identical. This is done\n // by setting up one of them (using init) and then assigning its value\n // to the other.\n \n-// Upper limit for recursion depth. Used to catch infinite recursions\n-// due to implementation issues (e.g., see issues #48619, #48656).\n-const unificationDepthLimit = 50\n+const (\n+\t// Upper limit for recursion depth. Used to catch infinite recursions\n+\t// due to implementation issues (e.g., see issues #48619, #48656).\n+\tunificationDepthLimit = 50\n+\n+\t// Whether to panic when unificationDepthLimit is reached. Turn on when\n+\t// investigating infinite recursion.\n+\tpanicAtUnificationDepthLimit = false\n+\n+\t// If enableCoreTypeUnification is set, unification will consider\n+\t// the core types, if any, of non-local (unbound) type parameters.\n+\tenableCoreTypeUnification = true\n+\n+\t// If traceInference is set, unification will print a trace of its operation.\n+\t// Interpretation of trace:\n+\t//   x \u2261 y    attempt to unify types x and y\n+\t//   p \u279e y    type parameter p is set to type y (p is inferred to be y)\n+\t//   p \u21c4 q    type parameters p and q match (p is inferred to be q and vice versa)\n+\t//   x \u2262 y    types x and y cannot be unified\n+\t//   [p, q, ...] \u279e [x, y, ...]    mapping from type parameters to types\n+\ttraceInference = false\n+)\n \n // A unifier maintains the current type parameters for x and y\n // and the respective types inferred for each type parameter.\n@@ -52,6 +72,7 @@ type unifier struct {\n // exactly. If exact is not set, a named type's underlying type\n // is considered if unification would fail otherwise, and the\n // direction of channels is ignored.\n+// TODO(gri) exact is not set anymore by a caller. Consider removing it.\n func newUnifier(exact bool) *unifier {\n \tu := &unifier{exact: exact}\n \tu.x.unifier = u\n@@ -64,6 +85,10 @@ func (u *unifier) unify(x, y Type) bool {\n \treturn u.nify(x, y, nil)\n }\n \n+func (u *unifier) tracef(format string, args ...interface{}) {\n+\tfmt.Println(strings.Repeat(\".  \", u.depth) + sprintf(nil, nil, true, format, args...))\n+}\n+\n // A tparamsList describes a list of type parameters and the types inferred for them.\n type tparamsList struct {\n \tunifier *unifier\n@@ -115,6 +140,9 @@ func (d *tparamsList) init(tparams []*TypeParam) {\n // If both type parameters already have a type associated with them and they are\n // not joined, join fails and returns false.\n func (u *unifier) join(i, j int) bool {\n+\tif traceInference {\n+\t\tu.tracef(\"%s \u21c4 %s\", u.x.tparams[i], u.y.tparams[j])\n+\t}\n \tti := u.x.indices[i]\n \ttj := u.y.indices[j]\n \tswitch {\n@@ -164,7 +192,7 @@ func (d *tparamsList) index(typ Type) int {\n }\n \n // If tpar is a type parameter in list, tparamIndex returns the type parameter index.\n-// Otherwise, the result is < 0. tpar must not be nil.j\n+// Otherwise, the result is < 0. tpar must not be nil.\n func tparamIndex(list []*TypeParam, tpar *TypeParam) int {\n \t// Once a type parameter is bound its index is >= 0. However, there are some\n \t// code paths (namely tracing and type hashing) by which it is possible to\n@@ -204,6 +232,9 @@ func (d *tparamsList) at(i int) Type {\n func (d *tparamsList) set(i int, typ Type) {\n \tassert(typ != nil)\n \tu := d.unifier\n+\tif traceInference {\n+\t\tu.tracef(\"%s \u279e %s\", d.tparams[i], typ)\n+\t}\n \tswitch ti := d.indices[i]; {\n \tcase ti < 0:\n \t\tu.types[-ti-1] = typ\n@@ -241,17 +272,27 @@ func (u *unifier) nifyEq(x, y Type, p *ifacePair) bool {\n // adapted version of Checker.identical. For changes to that\n // code the corresponding changes should be made here.\n // Must not be called directly from outside the unifier.\n-func (u *unifier) nify(x, y Type, p *ifacePair) bool {\n+func (u *unifier) nify(x, y Type, p *ifacePair) (result bool) {\n+\tif traceInference {\n+\t\tu.tracef(\"%s \u2261 %s\", x, y)\n+\t}\n+\n \t// Stop gap for cases where unification fails.\n \tif u.depth >= unificationDepthLimit {\n-\t\tif debug {\n+\t\tif traceInference {\n+\t\t\tu.tracef(\"depth %d >= %d\", u.depth, unificationDepthLimit)\n+\t\t}\n+\t\tif panicAtUnificationDepthLimit {\n \t\t\tpanic(\"unification reached recursion depth limit\")\n \t\t}\n \t\treturn false\n \t}\n \tu.depth++\n \tdefer func() {\n \t\tu.depth--\n+\t\tif traceInference && !result {\n+\t\t\tu.tracef(\"%s \u2262 %s\", x, y)\n+\t\t}\n \t}()\n \n \tif !u.exact {\n@@ -261,8 +302,14 @@ func (u *unifier) nify(x, y Type, p *ifacePair) bool {\n \t\t// (We use !hasName to exclude any type with a name, including\n \t\t// basic types and type parameters; the rest are unamed types.)\n \t\tif nx, _ := x.(*Named); nx != nil && !hasName(y) {\n+\t\t\tif traceInference {\n+\t\t\t\tu.tracef(\"under %s \u2261 %s\", nx, y)\n+\t\t\t}\n \t\t\treturn u.nify(nx.under(), y, p)\n \t\t} else if ny, _ := y.(*Named); ny != nil && !hasName(x) {\n+\t\t\tif traceInference {\n+\t\t\t\tu.tracef(\"%s \u2261 under %s\", x, ny)\n+\t\t\t}\n \t\t\treturn u.nify(x, ny.under(), p)\n \t\t}\n \t}\n@@ -296,6 +343,35 @@ func (u *unifier) nify(x, y Type, p *ifacePair) bool {\n \t\treturn true\n \t}\n \n+\t// If we get here and x or y is a type parameter, they are type parameters\n+\t// from outside our declaration list. Try to unify their core types, if any\n+\t// (see issue #50755 for a test case).\n+\tif enableCoreTypeUnification && !u.exact {\n+\t\tif isTypeParam(x) && !hasName(y) {\n+\t\t\t// When considering the type parameter for unification\n+\t\t\t// we look at the adjusted core type (adjCoreType).\n+\t\t\t// If the adjusted core type is a named type N; the\n+\t\t\t// corresponding core type is under(N). Since !u.exact\n+\t\t\t// and y doesn't have a name, unification will end up\n+\t\t\t// comparing under(N) to y, so we can just use the core\n+\t\t\t// type instead. Optimization.\n+\t\t\tif cx := coreType(x); cx != nil {\n+\t\t\t\tif traceInference {\n+\t\t\t\t\tu.tracef(\"core %s \u2261 %s\", x, y)\n+\t\t\t\t}\n+\t\t\t\treturn u.nify(cx, y, p)\n+\t\t\t}\n+\t\t} else if isTypeParam(y) && !hasName(x) {\n+\t\t\t// see comment above\n+\t\t\tif cy := coreType(y); cy != nil {\n+\t\t\t\tif traceInference {\n+\t\t\t\t\tu.tracef(\"%s \u2261 core %s\", x, y)\n+\t\t\t\t}\n+\t\t\t\treturn u.nify(x, cy, p)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t// For type unification, do not shortcut (x == y) for identical\n \t// types. Instead keep comparing them element-wise to unify the\n \t// matching (and equal type parameter types). A simple test case\n@@ -387,6 +463,9 @@ func (u *unifier) nify(x, y Type, p *ifacePair) bool {\n \t\tif y, ok := y.(*Interface); ok {\n \t\t\txset := x.typeSet()\n \t\t\tyset := y.typeSet()\n+\t\t\tif xset.comparable != yset.comparable {\n+\t\t\t\treturn false\n+\t\t\t}\n \t\t\tif !xset.terms.equal(yset.terms) {\n \t\t\t\treturn false\n \t\t\t}\n@@ -454,11 +533,14 @@ func (u *unifier) nify(x, y Type, p *ifacePair) bool {\n \t\t\txargs := x.targs.list()\n \t\t\tyargs := y.targs.list()\n \n+\t\t\tif len(xargs) != len(yargs) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n \t\t\t// TODO(gri) This is not always correct: two types may have the same names\n \t\t\t//           in the same package if one of them is nested in a function.\n \t\t\t//           Extremely unlikely but we need an always correct solution.\n \t\t\tif x.obj.pkg == y.obj.pkg && x.obj.name == y.obj.name {\n-\t\t\t\tassert(len(xargs) == len(yargs))\n \t\t\t\tfor i, x := range xargs {\n \t\t\t\t\tif !u.nify(x, yargs[i], p) {\n \t\t\t\t\t\treturn false\n@@ -478,7 +560,7 @@ func (u *unifier) nify(x, y Type, p *ifacePair) bool {\n \t\t// avoid a crash in case of nil type\n \n \tdefault:\n-\t\tpanic(fmt.Sprintf(\"### u.nify(%s, %s), u.x.tparams = %s\", x, y, u.x.tparams))\n+\t\tpanic(sprintf(nil, nil, true, \"u.nify(%s, %s), u.x.tparams = %s\", x, y, u.x.tparams))\n \t}\n \n \treturn false"}, {"sha": "78664d7a96ddab14d3baa2cb5b1422c9edcdf535", "filename": "libgo/go/internal/cfg/cfg.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -62,6 +62,7 @@ const KnownEnv = `\n \tGOTOOLDIR\n \tGOVCS\n \tGOWASM\n+\tGOWORK\n \tGO_EXTLINK_ENABLED\n \tPKG_CONFIG\n `"}, {"sha": "3ccf74745f67a161f6f2b4090197ca5eec98093e", "filename": "libgo/go/internal/fuzz/fuzz.go", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Finternal%2Ffuzz%2Ffuzz.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Finternal%2Ffuzz%2Ffuzz.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ffuzz%2Ffuzz.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -316,12 +316,12 @@ func CoordinateFuzzing(ctx context.Context, opts CoordinateFuzzingOpts) (err err\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// Update the coordinator's coverage mask and save the value.\n \t\t\t\t\t\tinputSize := len(result.entry.Data)\n-\t\t\t\t\t\tduplicate, err := c.addCorpusEntries(true, result.entry)\n+\t\t\t\t\t\tentryNew, err := c.addCorpusEntries(true, result.entry)\n \t\t\t\t\t\tif err != nil {\n \t\t\t\t\t\t\tstop(err)\n \t\t\t\t\t\t\tbreak\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tif duplicate {\n+\t\t\t\t\t\tif !entryNew {\n \t\t\t\t\t\t\tcontinue\n \t\t\t\t\t\t}\n \t\t\t\t\t\tc.updateCoverage(keepCoverage)\n@@ -419,11 +419,21 @@ type corpus struct {\n \thashes  map[[sha256.Size]byte]bool\n }\n \n+// addCorpusEntries adds entries to the corpus, and optionally writes the entries\n+// to the cache directory. If an entry is already in the corpus it is skipped. If\n+// all of the entries are unique, addCorpusEntries returns true and a nil error,\n+// if at least one of the entries was a duplicate, it returns false and a nil error.\n func (c *coordinator) addCorpusEntries(addToCache bool, entries ...CorpusEntry) (bool, error) {\n+\tnoDupes := true\n \tfor _, e := range entries {\n-\t\th := sha256.Sum256(e.Data)\n+\t\tdata, err := corpusEntryData(e)\n+\t\tif err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t\th := sha256.Sum256(data)\n \t\tif c.corpus.hashes[h] {\n-\t\t\treturn true, nil\n+\t\t\tnoDupes = false\n+\t\t\tcontinue\n \t\t}\n \t\tif addToCache {\n \t\t\tif err := writeToCorpus(&e, c.opts.CacheDir); err != nil {\n@@ -437,7 +447,7 @@ func (c *coordinator) addCorpusEntries(addToCache bool, entries ...CorpusEntry)\n \t\tc.corpus.hashes[h] = true\n \t\tc.corpus.entries = append(c.corpus.entries, e)\n \t}\n-\treturn false, nil\n+\treturn noDupes, nil\n }\n \n // CorpusEntry represents an individual input for fuzzing.\n@@ -468,9 +478,9 @@ type CorpusEntry = struct {\n \tIsSeed bool\n }\n \n-// Data returns the raw input bytes, either from the data struct field,\n-// or from disk.\n-func CorpusEntryData(ce CorpusEntry) ([]byte, error) {\n+// corpusEntryData returns the raw input bytes, either from the data struct\n+// field, or from disk.\n+func corpusEntryData(ce CorpusEntry) ([]byte, error) {\n \tif ce.Data != nil {\n \t\treturn ce.Data, nil\n \t}\n@@ -587,7 +597,7 @@ type coordinator struct {\n \n \t// interestingCount is the number of unique interesting values which have\n \t// been found this execution.\n-\tinterestingCount int64\n+\tinterestingCount int\n \n \t// warmupInputCount is the count of all entries in the corpus which will\n \t// need to be received from workers to run once during warmup, but not fuzz.\n@@ -721,8 +731,8 @@ func (c *coordinator) logStats() {\n \t} else {\n \t\trate := float64(c.count-c.countLastLog) / now.Sub(c.timeLastLog).Seconds()\n \t\tif coverageEnabled {\n-\t\t\tinterestingTotalCount := int64(c.warmupInputCount-len(c.opts.Seed)) + c.interestingCount\n-\t\t\tfmt.Fprintf(c.opts.Log, \"fuzz: elapsed: %s, execs: %d (%.0f/sec), new interesting: %d (total: %d)\\n\", c.elapsed(), c.count, rate, c.interestingCount, interestingTotalCount)\n+\t\t\ttotal := c.warmupInputCount + c.interestingCount\n+\t\t\tfmt.Fprintf(c.opts.Log, \"fuzz: elapsed: %s, execs: %d (%.0f/sec), new interesting: %d (total: %d)\\n\", c.elapsed(), c.count, rate, c.interestingCount, total)\n \t\t} else {\n \t\t\tfmt.Fprintf(c.opts.Log, \"fuzz: elapsed: %s, execs: %d (%.0f/sec)\\n\", c.elapsed(), c.count, rate)\n \t\t}"}, {"sha": "e984ba73b201f0437329daa090117020daae5dc6", "filename": "libgo/go/internal/fuzz/worker.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Finternal%2Ffuzz%2Fworker.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Finternal%2Ffuzz%2Fworker.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ffuzz%2Fworker.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -973,7 +973,7 @@ func (wc *workerClient) minimize(ctx context.Context, entryIn CorpusEntry, args\n \t\treturn CorpusEntry{}, minimizeResponse{}, errSharedMemClosed\n \t}\n \tmem.header().count = 0\n-\tinp, err := CorpusEntryData(entryIn)\n+\tinp, err := corpusEntryData(entryIn)\n \tif err != nil {\n \t\treturn CorpusEntry{}, minimizeResponse{}, err\n \t}\n@@ -1059,7 +1059,7 @@ func (wc *workerClient) fuzz(ctx context.Context, entryIn CorpusEntry, args fuzz\n \t\treturn CorpusEntry{}, fuzzResponse{}, true, errSharedMemClosed\n \t}\n \tmem.header().count = 0\n-\tinp, err := CorpusEntryData(entryIn)\n+\tinp, err := corpusEntryData(entryIn)\n \tif err != nil {\n \t\treturn CorpusEntry{}, fuzzResponse{}, true, err\n \t}"}, {"sha": "6e0dbe73bbff53429de657a1cdb28392ff82e060", "filename": "libgo/go/internal/nettrace/nettrace.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Finternal%2Fnettrace%2Fnettrace.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Finternal%2Fnettrace%2Fnettrace.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fnettrace%2Fnettrace.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -27,7 +27,7 @@ type Trace struct {\n \tDNSStart func(name string)\n \n \t// DNSDone is called after a DNS lookup completes (or fails).\n-\t// The coalesced parameter is whether singleflight de-dupped\n+\t// The coalesced parameter is whether singleflight de-duped\n \t// the call. The addrs are of type net.IPAddr but can't\n \t// actually be for circular dependency reasons.\n \tDNSDone func(netIPs []any, coalesced bool, err error)"}, {"sha": "ad121a6fa9392d7abf1333479e7cac0d533c71a8", "filename": "libgo/go/net/dnsclient_unix.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -30,6 +30,10 @@ const (\n \t// to be used as a useTCP parameter to exchange\n \tuseTCPOnly  = true\n \tuseUDPOrTCP = false\n+\n+\t// Maximum DNS packet size.\n+\t// Value taken from https://dnsflagday.net/2020/.\n+\tmaxDNSPacketSize = 1232\n )\n \n var (\n@@ -82,7 +86,7 @@ func dnsPacketRoundTrip(c Conn, id uint16, query dnsmessage.Question, b []byte)\n \t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, err\n \t}\n \n-\tb = make([]byte, 512) // see RFC 1035\n+\tb = make([]byte, maxDNSPacketSize)\n \tfor {\n \t\tn, err := c.Read(b)\n \t\tif err != nil {"}, {"sha": "0ea2fae086a7cb8b78d7657d8c13d0fb747657b4", "filename": "libgo/go/net/dnsclient_unix_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -881,7 +881,7 @@ func (f *fakeDNSPacketConn) Close() error {\n func TestIgnoreDNSForgeries(t *testing.T) {\n \tc, s := Pipe()\n \tgo func() {\n-\t\tb := make([]byte, 512)\n+\t\tb := make([]byte, maxDNSPacketSize)\n \t\tn, err := s.Read(b)\n \t\tif err != nil {\n \t\t\tt.Error(err)"}, {"sha": "e41b20a15ba46656d4656e7e0152996f72bee113", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -606,6 +606,9 @@ func (t *Transport) roundTrip(req *Request) (*Response, error) {\n \t\t} else if !pconn.shouldRetryRequest(req, err) {\n \t\t\t// Issue 16465: return underlying net.Conn.Read error from peek,\n \t\t\t// as we've historically done.\n+\t\t\tif e, ok := err.(nothingWrittenError); ok {\n+\t\t\t\terr = e.error\n+\t\t\t}\n \t\t\tif e, ok := err.(transportReadFromServerError); ok {\n \t\t\t\terr = e.err\n \t\t\t}\n@@ -2032,6 +2035,9 @@ func (pc *persistConn) mapRoundTripError(req *transportRequest, startBytesWritte\n \t}\n \n \tif _, ok := err.(transportReadFromServerError); ok {\n+\t\tif pc.nwrite == startBytesWritten {\n+\t\t\treturn nothingWrittenError{err}\n+\t\t}\n \t\t// Don't decorate\n \t\treturn err\n \t}"}, {"sha": "2ed637e9f036cac04101c689803d26130b484827", "filename": "libgo/go/net/http/transport_internal_test.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_internal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_internal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_internal_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -52,8 +52,8 @@ func TestTransportPersistConnReadLoopEOF(t *testing.T) {\n \tconn.Close() // simulate the server hanging up on the client\n \n \t_, err = pc.roundTrip(treq)\n-\tif !isTransportReadFromServerError(err) && err != errServerClosedIdle {\n-\t\tt.Errorf(\"roundTrip = %#v, %v; want errServerClosedIdle or transportReadFromServerError\", err, err)\n+\tif !isNothingWrittenError(err) && !isTransportReadFromServerError(err) && err != errServerClosedIdle {\n+\t\tt.Errorf(\"roundTrip = %#v, %v; want errServerClosedIdle, transportReadFromServerError, or nothingWrittenError\", err, err)\n \t}\n \n \t<-pc.closech\n@@ -63,6 +63,11 @@ func TestTransportPersistConnReadLoopEOF(t *testing.T) {\n \t}\n }\n \n+func isNothingWrittenError(err error) bool {\n+\t_, ok := err.(nothingWrittenError)\n+\treturn ok\n+}\n+\n func isTransportReadFromServerError(err error) bool {\n \t_, ok := err.(transportReadFromServerError)\n \treturn ok"}, {"sha": "3a31f56bea845056a6afe3ebe2b12a28b2ef9577", "filename": "libgo/go/net/lookup_test.go", "status": "modified", "additions": 57, "deletions": 12, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Flookup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Flookup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -883,21 +883,66 @@ func TestLookupNonLDH(t *testing.T) {\n \n func TestLookupContextCancel(t *testing.T) {\n \tmustHaveExternalNetwork(t)\n-\tdefer dnsWaitGroup.Wait()\n+\ttestenv.SkipFlakyNet(t)\n \n-\tctx, ctxCancel := context.WithCancel(context.Background())\n-\tctxCancel()\n-\t_, err := DefaultResolver.LookupIPAddr(ctx, \"google.com\")\n-\tif err.(*DNSError).Err != errCanceled.Error() {\n-\t\ttestenv.SkipFlakyNet(t)\n-\t\tt.Fatal(err)\n+\torigTestHookLookupIP := testHookLookupIP\n+\tdefer func() {\n+\t\tdnsWaitGroup.Wait()\n+\t\ttestHookLookupIP = origTestHookLookupIP\n+\t}()\n+\n+\tlookupCtx, cancelLookup := context.WithCancel(context.Background())\n+\tunblockLookup := make(chan struct{})\n+\n+\t// Set testHookLookupIP to start a new, concurrent call to LookupIPAddr\n+\t// and cancel the original one, then block until the canceled call has returned\n+\t// (ensuring that it has performed any synchronous cleanup).\n+\ttestHookLookupIP = func(\n+\t\tctx context.Context,\n+\t\tfn func(context.Context, string, string) ([]IPAddr, error),\n+\t\tnetwork string,\n+\t\thost string,\n+\t) ([]IPAddr, error) {\n+\t\tselect {\n+\t\tcase <-unblockLookup:\n+\t\tdefault:\n+\t\t\t// Start a concurrent LookupIPAddr for the same host while the caller is\n+\t\t\t// still blocked, and sleep a little to give it time to be deduplicated\n+\t\t\t// before we cancel (and unblock) the caller.\n+\t\t\t// (If the timing doesn't quite work out, we'll end up testing sequential\n+\t\t\t// calls instead of concurrent ones, but the test should still pass.)\n+\t\t\tt.Logf(\"starting concurrent LookupIPAddr\")\n+\t\t\tdnsWaitGroup.Add(1)\n+\t\t\tgo func() {\n+\t\t\t\tdefer dnsWaitGroup.Done()\n+\t\t\t\t_, err := DefaultResolver.LookupIPAddr(context.Background(), host)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Error(err)\n+\t\t\t\t}\n+\t\t\t}()\n+\t\t\ttime.Sleep(1 * time.Millisecond)\n+\t\t}\n+\n+\t\tcancelLookup()\n+\t\t<-unblockLookup\n+\t\t// If the concurrent lookup above is deduplicated to this one\n+\t\t// (as we expect to happen most of the time), it is important\n+\t\t// that the original call does not cancel the shared Context.\n+\t\t// (See https://go.dev/issue/22724.) Explicitly check for\n+\t\t// cancellation now, just in case fn itself doesn't notice it.\n+\t\tif err := ctx.Err(); err != nil {\n+\t\t\tt.Logf(\"testHookLookupIP canceled\")\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tt.Logf(\"testHookLookupIP performing lookup\")\n+\t\treturn fn(ctx, network, host)\n \t}\n-\tctx = context.Background()\n-\t_, err = DefaultResolver.LookupIPAddr(ctx, \"google.com\")\n-\tif err != nil {\n-\t\ttestenv.SkipFlakyNet(t)\n-\t\tt.Fatal(err)\n+\n+\t_, err := DefaultResolver.LookupIPAddr(lookupCtx, \"google.com\")\n+\tif dnsErr, ok := err.(*DNSError); !ok || dnsErr.Err != errCanceled.Error() {\n+\t\tt.Errorf(\"unexpected error from canceled, blocked LookupIPAddr: %v\", err)\n \t}\n+\tclose(unblockLookup)\n }\n \n // Issue 24330: treat the nil *Resolver like a zero value. Verify nothing"}, {"sha": "76a9c8b1517cfbe77f1c0064787e74362661491e", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -9,7 +9,6 @@ package net\n import (\n \t\"errors\"\n \t\"fmt\"\n-\t\"internal/testenv\"\n \t\"io\"\n \t\"net/internal/socktest\"\n \t\"os\"\n@@ -515,35 +514,50 @@ func TestCloseUnblocksRead(t *testing.T) {\n \n // Issue 24808: verify that ECONNRESET is not temporary for read.\n func TestNotTemporaryRead(t *testing.T) {\n-\tif runtime.GOOS == \"freebsd\" {\n-\t\ttestenv.SkipFlaky(t, 25289)\n-\t}\n-\tif runtime.GOOS == \"aix\" {\n-\t\ttestenv.SkipFlaky(t, 29685)\n-\t}\n \tt.Parallel()\n-\tserver := func(cs *TCPConn) error {\n-\t\tcs.SetLinger(0)\n-\t\t// Give the client time to get stuck in a Read.\n-\t\ttime.Sleep(50 * time.Millisecond)\n+\n+\tln := newLocalListener(t, \"tcp\")\n+\tserverDone := make(chan struct{})\n+\tdialed := make(chan struct{})\n+\tgo func() {\n+\t\tdefer close(serverDone)\n+\n+\t\tcs, err := ln.Accept()\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\t<-dialed\n+\t\tcs.(*TCPConn).SetLinger(0)\n \t\tcs.Close()\n-\t\treturn nil\n+\n+\t\tln.Close()\n+\t}()\n+\tdefer func() { <-serverDone }()\n+\n+\tss, err := Dial(\"tcp\", ln.Addr().String())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n \t}\n-\tclient := func(ss *TCPConn) error {\n-\t\t_, err := ss.Read([]byte{0})\n-\t\tif err == nil {\n-\t\t\treturn errors.New(\"Read succeeded unexpectedly\")\n-\t\t} else if err == io.EOF {\n-\t\t\t// This happens on Plan 9.\n-\t\t\treturn nil\n-\t\t} else if ne, ok := err.(Error); !ok {\n-\t\t\treturn fmt.Errorf(\"unexpected error %v\", err)\n-\t\t} else if ne.Temporary() {\n-\t\t\treturn fmt.Errorf(\"unexpected temporary error %v\", err)\n+\tdefer ss.Close()\n+\tclose(dialed)\n+\t_, err = ss.Read([]byte{0})\n+\tif err == nil {\n+\t\tt.Fatal(\"Read succeeded unexpectedly\")\n+\t} else if err == io.EOF {\n+\t\t// This happens on Plan 9, but for some reason (prior to CL 385314) it was\n+\t\t// accepted everywhere else too.\n+\t\tif runtime.GOOS == \"plan9\" {\n+\t\t\treturn\n \t\t}\n-\t\treturn nil\n+\t\t// TODO: during an open development cycle, try making this a failure\n+\t\t// and see whether it causes the test to become flaky anywhere else.\n+\t\treturn\n+\t}\n+\tif ne, ok := err.(Error); !ok {\n+\t\tt.Errorf(\"Read error does not implement net.Error: %v\", err)\n+\t} else if ne.Temporary() {\n+\t\tt.Errorf(\"Read error is unexpectedly temporary: %v\", err)\n \t}\n-\twithTCPConnPair(t, client, server)\n }\n \n // The various errors should implement the Error interface."}, {"sha": "f27984ab574baeb967e65743ca93ea3fbc11a8e0", "filename": "libgo/go/net/netip/netip.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fnetip%2Fnetip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fnetip%2Fnetip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnetip%2Fnetip.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -1288,7 +1288,7 @@ func (p Prefix) isZero() bool { return p == Prefix{} }\n func (p Prefix) IsSingleIP() bool { return p.bits != 0 && int(p.bits) == p.ip.BitLen() }\n \n // ParsePrefix parses s as an IP address prefix.\n-// The string can be in the form \"192.168.1.0/24\" or \"2001::db8::/32\",\n+// The string can be in the form \"192.168.1.0/24\" or \"2001:db8::/32\",\n // the CIDR notation defined in RFC 4632 and RFC 4291.\n //\n // Note that masked address bits are not zeroed. Use Masked for that."}, {"sha": "7a32ef6a2e615b4cb7b88b04aced247e3993b26b", "filename": "libgo/go/net/smtp/auth.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fsmtp%2Fauth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fsmtp%2Fauth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsmtp%2Fauth.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -16,8 +16,7 @@ type Auth interface {\n \t// Start begins an authentication with a server.\n \t// It returns the name of the authentication protocol\n \t// and optionally data to include in the initial AUTH message\n-\t// sent to the server. It can return proto == \"\" to indicate\n-\t// that the authentication should be skipped.\n+\t// sent to the server.\n \t// If it returns a non-nil error, the SMTP client aborts\n \t// the authentication attempt and closes the connection.\n \tStart(server *ServerInfo) (proto string, toServer []byte, err error)"}, {"sha": "df1f7d17bc1c90d60a089f7a1a2101d89e51872a", "filename": "libgo/go/net/udpsock_test.go", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fudpsock_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fnet%2Fudpsock_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -415,19 +415,14 @@ func TestUDPReadSizeError(t *testing.T) {\n \t\tif n != len(b1) {\n \t\t\tt.Errorf(\"got %d; want %d\", n, len(b1))\n \t\t}\n-\t\tc1.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n \t\tb2 := make([]byte, len(b1)-1)\n \t\tif genericRead {\n \t\t\tn, err = c1.(Conn).Read(b2)\n \t\t} else {\n \t\t\tn, _, err = c1.ReadFrom(b2)\n \t\t}\n-\t\tswitch err {\n-\t\tcase nil: // ReadFrom succeeds\n-\t\tdefault: // Read may timeout, it depends on the platform\n-\t\t\tif nerr, ok := err.(Error); (!ok || !nerr.Timeout()) && runtime.GOOS != \"windows\" { // Windows returns WSAEMSGSIZE\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n+\t\tif err != nil && runtime.GOOS != \"windows\" { // Windows returns WSAEMSGSIZE\n+\t\t\tt.Fatal(err)\n \t\t}\n \t\tif n != len(b1)-1 {\n \t\t\tt.Fatalf(\"got %d; want %d\", n, len(b1)-1)"}, {"sha": "53e3c5227ba6480192b1379a1b12f0c56f2f673a", "filename": "libgo/go/os/example_test.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fos%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fos%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexample_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -241,3 +241,25 @@ func ExampleWriteFile() {\n \t\tlog.Fatal(err)\n \t}\n }\n+\n+func ExampleMkdir() {\n+\terr := os.Mkdir(\"testdir\", 0750)\n+\tif err != nil && !os.IsExist(err) {\n+\t\tlog.Fatal(err)\n+\t}\n+\terr = os.WriteFile(\"testdir/testfile.txt\", []byte(\"Hello, Gophers!\"), 0660)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}\n+\n+func ExampleMkdirAll() {\n+\terr := os.MkdirAll(\"test/subdir\", 0750)\n+\tif err != nil && !os.IsExist(err) {\n+\t\tlog.Fatal(err)\n+\t}\n+\terr = os.WriteFile(\"test/subdir/testfile.txt\", []byte(\"Hello, Gophers!\"), 0660)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}"}, {"sha": "59e4fb693d60faf0f787f225efb9d6e505d67d6a", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -28,6 +28,16 @@ import (\n \t\"time\"\n )\n \n+func TestMain(m *testing.M) {\n+\tif Getenv(\"GO_OS_TEST_DRAIN_STDIN\") == \"1\" {\n+\t\tos.Stdout.Close()\n+\t\tio.Copy(io.Discard, os.Stdin)\n+\t\tExit(0)\n+\t}\n+\n+\tExit(m.Run())\n+}\n+\n var dot = []string{\n \t\"dir.go\",\n \t\"env.go\",\n@@ -2261,9 +2271,18 @@ func testKillProcess(t *testing.T, processKiller func(p *Process)) {\n \ttestenv.MustHaveExec(t)\n \tt.Parallel()\n \n-\t// Re-exec the test binary itself to emulate \"sleep 1\".\n-\tcmd := osexec.Command(Args[0], \"-test.run\", \"TestSleep\")\n-\terr := cmd.Start()\n+\t// Re-exec the test binary to start a process that hangs until stdin is closed.\n+\tcmd := osexec.Command(Args[0])\n+\tcmd.Env = append(os.Environ(), \"GO_OS_TEST_DRAIN_STDIN=1\")\n+\tstdout, err := cmd.StdoutPipe()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tstdin, err := cmd.StdinPipe()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\terr = cmd.Start()\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to start test process: %v\", err)\n \t}\n@@ -2272,19 +2291,14 @@ func testKillProcess(t *testing.T, processKiller func(p *Process)) {\n \t\tif err := cmd.Wait(); err == nil {\n \t\t\tt.Errorf(\"Test process succeeded, but expected to fail\")\n \t\t}\n+\t\tstdin.Close() // Keep stdin alive until the process has finished dying.\n \t}()\n \n-\ttime.Sleep(100 * time.Millisecond)\n-\tprocessKiller(cmd.Process)\n-}\n+\t// Wait for the process to be started.\n+\t// (It will close its stdout when it reaches TestMain.)\n+\tio.Copy(io.Discard, stdout)\n \n-// TestSleep emulates \"sleep 1\". It is a helper for testKillProcess, so we\n-// don't have to rely on an external \"sleep\" command being available.\n-func TestSleep(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"Skipping in short mode\")\n-\t}\n-\ttime.Sleep(time.Second)\n+\tprocessKiller(cmd.Process)\n }\n \n func TestKillStartProcess(t *testing.T) {"}, {"sha": "3be3d13dfb9c7f4c4555ca124115aac51be61008", "filename": "libgo/go/os/tempfile.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fos%2Ftempfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fos%2Ftempfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftempfile.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -46,7 +46,7 @@ func CreateTemp(dir, pattern string) (*File, error) {\n \t\t\tif try++; try < 10000 {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\treturn nil, &PathError{Op: \"createtemp\", Path: dir + string(PathSeparator) + prefix + \"*\" + suffix, Err: ErrExist}\n+\t\t\treturn nil, &PathError{Op: \"createtemp\", Path: prefix + \"*\" + suffix, Err: ErrExist}\n \t\t}\n \t\treturn f, err\n \t}"}, {"sha": "0f6587ab27f313b7d80b6a3237f497d527e9a0c5", "filename": "libgo/go/regexp/syntax/parse.go", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -76,13 +76,29 @@ const (\n \topVerticalBar\n )\n \n+// maxHeight is the maximum height of a regexp parse tree.\n+// It is somewhat arbitrarily chosen, but the idea is to be large enough\n+// that no one will actually hit in real use but at the same time small enough\n+// that recursion on the Regexp tree will not hit the 1GB Go stack limit.\n+// The maximum amount of stack for a single recursive frame is probably\n+// closer to 1kB, so this could potentially be raised, but it seems unlikely\n+// that people have regexps nested even this deeply.\n+// We ran a test on Google's C++ code base and turned up only\n+// a single use case with depth > 100; it had depth 128.\n+// Using depth 1000 should be plenty of margin.\n+// As an optimization, we don't even bother calculating heights\n+// until we've allocated at least maxHeight Regexp structures.\n+const maxHeight = 1000\n+\n type parser struct {\n \tflags       Flags     // parse mode flags\n \tstack       []*Regexp // stack of parsed expressions\n \tfree        *Regexp\n \tnumCap      int // number of capturing groups seen\n \twholeRegexp string\n-\ttmpClass    []rune // temporary char class work space\n+\ttmpClass    []rune          // temporary char class work space\n+\tnumRegexp   int             // number of regexps allocated\n+\theight      map[*Regexp]int // regexp height for height limit check\n }\n \n func (p *parser) newRegexp(op Op) *Regexp {\n@@ -92,16 +108,52 @@ func (p *parser) newRegexp(op Op) *Regexp {\n \t\t*re = Regexp{}\n \t} else {\n \t\tre = new(Regexp)\n+\t\tp.numRegexp++\n \t}\n \tre.Op = op\n \treturn re\n }\n \n func (p *parser) reuse(re *Regexp) {\n+\tif p.height != nil {\n+\t\tdelete(p.height, re)\n+\t}\n \tre.Sub0[0] = p.free\n \tp.free = re\n }\n \n+func (p *parser) checkHeight(re *Regexp) {\n+\tif p.numRegexp < maxHeight {\n+\t\treturn\n+\t}\n+\tif p.height == nil {\n+\t\tp.height = make(map[*Regexp]int)\n+\t\tfor _, re := range p.stack {\n+\t\t\tp.checkHeight(re)\n+\t\t}\n+\t}\n+\tif p.calcHeight(re, true) > maxHeight {\n+\t\tpanic(ErrInternalError)\n+\t}\n+}\n+\n+func (p *parser) calcHeight(re *Regexp, force bool) int {\n+\tif !force {\n+\t\tif h, ok := p.height[re]; ok {\n+\t\t\treturn h\n+\t\t}\n+\t}\n+\th := 1\n+\tfor _, sub := range re.Sub {\n+\t\thsub := p.calcHeight(sub, false)\n+\t\tif h < 1+hsub {\n+\t\t\th = 1 + hsub\n+\t\t}\n+\t}\n+\tp.height[re] = h\n+\treturn h\n+}\n+\n // Parse stack manipulation.\n \n // push pushes the regexp re onto the parse stack and returns the regexp.\n@@ -137,6 +189,7 @@ func (p *parser) push(re *Regexp) *Regexp {\n \t}\n \n \tp.stack = append(p.stack, re)\n+\tp.checkHeight(re)\n \treturn re\n }\n \n@@ -246,6 +299,7 @@ func (p *parser) repeat(op Op, min, max int, before, after, lastRepeat string) (\n \tre.Sub = re.Sub0[:1]\n \tre.Sub[0] = sub\n \tp.stack[n-1] = re\n+\tp.checkHeight(re)\n \n \tif op == OpRepeat && (min >= 2 || max >= 2) && !repeatIsValid(re, 1000) {\n \t\treturn \"\", &Error{ErrInvalidRepeatSize, before[:len(before)-len(after)]}\n@@ -693,6 +747,21 @@ func literalRegexp(s string, flags Flags) *Regexp {\n // Flags, and returns a regular expression parse tree. The syntax is\n // described in the top-level comment.\n func Parse(s string, flags Flags) (*Regexp, error) {\n+\treturn parse(s, flags)\n+}\n+\n+func parse(s string, flags Flags) (_ *Regexp, err error) {\n+\tdefer func() {\n+\t\tswitch r := recover(); r {\n+\t\tdefault:\n+\t\t\tpanic(r)\n+\t\tcase nil:\n+\t\t\t// ok\n+\t\tcase ErrInternalError:\n+\t\t\terr = &Error{Code: ErrInternalError, Expr: s}\n+\t\t}\n+\t}()\n+\n \tif flags&Literal != 0 {\n \t\t// Trivial parser for literal string.\n \t\tif err := checkUTF8(s); err != nil {\n@@ -704,7 +773,6 @@ func Parse(s string, flags Flags) (*Regexp, error) {\n \t// Otherwise, must do real work.\n \tvar (\n \t\tp          parser\n-\t\terr        error\n \t\tc          rune\n \t\top         Op\n \t\tlastRepeat string"}, {"sha": "1ef6d8a3fe09ba9034fef1c2a4dda6c7784c2d26", "filename": "libgo/go/regexp/syntax/parse_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -207,6 +207,11 @@ var parseTests = []parseTest{\n \t// Valid repetitions.\n \t{`((((((((((x{2}){2}){2}){2}){2}){2}){2}){2}){2}))`, ``},\n \t{`((((((((((x{1}){2}){2}){2}){2}){2}){2}){2}){2}){2})`, ``},\n+\n+\t// Valid nesting.\n+\t{strings.Repeat(\"(\", 999) + strings.Repeat(\")\", 999), ``},\n+\t{strings.Repeat(\"(?:\", 999) + strings.Repeat(\")*\", 999), ``},\n+\t{\"(\" + strings.Repeat(\"|\", 12345) + \")\", ``}, // not nested at all\n }\n \n const testFlags = MatchNL | PerlX | UnicodeGroups\n@@ -482,6 +487,8 @@ var invalidRegexps = []string{\n \t`a{100000}`,\n \t`a{100000,}`,\n \t\"((((((((((x{2}){2}){2}){2}){2}){2}){2}){2}){2}){2})\",\n+\tstrings.Repeat(\"(\", 1000) + strings.Repeat(\")\", 1000),\n+\tstrings.Repeat(\"(?:\", 1000) + strings.Repeat(\")*\", 1000),\n \t`\\Q\\E*`,\n }\n "}, {"sha": "7344a938bc6d1f572e478a300d8bbc6f63e7b47a", "filename": "libgo/go/runtime/crash_cgo_test.go", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -216,6 +216,19 @@ func TestCgoCCodeSIGPROF(t *testing.T) {\n \t}\n }\n \n+func TestCgoPprofCallback(t *testing.T) {\n+\tt.Parallel()\n+\tswitch runtime.GOOS {\n+\tcase \"windows\", \"plan9\":\n+\t\tt.Skipf(\"skipping cgo pprof callback test on %s\", runtime.GOOS)\n+\t}\n+\tgot := runTestProg(t, \"testprogcgo\", \"CgoPprofCallback\")\n+\twant := \"OK\\n\"\n+\tif got != want {\n+\t\tt.Errorf(\"expected %q got %v\", want, got)\n+\t}\n+}\n+\n func TestCgoCrashTraceback(t *testing.T) {\n \tt.Parallel()\n \tswitch platform := runtime.GOOS + \"/\" + runtime.GOARCH; platform {\n@@ -614,6 +627,9 @@ func TestSegv(t *testing.T) {\n \t\t\tt.Log(got)\n \t\t\twant := \"SIGSEGV\"\n \t\t\tif !strings.Contains(got, want) {\n+\t\t\t\tif runtime.GOOS == \"darwin\" && runtime.GOARCH == \"amd64\" && strings.Contains(got, \"fatal: morestack on g0\") {\n+\t\t\t\t\ttestenv.SkipFlaky(t, 39457)\n+\t\t\t\t}\n \t\t\t\tt.Errorf(\"did not see %q in output\", want)\n \t\t\t}\n \n@@ -628,13 +644,11 @@ func TestSegv(t *testing.T) {\n \t\t\t\t\t// a VDSO call via asmcgocall.\n \t\t\t\t\ttestenv.SkipFlaky(t, 50504)\n \t\t\t\t}\n-\t\t\t\tif testenv.Builder() == \"linux-mips64le-mengzhuo\" && strings.Contains(got, \"runtime: unknown pc\") {\n-\t\t\t\t\t// Runtime sometimes throw \"unknown pc\" when generating the traceback.\n-\t\t\t\t\t// Curiously, that doesn't seem to happen on the linux-mips64le-rtrk\n-\t\t\t\t\t// builder.\n-\t\t\t\t\ttestenv.SkipFlaky(t, 50605)\n-\t\t\t\t}\n \t\t\t}\n+\t\t\tif test == \"SegvInCgo\" && strings.Contains(got, \"runtime: unknown pc\") {\n+\t\t\t\ttestenv.SkipFlaky(t, 50979)\n+\t\t\t}\n+\n \t\t\tnowant := \"runtime: \"\n \t\t\tif strings.Contains(got, nowant) {\n \t\t\t\tt.Errorf(\"unexpectedly saw %q in output\", nowant)"}, {"sha": "ab94affe97f74743240c09f73330621333cc8ef7", "filename": "libgo/go/runtime/crash_unix_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -132,7 +132,7 @@ func TestCrashDumpsAllThreads(t *testing.T) {\n \tout := outbuf.Bytes()\n \tn := bytes.Count(out, []byte(\"main.crashDumpsAllThreadsLoop\"))\n \tif n != 4 {\n-\t\tt.Errorf(\"found %d instances of main.loop; expected 4\", n)\n+\t\tt.Errorf(\"found %d instances of main.crashDumpsAllThreadsLoop; expected 4\", n)\n \t\tt.Logf(\"%s\", out)\n \t}\n }"}, {"sha": "5184a028ea66558d736e8455eacf52416a351144", "filename": "libgo/go/runtime/debug/mod.go", "status": "modified", "additions": 106, "deletions": 51, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fdebug%2Fmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fdebug%2Fmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug%2Fmod.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -5,9 +5,9 @@\n package debug\n \n import (\n-\t\"bytes\"\n \t\"fmt\"\n \t\"runtime\"\n+\t\"strconv\"\n \t\"strings\"\n \t_ \"unsafe\" // for go:linkname\n )\n@@ -24,8 +24,8 @@ func ReadBuildInfo() (info *BuildInfo, ok bool) {\n \t\treturn nil, false\n \t}\n \tdata = data[16 : len(data)-16]\n-\tbi := &BuildInfo{}\n-\tif err := bi.UnmarshalText([]byte(data)); err != nil {\n+\tbi, err := ParseBuildInfo(data)\n+\tif err != nil {\n \t\treturn nil, false\n \t}\n \n@@ -64,8 +64,18 @@ type BuildSetting struct {\n \tKey, Value string\n }\n \n-func (bi *BuildInfo) MarshalText() ([]byte, error) {\n-\tbuf := &bytes.Buffer{}\n+// quoteKey reports whether key is required to be quoted.\n+func quoteKey(key string) bool {\n+\treturn len(key) == 0 || strings.ContainsAny(key, \"= \\t\\r\\n\\\"`\")\n+}\n+\n+// quoteValue reports whether value is required to be quoted.\n+func quoteValue(value string) bool {\n+\treturn strings.ContainsAny(value, \" \\t\\r\\n\\\"`\")\n+}\n+\n+func (bi *BuildInfo) String() string {\n+\tbuf := new(strings.Builder)\n \tif bi.GoVersion != \"\" {\n \t\tfmt.Fprintf(buf, \"go\\t%s\\n\", bi.GoVersion)\n \t}\n@@ -77,12 +87,8 @@ func (bi *BuildInfo) MarshalText() ([]byte, error) {\n \t\tbuf.WriteString(word)\n \t\tbuf.WriteByte('\\t')\n \t\tbuf.WriteString(m.Path)\n-\t\tmv := m.Version\n-\t\tif mv == \"\" {\n-\t\t\tmv = \"(devel)\"\n-\t\t}\n \t\tbuf.WriteByte('\\t')\n-\t\tbuf.WriteString(mv)\n+\t\tbuf.WriteString(m.Version)\n \t\tif m.Replace == nil {\n \t\t\tbuf.WriteByte('\\t')\n \t\t\tbuf.WriteString(m.Sum)\n@@ -92,27 +98,28 @@ func (bi *BuildInfo) MarshalText() ([]byte, error) {\n \t\t}\n \t\tbuf.WriteByte('\\n')\n \t}\n-\tif bi.Main.Path != \"\" {\n+\tif bi.Main != (Module{}) {\n \t\tformatMod(\"mod\", bi.Main)\n \t}\n \tfor _, dep := range bi.Deps {\n \t\tformatMod(\"dep\", *dep)\n \t}\n \tfor _, s := range bi.Settings {\n-\t\tif strings.ContainsAny(s.Key, \"= \\t\\n\") {\n-\t\t\treturn nil, fmt.Errorf(\"invalid build setting key %q\", s.Key)\n+\t\tkey := s.Key\n+\t\tif quoteKey(key) {\n+\t\t\tkey = strconv.Quote(key)\n \t\t}\n-\t\tif strings.Contains(s.Value, \"\\n\") {\n-\t\t\treturn nil, fmt.Errorf(\"invalid build setting value for key %q: contains newline\", s.Value)\n+\t\tvalue := s.Value\n+\t\tif quoteValue(value) {\n+\t\t\tvalue = strconv.Quote(value)\n \t\t}\n-\t\tfmt.Fprintf(buf, \"build\\t%s=%s\\n\", s.Key, s.Value)\n+\t\tfmt.Fprintf(buf, \"build\\t%s=%s\\n\", key, value)\n \t}\n \n-\treturn buf.Bytes(), nil\n+\treturn buf.String()\n }\n \n-func (bi *BuildInfo) UnmarshalText(data []byte) (err error) {\n-\t*bi = BuildInfo{}\n+func ParseBuildInfo(data string) (bi *BuildInfo, err error) {\n \tlineNum := 1\n \tdefer func() {\n \t\tif err != nil {\n@@ -121,85 +128,133 @@ func (bi *BuildInfo) UnmarshalText(data []byte) (err error) {\n \t}()\n \n \tvar (\n-\t\tpathLine  = []byte(\"path\\t\")\n-\t\tmodLine   = []byte(\"mod\\t\")\n-\t\tdepLine   = []byte(\"dep\\t\")\n-\t\trepLine   = []byte(\"=>\\t\")\n-\t\tbuildLine = []byte(\"build\\t\")\n-\t\tnewline   = []byte(\"\\n\")\n-\t\ttab       = []byte(\"\\t\")\n+\t\tpathLine  = \"path\\t\"\n+\t\tmodLine   = \"mod\\t\"\n+\t\tdepLine   = \"dep\\t\"\n+\t\trepLine   = \"=>\\t\"\n+\t\tbuildLine = \"build\\t\"\n+\t\tnewline   = \"\\n\"\n+\t\ttab       = \"\\t\"\n \t)\n \n-\treadModuleLine := func(elem [][]byte) (Module, error) {\n+\treadModuleLine := func(elem []string) (Module, error) {\n \t\tif len(elem) != 2 && len(elem) != 3 {\n \t\t\treturn Module{}, fmt.Errorf(\"expected 2 or 3 columns; got %d\", len(elem))\n \t\t}\n+\t\tversion := elem[1]\n \t\tsum := \"\"\n \t\tif len(elem) == 3 {\n-\t\t\tsum = string(elem[2])\n+\t\t\tsum = elem[2]\n \t\t}\n \t\treturn Module{\n-\t\t\tPath:    string(elem[0]),\n-\t\t\tVersion: string(elem[1]),\n+\t\t\tPath:    elem[0],\n+\t\t\tVersion: version,\n \t\t\tSum:     sum,\n \t\t}, nil\n \t}\n \n+\tbi = new(BuildInfo)\n \tvar (\n \t\tlast *Module\n-\t\tline []byte\n+\t\tline string\n \t\tok   bool\n \t)\n \t// Reverse of BuildInfo.String(), except for go version.\n \tfor len(data) > 0 {\n-\t\tline, data, ok = bytes.Cut(data, newline)\n+\t\tline, data, ok = strings.Cut(data, newline)\n \t\tif !ok {\n \t\t\tbreak\n \t\t}\n \t\tswitch {\n-\t\tcase bytes.HasPrefix(line, pathLine):\n+\t\tcase strings.HasPrefix(line, pathLine):\n \t\t\telem := line[len(pathLine):]\n \t\t\tbi.Path = string(elem)\n-\t\tcase bytes.HasPrefix(line, modLine):\n-\t\t\telem := bytes.Split(line[len(modLine):], tab)\n+\t\tcase strings.HasPrefix(line, modLine):\n+\t\t\telem := strings.Split(line[len(modLine):], tab)\n \t\t\tlast = &bi.Main\n \t\t\t*last, err = readModuleLine(elem)\n \t\t\tif err != nil {\n-\t\t\t\treturn err\n+\t\t\t\treturn nil, err\n \t\t\t}\n-\t\tcase bytes.HasPrefix(line, depLine):\n-\t\t\telem := bytes.Split(line[len(depLine):], tab)\n+\t\tcase strings.HasPrefix(line, depLine):\n+\t\t\telem := strings.Split(line[len(depLine):], tab)\n \t\t\tlast = new(Module)\n \t\t\tbi.Deps = append(bi.Deps, last)\n \t\t\t*last, err = readModuleLine(elem)\n \t\t\tif err != nil {\n-\t\t\t\treturn err\n+\t\t\t\treturn nil, err\n \t\t\t}\n-\t\tcase bytes.HasPrefix(line, repLine):\n-\t\t\telem := bytes.Split(line[len(repLine):], tab)\n+\t\tcase strings.HasPrefix(line, repLine):\n+\t\t\telem := strings.Split(line[len(repLine):], tab)\n \t\t\tif len(elem) != 3 {\n-\t\t\t\treturn fmt.Errorf(\"expected 3 columns for replacement; got %d\", len(elem))\n+\t\t\t\treturn nil, fmt.Errorf(\"expected 3 columns for replacement; got %d\", len(elem))\n \t\t\t}\n \t\t\tif last == nil {\n-\t\t\t\treturn fmt.Errorf(\"replacement with no module on previous line\")\n+\t\t\t\treturn nil, fmt.Errorf(\"replacement with no module on previous line\")\n \t\t\t}\n \t\t\tlast.Replace = &Module{\n \t\t\t\tPath:    string(elem[0]),\n \t\t\t\tVersion: string(elem[1]),\n \t\t\t\tSum:     string(elem[2]),\n \t\t\t}\n \t\t\tlast = nil\n-\t\tcase bytes.HasPrefix(line, buildLine):\n-\t\t\tkey, val, ok := strings.Cut(string(line[len(buildLine):]), \"=\")\n-\t\t\tif !ok {\n-\t\t\t\treturn fmt.Errorf(\"invalid build line\")\n+\t\tcase strings.HasPrefix(line, buildLine):\n+\t\t\tkv := line[len(buildLine):]\n+\t\t\tif len(kv) < 1 {\n+\t\t\t\treturn nil, fmt.Errorf(\"build line missing '='\")\n+\t\t\t}\n+\n+\t\t\tvar key, rawValue string\n+\t\t\tswitch kv[0] {\n+\t\t\tcase '=':\n+\t\t\t\treturn nil, fmt.Errorf(\"build line with missing key\")\n+\n+\t\t\tcase '`', '\"':\n+\t\t\t\trawKey, err := strconv.QuotedPrefix(kv)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"invalid quoted key in build line\")\n+\t\t\t\t}\n+\t\t\t\tif len(kv) == len(rawKey) {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"build line missing '=' after quoted key\")\n+\t\t\t\t}\n+\t\t\t\tif c := kv[len(rawKey)]; c != '=' {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"unexpected character after quoted key: %q\", c)\n+\t\t\t\t}\n+\t\t\t\tkey, _ = strconv.Unquote(rawKey)\n+\t\t\t\trawValue = kv[len(rawKey)+1:]\n+\n+\t\t\tdefault:\n+\t\t\t\tvar ok bool\n+\t\t\t\tkey, rawValue, ok = strings.Cut(kv, \"=\")\n+\t\t\t\tif !ok {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"build line missing '=' after key\")\n+\t\t\t\t}\n+\t\t\t\tif quoteKey(key) {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"unquoted key %q must be quoted\", key)\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tif key == \"\" {\n-\t\t\t\treturn fmt.Errorf(\"empty key\")\n+\n+\t\t\tvar value string\n+\t\t\tif len(rawValue) > 0 {\n+\t\t\t\tswitch rawValue[0] {\n+\t\t\t\tcase '`', '\"':\n+\t\t\t\t\tvar err error\n+\t\t\t\t\tvalue, err = strconv.Unquote(rawValue)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn nil, fmt.Errorf(\"invalid quoted value in build line\")\n+\t\t\t\t\t}\n+\n+\t\t\t\tdefault:\n+\t\t\t\t\tvalue = rawValue\n+\t\t\t\t\tif quoteValue(value) {\n+\t\t\t\t\t\treturn nil, fmt.Errorf(\"unquoted value %q must be quoted\", value)\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tbi.Settings = append(bi.Settings, BuildSetting{Key: key, Value: val})\n+\n+\t\t\tbi.Settings = append(bi.Settings, BuildSetting{Key: key, Value: value})\n \t\t}\n \t\tlineNum++\n \t}\n-\treturn nil\n+\treturn bi, nil\n }"}, {"sha": "b2917692f4459d9ab1645ed1182999a59dc943b9", "filename": "libgo/go/runtime/debug/mod_test.go", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fdebug%2Fmod_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fdebug%2Fmod_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug%2Fmod_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package debug_test\n+\n+import (\n+\t\"reflect\"\n+\t\"runtime/debug\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+// strip removes two leading tabs after each newline of s.\n+func strip(s string) string {\n+\treplaced := strings.ReplaceAll(s, \"\\n\\t\\t\", \"\\n\")\n+\tif len(replaced) > 0 && replaced[0] == '\\n' {\n+\t\treplaced = replaced[1:]\n+\t}\n+\treturn replaced\n+}\n+\n+func FuzzParseBuildInfoRoundTrip(f *testing.F) {\n+\t// Package built from outside a module, missing some fields..\n+\tf.Add(strip(`\n+\t\tpath\trsc.io/fortune\n+\t\tmod\trsc.io/fortune\tv1.0.0\n+\t\t`))\n+\n+\t// Package built from the standard library, missing some fields..\n+\tf.Add(`path\tcmd/test2json`)\n+\n+\t// Package built from inside a module.\n+\tf.Add(strip(`\n+\t\tgo\t1.18\n+\t\tpath\texample.com/m\n+\t\tmod\texample.com/m\t(devel)\t\n+\t\tbuild\t-compiler=gc\n+\t\t`))\n+\n+\t// Package built in GOPATH mode.\n+\tf.Add(strip(`\n+\t\tgo\t1.18\n+\t\tpath\texample.com/m\n+\t\tbuild\t-compiler=gc\n+\t\t`))\n+\n+\t// Escaped build info.\n+\tf.Add(strip(`\n+\t\tgo 1.18\n+\t\tpath example.com/m\n+\t\tbuild CRAZY_ENV=\"requires\\nescaping\"\n+\t\t`))\n+\n+\tf.Fuzz(func(t *testing.T, s string) {\n+\t\tbi, err := debug.ParseBuildInfo(s)\n+\t\tif err != nil {\n+\t\t\t// Not a round-trippable BuildInfo string.\n+\t\t\tt.Log(err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// s2 could have different escaping from s.\n+\t\t// However, it should parse to exactly the same contents.\n+\t\ts2 := bi.String()\n+\t\tbi2, err := debug.ParseBuildInfo(s2)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"%v:\\n%s\", err, s2)\n+\t\t}\n+\n+\t\tif !reflect.DeepEqual(bi2, bi) {\n+\t\t\tt.Fatalf(\"Parsed representation differs.\\ninput:\\n%s\\noutput:\\n%s\", s, s2)\n+\t\t}\n+\t})\n+}"}, {"sha": "85d6f61851202900c303b8b89b4d6a320be3743b", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -1202,6 +1202,8 @@ func (th *TimeHistogram) Record(duration int64) {\n \n var Pusestackmaps = &usestackmaps\n \n+var TimeHistogramMetricsBuckets = timeHistogramMetricsBuckets\n+\n func FinalizerGAsleep() bool {\n \tlock(&finlock)\n \tresult := fingwait\n@@ -1318,3 +1320,21 @@ func Releasem() {\n }\n \n var Timediv = timediv\n+\n+type PIController struct {\n+\tpiController\n+}\n+\n+func NewPIController(kp, ti, tt, min, max float64) *PIController {\n+\treturn &PIController{piController{\n+\t\tkp:  kp,\n+\t\tti:  ti,\n+\t\ttt:  tt,\n+\t\tmin: min,\n+\t\tmax: max,\n+\t}}\n+}\n+\n+func (c *PIController) Next(input, setpoint, period float64) (float64, bool) {\n+\treturn c.piController.next(input, setpoint, period)\n+}"}, {"sha": "cd7e29a8c8be87f96d7b33c17426ad48b5a63579", "filename": "libgo/go/runtime/histogram.go", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fhistogram.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fhistogram.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhistogram.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -47,7 +47,7 @@ const (\n \t//    \u2502  \u2514---- Next 4 bits -> sub-bucket 1\n \t//    \u2514------- Bit 5 set -> super-bucket 2\n \t//\n-\t// Following this pattern, bucket 45 will have the bit 48 set. We don't\n+\t// Following this pattern, super-bucket 44 will have the bit 47 set. We don't\n \t// have any buckets for higher values, so the highest sub-bucket will\n \t// contain values of 2^48-1 nanoseconds or approx. 3 days. This range is\n \t// more than enough to handle durations produced by the runtime.\n@@ -139,36 +139,30 @@ func float64NegInf() float64 {\n func timeHistogramMetricsBuckets() []float64 {\n \tb := make([]float64, timeHistTotalBuckets+1)\n \tb[0] = float64NegInf()\n-\tfor i := 0; i < timeHistNumSuperBuckets; i++ {\n-\t\tsuperBucketMin := uint64(0)\n-\t\t// The (inclusive) minimum for the first non-negative bucket is 0.\n-\t\tif i > 0 {\n-\t\t\t// The minimum for the second bucket will be\n-\t\t\t// 1 << timeHistSubBucketBits, indicating that all\n-\t\t\t// sub-buckets are represented by the next timeHistSubBucketBits\n-\t\t\t// bits.\n-\t\t\t// Thereafter, we shift up by 1 each time, so we can represent\n-\t\t\t// this pattern as (i-1)+timeHistSubBucketBits.\n-\t\t\tsuperBucketMin = uint64(1) << uint(i-1+timeHistSubBucketBits)\n-\t\t}\n-\t\t// subBucketShift is the amount that we need to shift the sub-bucket\n-\t\t// index to combine it with the bucketMin.\n-\t\tsubBucketShift := uint(0)\n-\t\tif i > 1 {\n-\t\t\t// The first two super buckets are exact with respect to integers,\n-\t\t\t// so we'll never have to shift the sub-bucket index. Thereafter,\n-\t\t\t// we shift up by 1 with each subsequent bucket.\n-\t\t\tsubBucketShift = uint(i - 2)\n-\t\t}\n+\t// Super-bucket 0 has no bits above timeHistSubBucketBits\n+\t// set, so just iterate over each bucket and assign the\n+\t// incrementing bucket.\n+\tfor i := 0; i < timeHistNumSubBuckets; i++ {\n+\t\tbucketNanos := uint64(i)\n+\t\tb[i+1] = float64(bucketNanos) / 1e9\n+\t}\n+\t// Generate the rest of the super-buckets. It's easier to reason\n+\t// about if we cut out the 0'th bucket, so subtract one since\n+\t// we just handled that bucket.\n+\tfor i := 0; i < timeHistNumSuperBuckets-1; i++ {\n \t\tfor j := 0; j < timeHistNumSubBuckets; j++ {\n-\t\t\t// j is the sub-bucket index. By shifting the index into position to\n-\t\t\t// combine with the bucket minimum, we obtain the minimum value for that\n-\t\t\t// sub-bucket.\n-\t\t\tsubBucketMin := superBucketMin + (uint64(j) << subBucketShift)\n-\n-\t\t\t// Convert the subBucketMin which is in nanoseconds to a float64 seconds value.\n+\t\t\t// Set the super-bucket bit.\n+\t\t\tbucketNanos := uint64(1) << (i + timeHistSubBucketBits)\n+\t\t\t// Set the sub-bucket bits.\n+\t\t\tbucketNanos |= uint64(j) << i\n+\t\t\t// The index for this bucket is going to be the (i+1)'th super bucket\n+\t\t\t// (note that we're starting from zero, but handled the first super-bucket\n+\t\t\t// earlier, so we need to compensate), and the j'th sub bucket.\n+\t\t\t// Add 1 because we left space for -Inf.\n+\t\t\tbucketIndex := (i+1)*timeHistNumSubBuckets + j + 1\n+\t\t\t// Convert nanoseconds to seconds via a division.\n \t\t\t// These values will all be exactly representable by a float64.\n-\t\t\tb[i*timeHistNumSubBuckets+j+1] = float64(subBucketMin) / 1e9\n+\t\t\tb[bucketIndex] = float64(bucketNanos) / 1e9\n \t\t}\n \t}\n \tb[len(b)-1] = float64Inf()"}, {"sha": "b12b65a41e36e932a645e50d6f00691f552ee22c", "filename": "libgo/go/runtime/histogram_test.go", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fhistogram_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fhistogram_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhistogram_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -68,3 +68,43 @@ func TestTimeHistogram(t *testing.T) {\n \n \tdummyTimeHistogram = TimeHistogram{}\n }\n+\n+func TestTimeHistogramMetricsBuckets(t *testing.T) {\n+\tbuckets := TimeHistogramMetricsBuckets()\n+\n+\tnonInfBucketsLen := TimeHistNumSubBuckets * TimeHistNumSuperBuckets\n+\texpBucketsLen := nonInfBucketsLen + 2 // Count -Inf and +Inf.\n+\tif len(buckets) != expBucketsLen {\n+\t\tt.Fatalf(\"unexpected length of buckets: got %d, want %d\", len(buckets), expBucketsLen)\n+\t}\n+\t// Check the first non-Inf 2*TimeHistNumSubBuckets buckets in order, skipping the\n+\t// first bucket which should be -Inf (checked later).\n+\t//\n+\t// Because of the way this scheme works, the bottom TimeHistNumSubBuckets\n+\t// buckets are fully populated, and then the next TimeHistNumSubBuckets\n+\t// have the TimeHistSubBucketBits'th bit set, while the bottom are once\n+\t// again fully populated.\n+\tfor i := 1; i <= 2*TimeHistNumSubBuckets+1; i++ {\n+\t\tif got, want := buckets[i], float64(i-1)/1e9; got != want {\n+\t\t\tt.Errorf(\"expected bucket %d to have value %e, got %e\", i, want, got)\n+\t\t}\n+\t}\n+\t// Check some values.\n+\tidxToBucket := map[int]float64{\n+\t\t0:                 math.Inf(-1),\n+\t\t33:                float64(0x10<<1) / 1e9,\n+\t\t34:                float64(0x11<<1) / 1e9,\n+\t\t49:                float64(0x10<<2) / 1e9,\n+\t\t58:                float64(0x19<<2) / 1e9,\n+\t\t65:                float64(0x10<<3) / 1e9,\n+\t\t513:               float64(0x10<<31) / 1e9,\n+\t\t519:               float64(0x16<<31) / 1e9,\n+\t\texpBucketsLen - 2: float64(0x1f<<43) / 1e9,\n+\t\texpBucketsLen - 1: math.Inf(1),\n+\t}\n+\tfor idx, bucket := range idxToBucket {\n+\t\tif got, want := buckets[idx], bucket; got != want {\n+\t\t\tt.Errorf(\"expected bucket %d to have value %e, got %e\", idx, want, got)\n+\t\t}\n+\t}\n+}"}, {"sha": "2bc59007b3112f4f2e8a68896e45976cdfe73488", "filename": "libgo/go/runtime/internal/syscall/errno.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Finternal%2Fsyscall%2Ferrno.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Finternal%2Fsyscall%2Ferrno.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Finternal%2Fsyscall%2Ferrno.c?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,27 @@\n+/* errno.c -- functions for getting and setting errno\n+\n+   Copyright 2022 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+#include <errno.h>\n+#include <stdint.h>\n+\n+#include \"runtime.h\"\n+\n+/* errno is typically a macro. These functions set and get errno\n+   specific to the libc being used.  */\n+\n+uintptr_t getErrno(void) __asm__ (GOSYM_PREFIX \"runtime_1internal_1syscall.getErrno\");\n+void setErrno(uintptr_t) __asm__ (GOSYM_PREFIX \"runtime_1internal_1syscall.setErrno\");\n+\n+uintptr_t\n+getErrno(void)\n+{\n+  return (uintptr_t) errno;\n+}\n+\n+void\n+setErrno(uintptr_t value)\n+{\n+  errno = (int) value;\n+}"}, {"sha": "a4e935845a33abf08b8b8a1a79add1804c257810", "filename": "libgo/go/runtime/internal/syscall/syscall_linux.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Finternal%2Fsyscall%2Fsyscall_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Finternal%2Fsyscall%2Fsyscall_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Finternal%2Fsyscall%2Fsyscall_linux.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package syscall provides the syscall primitives required for the runtime.\n+package syscall\n+\n+// TODO(https://go.dev/issue/51087): This package is incomplete and currently\n+// only contains very minimal support for Linux.\n+\n+//extern __go_syscall6\n+func syscall6(num uintptr, a1, a2, a3, a4, a5, a6 uintptr) uintptr\n+\n+func getErrno() uintptr\n+func setErrno(uintptr)\n+\n+// Syscall6 calls system call number 'num' with arguments a1-6.\n+func Syscall6(num, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, errno uintptr) {\n+\tsetErrno(0)\n+\tr := syscall6(num, a1, a2, a3, a4, a5, a6)\n+\terrno = getErrno()\n+\treturn r, 0, errno\n+}"}, {"sha": "94eebc996b96a89224e67027ee1b687b02512807", "filename": "libgo/go/runtime/mbarrier.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmbarrier.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmbarrier.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmbarrier.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -204,7 +204,7 @@ func reflectlite_typedmemmove(typ *_type, dst, src unsafe.Pointer) {\n \n // typedmemmovepartial is like typedmemmove but assumes that\n // dst and src point off bytes into the value and only copies size bytes.\n-// off must be a multiple of sys.PtrSize.\n+// off must be a multiple of goarch.PtrSize.\n //go:linkname reflect_typedmemmovepartial reflect.typedmemmovepartial\n func reflect_typedmemmovepartial(typ *_type, dst, src unsafe.Pointer, off, size uintptr) {\n \tif writeBarrier.needed && typ.ptrdata > off && size >= goarch.PtrSize {"}, {"sha": "33cfa7276b4b8260d2525bb7032a3329bf4dc7da", "filename": "libgo/go/runtime/mbitmap.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmbitmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmbitmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmbitmap.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -862,7 +862,7 @@ func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {\n \t// size is sizeof(_defer{}) (at least 6 words) and dataSize may be\n \t// arbitrarily larger.\n \t//\n-\t// The checks for size == sys.PtrSize and size == 2*sys.PtrSize can therefore\n+\t// The checks for size == goarch.PtrSize and size == 2*goarch.PtrSize can therefore\n \t// assume that dataSize == size without checking it explicitly.\n \n \tif goarch.PtrSize == 8 && size == goarch.PtrSize {\n@@ -912,7 +912,7 @@ func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {\n \t\t\t}\n \t\t\treturn\n \t\t}\n-\t\t// Otherwise typ.size must be 2*sys.PtrSize,\n+\t\t// Otherwise typ.size must be 2*goarch.PtrSize,\n \t\t// and typ.kind&kindGCProg == 0.\n \t\tif doubleCheck {\n \t\t\tif typ.size != 2*goarch.PtrSize || typ.kind&kindGCProg != 0 {\n@@ -1114,8 +1114,8 @@ func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {\n \t\t\t// Replicate ptrmask to fill entire pbits uintptr.\n \t\t\t// Doubling and truncating is fewer steps than\n \t\t\t// iterating by nb each time. (nb could be 1.)\n-\t\t\t// Since we loaded typ.ptrdata/sys.PtrSize bits\n-\t\t\t// but are pretending to have typ.size/sys.PtrSize,\n+\t\t\t// Since we loaded typ.ptrdata/goarch.PtrSize bits\n+\t\t\t// but are pretending to have typ.size/goarch.PtrSize,\n \t\t\t// there might be no replication necessary/possible.\n \t\t\tpbits = b\n \t\t\tendnb = nb\n@@ -1583,7 +1583,7 @@ func heapBitsSetTypeGCProg(h heapBits, progSize, elemSize, dataSize, allocSize u\n \n // progToPointerMask returns the 1-bit pointer mask output by the GC program prog.\n // size the size of the region described by prog, in bytes.\n-// The resulting bitvector will have no more than size/sys.PtrSize bits.\n+// The resulting bitvector will have no more than size/goarch.PtrSize bits.\n func progToPointerMask(prog *byte, size uintptr) bitvector {\n \tn := (size/goarch.PtrSize + 7) / 8\n \tx := (*[1 << 30]byte)(persistentalloc(n+1, 1, &memstats.buckhash_sys))[:n+1]\n@@ -1716,7 +1716,7 @@ Run:\n \t\t// into a register and use that register for the entire loop\n \t\t// instead of repeatedly reading from memory.\n \t\t// Handling fewer than 8 bits here makes the general loop simpler.\n-\t\t// The cutoff is sys.PtrSize*8 - 7 to guarantee that when we add\n+\t\t// The cutoff is goarch.PtrSize*8 - 7 to guarantee that when we add\n \t\t// the pattern to a bit buffer holding at most 7 bits (a partial byte)\n \t\t// it will not overflow.\n \t\tsrc := dst"}, {"sha": "3b568dd488d2daf5b89dde9852bea67a8dde6b0f", "filename": "libgo/go/runtime/mgcmark.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmgcmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmgcmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcmark.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -338,7 +338,7 @@ func markrootSpans(gcw *gcWork, shard int) {\n }\n \n // gcAssistAlloc performs GC work to make gp's assist debt positive.\n-// gp must be the calling user gorountine.\n+// gp must be the calling user goroutine.\n //\n // This must be called with preemption enabled.\n func gcAssistAlloc(gp *g) {"}, {"sha": "0fff13c1b8762a145586e425b9c5262d43608c6d", "filename": "libgo/go/runtime/mgcpacer.go", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmgcpacer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmgcpacer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcpacer.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -154,6 +154,8 @@ type gcControllerState struct {\n \t// For goexperiment.PacerRedesign.\n \tconsMarkController piController\n \n+\t_ uint32 // Padding for atomics on 32-bit platforms.\n+\n \t// heapGoal is the goal heapLive for when next GC ends.\n \t// Set to ^uint64(0) if disabled.\n \t//\n@@ -670,17 +672,41 @@ func (c *gcControllerState) endCycle(now int64, procs int, userForced bool) floa\n \t\tcurrentConsMark := (float64(c.heapLive-c.trigger) * (utilization + idleUtilization)) /\n \t\t\t(float64(scanWork) * (1 - utilization))\n \n-\t\t// Update cons/mark controller.\n-\t\t// Period for this is 1 GC cycle.\n+\t\t// Update cons/mark controller. The time period for this is 1 GC cycle.\n+\t\t//\n+\t\t// This use of a PI controller might seem strange. So, here's an explanation:\n+\t\t//\n+\t\t// currentConsMark represents the consMark we *should've* had to be perfectly\n+\t\t// on-target for this cycle. Given that we assume the next GC will be like this\n+\t\t// one in the steady-state, it stands to reason that we should just pick that\n+\t\t// as our next consMark. In practice, however, currentConsMark is too noisy:\n+\t\t// we're going to be wildly off-target in each GC cycle if we do that.\n+\t\t//\n+\t\t// What we do instead is make a long-term assumption: there is some steady-state\n+\t\t// consMark value, but it's obscured by noise. By constantly shooting for this\n+\t\t// noisy-but-perfect consMark value, the controller will bounce around a bit,\n+\t\t// but its average behavior, in aggregate, should be less noisy and closer to\n+\t\t// the true long-term consMark value, provided its tuned to be slightly overdamped.\n+\t\tvar ok bool\n \t\toldConsMark := c.consMark\n-\t\tc.consMark = c.consMarkController.next(c.consMark, currentConsMark, 1.0)\n+\t\tc.consMark, ok = c.consMarkController.next(c.consMark, currentConsMark, 1.0)\n+\t\tif !ok {\n+\t\t\t// The error spiraled out of control. This is incredibly unlikely seeing\n+\t\t\t// as this controller is essentially just a smoothing function, but it might\n+\t\t\t// mean that something went very wrong with how currentConsMark was calculated.\n+\t\t\t// Just reset consMark and keep going.\n+\t\t\tc.consMark = 0\n+\t\t}\n \n \t\tif debug.gcpacertrace > 0 {\n \t\t\tprintlock()\n \t\t\tgoal := gcGoalUtilization * 100\n \t\t\tprint(\"pacer: \", int(utilization*100), \"% CPU (\", int(goal), \" exp.) for \")\n \t\t\tprint(c.heapScanWork.Load(), \"+\", c.stackScanWork.Load(), \"+\", c.globalsScanWork.Load(), \" B work (\", c.lastHeapScan+c.stackScan+c.globalsScan, \" B exp.) \")\n \t\t\tprint(\"in \", c.trigger, \" B -> \", c.heapLive, \" B (\u2206goal \", int64(c.heapLive)-int64(c.heapGoal), \", cons/mark \", oldConsMark, \")\")\n+\t\t\tif !ok {\n+\t\t\t\tprint(\"[controller reset]\")\n+\t\t\t}\n \t\t\tprintln()\n \t\t\tprintunlock()\n \t\t}\n@@ -1263,15 +1289,38 @@ type piController struct {\n \t// PI controller state.\n \n \terrIntegral float64 // Integral of the error from t=0 to now.\n+\n+\t// Error flags.\n+\terrOverflow   bool // Set if errIntegral ever overflowed.\n+\tinputOverflow bool // Set if an operation with the input overflowed.\n }\n \n-func (c *piController) next(input, setpoint, period float64) float64 {\n+// next provides a new sample to the controller.\n+//\n+// input is the sample, setpoint is the desired point, and period is how much\n+// time (in whatever unit makes the most sense) has passed since the last sample.\n+//\n+// Returns a new value for the variable it's controlling, and whether the operation\n+// completed successfully. One reason this might fail is if error has been growing\n+// in an unbounded manner, to the point of overflow.\n+//\n+// In the specific case of an error overflow occurs, the errOverflow field will be\n+// set and the rest of the controller's internal state will be fully reset.\n+func (c *piController) next(input, setpoint, period float64) (float64, bool) {\n \t// Compute the raw output value.\n \tprop := c.kp * (setpoint - input)\n \trawOutput := prop + c.errIntegral\n \n \t// Clamp rawOutput into output.\n \toutput := rawOutput\n+\tif isInf(output) || isNaN(output) {\n+\t\t// The input had a large enough magnitude that either it was already\n+\t\t// overflowed, or some operation with it overflowed.\n+\t\t// Set a flag and reset. That's the safest thing to do.\n+\t\tc.reset()\n+\t\tc.inputOverflow = true\n+\t\treturn c.min, false\n+\t}\n \tif output < c.min {\n \t\toutput = c.min\n \t} else if output > c.max {\n@@ -1281,6 +1330,19 @@ func (c *piController) next(input, setpoint, period float64) float64 {\n \t// Update the controller's state.\n \tif c.ti != 0 && c.tt != 0 {\n \t\tc.errIntegral += (c.kp*period/c.ti)*(setpoint-input) + (period/c.tt)*(output-rawOutput)\n+\t\tif isInf(c.errIntegral) || isNaN(c.errIntegral) {\n+\t\t\t// So much error has accumulated that we managed to overflow.\n+\t\t\t// The assumptions around the controller have likely broken down.\n+\t\t\t// Set a flag and reset. That's the safest thing to do.\n+\t\t\tc.reset()\n+\t\t\tc.errOverflow = true\n+\t\t\treturn c.min, false\n+\t\t}\n \t}\n-\treturn output\n+\treturn output, true\n+}\n+\n+// reset resets the controller state, except for controller error flags.\n+func (c *piController) reset() {\n+\tc.errIntegral = 0\n }"}, {"sha": "10a8ca25202d18be47890fc1d632dbe3817e9dc9", "filename": "libgo/go/runtime/mgcpacer_test.go", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmgcpacer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmgcpacer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcpacer_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -715,3 +715,48 @@ func (f float64Stream) limit(min, max float64) float64Stream {\n \t\treturn v\n \t}\n }\n+\n+func FuzzPIController(f *testing.F) {\n+\tisNormal := func(x float64) bool {\n+\t\treturn !math.IsInf(x, 0) && !math.IsNaN(x)\n+\t}\n+\tisPositive := func(x float64) bool {\n+\t\treturn isNormal(x) && x > 0\n+\t}\n+\t// Seed with constants from controllers in the runtime.\n+\t// It's not critical that we keep these in sync, they're just\n+\t// reasonable seed inputs.\n+\tf.Add(0.3375, 3.2e6, 1e9, 0.001, 1000.0, 0.01)\n+\tf.Add(0.9, 4.0, 1000.0, -1000.0, 1000.0, 0.84)\n+\tf.Fuzz(func(t *testing.T, kp, ti, tt, min, max, setPoint float64) {\n+\t\t// Ignore uninteresting invalid parameters. These parameters\n+\t\t// are constant, so in practice surprising values will be documented\n+\t\t// or will be other otherwise immediately visible.\n+\t\t//\n+\t\t// We just want to make sure that given a non-Inf, non-NaN input,\n+\t\t// we always get a non-Inf, non-NaN output.\n+\t\tif !isPositive(kp) || !isPositive(ti) || !isPositive(tt) {\n+\t\t\treturn\n+\t\t}\n+\t\tif !isNormal(min) || !isNormal(max) || min > max {\n+\t\t\treturn\n+\t\t}\n+\t\t// Use a random source, but make it deterministic.\n+\t\trs := rand.New(rand.NewSource(800))\n+\t\trandFloat64 := func() float64 {\n+\t\t\treturn math.Float64frombits(rs.Uint64())\n+\t\t}\n+\t\tp := NewPIController(kp, ti, tt, min, max)\n+\t\tstate := float64(0)\n+\t\tfor i := 0; i < 100; i++ {\n+\t\t\tinput := randFloat64()\n+\t\t\t// Ignore the \"ok\" parameter. We're just trying to break it.\n+\t\t\t// state is intentionally completely uncorrelated with the input.\n+\t\t\tvar ok bool\n+\t\t\tstate, ok = p.Next(input, setPoint, 1.0)\n+\t\t\tif !isNormal(state) {\n+\t\t\t\tt.Fatalf(\"got NaN or Inf result from controller: %f %v\", state, ok)\n+\t\t\t}\n+\t\t}\n+\t})\n+}"}, {"sha": "9d6e0bd45b3d40f7042693dd57cc36e585d2942f", "filename": "libgo/go/runtime/mgcscavenge.go", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -165,11 +165,12 @@ func gcPaceScavenger(heapGoal, lastHeapGoal uint64) {\n \n // Sleep/wait state of the background scavenger.\n var scavenge struct {\n-\tlock       mutex\n-\tg          *g\n-\tparked     bool\n-\ttimer      *timer\n-\tsysmonWake uint32 // Set atomically.\n+\tlock                 mutex\n+\tg                    *g\n+\tparked               bool\n+\ttimer                *timer\n+\tsysmonWake           uint32 // Set atomically.\n+\tprintControllerReset bool   // Whether the scavenger is in cooldown.\n }\n \n // readyForScavenger signals sysmon to wake the scavenger because\n@@ -297,8 +298,14 @@ func bgscavenge(c chan int) {\n \t\tmax: 1000.0, // 1000:1\n \t}\n \t// It doesn't really matter what value we start at, but we can't be zero, because\n-\t// that'll cause divide-by-zero issues.\n-\tcritSleepRatio := 0.001\n+\t// that'll cause divide-by-zero issues. Pick something conservative which we'll\n+\t// also use as a fallback.\n+\tconst startingCritSleepRatio = 0.001\n+\tcritSleepRatio := startingCritSleepRatio\n+\t// Duration left in nanoseconds during which we avoid using the controller and\n+\t// we hold critSleepRatio at a conservative value. Used if the controller's\n+\t// assumptions fail to hold.\n+\tcontrollerCooldown := int64(0)\n \tfor {\n \t\treleased := uintptr(0)\n \t\tcrit := float64(0)\n@@ -385,9 +392,22 @@ func bgscavenge(c chan int) {\n \t\t// because of the additional overheads of using scavenged memory.\n \t\tcrit *= 1 + scavengeCostRatio\n \n-\t\t// Go to sleep for our current sleepNS.\n+\t\t// Go to sleep based on how much time we spent doing work.\n \t\tslept := scavengeSleep(int64(crit / critSleepRatio))\n \n+\t\t// Stop here if we're cooling down from the controller.\n+\t\tif controllerCooldown > 0 {\n+\t\t\t// crit and slept aren't exact measures of time, but it's OK to be a bit\n+\t\t\t// sloppy here. We're just hoping we're avoiding some transient bad behavior.\n+\t\t\tt := slept + int64(crit)\n+\t\t\tif t > controllerCooldown {\n+\t\t\t\tcontrollerCooldown = 0\n+\t\t\t} else {\n+\t\t\t\tcontrollerCooldown -= t\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n \t\t// Calculate the CPU time spent.\n \t\t//\n \t\t// This may be slightly inaccurate with respect to GOMAXPROCS, but we're\n@@ -397,7 +417,20 @@ func bgscavenge(c chan int) {\n \t\tcpuFraction := float64(crit) / ((float64(slept) + crit) * float64(gomaxprocs))\n \n \t\t// Update the critSleepRatio, adjusting until we reach our ideal fraction.\n-\t\tcritSleepRatio = critSleepController.next(cpuFraction, idealFraction, float64(slept)+crit)\n+\t\tvar ok bool\n+\t\tcritSleepRatio, ok = critSleepController.next(cpuFraction, idealFraction, float64(slept)+crit)\n+\t\tif !ok {\n+\t\t\t// The core assumption of the controller, that we can get a proportional\n+\t\t\t// response, broke down. This may be transient, so temporarily switch to\n+\t\t\t// sleeping a fixed, conservative amount.\n+\t\t\tcritSleepRatio = startingCritSleepRatio\n+\t\t\tcontrollerCooldown = 5e9 // 5 seconds.\n+\n+\t\t\t// Signal the scav trace printer to output this.\n+\t\t\tlock(&scavenge.lock)\n+\t\t\tscavenge.printControllerReset = true\n+\t\t\tunlock(&scavenge.lock)\n+\t\t}\n \t}\n }\n \n@@ -436,7 +469,11 @@ func (p *pageAlloc) scavenge(nbytes uintptr) uintptr {\n // released should be the amount of memory released since the last time this\n // was called, and forced indicates whether the scavenge was forced by the\n // application.\n+//\n+// scavenge.lock must be held.\n func printScavTrace(gen uint32, released uintptr, forced bool) {\n+\tassertLockHeld(&scavenge.lock)\n+\n \tprintlock()\n \tprint(\"scav \", gen, \" \",\n \t\treleased>>10, \" KiB work, \",\n@@ -445,6 +482,9 @@ func printScavTrace(gen uint32, released uintptr, forced bool) {\n \t)\n \tif forced {\n \t\tprint(\" (forced)\")\n+\t} else if scavenge.printControllerReset {\n+\t\tprint(\" [controller reset]\")\n+\t\tscavenge.printControllerReset = false\n \t}\n \tprintln()\n \tprintunlock()"}, {"sha": "983d4d448a221a02d7b13a808b8268a1b2cd7a64", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 49, "deletions": 18, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -798,7 +798,7 @@ func TestBlockProfile(t *testing.T) {\n \tt.Skip(\"lots of details are different for gccgo; FIXME\")\n \ttype TestCase struct {\n \t\tname string\n-\t\tf    func()\n+\t\tf    func(*testing.T)\n \t\tstk  []string\n \t\tre   string\n \t}\n@@ -907,7 +907,7 @@ func TestBlockProfile(t *testing.T) {\n \truntime.SetBlockProfileRate(1)\n \tdefer runtime.SetBlockProfileRate(0)\n \tfor _, test := range tests {\n-\t\ttest.f()\n+\t\ttest.f(t)\n \t}\n \n \tt.Run(\"debug=1\", func(t *testing.T) {\n@@ -983,42 +983,73 @@ func containsStack(got [][]string, want []string) bool {\n \treturn false\n }\n \n-const blockDelay = 10 * time.Millisecond\n+// awaitBlockedGoroutine spins on runtime.Gosched until a runtime stack dump\n+// shows a goroutine in the given state with a stack frame in\n+// runtime/pprof.<fName>.\n+func awaitBlockedGoroutine(t *testing.T, state, fName string) {\n+\tre := fmt.Sprintf(`(?m)^goroutine \\d+ \\[%s\\]:\\n(?:.+\\n\\t.+\\n)*runtime/pprof\\.%s`, regexp.QuoteMeta(state), fName)\n+\tr := regexp.MustCompile(re)\n \n-func blockChanRecv() {\n+\tif deadline, ok := t.Deadline(); ok {\n+\t\tif d := time.Until(deadline); d > 1*time.Second {\n+\t\t\ttimer := time.AfterFunc(d-1*time.Second, func() {\n+\t\t\t\tdebug.SetTraceback(\"all\")\n+\t\t\t\tpanic(fmt.Sprintf(\"timed out waiting for %#q\", re))\n+\t\t\t})\n+\t\t\tdefer timer.Stop()\n+\t\t}\n+\t}\n+\n+\tbuf := make([]byte, 64<<10)\n+\tfor {\n+\t\truntime.Gosched()\n+\t\tn := runtime.Stack(buf, true)\n+\t\tif n == len(buf) {\n+\t\t\t// Buffer wasn't large enough for a full goroutine dump.\n+\t\t\t// Resize it and try again.\n+\t\t\tbuf = make([]byte, 2*len(buf))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif r.Match(buf[:n]) {\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+func blockChanRecv(t *testing.T) {\n \tc := make(chan bool)\n \tgo func() {\n-\t\ttime.Sleep(blockDelay)\n+\t\tawaitBlockedGoroutine(t, \"chan receive\", \"blockChanRecv\")\n \t\tc <- true\n \t}()\n \t<-c\n }\n \n-func blockChanSend() {\n+func blockChanSend(t *testing.T) {\n \tc := make(chan bool)\n \tgo func() {\n-\t\ttime.Sleep(blockDelay)\n+\t\tawaitBlockedGoroutine(t, \"chan send\", \"blockChanSend\")\n \t\t<-c\n \t}()\n \tc <- true\n }\n \n-func blockChanClose() {\n+func blockChanClose(t *testing.T) {\n \tc := make(chan bool)\n \tgo func() {\n-\t\ttime.Sleep(blockDelay)\n+\t\tawaitBlockedGoroutine(t, \"chan receive\", \"blockChanClose\")\n \t\tclose(c)\n \t}()\n \t<-c\n }\n \n-func blockSelectRecvAsync() {\n+func blockSelectRecvAsync(t *testing.T) {\n \tconst numTries = 3\n \tc := make(chan bool, 1)\n \tc2 := make(chan bool, 1)\n \tgo func() {\n \t\tfor i := 0; i < numTries; i++ {\n-\t\t\ttime.Sleep(blockDelay)\n+\t\t\tawaitBlockedGoroutine(t, \"select\", \"blockSelectRecvAsync\")\n \t\t\tc <- true\n \t\t}\n \t}()\n@@ -1030,11 +1061,11 @@ func blockSelectRecvAsync() {\n \t}\n }\n \n-func blockSelectSendSync() {\n+func blockSelectSendSync(t *testing.T) {\n \tc := make(chan bool)\n \tc2 := make(chan bool)\n \tgo func() {\n-\t\ttime.Sleep(blockDelay)\n+\t\tawaitBlockedGoroutine(t, \"select\", \"blockSelectSendSync\")\n \t\t<-c\n \t}()\n \tselect {\n@@ -1043,11 +1074,11 @@ func blockSelectSendSync() {\n \t}\n }\n \n-func blockMutex() {\n+func blockMutex(t *testing.T) {\n \tvar mu sync.Mutex\n \tmu.Lock()\n \tgo func() {\n-\t\ttime.Sleep(blockDelay)\n+\t\tawaitBlockedGoroutine(t, \"semacquire\", \"blockMutex\")\n \t\tmu.Unlock()\n \t}()\n \t// Note: Unlock releases mu before recording the mutex event,\n@@ -1057,12 +1088,12 @@ func blockMutex() {\n \tmu.Lock()\n }\n \n-func blockCond() {\n+func blockCond(t *testing.T) {\n \tvar mu sync.Mutex\n \tc := sync.NewCond(&mu)\n \tmu.Lock()\n \tgo func() {\n-\t\ttime.Sleep(blockDelay)\n+\t\tawaitBlockedGoroutine(t, \"sync.Cond.Wait\", \"blockCond\")\n \t\tmu.Lock()\n \t\tc.Signal()\n \t\tmu.Unlock()\n@@ -1148,7 +1179,7 @@ func TestMutexProfile(t *testing.T) {\n \t\tt.Fatalf(\"need MutexProfileRate 0, got %d\", old)\n \t}\n \n-\tblockMutex()\n+\tblockMutex(t)\n \n \tt.Run(\"debug=1\", func(t *testing.T) {\n \t\tvar w bytes.Buffer"}, {"sha": "881793b8f2f11a4f1e305340f8f2d870e0a920c2", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 48, "deletions": 95, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -212,10 +212,6 @@ func main(unsafe.Pointer) {\n \tmainStarted = true\n \n \tif GOARCH != \"wasm\" { // no threads on wasm yet, so no sysmon\n-\t\t// For runtime_syscall_doAllThreadsSyscall, we\n-\t\t// register sysmon is not ready for the world to be\n-\t\t// stopped.\n-\t\tatomic.Store(&sched.sysmonStarting, 1)\n \t\tsystemstack(func() {\n \t\t\tnewm(sysmon, nil, -1)\n \t\t})\n@@ -232,7 +228,6 @@ func main(unsafe.Pointer) {\n \tif g.m != &m0 {\n \t\tthrow(\"runtime.main not on m0\")\n \t}\n-\tm0.doesPark = true\n \n \t// Record when the world started.\n \t// Must be before doInit for tracing init.\n@@ -801,7 +796,13 @@ func mcommoninit(mp *m, id int64) {\n \tif lo|hi == 0 {\n \t\thi = 1\n \t}\n-\tmp.fastrand = uint64(hi)<<32 | uint64(lo)\n+\t// Same behavior as for 1.17.\n+\t// TODO: Simplify ths.\n+\tif goarch.BigEndian {\n+\t\tmp.fastrand = uint64(lo)<<32 | uint64(hi)\n+\t} else {\n+\t\tmp.fastrand = uint64(hi)<<32 | uint64(lo)\n+\t}\n \n \tmpreinit(mp)\n \n@@ -1363,22 +1364,12 @@ func mstartm0() {\n \tinitsig(false)\n }\n \n-// mPark causes a thread to park itself - temporarily waking for\n-// fixups but otherwise waiting to be fully woken. This is the\n-// only way that m's should park themselves.\n+// mPark causes a thread to park itself, returning once woken.\n //go:nosplit\n func mPark() {\n-\tg := getg()\n-\tfor {\n-\t\tnotesleep(&g.m.park)\n-\t\t// Note, because of signal handling by this parked m,\n-\t\t// a preemptive mDoFixup() may actually occur via\n-\t\t// mDoFixupAndOSYield(). (See golang.org/issue/44193)\n-\t\tnoteclear(&g.m.park)\n-\t\tif !mDoFixup() {\n-\t\t\treturn\n-\t\t}\n-\t}\n+\tgp := getg()\n+\tnotesleep(&gp.m.park)\n+\tnoteclear(&gp.m.park)\n }\n \n // mexit tears down and exits the current thread.\n@@ -1623,8 +1614,14 @@ func runSafePointFn() {\n //\n //go:yeswritebarrierrec\n func allocm(_p_ *p, fn func(), id int64, allocatestack bool) (mp *m, g0Stack unsafe.Pointer, g0StackSize uintptr) {\n+\tallocmLock.rlock()\n+\n+\t// The caller owns _p_, but we may borrow (i.e., acquirep) it. We must\n+\t// disable preemption to ensure it is not stolen, which would make the\n+\t// caller lose ownership.\n+\tacquirem()\n+\n \t_g_ := getg()\n-\tacquirem() // disable GC because it can be called from sysmon\n \tif _g_.m.p == 0 {\n \t\tacquirep(_p_) // temporarily borrow p for mallocs in this function\n \t}\n@@ -1664,8 +1661,9 @@ func allocm(_p_ *p, fn func(), id int64, allocatestack bool) (mp *m, g0Stack uns\n \tif _p_ == _g_.m.p.ptr() {\n \t\treleasep()\n \t}\n-\treleasem(_g_.m)\n \n+\treleasem(_g_.m)\n+\tallocmLock.runlock()\n \treturn mp, g0Stack, g0StackSize\n }\n \n@@ -1940,9 +1938,17 @@ func unlockextra(mp *m) {\n \tatomic.Storeuintptr(&extram, uintptr(unsafe.Pointer(mp)))\n }\n \n-// execLock serializes exec and clone to avoid bugs or unspecified behaviour\n-// around exec'ing while creating/destroying threads.  See issue #19546.\n-var execLock rwmutex\n+var (\n+\t// allocmLock is locked for read when creating new Ms in allocm and their\n+\t// addition to allm. Thus acquiring this lock for write blocks the\n+\t// creation of new Ms.\n+\tallocmLock rwmutex\n+\n+\t// execLock serializes exec and clone to avoid bugs or unspecified\n+\t// behaviour around exec'ing while creating/destroying threads. See\n+\t// issue #19546.\n+\texecLock rwmutex\n+)\n \n // newmHandoff contains a list of m structures that need new OS threads.\n // This is used by newm in situations where newm itself can't safely\n@@ -1972,8 +1978,19 @@ var newmHandoff struct {\n // id is optional pre-allocated m ID. Omit by passing -1.\n //go:nowritebarrierrec\n func newm(fn func(), _p_ *p, id int64) {\n+\t// allocm adds a new M to allm, but they do not start until created by\n+\t// the OS in newm1 or the template thread.\n+\t//\n+\t// doAllThreadsSyscall requires that every M in allm will eventually\n+\t// start and be signal-able, even with a STW.\n+\t//\n+\t// Disable preemption here until we start the thread to ensure that\n+\t// newm is not preempted between allocm and starting the new thread,\n+\t// ensuring that anything added to allm is guaranteed to eventually\n+\t// start.\n+\tacquirem()\n+\n \tmp, _, _ := allocm(_p_, fn, id, false)\n-\tmp.doesPark = (_p_ != nil)\n \tmp.nextp.set(_p_)\n \tmp.sigmask = initSigmask\n \tif gp := getg(); gp != nil && gp.m != nil && (gp.m.lockedExt != 0 || gp.m.incgo) && GOOS != \"plan9\" {\n@@ -1999,9 +2016,14 @@ func newm(fn func(), _p_ *p, id int64) {\n \t\t\tnotewakeup(&newmHandoff.wake)\n \t\t}\n \t\tunlock(&newmHandoff.lock)\n+\t\t// The M has not started yet, but the template thread does not\n+\t\t// participate in STW, so it will always process queued Ms and\n+\t\t// it is safe to releasem.\n+\t\treleasem(getg().m)\n \t\treturn\n \t}\n \tnewm1(mp)\n+\treleasem(getg().m)\n }\n \n func newm1(mp *m) {\n@@ -2030,67 +2052,6 @@ func startTemplateThread() {\n \treleasem(mp)\n }\n \n-// mFixupRace is used to temporarily borrow the race context from the\n-// coordinating m during a syscall_runtime_doAllThreadsSyscall and\n-// loan it out to each of the m's of the runtime so they can execute a\n-// mFixup.fn in that context.\n-var mFixupRace struct {\n-\tlock mutex\n-\tctx  uintptr\n-}\n-\n-// mDoFixup runs any outstanding fixup function for the running m.\n-// Returns true if a fixup was outstanding and actually executed.\n-//\n-// Note: to avoid deadlocks, and the need for the fixup function\n-// itself to be async safe, signals are blocked for the working m\n-// while it holds the mFixup lock. (See golang.org/issue/44193)\n-//\n-//go:nosplit\n-func mDoFixup() bool {\n-\t_g_ := getg()\n-\tif used := atomic.Load(&_g_.m.mFixup.used); used == 0 {\n-\t\treturn false\n-\t}\n-\n-\t// slow path - if fixup fn is used, block signals and lock.\n-\tvar sigmask sigset\n-\tsigsave(&sigmask)\n-\tsigblock(false)\n-\tlock(&_g_.m.mFixup.lock)\n-\tfn := _g_.m.mFixup.fn\n-\tif fn != nil {\n-\t\tif gcphase != _GCoff {\n-\t\t\t// We can't have a write barrier in this\n-\t\t\t// context since we may not have a P, but we\n-\t\t\t// clear fn to signal that we've executed the\n-\t\t\t// fixup. As long as fn is kept alive\n-\t\t\t// elsewhere, technically we should have no\n-\t\t\t// issues with the GC, but fn is likely\n-\t\t\t// generated in a different package altogether\n-\t\t\t// that may change independently. Just assert\n-\t\t\t// the GC is off so this lack of write barrier\n-\t\t\t// is more obviously safe.\n-\t\t\tthrow(\"GC must be disabled to protect validity of fn value\")\n-\t\t}\n-\t\t*(*uintptr)(unsafe.Pointer(&_g_.m.mFixup.fn)) = 0\n-\t\tfn(false)\n-\t}\n-\tunlock(&_g_.m.mFixup.lock)\n-\tmsigrestore(sigmask)\n-\treturn fn != nil\n-}\n-\n-// mDoFixupAndOSYield is called when an m is unable to send a signal\n-// because the allThreadsSyscall mechanism is in progress. That is, an\n-// mPark() has been interrupted with this signal handler so we need to\n-// ensure the fixup is executed from this context.\n-//go:nosplit\n-func mDoFixupAndOSYield() {\n-\tmDoFixup()\n-\tosyield()\n-}\n-\n // templateThread is a thread in a known-good state that exists solely\n // to start new threads in known-good states when the calling thread\n // may not be in a good state.\n@@ -2127,7 +2088,6 @@ func templateThread() {\n \t\tnoteclear(&newmHandoff.wake)\n \t\tunlock(&newmHandoff.lock)\n \t\tnotesleep(&newmHandoff.wake)\n-\t\tmDoFixup()\n \t}\n }\n \n@@ -4826,10 +4786,6 @@ func sysmon() {\n \tcheckdead()\n \tunlock(&sched.lock)\n \n-\t// For syscall_runtime_doAllThreadsSyscall, sysmon is\n-\t// sufficiently up to participate in fixups.\n-\tatomic.Store(&sched.sysmonStarting, 0)\n-\n \tlasttrace := int64(0)\n \tidle := 0 // how many cycles in succession we had not wokeup somebody\n \tdelay := uint32(0)\n@@ -4844,7 +4800,6 @@ func sysmon() {\n \t\t\tdelay = 10 * 1000\n \t\t}\n \t\tusleep(delay)\n-\t\tmDoFixup()\n \n \t\t// sysmon should not enter deep sleep if schedtrace is enabled so that\n \t\t// it can print that information at the right time.\n@@ -4881,7 +4836,6 @@ func sysmon() {\n \t\t\t\t\t\tosRelax(true)\n \t\t\t\t\t}\n \t\t\t\t\tsyscallWake = notetsleep(&sched.sysmonnote, sleep)\n-\t\t\t\t\tmDoFixup()\n \t\t\t\t\tif shouldRelax {\n \t\t\t\t\t\tosRelax(false)\n \t\t\t\t\t}\n@@ -4924,7 +4878,6 @@ func sysmon() {\n \t\t\t\tincidlelocked(1)\n \t\t\t}\n \t\t}\n-\t\tmDoFixup()\n \t\tif GOOS == \"netbsd\" && needSysmonWorkaround {\n \t\t\t// netpoll is responsible for waiting for timer\n \t\t\t// expiration, so we typically don't have to worry"}, {"sha": "7885fbb92006e6fa09bf00ae699171a8ec51aad8", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -593,7 +593,6 @@ type m struct {\n \tncgo        int32  // number of cgo calls currently in progress\n \t// Not for gccgo: cgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily\n \t// Not for gccgo: cgoCallers    *cgoCallers // cgo traceback if crashing in cgo call\n-\tdoesPark      bool // non-P running threads: sysmon and newmHandoff never use .park\n \tpark          note\n \talllink       *m // on allm\n \tschedlink     muintptr\n@@ -610,16 +609,6 @@ type m struct {\n \tsyscalltick   uint32\n \tfreelink      *m // on sched.freem\n \n-\t// mFixup is used to synchronize OS related m state\n-\t// (credentials etc) use mutex to access. To avoid deadlocks\n-\t// an atomic.Load() of used being zero in mDoFixupFn()\n-\t// guarantees fn is nil.\n-\tmFixup struct {\n-\t\tlock mutex\n-\t\tused uint32\n-\t\tfn   func(bool) bool\n-\t}\n-\n \t// these are here because they are too large to be on the stack\n \t// of low-level NOSPLIT functions.\n \t// Not for gccgo: libcall   libcall\n@@ -869,10 +858,6 @@ type schedt struct {\n \tsysmonwait uint32\n \tsysmonnote note\n \n-\t// While true, sysmon not ready for mFixup calls.\n-\t// Accessed atomically.\n-\tsysmonStarting uint32\n-\n \t// safepointFn should be called on each P at the next GC\n \t// safepoint if p.runSafePointFn is set.\n \tsafePointFn   func(*p)\n@@ -890,6 +875,8 @@ type schedt struct {\n \t// with the rest of the runtime.\n \tsysmonlock mutex\n \n+\t_ uint32 // for alignment\n+\n \t// timeToRun is a distribution of scheduling latencies, defined\n \t// as the sum of time a G spends in the _Grunnable state before\n \t// it transitions to _Grunning.\n@@ -906,7 +893,7 @@ const (\n \t_SigPanic                // if the signal is from the kernel, panic\n \t_SigDefault              // if the signal isn't explicitly requested, don't monitor it\n \t_SigGoExit               // cause all runtime procs to exit (only used on Plan 9).\n-\t_SigSetStack             // add SA_ONSTACK to libc handler\n+\t_SigSetStack             // Don't explicitly install handler, but add SA_ONSTACK to existing libc handler\n \t_SigUnblock              // always unblock; see blockableSig\n \t_SigIgn                  // _SIG_DFL action is to ignore the signal\n )"}, {"sha": "49754f57643a66cb6a99c2e333b0ff967f687b04", "filename": "libgo/go/runtime/sigqueue.go", "status": "modified", "additions": 11, "deletions": 37, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigqueue.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -11,18 +11,18 @@\n //\n // sigsend is called by the signal handler to queue a new signal.\n // signal_recv is called by the Go program to receive a newly queued signal.\n+//\n // Synchronization between sigsend and signal_recv is based on the sig.state\n-// variable. It can be in 4 states: sigIdle, sigReceiving, sigSending and sigFixup.\n-// sigReceiving means that signal_recv is blocked on sig.Note and there are no\n-// new pending signals.\n-// sigSending means that sig.mask *may* contain new pending signals,\n-// signal_recv can't be blocked in this state.\n-// sigIdle means that there are no new pending signals and signal_recv is not blocked.\n-// sigFixup is a transient state that can only exist as a short\n-// transition from sigReceiving and then on to sigIdle: it is\n-// used to ensure the AllThreadsSyscall()'s mDoFixup() operation\n-// occurs on the sleeping m, waiting to receive a signal.\n+// variable. It can be in three states:\n+// * sigReceiving means that signal_recv is blocked on sig.Note and there are\n+//   no new pending signals.\n+// * sigSending means that sig.mask *may* contain new pending signals,\n+//   signal_recv can't be blocked in this state.\n+// * sigIdle means that there are no new pending signals and signal_recv is not\n+//   blocked.\n+//\n // Transitions between states are done atomically with CAS.\n+//\n // When signal_recv is unblocked, it resets sig.Note and rechecks sig.mask.\n // If several sigsends and signal_recv execute concurrently, it can lead to\n // unnecessary rechecks of sig.mask, but it cannot lead to missed signals\n@@ -63,7 +63,6 @@ const (\n \tsigIdle = iota\n \tsigReceiving\n \tsigSending\n-\tsigFixup\n )\n \n // sigsend delivers a signal from sighandler to the internal signal delivery queue.\n@@ -117,29 +116,13 @@ Send:\n \t\t\t\tnotewakeup(&sig.note)\n \t\t\t\tbreak Send\n \t\t\t}\n-\t\tcase sigFixup:\n-\t\t\t// nothing to do - we need to wait for sigIdle.\n-\t\t\tmDoFixupAndOSYield()\n \t\t}\n \t}\n \n \tatomic.Xadd(&sig.delivering, -1)\n \treturn true\n }\n \n-// sigRecvPrepareForFixup is used to temporarily wake up the\n-// signal_recv() running thread while it is blocked waiting for the\n-// arrival of a signal. If it causes the thread to wake up, the\n-// sig.state travels through this sequence: sigReceiving -> sigFixup\n-// -> sigIdle -> sigReceiving and resumes. (This is only called while\n-// GC is disabled.)\n-//go:nosplit\n-func sigRecvPrepareForFixup() {\n-\tif atomic.Cas(&sig.state, sigReceiving, sigFixup) {\n-\t\tnotewakeup(&sig.note)\n-\t}\n-}\n-\n // Called to receive the next queued signal.\n // Must only be called from a single goroutine at a time.\n //go:linkname signal_recv os_1signal.signal__recv\n@@ -167,16 +150,7 @@ func signal_recv() uint32 {\n \t\t\t\t\t}\n \t\t\t\t\tnotetsleepg(&sig.note, -1)\n \t\t\t\t\tnoteclear(&sig.note)\n-\t\t\t\t\tif !atomic.Cas(&sig.state, sigFixup, sigIdle) {\n-\t\t\t\t\t\tbreak Receive\n-\t\t\t\t\t}\n-\t\t\t\t\t// Getting here, the code will\n-\t\t\t\t\t// loop around again to sleep\n-\t\t\t\t\t// in state sigReceiving. This\n-\t\t\t\t\t// path is taken when\n-\t\t\t\t\t// sigRecvPrepareForFixup()\n-\t\t\t\t\t// has been called by another\n-\t\t\t\t\t// thread.\n+\t\t\t\t\tbreak Receive\n \t\t\t\t}\n \t\t\tcase sigSending:\n \t\t\t\tif atomic.Cas(&sig.state, sigSending, sigIdle) {"}, {"sha": "8c85712ac58c2d3b7dea05b448e051bd7dd87674", "filename": "libgo/go/runtime/slice.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fslice.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Fslice.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fslice.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -228,7 +228,7 @@ func growslice(et *_type, oldarray unsafe.Pointer, oldlen, oldcap, cap int) slic\n \tvar lenmem, newlenmem, capmem uintptr\n \t// Specialize for common values of et.size.\n \t// For 1 we don't need any division/multiplication.\n-\t// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.\n+\t// For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant.\n \t// For powers of 2, use a variable shift.\n \tswitch {\n \tcase et.size == 1:"}, {"sha": "c70d6333bbff9008a47797981f3b1a5d3a513354", "filename": "libgo/go/runtime/testdata/testprogcgo/aprof.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Faprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Faprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Faprof.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -7,8 +7,11 @@ package main\n // Test that SIGPROF received in C code does not crash the process\n // looking for the C code's func pointer.\n \n-// The test fails when the function is the first C function.\n-// The exported functions are the first C functions, so we use that.\n+// This is a regression test for issue 14599, where profiling fails when the\n+// function is the first C function. Exported functions are the first C\n+// functions, so we use an exported function. Exported functions are created in\n+// lexigraphical order of source files, so this file is named aprof.go to\n+// ensure its function is first.\n \n // extern void CallGoNop();\n import \"C\""}, {"sha": "e34564395e7f15fe028bc4cf4624c5f299ce3475", "filename": "libgo/go/runtime/testdata/testprogcgo/pprof_callback.go", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fpprof_callback.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fpprof_callback.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fpprof_callback.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//go:build !plan9 && !windows\n+\n+package main\n+\n+// Make many C-to-Go callback while collecting a CPU profile.\n+//\n+// This is a regression test for issue 50936.\n+\n+/*\n+#include <unistd.h>\n+\n+void goCallbackPprof();\n+\n+static void callGo() {\n+\t// Spent >20us in C so this thread is eligible for sysmon to retake its\n+\t// P.\n+\tusleep(50);\n+\tgoCallbackPprof();\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime/pprof\"\n+\t\"runtime\"\n+\t\"time\"\n+)\n+\n+func init() {\n+\tregister(\"CgoPprofCallback\", CgoPprofCallback)\n+}\n+\n+//export goCallbackPprof\n+func goCallbackPprof() {\n+\t// No-op. We want to stress the cgocall and cgocallback internals,\n+\t// landing as many pprof signals there as possible.\n+}\n+\n+func CgoPprofCallback() {\n+\t// Issue 50936 was a crash in the SIGPROF handler when the signal\n+\t// arrived during the exitsyscall following a cgocall(back) in dropg or\n+\t// execute, when updating mp.curg.\n+\t//\n+\t// These are reachable only when exitsyscall finds no P available. Thus\n+\t// we make C calls from significantly more Gs than there are available\n+\t// Ps. Lots of runnable work combined with >20us spent in callGo makes\n+\t// it possible for sysmon to retake Ps, forcing C calls to go down the\n+\t// desired exitsyscall path.\n+\t//\n+\t// High GOMAXPROCS is used to increase opportunities for failure on\n+\t// high CPU machines.\n+\tconst (\n+\t\tP = 16\n+\t\tG = 64\n+\t)\n+\truntime.GOMAXPROCS(P)\n+\n+\tf, err := os.CreateTemp(\"\", \"prof\")\n+\tif err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(2)\n+\t}\n+\tdefer f.Close()\n+\n+\tif err := pprof.StartCPUProfile(f); err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(2)\n+\t}\n+\n+\tfor i := 0; i < G; i++ {\n+\t\tgo func() {\n+\t\t\tfor {\n+\t\t\t\tC.callGo()\n+\t\t\t}\n+\t\t}()\n+\t}\n+\n+\ttime.Sleep(time.Second)\n+\n+\tpprof.StopCPUProfile()\n+\n+\tfmt.Println(\"OK\")\n+}"}, {"sha": "9678144d55dbe771bad22c367f782307da95b975", "filename": "libgo/go/runtime/trace.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Ftrace.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fruntime%2Ftrace.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftrace.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -230,7 +230,7 @@ func StartTrace() error {\n \t\t\tgp.traceseq = 0\n \t\t\tgp.tracelastp = getg().m.p\n \t\t\t// +PCQuantum because traceFrameForPC expects return PCs and subtracts PCQuantum.\n-\t\t\tid := trace.stackTab.put([]location{location{pc: gp.startpc + sys.PCQuantum}})\n+\t\t\tid := trace.stackTab.put([]location{location{pc: startPCforTrace(gp.startpc) + sys.PCQuantum}})\n \t\t\ttraceEvent(traceEvGoCreate, -1, uint64(gp.goid), uint64(id), stackID)\n \t\t}\n \t\tif status == _Gwaiting {\n@@ -1066,7 +1066,7 @@ func traceGoCreate(newg *g, pc uintptr) {\n \tnewg.traceseq = 0\n \tnewg.tracelastp = getg().m.p\n \t// +PCQuantum because traceFrameForPC expects return PCs and subtracts PCQuantum.\n-\tid := trace.stackTab.put([]location{location{pc: pc + sys.PCQuantum}})\n+\tid := trace.stackTab.put([]location{location{pc: startPCforTrace(pc) + sys.PCQuantum}})\n \ttraceEvent(traceEvGoCreate, 2, uint64(newg.goid), uint64(id))\n }\n \n@@ -1239,3 +1239,9 @@ func trace_userLog(id uint64, category, message string) {\n \n \ttraceReleaseBuffer(pid)\n }\n+\n+// the start PC of a goroutine for tracing purposes. If pc is a wrapper,\n+// it returns the PC of the wrapped function. Otherwise it returns pc.\n+func startPCforTrace(pc uintptr) uintptr {\n+\treturn pc\n+}"}, {"sha": "5793d9e26f4ed86bf203379c44fecad8cb646cbf", "filename": "libgo/go/strings/strings.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fstrings%2Fstrings.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fstrings%2Fstrings.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -270,6 +270,8 @@ func genSplit(s, sep string, sepSave, n int) []string {\n //\n // Edge cases for s and sep (for example, empty strings) are handled\n // as described in the documentation for Split.\n+//\n+// To split around the first instance of a separator, see Cut.\n func SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }\n \n // SplitAfterN slices s into substrings after each instance of sep and\n@@ -296,6 +298,8 @@ func SplitAfterN(s, sep string, n int) []string {\n // and sep are empty, Split returns an empty slice.\n //\n // It is equivalent to SplitN with a count of -1.\n+//\n+// To split around the first instance of a separator, see Cut.\n func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }\n \n // SplitAfter slices s into all substrings after each instance of sep and"}, {"sha": "3169cdda556d02c0309ef9c56f02d719d35e439c", "filename": "libgo/go/syscall/syscall_linux_test.go", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"sync\"\n \t\"syscall\"\n \t\"testing\"\n \t\"unsafe\"\n@@ -569,3 +570,73 @@ func TestSetuidEtc(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// TestAllThreadsSyscallError verifies that errors are properly returned when\n+// the syscall fails on the original thread.\n+func TestAllThreadsSyscallError(t *testing.T) {\n+\t// SYS_CAPGET takes pointers as the first two arguments. Since we pass\n+\t// 0, we expect to get EFAULT back.\n+\tr1, r2, err := syscall.AllThreadsSyscall(syscall.SYS_CAPGET, 0, 0, 0)\n+\tif err == syscall.ENOTSUP {\n+\t\tt.Skip(\"AllThreadsSyscall disabled with cgo\")\n+\t}\n+\tif err != syscall.EFAULT {\n+\t\tt.Errorf(\"AllThreadSyscall(SYS_CAPGET) got %d, %d, %v, want err %v\", r1, r2, err, syscall.EFAULT)\n+\t}\n+}\n+\n+// TestAllThreadsSyscallBlockedSyscall confirms that AllThreadsSyscall\n+// can interrupt threads in long-running system calls. This test will\n+// deadlock if this doesn't work correctly.\n+func TestAllThreadsSyscallBlockedSyscall(t *testing.T) {\n+\tif _, _, err := syscall.AllThreadsSyscall(syscall.SYS_PRCTL, PR_SET_KEEPCAPS, 0, 0); err == syscall.ENOTSUP {\n+\t\tt.Skip(\"AllThreadsSyscall disabled with cgo\")\n+\t}\n+\n+\trd, wr, err := os.Pipe()\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to obtain a pipe: %v\", err)\n+\t}\n+\n+\t// Perform a blocking read on the pipe.\n+\tvar wg sync.WaitGroup\n+\tready := make(chan bool)\n+\twg.Add(1)\n+\tgo func() {\n+\t\tdata := make([]byte, 1)\n+\n+\t\t// To narrow the window we have to wait for this\n+\t\t// goroutine to block in read, synchronize just before\n+\t\t// calling read.\n+\t\tready <- true\n+\n+\t\t// We use syscall.Read directly to avoid the poller.\n+\t\t// This will return when the write side is closed.\n+\t\tn, err := syscall.Read(int(rd.Fd()), data)\n+\t\tif !(n == 0 && err == nil) {\n+\t\t\tt.Errorf(\"expected read to return 0, got %d, %s\", n, err)\n+\t\t}\n+\n+\t\t// Clean up rd and also ensure rd stays reachable so\n+\t\t// it doesn't get closed by GC.\n+\t\trd.Close()\n+\t\twg.Done()\n+\t}()\n+\t<-ready\n+\n+\t// Loop here to give the goroutine more time to block in read.\n+\t// Generally this will trigger on the first iteration anyway.\n+\tpid := syscall.Getpid()\n+\tfor i := 0; i < 100; i++ {\n+\t\tif id, _, e := syscall.AllThreadsSyscall(syscall.SYS_GETPID, 0, 0, 0); e != 0 {\n+\t\t\tt.Errorf(\"[%d] getpid failed: %v\", i, e)\n+\t\t} else if int(id) != pid {\n+\t\t\tt.Errorf(\"[%d] getpid got=%d, want=%d\", i, id, pid)\n+\t\t}\n+\t\t// Provide an explicit opportunity for this goroutine\n+\t\t// to change Ms.\n+\t\truntime.Gosched()\n+\t}\n+\twr.Close()\n+\twg.Wait()\n+}"}, {"sha": "8bfbc9340358158774e87ff547c0ccb84b63af58", "filename": "libgo/go/syscall/syscall_unix_test.go", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fsyscall%2Fsyscall_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Fsyscall%2Fsyscall_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_unix_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -330,40 +330,27 @@ func TestUnixRightsRoundtrip(t *testing.T) {\n \n func TestRlimit(t *testing.T) {\n \tvar rlimit, zero syscall.Rlimit\n-\terr := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &rlimit)\n-\tif err != nil {\n+\tif err := syscall.Getrlimit(syscall.RLIMIT_CPU, &rlimit); err != nil {\n \t\tt.Fatalf(\"Getrlimit: save failed: %v\", err)\n \t}\n \tif zero == rlimit {\n \t\tt.Fatalf(\"Getrlimit: save failed: got zero value %#v\", rlimit)\n \t}\n \tset := rlimit\n \tset.Cur = set.Max - 1\n-\tif (runtime.GOOS == \"darwin\" || runtime.GOOS == \"ios\") && set.Cur > 4096 {\n-\t\t// rlim_min for RLIMIT_NOFILE should be equal to\n-\t\t// or lower than kern.maxfilesperproc, which on\n-\t\t// some machines are 4096. See #40564.\n-\t\tset.Cur = 4096\n-\t}\n-\terr = syscall.Setrlimit(syscall.RLIMIT_NOFILE, &set)\n-\tif err != nil {\n+\tif err := syscall.Setrlimit(syscall.RLIMIT_CPU, &set); err != nil {\n \t\tt.Fatalf(\"Setrlimit: set failed: %#v %v\", set, err)\n \t}\n \tvar get syscall.Rlimit\n-\terr = syscall.Getrlimit(syscall.RLIMIT_NOFILE, &get)\n-\tif err != nil {\n+\tif err := syscall.Getrlimit(syscall.RLIMIT_CPU, &get); err != nil {\n \t\tt.Fatalf(\"Getrlimit: get failed: %v\", err)\n \t}\n \tset = rlimit\n \tset.Cur = set.Max - 1\n-\tif (runtime.GOOS == \"darwin\" || runtime.GOOS == \"ios\") && set.Cur > 4096 {\n-\t\tset.Cur = 4096\n-\t}\n \tif set != get {\n \t\tt.Fatalf(\"Rlimit: change failed: wanted %#v got %#v\", set, get)\n \t}\n-\terr = syscall.Setrlimit(syscall.RLIMIT_NOFILE, &rlimit)\n-\tif err != nil {\n+\tif err := syscall.Setrlimit(syscall.RLIMIT_CPU, &rlimit); err != nil {\n \t\tt.Fatalf(\"Setrlimit: restore failed: %#v %v\", rlimit, err)\n \t}\n }"}, {"sha": "b5e1339debd22213ea93f787f92d8e92f65d0a83", "filename": "libgo/go/testing/fuzz.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Ftesting%2Ffuzz.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Ftesting%2Ffuzz.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ffuzz.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -227,6 +227,9 @@ func (f *F) Fuzz(ff any) {\n \tif fnType.NumIn() < 2 || fnType.In(0) != reflect.TypeOf((*T)(nil)) {\n \t\tpanic(\"testing: fuzz target must receive at least two arguments, where the first argument is a *T\")\n \t}\n+\tif fnType.NumOut() != 0 {\n+\t\tpanic(\"testing: fuzz target must not return a value\")\n+\t}\n \n \t// Save the types of the function to compare against the corpus.\n \tvar types []reflect.Type"}, {"sha": "9ecd59c77d761cb6ec0962e40d36a3f2a0e25c09", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -202,8 +202,7 @@\n // mode, the fuzz test acts much like a regular test, with subtests started\n // with F.Fuzz instead of T.Run.\n //\n-// TODO(#48255): write and link to documentation that will be helpful to users\n-// who are unfamiliar with fuzzing.\n+// See https://go.dev/doc/fuzz for documentation about fuzzing.\n //\n // Skipping\n //"}, {"sha": "33e6543289aedd5915300206e578d1220d5018eb", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -914,6 +914,7 @@ func skip(value, prefix string) (string, error) {\n // field immediately after the seconds field, even if the layout does not\n // signify its presence. In that case either a comma or a decimal point\n // followed by a maximal series of digits is parsed as a fractional second.\n+// Fractional seconds are truncated to nanosecond precision.\n //\n // Elements omitted from the layout are assumed to be zero or, when\n // zero is impossible, one, so parsing \"3:04pm\" returns the time"}, {"sha": "cb2f19d61b3f1bb38d76b5e5617781edbf77dfda", "filename": "libgo/libgo-packages.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Flibgo-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Flibgo-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Flibgo-packages.txt?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -204,6 +204,7 @@ runtime/debug\n runtime/internal/atomic\n runtime/internal/math\n runtime/internal/sys\n+runtime/internal/syscall\n runtime/metrics\n runtime/pprof\n runtime/trace"}, {"sha": "2ad0fe9df1907ed8e91bb5fc0daa71ccbd9500cb", "filename": "libgo/merge.sh", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -198,6 +198,18 @@ done\n     libgofile=${libgotd}/$f\n     merge ${name} ${oldfile} ${newfile} ${libgofile}\n   done\n+  (cd ${newtd} & git ls-files .) | while read f; do\n+    if test \"`basename -- $f`\" = \".gitignore\"; then\n+      continue\n+    fi\n+    oldfile=${oldtd}/$f\n+    if ! test -f ${oldfile}; then\n+      name=$d/$f\n+      newfile=${newtd}/$f\n+      libgofile=${libgotd}/$f\n+      merge ${name} ${oldfile} ${newfile} ${libgofile}\n+    fi\n+  done\n done\n \n (cd ${NEWDIR}/misc/cgo && find . -type f -print) | while read f; do"}, {"sha": "bc3ba2b489f2d120f831f656e74e1b373a0a65a5", "filename": "libgo/misc/cgo/errors/badsym_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fmisc%2Fcgo%2Ferrors%2Fbadsym_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fmisc%2Fcgo%2Ferrors%2Fbadsym_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fbadsym_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -201,6 +201,10 @@ func cCompilerCmd(t *testing.T) []string {\n \tif !lastSpace {\n \t\tcc = append(cc, s[start:])\n \t}\n+\n+\t// Force reallocation (and avoid aliasing bugs) for tests that append to cc.\n+\tcc = cc[:len(cc):len(cc)]\n+\n \treturn cc\n }\n "}, {"sha": "109ef987f93023a4bba79219fecd74c9eeb2ab07", "filename": "libgo/misc/cgo/test/test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fmisc%2Fcgo%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fmisc%2Fcgo%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftest.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -367,6 +367,11 @@ void init() {\n // Cgo incorrectly computed the alignment of structs\n // with no Go accessible fields as 0, and then panicked on\n // modulo-by-zero computations.\n+\n+// issue 50987\n+// disable arm64 GCC warnings\n+#cgo CFLAGS: -Wno-psabi -Wno-unknown-warning-option\n+\n typedef struct {\n } foo;\n "}, {"sha": "c59dbbb77e9a2bdd59edc631b7d0936b2a2f8868", "filename": "libgo/misc/cgo/testcarchive/carchive_test.go", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"flag\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/fs\"\n \t\"log\"\n \t\"os\"\n \t\"os/exec\"\n@@ -141,6 +140,9 @@ func testMain(m *testing.M) int {\n \tlibgodir = filepath.Join(GOPATH, \"pkg\", libbase, \"testcarchive\")\n \tcc = append(cc, \"-I\", libgodir)\n \n+\t// Force reallocation (and avoid aliasing bugs) for parallel tests that append to cc.\n+\tcc = cc[:len(cc):len(cc)]\n+\n \tif GOOS == \"windows\" {\n \t\texeSuffix = \".exe\"\n \t}\n@@ -248,29 +250,6 @@ func testInstall(t *testing.T, exe, libgoa, libgoh string, buildcmd ...string) {\n \n var badLineRegexp = regexp.MustCompile(`(?m)^#line [0-9]+ \"/.*$`)\n \n-// checkIsExecutable verifies that exe exists and has execute permission.\n-//\n-// (https://golang.org/issue/49693 notes failures with \"no such file or\n-// directory\", so we want to double-check that the executable actually exists\n-// immediately after we build it in order to better understand that failure\n-// mode.)\n-func checkIsExecutable(t *testing.T, exe string) {\n-\tt.Helper()\n-\tfi, err := os.Stat(exe)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif runtime.GOOS == \"windows\" {\n-\t\t// os.File doesn't check the \"execute\" permission on Windows files\n-\t\t// and as a result doesn't set that bit in a file's permissions.\n-\t\t// Assume that if the file exists it is \u201cexecutable enough\u201d.\n-\t\treturn\n-\t}\n-\tif fi.Mode()&0111 == 0 {\n-\t\tt.Fatalf(\"%s is not executable: %0o\", exe, fi.Mode()&fs.ModePerm)\n-\t}\n-}\n-\n // checkLineComments checks that the export header generated by\n // -buildmode=c-archive doesn't have any absolute paths in the #line\n // comments. We don't want those paths because they are unhelpful for\n@@ -964,7 +943,6 @@ func TestSIGPROF(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tcheckIsExecutable(t, \"./testp6\"+exeSuffix)\n \n \targv := cmdToRun(\"./testp6\")\n \tcmd = exec.Command(argv[0], argv[1:]...)\n@@ -1113,7 +1091,6 @@ func TestManyCalls(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tcheckIsExecutable(t, \"./testp7\"+exeSuffix)\n \n \targv := cmdToRun(\"./testp7\")\n \tcmd = exec.Command(argv[0], argv[1:]...)\n@@ -1170,7 +1147,6 @@ func TestPreemption(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tcheckIsExecutable(t, \"./testp8\"+exeSuffix)\n \n \targv := cmdToRun(\"./testp8\")\n \tcmd = exec.Command(argv[0], argv[1:]...)"}, {"sha": "c9e9e5fe63e4a53222b442c3db6f846a853d3b0d", "filename": "libgo/misc/cgo/testcshared/cshared_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fcshared_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fcshared_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fcshared_test.go?ref=20a33efdf32bf0aedcb0c9813ddc7572bb1ab8c7", "patch": "@@ -117,6 +117,9 @@ func testMain(m *testing.M) int {\n \t}\n \tcc = append(cc, \"-I\", filepath.Join(\"pkg\", libgodir))\n \n+\t// Force reallocation (and avoid aliasing bugs) for parallel tests that append to cc.\n+\tcc = cc[:len(cc):len(cc)]\n+\n \tif GOOS == \"windows\" {\n \t\texeSuffix = \".exe\"\n \t}"}]}