{"sha": "68e743090df65d936305620bacfa1e766011d027", "node_id": "C_kwDOANBUbNoAKDY4ZTc0MzA5MGRmNjVkOTM2MzA1NjIwYmFjZmExZTc2NjAxMWQwMjc", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-10-19T12:05:54Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-02-21T11:36:37Z"}, "message": "gccrs: rust: Replace uses of ASTFragment -> Fragment\n\ngcc/rust/ChangeLog:\n\n\t* ast/rust-ast.h (class ASTFragment): Remove old ASTFragment class.\n\t* ast/rust-macro.h (class MacroRulesDefinition): Use new Fragment API.\n\t* expand/rust-attribute-visitor.h: Likewise.\n\t* expand/rust-macro-builtins.cc (macro_end_token): Likewise.\n\t(MacroBuiltin::assert): Likewise.\n\t(MacroBuiltin::file): Likewise.\n\t(MacroBuiltin::column): Likewise.\n\t(MacroBuiltin::include_bytes): Likewise.\n\t(MacroBuiltin::include_str): Likewise.\n\t(MacroBuiltin::compile_error): Likewise.\n\t(MacroBuiltin::concat): Likewise.\n\t(MacroBuiltin::env): Likewise.\n\t(MacroBuiltin::cfg): Likewise.\n\t(MacroBuiltin::include): Likewise.\n\t(MacroBuiltin::line): Likewise.\n\t* expand/rust-macro-builtins.h: Likewise.\n\t* expand/rust-macro-expand.cc (MacroExpander::expand_decl_macro): Likewise.\n\t(MacroExpander::expand_invoc): Likewise.\n\t(MacroExpander::match_repetition): Likewise.\n\t(parse_many): Likewise.\n\t(transcribe_many_items): Likewise.\n\t(transcribe_many_ext): Likewise.\n\t(transcribe_many_trait_items): Likewise.\n\t(transcribe_many_impl_items): Likewise.\n\t(transcribe_many_trait_impl_items): Likewise.\n\t(transcribe_expression): Likewise.\n\t(transcribe_type): Likewise.\n\t(transcribe_on_delimiter): Likewise.\n\t(tokens_to_str): Likewise.\n\t* expand/rust-macro-expand.h (struct MacroExpander): Likewise.\n\t* util/rust-hir-map.cc (Mappings::insert_macro_def): Likewise.", "tree": {"sha": "393963bc4ff61edccce35f726e41b13c1841d4d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/393963bc4ff61edccce35f726e41b13c1841d4d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68e743090df65d936305620bacfa1e766011d027", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e743090df65d936305620bacfa1e766011d027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68e743090df65d936305620bacfa1e766011d027", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e743090df65d936305620bacfa1e766011d027/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2647e5e5ad109320339779474659a4f27135c78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2647e5e5ad109320339779474659a4f27135c78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2647e5e5ad109320339779474659a4f27135c78"}], "stats": {"total": 335, "additions": 100, "deletions": 235}, "files": [{"sha": "3d602b1a3798a7932e4b0b2206bc83f068e6bf59", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=68e743090df65d936305620bacfa1e766011d027", "patch": "@@ -1858,138 +1858,6 @@ class SingleASTNode\n   }\n };\n \n-/* Basically, a \"fragment\" that can be incorporated into the AST, created as\n- * a result of macro expansion. Really annoying to work with due to the fact\n- * that macros can really expand to anything. As such, horrible representation\n- * at the moment. */\n-class ASTFragment\n-{\n-private:\n-  /* basic idea: essentially, a vector of tagged unions of different AST node\n-   * types. Now, this could actually be stored without a tagged union if the\n-   * different AST node types had a unified parent, but that would create\n-   * issues with the diamond problem or significant performance penalties. So\n-   * a tagged union had to be used instead. A vector is used to represent the\n-   * ability for a macro to expand to two statements, for instance. */\n-\n-  std::vector<SingleASTNode> nodes;\n-  bool fragment_is_error;\n-\n-  /**\n-   * We need to make a special case for Expression and Type fragments as only\n-   * one Node will be extracted from the `nodes` vector\n-   */\n-\n-  bool is_single_fragment () const { return nodes.size () == 1; }\n-\n-  bool is_single_fragment_of_kind (SingleASTNode::NodeType expected) const\n-  {\n-    return is_single_fragment () && nodes[0].get_kind () == expected;\n-  }\n-\n-  void assert_single_fragment (SingleASTNode::NodeType expected) const\n-  {\n-    static const std::map<SingleASTNode::NodeType, const char *> str_map = {\n-      {SingleASTNode::NodeType::IMPL, \"impl\"},\n-      {SingleASTNode::NodeType::ITEM, \"item\"},\n-      {SingleASTNode::NodeType::TYPE, \"type\"},\n-      {SingleASTNode::NodeType::EXPRESSION, \"expr\"},\n-      {SingleASTNode::NodeType::STMT, \"stmt\"},\n-      {SingleASTNode::NodeType::EXTERN, \"extern\"},\n-      {SingleASTNode::NodeType::TRAIT, \"trait\"},\n-      {SingleASTNode::NodeType::TRAIT_IMPL, \"trait impl\"},\n-    };\n-\n-    auto actual = nodes[0].get_kind ();\n-    auto fail = false;\n-\n-    if (!is_single_fragment ())\n-      {\n-\trust_error_at (Location (), \"fragment is not single\");\n-\tfail = true;\n-      }\n-\n-    if (actual != expected)\n-      {\n-\trust_error_at (\n-\t  Location (),\n-\t  \"invalid fragment operation: expected %qs node, got %qs node\",\n-\t  str_map.find (expected)->second,\n-\t  str_map.find (nodes[0].get_kind ())->second);\n-\tfail = true;\n-      }\n-\n-    rust_assert (!fail);\n-  }\n-\n-public:\n-  ASTFragment (std::vector<SingleASTNode> nodes, bool fragment_is_error = false)\n-    : nodes (std::move (nodes)), fragment_is_error (fragment_is_error)\n-  {\n-    if (fragment_is_error)\n-      rust_assert (nodes.empty ());\n-  }\n-\n-  ASTFragment (ASTFragment const &other)\n-    : fragment_is_error (other.fragment_is_error)\n-  {\n-    nodes.clear ();\n-    nodes.reserve (other.nodes.size ());\n-    for (auto &n : other.nodes)\n-      {\n-\tnodes.push_back (n);\n-      }\n-  }\n-\n-  ASTFragment &operator= (ASTFragment const &other)\n-  {\n-    fragment_is_error = other.fragment_is_error;\n-    nodes.clear ();\n-    nodes.reserve (other.nodes.size ());\n-    for (auto &n : other.nodes)\n-      {\n-\tnodes.push_back (n);\n-      }\n-\n-    return *this;\n-  }\n-\n-  static ASTFragment create_error () { return ASTFragment ({}, true); }\n-\n-  std::vector<SingleASTNode> &get_nodes () { return nodes; }\n-  bool is_error () const { return fragment_is_error; }\n-\n-  bool should_expand () const { return !is_error (); }\n-\n-  bool is_expression_fragment () const\n-  {\n-    return is_single_fragment_of_kind (SingleASTNode::NodeType::EXPRESSION);\n-  }\n-\n-  bool is_type_fragment () const\n-  {\n-    return is_single_fragment_of_kind (SingleASTNode::NodeType::TYPE);\n-  }\n-\n-  std::unique_ptr<Expr> take_expression_fragment ()\n-  {\n-    assert_single_fragment (SingleASTNode::NodeType::EXPRESSION);\n-    return nodes[0].take_expr ();\n-  }\n-\n-  std::unique_ptr<Type> take_type_fragment ()\n-  {\n-    assert_single_fragment (SingleASTNode::NodeType::TYPE);\n-    return nodes[0].take_type ();\n-  }\n-\n-  void accept_vis (ASTVisitor &vis)\n-  {\n-    for (auto &node : nodes)\n-      node.accept_vis (vis);\n-  }\n-};\n-\n // A crate AST object - holds all the data for a single compilation unit\n struct Crate\n {"}, {"sha": "fc4b5b82fb56b3f56dbdb8ace24cabed256899d0", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=68e743090df65d936305620bacfa1e766011d027", "patch": "@@ -21,6 +21,7 @@\n \n #include \"rust-system.h\"\n #include \"rust-ast.h\"\n+#include \"rust-ast-fragment.h\"\n #include \"rust-location.h\"\n \n namespace Rust {\n@@ -456,8 +457,7 @@ class MacroRulesDefinition : public MacroItem\n   std::vector<MacroRule> rules; // inlined form\n   Location locus;\n \n-  std::function<ASTFragment (Location, MacroInvocData &)>\n-    associated_transcriber;\n+  std::function<Fragment (Location, MacroInvocData &)> associated_transcriber;\n   // Since we can't compare std::functions, we need to use an extra boolean\n   bool is_builtin_rule;\n \n@@ -468,10 +468,10 @@ class MacroRulesDefinition : public MacroItem\n    * should make use of the actual rules. If the macro is builtin, then another\n    * associated transcriber should be used\n    */\n-  static ASTFragment dummy_builtin (Location, MacroInvocData &)\n+  static Fragment dummy_builtin (Location, MacroInvocData &)\n   {\n     gcc_unreachable ();\n-    return ASTFragment::create_error ();\n+    return Fragment::create_error ();\n   }\n \n   /* NOTE: in rustc, macro definitions are considered (and parsed as) a type\n@@ -491,9 +491,9 @@ class MacroRulesDefinition : public MacroItem\n       associated_transcriber (dummy_builtin), is_builtin_rule (false)\n   {}\n \n-  MacroRulesDefinition (Identifier builtin_name, DelimType delim_type,\n-\t\t\tstd::function<ASTFragment (Location, MacroInvocData &)>\n-\t\t\t  associated_transcriber)\n+  MacroRulesDefinition (\n+    Identifier builtin_name, DelimType delim_type,\n+    std::function<Fragment (Location, MacroInvocData &)> associated_transcriber)\n     : outer_attrs (std::vector<Attribute> ()), rule_name (builtin_name),\n       delim_type (delim_type), rules (std::vector<MacroRule> ()),\n       locus (Location ()), associated_transcriber (associated_transcriber),\n@@ -521,14 +521,14 @@ class MacroRulesDefinition : public MacroItem\n   const std::vector<MacroRule> &get_rules () const { return rules; }\n \n   bool is_builtin () const { return is_builtin_rule; }\n-  const std::function<ASTFragment (Location, MacroInvocData &)> &\n+  const std::function<Fragment (Location, MacroInvocData &)> &\n   get_builtin_transcriber () const\n   {\n     rust_assert (is_builtin ());\n     return associated_transcriber;\n   }\n   void set_builtin_transcriber (\n-    std::function<ASTFragment (Location, MacroInvocData &)> transcriber)\n+    std::function<Fragment (Location, MacroInvocData &)> transcriber)\n   {\n     associated_transcriber = transcriber;\n     is_builtin_rule = true;"}, {"sha": "6b562bd49b11ea3d22bc4f483593004b49160bbf", "filename": "gcc/rust/expand/rust-attribute-visitor.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h?ref=68e743090df65d936305620bacfa1e766011d027", "patch": "@@ -56,11 +56,11 @@ class AttrVisitor : public AST::ASTVisitor\n    * @return Either the expanded fragment or an empty errored-out fragment\n    * indicating an expansion failure.\n    */\n-  AST::ASTFragment expand_macro_fragment_recursive ()\n+  AST::Fragment expand_macro_fragment_recursive ()\n   {\n     auto fragment = expander.take_expanded_fragment (*this);\n     unsigned int original_depth = expander.expansion_depth;\n-    auto final_fragment = AST::ASTFragment ({}, true);\n+    auto final_fragment = AST::Fragment ({}, true);\n \n     while (fragment.should_expand ())\n       {"}, {"sha": "2a8a3f752f44ac57124e76ff8849d634401a75f1", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=68e743090df65d936305620bacfa1e766011d027", "patch": "@@ -66,7 +66,7 @@ macro_end_token (AST::DelimTokenTree &invoc_token_tree,\n \n /* Expand and extract an expression from the macro */\n \n-static inline AST::ASTFragment\n+static inline AST::Fragment\n try_expand_macro_expression (AST::Expr *expr, MacroExpander *expander)\n {\n   rust_assert (expander);\n@@ -264,25 +264,25 @@ load_file_bytes (const char *filename)\n }\n } // namespace\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::assert (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   rust_debug (\"assert!() called\");\n \n-  return AST::ASTFragment::create_error ();\n+  return AST::Fragment::create_error ();\n }\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::file (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto current_file\n     = Session::get_instance ().linemap->location_file (invoc_locus);\n   auto file_str = AST::SingleASTNode (make_string (invoc_locus, current_file));\n \n-  return AST::ASTFragment ({file_str});\n+  return AST::Fragment ({file_str});\n }\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::column (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto current_column\n@@ -292,14 +292,14 @@ MacroBuiltin::column (Location invoc_locus, AST::MacroInvocData &invoc)\n     new AST::LiteralExpr (std::to_string (current_column), AST::Literal::INT,\n \t\t\t  PrimitiveCoreType::CORETYPE_U32, {}, invoc_locus)));\n \n-  return AST::ASTFragment ({column_no});\n+  return AST::Fragment ({column_no});\n }\n \n /* Expand builtin macro include_bytes!(\"filename\"), which includes the contents\n    of the given file as reference to a byte array. Yields an expression of type\n    &'static [u8; N].  */\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::include_bytes (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   /* Get target filename from the macro invocation, which is treated as a path\n@@ -308,7 +308,7 @@ MacroBuiltin::include_bytes (Location invoc_locus, AST::MacroInvocData &invoc)\n     = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   std::string target_filename\n     = source_relative_path (lit_expr->as_string (), invoc_locus);\n@@ -335,14 +335,14 @@ MacroBuiltin::include_bytes (Location invoc_locus, AST::MacroInvocData &invoc)\n     new AST::BorrowExpr (std::move (array), false, false, {}, invoc_locus));\n \n   auto node = AST::SingleASTNode (std::move (borrow));\n-  return AST::ASTFragment ({node});\n+  return AST::Fragment ({node});\n }\n \n /* Expand builtin macro include_str!(\"filename\"), which includes the contents\n    of the given file as a string. The file must be UTF-8 encoded. Yields an\n    expression of type &'static str.  */\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::include_str (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   /* Get target filename from the macro invocation, which is treated as a path\n@@ -351,7 +351,7 @@ MacroBuiltin::include_str (Location invoc_locus, AST::MacroInvocData &invoc)\n     = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   std::string target_filename\n     = source_relative_path (lit_expr->as_string (), invoc_locus);\n@@ -362,30 +362,30 @@ MacroBuiltin::include_str (Location invoc_locus, AST::MacroInvocData &invoc)\n   std::string str ((const char *) &bytes[0], bytes.size ());\n \n   auto node = AST::SingleASTNode (make_string (invoc_locus, str));\n-  return AST::ASTFragment ({node});\n+  return AST::Fragment ({node});\n }\n \n /* Expand builtin macro compile_error!(\"error\"), which forces a compile error\n    during the compile time. */\n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::compile_error (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto lit_expr\n     = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   std::string error_string = lit_expr->as_string ();\n   rust_error_at (invoc_locus, \"%s\", error_string.c_str ());\n \n-  return AST::ASTFragment::create_error ();\n+  return AST::Fragment::create_error ();\n }\n \n /* Expand builtin macro concat!(), which joins all the literal parameters\n    into a string with no delimiter. */\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::concat (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto invoc_token_tree = invoc.get_delim_tok_tree ();\n@@ -427,16 +427,16 @@ MacroBuiltin::concat (Location invoc_locus, AST::MacroInvocData &invoc)\n   parser.skip_token (last_token_id);\n \n   if (has_error)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   auto node = AST::SingleASTNode (make_string (invoc_locus, str));\n-  return AST::ASTFragment ({node});\n+  return AST::Fragment ({node});\n }\n \n /* Expand builtin macro env!(), which inspects an environment variable at\n    compile time. */\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::env (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto invoc_token_tree = invoc.get_delim_tok_tree ();\n@@ -451,19 +451,19 @@ MacroBuiltin::env (Location invoc_locus, AST::MacroInvocData &invoc)\n   auto expanded_expr = try_expand_many_expr (parser, invoc_locus, last_token_id,\n \t\t\t\t\t     invoc.get_expander (), has_error);\n   if (has_error)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n   if (expanded_expr.size () < 1 || expanded_expr.size () > 2)\n     {\n       rust_error_at (invoc_locus, \"env! takes 1 or 2 arguments\");\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n   if (expanded_expr.size () > 0)\n     {\n       if (!(lit_expr\n \t    = try_extract_string_literal_from_fragment (invoc_locus,\n \t\t\t\t\t\t\texpanded_expr[0])))\n \t{\n-\t  return AST::ASTFragment::create_error ();\n+\t  return AST::Fragment::create_error ();\n \t}\n     }\n   if (expanded_expr.size () > 1)\n@@ -472,7 +472,7 @@ MacroBuiltin::env (Location invoc_locus, AST::MacroInvocData &invoc)\n \t    = try_extract_string_literal_from_fragment (invoc_locus,\n \t\t\t\t\t\t\texpanded_expr[1])))\n \t{\n-\t  return AST::ASTFragment::create_error ();\n+\t  return AST::Fragment::create_error ();\n \t}\n     }\n \n@@ -487,14 +487,14 @@ MacroBuiltin::env (Location invoc_locus, AST::MacroInvocData &invoc)\n \t\t       lit_expr->as_string ().c_str ());\n       else\n \trust_error_at (invoc_locus, \"%s\", error_expr->as_string ().c_str ());\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n \n   auto node = AST::SingleASTNode (make_string (invoc_locus, env_value));\n-  return AST::ASTFragment ({node});\n+  return AST::Fragment ({node});\n }\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::cfg (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   // only parse if not already parsed\n@@ -519,21 +519,21 @@ MacroBuiltin::cfg (Location invoc_locus, AST::MacroInvocData &invoc)\n   /* TODO: assuming that cfg! macros can only have one meta item inner, like cfg\n    * attributes */\n   if (invoc.get_meta_items ().size () != 1)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   bool result = invoc.get_meta_items ()[0]->check_cfg_predicate (\n     Session::get_instance ());\n   auto literal_exp = AST::SingleASTNode (std::unique_ptr<AST::Expr> (\n     new AST::LiteralExpr (result ? \"true\" : \"false\", AST::Literal::BOOL,\n \t\t\t  PrimitiveCoreType::CORETYPE_BOOL, {}, invoc_locus)));\n \n-  return AST::ASTFragment ({literal_exp});\n+  return AST::Fragment ({literal_exp});\n }\n \n /* Expand builtin macro include!(), which includes a source file at the current\n  scope compile time. */\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   /* Get target filename from the macro invocation, which is treated as a path\n@@ -542,7 +542,7 @@ MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n     = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   std::string filename\n     = source_relative_path (lit_expr->as_string (), invoc_locus);\n@@ -556,7 +556,7 @@ MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n     {\n       rust_error_at (lit_expr->get_locus (),\n \t\t     \"cannot open included file %qs: %m\", target_filename);\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n \n   rust_debug (\"Attempting to parse included file %s\", target_filename);\n@@ -574,7 +574,7 @@ MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n     {\n       // inform the user that the errors above are from a included file\n       rust_inform (invoc_locus, \"included from here\");\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n \n   std::vector<AST::SingleASTNode> nodes{};\n@@ -584,10 +584,10 @@ MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n       nodes.push_back (node);\n     }\n \n-  return AST::ASTFragment (nodes);\n+  return AST::Fragment (nodes);\n }\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::line (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto current_line\n@@ -597,7 +597,7 @@ MacroBuiltin::line (Location invoc_locus, AST::MacroInvocData &invoc)\n     new AST::LiteralExpr (std::to_string (current_line), AST::Literal::INT,\n \t\t\t  PrimitiveCoreType::CORETYPE_U32, {}, invoc_locus)));\n \n-  return AST::ASTFragment ({line_no});\n+  return AST::Fragment ({line_no});\n }\n \n } // namespace Rust"}, {"sha": "c65bd940189035011be56f9bdded473ab41bb82e", "filename": "gcc/rust/expand/rust-macro-builtins.h", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h?ref=68e743090df65d936305620bacfa1e766011d027", "patch": "@@ -20,6 +20,7 @@\n #define RUST_MACRO_BUILTINS_H\n \n #include \"rust-ast.h\"\n+#include \"rust-ast-fragment.h\"\n #include \"rust-location.h\"\n \n /**\n@@ -61,6 +62,7 @@\n \n /* If assert is defined as a macro this file will not parse, so undefine this\n    before continuing.  */\n+// TODO: Rename all functions here `*_handler`\n #ifdef assert\n #undef assert\n #endif\n@@ -69,38 +71,34 @@ namespace Rust {\n class MacroBuiltin\n {\n public:\n-  static AST::ASTFragment assert (Location invoc_locus,\n-\t\t\t\t  AST::MacroInvocData &invoc);\n-\n-  static AST::ASTFragment file (Location invoc_locus,\n-\t\t\t\tAST::MacroInvocData &invoc);\n+  static AST::Fragment assert (Location invoc_locus,\n+\t\t\t       AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment column (Location invoc_locus,\n-\t\t\t\t  AST::MacroInvocData &invoc);\n+  static AST::Fragment file (Location invoc_locus, AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment include_bytes (Location invoc_locus,\n-\t\t\t\t\t AST::MacroInvocData &invoc);\n+  static AST::Fragment column (Location invoc_locus,\n+\t\t\t       AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment include_str (Location invoc_locus,\n-\t\t\t\t       AST::MacroInvocData &invoc);\n+  static AST::Fragment include_bytes (Location invoc_locus,\n+\t\t\t\t      AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment compile_error (Location invoc_locus,\n-\t\t\t\t\t AST::MacroInvocData &invoc);\n+  static AST::Fragment include_str (Location invoc_locus,\n+\t\t\t\t    AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment concat (Location invoc_locus,\n-\t\t\t\t  AST::MacroInvocData &invoc);\n+  static AST::Fragment compile_error (Location invoc_locus,\n+\t\t\t\t      AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment env (Location invoc_locus,\n+  static AST::Fragment concat (Location invoc_locus,\n \t\t\t       AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment cfg (Location invoc_locus,\n-\t\t\t       AST::MacroInvocData &invoc);\n+  static AST::Fragment env (Location invoc_locus, AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment include (Location invoc_locus,\n-\t\t\t\t   AST::MacroInvocData &invoc);\n+  static AST::Fragment cfg (Location invoc_locus, AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment line (Location invoc_locus,\n+  static AST::Fragment include (Location invoc_locus,\n \t\t\t\tAST::MacroInvocData &invoc);\n+\n+  static AST::Fragment line (Location invoc_locus, AST::MacroInvocData &invoc);\n };\n } // namespace Rust\n "}, {"sha": "0684a28787f302484608315110e92fc229285d39", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=68e743090df65d936305620bacfa1e766011d027", "patch": "@@ -26,7 +26,7 @@\n #include \"rust-early-name-resolver.h\"\n \n namespace Rust {\n-AST::ASTFragment\n+AST::Fragment\n MacroExpander::expand_decl_macro (Location invoc_locus,\n \t\t\t\t  AST::MacroInvocData &invoc,\n \t\t\t\t  AST::MacroRulesDefinition &rules_def,\n@@ -103,7 +103,7 @@ MacroExpander::expand_decl_macro (Location invoc_locus,\n       RichLocation r (invoc_locus);\n       r.add_range (rules_def.get_locus ());\n       rust_error_at (r, \"Failed to match any rule within macro\");\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n \n   return transcribe_rule (*matched_rule, invoc_token_tree, matched_fragments,\n@@ -139,7 +139,7 @@ MacroExpander::expand_invoc (AST::MacroInvocation &invoc, bool has_semicolon)\n   //      - else is unreachable\n   //  - derive container macro - unreachable\n \n-  auto fragment = AST::ASTFragment::create_error ();\n+  auto fragment = AST::Fragment::create_error ();\n   invoc_data.set_expander (this);\n \n   // lookup the rules\n@@ -707,7 +707,7 @@ MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n /**\n  * Helper function to refactor calling a parsing function 0 or more times\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n \t    std::function<AST::SingleASTNode ()> parse_fn)\n {\n@@ -723,13 +723,13 @@ parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n \t  for (auto err : parser.get_errors ())\n \t    err.emit_error ();\n \n-\t  return AST::ASTFragment::create_error ();\n+\t  return AST::Fragment::create_error ();\n \t}\n \n       nodes.emplace_back (std::move (node));\n     }\n \n-  return AST::ASTFragment (std::move (nodes));\n+  return AST::Fragment (std::move (nodes));\n }\n \n /**\n@@ -738,7 +738,7 @@ parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n  * @param parser Parser to extract items from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n {\n   return parse_many (parser, delimiter, [&parser] () {\n@@ -753,7 +753,7 @@ transcribe_many_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n  * @param parser Parser to extract items from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_ext (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n {\n   return parse_many (parser, delimiter, [&parser] () {\n@@ -768,7 +768,7 @@ transcribe_many_ext (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n  * @param parser Parser to extract items from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_trait_items (Parser<MacroInvocLexer> &parser,\n \t\t\t     TokenId &delimiter)\n {\n@@ -784,7 +784,7 @@ transcribe_many_trait_items (Parser<MacroInvocLexer> &parser,\n  * @param parser Parser to extract items from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_impl_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n {\n   return parse_many (parser, delimiter, [&parser] () {\n@@ -799,7 +799,7 @@ transcribe_many_impl_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n  * @param parser Parser to extract items from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_trait_impl_items (Parser<MacroInvocLexer> &parser,\n \t\t\t\t  TokenId &delimiter)\n {\n@@ -815,7 +815,7 @@ transcribe_many_trait_impl_items (Parser<MacroInvocLexer> &parser,\n  * @param parser Parser to extract statements from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_stmts (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n {\n   auto restrictions = ParseRestrictions ();\n@@ -835,30 +835,30 @@ transcribe_many_stmts (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n  *\n  * @param parser Parser to extract statements from\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_expression (Parser<MacroInvocLexer> &parser)\n {\n   auto expr = parser.parse_expr ();\n \n-  return AST::ASTFragment ({std::move (expr)});\n+  return AST::Fragment ({std::move (expr)});\n }\n \n /**\n  * Transcribe one type from a macro invocation\n  *\n  * @param parser Parser to extract statements from\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_type (Parser<MacroInvocLexer> &parser)\n {\n   auto type = parser.parse_type (true);\n   for (auto err : parser.get_errors ())\n     err.emit_error ();\n \n-  return AST::ASTFragment ({std::move (type)});\n+  return AST::Fragment ({std::move (type)});\n }\n \n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_on_delimiter (Parser<MacroInvocLexer> &parser, bool semicolon,\n \t\t\t AST::DelimType delimiter, TokenId last_token_id)\n {\n@@ -868,7 +868,7 @@ transcribe_on_delimiter (Parser<MacroInvocLexer> &parser, bool semicolon,\n     return transcribe_expression (parser);\n } // namespace Rust\n \n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_context (MacroExpander::ContextType ctx,\n \t\t    Parser<MacroInvocLexer> &parser, bool semicolon,\n \t\t    AST::DelimType delimiter, TokenId last_token_id)\n@@ -929,7 +929,7 @@ tokens_to_str (std::vector<std::unique_ptr<AST::Token>> &tokens)\n   return str;\n }\n \n-AST::ASTFragment\n+AST::Fragment\n MacroExpander::transcribe_rule (\n   AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n   std::map<std::string, MatchedFragmentContainer> &matched_fragments,\n@@ -951,7 +951,7 @@ MacroExpander::transcribe_rule (\n   rust_debug (\"substituted tokens: %s\",\n \t      tokens_to_str (substituted_tokens).c_str ());\n \n-  // parse it to an ASTFragment\n+  // parse it to an Fragment\n   MacroInvocLexer lex (std::move (substituted_tokens));\n   Parser<MacroInvocLexer> parser (lex);\n \n@@ -994,7 +994,7 @@ MacroExpander::transcribe_rule (\n     {\n       for (auto &err : parser.get_errors ())\n \trust_error_at (err.locus, \"%s\", err.message.c_str ());\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n \n   // are all the tokens used?"}, {"sha": "b0c0c23a0c384b930e2c060e8eb38de5770dc713", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=68e743090df65d936305620bacfa1e766011d027", "patch": "@@ -230,7 +230,7 @@ struct MacroExpander\n   MacroExpander (AST::Crate &crate, ExpansionCfg cfg, Session &session)\n     : cfg (cfg), crate (crate), session (session),\n       sub_stack (SubstitutionScope ()),\n-      expanded_fragment (AST::ASTFragment::create_error ()),\n+      expanded_fragment (AST::Fragment::create_error ()),\n       resolver (Resolver::Resolver::get ()),\n       mappings (Analysis::Mappings::get ())\n   {}\n@@ -246,10 +246,9 @@ struct MacroExpander\n   void expand_invoc (AST::MacroInvocation &invoc, bool has_semicolon);\n \n   // Expands a single declarative macro.\n-  AST::ASTFragment expand_decl_macro (Location locus,\n-\t\t\t\t      AST::MacroInvocData &invoc,\n-\t\t\t\t      AST::MacroRulesDefinition &rules_def,\n-\t\t\t\t      bool semicolon);\n+  AST::Fragment expand_decl_macro (Location locus, AST::MacroInvocData &invoc,\n+\t\t\t\t   AST::MacroRulesDefinition &rules_def,\n+\t\t\t\t   bool semicolon);\n \n   void expand_cfg_attrs (AST::AttrVec &attrs);\n   bool fails_cfg (const AST::AttrVec &attr) const;\n@@ -260,7 +259,7 @@ struct MacroExpander\n   bool try_match_rule (AST::MacroRule &match_rule,\n \t\t       AST::DelimTokenTree &invoc_token_tree);\n \n-  AST::ASTFragment transcribe_rule (\n+  AST::Fragment transcribe_rule (\n     AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n     std::map<std::string, MatchedFragmentContainer> &matched_fragments,\n     bool semicolon, ContextType ctx);\n@@ -314,16 +313,16 @@ struct MacroExpander\n \n   ContextType peek_context () { return context.back (); }\n \n-  void set_expanded_fragment (AST::ASTFragment &&fragment)\n+  void set_expanded_fragment (AST::Fragment &&fragment)\n   {\n     expanded_fragment = std::move (fragment);\n   }\n \n-  AST::ASTFragment take_expanded_fragment (AST::ASTVisitor &vis)\n+  AST::Fragment take_expanded_fragment (AST::ASTVisitor &vis)\n   {\n-    AST::ASTFragment old_fragment = std::move (expanded_fragment);\n+    AST::Fragment old_fragment = std::move (expanded_fragment);\n     auto accumulator = std::vector<AST::SingleASTNode> ();\n-    expanded_fragment = AST::ASTFragment::create_error ();\n+    expanded_fragment = AST::Fragment::create_error ();\n     auto early_name_resolver = Resolver::EarlyNameResolver ();\n \n     for (auto &node : old_fragment.get_nodes ())\n@@ -345,7 +344,7 @@ struct MacroExpander\n \t    auto new_nodes = expanded_fragment.get_nodes ();\n \t    std::move (new_nodes.begin (), new_nodes.end (),\n \t\t       std::back_inserter (accumulator));\n-\t    expanded_fragment = AST::ASTFragment (accumulator);\n+\t    expanded_fragment = AST::Fragment (accumulator);\n \t  }\n \texpansion_depth--;\n       }\n@@ -358,7 +357,7 @@ struct MacroExpander\n   Session &session;\n   SubstitutionScope sub_stack;\n   std::vector<ContextType> context;\n-  AST::ASTFragment expanded_fragment;\n+  AST::Fragment expanded_fragment;\n \n public:\n   Resolver::Resolver *resolver;"}, {"sha": "bee0682e9b41900e70bed03f7a73b6c8a75a3283", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e743090df65d936305620bacfa1e766011d027/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=68e743090df65d936305620bacfa1e766011d027", "patch": "@@ -840,8 +840,8 @@ Mappings::iterate_trait_items (\n void\n Mappings::insert_macro_def (AST::MacroRulesDefinition *macro)\n {\n-  static std::map<std::string, std::function<AST::ASTFragment (\n-\t\t\t\t Location, AST::MacroInvocData &)>>\n+  static std::map<\n+    std::string, std::function<AST::Fragment (Location, AST::MacroInvocData &)>>\n     builtin_macros = {\n       {\"assert\", MacroBuiltin::assert},\n       {\"file\", MacroBuiltin::file},"}]}