{"sha": "a9a5b8acd29597692a4df9323f790da0d7506c76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlhNWI4YWNkMjk1OTc2OTJhNGRmOTMyM2Y3OTBkYTBkNzUwNmM3Ng==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-04-06T09:25:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:25:29Z"}, "message": "sem_ch13.ads, [...] (Adjust_Record_For_Reverse_Bit_Order): Use First/Next_Component_Or_Discriminant\n\n2007-04-06  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch13.ads, sem_ch13.adb (Adjust_Record_For_Reverse_Bit_Order):\n\tUse First/Next_Component_Or_Discriminant\n\t(Analyze_Record_Representation_Clause):\n\tUse First/Next_Component_Or_Discriminant\n\t(Check_Component_Overlap): Use First/Next_Component_Or_Discriminant\n\t(Analyze_Attribute_Definition_Clause, case Value_Size): Reject\n\tdefinition if type is unconstrained.\n\t(Adjust_Record_For_Reverse_Bit_Order): New procedure\n\t(Analyze_Attribute_Definition_Clause): Split Is_Abstract flag into\n\tIs_Abstract_Subprogram and Is_Abstract_Type.\n\t(Adjust_Record_For_Reverse_Bit_Order): New procedure\n\n\t* repinfo.adb (List_Record_Info): Use First/\n\tNext_Component_Or_Discriminant.\n\n\t* style.ads, styleg-c.adb, styleg-c.ads (Check_Array_Attribute_Index):\n\tNew procedure.\n\n\t* stylesw.ads, stylesw.adb: Recognize new -gnatyA style switch\n\tInclude -gnatyA in default switches\n\n\t* opt.ads: (Warn_On_Non_Local_Exception): New flag\n\t(Warn_On_Reverse_Bit_Order): New flag\n\t(Extensions_Allowed): Update the documentation.\n\t(Warn_On_Questionable_Missing_Parens): Now on by default\n\n\t* usage.adb: Add documentation of -gnatw.x/X switches\n\tDocument new -gnatyA style switch\n\t-gnatq warnings are on by default\n\nFrom-SVN: r123590", "tree": {"sha": "5452d8d7f7de1a366e554e6d5ccd84c49ad180c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5452d8d7f7de1a366e554e6d5ccd84c49ad180c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9a5b8acd29597692a4df9323f790da0d7506c76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9a5b8acd29597692a4df9323f790da0d7506c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9a5b8acd29597692a4df9323f790da0d7506c76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9a5b8acd29597692a4df9323f790da0d7506c76/comments", "author": null, "committer": null, "parents": [{"sha": "2f41ec1a8fe5eab706ed223ab468de003d1995f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f41ec1a8fe5eab706ed223ab468de003d1995f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f41ec1a8fe5eab706ed223ab468de003d1995f0"}], "stats": {"total": 754, "additions": 537, "deletions": 217}, "files": [{"sha": "fb1fa0ed2171baa0fadc8ff494ba1c06100d109f", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=a9a5b8acd29597692a4df9323f790da0d7506c76", "patch": "@@ -430,7 +430,8 @@ package Opt is\n    Extensions_Allowed : Boolean := False;\n    --  GNAT\n    --  Set to True by switch -gnatX if GNAT specific language extensions\n-   --  are allowed. For example, \"limited with\" is a GNAT extension.\n+   --  are allowed. For example, the use of 'Constrained with objects of\n+   --  generic types is a GNAT extension.\n \n    type External_Casing_Type is (\n      As_Is,       -- External names cased as they appear in the Ada source\n@@ -1163,12 +1164,19 @@ package Opt is\n    --  variable that is at least partially uninitialized. Set to false to\n    --  suppress such warnings. The default is that such warnings are enabled.\n \n+   Warn_On_Non_Local_Exception : Boolean := True;\n+   --  GNAT\n+   --  Set to True to generate warnings for non-local exception raises and also\n+   --  handlers that can never handle a local raise. This warning is only ever\n+   --  generated if pragma Restrictions (No_Exception_Propagation) is set. The\n+   --  default is to generate the warnings if the restriction is set.\n+\n    Warn_On_Obsolescent_Feature : Boolean := False;\n    --  GNAT\n    --  Set to True to generate warnings on use of any feature in Annex or if a\n    --  subprogram is called for which a pragma Obsolescent applies.\n \n-   Warn_On_Questionable_Missing_Parens : Boolean := False;\n+   Warn_On_Questionable_Missing_Parens : Boolean := True;\n    --  GNAT\n    --  Set to True to generate warnings for cases where parenthese are missing\n    --  and the usage is questionable, because the intent is unclear.\n@@ -1178,6 +1186,12 @@ package Opt is\n    --  Set to True to generate warnings for redundant constructs (e.g. useless\n    --  assignments/conversions). The default is that this warning is disabled.\n \n+   Warn_On_Reverse_Bit_Order : Boolean := True;\n+   --  GNAT\n+   --  Set to True to generate warning (informational) messages for component\n+   --  clauses that are affected by non-standard bit-order. The default is\n+   --  that this warning is enabled.\n+\n    Warn_On_Unchecked_Conversion : Boolean := True;\n    --  GNAT\n    --  Set to True to generate warnings for unchecked conversions that may have"}, {"sha": "f32344291ac1a6a4dc413a45ff3291ad7ee9975f", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 115, "deletions": 122, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=a9a5b8acd29597692a4df9323f790da0d7506c76", "patch": "@@ -784,172 +784,165 @@ package body Repinfo is\n       Max_Name_Length := 0;\n       Max_Suni_Length   := 0;\n \n-      Comp := First_Entity (Ent);\n+      Comp := First_Component_Or_Discriminant (Ent);\n       while Present (Comp) loop\n-         if Ekind (Comp) = E_Component\n-           or else Ekind (Comp) = E_Discriminant\n-         then\n-            Get_Decoded_Name_String (Chars (Comp));\n-            Max_Name_Length := Natural'Max (Max_Name_Length, Name_Len);\n-\n-            Cfbit := Component_Bit_Offset (Comp);\n+         Get_Decoded_Name_String (Chars (Comp));\n+         Max_Name_Length := Natural'Max (Max_Name_Length, Name_Len);\n \n-            if Rep_Not_Constant (Cfbit) then\n-               UI_Image_Length := 2;\n+         Cfbit := Component_Bit_Offset (Comp);\n \n-            else\n-               --  Complete annotation in case not done\n+         if Rep_Not_Constant (Cfbit) then\n+            UI_Image_Length := 2;\n \n-               Set_Normalized_Position (Comp, Cfbit / SSU);\n-               Set_Normalized_First_Bit (Comp, Cfbit mod SSU);\n+         else\n+            --  Complete annotation in case not done\n \n-               Sunit := Cfbit / SSU;\n-               UI_Image (Sunit);\n-            end if;\n+            Set_Normalized_Position (Comp, Cfbit / SSU);\n+            Set_Normalized_First_Bit (Comp, Cfbit mod SSU);\n \n-            --  If the record is not packed, then we know that all fields whose\n-            --  position is not specified have a starting normalized bit\n-            --  position of zero\n+            Sunit := Cfbit / SSU;\n+            UI_Image (Sunit);\n+         end if;\n \n-            if Unknown_Normalized_First_Bit (Comp)\n-              and then not Is_Packed (Ent)\n-            then\n-               Set_Normalized_First_Bit (Comp, Uint_0);\n-            end if;\n+         --  If the record is not packed, then we know that all fields whose\n+         --  position is not specified have a starting normalized bit position\n+         --  of zero.\n \n-            Max_Suni_Length :=\n-              Natural'Max (Max_Suni_Length, UI_Image_Length);\n+         if Unknown_Normalized_First_Bit (Comp)\n+           and then not Is_Packed (Ent)\n+         then\n+            Set_Normalized_First_Bit (Comp, Uint_0);\n          end if;\n \n-         Comp := Next_Entity (Comp);\n+         Max_Suni_Length :=\n+           Natural'Max (Max_Suni_Length, UI_Image_Length);\n+\n+         Next_Component_Or_Discriminant (Comp);\n       end loop;\n \n       --  Second loop does actual output based on those values\n \n-      Comp := First_Entity (Ent);\n+      Comp := First_Component_Or_Discriminant (Ent);\n       while Present (Comp) loop\n-         if Ekind (Comp) = E_Component\n-           or else Ekind (Comp) = E_Discriminant\n-         then\n-            declare\n-               Esiz : constant Uint := Esize (Comp);\n-               Bofs : constant Uint := Component_Bit_Offset (Comp);\n-               Npos : constant Uint := Normalized_Position (Comp);\n-               Fbit : constant Uint := Normalized_First_Bit (Comp);\n-               Lbit : Uint;\n+         declare\n+            Esiz : constant Uint := Esize (Comp);\n+            Bofs : constant Uint := Component_Bit_Offset (Comp);\n+            Npos : constant Uint := Normalized_Position (Comp);\n+            Fbit : constant Uint := Normalized_First_Bit (Comp);\n+            Lbit : Uint;\n+\n+         begin\n+            Write_Str (\"   \");\n+            Get_Decoded_Name_String (Chars (Comp));\n+            Set_Casing (Unit_Casing);\n+            Write_Str (Name_Buffer (1 .. Name_Len));\n \n-            begin\n-               Write_Str (\"   \");\n-               Get_Decoded_Name_String (Chars (Comp));\n-               Set_Casing (Unit_Casing);\n-               Write_Str (Name_Buffer (1 .. Name_Len));\n+            for J in 1 .. Max_Name_Length - Name_Len loop\n+               Write_Char (' ');\n+            end loop;\n \n-               for J in 1 .. Max_Name_Length - Name_Len loop\n-                  Write_Char (' ');\n-               end loop;\n+            Write_Str (\" at \");\n \n-               Write_Str (\" at \");\n+            if Known_Static_Normalized_Position (Comp) then\n+               UI_Image (Npos);\n+               Spaces (Max_Suni_Length - UI_Image_Length);\n+               Write_Str (UI_Image_Buffer (1 .. UI_Image_Length));\n \n-               if Known_Static_Normalized_Position (Comp) then\n-                  UI_Image (Npos);\n-                  Spaces (Max_Suni_Length - UI_Image_Length);\n-                  Write_Str (UI_Image_Buffer (1 .. UI_Image_Length));\n+            elsif Known_Component_Bit_Offset (Comp)\n+              and then List_Representation_Info = 3\n+            then\n+               Spaces (Max_Suni_Length - 2);\n+               Write_Str (\"bit offset\");\n+               Write_Val (Bofs, Paren => True);\n+               Write_Str (\" size in bits = \");\n+               Write_Val (Esiz, Paren => True);\n+               Write_Eol;\n+               goto Continue;\n+\n+            elsif Known_Normalized_Position (Comp)\n+              and then List_Representation_Info = 3\n+            then\n+               Spaces (Max_Suni_Length - 2);\n+               Write_Val (Npos);\n \n-               elsif Known_Component_Bit_Offset (Comp)\n-                 and then List_Representation_Info = 3\n-               then\n-                  Spaces (Max_Suni_Length - 2);\n-                  Write_Str (\"bit offset\");\n-                  Write_Val (Bofs, Paren => True);\n-                  Write_Str (\" size in bits = \");\n-                  Write_Val (Esiz, Paren => True);\n-                  Write_Eol;\n+            else\n+               --  For the packed case, we don't know the bit positions if we\n+               --  don't know the starting position!\n+\n+               if Is_Packed (Ent) then\n+                  Write_Line (\"?? range  ? .. ??;\");\n                   goto Continue;\n \n-               elsif Known_Normalized_Position (Comp)\n-                 and then List_Representation_Info = 3\n-               then\n-                  Spaces (Max_Suni_Length - 2);\n-                  Write_Val (Npos);\n+               --  Otherwise we can continue\n \n                else\n-                  --  For the packed case, we don't know the bit positions\n-                  --  if we don't know the starting position!\n-\n-                  if Is_Packed (Ent) then\n-                     Write_Line (\"?? range  ? .. ??;\");\n-                     goto Continue;\n-\n-                  --  Otherwise we can continue\n-\n-                  else\n-                     Write_Str (\"??\");\n-                  end if;\n+                  Write_Str (\"??\");\n                end if;\n+            end if;\n \n-               Write_Str (\" range  \");\n-               UI_Write (Fbit);\n-               Write_Str (\" .. \");\n+            Write_Str (\" range  \");\n+            UI_Write (Fbit);\n+            Write_Str (\" .. \");\n \n-               --  Allowing Uint_0 here is a kludge, really this should be a\n-               --  fine Esize value but currently it means unknown, except that\n-               --  we know after gigi has back annotated that a size of zero is\n-               --  real, since otherwise gigi back annotates using No_Uint as\n-               --  the value to indicate unknown).\n+            --  Allowing Uint_0 here is a kludge, really this should be a\n+            --  fine Esize value but currently it means unknown, except that\n+            --  we know after gigi has back annotated that a size of zero is\n+            --  real, since otherwise gigi back annotates using No_Uint as\n+            --  the value to indicate unknown).\n \n-               if (Esize (Comp) = Uint_0 or else Known_Static_Esize (Comp))\n-                 and then Known_Static_Normalized_First_Bit (Comp)\n-               then\n-                  Lbit := Fbit + Esiz - 1;\n+            if (Esize (Comp) = Uint_0 or else Known_Static_Esize (Comp))\n+              and then Known_Static_Normalized_First_Bit (Comp)\n+            then\n+               Lbit := Fbit + Esiz - 1;\n \n-                  if Lbit < 10 then\n-                     Write_Char (' ');\n-                  end if;\n+               if Lbit < 10 then\n+                  Write_Char (' ');\n+               end if;\n \n-                  UI_Write (Lbit);\n+               UI_Write (Lbit);\n \n-               --  The test for Esize (Comp) not being Uint_0 here is a kludge.\n-               --  Officially a value of zero for Esize means unknown, but here\n-               --  we use the fact that we know that gigi annotates Esize with\n-               --  No_Uint, not Uint_0. Really everyone should use No_Uint???\n+            --  The test for Esize (Comp) not being Uint_0 here is a kludge.\n+            --  Officially a value of zero for Esize means unknown, but here\n+            --  we use the fact that we know that gigi annotates Esize with\n+            --  No_Uint, not Uint_0. Really everyone should use No_Uint???\n \n-               elsif List_Representation_Info < 3\n-                 or else (Esize (Comp) /= Uint_0 and then Unknown_Esize (Comp))\n-               then\n-                  Write_Str (\"??\");\n+            elsif List_Representation_Info < 3\n+              or else (Esize (Comp) /= Uint_0 and then Unknown_Esize (Comp))\n+            then\n+               Write_Str (\"??\");\n \n-               else -- List_Representation >= 3 and Known_Esize (Comp)\n+            --  List_Representation >= 3 and Known_Esize (Comp)\n \n-                  Write_Val (Esiz, Paren => True);\n+            else\n+               Write_Val (Esiz, Paren => True);\n \n-                  --  If in front end layout mode, then dynamic size is stored\n-                  --  in storage units, so renormalize for output\n+               --  If in front end layout mode, then dynamic size is stored\n+               --  in storage units, so renormalize for output\n \n-                  if not Back_End_Layout then\n-                     Write_Str (\" * \");\n-                     Write_Int (SSU);\n-                  end if;\n+               if not Back_End_Layout then\n+                  Write_Str (\" * \");\n+                  Write_Int (SSU);\n+               end if;\n \n-                  --  Add appropriate first bit offset\n+               --  Add appropriate first bit offset\n \n-                  if Fbit = 0 then\n-                     Write_Str (\" - 1\");\n+               if Fbit = 0 then\n+                  Write_Str (\" - 1\");\n \n-                  elsif Fbit = 1 then\n-                     null;\n+               elsif Fbit = 1 then\n+                  null;\n \n-                  else\n-                     Write_Str (\" + \");\n-                     Write_Int (UI_To_Int (Fbit) - 1);\n-                  end if;\n+               else\n+                  Write_Str (\" + \");\n+                  Write_Int (UI_To_Int (Fbit) - 1);\n                end if;\n+            end if;\n \n-               Write_Line (\";\");\n-            end;\n-         end if;\n+            Write_Line (\";\");\n+         end;\n \n       <<Continue>>\n-         Comp := Next_Entity (Comp);\n+         Next_Component_Or_Discriminant (Comp);\n       end loop;\n \n       Write_Line (\"end record;\");"}, {"sha": "e6925f378668fe5e787354084258d81399a964f6", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 288, "deletions": 38, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=a9a5b8acd29597692a4df9323f790da0d7506c76", "patch": "@@ -166,6 +166,265 @@ package body Sem_Ch13 is\n       return Empty;\n    end Address_Aliased_Entity;\n \n+   -----------------------------------------\n+   -- Adjust_Record_For_Reverse_Bit_Order --\n+   -----------------------------------------\n+\n+   procedure Adjust_Record_For_Reverse_Bit_Order (R : Entity_Id) is\n+      Max_Machine_Scalar_Size : constant Uint :=\n+                                  UI_From_Int\n+                                    (Standard_Long_Long_Integer_Size);\n+      --  We use this as the maximum machine scalar size in the sense of AI-133\n+\n+      Num_CC : Natural;\n+      Comp   : Entity_Id;\n+      SSU    : constant Uint := UI_From_Int (System_Storage_Unit);\n+\n+   begin\n+      --  This first loop through components does two things. First it deals\n+      --  with the case of components with component clauses whose length is\n+      --  greater than the maximum machine scalar size (either accepting them\n+      --  or rejecting as needed). Second, it counts the number of components\n+      --  with component clauses whose length does not exceed this maximum for\n+      --  later processing.\n+\n+      Num_CC := 0;\n+      Comp   := First_Component_Or_Discriminant (R);\n+      while Present (Comp) loop\n+         declare\n+            CC    : constant Node_Id := Component_Clause (Comp);\n+            Fbit  : constant Uint    := Static_Integer (First_Bit (CC));\n+\n+         begin\n+            if Present (CC) then\n+\n+               --  Case of component with size > max machine scalar\n+\n+               if Esize (Comp) > Max_Machine_Scalar_Size then\n+\n+                  --  Must begin on byte boundary\n+\n+                  if Fbit mod SSU /= 0 then\n+                     Error_Msg_N\n+                       (\"illegal first bit value for reverse bit order\",\n+                        First_Bit (CC));\n+                     Error_Msg_Uint_1 := SSU;\n+                     Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n+\n+                     Error_Msg_N\n+                       (\"\\must be a multiple of ^ if size greater than ^\",\n+                        First_Bit (CC));\n+\n+                  --  Must end on byte boundary\n+\n+                  elsif Esize (Comp) mod SSU /= 0 then\n+                     Error_Msg_N\n+                       (\"illegal last bit value for reverse bit order\",\n+                        Last_Bit (CC));\n+                     Error_Msg_Uint_1 := SSU;\n+                     Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n+\n+                     Error_Msg_N\n+                       (\"\\must be a multiple of ^ if size greater than ^\",\n+                        Last_Bit (CC));\n+\n+                  --  OK, give warning if enabled\n+\n+                  elsif Warn_On_Reverse_Bit_Order then\n+                     Error_Msg_N\n+                       (\"multi-byte field specified with non-standard\"\n+                        & \" Bit_Order?\", CC);\n+\n+                     if Bytes_Big_Endian then\n+                        Error_Msg_N\n+                          (\"\\bytes are not reversed \"\n+                           & \"(component is big-endian)?\", CC);\n+                     else\n+                        Error_Msg_N\n+                          (\"\\bytes are not reversed \"\n+                           & \"(component is little-endian)?\", CC);\n+                     end if;\n+                  end if;\n+\n+               --  Case where size is not greater than max machine scalar.\n+               --  For now, we just count these.\n+\n+               else\n+                  Num_CC := Num_CC + 1;\n+               end if;\n+            end if;\n+         end;\n+\n+         Next_Component_Or_Discriminant (Comp);\n+      end loop;\n+\n+      --  We need to sort the component clauses on the basis of the Position\n+      --  values in the clause, so we can group clauses with the same Position\n+      --  together to determine the relevant machine scalar size.\n+\n+      declare\n+         Comps : array (0 .. Num_CC) of Entity_Id;\n+         --  Array to collect component and discrimninant entities. The data\n+         --  starts at index 1, the 0'th entry is for GNAT.Heap_Sort_A.\n+\n+         function CP_Lt (Op1, Op2 : Natural) return Boolean;\n+         --  Compare routine for Sort (See GNAT.Heap_Sort_A)\n+\n+         procedure CP_Move (From : Natural; To : Natural);\n+         --  Move routine for Sort (see GNAT.Heap_Sort_A)\n+\n+         Start : Natural;\n+         Stop  : Natural;\n+         --  Start and stop positions in component list of set of components\n+         --  with the same starting position (that constitute components in\n+         --  a single machine scalar).\n+\n+         MaxL : Uint;\n+         --  Maximum last bit value of any component in this set\n+\n+         MSS : Uint;\n+         --  Corresponding machine scalar size\n+\n+         -----------\n+         -- CP_Lt --\n+         -----------\n+\n+         function CP_Lt (Op1, Op2 : Natural) return Boolean is\n+         begin\n+            return Position (Component_Clause (Comps (Op1))) <\n+                   Position (Component_Clause (Comps (Op2)));\n+         end CP_Lt;\n+\n+         -------------\n+         -- CP_Move --\n+         -------------\n+\n+         procedure CP_Move (From : Natural; To : Natural) is\n+         begin\n+            Comps (To) := Comps (From);\n+         end CP_Move;\n+\n+      begin\n+         --  Collect the component clauses\n+\n+         Num_CC := 0;\n+         Comp   := First_Component_Or_Discriminant (R);\n+         while Present (Comp) loop\n+            if Present (Component_Clause (Comp))\n+              and then Esize (Comp) <= Max_Machine_Scalar_Size\n+            then\n+               Num_CC := Num_CC + 1;\n+               Comps (Num_CC) := Comp;\n+            end if;\n+\n+            Next_Component_Or_Discriminant (Comp);\n+         end loop;\n+\n+         --  Sort by ascending position number\n+\n+         Sort (Num_CC, CP_Move'Unrestricted_Access, CP_Lt'Unrestricted_Access);\n+\n+         --  We now have all the components whose size does not exceed the max\n+         --  machine scalar value, sorted by starting position. In this loop\n+         --  we gather groups of clauses starting at the same position, to\n+         --  process them in accordance with Ada 2005 AI-133.\n+\n+         Stop := 0;\n+         while Stop < Num_CC loop\n+            Start := Stop + 1;\n+            Stop  := Start;\n+            MaxL  :=\n+              Static_Integer (Last_Bit (Component_Clause (Comps (Start))));\n+            while Stop < Num_CC loop\n+               if Static_Integer\n+                    (Position (Component_Clause (Comps (Stop + 1)))) =\n+                  Static_Integer\n+                    (Position (Component_Clause (Comps (Stop))))\n+               then\n+                  Stop := Stop + 1;\n+                  MaxL :=\n+                    UI_Max\n+                      (MaxL,\n+                       Static_Integer\n+                         (Last_Bit (Component_Clause (Comps (Stop)))));\n+               else\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            --  Now we have a group of component clauses from Start to Stop\n+            --  whose positions are identical, and MaxL is the maximum last bit\n+            --  value of any of these components.\n+\n+            --  We need to determine the corresponding machine scalar size.\n+            --  This loop assumes that machine scalar sizes are even, and that\n+            --  each possible machine scalar has twice as many bits as the\n+            --  next smaller one.\n+\n+            MSS := Max_Machine_Scalar_Size;\n+            while MSS mod 2 = 0\n+              and then (MSS / 2) >= SSU\n+              and then (MSS / 2) > MaxL\n+            loop\n+               MSS := MSS / 2;\n+            end loop;\n+\n+            --  Here is where we fix up the Component_Bit_Offset value to\n+            --  account for the reverse bit order. Some examples of what needs\n+            --  to be done for the case of a machine scalar size of 8 are:\n+\n+            --    First_Bit .. Last_Bit     Component_Bit_Offset\n+            --      old          new          old       new\n+\n+            --     0 .. 0       7 .. 7         0         7\n+            --     0 .. 1       6 .. 7         0         6\n+            --     0 .. 2       5 .. 7         0         5\n+            --     0 .. 7       0 .. 7         0         4\n+\n+            --     1 .. 1       6 .. 6         1         6\n+            --     1 .. 4       3 .. 6         1         3\n+            --     4 .. 7       0 .. 3         4         0\n+\n+            --  The general rule is that the first bit is is obtained by\n+            --  subtracting the old ending bit from machine scalar size - 1.\n+\n+            for C in Start .. Stop loop\n+               declare\n+                  Comp : constant Entity_Id := Comps (C);\n+                  CC   : constant Node_Id   := Component_Clause (Comp);\n+                  LB   : constant Uint := Static_Integer (Last_Bit (CC));\n+                  NFB  : constant Uint := MSS - Uint_1 - LB;\n+                  NLB  : constant Uint := NFB + Esize (Comp) - 1;\n+                  Pos  : constant Uint := Static_Integer (Position (CC));\n+\n+               begin\n+                  if Warn_On_Reverse_Bit_Order then\n+                     Error_Msg_Uint_1 := MSS;\n+                     Error_Msg_N\n+                       (\"?reverse bit order in machine \" &\n+                       \"scalar of length^\", First_Bit (CC));\n+                     Error_Msg_Uint_1 := NFB;\n+                     Error_Msg_Uint_2 := NLB;\n+\n+                     if Bytes_Big_Endian then\n+                        Error_Msg_NE\n+                          (\"?\\big-endian range for component & is ^ .. ^\",\n+                           First_Bit (CC), Comp);\n+                     else\n+                        Error_Msg_NE\n+                          (\"?\\little-endian range for component & is ^ .. ^\",\n+                           First_Bit (CC), Comp);\n+                     end if;\n+                  end if;\n+\n+                  Set_Component_Bit_Offset (Comp, Pos * SSU + NFB);\n+                  Set_Normalized_First_Bit (Comp, NFB mod SSU);\n+               end;\n+            end loop;\n+         end loop;\n+      end;\n+   end Adjust_Record_For_Reverse_Bit_Order;\n+\n    --------------------------------------\n    -- Alignment_Check_For_Esize_Change --\n    --------------------------------------\n@@ -355,7 +614,7 @@ package body Sem_Ch13 is\n          end if;\n \n          if Present (Subp) then\n-            if Is_Abstract (Subp) then\n+            if Is_Abstract_Subprogram (Subp) then\n                Error_Msg_N (\"stream subprogram must not be abstract\", Expr);\n                return;\n             end if;\n@@ -926,12 +1185,12 @@ package body Sem_Ch13 is\n                   Etyp := Etype (U_Ent);\n                end if;\n \n-               --  Check size, note that Gigi is in charge of checking\n-               --  that the size of an array or record type is OK. Also\n-               --  we do not check the size in the ordinary fixed-point\n-               --  case, since it is too early to do so (there may be a\n-               --  subsequent small clause that affects the size). We can\n-               --  check the size if a small clause has already been given.\n+               --  Check size, note that Gigi is in charge of checking that the\n+               --  size of an array or record type is OK. Also we do not check\n+               --  the size in the ordinary fixed-point case, since it is too\n+               --  early to do so (there may be subsequent small clause that\n+               --  affects the size). We can check the size if a small clause\n+               --  has already been given.\n \n                if not Is_Ordinary_Fixed_Point_Type (U_Ent)\n                  or else Has_Small_Clause (U_Ent)\n@@ -945,9 +1204,9 @@ package body Sem_Ch13 is\n                if Is_Type (U_Ent) then\n                   Set_RM_Size (U_Ent, Size);\n \n-                  --  For scalar types, increase Object_Size to power of 2,\n-                  --  but not less than a storage unit in any case (i.e.,\n-                  --  normally this means it will be byte addressable).\n+                  --  For scalar types, increase Object_Size to power of 2, but\n+                  --  not less than a storage unit in any case (i.e., normally\n+                  --  this means it will be byte addressable).\n \n                   if Is_Scalar_Type (U_Ent) then\n                      if Size <= System_Storage_Unit then\n@@ -1294,6 +1553,12 @@ package body Sem_Ch13 is\n             then\n                Error_Msg_N (\"Value_Size already given for &\", Nam);\n \n+            elsif Is_Array_Type (U_Ent)\n+              and then not Is_Constrained (U_Ent)\n+            then\n+               Error_Msg_N\n+                 (\"Value_Size cannot be given for unconstrained array\", Nam);\n+\n             else\n                if Is_Elementary_Type (U_Ent) then\n                   Check_Size (Expr, U_Ent, Size, Biased);\n@@ -1837,17 +2102,10 @@ package body Sem_Ch13 is\n       --  Clear any existing component clauses for the type (this happens\n       --  with derived types, where we are now overriding the original)\n \n-      Fent := First_Entity (Rectype);\n-\n-      Comp := Fent;\n+      Comp := First_Component_Or_Discriminant (Rectype);\n       while Present (Comp) loop\n-         if Ekind (Comp) = E_Component\n-           or else Ekind (Comp) = E_Discriminant\n-         then\n-            Set_Component_Clause (Comp, Empty);\n-         end if;\n-\n-         Next_Entity (Comp);\n+         Set_Component_Clause (Comp, Empty);\n+         Next_Component_Or_Discriminant (Comp);\n       end loop;\n \n       --  All done if no component clauses\n@@ -1862,6 +2120,8 @@ package body Sem_Ch13 is\n       --  it at the start of the record (otherwise gigi may place it after\n       --  other fields that have rep clauses).\n \n+      Fent := First_Entity (Rectype);\n+\n       if Nkind (Fent) = N_Defining_Identifier\n         and then Chars (Fent) = Name_uTag\n       then\n@@ -2284,15 +2544,10 @@ package body Sem_Ch13 is\n       then\n          --  Nothing to do if at least one component with no component clause\n \n-         Comp := First_Entity (Rectype);\n+         Comp := First_Component_Or_Discriminant (Rectype);\n          while Present (Comp) loop\n-            if Ekind (Comp) = E_Component\n-              or else Ekind (Comp) = E_Discriminant\n-            then\n-               exit when No (Component_Clause (Comp));\n-            end if;\n-\n-            Next_Entity (Comp);\n+            exit when No (Component_Clause (Comp));\n+            Next_Component_Or_Discriminant (Comp);\n          end loop;\n \n          --  If we fall out of loop, all components have component clauses\n@@ -2306,19 +2561,14 @@ package body Sem_Ch13 is\n       --  Check missing components if Complete_Representation pragma appeared\n \n       if Present (CR_Pragma) then\n-         Comp := First_Entity (Rectype);\n+         Comp := First_Component_Or_Discriminant (Rectype);\n          while Present (Comp) loop\n-            if Ekind (Comp) = E_Component\n-                 or else\n-               Ekind (Comp) = E_Discriminant\n-            then\n-               if No (Component_Clause (Comp)) then\n-                  Error_Msg_NE\n-                    (\"missing component clause for &\", CR_Pragma, Comp);\n-               end if;\n+            if No (Component_Clause (Comp)) then\n+               Error_Msg_NE\n+                 (\"missing component clause for &\", CR_Pragma, Comp);\n             end if;\n \n-            Next_Entity (Comp);\n+            Next_Component_Or_Discriminant (Comp);\n          end loop;\n       end if;\n    end Analyze_Record_Representation_Clause;"}, {"sha": "1da73e2f1c061c6ea4ebb8ee5a7bad64572ed6ff", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=a9a5b8acd29597692a4df9323f790da0d7506c76", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,13 @@ package Sem_Ch13 is\n    procedure Analyze_Record_Representation_Clause       (N : Node_Id);\n    procedure Analyze_Code_Statement                     (N : Node_Id);\n \n+   procedure Adjust_Record_For_Reverse_Bit_Order (R : Entity_Id);\n+   --  Called from Freeze where R is a record entity for which reverse bit\n+   --  order is specified and there is at least one component clause. Adjusts\n+   --  component positions according to Ada 2005 AI-133. Note that this is only\n+   --  called in Ada 2005 mode. The Ada 95 handling for bit order is entirely\n+   --  contained in Freeze.\n+\n    procedure Initialize;\n    --  Initialize internal tables for new compilation\n "}, {"sha": "4dbc55cef630c815f9b6367b1168bb03ee1ec9dc", "filename": "gcc/ada/style.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fstyle.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fstyle.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyle.ads?ref=a9a5b8acd29597692a4df9323f790da0d7506c76", "patch": "@@ -65,6 +65,16 @@ package Style is\n      renames Style_Inst.Check_Apostrophe;\n    --  Called after scanning an apostrophe to check spacing\n \n+   procedure Check_Array_Attribute_Index\n+     (N  : Node_Id;\n+      E1 : Node_Id;\n+      D  : Int)\n+     renames Style_C_Inst.Check_Array_Attribute_Index;\n+   --  Called for an array attribute specifying an index number. N is the\n+   --  node for the attribute, and E1 is the index expression (Empty if none\n+   --  present). If E1 is present, it is known to be a static integer. D is\n+   --  the number of dimensions of the array.\n+\n    procedure Check_Arrow\n      renames Style_Inst.Check_Arrow;\n    --  Called after scanning out an arrow to check spacing"}, {"sha": "fa3690ea4277aa96184d1643ca4504efe249e765", "filename": "gcc/ada/styleg-c.adb", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fstyleg-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fstyleg-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyleg-c.adb?ref=a9a5b8acd29597692a4df9323f790da0d7506c76", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -67,6 +67,29 @@ package body Styleg.C is\n       end if;\n    end Body_With_No_Spec;\n \n+   ---------------------------------\n+   -- Check_Array_Attribute_Index --\n+   ---------------------------------\n+\n+   procedure Check_Array_Attribute_Index\n+     (N  : Node_Id;\n+      E1 : Node_Id;\n+      D  : Int)\n+   is\n+   begin\n+      if Style_Check_Array_Attribute_Index then\n+         if D = 1 and then Present (E1) then\n+            Error_Msg_N\n+              (\"(style) index number not allowed for one dimensional array\",\n+               E1);\n+         elsif D > 1 and then No (E1) then\n+            Error_Msg_N\n+              (\"(style) index number required for multi-dimensional array\",\n+               N);\n+         end if;\n+      end if;\n+   end Check_Array_Attribute_Index;\n+\n    ----------------------\n    -- Check_Identifier --\n    ----------------------"}, {"sha": "23072da91b85fc5c969b9086adcc154aafe65489", "filename": "gcc/ada/styleg-c.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fstyleg-c.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fstyleg-c.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyleg-c.ads?ref=a9a5b8acd29597692a4df9323f790da0d7506c76", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,6 +38,15 @@ package Styleg.C is\n    --  Called where N is a subprogram body node for a subprogram body\n    --  for which no spec was given, i.e. a body acting as its own spec.\n \n+   procedure Check_Array_Attribute_Index\n+     (N  : Node_Id;\n+      E1 : Node_Id;\n+      D  : Int);\n+   --  Called for an array attribute specifying an index number. N is the\n+   --  node for the attribute, and E1 is the index expression (Empty if none\n+   --  present). If E1 is present, it is known to be a static integer. D is\n+   --  the number of dimensions of the array.\n+\n    procedure Check_Identifier\n      (Ref : Node_Or_Entity_Id;\n       Def : Node_Or_Entity_Id);"}, {"sha": "b27d4e03409a89d6a52f55baaaa5fb4a9c5c536d", "filename": "gcc/ada/stylesw.adb", "status": "modified", "additions": 52, "deletions": 47, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fstylesw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fstylesw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.adb?ref=a9a5b8acd29597692a4df9323f790da0d7506c76", "patch": "@@ -35,36 +35,37 @@ package body Stylesw is\n \n    procedure Reset_Style_Check_Options is\n    begin\n-      Style_Check_Indentation         := 0;\n-      Style_Check_Attribute_Casing    := False;\n-      Style_Check_Blanks_At_End       := False;\n-      Style_Check_Blank_Lines         := False;\n-      Style_Check_Comments            := False;\n-      Style_Check_DOS_Line_Terminator := False;\n-      Style_Check_End_Labels          := False;\n-      Style_Check_Form_Feeds          := False;\n-      Style_Check_Horizontal_Tabs     := False;\n-      Style_Check_If_Then_Layout      := False;\n-      Style_Check_Keyword_Casing      := False;\n-      Style_Check_Layout              := False;\n-      Style_Check_Max_Line_Length     := False;\n-      Style_Check_Max_Nesting_Level   := False;\n-      Style_Check_Mode_In             := False;\n-      Style_Check_Order_Subprograms   := False;\n-      Style_Check_Pragma_Casing       := False;\n-      Style_Check_References          := False;\n-      Style_Check_Specs               := False;\n-      Style_Check_Standard            := False;\n-      Style_Check_Tokens              := False;\n-      Style_Check_Xtra_Parens         := False;\n+      Style_Check_Indentation           := 0;\n+      Style_Check_Array_Attribute_Index := False;\n+      Style_Check_Attribute_Casing      := False;\n+      Style_Check_Blanks_At_End         := False;\n+      Style_Check_Blank_Lines           := False;\n+      Style_Check_Comments              := False;\n+      Style_Check_DOS_Line_Terminator   := False;\n+      Style_Check_End_Labels            := False;\n+      Style_Check_Form_Feeds            := False;\n+      Style_Check_Horizontal_Tabs       := False;\n+      Style_Check_If_Then_Layout        := False;\n+      Style_Check_Keyword_Casing        := False;\n+      Style_Check_Layout                := False;\n+      Style_Check_Max_Line_Length       := False;\n+      Style_Check_Max_Nesting_Level     := False;\n+      Style_Check_Mode_In               := False;\n+      Style_Check_Order_Subprograms     := False;\n+      Style_Check_Pragma_Casing         := False;\n+      Style_Check_References            := False;\n+      Style_Check_Specs                 := False;\n+      Style_Check_Standard              := False;\n+      Style_Check_Tokens                := False;\n+      Style_Check_Xtra_Parens           := False;\n    end Reset_Style_Check_Options;\n \n    ------------------------------\n    -- Save_Style_Check_Options --\n    ------------------------------\n \n    procedure Save_Style_Check_Options (Options : out Style_Check_Options) is\n-      P : Natural := 0;\n+      P : Natural   := 0;\n \n       procedure Add (C : Character; S : Boolean);\n       --  Add given character C to string if switch S is true\n@@ -109,6 +110,7 @@ package body Stylesw is\n            Style_Check_Indentation /= 0);\n \n       Add ('a', Style_Check_Attribute_Casing);\n+      Add ('A', Style_Check_Array_Attribute_Index);\n       Add ('b', Style_Check_Blanks_At_End);\n       Add ('c', Style_Check_Comments);\n       Add ('d', Style_Check_DOS_Line_Terminator);\n@@ -155,7 +157,7 @@ package body Stylesw is\n    procedure Set_Default_Style_Check_Options is\n    begin\n       Reset_Style_Check_Options;\n-      Set_Style_Check_Options (\"3abcefhiklmnprst\");\n+      Set_Style_Check_Options (\"3aAbcefhiklmnprst\");\n    end Set_Default_Style_Check_Options;\n \n    -----------------------------\n@@ -228,37 +230,40 @@ package body Stylesw is\n                  Character'Pos (C) - Character'Pos ('0');\n \n             when 'a' =>\n-               Style_Check_Attribute_Casing    := True;\n+               Style_Check_Attribute_Casing      := True;\n+\n+            when 'A' =>\n+               Style_Check_Array_Attribute_Index := True;\n \n             when 'b' =>\n-               Style_Check_Blanks_At_End       := True;\n+               Style_Check_Blanks_At_End         := True;\n \n             when 'c' =>\n-               Style_Check_Comments            := True;\n+               Style_Check_Comments              := True;\n \n             when 'd' =>\n-               Style_Check_DOS_Line_Terminator := True;\n+               Style_Check_DOS_Line_Terminator   := True;\n \n             when 'e' =>\n-               Style_Check_End_Labels          := True;\n+               Style_Check_End_Labels            := True;\n \n             when 'f' =>\n-               Style_Check_Form_Feeds          := True;\n+               Style_Check_Form_Feeds            := True;\n \n             when 'h' =>\n-               Style_Check_Horizontal_Tabs     := True;\n+               Style_Check_Horizontal_Tabs       := True;\n \n             when 'i' =>\n-               Style_Check_If_Then_Layout      := True;\n+               Style_Check_If_Then_Layout        := True;\n \n             when 'I' =>\n-               Style_Check_Mode_In             := True;\n+               Style_Check_Mode_In               := True;\n \n             when 'k' =>\n-               Style_Check_Keyword_Casing      := True;\n+               Style_Check_Keyword_Casing        := True;\n \n             when 'l' =>\n-               Style_Check_Layout              := True;\n+               Style_Check_Layout                := True;\n \n             when 'L' =>\n                Style_Max_Nesting_Level := 0;\n@@ -289,11 +294,11 @@ package body Stylesw is\n                Style_Check_Max_Nesting_Level := Style_Max_Nesting_Level /= 0;\n \n             when 'm' =>\n-               Style_Check_Max_Line_Length     := True;\n-               Style_Max_Line_Length           := 79;\n+               Style_Check_Max_Line_Length       := True;\n+               Style_Max_Line_Length             := 79;\n \n             when 'M' =>\n-               Style_Max_Line_Length := 0;\n+               Style_Max_Line_Length             := 0;\n \n                if Err_Col > Options'Last\n                  or else Options (Err_Col) not in '0' .. '9'\n@@ -321,34 +326,34 @@ package body Stylesw is\n                     or else Options (Err_Col) not in '0' .. '9';\n                end loop;\n \n-               Style_Check_Max_Line_Length   := Style_Max_Line_Length /= 0;\n+               Style_Check_Max_Line_Length       := Style_Max_Line_Length /= 0;\n \n             when 'n' =>\n-               Style_Check_Standard            := True;\n+               Style_Check_Standard              := True;\n \n             when 'N' =>\n                Reset_Style_Check_Options;\n \n             when 'o' =>\n-               Style_Check_Order_Subprograms   := True;\n+               Style_Check_Order_Subprograms     := True;\n \n             when 'p' =>\n-               Style_Check_Pragma_Casing       := True;\n+               Style_Check_Pragma_Casing         := True;\n \n             when 'r' =>\n-               Style_Check_References          := True;\n+               Style_Check_References            := True;\n \n             when 's' =>\n-               Style_Check_Specs               := True;\n+               Style_Check_Specs                 := True;\n \n             when 't' =>\n-               Style_Check_Tokens              := True;\n+               Style_Check_Tokens                := True;\n \n             when 'u' =>\n-               Style_Check_Blank_Lines         := True;\n+               Style_Check_Blank_Lines           := True;\n \n             when 'x' =>\n-               Style_Check_Xtra_Parens         := True;\n+               Style_Check_Xtra_Parens           := True;\n \n             when ' ' =>\n                null;"}, {"sha": "85b823051cae16fd7fffbc2a2204ee1179edea8b", "filename": "gcc/ada/stylesw.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fstylesw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fstylesw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.ads?ref=a9a5b8acd29597692a4df9323f790da0d7506c76", "patch": "@@ -47,6 +47,12 @@ package Stylesw is\n    --  through a call to Set_Default_Style_Check_Options. They should\n    --  not be set directly in any other manner.\n \n+   Style_Check_Array_Attribute_Index : Boolean := False;\n+   --  This can be set True by using -gnatg or -gnatyA switches. If it is True\n+   --  then index numbers for array attributes (like Length) are required to\n+   --  be absent for one-dimensional arrays and present for multi-dimensional\n+   --  array attribute references.\n+\n    Style_Check_Attribute_Casing : Boolean := False;\n    --  This can be set True by using the -gnatg or -gnatya switches. If\n    --  it is True, then attribute names (including keywords such as"}, {"sha": "1da60acdee8f5fb02b0ecffd270d60fb1fb9247e", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a5b8acd29597692a4df9323f790da0d7506c76/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=a9a5b8acd29597692a4df9323f790da0d7506c76", "patch": "@@ -391,10 +391,10 @@ begin\n    Write_Line (\"        O    turn off warnings for address clause overlay\");\n    Write_Line (\"        p    turn on warnings for ineffective pragma Inline\");\n    Write_Line (\"        P*   turn off warnings for ineffective pragma Inline\");\n-   Write_Line (\"        q    turn on warnings for questionable \" &\n-                                                  \"missing paretheses\");\n-   Write_Line (\"        Q*   turn off warnings for questionable \" &\n-                                                  \"missing paretheses\");\n+   Write_Line (\"        q*   turn on warnings for questionable \" &\n+                                                  \"missing parentheses\");\n+   Write_Line (\"        Q    turn off warnings for questionable \" &\n+                                                  \"missing parentheses\");\n    Write_Line (\"        r    turn on warnings for redundant construct\");\n    Write_Line (\"        R*   turn off warnings for redundant construct\");\n    Write_Line (\"        s    suppress all warnings\");\n@@ -409,6 +409,8 @@ begin\n                                                   \"assumption\");\n    Write_Line (\"        x*   turn on warnings for export/import\");\n    Write_Line (\"        X    turn off warnings for export/import\");\n+   Write_Line (\"        .x*  turn on warnings for non-local exceptions\");\n+   Write_Line (\"        .X   turn off warnings for non-local exceptions\");\n    Write_Line (\"        y*   turn on warnings for Ada 2005 incompatibility\");\n    Write_Line (\"        Y    turn off warnings for Ada 2005 incompatibility\");\n    Write_Line (\"        z*   turn on size/align warnings for \" &\n@@ -452,6 +454,7 @@ begin\n    Write_Line (\"Enable selected style checks xx = list of parameters:\");\n    Write_Line (\"        1-9  check indentation\");\n    Write_Line (\"        a    check attribute casing\");\n+   Write_Line (\"        A    check array attribute indexes\");\n    Write_Line (\"        b    check no blanks at end of lines\");\n    Write_Line (\"        c    check comment format\");\n    Write_Line (\"        d    check no DOS line terminators\");\n@@ -472,7 +475,7 @@ begin\n    Write_Line (\"        s    check separate subprogram specs present\");\n    Write_Line (\"        t    check token separation rules\");\n    Write_Line (\"        u    check no unnecessary blank lines\");\n-   Write_Line (\"        x    check extra parens around conditionals\");\n+   Write_Line (\"        x    check extra parentheses around conditionals\");\n \n    --  Lines for -gnatyN switch\n "}]}