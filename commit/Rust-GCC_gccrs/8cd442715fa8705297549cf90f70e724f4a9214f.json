{"sha": "8cd442715fa8705297549cf90f70e724f4a9214f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNkNDQyNzE1ZmE4NzA1Mjk3NTQ5Y2Y5MGY3MGU3MjRmNGE5MjE0Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-28T07:20:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-28T07:20:43Z"}, "message": "integrate.c (copy_insn_list): Use returnjump_p.\n\n        * integrate.c (copy_insn_list): Use returnjump_p.\n        (copy_insn_notes): Recurse for CALL_PLACEHOLDER.\n\nFrom-SVN: r40912", "tree": {"sha": "75ed5e9b27905299243ca2f77ff55612392c6d4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75ed5e9b27905299243ca2f77ff55612392c6d4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cd442715fa8705297549cf90f70e724f4a9214f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd442715fa8705297549cf90f70e724f4a9214f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd442715fa8705297549cf90f70e724f4a9214f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd442715fa8705297549cf90f70e724f4a9214f/comments", "author": null, "committer": null, "parents": [{"sha": "89996b6e7cbeecc7e86586fe83d5911c7295043d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89996b6e7cbeecc7e86586fe83d5911c7295043d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89996b6e7cbeecc7e86586fe83d5911c7295043d"}], "stats": {"total": 61, "additions": 39, "deletions": 22}, "files": [{"sha": "41d161910b9e968d7ed1baf067540414514c283c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd442715fa8705297549cf90f70e724f4a9214f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd442715fa8705297549cf90f70e724f4a9214f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8cd442715fa8705297549cf90f70e724f4a9214f", "patch": "@@ -1,5 +1,8 @@\n 2001-03-27  Richard Henderson  <rth@redhat.com>\n \n+\t* integrate.c (copy_insn_list): Use returnjump_p.\n+\t(copy_insn_notes): Recurse for CALL_PLACEHOLDER.\n+\n \t* function.h (struct function): Move all boolean valued fields\n \tto single bit fields at the end of the struct.\n "}, {"sha": "bedfd149610dabd1434e26655e9eda9ab4e199c4", "filename": "gcc/integrate.c", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd442715fa8705297549cf90f70e724f4a9214f/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd442715fa8705297549cf90f70e724f4a9214f/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=8cd442715fa8705297549cf90f70e724f4a9214f", "patch": "@@ -1391,9 +1391,7 @@ copy_insn_list (insns, map, static_chain_value)\n \t  break;\n \n \tcase JUMP_INSN:\n-\t  if (GET_CODE (PATTERN (insn)) == RETURN\n-\t      || (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t\t  && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == RETURN))\n+\t  if (map->integrating && returnjump_p (insn))\n \t    {\n \t      if (map->local_return_label == 0)\n \t\tmap->local_return_label = gen_label_rtx ();\n@@ -1593,30 +1591,46 @@ copy_insn_notes (insns, map)\n      rtx insns;\n      struct inline_remap *map;\n {\n-  rtx insn;\n+  rtx insn, new_insn;\n \n   map->const_age++;\n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn)\n-\t&& map->insn_map[INSN_UID (insn)]\n-\t&& REG_NOTES (insn))\n-      {\n-\trtx next, note = copy_rtx_and_substitute (REG_NOTES (insn), map, 0);\n+    {\n+      if (! INSN_P (insn))\n+\tcontinue;\n \n-\t/* We must also do subst_constants, in case one of our parameters\n-\t   has const type and constant value.  */\n-\tsubst_constants (&note, NULL_RTX, map, 0);\n-\tapply_change_group ();\n-\tREG_NOTES (map->insn_map[INSN_UID (insn)]) = note;\n+      new_insn = map->insn_map[INSN_UID (insn)];\n+      if (! new_insn)\n+\tcontinue;\n \n-\t/* Finally, delete any REG_LABEL notes from the chain.  */\n-\tfor (; note; note = next)\n-\t  {\n-\t    next = XEXP (note, 1);\n-\t    if (REG_NOTE_KIND (note) == REG_LABEL)\n-\t      remove_note (map->insn_map[INSN_UID (insn)], note);\n-\t  }\n-      }\n+      if (REG_NOTES (insn))\n+        {\n+\t  rtx next, note = copy_rtx_and_substitute (REG_NOTES (insn), map, 0);\n+\n+\t  /* We must also do subst_constants, in case one of our parameters\n+\t     has const type and constant value.  */\n+\t  subst_constants (&note, NULL_RTX, map, 0);\n+\t  apply_change_group ();\n+\t  REG_NOTES (new_insn) = note;\n+\n+\t  /* Delete any REG_LABEL notes from the chain.  Remap any\n+             REG_EH_REGION notes.  */\n+\t  for (; note; note = next)\n+\t    {\n+\t      next = XEXP (note, 1);\n+\t      if (REG_NOTE_KIND (note) == REG_LABEL)\n+\t        remove_note (new_insn, note);\n+\t    }\n+        }\n+\n+      if (GET_CODE (insn) == CALL_INSN\n+\t  && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n+\t{\n+\t  int i;\n+\t  for (i = 0; i < 3; i++)\n+\t    copy_insn_notes (XEXP (PATTERN (insn), i), map);\n+\t}\n+    }\n }\n \f\n /* Given a chain of PARM_DECLs, ARGS, copy each decl into a VAR_DECL,"}]}