{"sha": "a6f663e4317656da61dc19f22bd7c443e46cd0ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZmNjYzZTQzMTc2NTZkYTYxZGMxOWYyMmJkN2M0NDNlNDZjZDBlZA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-03-01T16:25:09Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-03-01T16:25:09Z"}, "message": "lwg-active.html, [...]: Import Revision 41.\n\n2006-03-01  Paolo Carlini  <pcarlini@suse.de>\n\n\t* docs/html/ext/lwg-active.html, lwg-defects.html: Import Revision 41.\n\nFrom-SVN: r111606", "tree": {"sha": "ca0755a9786b8e4b1c3dcd75aa52123d68307b28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca0755a9786b8e4b1c3dcd75aa52123d68307b28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6f663e4317656da61dc19f22bd7c443e46cd0ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f663e4317656da61dc19f22bd7c443e46cd0ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6f663e4317656da61dc19f22bd7c443e46cd0ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f663e4317656da61dc19f22bd7c443e46cd0ed/comments", "author": null, "committer": null, "parents": [{"sha": "02075bb20b7bdd76ee8aaadb836c4f7013bc59ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02075bb20b7bdd76ee8aaadb836c4f7013bc59ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02075bb20b7bdd76ee8aaadb836c4f7013bc59ab"}], "stats": {"total": 1793, "additions": 1753, "deletions": 40}, "files": [{"sha": "3c9418c49eae4f30b91fa4e7d657a6950d6f5e6f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f663e4317656da61dc19f22bd7c443e46cd0ed/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f663e4317656da61dc19f22bd7c443e46cd0ed/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a6f663e4317656da61dc19f22bd7c443e46cd0ed", "patch": "@@ -1,3 +1,7 @@\n+2006-03-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* docs/html/ext/lwg-active.html, lwg-defects.html: Import Revision 41.\n+\n 2006-02-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR other/26208"}, {"sha": "bd2346fc8367cc195edab93b360c667944eb98e7", "filename": "libstdc++-v3/docs/html/ext/lwg-active.html", "status": "modified", "additions": 1711, "deletions": 27, "changes": 1738, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f663e4317656da61dc19f22bd7c443e46cd0ed/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f663e4317656da61dc19f22bd7c443e46cd0ed/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html?ref=a6f663e4317656da61dc19f22bd7c443e46cd0ed", "patch": "@@ -8,11 +8,11 @@\n <table>\n <tbody><tr>\n <td align=\"left\">Doc. no.</td>\n-<td align=\"left\">N1926=05-0186</td>\n+<td align=\"left\">N1949=06-0019</td>\n </tr>\n <tr>\n <td align=\"left\">Date:</td>\n-<td align=\"left\">2005-12-16</td>\n+<td align=\"left\">2006-02-24</td>\n </tr>\n <tr>\n <td align=\"left\">Project:</td>\n@@ -23,7 +23,7 @@\n <td align=\"left\">Howard Hinnant &lt;howard.hinnant@gmail.com&gt;</td>\n </tr>\n </tbody></table>\n-<h1>C++ Standard Library Active Issues List (Revision R40)</h1>\n+<h1>C++ Standard Library Active Issues List (Revision R41)</h1>\n   <p>Reference ISO/IEC IS 14882:1998(E)</p>\n   <p>Also see:</p>\n   <ul>\n@@ -91,6 +91,12 @@ <h1>C++ Standard Library Active Issues List (Revision R40)</h1>\n   directory as the issues list files.  </p>\n <h2>Revision History</h2>\n <ul>\n+<li>R41: \n+2006-02-24 pre-Berlin mailing.\n+Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#536\">536</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#566\">566</a>.\n+Moved <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#342\">342</a> from Ready to Open.\n+Reopened <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#309\">309</a>.\n+</li>\n <li>R40: \n 2005-12-16 mid-term mailing.\n Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#529\">529</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#535\">535</a>.\n@@ -1159,7 +1165,246 @@ <h2>Active Issues</h2>\n   iterator redesign]</i></p>\n \n <hr>\n-<a name=\"342\"><h3>342.&nbsp;seek and eofbit</h3></a><p><b>Section:</b>&nbsp;27.6.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream.unformatted\"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready\">Ready</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;09 Oct 2001</p>\n+<a name=\"309\"></a><h3><a name=\"309\">309.&nbsp;Does sentry catch exceptions?</a></h3><p><b>Section:</b>&nbsp;27.6 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.iostream.format\"> [lib.iostream.format]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;19 Mar 2001</p>\n+<p>\n+The descriptions of the constructors of basic_istream&lt;&gt;::sentry\n+(27.6.1.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream::sentry\"> [lib.istream::sentry]</a>) and basic_ostream&lt;&gt;::sentry\n+(27.6.2.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.ostream::sentry\"> [lib.ostream::sentry]</a>) do not explain what the functions do in\n+case an exception is thrown while they execute. Some current\n+implementations allow all exceptions to propagate, others catch them\n+and set ios_base::badbit instead, still others catch some but let\n+others propagate.\n+</p>\n+\n+<p>\n+The text also mentions that the functions may call setstate(failbit)\n+(without actually saying on what object, but presumably the stream\n+argument is meant).  That may have been fine for\n+basic_istream&lt;&gt;::sentry prior to issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195\">195</a>, since\n+the function performs an input operation which may fail. However,\n+issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195\">195</a> amends 27.6.1.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream::sentry\"> [lib.istream::sentry]</a>, p2 to\n+clarify that the function should actually call setstate(failbit |\n+eofbit), so the sentence in p3 is redundant or even somewhat\n+contradictory.\n+</p>\n+\n+<p>\n+The same sentence that appears in 27.6.2.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.ostream::sentry\"> [lib.ostream::sentry]</a>, p3\n+doesn't seem to be very meaningful for basic_istream&lt;&gt;::sentry\n+which performs no input. It is actually rather misleading since it\n+would appear to guide library implementers to calling\n+setstate(failbit) when os.tie()-&gt;flush(), the only called function,\n+throws an exception (typically, it's badbit that's set in response to\n+such an event).\n+</p>\n+\n+<p><b>Additional comments from Martin, who isn't comfortable with the\n+    current proposed resolution</b> (see c++std-lib-11530)</p>\n+\n+<p>\n+The istream::sentry ctor says nothing about how the function\n+deals with exemptions (27.6.1.1.2, p1 says that the class is\n+responsible for doing \"exception safe\"(*) prefix and suffix\n+operations but it doesn't explain what level of exception\n+safety the class promises to provide). The mockup example\n+of a \"typical implementation of the sentry ctor\" given in\n+27.6.1.1.2, p6, removed in ISO/IEC 14882:2003, doesn't show\n+exception handling, either. Since the ctor is not classified\n+as a formatted or unformatted input function, the text in\n+27.6.1.1, p1 through p4 does not apply. All this would seem\n+to suggest that the sentry ctor should not catch or in any\n+way handle exceptions thrown from any functions it may call.\n+Thus, the typical implementation of an istream extractor may\n+look something like [1].\n+</p>\n+\n+<p>\n+The problem with [1] is that while it correctly sets ios::badbit\n+if an exception is thrown from one of the functions called from\n+the sentry ctor, if the sentry ctor reaches EOF while extracting\n+whitespace from a stream that has eofbit or failbit set in\n+exceptions(), it will cause an ios::failure to be thrown, which\n+will in turn cause the extractor to set ios::badbit.\n+</p>\n+\n+<p>\n+The only straightforward way to prevent this behavior is to\n+move the definition of the sentry object in the extractor\n+above the try block (as suggested by the example in 22.2.8,\n+p9 and also indirectly supported by 27.6.1.3, p1). See [2].\n+But such an implementation will allow exceptions thrown from\n+functions called from the ctor to freely propagate to the\n+caller regardless of the setting of ios::badbit in the stream\n+object's exceptions().\n+</p>\n+\n+<p>\n+So since neither [1] nor [2] behaves as expected, the only\n+possible solution is to have the sentry ctor catch exceptions\n+thrown from called functions, set badbit, and propagate those\n+exceptions if badbit is also set in exceptions(). (Another\n+solution exists that deals with both kinds of sentries, but\n+the code is non-obvious and cumbersome -- see [3].)\n+</p>\n+\n+<p>\n+Please note that, as the issue points out, current libraries\n+do not behave consistently, suggesting  that implementors are\n+not quite clear on the exception handling in istream::sentry,\n+despite the fact that some LWG members might feel otherwise.\n+(As documented by the parenthetical comment here:\n+http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1480.html#309)\n+</p>\n+\n+<p>\n+Also please note that those LWG members who in Copenhagen\n+felt that \"a sentry's constructor should not catch exceptions,\n+because sentries should only be used within (un)formatted input\n+functions and that exception handling is the responsibility of\n+those functions, not of the sentries,\" as noted here\n+http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2001/n1310.html#309\n+would in effect be either arguing for the behavior described\n+in [1] or for extractors implemented along the lines of [3].\n+</p>\n+\n+<p>\n+The original proposed resolution (Revision 25 of the issues\n+list) clarifies the role of the sentry ctor WRT exception\n+handling by making it clear that extractors (both library\n+or user-defined) should be implemented along the lines of\n+[2] (as opposed to [1]) and that no exception thrown from\n+the callees should propagate out of either function unless\n+badbit is also set in exceptions().\n+</p>\n+\n+\n+<p>[1] Extractor that catches exceptions thrown from sentry:</p>\n+\n+<blockquote>\n+<pre>struct S { long i; };\n+\n+istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)\n+{\n+    ios::iostate err = ios::goodbit;\n+    try {\n+        const istream::sentry guard (strm, false);\n+        if (guard) {\n+            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())\n+                .get (istreambuf_iterator&lt;char&gt;(strm),\n+                      istreambuf_iterator&lt;char&gt;(),\n+                      strm, err, s.i);\n+        }\n+    }\n+    catch (...) {\n+        bool rethrow;\n+        try {\n+            strm.setstate (ios::badbit);\n+            rethrow = false;\n+        }\n+        catch (...) {\n+            rethrow = true;\n+        }\n+        if (rethrow)\n+            throw;\n+    }\n+    if (err)\n+        strm.setstate (err);\n+    return strm;\n+}\n+</pre>\n+</blockquote>\n+\n+<p>[2] Extractor that propagates exceptions thrown from sentry:</p>\n+\n+<blockquote>\n+<pre>istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)\n+{\n+    istream::sentry guard (strm, false);\n+    if (guard) {\n+        ios::iostate err = ios::goodbit;\n+        try {\n+            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())\n+                .get (istreambuf_iterator&lt;char&gt;(strm),\n+                      istreambuf_iterator&lt;char&gt;(),\n+                      strm, err, s.i);\n+        }\n+        catch (...) {\n+            bool rethrow;\n+            try {\n+                strm.setstate (ios::badbit);\n+                rethrow = false;\n+            }\n+            catch (...) {\n+                rethrow = true;\n+            }\n+            if (rethrow)\n+                throw;\n+        }\n+        if (err)\n+            strm.setstate (err);\n+    }\n+    return strm;\n+}\n+</pre>\n+</blockquote>\n+\n+<p>\n+[3] Extractor that catches exceptions thrown from sentry\n+but doesn't set badbit if the exception was thrown as a\n+result of a call to strm.clear().\n+</p>\n+\n+<blockquote>\n+<pre>istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)\n+{\n+    const ios::iostate state = strm.rdstate ();\n+    const ios::iostate except = strm.exceptions ();\n+    ios::iostate err = std::ios::goodbit;\n+    bool thrown = true;\n+    try {\n+        const istream::sentry guard (strm, false);\n+        thrown = false;\n+        if (guard) {\n+            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())\n+                .get (istreambuf_iterator&lt;char&gt;(strm),\n+                      istreambuf_iterator&lt;char&gt;(),\n+                      strm, err, s.i);\n+        }\n+    }\n+    catch (...) {\n+        if (thrown &amp;&amp; state &amp; except)\n+            throw;\n+        try {\n+            strm.setstate (ios::badbit);\n+            thrown = false;\n+        }\n+        catch (...) {\n+            thrown = true;\n+        }\n+        if (thrown)\n+            throw;\n+    }\n+    if (err)\n+        strm.setstate (err);\n+\n+    return strm;\n+}\n+</pre>\n+</blockquote>\n+\n+<p>\n+[Pre-Berlin] Reopened at the request of Paolo Carlini and Steve Clamage.\n+</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p><b>Rationale:</b></p>\n+<p>The LWG agrees there is minor variation between implementations,\n+  but believes that it doesn't matter. This is a rarely used corner\n+  case. There is no evidence that this has any commercial importance\n+  or that it causes actual portability problems for customers trying\n+  to write code that runs on multiple implementations.</p>\n+<hr>\n+<a name=\"342\"><h3>342.&nbsp;seek and eofbit</h3></a><p><b>Section:</b>&nbsp;27.6.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream.unformatted\"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;09 Oct 2001</p>\n <p>I think we have a defect.</p>\n \n <p>According to lwg issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60\">60</a> which is now a dr, the\n@@ -1221,6 +1466,22 @@ <h2>Active Issues</h2>\n input, it should behave the same way as other unformatted input.  On\n the other hand, \"principle of least surprise\" is that seeking from EOF\n ought to be OK.</p>\n+\n+<p>\n+Pre-Berlin:  Paolo points out several problems with the proposed resolution in\n+Ready state:\n+</p>\n+\n+<ul>\n+<li>It should apply to both overloads of seekg.</li>\n+<li>tellg has similar issues, except that it should not call clear().</li>\n+<li>The point about clear() seems to apply to seekp().</li>\n+<li>Depending on the outcome of\n+<a href=\"file:///Volumes/Data/lwg/lwg-active.html#419\">419</a> if the sentry\n+sets <tt>failbit</tt> when it finds <tt>eofbit</tt> already set, then\n+you can never seek away from the end of stream.</li>\n+</ul>\n+\n <p><b>Proposed resolution:</b></p>\n \n <p>Change 27.6.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream.unformatted\"> [lib.istream.unformatted]</a> to:</p>\n@@ -1996,7 +2257,7 @@ <h2>Active Issues</h2>\n   fixed the analogous problem with the extractor in issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303\">303</a>.</p>\n \n <hr>\n-<a name=\"397\"><h3>397.&nbsp;ostream::sentry dtor throws exceptions</h3></a><p><b>Section:</b>&nbsp;27.6.2.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.ostream::sentry\"> [lib.ostream::sentry]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;5 Jan 2003</p>\n+<a name=\"397\"></a><h3><a name=\"397\">397.&nbsp;ostream::sentry dtor throws exceptions</a></h3><p><b>Section:</b>&nbsp;27.6.2.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.ostream::sentry\"> [lib.ostream::sentry]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;5 Jan 2003</p>\n     <p>\n 17.4.4.8, p3 prohibits library dtors from throwing exceptions.\n     </p>\n@@ -2415,7 +2676,7 @@ <h2>Active Issues</h2>\n   might reasonably swallow the exception, or call abort, or do\n   something even more drastic.]</i></p>\n <hr>\n-<a name=\"419\"></a><h3><a name=\"419\">419.&nbsp;istream extractors not setting failbit if eofbit is already set</a></h3><p><b>Section:</b>&nbsp;27.6.1.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream::sentry\"> [lib.istream::sentry]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;18 Sep 2003</p>\n+<a name=\"419\"><h3>419.&nbsp;istream extractors not setting failbit if eofbit is already set</h3></a><p><b>Section:</b>&nbsp;27.6.1.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream::sentry\"> [lib.istream::sentry]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;18 Sep 2003</p>\n         <p>\n \n 27.6.1.1.2, p2 says that istream::sentry ctor prepares for input if is.good()\n@@ -2485,6 +2746,13 @@ <h2>Active Issues</h2>\n corrected. \n \n         </p>\n+<p>\n+Pre Berlin:  This issue is related to\n+<a href=\"file:///Volumes/Data/lwg/lwg-active.html#342\">342</a>.  If the sentry\n+sets <tt>failbit</tt> when it finds <tt>eofbit</tt> already set, then\n+you can never seek away from the end of stream.\n+</p>\n+\n     <p><b>Proposed resolution:</b></p>\n <p>Kona: Possibly NAD.  If eofbit is set then good() will return false.  We\n   then set <i>ok</i> to false.  We believe that the sentry's\n@@ -2733,7 +3001,7 @@ <h2>Active Issues</h2>\n   negative.  Martin will do that review.]</i></p>\n \n <hr>\n-<a name=\"424\"></a><h3><a name=\"424\">424.&nbsp;normative notes</a></h3><p><b>Section:</b>&nbsp;17.3.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-intro.html#lib.structure.summary\"> [lib.structure.summary]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;18 Sep 2003</p>\n+<a name=\"424\"><h3>424.&nbsp;normative notes</h3></a><p><b>Section:</b>&nbsp;17.3.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-intro.html#lib.structure.summary\"> [lib.structure.summary]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;18 Sep 2003</p>\n \n <p>\n The text in 17.3.1.1, p1 says:\n@@ -2845,7 +3113,7 @@ <h2>Active Issues</h2>\n   performance, so we don't want to require specific checking.  We\n   need wording to express this decision.]</i></p>\n <hr>\n-<a name=\"431\"></a><h3><a name=\"431\">431.&nbsp;Swapping containers with unequal allocators</a></h3><p><b>Section:</b>&nbsp;20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.requirements\"> [lib.allocator.requirements]</a>, 25 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.algorithms\"> [lib.algorithms]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;20 Sep 2003</p>\n+<a name=\"431\"><h3>431.&nbsp;Swapping containers with unequal allocators</h3></a><p><b>Section:</b>&nbsp;20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.requirements\"> [lib.allocator.requirements]</a>, 25 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.algorithms\"> [lib.algorithms]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;20 Sep 2003</p>\n <p>Clause 20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.requirements\"> [lib.allocator.requirements]</a> paragraph 4 says that implementations\n   are permitted to supply containers that are unable to cope with\n   allocator instances and that container implementations may assume\n@@ -5411,6 +5679,11 @@ <h2>Active Issues</h2>\n by const reference.\n </p>\n \n+<p>\n+Matt Austern adds that this issue also exists for the <tt>insert</tt> and\n+<tt>erase</tt> members of the ordered and unordered associative containers.\n+</p>\n+\n <p><b>Proposed resolution:</b></p>\n <p>\n </p>\n@@ -5662,25 +5935,6 @@ <h2>Active Issues</h2>\n </p>\n </blockquote>\n <hr>\n-<a name=\"533\"><h3>533.&nbsp;typo in 2.2.3.10/1</h3></a><p><b>Section:</b>&nbsp;TR1 2.2.3.10 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.util.smartptr.getdeleter\"> [tr.util.smartptr.getdeleter]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Paolo Carlini&nbsp; <b>Date:</b>&nbsp;9 Nov 2005</p>\n-<p>\n-I'm seeing something that looks like a typo. The Return of <tt>get_deleter</tt>\n-says:\n-</p>\n-<blockquote>\n-If <tt>*this</tt> <i>owns</i> a deleter <tt>d</tt>...\n-</blockquote>\n-<p>\n-but <tt>get_deleter</tt> is a free function!\n-</p>\n-<p><b>Proposed resolution:</b></p>\n-<p>\n-Therefore, I think should be:\n-</p>\n-<blockquote>\n-If <tt><del>*this</del> <ins>p</ins></tt> <i>owns</i> a deleter <tt>d</tt>...\n-</blockquote>\n-<hr>\n <a name=\"534\"><h3>534.&nbsp;Missing basic_string members</h3></a><p><b>Section:</b>&nbsp;21.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-strings.html#lib.basic.string\"> [lib.basic.string]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Alisdair Meredith&nbsp; <b>Date:</b>&nbsp;16 Nov 2005</p>\n <p>\n OK, we all know std::basic_string is bloated and already has way too\n@@ -5765,5 +6019,1435 @@ <h2>Active Issues</h2>\n <del>were</del> <ins>was</ins> in <tt>*this</tt>.\n </p>\n </blockquote>\n+<hr>\n+<a name=\"536\"><h3>536.&nbsp;Container iterator constructor and explicit convertibility</h3></a><p><b>Section:</b>&nbsp;23.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.container.requirements\"> [lib.container.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Joaqu\ufffdn M L\ufffdpez Mu\ufffdoz&nbsp; <b>Date:</b>&nbsp;17 Dec 2005</p>\n+<p>\n+The iterator constructor X(i,j) for containers as defined in 23.1.1 and\n+23.2.2 does only require that i and j be input iterators but\n+nothing is said about their associated value_type. There are three\n+sensible\n+options:\n+</p>\n+<ol>\n+<li>iterator's value_type is exactly X::value_type (modulo cv).</li>\n+<li>iterator's value_type is *implicitly* convertible to X::value_type.</li>\n+<li>iterator's value_type is *explicitly* convertible to X::value_type.</li>\n+</ol>\n+<p>\n+The issue has practical implications, and stdlib vendors have\n+taken divergent approaches to it: Dinkumware follows 2,\n+libstdc++ follows 3.\n+</p>\n+<p>\n+The same problem applies to the definition of insert(p,i,j) for\n+sequences and insert(i,j) for associative contianers, as well as\n+assign.\n+</p>\n+\n+<p><i>[\n+The following added by Howard and the example code was originally written by\n+Dietmar.\n+]</i></p>\n+<p>\n+Valid code below?\n+</p>\n+\n+<blockquote><pre>#include &lt;vector&gt; \n+#include &lt;iterator&gt; \n+#include &lt;iostream&gt; \n+\n+struct foo \n+{ \n+    explicit foo(int) {} \n+}; \n+\n+int main() \n+{ \n+    std::vector&lt;int&gt; v_int; \n+    std::vector&lt;foo&gt; v_foo1(v_int.begin(), v_int.end()); \n+    std::vector&lt;foo&gt; v_foo2((std::istream_iterator&lt;int&gt;(std::cin)), \n+                             std::istream_iterator&lt;int&gt;()); \n+} \n+</pre></blockquote>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"537\"><h3>537.&nbsp;Typos in the signatures in 27.6.1.3/42-43 and 27.6.2.4</h3></a><p><b>Section:</b>&nbsp;27.6.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream.unformatted\"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Paolo Carlini&nbsp; <b>Date:</b>&nbsp;12 Feb 2006</p>\n+<p>\n+In the most recent working draft, I'm still seeing:\n+</p>\n+\n+<blockquote><pre>seekg(off_type&amp; off, ios_base::seekdir dir)\n+</pre></blockquote>\n+\n+<p>\n+and\n+</p>\n+\n+<blockquote><pre>seekp(pos_type&amp; pos)\n+\n+seekp(off_type&amp; off, ios_base::seekdir dir)\n+</pre></blockquote>\n+\n+<p>\n+that is, by reference off and pos arguments.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+After 27.6.1.3p42 change:\n+</p>\n+\n+<blockquote><pre>basic_istream&lt;charT,traits&gt;&amp; seekg(off_type<del>&amp;</del> <i>off</i>, ios_base::seekdir <i>dir</i>);\n+</pre></blockquote>\n+\n+<p>\n+After 27.6.2.4p1 change:\n+</p>\n+\n+<blockquote><pre>basic_ostream&lt;charT,traits&gt;&amp; seekp(pos_type<del>&amp;</del> <i>pos</i>);\n+</pre></blockquote>\n+\n+<p>\n+After 27.6.2.4p3 change:\n+</p>\n+\n+<blockquote><pre>basic_ostream&lt;charT,traits&gt;&amp; seekp(off_type<del>&amp;</del> <i>off</i>, ios_base::seekdir <i>dir</i>);\n+</pre></blockquote>\n+<hr>\n+<a name=\"538\"><h3>538.&nbsp;241 again: Does unique_copy() require CopyConstructible and Assignable?</h3></a><p><b>Section:</b>&nbsp;25.2.8 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.unique\"> [lib.alg.unique]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;9 Feb 2006</p>\n+<p>\n+I believe I botched the resolution of\n+<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241\">\n+241 \"Does unique_copy() require CopyConstructible and Assignable?\"</a> which now\n+has WP status.\n+</p>\n+\n+<p>\n+This talks about <tt>unique_copy</tt> requirements and currently reads:\n+</p>\n+\n+<blockquote>\n+-5- <i>Requires:</i> The ranges <tt>[<i>first</i>, <i>last</i>)</tt> and\n+<tt>[<i>result</i>, <i>result</i>+(<i>last</i>-<i>first</i>))</tt>\n+shall not overlap. The expression <tt>*<i>result</i> = *<i>first</i></tt> shall\n+be valid. If neither <tt>InputIterator</tt> nor <tt>OutputIterator</tt> meets the\n+requirements of forward iterator then the value type of <tt>InputIterator</tt>\n+must be CopyConstructible (20.1.3). Otherwise CopyConstructible is not required.\n+</blockquote>\n+\n+<p>\n+The problem (which Paolo discovered) is that when the iterators are at their\n+most restrictive (<tt>InputIterator</tt>, <tt>OutputIterator</tt>), then we want\n+<tt>InputIterator::value_type</tt> to be both <tt>CopyConstructible</tt> and\n+<tt>CopyAssignable</tt> (for the most efficient implementation).  However this\n+proposed resolution only makes it clear that it is <tt>CopyConstructible</tt>,\n+and that one can assign from <tt>*<i>first</i></tt> to <tt>*<i>result</i></tt>.\n+This latter requirement does not necessarily imply that you can:\n+</p>\n+\n+<blockquote><pre>*<i>first</i> = *<i>first</i>;\n+</pre></blockquote>\n+<p><b>Proposed resolution:</b></p>\n+<blockquote>\n+-5- <i>Requires:</i> The ranges <tt>[<i>first</i>, <i>last</i>)</tt> and\n+<tt>[<i>result</i>, <i>result</i>+(<i>last</i>-<i>first</i>))</tt>\n+shall not overlap. The expression <tt>*<i>result</i> = *<i>first</i></tt>\n+<del>shall</del> <ins>must</ins>\n+be valid. If neither <tt>InputIterator</tt> nor <tt>OutputIterator</tt> meets the\n+requirements of forward iterator then the <del>value type</del> \n+<ins><tt>value_type</tt></ins> of <tt>InputIterator</tt>\n+must be CopyConstructible (20.1.3) <ins>and CopyAssignable</ins>.\n+Otherwise CopyConstructible is not required.\n+</blockquote>\n+<hr>\n+<a name=\"539\"><h3>539.&nbsp;partial_sum and adjacent_difference should mention requirements</h3></a><p><b>Section:</b>&nbsp;26.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.numeric.ops\"> [lib.numeric.ops]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Marc Schoolderman&nbsp; <b>Date:</b>&nbsp;6 Feb 2006</p>\n+<p>\n+There are some problems in the definition of partial_sum and\n+adjacent_difference in 26.4 [lib.numeric.ops]\n+</p>\n+\n+<p>\n+Unlike <tt>accumulate</tt> and <tt>inner_product</tt>, these functions are not\n+parametrized on a \"type T\", instead, 26.4.3 [lib.partial.sum] simply\n+specifies the effects clause as;\n+</p>\n+\n+<blockquote>\n+Assigns to every element referred to by iterator <tt>i</tt> in the range\n+<tt>[result,result + (last - first))</tt> a value correspondingly equal to\n+<blockquote><pre>((...(* first + *( first + 1)) + ...) + *( first + ( i - result )))\n+</pre></blockquote>\n+</blockquote>\n+\n+<p>\n+And similarly for BinaryOperation. Using just this definition, it seems\n+logical to expect that:\n+</p>\n+\n+\n+<blockquote><pre>char i_array[4] = { 100, 100, 100, 100 };\n+int  o_array[4];\n+\n+std::partial_sum(i_array, i_array+4, o_array);\n+</pre></blockquote>\n+\n+<p>\n+Is equivalent to\n+</p>\n+\n+<blockquote><pre>int o_array[4] = { 100, 100+100, 100+100+100, 100+100+100+100 };\n+</pre></blockquote>\n+\n+<p>\n+i.e. 100, 200, 300, 400, with addition happening in the <tt>result type</tt>,\n+<tt>int</tt>.\n+</p>\n+\n+<p>\n+Yet all implementations I have tested produce 100, -56, 44, -112,\n+because they are using an accumulator of the <tt>InputIterator</tt>'s\n+<tt>value_type</tt>, which in this case is <tt>char</tt>, not <tt>int</tt>.\n+</p>\n+\n+<p>\n+The issue becomes more noticeable when the result of the expression <tt>*i +\n+*(i+1)</tt> or <tt>binary_op(*i, *i-1)</tt> can't be converted to the\n+<tt>value_type</tt>. In a contrived example:\n+</p>\n+\n+<blockquote><pre>enum not_int { x = 1, y = 2 };\n+...\n+not_int e_array[4] = { x, x, y, y };\n+std::partial_sum(e_array, e_array+4, o_array);\n+</pre></blockquote>\n+\n+<p>\n+Is it the intent that the operations happen in the <tt>input type</tt>, or in\n+the <tt>result type</tt>?\n+</p>\n+\n+<p>\n+If the intent is that operations happen in the <tt>result type</tt>, something\n+like this should be added to the \"Requires\" clause of 26.4.3/4\n+[lib.partial.sum]:\n+</p>\n+\n+<blockquote>\n+The type of <tt>*i + *(i+1)</tt> or <tt>binary_op(*i, *(i+1))</tt> shall meet the\n+requirements of <tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt>\n+(23.1) types.\n+</blockquote>\n+\n+<p>\n+(As also required for <tt>T</tt> in 26.4.1 [lib.accumulate] and 26.4.2\n+[lib.inner.product].)\n+</p>\n+\n+<p>\n+The \"auto initializer\" feature proposed in\n+<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1894.pdf\">N1894</a>\n+is not required to\n+implement <tt>partial_sum</tt> this way. The 'narrowing' behaviour can still be\n+obtained by using the <tt>std::plus&lt;&gt;</tt> function object.\n+</p>\n+\n+<p>\n+If the intent is that operations happen in the <tt>input type</tt>, then\n+something like this should be added instead;\n+</p>\n+\n+<blockquote>\n+The type of *first shall meet the requirements of\n+<tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt> (23.1) types.\n+The result of <tt>*i + *(i+1)</tt> or <tt>binary_op(*i, *(i+1))</tt> shall be\n+convertible to this type.\n+</blockquote>\n+\n+<p>\n+The 'widening' behaviour can then be obtained by writing a custom proxy\n+iterator, which is somewhat involved.\n+</p>\n+\n+<p>\n+In both cases, the semantics should probably be clarified.\n+</p>\n+\n+<p>\n+26.4.4 [lib.adjacent.difference] is similarly underspecified, although\n+all implementations seem to perform operations in the 'result' type:\n+</p>\n+\n+<blockquote><pre>unsigned char i_array[4] = { 4, 3, 2, 1 };\n+int o_array[4];\n+\n+std::adjacent_difference(i_array, i_array+4, o_array);\n+</pre></blockquote>\n+\n+<p>\n+o_array is 4, -1, -1, -1 as expected, not 4, 255, 255, 255.\n+</p>\n+\n+<p>\n+In any case, <tt>adjacent_difference</tt> doesn't mention the requirements on the\n+<tt>value_type</tt>; it can be brought in line with the rest of 26.4\n+[lib.numeric.ops] by adding the following to 26.4.4/2\n+[lib.adjacent.difference]:\n+</p>\n+\n+<blockquote>\n+The type of <tt>*first</tt> shall meet the requirements of\n+<tt>CopyConstructible</tt> (20.1.3) and <tt>Assignable</tt> (23.1) types.\"\n+</blockquote>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"540\"><h3>540.&nbsp;shared_ptr&lt;void&gt;::operator*()</h3></a><p><b>Section:</b>&nbsp;TR1 2.2.3.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.util.smartptr.shared.obs\"> [tr.util.smartptr.shared.obs]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;15 Oct 2005</p>\n+<p>\n+I'm trying to reconcile the note in tr.util.smartptr.shared.obs, p6\n+that talks about the operator*() member function of shared_ptr:\n+</p>\n+\n+<blockquote>\n+  Notes: When T is void, attempting to instantiate this member function\n+  renders the program ill-formed. [Note: Instantiating shared_ptr&lt;void&gt;\n+  does not necessarily result in instantiating this member function.\n+  --end note]\n+</blockquote>\n+\n+<p>\n+with the requirement in temp.inst, p1:\n+</p>\n+\n+<blockquote>\n+  The implicit instantiation of a class template specialization causes\n+  the implicit instantiation of the declarations, but not of the\n+  definitions...\n+</blockquote>\n+\n+<p>\n+I assume that what the note is really trying to say is that\n+\"instantiating shared_ptr&lt;void&gt; *must not* result in instantiating\n+this member function.\" That is, that this function must not be\n+declared a member of shared_ptr&lt;void&gt;. Is my interpretation\n+correct?\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change 2.2.3.5p6\n+</p>\n+\n+<blockquote>\n+-6- <del><i>Notes:</i></del> When <tt>T</tt> is <tt>void</tt>, <del>attempting to instantiate\n+this member function renders the program ill-formed. [<i>Note:</i>\n+Instantiating <tt>shared_ptr&lt;void&gt;</tt> does not necessarily result in\n+instantiating this member function. <i>--end note</i>]</del> <ins>it is\n+unspecified whether this member function is declared or not, and if so, what its\n+return type is, except that the declaration (although not necessarily the\n+definition) of the function shall be well-formed.</ins>\n+</blockquote>\n+\n+<hr>\n+<a name=\"541\"><h3>541.&nbsp;shared_ptr template assignment and void</h3></a><p><b>Section:</b>&nbsp;TR1 2.2.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.util.smartptr.shared\"> [tr.util.smartptr.shared]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;16 Oct 2005</p>\n+<p>\n+Is the void specialization of the template assignment operator taking\n+a shared_ptr&lt;void&gt; as an argument supposed be well-formed?\n+</p>\n+<p>\n+I.e., is this snippet well-formed:\n+</p>\n+<blockquote><pre>shared_ptr&lt;void&gt; p;\n+p.operator=&lt;void&gt;(p);\n+</pre></blockquote>\n+\n+<p>\n+Gcc complains about auto_ptr&lt;void&gt;::operator*() returning a reference\n+to void. I suspect it's because shared_ptr has two template assignment\n+operators, one of which takes auto_ptr, and the auto_ptr template gets\n+implicitly instantiated in the process of overload resolution.\n+</p>\n+\n+<p>\n+The only way I see around it is to do the same trick with auto_ptr&lt;void&gt;\n+operator*() as with the same operator in shared_ptr&lt;void&gt;.\n+</p>\n+\n+<p>\n+PS Strangely enough, the EDG front end doesn't mind the code, even\n+though in a small test case (below) I can reproduce the error with\n+it as well.\n+</p>\n+\n+<blockquote><pre>template &lt;class T&gt;\n+struct A { T&amp; operator*() { return *(T*)0; } };\n+\n+template &lt;class T&gt;\n+struct B {\n+    void operator= (const B&amp;) { }\n+    template &lt;class U&gt;\n+    void operator= (const B&lt;U&gt;&amp;) { }\n+    template &lt;class U&gt;\n+    void operator= (const A&lt;U&gt;&amp;) { }\n+};\n+\n+int main ()\n+{\n+    B&lt;void&gt; b;\n+    b.operator=&lt;void&gt;(b);\n+}\n+</pre></blockquote>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"542\"><h3>542.&nbsp;shared_ptr observers</h3></a><p><b>Section:</b>&nbsp;TR1 2.2.3.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.util.smartptr.shared.obs\"> [tr.util.smartptr.shared.obs]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;18 Oct 2005</p>\n+<p>\n+Peter Dimov wrote:\n+To: C++ libraries mailing list\n+Message c++std-lib-15614\n+[...]\n+The intent is for both use_count() and unique() to work in a threaded environment.\n+They are intrinsically prone to race conditions, but they never return garbage.\n+</p>\n+\n+<p>\n+This is a crucial piece of information that I really wish were\n+captured in the text. Having this in a non-normative note would\n+have made everything crystal clear to me and probably stopped\n+me from ever starting this discussion :) Instead, the sentence\n+in p12 \"use only for debugging and testing purposes, not for\n+production code\" very strongly suggests that implementations\n+can and even are encouraged to return garbage (when threads\n+are involved) for performance reasons.\n+</p>\n+<p>\n+How about adding an informative note along these lines:\n+</p>\n+<blockquote>\n+  Note: Implementations are encouraged to provide well-defined\n+  behavior for use_count() and unique() even in the presence of\n+  multiple threads.\n+</blockquote>\n+<p>\n+I don't necessarily insist on the exact wording, just that we\n+capture the intent.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"543\"><h3>543.&nbsp;valarray slice default constructor</h3></a><p><b>Section:</b>&nbsp;26.3.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.class.slice\"> [lib.class.slice]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;3 Nov 2005</p>\n+<p>\n+If one explicitly constructs a slice or glice with the default\n+constructor, does the standard require this slice to have any usable\n+state?  It says \"creates a slice which specifies no elements\", which\n+could be interpreted two ways:\n+</p>\n+<ol>\n+<li>There are no elements to which the slice refers (i.e. undefined).</li>\n+<li>The slice specifies an array with no elements in it (i.e. defined).</li>\n+</ol>\n+<p>\n+Here is a bit of code to illustrate:\n+</p>\n+<blockquote><pre>#include &lt;iostream&gt;\n+#include &lt;valarray&gt;\n+\n+int main()\n+{\n+    std::valarray&lt;int&gt; v(10);\n+    std::valarray&lt;int&gt; v2 = v[std::slice()];\n+    std::cout &lt;&lt; \"v[slice()].size() = \" &lt;&lt; v2.size() &lt;&lt; '\\n';\n+}\n+</pre></blockquote>\n+\n+<p>\n+Is the behavior undefined?  Or should the output be:\n+</p>\n+\n+<blockquote>\n+v[slice()].size() = 0\n+</blockquote>\n+\n+<p>\n+There is a similar question and wording for gslice at 26.3.6.1p1.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"544\"><h3>544.&nbsp;minor NULL problems in C.2</h3></a><p><b>Section:</b>&nbsp;C.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/diff.html#diff.library\"> [diff.library]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;25 Nov 2005</p>\n+<p>\n+According to C.2.2.3, p1, \"the macro NULL, defined in any of &lt;clocale&gt;,\n+&lt;cstddef&gt;, &lt;cstdio&gt;, &lt;cstdlib&gt;, &lt;cstring&gt;, &lt;ctime&gt;,\n+or &lt;cwchar&gt;.\" This is consistent with the C standard.\n+</p>\n+<p>\n+However, Table 95 in C.2 fails to mention &lt;clocale&gt; and &lt;cstdlib&gt;.\n+</p>\n+<p>\n+In addition, C.2, p2 claims that \"The C++ Standard library provides\n+54 standard macros from the C library, as shown in Table 95.\" While\n+table 95 does have 54 entries, since a couple of them (including the\n+NULL macro) are listed more than once, the actual number of macros\n+defined by the C++ Standard Library may not be 54.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+I propose we add &lt;clocale&gt; and &lt;cstdlib&gt; to Table 96 and remove the\n+number of macros from C.2, p2 and reword the sentence as follows:\n+</p>\n+<blockquote>\n+The C++ Standard library <del>provides 54 standard macros from</del>\n+<ins>defines a number macros corresponding to those defined by</ins> the C \n+<ins>Standard</ins> library, as shown in Table 96.\n+</blockquote>\n+<hr>\n+<a name=\"545\"><h3>545.&nbsp;When is a deleter deleted?</h3></a><p><b>Section:</b>&nbsp;TR1 2.2.3.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.util.smartptr.shared.dest\"> [tr.util.smartptr.shared.dest]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;10 Jan 2006</p>\n+<p>\n+The description of ~shared_ptr doesn't say when the shared_ptr's deleter, if\n+any, is destroyed. In principle there are two possibilities: it is destroyed\n+unconditionally whenever ~shared_ptr is executed (which, from an implementation\n+standpoint, means that the deleter is copied whenever the shared_ptr is copied),\n+or it is destroyed immediately after the owned pointer is destroyed (which, from\n+an implementation standpoint, means that the deleter object is shared between\n+instances). We should say which it is.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"546\"><h3>546.&nbsp;_Longlong and _ULonglong are integer types</h3></a><p><b>Section:</b>&nbsp;TR1 5.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.rand.req\"> [tr.rand.req]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;10 Jan 2006</p>\n+<p>\n+The TR sneaks in two new integer types, _Longlong and _Ulonglong, in [tr.c99].\n+The rest of the TR should use that type.&nbsp; I believe this affects two places.\n+First, the random number requirements, 5.1.1/10-11, lists all of the types with\n+which template parameters named IntType and UIntType may be instantiated.\n+_Longlong (or \"long long\", assuming it is added to C++0x) should be added to the\n+IntType list, and UIntType (again, or \"unsigned long long\") should be added to\n+the UIntType list.&nbsp; Second, 6.3.2 lists the types for which hash&lt;&gt; is\n+required to be instantiable. _Longlong and _Ulonglong should be added to that\n+list, so that people may use long long as a hash key.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"547\"><h3>547.&nbsp;division should be floating-point, not integer</h3></a><p><b>Section:</b>&nbsp;TR1 5.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.rand.var\"> [tr.rand.var]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;10 Jan 2006</p>\n+<p>\n+Paragraph 10 describes how a variate generator uses numbers produced by an\n+engine to pass to a generator. The sentence that concerns me is: \"Otherwise, if\n+the value for engine_value_type::result_type is true and the value for\n+Distribution::input_type is false [i.e. if the engine produces integers and the\n+engine wants floating-point values], then the numbers in s_eng are divided by\n+engine().max() - engine().min() + 1 to obtain the numbers in s_e.\" Since the\n+engine is producing integers, both the numerator and the denominator are\n+integers and we'll be doing integer division, which I don't think is what we\n+want. Shouldn't we be performing a conversion to a floating-point type first?\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"548\"><h3>548.&nbsp;May random_device block?</h3></a><p><b>Section:</b>&nbsp;TR1 5.1.6 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.rand.device\"> [tr.rand.device]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;10 Jan 2006</p>\n+<p>\n+Class random_device \"produces non-deterministic random numbers\", using some\n+external source of entropy. In most real-world systems, the amount of available\n+entropy is limited. Suppose that entropy has been exhausted. What is an\n+implementation permitted to do? In particular, is it permitted to block\n+indefinitely until more random bits are available, or is the implementation\n+required to detect failure immediately? This is not an academic question. On\n+Linux a straightforward implementation would read from /dev/random, and \"When\n+the entropy pool is empty, reads to /dev/random will block until additional\n+environmental noise is gathered.\" Programmers need to know whether random_device\n+is permitted to (or possibly even required to?) behave the same way.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"549\"><h3>549.&nbsp;Undefined variable in binomial_distribution</h3></a><p><b>Section:</b>&nbsp;TR1 5.1.7.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.rand.dist.bin\"> [tr.rand.dist.bin]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;10 Jan 2006</p>\n+<p>\n+Paragraph 1 says that \"A binomial distributon random distribution produces\n+integer values i&gt;0 with p(i) = (n choose i) * p*i * (1-p)^(t-i), where t and\n+p are the parameters of the distribution. OK, that tells us what t, p, and i\n+are. What's n?\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"550\"><h3>550.&nbsp;What should the return type of pow(float,int) be?</h3></a><p><b>Section:</b>&nbsp;26.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.c.math\"> [lib.c.math]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;12 Jan 2006</p>\n+<p>\n+Assuming we adopt the\n+<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf\">C\n+compatibility package from C99</a>  what should be the return type of the\n+following signature be:\n+</p>\n+<blockquote><pre>?  pow(float, int);\n+</pre></blockquote>\n+<p>\n+C++03 says that the return type should be <tt>float</tt>. \n+<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf\">\n+TR1</a> and C90/99 say the return type should be <tt>double</tt>.  This can put\n+clients into a situation where C++03 provides answers that are not as high\n+quality as C90/C99/TR1.  For example:\n+</p>\n+<blockquote><pre>#include &lt;math.h&gt;\n+\n+int main()\n+{\n+    float x = 2080703.375F;\n+    double y = pow(x, 2);\n+}\n+</pre></blockquote>\n+<p>\n+Assuming an IEEE 32 bit float and IEEE 64 bit double, C90/C99/TR1 all suggest:\n+</p>\n+\n+<blockquote><pre>y = 4329326534736.390625\n+</pre></blockquote>\n+\n+<p>\n+which is exactly right.  While C++98/C++03 demands:\n+</p>\n+\n+<blockquote><pre>y = 4329326510080.\n+</pre></blockquote>\n+\n+<p>\n+which is only approximately right.\n+</p>\n+\n+<p>\n+I recommend that C++0X adopt the mixed mode arithmetic already adopted by\n+Fortran, C and TR1 and make the return type of <tt>pow(float,int)</tt> be\n+<tt>double</tt>.\n+</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"551\"><h3>551.&nbsp;&lt;ccomplex&gt;</h3></a><p><b>Section:</b>&nbsp;TR1 8.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.c99.ccmplx\"> [tr.c99.ccmplx]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;23 Jan 2006</p>\n+<p>\n+Previously xxx.h was parsable by C++.  But in the case of C99's &lt;complex.h&gt;\n+it isn't.  Otherwise we could model it just like &lt;string.h&gt;, &lt;cstring&gt;, &lt;string&gt;:\n+</p>\n+\n+<ul>\n+<li>&lt;string&gt;   : C++ API in namespace std</li>\n+<li>&lt;cstring&gt;  : C API in namespace std</li>\n+<li>&lt;string.h&gt; : C API in global namespace</li>\n+</ul>\n+\n+<p>\n+In the case of C's complex, the C API won't compile in C++.  So we have:\n+</p>\n+\n+<ul>\n+<li>&lt;complex&gt;   : C++ API in namespace std</li>\n+<li>&lt;ccomplex&gt;  : ?</li>\n+<li>&lt;complex.h&gt; : ?</li>\n+</ul>\n+\n+<p>\n+The ? can't refer to the C API.  TR1 currently says:\n+</p>\n+\n+<ul>\n+<li>&lt;complex&gt;   : C++ API in namespace std</li>\n+<li>&lt;ccomplex&gt;  : C++ API in namespace std</li>\n+<li>&lt;complex.h&gt; : C++ API in global namespace</li>\n+</ul>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Strike 8.2 and 8.3 (and any other references to &lt;ccomplex&gt; and\n+&lt;complex.h&gt;).\n+</p>\n+<hr>\n+<a name=\"552\"><h3>552.&nbsp;random_shuffle and its generator</h3></a><p><b>Section:</b>&nbsp;25.2.11 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.random.shuffle\"> [lib.alg.random.shuffle]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;25 Jan 2006</p>\n+<p>\n+...is specified to shuffle its range by calling swap but not how\n+(or even that) it's supposed to use the RandomNumberGenerator\n+argument passed to it.\n+</p>\n+<p>\n+Shouldn't we require that the generator object actually be used\n+by the algorithm to obtain a series of random numbers and specify\n+how many times its operator() should be invoked by the algorithm?\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"553\"><h3>553.&nbsp;very minor editorial change intptr_t / uintptr_t</h3></a><p><b>Section:</b>&nbsp;TR1 8.22.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.c99.cstdint.syn\"> [tr.c99.cstdint.syn]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Paolo Carlini&nbsp; <b>Date:</b>&nbsp;30 Jan 2006</p>\n+<p>\n+In the synopsis, some types are identified as optional: int8_t, int16_t,\n+and so on, consistently with C99, indeed.\n+</p>\n+<p>\n+On the other hand, intptr_t and uintptr_t, are not marked as such and\n+probably should, consistently with C99, 7.18.1.4.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"554\"><h3>554.&nbsp;Problem with lwg DR 184 numeric_limits&lt;bool&gt;</h3></a><p><b>Section:</b>&nbsp;18.2.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-support.html#lib.numeric.special\"> [lib.numeric.special]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;29 Jan 2006</p>\n+<p>\n+I believe we have a bug in the resolution of:\n+<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184\">lwg 184</a>\n+(WP status).\n+</p>\n+\n+<p>\n+The resolution spells out each member of <tt>numeric_limits&lt;bool&gt;</tt>.\n+The part I'm having a little trouble with is:\n+</p>\n+<blockquote><pre>static const bool traps = false;\n+</pre></blockquote>\n+\n+<p>\n+Should this not be implementation defined?  Given:\n+</p>\n+\n+<blockquote><pre>int main()\n+{\n+     bool b1 = true;\n+     bool b2 = false;\n+     bool b3 = b1/b2;\n+}\n+</pre></blockquote>\n+\n+<p>\n+If this causes a trap, shouldn't <tt>numeric_limits&lt;bool&gt;::traps</tt> be\n+<tt>true</tt>?\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change 18.2.1.5p3:\n+</p>\n+\n+<blockquote>\n+-3- The specialization for <tt>bool</tt> shall be provided as follows: \n+<blockquote><pre>namespace std { \n+   template &lt;&gt; class numeric_limits&lt;bool&gt; {\n+      ...\n+      static const bool traps = <del>false</del> <ins><i>implementation-defined</i></ins>;\n+      ...\n+   };\n+}\n+</pre></blockquote>\n+</blockquote>\n+\n+<hr>\n+<a name=\"555\"><h3>555.&nbsp;TR1, 8.21/1: typo</h3></a><p><b>Section:</b>&nbsp;TR1 8.21 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.c99.boolh\"> [tr.c99.boolh]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Paolo Carlini&nbsp; <b>Date:</b>&nbsp;2 Feb 2006</p>\n+<p>\n+This one, if nobody noticed it yet, seems really editorial:\n+s/cstbool/cstdbool/\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change 8.21p1:\n+</p>\n+<blockquote>\n+-1- The header behaves as if it defines the additional macro defined in\n+<tt>&lt;cst<ins>d</ins>bool&gt;</tt> by including the header <tt>&lt;cstdbool&gt;</tt>.\n+</blockquote>\n+<hr>\n+<a name=\"556\"><h3>556.&nbsp;is Compare a BinaryPredicate?</h3></a><p><b>Section:</b>&nbsp;25.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.sorting\"> [lib.alg.sorting]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;5 Feb 2006</p>\n+<p>\n+In 25, p8 we allow BinaryPredicates to return a type that's convertible\n+to bool but need not actually be bool. That allows predicates to return\n+things like proxies and requires that implementations be careful about\n+what kinds of expressions they use the result of the predicate in (e.g.,\n+the expression in if (!pred(a, b)) need not be well-formed since the\n+negation operator may be inaccessible or return a type that's not\n+convertible to bool).\n+</p>\n+<p>\n+Here's the text for reference:\n+</p>\n+<blockquote>\n+  ...if an algorithm takes BinaryPredicate binary_pred as its argument\n+ and first1 and first2 as its iterator arguments, it should work\n+ correctly in the construct if (binary_pred(*first1, first2)){...}.\n+</blockquote>\n+\n+<p>\n+In 25.3, p2 we require that the Compare function object return true\n+of false, which would seem to preclude such proxies. The relevant text\n+is here:\n+</p>\n+<blockquote>\n+  Compare is used as a function object which returns true if the first\n+  argument is less than the second, and false otherwise...\n+</blockquote>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+I think we could fix this by rewording 25.3, p2 to read somthing like:\n+</p>\n+<blockquote>\n+-2- <tt>Compare</tt> is <del>used as a function object which returns\n+<tt>true</tt> if the first argument</del> <ins>a <tt>BinaryPredicate</tt>. The\n+return value of the function call operator applied to an object of type\n+<tt>Compare</tt>, when converted to type <tt>bool</tt>, yields <tt>true</tt>\n+if the first argument of the call</ins> is less than the second, and\n+<tt>false</tt> otherwise. <tt>Compare <i>comp</i></tt> is used throughout for\n+algorithms assuming an ordering relation. It is assumed that <tt><i>comp</i></tt>\n+will not apply any non-constant function through the dereferenced iterator.\n+</blockquote>\n+<hr>\n+<a name=\"557\"><h3>557.&nbsp;TR1: div(_Longlong, _Longlong) vs div(intmax_t, intmax_t)</h3></a><p><b>Section:</b>&nbsp;TR1 8.11.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.c99.cinttypes.syn\"> [tr.c99.cinttypes.syn]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Paolo Carlini&nbsp; <b>Date:</b>&nbsp;6 Feb 2006</p>\n+<p>\n+I'm seeing a problem with such overloads: when, _Longlong == intmax_t ==\n+long long we end up, essentially, with the same arguments and different\n+return types (lldiv_t and imaxdiv_t, respectively). Similar issue with\n+abs(_Longlong) and abs(intmax_t), of course.\n+</p>\n+<p>\n+Comparing sections 8.25 and 8.11, I see an important difference,\n+however: 8.25.3 and 8.25.4 carefully describe div and abs for _Longlong\n+types (rightfully, because not moved over directly from C99), whereas\n+there is no equivalent in 8.11: the abs and div overloads for intmax_t\n+types appear only in the synopsis and are not described anywhere, in\n+particular no mention in 8.11.2 (at variance with 8.25.2).\n+</p>\n+<p>\n+I'm wondering whether we really, really, want div and abs for intmax_t...\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change the <tt>&lt;cstdint&gt;</tt> synopsis in 8.11.1:\n+</p>\n+<blockquote><pre>...\n+intmax_t imaxabs(intmax_t i);\n+<del>intmax_t abs(intmax_t i);</del>\n+\n+imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);\n+<del>imaxdiv_t div(intmax_t numer, intmax_t denom);</del>\n+...\n+</pre></blockquote>\n+<hr>\n+<a name=\"558\"><h3>558.&nbsp;lib.input.iterators Defect</h3></a><p><b>Section:</b>&nbsp;24.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iterators.html#lib.input.iterators\"> [lib.input.iterators]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;David Abrahams&nbsp; <b>Date:</b>&nbsp;9 Feb 2006</p>\n+<blockquote>\n+<p>\n+  24.1.1 Input iterators [lib.input.iterators]\n+</p>\n+<p>\n+  1 A class or a built-in type X satisfies the requirements of an\n+  input iterator for the value type T if the following expressions are\n+  valid, where U is the type of any specified member of type T, as\n+  shown in Table 73.\n+</p>\n+</blockquote>\n+<p>\n+There is no capital U used in table 73.  There is a lowercase u, but\n+that is clearly not meant to denote a member of type T.  Also, there's\n+no description in 24.1.1 of what lowercase a means.  IMO the above\n+should have been...Hah, a and b are already covered in 24.1/11, so maybe it\n+should have just been:\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change 24.1.1p1:\n+</p>\n+<blockquote>\n+-1- A class or a built-in type <tt>X</tt> satisfies the requirements of an\n+input iterator for the value type <tt>T</tt> if the following expressions \n+are valid<del>, where <tt>U</tt> is the type of any specified member of type\n+<tt>T</tt>,</del> as shown in Table 73.\n+</blockquote>\n+<hr>\n+<a name=\"559\"><h3>559.&nbsp;numeric_limits&lt;const T&gt;</h3></a><p><b>Section:</b>&nbsp;18.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-support.html#lib.support.limits\"> [lib.support.limits]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;19 Feb 2006</p>\n+        <p>\n+\n+18.2.1, p2 requires implementations  to provide specializations of the\n+<code>numeric_limits</code> template for  each scalar type. While this\n+could be interepreted to include cv-qualified forms of such types such\n+an  interepretation   is  not  reflected   in  the  synopsis   of  the\n+<code>&lt;limits&gt;</code> header.\n+\n+        </p>\n+        <p>\n+\n+The absence  of specializations of the template  on cv-qualified forms\n+of  fundamental types  makes <code>numeric_limits</code>  difficult to\n+use in generic  code where the constness (or volatility)  of a type is\n+not  always  immediately  apparent.  In  such  contexts,  the  primary\n+template  ends   up  being   instantiated  instead  of   the  provided\n+specialization, typically yielding unexpected behavior.\n+\n+        </p>\n+<p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+Require   that  specializations   of   <code>numeric_limits</code>  on\n+cv-qualified fundamental types have the same semantics as those on the\n+unqualifed forms of the same types.\n+\n+        </p>\n+        <p>\n+\n+Add  to  the   synopsis  of  the  <code>&lt;limits&gt;</code>  header,\n+immediately  below  the  declaration  of  the  primary  template,  the\n+following:\n+\n+</p><pre>\n+template &lt;class T&gt; class numeric_limits&lt;const T&gt;;\n+template &lt;class T&gt; class numeric_limits&lt;volatile T&gt;;\n+template &lt;class T&gt; class numeric_limits&lt;const volatile T&gt;;\n+\n+</pre>\n+\n+        <p></p>\n+        <p>\n+\n+Add  a new paragraph  to the  end of  18.2.1.1, with  the following\n+text:\n+\n+        </p>\n+        <p>\n+\n+-new-para- The  value of each member  of a <code>numeric_limits</code>\n+specialization on a  cv-qualified T is equal to the  value of the same\n+member of <code>numeric_limits&lt;T&gt;</code>.\n+\n+        </p>\n+<hr>\n+<a name=\"560\"><h3>560.&nbsp;User-defined allocators without default constructor</h3></a><p><b>Section:</b>&nbsp;20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.requirements\"> [lib.allocator.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Sergey P. Derevyago&nbsp; <b>Date:</b>&nbsp;17 Feb 2006</p>\n+<h4>1. The essence of the problem.</h4>\n+<p>\n+User-defined allocators without default constructor are not explicitly\n+supported by the standard but they can be supported just like std::vector\n+supports elements without default constructor.\n+</p>\n+<p>\n+As a result, there exist implementations that work well with such allocators\n+and implementations that don't.\n+</p>\n+\n+<h4>2. The cause of the problem.</h4>\n+<p>\n+1) The standard doesn't explicitly state this intent but it should. In\n+particular, 20.1.5p5 explicitly state the intent w.r.t. the allocator\n+instances that compare non-equal. So it can similarly state the intent w.r.t.\n+the user-defined allocators without default constructor.\n+</p>\n+<p>\n+2) Some container operations are obviously underspecified. In particular,\n+21.3.7.1p2 tells:\n+</p>\n+<blockquote>\n+<pre>template&lt;class charT, class traits, class Allocator&gt;\n+  basic_string&lt;charT,traits,Allocator&gt; operator+(\n+    const charT* lhs,\n+    const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs\n+  );\n+</pre>\n+Returns: <tt>basic_string&lt;charT,traits,Allocator&gt;(lhs) + rhs</tt>.\n+</blockquote>\n+<p>\n+That leads to the basic_string&lt;charT,traits,Allocator&gt;(lhs, Allocator()) call.\n+Obviously, the right requirement is:\n+</p>\n+<blockquote>\n+Returns: <tt>basic_string&lt;charT,traits,Allocator&gt;(lhs, rhs.get_allocator()) + rhs</tt>.\n+</blockquote>\n+<p>\n+It seems like a lot of DRs can be submitted on this \"Absent call to\n+get_allocator()\" topic.\n+</p>\n+\n+<h4>3. Proposed actions.</h4>\n+<p>\n+1) Explicitly state the intent to allow for user-defined allocators without\n+default constructor in 20.1.5 Allocator requirements.\n+</p>\n+<p>\n+2) Correct all the places, where a correct allocator object is available\n+through the get_allocator() call but default Allocator() gets passed instead.\n+</p>\n+<h4>4. Code sample.</h4>\n+<p>\n+Let's suppose that the following memory pool is available:\n+</p>\n+<blockquote><pre>class mem_pool {\n+      // ...\n+      void* allocate(size_t size);\n+      void deallocate(void* ptr, size_t size);\n+};\n+</pre></blockquote>\n+<p>\n+So the following allocator can be implemented via this pool:\n+</p>\n+<blockquote><pre>class stl_allocator {\n+      mem_pool&amp; pool;\n+\n+ public:\n+      explicit stl_allocator(mem_pool&amp; mp) : pool(mp) {}\n+      stl_allocator(const stl_allocator&amp; sa) : pool(sa.pool) {}\n+      template &lt;class U&gt;\n+      stl_allocator(const stl_allocator&lt;U&gt;&amp; sa)  : pool(sa.get_pool()) {}\n+      ~stl_allocator() {}\n+\n+      pointer allocate(size_type n, std::allocator&lt;void&gt;::const_pointer = 0)\n+      {\n+       return (n!=0) ? static_cast&lt;pointer&gt;(pool.allocate(n*sizeof(T))) : 0;\n+      }\n+\n+      void deallocate(pointer p, size_type n)\n+      {\n+       if (n!=0) pool.deallocate(p, n*sizeof(T));\n+      }\n+\n+      // ...\n+};\n+</pre></blockquote>\n+<p>\n+Then the following code works well on some implementations and doesn't work on\n+another:\n+</p>\n+<blockquote><pre>typedef basic_string&lt;char, char_traits&lt;char&gt;, stl_allocator&lt;char&gt; &gt; \n+  tl_string;\n+mem_pool mp;\n+tl_string s1(\"abc\", stl_allocator&lt;int&gt;(mp));\n+printf(\"(%s)\\n\", (\"def\"+s1).c_str());\n+</pre></blockquote>\n+<p>\n+In particular, on some implementations the code can't be compiled without\n+default stl_allocator() constructor.\n+</p>\n+<p>\n+The obvious way to solve the compile-time problems is to intentionally define\n+a NULL pointer dereferencing default constructor\n+</p>\n+<blockquote><pre>stl_allocator() : pool(*static_cast&lt;mem_pool*&gt;(0)) {}\n+</pre></blockquote>\n+<p>\n+in a hope that it will not be called. The problem is that it really gets\n+called by operator+(const char*, const string&amp;) under the current 21.3.7.1p2\n+wording.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"561\"><h3>561.&nbsp;inserter overly generic</h3></a><p><b>Section:</b>&nbsp;24.4.2.6.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iterators.html#lib.inserter\"> [lib.inserter]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;21 Feb 2006</p>\n+<p>\n+The declaration of <tt>std::inserter</tt> is:\n+</p>\n+\n+<blockquote><pre>template &lt;class Container, class Iterator&gt;\n+insert_iterator&lt;Container&gt;\n+inserter(Container&amp; x, Iterator i);\n+</pre></blockquote>\n+\n+<p>\n+The template parameter <tt>Iterator</tt> in this function is completely unrelated\n+to the template parameter <tt>Container</tt> when it doesn't need to be.  This\n+causes the code to be overly generic.  That is, any type at all can be deduced\n+as <tt>Iterator</tt>, whether or not it makes sense.  Now the same is true of\n+<tt>Container</tt>.  However, for every free (unconstrained) template parameter\n+one has in a signature, the opportunity for a mistaken binding grows geometrically.\n+</p>\n+\n+<p>\n+It would be much better if <tt>inserter</tt> had the following signature instead:\n+</p>\n+\n+<blockquote><pre>template &lt;class Container&gt;\n+insert_iterator&lt;Container&gt;\n+inserter(Container&amp; x, typename Container::iterator i);\n+</pre></blockquote>\n+\n+<p>\n+Now there is only one free template parameter.  And the second argument to\n+<tt>inserter</tt> must be implicitly convertible to the container's iterator,\n+else the call will not be a viable overload (allowing other functions in the\n+overload set to take precedence).  Furthermore, the first parameter must have a\n+nested type named <tt>iterator</tt>, or again the binding to <tt>std::inserter</tt>\n+is not viable.  Contrast this with the current situation\n+where any type can bind to <tt>Container</tt> or <tt>Iterator</tt> and those\n+types need not be anything closely related to containers or iterators.\n+</p>\n+\n+<p>\n+This can adversely impact well written code.  Consider:\n+</p>\n+\n+<blockquote><pre>#include &lt;iterator&gt;\n+#include &lt;string&gt;\n+\n+namespace my\n+{\n+\n+template &lt;class String&gt;\n+struct my_type {};\n+\n+struct my_container\n+{\n+template &lt;class String&gt;\n+void push_back(const my_type&lt;String&gt;&amp;);\n+};\n+\n+template &lt;class String&gt;\n+void inserter(const my_type&lt;String&gt;&amp; m, my_container&amp; c) {c.push_back(m);}\n+\n+}  // my\n+\n+int main()\n+{\n+    my::my_container c;\n+    my::my_type&lt;std::string&gt; m;\n+    inserter(m, c);\n+}\n+</pre></blockquote>\n+\n+<p>\n+Today this code fails because the call to <tt>inserter</tt> binds to\n+<tt>std::inserter</tt> instead of to <tt>my::inserter</tt>.  However with the\n+proposed change <tt>std::inserter</tt> will no longer be a viable function which\n+leaves only <tt>my::inserter</tt> in the overload resolution set.  Everything\n+works as the client intends.\n+</p>\n+\n+<p>\n+To make matters a little more insidious, the above example works today if you\n+simply change the first argument to an rvalue:\n+</p>\n+\n+<blockquote><pre>    inserter(my::my_type(), c);\n+</pre></blockquote>\n+\n+<p>\n+It will also work if instantiated with some string type other than\n+<tt>std::string</tt> (or any other <tt>std</tt> type).  It will also work if\n+<tt>&lt;iterator&gt;</tt> happens to not get included.\n+</p>\n+\n+<p>\n+And it will fail again for such inocuous reaons as <tt>my_type</tt> or\n+<tt>my_container</tt> privately deriving from any <tt>std</tt> type.\n+</p>\n+\n+<p>\n+It seems unfortunate that such simple changes in the client's code can result\n+in such radically differing behavior.\n+</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change 24.2:\n+</p>\n+\n+<blockquote>\n+<b>24.2 Header</b> <tt>&lt;iterator&gt;</tt> <b>synopsis</b>\n+<blockquote><pre>...\n+template &lt;class Container<del>, class Iterator</del>&gt;\n+   insert_iterator&lt;Container&gt; inserter(Container&amp; x, <del>Iterator</del> <ins>typename Container::iterator</ins> i);\n+...\n+</pre></blockquote>\n+</blockquote>\n+\n+<p>\n+Change 24.4.2.5:\n+</p>\n+\n+<blockquote>\n+<b>24.4.2.5 Class template</b> <tt>insert_iterator</tt>\n+<blockquote><pre>...\n+template &lt;class Container<del>, class Iterator</del>&gt;\n+   insert_iterator&lt;Container&gt; inserter(Container&amp; x, <del>Iterator</del> <ins>typename Container::iterator</ins> i);\n+...\n+</pre></blockquote>\n+</blockquote>\n+\n+<p>\n+Change 24.4.2.6.5:\n+</p>\n+\n+<blockquote>\n+<p>\n+<b>24.4.2.6.5</b> <tt>inserter</tt>\n+</p>\n+<pre>template &lt;class Container<del>, class Inserter</del>&gt;\n+   insert_iterator&lt;Container&gt; inserter(Container&amp; x, <del>Inserter</del> <ins>typename Container::iterator</ins> i);\n+</pre>\n+<blockquote>\n+-1- <i>Returns:</i> <tt>insert_iterator&lt;Container&gt;(x,<del>typename Container::iterator(</del>i<del>)</del>)</tt>.\n+</blockquote>\n+</blockquote>\n+\n+<hr>\n+<a name=\"562\"><h3>562.&nbsp;stringbuf ctor inefficient</h3></a><p><b>Section:</b>&nbsp;27.7 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.string.streams\"> [lib.string.streams]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;23 Feb 2006</p>\n+        <p>\n+\n+For  better efficiency,  the requirement  on the  stringbuf  ctor that\n+takes  a  string  argument  should  be  loosened  up  to  let  it  set\n+<code>epptr()</code>  beyond  just   one  past  the  last  initialized\n+character  just like  <code>overflow()</code> has  been changed  to be\n+allowed  to  do   (see  issue  432).  That  way   the  first  call  to\n+<code>sputc()</code> on  an object won't  necessarily cause a  call to\n+<code>overflow</code>. The corresponding change  should be made to the\n+string overload of the <code>str()</code> member function.\n+\n+        </p>\n+<p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+Change 27.7.1.1, p3 of the Working Draft, N1804, as follows:\n+\n+        </p>\n+\n+<blockquote>\n+<pre>explicit basic_stringbuf(const basic_string&lt;charT,traits,Allocator&gt;&amp; <i>s<del>tr</del></i>,\n+               ios_base::openmode <i>which</i> = ios_base::in | ios_base::out);\n+</pre>\n+\n+<p>\n+-3- <i>Effects:</i>  Constructs an object of class <tt>basic_stringbuf</tt>,\n+initializing the base class with <tt>basic_streambuf()</tt>\n+(27.5.2.1), and initializing <tt><i>mode</i></tt> with <tt><i>which</i></tt>.\n+Then <ins>calls <tt>str(<i>s</i>)</tt>.</ins> <del>copies the content of\n+<i>str</i> into the <tt>basic_stringbuf</tt> underlying character\n+sequence. If <tt><i>which</i> &amp; ios_base::out</tt> is true, initializes the\n+output sequence such that <tt>pbase()</tt> points to the first underlying\n+character, <tt>epptr()</tt> points one past the last underlying character, and\n+<tt>pptr()</tt> is equal to <tt>epptr()</tt> if <tt><i>which</i> &amp; ios_base::ate</tt>\n+is true, otherwise <tt>pptr()</tt> is equal to <tt>pbase()</tt>. If\n+<tt>which &amp; ios_base::in</tt> is true, initializes the input sequence such\n+that <tt>eback()</tt> and <tt>gptr()</tt> point to the first underlying \n+character and <tt>egptr()</tt> points one past the last underlying character.</del>\n+</p>\n+</blockquote>\n+\n+        <p>\n+\n+Change the Effects clause of the <code>str()</code> in 27.7.1.2, p2 to\n+read:\n+\n+        </p>\n+<blockquote>\n+<p>\n+-2- <i>Effects:</i> Copies the content<ins>s</ins> of <tt><i>s</i></tt> into the\n+<tt>basic_stringbuf</tt> underlying character sequence <ins>and\n+initializes the input and output sequences according to <tt><i>mode</i></tt></ins>.\n+<del>If\n+<tt><i>mode</i> &amp; ios_base::out</tt> is true, initializes the output\n+sequence such that <tt>pbase()</tt> points to the first underlying character, \n+<tt>epptr()</tt> points one past the last underlying character, and <tt>pptr()</tt>\n+is equal to <tt>epptr()</tt> if <tt><i>mode</i> &amp; ios_base::in</tt>\n+is true, otherwise <tt>pptr()</tt> is equal to <tt>pbase()</tt>. If\n+<tt>mode &amp; ios_base::in</tt> is true, initializes the input sequence \n+such that <tt>eback()</tt> and <tt>gptr()</tt> point to the first underlying\n+character and <tt>egptr()</tt> points one past the last underlying character.</del>\n+</p>\n+\n+        <p>\n+\n+<ins>-3- <i>Postconditions:</i>  If  <code>mode  &amp; ios_base::out</code>  is  true,\n+<code>pbase()</code>  points  to the  first  underlying character  and\n+<code>(epptr() &gt;= pbase() + s.size())</code> holds; in addition, if\n+<code>mode &amp; ios_base::in</code> is true, <code>(pptr() == pbase()\n++ s.data())</code>  holds, otherwise <code>(pptr()  == pbase())</code>\n+is   true.    If  <code>mode   &amp;   ios_base::in</code>  is   true,\n+<code>eback()</code>  points to  the first  underlying  character, and\n+<code>(gptr()  ==  eback())</code>  and  <code>(egptr() ==  eback()  +\n+s.size())</code> hold.</ins>\n+\n+        </p>\n+</blockquote>\n+<hr>\n+<a name=\"563\"><h3>563.&nbsp;stringbuf seeking from end</h3></a><p><b>Section:</b>&nbsp;27.7.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.stringbuf.virtuals\"> [lib.stringbuf.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;23 Feb 2006</p>\n+<p>\n+According to  Table 92  (unchanged by issue  432), when  <code>(way ==\n+end)</code> the  <code>newoff</code> value in out mode  is computed as\n+the difference between <code>epptr()</code> and <code>pbase()</code>.\n+</p>\n+        <p>\n+\n+This value  isn't meaningful unless the  value of <code>epptr()</code>\n+can be  precisely controlled by a  program.  That used  to be possible\n+until  we accepted the  resolution of  issue 432,  but since  then the\n+requirements on <code>overflow()</code> have  been relaxed to allow it\n+to  make  more than  1  write  position  available (i.e.,  by  setting\n+<code>epptr()</code>     to     some     unspecified    value     past\n+<code>pptr()</code>).      So    after     the    first     call    to\n+<code>overflow()</code>  positioning the  output sequence  relative to\n+end will have unspecified results.\n+\n+        </p>\n+        <p>\n+\n+In  addition,  in <code>in|out</code>  mode,  since <code>(egptr()  ==\n+epptr())</code> need not hold, there are two different possible values\n+for   <code>newoff</code>:    <code>epptr()   -   pbase()</code>   and\n+<code>egptr() - eback()</code>.\n+\n+        </p>\n+<p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+Change the <code>newoff</code>  column in the last row  of Table 94 to\n+read:\n+\n+        </p>\n+<blockquote>\n+\n+the <del>end</del> <ins>high mark</ins> pointer minus the beginning \n+pointer (<code><del>xend</del> <ins>high_mark</ins> - xbeg</code>).\n+\n+</blockquote>\n+<hr>\n+<a name=\"564\"><h3>564.&nbsp;stringbuf seekpos underspecified</h3></a><p><b>Section:</b>&nbsp;27.7.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.stringbuf.virtuals\"> [lib.stringbuf.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;23 Feb 2006</p>\n+<p>\n+The   effects  of  the   <code>seekpos()</code>  member   function  of\n+<code>basic_stringbuf</code>  simply say  that the  function positions\n+the  input and/or  output  sequences  but fail  to  spell out  exactly\n+how. This is in contrast  to the detail in which <code>seekoff()</code>\n+is described.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+Change 27.7.1.3, p13 to read:\n+\n+        </p>\n+<blockquote>\n+<p>\n+-13- <i>Effects:</i> <ins>Same as <tt>seekoff(off_type(<i>sp</i>), ios_base::beg,\n+<i>which</i>)</tt>.</ins> <del>Alters the stream position within the controlled sequences,\n+if possible, to correspond to the stream position stored in <tt><i>sp</i></tt>\n+(as described below).</del>\n+</p>\n+<ul>\n+<li><del>If <tt>(<i>which</i> &amp; ios_base::in) != 0</tt>, positions the input sequence.</del></li>\n+<li><del>If <tt>(<i>which</i> &amp; ios_base::out) != 0</tt>, positions the output sequence.</del></li>\n+<li><del>If <tt><i>sp</i></tt> is an invalid stream position, or if the function\n+positions neither sequence, the positioning operation fails. If <tt><i>sp</i></tt>\n+has not been obtained by a previous successful call to one of the positioning\n+functions (<tt>seekoff</tt>, <tt>seekpos</tt>, <tt>tellg</tt>, <tt>tellp</tt>)\n+the effect is undefined.</del></li>\n+</ul>\n+</blockquote>\n+<hr>\n+<a name=\"565\"><h3>565.&nbsp;xsputn inefficient</h3></a><p><b>Section:</b>&nbsp;27.5.2.4.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.streambuf.virt.put\"> [lib.streambuf.virt.put]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;23 Feb 2006</p>\n+        <p>\n+\n+<tt>streambuf::xsputn()</tt>  is  specified  to  have  the  effect  of\n+\"writing up to  <tt>n</tt> characters to the output  sequence as if by\n+repeated calls to <tt>sputc(c)</tt>.\"\n+\n+        </p>\n+        <p>\n+\n+Since  <tt>sputc()</tt> is required  to call  <tt>overflow()</tt> when\n+<tt>(pptr()    ==   epptr())</tt>    is   true,    strictly   speaking\n+<tt>xsputn()</tt>  should do  the same.   However, doing  so  would be\n+suboptimal in  some interesting cases,  such as in unbuffered  mode or\n+when the buffer is <tt>basic_stringbuf</tt>.\n+\n+        </p>\n+        <p>\n+\n+Assuming  calling <tt>overflow()</tt>  is  not really  intended to  be\n+required  and the  wording is  simply  meant to  describe the  general\n+effect of appending to the end  of the sequence it would be worthwhile\n+to  mention in  <tt>xsputn()</tt> that  the function  is  not actually\n+required to cause a call to <tt>overflow()</tt>.\n+\n+        </p>\n+<p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+Add the following sentence  to the <tt>xsputn()</tt> Effects clause in\n+27.5.2.4.5, p1 (N1804):\n+\n+        </p>\n+        <blockquote>    \n+            <p>\n+-1- <i>Effects:</i> Writes up to <tt><i>n</i></tt> characters to the output\n+sequence as if by repeated calls to <tt>sputc(<i>c</i>)</tt>. The characters \n+written are obtained from successive elements of the array whose first element\n+is designated by <tt><i>s</i></tt>. Writing stops when either <tt><i>n</i></tt>\n+characters have been written or a call to <tt>sputc(<i>c</i>)</tt> would return\n+<tt>traits::eof()</tt>. <ins>It is  uspecified whether the function  calls\n+<tt>overflow()</tt> when <tt>(pptr() ==  epptr())</tt> becomes true or whether\n+it achieves the same effects by other means.</ins>\n+            </p>\n+        </blockquote>    \n+        <p>\n+\n+In addition,  I suggest to  add a footnote  to this function  with the\n+same text as Footnote 292 to  make it extra clear that derived classes\n+are permitted to override <tt>xsputn()</tt> for efficiency.\n+\n+        </p>\n+<hr>\n+<a name=\"566\"><h3>566.&nbsp;array forms of unformatted input function undefined for zero-element arrays</h3></a><p><b>Section:</b>&nbsp;27.6.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream.unformatted\"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;23 Feb 2006</p>\n+        <p>\n+\n+The array forms of unformatted input functions don't have well-defined\n+semantics for zero-element  arrays in a couple of  cases. The affected\n+ones (<tt>istream::get()</tt> and  <tt>getline()</tt>) are supposed to\n+terminate when <tt>(n - 1)</tt> characters are stored, which obviously\n+can never be true when <tt>(n == 0)</tt> to start with.\n+\n+        </p>\n+<p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+I  propose  the following  changes  (references  are  relative to  the\n+Working Draft (document N1804).\n+\n+        </p>\n+        <p>\n+\n+Change 27.6.1.3, p8 (<tt>istream::get()</tt>), bullet 1 as follows:\n+\n+        </p>\n+        <blockquote>\n+            <p>\n+\n+<ins>if  <tt>(n  &lt; 1)</tt>  is  true  or  </ins> <tt>(n  -  1)</tt>\n+characters are stored;\n+\n+            </p>\n+        </blockquote>\n+        <p>\n+\n+Similarly, change  27.6.1.3, p18 (<tt>istream::getline()</tt>), bullet\n+3 as follows:\n+\n+        </p>\n+        <blockquote>\n+            <p>\n+\n+<ins><tt>(n &lt; 1)</tt> is  true or </ins><tt>(n - 1)</tt> characters\n+are     stored     (in    which     case     the    function     calls\n+<tt>setstate(failbit)</tt>).\n+\n+            </p>\n+        </blockquote>\n+        <p>\n+\n+Finally, change p21 as follows:\n+\n+        </p>\n+        <blockquote>\n+            <p>\n+\n+In any  case, <ins>provided  <tt>(n &gt; 0)</tt>  is true,  </ins>it then\n+stores  a null  character  (using charT())  into  the next  successive\n+location of the array.\n+\n+            </p>\n+        </blockquote>\n <p>----- End of document -----</p>\n </body></html>\n\\ No newline at end of file"}, {"sha": "8d9138589c143d4c062977b8875a6b5dc89bcb6b", "filename": "libstdc++-v3/docs/html/ext/lwg-defects.html", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f663e4317656da61dc19f22bd7c443e46cd0ed/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f663e4317656da61dc19f22bd7c443e46cd0ed/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html?ref=a6f663e4317656da61dc19f22bd7c443e46cd0ed", "patch": "@@ -8,11 +8,11 @@\n <table>\n <tbody><tr>\n <td align=\"left\">Doc. no.</td>\n-<td align=\"left\">N1927=05-0187</td>\n+<td align=\"left\">N1950=06-0020</td>\n </tr>\n <tr>\n <td align=\"left\">Date:</td>\n-<td align=\"left\">2005-12-16</td>\n+<td align=\"left\">2006-02-24</td>\n </tr>\n <tr>\n <td align=\"left\">Project:</td>\n@@ -23,7 +23,7 @@\n <td align=\"left\">Howard Hinnant &lt;howard.hinnant@gmail.com&gt;</td>\n </tr>\n </tbody></table>\n-<h1>C++ Standard Library Defect Report List (Revision R40)</h1>\n+<h1>C++ Standard Library Defect Report List (Revision R41)</h1>\n   <p>Reference ISO/IEC IS 14882:1998(E)</p>\n   <p>Also see:</p>\n     <ul>\n@@ -45,6 +45,12 @@ <h1>C++ Standard Library Defect Report List (Revision R40)</h1>\n   document.</p>\n <h2>Revision History</h2>\n <ul>\n+<li>R41: \n+2006-02-24 pre-Berlin mailing.\n+Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#536\">536</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#566\">566</a>.\n+Moved <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#342\">342</a> from Ready to Open.\n+Reopened <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#309\">309</a>.\n+</li>\n <li>R40: \n 2005-12-16 mid-term mailing.\n Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#529\">529</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#535\">535</a>.\n@@ -649,7 +655,7 @@ <h2>Defect Reports</h2>\n <p>See 99-0040/N1216, October 22, 1999, by Stephen D. Clamage for the analysis\n supporting to the proposed resolution.</p>\n <hr>\n-<a name=\"11\"></a><h3><a name=\"11\">11.&nbsp;Bitset minor problems</a></h3><p><b>Section:</b>&nbsp;23.3.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.template.bitset\"> [lib.template.bitset]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;22 Jan 1998</p>\n+<a name=\"11\"><h3>11.&nbsp;Bitset minor problems</h3></a><p><b>Section:</b>&nbsp;23.3.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.template.bitset\"> [lib.template.bitset]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;22 Jan 1998</p>\n <p>(1) bitset&lt;&gt;::operator[] is mentioned in the class synopsis (23.3.5), but it is\n not documented in 23.3.5.2. </p>\n \n@@ -738,7 +744,7 @@ <h2>Defect Reports</h2>\n <tt>do_narrow</tt> and <tt>do_widen</tt> should be copied \n from 22.2.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.facet.ctype.special\"> [lib.facet.ctype.special]</a>.</p>\n <hr>\n-<a name=\"17\"></a><h3><a name=\"17\">17.&nbsp;Bad bool parsing</a></h3><p><b>Section:</b>&nbsp;22.2.2.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.facet.num.get.virtuals\"> [lib.facet.num.get.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>\n+<a name=\"17\"><h3>17.&nbsp;Bad bool parsing</h3></a><p><b>Section:</b>&nbsp;22.2.2.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.facet.num.get.virtuals\"> [lib.facet.num.get.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>\n <p>This section describes the process of parsing a text boolean value from the input\n stream. It does not say it recognizes either of the sequences \"true\" or\n \"false\" and returns the corresponding bool value; instead, it says it recognizes\n@@ -817,7 +823,7 @@ <h2>Defect Reports</h2>\n   <tt>err==str.failbit</tt>. --end example]</p>\n </blockquote>\n <hr>\n-<a name=\"18\"></a><h3><a name=\"18\">18.&nbsp;Get(...bool&amp;) omitted</a></h3><p><b>Section:</b>&nbsp;22.2.2.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.facet.num.get.members\"> [lib.facet.num.get.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>\n+<a name=\"18\"><h3>18.&nbsp;Get(...bool&amp;) omitted</h3></a><p><b>Section:</b>&nbsp;22.2.2.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.facet.num.get.members\"> [lib.facet.num.get.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Nathan Myers&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>\n <p>In the list of num_get&lt;&gt; non-virtual members on page 22-23, the member\n that parses bool values was omitted from the list of definitions of non-virtual\n members, though it is listed in the class definition and the corresponding\n@@ -2253,7 +2259,7 @@ <h2>Defect Reports</h2>\n by Judy Ward and Matt Austern.  This proposed resolution is section\n VI of that paper.</p>\n <hr>\n-<a name=\"61\"></a><h3><a name=\"61\">61.&nbsp;Ambiguity in iostreams exception policy</a></h3><p><b>Section:</b>&nbsp;27.6.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream.unformatted\"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>\n+<a name=\"61\"><h3>61.&nbsp;Ambiguity in iostreams exception policy</h3></a><p><b>Section:</b>&nbsp;27.6.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream.unformatted\"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;6 Aug 1998</p>\n <p>The introduction to the section on unformatted input (27.6.1.3)\n says that every unformatted input function catches all exceptions that\n were thrown during input, sets badbit, and then conditionally rethrows\n@@ -2347,7 +2353,7 @@ <h2>Defect Reports</h2>\n   (27.4.4.3), then the caught exception is rethrown. </p>\n </blockquote>\n <hr>\n-<a name=\"66\"></a><h3><a name=\"66\">66.&nbsp;Strstreambuf::setbuf</a></h3><p><b>Section:</b>&nbsp;D.7.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/future.html#depr.strstreambuf.virtuals\"> [depr.strstreambuf.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;18 Aug 1998</p>\n+<a name=\"66\"><h3>66.&nbsp;Strstreambuf::setbuf</h3></a><p><b>Section:</b>&nbsp;D.7.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/future.html#depr.strstreambuf.virtuals\"> [depr.strstreambuf.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;18 Aug 1998</p>\n <p>D.7.1.3, paragraph 19, says that strstreambuf::setbuf\n \"Performs an operation that is defined separately for each class\n derived from strstreambuf\". This is obviously an incorrect\n@@ -6457,7 +6463,7 @@ <h2>Defect Reports</h2>\n   to <tt>swap</tt>.  Also, in 26.3.3.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.valarray.transcend\"> [lib.valarray.transcend]</a> paragraph 1,\n   state that the valarray transcendentals use unqualified lookup.</p>\n <hr>\n-<a name=\"227\"></a><h3><a name=\"227\">227.&nbsp;std::swap() should require CopyConstructible or DefaultConstructible arguments</a></h3><p><b>Section:</b>&nbsp;25.2.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.swap\"> [lib.alg.swap]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Dave Abrahams&nbsp; <b>Date:</b>&nbsp;09 Apr 2000</p>\n+<a name=\"227\"><h3>227.&nbsp;std::swap() should require CopyConstructible or DefaultConstructible arguments</h3></a><p><b>Section:</b>&nbsp;25.2.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.swap\"> [lib.alg.swap]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#TC\">TC</a>&nbsp; <b>Submitter:</b>&nbsp;Dave Abrahams&nbsp; <b>Date:</b>&nbsp;09 Apr 2000</p>\n <p>25.2.2 reads:</p>\n <blockquote>\n   <p><tt>  template&lt;class T&gt; void swap(T&amp; a, T&amp; b);</tt><br>\n@@ -7036,7 +7042,7 @@ <h2>Defect Reports</h2>\n ]</i></p>\n \n <hr>\n-<a name=\"242\"></a><h3><a name=\"242\">242.&nbsp;Side effects of function objects</a></h3><p><b>Section:</b>&nbsp;25.2.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.transform\"> [lib.alg.transform]</a>, 26.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.numeric.ops\"> [lib.numeric.ops]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Angelika Langer&nbsp; <b>Date:</b>&nbsp;May 15 2000</p>\n+<a name=\"242\"><h3>242.&nbsp;Side effects of function objects</h3></a><p><b>Section:</b>&nbsp;25.2.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.transform\"> [lib.alg.transform]</a>, 26.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.numeric.ops\"> [lib.numeric.ops]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Angelika Langer&nbsp; <b>Date:</b>&nbsp;May 15 2000</p>\n <p>The algorithms transform(), accumulate(), inner_product(),\n partial_sum(), and adjacent_difference() require that the function\n object supplied to them shall not have any side effects.</p>\n@@ -12750,7 +12756,7 @@ <h2>Defect Reports</h2>\n uninitialized characters.  Positioning is only allowable over the\n initialized range.</p>\n <hr>\n-<a name=\"434\"></a><h3><a name=\"434\">434.&nbsp;bitset::to_string() hard to use</a></h3><p><b>Section:</b>&nbsp;23.3.5.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.bitset.members\"> [lib.bitset.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#DR\">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;15 Oct 2003</p>\n+<a name=\"434\"><h3>434.&nbsp;bitset::to_string() hard to use</h3></a><p><b>Section:</b>&nbsp;23.3.5.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.bitset.members\"> [lib.bitset.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#DR\">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;15 Oct 2003</p>\n <p>\n It has been pointed out a number of times that the bitset to_string() member\n function template is tedious to use since callers must explicitly specify the\n@@ -13210,7 +13216,7 @@ <h2>Defect Reports</h2>\n of <tt>sentry::operator bool()</tt> to const.\n </p>\n <hr>\n-<a name=\"443\"><h3>443.&nbsp;filebuf::close() inconsistent use of EOF</h3></a><p><b>Section:</b>&nbsp;27.8.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.filebuf.members\"> [lib.filebuf.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Vincent Leloup&nbsp; <b>Date:</b>&nbsp;20 Nov 2003</p>\n+<a name=\"443\"></a><h3><a name=\"443\">443.&nbsp;filebuf::close() inconsistent use of EOF</a></h3><p><b>Section:</b>&nbsp;27.8.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.filebuf.members\"> [lib.filebuf.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Vincent Leloup&nbsp; <b>Date:</b>&nbsp;20 Nov 2003</p>\n <p>\n In section 27.8.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.filebuf.members\"> [lib.filebuf.members]</a> par6, in effects description of\n basic_filebuf&lt;charT, traits&gt;::close(), overflow(EOF) is used twice;\n@@ -13795,7 +13801,7 @@ <h2>Defect Reports</h2>\n   Post-Redmond: Martin provided wording.]</i></p>\n \n <hr>\n-<a name=\"468\"></a><h3><a name=\"468\">468.&nbsp;unexpected consequences of ios_base::operator void*()</a></h3><p><b>Section:</b>&nbsp;27.4.4.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.iostate.flags\"> [lib.iostate.flags]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;28 Jun 2004</p>\n+<a name=\"468\"><h3>468.&nbsp;unexpected consequences of ios_base::operator void*()</h3></a><p><b>Section:</b>&nbsp;27.4.4.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.iostate.flags\"> [lib.iostate.flags]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;28 Jun 2004</p>\n \n <p>The program below is required to compile but when run it typically\n produces unexpected results due to the user-defined conversion from\n@@ -13893,5 +13899,24 @@ <h2>Defect Reports</h2>\n <p>The type, T, is not defined in this context.</p>\n <p><b>Proposed resolution:</b></p>\n <p>Replace \"T\" with \"value_type\".</p>\n+<hr>\n+<a name=\"533\"><h3>533.&nbsp;typo in 2.2.3.10/1</h3></a><p><b>Section:</b>&nbsp;TR1 2.2.3.10 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.util.smartptr.getdeleter\"> [tr.util.smartptr.getdeleter]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#DR\">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Paolo Carlini&nbsp; <b>Date:</b>&nbsp;9 Nov 2005</p>\n+<p>\n+I'm seeing something that looks like a typo. The Return of <tt>get_deleter</tt>\n+says:\n+</p>\n+<blockquote>\n+If <tt>*this</tt> <i>owns</i> a deleter <tt>d</tt>...\n+</blockquote>\n+<p>\n+but <tt>get_deleter</tt> is a free function!\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Therefore, I think should be:\n+</p>\n+<blockquote>\n+If <tt><del>*this</del> <ins>p</ins></tt> <i>owns</i> a deleter <tt>d</tt>...\n+</blockquote>\n <p>----- End of document -----</p>\n </body></html>\n\\ No newline at end of file"}]}