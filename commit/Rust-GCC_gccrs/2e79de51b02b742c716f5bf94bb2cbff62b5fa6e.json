{"sha": "2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU3OWRlNTFiMDJiNzQyYzcxNmY1YmY5NGJiMmNiZmY2MmI1ZmE2ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-07T12:45:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-07T12:45:48Z"}, "message": "[multiple changes]\n\n2010-10-07  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch3.adb, par-ch6.adb, par-ch7.adb, par-ch9.adb, par-ch10.adb: Add\n\tPexp to Pf_Rec constants\n\t(P_Subprogram): Expression is always enclosed in parentheses\n\t* par.adb (Pf_Rec): add Pexp flag for parametrized expression\n\t* sinfo.ads (N_Parametrized_Expression): Expression must be in parens\n\n2010-10-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Specification): Implement Ada2012\n\tchecks on functions that return an abstract type or have a controlling\n\tresult whose designated type is an abstract type.\n\t(Check_Private_Overriding): Implement Ada2012 checks on functions\n\tdeclared in the private part, if an abstract type is involved.\n\t* sem_ch12.adb (Analyze_Generic_Subprogram_Declaration): In Ada2012,\n\treject a generic function that returns an abstract type.\n\t* exp_ch5.adb (Expand_Simple_Function_Return): in Ada2012, if a\n\tfunction has a controlling access result, check that the tag of the\n\treturn value matches the designated type of the return expression.\n\nFrom-SVN: r165100", "tree": {"sha": "b5d98752418158a359ebc8106e255270aba2aff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5d98752418158a359ebc8106e255270aba2aff9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/comments", "author": null, "committer": null, "parents": [{"sha": "da7d70aae388ceeefd8b829865ba6ea55d4171c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da7d70aae388ceeefd8b829865ba6ea55d4171c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da7d70aae388ceeefd8b829865ba6ea55d4171c9"}], "stats": {"total": 339, "additions": 233, "deletions": 106}, "files": [{"sha": "68b651de5f302468bfa4740820f290166dd0dc83", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "patch": "@@ -1,3 +1,24 @@\n+2010-10-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch3.adb, par-ch6.adb, par-ch7.adb, par-ch9.adb, par-ch10.adb: Add\n+\tPexp to Pf_Rec constants\n+\t(P_Subprogram): Expression is always enclosed in parentheses\n+\t* par.adb (Pf_Rec): add Pexp flag for parametrized expression\n+\t* sinfo.ads (N_Parametrized_Expression): Expression must be in parens\n+\n+2010-10-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Specification): Implement Ada2012\n+\tchecks on functions that return an abstract type or have a controlling\n+\tresult whose designated type is an abstract type.\n+\t(Check_Private_Overriding): Implement Ada2012 checks on functions\n+\tdeclared in the private part, if an abstract type is involved.\n+\t* sem_ch12.adb (Analyze_Generic_Subprogram_Declaration): In Ada2012,\n+\treject a generic function that returns an abstract type.\n+\t* exp_ch5.adb (Expand_Simple_Function_Return): in Ada2012, if a\n+\tfunction has a controlling access result, check that the tag of the\n+\treturn value matches the designated type of the return expression.\n+\n 2010-10-07  Robert Dewar  <dewar@adacore.com>\n \n \t* par-ch6.adb: Fix error in handling of parametrized expressions."}, {"sha": "647f08819f88ab4d43eadf09c11fc58a3116f5b4", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "patch": "@@ -4246,6 +4246,29 @@ package body Exp_Ch5 is\n                         Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n                 Reason => PE_Accessibility_Check_Failed));\n          end;\n+\n+      --  AI05-0073 : if function has a controlling access result, check that\n+      --  the tag of the return value matches the designated type.\n+\n+      elsif Ekind (R_Type) = E_Anonymous_Access_Type\n+        and then Has_Controlling_Result (Scope_Id)\n+        and then Ada_Version >= Ada_12\n+      then\n+         Insert_Action (Exp,\n+           Make_Raise_Constraint_Error (Loc,\n+             Condition =>\n+               Make_Op_Ne (Loc,\n+                 Left_Opnd =>\n+                   Make_Selected_Component (Loc,\n+                     Prefix => Duplicate_Subexpr (Exp),\n+                     Selector_Name =>\n+                       Make_Identifier (Loc, Chars => Name_uTag)),\n+                 Right_Opnd =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix =>\n+                       New_Occurrence_Of (Designated_Type (R_Type), Loc),\n+                     Attribute_Name => Name_Tag)),\n+           Reason => CE_Tag_Check_Failed));\n       end if;\n \n       --  If we are returning an object that may not be bit-aligned, then copy"}, {"sha": "e59a8c0f7088bf5a5d36fa895a98005a3faae74b", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "patch": "@@ -347,10 +347,10 @@ package body Ch10 is\n             Error_Msg_BC -- CODEFIX\n               (\"keyword BODY expected here [see file name]\");\n             Restore_Scan_State (Scan_State);\n-            Set_Unit (Comp_Unit_Node, P_Package (Pf_Pbod));\n+            Set_Unit (Comp_Unit_Node, P_Package (Pf_Pbod_Pexp));\n          else\n             Restore_Scan_State (Scan_State);\n-            Set_Unit (Comp_Unit_Node, P_Package (Pf_Decl_Gins_Pbod_Rnam));\n+            Set_Unit (Comp_Unit_Node, P_Package (Pf_Decl_Gins_Pbod_Rnam_Pexp));\n          end if;\n \n       elsif Token = Tok_Generic then\n@@ -364,7 +364,7 @@ package body Ch10 is\n         or else Token = Tok_Overriding\n         or else Token = Tok_Procedure\n       then\n-         Set_Unit (Comp_Unit_Node, P_Subprogram (Pf_Decl_Gins_Pbod_Rnam));\n+         Set_Unit (Comp_Unit_Node, P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Pexp));\n \n          --  A little bit of an error recovery check here. If we just scanned\n          --  a subprogram declaration (as indicated by an SIS entry being\n@@ -1034,10 +1034,10 @@ package body Ch10 is\n         or else Token = Tok_Overriding\n         or else Token = Tok_Procedure\n       then\n-         Body_Node := P_Subprogram (Pf_Pbod);\n+         Body_Node := P_Subprogram (Pf_Pbod_Pexp);\n \n       elsif Token = Tok_Package then\n-         Body_Node := P_Package (Pf_Pbod);\n+         Body_Node := P_Package (Pf_Pbod_Pexp);\n \n       elsif Token = Tok_Protected then\n          Scan; -- past PROTECTED"}, {"sha": "885ba1e5761488f0abc364c6cec58c3022bb1ed3", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "patch": "@@ -4142,7 +4142,7 @@ package body Ch3 is\n \n          when Tok_Function =>\n             Check_Bad_Layout;\n-            Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub), Decls);\n+            Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub_Pexp), Decls);\n             Done := False;\n \n          when Tok_For =>\n@@ -4186,7 +4186,7 @@ package body Ch3 is\n                Error_Msg_SC (\"\\unit must be compiled with -gnat05 switch\");\n \n                Token := Tok_Overriding;\n-               Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub), Decls);\n+               Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub_Pexp), Decls);\n                Done := False;\n \n             --  Normal case, no overriding, or overriding followed by colon\n@@ -4201,17 +4201,17 @@ package body Ch3 is\n \n          when Tok_Not =>\n             Check_Bad_Layout;\n-            Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub), Decls);\n+            Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub_Pexp), Decls);\n             Done := False;\n \n          when Tok_Overriding =>\n             Check_Bad_Layout;\n-            Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub), Decls);\n+            Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub_Pexp), Decls);\n             Done := False;\n \n          when Tok_Package =>\n             Check_Bad_Layout;\n-            Append (P_Package (Pf_Decl_Gins_Pbod_Rnam_Stub), Decls);\n+            Append (P_Package (Pf_Decl_Gins_Pbod_Rnam_Stub_Pexp), Decls);\n             Done := False;\n \n          when Tok_Pragma =>\n@@ -4220,7 +4220,7 @@ package body Ch3 is\n \n          when Tok_Procedure =>\n             Check_Bad_Layout;\n-            Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub), Decls);\n+            Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub_Pexp), Decls);\n             Done := False;\n \n          when Tok_Protected =>"}, {"sha": "a074f53f0253b7dd190bd46c9292b0e89f8320c8", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 94, "deletions": 57, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "patch": "@@ -124,7 +124,7 @@ package body Ch6 is\n    --  other subprogram constructs.\n \n    --  PARAMETRIZED_EXPRESSION ::=\n-   --    FUNCTION SPECIFICATION IS EXPRESSION;\n+   --    FUNCTION SPECIFICATION IS (EXPRESSION);\n \n    --  The value in Pf_Flags indicates which of these possible declarations\n    --  is acceptable to the caller:\n@@ -134,6 +134,7 @@ package body Ch6 is\n    --    Pf_Flags.Pbod                 Set if proper body OK\n    --    Pf_Flags.Rnam                 Set if renaming declaration OK\n    --    Pf_Flags.Stub                 Set if body stub OK\n+   --    Pf_Flags.Pexp                 Set if parametrized expression OK\n \n    --  If an inappropriate form is encountered, it is scanned out but an\n    --  error message indicating that it is appearing in an inappropriate\n@@ -221,17 +222,17 @@ package body Ch6 is\n          --  already been given, so no need to give another message here.\n \n          --  An overriding indicator is allowed for subprogram declarations,\n-         --  bodies (including subunits), renamings, stubs, and\n-         --  instantiations. The test against Pf_Decl_Pbod is added to account\n-         --  for the case of subprograms declared in a protected type, where\n-         --  only subprogram declarations and bodies can occur. The Pf_Pbod\n-         --  case is for subunits.\n+         --  bodies (including subunits), renamings, stubs, and instantiations.\n+         --  The test against Pf_Decl_Pbod is added to account for the case of\n+         --  subprograms declared in a protected type, where only subprogram\n+         --  declarations and bodies can occur. The Pf_Pbod case is for\n+         --  subunits.\n \n-         if Pf_Flags /= Pf_Decl_Gins_Pbod_Rnam_Stub\n+         if Pf_Flags /= Pf_Decl_Gins_Pbod_Rnam_Stub_Pexp\n               and then\n-            Pf_Flags /= Pf_Decl_Pbod\n+            Pf_Flags /= Pf_Decl_Pbod_Pexp\n               and then\n-            Pf_Flags /= Pf_Pbod\n+            Pf_Flags /= Pf_Pbod_Pexp\n          then\n             Error_Msg_SC (\"overriding indicator not allowed here!\");\n \n@@ -583,12 +584,9 @@ package body Ch6 is\n          end if;\n       end if;\n \n-      --  Processing for subprogram body or parametrized expression\n+      --  Processing for stub or subprogram body or parametrized expression\n \n       <<Subprogram_Body>>\n-         if not Pf_Flags.Pbod then\n-            Error_Msg_SP (\"subprogram body not allowed here!\");\n-         end if;\n \n          --  Subprogram body stub case\n \n@@ -614,28 +612,24 @@ package body Ch6 is\n          --  Subprogram body or parametrized expression case\n \n          else\n-            --  Here we must distinguish a body and a parametrized expression\n+            Scan_Body_Or_Parametrized_Expression : declare\n \n-            Parse_Body_Or_Parametrized_Expression : declare\n-               function Is_Parametrized_Expression return Boolean;\n-               --  Returns True if we have case of parametrized epression\n+               function Likely_Parametrized_Expression return Boolean;\n+               --  Returns True if we have a probably case of a parametrized\n+               --  expression omitting the parentheses, if so, returns True\n+               --  and emits an appropriate error message, else returns False.\n \n-               --------------------------------\n-               -- Is_Parametrized_Expression --\n-               --------------------------------\n+               ------------------------------------\n+               -- Likely_Parametrized_Expression --\n+               ------------------------------------\n \n-               function Is_Parametrized_Expression return Boolean is\n+               function Likely_Parametrized_Expression return Boolean is\n                begin\n-                  --  Parametrized expression only allowed in Ada 2012\n-\n-                  if Ada_Version < Ada_12 then\n-                     return False;\n-\n                   --  If currently pointing to BEGIN or a declaration keyword\n                   --  or a pragma, then we definitely have a subprogram body.\n                   --  This is a common case, so worth testing first.\n \n-                  elsif Token = Tok_Begin\n+                  if Token = Tok_Begin\n                     or else Token in Token_Class_Declk\n                     or else Token = Tok_Pragma\n                   then\n@@ -652,42 +646,79 @@ package body Ch6 is\n                     or else Token = Tok_New\n                     or else Token = Tok_Not\n                   then\n-                     return True;\n+                     null;\n \n-                  --  Anything other than an identifier must be a body at\n-                  --  this stage. Probably we could do a little better job of\n-                  --  distingushing some more error cases, but it seems right\n-                  --  to err on the side of favoring a body over the\n-                  --  new-fangled parametrized expression.\n+                  --  Anything other than an identifier must be a body\n \n                   elsif Token /= Tok_Identifier then\n                      return False;\n \n-                  --  For identifier we have to scan ahead if identifier is\n-                  --  followed by a colon or a comma, it is a declaration and\n-                  --  hence we have a subprogram body. Otherwise we have an\n-                  --  expression.\n+                  --  Here for an identifier\n \n                   else\n-                     declare\n-                        Scan_State : Saved_Scan_State;\n-                        Tok        : Token_Type;\n-                     begin\n-                        Save_Scan_State (Scan_State);\n-                        Scan; -- past identifier\n-                        Tok := Token;\n-                        Restore_Scan_State (Scan_State);\n-                        return Tok /= Tok_Colon and then Tok /= Tok_Comma;\n-                     end;\n+                     --  If the identifier is the first token on its line, then\n+                     --  let's assume that we have a missing begin and this is\n+                     --  intended as a subprogram body.\n+\n+                     if Token_Is_At_Start_Of_Line then\n+                        return False;\n+\n+                     --  Otherwise we have to scan ahead. If the identifier is\n+                     --  followed by a colon or a comma, it is a declaration\n+                     --  and hence we have a subprogram body. Otherwise assume\n+                     --  a parametrized expression.\n+\n+                     else\n+                        declare\n+                           Scan_State : Saved_Scan_State;\n+                           Tok        : Token_Type;\n+                        begin\n+                           Save_Scan_State (Scan_State);\n+                           Scan; -- past identifier\n+                           Tok := Token;\n+                           Restore_Scan_State (Scan_State);\n+\n+                           if Tok = Tok_Colon or else Tok = Tok_Comma then\n+                              return False;\n+                           end if;\n+                        end;\n+                     end if;\n                   end if;\n-               end Is_Parametrized_Expression;\n \n-            --  Start of processing for Parse_Body_Or_Parametrized_Expression\n+                  --  Fall through if we have a likely parametrized expression\n+\n+                  Error_Msg_SC\n+                    (\"parametrized expression must be \"\n+                     & \"enclosed in parentheses\");\n+                  return True;\n+               end Likely_Parametrized_Expression;\n+\n+            --  Start of processing for Scan_Body_Or_Parametrized_Expression\n \n             begin\n-               --  Parametrized_Expression case, parse expression\n+               --  Parametrized_Expression case\n+\n+               if Token = Tok_Left_Paren\n+                 or else Likely_Parametrized_Expression\n+               then\n+                  --  Check parametrized expression allowed here\n+\n+                  if not Pf_Flags.Pexp then\n+                     Error_Msg_SC\n+                       (\"parametrized expression not allowed here!\");\n+                  end if;\n+\n+                  --  Check we are in Ada 2012 mode\n+\n+                  if Ada_Version < Ada_12 then\n+                     Error_Msg_SC\n+                       (\"parametrized expression is an Ada 2012 feature!\");\n+                     Error_Msg_SC\n+                       (\"\\unit must be compiled with -gnat2012 switch!\");\n+                  end if;\n+\n+                  --  Parse out expression and build parametrized expression\n \n-               if Is_Parametrized_Expression then\n                   Body_Node :=\n                     New_Node\n                       (N_Parametrized_Expression, Sloc (Specification_Node));\n@@ -699,10 +730,16 @@ package body Ch6 is\n                --  Subprogram body case\n \n                else\n-                  --  Here is the test for a suspicious IS (i.e. one that looks\n-                  --  like it might more properly be a semicolon). See separate\n-                  --  section discussing use of IS instead of semicolon in\n-                  --  package Parse.\n+                  --  Check body allowed here\n+\n+                  if not Pf_Flags.Pbod then\n+                     Error_Msg_SP (\"subprogram body not allowed here!\");\n+                  end if;\n+\n+                  --  Here is the test for a suspicious IS (i.e. one that\n+                  --  looks like it might more properly be a semicolon).\n+                  --  See separate section describing use of IS instead\n+                  --  of semicolon in package Parse.\n \n                   if (Token in Token_Class_Declk\n                         or else\n@@ -715,7 +752,7 @@ package body Ch6 is\n                   end if;\n \n                   --  Build and return subprogram body, parsing declarations\n-                  --  an statement sequence that belong to the body.\n+                  --  and statement sequence that belong to the body.\n \n                   Body_Node :=\n                     New_Node (N_Subprogram_Body, Sloc (Specification_Node));\n@@ -724,7 +761,7 @@ package body Ch6 is\n                end if;\n \n                return Body_Node;\n-            end Parse_Body_Or_Parametrized_Expression;\n+            end Scan_Body_Or_Parametrized_Expression;\n          end if;\n \n       --  Processing for subprogram declaration"}, {"sha": "d4238d2991de0dc10718f8085fb24d52caf4fcd3", "filename": "gcc/ada/par-ch7.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar-ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar-ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch7.adb?ref=2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "patch": "@@ -109,7 +109,7 @@ package body Ch7 is\n       --  Case of package body. Note that we demand a package body if that\n       --  is the only possibility (even if the BODY keyword is not present)\n \n-      if Token = Tok_Body or else Pf_Flags = Pf_Pbod then\n+      if Token = Tok_Body or else Pf_Flags = Pf_Pbod_Pexp then\n          if not Pf_Flags.Pbod then\n             Error_Msg_SC (\"package body cannot appear here!\");\n          end if;"}, {"sha": "f7a0c7f78373e7c6214875d616099d511453e443", "filename": "gcc/ada/par-ch9.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "patch": "@@ -651,7 +651,7 @@ package body Ch9 is\n                Set_Must_Not_Override (Decl, Not_Overriding);\n \n             elsif Token = Tok_Function or else Token = Tok_Procedure then\n-               Decl := P_Subprogram (Pf_Decl);\n+               Decl := P_Subprogram (Pf_Decl_Pexp);\n \n                Set_Must_Override     (Specification (Decl), Is_Overriding);\n                Set_Must_Not_Override (Specification (Decl), Not_Overriding);\n@@ -682,7 +682,7 @@ package body Ch9 is\n             return P_Entry_Declaration;\n \n          elsif Token = Tok_Function or else Token = Tok_Procedure then\n-            return P_Subprogram (Pf_Decl);\n+            return P_Subprogram (Pf_Decl_Pexp);\n \n          elsif Token = Tok_Identifier then\n             L := New_List;\n@@ -754,7 +754,7 @@ package body Ch9 is\n                  or else\n                Token = Tok_Not or else Bad_Spelling_Of (Tok_Not)\n          then\n-            Append (P_Subprogram (Pf_Decl_Pbod), Item_List);\n+            Append (P_Subprogram (Pf_Decl_Pbod_Pexp), Item_List);\n \n          elsif Token = Tok_Pragma or else Bad_Spelling_Of (Tok_Pragma) then\n             P_Pragmas_Opt (Item_List);"}, {"sha": "7ba6e0c0cbcbdf67b581d156f09e0943ee04a018", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "patch": "@@ -352,26 +352,26 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       Pbod : Boolean;                  -- True if proper body OK\n       Rnam : Boolean;                  -- True if renaming declaration OK\n       Stub : Boolean;                  -- True if body stub OK\n-      Fil1 : Boolean;                  -- Filler to fill to 8 bits\n+      Pexp : Boolean;                  -- True if parametried expression OK\n       Fil2 : Boolean;                  -- Filler to fill to 8 bits\n    end record;\n    pragma Pack (Pf_Rec);\n \n    function T return Boolean renames True;\n    function F return Boolean renames False;\n \n-   Pf_Decl_Gins_Pbod_Rnam_Stub : constant Pf_Rec :=\n-                                   Pf_Rec'(F, T, T, T, T, T, F, F);\n-   Pf_Decl                     : constant Pf_Rec :=\n-                                   Pf_Rec'(F, T, F, F, F, F, F, F);\n-   Pf_Decl_Gins_Pbod_Rnam      : constant Pf_Rec :=\n-                                   Pf_Rec'(F, T, T, T, T, F, F, F);\n-   Pf_Decl_Pbod                : constant Pf_Rec :=\n-                                   Pf_Rec'(F, T, F, T, F, F, F, F);\n-   Pf_Pbod                     : constant Pf_Rec :=\n-                                   Pf_Rec'(F, F, F, T, F, F, F, F);\n-   Pf_Spcn                     : constant Pf_Rec :=\n-                                   Pf_Rec'(T, F, F, F, F, F, F, F);\n+   Pf_Decl_Gins_Pbod_Rnam_Stub_Pexp : constant Pf_Rec :=\n+                                       Pf_Rec'(F, T, T, T, T, T, T, F);\n+   Pf_Decl_Pexp                     : constant Pf_Rec :=\n+                                       Pf_Rec'(F, T, F, F, F, F, T, F);\n+   Pf_Decl_Gins_Pbod_Rnam_Pexp      : constant Pf_Rec :=\n+                                       Pf_Rec'(F, T, T, T, T, F, T, F);\n+   Pf_Decl_Pbod_Pexp                : constant Pf_Rec :=\n+                                       Pf_Rec'(F, T, F, T, F, F, T, F);\n+   Pf_Pbod_Pexp                     : constant Pf_Rec :=\n+                                       Pf_Rec'(F, F, F, T, F, F, T, F);\n+   Pf_Spcn                         : constant Pf_Rec :=\n+                                       Pf_Rec'(T, F, F, F, F, F, F, F);\n    --  The above are the only allowed values of Pf_Rec arguments\n \n    type SS_Rec is record"}, {"sha": "7a2208ef76047bccce18fa7b16b50d7a15a0d286", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "patch": "@@ -2800,10 +2800,28 @@ package body Sem_Ch12 is\n          if Nkind (Result_Definition (Spec)) = N_Access_Definition then\n             Result_Type := Access_Definition (Spec, Result_Definition (Spec));\n             Set_Etype (Id, Result_Type);\n+\n+            --  Check restriction imposed by AI05-073 : a generic function\n+            --  cannot return an abstract type or an access to such.\n+\n+            if Is_Abstract_Type (Designated_Type (Result_Type))\n+              and then Ada_Version >= Ada_12\n+            then\n+               Error_Msg_N (\"generic function cannot have an access result\"\n+                 & \" that designates an abstract type\", Spec);\n+            end if;\n+\n          else\n             Find_Type (Result_Definition (Spec));\n             Typ := Entity (Result_Definition (Spec));\n \n+            if Is_Abstract_Type (Typ)\n+              and then Ada_Version >= Ada_12\n+            then\n+               Error_Msg_N\n+                 (\"generic function cannot have abstract result type\", Spec);\n+            end if;\n+\n             --  If a null exclusion is imposed on the result type, then create\n             --  a null-excluding itype (an access subtype) and use it as the\n             --  function's Etype."}, {"sha": "7be427e7b63fe4ad686cc643340b10df512bc63b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "patch": "@@ -2960,16 +2960,29 @@ package body Sem_Ch6 is\n          --  In case of primitives associated with abstract interface types\n          --  the check is applied later (see Analyze_Subprogram_Declaration).\n \n-         if Is_Abstract_Type (Etype (Designator))\n-           and then not Is_Interface (Etype (Designator))\n-           and then Nkind (Parent (N)) /= N_Subprogram_Renaming_Declaration\n-           and then Nkind (Parent (N)) /=\n-                      N_Abstract_Subprogram_Declaration\n-           and then\n-             (Nkind (Parent (N))) /= N_Formal_Abstract_Subprogram_Declaration\n+         if not Nkind_In (Parent (N),\n+             N_Subprogram_Renaming_Declaration,\n+             N_Abstract_Subprogram_Declaration,\n+             N_Formal_Abstract_Subprogram_Declaration)\n          then\n-            Error_Msg_N\n-              (\"function that returns abstract type must be abstract\", N);\n+            if Is_Abstract_Type (Etype (Designator))\n+              and then not Is_Interface (Etype (Designator))\n+            then\n+               Error_Msg_N\n+                 (\"function that returns abstract type must be abstract\", N);\n+\n+            --  Ada 2012 (AI-0073) : extend this test to subprograms with an\n+            --  access result whose designated type is abstract.\n+\n+            elsif Nkind (Result_Definition (N)) = N_Access_Definition\n+              and then\n+                not Is_Class_Wide_Type (Designated_Type (Etype (Designator)))\n+              and then Is_Abstract_Type (Designated_Type (Etype (Designator)))\n+              and then Ada_Version >= Ada_12\n+            then\n+               Error_Msg_N (\"function whose access result designates \"\n+                 & \"abstract type must be abstract\", N);\n+            end if;\n          end if;\n       end if;\n \n@@ -7029,16 +7042,34 @@ package body Sem_Ch6 is\n                      & \"(RM 3.9.3(10))!\", S);\n \n                elsif Ekind (S) = E_Function\n-                 and then Is_Tagged_Type (T)\n-                 and then T = Base_Type (Etype (S))\n                  and then not Is_Overriding\n                then\n-                  Error_Msg_N\n-                    (\"private function with tagged result must\"\n-                     & \" override visible-part function\", S);\n-                  Error_Msg_N\n-                    (\"\\move subprogram to the visible part\"\n-                     & \" (RM 3.9.3(10))\", S);\n+                  if Is_Tagged_Type (T)\n+                    and then T = Base_Type (Etype (S))\n+                  then\n+                     Error_Msg_N\n+                       (\"private function with tagged result must\"\n+                        & \" override visible-part function\", S);\n+                     Error_Msg_N\n+                       (\"\\move subprogram to the visible part\"\n+                        & \" (RM 3.9.3(10))\", S);\n+\n+                  --  AI05-0073: extend this test to the case of a function\n+                  --  with a controlling access result.\n+\n+                  elsif Ekind (Etype (S)) = E_Anonymous_Access_Type\n+                    and then Is_Tagged_Type (Designated_Type (Etype (S)))\n+                    and then\n+                      not Is_Class_Wide_Type (Designated_Type (Etype (S)))\n+                    and then Ada_Version >= Ada_12\n+                  then\n+                     Error_Msg_N\n+                       (\"private function with controlling access result \"\n+                          & \"must override visible-part function\", S);\n+                     Error_Msg_N\n+                       (\"\\move subprogram to the visible part\"\n+                          & \" (RM 3.9.3(10))\", S);\n+                  end if;\n                end if;\n             end if;\n          end Check_Private_Overriding;"}, {"sha": "af28795e574b47476f2820d6c7bf4cc24c0237d7", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e79de51b02b742c716f5bf94bb2cbff62b5fa6e/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=2e79de51b02b742c716f5bf94bb2cbff62b5fa6e", "patch": "@@ -4435,10 +4435,7 @@ package Sinfo is\n       --  and put in its proper section when we know exactly where that is!\n \n       --  PARAMETRIZED_EXPRESSION ::=\n-      --    FUNCTION SPECIFICATION IS EXPRESSION;\n-\n-      --  Note: there are no separate nodes for the profiles, instead the\n-      --  information appears directly in the following nodes.\n+      --    FUNCTION SPECIFICATION IS (EXPRESSION);\n \n       --  N_Parametrized_Expression\n       --  Sloc points to FUNCTION"}]}