{"sha": "cfeffe9c461762bf95ba63dce535c81ddb36f109", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZlZmZlOWM0NjE3NjJiZjk1YmE2M2RjZTUzNWM4MWRkYjM2ZjEwOQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-07-01T14:52:11Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-07-01T14:52:11Z"}, "message": "Return true/false instead of 1/0 from generic predicates.\n\nNo functional changes.\n\n2021-07-01  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/\n\t* recog.c (general_operand): Return true/false instead of 1/0.\n\t(register_operand): Ditto.\n\t(immediate_operand): Ditto.\n\t(const_int_operand): Ditto.\n\t(const_scalar_int_operand): Ditto.\n\t(const_double_operand): Ditto.\n\t(push_operand): Ditto.\n\t(pop_operand): Ditto.\n\t(memory_operand): Ditto.\n\t(indirect_operand): Ditto.", "tree": {"sha": "aff8d48e11be24520286b112b53ee5df4d550ee8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aff8d48e11be24520286b112b53ee5df4d550ee8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfeffe9c461762bf95ba63dce535c81ddb36f109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfeffe9c461762bf95ba63dce535c81ddb36f109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfeffe9c461762bf95ba63dce535c81ddb36f109", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfeffe9c461762bf95ba63dce535c81ddb36f109/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a86b3453fc6e29cf0e19916b01c393652d838d56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a86b3453fc6e29cf0e19916b01c393652d838d56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a86b3453fc6e29cf0e19916b01c393652d838d56"}], "stats": {"total": 64, "additions": 32, "deletions": 32}, "files": [{"sha": "2114df8c0d17e8ea9acbe087716c772297f9c628", "filename": "gcc/recog.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfeffe9c461762bf95ba63dce535c81ddb36f109/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfeffe9c461762bf95ba63dce535c81ddb36f109/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=cfeffe9c461762bf95ba63dce535c81ddb36f109", "patch": "@@ -1420,12 +1420,12 @@ general_operand (rtx op, machine_mode mode)\n   if (GET_MODE (op) == VOIDmode && mode != VOIDmode\n       && GET_MODE_CLASS (mode) != MODE_INT\n       && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n-    return 0;\n+    return false;\n \n   if (CONST_INT_P (op)\n       && mode != VOIDmode\n       && trunc_int_for_mode (INTVAL (op), mode) != INTVAL (op))\n-    return 0;\n+    return false;\n \n   if (CONSTANT_P (op))\n     return ((GET_MODE (op) == VOIDmode || GET_MODE (op) == mode\n@@ -1439,7 +1439,7 @@ general_operand (rtx op, machine_mode mode)\n      OP's mode must match MODE if MODE specifies a mode.  */\n \n   if (GET_MODE (op) != mode)\n-    return 0;\n+    return false;\n \n   if (code == SUBREG)\n     {\n@@ -1452,7 +1452,7 @@ general_operand (rtx op, machine_mode mode)\n \t get cleaned up by cleanup_subreg_operands.  */\n       if (!reload_completed && MEM_P (sub)\n \t  && paradoxical_subreg_p (op))\n-\treturn 0;\n+\treturn false;\n #endif\n       /* Avoid memories with nonzero SUBREG_BYTE, as offsetting the memory\n          may result in incorrect reference.  We should simplify all valid\n@@ -1463,7 +1463,7 @@ general_operand (rtx op, machine_mode mode)\n       if (!reload_completed\n \t  && maybe_ne (SUBREG_BYTE (op), 0)\n \t  && MEM_P (sub))\n-\treturn 0;\n+\treturn false;\n \n       if (REG_P (sub)\n \t  && REGNO (sub) < FIRST_PSEUDO_REGISTER\n@@ -1474,7 +1474,7 @@ general_operand (rtx op, machine_mode mode)\n \t     operand reload presentation.  LRA needs to treat them as\n \t     valid.  */\n \t  && ! LRA_SUBREG_P (op))\n-\treturn 0;\n+\treturn false;\n \n       /* FLOAT_MODE subregs can't be paradoxical.  Combine will occasionally\n \t create such rtl, and we must reject it.  */\n@@ -1486,7 +1486,7 @@ general_operand (rtx op, machine_mode mode)\n \t     mode.  */\n \t  && ! lra_in_progress \n \t  && paradoxical_subreg_p (op))\n-\treturn 0;\n+\treturn false;\n \n       op = sub;\n       code = GET_CODE (op);\n@@ -1501,18 +1501,18 @@ general_operand (rtx op, machine_mode mode)\n       rtx y = XEXP (op, 0);\n \n       if (! volatile_ok && MEM_VOLATILE_P (op))\n-\treturn 0;\n+\treturn false;\n \n       /* Use the mem's mode, since it will be reloaded thus.  LRA can\n \t generate move insn with invalid addresses which is made valid\n \t and efficiently calculated by LRA through further numerous\n \t transformations.  */\n       if (lra_in_progress\n \t  || memory_address_addr_space_p (GET_MODE (op), y, MEM_ADDR_SPACE (op)))\n-\treturn 1;\n+\treturn true;\n     }\n \n-  return 0;\n+  return false;\n }\n \f\n /* Return true if OP is a valid memory address for a memory reference\n@@ -1552,10 +1552,10 @@ register_operand (rtx op, machine_mode mode)\n \t but currently it does result from (SUBREG (REG)...) where the\n \t reg went on the stack.)  */\n       if (!REG_P (sub) && (reload_completed || !MEM_P (sub)))\n-\treturn 0;\n+\treturn false;\n     }\n   else if (!REG_P (op))\n-    return 0;\n+    return false;\n   return general_operand (op, mode);\n }\n \n@@ -1574,7 +1574,7 @@ bool\n scratch_operand (rtx op, machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n+    return false;\n \n   return (GET_CODE (op) == SCRATCH\n \t  || (REG_P (op)\n@@ -1596,12 +1596,12 @@ immediate_operand (rtx op, machine_mode mode)\n   if (GET_MODE (op) == VOIDmode && mode != VOIDmode\n       && GET_MODE_CLASS (mode) != MODE_INT\n       && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n-    return 0;\n+    return false;\n \n   if (CONST_INT_P (op)\n       && mode != VOIDmode\n       && trunc_int_for_mode (INTVAL (op), mode) != INTVAL (op))\n-    return 0;\n+    return false;\n \n   return (CONSTANT_P (op)\n \t  && (GET_MODE (op) == mode || mode == VOIDmode\n@@ -1618,13 +1618,13 @@ bool\n const_int_operand (rtx op, machine_mode mode)\n {\n   if (!CONST_INT_P (op))\n-    return 0;\n+    return false;\n \n   if (mode != VOIDmode\n       && trunc_int_for_mode (INTVAL (op), mode) != INTVAL (op))\n-    return 0;\n+    return false;\n \n-  return 1;\n+  return true;\n }\n \n #if TARGET_SUPPORTS_WIDE_INT\n@@ -1634,7 +1634,7 @@ bool\n const_scalar_int_operand (rtx op, machine_mode mode)\n {\n   if (!CONST_SCALAR_INT_P (op))\n-    return 0;\n+    return false;\n \n   if (CONST_INT_P (op))\n     return const_int_operand (op, mode);\n@@ -1646,10 +1646,10 @@ const_scalar_int_operand (rtx op, machine_mode mode)\n       int bitsize = GET_MODE_BITSIZE (int_mode);\n \n       if (CONST_WIDE_INT_NUNITS (op) * HOST_BITS_PER_WIDE_INT > bitsize)\n-\treturn 0;\n+\treturn false;\n \n       if (prec == bitsize)\n-\treturn 1;\n+\treturn true;\n       else\n \t{\n \t  /* Multiword partial int.  */\n@@ -1658,7 +1658,7 @@ const_scalar_int_operand (rtx op, machine_mode mode)\n \t  return (sext_hwi (x, prec & (HOST_BITS_PER_WIDE_INT - 1)) == x);\n \t}\n     }\n-  return 1;\n+  return true;\n }\n \n /* Return true if OP is an operand that is a constant integer or constant\n@@ -1682,7 +1682,7 @@ const_double_operand (rtx op, machine_mode mode)\n   if (GET_MODE (op) == VOIDmode && mode != VOIDmode\n       && GET_MODE_CLASS (mode) != MODE_INT\n       && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n-    return 0;\n+    return false;\n \n   return ((CONST_DOUBLE_P (op) || CONST_INT_P (op))\n \t  && (mode == VOIDmode || GET_MODE (op) == mode\n@@ -1719,10 +1719,10 @@ bool\n push_operand (rtx op, machine_mode mode)\n {\n   if (!MEM_P (op))\n-    return 0;\n+    return false;\n \n   if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return 0;\n+    return false;\n \n   poly_int64 rounded_size = GET_MODE_SIZE (mode);\n \n@@ -1735,7 +1735,7 @@ push_operand (rtx op, machine_mode mode)\n   if (known_eq (rounded_size, GET_MODE_SIZE (mode)))\n     {\n       if (GET_CODE (op) != STACK_PUSH_CODE)\n-\treturn 0;\n+\treturn false;\n     }\n   else\n     {\n@@ -1747,7 +1747,7 @@ push_operand (rtx op, machine_mode mode)\n \t  || (STACK_GROWS_DOWNWARD\n \t      ? maybe_ne (offset, -rounded_size)\n \t      : maybe_ne (offset, rounded_size)))\n-\treturn 0;\n+\treturn false;\n     }\n \n   return XEXP (op, 0) == stack_pointer_rtx;\n@@ -1763,15 +1763,15 @@ bool\n pop_operand (rtx op, machine_mode mode)\n {\n   if (!MEM_P (op))\n-    return 0;\n+    return false;\n \n   if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return 0;\n+    return false;\n \n   op = XEXP (op, 0);\n \n   if (GET_CODE (op) != STACK_POP_CODE)\n-    return 0;\n+    return false;\n \n   return XEXP (op, 0) == stack_pointer_rtx;\n }\n@@ -1812,7 +1812,7 @@ memory_operand (rtx op, machine_mode mode)\n     return MEM_P (op) && general_operand (op, mode);\n \n   if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return 0;\n+    return false;\n \n   inner = op;\n   if (GET_CODE (inner) == SUBREG)\n@@ -1832,7 +1832,7 @@ indirect_operand (rtx op, machine_mode mode)\n       && GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op)))\n     {\n       if (mode != VOIDmode && GET_MODE (op) != mode)\n-\treturn 0;\n+\treturn false;\n \n       /* The only way that we can have a general_operand as the resulting\n \t address is if OFFSET is zero and the address already is an operand"}]}