{"sha": "19af645506250e3ba54b35491e70f67485904168", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTlhZjY0NTUwNjI1MGUzYmE1NGIzNTQ5MWU3MGY2NzQ4NTkwNDE2OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-10-01T10:00:33Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-10-01T10:00:33Z"}, "message": "Delete !REGISTER_CONSTRAINTS code\n\nFrom-SVN: r29753", "tree": {"sha": "70f6058ae5fb3c1614281db92972314c13b5c500", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70f6058ae5fb3c1614281db92972314c13b5c500"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19af645506250e3ba54b35491e70f67485904168", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19af645506250e3ba54b35491e70f67485904168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19af645506250e3ba54b35491e70f67485904168", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19af645506250e3ba54b35491e70f67485904168/comments", "author": null, "committer": null, "parents": [{"sha": "39d6e3d71b06eb47a429ae05f0252131aef51999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d6e3d71b06eb47a429ae05f0252131aef51999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39d6e3d71b06eb47a429ae05f0252131aef51999"}], "stats": {"total": 266, "additions": 48, "deletions": 218}, "files": [{"sha": "b11c577fcd518b85c1832c549c6d0fcacc0c3ee4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -1,3 +1,34 @@\n+Fri Oct  1 10:56:06 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* Makefile.in (genattrtab.o): Don't depend on \"insn-config.h\".\n+\t* final.c (final_scan_insn): We always have register constraints.\n+\t* genattrtab.c: Don't include \"insn-config.h\".\n+\t(write_attr_case): We always have register constraints.\n+\t* genconfig.c (register_constraint_flag): Delete.\n+\t(walk_insn_part): Don't check whether we have register constraints.\n+\t(main): Don't write out \"#define REGISTER_CONSTRAINTS\".\n+\t* genoutput.c (have_constraints): Delete.\n+\t(main): Don't set it.\n+\t(output_operand_data): We always have constraints.\n+\t(scan_operands): Likewise.\n+\t(compare_operands): Likewise.\n+\t* local-alloc.c (block_alloc): We always have constraints.\n+\t(requires_inout): Always compile this function.\n+\t* recog.c (extract_insn): We always have constraints.\n+\t(constrain_operands, reg_fits_class_p): Always compile these\n+\tfunctions.\n+\t* recog.h (struct recog_data): Delete non-REGISTER_CONSTRAINTS\n+\tfields.\n+\t(struct insn_operand_data): Likewise.\n+\t* regclass.c (regclass): We always have constraints.\n+\t(record_reg_classes, copy_cost, record_address_regs,\n+\tauto_inc_dec_reg_p): Always compile these functions.\n+\t* regmove.c (regmove_optimize): We always have constraints.\n+\t* reload.c (find_reloads): Likewise.\n+\t* reload1.c (reload): Likewise.\n+\t(reload_cse_simplify_operands): Likewise.\n+\t* i860.c (output_delay_insn): Likewise.\n+\n Thu Sep 30 23:04:41 1999  Mark P. Mitchell  <mark@codesourcery.com>\n \n \t* iris6.h (BUILD_VA_LIST_TYPE): Define."}, {"sha": "5a09bb7b1d61019d9fa594b0810e93783e524e14", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -1844,7 +1844,7 @@ genattrtab : genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_RTLANA\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n \t genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_RTLANAL) $(HOST_LIBS)\n \n-genattrtab.o : genattrtab.c $(RTL_H)  $(build_xm_file) system.h insn-config.h errors.h ggc.h\n+genattrtab.o : genattrtab.c $(RTL_H)  $(build_xm_file) system.h errors.h ggc.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genattrtab.c\n \n genoutput : genoutput.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)"}, {"sha": "0bd53f077444b624c88e88c067a744f471ed3247", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -1493,10 +1493,8 @@ output_delay_insn (delay_insn)\n \trecog_data.operand[i] = alter_subreg (recog_data.operand[i]);\n     }\n \n-#ifdef REGISTER_CONSTRAINTS\n   if (! constrain_operands (1))\n     abort ();\n-#endif\n \n   cc_prev_status = cc_status;\n "}, {"sha": "5ef12ef36108e666b85d57ecfcb167eb2e4aba21", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -2886,10 +2886,8 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \textract_insn (insn);\n \tcleanup_subreg_operands (insn);\n \n-#ifdef REGISTER_CONSTRAINTS\n \tif (! constrain_operands (1))\n \t  fatal_insn_not_found (insn);\n-#endif\n \n \t/* Some target machines need to prescan each insn before\n \t   it is output.  */"}, {"sha": "f6fee5cb34ff3d091c0784fd34b620aec04ace7f", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -98,7 +98,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"hconfig.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n-#include \"insn-config.h\"\t/* For REGISTER_CONSTRAINTS */\n #include \"ggc.h\"\n \n #ifdef HAVE_SYS_RESOURCE_H\n@@ -5128,12 +5127,10 @@ write_attr_case (attr, av, write_case_lines, prefix, suffix, indent,\n \n   if (must_constrain)\n     {\n-#ifdef REGISTER_CONSTRAINTS\n       write_indent (indent + 2);\n       printf (\"if (! constrain_operands (reload_completed))\\n\");\n       write_indent (indent + 2);\n       printf (\"  fatal_insn_not_found (insn);\\n\");\n-#endif\n     }\n \n   write_attr_set (attr, indent + 2, av->value, prefix, suffix,"}, {"sha": "23bffeab3b92758d895268623ea856feea53585a", "filename": "gcc/genconfig.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -36,7 +36,6 @@ struct obstack *rtl_obstack = &obstack;\n static int max_recog_operands;  /* Largest operand number seen.  */\n static int max_dup_operands;    /* Largest number of match_dup in any insn.  */\n static int max_clobbers_per_insn;\n-static int register_constraint_flag;\n static int have_cc0_flag;\n static int have_cmove_flag;\n static int have_cond_arith_flag;\n@@ -85,8 +84,6 @@ walk_insn_part (part, recog_p, non_pc_set_src)\n     case MATCH_OPERAND:\n       if (XINT (part, 0) > max_recog_operands)\n \tmax_recog_operands = XINT (part, 0);\n-      if (XSTR (part, 2) && *XSTR (part, 2))\n-\tregister_constraint_flag = 1;\n       return;\n \n     case MATCH_OP_DUP:\n@@ -345,9 +342,6 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#ifndef MAX_INSNS_PER_SPLIT\\n#define MAX_INSNS_PER_SPLIT %d\\n#endif\\n\",\n \t  max_insns_per_split);\n \n-  if (register_constraint_flag)\n-    printf (\"#define REGISTER_CONSTRAINTS\\n\");\n-\n   if (have_cc0_flag)\n     printf (\"#define HAVE_cc0\\n\");\n "}, {"sha": "fa55181f787549851ffa961eec77ec550d0c4614", "filename": "gcc/genoutput.c", "status": "modified", "additions": 13, "deletions": 40, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -169,12 +169,6 @@ struct data\n /* This variable points to the first link in the insn chain.  */\n \n static struct data *idata, **idata_end = &idata;\n-\n-/* Nonzero if any match_operand has a constraint string; implies that\n-   REGISTER_CONSTRAINTS will be defined for this machine description.  */\n-\n-static int have_constraints;\n-\n \f\n static void output_prologue PROTO((void));\n static void output_predicate_decls PROTO((void));\n@@ -289,17 +283,10 @@ output_operand_data ()\n       printf (\"    %s,\\n\",\n \t      d->predicate && d->predicate[0] ? d->predicate : \"0\");\n \n-      if (have_constraints)\n-\t{\n-\t  printf (\"    \\\"%s\\\",\\n\",\n-\t\t  d->constraint ? d->constraint : \"\");\n-\t}\n+      printf (\"    \\\"%s\\\",\\n\", d->constraint ? d->constraint : \"\");\n \n       printf (\"    %smode,\\n\", GET_MODE_NAME (d->mode));\n \n-      if (! have_constraints)\n-\tprintf (\"    %d,\\n\", d->address_p);\n-\n       printf (\"    %d\\n\", d->strict_low);\n \n       printf(\"  },\\n\");\n@@ -446,11 +433,8 @@ scan_operands (d, part, this_address_p, this_strict_low)\n       d->operand[opno].predicate = XSTR (part, 1);\n       d->operand[opno].constraint = XSTR (part, 2);\n       if (XSTR (part, 2) != 0 && *XSTR (part, 2) != 0)\n-\t{\n-\t  d->operand[opno].n_alternatives\n-\t    = n_occurrences (',', XSTR (part, 2)) + 1;\n-\t  have_constraints = 1;\n-\t}\n+\td->operand[opno].n_alternatives\n+\t  = n_occurrences (',', XSTR (part, 2)) + 1;\n       d->operand[opno].address_p = this_address_p;\n       return;\n \n@@ -473,11 +457,8 @@ scan_operands (d, part, this_address_p, this_strict_low)\n       d->operand[opno].predicate = \"scratch_operand\";\n       d->operand[opno].constraint = XSTR (part, 1);\n       if (XSTR (part, 1) != 0 && *XSTR (part, 1) != 0)\n-\t{\n-\t  d->operand[opno].n_alternatives\n-\t    = n_occurrences (',', XSTR (part, 1)) + 1;\n-\t  have_constraints = 1;\n-\t}\n+\td->operand[opno].n_alternatives\n+\t  = n_occurrences (',', XSTR (part, 1)) + 1;\n       d->operand[opno].address_p = 0;\n       return;\n \n@@ -557,25 +538,18 @@ compare_operands (d0, d1)\n   if (strcmp (p0, p1) != 0)\n     return 0;\n \n-  if (have_constraints)\n-    {\n-      p0 = d0->constraint;\n-      if (!p0)\n-\tp0 = \"\";\n-      p1 = d1->constraint;\n-      if (!p1)\n-\tp1 = \"\";\n-      if (strcmp (p0, p1) != 0)\n-\treturn 0;\n-    }\n+  p0 = d0->constraint;\n+  if (!p0)\n+    p0 = \"\";\n+  p1 = d1->constraint;\n+  if (!p1)\n+    p1 = \"\";\n+  if (strcmp (p0, p1) != 0)\n+    return 0;\n \n   if (d0->mode != d1->mode)\n     return 0;\n \n-  if (!have_constraints)\n-    if (d0->address_p != d1->address_p)\n-      return 0;\n-\n   if (d0->strict_low != d1->strict_low)\n     return 0;\n \n@@ -937,7 +911,6 @@ main (argc, argv)\n   output_prologue ();\n   next_code_number = 0;\n   next_index_number = 0;\n-  have_constraints = 0;\n \n   /* Read the machine description.  */\n "}, {"sha": "8191ce0eaf8161fd3e012207f9842810a494eacd", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -1082,9 +1082,6 @@ block_alloc (b)\n \t  register rtx r0, r1;\n \t  int combined_regno = -1;\n \t  int i;\n-#ifndef REGISTER_CONSTRAINTS\n-\t  register rtx body = PATTERN (insn);\n-#endif\n \n \t  this_insn_number = insn_number;\n \t  this_insn = insn;\n@@ -1110,18 +1107,10 @@ block_alloc (b)\n \n \t     If tying is done, WIN is set nonzero.  */\n \n-\t  if (1\n-#ifdef REGISTER_CONSTRAINTS\n-\t      && recog_data.n_operands > 1\n+\t  if (recog_data.n_operands > 1\n \t      && recog_data.constraints[0][0] == '='\n-\t      && recog_data.constraints[0][1] != '&'\n-#else\n-\t      && GET_CODE (PATTERN (insn)) == SET\n-\t      && rtx_equal_p (SET_DEST (PATTERN (insn)), recog_data.operand[0])\n-#endif\n-\t      )\n+\t      && recog_data.constraints[0][1] != '&')\n \t    {\n-#ifdef REGISTER_CONSTRAINTS\n \t      /* If non-negative, is an operand that must match operand 0.  */\n \t      int must_match_0 = -1;\n \t      /* Counts number of alternatives that require a match with\n@@ -1137,12 +1126,10 @@ block_alloc (b)\n \t\t  if (this_match == recog_data.n_alternatives)\n \t\t    must_match_0 = i;\n \t\t}\n-#endif\n \n \t      r0 = recog_data.operand[0];\n \t      for (i = 1; i < recog_data.n_operands; i++)\n \t\t{\n-#ifdef REGISTER_CONSTRAINTS\n \t\t  /* Skip this operand if we found an operand that\n \t\t     must match operand 0 and this operand isn't it\n \t\t     and can't be made to be it by commutativity.  */\n@@ -1162,20 +1149,13 @@ block_alloc (b)\n \t\t  if (n_matching_alts == recog_data.n_alternatives\n \t\t      && 0 == requires_inout (recog_data.constraints[i]))\n \t\t    continue;\n-#endif\n \n \t\t  r1 = recog_data.operand[i];\n \n \t\t  /* If the operand is an address, find a register in it.\n \t\t     There may be more than one register, but we only try one\n \t\t     of them.  */\n-\t\t  if (\n-#ifdef REGISTER_CONSTRAINTS\n-\t\t      recog_data.constraints[i][0] == 'p'\n-#else\n-\t\t      recog_data.operand_address_p[i]\n-#endif\n-\t\t      )\n+\t\t  if (recog_data.constraints[i][0] == 'p')\n \t\t    while (GET_CODE (r1) == PLUS || GET_CODE (r1) == MULT)\n \t\t      r1 = XEXP (r1, 0);\n \n@@ -1186,11 +1166,7 @@ block_alloc (b)\n \t\t\t can only be in the same register as the output, give\n \t\t\t priority to an equivalence found from that insn.  */\n \t\t      int may_save_copy\n-#ifdef REGISTER_CONSTRAINTS\n \t\t\t= (r1 == recog_data.operand[i] && must_match_0 >= 0);\n-#else\n-\t\t\t= (SET_DEST (body) == r0 && SET_SRC (body) == r1);\n-#endif\n \t\t      \n \t\t      if (GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG)\n \t\t\twin = combine_regs (r1, r0, may_save_copy,\n@@ -2199,8 +2175,6 @@ no_conflict_p (insn, r0, r1)\n   return ok;\n }\n \f\n-#ifdef REGISTER_CONSTRAINTS\n-\n /* Return the number of alternatives for which the constraint string P\n    indicates that the operand must be equal to operand 0 and that no register\n    is acceptable.  */\n@@ -2257,7 +2231,6 @@ requires_inout (p)\n \n   return num_matching_alts;\n }\n-#endif /* REGISTER_CONSTRAINTS */\n \f\n void\n dump_local_alloc (file)"}, {"sha": "5a29920350d668b1df109c4879f7b829a63ff688", "filename": "gcc/recog.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -2012,10 +2012,6 @@ extract_insn (insn)\n \t      while (*p)\n \t\trecog_data.n_alternatives += (*p++ == ',');\n \t    }\n-#ifndef REGISTER_CONSTRAINTS\n-\t  bzero (recog_data.operand_address_p,\n-\t\t sizeof recog_data.operand_address_p);\n-#endif\n \t  break;\n \t}\n \n@@ -2037,12 +2033,7 @@ extract_insn (insn)\n \n       for (i = 0; i < noperands; i++)\n \t{\n-#ifdef REGISTER_CONSTRAINTS\n \t  recog_data.constraints[i] = insn_data[icode].operand[i].constraint;\n-#else\n-\t  recog_data.operand_address_p[i]\n-\t    = insn_data[icode].operand[i].address_p;\n-#endif\n \t  recog_data.operand_mode[i] = insn_data[icode].operand[i].mode;\n \t}\n     }\n@@ -2161,8 +2152,6 @@ preprocess_constraints ()\n     }\n }\n  \n-#ifdef REGISTER_CONSTRAINTS\n-\n /* Check the operands of an insn against the insn's operand constraints\n    and return 1 if they are valid.\n    The information about the insn's operands, constraints, operand modes\n@@ -2572,8 +2561,6 @@ reg_fits_class_p (operand, class, offset, mode)\n \n   return 0;\n }\n-\n-#endif /* REGISTER_CONSTRAINTS */\n \f\n /* Do the splitting of insns in the block B. Only try to actually split if\n    DO_SPLIT is true; otherwise, just remove nops. */ "}, {"sha": "0e26f2547d75b6b47177c500919b56e542a7ad70", "filename": "gcc/recog.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -158,11 +158,6 @@ struct recog_data\n      duplicate-appearance of an operand.  */\n   char dup_num[MAX_DUP_OPERANDS];\n \n-#ifndef REGISTER_CONSTRAINTS\n-  /* Nonzero if operand N should be an address.  */\n-  char operand_address_p[MAX_RECOG_OPERANDS];\n-#endif\n-\n   /* ??? Note that these are `char' instead of `unsigned char' to (try to)\n      avoid certain lossage from K&R C, wherein `unsigned char' default \n      promotes to `unsigned int' instead of `int' as in ISO C.  As of 1999,\n@@ -208,16 +203,10 @@ struct insn_operand_data\n {\n   insn_operand_predicate_fn predicate;\n \n-#ifdef REGISTER_CONSTRAINTS\n   const char *constraint;\n-#endif\n \n   enum machine_mode mode;\n \n-#ifndef REGISTER_CONSTRAINTS\n-  char address_p;\n-#endif\n-\n   char strict_low;\n };\n "}, {"sha": "1b9608586947a8e0af188352a0a97fb03e49566d", "filename": "gcc/regclass.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -955,7 +955,6 @@ regclass (f, nregs)\n      rtx f;\n      int nregs;\n {\n-#ifdef REGISTER_CONSTRAINTS\n   register rtx insn;\n   register int i;\n   int pass;\n@@ -1109,13 +1108,10 @@ regclass (f, nregs)\n \t  altclass[i] = (int) alt;\n \t}\n     }\n-#endif /* REGISTER_CONSTRAINTS */\n \n   free (costs);\n }\n \f\n-#ifdef REGISTER_CONSTRAINTS\n-\n /* Record the cost of using memory or registers of various classes for\n    the operands in INSN.\n \n@@ -1817,8 +1813,6 @@ auto_inc_dec_reg_p (reg, mode)\n   return 0;\n }\n #endif\n-\n-#endif /* REGISTER_CONSTRAINTS */\n \f\n static short *renumber = (short *)0;\n static size_t regno_allocated = 0;"}, {"sha": "98e2d13aab5458a12e03fa2ee8f2ef341b252261", "filename": "gcc/regmove.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -1166,7 +1166,6 @@ regmove_optimize (f, nregs, regmove_dump_file)\n           if (! flag_regmove)\n             continue;\n \n-#ifdef REGISTER_CONSTRAINTS\n \t  if (! find_matches (insn, &match))\n \t    continue;\n \n@@ -1556,7 +1555,6 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \n \t}\n     }\n-#endif /* REGISTER_CONSTRAINTS */\n \n   /* In fixup_match_1, some insns may have been inserted after basic block\n      ends.  Fix that here.  */"}, {"sha": "6ca7322806ed8df42fdbec00b34a4174d2cd3bfe", "filename": "gcc/reload.c", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -2353,8 +2353,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n      int live_known;\n      short *reload_reg_p;\n {\n-#ifdef REGISTER_CONSTRAINTS\n-\n   register int insn_code_number;\n   register int i, j;\n   int noperands;\n@@ -4175,74 +4173,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t}\n     }\n \n-#else /* no REGISTER_CONSTRAINTS */\n-  int noperands;\n-  int insn_code_number;\n-  int goal_earlyclobber = 0; /* Always 0, to make combine_reloads happen.  */\n-  register int i;\n-  rtx body = PATTERN (insn);\n-  int retval = 0;\n-\n-  n_reloads = 0;\n-  n_replacements = 0;\n-  n_earlyclobbers = 0;\n-  replace_reloads = replace;\n-  this_insn = insn;\n-\n-  extract_insn (insn);\n-\n-  noperands = reload_n_operands = recog_data.n_operands;\n-\n-  /* Return if the insn needs no reload processing.  */\n-  if (noperands == 0)\n-    return;\n-\n-  for (i = 0; i < noperands; i++)\n-    {\n-      register RTX_CODE code = GET_CODE (recog_data.operand[i]);\n-      int is_set_dest = GET_CODE (body) == SET && (i == 0);\n-\n-      if (insn_code_number >= 0)\n-\tif (insn_data[insn_code_number].operand[i].address_p)\n-\t  find_reloads_address (VOIDmode, NULL_PTR,\n-\t\t\t\trecog_data.operand[i],\n-\t\t\t\trecog_data.operand_loc[i],\n-\t\t\t\ti, RELOAD_FOR_INPUT, ind_levels, insn);\n-\n-      /* In these cases, we can't tell if the operand is an input\n-\t or an output, so be conservative.  In practice it won't be\n-\t problem.  */\n-\n-      if (code == MEM)\n-\tfind_reloads_address (GET_MODE (recog_data.operand[i]),\n-\t\t\t      recog_data.operand_loc[i],\n-\t\t\t      XEXP (recog_data.operand[i], 0),\n-\t\t\t      &XEXP (recog_data.operand[i], 0),\n-\t\t\t      i, RELOAD_OTHER, ind_levels, insn);\n-      if (code == SUBREG)\n-\trecog_data.operand[i] = *recog_data.operand_loc[i]\n-\t  = find_reloads_toplev (recog_data.operand[i], i, RELOAD_OTHER,\n-\t\t\t\t ind_levels, is_set_dest);\n-      if (code == REG)\n-\t{\n-\t  register int regno = REGNO (recog_data.operand[i]);\n-\t  if (reg_equiv_constant[regno] != 0 && !is_set_dest)\n-\t    recog_data.operand[i] = *recog_data.operand_loc[i]\n-\t      = reg_equiv_constant[regno];\n-#if 0 /* This might screw code in reload1.c to delete prior output-reload\n-\t that feeds this insn.  */\n-\t  if (reg_equiv_mem[regno] != 0)\n-\t    recog_data.operand[i] = *recog_data.operand_loc[i]\n-\t      = reg_equiv_mem[regno];\n-#endif\n-\t}\n-    }\n-\n-  /* Perhaps an output reload can be combined with another\n-     to reduce needs by one.  */\n-  if (!goal_earlyclobber)\n-    combine_reloads ();\n-#endif /* no REGISTER_CONSTRAINTS */\n   return retval;\n }\n "}, {"sha": "873dd3bda944740c66dd2143337fc0878f73fde4", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19af645506250e3ba54b35491e70f67485904168/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19af645506250e3ba54b35491e70f67485904168/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=19af645506250e3ba54b35491e70f67485904168", "patch": "@@ -801,34 +801,6 @@ reload (first, global, dumpfile)\n \t|| GET_CODE (insn) == CALL_INSN)\n       note_stores (PATTERN (insn), mark_not_eliminable);\n \n-#ifndef REGISTER_CONSTRAINTS\n-  /* If all the pseudo regs have hard regs,\n-     except for those that are never referenced,\n-     we know that no reloads are needed.  */\n-  /* But that is not true if there are register constraints, since\n-     in that case some pseudos might be in the wrong kind of hard reg.  */\n-\n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (reg_renumber[i] == -1 && REG_N_REFS (i) != 0)\n-      break;\n-\n-  if (i == max_regno && num_eliminable == 0 && ! caller_save_needed)\n-    {\n-      free (real_known_ptr);\n-      free (real_at_ptr);\n-      free (reg_equiv_constant);\n-      free (reg_equiv_memory_loc);\n-      free (reg_equiv_mem);\n-      free (reg_equiv_init);\n-      free (reg_equiv_address);\n-      free (reg_max_ref_width);\n-      free (reg_old_renumber);\n-      free (pseudo_previous_regs);\n-      free (pseudo_forbidden_regs);\n-      return 0;\n-    }\n-#endif\n-\n   maybe_fix_stack_asms ();\n \n   insns_need_reload = 0;\n@@ -9126,7 +9098,6 @@ static int\n reload_cse_simplify_operands (insn)\n      rtx insn;\n {\n-#ifdef REGISTER_CONSTRAINTS\n   int i,j;\n \n   const char *constraints[MAX_RECOG_OPERANDS];\n@@ -9334,9 +9305,6 @@ reload_cse_simplify_operands (insn)\n   push_obstacks (&reload_obstack, &reload_obstack);\n \n   return apply_change_group ();\n-#else\n-  return 0;\n-#endif\n }\n \n /* These two variables are used to pass information from"}]}