{"sha": "f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVmN2QxNzFjM2Y4ZGZmZjVkNzc1MWQ4YjliNDcxOGY3YzFkYmQ2Ng==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-04-11T17:40:55Z"}, "committer": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-04-11T17:40:55Z"}, "message": "sparc.c: Use gcc_assert and gcc_unreachable.\n\n2005-04-11  James A. Morrison  <phython@gcc.gnu.org>\n\n        * config/sparc/sparc.c: Use gcc_assert and gcc_unreachable.\n        * config/sparc/sparc.h: Likewise.\n        * config/sparc/sparc.md: Likewise.\n\nFrom-SVN: r97976", "tree": {"sha": "322887078ed40691f695459232e073209e8b2e57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/322887078ed40691f695459232e073209e8b2e57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66/comments", "author": null, "committer": null, "parents": [{"sha": "977ec5f82ca370c43585a32f419c2e26d0e01fda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/977ec5f82ca370c43585a32f419c2e26d0e01fda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/977ec5f82ca370c43585a32f419c2e26d0e01fda"}], "stats": {"total": 300, "additions": 116, "deletions": 184}, "files": [{"sha": "f4c65af823d160b685f570ec6835faa943953a93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66", "patch": "@@ -1,3 +1,9 @@\n+2005-04-11  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\t* config/sparc/sparc.c: Use gcc_assert and gcc_unreachable.\n+\t* config/sparc/sparc.h: Likewise.\n+\t* config/sparc/sparc.md: Likewise.\n+\n 2005-04-11  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-vrp.c (maybe_add_assert_expr): Move a comment."}, {"sha": "0e053877bfbf7e3f46af848563af9fc9f06dee84", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 93, "deletions": 157, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66", "patch": "@@ -630,8 +630,7 @@ sparc_override_options (void)\n   for (def = &cpu_default[0]; def->name; ++def)\n     if (def->cpu == TARGET_CPU_DEFAULT)\n       break;\n-  if (! def->name)\n-    abort ();\n+  gcc_assert (def->name);\n   sparc_select[0].string = def->name;\n \n   for (sel = &sparc_select[0]; sel->name; ++sel)\n@@ -974,8 +973,7 @@ icc_or_fcc_reg_operand (rtx op, enum machine_mode mode)\n int\n call_operand (rtx op, enum machine_mode mode)\n {\n-  if (GET_CODE (op) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (op) == MEM);\n   op = XEXP (op, 0);\n   return (symbolic_operand (op, mode) || memory_address_p (Pmode, op));\n }\n@@ -1631,9 +1629,8 @@ sparc_emit_set_const32 (rtx op0, rtx op1)\n     {\n       HOST_WIDE_INT value = INTVAL (op1);\n \n-      if (SPARC_SETHI_P (value & GET_MODE_MASK (mode))\n-\t  || SPARC_SIMM13_P (value))\n-\tabort ();\n+      gcc_assert (! SPARC_SETHI_P (value & GET_MODE_MASK (mode))\n+\t  \t  && ! SPARC_SIMM13_P (value));\n     }\n \n   /* Full 2-insn decomposition is needed.  */\n@@ -1772,10 +1769,8 @@ sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp)\n \t     it TImode).  Pick the other one to use as our scratch.  */\n \t  if (rtx_equal_p (temp, op0))\n \t    {\n-\t      if (ti_temp)\n-\t\ttemp = gen_rtx_REG (DImode, REGNO (temp) + 1);\n-\t      else\n-\t\tabort();\n+\t      gcc_assert (ti_temp);\n+\t      temp = gen_rtx_REG (DImode, REGNO (temp) + 1);\n \t    }\n \t  temp1 = op0;\n \t  temp2 = temp;  /* op0 is _not_ allowed, see above.  */\n@@ -1846,10 +1841,8 @@ sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp)\n \t\t it TImode).  Pick the other one to use as our scratch.  */\n \t      if (rtx_equal_p (temp, op0))\n \t\t{\n-\t\t  if (ti_temp)\n-\t\t    temp = gen_rtx_REG (DImode, REGNO (temp) + 1);\n-\t\t  else\n-\t\t    abort();\n+\t\t  gcc_assert (ti_temp);\n+\t\t  temp = gen_rtx_REG (DImode, REGNO (temp) + 1);\n \t\t}\n \t      temp1 = op0;\n \t      temp2 = temp;  /* op0 is _not_ allowed, see above.  */\n@@ -1878,7 +1871,7 @@ sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp)\n       break;\n \n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2166,9 +2159,7 @@ analyze_64bit_constant (unsigned HOST_WIDE_INT high_bits,\n     }\n   /* If there are no bits set this should have gone out\n      as one instruction!  */\n-  if (lowest_bit_set == -1\n-      || highest_bit_set == -1)\n-    abort ();\n+  gcc_assert (lowest_bit_set != -1 && highest_bit_set != -1);\n   all_bits_between_are_set = 1;\n   for (i = lowest_bit_set; i <= highest_bit_set; i++)\n     {\n@@ -2238,8 +2229,7 @@ create_simple_focus_bits (unsigned HOST_WIDE_INT high_bits,\n       lo = 0;\n       hi = ((high_bits >> (lowest_bit_set - 32)) << shift);\n     }\n-  if (hi & lo)\n-    abort ();\n+  gcc_assert (! (hi & lo));\n   return (hi | lo);\n }\n \n@@ -2256,15 +2246,13 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n   rtx temp = 0;\n \n   /* Sanity check that we know what we are working with.  */\n-  if (! TARGET_ARCH64)\n-    abort ();\n+  gcc_assert (TARGET_ARCH64);\n \n   if (GET_CODE (op0) != SUBREG)\n     {\n-      if (GET_CODE (op0) != REG\n-\t  || (REGNO (op0) >= SPARC_FIRST_FP_REG\n-\t      && REGNO (op0) <= SPARC_LAST_V9_FP_REG))\n-\tabort ();\n+      gcc_assert (GET_CODE (op0) == REG\n+\t\t  && (REGNO (op0) < SPARC_FIRST_FP_REG\n+\t      \t      || REGNO (op0) > SPARC_LAST_V9_FP_REG));\n     }\n \n   if (reload_in_progress || reload_completed)\n@@ -2340,8 +2328,8 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n       else if (lowest_bit_set == 0)\n \tshift = -(63 - highest_bit_set);\n \n-      if (! SPARC_SIMM13_P (the_const))\n-\tabort ();\n+      gcc_assert (SPARC_SIMM13_P (the_const));\n+      gcc_assert (shift != 0);\n \n       emit_insn (gen_safe_SET64 (temp, the_const));\n       if (shift > 0)\n@@ -2356,8 +2344,6 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n \t\t\t\tgen_rtx_LSHIFTRT (DImode,\n \t\t\t\t\t\t  temp,\n \t\t\t\t\t\t  GEN_INT (-shift))));\n-      else\n-\tabort ();\n       return;\n     }\n \n@@ -2373,8 +2359,8 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n \tcreate_simple_focus_bits (high_bits, low_bits,\n \t\t\t\t  lowest_bit_set, 10);\n \n-      if (! SPARC_SETHI_P (focus_bits))\n-\t abort ();\n+      gcc_assert (SPARC_SETHI_P (focus_bits));\n+      gcc_assert (lowest_bit_set != 10);\n \n       sparc_emit_set_safe_HIGH64 (temp, focus_bits);\n \n@@ -2389,8 +2375,6 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n \t\t\t\top0,\n \t\t\t\tgen_rtx_ASHIFT (DImode, temp,\n \t\t\t\t\t\tGEN_INT (lowest_bit_set - 10))));\n-      else\n-\tabort ();\n       return;\n     }\n \n@@ -2488,9 +2472,7 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n \t\t\t\t  lowest_bit_set, 0);\n \n       /* We can't get here in this state.  */\n-      if (highest_bit_set < 32\n-\t  || lowest_bit_set >= 32)\n-\tabort ();\n+      gcc_assert (highest_bit_set >= 32 && lowest_bit_set < 32);\n \n       /* So what we know is that the set bits straddle the\n \t middle of the 64-bit word.  */\n@@ -2552,7 +2534,7 @@ select_cc_mode (enum rtx_code op, rtx x, rtx y ATTRIBUTE_UNUSED)\n \t  return CCFPEmode;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   else if (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS\n@@ -2727,7 +2709,7 @@ gen_v9_scc (enum rtx_code compare_code, register rtx *operands)\n \t  case CCFPmode :\n \t    break;\n \t  default :\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n       emit_insn (gen_rtx_SET (VOIDmode, operands[0], const0_rtx));\n       emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n@@ -2781,8 +2763,7 @@ emit_soft_tfmode_libcall (const char *func_name, int nargs, rtx *operands)\n   int i;\n \n   /* We only expect to be called for conversions, unary, and binary ops.  */\n-  if (nargs < 2 || nargs > 3)\n-    abort ();\n+  gcc_assert (nargs == 2 || nargs == 3);\n \n   for (i = 0; i < nargs; ++i)\n     {\n@@ -2845,8 +2826,7 @@ emit_soft_tfmode_libcall (const char *func_name, int nargs, rtx *operands)\n     {\n       rtx ret;\n \n-      if (nargs != 2)\n-\tabort ();\n+      gcc_assert (nargs == 2);\n \n       ret = emit_library_call_value (func_sym, operands[0], LCT_NORMAL,\n \t\t\t\t     GET_MODE (operands[0]), 1,\n@@ -2879,7 +2859,7 @@ emit_soft_tfmode_binop (enum rtx_code code, rtx *operands)\n       func = \"_Qp_div\";\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   emit_soft_tfmode_libcall (func, 3, operands);\n@@ -2890,14 +2870,8 @@ emit_soft_tfmode_unop (enum rtx_code code, rtx *operands)\n {\n   const char *func;\n \n-  switch (code)\n-    {\n-    case SQRT:\n-      func = \"_Qp_sqrt\";\n-      break;\n-    default:\n-      abort ();\n-    }\n+  gcc_assert (code == SQRT);\n+  func = \"_Qp_sqrt\";\n \n   emit_soft_tfmode_libcall (func, 2, operands);\n }\n@@ -2919,7 +2893,7 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n \t  func = \"_Qp_dtoq\";\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -2933,7 +2907,7 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n \t  func = \"_Qp_qtod\";\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -2947,7 +2921,7 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n \t  func = \"_Qp_xtoq\";\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -2961,7 +2935,7 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n \t  func = \"_Qp_uxtoq\";\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -2975,7 +2949,7 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n \t  func = \"_Qp_qtox\";\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -2989,12 +2963,12 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n \t  func = \"_Qp_qtoux\";\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   emit_soft_tfmode_libcall (func, 2, operands);\n@@ -3356,7 +3330,7 @@ sparc_cannot_force_const_mem (rtx x)\n     case UNSPEC:\n       return true;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -3374,14 +3348,13 @@ check_pic (int i)\n   switch (flag_pic)\n     {\n     case 1:\n-      if (GET_CODE (recog_data.operand[i]) == SYMBOL_REF\n-\t  || (GET_CODE (recog_data.operand[i]) == CONST\n-\t      && ! (GET_CODE (XEXP (recog_data.operand[i], 0)) == MINUS\n-\t\t    && (XEXP (XEXP (recog_data.operand[i], 0), 0)\n-\t\t\t== global_offset_table)\n-\t\t    && (GET_CODE (XEXP (XEXP (recog_data.operand[i], 0), 1))\n-\t\t\t== CONST))))\n-\tabort ();\n+      gcc_assert (GET_CODE (recog_data.operand[i]) != SYMBOL_REF\n+\t  \t  && (GET_CODE (recog_data.operand[i]) != CONST\n+\t          || (GET_CODE (XEXP (recog_data.operand[i], 0)) == MINUS\n+\t\t      && (XEXP (XEXP (recog_data.operand[i], 0), 0)\n+\t\t\t  == global_offset_table)\n+\t\t      && (GET_CODE (XEXP (XEXP (recog_data.operand[i], 0), 1))\n+\t\t\t  == CONST))));\n     case 2:\n     default:\n       return 1;\n@@ -3660,8 +3633,7 @@ legitimize_tls_address (rtx addr)\n {\n   rtx temp1, temp2, temp3, ret, o0, got, insn;\n \n-  if (no_new_pseudos)\n-    abort ();\n+  gcc_assert (! no_new_pseudos);\n \n   if (GET_CODE (addr) == SYMBOL_REF)\n     switch (SYMBOL_REF_TLS_MODEL (addr))\n@@ -3777,11 +3749,11 @@ legitimize_tls_address (rtx addr)\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n \n   else\n-    abort ();  /* for now ... */\n+    gcc_unreachable ();  /* for now ... */\n \n   return ret;\n }\n@@ -3803,10 +3775,8 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \n       if (reg == 0)\n \t{\n-\t  if (reload_in_progress || reload_completed)\n-\t    abort ();\n-\t  else\n-\t    reg = gen_reg_rtx (Pmode);\n+\t  gcc_assert (! reload_in_progress && ! reload_completed);\n+\t  reg = gen_reg_rtx (Pmode);\n \t}\n \n       if (flag_pic == 2)\n@@ -3857,20 +3827,14 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \n       if (reg == 0)\n \t{\n-\t  if (reload_in_progress || reload_completed)\n-\t    abort ();\n-\t  else\n-\t    reg = gen_reg_rtx (Pmode);\n+\t  gcc_assert (! reload_in_progress && ! reload_completed);\n+\t  reg = gen_reg_rtx (Pmode);\n \t}\n \n-      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n-\t{\n-\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n-\t  offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n-\t\t\t\t\t base == reg ? 0 : reg);\n-\t}\n-      else\n-\tabort ();\n+      gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n+      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n+      offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n+\t\t\t \t       base == reg ? 0 : reg);\n \n       if (GET_CODE (offset) == CONST_INT)\n \t{\n@@ -3880,7 +3844,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t    offset = force_reg (Pmode, offset);\n \t  else\n \t    /* If we reach here, then something is seriously wrong.  */\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n       return gen_rtx_PLUS (Pmode, base, offset);\n     }\n@@ -4653,8 +4617,7 @@ static void\n sparc_asm_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   /* Check that the assumption we made in sparc_expand_prologue is valid.  */\n-  if (sparc_leaf_function_p != current_function_uses_only_leaf_regs)\n-    abort();\n+  gcc_assert (sparc_leaf_function_p == current_function_uses_only_leaf_regs);\n \n   sparc_output_scratch_registers (file);\n }\n@@ -4738,8 +4701,7 @@ output_restore (rtx pat)\n       return;\n     }\n \n-  if (GET_CODE (pat) != SET)\n-    abort ();\n+  gcc_assert (GET_CODE (pat) == SET);\n \n   operands[0] = SET_DEST (pat);\n   pat = SET_SRC (pat);\n@@ -4758,8 +4720,7 @@ output_restore (rtx pat)\n \tbreak;\n       case ASHIFT:\n \toperands[1] = XEXP (pat, 0);\n-\tif (XEXP (pat, 1) != const1_rtx)\n-\t  abort();\n+\tgcc_assert (XEXP (pat, 1) == const1_rtx);\n \toutput_asm_insn (\" restore %r1, %r1, %Y0\", operands);\n \tbreak;\n       default:\n@@ -4781,8 +4742,7 @@ output_return (rtx insn)\n \t semantics of restore/return.  We simply output the jump to the\n \t return address and the insn in the delay slot (if any).  */\n \n-      if (current_function_calls_eh_return)\n-\tabort ();\n+      gcc_assert (! current_function_calls_eh_return);\n \n       return \"jmp\\t%%o7+%)%#\";\n     }\n@@ -4797,8 +4757,7 @@ output_return (rtx insn)\n \t{\n \t  /* If the function uses __builtin_eh_return, the eh_return\n \t     machinery occupies the delay slot.  */\n-\t  if (final_sequence)\n-\t    abort ();\n+\t  gcc_assert (! final_sequence);\n \n \t  if (! flag_delayed_branch)\n \t    fputs (\"\\tadd\\t%fp, %g1, %fp\\n\", asm_out_file);\n@@ -4818,8 +4777,7 @@ output_return (rtx insn)\n \t  rtx delay, pat;\n \n \t  delay = NEXT_INSN (insn);\n-\t  if (! delay)\n-\t    abort ();\n+\t  gcc_assert (delay);\n \n \t  pat = PATTERN (delay);\n \n@@ -4858,8 +4816,7 @@ output_sibcall (rtx insn, rtx call_operand)\n {\n   rtx operands[1];\n \n-  if (! flag_delayed_branch)\n-    abort();\n+  gcc_assert (flag_delayed_branch);\n \n   operands[0] = call_operand;\n \n@@ -4869,8 +4826,7 @@ output_sibcall (rtx insn, rtx call_operand)\n \t register window.  We simply output the jump to the function and\n \t the insn in the delay slot (if any).  */\n \n-      if (LEAF_SIBCALL_SLOT_RESERVED_P && final_sequence)\n-\tabort();\n+      gcc_assert (!(LEAF_SIBCALL_SLOT_RESERVED_P && final_sequence));\n \n       if (final_sequence)\n \toutput_asm_insn (\"sethi\\t%%hi(%a0), %%g1\\n\\tjmp\\t%%g1 + %%lo(%a0)%#\",\n@@ -4892,8 +4848,7 @@ output_sibcall (rtx insn, rtx call_operand)\n       if (final_sequence)\n \t{\n \t  rtx delay = NEXT_INSN (insn);\n-\t  if (! delay)\n-\t    abort ();\n+\t  gcc_assert (delay);\n \n \t  output_restore (PATTERN (delay));\n \n@@ -5155,17 +5110,15 @@ function_arg_slotno (const struct sparc_args *cum, enum machine_mode mode,\n       if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)\n \t{\n \t  /* The SPARC port defines no floating-point vector modes.  */\n-\t  if (mode != BLKmode)\n-\t    abort ();\n+\t  gcc_assert (mode == BLKmode);\n \t}\n       else\n \t{\n \t  /* Integral vector types should either have a vector\n \t     mode or an integral mode, because we are guaranteed\n \t     by pass_by_reference that their size is not greater\n \t     than 16 bytes and TImode is 16-byte wide.  */\n-\t  if (mode == BLKmode)\n-\t    abort ();\n+\t  gcc_assert (mode != BLKmode);\n \n \t  /* Vector integers are handled like floats according to\n \t     the Sun VIS SDK.  */\n@@ -5202,8 +5155,7 @@ function_arg_slotno (const struct sparc_args *cum, enum machine_mode mode,\n \t/* MODE is VOIDmode when generating the actual call.  */\n \treturn -1;\n \n-      if (mode != BLKmode)\n-\tabort ();\n+      gcc_assert (mode == BLKmode);\n \n       /* For SPARC64, objects requiring 16-byte alignment get it.  */\n       if (TARGET_ARCH64\n@@ -5252,7 +5204,7 @@ function_arg_slotno (const struct sparc_args *cum, enum machine_mode mode,\n       break;\n \n     default :\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   *pregno = regno;\n@@ -5609,8 +5561,7 @@ function_arg_record_value (tree type, enum machine_mode mode,\n       if (nregs + slotno > SPARC_INT_ARG_MAX)\n \tnregs = SPARC_INT_ARG_MAX - slotno;\n     }\n-  if (nregs == 0)\n-    abort ();\n+  gcc_assert (nregs != 0);\n \n   parms.ret = gen_rtx_PARALLEL (mode, rtvec_alloc (parms.stack + nregs));\n \n@@ -5630,8 +5581,7 @@ function_arg_record_value (tree type, enum machine_mode mode,\n   function_arg_record_value_2 (type, 0, &parms, false);\n   function_arg_record_value_3 (typesize * BITS_PER_UNIT, &parms);\n \n-  if (parms.nregs != nregs)\n-    abort ();\n+  gcc_assert (parms.nregs == nregs);\n \n   return parms.ret;\n }\n@@ -5747,17 +5697,15 @@ function_arg (const struct sparc_args *cum, enum machine_mode mode,\n       /* Structures up to 16 bytes in size are passed in arg slots on the\n \t stack and are promoted to registers where possible.  */\n \n-      if (int_size_in_bytes (type) > 16)\n-\tabort (); /* shouldn't get here */\n+      gcc_assert (int_size_in_bytes (type) <= 16);\n \n       return function_arg_record_value (type, mode, slotno, named, regbase);\n     }\n   else if (type && TREE_CODE (type) == UNION_TYPE)\n     {\n       HOST_WIDE_INT size = int_size_in_bytes (type);\n \n-      if (size > 16)\n-\tabort (); /* shouldn't get here */\n+      gcc_assert (size <= 16);\n \n       return function_arg_union_value (size, mode, slotno, regno);\n     }\n@@ -5768,8 +5716,7 @@ function_arg (const struct sparc_args *cum, enum machine_mode mode,\n \t instructions are enabled.  */\n       HOST_WIDE_INT size = int_size_in_bytes (type);\n \n-      if (size > 16)\n-\tabort (); /* shouldn't get here */\n+      gcc_assert (size <= 16);\n \n       if (mode == BLKmode)\n \treturn function_arg_vector_value (size,\n@@ -6124,8 +6071,8 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n \t instructions are enabled.  */\n       HOST_WIDE_INT size = int_size_in_bytes (type);\n \n-      if ((TARGET_ARCH32 && size > 8) || (TARGET_ARCH64 && size > 32))\n-\tabort (); /* shouldn't get here */\n+      gcc_assert ((TARGET_ARCH32 && size <= 8)\n+\t\t  || (TARGET_ARCH64 && size <= 32));\n \n       if (mode == BLKmode)\n \treturn function_arg_vector_value (size,\n@@ -6141,17 +6088,15 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n \t  /* Structures up to 32 bytes in size are passed in registers,\n \t     promoted to fp registers where possible.  */\n \n-\t  if (int_size_in_bytes (type) > 32)\n-\t    abort (); /* shouldn't get here */\n+\t  gcc_assert (int_size_in_bytes (type) <= 32);\n \n \t  return function_arg_record_value (type, mode, 0, 1, regbase);\n \t}\n       else if (TREE_CODE (type) == UNION_TYPE)\n \t{\n \t  HOST_WIDE_INT size = int_size_in_bytes (type);\n \n-\t  if (size > 32)\n-\t    abort (); /* shouldn't get here */\n+\t  gcc_assert (size <= 32);\n \n \t  return function_arg_union_value (size, mode, 0, regbase);\n \t}\n@@ -6161,8 +6106,7 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n \t     in a mode corresponding to the size of the type.  */\n \t  HOST_WIDE_INT bytes = int_size_in_bytes (type);\n \n-\t  if (bytes > 32)\n-\t    abort (); /* shouldn't get here */\n+\t  gcc_assert (bytes <= 32);\n \n \t  mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 0);\n \n@@ -6474,7 +6418,7 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       /* ??? !v9: FP branches cannot be preceded by another floating point\n@@ -6529,7 +6473,7 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       strcpy (string, branch);\n     }\n@@ -6566,17 +6510,14 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n \t  labelno = v9_fcc_labelno;\n \t  if (v8)\n \t    {\n-\t      if (REGNO (cc_reg) == SPARC_FCC_REG)\n-\t\tlabelno = \"\";\n-\t      else\n-\t\tabort ();\n+\t      gcc_assert (REGNO (cc_reg) == SPARC_FCC_REG);\n+\t      labelno = \"\";\n \t    }\n \t}\n       else if (mode == CCXmode || mode == CCX_NOOVmode)\n \t{\n \t  labelno = \"%%xcc, \";\n-\t  if (v8)\n-\t    abort ();\n+\t  gcc_assert (! v8);\n \t}\n       else\n \t{\n@@ -6672,8 +6613,7 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n       break;\n \n     default:\n-      abort();\n-      break;\n+      gcc_unreachable ();\n     }\n \n   if (TARGET_ARCH64)\n@@ -6885,8 +6825,7 @@ output_v9branch (rtx op, rtx dest, int reg, int label, int reversed,\n     code = reverse_condition (code);\n \n   /* Only 64 bit versions of these instructions exist.  */\n-  if (mode != DImode)\n-    abort ();\n+  gcc_assert (mode == DImode);\n \n   /* Start by writing the branch condition.  */\n \n@@ -6917,7 +6856,7 @@ output_v9branch (rtx op, rtx dest, int reg, int label, int reversed,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   p = strchr (string, '\\0');\n@@ -7093,8 +7032,7 @@ int\n sparc_splitdi_legitimate (rtx reg, rtx mem)\n {\n   /* Punt if we are here by mistake.  */\n-  if (! reload_completed)\n-    abort ();\n+  gcc_assert (reload_completed);\n \n   /* We must have an offsettable memory reference.  */\n   if (! offsettable_memref_p (mem))\n@@ -7378,7 +7316,7 @@ print_operand (FILE *file, rtx x, int code)\n \t  else if (GET_MODE (x) == CCXmode)\n \t    fputs (\"%xcc\", file);\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n       else\n \t/* %fccN register */\n@@ -7730,7 +7668,7 @@ sparc_type_code (register tree type)\n \t  return qualifiers;\n   \n \tdefault:\n-\t  abort ();\t\t/* Not a type! */\n+\t  gcc_unreachable ();\t\t/* Not a type! */\n         }\n     }\n \n@@ -8227,8 +8165,7 @@ sparc_check_64 (rtx x, rtx insn)\n   int set_once = 0;\n   rtx y = x;\n \n-  if (GET_CODE (x) != REG)\n-    abort ();\n+  gcc_assert (GET_CODE (x) == REG);\n \n   if (GET_MODE (x) == DImode)\n     y = gen_rtx_REG (SImode, REGNO (x) + WORDS_BIG_ENDIAN);\n@@ -8988,8 +8925,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n       rtx vcall_offset_rtx = GEN_INT (vcall_offset);\n       rtx scratch = gen_rtx_REG (Pmode, 1);\n \n-      if (vcall_offset >= 0)\n-\tabort ();\n+      gcc_assert (vcall_offset < 0);\n \n       /* SCRATCH = *THIS.  */\n       emit_move_insn (scratch, gen_rtx_MEM (Pmode, this));\n@@ -9098,7 +9034,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t      break;\n \n \t    default:\n-\t      abort();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n \n@@ -9160,7 +9096,7 @@ get_some_local_dynamic_name (void)\n \t&& for_each_rtx (&PATTERN (insn), get_some_local_dynamic_name_1, 0))\n       return cfun->machine->some_ld_name;\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n static int\n@@ -9206,7 +9142,7 @@ sparc_output_dwarf_dtprel (FILE *file, int size, rtx x)\n       fputs (\"\\t.xword\\t%r_tls_dtpoff64(\", file);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   output_addr_const (file, x);\n   fputs (\")\", file);"}, {"sha": "dcdafa0923304138ecc30110b45ac47af9aef009", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66", "patch": "@@ -2571,10 +2571,9 @@ extern int sparc_indent_opcode;\n \tbase = XEXP (addr, 0), index = XEXP (addr, 1);\t\t\\\n       if (GET_CODE (base) == LO_SUM)\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  if (! USE_AS_OFFSETABLE_LO10\t\t\t\t\\\n-\t      || TARGET_ARCH32\t\t\t\t\t\\\n-\t      || TARGET_CM_MEDMID)\t\t\t\t\\\n-\t    abort ();\t\t\t\t\t\t\\\n+\t  gcc_assert (USE_AS_OFFSETABLE_LO10\t\t\t\\\n+\t      \t      && TARGET_ARCH64\t\t\t\t\\\n+\t\t      && ! TARGET_CM_MEDMID);\t\t\t\\\n \t  output_operand (XEXP (base, 0), 0);\t\t\t\\\n \t  fputs (\"+%lo(\", FILE);\t\t\t\t\\\n \t  output_address (XEXP (base, 1));\t\t\t\\\n@@ -2590,7 +2589,7 @@ extern int sparc_indent_opcode;\n \t  else if (GET_CODE (index) == SYMBOL_REF\t\t\\\n \t\t   || GET_CODE (index) == CONST)\t\t\\\n \t    fputc ('+', FILE), output_addr_const (FILE, index);\t\\\n-\t  else abort ();\t\t\t\t\t\\\n+\t  else gcc_unreachable ();\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (addr) == MINUS\t\t\t\t\\"}, {"sha": "88c474c98c77b0024da063b2ab602e02687be346", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=f5f7d171c3f8dfff5d7751d8b9b4718f7c1dbd66", "patch": "@@ -2083,8 +2083,7 @@\n \n       if (GET_CODE (operands[1]) == LABEL_REF)\n         {\n-          if (! TARGET_ARCH64)\n-            abort ();\n+          gcc_assert (TARGET_ARCH64);\n           emit_insn (gen_movdi_pic_label_ref (operands[0], operands[1]));\n           DONE;\n         }\n@@ -2639,7 +2638,7 @@\n     case 8:\n       return \"st\\t%r1, %0\";\n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"fpmove,*,*,*,*,load,fpload,fpstore,store\")])\n@@ -2686,7 +2685,7 @@\n     case 9:\n       return \"st\\t%r1, %0\";\n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"fpmove,fga,*,*,*,*,load,fpload,fpstore,store\")])\n@@ -2731,7 +2730,7 @@\n     case 5:\n       return \"st\\t%r1, %0\";\n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"*,*,*,*,load,store\")])\n@@ -3533,7 +3532,7 @@\n       dest2 = adjust_address (set_dest, DFmode, 8);\n       break;\n     default:\n-      abort ();      \n+      gcc_unreachable ();      \n     }\n \n   emit_insn (gen_movdf (dest1, CONST0_RTX (DFmode)));\n@@ -7358,8 +7357,7 @@\n \t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n   \"\"\n {\n-  if (GET_MODE (operands[0]) != CASE_VECTOR_MODE)\n-    abort ();\n+  gcc_assert (GET_MODE (operands[0]) == CASE_VECTOR_MODE);\n \n   /* In pic mode, our address differences are against the base of the\n      table.  Add that base value back in; CSE ought to be able to combine\n@@ -7402,11 +7400,9 @@\n {\n   rtx fn_rtx;\n \n-  if (GET_MODE (operands[0]) != FUNCTION_MODE)\n-    abort ();\n+  gcc_assert (GET_MODE (operands[0]) == FUNCTION_MODE);\n \n-  if (GET_CODE (operands[3]) != CONST_INT)\n-    abort();\n+  gcc_assert (GET_CODE (operands[3]) == CONST_INT);\n \n   if (GET_CODE (XEXP (operands[0], 0)) == LABEL_REF)\n     {\n@@ -7568,8 +7564,7 @@\n   rtx fn_rtx;\n   rtvec vec;\n \n-  if (GET_MODE (operands[1]) != FUNCTION_MODE)\n-    abort ();\n+  gcc_assert (GET_MODE (operands[1]) == FUNCTION_MODE);\n \n   fn_rtx = operands[1];\n \n@@ -8241,10 +8236,8 @@\n   int read_or_write = INTVAL (operands[1]);\n   int locality = INTVAL (operands[2]);\n \n-  if (read_or_write != 0 && read_or_write != 1)\n-    abort ();\n-  if (locality < 0 || locality > 3)\n-    abort ();\n+  gcc_assert (read_or_write == 0 || read_or_write == 1);\n+  gcc_assert (locality >= 0 && locality < 4);\n   return prefetch_instr [read_or_write][locality == 0 ? 0 : 1];\n }\n   [(set_attr \"type\" \"load\")])\n@@ -8268,10 +8261,8 @@\n   int read_or_write = INTVAL (operands[1]);\n   int locality = INTVAL (operands[2]);\n \n-  if (read_or_write != 0 && read_or_write != 1)\n-    abort ();\n-  if (locality < 0 || locality > 3)\n-    abort ();\n+  gcc_assert (read_or_write == 0 || read_or_write == 1);\n+  gcc_assert (locality >= 0 && locality < 4);\n   return prefetch_instr [read_or_write][locality == 0 ? 0 : 1];\n }\n   [(set_attr \"type\" \"load\")])"}]}