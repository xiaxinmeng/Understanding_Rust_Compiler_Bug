{"sha": "c63173ddb02d9e703eaaa1256fa6a77db180782f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYzMTczZGRiMDJkOWU3MDNlYWFhMTI1NmZhNmE3N2RiMTgwNzgyZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-01-22T21:22:13Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-01-22T21:22:13Z"}, "message": "re PR fortran/34875 (read into vector-valued section doesn't transfer any values)\n\n2008-01-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34875\n\t* trans-io.c (gfc_trans_transfer): If the array reference in a\n\tread has a vector subscript, use gfc_conv_subref_array_arg to\n\tcopy back the temporary.\n\n2008-01-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34875\n\t* gfortran.dg/vector_subscript_3.f90: New test.\n\nFrom-SVN: r131742", "tree": {"sha": "e8a477ffaecba8454bdb4160486f6bb86a3a7675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8a477ffaecba8454bdb4160486f6bb86a3a7675"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c63173ddb02d9e703eaaa1256fa6a77db180782f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c63173ddb02d9e703eaaa1256fa6a77db180782f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c63173ddb02d9e703eaaa1256fa6a77db180782f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c63173ddb02d9e703eaaa1256fa6a77db180782f/comments", "author": null, "committer": null, "parents": [{"sha": "1a23970d0e21f1e88824425a716230a786a1a0c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a23970d0e21f1e88824425a716230a786a1a0c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a23970d0e21f1e88824425a716230a786a1a0c5"}], "stats": {"total": 83, "additions": 80, "deletions": 3}, "files": [{"sha": "35fd98e41588ce1f564855b3a44ffbd7a086c180", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63173ddb02d9e703eaaa1256fa6a77db180782f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63173ddb02d9e703eaaa1256fa6a77db180782f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c63173ddb02d9e703eaaa1256fa6a77db180782f", "patch": "@@ -1,3 +1,10 @@\n+2008-01-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34875\n+\t* trans-io.c (gfc_trans_transfer): If the array reference in a\n+\tread has a vector subscript, use gfc_conv_subref_array_arg to\n+\tcopy back the temporary.\n+\n 2008-01-22  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34848"}, {"sha": "1e124154a4add3597e27afb26f768f1c002da618", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63173ddb02d9e703eaaa1256fa6a77db180782f/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63173ddb02d9e703eaaa1256fa6a77db180782f/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=c63173ddb02d9e703eaaa1256fa6a77db180782f", "patch": "@@ -1972,6 +1972,7 @@ gfc_trans_transfer (gfc_code * code)\n   gfc_ss *ss;\n   gfc_se se;\n   tree tmp;\n+  int n;\n \n   gfc_start_block (&block);\n   gfc_init_block (&body);\n@@ -2004,9 +2005,28 @@ gfc_trans_transfer (gfc_code * code)\n \t    && ref && ref->next == NULL\n \t    && !is_subref_array (expr))\n \t{\n-\t  /* Get the descriptor.  */\n-\t  gfc_conv_expr_descriptor (&se, expr, ss);\n-\t  tmp = build_fold_addr_expr (se.expr);\n+\t  bool seen_vector = false;\n+\n+\t  if (ref && ref->u.ar.type == AR_SECTION)\n+\t    {\n+\t      for (n = 0; n < ref->u.ar.dimen; n++)\n+\t\tif (ref->u.ar.dimen_type[n] == DIMEN_VECTOR)\n+\t\t  seen_vector = true;\n+\t    }\n+\n+\t  if (seen_vector && last_dt == READ)\n+\t    {\n+\t      /* Create a temp, read to that and copy it back.  */\n+\t      gfc_conv_subref_array_arg (&se, expr, 0, INTENT_OUT);\n+\t      tmp =  se.expr;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Get the descriptor.  */\n+\t      gfc_conv_expr_descriptor (&se, expr, ss);\n+\t      tmp = build_fold_addr_expr (se.expr);\n+\t    }\n+\n \t  transfer_array_desc (&se, &expr->ts, tmp);\n \t  goto finish_block_label;\n \t}"}, {"sha": "31d39534dfaa9ac4ae6fdd3e90564be3a6073ad0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63173ddb02d9e703eaaa1256fa6a77db180782f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63173ddb02d9e703eaaa1256fa6a77db180782f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c63173ddb02d9e703eaaa1256fa6a77db180782f", "patch": "@@ -1,3 +1,8 @@\n+2008-01-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34875\n+\t* gfortran.dg/vector_subscript_3.f90: New test.\n+\n 2008-01-22  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34848"}, {"sha": "974ee4be392e3c38e00fc3b212df7a4eeea4de7f", "filename": "gcc/testsuite/gfortran.dg/vector_subscript_3.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63173ddb02d9e703eaaa1256fa6a77db180782f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63173ddb02d9e703eaaa1256fa6a77db180782f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_3.f90?ref=c63173ddb02d9e703eaaa1256fa6a77db180782f", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR34875, in which the read with a vector index\n+! used to do nothing.\n+!\n+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>\n+!\n+Program QH0008\n+\n+  REAL(4) QDA(10)\n+  REAL(4) QDA1(10)\n+! Scramble the vector up a bit to make the test more interesting\n+  integer, dimension(10) ::  nfv1 = (/9,2,1,3,5,4,6,8,7,10/)\n+! Set qda1 in ordinal order\n+  qda1(nfv1) = nfv1\n+  qda = -100\n+  OPEN (UNIT = 47,                &\n+        STATUS = 'SCRATCH',       &\n+        FORM = 'UNFORMATTED',     &\n+        ACTION = 'READWRITE')\n+  ISTAT = -314\n+  REWIND (47, IOSTAT = ISTAT)\n+  IF (ISTAT .NE. 0) call abort ()\n+  ISTAT = -314\n+! write qda1\n+  WRITE (47,IOSTAT = ISTAT) QDA1\n+  IF (ISTAT .NE. 0) call abort ()\n+  ISTAT = -314\n+  REWIND (47, IOSTAT = ISTAT)\n+  IF (ISTAT .NE. 0) call abort ()\n+! Do the vector index read that used to fail\n+  READ (47,IOSTAT = ISTAT) QDA(NFV1)\n+  IF (ISTAT .NE. 0) call abort ()\n+! Unscramble qda using the vector index\n+  IF (ANY (QDA(nfv1) .ne. QDA1) ) print *, qda, qda1\n+  ISTAT = -314\n+  REWIND (47, IOSTAT = ISTAT)\n+  IF (ISTAT .NE. 0) call abort ()\n+  qda = -200\n+! Do the subscript read that was OK\n+  READ (47,IOSTAT = ISTAT) QDA(1:10)\n+  IF (ISTAT .NE. 0) call abort ()\n+  IF (ANY (QDA .ne. QDA1) ) call abort ()\n+END\n+"}]}