{"sha": "a7862cf746cd632e4ef12a008e6a4eed743bbcaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc4NjJjZjc0NmNkNjMyZTRlZjEyYTAwOGU2YTRlZWQ3NDNiYmNhZg==", "commit": {"author": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2000-04-02T15:41:00Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2000-04-02T15:41:00Z"}, "message": "Forgot to add this file before...\n\nFrom-SVN: r32868", "tree": {"sha": "6cd95521ff58006b82b264ff0ced1bc638e43086", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cd95521ff58006b82b264ff0ced1bc638e43086"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7862cf746cd632e4ef12a008e6a4eed743bbcaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7862cf746cd632e4ef12a008e6a4eed743bbcaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7862cf746cd632e4ef12a008e6a4eed743bbcaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7862cf746cd632e4ef12a008e6a4eed743bbcaf/comments", "author": null, "committer": null, "parents": [{"sha": "89afab9c44f5157411c36fbb3bf3ed81079f42f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89afab9c44f5157411c36fbb3bf3ed81079f42f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89afab9c44f5157411c36fbb3bf3ed81079f42f1"}], "stats": {"total": 227, "additions": 227, "deletions": 0}, "files": [{"sha": "1af9617825a6da9b05a506bdf042cf6dfd38ee55", "filename": "libjava/include/jvmpi.h", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7862cf746cd632e4ef12a008e6a4eed743bbcaf/libjava%2Finclude%2Fjvmpi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7862cf746cd632e4ef12a008e6a4eed743bbcaf/libjava%2Finclude%2Fjvmpi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvmpi.h?ref=a7862cf746cd632e4ef12a008e6a4eed743bbcaf", "patch": "@@ -0,0 +1,227 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Note: this file must be compilable by the C compiler (for now,\n+   assuming GNU C is ok).  This means you must never use `//'\n+   comments, and all C++-specific code must be conditional on\n+   __cplusplus.  */\n+\n+#ifndef __GCJ_JVMPI_H__\n+#define __GCJ_JVMPI_H__\n+\n+#include <jni.h>\n+\n+/* JVMPI version numbers.  FIXME: this is a semi-random number.  The\n+   documentation doesn't say what it should be.  */\n+#define JVMPI_VERSION_1 0x00020001\n+\n+/* JVMPI return codes.  FIXME: These are semi-random numbers.  The\n+   documentation doesn't say what they should be.  */\n+#define JVMPI_SUCCESS       0\n+#define JVMPI_FAIL          1\n+#define JVMPI_NOT_AVAILABLE 2\n+\n+/* An opaque pointer representing an object ID.  */\n+struct _jobjectID;\n+typedef struct _jobjectID * jobjectID;       \n+\n+typedef struct\n+{\n+  /* Source line number.  */\n+  jint lineno;\n+  /* Method being executed.  */\n+  jmethodID method_id;\n+} JVMPI_CallFrame;\n+\n+typedef struct \n+{\n+  JNIEnv *env_id;\n+  /* Number of frames in the call trace.  */\n+  jint num_frames;\n+  /* An array of frames representing the trace.  Callees first.  */\n+  JVMPI_CallFrame *frames;\n+} JVMPI_CallTrace;\n+\n+typedef struct\n+{\n+  /* Name of the field.  */\n+  char *field_name;\n+  /* Signature of the field.  */\n+  char *field_signature;\n+} JVMPI_Field;\n+\n+/* The documentation doesn't actually specify what the\n+   JVMPI_DUMP_LEVEL macros should be defined to.  Here's a reasonable\n+   guess.  */\n+#define JVMPI_DUMP_LEVEL_0 0\n+#define JVMPI_DUMP_LEVEL_1 1\n+#define JVMPI_DUMP_LEVEL_2 2\n+#define JVMPI_DUMP_LEVEL_3 3\n+\n+typedef struct\n+{\n+  /* One of JVMPI_DUMP_LEVEL_0, JVMPI_DUMP_LEVEL_1 or\n+     JVMPI_DUMP_LEVEL_2.  */\n+  jint heap_dump_level;\n+} JVMPI_HeapDumpArg;\n+\n+typedef struct\n+{\n+  /* Offset from the beginning of the method.  */\n+  jint offset;\n+  /* Line number from the beginning of the source file.  */\n+  jint lineno;\n+} JVMPI_Lineno;\n+\n+typedef struct\n+{\n+  /* Name of the method.  */\n+  char *method_name;\n+  /* Signature of the method.  */\n+  char *method_signature;\n+  /* Start line number from the beginning of the source file.  */\n+  jint start_lineno;\n+  /* End line number from the beginning of the source file.  */\n+  jint end_lineno;\n+  /* The method ID.  */\n+  jmethodID method_id;\n+} JVMPI_Method;\n+\n+/* An opaque pointer representing a raw monitor.  */\n+struct _JVMPI_RawMonitor;\n+typedef struct _JVMPI_RawMonitor *JVMPI_RawMonitor;\n+\n+/* JVMPI event codes.  FIXME: These are semi-random numbers.  The\n+   documentation doesn't say what they should be.  */\n+#define JVMPI_EVENT_ARENA_DELETE                   0\n+#define JVMPI_EVENT_ARENA_NEW                      1\n+#define JVMPI_EVENT_CLASS_LOAD                     2\n+#define JVMPI_EVENT_CLASS_LOAD_HOOK                3\n+#define JVMPI_EVENT_CLASS_UNLOAD                   4\n+#define JVMPI_EVENT_COMPILED_METHOD_LOAD           5\n+#define JVMPI_EVENT_COMPILED_METHOD_UNLOAD         6\n+#define JVMPI_EVENT_DATA_DUMP_REQUEST              7\n+#define JVMPI_EVENT_DATA_RESET_REQUEST             8\n+#define JVMPI_EVENT_GC_FINISH                      9\n+#define JVMPI_EVENT_GC_START                      10\n+#define JVMPI_EVENT_HEAP_DUMP                     11\n+#define JVMPI_EVENT_JNI_GLOBALREF_ALLOC           12\n+#define JVMPI_EVENT_JNI_GLOBALREF_FREE            13\n+#define JVMPI_EVENT_JNI_WEAK_GLOBALREF_ALLOC      14\n+#define JVMPI_EVENT_JNI_WEAK_GLOBALREF_FREE       15\n+#define JVMPI_EVENT_JVM_INIT_DONE                 16\n+#define JVMPI_EVENT_JVM_SHUT_DOWN                 17\n+#define JVMPI_EVENT_METHOD_ENTRY                  18\n+#define JVMPI_EVENT_METHOD_ENTRY2                 19\n+#define JVMPI_EVENT_METHOD_EXIT                   20\n+#define JVMPI_EVENT_MONITOR_CONTENDED_ENTER       21\n+#define JVMPI_EVENT_MONITOR_CONTENDED_ENTERED     22\n+#define JVMPI_EVENT_MONITOR_CONTENDED_EXIT        23\n+#define JVMPI_EVENT_MONITOR_DUMP                  24\n+#define JVMPI_EVENT_MONITOR_WAIT                  25\n+#define JVMPI_EVENT_MONITOR_WAITED                26\n+#define JVMPI_EVENT_OBJECT_ALLOC                  27\n+#define JVMPI_EVENT_OBJECT_DUMP                   28\n+#define JVMPI_EVENT_OBJECT_FREE                   29\n+#define JVMPI_EVENT_OBJECT_MOVE                   30\n+#define JVMPI_EVENT_RAW_MONITOR_CONTENDED_ENTER   31\n+#define JVMPI_EVENT_RAW_MONITOR_CONTENDED_ENTERED 32\n+#define JVMPI_EVENT_RAW_MONITOR_CONTENDED_EXIT    33\n+#define JVMPI_EVENT_THREAD_END                    34\n+#define JVMPI_EVENT_THREAD_START                  35\n+#define JVMPI_EVENT_INSTRUCTION_START             36\n+\n+\n+typedef struct\n+{\n+  /* Event type.  */\n+  jint event_type;\n+\n+  /* Evn where this event occurred.  */\n+  JNIEnv *env_id;\n+\n+  union \n+  {\n+    struct\n+    {\n+      char *class_name;\n+      char *source_name;\n+      jint num_interfaces;\n+      jint num_methods;\n+      JVMPI_Method *methods;\n+      jint num_static_fields;\n+      JVMPI_Field *statics;\n+      jint num_instance_fields;\n+      JVMPI_Field *instances;\n+      jobjectID class_id;\n+    } class_load;\n+\n+    struct\n+    {\n+      jobjectID class_id;\n+    } class_unload;\n+\n+    struct\n+    {\n+      jint arena_id;\n+      jobjectID class_id;\n+      jint is_array;\n+      jint size;\n+      jobjectID obj_id;\n+    } obj_alloc;\n+\n+    struct\n+    {\n+      char *thread_name;\n+      char *group_name;\n+      char *parent_name;\n+      jobjectID thread_id;\n+      JNIEnv *thread_env_id;\n+    } thread_start;\n+\n+  } u;\n+\n+} JVMPI_Event;\n+\n+typedef struct\n+{\n+  /* JVMPI version number.  */\n+  jint version;\n+  \n+  /* Implemented by the user...  */\n+  void (*NotifyEvent) (JVMPI_Event *event);\n+  \n+  /* Implemented by the runtime...  */\n+  jint (*EnableEvent) (jint event_type, void *arg);\n+  jint (*DisableEvent) (jint event_type, void *arg);\n+  jint (*RequestEvent) (jint event_type, void *arg);\n+  void (*GetCallTrace) (JVMPI_CallTrace *trace, jint depth);\n+  void (*ProfilerExit) (jint);\n+  JVMPI_RawMonitor (*RawMonitorCreate) (char *lock_name);\n+  void (*RawMonitorEnter) (JVMPI_RawMonitor lock_id);\n+  void (*RawMonitorExit) (JVMPI_RawMonitor lock_id);\n+  void (*RawMonitorWait) (JVMPI_RawMonitor lock_id, jlong ms);\n+  void (*RawMonitorNotifyAll) (JVMPI_RawMonitor lock_id);\n+  void (*RawMonitorDestroy) (JVMPI_RawMonitor lock_id);\n+  jlong (*GetCurrentThreadCpuTime) (void);\n+  void (*SuspendThread) (JNIEnv *env);\n+  void (*ResumeThread) (JNIEnv *env);\n+  jint (*GetThreadStatus) (JNIEnv *env);\n+  jboolean (*ThreadHasRun) (JNIEnv *env);\n+  jint (*CreateSystemThread) (char *name, jint priority, void (*f) (void *));\n+  void (*SetThreadLocalStorage) (JNIEnv *env_id, void *ptr);\n+  void *(*GetThreadLocalStorage) (JNIEnv *env_id);\n+  void (*DisableGC) (void);\n+  void (*EnableGC) (void);\n+  void (*RunGC) (void);\n+  jobjectID (*GetThreadObject) (JNIEnv *env);\n+  jobjectID (*GetMethodClass) (jmethodID mid);\n+  \n+} JVMPI_Interface;\n+\n+#endif /* __GCJ_JVMPI_H__ */"}]}