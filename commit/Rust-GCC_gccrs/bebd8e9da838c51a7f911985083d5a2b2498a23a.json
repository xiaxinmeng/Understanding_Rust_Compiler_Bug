{"sha": "bebd8e9da838c51a7f911985083d5a2b2498a23a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmViZDhlOWRhODM4YzUxYTdmOTExOTg1MDgzZDVhMmIyNDk4YTIzYQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-07-14T19:37:30Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-07-14T19:37:30Z"}, "message": "c++: CTAD and forwarding references [PR88252]\n\nHere during CTAD we're incorrectly treating T&& as a forwarding\nreference even though T is a template parameter of the class template.\n\nThis happens because the template parameter T in the out-of-line\ndefinition of the constructor doesn't have the flag\nTEMPLATE_TYPE_PARM_FOR_CLASS set, and during duplicate_decls the\nthe redeclaration (which is in terms of this unflagged T) prevails.\nTo fix this, we could perhaps be more consistent about setting the flag,\nbut it appears we don't really need this flag to make the determination.\n\nSince the template parameters of an synthesized guide consist of the\ntemplate parameters of the class template followed by those of the\nconstructor (if any), it should suffice to look at the index of the\ntemplate parameter to determine whether it comes from the class\ntemplate or the constructor (template).  This patch replaces the\nTEMPLATE_TYPE_PARM_FOR_CLASS flag with this approach.\n\n\tPR c++/88252\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (TEMPLATE_TYPE_PARM_FOR_CLASS): Remove.\n\t* pt.c (push_template_decl): Remove TEMPLATE_TYPE_PARM_FOR_CLASS\n\thandling.\n\t(redeclare_class_template): Likewise.\n\t(forwarding_reference_p): Define.\n\t(maybe_adjust_types_for_deduction): Use it instead.  Add 'tparms'\n\tparameter.\n\t(unify_one_argument): Pass tparms to\n\tmaybe_adjust_types_for_deduction.\n\t(try_one_overload): Likewise.\n\t(unify): Likewise.\n\t(rewrite_template_parm): Remove TEMPLATE_TYPE_PARM_FOR_CLASS\n\thandling.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1z/class-deduction96.C: New test.", "tree": {"sha": "1f1fa33ea953166342a0ca303c3b0fa75c3ea7df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f1fa33ea953166342a0ca303c3b0fa75c3ea7df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bebd8e9da838c51a7f911985083d5a2b2498a23a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bebd8e9da838c51a7f911985083d5a2b2498a23a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bebd8e9da838c51a7f911985083d5a2b2498a23a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bebd8e9da838c51a7f911985083d5a2b2498a23a/comments", "author": null, "committer": null, "parents": [{"sha": "91bb571d200e551f427e337e00494e0b4f229876", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bb571d200e551f427e337e00494e0b4f229876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91bb571d200e551f427e337e00494e0b4f229876"}], "stats": {"total": 130, "additions": 84, "deletions": 46}, "files": [{"sha": "f4bcab5b18d294cb7c4c9af4d7633dac5712f224", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bebd8e9da838c51a7f911985083d5a2b2498a23a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bebd8e9da838c51a7f911985083d5a2b2498a23a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bebd8e9da838c51a7f911985083d5a2b2498a23a", "patch": "@@ -443,7 +443,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       BLOCK_OUTER_CURLY_BRACE_P (in BLOCK)\n       FOLD_EXPR_MODOP_P (*_FOLD_EXPR)\n       IF_STMT_CONSTEXPR_P (IF_STMT)\n-      TEMPLATE_TYPE_PARM_FOR_CLASS (TEMPLATE_TYPE_PARM)\n       DECL_NAMESPACE_INLINE_P (in NAMESPACE_DECL)\n       SWITCH_STMT_ALL_CASES_P (in SWITCH_STMT)\n       REINTERPRET_CAST_P (in NOP_EXPR)\n@@ -5863,11 +5862,6 @@ enum auto_deduction_context\n   adc_decomp_type    /* Decomposition declaration initializer deduction */\n };\n \n-/* True if this type-parameter belongs to a class template, used by C++17\n-   class template argument deduction.  */\n-#define TEMPLATE_TYPE_PARM_FOR_CLASS(NODE) \\\n-  (TREE_LANG_FLAG_0 (TEMPLATE_TYPE_PARM_CHECK (NODE)))\n-\n /* True iff this TEMPLATE_TYPE_PARM represents decltype(auto).  */\n #define AUTO_IS_DECLTYPE(NODE) \\\n   (TYPE_LANG_FLAG_5 (TEMPLATE_TYPE_PARM_CHECK (NODE)))"}, {"sha": "c7bf7d412ca22922ebacd0f207714d6d5a865bd1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bebd8e9da838c51a7f911985083d5a2b2498a23a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bebd8e9da838c51a7f911985083d5a2b2498a23a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bebd8e9da838c51a7f911985083d5a2b2498a23a", "patch": "@@ -154,8 +154,8 @@ static void tsubst_enum\t(tree, tree, tree);\n static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n static int check_non_deducible_conversion (tree, tree, int, int,\n \t\t\t\t\t   struct conversion **, bool);\n-static int maybe_adjust_types_for_deduction (unification_kind_t, tree*, tree*,\n-\t\t\t\t\t     tree);\n+static int maybe_adjust_types_for_deduction (tree, unification_kind_t,\n+\t\t\t\t\t     tree*, tree*, tree);\n static int type_unification_real (tree, tree, tree, const tree *,\n \t\t\t\t  unsigned int, int, unification_kind_t,\n \t\t\t\t  vec<deferred_access_check, va_gc> **,\n@@ -5801,18 +5801,7 @@ push_template_decl (tree decl, bool is_friend)\n \t}\n       else if (DECL_IMPLICIT_TYPEDEF_P (decl)\n \t       && CLASS_TYPE_P (TREE_TYPE (decl)))\n-\t{\n-\t  /* Class template, set TEMPLATE_TYPE_PARM_FOR_CLASS.  */\n-\t  tree parms = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n-\t  for (int i = 0; i < TREE_VEC_LENGTH (parms); ++i)\n-\t    {\n-\t      tree t = TREE_VALUE (TREE_VEC_ELT (parms, i));\n-\t      if (TREE_CODE (t) == TYPE_DECL)\n-\t\tt = TREE_TYPE (t);\n-\t      if (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n-\t\tTEMPLATE_TYPE_PARM_FOR_CLASS (t) = true;\n-\t    }\n-\t}\n+\t/* Class template.  */;\n       else if (TREE_CODE (decl) == TYPE_DECL\n \t       && TYPE_DECL_ALIAS_P (decl))\n \t/* alias-declaration */\n@@ -6292,9 +6281,6 @@ redeclare_class_template (tree type, tree parms, tree cons)\n \t  gcc_assert (DECL_CONTEXT (parm) == NULL_TREE);\n \t  DECL_CONTEXT (parm) = tmpl;\n \t}\n-\n-      if (TREE_CODE (parm) == TYPE_DECL)\n-\tTEMPLATE_TYPE_PARM_FOR_CLASS (TREE_TYPE (parm)) = true;\n     }\n \n   tree ci = get_constraints (tmpl);\n@@ -21709,6 +21695,41 @@ fn_type_unification (tree fn,\n   return r;\n }\n \n+/* Returns true iff PARM is a forwarding reference in the context of\n+   template argument deduction for TMPL.  */\n+\n+static bool\n+forwarding_reference_p (tree parm, tree tmpl)\n+{\n+  /* [temp.deduct.call], \"A forwarding reference is an rvalue reference to a\n+     cv-unqualified template parameter ...\"  */\n+  if (TYPE_REF_P (parm)\n+      && TYPE_REF_IS_RVALUE (parm)\n+      && TREE_CODE (TREE_TYPE (parm)) == TEMPLATE_TYPE_PARM\n+      && cp_type_quals (TREE_TYPE (parm)) == TYPE_UNQUALIFIED)\n+    {\n+      parm = TREE_TYPE (parm);\n+      /* [temp.deduct.call], \"... that does not represent a template parameter\n+\t of a class template (during class template argument deduction).\"  */\n+      if (tmpl\n+\t  && deduction_guide_p (tmpl)\n+\t  && DECL_ARTIFICIAL (tmpl))\n+\t{\n+\t  /* Since the template parameters of a synthesized guide consist of\n+\t     the template parameters of the class template followed by those of\n+\t     the constructor (if any), we can tell if PARM represents a template\n+\t     parameter of the class template by comparing its index with the\n+\t     arity of the class template.  */\n+\t  tree ctmpl = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (TREE_TYPE (tmpl)));\n+\t  if (TEMPLATE_TYPE_IDX (parm)\n+\t      < TREE_VEC_LENGTH (DECL_INNERMOST_TEMPLATE_PARMS (ctmpl)))\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Adjust types before performing type deduction, as described in\n    [temp.deduct.call] and [temp.deduct.conv].  The rules in these two\n    sections are symmetric.  PARM is the type of a function parameter\n@@ -21718,7 +21739,8 @@ fn_type_unification (tree fn,\n    ARG_EXPR is the original argument expression, which may be null.  */\n \n static int\n-maybe_adjust_types_for_deduction (unification_kind_t strict,\n+maybe_adjust_types_for_deduction (tree tparms,\n+\t\t\t\t  unification_kind_t strict,\n \t\t\t\t  tree* parm,\n \t\t\t\t  tree* arg,\n \t\t\t\t  tree arg_expr)\n@@ -21741,10 +21763,7 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n       /* Core issue #873: Do the DR606 thing (see below) for these cases,\n \t too, but here handle it by stripping the reference from PARM\n \t rather than by adding it to ARG.  */\n-      if (TYPE_REF_P (*parm)\n-\t  && TYPE_REF_IS_RVALUE (*parm)\n-\t  && TREE_CODE (TREE_TYPE (*parm)) == TEMPLATE_TYPE_PARM\n-\t  && cp_type_quals (TREE_TYPE (*parm)) == TYPE_UNQUALIFIED\n+      if (forwarding_reference_p (*parm, TPARMS_PRIMARY_TEMPLATE (tparms))\n \t  && TYPE_REF_P (*arg)\n \t  && !TYPE_REF_IS_RVALUE (*arg))\n \t*parm = TREE_TYPE (*parm);\n@@ -21781,17 +21800,10 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n \t*arg = TYPE_MAIN_VARIANT (*arg);\n     }\n \n-  /* [14.8.2.1/3 temp.deduct.call], \"A forwarding reference is an rvalue\n-     reference to a cv-unqualified template parameter that does not represent a\n-     template parameter of a class template (during class template argument\n-     deduction (13.3.1.8)). If P is a forwarding reference and the argument is\n-     an lvalue, the type \"lvalue reference to A\" is used in place of A for type\n-     deduction. */\n-  if (TYPE_REF_P (*parm)\n-      && TYPE_REF_IS_RVALUE (*parm)\n-      && TREE_CODE (TREE_TYPE (*parm)) == TEMPLATE_TYPE_PARM\n-      && !TEMPLATE_TYPE_PARM_FOR_CLASS (TREE_TYPE (*parm))\n-      && cp_type_quals (TREE_TYPE (*parm)) == TYPE_UNQUALIFIED\n+  /* [temp.deduct.call], \"If P is a forwarding reference and the argument is\n+     an lvalue, the type 'lvalue reference to A' is used in place of A for\n+     type deduction.\"  */\n+  if (forwarding_reference_p (*parm, TPARMS_PRIMARY_TEMPLATE (tparms))\n       && (arg_expr ? lvalue_p (arg_expr)\n \t  /* try_one_overload doesn't provide an arg_expr, but\n \t     functions are always lvalues.  */\n@@ -22080,8 +22092,8 @@ unify_one_argument (tree tparms, tree targs, tree parm, tree arg,\n \t    return unify_invalid (explain_p);\n \t}\n \n-      arg_strict |=\n-\tmaybe_adjust_types_for_deduction (strict, &parm, &arg, arg_expr);\n+      arg_strict |= maybe_adjust_types_for_deduction (tparms, strict,\n+\t\t\t\t\t\t      &parm, &arg, arg_expr);\n     }\n   else\n     if ((TYPE_P (parm) || TREE_CODE (parm) == TEMPLATE_DECL)\n@@ -22750,7 +22762,8 @@ try_one_overload (tree tparms,\n   else if (addr_p)\n     arg = build_pointer_type (arg);\n \n-  sub_strict |= maybe_adjust_types_for_deduction (strict, &parm, &arg, NULL);\n+  sub_strict |= maybe_adjust_types_for_deduction (tparms, strict,\n+\t\t\t\t\t\t  &parm, &arg, NULL_TREE);\n \n   /* We don't copy orig_targs for this because if we have already deduced\n      some template args from previous args, unify would complain when we\n@@ -23449,7 +23462,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t\t/* It should only be possible to get here for a call.  */\n \t\tgcc_assert (elt_strict & UNIFY_ALLOW_OUTER_LEVEL);\n \t\telt_strict |= maybe_adjust_types_for_deduction\n-\t\t  (DEDUCE_CALL, &elttype, &type, elt);\n+\t\t  (tparms, DEDUCE_CALL, &elttype, &type, elt);\n \t\telt = type;\n \t      }\n \n@@ -28495,9 +28508,6 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,\n       tree oldtype = TREE_TYPE (olddecl);\n       newtype = cxx_make_type (TREE_CODE (oldtype));\n       TYPE_MAIN_VARIANT (newtype) = newtype;\n-      if (TREE_CODE (oldtype) == TEMPLATE_TYPE_PARM)\n-\tTEMPLATE_TYPE_PARM_FOR_CLASS (newtype)\n-\t  = TEMPLATE_TYPE_PARM_FOR_CLASS (oldtype);\n     }\n   else\n     {"}, {"sha": "7fa8400830ec33c52f922bfe56bc1fc5b54ccebc", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction96.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bebd8e9da838c51a7f911985083d5a2b2498a23a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction96.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bebd8e9da838c51a7f911985083d5a2b2498a23a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction96.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction96.C?ref=bebd8e9da838c51a7f911985083d5a2b2498a23a", "patch": "@@ -0,0 +1,34 @@\n+// PR c++/88252\n+// { dg-do compile { target c++17 } }\n+\n+template<class T>\n+struct A {\n+  A(T&&);\n+  template<class U> A(T&&, U&&);\n+  template<class U> struct B;\n+};\n+\n+template<class T>\n+A<T>::A(T&&) { }\n+\n+template<class T>\n+template<class U>\n+A<T>::A(T&&, U&&) { }\n+\n+template<class T>\n+template<class U>\n+struct A<T>::B {\n+  B(U&&);\n+  template<class V> B(U&&, V&&);\n+};\n+\n+int i;\n+\n+int main() {\n+  A{i}; // { dg-error \"deduction|no match|rvalue reference\" }\n+  A{i, 0}; // { dg-error \"deduction|no match|rvalue reference\" }\n+  A{0, i};\n+  A<int>::B{i}; // { dg-error \"deduction|no match|rvalue reference\" }\n+  A<int>::B{i, 0}; // { dg-error \"deduction|no match|rvalue reference\" }\n+  A<int>::B{0, i};\n+}"}]}