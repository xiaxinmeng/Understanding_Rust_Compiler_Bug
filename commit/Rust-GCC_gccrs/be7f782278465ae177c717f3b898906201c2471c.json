{"sha": "be7f782278465ae177c717f3b898906201c2471c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU3Zjc4MjI3ODQ2NWFlMTc3YzcxN2YzYjg5ODkwNjIwMWMyNDcxYw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-04-19T13:26:08Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-04-19T13:26:08Z"}, "message": "re PR libstdc++/48521 ([C++0x] std::result_of doesn't work with pointer to member)\n\n2011-04-19  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\tPR libstdc++/48521\n\t* include/std/type_traits (result_of): Handle pointer to member.\n\t* include/std/functional (__invoke): Likewise.\n\t(_Function_to_function_pointer): Remove.\n\t(_Reference_wrapper_base): Provide nested types independent of\n\tunary_function and binary_function.\n\t(reference_wrapper::operator()): DR 2017.\n\t(ref(const A&&), cref(const A&&): Define as deleted.\n\t* include/std/future (async): Simplify SFINAE and use result_of to\n\tsupport pointer to member.\n\t* testsuite/20_util/reference_wrapper/invoke.cc: Test pointer to \n\tmember.\n\t* testsuite/20_util/reference_wrapper/24803.cc: Likewise.\n\t* testsuite/20_util/reference_wrapper/typedefs.cc: Test for types\n\tinstead of derivation from unary_function and binary_function.\n\t* testsuite/20_util/declval/requirements/1_neg.cc: Adjust.\n\t* testsuite/20_util/reference_wrapper/invoke-2.cc: New.\n\t* testsuite/20_util/reference_wrapper/ref_neg.c: New.\n\t* testsuite/20_util/reference_wrapper/typedefs-3.c: New.\n\nFrom-SVN: r172709", "tree": {"sha": "46bddda6e0625793f71e6f9abbe316c4f086c355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46bddda6e0625793f71e6f9abbe316c4f086c355"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be7f782278465ae177c717f3b898906201c2471c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7f782278465ae177c717f3b898906201c2471c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be7f782278465ae177c717f3b898906201c2471c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7f782278465ae177c717f3b898906201c2471c/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d39132ea9b9d1a740bfc169326020fc28d78ba81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d39132ea9b9d1a740bfc169326020fc28d78ba81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d39132ea9b9d1a740bfc169326020fc28d78ba81"}], "stats": {"total": 565, "additions": 463, "deletions": 102}, "files": [{"sha": "3aa9a3907ca0cac1d3677d641a040b3cafb3385a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=be7f782278465ae177c717f3b898906201c2471c", "patch": "@@ -1,3 +1,25 @@\n+2011-04-19  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/48521\n+\t* include/std/type_traits (result_of): Handle pointer to member.\n+\t* include/std/functional (__invoke): Likewise.\n+\t(_Function_to_function_pointer): Remove.\n+\t(_Reference_wrapper_base): Provide nested types independent of\n+\tunary_function and binary_function.\n+\t(reference_wrapper::operator()): DR 2017.\n+\t(ref(const A&&), cref(const A&&): Define as deleted.\n+\t* include/std/future (async): Simplify SFINAE and use result_of to\n+\tsupport pointer to member.\n+\t* testsuite/20_util/reference_wrapper/invoke.cc: Test pointer to \n+\tmember.\n+\t* testsuite/20_util/reference_wrapper/24803.cc: Likewise.\n+\t* testsuite/20_util/reference_wrapper/typedefs.cc: Test for types\n+\tinstead of derivation from unary_function and binary_function.\n+\t* testsuite/20_util/declval/requirements/1_neg.cc: Adjust.\n+\t* testsuite/20_util/reference_wrapper/invoke-2.cc: New.\n+\t* testsuite/20_util/reference_wrapper/ref_neg.c: New.\n+\t* testsuite/20_util/reference_wrapper/typedefs-3.c: New.\n+\n 2011-04-19  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR testsuite/48675"}, {"sha": "57ec50621337a65e3f306c704f75abf34ea65f82", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=be7f782278465ae177c717f3b898906201c2471c", "patch": "@@ -212,19 +212,6 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       static const bool value = sizeof(__test((_Tp*)0)) == 1;\n     };\n \n-  /// Turns a function type into a function pointer type\n-  template<typename _Tp, bool _IsFunctionType = is_function<_Tp>::value>\n-    struct _Function_to_function_pointer\n-    {\n-      typedef _Tp type;\n-    };\n-\n-  template<typename _Tp>\n-    struct _Function_to_function_pointer<_Tp, true>\n-    {\n-      typedef _Tp* type;\n-    };\n-\n   /**\n    * Invoke a function object, which may be either a member pointer or a\n    * function object. The first parameter will tell which.\n@@ -235,20 +222,33 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t     (!is_member_pointer<_Functor>::value\n \t      && !is_function<_Functor>::value\n \t      && !is_function<typename remove_pointer<_Functor>::type>::value),\n-\t     typename result_of<_Functor(_Args...)>::type\n+\t     typename result_of<_Functor(_Args&&...)>::type\n \t   >::type\n     __invoke(_Functor& __f, _Args&&... __args)\n     {\n       return __f(std::forward<_Args>(__args)...);\n     }\n \n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename enable_if<\n+             (is_member_pointer<_Functor>::value\n+              && !is_function<_Functor>::value\n+              && !is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args&&...)>::type\n+           >::type\n+    __invoke(_Functor& __f, _Args&&... __args)\n+    {\n+      return mem_fn(__f)(std::forward<_Args>(__args)...);\n+    }\n+\n   // To pick up function references (that will become function pointers)\n   template<typename _Functor, typename... _Args>\n     inline\n     typename enable_if<\n \t     (is_pointer<_Functor>::value\n \t      && is_function<typename remove_pointer<_Functor>::type>::value),\n-\t     typename result_of<_Functor(_Args...)>::type\n+\t     typename result_of<_Functor(_Args&&...)>::type\n \t   >::type\n     __invoke(_Functor __f, _Args&&... __args)\n     {\n@@ -263,40 +263,43 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   template<bool _Unary, bool _Binary, typename _Tp>\n     struct _Reference_wrapper_base_impl;\n \n-  // Not a unary_function or binary_function, so try a weak result type.\n+  // None of the nested argument types.\n   template<typename _Tp>\n     struct _Reference_wrapper_base_impl<false, false, _Tp>\n     : _Weak_result_type<_Tp>\n     { };\n \n-  // unary_function but not binary_function\n+  // Nested argument_type only.\n   template<typename _Tp>\n     struct _Reference_wrapper_base_impl<true, false, _Tp>\n-    : unary_function<typename _Tp::argument_type,\n-\t\t     typename _Tp::result_type>\n-    { };\n+    : _Weak_result_type<_Tp>\n+    {\n+      typedef typename _Tp::argument_type argument_type;\n+    };\n \n-  // binary_function but not unary_function\n+  // Nested first_argument_type and second_argument_type only.\n   template<typename _Tp>\n     struct _Reference_wrapper_base_impl<false, true, _Tp>\n-    : binary_function<typename _Tp::first_argument_type,\n-\t\t      typename _Tp::second_argument_type,\n-\t\t      typename _Tp::result_type>\n-    { };\n+    : _Weak_result_type<_Tp>\n+    {\n+      typedef typename _Tp::first_argument_type first_argument_type;\n+      typedef typename _Tp::second_argument_type second_argument_type;\n+    };\n \n-  // Both unary_function and binary_function. Import result_type to\n-  // avoid conflicts.\n+  // All the nested argument types.\n    template<typename _Tp>\n     struct _Reference_wrapper_base_impl<true, true, _Tp>\n-    : unary_function<typename _Tp::argument_type,\n-\t\t     typename _Tp::result_type>,\n-      binary_function<typename _Tp::first_argument_type,\n-\t\t      typename _Tp::second_argument_type,\n-\t\t      typename _Tp::result_type>\n+    : _Weak_result_type<_Tp>\n     {\n-      typedef typename _Tp::result_type result_type;\n+      typedef typename _Tp::argument_type argument_type;\n+      typedef typename _Tp::first_argument_type first_argument_type;\n+      typedef typename _Tp::second_argument_type second_argument_type;\n     };\n \n+  _GLIBCXX_HAS_NESTED_TYPE(argument_type)\n+  _GLIBCXX_HAS_NESTED_TYPE(first_argument_type)\n+  _GLIBCXX_HAS_NESTED_TYPE(second_argument_type)\n+\n   /**\n    *  Derives from unary_function or binary_function when it\n    *  can. Specializations handle all of the easy cases. The primary\n@@ -306,8 +309,9 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   template<typename _Tp>\n     struct _Reference_wrapper_base\n     : _Reference_wrapper_base_impl<\n-      _Derives_from_unary_function<_Tp>::value,\n-      _Derives_from_binary_function<_Tp>::value,\n+      __has_argument_type<_Tp>::value,\n+      __has_first_argument_type<_Tp>::value\n+      && __has_second_argument_type<_Tp>::value,\n       _Tp>\n     { };\n \n@@ -422,12 +426,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     class reference_wrapper\n     : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>\n     {\n-      // If _Tp is a function type, we can't form result_of<_Tp(...)>,\n-      // so turn it into a function pointer type.\n-      typedef typename _Function_to_function_pointer<_Tp>::type\n-\t_M_func_type;\n-\n       _Tp* _M_data;\n+\n     public:\n       typedef _Tp type;\n \n@@ -456,7 +456,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       { return *_M_data; }\n \n       template<typename... _Args>\n-\ttypename result_of<_M_func_type(_Args...)>::type\n+\ttypename result_of<_Tp&(_Args&&...)>::type\n \toperator()(_Args&&... __args) const\n \t{\n \t  return __invoke(get(), std::forward<_Args>(__args)...);\n@@ -476,6 +476,12 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     cref(const _Tp& __t)\n     { return reference_wrapper<const _Tp>(__t); }\n \n+  template<typename _Tp>\n+    void ref(const _Tp&&) = delete;\n+\n+  template<typename _Tp>\n+    void cref(const _Tp&&) = delete;\n+\n   /// Partial specialization.\n   template<typename _Tp>\n     inline reference_wrapper<_Tp>"}, {"sha": "f7035a9109a35a8911ed9c2129147556d334c5be", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=be7f782278465ae177c717f3b898906201c2471c", "patch": "@@ -142,11 +142,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     future<typename result_of<_Fn(_Args...)>::type>\n     async(launch __policy, _Fn&& __fn, _Args&&... __args);\n \n+  template<typename _FnCheck, typename _Fn, typename... _Args>\n+    struct __async_sfinae_helper\n+    {\n+      typedef future<typename result_of<_Fn(_Args...)>::type> type;\n+    };\n+\n+  template<typename _Fn, typename... _Args>\n+    struct __async_sfinae_helper<launch, _Fn, _Args...>\n+    { };\n+\n   template<typename _Fn, typename... _Args>\n     typename\n-    enable_if<!is_same<typename decay<_Fn>::type, launch>::value,\n-              future<decltype(std::declval<_Fn>()(std::declval<_Args>()...))>\n-             >::type\n+    __async_sfinae_helper<typename decay<_Fn>::type, _Fn, _Args...>::type\n     async(_Fn&& __fn, _Args&&... __args);\n \n #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1) \\\n@@ -1373,9 +1381,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// async, potential overload\n   template<typename _Fn, typename... _Args>\n     inline typename\n-    enable_if<!is_same<typename decay<_Fn>::type, launch>::value,\n-              future<decltype(std::declval<_Fn>()(std::declval<_Args>()...))>\n-             >::type\n+    __async_sfinae_helper<typename decay<_Fn>::type, _Fn, _Args...>::type\n     async(_Fn&& __fn, _Args&&... __args)\n     {\n       return async(launch::any, std::forward<_Fn>(__fn),"}, {"sha": "11f1b0122612837b44b4cb75514d2401fdd3f4ec", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 92, "deletions": 12, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=be7f782278465ae177c717f3b898906201c2471c", "patch": "@@ -1583,18 +1583,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// underlying_type (still unimplemented)\n \n-  /// result_of\n-  template<typename _Signature>\n-    class result_of;\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    struct result_of<_Functor(_ArgTypes...)>\n-    {\n-      typedef\n-        decltype( std::declval<_Functor>()(std::declval<_ArgTypes>()...) )\n-        type;\n-    };\n-\n   /// declval\n   template<typename _Tp>\n     struct __declval_protector\n@@ -1612,6 +1600,98 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __declval_protector<_Tp>::__delegate();\n     }\n \n+  /// result_of\n+  template<typename _Signature>\n+    class result_of;\n+\n+  template<typename _MemPtr, typename _Arg>\n+    struct _Result_of_memobj;\n+\n+  template<typename _Res, typename _Class, typename _Arg>\n+    struct _Result_of_memobj<_Res _Class::*, _Arg>\n+    {\n+    private:\n+      typedef _Res _Class::* _Func;\n+\n+      template<typename _Tp>\n+\tstatic _Tp _S_get(const _Class&);\n+      template<typename _Tp>\n+\tstatic decltype(*std::declval<_Tp>()) _S_get(...);\n+        \n+    public:\n+      typedef\n+        decltype(_S_get<_Arg>(std::declval<_Arg>()).*std::declval<_Func>())\n+        __type;\n+    };\n+\n+  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>\n+    struct _Result_of_memfun;\n+\n+  template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n+    struct _Result_of_memfun<_Res _Class::*, _Arg, _Args...>\n+    {\n+    private:\n+      typedef _Res _Class::* _Func;\n+\n+      template<typename _Tp>\n+\tstatic _Tp _S_get(const _Class&);\n+      template<typename _Tp>\n+\tstatic decltype(*std::declval<_Tp>()) _S_get(...);\n+        \n+    public:\n+      typedef\n+        decltype((_S_get<_Arg>(std::declval<_Arg>()).*std::declval<_Func>())\n+            (std::declval<_Args>()...) )\n+        __type;\n+    };\n+\n+  template<bool, bool, typename _Functor, typename... _ArgTypes>\n+    struct _Result_of_impl;\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct _Result_of_impl<false, false, _Functor, _ArgTypes...>\n+    {\n+      typedef\n+        decltype( std::declval<_Functor>()(std::declval<_ArgTypes>()...) )\n+        __type;\n+    };\n+\n+  template<typename _MemPtr, typename _Arg>\n+    struct _Result_of_impl<true, false, _MemPtr, _Arg>\n+    : _Result_of_memobj<typename remove_reference<_MemPtr>::type, _Arg>\n+    {\n+      typedef typename _Result_of_memobj<\n+\ttypename remove_reference<_MemPtr>::type, _Arg>::__type\n+\t__type;\n+    };\n+\n+  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>\n+    struct _Result_of_impl<false, true, _MemPtr, _Arg, _ArgTypes...>\n+    : _Result_of_memfun<typename remove_reference<_MemPtr>::type, _Arg,\n+                        _ArgTypes...>\n+    {\n+      typedef typename _Result_of_memfun<\n+\ttypename remove_reference<_MemPtr>::type, _Arg, _ArgTypes...>::__type\n+\t__type;\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct result_of<_Functor(_ArgTypes...)>\n+    : _Result_of_impl<is_member_object_pointer<\n+                        typename remove_reference<_Functor>::type >::value,\n+                      is_member_function_pointer<\n+\t\t\ttypename remove_reference<_Functor>::type >::value,\n+\t\t      _Functor, _ArgTypes...>\n+    {\n+      typedef typename _Result_of_impl<\n+\tis_member_object_pointer<\n+\t  typename remove_reference<_Functor>::type >::value,\n+        is_member_function_pointer<\n+\t  typename remove_reference<_Functor>::type >::value,\n+       \t_Functor, _ArgTypes...>::__type\n+\ttype;\n+    };\n+\n   /**\n    *  Use SFINAE to determine if the type _Tp has a publicly-accessible\n    *  member type _NTYPE."}, {"sha": "debff581af5c592e475078c170ad63a362f4950b", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=be7f782278465ae177c717f3b898906201c2471c", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1610 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1598 }\n \n #include <utility>\n "}, {"sha": "4bf61485cc8094b4361a3d604d98bda053f3417b", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/24803.cc", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F24803.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F24803.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F24803.cc?ref=be7f782278465ae177c717f3b898906201c2471c", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -46,12 +46,18 @@ void verify_return_type(T, T)\n \n void test01()\n {\n+  test_type* null_tt = 0;\n+  const test_type* null_ttc = 0;\n   int zero;\n \n   std::reference_wrapper<double (int)>* pr1(0);\n   verify_return_type((*pr1)(0), double());\n   std::reference_wrapper<double (*)(int)>* pr2(0);\n   verify_return_type((*pr2)(0), double());\n+  std::reference_wrapper<int (test_type::*)()>* pr3(0);\n+  verify_return_type((*pr3)(null_tt), int());\n+  std::reference_wrapper<int (test_type::*)()const>* pr4(0);\n+  verify_return_type((*pr4)(null_ttc), int());\n   std::reference_wrapper<functor1>* pr5(0);\n \n   // libstdc++/24803\n@@ -62,6 +68,10 @@ void test01()\n   verify_return_type((*pr1b)(0, 0), double());\n   std::reference_wrapper<double (*)(int, char)>* pr2b(0);\n   verify_return_type((*pr2b)(0, 0), double());\n+  std::reference_wrapper<int (test_type::*)(char)>* pr3b(0);\n+  verify_return_type((*pr3b)(null_tt,zero), int());\n+  std::reference_wrapper<int (test_type::*)()const>* pr4b(0);\n+  verify_return_type((*pr4b)(null_ttc), int());\n   std::reference_wrapper<functor2>* pr5b(0);\n \n   // libstdc++/24803"}, {"sha": "bd9aeb2c40b3d7685b683a2d93384fffd7c2fa7b", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/invoke-2.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke-2.cc?ref=be7f782278465ae177c717f3b898906201c2471c", "patch": "@@ -0,0 +1,47 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile}\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.4 function object return types [func.ret]\n+#include <functional>\n+\n+struct X\n+{\n+    int f(int) { return 0; }\n+    int i;\n+};\n+\n+void test01()\n+{\n+  typedef int (X::*mfp)(int);\n+  typedef int X::*mp;\n+  mfp m = &X::f;\n+  mp m2 = &X::i;\n+  X x = { };\n+  std::ref(m)(x, 1);\n+  std::ref(m)(&x, 1);\n+  int& i1 = std::ref(m2)(x);\n+  int& i2 = std::ref(m2)(&x);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "7b694c76432e9c0e11a59987ee6633c448f5f9fa", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/invoke.cc", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke.cc?ref=be7f782278465ae177c717f3b898906201c2471c", "patch": "@@ -1,6 +1,6 @@\n // { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -36,6 +36,7 @@ struct X\n   int foo_c(float x)  const          { return truncate_float(x); }\n   int foo_v(float x)  volatile       { return truncate_float(x); }\n   int foo_cv(float x) const volatile { return truncate_float(x); }\n+  int foo_varargs(float x, ...)      { return truncate_float(x); }\n \n   int operator()(float x)\n   {\n@@ -69,6 +70,13 @@ void test01()\n \n   ::get_seventeen get_sev;\n   ::X x;\n+  ::X* xp = &x;\n+  int (::X::* p_foo)(float) = &::X::foo;\n+  int (::X::* p_foo_c)(float) const = &::X::foo_c;\n+  int (::X::* p_foo_v)(float) volatile = &::X::foo_v;\n+  int (::X::* p_foo_cv)(float) const volatile = &::X::foo_cv;\n+  int (::X::* p_foo_varargs)(float, ...) = &::X::foo_varargs;\n+  int ::X::* p_bar = &::X::bar;\n \n   const float pi = 3.14;\n \n@@ -77,8 +85,26 @@ void test01()\n   VERIFY(ref(seventeen)() == 17);\n \n   // Function pointers\n-  VERIFY(cref(&truncate_float)(pi) == 3);\n-  VERIFY(cref(&seventeen)() == 17);\n+  VERIFY(cref(truncate_float)(pi) == 3);\n+  VERIFY(cref(seventeen)() == 17);\n+\n+  // Member function pointers\n+  VERIFY(ref(p_foo)(x, pi) == 3);\n+  VERIFY(ref(p_foo)(xp, pi) == 3);\n+  VERIFY(ref(p_foo_c)(x, pi) == 3);\n+  VERIFY(ref(p_foo_c)(xp, pi) == 3);\n+  VERIFY(ref(p_foo_v)(x, pi) == 3);\n+  VERIFY(ref(p_foo_v)(xp, pi) == 3);\n+  VERIFY(ref(p_foo_cv)(x, pi) == 3);\n+  VERIFY(ref(p_foo_cv)(xp, pi) == 3);\n+  // VERIFY(ref(p_foo_varargs)(x, pi) == 3);\n+  // VERIFY(ref(p_foo_varargs)(xp, pi, 1, 1) == 3);\n+  // VERIFY(ref(p_foo_varargs)(x, pi, 1, 1) == 3);\n+  // VERIFY(ref(p_foo_varargs)(xp, pi) == 3);\n+\n+  // Member data pointers\n+  VERIFY(ref(p_bar)(x) == 17);\n+  VERIFY(ref(p_bar)(xp) == 17);\n \n   // Function objects\n   VERIFY(ref(get_sev)() == 17);"}, {"sha": "947a9b02f1e986d597a15f0c974df5a0030ce78b", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/ref_neg.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Fref_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Fref_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Fref_neg.cc?ref=be7f782278465ae177c717f3b898906201c2471c", "patch": "@@ -0,0 +1,44 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.8.3 Class template reference_wrapper\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <functional>\n+\n+struct X { };\n+X rval();\n+X&& rvalref();\n+\n+void test01()\n+{\n+  std::ref(1);          // { dg-error \"deleted\" }\n+  std::cref(1);         // { dg-error \"deleted\" }\n+  std::ref( int() );    // { dg-error \"deleted\" }\n+  std::cref( int() );   // { dg-error \"deleted\" }\n+  std::ref(rval());     // { dg-error \"deleted\" }\n+  std::cref(rvalref()); // { dg-error \"deleted\" }\n+}\n+\n+int main()\n+{\n+  test02();\n+}\n+\n+// { dg-excess-errors \"\" }"}, {"sha": "2fea52eed06a31e0e1512d49c7bb10ac88db8648", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/typedefs-3.cc", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs-3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs-3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs-3.cc?ref=be7f782278465ae177c717f3b898906201c2471c", "patch": "@@ -0,0 +1,148 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+#include <type_traits>\n+\n+struct S { };\n+\n+struct S0\n+{\n+  typedef int argument_type;\n+};\n+\n+struct S1\n+{\n+  typedef float first_argument_type;\n+};\n+\n+struct S2\n+{\n+  typedef char second_argument_type;\n+};\n+\n+struct S01 : S0, S1 { };\n+struct S02 : S0, S2 { };\n+struct S12 : S1, S2 { };\n+\n+struct S012 : S0, S1, S2 { };\n+\n+using std::__sfinae_types;\n+using std::integral_constant;\n+using std::remove_cv;\n+\n+_GLIBCXX_HAS_NESTED_TYPE(argument_type)\n+_GLIBCXX_HAS_NESTED_TYPE(first_argument_type)\n+_GLIBCXX_HAS_NESTED_TYPE(second_argument_type)\n+\n+template<typename T>\n+  struct has_arg_type : __has_argument_type<T>\n+  { };\n+\n+template<typename T>\n+  struct has_1st_arg_type : __has_first_argument_type<T>\n+  { };\n+\n+template<typename T>\n+  struct has_2nd_arg_type : __has_second_argument_type<T>\n+  { };\n+\n+template<typename T, bool = has_arg_type<T>::value>\n+struct test_arg_type\n+{\n+  static_assert( !has_arg_type<std::reference_wrapper<T>>::value,\n+      \"reference_wrapper has no nested argument_type\");\n+};\n+\n+template<typename T>\n+struct test_arg_type<T, true>\n+{\n+  typedef std::reference_wrapper<T> ref;\n+\n+  static_assert( has_arg_type<ref>::value,\n+      \"reference_wrapper has nested argument_type\");\n+\n+  static_assert(\n+      std::is_same< typename T::argument_type,\n+                    typename ref::argument_type >::value,\n+      \"reference_wrapper has the correct argument_type\");\n+};\n+\n+template<typename T,\n+         bool = has_1st_arg_type<T>::value && has_2nd_arg_type<T>::value>\n+struct test_1st_2nd_arg_types\n+{\n+  typedef std::reference_wrapper<T> ref;\n+\n+  static_assert( !has_1st_arg_type<ref>::value,\n+      \"reference_wrapper has no nested first_argument_type\");\n+\n+  static_assert( !has_2nd_arg_type<ref>::value,\n+      \"reference_wrapper has no nested second_argument_type\");\n+};\n+\n+template<typename T>\n+struct test_1st_2nd_arg_types<T, true>\n+{\n+  typedef std::reference_wrapper<T> ref;\n+\n+  static_assert( has_1st_arg_type<ref>::value,\n+      \"reference_wrapper has nested first_argument_type\");\n+\n+  static_assert( has_2nd_arg_type<ref>::value,\n+      \"reference_wrapper has nested second_argument_type\");\n+\n+  static_assert(\n+      std::is_same< typename T::first_argument_type,\n+                    typename ref::first_argument_type>::value,\n+      \"reference_wrapper has correct first_argument_type\");\n+\n+  static_assert(\n+      std::is_same< typename T::second_argument_type,\n+                    typename ref::second_argument_type>::value,\n+      \"reference_wrapper has correct second_argument_type\");\n+};\n+\n+\n+template<typename T>\n+  void test()\n+  {\n+    test_arg_type<T> t;\n+    test_arg_type<const T> tc;\n+    test_arg_type<volatile T> tv;\n+    test_arg_type<const volatile T> tcv;\n+    test_1st_2nd_arg_types<T> t12;\n+    test_1st_2nd_arg_types<const T> t12c;\n+    test_1st_2nd_arg_types<volatile T> t12v;\n+    test_1st_2nd_arg_types<const volatile T> t12cv;\n+  }\n+\n+int main()\n+{\n+  test<S>();\n+  test<S0>();\n+  test<S1>();\n+  test<S2>();\n+  test<S01>();\n+  test<S02>();\n+  test<S12>();\n+  test<S012>();\n+}\n+"}, {"sha": "815700f1c64b0acf447e4728af3d40fd80d799d7", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/typedefs.cc", "status": "modified", "additions": 10, "deletions": 38, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7f782278465ae177c717f3b898906201c2471c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs.cc?ref=be7f782278465ae177c717f3b898906201c2471c", "patch": "@@ -1,6 +1,7 @@\n+// { dg-do compile }\n // { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -19,10 +20,6 @@\n \n #include <functional>\n #include <type_traits>\n-#include <testsuite_hooks.h>\n-#include <testsuite_tr1.h>\n-\n-using namespace __gnu_test;\n \n struct X {};\n \n@@ -41,43 +38,18 @@ struct derives_unary_binary\n \n void test01()\n {\n-  bool test __attribute__((unused)) = true;\n-\n   using std::reference_wrapper;\n   using std::is_same;\n-  using std::is_convertible;\n-  using std::unary_function;\n-  using std::binary_function;\n \n   // Check result_type typedef\n-  VERIFY((is_same<reference_wrapper<int_result_type>::result_type, int>::value));\n-  VERIFY((is_same<reference_wrapper<derives_unary>::result_type, int>::value));\n-  VERIFY((is_same<reference_wrapper<derives_binary>::result_type, int>::value));\n-  VERIFY((is_same<reference_wrapper<derives_unary_binary>::result_type, int>::value));\n-  VERIFY((is_same<reference_wrapper<int(void)>::result_type, int>::value));\n-  VERIFY((is_same<reference_wrapper<int(*)(void)>::result_type, int>::value));\n-  VERIFY((is_same<reference_wrapper<int (::X::*)()>::result_type, int>::value));\n-  VERIFY((is_same<reference_wrapper<int (::X::*)(float)>::result_type, int>::value));\n-\n-  // Check derivation from unary_function\n-  VERIFY((is_convertible<reference_wrapper<derives_unary>*, unary_function<int, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<derives_unary_binary>*, unary_function<int, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int(int)>*, unary_function<int, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int(*)(int)>*, unary_function<int, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int (::X::*)()>*, unary_function< ::X*, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int (::X::*)() const>*, unary_function<const ::X*, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int (::X::*)() volatile>*, unary_function<volatile ::X*, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int (::X::*)() const volatile>*, unary_function<const volatile ::X*, int>*>::value));\n-\n-  // Check derivation from binary_function\n-  VERIFY((is_convertible<reference_wrapper<derives_binary>*, binary_function<int, float, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<derives_unary_binary>*, binary_function<int, float, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int(int, float)>*, binary_function<int, float, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int(*)(int, float)>*, binary_function<int, float, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int (::X::*)(float)>*, binary_function< ::X*, float, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int (::X::*)(float) const>*, binary_function<const ::X*, float, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int (::X::*)(float) volatile>*, binary_function<volatile ::X*, float, int>*>::value));\n-  VERIFY((is_convertible<reference_wrapper<int (::X::*)(float) const volatile>*, binary_function<const volatile ::X*, float, int>*>::value));\n+  static_assert( is_same<reference_wrapper<int_result_type>::result_type, int>::value, \"has result_type\" );\n+  static_assert( is_same<reference_wrapper<derives_unary>::result_type, int>::value, \"has result_type\" );\n+  static_assert( is_same<reference_wrapper<derives_binary>::result_type, int>::value, \"has result_type\" );\n+  static_assert( is_same<reference_wrapper<derives_unary_binary>::result_type, int>::value, \"has result_type\" );\n+  static_assert( is_same<reference_wrapper<int(void)>::result_type, int>::value, \"has result_type\" );\n+  static_assert( is_same<reference_wrapper<int(*)(void)>::result_type, int>::value, \"has result_type\" );\n+  static_assert( is_same<reference_wrapper<int (::X::*)()>::result_type, int>::value, \"has result_type\" );\n+  static_assert( is_same<reference_wrapper<int (::X::*)(float)>::result_type, int>::value, \"has result_type\" );\n }\n \n int main()"}]}