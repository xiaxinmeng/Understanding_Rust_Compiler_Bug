{"sha": "430c6cebe1f5acbbc209c12717cfe085c759f73e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMwYzZjZWJlMWY1YWNiYmMyMDljMTI3MTdjZmUwODVjNzU5ZjczZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-11-20T21:10:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-11-20T21:10:46Z"}, "message": "cgraph.c (ld_plugin_symbol_resolution_names): New.\n\n\n\t* cgraph.c (ld_plugin_symbol_resolution_names): New.\n\t(dump_cgraph_node): Dump resolution.\n\t* cgraph.h (ld_plugin_symbol_resolution_names): Declare.\n\t(cgraph_comdat_can_be_unshared_p): Dclare.\n\t* lto-streamer-out.c (produce_symtab): Use\n\tcgraph_comdat_can_be_unshared_p.\n\t* ipa.c (cgraph_address_taken_from_non_vtable_p): New function.\n\t(cgraph_comdat_can_be_unshared_p): New function based on logic\n\tin cgraph_externally_visible_p.\n\t(cgraph_externally_visible_p): Use it.\n\t(varpool_externally_visible_p): Virtual tables can be unshared.\n\t* varpool.c (dump_varpool_node): Dump resolution.\n\nFrom-SVN: r166985", "tree": {"sha": "840116a4decf1497419fc4f57051a92015fa008f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/840116a4decf1497419fc4f57051a92015fa008f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/430c6cebe1f5acbbc209c12717cfe085c759f73e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/430c6cebe1f5acbbc209c12717cfe085c759f73e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/430c6cebe1f5acbbc209c12717cfe085c759f73e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/430c6cebe1f5acbbc209c12717cfe085c759f73e/comments", "author": null, "committer": null, "parents": [{"sha": "671769c38a2a4e4f76817307be3eb871f1acc399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/671769c38a2a4e4f76817307be3eb871f1acc399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/671769c38a2a4e4f76817307be3eb871f1acc399"}], "stats": {"total": 112, "additions": 89, "deletions": 23}, "files": [{"sha": "99e4ee3eac63be8a19a72f6cb523daf941a8d9ec", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430c6cebe1f5acbbc209c12717cfe085c759f73e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430c6cebe1f5acbbc209c12717cfe085c759f73e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=430c6cebe1f5acbbc209c12717cfe085c759f73e", "patch": "@@ -56,6 +56,7 @@ enum availability\n struct lto_file_decl_data;\n \n extern const char * const cgraph_availability_names[];\n+extern const char * const ld_plugin_symbol_resolution_names[];\n \n /* Function inlining information.  */\n \n@@ -695,6 +696,7 @@ void varpool_node_set_remove (varpool_node_set, struct varpool_node *);\n void dump_varpool_node_set (FILE *, varpool_node_set);\n void debug_varpool_node_set (varpool_node_set);\n void ipa_discover_readonly_nonaddressable_vars (void);\n+bool cgraph_comdat_can_be_unshared_p (struct cgraph_node *);\n \n /* In predict.c  */\n bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);"}, {"sha": "28e6872ef7ffe2a47e1ee88e92e8b1c90799e5b4", "filename": "gcc/ipa.c", "status": "modified", "additions": 69, "deletions": 21, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430c6cebe1f5acbbc209c12717cfe085c759f73e/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430c6cebe1f5acbbc209c12717cfe085c759f73e/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=430c6cebe1f5acbbc209c12717cfe085c759f73e", "patch": "@@ -588,6 +588,56 @@ ipa_discover_readonly_nonaddressable_vars (void)\n     fprintf (dump_file, \"\\n\");\n }\n \n+/* Return true when there is a reference to node and it is not vtable.  */\n+static bool\n+cgraph_address_taken_from_non_vtable_p (struct cgraph_node *node)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+    {\n+      struct varpool_node *node;\n+      if (ref->refered_type == IPA_REF_CGRAPH)\n+\treturn true;\n+      node = ipa_ref_varpool_node (ref);\n+      if (!DECL_VIRTUAL_P (node->decl))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* COMDAT functions must be shared only if they have address taken,\n+   otherwise we can produce our own private implementation with\n+   -fwhole-program.  \n+   Return true when turning COMDAT functoin static can not lead to wrong\n+   code when the resulting object links with a library defining same COMDAT.\n+\n+   Virtual functions do have their addresses taken from the vtables,\n+   but in C++ there is no way to compare their addresses for equality.  */\n+\n+bool\n+cgraph_comdat_can_be_unshared_p (struct cgraph_node *node)\n+{\n+  if ((cgraph_address_taken_from_non_vtable_p (node)\n+       && !DECL_VIRTUAL_P (node->decl))\n+      || !node->analyzed)\n+    return false;\n+  if (node->same_comdat_group)\n+    {\n+      struct cgraph_node *next;\n+\n+      /* If more than one function is in the same COMDAT group, it must\n+         be shared even if just one function in the comdat group has\n+         address taken.  */\n+      for (next = node->same_comdat_group;\n+\t   next != node; next = next->same_comdat_group)\n+\tif (cgraph_address_taken_from_non_vtable_p (node)\n+\t    && !DECL_VIRTUAL_P (next->decl))\n+\t  return false;\n+    }\n+  return true;\n+}\n+\n /* Return true when function NODE should be considered externally visible.  */\n \n static bool\n@@ -613,6 +663,15 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool\n   if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (node->decl)))\n     return true;\n \n+  /* When doing LTO or whole program, we can bring COMDAT functoins static.\n+     This improves code quality and we know we will duplicate them at most twice\n+     (in the case that we are not using plugin and link with object file\n+      implementing same COMDAT)  */\n+  if ((in_lto_p || whole_program)\n+      && DECL_COMDAT (node->decl)\n+      && cgraph_comdat_can_be_unshared_p (node))\n+    return false;\n+\n   /* See if we have linker information about symbol not being used or\n      if we need to make guess based on the declaration.\n \n@@ -635,27 +694,6 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool\n     ;\n   else if (!whole_program)\n     return true;\n-  /* COMDAT functions must be shared only if they have address taken,\n-     otherwise we can produce our own private implementation with\n-     -fwhole-program.  */\n-  else if (DECL_COMDAT (node->decl))\n-    {\n-      if (node->address_taken || !node->analyzed)\n-\treturn true;\n-      if (node->same_comdat_group)\n-\t{\n-\t  struct cgraph_node *next;\n-\n-\t  /* If more than one function is in the same COMDAT group, it must\n-\t     be shared even if just one function in the comdat group has\n-\t     address taken.  */\n-\t  for (next = node->same_comdat_group;\n-\t       next != node;\n-\t       next = next->same_comdat_group)\n-\t    if (next->address_taken || !next->analyzed)\n-\t      return true;\n-\t}\n-    }\n \n   if (MAIN_NAME_P (DECL_NAME (node->decl)))\n     return true;\n@@ -701,6 +739,16 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n   if (!alias && vnode->resolution == LDPR_PREVAILING_DEF_IRONLY)\n     return false;\n \n+  /* As a special case, the COMDAT virutal tables can be unshared.\n+     In LTO mode turn vtables into static variables.  The variable is readonly,\n+     so this does not enable more optimization, but referring static var\n+     is faster for dynamic linking.  Also this match logic hidding vtables\n+     from LTO symbol tables.  */\n+  if ((in_lto_p || flag_whole_program)\n+      && !vnode->force_output\n+      && DECL_COMDAT (vnode->decl) && DECL_VIRTUAL_P (vnode->decl))\n+    return false;\n+\n   /* When doing link time optimizations, hidden symbols become local.  */\n   if (in_lto_p\n       && (DECL_VISIBILITY (vnode->decl) == VISIBILITY_HIDDEN"}, {"sha": "b6414b69ac21d10c8be30901d5e757d14d4f37c7", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430c6cebe1f5acbbc209c12717cfe085c759f73e/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430c6cebe1f5acbbc209c12717cfe085c759f73e/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=430c6cebe1f5acbbc209c12717cfe085c759f73e", "patch": "@@ -2492,7 +2492,7 @@ produce_symtab (struct output_block *ob,\n       if (DECL_EXTERNAL (node->decl))\n \tcontinue;\n       if (DECL_COMDAT (node->decl)\n-\t  && cgraph_can_remove_if_no_direct_calls_p (node))\n+\t  && cgraph_comdat_can_be_unshared_p (node))\n \tcontinue;\n       if (node->alias || node->global.inlined_to)\n \tcontinue;\n@@ -2506,7 +2506,7 @@ produce_symtab (struct output_block *ob,\n       if (!DECL_EXTERNAL (node->decl))\n \tcontinue;\n       if (DECL_COMDAT (node->decl)\n-\t  && cgraph_can_remove_if_no_direct_calls_p (node))\n+\t  && cgraph_comdat_can_be_unshared_p (node))\n \tcontinue;\n       if (node->alias || node->global.inlined_to)\n \tcontinue;\n@@ -2521,6 +2521,14 @@ produce_symtab (struct output_block *ob,\n       vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n       if (DECL_EXTERNAL (vnode->decl))\n \tcontinue;\n+      /* COMDAT virtual tables can be unshared.  Do not declare them\n+\t in the LTO symbol table to prevent linker from forcing them\n+\t into the output. */\n+      if (DECL_COMDAT (vnode->decl)\n+\t  && !vnode->force_output\n+\t  && vnode->finalized \n+\t  && DECL_VIRTUAL_P (vnode->decl))\n+\tcontinue;\n       if (vnode->alias)\n \tcontinue;\n       write_symbol (cache, &stream, vnode->decl, seen, false);\n@@ -2532,6 +2540,11 @@ produce_symtab (struct output_block *ob,\n       vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n       if (!DECL_EXTERNAL (vnode->decl))\n \tcontinue;\n+      if (DECL_COMDAT (vnode->decl)\n+\t  && !vnode->force_output\n+\t  && vnode->finalized \n+\t  && DECL_VIRTUAL_P (vnode->decl))\n+\tcontinue;\n       if (vnode->alias)\n \tcontinue;\n       write_symbol (cache, &stream, vnode->decl, seen, false);"}, {"sha": "d266ce9a8cf1fb10bbbb57e055463aada15e90c1", "filename": "gcc/varpool.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430c6cebe1f5acbbc209c12717cfe085c759f73e/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430c6cebe1f5acbbc209c12717cfe085c759f73e/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=430c6cebe1f5acbbc209c12717cfe085c759f73e", "patch": "@@ -241,6 +241,9 @@ dump_varpool_node (FILE *f, struct varpool_node *node)\n     fprintf (f, \" output\");\n   if (node->externally_visible)\n     fprintf (f, \" externally_visible\");\n+  if (node->resolution != LDPR_UNKNOWN)\n+    fprintf (f, \" %s\",\n+ \t     ld_plugin_symbol_resolution_names[(int)node->resolution]);\n   if (node->in_other_partition)\n     fprintf (f, \" in_other_partition\");\n   else if (node->used_from_other_partition)"}]}