{"sha": "152f968e86d14bbebe3e69286dd7a9257e3ca174", "node_id": "C_kwDOANBUbNoAKDE1MmY5NjhlODZkMTRiYmViZTNlNjkyODZkZDdhOTI1N2UzY2ExNzQ", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2022-07-29T22:54:19Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-06T07:14:20Z"}, "message": "[Ada] ICE handling discriminant-dependent index constraint for access component\n\nThe compiler would fail with an internal error in some cases involving\na discriminated record type that provides a discriminant-dependent index\nconstraint for the subtype of a component of an access-to-array type when a\ndereference of that component of some object is mentioned in a pre- or\npostcondition expression.\n\ngcc/ada/\n\n\t* sem_ch4.adb\n\t(Analyze_Selected_Component): Define new Boolean-valued function,\n\tConstraint_Has_Unprefixed_Discriminant_Reference, which takes a\n\tsubtype that is subject to a discriminant-dependent constraint and\n\treturns True if any of the constraint values are unprefixed\n\tdiscriminant names. Usually, the Etype of a selected component\n\tnode is set to Etype of the component. However, in the case of an\n\taccess-to-array component for which this predicate returns True,\n\twe instead use the base type of the Etype of the component.\n\tNormally such problematic discriminant references are addressed by\n\tcalling Build_Actual_Subtype_Of_Component, but that doesn't work\n\tif Full_Analyze is False.", "tree": {"sha": "2a71f82cd9e396d197c925a3e6a10ce38bd20da1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a71f82cd9e396d197c925a3e6a10ce38bd20da1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/152f968e86d14bbebe3e69286dd7a9257e3ca174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152f968e86d14bbebe3e69286dd7a9257e3ca174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/152f968e86d14bbebe3e69286dd7a9257e3ca174", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152f968e86d14bbebe3e69286dd7a9257e3ca174/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec95a21b5246af342fd91c9fe99022c1f2e9d7bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec95a21b5246af342fd91c9fe99022c1f2e9d7bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec95a21b5246af342fd91c9fe99022c1f2e9d7bf"}], "stats": {"total": 85, "additions": 85, "deletions": 0}, "files": [{"sha": "b63b5c862c62ea64141c746db592a5c5967940a4", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f968e86d14bbebe3e69286dd7a9257e3ca174/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f968e86d14bbebe3e69286dd7a9257e3ca174/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=152f968e86d14bbebe3e69286dd7a9257e3ca174", "patch": "@@ -4814,6 +4814,14 @@ package body Sem_Ch4 is\n       Is_Single_Concurrent_Object : Boolean;\n       --  Set True if the prefix is a single task or a single protected object\n \n+      function Constraint_Has_Unprefixed_Discriminant_Reference\n+        (Typ : Entity_Id) return Boolean;\n+      --  Given a subtype that is subject to a discriminant-dependent\n+      --  constraint, returns True if any of the values of the constraint\n+      --  (i.e., any of the index values for an index constraint, any of\n+      --  the discriminant values for a discriminant constraint)\n+      --  are unprefixed discriminant names.\n+\n       procedure Find_Component_In_Instance (Rec : Entity_Id);\n       --  In an instance, a component of a private extension may not be visible\n       --  while it was visible in the generic. Search candidate scope for a\n@@ -4842,6 +4850,56 @@ package body Sem_Ch4 is\n       --  _Procedure, and collect all its interpretations (since it may be an\n       --  overloaded interface primitive); otherwise return False.\n \n+      ------------------------------------------------------\n+      -- Constraint_Has_Unprefixed_Discriminant_Reference --\n+      ------------------------------------------------------\n+\n+      function Constraint_Has_Unprefixed_Discriminant_Reference\n+        (Typ : Entity_Id) return Boolean\n+      is\n+\n+         function Is_Discriminant_Name (N : Node_Id) return Boolean is\n+           ((Nkind (N) = N_Identifier)\n+              and then (Ekind (Entity (N)) = E_Discriminant));\n+      begin\n+         if Is_Array_Type (Typ) then\n+            declare\n+               Index : Node_Id := First_Index (Typ);\n+               Rng   : Node_Id;\n+            begin\n+               while Present (Index) loop\n+                  Rng := Index;\n+                  if Nkind (Rng) = N_Subtype_Indication then\n+                     Rng := Range_Expression (Constraint (Rng));\n+                  end if;\n+\n+                  if Nkind (Rng) = N_Range then\n+                     if Is_Discriminant_Name (Low_Bound (Rng))\n+                       or else Is_Discriminant_Name (High_Bound (Rng))\n+                     then\n+                        return True;\n+                     end if;\n+                  end if;\n+\n+                  Next_Index (Index);\n+               end loop;\n+            end;\n+         else\n+            declare\n+               Elmt : Elmt_Id := First_Elmt (Discriminant_Constraint (Typ));\n+            begin\n+               while Present (Elmt) loop\n+                  if Is_Discriminant_Name (Node (Elmt)) then\n+                     return True;\n+                  end if;\n+                  Next_Elmt (Elmt);\n+               end loop;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Constraint_Has_Unprefixed_Discriminant_Reference;\n+\n       --------------------------------\n       -- Find_Component_In_Instance --\n       --------------------------------\n@@ -5289,6 +5347,33 @@ package body Sem_Ch4 is\n                      end;\n                   end if;\n \n+               --  If Etype (Comp) is an access type whose designated subtype\n+               --  is constrained by an unprefixed discriminant value,\n+               --  then ideally we would build a new subtype with an\n+               --  appropriately prefixed discriminant value and use that\n+               --  instead, as is done in Build_Actual_Subtype_Of_Component.\n+               --  That turns out to be difficult in this context (with\n+               --  Full_Analysis = False, we could be processing a selected\n+               --  component that occurs in a Postcondition pragma;\n+               --  PPC pragmas are odd because they can contain references\n+               --  to formal parameters that occur outside the subprogram).\n+               --  So instead we punt on building a new subtype and we\n+               --  use the base type instead. This might introduce\n+               --  correctness problems if N were the target of an\n+               --  assignment (because a required check might be omitted);\n+               --  fortunately, that's impossible because a reference to the\n+               --  current instance of a type does not denote a variable view\n+               --  when the reference occurs within an aspect_specification.\n+               --  GNAT's Precondition and Postcondition pragmas follow the\n+               --  same rules as a Pre or Post aspect_specification.\n+\n+               elsif Has_Discriminant_Dependent_Constraint (Comp)\n+                 and then Ekind (Etype (Comp)) = E_Access_Subtype\n+                 and then Constraint_Has_Unprefixed_Discriminant_Reference\n+                            (Designated_Type (Etype (Comp)))\n+               then\n+                  Set_Etype (N, Base_Type (Etype (Comp)));\n+\n                --  If Full_Analysis not enabled, just set the Etype\n \n                else"}]}