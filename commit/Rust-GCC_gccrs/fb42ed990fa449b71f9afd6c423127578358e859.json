{"sha": "fb42ed990fa449b71f9afd6c423127578358e859", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI0MmVkOTkwZmE0NDliNzFmOWFmZDZjNDIzMTI3NTc4MzU4ZTg1OQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-05-18T11:07:20Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-05-18T11:07:20Z"}, "message": "function: Factor out make_*logue_seq\n\nMake new functions make_split_prologue_seq, make_prologue_seq, and\nmake_epilogue_seq.\n\n\n\t* function.c (make_split_prologue_seq, make_prologue_seq,\n\tmake_epilogue_seq): New functions, factored out from...\n\t(thread_prologue_and_epilogue_insns): Here.\n\nFrom-SVN: r236373", "tree": {"sha": "7f29f422924d83a8d9eba64f0e6bd57907edd544", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f29f422924d83a8d9eba64f0e6bd57907edd544"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb42ed990fa449b71f9afd6c423127578358e859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb42ed990fa449b71f9afd6c423127578358e859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb42ed990fa449b71f9afd6c423127578358e859", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb42ed990fa449b71f9afd6c423127578358e859/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "63d0f6ab560336d34b0a8f9b9b111c4a17e8737f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d0f6ab560336d34b0a8f9b9b111c4a17e8737f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63d0f6ab560336d34b0a8f9b9b111c4a17e8737f"}], "stats": {"total": 168, "additions": 99, "deletions": 69}, "files": [{"sha": "a472fd8ddb0f98e707776ee4704ba7bb91b2e184", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb42ed990fa449b71f9afd6c423127578358e859/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb42ed990fa449b71f9afd6c423127578358e859/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb42ed990fa449b71f9afd6c423127578358e859", "patch": "@@ -1,3 +1,9 @@\n+2016-05-18  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* function.c (make_split_prologue_seq, make_prologue_seq,\n+\tmake_epilogue_seq): New functions, factored out from...\n+\t(thread_prologue_and_epilogue_insns): Here.\n+\n 2016-05-18  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* function.c (rest_of_handle_thread_prologue_and_epilogue): Call"}, {"sha": "1c56253c30999ca1756c0be54f785fcae58ffef0", "filename": "gcc/function.c", "status": "modified", "additions": 93, "deletions": 69, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb42ed990fa449b71f9afd6c423127578358e859/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb42ed990fa449b71f9afd6c423127578358e859/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fb42ed990fa449b71f9afd6c423127578358e859", "patch": "@@ -5768,6 +5768,91 @@ set_return_jump_label (rtx_insn *returnjump)\n     JUMP_LABEL (returnjump) = ret_rtx;\n }\n \n+/* Return a sequence to be used as the split prologue for the current\n+   function, or NULL.  */\n+\n+static rtx_insn *\n+make_split_prologue_seq (void)\n+{\n+  if (!flag_split_stack\n+      || lookup_attribute (\"no_split_stack\", DECL_ATTRIBUTES (cfun->decl)))\n+    return NULL;\n+\n+  start_sequence ();\n+  emit_insn (targetm.gen_split_stack_prologue ());\n+  rtx_insn *seq = get_insns ();\n+  end_sequence ();\n+\n+  record_insns (seq, NULL, &prologue_insn_hash);\n+  set_insn_locations (seq, prologue_location);\n+\n+  return seq;\n+}\n+\n+/* Return a sequence to be used as the prologue for the current function,\n+   or NULL.  */\n+\n+static rtx_insn *\n+make_prologue_seq (void)\n+{\n+  if (!targetm.have_prologue ())\n+    return NULL;\n+\n+  start_sequence ();\n+  rtx_insn *seq = targetm.gen_prologue ();\n+  emit_insn (seq);\n+\n+  /* Insert an explicit USE for the frame pointer\n+     if the profiling is on and the frame pointer is required.  */\n+  if (crtl->profile && frame_pointer_needed)\n+    emit_use (hard_frame_pointer_rtx);\n+\n+  /* Retain a map of the prologue insns.  */\n+  record_insns (seq, NULL, &prologue_insn_hash);\n+  emit_note (NOTE_INSN_PROLOGUE_END);\n+\n+  /* Ensure that instructions are not moved into the prologue when\n+     profiling is on.  The call to the profiling routine can be\n+     emitted within the live range of a call-clobbered register.  */\n+  if (!targetm.profile_before_prologue () && crtl->profile)\n+    emit_insn (gen_blockage ());\n+\n+  seq = get_insns ();\n+  end_sequence ();\n+  set_insn_locations (seq, prologue_location);\n+\n+  return seq;\n+}\n+\n+/* Return a sequence to be used as the epilogue for the current function,\n+   or NULL.  */\n+\n+static rtx_insn *\n+make_epilogue_seq (rtx_insn **epilogue_end)\n+{\n+  if (!targetm.have_epilogue ())\n+    return NULL;\n+\n+  start_sequence ();\n+  *epilogue_end = emit_note (NOTE_INSN_EPILOGUE_BEG);\n+  rtx_insn *seq = targetm.gen_epilogue ();\n+  if (seq)\n+    emit_jump_insn (seq);\n+\n+  /* Retain a map of the epilogue insns.  */\n+  record_insns (seq, NULL, &epilogue_insn_hash);\n+  set_insn_locations (seq, epilogue_location);\n+\n+  seq = get_insns ();\n+  rtx_insn *returnjump = get_last_insn ();\n+  end_sequence ();\n+\n+  if (JUMP_P (returnjump))\n+    set_return_jump_label (returnjump);\n+\n+  return seq;\n+}\n+\n \n /* Generate the prologue and epilogue RTL if the machine supports it.  Thread\n    this into place with notes indicating where the prologue ends and where\n@@ -5822,9 +5907,7 @@ thread_prologue_and_epilogue_insns (void)\n {\n   bool inserted;\n   bitmap_head bb_flags;\n-  rtx_insn *returnjump;\n   rtx_insn *epilogue_end ATTRIBUTE_UNUSED;\n-  rtx_insn *prologue_seq ATTRIBUTE_UNUSED, *split_prologue_seq ATTRIBUTE_UNUSED;\n   edge e, entry_edge, orig_entry_edge, exit_fallthru_edge;\n   edge_iterator ei;\n \n@@ -5834,7 +5917,6 @@ thread_prologue_and_epilogue_insns (void)\n \n   inserted = false;\n   epilogue_end = NULL;\n-  returnjump = NULL;\n \n   /* Can't deal with multiple successors of the entry block at the\n      moment.  Function should always have at least one entry\n@@ -5843,46 +5925,9 @@ thread_prologue_and_epilogue_insns (void)\n   entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   orig_entry_edge = entry_edge;\n \n-  split_prologue_seq = NULL;\n-  if (flag_split_stack\n-      && (lookup_attribute (\"no_split_stack\", DECL_ATTRIBUTES (cfun->decl))\n-\t  == NULL))\n-    {\n-      start_sequence ();\n-      emit_insn (targetm.gen_split_stack_prologue ());\n-      split_prologue_seq = get_insns ();\n-      end_sequence ();\n-\n-      record_insns (split_prologue_seq, NULL, &prologue_insn_hash);\n-      set_insn_locations (split_prologue_seq, prologue_location);\n-    }\n-\n-  prologue_seq = NULL;\n-  if (targetm.have_prologue ())\n-    {\n-      start_sequence ();\n-      rtx_insn *seq = targetm.gen_prologue ();\n-      emit_insn (seq);\n-\n-      /* Insert an explicit USE for the frame pointer\n-         if the profiling is on and the frame pointer is required.  */\n-      if (crtl->profile && frame_pointer_needed)\n-\temit_use (hard_frame_pointer_rtx);\n-\n-      /* Retain a map of the prologue insns.  */\n-      record_insns (seq, NULL, &prologue_insn_hash);\n-      emit_note (NOTE_INSN_PROLOGUE_END);\n-\n-      /* Ensure that instructions are not moved into the prologue when\n-\t profiling is on.  The call to the profiling routine can be\n-\t emitted within the live range of a call-clobbered register.  */\n-      if (!targetm.profile_before_prologue () && crtl->profile)\n-        emit_insn (gen_blockage ());\n-\n-      prologue_seq = get_insns ();\n-      end_sequence ();\n-      set_insn_locations (prologue_seq, prologue_location);\n-    }\n+  rtx_insn *split_prologue_seq = make_split_prologue_seq ();\n+  rtx_insn *prologue_seq = make_prologue_seq ();\n+  rtx_insn *epilogue_seq = make_epilogue_seq (&epilogue_end);\n \n   bitmap_initialize (&bb_flags, &bitmap_default_obstack);\n \n@@ -5915,7 +5960,9 @@ thread_prologue_and_epilogue_insns (void)\n \n   exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n \n-  if (targetm.have_return () && exit_fallthru_edge == NULL)\n+  /* If nothing falls through into the exit block, we don't need an\n+     epilogue.  */\n+  if (exit_fallthru_edge == NULL)\n     goto epilogue_done;\n \n   /* A small fib -- epilogue is not yet completed, but we wish to re-use\n@@ -5947,33 +5994,10 @@ thread_prologue_and_epilogue_insns (void)\n       emit_note_after (NOTE_INSN_EPILOGUE_BEG, prev);\n     }\n \n-  /* If nothing falls through into the exit block, we don't need an\n-     epilogue.  */\n-\n-  if (exit_fallthru_edge == NULL)\n-    goto epilogue_done;\n-\n-  if (targetm.have_epilogue ())\n+  if (epilogue_seq)\n     {\n-      start_sequence ();\n-      epilogue_end = emit_note (NOTE_INSN_EPILOGUE_BEG);\n-      rtx_insn *seq = targetm.gen_epilogue ();\n-      if (seq)\n-\temit_jump_insn (seq);\n-\n-      /* Retain a map of the epilogue insns.  */\n-      record_insns (seq, NULL, &epilogue_insn_hash);\n-      set_insn_locations (seq, epilogue_location);\n-\n-      seq = get_insns ();\n-      returnjump = get_last_insn ();\n-      end_sequence ();\n-\n-      insert_insn_on_edge (seq, exit_fallthru_edge);\n+      insert_insn_on_edge (epilogue_seq, exit_fallthru_edge);\n       inserted = true;\n-\n-      if (JUMP_P (returnjump))\n-\tset_return_jump_label (returnjump);\n     }\n   else\n     {"}]}