{"sha": "96df3ff4bd3b0f2ce63f519955f20f7d93612929", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZkZjNmZjRiZDNiMGYyY2U2M2Y1MTk5NTVmMjBmN2Q5MzYxMjkyOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-07-04T10:09:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-07-04T10:09:04Z"}, "message": "[multiple changes]\n\n2016-07-04  Bob Duff  <duff@adacore.com>\n\n\t* xref_lib.adb (Parse_X_Filename, Parse_Identifier_Info): Ignore\n\tunknown files. Check that File_Nr is in the range of files we\n\tknow about. The previous code was checking the lower bound,\n\tbut not the upper bound.\n\n2016-07-04  Arnaud Charlet  <charlet@adacore.com>\n\n\t* tracebak.c: Minor reformatting.\n\n2016-07-04  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch12.adb, sem_ch12.ads Update calls to\n\tCreate_Instantiation_Source to use default argument.\n\t(Adjust_Inherited_Pragma_Sloc): New function to adjust sloc\n\tof inherited pragma.\n\t(Set_Copied_Sloc_For_Inherited_Pragma):\n\tNew function that wraps call to Create_Instantiation_Source for\n\tcopying an inherited pragma.\n\t(Set_Copied_Sloc_For_Inlined_Body): Update call to\n\tCreate_Instantiation_Source with new arguments.\n\t* sem_prag.adb (Build_Pragma_Check_Equivalent): In the case\n\tof inherited pragmas, use the generic machinery to get chained\n\tlocations for the pragma and its sub-expressions.\n\t* sinput-c.adb: Adapt to new type Source_File_Record.\n\t* sinput-l.adb, sinput-l.ads (Create_Instantiation_Source):\n\tAdd parameter Inherited_Pragma and make parameter Inlined_Body\n\toptional.\n\t* sinput.adb, sinput.ads (Comes_From_Inherited_Pragma): New\n\tfunction to return when a location comes from an inherited pragma.\n\t(Inherited_Pragma): New function to detect when a location comes\n\tfrom an inherited pragma.\n\t(Source_File_Record): New component Inherited_Pragma.\n\n2016-07-04  Yannick Moy  <moy@adacore.com>\n\n\t* sem_elab.adb: Register existence of quickfix for error message.\n\n2016-07-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Resolve_One_Call): In the context of a predicate\n\tfunction the formal and the actual in a call may have different\n\tviews of the same type, because of the delayed analysis of\n\tpredicates aspects. Extend the patch that handles this potential\n\tdiscrepancy to handle private and full views as well.\n\t* sem_ch8.adb (Find_Selected_Component): Refine predicate that\n\tproduces additional error when an illegal selected component\n\tlooks like a prefixed call whose first formal is untagged.\n\nFrom-SVN: r237963", "tree": {"sha": "9009e6f1cf9433a4d1de015b6f0b48fb40e0a7c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9009e6f1cf9433a4d1de015b6f0b48fb40e0a7c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96df3ff4bd3b0f2ce63f519955f20f7d93612929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96df3ff4bd3b0f2ce63f519955f20f7d93612929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96df3ff4bd3b0f2ce63f519955f20f7d93612929", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96df3ff4bd3b0f2ce63f519955f20f7d93612929/comments", "author": null, "committer": null, "parents": [{"sha": "015f33d73ec6634c9b96637fff73c49ac5f0ba9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015f33d73ec6634c9b96637fff73c49ac5f0ba9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/015f33d73ec6634c9b96637fff73c49ac5f0ba9f"}], "stats": {"total": 294, "additions": 238, "deletions": 56}, "files": [{"sha": "697352834dfdbdaeeef83a4365a092c7d048e278", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -1,3 +1,53 @@\n+2016-07-04  Bob Duff  <duff@adacore.com>\n+\n+\t* xref_lib.adb (Parse_X_Filename, Parse_Identifier_Info): Ignore\n+\tunknown files. Check that File_Nr is in the range of files we\n+\tknow about. The previous code was checking the lower bound,\n+\tbut not the upper bound.\n+\n+2016-07-04  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* tracebak.c: Minor reformatting.\n+\n+2016-07-04  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch12.adb, sem_ch12.ads Update calls to\n+\tCreate_Instantiation_Source to use default argument.\n+\t(Adjust_Inherited_Pragma_Sloc): New function to adjust sloc\n+\tof inherited pragma.\n+\t(Set_Copied_Sloc_For_Inherited_Pragma):\n+\tNew function that wraps call to Create_Instantiation_Source for\n+\tcopying an inherited pragma.\n+\t(Set_Copied_Sloc_For_Inlined_Body): Update call to\n+\tCreate_Instantiation_Source with new arguments.\n+\t* sem_prag.adb (Build_Pragma_Check_Equivalent): In the case\n+\tof inherited pragmas, use the generic machinery to get chained\n+\tlocations for the pragma and its sub-expressions.\n+\t* sinput-c.adb: Adapt to new type Source_File_Record.\n+\t* sinput-l.adb, sinput-l.ads (Create_Instantiation_Source):\n+\tAdd parameter Inherited_Pragma and make parameter Inlined_Body\n+\toptional.\n+\t* sinput.adb, sinput.ads (Comes_From_Inherited_Pragma): New\n+\tfunction to return when a location comes from an inherited pragma.\n+\t(Inherited_Pragma): New function to detect when a location comes\n+\tfrom an inherited pragma.\n+\t(Source_File_Record): New component Inherited_Pragma.\n+\n+2016-07-04  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_elab.adb: Register existence of quickfix for error message.\n+\n+2016-07-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Resolve_One_Call): In the context of a predicate\n+\tfunction the formal and the actual in a call may have different\n+\tviews of the same type, because of the delayed analysis of\n+\tpredicates aspects. Extend the patch that handles this potential\n+\tdiscrepancy to handle private and full views as well.\n+\t* sem_ch8.adb (Find_Selected_Component): Refine predicate that\n+\tproduces additional error when an illegal selected component\n+\tlooks like a prefixed call whose first formal is untagged.\n+\n 2016-07-04  Justin Squirek  <squirek@adacore.com>\n \n \t* einfo.adb (Has_Pragma_Unused): Create this function as a setter"}, {"sha": "3850ca5371ee2732acd48aca6b8a4881e97aaa84", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -1440,13 +1440,15 @@ package body Freeze is\n             A_Pre    := Find_Aspect (Par_Prim, Aspect_Pre);\n \n             if Present (A_Pre) and then Class_Present (A_Pre) then\n-               Build_Classwide_Expression (Expression (A_Pre), Prim);\n+               Build_Classwide_Expression (Expression (A_Pre), Prim,\n+                                           Adjust_Sloc => False);\n             end if;\n \n             A_Post := Find_Aspect (Par_Prim, Aspect_Post);\n \n             if Present (A_Post) and then Class_Present (A_Post) then\n-               Build_Classwide_Expression (Expression (A_Post), Prim);\n+               Build_Classwide_Expression (Expression (A_Post), Prim,\n+                                           Adjust_Sloc => False);\n             end if;\n          end if;\n "}, {"sha": "8e38db0280bb4ac42873d1cdef0b86ba854ae97c", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -1052,6 +1052,15 @@ package body Sem_Ch12 is\n           SPARK_Mode_Pragma        => SPARK_Mode_Pragma));\n    end Add_Pending_Instantiation;\n \n+   ----------------------------------\n+   -- Adjust_Inherited_Pragma_Sloc --\n+   ----------------------------------\n+\n+   procedure Adjust_Inherited_Pragma_Sloc (N : Node_Id) is\n+   begin\n+      Adjust_Instantiation_Sloc (N, S_Adjustment);\n+   end Adjust_Inherited_Pragma_Sloc;\n+\n    --------------------------\n    -- Analyze_Associations --\n    --------------------------\n@@ -2641,7 +2650,7 @@ package body Sem_Ch12 is\n       end if;\n \n       Formal := New_Copy (Pack_Id);\n-      Create_Instantiation_Source (N, Gen_Unit, False, S_Adjustment);\n+      Create_Instantiation_Source (N, Gen_Unit, S_Adjustment);\n \n       --  Make local generic without formals. The formals will be replaced with\n       --  internal declarations.\n@@ -3786,7 +3795,7 @@ package body Sem_Ch12 is\n          --  validate an actual package, the instantiation environment is that\n          --  of the enclosing instance.\n \n-         Create_Instantiation_Source (N, Gen_Unit, False, S_Adjustment);\n+         Create_Instantiation_Source (N, Gen_Unit, S_Adjustment);\n \n          --  Copy original generic tree, to produce text for instantiation\n \n@@ -5138,7 +5147,7 @@ package body Sem_Ch12 is\n          Generic_Renamings.Set_Last (0);\n          Generic_Renamings_HTable.Reset;\n \n-         Create_Instantiation_Source (N, Gen_Unit, False, S_Adjustment);\n+         Create_Instantiation_Source (N, Gen_Unit, S_Adjustment);\n \n          --  Copy original generic tree, to produce text for instantiation\n \n@@ -7646,7 +7655,6 @@ package body Sem_Ch12 is\n                Create_Instantiation_Source\n                  (Instantiation_Node,\n                   Defining_Entity (N),\n-                  False,\n                   S_Adjustment);\n             end if;\n \n@@ -10888,7 +10896,7 @@ package body Sem_Ch12 is\n          Gen_Body := Unit_Declaration_Node (Gen_Body_Id);\n \n          Create_Instantiation_Source\n-           (Inst_Node, Gen_Body_Id, False, S_Adjustment);\n+           (Inst_Node, Gen_Body_Id, S_Adjustment);\n \n          Act_Body :=\n            Copy_Generic_Node\n@@ -11229,7 +11237,6 @@ package body Sem_Ch12 is\n          Create_Instantiation_Source\n            (Inst_Node,\n             Gen_Body_Id,\n-            False,\n             S_Adjustment);\n \n          Act_Body :=\n@@ -15139,13 +15146,30 @@ package body Sem_Ch12 is\n       end loop;\n    end Save_Global_References_In_Aspects;\n \n+   ------------------------------------------\n+   -- Set_Copied_Sloc_For_Inherited_Pragma --\n+   ------------------------------------------\n+\n+   procedure Set_Copied_Sloc_For_Inherited_Pragma\n+     (N : Node_Id;\n+      E : Entity_Id) is\n+   begin\n+      Create_Instantiation_Source (N, E,\n+        Inlined_Body     => False,\n+        Inherited_Pragma => True,\n+        A                => S_Adjustment);\n+   end Set_Copied_Sloc_For_Inherited_Pragma;\n+\n    --------------------------------------\n    -- Set_Copied_Sloc_For_Inlined_Body --\n    --------------------------------------\n \n    procedure Set_Copied_Sloc_For_Inlined_Body (N : Node_Id; E : Entity_Id) is\n    begin\n-      Create_Instantiation_Source (N, E, True, S_Adjustment);\n+      Create_Instantiation_Source (N, E,\n+        Inlined_Body     => True,\n+        Inherited_Pragma => False,\n+        A                => S_Adjustment);\n    end Set_Copied_Sloc_For_Inlined_Body;\n \n    ---------------------"}, {"sha": "8365ac482c3691d6a760ce07ecedc2281fbc1f06", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -172,6 +172,32 @@ package Sem_Ch12 is\n    --  saved as part of the internal state of the Sem_Ch12 package for use\n    --  in subsequent calls to copy nodes.\n \n+   procedure Set_Copied_Sloc_For_Inherited_Pragma\n+     (N : Node_Id;\n+      E : Entity_Id);\n+   --  This procedure is used when a class-wide pre- or postcondition is\n+   --  inherited. This process shares the same circuitry as the creation of\n+   --  an instantiated copy of a generic template. The call to this procedure\n+   --  establishes a new source file entry representing the inherited pragma\n+   --  as an instantiation, marked as an inherited pragma (so that errout can\n+   --  distinguish cases for generating error messages, otherwise the treatment\n+   --  is identical). In this call N is the subprogram declaration from\n+   --  which the pragma is inherited and E is the defining identifier of\n+   --  the overridding subprogram (when the subprogram is redefined) or the\n+   --  defining identifier of the extension type (when the subprogram is\n+   --  inherited). The resulting Sloc adjustment factor is saved as part of the\n+   --  internal state of the Sem_Ch12 package for use in subsequent calls to\n+   --  copy nodes.\n+\n+   procedure Adjust_Inherited_Pragma_Sloc (N : Node_Id);\n+   --  This procedure is used when a class-wide pre- or postcondition\n+   --  is inherited. It is called on each node of the pragma expression\n+   --  to adjust its sloc. These call should be preceded by a call to\n+   --  Set_Copied_Sloc_For_Inherited_Pragma that sets the required sloc\n+   --  adjustment. This is done directly, instead of using Copy_Generic_Node\n+   --  to copy nodes and adjust slocs, as Copy_Generic_Node expects a specific\n+   --  structure to be in place, which is not the case for inherited pragmas.\n+\n    procedure Save_Env\n      (Gen_Unit : Entity_Id;\n       Act_Unit : Entity_Id);"}, {"sha": "6b1e5de63b9e32e7642199f521ef3d464f51b75a", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -3413,9 +3413,17 @@ package body Sem_Ch4 is\n                --  an incomplete type, while resolution of the corresponding\n                --  predicate function may see the full view, as a consequence\n                --  of the delayed resolution of the corresponding expressions.\n+               --  This can occur in the body of a predicate function, or in\n+               --  a call to such.\n \n-               elsif Ekind (Etype (Formal)) = E_Incomplete_Type\n-                 and then Full_View (Etype (Formal)) = Etype (Actual)\n+               elsif ((Ekind (Current_Scope) = E_Function\n+                       and then Is_Predicate_Function (Current_Scope))\n+                     or else (Ekind (Nam) = E_Function\n+                       and then Is_Predicate_Function (Nam)))\n+                  and then\n+                   (Base_Type (Underlying_Type (Etype (Formal))) =\n+                     Base_Type (Underlying_Type (Etype (Actual))))\n+                  and then Serious_Errors_Detected = 0\n                then\n                   Set_Etype (Formal, Etype (Actual));\n                   Next_Actual (Actual);"}, {"sha": "e4aa908430055c1968b8513c2437dd5d41c16f6f", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -6983,7 +6983,8 @@ package body Sem_Ch8 is\n             elsif Nkind (P) /= N_Attribute_Reference then\n \n                --  This may have been meant as a prefixed call to a primitive\n-               --  of an untagged type.\n+               --  of an untagged type. If it is a function call check type of\n+               --  its first formal and add explanation.\n \n                declare\n                   F : constant Entity_Id :=\n@@ -6992,8 +6993,7 @@ package body Sem_Ch8 is\n                   if Present (F)\n                     and then Is_Overloadable (F)\n                     and then Present (First_Entity (F))\n-                    and then Etype (First_Entity (F)) = Etype (P)\n-                    and then not Is_Tagged_Type (Etype (P))\n+                    and then not Is_Tagged_Type (Etype (First_Entity (F)))\n                   then\n                      Error_Msg_N\n                        (\"prefixed call is only allowed for objects \""}, {"sha": "d963def7980036ca244e28599b843fd18e3bdb6a", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -1097,7 +1097,8 @@ package body Sem_Elab is\n          --  is an error, so give an error message.\n \n          if Issue_In_SPARK then\n-            Error_Msg_NE (\"\\Elaborate_All pragma required for&\", N, W_Scope);\n+            Error_Msg_NE -- CODEFIX\n+              (\"\\Elaborate_All pragma required for&\", N, W_Scope);\n \n          --  Otherwise we generate an implicit pragma. For a subprogram\n          --  instantiation, Elaborate is good enough, since no transitive"}, {"sha": "8cda6c75bb2b3643141dc4af7c46d69ad1d28b7b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -26395,7 +26395,11 @@ package body Sem_Prag is\n    -- Build_Classwide_Expression --\n    --------------------------------\n \n-   procedure Build_Classwide_Expression (Prag : Node_Id; Subp : Entity_Id) is\n+   procedure Build_Classwide_Expression\n+     (Prag        : Node_Id;\n+      Subp        : Entity_Id;\n+      Adjust_Sloc : Boolean)\n+   is\n       function Replace_Entity (N : Node_Id) return Traverse_Result;\n       --  Replace reference to formal of inherited operation or to primitive\n       --  operation of root type, with corresponding entity for derived type,\n@@ -26410,6 +26414,10 @@ package body Sem_Prag is\n          New_E : Entity_Id;\n \n       begin\n+         if Adjust_Sloc then\n+            Adjust_Inherited_Pragma_Sloc (N);\n+         end if;\n+\n          if Nkind (N) = N_Identifier\n            and then Present (Entity (N))\n            and then\n@@ -26576,15 +26584,22 @@ package body Sem_Prag is\n             Next_Formal (Inher_Formal);\n             Next_Formal (Subp_Formal);\n          end loop;\n-      end if;\n \n-      --  Copy the original pragma while performing substitutions (if\n-      --  applicable).\n+         --  Use generic machinery to copy inherited pragma, as if it were an\n+         --  instantiation, resetting source locations appropriately, so that\n+         --  expressions inside the inherited pragma use chained locations.\n+         --  This is used in particular in GNATprove to locate precisely\n+         --  messages on a given inherited pragma.\n \n-      Check_Prag := New_Copy_Tree (Source => Prag);\n+         Set_Copied_Sloc_For_Inherited_Pragma\n+           (Unit_Declaration_Node (Subp_Id), Inher_Id);\n+         Check_Prag := New_Copy_Tree (Source => Prag);\n+         Build_Classwide_Expression (Check_Prag, Subp_Id, Adjust_Sloc => True);\n \n-      if Present (Inher_Id) then\n-         Build_Classwide_Expression (Check_Prag, Subp_Id);\n+      --  Otherwise simply copy the original pragma\n+\n+      else\n+         Check_Prag := New_Copy_Tree (Source => Prag);\n       end if;\n \n       --  Mark the pragma as being internally generated and reset the Analyzed"}, {"sha": "9a951ffe2478925a4f0c79921d4cbd9d24736505", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -244,16 +244,21 @@ package Sem_Prag is\n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id);\n    --  Perform preanalysis of pragma Test_Case\n \n-   procedure Build_Classwide_Expression (Prag : Node_Id; Subp : Entity_Id);\n+   procedure Build_Classwide_Expression\n+     (Prag        : Node_Id;\n+      Subp        : Entity_Id;\n+      Adjust_Sloc : Boolean);\n    --  Build the expression for an inherited classwide condition. Prag is\n    --  the pragma constructed from the corresponding aspect of the parent\n-   --  subprogram, and Subp is the overridding operation.\n-   --  The routine is also called to check whether an inherited operation\n-   --  that is not overridden but has inherited conditions need a wrapper,\n-   --  because the inherited condition includes calls to other primitives that\n-   --  have been overridden. In that case the first argument is the expression\n-   --  of the original classwide aspect. In SPARK_Mode, such operation which\n-   --  are just inherited but have modified pre/postconditions are illegal.\n+   --  subprogram, and Subp is the overridding operation. Adjust_Sloc is True\n+   --  when the sloc of nodes traversed should be adjusted for the inherited\n+   --  pragma. The routine is also called to check whether an inherited\n+   --  operation that is not overridden but has inherited conditions need\n+   --  a wrapper, because the inherited condition includes calls to other\n+   --  primitives that have been overridden. In that case the first argument\n+   --  is the expression of the original classwide aspect. In SPARK_Mode, such\n+   --  operation which are just inherited but have modified pre/postconditions\n+   --  are illegal.\n \n    function Build_Pragma_Check_Equivalent\n      (Prag           : Node_Id;"}, {"sha": "3ef0f5af35b923158dad60cc8b254ab5fe778647", "filename": "gcc/ada/sinput-c.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsinput-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsinput-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-c.adb?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -183,6 +183,7 @@ package body Sinput.C is\n                Identifier_Casing   => Unknown,\n                Inlined_Call        => No_Location,\n                Inlined_Body        => False,\n+               Inherited_Pragma    => False,\n                Keyword_Casing      => Unknown,\n                Last_Source_Line    => 1,\n                License             => Unknown,"}, {"sha": "32c2ac2e83506db3bd4b94d45df62b5122cb93b4", "filename": "gcc/ada/sinput-l.adb", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsinput-l.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsinput-l.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.adb?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -121,10 +121,11 @@ package body Sinput.L is\n    ---------------------------------\n \n    procedure Create_Instantiation_Source\n-     (Inst_Node    : Entity_Id;\n-      Template_Id  : Entity_Id;\n-      Inlined_Body : Boolean;\n-      A            : out Sloc_Adjustment)\n+     (Inst_Node        : Entity_Id;\n+      Template_Id      : Entity_Id;\n+      A                : out Sloc_Adjustment;\n+      Inlined_Body     : Boolean := False;\n+      Inherited_Pragma : Boolean := False)\n    is\n       Dnod : constant Node_Id := Declaration_Node (Template_Id);\n       Xold : Source_File_Index;\n@@ -145,16 +146,21 @@ package body Sinput.L is\n          Inst_Spec : Node_Id;\n \n       begin\n-         Snew.Inlined_Body  := Inlined_Body;\n-         Snew.Template      := Xold;\n+         Snew.Inlined_Body     := Inlined_Body;\n+         Snew.Inherited_Pragma := Inherited_Pragma;\n+         Snew.Template         := Xold;\n \n-         --  For a genuine generic instantiation, assign new instance id.\n-         --  For inlined bodies, we retain that of the template, but we\n-         --  save the call location.\n+         --  For a genuine generic instantiation, assign new instance id. For\n+         --  inlined bodies, we retain that of the template, but we save the\n+         --  call location. For inherited pragmas, we simply retain that of\n+         --  the template.\n \n          if Inlined_Body then\n             Snew.Inlined_Call := Sloc (Inst_Node);\n \n+         elsif Inherited_Pragma then\n+            null;\n+\n          else\n             --  If the spec has been instantiated already, and we are now\n             --  creating the instance source for the corresponding body now,\n@@ -509,6 +515,7 @@ package body Sinput.L is\n                   Identifier_Casing   => Unknown,\n                   Inlined_Call        => No_Location,\n                   Inlined_Body        => False,\n+                  Inherited_Pragma    => False,\n                   Keyword_Casing      => Unknown,\n                   Last_Source_Line    => 1,\n                   License             => Unknown,"}, {"sha": "1b0aacbe98851b273065d6d4c750b2c082eb6f24", "filename": "gcc/ada/sinput-l.ads", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsinput-l.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsinput-l.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.ads?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -83,19 +83,22 @@ package Sinput.L is\n    --  calls to Adjust_Instantiation_Sloc.\n \n    procedure Create_Instantiation_Source\n-     (Inst_Node    : Entity_Id;\n-      Template_Id  : Entity_Id;\n-      Inlined_Body : Boolean;\n-      A            : out Sloc_Adjustment);\n+     (Inst_Node        : Entity_Id;\n+      Template_Id      : Entity_Id;\n+      A                : out Sloc_Adjustment;\n+      Inlined_Body     : Boolean := False;\n+      Inherited_Pragma : Boolean := False);\n    --  This procedure creates the source table entry for an instantiation.\n    --  Inst_Node is the instantiation node, and Template_Id is the defining\n    --  identifier of the generic declaration or body unit as appropriate.\n    --  A is set to an adjustment factor to be used in subsequent calls to\n    --  Adjust_Instantiation_Sloc. The instantiation mechanism is also used\n-   --  for inlined function and procedure calls. The parameter Inlined_Body\n-   --  is set to True in such cases, and False for a generic instantiation.\n-   --  This is used for generating error messages that distinguish these\n-   --  two cases, otherwise the two cases are handled identically.\n+   --  for inlined function and procedure calls. The parameter Inlined_Body is\n+   --  set to True in such cases. This is used for generating error messages\n+   --  that distinguish these two cases, otherwise the two cases are handled\n+   --  identically. Similarly, the instantiation mechanism is also used\n+   --  for inherited class-wide pre- and postconditions. The parameter\n+   --  Inherited_Pragma is set to True in such cases.\n \n    procedure Adjust_Instantiation_Sloc (N : Node_Id; A : Sloc_Adjustment);\n    --  The instantiation tree is created by copying the tree of the generic"}, {"sha": "0105b2c4618c765d45bfda2820ff39d60571afc1", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -300,6 +300,17 @@ package body Sinput is\n       end case;\n    end Check_For_BOM;\n \n+   ---------------------------------\n+   -- Comes_From_Inherited_Pragma --\n+   ---------------------------------\n+\n+   function Comes_From_Inherited_Pragma (S : Source_Ptr) return Boolean is\n+      SIE : Source_File_Record renames\n+              Source_File.Table (Get_Source_File_Index (S));\n+   begin\n+      return SIE.Inherited_Pragma;\n+   end Comes_From_Inherited_Pragma;\n+\n    -----------------------------\n    -- Comes_From_Inlined_Body --\n    -----------------------------\n@@ -1190,6 +1201,11 @@ package body Sinput is\n       return Source_File.Table (S).Identifier_Casing;\n    end Identifier_Casing;\n \n+   function Inherited_Pragma (S : SFI) return Boolean is\n+   begin\n+      return Source_File.Table (S).Inherited_Pragma;\n+   end Inherited_Pragma;\n+\n    function Inlined_Body (S : SFI) return Boolean is\n    begin\n       return Source_File.Table (S).Inlined_Body;"}, {"sha": "21f16f20174e8a158a74cc2c94610f0fe013c8de", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -269,6 +269,11 @@ package Sinput is\n    --    an instance of an inlined body.\n    --    ??? Redundant, always equal to (Inlined_Call /= No_Location)\n \n+   --  Inherited_Pragma : Boolean;\n+   --    This can only be set True if Instantiation has a value other than\n+   --    No_Location. If true it indicates that the instantiation is actually\n+   --    an inherited class-wide pre- or postcondition.\n+\n    --  Template : Source_File_Index; (read-only)\n    --    Source file index of the source file containing the template if this\n    --    is a generic instantiation. Set to No_Source_File for the normal case\n@@ -298,6 +303,7 @@ package Sinput is\n    function Full_Ref_Name     (S : SFI) return File_Name_Type;\n    function Identifier_Casing (S : SFI) return Casing_Type;\n    function Inlined_Body      (S : SFI) return Boolean;\n+   function Inherited_Pragma  (S : SFI) return Boolean;\n    function Inlined_Call      (S : SFI) return Source_Ptr;\n    function Instance          (S : SFI) return Instance_Id;\n    function Keyword_Casing    (S : SFI) return Casing_Type;\n@@ -644,6 +650,13 @@ package Sinput is\n    --  from instantiation of generics, since Instantiation_Location returns a\n    --  valid location in both cases.\n \n+   function Comes_From_Inherited_Pragma (S : Source_Ptr) return Boolean;\n+   pragma Inline (Comes_From_Inherited_Pragma);\n+   --  Given a source pointer S, returns whether it comes from an inherited\n+   --  pragma. This allows distinguishing these source pointers from those\n+   --  that come from instantiation of generics, since Instantiation_Location\n+   --  returns a valid location in both cases.\n+\n    function Top_Level_Location (S : Source_Ptr) return Source_Ptr;\n    --  Given a source pointer S, returns the argument unchanged if it is\n    --  not in an instantiation. If S is in an instantiation, then it returns\n@@ -759,6 +772,7 @@ private\n    pragma Inline (Identifier_Casing);\n    pragma Inline (Inlined_Call);\n    pragma Inline (Inlined_Body);\n+   pragma Inline (Inherited_Pragma);\n    pragma Inline (Template);\n    pragma Inline (Unit);\n \n@@ -824,6 +838,7 @@ private\n       File_Type         : Type_Of_File;\n       Inlined_Call      : Source_Ptr;\n       Inlined_Body      : Boolean;\n+      Inherited_Pragma  : Boolean;\n       License           : License_Type;\n       Keyword_Casing    : Casing_Type;\n       Identifier_Casing : Casing_Type;\n@@ -881,7 +896,8 @@ private\n       Time_Stamp          at 60 range 0 .. 8 * Time_Stamp_Length - 1;\n       File_Type           at 74 range 0 .. 7;\n       Inlined_Call        at 88 range 0 .. 31;\n-      Inlined_Body        at 75 range 0 .. 7;\n+      Inlined_Body        at 75 range 0 .. 0;\n+      Inherited_Pragma    at 75 range 1 .. 1;\n       License             at 76 range 0 .. 7;\n       Keyword_Casing      at 77 range 0 .. 7;\n       Identifier_Casing   at 78 range 0 .. 15;"}, {"sha": "7cb7f105d561402d06f8fcf6fba14da168e45eb4", "filename": "gcc/ada/xref_lib.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fxref_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96df3ff4bd3b0f2ce63f519955f20f7d93612929/gcc%2Fada%2Fxref_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.adb?ref=96df3ff4bd3b0f2ce63f519955f20f7d93612929", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -890,8 +890,12 @@ package body Xref_Lib is\n \n       Parse_Token (Ali, Ptr, E_Name);\n \n-      --  Exit if the symbol does not match\n-      --  or if we have a local symbol and we do not want it\n+      --  Exit if the symbol does not match or if we have a local\n+      --  symbol and we do not want it or if the file is unknown.\n+\n+      if File.X_File = Empty_File then\n+         return;\n+      end if;\n \n       if (not Local_Symbols and not E_Global)\n         or else (Pattern.Initialized\n@@ -1261,8 +1265,12 @@ package body Xref_Lib is\n          Ptr := Ptr + 1;\n          Parse_Number (Ali, Ptr, File_Nr);\n \n-         if File_Nr > 0 then\n+         --  If the referenced file is unknown, we simply ignore it\n+\n+         if File_Nr in Dependencies_Tables.First .. Last (File.Dep) then\n             File.X_File := File.Dep.Table (File_Nr);\n+         else\n+            File.X_File := Empty_File;\n          end if;\n \n          Parse_EOL (Ali, Ptr);"}]}