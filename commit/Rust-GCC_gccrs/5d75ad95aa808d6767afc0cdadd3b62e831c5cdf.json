{"sha": "5d75ad95aa808d6767afc0cdadd3b62e831c5cdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ3NWFkOTVhYTgwOGQ2NzY3YWZjMGNkYWRkM2I2MmU4MzFjNWNkZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-24T08:02:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-24T08:02:35Z"}, "message": "Add a class to represent a gimple match result\n\nGimple match results are represented by a code_helper for the operation,\na tree for the type, and an array of three trees for the operands.\nThis patch wraps them up in a class so that they don't need to be\npassed around individually.\n\nThe main reason for doing this is to make it easier to increase the\nnumber of operands (for calls) or to support more complicated kinds\nof operation.  But passing around fewer operands also helps to reduce\nthe size of gimple-match.o (about 7% for development builds and 4% for\nrelease builds).\n\n2018-05-24  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* gimple-match.h (gimple_match_op): New class.\n\t(mprts_hook): Replace parameters with a gimple_match_op *.\n\t(maybe_build_generic_op): Likewise.\n\t(gimple_simplified_result_is_gimple_val): Replace parameters with\n\ta const gimple_match_op *.\n\t(gimple_simplify): Replace code_helper * and tree * parameters with\n\ta gimple_match_op * parameter.\n\t(gimple_resimplify1): Replace code_helper *, tree and tree *\n\tparameters with a gimple_match_op * parameter.\n\t(gimple_resimplify2): Likewise.\n\t(gimple_resimplify3): Likewise.\n\t(maybe_push_res_to_seq): Replace code_helper, tree and tree *\n\tparameters with a gimple_match_op * parameter.\n\t* gimple-match-head.c (gimple_simplify): Change prototypes of\n\tauto-generated functions to take a gimple_match_op * instead of\n\tseparate code_helper * and tree * parameters.  Make the same\n\tchange in the top-level overload and update calls to the\n\tgimple_resimplify routines.  Update calls to the auto-generated\n\tfunctions and to maybe_push_res_to_seq in the publicly-facing\n\toperation-specific gimple_simplify overloads.\n\t(gimple_match_op::MAX_NUM_OPS): Define.\n\t(gimple_resimplify1): Replace rcode and ops with a single res_op\n\tparameter.  Update call to gimple_simplify.\n\t(gimple_resimplify2): Likewise.\n\t(gimple_resimplify3): Likewise.\n\t(mprts_hook): Replace parameters with a gimple_match_op *.\n\t(maybe_build_generic_op): Likewise.\n\t(build_call_internal): Replace type, nargs and ops with\n\ta gimple_match_op *.\n\t(maybe_push_res_to_seq): Replace res_code, type and ops parameters\n\twith a single gimple_match_op *.  Update calls to mprts_hook,\n\tbuild_call_internal and gimple_simplified_result_is_gimple_val.\n\tFactor out code that is common to the tree_code and combined_fn cases.\n\t* genmatch.c (expr::gen_transform): Replace tem_code and\n\ttem_ops with a gimple_match_op called tem_op.  Update calls\n\tto the gimple_resimplify functions and maybe_push_res_to_seq.\n\t(dt_simplify::gen_1): Manipulate res_op instead of res_code and\n\tres_ops.  Update call to the gimple_resimplify functions.\n\t(dt_simplify::gen): Pass res_op instead of res_code and res_ops.\n\t(decision_tree::gen): Make the functions take a gimple_match_op *\n\tcalled res_op instead of separate res_code and res_ops parameters.\n\tUpdate call accordingly.\n\t* gimple-fold.c (replace_stmt_with_simplification): Replace rcode\n\tand ops with a single res_op parameter.  Update calls to\n\tmaybe_build_generic_op and maybe_push_res_to_seq.\n\t(fold_stmt_1): Update calls to gimple_simplify and\n\treplace_stmt_with_simplification.\n\t(gimple_fold_stmt_to_constant_1): Update calls to gimple_simplify\n\tand gimple_simplified_result_is_gimple_val.\n\t* tree-cfgcleanup.c (cleanup_control_expr_graph): Update call to\n\tgimple_simplify.\n\t* tree-ssa-sccvn.c (vn_lookup_simplify_result): Replace parameters\n\twith a gimple_match_op *.\n\t(vn_nary_build_or_lookup): Likewise.  Update call to\n\tvn_nary_build_or_lookup_1.\n\t(vn_nary_build_or_lookup_1): Replace rcode, type and ops with a\n\tgimple_match_op *.  Update calls to the gimple_resimplify routines\n\tand to gimple_simplified_result_is_gimple_val.\n\t(vn_nary_simplify): Update call to vn_nary_build_or_lookup_1.\n\tUse gimple_match_op::MAX_NUM_OPS instead of a hard-coded 3.\n\t(vn_reference_lookup_3): Update call to vn_nary_build_or_lookup.\n\t(visit_nary_op): Likewise.\n\t(visit_reference_op_load): Likewise.\n\nFrom-SVN: r260634", "tree": {"sha": "0cc9a5a00b0c8f56cb996dc8818b9bfa42ed5005", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cc9a5a00b0c8f56cb996dc8818b9bfa42ed5005"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/comments", "author": null, "committer": null, "parents": [{"sha": "e29ea4832560f961c00e19fca923f325a08761d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e29ea4832560f961c00e19fca923f325a08761d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e29ea4832560f961c00e19fca923f325a08761d6"}], "stats": {"total": 907, "additions": 522, "deletions": 385}, "files": [{"sha": "db2755c12dfcb78075bda497d99f334d7f9dea39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d75ad95aa808d6767afc0cdadd3b62e831c5cdf", "patch": "@@ -1,3 +1,69 @@\n+2018-05-24  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gimple-match.h (gimple_match_op): New class.\n+\t(mprts_hook): Replace parameters with a gimple_match_op *.\n+\t(maybe_build_generic_op): Likewise.\n+\t(gimple_simplified_result_is_gimple_val): Replace parameters with\n+\ta const gimple_match_op *.\n+\t(gimple_simplify): Replace code_helper * and tree * parameters with\n+\ta gimple_match_op * parameter.\n+\t(gimple_resimplify1): Replace code_helper *, tree and tree *\n+\tparameters with a gimple_match_op * parameter.\n+\t(gimple_resimplify2): Likewise.\n+\t(gimple_resimplify3): Likewise.\n+\t(maybe_push_res_to_seq): Replace code_helper, tree and tree *\n+\tparameters with a gimple_match_op * parameter.\n+\t* gimple-match-head.c (gimple_simplify): Change prototypes of\n+\tauto-generated functions to take a gimple_match_op * instead of\n+\tseparate code_helper * and tree * parameters.  Make the same\n+\tchange in the top-level overload and update calls to the\n+\tgimple_resimplify routines.  Update calls to the auto-generated\n+\tfunctions and to maybe_push_res_to_seq in the publicly-facing\n+\toperation-specific gimple_simplify overloads.\n+\t(gimple_match_op::MAX_NUM_OPS): Define.\n+\t(gimple_resimplify1): Replace rcode and ops with a single res_op\n+\tparameter.  Update call to gimple_simplify.\n+\t(gimple_resimplify2): Likewise.\n+\t(gimple_resimplify3): Likewise.\n+\t(mprts_hook): Replace parameters with a gimple_match_op *.\n+\t(maybe_build_generic_op): Likewise.\n+\t(build_call_internal): Replace type, nargs and ops with\n+\ta gimple_match_op *.\n+\t(maybe_push_res_to_seq): Replace res_code, type and ops parameters\n+\twith a single gimple_match_op *.  Update calls to mprts_hook,\n+\tbuild_call_internal and gimple_simplified_result_is_gimple_val.\n+\tFactor out code that is common to the tree_code and combined_fn cases.\n+\t* genmatch.c (expr::gen_transform): Replace tem_code and\n+\ttem_ops with a gimple_match_op called tem_op.  Update calls\n+\tto the gimple_resimplify functions and maybe_push_res_to_seq.\n+\t(dt_simplify::gen_1): Manipulate res_op instead of res_code and\n+\tres_ops.  Update call to the gimple_resimplify functions.\n+\t(dt_simplify::gen): Pass res_op instead of res_code and res_ops.\n+\t(decision_tree::gen): Make the functions take a gimple_match_op *\n+\tcalled res_op instead of separate res_code and res_ops parameters.\n+\tUpdate call accordingly.\n+\t* gimple-fold.c (replace_stmt_with_simplification): Replace rcode\n+\tand ops with a single res_op parameter.  Update calls to\n+\tmaybe_build_generic_op and maybe_push_res_to_seq.\n+\t(fold_stmt_1): Update calls to gimple_simplify and\n+\treplace_stmt_with_simplification.\n+\t(gimple_fold_stmt_to_constant_1): Update calls to gimple_simplify\n+\tand gimple_simplified_result_is_gimple_val.\n+\t* tree-cfgcleanup.c (cleanup_control_expr_graph): Update call to\n+\tgimple_simplify.\n+\t* tree-ssa-sccvn.c (vn_lookup_simplify_result): Replace parameters\n+\twith a gimple_match_op *.\n+\t(vn_nary_build_or_lookup): Likewise.  Update call to\n+\tvn_nary_build_or_lookup_1.\n+\t(vn_nary_build_or_lookup_1): Replace rcode, type and ops with a\n+\tgimple_match_op *.  Update calls to the gimple_resimplify routines\n+\tand to gimple_simplified_result_is_gimple_val.\n+\t(vn_nary_simplify): Update call to vn_nary_build_or_lookup_1.\n+\tUse gimple_match_op::MAX_NUM_OPS instead of a hard-coded 3.\n+\t(vn_reference_lookup_3): Update call to vn_nary_build_or_lookup.\n+\t(visit_nary_op): Likewise.\n+\t(visit_reference_op_load): Likewise.\n+\n 2018-05-23  Luis Machado  <luis.machado@linaro.org>\n \n \t* tree-ssa-loop-prefetch.c (should_issue_prefetch_p): Use correct type"}, {"sha": "5715dd16f550733882c2bdc203d9d07000c68a6a", "filename": "gcc/genmatch.c", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=5d75ad95aa808d6767afc0cdadd3b62e831c5cdf", "patch": "@@ -2484,17 +2484,16 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       /* ???  Building a stmt can fail for various reasons here, seq being\n          NULL or the stmt referencing SSA names occuring in abnormal PHIs.\n \t So if we fail here we should continue matching other patterns.  */\n-      fprintf_indent (f, indent, \"code_helper tem_code = %s;\\n\", opr_name);\n-      fprintf_indent (f, indent, \"tree tem_ops[3] = { \");\n+      fprintf_indent (f, indent, \"gimple_match_op tem_op (%s, %s\",\n+\t\t      opr_name, type);\n       for (unsigned i = 0; i < ops.length (); ++i)\n-\tfprintf (f, \"ops%d[%u]%s\", depth, i,\n-\t\t i == ops.length () - 1 ? \" };\\n\" : \", \");\n+\tfprintf (f, \", ops%d[%u]\", depth, i);\n+      fprintf (f, \");\\n\");\n       fprintf_indent (f, indent,\n-\t\t      \"gimple_resimplify%d (lseq, &tem_code, %s, tem_ops, valueize);\\n\",\n-\t\t      ops.length (), type);\n+\t\t      \"gimple_resimplify%d (lseq, &tem_op, valueize);\\n\",\n+\t\t      ops.length ());\n       fprintf_indent (f, indent,\n-\t\t      \"res = maybe_push_res_to_seq (tem_code, %s, tem_ops, lseq);\\n\",\n-\t\t      type);\n+\t\t      \"res = maybe_push_res_to_seq (&tem_op, lseq);\\n\");\n       fprintf_indent (f, indent,\n \t\t      \"if (!res) return false;\\n\");\n       if (*opr == CONVERT_EXPR)\n@@ -3322,17 +3321,22 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t  else if (is_a <predicate_id *> (opr))\n \t    is_predicate = true;\n \t  if (!is_predicate)\n-\t    fprintf_indent (f, indent, \"*res_code = %s;\\n\",\n+\t    fprintf_indent (f, indent, \"res_op->set_op (%s, type, %d);\\n\",\n \t\t\t    *e->operation == CONVERT_EXPR\n-\t\t\t    ? \"NOP_EXPR\" : e->operation->id);\n+\t\t\t    ? \"NOP_EXPR\" : e->operation->id,\n+\t\t\t    e->ops.length ());\n \t  for (unsigned j = 0; j < e->ops.length (); ++j)\n \t    {\n \t      char dest[32];\n-\t      snprintf (dest, 32, \"res_ops[%d]\", j);\n+\t      if (is_predicate)\n+\t\tsnprintf (dest, 32, \"res_ops[%d]\", j);\n+\t      else\n+\t\tsnprintf (dest, 32, \"res_op->ops[%d]\", j);\n \t      const char *optype\n \t\t= get_operand_type (opr, j,\n \t\t\t\t    \"type\", e->expr_type,\n-\t\t\t\t    j == 0 ? NULL : \"TREE_TYPE (res_ops[0])\");\n+\t\t\t\t    j == 0 ? NULL\n+\t\t\t\t    : \"TREE_TYPE (res_op->ops[0])\");\n \t      /* We need to expand GENERIC conditions we captured from\n \t         COND_EXPRs and we need to unshare them when substituting\n \t\t into COND_EXPRs.  */\n@@ -3348,30 +3352,29 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t     gimple_build w/o actually building the stmt.  */\n \t  if (!is_predicate)\n \t    fprintf_indent (f, indent,\n-\t\t\t    \"gimple_resimplify%d (lseq, res_code, type, \"\n-\t\t\t    \"res_ops, valueize);\\n\", e->ops.length ());\n+\t\t\t    \"gimple_resimplify%d (lseq, res_op,\"\n+\t\t\t    \" valueize);\\n\", e->ops.length ());\n \t}\n       else if (result->type == operand::OP_CAPTURE\n \t       || result->type == operand::OP_C_EXPR)\n \t{\n-\t  result->gen_transform (f, indent, \"res_ops[0]\", true, 1, \"type\",\n+\t  fprintf_indent (f, indent, \"tree tem;\\n\");\n+\t  result->gen_transform (f, indent, \"tem\", true, 1, \"type\",\n \t\t\t\t &cinfo, indexes);\n-\t  fprintf_indent (f, indent, \"*res_code = TREE_CODE (res_ops[0]);\\n\");\n+\t  fprintf_indent (f, indent, \"res_op->set_value (tem);\\n\");\n \t  if (is_a <capture *> (result)\n \t      && cinfo.info[as_a <capture *> (result)->where].cond_expr_cond_p)\n \t    {\n \t      /* ???  Stupid tcc_comparison GENERIC trees in COND_EXPRs.  Deal\n \t\t with substituting a capture of that.  */\n \t      fprintf_indent (f, indent,\n-\t\t\t      \"if (COMPARISON_CLASS_P (res_ops[0]))\\n\");\n+\t\t\t      \"if (COMPARISON_CLASS_P (tem))\\n\");\n \t      fprintf_indent (f, indent,\n \t\t\t      \"  {\\n\");\n \t      fprintf_indent (f, indent,\n-\t\t\t      \"    tree tem = res_ops[0];\\n\");\n-\t      fprintf_indent (f, indent,\n-\t\t\t      \"    res_ops[0] = TREE_OPERAND (tem, 0);\\n\");\n+\t\t\t      \"    res_op->ops[0] = TREE_OPERAND (tem, 0);\\n\");\n \t      fprintf_indent (f, indent,\n-\t\t\t      \"    res_ops[1] = TREE_OPERAND (tem, 1);\\n\");\n+\t\t\t      \"    res_op->ops[1] = TREE_OPERAND (tem, 1);\\n\");\n \t      fprintf_indent (f, indent,\n \t\t\t      \"  }\\n\");\n \t    }\n@@ -3529,7 +3532,7 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n     {\n       if (gimple)\n \t{\n-\t  fprintf_indent (f, indent, \"if (%s (res_code, res_ops, seq, \"\n+\t  fprintf_indent (f, indent, \"if (%s (res_op, seq, \"\n \t\t\t  \"valueize, type, captures\", info->fname);\n \t  for (unsigned i = 0; i < s->for_subst_vec.length (); ++i)\n \t    if (s->for_subst_vec[i].first->used)\n@@ -3697,9 +3700,8 @@ decision_tree::gen (FILE *f, bool gimple)\n \t\t\t    fcnt++);\n       if (gimple)\n \tfprintf (f, \"\\nstatic bool\\n\"\n-\t\t \"%s (code_helper *res_code, tree *res_ops,\\n\"\n-\t\t \"                 gimple_seq *seq, tree (*valueize)(tree) \"\n-\t\t \"ATTRIBUTE_UNUSED,\\n\"\n+\t\t \"%s (gimple_match_op *res_op, gimple_seq *seq,\\n\"\n+\t\t \"                 tree (*valueize)(tree) ATTRIBUTE_UNUSED,\\n\"\n \t\t \"                 const tree ARG_UNUSED (type), tree *ARG_UNUSED \"\n \t\t \"(captures)\\n\",\n \t\t s->fname);\n@@ -3753,8 +3755,9 @@ decision_tree::gen (FILE *f, bool gimple)\n \n \t  if (gimple)\n \t    fprintf (f, \"\\nstatic bool\\n\"\n-\t\t     \"gimple_simplify_%s (code_helper *res_code, tree *res_ops,\\n\"\n-\t\t     \"                 gimple_seq *seq, tree (*valueize)(tree) \"\n+\t\t     \"gimple_simplify_%s (gimple_match_op *res_op,\"\n+\t\t     \" gimple_seq *seq,\\n\"\n+\t\t     \"                 tree (*valueize)(tree) \"\n \t\t     \"ATTRIBUTE_UNUSED,\\n\"\n \t\t     \"                 code_helper ARG_UNUSED (code), tree \"\n \t\t     \"ARG_UNUSED (type)\\n\",\n@@ -3780,8 +3783,8 @@ decision_tree::gen (FILE *f, bool gimple)\n          tail-calls to the split-out functions.  */\n       if (gimple)\n \tfprintf (f, \"\\nstatic bool\\n\"\n-\t\t \"gimple_simplify (code_helper *res_code, tree *res_ops,\\n\"\n-\t\t \"                 gimple_seq *seq, tree (*valueize)(tree),\\n\"\n+\t\t \"gimple_simplify (gimple_match_op *res_op, gimple_seq *seq,\\n\"\n+\t\t \"                 tree (*valueize)(tree) ATTRIBUTE_UNUSED,\\n\"\n \t\t \"                 code_helper code, const tree type\");\n       else\n \tfprintf (f, \"\\ntree\\n\"\n@@ -3819,7 +3822,7 @@ decision_tree::gen (FILE *f, bool gimple)\n \t\t     is_a <fn_id *> (e->operation) ? \"-\" : \"\",\n \t\t     e->operation->id);\n \t  if (gimple)\n-\t    fprintf (f, \"      return gimple_simplify_%s (res_code, res_ops, \"\n+\t    fprintf (f, \"      return gimple_simplify_%s (res_op, \"\n \t\t     \"seq, valueize, code, type\", e->operation->id);\n \t  else\n \t    fprintf (f, \"      return generic_simplify_%s (loc, code, type\","}, {"sha": "cd1ab8058b4972a1a5d30de9d15b820b9730558e", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 43, "deletions": 55, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=5d75ad95aa808d6767afc0cdadd3b62e831c5cdf", "patch": "@@ -4360,34 +4360,29 @@ has_use_on_stmt (tree name, gimple *stmt)\n \n static bool\n replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n-\t\t\t\t  code_helper rcode, tree *ops,\n+\t\t\t\t  gimple_match_op *res_op,\n \t\t\t\t  gimple_seq *seq, bool inplace)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n+  tree *ops = res_op->ops;\n+  unsigned int num_ops = res_op->num_ops;\n \n   /* Play safe and do not allow abnormals to be mentioned in\n      newly created statements.  See also maybe_push_res_to_seq.\n      As an exception allow such uses if there was a use of the\n      same SSA name on the old stmt.  */\n-  if ((TREE_CODE (ops[0]) == SSA_NAME\n-       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[0])\n-       && !has_use_on_stmt (ops[0], stmt))\n-      || (ops[1]\n-\t  && TREE_CODE (ops[1]) == SSA_NAME\n-\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[1])\n-\t  && !has_use_on_stmt (ops[1], stmt))\n-      || (ops[2]\n-\t  && TREE_CODE (ops[2]) == SSA_NAME\n-\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[2])\n-\t  && !has_use_on_stmt (ops[2], stmt))\n-      || (COMPARISON_CLASS_P (ops[0])\n-\t  && ((TREE_CODE (TREE_OPERAND (ops[0], 0)) == SSA_NAME\n-\t       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (ops[0], 0))\n-\t       && !has_use_on_stmt (TREE_OPERAND (ops[0], 0), stmt))\n-\t      || (TREE_CODE (TREE_OPERAND (ops[0], 1)) == SSA_NAME\n-\t\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (ops[0], 1))\n-\t\t  && !has_use_on_stmt (TREE_OPERAND (ops[0], 1), stmt)))))\n-    return false;\n+  for (unsigned int i = 0; i < num_ops; ++i)\n+    if (TREE_CODE (ops[i]) == SSA_NAME\n+\t&& SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[i])\n+\t&& !has_use_on_stmt (ops[i], stmt))\n+      return false;\n+\n+  if (num_ops > 0 && COMPARISON_CLASS_P (ops[0]))\n+    for (unsigned int i = 0; i < 2; ++i)\n+      if (TREE_CODE (TREE_OPERAND (ops[0], i)) == SSA_NAME\n+\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (ops[0], i))\n+\t  && !has_use_on_stmt (TREE_OPERAND (ops[0], i), stmt))\n+\treturn false;\n \n   /* Don't insert new statements when INPLACE is true, even if we could\n      reuse STMT for the final statement.  */\n@@ -4396,19 +4391,19 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n \n   if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n     {\n-      gcc_assert (rcode.is_tree_code ());\n-      if (TREE_CODE_CLASS ((enum tree_code)rcode) == tcc_comparison\n+      gcc_assert (res_op->code.is_tree_code ());\n+      if (TREE_CODE_CLASS ((enum tree_code) res_op->code) == tcc_comparison\n \t  /* GIMPLE_CONDs condition may not throw.  */\n \t  && (!flag_exceptions\n \t      || !cfun->can_throw_non_call_exceptions\n-\t      || !operation_could_trap_p (rcode,\n+\t      || !operation_could_trap_p (res_op->code,\n \t\t\t\t\t  FLOAT_TYPE_P (TREE_TYPE (ops[0])),\n \t\t\t\t\t  false, NULL_TREE)))\n-\tgimple_cond_set_condition (cond_stmt, rcode, ops[0], ops[1]);\n-      else if (rcode == SSA_NAME)\n+\tgimple_cond_set_condition (cond_stmt, res_op->code, ops[0], ops[1]);\n+      else if (res_op->code == SSA_NAME)\n \tgimple_cond_set_condition (cond_stmt, NE_EXPR, ops[0],\n \t\t\t\t   build_zero_cst (TREE_TYPE (ops[0])));\n-      else if (rcode == INTEGER_CST)\n+      else if (res_op->code == INTEGER_CST)\n \t{\n \t  if (integer_zerop (ops[0]))\n \t    gimple_cond_make_false (cond_stmt);\n@@ -4417,8 +4412,7 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n \t}\n       else if (!inplace)\n \t{\n-\t  tree res = maybe_push_res_to_seq (rcode, boolean_type_node,\n-\t\t\t\t\t    ops, seq);\n+\t  tree res = maybe_push_res_to_seq (res_op, seq);\n \t  if (!res)\n \t    return false;\n \t  gimple_cond_set_condition (cond_stmt, NE_EXPR, res,\n@@ -4438,14 +4432,16 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n       return true;\n     }\n   else if (is_gimple_assign (stmt)\n-\t   && rcode.is_tree_code ())\n+\t   && res_op->code.is_tree_code ())\n     {\n       if (!inplace\n-\t  || gimple_num_ops (stmt) > get_gimple_rhs_num_ops (rcode))\n+\t  || gimple_num_ops (stmt) > get_gimple_rhs_num_ops (res_op->code))\n \t{\n-\t  maybe_build_generic_op (rcode,\n-\t\t\t\t  TREE_TYPE (gimple_assign_lhs (stmt)), ops);\n-\t  gimple_assign_set_rhs_with_ops (gsi, rcode, ops[0], ops[1], ops[2]);\n+\t  maybe_build_generic_op (res_op);\n+\t  gimple_assign_set_rhs_with_ops (gsi, res_op->code,\n+\t\t\t\t\t  res_op->op_or_null (0),\n+\t\t\t\t\t  res_op->op_or_null (1),\n+\t\t\t\t\t  res_op->op_or_null (2));\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"gimple_simplified to \");\n@@ -4458,17 +4454,12 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n \t  return true;\n \t}\n     }\n-  else if (rcode.is_fn_code ()\n-\t   && gimple_call_combined_fn (stmt) == rcode)\n+  else if (res_op->code.is_fn_code ()\n+\t   && gimple_call_combined_fn (stmt) == res_op->code)\n     {\n-      unsigned i;\n-      for (i = 0; i < gimple_call_num_args (stmt); ++i)\n-\t{\n-\t  gcc_assert (ops[i] != NULL_TREE);\n-\t  gimple_call_set_arg (stmt, i, ops[i]);\n-\t}\n-      if (i < 3)\n-\tgcc_assert (ops[i] == NULL_TREE);\n+      gcc_assert (num_ops == gimple_call_num_args (stmt));\n+      for (unsigned int i = 0; i < num_ops; ++i)\n+\tgimple_call_set_arg (stmt, i, ops[i]);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"gimple_simplified to \");\n@@ -4484,8 +4475,7 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n       if (gimple_has_lhs (stmt))\n \t{\n \t  tree lhs = gimple_get_lhs (stmt);\n-\t  if (!maybe_push_res_to_seq (rcode, TREE_TYPE (lhs),\n-\t\t\t\t      ops, seq, lhs))\n+\t  if (!maybe_push_res_to_seq (res_op, seq, lhs))\n \t    return false;\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -4751,12 +4741,11 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n       || gimple_code (stmt) == GIMPLE_COND)\n     {\n       gimple_seq seq = NULL;\n-      code_helper rcode;\n-      tree ops[3] = {};\n-      if (gimple_simplify (stmt, &rcode, ops, inplace ? NULL : &seq,\n+      gimple_match_op res_op;\n+      if (gimple_simplify (stmt, &res_op, inplace ? NULL : &seq,\n \t\t\t   valueize, valueize))\n \t{\n-\t  if (replace_stmt_with_simplification (gsi, rcode, ops, &seq, inplace))\n+\t  if (replace_stmt_with_simplification (gsi, &res_op, &seq, inplace))\n \t    changed = true;\n \t  else\n \t    gimple_seq_discard (seq);\n@@ -6106,19 +6095,18 @@ tree\n gimple_fold_stmt_to_constant_1 (gimple *stmt, tree (*valueize) (tree),\n \t\t\t\ttree (*gvalueize) (tree))\n {\n-  code_helper rcode;\n-  tree ops[3] = {};\n+  gimple_match_op res_op;\n   /* ???  The SSA propagators do not correctly deal with following SSA use-def\n      edges if there are intermediate VARYING defs.  For this reason\n      do not follow SSA edges here even though SCCVN can technically\n      just deal fine with that.  */\n-  if (gimple_simplify (stmt, &rcode, ops, NULL, gvalueize, valueize))\n+  if (gimple_simplify (stmt, &res_op, NULL, gvalueize, valueize))\n     {\n       tree res = NULL_TREE;\n-      if (gimple_simplified_result_is_gimple_val (rcode, ops))\n-\tres = ops[0];\n+      if (gimple_simplified_result_is_gimple_val (&res_op))\n+\tres = res_op.ops[0];\n       else if (mprts_hook)\n-\tres = mprts_hook (rcode, gimple_expr_type (stmt), ops);\n+\tres = mprts_hook (&res_op);\n       if (res)\n \t{\n \t  if (dump_file && dump_flags & TDF_DETAILS)"}, {"sha": "4598781e61c3fb589bbdf3dfda6d2e0af0aff341", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 181, "deletions": 229, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=5d75ad95aa808d6767afc0cdadd3b62e831c5cdf", "patch": "@@ -45,16 +45,14 @@ along with GCC; see the file COPYING3.  If not see\n /* Forward declarations of the private auto-generated matchers.\n    They expect valueized operands in canonical order and do not\n    perform simplification of all-constant operands.  */\n-static bool gimple_simplify (code_helper *, tree *,\n-\t\t\t     gimple_seq *, tree (*)(tree),\n+static bool gimple_simplify (gimple_match_op *, gimple_seq *, tree (*)(tree),\n \t\t\t     code_helper, tree, tree);\n-static bool gimple_simplify (code_helper *, tree *,\n-\t\t\t     gimple_seq *, tree (*)(tree),\n+static bool gimple_simplify (gimple_match_op *, gimple_seq *, tree (*)(tree),\n \t\t\t     code_helper, tree, tree, tree);\n-static bool gimple_simplify (code_helper *, tree *,\n-\t\t\t     gimple_seq *, tree (*)(tree),\n+static bool gimple_simplify (gimple_match_op *, gimple_seq *, tree (*)(tree),\n \t\t\t     code_helper, tree, tree, tree, tree);\n \n+const unsigned int gimple_match_op::MAX_NUM_OPS;\n \n /* Return whether T is a constant that we'll dispatch to fold to\n    evaluate fully constant expressions.  */\n@@ -72,43 +70,36 @@ constant_for_folding (tree t)\n /* Helper that matches and simplifies the toplevel result from\n    a gimple_simplify run (where we don't want to build\n    a stmt in case it's used in in-place folding).  Replaces\n-   *RES_CODE and *RES_OPS with a simplified and/or canonicalized\n-   result and returns whether any change was made.  */\n+   RES_OP with a simplified and/or canonicalized result and\n+   returns whether any change was made.  */\n \n bool\n-gimple_resimplify1 (gimple_seq *seq,\n-\t\t    code_helper *res_code, tree type, tree *res_ops,\n+gimple_resimplify1 (gimple_seq *seq, gimple_match_op *res_op,\n \t\t    tree (*valueize)(tree))\n {\n-  if (constant_for_folding (res_ops[0]))\n+  if (constant_for_folding (res_op->ops[0]))\n     {\n       tree tem = NULL_TREE;\n-      if (res_code->is_tree_code ())\n-\ttem = const_unop (*res_code, type, res_ops[0]);\n+      if (res_op->code.is_tree_code ())\n+\ttem = const_unop (res_op->code, res_op->type, res_op->ops[0]);\n       else\n-\ttem = fold_const_call (combined_fn (*res_code), type, res_ops[0]);\n+\ttem = fold_const_call (combined_fn (res_op->code), res_op->type,\n+\t\t\t       res_op->ops[0]);\n       if (tem != NULL_TREE\n \t  && CONSTANT_CLASS_P (tem))\n \t{\n \t  if (TREE_OVERFLOW_P (tem))\n \t    tem = drop_tree_overflow (tem);\n-\t  res_ops[0] = tem;\n-\t  res_ops[1] = NULL_TREE;\n-\t  res_ops[2] = NULL_TREE;\n-\t  *res_code = TREE_CODE (res_ops[0]);\n+\t  res_op->set_value (tem);\n \t  return true;\n \t}\n     }\n \n-  code_helper res_code2;\n-  tree res_ops2[3] = {};\n-  if (gimple_simplify (&res_code2, res_ops2, seq, valueize,\n-\t\t       *res_code, type, res_ops[0]))\n+  gimple_match_op res_op2 (*res_op);\n+  if (gimple_simplify (&res_op2, seq, valueize,\n+\t\t       res_op->code, res_op->type, res_op->ops[0]))\n     {\n-      *res_code = res_code2;\n-      res_ops[0] = res_ops2[0];\n-      res_ops[1] = res_ops2[1];\n-      res_ops[2] = res_ops2[2];\n+      *res_op = res_op2;\n       return true;\n     }\n \n@@ -118,57 +109,52 @@ gimple_resimplify1 (gimple_seq *seq,\n /* Helper that matches and simplifies the toplevel result from\n    a gimple_simplify run (where we don't want to build\n    a stmt in case it's used in in-place folding).  Replaces\n-   *RES_CODE and *RES_OPS with a simplified and/or canonicalized\n-   result and returns whether any change was made.  */\n+   RES_OP with a simplified and/or canonicalized result and\n+   returns whether any change was made.  */\n \n bool\n-gimple_resimplify2 (gimple_seq *seq,\n-\t\t    code_helper *res_code, tree type, tree *res_ops,\n+gimple_resimplify2 (gimple_seq *seq, gimple_match_op *res_op,\n \t\t    tree (*valueize)(tree))\n {\n-  if (constant_for_folding (res_ops[0]) && constant_for_folding (res_ops[1]))\n+  if (constant_for_folding (res_op->ops[0])\n+      && constant_for_folding (res_op->ops[1]))\n     {\n       tree tem = NULL_TREE;\n-      if (res_code->is_tree_code ())\n-\ttem = const_binop (*res_code, type, res_ops[0], res_ops[1]);\n+      if (res_op->code.is_tree_code ())\n+\ttem = const_binop (res_op->code, res_op->type,\n+\t\t\t   res_op->ops[0], res_op->ops[1]);\n       else\n-\ttem = fold_const_call (combined_fn (*res_code), type,\n-\t\t\t       res_ops[0], res_ops[1]);\n+\ttem = fold_const_call (combined_fn (res_op->code), res_op->type,\n+\t\t\t       res_op->ops[0], res_op->ops[1]);\n       if (tem != NULL_TREE\n \t  && CONSTANT_CLASS_P (tem))\n \t{\n \t  if (TREE_OVERFLOW_P (tem))\n \t    tem = drop_tree_overflow (tem);\n-\t  res_ops[0] = tem;\n-\t  res_ops[1] = NULL_TREE;\n-\t  res_ops[2] = NULL_TREE;\n-\t  *res_code = TREE_CODE (res_ops[0]);\n+\t  res_op->set_value (tem);\n \t  return true;\n \t}\n     }\n \n   /* Canonicalize operand order.  */\n   bool canonicalized = false;\n-  if (res_code->is_tree_code ()\n-      && (TREE_CODE_CLASS ((enum tree_code) *res_code) == tcc_comparison\n-\t  || commutative_tree_code (*res_code))\n-      && tree_swap_operands_p (res_ops[0], res_ops[1]))\n+  if (res_op->code.is_tree_code ()\n+      && (TREE_CODE_CLASS ((enum tree_code) res_op->code) == tcc_comparison\n+\t  || commutative_tree_code (res_op->code))\n+      && tree_swap_operands_p (res_op->ops[0], res_op->ops[1]))\n     {\n-      std::swap (res_ops[0], res_ops[1]);\n-      if (TREE_CODE_CLASS ((enum tree_code) *res_code) == tcc_comparison)\n-\t*res_code = swap_tree_comparison (*res_code);\n+      std::swap (res_op->ops[0], res_op->ops[1]);\n+      if (TREE_CODE_CLASS ((enum tree_code) res_op->code) == tcc_comparison)\n+\tres_op->code = swap_tree_comparison (res_op->code);\n       canonicalized = true;\n     }\n \n-  code_helper res_code2;\n-  tree res_ops2[3] = {};\n-  if (gimple_simplify (&res_code2, res_ops2, seq, valueize,\n-\t\t       *res_code, type, res_ops[0], res_ops[1]))\n+  gimple_match_op res_op2 (*res_op);\n+  if (gimple_simplify (&res_op2, seq, valueize,\n+\t\t       res_op->code, res_op->type,\n+\t\t       res_op->ops[0], res_op->ops[1]))\n     {\n-      *res_code = res_code2;\n-      res_ops[0] = res_ops2[0];\n-      res_ops[1] = res_ops2[1];\n-      res_ops[2] = res_ops2[2];\n+      *res_op = res_op2;\n       return true;\n     }\n \n@@ -178,180 +164,168 @@ gimple_resimplify2 (gimple_seq *seq,\n /* Helper that matches and simplifies the toplevel result from\n    a gimple_simplify run (where we don't want to build\n    a stmt in case it's used in in-place folding).  Replaces\n-   *RES_CODE and *RES_OPS with a simplified and/or canonicalized\n-   result and returns whether any change was made.  */\n+   RES_OP with a simplified and/or canonicalized result and\n+   returns whether any change was made.  */\n \n bool\n-gimple_resimplify3 (gimple_seq *seq,\n-\t\t    code_helper *res_code, tree type, tree *res_ops,\n+gimple_resimplify3 (gimple_seq *seq, gimple_match_op *res_op,\n \t\t    tree (*valueize)(tree))\n {\n-  if (constant_for_folding (res_ops[0]) && constant_for_folding (res_ops[1])\n-      && constant_for_folding (res_ops[2]))\n+  if (constant_for_folding (res_op->ops[0])\n+      && constant_for_folding (res_op->ops[1])\n+      && constant_for_folding (res_op->ops[2]))\n     {\n       tree tem = NULL_TREE;\n-      if (res_code->is_tree_code ())\n-\ttem = fold_ternary/*_to_constant*/ (*res_code, type, res_ops[0],\n-\t\t\t\t\t    res_ops[1], res_ops[2]);\n+      if (res_op->code.is_tree_code ())\n+\ttem = fold_ternary/*_to_constant*/ (res_op->code, res_op->type,\n+\t\t\t\t\t    res_op->ops[0], res_op->ops[1],\n+\t\t\t\t\t    res_op->ops[2]);\n       else\n-\ttem = fold_const_call (combined_fn (*res_code), type,\n-\t\t\t       res_ops[0], res_ops[1], res_ops[2]);\n+\ttem = fold_const_call (combined_fn (res_op->code), res_op->type,\n+\t\t\t       res_op->ops[0], res_op->ops[1], res_op->ops[2]);\n       if (tem != NULL_TREE\n \t  && CONSTANT_CLASS_P (tem))\n \t{\n \t  if (TREE_OVERFLOW_P (tem))\n \t    tem = drop_tree_overflow (tem);\n-\t  res_ops[0] = tem;\n-\t  res_ops[1] = NULL_TREE;\n-\t  res_ops[2] = NULL_TREE;\n-\t  *res_code = TREE_CODE (res_ops[0]);\n+\t  res_op->set_value (tem);\n \t  return true;\n \t}\n     }\n \n   /* Canonicalize operand order.  */\n   bool canonicalized = false;\n-  if (res_code->is_tree_code ()\n-      && commutative_ternary_tree_code (*res_code)\n-      && tree_swap_operands_p (res_ops[0], res_ops[1]))\n+  if (res_op->code.is_tree_code ()\n+      && commutative_ternary_tree_code (res_op->code)\n+      && tree_swap_operands_p (res_op->ops[0], res_op->ops[1]))\n     {\n-      std::swap (res_ops[0], res_ops[1]);\n+      std::swap (res_op->ops[0], res_op->ops[1]);\n       canonicalized = true;\n     }\n \n-  code_helper res_code2;\n-  tree res_ops2[3] = {};\n-  if (gimple_simplify (&res_code2, res_ops2, seq, valueize,\n-\t\t       *res_code, type,\n-\t\t       res_ops[0], res_ops[1], res_ops[2]))\n+  gimple_match_op res_op2 (*res_op);\n+  if (gimple_simplify (&res_op2, seq, valueize,\n+\t\t       res_op->code, res_op->type,\n+\t\t       res_op->ops[0], res_op->ops[1], res_op->ops[2]))\n     {\n-      *res_code = res_code2;\n-      res_ops[0] = res_ops2[0];\n-      res_ops[1] = res_ops2[1];\n-      res_ops[2] = res_ops2[2];\n+      *res_op = res_op2;\n       return true;\n     }\n \n   return canonicalized;\n }\n \n \n-/* If in GIMPLE expressions with CODE go as single-rhs build\n-   a GENERIC tree for that expression into *OP0.  */\n+/* If in GIMPLE the operation described by RES_OP should be single-rhs,\n+   build a GENERIC tree for that expression and update RES_OP accordingly.  */\n \n void\n-maybe_build_generic_op (enum tree_code code, tree type, tree *ops)\n+maybe_build_generic_op (gimple_match_op *res_op)\n {\n+  tree_code code = (tree_code) res_op->code;\n   switch (code)\n     {\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n     case VIEW_CONVERT_EXPR:\n-      ops[0] = build1 (code, type, ops[0]);\n+      res_op->set_value (build1 (code, res_op->type, res_op->ops[0]));\n       break;\n     case BIT_FIELD_REF:\n-      ops[0] = build3 (code, type, ops[0], ops[1], ops[2]);\n-      ops[1] = ops[2] = NULL_TREE;\n+      res_op->set_value (build3 (code, res_op->type, res_op->ops[0],\n+\t\t\t\t res_op->ops[1], res_op->ops[2]));\n       break;\n     default:;\n     }\n }\n \n-tree (*mprts_hook) (code_helper, tree, tree *);\n+tree (*mprts_hook) (gimple_match_op *);\n \n-/* Try to build a call to FN with return type TYPE and the NARGS\n-   arguments given in OPS.  Return null if the target doesn't support\n-   the function.  */\n+/* Try to build RES_OP, which is known to be a call to FN.  Return null\n+   if the target doesn't support the function.  */\n \n static gcall *\n-build_call_internal (internal_fn fn, tree type, unsigned int nargs, tree *ops)\n+build_call_internal (internal_fn fn, gimple_match_op *res_op)\n {\n   if (direct_internal_fn_p (fn))\n     {\n-      tree_pair types = direct_internal_fn_types (fn, type, ops);\n+      tree_pair types = direct_internal_fn_types (fn, res_op->type,\n+\t\t\t\t\t\t  res_op->ops);\n       if (!direct_internal_fn_supported_p (fn, types, OPTIMIZE_FOR_BOTH))\n \treturn NULL;\n     }\n-  return gimple_build_call_internal (fn, nargs, ops[0], ops[1], ops[2]);\n+  return gimple_build_call_internal (fn, res_op->num_ops,\n+\t\t\t\t     res_op->op_or_null (0),\n+\t\t\t\t     res_op->op_or_null (1),\n+\t\t\t\t     res_op->op_or_null (2));\n }\n \n-/* Push the exploded expression described by RCODE, TYPE and OPS\n-   as a statement to SEQ if necessary and return a gimple value\n-   denoting the value of the expression.  If RES is not NULL\n-   then the result will be always RES and even gimple values are\n-   pushed to SEQ.  */\n+/* Push the exploded expression described by RES_OP as a statement to\n+   SEQ if necessary and return a gimple value denoting the value of the\n+   expression.  If RES is not NULL then the result will be always RES\n+   and even gimple values are pushed to SEQ.  */\n \n tree\n-maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n-\t\t       gimple_seq *seq, tree res)\n+maybe_push_res_to_seq (gimple_match_op *res_op, gimple_seq *seq, tree res)\n {\n-  if (rcode.is_tree_code ())\n+  tree *ops = res_op->ops;\n+  unsigned num_ops = res_op->num_ops;\n+\n+  if (res_op->code.is_tree_code ())\n     {\n       if (!res\n-\t  && gimple_simplified_result_is_gimple_val (rcode, ops))\n+\t  && gimple_simplified_result_is_gimple_val (res_op))\n \treturn ops[0];\n       if (mprts_hook)\n \t{\n-\t  tree tem = mprts_hook (rcode, type, ops);\n+\t  tree tem = mprts_hook (res_op);\n \t  if (tem)\n \t    return tem;\n \t}\n-      if (!seq)\n-\treturn NULL_TREE;\n-      /* Play safe and do not allow abnormals to be mentioned in\n-         newly created statements.  */\n-      if ((TREE_CODE (ops[0]) == SSA_NAME\n-\t   && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[0]))\n-\t  || (ops[1]\n-\t      && TREE_CODE (ops[1]) == SSA_NAME\n-\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[1]))\n-\t  || (ops[2]\n-\t      && TREE_CODE (ops[2]) == SSA_NAME\n-\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[2]))\n-\t  || (COMPARISON_CLASS_P (ops[0])\n-\t      && ((TREE_CODE (TREE_OPERAND (ops[0], 0)) == SSA_NAME\n-\t\t   && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (ops[0],\n-\t\t\t\t\t\t\t\t     0)))\n-\t\t  || (TREE_CODE (TREE_OPERAND (ops[0], 1)) == SSA_NAME\n-\t\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (ops[0],\n-\t\t\t\t\t\t\t\t\t1))))))\n+    }\n+\n+  if (!seq)\n+    return NULL_TREE;\n+\n+  /* Play safe and do not allow abnormals to be mentioned in\n+     newly created statements.  */\n+  for (unsigned int i = 0; i < num_ops; ++i)\n+    if (TREE_CODE (ops[i]) == SSA_NAME\n+\t&& SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[i]))\n+      return NULL_TREE;\n+\n+  if (num_ops > 0 && COMPARISON_CLASS_P (ops[0]))\n+    for (unsigned int i = 0; i < 2; ++i)\n+      if (TREE_CODE (TREE_OPERAND (ops[0], i)) == SSA_NAME\n+\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (ops[0], i)))\n \treturn NULL_TREE;\n+\n+  if (res_op->code.is_tree_code ())\n+    {\n       if (!res)\n \t{\n \t  if (gimple_in_ssa_p (cfun))\n-\t    res = make_ssa_name (type);\n+\t    res = make_ssa_name (res_op->type);\n \t  else\n-\t    res = create_tmp_reg (type);\n+\t    res = create_tmp_reg (res_op->type);\n \t}\n-      maybe_build_generic_op (rcode, type, ops);\n-      gimple *new_stmt = gimple_build_assign (res, rcode,\n-\t\t\t\t\t     ops[0], ops[1], ops[2]);\n+      maybe_build_generic_op (res_op);\n+      gimple *new_stmt = gimple_build_assign (res, res_op->code,\n+\t\t\t\t\t      res_op->op_or_null (0),\n+\t\t\t\t\t      res_op->op_or_null (1),\n+\t\t\t\t\t      res_op->op_or_null (2));\n       gimple_seq_add_stmt_without_update (seq, new_stmt);\n       return res;\n     }\n   else\n     {\n-      if (!seq)\n-\treturn NULL_TREE;\n-      combined_fn fn = rcode;\n-      /* Play safe and do not allow abnormals to be mentioned in\n-         newly created statements.  */\n-      unsigned nargs;\n-      for (nargs = 0; nargs < 3; ++nargs)\n-\t{\n-\t  if (!ops[nargs])\n-\t    break;\n-\t  if (TREE_CODE (ops[nargs]) == SSA_NAME\n-\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[nargs]))\n-\t    return NULL_TREE;\n-\t}\n-      gcc_assert (nargs != 0);\n+      gcc_assert (num_ops != 0);\n+      combined_fn fn = res_op->code;\n       gcall *new_stmt = NULL;\n       if (internal_fn_p (fn))\n \t{\n \t  /* Generate the given function if we can.  */\n \t  internal_fn ifn = as_internal_fn (fn);\n-\t  new_stmt = build_call_internal (ifn, type, nargs, ops);\n+\t  new_stmt = build_call_internal (ifn, res_op);\n \t  if (!new_stmt)\n \t    return NULL_TREE;\n \t}\n@@ -366,14 +340,17 @@ maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n \t  if (!(flags_from_decl_or_type (decl) & ECF_CONST))\n \t    return NULL;\n \n-\t  new_stmt = gimple_build_call (decl, nargs, ops[0], ops[1], ops[2]);\n+\t  new_stmt = gimple_build_call (decl, num_ops,\n+\t\t\t\t\tres_op->op_or_null (0),\n+\t\t\t\t\tres_op->op_or_null (1),\n+\t\t\t\t\tres_op->op_or_null (2));\n \t}\n       if (!res)\n \t{\n \t  if (gimple_in_ssa_p (cfun))\n-\t    res = make_ssa_name (type);\n+\t    res = make_ssa_name (res_op->type);\n \t  else\n-\t    res = create_tmp_reg (type);\n+\t    res = create_tmp_reg (res_op->type);\n \t}\n       gimple_call_set_lhs (new_stmt, res);\n       gimple_seq_add_stmt_without_update (seq, new_stmt);\n@@ -406,12 +383,10 @@ gimple_simplify (enum tree_code code, tree type,\n \treturn res;\n     }\n \n-  code_helper rcode;\n-  tree ops[3] = {};\n-  if (!gimple_simplify (&rcode, ops, seq, valueize,\n-\t\t\tcode, type, op0))\n+  gimple_match_op res_op;\n+  if (!gimple_simplify (&res_op, seq, valueize, code, type, op0))\n     return NULL_TREE;\n-  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+  return maybe_push_res_to_seq (&res_op, seq);\n }\n \n /* Binary ops.  */\n@@ -440,12 +415,10 @@ gimple_simplify (enum tree_code code, tree type,\n \tcode = swap_tree_comparison (code);\n     }\n \n-  code_helper rcode;\n-  tree ops[3] = {};\n-  if (!gimple_simplify (&rcode, ops, seq, valueize,\n-\t\t\tcode, type, op0, op1))\n+  gimple_match_op res_op;\n+  if (!gimple_simplify (&res_op, seq, valueize, code, type, op0, op1))\n     return NULL_TREE;\n-  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+  return maybe_push_res_to_seq (&res_op, seq);\n }\n \n /* Ternary ops.  */\n@@ -470,12 +443,10 @@ gimple_simplify (enum tree_code code, tree type,\n       && tree_swap_operands_p (op0, op1))\n     std::swap (op0, op1);\n \n-  code_helper rcode;\n-  tree ops[3] = {};\n-  if (!gimple_simplify (&rcode, ops, seq, valueize,\n-\t\t\tcode, type, op0, op1, op2))\n+  gimple_match_op res_op;\n+  if (!gimple_simplify (&res_op, seq, valueize, code, type, op0, op1, op2))\n     return NULL_TREE;\n-  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+  return maybe_push_res_to_seq (&res_op, seq);\n }\n \n /* Builtin or internal function with one argument.  */\n@@ -492,11 +463,10 @@ gimple_simplify (combined_fn fn, tree type,\n \treturn res;\n     }\n \n-  code_helper rcode;\n-  tree ops[3] = {};\n-  if (!gimple_simplify (&rcode, ops, seq, valueize, fn, type, arg0))\n+  gimple_match_op res_op;\n+  if (!gimple_simplify (&res_op, seq, valueize, fn, type, arg0))\n     return NULL_TREE;\n-  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+  return maybe_push_res_to_seq (&res_op, seq);\n }\n \n /* Builtin or internal function with two arguments.  */\n@@ -514,11 +484,10 @@ gimple_simplify (combined_fn fn, tree type,\n \treturn res;\n     }\n \n-  code_helper rcode;\n-  tree ops[3] = {};\n-  if (!gimple_simplify (&rcode, ops, seq, valueize, fn, type, arg0, arg1))\n+  gimple_match_op res_op;\n+  if (!gimple_simplify (&res_op, seq, valueize, fn, type, arg0, arg1))\n     return NULL_TREE;\n-  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+  return maybe_push_res_to_seq (&res_op, seq);\n }\n \n /* Builtin or internal function with three arguments.  */\n@@ -537,12 +506,10 @@ gimple_simplify (combined_fn fn, tree type,\n \treturn res;\n     }\n \n-  code_helper rcode;\n-  tree ops[3] = {};\n-  if (!gimple_simplify (&rcode, ops, seq, valueize,\n-\t\t\tfn, type, arg0, arg1, arg2))\n+  gimple_match_op res_op;\n+  if (!gimple_simplify (&res_op, seq, valueize, fn, type, arg0, arg1, arg2))\n     return NULL_TREE;\n-  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+  return maybe_push_res_to_seq (&res_op, seq);\n }\n \n /* Helper for gimple_simplify valueizing OP using VALUEIZE and setting\n@@ -567,9 +534,7 @@ do_valueize (tree op, tree (*valueize)(tree), bool &valueized)\n    and the fold_stmt_to_constant APIs.  */\n \n bool\n-gimple_simplify (gimple *stmt,\n-\t\t code_helper *rcode, tree *ops,\n-\t\t gimple_seq *seq,\n+gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n \t\t tree (*valueize)(tree), tree (*top_valueize)(tree))\n {\n   switch (gimple_code (stmt))\n@@ -588,9 +553,8 @@ gimple_simplify (gimple *stmt,\n \t\ttree op0 = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n \t\tbool valueized = false;\n \t\top0 = do_valueize (op0, top_valueize, valueized);\n-\t\t*rcode = code;\n-\t\tops[0] = op0;\n-\t\treturn (gimple_resimplify1 (seq, rcode, type, ops, valueize)\n+\t\tres_op->set_op (code, type, op0);\n+\t\treturn (gimple_resimplify1 (seq, res_op, valueize)\n \t\t\t|| valueized);\n \t      }\n \t    else if (code == BIT_FIELD_REF)\n@@ -599,11 +563,10 @@ gimple_simplify (gimple *stmt,\n \t\ttree op0 = TREE_OPERAND (rhs1, 0);\n \t\tbool valueized = false;\n \t\top0 = do_valueize (op0, top_valueize, valueized);\n-\t\t*rcode = code;\n-\t\tops[0] = op0;\n-\t\tops[1] = TREE_OPERAND (rhs1, 1);\n-\t\tops[2] = TREE_OPERAND (rhs1, 2);\n-\t\treturn (gimple_resimplify3 (seq, rcode, type, ops, valueize)\n+\t\tres_op->set_op (code, type, op0,\n+\t\t\t\tTREE_OPERAND (rhs1, 1),\n+\t\t\t\tTREE_OPERAND (rhs1, 2));\n+\t\treturn (gimple_resimplify3 (seq, res_op, valueize)\n \t\t\t|| valueized);\n \t      }\n \t    else if (code == SSA_NAME\n@@ -613,8 +576,7 @@ gimple_simplify (gimple *stmt,\n \t\ttree valueized = top_valueize (op0);\n \t\tif (!valueized || op0 == valueized)\n \t\t  return false;\n-\t\tops[0] = valueized;\n-\t\t*rcode = TREE_CODE (op0);\n+\t\tres_op->set_op (TREE_CODE (op0), type, valueized);\n \t\treturn true;\n \t      }\n \t    break;\n@@ -623,9 +585,8 @@ gimple_simplify (gimple *stmt,\n \t      tree rhs1 = gimple_assign_rhs1 (stmt);\n \t      bool valueized = false;\n \t      rhs1 = do_valueize (rhs1, top_valueize, valueized);\n-\t      *rcode = code;\n-\t      ops[0] = rhs1;\n-\t      return (gimple_resimplify1 (seq, rcode, type, ops, valueize)\n+\t      res_op->set_op (code, type, rhs1);\n+\t      return (gimple_resimplify1 (seq, res_op, valueize)\n \t\t      || valueized);\n \t    }\n \t  case GIMPLE_BINARY_RHS:\n@@ -635,10 +596,8 @@ gimple_simplify (gimple *stmt,\n \t      bool valueized = false;\n \t      rhs1 = do_valueize (rhs1, top_valueize, valueized);\n \t      rhs2 = do_valueize (rhs2, top_valueize, valueized);\n-\t      *rcode = code;\n-\t      ops[0] = rhs1;\n-\t      ops[1] = rhs2;\n-\t      return (gimple_resimplify2 (seq, rcode, type, ops, valueize)\n+\t      res_op->set_op (code, type, rhs1, rhs2);\n+\t      return (gimple_resimplify2 (seq, res_op, valueize)\n \t\t      || valueized);\n \t    }\n \t  case GIMPLE_TERNARY_RHS:\n@@ -656,24 +615,21 @@ gimple_simplify (gimple *stmt,\n \t\t      tree rhs = TREE_OPERAND (rhs1, 1);\n \t\t      lhs = do_valueize (lhs, top_valueize, valueized);\n \t\t      rhs = do_valueize (rhs, top_valueize, valueized);\n-\t\t      code_helper rcode2 = TREE_CODE (rhs1);\n-\t\t      tree ops2[3] = {};\n-\t\t      ops2[0] = lhs;\n-\t\t      ops2[1] = rhs;\n-\t\t      if ((gimple_resimplify2 (seq, &rcode2, TREE_TYPE (rhs1),\n-\t\t\t\t\t       ops2, valueize)\n+\t\t      gimple_match_op res_op2 (TREE_CODE (rhs1),\n+\t\t\t\t\t       TREE_TYPE (rhs1), lhs, rhs);\n+\t\t      if ((gimple_resimplify2 (seq, &res_op2, valueize)\n \t\t\t   || valueized)\n-\t\t\t  && rcode2.is_tree_code ())\n+\t\t\t  && res_op2.code.is_tree_code ())\n \t\t\t{\n \t\t\t  valueized = true;\n-\t\t\t  if (TREE_CODE_CLASS ((enum tree_code)rcode2)\n+\t\t\t  if (TREE_CODE_CLASS ((enum tree_code) res_op2.code)\n \t\t\t      == tcc_comparison)\n-\t\t\t    rhs1 = build2 (rcode2, TREE_TYPE (rhs1),\n-\t\t\t\t\t   ops2[0], ops2[1]);\n-\t\t\t  else if (rcode2 == SSA_NAME\n-\t\t\t\t   || rcode2 == INTEGER_CST\n-\t\t\t\t   || rcode2 == VECTOR_CST)\n-\t\t\t    rhs1 = ops2[0];\n+\t\t\t    rhs1 = build2 (res_op2.code, TREE_TYPE (rhs1),\n+\t\t\t\t\t   res_op2.ops[0], res_op2.ops[1]);\n+\t\t\t  else if (res_op2.code == SSA_NAME\n+\t\t\t\t   || res_op2.code == INTEGER_CST\n+\t\t\t\t   || res_op2.code == VECTOR_CST)\n+\t\t\t    rhs1 = res_op2.ops[0];\n \t\t\t  else\n \t\t\t    valueized = false;\n \t\t\t}\n@@ -684,11 +640,8 @@ gimple_simplify (gimple *stmt,\n \t      rhs1 = do_valueize (rhs1, top_valueize, valueized);\n \t      rhs2 = do_valueize (rhs2, top_valueize, valueized);\n \t      rhs3 = do_valueize (rhs3, top_valueize, valueized);\n-\t      *rcode = code;\n-\t      ops[0] = rhs1;\n-\t      ops[1] = rhs2;\n-\t      ops[2] = rhs3;\n-\t      return (gimple_resimplify3 (seq, rcode, type, ops, valueize)\n+\t      res_op->set_op (code, type, rhs1, rhs2, rhs3);\n+\t      return (gimple_resimplify3 (seq, res_op, valueize)\n \t\t      || valueized);\n \t    }\n \t  default:\n@@ -704,8 +657,9 @@ gimple_simplify (gimple *stmt,\n \t  && gimple_call_num_args (stmt) <= 3)\n \t{\n \t  bool valueized = false;\n+\t  combined_fn cfn;\n \t  if (gimple_call_internal_p (stmt))\n-\t    *rcode = as_combined_fn (gimple_call_internal_fn (stmt));\n+\t    cfn = as_combined_fn (gimple_call_internal_fn (stmt));\n \t  else\n \t    {\n \t      tree fn = gimple_call_fn (stmt);\n@@ -722,25 +676,26 @@ gimple_simplify (gimple *stmt,\n \t\t  || !gimple_builtin_call_types_compatible_p (stmt, decl))\n \t\treturn false;\n \n-\t      *rcode = as_combined_fn (DECL_FUNCTION_CODE (decl));\n+\t      cfn = as_combined_fn (DECL_FUNCTION_CODE (decl));\n \t    }\n \n-\t  tree type = TREE_TYPE (gimple_call_lhs (stmt));\n-\t  for (unsigned i = 0; i < gimple_call_num_args (stmt); ++i)\n+\t  unsigned int num_args = gimple_call_num_args (stmt);\n+\t  res_op->set_op (cfn, TREE_TYPE (gimple_call_lhs (stmt)), num_args);\n+\t  for (unsigned i = 0; i < num_args; ++i)\n \t    {\n \t      tree arg = gimple_call_arg (stmt, i);\n-\t      ops[i] = do_valueize (arg, top_valueize, valueized);\n+\t      res_op->ops[i] = do_valueize (arg, top_valueize, valueized);\n \t    }\n-\t  switch (gimple_call_num_args (stmt))\n+\t  switch (num_args)\n \t    {\n \t    case 1:\n-\t      return (gimple_resimplify1 (seq, rcode, type, ops, valueize)\n+\t      return (gimple_resimplify1 (seq, res_op, valueize)\n \t\t      || valueized);\n \t    case 2:\n-\t      return (gimple_resimplify2 (seq, rcode, type, ops, valueize)\n+\t      return (gimple_resimplify2 (seq, res_op, valueize)\n \t\t      || valueized);\n \t    case 3:\n-\t      return (gimple_resimplify3 (seq, rcode, type, ops, valueize)\n+\t      return (gimple_resimplify3 (seq, res_op, valueize)\n \t\t      || valueized);\n \t    default:\n \t     gcc_unreachable ();\n@@ -755,11 +710,8 @@ gimple_simplify (gimple *stmt,\n \tbool valueized = false;\n \tlhs = do_valueize (lhs, top_valueize, valueized);\n \trhs = do_valueize (rhs, top_valueize, valueized);\n-\t*rcode = gimple_cond_code (stmt);\n-\tops[0] = lhs;\n-\tops[1] = rhs;\n-        return (gimple_resimplify2 (seq, rcode,\n-\t\t\t\t    boolean_type_node, ops, valueize)\n+\tres_op->set_op (gimple_cond_code (stmt), boolean_type_node, lhs, rhs);\n+\treturn (gimple_resimplify2 (seq, res_op, valueize)\n \t\t|| valueized);\n       }\n "}, {"sha": "9a4d3bb630fd65cd9bb5658918bc3d8be1a89802", "filename": "gcc/gimple-match.h", "status": "modified", "additions": 152, "deletions": 18, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Fgimple-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Fgimple-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match.h?ref=5d75ad95aa808d6767afc0cdadd3b62e831c5cdf", "patch": "@@ -40,31 +40,165 @@ class code_helper\n   int rep;\n };\n \n-/* Return whether OPS[0] with CODE is a non-expression result and\n-   a gimple value.  */\n+/* Represents an operation to be simplified, or the result of the\n+   simplification.  */\n+struct gimple_match_op\n+{\n+  gimple_match_op () : type (NULL_TREE), num_ops (0) {}\n+  gimple_match_op (code_helper, tree, unsigned int);\n+  gimple_match_op (code_helper, tree, tree);\n+  gimple_match_op (code_helper, tree, tree, tree);\n+  gimple_match_op (code_helper, tree, tree, tree, tree);\n+\n+  void set_op (code_helper, tree, unsigned int);\n+  void set_op (code_helper, tree, tree);\n+  void set_op (code_helper, tree, tree, tree);\n+  void set_op (code_helper, tree, tree, tree, tree);\n+  void set_value (tree);\n+\n+  tree op_or_null (unsigned int) const;\n+\n+  /* The maximum value of NUM_OPS.  */\n+  static const unsigned int MAX_NUM_OPS = 3;\n+\n+  /* The operation being performed.  */\n+  code_helper code;\n+\n+  /* The type of the result.  */\n+  tree type;\n+\n+  /* The number of operands to CODE.  */\n+  unsigned int num_ops;\n+\n+  /* The operands to CODE.  Only the first NUM_OPS entries are meaningful.  */\n+  tree ops[MAX_NUM_OPS];\n+};\n+\n+/* Constructor that takes the code, type and number of operands, but leaves\n+   the caller to fill in the operands.  */\n+\n+inline\n+gimple_match_op::gimple_match_op (code_helper code_in, tree type_in,\n+\t\t\t\t  unsigned int num_ops_in)\n+  : code (code_in), type (type_in), num_ops (num_ops_in)\n+{\n+}\n+\n+/* Constructors for various numbers of operands.  */\n+\n+inline\n+gimple_match_op::gimple_match_op (code_helper code_in, tree type_in,\n+\t\t\t\t  tree op0)\n+  : code (code_in), type (type_in), num_ops (1)\n+{\n+  ops[0] = op0;\n+}\n+\n+inline\n+gimple_match_op::gimple_match_op (code_helper code_in, tree type_in,\n+\t\t\t\t  tree op0, tree op1)\n+  : code (code_in), type (type_in), num_ops (2)\n+{\n+  ops[0] = op0;\n+  ops[1] = op1;\n+}\n+\n+inline\n+gimple_match_op::gimple_match_op (code_helper code_in, tree type_in,\n+\t\t\t\t  tree op0, tree op1, tree op2)\n+  : code (code_in), type (type_in), num_ops (3)\n+{\n+  ops[0] = op0;\n+  ops[1] = op1;\n+  ops[2] = op2;\n+}\n+\n+/* Change the operation performed to CODE_IN, the type of the result to\n+   TYPE_IN, and the number of operands to NUM_OPS_IN.  The caller needs\n+   to set the operands itself.  */\n+\n+inline void\n+gimple_match_op::set_op (code_helper code_in, tree type_in,\n+\t\t\t unsigned int num_ops_in)\n+{\n+  code = code_in;\n+  type = type_in;\n+  num_ops = num_ops_in;\n+}\n+\n+/* Functions for changing the operation performed, for various numbers\n+   of operands.  */\n+\n+inline void\n+gimple_match_op::set_op (code_helper code_in, tree type_in, tree op0)\n+{\n+  code = code_in;\n+  type = type_in;\n+  num_ops = 1;\n+  ops[0] = op0;\n+}\n+\n+inline void\n+gimple_match_op::set_op (code_helper code_in, tree type_in, tree op0, tree op1)\n+{\n+  code = code_in;\n+  type = type_in;\n+  num_ops = 2;\n+  ops[0] = op0;\n+  ops[1] = op1;\n+}\n+\n+inline void\n+gimple_match_op::set_op (code_helper code_in, tree type_in,\n+\t\t\t tree op0, tree op1, tree op2)\n+{\n+  code = code_in;\n+  type = type_in;\n+  num_ops = 3;\n+  ops[0] = op0;\n+  ops[1] = op1;\n+  ops[2] = op2;\n+}\n+\n+/* Set the \"operation\" to be the single value VALUE, such as a constant\n+   or SSA_NAME.  */\n+\n+inline void\n+gimple_match_op::set_value (tree value)\n+{\n+  set_op (TREE_CODE (value), TREE_TYPE (value), value);\n+}\n+\n+/* Return the value of operand I, or null if there aren't that many\n+   operands.  */\n+\n+inline tree\n+gimple_match_op::op_or_null (unsigned int i) const\n+{\n+  return i < num_ops ? ops[i] : NULL_TREE;\n+}\n+\n+/* Return whether OP is a non-expression result and a gimple value.  */\n \n inline bool\n-gimple_simplified_result_is_gimple_val (code_helper code, tree *ops)\n+gimple_simplified_result_is_gimple_val (const gimple_match_op *op)\n {\n-  return (code.is_tree_code ()\n-\t  && (TREE_CODE_LENGTH ((tree_code) code) == 0\n-\t      || ((tree_code) code) == ADDR_EXPR)\n-\t  && is_gimple_val (ops[0]));\n+  return (op->code.is_tree_code ()\n+\t  && (TREE_CODE_LENGTH ((tree_code) op->code) == 0\n+\t      || ((tree_code) op->code) == ADDR_EXPR)\n+\t  && is_gimple_val (op->ops[0]));\n }\n \n-extern tree (*mprts_hook) (code_helper, tree, tree *);\n+extern tree (*mprts_hook) (gimple_match_op *);\n \n-bool gimple_simplify (gimple *, code_helper *, tree *, gimple_seq *,\n+bool gimple_simplify (gimple *, gimple_match_op *, gimple_seq *,\n \t\t      tree (*)(tree), tree (*)(tree));\n-bool gimple_resimplify1 (gimple_seq *, code_helper *, tree, tree *,\n-\t\t\t tree (*)(tree));\n-bool gimple_resimplify2 (gimple_seq *, code_helper *, tree, tree *,\n-\t\t\t tree (*)(tree));\n-bool gimple_resimplify3 (gimple_seq *, code_helper *, tree, tree *,\n-\t\t\t tree (*)(tree));\n-tree maybe_push_res_to_seq (code_helper, tree, tree *,\n-\t\t\t    gimple_seq *, tree res = NULL_TREE);\n-void maybe_build_generic_op (enum tree_code, tree, tree *);\n+bool gimple_resimplify1 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n+bool gimple_resimplify2 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n+bool gimple_resimplify3 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n+tree maybe_push_res_to_seq (gimple_match_op *, gimple_seq *,\n+\t\t\t    tree res = NULL_TREE);\n+void maybe_build_generic_op (gimple_match_op *);\n \n \n #endif  /* GCC_GIMPLE_MATCH_H */"}, {"sha": "1bf7771dac16bb6893f71caeafd3f21279bb9c4f", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=5d75ad95aa808d6767afc0cdadd3b62e831c5cdf", "patch": "@@ -146,12 +146,11 @@ cleanup_control_expr_graph (basic_block bb, gimple_stmt_iterator gsi)\n \t{\n \tcase GIMPLE_COND:\n \t  {\n-\t    code_helper rcode;\n-\t    tree ops[3] = {};\n-\t    if (gimple_simplify (stmt, &rcode, ops, NULL, no_follow_ssa_edges,\n+\t    gimple_match_op res_op;\n+\t    if (gimple_simplify (stmt, &res_op, NULL, no_follow_ssa_edges,\n \t\t\t\t no_follow_ssa_edges)\n-\t\t&& rcode == INTEGER_CST)\n-\t      val = ops[0];\n+\t\t&& res_op.code == INTEGER_CST)\n+\t      val = res_op.ops[0];\n \t  }\n \t  break;\n "}, {"sha": "62015fda9293451fdd5b4b72aa04c64fe2bc8baa", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 43, "deletions": 48, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d75ad95aa808d6767afc0cdadd3b62e831c5cdf/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=5d75ad95aa808d6767afc0cdadd3b62e831c5cdf", "patch": "@@ -1655,25 +1655,25 @@ static unsigned mprts_hook_cnt;\n /* Hook for maybe_push_res_to_seq, lookup the expression in the VN tables.  */\n \n static tree\n-vn_lookup_simplify_result (code_helper rcode, tree type, tree *ops_)\n+vn_lookup_simplify_result (gimple_match_op *res_op)\n {\n-  if (!rcode.is_tree_code ())\n+  if (!res_op->code.is_tree_code ())\n     return NULL_TREE;\n-  tree *ops = ops_;\n-  unsigned int length = TREE_CODE_LENGTH ((tree_code) rcode);\n-  if (rcode == CONSTRUCTOR\n+  tree *ops = res_op->ops;\n+  unsigned int length = res_op->num_ops;\n+  if (res_op->code == CONSTRUCTOR\n       /* ???  We're arriving here with SCCVNs view, decomposed CONSTRUCTOR\n          and GIMPLEs / match-and-simplifies, CONSTRUCTOR as GENERIC tree.  */\n-      && TREE_CODE (ops_[0]) == CONSTRUCTOR)\n+      && TREE_CODE (res_op->ops[0]) == CONSTRUCTOR)\n     {\n-      length = CONSTRUCTOR_NELTS (ops_[0]);\n+      length = CONSTRUCTOR_NELTS (res_op->ops[0]);\n       ops = XALLOCAVEC (tree, length);\n       for (unsigned i = 0; i < length; ++i)\n-\tops[i] = CONSTRUCTOR_ELT (ops_[0], i)->value;\n+\tops[i] = CONSTRUCTOR_ELT (res_op->ops[0], i)->value;\n     }\n   vn_nary_op_t vnresult = NULL;\n-  tree res = vn_nary_op_lookup_pieces (length, (tree_code) rcode,\n-\t\t\t\t       type, ops, &vnresult);\n+  tree res = vn_nary_op_lookup_pieces (length, (tree_code) res_op->code,\n+\t\t\t\t       res_op->type, ops, &vnresult);\n   /* We can end up endlessly recursing simplifications if the lookup above\n      presents us with a def-use chain that mirrors the original simplification.\n      See PR80887 for an example.  Limit successful lookup artificially\n@@ -1695,8 +1695,7 @@ vn_lookup_simplify_result (code_helper rcode, tree type, tree *ops_)\n    INSERT is true.  */\n \n static tree\n-vn_nary_build_or_lookup_1 (code_helper rcode, tree type, tree *ops,\n-\t\t\t   bool insert)\n+vn_nary_build_or_lookup_1 (gimple_match_op *res_op, bool insert)\n {\n   tree result = NULL_TREE;\n   /* We will be creating a value number for\n@@ -1706,31 +1705,31 @@ vn_nary_build_or_lookup_1 (code_helper rcode, tree type, tree *ops,\n   mprts_hook = vn_lookup_simplify_result;\n   mprts_hook_cnt = 9;\n   bool res = false;\n-  switch (TREE_CODE_LENGTH ((tree_code) rcode))\n+  switch (TREE_CODE_LENGTH ((tree_code) res_op->code))\n     {\n     case 1:\n-      res = gimple_resimplify1 (NULL, &rcode, type, ops, vn_valueize);\n+      res = gimple_resimplify1 (NULL, res_op, vn_valueize);\n       break;\n     case 2:\n-      res = gimple_resimplify2 (NULL, &rcode, type, ops, vn_valueize);\n+      res = gimple_resimplify2 (NULL, res_op, vn_valueize);\n       break;\n     case 3:\n-      res = gimple_resimplify3 (NULL, &rcode, type, ops, vn_valueize);\n+      res = gimple_resimplify3 (NULL, res_op, vn_valueize);\n       break;\n     }\n   mprts_hook = NULL;\n   gimple *new_stmt = NULL;\n   if (res\n-      && gimple_simplified_result_is_gimple_val (rcode, ops))\n+      && gimple_simplified_result_is_gimple_val (res_op))\n     /* The expression is already available.  */\n-    result = ops[0];\n+    result = res_op->ops[0];\n   else\n     {\n-      tree val = vn_lookup_simplify_result (rcode, type, ops);\n+      tree val = vn_lookup_simplify_result (res_op);\n       if (!val && insert)\n \t{\n \t  gimple_seq stmts = NULL;\n-\t  result = maybe_push_res_to_seq (rcode, type, ops, &stmts);\n+\t  result = maybe_push_res_to_seq (res_op, &stmts);\n \t  if (result)\n \t    {\n \t      gcc_assert (gimple_seq_singleton_p (stmts));\n@@ -1792,9 +1791,9 @@ vn_nary_build_or_lookup_1 (code_helper rcode, tree type, tree *ops,\n    value-number for the simplified result or by inserting the operation.  */\n \n static tree\n-vn_nary_build_or_lookup (code_helper rcode, tree type, tree *ops)\n+vn_nary_build_or_lookup (gimple_match_op *res_op)\n {\n-  return vn_nary_build_or_lookup_1 (rcode, type, ops, true);\n+  return vn_nary_build_or_lookup_1 (res_op, true);\n }\n \n /* Try to simplify the expression RCODE OPS... of type TYPE and return\n@@ -1803,11 +1802,11 @@ vn_nary_build_or_lookup (code_helper rcode, tree type, tree *ops)\n tree\n vn_nary_simplify (vn_nary_op_t nary)\n {\n-  if (nary->length > 3)\n+  if (nary->length > gimple_match_op::MAX_NUM_OPS)\n     return NULL_TREE;\n-  tree ops[3];\n-  memcpy (ops, nary->op, sizeof (tree) * nary->length);\n-  return vn_nary_build_or_lookup_1 (nary->opcode, nary->type, ops, false);\n+  gimple_match_op op (nary->opcode, nary->type, nary->length);\n+  memcpy (op.ops, nary->op, sizeof (tree) * nary->length);\n+  return vn_nary_build_or_lookup_1 (&op, false);\n }\n \n \n@@ -2032,10 +2031,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t  else if (INTEGRAL_TYPE_P (vr->type)\n \t\t   && known_eq (ref->size, 8))\n \t    {\n-\t      code_helper rcode = NOP_EXPR;\n-\t      tree ops[3] = {};\n-\t      ops[0] = gimple_call_arg (def_stmt, 1);\n-\t      val = vn_nary_build_or_lookup (rcode, vr->type, ops);\n+\t      gimple_match_op res_op (NOP_EXPR, vr->type,\n+\t\t\t\t      gimple_call_arg (def_stmt, 1));\n+\t      val = vn_nary_build_or_lookup (&res_op);\n \t      if (!val\n \t\t  || (TREE_CODE (val) == SSA_NAME\n \t\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (val)))\n@@ -2174,12 +2172,11 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t      || known_eq (ref->size, TYPE_PRECISION (vr->type)))\n \t  && multiple_p (ref->size, BITS_PER_UNIT))\n \t{\n-\t  code_helper rcode = BIT_FIELD_REF;\n-\t  tree ops[3];\n-\t  ops[0] = SSA_VAL (gimple_assign_rhs1 (def_stmt));\n-\t  ops[1] = bitsize_int (ref->size);\n-\t  ops[2] = bitsize_int (offset - offset2);\n-\t  tree val = vn_nary_build_or_lookup (rcode, vr->type, ops);\n+\t  gimple_match_op op (BIT_FIELD_REF, vr->type,\n+\t\t\t      SSA_VAL (gimple_assign_rhs1 (def_stmt)),\n+\t\t\t      bitsize_int (ref->size),\n+\t\t\t      bitsize_int (offset - offset2));\n+\t  tree val = vn_nary_build_or_lookup (&op);\n \t  if (val\n \t      && (TREE_CODE (val) != SSA_NAME\n \t\t  || ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (val)))\n@@ -3704,9 +3701,8 @@ visit_nary_op (tree lhs, gassign *stmt)\n \t\t      unsigned rhs_prec = TYPE_PRECISION (TREE_TYPE (rhs1));\n \t\t      if (lhs_prec == rhs_prec)\n \t\t\t{\n-\t\t\t  ops[1] = NULL_TREE;\n-\t\t\t  result = vn_nary_build_or_lookup (NOP_EXPR,\n-\t\t\t\t\t\t\t    type, ops);\n+\t\t\t  gimple_match_op match_op (NOP_EXPR, type, ops[0]);\n+\t\t\t  result = vn_nary_build_or_lookup (&match_op);\n \t\t\t  if (result)\n \t\t\t    {\n \t\t\t      bool changed = set_ssa_val_to (lhs, result);\n@@ -3716,12 +3712,12 @@ visit_nary_op (tree lhs, gassign *stmt)\n \t\t\t}\n \t\t      else\n \t\t\t{\n-\t\t\t  ops[1] = wide_int_to_tree (type,\n-\t\t\t\t\t\t     wi::mask (rhs_prec, false,\n-\t\t\t\t\t\t\t       lhs_prec));\n-\t\t\t  result = vn_nary_build_or_lookup (BIT_AND_EXPR,\n-\t\t\t\t\t\t\t    TREE_TYPE (lhs),\n-\t\t\t\t\t\t\t    ops);\n+\t\t\t  tree mask = wide_int_to_tree\n+\t\t\t    (type, wi::mask (rhs_prec, false, lhs_prec));\n+\t\t\t  gimple_match_op match_op (BIT_AND_EXPR,\n+\t\t\t\t\t\t    TREE_TYPE (lhs),\n+\t\t\t\t\t\t    ops[0], mask);\n+\t\t\t  result = vn_nary_build_or_lookup (&match_op);\n \t\t\t  if (result)\n \t\t\t    {\n \t\t\t      bool changed = set_ssa_val_to (lhs, result);\n@@ -3842,9 +3838,8 @@ visit_reference_op_load (tree lhs, tree op, gimple *stmt)\n \t of VIEW_CONVERT_EXPR <TREE_TYPE (result)> (result).\n \t So first simplify and lookup this expression to see if it\n \t is already available.  */\n-      code_helper rcode = VIEW_CONVERT_EXPR;\n-      tree ops[3] = { result };\n-      result = vn_nary_build_or_lookup (rcode, TREE_TYPE (op), ops);\n+      gimple_match_op res_op (VIEW_CONVERT_EXPR, TREE_TYPE (op), result);\n+      result = vn_nary_build_or_lookup (&res_op);\n     }\n \n   if (result)"}]}