{"sha": "ff6663134070df58da6bee2b654fb683ba4cfb25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY2NjYzMTM0MDcwZGY1OGRhNmJlZTJiNjU0ZmI2ODNiYTRjZmIyNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-14T23:31:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-14T23:31:25Z"}, "message": "flow.c (propagate_block): Use free_EXPR_LIST_list instead of zapping mem_set_list.\n\n        * flow.c (propagate_block): Use free_EXPR_LIST_list instead of\n        zapping mem_set_list.\n        (invalidate_mems_from_autoinc): Use free_EXPR_LIST_node.\n        (mark_set_1, mark_used_regs): Likewise.\n\nFrom-SVN: r29990", "tree": {"sha": "bb8ecc69cc595e63f765606859f035b861876b72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb8ecc69cc595e63f765606859f035b861876b72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff6663134070df58da6bee2b654fb683ba4cfb25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6663134070df58da6bee2b654fb683ba4cfb25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff6663134070df58da6bee2b654fb683ba4cfb25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6663134070df58da6bee2b654fb683ba4cfb25/comments", "author": null, "committer": null, "parents": [{"sha": "d1abb9254b8e917820e4b8c31f7ec0cc1090b6f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1abb9254b8e917820e4b8c31f7ec0cc1090b6f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1abb9254b8e917820e4b8c31f7ec0cc1090b6f6"}], "stats": {"total": 45, "additions": 27, "deletions": 18}, "files": [{"sha": "e9305fafd5c2374b970fbf6458d824edc58cb1db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6663134070df58da6bee2b654fb683ba4cfb25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6663134070df58da6bee2b654fb683ba4cfb25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff6663134070df58da6bee2b654fb683ba4cfb25", "patch": "@@ -3,6 +3,11 @@ Thu Oct 14 16:27:50 1999  Richard Henderson  <rth@cygnus.com>\n \t* flow.c (propagate_block): Add call-clobbered registers to\n \tsignificant too.\n \n+\t* flow.c (propagate_block): Use free_EXPR_LIST_list instead of\n+\tzapping mem_set_list.\n+\t(invalidate_mems_from_autoinc): Use free_EXPR_LIST_node.\n+\t(mark_set_1, mark_used_regs): Likewise.\n+\n Thu Oct 14 13:54:25 1999  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* toplev.c (main): Don't complain about options for other languages."}, {"sha": "59111be13c043688558f8d86177772c1fdd60055", "filename": "gcc/flow.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6663134070df58da6bee2b654fb683ba4cfb25/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6663134070df58da6bee2b654fb683ba4cfb25/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ff6663134070df58da6bee2b654fb683ba4cfb25", "patch": "@@ -263,12 +263,7 @@ static int loop_depth;\n static int cc0_live;\n \n /* During propagate_block, this contains a list of all the MEMs we are\n-   tracking for dead store elimination. \n-\n-   ?!? Note we leak memory by not free-ing items on this list.  We need to\n-   write some generic routines to operate on memory lists since cse, gcse,\n-   loop, sched, flow and possibly other passes all need to do basically the\n-   same operations on these lists.  */\n+   tracking for dead store elimination.  */\n \n static rtx mem_set_list;\n \n@@ -3227,7 +3222,6 @@ propagate_block (old, first, last, significant, bnum, flags)\n   live = ALLOCA_REG_SET ();\n \n   cc0_live = 0;\n-  mem_set_list = NULL_RTX;\n \n   if (flags & PROP_REG_INFO)\n     {\n@@ -3451,7 +3445,7 @@ propagate_block (old, first, last, significant, bnum, flags)\n \t\t\t\t      flags, insn);\n \n \t\t  /* Calls also clobber memory.  */\n-\t\t  mem_set_list = NULL_RTX;\n+\t\t  free_EXPR_LIST_list (&mem_set_list);\n \t\t}\n \n \t      /* Update OLD for the registers used or set.  */\n@@ -3473,6 +3467,7 @@ propagate_block (old, first, last, significant, bnum, flags)\n \n   FREE_REG_SET (dead);\n   FREE_REG_SET (live);\n+  free_EXPR_LIST_list (&mem_set_list);\n }\n \f\n /* Return 1 if X (the body of an insn, or part of it) is just dead stores\n@@ -3730,20 +3725,23 @@ invalidate_mems_from_autoinc (insn)\n         {\n           rtx temp = mem_set_list;\n           rtx prev = NULL_RTX;\n+\t  rtx next;\n \n           while (temp)\n \t    {\n+\t      next = XEXP (temp, 1);\n \t      if (reg_overlap_mentioned_p (XEXP (note, 0), XEXP (temp, 0)))\n \t        {\n \t          /* Splice temp out of list.  */\n \t          if (prev)\n-\t            XEXP (prev, 1) = XEXP (temp, 1);\n+\t            XEXP (prev, 1) = next;\n \t          else\n-\t            mem_set_list = XEXP (temp, 1);\n+\t            mem_set_list = next;\n+\t\t  free_EXPR_LIST_node (temp);\n \t        }\n \t      else\n \t        prev = temp;\n-              temp = XEXP (temp, 1);\n+              temp = next;\n \t    }\n \t}\n     }\n@@ -3836,23 +3834,26 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n \t{\n \t  rtx temp = mem_set_list;\n \t  rtx prev = NULL_RTX;\n+\t  rtx next;\n \n \t  while (temp)\n \t    {\n+\t      next = XEXP (temp, 1);\n \t      if ((GET_CODE (reg) == MEM\n \t\t   && output_dependence (XEXP (temp, 0), reg))\n \t\t  || (GET_CODE (reg) == REG\n \t\t      && reg_overlap_mentioned_p (reg, XEXP (temp, 0))))\n \t\t{\n \t\t  /* Splice this entry out of the list.  */\n \t\t  if (prev)\n-\t\t    XEXP (prev, 1) = XEXP (temp, 1);\n+\t\t    XEXP (prev, 1) = next;\n \t\t  else\n-\t\t    mem_set_list = XEXP (temp, 1);\n+\t\t    mem_set_list = next;\n+\t\t  free_EXPR_LIST_node (temp);\n \t\t}\n \t      else\n \t\tprev = temp;\n-\t      temp = XEXP (temp, 1);\n+\t      temp = next;\n \t    }\n \t}\n \n@@ -4300,20 +4301,23 @@ mark_used_regs (needed, live, x, flags, insn)\n \t    {\n \t      rtx temp = mem_set_list;\n \t      rtx prev = NULL_RTX;\n+\t      rtx next;\n \n \t      while (temp)\n \t\t{\n+\t\t  next = XEXP (temp, 1);\n \t\t  if (anti_dependence (XEXP (temp, 0), x))\n \t\t    {\n \t\t      /* Splice temp out of the list.  */\n \t\t      if (prev)\n-\t\t\tXEXP (prev, 1) = XEXP (temp, 1);\n+\t\t\tXEXP (prev, 1) = next;\n \t\t      else\n-\t\t\tmem_set_list = XEXP (temp, 1);\n+\t\t\tmem_set_list = next;\n+\t\t      free_EXPR_LIST_node (temp);\n \t\t    }\n \t\t  else\n \t\t    prev = temp;\n-\t\t  temp = XEXP (temp, 1);\n+\t\t  temp = next;\n \t\t}\n \t    }\n \n@@ -4606,7 +4610,7 @@ mark_used_regs (needed, live, x, flags, insn)\n \t   So for now, just clear the memory set list and mark any regs\n \t   we can find in ASM_OPERANDS as used.  */\n \tif (code != ASM_OPERANDS || MEM_VOLATILE_P (x))\n-\t  mem_set_list = NULL_RTX;\n+\t  free_EXPR_LIST_list (&mem_set_list);\n \n         /* For all ASM_OPERANDS, we must traverse the vector of input operands.\n \t   We can not just fall through here since then we would be confused"}]}