{"sha": "e398aa80628423ec3d52bca83864a8fc908641c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM5OGFhODA2Mjg0MjNlYzNkNTJiY2E4Mzg2NGE4ZmM5MDg2NDFjMQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-11-17T09:14:33Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-11-17T09:14:33Z"}, "message": "* flow.c (insn_dead_p): New argument NOTES.  Changed all callers.\n\nFrom-SVN: r23680", "tree": {"sha": "45fcd7990e357333c692392379fd67acb255bbc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45fcd7990e357333c692392379fd67acb255bbc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e398aa80628423ec3d52bca83864a8fc908641c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e398aa80628423ec3d52bca83864a8fc908641c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e398aa80628423ec3d52bca83864a8fc908641c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e398aa80628423ec3d52bca83864a8fc908641c1/comments", "author": null, "committer": null, "parents": [{"sha": "bcd91ba75333ac033300f7b2f2e7d93b30a779f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcd91ba75333ac033300f7b2f2e7d93b30a779f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcd91ba75333ac033300f7b2f2e7d93b30a779f1"}], "stats": {"total": 53, "additions": 41, "deletions": 12}, "files": [{"sha": "521f3e842a6a288b27b1ada4a446a9f3e5e963d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e398aa80628423ec3d52bca83864a8fc908641c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e398aa80628423ec3d52bca83864a8fc908641c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e398aa80628423ec3d52bca83864a8fc908641c1", "patch": "@@ -1,3 +1,7 @@\n+Tue Nov 17 17:13:53 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* flow.c (insn_dead_p): New argument NOTES.  Changed all callers.\n+\n Mon Nov 16 17:56:07 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n \n \t* rs6000.c (output_mi_thunk): Improve test for local branch."}, {"sha": "51be372988c2ff3b9ea1952de66bbb704538c6e6", "filename": "gcc/flow.c", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e398aa80628423ec3d52bca83864a8fc908641c1/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e398aa80628423ec3d52bca83864a8fc908641c1/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e398aa80628423ec3d52bca83864a8fc908641c1", "patch": "@@ -271,7 +271,7 @@ static int set_noop_p\t\t\tPROTO((rtx));\n static int noop_move_p\t\t\tPROTO((rtx));\n static void record_volatile_insns\tPROTO((rtx));\n static void mark_regs_live_at_end\tPROTO((regset));\n-static int insn_dead_p\t\t\tPROTO((rtx, regset, int));\n+static int insn_dead_p\t\t\tPROTO((rtx, regset, int, rtx));\n static int libcall_dead_p\t\tPROTO((rtx, regset, rtx, rtx));\n static void mark_set_regs\t\tPROTO((regset, regset, rtx,\n \t\t\t\t\t       rtx, regset));\n@@ -1749,7 +1749,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t  register int i;\n \t  rtx note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n \t  int insn_is_dead\n-\t    = (insn_dead_p (PATTERN (insn), old, 0)\n+\t    = (insn_dead_p (PATTERN (insn), old, 0, REG_NOTES (insn))\n \t       /* Don't delete something that refers to volatile storage!  */\n \t       && ! INSN_VOLATILE (insn));\n \t  int libcall_is_dead \n@@ -1935,16 +1935,40 @@ propagate_block (old, first, last, final, significant, bnum)\n    (SET expressions whose destinations are registers dead after the insn).\n    NEEDED is the regset that says which regs are alive after the insn.\n \n-   Unless CALL_OK is non-zero, an insn is needed if it contains a CALL.  */\n+   Unless CALL_OK is non-zero, an insn is needed if it contains a CALL.\n+\n+   If X is the entire body of an insn, NOTES contains the reg notes\n+   pertaining to the insn.  */\n \n static int\n-insn_dead_p (x, needed, call_ok)\n+insn_dead_p (x, needed, call_ok, notes)\n      rtx x;\n      regset needed;\n      int call_ok;\n+     rtx notes ATTRIBUTE_UNUSED;\n {\n   enum rtx_code code = GET_CODE (x);\n \n+#ifdef AUTO_INC_DEC\n+  /* If flow is invoked after reload, we must take existing AUTO_INC\n+     expresions into account.  */\n+  if (reload_completed)\n+    {\n+      for ( ; notes; notes = XEXP (notes, 1))\n+\t{\n+\t  if (REG_NOTE_KIND (notes) == REG_INC)\n+\t    {\n+\t      int regno = REGNO (XEXP (notes, 0));\n+\n+\t      /* Don't delete insns to set global regs.  */\n+\t      if ((regno < FIRST_PSEUDO_REGISTER && global_regs[regno])\n+\t\t  || REGNO_REG_SET_P (needed, regno))\n+\t\treturn 0;\n+\t    }\n+\t}\n+    }\n+#endif\n+\n   /* If setting something that's a reg or part of one,\n      see if that register's altered value will be live.  */\n \n@@ -2015,7 +2039,7 @@ insn_dead_p (x, needed, call_ok)\n       for (i--; i >= 0; i--)\n \tif (GET_CODE (XVECEXP (x, 0, i)) != CLOBBER\n \t    && GET_CODE (XVECEXP (x, 0, i)) != USE\n-\t    && ! insn_dead_p (XVECEXP (x, 0, i), needed, call_ok))\n+\t    && ! insn_dead_p (XVECEXP (x, 0, i), needed, call_ok, NULL_RTX))\n \t  return 0;\n \n       return 1;\n@@ -2062,6 +2086,7 @@ libcall_dead_p (x, needed, note, insn)\n       if (GET_CODE (r) == REG)\n \t{\n \t  rtx call = XEXP (note, 0);\n+\t  rtx call_pat;\n \t  register int i;\n \n \t  /* Find the call insn.  */\n@@ -2075,12 +2100,12 @@ libcall_dead_p (x, needed, note, insn)\n \n \t  /* See if the hard reg holding the value is dead.\n \t     If this is a PARALLEL, find the call within it.  */\n-\t  call = PATTERN (call);\n-\t  if (GET_CODE (call) == PARALLEL)\n+\t  call_pat = PATTERN (call);\n+\t  if (GET_CODE (call_pat) == PARALLEL)\n \t    {\n-\t      for (i = XVECLEN (call, 0) - 1; i >= 0; i--)\n-\t\tif (GET_CODE (XVECEXP (call, 0, i)) == SET\n-\t\t    && GET_CODE (SET_SRC (XVECEXP (call, 0, i))) == CALL)\n+\t      for (i = XVECLEN (call_pat, 0) - 1; i >= 0; i--)\n+\t\tif (GET_CODE (XVECEXP (call_pat, 0, i)) == SET\n+\t\t    && GET_CODE (SET_SRC (XVECEXP (call_pat, 0, i))) == CALL)\n \t\t  break;\n \n \t      /* This may be a library call that is returning a value\n@@ -2089,10 +2114,10 @@ libcall_dead_p (x, needed, note, insn)\n \t      if (i < 0)\n \t\treturn 0;\n \n-\t      call = XVECEXP (call, 0, i);\n+\t      call_pat = XVECEXP (call_pat, 0, i);\n \t    }\n \n-\t  return insn_dead_p (call, needed, 1);\n+\t  return insn_dead_p (call_pat, needed, 1, REG_NOTES (call));\n \t}\n     }\n   return 1;"}]}