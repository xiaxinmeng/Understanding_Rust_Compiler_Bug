{"sha": "45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVkMDljMDJlNTQ0YzQwNzRhYTRhNjk5MjVjMWZlNTQ3YTBkZDdhMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-07-27T07:27:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-07-27T07:27:12Z"}, "message": "expr.h (canonicalize_condition, [...]): Add an int argument.\n\n\t* expr.h (canonicalize_condition, get_condition): Add an int argument.\n\t* gcse.c (fis_get_condition): Reimplement using get_condition, leaving\n\tit to check whether the condition is still valid at the jump insn.\n\t* ifcvt.c (noce_get_condition): Likewise.\n\t(noce_get_alt_condition): Update call to canonicalize_condition.\n\t* loop-iv.c (simplify_using_initial_values): Update call to\n\tget_condition.  Remove FIXME.\n\t(check_simple_exit): Update call to get_condition.\n\t* loop-unswitch.c (may_unswitch_on): Likewise.\n\t* loop.c (check_dbra_loop): Likewise.\n\t(canonicalize_condition, get_condition): Add an argument to say whether\n\tthe condition must still be valid at INSN.\n\t(get_condition_for_loop): Update call to get_condition.  Require that\n\tthe condition be valid at INSN.\n\t* predict.c (estimate_probability): Update call to get_condition.\n\tRemove unused earliest parameter.\n\t(expected_value_to_br_prob): Update call to canonicalize_condition.\n\nFrom-SVN: r85218", "tree": {"sha": "3acb7007422c04dcb1bc209a9aeb6d560798c498", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3acb7007422c04dcb1bc209a9aeb6d560798c498"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/comments", "author": null, "committer": null, "parents": [{"sha": "dbe9c577763c34327150e88314c3f8b633f4be99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbe9c577763c34327150e88314c3f8b633f4be99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbe9c577763c34327150e88314c3f8b633f4be99"}], "stats": {"total": 151, "additions": 53, "deletions": 98}, "files": [{"sha": "6bb0422d841789960b0bd3deabbac084ef9fee42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "patch": "@@ -1,3 +1,23 @@\n+2004-07-27  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* expr.h (canonicalize_condition, get_condition): Add an int argument.\n+\t* gcse.c (fis_get_condition): Reimplement using get_condition, leaving\n+\tit to check whether the condition is still valid at the jump insn.\n+\t* ifcvt.c (noce_get_condition): Likewise.\n+\t(noce_get_alt_condition): Update call to canonicalize_condition.\n+\t* loop-iv.c (simplify_using_initial_values): Update call to\n+\tget_condition.  Remove FIXME.\n+\t(check_simple_exit): Update call to get_condition.\n+\t* loop-unswitch.c (may_unswitch_on): Likewise.\n+\t* loop.c (check_dbra_loop): Likewise.\n+\t(canonicalize_condition, get_condition): Add an argument to say whether\n+\tthe condition must still be valid at INSN.\n+\t(get_condition_for_loop): Update call to get_condition.  Require that\n+\tthe condition be valid at INSN.\n+\t* predict.c (estimate_probability): Update call to get_condition.\n+\tRemove unused earliest parameter.\n+\t(expected_value_to_br_prob): Update call to canonicalize_condition.\n+\n 2004-07-26  Eric Christopher  <echristo@redhat.com>\n \n \t* tree-dfa.c (add_referenced_var): Register initializers of global"}, {"sha": "ad4874836779ddc116ae1191d1a3898340e20c7e", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "patch": "@@ -338,11 +338,11 @@ extern rtx emit_store_flag_force (rtx, enum rtx_code, rtx, rtx,\n \n /* Given an insn and condition, return a canonical description of\n    the test being made.  */\n-extern rtx canonicalize_condition (rtx, rtx, int, rtx *, rtx, int);\n+extern rtx canonicalize_condition (rtx, rtx, int, rtx *, rtx, int, int);\n \n /* Given a JUMP_INSN, return a canonical description of the test\n    being made.  */\n-extern rtx get_condition (rtx, rtx *, int);\n+extern rtx get_condition (rtx, rtx *, int, int);\n \n /* Generate a conditional trap instruction.  */\n extern rtx gen_cond_trap (enum rtx_code, rtx, rtx, rtx);"}, {"sha": "b99fc415eaf10840e36bd2273c2de72fd3453bb1", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "patch": "@@ -3687,52 +3687,7 @@ cprop (int alter_jumps)\n rtx\n fis_get_condition (rtx jump)\n {\n-  rtx cond, set, tmp, insn, earliest;\n-  bool reverse;\n-\n-  if (! any_condjump_p (jump))\n-    return NULL_RTX;\n-\n-  set = pc_set (jump);\n-  cond = XEXP (SET_SRC (set), 0);\n-\n-  /* If this branches to JUMP_LABEL when the condition is false,\n-     reverse the condition.  */\n-  reverse = (GET_CODE (XEXP (SET_SRC (set), 2)) == LABEL_REF\n-\t     && XEXP (XEXP (SET_SRC (set), 2), 0) == JUMP_LABEL (jump));\n-\n-  /* Use canonicalize_condition to do the dirty work of manipulating\n-     MODE_CC values and COMPARE rtx codes.  */\n-  tmp = canonicalize_condition (jump, cond, reverse, &earliest, NULL_RTX,\n-\t\t\t\tfalse);\n-  if (!tmp)\n-    return NULL_RTX;\n-\n-  /* Verify that the given condition is valid at JUMP by virtue of not\n-     having been modified since EARLIEST.  */\n-  for (insn = earliest; insn != jump; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn) && modified_in_p (tmp, insn))\n-      break;\n-  if (insn == jump)\n-    return tmp;\n-\n-  /* The condition was modified.  See if we can get a partial result\n-     that doesn't follow all the reversals.  Perhaps combine can fold\n-     them together later.  */\n-  tmp = XEXP (tmp, 0);\n-  if (!REG_P (tmp) || GET_MODE_CLASS (GET_MODE (tmp)) != MODE_INT)\n-    return NULL_RTX;\n-  tmp = canonicalize_condition (jump, cond, reverse, &earliest, tmp,\n-\t\t\t\tfalse);\n-  if (!tmp)\n-    return NULL_RTX;\n-\n-  /* For sanity's sake, re-validate the new result.  */\n-  for (insn = earliest; insn != jump; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn) && modified_in_p (tmp, insn))\n-      return NULL_RTX;\n-\n-  return tmp;\n+  return get_condition (jump, NULL, false, true);\n }\n \n /* Check the comparison COND to see if we can safely form an implicit set from"}, {"sha": "96833a54dda72c1a63b162c1e7805f8cb6fdf0c5", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "patch": "@@ -1489,7 +1489,7 @@ noce_get_alt_condition (struct noce_if_info *if_info, rtx target,\n     }\n \n   cond = canonicalize_condition (if_info->jump, cond, reverse,\n-\t\t\t\t earliest, target, false);\n+\t\t\t\t earliest, target, false, true);\n   if (! cond || ! reg_mentioned_p (target, cond))\n     return NULL;\n \n@@ -1800,7 +1800,7 @@ noce_try_sign_mask (struct noce_if_info *if_info)\n static rtx\n noce_get_condition (rtx jump, rtx *earliest)\n {\n-  rtx cond, set, tmp, insn;\n+  rtx cond, set, tmp;\n   bool reverse;\n \n   if (! any_condjump_p (jump))\n@@ -1829,38 +1829,8 @@ noce_get_condition (rtx jump, rtx *earliest)\n \n   /* Otherwise, fall back on canonicalize_condition to do the dirty\n      work of manipulating MODE_CC values and COMPARE rtx codes.  */\n-\n-  tmp = canonicalize_condition (jump, cond, reverse, earliest, NULL_RTX,\n-\t\t\t\tfalse);\n-  if (!tmp)\n-    return NULL_RTX;\n-\n-  /* We are going to insert code before JUMP, not before EARLIEST.\n-     We must therefore be certain that the given condition is valid\n-     at JUMP by virtue of not having been modified since.  */\n-  for (insn = *earliest; insn != jump; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn) && modified_in_p (tmp, insn))\n-      break;\n-  if (insn == jump)\n-    return tmp;\n-\n-  /* The condition was modified.  See if we can get a partial result\n-     that doesn't follow all the reversals.  Perhaps combine can fold\n-     them together later.  */\n-  tmp = XEXP (tmp, 0);\n-  if (!REG_P (tmp) || GET_MODE_CLASS (GET_MODE (tmp)) != MODE_INT)\n-    return NULL_RTX;\n-  tmp = canonicalize_condition (jump, cond, reverse, earliest, tmp,\n-\t\t\t\tfalse);\n-  if (!tmp)\n-    return NULL_RTX;\n-\n-  /* For sanity's sake, re-validate the new result.  */\n-  for (insn = *earliest; insn != jump; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn) && modified_in_p (tmp, insn))\n-      return NULL_RTX;\n-\n-  return tmp;\n+  return canonicalize_condition (jump, cond, reverse, earliest,\n+\t\t\t\t NULL_RTX, false, true);\n }\n \n /* Return true if OP is ok for if-then-else processing.  */"}, {"sha": "68b0013c06cbd11a8d0de171cfb82b3106477dea", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "patch": "@@ -1737,9 +1737,7 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n       insn = BB_END (e->src);\n       if (any_condjump_p (insn))\n \t{\n-\t  /* FIXME -- slightly wrong -- what if compared register\n-\t     gets altered between start of the condition and insn?  */\n-\t  rtx cond = get_condition (BB_END (e->src), NULL, false);\n+\t  rtx cond = get_condition (BB_END (e->src), NULL, false, true);\n       \n \t  if (cond && (e->flags & EDGE_FALLTHRU))\n \t    cond = reversed_condition (cond);\n@@ -2472,7 +2470,7 @@ check_simple_exit (struct loop *loop, edge e, struct niter_desc *desc)\n   desc->in_edge = ei;\n \n   /* Test whether the condition is suitable.  */\n-  if (!(condition = get_condition (BB_END (ei->src), &at, false)))\n+  if (!(condition = get_condition (BB_END (ei->src), &at, false, false)))\n     return;\n \n   if (ei->flags & EDGE_FALLTHRU)"}, {"sha": "08780f0d58f94075608b028b504c38dff799396e", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "patch": "@@ -196,7 +196,7 @@ may_unswitch_on (basic_block bb, struct loop *loop, rtx *cinsn)\n     return NULL_RTX;\n \n   /* Condition must be invariant.  */\n-  test = get_condition (BB_END (bb), &at, true);\n+  test = get_condition (BB_END (bb), &at, true, false);\n   if (!test)\n     return NULL_RTX;\n "}, {"sha": "c8a16e0850d8eb4f36351fcb566348e1b5ef8dd6", "filename": "gcc/loop.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "patch": "@@ -8001,7 +8001,7 @@ check_dbra_loop (struct loop *loop, int insn_count)\n \n   /* Try to compute whether the compare/branch at the loop end is one or\n      two instructions.  */\n-  get_condition (jump, &first_compare, false);\n+  get_condition (jump, &first_compare, false, true);\n   if (first_compare == jump)\n     compare_and_branch = 1;\n   else if (first_compare == prev_nonnote_insn (jump))\n@@ -9195,11 +9195,14 @@ update_reg_last_use (rtx x, rtx insn)\n    If WANT_REG is nonzero, we wish the condition to be relative to that\n    register, if possible.  Therefore, do not canonicalize the condition\n    further.  If ALLOW_CC_MODE is nonzero, allow the condition returned \n-   to be a compare to a CC mode register.  */\n+   to be a compare to a CC mode register.\n+\n+   If VALID_AT_INSN_P, the condition must be valid at both *EARLIEST\n+   and at INSN.  */\n \n rtx\n canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n-\t\t\trtx want_reg, int allow_cc_mode)\n+\t\t\trtx want_reg, int allow_cc_mode, int valid_at_insn_p)\n {\n   enum rtx_code code;\n   rtx prev = insn;\n@@ -9357,6 +9360,11 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \n       if (x)\n \t{\n+\t  /* If the caller is expecting the condition to be valid at INSN,\n+\t     make sure X doesn't change before INSN.  */\n+\t  if (valid_at_insn_p)\n+\t    if (modified_in_p (x, prev) || modified_between_p (x, prev, insn))\n+\t      break;\n \t  if (COMPARISON_P (x))\n \t    code = GET_CODE (x);\n \t  if (reverse_code)\n@@ -9443,13 +9451,16 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n    If EARLIEST is nonzero, it is a pointer to a place where the earliest\n    insn used in locating the condition was found.  If a replacement test\n    of the condition is desired, it should be placed in front of that\n-   insn and we will be sure that the inputs are still valid.  \n+   insn and we will be sure that the inputs are still valid.  If EARLIEST\n+   is null, the returned condition will be valid at INSN.\n \n    If ALLOW_CC_MODE is nonzero, allow the condition returned to be a\n-   compare CC mode register.  */\n+   compare CC mode register.\n+\n+   VALID_AT_INSN_P is the same as for canonicalize_condition.  */\n \n rtx\n-get_condition (rtx jump, rtx *earliest, int allow_cc_mode)\n+get_condition (rtx jump, rtx *earliest, int allow_cc_mode, int valid_at_insn_p)\n {\n   rtx cond;\n   int reverse;\n@@ -9470,7 +9481,7 @@ get_condition (rtx jump, rtx *earliest, int allow_cc_mode)\n       && XEXP (XEXP (SET_SRC (set), 2), 0) == JUMP_LABEL (jump);\n \n   return canonicalize_condition (jump, cond, reverse, earliest, NULL_RTX,\n-\t\t\t\t allow_cc_mode);\n+\t\t\t\t allow_cc_mode, valid_at_insn_p);\n }\n \n /* Similar to above routine, except that we also put an invariant last\n@@ -9479,7 +9490,7 @@ get_condition (rtx jump, rtx *earliest, int allow_cc_mode)\n rtx\n get_condition_for_loop (const struct loop *loop, rtx x)\n {\n-  rtx comparison = get_condition (x, (rtx*) 0, false);\n+  rtx comparison = get_condition (x, (rtx*) 0, false, true);\n \n   if (comparison == 0\n       || ! loop_invariant_p (loop, XEXP (comparison, 0))"}, {"sha": "e55427d9acc930e504345be716ad2736d4e166d2", "filename": "gcc/predict.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d09c02e544c4074aa4a69925c1fe547a0dd7a0/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=45d09c02e544c4074aa4a69925c1fe547a0dd7a0", "patch": "@@ -636,7 +636,7 @@ estimate_probability (struct loops *loops_info)\n   FOR_EACH_BB (bb)\n     {\n       rtx last_insn = BB_END (bb);\n-      rtx cond, earliest;\n+      rtx cond;\n       edge e;\n \n       if (! can_predict_insn_p (last_insn))\n@@ -681,7 +681,7 @@ estimate_probability (struct loops *loops_info)\n \t    }\n \t}\n \n-      cond = get_condition (last_insn, &earliest, false);\n+      cond = get_condition (last_insn, NULL, false, false);\n       if (! cond)\n \tcontinue;\n \n@@ -1043,7 +1043,8 @@ expected_value_to_br_prob (void)\n \t\t(lt r70, r71)\n \t Could use cselib to try and reduce this further.  */\n       cond = XEXP (SET_SRC (pc_set (insn)), 0);\n-      cond = canonicalize_condition (insn, cond, 0, NULL, ev_reg, false);\n+      cond = canonicalize_condition (insn, cond, 0, NULL, ev_reg,\n+\t\t\t\t     false, false);\n       if (! cond || XEXP (cond, 0) != ev_reg\n \t  || GET_CODE (XEXP (cond, 1)) != CONST_INT)\n \tcontinue;"}]}