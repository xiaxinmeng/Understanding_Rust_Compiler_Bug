{"sha": "25e21aed5640682f693cd304b2d24007d797ce7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlMjFhZWQ1NjQwNjgyZjY5M2NkMzA0YjJkMjQwMDdkNzk3Y2U3ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-07-15T15:38:52Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-15T15:38:52Z"}, "message": "alpha.c (alpha_tablejump_addr_vec): New.\n\n        * config/alpha/alpha.c (alpha_tablejump_addr_vec): New.\n        (alpha_tablejump_best_label): New.\n        * config/alpha/alpha-protos.h: Declare them.\n        * config/alpha/alpha.md: Use braced strings for code blocks.\n        (tablejump_osf): Break out add with r29.\n        (tablejump_osf_internal): Remove.\n        (tablejump_osf_nt_internal): Rename from tablejump_nt_internal,\n        use alpha_tablejump_addr_vec and alpha_tablejump_best_label.\n\nFrom-SVN: r44022", "tree": {"sha": "2555a3469e98ab3b2a6cf31e6c4b596f9d383609", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2555a3469e98ab3b2a6cf31e6c4b596f9d383609"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25e21aed5640682f693cd304b2d24007d797ce7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e21aed5640682f693cd304b2d24007d797ce7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e21aed5640682f693cd304b2d24007d797ce7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e21aed5640682f693cd304b2d24007d797ce7d/comments", "author": null, "committer": null, "parents": [{"sha": "09b495e503444139ec2e9782d25f81cfdd30496c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09b495e503444139ec2e9782d25f81cfdd30496c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09b495e503444139ec2e9782d25f81cfdd30496c"}], "stats": {"total": 570, "additions": 239, "deletions": 331}, "files": [{"sha": "c9f6acd2579d8449cef2607d388252f2e157685b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e21aed5640682f693cd304b2d24007d797ce7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e21aed5640682f693cd304b2d24007d797ce7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25e21aed5640682f693cd304b2d24007d797ce7d", "patch": "@@ -1,3 +1,14 @@\n+2001-07-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (alpha_tablejump_addr_vec): New.\n+\t(alpha_tablejump_best_label): New.\n+\t* config/alpha/alpha-protos.h: Declare them.\n+\t* config/alpha/alpha.md: Use braced strings for code blocks.\n+\t(tablejump_osf): Break out add with r29.\n+\t(tablejump_osf_internal): Remove.\n+\t(tablejump_osf_nt_internal): Rename from tablejump_nt_internal,\n+\tuse alpha_tablejump_addr_vec and alpha_tablejump_best_label.\n+\n Sun Jul 15 00:53:35 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* loop.c (scan_loop): Add USEs inside PARALLELs into dependencies"}, {"sha": "9e3ae7dd25ed185e937bdc6a2cb23dc01ea57c09", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e21aed5640682f693cd304b2d24007d797ce7d/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e21aed5640682f693cd304b2d24007d797ce7d/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=25e21aed5640682f693cd304b2d24007d797ce7d", "patch": "@@ -70,6 +70,8 @@ extern int normal_memory_operand PARAMS ((rtx, enum machine_mode));\n extern int reg_no_subreg_operand PARAMS ((rtx, enum machine_mode));\n extern int addition_operation PARAMS ((rtx, enum machine_mode));\n \n+extern rtx alpha_tablejump_addr_vec PARAMS ((rtx));\n+extern rtx alpha_tablejump_best_label PARAMS ((rtx));\n extern void get_aligned_mem PARAMS ((rtx, rtx *, rtx *));\n extern rtx get_unaligned_address PARAMS ((rtx, int));\n extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,"}, {"sha": "12bd57700495e7afb2abf2009c480f6ef1d2e66e", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e21aed5640682f693cd304b2d24007d797ce7d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e21aed5640682f693cd304b2d24007d797ce7d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=25e21aed5640682f693cd304b2d24007d797ce7d", "patch": "@@ -1074,6 +1074,61 @@ direct_return ()\n \t  && current_function_outgoing_args_size == 0\n \t  && current_function_pretend_args_size == 0);\n }\n+\n+/* Return the ADDR_VEC associated with a tablejump insn.  */\n+\n+rtx\n+alpha_tablejump_addr_vec (insn)\n+     rtx insn;\n+{\n+  rtx tmp;\n+\n+  tmp = JUMP_LABEL (insn);\n+  if (!tmp)\n+    return NULL_RTX;\n+  tmp = NEXT_INSN (tmp);\n+  if (!tmp)\n+    return NULL_RTX;\n+  if (GET_CODE (tmp) == JUMP_INSN\n+      && GET_CODE (PATTERN (tmp)) == ADDR_DIFF_VEC)\n+    return PATTERN (tmp);\n+  return NULL_RTX;\n+}\n+\n+/* Return the label of the predicted edge, or CONST0_RTX if we don't know.  */\n+\n+rtx\n+alpha_tablejump_best_label (insn)\n+     rtx insn;\n+{\n+  rtx jump_table = alpha_tablejump_addr_vec (insn);\n+  rtx best_label = NULL_RTX;\n+\n+  /* ??? Once the CFG doesn't keep getting completely rebuilt, look\n+     there for edge frequency counts from profile data.  */\n+\n+  if (jump_table)\n+    {\n+      int n_labels = XVECLEN (jump_table, 1);\n+      int best_count = -1;\n+      int i, j;\n+\n+      for (i = 0; i < n_labels; i++)\n+\t{\n+\t  int count = 1;\n+\n+\t  for (j = i + 1; j < n_labels; j++)\n+\t    if (XEXP (XVECEXP (jump_table, 1, i), 0)\n+\t\t== XEXP (XVECEXP (jump_table, 1, j), 0))\n+\t      count++;\n+\n+\t  if (count > best_count)\n+\t    best_count = count, best_label = XVECEXP (jump_table, 1, i);\n+\t}\n+    }\n+\n+  return best_label ? best_label : const0_rtx;\n+}\n \f\n /* REF is an alignable memory location.  Place an aligned SImode\n    reference into *PALIGNED_MEM and the number of bits to shift into"}, {"sha": "26ed7b30b0165fbcdf68ecf6bb8ab04160722031", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 171, "deletions": 331, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e21aed5640682f693cd304b2d24007d797ce7d/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e21aed5640682f693cd304b2d24007d797ce7d/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=25e21aed5640682f693cd304b2d24007d797ce7d", "patch": "@@ -61,7 +61,8 @@\n ;; separately.\n \n (define_attr \"type\"\n-  \"ild,fld,ldsym,ist,fst,ibr,fbr,jsr,iadd,ilog,shift,icmov,fcmov,icmp,imul,fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n+  \"ild,fld,ldsym,ist,fst,ibr,fbr,jsr,iadd,ilog,shift,icmov,fcmov,icmp,imul,\\\n+fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   (const_string \"iadd\"))\n \n ;; Describe a user's asm statement.\n@@ -487,7 +488,6 @@\n \t(plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"\")\n \t\t (match_operand:SI 2 \"add_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (optimize)\n     {\n@@ -504,7 +504,7 @@\n         emit_insn (gen_adddi3 (gen_lowpart (DImode, operands[0]), op1, op2));\n       DONE;\n     }\n-}\")\n+})\n \n (define_insn \"*addsi_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n@@ -524,15 +524,14 @@\n   \"! add_operand (operands[2], SImode)\"\n   [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 3)))\n    (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 4)))]\n-  \"\n {\n   HOST_WIDE_INT val = INTVAL (operands[2]);\n   HOST_WIDE_INT low = (val & 0xffff) - 2 * (val & 0x8000);\n   HOST_WIDE_INT rest = val - low;\n \n   operands[3] = GEN_INT (rest);\n   operands[4] = GEN_INT (low);\n-}\")\n+})\n \n (define_insn \"*addsi_se\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n@@ -556,7 +555,6 @@\n    (set (match_dup 0) (sign_extend:DI (plus:SI (mult:SI (match_dup 3)\n \t\t\t\t\t\t\t(match_dup 5))\n \t\t\t\t\t       (match_dup 1))))]\n-  \"\n {\n   HOST_WIDE_INT val = INTVAL (operands[2]) / 4;\n   int mult = 4;\n@@ -566,7 +564,7 @@\n \n   operands[4] = GEN_INT (val);\n   operands[5] = GEN_INT (mult);\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -579,12 +577,11 @@\n   \"\"\n   [(set (match_dup 5) (match_dup 6))\n    (set (match_dup 0) (sign_extend:DI (plus:SI (match_dup 7) (match_dup 4))))]\n-  \"\n {\n   operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[1]), DImode,\n \t\t\t\toperands[2], operands[3]);\n   operands[7] = gen_lowpart (SImode, operands[5]);\n-}\")\n+})\n \n (define_insn \"addvsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -669,7 +666,6 @@\n    && operands[1] != arg_pointer_rtx\"\n   [(set (match_dup 0) (plus:DI (match_dup 1) (match_dup 3)))\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 4)))]\n-  \"\n {\n   HOST_WIDE_INT val = INTVAL (operands[2]);\n   HOST_WIDE_INT low = (val & 0xffff) - 2 * (val & 0x8000);\n@@ -687,7 +683,7 @@\n     }\n   else\n     FAIL;\n-}\")\n+})\n \n (define_insn \"*saddl\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -724,12 +720,11 @@\n    (set (match_dup 0)\n \t(sign_extend:DI (plus:SI (mult:SI (match_dup 8) (match_dup 4))\n \t\t\t\t (match_dup 5))))]\n-  \"\n {\n   operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[1]), DImode,\n \t\t\t\toperands[2], operands[3]);\n   operands[8] = gen_lowpart (SImode, operands[6]);\n-}\")\n+})\n \n (define_insn \"*saddq\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n@@ -797,7 +792,6 @@\n \t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"\")\n \t\t  (match_operand:SI 2 \"reg_or_8bit_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (optimize)\n     {\n@@ -814,7 +808,7 @@\n         emit_insn (gen_subdi3 (gen_lowpart (DImode, operands[0]), op1, op2));\n       DONE;\n     }\n-} \")\n+})\n \n (define_insn \"*subsi_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1133,7 +1127,6 @@\n   \"HOST_BITS_PER_WIDE_INT == 64 && ! and_operand (operands[2], DImode)\"\n   [(set (match_dup 0) (and:DI (match_dup 1) (match_dup 3)))\n    (set (match_dup 0) (and:DI (match_dup 0) (match_dup 4)))]\n-  \"\n {\n   unsigned HOST_WIDE_INT mask1 = INTVAL (operands[2]);\n   unsigned HOST_WIDE_INT mask2 = mask1;\n@@ -1149,17 +1142,16 @@\n \n   operands[3] = GEN_INT (mask1);\n   operands[4] = GEN_INT (mask2);\n-}\")\n+})\n \n (define_expand \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (! TARGET_BWX)\n     operands[1] = force_reg (QImode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*zero_extendqihi2_bwx\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n@@ -1181,11 +1173,10 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (! TARGET_BWX)\n     operands[1] = force_reg (QImode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*zero_extendqisi2_bwx\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -1207,11 +1198,10 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (! TARGET_BWX)\n     operands[1] = force_reg (QImode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*zero_extendqidi2_bwx\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n@@ -1233,11 +1223,10 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (! TARGET_BWX)\n     operands[1] = force_reg (HImode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*zero_extendhisi2_bwx\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -1259,11 +1248,10 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extend:DI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if (! TARGET_BWX)\n     operands[1] = force_reg (HImode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*zero_extendhidi2_bwx\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n@@ -1350,11 +1338,10 @@\n \t(if_then_else:DI (eq (match_dup 1) (const_int 0))\n \t\t\t (const_int 0) (match_dup 3)))]\n   \"TARGET_CIX\"\n-  \"\n {\n   operands[2] = gen_reg_rtx (DImode);\n   operands[3] = gen_reg_rtx (DImode);\n-}\")\n+})\n \n (define_insn \"*cttz\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -1372,21 +1359,20 @@\n \t(ashift:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ,rJ\")\n \t\t   (match_operand:DI 2 \"reg_or_6bit_operand\" \"P,rS\")))]\n   \"\"\n-  \"*\n {\n   switch (which_alternative)\n     {\n     case 0:\n       if (operands[2] == const1_rtx)\n-\treturn \\\"addq %r1,%r1,%0\\\";\n+\treturn \"addq %r1,%r1,%0\";\n       else\n-\treturn \\\"s%P2addq %r1,0,%0\\\";\n+\treturn \"s%P2addq %r1,0,%0\";\n     case 1:\n-      return \\\"sll %r1,%2,%0\\\";\n+      return \"sll %r1,%2,%0\";\n     default:\n       abort();\n     }\n-}\"\n+}\n   [(set_attr \"type\" \"iadd,shift\")])\n \n ;; ??? The following pattern is made by combine, but earlier phases\n@@ -1399,13 +1385,12 @@\n ;;\t\t\t       (match_operand:DI 2 \"const_int_operand\" \"P\"))\n ;;\t\t    0)))]\n ;;  \"INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 3\"\n-;;  \"*\n ;;{\n ;;  if (operands[2] == const1_rtx)\n-;;    return \\\"addl %r1,%r1,%0\\\";\n+;;    return \"addl %r1,%r1,%0\";\n ;;  else\n-;;    return \\\"s%P2addl %r1,0,%0\\\";\n-;; }\"\n+;;    return \"s%P2addl %r1,0,%0\";\n+;;}\n ;;  [(set_attr \"type\" \"iadd\")])\n \n (define_insn \"lshrdi3\"\n@@ -1432,7 +1417,6 @@\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 56)))]\n   \"\"\n-  \"\n {\n   if (TARGET_BWX)\n     {\n@@ -1455,7 +1439,7 @@\n   operands[0] = gen_lowpart (DImode, operands[0]);\n   operands[1] = gen_lowpart (DImode, force_reg (QImode, operands[1]));\n   operands[2] = gen_reg_rtx (DImode);\n-}\")\n+})\n \n (define_insn \"extendqidi2x\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -1500,7 +1484,6 @@\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 56)))]\n   \"\"\n-  \"\n {\n   if (TARGET_BWX)\n     {\n@@ -1523,7 +1506,7 @@\n   operands[0] = gen_lowpart (DImode, operands[0]);\n   operands[1] = gen_lowpart (DImode, force_reg (QImode, operands[1]));\n   operands[2] = gen_reg_rtx (DImode);\n-}\")\n+})\n \n (define_expand \"extendqidi2\"\n   [(set (match_dup 2)\n@@ -1533,7 +1516,6 @@\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 56)))]\n   \"\"\n-  \"\n {\n   if (TARGET_BWX)\n     {\n@@ -1555,7 +1537,7 @@\n \n   operands[1] = gen_lowpart (DImode, force_reg (QImode, operands[1]));\n   operands[2] = gen_reg_rtx (DImode);\n-}\")\n+})\n \n (define_expand \"extendhisi2\"\n   [(set (match_dup 2)\n@@ -1565,7 +1547,6 @@\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 48)))]\n   \"\"\n-  \"\n {\n   if (TARGET_BWX)\n     {\n@@ -1588,7 +1569,7 @@\n   operands[0] = gen_lowpart (DImode, operands[0]);\n   operands[1] = gen_lowpart (DImode, force_reg (HImode, operands[1]));\n   operands[2] = gen_reg_rtx (DImode);\n-}\")\n+})\n \n (define_expand \"extendhidi2\"\n   [(set (match_dup 2)\n@@ -1598,7 +1579,6 @@\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 48)))]\n   \"\"\n-  \"\n {\n   if (TARGET_BWX)\n     {\n@@ -1620,7 +1600,7 @@\n \n   operands[1] = gen_lowpart (DImode, force_reg (HImode, operands[1]));\n   operands[2] = gen_reg_rtx (DImode);\n-}\")\n+})\n \n ;; Here's how we sign extend an unaligned byte and halfword.  Doing this\n ;; as a pattern saves one instruction.  The code is similar to that for\n@@ -1641,11 +1621,11 @@\n    (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n \t(ashiftrt:DI (match_dup 4) (const_int 56)))]\n   \"\"\n-  \"\n-{ operands[2] = gen_reg_rtx (DImode);\n+{\n+  operands[2] = gen_reg_rtx (DImode);\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n-}\")\n+})\n \n (define_expand \"unaligned_extendhidi\"\n   [(set (match_dup 2) (match_operand:DI 1 \"address_operand\" \"\"))\n@@ -1661,11 +1641,11 @@\n    (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n \t(ashiftrt:DI (match_dup 4) (const_int 48)))]\n   \"\"\n-  \"\n-{ operands[2] = gen_reg_rtx (DImode);\n+{\n+  operands[2] = gen_reg_rtx (DImode);\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n-}\")\n+})\n \n (define_insn \"*extxl_const\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -1855,21 +1835,20 @@\n         == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\n        || ((unsigned HOST_WIDE_INT) 0xffffffff << INTVAL (operands[2])\n         == (unsigned HOST_WIDE_INT) INTVAL (operands[3])))\"\n-  \"*\n {\n #if HOST_BITS_PER_WIDE_INT == 64\n   if ((unsigned HOST_WIDE_INT) 0xff << INTVAL (operands[2])\n       == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\n-    return \\\"insbl %1,%s2,%0\\\";\n+    return \"insbl %1,%s2,%0\";\n   if ((unsigned HOST_WIDE_INT) 0xffff << INTVAL (operands[2])\n       == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\n-    return \\\"inswl %1,%s2,%0\\\";\n+    return \"inswl %1,%s2,%0\";\n   if ((unsigned HOST_WIDE_INT) 0xffffffff << INTVAL (operands[2])\n       == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\n-    return \\\"insll %1,%s2,%0\\\";\n+    return \"insll %1,%s2,%0\";\n #endif\n   abort();\n-}\"\n+}\n   [(set_attr \"type\" \"shift\")])\n \n ;; We do not include the insXh insns because they are complex to express\n@@ -1967,14 +1946,13 @@\n \t\t   (neg:TF (match_operand:TF 1 \"reg_or_fp0_operand\" \"\")))\n \t      (use (match_dup 2))])]\n   \"TARGET_HAS_XFLOATING_LIBS\"\n-  \"\n {\n #if HOST_BITS_PER_WIDE_INT >= 64\n   operands[2] = force_reg (DImode, GEN_INT (0x8000000000000000));\n #else\n   operands[2] = force_reg (DImode, immed_double_const (0, 0x80000000, DImode));\n #endif\n-}\")\n+})\n \n (define_insn_and_split \"*abstf_internal\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=r\")\n@@ -2005,14 +1983,13 @@\n \t\t   (neg:TF (match_operand:TF 1 \"reg_or_fp0_operand\" \"\")))\n \t      (use (match_dup 2))])]\n   \"TARGET_HAS_XFLOATING_LIBS\"\n-  \"\n {\n #if HOST_BITS_PER_WIDE_INT >= 64\n   operands[2] = force_reg (DImode, GEN_INT (0x8000000000000000));\n #else\n   operands[2] = force_reg (DImode, immed_double_const (0, 0x80000000, DImode));\n #endif\n-}\")\n+})\n \n (define_insn_and_split \"*negtf_internal\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=r\")\n@@ -2270,11 +2247,10 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(float_extend:DF (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_FP\"\n-  \"\n {\n   if (alpha_fptm >= ALPHA_FPTM_SU)\n     operands[1] = force_reg (SFmode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*extendsfdf2_ieee\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=&f\")\n@@ -2298,13 +2274,12 @@\n   [(use (match_operand:TF 0 \"register_operand\" \"\"))\n    (use (match_operand:SF 1 \"general_operand\" \"\"))]\n   \"TARGET_HAS_XFLOATING_LIBS\"\n-  \"\n {\n   rtx tmp = gen_reg_rtx (DFmode);\n   emit_insn (gen_extendsfdf2 (tmp, operands[1]));\n   emit_insn (gen_extenddftf2 (operands[0], tmp));\n   DONE;\n-}\")\n+})\n \n (define_expand \"extenddftf2\"\n   [(use (match_operand:TF 0 \"register_operand\" \"\"))\n@@ -2338,7 +2313,6 @@\n   [(use (match_operand:SF 0 \"register_operand\" \"\"))\n    (use (match_operand:TF 1 \"general_operand\" \"\"))]\n   \"TARGET_FP && TARGET_HAS_XFLOATING_LIBS\"\n-  \"\n {\n   rtx tmpf, sticky, arg, lo, hi;\n \n@@ -2359,7 +2333,7 @@\n   emit_insn (gen_trunctfdf2 (tmpf, arg));\n   emit_insn (gen_truncdfsf2 (operands[0], tmpf));\n   DONE;\n-}\")\n+})\n \n (define_insn \"*divsf3_ieee\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n@@ -2845,14 +2819,13 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(abs:DI (match_operand:DI 1 \"register_operand\" \"\")))]\n   \"\"\n-  \"\n-{ if (rtx_equal_p (operands[0], operands[1]))\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n     emit_insn (gen_absdi2_same (operands[0], gen_reg_rtx (DImode)));\n   else\n     emit_insn (gen_absdi2_diff (operands[0], operands[1]));\n-\n   DONE;\n-}\")\n+})\n \n (define_expand \"absdi2_same\"\n   [(set (match_operand:DI 1 \"register_operand\" \"\")\n@@ -2984,9 +2957,7 @@\n \t(if_then_else:DI (eq (match_dup 3) (const_int 0))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"\n-{ operands[3] = gen_reg_rtx (DImode);\n-}\")\n+  { operands[3] = gen_reg_rtx (DImode); })\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -3015,9 +2986,7 @@\n \t(if_then_else:DI (ne (match_dup 3) (const_int 0))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"\n-{ operands[3] = gen_reg_rtx (DImode);\n-}\")\n+  { operands[3] = gen_reg_rtx (DImode); })\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -3343,10 +3312,10 @@\n \t(if_then_else:DF (eq (match_dup 3) (match_dup 4))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"TARGET_FP\"\n-  \"\n-{ operands[3] = gen_reg_rtx (DFmode);\n+{\n+  operands[3] = gen_reg_rtx (DFmode);\n   operands[4] = CONST0_RTX (DFmode);\n-}\")\n+})\n \n (define_expand \"mindf3\"\n   [(set (match_dup 3)\n@@ -3356,10 +3325,10 @@\n \t(if_then_else:DF (ne (match_dup 3) (match_dup 4))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"TARGET_FP\"\n-  \"\n-{ operands[3] = gen_reg_rtx (DFmode);\n+{\n+  operands[3] = gen_reg_rtx (DFmode);\n   operands[4] = CONST0_RTX (DFmode);\n-}\")\n+})\n \n (define_expand \"maxsf3\"\n   [(set (match_dup 3)\n@@ -3369,10 +3338,10 @@\n \t(if_then_else:SF (eq (match_dup 3) (match_dup 4))\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"TARGET_FP\"\n-  \"\n-{ operands[3] = gen_reg_rtx (DFmode);\n+{\n+  operands[3] = gen_reg_rtx (DFmode);\n   operands[4] = CONST0_RTX (DFmode);\n-}\")\n+})\n \n (define_expand \"minsf3\"\n   [(set (match_dup 3)\n@@ -3382,10 +3351,10 @@\n \t(if_then_else:SF (ne (match_dup 3) (match_dup 4))\n \t\t      (match_dup 1) (match_dup 2)))]\n   \"TARGET_FP\"\n-  \"\n-{ operands[3] = gen_reg_rtx (DFmode);\n+{\n+  operands[3] = gen_reg_rtx (DFmode);\n   operands[4] = CONST0_RTX (DFmode);\n-}\")\n+})\n \n (define_insn \"*fbcc_normal\"\n   [(set (pc)\n@@ -3419,37 +3388,34 @@\n   [(set (cc0) (compare (match_operand:DF 0 \"reg_or_fp0_operand\" \"\")\n \t\t       (match_operand:DF 1 \"reg_or_fp0_operand\" \"\")))]\n   \"TARGET_FP\"\n-  \"\n {\n   alpha_compare.op0 = operands[0];\n   alpha_compare.op1 = operands[1];\n   alpha_compare.fp_p = 1;\n   DONE;\n-}\")\n+})\n \n (define_expand \"cmptf\"\n   [(set (cc0) (compare (match_operand:TF 0 \"general_operand\" \"\")\n \t\t       (match_operand:TF 1 \"general_operand\" \"\")))]\n   \"TARGET_HAS_XFLOATING_LIBS\"\n-  \"\n {\n   alpha_compare.op0 = operands[0];\n   alpha_compare.op1 = operands[1];\n   alpha_compare.fp_p = 1;\n   DONE;\n-}\")\n+})\n \n (define_expand \"cmpdi\"\n   [(set (cc0) (compare (match_operand:DI 0 \"general_operand\" \"\")\n \t\t       (match_operand:DI 1 \"general_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   alpha_compare.op0 = operands[0];\n   alpha_compare.op1 = operands[1];\n   alpha_compare.fp_p = 0;\n   DONE;\n-}\")\n+})\n \n (define_expand \"beq\"\n   [(set (pc)\n@@ -3627,47 +3593,43 @@\n \t\t\t (match_operand:SI 2 \"reg_or_8bit_operand\" \"\")\n \t\t\t (match_operand:SI 3 \"reg_or_8bit_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if ((operands[1] = alpha_emit_conditional_move (operands[1], SImode)) == 0)\n     FAIL;\n-}\")\n+})\n \n (define_expand \"movdicc\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(if_then_else:DI (match_operand 1 \"comparison_operator\" \"\")\n \t\t\t (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")\n \t\t\t (match_operand:DI 3 \"reg_or_8bit_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if ((operands[1] = alpha_emit_conditional_move (operands[1], DImode)) == 0)\n     FAIL;\n-}\")\n+})\n \n (define_expand \"movsfcc\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n \t\t\t (match_operand:SF 2 \"reg_or_8bit_operand\" \"\")\n \t\t\t (match_operand:SF 3 \"reg_or_8bit_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if ((operands[1] = alpha_emit_conditional_move (operands[1], SFmode)) == 0)\n     FAIL;\n-}\")\n+})\n \n (define_expand \"movdfcc\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n \t\t\t (match_operand:DF 2 \"reg_or_8bit_operand\" \"\")\n \t\t\t (match_operand:DF 3 \"reg_or_8bit_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   if ((operands[1] = alpha_emit_conditional_move (operands[1], DFmode)) == 0)\n     FAIL;\n-}\")\n+})\n \f\n ;; These define_split definitions are used in cases when comparisons have\n ;; not be stated in the correct way and we need to reverse the second\n@@ -3699,8 +3661,8 @@\n   [(set (match_dup 6) (match_dup 7))\n    (set (match_dup 0)\n \t(if_then_else:DI (match_dup 8) (match_dup 4) (match_dup 5)))]\n-  \"\n-{ enum rtx_code code = GET_CODE (operands[1]);\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n   int unsignedp = (code == GEU || code == LEU || code == GTU || code == LTU);\n \n   /* If we are comparing for equality with a constant and that constant\n@@ -3741,7 +3703,7 @@\n \t\t\t\t    operands[2], operands[3]);\n       operands[8] = gen_rtx_EQ (VOIDmode, operands[6], const0_rtx);\n     }\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -3757,8 +3719,8 @@\n   [(set (match_dup 6) (match_dup 7))\n    (set (match_dup 0)\n \t(if_then_else:DI (match_dup 8) (match_dup 4) (match_dup 5)))]\n-  \"\n-{ enum rtx_code code = GET_CODE (operands[1]);\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n   int unsignedp = (code == GEU || code == LEU || code == GTU || code == LTU);\n   rtx tem;\n \n@@ -3776,7 +3738,7 @@\n   operands[7] = gen_rtx_SIGN_EXTEND (DImode, tem);\n   operands[8] = gen_rtx_fmt_ee (GET_CODE (operands[1]), VOIDmode,\n \t\t\t\toperands[6], const0_rtx);\n-}\")\n+})\n \n (define_split\n   [(set (pc)\n@@ -3790,8 +3752,8 @@\n   \"operands[3] != const0_rtx\"\n   [(set (match_dup 4) (match_dup 5))\n    (set (pc) (if_then_else (match_dup 6) (label_ref (match_dup 0)) (pc)))]\n-  \"\n-{ enum rtx_code code = GET_CODE (operands[1]);\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n   int unsignedp = (code == GEU || code == LEU || code == GTU || code == LTU);\n \n   if (code == NE || code == EQ\n@@ -3819,7 +3781,7 @@\n \t\t\t\t    operands[2], operands[3]);\n       operands[6] = gen_rtx_EQ (VOIDmode, operands[4], const0_rtx);\n     }\n-}\")\n+})\n \n (define_split\n   [(set (pc)\n@@ -3834,8 +3796,8 @@\n    && (GET_CODE (operands[1]) == EQ || GET_CODE (operands[1]) == NE)\"\n   [(set (match_dup 4) (match_dup 5))\n    (set (pc) (if_then_else (match_dup 6) (label_ref (match_dup 0)) (pc)))]\n-  \"\n-{ rtx tem;\n+{\n+  rtx tem;\n \n   if (GET_CODE (operands[3]) == CONST_INT)\n     tem = gen_rtx_PLUS (SImode, operands[2],\n@@ -3846,7 +3808,7 @@\n   operands[5] = gen_rtx_SIGN_EXTEND (DImode, tem);\n   operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[1]), VOIDmode,\n \t\t\t\toperands[4], const0_rtx);\n-}\")\n+})\n \n ;; We can convert such things as \"a > 0xffff\" to \"t = a & ~ 0xffff; t != 0\".\n ;; This eliminates one, and sometimes two, insns when the AND can be done\n@@ -3864,14 +3826,13 @@\n \t   && extended_count (operands[2], DImode, 1) > 0))\"\n   [(set (match_dup 4) (and:DI (match_dup 2) (match_dup 5)))\n    (set (match_dup 0) (match_dup 6))]\n-  \"\n {\n   operands[5] = GEN_INT (~ INTVAL (operands[3]));\n   operands[6] = gen_rtx_fmt_ee (((GET_CODE (operands[1]) == GTU\n \t\t\t\t  || GET_CODE (operands[1]) == GT)\n \t\t\t\t ? NE : EQ),\n \t\t\t\tDImode, operands[4], const0_rtx);\n-}\")\n+})\n \n ;; Prefer to use cmp and arithmetic when possible instead of a cmove.\n \n@@ -3884,14 +3845,13 @@\n \t  (match_operand 4 \"const_int_operand\" \"\")))]\n   \"\"\n   [(const_int 0)]\n-  \"\n {\n   if (alpha_split_conditional_move (GET_CODE (operands[1]), operands[0],\n \t\t\t\t    operands[2], operands[3], operands[4]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n ;; ??? Why combine is allowed to create such non-canonical rtl, I don't know.\n ;; Oh well, we match it in movcc, so it must be partially our fault.\n@@ -3904,15 +3864,14 @@\n \t  (match_operand 4 \"const_int_operand\" \"\")))]\n   \"\"\n   [(const_int 0)]\n-  \"\n {\n   if (alpha_split_conditional_move (swap_condition (GET_CODE (operands[1])),\n \t\t\t\t    operands[0], operands[2], operands[3],\n \t\t\t\t    operands[4]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_insn_and_split \"*cmp_sadd_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -3932,13 +3891,12 @@\n    (set (match_dup 0)\n \t(plus:DI (mult:DI (match_dup 5) (match_dup 3))\n \t\t (match_dup 4)))]\n-  \"\n {\n   if (! no_new_pseudos)\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n-}\")\n+})\n \n (define_insn_and_split \"*cmp_sadd_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -3958,13 +3916,12 @@\n    (set (match_dup 0)\n \t(plus:SI (mult:SI (match_dup 5) (match_dup 3))\n \t\t (match_dup 4)))]\n-  \"\n {\n   if (! no_new_pseudos)\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n-}\")\n+})\n \n (define_insn_and_split \"*cmp_sadd_sidi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -3985,13 +3942,12 @@\n    (set (match_dup 0)\n \t(sign_extend:DI (plus:SI (mult:SI (match_dup 5) (match_dup 3))\n \t\t\t\t (match_dup 4))))]\n-  \"\n {\n   if (! no_new_pseudos)\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n-}\")\n+})\n \n (define_insn_and_split \"*cmp_ssub_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4011,13 +3967,12 @@\n    (set (match_dup 0)\n \t(minus:DI (mult:DI (match_dup 5) (match_dup 3))\n \t\t  (match_dup 4)))]\n-  \"\n {\n   if (! no_new_pseudos)\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n-}\")\n+})\n \n (define_insn_and_split \"*cmp_ssub_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -4037,13 +3992,12 @@\n    (set (match_dup 0)\n \t(minus:SI (mult:SI (match_dup 5) (match_dup 3))\n \t\t (match_dup 4)))]\n-  \"\n {\n   if (! no_new_pseudos)\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n-}\")\n+})\n \n (define_insn_and_split \"*cmp_ssub_sidi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4064,13 +4018,12 @@\n    (set (match_dup 0)\n \t(sign_extend:DI (minus:SI (mult:SI (match_dup 5) (match_dup 3))\n \t\t\t\t  (match_dup 4))))]\n-  \"\n {\n   if (! no_new_pseudos)\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n-}\")\n+})\n \f\n ;; Here are the CALL and unconditional branch insns.  Calls on NT and OSF\n ;; work differently, so we have different patterns for each.\n@@ -4081,36 +4034,34 @@\n    (use (match_operand 2 \"\" \"\"))\n    (use (match_operand 3 \"\" \"\"))]\n   \"\"\n-  \"\n-{ if (TARGET_ABI_WINDOWS_NT)\n+{\n+  if (TARGET_ABI_WINDOWS_NT)\n     emit_call_insn (gen_call_nt (operands[0], operands[1]));\n   else if (TARGET_ABI_OPEN_VMS)\n     emit_call_insn (gen_call_vms (operands[0], operands[2]));\n   else\n     emit_call_insn (gen_call_osf (operands[0], operands[1]));\n-\n   DONE;\n-}\")\n+})\n \n (define_expand \"sibcall\"\n   [(call (mem:DI (match_operand 0 \"\" \"\"))\n \t\t (match_operand 1 \"\" \"\"))]\n   \"TARGET_ABI_OSF\"\n-  \"\n {\n   if (GET_CODE (operands[0]) != MEM)\n     abort ();\n   operands[0] = XEXP (operands[0], 0);\n-}\")\n+})\n \n (define_expand \"call_osf\"\n   [(parallel [(call (mem:DI (match_operand 0 \"\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (clobber (reg:DI 27))\n \t      (clobber (reg:DI 26))])]\n   \"\"\n-  \"\n-{ if (GET_CODE (operands[0]) != MEM)\n+{\n+  if (GET_CODE (operands[0]) != MEM)\n     abort ();\n \n   operands[0] = XEXP (operands[0], 0);\n@@ -4122,21 +4073,21 @@\n       emit_move_insn (tem, operands[0]);\n       operands[0] = tem;\n     }\n-}\")\n+})\n \n (define_expand \"call_nt\"\n   [(parallel [(call (mem:DI (match_operand 0 \"\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (clobber (reg:DI 26))])]\n   \"\"\n-  \"\n-{ if (GET_CODE (operands[0]) != MEM)\n+{\n+  if (GET_CODE (operands[0]) != MEM)\n     abort ();\n \n   operands[0] = XEXP (operands[0], 0);\n   if (GET_CODE (operands[0]) != SYMBOL_REF && GET_CODE (operands[0]) != REG)\n     operands[0] = force_reg (DImode, operands[0]);\n-}\")\n+})\n \n ;;\n ;; call openvms/alpha\n@@ -4151,8 +4102,8 @@\n \t      (use (reg:DI 26))\n \t      (clobber (reg:DI 27))])]\n   \"\"\n-  \"\n-{ if (GET_CODE (operands[0]) != MEM)\n+{\n+  if (GET_CODE (operands[0]) != MEM)\n     abort ();\n \n   operands[0] = XEXP (operands[0], 0);\n@@ -4177,7 +4128,7 @@\n       operands[2] = operands[0];\n     }\n \n-}\")\n+})\n \n (define_expand \"call_value\"\n   [(use (match_operand 0 \"\" \"\"))\n@@ -4186,7 +4137,6 @@\n    (use (match_operand 3 \"\" \"\"))\n    (use (match_operand 4 \"\" \"\"))]\n   \"\"\n-  \"\n {\n   if (TARGET_ABI_WINDOWS_NT)\n     emit_call_insn (gen_call_value_nt (operands[0], operands[1], operands[2]));\n@@ -4197,19 +4147,18 @@\n     emit_call_insn (gen_call_value_osf (operands[0], operands[1],\n \t\t\t\t\toperands[2]));\n   DONE;\n-}\")\n+})\n \n (define_expand \"sibcall_value\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:DI (match_operand 1 \"\" \"\"))\n \t      (match_operand 2 \"\" \"\")))]\n   \"TARGET_ABI_OSF\"\n-  \"\n {\n   if (GET_CODE (operands[1]) != MEM)\n     abort ();\n   operands[1] = XEXP (operands[1], 0);\n-}\")\n+})\n \n (define_expand \"call_value_osf\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -4218,8 +4167,8 @@\n \t      (clobber (reg:DI 27))\n \t      (clobber (reg:DI 26))])]\n   \"\"\n-  \"\n-{ if (GET_CODE (operands[1]) != MEM)\n+{\n+  if (GET_CODE (operands[1]) != MEM)\n     abort ();\n \n   operands[1] = XEXP (operands[1], 0);\n@@ -4231,22 +4180,22 @@\n       emit_move_insn (tem, operands[1]);\n       operands[1] = tem;\n     }\n-}\")\n+})\n \n (define_expand \"call_value_nt\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n \t\t   (call (mem:DI (match_operand 1 \"\" \"\"))\n \t\t\t (match_operand 2 \"\" \"\")))\n \t      (clobber (reg:DI 26))])]\n   \"\"\n-  \"\n-{ if (GET_CODE (operands[1]) != MEM)\n+{\n+  if (GET_CODE (operands[1]) != MEM)\n     abort ();\n \n   operands[1] = XEXP (operands[1], 0);\n   if (GET_CODE (operands[1]) != SYMBOL_REF && GET_CODE (operands[1]) != REG)\n     operands[1] = force_reg (DImode, operands[1]);\n-}\")\n+})\n \n (define_expand \"call_value_vms\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -4257,8 +4206,8 @@\n \t      (use (reg:DI 26))\n \t      (clobber (reg:DI 27))])]\n   \"\"\n-  \"\n-{ if (GET_CODE (operands[1]) != MEM)\n+{\n+  if (GET_CODE (operands[1]) != MEM)\n     abort ();\n \n   operands[1] = XEXP (operands[1], 0);\n@@ -4282,7 +4231,7 @@\n \t\t      gen_rtx_MEM (Pmode, plus_constant (operands[1], 8)));\n       operands[3] = operands[1];\n     }\n-}\")\n+})\n \n (define_insn \"*call_osf_1_noreturn\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,i\"))\n@@ -4354,7 +4303,6 @@\n \t      (match_operand 1 \"\" \"\")\n \t      (match_operand 2 \"\" \"\")])]\n   \"\"\n-  \"\n {\n   int i;\n \n@@ -4373,7 +4321,7 @@\n   emit_insn (gen_blockage ());\n \n   DONE;\n-}\")\n+})\n \n ;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n ;; all of memory.  This blocks insns from being moved across this point.\n@@ -4412,7 +4360,6 @@\n   [(use (match_operand:SI 0 \"register_operand\" \"\"))\n    (use (match_operand:SI 1 \"\" \"\"))]\n   \"\"\n-  \"\n {\n   if (TARGET_ABI_WINDOWS_NT)\n     emit_jump_insn (gen_tablejump_nt (operands[0], operands[1]));\n@@ -4422,18 +4369,18 @@\n     emit_jump_insn (gen_tablejump_osf (operands[0], operands[1]));\n \n   DONE;\n-}\")\n+})\n \n (define_expand \"tablejump_osf\"\n   [(set (match_dup 3)\n \t(sign_extend:DI (match_operand:SI 0 \"register_operand\" \"\")))\n+   (set (match_dup 3)\n+\t(plus:DI (reg:DI 29) (match_dup 3)))\n    (parallel [(set (pc)\n-\t\t   (plus:DI (match_dup 3)\n-\t\t\t    (label_ref (match_operand 1 \"\" \"\"))))\n-\t      (clobber (match_scratch:DI 2 \"=r\"))])]\n+\t\t   (match_dup 3))\n+\t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n   \"\"\n-  \"\n-{ operands[3] = gen_reg_rtx (DImode); }\")\n+  { operands[3] = gen_reg_rtx (DImode); })\n \n (define_expand \"tablejump_nt\"\n   [(set (match_dup 3)\n@@ -4442,8 +4389,7 @@\n \t\t   (match_dup 3))\n \t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n   \"\"\n-  \"\n-{ operands[3] = gen_reg_rtx (DImode); }\")\n+  { operands[3] = gen_reg_rtx (DImode); })\n \n ;;\n ;; tablejump, openVMS way\n@@ -4457,95 +4403,18 @@\n \t(plus:DI (match_dup 2)\n \t\t(label_ref (match_operand 1 \"\" \"\"))))]\n   \"\"\n-  \"\n-{ operands[2] = gen_reg_rtx (DImode); }\")\n-\n-(define_insn \"*tablejump_osf_internal\"\n-  [(set (pc)\n-\t(plus (match_operand:DI 0 \"register_operand\" \"r\")\n-\t      (label_ref (match_operand 1 \"\" \"\"))))\n-   (clobber (match_scratch:DI 2 \"=r\"))]\n-  \"TARGET_ABI_OSF && next_active_insn (insn) != 0\n-   && GET_CODE (PATTERN (next_active_insn (insn))) == ADDR_DIFF_VEC\n-   && PREV_INSN (next_active_insn (insn)) == operands[1]\"\n-  \"*\n-{ rtx best_label = 0;\n-  rtx jump_table_insn = next_active_insn (operands[1]);\n-\n-  if (GET_CODE (jump_table_insn) == JUMP_INSN\n-      && GET_CODE (PATTERN (jump_table_insn)) == ADDR_DIFF_VEC)\n-    {\n-      rtx jump_table = PATTERN (jump_table_insn);\n-      int n_labels = XVECLEN (jump_table, 1);\n-      int best_count = -1;\n-      int i, j;\n-\n-      for (i = 0; i < n_labels; i++)\n-\t{\n-\t  int count = 1;\n-\n-\t  for (j = i + 1; j < n_labels; j++)\n-\t    if (XEXP (XVECEXP (jump_table, 1, i), 0)\n-\t\t== XEXP (XVECEXP (jump_table, 1, j), 0))\n-\t      count++;\n-\n-\t  if (count > best_count)\n-\t    best_count = count, best_label = XVECEXP (jump_table, 1, i);\n-\t}\n-    }\n-\n-  if (best_label)\n-    {\n-      operands[3] = best_label;\n-      return \\\"addq %0,$29,%2\\;jmp $31,(%2),%3\\\";\n-    }\n-  else\n-    return \\\"addq %0,$29,%2\\;jmp $31,(%2),0\\\";\n-}\"\n-  [(set_attr \"type\" \"ibr\")\n-   (set_attr \"length\" \"8\")])\n+  { operands[2] = gen_reg_rtx (DImode); })\n \n-(define_insn \"*tablejump_nt_internal\"\n+(define_insn \"*tablejump_osf_nt_internal\"\n   [(set (pc)\n \t(match_operand:DI 0 \"register_operand\" \"r\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"TARGET_ABI_WINDOWS_NT && next_active_insn (insn) != 0\n-   && GET_CODE (PATTERN (next_active_insn (insn))) == ADDR_DIFF_VEC\n-   && PREV_INSN (next_active_insn (insn)) == operands[1]\"\n-  \"*\n-{ rtx best_label = 0;\n-  rtx jump_table_insn = next_active_insn (operands[1]);\n-\n-  if (GET_CODE (jump_table_insn) == JUMP_INSN\n-      && GET_CODE (PATTERN (jump_table_insn)) == ADDR_DIFF_VEC)\n-    {\n-      rtx jump_table = PATTERN (jump_table_insn);\n-      int n_labels = XVECLEN (jump_table, 1);\n-      int best_count = -1;\n-      int i, j;\n-\n-      for (i = 0; i < n_labels; i++)\n-\t{\n-\t  int count = 1;\n-\n-\t  for (j = i + 1; j < n_labels; j++)\n-\t    if (XEXP (XVECEXP (jump_table, 1, i), 0)\n-\t\t== XEXP (XVECEXP (jump_table, 1, j), 0))\n-\t      count++;\n-\n-\t  if (count > best_count)\n-\t    best_count = count, best_label = XVECEXP (jump_table, 1, i);\n-\t}\n-    }\n-\n-  if (best_label)\n-    {\n-      operands[2] = best_label;\n-      return \\\"jmp $31,(%0),%2\\\";\n-    }\n-  else\n-    return \\\"jmp $31,(%0),0\\\";\n-}\"\n+  \"(TARGET_ABI_OSF || TARGET_ABI_WINDOWS_NT)\n+   && alpha_tablejump_addr_vec (insn)\"\n+{\n+  operands[2] = alpha_tablejump_best_label (insn);\n+  return \"jmp $31,(%0),%2\";\n+}\n   [(set_attr \"type\" \"ibr\")])\n \n ;;\n@@ -4677,7 +4546,6 @@\n   \"reload_completed\"\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 1) (match_dup 3))]\n-  \"\n {\n   alpha_split_tfmode_pair (operands);\n   if (reg_overlap_mentioned_p (operands[0], operands[3]))\n@@ -4686,40 +4554,37 @@\n       tmp = operands[0], operands[0] = operands[1], operands[1] = tmp;\n       tmp = operands[2], operands[2] = operands[3], operands[3] = tmp;\n     }\n-}\")\n+})\n \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:SF 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (GET_CODE (operands[0]) == MEM\n       && ! reg_or_fp0_operand (operands[1], SFmode))\n     operands[1] = force_reg (SFmode, operands[1]);\n-}\")\n+})\n \n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (GET_CODE (operands[0]) == MEM\n       && ! reg_or_fp0_operand (operands[1], DFmode))\n     operands[1] = force_reg (DFmode, operands[1]);\n-}\")\n+})\n \n (define_expand \"movtf\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:TF 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (GET_CODE (operands[0]) == MEM\n       && ! reg_or_fp0_operand (operands[1], TFmode))\n     operands[1] = force_reg (TFmode, operands[1]);\n-}\")\n+})\n \n (define_insn \"*movsi_nofix\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,*f,*f,m\")\n@@ -4830,7 +4695,6 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (GET_CODE (operands[0]) == MEM\n       && ! reg_or_0_operand (operands[1], SImode))\n@@ -4845,7 +4709,7 @@\n       if (rtx_equal_p (operands[0], operands[1]))\n \tDONE;\n     }\n-}\")\n+})\n \n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence.\n@@ -4856,15 +4720,15 @@\n   \"! add_operand (operands[1], SImode)\"\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 3)))]\n-  \"\n-{ rtx tem\n+{\n+  rtx tem\n     = alpha_emit_set_const (operands[0], SImode, INTVAL (operands[1]), 2);\n \n   if (tem == operands[0])\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_insn \"*movdi_nofix\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q\")\n@@ -4911,7 +4775,6 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   rtx tem;\n \n@@ -4975,7 +4838,7 @@\n     }\n   else\n     abort ();\n-}\")\n+})\n \n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence.\n@@ -4986,15 +4849,15 @@\n   \"! add_operand (operands[1], DImode)\"\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 3)))]\n-  \"\n-{ rtx tem\n+{\n+  rtx tem\n     = alpha_emit_set_const (operands[0], DImode, INTVAL (operands[1]), 2);\n \n   if (tem == operands[0])\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n ;; These are the partial-word cases.\n ;;\n@@ -5076,10 +4939,10 @@\n \t(ior:DI (subreg:DI (match_dup 4) 0) (subreg:DI (match_dup 3) 0)))\n    (set (match_dup 0) (match_dup 4))]\n   \"\"\n-  \"\n-{ operands[5] = GEN_INT (~ (GET_MODE_MASK (GET_MODE (operands[1]))\n+{\n+  operands[5] = GEN_INT (~ (GET_MODE_MASK (GET_MODE (operands[1]))\n \t\t\t    << INTVAL (operands[2])));\n-}\")\n+})\n \n ;; For the unaligned byte and halfword cases, we use code similar to that\n ;; in the ;; Architecture book, but reordered to lower the number of registers\n@@ -5134,7 +4997,6 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (TARGET_BWX)\n     {\n@@ -5246,13 +5108,12 @@\n       DONE;\n     }\n  def:;\n-}\")\n+})\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:HI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (TARGET_BWX)\n     {\n@@ -5365,7 +5226,7 @@\n       DONE;\n     }\n  def:;\n-}\")\n+})\n \n ;; Here are the versions for reload.  Note that in the unaligned cases\n ;; we know that the operand must not be a pseudo-register because stack\n@@ -5376,7 +5237,6 @@\n \t      (match_operand:QI 1 \"any_memory_operand\" \"m\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n-  \"\n {\n   rtx scratch, seq;\n \n@@ -5407,14 +5267,13 @@\n     }\n   emit_insn (seq);\n   DONE;\n-}\")\n+})\n \n (define_expand \"reload_inhi\"\n   [(parallel [(match_operand:HI 0 \"register_operand\" \"=r\")\n \t      (match_operand:HI 1 \"any_memory_operand\" \"m\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n-  \"\n {\n   rtx scratch, seq;\n \n@@ -5445,14 +5304,13 @@\n     }\n   emit_insn (seq);\n   DONE;\n-}\")\n+})\n \n (define_expand \"reload_outqi\"\n   [(parallel [(match_operand:QI 0 \"any_memory_operand\" \"=m\")\n \t      (match_operand:QI 1 \"register_operand\" \"r\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n-  \"\n {\n   if (GET_CODE (operands[0]) != MEM)\n     abort ();\n@@ -5481,14 +5339,13 @@\n       emit_insn (seq);\n     }\n   DONE;\n-}\")\n+})\n \n (define_expand \"reload_outhi\"\n   [(parallel [(match_operand:HI 0 \"any_memory_operand\" \"=m\")\n \t      (match_operand:HI 1 \"register_operand\" \"r\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n-  \"\n {\n   if (GET_CODE (operands[0]) != MEM)\n     abort ();\n@@ -5517,7 +5374,7 @@\n       emit_insn (seq);\n     }\n   DONE;\n-}\")\n+})\n \n ;; Helpers for the above.  The way reload is structured, we can't\n ;; always get a proper address for a stack slot during reload_foo\n@@ -5559,29 +5416,27 @@\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n   \"! TARGET_BWX && reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx aligned_mem, bitnum;\n   get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n   emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n \t\t\t\t operands[2]));\n   DONE;\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n         (match_operand:HI 1 \"memory_operand\" \"\"))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n   \"! TARGET_BWX && reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx aligned_mem, bitnum;\n   get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n   emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n \t\t\t\t operands[2]));\n   DONE;\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:QI 0 \"memory_operand\" \"\")\n@@ -5590,14 +5445,13 @@\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"! TARGET_BWX && reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx aligned_mem, bitnum;\n   get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n   emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n \t\t\t\toperands[2], operands[3]));\n   DONE;\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:HI 0 \"memory_operand\" \"\")\n@@ -5606,14 +5460,13 @@\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"! TARGET_BWX && reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx aligned_mem, bitnum;\n   get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n   emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n \t\t\t\toperands[2], operands[3]));\n   DONE;\n-}\")\n+})\n \f\n ;; Bit field extract patterns which use ext[wlq][lh]\n \n@@ -5623,7 +5476,6 @@\n \t\t\t (match_operand:DI 2 \"immediate_operand\" \"\")\n \t\t\t (match_operand:DI 3 \"immediate_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   /* We can do 16, 32 and 64 bit fields, if aligned on byte boundaries.  */\n   if (INTVAL (operands[3]) % 8 != 0\n@@ -5641,15 +5493,14 @@\n \t\t\t       INTVAL (operands[2]) / 8,\n \t\t\t       INTVAL (operands[3]) / 8, 1);\n   DONE;\n-}\")\n+})\n \n (define_expand \"extzv\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extract:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n \t\t\t (match_operand:DI 2 \"immediate_operand\" \"\")\n \t\t\t (match_operand:DI 3 \"immediate_operand\" \"\")))]\n   \"\"\n-  \"\n {\n   /* We can do 8, 16, 32 and 64 bit fields, if aligned on byte boundaries.  */\n   if (INTVAL (operands[3]) % 8 != 0\n@@ -5670,15 +5521,14 @@\n \t\t\t           INTVAL (operands[3]) / 8, 0);\n       DONE;\n     }\n-}\")\n+})\n \n (define_expand \"insv\"\n   [(set (zero_extract:DI (match_operand:QI 0 \"memory_operand\" \"\")\n \t\t\t (match_operand:DI 1 \"immediate_operand\" \"\")\n \t\t\t (match_operand:DI 2 \"immediate_operand\" \"\"))\n \t(match_operand:DI 3 \"register_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   /* We can do 16, 32 and 64 bit fields, if aligned on byte boundaries.  */\n   if (INTVAL (operands[2]) % 8 != 0\n@@ -5696,7 +5546,7 @@\n \t\t\t        INTVAL (operands[1]) / 8,\n \t\t\t        INTVAL (operands[2]) / 8);\n   DONE;\n-}\")\n+})\n \n ;; Block move/clear, see alpha.c for more details.\n ;; Argument 0 is the destination\n@@ -5710,40 +5560,37 @@\n \t      (use (match_operand:DI 2 \"immediate_operand\" \"\"))\n \t      (use (match_operand:DI 3 \"immediate_operand\" \"\"))])]\n   \"\"\n-  \"\n {\n   if (alpha_expand_block_move (operands))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_expand \"clrstrqi\"\n   [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n \t\t   (const_int 0))\n \t      (use (match_operand:DI 1 \"immediate_operand\" \"\"))\n \t      (use (match_operand:DI 2 \"immediate_operand\" \"\"))])]\n   \"\"\n-  \"\n {\n   if (alpha_expand_block_clear (operands))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \f\n ;; Subroutine of stack space allocation.  Perform a stack probe.\n (define_expand \"probe_stack\"\n   [(set (match_dup 1) (match_operand:DI 0 \"const_int_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   operands[1] = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx,\n \t\t\t\t\t\t    INTVAL (operands[0])));\n   MEM_VOLATILE_P (operands[1]) = 1;\n \n   operands[0] = const0_rtx;\n-}\")\n+})\n \n ;; This is how we allocate stack space.  If we are allocating a\n ;; constant amount of space and we know it is less than 4096\n@@ -5758,7 +5605,6 @@\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(match_dup 2))]\n   \"\"\n-  \"\n {\n   if (GET_CODE (operands[1]) == CONST_INT\n       && INTVAL (operands[1]) < 32768)\n@@ -5819,7 +5665,7 @@\n       emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n       DONE;\n     }\n-}\")\n+})\n \n ;; This is used by alpha_expand_prolog to do the same thing as above,\n ;; except we cannot at that time generate new basic blocks, so we hide\n@@ -5830,25 +5676,23 @@\n \t\t     (match_operand:DI 1 \"register_operand\" \"r\")]\n \t\t    UNSPECV_PSPL)]\n   \"\"\n-  \"*\n {\n   operands[2] = gen_label_rtx ();\n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n \t\t\t     CODE_LABEL_NUMBER (operands[2]));\n \n-  return \\\"stq $31,-8192(%1)\\;subq %0,1,%0\\;lda %1,-8192(%1)\\;bne %0,%l2\\\";\n-}\"\n+  return \"stq $31,-8192(%1)\\;subq %0,1,%0\\;lda %1,-8192(%1)\\;bne %0,%l2\";\n+}\n   [(set_attr \"length\" \"16\")\n    (set_attr \"type\" \"multi\")])\n \n (define_expand \"prologue\"\n   [(clobber (const_int 0))]\n   \"\"\n-  \"\n {\n   alpha_expand_prologue ();\n   DONE;\n-}\")\n+})\n \n ;; These take care of emitting the ldgp insn in the prologue. This will be\n ;; an lda/ldah pair and we want to align them properly.  So we have two\n@@ -5866,7 +5710,7 @@\n (define_insn \"*prologue_ldgp_1\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_LDGP1)]\n   \"\"\n-  \"ldgp $29,0($27)\\\\n$%~..ng:\")\n+  \"ldgp $29,0($27)\\n$%~..ng:\")\n \n (define_insn \"*prologue_ldgp_2\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_LDGP2)]\n@@ -5894,19 +5738,17 @@\n (define_expand \"epilogue\"\n   [(return)]\n   \"\"\n-  \"\n {\n   alpha_expand_epilogue ();\n-}\")\n+})\n \n (define_expand \"sibcall_epilogue\"\n   [(return)]\n   \"TARGET_ABI_OSF\"\n-  \"\n {\n   alpha_expand_epilogue ();\n   DONE;\n-}\")\n+})\n \n ;; In creating a large stack frame, NT _must_ use ldah+lda to load\n ;; the frame size into a register.  We use this pattern to ensure\n@@ -5922,7 +5764,6 @@\n (define_expand \"builtin_longjmp\"\n   [(use (match_operand:DI 0 \"register_operand\" \"r\"))]\n   \"TARGET_ABI_OSF\"\n-  \"\n {\n   /* The elements of the buffer are, in order:  */\n   rtx fp = gen_rtx_MEM (Pmode, operands[0]);\n@@ -5943,7 +5784,7 @@\n   emit_jump_insn (gen_builtin_longjmp_internal (pv));\n   emit_barrier ();\n   DONE;\n-}\")\n+})\n \n ;; This is effectively a copy of indirect_jump, but constrained such\n ;; that register renaming cannot foil our cunning plan with $27.\n@@ -5958,27 +5799,26 @@\n (define_insn \"*builtin_setjmp_receiver_sub_label\"\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n   \"TARGET_ABI_OSF && TARGET_AS_CAN_SUBTRACT_LABELS\"\n-  \"\\\\n$LSJ%=:\\;ldgp $29,$LSJ%=-%l0($27)\"\n+  \"\\n$LSJ%=:\\;ldgp $29,$LSJ%=-%l0($27)\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"multi\")])\n \n (define_insn \"builtin_setjmp_receiver\"\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n   \"TARGET_ABI_OSF\"\n-  \"br $29,$LSJ%=\\\\n$LSJ%=:\\;ldgp $29,0($29)\"\n+  \"br $29,$LSJ%=\\n$LSJ%=:\\;ldgp $29,0($29)\"\n   [(set_attr \"length\" \"12\")\n    (set_attr \"type\" \"multi\")])\n \n (define_expand \"exception_receiver\"\n   [(unspec_volatile [(match_dup 0)] UNSPECV_EHR)]\n   \"TARGET_ABI_OSF\"\n-  \"\n {\n   if (TARGET_LD_BUGGY_LDGP)\n     operands[0] = alpha_gp_save_rtx ();\n   else\n     operands[0] = const0_rtx;\n-}\")\n+})\n \n (define_insn \"*exception_receiver_1\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_EHR)]"}]}