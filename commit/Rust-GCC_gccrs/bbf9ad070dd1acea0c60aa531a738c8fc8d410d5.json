{"sha": "bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJmOWFkMDcwZGQxYWNlYTBjNjBhYTUzMWE3MzhjOGZjOGQ0MTBkNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-06-12T09:12:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-06-12T09:12:47Z"}, "message": "lto-symtab.c (lto_symtab_merge_symbols): Populate symtab hashtable.\n\n\t* lto-symtab.c (lto_symtab_merge_symbols): Populate symtab hashtable.\n\t* cgraph.h (varpool_create_empty_node): Declare.\n\t* lto-cgraph.c (input_node, input_varpool_node): Forcingly create\n\tduplicated nodes.\n\t* symtab.c (symtab_unregister_node): Be lax about missin entries\n\tin node hash.\n\t(symtab_get_node): Update comment.\n\t* varpool.c (varpool_create_empty_node): Break out from ...\n\t(varpool_node_for_decl): ... here.\n\t* lto-streamer.h (lto_file_decl_data): Add RESOLUTION_MAP.\n\n\t* lto.c (register_resolution): Take lto_file_data argument.\n\t(lto_register_var_decl_in_symtab,\n\tlto_register_function_decl_in_symtab): Update.\n\t(read_cgraph_and_symbols): Update resolution_map handling.\n\nFrom-SVN: r199990", "tree": {"sha": "f90b96685d9ff8fb7b5722fdf8b1ff094b9c8b96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f90b96685d9ff8fb7b5722fdf8b1ff094b9c8b96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/comments", "author": null, "committer": null, "parents": [{"sha": "a53f90adbffa2ec9fae2b28c7dd33d1b923b5431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a53f90adbffa2ec9fae2b28c7dd33d1b923b5431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a53f90adbffa2ec9fae2b28c7dd33d1b923b5431"}], "stats": {"total": 127, "additions": 95, "deletions": 32}, "files": [{"sha": "16b4ca23c3df810de53b45e0fba28f69dc7f6b28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "patch": "@@ -1,3 +1,16 @@\n+2013-06-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_symtab_merge_symbols): Populate symtab hashtable.\n+\t* cgraph.h (varpool_create_empty_node): Declare.\n+\t* lto-cgraph.c (input_node, input_varpool_node): Forcingly create\n+\tduplicated nodes.\n+\t* symtab.c (symtab_unregister_node): Be lax about missin entries\n+\tin node hash.\n+\t(symtab_get_node): Update comment.\n+\t* varpool.c (varpool_create_empty_node): Break out from ...\n+\t(varpool_node_for_decl): ... here.\n+\t* lto-streamer.h (lto_file_decl_data): Add RESOLUTION_MAP.\n+\n 2013-06-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* expr.c (expand_expr_real_1) <TARGET_MEM_REF>: Use straight-line flow."}, {"sha": "96614272fd391f63a7fde555a112f0577a48652b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "patch": "@@ -773,6 +773,7 @@ bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n bool cgraph_optimize_for_size_p (struct cgraph_node *);\n \n /* In varpool.c  */\n+struct varpool_node *varpool_create_empty_node (void);\n struct varpool_node *varpool_node_for_decl (tree);\n struct varpool_node *varpool_node_for_asm (tree asmname);\n void varpool_mark_needed_node (struct varpool_node *);"}, {"sha": "e3f8880be7668a5f90369b21ead29e88ba94ada6", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "patch": "@@ -959,7 +959,14 @@ input_node (struct lto_file_decl_data *file_data,\n \t\t\t\tvNULL, false);\n     }\n   else\n-    node = cgraph_get_create_node (fn_decl);\n+    {\n+      /* Declaration of functions can be already merged with a declaration\n+\t from other input file.  We keep cgraph unmerged until after streaming\n+\t of ipa passes is done.  Alays forcingly create a fresh node.  */\n+      node = cgraph_create_empty_node ();\n+      node->symbol.decl = fn_decl;\n+      symtab_register_node ((symtab_node)node);\n+    }\n \n   node->symbol.order = order;\n   if (order >= symtab_order)\n@@ -1035,7 +1042,14 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   order = streamer_read_hwi (ib) + order_base;\n   decl_index = streamer_read_uhwi (ib);\n   var_decl = lto_file_decl_data_get_var_decl (file_data, decl_index);\n-  node = varpool_node_for_decl (var_decl);\n+\n+  /* Declaration of functions can be already merged with a declaration\n+     from other input file.  We keep cgraph unmerged until after streaming\n+     of ipa passes is done.  Alays forcingly create a fresh node.  */\n+  node = varpool_create_empty_node ();\n+  node->symbol.decl = var_decl;\n+  symtab_register_node ((symtab_node)node);\n+\n   node->symbol.order = order;\n   if (order >= symtab_order)\n     symtab_order = order + 1;"}, {"sha": "88985ddca233978db9884743c15c803ebe321ce5", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "patch": "@@ -569,6 +569,9 @@ struct GTY(()) lto_file_decl_data\n   unsigned max_index;\n \n   struct gcov_ctr_summary GTY((skip)) profile_info;\n+\n+  /* Map assigning declarations their resolutions.  */\n+  pointer_map_t * GTY((skip)) resolution_map;\n };\n \n typedef struct lto_file_decl_data *lto_file_decl_data_ptr;"}, {"sha": "a92e14c0dceae6fd6a8f7f93d7916e3e773c5a62", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "patch": "@@ -573,16 +573,21 @@ lto_symtab_merge_symbols (void)\n     {\n       symtab_initialize_asm_name_hash ();\n \n-      /* Do the actual merging.  */\n+      /* Do the actual merging.  \n+         At this point we invalidate hash translating decls into symtab nodes\n+\t because after removing one of duplicate decls the hash is not correcly\n+\t updated to the ohter dupliate.  */\n       FOR_EACH_SYMBOL (node)\n \tif (lto_symtab_symbol_p (node)\n \t    && node->symbol.next_sharing_asm_name\n \t    && !node->symbol.previous_sharing_asm_name)\n \t  lto_symtab_merge_symbols_1 (node);\n \n-      /* Resolve weakref aliases whose target are now in the compilation unit.  */\n+      /* Resolve weakref aliases whose target are now in the compilation unit.  \n+\t also re-populate the hash translating decls into symtab nodes*/\n       FOR_EACH_SYMBOL (node)\n \t{\n+\t  cgraph_node *cnode;\n \t  if (!node->symbol.analyzed && node->symbol.alias_target)\n \t    {\n \t      symtab_node tgt = symtab_node_for_asm (node->symbol.alias_target);\n@@ -591,6 +596,10 @@ lto_symtab_merge_symbols (void)\n \t\tsymtab_resolve_alias (node, tgt);\n \t    }\n \t  node->symbol.aux = NULL;\n+\t  if (!(cnode = dyn_cast <cgraph_node> (node))\n+\t      || !cnode->clone_of\n+\t      || cnode->clone_of->symbol.decl != cnode->symbol.decl)\n+\t    symtab_insert_node_to_hashtable ((symtab_node)node);\n \t}\n     }\n }"}, {"sha": "216882afd13a75808e0020166763d690161c7116", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "patch": "@@ -1,3 +1,10 @@\n+2013-06-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (register_resolution): Take lto_file_data argument.\n+\t(lto_register_var_decl_in_symtab,\n+\tlto_register_function_decl_in_symtab): Update.\n+\t(read_cgraph_and_symbols): Update resolution_map handling.\n+\n 2013-06-11 Jan Hubicka  <jh@suse.cz>\n \n \t* lto-partition.c (get_symbol_class): Simplify weakref handling."}, {"sha": "a4c5d29e974e634912df73bd3c9d34987dccf4a0", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "patch": "@@ -1726,18 +1726,16 @@ get_resolution (struct data_in *data_in, unsigned index)\n     return LDPR_UNKNOWN;\n }\n \n-/* Map assigning declarations their resolutions.  */\n-static pointer_map_t *resolution_map;\n-\n /* We need to record resolutions until symbol table is read.  */\n static void\n-register_resolution (tree decl, enum ld_plugin_symbol_resolution resolution)\n+register_resolution (struct lto_file_decl_data *file_data, tree decl,\n+\t\t     enum ld_plugin_symbol_resolution resolution)\n {\n   if (resolution == LDPR_UNKNOWN)\n     return;\n-  if (!resolution_map)\n-    resolution_map = pointer_map_create ();\n-  *pointer_map_insert (resolution_map, decl) = (void *)(size_t)resolution;\n+  if (!file_data->resolution_map)\n+    file_data->resolution_map = pointer_map_create ();\n+  *pointer_map_insert (file_data->resolution_map, decl) = (void *)(size_t)resolution;\n }\n \n /* Register DECL with the global symbol table and change its\n@@ -1764,7 +1762,7 @@ lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl)\n       unsigned ix;\n       if (!streamer_tree_cache_lookup (data_in->reader_cache, decl, &ix))\n \tgcc_unreachable ();\n-      register_resolution (decl, get_resolution (data_in, ix));\n+      register_resolution (data_in->file_data, decl, get_resolution (data_in, ix));\n     }\n }\n \n@@ -1784,7 +1782,7 @@ lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl)\n       unsigned ix;\n       if (!streamer_tree_cache_lookup (data_in->reader_cache, decl, &ix))\n \tgcc_unreachable ();\n-      register_resolution (decl, get_resolution (data_in, ix));\n+      register_resolution (data_in->file_data, decl, get_resolution (data_in, ix));\n     }\n }\n \n@@ -2865,6 +2863,8 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   struct cgraph_node *node;\n   int count = 0;\n   struct lto_file_decl_data **decl_data;\n+  void **res;\n+  symtab_node snode;\n \n   init_cgraph ();\n \n@@ -2971,21 +2971,21 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   input_symtab ();\n \n   /* Store resolutions into the symbol table.  */\n-  if (resolution_map)\n-    {\n-      void **res;\n-      symtab_node snode;\n \n-      FOR_EACH_SYMBOL (snode)\n-\tif (symtab_real_symbol_p (snode)\n-\t    && (res = pointer_map_contains (resolution_map,\n-\t\t\t\t            snode->symbol.decl)))\n-\t  snode->symbol.resolution\n-\t    = (enum ld_plugin_symbol_resolution)(size_t)*res;\n-\n-      pointer_map_destroy (resolution_map);\n-      resolution_map = NULL;\n-    }\n+  FOR_EACH_SYMBOL (snode)\n+    if (symtab_real_symbol_p (snode)\n+\t&& snode->symbol.lto_file_data\n+\t&& snode->symbol.lto_file_data->resolution_map\n+\t&& (res = pointer_map_contains (snode->symbol.lto_file_data->resolution_map,\n+\t\t\t\t\tsnode->symbol.decl)))\n+      snode->symbol.resolution\n+\t= (enum ld_plugin_symbol_resolution)(size_t)*res;\n+  for (i = 0; all_file_decl_data[i]; i++)\n+    if (all_file_decl_data[i]->resolution_map)\n+      {\n+        pointer_map_destroy (all_file_decl_data[i]->resolution_map);\n+        all_file_decl_data[i]->resolution_map = NULL;\n+      }\n   \n   timevar_pop (TV_IPA_LTO_CGRAPH_IO);\n "}, {"sha": "0ce44a9180db7bfe4274af5009b22d07612380db", "filename": "gcc/symtab.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "patch": "@@ -269,7 +269,11 @@ symtab_unregister_node (symtab_node node)\n   node->symbol.previous = NULL;\n \n   slot = htab_find_slot (symtab_hash, node, NO_INSERT);\n-  if (*slot == node)\n+\n+  /* During LTO symtab merging we temporarily corrupt decl to symtab node\n+     hash.  */\n+  gcc_assert ((slot && *slot) || in_lto_p);\n+  if (slot && *slot && *slot == node)\n     {\n       symtab_node replacement_node = NULL;\n       if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n@@ -291,10 +295,14 @@ symtab_get_node (const_tree decl)\n   symtab_node *slot;\n   struct symtab_node_base key;\n \n+#ifdef ENABLE_CHECKING\n+  /* Check that we are called for sane type of object - functions\n+     and static or external variables.  */\n   gcc_checking_assert (TREE_CODE (decl) == FUNCTION_DECL\n \t\t       || (TREE_CODE (decl) == VAR_DECL\n \t\t\t   && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)\n \t\t\t       || in_lto_p)));\n+#endif\n \n   if (!symtab_hash)\n     return NULL;"}, {"sha": "fd193d3c74a8887c14129f5152677256b46fde7a", "filename": "gcc/varpool.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf9ad070dd1acea0c60aa531a738c8fc8d410d5/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=bbf9ad070dd1acea0c60aa531a738c8fc8d410d5", "patch": "@@ -36,18 +36,26 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"flags.h\"\n \n+/* Allocate new callgraph node and insert it into basic data structures.  */\n+\n+struct varpool_node *\n+varpool_create_empty_node (void)\n+{   \n+  struct varpool_node *node = ggc_alloc_cleared_varpool_node ();\n+  node->symbol.type = SYMTAB_VARIABLE;\n+  return node;\n+}   \n+\n /* Return varpool node assigned to DECL.  Create new one when needed.  */\n struct varpool_node *\n varpool_node_for_decl (tree decl)\n {\n   struct varpool_node *node = varpool_get_node (decl);\n-  gcc_assert (TREE_CODE (decl) == VAR_DECL\n-\t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl) || in_lto_p));\n+  gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n   if (node)\n     return node;\n \n-  node = ggc_alloc_cleared_varpool_node ();\n-  node->symbol.type = SYMTAB_VARIABLE;\n+  node = varpool_create_empty_node ();\n   node->symbol.decl = decl;\n   symtab_register_node ((symtab_node)node);\n   return node;"}]}