{"sha": "7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZhMDcyZGVhNTg3ZmY3MGJlZTVlMDU5ZjNjZDMxYTdiMmNlOWEzYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-10-12T18:44:48Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-10-12T18:44:48Z"}, "message": "[C++ PATCH] more TU parsing refactoring\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-10/msg00788.html\n\t* parser.h (struct cp_parser): Drop implicit_extern_c.\n\t* parser.c (cp_debug_parser): Drop implicit_extern_c.\n\t(cp_parser_new): Likewise.\n\t(cp_parser_translation_unit): Handle implicit extern c here.  Call\n\tcp_parser_toplevel_declaration.\n\t(cp_parser_toplevel_declaration): New, broken out of ...\n\t(cp_parser_declaration_seq_opt): ... here.  Call it.  Drop\n\timplicit extern C handling.\n\nFrom-SVN: r265127", "tree": {"sha": "1082f25d05a37c2f027f3ccf3aaf511f018948ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1082f25d05a37c2f027f3ccf3aaf511f018948ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47b92d22d3aea04ce6a936c768953dd0406f41c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b92d22d3aea04ce6a936c768953dd0406f41c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47b92d22d3aea04ce6a936c768953dd0406f41c2"}], "stats": {"total": 141, "additions": 74, "deletions": 67}, "files": [{"sha": "701ec64cc0743167b8ed74faeed0be64952ec16b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c", "patch": "@@ -1,3 +1,14 @@\n+2018-10-12  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* parser.h (struct cp_parser): Drop implicit_extern_c.\n+\t* parser.c (cp_debug_parser): Drop implicit_extern_c.\n+\t(cp_parser_new): Likewise.\n+\t(cp_parser_translation_unit): Handle implicit extern c here.  Call\n+\tcp_parser_toplevel_declaration.\n+\t(cp_parser_toplevel_declaration): New, broken out of ...\n+\t(cp_parser_declaration_seq_opt): ... here.  Call it.  Drop\n+\timplicit extern C handling.\n+\n 2018-10-11  Will Wray  <wjwray@gmail.com>\n \n \tPR c++/87364"}, {"sha": "c46b77608b21fe332565a6ecd5e90b2318948abe", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c", "patch": "@@ -556,8 +556,6 @@ cp_debug_parser (FILE *file, cp_parser *parser)\n \t\t\t      parser->in_statement & IN_IF_STMT);\n   cp_debug_print_flag (file, \"Parsing a type-id in an expression \"\n \t\t\t      \"context\", parser->in_type_id_in_expr_p);\n-  cp_debug_print_flag (file, \"Declarations are implicitly extern \\\"C\\\"\",\n-\t\t\t      parser->implicit_extern_c);\n   cp_debug_print_flag (file, \"String expressions should be translated \"\n \t\t\t      \"to execution character set\",\n \t\t\t      parser->translate_strings_p);\n@@ -2135,6 +2133,8 @@ static void cp_parser_declaration_seq_opt\n   (cp_parser *);\n static void cp_parser_declaration\n   (cp_parser *);\n+static void cp_parser_toplevel_declaration\n+  (cp_parser *);\n static void cp_parser_block_declaration\n   (cp_parser *, bool);\n static void cp_parser_simple_declaration\n@@ -3923,9 +3923,6 @@ cp_parser_new (void)\n   /* We are not parsing a type-id inside an expression.  */\n   parser->in_type_id_in_expr_p = false;\n \n-  /* Declarations aren't implicitly extern \"C\".  */\n-  parser->implicit_extern_c = false;\n-\n   /* String literals should be translated to the execution character set.  */\n   parser->translate_strings_p = true;\n \n@@ -4601,31 +4598,45 @@ cp_parser_translation_unit (cp_parser* parser)\n   /* Remember where the base of the declarator obstack lies.  */\n   void *declarator_obstack_base = obstack_next_free (&declarator_obstack);\n \n+  bool implicit_extern_c = false;\n+\n   for (;;)\n     {\n-      cp_parser_declaration_seq_opt (parser);\n-      gcc_assert (!cp_parser_parsing_tentatively (parser));\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      \n+      /* If we're entering or exiting a region that's implicitly\n+\t extern \"C\", modify the lang context appropriately.  */\n+      if (implicit_extern_c\n+\t  != cp_lexer_peek_token (parser->lexer)->implicit_extern_c)\n+\t{\n+\t  implicit_extern_c = !implicit_extern_c;\n+\t  if (implicit_extern_c)\n+\t    push_lang_context (lang_name_c);\n+\t  else\n+\t    pop_lang_context ();\n+\t}\n+\n+      if (token->type == CPP_EOF)\n \tbreak;\n-      /* Must have been an extra close-brace.  */\n-      cp_parser_error (parser, \"expected declaration\");\n-      cp_lexer_consume_token (parser->lexer);\n-      /* If the next token is now a `;', consume it.  */\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-\tcp_lexer_consume_token (parser->lexer);\n+\n+      if (token->type == CPP_CLOSE_BRACE)\n+\t{\n+\t  cp_parser_error (parser, \"expected declaration\");\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  /* If the next token is now a `;', consume it.  */\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t}\n+      else\n+\tcp_parser_toplevel_declaration (parser);\n     }\n \n   /* Get rid of the token array; we don't need it any more.  */\n   cp_lexer_destroy (parser->lexer);\n   parser->lexer = NULL;\n-  \n-  /* This file might have been a context that's implicitly extern\n-     \"C\".  If so, pop the lang context.  (Only relevant for PCH.) */\n-  if (parser->implicit_extern_c)\n-    {\n-      pop_lang_context ();\n-      parser->implicit_extern_c = false;\n-    }\n+\n+  /* The EOF should have reset this. */\n+  gcc_checking_assert (!implicit_extern_c);\n \n   /* Make sure the declarator obstack was fully cleaned up.  */\n   gcc_assert (obstack_next_free (&declarator_obstack)\n@@ -12732,50 +12743,13 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n {\n   while (true)\n     {\n-      cp_token *token;\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n       if (token->type == CPP_CLOSE_BRACE\n-\t  || token->type == CPP_EOF\n-\t  || token->type == CPP_PRAGMA_EOL)\n+\t  || token->type == CPP_EOF)\n \tbreak;\n-\n-      if (token->type == CPP_SEMICOLON)\n-\t{\n-\t  /* A declaration consisting of a single semicolon is\n-\t     invalid.  Allow it unless we're being pedantic.  */\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  if (!in_system_header_at (input_location))\n-\t    pedwarn (input_location, OPT_Wpedantic, \"extra %<;%>\");\n-\t  continue;\n-\t}\n-\n-      /* If we're entering or exiting a region that's implicitly\n-\t extern \"C\", modify the lang context appropriately.  */\n-      if (!parser->implicit_extern_c && token->implicit_extern_c)\n-\t{\n-\t  push_lang_context (lang_name_c);\n-\t  parser->implicit_extern_c = true;\n-\t}\n-      else if (parser->implicit_extern_c && !token->implicit_extern_c)\n-\t{\n-\t  pop_lang_context ();\n-\t  parser->implicit_extern_c = false;\n-\t}\n-\n-      if (token->type == CPP_PRAGMA)\n-\t{\n-\t  /* A top-level declaration can consist solely of a #pragma.\n-\t     A nested declaration cannot, so this is done here and not\n-\t     in cp_parser_declaration.  (A #pragma at block scope is\n-\t     handled in cp_parser_statement.)  */\n-\t  cp_parser_pragma (parser, pragma_external, NULL);\n-\t  continue;\n-\t}\n-\n-      /* Parse the declaration itself.  */\n-      cp_parser_declaration (parser);\n+      else\n+\tcp_parser_toplevel_declaration (parser);\n     }\n }\n \n@@ -12905,6 +12879,32 @@ cp_parser_declaration (cp_parser* parser)\n   obstack_free (&declarator_obstack, p);\n }\n \n+/* Parse a namespace-scope declaration.  */\n+\n+static void\n+cp_parser_toplevel_declaration (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  if (token->type == CPP_PRAGMA)\n+    /* A top-level declaration can consist solely of a #pragma.  A\n+       nested declaration cannot, so this is done here and not in\n+       cp_parser_declaration.  (A #pragma at block scope is\n+       handled in cp_parser_statement.)  */\n+    cp_parser_pragma (parser, pragma_external, NULL);\n+  else if (token->type == CPP_SEMICOLON)\n+    {\n+      /* A declaration consisting of a single semicolon is\n+\t invalid.  Allow it unless we're being pedantic.  */\n+      cp_lexer_consume_token (parser->lexer);\n+      if (!in_system_header_at (input_location))\n+\tpedwarn (input_location, OPT_Wpedantic, \"extra %<;%>\");\n+    }\n+  else\n+    /* Parse the declaration itself.  */\n+    cp_parser_declaration (parser);\n+}\n+\n /* Parse a block-declaration.\n \n    block-declaration:"}, {"sha": "8bfa3f3b9c4f2c22167ecd0ec9616e183a2ccae8", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=7fa072dea587ff70bee5e059f3cd31a7b2ce9a3c", "patch": "@@ -321,10 +321,6 @@ struct GTY(()) cp_parser {\n      alternatives.  */\n   bool in_type_id_in_expr_p;\n \n-  /* TRUE if we are currently in a header file where declarations are\n-     implicitly extern \"C\".  */\n-  bool implicit_extern_c;\n-\n   /* TRUE if strings in expressions should be translated to the execution\n      character set.  */\n   bool translate_strings_p;"}]}