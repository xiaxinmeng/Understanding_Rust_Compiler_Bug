{"sha": "224eeff2ea7cee133a2614f9562d6fa8bfeb0a85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI0ZWVmZjJlYTdjZWUxMzNhMjYxNGY5NTYyZDZmYThiZmViMGE4NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-26T15:06:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-26T15:06:55Z"}, "message": "(subst): apply_distributive_law can also handle AND.\n\n(subst, case IF_THEN_ELSE): Make a shift when appropriate.\n(simplify_shift_const): If we have an outer operation and made a shift, see if\nit can be simplified.\n\nFrom-SVN: r4748", "tree": {"sha": "1faa27638e57d35e54968f9fa4cb71c85b8058c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1faa27638e57d35e54968f9fa4cb71c85b8058c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/224eeff2ea7cee133a2614f9562d6fa8bfeb0a85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224eeff2ea7cee133a2614f9562d6fa8bfeb0a85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/224eeff2ea7cee133a2614f9562d6fa8bfeb0a85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224eeff2ea7cee133a2614f9562d6fa8bfeb0a85/comments", "author": null, "committer": null, "parents": [{"sha": "af508edd0a24fde29a7f879577b2ad2498d5123d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af508edd0a24fde29a7f879577b2ad2498d5123d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af508edd0a24fde29a7f879577b2ad2498d5123d"}], "stats": {"total": 34, "additions": 33, "deletions": 1}, "files": [{"sha": "d986f7d9e55ad9c470e50e8637a32a7c7b13bf2a", "filename": "gcc/combine.c", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/224eeff2ea7cee133a2614f9562d6fa8bfeb0a85/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/224eeff2ea7cee133a2614f9562d6fa8bfeb0a85/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=224eeff2ea7cee133a2614f9562d6fa8bfeb0a85", "patch": "@@ -2931,7 +2931,8 @@ subst (x, from, to, in_dest, unique_copy)\n     x = temp, code = GET_CODE (temp);\n \n   /* First see if we can apply the inverse distributive law.  */\n-  if (code == PLUS || code == MINUS || code == IOR || code == XOR)\n+  if (code == PLUS || code == MINUS\n+      || code == AND || code == IOR || code == XOR)\n     {\n       x = apply_distributive_law (x);\n       code = GET_CODE (x);\n@@ -3814,6 +3815,27 @@ subst (x, from, to, in_dest, unique_copy)\n \t      return temp;\n \t    }\n \t}\n+\n+      /* If we have (if_then_else (ne A 0) C1 0) and either A is known to \n+\t be 0 or 1 and C1 is a single bit or A is known to be 0 or -1 and\n+\t C1 is the negation of a single bit, we can convert this operation\n+\t to a shift.  We can actually do this in more general cases, but it\n+\t doesn't seem worth it.  */\n+\n+      if (GET_CODE (XEXP (x, 0)) == NE && XEXP (XEXP (x, 0), 1) == const0_rtx\n+\t  && XEXP (x, 2) == const0_rtx && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && ((1 == nonzero_bits (XEXP (XEXP (x, 0), 0),\n+\t\t\t\t  GET_MODE (XEXP (XEXP (x, 0), 0)))\n+\t       && (i = exact_log2 (INTVAL (XEXP (x, 1)))) >= 0)\n+\t      || ((num_sign_bit_copies (XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\tGET_MODE (XEXP (XEXP (x, 0), 0)))\n+\t\t   == GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (x, 0), 0))))\n+\t\t  && (i = exact_log2 (- INTVAL (XEXP (x, 1)))) >= 0)))\n+\treturn\n+\t  simplify_shift_const (NULL_RTX, ASHIFT, mode,\n+\t\t\t\tgen_lowpart_for_combine (mode,\n+\t\t\t\t\t\t\t XEXP (XEXP (x, 0), 0)),\n+\t\t\t\ti);\n       break;\n \t  \n     case ZERO_EXTRACT:\n@@ -7615,6 +7637,16 @@ simplify_shift_const (x, code, result_mode, varop, count)\n       SUBST (XEXP (x, 1), const_rtx);\n     }\n \n+  /* If we have an outer operation and we just made a shift, it is\n+     possible that we could have simplified the shift were it not\n+     for the outer operation.  So try to do the simplification\n+     recursively.  */\n+\n+  if (outer_op != NIL && GET_CODE (x) == code\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    x = simplify_shift_const (x, code, shift_mode, XEXP (x, 0),\n+\t\t\t      INTVAL (XEXP (x, 1)));\n+\n   /* If we were doing a LSHIFTRT in a wider mode than it was originally,\n      turn off all the bits that the shift would have turned off.  */\n   if (orig_code == LSHIFTRT && result_mode != shift_mode)"}]}