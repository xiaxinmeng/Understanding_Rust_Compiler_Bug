{"sha": "eb232f4ef11305a4c2ce9ae0cc7975eafd942153", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIyMzJmNGVmMTEzMDVhNGMyY2U5YWUwY2M3OTc1ZWFmZDk0MjE1Mw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-04-10T08:45:25Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-04-10T08:45:25Z"}, "message": "cselib.c (clear_table): Rename to cselib_clear_table.\n\n\t* cselib.c (clear_table): Rename to cselib_clear_table.\n\t* cselib.h (cselib_clear_table): Add prototype.\n\t* gcse.c (gcse_main): Make 'f' argument unused.\n\t(alloc_gcse_mem): Do not walk the insn chain, walk the contents\n\tof each basic block instead.\n\t(compute_sets, compute_hash_table_work): Likewise.\n\t(constprop_register): Change int 'alter_jumps' argument to bool.\n\t(do_local_cprop): Likewise.\n\t(local_cprop_pass): Likewise.  Also walk basic blocks instead of\n\tthe insn chain.  Explicitly clear the cselib tables after finishing\n\tone basic block.  Make sure there are no unterminated libcall blocks.\n\tUpdate compute_sets call.\n\t(cprop): Walk basic blocks instead of the insn chain.\n\t(one_cprop_pass, compute_ld_motion_mems, compute_store_table):\n\tLikewise.\n\t(bypass_jumps): Update alloc_gcse_mem, compute_sets, and\n\tone_cprop_pass calls.\n\nFrom-SVN: r97945", "tree": {"sha": "6229d5f39b16f05c907b4000ab97e789cb96da6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6229d5f39b16f05c907b4000ab97e789cb96da6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb232f4ef11305a4c2ce9ae0cc7975eafd942153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb232f4ef11305a4c2ce9ae0cc7975eafd942153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb232f4ef11305a4c2ce9ae0cc7975eafd942153", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb232f4ef11305a4c2ce9ae0cc7975eafd942153/comments", "author": null, "committer": null, "parents": [{"sha": "1d1df67fa98446e02aee8912c2c5fd979b8b2e56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d1df67fa98446e02aee8912c2c5fd979b8b2e56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d1df67fa98446e02aee8912c2c5fd979b8b2e56"}], "stats": {"total": 227, "additions": 129, "deletions": 98}, "files": [{"sha": "d6ae8525c774b2f1fb2477be102bd208fa3c95de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb232f4ef11305a4c2ce9ae0cc7975eafd942153/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb232f4ef11305a4c2ce9ae0cc7975eafd942153/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb232f4ef11305a4c2ce9ae0cc7975eafd942153", "patch": "@@ -1,3 +1,23 @@\n+2005-04-10  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* cselib.c (clear_table): Rename to cselib_clear_table.\n+\t* cselib.h (cselib_clear_table): Add prototype.\n+\t* gcse.c (gcse_main): Make 'f' argument unused.\n+\t(alloc_gcse_mem): Do not walk the insn chain, walk the contents\n+\tof each basic block instead.\n+\t(compute_sets, compute_hash_table_work): Likewise.\n+\t(constprop_register): Change int 'alter_jumps' argument to bool.\n+\t(do_local_cprop): Likewise.\n+\t(local_cprop_pass): Likewise.  Also walk basic blocks instead of\n+\tthe insn chain.  Explicitly clear the cselib tables after finishing\n+\tone basic block.  Make sure there are no unterminated libcall blocks.\n+\tUpdate compute_sets call.\n+\t(cprop): Walk basic blocks instead of the insn chain.\n+\t(one_cprop_pass, compute_ld_motion_mems, compute_store_table):\n+\tLikewise.\n+\t(bypass_jumps): Update alloc_gcse_mem, compute_sets, and\n+\tone_cprop_pass calls.\n+\n 2005-04-10  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* combine.c (combine_simplify_rtx): Remove a transformation that\n@@ -1201,7 +1221,7 @@\n \t* config/mn10300/mn10300.opt: New file.\n \n 2005-04-05  Eric Botcazou  <ebotcazou@libertysurf.fr>\n-            Sebastian Pop <sebastian.pop@cri.ensmp.fr>\n+\t    Sebastian Pop <sebastian.pop@cri.ensmp.fr>\n \n \tPR tree-optimization/19903\n \t* tree-chrec.c (chrec_convert): Return chrec_dont_know for constants\n@@ -1284,7 +1304,7 @@\n \tCRIS epilogue as RTL.\n \t* config/cris/cris.md: Change all 0 in unspec 0 to\n \tCRIS_UNSPEC_PLT.\n- \t(CRIS_UNSPEC_PLT, CRIS_UNSPEC_FRAME_DEALLOC): New constants.\n+\t(CRIS_UNSPEC_PLT, CRIS_UNSPEC_FRAME_DEALLOC): New constants.\n \t(\"*cris_load_multiple\", \"cris_frame_deallocated_barrier\"): New\n \tpatterns.\n \t(\"return\"): Change to define_expand.  Call cris_expand_return for"}, {"sha": "b7a8963da7793db0e4bb98fed9aaa83c804d6ef5", "filename": "gcc/cselib.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb232f4ef11305a4c2ce9ae0cc7975eafd942153/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb232f4ef11305a4c2ce9ae0cc7975eafd942153/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=eb232f4ef11305a4c2ce9ae0cc7975eafd942153", "patch": "@@ -50,7 +50,6 @@ static struct elt_loc_list *new_elt_loc_list (struct elt_loc_list *, rtx);\n static void unchain_one_value (cselib_val *);\n static void unchain_one_elt_list (struct elt_list **);\n static void unchain_one_elt_loc_list (struct elt_loc_list **);\n-static void clear_table (void);\n static int discard_useless_locs (void **, void *);\n static int discard_useless_values (void **, void *);\n static void remove_useless_values (void);\n@@ -106,11 +105,11 @@ static unsigned int reg_values_size;\n #define REG_VALUES(i) reg_values[i]\n \n /* The largest number of hard regs used by any entry added to the\n-   REG_VALUES table.  Cleared on each clear_table() invocation.  */\n+   REG_VALUES table.  Cleared on each cselib_clear_table() invocation.  */\n static unsigned int max_value_regs;\n \n /* Here the set of indices I with REG_VALUES(I) != 0 is saved.  This is used\n-   in clear_table() for fast emptying.  */\n+   in cselib_clear_table() for fast emptying.  */\n static unsigned int *used_regs;\n static unsigned int n_used_regs;\n \n@@ -200,8 +199,8 @@ unchain_one_value (cselib_val *v)\n    initialization.  If CLEAR_ALL isn't set, then only clear the entries\n    which are known to have been used.  */\n \n-static void\n-clear_table (void)\n+void\n+cselib_clear_table (void)\n {\n   unsigned int i;\n \n@@ -1362,7 +1361,7 @@ cselib_process_insn (rtx insn)\n     {\n       if (find_reg_note (insn, REG_RETVAL, NULL))\n         cselib_current_insn_in_libcall = false;\n-      clear_table ();\n+      cselib_clear_table ();\n       return;\n     }\n \n@@ -1464,7 +1463,7 @@ cselib_finish (void)\n   free_alloc_pool (elt_loc_list_pool);\n   free_alloc_pool (cselib_val_pool);\n   free_alloc_pool (value_pool);\n-  clear_table ();\n+  cselib_clear_table ();\n   htab_delete (hash_table);\n   free (used_regs);\n   used_regs = 0;"}, {"sha": "394e73193190e51f340afe5b6b6486fb97b5f775", "filename": "gcc/cselib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb232f4ef11305a4c2ce9ae0cc7975eafd942153/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb232f4ef11305a4c2ce9ae0cc7975eafd942153/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=eb232f4ef11305a4c2ce9ae0cc7975eafd942153", "patch": "@@ -64,6 +64,7 @@ struct elt_list GTY(())\n \n extern cselib_val *cselib_lookup (rtx, enum machine_mode, int);\n extern void cselib_init (bool record_memory);\n+extern void cselib_clear_table (void);\n extern void cselib_finish (void);\n extern void cselib_process_insn (rtx);\n extern enum machine_mode cselib_reg_set_mode (rtx);"}, {"sha": "7223f0520b38eb38b84daa12b525d5fbccb5859b", "filename": "gcc/gcse.c", "status": "modified", "additions": 100, "deletions": 89, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb232f4ef11305a4c2ce9ae0cc7975eafd942153/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb232f4ef11305a4c2ce9ae0cc7975eafd942153/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=eb232f4ef11305a4c2ce9ae0cc7975eafd942153", "patch": "@@ -522,13 +522,13 @@ static void *gmalloc (size_t) ATTRIBUTE_MALLOC;\n static void *gcalloc (size_t, size_t) ATTRIBUTE_MALLOC;\n static void *grealloc (void *, size_t);\n static void *gcse_alloc (unsigned long);\n-static void alloc_gcse_mem (rtx);\n+static void alloc_gcse_mem (void);\n static void free_gcse_mem (void);\n static void alloc_reg_set_mem (int);\n static void free_reg_set_mem (void);\n static void record_one_set (int, rtx);\n static void record_set_info (rtx, rtx, void *);\n-static void compute_sets (rtx);\n+static void compute_sets (void);\n static void hash_scan_insn (rtx, struct hash_table *, int);\n static void hash_scan_set (rtx, rtx, struct hash_table *);\n static void hash_scan_clobber (rtx, rtx, struct hash_table *);\n@@ -578,8 +578,8 @@ static void canon_list_insert (rtx, rtx, void *);\n static int cprop_insn (rtx, int);\n static int cprop (int);\n static void find_implicit_sets (void);\n-static int one_cprop_pass (int, int, int);\n-static bool constprop_register (rtx, rtx, rtx, int);\n+static int one_cprop_pass (int, bool, bool);\n+static bool constprop_register (rtx, rtx, rtx, bool);\n static struct expr *find_bypass_set (int, int);\n static bool reg_killed_on_edge (rtx, edge);\n static int bypass_block (basic_block, rtx, rtx);\n@@ -645,9 +645,9 @@ static void clear_modify_mem_tables (void);\n static void free_modify_mem_tables (void);\n static rtx gcse_emit_move_after (rtx, rtx, rtx);\n static void local_cprop_find_used_regs (rtx *, void *);\n-static bool do_local_cprop (rtx, rtx, int, rtx*);\n+static bool do_local_cprop (rtx, rtx, bool, rtx*);\n static bool adjust_libcall_notes (rtx, rtx, rtx, rtx*);\n-static void local_cprop_pass (int);\n+static void local_cprop_pass (bool);\n static bool is_too_expensive (const char *);\n \f\n \n@@ -656,7 +656,7 @@ static bool is_too_expensive (const char *);\n    change is mode.  */\n \n int\n-gcse_main (rtx f, FILE *file)\n+gcse_main (rtx f ATTRIBUTE_UNUSED, FILE *file)\n {\n   int changed, pass;\n   /* Bytes used at start of pass.  */\n@@ -704,7 +704,7 @@ gcse_main (rtx f, FILE *file)\n      information about memory sets when we build the hash tables.  */\n \n   alloc_reg_set_mem (max_gcse_regno);\n-  compute_sets (f);\n+  compute_sets ();\n \n   pass = 0;\n   initial_bytes_used = bytes_used;\n@@ -724,12 +724,12 @@ gcse_main (rtx f, FILE *file)\n       /* Each pass may create new registers, so recalculate each time.  */\n       max_gcse_regno = max_reg_num ();\n \n-      alloc_gcse_mem (f);\n+      alloc_gcse_mem ();\n \n       /* Don't allow constant propagation to modify jumps\n \t during this pass.  */\n       timevar_push (TV_CPROP1);\n-      changed = one_cprop_pass (pass + 1, 0, 0);\n+      changed = one_cprop_pass (pass + 1, false, false);\n       timevar_pop (TV_CPROP1);\n \n       if (optimize_size)\n@@ -749,7 +749,7 @@ gcse_main (rtx f, FILE *file)\n \t    }\n \t  free_reg_set_mem ();\n \t  alloc_reg_set_mem (max_reg_num ());\n-\t  compute_sets (f);\n+\t  compute_sets ();\n \t  run_jump_opt_after_gcse = 1;\n \t  timevar_pop (TV_PRE);\n \t}\n@@ -771,7 +771,7 @@ gcse_main (rtx f, FILE *file)\n \t{\n \t  timevar_push (TV_HOIST);\n \t  max_gcse_regno = max_reg_num ();\n-\t  alloc_gcse_mem (f);\n+\t  alloc_gcse_mem ();\n \t  changed |= one_code_hoisting_pass ();\n \t  free_gcse_mem ();\n \n@@ -794,10 +794,10 @@ gcse_main (rtx f, FILE *file)\n      conditional jumps.  */\n \n   max_gcse_regno = max_reg_num ();\n-  alloc_gcse_mem (f);\n+  alloc_gcse_mem ();\n   /* This time, go ahead and allow cprop to alter jumps.  */\n   timevar_push (TV_CPROP2);\n-  one_cprop_pass (pass + 1, 1, 0);\n+  one_cprop_pass (pass + 1, true, false);\n   timevar_pop (TV_CPROP2);\n   free_gcse_mem ();\n \n@@ -923,32 +923,39 @@ gcse_alloc (unsigned long size)\n    This is called at the start of each pass.  */\n \n static void\n-alloc_gcse_mem (rtx f)\n+alloc_gcse_mem (void)\n {\n   int i;\n+  basic_block bb;\n   rtx insn;\n \n   /* Find the largest UID and create a mapping from UIDs to CUIDs.\n      CUIDs are like UIDs except they increase monotonically, have no gaps,\n-     and only apply to real insns.  */\n+     and only apply to real insns.\n+     (Actually, there are gaps, for insn that are not inside a basic block.\n+     but we should never see those anyway, so this is OK.)  */\n \n   max_uid = get_max_uid ();\n   uid_cuid = gcalloc (max_uid + 1, sizeof (int));\n-  for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_P (insn))\n-\tuid_cuid[INSN_UID (insn)] = i++;\n-      else\n-\tuid_cuid[INSN_UID (insn)] = i;\n-    }\n+  i = 0;\n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS (bb, insn)\n+      {\n+\tif (INSN_P (insn))\n+\t  uid_cuid[INSN_UID (insn)] = i++;\n+\telse\n+\t  uid_cuid[INSN_UID (insn)] = i;\n+      }\n \n   /* Create a table mapping cuids to insns.  */\n \n   max_cuid = i;\n   cuid_insn = gcalloc (max_cuid + 1, sizeof (rtx));\n-  for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      CUID_INSN (i++) = insn;\n+  i = 0;\n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS (bb, insn)\n+      if (INSN_P (insn))\n+\tCUID_INSN (i++) = insn;\n \n   /* Allocate vars to track sets of regs.  */\n   reg_set_bitmap = BITMAP_ALLOC (NULL);\n@@ -1141,13 +1148,15 @@ record_set_info (rtx dest, rtx setter ATTRIBUTE_UNUSED, void *data)\n    `reg_set_table' for further documentation.  */\n \n static void\n-compute_sets (rtx f)\n+compute_sets (void)\n {\n+  basic_block bb;\n   rtx insn;\n \n-  for (insn = f; insn != 0; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      note_stores (PATTERN (insn), record_set_info, insn);\n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS (bb, insn)\n+      if (INSN_P (insn))\n+\tnote_stores (PATTERN (insn), record_set_info, insn);\n }\n \f\n /* Hash table support.  */\n@@ -2038,9 +2047,7 @@ compute_hash_table_work (struct hash_table *table)\n \t ??? hard-reg reg_set_in_block computation\n \t could be moved to compute_sets since they currently don't change.  */\n \n-      for (insn = BB_HEAD (current_bb);\n-\t   insn && insn != NEXT_INSN (BB_END (current_bb));\n-\t   insn = NEXT_INSN (insn))\n+      FOR_BB_INSNS (current_bb, insn)\n \t{\n \t  if (! INSN_P (insn))\n \t    continue;\n@@ -2064,10 +2071,8 @@ compute_hash_table_work (struct hash_table *table)\n \t\t       BB_HEAD (current_bb), table);\n \n       /* The next pass builds the hash table.  */\n-\n-      for (insn = BB_HEAD (current_bb), in_libcall_block = 0;\n-\t   insn && insn != NEXT_INSN (BB_END (current_bb));\n-\t   insn = NEXT_INSN (insn))\n+      in_libcall_block = 0;\n+      FOR_BB_INSNS (current_bb, insn)\n \tif (INSN_P (insn))\n \t  {\n \t    if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n@@ -2852,7 +2857,7 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n }\n \n static bool\n-constprop_register (rtx insn, rtx from, rtx to, int alter_jumps)\n+constprop_register (rtx insn, rtx from, rtx to, bool alter_jumps)\n {\n   rtx sset;\n \n@@ -3030,7 +3035,7 @@ local_cprop_find_used_regs (rtx *xptr, void *data)\n    their REG_EQUAL notes need updating.  */\n \n static bool\n-do_local_cprop (rtx x, rtx insn, int alter_jumps, rtx *libcall_sp)\n+do_local_cprop (rtx x, rtx insn, bool alter_jumps, rtx *libcall_sp)\n {\n   rtx newreg = NULL, newcnst = NULL;\n \n@@ -3148,9 +3153,14 @@ adjust_libcall_notes (rtx oldreg, rtx newval, rtx insn, rtx *libcall_sp)\n \n #define MAX_NESTED_LIBCALLS 9\n \n+/* Do local const/copy propagation (i.e. within each basic block).\n+   If ALTER_JUMPS is true, allow propagating into jump insns, which\n+   could modify the CFG.  */\n+\n static void\n-local_cprop_pass (int alter_jumps)\n+local_cprop_pass (bool alter_jumps)\n {\n+  basic_block bb;\n   rtx insn;\n   struct reg_use *reg_used;\n   rtx libcall_stack[MAX_NESTED_LIBCALLS + 1], *libcall_sp;\n@@ -3159,51 +3169,62 @@ local_cprop_pass (int alter_jumps)\n   cselib_init (false);\n   libcall_sp = &libcall_stack[MAX_NESTED_LIBCALLS];\n   *libcall_sp = 0;\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+  FOR_EACH_BB (bb)\n     {\n-      if (INSN_P (insn))\n+      FOR_BB_INSNS (bb, insn)\n \t{\n-\t  rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n-\n-\t  if (note)\n-\t    {\n-\t      gcc_assert (libcall_sp != libcall_stack);\n-\t      *--libcall_sp = XEXP (note, 0);\n-\t    }\n-\t  note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n-\t  if (note)\n-\t    libcall_sp++;\n-\t  note = find_reg_equal_equiv_note (insn);\n-\t  do\n+\t  if (INSN_P (insn))\n \t    {\n-\t      reg_use_count = 0;\n-\t      note_uses (&PATTERN (insn), local_cprop_find_used_regs, NULL);\n-\t      if (note)\n-\t\tlocal_cprop_find_used_regs (&XEXP (note, 0), NULL);\n+\t      rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n \n-\t      for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n-\t\t   reg_used++, reg_use_count--)\n-\t\tif (do_local_cprop (reg_used->reg_rtx, insn, alter_jumps,\n-\t\t    libcall_sp))\n-\t\t  {\n-\t\t    changed = true;\n+\t      if (note)\n+\t\t{\n+\t\t  gcc_assert (libcall_sp != libcall_stack);\n+\t\t  *--libcall_sp = XEXP (note, 0);\n+\t\t}\n+\t      note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n+\t      if (note)\n+\t\tlibcall_sp++;\n+\t      note = find_reg_equal_equiv_note (insn);\n+\t      do\n+\t\t{\n+\t\t  reg_use_count = 0;\n+\t\t  note_uses (&PATTERN (insn), local_cprop_find_used_regs,\n+\t\t\t     NULL);\n+\t\t  if (note)\n+\t\t    local_cprop_find_used_regs (&XEXP (note, 0), NULL);\n+\n+\t\t  for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n+\t\t       reg_used++, reg_use_count--)\n+\t\t    if (do_local_cprop (reg_used->reg_rtx, insn, alter_jumps,\n+\t\t\tlibcall_sp))\n+\t\t      {\n+\t\t\tchanged = true;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  if (INSN_DELETED_P (insn))\n \t\t    break;\n-\t\t  }\n-\t      if (INSN_DELETED_P (insn))\n-\t\tbreak;\n+\t\t}\n+\t      while (reg_use_count);\n \t    }\n-\t  while (reg_use_count);\n+\t  cselib_process_insn (insn);\n \t}\n-      cselib_process_insn (insn);\n+\n+      /* Forget everything at the end of a basic block.  Make sure we are\n+\t not inside a libcall, they should never cross basic blocks.  */\n+      cselib_clear_table ();\n+      gcc_assert (libcall_sp == &libcall_stack[MAX_NESTED_LIBCALLS]);\n     }\n+\n   cselib_finish ();\n+\n   /* Global analysis may get into infinite loops for unreachable blocks.  */\n   if (changed && alter_jumps)\n     {\n       delete_unreachable_blocks ();\n       free_reg_set_mem ();\n       alloc_reg_set_mem (max_reg_num ());\n-      compute_sets (get_insns ());\n+      compute_sets ();\n     }\n }\n \n@@ -3232,9 +3253,7 @@ cprop (int alter_jumps)\n \t start of the block].  */\n       reset_opr_set_tables ();\n \n-      for (insn = BB_HEAD (bb);\n-\t   insn != NULL && insn != NEXT_INSN (BB_END (bb));\n-\t   insn = NEXT_INSN (insn))\n+      FOR_BB_INSNS (bb, insn)\n \tif (INSN_P (insn))\n \t  {\n \t    changed |= cprop_insn (insn, alter_jumps);\n@@ -3358,7 +3377,7 @@ find_implicit_sets (void)\n    perform conditional jump bypassing optimizations.  */\n \n static int\n-one_cprop_pass (int pass, int cprop_jumps, int bypass_jumps)\n+one_cprop_pass (int pass, bool cprop_jumps, bool bypass_jumps)\n {\n   int changed = 0;\n \n@@ -3665,9 +3684,7 @@ bypass_conditional_jumps (void)\n       if (!single_pred_p (bb))\n \t{\n \t  setcc = NULL_RTX;\n-\t  for (insn = BB_HEAD (bb);\n-\t       insn != NULL && insn != NEXT_INSN (BB_END (bb));\n-\t       insn = NEXT_INSN (insn))\n+\t  FOR_BB_INSNS (bb, insn)\n \t    if (NONJUMP_INSN_P (insn))\n \t      {\n \t\tif (setcc)\n@@ -5221,9 +5238,7 @@ compute_ld_motion_mems (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      for (insn = BB_HEAD (bb);\n-\t   insn && insn != NEXT_INSN (BB_END (bb));\n-\t   insn = NEXT_INSN (insn))\n+      FOR_BB_INSNS (bb, insn)\n \t{\n \t  if (INSN_P (insn))\n \t    {\n@@ -5678,9 +5693,7 @@ compute_store_table (void)\n       /* First compute the registers set in this block.  */\n       regvec = last_set_in;\n \n-      for (insn = BB_HEAD (bb);\n-\t   insn != NEXT_INSN (BB_END (bb));\n-\t   insn = NEXT_INSN (insn))\n+      FOR_BB_INSNS (bb, insn)\n \t{\n \t  if (! INSN_P (insn))\n \t    continue;\n@@ -5703,9 +5716,7 @@ compute_store_table (void)\n       /* Now find the stores.  */\n       memset (already_set, 0, sizeof (int) * max_gcse_regno);\n       regvec = already_set;\n-      for (insn = BB_HEAD (bb);\n-\t   insn != NEXT_INSN (BB_END (bb));\n-\t   insn = NEXT_INSN (insn))\n+      FOR_BB_INSNS (bb, insn)\n \t{\n \t  if (! INSN_P (insn))\n \t    continue;\n@@ -6477,11 +6488,11 @@ bypass_jumps (FILE *file)\n      information about memory sets when we build the hash tables.  */\n \n   alloc_reg_set_mem (max_gcse_regno);\n-  compute_sets (get_insns ());\n+  compute_sets ();\n \n   max_gcse_regno = max_reg_num ();\n-  alloc_gcse_mem (get_insns ());\n-  changed = one_cprop_pass (MAX_GCSE_PASSES + 2, 1, 1);\n+  alloc_gcse_mem ();\n+  changed = one_cprop_pass (MAX_GCSE_PASSES + 2, true, true);\n   free_gcse_mem ();\n \n   if (file)"}]}