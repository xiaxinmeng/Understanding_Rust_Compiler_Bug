{"sha": "2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYyYWVkYTk4ZjNhYTI0MDM0YTcwMGU3ZWZjYjZjMWE5Mzk3ODM2Zg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2019-09-03T15:08:28Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2019-09-03T15:08:28Z"}, "message": "Remove Cell Broadband Engine SPU targets\n\nFrom-SVN: r275343", "tree": {"sha": "5b5243531a267cc134be476ce30f7405ea5998a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b5243531a267cc134be476ce30f7405ea5998a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/comments", "author": null, "committer": null, "parents": [{"sha": "934392185369af22fee845e4edd92c420b8c248b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/934392185369af22fee845e4edd92c420b8c248b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/934392185369af22fee845e4edd92c420b8c248b"}], "stats": {"total": 34316, "additions": 299, "deletions": 34017}, "files": [{"sha": "329c581d0ba86e1b05f6ac212e151178875fde9c", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,3 +1,7 @@\n+2019-09-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* MAINTAINERS: Remove spu port maintainers.\n+\n 2019-08-28  Martin Liska  <mliska@suse.cz>\n \n \t* .gitignore: Add .clangd and compile_commands.json"}, {"sha": "109ac32e7aec2568bac1c526922e0dd5947a327d", "filename": "MAINTAINERS", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -109,9 +109,6 @@ sh port\t\t\tAlexandre Oliva\t\t<aoliva@gcc.gnu.org>\n sh port\t\t\tOleg Endo\t\t<olegendo@gcc.gnu.org>\n sparc port\t\tDavid S. Miller\t\t<davem@redhat.com>\n sparc port\t\tEric Botcazou\t\t<ebotcazou@libertysurf.fr>\n-spu port\t\tTrevor Smigiel\t\t<trevor_smigiel@playstation.sony.com>\n-spu port\t\tDavid Edelsohn\t\t<dje.gcc@gmail.com>\n-spu port\t\tUlrich Weigand\t\t<uweigand@de.ibm.com>\n tilegx port\t\tWalter Lee\t\t<walt@tilera.com>\n tilepro port\t\tWalter Lee\t\t<walt@tilera.com>\n v850 port\t\tNick Clifton\t\t<nickc@redhat.com>"}, {"sha": "95a64658b627931e640bc2f482f54b68c4f87ae0", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,3 +1,8 @@\n+2019-09-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* compare-all-tests (all_targets): Remove references to spu.\n+\t* config-list.mk (LIST): Likewise.\n+\n 2019-09-02  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* vim-gcc-dev/syntax/gcc-match.vim: Do not override 'tabstop' here."}, {"sha": "502cc64f52270c19b4086b3d660fedaf928e5a31", "filename": "contrib/compare-all-tests", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2Fcompare-all-tests", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2Fcompare-all-tests", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fcompare-all-tests?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -34,7 +34,7 @@ s390_opts='-m31 -m31/-mzarch -m64'\n sh_opts='-m3 -m3e -m4 -m4a -m4al -m4/-mieee -m1 -m1/-mno-cbranchdi -m2a -m2a/-mieee -m2e -m2e/-mieee'\n sparc_opts='-mcpu=v8/-m32 -mcpu=v9/-m32 -m64'\n \n-all_targets='alpha arm avr bfin cris fr30 frv h8300 ia64 iq2000 m32c m32r m68k mcore mips mmix mn10300 pa pdp11 ppc sh sparc spu v850 vax xstormy16 xtensa' # e500 \n+all_targets='alpha arm avr bfin cris fr30 frv h8300 ia64 iq2000 m32c m32r m68k mcore mips mmix mn10300 pa pdp11 ppc sh sparc v850 vax xstormy16 xtensa' # e500 \n \n test_one_file ()\n {"}, {"sha": "8c37cdb628c5c75265ad8be57f723fc95d2b427a", "filename": "contrib/config-list.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -90,7 +90,7 @@ LIST = aarch64-elf aarch64-linux-gnu aarch64-rtems \\\n   sparc-leon3-linux-gnuOPT-enable-target=all sparc-netbsdelf \\\n   sparc64-sun-solaris2.11OPT-with-gnu-ldOPT-with-gnu-asOPT-enable-threads=posix \\\n   sparc-wrs-vxworks sparc64-elf sparc64-rtems sparc64-linux sparc64-freebsd6 \\\n-  sparc64-netbsd sparc64-openbsd spu-elf \\\n+  sparc64-netbsd sparc64-openbsd \\\n   tilegx-linux-gnu tilegxbe-linux-gnu tilepro-linux-gnu \\\n   v850e-elf v850-elf v850-rtems vax-linux-gnu \\\n   vax-netbsdelf vax-openbsd visium-elf x86_64-apple-darwin \\"}, {"sha": "64154730f84a294b57eab3883e8a2edac4b3ec38", "filename": "contrib/header-tools/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2Fheader-tools%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2Fheader-tools%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fheader-tools%2FChangeLog?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,3 +1,8 @@\n+2019-09-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* README: Remove references to spu.\n+\t* reduce-headers: Likewise.\n+\n 2017-07-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "592af3ab60d20a0241407e163471e88b8c9be8b9", "filename": "contrib/header-tools/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2Fheader-tools%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2Fheader-tools%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fheader-tools%2FREADME?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -203,7 +203,7 @@ reduce-headers\n   these targets.  They are also known to the tool.  When building targets it\n   will check those targets before the rest.  \n   This coverage can be achieved by building config-list.mk with :\n-  LIST=\"aarch64-linux-gnu arm-netbsdelf c6x-elf epiphany-elf hppa2.0-hpux10.1 i686-mingw32crt i686-pc-msdosdjgpp mipsel-elf powerpc-eabisimaltivec rs6000-ibm-aix5.1.0 sh-superh-elf sparc64-elf spu-elf\"\n+  LIST=\"aarch64-linux-gnu arm-netbsdelf c6x-elf epiphany-elf hppa2.0-hpux10.1 i686-mingw32crt i686-pc-msdosdjgpp mipsel-elf powerpc-eabisimaltivec rs6000-ibm-aix5.1.0 sh-superh-elf sparc64-elf\"\n \n   -b specifies the native bootstrapped build root directory\n   -t specifies a target build root directory that config-list.mk was run from"}, {"sha": "8363736d0c85aa52cb01270ba086c6affa9eb693", "filename": "contrib/header-tools/reduce-headers", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2Fheader-tools%2Freduce-headers", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/contrib%2Fheader-tools%2Freduce-headers", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fheader-tools%2Freduce-headers?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -32,8 +32,7 @@ target_priority = [\n     \"powerpc-eabisimaltivec\",\n     \"rs6000-ibm-aix5.1.0\",\n     \"sh-superh-elf\",\n-    \"sparc64-elf\",\n-    \"spu-elf\"\n+    \"sparc64-elf\"\n ]\n \n "}, {"sha": "4996f8cecec210ae4fc2542607a149b953cf2b70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,3 +1,16 @@\n+2019-09-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config.gcc: Obsolete spu target.  Remove references to spu.\n+\t* configure.ac: Remove references to spu.\n+\t* configure: Regenerate.\n+\t* config/spu/: Remove directory.\n+\t* common/config/spu/: Remove directory.\n+\n+\t* doc/extend.texi: Remove references to spu.\n+\t* doc/invoke.texi: Likewise.\n+\t* doc/md.texi: Likewise.\n+\t* doc/sourcebuild.texi: Likewise.\n+\n 2019-09-03  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR middle-end/91603"}, {"sha": "a1be3aad88b748337e1ae4b51232d5380b3cb108", "filename": "gcc/common/config/spu/spu-common.c", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fcommon%2Fconfig%2Fspu%2Fspu-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fcommon%2Fconfig%2Fspu%2Fspu-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fspu%2Fspu-common.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,56 +0,0 @@\n-/* Common hooks for SPU.\n-   Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option) \n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"common/common-target.h\"\n-#include \"common/common-target-def.h\"\n-#include \"opts.h\"\n-#include \"flags.h\"\n-#include \"params.h\"\n-\n-static void\n-spu_option_init_struct (struct gcc_options *opts)\n-{\n-  /* With so many registers this is better on by default. */\n-  opts->x_flag_rename_registers = 1;\n-}\n-\n-/* Implement TARGET_OPTION_DEFAULT_PARAMS.  */\n-static void\n-spu_option_default_params (void)\n-{\n-  /* Override some of the default param values.  With so many registers\n-     larger values are better for these params.  */\n-  set_default_param_value (PARAM_MAX_PENDING_LIST_LENGTH, 128);\n-}\n-\n-#undef TARGET_DEFAULT_TARGET_FLAGS\n-#define TARGET_DEFAULT_TARGET_FLAGS (TARGET_DEFAULT)\n-\n-#undef TARGET_OPTION_INIT_STRUCT\n-#define TARGET_OPTION_INIT_STRUCT spu_option_init_struct\n-\n-#undef TARGET_OPTION_DEFAULT_PARAMS\n-#define TARGET_OPTION_DEFAULT_PARAMS spu_option_default_params\n-\n-#undef TARGET_EXCEPT_UNWIND_INFO\n-#define TARGET_EXCEPT_UNWIND_INFO  sjlj_except_unwind_info\n-\n-struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "94a36083db051c039231e76a96410efe93b6d145", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -247,8 +247,7 @@ md_file=\n \n # Obsolete configurations.\n case ${target} in\n-  spu*-*-*\t\t\t\t\\\n-  | tile*-*-*\t\t\t\t\\\n+  tile*-*-*\t\t\t\t\\\n  )\n     if test \"x$enable_obsolete\" != xyes; then\n       echo \"*** Configuration ${target} is obsolete.\" >&2\n@@ -280,6 +279,7 @@ case ${target} in\n  | powerpc*-*-linux*paired*\t\t\\\n  | powerpc*-*-*spe*\t\t\t\\\n  | sparc-hal-solaris2*\t\t\t\\\n+ | spu*-*-*\t\t\t\t\\\n  | thumb-*-*\t\t\t\t\\\n  | *-*-freebsd[12] | *-*-freebsd[1234].* \\\n  | *-*-freebsd*aout*\t\t\t\\\n@@ -535,9 +535,6 @@ sparc*-*-*)\n \td_target_objs=\"sparc-d.o\"\n \textra_headers=\"visintrin.h\"\n \t;;\n-spu*-*-*)\n-\tcpu_type=spu\n-\t;;\n s390*-*-*)\n \tcpu_type=s390\n \td_target_objs=\"s390-d.o\"\n@@ -3171,15 +3168,6 @@ sparc64-*-openbsd*)\n \twith_cpu=ultrasparc\n \ttmake_file=\"${tmake_file} sparc/t-sparc\"\n \t;;\n-spu-*-elf*)\n-\ttm_file=\"dbxelf.h elfos.h spu/spu-elf.h spu/spu.h newlib-stdint.h\"\n-\ttmake_file=\"spu/t-spu-elf\"\n-        native_system_header_dir=/include\n-\textra_headers=\"spu_intrinsics.h spu_internals.h vmx2spu.h spu_mfcio.h vec_types.h spu_cache.h\"\n-\textra_modes=spu/spu-modes.def\n-\tc_target_objs=\"${c_target_objs} spu-c.o\"\n-\tcxx_target_objs=\"${cxx_target_objs} spu-c.o\"\n-\t;;\n tic6x-*-elf)\n \ttm_file=\"elfos.h ${tm_file} c6x/elf-common.h c6x/elf.h\"\n \ttm_file=\"${tm_file} dbxelf.h tm-dwarf2.h newlib-stdint.h\"\n@@ -4890,23 +4878,6 @@ case \"${target}\" in\n \t\tesac\n \t\t;;\n \n-\tspu-*-*)\n-\t\tsupported_defaults=\"arch tune\"\n-\n-\t\tfor which in arch tune; do\n-\t\t\teval \"val=\\$with_$which\"\n-\t\t\tcase ${val} in\n-\t\t\t\"\" | cell | celledp)\n-\t\t\t\t# OK\n-\t\t\t\t;;\n-\t\t\t*)\n-\t\t\t\techo \"Unknown cpu used in --with-$which=$val.\" 1>&2\n-\t\t\t\texit 1\n-\t\t\t\t;;\n-\t\t\tesac\n-\t\tdone\n-\t\t;;\n-\n \ttic6x-*-*)\n \t\tsupported_defaults=\"arch\"\n "}, {"sha": "6c6897d0602f0175968f692da4b1f01420a2aa8a", "filename": "gcc/config/spu/constraints.md", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fconstraints.md?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,179 +0,0 @@\n-;; Constraint definitions for SPU\n-;; Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-;;\n-;; This file is free software; you can redistribute it and/or modify it under\n-;; the terms of the GNU General Public License as published by the Free\n-;; Software Foundation; either version 3 of the License, or (at your option) \n-;; any later version.\n-\n-;; This file is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-;; for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-\f\n-;;       ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n-;; GCC:      ffffiiiiiiii     x x        x x   xxxx xx\n-;; SPU:  xxxx    xxx xxxx xxxx x xxx xx x   xxx         xx\n-;; FREE:     ffff   i    a          a  a  a        a  aa  aaa\n-;; x - used\n-;; a - available\n-;; i - available for integer immediates\n-;; f - available for floating point immediates\n-\n-;; For most immediate constraints we have 3 variations to deal with the\n-;; fact const_int has no mode.  One variation treats const_int as 32 bit,\n-;; another treats it as 64 bit, and the third sign extends it to 128 bit.\n-\n-(define_constraint \"A\"\n-  \"An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 32-bit value.\"\n-  (ior (and (match_code \"const_int,const_double,const_vector\")\n-\t    (match_test \"immediate_load_p (op, SImode)\"))\n-       (match_code \"symbol_ref,label_ref,high,const\")))\n-\n-(define_constraint \"B\"\n-  \"An immediate for arithmetic instructions (e.g., ai, ceqi).  const_int is treated as a 32-bit value.\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"arith_immediate_p (op, SImode, -0x200, 0x1ff)\")))\n-\n-(define_constraint \"C\"\n-  \"An immediate for and/xor/or instructions.  const_int is treated as a 32-bit value.\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"logical_immediate_p (op, SImode)\")))\n-\n-(define_constraint \"D\"\n-  \"An immediate for iohl instruction.  const_int is treated as a 32-bit value.\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"iohl_immediate_p (op, SImode)\")))\n-\n-(define_constraint \"U\"\n-  \"An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is sign extended to 128 bit.\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"immediate_load_p (op, TImode)\")))\n-\n-(define_constraint \"W\"\n-  \"An immediate for shift and rotate instructions.  const_int is treated as a 32-bit value.\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"arith_immediate_p (op, SImode, -0x80000000ll, 0x7fffffffll)\")))\n-\n-(define_constraint \"Y\"\n-  \"An immediate for and/xor/or instructions.  const_int is sign extended as a 128 bit.\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"logical_immediate_p (op, TImode)\")))\n-\n-(define_constraint \"Z\"\n-  \"An immediate for iohl instruction.  const_int is sign extended to 128 bit.\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"iohl_immediate_p (op, TImode)\")))\n-\n-(define_constraint \"a\"\n-  \"An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 64-bit value.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"immediate_load_p (op, DImode)\")))\n-\n-(define_constraint \"c\"\n-  \"An immediate for and/xor/or instructions.  const_int is treated as a 64-bit value.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"logical_immediate_p (op, DImode)\")))\n-\n-(define_constraint \"d\"\n-  \"An immediate for iohl instruction.  const_int is treated as a 64-bit value.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"iohl_immediate_p (op, DImode)\")))\n-\n-(define_constraint \"f\"\n-  \"An immediate which can be loaded with fsmbi.\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"fsmbi_const_p (op)\")))\n-\n-(define_constraint \"j\"\n-  \"An immediate which can be loaded with one of the cbd/chd/cwd/cdd instructions.  const_int is treated as a 32-bit value.\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"cpat_const_p (op, SImode)\")))\n-\n-(define_constraint \"k\"\n-  \"An immediate which can be loaded with one of the cbd/chd/cwd/cdd instructions.  const_int is treated as a 64-bit value.\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"cpat_const_p (op, DImode)\")))\n-\n-(define_constraint \"l\"\n-  \"An immediate which can be loaded with one of the cbd/chd/cwd/cdd instructions.\"\n-  (and (match_code \"const_double,const_vector\")\n-       (match_test \"cpat_const_p (op, TImode)\")))\n-\n-\f\n-;; Integer constraints\n-\n-(define_constraint \"I\"\n-  \"A constant in the range [-64, 63] for shift/rotate instructions.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -0x40 && ival <= 0x3f\")))\n-\n-(define_constraint \"J\"\n-  \"An unsigned 7-bit constant for conversion/nop/channel instructions.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= 0 && ival <= 0x7f\")))\n-\n-(define_constraint \"K\"\n-  \"A signed 10-bit constant for most arithmetic instructions.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -0x200 && ival <= 0x1ff\")))\n- \n-(define_constraint \"M\"\n-  \"A signed 16-bit immediate for @code{stop}.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -0x8000ll && ival <= 0x7fffll\")))\n-\n-(define_constraint \"N\"\n-  \"An unsigned 16-bit constant for @code{iohl} and @code{fsmbi}.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= 0 && ival <= 0xffff\")))\n-\n-(define_constraint \"O\"\n-  \"An unsigned 7-bit constant whose 3 least significant bits are 0.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"(ival & 7) == 0\")))\n-\n-(define_constraint \"P\"\n-  \"An unsigned 3-bit constant for 16-byte rotates and shifts\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= 0 && ival <= 7\")))\n-\n-\f\n-;; Memory constraints\n-\n-(define_memory_constraint \"R\"\n-  \"Call operand, reg, for indirect calls\"\n-  (and (match_code \"mem\")\n-       (match_test \"GET_CODE(XEXP(op, 0)) == REG\")))\n-\n-(define_memory_constraint \"S\"\n-  \"Call operand, symbol, for relative calls.\"\n-  (and (match_code \"mem\")\n-       (match_test \"!TARGET_LARGE_MEM\n-\t\t    && ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t\t\t || GET_CODE (XEXP (op, 0)) == LABEL_REF))\")))\n-\n-(define_memory_constraint \"T\"\n-  \"Call operand, const_int, for absolute calls.\"\n-  (and (match_code \"mem\")\n-       (match_test \"GET_CODE (XEXP (op, 0)) == CONST_INT\n-\t\t    && INTVAL (XEXP (op, 0)) >= 0\n-\t\t    && INTVAL (XEXP (op, 0)) <= 0x3ffff\")))\n-\n-\f\n-;; Floating-point constant constraints.\n-\n-(define_constraint \"v\"\n-  \"Floating point power of 2 with exponent in [0..127]\"\n-  (and (match_code \"const_double,const_vector\")\n-       (match_test \"exp2_immediate_p (op, VOIDmode, 0, 127)\")))\n-\n-(define_constraint \"w\"\n-  \"Floating point power of 2 with exponent in [-126..0]\"\n-  (and (match_code \"const_double,const_vector\")\n-       (match_test \"exp2_immediate_p (op, VOIDmode, -126, 0)\")))"}, {"sha": "8d7767dad13cde0440cea01ade89ab26756cc1a1", "filename": "gcc/config/spu/predicates.md", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fpredicates.md?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,122 +0,0 @@\n-;; Predicate definitions for CELL SPU\n-;; Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-;;\n-;; This file is free software; you can redistribute it and/or modify it under\n-;; the terms of the GNU General Public License as published by the Free\n-;; Software Foundation; either version 3 of the License, or (at your option) \n-;; any later version.\n-\n-;; This file is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-;; for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-;; Return 1 if operand is constant zero of its mode\n-(define_predicate \"const_zero_operand\"\n-  (and (match_code \"const_int,const,const_double,const_vector\")\n-       (match_test \"op == CONST0_RTX (mode)\")))\n-\n-(define_predicate \"const_one_operand\"\n-  (and (match_code \"const_int,const,const_double,const_vector\")\n-       (match_test \"op == CONST1_RTX (mode)\")))\n-\n-(define_predicate \"spu_reg_operand\"\n-  (and (match_operand 0 \"register_operand\")\n-       (ior (not (match_code \"subreg\"))\n-            (match_test \"valid_subreg (op)\"))))\n-\n-(define_predicate \"spu_nonimm_operand\"\n-  (and (match_operand 0 \"nonimmediate_operand\")\n-       (ior (not (match_code \"subreg\"))\n-            (match_test \"valid_subreg (op)\"))))\n-\n-(define_predicate \"spu_nonmem_operand\"\n-  (and (match_operand 0 \"nonmemory_operand\")\n-       (ior (not (match_code \"subreg\"))\n-            (match_test \"valid_subreg (op)\"))))\n-\n-(define_predicate \"spu_mov_operand\"\n-  (ior (match_operand 0 \"memory_operand\")\n-       (match_operand 0 \"spu_nonmem_operand\")))\n-\n-(define_predicate \"spu_dest_operand\"\n-  (ior (match_operand 0 \"memory_operand\")\n-       (match_operand 0 \"spu_reg_operand\")))\n-\n-(define_predicate \"call_operand\"\n-  (and (match_code \"mem\")\n-       (match_test \"(!TARGET_LARGE_MEM && satisfies_constraint_S (op))\n-\t\t    || (satisfies_constraint_R (op)\n-\t\t\t&& REGNO (XEXP (op, 0)) != FRAME_POINTER_REGNUM\n-\t\t\t&& REGNO (XEXP (op, 0)) != ARG_POINTER_REGNUM\n-\t\t\t&& (REGNO (XEXP (op, 0)) < FIRST_PSEUDO_REGISTER\n-\t\t\t    || REGNO (XEXP (op, 0)) > LAST_VIRTUAL_REGISTER))\")))\n-\n-(define_predicate \"vec_imm_operand\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"spu_legitimate_constant_p (mode, op)\")))\n-\n-(define_predicate \"spu_arith_operand\"\n-  (match_code \"reg,subreg,const_int,const_vector\")\n-  {\n-    if (spu_reg_operand (op, mode))\n-      return 1;\n-    if (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_VECTOR)\n-      return arith_immediate_p (op, mode, -0x200, 0x1ff);\n-    return 0;\n-  })\n-\n-(define_predicate \"spu_logical_operand\"\n-  (match_code \"reg,subreg,const_int,const_double,const_vector\")\n-  {\n-    if (spu_reg_operand (op, mode))\n-      return 1;\n-    if (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE\n-\t|| GET_CODE (op) == CONST_VECTOR)\n-      return logical_immediate_p (op, mode);\n-    return 0;\n-  })\n-\n-(define_predicate \"spu_ior_operand\"\n-  (match_code \"reg,subreg,const_int,const_double,const_vector\")\n-  {\n-    if (spu_reg_operand (op, mode))\n-      return 1;\n-    if (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE\n-\t|| GET_CODE (op) == CONST_VECTOR)\n-      return logical_immediate_p (op, mode)\n-\t     || iohl_immediate_p (op, mode);\n-    return 0;\n-  })\n-\n-(define_predicate \"imm_K_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"arith_immediate_p (op, mode, -0x200, 0x1ff)\")))\n-\n-;; Return 1 if OP is a comparison operation that is valid for a branch insn.\n-;; We only check the opcode against the mode of the register value here. \n-(define_predicate \"branch_comparison_operator\"\n-  (and (match_code \"eq,ne\")\n-       (ior (match_test \"GET_MODE (XEXP (op, 0)) == HImode\")\n-\t    (match_test \"GET_MODE (XEXP (op, 0)) == SImode\"))))\n-\n-(define_predicate \"spu_inv_exp2_operand\"\n-  (and (match_code \"const_double,const_vector\")\n-       (and (match_operand 0 \"immediate_operand\")\n-\t    (match_test \"exp2_immediate_p (op, mode, -126, 0)\"))))\n-\n-(define_predicate \"spu_exp2_operand\"\n-  (and (match_code \"const_double,const_vector\")\n-       (and (match_operand 0 \"immediate_operand\")\n-\t    (match_test \"exp2_immediate_p (op, mode, 0, 127)\"))))\n-\n-(define_predicate \"shiftrt_operator\"\n-  (match_code \"lshiftrt,ashiftrt\"))\n-\n-(define_predicate \"extend_operator\"\n-  (match_code \"sign_extend,zero_extend\"))\n-"}, {"sha": "29b3639319f20a5220ff936281b9c26eb1ac3d30", "filename": "gcc/config/spu/spu-builtins.def", "status": "removed", "additions": 0, "deletions": 781, "changes": 781, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-builtins.def?ref=934392185369af22fee845e4edd92c420b8c248b"}, {"sha": "524324f22abbfd2dfe35b8950c632548e0a245ca", "filename": "gcc/config/spu/spu-builtins.md", "status": "removed", "additions": 0, "deletions": 864, "changes": 864, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-builtins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-builtins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-builtins.md?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,864 +0,0 @@\n-;; Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-;; This file is free software; you can redistribute it and/or modify it under\n-;; the terms of the GNU General Public License as published by the Free\n-;; Software Foundation; either version 3 of the License, or (at your option) \n-;; any later version.\n-\n-;; This file is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-;; for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-\n-;; This includes expands for all the intrinsics.\n-;; spu_expand_builtin looks at the mode of match_operand.\n-\n-\f\n-;; load/store\n-\n-(define_expand \"spu_lqd\"\n-  [(set (match_operand:TI 0 \"spu_reg_operand\" \"\")\n-        (mem:TI (and:SI (plus:SI (match_operand:SI 1 \"spu_reg_operand\" \"\")\n-\t\t\t\t (match_operand:SI 2 \"spu_nonmem_operand\" \"\"))\n-\t\t        (const_int -16))))]\n-  \"\"\n-  {\n-    if (GET_CODE (operands[2]) == CONST_INT\n-\t&& (INTVAL (operands[2]) & 15) != 0)\n-      operands[2] = GEN_INT (INTVAL (operands[2]) & -16);\n-    if (GET_CODE (operands[2]) != CONST_INT)\n-      {\n-\trtx op2 = operands[2];\n-\toperands[2] = force_reg (Pmode, operands[2]);\n-\tif (!ALIGNED_SYMBOL_REF_P (op2))\n-\t  emit_insn (gen_andsi3 (operands[2], operands[2], GEN_INT (-16)));\n-      }\n-  })\n-\n-(define_expand \"spu_lqx\"\n-  [(set (match_operand:TI 0 \"spu_reg_operand\" \"\")\n-        (mem:TI (and:SI (plus:SI (match_operand:SI 1 \"spu_reg_operand\" \"\")\n-                                 (match_operand:SI 2 \"spu_reg_operand\" \"\"))\n-                        (const_int -16))))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"spu_lqa\"\n-  [(set (match_operand:TI 0 \"spu_reg_operand\" \"\")\n-        (mem:TI (and:SI (match_operand:SI 1 \"immediate_operand\" \"\")\n-                        (const_int -16))))]\n-  \"\"\n-  {\n-    if (GET_CODE (operands[1]) == CONST_INT\n-\t&& (INTVAL (operands[1]) & 15) != 0)\n-      operands[1] = GEN_INT (INTVAL (operands[1]) & -16);\n-  })\n-\n-(define_expand \"spu_lqr\"\n-  [(set (match_operand:TI 0 \"spu_reg_operand\" \"\")\n-\t(mem:TI (and:SI (match_operand:SI 1 \"address_operand\" \"\")\n-\t\t\t(const_int -16))))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"spu_stqd\"\n-  [(set (mem:TI (and:SI (plus:SI (match_operand:SI 1 \"spu_reg_operand\" \"\")\n-\t\t\t\t (match_operand:SI 2 \"spu_nonmem_operand\" \"\"))\n-\t\t        (const_int -16)))\n-        (match_operand:TI 0 \"spu_reg_operand\" \"r,r\"))]\n-  \"\"\n-  {\n-    if (GET_CODE (operands[2]) == CONST_INT\n-\t&& (INTVAL (operands[2]) & 15) != 0)\n-      operands[2] = GEN_INT (INTVAL (operands[2]) & -16);\n-    if (GET_CODE (operands[2]) != CONST_INT)\n-      {\n-\trtx op2 = operands[2];\n-\toperands[2] = force_reg (Pmode, operands[2]);\n-\tif (!ALIGNED_SYMBOL_REF_P (op2))\n-\t  emit_insn (gen_andsi3 (operands[2], operands[2], GEN_INT (-16)));\n-      }\n-  })\n-\n-(define_expand \"spu_stqx\"\n-  [(set (mem:TI (and:SI (plus:SI (match_operand:SI 1 \"spu_reg_operand\" \"\")\n-\t\t\t\t (match_operand:SI 2 \"spu_reg_operand\" \"\"))\n-\t\t        (const_int -16)))\n-        (match_operand:TI 0 \"spu_reg_operand\" \"r\"))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"spu_stqa\"\n-  [(set (mem:TI (and:SI (match_operand:SI 1 \"immediate_operand\" \"\")\n-\t\t\t(const_int -16)))\n-        (match_operand:TI 0 \"spu_reg_operand\" \"r\"))]\n-  \"\"\n-  {\n-    if (GET_CODE (operands[1]) == CONST_INT\n-\t&& (INTVAL (operands[1]) & 15) != 0)\n-      operands[1] = GEN_INT (INTVAL (operands[1]) & -16);\n-  })\n-\n-(define_expand \"spu_stqr\"\n-    [(set (mem:TI (and:SI (match_operand:SI 1 \"address_operand\" \"\")\n-\t\t\t  (const_int -16)))\n-\t  (match_operand:TI 0 \"spu_reg_operand\" \"\"))]\n-  \"\"\n-  \"\")\n-\n-\f\n-;; generate control word\n-\n-(define_expand \"spu_cbx\"\n-  [(set (match_operand:TI 0 \"spu_reg_operand\" \"\")\n-        (unspec:TI [(match_operand:SI 1 \"spu_reg_operand\" \"\")\n-                    (match_operand:SI 2 \"spu_nonmem_operand\" \"\")\n-                    (const_int 1)] UNSPEC_CPAT))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"spu_chx\"\n-  [(set (match_operand:TI 0 \"spu_reg_operand\" \"\")\n-        (unspec:TI [(match_operand:SI 1 \"spu_reg_operand\" \"\")\n-                    (match_operand:SI 2 \"spu_nonmem_operand\" \"\")\n-                    (const_int 2)] UNSPEC_CPAT))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"spu_cwx\"\n-  [(set (match_operand:TI 0 \"spu_reg_operand\" \"\")\n-        (unspec:TI [(match_operand:SI 1 \"spu_reg_operand\" \"\")\n-                    (match_operand:SI 2 \"spu_nonmem_operand\" \"\")\n-                    (const_int 4)] UNSPEC_CPAT))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"spu_cdx\"\n-  [(set (match_operand:TI 0 \"spu_reg_operand\" \"\")\n-        (unspec:TI [(match_operand:SI 1 \"spu_reg_operand\" \"\")\n-                    (match_operand:SI 2 \"spu_nonmem_operand\" \"\")\n-                    (const_int 8)] UNSPEC_CPAT))]\n-  \"\"\n-  \"\")\n-\n-\n-\f\n-;; Constant formation\n-\n-(define_expand \"spu_ilhu\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"\")\n-        (const_vector:V4SI [(match_operand:SI 1 \"immediate_operand\" \"\")]))]\n-  \"\"\n-  \"{ emit_insn(gen_movv4si(operands[0], spu_const(V4SImode, (INTVAL(operands[1]) << 16))));\n-     DONE;\n-   }\")\n-\n-\f\n-;; integer subtract\n-(define_expand \"spu_sfh\"\n-  [(set (match_operand:V8HI 0 \"spu_reg_operand\" \"\")\n-        (minus:V8HI (match_operand:V8HI 2 \"spu_nonmem_operand\" \"\")\n-                    (match_operand:V8HI 1 \"spu_reg_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"spu_sf\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"\")\n-        (minus:V4SI (match_operand:V4SI 2 \"spu_nonmem_operand\" \"\")\n-                    (match_operand:V4SI 1 \"spu_reg_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"spu_sfx\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"\")\n-        (unspec:V4SI [(match_operand:V4SI 2 \"spu_reg_operand\" \"\")\n-\t\t      (match_operand:V4SI 1 \"spu_reg_operand\" \"\")\n-\t\t      (match_operand:V4SI 3 \"spu_reg_operand\" \"\")] UNSPEC_SFX))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"spu_bg\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"\")\n-        (unspec:V4SI [(match_operand:V4SI 2 \"spu_reg_operand\" \"\")\n-\t\t      (match_operand:V4SI 1 \"spu_reg_operand\" \"\")] UNSPEC_BG))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"spu_bgx\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"\")\n-        (unspec:V4SI [(match_operand:V4SI 2 \"spu_reg_operand\" \"\")\n-\t\t      (match_operand:V4SI 1 \"spu_reg_operand\" \"\")\n-\t\t      (match_operand:V4SI 3 \"spu_reg_operand\" \"\")] UNSPEC_BGX))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"spu_mpya\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (plus:V4SI\n-\t  (mult:V4SI\n-\t    (sign_extend:V4SI\n-\t      (vec_select:V4HI\n-\t\t(match_operand:V8HI 1 \"spu_reg_operand\" \"r\")\n-\t\t(parallel [(const_int 1)(const_int 3)(const_int 5)(const_int 7)])))\n-\t    (sign_extend:V4SI\n-\t      (vec_select:V4HI\n-\t\t(match_operand:V8HI 2 \"spu_reg_operand\" \"r\")\n-\t\t(parallel [(const_int 1)(const_int 3)(const_int 5)(const_int 7)]))))\n-\t(match_operand:V4SI 3 \"spu_reg_operand\" \"r\")))]\n-  \"\"\n-  \"mpya\\t%0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp7\")])\n-\n-(define_insn \"spu_mpyh\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (ashift:V4SI\n-\t  (mult:V4SI\n-\t    (sign_extend:V4SI\n-\t      (vec_select:V4HI\n-\t\t(match_operand:V8HI 1 \"spu_reg_operand\" \"r\")\n-\t\t(parallel [(const_int 0)(const_int 2)(const_int 4)(const_int 6)])))\n-\t    (sign_extend:V4SI\n-\t      (vec_select:V4HI\n-\t\t(match_operand:V8HI 2 \"spu_reg_operand\" \"r\")\n-\t\t(parallel [(const_int 1)(const_int 3)(const_int 5)(const_int 7)]))))\n-\t  (const_vector:V4SI [(const_int 16)(const_int 16)(const_int 16)(const_int 16)])))]\n-  \"\"\n-  \"mpyh\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fp7\")])\n-\n-(define_insn \"spu_mpys\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (ashiftrt:V4SI\n-\t  (mult:V4SI\n-\t    (sign_extend:V4SI\n-\t      (vec_select:V4HI\n-\t\t(match_operand:V8HI 1 \"spu_reg_operand\" \"r\")\n-\t\t(parallel [(const_int 1)(const_int 3)(const_int 5)(const_int 7)])))\n-\t    (sign_extend:V4SI\n-\t      (vec_select:V4HI\n-\t\t(match_operand:V8HI 2 \"spu_reg_operand\" \"r\")\n-\t\t(parallel [(const_int 1)(const_int 3)(const_int 5)(const_int 7)]))))\n-\t  (const_vector:V4SI [(const_int 16)(const_int 16)(const_int 16)(const_int 16)])))]\n-  \"\"\n-  \"mpys\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fp7\")])\n-\n-(define_insn \"spu_mpyhhau\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (plus:V4SI\n-\t  (mult:V4SI\n-\t    (zero_extend:V4SI\n-\t      (vec_select:V4HI\n-\t\t(match_operand:V8HI 1 \"spu_reg_operand\" \"r\")\n-\t\t(parallel [(const_int 0)(const_int 2)(const_int 4)(const_int 6)])))\n-\t    (zero_extend:V4SI\n-\t      (vec_select:V4HI\n-\t\t(match_operand:V8HI 2 \"spu_reg_operand\" \"r\")\n-\t\t(parallel [(const_int 0)(const_int 2)(const_int 4)(const_int 6)]))))\n-\t  (match_operand:V4SI 3 \"spu_reg_operand\" \"0\")))]\n-  \"\"\n-  \"mpyhhau\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fp7\")])\n-\n-(define_insn \"spu_mpyhha\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (plus:V4SI\n-\t  (mult:V4SI\n-\t    (sign_extend:V4SI\n-\t      (vec_select:V4HI\n-\t\t(match_operand:V8HI 1 \"spu_reg_operand\" \"r\")\n-\t\t(parallel [(const_int 0)(const_int 2)(const_int 4)(const_int 6)])))\n-\t    (sign_extend:V4SI\n-\t      (vec_select:V4HI\n-\t\t(match_operand:V8HI 2 \"spu_reg_operand\" \"r\")\n-\t\t(parallel [(const_int 0)(const_int 2)(const_int 4)(const_int 6)]))))\n-\t  (match_operand:V4SI 3 \"spu_reg_operand\" \"0\")))]\n-  \"\"\n-  \"mpyhha\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fp7\")])\n-\n-;; form select mask\n-(define_insn \"spu_fsmb\"\n-  [(set (match_operand:V16QI 0 \"spu_reg_operand\" \"=r,r\")\n-        (unspec:V16QI [(match_operand:SI 1 \"spu_nonmem_operand\" \"r,MN\")] UNSPEC_FSMB))]\n-  \"\"\n-  \"@\n-  fsmb\\t%0,%1\n-  fsmbi\\t%0,%1\"\n-  [(set_attr \"type\" \"shuf\")])\n-\n-(define_insn \"spu_fsmh\"\n-  [(set (match_operand:V8HI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec:V8HI [(match_operand:SI 1 \"spu_reg_operand\" \"r\")] UNSPEC_FSMH))]\n-  \"\"\n-  \"fsmh\\t%0,%1\"\n-  [(set_attr \"type\" \"shuf\")])\n-\n-(define_insn \"spu_fsm\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec:V4SI [(match_operand:SI 1 \"spu_reg_operand\" \"r\")] UNSPEC_FSM))]\n-  \"\"\n-  \"fsm\\t%0,%1\"\n-  [(set_attr \"type\" \"shuf\")])\n-\n-\n-;; gather bits\n-(define_insn \"spu_gbb\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec:V4SI [(match_operand:V16QI 1 \"spu_reg_operand\" \"r\")] UNSPEC_GBB))]\n-  \"\"\n-  \"gbb\\t%0,%1\"\n-  [(set_attr \"type\" \"shuf\")])\n-\n-(define_insn \"spu_gbh\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec:V4SI [(match_operand:V8HI 1 \"spu_reg_operand\" \"r\")] UNSPEC_GBH))]\n-  \"\"\n-  \"gbh\\t%0,%1\"\n-  [(set_attr \"type\" \"shuf\")])\n-\n-(define_insn \"spu_gb\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec:V4SI [(match_operand:V4SI 1 \"spu_reg_operand\" \"r\")] UNSPEC_GB))]\n-  \"\"\n-  \"gb\\t%0,%1\"\n-  [(set_attr \"type\" \"shuf\")])\n-\n-;; misc byte operations\n-(define_insn \"spu_avgb\"\n-  [(set (match_operand:V16QI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec:V16QI [(match_operand:V16QI 1 \"spu_reg_operand\" \"r\")\n-\t\t       (match_operand:V16QI 2 \"spu_reg_operand\" \"r\")] UNSPEC_AVGB))]\n-  \"\"\n-  \"avgb\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fxb\")])\n-\n-(define_insn \"spu_absdb\"\n-  [(set (match_operand:V16QI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec:V16QI [(match_operand:V16QI 1 \"spu_reg_operand\" \"r\")\n-\t\t       (match_operand:V16QI 2 \"spu_reg_operand\" \"r\")] UNSPEC_ABSDB))]\n-  \"\"\n-  \"absdb\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fxb\")])\n-\n-(define_insn \"spu_sumb\"\n-  [(set (match_operand:V8HI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec:V8HI [(match_operand:V16QI 1 \"spu_reg_operand\" \"r\")\n-\t\t      (match_operand:V16QI 2 \"spu_reg_operand\" \"r\")] UNSPEC_SUMB))]\n-  \"\"\n-  \"sumb\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fxb\")])\n-\n-;; sign extend\n-(define_insn \"spu_xsbh\"\n-  [(set (match_operand:V8HI 0 \"spu_reg_operand\" \"=r\")\n-        (sign_extend:V8HI\n-\t  (vec_select:V8QI\n-\t    (match_operand:V16QI 1 \"spu_reg_operand\" \"r\")\n-\t    (parallel [(const_int 1)(const_int 3)(const_int 5)(const_int 7)\n-\t               (const_int 9)(const_int 11)(const_int 13)(const_int 15)]))))]\n-  \"\"\n-  \"xsbh\\t%0,%1\")\n-\n-(define_insn \"spu_xshw\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (sign_extend:V4SI\n-\t  (vec_select:V4HI\n-\t    (match_operand:V8HI 1 \"spu_reg_operand\" \"r\")\n-\t    (parallel [(const_int 1)(const_int 3)(const_int 5)(const_int 7)]))))]\n-  \"\"\n-  \"xshw\\t%0,%1\")\n-\n-(define_insn \"spu_xswd\"\n-  [(set (match_operand:V2DI 0 \"spu_reg_operand\" \"=r\")\n-        (sign_extend:V2DI\n-\t  (vec_select:V2SI\n-\t    (match_operand:V4SI 1 \"spu_reg_operand\" \"r\")\n-\t    (parallel [(const_int 1)(const_int 3)]))))]\n-  \"\"\n-  \"xswd\\t%0,%1\")\n-\n-;; or across\n-\n-(define_insn \"spu_orx\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-\t(unspec:V4SI [(match_operand:V4SI 1 \"spu_reg_operand\" \"r\")] UNSPEC_ORX))]\n-  \"\"\n-  \"orx\\t%0,%1\")\n-\n-\n-;; compare & halt\n-(define_insn \"spu_heq\"\n-  [(unspec_volatile [(match_operand:SI 0 \"spu_reg_operand\" \"r,r\")\n-\t             (match_operand:SI 1 \"spu_nonmem_operand\" \"r,K\")] UNSPEC_HEQ)]\n-  \"\"\n-  \"@\n-  heq\\t%0,%1\n-  heqi\\t%0,%1\")\n-\n-(define_insn \"spu_hgt\"\n-  [(unspec_volatile [(match_operand:SI 0 \"spu_reg_operand\" \"r,r\")\n-\t             (match_operand:SI 1 \"spu_nonmem_operand\" \"r,K\")] UNSPEC_HGT)]\n-  \"\"\n-  \"@\n-  hgt\\t%0,%1\n-  hgti\\t%0,%1\")\n-\n-(define_insn \"spu_hlgt\"\n-  [(unspec_volatile [(match_operand:SI 0 \"spu_reg_operand\" \"r,r\")\n-\t             (match_operand:SI 1 \"spu_nonmem_operand\" \"r,K\")] UNSPEC_HLGT)]\n-  \"\"\n-  \"@\n-  hlgt\\t%0,%1\n-  hlgti\\t%0,%1\")\n-\n-;; branches\n-\n-;; The description below hides the fact that bisled conditionally\n-;; executes the call depending on the value in channel 0.  This was \n-;; done so that the description would conform to the format of a call \n-;; insn.  Otherwise (if this were not part of call insn), the link \n-;; register, $lr, would not be saved/restored in the prologue/epilogue.\n-\n-(define_insn \"spu_bisled\"\n-  [(parallel\n-    [(call (mem:QI (match_operand:SI 0 \"spu_reg_operand\" \"r\"))\n-            (const_int 0))\n-     (clobber (reg:SI 0))\n-     (clobber (reg:SI 130))\n-     (use (match_operand:SI 1 \"address_operand\" \"\"))\n-     (use (const_int 0))])]\n-  \"\"\n-  \"bisled\\t$lr,%0\"\n-  [(set_attr \"type\" \"br\")])\n-\n-(define_insn \"spu_bisledd\"\n-  [(parallel\n-    [(call (mem:QI (match_operand:SI 0 \"spu_reg_operand\" \"r\"))\n-            (const_int 0))\n-     (clobber (reg:SI 0))\n-     (clobber (reg:SI 130))\n-     (use (match_operand:SI 1 \"address_operand\" \"\"))\n-     (use (const_int 1))])]\n-  \"\"\n-  \"bisledd\\t$lr,%0\"\n-  [(set_attr \"type\" \"br\")])\n-\n-(define_insn \"spu_bislede\"\n-  [(parallel\n-    [(call (mem:QI (match_operand:SI 0 \"spu_reg_operand\" \"r\"))\n-            (const_int 0))\n-     (clobber (reg:SI 0))\n-     (clobber (reg:SI 130))\n-     (use (match_operand:SI 1 \"address_operand\" \"\"))\n-     (use (const_int 2))])]\n-  \"\"\n-  \"bislede\\t$lr,%0\"\n-  [(set_attr \"type\" \"br\")])\n-\n-;; float convert\n-(define_expand \"spu_csflt\"\n-  [(set (match_operand:V4SF 0 \"spu_reg_operand\")\n-\t(unspec:V4SF [(match_operand:V4SI 1 \"spu_reg_operand\")\n-\t\t      (match_operand:SI 2 \"spu_nonmem_operand\")] 0 ))]\n-  \"\"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))\n-    {\n-      error (\"spu_convtf expects an integer literal in the range [0, 127].\");\n-      operands[2] = force_reg (SImode, operands[2]);\n-    }\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    {\n-      rtx exp2;\n-      rtx cnv = gen_reg_rtx (V4SFmode);\n-      rtx scale = gen_reg_rtx (SImode);\n-      rtx op2 = force_reg (SImode, operands[2]);\n-      rtx m1 = spu_gen_exp2 (V4SFmode, GEN_INT (-1));\n-      emit_insn (gen_subsi3 (scale, const1_rtx, op2));\n-      exp2 = spu_gen_exp2 (V4SFmode, scale);\n-      emit_insn (gen_floatv4siv4sf2_mul (cnv, operands[1], m1));\n-      emit_insn (gen_mulv4sf3 (operands[0], cnv, exp2));\n-    }\n-  else\n-    {\n-      rtx exp2 = spu_gen_exp2 (V4SFmode, operands[2]);\n-      emit_insn (gen_floatv4siv4sf2_div (operands[0], operands[1], exp2));\n-    }\n-  DONE;\n-})\n-\n-(define_expand \"spu_cflts\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\")\n-\t(unspec:V4SI [(match_operand:V4SF 1 \"spu_reg_operand\")\n-                      (match_operand:SI 2 \"spu_nonmem_operand\")] 0 ))]\n-  \"\"\n-{\n-  rtx exp2;\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))\n-    {\n-      error (\"spu_convts expects an integer literal in the range [0, 127].\");\n-      operands[2] = force_reg (SImode, operands[2]);\n-    }\n-  exp2 = spu_gen_exp2 (V4SFmode, operands[2]);\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    {\n-      rtx mul = gen_reg_rtx (V4SFmode);\n-      emit_insn (gen_mulv4sf3 (mul, operands[1], exp2));\n-      emit_insn (gen_fix_truncv4sfv4si2 (operands[0], mul));\n-    }\n-  else \n-    emit_insn (gen_fix_truncv4sfv4si2_mul (operands[0], operands[1], exp2));\n-  DONE;\n-})\n-\n-(define_expand \"spu_cuflt\"\n-  [(set (match_operand:V4SF 0 \"spu_reg_operand\" \"=r\")\n-\t(unspec:V4SF [(match_operand:V4SI 1 \"spu_reg_operand\")\n-\t\t      (match_operand:SI 2 \"spu_nonmem_operand\")] 0 ))]\n-  \"\"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))\n-    {\n-      error (\"spu_convtf expects an integer literal in the range [0, 127].\");\n-      operands[2] = force_reg (SImode, operands[2]);\n-    }\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    {\n-      rtx exp2;\n-      rtx cnv = gen_reg_rtx (V4SFmode);\n-      rtx scale = gen_reg_rtx (SImode);\n-      rtx op2 = force_reg (SImode, operands[2]);\n-      rtx m1 = spu_gen_exp2 (V4SFmode, GEN_INT (-1));\n-      emit_insn (gen_subsi3 (scale, const1_rtx, op2));\n-      exp2 = spu_gen_exp2 (V4SFmode, scale);\n-      emit_insn (gen_floatunsv4siv4sf2_mul (cnv, operands[1], m1));\n-      emit_insn (gen_mulv4sf3 (operands[0], cnv, exp2));\n-    }\n-  else\n-    {\n-      rtx exp2 = spu_gen_exp2 (V4SFmode, operands[2]);\n-      emit_insn (gen_floatunsv4siv4sf2_div (operands[0], operands[1], exp2));\n-    }\n-  DONE;\n-})\n-\n-(define_expand \"spu_cfltu\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\")\n-\t(unspec:V4SI [(match_operand:V4SF 1 \"spu_reg_operand\")\n-\t\t      (match_operand:SI 2 \"spu_nonmem_operand\")] 0 ))]\n-  \"\"\n-{\n-  rtx exp2;\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))\n-    {\n-      error (\"spu_convtu expects an integer literal in the range [0, 127].\");\n-      operands[2] = force_reg (SImode, operands[2]);\n-    }\n-  exp2 = spu_gen_exp2 (V4SFmode, operands[2]);\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    {\n-      rtx mul = gen_reg_rtx (V4SFmode);\n-      emit_insn (gen_mulv4sf3 (mul, operands[1], exp2));\n-      emit_insn (gen_fixuns_truncv4sfv4si2 (operands[0], mul));\n-    }\n-  else \n-    emit_insn (gen_fixuns_truncv4sfv4si2_mul (operands[0], operands[1], exp2));\n-  DONE;\n-})\n-\n-(define_expand \"spu_frds\"\n-   [(set (match_operand:V4SF 0 \"spu_reg_operand\" \"\")\n-         (vec_select:V4SF\n-\t   (vec_concat:V4SF\n-\t     (float_truncate:V2SF (match_operand:V2DF 1 \"spu_reg_operand\" \"\"))\n-\t     (match_dup:V2SF 2))\n-\t   (parallel [(const_int 0)(const_int 2)(const_int 1)(const_int 3)])))]\n-  \"\"\n-  \"operands[2] = spu_const(V2SFmode, 0);\")\n-\n-(define_insn \"_frds\"\n-   [(set (match_operand:V4SF 0 \"spu_reg_operand\" \"=r\")\n-        (vec_select:V4SF\n-\t  (vec_concat:V4SF\n-\t    (float_truncate:V2SF (match_operand:V2DF 1 \"spu_reg_operand\" \"r\"))\n-\t    (match_operand:V2SF 2 \"vec_imm_operand\" \"i\"))\n-\t  (parallel [(const_int 0)(const_int 2)(const_int 1)(const_int 3)])))]\n-  \"\"\n-  \"frds\\t%0,%1\"\n-  [(set_attr \"type\" \"fpd\")])\n-\n-(define_insn \"spu_fesd\"\n-  [(set (match_operand:V2DF 0 \"spu_reg_operand\" \"=r\")\n-        (float_extend:V2DF\n-\t  (vec_select:V2SF\n-\t    (match_operand:V4SF 1 \"spu_reg_operand\" \"r\")\n-\t      (parallel [(const_int 0)(const_int 2)]))))]\n-  \"\"\n-  \"fesd\\t%0,%1\"\n-  [(set_attr \"type\" \"fpd\")])\n-\n-;; control\n-(define_insn \"spu_stop\"\n-  [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"M\")] UNSPEC_STOP)]\n-  \"\"\n-  \"stop\\t%0\"\n-  [(set_attr \"type\" \"br\")])\n-\n-(define_insn \"spu_stopd\"\n-  [(unspec_volatile [(match_operand:SI 0 \"spu_reg_operand\" \"r\")\n-\t\t     (match_operand:SI 1 \"spu_reg_operand\" \"r\")\n-\t\t     (match_operand:SI 2 \"spu_reg_operand\" \"r\")] UNSPEC_STOPD)]\n-  \"\"\n-  \"stopd\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"br\")])\n-\n-;; interrupt disable/enable\n-(define_expand \"spu_idisable\"\n-  [(parallel\n-    [(unspec_volatile [(const_int 0)] UNSPEC_SET_INTR)\n-     (clobber (match_dup:SI 0))\n-     (clobber (mem:BLK (scratch)))])]\n-  \"\"\n-  \"operands[0] = gen_reg_rtx (SImode);\")\n-\n-(define_expand \"spu_ienable\"\n-  [(parallel\n-    [(unspec_volatile [(const_int 1)] UNSPEC_SET_INTR)\n-     (clobber (match_dup:SI 0))\n-     (clobber (mem:BLK (scratch)))])]\n-  \"\"\n-  \"operands[0] = gen_reg_rtx (SImode);\")\n-\n-(define_insn \"set_intr\"\n-  [(unspec_volatile [(match_operand 1 \"const_int_operand\" \"i\")] UNSPEC_SET_INTR)\n-   (clobber (match_operand:SI 0 \"spu_reg_operand\" \"=&r\"))\n-   (clobber (mem:BLK (scratch)))]\n-  \"! flag_pic\"\n-  \"ila\\t%0,.+8\\;bi%I1\\t%0\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multi0\")])\n-\n-(define_insn \"set_intr_pic\"\n-  [(unspec_volatile [(match_operand 1 \"const_int_operand\" \"i\")] UNSPEC_SET_INTR)\n-   (clobber (match_operand:SI 0 \"spu_reg_operand\" \"=&r\"))\n-   (clobber (mem:BLK (scratch)))]\n-  \"flag_pic\"\n-  \"brsl\\t%0,.+4\\;ai\\t%0,%0,8\\;bi%I1\\t%0\"\n-  [(set_attr \"length\" \"12\")\n-   (set_attr \"type\" \"multi1\")])\n-\n-(define_insn \"set_intr_cc\"\n-  [(cond_exec (match_operator 1 \"branch_comparison_operator\"\n-\t\t[(match_operand 2 \"spu_reg_operand\" \"r\")\n-\t\t (const_int 0)])\n-              (parallel [(unspec_volatile [(match_operand:SI 3 \"const_int_operand\" \"i\")] UNSPEC_SET_INTR)\n-                         (clobber (match_operand:SI 0 \"spu_reg_operand\" \"=&r\"))\n-\t\t\t (clobber (mem:BLK (scratch)))]))]\n-  \"! flag_pic\"\n-  \"ila\\t%0,.+8\\;bi%b2%b1z%I3\\t%2,%0\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multi0\")])\n-\n-(define_insn \"set_intr_cc_pic\"\n-  [(cond_exec (match_operator 1 \"branch_comparison_operator\"\n-\t\t[(match_operand 2 \"spu_reg_operand\" \"r\")\n-\t\t (const_int 0)])\n-              (parallel [(unspec_volatile [(match_operand:SI 3 \"const_int_operand\" \"i\")] UNSPEC_SET_INTR)\n-                         (clobber (match_operand:SI 0 \"spu_reg_operand\" \"=&r\"))\n-\t\t\t (clobber (mem:BLK (scratch)))]))]\n-  \"flag_pic\"\n-  \"brsl\\t%0,.+4\\;ai\\t%0,%0,8\\;bi%b2%b1z%I3\\t%2,%0\"\n-  [(set_attr \"length\" \"12\")\n-   (set_attr \"type\" \"multi1\")])\n-\n-(define_insn \"set_intr_return\"\n-  [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"i\")] UNSPEC_SET_INTR)\n-   (return)]\n-  \"\"\n-  \"bi%I0\\t$lr\"\n-  [(set_attr \"type\" \"br\")])\n-\n-(define_peephole2\n-  [(parallel\n-    [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\")] UNSPEC_SET_INTR)\n-     (clobber (match_operand:SI 1 \"spu_reg_operand\"))\n-     (clobber (mem:BLK (scratch)))])\n-   (use (reg:SI 0))\n-   (return)]\n-  \"\"\n-  [(use (reg:SI 0))\n-   (parallel\n-    [(unspec_volatile [(match_dup:SI 0)] UNSPEC_SET_INTR)\n-     (return)])]\n-  \"\")\n-\n-;; special purpose registers\n-(define_insn \"spu_fscrrd\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec_volatile:V4SI [(const_int 6)] UNSPEC_FSCRRD))]\n-  \"\"\n-  \"fscrrd\\t%0\"\n-  [(set_attr \"type\" \"spr\")])\n-\n-(define_insn \"spu_fscrwr\"\n-  [(unspec_volatile [(match_operand:V4SI 0 \"spu_reg_operand\" \"r\")] UNSPEC_FSCRWR)]\n-  \"\"\n-  \"fscrwr\\t$0,%0\"\n-  [(set_attr \"type\" \"spr\")])\n-\n-(define_insn \"spu_mfspr\"\n-  [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec_volatile:SI [(match_operand:SI 1 \"immediate_operand\" \"J\")] UNSPEC_MFSPR))]\n-  \"\"\n-  \"mfspr\\t%0,$sp%1\"\n-  [(set_attr \"type\" \"spr\")])\n-\n-(define_insn \"spu_mtspr\"\n-  [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"J\")\n-\t             (match_operand:SI 1 \"spu_reg_operand\" \"r\")] UNSPEC_MTSPR)]\n-  \"\"\n-  \"mtspr\\t$sp%0,%1\"\n-  [(set_attr \"type\" \"spr\")])\n-\n-;; channels\n-(define_expand \"spu_rdch\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"\")\n-        (unspec_volatile:V4SI [(match_operand:SI 1 \"immediate_operand\" \"\")] UNSPEC_RDCH))]\n-  \"\"\n-  \"{\n-    if (spu_safe_dma (INTVAL (operands[1])))\n-      {\n-        emit_insn (gen_spu_rdch_clobber (operands[0], operands[1]));\n-        DONE;\n-      }\n-   }\")\n-\n-(define_expand \"spu_rchcnt\"\n-  [(set (match_operand:SI 0 \"spu_reg_operand\" \"\")\n-        (unspec_volatile:SI [(match_operand:SI 1 \"immediate_operand\" \"\")] UNSPEC_RCHCNT))]\n-  \"\"\n-  \"{\n-    if (spu_safe_dma (INTVAL (operands[1])))\n-      {\n-        emit_insn (gen_spu_rchcnt_clobber (operands[0], operands[1]));\n-        DONE;\n-      }\n-   }\")\n-\n-(define_expand \"spu_wrch\"\n-   [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"\")\n- \t              (match_operand:V4SI 1 \"spu_reg_operand\" \"\")] UNSPEC_WRCH)]\n-   \"\"\n-  \"{\n-    if (spu_safe_dma (INTVAL (operands[0])))\n-      {\n-        emit_insn (gen_spu_wrch_clobber (operands[0], operands[1]));\n-        DONE;\n-      }\n-   }\")\n-\n-(define_insn \"spu_rdch_noclobber\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec_volatile:V4SI [(match_operand:SI 1 \"immediate_operand\" \"J\")] UNSPEC_RDCH))]\n-  \"\"\n-  \"rdch\\t%0,$ch%1\"\n-  [(set_attr \"type\" \"spr\")])\n-\n-(define_insn \"spu_rchcnt_noclobber\"\n-  [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec_volatile:SI [(match_operand:SI 1 \"immediate_operand\" \"J\")] UNSPEC_RCHCNT))]\n-  \"\"\n-  \"rchcnt\\t%0,$ch%1\"\n-  [(set_attr \"type\" \"spr\")])\n-\n-(define_insn \"spu_wrch_noclobber\"\n-   [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"J\")\n- \t              (match_operand:V4SI 1 \"spu_reg_operand\" \"r\")] UNSPEC_WRCH)]\n-   \"\"\n-   \"wrch\\t$ch%0,%1\"\n-   [(set_attr \"type\" \"spr\")])\n-\n-(define_insn \"spu_rdch_clobber\"\n-  [(set (match_operand:V4SI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec_volatile:V4SI [(match_operand:SI 1 \"immediate_operand\" \"J\")] UNSPEC_RDCH))\n-    (clobber (mem:BLK (scratch)))]\n-  \"\"\n-  \"rdch\\t%0,$ch%1\"\n-  [(set_attr \"type\" \"spr\")])\n-\n-(define_insn \"spu_rchcnt_clobber\"\n-  [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n-        (unspec_volatile:SI [(match_operand:SI 1 \"immediate_operand\" \"J\")] UNSPEC_RCHCNT))\n-    (clobber (mem:BLK (scratch)))]\n-  \"\"\n-  \"rchcnt\\t%0,$ch%1\"\n-  [(set_attr \"type\" \"spr\")])\n-\n-(define_insn \"spu_wrch_clobber\"\n-   [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"J\")\n- \t              (match_operand:V4SI 1 \"spu_reg_operand\" \"r\")] UNSPEC_WRCH)\n-    (clobber (mem:BLK (scratch)))]\n-   \"\"\n-   \"wrch\\t$ch%0,%1\"\n-   [(set_attr \"type\" \"spr\")])\n-\n-(define_expand \"spu_splats\" \n-  [(set (match_operand 0 \"spu_reg_operand\" \"\")\n-        (vec_duplicate (match_operand 1 \"spu_nonmem_operand\" \"\")))]\n-  \"\"\n-  {\n-    spu_builtin_splats(operands);\n-    DONE;\n-  })\n-\n-(define_expand \"spu_extract\"\n-  [(set (match_operand 0 \"spu_reg_operand\" \"\")\n-\t(unspec [(match_operand 1 \"spu_reg_operand\" \"\")\n-\t\t (match_operand 2 \"spu_nonmem_operand\" \"\")] 0))]\n-  \"\"\n-  {\n-    spu_builtin_extract (operands);\n-    DONE;\n-  })\n-\n-(define_expand \"spu_insert\"\n-  [(set (match_operand 0 \"spu_reg_operand\" \"\")\n-        (unspec [(match_operand 1 \"spu_reg_operand\" \"\")\n-                 (match_operand 2 \"spu_reg_operand\" \"\")\n-                 (match_operand:SI 3 \"spu_nonmem_operand\" \"\")] 0))] \n-  \"\"\n-  {\n-    spu_builtin_insert(operands);\n-    DONE;\n-  })\n-\n-(define_expand \"spu_promote\"\n-  [(set (match_operand 0 \"spu_reg_operand\" \"\")\n-        (unspec [(match_operand 1 \"spu_reg_operand\" \"\")\n-                 (match_operand:SI 2 \"immediate_operand\" \"\")] 0))] \n-  \"\"\n-  {\n-    spu_builtin_promote(operands);\n-    DONE;\n-  })\n-\n-;; Currently doing nothing with this but expanding its args.\n-(define_expand \"spu_align_hint\"\n-  [(unspec [(match_operand:SI 0 \"address_operand\" \"\")\n-            (match_operand:SI 1 \"immediate_operand\" \"\")\n-            (match_operand:SI 2 \"immediate_operand\" \"\")] 0)]\n-  \"\"\n-  {\n-     DONE;\n-  })\n-"}, {"sha": "63120824e031e081429d2847ee7331710f79cc80", "filename": "gcc/config/spu/spu-c.c", "status": "removed", "additions": 0, "deletions": 233, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-c.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,233 +0,0 @@\n-/* Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option) \n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#define IN_TARGET_CODE 1\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"target.h\"\n-#include \"c-family/c-common.h\"\n-#include \"stringpool.h\"\n-#include \"langhooks.h\"\n-\f\n-\n-/* Keep the vector keywords handy for fast comparisons.  */\n-static GTY(()) tree __vector_keyword;\n-static GTY(()) tree vector_keyword;\n-\n-static cpp_hashnode *\n-spu_categorize_keyword (const cpp_token *tok)\n-{\n-  if (tok->type == CPP_NAME)\n-    {\n-      cpp_hashnode *ident = tok->val.node.node;\n-\n-      if (ident == C_CPP_HASHNODE (vector_keyword)\n-\t  || ident == C_CPP_HASHNODE (__vector_keyword))\n-\treturn C_CPP_HASHNODE (__vector_keyword);\n-      else\n-\treturn ident;\n-    }\n-  return 0;\n-}\n-\n-/* Called to decide whether a conditional macro should be expanded.\n-   Since we have exactly one such macro (i.e, 'vector'), we do not\n-   need to examine the 'tok' parameter.  */\n-\n-static cpp_hashnode *\n-spu_macro_to_expand (cpp_reader *pfile, const cpp_token *tok)\n-{\n-  cpp_hashnode *expand_this = tok->val.node.node;\n-  cpp_hashnode *ident;\n-\n-  ident = spu_categorize_keyword (tok);\n-  if (ident == C_CPP_HASHNODE (__vector_keyword))\n-    {\n-      tok = cpp_peek_token (pfile, 0);\n-      ident = spu_categorize_keyword (tok);\n-\n-      if (ident)\n-\t{\n-\t  enum rid rid_code = (enum rid)(ident->rid_code);\n-\t  if (cpp_macro_p (ident))\n-\t    {\n-\t      (void) cpp_get_token (pfile);\n-\t      tok = cpp_peek_token (pfile, 0);\n-\t      ident = spu_categorize_keyword (tok);\n-\t      if (ident)\n-\t\trid_code = (enum rid)(ident->rid_code);\n-\t    }\n-\t  \n-\t  if (rid_code == RID_UNSIGNED || rid_code == RID_LONG\n-\t      || rid_code == RID_SHORT || rid_code == RID_SIGNED\n-\t      || rid_code == RID_INT || rid_code == RID_CHAR\n-\t      || rid_code == RID_FLOAT || rid_code == RID_DOUBLE)\n-\t    expand_this = C_CPP_HASHNODE (__vector_keyword);\n-\t}\n-    }\n-  return expand_this;\n-}\n-\n-/* target hook for resolve_overloaded_builtin(). Returns a function call\n-   RTX if we can resolve the overloaded builtin */\n-tree\n-spu_resolve_overloaded_builtin (location_t loc, tree fndecl, void *passed_args)\n-{\n-#define SCALAR_TYPE_P(t) (INTEGRAL_TYPE_P (t) \\\n-\t\t\t  || SCALAR_FLOAT_TYPE_P (t) \\\n-\t\t\t  || POINTER_TYPE_P (t))\n-  vec<tree, va_gc> *fnargs = static_cast <vec<tree, va_gc> *> (passed_args);\n-  unsigned int nargs = vec_safe_length (fnargs);\n-  int new_fcode, fcode = DECL_MD_FUNCTION_CODE (fndecl);\n-  struct spu_builtin_description *desc;\n-  tree match = NULL_TREE;\n-\n-  /* The vector types are not available if the backend is not initialized.  */\n-  gcc_assert (!flag_preprocess_only);\n-\n-  desc = &spu_builtins[fcode];\n-  if (desc->type != B_OVERLOAD)\n-    return NULL_TREE;\n-\n-  /* Compare the signature of each internal builtin function with the\n-     function arguments until a match is found. */\n-\n-  for (new_fcode = fcode + 1; spu_builtins[new_fcode].type == B_INTERNAL;\n-       new_fcode++)\n-    {\n-      tree decl = targetm.builtin_decl (new_fcode, true);\n-      tree params = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-      tree param;\n-      bool all_scalar;\n-      unsigned int p;\n-\n-      /* Check whether all parameters are scalar.  */\n-      all_scalar = true;\n-      for (param = params; param != void_list_node; param = TREE_CHAIN (param))\n-      if (!SCALAR_TYPE_P (TREE_VALUE (param)))\n-\tall_scalar = false;\n-\n-      for (param = params, p = 0;\n-\t   param != void_list_node;\n-\t   param = TREE_CHAIN (param), p++)\n-\t{\n-\t  tree var, arg_type, param_type = TREE_VALUE (param);\n-\n-\t  if (p >= nargs)\n-\t    {\n-\t      error (\"insufficient arguments to overloaded function %s\",\n-\t\t     desc->name);\n-\t      return error_mark_node;\n-\t    }\n-\n-\t  var = (*fnargs)[p];\n-\n-\t  if (TREE_CODE (var) == NON_LVALUE_EXPR)\n-\t    var = TREE_OPERAND (var, 0);\n-\n-\t  if (TREE_CODE (var) == ERROR_MARK)\n-\t    return NULL_TREE;\t/* Let somebody else deal with the problem. */\n-\n-\t  arg_type = TREE_TYPE (var);\n-\n-\t  /* The intrinsics spec does not specify precisely how to\n-\t     resolve generic intrinsics.  We require an exact match\n-\t     for vector types and let C do it's usual parameter type\n-\t     checking/promotions for scalar arguments, except for the\n-\t     first argument of intrinsics which don't have a vector\n-\t     parameter. */\n-\t  if ((!SCALAR_TYPE_P (param_type)\n-\t       || !SCALAR_TYPE_P (arg_type)\n-\t       || (all_scalar && p == 0))\n-\t      && !lang_hooks.types_compatible_p (param_type, arg_type))\n-\t    break;\n-\t}\n-      if (param == void_list_node)\n-\t{\n-\t  if (p != nargs)\n-\t    {\n-\t      error (\"too many arguments to overloaded function %s\",\n-\t\t     desc->name);\n-\t      return error_mark_node;\n-\t    }\n-\n-\t  match = decl;\n-\t  break;\n-\t}\n-    }\n-\n-  if (match == NULL_TREE)\n-    {\n-      error (\"parameter list does not match a valid signature for %s()\",\n-\t     desc->name);\n-      return error_mark_node;\n-    }\n-\n-  return build_function_call_vec (loc, vNULL, match, fnargs, NULL);\n-#undef SCALAR_TYPE_P\n-}\n-\n-\n-void\n-spu_cpu_cpp_builtins (struct cpp_reader *pfile)\n-{\n-  cpp_define (pfile, \"__SPU__\");\n-  cpp_assert (pfile, \"cpu=spu\");\n-  cpp_assert (pfile, \"machine=spu\");\n-  if (spu_arch == PROCESSOR_CELLEDP)\n-    cpp_define (pfile, \"__SPU_EDP__\");\n-  if (cpp_get_options (pfile)->lang != CLK_ASM)\n-    cpp_define (pfile, \"__vector=__attribute__((__spu_vector__))\");\n-  switch (spu_ea_model)\n-    {\n-    case 32:\n-      cpp_define (pfile, \"__EA32__\");\n-      break;\n-    case 64:\n-      cpp_define (pfile, \"__EA64__\");\n-      break;\n-    default:\n-       gcc_unreachable ();\n-    }\n-\n-  if (!flag_iso && cpp_get_options (pfile)->lang != CLK_ASM)\n-    {\n-      /* Define this when supporting context-sensitive keywords.  */\n-      cpp_define (pfile, \"__VECTOR_KEYWORD_SUPPORTED__\");\n-      cpp_define (pfile, \"vector=vector\");\n-\n-      /* Initialize vector keywords.  */\n-      __vector_keyword = get_identifier (\"__vector\");\n-      C_CPP_HASHNODE (__vector_keyword)->flags |= NODE_CONDITIONAL;\n-      vector_keyword = get_identifier (\"vector\");\n-      C_CPP_HASHNODE (vector_keyword)->flags |= NODE_CONDITIONAL;\n-\n-      /* Enable context-sensitive macros.  */\n-      cpp_get_callbacks (pfile)->macro_to_expand = spu_macro_to_expand;\n-    }\n-}\n-\n-void\n-spu_c_common_override_options (void)\n-{ \n-  if (!TARGET_STD_MAIN)\n-    {\n-      /* Don't give warnings about the main() function.  */\n-      warn_main = 0;\n-    }\n-}"}, {"sha": "7ce60201406410c2eee90012f2822fc74e7170a9", "filename": "gcc/config/spu/spu-elf.h", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-elf.h?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,75 +0,0 @@\n-/* Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option) \n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef OBJECT_FORMAT_ELF\n- #error elf.h included before elfos.h\n-#endif\n-\n-#define BSS_SECTION_ASM_OP \"\\t.section .bss\"\n-\n-#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n-            asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n-\n-\n-/* The following macros define \"native\" directory locations; on the SPU,\n-   these are used only when building the compiler with --with-sysroot.\n-   This can be used to build a pair of PPU and SPU cross-compilers with\n-   a common sysroot; the SPU compiler will search for its files in\n-   ${sysroot}/include and ${sysroot}/lib.  */\n-\n-/* STANDARD_STARTFILE_PREFIX_1 is \"/lib\", which we keep.\n-   STANDARD_STARTFILE_PREFIX_2 is \"/usr/lib\" -- we remove this.  */\n-#undef STANDARD_STARTFILE_PREFIX_2\n-#define STANDARD_STARTFILE_PREFIX_2 \"\"\n-\n-/* We do not provide any \"/usr/local/include\" directory on SPU.  */\n-#undef LOCAL_INCLUDE_DIR\n-\n-/* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add\n-   the GNU/Linux magical crtbegin.o file (see crtstuff.c) which\n-   provides part of the support for getting C++ file-scope static\n-   object constructed before entering `main'.  */\n-\n-#undef  STARTFILE_SPEC \n-#define STARTFILE_SPEC \"%{mstdmain: %{pg|p:gcrt2.o%s;:crt2.o%s}}\\\n-                        %{!mstdmain: %{pg|p:gcrt1.o%s;:crt1.o%s}}\\\n-                        crti.o%s crtbegin.o%s\"\n-\n-#undef  ENDFILE_SPEC\n-#define ENDFILE_SPEC   \"crtend.o%s crtn.o%s\"\n-\n-#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n-\n-#define DWARF2_DEBUGGING_INFO 1\n-#define DWARF2_ASM_LINE_DEBUG_INFO 1\n-\n-#define SET_ASM_OP\t\t\"\\t.set\\t\"\n-\n-#undef TARGET_ASM_NAMED_SECTION\n-#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section\n-\n-#define EH_FRAME_THROUGH_COLLECT2 1\n-\n-#define LINK_SPEC \"%{mlarge-mem: --defsym __stack=0xfffffff0 }\"\n-\n-#define LIB_SPEC \"-( %{!shared:%{g*:-lg}} -lc -lgloss -) \\\n-    %{mno-atomic-updates:-lgcc_cachemgr_nonatomic; :-lgcc_cachemgr} \\\n-    %{mcache-size=128:-lgcc_cache128k; \\\n-      mcache-size=64 :-lgcc_cache64k; \\\n-      mcache-size=32 :-lgcc_cache32k; \\\n-      mcache-size=16 :-lgcc_cache16k; \\\n-      mcache-size=8  :-lgcc_cache8k; \\\n-                     :-lgcc_cache64k}\""}, {"sha": "319baf675e7c52f7d12dd52c2de1ffec12abba13", "filename": "gcc/config/spu/spu-modes.def", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-modes.def?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,29 +0,0 @@\n-/* Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option) \n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Vector modes.  */\n-VECTOR_MODES (INT, 2);        /*                 V2QI */ \n-VECTOR_MODES (INT, 4);        /*            V4QI V2HI */\n-VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI */\n-VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */\n-        \n-        \n-VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */ \n-VECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */ \n-        \n-/* cse_insn needs an INT_MODE larger than WORD_MODE, otherwise some\n-   parts of it will go into an infinite loop. */\n-INT_MODE (OI, 32);"}, {"sha": "3b18d99c28e32cc147e1135cad582d8e7a62dd2b", "filename": "gcc/config/spu/spu-protos.h", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,95 +0,0 @@\n-/* Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option) \n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef _SPU_PROTOS_\n-#define _SPU_PROTOS_\n-\n-extern void spu_cpu_cpp_builtins (struct cpp_reader * pfile);\n-extern void builtin_define_std (const char *);\n-extern void spu_c_common_override_options (void);\n-extern int valid_subreg (rtx op);\n-extern void spu_expand_extv (rtx * ops, int unsignedp);\n-extern void spu_expand_insv (rtx * ops);\n-extern int spu_expand_block_move (rtx * ops);\n-extern void spu_emit_branch_or_set (int is_set, rtx cmp, rtx * operands);\n-extern int spu_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);\n-extern HOST_WIDE_INT const_double_to_hwint (rtx x);\n-extern void print_operand_address (FILE * file, register rtx addr);\n-extern void print_operand (FILE * file, rtx x, int code);\n-extern int spu_split_immediate (rtx * ops);\n-extern int spu_saved_regs_size (void);\n-extern int direct_return (void);\n-extern void spu_expand_prologue (void);\n-extern void spu_expand_epilogue (bool sibcall_p);\n-extern rtx spu_return_addr (int count, rtx frame);\n-\n-#ifdef RTX_CODE\n-extern rtx hwint_to_const_double (machine_mode mode, HOST_WIDE_INT v);\n-extern rtx spu_const (machine_mode mode, HOST_WIDE_INT val);\n-extern rtx spu_const_from_ints (machine_mode mode, \n-\t\t\t        int a, int b, int c, int d);\n-extern rtx spu_float_const (const char *string,\n-\t\t\t    machine_mode mode);\n-extern int immediate_load_p (rtx op, machine_mode mode);\n-extern int logical_immediate_p (rtx op, machine_mode mode);\n-extern int iohl_immediate_p (rtx op, machine_mode mode);\n-extern int arith_immediate_p (rtx op, machine_mode mode,\n-\t\t\t      HOST_WIDE_INT low, HOST_WIDE_INT high);\n-extern bool exp2_immediate_p (rtx op, machine_mode mode, int low,\n-\t\t\t      int high);\n-extern int spu_constant_address_p (rtx x);\n-extern bool spu_legitimate_constant_p (machine_mode, rtx);\n-extern int spu_initial_elimination_offset (int from, int to);\n-extern rtx spu_function_value (const_tree type, const_tree func);\n-extern int spu_expand_mov (rtx * ops, machine_mode mode);\n-extern int spu_split_load (rtx * ops);\n-extern int spu_split_store (rtx * ops);\n-extern int fsmbi_const_p (rtx x);\n-extern int cpat_const_p (rtx x, machine_mode mode);\n-extern rtx gen_cpat_const (rtx * ops);\n-extern void constant_to_array (machine_mode mode, rtx x,\n-\t\t\t       unsigned char *arr);\n-extern rtx array_to_constant (machine_mode mode, const unsigned char *arr);\n-extern rtx spu_gen_exp2 (machine_mode mode, rtx x);\n-extern void spu_allocate_stack (rtx op0, rtx op1);\n-extern void spu_restore_stack_nonlocal (rtx op0, rtx op1);\n-extern void spu_restore_stack_block (rtx op0, rtx op1);\n-extern rtx spu_gen_subreg (machine_mode mode, rtx x);\n-extern int spu_safe_dma(HOST_WIDE_INT channel);\n-extern void spu_builtin_splats (rtx ops[]);\n-extern void spu_builtin_extract (rtx ops[]);\n-extern void spu_builtin_insert (rtx ops[]);\n-extern void spu_builtin_promote (rtx ops[]);\n-extern void spu_expand_sign_extend (rtx ops[]);\n-extern void spu_expand_vector_init (rtx target, rtx vals);\n-extern rtx spu_legitimize_reload_address (rtx, machine_mode, int, int);\n-extern void spu_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n-\t\t\t\t  rtx orig_before, rtx orig_after);\n-#endif /* RTX_CODE  */\n-\n-extern void spu_init_expanders (void);\n-extern void spu_split_convert (rtx *);\n-extern void spu_function_profiler (FILE *, int);\n-\n-/* spu-c.c */\n-extern tree spu_resolve_overloaded_builtin (location_t, tree fndecl,\n-    \t\t\t\t\t    void *fnargs);\n-extern rtx spu_expand_builtin (tree exp, rtx target, rtx subtarget,\n-\t\t\t       machine_mode mode, int ignore);\n-extern rtx spu_expand_builtin (tree, rtx, rtx, machine_mode, int);\n-\n-#endif /* _SPU_PROTOS_  */\n-"}, {"sha": "7afd43b2a00683966ea1c31d6d059a987fd3fe8e", "filename": "gcc/config/spu/spu.c", "status": "removed", "additions": 0, "deletions": 7469, "changes": 7469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=934392185369af22fee845e4edd92c420b8c248b"}, {"sha": "4af55bd9d8d013daaf7639946395365703a3c62d", "filename": "gcc/config/spu/spu.h", "status": "removed", "additions": 0, "deletions": 517, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,517 +0,0 @@\n-/* Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option) \n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-\f\n-/* Run-time Target */\n-#define TARGET_CPU_CPP_BUILTINS()\tspu_cpu_cpp_builtins(pfile)\n-\n-#define C_COMMON_OVERRIDE_OPTIONS spu_c_common_override_options()\n-\n-#define INIT_EXPANDERS spu_init_expanders()\n-\n-/* Which processor to generate code or schedule for.  */\n-enum processor_type\n-{\n-  PROCESSOR_CELL,\n-  PROCESSOR_CELLEDP\n-};\n-\n-extern GTY(()) int spu_arch;\n-extern GTY(()) int spu_tune;\n-\n-/* Support for a compile-time default architecture and tuning.  The rules are:\n-   --with-arch is ignored if -march is specified.\n-   --with-tune is ignored if -mtune is specified.  */\n-#define OPTION_DEFAULT_SPECS \\\n-  {\"arch\", \"%{!march=*:-march=%(VALUE)}\" }, \\\n-  {\"tune\", \"%{!mtune=*:-mtune=%(VALUE)}\" }\n-\n-/* Default target_flags if no switches specified.  */\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT (MASK_ERROR_RELOC | MASK_SAFE_DMA | MASK_BRANCH_HINTS \\\n-\t\t\t| MASK_SAFE_HINTS | MASK_ADDRESS_SPACE_CONVERSION)\n-#endif\n-\n-\f\n-/* Storage Layout */\n-\n-#define BITS_BIG_ENDIAN 1\n-\n-#define BYTES_BIG_ENDIAN 1\n-\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* GCC uses word_mode in many places, assuming that it is the fastest\n-   integer mode.  That is not the case for SPU though.  We can't use\n-   32 here because (of some reason I can't remember.) */\n-#define BITS_PER_WORD 128\n-\n-#define UNITS_PER_WORD (BITS_PER_WORD/BITS_PER_UNIT)\n-\n-/* When building libgcc, we need to assume 4 words per units even\n-   though UNITS_PER_WORD is 16, because the SPU has basically a 32-bit\n-   instruction set although register size is 128 bits.  In particular,\n-   this causes libgcc to contain __divdi3 instead of __divti3 etc.\n-   However, we allow this default to be re-defined on the command\n-   line, so that we can use the LIB2_SIDITI_CONV_FUNCS mechanism\n-   to get (in addition) TImode versions of some routines.  */\n-#ifndef LIBGCC2_UNITS_PER_WORD\n-#define LIBGCC2_UNITS_PER_WORD 4\n-#endif\n-\n-#define POINTER_SIZE 32\n-\n-#define PARM_BOUNDARY 128\n-\n-#define STACK_BOUNDARY 128\n-\n-/* We want it 8-byte aligned so we can properly use dual-issue\n-   instructions, which can only happen on an 8-byte aligned address. */\n-#define FUNCTION_BOUNDARY 64\n-\n-/* We would like to allow a larger alignment for data objects (for DMA)\n-   but the aligned attribute is limited by BIGGEST_ALIGNMENT.  We don't\n-   define BIGGEST_ALIGNMENT as larger because it is used in other places\n-   and would end up wasting space.  (Is this still true?)  */\n-#define BIGGEST_ALIGNMENT 128\n-\n-#define MINIMUM_ATOMIC_ALIGNMENT 128\n-\n-/* Make all static objects 16-byte aligned.  This allows us to assume\n-   they are also padded to 16-bytes, which means we can use a single\n-   load or store instruction to access them.  Do the same for objects\n-   on the stack.  (Except a bug (?) allows some stack objects to be\n-   unaligned.)  */\n-#define DATA_ALIGNMENT(TYPE,ALIGN) ((ALIGN) > 128 ? (ALIGN) : 128)\n-#define LOCAL_ALIGNMENT(TYPE,ALIGN) ((ALIGN) > 128 ? (ALIGN) : 128)\n-\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-#define STRICT_ALIGNMENT 1\n-\n-/* symbol_ref's of functions are not aligned to 16 byte boundary. */\n-#define ALIGNED_SYMBOL_REF_P(X) \\\n-\t(GET_CODE (X) == SYMBOL_REF \\\n-          && (SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_ALIGN1) == 0 \\\n-\t  && (! SYMBOL_REF_FUNCTION_P (X) \\\n-\t      || align_functions.levels[0].get_value () >= 16))\n-\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-#define MAX_FIXED_MODE_SIZE 128\n-\n-#define STACK_SAVEAREA_MODE(save_level) \\\n-  (save_level == SAVE_FUNCTION ? VOIDmode \\\n-    : save_level == SAVE_NONLOCAL ? SImode \\\n-      : Pmode)\n-\n-#define STACK_SIZE_MODE SImode\n-\n-\f\n-/* Type Layout */\n-\n-#define INT_TYPE_SIZE 32\n-\n-#define LONG_TYPE_SIZE 32\n-\n-#define LONG_LONG_TYPE_SIZE 64\n-\n-#define FLOAT_TYPE_SIZE 32\n-\n-#define DOUBLE_TYPE_SIZE 64\n-\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-#define DEFAULT_SIGNED_CHAR 0\n-\n-#define STDINT_LONG32 0\n-\n-\f\n-/* Register Basics */\n-\n-/* 128-130 are special registers that never appear in assembly code. */\n-#define FIRST_PSEUDO_REGISTER 131\n-\n-#define FIXED_REGISTERS {\t\t\t    \\\n-    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    1, 1, 1 \\\n-}\n-\n-#define CALL_USED_REGISTERS {\t\t\t    \\\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    1, 1, 1 \\\n-}\n-\n-\f\n-/* Register Classes */\n-\n-enum reg_class { \n-   NO_REGS, \n-   GENERAL_REGS,\n-   ALL_REGS,\n-   LIM_REG_CLASSES \n-};\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-#define REG_CLASS_NAMES \\\n-{  \"NO_REGS\", \\\n-   \"GENERAL_REGS\", \\\n-   \"ALL_REGS\" \\\n-}\n-\n-#define REG_CLASS_CONTENTS { \\\n-    {0, 0, 0, 0, 0}, /* no regs */ \\\n-    {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x3}, /* general regs */ \\\n-    {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x3}} /* all regs */\n-\n-#define REGNO_REG_CLASS(REGNO) ((void)(REGNO), GENERAL_REGS)\n-\n-\n-#define BASE_REG_CLASS GENERAL_REGS\n-\n-#define INDEX_REG_CLASS GENERAL_REGS\n-\n-#define REGNO_OK_FOR_BASE_P(regno) \\\n-   ((regno) < FIRST_PSEUDO_REGISTER || (regno > LAST_VIRTUAL_REGISTER && reg_renumber[regno] >= 0))\n-\n-#define REGNO_OK_FOR_INDEX_P(regno)  \\\n-   ((regno) < FIRST_PSEUDO_REGISTER || (regno > LAST_VIRTUAL_REGISTER && reg_renumber[regno] >= 0))\n-\n-#define INT_REG_OK_FOR_INDEX_P(X,STRICT) \\\n-\t((!(STRICT) || REGNO_OK_FOR_INDEX_P (REGNO (X))))\n-#define INT_REG_OK_FOR_BASE_P(X,STRICT) \\\n-\t((!(STRICT) || REGNO_OK_FOR_BASE_P (REGNO (X))))\n-\n-#define REGISTER_TARGET_PRAGMAS() do {\t\t\t\t\t\\\n-c_register_addr_space (\"__ea\", ADDR_SPACE_EA);\t\t\t\t\\\n-targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n-}while (0)\n-\n-\f\n-/* Frame Layout */\n-\n-#define STACK_GROWS_DOWNWARD 1\n-\n-#define FRAME_GROWS_DOWNWARD 1\n-\n-#define STACK_POINTER_OFFSET 32\n-\n-#define FIRST_PARM_OFFSET(FNDECL) (0)\n-\n-#define DYNAMIC_CHAIN_ADDRESS(FP) plus_constant (Pmode, (FP), -16)\n-\n-#define RETURN_ADDR_RTX(COUNT,FP) (spu_return_addr (COUNT, FP))\n-\n-/* Should this be defined?  Would it simplify our implementation. */\n-/* #define RETURN_ADDR_IN_PREVIOUS_FRAME */\n-\n-#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG(Pmode, LINK_REGISTER_REGNUM)\n-\n-#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (LINK_REGISTER_REGNUM)\n-\n-#define ARG_POINTER_CFA_OFFSET(FNDECL) \\\n-  (crtl->args.pretend_args_size - STACK_POINTER_OFFSET)\n-\n-\f\n-/* Stack Checking */\n-\n-/* We store the Available Stack Size in the second slot of the stack\n-   register.   We emit stack checking code during the prologue.  */\n-#define STACK_CHECK_BUILTIN 1\n-\n-\f\n-/* Frame Registers, and other registers */\n-\n-#define STACK_POINTER_REGNUM 1\n-\n-/* Will be eliminated. */\n-#define FRAME_POINTER_REGNUM 128\n-\n-/* This is not specified in any ABI, so could be set to anything. */\n-#define HARD_FRAME_POINTER_REGNUM 127\n-\n-/* Will be eliminated. */\n-#define ARG_POINTER_REGNUM 129\n-\n-#define STATIC_CHAIN_REGNUM 2\n-\n-#define LINK_REGISTER_REGNUM 0\n-\n-/* Used to keep track of instructions that have clobbered the hint\n- * buffer.  Users can also specify it in inline asm. */\n-#define HBR_REGNUM 130\n-\n-#define MAX_REGISTER_ARGS    72\n-#define FIRST_ARG_REGNUM     3\n-#define LAST_ARG_REGNUM      (FIRST_ARG_REGNUM + MAX_REGISTER_ARGS - 1)\n-\n-#define MAX_REGISTER_RETURN  72\n-#define FIRST_RETURN_REGNUM  3\n-#define LAST_RETURN_REGNUM   (FIRST_RETURN_REGNUM + MAX_REGISTER_RETURN - 1)\n-\n-\f\n-/* Elimination */\n-\n-#define ELIMINABLE_REGS  \\\n-  {{ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM},\t\t\t\t\\\n-  {ARG_POINTER_REGNUM,\t HARD_FRAME_POINTER_REGNUM},\t\t\t\\\n-  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n-  {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n-  ((OFFSET) = spu_initial_elimination_offset((FROM),(TO)))\n-\n-\f\n-/* Stack Arguments */\n-\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-#define REG_PARM_STACK_SPACE(FNDECL) 0\n-\n-#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n-\n-\f\n-/* Register Arguments */\n-\n-#define CUMULATIVE_ARGS int\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS) \\\n-\t\t((CUM) = 0)\n-\n-#define PAD_VARARGS_DOWN 0\n-\n-#define FUNCTION_ARG_REGNO_P(N) ((N) >= (FIRST_ARG_REGNUM) && (N) <= (LAST_ARG_REGNUM))\n-\f\n-/* Scalar Return */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-        (spu_function_value((VALTYPE),(FUNC)))\n-\n-#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, FIRST_RETURN_REGNUM)\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) >= (FIRST_RETURN_REGNUM) && (N) <= (LAST_RETURN_REGNUM))\n-\n-\f\n-/* Machine-specific symbol_ref flags.  */\n-#define SYMBOL_FLAG_ALIGN1\t(SYMBOL_FLAG_MACH_DEP << 0)\n-\f\n-/* Aggregate Return */\n-\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-\f\n-/* Function Entry */\n-\n-#define EXIT_IGNORE_STACK 0\n-\n-#define EPILOGUE_USES(REGNO) ((REGNO)==1 ? 1 : 0)\n-\n-\f\n-/* Profiling */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-  spu_function_profiler ((FILE), (LABELNO));\n-\n-#define NO_PROFILE_COUNTERS 1\n-\n-#define PROFILE_BEFORE_PROLOGUE 1\n-\n-\f\n-/* Trampolines */\n-\n-#define TRAMPOLINE_SIZE (TARGET_LARGE_MEM ? 20 : 16)\n-\n-#define TRAMPOLINE_ALIGNMENT 128\n-\f\n-/* Addressing Modes */\n-\n-#define CONSTANT_ADDRESS_P(X)   spu_constant_address_p(X)\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-#define LEGITIMIZE_RELOAD_ADDRESS(AD, MODE, OPNUM, TYPE, IND, WIN)\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  rtx new_rtx = spu_legitimize_reload_address (AD, MODE, OPNUM,\t\t\\\n-\t\t\t\t\t       (int)(TYPE));\t\t\\\n-  if (new_rtx)\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      (AD) = new_rtx;\t\t\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-\f\n-/* Costs */\n-\n-#define BRANCH_COST(speed_p, predictable_p) spu_branch_cost\n-\n-#define SLOW_BYTE_ACCESS 0\n-\n-#define MOVE_RATIO(speed) ((speed)? 32 : 4)\n-\n-#define NO_FUNCTION_CSE 1\n-\n-\f\n-/* Sections */\n-\n-#define TEXT_SECTION_ASM_OP \".text\"\n-\n-#define DATA_SECTION_ASM_OP \".data\"\n-\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n-\n-\f\n-/* PIC */\n-#define PIC_OFFSET_TABLE_REGNUM 126\n-\n-\f\n-/* File Framework */\n-\n-#define ASM_APP_ON \"\"\n-\n-#define ASM_APP_OFF \"\"\n-\n-\f\n-/* Uninitialized Data */\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%d\\n\", (ROUNDED)))\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".lcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%d\\n\", (ROUNDED)))\n-\n-\f\n-/* Label Output */\n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n-\n-#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n-  asm_fprintf (FILE, \"%U%s\", default_strip_name_encoding (NAME))\n-\n-#define ASM_OUTPUT_SYMBOL_REF(FILE, X) \\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      tree decl;\t\t\t\t\t\\\n-      assemble_name (FILE, XSTR ((X), 0));\t\t\\\n-      if ((decl = SYMBOL_REF_DECL ((X))) != 0\t\t\\\n-\t  && TREE_CODE (decl) == VAR_DECL\t\t\\\n-\t  && TYPE_ADDR_SPACE (TREE_TYPE (decl)))\t\\\n-\tfputs (\"@ppu\", FILE);\t\t\t\t\\\n-    } while (0)\n-\n-\f\n-/* Instruction Output */\n-#define REGISTER_NAMES \\\n-{\"$lr\", \"$sp\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\", \"$9\", \"$10\", \"$11\", \"$12\", \"$13\", \"$14\", \"$15\", \\\n- \"$16\", \"$17\", \"$18\", \"$19\", \"$20\", \"$21\", \"$22\", \"$23\", \"$24\", \"$25\", \"$26\", \"$27\", \"$28\", \"$29\", \"$30\", \"$31\", \\\n- \"$32\", \"$33\", \"$34\", \"$35\", \"$36\", \"$37\", \"$38\", \"$39\", \"$40\", \"$41\", \"$42\", \"$43\", \"$44\", \"$45\", \"$46\", \"$47\", \\\n- \"$48\", \"$49\", \"$50\", \"$51\", \"$52\", \"$53\", \"$54\", \"$55\", \"$56\", \"$57\", \"$58\", \"$59\", \"$60\", \"$61\", \"$62\", \"$63\", \\\n- \"$64\", \"$65\", \"$66\", \"$67\", \"$68\", \"$69\", \"$70\", \"$71\", \"$72\", \"$73\", \"$74\", \"$75\", \"$76\", \"$77\", \"$78\", \"$79\", \\\n- \"$80\", \"$81\", \"$82\", \"$83\", \"$84\", \"$85\", \"$86\", \"$87\", \"$88\", \"$89\", \"$90\", \"$91\", \"$92\", \"$93\", \"$94\", \"$95\", \\\n- \"$96\", \"$97\", \"$98\", \"$99\", \"$100\", \"$101\", \"$102\", \"$103\", \"$104\", \"$105\", \"$106\", \"$107\", \"$108\", \"$109\", \"$110\", \"$111\", \\\n- \"$112\", \"$113\", \"$114\", \"$115\", \"$116\", \"$117\", \"$118\", \"$119\", \"$120\", \"$121\", \"$122\", \"$123\", \"$124\", \"$125\", \"$126\", \"$127\", \\\n- \"$vfp\", \"$vap\", \"hbr\" \\\n-}\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE, X, CODE)\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n- print_operand_address (FILE, ADDR)\n-\n-#define LOCAL_LABEL_PREFIX \".\"\n-\n-#define USER_LABEL_PREFIX \"\"\n-\n-#define ASM_COMMENT_START \"#\"\n-\n-\f\n-/* Dispatch Tables */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.word .L%d\\n\", VALUE)\n-\n-\f\n-/* Alignment Output */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n-  do { if (LOG!=0) fprintf (FILE, \"\\t.align\\t%d\\n\", (LOG)); } while (0)\n-\n-\f\n-/* Misc */\n-\n-#define CASE_VECTOR_MODE SImode\n-\n-#define MOVE_MAX 16 \n-\n-#define STORE_FLAG_VALUE -1\n-\n-#define Pmode SImode\n-\n-#define FUNCTION_MODE QImode\n-\n-\n-/* Address spaces.  */\n-#define ADDR_SPACE_EA\t1\n-\n-\n-/* Builtins.  */\n-\n-enum spu_builtin_type\n-{\n-  B_INSN,\n-  B_JUMP,\n-  B_BISLED,\n-  B_CALL,\n-  B_HINT,\n-  B_OVERLOAD,\n-  B_INTERNAL\n-};\n-\n-struct spu_builtin_description\n-{\n-  int fcode;\n-  int icode;\n-  const char *name;\n-  enum spu_builtin_type type;\n-\n-  /* The first element of parm is always the return type.  The rest\n-     are a zero terminated list of parameters.  */\n-  int parm[5];\n-};\n-\n-extern struct spu_builtin_description spu_builtins[];\n-"}, {"sha": "bb622981abd9339e2cdd435825737af737e03238", "filename": "gcc/config/spu/spu.md", "status": "removed", "additions": 0, "deletions": 5255, "changes": 5255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=934392185369af22fee845e4edd92c420b8c248b"}, {"sha": "9eb18cc2fe1407a1cdc897a26aba3fd38e127301", "filename": "gcc/config/spu/spu.opt", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.opt?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,105 +0,0 @@\n-; Options for the SPU port of the compiler\n-; Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-; This file is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3 of the License, or (at your option)\n-; any later version.\n-\n-; This file is distributed in the hope that it will be useful, but WITHOUT\n-; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-mwarn-reloc\n-Target Report Mask(WARN_RELOC)\n-Emit warnings when run-time relocations are generated.\n-\n-merror-reloc\n-Target Report Mask(ERROR_RELOC)\n-Emit errors when run-time relocations are generated.\n-\n-mbranch-cost=\n-Target RejectNegative Joined UInteger Var(spu_branch_cost) Init(20)\n-Specify cost of branches (Default 20).\n-\n-msafe-dma\n-Target Report RejectNegative Mask(SAFE_DMA)\n-Make sure loads and stores are not moved past DMA instructions.\n-\n-munsafe-dma\n-Target Report RejectNegative InverseMask(SAFE_DMA)\n-volatile must be specified on any memory that is effected by DMA.\n-\n-mdual-nops\n-Target Report Var(spu_dual_nops,10) Init(10)\n-Insert nops when it might improve performance by allowing dual issue (default).\n-\n-mdual-nops=\n-Target RejectNegative Joined UInteger Var(spu_dual_nops)\n-Insert nops when it might improve performance by allowing dual issue (default).\n-\n-mstdmain\n-Target Report Mask(STD_MAIN)\n-Use standard main function as entry for startup.\n-\n-mbranch-hints\n-Target Report Mask(BRANCH_HINTS)\n-Generate branch hints for branches.\n-\n-mhint-max-nops=\n-Target RejectNegative Joined UInteger Var(spu_max_nops) Init(2)\n-Maximum number of nops to insert for a hint (Default 2).\n-\n-mhint-max-distance=\n-Target RejectNegative Joined Var(spu_max_distance_str)\n-Approximate maximum number of instructions to allow between a hint and its branch [125].\n-\n-msmall-mem\n-Target Report RejectNegative InverseMask(LARGE_MEM)\n-Generate code for 18 bit addressing.\n-\n-mlarge-mem\n-Target Report RejectNegative Mask(LARGE_MEM)\n-Generate code for 32 bit addressing.\n-\n-mfixed-range=\n-Target RejectNegative Joined Var(spu_fixed_range_string)\n-Specify range of registers to make fixed.\n-\n-msafe-hints\n-Target Report Mask(SAFE_HINTS)\n-Insert hbrp instructions after hinted branch targets to avoid the SPU hang issue.\n-\n-march=\n-Target RejectNegative Joined Var(spu_arch_string)\n-Generate code for given CPU.\n-\n-mtune=\n-Target RejectNegative Joined Var(spu_tune_string)\n-Schedule code for given CPU.\n-\n-mea32\n-Target Report RejectNegative Var(spu_ea_model,32) Init(32)\n-Access variables in 32-bit PPU objects (default).\n-\n-mea64\n-Target Report RejectNegative Var(spu_ea_model,64)\n-Access variables in 64-bit PPU objects.\n-\n-maddress-space-conversion\n-Target Report Mask(ADDRESS_SPACE_CONVERSION)\n-Allow conversions between __ea and generic pointers (default).\n-\n-mcache-size=\n-Target Report RejectNegative Joined UInteger\n-Size (in KB) of software data cache.\n-\n-matomic-updates\n-Target Report\n-Atomically write back software data cache lines (default).\n-"}, {"sha": "cb6fe312a37f495db69efc24db963461dc5d169a", "filename": "gcc/config/spu/spu_cache.h", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu_cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu_cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu_cache.h?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,39 +0,0 @@\n-/* Copyright (C) 2008-2019 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef _SPU_CACHE_H\n-#define _SPU_CACHE_H\n-\n-void *__cache_fetch_dirty (__ea void *ea, int n_bytes_dirty);\n-void *__cache_fetch (__ea void *ea);\n-void __cache_evict (__ea void *ea);\n-void __cache_flush (void);\n-void __cache_touch (__ea void *ea);\n-\n-#define cache_fetch_dirty(_ea, _n_bytes_dirty) \\\n-     __cache_fetch_dirty(_ea, _n_bytes_dirty)\n-\n-#define cache_fetch(_ea) __cache_fetch(_ea)\n-#define cache_touch(_ea) __cache_touch(_ea)\n-#define cache_evict(_ea) __cache_evict(_ea)\n-#define cache_flush() __cache_flush()\n-\n-#endif"}, {"sha": "fb23b4a9ed74b01afcfb3dde7dd79466751b29fe", "filename": "gcc/config/spu/spu_internals.h", "status": "removed", "additions": 0, "deletions": 421, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu_internals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu_internals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu_internals.h?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,421 +0,0 @@\n-/* Definitions of Synergistic Processing Unit (SPU). */\n-/* Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option) \n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef  _SPU_INTERNALS_H\n-#define _SPU_INTERNALS_H \n- \n-/* For a typical GCC implementation, the vector keyword is defined here\n- * as a macro.  If this macro conflicts with user code the user needs to\n- * undefine it.  An extended GCC implementation may implement this\n- * keyword differently, such that it never conflicts,  and will define\n- * the macro __VECTOR_KEYWORD_SUPPORTED__. */\n-#ifndef __VECTOR_KEYWORD_SUPPORTED__\n-#define vector __vector\n-#endif\n-\n-\n-/*  The spu specific instruction macros, si_*(), correspond 1-1 with\n- *  SPU instructions in the ISA.  The arguments are the same with the\n- *  following exceptions:\n- *   -  any instruction which both reads and writes rt will have an\n- *      extra parameter in the macro.\n- *   -  instructions which append zero to the immediate field assume\n- *      the value given in a macro already has the zeroes appended.\n- *   -  integer/float convert functions expect a value from 0 to 127,\n- *      i.e., the bias is added by the compiler.\n- *\n- *  Parameters named 'imm' accept an integer literal.\n- *  Parameters named 'r[abcdt]' accept a qword argument.\n- *  Parameters named 'scalar' accept a scalar argument.\n- */\n-\n-#define qword __vector signed char\n-\n-#define si_lqd(ra,imm)       __builtin_si_lqd(ra,imm)\n-#define si_lqx(ra,rb)        __builtin_si_lqx(ra,rb)\n-#define si_lqa(imm)          __builtin_si_lqa(imm)\n-#define si_lqr(imm)          __builtin_si_lqr(imm)\n-#define si_stqd(rt,ra,imm)   __builtin_si_stqd(rt,ra,imm)\n-#define si_stqx(rt,ra,rb)    __builtin_si_stqx(rt,ra,rb)\n-#define si_stqa(rt,imm)      __builtin_si_stqa(rt,imm)\n-#define si_stqr(rt,imm)      __builtin_si_stqr(rt,imm)\n-#define si_cbd(ra,imm)       __builtin_si_cbd(ra,imm)\n-#define si_cbx(ra,rb)        __builtin_si_cbx(ra,rb)\n-#define si_chd(ra,imm)       __builtin_si_chd(ra,imm)\n-#define si_chx(ra,rb)        __builtin_si_chx(ra,rb)\n-#define si_cwd(ra,imm)       __builtin_si_cwd(ra,imm)\n-#define si_cwx(ra,rb)        __builtin_si_cwx(ra,rb)\n-#define si_cdd(ra,imm)       __builtin_si_cdd(ra,imm)\n-#define si_cdx(ra,rb)        __builtin_si_cdx(ra,rb)\n-#define si_ilh(imm)          __builtin_si_ilh(imm)\n-#define si_ilhu(imm)         __builtin_si_ilhu(imm)\n-#define si_il(imm)           __builtin_si_il(imm)\n-#define si_ila(imm)          __builtin_si_ila(imm)\n-#define si_iohl(ra,imm)      __builtin_si_iohl(ra,imm)\n-#define si_fsmbi(imm)        __builtin_si_fsmbi(imm)\n-#define si_ah(ra,rb)         __builtin_si_ah(ra,rb)\n-#define si_ahi(ra,imm)       __builtin_si_ahi(ra,imm)\n-#define si_a(ra,rb)          __builtin_si_a(ra,rb)\n-#define si_ai(ra,imm)        __builtin_si_ai(ra,imm)\n-#define si_addx(ra,rb,rt)    __builtin_si_addx(ra,rb,rt)\n-#define si_cg(ra,rb)         __builtin_si_cg(ra,rb)\n-#define si_cgx(ra,rb,rt)     __builtin_si_cgx(ra,rb,rt)\n-#define si_sfh(ra,rb)        __builtin_si_sfh(ra,rb)\n-#define si_sfhi(imm,ra)      __builtin_si_sfhi(imm,ra)\n-#define si_sf(ra,rb)         __builtin_si_sf(ra,rb)\n-#define si_sfi(ra,imm)       __builtin_si_sfi(ra,imm)\n-#define si_sfx(ra,rb,rt)     __builtin_si_sfx(ra,rb,rt)\n-#define si_bg(ra,rb)         __builtin_si_bg(ra,rb)\n-#define si_bgx(ra,rb,rt)     __builtin_si_bgx(ra,rb,rt)\n-#define si_mpy(ra,rb)        __builtin_si_mpy(ra,rb)\n-#define si_mpyu(ra,rb)       __builtin_si_mpyu(ra,rb)\n-#define si_mpyi(ra,imm)      __builtin_si_mpyi(ra,imm)\n-#define si_mpyui(ra,imm)     __builtin_si_mpyui(ra,imm)\n-#define si_mpya(ra,rb,rc)    __builtin_si_mpya(ra,rb,rc)\n-#define si_mpyh(ra,rb)       __builtin_si_mpyh(ra,rb)\n-#define si_mpys(ra,rb)       __builtin_si_mpys(ra,rb)\n-#define si_mpyhh(ra,rb)      __builtin_si_mpyhh(ra,rb)\n-#define si_mpyhhu(ra,rb)     __builtin_si_mpyhhu(ra,rb)\n-#define si_mpyhha(ra,rb,rc)  __builtin_si_mpyhha(ra,rb,rc)\n-#define si_mpyhhau(ra,rb,rc) __builtin_si_mpyhhau(ra,rb,rc)\n-#define si_clz(ra)           __builtin_si_clz(ra)\n-#define si_cntb(ra)          __builtin_si_cntb(ra)\n-#define si_fsmb(ra)          __builtin_si_fsmb(ra)\n-#define si_fsmh(ra)          __builtin_si_fsmh(ra)\n-#define si_fsm(ra)           __builtin_si_fsm(ra)\n-#define si_gbb(ra)           __builtin_si_gbb(ra)\n-#define si_gbh(ra)           __builtin_si_gbh(ra)\n-#define si_gb(ra)            __builtin_si_gb(ra)\n-#define si_avgb(ra,rb)       __builtin_si_avgb(ra,rb)\n-#define si_absdb(ra,rb)      __builtin_si_absdb(ra,rb)\n-#define si_sumb(ra,rb)       __builtin_si_sumb(ra,rb)\n-#define si_xsbh(ra)          __builtin_si_xsbh(ra)\n-#define si_xshw(ra)          __builtin_si_xshw(ra)\n-#define si_xswd(ra)          __builtin_si_xswd(ra)\n-#define si_and(ra,rb)        __builtin_si_and(ra,rb)\n-#define si_andc(ra,rb)       __builtin_si_andc(ra,rb)\n-#define si_andbi(ra,imm)     __builtin_si_andbi(ra,imm)\n-#define si_andhi(ra,imm)     __builtin_si_andhi(ra,imm)\n-#define si_andi(ra,imm)      __builtin_si_andi(ra,imm)\n-#define si_or(ra,rb)         __builtin_si_or(ra,rb)\n-#define si_orc(ra,rb)        __builtin_si_orc(ra,rb)\n-#define si_orbi(ra,imm)      __builtin_si_orbi(ra,imm)\n-#define si_orhi(ra,imm)      __builtin_si_orhi(ra,imm)\n-#define si_ori(ra,imm)       __builtin_si_ori(ra,imm)\n-#define si_orx(ra)           __builtin_si_orx(ra)\n-#define si_xor(ra,rb)        __builtin_si_xor(ra,rb)\n-#define si_xorbi(ra,imm)     __builtin_si_xorbi(ra,imm)\n-#define si_xorhi(ra,imm)     __builtin_si_xorhi(ra,imm)\n-#define si_xori(ra,imm)      __builtin_si_xori(ra,imm)\n-#define si_nand(ra,rb)       __builtin_si_nand(ra,rb)\n-#define si_nor(ra,rb)        __builtin_si_nor(ra,rb)\n-#define si_eqv(ra,rb)        __builtin_si_eqv(ra,rb)\n-#define si_selb(ra,rb,rc)    __builtin_si_selb(ra,rb,rc)\n-#define si_shufb(ra,rb,rc)   __builtin_si_shufb(ra,rb,rc)\n-#define si_shlh(ra,rb)       __builtin_si_shlh(ra,rb)\n-#define si_shlhi(ra,imm)     __builtin_si_shlhi(ra,imm)\n-#define si_shl(ra,rb)        __builtin_si_shl(ra,rb)\n-#define si_shli(ra,imm)      __builtin_si_shli(ra,imm)\n-#define si_shlqbi(ra,rb)     __builtin_si_shlqbi(ra,rb)\n-#define si_shlqbii(ra,imm)   __builtin_si_shlqbii(ra,imm)\n-#define si_shlqby(ra,rb)     __builtin_si_shlqby(ra,rb)\n-#define si_shlqbyi(ra,imm)   __builtin_si_shlqbyi(ra,imm)\n-#define si_shlqbybi(ra,rb)   __builtin_si_shlqbybi(ra,rb)\n-#define si_roth(ra,rb)       __builtin_si_roth(ra,rb)\n-#define si_rothi(ra,imm)     __builtin_si_rothi(ra,imm)\n-#define si_rot(ra,rb)        __builtin_si_rot(ra,rb)\n-#define si_roti(ra,imm)      __builtin_si_roti(ra,imm)\n-#define si_rotqby(ra,rb)     __builtin_si_rotqby(ra,rb)\n-#define si_rotqbyi(ra,imm)   __builtin_si_rotqbyi(ra,imm)\n-#define si_rotqbybi(ra,rb)   __builtin_si_rotqbybi(ra,rb)\n-#define si_rotqbi(ra,rb)     __builtin_si_rotqbi(ra,rb)\n-#define si_rotqbii(ra,imm)   __builtin_si_rotqbii(ra,imm)\n-#define si_rothm(ra,rb)      __builtin_si_rothm(ra,rb)\n-#define si_rothmi(ra,imm)    __builtin_si_rothmi(ra,imm)\n-#define si_rotm(ra,rb)       __builtin_si_rotm(ra,rb)\n-#define si_rotmi(ra,imm)     __builtin_si_rotmi(ra,imm)\n-#define si_rotqmby(ra,rb)    __builtin_si_rotqmby(ra,rb)\n-#define si_rotqmbyi(ra,imm)  __builtin_si_rotqmbyi(ra,imm)\n-#define si_rotqmbi(ra,rb)    __builtin_si_rotqmbi(ra,rb)\n-#define si_rotqmbii(ra,imm)  __builtin_si_rotqmbii(ra,imm)\n-#define si_rotqmbybi(ra,rb)  __builtin_si_rotqmbybi(ra,rb)\n-#define si_rotmah(ra,rb)     __builtin_si_rotmah(ra,rb)\n-#define si_rotmahi(ra,imm)   __builtin_si_rotmahi(ra,imm)\n-#define si_rotma(ra,rb)      __builtin_si_rotma(ra,rb)\n-#define si_rotmai(ra,imm)    __builtin_si_rotmai(ra,imm)\n-#define si_heq(ra,rb)        __builtin_si_heq(ra,rb)\n-#define si_heqi(ra,imm)      __builtin_si_heqi(ra,imm)\n-#define si_hgt(ra,rb)        __builtin_si_hgt(ra,rb)\n-#define si_hgti(ra,imm)      __builtin_si_hgti(ra,imm)\n-#define si_hlgt(ra,rb)       __builtin_si_hlgt(ra,rb)\n-#define si_hlgti(ra,imm)     __builtin_si_hlgti(ra,imm)\n-#define si_ceqb(ra,rb)       __builtin_si_ceqb(ra,rb)\n-#define si_ceqbi(ra,imm)     __builtin_si_ceqbi(ra,imm)\n-#define si_ceqh(ra,rb)       __builtin_si_ceqh(ra,rb)\n-#define si_ceqhi(ra,imm)     __builtin_si_ceqhi(ra,imm)\n-#define si_ceq(ra,rb)        __builtin_si_ceq(ra,rb)\n-#define si_ceqi(ra,imm)      __builtin_si_ceqi(ra,imm)\n-#define si_cgtb(ra,rb)       __builtin_si_cgtb(ra,rb)\n-#define si_cgtbi(ra,imm)     __builtin_si_cgtbi(ra,imm)\n-#define si_cgth(ra,rb)       __builtin_si_cgth(ra,rb)\n-#define si_cgthi(ra,imm)     __builtin_si_cgthi(ra,imm)\n-#define si_cgt(ra,rb)        __builtin_si_cgt(ra,rb)\n-#define si_cgti(ra,imm)      __builtin_si_cgti(ra,imm)\n-#define si_clgtb(ra,rb)      __builtin_si_clgtb(ra,rb)\n-#define si_clgtbi(ra,imm)    __builtin_si_clgtbi(ra,imm)\n-#define si_clgth(ra,rb)      __builtin_si_clgth(ra,rb)\n-#define si_clgthi(ra,imm)    __builtin_si_clgthi(ra,imm)\n-#define si_clgt(ra,rb)       __builtin_si_clgt(ra,rb)\n-#define si_clgti(ra,imm)     __builtin_si_clgti(ra,imm)\n-#define si_bisled(ra)        __builtin_si_bisled(ra,0)\n-#define si_bisledd(ra)       __builtin_si_bisledd(ra,0)\n-#define si_bislede(ra)       __builtin_si_bislede(ra,0)\n-#define si_fa(ra,rb)         __builtin_si_fa(ra,rb)\n-#define si_dfa(ra,rb)        __builtin_si_dfa(ra,rb)\n-#define si_fs(ra,rb)         __builtin_si_fs(ra,rb)\n-#define si_dfs(ra,rb)        __builtin_si_dfs(ra,rb)\n-#define si_fm(ra,rb)         __builtin_si_fm(ra,rb)\n-#define si_dfm(ra,rb)        __builtin_si_dfm(ra,rb)\n-#define si_fma(ra,rb,rc)     __builtin_si_fma(ra,rb,rc)\n-#define si_dfma(ra,rb,rc)    __builtin_si_dfma(ra,rb,rc)\n-#define si_dfnma(ra,rb,rc)   __builtin_si_dfnma(ra,rb,rc)\n-#define si_fnms(ra,rb,rc)    __builtin_si_fnms(ra,rb,rc)\n-#define si_dfnms(ra,rb,rc)   __builtin_si_dfnms(ra,rb,rc)\n-#define si_fms(ra,rb,rc)     __builtin_si_fms(ra,rb,rc)\n-#define si_dfms(ra,rb,rc)    __builtin_si_dfms(ra,rb,rc)\n-#define si_frest(ra)         __builtin_si_frest(ra)\n-#define si_frsqest(ra)       __builtin_si_frsqest(ra)\n-#define si_fi(ra,rb)         __builtin_si_fi(ra,rb)\n-#define si_csflt(ra,imm)     __builtin_si_csflt(ra,imm)\n-#define si_cflts(ra,imm)     __builtin_si_cflts(ra,imm)\n-#define si_cuflt(ra,imm)     __builtin_si_cuflt(ra,imm)\n-#define si_cfltu(ra,imm)     __builtin_si_cfltu(ra,imm)\n-#define si_frds(ra)          __builtin_si_frds(ra)\n-#define si_fesd(ra)          __builtin_si_fesd(ra)\n-#define si_fceq(ra,rb)       __builtin_si_fceq(ra,rb)\n-#define si_fcmeq(ra,rb)      __builtin_si_fcmeq(ra,rb)\n-#define si_fcgt(ra,rb)       __builtin_si_fcgt(ra,rb)\n-#define si_fcmgt(ra,rb)      __builtin_si_fcmgt(ra,rb)\n-#define si_stop(imm)         __builtin_si_stop(imm)\n-#define si_stopd(ra,rb,rc)   __builtin_si_stopd(ra,rb,rc)\n-#define si_lnop()            __builtin_si_lnop()\n-#define si_nop()             __builtin_si_nop()\n-#define si_sync()            __builtin_si_sync()\n-#define si_syncc()           __builtin_si_syncc()\n-#define si_dsync()           __builtin_si_dsync()\n-#define si_mfspr(imm)        __builtin_si_mfspr(imm)\n-#define si_mtspr(imm,ra)     __builtin_si_mtspr(imm,ra)\n-#define si_fscrrd()          __builtin_si_fscrrd()\n-#define si_fscrwr(ra)        __builtin_si_fscrwr(ra)\n-#define si_rdch(imm)         __builtin_si_rdch(imm)\n-#define si_rchcnt(imm)       __builtin_si_rchcnt(imm)\n-#define si_wrch(imm,ra)      __builtin_si_wrch(imm,ra)\n-\n-/* celledp only instructions  */\n-#ifdef __SPU_EDP__\n-#define si_dfceq(ra,rb)      __builtin_si_dfceq(ra,rb)\n-#define si_dfcmeq(ra,rb)     __builtin_si_dfcmeq(ra,rb)\n-#define si_dfcgt(ra,rb)      __builtin_si_dfcgt(ra,rb)\n-#define si_dfcmgt(ra,rb)     __builtin_si_dfcmgt(ra,rb)\n-#define si_dftsv(ra,imm)     __builtin_si_dftsv(ra,imm)\n-#endif /* __SPU_EDP__  */\n-\n-#define si_from_char(scalar)    __builtin_si_from_char(scalar)\n-#define si_from_uchar(scalar)   __builtin_si_from_uchar(scalar)\n-#define si_from_short(scalar)   __builtin_si_from_short(scalar)\n-#define si_from_ushort(scalar)  __builtin_si_from_ushort(scalar)\n-#define si_from_int(scalar)     __builtin_si_from_int(scalar)\n-#define si_from_uint(scalar)    __builtin_si_from_uint(scalar)\n-#define si_from_llong(scalar)   __builtin_si_from_long(scalar)\n-#define si_from_ullong(scalar)  __builtin_si_from_ulong(scalar)\n-#define si_from_float(scalar)   __builtin_si_from_float(scalar)\n-#define si_from_double(scalar)  __builtin_si_from_double(scalar)\n-#define si_from_ptr(scalar)     __builtin_si_from_ptr(scalar)\n-\n-#define si_to_char(ra)      __builtin_si_to_char(ra)\n-#define si_to_uchar(ra)     __builtin_si_to_uchar(ra)\n-#define si_to_short(ra)     __builtin_si_to_short(ra)\n-#define si_to_ushort(ra)    __builtin_si_to_ushort(ra)\n-#define si_to_int(ra)       __builtin_si_to_int(ra)\n-#define si_to_uint(ra)      __builtin_si_to_uint(ra)\n-#define si_to_llong(ra)     __builtin_si_to_long(ra)\n-#define si_to_ullong(ra)    __builtin_si_to_ulong(ra)\n-#define si_to_float(ra)     __builtin_si_to_float(ra)\n-#define si_to_double(ra)    __builtin_si_to_double(ra)\n-#define si_to_ptr(ra)       __builtin_si_to_ptr(ra)\n-\n-#define __align_hint(ptr,base,offset) __builtin_spu_align_hint(ptr,base,offset)\n-\n-/* generic spu_* intrinsics */\n-\n-#define spu_splats(scalar)        __builtin_spu_splats(scalar) \n-#define spu_convtf(ra,imm)        __builtin_spu_convtf(ra,imm)\n-#define spu_convts(ra,imm)        __builtin_spu_convts(ra,imm)\n-#define spu_convtu(ra,imm)        __builtin_spu_convtu(ra,imm) \n-#define spu_extend(ra)            __builtin_spu_extend(ra) \n-#define spu_roundtf(ra)           __builtin_spu_roundtf(ra) \n-#define spu_add(ra,rb)            __builtin_spu_add(ra,rb) \n-#define spu_addx(ra,rb,rt)        __builtin_spu_addx(ra,rb,rt) \n-#define spu_genc(ra,rb)           __builtin_spu_genc(ra,rb) \n-#define spu_gencx(ra,rb,rt)       __builtin_spu_gencx(ra,rb,rt) \n-#define spu_madd(ra,rb,rc)        __builtin_spu_madd(ra,rb,rc)\n-#define spu_nmadd(ra,rb,rc)       __builtin_spu_nmadd(ra,rb,rc)\n-#define spu_mhhadd(ra,rb,rc)      __builtin_spu_mhhadd(ra,rb,rc)\n-#define spu_msub(ra,rb,rc)        __builtin_spu_msub(ra,rb,rc) \n-#define spu_mul(ra,rb)            __builtin_spu_mul(ra,rb) \n-#define spu_mulh(ra,rb)           __builtin_spu_mulh(ra,rb) \n-#define spu_mule(ra,rb)           __builtin_spu_mule(ra,rb) \n-#define spu_mulo(ra,rb)           __builtin_spu_mulo(ra,rb) \n-#define spu_mulsr(ra,rb)          __builtin_spu_mulsr(ra,rb) \n-#define spu_nmsub(ra,rb,rc)       __builtin_spu_nmsub(ra,rb,rc) \n-#define spu_sub(ra,rb)            __builtin_spu_sub(ra,rb)\n-#define spu_subx(ra,rb,rt)        __builtin_spu_subx(ra,rb,rt) \n-#define spu_genb(ra,rb)           __builtin_spu_genb(ra,rb) \n-#define spu_genbx(ra,rb,rt)       __builtin_spu_genbx(ra,rb,rt) \n-#define spu_absd(ra,rb)           __builtin_spu_absd(ra,rb) \n-#define spu_avg(ra,rb)            __builtin_spu_avg(ra,rb) \n-#define spu_sumb(ra,rb)           __builtin_spu_sumb(ra,rb) \n-#define spu_bisled(ra)            __builtin_spu_bisled(ra, 0)\n-#define spu_bisled_d(ra)          __builtin_spu_bisled_d(ra, 0)\n-#define spu_bisled_e(ra)          __builtin_spu_bisled_e(ra, 0)\n-#define spu_cmpabseq(ra,rb)       __builtin_spu_cmpabseq(ra,rb) \n-#define spu_cmpabsgt(ra,rb)       __builtin_spu_cmpabsgt(ra,rb) \n-#define spu_cmpeq(ra,rb)          __builtin_spu_cmpeq(ra,rb) \n-#define spu_cmpgt(ra,rb)          __builtin_spu_cmpgt(ra,rb) \n-#define spu_testsv(ra,imm)        __builtin_spu_testsv(ra,imm) \n-#define spu_hcmpeq(ra,rb)         __builtin_spu_hcmpeq(ra,rb) \n-#define spu_hcmpgt(ra,rb)         __builtin_spu_hcmpgt(ra,rb) \n-#define spu_cntb(ra)              __builtin_spu_cntb(ra) \n-#define spu_cntlz(ra)             __builtin_spu_cntlz(ra) \n-#define spu_gather(ra)            __builtin_spu_gather(ra) \n-#define spu_maskb(ra)             __builtin_spu_maskb(ra) \n-#define spu_maskh(ra)             __builtin_spu_maskh(ra) \n-#define spu_maskw(ra)             __builtin_spu_maskw(ra) \n-#define spu_sel(ra,rb,rc)         __builtin_spu_sel(ra,rb,rc) \n-#define spu_shuffle(ra,rb,rc)     __builtin_spu_shuffle(ra,rb,rc) \n-#define spu_and(ra,rb)            __builtin_spu_and(ra,rb) \n-#define spu_andc(ra,rb)           __builtin_spu_andc(ra,rb) \n-#define spu_eqv(ra,rb)            __builtin_spu_eqv(ra,rb) \n-#define spu_nand(ra,rb)           __builtin_spu_nand(ra,rb)\n-#define spu_nor(ra,rb)            __builtin_spu_nor(ra,rb) \n-#define spu_or(ra,rb)             __builtin_spu_or(ra,rb) \n-#define spu_orc(ra,rb)            __builtin_spu_orc(ra,rb) \n-#define spu_orx(ra)               __builtin_spu_orx(ra)\n-#define spu_xor(ra,rb)            __builtin_spu_xor(ra,rb) \n-#define spu_rl(ra,rb)             __builtin_spu_rl(ra,rb) \n-#define spu_rlqw(ra,count)        __builtin_spu_rlqw(ra,count) \n-#define spu_rlqwbyte(ra,count)    __builtin_spu_rlqwbyte(ra,count) \n-#define spu_rlqwbytebc(ra,count)  __builtin_spu_rlqwbytebc(ra,count) \n-#define spu_rlmask(ra,rb)         __builtin_spu_rlmask(ra,rb) \n-#define spu_rlmaska(ra,rb)        __builtin_spu_rlmaska(ra,rb) \n-#define spu_rlmaskqw(ra,rb)       __builtin_spu_rlmaskqw(ra,rb) \n-#define spu_rlmaskqwbyte(ra,rb)   __builtin_spu_rlmaskqwbyte(ra,rb) \n-#define spu_rlmaskqwbytebc(ra,rb) __builtin_spu_rlmaskqwbytebc(ra,rb) \n-#define spu_sl(ra,rb)             __builtin_spu_sl(ra,rb) \n-#define spu_slqw(ra,rb)           __builtin_spu_slqw(ra,rb) \n-#define spu_slqwbyte(ra,rb)       __builtin_spu_slqwbyte(ra,rb) \n-#define spu_slqwbytebc(ra,rb)     __builtin_spu_slqwbytebc(ra,rb) \n-#define spu_sr(ra,rb)             __builtin_spu_sr(ra,rb) \n-#define spu_sra(ra,rb)            __builtin_spu_sra(ra,rb) \n-#define spu_srqw(ra,rb)           __builtin_spu_srqw(ra,rb) \n-#define spu_srqwbyte(ra,rb)       __builtin_spu_srqwbyte(ra,rb) \n-#define spu_srqwbytebc(ra,rb)     __builtin_spu_srqwbytebc(ra,rb) \n-#define spu_extract(ra,pos)       __builtin_spu_extract(ra,pos) \n-#define spu_insert(scalar,ra,pos) __builtin_spu_insert(scalar,ra,pos) \n-#define spu_promote(scalar,pos)   __builtin_spu_promote(scalar,pos) \n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-/* The type checking for some of these won't be accurate but they need\n- * to be defines because of the immediate values. */\n-#define spu_idisable()          __builtin_spu_idisable()\n-#define spu_ienable()           __builtin_spu_ienable()\n-#define spu_mfspr(imm)          si_to_uint(si_mfspr((imm)))\n-#define spu_mtspr(imm, ra)      si_mtspr((imm),si_from_uint (ra))\n-#define spu_mffpscr()           ((vec_uint4)si_fscrrd())\n-#define spu_mtfpscr(a)          si_fscrwr((qword)a)\n-#define spu_dsync()             si_dsync() \n-#define spu_stop(imm)           si_stop(imm)\n-#define spu_sync()              si_sync()\n-#define spu_sync_c()            si_syncc()\n-#define spu_readch(imm)         si_to_uint(si_rdch((imm)))\n-#define spu_readchqw(imm)       ((vec_uint4)si_rdch((imm)))\n-#define spu_readchcnt(imm)      si_to_uint(si_rchcnt((imm)))\n-#define spu_writech(imm, ra)    si_wrch((imm), si_from_uint(ra))\n-#define spu_writechqw(imm, ra)  si_wrch((imm), (qword)(ra))\n-\n-/* The following functions are static and always_inline to make sure\n- * they don't show up in object files which they aren't used in.  */\n-\n-static __inline__ vec_float4 spu_re (vec_float4 ra) __attribute__((__always_inline__));\n-static __inline__ vec_float4 spu_rsqrte (vec_float4 ra) __attribute__((__always_inline__));\n-\n-static __inline__ vec_float4\n-spu_re (vec_float4 ra)\n-{\n-  return (vec_float4) si_fi ((qword) (ra), si_frest ((qword) (ra)));\n-}\n-static __inline__ vec_float4\n-spu_rsqrte (vec_float4 ra)\n-{\n-  return (vec_float4) si_fi ((qword) (ra), si_frsqest ((qword) (ra)));\n-}\n-\n-/* composite intrinsics */\n-static __inline__ void spu_mfcdma32(volatile void *ls, unsigned int ea, unsigned int size, unsigned int tagid, unsigned int cmd) __attribute__((__always_inline__));\n-static __inline__ void spu_mfcdma64(volatile void *ls, unsigned int eahi, unsigned int ealow, unsigned int size, unsigned int tagid, unsigned int cmd) __attribute__((__always_inline__));\n-static __inline__ unsigned int spu_mfcstat(unsigned int type) __attribute__((__always_inline__));\n-\n-static __inline__ void\n-spu_mfcdma32(volatile void *ls, unsigned int ea, unsigned int size, unsigned int tagid, unsigned int cmd)\n-{\n-      si_wrch(MFC_LSA,si_from_ptr(ls));\n-      si_wrch(MFC_EAL,si_from_uint(ea));\n-      si_wrch(MFC_Size,si_from_uint(size));\n-      si_wrch(MFC_TagID,si_from_uint(tagid));\n-      si_wrch(MFC_Cmd,si_from_uint(cmd));\n-}\n-static __inline__ void\n-spu_mfcdma64(volatile void *ls, unsigned int eahi, unsigned int ealow, unsigned int size, unsigned int tagid, unsigned int cmd)\n-{\n-      si_wrch(MFC_LSA,si_from_ptr(ls));\n-      si_wrch(MFC_EAH,si_from_uint(eahi));\n-      si_wrch(MFC_EAL,si_from_uint(ealow));\n-      si_wrch(MFC_Size,si_from_uint(size));\n-      si_wrch(MFC_TagID,si_from_uint(tagid));\n-      si_wrch(MFC_Cmd,si_from_uint(cmd));\n-}\n-static __inline__ unsigned int\n-spu_mfcstat(unsigned int type)\n-{\n-      si_wrch(MFC_WrTagUpdate,si_from_uint(type));\n-      return si_to_uint(si_rdch(MFC_RdTagStat));\n-}\n-#ifdef __cplusplus\n-\n-}\n-#endif  /* __cplusplus */\n-\n-#endif /* SPUINTRIN_H */\n-"}, {"sha": "81ed50ad8368d4e04e826349b2bb5230df3cac96", "filename": "gcc/config/spu/spu_intrinsics.h", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu_intrinsics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu_intrinsics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu_intrinsics.h?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,83 +0,0 @@\n-/* Definitions of Synergistic Processing Unit (SPU). */\n-/* Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option) \n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef  _SPU_INTRINSICS_H\n-#define _SPU_INTRINSICS_H \n- \n-#define vec_uchar16             __vector unsigned char\n-#define vec_char16              __vector   signed char\n-#define vec_ushort8             __vector unsigned short\n-#define vec_short8              __vector   signed short\n-#define vec_uint4               __vector unsigned int\n-#define vec_int4                __vector   signed int\n-#define vec_ullong2             __vector unsigned long long\n-#define vec_llong2              __vector   signed long long\n-#define vec_float4              __vector          float\n-#define vec_double2             __vector          double\n-\n-/* SPU Channel Defines \n- */\n-#define SPU_RdEventStat\t\t 0\n-#define SPU_WrEventMask\t\t 1\n-#define SPU_WrEventAck\t\t 2\n-#define SPU_RdSigNotify1\t 3\n-#define SPU_RdSigNotify2\t 4\n-#define SPU_WrDec\t\t 7\n-#define SPU_RdDec\t\t 8\n-#define SPU_RdEventMask\t\t11\n-#define SPU_RdMachStat\t\t13\n-#define SPU_WrSRR0\t\t14\n-#define SPU_RdSRR0\t\t15\n-#define SPU_WrOutMbox\t\t28 \n-#define SPU_RdInMbox\t\t29 \n-#define SPU_WrOutIntrMbox\t30 \n-\n-/* MFC Channel Defines. \n- */\n-#define MFC_WrMSSyncReq\t\t 9\n-#define MFC_RdTagMask\t\t12\n-#define MFC_LSA\t\t\t16 \n-#define MFC_EAH\t\t\t17 \n-#define MFC_EAL\t\t\t18 \n-#define MFC_Size\t\t19 \n-#define MFC_TagID\t\t20 \n-#define MFC_Cmd\t\t\t21 \n-#define MFC_WrTagMask\t\t22 \n-#define MFC_WrTagUpdate\t\t23 \n-#define MFC_RdTagStat\t\t24 \n-#define MFC_RdListStallStat\t25 \n-#define MFC_WrListStallAck\t26 \n-#define MFC_RdAtomicStat\t27 \n-\n-/* Bit flag mnemonics for test special value.\n- */\n-#define SPU_SV_NEG_DENORM       0x01    /* negative denormalized number  */\n-#define SPU_SV_POS_DENORM       0x02    /* positive denormalized number  */\n-#define SPU_SV_NEG_ZERO         0x04    /* negative zero                 */\n-#define SPU_SV_POS_ZERO         0x08    /* positive zero                 */\n-#define SPU_SV_NEG_INFINITY     0x10    /* negative infinity             */\n-#define SPU_SV_POS_INFINITY     0x20    /* positive infinity             */\n-#define SPU_SV_NAN              0x40    /* not a number                  */\n-\n-#include <spu_internals.h>\n-\n-#endif /* _SPU_INTRINSICS_H */"}, {"sha": "db35a3327558d676d00891de89e621099e16244a", "filename": "gcc/config/spu/spu_mfcio.h", "status": "removed", "additions": 0, "deletions": 342, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu_mfcio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fspu_mfcio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu_mfcio.h?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,342 +0,0 @@\n-/* Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option) \n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef __SPU_MFCIO_H__\n-#define __SPU_MFCIO_H__ 1\n-\n-#include <spu_intrinsics.h>\n-#ifdef __IN_LIBGCC2\n-typedef unsigned long long uint64_t;\n-#else\n-#include <stdint.h>\n-#endif\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-\n-/****************************************************************/\n-/* DMA list element structure*/\n-/****************************************************************/\n- \n-#ifdef __GNUC__\n-__extension__\n-#endif\n-typedef struct mfc_list_element {\n-  uint64_t notify       :  1;   /** Stall-and-notify bit  */\n-  uint64_t reserved     : 16;\n-  uint64_t size         : 15;   /** Transfer size */\n-  uint64_t eal          : 32;   /** Lower word of effective address */\n-} mfc_list_element_t;\n- \n-/****************************************************************/\n-/* DMA max/min size definitions.                        */\n-/****************************************************************/\n-\n-#define MFC_MIN_DMA_SIZE_SHIFT  4      /* 16 bytes */\n-#define MFC_MAX_DMA_SIZE_SHIFT 14      /* 16384 bytes */\n-\n-#define MFC_MIN_DMA_SIZE (1 << MFC_MIN_DMA_SIZE_SHIFT)\n-#define MFC_MAX_DMA_SIZE (1 << MFC_MAX_DMA_SIZE_SHIFT)\n-\n-#define MFC_MIN_DMA_SIZE_MASK (MFC_MIN_DMA_SIZE - 1)\n-#define MFC_MAX_DMA_SIZE_MASK (MFC_MAX_DMA_SIZE - 1)\n-\n-#define MFC_MIN_DMA_LIST_ELEMENTS 1\n-#define MFC_MAX_DMA_LIST_ELEMENTS 2048\n-\n-#define MFC_MIN_DMA_LIST_SIZE (MFC_MIN_DMA_LIST_ELEMENTS << 3) /*   8 bytes */\n-#define MFC_MAX_DMA_LIST_SIZE (MFC_MAX_DMA_LIST_ELEMENTS << 3) /* 16K bytes */\n-\n-/****************************************************************/\n-/* MFC DMA command modifiers to identify classes of operations. */\n-/****************************************************************/\n-\n-/* Note: These commands modifier may be used in conjunction with the base\n-   command types (i.e. MFC_PUT_CMD, MFC_GET_CMD, and MFC_SNDSIG_CMD)\n-   to construct the various command permutations.  */\n-\n-#define MFC_BARRIER_ENABLE    0x0001\n-#define MFC_FENCE_ENABLE      0x0002\n-#define MFC_LIST_ENABLE       0x0004\n-#define MFC_RESULT_ENABLE     0x0010\n-\n-/****************************************************************/\n-/* MFC DMA Put Commands                                 */\n-/****************************************************************/\n-\n-#define MFC_PUT_CMD          0x0020\n-#define MFC_PUTB_CMD         (MFC_PUT_CMD | MFC_BARRIER_ENABLE)\n-#define MFC_PUTF_CMD         (MFC_PUT_CMD | MFC_FENCE_ENABLE)\n-#define MFC_PUTL_CMD         (MFC_PUT_CMD | MFC_LIST_ENABLE)\n-#define MFC_PUTLB_CMD        (MFC_PUTL_CMD | MFC_BARRIER_ENABLE)\n-#define MFC_PUTLF_CMD        (MFC_PUTL_CMD | MFC_FENCE_ENABLE)\n-\n-#define MFC_PUTR_CMD         (MFC_PUT_CMD | MFC_RESULT_ENABLE)\n-#define MFC_PUTRB_CMD        (MFC_PUTR_CMD | MFC_BARRIER_ENABLE)\n-#define MFC_PUTRF_CMD        (MFC_PUTR_CMD | MFC_FENCE_ENABLE)\n-#define MFC_PUTRL_CMD        (MFC_PUTR_CMD | MFC_LIST_ENABLE)\n-#define MFC_PUTRLB_CMD       (MFC_PUTRL_CMD | MFC_BARRIER_ENABLE)\n-#define MFC_PUTRLF_CMD       (MFC_PUTRL_CMD | MFC_FENCE_ENABLE)\n-\n-/****************************************************************/\n-/* MFC DMA Get Commands                                 */\n-/****************************************************************/\n-\n-#define MFC_GET_CMD          0x0040\n-#define MFC_GETB_CMD         (MFC_GET_CMD | MFC_BARRIER_ENABLE)\n-#define MFC_GETF_CMD         (MFC_GET_CMD | MFC_FENCE_ENABLE)\n-#define MFC_GETL_CMD         (MFC_GET_CMD | MFC_LIST_ENABLE)\n-#define MFC_GETLB_CMD        (MFC_GETL_CMD | MFC_BARRIER_ENABLE)\n-#define MFC_GETLF_CMD        (MFC_GETL_CMD | MFC_FENCE_ENABLE)\n-\n-/****************************************************************/\n-/* MFC Synchronization Commands                           */\n-/****************************************************************/\n-\n-#define MFC_SNDSIG_CMD       0x00A0\n-#define MFC_SNDSIGB_CMD      (MFC_SNDSIG_CMD | MFC_BARRIER_ENABLE)\n-#define MFC_SNDSIGF_CMD      (MFC_SNDSIG_CMD | MFC_FENCE_ENABLE)\n-#define MFC_BARRIER_CMD      0x00C0\n-#define MFC_EIEIO_CMD        0x00C8\n-#define MFC_SYNC_CMD         0x00CC\n-\n-/****************************************************************/\n-/* MFC Atomic Commands                                 */\n-/****************************************************************/\n-\n-#define MFC_GETLLAR_CMD      0x00D0\n-#define MFC_PUTLLC_CMD       0x00B4\n-#define MFC_PUTLLUC_CMD      0x00B0\n-#define MFC_PUTQLLUC_CMD     0x00B8\n-\n-/****************************************************************/\n-/* MFC SL1 Storage Control Commands                             */\n-/****************************************************************/\n-\n-#define MFC_SDCRT_CMD        0x0080\n-#define MFC_SDCRTST_CMD      0x0081\n-#define MFC_SDCRZ_CMD        0x0089\n-#define MFC_SDCRST_CMD       0x008D\n-#define MFC_SDCRF_CMD        0x008F\n-\n-/****************************************************************/\n-/* Channel Defines                                    */\n-/****************************************************************/\n-\n-/* Events Defines for channels\n- *    0 (SPU_RdEventStat),\n- *    1 (SPU_WrEventMask), and\n- *    2 (SPU_WrEventAck).\n- */\n-#define MFC_TAG_STATUS_UPDATE_EVENT         0x00000001\n-#define MFC_LIST_STALL_NOTIFY_EVENT         0x00000002\n-#define MFC_COMMAND_QUEUE_AVAILABLE_EVENT   0x00000008\n-#define MFC_IN_MBOX_AVAILABLE_EVENT         0x00000010\n-#define MFC_DECREMENTER_EVENT               0x00000020\n-#define MFC_OUT_INTR_MBOX_AVAILABLE_EVENT   0x00000040\n-#define MFC_OUT_MBOX_AVAILABLE_EVENT        0x00000080\n-#define MFC_SIGNAL_NOTIFY_2_EVENT           0x00000100\n-#define MFC_SIGNAL_NOTIFY_1_EVENT           0x00000200\n-#define MFC_LLR_LOST_EVENT                  0x00000400\n-#define MFC_PRIV_ATTN_EVENT                 0x00000800\n-#define MFC_MULTI_SRC_SYNC_EVENT            0x00001000\n-\n-/* Tag Status Update defines for channel 23 (MFC_WrTagUpdate) */\n-#define MFC_TAG_UPDATE_IMMEDIATE   0x0\n-#define MFC_TAG_UPDATE_ANY         0x1\n-#define MFC_TAG_UPDATE_ALL         0x2\n-\n-/* Atomic Command Status defines for channel 27 (MFC_RdAtomicStat) */\n-#define MFC_PUTLLC_STATUS    0x00000001\n-#define MFC_PUTLLUC_STATUS   0x00000002\n-#define MFC_GETLLAR_STATUS   0x00000004\n-\n-\n-/****************************************************************/\n-/* Definitions for constructing a 32-bit command word         */\n-/* including the transfer and replacement class id and the      */\n-/* command opcode.                                    */\n-/****************************************************************/\n-#define MFC_CMD_WORD(_tid, _rid, _cmd) (((_tid)<<24)|((_rid)<<16)|(_cmd))\n-\n-\n-/* Addressing Utilities */\n-#define mfc_ea2h(ea)   (unsigned int)((unsigned long long)(ea)>>32)\n-#define mfc_ea2l(ea)   (unsigned int)(ea)\n-#define mfc_hl2ea(h,l)   si_to_ullong(si_selb(si_from_uint(h),\\\n-                                  si_rotqbyi(si_from_uint(l), -4),\\\n-                                  si_fsmbi(0x0f0f)))\n-#define mfc_ceil128(v)   (((v) + 127) & ~127)\n-\n-/* MFC DMA */\n-#define mfc_put(  ls,ea,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),size,tag,MFC_CMD_WORD(tid,rid,MFC_PUT_CMD))\n-#define mfc_putf( ls,ea,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),size,tag,MFC_CMD_WORD(tid,rid,MFC_PUTF_CMD))\n-#define mfc_putb( ls,ea,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),size,tag,MFC_CMD_WORD(tid,rid,MFC_PUTB_CMD))\n-#define mfc_get(  ls,ea,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),size,tag,MFC_CMD_WORD(tid,rid,MFC_GET_CMD))\n-#define mfc_getf( ls,ea,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),size,tag,MFC_CMD_WORD(tid,rid,MFC_GETF_CMD))\n-#define mfc_getb( ls,ea,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),size,tag,MFC_CMD_WORD(tid,rid,MFC_GETB_CMD))\n-\n-/* MFC list DMA */\n-#define mfc_putl(  ls,ea,lsa,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),(unsigned int)(lsa),size,tag,MFC_CMD_WORD(tid,rid,MFC_PUTL_CMD))\n-#define mfc_putlf( ls,ea,lsa,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),(unsigned int)(lsa),size,tag,MFC_CMD_WORD(tid,rid,MFC_PUTLF_CMD))\n-#define mfc_putlb( ls,ea,lsa,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),(unsigned int)(lsa),size,tag,MFC_CMD_WORD(tid,rid,MFC_PUTLB_CMD))\n-#define mfc_getl(  ls,ea,lsa,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),(unsigned int)(lsa),size,tag,MFC_CMD_WORD(tid,rid,MFC_GETL_CMD))\n-#define mfc_getlf( ls,ea,lsa,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),(unsigned int)(lsa),size,tag,MFC_CMD_WORD(tid,rid,MFC_GETLF_CMD))\n-#define mfc_getlb( ls,ea,lsa,size,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),(unsigned int)(lsa),size,tag,MFC_CMD_WORD(tid,rid,MFC_GETLB_CMD))\n-\n-/* MFC Atomic Update DMA */\n-#define mfc_getllar( ls,ea,tid,rid)     spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),128,  0,MFC_CMD_WORD(tid,rid,MFC_GETLLAR_CMD))\n-#define mfc_putllc(  ls,ea,tid,rid)     spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),128,  0,MFC_CMD_WORD(tid,rid,MFC_PUTLLC_CMD))\n-#define mfc_putlluc( ls,ea,tid,rid)     spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),128,  0,MFC_CMD_WORD(tid,rid,MFC_PUTLLUC_CMD))\n-#define mfc_putqlluc(ls,ea,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),128,tag,MFC_CMD_WORD(tid,rid,MFC_PUTQLLUC_CMD))\n-\n-/* MFC Synchronization Commands */\n-#define mfc_sndsig( ls,ea,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),4,tag,MFC_CMD_WORD(tid,rid,MFC_SNDSIG_CMD))\n-#define mfc_sndsigb(ls,ea,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),4,tag,MFC_CMD_WORD(tid,rid,MFC_SNDSIGB_CMD))\n-#define mfc_sndsigf(ls,ea,tag,tid,rid) spu_mfcdma64(ls,mfc_ea2h(ea),mfc_ea2l(ea),4,tag,MFC_CMD_WORD(tid,rid,MFC_SNDSIGF_CMD))\n-#define mfc_barrier(tag)       spu_mfcdma32(0,0,0,tag,MFC_BARRIER_CMD)\n-#define mfc_eieio(tag,tid,rid) spu_mfcdma32(0,0,0,tag,MFC_CMD_WORD(tid,rid,MFC_EIEIO_CMD))\n-#define mfc_sync(tag)          spu_mfcdma32(0,0,0,tag,MFC_SYNC_CMD)\n-\n-/* MFC SL1 Storage Control Commands */\n-#define mfc_sdcrt(  ea,size,tag,tid,rid) spu_mfcdma64(0,mfc_ea2h(ea),mfc_ea2l(ea),size,tag,MFC_CMD_WORD(tid,rid,MFC_SDCRT_CMD))\n-#define mfc_sdcrtst(ea,size,tag,tid,rid) spu_mfcdma64(0,mfc_ea2h(ea),mfc_ea2l(ea),size,tag,MFC_CMD_WORD(tid,rid,MFC_SDCRTST_CMD))\n-#define mfc_sdcrz(  ea,size,tag,tid,rid) spu_mfcdma64(0,mfc_ea2h(ea),mfc_ea2l(ea),size,tag,MFC_CMD_WORD(tid,rid,MFC_SDCRZ_CMD))\n-#define mfc_sdcrst( ea,size,tag,tid,rid) spu_mfcdma64(0,mfc_ea2h(ea),mfc_ea2l(ea),size,tag,MFC_CMD_WORD(tid,rid,MFC_SDCRST_CMD))\n-#define mfc_sdcrf(  ea,size,tag,tid,rid) spu_mfcdma64(0,mfc_ea2h(ea),mfc_ea2l(ea),size,tag,MFC_CMD_WORD(tid,rid,MFC_SDCRF_CMD))\n-\n-/* DMA Queue */\n-#define mfc_stat_cmd_queue()          spu_readchcnt(MFC_Cmd)\n-\n-/* MFC Tag-Status */\n-#define mfc_write_tag_mask(mask)      spu_writech(MFC_WrTagMask,mask)\n-#define mfc_read_tag_mask()           spu_readch(MFC_RdTagMask)\n-\n-#define mfc_write_tag_update(ts)         spu_writech(MFC_WrTagUpdate,ts)\n-#define mfc_write_tag_update_immediate() mfc_write_tag_update(MFC_TAG_UPDATE_IMMEDIATE)\n-#define mfc_write_tag_update_any()       mfc_write_tag_update(MFC_TAG_UPDATE_ANY)\n-#define mfc_write_tag_update_all()       mfc_write_tag_update(MFC_TAG_UPDATE_ALL)\n-#define mfc_stat_tag_update()            spu_readchcnt(MFC_WrTagUpdate)\n-\n-#define mfc_read_tag_status()            spu_readch(MFC_RdTagStat)\n-#define mfc_read_tag_status_immediate()  (mfc_write_tag_update_immediate(), mfc_read_tag_status())\n-#define mfc_read_tag_status_any()        (mfc_write_tag_update_any(), mfc_read_tag_status())\n-#define mfc_read_tag_status_all()        (mfc_write_tag_update_all(), mfc_read_tag_status())\n-#define mfc_stat_tag_status()            spu_readchcnt(MFC_RdTagStat)\n-\n-/* MFC List Stall-and-Notify Tag */\n-#define mfc_read_list_stall_status()     spu_readch(MFC_RdListStallStat)\n-#define mfc_stat_list_stall_status()     spu_readchcnt(MFC_RdListStallStat)\n-#define mfc_write_list_stall_ack(tag)    spu_writech(MFC_WrListStallAck,tag)\n-\n-/* Atomic DMA */\n-#define mfc_read_atomic_status()      spu_readch(MFC_RdAtomicStat)\n-#define mfc_stat_atomic_status()      spu_readchcnt(MFC_RdAtomicStat)\n-\n-/* MFC Multi-source Synchronization */\n-#define mfc_write_multi_src_sync_request()   spu_writech(MFC_WrMSSyncReq,0)\n-#define mfc_stat_multi_src_sync_request()    spu_readchcnt(MFC_WrMSSyncReq)\n-\n-/* SPU Signal */\n-#define spu_read_signal1()            spu_readch(SPU_RdSigNotify1)\n-#define spu_stat_signal1()            spu_readchcnt(SPU_RdSigNotify1)\n-#define spu_read_signal2()            spu_readch(SPU_RdSigNotify2)\n-#define spu_stat_signal2()            spu_readchcnt(SPU_RdSigNotify2)\n-\n-/* SPU/PPE Mailbox */\n-#define spu_read_in_mbox()            spu_readch(SPU_RdInMbox)\n-#define spu_stat_in_mbox()            spu_readchcnt(SPU_RdInMbox)\n-#define spu_write_out_mbox(a)         spu_writech(SPU_WrOutMbox,a)\n-#define spu_stat_out_mbox()           spu_readchcnt(SPU_WrOutMbox)\n-#define spu_write_out_intr_mbox(a)    spu_writech(SPU_WrOutIntrMbox,a)\n-#define spu_stat_out_intr_mbox()      spu_readchcnt(SPU_WrOutIntrMbox)\n-\n-/* SPU Decrementer */\n-#define spu_read_decrementer()        spu_readch(SPU_RdDec)\n-#define spu_write_decrementer(cnt)    spu_writech(SPU_WrDec,(cnt))\n-\n-/* SPU Event */\n-#define spu_read_event_status()       spu_readch(SPU_RdEventStat)\n-#define spu_stat_event_status()       spu_readchcnt(SPU_RdEventStat)\n-#define spu_write_event_mask(mask)    spu_writech(SPU_WrEventMask,(mask))\n-#define spu_write_event_ack(ack)      spu_writech(SPU_WrEventAck,(ack))\n-#define spu_read_event_mask()         spu_readch(SPU_RdEventMask)\n-\n-/* SPU State Management */\n-#define spu_read_machine_status()     spu_readch(SPU_RdMachStat)\n-#define spu_write_srr0(srr0)          spu_writech(SPU_WrSRR0,srr0)\n-#define spu_read_srr0()               spu_readch(SPU_RdSRR0)\n-\n-/* Interrupt-Safe Critical Sections */\n-\n-static __inline__ unsigned int mfc_begin_critical_section (void)\n-  __attribute__ ((__always_inline__));\n-\n-static __inline__ unsigned int\n-mfc_begin_critical_section (void)\n-{\n-#ifdef SPU_MFCIO_INTERRUPT_SAFE\n-  unsigned int __status = spu_read_machine_status ();\n-  spu_idisable ();\n-  return __status;\n-#else\n-  return 0;\n-#endif\n-}\n-\n-static __inline__ void mfc_end_critical_section (unsigned int)\n-  __attribute__ ((__always_inline__));\n-\n-static __inline__ void\n-mfc_end_critical_section (unsigned int __status __attribute__ ((__unused__)))\n-{\n-#ifdef SPU_MFCIO_INTERRUPT_SAFE\n-  if (__status & 1)\n-    spu_ienable ();\n-#endif\n-}\n-\n-/* MFC Tag Manager */\n-\n-#define MFC_TAG_INVALID 0xFFFFFFFF\n-#define MFC_TAG_VALID   0x00000000\n-\n-#define mfc_tag_reserve() \\\n-\t__mfc_tag_reserve()\n-#define mfc_tag_release(tag) \\\n-\t__mfc_tag_release((tag))\n-#define mfc_multi_tag_reserve(nr_tags) \\\n-\t__mfc_multi_tag_reserve((nr_tags))\n-#define mfc_multi_tag_release(tag, nr_tags) \\\n-\t__mfc_multi_tag_release((tag),(nr_tags))\n-\n-extern unsigned int __mfc_tag_reserve (void);\n-extern unsigned int __mfc_tag_release (unsigned int);\n-extern unsigned int __mfc_multi_tag_reserve (unsigned int);\n-extern unsigned int __mfc_multi_tag_release (unsigned int, unsigned int);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif /* __SPU_MFCIO_H__ */"}, {"sha": "fe9591de8d7393fdbb0d25c278295bb200aa964c", "filename": "gcc/config/spu/t-spu-elf", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Ft-spu-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Ft-spu-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Ft-spu-elf?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,34 +0,0 @@\n-#  Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-#\n-#  This file is free software; you can redistribute it and/or modify it under\n-#  the terms of the GNU General Public License as published by the Free\n-#  Software Foundation; either version 3 of the License, or (at your option) \n-#  any later version.\n-#\n-#  This file is distributed in the hope that it will be useful, but WITHOUT\n-#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-#  for more details.\n-#\n-#  You should have received a copy of the GNU General Public License\n-#  along with GCC; see the file COPYING3.  If not see\n-#  <http://www.gnu.org/licenses/>.\n-\n-# Multi-lib support.\n-MULTILIB_OPTIONS=mea64\n-\n-spu.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-  $(RTL_H) $(REGS_H) hard-reg-set.h dumpfile.h \\\n-  real.h insn-config.h conditions.h insn-attr.h flags.h $(RECOG_H) \\\n-  $(OBSTACK_H) $(TREE_H) $(EXPR_H) $(OPTABS_H) except.h function.h \\\n-  output.h $(BASIC_BLOCK_H) $(GGC_H) $(HASHTAB_H) \\\n-  $(TM_P_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h reload.h $(CFGLOOP_H) \\\n-  $(srcdir)/config/spu/spu-protos.h \\\n-  $(srcdir)/config/spu/spu-builtins.def \n-\n-spu-c.o: $(srcdir)/config/spu/spu-c.c \\\n-    $(srcdir)/config/spu/spu-protos.h \\\n-    $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(CPPLIB_H) \\\n-    $(TM_P_H) $(C_COMMON_H) $(C_PRAGMA_H) coretypes.h $(TM_H) insn-codes.h\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n-\t\t$(srcdir)/config/spu/spu-c.c"}, {"sha": "2c3f18f8f3307e89fe17ff91059c2725aec414b4", "filename": "gcc/config/spu/vec_types.h", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fvec_types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fvec_types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fvec_types.h?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,36 +0,0 @@\n-/* Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option) \n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef _VEC_TYPES_H_\n-#define _VEC_TYPES_H_\t1\n-\n-#include <spu_intrinsics.h>\n-\n-/* Define additional PowerPC SIMD/Vector Multi-media eXtension\n- * single keyword vector data types for use in mapping VMX code\n- * to the SPU.\n- */\n-#define vec_bchar16\t__vector unsigned char\n-#define vec_bshort8\t__vector unsigned short\n-#define vec_pixel8\t__vector unsigned short\n-#define vec_bint4\t__vector unsigned int\n-\n-#endif /* _VEC_TYPES_H_ */"}, {"sha": "75ab5949bf0e1bd2fdcdba09cae54e7c0c705c90", "filename": "gcc/config/spu/vmx2spu.h", "status": "removed", "additions": 0, "deletions": 3985, "changes": 3985, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fvmx2spu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Fconfig%2Fspu%2Fvmx2spu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fvmx2spu.h?ref=934392185369af22fee845e4edd92c420b8c248b"}, {"sha": "22cf194a897c4506cd12988d1134fde8f61067db", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -27962,7 +27962,7 @@ esac\n # version to the per-target configury.\n case \"$cpu_type\" in\n   aarch64 | alpha | arc | arm | avr | bfin | cris | csky | i386 | m32c | m68k \\\n-  | microblaze | mips | nds32 | nios2 | pa | riscv | rs6000 | score | sparc | spu \\\n+  | microblaze | mips | nds32 | nios2 | pa | riscv | rs6000 | score | sparc \\\n   | tilegx | tilepro | visium | xstormy16 | xtensa)\n     insn=\"nop\"\n     ;;"}, {"sha": "5c60d0f8dfdbee5b33d1736c93f174d01dcb2b02", "filename": "gcc/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -4999,7 +4999,7 @@ esac\n # version to the per-target configury.\n case \"$cpu_type\" in\n   aarch64 | alpha | arc | arm | avr | bfin | cris | csky | i386 | m32c | m68k \\\n-  | microblaze | mips | nds32 | nios2 | pa | riscv | rs6000 | score | sparc | spu \\\n+  | microblaze | mips | nds32 | nios2 | pa | riscv | rs6000 | score | sparc \\\n   | tilegx | tilepro | visium | xstormy16 | xtensa)\n     insn=\"nop\"\n     ;;"}, {"sha": "cec15e5034c0b9f5cde26c922559bf39b45eaeaa", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 1, "deletions": 112, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1385,7 +1385,7 @@ As an extension, GNU C supports named address spaces as\n defined in the N1275 draft of ISO/IEC DTR 18037.  Support for named\n address spaces in GCC will evolve as the draft technical report\n changes.  Calling conventions for any target might also change.  At\n-present, only the AVR, SPU, M32C, RL78, and x86 targets support\n+present, only the AVR, M32C, RL78, and x86 targets support\n address spaces other than the generic address space.\n \n Address space identifiers may be used exactly like any other C type\n@@ -1573,23 +1573,6 @@ with 32-bit pointers (20-bit addresses) rather than the default 16-bit\n addresses.  Non-far variables are assumed to appear in the topmost\n 64@tie{}KiB of the address space.\n \n-@subsection SPU Named Address Spaces\n-@cindex @code{__ea} SPU Named Address Spaces\n-\n-On the SPU target variables may be declared as\n-belonging to another address space by qualifying the type with the\n-@code{__ea} address space identifier:\n-\n-@smallexample\n-extern int __ea i;\n-@end smallexample\n-\n-@noindent \n-The compiler generates special code to access the variable @code{i}.\n-It may use runtime library\n-support, or generate special machine instructions to access that address\n-space.\n-\n @subsection x86 Named Address Spaces\n @cindex x86 named address spaces\n \n@@ -2486,7 +2469,6 @@ GCC plugins may provide their own attributes.\n * RX Function Attributes::\n * S/390 Function Attributes::\n * SH Function Attributes::\n-* SPU Function Attributes::\n * Symbian OS Function Attributes::\n * V850 Function Attributes::\n * Visium Function Attributes::\n@@ -5839,24 +5821,6 @@ On SH targets this function attribute is similar to @code{interrupt_handler}\n but it does not save and restore all registers.\n @end table\n \n-@node SPU Function Attributes\n-@subsection SPU Function Attributes\n-\n-These function attributes are supported by the SPU back end:\n-\n-@table @code\n-@item naked\n-@cindex @code{naked} function attribute, SPU\n-This attribute allows the compiler to construct the\n-requisite function declaration, while allowing the body of the\n-function to be assembly code. The specified function will not have\n-prologue/epilogue sequences generated by the compiler. Only basic\n-@code{asm} statements can safely be included in naked functions\n-(@pxref{Basic Asm}). While using extended @code{asm} or a mixture of\n-basic @code{asm} and C code may appear to work, they cannot be\n-depended upon to work reliably and are not supported.\n-@end table\n-\n @node Symbian OS Function Attributes\n @subsection Symbian OS Function Attributes\n \n@@ -6707,7 +6671,6 @@ attributes.\n * Nvidia PTX Variable Attributes::\n * PowerPC Variable Attributes::\n * RL78 Variable Attributes::\n-* SPU Variable Attributes::\n * V850 Variable Attributes::\n * x86 Variable Attributes::\n * Xstormy16 Variable Attributes::\n@@ -7622,14 +7585,6 @@ The RL78 back end supports the @code{saddr} variable attribute.  This\n specifies placement of the corresponding variable in the SADDR area,\n which can be accessed more efficiently than the default memory region.\n \n-@node SPU Variable Attributes\n-@subsection SPU Variable Attributes\n-\n-@cindex @code{spu_vector} variable attribute, SPU\n-The SPU supports the @code{spu_vector} attribute for variables.  For\n-documentation of this attribute please see the documentation in\n-@ref{SPU Type Attributes}.\n-\n @node V850 Variable Attributes\n @subsection V850 Variable Attributes\n \n@@ -7737,7 +7692,6 @@ attributes.\n * ARM Type Attributes::\n * MeP Type Attributes::\n * PowerPC Type Attributes::\n-* SPU Type Attributes::\n * x86 Type Attributes::\n @end menu\n \n@@ -8328,15 +8282,6 @@ __attribute__((altivec(bool__))) unsigned\n These attributes mainly are intended to support the @code{__vector},\n @code{__pixel}, and @code{__bool} AltiVec keywords.\n \n-@node SPU Type Attributes\n-@subsection SPU Type Attributes\n-\n-@cindex @code{spu_vector} type attribute, SPU\n-The SPU supports the @code{spu_vector} attribute for types.  This attribute\n-allows one to declare vector data types supported by the Sony/Toshiba/IBM SPU\n-Language Extensions Specification.  It is intended to support the\n-@code{__vector} keyword.\n-\n @node x86 Type Attributes\n @subsection x86 Type Attributes\n \n@@ -13621,7 +13566,6 @@ instructions, but allow the compiler to schedule those calls.\n * S/390 System z Built-in Functions::\n * SH Built-in Functions::\n * SPARC VIS Built-in Functions::\n-* SPU Built-in Functions::\n * TI C6X Built-in Functions::\n * TILE-Gx Built-in Functions::\n * TILEPro Built-in Functions::\n@@ -21160,61 +21104,6 @@ long __builtin_vis_fpcmpur16shl (v4hi, v4hi, int);\n long __builtin_vis_fpcmpur32shl (v2si, v2si, int);\n @end smallexample\n \n-@node SPU Built-in Functions\n-@subsection SPU Built-in Functions\n-\n-GCC provides extensions for the SPU processor as described in the\n-Sony/Toshiba/IBM SPU Language Extensions Specification.  GCC's\n-implementation differs in several ways.\n-\n-@itemize @bullet\n-\n-@item\n-The optional extension of specifying vector constants in parentheses is\n-not supported.\n-\n-@item\n-A vector initializer requires no cast if the vector constant is of the\n-same type as the variable it is initializing.\n-\n-@item\n-If @code{signed} or @code{unsigned} is omitted, the signedness of the\n-vector type is the default signedness of the base type.  The default\n-varies depending on the operating system, so a portable program should\n-always specify the signedness.\n-\n-@item\n-By default, the keyword @code{__vector} is added. The macro\n-@code{vector} is defined in @code{<spu_intrinsics.h>} and can be\n-undefined.\n-\n-@item\n-GCC allows using a @code{typedef} name as the type specifier for a\n-vector type.\n-\n-@item\n-For C, overloaded functions are implemented with macros so the following\n-does not work:\n-\n-@smallexample\n-  spu_add ((vector signed int)@{1, 2, 3, 4@}, foo);\n-@end smallexample\n-\n-@noindent\n-Since @code{spu_add} is a macro, the vector constant in the example\n-is treated as four separate arguments.  Wrap the entire argument in\n-parentheses for this to work.\n-\n-@item\n-The extended version of @code{__builtin_expect} is not supported.\n-\n-@end itemize\n-\n-@emph{Note:} Only the interface described in the aforementioned\n-specification is supported. Internally, GCC uses built-in functions to\n-implement the required functionality, but these are not supported and\n-are subject to change without notice.\n-\n @node TI C6X Built-in Functions\n @subsection TI C6X Built-in Functions\n "}, {"sha": "2e353be433c81146af97578787b14d770cf03446", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1214,17 +1214,6 @@ See RS/6000 and PowerPC Options.\n -mfix-at697f  -mfix-ut699  -mfix-ut700  -mfix-gr712rc @gol\n -mlra  -mno-lra}\n \n-@emph{SPU Options}\n-@gccoptlist{-mwarn-reloc  -merror-reloc @gol\n--msafe-dma  -munsafe-dma @gol\n--mbranch-hints @gol\n--msmall-mem  -mlarge-mem  -mstdmain @gol\n--mfixed-range=@var{register-range} @gol\n--mea32  -mea64 @gol\n--maddress-space-conversion  -mno-address-space-conversion @gol\n--mcache-size=@var{cache-size} @gol\n--matomic-updates  -mno-atomic-updates}\n-\n @emph{System V Options}\n @gccoptlist{-Qy  -Qn  -YP,@var{paths}  -Ym,@var{dir}}\n \n@@ -15717,7 +15706,6 @@ platform.\n * SH Options::\n * Solaris 2 Options::\n * SPARC Options::\n-* SPU Options::\n * System V Options::\n * TILE-Gx Options::\n * TILEPro Options::\n@@ -26772,141 +26760,6 @@ when making stack frame references.  This is the default in 64-bit mode.\n Otherwise, assume no such offset is present.\n @end table\n \n-@node SPU Options\n-@subsection SPU Options\n-@cindex SPU options\n-\n-These @samp{-m} options are supported on the SPU:\n-\n-@table @gcctabopt\n-@item -mwarn-reloc\n-@itemx -merror-reloc\n-@opindex mwarn-reloc\n-@opindex merror-reloc\n-\n-The loader for SPU does not handle dynamic relocations.  By default, GCC\n-gives an error when it generates code that requires a dynamic\n-relocation.  @option{-mno-error-reloc} disables the error,\n-@option{-mwarn-reloc} generates a warning instead.\n-\n-@item -msafe-dma\n-@itemx -munsafe-dma\n-@opindex msafe-dma\n-@opindex munsafe-dma\n-\n-Instructions that initiate or test completion of DMA must not be\n-reordered with respect to loads and stores of the memory that is being\n-accessed.\n-With @option{-munsafe-dma} you must use the @code{volatile} keyword to protect\n-memory accesses, but that can lead to inefficient code in places where the\n-memory is known to not change.  Rather than mark the memory as volatile,\n-you can use @option{-msafe-dma} to tell the compiler to treat\n-the DMA instructions as potentially affecting all memory.  \n-\n-@item -mbranch-hints\n-@opindex mbranch-hints\n-\n-By default, GCC generates a branch hint instruction to avoid\n-pipeline stalls for always-taken or probably-taken branches.  A hint\n-is not generated closer than 8 instructions away from its branch.\n-There is little reason to disable them, except for debugging purposes,\n-or to make an object a little bit smaller.\n-\n-@item -msmall-mem\n-@itemx -mlarge-mem\n-@opindex msmall-mem\n-@opindex mlarge-mem\n-\n-By default, GCC generates code assuming that addresses are never larger\n-than 18 bits.  With @option{-mlarge-mem} code is generated that assumes\n-a full 32-bit address.\n-\n-@item -mstdmain\n-@opindex mstdmain\n-\n-By default, GCC links against startup code that assumes the SPU-style\n-main function interface (which has an unconventional parameter list).\n-With @option{-mstdmain}, GCC links your program against startup\n-code that assumes a C99-style interface to @code{main}, including a\n-local copy of @code{argv} strings.\n-\n-@item -mfixed-range=@var{register-range}\n-@opindex mfixed-range\n-Generate code treating the given register range as fixed registers.\n-A fixed register is one that the register allocator cannot use.  This is\n-useful when compiling kernel code.  A register range is specified as\n-two registers separated by a dash.  Multiple register ranges can be\n-specified separated by a comma.\n-\n-@item -mea32\n-@itemx -mea64\n-@opindex mea32\n-@opindex mea64\n-Compile code assuming that pointers to the PPU address space accessed\n-via the @code{__ea} named address space qualifier are either 32 or 64\n-bits wide.  The default is 32 bits.  As this is an ABI-changing option,\n-all object code in an executable must be compiled with the same setting.\n-\n-@item -maddress-space-conversion\n-@itemx -mno-address-space-conversion\n-@opindex maddress-space-conversion\n-@opindex mno-address-space-conversion\n-Allow/disallow treating the @code{__ea} address space as superset\n-of the generic address space.  This enables explicit type casts\n-between @code{__ea} and generic pointer as well as implicit\n-conversions of generic pointers to @code{__ea} pointers.  The\n-default is to allow address space pointer conversions.\n-\n-@item -mcache-size=@var{cache-size}\n-@opindex mcache-size\n-This option controls the version of libgcc that the compiler links to an\n-executable and selects a software-managed cache for accessing variables\n-in the @code{__ea} address space with a particular cache size.  Possible\n-options for @var{cache-size} are @samp{8}, @samp{16}, @samp{32}, @samp{64}\n-and @samp{128}.  The default cache size is 64KB.\n-\n-@item -matomic-updates\n-@itemx -mno-atomic-updates\n-@opindex matomic-updates\n-@opindex mno-atomic-updates\n-This option controls the version of libgcc that the compiler links to an\n-executable and selects whether atomic updates to the software-managed\n-cache of PPU-side variables are used.  If you use atomic updates, changes\n-to a PPU variable from SPU code using the @code{__ea} named address space\n-qualifier do not interfere with changes to other PPU variables residing\n-in the same cache line from PPU code.  If you do not use atomic updates,\n-such interference may occur; however, writing back cache lines is\n-more efficient.  The default behavior is to use atomic updates.\n-\n-@item -mdual-nops\n-@itemx -mdual-nops=@var{n}\n-@opindex mdual-nops\n-By default, GCC inserts NOPs to increase dual issue when it expects\n-it to increase performance.  @var{n} can be a value from 0 to 10.  A\n-smaller @var{n} inserts fewer NOPs.  10 is the default, 0 is the\n-same as @option{-mno-dual-nops}.  Disabled with @option{-Os}.\n-\n-@item -mhint-max-nops=@var{n}\n-@opindex mhint-max-nops\n-Maximum number of NOPs to insert for a branch hint.  A branch hint must\n-be at least 8 instructions away from the branch it is affecting.  GCC\n-inserts up to @var{n} NOPs to enforce this, otherwise it does not\n-generate the branch hint.\n-\n-@item -mhint-max-distance=@var{n}\n-@opindex mhint-max-distance\n-The encoding of the branch hint instruction limits the hint to be within\n-256 instructions of the branch it is affecting.  By default, GCC makes\n-sure it is within 125.\n-\n-@item -msafe-hints\n-@opindex msafe-hints\n-Work around a hardware bug that causes the SPU to stall indefinitely.\n-By default, GCC inserts the @code{hbrp} instruction to make sure\n-this stall won't happen.\n-\n-@end table\n-\n @node System V Options\n @subsection Options for System V\n "}, {"sha": "fa4ae14534b790f0416992da31ce49ccefec7a73", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -3736,76 +3736,6 @@ Vector zero\n \n @end table\n \n-@item SPU---@file{config/spu/spu.h}\n-@table @code\n-@item a\n-An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 64 bit value.\n-\n-@item c\n-An immediate for and/xor/or instructions.  const_int is treated as a 64 bit value.\n-\n-@item d\n-An immediate for the @code{iohl} instruction.  const_int is treated as a 64 bit value.\n-\n-@item f\n-An immediate which can be loaded with @code{fsmbi}.\n-\n-@item A\n-An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 32 bit value.\n-\n-@item B\n-An immediate for most arithmetic instructions.  const_int is treated as a 32 bit value.\n-\n-@item C\n-An immediate for and/xor/or instructions.  const_int is treated as a 32 bit value.\n-\n-@item D\n-An immediate for the @code{iohl} instruction.  const_int is treated as a 32 bit value.\n-\n-@item I\n-A constant in the range [@minus{}64, 63] for shift/rotate instructions.\n-\n-@item J\n-An unsigned 7-bit constant for conversion/nop/channel instructions.\n-\n-@item K\n-A signed 10-bit constant for most arithmetic instructions.\n-\n-@item M\n-A signed 16 bit immediate for @code{stop}.\n-\n-@item N\n-An unsigned 16-bit constant for @code{iohl} and @code{fsmbi}.\n-\n-@item O\n-An unsigned 7-bit constant whose 3 least significant bits are 0.\n-\n-@item P\n-An unsigned 3-bit constant for 16-byte rotates and shifts\n-\n-@item R\n-Call operand, reg, for indirect calls\n-\n-@item S\n-Call operand, symbol, for relative calls.\n-\n-@item T\n-Call operand, const_int, for absolute calls.\n-\n-@item U\n-An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is sign extended to 128 bit.\n-\n-@item W\n-An immediate for shift and rotate instructions.  const_int is treated as a 32 bit value.\n-\n-@item Y\n-An immediate for and/xor/or instructions.  const_int is sign extended as a 128 bit.\n-\n-@item Z\n-An immediate for the @code{iohl} instruction.  const_int is sign extended to 128 bit.\n-\n-@end table\n-\n @item TI C6X family---@file{config/c6x/constraints.md}\n @table @code\n @item a"}, {"sha": "7867ac8424419bfeb1cdbd21f6b98f62979fbf8d", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -2011,9 +2011,6 @@ PowerPC target supports PowerPC 405.\n @item ppc_recip_hw\n PowerPC target supports executing reciprocal estimate instructions.\n \n-@item spu_auto_overlay\n-SPU target has toolchain that supports automatic overlay generation.\n-\n @item vmx_hw\n PowerPC target supports executing AltiVec instructions.\n \n@@ -2423,13 +2420,6 @@ Target supports compiling @code{vpclmul} instructions.\n Target supports compiling @code{xop} instructions.\n @end table\n \n-@subsubsection Local to tests in @code{gcc.target/spu/ea}\n-\n-@table @code\n-@item ealib\n-Target @code{__ea} library functions are available.\n-@end table\n-\n @subsubsection Local to tests in @code{gcc.test-framework}\n \n @table @code"}, {"sha": "1a17b066401519fe93379f69f0be384375c98041", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,3 +1,168 @@\n+2019-09-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* lib/compat.exp: Remove references to spu.\n+\t* lib/fortran-torture.exp: Likewise.\n+\t* lib/gcc-dg.exp: Likewise.\n+\t* lib/gfortran.exp: Likewise.\n+\t* lib/target-supports.exp: Likewise.\n+\t* lib/target-utils.exp: Likewise.\n+\n+\t* c-c++-common/torture/complex-sign-add.c: Remove references to spu.\n+\t* c-c++-common/torture/complex-sign-mixed-add.c: Likewise.\n+\t* c-c++-common/torture/complex-sign-mixed-div.c: Likewise.\n+\t* c-c++-common/torture/complex-sign-mixed-mul.c: Likewise.\n+\t* c-c++-common/torture/complex-sign-mixed-sub.c: Likewise.\n+\t* c-c++-common/torture/complex-sign-mul-minus-one.c: Likewise.\n+\t* c-c++-common/torture/complex-sign-mul-one.c: Likewise.\n+\t* c-c++-common/torture/complex-sign-mul.c: Likewise.\n+\t* c-c++-common/torture/complex-sign-sub.c: Likewise.\n+\n+\t* g++.dg/opt/temp1.C: Remove references to spu.\n+\t* g++.dg/opt/vt1.C: Likewise.\n+\t* g++.dg/torture/type-generic-1.C: Likewise.\n+\t* g++.dg/warn/pr30551-2.C: Likewise.\n+\t* g++.dg/warn/pr30551.C: Likewise.\n+\t* g++.old-deja/g++.jason/thunk2.C: Likewise.\n+\t* g++.old-deja/g++.other/comdat5.C: Likewise.\n+\t* g++.old-deja/g++.other/local-alloc1.C: Likewise.\n+\n+\t* gcc.c-torture/compile/20001226-1.c: Remove references to spu.\n+\t* gcc.c-torture/execute/20030222-1.c: Likewise.\n+\t* gcc.c-torture/execute/20031003-1.c: Likewise.\n+\t* gcc.c-torture/execute/20101011-1.c: Likewise.\n+\t* gcc.c-torture/execute/conversion.c: Likewise.\n+\t* gcc.c-torture/execute/ieee/compare-fp-4.x: Likewise.\n+\t* gcc.c-torture/execute/ieee/fp-cmp-2.x: Likewise.\n+\t* gcc.c-torture/execute/ieee/inf-1.c: Likewise.\n+\t* gcc.c-torture/execute/ieee/inf-2.c: Likewise.\n+\t* gcc.c-torture/execute/ieee/mul-subnormal-single-1.x: Likewise.\n+\t* gcc.c-torture/execute/ieee/rbug.c: Likewise.\n+\t* gcc.c-torture/execute/pr39228.c: Likewise.\n+\t* gcc.c-torture/execute/ieee/20010114-2.x: Remove file.\n+\t* gcc.c-torture/execute/ieee/20030331-1.x: Remove file.\n+\t* gcc.c-torture/execute/ieee/920518-1.x: Remove file.\n+\t* gcc.c-torture/execute/ieee/compare-fp-1.x: Remove file.\n+\t* gcc.c-torture/execute/ieee/fp-cmp-4f.x: Remove file.\n+\t* gcc.c-torture/execute/ieee/fp-cmp-8f.x: Remove file.\n+\n+\t* gcc.dg/20020312-2.c: Remove references to spu.\n+\t* gcc.dg/20030702-1.c: Likewise.\n+\t* gcc.dg/and-1.c: Likewise.\n+\t* gcc.dg/builtin-inf-1.c: Likewise.\n+\t* gcc.dg/builtins-1.c: Likewise.\n+\t* gcc.dg/builtins-43.c: Likewise.\n+\t* gcc.dg/builtins-44.c: Likewise.\n+\t* gcc.dg/builtins-45.c: Likewise.\n+\t* gcc.dg/float-range-1.c: Likewise.\n+\t* gcc.dg/float-range-3.c: Likewise.\n+\t* gcc.dg/float-range-4.c: Likewise.\n+\t* gcc.dg/float-range-5.c: Likewise.\n+\t* gcc.dg/fold-overflow-1.c: Likewise.\n+\t* gcc.dg/format/ms_unnamed-1.c: Likewise.\n+\t* gcc.dg/format/unnamed-1.c: Likewise.\n+\t* gcc.dg/hex-round-1.c: Likewise.\n+\t* gcc.dg/hex-round-2.c: Likewise.\n+\t* gcc.dg/lower-subreg-1.c: Likewise.\n+\t* gcc.dg/nrv3.c: Likewise.\n+\t* gcc.dg/pr15784-3.c: Likewise.\n+\t* gcc.dg/pr27095.c: Likewise.\n+\t* gcc.dg/pr28243.c: Likewise.\n+\t* gcc.dg/pr28796-2.c: Likewise.\n+\t* gcc.dg/pr30551-3.c: Likewise.\n+\t* gcc.dg/pr30551-6.c: Likewise.\n+\t* gcc.dg/pr30551.c: Likewise.\n+\t* gcc.dg/pr70317.c: Likewise.\n+\t* gcc.dg/sms-1.c: Likewise.\n+\t* gcc.dg/sms-2.c: Likewise.\n+\t* gcc.dg/sms-3.c: Likewise.\n+\t* gcc.dg/sms-4.c: Likewise.\n+\t* gcc.dg/sms-5.c: Likewise.\n+\t* gcc.dg/sms-6.c: Likewise.\n+\t* gcc.dg/sms-7.c: Likewise.\n+\t* gcc.dg/stack-usage-1.c: Likewise.\n+\t* gcc.dg/strlenopt-73.c: Likewise.\n+\t* gcc.dg/titype-1.c: Likewise.\n+\t* gcc.dg/tls/thr-cse-1.c: Likewise.\n+\t* gcc.dg/torture/builtin-attr-1.c: Likewise.\n+\t* gcc.dg/torture/builtin-complex-1.c: Likewise.\n+\t* gcc.dg/torture/builtin-cproj-1.c: Likewise.\n+\t* gcc.dg/torture/builtin-frexp-1.c: Likewise.\n+\t* gcc.dg/torture/builtin-ldexp-1.c: Likewise.\n+\t* gcc.dg/torture/builtin-logb-1.c: Likewise.\n+\t* gcc.dg/torture/builtin-math-2.c: Likewise.\n+\t* gcc.dg/torture/builtin-math-5.c: Likewise.\n+\t* gcc.dg/torture/builtin-modf-1.c: Likewise.\n+\t* gcc.dg/torture/fp-int-convert.h: Likewise.\n+\t* gcc.dg/torture/pr25947-1.c: Likewise.\n+\t* gcc.dg/torture/type-generic-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/20040204-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/ivopts-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/vector-6.c: Likewise.\n+\t* gcc.dg/uninit-C-O0.c: Likewise.\n+\t* gcc.dg/uninit-C.c: Likewise.\n+\t* gcc.dg/vect/no-math-errno-slp-32.c: Likewise.\n+\t* gcc.dg/vect/no-math-errno-vect-pow-1.c: Likewise.\n+\t* gcc.dg/vect/vect-float-extend-1.c: Likewise.\n+\t* gcc.dg/vect/vect-float-truncate-1.c: Likewise.\n+\t* gcc.dg/vect/vect.exp: Likewise.\n+\t* gcc.gd/vect/costmodel/spu/: Remove directory.\n+\n+\t* gcc.target/spu/: Remove directory.\n+\n+\t* gfortran.dg/bessel_6.f90: Remove references to spu.\n+\t* gfortran.dg/bessel_7.f90: Likewise.\n+\t* gfortran.dg/char4_iunit_1.f03: Likewise.\n+\t* gfortran.dg/chmod_1.f90: Likewise.\n+\t* gfortran.dg/chmod_2.f90: Likewise.\n+\t* gfortran.dg/chmod_3.f90: Likewise.\n+\t* gfortran.dg/default_format_1.f90: Likewise.\n+\t* gfortran.dg/default_format_denormal_1.f90: Likewise.\n+\t* gfortran.dg/erf_2.F90: Likewise.\n+\t* gfortran.dg/erf_3.F90: Likewise.\n+\t* gfortran.dg/init_flag_10.f90: Likewise.\n+\t* gfortran.dg/init_flag_3.f90: Likewise.\n+\t* gfortran.dg/int_conv_2.f90: Likewise.\n+\t* gfortran.dg/integer_exponentiation_3.F90: Likewise.\n+\t* gfortran.dg/integer_exponentiation_5.F90: Likewise.\n+\t* gfortran.dg/isnan_1.f90: Likewise.\n+\t* gfortran.dg/isnan_2.f90: Likewise.\n+\t* gfortran.dg/maxloc_2.f90: Likewise.\n+\t* gfortran.dg/maxlocval_2.f90: Likewise.\n+\t* gfortran.dg/maxlocval_4.f90: Likewise.\n+\t* gfortran.dg/minloc_1.f90: Likewise.\n+\t* gfortran.dg/minlocval_1.f90: Likewise.\n+\t* gfortran.dg/minlocval_4.f90: Likewise.\n+\t* gfortran.dg/module_nan.f90: Likewise.\n+\t* gfortran.dg/namelist_42.f90: Likewise.\n+\t* gfortran.dg/namelist_43.f90: Likewise.\n+\t* gfortran.dg/nan_1.f90: Likewise.\n+\t* gfortran.dg/nan_2.f90: Likewise.\n+\t* gfortran.dg/nan_3.f90: Likewise.\n+\t* gfortran.dg/nan_4.f90: Likewise.\n+\t* gfortran.dg/nan_5.f90: Likewise.\n+\t* gfortran.dg/nan_6.f90: Likewise.\n+\t* gfortran.dg/nearest_1.f90: Likewise.\n+\t* gfortran.dg/nearest_3.f90: Likewise.\n+\t* gfortran.dg/open_errors.f90: Likewise.\n+\t* gfortran.dg/pr20257.f90: Likewise.\n+\t* gfortran.dg/read_infnan_1.f90: Likewise.\n+\t* gfortran.dg/real_const_3.f90: Likewise.\n+\t* gfortran.dg/realloc_on_assign_2.f03: Likewise.\n+\t* gfortran.dg/reassoc_4.f: Likewise.\n+\t* gfortran.dg/scalar_mask_2.f90: Likewise.\n+\t* gfortran.dg/scratch_1.f90: Likewise.\n+\t* gfortran.dg/stat_1.f90: Likewise.\n+\t* gfortran.dg/stat_2.f90: Likewise.\n+\t* gfortran.dg/transfer_simplify_1.f90: Likewise.\n+\t* gfortran.dg/typebound_operator_9.f03: Likewise.\n+\n+\t* gfortran.fortran-torture/execute/intrinsic_nearest.x: Remove\n+\treferences to spu.\n+\t* gfortran.fortran-torture/execute/intrinsic_set_exponent.x: Likewise.\n+\t* gfortran.fortran-torture/execute/nan_inf_fmt.x: Likewise.\n+\t* gfortran.fortran-torture/execute/getarg_1.x: Remove file.\n+\n 2019-09-03  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR middle-end/91603"}, {"sha": "e81223224dcfd0e516d5d03352c8c31493860e5e", "filename": "gcc/testsuite/c-c++-common/torture/complex-sign-add.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-add.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-add.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-add.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -28,9 +28,7 @@\n void\n check_add_float (void)\n {\n-#ifndef __SPU__\n   CHECK_ADD (float, __builtin_copysignf, 0.0f, 0.0if);\n-#endif\n }\n \n void"}, {"sha": "a209161e157816afc39051e7fd4a69d06dc824a3", "filename": "gcc/testsuite/c-c++-common/torture/complex-sign-mixed-add.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-add.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-add.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-add.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -29,9 +29,7 @@\n void\n check_add_float (void)\n {\n-#ifndef __SPU__\n   CHECK_ADD (float, __builtin_copysignf, 0.0f, 0.0if);\n-#endif\n }\n \n void"}, {"sha": "f7ee48341c09eed4845a19e15688d1c96279c25b", "filename": "gcc/testsuite/c-c++-common/torture/complex-sign-mixed-div.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-div.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-div.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-div.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -20,9 +20,7 @@\n void\n check_div_float (void)\n {\n-#ifndef __SPU__\n   CHECK_DIV (float, __builtin_copysignf, 0.0f, 0.0if, 1.0f);\n-#endif\n }\n \n void"}, {"sha": "02f936b75bdd542d132685d39b87433365e9e43b", "filename": "gcc/testsuite/c-c++-common/torture/complex-sign-mixed-mul.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-mul.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -28,9 +28,7 @@\n void\n check_mul_float (void)\n {\n-#ifndef __SPU__\n   CHECK_MUL (float, __builtin_copysignf, 0.0f, 0.0if);\n-#endif\n }\n \n void"}, {"sha": "02ab4db247cb59e97a74196b00889bd5fbcd06de", "filename": "gcc/testsuite/c-c++-common/torture/complex-sign-mixed-sub.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-sub.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-sub.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mixed-sub.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -29,9 +29,7 @@\n void\n check_sub_float (void)\n {\n-#ifndef __SPU__\n   CHECK_SUB (float, __builtin_copysignf, 0.0f, 0.0if);\n-#endif\n }\n \n void"}, {"sha": "05cc4fabea41bce6a5d51e85188a8e8f26cc057d", "filename": "gcc/testsuite/c-c++-common/torture/complex-sign-mul-minus-one.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mul-minus-one.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mul-minus-one.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mul-minus-one.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -36,9 +36,7 @@\n void\n check_mul_float (void)\n {\n-#ifndef __SPU__\n   CHECK_MUL (float, __builtin_copysignf, 0.0f, 0.0if, 1.0f);\n-#endif\n }\n \n void"}, {"sha": "014d813e99ed758a18ef71bc6ce01827dbd39c9d", "filename": "gcc/testsuite/c-c++-common/torture/complex-sign-mul-one.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mul-one.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mul-one.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mul-one.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -36,9 +36,7 @@\n void\n check_mul_float (void)\n {\n-#ifndef __SPU__\n   CHECK_MUL (float, __builtin_copysignf, 0.0f, 0.0if, 1.0f);\n-#endif\n }\n \n void"}, {"sha": "08d247aa5c044df89f2a0dd4a08050b7f970b5f1", "filename": "gcc/testsuite/c-c++-common/torture/complex-sign-mul.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-mul.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -28,9 +28,7 @@\n void\n check_mul_float (void)\n {\n-#ifndef __SPU__\n   CHECK_MUL (float, __builtin_copysignf, 0.0f, 0.0if);\n-#endif\n }\n \n void"}, {"sha": "d4da14dc5f56d0ae57cc00cc647ee75c66283ae3", "filename": "gcc/testsuite/c-c++-common/torture/complex-sign-sub.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-sub.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-sub.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fcomplex-sign-sub.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -28,9 +28,7 @@\n void\n check_sub_float (void)\n {\n-#ifndef __SPU__\n   CHECK_SUB (float, __builtin_copysignf, 0.0f, 0.0if);\n-#endif\n }\n \n void"}, {"sha": "b822dc464fe19ebdbbd5148b4fe6ce421919b694", "filename": "gcc/testsuite/g++.dg/opt/temp1.C", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemp1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemp1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemp1.C?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -24,12 +24,7 @@ void *memcpy (void *dest, const void *src, __SIZE_TYPE__ n)\n }\n  \n struct T {\n-#ifdef __SPU__\n-  /* SPU returns aggregates up to 1172 bytes in registers.  */\n-  int a[300];\n-#else\n   int a[128];\n-#endif\n   T &operator+=(T const &v) __attribute__((noinline));\n   T operator+(T const &v) const { T t = *this; t += v; return t; }\n };"}, {"sha": "a15f77631a039bfb8ed68ad792f029250aa6ea2e", "filename": "gcc/testsuite/g++.dg/opt/vt1.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvt1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvt1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvt1.C?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n // Test whether vtable for S is not put into read-only section.\n // { dg-do compile { target fpic } }\n // { dg-options \"-O2 -fpic -fno-rtti\" }\n-// { dg-skip-if \"requires unsupported run-time relocation\" { spu-*-* } }\n // { dg-skip-if \"No Windows PIC\" { *-*-mingw* *-*-cygwin } }\n // Origin: Jakub Jelinek <jakub@redhat.com>\n "}, {"sha": "e41b8e0288d7380d7571e9fdde03e8caeb7cd5ca", "filename": "gcc/testsuite/g++.dg/torture/type-generic-1.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Ftype-generic-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Ftype-generic-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Ftype-generic-1.C?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -3,7 +3,6 @@\n \n /* { dg-do run } */\n /* { dg-add-options ieee } */\n-/* { dg-skip-if \"No Inf/NaN support\" { spu-*-* } } */\n /* { dg-skip-if \"No subnormal support\" { csky-*-* } { \"-mhard-float\" } } */\n \n #include \"../../gcc.dg/tg-tests.h\""}, {"sha": "95085c61374e33bd8e63e334b5612b079c53e661", "filename": "gcc/testsuite/g++.dg/warn/pr30551-2.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr30551-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr30551-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr30551-2.C?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n // PR 30551 -Wmain is enabled by -pedantic/-pedantic-errors.\n // { dg-do compile }\n // { dg-options \"-pedantic-errors\" }\n-// { dg-skip-if \"-Wmain not enabled with -pedantic on SPU\" { spu-*-* } } \n int main(char a) {} /* { dg-error \"first argument of .*main.* should be .int.\" \"int\" } */\n /* { dg-error \"main.* takes only zero or two arguments\" \"zero or two\" { target *-*-* } .-1 } */ "}, {"sha": "359b3622d6c946fb7ec26ed6b43e363d4d8c5f62", "filename": "gcc/testsuite/g++.dg/warn/pr30551.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr30551.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr30551.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr30551.C?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n // PR 30551 -Wmain is enabled by default.\n // { dg-do compile }\n // { dg-options \"\" }\n-// { dg-skip-if \"-Wmain not enabled on SPU\" { spu-*-* } } \n int main(char a) {} /* { dg-warning \"first argument of .*main.* should be .int.\" \"int\" } */\n /* { dg-warning \"main.* takes only zero or two arguments\" \"zero or two\" { target *-*-* } .-1 } */ "}, {"sha": "fdcff095d3b43f878889b6fe20485ec9d6325ca3", "filename": "gcc/testsuite/g++.old-deja/g++.jason/thunk2.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fthunk2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fthunk2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fthunk2.C?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n // { dg-do run { target fpic } }\n // { dg-options \"-fPIC\" }\n-// { dg-skip-if \"requires unsupported run-time relocation\" { spu-*-* } }\n // Test that non-variadic function calls using thunks and PIC work right.\n \n struct A {"}, {"sha": "5c2baa389e2a65a940f34001dbca86c6ee61961f", "filename": "gcc/testsuite/g++.old-deja/g++.other/comdat5.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcomdat5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcomdat5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcomdat5.C?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -2,6 +2,5 @@\n // { dg-do link { target fpic } }\n // { dg-additional-sources \" comdat5-aux.cc\" }\n // { dg-options \"-O2 -fPIC\" }\n-// { dg-skip-if \"requires unsupported run-time relocation\" { spu-*-* } }\n \n #include \"comdat4.C\""}, {"sha": "fe9d24fccf77e9eca96a72c3d0b919307a06f5f4", "filename": "gcc/testsuite/g++.old-deja/g++.other/local-alloc1.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flocal-alloc1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flocal-alloc1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flocal-alloc1.C?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n // { dg-do assemble { target fpic } }\n // { dg-options \"-O0 -fpic\" }\n-// { dg-skip-if \"requires unsupported run-time relocation\" { spu-*-* } }\n // Origin: Jakub Jelinek <jakub@redhat.com>\n \n struct bar {"}, {"sha": "073ac6a784d36357fc6aa46758a64bd8e79ac255", "filename": "gcc/testsuite/gcc.c-torture/compile/20001226-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001226-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001226-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001226-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n /* { dg-do assemble } */\n /* { dg-skip-if \"too much code for avr\" { \"avr-*-*\" } } */\n /* { dg-skip-if \"too much code for pdp11\" { \"pdp11-*-*\" } } */\n-/* { dg-xfail-if \"PR36698\" { spu-*-* } { \"-O0\" } { \"\" } } */\n /* { dg-skip-if \"\" { m32c-*-* } } */\n /* { dg-timeout-factor 4.0 } */\n "}, {"sha": "d395b8dbc9c3afdcde8684f074807f07564e27c0", "filename": "gcc/testsuite/gcc.c-torture/execute/20030222-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030222-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030222-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030222-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -3,7 +3,6 @@\n    succeeded at all.  We use volatile to make sure the long long is\n    actually truncated to int, in case a single register is wide enough\n    for a long long.  */\n-/* { dg-skip-if \"asm would require extra shift-left-4-byte\" { spu-*-* } } */\n /* { dg-skip-if \"asm requires register allocation\" { nvptx-*-* } } */\n #include <limits.h>\n "}, {"sha": "5d39d799e50447d610368d561eb959595f5a8f50", "filename": "gcc/testsuite/gcc.c-torture/execute/20031003-1.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20031003-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20031003-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20031003-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -19,14 +19,8 @@ int main()\n #if INT_MAX == 2147483647\n   if (f1() != 2147483647)\n     abort ();\n-#ifdef __SPU__\n-  /* SPU float rounds towards zero.  */\n-  if (f2() != 0x7fffff80)\n-    abort ();\n-#else\n   if (f2() != 2147483647)\n     abort ();\n-#endif\n #endif\n   return 0;\n }"}, {"sha": "649e168e0b1d8e8097aa4752a659d2ec77c23f59", "filename": "gcc/testsuite/gcc.c-torture/execute/20101011-1.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -10,9 +10,6 @@\n #elif defined (__riscv)\n   /* On RISC-V division by zero does not trap.  */\n # define DO_TEST 0\n-#elif defined (__SPU__)\n-  /* On SPU division by zero does not trap.  */\n-# define DO_TEST 0\n #elif defined (__sh__)\n   /* On SH division by zero does not trap.  */\n # define DO_TEST 0"}, {"sha": "9e62acfd2ada3efebe54687d356f9fa835af73d6", "filename": "gcc/testsuite/gcc.c-torture/execute/conversion.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fconversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fconversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fconversion.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -284,15 +284,9 @@ test_float_to_integer()\n     abort();\n   if (f2u(1.99) != 1)\n     abort();\n-#ifdef __SPU__\n-  /* SPU float rounds towards zero.  */\n-  if (f2u((float) ((~0U) >> 1)) != 0x7fffff80)\n-    abort();\n-#else\n   if (f2u((float) ((~0U) >> 1)) != (~0U) >> 1 &&\t/* 0x7fffffff */\n       f2u((float) ((~0U) >> 1)) != ((~0U) >> 1) + 1)\n     abort();\n-#endif\n   if (f2u((float) ~((~0U) >> 1)) != ~((~0U) >> 1))\t/* 0x80000000 */\n     abort();\n \n@@ -445,15 +439,9 @@ test_float_to_longlong_integer()\n     abort();\n   if (f2ull(1.99) != 1LL)\n     abort();\n-#ifdef __SPU__\n-  /* SPU float rounds towards zero.  */\n-  if (f2ull((float) ((~0ULL) >> 1)) != 0x7fffff8000000000ULL)\n-    abort();\n-#else\n   if (f2ull((float) ((~0ULL) >> 1)) != (~0ULL) >> 1 &&\t/* 0x7fffffff */\n       f2ull((float) ((~0ULL) >> 1)) != ((~0ULL) >> 1) + 1)\n     abort();\n-#endif\n   if (f2ull((float) ~((~0ULL) >> 1)) != ~((~0ULL) >> 1)) /* 0x80000000 */\n     abort();\n "}, {"sha": "73b18d1604d911a4804a94f88720d927d343fcda", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/20010114-2.x", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2F20010114-2.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2F20010114-2.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2F20010114-2.x?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,6 +0,0 @@\n-if [istarget \"spu-*-*\"] {\n-    # This doesn't work on the SPU because single precision floats are\n-    # always rounded toward 0.\n-    return 1\n-}\n-return 0"}, {"sha": "73b18d1604d911a4804a94f88720d927d343fcda", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/20030331-1.x", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2F20030331-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2F20030331-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2F20030331-1.x?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,6 +0,0 @@\n-if [istarget \"spu-*-*\"] {\n-    # This doesn't work on the SPU because single precision floats are\n-    # always rounded toward 0.\n-    return 1\n-}\n-return 0"}, {"sha": "73b18d1604d911a4804a94f88720d927d343fcda", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/920518-1.x", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2F920518-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2F920518-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2F920518-1.x?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,6 +0,0 @@\n-if [istarget \"spu-*-*\"] {\n-    # This doesn't work on the SPU because single precision floats are\n-    # always rounded toward 0.\n-    return 1\n-}\n-return 0"}, {"sha": "2f7a4ecc54a3db40bd1916e38b6ed793ead40179", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/compare-fp-1.x", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcompare-fp-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcompare-fp-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcompare-fp-1.x?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,6 +0,0 @@\n-if [istarget \"spu-*-*\"] {\n-    # The SPU single-precision floating point format does not\n-    # support Nan & Inf. \n-    return 1\n-}\n-return 0"}, {"sha": "510a30909ea8e28e448f4a6c9eba71fe9243c077", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/compare-fp-4.x", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcompare-fp-4.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcompare-fp-4.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcompare-fp-4.x?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -13,11 +13,5 @@ if [istarget \"arm*-*-vxworks*\"] {\n     }\n }\n \n-if [istarget \"spu-*-*\"] {\n-    # The SPU single-precision floating point format does not\n-    # support Nan & Inf.\n-    return 1\n-}\n-\n lappend additional_flags \"-fno-trapping-math\"\n return 0"}, {"sha": "84c193fe0e47d13f0b71eb83a159dd47d0f2e20b", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/fp-cmp-2.x", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-2.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-2.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-2.x?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -13,10 +13,4 @@ if [istarget \"arm*-*-vxworks*\"] {\n     }\n }\n \n-if [istarget \"spu-*-*\"] {\n-    # The SPU single-precision floating point format does not\n-    # support Nan & Inf.\n-    return 1\n-}\n-\n return 0"}, {"sha": "2f7a4ecc54a3db40bd1916e38b6ed793ead40179", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/fp-cmp-4f.x", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-4f.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-4f.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-4f.x?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,6 +0,0 @@\n-if [istarget \"spu-*-*\"] {\n-    # The SPU single-precision floating point format does not\n-    # support Nan & Inf. \n-    return 1\n-}\n-return 0"}, {"sha": "2f7a4ecc54a3db40bd1916e38b6ed793ead40179", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/fp-cmp-8f.x", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-8f.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-8f.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-8f.x?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,6 +0,0 @@\n-if [istarget \"spu-*-*\"] {\n-    # The SPU single-precision floating point format does not\n-    # support Nan & Inf. \n-    return 1\n-}\n-return 0"}, {"sha": "34f60f3f1c0095ae94013183e7d81d5f2edf82be", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/inf-1.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Finf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Finf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Finf-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -2,39 +2,30 @@ extern void abort (void);\n \n int main()\n {\n-#ifndef __SPU__\n-  /* The SPU single-precision floating point format does not support Inf.  */\n   float fi = __builtin_inff();\n-#endif\n   double di = __builtin_inf();\n   long double li = __builtin_infl();\n \n   float fh = __builtin_huge_valf();\n   double dh = __builtin_huge_val();\n   long double lh = __builtin_huge_vall();\n \n-#ifndef __SPU__\n   if (fi + fi != fi)\n     abort ();\n-#endif\n   if (di + di != di)\n     abort ();\n   if (li + li != li)\n     abort ();\n \n-#ifndef __SPU__\n   if (fi != fh)\n     abort ();\n-#endif\n   if (di != dh)\n     abort ();\n   if (li != lh)\n     abort ();\n \n-#ifndef __SPU__\n   if (fi <= 0)\n     abort ();\n-#endif\n   if (di <= 0)\n     abort ();\n   if (li <= 0)"}, {"sha": "50124b287361dffb4f19102d60927afb15991c22", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/inf-2.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Finf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Finf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Finf-2.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -25,9 +25,6 @@ void test(double f, double i)\n \n void testf(float f, float i)\n {\n-#ifndef __SPU__\n-  /* The SPU single-precision floating point format does not support Inf.  */\n-\n   if (f == __builtin_inff())\n     abort ();\n   if (f == -__builtin_inff())\n@@ -47,7 +44,6 @@ void testf(float f, float i)\n     abort ();\n   if (f < -__builtin_inff())\n     abort ();\n-#endif\n }\n \n void testl(long double f, long double i)"}, {"sha": "bf170819920f4ace83d62d7fb8a605c4a691797b", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/mul-subnormal-single-1.x", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fmul-subnormal-single-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fmul-subnormal-single-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fmul-subnormal-single-1.x?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -13,11 +13,6 @@ if {[istarget \"m68k-*-*\"] && [check_effective_target_coldfire_fpu]} {\n     # not aware of any system that has this.\n     set torture_execute_xfail \"m68k-*-*\"\n }\n-if [istarget \"spu-*-*\"] {\n-    # The SPU single-precision floating point format does not\n-    # support subnormals.\n-    return 1\n-}\n if { [istarget \"tic6x-*-*\"] && [check_effective_target_ti_c67x] } {\n     # C6X floating point hardware turns denormals to zero in multiplications.\n     set torture_execute_xfail \"tic6x-*-*\""}, {"sha": "ce13d7e9eed73a756bcf7b41be46c3d930d03a4c", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/rbug.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Frbug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Frbug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Frbug.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -41,14 +41,8 @@ main ()\n   k = 0x8234508000000001ULL;\n   x = s (k);\n   k = (unsigned long long) x;\n-#ifdef __SPU__\n-  /* SPU float rounds towards zero.  */\n-  if (k != 0x8234500000000000ULL)\n-    abort ();\n-#else\n   if (k != 0x8234510000000000ULL)\n     abort ();\n-#endif\n \n   exit (0);\n }"}, {"sha": "f31ec90433838ad7377b85e9de3a10994f4d68c2", "filename": "gcc/testsuite/gcc.c-torture/execute/pr39228.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr39228.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr39228.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr39228.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,5 +1,4 @@\n /* { dg-add-options ieee } */\n-/* { dg-skip-if \"No Inf/NaN support\" { spu-*-* } } */\n \n extern void abort (void);\n "}, {"sha": "98af0d4aad3a6de15aabddf9d85e2e2e2b13c69f", "filename": "gcc/testsuite/gcc.dg/20020312-2.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -96,8 +96,6 @@ extern void abort (void);\n /* No pic register.  */\n #elif defined(__m32c__)\n /* No pic register.  */\n-#elif defined(__SPU__)\n-#  define PIC_REG  \"126\"\n #elif defined (__frv__)\n # ifdef __FRV_FDPIC__\n #  define PIC_REG \"gr15\""}, {"sha": "ee03f71a7bfa2e7693e87291efd46ea97c6adbf4", "filename": "gcc/testsuite/gcc.dg/20030702-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2F20030702-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2F20030702-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20030702-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -2,7 +2,6 @@\n    correctly in combine.  */\n /* { dg-do compile { target fpic } } */\n /* { dg-options \"-O2 -fpic -fprofile-arcs\" } */\n-/* { dg-skip-if \"requires unsupported run-time relocation\" { spu-*-* } } */\n /* { dg-require-profiling \"-fprofile-generate\" } */\n \n int fork (void);"}, {"sha": "bec56fd8492d331c21d6a539f06109e77c7a63d9", "filename": "gcc/testsuite/gcc.dg/and-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fand-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fand-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fand-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,8 +1,8 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2\" } */\n-/* { dg-final { scan-assembler \"and\" { target powerpc*-*-* spu-*-* } } } */\n-/* There should be no nand for this testcase (for either PPC or SPU). */\n-/* { dg-final { scan-assembler-not \"nand\" { target powerpc*-*-* spu-*-* } } } */\n+/* { dg-final { scan-assembler \"and\" { target powerpc*-*-* } } } */\n+/* There should be no nand for this testcase (for PPC). */\n+/* { dg-final { scan-assembler-not \"nand\" { target powerpc*-*-* } } } */\n \n int f(int y)\n {"}, {"sha": "b075fcd85f729713021e4fef6a262426c1ac407f", "filename": "gcc/testsuite/gcc.dg/builtin-inf-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-inf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-inf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-inf-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n \n float fi = __builtin_inff();\n-/* { dg-error \"does not support infinity\" \"INF unsupported\" { target pdp11*-*-* vax-*-* spu-*-* } .-1 } */\n+/* { dg-error \"does not support infinity\" \"INF unsupported\" { target pdp11*-*-* vax-*-* } .-1 } */\n double di = __builtin_inf();\n /* { dg-error \"does not support infinity\" \"INF unsupported\" { target pdp11*-*-* vax-*-* } .-1 } */\n long double li = __builtin_infl();"}, {"sha": "6128642b5b6e0361908e8cfbb6ea64568f8b09ec", "filename": "gcc/testsuite/gcc.dg/builtins-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -144,7 +144,7 @@ FPTEST2ARG2_REENT (gamma, int *) /* gamma_r */\n FPTEST0     (huge_val)\n FPTEST2     (hypot)\n FPTEST1     (ilogb)\n-FPTEST0     (inf)  /* { dg-warning \"target format does not support infinity\" \"inf\" {target pdp11*-*-* spu-*-*} } */\n+FPTEST0     (inf)  /* { dg-warning \"target format does not support infinity\" \"inf\" {target pdp11*-*-* } } */\n FPTEST1     (j0)\n FPTEST1     (j1)\n FPTEST2ARG1 (jn, int)"}, {"sha": "24a34ed35bbd7a46c92d2c9d86dc68b6c23b8cde", "filename": "gcc/testsuite/gcc.dg/builtins-43.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-43.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -12,20 +12,15 @@ int\n main ()\n {\n   double nan = __builtin_nan (\"\");\n-#ifndef __SPU__\n-  /* The SPU single-precision floating point format does not support NANs.  */\n   float nanf = __builtin_nanf (\"\");\n-#endif\n   long double nanl = __builtin_nanl (\"\");\n \n   if (!__builtin_isnan (nan))\n     link_error ();\n-#ifndef __SPU__\n   if (!__builtin_isnan (nanf))\n     link_error ();\n   if (!__builtin_isnanf (nanf))\n     link_error ();\n-#endif\n   if (!__builtin_isnan (nanl))\n     link_error ();\n   if (!__builtin_isnanl (nanl))"}, {"sha": "4a123502dd09da1aa705e0fb8a7e643006d7be80", "filename": "gcc/testsuite/gcc.dg/builtins-44.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-44.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -13,31 +13,24 @@ int\n main ()\n {\n   double pinf = __builtin_inf ();\n-#ifndef __SPU__\n-  /* The SPU single-precision floating point format does not support Inf.  */\n   float pinff = __builtin_inff ();\n-#endif\n   long double pinfl = __builtin_infl ();\n \n   if (__builtin_isinf (pinf) != 1)\n     link_error ();\n-#ifndef __SPU__\n   if (__builtin_isinf (pinff) != 1)\n     link_error ();\n   if (__builtin_isinff (pinff) != 1)\n     link_error ();\n-#endif\n   if (__builtin_isinf (pinfl) != 1)\n     link_error ();\n   if (__builtin_isinfl (pinfl) != 1)\n     link_error ();\n \n   if (__builtin_isinf_sign (-pinf) != -1)\n     link_error ();\n-#ifndef __SPU__\n   if (__builtin_isinf_sign (-pinff) != -1)\n     link_error ();\n-#endif\n   if (__builtin_isinf_sign (-pinfl) != -1)\n     link_error ();\n "}, {"sha": "871e802e191d707eab9027f192681416ce8aa14e", "filename": "gcc/testsuite/gcc.dg/builtins-45.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-45.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -13,34 +13,24 @@ int\n main ()\n {\n   double nan = __builtin_nan (\"\");\n-#ifndef __SPU__\n-  /* The SPU single-precision floating point format does not support NANs.  */\n   float nanf = __builtin_nanf (\"\");\n-#endif\n   long double nanl = __builtin_nanl (\"\");\n \n   double pinf = __builtin_inf ();\n-#ifndef __SPU__\n-  /* The SPU single-precision floating point format does not support Inf.  */\n   float pinff = __builtin_inff ();\n-#endif\n   long double pinfl = __builtin_infl ();\n \n   if (__builtin_finite (pinf))\n     link_error ();\n-#ifndef __SPU__\n   if (__builtin_finitef (pinff))\n     link_error ();\n-#endif\n   if (__builtin_finitel (pinfl))\n     link_error ();\n \n   if (__builtin_finite (nan))\n     link_error ();\n-#ifndef __SPU__\n   if (__builtin_finitef (nanf))\n     link_error ();\n-#endif\n   if (__builtin_finitel (nanl))\n     link_error ();\n "}, {"sha": "0142c3d8f934bcbe9a36a2029370cea18ce8f22a", "filename": "gcc/testsuite/gcc.dg/float-range-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -4,7 +4,6 @@\n /* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n /* { dg-do compile } */\n /* { dg-options \"-ansi -pedantic-errors -Woverflow\" } */\n-/* { dg-skip-if \"No Inf support\" { spu-*-* } } */\n \n void\n f (void)"}, {"sha": "e386bbab36b3ead63d2abe829333240338e9809f", "filename": "gcc/testsuite/gcc.dg/float-range-3.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-3.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n /* PR 23572 : warnings for out of range floating-point constants.  */\n /* { dg-do compile } */\n /* { dg-options \"-std=c99\" } */\n-/* { dg-skip-if \"No Inf support\" { spu-*-* } } */\n #include <math.h>\n \n #ifndef INFINITY"}, {"sha": "c4faaa067b2041b502869005e9fb33e121c9e647", "filename": "gcc/testsuite/gcc.dg/float-range-4.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-4.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n /* PR 23572 : warnings for out of range floating-point constants.  */\n /* { dg-do compile } */\n /* { dg-options \"-Wno-overflow -std=c99\" } */\n-/* { dg-skip-if \"No Inf support\" { spu-*-* } } */\n #include <math.h>\n \n #ifndef INFINITY"}, {"sha": "f3e06ba636617e50d76ab180c6d5d3d88d6a182d", "filename": "gcc/testsuite/gcc.dg/float-range-5.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat-range-5.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -2,7 +2,6 @@\n    Test that they are NOT pedantic warnings.  */\n /* { dg-do compile } */\n /* { dg-options \"-pedantic-errors -std=c99\" } */\n-/* { dg-skip-if \"No Inf support\" { spu-*-* } } */\n #include <math.h>\n \n #ifndef INFINITY"}, {"sha": "108df4e3155f393f67a59c7abc3da85a109b28bc", "filename": "gcc/testsuite/gcc.dg/fold-overflow-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-overflow-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target int32plus } */\n-/* { dg-skip-if \"No Inf support\" { spu-*-* } } */\n /* { dg-options \"-O -ftrapping-math\" } */\n \n /* There should be exactly 2 +Inf in the assembly file.  */"}, {"sha": "e5a2562c84f7c0e1b2cafbdd4a696341d62a8505", "filename": "gcc/testsuite/gcc.dg/format/ms_unnamed-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fms_unnamed-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fms_unnamed-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fms_unnamed-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -10,7 +10,7 @@\n \n /* Definition of TItype follows same logic as in gcc.dg/titype-1.c,\n    but must be a #define to avoid giving the type a name.  */\n-#if (defined(__LP64__) && !defined(__hppa__)) || defined(__SPU__)\n+#if defined(__LP64__) && !defined(__hppa__)\n #define TItype int __attribute__ ((mode (TI)))\n #else\n #define TItype long"}, {"sha": "4b24bec7164200cfcedf8b79e5745727ffb3e8c4", "filename": "gcc/testsuite/gcc.dg/format/unnamed-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Funnamed-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Funnamed-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Funnamed-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -10,7 +10,7 @@\n \n /* Definition of TItype follows same logic as in gcc.dg/titype-1.c,\n    but must be a #define to avoid giving the type a name.  */\n-#if (defined(__LP64__) && !defined(__hppa__)) || defined(__SPU__)\n+#if defined(__LP64__) && !defined(__hppa__)\n #define TItype int __attribute__ ((mode (TI)))\n #else\n #define TItype long"}, {"sha": "3276ad463784816d29e03d486c96f64f9c356875", "filename": "gcc/testsuite/gcc.dg/hex-round-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fhex-round-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fhex-round-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fhex-round-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n /* Test for hexadecimal float rounding: bug 21720.  */\n /* { dg-do link } */\n /* { dg-options \"-O -std=gnu99\" } */\n-/* { dg-skip-if \"SPU float rounds towards zero\" { spu-*-* } } */\n \n #include <float.h>\n "}, {"sha": "ba9b8bf3d022c3dffe4d793c4a7bde4f46cfcac9", "filename": "gcc/testsuite/gcc.dg/hex-round-2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fhex-round-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fhex-round-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fhex-round-2.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -2,7 +2,6 @@\n    in number.  */\n /* { dg-do link } */\n /* { dg-options \"-O -std=gnu99\" } */\n-/* { dg-skip-if \"SPU float rounds towards zero\" { spu-*-* } } */\n \n #include <float.h>\n "}, {"sha": "63a47106e2744df441e90f5a8746681ad60d67f3", "filename": "gcc/testsuite/gcc.dg/lower-subreg-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do compile { target { ! { mips64 || { aarch64*-*-* arm*-*-* ia64-*-* sparc*-*-* spu-*-* tilegx-*-* } } } } } */\n+/* { dg-do compile { target { ! { mips64 || { aarch64*-*-* arm*-*-* ia64-*-* sparc*-*-* tilegx-*-* } } } } } */\n /* { dg-options \"-O -fdump-rtl-subreg1\" } */\n /* { dg-additional-options \"-mno-stv\" { target ia32 } } */\n /* { dg-skip-if \"\" { { i?86-*-* x86_64-*-* } && x32 } } */"}, {"sha": "6c66ecf8835782da356c73515580377ee3dea36b", "filename": "gcc/testsuite/gcc.dg/nrv3.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fnrv3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fnrv3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnrv3.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -3,12 +3,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-O -fdump-tree-optimized\" } */\n \n-#ifdef __SPU__\n-/* SPU returns aggregates up to 1172 bytes in registers.  */\n-typedef struct { int x[300]; void *y; } S;\n-#else\n typedef struct { int x[20]; void *y; } S;\n-#endif\n typedef struct { int a; S b; } T;\n S nrv_candidate (void);\n void use_result (S, int);"}, {"sha": "17bf722bfeb7661c418e60e6ef4879c3f5d4af7e", "filename": "gcc/testsuite/gcc.dg/pr15784-3.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15784-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15784-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15784-3.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,5 +1,4 @@\n /* { dg-do compile } */\n-/* { dg-skip-if \"No NaN support\" { spu-*-* } } */\n /* SH4 without -mieee defaults to -ffinite-math-only.  */\n /* { dg-options \"-fdump-tree-gimple -fno-finite-math-only\" } */\n /* Test for folding abs(x) where appropriate.  */"}, {"sha": "1c3566c61843ed4c9e62b7af512011275fefa704", "filename": "gcc/testsuite/gcc.dg/pr27095.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr27095.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr27095.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr27095.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -19,7 +19,7 @@ main (int argc, char **argv)\n   memset (x, argc, strlen (x));\n   return 0;\n }\n-/* { dg-final { scan-assembler-not \"(?n)strlen\\(.*\\n\\)+.*strlen\" { target { ! { powerpc*-*-darwin* hppa*-*-hpux* ia64-*-hpux* alpha*-*-* spu-*-* tic6x-*-* } } } } } */\n+/* { dg-final { scan-assembler-not \"(?n)strlen\\(.*\\n\\)+.*strlen\" { target { ! { powerpc*-*-darwin* hppa*-*-hpux* ia64-*-hpux* alpha*-*-* tic6x-*-* } } } } } */\n /* hppa*-*-hpux* has an IMPORT statement for strlen (plus the branch). */\n /* *-*-darwin* has something similar. */\n /* tic6x emits a comment at the point where the delayed branch happens.  */\n@@ -29,5 +29,3 @@ main (int argc, char **argv)\n /* { dg-final { scan-assembler-not \"(?n)strlen\\(.*\\n\\)+.*strlen\\(.*\\n\\)+.*strlen\\(.*\\n\\)+.*strlen\" { target ia64-*-hpux* } } } */\n /* alpha-*-* has a GOT load and the call.  */\n /* { dg-final { scan-assembler-not \"(?n)jsr .*,strlen\\(.*\\n\\)+.*jsr .*,strlen\" { target alpha*-*-* } } } */\n-/* spu-*-* has a branch hint and the call.  */\n-/* { dg-final { scan-assembler-not \"(?n)brsl.*,strlen\\(.*\\n\\)+.*brsl.*,strlen\" { target spu-*-* } } } */"}, {"sha": "a6d693e224caba15a39cffb87cfc99730ba9dd6e", "filename": "gcc/testsuite/gcc.dg/pr28243.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28243.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28243.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28243.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -4,7 +4,6 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target fpic } */\n /* { dg-options \"-O2 -ftracer -fPIC\" } */\n-/* { dg-skip-if \"requires unsupported run-time relocation\" { spu-*-* } } */\n \n struct displayfuncs {\n   void (*init) ();"}, {"sha": "a56b4abf8e51f54d6cfcdd981afcc1c5ef248ece", "filename": "gcc/testsuite/gcc.dg/pr28796-2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-2.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n /* { dg-do run } */\n /* { dg-options \"-O2 -funsafe-math-optimizations -fno-finite-math-only -DUNSAFE\" } */\n /* { dg-add-options ieee } */\n-/* { dg-skip-if \"No Inf/NaN support\" { spu-*-* } } */\n \n #include \"tg-tests.h\"\n "}, {"sha": "9151b1e3adaea81b50d0d2ec05dbb8510934925e", "filename": "gcc/testsuite/gcc.dg/pr30551-3.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30551-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30551-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30551-3.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n /* PR 30551 -Wmain is enabled by -pedantic-errors. */\n /* { dg-do compile } */\n /* { dg-options \"-pedantic-errors\" } */\n-/* { dg-skip-if \"-Wmain not enabled with -pedantic on SPU\" { spu-*-* } } */\n void main(char a) {} /* { dg-error \"first argument of .main. should be .int.\" \"int\" } */\n /* { dg-error \".main. takes only zero or two arguments\" \"zero or two\" { target *-*-* } .-1 } */ \n /* { dg-error \"return type of .main. is not .int.\" \"return type\" { target *-*-* } .-2 } */ "}, {"sha": "fa6bf0c6a9fd5b9f17cb109ab3532d48da50bf22", "filename": "gcc/testsuite/gcc.dg/pr30551-6.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30551-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30551-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30551-6.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n /* PR 30551 -Wmain is enabled by -pedantic. */\n /* { dg-do compile } */\n /* { dg-options \"-pedantic\" } */\n-/* { dg-skip-if \"-Wmain not enabled with -pedantic on SPU\" { spu-*-* } } */\n void main(char a) {} /* { dg-warning \"first argument of .main. should be .int.\" \"int\" } */\n /* { dg-warning \".main. takes only zero or two arguments\" \"zero or two\" { target *-*-* } .-1 } */ \n /* { dg-warning \"return type of .main. is not .int.\" \"return type\" { target *-*-* } .-2 } */ "}, {"sha": "c7b108e8590a27862a84ca092602b695e4b0abd2", "filename": "gcc/testsuite/gcc.dg/pr30551.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30551.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30551.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30551.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n /* PR 30551 -Wmain is enabled by -Wall.  */\n /* { dg-do compile } */\n /* { dg-options \"-Wall\" } */\n-/* { dg-skip-if \"-Wmain not enabled with -Wall on SPU\" { spu-*-* } } */\n void main(char a) {} /* { dg-warning \"first argument of .main. should be .int.\" \"int\" } */\n /* { dg-warning \".main. takes only zero or two arguments\" \"zero or two\" { target *-*-* } .-1 } */ \n /* { dg-warning \"return type of .main. is not .int.\" \"return type\" { target *-*-* } .-2 } */ "}, {"sha": "585212d1fc0180d76814bf599fa3926004ac4b86", "filename": "gcc/testsuite/gcc.dg/pr70317.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr70317.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr70317.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr70317.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/70317 */\n /* { dg-do compile } */\n-/* { dg-skip-if \"No NaN support\" { spu*-*-* vax*-*-* pdp11*-*-* } } */\n+/* { dg-skip-if \"No NaN support\" { vax*-*-* pdp11*-*-* } } */\n /* { dg-options \"-O2 -fdump-tree-optimized\" } */\n /* { dg-additional-options \"-fno-common\" { target hppa*-*-hpux* } } */\n "}, {"sha": "26868c34c71af90e4dda7aed496e2c2dff515827", "filename": "gcc/testsuite/gcc.dg/sms-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -40,5 +40,5 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"SMS succeeded\" 1 \"sms\"  { target powerpc*-*-* spu-*-* } } } */\n+/* { dg-final { scan-rtl-dump-times \"SMS succeeded\" 1 \"sms\"  { target powerpc*-*-* } } } */\n "}, {"sha": "7b96f5502628ab9a54a73006ae7c560fefbecf42", "filename": "gcc/testsuite/gcc.dg/sms-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-2.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -32,4 +32,4 @@ fun (nb)\n       }\n }\n \n-/* { dg-final { scan-rtl-dump-times \"SMS loop many exits\" 1 \"sms\" { target spu-*-* powerpc*-*-* } } } */\n+/* { dg-final { scan-rtl-dump-times \"SMS loop many exits\" 1 \"sms\" { target powerpc*-*-* } } } */"}, {"sha": "822b516af2f3739effacb7792db52f8f1ea486ec", "filename": "gcc/testsuite/gcc.dg/sms-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-3.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -39,5 +39,5 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"SMS succeeded\" 1 \"sms\" { target spu-*-* powerpc*-*-* } } } */\n+/* { dg-final { scan-rtl-dump-times \"SMS succeeded\" 1 \"sms\" { target powerpc*-*-* } } } */\n "}, {"sha": "f5ebb55a2f4b8bc3bcedc7a017decf8460483dd7", "filename": "gcc/testsuite/gcc.dg/sms-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-4.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -35,5 +35,5 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"SMS succeeded\" 1 \"sms\" { target spu-*-* powerpc*-*-* } } } */\n+/* { dg-final { scan-rtl-dump-times \"SMS succeeded\" 1 \"sms\" { target powerpc*-*-* } } } */\n "}, {"sha": "9ce36a0b69934df421c0c5c96b7ee00a2ae212a8", "filename": "gcc/testsuite/gcc.dg/sms-5.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-5.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -46,6 +46,5 @@ int main ()\n   return 0;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"SMS succeeded\" 1 \"sms\" { target spu-*-* } } } */\n \n "}, {"sha": "e57e01539eb56f6361af168727526a06438d9c3f", "filename": "gcc/testsuite/gcc.dg/sms-6.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-6.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -42,5 +42,4 @@ int main()\n   return 0;        \n }\n \n-/* { dg-final { scan-rtl-dump-times \"SMS succeeded\" 1 \"sms\" { target spu-*-* } } } */\n /* { dg-final { scan-rtl-dump-times \"SMS succeeded\" 3 \"sms\" { target powerpc*-*-* } } } */"}, {"sha": "4fd9bf1e916050aeec4af0eee28ddeed696c0231", "filename": "gcc/testsuite/gcc.dg/sms-7.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-7.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -44,5 +44,4 @@ int main()\n   return 0;        \n }\n \n-/* { dg-final { scan-rtl-dump-times \"SMS succeeded\" 1 \"sms\" { target spu-*-* } } } */\n "}, {"sha": "be1254a7348d8b9fedec182c186653746e70c4fa", "filename": "gcc/testsuite/gcc.dg/stack-usage-1.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -79,8 +79,6 @@\n #  define SIZE 96  /* 256 - 160 bytes for register save area */\n #elif defined (__s390__)\n #  define SIZE 160 /* 256 -  96 bytes for register save area */\n-#elif defined (__SPU__)\n-#  define SIZE 224\n #elif defined (__epiphany__)\n #  define SIZE (256 - __EPIPHANY_STACK_OFFSET__)\n #elif defined (__RL78__)"}, {"sha": "65239490628686b702ce3dcc88b3049363152641", "filename": "gcc/testsuite/gcc.dg/strlenopt-73.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-73.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-73.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-73.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -89,7 +89,7 @@ void test_copy_cond_unequal_length_i64 (void)\n \n /* The following tests assume GCC transforms the memcpy calls into\n    int128_t assignments which it does only on targets that define\n-   the MOVE_MAX macro to 16.  That's only spu, s390, and i386 with\n+   the MOVE_MAX macro to 16.  That's only s390 and i386 with\n    int128_t support.  */\n \n const char a8[32] = \"01234567\";"}, {"sha": "31c01a681a3196abc850ed11ac2998b738ac89cf", "filename": "gcc/testsuite/gcc.dg/titype-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftitype-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftitype-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftitype-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run } */\n \n /* Not all platforms support TImode integers.  */\n-#if (defined(__LP64__) && !defined(__hppa__)) || defined(_WIN64) || defined(__SPU__)\n+#if (defined(__LP64__) && !defined(__hppa__)) || defined(_WIN64)\n typedef int TItype __attribute__ ((mode (TI)));\n #else\n typedef long TItype;"}, {"sha": "84eedfdb226382e9745ca7b56fcc1621359107d9", "filename": "gcc/testsuite/gcc.dg/tls/thr-cse-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-cse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-cse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-cse-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -18,10 +18,9 @@ int foo (int b, int c, int d)\n   return a;\n }\n \n-/* { dg-final { scan-assembler-not \"emutls_get_address.*emutls_get_address.*\" { target { ! { \"*-wrs-vxworks\"  \"*-*-darwin8\"  \"hppa*-*-hpux*\" \"spu-*-*\" \"i?86-*-mingw*\" \"x86_64-*-mingw*\" visium-*-* } } } } } */\n+/* { dg-final { scan-assembler-not \"emutls_get_address.*emutls_get_address.*\" { target { ! { \"*-wrs-vxworks\"  \"*-*-darwin8\"  \"hppa*-*-hpux*\" \"i?86-*-mingw*\" \"x86_64-*-mingw*\" visium-*-* } } } } } */\n /* { dg-final { scan-assembler-not \"call\\tL___emutls_get_address.stub.*call\\tL___emutls_get_address.stub.*\" { target \"*-*-darwin8\" } } } */\n /* { dg-final { scan-assembler-not \"(b,l|bl) __emutls_get_address.*(b,l|bl) __emutls_get_address.*\" { target \"hppa*-*-hpux*\" } } } */\n-/* { dg-final { scan-assembler-not \"(brsl|brasl)\\t__emutls_get_address.*(brsl|brasl)\\t__emutls_get_address.*\" { target spu-*-* } } } */\n /* { dg-final { scan-assembler-not \"tls_lookup.*tls_lookup.*\" { target *-wrs-vxworks } } } */\n /* { dg-final { scan-assembler-not \"call\\t___emutls_get_address.*call\\t___emutls_get_address\" { target \"i?86-*-mingw*\" } } } */\n /* { dg-final { scan-assembler-not \"call\\t__emutls_get_address.*call\\t__emutls_get_address\" { target \"x86_64-*-mingw*\" } } } */"}, {"sha": "c5e5d2a7fc6df19a19002e4476c6dd8510489ed7", "filename": "gcc/testsuite/gcc.dg/torture/builtin-attr-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-attr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-attr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-attr-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -339,7 +339,7 @@ FPTEST2            (fmod)\n BUILTIN_FPTEST0    (huge_val)\n FPTEST2            (hypot)\n FPTEST1T           (ilogb, int)\n-BUILTIN_FPTEST0    (inf) /* { dg-warning \"does not support infinity\" \"INF unsupported\" { target vax-*-* pdp11-*-* spu-*-* } } */\n+BUILTIN_FPTEST0    (inf) /* { dg-warning \"does not support infinity\" \"INF unsupported\" { target vax-*-* pdp11-*-* } } */\n FPTEST1            (j0)\n FPTEST1            (j1)\n FPTEST2ARG1        (jn, int)"}, {"sha": "f0d3dd32cf5da08fadfcc1d1db9b226cdb242736", "filename": "gcc/testsuite/gcc.dg/torture/builtin-complex-1.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-complex-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-complex-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-complex-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -19,13 +19,11 @@ extern void abort (void);\n       abort ();\t\t\t\t\t\t\t\t\\\n   } while (0)\n \n-#ifndef __SPU__\n void\n comparef (float a, float b)\n {\n   COMPARE_BODY (a, b, float, __builtin_copysignf);\n }\n-#endif\n \n void\n compare (double a, double b)\n@@ -39,14 +37,12 @@ comparel (long double a, long double b)\n   COMPARE_BODY (a, b, long double, __builtin_copysignl);\n }\n \n-#ifndef __SPU__\n void\n comparecf (_Complex float a, float r, float i)\n {\n   comparef (__real__ a, r);\n   comparef (__imag__ a, i);\n }\n-#endif\n \n void\n comparec (_Complex double a, double r, double i)\n@@ -95,10 +91,8 @@ comparecl (_Complex long double a, long double r, long double i)\n void\n check_float (void)\n {\n-#ifndef __SPU__\n   ALL_CHECKS (0.0f, -0.0f, __builtin_nanf(\"\"), __builtin_inff(),\n \t      float, comparecf);\n-#endif\n }\n \n void"}, {"sha": "c8a3f517f92b78a5d71a66b19aab8cfa43a93145", "filename": "gcc/testsuite/gcc.dg/torture/builtin-cproj-1.c", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-cproj-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-cproj-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-cproj-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -18,11 +18,7 @@ extern void link_error(int);\n #define CPROJ(X) __builtin_cproj(X)\n #define CPROJF(X) __builtin_cprojf(X)\n #define CPROJL(X) __builtin_cprojl(X)\n-#ifndef __SPU__\n #define INF __builtin_inff()\n-#else\n-#define INF __builtin_inf()\n-#endif\n #define I 1i\n #define CPSGN(X,Y) __builtin_copysignf((X),(Y))\n #define CIMAG(X) __builtin_cimagf(X)\n@@ -36,7 +32,6 @@ extern void link_error(int);\n \n /* Test that (cproj(X) == ZERO+Inf) and that the signs of the\n    imaginary parts match.  ZERO is +/- 0i.  */\n-#ifndef __SPU__\n #define TEST_CST_INF(X,ZERO) do { \\\n   if (CPROJF(X) != ZERO+INF || CKSGN_I(CPROJF(X),ZERO+INF)) \\\n     link_error(__LINE__); \\\n@@ -45,14 +40,6 @@ extern void link_error(int);\n   if (CPROJL(X) != ZERO+INF || CKSGN_I(CPROJL(X),ZERO+INF)) \\\n     link_error(__LINE__); \\\n } while (0)\n-#else\n-#define TEST_CST_INF(X,ZERO) do { \\\n-  if (CPROJ(X) != ZERO+INF || CKSGN_I(CPROJ(X),ZERO+INF)) \\\n-    link_error(__LINE__); \\\n-  if (CPROJL(X) != ZERO+INF || CKSGN_I(CPROJL(X),ZERO+INF)) \\\n-    link_error(__LINE__); \\\n-} while (0)\n-#endif\n \n /* Test that (cproj(X) == X) for all finite (X).  */\n #define TEST_CST(X) do { \\\n@@ -62,7 +49,6 @@ extern void link_error(int);\n \n /* Test that cproj(X + I*INF) -> (ZERO + INF), where ZERO is +-0i.\n    NEG is either blank or a minus sign when ZERO is negative.  */\n-#ifndef __SPU__\n #define TEST_IMAG_INF(NEG,ZERO) do { \\\n   if (CPROJF(f+I*NEG INF) != ZERO+INF \\\n       || CKSGN_I (CPROJF(f+I*NEG INF), ZERO+INF)) \\\n@@ -74,19 +60,8 @@ extern void link_error(int);\n       || CKSGN_I (CPROJL(ld+I*NEG INF), ZERO+INF)) \\\n     link_error(__LINE__); \\\n } while (0)\n-#else\n-#define TEST_IMAG_INF(NEG,ZERO) do { \\\n-  if (CPROJ(d+I*NEG INF) != ZERO+INF \\\n-      || CKSGN_I (CPROJ(d+I*NEG INF), ZERO+INF)) \\\n-    link_error(__LINE__); \\\n-  if (CPROJL(ld+I*NEG INF) != ZERO+INF \\\n-      || CKSGN_I (CPROJL(ld+I*NEG INF), ZERO+INF)) \\\n-    link_error(__LINE__); \\\n-} while (0)\n-#endif\n \n /* Like TEST_IMAG_INF, but check that side effects are honored.  */\n-#ifndef __SPU__\n #define TEST_IMAG_INF_SIDE_EFFECT(NEG,ZERO) do { \\\n   int side = 4; \\\n   if (CPROJF(++side+I*NEG INF) != ZERO+INF \\\n@@ -101,23 +76,9 @@ extern void link_error(int);\n   if (side != 10) \\\n     link_error(__LINE__); \\\n } while (0)\n-#else\n-#define TEST_IMAG_INF_SIDE_EFFECT(NEG,ZERO) do { \\\n-  int side = 4; \\\n-  if (CPROJ(++side+I*NEG INF) != ZERO+INF \\\n-      || CKSGN_I (CPROJ(++side+I*NEG INF), ZERO+INF)) \\\n-    link_error(__LINE__); \\\n-  if (CPROJL(++side+I*NEG INF) != ZERO+INF \\\n-      || CKSGN_I (CPROJL(++side+I*NEG INF), ZERO+INF)) \\\n-    link_error(__LINE__); \\\n-  if (side != 8) \\\n-    link_error(__LINE__); \\\n-} while (0)\n-#endif\n \n /* Test that cproj(INF, POSITIVE) -> INF+0i.  NEG is either blank or a\n    minus sign to test negative INF.  */\n-#ifndef __SPU__\n #define TEST_REAL_INF(NEG) do { \\\n   __real cf = NEG INF; \\\n   __imag cf = (x ? 4 : 5); \\\n@@ -135,23 +96,8 @@ extern void link_error(int);\n       || CKSGN_I (CPROJL(cld), INF)) \\\n     link_error(__LINE__); \\\n } while (0)\n-#else\n-#define TEST_REAL_INF(NEG) do { \\\n-  __real cd = NEG INF; \\\n-  __imag cd = (x ? 4 : 5); \\\n-  if (CPROJ(cd) != INF \\\n-      || CKSGN_I (CPROJ(cd), INF)) \\\n-    link_error(__LINE__); \\\n-  __real cld = NEG INF; \\\n-  __imag cld = (x ? 4 : 5); \\\n-  if (CPROJL(cld) != INF \\\n-      || CKSGN_I (CPROJL(cld), INF)) \\\n-    link_error(__LINE__); \\\n-} while (0)\n-#endif\n \n /* Like TEST_REAL_INF, but check that side effects are honored.  */\n-#ifndef __SPU__\n #define TEST_REAL_INF_SIDE_EFFECT(NEG) do { \\\n   int side = -9; \\\n   __real cf = NEG INF; \\\n@@ -172,23 +118,6 @@ extern void link_error(int);\n   if (side != -3) \\\n     link_error(__LINE__); \\\n } while (0)\n-#else\n-#define TEST_REAL_INF_SIDE_EFFECT(NEG) do { \\\n-  int side = -9; \\\n-  __real cd = NEG INF; \\\n-  __imag cd = (x ? 4 : 5); \\\n-  if (CPROJ((++side,cd)) != INF \\\n-      || CKSGN_I (CPROJ((++side,cd)), INF)) \\\n-    link_error(__LINE__); \\\n-  __real cld = NEG INF; \\\n-  __imag cld = (x ? 4 : 5); \\\n-  if (CPROJL((++side,cld)) != INF \\\n-      || CKSGN_I (CPROJL((++side,cld)), INF)) \\\n-    link_error(__LINE__); \\\n-  if (side != -5) \\\n-    link_error(__LINE__); \\\n-} while (0)\n-#endif\n \n void foo (_Complex long double cld, _Complex double cd, _Complex float cf,\n \t  long double ld, double d, float f, int x)"}, {"sha": "2d1c1847b267f627c1ac02523293bde901df5c7e", "filename": "gcc/testsuite/gcc.dg/torture/builtin-frexp-1.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-frexp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-frexp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-frexp-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -54,7 +54,6 @@ extern void link_error(int);\n \n /* Test that FUNCRES(frexp(NEG FUNCARG(ARGARG),&i)) is false.  Check\n    the sign as well.  Ensure side-effects are evaluated in i.  */\n-#ifndef __SPU__\n #define TESTIT_FREXP2(NEG,FUNCARG,ARGARG,FUNCRES) do { \\\n   int i=5; \\\n   if (!__builtin_##FUNCRES##f(__builtin_frexpf(NEG __builtin_##FUNCARG##f(ARGARG),&i)) \\\n@@ -70,20 +69,6 @@ extern void link_error(int);\n       || CKEXP(i,8)) \\\n     link_error(__LINE__); \\\n   } while (0)\n-#else\n-#define TESTIT_FREXP2(NEG,FUNCARG,ARGARG,FUNCRES) do { \\\n-  int i=6; \\\n-  /* SPU single-precision floating point format does not support Inf or Nan.  */ \\\n-  if (!__builtin_##FUNCRES(__builtin_frexp(NEG __builtin_##FUNCARG(ARGARG),&i)) \\\n-      || CKSGN(__builtin_frexp(NEG __builtin_##FUNCARG(ARGARG),(i++,&i)), NEG __builtin_##FUNCARG(ARGARG)) \\\n-      || CKEXP(i,7)) \\\n-    link_error(__LINE__); \\\n-  if (!__builtin_##FUNCRES##l(__builtin_frexpl(NEG __builtin_##FUNCARG##l(ARGARG),&i)) \\\n-      || CKSGN_L(__builtin_frexpl(NEG __builtin_##FUNCARG##l(ARGARG),(i++,&i)), NEG __builtin_##FUNCARG##l(ARGARG)) \\\n-      || CKEXP(i,8)) \\\n-    link_error(__LINE__); \\\n-  } while (0)\n-#endif\n \n void __attribute__ ((__noinline__))\n foo(void)"}, {"sha": "eb32546d90c50c77898bee66d52280df0ba42b8e", "filename": "gcc/testsuite/gcc.dg/torture/builtin-ldexp-1.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-ldexp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-ldexp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-ldexp-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -47,7 +47,6 @@ extern void link_error(int);\n \n /* Test that FUNCRES(FUNC(NEG FUNCARG(ARGARG),ARG2)) is false.  Check\n    the sign as well.  */\n-#ifndef __SPU__\n #define TESTIT3(FUNC,NEG,FUNCARG,ARGARG,ARG2,FUNCRES) do { \\\n   if (!__builtin_##FUNCRES##f(__builtin_##FUNC##f(NEG __builtin_##FUNCARG##f(ARGARG),ARG2)) \\\n       || CKSGN_F(__builtin_##FUNC##f(NEG __builtin_##FUNCARG##f(ARGARG),ARG2), NEG __builtin_##FUNCARG##f(ARGARG))) \\\n@@ -59,17 +58,6 @@ extern void link_error(int);\n       || CKSGN_L(__builtin_##FUNC##l(NEG __builtin_##FUNCARG##l(ARGARG),ARG2), NEG __builtin_##FUNCARG##l(ARGARG))) \\\n     link_error(__LINE__); \\\n   } while (0)\n-#else\n-#define TESTIT3(FUNC,NEG,FUNCARG,ARGARG,ARG2,FUNCRES) do { \\\n-  /* SPU single-precision floating point format does not support Inf or Nan.  */ \\\n-  if (!__builtin_##FUNCRES(__builtin_##FUNC(NEG __builtin_##FUNCARG(ARGARG),ARG2)) \\\n-      || CKSGN(__builtin_##FUNC(NEG __builtin_##FUNCARG(ARGARG),ARG2), NEG __builtin_##FUNCARG(ARGARG))) \\\n-    link_error(__LINE__); \\\n-  if (!__builtin_##FUNCRES##l(__builtin_##FUNC##l(NEG __builtin_##FUNCARG##l(ARGARG),ARG2)) \\\n-      || CKSGN_L(__builtin_##FUNC##l(NEG __builtin_##FUNCARG##l(ARGARG),ARG2), NEG __builtin_##FUNCARG##l(ARGARG))) \\\n-    link_error(__LINE__); \\\n-  } while (0)\n-#endif\n \n /* Using foo==MIN/MAX float values, test that FUNC(foo,EXP) == foo*exp2(EXP),\n    and also that FUNC(foo,-EXP) == foo*exp2(-EXP).  */"}, {"sha": "edf2f5044c5179fb3e6e17b7417a7d294b450103", "filename": "gcc/testsuite/gcc.dg/torture/builtin-logb-1.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-logb-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-logb-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-logb-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -48,7 +48,6 @@ extern void link_error(int);\n \n /* Test if FUNCRES(FUNC(NEG FUNCARG(ARGARG))) is false.  Check the\n    sign as well.  */\n-#ifndef __SPU__\n #define TESTIT3(FUNC,NEG,FUNCARG,ARGARG,FUNCRES,NEG2) do { \\\n   if (!__builtin_##FUNCRES##f(__builtin_##FUNC(NEG __builtin_##FUNCARG##f(ARGARG))) \\\n       || CKSGN_F(__builtin_##FUNC##f(NEG __builtin_##FUNCARG##f(ARGARG)), NEG2 __builtin_##FUNCARG##f(ARGARG))) \\\n@@ -60,17 +59,6 @@ extern void link_error(int);\n       || CKSGN_L(__builtin_##FUNC##l(NEG __builtin_##FUNCARG##l(ARGARG)), NEG2 __builtin_##FUNCARG##l(ARGARG))) \\\n     link_error(__LINE__); \\\n   } while (0)\n-#else\n-#define TESTIT3(FUNC,NEG,FUNCARG,ARGARG,FUNCRES,NEG2) do { \\\n-  /* SPU single-precision floating point format does not support Inf or Nan.  */ \\\n-  if (!__builtin_##FUNCRES(__builtin_##FUNC(NEG __builtin_##FUNCARG(ARGARG))) \\\n-      || CKSGN(__builtin_##FUNC(NEG __builtin_##FUNCARG(ARGARG)), NEG2 __builtin_##FUNCARG(ARGARG))) \\\n-    link_error(__LINE__); \\\n-  if (!__builtin_##FUNCRES##l(__builtin_##FUNC##l(NEG __builtin_##FUNCARG##l(ARGARG))) \\\n-      || CKSGN_L(__builtin_##FUNC##l(NEG __builtin_##FUNCARG##l(ARGARG)), NEG2 __builtin_##FUNCARG##l(ARGARG))) \\\n-    link_error(__LINE__); \\\n-  } while (0)\n-#endif\n \n void __attribute__ ((__noinline__))\n foo(void)"}, {"sha": "6f3a4beed9bc8ac73507085b0df761e065f77504", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-2.c", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -60,21 +60,15 @@ extern void fool (long double);\n void bar()\n {\n   /* An argument of NaN is not evaluated at compile-time.  */\n-#ifndef __SPU__\n   foof (__builtin_exp2f (__builtin_nanf(\"\")));\n-#endif\n   foo (__builtin_exp2 (__builtin_nan(\"\")));\n   fool (__builtin_exp2l (__builtin_nanl(\"\")));\n \n   /* An argument of Inf/-Inf is not evaluated at compile-time.  */\n-#ifndef __SPU__\n   foof (__builtin_exp2f (__builtin_inff()));\n-#endif\n   foo (__builtin_exp2 (__builtin_inf()));\n   fool (__builtin_exp2l (__builtin_infl()));\n-#ifndef __SPU__\n   foof (__builtin_exp2f (-__builtin_inff()));\n-#endif\n   foo (__builtin_exp2 (-__builtin_inf()));\n   fool (__builtin_exp2l (-__builtin_infl()));\n \n@@ -137,36 +131,24 @@ void bar()\n   TESTIT (tgamma, -3.0);\n \n   /* An argument of NaN is not evaluated at compile-time.  */\n-#ifndef __SPU__\n   foof (__builtin_powf (__builtin_nanf(\"\"), 2.5F));\n-#endif\n   foo (__builtin_pow (__builtin_nan(\"\"), 2.5));\n   fool (__builtin_powl (__builtin_nanl(\"\"), 2.5L));\n-#ifndef __SPU__\n   foof (__builtin_powf (2.5F, __builtin_nanf(\"\")));\n-#endif\n   foo (__builtin_pow (2.5, __builtin_nan(\"\")));\n   fool (__builtin_powl (2.5L, __builtin_nanl(\"\")));\n \n   /* An argument of Inf/-Inf is not evaluated at compile-time.  */\n-#ifndef __SPU__\n   foof (__builtin_powf (__builtin_inff(), 2.5F));\n-#endif\n   foo (__builtin_pow (__builtin_inf(), 2.5));\n   fool (__builtin_powl (__builtin_infl(), 2.5L));\n-#ifndef __SPU__\n   foof (__builtin_powf (-__builtin_inff(), 2.5F));\n-#endif\n   foo (__builtin_pow (-__builtin_inf(), 2.5));\n   fool (__builtin_powl (-__builtin_infl(), 2.5L));\n-#ifndef __SPU__\n   foof (__builtin_powf (2.5F, __builtin_inff()));\n-#endif\n   foo (__builtin_pow (2.5, __builtin_inf()));\n   fool (__builtin_powl (2.5L, __builtin_infl()));\n-#ifndef __SPU__\n   foof (__builtin_powf (2.5F, -__builtin_inff()));\n-#endif\n   foo (__builtin_pow (2.5, -__builtin_inf()));\n   fool (__builtin_powl (2.5L, -__builtin_infl()));\n \n@@ -242,25 +224,17 @@ void bar()\n   TESTIT (ilogb, 0.0);\n   TESTIT (ilogb, -0.0);\n \n-#ifndef __SPU__\n   foof (__builtin_ilogbf (__builtin_inff()));\n-#endif\n   foo (__builtin_ilogb (__builtin_inf()));\n   fool (__builtin_ilogbl (__builtin_infl()));\n-#ifndef __SPU__\n   foof (__builtin_ilogbf (-__builtin_inff()));\n-#endif\n   foo (__builtin_ilogb (-__builtin_inf()));\n   fool (__builtin_ilogbl (-__builtin_infl()));\n \n-#ifndef __SPU__\n   foof (__builtin_ilogbf (__builtin_nanf(\"\")));\n-#endif\n   foo (__builtin_ilogb (__builtin_nan(\"\")));\n   fool (__builtin_ilogbl (__builtin_nanl(\"\")));\n-#ifndef __SPU__\n   foof (__builtin_ilogbf (-__builtin_nanf(\"\")));\n-#endif\n   foo (__builtin_ilogb (-__builtin_nan(\"\")));\n   fool (__builtin_ilogbl (-__builtin_nanl(\"\")));\n \n@@ -306,8 +280,7 @@ void bar()\n }\n \n /* { dg-final { scan-tree-dump-times \"exp2 \" 9 \"original\" } } */\n-/* { dg-final { scan-tree-dump-times \"exp2f\" 9 \"original\" { target { ! { spu*-*-* } } } } } */\n-/* { dg-final { scan-tree-dump-times \"exp2f\" 6 \"original\" { target { spu*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"exp2f\" 9 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"exp2l\" 9 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"asin \" 2 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"asinf\" 2 \"original\" } } */\n@@ -337,8 +310,7 @@ void bar()\n /* { dg-final { scan-tree-dump-times \"tgammaf\" 5 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"tgammal\" 5 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"pow \" 13 \"original\" } } */\n-/* { dg-final { scan-tree-dump-times \"powf\" 13 \"original\" { target { ! { spu*-*-* } } } } } */\n-/* { dg-final { scan-tree-dump-times \"powf\" 7 \"original\" { target { spu*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"powf\" 13 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"powl\" 13 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"sqrt \" 1 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"sqrtf\" 1 \"original\" } } */\n@@ -356,8 +328,7 @@ void bar()\n /* { dg-final { scan-tree-dump-times \"_logbf\" 2 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"_logbl\" 2 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"ilogb \" 6 \"original\" } } */\n-/* { dg-final { scan-tree-dump-times \"ilogbf\" 6 \"original\" { target { ! { spu*-*-* } } } } } */\n-/* { dg-final { scan-tree-dump-times \"ilogbf\" 2 \"original\" { target { spu*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"ilogbf\" 6 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"ilogbl\" 6 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"y0 \" 3 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"y0f\" 3 \"original\" } } */"}, {"sha": "e1d3d06feed24bef79b07acae615c7fda0beced9", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-5.c", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-5.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -28,21 +28,15 @@ extern void fool (_Complex long double);\n void bar()\n {\n   /* An argument of NaN is not evaluated at compile-time.  */\n-#ifndef __SPU__\n   foof (__builtin_csqrtf (__builtin_nanf(\"\")));\n-#endif\n   foo (__builtin_csqrt (__builtin_nan(\"\")));\n   fool (__builtin_csqrtl (__builtin_nanl(\"\")));\n \n   /* An argument of Inf/-Inf is not evaluated at compile-time.  */\n-#ifndef __SPU__\n   foof (__builtin_csqrtf (__builtin_inff()));\n-#endif\n   foo (__builtin_csqrt (__builtin_inf()));\n   fool (__builtin_csqrtl (__builtin_infl()));\n-#ifndef __SPU__\n   foof (__builtin_csqrtf (-__builtin_inff()));\n-#endif\n   foo (__builtin_csqrt (-__builtin_inf()));\n   fool (__builtin_csqrtl (-__builtin_infl()));\n \n@@ -51,36 +45,24 @@ void bar()\n   TESTIT (cexp, -1e20);\n   \n   /* An argument of NaN is not evaluated at compile-time.  */\n-#ifndef __SPU__\n   foof (__builtin_cpowf (__builtin_nanf(\"\"), 2.5F));\n-#endif\n   foo (__builtin_cpow (__builtin_nan(\"\"), 2.5));\n   fool (__builtin_cpowl (__builtin_nanl(\"\"), 2.5L));\n-#ifndef __SPU__\n   foof (__builtin_cpowf (2.5F, __builtin_nanf(\"\")));\n-#endif\n   foo (__builtin_cpow (2.5, __builtin_nan(\"\")));\n   fool (__builtin_cpowl (2.5L, __builtin_nanl(\"\")));\n \n   /* An argument of Inf/-Inf is not evaluated at compile-time.  */\n-#ifndef __SPU__\n   foof (__builtin_cpowf (__builtin_inff(), 2.5F));\n-#endif\n   foo (__builtin_cpow (__builtin_inf(), 2.5));\n   fool (__builtin_cpowl (__builtin_infl(), 2.5L));\n-#ifndef __SPU__\n   foof (__builtin_cpowf (-__builtin_inff(), 2.5F));\n-#endif\n   foo (__builtin_cpow (-__builtin_inf(), 2.5));\n   fool (__builtin_cpowl (-__builtin_infl(), 2.5L));\n-#ifndef __SPU__\n   foof (__builtin_cpowf (2.5F, __builtin_inff()));\n-#endif\n   foo (__builtin_cpow (2.5, __builtin_inf()));\n   fool (__builtin_cpowl (2.5L, __builtin_infl()));\n-#ifndef __SPU__\n   foof (__builtin_cpowf (2.5F, -__builtin_inff()));\n-#endif\n   foo (__builtin_cpow (2.5, -__builtin_inf()));\n   fool (__builtin_cpowl (2.5L, -__builtin_infl()));\n \n@@ -110,14 +92,12 @@ void bar()\n \n }\n \n-/* { dg-final { scan-tree-dump-times \"csqrtf\" 3 \"original\" { target { ! { spu*-*-* } } } } } */\n-/* { dg-final { scan-tree-dump-times \"csqrtf\" 0 \"original\" { target { spu*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"csqrtf\" 3 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"csqrt \" 3 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"csqrtl\" 3 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"cexpf\" 2 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"cexp \" 2 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"cexpl\" 2 \"original\" } } */\n-/* { dg-final { scan-tree-dump-times \"cpowf\" 18 \"original\" { target { ! { spu*-*-* } } } } } */\n-/* { dg-final { scan-tree-dump-times \"cpowf\" 12 \"original\" { target { spu*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"cpowf\" 18 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"cpow \" 18 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"cpowl\" 18 \"original\" } } */"}, {"sha": "246d5b11233ec878d83b23ea7082b7d33e4cb835", "filename": "gcc/testsuite/gcc.dg/torture/builtin-modf-1.c", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-modf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-modf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-modf-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -63,7 +63,6 @@ extern void link_error(int);\n /* Test that modf(NEG FUNCARG(ARGARG, &iptr)) == FRACRES &&\n    FUNCRES(iptr) is true.  Check the sign of both as well.  This is\n    for checking an argument of Inf.  */\n-#ifndef __SPU__\n #define TESTIT_MODF2(NEG,FUNCARG,ARGARG,FUNCRES,FRACRES) do { \\\n   float iptrf = 0.5; double iptr = 0.5; long double iptrl = 0.5; \\\n   if (__builtin_modff(NEG __builtin_##FUNCARG##f(ARGARG),&iptrf) != FRACRES##f \\\n@@ -82,27 +81,10 @@ extern void link_error(int);\n       || CKSGN_IPTR_L(iptrl,FRACRES##l)) \\\n     link_error(__LINE__); \\\n   } while (0)\n-#else\n-#define TESTIT_MODF2(NEG,FUNCARG,ARGARG,FUNCRES,FRACRES) do { \\\n-  /* SPU single-precision floating point format does not support Inf or Nan.  */ \\\n-  double iptr = 0.5; long double iptrl = 0.5; \\\n-  if (__builtin_modf(NEG __builtin_##FUNCARG(ARGARG),&iptr) != FRACRES \\\n-      || CKSGN(__builtin_modf(NEG __builtin_##FUNCARG(ARGARG),&iptr), FRACRES) \\\n-      || CKIPTR(!__builtin_##FUNCRES(iptr),0) \\\n-      || CKSGN_IPTR(iptr,FRACRES)) \\\n-    link_error(__LINE__); \\\n-  if (__builtin_modfl(NEG __builtin_##FUNCARG##l(ARGARG),&iptrl) != FRACRES##l \\\n-      || CKSGN_L(__builtin_modfl(NEG __builtin_##FUNCARG##l(ARGARG),&iptrl), FRACRES##l) \\\n-      || CKIPTR(!__builtin_##FUNCRES##l(iptrl),0) \\\n-      || CKSGN_IPTR_L(iptrl,FRACRES##l)) \\\n-    link_error(__LINE__); \\\n-  } while (0)\n-#endif\n \n /* Test that FUNCRES(modf(NEG FUNCARG(ARGARG, &iptr))) is true &&\n    FUNCRES(iptr) is true.  Check the sign of both as well.  This is\n    for checking an argument of NaN.  */\n-#ifndef __SPU__\n #define TESTIT_MODF3(NEG,FUNCARG,ARGARG,FUNCRES) do { \\\n   float iptrf = 0.5; double iptr = 0.5; long double iptrl = 0.5; \\\n   if (CKRES(!__builtin_##FUNCRES##f(__builtin_modff(NEG __builtin_##FUNCARG##f(ARGARG),&iptrf))) \\\n@@ -121,22 +103,6 @@ extern void link_error(int);\n       || CKSGN_IPTR_L(iptrl,NEG 1)) \\\n     link_error(__LINE__); \\\n   } while (0)\n-#else\n-#define TESTIT_MODF3(NEG,FUNCARG,ARGARG,FUNCRES) do { \\\n-  /* SPU single-precision floating point format does not support Inf or Nan.  */ \\\n-  double iptr = 0.5; long double iptrl = 0.5; \\\n-  if (CKRES(!__builtin_##FUNCRES(__builtin_modf(NEG __builtin_##FUNCARG(ARGARG),&iptr))) \\\n-      || CKSGN(__builtin_modf(NEG __builtin_##FUNCARG(ARGARG),&iptr), NEG 1) \\\n-      || CKIPTR(!__builtin_##FUNCRES(iptr),0) \\\n-      || CKSGN_IPTR(iptr,NEG 1)) \\\n-    link_error(__LINE__); \\\n-  if (CKRES(!__builtin_##FUNCRES##l(__builtin_modfl(NEG __builtin_##FUNCARG##l(ARGARG),&iptrl))) \\\n-      || CKSGN_L(__builtin_modfl(NEG __builtin_##FUNCARG##l(ARGARG),&iptrl), NEG 1) \\\n-      || CKIPTR(!__builtin_##FUNCRES##l(iptrl),0) \\\n-      || CKSGN_IPTR_L(iptrl,NEG 1)) \\\n-    link_error(__LINE__); \\\n-  } while (0)\n-#endif\n \n void __attribute__ ((__noinline__))\n foo(void)"}, {"sha": "ecc3977b3f5dc5bebbe0a1f3bd0257b333780dbb", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert.h?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -7,7 +7,7 @@ extern void exit (int);\n \n /* Not all platforms support TImode integers; logic as in\n    gcc.dg/titype-1.c.  */\n-#if (defined(__LP64__) && !defined(__hppa__)) || defined(_WIN64) || defined(__SPU__)\n+#if (defined(__LP64__) && !defined(__hppa__)) || defined(_WIN64)\n typedef int TItype __attribute__ ((mode (TI)));\n typedef unsigned int UTItype __attribute__ ((mode (TI)));\n #else"}, {"sha": "3acad8d36690f3ef6dbf8b1f0ef3581f4cead8e0", "filename": "gcc/testsuite/gcc.dg/torture/pr25947-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr25947-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr25947-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr25947-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n /* PR target/25947: define_split in cris.md caused unrecognized insn.  */\n /* { dg-options \"-fpic\" { target fpic } } */\n-/* { dg-skip-if \"requires unsupported run-time relocation\" { spu-*-* } { \"-O0\" } { \"\" } } */\n \n extern char *rl_line_buffer;\n extern int rl_point;"}, {"sha": "b2aacd933f8ac4e425aaf52410b7efa81810536e", "filename": "gcc/testsuite/gcc.dg/torture/type-generic-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftype-generic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftype-generic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftype-generic-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -3,7 +3,6 @@\n \n /* { dg-do run } */\n /* { dg-require-effective-target inf } */\n-/* { dg-skip-if \"No Inf/NaN support\" { spu-*-* } } */\n /* { dg-skip-if \"No subnormal support\" { csky-*-* } { \"-mhard-float\" } } */\n /* { dg-options \"-DUNSAFE\" { target tic6x*-*-* visium-*-* nvptx-*-* } } */\n /* { dg-add-options ieee } */"}, {"sha": "3e07a359b5560e7bb93eb0320fab84dccd642756", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040204-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040204-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040204-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -33,4 +33,4 @@ void test55 (int x, int y)\n    that the && should be emitted (based on BRANCH_COST).  Fix this\n    by teaching dom to look through && and register all components\n    as true.  */\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" { xfail { ! \"alpha*-*-* arm*-*-* aarch64*-*-* powerpc*-*-* cris-*-* crisv32-*-* hppa*-*-* i?86-*-* mmix-*-* mips*-*-* m68k*-*-* moxie-*-* nds32*-*-* s390*-*-* sh*-*-* sparc*-*-* spu-*-* visium-*-* x86_64-*-* riscv*-*-* or1k*-*-* msp430-*-* pru*-*-*\" } } } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" { xfail { ! \"alpha*-*-* arm*-*-* aarch64*-*-* powerpc*-*-* cris-*-* crisv32-*-* hppa*-*-* i?86-*-* mmix-*-* mips*-*-* m68k*-*-* moxie-*-* nds32*-*-* s390*-*-* sh*-*-* sparc*-*-* visium-*-* x86_64-*-* riscv*-*-* or1k*-*-* msp430-*-* pru*-*-*\" } } } } */"}, {"sha": "5ee87b033b11ad85447057801b97385e20832677", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopts-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n \n /* Not all platforms support TImode integers.  */\n-#if (defined(__LP64__) && !defined(__hppa__)) || defined(__SPU__)\n+#if defined(__LP64__) && !defined(__hppa__)\n typedef int TItype __attribute__ ((mode (TI)));\n #else\n typedef long TItype;"}, {"sha": "6b6255b9713b061fc26c48ddf162959e814b2e6a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-3.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -5,7 +5,7 @@\n \n    When the condition is true, we distribute \"(int) (a + b)\" as\n    \"(int) a + (int) b\", otherwise we keep the original.  */\n-/* { dg-do compile { target { { ! mips64 } && { ! spu-*-* } } } } */\n+/* { dg-do compile { target { ! mips64 } } } */\n /* { dg-options \"-O -fno-tree-forwprop -fno-tree-ccp -fwrapv -fdump-tree-fre1-details\" } */\n \n /* From PR14844.  */"}, {"sha": "151962ea7a6ede9d4d30d3a8d1ba86747af4adaa", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vector-6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-6.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -32,5 +32,5 @@ v4si test4 (v4si v, int i)\n   return v;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Now a gimple register: v\" 2 \"ssa\" { target { { i?86-*-* x86_64-*-* aarch64*-*-* spu*-*-* } || { powerpc_altivec_ok } } } } } */\n-/* { dg-final { scan-tree-dump-times \"Now a gimple register: v\" 2 \"ccp1\" { target { { i?86-*-* x86_64-*-* aarch64*-*-* spu*-*-* } || { powerpc_altivec_ok } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Now a gimple register: v\" 2 \"ssa\" { target { { i?86-*-* x86_64-*-* aarch64*-*-* } || { powerpc_altivec_ok } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Now a gimple register: v\" 2 \"ccp1\" { target { { i?86-*-* x86_64-*-* aarch64*-*-* } || { powerpc_altivec_ok } } } } } */"}, {"sha": "305dd36707ea88acd59e6dd99738e2153b54147b", "filename": "gcc/testsuite/gcc.dg/uninit-C-O0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-C-O0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-C-O0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-C-O0.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -3,7 +3,7 @@\n /* { dg-options \"-Wuninitialized\" } */\n \n /* Not all platforms support TImode integers.  */\n-#if (defined(__LP64__) && !defined(__hppa__)) || defined(__SPU__)\n+#if defined(__LP64__) && !defined(__hppa__)\n typedef int TItype __attribute__ ((mode (TI)));\n #else\n typedef long TItype;"}, {"sha": "741106cb4638b698ffc98bfd797164a7415c0736", "filename": "gcc/testsuite/gcc.dg/uninit-C.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-C.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-C.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-C.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -3,7 +3,7 @@\n /* { dg-options \"-O -Wuninitialized\" } */\n \n /* Not all platforms support TImode integers.  */\n-#if (defined(__LP64__) && !defined(__hppa__)) || defined(__SPU__)\n+#if defined(__LP64__) && !defined(__hppa__)\n typedef int TItype __attribute__ ((mode (TI)));\n #else\n typedef long TItype;"}, {"sha": "d8fe35c6091c32b00b58920224c70dee1d5e7b14", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-fast-math-vect-pr29925.c", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-fast-math-vect-pr29925.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-fast-math-vect-pr29925.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-fast-math-vect-pr29925.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,39 +0,0 @@\n-/* { dg-require-effective-target vect_float } */\n-\n-#include <stdlib.h>\n-#include \"../../tree-vect.h\"\n-\n-__attribute__ ((noinline)) void\n-interp_pitch(float *exc, float *interp, int pitch, int len)\n-{\n-   int i,k;\n-   int maxj;\n-\n-   maxj=3;\n-   for (i=0;i<len;i++)\n-   {\n-      float tmp = 0;\n-      for (k=0;k<7;k++)\n-      {\n-         tmp += exc[i-pitch+k+maxj-6];\n-      }\n-      interp[i] = tmp;\n-   }\n-}\n-\n-int main()\n-{\n-   float *exc = calloc(126,sizeof(float));\n-   float *interp = calloc(80,sizeof(float));\n-   int pitch = -35;\n-\n-   check_vect ();\n-\n-   interp_pitch(exc, interp, pitch, 80);\n-   free(exc);\n-   free(interp);\n-   return 0;\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n-"}, {"sha": "9f75ce81aff19f286c0722be50433c9fe0acbff5", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31a.c", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31a.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,50 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 32\n-\n-struct t{\n-  int k[N];\n-  int l; \n-};\n-  \n-struct s{\n-  char a;\t/* aligned */\n-  char b[N-1];  /* unaligned (offset 1B) */\n-  char c[N];    /* aligned (offset NB) */\n-  struct t d;   /* aligned (offset 2NB) */\n-  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n-};\n- \n-int main1 ()\n-{  \n-  int i;\n-  struct s tmp;\n-\n-  /* unaligned */\n-  for (i = 0; i < N/2; i++)\n-    {\n-      tmp.b[i] = 5;\n-    }\n-\n-  /* check results:  */\n-  for (i = 0; i <N/2; i++)\n-    {\n-      if (tmp.b[i] != 5)\n-        abort ();\n-    }\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{ \n-  check_vect ();\n-  \n-  return main1 ();\n-} \n-\n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */"}, {"sha": "b0f193f042e1e89b87c169f3d8c45d7860e0eebb", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31b.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31b.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,49 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 32\n-\n-struct t{\n-  int k[N];\n-  int l; \n-};\n-  \n-struct s{\n-  char a;\t/* aligned */\n-  char b[N-1];  /* unaligned (offset 1B) */\n-  char c[N];    /* aligned (offset NB) */\n-  struct t d;   /* aligned (offset 2NB) */\n-  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n-};\n- \n-int main1 ()\n-{  \n-  int i;\n-  struct s tmp;\n-\n-  /* aligned */\n-  for (i = 0; i < N/2; i++)\n-    {\n-      tmp.c[i] = 6;\n-    }\n-\n-  /* check results:  */\n-  for (i = 0; i <N/2; i++)\n-    {\n-      if (tmp.c[i] != 6)\n-        abort ();\n-    }\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{ \n-  check_vect ();\n-  \n-  return main1 ();\n-} \n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "d062d659ffb0138859333f3d7e375bd83fc1c99a", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31c.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31c.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,49 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 32\n-\n-struct t{\n-  int k[N];\n-  int l; \n-};\n-  \n-struct s{\n-  char a;\t/* aligned */\n-  char b[N-1];  /* unaligned (offset 1B) */\n-  char c[N];    /* aligned (offset NB) */\n-  struct t d;   /* aligned (offset 2NB) */\n-  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n-};\n- \n-int main1 ()\n-{  \n-  int i;\n-  struct s tmp;\n-\n-  /* aligned */\n-  for (i = 0; i < N/2; i++)\n-    {\n-      tmp.d.k[i] = 7;\n-    }\n-\n-  /* check results:  */\n-  for (i = 0; i <N/2; i++)\n-    {\n-      if (tmp.d.k[i] != 7)\n-        abort ();\n-    }\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{ \n-  check_vect ();\n-  \n-  return main1 ();\n-} \n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "843d739af4db1d363e057a60ea2d87f783eee041", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31d.c", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31d.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,50 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 32\n-\n-struct t{\n-  int k[N];\n-  int l; \n-};\n-  \n-struct s{\n-  char a;\t/* aligned */\n-  char b[N-1];  /* unaligned (offset 1B) */\n-  char c[N];    /* aligned (offset NB) */\n-  struct t d;   /* aligned (offset 2NB) */\n-  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n-};\n- \n-int main1 ()\n-{  \n-  int i;\n-  struct s tmp;\n-\n-  /* unaligned */\n-  for (i = 0; i < N/2; i++)\n-    {\n-      tmp.e.k[i] = 8;\n-    }\n-\n-  /* check results:  */\n-  for (i = 0; i <N/2; i++)\n-    {\n-      if (tmp.e.k[i] != 8)\n-        abort ();\n-    }\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{ \n-  check_vect ();\n-  \n-  return main1 ();\n-} \n-\n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "e0764f877f69b2b8ebe8ffcb1c62c4ee19b492d8", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-33.c", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-33.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,42 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 16\n-struct test {\n-  char ca[N];\n-};\n-\n-extern struct test s;\n- \n-int main1 ()\n-{  \n-  int i;\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      s.ca[i] = 5;\n-    }\n-\n-  /* check results:  */\n-  for (i = 0; i < N; i++)\n-    {\n-      if (s.ca[i] != 5)\n-        abort ();\n-    }\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{ \n-  return main1 ();\n-} \n-\n-/* Peeling to align the store is used. Overhead of peeling is too high.  */\n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" { target vector_alignment_reachable } } } */\n-\n-/* Versioning to align the store is used. Overhead of versioning is not too high.  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target {! vector_alignment_reachable} } } } */"}, {"sha": "ce27e4f082151b630376bd9cfbbabb78e80e4387", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68a.c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68a.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,48 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 32\n-\n-struct s{\n-  int m;\n-  int n[N][N][N];\n-};\n-\n-struct test1{\n-  struct s a; /* array a.n is unaligned */\n-  int b;\n-  int c;\n-  struct s e; /* array e.n is aligned */\n-};\n-\n-int main1 ()\n-{  \n-  int i,j;\n-  struct test1 tmp1;\n-\n-  /* 1. unaligned */\n-  for (i = 0; i < N; i++)\n-    {\n-      tmp1.a.n[1][2][i] = 5;\n-    }\n-\n-  /* check results:  */\n-  for (i = 0; i <N; i++)\n-    {\n-      if (tmp1.a.n[1][2][i] != 5)\n-        abort ();\n-    }\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{ \n-  check_vect ();\n-  \n-  return main1 ();\n-} \n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "dae5a78808f1d6a5754adb8e7ff4b22608ea33b4", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68b.c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68b.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,48 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 32\n-\n-struct s{\n-  int m;\n-  int n[N][N][N];\n-};\n-\n-struct test1{\n-  struct s a; /* array a.n is unaligned */\n-  int b;\n-  int c;\n-  struct s e; /* array e.n is aligned */\n-};\n-\n-int main1 ()\n-{  \n-  int i,j;\n-  struct test1 tmp1;\n-\n-  /* 2. aligned */\n-  for (i = 3; i < N-1; i++)\n-    {\n-      tmp1.a.n[1][2][i] = 6;\n-    }\n-\n-  /* check results:  */\n-  for (i = 3; i < N-1; i++)\n-    {\n-      if (tmp1.a.n[1][2][i] != 6)\n-        abort ();\n-    }\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{ \n-  check_vect ();\n-  \n-  return main1 ();\n-} \n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "8221f9e49f8875f453dbc12ca0da4a226e7cf62d", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68c.c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68c.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,48 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 32\n-\n-struct s{\n-  int m;\n-  int n[N][N][N];\n-};\n-\n-struct test1{\n-  struct s a; /* array a.n is unaligned */\n-  int b;\n-  int c;\n-  struct s e; /* array e.n is aligned */\n-};\n-\n-int main1 ()\n-{  \n-  int i,j;\n-  struct test1 tmp1;\n-\n-  /* 3. aligned */\n-  for (i = 0; i < N; i++)\n-    {\n-      tmp1.e.n[1][2][i] = 7;\n-    }\n-\n-  /* check results:  */\n-  for (i = 0; i < N; i++)\n-    {\n-      if (tmp1.e.n[1][2][i] != 7)\n-        abort ();\n-    }\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{ \n-  check_vect ();\n-  \n-  return main1 ();\n-} \n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "0468455ccc71c4d433a8bb3b3bd640c92f8792bb", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68d.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68d.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,49 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 20\n-\n-struct s{\n-  int m;\n-  int n[N][N][N];\n-};\n-\n-struct test1{\n-  struct s a; /* array a.n is unaligned */\n-  int b;\n-  int c;\n-  struct s e; /* array e.n is aligned */\n-};\n-\n-int main1 ()\n-{  \n-  int i,j;\n-  struct test1 tmp1;\n-\n-  /* 4. unaligned */\n-  for (i = 3; i < N-3; i++)\n-    {\n-      tmp1.e.n[1][2][i] = 8;\n-    }\n- \n-  /* check results:  */\n-  for (i = 3; i <N-3; i++)\n-    {\n-      if (tmp1.e.n[1][2][i] != 8)\n-        abort ();\n-    }\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{ \n-  check_vect ();\n-  \n-  return main1 ();\n-} \n-\n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "e18822c93f5ddf0aca85aca475ee9337ba30b6e1", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76a.c", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76a.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,46 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 16\n-#define OFF 4\n-\n-/* Check handling of accesses for which the \"initial condition\" -\n-   the expression that represents the first location accessed - is\n-   more involved than just an ssa_name.  */\n-\n-int ib[N+OFF] __attribute__ ((__aligned__(16))) = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n-\n-int main1 (int *pib)\n-{\n-  int i;\n-  int ia[N+OFF];\n-  int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n-\n-  for (i = OFF; i < N; i++)\n-    {\n-      ia[i] = pib[i - OFF];\n-    }\n-\n-\n-  /* check results:  */\n-  for (i = OFF; i < N; i++)\n-    {\n-     if (ia[i] != pib[i - OFF])\n-        abort ();\n-    }\n-\n-  return 0;  \n-}\n-\n-int main (void)\n-{\n-  check_vect ();\n-\n-  main1 (&ib[OFF]);\n-  return 0;\n-}\n-\n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "1d6075e1a4ce3546372b5bca13576a68a28207c3", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76b.c", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76b.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,46 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 16\n-#define OFF 4\n-\n-/* Check handling of accesses for which the \"initial condition\" -\n-   the expression that represents the first location accessed - is\n-   more involved than just an ssa_name.  */\n-\n-int ib[N+OFF] __attribute__ ((__aligned__(16))) = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10, 0, 1, 3, 5, 7, 11, 13, 17};\n-int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10, 0, 1, 3, 5, 7, 11, 13, 17};\n-\n-int main1 (int *pib)\n-{\n-  int i;\n-  int ia[N+OFF];\n-\n-  for (i = OFF; i < N; i++)\n-    {\n-      pib[i - OFF] = ic[i];\n-    }\n-\n-\n-  /* check results:  */\n-  for (i = OFF; i < N; i++)\n-    {\n-     if (pib[i - OFF] != ic[i])\n-        abort ();\n-    }\n-\n-  return 0;  \n-}\n-\n-int main (void)\n-{\n-  check_vect ();\n-\n-  main1 (&ib[OFF]);\n-  return 0;\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 0 \"vect\" } } */"}, {"sha": "672e967ec2e82e751d12ad230bc0de84b41de798", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76c.c", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76c.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,46 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 32\n-#define OFF 4\n-\n-/* Check handling of accesses for which the \"initial condition\" -\n-   the expression that represents the first location accessed - is\n-   more involved than just an ssa_name.  */\n-\n-int ib[N+OFF] __attribute__ ((__aligned__(16))) = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n-int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n-\n-int main1 (int *pib)\n-{\n-  int i;\n-  int ia[N+OFF];\n-\n-  for (i = OFF; i < N; i++)\n-    {\n-      ia[i] = ic[i - OFF];\n-    }\n-\n-\n-  /* check results:  */\n-  for (i = OFF; i < N; i++)\n-    {\n-     if (ia[i] != ic[i - OFF])\n-        abort ();  \n-    }\n-\n-  return 0;  \n-}\n-\n-int main (void)\n-{\n-  check_vect ();\n-\n-  main1 (&ib[OFF]);\n-  return 0;\n-}\n-\n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "0f09405b89abb2b338a309a3f3be3fa92e43a0f5", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-iv-9.c", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-iv-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-iv-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-iv-9.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,37 +0,0 @@\n-/* { dg-require-effective-target vect_int } */\n-\n-#include <stdarg.h>\n-#include \"../../tree-vect.h\"\n-\n-#define N 26\n-int a[N];\n- \n-__attribute__ ((noinline)) int main1 (int X)\n-{  \n-  int s = X;\n-  int i;\n-\n-  /* vectorization of reduction with induction.  */\n-  for (i = 0; i < N; i++)\n-    s += (i + a[i]);\n-\n-  return s;\n-}\n-\n-int main (void)\n-{ \n-  int s, i;\n-  check_vect ();\n-  \n-  for (i = 0; i < N; i++)\n-    a[i] = 2*i;\n-\n-  s = main1 (3);\n-  if (s != 978)\n-    abort ();\n-\n-  return 0;\n-} \n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_int_mult } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target {! vect_int_mult } } } } */"}, {"sha": "fb3da51ed2866d0b2daf23eb09980dd22294811e", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/spu-costmodel-vect.exp", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fspu-costmodel-vect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fspu-costmodel-vect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fspu-costmodel-vect.exp?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,69 +0,0 @@\n-# Copyright (C) 1997-2019 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-# \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-# GCC testsuite that uses the `dg.exp' driver.\n-\n-# Load support procs.\n-load_lib gcc-dg.exp\n-\n-# Exit immediately if this isn't a powerpc target.\n-if { ![istarget spu*-*-*] } then {\n-  return\n-}\n-\n-\n-# Set up flags used for tests that don't specify options.\n-set DEFAULT_VECTCFLAGS \"\"\n-\n-# These flags are used for all targets.\n-lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \"-fvect-cost-model=dynamic\"\n-\n-# If the target system supports vector instructions, the default action\n-# for a test is 'run', otherwise it's 'compile'.  Save current default.\n-# Executing vector instructions on a system without hardware vector support\n-# is also disabled by a call to check_vect, but disabling execution here is\n-# more efficient.\n-global dg-do-what-default\n-set save-dg-do-what-default ${dg-do-what-default}\n-\n-set dg-do-what-default run\n-\n-# Initialize `dg'.\n-dg-init\n-\n-lappend DEFAULT_VECTCFLAGS \"-fdump-tree-vect-details\"\n-\n-# Main loop.\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-pr*.\\[cS\\]]]  \\\n-\t\"\" $DEFAULT_VECTCFLAGS\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-vect-*.\\[cS\\]]]  \\\n-\t\"\" $DEFAULT_VECTCFLAGS\n-\n-#### Tests with special options\n-global SAVED_DEFAULT_VECTCFLAGS\n-set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n-\n-# -ffast-math tests\n-set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n-lappend DEFAULT_VECTCFLAGS \"-ffast-math\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-fast-math-vect*.\\[cS\\]]]  \\\n-\t\"\" $DEFAULT_VECTCFLAGS\n-\n-# Clean up.\n-set dg-do-what-default ${save-dg-do-what-default}\n-\n-# All done.\n-dg-finish"}, {"sha": "18064cc3e87df846c4fe36019c12fb88e845e7a5", "filename": "gcc/testsuite/gcc.dg/vect/no-math-errno-slp-32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-math-errno-slp-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-math-errno-slp-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-math-errno-slp-32.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -13,4 +13,4 @@ void foo(void)\n    }\n }\n \n-/* { dg-final { scan-tree-dump \"pattern recognized\" \"vect\" { xfail spu*-*-* } } } */\n+/* { dg-final { scan-tree-dump \"pattern recognized\" \"vect\" } } */"}, {"sha": "8e3989a3283951de422562058e098069bb103c83", "filename": "gcc/testsuite/gcc.dg/vect/no-math-errno-vect-pow-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-math-errno-vect-pow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-math-errno-vect-pow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-math-errno-vect-pow-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -10,4 +10,4 @@ void foo(void)\n     x[i] = __builtin_pow (x[i], 0.5);\n }\n \n-/* { dg-final { scan-tree-dump \"pattern recognized\" \"vect\" { xfail spu*-*-* } } } */\n+/* { dg-final { scan-tree-dump \"pattern recognized\" \"vect\" } } */"}, {"sha": "76b436948c185ca73e21203ef68b0a9d4da03408", "filename": "gcc/testsuite/gcc.dg/vect/vect-float-extend-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-float-extend-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-float-extend-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-float-extend-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -38,4 +38,4 @@ main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail spu*-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "8b82c82f1cdd1078898847c31c6c06371f4232f6", "filename": "gcc/testsuite/gcc.dg/vect/vect-float-truncate-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-float-truncate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-float-truncate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-float-truncate-1.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -37,4 +37,4 @@ main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail spu*-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "a52a2aac2f6b27eb12d90956a83ed1a71f6585c0", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -266,9 +266,6 @@ et-dg-runtest dg-runtest [lsort \\\n # Don't allow IPA cloning, because it throws our counts out of whack.\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-O3\" \"-fno-ipa-cp-clone\"\n-if  [istarget \"spu-*-*\"] {\n-  lappend DEFAULT_VECTCFLAGS \"-funroll-loops\"\n-}\n \n et-dg-runtest dg-runtest [lsort \\\n \t[glob -nocomplain $srcdir/$subdir/O3-*.\\[cS\\]]] \\"}, {"sha": "d80e182665879b594dd315c3e1b6012fd2ee5dc9", "filename": "gcc/testsuite/gcc.target/spu/Wmain.c", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2FWmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2FWmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2FWmain.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,7 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-Wmain -mstdmain\" } */\n-\n-int main (void *wrong)/* { dg-warning \"first argument of 'main' should be 'int'\" } */\n-  /* { dg-warning \"'main' takes only zero or two arguments\" \"\" { target *-*-* } .-1 } */\n-{ \n-}"}, {"sha": "b435f1ede5cc053afb1ac7c0e3656415b98435c9", "filename": "gcc/testsuite/gcc.target/spu/abi.c", "status": "removed", "additions": 0, "deletions": 474, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fabi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fabi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fabi.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,474 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-O2\" } */\n-/* Test that arguments are passed in the correct location according to the ABI.  */\n-\n-#include <stdlib.h>\n-\n-/* Hack to allow calling func_asm which takes 84 arguments that are scalars.\n-   The function func_call takes 84 union quadword arguments, so we can check to\n-   see if each scalar is passed in the correct location.  This asm glues the\n-   two functions together, so that the compiler is not aware of the\n-   aliasing.  */\n-__asm__ (\"func_asm = func_call\");\n-\n-typedef unsigned int uqword __attribute__((mode(TI)));\n-typedef int qword __attribute__((mode(TI)));\n-\n-union u\n-{\n-  uqword\t\tuq;\n-  qword\t\t\tsq;\n-  double\t\td[2];\n-  float\t\t\tf[4];\n-  unsigned long long\tull[2];\n-  long long\t\tsll[2];\n-  unsigned long\t\tul[4];\n-  long\t\t\tsl[4];\n-  unsigned int\t\tui[4];\n-  int\t\t\tsi[4];\n-  unsigned short\tus[8];\n-  short\t\t\tss[8];\n-  unsigned char\t\tuc[16];\n-  signed char\t\tsc[16];\n-};\n-\n-\n-extern void func_asm(signed char a1,\n-\t\t     unsigned char a2,\n-\t\t     short a3,\n-\t\t     unsigned short a4,\n-\t\t     int a5,\n-\t\t     unsigned int a6,\n-\t\t     long a7,\n-\t\t     unsigned long a8,\n-\t\t     long long a9,\n-\t\t     unsigned long long a10,\n-\t\t     float a11,\n-\t\t     double a12,\n-\t\t     int a13,\n-\t\t     int a14,\n-\t\t     int a15,\n-\t\t     int a16,\n-\t\t     int a17,\n-\t\t     int a18,\n-\t\t     int a19,\n-\t\t     int a20,\n-\t\t     int a21,\n-\t\t     int a22,\n-\t\t     int a23,\n-\t\t     int a24,\n-\t\t     int a25,\n-\t\t     int a26,\n-\t\t     int a27,\n-\t\t     int a28,\n-\t\t     int a29,\n-\t\t     int a30,\n-\t\t     int a31,\n-\t\t     int a32,\n-\t\t     int a33,\n-\t\t     int a34,\n-\t\t     int a35,\n-\t\t     int a36,\n-\t\t     int a37,\n-\t\t     int a38,\n-\t\t     int a39,\n-\t\t     int a40,\n-\t\t     int a41,\n-\t\t     int a42,\n-\t\t     int a43,\n-\t\t     int a44,\n-\t\t     int a45,\n-\t\t     int a46,\n-\t\t     int a47,\n-\t\t     int a48,\n-\t\t     int a49,\n-\t\t     int a50,\n-\t\t     int a51,\n-\t\t     int a52,\n-\t\t     int a53,\n-\t\t     int a54,\n-\t\t     int a55,\n-\t\t     int a56,\n-\t\t     int a57,\n-\t\t     int a58,\n-\t\t     int a59,\n-\t\t     int a60,\n-\t\t     int a61,\n-\t\t     int a62,\n-\t\t     int a63,\n-\t\t     int a64,\n-\t\t     int a65,\n-\t\t     int a66,\n-\t\t     int a67,\n-\t\t     int a68,\n-\t\t     int a69,\n-\t\t     int a70,\n-\t\t     int a71,\n-\t\t     int a72,\n-\t\t     signed char a73,\n-\t\t     unsigned char a74,\n-\t\t     short a75,\n-\t\t     unsigned short a76,\n-\t\t     int a77,\n-\t\t     unsigned int a78,\n-\t\t     long a79,\n-\t\t     unsigned long a80,\n-\t\t     long long a81,\n-\t\t     unsigned long long a82,\n-\t\t     float a83,\n-\t\t     double a84);\n-\n-void func_call(union u a1,\n-\t       union u a2,\n-\t       union u a3,\n-\t       union u a4,\n-\t       union u a5,\n-\t       union u a6,\n-\t       union u a7,\n-\t       union u a8,\n-\t       union u a9,\n-\t       union u a10,\n-\t       union u a11,\n-\t       union u a12,\n-\t       union u a13,\n-\t       union u a14,\n-\t       union u a15,\n-\t       union u a16,\n-\t       union u a17,\n-\t       union u a18,\n-\t       union u a19,\n-\t       union u a20,\n-\t       union u a21,\n-\t       union u a22,\n-\t       union u a23,\n-\t       union u a24,\n-\t       union u a25,\n-\t       union u a26,\n-\t       union u a27,\n-\t       union u a28,\n-\t       union u a29,\n-\t       union u a30,\n-\t       union u a31,\n-\t       union u a32,\n-\t       union u a33,\n-\t       union u a34,\n-\t       union u a35,\n-\t       union u a36,\n-\t       union u a37,\n-\t       union u a38,\n-\t       union u a39,\n-\t       union u a40,\n-\t       union u a41,\n-\t       union u a42,\n-\t       union u a43,\n-\t       union u a44,\n-\t       union u a45,\n-\t       union u a46,\n-\t       union u a47,\n-\t       union u a48,\n-\t       union u a49,\n-\t       union u a50,\n-\t       union u a51,\n-\t       union u a52,\n-\t       union u a53,\n-\t       union u a54,\n-\t       union u a55,\n-\t       union u a56,\n-\t       union u a57,\n-\t       union u a58,\n-\t       union u a59,\n-\t       union u a60,\n-\t       union u a61,\n-\t       union u a62,\n-\t       union u a63,\n-\t       union u a64,\n-\t       union u a65,\n-\t       union u a66,\n-\t       union u a67,\n-\t       union u a68,\n-\t       union u a69,\n-\t       union u a70,\n-\t       union u a71,\n-\t       union u a72,\n-\t       union u a73,\n-\t       union u a74,\n-\t       union u a75,\n-\t       union u a76,\n-\t       union u a77,\n-\t       union u a78,\n-\t       union u a79,\n-\t       union u a80,\n-\t       union u a81,\n-\t       union u a82,\n-\t       union u a83,\n-\t       union u a84)\n-{\n-  /* arguments passed in registers */\n-  if (a1.sc[3] != -1)\t\t\t/* signed char */\n-    abort ();\n-\n-  if (a2.uc[3] != +2)\t\t\t/* unsigned char */\n-    abort ();\n-\n-  if (a3.ss[1] != -3)\t\t\t/* short */\n-    abort ();\n-\n-  if (a4.us[1] != +4)\t\t\t/* unsigned short */\n-    abort ();\n-\n-  if (a5.si[0] != -5)\t\t\t/* int */\n-    abort ();\n-\n-  if (a6.ui[0] != +6)\t\t\t/* unsigned int */\n-    abort ();\n-\n-  if (a7.sl[0] != -7)\t\t\t/* long */\n-    abort ();\n-\n-  if (a8.ul[0] != +8)\t\t\t/* unsigned long */\n-    abort ();\n-\n-  if (a9.sll[0] != -9)\t\t\t/* long long */\n-    abort ();\n-\n-  if (a10.ull[0] != +10)\t\t/* unsigned long long */\n-    abort ();\n-\n-  if (a11.f[0] != -11.0f)\t\t/* float */\n-    abort ();\n-\n-  if (a12.d[0] != +12.0)\t\t/* double */\n-    abort ();\n-\n-  if (a13.si[0] != -13)\t\t\t/* int */\n-    abort ();\n-\n-  if (a14.si[0] != +14)\t\t\t/* int */\n-    abort ();\n-\n-  if (a15.si[0] != -15)\t\t\t/* int */\n-    abort ();\n-\n-  if (a16.si[0] != +16)\t\t\t/* int */\n-    abort ();\n-\n-  if (a17.si[0] != -17)\t\t\t/* int */\n-    abort ();\n-\n-  if (a18.si[0] != +18)\t\t\t/* int */\n-    abort ();\n-\n-  if (a19.si[0] != -19)\t\t\t/* int */\n-    abort ();\n-\n-  if (a20.si[0] != +20)\t\t\t/* int */\n-    abort ();\n-\n-  if (a21.si[0] != -21)\t\t\t/* int */\n-    abort ();\n-\n-  if (a22.si[0] != +22)\t\t\t/* int */\n-    abort ();\n-\n-  if (a23.si[0] != -23)\t\t\t/* int */\n-    abort ();\n-\n-  if (a24.si[0] != +24)\t\t\t/* int */\n-    abort ();\n-\n-  if (a25.si[0] != -25)\t\t\t/* int */\n-    abort ();\n-\n-  if (a26.si[0] != +26)\t\t\t/* int */\n-    abort ();\n-\n-  if (a27.si[0] != -27)\t\t\t/* int */\n-    abort ();\n-\n-  if (a28.si[0] != +28)\t\t\t/* int */\n-    abort ();\n-\n-  if (a29.si[0] != -29)\t\t\t/* int */\n-    abort ();\n-\n-  if (a30.si[0] != +30)\t\t\t/* int */\n-    abort ();\n-\n-  if (a31.si[0] != -31)\t\t\t/* int */\n-    abort ();\n-\n-  if (a32.si[0] != +32)\t\t\t/* int */\n-    abort ();\n-\n-  if (a33.si[0] != -33)\t\t\t/* int */\n-    abort ();\n-\n-  if (a34.si[0] != +34)\t\t\t/* int */\n-    abort ();\n-\n-  if (a35.si[0] != -35)\t\t\t/* int */\n-    abort ();\n-\n-  if (a36.si[0] != +36)\t\t\t/* int */\n-    abort ();\n-\n-  if (a37.si[0] != -37)\t\t\t/* int */\n-    abort ();\n-\n-  if (a38.si[0] != +38)\t\t\t/* int */\n-    abort ();\n-\n-  if (a39.si[0] != -39)\t\t\t/* int */\n-    abort ();\n-\n-  if (a40.si[0] != +40)\t\t\t/* int */\n-    abort ();\n-\n-  if (a41.si[0] != -41)\t\t\t/* int */\n-    abort ();\n-\n-  if (a42.si[0] != +42)\t\t\t/* int */\n-    abort ();\n-\n-  if (a43.si[0] != -43)\t\t\t/* int */\n-    abort ();\n-\n-  if (a44.si[0] != +44)\t\t\t/* int */\n-    abort ();\n-\n-  if (a45.si[0] != -45)\t\t\t/* int */\n-    abort ();\n-\n-  if (a46.si[0] != +46)\t\t\t/* int */\n-    abort ();\n-\n-  if (a47.si[0] != -47)\t\t\t/* int */\n-    abort ();\n-\n-  if (a48.si[0] != +48)\t\t\t/* int */\n-    abort ();\n-\n-  if (a49.si[0] != -49)\t\t\t/* int */\n-    abort ();\n-\n-  if (a50.si[0] != +50)\t\t\t/* int */\n-    abort ();\n-\n-  if (a51.si[0] != -51)\t\t\t/* int */\n-    abort ();\n-\n-  if (a52.si[0] != +52)\t\t\t/* int */\n-    abort ();\n-\n-  if (a53.si[0] != -53)\t\t\t/* int */\n-    abort ();\n-\n-  if (a54.si[0] != +54)\t\t\t/* int */\n-    abort ();\n-\n-  if (a55.si[0] != -55)\t\t\t/* int */\n-    abort ();\n-\n-  if (a56.si[0] != +56)\t\t\t/* int */\n-    abort ();\n-\n-  if (a57.si[0] != -57)\t\t\t/* int */\n-    abort ();\n-\n-  if (a58.si[0] != +58)\t\t\t/* int */\n-    abort ();\n-\n-  if (a59.si[0] != -59)\t\t\t/* int */\n-    abort ();\n-\n-  if (a60.si[0] != +60)\t\t\t/* int */\n-    abort ();\n-\n-  if (a61.si[0] != -61)\t\t\t/* int */\n-    abort ();\n-\n-  if (a62.si[0] != +62)\t\t\t/* int */\n-    abort ();\n-\n-  if (a63.si[0] != -63)\t\t\t/* int */\n-    abort ();\n-\n-  if (a64.si[0] != +64)\t\t\t/* int */\n-    abort ();\n-\n-  if (a65.si[0] != -65)\t\t\t/* int */\n-    abort ();\n-\n-  if (a66.si[0] != +66)\t\t\t/* int */\n-    abort ();\n-\n-  if (a67.si[0] != -67)\t\t\t/* int */\n-    abort ();\n-\n-  if (a68.si[0] != +68)\t\t\t/* int */\n-    abort ();\n-\n-  if (a69.si[0] != -69)\t\t\t/* int */\n-    abort ();\n-\n-  if (a70.si[0] != +70)\t\t\t/* int */\n-    abort ();\n-\n-  if (a71.si[0] != -71)\t\t\t/* int */\n-    abort ();\n-\n-  if (a72.si[0] != +72)\t\t\t/* int */\n-    abort ();\n-\n-  /* arguments passed on the stack */\n-  if (a73.sc[3] != -73)\t\t\t/* signed char */\n-    abort ();\n-\n-  if (a74.uc[3] != 74)\t\t\t/* unsigned char */\n-    abort ();\n-\n-  if (a75.ss[1] != -75)\t\t\t/* short */\n-    abort ();\n-\n-  if (a76.us[1] != +76)\t\t\t/* unsigned short */\n-    abort ();\n-\n-  if (a77.si[0] != -77)\t\t\t/* int */\n-    abort ();\n-\n-  if (a78.ui[0] != +78)\t\t\t/* unsigned int */\n-    abort ();\n-\n-  if (a79.sl[0] != -79)\t\t\t/* long */\n-    abort ();\n-\n-  if (a80.ul[0] != +80)\t\t\t/* unsigned long */\n-    abort ();\n-\n-  if (a81.sll[0] != -81)\t\t/* long long */\n-    abort ();\n-\n-  if (a82.ull[0] != +82)\t\t/* unsigned long long */\n-    abort ();\n-\n-  if (a83.f[0] != -83.0f)\t\t/* float */\n-    abort ();\n-\n-  if (a84.d[0] != +84.0)\t\t/* double */\n-    abort ();\n-}\n-\n-int main(void)\n-{\n-  func_asm(-1,   +2,  -3,  +4,  -5,  +6,  -7,  +8,  -9, +10,\n-\t   -11, +12, -13, +14, -15, +16, -17, +18, -19, +20,\n-\t   -21, +22, -23, +24, -25, +26, -27, +28, -29, +30,\n-\t   -31, +32, -33, +34, -35, +36, -37, +38, -39, +40,\n-\t   -41, +42, -43, +44, -45, +46, -47, +48, -49, +50,\n-\t   -51, +52, -53, +54, -55, +56, -57, +58, -59, +60,\n-\t   -61, +62, -63, +64, -65, +66, -67, +68, -69, +70,\n-\t   -71, +72, -73, +74, -75, +76, -77, +78, -79, +80,\n-\t   -81, +82, -83, +84);\n-\n-  return 0;\n-}"}, {"sha": "cbc7663b967c42db2e3272ce5d2b4e045392a3c3", "filename": "gcc/testsuite/gcc.target/spu/compare-dp.c", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcompare-dp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcompare-dp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcompare-dp.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,10 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-final { scan-assembler-not \"__eqdf2\" } } */\n-\n-/* Ensure double precision comparisons are always inlined.  */\n-\n-int test (double a, double b) __attribute__((noinline));\n-int test (double a, double b)\n-{\n-  return a == b;\n-}"}, {"sha": "6fe2925621590180981cecf1e0f1abd6786ed364", "filename": "gcc/testsuite/gcc.target/spu/cpat-1.c", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-1.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,104 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -w\" } */\n-/* { dg-final { scan-assembler-times \"lqr\\t.3,.LC\" 4 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,0\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,1\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,2\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,3\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,4\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,5\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,6\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,7\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,8\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,9\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,10\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,11\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,12\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,13\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,14\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\\t.3,15\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\\t.3,0\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\\t.3,2\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\\t.3,4\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\\t.3,6\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\\t.3,8\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\\t.3,10\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\\t.3,12\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\\t.3,14\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cwd\\t.3,0\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cwd\\t.3,4\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cwd\\t.3,8\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cwd\\t.3,12\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cdd\\t.3,0\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cdd\\t.3,8\\\\(.sp\\\\)\" 1 } } */\n-\n-__vector unsigned char\n-not_cpat0()\n-{\n-  /* Contains no runs */\n-  return (__vector unsigned char) {\n-\t    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n-\t    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F};\n-}\n-\n-__vector unsigned char\n-not_cpat1()\n-{\n-  /* Includes 1 run but not in the right place. */\n-  return (__vector unsigned char) {\n-\t    0x10, 0x02, 0x03, 0x13, 0x14, 0x15, 0x16, 0x17,\n-\t    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F};\n-}\n-\n-__vector unsigned char\n-not_cpat2()\n-{\n-  /* Includes 2 runs. */\n-  return (__vector unsigned char) {\n-\t    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n-\t    0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03};\n-}\n-\n-__vector unsigned char\n-not_cpat3()\n-{\n-  /* Includes 1 incorrect run. */\n-  return (__vector unsigned char) {\n-\t    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n-\t    0x00, 0x01, 0x02, 0x03, 0x05, 0x06, 0x07, 0x1F};\n-}\n-\n-__vector unsigned char cbd_0() { return (__vector unsigned char) { 0x03, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_1() { return (__vector unsigned char) { 0x10, 0x03, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_2() { return (__vector unsigned char) { 0x10, 0x11, 0x03, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_3() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_4() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x03, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_5() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x03, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_6() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x03, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_7() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_8() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x03, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_9() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x03, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_a() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x03, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_b() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x03, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_c() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x03, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_d() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x03, 0x1E, 0x1F}; }\n-__vector unsigned char cbd_e() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x03, 0x1F}; }\n-__vector unsigned char cbd_f() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x03}; }\n-\n-__vector unsigned char chd_0() { return (__vector unsigned char) { 0x02, 0x03, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char chd_2() { return (__vector unsigned char) { 0x10, 0x11, 0x02, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char chd_4() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x02, 0x03, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char chd_6() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x02, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char chd_8() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x02, 0x03, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char chd_a() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x02, 0x03, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char chd_c() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x02, 0x03, 0x1E, 0x1F}; }\n-__vector unsigned char chd_e() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x02, 0x03}; }\n-\n-__vector unsigned char cwd_0() { return (__vector unsigned char) { 0x00, 0x01, 0x02, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cwd_4() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x00, 0x01, 0x02, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cwd_8() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x00, 0x01, 0x02, 0x03, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cwd_c() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x00, 0x01, 0x02, 0x03}; }\n-\n-__vector unsigned char cdd_0() { return (__vector unsigned char) { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; }\n-__vector unsigned char cdd_8() { return (__vector unsigned char) { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}; }\n-"}, {"sha": "d5f86ed30ad4119efeb96bdd2eaf5436c81d4d12", "filename": "gcc/testsuite/gcc.target/spu/cpat-2.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-2.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,44 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -w\" } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,0\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,1\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,2\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,3\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,15\\\\(.sp\\\\)\" 22 } } */\n-/* { dg-final { scan-assembler-times \"chd\t.3,0\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\t.3,2\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"ila\t.3,66051\" 2 } } */\n-\n-#define MAKE_UINT(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aA,aB,aC,aD,aE,aF) ((unsigned int)(a0 << 24 | a1 << 16 | a2 << 8 | a3))\n-\n-unsigned int cbd_0() { return MAKE_UINT( 0x03, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_1() { return MAKE_UINT( 0x10, 0x03, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_2() { return MAKE_UINT( 0x10, 0x11, 0x03, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_3() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_4() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x03, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_5() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x03, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_6() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x03, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_7() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_8() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x03, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_9() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x03, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_a() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x03, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_b() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x03, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_c() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x03, 0x1D, 0x1E, 0x1F); }\n-unsigned int cbd_d() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x03, 0x1E, 0x1F); }\n-unsigned int cbd_e() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x03, 0x1F); }\n-unsigned int cbd_f() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x03); }\n-unsigned int chd_0() { return MAKE_UINT( 0x02, 0x03, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int chd_2() { return MAKE_UINT( 0x10, 0x11, 0x02, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int chd_4() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x02, 0x03, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int chd_6() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x02, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int chd_8() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x02, 0x03, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int chd_a() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x02, 0x03, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int chd_c() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x02, 0x03, 0x1E, 0x1F); }\n-unsigned int chd_e() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x02, 0x03); }\n-unsigned int cwd_0() { return MAKE_UINT( 0x00, 0x01, 0x02, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cwd_4() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x00, 0x01, 0x02, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cwd_8() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x00, 0x01, 0x02, 0x03, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cwd_c() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x00, 0x01, 0x02, 0x03); }\n-unsigned int cdd_0() { return MAKE_UINT( 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned int cdd_8() { return MAKE_UINT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07); }\n-"}, {"sha": "ced50111f337fe6e7b59e439573f1cb170330cb0", "filename": "gcc/testsuite/gcc.target/spu/cpat-3.c", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-3.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,61 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -w\" } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,0\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,1\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,2\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,3\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,4\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,5\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,6\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,7\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cbd\t.3,15\\\\(.sp\\\\)\" 15 } } */\n-/* { dg-final { scan-assembler-times \"chd\t.3,0\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\t.3,2\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\t.3,4\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"chd\t.3,6\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cwd\t.3,0\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cwd\t.3,4\\\\(.sp\\\\)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"cdd\t.3,0\\\\(.sp\\\\)\" 1 } } */\n-\n-#define MAKE_ULLONG(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aA,aB,aC,aD,aE,aF) \\\n-  ((unsigned long long) \\\n-    (a0##ull << 56 \\\n-     | a1##ull << 48 \\\n-     | a2##ull << 40 \\\n-     | a3##ull << 32\\\n-     | a4##ull << 24\\\n-     | a5##ull << 16 \\\n-     | a6##ull << 8 \\\n-     | a7##ull ))\n-\n-unsigned long long cbd_0() { return MAKE_ULLONG( 0x03, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_1() { return MAKE_ULLONG( 0x10, 0x03, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_2() { return MAKE_ULLONG( 0x10, 0x11, 0x03, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_3() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_4() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x03, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_5() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x03, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_6() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x03, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_7() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_8() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x03, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_9() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x03, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_a() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x03, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_b() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x03, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_c() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x03, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cbd_d() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x03, 0x1E, 0x1F); }\n-unsigned long long cbd_e() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x03, 0x1F); }\n-unsigned long long cbd_f() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x03); }\n-unsigned long long chd_0() { return MAKE_ULLONG( 0x02, 0x03, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long chd_2() { return MAKE_ULLONG( 0x10, 0x11, 0x02, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long chd_4() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x02, 0x03, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long chd_6() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x02, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long chd_8() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x02, 0x03, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long chd_a() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x02, 0x03, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long chd_c() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x02, 0x03, 0x1E, 0x1F); }\n-unsigned long long chd_e() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x02, 0x03); }\n-unsigned long long cwd_0() { return MAKE_ULLONG( 0x00, 0x01, 0x02, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cwd_4() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x00, 0x01, 0x02, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cwd_8() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x00, 0x01, 0x02, 0x03, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cwd_c() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x00, 0x01, 0x02, 0x03); }\n-unsigned long long cdd_0() { return MAKE_ULLONG( 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned long long cdd_8() { return MAKE_ULLONG( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07); }\n-"}, {"sha": "89110a66d82937b8729bd10167e185ce949ec1a8", "filename": "gcc/testsuite/gcc.target/spu/cpat-4.c", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcpat-4.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,40 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -w\" } */\n-/* { dg-final { scan-assembler-times \"il\\t.3,4611\" 1 } } */\n-/* { dg-final { scan-assembler-times \"il\\t.3,4627\" 25 } } */\n-/* { dg-final { scan-assembler-times \"il\\t.3,515\" 3 } } */\n-/* { dg-final { scan-assembler-times \"il\\t.3,787\" 1 } } */\n-\n-#define MAKE_USHORT(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aA,aB,aC,aD,aE,aF) ((unsigned short)(a2 << 8 | a3))\n-\n-unsigned short cbd_0() { return MAKE_USHORT( 0x03, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_1() { return MAKE_USHORT( 0x10, 0x03, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_2() { return MAKE_USHORT( 0x10, 0x11, 0x03, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_3() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_4() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x03, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_5() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x03, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_6() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x03, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_7() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_8() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x03, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_9() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x03, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_a() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x03, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_b() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x03, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_c() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x03, 0x1D, 0x1E, 0x1F); }\n-unsigned short cbd_d() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x03, 0x1E, 0x1F); }\n-unsigned short cbd_e() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x03, 0x1F); }\n-unsigned short cbd_f() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x03); }\n-unsigned short chd_0() { return MAKE_USHORT( 0x02, 0x03, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short chd_2() { return MAKE_USHORT( 0x10, 0x11, 0x02, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short chd_4() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x02, 0x03, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short chd_6() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x02, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short chd_8() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x02, 0x03, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short chd_a() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x02, 0x03, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short chd_c() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x02, 0x03, 0x1E, 0x1F); }\n-unsigned short chd_e() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x02, 0x03); }\n-unsigned short cwd_0() { return MAKE_USHORT( 0x00, 0x01, 0x02, 0x03, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cwd_4() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x00, 0x01, 0x02, 0x03, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cwd_8() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x00, 0x01, 0x02, 0x03, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cwd_c() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x00, 0x01, 0x02, 0x03); }\n-unsigned short cdd_0() { return MAKE_USHORT( 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F); }\n-unsigned short cdd_8() { return MAKE_USHORT( 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07); }\n-"}, {"sha": "18ce0135638c74fa4771caf9a237198b486aea14", "filename": "gcc/testsuite/gcc.target/spu/dfcgt-nan.c", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcgt-nan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcgt-nan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcgt-nan.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,31 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-march=celledp -O1\" } */\n-/* { dg-final { scan-assembler \"dfceq\" } } */\n-\n-/* GCC previously transformed an \"a <= b\" test into \"! (a > b)\" when\n-   compiling with -march=celledp, so that the dfcgt instruction can be\n-   used to implement the comparison.\n-\n-   However, this transformation violates the IEEE-754 standard in the\n-   presence of NaN values.  If either a or b is a NaN, a <= b should\n-   evaluate to false according to IEEE rules.  However, after the\n-   transformation, a > b as implemented by dfcgt itself returns false,\n-   so the transformed test returns true.\n-\n-   Note that the equivalent transformation is valid for single-\n-   precision floating-point values on the Cell SPU, because the format\n-   does not have NaNs.  It is invalid for double-precision, even on\n-   Cell, however.  */\n-\n-int test (double a, double b) __attribute__ ((noinline));\n-int test (double a, double b)\n-{\n-  return a <= b;\n-}\n-\n-int main (void)\n-{\n-  double x = 0.0;\n-  double y = 0.0/0.0;\n-  return test (x, y);\n-}"}, {"sha": "9286361b343d23499d8b90ceb0f62f1667104dfc", "filename": "gcc/testsuite/gcc.target/spu/dfcmeq.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmeq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmeq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmeq.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,9 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-march=celledp -O1\" } */\n-/* { dg-final { scan-assembler \"dfcmeq\" } } */\n-\n-int foo(double x, double y)\n-{\n-  if (__builtin_fabs(x) == __builtin_fabs(y))\n-    return 0;\n-}"}, {"sha": "ef7ef5899f7903a2273822a993f52bc8584eaef4", "filename": "gcc/testsuite/gcc.target/spu/dfcmgt.c", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmgt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmgt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmgt.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,10 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-march=celledp -O1\" } */\n-/* { dg-final { scan-assembler \"dfcmgt\" } } */\n-\n-int foo(double x, double y)\n-{\n-  if (__builtin_fabs(x) > __builtin_fabs(y))\n-    return 0;\n-}\n-"}, {"sha": "3487ce9806bf5de03ab46ddb1c0d19f5de4a30c1", "filename": "gcc/testsuite/gcc.target/spu/ea/cache1.c", "status": "removed", "additions": 0, "deletions": 195, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcache1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcache1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcache1.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,195 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* { dg-do run } */\n-/* { dg-require-effective-target \"ealib\" } */\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include <ea.h>\n-#include <spu_cache.h>\n-\n-#ifdef __EA64__\n-#define addr unsigned long long\n-#else\n-#define addr unsigned long\n-#endif\n-\n-static __ea void *bigblock;\n-static __ea void *block;\n-static int *ls_block;\n-\n-extern char __cache_tag_array_size[];\n-#define CACHE_SIZE (4 * (int) &__cache_tag_array_size[0])\n-#define LINE_SIZE ((addr)128)\n-\n-void\n-init_mem (void)\n-{\n-  bigblock = malloc_ea (CACHE_SIZE + 2 * LINE_SIZE);\n-  block = malloc_ea (2 * LINE_SIZE);\n-  ls_block = malloc (LINE_SIZE);\n-\n-  memset_ea (bigblock, 0, CACHE_SIZE + 2 * LINE_SIZE);\n-  memset_ea (block, -1, 2 * LINE_SIZE);\n-  memset (ls_block, -1, LINE_SIZE);\n-  cache_flush ();\n-}\n-\n-/* Test 1: Simple cache fetching.  */\n-void\n-test1 (void)\n-{\n-  addr aligned = ((((addr) block) + LINE_SIZE - 1) & -LINE_SIZE);\n-  int *p1 = NULL;\n-  int *p2 = NULL;\n-  int i = 0;\n-\n-  /* First, check if the same addr give the same cache ptr.  */\n-  p1 = cache_fetch ((__ea void *) aligned);\n-  p2 = cache_fetch ((__ea void *) aligned);\n-\n-  if (p1 != p2)\n-    abort ();\n-\n-  /* Check that the data actually is in the cache. */\n-  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n-    {\n-      if (p1[i] != -1)\n-\tabort ();\n-    }\n-\n-  /* Check returning within the cache line. */\n-  p2 = cache_fetch ((__ea void *) (aligned + sizeof (int)));\n-\n-  if (p2 - p1 != 1)\n-    abort ();\n-\n-  /* Finally, check that fetching an LS pointer returns that pointer.  */\n-  p1 = cache_fetch ((__ea char *) ls_block);\n-  if (p1 != ls_block)\n-    abort ();\n-}\n-\n-/* Test 2: Eviction testing. */\n-void\n-test2 (void)\n-{\n-  addr aligned = ((((addr) block) + LINE_SIZE - 1) & -LINE_SIZE);\n-  int *p = NULL;\n-  int i = 0;\n-\n-  /* First check that clean evictions don't write back.  */\n-  p = cache_fetch ((__ea void *) aligned);\n-  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n-    p[i] = 0;\n-\n-  cache_evict ((__ea void *) aligned);\n-  memcpy_ea ((__ea char *) ls_block, (__ea void *) aligned, LINE_SIZE);\n-\n-  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n-    {\n-      if (ls_block[i] == 0)\n-\tabort ();\n-    }\n-\n-  /* Now check that dirty evictions do write back.  */\n-  p = cache_fetch_dirty ((__ea void *) aligned, LINE_SIZE);\n-  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n-    p[i] = 0;\n-\n-  cache_evict ((__ea void *) aligned);\n-  memcpy_ea ((__ea char *) ls_block, (__ea void *) aligned, LINE_SIZE);\n-\n-  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n-    {\n-      if (ls_block[i] != 0)\n-\tabort ();\n-    }\n-\n-  /* Finally, check that non-atomic writeback only writes dirty bytes.  */\n-\n-  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n-    {\n-      p = cache_fetch_dirty ((__ea void *) (aligned + i * sizeof (int)),\n-\t\t\t     (i % 2) * sizeof (int));\n-      p[0] = -1;\n-    }\n-\n-  cache_evict ((__ea void *) aligned);\n-  memcpy_ea ((__ea char *) ls_block, (__ea void *) aligned, LINE_SIZE);\n-\n-  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n-    {\n-      if ((ls_block[i] == -1) && (i % 2 == 0))\n-\tabort ();\n-      if ((ls_block[i] == 0) && (i % 2 == 1))\n-\tabort ();\n-    }\n-}\n-\n-/* Test LS forced-eviction. */\n-void\n-test3 (void)\n-{\n-  addr aligned = ((((addr) bigblock) + LINE_SIZE - 1) & -LINE_SIZE);\n-  char *test = NULL;\n-  char *ls = NULL;\n-  int i = 0;\n-\n-  /* Init memory, fill the cache to capacity.  */\n-  ls = cache_fetch_dirty ((__ea void *) aligned, LINE_SIZE);\n-  for (i = 1; i < (CACHE_SIZE / LINE_SIZE); i++)\n-    cache_fetch_dirty ((__ea void *) (aligned + i * LINE_SIZE), LINE_SIZE);\n-\n-  memset (ls, -1, LINE_SIZE);\n-  test = cache_fetch ((__ea void *) (aligned + CACHE_SIZE));\n-\n-  /* test == ls indicates cache collision.  */\n-  if (test != ls)\n-    abort ();\n-\n-  /* Make sure it actually wrote the cache line.  */\n-  for (i = 0; i < LINE_SIZE; i++)\n-    {\n-      if (ls[i] != 0)\n-\tabort ();\n-    }\n-\n-  ls = cache_fetch ((__ea void *) aligned);\n-\n-  /* test != ls indicates another entry was evicted.  */\n-  if (test == ls)\n-    abort ();\n-\n-  /* Make sure that the previous eviction actually wrote back.  */\n-  for (i = 0; i < LINE_SIZE; i++)\n-    {\n-      if (ls[i] != 0xFF)\n-\tabort ();\n-    }\n-}\n-\n-int\n-main (int argc, char **argv)\n-{\n-  init_mem ();\n-  test1 ();\n-  test2 ();\n-  test3 ();\n-\n-  return 0;\n-}"}, {"sha": "9ec4e15463058aea536799fe89ea9e2dcef2b1d9", "filename": "gcc/testsuite/gcc.target/spu/ea/cast1.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast1.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,43 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* { dg-do run } */\n-\n-extern void abort (void);\n-extern unsigned long long __ea_local_store;\n-\n-__ea int *ppu;\n-int x, *spu = &x, *spu2;\n-\n-int\n-main (int argc, char **argv)\n-{\n-  ppu = (__ea int *) spu;\n-  spu2 = (int *) ppu;\n-\n-#ifdef __EA32__\n-  if ((int) ppu != (int) __ea_local_store + (int) spu)\n-#else\n-  if ((unsigned long long) ppu != __ea_local_store + (unsigned long long)(int) spu)\n-#endif\n-\n-    abort ();\n-\n-  if (spu != spu2)\n-    abort ();\n-\n-  return 0;\n-}"}, {"sha": "6ce57dc4da740aa626bd85daf5393532f19c9644", "filename": "gcc/testsuite/gcc.target/spu/ea/cast2.c", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast2.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,74 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* { dg-do run } */\n-\n-extern void abort (void);\n-\n-int array[128];\n-\n-__ea int *ea;\n-int *lm;\n-\n-void verify_ea (void) __attribute__ ((noinline));\n-void\n-verify_ea (void)\n-{\n-  if (ea != (__ea int *)lm)\n-    abort ();\n-}\n-\n-void verify_lm (void) __attribute__ ((noinline));\n-void\n-verify_lm (void)\n-{\n-  if ((int *)ea != lm)\n-    abort ();\n-}\n-\n-void verify_diff (int x) __attribute__ ((noinline));\n-void\n-verify_diff (int x)\n-{\n-  if (ea - lm != x)\n-    abort ();\n-}\n-\n-int\n-main (int argc, char **argv)\n-{\n-  ea = 0;\n-  lm = 0;\n-  verify_ea ();\n-  verify_lm ();\n-  verify_diff (0);\n-\n-  ea = &array[64];\n-  lm = &array[64];\n-  verify_ea ();\n-  verify_lm ();\n-  verify_diff (0);\n-\n-  ea = &array[0];\n-  lm = &array[64];\n-  verify_diff (-64);\n-\n-  ea = &array[64];\n-  lm = &array[0];\n-  verify_diff (64);\n-\n-  return 0;\n-}"}, {"sha": "ee7a32ad29b585166a891be09f193e7ae37c11b4", "filename": "gcc/testsuite/gcc.target/spu/ea/compile1.c", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile1.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,109 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Valid __ea declarations.  */\n-\n-/* { dg-do compile } */\n-\n-/* Typedefs.  */\n-typedef __ea int ea_int_t;\n-typedef __ea int *ea_int_star_t;\n-typedef int outer_t;\n-\n-/* Externs.  */\n-\n-__ea extern int i1;\n-extern __ea int i2;\n-extern int __ea i3;\n-extern __ea ea_int_t i4;\t\t/* __ea qualifier permitted via typedef.  */\n-extern int __ea __ea __ea dupe;\t\t/* __ea duplicate permitted directly.  */\n-extern int __ea *ppu;\n-\n-/* Pointers.  */\n-__ea int *i4p;\n-\n-/* Structs.  */\n-struct st {\n-  __ea int *p;\n-};\n-\n-/* Variable definitions.  */\n-__ea int ii0;\n-int *__ea ii1;\n-static int __ea ii2;\n-\n-void\n-f1 ()\n-{\n-  int *spu;\n-  ppu = (ea_int_t *) spu;\n-  ppu = (ea_int_star_t) spu;\n-}\n-\n-void\n-f2 ()\n-{\n-  int *spu;\n-  spu = (int *) ppu;\n-  ppu = (__ea int *) spu;\n-}\n-\n-void\n-f3 ()\n-{\n-  int i = sizeof (__ea int);\n-}\n-\n-__ea int *f4 (void)\n-{\n-  return 0;\n-}\n-\n-int f5 (__ea int *parm)\n-{\n-  static __ea int local4;\n-  int tmp = local4;\n-  local4 = *parm;\n-  return tmp;\n-}\n-\n-static inline __ea void *f6 (__ea void *start)\n-{\n-  return 0;\n-}\n-\n-void f7 (void)\n-{\n-  __ea void *s1;\n-  auto __ea void *s2;\n-}\n-\n-__ea int *f8 (__ea int *x)\n-{\n-  register __ea int *y = x;\n-  __ea int *z = y;\n-  return z;\n-}\n-\n-long long f9 (__ea long long x[2])\n-{\n-  return x[0] + x[1];\n-}\n-\n-void f10 ()\n-{\n-  static __ea outer_t o;\n-}"}, {"sha": "58e64890e672cd158b047e9d1c425665dce28d1a", "filename": "gcc/testsuite/gcc.target/spu/ea/compile2.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile2.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,43 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Make sure __ea structure references work.  */\n-\n-/* { dg-do compile } */\n-\n-typedef unsigned long int uintptr_t;\n-\n-struct tostruct\n-{\n-  uintptr_t selfpc;\n-  long count;\n-  unsigned short link;\n-};\n-\n-/* froms are indexing tos */\n-static __ea unsigned short *froms;\n-static __ea struct tostruct *tos = 0;\n-\n-void\n-foo (uintptr_t frompc, uintptr_t selfpc)\n-{\n-  __ea unsigned short *frompcindex;\n-\n-  frompcindex = &froms[(frompc) / (4 * sizeof (*froms))];\n-  *frompcindex = tos[0].link;\n-\n-  return;\n-}"}, {"sha": "583635734b5ce7f7fd166a289cbabda655073616", "filename": "gcc/testsuite/gcc.target/spu/ea/cppdefine.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcppdefine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcppdefine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcppdefine.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,36 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Test default __EA32__/__EA64__ define.  */\n-\n-/* { dg-do compile } */\n-\n-#if !defined (__EA32__) && !defined (__EA64__)\n-#error both __EA32__ and __EA64__ undefined\n-#endif\n-\n-#if defined (__EA32__) && defined (__EA64__)\n-#error both __EA32__ and __EA64__ defined\n-#endif\n-\n-#ifdef __EA32__\n-int x [ sizeof (__ea char *) == 4 ? 1 : -1 ];\n-#endif\n-\n-#ifdef __EA64__\n-int x [ sizeof (__ea char *) == 8 ? 1 : -1 ];\n-#endif\n-"}, {"sha": "54114548486ba7ed2a2b9cfc2e1aa0b720473662", "filename": "gcc/testsuite/gcc.target/spu/ea/ea.exp", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fea.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fea.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fea.exp?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,54 +0,0 @@\n-#   Copyright (C) 2008-2019 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-# GCC testsuite that uses the `dg.exp' driver.\n-\n-# Exit immediately if this isn't a SPU target.\n-if { ![istarget spu-*-*] } then {\n-  return\n-}\n-\n-# Load support procs.\n-load_lib gcc-dg.exp\n-\n-# Return 1 if target __ea library functions are available\n-proc check_effective_target_ealib { } {\n-    return [check_no_compiler_messages ealib executable {\n-\t#include <ea.h>\n-\tint main (void)\n-\t{\n-\t    __ea void *ptr = malloc_ea (1024);\n-\t    return 0;\n-\t}\n-    }]\n-}\n-\n-# If a testcase doesn't have special options, use these.\n-# We do not use the global DEFAULT_CFLAGS as all test cases\n-# in this directory use the __ea address space qualifier\n-# extension and thus will not compile with -ansi.\n-set DEFAULT_EA_CFLAGS \"-std=gnu99 -pedantic-errors -O2\"\n-\n-# Initialize `dg'.\n-dg-init\n-\n-# Run all tests in both -mea32 and -mea64 mode.\n-set tests [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]]\n-dg-runtest $tests \"-mea32\" $DEFAULT_EA_CFLAGS\n-dg-runtest $tests \"-mea64\" $DEFAULT_EA_CFLAGS\n-\n-# All done.\n-dg-finish"}, {"sha": "7d0b5a11ca9477b64baffbdc216ffd8d67ee58d7", "filename": "gcc/testsuite/gcc.target/spu/ea/errors1.c", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors1.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,67 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Invalid __ea declarations.  */\n-\n-/* { dg-do compile } */\n-\n-typedef __ea int eaint;\n-\n-void func ()\n-{\n-  register __ea int local1; /* { dg-error \"'__ea' combined with 'register' qualifier for 'local1'\" } */\n-  auto __ea int local2;     /* { dg-error \"'__ea' combined with 'auto' qualifier for 'local2'\" } */\n-  __ea int local3;\t    /* { dg-error \"'__ea' specified for auto variable 'local3'\" } */\n-  register int *__ea p1;    /* { dg-error \"'__ea' combined with 'register' qualifier for 'p1'\" } */\n-  auto char *__ea p2;       /* { dg-error \"'__ea' combined with 'auto' qualifier for 'p2'\" } */\n-  void *__ea p3;            /* { dg-error \"'__ea' specified for auto variable 'p3'\" } */\n-  register __ea int a1[2];  /* { dg-error \"'__ea' combined with 'register' qualifier for 'a1'\" } */\n-  auto __ea char a2[1];     /* { dg-error \"'__ea' combined with 'auto' qualifier for 'a2'\" } */\n-  __ea char a3[5];          /* { dg-error \"'__ea' specified for auto variable 'a3'\" } */\n-  register eaint td1;       /* { dg-error \"'__ea' combined with 'register' qualifier for 'td1'\" } */\n-  auto eaint td2;           /* { dg-error \"'__ea' combined with 'auto' qualifier for 'td2'\" } */\n-  eaint td3;\t            /* { dg-error \"'__ea' specified for auto variable 'td3'\" } */\n-}\n-\n-void func2 (__ea int x)\t    /* { dg-error \"'__ea' specified for parameter 'x'\" } */\n-{ }\n-\n-void func2td (eaint x)\t    /* { dg-error \"'__ea' specified for parameter 'x'\" } */\n-{ }\n-\n-struct st {\n-  __ea int x;\t\t    /* { dg-error \"'__ea' specified for structure field 'x'\" } */\n-  eaint td;\t\t    /* { dg-error \"'__ea' specified for structure field 'td'\" } */\n-  int *__ea q;\t\t    /* { dg-error \"'__ea' specified for structure field 'q'\" } */\n-  int __ea b : 7;\t    /* { dg-error \"'__ea' specified for structure field 'b'\" } */\n-  int __ea : 1;\t\t    /* { dg-error \"'__ea' specified for structure field\" } */\n-} s;\n-\n-struct A { int a; };\n-\n-int func3 (int *__ea);\t    /* { dg-error \"'__ea' specified for unnamed parameter\" } */\n-int func3 (int *__ea x)\t    /* { dg-error \"'__ea' specified for parameter 'x'\" } */\n-{\n-  struct A i = (__ea struct A) { 1 };\t/* { dg-error \"compound literal qualified by address-space qualifier\" } */\n-  return i.a;\n-}\n-\n-extern __ea int ea_var;\t\t/* { dg-message \"note: previous declaration of 'ea_var' was here\" } */\n-int ea_var;\t\t\t/* { dg-error \"conflicting named address spaces \\\\(generic vs __ea\\\\) for 'ea_var'\" } */\n-\n-extern eaint ea_var_td;\t\t/* { dg-message \"note: previous declaration of 'ea_var_td' was here\" } */\n-int ea_var_td;\t\t\t/* { dg-error \"conflicting named address spaces \\\\(generic vs __ea\\\\) for 'ea_var_td'\" } */\n-"}, {"sha": "f8269e96dfec26f9b69d306c1ce53d9ee1d1a058", "filename": "gcc/testsuite/gcc.target/spu/ea/errors2.c", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors2.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,107 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Invalid __ea declarations.  */\n-\n-/* { dg-do compile } */\n-\n-__ea char ea_str[] = \"abc\";\n-char lm_str[] = \"abc\";\n-\n-__ea char *lm_ea_ptr1 = \"abc\";\t\t\t\t/* { dg-error \"initializer element is not computable at load time\" } */\n-__ea char *lm_ea_ptr2 = (__ea char *)\"abc\";\t\t/* { dg-error \"initializer element is not constant\" } */\n-__ea char *lm_ea_ptr3 = ea_str;\n-__ea char *lm_ea_ptr4 = (__ea char *)ea_str;\n-__ea char *lm_ea_ptr5 = lm_str;\t\t\t\t/* { dg-error \"initializer element is not computable at load time\" } */\n-__ea char *lm_ea_ptr6 = (__ea char *)lm_str;\t\t/* { dg-error \"initializer element is not constant\" } */\n-\n-__ea char * __ea ea_ea_ptr1 = ea_str;\n-__ea char * __ea ea_ea_ptr2 = (__ea char *)ea_str;\n-\n-char * __ea ea_lm_ptr1 = lm_str;\n-char * __ea ea_lm_ptr2 = (char *)lm_str;\n-\n-struct foo {\n-  int first;\n-  __ea char *ptr;\n-  int last;\n-};\n-\n-__ea struct foo ea_struct1 = {\n-  10,\n-  (__ea char *)0,\n-  11,\n-};\n-\n-__ea struct foo ea_struct2 = {\n-  20,\n-  0,\n-  21,\n-};\n-\n-struct foo ea_struct3 = {\n-  30,\n-  ea_str,\n-  31,\n-};\n-\n-struct foo ea_struct4 = {\n-  40,\n-  (__ea char *)lm_str,\t/* { dg-error \"(initializer element is not constant)|(near initialization)\" } */\n-  41,\n-};\n-\n-struct bar {\n-  int first;\n-  char *ptr;\n-  int last;\n-};\n-\n-__ea struct bar ea_struct5 = {\n-  50,\n-  0,\n-  51,\n-};\n-\n-__ea struct bar ea_struct6 = {\n-  60,\n-  (char *)0,\n-  61,\n-};\n-\n-__ea struct bar ea_struct7 = {\n-  70,\n-  lm_str,\n-  71,\n-};\n-\n-struct bar lm_struct8 = {\n-  80,\n-  0,\n-  81,\n-};\n-\n-struct bar lm_struct9 = {\n-  90,\n-  (char *)0,\n-  91,\n-};\n-\n-struct bar lm_struct10 = {\n-  100,\n-  lm_str,\n-  101,\n-};"}, {"sha": "99d6d691810a0d9e063e96e996490bf65e05011a", "filename": "gcc/testsuite/gcc.target/spu/ea/execute1.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute1.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,41 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* { dg-do compile } */\n-\n-#include <stdlib.h>\n-\n-__ea char str[] = \"abc\";\n-\n-int\n-main (void)\n-{\n-  __ea char *p = str;\n-\n-  if (*p++ != 'a')\n-    abort ();\n-\n-  if (*p++ != 'b')\n-    abort ();\n-\n-  if (*p++ != 'c')\n-    abort ();\n-\n-  if (*p++ != '\\0')\n-    abort ();\n-\n-  return 0;\n-}"}, {"sha": "5fce4e673ff9e60700553985b97d05b57131ff9d", "filename": "gcc/testsuite/gcc.target/spu/ea/execute2.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute2.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,41 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-\n-char str[] = \"abc\";\n-\n-int\n-main (void)\n-{\n-  __ea char *p = (__ea char *)str;\n-\n-  if (*p++ != 'a')\n-    abort ();\n-\n-  if (*p++ != 'b')\n-    abort ();\n-\n-  if (*p++ != 'c')\n-    abort ();\n-\n-  if (*p++ != '\\0')\n-    abort ();\n-\n-  return 0;\n-}"}, {"sha": "1b8c139d7af7131d9a9a1aef61544d5235cbf887", "filename": "gcc/testsuite/gcc.target/spu/ea/execute3.c", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute3.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,39 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-\n-int\n-main (void)\n-{\n-  __ea char *p = (__ea char *)\"abc\";\n-\n-  if (*p++ != 'a')\n-    abort ();\n-\n-  if (*p++ != 'b')\n-    abort ();\n-\n-  if (*p++ != 'c')\n-    abort ();\n-\n-  if (*p++ != '\\0')\n-    abort ();\n-\n-  return 0;\n-}"}, {"sha": "0d162f218205e04dc900d830fde3fc0ab98c8e58", "filename": "gcc/testsuite/gcc.target/spu/ea/ops1.c", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops1.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,94 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* This is the same as ops2.c except for the compile option.\n-   If you modify this code, please modify ops2.c as well.  */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -std=gnu99 -pedantic-errors -maddress-space-conversion\" } */\n-\n-#define __lm\n-\n-__ea int ea_var = 1;\n-__lm int lm_var = 2;\n-\n-typedef __ea int *ea_ptr_t;\n-typedef __lm int *lm_ptr_t;\n-\n-typedef __ea void *ea_vptr_t;\n-typedef __lm void *lm_vptr_t;\n-\n-ea_ptr_t ea, ea2;\n-lm_ptr_t lm, lm2;\n-\n-ea_vptr_t eav;\n-lm_vptr_t lmv;\n-\n-extern void call_ea (ea_ptr_t);\n-extern void call_lm (lm_ptr_t);\n-\n-/* Assignment, initialization, argument passing, and return.  */\n-void to_ea (void) { ea = lm; }\n-void to_lm (void) { lm = ea; }\t\t\t/* { dg-error \"assignment from pointer to non-enclosed address space\" } */\n-void init_ea (void) { ea_ptr_t l_ea = lm; }\n-void init_lm (void) { lm_ptr_t l_lm = ea; }\t/* { dg-error \"initialization from pointer to non-enclosed address space\" } */\n-ea_ptr_t ret_ea (void) { return lm; }\n-lm_ptr_t ret_lm (void) { return ea; }\t\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n-void call_ea2 (void) { call_ea (lm); }\n-void call_lm2 (void) { call_lm (ea); }\t\t/* { dg-error \"passing argument 1 of 'call_lm' from pointer to non-enclosed address space\" } */\n-\n-/* Explicit casts.  */\n-void to_ea_with_cast (void) { ea = (ea_ptr_t)lm; }\n-void to_lm_with_cast (void) { lm = (lm_ptr_t)ea; }\n-void init_ea_with_cast (void) { ea_ptr_t l_ea = (ea_ptr_t)lm; }\n-void init_lm_with_cast (void) { lm_ptr_t l_lm = (lm_ptr_t)ea; }\n-ea_ptr_t ret_ea_with_cast (void) { return (ea_ptr_t)lm; }\n-lm_ptr_t ret_lm_with_cast (void) { return (lm_ptr_t)ea; }\n-void call_ea2_with_cast (void) { call_ea ((ea_ptr_t)lm); }\n-void call_lm2_with_cast (void) { call_lm ((lm_ptr_t)ea); }\n-\n-/* Arithmetic operators.  */\n-int sub_eaea (void) { return ea - ea2; }\n-int sub_ealm (void) { return ea - lm2; }\n-int sub_lmea (void) { return lm - ea2; }\n-int sub_lmlm (void) { return lm - lm2; }\n-ea_ptr_t if_eaea1 (int test) { return test? ea : ea2; }\n-lm_ptr_t if_eaea2 (int test) { return test? ea : ea2; }\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n-ea_ptr_t if_ealm1 (int test) { return test? ea : lm2; }\n-lm_ptr_t if_ealm2 (int test) { return test? ea : lm2; }\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n-ea_ptr_t if_lmea1 (int test) { return test? lm : ea2; }\n-lm_ptr_t if_lmea2 (int test) { return test? lm : ea2; }\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n-ea_ptr_t if_lmlm1 (int test) { return test? lm : lm2; }\n-lm_ptr_t if_lmlm2 (int test) { return test? lm : lm2; }\n-\n-/* Relational operators.  */\n-int eq_eaea (void) { return ea == ea2; }\n-int eq_ealm (void) { return ea == lm2; }\n-int eq_lmea (void) { return lm == ea2; }\n-int eq_lmlm (void) { return lm == lm2; }\n-int lt_eaea (void) { return ea < ea2; }\n-int lt_ealm (void) { return ea < lm2; }\n-int lt_lmea (void) { return lm < ea2; }\n-int lt_lmlm (void) { return lm < lm2; }\n-\n-/* Null pointer.  */\n-void null_ea1 (void) { ea = 0; }\n-void null_ea2 (void) { ea = (void *)0; }\n-void null_ea3 (void) { ea = (__ea void *)0; }\n-void null_lm1 (void) { lm = 0; }\n-void null_lm2 (void) { lm = (void *)0; }\n-void null_lm3 (void) { lm = (__ea void *)0; }\t/* { dg-error \"assignment from pointer to non-enclosed address space\" } */\n-"}, {"sha": "2514e6b2095732089690cf4dbd0049519b894309", "filename": "gcc/testsuite/gcc.target/spu/ea/ops2.c", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops2.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,94 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* This is the same as ops1.c except for the compile option.\n-   If you modify this code, please modify ops1.c as well.  */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -std=gnu99 -pedantic-errors -mno-address-space-conversion\" } */\n-\n-#define __lm\n-\n-__ea int ea_var = 1;\n-__lm int lm_var = 2;\n-\n-typedef __ea int *ea_ptr_t;\n-typedef __lm int *lm_ptr_t;\n-\n-typedef __ea void *ea_vptr_t;\n-typedef __lm void *lm_vptr_t;\n-\n-ea_ptr_t ea, ea2;\n-lm_ptr_t lm, lm2;\n-\n-ea_vptr_t eav;\n-lm_vptr_t lmv;\n-\n-extern void call_ea (ea_ptr_t);\n-extern void call_lm (lm_ptr_t);\n-\n-/* Assignment, initialization, argument passing, and return.  */\n-void to_ea (void) { ea = lm; }\t\t\t/* { dg-error \"assignment from pointer to non-enclosed address space\" } */\n-void to_lm (void) { lm = ea; }\t\t\t/* { dg-error \"assignment from pointer to non-enclosed address space\" } */\n-void init_ea (void) { ea_ptr_t l_ea = lm; }\t/* { dg-error \"initialization from pointer to non-enclosed address space\" } */\n-void init_lm (void) { lm_ptr_t l_lm = ea; }\t/* { dg-error \"initialization from pointer to non-enclosed address space\" } */\n-ea_ptr_t ret_ea (void) { return lm; }\t\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n-lm_ptr_t ret_lm (void) { return ea; }\t\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n-void call_ea2 (void) { call_ea (lm); }\t\t/* { dg-error \"passing argument 1 of 'call_ea' from pointer to non-enclosed address space\" } */\n-void call_lm2 (void) { call_lm (ea); }\t\t/* { dg-error \"passing argument 1 of 'call_lm' from pointer to non-enclosed address space\" } */\n-\n-/* Explicit casts.  */\n-void to_ea_with_cast (void) { ea = (ea_ptr_t)lm; }\t\t/* { dg-warning \"cast to __ea address space pointer\" } */\n-void to_lm_with_cast (void) { lm = (lm_ptr_t)ea; }\t\t/* { dg-warning \"cast to generic address space pointer\" } */\n-void init_ea_with_cast (void) { ea_ptr_t l_ea = (ea_ptr_t)lm; }\t/* { dg-warning \"cast to __ea address space pointer\" } */\n-void init_lm_with_cast (void) { lm_ptr_t l_lm = (lm_ptr_t)ea; }\t/* { dg-warning \"cast to generic address space pointer\" } */\n-ea_ptr_t ret_ea_with_cast (void) { return (ea_ptr_t)lm; }\t/* { dg-warning \"cast to __ea address space pointer\" } */\n-lm_ptr_t ret_lm_with_cast (void) { return (lm_ptr_t)ea; }\t/* { dg-warning \"cast to generic address space pointer\" } */\n-void call_ea2_with_cast (void) { call_ea ((ea_ptr_t)lm); }\t/* { dg-warning \"cast to __ea address space pointer\" } */\n-void call_lm2_with_cast (void) { call_lm ((lm_ptr_t)ea); }\t/* { dg-warning \"cast to generic address space pointer\" } */\n-\n-/* Arithmetic operators.  */\n-int sub_eaea (void) { return ea - ea2; }\n-int sub_ealm (void) { return ea - lm2; }\t\t/* { dg-error \"invalid operands to binary -\" } */\n-int sub_lmea (void) { return lm - ea2; }\t\t/* { dg-error \"invalid operands to binary -\" } */\n-int sub_lmlm (void) { return lm - lm2; }\n-ea_ptr_t if_eaea1 (int test) { return test? ea : ea2; }\n-lm_ptr_t if_eaea2 (int test) { return test? ea : ea2; }\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n-ea_ptr_t if_ealm1 (int test) { return test? ea : lm2; } /* { dg-error \"pointers to disjoint address spaces used in conditional expression\" } */\n-lm_ptr_t if_ealm2 (int test) { return test? ea : lm2; } /* { dg-error \"pointers to disjoint address spaces used in conditional expression\" } */\n-ea_ptr_t if_lmea1 (int test) { return test? lm : ea2; } /* { dg-error \"pointers to disjoint address spaces used in conditional expression\" } */\n-lm_ptr_t if_lmea2 (int test) { return test? lm : ea2; } /* { dg-error \"pointers to disjoint address spaces used in conditional expression\" } */\n-ea_ptr_t if_lmlm1 (int test) { return test? lm : lm2; }\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n-lm_ptr_t if_lmlm2 (int test) { return test? lm : lm2; }\n-\n-/* Relational operators.  */\n-int eq_eaea (void) { return ea == ea2; }\n-int eq_ealm (void) { return ea == lm2; }\t/* { dg-error \"comparison of pointers to disjoint address spaces\" } */\n-int eq_lmea (void) { return lm == ea2; }\t/* { dg-error \"comparison of pointers to disjoint address spaces\" } */\n-int eq_lmlm (void) { return lm == lm2; }\n-int lt_eaea (void) { return ea < ea2; }\n-int lt_ealm (void) { return ea < lm2; }\t\t/* { dg-error \"comparison of pointers to disjoint address spaces\" } */\n-int lt_lmea (void) { return lm < ea2; }\t\t/* { dg-error \"comparison of pointers to disjoint address spaces\" } */\n-int lt_lmlm (void) { return lm < lm2; }\n-\n-/* Null pointer.  */\n-void null_ea1 (void) { ea = 0; }\n-void null_ea2 (void) { ea = (void *)0; }\n-void null_ea3 (void) { ea = (__ea void *)0; }\n-void null_lm1 (void) { lm = 0; }\n-void null_lm2 (void) { lm = (void *)0; }\n-void null_lm3 (void) { lm = (__ea void *)0; }\t/* { dg-error \"assignment from pointer to non-enclosed address space\" } */\n-"}, {"sha": "19040090206db85c426e6fbd236da9bf3c35a3b4", "filename": "gcc/testsuite/gcc.target/spu/ea/options1.c", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Foptions1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Foptions1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Foptions1.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,22 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Test -mcache-size.  */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-mcache-size=128\" } */\n-\n-int x;"}, {"sha": "17710674cf6d504b12a5973ef9e2887dae180e9c", "filename": "gcc/testsuite/gcc.target/spu/ea/pr41857.c", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fpr41857.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fpr41857.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fpr41857.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,29 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* { dg-do compile } */\n-\n-__ea char *strchr_ea (__ea const char *s, int c);\n-__ea char *foo (__ea char *s)\n-{\n-  __ea char *ret = s;\n-  int i;\n-\n-  for (i = 0; i < 3; i++)\n-    ret = strchr_ea (ret, s[i]);\n- \n-  return ret;\n-}"}, {"sha": "e467616b6280f5379848043339dab7a04e234e80", "filename": "gcc/testsuite/gcc.target/spu/ea/test-sizes.c", "status": "removed", "additions": 0, "deletions": 608, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ftest-sizes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ftest-sizes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ftest-sizes.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,608 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* { dg-do run } */\n-\n-#ifdef __EA32__\n-#define EA_PTRSIZE 4\n-#endif\n-#ifdef __EA64__\n-#define EA_PTRSIZE 8\n-#endif\n-\n-#if !defined(LEVEL1) && !defined(LEVEL2) && !defined(LEVEL3)\n-#define LEVEL1 1\t\t/* single pointer indirection */\n-#define LEVEL2 1\t\t/* 2 levels of pointer indirection */\n-#define LEVEL3 1\t\t/* 3 levels of pointer indirection */\n-\n-#else\n-#ifndef LEVEL1\n-#define LEVEL1 0\n-#endif\n-\n-#ifndef LEVEL2\n-#define LEVEL2 0\n-#endif\n-\n-#ifndef LEVEL3\n-#define LEVEL3 0\n-#endif\n-#endif\n-\n-#if !defined(USE_SIMPLE) && !defined(USE_COMPLEX)\n-#define USE_SIMPLE  1\t\t/* build up pointers via multiple typedefs */\n-#define USE_COMPLEX 1\t\t/* single typedef for pointer indirections */\n-\n-#else\n-#ifndef USE_SIMPLE\n-#define USE_SIMPLE 0\n-#endif\n-\n-#ifndef USE_COMPLEX\n-#define USE_COMPLEX 0\n-#endif\n-#endif\n-\n-#if !defined(USE_LOCAL_VAR) && !defined(USE_EA_VAR)\n-#define USE_LOCAL_VAR 1\t\t/* use variables declared locally */\n-#define USE_EA_VAR    1\t\t/* use variables on the host */\n-\n-#else\n-#ifndef USE_LOCAL_VAR\n-#define USE_LOCAL_VAR 0\n-#endif\n-\n-#ifndef USE_EA_VAR\n-#define USE_EA_VAR    0\n-#endif\n-#endif\n-\n-static int errors;\n-\n-#ifdef USE_PRINTF\t\t/* print results via printf */\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-static int num_tests;\n-\n-#define TEST_SIZE(EXPR, EXPECTED)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  char *msg;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (sizeof (EXPR) != EXPECTED)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      msg = \", FAIL\";\t\t\t\t\t\t\t\\\n-      errors++;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    msg = \"\";\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  num_tests++;\t\t\t\t\t\t\t\t\\\n-  printf (\"sizeof %-20s = %2u, expected = %2u%s\\n\",\t\t\t\\\n-\t  #EXPR,\t\t\t\t\t\t\t\\\n-\t  (unsigned) sizeof (EXPR),\t\t\t\t\t\\\n-\t  (unsigned) EXPECTED,\t\t\t\t\t\t\\\n-\t  msg);\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define PRINT1(FMT)\t  printf (FMT)\n-#define PRINT2(FMT,A1)\t  printf (FMT,A1)\n-#define PRINT3(FMT,A1,A2) printf (FMT,A1,A2)\n-\n-#else\t/* standalone */\n-extern void abort (void);\n-\n-#define TEST_SIZE(EXPR, EXPECTED)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (sizeof (EXPR) != EXPECTED)\t\t\t\t\t\\\n-    abort ();\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define PRINT1(FMT)\n-#define PRINT2(FMT,ARG)\n-#define PRINT3(FMT,A1,A2)\n-#endif\n-\n-/* 'local memory' hack to keep the same spacing.  */\n-#define __lm\n-\n-#if USE_SIMPLE\n-#if (LEVEL1 || LEVEL2 || LEVEL3)\n-typedef __lm char *lm_ptr_t;\n-typedef __ea char *ea_ptr_t;\n-#endif\n-\n-#if LEVEL1\n-#if USE_LOCAL_VAR\n-__lm lm_ptr_t lm_ptr;\n-__lm ea_ptr_t ea_ptr;\n-#endif\n-\n-#if USE_EA_VAR\n-__ea lm_ptr_t lm_ptr_ea;\n-__ea ea_ptr_t ea_ptr_ea;\n-#endif\n-#endif\n-\n-#if (LEVEL2 || LEVEL3)\n-typedef __lm lm_ptr_t *lm_lm_ptr_t;\n-typedef __ea lm_ptr_t *ea_lm_ptr_t;\n-typedef __lm ea_ptr_t *lm_ea_ptr_t;\n-typedef __ea ea_ptr_t *ea_ea_ptr_t;\n-#endif\n-\n-#if LEVEL2\n-#if USE_LOCAL_VAR\n-__lm lm_lm_ptr_t lm_lm_ptr;\n-__lm ea_lm_ptr_t ea_lm_ptr;\n-__lm lm_ea_ptr_t lm_ea_ptr;\n-__lm ea_ea_ptr_t ea_ea_ptr;\n-#endif\n-\n-#if USE_EA_VAR\n-__ea lm_lm_ptr_t lm_lm_ptr_ea;\n-__ea ea_lm_ptr_t ea_lm_ptr_ea;\n-__ea lm_ea_ptr_t lm_ea_ptr_ea;\n-__ea ea_ea_ptr_t ea_ea_ptr_ea;\n-#endif\n-#endif\n-\n-#if LEVEL3\n-typedef __lm lm_lm_ptr_t *lm_lm_lm_ptr_t;\n-typedef __ea lm_lm_ptr_t *ea_lm_lm_ptr_t;\n-typedef __lm ea_lm_ptr_t *lm_ea_lm_ptr_t;\n-typedef __ea ea_lm_ptr_t *ea_ea_lm_ptr_t;\n-typedef __lm lm_ea_ptr_t *lm_lm_ea_ptr_t;\n-typedef __ea lm_ea_ptr_t *ea_lm_ea_ptr_t;\n-typedef __lm ea_ea_ptr_t *lm_ea_ea_ptr_t;\n-typedef __ea ea_ea_ptr_t *ea_ea_ea_ptr_t;\n-\n-#if USE_LOCAL_VAR\n-__lm lm_lm_lm_ptr_t lm_lm_lm_ptr;\n-__lm ea_lm_lm_ptr_t ea_lm_lm_ptr;\n-__lm lm_ea_lm_ptr_t lm_ea_lm_ptr;\n-__lm ea_ea_lm_ptr_t ea_ea_lm_ptr;\n-__lm lm_lm_ea_ptr_t lm_lm_ea_ptr;\n-__lm ea_lm_ea_ptr_t ea_lm_ea_ptr;\n-__lm lm_ea_ea_ptr_t lm_ea_ea_ptr;\n-__lm ea_ea_ea_ptr_t ea_ea_ea_ptr;\n-#endif\n-\n-#if USE_EA_VAR\n-__ea lm_lm_lm_ptr_t lm_lm_lm_ptr_ea;\n-__ea ea_lm_lm_ptr_t ea_lm_lm_ptr_ea;\n-__ea lm_ea_lm_ptr_t lm_ea_lm_ptr_ea;\n-__ea ea_ea_lm_ptr_t ea_ea_lm_ptr_ea;\n-__ea lm_lm_ea_ptr_t lm_lm_ea_ptr_ea;\n-__ea ea_lm_ea_ptr_t ea_lm_ea_ptr_ea;\n-__ea lm_ea_ea_ptr_t lm_ea_ea_ptr_ea;\n-__ea ea_ea_ea_ptr_t ea_ea_ea_ptr_ea;\n-#endif\n-#endif\n-#endif\n-\n-#if USE_COMPLEX\n-#if LEVEL1\n-#if USE_LOCAL_VAR\n-__lm char *__lm lm_cptr;\n-__ea char *__lm ea_cptr;\n-#endif\n-\n-#if USE_EA_VAR\n-__lm char *__ea lm_cptr_ea;\n-__ea char *__ea ea_cptr_ea;\n-#endif\n-#endif\n-\n-#if LEVEL2\n-#if USE_LOCAL_VAR\n-__lm char *__lm *__lm lm_lm_cptr;\n-__lm char *__ea *__lm ea_lm_cptr;\n-__ea char *__lm *__lm lm_ea_cptr;\n-__ea char *__ea *__lm ea_ea_cptr;\n-#endif\n-\n-#if USE_EA_VAR\n-__lm char *__lm *__ea lm_lm_cptr_ea;\n-__lm char *__ea *__ea ea_lm_cptr_ea;\n-__ea char *__lm *__ea lm_ea_cptr_ea;\n-__ea char *__ea *__ea ea_ea_cptr_ea;\n-#endif\n-#endif\n-\n-#if LEVEL3\n-#if USE_LOCAL_VAR\n-__lm char *__lm *__lm *__lm lm_lm_lm_cptr;\n-__lm char *__ea *__lm *__lm lm_ea_lm_cptr;\n-__ea char *__lm *__lm *__lm lm_lm_ea_cptr;\n-__ea char *__ea *__lm *__lm lm_ea_ea_cptr;\n-__lm char *__lm *__ea *__lm ea_lm_lm_cptr;\n-__lm char *__ea *__ea *__lm ea_ea_lm_cptr;\n-__ea char *__lm *__ea *__lm ea_lm_ea_cptr;\n-__ea char *__ea *__ea *__lm ea_ea_ea_cptr;\n-#endif\n-\n-#if USE_EA_VAR\n-__lm char *__lm *__lm *__ea lm_lm_lm_cptr_ea;\n-__lm char *__ea *__lm *__ea lm_ea_lm_cptr_ea;\n-__ea char *__lm *__lm *__ea lm_lm_ea_cptr_ea;\n-__ea char *__ea *__lm *__ea lm_ea_ea_cptr_ea;\n-__lm char *__lm *__ea *__ea ea_lm_lm_cptr_ea;\n-__lm char *__ea *__ea *__ea ea_ea_lm_cptr_ea;\n-__ea char *__lm *__ea *__ea ea_lm_ea_cptr_ea;\n-__ea char *__ea *__ea *__ea ea_ea_ea_cptr_ea;\n-#endif\n-#endif\n-#endif\n-\n-int\n-main ()\n-{\n-  PRINT2 (\"LEVEL1        = %d\\n\", LEVEL1);\n-  PRINT2 (\"LEVEL2        = %d\\n\", LEVEL2);\n-  PRINT2 (\"LEVEL3        = %d\\n\", LEVEL3);\n-  PRINT2 (\"USE_SIMPLE    = %d\\n\", USE_SIMPLE);\n-  PRINT2 (\"USE_COMPLEX   = %d\\n\", USE_COMPLEX);\n-  PRINT2 (\"USE_LOCAL_VAR = %d\\n\", USE_LOCAL_VAR);\n-  PRINT2 (\"USE_EA_VAR    = %d\\n\", USE_EA_VAR);\n-  PRINT1 (\"\\n\");\n-\n-#if USE_SIMPLE\n-#if LEVEL1\n-#if USE_LOCAL_VAR\n-  TEST_SIZE ( lm_ptr, 4);\n-  TEST_SIZE (*lm_ptr, 1);\n-  TEST_SIZE ( ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE (*ea_ptr, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-\n-#if USE_EA_VAR\n-  TEST_SIZE ( lm_ptr_ea, 4);\n-  TEST_SIZE (*lm_ptr_ea, 1);\n-  TEST_SIZE ( ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (*ea_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-#endif\n-\n-#if LEVEL2\n-#if USE_LOCAL_VAR\n-  TEST_SIZE (  lm_lm_ptr, 4);\n-  TEST_SIZE ( *lm_lm_ptr, 4);\n-  TEST_SIZE (**lm_lm_ptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  lm_ea_ptr, 4);\n-  TEST_SIZE ( *lm_ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE (**lm_ea_ptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  ea_lm_ptr, EA_PTRSIZE);\n-  TEST_SIZE ( *ea_lm_ptr, 4);\n-  TEST_SIZE (**ea_lm_ptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  ea_ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE ( *ea_ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE (**ea_ea_ptr, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-\n-#if USE_EA_VAR\n-  TEST_SIZE (  lm_lm_ptr_ea, 4);\n-  TEST_SIZE ( *lm_lm_ptr_ea, 4);\n-  TEST_SIZE (**lm_lm_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  lm_ea_ptr_ea, 4);\n-  TEST_SIZE ( *lm_ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (**lm_ea_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  ea_lm_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( *ea_lm_ptr_ea, 4);\n-  TEST_SIZE (**ea_lm_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  ea_ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( *ea_ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (**ea_ea_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-#endif\n-\n-#if LEVEL3\n-#if USE_LOCAL_VAR\n-  TEST_SIZE (   lm_lm_lm_ptr, 4);\n-  TEST_SIZE (  *lm_lm_lm_ptr, 4);\n-  TEST_SIZE ( **lm_lm_lm_ptr, 4);\n-  TEST_SIZE (***lm_lm_lm_ptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_lm_ea_ptr, 4);\n-  TEST_SIZE (  *lm_lm_ea_ptr, 4);\n-  TEST_SIZE ( **lm_lm_ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE (***lm_lm_ea_ptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_ea_lm_ptr, 4);\n-  TEST_SIZE (  *lm_ea_lm_ptr, EA_PTRSIZE);\n-  TEST_SIZE ( **lm_ea_lm_ptr, 4);\n-  TEST_SIZE (***lm_ea_lm_ptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_ea_ea_ptr, 4);\n-  TEST_SIZE (  *lm_ea_ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE ( **lm_ea_ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE (***lm_ea_ea_ptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_lm_lm_ptr, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_lm_lm_ptr, 4);\n-  TEST_SIZE ( **ea_lm_lm_ptr, 4);\n-  TEST_SIZE (***ea_lm_lm_ptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_lm_ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_lm_ea_ptr, 4);\n-  TEST_SIZE ( **ea_lm_ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE (***ea_lm_ea_ptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_ea_lm_ptr, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_ea_lm_ptr, EA_PTRSIZE);\n-  TEST_SIZE ( **ea_ea_lm_ptr, 4);\n-  TEST_SIZE (***ea_ea_lm_ptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_ea_ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_ea_ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE ( **ea_ea_ea_ptr, EA_PTRSIZE);\n-  TEST_SIZE (***ea_ea_ea_ptr, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-\n-#if USE_EA_VAR\n-  TEST_SIZE (   lm_lm_lm_ptr_ea, 4);\n-  TEST_SIZE (  *lm_lm_lm_ptr_ea, 4);\n-  TEST_SIZE ( **lm_lm_lm_ptr_ea, 4);\n-  TEST_SIZE (***lm_lm_lm_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_lm_ea_ptr_ea, 4);\n-  TEST_SIZE (  *lm_lm_ea_ptr_ea, 4);\n-  TEST_SIZE ( **lm_lm_ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (***lm_lm_ea_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_ea_lm_ptr_ea, 4);\n-  TEST_SIZE (  *lm_ea_lm_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( **lm_ea_lm_ptr_ea, 4);\n-  TEST_SIZE (***lm_ea_lm_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_ea_ea_ptr_ea, 4);\n-  TEST_SIZE (  *lm_ea_ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( **lm_ea_ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (***lm_ea_ea_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_lm_lm_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_lm_lm_ptr_ea, 4);\n-  TEST_SIZE ( **ea_lm_lm_ptr_ea, 4);\n-  TEST_SIZE (***ea_lm_lm_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_lm_ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_lm_ea_ptr_ea, 4);\n-  TEST_SIZE ( **ea_lm_ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (***ea_lm_ea_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_ea_lm_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_ea_lm_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( **ea_ea_lm_ptr_ea, 4);\n-  TEST_SIZE (***ea_ea_lm_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_ea_ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_ea_ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( **ea_ea_ea_ptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (***ea_ea_ea_ptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-#endif\n-#endif\n-\n-#if USE_COMPLEX\n-#if LEVEL1\n-#if USE_LOCAL_VAR\n-  TEST_SIZE ( lm_cptr, 4);\n-  TEST_SIZE (*lm_cptr, 1);\n-  TEST_SIZE ( ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE (*ea_cptr, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-\n-#if USE_EA_VAR\n-  TEST_SIZE ( lm_cptr_ea, 4);\n-  TEST_SIZE (*lm_cptr_ea, 1);\n-  TEST_SIZE ( ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (*ea_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-#endif\n-\n-#if LEVEL2\n-#if USE_LOCAL_VAR\n-  TEST_SIZE (  lm_lm_cptr, 4);\n-  TEST_SIZE ( *lm_lm_cptr, 4);\n-  TEST_SIZE (**lm_lm_cptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  lm_ea_cptr, 4);\n-  TEST_SIZE ( *lm_ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE (**lm_ea_cptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  ea_lm_cptr, EA_PTRSIZE);\n-  TEST_SIZE ( *ea_lm_cptr, 4);\n-  TEST_SIZE (**ea_lm_cptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  ea_ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE ( *ea_ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE (**ea_ea_cptr, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-\n-#if USE_EA_VAR\n-  TEST_SIZE (  lm_lm_cptr_ea, 4);\n-  TEST_SIZE ( *lm_lm_cptr_ea, 4);\n-  TEST_SIZE (**lm_lm_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  lm_ea_cptr_ea, 4);\n-  TEST_SIZE ( *lm_ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (**lm_ea_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  ea_lm_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( *ea_lm_cptr_ea, 4);\n-  TEST_SIZE (**ea_lm_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (  ea_ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( *ea_ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (**ea_ea_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-#endif\n-\n-#if LEVEL3\n-#if USE_LOCAL_VAR\n-  TEST_SIZE (   lm_lm_lm_cptr, 4);\n-  TEST_SIZE (  *lm_lm_lm_cptr, 4);\n-  TEST_SIZE ( **lm_lm_lm_cptr, 4);\n-  TEST_SIZE (***lm_lm_lm_cptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_lm_ea_cptr, 4);\n-  TEST_SIZE (  *lm_lm_ea_cptr, 4);\n-  TEST_SIZE ( **lm_lm_ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE (***lm_lm_ea_cptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_ea_lm_cptr, 4);\n-  TEST_SIZE (  *lm_ea_lm_cptr, EA_PTRSIZE);\n-  TEST_SIZE ( **lm_ea_lm_cptr, 4);\n-  TEST_SIZE (***lm_ea_lm_cptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_ea_ea_cptr, 4);\n-  TEST_SIZE (  *lm_ea_ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE ( **lm_ea_ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE (***lm_ea_ea_cptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_lm_lm_cptr, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_lm_lm_cptr, 4);\n-  TEST_SIZE ( **ea_lm_lm_cptr, 4);\n-  TEST_SIZE (***ea_lm_lm_cptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_lm_ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_lm_ea_cptr, 4);\n-  TEST_SIZE ( **ea_lm_ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE (***ea_lm_ea_cptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_ea_lm_cptr, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_ea_lm_cptr, EA_PTRSIZE);\n-  TEST_SIZE ( **ea_ea_lm_cptr, 4);\n-  TEST_SIZE (***ea_ea_lm_cptr, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_ea_ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_ea_ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE ( **ea_ea_ea_cptr, EA_PTRSIZE);\n-  TEST_SIZE (***ea_ea_ea_cptr, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-\n-#if USE_EA_VAR\n-  TEST_SIZE (   lm_lm_lm_cptr_ea, 4);\n-  TEST_SIZE (  *lm_lm_lm_cptr_ea, 4);\n-  TEST_SIZE ( **lm_lm_lm_cptr_ea, 4);\n-  TEST_SIZE (***lm_lm_lm_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_lm_ea_cptr_ea, 4);\n-  TEST_SIZE (  *lm_lm_ea_cptr_ea, 4);\n-  TEST_SIZE ( **lm_lm_ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (***lm_lm_ea_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_ea_lm_cptr_ea, 4);\n-  TEST_SIZE (  *lm_ea_lm_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( **lm_ea_lm_cptr_ea, 4);\n-  TEST_SIZE (***lm_ea_lm_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   lm_ea_ea_cptr_ea, 4);\n-  TEST_SIZE (  *lm_ea_ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( **lm_ea_ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (***lm_ea_ea_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_lm_lm_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_lm_lm_cptr_ea, 4);\n-  TEST_SIZE ( **ea_lm_lm_cptr_ea, 4);\n-  TEST_SIZE (***ea_lm_lm_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_lm_ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_lm_ea_cptr_ea, 4);\n-  TEST_SIZE ( **ea_lm_ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (***ea_lm_ea_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_ea_lm_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_ea_lm_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( **ea_ea_lm_cptr_ea, 4);\n-  TEST_SIZE (***ea_ea_lm_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-\n-  TEST_SIZE (   ea_ea_ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (  *ea_ea_ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE ( **ea_ea_ea_cptr_ea, EA_PTRSIZE);\n-  TEST_SIZE (***ea_ea_ea_cptr_ea, 1);\n-  PRINT1 (\"\\n\");\n-#endif\n-#endif\n-#endif\n-\n-  if (errors)\n-    {\n-      PRINT3 (\"%d error(s), %d test(s)\\n\", errors, num_tests);\n-      abort ();\n-    }\n-  else\n-    PRINT2 (\"No errors, %d test(s)\\n\", num_tests);\n-\n-  return 0;\n-}"}, {"sha": "099328378c74bebca4fc533e4c9037f7f50fbe96", "filename": "gcc/testsuite/gcc.target/spu/fixed-range-bad.c", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ffixed-range-bad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ffixed-range-bad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ffixed-range-bad.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,5 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-mfixed-range=1-x\" } */\n-/* { dg-warning \"unknown register name\" \"\" { target spu-*-* } 0 } */\n-\n-int i;"}, {"sha": "8dcb7fe4c251392e1241e984cb917b45619127e0", "filename": "gcc/testsuite/gcc.target/spu/fixed-range.c", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ffixed-range.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ffixed-range.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ffixed-range.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,8 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-mfixed-range=1-20\" } */\n-/* { dg-final { scan-assembler \"lqd.*21\" } } */\n-\n-int foo (int i)\n-{\n-  return i;\n-}"}, {"sha": "b8974f608c81af05a8cac3ba36c2db78cbb1ef5d", "filename": "gcc/testsuite/gcc.target/spu/intrinsics-1.c", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-1.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,24 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-std=c99 -pedantic-errors\" } */\n-#include <spu_intrinsics.h>\n-/* With this intrinsics section, we used to ICE as we would try\n-   to convert from an vector to an integer type.  */\n-void f(void)\n-{\n-  vec_uint4 gt, N;\n-  vec_int4 a;\n-  int *a1;\n-  _Complex double b;\n-  gt = spu_cmpgt(a, N); /* { dg-error \"parameter list\" } */\n-\n-  gt = spu_cmpgt(a, a1); /* { dg-error \"integer from pointer without a cast\" } */\n-  /* { dg-message \"note: expected 'int'\" \"\" { target *-*-* } .-1 } */\n-\n-  gt = spu_cmpgt(a, b); /* { dg-error \"parameter list\" } */\n-\n-  gt = spu_cmpgt(a, a);\n-\n-  a = spu_cmpgt(a, a);\n-  /* { dg-message \"note: use -flax-vector-conversions to permit conversions between vectors with differing element types or numbers of subparts\" \"\" { target *-*-* } .-1 } */\n-  /* { dg-error \"incompatible types when assigning\" \"\" { target *-*-* } .-2 } */\n-}"}, {"sha": "43a272b91d8f03fbb899e946bca6de56ffdda32e", "filename": "gcc/testsuite/gcc.target/spu/intrinsics-2.c", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-2.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,305 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-std=c99\" } */\n-#include <vec_types.h>\n-extern void abort (void);\n-extern void exit (int);\n-\n-typedef union {\n-  vec_ullong2   vull;\n-  vec_double2   vd;\n-  unsigned int  ui[4];\n-  unsigned long long ull[2];\n-  double        d[2];\n-} v128;\n-\n-static v128 a, b, c, d, a0, b0, a1, b1;\n-static int samples = 10;\n-unsigned int seed = 0;\n-\n-unsigned int rand_local()\n-{\n-  seed = seed * 69607 + 54329;\n-  return (seed);\n-}\n-\n-double rand_double(double min, double max)\n-{\n-  union {\n-    unsigned int ui[2];\n-    double d;\n-  } x;\n-\n-  x.ui[0] = (rand_local() & 0x000FFFFF) | 0x3FF00000;\n-  x.ui[1] = rand_local();\n-  x.d -= 1.0;\n-  x.d *= max - min;\n-  x.d += min;\n-  return (x.d);\n-}\n-\n-vec_double2 rand_vd(double min, double max)\n-{\n-  int i;\n-  static v128 val;\n-\n-  for (i=0; i<2; i++) val.d[i] = rand_double(min, max);\n-  return (val.vd);\n-}\n-\n-int test_spu_cmpeq()\n-{\n-  int i, j;\n-  unsigned long long exp;\n-\n-  /* double */\n-  for (i=0; i<samples; i++) {\n-    a.vd = rand_vd(-4.0, 4.0);\n-    b.vd = rand_vd(-4.0, 4.0);\n-    d.vull = spu_cmpeq(a.vd, b.vd);\n-    for (j=0; j<2; j++) {\n-      exp = (a.d[j] == b.d[j]) ? \n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    }\n-  }\n-\n-  /* compare zeros  */\n-    d.vull = spu_cmpeq(a0.vd, b0.vd);\n-    for (j=0; j<2; j++) {\n-      exp = (a0.d[j] == b0.d[j]) ? \n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    }\n-\n-  /* compare NaNs  */\n-    d.vull = spu_cmpeq(a1.vd, b1.vd);\n-    for (j=0; j<2; j++) {\n-      exp = (a1.d[j] == b1.d[j]) ? \n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    }\n-  return 0;\n-}\n-\n-int test_spu_cmpgt()\n-{   \n-  int i, j;\n-  unsigned long long exp;\n-\n-  /* double */\n-  for (i=0; i<samples; i++) {\n-    a.vd = rand_vd(-4.0, 4.0);\n-    b.vd = rand_vd(-4.0, 4.0);\n-    d.vull = spu_cmpgt(a.vd, b.vd);\n-    for (j=0; j<2; j++) {\n-      exp = (a.d[j] > b.d[j]) ? \n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    } \n-  }\n-\n-  /* compare zeros  */\n-    d.vull = spu_cmpgt(a0.vd, b0.vd);\n-    for (j=0; j<2; j++) {\n-      exp = (a0.d[j] > b0.d[j]) ? \n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    }\n-  /* compare NaNs  */\n-    d.vull = spu_cmpgt(a1.vd, b1.vd);\n-    for (j=0; j<2; j++) {\n-      exp = (a1.d[j] > b1.d[j]) ? \n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    }\n-  return 0;\n-}\n-\n-int test_spu_cmpabseq()\n-{   \n-  int i, j;\n-  unsigned long long exp;\n-\n-  /* double */\n-  for (i=0; i<samples; i++) {\n-    a.vd = rand_vd(-4.0, 4.0);\n-    b.vd = rand_vd(-4.0, 4.0);\n-    d.vull = spu_cmpabseq(a.vd, b.vd);\n-    for (j=0; j<2; j++) {\n-      exp = ((a.d[j] == b.d[j]) || (-a.d[j] == b.d[j]) || (a.d[j] == -b.d[j])) ?\n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    } \n-  }\n-\n-  /* compare zeros  */\n-    d.vull = spu_cmpabseq(a0.vd, b0.vd);\n-    for (j=0; j<2; j++) {\n-      exp = ((a0.d[j] == b0.d[j]) || (-a0.d[j] == b0.d[j]) || (a0.d[j] == -b0.d[j])) ?\n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    }\n-\n-  /* compare NaNs  */\n-    d.vull = spu_cmpabseq(a1.vd, b1.vd);\n-    for (j=0; j<2; j++) {\n-      exp = ((a1.d[j] == b1.d[j]) || (-a1.d[j] == b1.d[j]) || (a1.d[j] == -b1.d[j])) ?\n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    }\n-  return 0;\n-}\n-\n-int test_spu_cmpabsgt()\n-{\n-  int i, j;\n-  unsigned long long exp;\n-  double abs_a, abs_b;\n-  \n-  /* double */\n-  for (i=0; i<samples; i++) {\n-    a.vd = rand_vd(-4.0, 4.0);\n-    b.vd = rand_vd(-4.0, 4.0);\n-    d.vull = spu_cmpabsgt(a.vd, b.vd);\n-    for (j=0; j<2; j++) {\n-      double abs_a = (a.d[j] < 0.0) ? -a.d[j] : a.d[j];\n-      double abs_b = (b.d[j] < 0.0) ? -b.d[j] : b.d[j];\n-      exp = (abs_a > abs_b) ? \n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    }\n-  }\n-\n-  /* compare zeros  */\n-    d.vull = spu_cmpabsgt(a0.vd, b0.vd);\n-    for (j=0; j<2; j++) {\n-      abs_a = (a0.d[j] < 0.0) ? -a0.d[j] : a0.d[j];\n-      abs_b = (b0.d[j] < 0.0) ? -b0.d[j] : b0.d[j];\n-      exp = (abs_a > abs_b) ? \n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    }\n-  /* compare NaNs  */\n-    d.vull = spu_cmpabsgt(a1.vd, b1.vd);\n-    for (j=0; j<2; j++) {\n-      abs_a = (a1.d[j] < 0.0) ? -a1.d[j] : a1.d[j];\n-      abs_b = (b1.d[j] < 0.0) ? -b1.d[j] : b1.d[j];\n-      exp = (abs_a > abs_b) ? \n-\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n-\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n-      if (exp != d.ull[j]) abort();\n-    }\n-  return 0;\n-}\n-\n-int test_spu_testsv()\n-{\n-  int i, j;\n-  unsigned long long exp;\n-  struct _samples {\n-    unsigned long long v;\n-    unsigned int sv;\n- } samples[] = {\n-  {0x0000000000000000ULL, SPU_SV_POS_ZERO},\n-  {0x8000000000000000ULL, SPU_SV_NEG_ZERO},\n-  {0x0000000000000001ULL, SPU_SV_POS_DENORM},\n-  {0x0000000080000000ULL, SPU_SV_POS_DENORM},\n-  {0x0000000100000000ULL, SPU_SV_POS_DENORM},\n-  {0x0008000000000000ULL, SPU_SV_POS_DENORM},\n-  {0x000FFFFFFFFFFFFFULL, SPU_SV_POS_DENORM},\n-  {0x00000000FFF00000ULL, SPU_SV_POS_DENORM},\n-  {0x8000000000000001ULL, SPU_SV_NEG_DENORM},\n-  {0x8000000080000000ULL, SPU_SV_NEG_DENORM},\n-  {0x8000000100000000ULL, SPU_SV_NEG_DENORM},\n-  {0x8008000000000000ULL, SPU_SV_NEG_DENORM},\n-  {0x800FFFFFFFFFFFFFULL, SPU_SV_NEG_DENORM},\n-  {0x80000000FFF00000ULL, SPU_SV_NEG_DENORM},\n-  {0x0010000000000000ULL, 0},\n-  {0x0010000000000001ULL, 0},\n-  {0x3FF0000000000000ULL, 0},\n-  {0x3FF00000FFF00000ULL, 0},\n-  {0xBFF0000000000000ULL, 0},\n-  {0xBFF00000FFF00000ULL, 0},\n-  {0x7FE0000000000000ULL, 0},\n-  {0x7FEFFFFFFFFFFFFFULL, 0},\n-  {0x8010000000000000ULL, 0},\n-  {0x8010000000000001ULL, 0},\n-  {0xFFE0000000000000ULL, 0},\n-  {0xFFEFFFFFFFFFFFFFULL, 0},\n-  {0x7FF0000000000000ULL, SPU_SV_POS_INFINITY},\n-  {0xFFF0000000000000ULL, SPU_SV_NEG_INFINITY},\n-  {0x7FF0000000000001ULL, SPU_SV_NAN},\n-  {0x7FF0000080000000ULL, SPU_SV_NAN},\n-  {0x7FF0000100000000ULL, SPU_SV_NAN},\n-  {0x7FFFFFFFFFFFFFFFULL, SPU_SV_NAN},\n-  {0xFFF0000000000001ULL, SPU_SV_NAN},\n-  {0xFFF0000080000000ULL, SPU_SV_NAN},\n-  {0xFFF0000100000000ULL, SPU_SV_NAN},\n-  {0xFFFFFFFFFFFFFFFFULL, SPU_SV_NAN}\n- };\n-\n-  unsigned char cnt = sizeof(samples)/sizeof(struct _samples);\n-  int e0;\n-    for (e0=0; e0<cnt; e0++)\n-    {   \n-      a.ull[0] = samples[e0].v;\n-      a.d[1] = rand_double(-1, -4);\n-\n-      d.vull = spu_testsv(a.vd, SPU_SV_NEG_DENORM);\n-      exp = (SPU_SV_NEG_DENORM & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n-      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n-    \n-      d.vull = spu_testsv(a.vd, SPU_SV_POS_DENORM);\n-      exp = (SPU_SV_POS_DENORM & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n-      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n-    \n-      d.vull = spu_testsv(a.vd, SPU_SV_NEG_ZERO);\n-      exp = (SPU_SV_NEG_ZERO & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n-      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n-    \n-      d.vull = spu_testsv(a.vd, SPU_SV_POS_ZERO);\n-      exp = (SPU_SV_POS_ZERO & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n-      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n-    \n-      d.vull = spu_testsv(a.vd, SPU_SV_NEG_INFINITY);\n-      exp = (SPU_SV_NEG_INFINITY & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n-      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n-    \n-      d.vull = spu_testsv(a.vd, SPU_SV_POS_INFINITY);\n-      exp = (SPU_SV_POS_INFINITY & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n-      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n-    \n-      d.vull = spu_testsv(a.vd, SPU_SV_NAN);\n-      exp = (SPU_SV_NAN & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n-      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n-   }  \n-  return 0;\n-}\n-\n-int main()\n-{\n-  /* +0.0 and -0.0  */\n-  a0.d[0] = 0.0; a0.d[1] = -0.0; b0.d[0] = -0.0; b0.d[1] = 0.0;\n-  /* NaN  */\n-  a1.d[0] = 0.0/0.0; a1.d[1] = 0.0/-0.0; b1.d[0] = -0.0/0.0;  b1.d[1] = -0.0/-0.0;\n-\n-  test_spu_cmpeq();\n-  test_spu_cmpabseq();\n-  test_spu_cmpgt();\n-  test_spu_cmpabsgt();\n-  test_spu_testsv();\n-  return 0;\n-}\n-\n-"}, {"sha": "3d3946641028ff885a083cfa18eb2eac209afa70", "filename": "gcc/testsuite/gcc.target/spu/intrinsics-3.c", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-3.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,42 +0,0 @@\n-/* { dg-do compile } */\n-#include <spu_intrinsics.h>\n-void f0 (vec_uint4 *in)\n-{\n-  vec_float4 out = spu_convtf (in[0], 128); /* { dg-error \"expects an integer literal in the range\" \"0, 127\"  }*/\n-}\n-\n-void f1 (vec_int4 *in)\n-{\n-  vec_float4 out = spu_convtf (in[0], 128); /* { dg-error \"expects an integer literal in the range\" \"0, 127\"  }*/\n-}\n-\n-void f2 (vec_float4 *in)\n-{\n-  vec_int4 out = spu_convts (in[0], 128); /* { dg-error \"expects an integer literal in the range\" \"0, 127\"  }*/\n-}\n-\n-void f3 (vec_float4 *in)\n-{\n-  vec_uint4 out = spu_convtu (in[0], 128); /* { dg-error \"expects an integer literal in the range\" \"0, 127\"  }*/\n-}\n-\n-/* Test that these intrinsics accept non-literal arguments */\n-void f4 (vec_uint4 *in, int n)\n-{\n-  vec_float4 out = spu_convtf (in[0], n); \n-}\n-\n-void f5 (vec_int4 *in, int n)\n-{\n-  vec_float4 out = spu_convtf (in[0], n);\n-}\n-\n-void f6 (vec_float4 *in, int n)\n-{\n-  vec_int4 out = spu_convts (in[0], n);\n-}\n-\n-void f7 (vec_float4 *in, int n)\n-{\n-  vec_uint4 out = spu_convtu (in[0], n);\n-}"}, {"sha": "f7c62ddcb6de6722c574b8b7045eb168ab1a2b5e", "filename": "gcc/testsuite/gcc.target/spu/intrinsics-sr.c", "status": "removed", "additions": 0, "deletions": 496, "changes": 496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-sr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-sr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-sr.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,496 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-std=c99\" } */\n-\n-#include <spu_intrinsics.h>\n-\n-/* spu_sr */\n-\n-vector unsigned short test_sr_1 (vector unsigned short ra, vector unsigned short count)\n-{\n-  return spu_sr (ra, count);\n-}\n-\n-vector signed short test_sr_2 (vector signed short ra, vector unsigned short count)\n-{\n-  return spu_sr (ra, count);\n-}\n-\n-vector unsigned int test_sr_3 (vector unsigned int ra, vector unsigned int count)\n-{\n-  return spu_sr (ra, count);\n-}\n-\n-vector signed int test_sr_4 (vector signed int ra, vector unsigned int count)\n-{\n-  return spu_sr (ra, count);\n-}\n-\n-vector unsigned short test_sr_5 (vector unsigned short ra)\n-{\n-  return spu_sr (ra, 11);\n-}\n-\n-vector signed short test_sr_6 (vector signed short ra)\n-{\n-  return spu_sr (ra, 11);\n-}\n-\n-vector unsigned short test_sr_7 (vector unsigned short ra, unsigned int count)\n-{\n-  return spu_sr (ra, count);\n-}\n-\n-vector signed short test_sr_8 (vector signed short ra, unsigned int count)\n-{\n-  return spu_sr (ra, count);\n-}\n-\n-vector unsigned int test_sr_9 (vector unsigned int ra)\n-{\n-  return spu_sr (ra, 11);\n-}\n-\n-vector signed int test_sr_10 (vector signed int ra)\n-{\n-  return spu_sr (ra, 11);\n-}\n-\n-vector unsigned int test_sr_11 (vector unsigned int ra, unsigned int count)\n-{\n-  return spu_sr (ra, count);\n-}\n-\n-vector signed int test_sr_12 (vector signed int ra, unsigned int count)\n-{\n-  return spu_sr (ra, count);\n-}\n-\n-\n-/* spu_sra */\n-\n-vector unsigned short test_sra_1 (vector unsigned short ra, vector unsigned short count)\n-{\n-  return spu_sra (ra, count);\n-}\n-\n-vector signed short test_sra_2 (vector signed short ra, vector unsigned short count)\n-{\n-  return spu_sra (ra, count);\n-}\n-\n-vector unsigned int test_sra_3 (vector unsigned int ra, vector unsigned int count)\n-{\n-  return spu_sra (ra, count);\n-}\n-\n-vector signed int test_sra_4 (vector signed int ra, vector unsigned int count)\n-{\n-  return spu_sra (ra, count);\n-}\n-\n-vector unsigned short test_sra_5 (vector unsigned short ra)\n-{\n-  return spu_sra (ra, 11);\n-}\n-\n-vector signed short test_sra_6 (vector signed short ra)\n-{\n-  return spu_sra (ra, 11);\n-}\n-\n-vector unsigned short test_sra_7 (vector unsigned short ra, unsigned int count)\n-{\n-  return spu_sra (ra, count);\n-}\n-\n-vector signed short test_sra_8 (vector signed short ra, unsigned int count)\n-{\n-  return spu_sra (ra, count);\n-}\n-\n-vector unsigned int test_sra_9 (vector unsigned int ra)\n-{\n-  return spu_sra (ra, 11);\n-}\n-\n-vector signed int test_sra_10 (vector signed int ra)\n-{\n-  return spu_sra (ra, 11);\n-}\n-\n-vector unsigned int test_sra_11 (vector unsigned int ra, unsigned int count)\n-{\n-  return spu_sra (ra, count);\n-}\n-\n-vector signed int test_sra_12 (vector signed int ra, unsigned int count)\n-{\n-  return spu_sra (ra, count);\n-}\n-\n-/* spu_srqw */\n-\n-vector unsigned char test_srqw_1 (vector unsigned char ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector signed char test_srqw_2 (vector signed char ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector unsigned short test_srqw_3 (vector unsigned short ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector signed short test_srqw_4 (vector signed short ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector unsigned int test_srqw_5 (vector unsigned int ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector signed int test_srqw_6 (vector signed int ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector unsigned long test_srqw_7 (vector unsigned long ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector signed long test_srqw_8 (vector signed long ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector unsigned long long test_srqw_9 (vector unsigned long long ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector signed long long test_srqw_10 (vector signed long long ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector float test_srqw_11 (vector float ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector double test_srqw_12 (vector double ra)\n-{\n-  return spu_srqw (ra, 5);\n-}\n-\n-vector unsigned char test_srqw_13 (vector unsigned char ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-vector signed char test_srqw_14 (vector signed char ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-vector unsigned short test_srqw_15 (vector unsigned short ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-vector signed short test_srqw_16 (vector signed short ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-vector unsigned int test_srqw_17 (vector unsigned int ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-vector signed int test_srqw_18 (vector signed int ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-vector unsigned long test_srqw_19 (vector unsigned long ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-vector signed long test_srqw_20 (vector signed long ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-vector unsigned long long test_srqw_21 (vector unsigned long long ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-vector signed long long test_srqw_22 (vector signed long long ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-vector float test_srqw_23 (vector float ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-vector double test_srqw_24 (vector double ra, unsigned int count)\n-{\n-  return spu_srqw (ra, count);\n-}\n-\n-/* spu_srqwbyte */\n-\n-vector unsigned char test_srqwbyte_1 (vector unsigned char ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector signed char test_srqwbyte_2 (vector signed char ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector unsigned short test_srqwbyte_3 (vector unsigned short ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector signed short test_srqwbyte_4 (vector signed short ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector unsigned int test_srqwbyte_5 (vector unsigned int ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector signed int test_srqwbyte_6 (vector signed int ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector unsigned long test_srqwbyte_7 (vector unsigned long ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector signed long test_srqwbyte_8 (vector signed long ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector unsigned long long test_srqwbyte_9 (vector unsigned long long ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector signed long long test_srqwbyte_10 (vector signed long long ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector float test_srqwbyte_11 (vector float ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector double test_srqwbyte_12 (vector double ra)\n-{\n-  return spu_srqwbyte (ra, 5);\n-}\n-\n-vector unsigned char test_srqwbyte_13 (vector unsigned char ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-vector signed char test_srqwbyte_14 (vector signed char ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-vector unsigned short test_srqwbyte_15 (vector unsigned short ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-vector signed short test_srqwbyte_16 (vector signed short ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-vector unsigned int test_srqwbyte_17 (vector unsigned int ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-vector signed int test_srqwbyte_18 (vector signed int ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-vector unsigned long test_srqwbyte_19 (vector unsigned long ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-vector signed long test_srqwbyte_20 (vector signed long ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-vector unsigned long long test_srqwbyte_21 (vector unsigned long long ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-vector signed long long test_srqwbyte_22 (vector signed long long ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-vector float test_srqwbyte_23 (vector float ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-vector double test_srqwbyte_24 (vector double ra, unsigned int count)\n-{\n-  return spu_srqwbyte (ra, count);\n-}\n-\n-/* spu_srqwbytebc */\n-\n-vector unsigned char test_srqwbytebc_1 (vector unsigned char ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector signed char test_srqwbytebc_2 (vector signed char ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector unsigned short test_srqwbytebc_3 (vector unsigned short ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector signed short test_srqwbytebc_4 (vector signed short ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector unsigned int test_srqwbytebc_5 (vector unsigned int ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector signed int test_srqwbytebc_6 (vector signed int ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector unsigned long test_srqwbytebc_7 (vector unsigned long ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector signed long test_srqwbytebc_8 (vector signed long ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector unsigned long long test_srqwbytebc_9 (vector unsigned long long ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector signed long long test_srqwbytebc_10 (vector signed long long ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector float test_srqwbytebc_11 (vector float ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector double test_srqwbytebc_12 (vector double ra)\n-{\n-  return spu_srqwbytebc (ra, 40);\n-}\n-\n-vector unsigned char test_srqwbytebc_13 (vector unsigned char ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-\n-vector signed char test_srqwbytebc_14 (vector signed char ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-\n-vector unsigned short test_srqwbytebc_15 (vector unsigned short ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-\n-vector signed short test_srqwbytebc_16 (vector signed short ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-\n-vector unsigned int test_srqwbytebc_17 (vector unsigned int ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-\n-vector signed int test_srqwbytebc_18 (vector signed int ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-\n-vector unsigned long test_srqwbytebc_19 (vector unsigned long ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-\n-vector signed long test_srqwbytebc_20 (vector signed long ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-\n-vector unsigned long long test_srqwbytebc_21 (vector unsigned long long ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-\n-vector signed long long test_srqwbytebc_22 (vector signed long long ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-\n-vector float test_srqwbytebc_23 (vector float ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-\n-vector double test_srqwbytebc_24 (vector double ra, unsigned int count)\n-{\n-  return spu_srqwbytebc (ra, count);\n-}\n-"}, {"sha": "0363e34207514eb28d08c026a28a05b4b61eabe6", "filename": "gcc/testsuite/gcc.target/spu/muldivti3.c", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fmuldivti3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fmuldivti3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fmuldivti3.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,46 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-std=c99\" } */\n-#include <stdlib.h>\n-typedef unsigned int uqword __attribute__((mode(TI)));\n-typedef int qword __attribute__((mode(TI)));\n-\n-typedef union\n-{\n-  uqword                uq;\n-  qword                 q;\n-  unsigned long long    ull[2];\n-} u;\n-\n-int main(void)\n-{\n-  uqword e, f;\n-  qword g, h;\n-\n-  e = 0x1111111111111111ULL;\n-  f = 0xFULL;\n-  g = 0x0000000000111100ULL;\n-  h = 0x0000000000000000ULL;\n-\n-  u m, n, o, p, q;\n-\n-  m.ull[0] = f;\n-  m.ull[1] = e;\n-  n.ull[0] = h;\n-  n.ull[1] = g;\n-\n-  /* __multi3  */\n-  o.q = m.q * n.q;\n-\n-  o.q = o.q + n.q + 0x1110FF;\n-  /* __udivti3, __umodti3  */\n-  p.uq = o.uq / n.uq;\n-  q.uq = o.uq % n.uq;\n-  if (p.uq != (m.uq+1)) abort();\n-  if (q.uq != 0x1110FF) abort();\n-  /* __divti3, __modti3  */\n-  p.q = -o.q / n.q;\n-  q.q = -o.q % n.q;\n-  if ((-p.q * n.q - q.q) != o.q) abort();\n-\n-  return 0;\n-}"}, {"sha": "442f72d4fa85b0af41abae12019dd63205ff7ab3", "filename": "gcc/testsuite/gcc.target/spu/pr40001.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fpr40001.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fpr40001.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fpr40001.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,17 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O\" } */\n-\n-void *\n-sbrk (unsigned int increment)\n-{\n-  volatile register\n-      __attribute__ ((__spu_vector__)) unsigned int sp_r1 __asm__ (\"1\");\n-  unsigned int sps;\n-\n-  sps = __builtin_spu_extract (sp_r1, 0);\n-  if (sps - 4096 >= increment)\n-    return 0;\n-  else\n-    return ((void *) -1);\n-}\n-"}, {"sha": "79ef5b843ebda02784cf561b33e21c8119279f5f", "filename": "gcc/testsuite/gcc.target/spu/spu.exp", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fspu.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fspu.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fspu.exp?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,41 +0,0 @@\n-#   Copyright (C) 2005-2019 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-# \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-# GCC testsuite that uses the 'dg.exp' driver.\n-\n-# Exit immediately if this isn't a SPU target.\n-if { ![istarget spu-*-*] } then {\n-  return\n-}\n-\n-# Load support procs.\n-load_lib gcc-dg.exp\n-\n-# If a testcase doesn't have special options, use these.\n-global DEFAULT_CFLAGS\n-if ![info exists DEFAULT_CFLAGS] then {\n-    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n-}\n-\n-# Initialize 'dg'.\n-dg-init\n-\n-# Main loop.\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]] \\\n-\t\"\" $DEFAULT_CFLAGS\n-\n-# All done.\n-dg-finish"}, {"sha": "4112c958cc380e12a1fdd25b01be5b0154cee7c8", "filename": "gcc/testsuite/gcc.target/spu/subti3.c", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fsubti3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fsubti3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fsubti3.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,45 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-std=c99\" } */\n-#include <stdlib.h>\n-typedef int TItype __attribute__ ((mode (TI)));\n-typedef int DItype __attribute__ ((mode (DI)));\n-typedef unsigned int UDItype __attribute__ ((mode (DI)));\n-\n-struct DIstruct {DItype high, low;};\n-typedef union\n-{\n-  struct DIstruct s;\n-  TItype t;\n-} TIunion;\n-\n-static\n-void sub_ddmmss (UDItype *sh, UDItype *sl, UDItype ah, UDItype al, UDItype bh, UDItype bl)\n-{\n-  UDItype x;\n-  x = al - bl;\n-  *sh = ah - bh - (x > al);\n-  *sl = x;\n-}\n-\n-int main(void)\n-{\n-  TIunion aa, bb, cc;\n-  TItype m = 0x1111111111111110ULL;\n-  TItype n = 0x1111111111111111ULL;\n-  TItype d;\n-\n-  aa.s.high = m;\n-  aa.s.low = m;\n-  bb.s.high = n;\n-  bb.s.low = n;\n-\n-\n-  sub_ddmmss (&cc.s.high, &cc.s.low, aa.s.high, aa.s.low, bb.s.high, bb.s.low);\n-  d = aa.t - bb.t;\n-  if (d != cc.t)\n-   abort();\n-  cc.t = aa.t -d;\n-  if (cc.t != bb.t)\n-   abort();\n- return 0;\n-}"}, {"sha": "4b3ab9f8ddae2b482960e088c1f73241db1d8cb4", "filename": "gcc/testsuite/gcc.target/spu/tag_manager.c", "status": "removed", "additions": 0, "deletions": 312, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ftag_manager.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ftag_manager.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ftag_manager.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,312 +0,0 @@\n-/* Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n-\n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-\n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this file; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* { dg-do run } */\n-\n-#include <spu_mfcio.h>\n-#include <stdlib.h>\n-\n-/* This test directly accesses the internal table used\n-   by the MFC tag manager.  */\n-extern vector unsigned int __mfc_tag_table;\n-\n-\n-/* This tag tests invalid tag release.  Invalid tag release does\n-   nothing to the tag table.  */\n-void\n-test_tag_release01 (void)\n-{\n-  unsigned int copy;\n-  copy = spu_extract (__mfc_tag_table, 0);\n-\n-  mfc_tag_release (35);\n-  if (copy != spu_extract (__mfc_tag_table, 0))\n-    abort ();\n-}\n-\n-/* More invalid release tests.  */\n-void\n-test_tag_release_invalid (void)\n-{\n-  unsigned int copy;\n-  copy = spu_extract (__mfc_tag_table, 0);\n-\n-  if (mfc_tag_release (32) != MFC_TAG_INVALID)\n-    abort ();\n-  if (copy != spu_extract (__mfc_tag_table, 0))\n-    abort ();\n-\n-  if (mfc_tag_release (17) != MFC_TAG_INVALID)\n-    abort ();\n-  if (copy != spu_extract (__mfc_tag_table, 0))\n-    abort ();\n-}\n-\n-/* Invalid multiple-tag release tests.  */\n-void\n-test_tag_group_release_invalid (void)\n-{\n-  unsigned int copy;\n-  copy = spu_extract (__mfc_tag_table, 0);\n-\n-  if (mfc_multi_tag_release (32, 10) != MFC_TAG_INVALID)\n-    abort ();\n-  if (copy != spu_extract (__mfc_tag_table, 0))\n-    abort ();\n-\n-  if (mfc_multi_tag_release (28, 10) != MFC_TAG_INVALID)\n-    abort ();\n-  if (copy != spu_extract (__mfc_tag_table, 0))\n-    abort ();\n-\n-  if (mfc_multi_tag_release (17, 10) != MFC_TAG_INVALID)\n-    abort ();\n-  if (copy != spu_extract (__mfc_tag_table, 0))\n-    abort ();\n-\n-  if (mfc_multi_tag_release (32, 10) != MFC_TAG_INVALID)\n-    abort ();\n-  if (copy != spu_extract (__mfc_tag_table, 0))\n-    abort ();\n-}\n-\n-/* The tag table should be in a pristine mode to run this test.  */\n-void\n-test_tag_reserve01 (void)\n-{\n-  unsigned int correct_table[32] =\n-    {\n-\t\t  0x80000000, 0xC0000000, 0xE0000000,\n-      0xF0000000, 0xF8000000, 0xFC000000, 0xFE000000,\n-      0xFF000000, 0xFF800000, 0xFFC00000, 0xFFE00000,\n-      0xFFF00000, 0xFFF80000, 0xFFFC0000, 0xFFFE0000,\n-      0xFFFF0000, 0xFFFF8000, 0xFFFFC000, 0xFFFFE000,\n-      0xFFFFF000, 0xFFFFF800, 0xFFFFFC00, 0xFFFFFE00,\n-      0xFFFFFF00, 0xFFFFFF80, 0xFFFFFFC0, 0xFFFFFFE0,\n-      0xFFFFFFF0, 0xFFFFFFF8, 0xFFFFFFFC, 0xFFFFFFFE,\n-      0xFFFFFFFF\n-    };\n-\n-  unsigned int tag;\n-  unsigned int i;\n-\n-  for (i = 0; i < 32; i++)\n-    {\n-      tag = mfc_tag_reserve ();\n-      if (tag != i)\n-\tabort ();\n-    }\n-\n-  for (i = 0; i < 32; i++)\n-    {\n-      tag = mfc_tag_reserve ();\n-      if (tag != MFC_TAG_INVALID)\n-\tabort ();\n-    }\n-\n-  for (i = 0; i < 32; i++)\n-    {\n-      mfc_tag_release (i);\n-      if (spu_extract (__mfc_tag_table, 0) != correct_table[i])\n-\tabort ();\n-    }\n-}\n-\n-/* The tag table should be in a pristine mode to run this test.  */\n-void\n-test_tag_reserve02 (void)\n-{\n-  unsigned int correct_table[32] =\n-    {\n-      0x80000000, 0xC0000000, 0xA0000000, 0xF0000000,\n-      0xA8000000, 0xFC000000, 0xAA000000, 0xFF000000,\n-      0xAA800000, 0xFFC00000, 0xAAA00000, 0xFFF00000,\n-      0xAAA80000, 0xFFFC0000, 0xAAAA0000, 0xFFFF0000,\n-      0xAAAA8000, 0xFFFFC000, 0xAAAAA000, 0xFFFFF000,\n-      0xAAAAA800, 0xFFFFFC00, 0xAAAAAA00, 0xFFFFFF00,\n-      0xAAAAAA80, 0xFFFFFFC0, 0xAAAAAAA0, 0xFFFFFFF0,\n-      0xAAAAAAA8, 0xFFFFFFFC, 0xAAAAAAAA, 0xFFFFFFFF\n-    };\n-\n-  unsigned int correct_table2[32] =\n-    {\n-      0x80000000, 0xEAAAAAAA, 0xA0000000, 0xFAAAAAAA,\n-      0xA8000000, 0xFEAAAAAA, 0xAA000000, 0xFFAAAAAA,\n-      0xAA800000, 0xFFEAAAAA, 0xAAA00000, 0xFFFAAAAA,\n-      0xAAA80000, 0xFFFEAAAA, 0xAAAA0000, 0xFFFFAAAA,\n-      0xAAAA8000, 0xFFFFEAAA, 0xAAAAA000, 0xFFFFFAAA,\n-      0xAAAAA800, 0xFFFFFEAA, 0xAAAAAA00, 0xFFFFFFAA,\n-      0xAAAAAA80, 0xFFFFFFEA, 0xAAAAAAA0, 0xFFFFFFFA,\n-      0xAAAAAAA8, 0xFFFFFFFE, 0xAAAAAAAA, 0xFFFFFFFF\n-    };\n-\n-  unsigned int tag;\n-  unsigned int i;\n-\n-  /* Reserve all 32 tags.  */\n-  for (i = 0; i < 32; i++)\n-    {\n-      tag = mfc_tag_reserve();\n-      if (tag != i)\n-\tabort ();\n-    }\n-\n-  for (i = 0; i < 32; i++)\n-    {\n-      tag = mfc_tag_reserve();\n-      if (tag != MFC_TAG_INVALID)\n-\tabort ();\n-    }\n-\n-  /* Release only 16 tags with a stride of 2.  */\n-  for (i = 0; i < 32; i += 2)\n-    {\n-      mfc_tag_release (i);\n-      if (spu_extract (__mfc_tag_table, 0) != correct_table[i])\n-\tabort ();\n-    }\n-\n-  /* Release the other 16 tags with a stride of 2.  */\n-  for (i = 1; i < 32; i += 2)\n-    {\n-      mfc_tag_release (i);\n-      if (spu_extract (__mfc_tag_table, 0) != correct_table2[i])\n-\tabort ();\n-    }\n-}\n-\n-/* The tag table should be in a pristine mode to run this test.  */\n-void\n-test_tag_reserve03 (void)\n-{\n-  unsigned int tag;\n-  unsigned int i;\n-\n-  /* Reserve all 32 tags.  */\n-  for (i = 0; i < 32; i++)\n-    {\n-      tag = mfc_tag_reserve ();\n-      if (tag != i)\n-\tabort ();\n-    }\n-\n-  for (i = 0; i < 32; i++)\n-    {\n-      tag = mfc_tag_reserve ();\n-      if (tag != MFC_TAG_INVALID)\n-\tabort ();\n-    }\n-\n-  /* Release only 16 tags with a stride of 2.  */\n-  for (i = 0; i < 32; i += 2)\n-    mfc_tag_release (i);\n-\n-  /* Now let's re-reserve those tags.  */\n-  for (i = 0; i < 32; i += 2)\n-    {\n-      tag = mfc_tag_reserve ();\n-      if (tag != i)\n-\tabort ();\n-    }\n-\n-  /* Release all tags.  */\n-  for (i = 0; i < 32; i++)\n-    mfc_tag_release (i);\n-\n-  if (spu_extract (__mfc_tag_table,0) != 0xFFFFFFFF)\n-    abort ();\n-}\n-\n-\n-void\n-test_tag_group_reserve (void)\n-{\n-  unsigned int tag;\n-  unsigned int i;\n-  unsigned int copy;\n-\n-  /* Reserve all tags.  */\n-  for (i = 0; i < 32; i++)\n-    mfc_tag_reserve();\n-\n-  /* Release the first 4. */\n-  for (i = 0; i < 4; i++)\n-    mfc_tag_release (i);\n-\n-  /* Release tag 5 to 7.  */\n-  for (i = 5; i < 8; i++)\n-    mfc_tag_release (i);\n-\n-  /* Release tag 9 to 19.  */\n-  for (i = 9; i < 20; i++)\n-    mfc_tag_release (i);\n-\n-  /* Tag table should be 0xF77FF000.  */\n-  if (spu_extract (__mfc_tag_table, 0) != 0xF77FF000)\n-    abort ();\n-\n-\n-  /* Verify invalid release is detected.  */\n-  copy = spu_extract (__mfc_tag_table, 0);\n-  if (mfc_multi_tag_release (1, 5) != MFC_TAG_INVALID)\n-    abort ();\n-  if (copy != spu_extract (__mfc_tag_table, 0))\n-    abort ();\n-\n-\n-  /* Reserve multiple tags.  */\n-  tag = mfc_multi_tag_reserve (5);\n-  if (tag != 9)\n-    abort ();\n-\n-  /* Tag table should be 0xF703F000.  */\n-  if (spu_extract (__mfc_tag_table, 0) != 0xF703F000)\n-    abort ();\n-\n-\n-  /* Release 5 tags in the group.  */\n-  mfc_multi_tag_release (tag, 5);\n-\n-  /* Tag table should be 0xF77FF000.  */\n-  if (spu_extract (__mfc_tag_table, 0) != 0xF77FF000)\n-    abort ();\n-\n-\n-  /* This call should not do anything.  */\n-  mfc_multi_tag_release (32, 5);\n-\n-  /* Tag table should be 0xF77FF000.  */\n-  if (spu_extract (__mfc_tag_table, 0) != 0xF77FF000)\n-    abort ();\n-}\n-\n-\n-int\n-main (void)\n-{\n-  test_tag_release01 ();\n-  test_tag_release_invalid ();\n-  test_tag_group_release_invalid ();\n-\n-  test_tag_reserve01 ();\n-  test_tag_reserve02 ();\n-  test_tag_reserve03 ();\n-\n-  test_tag_group_reserve ();\n-\n-  return 0;\n-}\n-"}, {"sha": "3c086169947e7e2ab23bfc5e247636ccaf5d42a9", "filename": "gcc/testsuite/gcc.target/spu/vector-ansi.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector-ansi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector-ansi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector-ansi.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,35 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-ansi\" } */\n-\n-/* This is done by spu_internals.h, but we not include it here to keep\n-   down the dependencies.  */\n-\n-#ifndef __VECTOR_KEYWORD_SUPPORTED__\n-#define vector __vector\n-#endif\n-\n-/* __vector is expanded unconditionally by the preprocessor.  */\n-__vector int vi;\n-__vector unsigned char vuc;\n-__vector signed char vsc;\n-__vector unsigned short vus;\n-__vector signed short vss;\n-__vector unsigned int vui;\n-__vector signed int vsi;\n-__vector unsigned long long ull;\n-__vector signed long long sll;\n-__vector float vf;\n-__vector double vd;\n-\n-/* vector is expanded by the define above, regardless of context.  */\n-vector int vi;\n-vector unsigned char vuc;\n-vector signed char vsc;\n-vector unsigned short vus;\n-vector signed short vss;\n-vector unsigned int vui;\n-vector signed int vsi;\n-vector unsigned long long ull;\n-vector signed long long sll;\n-vector float vf;\n-vector double vd;"}, {"sha": "237f93b7e58e7c87e153d329c405bc4b529039e0", "filename": "gcc/testsuite/gcc.target/spu/vector.c", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,32 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"\" } */\n-\n-#ifndef __VECTOR_KEYWORD_SUPPORTED__\n-#error __VECTOR_KEYWORD_SUPPORTED__ is not defined\n-#endif\n-\n-/* __vector is expanded unconditionally.  */\n-__vector int vi;\n-__vector unsigned char vuc;\n-__vector signed char vsc;\n-__vector unsigned short vus;\n-__vector signed short vss;\n-__vector unsigned int vui;\n-__vector signed int vsi;\n-__vector unsigned long long ull;\n-__vector signed long long sll;\n-__vector float vf;\n-__vector double vd;\n-\n-/* vector is expanded conditionally, based on the context.  */\n-vector int vi;\n-vector unsigned char vuc;\n-vector signed char vsc;\n-vector unsigned short vus;\n-vector signed short vss;\n-vector unsigned int vui;\n-vector signed int vsi;\n-vector unsigned long long ull;\n-vector signed long long sll;\n-vector float vf;\n-vector double vd;"}, {"sha": "07ce13c6da128f02f0895d43cd2e713fb7930470", "filename": "gcc/testsuite/gfortran.dg/bessel_6.f90", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_6.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,12 +1,8 @@\n-! { dg-do run { xfail spu-*-* } }\n ! { dg-add-options ieee }\n !\n ! PR fortran/36158\n ! PR fortran/33197\n !\n-! XFAILed for SPU targets since we don't have an accurate library\n-! implementation of the single-precision Bessel functions.\n-!\n ! Run-time tests for transformations BESSEL_JN\n !\n implicit none"}, {"sha": "19379768d99ad7ea8d23d8ba3caa2496e293c9e2", "filename": "gcc/testsuite/gfortran.dg/bessel_7.f90", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_7.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,4 +1,4 @@\n-! { dg-do run { xfail *-*-mingw* spu-*-* } }\n+! { dg-do run { xfail *-*-mingw* } }\n ! { dg-add-options ieee }\n !\n ! PR fortran/36158\n@@ -8,9 +8,6 @@\n ! of BESSEL_YN(n,x) has different results.  It returns NAN rather than\n ! -INF for \"x=0.0\" and all \"n\".\n !\n-! XFAILed for SPU targets since we don't have an accurate library\n-! implementation of the single-precision Bessel functions.\n-!\n ! Run-time tests for transformations BESSEL_YN\n !\n implicit none"}, {"sha": "92c7bec48737746d4cb8508c19170acc1b79062a", "filename": "gcc/testsuite/gfortran.dg/char4_iunit_1.f03", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar4_iunit_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar4_iunit_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar4_iunit_1.f03?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n ! PR37077 Implement Internal Unit I/O for character KIND=4\n ! Test case prepared by Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n program char4_iunit_1"}, {"sha": "8e50adbc5ac5c999acaa89cda980411da939eee4", "filename": "gcc/testsuite/gfortran.dg/chmod_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fchmod_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fchmod_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchmod_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,4 +1,4 @@\n-! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* spu-*-* } } } }\n+! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* } } } }\n ! { dg-options \"-std=gnu\" }\n ! See PR38956.  Test fails on cygwin when user has Administrator rights\n   implicit none"}, {"sha": "faed62b8af593954dcb4f6ade993e0381847bc14", "filename": "gcc/testsuite/gfortran.dg/chmod_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fchmod_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fchmod_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchmod_2.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,4 +1,4 @@\n-! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* spu-*-* } } } }\n+! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* } } } }\n ! { dg-options \"-std=gnu\" }\n ! See PR38956.  Test fails on cygwin when user has Administrator rights\n   implicit none"}, {"sha": "81425b33fb9bdc8729251a835b518711184ebebd", "filename": "gcc/testsuite/gfortran.dg/chmod_3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fchmod_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fchmod_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchmod_3.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,4 +1,4 @@\n-! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* spu-*-* } } } }\n+! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* } } } }\n ! { dg-options \"-std=gnu -fdefault-integer-8\" }\n ! See PR38956.  Test fails on cygwin when user has Administrator rights\n   implicit none"}, {"sha": "cafda89a98f206459b2547d11d27dda08b2ffe2a", "filename": "gcc/testsuite/gfortran.dg/default_format_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefault_format_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefault_format_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefault_format_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,4 +1,4 @@\n-! { dg-do run { xfail spu-*-* powerpc-ibm-aix* } }\n+! { dg-do run { xfail powerpc-ibm-aix* } }\n ! Test XFAILed on Darwin because the system's printf() lacks\n ! proper support for denormals.\n !"}, {"sha": "6ae79a3f1a9345d6533c28339f5afad7649be054", "filename": "gcc/testsuite/gfortran.dg/default_format_denormal_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefault_format_denormal_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefault_format_denormal_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefault_format_denormal_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,4 +1,4 @@\n-! { dg-do run { xfail *-*-darwin[89]* *-*-cygwin* spu-*-* powerpc-ibm-aix* } }\n+! { dg-do run { xfail *-*-darwin[89]* *-*-cygwin* powerpc-ibm-aix* } }\n ! Test XFAILed on these platforms because the system's printf() lacks\n ! proper support for denormals.\n !"}, {"sha": "87c99a9d5c04e540eb0a50d066afdb8bcba164b2", "filename": "gcc/testsuite/gfortran.dg/erf_2.F90", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Ferf_2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Ferf_2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ferf_2.F90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,10 +1,6 @@\n-! { dg-do run { xfail spu-*-* } }\n ! { dg-options \"-fno-range-check -ffree-line-length-none -O0\" }\n ! { dg-add-options ieee }\n !\n-! XFAILed for SPU targets because our library implementation of\n-! the double-precision erf/erfc functions is not accurate enough.\n-!\n ! Check that simplification functions and runtime library agree on ERF,\n ! ERFC and ERFC_SCALED.\n "}, {"sha": "69ac8430d963c0215e9caadf233c1eb5fd47e3b4", "filename": "gcc/testsuite/gfortran.dg/erf_3.F90", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Ferf_3.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Ferf_3.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ferf_3.F90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,14 +1,11 @@\n-! { dg-do run { xfail spu-*-* ia64-*-linux* } }\n+! { dg-do run { xfail ia64-*-linux* } }\n ! { dg-options \"-fno-range-check -ffree-line-length-none -O0\" }\n ! { dg-add-options ieee }\n ! { dg-skip-if \"PR libfortran/59313\" { hppa*-*-hpux* } }\n !\n ! Check that simplification functions and runtime library agree on ERF,\n ! ERFC and ERFC_SCALED, for quadruple-precision.\n !\n-! XFAILed for SPU targets because our library implementation of\n-! the double-precision erf/erfc functions is not accurate enough.\n-!\n ! XFAILed for IA64 Linux because of a glibc bug:\n ! http://gcc.gnu.org/bugzilla/show_bug.cgi?id=59227\n "}, {"sha": "49b75f9603a14e87ef38c4372164237b070fe7ea", "filename": "gcc/testsuite/gfortran.dg/init_flag_10.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_10.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n ! { dg-do run }\n ! { dg-options \"-finit-real=NAN\" }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n ! PR fortran/50619\n !"}, {"sha": "6c466a9a0fb9b116b44d7f4a8d594d592c110e18", "filename": "gcc/testsuite/gfortran.dg/init_flag_3.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_3.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n ! { dg-do run }\n ! { dg-options \"-finit-integer=-1 -finit-logical=false -finit-real=nan\" }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n \n program init_flag_3\n   call real_test"}, {"sha": "ce5f5a21712c385d3de7e2100403ad5ecff04066", "filename": "gcc/testsuite/gfortran.dg/int_conv_2.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fint_conv_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fint_conv_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fint_conv_2.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,5 +1,4 @@\n ! { dg-do compile }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n ! PR fortran/37930\n program test\n   implicit none"}, {"sha": "f73d691c5a21263d8de77044c70776c0730bdf55", "filename": "gcc/testsuite/gfortran.dg/integer_exponentiation_3.F90", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_3.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_3.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_3.F90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,5 +1,3 @@\n-! { dg-do run { xfail spu-*-* } }\n-! FAILs on SPU because of wrong compile-time rounding mode\n ! { dg-options \"\" }\n ! { dg-options \"-ffloat-store\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } \n !"}, {"sha": "f34a457c28b108ec705f59ca24cf8d897d35268a", "filename": "gcc/testsuite/gfortran.dg/integer_exponentiation_5.F90", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_5.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_5.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_5.F90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,5 +1,3 @@\n-! { dg-do run { xfail spu-*-* } }\n-! FAILs on SPU because of invalid result of 1.0/0.0 inline code\n ! { dg-options \"-fno-range-check\" }\n ! { dg-add-options ieee }\n module mod_check"}, {"sha": "e9506c2d0c5454ef2ba79bc756cc8c99380e5b5c", "filename": "gcc/testsuite/gfortran.dg/isnan_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fisnan_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fisnan_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fisnan_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -2,7 +2,6 @@\n !\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n   implicit none\n   real :: x"}, {"sha": "672e56466497d0dc6b22e3a0e9f398e3b74c1ad2", "filename": "gcc/testsuite/gfortran.dg/isnan_2.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fisnan_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fisnan_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fisnan_2.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -3,7 +3,6 @@\n ! { dg-do run }\n ! { dg-options \"-fno-range-check\" }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n   implicit none\n   character(len=1) :: s"}, {"sha": "d9d3100c674533b052a2ba554aa4d2c4e5d440bb", "filename": "gcc/testsuite/gfortran.dg/maxloc_2.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_2.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n   real :: a(3), nan, minf, pinf\n   real, allocatable :: c(:)\n   integer :: ia(1)"}, {"sha": "724b6073d810076b8dee20b5e156d10010340d8e", "filename": "gcc/testsuite/gfortran.dg/maxlocval_2.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_2.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n   real :: a(3), nan, minf, pinf\n   real, allocatable :: c(:)\n   logical :: l"}, {"sha": "f8f90fd0571e040aa44fb838e7315484cc32680f", "filename": "gcc/testsuite/gfortran.dg/maxlocval_4.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_4.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n   real :: a(3,3), b(3), nan, minf, pinf, h\n   logical :: l, l2\n   logical :: l3(3,3), l4(3,3), l5(3,3)"}, {"sha": "6418df415faec2206b0ecad9531de6d78ddeee96", "filename": "gcc/testsuite/gfortran.dg/minloc_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fminloc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fminloc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminloc_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n   real :: a(3), nan, minf, pinf\n   integer :: ia(1)\n   real, allocatable :: c(:)"}, {"sha": "822e4da11f1a534db4ebbafeaa913e96e994c550", "filename": "gcc/testsuite/gfortran.dg/minlocval_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n   real :: a(3), nan, minf, pinf\n   real, allocatable :: c(:)\n   logical :: l"}, {"sha": "12b5fa7ecda8fed2e834566b8a6a39caed547bba", "filename": "gcc/testsuite/gfortran.dg/minlocval_4.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_4.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n   real :: a(3,3), b(3), nan, minf, pinf, h\n   logical :: l, l2\n   logical :: l3(3,3), l4(3,3), l5(3,3)"}, {"sha": "4b7cd9a50c5b73c55be2a7d19f71b9c5d526fab8", "filename": "gcc/testsuite/gfortran.dg/module_nan.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_nan.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_nan.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_nan.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n ! { dg-do run }\n ! { dg-options \"-fno-range-check\" }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n ! PR fortran/34318\n !"}, {"sha": "d4a6e71912eeee6ec5f031002b59d19232993e4d", "filename": "gcc/testsuite/gfortran.dg/namelist_42.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_42.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_42.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_42.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run { target fd_truncate } }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n ! PR fortran/34427\n !"}, {"sha": "0eead9c2011c3a56e15f80aefe7b522124149b4b", "filename": "gcc/testsuite/gfortran.dg/namelist_43.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_43.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_43.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_43.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n ! PR fortran/34427\n !"}, {"sha": "6d49a6fa6866582f4807a5c308e40f6091e5876f", "filename": "gcc/testsuite/gfortran.dg/nan_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -3,7 +3,6 @@\n !\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n module aux2\n   interface isnan"}, {"sha": "e0270a1b5a26ff7c9e5e0acf8a10b4db11731424", "filename": "gcc/testsuite/gfortran.dg/nan_2.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_2.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n ! { dg-do run }\n ! { dg-options \"-fno-range-check -pedantic\" }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n ! PR fortran/34333\n !"}, {"sha": "feb19a8f41cc6f030c5fb3fd300162bdcb2a387c", "filename": "gcc/testsuite/gfortran.dg/nan_3.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_3.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n ! { dg-do run }\n ! { dg-options \"-fno-range-check\" }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n ! PR fortran/34319\n !"}, {"sha": "0821b0f63025c836cbcda7a65d8013152b5ac3c1", "filename": "gcc/testsuite/gfortran.dg/nan_4.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_4.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n ! { dg-do compile }\n ! { dg-options \"-std=gnu -fallow-invalid-boz\" } \n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n ! PR fortran/34398.\n !"}, {"sha": "fcfc1b14d6b486ef5d7cd3f58623eafa67d23d12", "filename": "gcc/testsuite/gfortran.dg/nan_5.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_5.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -4,7 +4,6 @@\n !\n ! { dg-options \"-fno-range-check\" }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n \n   implicit none\n   real, parameter :: inf = 2 * huge(inf)"}, {"sha": "d03cc271713ecd3f8793907b7ca931dcf673756b", "filename": "gcc/testsuite/gfortran.dg/nan_6.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_6.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n ! List-directed part of PR fortran/43298\n ! and follow up to PR fortran/34319."}, {"sha": "4ba589c153db2da9a8b66a3a09e79406272dcb7f", "filename": "gcc/testsuite/gfortran.dg/nearest_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnearest_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnearest_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnearest_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n ! { dg-do run }\n ! { dg-options \"-O0 -ffloat-store\" }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"Denormals not supported\" { spu-*-* } }\n ! PR fortran/27021\n ! Original code submitted by Dominique d'Humieres\n ! Converted to Dejagnu for the testsuite by Steven G. Kargl"}, {"sha": "68ec9301dfb0e605ac0e814d195bdafef36a693a", "filename": "gcc/testsuite/gfortran.dg/nearest_3.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnearest_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnearest_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnearest_3.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n ! PR fortran/34209\n !"}, {"sha": "838fad8929dcd41222b6f242625847a30ffc4cd3", "filename": "gcc/testsuite/gfortran.dg/open_errors.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fopen_errors.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fopen_errors.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fopen_errors.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,4 +1,4 @@\n-! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* spu-*-* } } } }\n+! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* } } } }\n ! PR30005 Enhanced error messages for OPEN\n ! Submitted by Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n ! See PR38956.  Test fails on cygwin when user has Administrator rights"}, {"sha": "3808829b486d62a8275cea6ff5725220d32f9bc5", "filename": "gcc/testsuite/gfortran.dg/pr20257.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr20257.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr20257.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr20257.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,5 +1,4 @@\n ! { dg-do run }\n-! { dg-skip-if \"Too big for local store\" { spu-*-* } }\n   integer,parameter :: n = 10000\n   real(8) array(10000)\n "}, {"sha": "97f82674c6b60ea2cb0b392e453ee7ff8c48d502", "filename": "gcc/testsuite/gfortran.dg/read_infnan_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_infnan_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_infnan_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_infnan_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n \n ! PR43298  Fortran library does not read in NaN, NaN(), -Inf, or Inf\n "}, {"sha": "8811632fa520d90e207d8356e79ea2824c268d9c", "filename": "gcc/testsuite/gfortran.dg/real_const_3.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_3.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,6 @@\n !{ dg-do run }\n !{ dg-options \"-fno-range-check\" }\n !{ dg-add-options ieee }\n-!{ dg-skip-if \"NaN not supported\" { spu-*-* } }\n ! PR19310 and PR19904, allow disabling range check during compile.\n ! Contributed by Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n program main"}, {"sha": "4e7c4194f765dc59a6b6df939c4fb3420b26a162", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_2.f03", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_2.f03?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,5 +1,4 @@\n ! { dg-do run }\n-! { dg-skip-if \"Too big for local store\" { spu-*-* } }\n ! Tests the patch that implements F2003 automatic allocation and\n ! reallocation of allocatable arrays on assignment.  The tests\n ! below were generated in the final stages of the development of"}, {"sha": "fdcb46e835cf6a7c54f2a69eb489cb2cde9eb6ab", "filename": "gcc/testsuite/gfortran.dg/reassoc_4.f", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_4.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_4.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_4.f?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do compile }\n ! { dg-options \"-O3 -ffast-math -fdump-tree-reassoc1 --param max-completely-peeled-insns=200\" }\n-! { dg-additional-options \"--param max-completely-peel-times=16\" { target spu-*-* } }\n       subroutine anisonl(w,vo,anisox,s,ii1,jj1,weight)\n       integer ii1,jj1,i1,iii1,j1,jjj1,k1,l1,m1,n1\n       real*8 w(3,3),vo(3,3),anisox(3,3,3,3),s(60,60),weight"}, {"sha": "075e2cf523c80d66e63da2c33671c9f9d35489a9", "filename": "gcc/testsuite/gfortran.dg/scalar_mask_2.f90", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_mask_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_mask_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_mask_2.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,5 +1,4 @@\n-! { dg-do run { xfail spu-*-* } }\n-! FAILs on SPU because of rounding error reading kinds.h\n+! { dg-do run }\n program main\n   ! Test scalar masks for different intrinsics.\n   real, dimension(2,2) :: a"}, {"sha": "1547bfe8c5bdd818e8cd15e6c3dad0dd2b3cc605", "filename": "gcc/testsuite/gfortran.dg/scratch_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fscratch_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fscratch_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fscratch_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,5 +1,4 @@\n ! { dg-do run }\n-! { dg-skip-if \"Too big for local store\" { spu-*-* } }\n ! Check that we can open more than 26 scratch files concurrently\n   integer :: i\n   do i = 1, 30"}, {"sha": "5c66e0d4cf90a864b583421aa535a65dcb4d2c19", "filename": "gcc/testsuite/gfortran.dg/stat_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fstat_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fstat_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstat_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-skip-if \"\" { *-*-mingw* spu-*-* } }\n+! { dg-skip-if \"\" { *-*-mingw* } }\n ! { dg-options \"-std=gnu\" }\n   character(len=*), parameter :: f = \"testfile_stat_1\"\n   integer :: s1(13), r1, s2(13), r2, s3(13), r3, d(13), rd"}, {"sha": "841d33db9e363b47fb02d8100bc7eb53ab4452ee", "filename": "gcc/testsuite/gfortran.dg/stat_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fstat_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Fstat_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstat_2.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-skip-if \"\" { *-*-mingw* spu-*-* } }\n+! { dg-skip-if \"\" { *-*-mingw* } }\n ! { dg-options \"-std=gnu\" }\n   character(len=*), parameter :: f = \"testfile_stat_2\"\n   integer :: s1(13), r1, s2(13), r2, s3(13), r3, d(13), rd"}, {"sha": "e5d4e1ae6883d25cb795068c0f04cfb3dbdb7fbf", "filename": "gcc/testsuite/gfortran.dg/transfer_simplify_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_1.f90?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-options \"-O2\" }\n-! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n ! Tests that the PRs caused by the lack of gfc_simplify_transfer are\n ! now fixed. These were brought together in the meta-bug PR31237\n ! (TRANSFER intrinsic)."}, {"sha": "0967f949bb95c36bb9bab8ae895172a72603bb8f", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_9.f03", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_9.f03?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do run }\n ! { dg-add-options ieee }\n-! { dg-skip-if \"Too big for local store\" { spu-*-* } }\n !\n !     Solve a diffusion problem using an object-oriented approach\n !"}, {"sha": "6356b439e5eb39cffe04dc5bed88fbf323c8f7b4", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/getarg_1.x", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fgetarg_1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fgetarg_1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fgetarg_1.x?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,5 +0,0 @@\n-if [istarget \"spu-*-*\"] {\n-    # We need -mstdmain to enable argument processing on SPU.\n-    lappend additional_flags \"-mstdmain\"\n-}\n-return 0"}, {"sha": "8ad5a79180d41e30bfc8bcc9048a2da776259c7b", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_nearest.x", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_nearest.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_nearest.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_nearest.x?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,7 +1,3 @@\n-if [istarget \"spu-*-*\"] {\n-    # No Inf/NaN support on SPU.\n-    return 1\n-}\n if [istarget \"powerpc-ibm-aix*\"] {\n     # z'7f7fffff' value not preserved by lfs instruction.\n     return 1"}, {"sha": "dad399dcb8d84cc7d63f3c5ed478abbdb248f0b4", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_set_exponent.x", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_set_exponent.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_set_exponent.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_set_exponent.x?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,2 @@\n-if [istarget \"spu-*-*\"] {\n-    # No denormal support on SPU.\n-    return 1\n-}\n add-ieee-options\n return 0"}, {"sha": "dad399dcb8d84cc7d63f3c5ed478abbdb248f0b4", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/nan_inf_fmt.x", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fnan_inf_fmt.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fnan_inf_fmt.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fnan_inf_fmt.x?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,6 +1,2 @@\n-if [istarget \"spu-*-*\"] {\n-    # No Inf/NaN support on SPU.\n-    return 1\n-}\n add-ieee-options\n return 0"}, {"sha": "d8e902b786bfa0d9b7c624149c6dbf2a0c664763", "filename": "gcc/testsuite/lib/compat.exp", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Fcompat.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Fcompat.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fcompat.exp?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -277,16 +277,6 @@ proc compat-execute { src1 sid use_alt } {\n     set extra_flags_3 [compat-get-options $src3]\n     set compile_xfail_3 $compiler_conditional_xfail_data\n \n-    # On the SPU, most of the compat test cases exceed local store size.\n-    # Use automatic overlay support to make them fit.\n-    if { [check_effective_target_spu_auto_overlay] } {\n-\tset extra_flags_1 \"$extra_flags_1 -Wl,--auto-overlay\"\n-\tset extra_flags_1 \"$extra_flags_1 -Wl,--extra-stack-space=8192\"\n-\tset extra_flags_1 \"$extra_flags_1 -ffunction-sections\"\n-\tset extra_flags_2 \"$extra_flags_2 -ffunction-sections\"\n-\tset extra_flags_3 \"$extra_flags_3 -ffunction-sections\"\n-    }\n-\n     # Define the names of the object files.\n     regsub \"sid\" \"sid_main_tst.o\" $sid obj1\n     regsub \"sid\" \"sid_x_tst.o\" $sid obj2_tst"}, {"sha": "1dcc1474723c432adc01507581b0c589234e9653", "filename": "gcc/testsuite/lib/fortran-torture.exp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Ffortran-torture.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Ffortran-torture.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ffortran-torture.exp?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -44,8 +44,6 @@ proc get-fortran-torture-options { } {\n \t && [check_vmx_hw_available] } {\n \tlappend vectorizer_options \"-maltivec\"\n \tset test_tree_vectorize 1\n-    } elseif { [istarget spu-*-*] } {\n-\tset test_tree_vectorize 1\n     } elseif { ( [istarget i?86-*-*] || [istarget x86_64-*-*] )\n \t       && [check_effective_target_sse2]\n \t       && [check_sse2_hw_available]"}, {"sha": "88fe6664d00284e2a6b0ce881d54abed7d15b2d3", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -414,14 +414,6 @@ proc gcc-dg-prune { system text } {\n \treturn \"::unsupported::memory full\"\n     }\n \n-    # Likewise, if we see \".text exceeds local store range\" or\n-    # similar.\n-    if {[string match \"spu-*\" $system] && \\\n-\t    [string match \"*exceeds local store*\" $text]} {\n-\t# The format here is important.  See dg.exp.\n-\treturn \"::unsupported::memory full\"\n-    }\n-\n     if { [string match \"*error: function pointers not supported*\" $text]\n \t  && ![check_effective_target_function_pointers] } {\n \t# The format here is important.  See dg.exp."}, {"sha": "1e80e1f338ac5aabdd897f54a8a1da28158c6fb1", "filename": "gcc/testsuite/lib/gfortran.exp", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Fgfortran.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Fgfortran.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgfortran.exp?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -220,13 +220,6 @@ proc gfortran_init { args } {\n \tlappend ALWAYS_GFORTRANFLAGS \"additional_flags=$TOOL_OPTIONS\"\n     }\n \n-    # On the SPU, most of the fortran test cases exceed local store size.\n-    # Use automatic overlay support to make them fit.\n-    if { [check_effective_target_spu_auto_overlay] } {\n-\tlappend ALWAYS_GFORTRANFLAGS \"ldflags=-Wl,--auto-overlay\"\n-\tlappend ALWAYS_GFORTRANFLAGS \"ldflags=-Wl,--reserved-space=131072\"\n-    }\n-\n     verbose -log \"ALWAYS_GFORTRANFLAGS set to $ALWAYS_GFORTRANFLAGS\"\n \n     verbose \"gfortran is initialized\" 3"}, {"sha": "e32d42491d96959ad04547263f2cc3631f4994d9", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 6, "deletions": 55, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -3173,7 +3173,6 @@ proc check_effective_target_vect_cmdline_needed { } {\n \t\t && ([check_effective_target_powerpc_spe]\n \t\t     || [check_effective_target_powerpc_altivec]))\n \t     || ([istarget sparc*-*-*] && [check_effective_target_sparc_vis])\n-             || [istarget spu-*-*]\n \t     || ([istarget arm*-*-*] && [check_effective_target_arm_neon])\n \t     || [istarget aarch64*-*-*] } {\n \t    return 0\n@@ -3193,7 +3192,6 @@ proc check_effective_target_vect_int { } {\n          || ([istarget powerpc*-*-*]\n \t     && ![istarget powerpc-*-linux*paired*])\n \t || [istarget amdgcn-*-*]\n-\t || [istarget spu-*-*]\n \t || [istarget sparc*-*-*]\n \t || [istarget alpha*-*-*]\n \t || [istarget ia64-*-*]\n@@ -3233,7 +3231,6 @@ proc check_effective_target_vect_doubleint_cvt { } {\n \t\t   #endif\n \t      }])\n \t    || [istarget aarch64*-*-*]\n-\t    || [istarget spu-*-*]\n \t    || ([istarget powerpc*-*-*] && [check_vsx_hw_available])\n \t    || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa]) }}]\n@@ -3251,7 +3248,6 @@ proc check_effective_target_vect_intdouble_cvt { } {\n \t\t  #endif\n \t      }])\n \t     || [istarget aarch64*-*-*]\n-\t     || [istarget spu-*-*]\n \t     || ([istarget powerpc*-*-*] && [check_vsx_hw_available])\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa]) }}]\n@@ -5519,19 +5515,6 @@ proc check_effective_target_powerpc_elfv2 { } {\n     }\n }\n \n-# Return 1 if this is a SPU target with a toolchain that\n-# supports automatic overlay generation.\n-\n-proc check_effective_target_spu_auto_overlay { } {\n-    if { [istarget spu*-*-elf*] } {\n-\treturn [check_no_compiler_messages spu_auto_overlay executable {\n-\t\tint main (void) { }\n-\t\t} \"-Wl,--auto-overlay\" ]\n-    } else {\n-\treturn 0\n-    }\n-}\n-\n # The VxWorks SPARC simulator accepts only EM_SPARC executables and\n # chokes on EM_SPARC32PLUS or EM_SPARCV9 executables.  Return 1 if the\n # test environment appears to run executables on such a simulator.\n@@ -5697,7 +5680,6 @@ proc check_effective_target_vect_float { } {\n     return [check_cached_effective_target_indexed vect_float {\n       expr { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget powerpc*-*-*]\n-\t     || [istarget spu-*-*]\n \t     || [istarget mips-sde-elf]\n \t     || [istarget mipsisa64*-*-*]\n \t     || [istarget ia64-*-*]\n@@ -5731,7 +5713,6 @@ proc check_effective_target_vect_double { } {\n \t\t  #endif\n \t\t}])\n \t     || [istarget aarch64*-*-*]\n-\t     || [istarget spu-*-*]\n \t     || ([istarget powerpc*-*-*] && [check_vsx_hw_available])\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n@@ -5770,7 +5751,6 @@ proc check_effective_target_vect_long_long { } {\n proc check_effective_target_vect_no_int_min_max { } {\n     return [check_cached_effective_target_indexed vect_no_int_min_max {\n       expr { [istarget sparc*-*-*]\n-\t     || [istarget spu-*-*]\n \t     || [istarget alpha*-*-*]\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_loongson_mmi]) }}]\n@@ -5806,7 +5786,6 @@ proc check_effective_target_vect_perm { } {\n       expr { [is-effective-target arm_neon]\n \t     || [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n-             || [istarget spu-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([istarget mips*-*-*]\n \t\t && ([et-is-effective-target mpaired_single]\n@@ -5902,7 +5881,6 @@ proc check_effective_target_vect_perm_byte { } {\n \t     || ([istarget aarch64*-*-*]\n \t\t && [is-effective-target aarch64_little_endian])\n \t     || [istarget powerpc*-*-*]\n-\t     || [istarget spu-*-*]\n \t     || ([istarget mips-*.*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n@@ -5930,7 +5908,6 @@ proc check_effective_target_vect_perm_short { } {\n \t     || ([istarget aarch64*-*-*]\n \t\t && [is-effective-target aarch64_little_endian])\n \t     || [istarget powerpc*-*-*]\n-\t     || [istarget spu-*-*]\n \t     || (([istarget i?86-*-*] || [istarget x86_64-*-*])\n \t         && [check_ssse3_available])\n \t     || ([istarget mips*-*-*]\n@@ -6047,7 +6024,6 @@ proc check_effective_target_vect_widen_mult_hi_to_si { } {\n       expr { ([check_effective_target_vect_unpack]\n               && [check_effective_target_vect_int_mult])\n \t     || ([istarget powerpc*-*-*]\n-\t\t || [istarget spu-*-*]\n \t\t || [istarget ia64-*-*]\n \t\t || ([istarget aarch64*-*-*]\n \t\t     && ![check_effective_target_aarch64_sve])\n@@ -6081,7 +6057,6 @@ proc check_effective_target_vect_widen_mult_qi_to_hi_pattern { } {\n proc check_effective_target_vect_widen_mult_hi_to_si_pattern { } {\n     return [check_cached_effective_target_indexed vect_widen_mult_hi_to_si_pattern {\n       expr { [istarget powerpc*-*-*]\n-\t     || [istarget spu-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([is-effective-target arm_neon]\n@@ -6203,7 +6178,6 @@ proc check_effective_target_vect_pack_trunc { } {\n       expr { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n              || [istarget i?86-*-*] || [istarget x86_64-*-*]\n              || [istarget aarch64*-*-*]\n-             || [istarget spu-*-*]\n              || ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok]\n \t\t && [check_effective_target_arm_little_endian])\n \t     || ([istarget mips*-*-*]\n@@ -6221,7 +6195,6 @@ proc check_effective_target_vect_unpack { } {\n     return [check_cached_effective_target_indexed vect_unpack {\n       expr { ([istarget powerpc*-*-*] && ![istarget powerpc-*paired*])\n              || [istarget i?86-*-*] || [istarget x86_64-*-*]\n-             || [istarget spu-*-*]\n              || [istarget ia64-*-*]\n              || [istarget aarch64*-*-*]\n \t     || ([istarget mips*-*-*]\n@@ -6288,8 +6261,7 @@ proc check_effective_target_vect_aligned_arrays { } {\n     set et_vect_aligned_arrays 0\n     if { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n \t  && !([is-effective-target ia32]\n-\t       || ([check_avx_available] && ![check_prefer_avx128])))\n-\t || [istarget spu-*-*] } {\n+\t       || ([check_avx_available] && ![check_prefer_avx128]))) } {\n \tset et_vect_aligned_arrays 1\n     }\n \n@@ -6332,8 +6304,7 @@ proc check_effective_target_natural_alignment_32 { } {\n proc check_effective_target_natural_alignment_64 { } {\n     return [check_cached_effective_target_indexed natural_alignment_64 {\n       expr { [is-effective-target natural_alignment_32]\n-             && (([is-effective-target lp64] && ![istarget *-*-darwin*])\n-\t\t || [istarget spu-*-*]) }\n+             && [is-effective-target lp64] && ![istarget *-*-darwin*] }\n     }]\n }\n \n@@ -6454,7 +6425,6 @@ proc check_effective_target_vect_condition { } {\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n-\t     || [istarget spu-*-*]\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget arm*-*-*]\n@@ -6500,7 +6470,6 @@ proc check_effective_target_vect_char_mult { } {\n proc check_effective_target_vect_short_mult { } {\n     return [check_cached_effective_target_indexed vect_short_mult {\n       expr { [istarget ia64-*-*]\n-\t     || [istarget spu-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget aarch64*-*-*]\n@@ -6518,7 +6487,6 @@ proc check_effective_target_vect_short_mult { } {\n proc check_effective_target_vect_int_mult { } {\n     return [check_cached_effective_target_indexed vect_int_mult {\n       expr { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n-\t     || [istarget spu-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [istarget aarch64*-*-*]\n@@ -6563,7 +6531,6 @@ proc check_effective_target_vect_extract_even_odd { } {\n \t     || [is-effective-target arm_neon]\n              || [istarget i?86-*-*] || [istarget x86_64-*-*]\n              || [istarget ia64-*-*]\n-             || [istarget spu-*-*]\n \t     || ([istarget mips*-*-*]\n \t\t && ([et-is-effective-target mips_msa]\n \t\t     || [et-is-effective-target mpaired_single]))\n@@ -6580,7 +6547,6 @@ proc check_effective_target_vect_interleave { } {\n \t     || [is-effective-target arm_neon]\n              || [istarget i?86-*-*] || [istarget x86_64-*-*]\n              || [istarget ia64-*-*]\n-             || [istarget spu-*-*]\n \t     || ([istarget mips*-*-*]\n \t\t && ([et-is-effective-target mpaired_single]\n \t\t     || [et-is-effective-target mips_msa]))\n@@ -6827,23 +6793,15 @@ proc check_effective_target_section_anchors { } {\n # Return 1 if the target supports atomic operations on \"int_128\" values.\n \n proc check_effective_target_sync_int_128 { } {\n-    if { [istarget spu-*-*] } {\n-\treturn 1\n-    } else {\n-\treturn 0\n-    }\n+    return 0\n }\n \n # Return 1 if the target supports atomic operations on \"int_128\" values\n # and can execute them.\n # This requires support for both compare-and-swap and true atomic loads.\n \n proc check_effective_target_sync_int_128_runtime { } {\n-    if { [istarget spu-*-*] } {\n-\treturn 1\n-    } else {\n-\treturn 0\n-    }\n+    return 0\n }\n \n # Return 1 if the target supports atomic operations on \"long long\".\n@@ -6857,8 +6815,7 @@ proc check_effective_target_sync_long_long { } {\n \t || [istarget arm*-*-*]\n \t || [istarget alpha*-*-*]\n \t || ([istarget sparc*-*-*] && [check_effective_target_lp64])\n-\t || [istarget s390*-*-*]\n-\t || [istarget spu-*-*] } {\n+\t || [istarget s390*-*-*] } {\n \treturn 1\n     } else {\n \treturn 0\n@@ -6917,7 +6874,6 @@ proc check_effective_target_sync_long_long_runtime { } {\n \t || ([istarget sparc*-*-*]\n \t     && [check_effective_target_lp64]\n \t     && [check_effective_target_ultrasparc_hw])\n-\t || [istarget spu-*-*]\n \t || ([istarget powerpc*-*-*] && [check_effective_target_lp64]) } {\n \treturn 1\n     } else {\n@@ -6964,7 +6920,6 @@ proc check_effective_target_sync_int_long { } {\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget crisv32-*-*] || [istarget cris-*-*]\n \t     || ([istarget sparc*-*-*] && [check_effective_target_sparc_v9])\n-\t     || [istarget spu-*-*]\n \t     || ([istarget arc*-*-*] && [check_effective_target_arc_atomic])\n \t     || [check_effective_target_mips_llsc] }}]\n }\n@@ -6987,7 +6942,6 @@ proc check_effective_target_sync_char_short { } {\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget crisv32-*-*] || [istarget cris-*-*]\n \t     || ([istarget sparc*-*-*] && [check_effective_target_sparc_v9])\n-\t     || [istarget spu-*-*]\n \t     || ([istarget arc*-*-*] && [check_effective_target_arc_atomic])\n \t     || [check_effective_target_mips_llsc] }}]\n }\n@@ -8575,8 +8529,6 @@ proc check_vect_support_and_set_flags { } {\n             }\n             set dg-do-what-default compile\n         }\n-    } elseif { [istarget spu-*-*] } {\n-        set dg-do-what-default run\n     } elseif { [istarget i?86-*-*] || [istarget x86_64-*-*] } {\n         lappend DEFAULT_VECTCFLAGS \"-msse2\"\n         if { [check_effective_target_sse2_runtime] } {\n@@ -8861,8 +8813,7 @@ proc check_effective_target_branch_cost {} {\n \t || [istarget mips*-*-*]\n \t || [istarget s390*-*-*]\n \t || [istarget riscv*-*-*]\n-\t || [istarget sh*-*-*]\n-\t || [istarget spu*-*-*] } {\n+\t || [istarget sh*-*-*] } {\n \treturn 1\n     }\n     return 0"}, {"sha": "9e36ec0ea35a598a62ee31ccfe0d2ca8f4c93efe", "filename": "gcc/testsuite/lib/target-utils.exp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Ftarget-utils.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/gcc%2Ftestsuite%2Flib%2Ftarget-utils.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-utils.exp?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -40,10 +40,6 @@ proc ${tool}_check_unsupported_p { output } {\n \treturn \"memory full\"\n     }\n \n-    if { [istarget spu-*-*] && \\\n-\t     [string match \"*exceeds local store*\" $output] } {\n-\treturn \"memory full\"\n-    }\n     if { [string match \"*error: function pointers not supported*\" $output]\n \t  && ![check_effective_target_function_pointers] } {\n \treturn \"function pointers not supported\""}, {"sha": "60ae5d2788d27e3b86e158d10f37776fd017195f", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,3 +1,8 @@\n+2019-09-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* configure.ac: Remove references to spu.\n+\t* configure: Regenerate.\n+\n 2019-05-24  Clement Chigot  <clement.chigot@atos.net>\n \n \t* Makefile.am (BUILDTESTS): Remove test_elf, add test_elf_32 and"}, {"sha": "b8be21088eb4846972a5468ee08d340503007c6d", "filename": "libbacktrace/configure", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -12971,10 +12971,8 @@ else\n     # simply assume that if we have mman.h, we have mmap.\n     have_mmap=yes\n     case \"${host}\" in\n-    spu-*-*|*-*-msdosdjgpp)\n-        # The SPU does not have mmap, but it has a sys/mman.h header file\n-        # containing \"mmap_eaddr\" and the mmap flags, confusing the test.\n-        # DJGPP also has sys/man.h, but no mmap\n+    *-*-msdosdjgpp)\n+        # DJGPP has sys/man.h, but no mmap\n \thave_mmap=no ;;\n     esac\n   else\n@@ -13115,7 +13113,6 @@ fi\n if test -n \"${with_target_subdir}\"; then\n    case \"${host}\" in\n    *-*-mingw*) have_fcntl=no ;;\n-   spu-*-*) have_fcntl=no ;;\n    *) have_fcntl=yes ;;\n    esac\n else"}, {"sha": "a657ef6097a085eb9fcb73a58ebfbc0abcb3f32c", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -293,10 +293,8 @@ else\n     # simply assume that if we have mman.h, we have mmap.\n     have_mmap=yes\n     case \"${host}\" in\n-    spu-*-*|*-*-msdosdjgpp)\n-        # The SPU does not have mmap, but it has a sys/mman.h header file\n-        # containing \"mmap_eaddr\" and the mmap flags, confusing the test.\n-        # DJGPP also has sys/man.h, but no mmap\n+    *-*-msdosdjgpp)\n+        # DJGPP has sys/man.h, but no mmap\n \thave_mmap=no ;;\n     esac\n   else\n@@ -364,7 +362,6 @@ fi\n if test -n \"${with_target_subdir}\"; then\n    case \"${host}\" in\n    *-*-mingw*) have_fcntl=no ;;\n-   spu-*-*) have_fcntl=no ;;\n    *) have_fcntl=yes ;;\n    esac\n else"}, {"sha": "6791b3644e525fabbc145981ef1e823d0ca5c05a", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,3 +1,8 @@\n+2019-09-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* directives.c: Remove references to spu from comments.\n+\t* expr.c: Likewise.\n+\n 2019-08-29  Nathan Sidwell  <nathan@acm.org>\n \n \t* internal.h (enum include_type): Add IT_MAIN, IT_DIRECTIVE_HWM,"}, {"sha": "29d21ed9fdf0d6352343ba5c15b3e21f9ae89926", "filename": "libcpp/directives.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1952,9 +1952,9 @@ do_ifdef (cpp_reader *pfile)\n       if (node)\n \t{\n \t  /* Do not treat conditional macros as being defined.  This is due to\n-\t     the powerpc and spu ports using conditional macros for 'vector',\n-\t     'bool', and 'pixel' to act as conditional keywords.  This messes\n-\t     up tests like #ifndef bool.  */\n+\t     the powerpc port using conditional macros for 'vector', 'bool',\n+\t     and 'pixel' to act as conditional keywords.  This messes up tests\n+\t     like #ifndef bool.  */\n \t  skip = !cpp_macro_p (node) || (node->flags & NODE_CONDITIONAL);\n \t  _cpp_mark_macro_used (node);\n \t  _cpp_maybe_notify_macro_use (pfile, node);\n@@ -1981,9 +1981,9 @@ do_ifndef (cpp_reader *pfile)\n       if (node)\n \t{\n \t  /* Do not treat conditional macros as being defined.  This is due to\n-\t     the powerpc and spu ports using conditional macros for 'vector',\n-\t     'bool', and 'pixel' to act as conditional keywords.  This messes\n-\t     up tests like #ifndef bool.  */\n+\t     the powerpc port using conditional macros for 'vector', 'bool',\n+\t     and 'pixel' to act as conditional keywords.  This messes up tests\n+\t     like #ifndef bool.  */\n \t  skip = (cpp_macro_p (node)\n \t\t  && !(node->flags & NODE_CONDITIONAL));\n \t  _cpp_mark_macro_used (node);"}, {"sha": "4b514b17d9c237c3757285f8c749ce82318a3d18", "filename": "libcpp/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1075,8 +1075,8 @@ parse_defined (cpp_reader *pfile)\n   pfile->state.prevent_expansion--;\n \n   /* Do not treat conditional macros as being defined.  This is due to the\n-     powerpc and spu ports using conditional macros for 'vector', 'bool', and\n-     'pixel' to act as conditional keywords.  This messes up tests like #ifndef\n+     powerpc port using conditional macros for 'vector', 'bool', and 'pixel'\n+     to act as conditional keywords.  This messes up tests like #ifndef\n      bool.  */\n   result.unsignedp = false;\n   result.high = 0;"}, {"sha": "1ffb236add270c2341af9331f844d3f8f49b4ff2", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,3 +1,8 @@\n+2019-09-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config.host: Remove references to spu.\n+\t* config/spu/: Remove directory.\n+\n 2019-08-23  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \tPR target/91306"}, {"sha": "a3976702ab5a4317f266f423faa4167ca2b7ba8e", "filename": "libgcc/config.host", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -189,9 +189,6 @@ sparc64*-*-*)\n sparc*-*-*)\n \tcpu_type=sparc\n \t;;\n-spu*-*-*)\n-\tcpu_type=spu\n-\t;;\n s390*-*-*)\n \tcpu_type=s390\n \t;;\n@@ -1369,13 +1366,6 @@ sparc64-*-linux*)\t\t# 64-bit SPARC's running GNU/Linux\n \t;;\n sparc64-*-netbsd*)\n \t;;\n-spu-*-elf*)\n-\ttmake_file=\"$tmake_file spu/t-elf t-libgcc-pic t-fdpbit\"\n-\textra_parts=\"$extra_parts \\\n-\t\tlibgcc_cachemgr.a libgcc_cachemgr_nonatomic.a \\\n-\t\tlibgcc_cache8k.a libgcc_cache16k.a libgcc_cache32k.a \\\n-\t\tlibgcc_cache64k.a libgcc_cache128k.a\"\n-\t;;\n tic6x-*-uclinux)\n \ttmake_file=\"${tmake_file} t-softfp-sfdf t-softfp-excl t-softfp \\\n \t\tc6x/t-elf  c6x/t-uclinux t-crtstuff-pic t-libgcc-pic \\"}, {"sha": "1affe632550702c449677f3f153568bd301e96b1", "filename": "libgcc/config/spu/cache.S", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fcache.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fcache.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Fcache.S?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,43 +0,0 @@\n-/* Copyright (C) 2008-2019 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\t.data\n-\t.p2align 7\n-\t.global __cache\n-__cache:\n-\t.rept __CACHE_SIZE__ * 8\n-\t.fill 128\n-\t.endr\n-\n-\t.p2align 7\n-\t.global __cache_tag_array\n-__cache_tag_array:\n-\t.rept __CACHE_SIZE__ * 2\n-\t.long 1, 1, 1, 1\n-\t.fill 128-16\n-\t.endr\n-__end_cache_tag_array:\n-\n-\t.globl __cache_tag_array_size\n-\t.set __cache_tag_array_size, __end_cache_tag_array-__cache_tag_array\n-"}, {"sha": "32b2a0e45d4219b36567167a7d3ac25ead6878bf", "filename": "libgcc/config/spu/cachemgr.c", "status": "removed", "additions": 0, "deletions": 438, "changes": 438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fcachemgr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fcachemgr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Fcachemgr.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,438 +0,0 @@\n-/* Copyright (C) 2008-2019 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include <spu_mfcio.h>\n-#include <spu_internals.h>\n-#include <spu_intrinsics.h>\n-#include <spu_cache.h>\n-\n-extern unsigned long long __ea_local_store;\n-extern char __cache_tag_array_size;\n-\n-#define LINE_SIZE 128\n-#define TAG_MASK (LINE_SIZE - 1)\n-\n-#define WAYS 4\n-#define SET_MASK ((int) &__cache_tag_array_size - LINE_SIZE)\n-\n-#define CACHE_LINES ((int) &__cache_tag_array_size /\t\t\\\n-\t\t     sizeof (struct __cache_tag_array) * WAYS)\n-\n-struct __cache_tag_array\n-{\n-  unsigned int tag_lo[WAYS];\n-  unsigned int tag_hi[WAYS];\n-  void *base[WAYS];\n-  int reserved[WAYS];\n-  vector unsigned short dirty_bits[WAYS];\n-};\n-\n-extern struct __cache_tag_array __cache_tag_array[];\n-extern char __cache[];\n-\n-/* In order to make the code seem a little cleaner, and to avoid having\n-   64/32 bit ifdefs all over the place, we use macros.  */\n-\n-#ifdef __EA64__\n-typedef unsigned long long addr;\n-\n-#define CHECK_TAG(_entry, _way, _tag)\t\t\t\\\n-  ((_entry)->tag_lo[(_way)] == ((_tag) & 0xFFFFFFFF)\t\\\n-   && (_entry)->tag_hi[(_way)] == ((_tag) >> 32))\n-\n-#define GET_TAG(_entry, _way) \\\n-  ((unsigned long long)(_entry)->tag_hi[(_way)] << 32\t\\\n-   | (unsigned long long)(_entry)->tag_lo[(_way)])\n-\n-#define SET_TAG(_entry, _way, _tag)\t\t\t\\\n-  (_entry)->tag_lo[(_way)] = (_tag) & 0xFFFFFFFF;\t\\\n-  (_entry)->tag_hi[(_way)] = (_tag) >> 32\n-\n-#else /*__EA32__*/\n-typedef unsigned long addr;\n-\n-#define CHECK_TAG(_entry, _way, _tag)\t\t\t\\\n-  ((_entry)->tag_lo[(_way)] == (_tag))\n-\n-#define GET_TAG(_entry, _way)\t\t\t\t\\\n-  ((_entry)->tag_lo[(_way)])\n-\n-#define SET_TAG(_entry, _way, _tag)\t\t\t\\\n-  (_entry)->tag_lo[(_way)] = (_tag)\n-\n-#endif\n-\n-/* In GET_ENTRY, we cast away the high 32 bits,\n-   as the tag is only in the low 32.  */\n-\n-#define GET_ENTRY(_addr)\t\t\t\t\t\t   \\\n-  ((struct __cache_tag_array *)\t\t\t\t\t\t   \\\n-   si_to_uint (si_a (si_and (si_from_uint ((unsigned int) (addr) (_addr)), \\\n-\t\t\t     si_from_uint (SET_MASK)),\t\t\t   \\\n-\t       si_from_uint ((unsigned int) __cache_tag_array))))\n-\n-#define GET_CACHE_LINE(_addr, _way) \\\n-  ((void *) (__cache + ((_addr) & SET_MASK) * WAYS) + ((_way) * LINE_SIZE));\n-\n-#define CHECK_DIRTY(_vec) (si_to_uint (si_orx ((qword) (_vec))))\n-#define SET_EMPTY(_entry, _way) ((_entry)->tag_lo[(_way)] = 1)\n-#define CHECK_EMPTY(_entry, _way) ((_entry)->tag_lo[(_way)] == 1)\n-\n-#define LS_FLAG 0x80000000\n-#define SET_IS_LS(_entry, _way) ((_entry)->reserved[(_way)] |= LS_FLAG)\n-#define CHECK_IS_LS(_entry, _way) ((_entry)->reserved[(_way)] & LS_FLAG)\n-#define GET_LRU(_entry, _way) ((_entry)->reserved[(_way)] & ~LS_FLAG)\n-\n-static int dma_tag = 32;\n-\n-static void\n-__cache_evict_entry (struct __cache_tag_array *entry, int way)\n-{\n-  addr tag = GET_TAG (entry, way);\n-\n-  if (CHECK_DIRTY (entry->dirty_bits[way]) && !CHECK_IS_LS (entry, way))\n-    {\n-#ifdef NONATOMIC\n-      /* Non-atomic writes.  */\n-      unsigned int oldmask, mach_stat;\n-      char *line = ((void *) 0);\n-\n-      /* Enter critical section.  */\n-      mach_stat = spu_readch (SPU_RdMachStat);\n-      spu_idisable ();\n-\n-      /* Issue DMA request.  */\n-      line = GET_CACHE_LINE (entry->tag_lo[way], way);\n-      mfc_put (line, tag, LINE_SIZE, dma_tag, 0, 0);\n-\n-      /* Wait for DMA completion.  */\n-      oldmask = mfc_read_tag_mask ();\n-      mfc_write_tag_mask (1 << dma_tag);\n-      mfc_read_tag_status_all ();\n-      mfc_write_tag_mask (oldmask);\n-\n-      /* Leave critical section.  */\n-      if (__builtin_expect (mach_stat & 1, 0))\n-\tspu_ienable ();\n-#else\n-      /* Allocate a buffer large enough that we know it has 128 bytes\n-         that are 128 byte aligned (for DMA). */\n-\n-      char buffer[LINE_SIZE + 127];\n-      qword *buf_ptr = (qword *) (((unsigned int) (buffer) + 127) & ~127);\n-      qword *line = GET_CACHE_LINE (entry->tag_lo[way], way);\n-      qword bits;\n-      unsigned int mach_stat;\n-\n-      /* Enter critical section.  */\n-      mach_stat = spu_readch (SPU_RdMachStat);\n-      spu_idisable ();\n-\n-      do\n-\t{\n-\t  /* We atomically read the current memory into a buffer\n-\t     modify the dirty bytes in the buffer, and write it\n-\t     back. If writeback fails, loop and try again.  */\n-\n-\t  mfc_getllar (buf_ptr, tag, 0, 0);\n-\t  mfc_read_atomic_status ();\n-\n-\t  /* The method we're using to write 16 dirty bytes into\n-\t     the buffer at a time uses fsmb which in turn uses\n-\t     the least significant 16 bits of word 0, so we\n-\t     load the bits and rotate so that the first bit of\n-\t     the bitmap is in the first bit that fsmb will use.  */\n-\n-\t  bits = (qword) entry->dirty_bits[way];\n-\t  bits = si_rotqbyi (bits, -2);\n-\n-\t  /* Si_fsmb creates the mask of dirty bytes.\n-\t     Use selb to nab the appropriate bits.  */\n-\t  buf_ptr[0] = si_selb (buf_ptr[0], line[0], si_fsmb (bits));\n-\n-\t  /* Rotate to next 16 byte section of cache.  */\n-\t  bits = si_rotqbyi (bits, 2);\n-\n-\t  buf_ptr[1] = si_selb (buf_ptr[1], line[1], si_fsmb (bits));\n-\t  bits = si_rotqbyi (bits, 2);\n-\t  buf_ptr[2] = si_selb (buf_ptr[2], line[2], si_fsmb (bits));\n-\t  bits = si_rotqbyi (bits, 2);\n-\t  buf_ptr[3] = si_selb (buf_ptr[3], line[3], si_fsmb (bits));\n-\t  bits = si_rotqbyi (bits, 2);\n-\t  buf_ptr[4] = si_selb (buf_ptr[4], line[4], si_fsmb (bits));\n-\t  bits = si_rotqbyi (bits, 2);\n-\t  buf_ptr[5] = si_selb (buf_ptr[5], line[5], si_fsmb (bits));\n-\t  bits = si_rotqbyi (bits, 2);\n-\t  buf_ptr[6] = si_selb (buf_ptr[6], line[6], si_fsmb (bits));\n-\t  bits = si_rotqbyi (bits, 2);\n-\t  buf_ptr[7] = si_selb (buf_ptr[7], line[7], si_fsmb (bits));\n-\t  bits = si_rotqbyi (bits, 2);\n-\n-\t  mfc_putllc (buf_ptr, tag, 0, 0);\n-\t}\n-      while (mfc_read_atomic_status ());\n-\n-      /* Leave critical section.  */\n-      if (__builtin_expect (mach_stat & 1, 0))\n-\tspu_ienable ();\n-#endif\n-    }\n-\n-  /* In any case, marking the lo tag with 1 which denotes empty.  */\n-  SET_EMPTY (entry, way);\n-  entry->dirty_bits[way] = (vector unsigned short) si_from_uint (0);\n-}\n-\n-void\n-__cache_evict (__ea void *ea)\n-{\n-  addr tag = (addr) ea & ~TAG_MASK;\n-  struct __cache_tag_array *entry = GET_ENTRY (ea);\n-  int i = 0;\n-\n-  /* Cycles through all the possible ways an address could be at\n-     and evicts the way if found.  */\n-\n-  for (i = 0; i < WAYS; i++)\n-    if (CHECK_TAG (entry, i, tag))\n-      __cache_evict_entry (entry, i);\n-}\n-\n-static void *\n-__cache_fill (int way, addr tag)\n-{\n-  unsigned int oldmask, mach_stat;\n-  char *line = ((void *) 0);\n-\n-  /* Reserve our DMA tag.  */\n-  if (dma_tag == 32)\n-    dma_tag = mfc_tag_reserve ();\n-\n-  /* Enter critical section.  */\n-  mach_stat = spu_readch (SPU_RdMachStat);\n-  spu_idisable ();\n-\n-  /* Issue DMA request.  */\n-  line = GET_CACHE_LINE (tag, way);\n-  mfc_get (line, tag, LINE_SIZE, dma_tag, 0, 0);\n-\n-  /* Wait for DMA completion.  */\n-  oldmask = mfc_read_tag_mask ();\n-  mfc_write_tag_mask (1 << dma_tag);\n-  mfc_read_tag_status_all ();\n-  mfc_write_tag_mask (oldmask);\n-\n-  /* Leave critical section.  */\n-  if (__builtin_expect (mach_stat & 1, 0))\n-    spu_ienable ();\n-\n-  return (void *) line;\n-}\n-\n-static void\n-__cache_miss (__ea void *ea, struct __cache_tag_array *entry, int way)\n-{\n-\n-  addr tag = (addr) ea & ~TAG_MASK;\n-  unsigned int lru = 0;\n-  int i = 0;\n-  int idx = 0;\n-\n-  /* If way > 4, then there are no empty slots, so we must evict\n-     the least recently used entry. */\n-  if (way >= 4)\n-    {\n-      for (i = 0; i < WAYS; i++)\n-\t{\n-\t  if (GET_LRU (entry, i) > lru)\n-\t    {\n-\t      lru = GET_LRU (entry, i);\n-\t      idx = i;\n-\t    }\n-\t}\n-      __cache_evict_entry (entry, idx);\n-      way = idx;\n-    }\n-\n-  /* Set the empty entry's tag and fill it's cache line. */\n-\n-  SET_TAG (entry, way, tag);\n-  entry->reserved[way] = 0;\n-\n-  /* Check if the address is just an effective address within the\n-     SPU's local store. */\n-\n-  /* Because the LS is not 256k aligned, we can't do a nice and mask\n-     here to compare, so we must check the whole range.  */\n-\n-  if ((addr) ea >= (addr) __ea_local_store\n-      && (addr) ea < (addr) (__ea_local_store + 0x40000))\n-    {\n-      SET_IS_LS (entry, way);\n-      entry->base[way] =\n-\t(void *) ((unsigned int) ((addr) ea -\n-\t\t\t\t  (addr) __ea_local_store) & ~0x7f);\n-    }\n-  else\n-    {\n-      entry->base[way] = __cache_fill (way, tag);\n-    }\n-}\n-\n-void *\n-__cache_fetch_dirty (__ea void *ea, int n_bytes_dirty)\n-{\n-#ifdef __EA64__\n-  unsigned int tag_hi;\n-  qword etag_hi;\n-#endif\n-  unsigned int tag_lo;\n-  struct __cache_tag_array *entry;\n-\n-  qword etag_lo;\n-  qword equal;\n-  qword bit_mask;\n-  qword way;\n-\n-  /* This first chunk, we merely fill the pointer and tag.  */\n-\n-  entry = GET_ENTRY (ea);\n-\n-#ifndef __EA64__\n-  tag_lo =\n-    si_to_uint (si_andc\n-\t\t(si_shufb\n-\t\t (si_from_uint ((addr) ea), si_from_uint (0),\n-\t\t  si_from_uint (0x00010203)), si_from_uint (TAG_MASK)));\n-#else\n-  tag_lo =\n-    si_to_uint (si_andc\n-\t\t(si_shufb\n-\t\t (si_from_ullong ((addr) ea), si_from_uint (0),\n-\t\t  si_from_uint (0x04050607)), si_from_uint (TAG_MASK)));\n-\n-  tag_hi =\n-    si_to_uint (si_shufb\n-\t\t(si_from_ullong ((addr) ea), si_from_uint (0),\n-\t\t si_from_uint (0x00010203)));\n-#endif\n-\n-  /* Increment LRU in reserved bytes.  */\n-  si_stqd (si_ai (si_lqd (si_from_ptr (entry), 48), 1),\n-\t   si_from_ptr (entry), 48);\n-\n-missreturn:\n-  /* Check if the entry's lo_tag is equal to the address' lo_tag.  */\n-  etag_lo = si_lqd (si_from_ptr (entry), 0);\n-  equal = si_ceq (etag_lo, si_from_uint (tag_lo));\n-#ifdef __EA64__\n-  /* And the high tag too.  */\n-  etag_hi = si_lqd (si_from_ptr (entry), 16);\n-  equal = si_and (equal, (si_ceq (etag_hi, si_from_uint (tag_hi))));\n-#endif\n-\n-  if ((si_to_uint (si_orx (equal)) == 0))\n-    goto misshandler;\n-\n-  if (n_bytes_dirty)\n-    {\n-      /* way = 0x40,0x50,0x60,0x70 for each way, which is also the\n-         offset of the appropriate dirty bits.  */\n-      way = si_shli (si_clz (si_gbb (equal)), 2);\n-\n-      /* To create the bit_mask, we set it to all 1s (uint -1), then we\n-         shift it over (128 - n_bytes_dirty) times.  */\n-\n-      bit_mask = si_from_uint (-1);\n-\n-      bit_mask =\n-\tsi_shlqby (bit_mask, si_from_uint ((LINE_SIZE - n_bytes_dirty) / 8));\n-\n-      bit_mask =\n-\tsi_shlqbi (bit_mask, si_from_uint ((LINE_SIZE - n_bytes_dirty) % 8));\n-\n-      /* Rotate it around to the correct offset.  */\n-      bit_mask =\n-\tsi_rotqby (bit_mask,\n-\t\t   si_from_uint (-1 * ((addr) ea & TAG_MASK) / 8));\n-\n-      bit_mask =\n-\tsi_rotqbi (bit_mask,\n-\t\t   si_from_uint (-1 * ((addr) ea & TAG_MASK) % 8));\n-\n-      /* Update the dirty bits.  */\n-      si_stqx (si_or (si_lqx (si_from_ptr (entry), way), bit_mask),\n-\t       si_from_ptr (entry), way);\n-    };\n-\n-  /* We've definitely found the right entry, set LRU (reserved) to 0\n-     maintaining the LS flag (MSB).  */\n-\n-  si_stqd (si_andc\n-\t   (si_lqd (si_from_ptr (entry), 48),\n-\t    si_and (equal, si_from_uint (~(LS_FLAG)))),\n-\t   si_from_ptr (entry), 48);\n-\n-  return (void *)\n-    si_to_uint (si_a\n-\t\t(si_orx\n-\t\t (si_and (si_lqd (si_from_ptr (entry), 32), equal)),\n-\t\t si_from_uint (((unsigned int) (addr) ea) & TAG_MASK)));\n-\n-misshandler:\n-  equal = si_ceqi (etag_lo, 1);\n-  __cache_miss (ea, entry, (si_to_uint (si_clz (si_gbb (equal))) - 16) >> 2);\n-  goto missreturn;\n-}\n-\n-void *\n-__cache_fetch (__ea void *ea)\n-{\n-  return __cache_fetch_dirty (ea, 0);\n-}\n-\n-void\n-__cache_touch (__ea void *ea __attribute__ ((unused)))\n-{\n-  /* NO-OP for now.  */\n-}\n-\n-void __cache_flush (void) __attribute__ ((destructor));\n-void\n-__cache_flush (void)\n-{\n-  struct __cache_tag_array *entry = __cache_tag_array;\n-  unsigned int i;\n-  int j;\n-\n-  /* Cycle through each cache entry and evict all used ways.  */\n-\n-  for (i = 0; i < CACHE_LINES / WAYS; i++)\n-    {\n-      for (j = 0; j < WAYS; j++)\n-\tif (!CHECK_EMPTY (entry, j))\n-\t  __cache_evict_entry (entry, j);\n-\n-      entry++;\n-    }\n-}"}, {"sha": "db9fdf9fbf960d467b309102cc1916f9008237fc", "filename": "libgcc/config/spu/divmodti4.c", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fdivmodti4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fdivmodti4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Fdivmodti4.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,188 +0,0 @@\n-/* Copyright (C) 2008-2019 Free Software Foundation, Inc.\n- \n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n- \n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n- \n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <spu_intrinsics.h>\n-\n-typedef unsigned int UTItype __attribute__ ((mode (TI)));\n-typedef int TItype __attribute__ ((mode (TI)));\n-TItype __divti3 (TItype u, TItype v);\n-TItype __modti3 (TItype u, TItype v);\n-UTItype __udivti3 (UTItype u, UTItype v);\n-UTItype __umodti3 (UTItype u, UTItype v);\n-UTItype __udivmodti4 (UTItype u, UTItype v, UTItype *w);\n-\n-union qword_UTItype\n-  {\n-    qword q;\n-    UTItype t;\n-  };\n-  \n-inline static qword\n-si_from_UTItype (UTItype t)\n-{ \n-  union qword_UTItype u;\n-  u.t = t;\n-  return u.q;\n-}\n-\n-inline static UTItype\n-si_to_UTItype (qword q)\n-{ \n-  union qword_UTItype u;\n-  u.q = q;\n-  return u.t;\n-}\n-\n-inline static unsigned int\n-count_leading_zeros (UTItype x)\n-{\n-  qword c = si_clz (*(qword *) & x);\n-  qword cmp0 = si_cgti (c, 31);\n-  qword cmp1 = si_and (cmp0, si_shlqbyi (cmp0, 4));\n-  qword cmp2 = si_and (cmp1, si_shlqbyi (cmp0, 8));\n-  qword s = si_a (c, si_and (cmp0, si_shlqbyi (c, 4)));\n-  s = si_a (s, si_and (cmp1, si_shlqbyi (c, 8)));\n-  s = si_a (s, si_and (cmp2, si_shlqbyi (c, 12)));\n-  return si_to_uint (s);\n-}\n-\n-/* Based on implementation of udivmodsi4, which is essentially\n- * an optimized version of libgcc/udivmodsi4.c\n-        clz      %7,%2\n-        clz      %4,%1\n-        il       %5,1\n-        fsmbi    %0,0\n-        sf       %7,%4,%7\n-        ori      %3,%1,0\n-        shl      %5,%5,%7\n-        shl      %4,%2,%7\n-1:      or       %8,%0,%5\n-        rotmi    %5,%5,-1\n-        clgt     %6,%4,%3\n-        sf       %7,%4,%3\n-        rotmi    %4,%4,-1\n-        selb     %0,%8,%0,%6\n-        selb     %3,%7,%3,%6\n-3:      brnz     %5,1b\n- */\n-\n-UTItype\n-__udivmodti4 (UTItype num, UTItype den, UTItype * rp)\n-{\n-  qword shift =\n-    si_from_uint (count_leading_zeros (den) - count_leading_zeros (num));\n-  qword n0 = si_from_UTItype (num);\n-  qword d0 = si_from_UTItype (den);\n-  qword bit = si_andi (si_fsmbi (1), 1);\n-  qword r0 = si_il (0);\n-  qword m1 = si_fsmbi (0x000f);\n-  qword mask, r1, n1;\n-\n-  d0 = si_shlqbybi (si_shlqbi (d0, shift), shift);\n-  bit = si_shlqbybi (si_shlqbi (bit, shift), shift);\n-\n-  do\n-    {\n-      r1 = si_or (r0, bit);\n-\n-      // n1 = n0 - d0 in TImode\n-      n1 = si_bg (d0, n0);\n-      n1 = si_shlqbyi (n1, 4);\n-      n1 = si_sf (m1, n1);\n-      n1 = si_bgx (d0, n0, n1);\n-      n1 = si_shlqbyi (n1, 4);\n-      n1 = si_sf (m1, n1);\n-      n1 = si_bgx (d0, n0, n1);\n-      n1 = si_shlqbyi (n1, 4);\n-      n1 = si_sf (m1, n1);\n-      n1 = si_sfx (d0, n0, n1);\n-\n-      mask = si_fsm (si_cgti (n1, -1));\n-      r0 = si_selb (r0, r1, mask);\n-      n0 = si_selb (n0, n1, mask);\n-      bit = si_rotqmbii (bit, -1);\n-      d0 = si_rotqmbii (d0, -1);\n-    }\n-  while (si_to_uint (si_orx (bit)));\n-  if (rp)\n-    *rp = si_to_UTItype (n0);\n-  return si_to_UTItype (r0);\n-}\n-\n-UTItype\n-__udivti3 (UTItype n, UTItype d)\n-{\n-  return __udivmodti4 (n, d, (UTItype *)0);\n-}\n-\n-UTItype\n-__umodti3 (UTItype n, UTItype d)\n-{\n-  UTItype w;\n-  __udivmodti4 (n, d, &w);\n-  return w;\n-}\n-\n-TItype\n-__divti3 (TItype n, TItype d)\n-{\n-  int c = 0;\n-  TItype w;\n-\n-  if (n < 0)\n-    {\n-        c = ~c;\n-        n = -n;\n-    }\n-  if (d < 0)\n-    {\n-        c = ~c;\n-        d = -d;\n-    }\n-\n-  w = __udivmodti4 (n, d, (UTItype *)0);\n-  if (c)\n-    w = -w;\n-  return w;\n-}\n-\n-TItype\n-__modti3 (TItype n, TItype d)\n-{\n-  int c = 0;\n-  TItype w;\n-\n-  if (n < 0)\n-    {\n-        c = ~c;\n-        n = -n;\n-    }\n-  if (d < 0)\n-    {\n-        c = ~c;\n-        d = -d;\n-    }\n-\n-  __udivmodti4 (n, d, (UTItype *) &w);\n-  if (c)\n-    w = -w;\n-  return w;\n-}"}, {"sha": "f4e95a9927b399b8ffa84a65ffec7c50a9856703", "filename": "libgcc/config/spu/divv2df3.c", "status": "removed", "additions": 0, "deletions": 195, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fdivv2df3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fdivv2df3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Fdivv2df3.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,195 +0,0 @@\n-/* Copyright (C) 2009-2019 Free Software Foundation, Inc.\n- \n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n- \n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n- \n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <spu_intrinsics.h>\n-\n-vector double __divv2df3 (vector double a_in, vector double b_in);\n-\n-/* __divv2df3 divides the vector dividend a by the vector divisor b and \n-   returns the resulting vector quotient.  Maximum error about 0.5 ulp \n-   over entire double range including denorms, compared to true result\n-   in round-to-nearest rounding mode.  Handles Inf or NaN operands and \n-   results correctly.  */\n-\n-vector double\n-__divv2df3 (vector double a_in, vector double b_in)\n-{\n-  /* Variables */\n-  vec_int4    exp, exp_bias;\n-  vec_uint4   no_underflow, overflow;\n-  vec_float4  mant_bf, inv_bf;\n-  vec_ullong2 exp_a, exp_b;\n-  vec_ullong2 a_nan, a_zero, a_inf, a_denorm, a_denorm0;\n-  vec_ullong2 b_nan, b_zero, b_inf, b_denorm, b_denorm0;\n-  vec_ullong2 nan;\n-  vec_uint4   a_exp, b_exp;\n-  vec_ullong2 a_mant_0, b_mant_0;\n-  vec_ullong2 a_exp_1s, b_exp_1s;\n-  vec_ullong2 sign_exp_mask;\n-\n-  vec_double2 a, b;\n-  vec_double2 mant_a, mant_b, inv_b, q0, q1, q2, mult;\n-\n-  /* Constants */\n-  vec_uint4   exp_mask_u32 = spu_splats((unsigned int)0x7FF00000);\n-  vec_uchar16 splat_hi = (vec_uchar16){0,1,2,3, 0,1,2,3,  8, 9,10,11, 8,9,10,11};\n-  vec_uchar16 swap_32 = (vec_uchar16){4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11};\n-  vec_ullong2 exp_mask = spu_splats(0x7FF0000000000000ULL);\n-  vec_ullong2 sign_mask = spu_splats(0x8000000000000000ULL);\n-  vec_float4  onef = spu_splats(1.0f);\n-  vec_double2 one = spu_splats(1.0);\n-  vec_double2 exp_53 = (vec_double2)spu_splats(0x0350000000000000ULL);\n-\n-  sign_exp_mask = spu_or(sign_mask, exp_mask);\n-\n-  /* Extract the floating point components from each of the operands including\n-   * exponent and mantissa.\n-   */\n-  a_exp = (vec_uint4)spu_and((vec_uint4)a_in, exp_mask_u32);\n-  a_exp = spu_shuffle(a_exp, a_exp, splat_hi);\n-  b_exp = (vec_uint4)spu_and((vec_uint4)b_in, exp_mask_u32);\n-  b_exp = spu_shuffle(b_exp, b_exp, splat_hi);\n-\n-  a_mant_0 = (vec_ullong2)spu_cmpeq((vec_uint4)spu_andc((vec_ullong2)a_in, sign_exp_mask), 0);\n-  a_mant_0 = spu_and(a_mant_0, spu_shuffle(a_mant_0, a_mant_0, swap_32));\n-\n-  b_mant_0 = (vec_ullong2)spu_cmpeq((vec_uint4)spu_andc((vec_ullong2)b_in, sign_exp_mask), 0);\n-  b_mant_0 = spu_and(b_mant_0, spu_shuffle(b_mant_0, b_mant_0, swap_32));\n-\n-  a_exp_1s = (vec_ullong2)spu_cmpeq(a_exp, exp_mask_u32);\n-  b_exp_1s = (vec_ullong2)spu_cmpeq(b_exp, exp_mask_u32);\n-\n-  /* Identify all possible special values that must be accommodated including:\n-   * +-denorm, +-0, +-infinity, and NaNs.\n-   */\n-  a_denorm0= (vec_ullong2)spu_cmpeq(a_exp, 0);\n-  a_nan    = spu_andc(a_exp_1s, a_mant_0);\n-  a_zero   = spu_and (a_denorm0, a_mant_0);\n-  a_inf    = spu_and (a_exp_1s, a_mant_0);\n-  a_denorm = spu_andc(a_denorm0, a_zero);\n-\n-  b_denorm0= (vec_ullong2)spu_cmpeq(b_exp, 0);\n-  b_nan    = spu_andc(b_exp_1s, b_mant_0);\n-  b_zero   = spu_and (b_denorm0, b_mant_0);\n-  b_inf    = spu_and (b_exp_1s, b_mant_0);\n-  b_denorm = spu_andc(b_denorm0, b_zero);\n-\n-  /* Scale denorm inputs to into normalized numbers by conditionally scaling the \n-   * input parameters.\n-   */\n-  a = spu_sub(spu_or(a_in, exp_53), spu_sel(exp_53, a_in, sign_mask));\n-  a = spu_sel(a_in, a, a_denorm);\n-\n-  b = spu_sub(spu_or(b_in, exp_53), spu_sel(exp_53, b_in, sign_mask));\n-  b = spu_sel(b_in, b, b_denorm);\n-\n-  /* Extract the divisor and dividend exponent and force parameters into the signed \n-   * range [1.0,2.0) or [-1.0,2.0).\n-   */\n-  exp_a = spu_and((vec_ullong2)a, exp_mask);\n-  exp_b = spu_and((vec_ullong2)b, exp_mask);\n-\n-  mant_a = spu_sel(a, one, (vec_ullong2)exp_mask);\n-  mant_b = spu_sel(b, one, (vec_ullong2)exp_mask);\n-  \n-  /* Approximate the single reciprocal of b by using\n-   * the single precision reciprocal estimate followed by one \n-   * single precision iteration of Newton-Raphson.\n-   */\n-  mant_bf = spu_roundtf(mant_b);\n-  inv_bf = spu_re(mant_bf);\n-  inv_bf = spu_madd(spu_nmsub(mant_bf, inv_bf, onef), inv_bf, inv_bf);\n-\n-  /* Perform 2 more Newton-Raphson iterations in double precision. The\n-   * result (q1) is in the range (0.5, 2.0).\n-   */\n-  inv_b = spu_extend(inv_bf);\n-  inv_b = spu_madd(spu_nmsub(mant_b, inv_b, one), inv_b, inv_b);\n-  q0 = spu_mul(mant_a, inv_b);\n-  q1 = spu_madd(spu_nmsub(mant_b, q0, mant_a), inv_b, q0);\n-\n-  /* Determine the exponent correction factor that must be applied \n-   * to q1 by taking into account the exponent of the normalized inputs\n-   * and the scale factors that were applied to normalize them.\n-   */\n-  exp = spu_rlmaska(spu_sub((vec_int4)exp_a, (vec_int4)exp_b), -20);\n-  exp = spu_add(exp, (vec_int4)spu_add(spu_and((vec_int4)a_denorm, -0x34), spu_and((vec_int4)b_denorm, 0x34)));\n-  \n-  /* Bias the quotient exponent depending on the sign of the exponent correction\n-   * factor so that a single multiplier will ensure the entire double precision\n-   * domain (including denorms) can be achieved.\n-   *\n-   *    exp \t       bias q1     adjust exp\n-   *   =====\t       ========    ==========\n-   *   positive         2^+65         -65\n-   *   negative         2^-64         +64\n-   */\n-  exp_bias = spu_xor(spu_rlmaska(exp, -31), 64);\n-  exp = spu_sub(exp, exp_bias);\n-\n-  q1 = spu_sel(q1, (vec_double2)spu_add((vec_int4)q1, spu_sl(exp_bias, 20)), exp_mask);\n-\n-  /* Compute a multiplier (mult) to applied to the quotient (q1) to produce the \n-   * expected result. On overflow, clamp the multiplier to the maximum non-infinite\n-   * number in case the rounding mode is not round-to-nearest.\n-   */\n-  exp = spu_add(exp, 0x3FF);\n-  no_underflow = spu_cmpgt(exp, 0);\n-  overflow = spu_cmpgt(exp, 0x7FE);\n-  exp = spu_and(spu_sl(exp, 20), (vec_int4)no_underflow);\n-  exp = spu_and(exp, (vec_int4)exp_mask);\n-\n-  mult = spu_sel((vec_double2)exp, (vec_double2)(spu_add((vec_uint4)exp_mask, -1)), (vec_ullong2)overflow);\n-\n-  /* Handle special value conditions. These include:\n-   *\n-   * 1) IF either operand is a NaN OR both operands are 0 or INFINITY THEN a NaN \n-   *    results.\n-   * 2) ELSE IF the dividend is an INFINITY OR the divisor is 0 THEN a INFINITY results.\n-   * 3) ELSE IF the dividend is 0 OR the divisor is INFINITY THEN a 0 results.\n-   */\n-  mult = spu_andc(mult, (vec_double2)spu_or(a_zero, b_inf));\n-  mult = spu_sel(mult, (vec_double2)exp_mask, spu_or(a_inf, b_zero));\n-\n-  nan = spu_or(a_nan, b_nan);\n-  nan = spu_or(nan, spu_and(a_zero, b_zero));\n-  nan = spu_or(nan, spu_and(a_inf, b_inf));\n-\n-  mult = spu_or(mult, (vec_double2)nan);\n-\n-  /* Scale the final quotient */\n-\n-  q2 = spu_mul(q1, mult);\n-\n-  return (q2);\n-}\n-\n-\n-/* We use the same function for vector and scalar division.  Provide the\n-   scalar entry point as an alias.  */\n-double __divdf3 (double a, double b)\n-  __attribute__ ((__alias__ (\"__divv2df3\")));\n-\n-/* Some toolchain builds used the __fast_divdf3 name for this helper function.\n-   Provide this as another alternate entry point for compatibility.  */\n-double __fast_divdf3 (double a, double b)\n-  __attribute__ ((__alias__ (\"__divv2df3\")));\n-"}, {"sha": "1cdfa805ada81feaf4a78218b62511fc4636d5d6", "filename": "libgcc/config/spu/float_disf.c", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Ffloat_disf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Ffloat_disf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Ffloat_disf.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,31 +0,0 @@\n-/* Copyright (C) 2008-2019 Free Software Foundation, Inc.\n-  \n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-  \n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-  \n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Prototype.  */\n-float __floatdisf (long long x);\n-\n-float __floatdisf (long long x)\n-{\n-  /* The SPU back-end now generates inline code for this conversion.\n-     This file is solely used to provide the __floatdisf functions\n-     for objects generated with prior versions of GCC.  */\n-  return x;\n-}"}, {"sha": "81dab3c1b27a3a9ee344aadebd6373281ba8a11f", "filename": "libgcc/config/spu/float_unsdidf.c", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Ffloat_unsdidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Ffloat_unsdidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Ffloat_unsdidf.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,54 +0,0 @@\n-/* Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-  \n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-  \n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-  \n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <spu_intrinsics.h>\n-const unsigned char __didf_scale[16] __attribute__ ((__aligned__ (16))) = {\n-  0x00, 0x00, 0x04, 0x3e,\n-  0x00, 0x00, 0x04, 0x1e,\n-  0x00, 0x00, 0x00, 0x00,\n-  0x00, 0x00, 0x00, 0x00\n-};\n-const unsigned char __didf_pat[16] __attribute__ ((__aligned__ (16))) = {\n-  0x02, 0x03, 0x10, 0x11,\n-  0x12, 0x13, 0x80, 0x80,\n-  0x06, 0x07, 0x14, 0x15,\n-  0x16, 0x17, 0x80, 0x80\n-};\n-\n-/* double __float_unsdidf (unsigned long long int) \n-   Construct two exact doubles representing the high and low parts (in\n-   parallel), then add them. */\n-qword __float_unsdidf (qword DI);\n-qword\n-__float_unsdidf (qword DI)\n-{\n-  qword t0, t1, t2, t3, t4, t5, t6, t7, t8;\n-  t0 = si_clz (DI);\n-  t1 = si_shl (DI, t0);\n-  t2 = si_ceqi (t0, 32);\n-  t3 = si_sf (t0, *(const qword *) __didf_scale);\n-  t4 = si_a (t1, t1);\n-  t5 = si_andc (t3, t2);\n-  t6 = si_shufb (t5, t4, *(const qword *) __didf_pat);\n-  t7 = si_shlqbii (t6, 4);\n-  t8 = si_shlqbyi (t7, 8);\n-  return si_dfa (t7, t8);\n-}"}, {"sha": "93e1bd306d539f6dd2cce49fc33206a7b2476b0c", "filename": "libgcc/config/spu/float_unsdisf.c", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Ffloat_unsdisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Ffloat_unsdisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Ffloat_unsdisf.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,31 +0,0 @@\n-/* Copyright (C) 2008-2019 Free Software Foundation, Inc.\n-  \n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-  \n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-  \n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Prototype.  */\n-float __floatundisf (unsigned long long x);\n-\n-float __floatundisf (unsigned long long x)\n-{\n-  /* The SPU back-end now generates inline code for this conversion.\n-     This file is solely used to provide the __floatundisf function\n-     for objects generated with prior versions of GCC.  */\n-  return x;\n-}"}, {"sha": "7f78977592b7f3d2b8cfd70cd2d8016324214652", "filename": "libgcc/config/spu/float_unssidf.c", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Ffloat_unssidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Ffloat_unssidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Ffloat_unssidf.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,45 +0,0 @@\n-/* Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-  \n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n-  \n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-  \n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <spu_intrinsics.h>\n-const unsigned char __sidf_pat[16] __attribute__ ((__aligned__ (16))) = {\n-  0x02, 0x03, 0x10, 0x11,\n-  0x12, 0x13, 0x80, 0x80,\n-  0x06, 0x07, 0x14, 0x15,\n-  0x16, 0x17, 0x80, 0x80\n-};\n-\n-/* double __float_unssidf (unsigned int SI) */\n-qword __float_unssidf (qword SI);\n-qword\n-__float_unssidf (qword SI)\n-{\n-  qword t0, t1, t2, t3, t4, t5, t6, t7;\n-  t0 = si_clz (SI);\n-  t1 = si_il (1054);\n-  t2 = si_shl (SI, t0);\n-  t3 = si_ceqi (t0, 32);\n-  t4 = si_sf (t0, t1);\n-  t5 = si_a (t2, t2);\n-  t6 = si_andc (t4, t3);\n-  t7 = si_shufb (t6, t5, *(const qword *) __sidf_pat);\n-  return si_shlqbii (t7, 4);\n-}"}, {"sha": "36ce140aae0254a482035205bd6a6ec7c65d01a1", "filename": "libgcc/config/spu/mfc_multi_tag_release.c", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmfc_multi_tag_release.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmfc_multi_tag_release.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Fmfc_multi_tag_release.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,72 +0,0 @@\n-/* Copyright (C) 2007-2019 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include <spu_mfcio.h>\n-extern vector unsigned int __mfc_tag_table;\n-\n-/* Release a sequential group of tags from exclusive use. The sequential\n-   group of tags is the range starting from <first_tag> through\n-   <first_tag>+<number_of_tags>-1. Upon successful release, MFC_DMA_TAG_VALID\n-   is returned and the tags become available for future reservation.\n-\n-   If the specified tags were not previously reserved, no action is\n-   taken and MFC_DMA_TAG_INVALID is returned.  */\n-\n-unsigned int\n-__mfc_multi_tag_release (unsigned int first_tag, unsigned int number_of_tags)\n-{\n-  vector unsigned int table_copy, tmp, tmp1;\n-  vector unsigned int one = (vector unsigned int)\n-        { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };\n-  vector unsigned int is_invalid;\n-  unsigned int last_tag;\n-  vector unsigned int has_been_reserved;\n-\n-  last_tag = first_tag + number_of_tags;\n-\n-  table_copy = spu_sl (one, number_of_tags);\n-  table_copy = spu_rl (table_copy, -last_tag);\n-  table_copy = spu_xor (table_copy, -1);\n-\n-  /* Make sure the tags are in range and valid.  */\n-  tmp = spu_cmpgt (spu_promote(last_tag, 0), 32);\n-  tmp1 = spu_cmpgt (spu_promote(number_of_tags, 0), 32);\n-  is_invalid =  spu_cmpgt (spu_promote(first_tag, 0), 31);\n-\n-  /* All bits are set to 1 if invalid, 0 if valid.  */\n-  is_invalid = spu_or (tmp, is_invalid);\n-  is_invalid = spu_or (tmp1, is_invalid);\n-\n-  /* check whether these tags have been reserved */\n-  tmp = spu_rlmask (one, (int)-number_of_tags);\n-  tmp1 = spu_sl (__mfc_tag_table, first_tag);\n-  has_been_reserved = spu_cmpgt(tmp1, tmp);\n-\n-  is_invalid = spu_or (has_been_reserved, is_invalid);\n-\n-  table_copy = spu_sel (__mfc_tag_table, table_copy, table_copy);\n-  __mfc_tag_table = spu_sel (table_copy, __mfc_tag_table, is_invalid);\n-\n-  return spu_extract (is_invalid, 0);\n-}\n-"}, {"sha": "598c14efab567b45d04bb81f4c6245383fa97a94", "filename": "libgcc/config/spu/mfc_multi_tag_reserve.c", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmfc_multi_tag_reserve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmfc_multi_tag_reserve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Fmfc_multi_tag_reserve.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,84 +0,0 @@\n-/* Copyright (C) 2007-2019 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include <spu_mfcio.h>\n-extern vector unsigned int __mfc_tag_table;\n-\n-/* Reserve a sequential group of tags for exclusive use.  The number of\n-   tags to be reserved is specified by the <number_of_tags> parameter.\n-   This routine returns the first tag ID for a sequential list of\n-   available tags and marks them as reserved. The reserved group\n-   of tags is in the range starting from the returned tag through\n-   the returned tag + <number_of_tags>-1.\n-\n-   If the number of tags requested exceeds the number of available\n-   sequential tags, then MFC_DMA_TAG_INVALID is returned indicating\n-   that the request could not be serviced.  */\n-\n-unsigned int\n-__mfc_multi_tag_reserve (unsigned int number_of_tags)\n-{\n-  vector unsigned int table_copy;\n-  vector unsigned int one = (vector unsigned int)\n-        { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };\n-  vector unsigned int count_busy, is_valid;\n-  vector unsigned int count_total;\n-  vector unsigned int count_avail = (vector unsigned int) { 0, 0, 0, 0 };\n-  vector unsigned int index = (vector unsigned int) { 0, 0, 0, 0 };\n-\n-  table_copy = __mfc_tag_table;\n-\n-\n-  /* count_busy: number of consecutive busy tags\n-     count_avail: number of consecutive free tags\n-     table_copy: temporary copy of the tag table\n-     count_total: sum of count_busy and count_avail\n-     index: index of the current working tag  */\n-  do\n-    {\n-      table_copy = spu_sl (table_copy, count_avail);\n-\n-      count_busy = spu_cntlz (table_copy);\n-      table_copy = spu_sl (table_copy, count_busy);\n-      count_avail = spu_cntlz (spu_xor(table_copy, -1));\n-      count_total = spu_add (count_busy, count_avail);\n-      index = spu_add (index, count_total);\n-    }\n-  while (spu_extract (count_avail, 0) < number_of_tags\n-\t && spu_extract (table_copy, 0) != 0);\n-\n-  index = spu_sub (index, count_avail);\n-\n-  /* is_valid is set to 0xFFFFFFFF if table_copy == 0, 0 otherwise.  */\n-  is_valid = spu_cmpeq (table_copy, 0);\n-  index = spu_sel (index, is_valid, is_valid);\n-\n-  /* Now I need to actually mark the tags as used.  */\n-  table_copy = spu_sl (one, number_of_tags);\n-  table_copy = spu_rl (table_copy, -number_of_tags - spu_extract (index, 0));\n-  table_copy = spu_sel (table_copy, __mfc_tag_table, table_copy);\n-  __mfc_tag_table = spu_sel (table_copy, __mfc_tag_table, is_valid);\n-\n-  return spu_extract (index, 0);\n-}\n-"}, {"sha": "29e8bacaeadde8c404fc75abde30005a1d96c1b7", "filename": "libgcc/config/spu/mfc_tag_release.c", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmfc_tag_release.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmfc_tag_release.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Fmfc_tag_release.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,59 +0,0 @@\n-/* Copyright (C) 2007-2019 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include <spu_mfcio.h>\n-extern vector unsigned int __mfc_tag_table;\n-\n-/* Release the specified DMA tag from exclusive use.  Once released, the\n-   tag is available for future reservation.  Upon successful release,\n-   MFC_DMA_TAG_VALID is returned.  If the specified tag is not in the\n-   range 0 to 31, or had not been reserved, no action is taken and\n-   MFC_DMA_TAG_INVALID is returned.  */\n-\n-unsigned int\n-__mfc_tag_release (unsigned int tag)\n-{\n-  vector unsigned int is_invalid;\n-  vector unsigned int mask = (vector unsigned int)\n-\t{ 0x80000000, 0x80000000, 0x80000000, 0x80000000 };\n-  vector signed int zero = (vector signed int) { 0, 0, 0, 0 };\n-\n-  vector signed int has_been_reserved;\n-\n-  /* Check if the tag is out of range.  */\n-  is_invalid = spu_cmpgt (spu_promote (tag, 0), 31);\n-\n-  /* Check whether the tag has been reserved, set to all 1 if has not\n-     been reserved, 0 otherwise.  */\n-  has_been_reserved = (vector signed int) spu_rl (__mfc_tag_table, tag);\n-  has_been_reserved = (vector signed int) spu_cmpgt (zero, has_been_reserved);\n-\n-  /* Set invalid.  */\n-  is_invalid = spu_or ((vector unsigned int) has_been_reserved, is_invalid);\n-\n-  mask = spu_rlmask (mask, (int)(-tag));\n-  __mfc_tag_table = spu_or (__mfc_tag_table, mask);\n-\n-  return spu_extract(is_invalid, 0);\n-}\n-"}, {"sha": "e2e09daebca31a607cad035ddd4b1271522da6d5", "filename": "libgcc/config/spu/mfc_tag_reserve.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmfc_tag_reserve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmfc_tag_reserve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Fmfc_tag_reserve.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,51 +0,0 @@\n-/* Copyright (C) 2007-2019 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include <spu_mfcio.h>\n-extern vector unsigned int __mfc_tag_table;\n-\n-/* Reserves a DMA tag for exclusive use.  This routine returns an available\n-   tag id in the range 0 to 31 and marks the tag as reserved.  If no tags\n-   are available, MFC_DMA_TAG_INVALID is returned indicating that all tags\n-   are already reserved.  */\n-\n-unsigned int\n-__mfc_tag_reserve (void)\n-{\n-  vector unsigned int mask = (vector unsigned int)\n-\t{ 0x80000000, 0x80000000, 0x80000000, 0x80000000 };\n-  vector unsigned int count_zeros, is_valid;\n-  vector signed int count_neg;\n-\n-  count_zeros = spu_cntlz (__mfc_tag_table);\n-  count_neg = spu_sub (0, (vector signed int) count_zeros);\n-\n-  mask = spu_rlmask (mask, (vector signed int) count_neg);\n-  __mfc_tag_table = spu_andc (__mfc_tag_table, mask);\n-\n-  is_valid = spu_cmpeq (count_zeros, 32);\n-  count_zeros = spu_sel (count_zeros, is_valid, is_valid);\n-\n-  return spu_extract (count_zeros, 0);\n-}\n-"}, {"sha": "34a640a18aee71db2cc56540071b97e784631ec0", "filename": "libgcc/config/spu/mfc_tag_table.c", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmfc_tag_table.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmfc_tag_table.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Fmfc_tag_table.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,39 +0,0 @@\n-/* Copyright (C) 2007-2019 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* The free tag table used by the MFC tag manager, with tag0\n-   reserved for the overlay manager.  */\n-__vector unsigned int\n-__mfc_tag_table = (__vector unsigned int) { 0x7FFFFFFF, -1, -1, -1 };\n-\n-/* Arrange to release tag0 if overlays are not present.  */\n-static void __mfc_tag_init (void) __attribute__ ((constructor));\n-\n-static void\n-__mfc_tag_init (void)\n-{\n-  extern void _ovly_table __attribute__ ((weak));\n-\n-  if (&_ovly_table == 0)\n-    __mfc_tag_table = (__vector unsigned int) { -1, -1, -1, -1 };\n-}"}, {"sha": "c582e46b402f97bf1bfc858198a454ef1296f710", "filename": "libgcc/config/spu/multi3.c", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmulti3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Fmulti3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Fmulti3.c?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,119 +0,0 @@\n-/* Copyright (C) 2008-2019 Free Software Foundation, Inc.\n- \n-   This file is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3 of the License, or (at your option)\n-   any later version.\n- \n-   This file is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n- \n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <spu_intrinsics.h>\n-\n-typedef int TItype __attribute__ ((mode (TI)));\n-\n-union qword_TItype\n-  {\n-    qword q;\n-    TItype t;\n-  };\n-  \n-inline static qword\n-si_from_TItype (TItype t)\n-{ \n-  union qword_TItype u;\n-  u.t = t;\n-  return u.q;\n-}\n-\n-inline static TItype\n-si_to_TItype (qword q)\n-{ \n-  union qword_TItype u;\n-  u.q = q;\n-  return u.t;\n-}\n-\n-/* A straight forward vectorization and unrolling of\n- *   short l[8], r[8];\n- *   TItype total = 0;\n- *   for (i = 0; i < 8; i++)\n- *     for (j = 0; j < 8; j++)\n- *       total += (TItype)((l[7-i] * r[7-j]) << (16 * (i + j)));\n- */\n-TItype\n-__multi3 (TItype l, TItype r)\n-{\n-  qword u = si_from_TItype (l);\n-  qword v = si_from_TItype (r);\n-  qword splat0 = si_shufb (v, v, si_ilh (0x0001));\n-  qword splat1 = si_shufb (v, v, si_ilh (0x0203));\n-  qword splat2 = si_shufb (v, v, si_ilh (0x0405));\n-  qword splat3 = si_shufb (v, v, si_ilh (0x0607));\n-  qword splat4 = si_shufb (v, v, si_ilh (0x0809));\n-  qword splat5 = si_shufb (v, v, si_ilh (0x0a0b));\n-  qword splat6 = si_shufb (v, v, si_ilh (0x0c0d));\n-  qword splat7 = si_shufb (v, v, si_ilh (0x0e0f));\n-\n-  qword part0l = si_shlqbyi (si_mpyu   (u, splat0), 14);\n-  qword part1h = si_shlqbyi (si_mpyhhu (u, splat1), 14);\n-  qword part1l = si_shlqbyi (si_mpyu   (u, splat1), 12);\n-  qword part2h = si_shlqbyi (si_mpyhhu (u, splat2), 12);\n-  qword part2l = si_shlqbyi (si_mpyu   (u, splat2), 10);\n-  qword part3h = si_shlqbyi (si_mpyhhu (u, splat3), 10);\n-  qword part3l = si_shlqbyi (si_mpyu   (u, splat3), 8);\n-  qword part4h = si_shlqbyi (si_mpyhhu (u, splat4), 8);\n-  qword part4l = si_shlqbyi (si_mpyu   (u, splat4), 6);\n-  qword part5h = si_shlqbyi (si_mpyhhu (u, splat5), 6);\n-  qword part5l = si_shlqbyi (si_mpyu   (u, splat5), 4);\n-  qword part6h = si_shlqbyi (si_mpyhhu (u, splat6), 4);\n-  qword part6l = si_shlqbyi (si_mpyu   (u, splat6), 2);\n-  qword part7h = si_shlqbyi (si_mpyhhu (u, splat7), 2);\n-  qword part7l = si_mpyu (u, splat7);\n-\n-  qword carry, total0, total1, total2, total3, total4;\n-  qword total5, total6, total7, total8, total9, total10;\n-  qword total;\n-\n-  total0 = si_a (si_a (si_a (part0l, part1h), si_a (part1l, part2h)), part7l);\n-  total1 = si_a (part2l, part3h);\n-  total2 = si_a (part3l, part4h);\n-  total3 = si_a (part4l, part5h);\n-  total4 = si_a (part5l, part6h);\n-  total5 = si_a (part6l, part7h);\n-  total6 = si_a (total0, total1);\n-  total7 = si_a (total2, total3);\n-  total8 = si_a (total4, total5);\n-  total9 = si_a (total6, total7);\n-  total10 = si_a (total8, total9);\n-\n-  carry = si_cg (part2l, part3h);\n-  carry = si_a (carry, si_cg (part3l, part4h));\n-  carry = si_a (carry, si_cg (part4l, part5h));\n-  carry = si_a (carry, si_cg (part5l, part6h));\n-  carry = si_a (carry, si_cg (part6l, part7h));\n-  carry = si_a (carry, si_cg (total0, total1));\n-  carry = si_a (carry, si_cg (total2, total3));\n-  carry = si_a (carry, si_cg (total4, total5));\n-  carry = si_a (carry, si_cg (total6, total7));\n-  carry = si_a (carry, si_cg (total8, total9));\n-  carry = si_shlqbyi (carry, 4);\n-\n-  total = si_cg (total10, carry);\n-  total = si_shlqbyi (total, 4);\n-  total = si_cgx (total10, carry, total);\n-  total = si_shlqbyi (total, 4);\n-  total = si_addx (total10, carry, total);\n-  return si_to_TItype (total);\n-}"}, {"sha": "29536e881324edc627af074f229bbcfc15a2ccaa", "filename": "libgcc/config/spu/t-elf", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Ft-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/934392185369af22fee845e4edd92c420b8c248b/libgcc%2Fconfig%2Fspu%2Ft-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fspu%2Ft-elf?ref=934392185369af22fee845e4edd92c420b8c248b", "patch": "@@ -1,59 +0,0 @@\n-# Don't let CTOR_LIST end up in sdata section.\n-# FIXME: This is the default.\n-CRTSTUFF_T_CFLAGS =\n-\n-# We exclude those because the libgcc2.c default versions do not support\n-# the SPU single-precision format (round towards zero).  We provide our\n-# own versions below and/or via direct expansion.\n-LIB2FUNCS_EXCLUDE = _floatdisf _floatundisf _floattisf _floatunstisf\n-\n-LIB2ADD_ST = $(srcdir)/config/spu/float_unssidf.c \\\n-\t     $(srcdir)/config/spu/float_unsdidf.c \\\n-\t     $(srcdir)/config/spu/float_unsdisf.c \\\n-\t     $(srcdir)/config/spu/float_disf.c \\\n-\t     $(srcdir)/config/spu/mfc_tag_table.c \\\n-\t     $(srcdir)/config/spu/mfc_tag_reserve.c \\\n-\t     $(srcdir)/config/spu/mfc_tag_release.c \\\n-\t     $(srcdir)/config/spu/mfc_multi_tag_reserve.c \\\n-\t     $(srcdir)/config/spu/mfc_multi_tag_release.c \\\n-\t     $(srcdir)/config/spu/multi3.c \\\n-\t     $(srcdir)/config/spu/divmodti4.c \\\n-\t     $(srcdir)/config/spu/divv2df3.c\n-\n-# Build TImode conversion routines to support Fortran 128-bit\n-# integer data types.\n-LIB2_SIDITI_CONV_FUNCS = yes\n-\n-HOST_LIBGCC2_CFLAGS += -mwarn-reloc -D__IN_LIBGCC2\n-\n-# Neither gcc or newlib seem to have a standard way to generate multiple\n-# crt*.o files.  So we don't use the standard crt0.o name anymore.\n-\n-cachemgr.o: $(srcdir)/config/spu/cachemgr.c\n-\t$(gcc_compile) -c $<\n-\n-# Specialised rule to add a -D flag.\n-cachemgr_nonatomic.o: $(srcdir)/config/spu/cachemgr.c\n-\t$(gcc_compile) -DNONATOMIC -c $<\n-\n-libgcc_%.a: %.o\n-\t$(AR_FOR_TARGET) -rcs $@ $<\n-\n-cache8k.o: $(srcdir)/config/spu/cache.S\n-\t$(gcc_compile) -D__CACHE_SIZE__=8 -c $<\n-\n-cache16k.o: $(srcdir)/config/spu/cache.S\n-\t$(gcc_compile) -D__CACHE_SIZE__=16 -c $<\n-\n-cache32k.o: $(srcdir)/config/spu/cache.S\n-\t$(gcc_compile) -D__CACHE_SIZE__=32 -c $<\n-\n-cache64k.o: $(srcdir)/config/spu/cache.S\n-\t$(gcc_compile) -D__CACHE_SIZE__=64 -c $<\n-\n-cache128k.o: $(srcdir)/config/spu/cache.S\n-\t$(gcc_compile) -D__CACHE_SIZE__=128 -c $<\n-\n-# We provide our own version of __divdf3 that performs better and has\n-# better support for non-default rounding modes.\n-DPBIT_FUNCS := $(filter-out _div_df, $(DPBIT_FUNCS))"}, {"sha": "b130f0f55225a20de8159e68447858942b78348d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -1,3 +1,14 @@\n+2019-09-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* crossconfig.m4: Remove references to spu.\n+\t* configure: Regenerate.\n+\t* doc/xml/manual/appendix_contributing.xml: Remove references\n+\tto __ea as \"badword\" for spu.\n+\t* doc/html/manual/source_code_style.html: Regenerate.\n+\t* include/tr1/ell_integral.tcc (__ellint_rd): Do not attempt\n+\tto avoid __ea (as \"badword\" for spu).\n+\t(__ellint_rj): Likewise.\n+\n 2019-09-03  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \tPR other/79543"}, {"sha": "e3ad6129c0a3cb8a7e0a00b05c5b991ae6436b25", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 0, "deletions": 6167, "changes": 6167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f"}, {"sha": "5e2488979431b059f45977dbfb30164972fabd64", "filename": "libstdc++-v3/crossconfig.m4", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2Fcrossconfig.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2Fcrossconfig.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fcrossconfig.m4?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -54,14 +54,6 @@ case \"${host}\" in\n     AC_DEFINE(HAVE_SQRTF)\n     ;;\n \n-  spu-*-elf*)\n-    GLIBCXX_CHECK_COMPILER_FEATURES\n-    GLIBCXX_CHECK_LINKER_FEATURES\n-    GLIBCXX_CHECK_MATH_SUPPORT\n-    GLIBCXX_CHECK_STDLIB_SUPPORT\n-    AM_ICONV\n-    ;;\n-\n   *-aix*)\n     GLIBCXX_CHECK_LINKER_FEATURES\n     GLIBCXX_CHECK_MATH_SUPPORT"}, {"sha": "dd56d17681c373127806cb8e8a3c5a81dbc6ceed", "filename": "libstdc++-v3/doc/html/manual/source_code_style.html", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fsource_code_style.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fsource_code_style.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fsource_code_style.html?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -48,9 +48,6 @@\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0_res_ext<br />\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0__tg_*<br />\n <br />\n-\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SPU\u00a0adds:<br />\n-\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0__ea<br />\n-<br />\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0For\u00a0GCC:<br />\n <br />\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Note\u00a0that\u00a0this\u00a0list\u00a0is\u00a0out\u00a0of\u00a0date.\u00a0It\u00a0applies\u00a0to\u00a0the\u00a0old<br />"}, {"sha": "3e10e1b5e5c06171419ef80b86833a472ce7037d", "filename": "libstdc++-v3/doc/xml/manual/appendix_contributing.xml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fappendix_contributing.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fappendix_contributing.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fappendix_contributing.xml?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -463,9 +463,6 @@ indicate a place that may require attention for multi-thread safety.\n       _res_ext\n       __tg_*\n \n-      SPU adds:\n-      __ea\n-\n       For GCC:\n \n       [Note that this list is out of date. It applies to the old"}, {"sha": "1762f8e53519a4fc4cb1bb0770469c2bf0ae3bcf", "filename": "libstdc++-v3/include/tr1/ell_integral.tcc", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fell_integral.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2aeda98f3aa24034a700e7efcb6c1a9397836f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fell_integral.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fell_integral.tcc?ref=2f2aeda98f3aa24034a700e7efcb6c1a9397836f", "patch": "@@ -370,18 +370,17 @@ namespace tr1\n               __zn = __c0 * (__zn + __lambda);\n             }\n \n-\t  // Note: __ea is an SPU badname.\n-          _Tp __eaa = __xndev * __yndev;\n+          _Tp __ea = __xndev * __yndev;\n           _Tp __eb = __zndev * __zndev;\n-          _Tp __ec = __eaa - __eb;\n-          _Tp __ed = __eaa - _Tp(6) * __eb;\n+          _Tp __ec = __ea - __eb;\n+          _Tp __ed = __ea - _Tp(6) * __eb;\n           _Tp __ef = __ed + __ec + __ec;\n           _Tp __s1 = __ed * (-__c1 + __c3 * __ed\n                                    / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef\n                                    / _Tp(2));\n           _Tp __s2 = __zndev\n                    * (__c2 * __ef\n-                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __eaa));\n+                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));\n \n           return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2)\n                                         / (__mu * std::sqrt(__mu));\n@@ -634,17 +633,16 @@ namespace tr1\n               __pn = __c0 * (__pn + __lambda);\n             }\n \n-\t  // Note: __ea is an SPU badname.\n-          _Tp __eaa = __xndev * (__yndev + __zndev) + __yndev * __zndev;\n+          _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;\n           _Tp __eb = __xndev * __yndev * __zndev;\n           _Tp __ec = __pndev * __pndev;\n-          _Tp __e2 = __eaa - _Tp(3) * __ec;\n-          _Tp __e3 = __eb + _Tp(2) * __pndev * (__eaa - __ec);\n+          _Tp __e2 = __ea - _Tp(3) * __ec;\n+          _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);\n           _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4)\n                             - _Tp(3) * __c4 * __e3 / _Tp(2));\n           _Tp __s2 = __eb * (__c2 / _Tp(2)\n                    + __pndev * (-__c3 - __c3 + __pndev * __c4));\n-          _Tp __s3 = __pndev * __eaa * (__c2 - __pndev * __c3)\n+          _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3)\n                    - __c2 * __pndev * __ec;\n \n           return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3)"}]}