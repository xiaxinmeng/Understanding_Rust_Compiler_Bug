{"sha": "34eb8991ffc7d23522a2764821e03e0a774a2979", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRlYjg5OTFmZmM3ZDIzNTIyYTI3NjQ4MjFlMDNlMGE3NzRhMjk3OQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-05-19T20:44:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-05-19T20:44:32Z"}, "message": "tree-into-ssa.c (prepare_operand_for_rename): New argument is_use.\n\n\t* tree-into-ssa.c (prepare_operand_for_rename): New argument is_use.\n\tIf the operand is for a use, then strip away the SSA_NAME, do not\n\tstrip away the SSA_NAME for a set.  Never call release_ssa_name.\n\t(mark_def_sites): Appropriately pass additional argument to\n\tprepare_operand_for_rename.  If a VDEF_RESULT is not an SSA_NAME,\n\tthen set the VDEF_RESULT to the VDEF_OP.\n\t(set_def_block): Strip away any SSA_NAME to get to the real\n\tunderlying variable.\n\nFrom-SVN: r82035", "tree": {"sha": "aaee6127cca598dbcd8db80c30a6d4c475cfb26c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaee6127cca598dbcd8db80c30a6d4c475cfb26c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34eb8991ffc7d23522a2764821e03e0a774a2979", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34eb8991ffc7d23522a2764821e03e0a774a2979", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34eb8991ffc7d23522a2764821e03e0a774a2979", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34eb8991ffc7d23522a2764821e03e0a774a2979/comments", "author": null, "committer": null, "parents": [{"sha": "0f22079ec250534ffdc853b892162c160de8b302", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f22079ec250534ffdc853b892162c160de8b302", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f22079ec250534ffdc853b892162c160de8b302"}], "stats": {"total": 65, "additions": 42, "deletions": 23}, "files": [{"sha": "ae3bc3b8cfa49c1dff7a561fa2cf0583f8235882", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34eb8991ffc7d23522a2764821e03e0a774a2979/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34eb8991ffc7d23522a2764821e03e0a774a2979/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34eb8991ffc7d23522a2764821e03e0a774a2979", "patch": "@@ -5,6 +5,15 @@\n \n 2004-05-19  Jeff Law <law@redhat.com>\n \n+\t* tree-into-ssa.c (prepare_operand_for_rename): New argument is_use.\n+\tIf the operand is for a use, then strip away the SSA_NAME, do not\n+\tstrip away the SSA_NAME for a set.  Never call release_ssa_name.\n+\t(mark_def_sites): Appropriately pass additional argument to\n+\tprepare_operand_for_rename.  If a VDEF_RESULT is not an SSA_NAME,\n+\tthen set the VDEF_RESULT to the VDEF_OP.\n+\t(set_def_block): Strip away any SSA_NAME to get to the real\n+\tunderlying variable.\n+\n \t* tree-ssa-phiopt.c (value_replacement): Handle the case where\n \tthe desired edge out of COND_BLOCK reaches OTHER_BLOCK rather than\n \tBB directly."}, {"sha": "91c73b2ec9f5ee8cb8764fb97d425938b3a48064", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34eb8991ffc7d23522a2764821e03e0a774a2979/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34eb8991ffc7d23522a2764821e03e0a774a2979/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=34eb8991ffc7d23522a2764821e03e0a774a2979", "patch": "@@ -109,7 +109,7 @@ static void mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n static void compute_global_livein (bitmap, bitmap);\n static void set_def_block (tree, basic_block);\n static void set_livein_block (tree, basic_block);\n-static bool prepare_operand_for_rename (tree *op_p, size_t *uid_p);\n+static bool prepare_operand_for_rename (tree *op_p, size_t *uid_p, bool);\n static void insert_phi_nodes (bitmap *);\n static void rewrite_stmt (struct dom_walk_data *, basic_block,\n \t\t\t  block_stmt_iterator);\n@@ -232,7 +232,7 @@ mark_def_sites (struct dom_walk_data *walk_data,\n     {\n       tree *use_p = USE_OP_PTR (uses, i);\n \n-      if (prepare_operand_for_rename (use_p, &uid)\n+      if (prepare_operand_for_rename (use_p, &uid, true)\n \t  && !TEST_BIT (kills, uid))\n \tset_livein_block (*use_p, bb);\n     }\n@@ -243,7 +243,7 @@ mark_def_sites (struct dom_walk_data *walk_data,\n     {\n       tree *use_p = VUSE_OP_PTR (vuses, i);\n \n-      if (prepare_operand_for_rename (use_p, &uid))\n+      if (prepare_operand_for_rename (use_p, &uid, true))\n \tset_livein_block (*use_p, bb);\n     }\n \n@@ -255,12 +255,12 @@ mark_def_sites (struct dom_walk_data *walk_data,\n   vdefs = VDEF_OPS (ann);\n   for (i = 0; i < NUM_VDEFS (vdefs); i++)\n     {\n-      size_t dummy;\n-\n-      if (prepare_operand_for_rename (VDEF_OP_PTR (vdefs, i), &uid)\n-\t  && prepare_operand_for_rename (VDEF_RESULT_PTR (vdefs, i), &dummy))\n+      if (prepare_operand_for_rename (VDEF_OP_PTR (vdefs, i), &uid, true))\n \t{\n-\t  VDEF_RESULT (vdefs, i) = VDEF_OP (vdefs, i);\n+\t  /* If we do not already have an SSA_NAME for our destination,\n+\t     then set the destination to the source.  */\n+\t  if (TREE_CODE (VDEF_RESULT (vdefs, i)) != SSA_NAME)\n+\t    VDEF_RESULT (vdefs, i) = VDEF_OP (vdefs, i);\n \n \t  set_livein_block (VDEF_OP (vdefs, i), bb);\n \t  set_def_block (VDEF_RESULT (vdefs, i), bb);\n@@ -274,7 +274,7 @@ mark_def_sites (struct dom_walk_data *walk_data,\n     {\n       tree *def_p = DEF_OP_PTR (defs, i);\n \n-      if (prepare_operand_for_rename (def_p, &uid))\n+      if (prepare_operand_for_rename (def_p, &uid, false))\n \t{\n \t  set_def_block (*def_p, bb);\n \t  SET_BIT (kills, uid);\n@@ -289,8 +289,12 @@ static void\n set_def_block (tree var, basic_block bb)\n {\n   struct def_blocks_d *db_p;\n-  enum need_phi_state state = var_ann (var)->need_phi_state;\n+  enum need_phi_state state;\n+\n+  if (TREE_CODE (var) == SSA_NAME)\n+    var = SSA_NAME_VAR (var);\n \n+  state = var_ann (var)->need_phi_state;\n   db_p = get_def_blocks_for (var);\n \n   /* Set the bit corresponding to the block where VAR is defined.  */\n@@ -348,12 +352,19 @@ set_livein_block (tree var, basic_block bb)\n }\n \n \n-/* If the operand pointed by OP_P needs to be renamed, strip away SSA_NAME\n-   wrappers (if needed) and return true.  The unique ID for the operand's\n-   variable will be stored in *UID_P.  */\n+/* If the operand pointed to by OP_P needs to be renamed, then\n+\n+     1. If OP_P is used (rather than set), then strip away any SSA_NAME\n+        wrapping the operand.\n+\n+     2. Set *UID_P to the underlying variable's uid.\n+\n+     3. Return true.\n+\n+   Otherwise return false.  */\n \n static bool\n-prepare_operand_for_rename (tree *op_p, size_t *uid_p)\n+prepare_operand_for_rename (tree *op_p, size_t *uid_p, bool is_use)\n {\n   tree var = (TREE_CODE (*op_p) != SSA_NAME) ? *op_p : SSA_NAME_VAR (*op_p);\n   *uid_p = var_ann (var)->uid;\n@@ -362,15 +373,14 @@ prepare_operand_for_rename (tree *op_p, size_t *uid_p)\n   if (vars_to_rename && !bitmap_bit_p (vars_to_rename, *uid_p))\n     return false;\n \n-  /* The variable needs to be renamed.  If it already had an\n-     SSA_NAME, strip it off.  This way, the SSA rename pass\n-     doesn't need to deal with existing SSA names.  */\n-  if (TREE_CODE (*op_p) == SSA_NAME)\n-    {\n-      if (default_def (SSA_NAME_VAR (*op_p)) != *op_p)\n-\trelease_ssa_name (*op_p);\n-      *op_p = var;\n-    }\n+  /* The variable needs to be renamed.  If this is a use which already\n+     has an SSA_NAME, then strip it off.\n+\n+     By not throwing away SSA_NAMEs on assignments, we avoid a lot of \n+     useless churn of SSA_NAMEs without having to overly complicate the\n+     renamer.  */\n+  if (TREE_CODE (*op_p) == SSA_NAME && is_use)\n+    *op_p = var;\n \n   return true;\n }"}]}