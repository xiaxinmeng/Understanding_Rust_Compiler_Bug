{"sha": "615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE1Y2JkOTViZDczZDM1YmRmNDE0NzVmNjAyNDNmOWQ5ZmVmYzVmNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-07-26T10:42:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-07-26T10:42:13Z"}, "message": "[multiple changes]\n\n2004-07-26  Arnaud Charlet  <charlet@act-europe.fr>\n\n\t* sem_util.adb (Requires_Transient_Scope): Temporarily disable\n\toptimization, not supported by the tree-ssa back-end.\n\n2004-07-26  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* s-mastop-irix.adb: Update comments.\n\n\t* a-except.adb (Exception_Information): Raise Constraint_Error if\n\texception Id is Null_Id.\n\tThis is required behavior, which is more reliably and clearly checked\n\tat the top level interface level.\n\n2004-07-26  Javier Miranda  <miranda@gnat.com>\n\n\t* exp_aggr.adb (Build_Array_Aggr_Code): Do not build the initialization\n\tcall if a component has no default_expression and the box is used.\n\n\t* sem_aggr.adb (Resolve_Array_Aggregate): If a component has no\n\tdefault_expression and you use box, it behaves as if you had declared a\n\tstand-alone object.\n\t(Resolve_Record_Aggregate): If a component has no default_expression and\n\tyou use box, it behaves as if you had declared a stand-alone object.\n\n\t* sem_ch10.adb (Install_Siblings): Do not make visible the private\n\tentities of private-with siblings.\n\n2004-07-26  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_ch3.adb (Build_Underlying_Full_View): If this is the full view\n\tfor a component of an itype, set the parent pointer for analysis,\n\tthere is no list in which to insert it.\n\n\t* sem_res.adb (Resolve): Call Rewrite_Renamed_Operator only for\n\tbona-fide renamings, not for inherited operations.\n\n\t* exp_ch4.adb (Expand_Allocator_Expression): If the allocator is an\n\tactual for a formal that is an access parameter, create local\n\tfinalization list even if the expression is not an aggregate.\n\n2004-07-26  Ed Schonberg  <schonberg@gnat.com>\n\n\tPR ada/16213\n\t* sem_ch8.adb (Attribute_Renaming, Check_Library_Level_Renaming):\n\tDiagnose properly illegal subprogram renamings that are library units.\n\n2004-07-26  Ed Schonberg  <schonberg@gnat.com>\n\n\tPR ada/15588\n\t* sem_util.adb (Is_OK_Variable_For_Out_Formal): If actual is a type\n\tconversion rewritten as an unchecked conversion, check that original\n\texpression is a variable.\n\n\t* exp_ch4.adb (Expand_N_Type_Conversion): If rewriting as an\n\tunchecked_conversion, create new node rather than rewriting in place,\n\tto preserve original construct.\n\n2004-07-26  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* gigi.h (gnat_expand_body): Deleted.\n\n\t* Make-lang.in: (trans.o): Depends on function.h.\n\n\t* misc.c: (gnat_expand_body): Moved to here.\n\n\t* trans.c (gnat_expand_body_1): Deleted.\n\t(gnat_expand_body): Moved from here.\n\t(gnat_to_gnu): N_Implicit_Label_Declaration forces being in elab proc.\n\t(add_stmt): Check for marked visited with global_bindings_p.\n\t(gnat_gimplify_expr, case COMPONENT_REF): New case.\n\t(gnat_gimplify_expr, case NULL_EXPR): Set TREE_NO_WARNING for temp.\n\n\t* utils2.c (build_binary_op, case MODIFY_EXPR): Put LHS in a\n\tVIEW_CONVERT_EXPR if not operation type.\n\n\t* utils.c (update_pointer_to): Set DECL_ORIGINAL_FIELD for\n\tfat pointer.\n\n\t* decl.c, cuintp.c, gigi.h, misc.c, trans.c, utils.c, utils2.c: Minor\n\tchanges: reformatting of negation operators, removing unneeded\n\tinequality comparison with zero, converting equality comparisons with\n\tzero to negations, changing int/0/1 to bool/false/true, replace calls\n\tto gigi_abort with abort, and various other similar changes.\n\n2004-07-26  Vincent Celier  <celier@gnat.com>\n\n\t* gnatcmd.adb (GNATCmd): Add processing for new built-in command\n\t\"setup\".\n\n\t* make.adb (Gnatmake): Fail when a library is not present and there is\n\tno object directory.\n\n\t* mlib-prj.adb (Check_Library): No need to check if the library needs\n\tto be rebuilt if there is no object directory, hence no object files\n\tto build the library.\n\n\t* opt.ads (Setup_Projects): New Boolean flag.\n\n\t* prj-nmsc.adb (Locate_Directory): New parameter Project, Kind and\n\tLocation.\n\tCreate directory when Kind /= \"\" and in \"gnat setup\". Report error if\n\tdirectory cannot be created.\n\t(Ada_Check): Create library interface copy dir if it does not exist\n\tand we are in \"gnat setup\".\n\t(Find_Sources): No error if in \"gnat setup\" and no Ada sources were\n\tfound.\n\t(Language_Independent_Check): Create object directory, exec directory\n\tand/or library directory if they do not exist and we are in\n\t\"gnat setup\".\n\n\t* vms_conv.ads: (Command_Type): New command Setup.\n\n\t* vms_conv.adb (Initialize): Add Setup component of Cammand_List.\n\n\t* vms_data.ads: Add qualifiers/switches for new built-in command\n\t\"setup\".\n\nFrom-SVN: r85188", "tree": {"sha": "70c781e7f9e0b3989847ce98520d13a3cf176d39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70c781e7f9e0b3989847ce98520d13a3cf176d39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/comments", "author": null, "committer": null, "parents": [{"sha": "63d1c7b35fe104326f278f45daf20743853920bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d1c7b35fe104326f278f45daf20743853920bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63d1c7b35fe104326f278f45daf20743853920bb"}], "stats": {"total": 3539, "additions": 1959, "deletions": 1580}, "files": [{"sha": "88eb443d089684b020795393f55058afe64eb49a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -1,3 +1,121 @@\n+2004-07-26  Arnaud Charlet  <charlet@act-europe.fr>\n+\n+\t* sem_util.adb (Requires_Transient_Scope): Temporarily disable\n+\toptimization, not supported by the tree-ssa back-end.\n+\n+2004-07-26  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* s-mastop-irix.adb: Update comments.\n+\n+\t* a-except.adb (Exception_Information): Raise Constraint_Error if\n+\texception Id is Null_Id.\n+\tThis is required behavior, which is more reliably and clearly checked\n+\tat the top level interface level.\n+\n+2004-07-26  Javier Miranda  <miranda@gnat.com>\n+\n+\t* exp_aggr.adb (Build_Array_Aggr_Code): Do not build the initialization\n+\tcall if a component has no default_expression and the box is used.\n+\n+\t* sem_aggr.adb (Resolve_Array_Aggregate): If a component has no\n+\tdefault_expression and you use box, it behaves as if you had declared a\n+\tstand-alone object.\n+\t(Resolve_Record_Aggregate): If a component has no default_expression and\n+\tyou use box, it behaves as if you had declared a stand-alone object.\n+\n+\t* sem_ch10.adb (Install_Siblings): Do not make visible the private\n+\tentities of private-with siblings.\n+\n+2004-07-26  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch3.adb (Build_Underlying_Full_View): If this is the full view\n+\tfor a component of an itype, set the parent pointer for analysis,\n+\tthere is no list in which to insert it.\n+\n+\t* sem_res.adb (Resolve): Call Rewrite_Renamed_Operator only for\n+\tbona-fide renamings, not for inherited operations.\n+\n+\t* exp_ch4.adb (Expand_Allocator_Expression): If the allocator is an\n+\tactual for a formal that is an access parameter, create local\n+\tfinalization list even if the expression is not an aggregate.\n+\n+2004-07-26  Ed Schonberg  <schonberg@gnat.com>\n+\n+\tPR ada/16213\n+\t* sem_ch8.adb (Attribute_Renaming, Check_Library_Level_Renaming):\n+\tDiagnose properly illegal subprogram renamings that are library units.\n+\n+2004-07-26  Ed Schonberg  <schonberg@gnat.com>\n+\n+\tPR ada/15588\n+\t* sem_util.adb (Is_OK_Variable_For_Out_Formal): If actual is a type\n+\tconversion rewritten as an unchecked conversion, check that original\n+\texpression is a variable.\n+\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): If rewriting as an\n+\tunchecked_conversion, create new node rather than rewriting in place,\n+\tto preserve original construct.\n+\n+2004-07-26  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* gigi.h (gnat_expand_body): Deleted.\n+\n+\t* Make-lang.in: (trans.o): Depends on function.h.\n+\n+\t* misc.c: (gnat_expand_body): Moved to here.\n+\n+\t* trans.c (gnat_expand_body_1): Deleted.\n+\t(gnat_expand_body): Moved from here.\n+\t(gnat_to_gnu): N_Implicit_Label_Declaration forces being in elab proc.\n+\t(add_stmt): Check for marked visited with global_bindings_p.\n+\t(gnat_gimplify_expr, case COMPONENT_REF): New case.\n+\t(gnat_gimplify_expr, case NULL_EXPR): Set TREE_NO_WARNING for temp.\n+\n+\t* utils2.c (build_binary_op, case MODIFY_EXPR): Put LHS in a\n+\tVIEW_CONVERT_EXPR if not operation type.\n+\n+\t* utils.c (update_pointer_to): Set DECL_ORIGINAL_FIELD for\n+\tfat pointer.\n+\n+\t* decl.c, cuintp.c, gigi.h, misc.c, trans.c, utils.c, utils2.c: Minor\n+\tchanges: reformatting of negation operators, removing unneeded\n+\tinequality comparison with zero, converting equality comparisons with\n+\tzero to negations, changing int/0/1 to bool/false/true, replace calls\n+\tto gigi_abort with abort, and various other similar changes.\n+\n+2004-07-26  Vincent Celier  <celier@gnat.com>\n+\n+\t* gnatcmd.adb (GNATCmd): Add processing for new built-in command\n+\t\"setup\".\n+\n+\t* make.adb (Gnatmake): Fail when a library is not present and there is\n+\tno object directory.\n+\n+\t* mlib-prj.adb (Check_Library): No need to check if the library needs\n+\tto be rebuilt if there is no object directory, hence no object files\n+\tto build the library.\n+\n+\t* opt.ads (Setup_Projects): New Boolean flag.\n+\n+\t* prj-nmsc.adb (Locate_Directory): New parameter Project, Kind and\n+\tLocation.\n+\tCreate directory when Kind /= \"\" and in \"gnat setup\". Report error if\n+\tdirectory cannot be created.\n+\t(Ada_Check): Create library interface copy dir if it does not exist\n+\tand we are in \"gnat setup\".\n+\t(Find_Sources): No error if in \"gnat setup\" and no Ada sources were\n+\tfound.\n+\t(Language_Independent_Check): Create object directory, exec directory\n+\tand/or library directory if they do not exist and we are in\n+\t\"gnat setup\".\n+\n+\t* vms_conv.ads: (Command_Type): New command Setup.\n+\n+\t* vms_conv.adb (Initialize): Add Setup component of Cammand_List.\n+\n+\t* vms_data.ads: Add qualifiers/switches for new built-in command\n+\t\"setup\".\n+\n 2004-07-25  Richard Henderson  <rth@redhat.com>\n \n \t* utils.c (create_subprog_decl): Set DECL_ARTIFICIAL and"}, {"sha": "2d303313302172683bfb81879dabee07e3643a93", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -1089,10 +1089,10 @@ ada/targtyps.o : ada/targtyps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    ada/urealp.h ada/fe.h $(ADA_TREE_H) ada/gigi.h\n \n ada/trans.o : ada/trans.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) $(RTL_H) flags.h ada/ada.h except.h ada/types.h ada/atree.h \\\n-   ada/nlists.h ada/elists.h ada/uintp.h ada/sinfo.h ada/einfo.h ada/namet.h \\\n-   ada/snames.h ada/stringt.h ada/urealp.h ada/fe.h $(ADA_TREE_H) ada/gigi.h \\\n-   gt-ada-trans.h\n+   $(TREE_H) $(RTL_H) flags.h function.h ada/ada.h except.h ada/types.h \\\n+   ada/atree.h ada/nlists.h ada/elists.h ada/uintp.h ada/sinfo.h ada/einfo.h \\\n+   ada/namet.h ada/snames.h ada/stringt.h ada/urealp.h ada/fe.h $(ADA_TREE_H) \\\n+   ada/gigi.h gt-ada-trans.h\n \n ada/utils.o : ada/utils.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) flags.h expr.h convert.h defaults.h ada/ada.h ada/types.h \\"}, {"sha": "3f574085a4849160e3ca668a424bb34a29c2c397", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -640,8 +640,14 @@ package body Ada.Exceptions is\n    -- Exception_Information --\n    ---------------------------\n \n-   function Exception_Information (X : Exception_Occurrence) return String\n-     renames Exception_Data.Exception_Information;\n+   function Exception_Information (X : Exception_Occurrence) return String is\n+   begin\n+      if X.Id = Null_Id then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Exception_Data.Exception_Information (X);\n+   end Exception_Information;\n \n    -----------------------\n    -- Exception_Message --"}, {"sha": "3b8495c7e773959f27e4aa36dbb18f8765036c77", "filename": "gcc/ada/cuintp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcuintp.c?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -77,7 +77,7 @@ UI_To_gnu (Uint Input, tree type)\n       tree gnu_base = convert (comp_type, build_int_2 (Base, 0));\n \n       if (Length <= 0)\n-\tgigi_abort (601);\n+\tabort ();\n \n       gnu_ret = convert (comp_type, build_int_2 (First, First < 0 ? -1 : 0));\n       if (First < 0)"}, {"sha": "480ebad8ca72eecc8f400efd5c51fd48ff2d0152", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 664, "deletions": 691, "changes": 1355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4"}, {"sha": "7bc0a762f5237e02c52e17644dd1456bc2910ff4", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -34,6 +34,7 @@ with Exp_Util; use Exp_Util;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n+with Exp_Tss;  use Exp_Tss;\n with Freeze;   use Freeze;\n with Hostparm; use Hostparm;\n with Itypes;   use Itypes;\n@@ -823,14 +824,17 @@ package body Exp_Aggr is\n \n          if not Present (Expr) then\n \n-            Append_List_To (L,\n+            if Present (Base_Init_Proc (Etype (Ctype)))\n+              or else Has_Task (Base_Type (Ctype))\n+            then\n+               Append_List_To (L,\n                  Build_Initialization_Call (Loc,\n                    Id_Ref            => Indexed_Comp,\n                    Typ               => Ctype,\n                    With_Default_Init => True));\n+            end if;\n \n          else\n-\n             --  Now generate the assignment with no associated controlled\n             --  actions since the target of the assignment may not have\n             --  been initialized, it is not possible to Finalize it as"}, {"sha": "d1a7bbcd803d4d05525cb1197d27ae989afe7e55", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -54,7 +54,6 @@ with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n-with Sinfo.CN; use Sinfo.CN;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Targparm; use Targparm;\n@@ -521,7 +520,17 @@ package body Exp_Ch4 is\n                --  Normal case, not a secondary stack allocation\n \n                else\n-                  Flist := Find_Final_List (PtrT);\n+                  if Controlled_Type (T)\n+                    and then Ekind (PtrT) = E_Anonymous_Access_Type\n+                  then\n+                     --  Create local finalization list for access parameter.\n+\n+                     Flist :=\n+                       Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n+                  else\n+                     Flist := Find_Final_List (PtrT);\n+                  end if;\n+\n                   Attach :=  Make_Integer_Literal (Loc, 2);\n                end if;\n \n@@ -6108,8 +6117,16 @@ package body Exp_Ch4 is\n                    Condition => Cond,\n                    Reason    => CE_Tag_Check_Failed));\n \n-               Change_Conversion_To_Unchecked (N);\n-               Analyze_And_Resolve (N, Target_Type);\n+               declare\n+                  Conv : Node_Id;\n+               begin\n+                  Conv :=\n+                    Make_Unchecked_Type_Conversion (Loc,\n+                      Subtype_Mark => New_Occurrence_Of (Target_Type, Loc),\n+                      Expression => Relocate_Node (Expression (N)));\n+                  Rewrite (N, Conv);\n+                  Analyze_And_Resolve (N, Target_Type);\n+               end;\n             end if;\n          end;\n "}, {"sha": "8d0917435d61d84e958663092b2d6e039bddbcfd", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 32, "deletions": 64, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -46,11 +46,11 @@ extern tree emit_stack_check (tree);\n \n /* GNU_TYPE is a type. Determine if it should be passed by reference by\n    default.  */\n-extern int default_pass_by_ref (tree);\n+extern bool default_pass_by_ref (tree);\n \n /* GNU_TYPE is the type of a subprogram parameter.  Determine from the type\n    if it should be passed by reference.  */\n-extern int must_pass_by_ref (tree);\n+extern bool must_pass_by_ref (tree);\n \n /* Elaboration routines for the front end.  */\n extern void elab_all_gnat (void);\n@@ -145,7 +145,7 @@ extern tree create_concat_name (Entity_Id, const char *);\n /* If true, then gigi is being called on an analyzed but unexpanded tree, and\n    the only purpose of the call is to properly annotate types with\n    representation information.  */\n-extern int type_annotate_only;\n+extern bool type_annotate_only;\n \n /* Current file name without path */\n extern const char *ref_filename;\n@@ -169,9 +169,6 @@ extern void gnat_expand_stmt (tree);\n \n extern int gnat_gimplify_expr (tree *, tree *, tree *);\n \n-/* Expand the body of GNU_DECL, which is not a nested function.  */\n-extern void gnat_expand_body (tree);\n-\n /* Do the processing for the declaration of a GNAT_ENTITY, a type.  If\n    a separate Freeze node exists, delay the bulk of the processing.  Otherwise\n    make a GCC type for GNAT_ENTITY and set up the correspondance.  */\n@@ -215,12 +212,6 @@ extern void set_second_error_entity (Entity_Id);\n /* Protect EXP from multiple evaluation.  This may make a SAVE_EXPR.  */\n extern tree protect_multiple_eval (tree);\n \n-/* Signal abort, with \"Gigi abort\" as the error label, and error_gnat_node\n-   as the relevant node that provides the location info for the error.\n-   The single parameter CODE is an integer code that is included in the\n-   additional error message generated. */\n-extern void gigi_abort (int) ATTRIBUTE_NORETURN;\n-\n /* Initialize the table that maps GNAT codes to GCC codes for simple\n    binary and unary operations.  */\n extern void init_code_table (void);\n@@ -232,8 +223,7 @@ extern Node_Id error_gnat_node;\n /* This is equivalent to stabilize_reference in GCC's tree.c, but we know\n    how to handle our new nodes and we take an extra argument that says\n    whether to force evaluation of everything.  */\n-\n-extern tree gnat_stabilize_reference (tree, int);\n+extern tree gnat_stabilize_reference (tree, bool);\n \n /* Highest number in the front-end node table.  */\n extern int max_gnat_nodes;\n@@ -427,37 +417,37 @@ extern tree convert (tree, tree);\n    GNAT_ENTITY. Such gnu tree node is always an ..._DECL node.\n    If NO_CHECK is nonzero, the latter check is suppressed.\n    If GNU_DECL is zero, a previous association is to be reset.  */\n-extern void save_gnu_tree (Entity_Id, tree, int);\n+extern void save_gnu_tree (Entity_Id, tree, bool);\n \n /* GNAT_ENTITY is a GNAT tree node for a defining identifier.\n    Return the ..._DECL node that was associated with it.  If there is no tree\n    node associated with GNAT_ENTITY, abort.  */\n extern tree get_gnu_tree (Entity_Id);\n \n /* Return nonzero if a GCC tree has been associated with GNAT_ENTITY.  */\n-extern int present_gnu_tree (Entity_Id);\n+extern bool present_gnu_tree (Entity_Id);\n \n /* Initialize tables for above routines.  */\n extern void init_gnat_to_gnu (void);\n \n /* Given a record type (RECORD_TYPE) and a chain of FIELD_DECL\n    nodes (FIELDLIST), finish constructing the record or union type.\n-   If HAS_REP is nonzero, this record has a rep clause; don't call\n+   If HAS_REP is true, this record has a rep clause; don't call\n    layout_type but merely set the size and alignment ourselves.\n-   If DEFER_DEBUG is nonzero, do not call the debugging routines\n+   If DEFER_DEBUG is true, do not call the debugging routines\n    on this type; it will be done later. */\n-extern void finish_record_type (tree, tree, int, int);\n+extern void finish_record_type (tree, tree, bool, bool);\n \n /* Returns a FUNCTION_TYPE node. RETURN_TYPE is the type returned by the\n    subprogram. If it is void_type_node, then we are dealing with a procedure,\n    otherwise we are dealing with a function. PARAM_DECL_LIST is a list of\n    PARM_DECL nodes that are the subprogram arguments.  CICO_LIST is the\n    copy-in/copy-out list to be stored into TYPE_CI_CO_LIST.\n-   RETURNS_UNCONSTRAINED is nonzero if the function returns an unconstrained\n-   object.  RETURNS_BY_REF is nonzero if the function returns by reference.\n-   RETURNS_WITH_DSP is nonzero if the function is to return with a\n+   RETURNS_UNCONSTRAINED is true if the function returns an unconstrained\n+   object.  RETURNS_BY_REF is true if the function returns by reference.\n+   RETURNS_WITH_DSP is true if the function is to return with a\n    depressed stack pointer.  */\n-extern tree create_subprog_type (tree, tree, tree, int, int, int);\n+extern tree create_subprog_type (tree, tree, tree, bool, bool, bool);\n \n /* Return a copy of TYPE, but safe to modify in any way.  */\n extern tree copy_type (tree);\n@@ -468,58 +458,36 @@ extern tree create_index_type (tree, tree, tree);\n \n /* Return a TYPE_DECL node. TYPE_NAME gives the name of the type (a character\n    string) and TYPE is a ..._TYPE node giving its data type.\n-   ARTIFICIAL_P is nonzero if this is a declaration that was generated\n-   by the compiler.  DEBUG_INFO_P is nonzero if we need to write debugging\n+   ARTIFICIAL_P is true if this is a declaration that was generated\n+   by the compiler.  DEBUG_INFO_P is true if we need to write debugging\n    information about this type.  GNAT_NODE is used for the position of\n    the decl.  */\n-extern tree create_type_decl (tree, tree, struct attrib *, int, int, Node_Id);\n+extern tree create_type_decl (tree, tree, struct attrib *, bool, bool,\n+\t\t\t      Node_Id);\n \n /* Returns a GCC VAR_DECL node. VAR_NAME gives the name of the variable.\n    ASM_NAME is its assembler name (if provided).  TYPE is\n    its data type (a GCC ..._TYPE node).  VAR_INIT is the GCC tree for an\n    optional initial expression; NULL_TREE if none.\n \n-   CONST_FLAG is nonzero if this variable is constant.\n+   CONST_FLAG is true if this variable is constant.\n \n-   PUBLIC_FLAG is nonzero if this definition is to be made visible outside of\n+   PUBLIC_FLAG is true if this definition is to be made visible outside of\n    the current compilation unit. This flag should be set when processing the\n    variable definitions in a package specification.  EXTERN_FLAG is nonzero\n    when processing an external variable declaration (as opposed to a\n    definition: no storage is to be allocated for the variable here).\n+\n    STATIC_FLAG is only relevant when not at top level.  In that case\n    it indicates whether to always allocate storage to the variable.\n \n    GNAT_NODE is used for the position of the decl.  */\n-extern tree create_var_decl (tree, tree, tree, tree, int, int, int, int,\n+extern tree create_var_decl (tree, tree, tree, tree, bool, bool, bool, bool,\n \t\t\t     struct attrib *, Node_Id);\n \n /* Given a DECL and ATTR_LIST, apply the listed attributes.  */\n extern void process_attributes (tree, struct attrib *);\n \n-/* Obtain any pending elaborations and clear the old list.  */\n-extern tree get_pending_elaborations (void);\n-\n-/* Return nonzero if there are pending elaborations.  */\n-extern int pending_elaborations_p (void);\n-\n-/* Save a copy of the current pending elaboration list and make a new\n-   one.  */\n-extern void push_pending_elaborations (void);\n-\n-/* Pop the stack of pending elaborations.  */\n-extern void pop_pending_elaborations (void);\n-\n-/* Return the current position in pending_elaborations so we can insert\n-   elaborations after that point.  */\n-extern tree get_elaboration_location (void);\n-\n-/* Insert the current elaborations after ELAB, which is in some elaboration\n-   list.  */\n-extern void insert_elaboration_list (tree);\n-\n-/* Add some pending elaborations to the current list.  */\n-extern void add_pending_elaborations (tree, tree);\n-\n /* Returns a FIELD_DECL node. FIELD_NAME the field name, FIELD_TYPE is its\n    type, and RECORD_TYPE is the type of the parent.  PACKED is nonzero if\n    this field is in a record type with a \"pragma pack\".  If SIZE is nonzero\n@@ -529,19 +497,19 @@ extern void add_pending_elaborations (tree, tree);\n extern tree create_field_decl (tree, tree, tree, int, tree, tree, int);\n \n /* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n-   PARAM_TYPE is its type.  READONLY is nonzero if the parameter is\n+   PARAM_TYPE is its type.  READONLY is true if the parameter is\n    readonly (either an IN parameter or an address of a pass-by-ref\n    parameter). */\n-extern tree create_param_decl (tree, tree, int);\n+extern tree create_param_decl (tree, tree, bool);\n \n /* Returns a FUNCTION_DECL node.  SUBPROG_NAME is the name of the subprogram,\n    ASM_NAME is its assembler name, SUBPROG_TYPE is its type (a FUNCTION_TYPE\n    node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n    PARM_DECL nodes chained through the TREE_CHAIN field).\n \n    INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, and ATTR_LIST are used to set the\n-   appropriate fields in the FUNCTION_DECL.  GNAT_NODE gives the location.  */ \n-extern tree create_subprog_decl (tree, tree, tree, tree, int, int, int,\n+   appropriate fields in the FUNCTION_DECL.  GNAT_NODE gives the location.  */\n+extern tree create_subprog_decl (tree, tree, tree, tree, bool, bool, bool,\n \t\t\t\t struct attrib *, Node_Id);\n \n /* Returns a LABEL_DECL node for LABEL_NAME.  */\n@@ -586,23 +554,23 @@ extern void update_pointer_to (tree, tree);\n \n /* EXP is an expression for the size of an object.  If this size contains\n    discriminant references, replace them with the maximum (if MAX_P) or\n-   minimum (if ! MAX_P) possible value of the discriminant.  */\n-extern tree max_size (tree, int);\n+   minimum (if !MAX_P) possible value of the discriminant.  */\n+extern tree max_size (tree, bool);\n \n /* Remove all conversions that are done in EXP.  This includes converting\n    from a padded type or to a left-justified modular type.  If TRUE_ADDRESS\n-   is nonzero, always return the address of the containing object even if\n+   is true, always return the address of the containing object even if\n    the address is not bit-aligned.  */\n-extern tree remove_conversions (tree, int);\n+extern tree remove_conversions (tree, bool);\n \n /* If EXP's type is an UNCONSTRAINED_ARRAY_TYPE, return an expression that\n    refers to the underlying array.  If its type has TYPE_CONTAINS_TEMPLATE_P,\n    likewise return an expression pointing to the underlying array.  */\n extern tree maybe_unconstrained_array (tree);\n \n /* Return an expression that does an unchecked converstion of EXPR to TYPE.\n-   If NOTRUNC_P is set, truncation operations should be suppressed.  */\n-extern tree unchecked_convert (tree, tree, int);\n+   If NOTRUNC_P is true, truncation operations should be suppressed.  */\n+extern tree unchecked_convert (tree, tree, bool);\n \n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n    operation.\n@@ -664,7 +632,7 @@ extern tree gnat_build_constructor (tree, tree);\n /* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n    an IDENTIFIER_NODE giving the name of the field, FIELD, a FIELD_DECL,\n    for the field, or both.  Don't fold the result if NO_FOLD_P.  */\n-extern tree build_component_ref (tree, tree, tree, int);\n+extern tree build_component_ref (tree, tree, tree, bool);\n \n /* Build a GCC tree to call an allocation or deallocation function.\n    If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,"}, {"sha": "91b582a7331872fcc2f6afe526ec54a8932bf169", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -1137,6 +1137,148 @@ begin\n       Exec_Path : String_Access;\n \n    begin\n+      --  First deal with built-in command(s)\n+\n+      if The_Command = Setup then\n+         Process_Setup :\n+         declare\n+            Arg_Num : Positive := 1;\n+            Argv    : String_Access;\n+\n+         begin\n+            while Arg_Num <= Last_Switches.Last loop\n+               Argv := Last_Switches.Table (Arg_Num);\n+\n+               if Argv (Argv'First) /= '-' then\n+                  Fail (\"invalid parameter \"\"\", Argv.all, \"\"\"\");\n+\n+               else\n+                  if Argv'Length = 1 then\n+                     Fail\n+                       (\"switch character cannot be followed by a blank\");\n+                  end if;\n+\n+                  --  -vPx  Specify verbosity while parsing project files\n+\n+                  if Argv'Length = 4\n+                    and then Argv (Argv'First + 1 .. Argv'First + 2) = \"vP\"\n+                  then\n+                     case Argv (Argv'Last) is\n+                        when '0' =>\n+                           Current_Verbosity := Prj.Default;\n+                        when '1' =>\n+                           Current_Verbosity := Prj.Medium;\n+                        when '2' =>\n+                           Current_Verbosity := Prj.High;\n+                        when others =>\n+                           Fail (\"Invalid switch: \", Argv.all);\n+                     end case;\n+\n+                  --  -Pproject_file  Specify project file to be used\n+\n+                  elsif Argv (Argv'First + 1) = 'P' then\n+\n+                     --  Only one -P switch can be used\n+\n+                     if Project_File /= null then\n+                        Fail\n+                          (Argv.all,\n+                           \": second project file forbidden (first is \"\"\",\n+                           Project_File.all & \"\"\")\");\n+\n+                     elsif Argv'Length = 2 then\n+\n+                        --  There is space between -P and the project file\n+                        --  name. -P cannot be the last option.\n+\n+                        if Arg_Num = Last_Switches.Last then\n+                           Fail (\"project file name missing after -P\");\n+\n+                        else\n+                           Arg_Num := Arg_Num + 1;\n+                           Argv := Last_Switches.Table (Arg_Num);\n+\n+                           --  After -P, there must be a project file name,\n+                           --  not another switch.\n+\n+                           if Argv (Argv'First) = '-' then\n+                              Fail (\"project file name missing after -P\");\n+\n+                           else\n+                              Project_File := new String'(Argv.all);\n+                           end if;\n+                        end if;\n+\n+                     else\n+                        --  No space between -P and project file name\n+\n+                        Project_File :=\n+                          new String'(Argv (Argv'First + 2 .. Argv'Last));\n+                     end if;\n+\n+                  --  -Xexternal=value Specify an external reference to be\n+                  --                   used in project files\n+\n+                  elsif Argv'Length >= 5\n+                    and then Argv (Argv'First + 1) = 'X'\n+                  then\n+                     declare\n+                        Equal_Pos : constant Natural :=\n+                          Index ('=', Argv (Argv'First + 2 .. Argv'Last));\n+                     begin\n+                        if Equal_Pos >= Argv'First + 3 and then\n+                          Equal_Pos /= Argv'Last then\n+                           Add\n+                             (External_Name =>\n+                              Argv (Argv'First + 2 .. Equal_Pos - 1),\n+                              Value     => Argv (Equal_Pos + 1 .. Argv'Last));\n+                        else\n+                           Fail\n+                             (Argv.all,\n+                              \" is not a valid external assignment.\");\n+                        end if;\n+                     end;\n+\n+                  elsif Argv.all = \"-v\" then\n+                     Verbose_Mode := True;\n+\n+                  elsif Argv.all = \"-q\" then\n+                     Quiet_Output := True;\n+\n+                  else\n+                     Fail (\"invalid parameter \"\"\", Argv.all, \"\"\"\");\n+                  end if;\n+               end if;\n+\n+               Arg_Num := Arg_Num + 1;\n+            end loop;\n+\n+            if Project_File = null then\n+               Fail (\"no project file specified\");\n+            end if;\n+\n+            Setup_Projects := True;\n+\n+            Prj.Pars.Set_Verbosity (To => Current_Verbosity);\n+\n+            --  Missing directories are created during processing of the\n+            --  project tree.\n+\n+            Prj.Pars.Parse\n+              (Project           => Project,\n+               Project_File_Name => Project_File.all,\n+               Packages_To_Check => All_Packages);\n+\n+            if Project = Prj.No_Project then\n+               Fail (\"\"\"\", Project_File.all, \"\"\" processing failed\");\n+            end if;\n+\n+            --  Processing is done\n+\n+            return;\n+         end Process_Setup;\n+      end if;\n+\n       --  Locate the executable for the command\n \n       Exec_Path := Locate_Exec_On_Path (Program);"}, {"sha": "8260ebdb3016ff1ba1190c33a2e8cc70e4294152", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -4344,18 +4344,31 @@ package body Make is\n                     not MLib.Tgt.Library_Exists_For (Proj);\n \n                   if Projects.Table (Proj).Need_To_Build_Lib then\n-                     if Verbose_Mode then\n-                        Write_Str\n-                          (\"Library file does not exist for project \"\"\");\n-                        Write_Str\n-                          (Get_Name_String (Projects.Table (Proj).Name));\n-                        Write_Line (\"\"\"\");\n-                     end if;\n+                     --  If there is no object directory, then it will be\n+                     --  impossible to build the library. So, we fail\n+                     --  immediately.\n \n-                     Insert_Project_Sources\n-                       (The_Project  => Proj,\n-                        All_Projects => False,\n-                        Into_Q       => True);\n+                     if Projects.Table (Proj).Object_Directory = No_Name then\n+                        Make_Failed\n+                          (\"no object files to build library for project \"\"\",\n+                           Get_Name_String (Projects.Table (Proj).Name),\n+                           \"\"\"\");\n+                        Projects.Table (Proj).Need_To_Build_Lib := False;\n+\n+                     else\n+                        if Verbose_Mode then\n+                           Write_Str\n+                             (\"Library file does not exist for project \"\"\");\n+                           Write_Str\n+                             (Get_Name_String (Projects.Table (Proj).Name));\n+                           Write_Line (\"\"\"\");\n+                        end if;\n+\n+                        Insert_Project_Sources\n+                          (The_Project  => Proj,\n+                           All_Projects => False,\n+                           Into_Q       => True);\n+                     end if;\n                   end if;\n                end if;\n             end loop;"}, {"sha": "9aef623ed4e43ad8cdf5ffd444d15e88712302bd", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -101,6 +101,7 @@ static int gnat_eh_type_covers\t\t(tree, tree);\n static void gnat_parse_file\t\t(int);\n static rtx gnat_expand_expr\t\t(tree, rtx, enum machine_mode, int,\n \t\t\t\t\t rtx *);\n+static void gnat_expand_body\t\t(tree);\n static void internal_error_function\t(const char *, va_list *);\n static void gnat_adjust_rli\t\t(record_layout_info);\n static tree gnat_type_max_size\t\t(tree);\n@@ -117,54 +118,51 @@ static tree gnat_type_max_size\t\t(tree);\n #define LANG_HOOKS_INIT_OPTIONS\t\tgnat_init_options\n #undef  LANG_HOOKS_HANDLE_OPTION\n #define LANG_HOOKS_HANDLE_OPTION\tgnat_handle_option\n-#undef LANG_HOOKS_POST_OPTIONS\n+#undef  LANG_HOOKS_POST_OPTIONS\n #define LANG_HOOKS_POST_OPTIONS\t\tgnat_post_options\n-#undef LANG_HOOKS_PARSE_FILE\n+#undef  LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE\t\tgnat_parse_file\n-#undef LANG_HOOKS_HONOR_READONLY\n+#undef  LANG_HOOKS_HONOR_READONLY\n #define LANG_HOOKS_HONOR_READONLY\ttrue\n-#undef LANG_HOOKS_HASH_TYPES\n+#undef  LANG_HOOKS_HASH_TYPES\n #define LANG_HOOKS_HASH_TYPES\t\tfalse\n-#undef LANG_HOOKS_GETDECLS\n+#undef  LANG_HOOKS_GETDECLS\n #define LANG_HOOKS_GETDECLS\t\tlhd_return_null_tree_v\n-#undef LANG_HOOKS_PUSHDECL\n+#undef  LANG_HOOKS_PUSHDECL\n #define LANG_HOOKS_PUSHDECL\t\tlhd_return_tree\n-#undef LANG_HOOKS_FINISH_INCOMPLETE_DECL\n+#undef  LANG_HOOKS_FINISH_INCOMPLETE_DECL\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL gnat_finish_incomplete_decl\n-#undef LANG_HOOKS_GET_ALIAS_SET\n+#undef  LANG_HOOKS_GET_ALIAS_SET\n #define LANG_HOOKS_GET_ALIAS_SET\tgnat_get_alias_set\n-#undef LANG_HOOKS_EXPAND_EXPR\n+#undef  LANG_HOOKS_EXPAND_EXPR\n #define LANG_HOOKS_EXPAND_EXPR\t\tgnat_expand_expr\n-#undef LANG_HOOKS_MARK_ADDRESSABLE\n+#undef  LANG_HOOKS_MARK_ADDRESSABLE\n #define LANG_HOOKS_MARK_ADDRESSABLE\tgnat_mark_addressable\n-#undef LANG_HOOKS_TRUTHVALUE_CONVERSION\n+#undef  LANG_HOOKS_TRUTHVALUE_CONVERSION\n #define LANG_HOOKS_TRUTHVALUE_CONVERSION gnat_truthvalue_conversion\n-#undef LANG_HOOKS_PRINT_DECL\n+#undef  LANG_HOOKS_PRINT_DECL\n #define LANG_HOOKS_PRINT_DECL\t\tgnat_print_decl\n-#undef LANG_HOOKS_PRINT_TYPE\n+#undef  LANG_HOOKS_PRINT_TYPE\n #define LANG_HOOKS_PRINT_TYPE\t\tgnat_print_type\n-#undef LANG_HOOKS_TYPES_COMPATIBLE_P\n+#undef  LANG_HOOKS_TYPES_COMPATIBLE_P\n #define LANG_HOOKS_TYPES_COMPATIBLE_P\tgnat_types_compatible_p\n-#undef LANG_HOOKS_TYPE_MAX_SIZE\n+#undef  LANG_HOOKS_TYPE_MAX_SIZE\n #define LANG_HOOKS_TYPE_MAX_SIZE\tgnat_type_max_size\n-#undef LANG_HOOKS_DECL_PRINTABLE_NAME\n+#undef  LANG_HOOKS_DECL_PRINTABLE_NAME\n #define LANG_HOOKS_DECL_PRINTABLE_NAME\tgnat_printable_name\n-#undef LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n+#undef  LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n #define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION gnat_expand_body\n-#undef LANG_HOOKS_RTL_EXPAND_STMT\n-#define LANG_HOOKS_RTL_EXPAND_STMT gnat_expand_stmt\n-#undef LANG_HOOKS_GIMPLIFY_EXPR\n-#define LANG_HOOKS_GIMPLIFY_EXPR gnat_gimplify_expr\n-\n-#undef LANG_HOOKS_TYPE_FOR_MODE\n+#undef  LANG_HOOKS_GIMPLIFY_EXPR\n+#define LANG_HOOKS_GIMPLIFY_EXPR\tgnat_gimplify_expr\n+#undef  LANG_HOOKS_TYPE_FOR_MODE\n #define LANG_HOOKS_TYPE_FOR_MODE\tgnat_type_for_mode\n-#undef LANG_HOOKS_TYPE_FOR_SIZE\n+#undef  LANG_HOOKS_TYPE_FOR_SIZE\n #define LANG_HOOKS_TYPE_FOR_SIZE\tgnat_type_for_size\n-#undef LANG_HOOKS_SIGNED_TYPE\n+#undef  LANG_HOOKS_SIGNED_TYPE\n #define LANG_HOOKS_SIGNED_TYPE\t\tgnat_signed_type\n-#undef LANG_HOOKS_UNSIGNED_TYPE\n+#undef  LANG_HOOKS_UNSIGNED_TYPE\n #define LANG_HOOKS_UNSIGNED_TYPE\tgnat_unsigned_type\n-#undef LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE\n+#undef  LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE\n #define LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE gnat_signed_or_unsigned_type\n \n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n@@ -377,7 +375,7 @@ internal_error_function (const char *msgid, va_list *ap)\n   vsprintf (buffer, msgid, *ap);\n \n   /* Go up to the first newline.  */\n-  for (p = buffer; *p != 0; p++)\n+  for (p = buffer; *p; p++)\n     if (*p == '\\n')\n       {\n \t*p = '\\0';\n@@ -427,7 +425,7 @@ gnat_init (void)\n static void\n gnat_finish_incomplete_decl (tree dont_care ATTRIBUTE_UNUSED)\n {\n-  gigi_abort (202);\n+  abort ();\n }\n \f\n /* Compute the alignment of the largest mode that can be used for copying\n@@ -639,12 +637,23 @@ gnat_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n       /* ... fall through ... */\n \n     default:\n-      gigi_abort (201);\n+      abort ();\n     }\n \n   return expand_expr_real (new, target, tmode, modifier, alt_rtl);\n }\n \n+/* Generate the RTL for the body of GNU_DECL.  */\n+\n+static void\n+gnat_expand_body (tree gnu_decl)\n+{\n+  if (!DECL_INITIAL (gnu_decl) || DECL_INITIAL (gnu_decl) == error_mark_node)\n+    return;\n+\n+  tree_rest_of_compilation (gnu_decl, false);\n+}\n+\n /* Adjusts the RLI used to layout a record after all the fields have been\n    added.  We only handle the packed case and cause it to use the alignment\n    that will pad the record at the end.  */\n@@ -724,13 +733,13 @@ static tree\n gnat_type_max_size (gnu_type)\n      tree gnu_type;\n {\n-  return max_size (TYPE_SIZE_UNIT (gnu_type), 1);\n+  return max_size (TYPE_SIZE_UNIT (gnu_type), true);\n }\n \n /* GNU_TYPE is a type. Determine if it should be passed by reference by\n    default.  */\n \n-int\n+bool\n default_pass_by_ref (tree gnu_type)\n {\n   /* We pass aggregates by reference if they are sufficiently large.  The\n@@ -747,7 +756,7 @@ default_pass_by_ref (tree gnu_type)\n     return true;\n \n   if (AGGREGATE_TYPE_P (gnu_type)\n-      && (! host_integerp (TYPE_SIZE (gnu_type), 1)\n+      && (!host_integerp (TYPE_SIZE (gnu_type), 1)\n \t  || 0 < compare_tree_int (TYPE_SIZE (gnu_type),\n \t\t\t\t   8 * TYPE_ALIGN (gnu_type))))\n     return true;\n@@ -758,7 +767,7 @@ default_pass_by_ref (tree gnu_type)\n /* GNU_TYPE is the type of a subprogram parameter.  Determine from the type if\n    it should be passed by reference. */\n \n-int\n+bool\n must_pass_by_ref (tree gnu_type)\n {\n   /* We pass only unconstrained objects, those required by the language\n@@ -768,7 +777,7 @@ must_pass_by_ref (tree gnu_type)\n      not have such objects.  */\n   return (TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE\n \t  || (AGGREGATE_TYPE_P (gnu_type) && TYPE_BY_REFERENCE_P (gnu_type))\n-\t  || (TYPE_SIZE (gnu_type) != 0\n+\t  || (TYPE_SIZE (gnu_type)\n \t      && TREE_CODE (TYPE_SIZE (gnu_type)) != INTEGER_CST));\n }\n "}, {"sha": "8ff9b87599f8cec548b70b8067cac2092e26823b", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -1556,7 +1556,13 @@ package body MLib.Prj is\n       Data : constant Project_Data := Projects.Table (For_Project);\n \n    begin\n-      if Data.Library and not Data.Need_To_Build_Lib then\n+      --  No need to build the library if there is no object directory,\n+      --  hence no object files to build the library.\n+\n+      if Data.Library\n+        and then not Data.Need_To_Build_Lib\n+        and then Data.Object_Directory /= No_Name\n+      then\n          declare\n             Current  : constant Dir_Name_Str := Get_Current_Dir;\n             Lib_Name : constant Name_Id := Library_File_Name_For (For_Project);"}, {"sha": "25223bcbf32b81b5bb14578e463000ab9533311d", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -837,6 +837,11 @@ package Opt is\n    --  Set True if generated code uses the System.Secondary_Stack package.\n    --  For the binder, set if any unit uses the secondary stack package.\n \n+   Setup_Projects : Boolean := False;\n+   --  GNAT DRIVER\n+   --  Set to True for GNAT SETUP: the Project Manager creates non existing\n+   --  object, library and exec directories.\n+\n    Shared_Libgnat : Boolean;\n    --  GNATBIND\n    --  Set to True if a shared libgnat is requested by using the -shared"}, {"sha": "c166baafa3a5f8344558ba2e7333818ddf0cc26d", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 121, "deletions": 67, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -29,6 +29,7 @@ with Fmap;     use Fmap;\n with Hostparm;\n with MLib.Tgt;\n with Namet;    use Namet;\n+with Opt;      use Opt;\n with Osint;    use Osint;\n with Output;   use Output;\n with MLib.Tgt; use MLib.Tgt;\n@@ -237,12 +238,19 @@ package body Prj.Nmsc is\n    --  a spec suffix, a body suffix or a separate suffix.\n \n    procedure Locate_Directory\n-     (Name    : Name_Id;\n-      Parent  : Name_Id;\n-      Dir     : out Name_Id;\n-      Display : out Name_Id);\n-   --  Locate a directory.\n-   --  Returns No_Name if directory does not exist.\n+     (Name     : Name_Id;\n+      Parent   : Name_Id;\n+      Dir      : out Name_Id;\n+      Display  : out Name_Id;\n+      Project  : Project_Id := No_Project;\n+      Kind     : String := \"\";\n+      Location : Source_Ptr := No_Location);\n+   --  Locate a directory. Dir is the canonical path name. Display is the\n+   --  path name for display purpose.\n+   --  When the directory does not exist, Setup_Projects is True and Kind is\n+   --  not the empty string, an attempt is made to create the directory.\n+   --  Returns No_Name in Dir and Display if directory does not exist or\n+   --  cannot be created.\n \n    function Path_Name_Of\n      (File_Name : Name_Id;\n@@ -1105,7 +1113,8 @@ package body Prj.Nmsc is\n                --  the object directory or one of the source directories.\n                --  This is the directory where copies of the interface\n                --  sources will be copied. Note that this directory may be\n-               --  the library directory.\n+               --  the library directory. If setting up projects (gnat setup)\n+               --  and the directory does not exist, attempt to create it.\n \n                if Lib_Src_Dir.Value /= Empty_String then\n                   declare\n@@ -1115,11 +1124,18 @@ package body Prj.Nmsc is\n                      Locate_Directory\n                        (Dir_Id, Data.Display_Directory,\n                         Data.Library_Src_Dir,\n-                        Data.Display_Library_Src_Dir);\n+                        Data.Display_Library_Src_Dir,\n+                        Project  => Project,\n+                        Kind     => \"library interface copy\",\n+                        Location => Lib_Src_Dir.Location);\n \n-                     --  If directory does not exist, report an error\n+                     --  If directory does not exist, report an error. No need\n+                     --  to do that if Setup_Projects is True, as an error\n+                     --  has already been reported by Locate_Directory.\n \n-                     if Data.Library_Src_Dir = No_Name then\n+                     if not Setup_Projects\n+                       and then Data.Library_Src_Dir = No_Name\n+                     then\n \n                         --  Get the absolute name of the library directory\n                         --  that does not exist, to report an error.\n@@ -2514,11 +2530,12 @@ package body Prj.Nmsc is\n          --  it is an error, except if it is an extending project.\n          --  If a non extending project is not supposed to contain\n          --  any source, then we never call Find_Sources.\n+         --  No error either when setting up projects (gnat setup).\n \n          if Current_Source /= Nil_String then\n             Data.Ada_Sources_Present := True;\n \n-         elsif Data.Extends = No_Project then\n+         elsif not Setup_Projects and then Data.Extends = No_Project then\n             Error_Msg\n               (Project,\n                \"there are no Ada sources in this project\",\n@@ -3289,13 +3306,18 @@ package body Prj.Nmsc is\n \n             else\n                --  We check that the specified object directory\n-               --  does exist.\n+               --  does exist, and attempt to create it if setting up projects\n+               --  (gnat setup).\n \n                Locate_Directory\n                  (Object_Dir.Value, Data.Display_Directory,\n-                  Data.Object_Directory, Data.Display_Object_Dir);\n+                  Data.Object_Directory, Data.Display_Object_Dir,\n+                  Project  => Project, Kind => \"object\",\n+                  Location => Object_Dir.Location);\n \n-               if Data.Object_Directory = No_Name then\n+               if not Setup_Projects\n+                 and then Data.Object_Directory = No_Name\n+               then\n                   --  The object directory does not exist, report an error\n                   Err_Vars.Error_Msg_Name_1 := Object_Dir.Value;\n                   Error_Msg\n@@ -3354,14 +3376,18 @@ package body Prj.Nmsc is\n                   Exec_Dir.Location);\n \n             else\n-               --  We check that the specified object directory\n-               --  does exist.\n+               --  We check that the specified exec directory does exist and\n+               --  attempt to create it if setting up projects (gnat setup).\n \n                Locate_Directory\n                  (Exec_Dir.Value, Data.Directory,\n-                  Data.Exec_Directory, Data.Display_Exec_Dir);\n+                  Data.Exec_Directory, Data.Display_Exec_Dir,\n+                  Project  => Project, Kind => \"exec\",\n+                  Location => Exec_Dir.Location);\n \n-               if Data.Exec_Directory = No_Name then\n+               if not Setup_Projects\n+                 and then Data.Exec_Directory = No_Name\n+               then\n                   Err_Vars.Error_Msg_Name_1 := Exec_Dir.Value;\n                   Error_Msg\n                     (Project,\n@@ -3553,13 +3579,16 @@ package body Prj.Nmsc is\n             end if;\n \n          else\n-            --  Find path name, check that it is a directory\n+            --  Find path name, check that it is a directory, and attempt\n+            --  to create it if setting up projects (gnat setup).\n \n             Locate_Directory\n               (Lib_Dir.Value, Data.Display_Directory,\n-               Data.Library_Dir, Data.Display_Library_Dir);\n+               Data.Library_Dir, Data.Display_Library_Dir,\n+               Project => Project, Kind => \"library\",\n+               Location => Lib_Dir.Location);\n \n-            if Data.Library_Dir = No_Name then\n+            if not Setup_Projects and then Data.Library_Dir = No_Name then\n \n                --  Get the absolute name of the library directory that\n                --  does not exist, to report an error.\n@@ -3914,17 +3943,78 @@ package body Prj.Nmsc is\n    ----------------------\n \n    procedure Locate_Directory\n-     (Name    : Name_Id;\n-      Parent  : Name_Id;\n-      Dir     : out Name_Id;\n-      Display : out Name_Id)\n+     (Name     : Name_Id;\n+      Parent   : Name_Id;\n+      Dir      : out Name_Id;\n+      Display  : out Name_Id;\n+      Project  : Project_Id := No_Project;\n+      Kind     : String := \"\";\n+      Location : Source_Ptr := No_Location)\n    is\n       The_Name   : constant String := Get_Name_String (Name);\n       The_Parent : constant String :=\n                      Get_Name_String (Parent) & Directory_Separator;\n       The_Parent_Last : constant Natural :=\n                      Compute_Directory_Last (The_Parent);\n \n+      procedure Create_Directory (Absolute_Path : String);\n+      --  Attempt to create a new directory\n+\n+      procedure Get_Names_For (Absolute_Path : String);\n+      --  Create name ids Dir and Display for directory Absolute_Path\n+\n+      ----------------------\n+      -- Create_Directory --\n+      ----------------------\n+\n+      procedure Create_Directory (Absolute_Path : String) is\n+      begin\n+         --  Attempt to create the directory\n+\n+         Make_Dir (Absolute_Path);\n+\n+         --  Setup Dir and Display if creation was successful\n+\n+         Get_Names_For (Absolute_Path);\n+\n+      exception\n+         when Directory_Error =>\n+            Error_Msg\n+              (Project,\n+               \"could not create \" & Kind & \" directory \"\"\" &\n+               Absolute_Path & \"\"\"\",\n+               Location);\n+      end Create_Directory;\n+\n+      -------------------\n+      -- Get_Names_For --\n+      -------------------\n+\n+      procedure Get_Names_For (Absolute_Path : String) is\n+         Normed         : constant String :=\n+                            Normalize_Pathname\n+                              (Absolute_Path,\n+                               Resolve_Links  => False,\n+                               Case_Sensitive => True);\n+\n+         Canonical_Path : constant String :=\n+                            Normalize_Pathname\n+                              (Normed,\n+                               Resolve_Links  => True,\n+                               Case_Sensitive => False);\n+\n+      begin\n+         Name_Len := Normed'Length;\n+         Name_Buffer (1 .. Name_Len) := Normed;\n+         Display := Name_Find;\n+\n+         Name_Len := Canonical_Path'Length;\n+         Name_Buffer (1 .. Name_Len) := Canonical_Path;\n+         Dir := Name_Find;\n+      end Get_Names_For;\n+\n+   --  Start of processing for Locate_Directory\n+\n    begin\n       if Current_Verbosity = High then\n          Write_Str (\"Locate_Directory (\"\"\");\n@@ -3939,28 +4029,10 @@ package body Prj.Nmsc is\n \n       if Is_Absolute_Path (The_Name) then\n          if Is_Directory (The_Name) then\n-            declare\n-               Normed : constant String :=\n-                          Normalize_Pathname\n-                            (The_Name,\n-                             Resolve_Links  => False,\n-                             Case_Sensitive => True);\n-\n-               Canonical_Path : constant String :=\n-                                  Normalize_Pathname\n-                                    (Normed,\n-                                     Resolve_Links  => True,\n-                                     Case_Sensitive => False);\n-\n-            begin\n-               Name_Len := Normed'Length;\n-               Name_Buffer (1 .. Name_Len) := Normed;\n-               Display := Name_Find;\n+            Get_Names_For (The_Name);\n \n-               Name_Len := Canonical_Path'Length;\n-               Name_Buffer (1 .. Name_Len) := Canonical_Path;\n-               Dir := Name_Find;\n-            end;\n+         elsif Kind /= \"\" and then Setup_Projects then\n+            Create_Directory (The_Name);\n          end if;\n \n       else\n@@ -3971,28 +4043,10 @@ package body Prj.Nmsc is\n \n          begin\n             if Is_Directory (Full_Path) then\n-               declare\n-                  Normed : constant String :=\n-                             Normalize_Pathname\n-                               (Full_Path,\n-                                Resolve_Links  => False,\n-                                Case_Sensitive => True);\n-\n-                  Canonical_Path : constant String :=\n-                                     Normalize_Pathname\n-                                       (Normed,\n-                                        Resolve_Links  => True,\n-                                        Case_Sensitive => False);\n+               Get_Names_For (Full_Path);\n \n-               begin\n-                  Name_Len := Normed'Length;\n-                  Name_Buffer (1 .. Name_Len) := Normed;\n-                  Display := Name_Find;\n-\n-                  Name_Len := Canonical_Path'Length;\n-                  Name_Buffer (1 .. Name_Len) := Canonical_Path;\n-                  Dir := Name_Find;\n-               end;\n+            elsif Kind /= \"\" and then Setup_Projects then\n+               Create_Directory (Full_Path);\n             end if;\n          end;\n       end if;"}, {"sha": "c6d1d90c0c8ced81265c1d727dd9c60f28c01d57", "filename": "gcc/ada/s-mastop-irix.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fs-mastop-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fs-mastop-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mastop-irix.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -125,7 +125,9 @@ package body System.Machine_State_Operations is\n    --  Offset from first byte of a __uint64 register save location where\n    --  the register value is stored.  For n32/64 we store the entire 64\n    --  bit register into the uint64.  For o32, only 32 bits are stored\n-   --  at an offset of 4 bytes.\n+   --  at an offset of 4 bytes. This is used as part of expressions with\n+   --  '+' signs on both sides, so a null offset has to be '0' and not ' '\n+   --  to avoid assembler syntax errors on \"X + + Y\" in the latter case.\n \n    procedure Update_GP (Scp : Sigcontext_Ptr);\n "}, {"sha": "44c80e0910f7907dab6b98cc60b1d4da617b298e", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -29,7 +29,6 @@ with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n-with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n with Itypes;   use Itypes;\n@@ -1684,15 +1683,7 @@ package body Sem_Aggr is\n                   --  of a component the expander will generate calls to\n                   --  the corresponding initialization subprogram.\n \n-                  if Present (Base_Init_Proc (Etype (Component_Typ)))\n-                    or else Has_Task (Base_Type (Component_Typ))\n-                  then\n-                     null;\n-                  else\n-                     Error_Msg_N\n-                       (\"(Ada 2005): no value supplied for this component\",\n-                        Assoc);\n-                  end if;\n+                  null;\n \n                elsif not Resolve_Aggr_Expr (Expression (Assoc),\n                                             Single_Elmt => Single_Choice)\n@@ -1831,13 +1822,7 @@ package body Sem_Aggr is\n                --  of a component the expander will generate calls to\n                --  the corresponding initialization subprogram.\n \n-               if Present (Base_Init_Proc (Etype (Component_Typ))) then\n-                  null;\n-               else\n-                  Error_Msg_N\n-                    (\"(Ada 2005): no value supplied for these components\",\n-                     Assoc);\n-               end if;\n+               null;\n \n             elsif not Resolve_Aggr_Expr (Expression (Assoc),\n                                          Single_Elmt => False)\n@@ -2965,20 +2950,24 @@ package body Sem_Aggr is\n          Component := Node (Component_Elmt);\n          Expr := Get_Value (Component, Component_Associations (N), True);\n \n-         if Mbox_Present and then Is_Limited_Type (Etype (Component)) then\n-\n-            --  Ada 2005 (AI-287): In case of default initialization of\n-            --  a limited component we pass the limited component to\n-            --  the expander. The expander will generate calls to the\n-            --  corresponding initialization subprograms.\n+         --  Ada 2005 (AI-287): Default initialized limited component are\n+         --  passed to the expander, that will generate calls to the\n+         --  corresponding IP.\n \n+         if Mbox_Present and then Is_Limited_Type (Etype (Component)) then\n             Add_Association\n               (Component   => Component,\n                Expr        => Empty,\n                Box_Present => True);\n \n+         --  Ada 2005 (AI-287): No value supplied for component\n+\n+         elsif Mbox_Present and No (Expr) then\n+            null;\n+\n          elsif No (Expr) then\n             Error_Msg_NE (\"no value supplied for component &!\", N, Component);\n+\n          else\n             Resolve_Aggr_Expr (Expr, Component);\n          end if;"}, {"sha": "cbdfbc272d953306ed1ae87c69738d6d7d810f3c", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -3248,13 +3248,6 @@ package body Sem_Ch10 is\n             then\n                Set_Is_Immediately_Visible (Id);\n \n-               --  Ada 2005 (AI-262): Make visible the private entities of\n-               --  private-withed siblings\n-\n-               if Private_Present (Item) then\n-                  Install_Private_Declarations (Id);\n-               end if;\n-\n                --  Check for the presence of another unit in the context,\n                --  that may be inadvertently hidden by the child.\n "}, {"sha": "b7dc0a793ec1b11a8f32efde1eb7d712559e489b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -6251,7 +6251,17 @@ package body Sem_Ch3 is\n              Subtype_Mark => New_Reference_To (Par, Loc),\n              Constraint   => New_Copy_Tree (Constr)));\n \n-      Insert_Before (N, Indic);\n+      --  If this is a component subtype for an outer itype, it is not\n+      --  a list member, so simply set the parent link for analysis: if\n+      --  the enclosing type does not need to be in a declarative list,\n+      --  neither do the components.\n+\n+      if Is_List_Member (N) then\n+         Insert_Before (N, Indic);\n+      else\n+         Set_Parent (Indic, Parent (N));\n+      end if;\n+\n       Analyze (Indic);\n       Set_Underlying_Full_View (Typ, Full_View (Subt));\n    end Build_Underlying_Full_View;"}, {"sha": "790ca0014e874cd049f3082831ddbd7f8ca2a7b6", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -1918,6 +1918,11 @@ package body Sem_Ch8 is\n       Rewrite (N, Body_Node);\n       Analyze (N);\n \n+      if Is_Compilation_Unit (New_S) then\n+         Error_Msg_N\n+           (\"a library unit can only rename another library unit\", N);\n+      end if;\n+\n       Set_Etype (New_S, Base_Type (Etype (New_S)));\n \n       --  We suppress elaboration warnings for the resulting entity, since\n@@ -2051,6 +2056,14 @@ package body Sem_Ch8 is\n       then\n          Error_Msg_N (\"renamed unit must be a library unit\", Name (N));\n \n+      --  Entities defined in Standard (operators and boolean literals) cannot\n+      --  be renamed as library units.\n+\n+      elsif Scope (Old_E) = Standard_Standard\n+        and then Sloc (Old_E) = Standard_Location\n+      then\n+         Error_Msg_N (\"renamed unit must be a library unit\", Name (N));\n+\n       elsif Present (Parent_Spec (N))\n         and then Nkind (Unit (Parent_Spec (N))) = N_Generic_Package_Declaration\n         and then not Is_Child_Unit (Old_E)"}, {"sha": "9a7d711b5ec95cfcbfbfc09edbb9f43165de1411", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -2110,7 +2110,11 @@ package body Sem_Res is\n             if not Is_Predefined_Op (Entity (N)) then\n                Rewrite_Operator_As_Call (N, Entity (N));\n \n-            elsif Present (Alias (Entity (N))) then\n+            elsif Present (Alias (Entity (N)))\n+              and then\n+                Nkind (Parent (Parent (Entity (N))))\n+                  = N_Subprogram_Renaming_Declaration\n+            then\n                Rewrite_Renamed_Operator (N, Alias (Entity (N)), Typ);\n \n                --  If the node is rewritten, it will be fully resolved in"}, {"sha": "3f9c7eeba1d8f7c57f8a6f516b9ec103fa700a0c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -4043,6 +4043,9 @@ package body Sem_Util is\n          then\n             return False;\n \n+         elsif Nkind (Original_Node (AV)) = N_Type_Conversion then\n+            return Is_OK_Variable_For_Out_Formal (Expression (AV));\n+\n          else\n             return True;\n          end if;\n@@ -5772,9 +5775,10 @@ package body Sem_Util is\n          --  scope because the back end otherwise tries to allocate a\n          --  variable length temporary for the particular variant.\n \n-         if Opt.GCC_Version = 2\n-           and then Has_Discriminants (Typ)\n-         then\n+         --  ??? With tree-ssa, the back-end does not (yet) support these\n+         --  types either, so disable this optimization for now.\n+\n+         if Has_Discriminants (Typ) then\n             return True;\n \n          --  For GCC 3, or for a non-discriminated record in GCC 2, we are"}, {"sha": "f45783e9986d9c4df402f32a536a69b7a11f83bf", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 297, "deletions": 321, "changes": 618, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -73,7 +73,7 @@ const char *ref_filename;\n /* If true, then gigi is being called on an analyzed but unexpanded\n    tree, and the only purpose of the call is to properly annotate\n    types with representation information. */\n-int type_annotate_only;\n+bool type_annotate_only;\n \n /* A structure used to gather together information about a statement group.\n    We use this to gather related statements, for example the \"then\" part\n@@ -120,7 +120,7 @@ static GTY(()) tree gnu_elab_proc_decl;\n /* Map GNAT tree codes to GCC tree codes for simple expressions.  */\n static enum tree_code gnu_codes[Number_Node_Kinds];\n \n-/* Current node being treated, in case gigi_abort called.  */\n+/* Current node being treated, in case abort called.  */\n Node_Id error_gnat_node;\n \n static void record_code_position (Node_Id);\n@@ -135,21 +135,20 @@ static tree build_stmt_group (List_Id, bool);\n static void push_stack (tree *, tree, tree);\n static void pop_stack (tree *);\n static enum gimplify_status gnat_gimplify_stmt (tree *);\n-static void gnat_expand_body_1 (tree, bool);\n static void elaborate_all_entities (Node_Id);\n static void process_freeze_entity (Node_Id);\n static void process_inlined_subprograms (Node_Id);\n-static void process_decls (List_Id, List_Id, Node_Id, int, int);\n+static void process_decls (List_Id, List_Id, Node_Id, bool, bool);\n static tree emit_range_check (tree, Node_Id);\n static tree emit_index_check (tree, tree, tree, tree);\n static tree emit_check (tree, tree, int);\n-static tree convert_with_check (Entity_Id, tree, int, int, int);\n-static int addressable_p (tree);\n+static tree convert_with_check (Entity_Id, tree, bool, bool, bool);\n+static bool addressable_p (tree);\n static tree assoc_to_constructor (Node_Id, tree);\n static tree extract_values (tree, tree);\n static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static tree maybe_implicit_deref (tree);\n-static tree gnat_stabilize_reference_1 (tree, int);\n+static tree gnat_stabilize_reference_1 (tree, bool);\n static bool build_unit_elab (void);\n static void annotate_with_node (tree, Node_Id);\n \n@@ -203,8 +202,8 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n   /* Save the type we made for integer as the type for Standard.Integer.\n      Then make the rest of the standard types.  Note that some of these\n      may be subtypes.  */\n-  save_gnu_tree (Base_Type (standard_integer),\n-\t\t TYPE_NAME (integer_type_node), 0);\n+  save_gnu_tree (Base_Type (standard_integer), TYPE_NAME (integer_type_node),\n+\t\t false);\n \n   gnu_except_ptr_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n \n@@ -237,7 +236,8 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n     = create_subprog_decl\n       (create_concat_name (gnat_unit_entity,\n \t\t\t   body_p ? \"elabb\" : \"elabs\"),\n-       NULL_TREE, void_ftype, NULL_TREE, 0, 1, 0, 0, gnat_unit_entity);\n+       NULL_TREE, void_ftype, NULL_TREE, false, true, false, NULL,\n+       gnat_unit_entity);\n \n   DECL_ELABORATION_PROC_P (gnu_elab_proc_decl) = 1;\n   allocate_struct_function (gnu_elab_proc_decl);\n@@ -247,7 +247,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n       /* For a body, first process the spec if there is one. */\n   if (Nkind (Unit (gnat_root)) == N_Package_Body\n       || (Nkind (Unit (gnat_root)) == N_Subprogram_Body\n-\t      && ! Acts_As_Spec (gnat_root)))\n+\t      && !Acts_As_Spec (gnat_root)))\n     add_stmt (gnat_to_gnu (Library_Unit (gnat_root)));\n \n   process_inlined_subprograms (gnat_root);\n@@ -263,7 +263,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n     }\n \n   process_decls (Declarations (Aux_Decls_Node (gnat_root)), Empty, Empty,\n-\t\t 1, 1);\n+\t\t true, true);\n   add_stmt (gnat_to_gnu (Unit (gnat_root)));\n \n   /* Process any pragmas and actions following the unit.  */\n@@ -322,22 +322,22 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   gnat_temp_type = Etype (gnat_temp);\n \n   if (Etype (gnat_node) != gnat_temp_type\n-      && ! (Is_Packed (gnat_temp_type)\n-\t    && Etype (gnat_node) == Packed_Array_Type (gnat_temp_type))\n-      && ! (Is_Class_Wide_Type (Etype (gnat_node)))\n-      && ! (IN (Ekind (gnat_temp_type), Private_Kind)\n-\t    && Present (Full_View (gnat_temp_type))\n-\t    && ((Etype (gnat_node) == Full_View (gnat_temp_type))\n-\t\t|| (Is_Packed (Full_View (gnat_temp_type))\n-\t\t    && (Etype (gnat_node)\n-\t\t\t== Packed_Array_Type (Full_View (gnat_temp_type))))))\n+      && !(Is_Packed (gnat_temp_type)\n+\t   && Etype (gnat_node) == Packed_Array_Type (gnat_temp_type))\n+      && !(Is_Class_Wide_Type (Etype (gnat_node)))\n+      && !(IN (Ekind (gnat_temp_type), Private_Kind)\n+\t   && Present (Full_View (gnat_temp_type))\n+\t   && ((Etype (gnat_node) == Full_View (gnat_temp_type))\n+\t       || (Is_Packed (Full_View (gnat_temp_type))\n+\t\t   && (Etype (gnat_node)\n+\t\t       == Packed_Array_Type (Full_View (gnat_temp_type))))))\n       && (!Is_Itype (Etype (gnat_node)) || !Is_Itype (gnat_temp_type))\n       && (Ekind (gnat_temp) == E_Variable\n \t  || Ekind (gnat_temp) == E_Component\n \t  || Ekind (gnat_temp) == E_Constant\n \t  || Ekind (gnat_temp) == E_Loop_Parameter\n \t  || IN (Ekind (gnat_temp), Formal_Kind)))\n-    gigi_abort (304);\n+    abort ();\n \n   /* If this is a reference to a deferred constant whose partial view is an\n      unconstrained private type, the proper type is on the full view of the\n@@ -350,7 +350,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   if (Is_Private_Type (gnat_temp_type)\n       && Has_Unknown_Discriminants (gnat_temp_type)\n       && Present (Full_View (gnat_temp))\n-      && ! Is_Type (gnat_temp))\n+      && !Is_Type (gnat_temp))\n     {\n       gnat_temp = Full_View (gnat_temp);\n       gnat_temp_type = Etype (gnat_temp);\n@@ -365,8 +365,8 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t Actual_Subtype for packed arrays to simplify things.  */\n       if ((Ekind (gnat_temp) == E_Constant\n \t   || Ekind (gnat_temp) == E_Variable || Is_Formal (gnat_temp))\n-\t  && ! (Is_Array_Type (Etype (gnat_temp))\n-\t\t&& Present (Packed_Array_Type (Etype (gnat_temp))))\n+\t  && !(Is_Array_Type (Etype (gnat_temp))\n+\t       && Present (Packed_Array_Type (Etype (gnat_temp))))\n \t  && Present (Actual_Subtype (gnat_temp))\n \t  && present_gnu_tree (Actual_Subtype (gnat_temp)))\n \tgnat_temp_type = Actual_Subtype (gnat_temp);\n@@ -388,7 +388,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \n      ??? Also, for now all we can do is make it volatile.  But we only\n      do this for SJLJ.  */\n-  if (TREE_VALUE (gnu_except_ptr_stack) != 0\n+  if (TREE_VALUE (gnu_except_ptr_stack)\n       && TREE_CODE (gnu_result) == VAR_DECL)\n     TREE_THIS_VOLATILE (gnu_result) = TREE_SIDE_EFFECTS (gnu_result) = 1;\n \n@@ -402,7 +402,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t  || (TREE_CODE (gnu_result) == PARM_DECL\n \t      && DECL_BY_COMPONENT_PTR_P (gnu_result))))\n     {\n-      int ro = DECL_POINTS_TO_READONLY_P (gnu_result);\n+      bool ro = DECL_POINTS_TO_READONLY_P (gnu_result);\n       tree initial;\n \n       if (TREE_CODE (gnu_result) == PARM_DECL\n@@ -465,37 +465,37 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   if (TREE_CODE (gnu_result) == CONST_DECL)\n     {\n       gnat_temp = Parent (gnat_node);\n-      if (DECL_CONST_CORRESPONDING_VAR (gnu_result) == 0\n+      if (!DECL_CONST_CORRESPONDING_VAR (gnu_result)\n \t  || (Nkind (gnat_temp) != N_Reference\n-\t      && ! (Nkind (gnat_temp) == N_Attribute_Reference\n-\t\t    && ((Get_Attribute_Id (Attribute_Name (gnat_temp))\n-\t\t\t == Attr_Address)\n-\t\t\t|| (Get_Attribute_Id (Attribute_Name (gnat_temp))\n-\t\t\t    == Attr_Access)\n-\t\t\t|| (Get_Attribute_Id (Attribute_Name (gnat_temp))\n+\t      && !(Nkind (gnat_temp) == N_Attribute_Reference\n+\t\t   && ((Get_Attribute_Id (Attribute_Name (gnat_temp))\n+\t\t\t== Attr_Address)\n+\t\t       || (Get_Attribute_Id (Attribute_Name (gnat_temp))\n+\t\t\t   == Attr_Access)\n+\t\t       || (Get_Attribute_Id (Attribute_Name (gnat_temp))\n \t\t\t    == Attr_Unchecked_Access)\n-\t\t\t|| (Get_Attribute_Id (Attribute_Name (gnat_temp))\n-\t\t\t    == Attr_Unrestricted_Access)))))\n+\t\t       || (Get_Attribute_Id (Attribute_Name (gnat_temp))\n+\t\t\t   == Attr_Unrestricted_Access)))))\n \tgnu_result = DECL_INITIAL (gnu_result);\n     }\n \n   *gnu_result_type_p = gnu_result_type;\n   return gnu_result;\n }\n+\f\n+/* Subroutine of gnat_to_gnu to process gnat_node, an N_Pragma.  Return\n+   any statements we generate.  */\n \n-/* Subroutine of gnat_to_gnu to process gnat_node, an N_Pragma.  We don't\n-   return anything.  */\n-\n-static void\n+static tree\n Pragma_to_gnu (Node_Id gnat_node)\n {\n   Node_Id gnat_temp;\n+  tree gnu_result = alloc_stmt_list ();\n \n   /* Check for (and ignore) unrecognized pragma and do nothing if we are just\n      annotating types.  */\n-  if (type_annotate_only\n-      || ! Is_Pragma_Name (Chars (gnat_node)))\n-    return;\n+  if (type_annotate_only || !Is_Pragma_Name (Chars (gnat_node)))\n+    return gnu_result;\n \n   switch (Get_Pragma_Id (Chars (gnat_node)))\n     {\n@@ -514,7 +514,8 @@ Pragma_to_gnu (Node_Id gnat_node)\n \t    gnu_expr = TREE_OPERAND (gnu_expr, 0);\n \n \t  gnu_expr = build1 (USE_STMT, void_type_node, gnu_expr);\n-\t  add_stmt (gnu_expr);\n+\t  annotate_with_node (gnu_expr, gnat_node);\n+\t  append_to_statement_list (gnu_expr, &gnu_result);\n \t}\n       break;\n \n@@ -533,7 +534,7 @@ Pragma_to_gnu (Node_Id gnat_node)\n \t  break;\n \n \tdefault:\n-\t  gigi_abort (331);\n+\t  abort ();\n \t  break;\n \t}\n       break;\n@@ -543,6 +544,8 @@ Pragma_to_gnu (Node_Id gnat_node)\n \tpost_error (\"must specify -g?\", gnat_node);\n       break;\n     }\n+\n+  return gnu_result;\n }\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Attribute,\n    to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to\n@@ -573,12 +576,12 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       /* These are just conversions until since representation clauses for\n \t enumerations are handled in the front end.  */\n       {\n-\tint check_p = Do_Range_Check (First (Expressions (gnat_node)));\n+\tbool checkp = Do_Range_Check (First (Expressions (gnat_node)));\n \n \tgnu_result = gnat_to_gnu (First (Expressions (gnat_node)));\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \tgnu_result = convert_with_check (Etype (gnat_node), gnu_result,\n-\t\t\t\t\t check_p, check_p, 1);\n+\t\t\t\t\t checkp, checkp, true);\n       }\n       break;\n \n@@ -614,7 +617,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       /* Conversions don't change something's address but can cause us to miss\n \t the COMPONENT_REF case below, so strip them off.  */\n       gnu_prefix = remove_conversions (gnu_prefix,\n-\t\t\t\t       ! Must_Be_Byte_Aligned (gnat_node));\n+\t\t\t\t       !Must_Be_Byte_Aligned (gnat_node));\n \n       /* If we are taking 'Address of an unconstrained object, this is the\n \t pointer to the underlying array.  */\n@@ -629,7 +632,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       gnu_result\n \t= build_unary_op (((attribute == Attr_Address\n \t\t\t    || attribute == Attr_Unrestricted_Access)\n-\t\t\t   && ! Must_Be_Byte_Aligned (gnat_node))\n+\t\t\t   && !Must_Be_Byte_Aligned (gnat_node))\n \t\t\t  ? ATTR_ADDR_EXPR : ADDR_EXPR,\n \t\t\t  gnu_result_type, gnu_prefix);\n \n@@ -696,7 +699,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \tgnu_expr = TREE_OPERAND (gnu_expr, 0)\n \t  ;\n \n-      gnu_prefix = remove_conversions (gnu_prefix, 1);\n+      gnu_prefix = remove_conversions (gnu_prefix, true);\n       prefix_unused = true;\n       gnu_type = TREE_TYPE (gnu_prefix);\n \n@@ -734,8 +737,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t      && TREE_CODE (gnu_expr) == COMPONENT_REF)\n \t    {\n \t      gnu_result = rm_size (gnu_type);\n-\t      if (! (CONTAINS_PLACEHOLDER_P\n-\t\t     (DECL_SIZE (TREE_OPERAND (gnu_expr, 1)))))\n+\t      if (!(CONTAINS_PLACEHOLDER_P\n+\t\t    (DECL_SIZE (TREE_OPERAND (gnu_expr, 1)))))\n \t\tgnu_result\n \t\t  = size_binop (MAX_EXPR, gnu_result,\n \t\t\t\tDECL_SIZE (TREE_OPERAND (gnu_expr, 1)));\n@@ -746,8 +749,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       else\n \tgnu_result = rm_size (gnu_type);\n \n-      if (gnu_result == 0)\n-\tgigi_abort (325);\n+      if (!gnu_result)\n+\tabort ();\n \n       /* Deal with a self-referential size by returning the maximum size for a\n \t type and by qualifying the size with the object for 'Size of an\n@@ -758,7 +761,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t    gnu_result = substitute_placeholder_in_expr (gnu_result,\n \t\t\t\t\t\t\t gnu_expr);\n \t  else\n-\t    gnu_result = max_size (gnu_result, 1);\n+\t    gnu_result = max_size (gnu_result, true);\n \t}\n \n       /* If the type contains a template, subtract its size.  */\n@@ -862,7 +865,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t  gnu_type = TREE_TYPE (gnu_type);\n \n \tif (TREE_CODE (gnu_type) != ARRAY_TYPE)\n-\t  gigi_abort (309);\n+\t  abort ();\n \n \tif (attribute == Attr_First)\n \t  gnu_result\n@@ -918,7 +921,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \tint unsignedp, volatilep;\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n-\tgnu_prefix = remove_conversions (gnu_prefix, 1);\n+\tgnu_prefix = remove_conversions (gnu_prefix, true);\n \tprefix_unused = true;\n \n \t/* We can have 'Bit on any object, but if it isn't a COMPONENT_REF,\n@@ -932,9 +935,9 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t  }\n \n \telse if (TREE_CODE (gnu_prefix) != COMPONENT_REF\n-\t\t && ! (attribute == Attr_Bit_Position\n-\t\t       && TREE_CODE (gnu_prefix) == FIELD_DECL))\n-\t  gigi_abort (310);\n+\t\t && !(attribute == Attr_Bit_Position\n+\t\t      && TREE_CODE (gnu_prefix) == FIELD_DECL))\n+\t  abort ();\n \n \tget_inner_reference (gnu_prefix, &bitsize, &bitpos, &gnu_offset,\n \t\t\t     &mode, &unsignedp, &volatilep);\n@@ -1035,7 +1038,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \tgnu_type = TREE_TYPE (gnu_type);\n \n       if (TREE_CODE (gnu_type) != ARRAY_TYPE)\n-\tgigi_abort (330);\n+\tabort ();\n \n       /* Note this size cannot be self-referential.  */\n       gnu_result = TYPE_SIZE (TREE_TYPE (gnu_type));\n@@ -1098,7 +1101,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n      name.  However, if an access check is needed, we must do it.  See second\n      example in AARM 11.6(5.e). */\n   if (prefix_unused && TREE_SIDE_EFFECTS (gnu_prefix)\n-      && ! Is_Entity_Name (Prefix (gnat_node)))\n+      && !Is_Entity_Name (Prefix (gnat_node)))\n     gnu_result = fold (build (COMPOUND_EXPR, TREE_TYPE (gnu_result),\n \t\t\t      gnu_prefix, gnu_result));\n \n@@ -1192,7 +1195,7 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t      break;\n \n \t    default:\n-\t      gigi_abort (316);\n+\t      abort ();\n \t    }\n \n \t  add_stmt_with_node (build (CASE_LABEL_EXPR, void_type_node,\n@@ -1325,7 +1328,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n      LOOP_STMT. */\n   if (Present (Identifier (gnat_node)))\n     save_gnu_tree (Entity (Identifier (gnat_node)),\n-\t\t   LOOP_STMT_LABEL (gnu_loop_stmt), 1);\n+\t\t   LOOP_STMT_LABEL (gnu_loop_stmt), true);\n \n   /* Make the loop body into its own block, so any allocated storage will be\n      released every iteration.  This is needed for stack allocation.  */\n@@ -1406,7 +1409,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   gnu_subprog_decl\n     = gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE,\n \t\t\t  Acts_As_Spec (gnat_node)\n-\t\t\t  && ! present_gnu_tree (gnat_subprog_id));\n+\t\t\t  && !present_gnu_tree (gnat_subprog_id));\n \n   gnu_subprog_type = TREE_TYPE (gnu_subprog_decl);\n \n@@ -1440,7 +1443,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n       {\n \t/* Skip any entries that have been already filled in; they must\n \t   correspond to IN OUT parameters.  */\n-\tfor (; gnu_cico_list != 0 && TREE_VALUE (gnu_cico_list) != 0;\n+\tfor (; gnu_cico_list && TREE_VALUE (gnu_cico_list);\n \t     gnu_cico_list = TREE_CHAIN (gnu_cico_list))\n \t  ;\n \n@@ -1450,7 +1453,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t\t     gnat_to_gnu_entity (gnat_param, NULL_TREE, 1));\n       }\n \n-  process_decls (Declarations (gnat_node), Empty, Empty, 1, 1);\n+  process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n \n   /* Generate the code of the subprogram itself.  A return statement will be\n      present and any OUT parameters will be handled there.  */\n@@ -1461,7 +1464,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   /* If we made a special return label, we need to make a block that contains\n      the definition of that label and the copying to the return value.  That\n      block first contains the function, then the label and copy statement.  */\n-  if (TREE_VALUE (gnu_return_label_stack) != 0)\n+  if (TREE_VALUE (gnu_return_label_stack))\n     {\n       tree gnu_retval;\n \n@@ -1509,7 +1512,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n        Present (gnat_param);\n        gnat_param = Next_Formal_With_Extras (gnat_param))\n     if (TREE_CODE (get_gnu_tree (gnat_param)) == VAR_DECL)\n-      save_gnu_tree (gnat_param, NULL_TREE, 0);\n+      save_gnu_tree (gnat_param, NULL_TREE, false);\n \n   mark_out_of_scope (Defining_Unit_Name (Specification (gnat_node)));\n   write_symbols = save_write_symbols;\n@@ -1552,7 +1555,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n     }\n \n   if (TREE_CODE (gnu_subprog_type) != FUNCTION_TYPE)\n-    gigi_abort (317);\n+    abort ();\n \n   /* If we are calling a stubbed function, make this into a raise of\n      Program_Error.  Elaborate all our args first.  */\n@@ -1606,6 +1609,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t\t   ? Expression (gnat_actual) : gnat_actual);\n       tree gnu_name = gnat_to_gnu (gnat_name);\n       tree gnu_name_type = gnat_to_gnu_type (Etype (gnat_name));\n+      tree gnu_formal\n+\t= (present_gnu_tree (gnat_formal)\n+\t   ? get_gnu_tree (gnat_formal) : NULL_TREE);\n       tree gnu_actual;\n \n       /* If it's possible we may need to use this expression twice, make sure\n@@ -1618,14 +1624,13 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t of a copy and set up to copy back out after the call.  */\n       if (Ekind (gnat_formal) != E_In_Parameter)\n \t{\n-\t  gnu_name = gnat_stabilize_reference (gnu_name, 1);\n-\t  if (! addressable_p (gnu_name)\n-\t      && present_gnu_tree (gnat_formal)\n-\t      && (DECL_BY_REF_P (get_gnu_tree (gnat_formal))\n-\t\t  || (TREE_CODE (get_gnu_tree (gnat_formal)) == PARM_DECL\n-\t\t      && (DECL_BY_COMPONENT_PTR_P (get_gnu_tree (gnat_formal))\n-\t\t\t  || (DECL_BY_DESCRIPTOR_P\n-\t\t\t      (get_gnu_tree (gnat_formal)))))))\n+\t  gnu_name = gnat_stabilize_reference (gnu_name, true);\n+\t  if (!addressable_p (gnu_name)\n+\t      && gnu_formal\n+\t      && (DECL_BY_REF_P (gnu_formal)\n+\t\t  || (TREE_CODE (gnu_formal) == PARM_DECL\n+\t\t      && (DECL_BY_COMPONENT_PTR_P (gnu_formal)\n+\t\t\t  || (DECL_BY_DESCRIPTOR_P (gnu_formal))))))\n \t    {\n \t      tree gnu_copy = gnu_name;\n \t      tree gnu_temp;\n@@ -1682,7 +1687,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t\t    gnu_name);\n \n       if (Ekind (gnat_formal) != E_Out_Parameter\n-\t  && ! unchecked_convert_p\n+\t  && !unchecked_convert_p\n \t  && Do_Range_Check (gnat_actual))\n \tgnu_actual = emit_range_check (gnu_actual, Etype (gnat_formal));\n \n@@ -1718,9 +1723,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t OUT parameter not passed by reference and that does not need to be\n \t copied in. Otherwise, look at the PARM_DECL to see if it is passed by\n \t reference. */\n-      if (present_gnu_tree (gnat_formal)\n-\t  && TREE_CODE (get_gnu_tree (gnat_formal)) == PARM_DECL\n-\t  && DECL_BY_REF_P (get_gnu_tree (gnat_formal)))\n+      if (gnu_formal\n+\t  && TREE_CODE (gnu_formal) == PARM_DECL && DECL_BY_REF_P (gnu_formal))\n \t{\n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    {\n@@ -1739,7 +1743,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t     so, remove that operation since we have no way of allocating the\n \t     required temporary.  */\n \t  if (TREE_CODE (gnu_actual) == COMPONENT_REF\n-\t      && ! TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_actual)))\n+\t      && !TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_actual)))\n \t      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_actual, 0)))\n \t\t  == RECORD_TYPE)\n \t      && TYPE_IS_PADDING_P (TREE_TYPE\n@@ -1752,9 +1756,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t  gnu_formal_type = TREE_TYPE (get_gnu_tree (gnat_formal));\n \t  gnu_actual = build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n \t}\n-      else if (present_gnu_tree (gnat_formal)\n-\t       && TREE_CODE (get_gnu_tree (gnat_formal)) == PARM_DECL\n-\t       && DECL_BY_COMPONENT_PTR_P (get_gnu_tree (gnat_formal)))\n+      else if (gnu_formal && TREE_CODE (gnu_formal) == PARM_DECL\n+\t       && DECL_BY_COMPONENT_PTR_P (gnu_formal))\n \t{\n \t  gnu_formal_type = TREE_TYPE (get_gnu_tree (gnat_formal));\n \t  gnu_actual = maybe_implicit_deref (gnu_actual);\n@@ -1777,9 +1780,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t\t\tgnu_actual));\n \t}\n-      else if (present_gnu_tree (gnat_formal)\n-\t       && TREE_CODE (get_gnu_tree (gnat_formal)) == PARM_DECL\n-\t       && DECL_BY_DESCRIPTOR_P (get_gnu_tree (gnat_formal)))\n+      else if (gnu_formal && TREE_CODE (gnu_formal) == PARM_DECL\n+\t       && DECL_BY_DESCRIPTOR_P (gnu_formal))\n \t{\n \t  /* If arg is 'Null_Parameter, pass zero descriptor.  */\n \t  if ((TREE_CODE (gnu_actual) == INDIRECT_REF\n@@ -1797,11 +1799,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t  tree gnu_actual_size = TYPE_SIZE (TREE_TYPE (gnu_actual));\n \t  \n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n-\t    gnu_name_list = chainon (gnu_name_list,\n-\t\t\t\t     build_tree_list (NULL_TREE, gnu_name));\n+\t    gnu_name_list = tree_cons (NULL_TREE, gnu_name, gnu_name_list);\n \n-\t  if (! present_gnu_tree (gnat_formal)\n-\t      || TREE_CODE (get_gnu_tree (gnat_formal)) != PARM_DECL)\n+\t  if (!gnu_formal || TREE_CODE (gnu_formal) != PARM_DECL)\n \t    continue;\n \n \t  /* If this is 'Null_Parameter, pass a zero even though we are\n@@ -1812,24 +1812,24 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t   && 0 >= compare_tree_int (gnu_actual_size,\n \t\t\t\t\t\t   BITS_PER_WORD))\n \t    gnu_actual\n-\t      = unchecked_convert\n-\t\t(DECL_ARG_TYPE (get_gnu_tree (gnat_formal)),\n-\t\t convert (gnat_type_for_size\n-\t\t\t  (tree_low_cst (gnu_actual_size, 1), 1),\n-\t\t\t  integer_zero_node), 0);\n+\t      = unchecked_convert (DECL_ARG_TYPE (gnu_formal),\n+\t\t\t\t   convert (gnat_type_for_size\n+\t\t\t\t\t    (tree_low_cst (gnu_actual_size, 1),\n+\t\t\t\t\t     1),\n+\t\t\t\t\t    integer_zero_node),\n+\t\t\t\t   false);\n \t  else\n-\t    gnu_actual = convert (TYPE_MAIN_VARIANT\n-\t\t\t\t  (DECL_ARG_TYPE (get_gnu_tree (gnat_formal))),\n-\t\t\t\t  gnu_actual);\n+\t    gnu_actual\n+\t      = convert (TYPE_MAIN_VARIANT (DECL_ARG_TYPE (gnu_formal)),\n+\t\t\t gnu_actual);\n \t}\n \n-      gnu_actual_list = chainon (gnu_actual_list,\n-\t\t\t\t build_tree_list (NULL_TREE, gnu_actual));\n+      gnu_actual_list = tree_cons (NULL_TREE, gnu_actual, gnu_actual_list);\n     }\n \n   gnu_subprog_call = build (CALL_EXPR, TREE_TYPE (gnu_subprog_type),\n-\t\t\t    gnu_subprog_addr, gnu_actual_list, NULL_TREE);\n-  TREE_SIDE_EFFECTS (gnu_subprog_call) = 1;\n+\t\t\t    gnu_subprog_addr, nreverse (gnu_actual_list),\n+\t\t\t    NULL_TREE);\n \n   /* If it is a function call, the result is the call expression.  */\n   if (Nkind (gnat_node) == N_Function_Call)\n@@ -1861,13 +1861,15 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t  tree gnu_name;\n \n \t  gnu_subprog_call = protect_multiple_eval (gnu_subprog_call);\n+\t  gnu_name_list = nreverse (gnu_name_list);\n \n \t  /* If any of the names had side-effects, ensure they are all\n \t     evaluated before the call.  */\n \t  for (gnu_name = gnu_name_list; gnu_name;\n \t       gnu_name = TREE_CHAIN (gnu_name))\n \t    if (TREE_SIDE_EFFECTS (TREE_VALUE (gnu_name)))\n-\t      add_stmt (TREE_VALUE (gnu_name));\n+\t      append_to_statement_list (TREE_VALUE (gnu_name),\n+\t\t\t\t\t&gnu_before_list);\n \t}\n \n       if (Nkind (Name (gnat_node)) == N_Explicit_Dereference)\n@@ -1881,14 +1883,13 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t   gnat_actual = Next_Actual (gnat_actual))\n \t/* If we are dealing with a copy in copy out parameter, we must\n \t   retrieve its value from the record returned in the call.  */\n-\tif (! (present_gnu_tree (gnat_formal)\n-\t       && TREE_CODE (get_gnu_tree (gnat_formal)) == PARM_DECL\n-\t       && (DECL_BY_REF_P (get_gnu_tree (gnat_formal))\n-\t\t   || (TREE_CODE (get_gnu_tree (gnat_formal)) == PARM_DECL\n-\t\t       && ((DECL_BY_COMPONENT_PTR_P\n-\t\t\t    (get_gnu_tree (gnat_formal))\n-\t\t\t    || (DECL_BY_DESCRIPTOR_P\n-\t\t\t\t(get_gnu_tree (gnat_formal))))))))\n+\tif (!(present_gnu_tree (gnat_formal)\n+\t      && TREE_CODE (get_gnu_tree (gnat_formal)) == PARM_DECL\n+\t      && (DECL_BY_REF_P (get_gnu_tree (gnat_formal))\n+\t\t  || (TREE_CODE (get_gnu_tree (gnat_formal)) == PARM_DECL\n+\t\t      && ((DECL_BY_COMPONENT_PTR_P (get_gnu_tree (gnat_formal))\n+\t\t\t   || (DECL_BY_DESCRIPTOR_P\n+\t\t\t       (get_gnu_tree (gnat_formal))))))))\n \t    && Ekind (gnat_formal) != E_In_Parameter)\n \t  {\n \t    /* Get the value to assign to this OUT or IN OUT parameter.  It is\n@@ -1897,7 +1898,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t    tree gnu_result\n \t      = length == 1 ? gnu_subprog_call\n \t\t: build_component_ref (gnu_subprog_call, NULL_TREE,\n-\t\t\t\t       TREE_PURPOSE (scalar_return_list), 0);\n+\t\t\t\t       TREE_PURPOSE (scalar_return_list),\n+\t\t\t\t       false);\n \t    bool unchecked_conversion = (Nkind (gnat_actual)\n \t\t\t\t\t == N_Unchecked_Type_Conversion);\n \t    /* If the actual is a conversion, get the inner expression, which\n@@ -1932,9 +1934,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t  gnu_result = emit_range_check (gnu_result,\n \t\t\t\t\t\t Etype (gnat_actual));\n \n-\t\tif (! (! TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_actual)))\n-\t\t       && TREE_CONSTANT (TYPE_SIZE\n-\t\t\t\t\t (TREE_TYPE (gnu_result)))))\n+\t\tif (!(!TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_actual)))\n+\t\t      && TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_result)))))\n \t\t  gnu_result = convert (TREE_TYPE (gnu_actual), gnu_result);\n \t      }\n \t\t\n@@ -2011,10 +2012,12 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       gnu_jmpsave_decl = create_var_decl (get_identifier (\"JMPBUF_SAVE\"),\n \t\t\t\t\t  NULL_TREE, jmpbuf_ptr_type,\n \t\t\t\t\t  build_call_0_expr (get_jmpbuf_decl),\n-\t\t\t\t\t  0, 0, 0, 0, 0, gnat_node);\n+\t\t\t\t\t  false, false, false, false, NULL,\n+\t\t\t\t\t  gnat_node);\n       gnu_jmpbuf_decl = create_var_decl (get_identifier (\"JMP_BUF\"),\n \t\t\t\t\t NULL_TREE, jmpbuf_type,\n-\t\t\t\t\t NULL_TREE, 0, 0, 0, 0, 0, gnat_node);\n+\t\t\t\t\t NULL_TREE, false, false, false, false,\n+\t\t\t\t\t NULL, gnat_node);\n \n       set_block_jmpbuf_decl (gnu_jmpbuf_decl);\n \n@@ -2034,7 +2037,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \n   if (Present (First_Real_Statement (gnat_node)))\n     process_decls (Statements (gnat_node), Empty,\n-\t\t   First_Real_Statement (gnat_node), 1, 1);\n+\t\t   First_Real_Statement (gnat_node), true, true);\n \n   /* Generate code for each statement in the block.  */\n   for (gnat_temp = (Present (First_Real_Statement (gnat_node))\n@@ -2060,8 +2063,8 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \t\t  create_var_decl (get_identifier (\"EXCEPT_PTR\"),\n \t\t\t\t   NULL_TREE,\n \t\t\t\t   build_pointer_type (except_type_node),\n-\t\t\t\t   build_call_0_expr (get_excptr_decl),\n-\t\t\t\t   0, 0, 0, 0, 0, gnat_node));\n+\t\t\t\t   build_call_0_expr (get_excptr_decl), false,\n+\t\t\t\t   false, false, false, NULL, gnat_node));\n \n       /* Generate code for each handler. The N_Exception_Handler case does the\n \t real work and returns a COND_EXPR for each handler, which we chain\n@@ -2181,7 +2184,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t\t   (INDIRECT_REF, NULL_TREE,\n \t\t    TREE_VALUE (gnu_except_ptr_stack)),\n \t\t   get_identifier (\"not_handled_by_others\"), NULL_TREE,\n-\t\t   0)),\n+\t\t   false)),\n \t\t integer_zero_node);\n \t}\n \n@@ -2206,7 +2209,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t\t= build_component_ref\n \t\t  (build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t\t   TREE_VALUE (gnu_except_ptr_stack)),\n-\t\t   get_identifier (\"lang\"), NULL_TREE, 0);\n+\t\t   get_identifier (\"lang\"), NULL_TREE, false);\n \n \t      this_choice\n \t\t= build_binary_op\n@@ -2218,7 +2221,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t    }\n \t}\n       else\n-\tgigi_abort (318);\n+\tabort ();\n \n       gnu_choice = build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n \t\t\t\t    gnu_choice, this_choice);\n@@ -2279,7 +2282,7 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n \t     by the personality routine.  */\n \t}\n       else\n-\tgigi_abort (337);\n+\tabort ();\n \n       /* The GCC interface expects NULL to be passed for catch all handlers, so\n \t it would be quite tempting to set gnu_etypes_list to NULL if gnu_etype\n@@ -2314,7 +2317,8 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n   gnu_current_exc_ptr = build (EXC_PTR_EXPR, ptr_type_node);\n   gnu_incoming_exc_ptr = create_var_decl (get_identifier (\"EXPTR\"), NULL_TREE,\n \t\t\t\t\t  ptr_type_node, gnu_current_exc_ptr,\n-\t\t\t\t\t  0, 0, 0, 0, 0, gnat_node);\n+\t\t\t\t\t  false, false, false, false, NULL,\n+\t\t\t\t\t  gnat_node);\n \n   add_stmt_with_node (build_call_1_expr (begin_handler_decl,\n \t\t\t\t\t gnu_incoming_exc_ptr),\n@@ -2359,7 +2363,7 @@ gnat_to_gnu (Node_Id gnat_node)\n   if (type_annotate_only\n       && IN (Nkind (gnat_node), N_Subexpr)\n       && Nkind (gnat_node) != N_Identifier\n-      && ! Compile_Time_Known_Value (gnat_node))\n+      && !Compile_Time_Known_Value (gnat_node))\n     return build1 (NULL_EXPR, get_unpadded_type (Etype (gnat_node)),\n \t\t   build_call_raise (CE_Range_Check_Failed));\n \n@@ -2371,6 +2375,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   && Nkind (gnat_node) != N_Null_Statement)\n \t  || Nkind (gnat_node) == N_Procedure_Call_Statement\n \t  || Nkind (gnat_node) == N_Label\n+\t  || Nkind (gnat_node) == N_Implicit_Label_Declaration\n \t  || Nkind (gnat_node) == N_Handled_Sequence_Of_Statements\n \t  || ((Nkind (gnat_node) == N_Raise_Constraint_Error\n \t       || Nkind (gnat_node) == N_Raise_Storage_Error\n@@ -2416,7 +2421,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   will raise Constraint_Error and with biased representation, so\n \t   we don't.  */\n \tif (TREE_CONSTANT_OVERFLOW (gnu_result))\n-\t  gigi_abort (305);\n+\t  abort ();\n       }\n       break;\n \n@@ -2443,13 +2448,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gnu_result = UI_To_gnu (Corresponding_Integer_Value (gnat_node),\n \t\t\t\t  gnu_result_type);\n \t  if (TREE_CONSTANT_OVERFLOW (gnu_result))\n-\t    gigi_abort (305);\n+\t    abort ();\n \t}\n \n       /* We should never see a Vax_Float type literal, since the front end\n          is supposed to transform these using appropriate conversions */\n       else if (Vax_Float (Underlying_Type (Etype (gnat_node))))\n-\tgigi_abort (334);\n+\tabort ();\n \n       else\n         {\n@@ -2464,7 +2469,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_result = convert (gnu_result_type, integer_zero_node);\n \t  else\n \t    {\n-\t      if (! Is_Machine_Number (gnat_node))\n+\t      if (!Is_Machine_Number (gnat_node))\n \t\tur_realval\n \t\t  = Machine (Base_Type (Underlying_Type (Etype (gnat_node))),\n \t\t\t     ur_realval, Round_Even, gnat_node);\n@@ -2476,15 +2481,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t Otherwise, the base must be 2 and we scale the value, which\n \t\t we know can fit in the mantissa of the type (hence the use\n \t\t of that type above).  */\n-\t      if (Rbase (ur_realval) == 0)\n+\t      if (No (Rbase (ur_realval)))\n \t\tgnu_result\n \t\t  = build_binary_op (RDIV_EXPR,\n \t\t\t\t     get_base_type (gnu_result_type),\n \t\t\t\t     gnu_result,\n \t\t\t\t     UI_To_gnu (Denominator (ur_realval),\n \t\t\t\t\t\tgnu_result_type));\n \t      else if (Rbase (ur_realval) != 2)\n-\t\tgigi_abort (336);\n+\t\tabort ();\n \n \t      else\n \t\t{\n@@ -2560,8 +2565,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Pragma:\n-      gnu_result = alloc_stmt_list ();\n-      Pragma_to_gnu (gnat_node);\n+      gnu_result = Pragma_to_gnu (gnat_node);\n       break;\n \n     /**************************************/\n@@ -2588,14 +2592,14 @@ gnat_to_gnu (Node_Id gnat_node)\n       if (type_annotate_only\n \t  && (((Is_Array_Type (Etype (gnat_temp))\n \t\t|| Is_Record_Type (Etype (gnat_temp)))\n-\t       && ! Is_Constrained (Etype (gnat_temp)))\n+\t       && !Is_Constrained (Etype (gnat_temp)))\n \t    || Is_Concurrent_Type (Etype (gnat_temp))))\n \tbreak;\n \n       if (Present (Expression (gnat_node))\n-\t  && ! (Nkind (gnat_node) == N_Object_Declaration\n-\t\t&& No_Initialization (gnat_node))\n-\t  && (! type_annotate_only\n+\t  && !(Nkind (gnat_node) == N_Object_Declaration\n+\t       && No_Initialization (gnat_node))\n+\t  && (!type_annotate_only\n \t      || Compile_Time_Known_Value (Expression (gnat_node))))\n \t{\n \t  gnu_expr = gnat_to_gnu (Expression (gnat_node));\n@@ -2608,24 +2612,23 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  if (Present (Freeze_Node (gnat_temp)))\n \t    {\n \t      if ((Is_Public (gnat_temp) || global_bindings_p ())\n-\t\t  && ! TREE_CONSTANT (gnu_expr))\n+\t\t  && !TREE_CONSTANT (gnu_expr))\n \t\tgnu_expr\n \t\t  = create_var_decl (create_concat_name (gnat_temp, \"init\"),\n \t\t\t\t     NULL_TREE, TREE_TYPE (gnu_expr),\n-\t\t\t\t     gnu_expr, 0, Is_Public (gnat_temp), 0,\n-\t\t\t\t     0, 0, gnat_temp);\n+\t\t\t\t     gnu_expr, false, Is_Public (gnat_temp),\n+\t\t\t\t     false, false, NULL, gnat_temp);\n \t      else\n \t\tgnu_expr = maybe_variable (gnu_expr);\n \n-\t      save_gnu_tree (gnat_node, gnu_expr, 1);\n+\t      save_gnu_tree (gnat_node, gnu_expr, true);\n \t    }\n \t}\n       else\n-\tgnu_expr = 0;\n+\tgnu_expr = NULL_TREE;\n \n-      if (type_annotate_only && gnu_expr != 0\n-\t  && TREE_CODE (gnu_expr) == ERROR_MARK)\n-\tgnu_expr = 0;\n+      if (type_annotate_only && gnu_expr && TREE_CODE (gnu_expr) == ERROR_MARK)\n+\tgnu_expr = NULL_TREE;\n \n       if (No (Freeze_Node (gnat_temp)))\n \tgnat_to_gnu_entity (gnat_temp, gnu_expr, 1);\n@@ -2638,7 +2641,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t we are just annotating types and this object has a composite or task\n \t type, don't elaborate it.  We return the result in case it has any\n \t SAVE_EXPRs in it that need to be evaluated here.  */\n-      if (! Is_Renaming_Of_Object (gnat_temp)\n+      if (!Is_Renaming_Of_Object (gnat_temp)\n \t  && ! (type_annotate_only\n \t\t&& (Is_Array_Type (Etype (gnat_temp))\n \t\t    || Is_Record_Type (Etype (gnat_temp))\n@@ -2719,7 +2722,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t     i < ndim; i++, gnu_type = TREE_TYPE (gnu_type))\n \t  {\n \t    if (TREE_CODE (gnu_type) != ARRAY_TYPE)\n-\t      gigi_abort (307);\n+\t      abort ();\n \n \t    gnat_temp = gnat_expr_array[i];\n \t    gnu_expr = gnat_to_gnu (gnat_temp);\n@@ -2861,8 +2864,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t      == N_Attribute_Reference));\n \t  }\n \n-\tif (gnu_result == 0)\n-\t  gigi_abort (308);\n+\tif (!gnu_result)\n+\t  abort ();\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n       }\n@@ -2881,7 +2884,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t  (create_concat_name (Entity (Prefix (gnat_node)),\n \t\t\t\t       attribute == Attr_Elab_Body\n \t\t\t\t       ? \"elabb\" : \"elabs\"),\n-\t\t   NULL_TREE, void_ftype, NULL_TREE, 0, 1, 1, 0, gnat_node));\n+\t\t   NULL_TREE, void_ftype, NULL_TREE, false, true, true, NULL,\n+\t\t   gnat_node));\n \n \tgnu_result = Attribute_to_gnu (gnat_node, &gnu_result_type, attribute);\n       }\n@@ -2945,7 +2949,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t    (Next\n \t\t\t     (First (Component_Associations (gnat_node))))));\n \telse\n-\t  gigi_abort (312);\n+\t  abort ();\n \n \tgnu_result = convert (gnu_result_type, gnu_result);\n       }\n@@ -2984,7 +2988,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  tree gnu_obj_type = TREE_TYPE (gnu_result_type);\n \t  unsigned int oalign = TYPE_ALIGN (gnu_obj_type);\n \n-\t  if (align != 0 && align < oalign && ! TYPE_ALIGN_OK (gnu_obj_type))\n+\t  if (align != 0 && align < oalign && !TYPE_ALIGN_OK (gnu_obj_type))\n \t    post_error_ne_tree_2\n \t      (\"?source alignment (^) < alignment of & (^)\",\n \t       gnat_node, Designated_Type (Etype (gnat_node)),\n@@ -3019,7 +3023,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_high = TYPE_MAX_VALUE (gnu_range_type);\n \t  }\n \telse\n-\t  gigi_abort (313);\n+\t  abort ();\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n@@ -3115,7 +3119,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t/* If this is a shift whose count is not guaranteed to be correct,\n \t   we need to adjust the shift count.  */\n \tif (IN (Nkind (gnat_node), N_Op_Shift)\n-\t    && ! Shift_Count_OK (gnat_node))\n+\t    && !Shift_Count_OK (gnat_node))\n \t  {\n \t    tree gnu_count_type = get_base_type (TREE_TYPE (gnu_rhs));\n \t    tree gnu_max_shift\n@@ -3140,7 +3144,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t/* For right shifts, the type says what kind of shift to do,\n \t   so we may need to choose a different type.  */\n \tif (Nkind (gnat_node) == N_Op_Shift_Right\n-\t    && ! TYPE_UNSIGNED (gnu_type))\n+\t    && !TYPE_UNSIGNED (gnu_type))\n \t  gnu_type = gnat_unsigned_type (gnu_type);\n \telse if (Nkind (gnat_node) == N_Op_Shift_Right_Arithmetic\n \t\t && TYPE_UNSIGNED (gnu_type))\n@@ -3159,7 +3163,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   above in this case.  */\n \tif ((Nkind (gnat_node) == N_Op_Shift_Left\n \t     || Nkind (gnat_node) == N_Op_Shift_Right)\n-\t    && ! Shift_Count_OK (gnat_node))\n+\t    && !Shift_Count_OK (gnat_node))\n \t  gnu_result\n \t    = build_cond_expr\n \t      (gnu_type,\n@@ -3260,7 +3264,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      }\n \t  }\n \telse\n-\t  gigi_abort (315);\n+\t  abort ();\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \treturn build_allocator (gnu_type, gnu_init, gnu_result_type,\n@@ -3352,7 +3356,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Block_Statement:\n       start_stmt_group ();\n       gnat_pushlevel ();\n-      process_decls (Declarations (gnat_node), Empty, Empty, 1, 1);\n+      process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n       add_stmt (gnat_to_gnu (Handled_Statement_Sequence (gnat_node)));\n       gnat_poplevel ();\n       gnu_result = end_stmt_group ();\n@@ -3390,21 +3394,21 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   But if we have a return label defined, convert this into\n \t   a branch to that label.  */\n \n-\tif (TREE_VALUE (gnu_return_label_stack) != 0)\n+\tif (TREE_VALUE (gnu_return_label_stack))\n \t  {\n \t    gnu_result = build1 (GOTO_EXPR, void_type_node,\n \t\t\t\t TREE_VALUE (gnu_return_label_stack));\n \t    break;\n \t  }\n \n-\telse if (TYPE_CI_CO_LIST (gnu_subprog_type) != NULL_TREE)\n+\telse if (TYPE_CI_CO_LIST (gnu_subprog_type))\n \t  {\n \t    if (list_length (TYPE_CI_CO_LIST (gnu_subprog_type)) == 1)\n \t      gnu_ret_val = TREE_VALUE (TYPE_CI_CO_LIST (gnu_subprog_type));\n \t    else\n \t      gnu_ret_val\n \t\t= gnat_build_constructor (TREE_TYPE (gnu_subprog_type),\n-\t\t\t\t     TYPE_CI_CO_LIST (gnu_subprog_type));\n+\t\t\t\t\t  TYPE_CI_CO_LIST (gnu_subprog_type));\n \t  }\n \n \t/* If the Ada subprogram is a function, we just need to return the\n@@ -3529,7 +3533,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       start_stmt_group ();\n       process_decls (Visible_Declarations (gnat_node),\n-\t\t     Private_Declarations (gnat_node), Empty, 1, 1);\n+\t\t     Private_Declarations (gnat_node), Empty, true, true);\n       gnu_result = end_stmt_group ();\n       break;\n \n@@ -3543,7 +3547,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t}\n \n       start_stmt_group ();\n-      process_decls (Declarations (gnat_node), Empty, Empty, 1, 1);\n+      process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n \n       if (Present (Handled_Statement_Sequence (gnat_node)))\n \tadd_stmt (gnat_to_gnu (Handled_Statement_Sequence (gnat_node)));\n@@ -3587,12 +3591,12 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* For a body, first process the spec if there is one. */\n       if (Nkind (Unit (gnat_node)) == N_Package_Body\n \t  || (Nkind (Unit (gnat_node)) == N_Subprogram_Body\n-\t      && ! Acts_As_Spec (gnat_node)))\n+\t      && !Acts_As_Spec (gnat_node)))\n \tadd_stmt (gnat_to_gnu (Library_Unit (gnat_node)));\n \n       process_inlined_subprograms (gnat_node);\n       process_decls (Declarations (Aux_Decls_Node (gnat_node)),\n-\t\t     Empty, Empty, 1, 1);\n+\t\t     Empty, Empty, true, true);\n       add_stmt (gnat_to_gnu (Unit (gnat_node)));\n \n       /* Process any pragmas and actions following the unit.  */\n@@ -3623,12 +3627,12 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* If there is an At_End procedure attached to this node, and the EH\n \t mechanism is SJLJ, we must have at least a corresponding At_End\n \t handler, unless the No_Exception_Handlers restriction is set.  */\n-      if (! type_annotate_only\n+      if (!type_annotate_only\n \t  && Exception_Mechanism == Setjmp_Longjmp\n \t  && Present (At_End_Proc (gnat_node))\n-\t  && ! Present (Exception_Handlers (gnat_node))\n-\t  && ! No_Exception_Handlers_Set())\n-\tgigi_abort (335);\n+\t  && !Present (Exception_Handlers (gnat_node))\n+\t  && !No_Exception_Handlers_Set())\n+\tabort ();\n \n       gnu_result = Handled_Sequence_Of_Statements_to_gnu (gnat_node);\n       break;\n@@ -3680,7 +3684,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t equivalent for GNAT_TEMP.  When the object is frozen,\n \t gnat_to_gnu_entity will do the right thing. */\n       save_gnu_tree (Entity (Name (gnat_node)),\n-\t\t     gnat_to_gnu (Expression (gnat_node)), 1);\n+\t\t     gnat_to_gnu (Expression (gnat_node)), true);\n       break;\n \n     case N_Enumeration_Representation_Clause:\n@@ -3691,11 +3695,11 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Code_Statement:\n-      if (! type_annotate_only)\n+      if (!type_annotate_only)\n \t{\n \t  tree gnu_template = gnat_to_gnu (Asm_Template (gnat_node));\n-\t  tree gnu_input_list = 0, gnu_output_list = 0;\n-\t  tree gnu_clobber_list = 0;\n+\t  tree gnu_input_list = NULL_TREE, gnu_output_list = NULL_TREE;\n+\t  tree gnu_clobber_list = NULL_TREE;\n \t  char *clobber;\n \n \t  /* First process inputs, then outputs, then clobbers.  */\n@@ -3724,7 +3728,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    }\n \n \t  Clobber_Setup (gnat_node);\n-\t  while ((clobber = Clobber_Get_Next ()) != 0)\n+\t  while ((clobber = Clobber_Get_Next ()))\n \t    gnu_clobber_list\n \t      = tree_cons (NULL_TREE,\n \t\t\t   build_string (strlen (clobber) + 1, clobber),\n@@ -3749,19 +3753,19 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Freeze_Entity:\n       start_stmt_group ();\n       process_freeze_entity (gnat_node);\n-      process_decls (Actions (gnat_node), Empty, Empty, 1, 1);\n+      process_decls (Actions (gnat_node), Empty, Empty, true, true);\n       gnu_result = end_stmt_group ();\n       break;\n \n     case N_Itype_Reference:\n-      if (! present_gnu_tree (Itype (gnat_node)))\n+      if (!present_gnu_tree (Itype (gnat_node)))\n \tprocess_type (Itype (gnat_node));\n \n       gnu_result = alloc_stmt_list ();\n       break;\n \n     case N_Free_Statement:\n-      if (! type_annotate_only)\n+      if (!type_annotate_only)\n \t{\n \t  tree gnu_ptr = gnat_to_gnu (Expression (gnat_node));\n \t  tree gnu_obj_type;\n@@ -3880,8 +3884,8 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Component_Association:\n     case N_Task_Body:\n     default:\n-      if (! type_annotate_only)\n-\tgigi_abort (321);\n+      if (!type_annotate_only)\n+\tabort ();\n \n       gnu_result = alloc_stmt_list ();\n     }\n@@ -3951,22 +3955,22 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  || (Nkind (Parent (gnat_node)) == N_Procedure_Call_Statement\n \t      && Name (Parent (gnat_node)) != gnat_node)\n \t  || (Nkind (Parent (gnat_node)) == N_Unchecked_Type_Conversion\n-\t      && ! AGGREGATE_TYPE_P (gnu_result_type)\n-\t      && ! AGGREGATE_TYPE_P (TREE_TYPE (gnu_result)))\n+\t      && !AGGREGATE_TYPE_P (gnu_result_type)\n+\t      && !AGGREGATE_TYPE_P (TREE_TYPE (gnu_result)))\n \t  || Nkind (Parent (gnat_node)) == N_Parameter_Association)\n-      && ! (TYPE_SIZE (gnu_result_type) != 0\n-\t    && TYPE_SIZE (TREE_TYPE (gnu_result)) != 0\n-\t    && (AGGREGATE_TYPE_P (gnu_result_type)\n-\t\t== AGGREGATE_TYPE_P (TREE_TYPE (gnu_result)))\n-\t    && ((TREE_CODE (TYPE_SIZE (gnu_result_type)) == INTEGER_CST\n-\t\t && (TREE_CODE (TYPE_SIZE (TREE_TYPE (gnu_result)))\n-\t\t     != INTEGER_CST))\n-\t\t|| (TREE_CODE (TYPE_SIZE (gnu_result_type)) != INTEGER_CST\n-\t\t    && ! CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type))\n-\t\t    && (CONTAINS_PLACEHOLDER_P\n-\t\t\t(TYPE_SIZE (TREE_TYPE (gnu_result))))))\n-\t    && ! (TREE_CODE (gnu_result_type) == RECORD_TYPE\n-\t\t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_result_type))))\n+      && !(TYPE_SIZE (gnu_result_type)\n+\t   && TYPE_SIZE (TREE_TYPE (gnu_result))\n+\t   && (AGGREGATE_TYPE_P (gnu_result_type)\n+\t       == AGGREGATE_TYPE_P (TREE_TYPE (gnu_result)))\n+\t   && ((TREE_CODE (TYPE_SIZE (gnu_result_type)) == INTEGER_CST\n+\t\t&& (TREE_CODE (TYPE_SIZE (TREE_TYPE (gnu_result)))\n+\t\t    != INTEGER_CST))\n+\t       || (TREE_CODE (TYPE_SIZE (gnu_result_type)) != INTEGER_CST\n+\t\t   && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type))\n+\t\t   && (CONTAINS_PLACEHOLDER_P\n+\t\t       (TYPE_SIZE (TREE_TYPE (gnu_result))))))\n+\t   && !(TREE_CODE (gnu_result_type) == RECORD_TYPE\n+\t\t&& TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_result_type))))\n     {\n       /* In this case remove padding only if the inner object is of\n \t self-referential size: in that case it must be an object of\n@@ -3984,7 +3988,7 @@ gnat_to_gnu (Node_Id gnat_node)\n   else if (TREE_CODE (gnu_result) == LABEL_DECL\n \t   || TREE_CODE (gnu_result) == FIELD_DECL\n \t   || TREE_CODE (gnu_result) == ERROR_MARK\n-\t   || (TYPE_SIZE (gnu_result_type) != 0\n+\t   || (TYPE_SIZE (gnu_result_type)\n \t       && TREE_CODE (TYPE_SIZE (gnu_result_type)) != INTEGER_CST\n \t       && TREE_CODE (gnu_result) != INDIRECT_REF\n \t       && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type)))\n@@ -4026,7 +4030,7 @@ record_code_position (Node_Id gnat_node)\n   tree stmt_stmt = build (STMT_STMT, void_type_node, NULL_TREE);\n \n   add_stmt_with_node (stmt_stmt, gnat_node);\n-  save_gnu_tree (gnat_node, stmt_stmt, 1);\n+  save_gnu_tree (gnat_node, stmt_stmt, true);\n }\n \n /* Insert the code for GNAT_NODE at the position saved for that node.  */\n@@ -4035,7 +4039,7 @@ static void\n insert_code_for (Node_Id gnat_node)\n {\n   STMT_STMT_STMT (get_gnu_tree (gnat_node)) = gnat_to_gnu (gnat_node);\n-  save_gnu_tree (gnat_node, NULL_TREE, 1);\n+  save_gnu_tree (gnat_node, NULL_TREE, true);\n }\n \f\n /* Start a new statement group chained to the previous group.  */\n@@ -4069,7 +4073,7 @@ add_stmt (tree gnu_stmt)\n      ??? If this is a DECL_EXPR for a VAR_DECL or CONST_DECL, we must\n      walk the sizes and DECL_INITIAL since we won't be walking the\n      BIND_EXPR here.  This whole thing is a mess!  */\n-  if (!current_function_decl)\n+  if (global_bindings_p ())\n     {\n       walk_tree (&gnu_stmt, mark_visited, NULL, NULL);\n       if (TREE_CODE (gnu_stmt) == DECL_EXPR\n@@ -4353,7 +4357,10 @@ gnat_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED, tree *post_p)\n \t\t\t  convert (build_pointer_type (TREE_TYPE (expr)),\n \t\t\t\t   integer_zero_node));\n       else\n-\t*expr_p = create_tmp_var (TREE_TYPE (expr), NULL);\n+\t{\n+\t  *expr_p = create_tmp_var (TREE_TYPE (expr), NULL);\n+\t  TREE_NO_WARNING (*expr_p) = 1;\n+\t}\n \n       append_to_statement_list (TREE_OPERAND (expr, 0), post_p);\n       return GS_OK;\n@@ -4364,6 +4371,20 @@ gnat_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED, tree *post_p)\n       *expr_p = TREE_OPERAND (*expr_p, 0);\n       return GS_OK;\n \n+    case COMPONENT_REF:\n+      /* We have a kludge here.  If the FIELD_DECL is from a fat pointer\n+\t and is from an early dummy type, replace it with the proper\n+\t FIELD_DECL.  */\n+      if (TYPE_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (*expr_p, 0)))\n+\t  && DECL_ORIGINAL_FIELD (TREE_OPERAND (*expr_p, 1)))\n+\t{\n+\t  TREE_OPERAND (*expr_p, 1)\n+\t    = DECL_ORIGINAL_FIELD (TREE_OPERAND (*expr_p, 1));\n+\t  return GS_OK;\n+\t}\n+\n+      /* ... fall through ... */\n+\n     default:\n       return GS_UNHANDLED;\n     }\n@@ -4449,31 +4470,6 @@ gnat_gimplify_stmt (tree *stmt_p)\n     }\n }\n \f\n-/* Generate the RTL for the body of GNU_DECL.  If NESTED_P is nonzero,\n-   then we are already in the process of generating RTL for another\n-   function.  */\n-\n-static void\n-gnat_expand_body_1 (tree gnu_decl, bool nested_p)\n-{\n-  if (nested_p)\n-    push_function_context ();\n-\n-  tree_rest_of_compilation (gnu_decl, nested_p);\n-\n-  if (nested_p)\n-    pop_function_context ();\n-}\n-\n-/* Expand the body of GNU_DECL, which is not a nested function.  */\n-\n-void\n-gnat_expand_body (tree gnu_decl)\n-{\n-  if (DECL_INITIAL (gnu_decl) && DECL_INITIAL (gnu_decl) != error_mark_node)\n-    gnat_expand_body_1 (gnu_decl, false);\n-}\n-\f\n /* Force references to each of the entities in packages GNAT_NODE with's\n    so that the debugging information for all of them are identical\n    in all clients.  Operate recursively on anything it with's, but check\n@@ -4504,7 +4500,7 @@ elaborate_all_entities (Node_Id gnat_node)\n      same generic unit repeatedly */\n \n   if (!present_gnu_tree (gnat_node))\n-     save_gnu_tree (gnat_node, integer_zero_node, 1);\n+     save_gnu_tree (gnat_node, integer_zero_node, true);\n \n   /* Save entities in all context units. A body may have an implicit_with\n      on its own spec, if the context includes a child unit, so don't save\n@@ -4514,7 +4510,7 @@ elaborate_all_entities (Node_Id gnat_node)\n        Present (gnat_with_clause);\n        gnat_with_clause = Next (gnat_with_clause))\n     if (Nkind (gnat_with_clause) == N_With_Clause\n-\t&& ! present_gnu_tree (Library_Unit (gnat_with_clause))\n+\t&& !present_gnu_tree (Library_Unit (gnat_with_clause))\n         && Library_Unit (gnat_with_clause) != Library_Unit (Cunit (Main_Unit)))\n       {\n \telaborate_all_entities (Library_Unit (gnat_with_clause));\n@@ -4529,13 +4525,13 @@ elaborate_all_entities (Node_Id gnat_node)\n \t\t  && Ekind (gnat_entity) != E_Package\n \t\t  && Ekind (gnat_entity) != E_Package_Body\n \t\t  && Ekind (gnat_entity) != E_Operator\n-\t\t  && ! (IN (Ekind (gnat_entity), Type_Kind)\n-\t\t\t&& ! Is_Frozen (gnat_entity))\n-\t\t  && ! ((Ekind (gnat_entity) == E_Procedure\n-\t\t\t || Ekind (gnat_entity) == E_Function)\n-\t\t\t&& Is_Intrinsic_Subprogram (gnat_entity))\n-\t\t  && ! IN (Ekind (gnat_entity), Named_Kind)\n-\t\t  && ! IN (Ekind (gnat_entity), Generic_Unit_Kind))\n+\t\t  && !(IN (Ekind (gnat_entity), Type_Kind)\n+\t\t       && !Is_Frozen (gnat_entity))\n+\t\t  && !((Ekind (gnat_entity) == E_Procedure\n+\t\t\t|| Ekind (gnat_entity) == E_Function)\n+\t\t       && Is_Intrinsic_Subprogram (gnat_entity))\n+\t\t  && !IN (Ekind (gnat_entity), Named_Kind)\n+\t\t  && !IN (Ekind (gnat_entity), Generic_Unit_Kind))\n \t\tgnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n           }\n         else if (Ekind (Entity (Name (gnat_with_clause))) == E_Generic_Package)\n@@ -4600,7 +4596,7 @@ process_freeze_entity (Node_Id gnat_node)\n   /* Don't do anything for subprograms that may have been elaborated before\n      their freeze nodes.  This can happen, for example because of an inner call\n      in an instance body.  */\n-  if (gnu_old != 0\n+  if (gnu_old\n        && TREE_CODE (gnu_old) == FUNCTION_DECL\n        && (Ekind (gnat_entity) == E_Function\n           || Ekind (gnat_entity) == E_Procedure))\n@@ -4611,9 +4607,9 @@ process_freeze_entity (Node_Id gnat_node)\n      delayed, this node was never delayed as it should have been.\n      Also allow this to happen for concurrent types since we may have\n      frozen both the Corresponding_Record_Type and this type.  */\n-  if (gnu_old != 0\n-      && ! (TREE_CODE (gnu_old) == TYPE_DECL\n-  \t    && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old))))\n+  if (gnu_old\n+      && !(TREE_CODE (gnu_old) == TYPE_DECL\n+\t   && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old))))\n     {\n       if (IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n   \t  && Present (Full_View (gnat_entity))\n@@ -4622,23 +4618,23 @@ process_freeze_entity (Node_Id gnat_node)\n       else if (Is_Concurrent_Type (gnat_entity))\n \treturn;\n       else\n-\tgigi_abort (320);\n+\tabort ();\n     }\n \n   /* Reset the saved tree, if any, and elaborate the object or type for real.\n      If there is a full declaration, elaborate it and copy the type to\n      GNAT_ENTITY.  Likewise if this is the record subtype corresponding to\n      a class wide type or subtype.  */\n-  if (gnu_old != 0)\n+  if (gnu_old)\n     {\n-      save_gnu_tree (gnat_entity, NULL_TREE, 0);\n+      save_gnu_tree (gnat_entity, NULL_TREE, false);\n       if (IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n   \t  && Present (Full_View (gnat_entity))\n   \t  && present_gnu_tree (Full_View (gnat_entity)))\n-  \tsave_gnu_tree (Full_View (gnat_entity), NULL_TREE, 0);\n+  \tsave_gnu_tree (Full_View (gnat_entity), NULL_TREE, false);\n       if (Present (Class_Wide_Type (gnat_entity))\n \t  && Class_Wide_Type (gnat_entity) != gnat_entity)\n-\tsave_gnu_tree (Class_Wide_Type (gnat_entity), NULL_TREE, 0);\n+\tsave_gnu_tree (Class_Wide_Type (gnat_entity), NULL_TREE, false);\n     }\n \n   if (IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n@@ -4649,18 +4645,18 @@ process_freeze_entity (Node_Id gnat_node)\n       /* The above call may have defined this entity (the simplest example\n   \t of this is when we have a private enumeral type since the bounds\n   \t will have the public view.  */\n-      if (! present_gnu_tree (gnat_entity))\n-  \tsave_gnu_tree (gnat_entity, gnu_new, 0);\n+      if (!present_gnu_tree (gnat_entity))\n+  \tsave_gnu_tree (gnat_entity, gnu_new, false);\n       if (Present (Class_Wide_Type (gnat_entity))\n \t  && Class_Wide_Type (gnat_entity) != gnat_entity)\n-\tsave_gnu_tree (Class_Wide_Type (gnat_entity), gnu_new, 0);\n+\tsave_gnu_tree (Class_Wide_Type (gnat_entity), gnu_new, false);\n     }\n   else\n     gnu_new = gnat_to_gnu_entity (gnat_entity, gnu_init, 1);\n \n   /* If we've made any pointers to the old version of this type, we\n      have to update them.  */\n-  if (gnu_old != 0)\n+  if (gnu_old)\n     update_pointer_to (TYPE_MAIN_VARIANT (TREE_TYPE (gnu_old)),\n \t\t       TREE_TYPE (gnu_new));\n }\n@@ -4676,7 +4672,7 @@ process_inlined_subprograms (Node_Id gnat_node)\n \n   /* If we can inline, generate RTL for all the inlined subprograms.\n      Define the entity first so we set DECL_EXTERNAL.  */\n-  if (optimize > 0 && ! flag_no_inline)\n+  if (optimize > 0 && !flag_no_inline)\n     for (gnat_entity = First_Inlined_Subprogram (gnat_node);\n \t Present (gnat_entity);\n \t gnat_entity = Next_Inlined_Subprogram (gnat_entity))\n@@ -4716,7 +4712,7 @@ process_inlined_subprograms (Node_Id gnat_node)\n \n static void\n process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n-               Node_Id gnat_end_list, int pass1p, int pass2p)\n+               Node_Id gnat_end_list, bool pass1p, bool pass2p)\n {\n   List_Id gnat_decl_array[2];\n   Node_Id gnat_decl;\n@@ -4737,14 +4733,14 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t\t\t   == N_Package_Specification)))\n \t      process_decls (Visible_Declarations (Specification (gnat_decl)),\n \t\t\t     Private_Declarations (Specification (gnat_decl)),\n-\t\t\t     Empty, 1, 0);\n+\t\t\t     Empty, true, false);\n \n \t    /* Similarly for any declarations in the actions of a\n \t       freeze node.  */\n \t    else if (Nkind (gnat_decl) == N_Freeze_Entity)\n \t      {\n \t\tprocess_freeze_entity (gnat_decl);\n-\t\tprocess_decls (Actions (gnat_decl), Empty, Empty, 1, 0);\n+\t\tprocess_decls (Actions (gnat_decl), Empty, Empty, true, false);\n \t      }\n \n \t    /* Package bodies with freeze nodes get their elaboration deferred\n@@ -4818,10 +4814,10 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t\t\t\t== N_Package_Specification)))\n \t      process_decls (Visible_Declarations (Specification (gnat_decl)),\n \t\t\t     Private_Declarations (Specification (gnat_decl)),\n-\t\t\t     Empty, 0, 1);\n+\t\t\t     Empty, false, true);\n \n \t    else if (Nkind (gnat_decl) == N_Freeze_Entity)\n-\t      process_decls (Actions (gnat_decl), Empty, Empty, 0, 1);\n+\t      process_decls (Actions (gnat_decl), Empty, Empty, false, true);\n \t  }\n }\n \f\n@@ -4914,11 +4910,10 @@ emit_index_check (tree gnu_array_object,\n      gnu_expr, CE_Index_Check_Failed);\n }\n \f\n-/* Given GNU_COND which contains the condition corresponding to an access,\n-   discriminant or range check, of value GNU_EXPR, build a COND_EXPR\n-   that returns GNU_EXPR if GNU_COND is false and raises a\n-   CONSTRAINT_ERROR if GNU_COND is true.  REASON is the code that says\n-   why the exception was raised.  */\n+/* GNU_COND contains the condition corresponding to an access, discriminant or\n+   range check of value GNU_EXPR.  Build a COND_EXPR that returns GNU_EXPR if\n+   GNU_COND is false and raises a CONSTRAINT_ERROR if GNU_COND is true. \n+   REASON is the code that says why the exception was raised.  */\n \n static tree\n emit_check (tree gnu_cond, tree gnu_expr, int reason)\n@@ -4959,11 +4954,8 @@ emit_check (tree gnu_cond, tree gnu_expr, int reason)\n    truncation; otherwise round.  */\n \n static tree\n-convert_with_check (Entity_Id gnat_type,\n-                    tree gnu_expr,\n-                    int overflow_p,\n-                    int range_p,\n-                    int truncate_p)\n+convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n+\t\t    bool rangep, bool truncatep)\n {\n   tree gnu_type = get_unpadded_type (gnat_type);\n   tree gnu_in_type = TREE_TYPE (gnu_expr);\n@@ -4976,8 +4968,8 @@ convert_with_check (Entity_Id gnat_type,\n      the input is not a floating type, just do the conversion.  This\n      shortcut is required to avoid problems with packed array types\n      and simplifies code in all cases anyway.   */\n-  if (! range_p && ! overflow_p && INTEGRAL_TYPE_P (gnu_base_type)\n-      && ! FLOAT_TYPE_P (gnu_in_type))\n+  if (!rangep && !overflowp && INTEGRAL_TYPE_P (gnu_base_type)\n+      && !FLOAT_TYPE_P (gnu_in_type))\n     return convert (gnu_type, gnu_expr);\n \n   /* First convert the expression to its base type.  This\n@@ -4991,8 +4983,8 @@ convert_with_check (Entity_Id gnat_type,\n   /* If overflow checks are requested,  we need to be sure the result will\n      fit in the output base type.  But don't do this if the input\n      is integer and the output floating-point.  */\n-  if (overflow_p\n-      && ! (FLOAT_TYPE_P (gnu_base_type) && INTEGRAL_TYPE_P (gnu_in_basetype)))\n+  if (overflowp\n+      && !(FLOAT_TYPE_P (gnu_base_type) && INTEGRAL_TYPE_P (gnu_in_basetype)))\n     {\n       /* Ensure GNU_EXPR only gets evaluated once.  */\n       tree gnu_input = protect_multiple_eval (gnu_result);\n@@ -5054,15 +5046,15 @@ convert_with_check (Entity_Id gnat_type,\n \t\t\t\t\t       convert (gnu_in_basetype,\n \t\t\t\t\t\t\tgnu_out_ub))));\n \n-      if (! integer_zerop (gnu_cond))\n+      if (!integer_zerop (gnu_cond))\n \tgnu_result = emit_check (gnu_cond, gnu_input,\n \t                         CE_Overflow_Check_Failed);\n     }\n \n   /* Now convert to the result base type.  If this is a non-truncating\n      float-to-integer conversion, round.  */\n   if (INTEGRAL_TYPE_P (gnu_ada_base_type) && FLOAT_TYPE_P (gnu_in_basetype)\n-      && ! truncate_p)\n+      && !truncatep)\n     {\n       tree gnu_point_5 = build_real (gnu_in_basetype, dconstp5);\n       tree gnu_minus_point_5 = build_real (gnu_in_basetype, dconstmp5);\n@@ -5080,17 +5072,17 @@ convert_with_check (Entity_Id gnat_type,\n   if (TREE_CODE (gnu_ada_base_type) == INTEGER_TYPE\n       && TYPE_HAS_ACTUAL_BOUNDS_P (gnu_ada_base_type)\n       && TREE_CODE (gnu_result) == UNCONSTRAINED_ARRAY_REF)\n-    gnu_result = unchecked_convert (gnu_ada_base_type, gnu_result, 0);\n+    gnu_result = unchecked_convert (gnu_ada_base_type, gnu_result, false);\n   else\n     gnu_result = convert (gnu_ada_base_type, gnu_result);\n \n   /* Finally, do the range check if requested.  Note that if the\n      result type is a modular type, the range check is actually\n      an overflow check.  */\n \n-  if (range_p\n+  if (rangep\n       || (TREE_CODE (gnu_base_type) == INTEGER_TYPE\n-\t  && TYPE_MODULAR_P (gnu_base_type) && overflow_p))\n+\t  && TYPE_MODULAR_P (gnu_base_type) && overflowp))\n     gnu_result = emit_range_check (gnu_result, gnat_type);\n \n   return convert (gnu_type, gnu_result);\n@@ -5101,7 +5093,7 @@ convert_with_check (Entity_Id gnat_type,\n    reference.  This returns the same as gnat_mark_addressable in most\n    cases.  */\n \n-static int\n+static bool\n addressable_p (tree gnu_expr)\n {\n   switch (TREE_CODE (gnu_expr))\n@@ -5112,19 +5104,19 @@ addressable_p (tree gnu_expr)\n     case RESULT_DECL:\n       /* All DECLs are addressable: if they are in a register, we can force\n \t them to memory.  */\n-      return 1;\n+      return true;\n \n     case UNCONSTRAINED_ARRAY_REF:\n     case INDIRECT_REF:\n     case CONSTRUCTOR:\n     case NULL_EXPR:\n     case SAVE_EXPR:\n-      return 1;\n+      return true;\n \n     case COMPONENT_REF:\n-      return (! DECL_BIT_FIELD (TREE_OPERAND (gnu_expr, 1))\n-\t      && (! DECL_NONADDRESSABLE_P (TREE_OPERAND (gnu_expr, 1))\n-\t\t  || ! flag_strict_aliasing)\n+      return (!DECL_BIT_FIELD (TREE_OPERAND (gnu_expr, 1))\n+\t      && (!DECL_NONADDRESSABLE_P (TREE_OPERAND (gnu_expr, 1))\n+\t\t  || !flag_strict_aliasing)\n \t      && addressable_p (TREE_OPERAND (gnu_expr, 0)));\n \n     case ARRAY_REF:  case ARRAY_RANGE_REF:\n@@ -5155,7 +5147,7 @@ addressable_p (tree gnu_expr)\n       }\n \n     default:\n-      return 0;\n+      return false;\n     }\n }\n \f\n@@ -5180,20 +5172,20 @@ process_type (Entity_Id gnat_entity)\n       || (IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n \t  && Present (Full_View (gnat_entity))\n \t  && Freeze_Node (Full_View (gnat_entity))\n-\t  && ! present_gnu_tree (Full_View (gnat_entity))))\n+\t  && !present_gnu_tree (Full_View (gnat_entity))))\n     {\n       elaborate_entity (gnat_entity);\n \n-      if (gnu_old == 0)\n+      if (!gnu_old)\n         {\n \t  tree gnu_decl = create_type_decl (get_entity_name (gnat_entity),\n \t\t\t\t\t    make_dummy_type (gnat_entity),\n-\t\t\t\t\t    0, 0, 0, gnat_entity);\n+\t\t\t\t\t    NULL, false, false, gnat_entity);\n \n-\t  save_gnu_tree (gnat_entity, gnu_decl, 0);\n+\t  save_gnu_tree (gnat_entity, gnu_decl, false);\n \t  if (IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n \t      && Present (Full_View (gnat_entity)))\n-\t    save_gnu_tree (Full_View (gnat_entity), gnu_decl, 0);\n+\t    save_gnu_tree (Full_View (gnat_entity), gnu_decl, false);\n \t}\n \n       return;\n@@ -5203,31 +5195,31 @@ process_type (Entity_Id gnat_entity)\n      made the type that corresponds to the full type of an incomplete\n      type.  Clear that type for now and then update the type in the\n      pointers.  */\n-  if (gnu_old != 0)\n+  if (gnu_old)\n     {\n       if (TREE_CODE (gnu_old) != TYPE_DECL\n-\t  || ! TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old)))\n+\t  || !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old)))\n \t{\n \t  /* If this was a withed access type, this is not an error\n \t     and merely indicates we've already elaborated the type\n \t     already. */\n \t  if (Is_Type (gnat_entity) && From_With_Type (gnat_entity))\n \t    return;\n \n-\t  gigi_abort (323);\n+\t  abort ();\n \t}\n \n-      save_gnu_tree (gnat_entity, NULL_TREE, 0);\n+      save_gnu_tree (gnat_entity, NULL_TREE, false);\n     }\n \n   /* Now fully elaborate the type.  */\n   gnu_new = gnat_to_gnu_entity (gnat_entity, NULL_TREE, 1);\n   if (TREE_CODE (gnu_new) != TYPE_DECL)\n-    gigi_abort (324);\n+    abort ();\n \n   /* If we have an old type and we've made pointers to this type,\n      update those pointers.  */\n-  if (gnu_old != 0)\n+  if (gnu_old)\n     update_pointer_to (TYPE_MAIN_VARIANT (TREE_TYPE (gnu_old)),\n \t\t       TREE_TYPE (gnu_new));\n \n@@ -5244,9 +5236,9 @@ process_type (Entity_Id gnat_entity)\n \t= get_gnu_tree (Corresponding_Concurrent_Type (gnat_entity));\n \n       save_gnu_tree (Corresponding_Concurrent_Type (gnat_entity),\n-\t\t     NULL_TREE, 0);\n+\t\t     NULL_TREE, false);\n       save_gnu_tree (Corresponding_Concurrent_Type (gnat_entity),\n-\t\t     gnu_new, 0);\n+\t\t     gnu_new, false);\n \n       update_pointer_to (TYPE_MAIN_VARIANT (TREE_TYPE (gnu_task_old)),\n \t\t\t TREE_TYPE (gnu_new));\n@@ -5278,7 +5270,7 @@ assoc_to_constructor (Node_Id gnat_assoc, tree gnu_type)\n       /* The expander is supposed to put a single component selector name\n \t in every record component association */\n       if (Next (gnat_field))\n-\tgigi_abort (328);\n+\tabort ();\n \n       /* Before assigning a value in an aggregate make sure range checks\n \t are done if required.  Then convert to the type of the field.  */\n@@ -5295,8 +5287,8 @@ assoc_to_constructor (Node_Id gnat_assoc, tree gnu_type)\n \n   /* Verify every enty in GNU_LIST was used.  */\n   for (gnu_field = gnu_list; gnu_field; gnu_field = TREE_CHAIN (gnu_field))\n-    if (! TREE_ADDRESSABLE (gnu_field))\n-      gigi_abort (311);\n+    if (!TREE_ADDRESSABLE (gnu_field))\n+      abort ();\n \n   return gnu_result;\n }\n@@ -5364,7 +5356,7 @@ extract_values (tree values, tree record_type)\n \n       /* _Parent is an internal field, but may have values in the aggregate,\n \t so check for values first.  */\n-      if ((tem = purpose_member (field, values)) != 0)\n+      if ((tem = purpose_member (field, values)))\n \t{\n \t  value = TREE_VALUE (tem);\n \t  TREE_ADDRESSABLE (tem) = 1;\n@@ -5373,8 +5365,7 @@ extract_values (tree values, tree record_type)\n       else if (DECL_INTERNAL_P (field))\n \t{\n \t  value = extract_values (values, TREE_TYPE (field));\n-\t  if (TREE_CODE (value) == CONSTRUCTOR\n-\t      && CONSTRUCTOR_ELTS (value) == 0)\n+\t  if (TREE_CODE (value) == CONSTRUCTOR && !CONSTRUCTOR_ELTS (value))\n \t    value = 0;\n \t}\n       else\n@@ -5387,7 +5378,7 @@ extract_values (tree values, tree record_type)\n \t      TREE_ADDRESSABLE (tem) = 1;\n \t    }\n \n-      if (value == 0)\n+      if (!value)\n \tcontinue;\n \n       result = tree_cons (field, value, result);\n@@ -5423,7 +5414,7 @@ protect_multiple_eval (tree exp)\n   tree type = TREE_TYPE (exp);\n \n   /* If this has no side effects, we don't need to do anything.  */\n-  if (! TREE_SIDE_EFFECTS (exp))\n+  if (!TREE_SIDE_EFFECTS (exp))\n     return exp;\n \n   /* If it is a conversion, protect what's inside the conversion.\n@@ -5457,7 +5448,7 @@ protect_multiple_eval (tree exp)\n    whether to force evaluation of everything.  */\n \n tree\n-gnat_stabilize_reference (tree ref, int force)\n+gnat_stabilize_reference (tree ref, bool force)\n {\n   tree type = TREE_TYPE (ref);\n   enum tree_code code = TREE_CODE (ref);\n@@ -5555,7 +5546,7 @@ gnat_stabilize_reference (tree ref, int force)\n    arg to force a SAVE_EXPR for everything.  */\n \n static tree\n-gnat_stabilize_reference_1 (tree e, int force)\n+gnat_stabilize_reference_1 (tree e, bool force)\n {\n   enum tree_code code = TREE_CODE (e);\n   tree type = TREE_TYPE (e);\n@@ -5792,7 +5783,7 @@ post_error_ne_tree (const char *msg, Node_Id node, Entity_Id ent, tree t)\n   else\n     start_yes = '[', end_yes = ']', start_no = '{', end_no = '}';\n \n-  for (p = msg, q = newmsg; *p != 0; p++)\n+  for (p = msg, q = newmsg; *p; p++)\n     {\n       if (*p == start_yes)\n \tfor (p++; *p != end_yes; p++)\n@@ -5833,21 +5824,6 @@ set_second_error_entity (Entity_Id e)\n   Error_Msg_Node_2 = e;\n }\n \f\n-/* Signal abort, with \"Gigi abort\" as the error label, and error_gnat_node\n-   as the relevant node that provides the location info for the error */\n-\n-void\n-gigi_abort (int code)\n-{\n-  String_Template temp = {1, 10};\n-  Fat_Pointer fp;\n-\n-  fp.Array = \"Gigi abort\", fp.Bounds = &temp;\n-\n-  Current_Error_Node = error_gnat_node;\n-  Compiler_Abort (fp, code);\n-}\n-\f\n /* Initialize the table that maps GNAT codes to GCC codes for simple\n    binary and unary operations.  */\n "}, {"sha": "2dc27d39b719c85d5f5c56bdc3904f076b1a606a", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 199, "deletions": 187, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -149,16 +149,16 @@ init_gnat_to_gnu (void)\n    If GNU_DECL is zero, a previous association is to be reset.  */\n \n void\n-save_gnu_tree (Entity_Id gnat_entity, tree gnu_decl, int no_check)\n+save_gnu_tree (Entity_Id gnat_entity, tree gnu_decl, bool no_check)\n {\n   /* Check that GNAT_ENTITY is not already defined and that it is being set\n      to something which is a decl.  Raise gigi 401 if not.  Usually, this\n      means GNAT_ENTITY is defined twice, but occasionally is due to some\n      Gigi problem.  */\n   if (gnu_decl\n       && (associate_gnat_to_gnu[gnat_entity - First_Node_Id]\n-\t  || (! no_check && ! DECL_P (gnu_decl))))\n-    gigi_abort (401);\n+\t  || (!no_check && !DECL_P (gnu_decl))))\n+    abort ();\n \n   associate_gnat_to_gnu[gnat_entity - First_Node_Id] = gnu_decl;\n }\n@@ -173,18 +173,18 @@ save_gnu_tree (Entity_Id gnat_entity, tree gnu_decl, int no_check)\n tree\n get_gnu_tree (Entity_Id gnat_entity)\n {\n-  if (! associate_gnat_to_gnu[gnat_entity - First_Node_Id])\n-    gigi_abort (402);\n+  if (!associate_gnat_to_gnu[gnat_entity - First_Node_Id])\n+    abort ();\n \n   return associate_gnat_to_gnu[gnat_entity - First_Node_Id];\n }\n \n /* Return nonzero if a GCC tree has been associated with GNAT_ENTITY.  */\n \n-int\n+bool\n present_gnu_tree (Entity_Id gnat_entity)\n {\n-  return (associate_gnat_to_gnu[gnat_entity - First_Node_Id] != NULL_TREE);\n+  return (associate_gnat_to_gnu[gnat_entity - First_Node_Id]) != 0;\n }\n \n \f\n@@ -193,8 +193,8 @@ present_gnu_tree (Entity_Id gnat_entity)\n int\n global_bindings_p (void)\n {\n-  return (force_global != 0 || current_binding_level == 0\n-\t  || current_binding_level->chain == 0 ? -1 : 0);\n+  return (force_global || !current_binding_level\n+\t  || !current_binding_level->chain ? -1 : 0);\n }\n \n /* Enter a new binding level. */\n@@ -356,12 +356,12 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n      for now).  */\n \n   if (TREE_CODE (decl) == TYPE_DECL\n-      && DECL_NAME (decl) != 0\n-      && (TYPE_NAME (TREE_TYPE (decl)) == 0\n+      && DECL_NAME (decl)\n+      && (!TYPE_NAME (TREE_TYPE (decl))\n \t  || TREE_CODE (TYPE_NAME (TREE_TYPE (decl))) == IDENTIFIER_NODE\n \t  || (TREE_CODE (TYPE_NAME (TREE_TYPE (decl))) == TYPE_DECL\n \t      && DECL_ARTIFICIAL (TYPE_NAME (TREE_TYPE (decl)))\n-\t      && ! DECL_ARTIFICIAL (decl))))\n+\t      && !DECL_ARTIFICIAL (decl))))\n     TYPE_NAME (TREE_TYPE (decl)) = decl;\n \n   if (TREE_CODE (decl) != CONST_DECL)\n@@ -531,7 +531,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n       TYPE_PRECISION (longest_float_type_node) = LONG_DOUBLE_TYPE_SIZE;\n       layout_type (longest_float_type_node);\n       create_type_decl (get_identifier (\"longest float type\"),\n-\t\t\tlongest_float_type_node, NULL, 0, 1, Empty);\n+\t\t\tlongest_float_type_node, NULL, false, true, Empty);\n     }\n   else\n     longest_float_type_node = TREE_TYPE (long_long_float_type);\n@@ -540,10 +540,11 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \n   unsigned_type_node = gnat_type_for_size (INT_TYPE_SIZE, 1);\n   create_type_decl (get_identifier (\"unsigned int\"), unsigned_type_node,\n-\t\t    NULL, 0, 1, Empty);\n+\t\t    NULL, false, true, Empty);\n \n   void_type_decl_node = create_type_decl (get_identifier (\"void\"),\n-\t\t\t\t\t  void_type_node, NULL, 0, 1, Empty);\n+\t\t\t\t\t  void_type_node, NULL, false, true,\n+\t\t\t\t\t  Empty);\n \n   void_ftype = build_function_type (void_type_node, NULL_TREE);\n   ptr_void_ftype = build_pointer_type (void_ftype);\n@@ -559,7 +560,8 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t\t\t  tree_cons (NULL_TREE,\n \t\t\t\t\t\t\t\t     sizetype,\n \t\t\t\t\t\t\t\t     endlink)),\n-\t\t\t\t     NULL_TREE, 0, 1, 1, 0, Empty);\n+\t\t\t\t     NULL_TREE, false, true, true, NULL,\n+\t\t\t\t     Empty);\n \n   /* free is a function declaration tree for a function to free memory.  */\n   free_decl\n@@ -568,38 +570,38 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t\ttree_cons (NULL_TREE,\n \t\t\t\t\t\t\t   ptr_void_type_node,\n \t\t\t\t\t\t\t   endlink)),\n-\t\t\t   NULL_TREE, 0, 1, 1, 0, Empty);\n+\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n \n   /* Make the types and functions used for exception processing.    */\n   jmpbuf_type\n     = build_array_type (gnat_type_for_mode (Pmode, 0),\n \t\t\tbuild_index_type (build_int_2 (5, 0)));\n   create_type_decl (get_identifier (\"JMPBUF_T\"), jmpbuf_type, NULL,\n-\t\t    0, 1, Empty);\n+\t\t    false, true, Empty);\n   jmpbuf_ptr_type = build_pointer_type (jmpbuf_type);\n \n   /* Functions to get and set the jumpbuf pointer for the current thread.  */\n   get_jmpbuf_decl\n     = create_subprog_decl\n     (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n      NULL_TREE, build_function_type (jmpbuf_ptr_type, NULL_TREE),\n-     NULL_TREE, 0, 1, 1, 0, Empty);\n+     NULL_TREE, false, true, true, NULL, Empty);\n \n   set_jmpbuf_decl\n     = create_subprog_decl\n     (get_identifier (\"system__soft_links__set_jmpbuf_address_soft\"),\n      NULL_TREE,\n      build_function_type (void_type_node,\n \t\t\t  tree_cons (NULL_TREE, jmpbuf_ptr_type, endlink)),\n-     NULL_TREE, 0, 1, 1, 0, Empty);\n+     NULL_TREE, false, true, true, NULL, Empty);\n \n   /* Function to get the current exception.  */\n   get_excptr_decl\n     = create_subprog_decl\n     (get_identifier (\"system__soft_links__get_gnat_exception\"),\n      NULL_TREE,\n      build_function_type (build_pointer_type (except_type_node), NULL_TREE),\n-     NULL_TREE, 0, 1, 1, 0, Empty);\n+     NULL_TREE, false, true, true, NULL, Empty);\n \n   /* Functions that raise exceptions. */\n   raise_nodefer_decl\n@@ -609,7 +611,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t    tree_cons (NULL_TREE,\n \t\t\t\t       build_pointer_type (except_type_node),\n \t\t\t\t       endlink)),\n-       NULL_TREE, 0, 1, 1, 0, Empty);\n+       NULL_TREE, false, true, true, NULL, Empty);\n \n   /* Hooks to call when entering/leaving an exception handler.  */\n   begin_handler_decl\n@@ -618,15 +620,15 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t\ttree_cons (NULL_TREE,\n \t\t\t\t\t\t\t   ptr_void_type_node,\n \t\t\t\t\t\t\t   endlink)),\n-\t\t\t   NULL_TREE, 0, 1, 1, 0, Empty);\n+\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n \n   end_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n \t\t\t   build_function_type (void_type_node,\n \t\t\t\t\t\ttree_cons (NULL_TREE,\n \t\t\t\t\t\t\t   ptr_void_type_node,\n \t\t\t\t\t\t\t   endlink)),\n-\t\t\t   NULL_TREE, 0, 1, 1, 0, Empty);\n+\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n \n   /* If in no exception handlers mode, all raise statements are redirected to\n      __gnat_last_chance_handler. No need to redefine raise_nodefer_decl, since\n@@ -642,7 +644,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t   tree_cons (NULL_TREE,\n \t\t\t\t\t\t      integer_type_node,\n \t\t\t\t\t\t      endlink))),\n-\t   NULL_TREE, 0, 1, 1, 0, Empty);\n+\t   NULL_TREE, false, true, true, NULL, Empty);\n \n       for (i = 0; i < ARRAY_SIZE (gnat_raise_decls); i++)\n \tgnat_raise_decls[i] = decl;\n@@ -664,7 +666,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t     tree_cons (NULL_TREE,\n \t\t\t\t\t\t\tinteger_type_node,\n \t\t\t\t\t\t\tendlink))),\n-\t     NULL_TREE, 0, 1, 1, 0, Empty);\n+\t     NULL_TREE, false, true, true, NULL, Empty);\n       }\n \n   /* Indicate that these never return.  */\n@@ -690,7 +692,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n       (get_identifier (\"__builtin_setjmp\"), NULL_TREE,\n        build_function_type (integer_type_node,\n \t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, endlink)),\n-       NULL_TREE, 0, 1, 1, 0, Empty);\n+       NULL_TREE, false, true, true, NULL, Empty);\n \n   DECL_BUILT_IN_CLASS (setjmp_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n@@ -702,7 +704,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n       (get_identifier (\"__builtin_update_setjmp_buf\"), NULL_TREE,\n        build_function_type (void_type_node,\n \t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, endlink)),\n-       NULL_TREE, 0, 1, 1, 0, Empty);\n+       NULL_TREE, false, true, true, NULL, Empty);\n \n   DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n@@ -712,19 +714,19 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \f\n /* Given a record type (RECORD_TYPE) and a chain of FIELD_DECL nodes\n    (FIELDLIST), finish constructing the record or union type.  If HAS_REP is\n-   nonzero, this record has a rep clause; don't call layout_type but merely set\n-   the size and alignment ourselves.  If DEFER_DEBUG is nonzero, do not call\n+   true, this record has a rep clause; don't call layout_type but merely set\n+   the size and alignment ourselves.  If DEFER_DEBUG is true, do not call\n    the debugging routines on this type; it will be done later. */\n \n void\n-finish_record_type (tree record_type, tree fieldlist, int has_rep,\n-                    int defer_debug)\n+finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n+                    bool defer_debug)\n {\n   enum tree_code code = TREE_CODE (record_type);\n   tree ada_size = bitsize_zero_node;\n   tree size = bitsize_zero_node;\n   tree size_unit = size_zero_node;\n-  int var_size = 0;\n+  bool var_size = false;\n   tree field;\n \n   TYPE_FIELDS (record_type) = fieldlist;\n@@ -742,7 +744,7 @@ finish_record_type (tree record_type, tree fieldlist, int has_rep,\n     {\n       TYPE_ALIGN (record_type) = MAX (BITS_PER_UNIT, TYPE_ALIGN (record_type));\n       TYPE_MODE (record_type) = BLKmode;\n-      if (TYPE_SIZE (record_type) == 0)\n+      if (!TYPE_SIZE (record_type))\n \t{\n \t  TYPE_SIZE (record_type) = bitsize_zero_node;\n \t  TYPE_SIZE_UNIT (record_type) = size_zero_node;\n@@ -789,13 +791,13 @@ finish_record_type (tree record_type, tree fieldlist, int has_rep,\n \t output routines (except Dwarf2) won't be able to output the fields,\n \t so we need to make the special record.  */\n       if (TREE_CODE (this_size) != INTEGER_CST)\n-\tvar_size = 1;\n+\tvar_size = true;\n \n       if ((TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE\n \t  || TREE_CODE (type) == QUAL_UNION_TYPE)\n-\t  && ! TYPE_IS_FAT_POINTER_P (type)\n-\t  && ! TYPE_CONTAINS_TEMPLATE_P (type)\n-\t  && TYPE_ADA_SIZE (type) != 0)\n+\t  && !TYPE_IS_FAT_POINTER_P (type)\n+\t  && !TYPE_CONTAINS_TEMPLATE_P (type)\n+\t  && TYPE_ADA_SIZE (type))\n \tthis_ada_size = TYPE_ADA_SIZE (type);\n \n       /* Clear DECL_BIT_FIELD for the cases layout_decl does not handle.  */\n@@ -811,7 +813,7 @@ finish_record_type (tree record_type, tree fieldlist, int has_rep,\n       DECL_NONADDRESSABLE_P (field)\n \t|= DECL_BIT_FIELD (field) && DECL_MODE (field) != BLKmode;\n \n-      if (has_rep && ! DECL_BIT_FIELD (field))\n+      if (has_rep && !DECL_BIT_FIELD (field))\n \tTYPE_ALIGN (record_type)\n \t  = MAX (TYPE_ALIGN (record_type), DECL_ALIGN (field));\n \n@@ -863,22 +865,22 @@ finish_record_type (tree record_type, tree fieldlist, int has_rep,\n   /* If this is a padding record, we never want to make the size smaller than\n      what was specified in it, if any.  */\n   if (TREE_CODE (record_type) == RECORD_TYPE\n-      && TYPE_IS_PADDING_P (record_type) && TYPE_SIZE (record_type) != 0)\n+      && TYPE_IS_PADDING_P (record_type) && TYPE_SIZE (record_type))\n     {\n       size = TYPE_SIZE (record_type);\n       size_unit = TYPE_SIZE_UNIT (record_type);\n     }\n \n   /* Now set any of the values we've just computed that apply.  */\n-  if (! TYPE_IS_FAT_POINTER_P (record_type)\n-      && ! TYPE_CONTAINS_TEMPLATE_P (record_type))\n+  if (!TYPE_IS_FAT_POINTER_P (record_type)\n+      && !TYPE_CONTAINS_TEMPLATE_P (record_type))\n     SET_TYPE_ADA_SIZE (record_type, ada_size);\n \n   if (has_rep)\n     {\n-      if (! (TREE_CODE (record_type) == RECORD_TYPE\n-\t     && TYPE_IS_PADDING_P (record_type)\n-\t     && CONTAINS_PLACEHOLDER_P (size)))\n+      if (!(TREE_CODE (record_type) == RECORD_TYPE\n+\t    && TYPE_IS_PADDING_P (record_type)\n+\t    && CONTAINS_PLACEHOLDER_P (size)))\n \t{\n \t  TYPE_SIZE (record_type) = round_up (size, TYPE_ALIGN (record_type));\n \t  TYPE_SIZE_UNIT (record_type)\n@@ -889,16 +891,16 @@ finish_record_type (tree record_type, tree fieldlist, int has_rep,\n       compute_record_mode (record_type);\n     }\n \n-  if (! defer_debug)\n+  if (!defer_debug)\n     {\n       /* If this record is of variable size, rename it so that the\n \t debugger knows it is and make a new, parallel, record\n \t that tells the debugger how the record is laid out.  See\n \t exp_dbug.ads.  But don't do this for records that are padding\n \t since they confuse GDB.  */\n       if (var_size\n-\t  && ! (TREE_CODE (record_type) == RECORD_TYPE\n-\t\t&& TYPE_IS_PADDING_P (record_type)))\n+\t  && !(TREE_CODE (record_type) == RECORD_TYPE\n+\t       && TYPE_IS_PADDING_P (record_type)))\n \t{\n \t  tree new_record_type\n \t    = make_node (TREE_CODE (record_type) == QUAL_UNION_TYPE\n@@ -923,17 +925,19 @@ finish_record_type (tree record_type, tree fieldlist, int has_rep,\n \t  DECL_IGNORED_P (TYPE_STUB_DECL (new_record_type))\n \t    = DECL_IGNORED_P (TYPE_STUB_DECL (record_type));\n \t  TYPE_SIZE (new_record_type) = size_int (TYPE_ALIGN (record_type));\n+\t  TYPE_SIZE_UNIT (new_record_type)\n+  \t    = size_int (TYPE_ALIGN (record_type) / BITS_PER_UNIT);\n \n \t  /* Now scan all the fields, replacing each field with a new\n \t     field corresponding to the new encoding.  */\n-\t  for (old_field = TYPE_FIELDS (record_type); old_field != 0;\n+\t  for (old_field = TYPE_FIELDS (record_type); old_field;\n \t       old_field = TREE_CHAIN (old_field))\n \t    {\n \t      tree field_type = TREE_TYPE (old_field);\n \t      tree field_name = DECL_NAME (old_field);\n \t      tree new_field;\n \t      tree curpos = bit_position (old_field);\n-\t      int var = 0;\n+\t      bool var = false;\n \t      unsigned int align = 0;\n \t      tree pos;\n \n@@ -953,14 +957,14 @@ finish_record_type (tree record_type, tree fieldlist, int has_rep,\n \t      else\n \t\tpos = compute_related_constant (curpos, last_pos);\n \n-\t      if (pos == 0 && TREE_CODE (curpos) == MULT_EXPR\n+\t      if (!pos && TREE_CODE (curpos) == MULT_EXPR\n \t\t  && TREE_CODE (TREE_OPERAND (curpos, 1)) == INTEGER_CST)\n \t\t{\n \t\t  align = TREE_INT_CST_LOW (TREE_OPERAND (curpos, 1));\n \t\t  pos = compute_related_constant (curpos,\n \t\t\t\t\t\t  round_up (last_pos, align));\n \t\t}\n-\t      else if (pos == 0 && TREE_CODE (curpos) == PLUS_EXPR\n+\t      else if (!pos && TREE_CODE (curpos) == PLUS_EXPR\n \t\t       && TREE_CODE (TREE_OPERAND (curpos, 1)) == INTEGER_CST\n \t\t       && TREE_CODE (TREE_OPERAND (curpos, 0)) == MULT_EXPR\n \t\t       && host_integerp (TREE_OPERAND\n@@ -986,15 +990,15 @@ finish_record_type (tree record_type, tree fieldlist, int has_rep,\n \t\t ??? We really should abort here, but it's too much work\n \t\t to get this correct for all cases.  */\n \n-\t      if (pos == 0)\n+\t      if (!pos)\n \t\tpos = bitsize_zero_node;\n \n \t      /* See if this type is variable-size and make a new type\n \t\t and indicate the indirection if so.  */\n \t      if (TREE_CODE (DECL_SIZE (old_field)) != INTEGER_CST)\n \t\t{\n \t\t  field_type = build_pointer_type (field_type);\n-\t\t  var = 1;\n+\t\t  var = true;\n \t\t}\n \n \t      /* Make a new field name, if necessary.  */\n@@ -1056,7 +1060,7 @@ merge_sizes (tree last_size, tree first_bit, tree size, bool special,\n   tree type = TREE_TYPE (last_size);\n   tree new;\n \n-  if (! special || TREE_CODE (size) != COND_EXPR)\n+  if (!special || TREE_CODE (size) != COND_EXPR)\n     {\n       new = size_binop (PLUS_EXPR, first_bit, size);\n       if (has_rep)\n@@ -1149,10 +1153,11 @@ split_plus (tree in, tree *pvar)\n    object.  RETURNS_BY_REF is nonzero if the function returns by reference.\n    RETURNS_WITH_DSP is nonzero if the function is to return with a\n    depressed stack pointer.  */\n+\n tree\n create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n-                     int returns_unconstrained, int returns_by_ref,\n-                     int returns_with_dsp)\n+                     bool returns_unconstrained, bool returns_by_ref,\n+                     bool returns_with_dsp)\n {\n   /* A chain of TREE_LIST nodes whose TREE_VALUEs are the data type nodes of\n      the subprogram formal parameters. This list is generated by traversing the\n@@ -1164,7 +1169,7 @@ create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n   for (param_decl = param_decl_list; param_decl;\n        param_decl = TREE_CHAIN (param_decl))\n     param_type_list = tree_cons (NULL_TREE, TREE_TYPE (param_decl),\n-\t\t\t\t\t  param_type_list);\n+\t\t\t\t param_type_list);\n \n   /* The list of the function parameter types has to be terminated by the void\n      type to signal to the back-end that we are not dealing with a variable\n@@ -1181,7 +1186,7 @@ create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n   /* TYPE may have been shared since GCC hashes types.  If it has a CICO_LIST\n      or the new type should, make a copy of TYPE.  Likewise for\n      RETURNS_UNCONSTRAINED and RETURNS_BY_REF.  */\n-  if (TYPE_CI_CO_LIST (type) != 0 || cico_list != 0\n+  if (TYPE_CI_CO_LIST (type) || cico_list\n       || TYPE_RETURNS_UNCONSTRAINED_P (type) != returns_unconstrained\n       || TYPE_RETURNS_BY_REF_P (type) != returns_by_ref)\n     type = copy_type (type);\n@@ -1228,24 +1233,24 @@ create_index_type (tree min, tree max, tree index)\n      only a small hole.  */\n   if (TYPE_INDEX_TYPE (type) == index)\n     return type;\n-  else if (TYPE_INDEX_TYPE (type) != 0)\n+  else if (TYPE_INDEX_TYPE (type))\n     type = copy_type (type);\n \n   SET_TYPE_INDEX_TYPE (type, index);\n-  create_type_decl (NULL_TREE, type, NULL, 1, 0, Empty);\n+  create_type_decl (NULL_TREE, type, NULL, true, false, Empty);\n   return type;\n }\n \f\n /* Return a TYPE_DECL node. TYPE_NAME gives the name of the type (a character\n    string) and TYPE is a ..._TYPE node giving its data type.\n-   ARTIFICIAL_P is nonzero if this is a declaration that was generated\n-   by the compiler.  DEBUG_INFO_P is nonzero if we need to write debugging\n+   ARTIFICIAL_P is true if this is a declaration that was generated\n+   by the compiler.  DEBUG_INFO_P is true if we need to write debugging\n    information about this type.  GNAT_NODE is used for the position of\n    the decl.  */\n \n tree\n create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n-\t\t  int artificial_p, int debug_info_p, Node_Id gnat_node)\n+\t\t  bool artificial_p, bool debug_info_p, Node_Id gnat_node)\n {\n   tree type_decl = build_decl (TYPE_DECL, type_name, type);\n   enum tree_code code = TREE_CODE (type);\n@@ -1260,11 +1265,11 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n      a dummy type, which will be completed later, or a type for which\n      debugging information was not requested.  */\n   if (code == UNCONSTRAINED_ARRAY_TYPE || TYPE_IS_DUMMY_P (type)\n-      || ! debug_info_p)\n+      || !debug_info_p)\n     DECL_IGNORED_P (type_decl) = 1;\n   else if (code != ENUMERAL_TYPE && code != RECORD_TYPE\n-      && ! ((code == POINTER_TYPE || code == REFERENCE_TYPE)\n-\t    && TYPE_IS_DUMMY_P (TREE_TYPE (type))))\n+      && !((code == POINTER_TYPE || code == REFERENCE_TYPE)\n+\t   && TYPE_IS_DUMMY_P (TREE_TYPE (type))))\n     rest_of_decl_compilation (type_decl, NULL, global_bindings_p (), 0);\n \n   if (!TYPE_IS_DUMMY_P (type))\n@@ -1278,9 +1283,9 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n    (a GCC ..._TYPE node).  VAR_INIT is the GCC tree for an optional initial\n    expression; NULL_TREE if none.\n \n-   CONST_FLAG is nonzero if this variable is constant.\n+   CONST_FLAG is true if this variable is constant.\n \n-   PUBLIC_FLAG is nonzero if this definition is to be made visible outside of\n+   PUBLIC_FLAG is true if this definition is to be made visible outside of\n    the current compilation unit. This flag should be set when processing the\n    variable definitions in a package specification.  EXTERN_FLAG is nonzero\n    when processing an external variable declaration (as opposed to a\n@@ -1293,12 +1298,12 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n \n tree\n create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n-                 int const_flag, int public_flag, int extern_flag,\n-                 int static_flag, struct attrib *attr_list, Node_Id gnat_node)\n+                 bool const_flag, bool public_flag, bool extern_flag,\n+                 bool static_flag, struct attrib *attr_list, Node_Id gnat_node)\n {\n-  int init_const\n-    = (var_init == 0\n-       ? 0\n+  bool init_const\n+    = (!var_init\n+       ? false\n        : (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (var_init))\n \t  && (global_bindings_p () || static_flag\n \t      ? 0 != initializer_constant_valid_p (var_init,\n@@ -1321,8 +1326,8 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n      just annotating types, throw away the initialization if it isn't a\n      constant.  */\n   if ((extern_flag && TREE_CODE (var_decl) != CONST_DECL)\n-      || (type_annotate_only && var_init != 0 && ! TREE_CONSTANT (var_init)))\n-    var_init = 0;\n+      || (type_annotate_only && var_init && !TREE_CONSTANT (var_init)))\n+    var_init = NULL_TREE;\n \n   DECL_INITIAL  (var_decl) = var_init;\n   TREE_READONLY (var_decl) = const_flag;\n@@ -1337,7 +1342,7 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n      we allocate automatic storage unless requested not to.  */\n   TREE_STATIC (var_decl) = global_bindings_p () ? !extern_flag : static_flag;\n \n-  if (asm_name != 0)\n+  if (asm_name)\n     SET_DECL_ASSEMBLER_NAME (var_decl, asm_name);\n \n   process_attributes (var_decl, attr_list);\n@@ -1380,7 +1385,7 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n      We always set a size in this case to trigger the checks for bitfield\n      creation below, which is typically required when no position has been\n      specified.  */\n-  if (size != 0)\n+  if (size)\n     size = convert (bitsizetype, size);\n   else if (packed == 1)\n     {\n@@ -1408,35 +1413,35 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n      We also don't look at STRICT_ALIGNMENT here, and rely on later processing\n      in layout_decl or finish_record_type to clear the bit_field indication if\n      it is in fact not needed. */\n-  if (size != 0 && TREE_CODE (size) == INTEGER_CST\n+  if (size && TREE_CODE (size) == INTEGER_CST\n       && TREE_CODE (TYPE_SIZE (field_type)) == INTEGER_CST\n-      && ! addressable\n-      && (! operand_equal_p (TYPE_SIZE (field_type), size, 0)\n-\t  || (pos != 0\n-\t      && ! value_zerop (size_binop (TRUNC_MOD_EXPR, pos,\n-\t\t\t\t\t    bitsize_int (TYPE_ALIGN\n-\t\t\t\t\t\t\t (field_type)))))\n+      && !addressable\n+      && (!operand_equal_p (TYPE_SIZE (field_type), size, 0)\n+\t  || (pos\n+\t      && !value_zerop (size_binop (TRUNC_MOD_EXPR, pos,\n+\t\t\t\t\t   bitsize_int (TYPE_ALIGN\n+\t\t\t\t\t\t\t(field_type)))))\n \t  || packed\n \t  || (TYPE_ALIGN (record_type) != 0\n \t      && TYPE_ALIGN (record_type) < TYPE_ALIGN (field_type))))\n     {\n       DECL_BIT_FIELD (field_decl) = 1;\n       DECL_SIZE (field_decl) = size;\n-      if (! packed && pos == 0)\n+      if (!packed && !pos)\n \tDECL_ALIGN (field_decl)\n \t  = (TYPE_ALIGN (record_type) != 0\n \t     ? MIN (TYPE_ALIGN (record_type), TYPE_ALIGN (field_type))\n \t     : TYPE_ALIGN (field_type));\n     }\n \n-  DECL_PACKED (field_decl) = pos != 0 ? DECL_BIT_FIELD (field_decl) : packed;\n+  DECL_PACKED (field_decl) = pos ? DECL_BIT_FIELD (field_decl) : packed;\n   DECL_ALIGN (field_decl)\n     = MAX (DECL_ALIGN (field_decl),\n \t   DECL_BIT_FIELD (field_decl) ? 1\n \t   : packed && TYPE_MODE (field_type) != BLKmode ? BITS_PER_UNIT\n \t   : TYPE_ALIGN (field_type));\n \n-  if (pos != 0)\n+  if (pos)\n     {\n       /* We need to pass in the alignment the DECL is known to have.\n \t This is the lowest-order bit set in POS, but no more than\n@@ -1482,7 +1487,7 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n      copy. This is the case for true bitfields, but the DECL_BIT_FIELD value\n      we have at this point is not accurate enough, so we don't account for\n      this here and let finish_record_type decide.  */\n-  DECL_NONADDRESSABLE_P (field_decl) = ! addressable;\n+  DECL_NONADDRESSABLE_P (field_decl) = !addressable;\n \n   return field_decl;\n }\n@@ -1500,12 +1505,12 @@ value_zerop (tree exp)\n }\n \f\n /* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n-   PARAM_TYPE is its type.  READONLY is nonzero if the parameter is\n+   PARAM_TYPE is its type.  READONLY is true if the parameter is\n    readonly (either an IN parameter or an address of a pass-by-ref\n    parameter). */\n \n tree\n-create_param_decl (tree param_name, tree param_type, int readonly)\n+create_param_decl (tree param_name, tree param_type, bool readonly)\n {\n   tree param_decl = build_decl (PARM_DECL, param_name, param_type);\n \n@@ -1606,21 +1611,21 @@ potential_alignment_gap (tree prev_field, tree curr_field, tree offset)\n {\n   /* If this is the first field of the record, there cannot be any gap */\n   if (!prev_field)\n-    return 0;\n+    return false;\n \n   /* If the previous field is a union type, then return False: The only\n      time when such a field is not the last field of the record is when\n      there are other components at fixed positions after it (meaning there\n      was a rep clause for every field), in which case we don't want the\n      alignment constraint to override them. */\n   if (TREE_CODE (TREE_TYPE (prev_field)) == QUAL_UNION_TYPE)\n-    return 0;\n+    return false;\n \n   /* If the distance between the end of prev_field and the begining of\n      curr_field is constant, then there is a gap if the value of this\n      constant is not null. */\n   if (offset && host_integerp (offset, 1))\n-    return (!integer_zerop (offset));\n+    return !integer_zerop (offset);\n \n   /* If the size and position of the previous field are constant,\n      then check the sum of this size and position. There will be a gap\n@@ -1635,10 +1640,10 @@ potential_alignment_gap (tree prev_field, tree curr_field, tree offset)\n      of the current field alignment, there can not be any gap. */\n   if (value_factor_p (bit_position (prev_field), DECL_ALIGN (curr_field))\n       && value_factor_p (DECL_SIZE (prev_field), DECL_ALIGN (curr_field)))\n-    return 0;\n+    return false;\n \n   /* Fallback, return that there may be a potential gap */\n-  return 1;\n+  return true;\n }\n \n /* Returns a LABEL_DECL node for LABEL_NAME.  */\n@@ -1665,8 +1670,8 @@ create_label_decl (tree label_name)\n \n tree\n create_subprog_decl (tree subprog_name, tree asm_name,\n-                     tree subprog_type, tree param_decl_list, int inline_flag,\n-                     int public_flag, int extern_flag,\n+                     tree subprog_type, tree param_decl_list, bool inline_flag,\n+\t\t     bool public_flag, bool extern_flag,\n                      struct attrib *attr_list, Node_Id gnat_node)\n {\n   tree return_type  = TREE_TYPE (subprog_type);\n@@ -1675,9 +1680,9 @@ create_subprog_decl (tree subprog_name, tree asm_name,\n   /* If this is a function nested inside an inlined external function, it\n      means we aren't going to compile the outer function unless it is\n      actually inlined, so do the same for us.  */\n-  if (current_function_decl != 0 && DECL_INLINE (current_function_decl)\n+  if (current_function_decl && DECL_INLINE (current_function_decl)\n       && DECL_EXTERNAL (current_function_decl))\n-    extern_flag = 1;\n+    extern_flag = true;\n \n   DECL_EXTERNAL (subprog_decl)  = extern_flag;\n   TREE_PUBLIC (subprog_decl)    = public_flag;\n@@ -1693,7 +1698,7 @@ create_subprog_decl (tree subprog_name, tree asm_name,\n   if (inline_flag)\n     DECL_DECLARED_INLINE_P (subprog_decl) = 1;\n \n-  if (asm_name != 0)\n+  if (asm_name)\n     SET_DECL_ASSEMBLER_NAME (subprog_decl, asm_name);\n \n   process_attributes (subprog_decl, attr_list);\n@@ -1859,7 +1864,7 @@ gnat_type_for_size (unsigned precision, int unsignedp)\n   char type_name[20];\n \n   if (precision <= 2 * MAX_BITS_PER_WORD\n-      && signed_and_unsigned_types[precision][unsignedp] != 0)\n+      && signed_and_unsigned_types[precision][unsignedp])\n     return signed_and_unsigned_types[precision][unsignedp];\n \n  if (unsignedp)\n@@ -1870,7 +1875,7 @@ gnat_type_for_size (unsigned precision, int unsignedp)\n   if (precision <= 2 * MAX_BITS_PER_WORD)\n     signed_and_unsigned_types[precision][unsignedp] = t;\n \n-  if (TYPE_NAME (t) == 0)\n+  if (!TYPE_NAME (t))\n     {\n       sprintf (type_name, \"%sSIGNED_%d\", unsignedp ? \"UN\" : \"\", precision);\n       TYPE_NAME (t) = get_identifier (type_name);\n@@ -1887,17 +1892,17 @@ float_type_for_precision (int precision, enum machine_mode mode)\n   tree t;\n   char type_name[20];\n \n-  if (float_types[(int) mode] != 0)\n+  if (float_types[(int) mode])\n     return float_types[(int) mode];\n \n   float_types[(int) mode] = t = make_node (REAL_TYPE);\n   TYPE_PRECISION (t) = precision;\n   layout_type (t);\n \n   if (TYPE_MODE (t) != mode)\n-    gigi_abort (414);\n+    abort ();\n \n-  if (TYPE_NAME (t) == 0)\n+  if (!TYPE_NAME (t))\n     {\n       sprintf (type_name, \"FLOAT_%d\", precision);\n       TYPE_NAME (t) = get_identifier (type_name);\n@@ -1934,7 +1939,7 @@ gnat_unsigned_type (tree type_node)\n       type = copy_node (type);\n       TREE_TYPE (type) = type_node;\n     }\n-  else if (TREE_TYPE (type_node) != 0\n+  else if (TREE_TYPE (type_node)\n \t   && TREE_CODE (TREE_TYPE (type_node)) == INTEGER_TYPE\n \t   && TYPE_MODULAR_P (TREE_TYPE (type_node)))\n     {\n@@ -1957,7 +1962,7 @@ gnat_signed_type (tree type_node)\n       type = copy_node (type);\n       TREE_TYPE (type) = type_node;\n     }\n-  else if (TREE_TYPE (type_node) != 0\n+  else if (TREE_TYPE (type_node)\n \t   && TREE_CODE (TREE_TYPE (type_node)) == INTEGER_TYPE\n \t   && TYPE_MODULAR_P (TREE_TYPE (type_node)))\n     {\n@@ -1974,18 +1979,18 @@ gnat_signed_type (tree type_node)\n tree\n gnat_signed_or_unsigned_type (int unsignedp, tree type)\n {\n-  if (! INTEGRAL_TYPE_P (type) || TYPE_UNSIGNED (type) == unsignedp)\n+  if (!INTEGRAL_TYPE_P (type) || TYPE_UNSIGNED (type) == unsignedp)\n     return type;\n   else\n     return gnat_type_for_size (TYPE_PRECISION (type), unsignedp);\n }\n \f\n /* EXP is an expression for the size of an object.  If this size contains\n    discriminant references, replace them with the maximum (if MAX_P) or\n-   minimum (if ! MAX_P) possible value of the discriminant.  */\n+   minimum (if !MAX_P) possible value of the discriminant.  */\n \n tree\n-max_size (tree exp, int max_p)\n+max_size (tree exp, bool max_p)\n {\n   enum tree_code code = TREE_CODE (exp);\n   tree type = TREE_TYPE (exp);\n@@ -2000,19 +2005,19 @@ max_size (tree exp, int max_p)\n       if (code == TREE_LIST)\n \treturn tree_cons (TREE_PURPOSE (exp),\n \t\t\t  max_size (TREE_VALUE (exp), max_p),\n-\t\t\t  TREE_CHAIN (exp) != 0\n-\t\t\t  ? max_size (TREE_CHAIN (exp), max_p) : 0);\n+\t\t\t  TREE_CHAIN (exp)\n+\t\t\t  ? max_size (TREE_CHAIN (exp), max_p) : NULL_TREE);\n       break;\n \n     case 'r':\n       /* If this contains a PLACEHOLDER_EXPR, it is the thing we want to\n \t modify.  Otherwise, we treat it like a variable.  */\n-      if (! CONTAINS_PLACEHOLDER_P (exp))\n+      if (!CONTAINS_PLACEHOLDER_P (exp))\n \treturn exp;\n \n       type = TREE_TYPE (TREE_OPERAND (exp, 1));\n       return\n-\tmax_size (max_p ? TYPE_MAX_VALUE (type) : TYPE_MIN_VALUE (type), 1);\n+\tmax_size (max_p ? TYPE_MAX_VALUE (type) : TYPE_MIN_VALUE (type), true);\n \n     case '<':\n       return max_p ? size_one_node : size_zero_node;\n@@ -2029,7 +2034,7 @@ max_size (tree exp, int max_p)\n \t    return\n \t      fold (build1 (code, type,\n \t\t\t    max_size (TREE_OPERAND (exp, 0),\n-\t\t\t\t      code == NEGATE_EXPR ? ! max_p : max_p)));\n+\t\t\t\t      code == NEGATE_EXPR ? !max_p : max_p)));\n \n \tcase 2:\n \t  if (code == COMPOUND_EXPR)\n@@ -2038,7 +2043,7 @@ max_size (tree exp, int max_p)\n \t  {\n \t    tree lhs = max_size (TREE_OPERAND (exp, 0), max_p);\n \t    tree rhs = max_size (TREE_OPERAND (exp, 1),\n-\t\t\t\t code == MINUS_EXPR ? ! max_p : max_p);\n+\t\t\t\t code == MINUS_EXPR ? !max_p : max_p);\n \n \t    /* Special-case wanting the maximum value of a MIN_EXPR.\n \t       In that case, if one side overflows, return the other.\n@@ -2053,7 +2058,7 @@ max_size (tree exp, int max_p)\n \t    else if ((code == MINUS_EXPR || code == PLUS_EXPR)\n \t\t     && ((TREE_CONSTANT (lhs) && TREE_OVERFLOW (lhs))\n \t\t\t || operand_equal_p (lhs, TYPE_MAX_VALUE (type), 0))\n-\t\t     && ! TREE_CONSTANT (rhs))\n+\t\t     && !TREE_CONSTANT (rhs))\n \t      return lhs;\n \t    else\n \t      return fold (build (code, type, lhs, rhs));\n@@ -2066,13 +2071,13 @@ max_size (tree exp, int max_p)\n \t    return fold (build (max_p ? MAX_EXPR : MIN_EXPR, type,\n \t\t\t\tmax_size (TREE_OPERAND (exp, 1), max_p),\n \t\t\t\tmax_size (TREE_OPERAND (exp, 2), max_p)));\n-\t  else if (code == CALL_EXPR && TREE_OPERAND (exp, 1) != 0)\n+\t  else if (code == CALL_EXPR && TREE_OPERAND (exp, 1))\n \t    return build (CALL_EXPR, type, TREE_OPERAND (exp, 0),\n \t\t\t  max_size (TREE_OPERAND (exp, 1), max_p), NULL);\n \t}\n     }\n \n-  gigi_abort (408);\n+  abort ();\n }\n \f\n /* Build a template of type TEMPLATE_TYPE from the array bounds of ARRAY_TYPE.\n@@ -2102,7 +2107,7 @@ build_template (tree template_type, tree array_type, tree expr)\n      nested arrays stop being the underlying object.  */\n \n   for (field = TYPE_FIELDS (template_type); field;\n-       (bound_list != 0\n+       (bound_list\n \t? (bound_list = TREE_CHAIN (bound_list))\n \t: (array_type = TREE_TYPE (array_type))),\n        field = TREE_CHAIN (TREE_CHAIN (field)))\n@@ -2113,15 +2118,15 @@ build_template (tree template_type, tree array_type, tree expr)\n \t for an ARRAY_TYPE.  Otherwise, if expr is a PARM_DECL with\n \t DECL_BY_COMPONENT_PTR_P, use the bounds of the field in the template.\n \t This will give us a maximum range.  */\n-      if (bound_list != 0)\n+      if (bound_list)\n \tbounds = TREE_VALUE (bound_list);\n       else if (TREE_CODE (array_type) == ARRAY_TYPE)\n \tbounds = TYPE_INDEX_TYPE (TYPE_DOMAIN (array_type));\n-      else if (expr != 0 && TREE_CODE (expr) == PARM_DECL\n+      else if (expr && TREE_CODE (expr) == PARM_DECL\n \t       && DECL_BY_COMPONENT_PTR_P (expr))\n \tbounds = TREE_TYPE (field);\n       else\n-\tgigi_abort (411);\n+\tabort ();\n \n       min = convert (TREE_TYPE (TREE_CHAIN (field)), TYPE_MIN_VALUE (bounds));\n       max = convert (TREE_TYPE (field), TYPE_MAX_VALUE (bounds));\n@@ -2426,9 +2431,9 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n       post_error (\"unsupported descriptor type for &\", gnat_entity);\n     }\n \n-  finish_record_type (record_type, field_list, 0, 1);\n+  finish_record_type (record_type, field_list, false, true);\n   create_type_decl (create_concat_name (gnat_entity, \"DESC\"), record_type,\n-\t\t    NULL, 1, 0, gnat_entity);\n+\t\t    NULL, true, false, gnat_entity);\n \n   return record_type;\n }\n@@ -2467,7 +2472,7 @@ build_unc_object_type (tree template_type, tree object_type, tree name)\n   finish_record_type (type,\n \t\t      chainon (chainon (NULL_TREE, template_field),\n \t\t\t       array_field),\n-\t\t      0, 0);\n+\t\t      false, false);\n \n   return type;\n }\n@@ -2486,12 +2491,12 @@ update_pointer_to (tree old_type, tree new_type)\n \n   /* If this is the main variant, process all the other variants first.  */\n   if (TYPE_MAIN_VARIANT (old_type) == old_type)\n-    for (type = TYPE_NEXT_VARIANT (old_type); type != 0;\n+    for (type = TYPE_NEXT_VARIANT (old_type); type;\n \t type = TYPE_NEXT_VARIANT (type))\n       update_pointer_to (type, new_type);\n \n   /* If no pointer or reference, we are done.  */\n-  if (ptr == 0 && ref == 0)\n+  if (!ptr && !ref)\n     return;\n \n   /* Merge the old type qualifiers in the new type.\n@@ -2534,7 +2539,7 @@ update_pointer_to (tree old_type, tree new_type)\n \t  {\n \t    TREE_TYPE (ptr1) = new_type;\n \n-\t    if (TYPE_NAME (ptr1) != 0\n+\t    if (TYPE_NAME (ptr1)\n \t\t&& TREE_CODE (TYPE_NAME (ptr1)) == TYPE_DECL\n \t\t&& TREE_CODE (new_type) != ENUMERAL_TYPE)\n \t      rest_of_decl_compilation (TYPE_NAME (ptr1), NULL,\n@@ -2547,7 +2552,7 @@ update_pointer_to (tree old_type, tree new_type)\n \t  {\n \t    TREE_TYPE (ref1) = new_type;\n \n-\t    if (TYPE_NAME (ref1) != 0\n+\t    if (TYPE_NAME (ref1)\n \t\t&& TREE_CODE (TYPE_NAME (ref1)) == TYPE_DECL\n \t\t&& TREE_CODE (new_type) != ENUMERAL_TYPE)\n \t      rest_of_decl_compilation (TYPE_NAME (ref1), NULL,\n@@ -2559,8 +2564,8 @@ update_pointer_to (tree old_type, tree new_type)\n      is actually a RECORD_TYPE where the types of both fields are\n      pointers to void.  In that case, copy the field list from the\n      old type to the new one and update the fields' context. */\n-  else if (TREE_CODE (ptr) != RECORD_TYPE || ! TYPE_IS_FAT_POINTER_P (ptr))\n-    gigi_abort (412);\n+  else if (TREE_CODE (ptr) != RECORD_TYPE || !TYPE_IS_FAT_POINTER_P (ptr))\n+    abort ();\n \n   else\n     {\n@@ -2569,6 +2574,12 @@ update_pointer_to (tree old_type, tree new_type)\n       tree new_ref;\n       tree var;\n \n+      SET_DECL_ORIGINAL_FIELD (TYPE_FIELDS (ptr),\n+\t\t\t       TYPE_FIELDS (TYPE_POINTER_TO (new_type)));\n+      SET_DECL_ORIGINAL_FIELD (TREE_CHAIN (TYPE_FIELDS (ptr)),\n+\t\t\t       TREE_CHAIN (TYPE_FIELDS\n+\t\t\t\t\t   (TYPE_POINTER_TO (new_type))));\n+\n       TYPE_FIELDS (ptr) = TYPE_FIELDS (TYPE_POINTER_TO (new_type));\n       DECL_CONTEXT (TYPE_FIELDS (ptr)) = ptr;\n       DECL_CONTEXT (TREE_CHAIN (TYPE_FIELDS (ptr))) = ptr;\n@@ -2656,10 +2667,10 @@ convert_to_fat_pointer (tree type, tree expr)\n       else\n \texpr = build1 (INDIRECT_REF, TREE_TYPE (etype), expr);\n \n-      template = build_component_ref (expr, NULL_TREE, fields, 0);\n+      template = build_component_ref (expr, NULL_TREE, fields, false);\n       expr = build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t     build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t\t  TREE_CHAIN (fields), 0));\n+\t\t\t\t\t\t  TREE_CHAIN (fields), false));\n     }\n   else\n     /* Otherwise, build the constructor for the template.  */\n@@ -2694,15 +2705,15 @@ convert_to_fat_pointer (tree type, tree expr)\n static tree\n convert_to_thin_pointer (tree type, tree expr)\n {\n-  if (! TYPE_FAT_POINTER_P (TREE_TYPE (expr)))\n+  if (!TYPE_FAT_POINTER_P (TREE_TYPE (expr)))\n     expr\n       = convert_to_fat_pointer\n \t(TREE_TYPE (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type))), expr);\n \n   /* We get the pointer to the data and use a NOP_EXPR to make it the\n      proper GCC type.  */\n-  expr\n-    = build_component_ref (expr, NULL_TREE, TYPE_FIELDS (TREE_TYPE (expr)), 0);\n+  expr = build_component_ref (expr, NULL_TREE, TYPE_FIELDS (TREE_TYPE (expr)),\n+\t\t\t      false);\n   expr = build1 (NOP_EXPR, type, expr);\n \n   return expr;\n@@ -2732,28 +2743,29 @@ convert (tree type, tree expr)\n      of variable size, do this as an unchecked conversion.  */\n   else if (ecode == RECORD_TYPE && code == RECORD_TYPE\n       && TYPE_IS_PADDING_P (type) && TYPE_IS_PADDING_P (etype)\n-      && (! TREE_CONSTANT (TYPE_SIZE (type))\n-\t  || ! TREE_CONSTANT (TYPE_SIZE (etype))))\n+      && (!TREE_CONSTANT (TYPE_SIZE (type))\n+\t  || !TREE_CONSTANT (TYPE_SIZE (etype))))\n     ;\n   else if (ecode == RECORD_TYPE && TYPE_IS_PADDING_P (etype))\n     {\n       /* If we have just converted to this padded type, just get\n \t the inner expression.  */\n       if (TREE_CODE (expr) == CONSTRUCTOR\n-\t  && CONSTRUCTOR_ELTS (expr) != 0\n+\t  && CONSTRUCTOR_ELTS (expr)\n \t  && TREE_PURPOSE (CONSTRUCTOR_ELTS (expr)) == TYPE_FIELDS (etype))\n \treturn TREE_VALUE (CONSTRUCTOR_ELTS (expr));\n       else\n-\treturn convert (type, build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t\t   TYPE_FIELDS (etype), 0));\n+\treturn convert (type,\n+\t\t\tbuild_component_ref (expr, NULL_TREE,\n+\t\t\t\t\t     TYPE_FIELDS (etype), false));\n     }\n   else if (code == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n     {\n       /* If we previously converted from another type and our type is\n \t of variable size, remove the conversion to avoid the need for\n \t variable-size temporaries.  */\n       if (TREE_CODE (expr) == VIEW_CONVERT_EXPR\n-\t  && ! TREE_CONSTANT (TYPE_SIZE (type)))\n+\t  && !TREE_CONSTANT (TYPE_SIZE (type)))\n \texpr = TREE_OPERAND (expr, 0);\n \n       /* If we are just removing the padding from expr, convert the original\n@@ -2762,15 +2774,15 @@ convert (tree type, tree expr)\n       if (TREE_CODE (expr) == COMPONENT_REF\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == RECORD_TYPE\n \t  && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (expr, 0)))\n-\t  && ! TREE_CONSTANT (TYPE_SIZE (type)))\n+\t  && !TREE_CONSTANT (TYPE_SIZE (type)))\n \treturn convert (type, TREE_OPERAND (expr, 0));\n \n       /* If the result type is a padded type with a self-referentially-sized\n \t field and the expression type is a record, do this as an\n \t unchecked converstion.  */\n       else if (TREE_CODE (etype) == RECORD_TYPE\n \t       && CONTAINS_PLACEHOLDER_P (DECL_SIZE (TYPE_FIELDS (type))))\n-\treturn unchecked_convert (type, expr, 0);\n+\treturn unchecked_convert (type, expr, false);\n \n       else\n \treturn\n@@ -2795,7 +2807,7 @@ convert (tree type, tree expr)\n   if (ecode == RECORD_TYPE && TYPE_LEFT_JUSTIFIED_MODULAR_P (etype)\n       && code != UNCONSTRAINED_ARRAY_TYPE)\n     return convert (type, build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t       TYPE_FIELDS (etype), 0));\n+\t\t\t\t\t       TYPE_FIELDS (etype), false));\n \n   /* If converting to a type that contains a template, convert to the data\n      type and then build the template. */\n@@ -2837,8 +2849,8 @@ convert (tree type, tree expr)\n       /* If we are converting a STRING_CST to another constrained array type,\n \t just make a new one in the proper type.  */\n       if (code == ecode && AGGREGATE_TYPE_P (etype)\n-\t  && ! (TREE_CODE (TYPE_SIZE (etype)) == INTEGER_CST\n-\t\t&& TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\t  && !(TREE_CODE (TYPE_SIZE (etype)) == INTEGER_CST\n+\t       && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n \t  && (TREE_CODE (expr) == STRING_CST\n \t      || get_alias_set (etype) == get_alias_set (type)))\n \t{\n@@ -2854,14 +2866,14 @@ convert (tree type, tree expr)\n       expr = build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t     build_component_ref (TREE_OPERAND (expr, 0),\n \t\t\t\t\t\t  get_identifier (\"P_ARRAY\"),\n-\t\t\t\t\t\t  NULL_TREE, 0));\n+\t\t\t\t\t\t  NULL_TREE, false));\n       etype = TREE_TYPE (expr);\n       ecode = TREE_CODE (etype);\n       break;\n \n     case VIEW_CONVERT_EXPR:\n       if (AGGREGATE_TYPE_P (type) && AGGREGATE_TYPE_P (etype)\n-\t  && ! TYPE_FAT_POINTER_P (type) && ! TYPE_FAT_POINTER_P (etype))\n+\t  && !TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype))\n \treturn convert (type, TREE_OPERAND (expr, 0));\n       break;\n \n@@ -2878,7 +2890,7 @@ convert (tree type, tree expr)\n \t      || TREE_CODE (type) == UNION_TYPE)\n \t  && (TREE_CODE (etype) == RECORD_TYPE\n \t      || TREE_CODE (etype) == UNION_TYPE)\n-\t  && ! TYPE_FAT_POINTER_P (type) && ! TYPE_FAT_POINTER_P (etype))\n+\t  && !TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype))\n \treturn build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t       convert (build_pointer_type (type),\n \t\t\t\t\tTREE_OPERAND (expr, 0)));\n@@ -2889,7 +2901,7 @@ convert (tree type, tree expr)\n     }\n \n   /* Check for converting to a pointer to an unconstrained array.  */\n-  if (TYPE_FAT_POINTER_P (type) && ! TYPE_FAT_POINTER_P (etype))\n+  if (TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype))\n     return convert_to_fat_pointer (type, expr);\n \n   /* If we're converting between two aggregate types that have the same main\n@@ -2916,7 +2928,7 @@ convert (tree type, tree expr)\n       if (TYPE_HAS_ACTUAL_BOUNDS_P (type)\n \t  && (ecode == ARRAY_TYPE || ecode == UNCONSTRAINED_ARRAY_TYPE\n \t      || (ecode == RECORD_TYPE && TYPE_CONTAINS_TEMPLATE_P (etype))))\n-\treturn unchecked_convert (type, expr, 0);\n+\treturn unchecked_convert (type, expr, false);\n       else if (TYPE_BIASED_REPRESENTATION_P (type))\n \treturn fold (build1 (CONVERT_EXPR, type,\n \t\t\t     fold (build (MINUS_EXPR, TREE_TYPE (type),\n@@ -2952,22 +2964,22 @@ convert (tree type, tree expr)\n \n       /* If converting to a thin pointer, handle specially.  */\n       if (TYPE_THIN_POINTER_P (type)\n-\t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)) != 0)\n+\t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)))\n \treturn convert_to_thin_pointer (type, expr);\n \n       /* If converting fat pointer to normal pointer, get the pointer to the\n \t array and then convert it.  */\n       else if (TYPE_FAT_POINTER_P (etype))\n \texpr = build_component_ref (expr, get_identifier (\"P_ARRAY\"),\n-\t\t\t\t    NULL_TREE, 0);\n+\t\t\t\t    NULL_TREE, false);\n \n       return fold (convert_to_pointer (type, expr));\n \n     case REAL_TYPE:\n       return fold (convert_to_real (type, expr));\n \n     case RECORD_TYPE:\n-      if (TYPE_LEFT_JUSTIFIED_MODULAR_P (type) && ! AGGREGATE_TYPE_P (etype))\n+      if (TYPE_LEFT_JUSTIFIED_MODULAR_P (type) && !AGGREGATE_TYPE_P (etype))\n \treturn\n \t  gnat_build_constructor\n \t    (type, tree_cons (TYPE_FIELDS (type),\n@@ -2980,7 +2992,7 @@ convert (tree type, tree expr)\n       /* In these cases, assume the front-end has validated the conversion.\n \t If the conversion is valid, it will be a bit-wise conversion, so\n \t it can be viewed as an unchecked conversion.  */\n-      return unchecked_convert (type, expr, 0);\n+      return unchecked_convert (type, expr, false);\n \n     case UNION_TYPE:\n       /* Just validate that the type is indeed that of a field\n@@ -2997,7 +3009,7 @@ convert (tree type, tree expr)\n \t\t\t   convert (TREE_TYPE (tem), expr));\n \t}\n \n-      gigi_abort (413);\n+      abort ();\n \n     case UNCONSTRAINED_ARRAY_TYPE:\n       /* If EXPR is a constrained array, take its address, convert it to a\n@@ -3025,31 +3037,31 @@ convert (tree type, tree expr)\n \t\t\t\t   build_unary_op (ADDR_EXPR,\n \t\t\t\t\t\t   NULL_TREE, expr)));\n       else\n-\tgigi_abort (409);\n+\tabort ();\n \n     case COMPLEX_TYPE:\n       return fold (convert_to_complex (type, expr));\n \n     default:\n-      gigi_abort (410);\n+      abort ();\n     }\n }\n \f\n /* Remove all conversions that are done in EXP.  This includes converting\n    from a padded type or to a left-justified modular type.  If TRUE_ADDRESS\n-   is nonzero, always return the address of the containing object even if\n+   is true, always return the address of the containing object even if\n    the address is not bit-aligned.  */\n \n tree\n-remove_conversions (tree exp, int true_address)\n+remove_conversions (tree exp, bool true_address)\n {\n   switch (TREE_CODE (exp))\n     {\n     case CONSTRUCTOR:\n       if (true_address\n \t  && TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n \t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (TREE_TYPE (exp)))\n-\treturn remove_conversions (TREE_VALUE (CONSTRUCTOR_ELTS (exp)), 1);\n+\treturn remove_conversions (TREE_VALUE (CONSTRUCTOR_ELTS (exp)), true);\n       break;\n \n     case COMPONENT_REF:\n@@ -3088,7 +3100,7 @@ maybe_unconstrained_array (tree exp)\n \t    = build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t      build_component_ref (TREE_OPERAND (exp, 0),\n \t\t\t\t\t\t   get_identifier (\"P_ARRAY\"),\n-\t\t\t\t\t\t   NULL_TREE, 0));\n+\t\t\t\t\t\t   NULL_TREE, false));\n \t  TREE_READONLY (new) = TREE_STATIC (new) = TREE_READONLY (exp);\n \t  return new;\n \t}\n@@ -3126,10 +3138,10 @@ maybe_unconstrained_array (tree exp)\n }\n \f\n /* Return an expression that does an unchecked converstion of EXPR to TYPE.\n-   If NOTRUNC_P is set, truncation operations should be suppressed.  */\n+   If NOTRUNC_P is true, truncation operations should be suppressed.  */\n \n tree\n-unchecked_convert (tree type, tree expr, int notrunc_p)\n+unchecked_convert (tree type, tree expr, bool notrunc_p)\n {\n   tree etype = TREE_TYPE (expr);\n \n@@ -3140,15 +3152,15 @@ unchecked_convert (tree type, tree expr, int notrunc_p)\n   /* If both types types are integral just do a normal conversion.\n      Likewise for a conversion to an unconstrained array.  */\n   if ((((INTEGRAL_TYPE_P (type)\n-\t && ! (TREE_CODE (type) == INTEGER_TYPE\n-\t       && TYPE_VAX_FLOATING_POINT_P (type)))\n+\t && !(TREE_CODE (type) == INTEGER_TYPE\n+\t      && TYPE_VAX_FLOATING_POINT_P (type)))\n \t|| (POINTER_TYPE_P (type) && ! TYPE_THIN_POINTER_P (type))\n \t|| (TREE_CODE (type) == RECORD_TYPE\n \t    && TYPE_LEFT_JUSTIFIED_MODULAR_P (type)))\n        && ((INTEGRAL_TYPE_P (etype)\n-\t    && ! (TREE_CODE (etype) == INTEGER_TYPE\n-\t\t  && TYPE_VAX_FLOATING_POINT_P (etype)))\n-\t   || (POINTER_TYPE_P (etype) && ! TYPE_THIN_POINTER_P (etype))\n+\t    && !(TREE_CODE (etype) == INTEGER_TYPE\n+\t\t && TYPE_VAX_FLOATING_POINT_P (etype)))\n+\t   || (POINTER_TYPE_P (etype) && !TYPE_THIN_POINTER_P (etype))\n \t   || (TREE_CODE (etype) == RECORD_TYPE\n \t       && TYPE_LEFT_JUSTIFIED_MODULAR_P (etype))))\n       || TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n@@ -3181,7 +3193,7 @@ unchecked_convert (tree type, tree expr, int notrunc_p)\n   /* If we are converting TO an integral type whose precision is not the\n      same as its size, first unchecked convert to a record that contains\n      an object of the output type.  Then extract the field. */\n-  else if (INTEGRAL_TYPE_P (type) && TYPE_RM_SIZE (type) != 0\n+  else if (INTEGRAL_TYPE_P (type) && TYPE_RM_SIZE (type)\n \t   && 0 != compare_tree_int (TYPE_RM_SIZE (type),\n \t\t\t\t     GET_MODE_BITSIZE (TYPE_MODE (type))))\n     {\n@@ -3198,7 +3210,7 @@ unchecked_convert (tree type, tree expr, int notrunc_p)\n \n   /* Similarly for integral input type whose precision is not equal to its\n      size.  */\n-  else if (INTEGRAL_TYPE_P (etype) && TYPE_RM_SIZE (etype) != 0\n+  else if (INTEGRAL_TYPE_P (etype) && TYPE_RM_SIZE (etype)\n       && 0 != compare_tree_int (TYPE_RM_SIZE (etype),\n \t\t\t\tGET_MODE_BITSIZE (TYPE_MODE (etype))))\n     {\n@@ -3240,19 +3252,19 @@ unchecked_convert (tree type, tree expr, int notrunc_p)\n      the result.  We need not do this in the case where the input is\n      an integral type of the same precision and signedness or if the output\n      is a biased type or if both the input and output are unsigned.  */\n-  if (! notrunc_p\n-      && INTEGRAL_TYPE_P (type) && TYPE_RM_SIZE (type) != 0\n-      && ! (TREE_CODE (type) == INTEGER_TYPE\n-\t    && TYPE_BIASED_REPRESENTATION_P (type))\n+  if (!notrunc_p\n+      && INTEGRAL_TYPE_P (type) && TYPE_RM_SIZE (type)\n+      && !(TREE_CODE (type) == INTEGER_TYPE\n+\t   && TYPE_BIASED_REPRESENTATION_P (type))\n       && 0 != compare_tree_int (TYPE_RM_SIZE (type),\n \t\t\t\tGET_MODE_BITSIZE (TYPE_MODE (type)))\n-      && ! (INTEGRAL_TYPE_P (etype)\n-\t    && TYPE_UNSIGNED (type) == TYPE_UNSIGNED (etype)\n-\t    && operand_equal_p (TYPE_RM_SIZE (type),\n-\t\t\t\t(TYPE_RM_SIZE (etype) != 0\n-\t\t\t\t ? TYPE_RM_SIZE (etype) : TYPE_SIZE (etype)),\n-\t\t\t\t0))\n-      && ! (TYPE_UNSIGNED (type) && TYPE_UNSIGNED (etype)))\n+      && !(INTEGRAL_TYPE_P (etype)\n+\t   && TYPE_UNSIGNED (type) == TYPE_UNSIGNED (etype)\n+\t   && operand_equal_p (TYPE_RM_SIZE (type),\n+\t\t\t       (TYPE_RM_SIZE (etype) != 0\n+\t\t\t\t? TYPE_RM_SIZE (etype) : TYPE_SIZE (etype)),\n+\t\t\t       0))\n+      && !(TYPE_UNSIGNED (type) && TYPE_UNSIGNED (etype)))\n     {\n       tree base_type = gnat_type_for_mode (TYPE_MODE (type),\n \t\t\t\t\t   TYPE_UNSIGNED (type));\n@@ -3282,8 +3294,8 @@ unchecked_convert (tree type, tree expr, int notrunc_p)\n   /* If the sizes of the types differ and this is an VIEW_CONVERT_EXPR,\n      show no longer constant.  */\n   if (TREE_CODE (expr) == VIEW_CONVERT_EXPR\n-      && ! operand_equal_p (TYPE_SIZE_UNIT (type), TYPE_SIZE_UNIT (etype),\n-\t\t\t    OEP_ONLY_CONST))\n+      && !operand_equal_p (TYPE_SIZE_UNIT (type), TYPE_SIZE_UNIT (etype),\n+\t\t\t   OEP_ONLY_CONST))\n     TREE_CONSTANT (expr) = 0;\n \n   return expr;"}, {"sha": "6d8ba355944ce4cf0a046e911ea6435d3280e03d", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 140, "deletions": 153, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -46,11 +46,11 @@\n #include \"gigi.h\"\n \n static tree find_common_type (tree, tree);\n-static int contains_save_expr_p (tree);\n+static bool contains_save_expr_p (tree);\n static tree contains_null_expr (tree);\n static tree compare_arrays (tree, tree, tree);\n static tree nonbinary_modular_operation (enum tree_code, tree, tree, tree);\n-static tree build_simple_component_ref (tree, tree, tree, int);\n+static tree build_simple_component_ref (tree, tree, tree, bool);\n \f\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n    operation.\n@@ -114,7 +114,7 @@ get_base_type (tree type)\n       && TYPE_LEFT_JUSTIFIED_MODULAR_P (type))\n     type = TREE_TYPE (TYPE_FIELDS (type));\n \n-  while (TREE_TYPE (type) != 0\n+  while (TREE_TYPE (type)\n \t && (TREE_CODE (type) == INTEGER_TYPE\n \t     || TREE_CODE (type) == REAL_TYPE))\n     type = TREE_TYPE (type);\n@@ -126,10 +126,10 @@ get_base_type (tree type)\n tree\n get_ada_base_type (tree type)\n {\n-  while (TREE_TYPE (type) != 0\n+  while (TREE_TYPE (type)\n \t && (TREE_CODE (type) == INTEGER_TYPE\n \t     || TREE_CODE (type) == REAL_TYPE)\n-\t && ! TYPE_EXTRA_SUBTYPE_P (type))\n+\t && !TYPE_EXTRA_SUBTYPE_P (type))\n     type = TREE_TYPE (type);\n \n   return type;\n@@ -159,7 +159,7 @@ known_alignment (tree exp)\n      type_alignment value to 0 when the type information is to be ignored.  */\n   type_alignment\n     = ((POINTER_TYPE_P (TREE_TYPE (exp))\n-\t&& ! TYPE_IS_DUMMY_P (TREE_TYPE (TREE_TYPE (exp))))\n+\t&& !TYPE_IS_DUMMY_P (TREE_TYPE (TREE_TYPE (exp))))\n        ? TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp))) : 0);\n \n   switch (TREE_CODE (exp))\n@@ -248,30 +248,30 @@ find_common_type (tree t1, tree t2)\n    ??? This is a real kludge, but is probably the best approach short\n    of some very general solution.  */\n \n-static int\n+static bool\n contains_save_expr_p (tree exp)\n {\n   switch (TREE_CODE (exp))\n     {\n     case SAVE_EXPR:\n-      return 1;\n+      return true;\n \n     case ADDR_EXPR:  case INDIRECT_REF:\n     case COMPONENT_REF:\n     case NOP_EXPR:  case CONVERT_EXPR: case VIEW_CONVERT_EXPR:\n       return contains_save_expr_p (TREE_OPERAND (exp, 0));\n \n     case CONSTRUCTOR:\n-      return (CONSTRUCTOR_ELTS (exp) != 0\n+      return (CONSTRUCTOR_ELTS (exp)\n \t      && contains_save_expr_p (CONSTRUCTOR_ELTS (exp)));\n \n     case TREE_LIST:\n       return (contains_save_expr_p (TREE_VALUE (exp))\n-\t      || (TREE_CHAIN (exp) != 0\n+\t      || (TREE_CHAIN (exp)\n \t\t  && contains_save_expr_p (TREE_CHAIN (exp))));\n \n     default:\n-      return 0;\n+      return false;\n     }\n }\n \f\n@@ -294,7 +294,7 @@ contains_null_expr (tree exp)\n \n     case '<':  case '2':\n       tem = contains_null_expr (TREE_OPERAND (exp, 0));\n-      if (tem != 0)\n+      if (tem)\n \treturn tem;\n \n       return contains_null_expr (TREE_OPERAND (exp, 1));\n@@ -307,11 +307,11 @@ contains_null_expr (tree exp)\n \n \tcase COND_EXPR:\n \t  tem = contains_null_expr (TREE_OPERAND (exp, 0));\n-\t  if (tem != 0)\n+\t  if (tem)\n \t    return tem;\n \n \t  tem = contains_null_expr (TREE_OPERAND (exp, 1));\n-\t  if (tem != 0)\n+\t  if (tem)\n \t    return tem;\n \n \t  return contains_null_expr (TREE_OPERAND (exp, 2));\n@@ -342,7 +342,7 @@ compare_arrays (tree result_type, tree a1, tree a2)\n   tree result = convert (result_type, integer_one_node);\n   tree a1_is_null = convert (result_type, integer_zero_node);\n   tree a2_is_null = convert (result_type, integer_zero_node);\n-  int length_zero_p = 0;\n+  bool length_zero_p = false;\n \n   /* Process each dimension separately and compare the lengths.  If any\n      dimension has a size known to be zero, set SIZE_ZERO_P to 1 to\n@@ -364,8 +364,8 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t unless the length of the second array is the constant zero.\n \t Note that we have set the `length' values to the length - 1.  */\n       if (TREE_CODE (length1) == INTEGER_CST\n-\t  && ! integer_zerop (fold (build (PLUS_EXPR, bt, length2,\n-\t\t\t\t\t   convert (bt, integer_one_node)))))\n+\t  && !integer_zerop (fold (build (PLUS_EXPR, bt, length2,\n+\t\t\t\t\t  convert (bt, integer_one_node)))))\n \t{\n \t  tem = a1, a1 = a2, a2 = tem;\n \t  tem = t1, t1 = t2, t2 = tem;\n@@ -388,7 +388,7 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n \t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n \n-\t  length_zero_p = 1;\n+\t  length_zero_p = true;\n \t  this_a1_is_null = comparison;\n \t  this_a2_is_null = convert (result_type, integer_one_node);\n \t}\n@@ -450,11 +450,11 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \n   /* Unless the size of some bound is known to be zero, compare the\n      data in the array.  */\n-  if (! length_zero_p)\n+  if (!length_zero_p)\n     {\n       tree type = find_common_type (TREE_TYPE (a1), TREE_TYPE (a2));\n \n-      if (type != 0)\n+      if (type)\n \ta1 = convert (type, a1), a2 = convert (type, a2);\n \n       result = build_binary_op (TRUTH_ANDIF_EXPR, result_type, result,\n@@ -486,15 +486,13 @@ compare_arrays (tree result_type, tree a1, tree a2)\n    modulus.  */\n \n static tree\n-nonbinary_modular_operation (enum tree_code op_code,\n-                             tree type,\n-                             tree lhs,\n+nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n                              tree rhs)\n {\n   tree modulus = TYPE_MODULUS (type);\n   unsigned int needed_precision = tree_floor_log2 (modulus) + 1;\n   unsigned int precision;\n-  int unsignedp = 1;\n+  bool unsignedp = true;\n   tree op_type = type;\n   tree result;\n \n@@ -516,7 +514,7 @@ nonbinary_modular_operation (enum tree_code op_code,\n \n   /* Unsigned will do for everything but subtraction.  */\n   if (op_code == MINUS_EXPR)\n-    unsignedp = 0;\n+    unsignedp = false;\n \n   /* If our type is the wrong signedness or isn't wide enough, make a new\n      type and convert both our operands to it.  */\n@@ -594,22 +592,22 @@ build_binary_op (enum tree_code op_code, tree result_type,\n   tree left_base_type = get_base_type (left_type);\n   tree right_base_type = get_base_type (right_type);\n   tree operation_type = result_type;\n-  tree best_type = 0;\n+  tree best_type = NULL_TREE;\n   tree modulus;\n   tree result;\n-  int has_side_effects = 0;\n+  bool has_side_effects = false;\n \n-  if (operation_type != 0\n+  if (operation_type\n       && TREE_CODE (operation_type) == RECORD_TYPE\n       && TYPE_LEFT_JUSTIFIED_MODULAR_P (operation_type))\n     operation_type = TREE_TYPE (TYPE_FIELDS (operation_type));\n \n-  if (operation_type != 0\n-      && ! AGGREGATE_TYPE_P (operation_type)\n+  if (operation_type\n+      && !AGGREGATE_TYPE_P (operation_type)\n       && TYPE_EXTRA_SUBTYPE_P (operation_type))\n     operation_type = get_base_type (operation_type);\n \n-  modulus = (operation_type != 0 && TREE_CODE (operation_type) == INTEGER_TYPE\n+  modulus = (operation_type && TREE_CODE (operation_type) == INTEGER_TYPE\n \t     && TYPE_MODULAR_P (operation_type)\n \t     ? TYPE_MODULUS (operation_type) : 0);\n \n@@ -633,7 +631,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t\t || (((TREE_CODE (left_type) == RECORD_TYPE\n \t\t       /* Don't remove conversions to left-justified modular\n \t\t\t  types. */\n-\t\t       && ! TYPE_LEFT_JUSTIFIED_MODULAR_P (left_type))\n+\t\t       && !TYPE_LEFT_JUSTIFIED_MODULAR_P (left_type))\n \t\t      || TREE_CODE (left_type) == ARRAY_TYPE)\n \t\t     && ((TREE_CODE (TREE_TYPE\n \t\t\t\t     (TREE_OPERAND (left_operand, 0)))\n@@ -651,7 +649,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t  left_type = TREE_TYPE (left_operand);\n \t}\n \n-      if (operation_type == 0)\n+      if (!operation_type)\n \toperation_type = left_type;\n \n       /* If the RHS has a conversion between record and array types and\n@@ -661,18 +659,18 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t type, which we must not remove.  */\n       while (TREE_CODE (right_operand) == VIEW_CONVERT_EXPR\n \t     && ((TREE_CODE (right_type) == RECORD_TYPE\n-\t\t  && ! TYPE_LEFT_JUSTIFIED_MODULAR_P (right_type)\n-\t\t  && ! TYPE_ALIGN_OK (right_type)\n-\t\t  && ! TYPE_IS_FAT_POINTER_P (right_type))\n+\t\t  && !TYPE_LEFT_JUSTIFIED_MODULAR_P (right_type)\n+\t\t  && !TYPE_ALIGN_OK (right_type)\n+\t\t  && !TYPE_IS_FAT_POINTER_P (right_type))\n \t\t || TREE_CODE (right_type) == ARRAY_TYPE)\n \t     && (((TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n \t\t   == RECORD_TYPE)\n-\t\t  && ! (TYPE_LEFT_JUSTIFIED_MODULAR_P\n-\t\t\t(TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n-\t\t  && ! (TYPE_ALIGN_OK\n-\t\t\t(TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n-\t\t  && ! (TYPE_IS_FAT_POINTER_P\n-\t\t\t(TREE_TYPE (TREE_OPERAND (right_operand, 0)))))\n+\t\t  && !(TYPE_LEFT_JUSTIFIED_MODULAR_P\n+\t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n+\t\t  && !(TYPE_ALIGN_OK\n+\t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n+\t\t  && !(TYPE_IS_FAT_POINTER_P\n+\t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0)))))\n \t\t || (TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n \t\t     == ARRAY_TYPE))\n \t     && (0 == (best_type\n@@ -691,7 +689,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t    && TREE_CODE (right_type) == ARRAY_TYPE)\n \t   || (TREE_CODE (left_type) == RECORD_TYPE\n \t       && TREE_CODE (right_type) == RECORD_TYPE))\n-\t  && (best_type = find_common_type (left_type, right_type)) != 0)\n+\t  && (best_type = find_common_type (left_type, right_type)))\n \toperation_type = best_type;\n \n       /* If a class-wide type may be involved, force use of the RHS type.  */\n@@ -735,38 +733,31 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t}\n \n       if (TREE_CODE (result) != INDIRECT_REF && TREE_CODE (result) != NULL_EXPR\n-\t  && ! DECL_P (result))\n-\tgigi_abort (516);\n+\t  && !DECL_P (result))\n+\tabort ();\n \n       /* Convert the right operand to the operation type unless\n \t it is either already of the correct type or if the type\n \t involves a placeholder, since the RHS may not have the same\n \t record type.  */\n       if (operation_type != right_type\n-\t  && (! CONTAINS_PLACEHOLDER_P (TYPE_SIZE (operation_type))))\n+\t  && (!CONTAINS_PLACEHOLDER_P (TYPE_SIZE (operation_type))))\n \t{\n \t  right_operand = convert (operation_type, right_operand);\n \t  right_type = operation_type;\n \t}\n \n-      /* If the modes differ, make up a bogus type and convert the RHS to\n-\t it.  This can happen with packed types.  */\n-      if (TYPE_MODE (left_type) != TYPE_MODE (right_type))\n-\t{\n-\t  tree new_type = copy_node (left_type);\n-\n-\t  TYPE_SIZE (new_type) = TYPE_SIZE (right_type);\n-\t  TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (right_type);\n-\t  TYPE_MAIN_VARIANT (new_type) = new_type;\n-\t  right_operand = convert (new_type, right_operand);\n-\t}\n+      /* If the left operand is not the same type as the operation type,\n+\t surround it in a VIEW_CONVERT_EXPR.  */\n+      if (left_type != operation_type)\n+\tleft_operand = unchecked_convert (operation_type, left_operand, false);\n \n-      has_side_effects = 1;\n-      modulus = 0;\n+      has_side_effects = true;\n+      modulus = NULL_TREE;\n       break;\n \n     case ARRAY_REF:\n-      if (operation_type == 0)\n+      if (!operation_type)\n \toperation_type = TREE_TYPE (left_type);\n \n       /* ... fall through ... */\n@@ -779,19 +770,19 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       right_operand = convert (right_base_type, right_operand);\n       right_operand = convert (TYPE_DOMAIN (left_type), right_operand);\n \n-      if (! TREE_CONSTANT (right_operand)\n-\t  || ! TREE_CONSTANT (TYPE_MIN_VALUE (right_type)))\n+      if (!TREE_CONSTANT (right_operand)\n+\t  || !TREE_CONSTANT (TYPE_MIN_VALUE (right_type)))\n \tgnat_mark_addressable (left_operand);\n \n-      modulus = 0;\n+      modulus = NULL_TREE;\n       break;\n \n     case GE_EXPR:\n     case LE_EXPR:\n     case GT_EXPR:\n     case LT_EXPR:\n       if (POINTER_TYPE_P (left_type))\n-\tgigi_abort (501);\n+\tabort ();\n \n       /* ... fall through ... */\n \n@@ -845,7 +836,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t  else if (op_code == NE_EXPR)\n \t    result = invert_truthvalue (result);\n \t  else\n-\t    gigi_abort (502);\n+\t    abort ();\n \n \t  return result;\n \t}\n@@ -862,28 +853,28 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t\t types have the same name.  In that case, one of them must\n \t\t not be self-referential.  Use that one as the best type.\n \t\t Even better is if one is of fixed size.  */\n-\t      best_type = 0;\n+\t      best_type = NULL_TREE;\n \n-\t      if (TYPE_NAME (left_base_type) == 0\n+\t      if (!TYPE_NAME (left_base_type)\n \t\t  || TYPE_NAME (left_base_type) != TYPE_NAME (right_base_type))\n-\t\tgigi_abort (503);\n+\t\tabort ();\n \n \t      if (TREE_CONSTANT (TYPE_SIZE (left_base_type)))\n \t\tbest_type = left_base_type;\n \t      else if (TREE_CONSTANT (TYPE_SIZE (right_base_type)))\n \t\tbest_type = right_base_type;\n-\t      else if (! CONTAINS_PLACEHOLDER_P (TYPE_SIZE (left_base_type)))\n+\t      else if (!CONTAINS_PLACEHOLDER_P (TYPE_SIZE (left_base_type)))\n \t\tbest_type = left_base_type;\n-\t      else if (! CONTAINS_PLACEHOLDER_P (TYPE_SIZE (right_base_type)))\n+\t      else if (!CONTAINS_PLACEHOLDER_P (TYPE_SIZE (right_base_type)))\n \t\tbest_type = right_base_type;\n \t      else\n-\t\tgigi_abort (504);\n+\t\tabort ();\n \n \t      left_operand = convert (best_type, left_operand);\n \t      right_operand = convert (best_type, right_operand);\n \t    }\n \t  else\n-\t    gigi_abort (505);\n+\t    abort ();\n \t}\n \n       /* If we are comparing a fat pointer against zero, we need to\n@@ -895,7 +886,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t{\n \t  right_operand = build_component_ref (left_operand, NULL_TREE,\n \t\t\t\t\t       TYPE_FIELDS (left_base_type),\n-\t\t\t\t\t       0);\n+\t\t\t\t\t       false);\n \t  left_operand = convert (TREE_TYPE (right_operand),\n \t\t\t\t  integer_zero_node);\n \t}\n@@ -905,7 +896,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t  right_operand = convert (right_base_type, right_operand);\n \t}\n \n-      modulus = 0;\n+      modulus = NULL_TREE;\n       break;\n \n     case PREINCREMENT_EXPR:\n@@ -921,13 +912,13 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t be done for modular types.  */\n \n       if (left_type != result_type)\n-\tgigi_abort (506);\n+\tabort ();\n \n       operation_type = get_base_type (result_type);\n       left_operand = convert (operation_type, left_operand);\n       right_operand = convert (operation_type, right_operand);\n-      has_side_effects = 1;\n-      modulus = 0;\n+      has_side_effects = true;\n+      modulus = NULL_TREE;\n       break;\n \n     case LSHIFT_EXPR:\n@@ -938,9 +929,9 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t (we used to abort, but this is needed for unchecked conversion\n \t to modular types).  Otherwise, processing is the same as normal.  */\n       if (operation_type != left_base_type)\n-\tgigi_abort (514);\n+\tabort ();\n \n-      modulus = 0;\n+      modulus = NULL_TREE;\n       left_operand = convert (operation_type, left_operand);\n       break;\n \n@@ -958,15 +949,15 @@ build_binary_op (enum tree_code op_code, tree result_type,\n     case BIT_XOR_EXPR:\n       /* For binary modulus, if the inputs are in range, so are the\n \t outputs.  */\n-      if (modulus != 0 && integer_pow2p (modulus))\n-\tmodulus = 0;\n+      if (modulus && integer_pow2p (modulus))\n+\tmodulus = NULL_TREE;\n \n       goto common;\n \n     case COMPLEX_EXPR:\n       if (TREE_TYPE (result_type) != left_base_type\n \t  || TREE_TYPE (result_type) != right_base_type)\n-\tgigi_abort (515);\n+\tabort ();\n \n       left_operand = convert (left_base_type, left_operand);\n       right_operand = convert (right_base_type, right_operand);\n@@ -977,7 +968,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n     case FLOOR_DIV_EXPR:   case FLOOR_MOD_EXPR:\n     case ROUND_DIV_EXPR:   case ROUND_MOD_EXPR:\n       /* These always produce results lower than either operand.  */\n-      modulus = 0;\n+      modulus = NULL_TREE;\n       goto common;\n \n     default:\n@@ -988,17 +979,17 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \n       if (operation_type != left_base_type\n \t  || left_base_type != right_base_type)\n-\tgigi_abort (507);\n+\tabort ();\n \n       left_operand = convert (operation_type, left_operand);\n       right_operand = convert (operation_type, right_operand);\n     }\n \n-  if (modulus != 0 && ! integer_pow2p (modulus))\n+  if (modulus && !integer_pow2p (modulus))\n     {\n       result = nonbinary_modular_operation (op_code, operation_type,\n \t\t\t\t\t    left_operand, right_operand);\n-      modulus = 0;\n+      modulus = NULL_TREE;\n     }\n   /* If either operand is a NULL_EXPR, just return a new one.  */\n   else if (TREE_CODE (left_operand) == NULL_EXPR)\n@@ -1023,11 +1014,11 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \n   /* If we are working with modular types, perform the MOD operation\n      if something above hasn't eliminated the need for it.  */\n-  if (modulus != 0)\n+  if (modulus)\n     result = fold (build (FLOOR_MOD_EXPR, operation_type, result,\n \t\t\t  convert (operation_type, modulus)));\n \n-  if (result_type != 0 && result_type != operation_type)\n+  if (result_type && result_type != operation_type)\n     result = convert (result_type, result);\n \n   return result;\n@@ -1042,33 +1033,33 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n   tree base_type = get_base_type (type);\n   tree operation_type = result_type;\n   tree result;\n-  int side_effects = 0;\n+  bool side_effects = false;\n \n-  if (operation_type != 0\n+  if (operation_type\n       && TREE_CODE (operation_type) == RECORD_TYPE\n       && TYPE_LEFT_JUSTIFIED_MODULAR_P (operation_type))\n     operation_type = TREE_TYPE (TYPE_FIELDS (operation_type));\n \n-  if (operation_type != 0\n-      && ! AGGREGATE_TYPE_P (operation_type)\n+  if (operation_type\n+      && !AGGREGATE_TYPE_P (operation_type)\n       && TYPE_EXTRA_SUBTYPE_P (operation_type))\n     operation_type = get_base_type (operation_type);\n \n   switch (op_code)\n     {\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      if (operation_type == 0)\n+      if (!operation_type)\n \tresult_type = operation_type = TREE_TYPE (type);\n       else if (result_type != TREE_TYPE (type))\n-\tgigi_abort (513);\n+\tabort ();\n \n       result = fold (build1 (op_code, operation_type, operand));\n       break;\n \n     case TRUTH_NOT_EXPR:\n       if (result_type != base_type)\n-\tgigi_abort (508);\n+\tabort ();\n \n       result = invert_truthvalue (gnat_truthvalue_conversion (operand));\n       break;\n@@ -1083,7 +1074,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \n \t  /* Make sure the type here is a pointer, not a reference.\n \t     GCC wants pointer types for function addresses.  */\n-\t  if (result_type == 0)\n+\t  if (!result_type)\n \t    result_type = build_pointer_type (type);\n \t  break;\n \n@@ -1122,7 +1113,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t\t\t\t inner);\n \n \t      /* Compute the offset as a byte offset from INNER.  */\n-\t      if (offset == 0)\n+\t      if (!offset)\n \t\toffset = size_zero_node;\n \n \t      if (bitpos % BITS_PER_UNIT != 0)\n@@ -1176,9 +1167,8 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t      && (TYPE_MODE (type)\n \t\t  == TYPE_MODE (TREE_TYPE (TREE_OPERAND (operand, 0)))))\n \t    return build_unary_op (ADDR_EXPR,\n-\t\t\t\t   (result_type == 0\n-\t\t\t\t    ? build_pointer_type (type)\n-\t\t\t\t    : result_type),\n+\t\t\t\t   (result_type ? result_type\n+\t\t\t\t    : build_pointer_type (type)),\n \t\t\t\t   TREE_OPERAND (operand, 0));\n \t  goto common;\n \n@@ -1217,7 +1207,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t the backend.  If TYPE is a thin pointer, first convert the\n \t operand to a fat pointer.  */\n       if (TYPE_THIN_POINTER_P (type)\n-\t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)) != 0)\n+\t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)))\n \t{\n \t  operand\n \t    = convert (TREE_TYPE (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type))),\n@@ -1242,26 +1232,26 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t}\n \n       side_effects\n-\t=  (! TYPE_FAT_POINTER_P (type) && TYPE_VOLATILE (TREE_TYPE (type)));\n+\t=  (!TYPE_FAT_POINTER_P (type) && TYPE_VOLATILE (TREE_TYPE (type)));\n       break;\n \n     case NEGATE_EXPR:\n     case BIT_NOT_EXPR:\n       {\n-\ttree modulus = ((operation_type != 0\n+\ttree modulus = ((operation_type\n \t\t\t && TREE_CODE (operation_type) == INTEGER_TYPE\n \t\t\t && TYPE_MODULAR_P (operation_type))\n \t\t\t? TYPE_MODULUS (operation_type) : 0);\n-\tint mod_pow2 = modulus != 0 && integer_pow2p (modulus);\n+\tint mod_pow2 = modulus && integer_pow2p (modulus);\n \n \t/* If this is a modular type, there are various possibilities\n \t   depending on the operation and whether the modulus is a\n \t   power of two or not.  */\n \n-\tif (modulus != 0)\n+\tif (modulus)\n \t  {\n \t    if (operation_type != base_type)\n-\t      gigi_abort (509);\n+\t      abort ();\n \n \t    operand = convert (operation_type, operand);\n \n@@ -1278,7 +1268,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t       else return the modulus minus the operand.  If the modulus\n \t       is a power of two minus one, we can do the subtraction\n \t       as an XOR since it is equivalent and faster on most machines. */\n-\t    else if (op_code == NEGATE_EXPR && ! mod_pow2)\n+\t    else if (op_code == NEGATE_EXPR && !mod_pow2)\n \t      {\n \t\tif (integer_pow2p (fold (build (PLUS_EXPR, operation_type,\n \t\t\t\t\t\tmodulus,\n@@ -1324,7 +1314,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \n     default:\n       if (operation_type != base_type)\n-\tgigi_abort (509);\n+\tabort ();\n \n       result = fold (build1 (op_code, operation_type, convert (operation_type,\n \t\t\t\t\t\t\t       operand)));\n@@ -1337,7 +1327,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \tTREE_THIS_VOLATILE (result) = TYPE_VOLATILE (TREE_TYPE (result));\n     }\n \n-  if (result_type != 0 && TREE_TYPE (result) != result_type)\n+  if (result_type && TREE_TYPE (result) != result_type)\n     result = convert (result_type, result);\n \n   return result;\n@@ -1350,7 +1340,7 @@ build_cond_expr (tree result_type, tree condition_operand,\n                  tree true_operand, tree false_operand)\n {\n   tree result;\n-  int addr_p = 0;\n+  bool addr_p = false;\n \n   /* The front-end verifies that result, true and false operands have same base\n      type.  Convert everything to the result type.  */\n@@ -1363,7 +1353,7 @@ build_cond_expr (tree result_type, tree condition_operand,\n   if (TREE_CODE (result_type) == UNCONSTRAINED_ARRAY_TYPE\n       || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (result_type)))\n     {\n-      addr_p = 1;\n+      addr_p = true;\n       result_type = build_pointer_type (result_type);\n       true_operand = build_unary_op (ADDR_EXPR, result_type, true_operand);\n       false_operand = build_unary_op (ADDR_EXPR, result_type, false_operand);\n@@ -1469,22 +1459,22 @@ tree\n gnat_build_constructor (tree type, tree list)\n {\n   tree elmt;\n-  int allconstant = (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST);\n-  int side_effects = 0;\n+  bool allconstant = (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST);\n+  bool side_effects = false;\n   tree result;\n \n   for (elmt = list; elmt; elmt = TREE_CHAIN (elmt))\n     {\n-      if (! TREE_CONSTANT (TREE_VALUE (elmt))\n+      if (!TREE_CONSTANT (TREE_VALUE (elmt))\n \t  || (TREE_CODE (type) == RECORD_TYPE\n \t      && DECL_BIT_FIELD (TREE_PURPOSE (elmt))\n \t      && TREE_CODE (TREE_VALUE (elmt)) != INTEGER_CST)\n-\t  || ! initializer_constant_valid_p (TREE_VALUE (elmt),\n-\t\t\t\t\t     TREE_TYPE (TREE_VALUE (elmt))))\n-\tallconstant = 0;\n+\t  || !initializer_constant_valid_p (TREE_VALUE (elmt),\n+\t\t\t\t\t    TREE_TYPE (TREE_VALUE (elmt))))\n+\tallconstant = false;\n \n       if (TREE_SIDE_EFFECTS (TREE_VALUE (elmt)))\n-\tside_effects = 1;\n+\tside_effects = true;\n \n       /* Propagate an NULL_EXPR from the size of the type.  We won't ever\n \t be executing the code we generate here in that case, but handle it\n@@ -1510,7 +1500,7 @@ gnat_build_constructor (tree type, tree list)\n \t  if (TREE_CODE (this_pos) != INTEGER_CST\n \t      || tree_int_cst_lt (this_pos, last_pos))\n \t    {\n-\t      allconstant = 0;\n+\t      allconstant = false;\n \t      break;\n \t    }\n \n@@ -1529,38 +1519,35 @@ gnat_build_constructor (tree type, tree list)\n \f\n /* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n    an IDENTIFIER_NODE giving the name of the field, or FIELD, a FIELD_DECL,\n-   for the field.  Don't fold the result if NO_FOLD_P is nonzero.\n+   for the field.  Don't fold the result if NO_FOLD_P is true.\n \n    We also handle the fact that we might have been passed a pointer to the\n    actual record and know how to look for fields in variant parts.  */\n \n static tree\n build_simple_component_ref (tree record_variable, tree component,\n-                            tree field, int no_fold_p)\n+                            tree field, bool no_fold_p)\n {\n   tree record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_variable));\n   tree ref;\n \n   if ((TREE_CODE (record_type) != RECORD_TYPE\n        && TREE_CODE (record_type) != UNION_TYPE\n        && TREE_CODE (record_type) != QUAL_UNION_TYPE)\n-      || TYPE_SIZE (record_type) == 0)\n-    gigi_abort (510);\n-\n-  /* Either COMPONENT or FIELD must be specified, but not both.  */\n-  if ((component != 0) == (field != 0))\n-    gigi_abort (511);\n+      || !TYPE_SIZE (record_type)\n+      || (component != 0) == (field != 0))\n+    abort ();\n \n   /* If no field was specified, look for a field with the specified name\n      in the current record only.  */\n-  if (field == 0)\n+  if (!field)\n     for (field = TYPE_FIELDS (record_type); field;\n \t field = TREE_CHAIN (field))\n       if (DECL_NAME (field) == component)\n \tbreak;\n \n-  if (field == 0)\n-    return 0;\n+  if (!field)\n+    return NULL_TREE;\n \n   /* If this field is not in the specified record, see if we can find\n      something in the record whose original field is the same as this one. */\n@@ -1571,11 +1558,11 @@ build_simple_component_ref (tree record_variable, tree component,\n \n       /* First loop thru normal components.  */\n \n-      for (new_field = TYPE_FIELDS (record_type); new_field != 0;\n+      for (new_field = TYPE_FIELDS (record_type); new_field;\n \t   new_field = TREE_CHAIN (new_field))\n \tif (DECL_ORIGINAL_FIELD (new_field) == field\n \t    || new_field == DECL_ORIGINAL_FIELD (field)\n-\t    || (DECL_ORIGINAL_FIELD (field) != 0\n+\t    || (DECL_ORIGINAL_FIELD (field)\n \t\t&& (DECL_ORIGINAL_FIELD (field)\n \t\t    == DECL_ORIGINAL_FIELD (new_field))))\n \t  break;\n@@ -1585,8 +1572,8 @@ build_simple_component_ref (tree record_variable, tree component,\n          is required to avoiding hidden homonymous fields in the\n          _Parent field.  */\n \n-      if (new_field == 0)\n-\tfor (new_field = TYPE_FIELDS (record_type); new_field != 0;\n+      if (!new_field)\n+\tfor (new_field = TYPE_FIELDS (record_type); new_field;\n \t     new_field = TREE_CHAIN (new_field))\n \t  if (DECL_INTERNAL_P (new_field))\n \t    {\n@@ -1596,15 +1583,15 @@ build_simple_component_ref (tree record_variable, tree component,\n \t      ref = build_simple_component_ref (field_ref, NULL_TREE, field,\n \t\t\t\t\t\tno_fold_p);\n \n-\t      if (ref != 0)\n+\t      if (ref)\n \t\treturn ref;\n \t    }\n \n       field = new_field;\n     }\n \n-  if (field == 0)\n-    return 0;\n+  if (!field)\n+    return NULL_TREE;\n \n   /* It would be nice to call \"fold\" here, but that can lose a type\n      we need to tag a PLACEHOLDER_EXPR with, so we can't do it.  */\n@@ -1625,23 +1612,23 @@ build_simple_component_ref (tree record_variable, tree component,\n \n tree\n build_component_ref (tree record_variable, tree component,\n-                     tree field, int no_fold_p)\n+                     tree field, bool no_fold_p)\n {\n   tree ref = build_simple_component_ref (record_variable, component, field,\n \t\t\t\t\t no_fold_p);\n \n-  if (ref != 0)\n+  if (ref)\n     return ref;\n \n   /* If FIELD was specified, assume this is an invalid user field so\n      raise constraint error.  Otherwise, we can't find the type to return, so\n      abort.  */\n \n-  else if (field != 0)\n+  else if (field)\n     return build1 (NULL_EXPR, TREE_TYPE (field),\n \t\t   build_call_raise (CE_Discriminant_Check_Failed));\n   else\n-    gigi_abort (512);\n+    abort ();\n }\n \f\n /* Build a GCC tree to call an allocation or deallocation function.\n@@ -1746,15 +1733,15 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n     {\n       /* If the size is a constant, we can put it in the fixed portion of\n \t the stack frame to avoid the need to adjust the stack pointer.  */\n-      if (TREE_CODE (gnu_size) == INTEGER_CST && ! flag_stack_check)\n+      if (TREE_CODE (gnu_size) == INTEGER_CST && !flag_stack_check)\n \t{\n \t  tree gnu_range\n \t    = build_range_type (NULL_TREE, size_one_node, gnu_size);\n \t  tree gnu_array_type = build_array_type (char_type_node, gnu_range);\n \t  tree gnu_decl\n \t    = create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n-\t\t\t       gnu_array_type, NULL_TREE, 0, 0, 0, 0, 0,\n-\t\t\t       gnat_node);\n+\t\t\t       gnu_array_type, NULL_TREE, false, false, false,\n+\t\t\t       false, NULL, gnat_node);\n \n \t  return convert (ptr_void_type_node,\n \t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE, gnu_decl));\n@@ -1787,7 +1774,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n   tree result;\n \n   /* If the initializer, if present, is a NULL_EXPR, just return a new one.  */\n-  if (init != 0 && TREE_CODE (init) == NULL_EXPR)\n+  if (init && TREE_CODE (init) == NULL_EXPR)\n     return build1 (NULL_EXPR, result_type, TREE_OPERAND (init, 0));\n \n   /* If RESULT_TYPE is a fat or thin pointer, set SIZE to be the sum of the\n@@ -1823,15 +1810,15 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t{\n \t  type = TREE_TYPE (TYPE_FIELDS (type));\n \n-\t  if (init != 0)\n+\t  if (init)\n \t    init = convert (type, init);\n \t}\n \n       /* If there is an initializing expression, make a constructor for\n \t the entire object including the bounds and copy it into the\n \t object.  If there is no initializing expression, just set the\n \t bounds.  */\n-      if (init != 0)\n+      if (init)\n \t{\n \t  template_cons = tree_cons (TREE_CHAIN (TYPE_FIELDS (storage_type)),\n \t\t\t\t     init, NULL_TREE);\n@@ -1865,7 +1852,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \n   /* If we have an initializing expression, see if its size is simpler\n      than the size from the type.  */\n-  if (init != 0 && TYPE_SIZE_UNIT (TREE_TYPE (init)) != 0\n+  if (init && TYPE_SIZE_UNIT (TREE_TYPE (init))\n       && (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (init))) == INTEGER_CST\n \t  || CONTAINS_PLACEHOLDER_P (size)))\n     size = TYPE_SIZE_UNIT (TREE_TYPE (init));\n@@ -1876,10 +1863,10 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n      the maximum size.  */\n   if (CONTAINS_PLACEHOLDER_P (size))\n     {\n-      if (init == 0)\n-\tsize = max_size (size, 1);\n-      else\n+      if (init)\n \tsize = substitute_placeholder_in_expr (size, init);\n+      else\n+\tsize = max_size (size, true);\n     }\n \n   /* If the size overflows, pass -1 so the allocator will raise\n@@ -1942,7 +1929,7 @@ fill_vms_descriptor (tree expr, Entity_Id gnat_formal)\n {\n   tree record_type = TREE_TYPE (TREE_TYPE (get_gnu_tree (gnat_formal)));\n   tree field;\n-  tree const_list = 0;\n+  tree const_list = NULL_TREE;\n \n   expr = maybe_unconstrained_array (expr);\n   gnat_mark_addressable (expr);\n@@ -1995,7 +1982,7 @@ gnat_mark_addressable (tree expr_node)\n \treturn true;\n \n       case CONST_DECL:\n-\treturn (DECL_CONST_CORRESPONDING_VAR (expr_node) != 0\n+\treturn (DECL_CONST_CORRESPONDING_VAR (expr_node)\n \t\t&& (gnat_mark_addressable\n \t\t    (DECL_CONST_CORRESPONDING_VAR (expr_node))));\n       default:"}, {"sha": "fc924434ad209815cc42b119c83d8cdbc6fa8060", "filename": "gcc/ada/vms_conv.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fvms_conv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fvms_conv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.adb?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -360,6 +360,16 @@ package body VMS_Conv is\n             Params   => new Parameter_Array'(1 => Unlimited_Files),\n             Defext   => \"   \"),\n \n+         Setup =>\n+           (Cname    => new S'(\"SETUP\"),\n+            Usage    => new S'(\"GNAT SETUP /qualifiers\"),\n+            VMS_Only => False,\n+            Unixcmd  => new S'(\"\"),\n+            Unixsws  => null,\n+            Switches => Setup_Switches'Access,\n+            Params   => new Parameter_Array'(1 => Unlimited_Files),\n+            Defext   => \"   \"),\n+\n          Shared =>\n            (Cname    => new S'(\"SHARED\"),\n             Usage    => new S'(\"GNAT SHARED [obj_&_lib_&_exe_&_opt\""}, {"sha": "fb0e4dd9c0d4b49e51e2573d1636aa2a97ce7c9d", "filename": "gcc/ada/vms_conv.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fvms_conv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fvms_conv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.ads?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -97,7 +97,8 @@ package VMS_Conv is\n \n    type Command_Type is\n      (Bind, Chop, Clean, Compile, Elim, Find, Krunch, Library, Link, List,\n-      Make, Metric, Name, Preprocess, Pretty, Shared, Stub, Xref, Undefined);\n+      Make, Metric, Name, Preprocess, Pretty, Setup, Shared, Stub, Xref,\n+      Undefined);\n \n    type Alternate_Command is (Comp, Ls, Kr, Pp, Prep);\n    --  Alternate command libel for non VMS system"}, {"sha": "e90ea6de86299102bf6eb259f4444f49c21edda6", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/615cbd95bd73d35bdf41475f60243f9d9fefc5f4/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=615cbd95bd73d35bdf41475f60243f9d9fefc5f4", "patch": "@@ -4940,6 +4940,69 @@ package VMS_Data is\n       S_Pretty_Verbose   'Access,\n       S_Pretty_Warnings  'Access);\n \n+   -----------------------------\n+   -- Switches for GNAT SETUP --\n+   -----------------------------\n+\n+   S_Setup_Ext       : aliased constant S := \"/EXTERNAL_REFERENCE=\" & '\"' &\n+                                              \"-X\" & '\"';\n+   --        /EXTERNAL_REFERENCE=\"name=val\"\n+   --\n+   --   Specifies an external reference to the project manager. Useful only if\n+   --   /PROJECT_FILE is used.\n+   --\n+   --   Example:\n+   --      /EXTERNAL_REFERENCE=\"DEBUG=TRUE\"\n+\n+   S_Setup_Mess      : aliased constant S := \"/MESSAGES_PROJECT_FILE=\"    &\n+                                             \"DEFAULT \"                   &\n+                                                \"-vP0 \"                   &\n+                                             \"MEDIUM \"                    &\n+                                                \"-vP1 \"                   &\n+                                             \"HIGH \"                      &\n+                                                \"-vP2\";\n+   --        /MESSAGES_PROJECT_FILE[=messages-option]\n+   --\n+   --   Specifies the \"verbosity\" of the parsing of project files.\n+   --   messages-option may be one of the following:\n+   --\n+   --      DEFAULT (D)  No messages are output if there is no error or warning.\n+   --\n+   --      MEDIUM       A small number of messages are output.\n+   --\n+   --      HIGH         A great number of messages are output, most of them not\n+   --                   being useful for the user.\n+\n+   S_Setup_Project   : aliased constant S := \"/PROJECT_FILE=<\"            &\n+                                                \"-P>\";\n+   --        /PROJECT_FILE=filename\n+   --\n+   --   Specifies the main project file to be used. The project files rooted\n+   --   at the main project file are parsed and non existing object\n+   --   directories, library directories and exec directories are created.\n+\n+   S_Setup_Quiet     : aliased constant S := \"/QUIET \"                    &\n+                                            \"-q\";\n+   --        /NOQUIET (D)\n+   --        /QUIET\n+   --\n+   --   Work quietly, only output warnings and errors.\n+\n+   S_Setup_Verbose   : aliased constant S := \"/VERBOSE \"                  &\n+                                              \"-v\";\n+   --        /NOVERBOSE (D)\n+   --        /VERBOSE\n+   --\n+   --   Verbose mode; GNAT PRETTY generates version information and then a\n+   --   trace of the actions it takes to produce or obtain the ASIS tree.\n+\n+   Setup_Switches : aliased constant Switches :=\n+     (S_Setup_Ext     'Access,\n+      S_Setup_Mess    'Access,\n+      S_Setup_Project 'Access,\n+      S_Setup_Quiet   'Access,\n+      S_Setup_Verbose 'Access);\n+\n    ------------------------------\n    -- Switches for GNAT SHARED --\n    ------------------------------"}]}