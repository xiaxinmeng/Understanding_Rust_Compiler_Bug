{"sha": "b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU4ZDNkZjI5ZmQwYzM3YTJkNTExNWZjOWM3MDhjZmZjYzM3OWZmYw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-11-27T09:36:20Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-11-27T09:36:20Z"}, "message": "Fix memory leak in cilk\n\n\tPR c++/68312\n\t* c-array-notation.c (fix_builtin_array_notation_fn):\n\tUse release_vec_vec instead of vec::release.\n\t(build_array_notation_expr): Likewise.\n\t(fix_conditional_array_notations_1): Likewise.\n\t(fix_array_notation_expr): Likewise.\n\t(fix_array_notation_call_expr): Likewise.\n\tPR c++/68312\n\t* cp-array-notation.c (expand_sec_reduce_builtin):\n\tLikewise.\n\t(create_array_refs): Replace argument with const reference.\n\t(expand_an_in_modify_expr): Likewise.\n\t(cp_expand_cond_array_notations): Likewise.\n\t(expand_unary_array_notation_exprs): Likewise.\n\tPR c++/68312\n\t* array-notation-common.c (cilkplus_extract_an_triplets):\n\tRelease vector of vectors.\n\t* cilk.c (gimplify_cilk_spawn): Free allocated memory.\n\tPR c++/68312\n\t* vec.h (release_vec_vec): New function.\n\nFrom-SVN: r231001", "tree": {"sha": "dd1adb68f7048a3707687ccc46f906e3f92b822d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd1adb68f7048a3707687ccc46f906e3f92b822d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d95edca1212e23855e4f613b588cbc6dac89999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d95edca1212e23855e4f613b588cbc6dac89999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d95edca1212e23855e4f613b588cbc6dac89999"}], "stats": {"total": 144, "additions": 92, "deletions": 52}, "files": [{"sha": "24fb40fb90cc3b120c50a79219b8d9ecaf66133e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "patch": "@@ -1,3 +1,8 @@\n+2015-11-27  Martin Liska  <mliska@suse.cz>\n+\n+\tPR c++/68312\n+\t* vec.h (release_vec_vec): New function.\n+\n 2015-11-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/68552"}, {"sha": "ad0fbc1c73559485f4608cc49fc91866d371393c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "patch": "@@ -1,3 +1,10 @@\n+2015-11-27  Martin Liska  <mliska@suse.cz>\n+\n+\tPR c++/68312\n+\t* array-notation-common.c (cilkplus_extract_an_triplets):\n+\tRelease vector of vectors.\n+\t* cilk.c (gimplify_cilk_spawn): Free allocated memory.\n+\n 2015-11-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR c++/68527"}, {"sha": "5f2209dbc31aedc45c07fdd6df0bf4a170bef8ea", "filename": "gcc/c-family/array-notation-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fc-family%2Farray-notation-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fc-family%2Farray-notation-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Farray-notation-common.c?ref=b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "patch": "@@ -636,6 +636,8 @@ cilkplus_extract_an_triplets (vec<tree, va_gc> *list, size_t size, size_t rank,\n \t      fold_build1 (CONVERT_EXPR, integer_type_node,\n \t\t\t   ARRAY_NOTATION_STRIDE (ii_tree));\n \t  }\n+\n+  release_vec_vec (array_exprs);\n }\n \n /* Replaces all the __sec_implicit_arg functions in LIST with the induction"}, {"sha": "99ff75a3966f19a19d81045952ef832a5de3a632", "filename": "gcc/c-family/cilk.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "patch": "@@ -857,6 +857,7 @@ gimplify_cilk_spawn (tree *spawn_p)\n \t\t\t    call2, build_empty_stmt (EXPR_LOCATION (call1)));\n   append_to_statement_list (spawn_expr, spawn_p);\n \n+  free (arg_array);\n   return GS_OK;\n }\n "}, {"sha": "ffa365c1f7231e82ef8c4a06edb99a9410a88e7d", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "patch": "@@ -1,3 +1,13 @@\n+2015-11-27  Martin Liska  <mliska@suse.cz>\n+\n+\tPR c++/68312\n+\t* c-array-notation.c (fix_builtin_array_notation_fn):\n+\tUse release_vec_vec instead of vec::release.\n+\t(build_array_notation_expr): Likewise.\n+\t(fix_conditional_array_notations_1): Likewise.\n+\t(fix_array_notation_expr): Likewise.\n+\t(fix_array_notation_call_expr): Likewise.\n+\n 2015-11-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/63326"}, {"sha": "8d5876a4b32f8b8fa21c0e140fe736a86f2f8251", "filename": "gcc/c/c-array-notation.c", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fc%2Fc-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fc%2Fc-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-array-notation.c?ref=b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "patch": "@@ -205,7 +205,7 @@ fix_builtin_array_notation_fn (tree an_builtin_fn, tree *new_var)\n   location_t location = UNKNOWN_LOCATION;\n   tree loop_with_init = alloc_stmt_list ();\n   vec<vec<an_parts> > an_info = vNULL;\n-  vec<an_loop_parts> an_loop_info = vNULL;\n+  auto_vec<an_loop_parts> an_loop_info;\n   enum built_in_function an_type =\n     is_cilkplus_reduce_builtin (CALL_EXPR_FN (an_builtin_fn));\n   if (an_type == BUILT_IN_NONE)\n@@ -593,8 +593,7 @@ fix_builtin_array_notation_fn (tree an_builtin_fn, tree *new_var)\n     }\n   append_to_statement_list_force (body, &loop_with_init);\n \n-  an_info.release ();\n-  an_loop_info.release ();\n+  release_vec_vec (an_info);\n   \n   return loop_with_init;\n }\n@@ -614,7 +613,7 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n   tree array_expr_lhs = NULL_TREE, array_expr_rhs = NULL_TREE;\n   tree array_expr = NULL_TREE;\n   tree an_init = NULL_TREE;\n-  vec<tree> cond_expr = vNULL;\n+  auto_vec<tree> cond_expr;\n   tree body, loop_with_init = alloc_stmt_list();\n   tree scalar_mods = NULL_TREE;\n   vec<tree, va_gc> *rhs_array_operand = NULL, *lhs_array_operand = NULL;\n@@ -624,7 +623,7 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n   tree new_modify_expr, new_var = NULL_TREE, builtin_loop = NULL_TREE;\n   size_t rhs_list_size = 0, lhs_list_size = 0; \n   vec<vec<an_parts> > lhs_an_info = vNULL, rhs_an_info = vNULL;\n-  vec<an_loop_parts> lhs_an_loop_info = vNULL, rhs_an_loop_info = vNULL;\n+  auto_vec<an_loop_parts> lhs_an_loop_info, rhs_an_loop_info;\n   \n   /* If either of this is true, an error message must have been send out\n      already.  Not necessary to send out multiple error messages.  */\n@@ -771,7 +770,7 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n \t  && length_mismatch_in_expr_p (EXPR_LOCATION (rhs), rhs_an_info)))\n     {\n       pop_stmt_list (an_init);\n-      return error_mark_node;\n+      goto error;\n     }\n   if (lhs_list_size > 0 && rhs_list_size > 0 && lhs_rank > 0 && rhs_rank > 0\n       && TREE_CODE (lhs_an_info[0][0].length) == INTEGER_CST\n@@ -786,7 +785,7 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n \t{\n \t  error_at (location, \"length mismatch between LHS and RHS\");\n \t  pop_stmt_list (an_init);\n-\t  return error_mark_node;\n+\t  goto error;\n \t}\n     }\n   for (ii = 0; ii < lhs_rank; ii++)\n@@ -829,7 +828,7 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n \t\t\t\t\t\t rhs_an_loop_info, rhs_rank,\n \t\t\t\t\t\t rhs);\n       if (!rhs_array_operand)\n-\treturn error_mark_node;\n+\tgoto error;\n       replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n     }\n   else if (rhs_list_size > 0)\n@@ -838,7 +837,7 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n \t\t\t\t\t\t lhs_an_loop_info, lhs_rank,\n \t\t\t\t\t\t lhs);\n       if (!rhs_array_operand)\n-\treturn error_mark_node;\n+\tgoto error;\n       replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n     }\n   array_expr_lhs = lhs;\n@@ -881,15 +880,15 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n     }\n   append_to_statement_list_force (body, &loop_with_init);\n \n-  lhs_an_info.release ();\n-  lhs_an_loop_info.release ();\n-  if (rhs_rank)\n-    {\n-      rhs_an_info.release ();\n-      rhs_an_loop_info.release ();\n-    }\n-  cond_expr.release ();\n+  release_vec_vec (lhs_an_info);\n+  release_vec_vec (rhs_an_info);\n   return loop_with_init;\n+\n+error:\n+  release_vec_vec (lhs_an_info);\n+  release_vec_vec (rhs_an_info);\n+\n+  return error_mark_node;\n }\n \n /* Helper function for fix_conditional_array_notations.  Encloses the \n@@ -909,7 +908,7 @@ fix_conditional_array_notations_1 (tree stmt)\n   location_t location = EXPR_LOCATION (stmt);\n   tree body = NULL_TREE, loop_with_init = alloc_stmt_list ();\n   vec<vec<an_parts> > an_info = vNULL;\n-  vec<an_loop_parts> an_loop_info = vNULL;\n+  auto_vec<an_loop_parts> an_loop_info;\n  \n   if (TREE_CODE (stmt) == COND_EXPR)\n     cond = COND_EXPR_COND (stmt);\n@@ -1005,9 +1004,7 @@ fix_conditional_array_notations_1 (tree stmt)\n       body = pop_stmt_list (new_loop);\n     }\n   append_to_statement_list_force (body, &loop_with_init);\n-\n-  an_loop_info.release ();\n-  an_info.release ();\n+  release_vec_vec (an_info);\n \n   return loop_with_init;\n }\n@@ -1048,7 +1045,7 @@ fix_array_notation_expr (location_t location, enum tree_code code,\n   tree loop_init;\n   tree body, loop_with_init = alloc_stmt_list ();\n   vec<vec<an_parts> > an_info = vNULL;\n-  vec<an_loop_parts> an_loop_info = vNULL;\n+  auto_vec<an_loop_parts> an_loop_info;\n   \n   if (!find_rank (location, arg.value, arg.value, false, &rank))\n     {\n@@ -1110,8 +1107,7 @@ fix_array_notation_expr (location_t location, enum tree_code code,\n     }\n   append_to_statement_list_force (body, &loop_with_init);\n   arg.value = loop_with_init;\n-  an_info.release ();\n-  an_loop_info.release ();\n+  release_vec_vec (an_info);\n   return arg;\n }\n \n@@ -1128,7 +1124,7 @@ fix_array_notation_call_expr (tree arg)\n   tree body, loop_with_init = alloc_stmt_list ();\n   location_t location = UNKNOWN_LOCATION;\n   vec<vec<an_parts> > an_info = vNULL;\n-  vec<an_loop_parts> an_loop_info = vNULL;\n+  auto_vec<an_loop_parts> an_loop_info;\n \n   if (TREE_CODE (arg) == CALL_EXPR\n       && is_cilkplus_reduce_builtin (CALL_EXPR_FN (arg)))\n@@ -1194,8 +1190,7 @@ fix_array_notation_call_expr (tree arg)\n       body = pop_stmt_list (new_loop);\n     }\n   append_to_statement_list_force (body, &loop_with_init);\n-  an_loop_info.release ();\n-  an_info.release ();\n+  release_vec_vec (an_info);\n   return loop_with_init;\n }\n "}, {"sha": "b4243369fb2872c848d21fa14fc29bac7f6d53d9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "patch": "@@ -1,3 +1,13 @@\n+2015-11-27  Martin Liska  <mliska@suse.cz>\n+\n+\tPR c++/68312\n+\t* cp-array-notation.c (expand_sec_reduce_builtin):\n+\tLikewise.\n+\t(create_array_refs): Replace argument with const reference.\n+\t(expand_an_in_modify_expr): Likewise.\n+\t(cp_expand_cond_array_notations): Likewise.\n+\t(expand_unary_array_notation_exprs): Likewise.\n+\n 2015-11-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/63326"}, {"sha": "8862af1bc4d761dde7ae9b1db8f0ba1a8422d3ea", "filename": "gcc/cp/cp-array-notation.c", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fcp%2Fcp-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fcp%2Fcp-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-array-notation.c?ref=b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "patch": "@@ -210,7 +210,7 @@ expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n   enum tree_code code = NOP_EXPR;\n   location_t location = UNKNOWN_LOCATION;\n   vec<vec<an_parts> > an_info = vNULL;\n-  vec<an_loop_parts> an_loop_info = vNULL; \n+  auto_vec<an_loop_parts> an_loop_info;\n   enum built_in_function an_type =\n     is_cilkplus_reduce_builtin (CALL_EXPR_FN (an_builtin_fn));\n   vec <tree, va_gc> *func_args;\n@@ -494,8 +494,7 @@ expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n     }\n   append_to_statement_list (body, &loop_with_init);\n \n-  an_info.release ();\n-  an_loop_info.release ();\n+  release_vec_vec (an_info);\n \n   return loop_with_init;\n }\n@@ -512,7 +511,7 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n   tree array_expr_lhs = NULL_TREE, array_expr_rhs = NULL_TREE;\n   tree array_expr = NULL_TREE;\n   tree body = NULL_TREE;\n-  vec<tree> cond_expr = vNULL;\n+  auto_vec<tree> cond_expr;\n   vec<tree, va_gc> *lhs_array_operand = NULL, *rhs_array_operand = NULL;\n   size_t lhs_rank = 0, rhs_rank = 0, ii = 0;\n   vec<tree, va_gc> *rhs_list = NULL, *lhs_list = NULL;\n@@ -521,7 +520,8 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n   bool found_builtin_fn = false;\n   tree an_init, loop_with_init = alloc_stmt_list ();\n   vec<vec<an_parts> > lhs_an_info = vNULL, rhs_an_info = vNULL;\n-  vec<an_loop_parts> lhs_an_loop_info = vNULL, rhs_an_loop_info = vNULL;\n+  auto_vec<an_loop_parts> lhs_an_loop_info, rhs_an_loop_info;\n+  tree lhs_len, rhs_len;\n \n   if (!find_rank (location, rhs, rhs, false, &rhs_rank))\n     return error_mark_node;\n@@ -645,11 +645,11 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n \t\t\t\t\t\t rhs_an_info)))\n     {\n       pop_stmt_list (an_init);\n-      return error_mark_node;\n+      goto error;\n     }\n-  tree rhs_len = ((rhs_list_size > 0 && rhs_rank > 0) ?\n+  rhs_len = ((rhs_list_size > 0 && rhs_rank > 0) ?\n     rhs_an_info[0][0].length : NULL_TREE);\n-  tree lhs_len = ((lhs_list_size > 0 && lhs_rank > 0) ?\n+  lhs_len = ((lhs_list_size > 0 && lhs_rank > 0) ?\n     lhs_an_info[0][0].length : NULL_TREE);\n   if (lhs_list_size > 0 && rhs_list_size > 0 && lhs_rank > 0 && rhs_rank > 0\n       && TREE_CODE (lhs_len) == INTEGER_CST && rhs_len\n@@ -658,7 +658,7 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n     { \n       error_at (location, \"length mismatch between LHS and RHS\"); \n       pop_stmt_list (an_init); \n-      return error_mark_node;\n+      goto error;\n     }\n    for (ii = 0; ii < lhs_rank; ii++) \n      {\n@@ -676,7 +676,7 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n \t\t\t\t\t\t  lhs_an_loop_info, lhs_rank,\n \t\t\t\t\t\t  lhs); \n        if (!rhs_array_operand)\n-\t return error_mark_node;\n+\t goto error;\n      }\n   replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n   rhs_list_size = 0;\n@@ -717,7 +717,7 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n \t\t\t\t\t\t rhs_an_loop_info, rhs_rank,\n \t\t\t\t\t\t rhs);\n       if (!rhs_array_operand)\n-\treturn error_mark_node;\n+\tgoto error;\n       replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n     }\n \n@@ -768,16 +768,16 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n     }\n   append_to_statement_list (body, &loop_with_init);\n \n-  lhs_an_info.release ();\n-  lhs_an_loop_info.release ();\n-  if (rhs_rank) \n-    { \n-      rhs_an_info.release (); \n-      rhs_an_loop_info.release ();\n-    }\n-  cond_expr.release ();\n+  release_vec_vec (lhs_an_info);\n+  release_vec_vec (rhs_an_info);\n \n   return loop_with_init;\n+\n+error:\n+  release_vec_vec (lhs_an_info);\n+  release_vec_vec (rhs_an_info);\n+\n+  return error_mark_node;\n }\n \n /* Helper function for expand_conditonal_array_notations.  Encloses the\n@@ -796,7 +796,7 @@ cp_expand_cond_array_notations (tree orig_stmt)\n   tree loop_with_init = alloc_stmt_list ();\n   location_t location = UNKNOWN_LOCATION;\n   vec<vec<an_parts> > an_info = vNULL;\n-  vec<an_loop_parts> an_loop_info = vNULL;\n+  auto_vec<an_loop_parts> an_loop_info;\n \n   if (TREE_CODE (orig_stmt) == COND_EXPR)\n     {\n@@ -957,8 +957,7 @@ cp_expand_cond_array_notations (tree orig_stmt)\n     }\n   append_to_statement_list (body, &loop_with_init);\n \n-  an_info.release ();\n-  an_loop_info.release ();\n+  release_vec_vec (an_info);\n   \n   return loop_with_init;\n }\n@@ -977,7 +976,7 @@ expand_unary_array_notation_exprs (tree orig_stmt)\n   location_t location = EXPR_LOCATION (orig_stmt);\n   tree an_init, loop_with_init = alloc_stmt_list ();\n   vec<vec<an_parts> > an_info = vNULL;\n-  vec<an_loop_parts> an_loop_info = vNULL;\n+  auto_vec<an_loop_parts> an_loop_info;\n   \n   if (!find_rank (location, orig_stmt, orig_stmt, true, &rank))\n     return error_mark_node;\n@@ -1060,8 +1059,7 @@ expand_unary_array_notation_exprs (tree orig_stmt)\n     }\n   append_to_statement_list (body, &loop_with_init);\n \n-  an_info.release ();\n-  an_loop_info.release ();\n+  release_vec_vec (an_info);\n \n   return loop_with_init;\n }"}, {"sha": "ed300b48c7fd9ee0e49b634aba68fe3c185f8b9b", "filename": "gcc/vec.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58d3df29fd0c37a2d5115fc9c708cffcc379ffc/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=b58d3df29fd0c37a2d5115fc9c708cffcc379ffc", "patch": "@@ -1702,6 +1702,18 @@ vec<T, va_heap, vl_ptr>::using_auto_storage () const\n   return m_vec->m_vecpfx.m_using_auto_storage;\n }\n \n+/* Release VEC and call release of all element vectors.  */\n+\n+template<typename T>\n+inline void\n+release_vec_vec (vec<vec<T> > &vec)\n+{\n+  for (unsigned i = 0; i < vec.length (); i++)\n+    vec[i].release ();\n+\n+  vec.release ();\n+}\n+\n #if (GCC_VERSION >= 3000)\n # pragma GCC poison m_vec m_vecpfx m_vecdata\n #endif"}]}