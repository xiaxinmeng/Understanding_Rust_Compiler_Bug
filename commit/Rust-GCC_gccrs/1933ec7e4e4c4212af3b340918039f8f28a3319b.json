{"sha": "1933ec7e4e4c4212af3b340918039f8f28a3319b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkzM2VjN2U0ZTRjNDIxMmFmM2IzNDA5MTgwMzlmOGYyOGEzMzE5Yg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1997-10-18T05:46:19Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-10-18T05:46:19Z"}, "message": "v850.c (ep_memory_offset): New function.\n\n        * v850.c (ep_memory_offset): New function.\n        (ep_memory_operand, substitute_ep_register, v850_reorg): Call it.\n\n        * v850.h (CONST_OK_FOR_*): Add and correct comments.\n        (CONSTANT_ADDRESS_P): Add comment.\n        (EXTRA_CONSTRAINT): Define 'U'.\n        * v850.md: Add comments on bit field instructions.\n        (addsi3): Delete &r/r/r alternative.  Add r/r/U alternative.\n        (lshrsi3): Use N not J constraint.\n\n        * v850.md (v850_tst1+1): New define_split for tst1 instruction.\n\n        * v850.c (reg_or_0_operand): Call register_operand.\n        (reg_or_int5_operand): Likewise.\n        * v850.h (MASK_BIG_SWITCH, TARGET_BIG_SWITCH): New macros.\n        (TARGET_SWITCHES): Add \"big-switch\".\n        (ASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT, CASE_VECTOR_MODE,\n        ASM_OUTPUT_BEFORE_BASE_LABEL): Add support for TARGET_BIG_SWITCH.\n        (CASE_DROPS_THROUGH): Comment out.\n        (CASE_VECTOR_PC_RELATIVE, JUMP_TABLES_IN_TEXT_SECTION): Define.\n        * v850.md (cmpsi): Delete compare mode.\n        (casesi): New pattern.\n\n        * v850.h (CONST_OK_FOR_N): Delete redundant compare against zero.\n        * v850.md (ashlsi3): Use SImode not QImode for shift count.\n        (lshrsi3): Likewise.\n\n        * v850.c (print_operand): Add 'c', 'C', and 'z' support.  Delete\n        unreachable switch statement after 'b' support.  Remove \"b\" from\n        strings for 'b' support.\n        * v850.md (branch_normal, branch_invert): Change %b to b%b.\n\nv850 patches from Jim.\n\nFrom-SVN: r15992", "tree": {"sha": "8cae98058ed9ce63295b4215a6e9b8b9ed231f41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cae98058ed9ce63295b4215a6e9b8b9ed231f41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1933ec7e4e4c4212af3b340918039f8f28a3319b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1933ec7e4e4c4212af3b340918039f8f28a3319b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1933ec7e4e4c4212af3b340918039f8f28a3319b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1933ec7e4e4c4212af3b340918039f8f28a3319b/comments", "author": null, "committer": null, "parents": [{"sha": "13c2de98de6b965b2ac2839205487a4f79e75b82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c2de98de6b965b2ac2839205487a4f79e75b82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13c2de98de6b965b2ac2839205487a4f79e75b82"}], "stats": {"total": 364, "additions": 232, "deletions": 132}, "files": [{"sha": "45adb8493bb715d1697f91330e21e8c7bed3fabc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ec7e4e4c4212af3b340918039f8f28a3319b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ec7e4e4c4212af3b340918039f8f28a3319b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1933ec7e4e4c4212af3b340918039f8f28a3319b", "patch": "@@ -1,3 +1,37 @@\n+Fri Oct 17 23:48:52 1997  Jim Wilson  (wilson@cygnus.com)\n+\n+\t* v850.c (ep_memory_offset): New function.\n+\t(ep_memory_operand, substitute_ep_register, v850_reorg): Call it.\n+\n+\t* v850.h (CONST_OK_FOR_*): Add and correct comments.\n+\t(CONSTANT_ADDRESS_P): Add comment.\n+\t(EXTRA_CONSTRAINT): Define 'U'.\n+\t* v850.md: Add comments on bit field instructions.\n+\t(addsi3): Delete &r/r/r alternative.  Add r/r/U alternative.\n+\t(lshrsi3): Use N not J constraint. \n+\n+\t* v850.md (v850_tst1+1): New define_split for tst1 instruction.\n+\n+\t* v850.c (reg_or_0_operand): Call register_operand.\n+\t(reg_or_int5_operand): Likewise.\n+\t* v850.h (MASK_BIG_SWITCH, TARGET_BIG_SWITCH): New macros.\n+\t(TARGET_SWITCHES): Add \"big-switch\".\n+\t(ASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT, CASE_VECTOR_MODE,\n+\tASM_OUTPUT_BEFORE_BASE_LABEL): Add support for TARGET_BIG_SWITCH.\n+\t(CASE_DROPS_THROUGH): Comment out.\n+\t(CASE_VECTOR_PC_RELATIVE, JUMP_TABLES_IN_TEXT_SECTION): Define.\n+\t* v850.md (cmpsi): Delete compare mode.\n+\t(casesi): New pattern.\n+\n+\t* v850.h (CONST_OK_FOR_N): Delete redundant compare against zero.\n+\t* v850.md (ashlsi3): Use SImode not QImode for shift count.\n+\t(lshrsi3): Likewise.\n+\n+\t* v850.c (print_operand): Add 'c', 'C', and 'z' support.  Delete\n+\tunreachable switch statement after 'b' support.  Remove \"b\" from\n+\tstrings for 'b' support.\n+\t* v850.md (branch_normal, branch_invert): Change %b to b%b.\n+\n Fri Oct 17 23:33:20 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* Makefile.in (LIBGCC2_CFLAGS): Avoid a backslash then an"}, {"sha": "79ae10f9fbef219a8c01f345d7c2520986b7e5bc", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 72, "deletions": 107, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ec7e4e4c4212af3b340918039f8f28a3319b/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ec7e4e4c4212af3b340918039f8f28a3319b/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=1933ec7e4e4c4212af3b340918039f8f28a3319b", "patch": "@@ -307,73 +307,46 @@ print_operand (file, x, code)\n     {\n     case 'b':\n     case 'B':\n-      switch (code == 'b' ? GET_CODE (x) : reverse_condition (GET_CODE (x)))\n+    case 'c':\n+    case 'C':\n+      switch ((code == 'B' || code == 'C')\n+\t      ? reverse_condition (GET_CODE (x)) : GET_CODE (x))\n \t{\n \t  case NE:\n-\t    fprintf (file, \"bne\");\n+\t    if (code == 'c' || code == 'C')\n+\t      fprintf (file, \"nz\");\n+\t    else\n+\t      fprintf (file, \"ne\");\n \t    break;\n \t  case EQ:\n-\t    fprintf (file, \"be\");\n+\t    if (code == 'c' || code == 'C')\n+\t      fprintf (file, \"z\");\n+\t    else\n+\t      fprintf (file, \"e\");\n \t    break;\n \t  case GE:\n-\t    fprintf (file, \"bge\");\n+\t    fprintf (file, \"ge\");\n \t    break;\n \t  case GT:\n-\t    fprintf (file, \"bgt\");\n+\t    fprintf (file, \"gt\");\n \t    break;\n \t  case LE:\n-\t    fprintf (file, \"ble\");\n+\t    fprintf (file, \"le\");\n \t    break;\n \t  case LT:\n-\t    fprintf (file, \"blt\");\n+\t    fprintf (file, \"lt\");\n \t    break;\n \t  case GEU:\n-\t    fprintf (file, \"bnl\");\n+\t    fprintf (file, \"nl\");\n \t    break;\n \t  case GTU:\n-\t    fprintf (file, \"bh\");\n+\t    fprintf (file, \"h\");\n \t    break;\n \t  case LEU:\n-\t    fprintf (file, \"bnh\");\n+\t    fprintf (file, \"nh\");\n \t    break;\n \t  case LTU:\n-\t    fprintf (file, \"bl\");\n-\t    break;\n-\t  default:\n-\t    abort ();\n-\t}\n-      break;\n-      switch (GET_CODE (x))\n-\t{\n-\t  case NE:\n-\t    fprintf (file, \"be\");\n-\t    break;\n-\t  case EQ:\n-\t    fprintf (file, \"bne\");\n-\t    break;\n-\t  case GE:\n-\t    fprintf (file, \"blt\");\n-\t    break;\n-\t  case GT:\n-\t    fprintf (file, \"bgt\");\n-\t    break;\n-\t  case LE:\n-\t    fprintf (file, \"ble\");\n-\t    break;\n-\t  case LT:\n-\t    fprintf (file, \"blt\");\n-\t    break;\n-\t  case GEU:\n-\t    fprintf (file, \"bnl\");\n-\t    break;\n-\t  case GTU:\n-\t    fprintf (file, \"bh\");\n-\t    break;\n-\t  case LEU:\n-\t    fprintf (file, \"bnh\");\n-\t    break;\n-\t  case LTU:\n-\t    fprintf (file, \"bl\");\n+\t    fprintf (file, \"l\");\n \t    break;\n \t  default:\n \t    abort ();\n@@ -504,6 +477,14 @@ print_operand (file, x, code)\n     case '.':\t\t\t/* register r0 */\n       fputs (reg_names[0], file);\n       break;\n+    case 'z':\t\t\t/* reg or zero */\n+      if (x == const0_rtx)\n+\tfputs (reg_names[0], file);\n+      else if (GET_CODE (x) == REG)\n+\tfputs (reg_names[REGNO (x)], file);\n+      else\n+\tabort ();\n+      break;\n     default:\n       switch (GET_CODE (x))\n \t{\n@@ -821,43 +802,54 @@ output_move_double (operands)\n }\n \n \f\n-/* Return true if OP is a valid short EP memory reference */\n+/* Return maximum offset supported for a short EP memory reference of mode\n+   MODE and signedness UNSIGNEDP.  */\n \n int\n-ep_memory_operand (op, mode, unsigned_load)\n-     rtx op;\n+ep_memory_offset (mode, unsignedp)\n      enum machine_mode mode;\n-     int unsigned_load;\n+     int unsignedp;\n {\n-  rtx addr, op0, op1;\n-  int max_offset;\n-  int mask;\n-\n-  if (GET_CODE (op) != MEM)\n-    return FALSE;\n+  int max_offset = 0;\n \n-  switch (GET_MODE (op))\n+  switch (mode)\n     {\n-    default:\n-      return FALSE;\n-\n     case QImode:\n-\t  max_offset = (1 << 7);\n-      mask = 0;\n+      max_offset = (1 << 7);\n       break;\n \n     case HImode:\n-\t  max_offset = (1 << 8);\n-      mask = 1;\n+      max_offset = (1 << 8);\n       break;\n \n     case SImode:\n     case SFmode:\n       max_offset = (1 << 8);\n-      mask = 3;\n       break;\n     }\n \n+  return max_offset;\n+}\n+\n+/* Return true if OP is a valid short EP memory reference */\n+\n+int\n+ep_memory_operand (op, mode, unsigned_load)\n+     rtx op;\n+     enum machine_mode mode;\n+     int unsigned_load;\n+{\n+  rtx addr, op0, op1;\n+  int max_offset;\n+  int mask;\n+\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n+\n+  max_offset = ep_memory_offset (mode, unsigned_load);\n+\n+  mask = GET_MODE_SIZE (mode) - 1;\n+\n   addr = XEXP (op, 0);\n   if (GET_CODE (addr) == CONST)\n     addr = XEXP (addr, 0);\n@@ -905,23 +897,8 @@ reg_or_0_operand (op, mode)\n   else if (GET_CODE (op) == CONST_DOUBLE)\n     return CONST_DOUBLE_OK_FOR_G (op);\n \n-  else if (GET_CODE (op) == REG)\n-    return TRUE;\n-\n-  else if (GET_CODE (op) == SUBREG)\n-    {\n-      do {\n-\top = SUBREG_REG (op);\n-      } while (GET_CODE (op) == SUBREG);\n-\n-      if (GET_CODE (op) == MEM && !reload_completed)\n-\treturn TRUE;\n-\n-      else if (GET_CODE (op) == REG)\n-\treturn TRUE;\n-    }\n-\n-  return FALSE;\n+  else\n+    return register_operand (op, mode);\n }\n \n /* Return true if OP is either a register or a signed five bit integer */\n@@ -934,23 +911,8 @@ reg_or_int5_operand (op, mode)\n   if (GET_CODE (op) == CONST_INT)\n     return CONST_OK_FOR_J (INTVAL (op));\n \n-  else if (GET_CODE (op) == REG)\n-    return TRUE;\n-\n-  else if (GET_CODE (op) == SUBREG)\n-    {\n-      do {\n-\top = SUBREG_REG (op);\n-      } while (GET_CODE (op) == SUBREG);\n-\n-      if (GET_CODE (op) == MEM && !reload_completed)\n-\treturn TRUE;\n-\n-      else if (GET_CODE (op) == REG)\n-\treturn TRUE;\n-    }\n-\n-  return FALSE;\n+  else\n+    return register_operand (op, mode);\n }\n \n /* Return true if OP is a valid call operand.  */\n@@ -1083,6 +1045,8 @@ substitute_ep_register (first_insn, last_insn, uses, regno, p_r1, p_ep)\n \t  if (pattern)\n \t    {\n \t      rtx *p_mem;\n+\t      /* Memory operands are signed by default.  */\n+\t      int unsignedp = FALSE;\n \n \t      if (GET_CODE (SET_DEST (pattern)) == MEM\n \t\t  && GET_CODE (SET_SRC (pattern)) == MEM)\n@@ -1108,9 +1072,9 @@ substitute_ep_register (first_insn, last_insn, uses, regno, p_r1, p_ep)\n \t\t\t   && GET_CODE (XEXP (addr, 0)) == REG\n \t\t\t   && REGNO (XEXP (addr, 0)) == regno\n \t\t\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT\n-\t\t\t   && ((unsigned)INTVAL (XEXP (addr, 1))) < 256\n-\t\t\t   && (GET_MODE (*p_mem) != QImode\n-\t\t\t       || ((unsigned)INTVAL (XEXP (addr, 1))) < 128))\n+\t\t\t   && (((unsigned)INTVAL (XEXP (addr, 1)))\n+\t\t\t       < ep_memory_offset (GET_MODE (*p_mem),\n+\t\t\t\t\t\t   unsignedp)))\n \t\t    *p_mem = change_address (*p_mem, VOIDmode,\n \t\t\t\t\t     gen_rtx (PLUS, Pmode,\n \t\t\t\t\t\t      *p_ep, XEXP (addr, 1)));\n@@ -1216,6 +1180,8 @@ void v850_reorg (start_insn)\n \t      rtx src = SET_SRC (pattern);\n \t      rtx dest = SET_DEST (pattern);\n \t      rtx mem;\n+\t      /* Memory operands are signed by default.  */\n+\t      int unsignedp = FALSE;\n \n \t      if (GET_CODE (dest) == MEM && GET_CODE (src) == MEM)\n \t\tmem = NULL_RTX;\n@@ -1229,7 +1195,7 @@ void v850_reorg (start_insn)\n \t      else\n \t\tmem = NULL_RTX;\n \n-\t      if (mem && ep_memory_operand (mem, GET_MODE (mem), FALSE))\n+\t      if (mem && ep_memory_operand (mem, GET_MODE (mem), unsignedp))\n \t\tuse_ep = TRUE;\n \n \t      else if (!use_ep && mem\n@@ -1248,9 +1214,8 @@ void v850_reorg (start_insn)\n \t\t  else if (GET_CODE (addr) == PLUS\n \t\t\t   && GET_CODE (XEXP (addr, 0)) == REG\n \t\t\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT\n-\t\t\t   && ((unsigned)INTVAL (XEXP (addr, 1))) < 256\n-\t\t\t   && (GET_MODE (mem) != QImode\n-\t\t\t       || ((unsigned)INTVAL (XEXP (addr, 1))) < 128))\n+\t\t\t   && (((unsigned)INTVAL (XEXP (addr, 1)))\n+\t\t\t       < ep_memory_offset (GET_MODE (mem), unsignedp)))\n \t\t    {\n \t\t      short_p = TRUE;\n \t\t      regno = REGNO (XEXP (addr, 0));"}, {"sha": "00e6fd1da519e99f79390698d81dded5bc7c6378", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ec7e4e4c4212af3b340918039f8f28a3319b/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ec7e4e4c4212af3b340918039f8f28a3319b/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=1933ec7e4e4c4212af3b340918039f8f28a3319b", "patch": "@@ -58,6 +58,8 @@ extern int target_flags;\n #define MASK_CPU                0x00000030\n #define MASK_V850               0x00000010\n \n+#define MASK_BIG_SWITCH\t\t0x00000100\n+\n #ifndef MASK_DEFAULT\n #define MASK_DEFAULT            MASK_V850\n #endif\n@@ -97,6 +99,9 @@ extern int target_flags;\n /* Whether to call out-of-line functions to save registers or not.  */\n #define TARGET_PROLOG_FUNCTION (target_flags & MASK_PROLOG_FUNCTION)\n \n+/* Whether to emit 2 byte per entry or 4 byte per entry switch tables.  */\n+#define TARGET_BIG_SWITCH (target_flags & MASK_BIG_SWITCH)\n+\n /* General debug flag */\n #define TARGET_DEBUG (target_flags & MASK_DEBUG)\n \n@@ -119,6 +124,7 @@ extern int target_flags;\n    { \"debug\",\t\t\t MASK_DEBUG },\t\t\t\t\\\n    { \"v850\",\t\t \t MASK_V850 },\t\t\t\t\\\n    { \"v850\",\t\t \t -(MASK_V850 ^ MASK_CPU) },\t\t\\\n+   { \"big-switch\",\t\t MASK_BIG_SWITCH },\t\t\t\\\n    EXTRA_SWITCHES\t\t\t\t\t\t\t\\\n    { \"\",\t\t\t TARGET_DEFAULT}}\n \n@@ -468,19 +474,21 @@ enum reg_class {\n \n #define INT_7_BITS(VALUE) ((unsigned) (VALUE) + 0x40 < 0x80)\n #define INT_8_BITS(VALUE) ((unsigned) (VALUE) + 0x80 < 0x100)\n-/* 0 bits */\n+/* zero */\n #define CONST_OK_FOR_I(VALUE) ((VALUE) == 0)\n-/* 4 bits */\n+/* 5 bit signed immediate */\n #define CONST_OK_FOR_J(VALUE) ((unsigned) (VALUE) + 0x10 < 0x20)\n-/* 15 bits */\n+/* 16 bit signed immediate */\n #define CONST_OK_FOR_K(VALUE) ((unsigned) (VALUE) + 0x8000 < 0x10000)\n+/* valid constant for movhi instruction.  */\n #define CONST_OK_FOR_L(VALUE) \\\n   (((unsigned) ((int) (VALUE) >> 16) + 0x8000 < 0x10000) \\\n    && CONST_OK_FOR_I ((VALUE & 0xffff)))\n-/* 16 bits */\n-#define CONST_OK_FOR_M(VALUE) ((unsigned)(VALUE) < 0x10000\n+/* 16 bit unsigned immediate */\n+#define CONST_OK_FOR_M(VALUE) ((unsigned)(VALUE) < 0x10000)\n+/* 5 bit unsigned immediate in shift instructions */\n+#define CONST_OK_FOR_N(VALUE) ((unsigned) (VALUE) <= 31)\n \n-#define CONST_OK_FOR_N(VALUE) ((unsigned) VALUE >= 0 && (unsigned) VALUE <= 31) /* 5 bit signed immediate in shift instructions */\n #define CONST_OK_FOR_O(VALUE) 0\n #define CONST_OK_FOR_P(VALUE) 0\n \n@@ -799,6 +807,9 @@ extern int current_function_anonymous_args;\n \f\n /* 1 if X is an rtx for a constant that is a valid address.  */\n \n+/* ??? This seems too exclusive.  May get better code by accepting more\n+   possibilities here, in particular, should accept ZDA_NAME SYMBOL_REFs.  */\n+\n #define CONSTANT_ADDRESS_P(X)   \\\n   (GET_CODE (X) == CONST_INT\t\t\t\t\\\n    && CONST_OK_FOR_K (INTVAL (X)))\n@@ -864,7 +875,11 @@ extern int current_function_anonymous_args;\n   : (C) == 'R' ? special_symbolref_operand (OP, VOIDmode)\t\t\\\n   : (C) == 'S' ? (GET_CODE (OP) == SYMBOL_REF && ! ZDA_NAME_P (XSTR (OP, 0))) \\\n   : (C) == 'T' ? 0\t\t\t\t\t\t\t\\\n-  : (C) == 'U' ? 0                                                      \\\n+  : (C) == 'U' ? ((GET_CODE (OP) == SYMBOL_REF && ZDA_NAME_P (XSTR (OP, 0))) \\\n+\t\t  || (GET_CODE (OP) == CONST\t\t\t\t\\\n+\t\t      && GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n+\t\t      && GET_CODE (XEXP (XEXP (OP, 0), 0)) == SYMBOL_REF \\\n+\t\t      && ZDA_NAME_P (XSTR (XEXP (XEXP (OP, 0), 0), 0)))) \\\n   : 0)\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -1266,12 +1281,15 @@ do { char dstr[30];\t\t\t\t\t\\\n /* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n-  asm_fprintf (FILE, \"\\t%s .L%d\\n\", \".long\", VALUE)\n+  asm_fprintf (FILE, \"\\t%s .L%d\\n\",\t\t\t\t\t\\\n+\t       (TARGET_BIG_SWITCH ? \".long\" : \".short\"), VALUE)\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n-  fprintf (FILE, \"\\t%s .L%d-.L%d\\n\", \".long\", VALUE, REL)\n+  fprintf (FILE, \"\\t%s .L%d-.L%d\\n\",\t\t\t\t\t\\\n+\t   (TARGET_BIG_SWITCH ? \".long\" : \".short\"),\t\t\t\\\n+\t   VALUE, REL)\n \n #define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n   if ((LOG) != 0)\t\t\t\\\n@@ -1292,12 +1310,26 @@ do { char dstr[30];\t\t\t\t\t\\\n \n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE Pmode\n+#define CASE_VECTOR_MODE (TARGET_BIG_SWITCH ? SImode : HImode)\n \n /* Define this if the case instruction drops through after the table\n    when the index is out of range.  Don't define it if the case insn\n    jumps to the default label instead.  */\n-#define CASE_DROPS_THROUGH\n+/* #define CASE_DROPS_THROUGH */\n+\n+/* We must use a PC relative entry for small tables.  It would be more\n+   efficient to use an absolute entry for big tables, but this is not\n+   a runtime choice yet.  */\n+#define CASE_VECTOR_PC_RELATIVE\n+\n+/* The switch instruction requires that the jump table immediately follow\n+   it. */\n+#define JUMP_TABLES_IN_TEXT_SECTION\n+\n+/* svr4.h defines this assuming that 4 byte alignment is required.  */\n+#undef ASM_OUTPUT_BEFORE_CASE_LABEL\n+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \\\n+  ASM_OUTPUT_ALIGN ((FILE), (TARGET_BIG_SWITCH ? 2 : 1));\n \n #define WORD_REGISTER_OPERATIONS\n "}, {"sha": "c2095f2c294e12702ac45cf54008247bdaa4c9a2", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 83, "deletions": 14, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ec7e4e4c4212af3b340918039f8f28a3319b/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ec7e4e4c4212af3b340918039f8f28a3319b/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=1933ec7e4e4c4212af3b340918039f8f28a3319b", "patch": "@@ -263,6 +263,22 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n \n+;; This replaces ld.b;sar;andi with tst1;setf nz.\n+\n+;; ??? The zero_extract sets the Z bit to the opposite of what one would\n+;; expect.  This perhaps should be wrapped in a (eq: X (const_int 0)).\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  [(set (cc0) (zero_extract:SI (match_dup 1)\n+\t\t\t       (const_int 1)\n+\t\t\t       (match_dup 2)))\n+   (set (match_dup 0) (ne:SI (cc0) (const_int 0)))])\n+\n (define_insn \"tstsi\"\n   [(set (cc0) (match_operand:SI 0 \"register_operand\" \"r\"))]\n   \"\"\n@@ -272,8 +288,8 @@\n \n (define_insn \"cmpsi\"\n   [(set (cc0)\n-\t(compare:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n-\t\t    (match_operand:SI 1 \"reg_or_int5_operand\" \"r,J\")))]\n+\t(compare (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t (match_operand:SI 1 \"reg_or_int5_operand\" \"r,J\")))]\n   \"\"\n   \"@\n   cmp %1,%0\n@@ -286,16 +302,16 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,&r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,r,r\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rJ,K,r\")))]\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rJ,K,U\")))]\n   \"\"\n   \"@\n    add %2,%0\n    addi %2,%1,%0\n-   mov %1,%0\\;add %2,%0\"\n-  [(set_attr \"length\" \"2,4,6\")\n-   (set_attr \"cc\" \"set_zn\")])\n+   addi %O2(%P2),%1,%0\"\n+  [(set_attr \"length\" \"2,4,4\")\n+   (set_attr \"cc\" \"set_zn,set_zn,set_zn\")])\n \n ;; ----------------------------------------------------------------------\n ;; SUBTRACT INSTRUCTIONS\n@@ -592,7 +608,16 @@\n ;; -----------------------------------------------------------------\n ;; BIT FIELDS\n ;; -----------------------------------------------------------------\n-;; Is it worth defining insv and extv for the V850 series?!?\n+\n+;; ??? Is it worth defining insv and extv for the V850 series?!?\n+\n+;; An insv pattern would be useful, but does not get used because\n+;; store_bit_field never calls insv when storing a constant value into a\n+;; single-bit bitfield.\n+\n+;; extv/extzv patterns would be useful, but do not get used because\n+;; optimize_bitfield_compare in fold-const usually converts single\n+;; bit extracts into an AND with a mask.\n \n ;; -----------------------------------------------------------------\n ;; Scc INSTRUCTIONS\n@@ -816,9 +841,9 @@\n     return 0;\n \n   if (get_attr_length (insn) == 2)\n-    return \\\"%b1 %l0\\\";\n+    return \\\"b%b1 %l0\\\";\n   else\n-    return \\\"%B1 .+6\\;jr %l0\\\";\n+    return \\\"b%B1 .+6\\;jr %l0\\\";\n }\"\n  [(set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n@@ -843,9 +868,9 @@\n \t  || GET_CODE (operands[1]) == LT))\n     return 0;\n   if (get_attr_length (insn) == 2)\n-    return \\\"%B1 %l0\\\";\n+    return \\\"b%B1 %l0\\\";\n   else\n-    return \\\"%b1 .+6\\;jr %l0\\\";\n+    return \\\"b%b1 .+6\\;jr %l0\\\";\n }\"\n  [(set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n@@ -889,6 +914,50 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"none\")])\n \n+(define_expand \"casesi\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:SI 1 \"register_operand\" \"\")\n+   (match_operand:SI 2 \"register_operand\" \"\")\n+   (match_operand 3 \"\" \"\") (match_operand 4 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx reg = gen_reg_rtx (SImode);\n+  rtx tableaddress = gen_reg_rtx (SImode);\n+  rtx mem;\n+\n+  /* Subtract the lower bound from the index.  */\n+  emit_insn (gen_subsi3 (reg, operands[0], operands[1]));\n+  /* Compare the result against the number of table entries.  */\n+  emit_insn (gen_cmpsi (reg, operands[2]));\n+  /* Branch to the default label if out of range of the table.  */\n+  emit_jump_insn (gen_bgtu (operands[4]));\n+\n+  /* Shift index for the table array access.  */\n+  emit_insn (gen_ashlsi3 (reg, reg, GEN_INT (TARGET_BIG_SWITCH ? 2 : 1)));\n+  /* Load the table address into a psuedo.  */\n+  emit_insn (gen_movsi (tableaddress,\n+\t\t\tgen_rtx (LABEL_REF, VOIDmode, operands[3])));\n+  /* Add the table address to the index.  */\n+  emit_insn (gen_addsi3 (reg, reg, tableaddress));\n+  /* Load the table entry.  */\n+  mem = gen_rtx (MEM, CASE_VECTOR_MODE, reg);\n+  RTX_UNCHANGING_P (mem);\n+  if (! TARGET_BIG_SWITCH)\n+    {\n+      rtx reg2 = gen_reg_rtx (HImode);\n+      emit_insn (gen_movhi (reg2, mem));\n+      emit_insn (gen_extendhisi2 (reg, reg2));\n+    }\n+  else\n+    emit_insn (gen_movsi (reg, mem));\n+  /* Add the table address.  */\n+  emit_insn (gen_addsi3 (reg, reg, tableaddress));\n+  /* Branch to the switch label.  */\n+  emit_jump_insn (gen_tablejump (reg, operands[3]));\n+  DONE;\n+}\")\n+\n ;; Call subroutine with no return value.\n \n (define_expand \"call\"\n@@ -1021,7 +1090,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(ashift:SI\n \t (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"r,N\")))]\n+\t (match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))]\n   \"\"\n   \"@\n   shl %2,%0\n@@ -1033,7 +1102,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(lshiftrt:SI\n \t (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"r,J\")))]\n+\t (match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))]\n   \"\"\n   \"@\n   shr %2,%0"}]}