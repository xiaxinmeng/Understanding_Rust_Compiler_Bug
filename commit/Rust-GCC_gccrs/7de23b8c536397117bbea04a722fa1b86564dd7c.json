{"sha": "7de23b8c536397117bbea04a722fa1b86564dd7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RlMjNiOGM1MzYzOTcxMTdiYmVhMDRhNzIyZmExYjg2NTY0ZGQ3Yw==", "commit": {"author": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2020-10-30T09:21:31Z"}, "committer": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2020-10-30T09:21:31Z"}, "message": "aarch64: Fix PR96998 and restore code quality in combine\n\nThis change fixes a bug in the AArch64 backend. Currently, we accept an\nodd sign_extract representation of addresses, but don't accept that same\nodd form of address as an LEA.\n\nThis is the cause of PR96998. In the testcase given in the PR, combine\nproduces:\n\n(insn 9 8 10 3 (set (mem:SI (plus:DI (sign_extract:DI (mult:DI (subreg:DI (reg/v:SI 92 [ g ]) 0)\n                        (const_int 4 [0x4]))\n                    (const_int 34 [0x22])\n                    (const_int 0 [0]))\n                (reg/f:DI 96)) [3 *i_5+0 S4 A32])\n        (asm_operands:SI (\"\") (\"=Q\") 0 []\n             []\n             [] test.c:11)) \"test.c\":11:5 -1\n     (expr_list:REG_DEAD (reg/v:SI 92 [ g ])\n        (nil)))\n\nThen LRA reloads the address and we ICE because we fail to recognize the\nsign_extract outside the mem:\n\n(insn 33 8 34 3 (set (reg:DI 100)\n        (sign_extract:DI (ashift:DI (subreg:DI (reg/v:SI 92 [ g ]) 0)\n                (const_int 2 [0x2]))\n            (const_int 34 [0x22])\n            (const_int 0 [0]))) \"test.c\":11:5 -1\n     (nil))\n\nThe aarch64 changes here remove the support for this sign_extract\nrepresentation of addresses, fixing PR96998. Now this by itself would\nregress code quality, so this change is paired with an improvement to\ncombine which prevents an extract rtx from being emitted in this case:\nwe now write the rtx above as a shift of an extend, which allows the\ncombination to go ahead.\n\nPrior to this, combine.c:make_extraction() identified where we can emit\nan ashift of an extend in place of an extraction, but failed to make the\ncorresponding canonicalization/simplification when presented with a mult\nby a power of two. Such a representation is canonical when representing\na left-shifted address inside a mem.\n\nThis change remedies this situation. For rtxes such as:\n\n(mult:DI (subreg:DI (reg:SI r) 0) (const_int 2^n))\n\nwhere the bottom 32 + n bits are valid (the higher-order bits are\nundefined) and make_extraction() is being asked to sign_extract the\nlower (valid) bits, after the patch, we rewrite this as:\n\n(mult:DI (sign_extend:DI (reg:SI r)) (const_int 2^n))\n\ninstead of using a sign_extract.\n\ngcc/ChangeLog:\n\n\tPR target/96998\n\t* combine.c (make_extraction): Also handle shifts written as\n\t(mult x 2^n), avoid creating an extract rtx for these.\n\t* config/aarch64/aarch64.c (aarch64_is_extend_from_extract): Delete.\n\t(aarch64_classify_index): Remove extract-based address handling.\n\t(aarch64_strip_extend): Likewise.\n\t(aarch64_rtx_arith_op_extract_p): Likewise, remove now-unused parameter.\n\tUpdate callers...\n\t(aarch64_rtx_costs): ... here.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/96998\n\t* gcc.c-torture/compile/pr96998.c: New test.", "tree": {"sha": "482047823141481f576088ffc9a8b477768bcb6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/482047823141481f576088ffc9a8b477768bcb6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7de23b8c536397117bbea04a722fa1b86564dd7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7de23b8c536397117bbea04a722fa1b86564dd7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7de23b8c536397117bbea04a722fa1b86564dd7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7de23b8c536397117bbea04a722fa1b86564dd7c/comments", "author": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17e8da49bfe6a91d13d30888cb9cea0ee255b945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e8da49bfe6a91d13d30888cb9cea0ee255b945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17e8da49bfe6a91d13d30888cb9cea0ee255b945"}], "stats": {"total": 140, "additions": 42, "deletions": 98}, "files": [{"sha": "ed1ad45de838436d580a8efe11c7e56f17fe9557", "filename": "gcc/combine.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de23b8c536397117bbea04a722fa1b86564dd7c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de23b8c536397117bbea04a722fa1b86564dd7c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=7de23b8c536397117bbea04a722fa1b86564dd7c", "patch": "@@ -7665,6 +7665,24 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n       if (new_rtx != 0)\n \treturn gen_rtx_ASHIFT (mode, new_rtx, XEXP (inner, 1));\n     }\n+  else if (GET_CODE (inner) == MULT\n+\t   && CONST_INT_P (XEXP (inner, 1))\n+\t   && pos_rtx == 0 && pos == 0)\n+    {\n+      /* We're extracting the least significant bits of an rtx\n+\t (mult X (const_int 2^C)), where LEN > C.  Extract the\n+\t least significant (LEN - C) bits of X, giving an rtx\n+\t whose mode is MODE, then multiply it by 2^C.  */\n+      const HOST_WIDE_INT shift_amt = exact_log2 (INTVAL (XEXP (inner, 1)));\n+      if (IN_RANGE (shift_amt, 1, len - 1))\n+\t{\n+\t  new_rtx = make_extraction (mode, XEXP (inner, 0),\n+\t\t\t\t     0, 0, len - shift_amt,\n+\t\t\t\t     unsignedp, in_dest, in_compare);\n+\t  if (new_rtx)\n+\t    return gen_rtx_MULT (mode, new_rtx, XEXP (inner, 1));\n+\t}\n+    }\n   else if (GET_CODE (inner) == TRUNCATE\n \t   /* If trying or potentionally trying to extract\n \t      bits outside of is_mode, don't look through"}, {"sha": "db991e59cbe8c8847f53b86a5b9cf41c799b5ce7", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 9, "deletions": 98, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de23b8c536397117bbea04a722fa1b86564dd7c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de23b8c536397117bbea04a722fa1b86564dd7c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=7de23b8c536397117bbea04a722fa1b86564dd7c", "patch": "@@ -2886,33 +2886,6 @@ aarch64_is_noplt_call_p (rtx sym)\n   return false;\n }\n \n-/* Return true if the offsets to a zero/sign-extract operation\n-   represent an expression that matches an extend operation.  The\n-   operands represent the parameters from\n-\n-   (extract:MODE (mult (reg) (MULT_IMM)) (EXTRACT_IMM) (const_int 0)).  */\n-bool\n-aarch64_is_extend_from_extract (scalar_int_mode mode, rtx mult_imm,\n-\t\t\t\trtx extract_imm)\n-{\n-  HOST_WIDE_INT mult_val, extract_val;\n-\n-  if (! CONST_INT_P (mult_imm) || ! CONST_INT_P (extract_imm))\n-    return false;\n-\n-  mult_val = INTVAL (mult_imm);\n-  extract_val = INTVAL (extract_imm);\n-\n-  if (extract_val > 8\n-      && extract_val < GET_MODE_BITSIZE (mode)\n-      && exact_log2 (extract_val & ~7) > 0\n-      && (extract_val & 7) <= 4\n-      && mult_val == (1 << (extract_val & 7)))\n-    return true;\n-\n-  return false;\n-}\n-\n /* Emit an insn that's a simple single-set.  Both the operands must be\n    known to be valid.  */\n inline static rtx_insn *\n@@ -8936,22 +8909,6 @@ aarch64_classify_index (struct aarch64_address_info *info, rtx x,\n       index = XEXP (XEXP (x, 0), 0);\n       shift = INTVAL (XEXP (x, 1));\n     }\n-  /* (sign_extract:DI (mult:DI (reg:DI) (const_int scale)) 32+shift 0) */\n-  else if ((GET_CODE (x) == SIGN_EXTRACT\n-\t    || GET_CODE (x) == ZERO_EXTRACT)\n-\t   && GET_MODE (x) == DImode\n-\t   && GET_CODE (XEXP (x, 0)) == MULT\n-\t   && GET_MODE (XEXP (XEXP (x, 0), 0)) == DImode\n-\t   && CONST_INT_P (XEXP (XEXP (x, 0), 1)))\n-    {\n-      type = (GET_CODE (x) == SIGN_EXTRACT)\n-\t? ADDRESS_REG_SXTW : ADDRESS_REG_UXTW;\n-      index = XEXP (XEXP (x, 0), 0);\n-      shift = exact_log2 (INTVAL (XEXP (XEXP (x, 0), 1)));\n-      if (INTVAL (XEXP (x, 1)) != 32 + shift\n-\t  || INTVAL (XEXP (x, 2)) != 0)\n-\tshift = -1;\n-    }\n   /* (and:DI (mult:DI (reg:DI) (const_int scale))\n      (const_int 0xffffffff<<shift)) */\n   else if (GET_CODE (x) == AND\n@@ -8967,22 +8924,6 @@ aarch64_classify_index (struct aarch64_address_info *info, rtx x,\n       if (INTVAL (XEXP (x, 1)) != (HOST_WIDE_INT)0xffffffff << shift)\n \tshift = -1;\n     }\n-  /* (sign_extract:DI (ashift:DI (reg:DI) (const_int shift)) 32+shift 0) */\n-  else if ((GET_CODE (x) == SIGN_EXTRACT\n-\t    || GET_CODE (x) == ZERO_EXTRACT)\n-\t   && GET_MODE (x) == DImode\n-\t   && GET_CODE (XEXP (x, 0)) == ASHIFT\n-\t   && GET_MODE (XEXP (XEXP (x, 0), 0)) == DImode\n-\t   && CONST_INT_P (XEXP (XEXP (x, 0), 1)))\n-    {\n-      type = (GET_CODE (x) == SIGN_EXTRACT)\n-\t? ADDRESS_REG_SXTW : ADDRESS_REG_UXTW;\n-      index = XEXP (XEXP (x, 0), 0);\n-      shift = INTVAL (XEXP (XEXP (x, 0), 1));\n-      if (INTVAL (XEXP (x, 1)) != 32 + shift\n-\t  || INTVAL (XEXP (x, 2)) != 0)\n-\tshift = -1;\n-    }\n   /* (and:DI (ashift:DI (reg:DI) (const_int shift))\n      (const_int 0xffffffff<<shift)) */\n   else if (GET_CODE (x) == AND\n@@ -11360,16 +11301,6 @@ aarch64_strip_extend (rtx x, bool strip_shift)\n   if (!is_a <scalar_int_mode> (GET_MODE (op), &mode))\n     return op;\n \n-  /* Zero and sign extraction of a widened value.  */\n-  if ((GET_CODE (op) == ZERO_EXTRACT || GET_CODE (op) == SIGN_EXTRACT)\n-      && XEXP (op, 2) == const0_rtx\n-      && GET_CODE (XEXP (op, 0)) == MULT\n-      && aarch64_is_extend_from_extract (mode, XEXP (XEXP (op, 0), 1),\n-\t\t\t\t\t XEXP (op, 1)))\n-    return XEXP (XEXP (op, 0), 0);\n-\n-  /* It can also be represented (for zero-extend) as an AND with an\n-     immediate.  */\n   if (GET_CODE (op) == AND\n       && GET_CODE (XEXP (op, 0)) == MULT\n       && CONST_INT_P (XEXP (XEXP (op, 0), 1))\n@@ -11704,35 +11635,15 @@ aarch64_branch_cost (bool speed_p, bool predictable_p)\n     return branch_costs->unpredictable;\n }\n \n-/* Return true if the RTX X in mode MODE is a zero or sign extract\n+/* Return true if X is a zero or sign extract\n    usable in an ADD or SUB (extended register) instruction.  */\n static bool\n-aarch64_rtx_arith_op_extract_p (rtx x, scalar_int_mode mode)\n-{\n-  /* Catch add with a sign extract.\n-     This is add_<optab><mode>_multp2.  */\n-  if (GET_CODE (x) == SIGN_EXTRACT\n-      || GET_CODE (x) == ZERO_EXTRACT)\n-    {\n-      rtx op0 = XEXP (x, 0);\n-      rtx op1 = XEXP (x, 1);\n-      rtx op2 = XEXP (x, 2);\n-\n-      if (GET_CODE (op0) == MULT\n-\t  && CONST_INT_P (op1)\n-\t  && op2 == const0_rtx\n-\t  && CONST_INT_P (XEXP (op0, 1))\n-\t  && aarch64_is_extend_from_extract (mode,\n-\t\t\t\t\t     XEXP (op0, 1),\n-\t\t\t\t\t     op1))\n-\t{\n-\t  return true;\n-\t}\n-    }\n+aarch64_rtx_arith_op_extract_p (rtx x)\n+{\n   /* The simple case <ARITH>, XD, XN, XM, [us]xt.\n      No shift.  */\n-  else if (GET_CODE (x) == SIGN_EXTEND\n-\t   || GET_CODE (x) == ZERO_EXTEND)\n+  if (GET_CODE (x) == SIGN_EXTEND\n+      || GET_CODE (x) == ZERO_EXTEND)\n     return REG_P (XEXP (x, 0));\n \n   return false;\n@@ -12419,8 +12330,8 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n \t  }\n \n \t/* Look for SUB (extended register).  */\n-\tif (is_a <scalar_int_mode> (mode, &int_mode)\n-\t    && aarch64_rtx_arith_op_extract_p (op1, int_mode))\n+\tif (is_a <scalar_int_mode> (mode)\n+\t    && aarch64_rtx_arith_op_extract_p (op1))\n \t  {\n \t    if (speed)\n \t      *cost += extra_cost->alu.extend_arith;\n@@ -12499,8 +12410,8 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n \t*cost += rtx_cost (op1, mode, PLUS, 1, speed);\n \n \t/* Look for ADD (extended register).  */\n-\tif (is_a <scalar_int_mode> (mode, &int_mode)\n-\t    && aarch64_rtx_arith_op_extract_p (op0, int_mode))\n+\tif (is_a <scalar_int_mode> (mode)\n+\t    && aarch64_rtx_arith_op_extract_p (op0))\n \t  {\n \t    if (speed)\n \t      *cost += extra_cost->alu.extend_arith;"}, {"sha": "a75d5dcfe080f1b9950f1a5760397173f7bf3a45", "filename": "gcc/testsuite/gcc.c-torture/compile/pr96998.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de23b8c536397117bbea04a722fa1b86564dd7c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr96998.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de23b8c536397117bbea04a722fa1b86564dd7c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr96998.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr96998.c?ref=7de23b8c536397117bbea04a722fa1b86564dd7c", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target arm*-*-* aarch64*-*-* } } */\n+\n+int h(void);\n+struct c d;\n+struct c {\n+  int e[1];\n+};\n+\n+void f(void) {\n+  int g;\n+  for (;; g = h()) {\n+    int *i = &d.e[g];\n+    asm(\"\" : \"=Q\"(*i));\n+  }\n+}"}]}