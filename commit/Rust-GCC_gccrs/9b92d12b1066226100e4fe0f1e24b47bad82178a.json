{"sha": "9b92d12b1066226100e4fe0f1e24b47bad82178a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI5MmQxMmIxMDY2MjI2MTAwZTRmZTBmMWUyNGI0N2JhZDgyMTc4YQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2013-05-03T18:56:39Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2013-05-03T18:56:39Z"}, "message": "gimple-ssa-strength-reduction.c (cand_kind): Add CAND_PHI.\n\ngcc:\n\n2013-05-03  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gimple-ssa-strength-reduction.c (cand_kind): Add CAND_PHI.\n\t(slsr_cand_d): Redefine def_phi.\n\t(stride_status, phi_adjust_status, count_phis_status): New enums.\n\t(find_phi_def): New.\n\t(find_basis_for_base_expr): New.\n\t(find_basis_for_candidate): Handle hidden bases.\n\t(alloc_cand_and_find_basis): Handle phi candidates.\n\t(slsr_process_phi): New.\n\t(create_mul_ssa_cand): Exclude phi base candidates; use integer_onep.\n\t(create_mul_imm_cand): Likewise.\n\t(create_add_ssa_cand): Exclude phi base candidates.\n\t(create_add_imm_cand): Likewise.\n\t(slsr_process_cast): Likewise.\n\t(slsr_process_copy): Likewise.\n\t(find_candidates_in_block): Handle phi candidates.\n\t(dump_candidate): Likewise.\n\t(unconditional_cands): Delete.\n\t(unconditional_cands_with_known_stride_p): Delete.\n\t(phi_dependent_cand_p): New.\n\t(cand_increment): Handle phi-dependent candidates.\n\t(replace_dependent): Delete.\n\t(replace_mult_candidate): New.\n\t(replace_unconditional_candidate): New.\n\t(incr_vec_index): Move to avoid forward reference.\n\t(create_add_on_incoming_edge): New.\n\t(create_phi_basis): New.\n\t(replace_dependents): Delete.\n\t(replace_conditional_candidate): New.\n\t(phi_add_costs): New.\n\t(replace_uncond_cands_and_profitable_phis): New.\n\t(record_increment): Handle phi adjustments.\n\t(record_phi_increments): New.\n\t(record_increments): Handle phi adjustments.\n\t(phi_incr_cost): New.\n\t(lowest_cost_path): Handle phis.\n\t(total_savings): Likewise.\n\t(analyze_increments): Likewise.\n\t(ncd_with_phi): New.\n\t(ncd_of_cand_and_phis): New.\n\t(nearest_common_dominator_for_cands): Handle phi increments.\n\t(all_phi_incrs_profitable): New.\n\t(replace_profitable_candidates): Handle phi-dependent candidates.\n\t(analyze_candidates_and_replace): Likewise.\n\ngcc/testsuite:\n\n2013-05-03  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gcc.dg/tree-ssa/slsr-32.c: New.\n\t* gcc.dg/tree-ssa/slsr-33.c: New.\n\t* gcc.dg/tree-ssa/slsr-34.c: New.\n\t* gcc.dg/tree-ssa/slsr-35.c: New.\n\t* gcc.dg/tree-ssa/slsr-36.c: New.\n\t* gcc.dg/tree-ssa/slsr-37.c: New.\n\t* gcc.dg/tree-ssa/slsr-38.c: New.\n\nFrom-SVN: r198586", "tree": {"sha": "216cd578306ce4a9506775df9c2d5dcfa548452c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/216cd578306ce4a9506775df9c2d5dcfa548452c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b92d12b1066226100e4fe0f1e24b47bad82178a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b92d12b1066226100e4fe0f1e24b47bad82178a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b92d12b1066226100e4fe0f1e24b47bad82178a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b92d12b1066226100e4fe0f1e24b47bad82178a/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72c8864445e3443ac8bfa2134e480e80289dce0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c8864445e3443ac8bfa2134e480e80289dce0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72c8864445e3443ac8bfa2134e480e80289dce0f"}], "stats": {"total": 1489, "additions": 1279, "deletions": 210}, "files": [{"sha": "f1d6fb4eae822f4b9bd007e2d29eba9fd2cb6e9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b92d12b1066226100e4fe0f1e24b47bad82178a", "patch": "@@ -1,3 +1,49 @@\n+2013-05-03  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gimple-ssa-strength-reduction.c (cand_kind): Add CAND_PHI.\n+\t(slsr_cand_d): Redefine def_phi.\n+\t(stride_status, phi_adjust_status, count_phis_status): New enums.\n+\t(find_phi_def): New.\n+\t(find_basis_for_base_expr): New.\n+\t(find_basis_for_candidate): Handle hidden bases.\n+\t(alloc_cand_and_find_basis): Handle phi candidates.\n+\t(slsr_process_phi): New.\n+\t(create_mul_ssa_cand): Exclude phi base candidates; use integer_onep.\n+\t(create_mul_imm_cand): Likewise.\n+\t(create_add_ssa_cand): Exclude phi base candidates.\n+\t(create_add_imm_cand): Likewise.\n+\t(slsr_process_cast): Likewise.\n+\t(slsr_process_copy): Likewise.\n+\t(find_candidates_in_block): Handle phi candidates.\n+\t(dump_candidate): Likewise.\n+\t(unconditional_cands): Delete.\n+\t(unconditional_cands_with_known_stride_p): Delete.\n+\t(phi_dependent_cand_p): New.\n+\t(cand_increment): Handle phi-dependent candidates.\n+\t(replace_dependent): Delete.\n+\t(replace_mult_candidate): New.\n+\t(replace_unconditional_candidate): New.\n+\t(incr_vec_index): Move to avoid forward reference.\n+\t(create_add_on_incoming_edge): New.\n+\t(create_phi_basis): New.\n+\t(replace_dependents): Delete.\n+\t(replace_conditional_candidate): New.\n+\t(phi_add_costs): New.\n+\t(replace_uncond_cands_and_profitable_phis): New.\n+\t(record_increment): Handle phi adjustments.\n+\t(record_phi_increments): New.\n+\t(record_increments): Handle phi adjustments.\n+\t(phi_incr_cost): New.\n+\t(lowest_cost_path): Handle phis.\n+\t(total_savings): Likewise.\n+\t(analyze_increments): Likewise.\n+\t(ncd_with_phi): New.\n+\t(ncd_of_cand_and_phis): New.\n+\t(nearest_common_dominator_for_cands): Handle phi increments.\n+\t(all_phi_incrs_profitable): New.\n+\t(replace_profitable_candidates): Handle phi-dependent candidates.\n+\t(analyze_candidates_and_replace): Likewise.\n+\n 2013-05-03  Teresa Johnson  <tejohnson@google.com>\n \n \tPR bootstrap/57154"}, {"sha": "d4a914886f4a4754559abe7b4834888a03248ab0", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 995, "deletions": 210, "changes": 1205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=9b92d12b1066226100e4fe0f1e24b47bad82178a", "patch": "@@ -24,18 +24,10 @@ along with GCC; see the file COPYING3.  If not see\n    up the crumbs it leaves behind, by considering opportunities for\n    strength reduction along dominator paths.\n \n-   Strength reduction will be implemented in four stages, gradually\n-   adding more complex candidates:\n-\n-   1) Explicit multiplies, known constant multipliers, no\n-      conditional increments. (complete)\n-   2) Explicit multiplies, unknown constant multipliers,\n-      no conditional increments. (complete)\n-   3) Implicit multiplies in addressing expressions. (complete)\n-   4) Explicit multiplies, conditional increments. (pending)\n-\n-   It would also be possible to apply strength reduction to divisions\n-   and modulos, but such opportunities are relatively uncommon.\n+   Strength reduction addresses explicit multiplies, and certain\n+   multiplies implicit in addressing expressions.  It would also be\n+   possible to apply strength reduction to divisions and modulos,\n+   but such opportunities are relatively uncommon.\n \n    Strength reduction is also currently restricted to integer operations.\n    If desired, it could be extended to floating-point operations under\n@@ -147,7 +139,69 @@ along with GCC; see the file COPYING3.  If not see\n    is thus another CAND_REF with the same B and S values.  When at \n    least two CAND_REFs are chained together using the basis relation,\n    each of them is replaced as above, resulting in improved code\n-   generation for addressing.  */\n+   generation for addressing.\n+\n+   Conditional candidates\n+   ======================\n+\n+   Conditional candidates are best illustrated with an example.\n+   Consider the code sequence:\n+\n+   (1)  x_0 = ...;\n+   (2)  a_0 = x_0 * 5;          MULT (B: x_0; i: 0; S: 5)\n+        if (...)\n+   (3)    x_1 = x_0 + 1;        ADD  (B: x_0, i: 1; S: 1)\n+   (4)  x_2 = PHI <x_0, x_1>;   PHI  (B: x_0, i: 0, S: 1)\n+   (5)  x_3 = x_2 + 1;          ADD  (B: x_2, i: 1, S: 1)\n+   (6)  a_1 = x_3 * 5;          MULT (B: x_2, i: 1; S: 5)\n+\n+   Here strength reduction is complicated by the uncertain value of x_2.\n+   A legitimate transformation is:\n+\n+   (1)  x_0 = ...;\n+   (2)  a_0 = x_0 * 5;\n+        if (...)\n+\t  {\n+   (3)      [x_1 = x_0 + 1;]\n+   (3a)     t_1 = a_0 + 5;\n+          }\n+   (4)  [x_2 = PHI <x_0, x_1>;]\n+   (4a) t_2 = PHI <a_0, t_1>;\n+   (5)  [x_3 = x_2 + 1;]\n+   (6r) a_1 = t_2 + 5;\n+\n+   where the bracketed instructions may go dead.\n+\n+   To recognize this opportunity, we have to observe that statement (6)\n+   has a \"hidden basis\" (2).  The hidden basis is unlike a normal basis\n+   in that the statement and the hidden basis have different base SSA\n+   names (x_2 and x_0, respectively).  The relationship is established\n+   when a statement's base name (x_2) is defined by a phi statement (4),\n+   each argument of which (x_0, x_1) has an identical \"derived base name.\"\n+   If the argument is defined by a candidate (as x_1 is by (3)) that is a\n+   CAND_ADD having a stride of 1, the derived base name of the argument is\n+   the base name of the candidate (x_0).  Otherwise, the argument itself\n+   is its derived base name (as is the case with argument x_0).\n+\n+   The hidden basis for statement (6) is the nearest dominating candidate\n+   whose base name is the derived base name (x_0) of the feeding phi (4), \n+   and whose stride is identical to that of the statement.  We can then\n+   create the new \"phi basis\" (4a) and feeding adds along incoming arcs (3a),\n+   allowing the final replacement of (6) by the strength-reduced (6r).\n+\n+   To facilitate this, a new kind of candidate (CAND_PHI) is introduced.\n+   A CAND_PHI is not a candidate for replacement, but is maintained in the\n+   candidate table to ease discovery of hidden bases.  Any phi statement\n+   whose arguments share a common derived base name is entered into the\n+   table with the derived base name, an (arbitrary) index of zero, and a\n+   stride of 1.  A statement with a hidden basis can then be detected by\n+   simply looking up its feeding phi definition in the candidate table,\n+   extracting the derived base name, and searching for a basis in the\n+   usual manner after substituting the derived base name.\n+\n+   Note that the transformation is only valid when the original phi and \n+   the statements that define the phi's arguments are all at the same\n+   position in the loop hierarchy.  */\n \n \n /* Index into the candidate vector, offset by 1.  VECs are zero-based,\n@@ -159,7 +213,8 @@ enum cand_kind\n {\n   CAND_MULT,\n   CAND_ADD,\n-  CAND_REF\n+  CAND_REF,\n+  CAND_PHI\n };\n \n struct slsr_cand_d\n@@ -204,9 +259,9 @@ struct slsr_cand_d\n   /* Next candidate having the same basis as this one.  */\n   cand_idx sibling;\n \n-  /* If this is a conditional candidate, the defining PHI statement\n-     for the base SSA name B.  For future use; always NULL for now.  */\n-  gimple def_phi;\n+  /* If this is a conditional candidate, the CAND_PHI candidate\n+     that defines the base SSA name B.  */\n+  cand_idx def_phi;\n \n   /* Savings that can be expected from eliminating dead code if this\n      candidate is replaced.  */\n@@ -282,6 +337,24 @@ enum cost_consts\n   COST_INFINITE = 1000\n };\n \n+enum stride_status\n+{\n+  UNKNOWN_STRIDE = 0,\n+  KNOWN_STRIDE = 1\n+};\n+\n+enum phi_adjust_status\n+{\n+  NOT_PHI_ADJUST = 0,\n+  PHI_ADJUST = 1\n+};\n+\n+enum count_phis_status\n+{\n+  DONT_COUNT_PHIS = 0,\n+  COUNT_PHIS = 1\n+};\n+ \n /* Pointer map embodying a mapping from statements to candidates.  */\n static struct pointer_map_t *stmt_cand_map;\n \n@@ -300,6 +373,10 @@ static unsigned incr_vec_len;\n /* For a chain of candidates with unknown stride, indicates whether or not\n    we must generate pointer arithmetic when replacing statements.  */\n static bool address_arithmetic_p;\n+\n+/* Forward function declarations.  */\n+static slsr_cand_t base_cand_from_table (tree);\n+static tree introduce_cast_before_cand (slsr_cand_t, tree, tree, tree*);\n \f\n /* Produce a pointer to the IDX'th candidate in the candidate vector.  */\n \n@@ -335,15 +412,31 @@ cand_chain_hasher::equal (const value_type *chain1, const compare_type *chain2)\n /* Hash table embodying a mapping from base exprs to chains of candidates.  */\n static hash_table <cand_chain_hasher> base_cand_map;\n \f\n-/* Use the base expr from candidate C to look for possible candidates\n-   that can serve as a basis for C.  Each potential basis must also\n-   appear in a block that dominates the candidate statement and have\n-   the same stride and type.  If more than one possible basis exists,\n-   the one with highest index in the vector is chosen; this will be\n-   the most immediately dominating basis.  */\n+/* Look in the candidate table for a CAND_PHI that defines BASE and\n+   return it if found; otherwise return NULL.  */\n \n-static int\n-find_basis_for_candidate (slsr_cand_t c)\n+static cand_idx\n+find_phi_def (tree base)\n+{\n+  slsr_cand_t c;\n+\n+  if (TREE_CODE (base) != SSA_NAME)\n+    return 0;\n+  \n+  c = base_cand_from_table (base);\n+\n+  if (!c || c->kind != CAND_PHI)\n+    return 0;\n+\n+  return c->cand_num;\n+}\n+\n+/* Helper routine for find_basis_for_candidate.  May be called twice:\n+   once for the candidate's base expr, and optionally again for the\n+   candidate's phi definition.  */\n+\n+static slsr_cand_t\n+find_basis_for_base_expr (slsr_cand_t c, tree base_expr)\n {\n   cand_chain mapping_key;\n   cand_chain_t chain;\n@@ -353,7 +446,7 @@ find_basis_for_candidate (slsr_cand_t c)\n   int iters = 0;\n   int max_iters = PARAM_VALUE (PARAM_MAX_SLSR_CANDIDATE_SCAN);\n \n-  mapping_key.base_expr = c->base_expr;\n+  mapping_key.base_expr = base_expr;\n   chain = base_cand_map.find (&mapping_key);\n \n   for (; chain && iters < max_iters; chain = chain->next, ++iters)\n@@ -373,6 +466,50 @@ find_basis_for_candidate (slsr_cand_t c)\n \tbasis = one_basis;\n     }\n \n+  return basis;\n+}\n+\n+/* Use the base expr from candidate C to look for possible candidates\n+   that can serve as a basis for C.  Each potential basis must also\n+   appear in a block that dominates the candidate statement and have\n+   the same stride and type.  If more than one possible basis exists,\n+   the one with highest index in the vector is chosen; this will be\n+   the most immediately dominating basis.  */\n+\n+static int\n+find_basis_for_candidate (slsr_cand_t c)\n+{\n+  slsr_cand_t basis = find_basis_for_base_expr (c, c->base_expr);\n+\n+  /* If a candidate doesn't have a basis using its base expression,\n+     it may have a basis hidden by one or more intervening phis.  */\n+  if (!basis && c->def_phi)\n+    {\n+      basic_block basis_bb, phi_bb;\n+      slsr_cand_t phi_cand = lookup_cand (c->def_phi);\n+      basis = find_basis_for_base_expr (c, phi_cand->base_expr);\n+\n+      if (basis)\n+\t{\n+\t  /* A hidden basis must dominate the phi-definition of the\n+\t     candidate's base name.  */\n+\t  phi_bb = gimple_bb (phi_cand->cand_stmt);\n+\t  basis_bb = gimple_bb (basis->cand_stmt);\n+\n+\t  if (phi_bb == basis_bb\n+\t      || !dominated_by_p (CDI_DOMINATORS, phi_bb, basis_bb))\n+\t    {\n+\t      basis = NULL;\n+\t      c->basis = 0;\n+\t    }\n+\n+\t  /* If we found a hidden basis, estimate additional dead-code\n+\t     savings if the phi and its feeding statements can be removed.  */\n+\t  if (basis && has_single_use (gimple_phi_result (phi_cand->cand_stmt)))\n+\t    c->dead_savings += phi_cand->dead_savings;\n+\t}\n+    }\n+\n   if (basis)\n     {\n       c->sibling = basis->dependent;\n@@ -428,11 +565,16 @@ alloc_cand_and_find_basis (enum cand_kind kind, gimple gs, tree base,\n   c->next_interp = 0;\n   c->dependent = 0;\n   c->sibling = 0;\n-  c->def_phi = NULL;\n+  c->def_phi = find_phi_def (base);\n   c->dead_savings = savings;\n \n   cand_vec.safe_push (c);\n-  c->basis = find_basis_for_candidate (c);\n+\n+  if (kind == CAND_PHI)\n+    c->basis = 0;\n+  else\n+    c->basis = find_basis_for_candidate (c);\n+\n   record_potential_basis (c);\n \n   return c;\n@@ -515,6 +657,97 @@ add_cand_for_stmt (gimple gs, slsr_cand_t c)\n   *slot = c;\n }\n \f\n+/* Given PHI which contains a phi statement, determine whether it\n+   satisfies all the requirements of a phi candidate.  If so, create\n+   a candidate.  Note that a CAND_PHI never has a basis itself, but\n+   is used to help find a basis for subsequent candidates.  */\n+\n+static void\n+slsr_process_phi (gimple phi, bool speed)\n+{\n+  unsigned i;\n+  tree arg0_base = NULL_TREE, base_type;\n+  slsr_cand_t c;\n+  struct loop *cand_loop = gimple_bb (phi)->loop_father;\n+  unsigned savings = 0;\n+\n+  /* A CAND_PHI requires each of its arguments to have the same\n+     derived base name.  (See the module header commentary for a\n+     definition of derived base names.)  Furthermore, all feeding\n+     definitions must be in the same position in the loop hierarchy\n+     as PHI.  */\n+\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      slsr_cand_t arg_cand;\n+      tree arg = gimple_phi_arg_def (phi, i);\n+      tree derived_base_name = NULL_TREE;\n+      gimple arg_stmt = NULL;\n+      basic_block arg_bb = NULL;\n+\n+      if (TREE_CODE (arg) != SSA_NAME)\n+\treturn;\n+\n+      arg_cand = base_cand_from_table (arg);\n+\n+      if (arg_cand)\n+\t{\n+\t  while (arg_cand->kind != CAND_ADD && arg_cand->kind != CAND_PHI)\n+\t    {\n+\t      if (!arg_cand->next_interp)\n+\t\treturn;\n+\n+\t      arg_cand = lookup_cand (arg_cand->next_interp);\n+\t    }\n+\n+\t  if (!integer_onep (arg_cand->stride))\n+\t    return;\n+\n+\t  derived_base_name = arg_cand->base_expr;\n+\t  arg_stmt = arg_cand->cand_stmt;\n+\t  arg_bb = gimple_bb (arg_stmt);\n+\n+\t  /* Gather potential dead code savings if the phi statement\n+\t     can be removed later on.  */\n+\t  if (has_single_use (arg))\n+\t    {\n+\t      if (gimple_code (arg_stmt) == GIMPLE_PHI)\n+\t\tsavings += arg_cand->dead_savings;\n+\t      else\n+\t\tsavings += stmt_cost (arg_stmt, speed);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  derived_base_name = arg;\n+\n+\t  if (SSA_NAME_IS_DEFAULT_DEF (arg))\n+\t    arg_bb = single_succ (ENTRY_BLOCK_PTR);\n+\t  else\n+\t    gimple_bb (SSA_NAME_DEF_STMT (arg));\n+\t}\n+\n+      if (!arg_bb || arg_bb->loop_father != cand_loop)\n+\treturn;\n+\n+      if (i == 0)\n+\targ0_base = derived_base_name;\n+      else if (!operand_equal_p (derived_base_name, arg0_base, 0))\n+\treturn;\n+    }\n+\n+  /* Create the candidate.  \"alloc_cand_and_find_basis\" is named\n+     misleadingly for this case, as no basis will be sought for a\n+     CAND_PHI.  */\n+  base_type = TREE_TYPE (arg0_base);\n+\n+  c = alloc_cand_and_find_basis (CAND_PHI, phi, arg0_base, double_int_zero,\n+\t\t\t\t integer_one_node, base_type, savings);\n+\n+  /* Add the candidate to the statement-candidate mapping.  */\n+  add_cand_for_stmt (phi, c);\n+}\n+\n /* Look for the following pattern:\n \n     *PBASE:    MEM_REF (T1, C1)\n@@ -652,11 +885,10 @@ create_mul_ssa_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n \n   /* Look at all interpretations of the base candidate, if necessary,\n      to find information to propagate into this candidate.  */\n-  while (base_cand && !base)\n+  while (base_cand && !base && base_cand->kind != CAND_PHI)\n     {\n \n-      if (base_cand->kind == CAND_MULT\n-\t  && operand_equal_p (base_cand->stride, integer_one_node, 0))\n+      if (base_cand->kind == CAND_MULT && integer_onep (base_cand->stride))\n \t{\n \t  /* Y = (B + i') * 1\n \t     X = Y * Z\n@@ -723,7 +955,7 @@ create_mul_imm_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n \n   /* Look at all interpretations of the base candidate, if necessary,\n      to find information to propagate into this candidate.  */\n-  while (base_cand && !base)\n+  while (base_cand && !base && base_cand->kind != CAND_PHI)\n     {\n       if (base_cand->kind == CAND_MULT\n \t  && TREE_CODE (base_cand->stride) == INTEGER_CST)\n@@ -742,8 +974,7 @@ create_mul_imm_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n \t    savings = (base_cand->dead_savings \n \t\t       + stmt_cost (base_cand->cand_stmt, speed));\n \t}\n-      else if (base_cand->kind == CAND_ADD\n-\t       && operand_equal_p (base_cand->stride, integer_one_node, 0))\n+      else if (base_cand->kind == CAND_ADD && integer_onep (base_cand->stride))\n \t{\n \t  /* Y = B + (i' * 1)\n \t     X = Y * c\n@@ -856,7 +1087,7 @@ create_add_ssa_cand (gimple gs, tree base_in, tree addend_in,\n \n   /* The most useful transformation is a multiply-immediate feeding\n      an add or subtract.  Look for that first.  */\n-  while (addend_cand && !base)\n+  while (addend_cand && !base && addend_cand->kind != CAND_PHI)\n     {\n       if (addend_cand->kind == CAND_MULT\n \t  && addend_cand->index.is_zero ()\n@@ -883,7 +1114,7 @@ create_add_ssa_cand (gimple gs, tree base_in, tree addend_in,\n \taddend_cand = NULL;\n     }\n \n-  while (base_cand && !base)\n+  while (base_cand && !base && base_cand->kind != CAND_PHI)\n     {\n       if (base_cand->kind == CAND_ADD\n \t  && (base_cand->index.is_zero ()\n@@ -906,7 +1137,7 @@ create_add_ssa_cand (gimple gs, tree base_in, tree addend_in,\n \t{\n \t  slsr_cand_t subtrahend_cand = base_cand_from_table (addend_in);\n \n-\t  while (subtrahend_cand && !base)\n+\t  while (subtrahend_cand && !base && subtrahend_cand->kind != CAND_PHI)\n \t    {\n \t      if (subtrahend_cand->kind == CAND_MULT\n \t\t  && subtrahend_cand->index.is_zero ()\n@@ -968,7 +1199,7 @@ create_add_imm_cand (gimple gs, tree base_in, double_int index_in, bool speed)\n   slsr_cand_t c;\n   slsr_cand_t base_cand = base_cand_from_table (base_in);\n \n-  while (base_cand && !base)\n+  while (base_cand && !base && base_cand->kind != CAND_PHI)\n     {\n       bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (base_cand->stride));\n \n@@ -1178,7 +1409,7 @@ slsr_process_cast (gimple gs, tree rhs1, bool speed)\n   base_cand = base_cand_from_table (rhs1);\n   ctype = TREE_TYPE (lhs);\n \n-  if (base_cand)\n+  if (base_cand && base_cand->kind != CAND_PHI)\n     {\n       while (base_cand)\n \t{\n@@ -1237,7 +1468,7 @@ slsr_process_copy (gimple gs, tree rhs1, bool speed)\n \n   base_cand = base_cand_from_table (rhs1);\n \n-  if (base_cand)\n+  if (base_cand && base_cand->kind != CAND_PHI)\n     {\n       while (base_cand)\n \t{\n@@ -1288,6 +1519,9 @@ find_candidates_in_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   bool speed = optimize_bb_for_speed_p (bb);\n   gimple_stmt_iterator gsi;\n \n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    slsr_process_phi (gsi_stmt (gsi), speed);\n+\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple gs = gsi_stmt (gsi);\n@@ -1400,6 +1634,13 @@ dump_candidate (slsr_cand_t c)\n       dump_double_int (dump_file, c->index, false);\n       fputs (\" : \", dump_file);\n       break;\n+    case CAND_PHI:\n+      fputs (\"     PHI  : \", dump_file);\n+      print_generic_expr (dump_file, c->base_expr, 0);\n+      fputs (\" + (unknown * \", dump_file);\n+      print_generic_expr (dump_file, c->stride, 0);\n+      fputs (\") : \", dump_file);\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -1409,10 +1650,7 @@ dump_candidate (slsr_cand_t c)\n   fprintf (dump_file, \"     next-interp: %d  dead-savings: %d\\n\",\n \t   c->next_interp, c->dead_savings);\n   if (c->def_phi)\n-    {\n-      fputs (\"     phi:  \", dump_file);\n-      print_gimple_stmt (dump_file, c->def_phi, 0, 0);\n-    }\n+    fprintf (dump_file, \"     phi:  %d\\n\", c->def_phi);\n   fputs (\"\\n\", dump_file);\n }\n \n@@ -1482,40 +1720,6 @@ dump_incr_vec (void)\n     }\n }\n \f\n-/* Recursive helper for unconditional_cands_with_known_stride_p.\n-   Returns TRUE iff C, its siblings, and its dependents are all\n-   unconditional candidates.  */\n-\n-static bool\n-unconditional_cands (slsr_cand_t c)\n-{\n-  if (c->def_phi)\n-    return false;\n-\n-  if (c->sibling && !unconditional_cands (lookup_cand (c->sibling)))\n-    return false;\n-\n-  if (c->dependent && !unconditional_cands (lookup_cand (c->dependent)))\n-    return false;\n-\n-  return true;\n-}\n-\n-/* Determine whether or not the tree of candidates rooted at\n-   ROOT consists entirely of unconditional increments with\n-   an INTEGER_CST stride.  */\n-\n-static bool\n-unconditional_cands_with_known_stride_p (slsr_cand_t root)\n-{\n-  /* The stride is identical for all related candidates, so\n-     check it once.  */\n-  if (TREE_CODE (root->stride) != INTEGER_CST)\n-    return false;\n-\n-  return unconditional_cands (lookup_cand (root->dependent));\n-}\n-\n /* Replace *EXPR in candidate C with an equivalent strength-reduced\n    data reference.  */\n \n@@ -1563,6 +1767,20 @@ replace_refs (slsr_cand_t c)\n     replace_refs (lookup_cand (c->dependent));\n }\n \n+/* Return TRUE if candidate C is dependent upon a PHI.  */\n+\n+static bool\n+phi_dependent_cand_p (slsr_cand_t c)\n+{\n+  /* A candidate is not necessarily dependent upon a PHI just because\n+     it has a phi definition for its base name.  It may have a basis\n+     that relies upon the same phi definition, in which case the PHI\n+     is irrelevant to this candidate.  */\n+  return (c->def_phi\n+\t  && c->basis\n+\t  && lookup_cand (c->basis)->def_phi != c->def_phi);\n+}\n+\n /* Calculate the increment required for candidate C relative to \n    its basis.  */\n \n@@ -1573,8 +1791,10 @@ cand_increment (slsr_cand_t c)\n \n   /* If the candidate doesn't have a basis, just return its own\n      index.  This is useful in record_increments to help us find\n-     an existing initializer.  */\n-  if (!c->basis)\n+     an existing initializer.  Also, if the candidate's basis is\n+     hidden by a phi, then its own index will be the increment\n+     from the newly introduced phi basis.  */\n+  if (!c->basis || phi_dependent_cand_p (c))\n     return c->index;\n \n   basis = lookup_cand (c->basis);\n@@ -1617,142 +1837,431 @@ cand_already_replaced (slsr_cand_t c)\n   return (gimple_bb (c->cand_stmt) == 0);\n }\n \n-/* Helper routine for replace_dependents, doing the work for a \n-   single candidate C.  */\n+/* Common logic used by replace_unconditional_candidate and\n+   replace_conditional_candidate.  */\n \n static void\n-replace_dependent (slsr_cand_t c, enum tree_code cand_code)\n+replace_mult_candidate (slsr_cand_t c, tree basis_name, double_int bump,\n+\t\t\ttree *var)\n {\n-  double_int stride = tree_to_double_int (c->stride);\n-  double_int bump = cand_increment (c) * stride;\n-  gimple stmt_to_print = NULL;\n-  slsr_cand_t basis;\n-  tree basis_name, incr_type, bump_tree;\n-  enum tree_code code;\n-  \n+  tree target_type = TREE_TYPE (gimple_assign_lhs (c->cand_stmt));\n+  enum tree_code cand_code = gimple_assign_rhs_code (c->cand_stmt);\n+\n   /* It is highly unlikely, but possible, that the resulting\n      bump doesn't fit in a HWI.  Abandon the replacement\n-     in this case.  Restriction to signed HWI is conservative\n-     for unsigned types but allows for safe negation without\n-     twisted logic.  */\n-  if (!bump.fits_shwi ())\n+     in this case.  This does not affect siblings or dependents\n+     of C.  Restriction to signed HWI is conservative for unsigned\n+     types but allows for safe negation without twisted logic.  */\n+  if (bump.fits_shwi ()\n+      && bump.to_shwi () != HOST_WIDE_INT_MIN\n+      /* It is not useful to replace casts, copies, or adds of\n+\t an SSA name and a constant.  */\n+      && cand_code != MODIFY_EXPR\n+      && cand_code != NOP_EXPR\n+      && cand_code != PLUS_EXPR\n+      && cand_code != POINTER_PLUS_EXPR\n+      && cand_code != MINUS_EXPR)\n+    {\n+      enum tree_code code = PLUS_EXPR;\n+      tree bump_tree;\n+      gimple stmt_to_print = NULL;\n+\n+      /* If the basis name and the candidate's LHS have incompatible\n+\t types, introduce a cast.  */\n+      if (!useless_type_conversion_p (target_type, TREE_TYPE (basis_name)))\n+\tbasis_name = introduce_cast_before_cand (c, target_type,\n+\t\t\t\t\t\t basis_name, var);\n+      if (bump.is_negative ())\n+\t{\n+\t  code = MINUS_EXPR;\n+\t  bump = -bump;\n+\t}\n+\n+      bump_tree = double_int_to_tree (target_type, bump);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fputs (\"Replacing: \", dump_file);\n+\t  print_gimple_stmt (dump_file, c->cand_stmt, 0, 0);\n+\t}\n+\n+      if (bump.is_zero ())\n+\t{\n+\t  tree lhs = gimple_assign_lhs (c->cand_stmt);\n+\t  gimple copy_stmt = gimple_build_assign (lhs, basis_name);\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n+\t  gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));\n+\t  gsi_replace (&gsi, copy_stmt, false);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    stmt_to_print = copy_stmt;\n+\t}\n+      else\n+\t{\n+\t  tree rhs1, rhs2;\n+\t  if (cand_code != NEGATE_EXPR) {\n+\t    rhs1 = gimple_assign_rhs1 (c->cand_stmt);\n+\t    rhs2 = gimple_assign_rhs2 (c->cand_stmt);\n+\t  }\n+\t  if (cand_code != NEGATE_EXPR\n+\t      && ((operand_equal_p (rhs1, basis_name, 0)\n+\t\t   && operand_equal_p (rhs2, bump_tree, 0))\n+\t\t  || (operand_equal_p (rhs1, bump_tree, 0)\n+\t\t      && operand_equal_p (rhs2, basis_name, 0))))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fputs (\"(duplicate, not actually replacing)\", dump_file);\n+\t\t  stmt_to_print = c->cand_stmt;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n+\t      gimple_assign_set_rhs_with_ops (&gsi, code,\n+\t\t\t\t\t      basis_name, bump_tree);\n+\t      update_stmt (gsi_stmt (gsi));\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tstmt_to_print = gsi_stmt (gsi);\n+\t    }\n+\t}\n+  \n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fputs (\"With: \", dump_file);\n+\t  print_gimple_stmt (dump_file, stmt_to_print, 0, 0);\n+\t  fputs (\"\\n\", dump_file);\n+  \t}\n+    }\n+}\n+\n+/* Replace candidate C with an add or subtract.   Note that we only\n+   operate on CAND_MULTs with known strides, so we will never generate\n+   a POINTER_PLUS_EXPR.  Each candidate X = (B + i) * S is replaced by\n+   X = Y + ((i - i') * S), as described in the module commentary.  The\n+   folded value ((i - i') * S) is referred to here as the \"bump.\"  */\n+\n+static void\n+replace_unconditional_candidate (slsr_cand_t c)\n+{\n+  slsr_cand_t basis;\n+  double_int stride, bump;\n+  tree var = NULL;\n+\n+  if (cand_already_replaced (c))\n     return;\n \n   basis = lookup_cand (c->basis);\n-  basis_name = gimple_assign_lhs (basis->cand_stmt);\n-  if (cand_code == POINTER_PLUS_EXPR)\n+  stride = tree_to_double_int (c->stride);\n+  bump = cand_increment (c) * stride;\n+\n+  replace_mult_candidate (c, gimple_assign_lhs (basis->cand_stmt), bump, &var);\n+}\n+\f\n+/* Return the index in the increment vector of the given INCREMENT.  */\n+\n+static inline unsigned\n+incr_vec_index (double_int increment)\n+{\n+  unsigned i;\n+  \n+  for (i = 0; i < incr_vec_len && increment != incr_vec[i].incr; i++)\n+    ;\n+\n+  gcc_assert (i < incr_vec_len);\n+  return i;\n+}\n+\n+/* Create a new statement along edge E to add BASIS_NAME to the product\n+   of INCREMENT and the stride of candidate C.  Create and return a new\n+   SSA name from *VAR to be used as the LHS of the new statement.\n+   KNOWN_STRIDE is true iff C's stride is a constant.  */\n+\n+static tree\n+create_add_on_incoming_edge (slsr_cand_t c, tree basis_name,\n+\t\t\t     double_int increment, edge e, location_t loc,\n+\t\t\t     bool known_stride)\n+{\n+  basic_block insert_bb;\n+  gimple_stmt_iterator gsi;\n+  tree lhs, basis_type;\n+  gimple new_stmt;\n+\n+  /* If the add candidate along this incoming edge has the same\n+     index as C's hidden basis, the hidden basis represents this\n+     edge correctly.  */\n+  if (increment.is_zero ())\n+    return basis_name;\n+\n+  basis_type = TREE_TYPE (basis_name);\n+  lhs = make_temp_ssa_name (basis_type, NULL, \"slsr\");\n+\n+  if (known_stride)\n     {\n-      incr_type = sizetype;\n-      code = cand_code;\n+      tree bump_tree;\n+      enum tree_code code = PLUS_EXPR;\n+      double_int bump = increment * tree_to_double_int (c->stride);\n+      if (bump.is_negative ())\n+\t{\n+\t  code = MINUS_EXPR;\n+\t  bump = -bump;\n+\t}\n+\n+      bump_tree = double_int_to_tree (basis_type, bump);\n+      new_stmt = gimple_build_assign_with_ops (code, lhs, basis_name,\n+\t\t\t\t\t       bump_tree);\n     }\n   else\n     {\n-      incr_type = TREE_TYPE (gimple_assign_rhs1 (c->cand_stmt));\n-      code = PLUS_EXPR;\n-    }\n+      unsigned i;\n+      bool negate_incr = (!address_arithmetic_p && increment.is_negative ());\n+      i = incr_vec_index (negate_incr ? -increment : increment);\n \n-  if (bump.is_negative ()\n-      && cand_code != POINTER_PLUS_EXPR)\n-    {\n-      code = MINUS_EXPR;\n-      bump = -bump;\n+      if (incr_vec[i].initializer)\n+\t{\n+\t  enum tree_code code = negate_incr ? MINUS_EXPR : PLUS_EXPR;\n+\t  new_stmt = gimple_build_assign_with_ops (code, lhs, basis_name,\n+\t\t\t\t\t\t   incr_vec[i].initializer);\n+\t}\n+      else if (increment.is_one ())\n+\tnew_stmt = gimple_build_assign_with_ops (PLUS_EXPR, lhs, basis_name,\n+\t\t\t\t\t\t c->stride);\n+      else if (increment.is_minus_one ())\n+\tnew_stmt = gimple_build_assign_with_ops (MINUS_EXPR, lhs, basis_name,\n+\t\t\t\t\t\t c->stride);\n+      else\n+\tgcc_unreachable ();\n     }\n \n-  bump_tree = double_int_to_tree (incr_type, bump);\n+  insert_bb = single_succ_p (e->src) ? e->src : split_edge (e);\n+  gsi = gsi_last_bb (insert_bb);\n+\n+  if (!gsi_end_p (gsi) && is_ctrl_stmt (gsi_stmt (gsi)))\n+    gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);\n+  else\n+    gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n+\n+  gimple_set_location (new_stmt, loc);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fputs (\"Replacing: \", dump_file);\n-      print_gimple_stmt (dump_file, c->cand_stmt, 0, 0);\n+      fprintf (dump_file, \"Inserting in block %d: \", insert_bb->index);\n+      print_gimple_stmt (dump_file, new_stmt, 0, 0);\n     }\n \n-  if (bump.is_zero ())\n-    {\n-      tree lhs = gimple_assign_lhs (c->cand_stmt);\n-      gimple copy_stmt = gimple_build_assign (lhs, basis_name);\n-      gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n-      gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));\n-      gsi_replace (&gsi, copy_stmt, false);\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tstmt_to_print = copy_stmt;\n-    }\n-  else\n+  return lhs;\n+}\n+\n+/* Given a candidate C with BASIS_NAME being the LHS of C's basis which\n+   is hidden by the phi node FROM_PHI, create a new phi node in the same\n+   block as FROM_PHI.  The new phi is suitable for use as a basis by C,\n+   with its phi arguments representing conditional adjustments to the\n+   hidden basis along conditional incoming paths.  Those adjustments are\n+   made by creating add statements (and sometimes recursively creating\n+   phis) along those incoming paths.  LOC is the location to attach to\n+   the introduced statements.  KNOWN_STRIDE is true iff C's stride is a\n+   constant.  */\n+\n+static tree\n+create_phi_basis (slsr_cand_t c, gimple from_phi, tree basis_name,\n+\t\t  location_t loc, bool known_stride)\n+{\n+  int i;\n+  tree name, phi_arg;\n+  gimple phi;\n+  vec<tree> phi_args;\n+  slsr_cand_t basis = lookup_cand (c->basis);\n+  int nargs = gimple_phi_num_args (from_phi);\n+  basic_block phi_bb = gimple_bb (from_phi);\n+  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (from_phi));\n+  phi_args.create (nargs);\n+\n+  /* Process each argument of the existing phi that represents\n+     conditionally-executed add candidates.  */\n+  for (i = 0; i < nargs; i++)\n     {\n-      tree rhs1 = gimple_assign_rhs1 (c->cand_stmt);\n-      tree rhs2 = gimple_assign_rhs2 (c->cand_stmt);\n-      if (cand_code != NEGATE_EXPR\n-\t  && ((operand_equal_p (rhs1, basis_name, 0)\n-\t       && operand_equal_p (rhs2, bump_tree, 0))\n-\t      || (operand_equal_p (rhs1, bump_tree, 0)\n-\t\t  && operand_equal_p (rhs2, basis_name, 0))))\n+      edge e = (*phi_bb->preds)[i];\n+      tree arg = gimple_phi_arg_def (from_phi, i);\n+      tree feeding_def;\n+\n+      /* If the phi argument is the base name of the CAND_PHI, then\n+\t this incoming arc should use the hidden basis.  */\n+      if (operand_equal_p (arg, phi_cand->base_expr, 0))\n+\tif (basis->index.is_zero ())\n+\t  feeding_def = gimple_assign_lhs (basis->cand_stmt);\n+\telse\n+\t  {\n+\t    double_int incr = c->index - basis->index;\n+\t    feeding_def = create_add_on_incoming_edge (c, basis_name, incr,\n+\t\t\t\t\t\t       e, loc, known_stride);\n+\t  }\n+      else\n \t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+\n+\t  /* If there is another phi along this incoming edge, we must\n+\t     process it in the same fashion to ensure that all basis\n+\t     adjustments are made along its incoming edges.  */\n+\t  if (gimple_code (arg_def) == GIMPLE_PHI)\n+\t    feeding_def = create_phi_basis (c, arg_def, basis_name,\n+\t\t\t\t\t    loc, known_stride);\n+\t  else\n \t    {\n-\t      fputs (\"(duplicate, not actually replacing)\", dump_file);\n-\t      stmt_to_print = c->cand_stmt;\n+\t      slsr_cand_t arg_cand = base_cand_from_table (arg);\n+\t      double_int diff = arg_cand->index - basis->index;\n+\t      feeding_def = create_add_on_incoming_edge (c, basis_name, diff,\n+\t\t\t\t\t\t\t e, loc, known_stride);\n \t    }\n \t}\n-      else\n-\t{\n-\t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n-\t  gimple_assign_set_rhs_with_ops (&gsi, code, basis_name, bump_tree);\n-\t  update_stmt (gsi_stmt (gsi));\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    stmt_to_print = gsi_stmt (gsi);\n-\t}\n+\n+      /* Because of recursion, we need to save the arguments in a vector\n+\t so we can create the PHI statement all at once.  Otherwise the\n+\t storage for the half-created PHI can be reclaimed.  */\n+      phi_args.safe_push (feeding_def);\n     }\n-  \n+\n+  /* Create the new phi basis.  */\n+  name = make_temp_ssa_name (TREE_TYPE (basis_name), NULL, \"slsr\");\n+  phi = create_phi_node (name, phi_bb);\n+  SSA_NAME_DEF_STMT (name) = phi;\n+\n+  FOR_EACH_VEC_ELT (phi_args, i, phi_arg)\n+    {\n+      edge e = (*phi_bb->preds)[i];\n+      add_phi_arg (phi, phi_arg, e, loc);\n+    }\n+\n+  update_stmt (phi);\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fputs (\"With: \", dump_file);\n-      print_gimple_stmt (dump_file, stmt_to_print, 0, 0);\n-      fputs (\"\\n\", dump_file);\n+      fputs (\"Introducing new phi basis: \", dump_file);\n+      print_gimple_stmt (dump_file, phi, 0, 0);\n     }\n+\n+  return name;\n }\n \n-/* Replace candidate C, each sibling of candidate C, and each\n-   dependent of candidate C with an add or subtract.  Note that we\n-   only operate on CAND_MULTs with known strides, so we will never\n-   generate a POINTER_PLUS_EXPR.  Each candidate X = (B + i) * S is\n-   replaced by X = Y + ((i - i') * S), as described in the module\n-   commentary.  The folded value ((i - i') * S) is referred to here\n-   as the \"bump.\"  */\n+/* Given a candidate C whose basis is hidden by at least one intervening\n+   phi, introduce a matching number of new phis to represent its basis\n+   adjusted by conditional increments along possible incoming paths.  Then\n+   replace C as though it were an unconditional candidate, using the new\n+   basis.  */\n \n static void\n-replace_dependents (slsr_cand_t c)\n+replace_conditional_candidate (slsr_cand_t c)\n {\n-  enum tree_code cand_code = gimple_assign_rhs_code (c->cand_stmt);\n+  tree basis_name, name, var = NULL;\n+  slsr_cand_t basis;\n+  location_t loc;\n+  double_int stride, bump;\n \n-  /* It is not useful to replace casts, copies, or adds of an SSA name\n-     and a constant.  Also skip candidates that have already been\n-     replaced under another interpretation.  */\n-  if (cand_code != MODIFY_EXPR\n-      && cand_code != NOP_EXPR\n-      && c->kind == CAND_MULT\n-      && !cand_already_replaced (c))\n-    replace_dependent (c, cand_code);\n+  /* Look up the LHS SSA name from C's basis.  This will be the \n+     RHS1 of the adds we will introduce to create new phi arguments.  */\n+  basis = lookup_cand (c->basis);\n+  basis_name = gimple_assign_lhs (basis->cand_stmt);\n \n-  if (c->sibling)\n-    replace_dependents (lookup_cand (c->sibling));\n+  /* Create a new phi statement which will represent C's true basis\n+     after the transformation is complete.  */\n+  loc = gimple_location (c->cand_stmt);\n+  name = create_phi_basis (c, lookup_cand (c->def_phi)->cand_stmt,\n+\t\t\t   basis_name, loc, KNOWN_STRIDE);\n+  /* Replace C with an add of the new basis phi and a constant.  */\n+  stride = tree_to_double_int (c->stride);\n+  bump = c->index * stride;\n \n-  if (c->dependent)\n-    replace_dependents (lookup_cand (c->dependent));\n+  replace_mult_candidate (c, name, bump, &var);\n }\n-\f\n-/* Return the index in the increment vector of the given INCREMENT.  */\n \n-static inline unsigned\n-incr_vec_index (double_int increment)\n+/* Compute the expected costs of inserting basis adjustments for\n+   candidate C with phi-definition PHI.  The cost of inserting \n+   one adjustment is given by ONE_ADD_COST.  If PHI has arguments\n+   which are themselves phi results, recursively calculate costs\n+   for those phis as well.  */\n+\n+static int\n+phi_add_costs (gimple phi, slsr_cand_t c, int one_add_cost)\n {\n   unsigned i;\n-  \n-  for (i = 0; i < incr_vec_len && increment != incr_vec[i].incr; i++)\n-    ;\n+  int cost = 0;\n+  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));\n \n-  gcc_assert (i < incr_vec_len);\n-  return i;\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, i);\n+\n+      if (arg != phi_cand->base_expr)\n+\t{\n+\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+\n+\t  if (gimple_code (arg_def) == GIMPLE_PHI)\n+\t    cost += phi_add_costs (arg_def, c, one_add_cost);\n+\t  else\n+\t    {\n+\t      slsr_cand_t arg_cand = base_cand_from_table (arg);\n+\n+\t      if (arg_cand->index != c->index)\n+\t\tcost += one_add_cost;\n+\t    }\n+\t}\n+    }\n+\n+  return cost;\n }\n \n+/* For candidate C, each sibling of candidate C, and each dependent of\n+   candidate C, determine whether the candidate is dependent upon a \n+   phi that hides its basis.  If not, replace the candidate unconditionally.\n+   Otherwise, determine whether the cost of introducing compensation code\n+   for the candidate is offset by the gains from strength reduction.  If\n+   so, replace the candidate and introduce the compensation code.  */\n+\n+static void\n+replace_uncond_cands_and_profitable_phis (slsr_cand_t c)\n+{\n+  if (phi_dependent_cand_p (c))\n+    {\n+      if (c->kind == CAND_MULT)\n+\t{\n+\t  /* A candidate dependent upon a phi will replace a multiply by \n+\t     a constant with an add, and will insert at most one add for\n+\t     each phi argument.  Add these costs with the potential dead-code\n+\t     savings to determine profitability.  */\n+\t  bool speed = optimize_bb_for_speed_p (gimple_bb (c->cand_stmt));\n+\t  int mult_savings = stmt_cost (c->cand_stmt, speed);\n+\t  gimple phi = lookup_cand (c->def_phi)->cand_stmt;\n+\t  tree phi_result = gimple_phi_result (phi);\n+\t  int one_add_cost = add_cost (speed, \n+\t\t\t\t       TYPE_MODE (TREE_TYPE (phi_result)));\n+\t  int add_costs = one_add_cost + phi_add_costs (phi, c, one_add_cost);\n+\t  int cost = add_costs - mult_savings - c->dead_savings;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"  Conditional candidate %d:\\n\", c->cand_num);\n+\t      fprintf (dump_file, \"    add_costs = %d\\n\", add_costs);\n+\t      fprintf (dump_file, \"    mult_savings = %d\\n\", mult_savings);\n+\t      fprintf (dump_file, \"    dead_savings = %d\\n\", c->dead_savings);\n+\t      fprintf (dump_file, \"    cost = %d\\n\", cost);\n+\t      if (cost <= COST_NEUTRAL)\n+\t\tfputs (\"  Replacing...\\n\", dump_file);\n+\t      else\n+\t\tfputs (\"  Not replaced.\\n\", dump_file);\n+\t    }\n+\n+\t  if (cost <= COST_NEUTRAL)\n+\t    replace_conditional_candidate (c);\n+\t}\n+    }\n+  else\n+    replace_unconditional_candidate (c);\n+\n+  if (c->sibling)\n+    replace_uncond_cands_and_profitable_phis (lookup_cand (c->sibling));\n+\n+  if (c->dependent)\n+    replace_uncond_cands_and_profitable_phis (lookup_cand (c->dependent));\n+}\n+\f\n /* Count the number of candidates in the tree rooted at C that have\n    not already been replaced under other interpretations.  */\n \n@@ -1771,12 +2280,14 @@ count_candidates (slsr_cand_t c)\n }\n \n /* Increase the count of INCREMENT by one in the increment vector.\n-   INCREMENT is associated with candidate C.  If an initializer\n+   INCREMENT is associated with candidate C.  If INCREMENT is to be\n+   conditionally executed as part of a conditional candidate replacement,\n+   IS_PHI_ADJUST is true, otherwise false.  If an initializer\n    T_0 = stride * I is provided by a candidate that dominates all\n    candidates with the same increment, also record T_0 for subsequent use.  */\n \n static void\n-record_increment (slsr_cand_t c, double_int increment)\n+record_increment (slsr_cand_t c, double_int increment, bool is_phi_adjust)\n {\n   bool found = false;\n   unsigned i;\n@@ -1816,14 +2327,16 @@ record_increment (slsr_cand_t c, double_int increment)\n \t the count to zero.  We're only processing it so it can possibly\n \t provide an initializer for other candidates.  */\n       incr_vec[incr_vec_len].incr = increment;\n-      incr_vec[incr_vec_len].count = c->basis ? 1 : 0;\n+      incr_vec[incr_vec_len].count = c->basis || is_phi_adjust ? 1 : 0;\n       incr_vec[incr_vec_len].cost = COST_INFINITE;\n       \n       /* Optimistically record the first occurrence of this increment\n \t as providing an initializer (if it does); we will revise this\n \t opinion later if it doesn't dominate all other occurrences.\n-         Exception:  increments of -1, 0, 1 never need initializers.  */\n+         Exception:  increments of -1, 0, 1 never need initializers;\n+\t and phi adjustments don't ever provide initializers.  */\n       if (c->kind == CAND_ADD\n+\t  && !is_phi_adjust\n \t  && c->index == increment\n \t  && (increment.sgt (double_int_one)\n \t      || increment.slt (double_int_minus_one))\n@@ -1859,6 +2372,38 @@ record_increment (slsr_cand_t c, double_int increment)\n     }\n }\n \n+/* Given phi statement PHI that hides a candidate from its BASIS, find\n+   the increments along each incoming arc (recursively handling additional\n+   phis that may be present) and record them.  These increments are the\n+   difference in index between the index-adjusting statements and the\n+   index of the basis.  */\n+\n+static void\n+record_phi_increments (slsr_cand_t basis, gimple phi)\n+{\n+  unsigned i;\n+  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));\n+  \n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, i);\n+\n+      if (!operand_equal_p (arg, phi_cand->base_expr, 0))\n+\t{\n+\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+\n+\t  if (gimple_code (arg_def) == GIMPLE_PHI)\n+\t    record_phi_increments (basis, arg_def);\n+\t  else\n+\t    {\n+\t      slsr_cand_t arg_cand = base_cand_from_table (arg);\n+\t      double_int diff = arg_cand->index - basis->index;\n+\t      record_increment (arg_cand, diff, PHI_ADJUST);\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Determine how many times each unique increment occurs in the set\n    of candidates rooted at C's parent, recording the data in the\n    increment vector.  For each unique increment I, if an initializer\n@@ -1870,7 +2415,24 @@ static void\n record_increments (slsr_cand_t c)\n {\n   if (!cand_already_replaced (c))\n-    record_increment (c, cand_increment (c));\n+    {\n+      if (!phi_dependent_cand_p (c))\n+\trecord_increment (c, cand_increment (c), NOT_PHI_ADJUST);\n+      else\n+\t{\n+\t  /* A candidate with a basis hidden by a phi will have one\n+\t     increment for its relationship to the index represented by\n+\t     the phi, and potentially additional increments along each\n+\t     incoming edge.  For the root of the dependency tree (which\n+\t     has no basis), process just the initial index in case it has\n+\t     an initializer that can be used by subsequent candidates.  */\n+\t  record_increment (c, c->index, NOT_PHI_ADJUST);\n+\n+\t  if (c->basis)\n+\t    record_phi_increments (lookup_cand (c->basis),\n+\t\t\t\t   lookup_cand (c->def_phi)->cand_stmt);\n+\t}\n+    }\n \n   if (c->sibling)\n     record_increments (lookup_cand (c->sibling));\n@@ -1879,6 +2441,55 @@ record_increments (slsr_cand_t c)\n     record_increments (lookup_cand (c->dependent));\n }\n \n+/* Add up and return the costs of introducing add statements that\n+   require the increment INCR on behalf of candidate C and phi\n+   statement PHI.  Accumulate into *SAVINGS the potential savings\n+   from removing existing statements that feed PHI and have no other\n+   uses.  */\n+\n+static int\n+phi_incr_cost (slsr_cand_t c, double_int incr, gimple phi, int *savings)\n+{\n+  unsigned i;\n+  int cost = 0;\n+  slsr_cand_t basis = lookup_cand (c->basis);\n+  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));\n+\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, i);\n+\n+      if (!operand_equal_p (arg, phi_cand->base_expr, 0))\n+\t{\n+\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+      \n+\t  if (gimple_code (arg_def) == GIMPLE_PHI)\n+\t    {\n+\t      int feeding_savings = 0;\n+\t      cost += phi_incr_cost (c, incr, arg_def, &feeding_savings);\n+\t      if (has_single_use (gimple_phi_result (arg_def)))\n+\t\t*savings += feeding_savings;\n+\t    }\n+\t  else\n+\t    {\n+\t      slsr_cand_t arg_cand = base_cand_from_table (arg);\n+\t      double_int diff = arg_cand->index - basis->index;\n+\n+\t      if (incr == diff)\n+\t\t{\n+\t\t  tree basis_lhs = gimple_assign_lhs (basis->cand_stmt);\n+\t\t  tree lhs = gimple_assign_lhs (arg_cand->cand_stmt);\n+\t\t  cost += add_cost (true, TYPE_MODE (TREE_TYPE (basis_lhs)));\n+\t\t  if (has_single_use (lhs))\n+\t\t    *savings += stmt_cost (arg_cand->cand_stmt, true);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return cost;\n+}\n+\n /* Return the first candidate in the tree rooted at C that has not\n    already been replaced, favoring siblings over dependents.  */\n \n@@ -1922,12 +2533,14 @@ optimize_cands_for_speed_p (slsr_cand_t c)\n    candidate C or any of its siblings, counting only candidates along\n    such paths with increment INCR.  Assume that replacing a candidate\n    reduces cost by REPL_SAVINGS.  Also account for savings from any\n-   statements that would go dead.  */\n+   statements that would go dead.  If COUNT_PHIS is true, include\n+   costs of introducing feeding statements for conditional candidates.  */\n \n static int\n-lowest_cost_path (int cost_in, int repl_savings, slsr_cand_t c, double_int incr)\n+lowest_cost_path (int cost_in, int repl_savings, slsr_cand_t c,\n+\t\t  double_int incr, bool count_phis)\n {\n-  int local_cost, sib_cost;\n+  int local_cost, sib_cost, savings = 0;\n   double_int cand_incr = cand_abs_increment (c);\n \n   if (cand_already_replaced (c))\n@@ -1937,14 +2550,27 @@ lowest_cost_path (int cost_in, int repl_savings, slsr_cand_t c, double_int incr)\n   else\n     local_cost = cost_in - c->dead_savings;\n \n+  if (count_phis\n+      && phi_dependent_cand_p (c)\n+      && !cand_already_replaced (c))\n+    {\n+      gimple phi = lookup_cand (c->def_phi)->cand_stmt;\n+      local_cost += phi_incr_cost (c, incr, phi, &savings);\n+\n+      if (has_single_use (gimple_phi_result (phi)))\n+\tlocal_cost -= savings;\n+    }\n+\n   if (c->dependent)\n     local_cost = lowest_cost_path (local_cost, repl_savings, \n-\t\t\t\t   lookup_cand (c->dependent), incr);\n+\t\t\t\t   lookup_cand (c->dependent), incr,\n+\t\t\t\t   count_phis);\n \n   if (c->sibling)\n     {\n       sib_cost = lowest_cost_path (cost_in, repl_savings,\n-\t\t\t\t   lookup_cand (c->sibling), incr);\n+\t\t\t\t   lookup_cand (c->sibling), incr,\n+\t\t\t\t   count_phis);\n       local_cost = MIN (local_cost, sib_cost);\n     }\n \n@@ -1958,19 +2584,34 @@ lowest_cost_path (int cost_in, int repl_savings, slsr_cand_t c, double_int incr)\n    would go dead.  */\n \n static int\n-total_savings (int repl_savings, slsr_cand_t c, double_int incr)\n+total_savings (int repl_savings, slsr_cand_t c, double_int incr,\n+\t       bool count_phis)\n {\n   int savings = 0;\n   double_int cand_incr = cand_abs_increment (c);\n \n   if (incr == cand_incr && !cand_already_replaced (c))\n     savings += repl_savings + c->dead_savings;\n \n+  if (count_phis\n+      && phi_dependent_cand_p (c)\n+      && !cand_already_replaced (c))\n+    {\n+      int phi_savings = 0;\n+      gimple phi = lookup_cand (c->def_phi)->cand_stmt;\n+      savings -= phi_incr_cost (c, incr, phi, &phi_savings);\n+\n+      if (has_single_use (gimple_phi_result (phi)))\n+\tsavings += phi_savings;\n+    }\n+\n   if (c->dependent)\n-    savings += total_savings (repl_savings, lookup_cand (c->dependent), incr);\n+    savings += total_savings (repl_savings, lookup_cand (c->dependent), incr,\n+\t\t\t      count_phis);\n \n   if (c->sibling)\n-    savings += total_savings (repl_savings, lookup_cand (c->sibling), incr);\n+    savings += total_savings (repl_savings, lookup_cand (c->sibling), incr,\n+\t\t\t      count_phis);\n \n   return savings;\n }\n@@ -2062,9 +2703,10 @@ analyze_increments (slsr_cand_t first_dep, enum machine_mode mode, bool speed)\n \t  int repl_savings = mul_cost (speed, mode) - add_cost (speed, mode);\n \t  if (speed)\n \t    cost = lowest_cost_path (cost, repl_savings, first_dep,\n-\t\t\t\t     incr_vec[i].incr);\n+\t\t\t\t     incr_vec[i].incr, COUNT_PHIS);\n \t  else\n-\t    cost -= total_savings (repl_savings, first_dep, incr_vec[i].incr);\n+\t    cost -= total_savings (repl_savings, first_dep, incr_vec[i].incr,\n+\t\t\t\t   COUNT_PHIS);\n \n \t  incr_vec[i].cost = cost;\n \t}\n@@ -2081,9 +2723,11 @@ analyze_increments (slsr_cand_t first_dep, enum machine_mode mode, bool speed)\n \t    cost = mult_by_coeff_cost (incr, mode, speed);\n \n \t  if (speed)\n-\t    cost = lowest_cost_path (cost, 0, first_dep, incr_vec[i].incr);\n+\t    cost = lowest_cost_path (cost, 0, first_dep, incr_vec[i].incr,\n+\t\t\t\t     DONT_COUNT_PHIS);\n \t  else\n-\t    cost -= total_savings (0, first_dep, incr_vec[i].incr);\n+\t    cost -= total_savings (0, first_dep, incr_vec[i].incr,\n+\t\t\t\t   DONT_COUNT_PHIS);\n \n \t  incr_vec[i].cost = cost;\n \t}\n@@ -2141,6 +2785,69 @@ ncd_for_two_cands (basic_block bb1, basic_block bb2,\n   return ncd;\n }\n \n+/* Consider all candidates that feed PHI.  Find the nearest common\n+   dominator of those candidates requiring the given increment INCR.\n+   Further find and return the nearest common dominator of this result\n+   with block NCD.  If the returned block contains one or more of the\n+   candidates, return the earliest candidate in the block in *WHERE.  */\n+\n+static basic_block\n+ncd_with_phi (slsr_cand_t c, double_int incr, gimple phi,\n+\t      basic_block ncd, slsr_cand_t *where)\n+{\n+  unsigned i;\n+  slsr_cand_t basis = lookup_cand (c->basis);\n+  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));\n+\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, i);\n+\n+      if (!operand_equal_p (arg, phi_cand->base_expr, 0))\n+\t{\n+\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+\n+\t  if (gimple_code (arg_def) == GIMPLE_PHI)\n+\t    ncd = ncd_with_phi (c, incr, arg_def, ncd, where);\n+\t  else \n+\t    {\n+\t      slsr_cand_t arg_cand = base_cand_from_table (arg);\n+\t      double_int diff = arg_cand->index - basis->index;\n+\n+\t      if ((incr == diff) || (!address_arithmetic_p && incr == -diff))\n+\t\tncd = ncd_for_two_cands (ncd, gimple_bb (arg_cand->cand_stmt),\n+\t\t\t\t\t *where, arg_cand, where);\n+\t    }\n+\t}\n+    }\n+\n+  return ncd;\n+}\n+\n+/* Consider the candidate C together with any candidates that feed\n+   C's phi dependence (if any).  Find and return the nearest common\n+   dominator of those candidates requiring the given increment INCR.\n+   If the returned block contains one or more of the candidates,\n+   return the earliest candidate in the block in *WHERE.  */\n+\n+static basic_block\n+ncd_of_cand_and_phis (slsr_cand_t c, double_int incr, slsr_cand_t *where)\n+{\n+  basic_block ncd = NULL;\n+\n+  if (cand_abs_increment (c) == incr)\n+    {\n+      ncd = gimple_bb (c->cand_stmt);\n+      *where = c;\n+    }\n+  \n+  if (phi_dependent_cand_p (c))\n+    ncd = ncd_with_phi (c, incr, lookup_cand (c->def_phi)->cand_stmt,\n+\t\t\tncd, where);\n+\n+  return ncd;\n+}\n+\n /* Consider all candidates in the tree rooted at C for which INCR\n    represents the required increment of C relative to its basis.\n    Find and return the basic block that most nearly dominates all\n@@ -2154,7 +2861,6 @@ nearest_common_dominator_for_cands (slsr_cand_t c, double_int incr,\n {\n   basic_block sib_ncd = NULL, dep_ncd = NULL, this_ncd = NULL, ncd;\n   slsr_cand_t sib_where = NULL, dep_where = NULL, this_where = NULL, new_where;\n-  double_int cand_incr;\n \n   /* First find the NCD of all siblings and dependents.  */\n   if (c->sibling)\n@@ -2183,19 +2889,18 @@ nearest_common_dominator_for_cands (slsr_cand_t c, double_int incr,\n \t\t\t     dep_where, &new_where);\n \n   /* If the candidate's increment doesn't match the one we're interested\n-     in, then the result depends only on siblings and dependents.  */\n-  cand_incr = cand_abs_increment (c);\n+     in (and nor do any increments for feeding defs of a phi-dependence),\n+     then the result depends only on siblings and dependents.  */\n+  this_ncd = ncd_of_cand_and_phis (c, incr, &this_where);\n \n-  if (cand_incr != incr || cand_already_replaced (c))\n+  if (!this_ncd || cand_already_replaced (c))\n     {\n       *where = new_where;\n       return ncd;\n     }\n \n   /* Otherwise, compare this candidate with the result from all siblings\n      and dependents.  */\n-  this_where = c;\n-  this_ncd = gimple_bb (c->cand_stmt);\n   ncd = ncd_for_two_cands (ncd, this_ncd, new_where, this_where, where);\n \n   return ncd;\n@@ -2294,6 +2999,63 @@ insert_initializers (slsr_cand_t c)\n     }\n }\n \n+/* Return TRUE iff all required increments for candidates feeding PHI\n+   are profitable to replace on behalf of candidate C.  */\n+\n+static bool\n+all_phi_incrs_profitable (slsr_cand_t c, gimple phi)\n+{\n+  unsigned i;\n+  slsr_cand_t basis = lookup_cand (c->basis);\n+  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));\n+\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, i);\n+\n+      if (!operand_equal_p (arg, phi_cand->base_expr, 0))\n+\t{\n+\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+\n+\t  if (gimple_code (arg_def) == GIMPLE_PHI)\n+\t    {\n+\t      if (!all_phi_incrs_profitable (c, arg_def))\n+\t\treturn false;\n+\t    }\n+\t  else\n+\t    {\n+\t      unsigned j;\n+\t      slsr_cand_t arg_cand = base_cand_from_table (arg);\n+\t      double_int increment = arg_cand->index - basis->index;\n+\n+\t      if (!address_arithmetic_p && increment.is_negative ())\n+\t\tincrement = -increment;\n+\n+\t      j = incr_vec_index (increment);\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"  Conditional candidate %d, phi: \",\n+\t\t\t   c->cand_num);\n+\t\t  print_gimple_stmt (dump_file, phi, 0, 0);\n+\t\t  fputs (\"    increment: \", dump_file);\n+\t\t  dump_double_int (dump_file, increment, false);\n+\t\t  fprintf (dump_file, \"\\n    cost: %d\\n\", incr_vec[j].cost);\n+\t\t  if (profitable_increment_p (j))\n+\t\t    fputs (\"  Replacing...\\n\", dump_file);\n+\t\t  else\n+\t\t    fputs (\"  Not replaced.\\n\", dump_file);\n+\t\t}\n+\n+\t      if (!profitable_increment_p (j))\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+  \n /* Create a NOP_EXPR that copies FROM_EXPR into a new SSA name of\n    type TO_TYPE, and insert it in front of the statement represented\n    by candidate C.  Use *NEW_VAR to create the new SSA name.  Return\n@@ -2520,9 +3282,35 @@ replace_profitable_candidates (slsr_cand_t c)\n \t  && orig_code != MODIFY_EXPR\n \t  && orig_code != NOP_EXPR)\n \t{\n-\t  slsr_cand_t basis = lookup_cand (c->basis);\n-\t  tree basis_name = gimple_assign_lhs (basis->cand_stmt);\n-\t  replace_one_candidate (c, i, &new_var, basis_name);\n+\t  if (phi_dependent_cand_p (c))\n+\t    {\n+\t      gimple phi = lookup_cand (c->def_phi)->cand_stmt;\n+\n+\t      if (all_phi_incrs_profitable (c, phi))\n+\t\t{\n+\t\t  /* Look up the LHS SSA name from C's basis.  This will be \n+\t\t     the RHS1 of the adds we will introduce to create new\n+\t\t     phi arguments.  */\n+\t\t  slsr_cand_t basis = lookup_cand (c->basis);\n+\t\t  tree basis_name = gimple_assign_lhs (basis->cand_stmt);\n+\n+\t\t  /* Create a new phi statement that will represent C's true\n+\t\t     basis after the transformation is complete.  */\n+\t\t  location_t loc = gimple_location (c->cand_stmt);\n+\t\t  tree name = create_phi_basis (c, phi, basis_name,\n+\t\t\t\t\t\tloc, UNKNOWN_STRIDE);\n+\n+\t\t  /* Replace C with an add of the new basis phi and the\n+\t\t     increment.  */\n+\t\t  replace_one_candidate (c, i, &new_var, name);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      slsr_cand_t basis = lookup_cand (c->basis);\n+\t      tree basis_name = gimple_assign_lhs (basis->cand_stmt);\n+\t      replace_one_candidate (c, i, &new_var, basis_name);\n+\t    }\n \t}\n     }\n \n@@ -2564,14 +3352,15 @@ analyze_candidates_and_replace (void)\n       if (c->kind == CAND_REF)\n \treplace_refs (c);\n \n-      /* If the common stride of all related candidates is a\n-\t known constant, and none of these has a phi-dependence,\n-\t then all replacements are considered profitable.\n-\t Each replaces a multiply by a single add, with the\n-\t possibility that a feeding add also goes dead as a\n-\t result.  */\n-      else if (unconditional_cands_with_known_stride_p (c))\n-\treplace_dependents (first_dep);\n+      /* If the common stride of all related candidates is a known\n+\t constant, each candidate without a phi-dependence can be\n+\t profitably replaced.  Each replaces a multiply by a single\n+\t add, with the possibility that a feeding add also goes dead.\n+\t A candidate with a phi-dependence is replaced only if the\n+\t compensation code it requires is offset by the strength\n+\t reduction savings.  */\n+      else if (TREE_CODE (c->stride) == INTEGER_CST)\n+\treplace_uncond_cands_and_profitable_phis (first_dep);\n \n       /* When the stride is an SSA name, it may still be profitable\n \t to replace some or all of the dependent candidates, depending\n@@ -2613,10 +3402,6 @@ analyze_candidates_and_replace (void)\n \t  replace_profitable_candidates (first_dep);\n \t  free (incr_vec);\n \t}\n-\n-      /* TODO:  When conditional increments occur so that a \n-\t candidate is dependent upon a phi-basis, the cost of\n-\t introducing a temporary must be accounted for.  */\n     }\n }\n "}, {"sha": "8688db37b6154918934831bc7c281fdc377d92ce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9b92d12b1066226100e4fe0f1e24b47bad82178a", "patch": "@@ -1,3 +1,13 @@\n+2013-05-03  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gcc.dg/tree-ssa/slsr-32.c: New.\n+\t* gcc.dg/tree-ssa/slsr-33.c: New.\n+\t* gcc.dg/tree-ssa/slsr-34.c: New.\n+\t* gcc.dg/tree-ssa/slsr-35.c: New.\n+\t* gcc.dg/tree-ssa/slsr-36.c: New.\n+\t* gcc.dg/tree-ssa/slsr-37.c: New.\n+\t* gcc.dg/tree-ssa/slsr-38.c: New.\n+\n 2013-05-03  Ian Bolton  <ian.bolton@arm.com>\n \n \t* gcc.target/aarch64/tst_1.c: New test."}, {"sha": "73e67974338760eee26e52dbf04d2ac1bb1a3a0a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-32.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-32.c?ref=9b92d12b1066226100e4fe0f1e24b47bad82178a", "patch": "@@ -0,0 +1,32 @@\n+/* Verify straight-line strength reduction for a candidate with a basis\n+   hidden by a phi dependence and having an unknown stride.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int s, int c, int i)\n+{\n+  int a1, a2, a3, x1, x2, x3, x;\n+\n+  a1 = i * s;\n+  x1 = c + a1;\n+\n+  i = i + 2;\n+  a2 = i * s;\n+  x2 = c + a2;\n+\n+  if (x2 > 6)\n+    i = i + 2;\n+\n+  i = i + 2;\n+  a3 = i * s;\n+  x3 = c + a3;\n+\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* s\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* 2\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "5cd4276577b89be5b001c64972f65192e4dba2fa", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-33.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-33.c?ref=9b92d12b1066226100e4fe0f1e24b47bad82178a", "patch": "@@ -0,0 +1,31 @@\n+/* Verify straight-line strength reduction for a candidate with a basis\n+   hidden by a phi dependence and having a known stride.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int c, int i)\n+{\n+  int a1, a2, a3, x1, x2, x3, x;\n+\n+  a1 = i * 16;\n+  x1 = c + a1;\n+\n+  i = i + 2;\n+  a2 = i * 16;\n+  x2 = c + a2;\n+\n+  if (x2 > 6)\n+    i = i + 2;\n+\n+  i = i + 2;\n+  a3 = i * 16;\n+  x3 = c + a3;\n+\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "3593f869b6bc4452f996c47a9204dc6ad8a16592", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-34.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-34.c?ref=9b92d12b1066226100e4fe0f1e24b47bad82178a", "patch": "@@ -0,0 +1,43 @@\n+/* Verify straight-line strength reduction for a candidate with a basis\n+   hidden by two phi dependences, and having a known stride.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+extern void\n+g (void);\n+\n+int\n+f (int c, int i)\n+{\n+  int a1, a2, a3, x1, x2, x3, x;\n+\n+  a1 = i * 16;\n+  x1 = c + a1;\n+\n+  i = i + 2;\n+  a2 = i * 16;\n+  x2 = c + a2;\n+\n+  if (x2 > 6)\n+    {\n+      if (c < 200)\n+\ti = i + 2;\n+      else\n+\ti = i + 4;\n+      g ();\n+    }\n+  else\n+    i = i + 6;\n+\n+  i = i + 2;\n+  a3 = i * 16;\n+  x3 = c + a3;\n+\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"PHI\" 2 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "3f4d136171ae34d5efc694ea51d4714661e32375", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-35.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-35.c?ref=9b92d12b1066226100e4fe0f1e24b47bad82178a", "patch": "@@ -0,0 +1,28 @@\n+/* Verify straight-line strength reduction for a candidate with a basis\n+   hidden by a phi dependences, having a known stride, and where the \n+   phi has an argument which is a parameter.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int c, int i)\n+{\n+  int a1, a3, x1, x3, x;\n+\n+  a1 = i * 16;\n+  x1 = c + a1;\n+\n+  if (x1 > 6)\n+    i = i + 2;\n+\n+  i = i + 2;\n+  a3 = i * 16;\n+  x3 = c + a3;\n+\n+  x = x1 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "8cb09e0cf504c589e3387b8eed770a772af78f5f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-36.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-36.c?ref=9b92d12b1066226100e4fe0f1e24b47bad82178a", "patch": "@@ -0,0 +1,29 @@\n+/* Verify straight-line strength reduction for a candidate with a basis\n+   hidden by a phi dependences, having an unknown stride, and where the \n+   phi has an argument which is a parameter.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int s, int c, int i)\n+{\n+  int a1, a3, x1, x3, x;\n+\n+  a1 = i * s;\n+  x1 = c + a1;\n+\n+  if (x1 > 6)\n+    i = i + 2;\n+\n+  i = i + 2;\n+  a3 = i * s;\n+  x3 = c + a3;\n+\n+  x = x1 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* s\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* 2\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "fb13b20e142584cb1f880f390256f858bcf5c6c6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-37.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-37.c?ref=9b92d12b1066226100e4fe0f1e24b47bad82178a", "patch": "@@ -0,0 +1,33 @@\n+/* Verify straight-line strength reduction for a candidate with a basis\n+   hidden by a phi dependence and having an unknown stride.  Variation\n+   using negative increments.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int s, int c, int i)\n+{\n+  int a1, a2, a3, x1, x2, x3, x;\n+\n+  a1 = i * s;\n+  x1 = c + a1;\n+\n+  i = i - 2;\n+  a2 = i * s;\n+  x2 = c + a2;\n+\n+  if (x2 > 6)\n+    i = i - 2;\n+\n+  i = i - 2;\n+  a3 = i * s;\n+  x3 = c + a3;\n+\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* s\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* 2\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "1a0ab79bd55754965499dd8f7faecd2e47f567f9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-38.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b92d12b1066226100e4fe0f1e24b47bad82178a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-38.c?ref=9b92d12b1066226100e4fe0f1e24b47bad82178a", "patch": "@@ -0,0 +1,32 @@\n+/* Verify straight-line strength reduction for a candidate with a basis\n+   hidden by a phi dependence and having a known stride.  Variation using\n+   negative increments.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int c, int i)\n+{\n+  int a1, a2, a3, x1, x2, x3, x;\n+\n+  a1 = i * 16;\n+  x1 = c + a1;\n+\n+  i = i - 2;\n+  a2 = i * 16;\n+  x2 = c + a2;\n+\n+  if (x2 > 6)\n+    i = i - 2;\n+\n+  i = i - 2;\n+  a3 = i * 16;\n+  x3 = c + a3;\n+\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}