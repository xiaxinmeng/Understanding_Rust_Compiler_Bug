{"sha": "afdb85f9dd2a354027eabae91b461df6d08ecb5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZkYjg1ZjlkZDJhMzU0MDI3ZWFiYWU5MWI0NjFkZjZkMDhlY2I1Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-08-17T10:04:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-08-17T10:04:04Z"}, "message": "re PR fortran/81827 (Large compile time with derived-type rrays)\n\n2017-08-17  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/81827\n\t* tree-ssa-structalias.c (struct variable_info): Add is_reg_var\n\tflag.\n\t(new_var_info): Initialize it conservatively.\n\t(get_call_vi): Mark register vars.\n\t(new_scalar_tmp_constraint_exp): Likewise.\n\t(handle_rhs_call): Likewise.\n\t(handle_const_call): Likewise.\n\t(create_function_info_for): Likewise.\n\t(solve_constraints): Sort varinfos to separate register from\n\tnon-register vars to pack points-to solution bitmaps during\n\titeration.\n\nFrom-SVN: r251143", "tree": {"sha": "6d95d774c88a6821e08a3882d17c756564684b4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d95d774c88a6821e08a3882d17c756564684b4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afdb85f9dd2a354027eabae91b461df6d08ecb5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afdb85f9dd2a354027eabae91b461df6d08ecb5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afdb85f9dd2a354027eabae91b461df6d08ecb5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afdb85f9dd2a354027eabae91b461df6d08ecb5c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cca6b724cdcca931237f0d513490eebfe110927e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca6b724cdcca931237f0d513490eebfe110927e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cca6b724cdcca931237f0d513490eebfe110927e"}], "stats": {"total": 64, "additions": 63, "deletions": 1}, "files": [{"sha": "d4db491b1f28bb5a978670c928f824ce90e91288", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afdb85f9dd2a354027eabae91b461df6d08ecb5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afdb85f9dd2a354027eabae91b461df6d08ecb5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=afdb85f9dd2a354027eabae91b461df6d08ecb5c", "patch": "@@ -1,3 +1,18 @@\n+2017-08-17  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/81827\n+\t* tree-ssa-structalias.c (struct variable_info): Add is_reg_var\n+\tflag.\n+\t(new_var_info): Initialize it conservatively.\n+\t(get_call_vi): Mark register vars.\n+\t(new_scalar_tmp_constraint_exp): Likewise.\n+\t(handle_rhs_call): Likewise.\n+\t(handle_const_call): Likewise.\n+\t(create_function_info_for): Likewise.\n+\t(solve_constraints): Sort varinfos to separate register from\n+\tnon-register vars to pack points-to solution bitmaps during\n+\titeration.\n+\n 2017-08-17  Marek Polacek  <polacek@redhat.com>\n \n \t* gimplify.c (gimplify_adjust_omp_clauses): Compare with 0 instead of"}, {"sha": "c95d1e3784bcc964f46b3092188b73c7153e7bb1", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afdb85f9dd2a354027eabae91b461df6d08ecb5c/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afdb85f9dd2a354027eabae91b461df6d08ecb5c/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=afdb85f9dd2a354027eabae91b461df6d08ecb5c", "patch": "@@ -257,6 +257,9 @@ struct variable_info\n   /* True if this is a heap variable.  */\n   unsigned int is_heap_var : 1;\n \n+  /* True if this is a register variable.  */\n+  unsigned int is_reg_var : 1;\n+\n   /* True if this field may contain pointers.  */\n   unsigned int may_have_pointers : 1;\n \n@@ -389,6 +392,7 @@ new_var_info (tree t, const char *name, bool add_id)\n \t\t\t  /* We have to treat even local register variables\n \t\t\t     as escape points.  */\n \t\t\t  || (VAR_P (t) && DECL_HARD_REGISTER (t)));\n+  ret->is_reg_var = (t && TREE_CODE (t) == SSA_NAME);\n   ret->solution = BITMAP_ALLOC (&pta_obstack);\n   ret->oldsolution = NULL;\n   ret->next = 0;\n@@ -422,12 +426,14 @@ get_call_vi (gcall *call)\n   vi->size = 1;\n   vi->fullsize = 2;\n   vi->is_full_var = true;\n+  vi->is_reg_var = true;\n \n   vi2 = new_var_info (NULL_TREE, \"CALLCLOBBERED\", true);\n   vi2->offset = 1;\n   vi2->size = 1;\n   vi2->fullsize = 2;\n   vi2->is_full_var = true;\n+  vi2->is_reg_var = true;\n \n   vi->next = vi2->id;\n \n@@ -2892,6 +2898,7 @@ new_scalar_tmp_constraint_exp (const char *name, bool add_id)\n   vi->size = -1;\n   vi->fullsize = -1;\n   vi->is_full_var = 1;\n+  vi->is_reg_var = 1;\n \n   tmp.var = vi->id;\n   tmp.type = SCALAR;\n@@ -3930,6 +3937,7 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n \t{\n \t  varinfo_t uses = get_call_use_vi (stmt);\n \t  varinfo_t tem = new_var_info (NULL_TREE, \"callarg\", true);\n+\t  tem->is_reg_var = true;\n \t  make_constraint_to (tem->id, arg);\n \t  make_any_offset_constraints (tem);\n \t  if (!(flags & EAF_DIRECT))\n@@ -3943,6 +3951,7 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n \t  varinfo_t uses = get_call_use_vi (stmt);\n \t  varinfo_t clobbers = get_call_clobber_vi (stmt);\n \t  varinfo_t tem = new_var_info (NULL_TREE, \"callarg\", true);\n+\t  tem->is_reg_var = true;\n \t  make_constraint_to (tem->id, arg);\n \t  make_any_offset_constraints (tem);\n \t  if (!(flags & EAF_DIRECT))\n@@ -4110,7 +4119,10 @@ handle_const_call (gcall *stmt, vec<ce_s> *results)\n   /* May return offsetted arguments.  */\n   varinfo_t tem = NULL;\n   if (gimple_call_num_args (stmt) != 0)\n-    tem = new_var_info (NULL_TREE, \"callarg\", true);\n+    {\n+      tem = new_var_info (NULL_TREE, \"callarg\", true);\n+      tem->is_reg_var = true;\n+    }\n   for (k = 0; k < gimple_call_num_args (stmt); ++k)\n     {\n       tree arg = gimple_call_arg (stmt, k);\n@@ -5712,6 +5724,7 @@ create_function_info_for (tree decl, const char *name, bool add_id,\n       clobbervi->fullsize = vi->fullsize;\n       clobbervi->is_full_var = true;\n       clobbervi->is_global_var = false;\n+      clobbervi->is_reg_var = true;\n \n       gcc_assert (prev_vi->offset < clobbervi->offset);\n       prev_vi->next = clobbervi->id;\n@@ -5727,6 +5740,7 @@ create_function_info_for (tree decl, const char *name, bool add_id,\n       usevi->fullsize = vi->fullsize;\n       usevi->is_full_var = true;\n       usevi->is_global_var = false;\n+      usevi->is_reg_var = true;\n \n       gcc_assert (prev_vi->offset < usevi->offset);\n       prev_vi->next = usevi->id;\n@@ -7075,6 +7089,39 @@ solve_constraints (void)\n {\n   struct scc_info *si;\n \n+  /* Sort varinfos so that ones that cannot be pointed to are last.\n+     This makes bitmaps more efficient.  */\n+  unsigned int *map = XNEWVEC (unsigned int, varmap.length ());\n+  for (unsigned i = 0; i < integer_id + 1; ++i)\n+    map[i] = i;\n+  /* Start with non-register vars (as possibly address-taken), followed\n+     by register vars as conservative set of vars never appearing in\n+     the points-to solution bitmaps.  */\n+  unsigned j = integer_id + 1;\n+  for (unsigned i = integer_id + 1; i < varmap.length (); ++i)\n+    if (! varmap[i]->is_reg_var)\n+      map[i] = j++;\n+  for (unsigned i = integer_id + 1; i < varmap.length (); ++i)\n+    if (varmap[i]->is_reg_var)\n+      map[i] = j++;\n+  /* Shuffle varmap according to map.  */\n+  for (unsigned i = integer_id + 1; i < varmap.length (); ++i)\n+    {\n+      while (map[varmap[i]->id] != i)\n+\tstd::swap (varmap[i], varmap[map[varmap[i]->id]]);\n+      gcc_assert (bitmap_empty_p (varmap[i]->solution));\n+      varmap[i]->id = i;\n+      varmap[i]->next = map[varmap[i]->next];\n+      varmap[i]->head = map[varmap[i]->head];\n+    }\n+  /* Finally rewrite constraints.  */\n+  for (unsigned i = 0; i < constraints.length (); ++i)\n+    {\n+      constraints[i]->lhs.var = map[constraints[i]->lhs.var];\n+      constraints[i]->rhs.var = map[constraints[i]->rhs.var];\n+    }\n+  free (map);\n+\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"\\nCollapsing static cycles and doing variable \""}]}