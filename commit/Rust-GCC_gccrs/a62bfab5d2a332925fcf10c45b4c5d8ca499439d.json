{"sha": "a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYyYmZhYjVkMmEzMzI5MjVmY2YxMGM0NWI0YzVkOGNhNDk5NDM5ZA==", "commit": {"author": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-10-30T07:55:39Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-10-30T07:55:39Z"}, "message": "Remove cgraph_global_info.\n\nFrom-SVN: r277600", "tree": {"sha": "d0586bccd3e715429ba1c4df5ba680575950b1e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0586bccd3e715429ba1c4df5ba680575950b1e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/comments", "author": null, "committer": null, "parents": [{"sha": "53289de583e4dfab17ace7b39e102b04eba749e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53289de583e4dfab17ace7b39e102b04eba749e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53289de583e4dfab17ace7b39e102b04eba749e5"}], "stats": {"total": 374, "additions": 184, "deletions": 190}, "files": [{"sha": "2dc91a3a99bb7a3324f353e11a282c9b0e14b051", "filename": "gcc/cgraph.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -539,7 +539,7 @@ cgraph_node::get_create (tree decl)\n {\n   cgraph_node *first_clone = cgraph_node::get (decl);\n \n-  if (first_clone && !first_clone->global.inlined_to)\n+  if (first_clone && !first_clone->inlined_to)\n     return first_clone;\n \n   cgraph_node *node = cgraph_node::create (decl);\n@@ -659,7 +659,7 @@ cgraph_node::get_for_asmname (tree asmname)\n        node = node->next_sharing_asm_name)\n     {\n       cgraph_node *cn = dyn_cast <cgraph_node *> (node);\n-      if (cn && !cn->global.inlined_to)\n+      if (cn && !cn->inlined_to)\n \treturn cn;\n     }\n   return NULL;\n@@ -1786,7 +1786,7 @@ cgraph_node::remove (void)\n     {\n       cgraph_node *n = cgraph_node::get (decl);\n       if (!n\n-\t  || (!n->clones && !n->clone_of && !n->global.inlined_to\n+\t  || (!n->clones && !n->clone_of && !n->inlined_to\n \t      && ((symtab->global_info_ready || in_lto_p)\n \t\t  && (TREE_ASM_WRITTEN (n->decl)\n \t\t      || DECL_EXTERNAL (n->decl)\n@@ -1817,7 +1817,7 @@ cgraph_node::mark_address_taken (void)\n {\n   /* Indirect inlining can figure out that all uses of the address are\n      inlined.  */\n-  if (global.inlined_to)\n+  if (inlined_to)\n     {\n       gcc_assert (cfun->after_inlining);\n       gcc_assert (callers->indirect_inlining_edge);\n@@ -1944,10 +1944,10 @@ cgraph_node::dump (FILE *f)\n \n   dump_base (f);\n \n-  if (global.inlined_to)\n+  if (inlined_to)\n     fprintf (f, \"  Function %s is inline copy in %s\\n\",\n \t     dump_name (),\n-\t     global.inlined_to->dump_name ());\n+\t     inlined_to->dump_name ());\n   if (clone_of)\n     fprintf (f, \"  Clone of %s\\n\", clone_of->dump_asm_name ());\n   if (symtab->function_flags_ready)\n@@ -2096,7 +2096,7 @@ cgraph_node::dump (FILE *f)\n \tif (dyn_cast <cgraph_node *> (ref->referring)->count.initialized_p ())\n \t  sum += dyn_cast <cgraph_node *> (ref->referring)->count.ipa ();\n   \n-      if (global.inlined_to\n+      if (inlined_to\n \t  || (symtab->state < EXPANSION\n \t      && ultimate_alias_target () == this && only_called_directly_p ()))\n \tok = !count.ipa ().differs_from_p (sum);\n@@ -2212,14 +2212,14 @@ cgraph_node::get_availability (symtab_node *ref)\n     {\n       cgraph_node *cref = dyn_cast <cgraph_node *> (ref);\n       if (cref)\n-\tref = cref->global.inlined_to;\n+\tref = cref->inlined_to;\n     }\n   enum availability avail;\n   if (!analyzed)\n     avail = AVAIL_NOT_AVAILABLE;\n   else if (local.local)\n     avail = AVAIL_LOCAL;\n-  else if (global.inlined_to)\n+  else if (inlined_to)\n     avail = AVAIL_AVAILABLE;\n   else if (transparent_alias)\n     ultimate_alias_target (&avail, ref);\n@@ -2828,7 +2828,7 @@ bool\n cgraph_node::will_be_removed_from_program_if_no_direct_calls_p\n \t (bool will_inline)\n {\n-  gcc_assert (!global.inlined_to);\n+  gcc_assert (!inlined_to);\n   if (DECL_EXTERNAL (decl))\n     return true;\n \n@@ -3015,7 +3015,7 @@ cgraph_edge::verify_corresponds_to_fndecl (tree decl)\n {\n   cgraph_node *node;\n \n-  if (!decl || callee->global.inlined_to)\n+  if (!decl || callee->inlined_to)\n     return false;\n   if (symtab->state == LTO_STREAMING)\n     return false;\n@@ -3085,7 +3085,7 @@ cgraph_node::verify_node (void)\n       error (\"cgraph count invalid\");\n       error_found = true;\n     }\n-  if (global.inlined_to && same_comdat_group)\n+  if (inlined_to && same_comdat_group)\n     {\n       error (\"inline clone in same comdat group list\");\n       error_found = true;\n@@ -3095,17 +3095,17 @@ cgraph_node::verify_node (void)\n       error (\"local symbols must be defined\");\n       error_found = true;\n     }\n-  if (global.inlined_to && externally_visible)\n+  if (inlined_to && externally_visible)\n     {\n       error (\"externally visible inline clone\");\n       error_found = true;\n     }\n-  if (global.inlined_to && address_taken)\n+  if (inlined_to && address_taken)\n     {\n       error (\"inline clone with address taken\");\n       error_found = true;\n     }\n-  if (global.inlined_to && force_output)\n+  if (inlined_to && force_output)\n     {\n       error (\"inline clone is forced to output\");\n       error_found = true;\n@@ -3142,9 +3142,9 @@ cgraph_node::verify_node (void)\n \t}\n       if (!e->inline_failed)\n \t{\n-\t  if (global.inlined_to\n-\t      != (e->caller->global.inlined_to\n-\t\t  ? e->caller->global.inlined_to : e->caller))\n+\t  if (inlined_to\n+\t      != (e->caller->inlined_to\n+\t\t  ? e->caller->inlined_to : e->caller))\n \t    {\n \t      error (\"inlined_to pointer is wrong\");\n \t      error_found = true;\n@@ -3156,7 +3156,7 @@ cgraph_node::verify_node (void)\n \t    }\n \t}\n       else\n-\tif (global.inlined_to)\n+\tif (inlined_to)\n \t  {\n \t    error (\"inlined_to pointer set for noninline callers\");\n \t    error_found = true;\n@@ -3167,7 +3167,7 @@ cgraph_node::verify_node (void)\n       if (e->verify_count ())\n \terror_found = true;\n       if (gimple_has_body_p (e->caller->decl)\n-\t  && !e->caller->global.inlined_to\n+\t  && !e->caller->inlined_to\n \t  && !e->speculative\n \t  /* Optimized out calls are redirected to __builtin_unreachable.  */\n \t  && (e->count.nonzero_p ()\n@@ -3192,7 +3192,7 @@ cgraph_node::verify_node (void)\n       if (e->verify_count ())\n \terror_found = true;\n       if (gimple_has_body_p (e->caller->decl)\n-\t  && !e->caller->global.inlined_to\n+\t  && !e->caller->inlined_to\n \t  && !e->speculative\n \t  && e->count.ipa_p ()\n \t  && count\n@@ -3209,12 +3209,12 @@ cgraph_node::verify_node (void)\n \t  error_found = true;\n \t}\n     }\n-  if (!callers && global.inlined_to)\n+  if (!callers && inlined_to)\n     {\n       error (\"inlined_to pointer is set but no predecessors found\");\n       error_found = true;\n     }\n-  if (global.inlined_to == this)\n+  if (inlined_to == this)\n     {\n       error (\"inlined_to pointer refers to itself\");\n       error_found = true;\n@@ -3303,15 +3303,15 @@ cgraph_node::verify_node (void)\n \t  error (\"More than one edge out of thunk node\");\n           error_found = true;\n \t}\n-      if (gimple_has_body_p (decl) && !global.inlined_to)\n+      if (gimple_has_body_p (decl) && !inlined_to)\n         {\n \t  error (\"Thunk is not supposed to have body\");\n           error_found = true;\n         }\n     }\n   else if (analyzed && gimple_has_body_p (decl)\n \t   && !TREE_ASM_WRITTEN (decl)\n-\t   && (!DECL_EXTERNAL (decl) || global.inlined_to)\n+\t   && (!DECL_EXTERNAL (decl) || inlined_to)\n \t   && !flag_wpa)\n     {\n       if (this_cfun->cfg)\n@@ -3586,7 +3586,7 @@ cgraph_node::get_body (void)\n      early.\n      TODO: Materializing clones here will likely lead to smaller LTRANS\n      footprint. */\n-  gcc_assert (!global.inlined_to && !clone_of);\n+  gcc_assert (!inlined_to && !clone_of);\n   if (ipa_transforms_to_apply.exists ())\n     {\n       opt_pass *saved_current_pass = current_pass;\n@@ -3776,8 +3776,8 @@ cgraph_node::has_thunk_p (cgraph_node *node, void *)\n sreal\n cgraph_edge::sreal_frequency ()\n {\n-  return count.to_sreal_scale (caller->global.inlined_to\n-\t\t\t       ? caller->global.inlined_to->count\n+  return count.to_sreal_scale (caller->inlined_to\n+\t\t\t       ? caller->inlined_to->count\n \t\t\t       : caller->count);\n }\n "}, {"sha": "826d391db32e6112e939513dffb534208382683b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -730,15 +730,6 @@ struct GTY(()) cgraph_local_info {\n   unsigned tm_may_enter_irr : 1;\n };\n \n-/* Information about the function that needs to be computed globally\n-   once compilation is finished.  Available only with -funit-at-a-time.  */\n-\n-struct GTY(()) cgraph_global_info {\n-  /* For inline clones this points to the function they will be\n-     inlined into.  */\n-  cgraph_node *inlined_to;\n-};\n-\n /* Represent which DECL tree (or reference to such tree)\n    will be replaced by another tree while versioning.  */\n struct GTY(()) ipa_replace_map\n@@ -979,7 +970,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n \n      If the new node is being inlined into another one, NEW_INLINED_TO should be\n      the outline function the new one is (even indirectly) inlined to.\n-     All hooks will see this in node's global.inlined_to, when invoked.\n+     All hooks will see this in node's inlined_to, when invoked.\n      Can be NULL if the node is not inlined.  SUFFIX is string that is appended\n      to the original name.  */\n   cgraph_node *create_clone (tree decl, profile_count count,\n@@ -1446,7 +1437,11 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   vec<ipa_opt_pass> GTY((skip)) ipa_transforms_to_apply;\n \n   cgraph_local_info local;\n-  cgraph_global_info global;\n+\n+  /* For inline clones this points to the function they will be\n+     inlined into.  */\n+  cgraph_node *inlined_to;\n+\n   struct cgraph_rtl_info *rtl;\n   cgraph_clone_info clone;\n   cgraph_thunk_info thunk;\n@@ -2519,7 +2514,7 @@ symtab_node::real_symbol_p (void)\n   if (!is_a <cgraph_node *> (this))\n     return true;\n   cnode = dyn_cast <cgraph_node *> (this);\n-  if (cnode->global.inlined_to)\n+  if (cnode->inlined_to)\n     return false;\n   return true;\n }\n@@ -2542,13 +2537,13 @@ symtab_node::in_same_comdat_group_p (symtab_node *target)\n \n   if (cgraph_node *cn = dyn_cast <cgraph_node *> (target))\n     {\n-      if (cn->global.inlined_to)\n-\tsource = cn->global.inlined_to;\n+      if (cn->inlined_to)\n+\tsource = cn->inlined_to;\n     }\n   if (cgraph_node *cn = dyn_cast <cgraph_node *> (target))\n     {\n-      if (cn->global.inlined_to)\n-\ttarget = cn->global.inlined_to;\n+      if (cn->inlined_to)\n+\ttarget = cn->inlined_to;\n     }\n \n   return source->get_comdat_group () == target->get_comdat_group ();\n@@ -2995,7 +2990,7 @@ struct GTY((for_user)) constant_descriptor_tree {\n inline bool\n cgraph_node::only_called_directly_or_aliased_p (void)\n {\n-  gcc_assert (!global.inlined_to);\n+  gcc_assert (!inlined_to);\n   return (!force_output && !address_taken\n \t  && !ifunc_resolver\n \t  && !used_from_other_partition\n@@ -3012,7 +3007,7 @@ cgraph_node::only_called_directly_or_aliased_p (void)\n inline bool\n cgraph_node::can_remove_if_no_direct_calls_and_refs_p (void)\n {\n-  gcc_checking_assert (!global.inlined_to);\n+  gcc_checking_assert (!inlined_to);\n   /* Extern inlines can always go, we will use the external definition.  */\n   if (DECL_EXTERNAL (decl))\n     return true;\n@@ -3183,8 +3178,8 @@ inline bool\n cgraph_edge::recursive_p (void)\n {\n   cgraph_node *c = callee->ultimate_alias_target ();\n-  if (caller->global.inlined_to)\n-    return caller->global.inlined_to->decl == c->decl;\n+  if (caller->inlined_to)\n+    return caller->inlined_to->decl == c->decl;\n   else\n     return caller->decl == c->decl;\n }\n@@ -3221,8 +3216,8 @@ cgraph_edge::binds_to_current_def_p ()\n inline int\n cgraph_edge::frequency ()\n {\n-  return count.to_cgraph_frequency (caller->global.inlined_to\n-\t\t\t\t    ? caller->global.inlined_to->count\n+  return count.to_cgraph_frequency (caller->inlined_to\n+\t\t\t\t    ? caller->inlined_to->count\n \t\t\t\t    : caller->count);\n }\n \n@@ -3244,7 +3239,7 @@ inline void\n cgraph_node::mark_force_output (void)\n {\n   force_output = 1;\n-  gcc_checking_assert (!global.inlined_to);\n+  gcc_checking_assert (!inlined_to);\n }\n \n /* Return true if function should be optimized for size.  */"}, {"sha": "3baf67b48289f06b6b4260d584445fec2b52758b", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -428,7 +428,7 @@ cgraph_edge::rebuild_edges (void)\n \tnode->record_stmt_references (gsi_stmt (gsi));\n     }\n   record_eh_tables (node, cfun);\n-  gcc_assert (!node->global.inlined_to);\n+  gcc_assert (!node->inlined_to);\n   return 0;\n }\n "}, {"sha": "fcf9cd5c992a952bc1a5a06d835368ccb8ca8723", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -309,7 +309,7 @@ dump_callgraph_transformation (const cgraph_node *original,\n \n    If the new node is being inlined into another one, NEW_INLINED_TO should be\n    the outline function the new one is (even indirectly) inlined to.  All hooks\n-   will see this in node's global.inlined_to, when invoked.  Can be NULL if the\n+   will see this in node's inlined_to, when invoked.  Can be NULL if the\n    node is not inlined.\n \n    If PARAM_ADJUSTMENTS is non-NULL, the parameter manipulation information\n@@ -357,8 +357,7 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n   new_node->externally_visible = false;\n   new_node->no_reorder = no_reorder;\n   new_node->local.local = true;\n-  new_node->global = global;\n-  new_node->global.inlined_to = new_inlined_to;\n+  new_node->inlined_to = new_inlined_to;\n   new_node->rtl = rtl;\n   new_node->frequency = frequency;\n   new_node->tp_first_run = tp_first_run;\n@@ -862,7 +861,7 @@ cgraph_node::create_version_clone (tree new_decl,\n    new_version->externally_visible = false;\n    new_version->no_reorder = no_reorder;\n    new_version->local.local = new_version->definition;\n-   new_version->global = global;\n+   new_version->inlined_to = inlined_to;\n    new_version->rtl = rtl;\n    new_version->count = count;\n "}, {"sha": "ef96393a009ba5becc2f2f49f274e4cf26b49a41", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -392,7 +392,7 @@ cgraph_node::reset (void)\n \n   /* Reset our data structures so we can analyze the function again.  */\n   memset (&local, 0, sizeof (local));\n-  memset (&global, 0, sizeof (global));\n+  inlined_to = NULL;\n   memset (&rtl, 0, sizeof (rtl));\n   analyzed = false;\n   definition = false;\n@@ -1507,7 +1507,7 @@ mark_functions_to_output (void)\n       if (node->analyzed\n \t  && !node->thunk.thunk_p\n \t  && !node->alias\n-\t  && !node->global.inlined_to\n+\t  && !node->inlined_to\n \t  && !TREE_ASM_WRITTEN (decl)\n \t  && !DECL_EXTERNAL (decl))\n \t{\n@@ -1532,7 +1532,7 @@ mark_functions_to_output (void)\n \t{\n \t  /* We should've reclaimed all functions that are not needed.  */\n \t  if (flag_checking\n-\t      && !node->global.inlined_to\n+\t      && !node->inlined_to\n \t      && gimple_has_body_p (decl)\n \t      /* FIXME: in ltrans unit when offline copy is outside partition but inline copies\n \t\t are inside partition, we can end up not removing the body since we no longer\n@@ -1545,7 +1545,7 @@ mark_functions_to_output (void)\n \t      node->debug ();\n \t      internal_error (\"failed to reclaim unneeded function\");\n \t    }\n-\t  gcc_assert (node->global.inlined_to\n+\t  gcc_assert (node->inlined_to\n \t\t      || !gimple_has_body_p (decl)\n \t\t      || node->in_other_partition\n \t\t      || node->clones\n@@ -1560,7 +1560,7 @@ mark_functions_to_output (void)\n       if (node->same_comdat_group && !node->process)\n \t{\n \t  tree decl = node->decl;\n-\t  if (!node->global.inlined_to\n+\t  if (!node->inlined_to\n \t      && gimple_has_body_p (decl)\n \t      /* FIXME: in an ltrans unit when the offline copy is outside a\n \t\t partition but inline copies are inside a partition, we can\n@@ -2117,7 +2117,7 @@ cgraph_node::assemble_thunks_and_aliases (void)\n \n   for (e = callers; e;)\n     if (e->caller->thunk.thunk_p\n-\t&& !e->caller->global.inlined_to)\n+\t&& !e->caller->inlined_to)\n       {\n \tcgraph_node *thunk = e->caller;\n \n@@ -2154,7 +2154,7 @@ cgraph_node::expand (void)\n   location_t saved_loc;\n \n   /* We ought to not compile any inline clones.  */\n-  gcc_assert (!global.inlined_to);\n+  gcc_assert (!inlined_to);\n \n   /* __RTL functions are compiled as soon as they are parsed, so don't\n      do it again.  */\n@@ -2707,7 +2707,7 @@ symbol_table::compile (void)\n       bool error_found = false;\n \n       FOR_EACH_DEFINED_FUNCTION (node)\n-\tif (node->global.inlined_to\n+\tif (node->inlined_to\n \t    || gimple_has_body_p (node->decl))\n \t  {\n \t    error_found = true;"}, {"sha": "1b7e7edfa8c3c34bf1433dcb6be610bb521333db", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -135,7 +135,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n       if (!snode || !snode->definition)\n \treturn false;\n       node = dyn_cast <cgraph_node *> (snode);\n-      return !node || !node->global.inlined_to;\n+      return !node || !node->inlined_to;\n     }\n \n   /* We will later output the initializer, so we can refer to it.\n@@ -184,7 +184,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n \t      || (!snode->forced_by_abi && !snode->force_output))))\n     return false;\n   node = dyn_cast <cgraph_node *> (snode);\n-  return !node || !node->global.inlined_to;\n+  return !node || !node->inlined_to;\n }\n \n /* Create a temporary for TYPE for a statement STMT.  If the current function"}, {"sha": "b496497ff66127ef82bbd04d76c6953f7e85ec50", "filename": "gcc/ipa-comdats.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-comdats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-comdats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-comdats.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -98,8 +98,8 @@ propagate_comdat_group (struct symtab_node *symbol,\n \n       if (cgraph_node * cn = dyn_cast <cgraph_node *> (symbol2))\n \t{\n-\t  if (cn->global.inlined_to)\n-\t    symbol2 = cn->global.inlined_to;\n+\t  if (cn->inlined_to)\n+\t    symbol2 = cn->inlined_to;\n \t}\n \n       /* The actual merge operation.  */\n@@ -133,8 +133,8 @@ propagate_comdat_group (struct symtab_node *symbol,\n \t    /* If we see inline clone, its comdat group actually\n \t       corresponds to the comdat group of the function it\n \t       is inlined to.  */\n-\t    if (cn->global.inlined_to)\n-\t      symbol2 = cn->global.inlined_to;\n+\t    if (cn->inlined_to)\n+\t      symbol2 = cn->inlined_to;\n \t  }\n \n         /* The actual merge operation.  */"}, {"sha": "a14e79537886043727c06b4ab86c0be1ea69b3c3", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -2414,7 +2414,7 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n \t       || target_node->definition)\n \t   && target_node->real_symbol_p ())\n     {\n-      gcc_assert (!target_node->global.inlined_to);\n+      gcc_assert (!target_node->inlined_to);\n       gcc_assert (target_node->real_symbol_p ());\n       /* When sanitizing, do not assume that __cxa_pure_virtual is not called\n \t by valid program.  */"}, {"sha": "798fdbe5dd251567b947ab6abe8359db3da46610", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -470,8 +470,8 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n       class ipa_call_summary *es = ipa_call_summaries->get (e);\n       int i, count = ipa_get_cs_argument_count (args);\n \n-      if (e->caller->global.inlined_to)\n-\tcaller_parms_info = IPA_NODE_REF (e->caller->global.inlined_to);\n+      if (e->caller->inlined_to)\n+\tcaller_parms_info = IPA_NODE_REF (e->caller->inlined_to);\n       else\n \tcaller_parms_info = IPA_NODE_REF (e->caller);\n       callee_pi = IPA_NODE_REF (e->callee);\n@@ -746,7 +746,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t  set_hint_predicate (&info->loop_stride, p);\n \t}\n     }\n-  if (!dst->global.inlined_to)\n+  if (!dst->inlined_to)\n     ipa_update_overall_fn_summary (dst);\n }\n \n@@ -927,7 +927,7 @@ ipa_dump_fn_summaries (FILE *f)\n   struct cgraph_node *node;\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (!node->global.inlined_to)\n+    if (!node->inlined_to)\n       ipa_dump_fn_summary (f, node);\n }\n \n@@ -2690,7 +2690,7 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n   HOST_WIDE_INT self_stack_size;\n   struct cgraph_edge *e;\n \n-  gcc_assert (!node->global.inlined_to);\n+  gcc_assert (!node->inlined_to);\n \n   if (!ipa_fn_summaries)\n     ipa_fn_summary_alloc ();\n@@ -3115,13 +3115,13 @@ HOST_WIDE_INT\n ipa_get_stack_frame_offset (struct cgraph_node *node)\n {\n   HOST_WIDE_INT offset = 0;\n-  if (!node->global.inlined_to)\n+  if (!node->inlined_to)\n     return 0;\n   node = node->callers->caller;\n   while (true)\n     {\n       offset += ipa_size_summaries->get (node)->estimated_self_stack_size;\n-      if (!node->global.inlined_to)\n+      if (!node->inlined_to)\n \treturn offset;\n       node = node->callers->caller;\n     }\n@@ -3292,8 +3292,8 @@ void\n ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n {\n   ipa_fn_summary *callee_info = ipa_fn_summaries->get (edge->callee);\n-  struct cgraph_node *to = (edge->caller->global.inlined_to\n-\t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n+  struct cgraph_node *to = (edge->caller->inlined_to\n+\t\t\t    ? edge->caller->inlined_to : edge->caller);\n   class ipa_fn_summary *info = ipa_fn_summaries->get (to);\n   clause_t clause = 0;\t/* not_inline is known to be false.  */\n   size_time_entry *e;"}, {"sha": "8dee132600a0cb3ed89b44122b1a4d7da44c3118", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -93,8 +93,8 @@ int\n simple_edge_hints (struct cgraph_edge *edge)\n {\n   int hints = 0;\n-  struct cgraph_node *to = (edge->caller->global.inlined_to\n-\t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n+  struct cgraph_node *to = (edge->caller->inlined_to\n+\t\t\t    ? edge->caller->inlined_to : edge->caller);\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n   int to_scc_no = ipa_fn_summaries->get (to)->scc_no;\n   int callee_scc_no = ipa_fn_summaries->get (callee)->scc_no;\n@@ -147,8 +147,8 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n      may hurt optimization of the caller's hot path.  */\n   if (edge->count.ipa ().initialized_p () && edge->maybe_hot_p ()\n       && (edge->count.ipa ().apply_scale (2, 1)\n-          > (edge->caller->global.inlined_to\n-\t     ? edge->caller->global.inlined_to->count.ipa ()\n+\t  > (edge->caller->inlined_to\n+\t     ? edge->caller->inlined_to->count.ipa ()\n \t     : edge->caller->count.ipa ())))\n     hints |= INLINE_HINT_known_hot;\n "}, {"sha": "1cc78034f19111b5211041626080437134d72051", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -166,8 +166,8 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n   struct cgraph_node *inlining_into;\n   struct cgraph_edge *next;\n \n-  if (e->caller->global.inlined_to)\n-    inlining_into = e->caller->global.inlined_to;\n+  if (e->caller->inlined_to)\n+    inlining_into = e->caller->inlined_to;\n   else\n     inlining_into = e->caller;\n \n@@ -193,7 +193,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \n \t     For now we keep the ohter functions in the group in program until\n \t     cgraph_remove_unreachable_functions gets rid of them.  */\n-\t  gcc_assert (!e->callee->global.inlined_to);\n+\t  gcc_assert (!e->callee->inlined_to);\n \t  e->callee->remove_from_same_comdat_group ();\n \t  if (e->callee->definition\n \t      && inline_account_function_p (e->callee))\n@@ -226,7 +226,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n   else\n     e->callee->remove_from_same_comdat_group ();\n \n-  e->callee->global.inlined_to = inlining_into;\n+  e->callee->inlined_to = inlining_into;\n \n   /* Recursively clone all bodies.  */\n   for (e = e->callee->callees; e; e = next)\n@@ -344,11 +344,11 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   /* Don't inline inlined edges.  */\n   gcc_assert (e->inline_failed);\n   /* Don't even think of inlining inline clone.  */\n-  gcc_assert (!callee->global.inlined_to);\n+  gcc_assert (!callee->inlined_to);\n \n   to = e->caller;\n-  if (to->global.inlined_to)\n-    to = to->global.inlined_to;\n+  if (to->inlined_to)\n+    to = to->inlined_to;\n   if (to->thunk.thunk_p)\n     {\n       struct cgraph_node *target = to->callees->callee;\n@@ -478,7 +478,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \n   clone_inlined_nodes (e, true, update_original, overall_size);\n \n-  gcc_assert (curr->callee->global.inlined_to == to);\n+  gcc_assert (curr->callee->inlined_to == to);\n \n   old_size = ipa_size_summaries->get (to)->size;\n   ipa_merge_fn_summary_after_inlining (e);"}, {"sha": "210387050bcecd7ceb36fbc8b12ebda0dbe6f3a6", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -167,7 +167,7 @@ caller_growth_limits (struct cgraph_edge *e)\n \tlimit = size_info->self_size;\n       if (stack_size_limit < size_info->estimated_self_stack_size)\n \tstack_size_limit = size_info->estimated_self_stack_size;\n-      if (to->global.inlined_to)\n+      if (to->inlined_to)\n         to = to->callers->caller;\n       else\n \tbreak;\n@@ -321,8 +321,8 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n \n   bool inlinable = true;\n   enum availability avail;\n-  cgraph_node *caller = e->caller->global.inlined_to\n-\t\t        ? e->caller->global.inlined_to : e->caller;\n+  cgraph_node *caller = (e->caller->inlined_to\n+\t\t\t ? e->caller->inlined_to : e->caller);\n   cgraph_node *callee = e->callee->ultimate_alias_target (&avail, caller);\n \n   if (!callee->definition)\n@@ -458,8 +458,8 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \n   bool inlinable = true;\n   enum availability avail;\n-  cgraph_node *caller = e->caller->global.inlined_to\n-\t\t        ? e->caller->global.inlined_to : e->caller;\n+  cgraph_node *caller = (e->caller->inlined_to\n+\t\t\t ? e->caller->inlined_to : e->caller);\n   cgraph_node *callee = e->callee->ultimate_alias_target (&avail, caller);\n   tree caller_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (caller->decl);\n   tree callee_tree\n@@ -737,8 +737,8 @@ inline sreal\n compute_uninlined_call_time (struct cgraph_edge *edge,\n \t\t\t     sreal uninlined_call_time)\n {\n-  cgraph_node *caller = (edge->caller->global.inlined_to \n-\t\t\t ? edge->caller->global.inlined_to\n+  cgraph_node *caller = (edge->caller->inlined_to\n+\t\t\t ? edge->caller->inlined_to\n \t\t\t : edge->caller);\n \n   sreal freq = edge->sreal_frequency ();\n@@ -758,8 +758,8 @@ inline sreal\n compute_inlined_call_time (struct cgraph_edge *edge,\n \t\t\t   sreal time)\n {\n-  cgraph_node *caller = (edge->caller->global.inlined_to \n-\t\t\t ? edge->caller->global.inlined_to\n+  cgraph_node *caller = (edge->caller->inlined_to\n+\t\t\t ? edge->caller->inlined_to\n \t\t\t : edge->caller);\n   sreal caller_time = ipa_fn_summaries->get (caller)->time;\n \n@@ -789,9 +789,9 @@ big_speedup_p (struct cgraph_edge *e)\n   sreal spec_time = estimate_edge_time (e, &unspec_time);\n   sreal time = compute_uninlined_call_time (e, unspec_time);\n   sreal inlined_time = compute_inlined_call_time (e, spec_time);\n-  cgraph_node *caller = e->caller->global.inlined_to\n-\t\t        ? e->caller->global.inlined_to\n-\t\t        : e->caller;\n+  cgraph_node *caller = (e->caller->inlined_to\n+\t\t\t ? e->caller->inlined_to\n+\t\t\t : e->caller);\n   int limit = opt_for_fn (caller->decl, optimize) >= 3\n \t      ? PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP)\n \t      : PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP_O2);\n@@ -959,7 +959,7 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n       reason = \"--param max-inline-recursive-depth exceeded.\";\n       want_inline = false;\n     }\n-  else if (outer_node->global.inlined_to\n+  else if (outer_node->inlined_to\n \t   && (caller_freq = outer_node->callers->sreal_frequency ()) == 0)\n     {\n       reason = \"caller frequency is 0\";\n@@ -1069,7 +1069,7 @@ want_inline_function_to_all_callers_p (struct cgraph_node *node, bool cold)\n   if (node->alias)\n     return false;\n   /* Already inlined?  */\n-  if (node->global.inlined_to)\n+  if (node->inlined_to)\n     return false;\n   /* Does it have callers?  */\n   if (!node->call_for_symbol_and_aliases (has_caller_p, NULL, true))\n@@ -1101,8 +1101,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n   class ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n   ipa_hints hints;\n-  cgraph_node *caller = (edge->caller->global.inlined_to \n-\t\t\t ? edge->caller->global.inlined_to\n+  cgraph_node *caller = (edge->caller->inlined_to\n+\t\t\t ? edge->caller->inlined_to\n \t\t\t : edge->caller);\n \n   growth = estimate_edge_growth (edge);\n@@ -1196,7 +1196,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n       if (growth > overall_growth\n \t  /* ... and having only one caller which is not inlined ... */\n \t  && callee_info->single_caller\n-\t  && !edge->caller->global.inlined_to\n+\t  && !edge->caller->inlined_to\n \t  /* ... and edges executed only conditionally ... */\n \t  && edge->sreal_frequency () < 1\n \t  /* ... consider case where callee is not inline but caller is ... */\n@@ -1365,8 +1365,8 @@ reset_edge_caches (struct cgraph_node *node)\n   struct cgraph_node *where = node;\n   struct ipa_ref *ref;\n \n-  if (where->global.inlined_to)\n-    where = where->global.inlined_to;\n+  if (where->inlined_to)\n+    where = where->inlined_to;\n \n   if (edge_growth_cache != NULL)\n     for (edge = where->callers; edge; edge = edge->next_caller)\n@@ -1416,7 +1416,7 @@ update_caller_keys (edge_heap_t *heap, struct cgraph_node *node,\n   struct ipa_ref *ref;\n \n   if ((!node->alias && !ipa_fn_summaries->get (node)->inlinable)\n-      || node->global.inlined_to)\n+      || node->inlined_to)\n     return;\n   if (!bitmap_set_bit (updated_nodes, node->get_uid ()))\n     return;\n@@ -1544,8 +1544,8 @@ recursive_inlining (struct cgraph_edge *edge,\n   int n = 0;\n \n   node = edge->caller;\n-  if (node->global.inlined_to)\n-    node = node->global.inlined_to;\n+  if (node->inlined_to)\n+    node = node->inlined_to;\n \n   if (DECL_DECLARED_INLINE_P (node->decl))\n     limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE);\n@@ -1593,7 +1593,7 @@ recursive_inlining (struct cgraph_edge *edge,\n \n       depth = 1;\n       for (cnode = curr->caller;\n-\t   cnode->global.inlined_to; cnode = cnode->callers->caller)\n+\t   cnode->inlined_to; cnode = cnode->callers->caller)\n \tif (node->decl\n \t    == curr->callee->ultimate_alias_target ()->decl)\n           depth++;\n@@ -1658,7 +1658,7 @@ recursive_inlining (struct cgraph_edge *edge,\n        node = next)\n     {\n       next = symtab->next_function (node);\n-      if (node->global.inlined_to == master_clone)\n+      if (node->inlined_to == master_clone)\n \tnode->remove ();\n     }\n   master_clone->remove ();\n@@ -1776,8 +1776,8 @@ resolve_noninline_speculation (edge_heap_t *edge_heap, struct cgraph_edge *edge)\n   if (edge->speculative && !speculation_useful_p (edge, false))\n     {\n       struct cgraph_node *node = edge->caller;\n-      struct cgraph_node *where = node->global.inlined_to\n-\t\t\t\t  ? node->global.inlined_to : node;\n+      struct cgraph_node *where = node->inlined_to\n+\t\t\t\t  ? node->inlined_to : node;\n       auto_bitmap updated_nodes;\n \n       if (edge->count.ipa ().initialized_p ())\n@@ -1859,7 +1859,7 @@ inline_small_functions (void)\n   free (order);\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (!node->global.inlined_to)\n+    if (!node->inlined_to)\n       {\n \tif (!node->alias && node->analyzed\n \t    && (node->has_gimple_body_p () || node->thunk.thunk_p)\n@@ -1888,7 +1888,7 @@ inline_small_functions (void)\n \t\t  if (opt_for_fn (n2->decl, optimize))\n \t\t    {\n \t\t      ipa_fn_summary *info2 = ipa_fn_summaries->get\n-\t\t\t (n2->global.inlined_to ? n2->global.inlined_to : n2);\n+\t\t\t (n2->inlined_to ? n2->inlined_to : n2);\n \t\t      if (info2->scc_no)\n \t\t\tbreak;\n \t\t      info2->scc_no = id;\n@@ -1952,8 +1952,8 @@ inline_small_functions (void)\n \t    }\n       if (update)\n \t{\n-\t  struct cgraph_node *where = node->global.inlined_to\n-\t\t\t\t      ? node->global.inlined_to : node;\n+\t  struct cgraph_node *where = node->inlined_to\n+\t\t\t\t      ? node->inlined_to : node;\n \t  ipa_update_overall_fn_summary (where);\n \t  reset_edge_caches (where);\n           update_caller_keys (&edge_heap, where,\n@@ -2097,8 +2097,8 @@ inline_small_functions (void)\n       if (edge->recursive_p ())\n \t{\n \t  where = edge->caller;\n-\t  if (where->global.inlined_to)\n-\t    where = where->global.inlined_to;\n+\t  if (where->inlined_to)\n+\t    where = where->inlined_to;\n \t  if (!recursive_inlining (edge,\n \t\t\t\t   opt_for_fn (edge->caller->decl,\n \t\t\t\t\t       flag_indirect_inlining)\n@@ -2128,7 +2128,7 @@ inline_small_functions (void)\n \t     selective.  */\n \n \t  where = edge->caller;\n-\t  while (where->global.inlined_to)\n+\t  while (where->inlined_to)\n \t    {\n \t      if (where->decl == callee->decl)\n \t\touter_node = where, depth++;\n@@ -2147,7 +2147,7 @@ inline_small_functions (void)\n \t  else if (depth && dump_file)\n \t    fprintf (dump_file, \" Peeling recursion with depth %i\\n\", depth);\n \n-\t  gcc_checking_assert (!callee->global.inlined_to);\n+\t  gcc_checking_assert (!callee->inlined_to);\n \t  inline_call (edge, true, &new_indirect_edges, &overall_size, true);\n \t  add_new_edges_to_heap (&edge_heap, new_indirect_edges);\n \n@@ -2156,8 +2156,8 @@ inline_small_functions (void)\n \t  update_callee_keys (&edge_heap, where, updated_nodes);\n \t}\n       where = edge->caller;\n-      if (where->global.inlined_to)\n-\twhere = where->global.inlined_to;\n+      if (where->inlined_to)\n+\twhere = where->inlined_to;\n \n       /* Our profitability metric can depend on local properties\n \t such as number of inlinable calls and size of the function body.\n@@ -2290,8 +2290,8 @@ flatten_function (struct cgraph_node *node, bool early, bool update)\n \n   node->aux = NULL;\n   if (update)\n-    ipa_update_overall_fn_summary (node->global.inlined_to\n-\t\t\t\t   ? node->global.inlined_to : node);\n+    ipa_update_overall_fn_summary (node->inlined_to\n+\t\t\t\t   ? node->inlined_to : node);\n }\n \n /* Inline NODE to all callers.  Worker for cgraph_for_node_and_aliases.\n@@ -2305,7 +2305,7 @@ inline_to_all_callers_1 (struct cgraph_node *node, void *data,\n   int *num_calls = (int *)data;\n   bool callee_removed = false;\n \n-  while (node->callers && !node->global.inlined_to)\n+  while (node->callers && !node->inlined_to)\n     {\n       struct cgraph_node *caller = node->callers->caller;\n \n@@ -2378,7 +2378,7 @@ dump_overall_stats (void)\n   struct cgraph_node *node;\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (!node->global.inlined_to\n+    if (!node->inlined_to\n \t&& !node->alias)\n       {\n \tipa_fn_summary *s = ipa_fn_summaries->get (node);\n@@ -2670,8 +2670,8 @@ ipa_inline (void)\n \t    }\n \t  if (update)\n \t    {\n-\t      struct cgraph_node *where = node->global.inlined_to\n-\t\t\t\t\t  ? node->global.inlined_to : node;\n+\t      struct cgraph_node *where = node->inlined_to\n+\t\t\t\t\t  ? node->inlined_to : node;\n \t      reset_edge_caches (where);\n \t      ipa_update_overall_fn_summary (where);\n \t    }"}, {"sha": "50a54ebf19befea1fc3970a3608b53b00832cc21", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -326,8 +326,8 @@ ipa_propagate_frequency_1 (struct cgraph_node *node, void *data)\n       if (profile_info\n \t  && !(edge->callee->count.ipa () == profile_count::zero ())\n \t  && (edge->caller->frequency != NODE_FREQUENCY_UNLIKELY_EXECUTED\n-\t      || (edge->caller->global.inlined_to\n-\t\t  && edge->caller->global.inlined_to->frequency\n+\t      || (edge->caller->inlined_to\n+\t\t  && edge->caller->inlined_to->frequency\n \t\t     != NODE_FREQUENCY_UNLIKELY_EXECUTED)))\n \t  d->maybe_unlikely_executed = false;\n       if (edge->count.ipa ().initialized_p ()"}, {"sha": "5e703955f01a98a9f9b9feb4d872ac71af412e13", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -2892,7 +2892,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \n   /* Because may-edges are not explicitely represented and vtable may be external,\n      we may create the first reference to the object in the unit.  */\n-  if (!callee || callee->global.inlined_to)\n+  if (!callee || callee->inlined_to)\n     {\n \n       /* We are better to ensure we can refer to it.\n@@ -2945,7 +2945,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \n   /* We cannot make edges to inline clones.  It is bug that someone removed\n      the cgraph node too early.  */\n-  gcc_assert (!callee->global.inlined_to);\n+  gcc_assert (!callee->inlined_to);\n \n   if (dump_file && !unreachable)\n     {\n@@ -3412,8 +3412,8 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \n   ipa_check_create_edge_args ();\n   top = IPA_EDGE_REF (cs);\n-  new_root_info = IPA_NODE_REF (cs->caller->global.inlined_to\n-\t\t\t\t? cs->caller->global.inlined_to\n+  new_root_info = IPA_NODE_REF (cs->caller->inlined_to\n+\t\t\t\t? cs->caller->inlined_to\n \t\t\t\t: cs->caller);\n   inlined_node_info = IPA_NODE_REF (cs->callee->function_symbol ());\n \n@@ -3579,8 +3579,8 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n   class ipa_edge_args *args = IPA_EDGE_REF (cs);\n   if (!args)\n     return;\n-  struct cgraph_node *new_root = cs->caller->global.inlined_to\n-    ? cs->caller->global.inlined_to : cs->caller;\n+  struct cgraph_node *new_root = cs->caller->inlined_to\n+    ? cs->caller->inlined_to : cs->caller;\n   class ipa_node_params *new_root_info = IPA_NODE_REF (new_root);\n   class ipa_node_params *old_root_info = IPA_NODE_REF (cs->callee);\n   int count, i;\n@@ -3645,7 +3645,7 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t  gcc_checking_assert (ok);\n \n \t\t  clone = cs->caller;\n-\t\t  while (clone->global.inlined_to\n+\t\t  while (clone->inlined_to\n \t\t\t && clone != rdesc->cs->caller\n \t\t\t && IPA_NODE_REF (clone)->ipcp_orig_node)\n \t\t    {\n@@ -3870,16 +3870,16 @@ ipa_edge_args_sum_t::duplicate (cgraph_edge *src, cgraph_edge *dst,\n \t\t We need to find the duplicate that refers to our tree of\n \t\t inline clones.  */\n \n-\t      gcc_assert (dst->caller->global.inlined_to);\n+\t      gcc_assert (dst->caller->inlined_to);\n \t      for (dst_rdesc = src_rdesc->next_duplicate;\n \t\t   dst_rdesc;\n \t\t   dst_rdesc = dst_rdesc->next_duplicate)\n \t\t{\n \t\t  struct cgraph_node *top;\n-\t\t  top = dst_rdesc->cs->caller->global.inlined_to\n-\t\t    ? dst_rdesc->cs->caller->global.inlined_to\n+\t\t  top = dst_rdesc->cs->caller->inlined_to\n+\t\t    ? dst_rdesc->cs->caller->inlined_to\n \t\t    : dst_rdesc->cs->caller;\n-\t\t  if (dst->caller->global.inlined_to == top)\n+\t\t  if (dst->caller->inlined_to == top)\n \t\t    break;\n \t\t}\n \t      gcc_assert (dst_rdesc);\n@@ -3889,8 +3889,8 @@ ipa_edge_args_sum_t::duplicate (cgraph_edge *src, cgraph_edge *dst,\n       else if (dst_jf->type == IPA_JF_PASS_THROUGH\n \t       && src->caller == dst->caller)\n \t{\n-\t  struct cgraph_node *inline_root = dst->caller->global.inlined_to\n-\t    ? dst->caller->global.inlined_to : dst->caller;\n+\t  struct cgraph_node *inline_root = dst->caller->inlined_to\n+\t    ? dst->caller->inlined_to : dst->caller;\n \t  class ipa_node_params *root_info = IPA_NODE_REF (inline_root);\n \t  int idx = ipa_get_jf_pass_through_formal_id (dst_jf);\n "}, {"sha": "a142e0cc8f6b36e3219559aa87f1e17001b5623b", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -1678,7 +1678,7 @@ propagate_pure_const (void)\n \t  /* Inline clones share declaration with their offline copies;\n \t     do not modify their declarations since the offline copy may\n \t     be different.  */\n-\t  if (!w->global.inlined_to)\n+\t  if (!w->inlined_to)\n \t    switch (this_state)\n \t      {\n \t      case IPA_CONST:\n@@ -1839,7 +1839,7 @@ propagate_nothrow (void)\n \t      /* Inline clones share declaration with their offline copies;\n \t\t do not modify their declarations since the offline copy may\n \t\t be different.  */\n-\t      if (!w->global.inlined_to)\n+\t      if (!w->inlined_to)\n \t\t{\n \t\t  w->set_nothrow_flag (true);\n \t\t  if (dump_file)\n@@ -1966,7 +1966,7 @@ propagate_malloc (void)\n \tfunct_state l = funct_state_summaries->get (node);\n \tif (!node->alias\n \t    && l->malloc_state == STATE_MALLOC\n-\t    && !node->global.inlined_to)\n+\t    && !node->inlined_to)\n \t  {\n \t    if (dump_file && (dump_flags & TDF_DETAILS))\n \t      fprintf (dump_file, \"Function %s found to be malloc\\n\","}, {"sha": "feee92de545254848207eea7dbfcc98dce5023eb", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -901,7 +901,7 @@ propagate (void)\n       ipa_reference_global_vars_info_t node_g;\n \n       /* No need to produce summaries for inline clones.  */\n-      if (node->global.inlined_to)\n+      if (node->inlined_to)\n \tcontinue;\n \n       node_info = get_reference_vars_info (node);\n@@ -977,7 +977,7 @@ write_node_summary_p (struct cgraph_node *node,\n   ipa_reference_optimization_summary_t info;\n \n   /* See if we have (non-empty) info.  */\n-  if (!node->definition || node->global.inlined_to)\n+  if (!node->definition || node->inlined_to)\n     return false;\n   info = get_reference_optimization_summary (node);\n   if (!info)"}, {"sha": "8849429e9e404cf4dbf951dff0115ed9ab80a1ae", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -296,7 +296,7 @@ ipa_reverse_postorder (struct cgraph_node **order)\n       if (!node->aux\n \t  && (pass\n \t      || (!node->address_taken\n-\t\t  && !node->global.inlined_to\n+\t\t  && !node->inlined_to\n \t\t  && !node->alias && !node->thunk.thunk_p\n \t\t  && !node->only_called_directly_p ())))\n \t{"}, {"sha": "274d3081ada6ef9903cc7f611b676fd5195b8b8f", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -707,7 +707,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t  || DECL_EXTERNAL (node->decl));\n       if (cgraph_externally_visible_p (node, whole_program))\n         {\n-\t  gcc_assert (!node->global.inlined_to);\n+\t  gcc_assert (!node->inlined_to);\n \t  node->externally_visible = true;\n \t}\n       else"}, {"sha": "5d47e3d21463a56c24cc79e854ac6bba6fca9d51", "filename": "gcc/ipa.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -71,9 +71,9 @@ update_inlined_to_pointer (struct cgraph_node *node, struct cgraph_node *inlined\n {\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n-    if (e->callee->global.inlined_to)\n+    if (e->callee->inlined_to)\n       {\n-        e->callee->global.inlined_to = inlined_to;\n+\te->callee->inlined_to = inlined_to;\n \tupdate_inlined_to_pointer (e->callee, inlined_to);\n       }\n }\n@@ -335,11 +335,11 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n       node->used_as_abstract_origin = false;\n       node->indirect_call_target = false;\n       if (node->definition\n-\t  && !node->global.inlined_to\n+\t  && !node->inlined_to\n \t  && !node->in_other_partition\n \t  && !node->can_remove_if_no_direct_calls_and_refs_p ())\n \t{\n-\t  gcc_assert (!node->global.inlined_to);\n+\t  gcc_assert (!node->inlined_to);\n \t  reachable.add (node);\n \t  enqueue_node (node, &first, &reachable);\n \t}\n@@ -451,7 +451,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \n \t      /* When inline clone exists, mark body to be preserved so when removing\n \t\t offline copy of the function we don't kill it.  */\n-\t      if (cnode->global.inlined_to)\n+\t      if (cnode->inlined_to)\n \t        body_needed_for_clonning.add (cnode->decl);\n \n \t      /* For non-inline clones, force their origins to the boundary and ensure\n@@ -560,11 +560,11 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n      to turn it into normal cone.  */\n   FOR_EACH_FUNCTION (node)\n     {\n-      if (node->global.inlined_to\n+      if (node->inlined_to\n \t  && !node->callers)\n \t{\n \t  gcc_assert (node->clones);\n-\t  node->global.inlined_to = NULL;\n+\t  node->inlined_to = NULL;\n \t  update_inlined_to_pointer (node, node);\n \t}\n       node->aux = NULL;\n@@ -1212,8 +1212,8 @@ propagate_single_user (varpool_node *vnode, cgraph_node *function,\n       struct cgraph_node *cnode = dyn_cast <cgraph_node *> (ref->referring);\n       if (cnode)\n \t{\n-\t  if (cnode->global.inlined_to)\n-\t    cnode = cnode->global.inlined_to;\n+\t  if (cnode->inlined_to)\n+\t    cnode = cnode->inlined_to;\n \t  if (!function)\n \t    function = cnode;\n \t  else if (function != cnode)"}, {"sha": "b03835a9b8c726d1fbc416f4a00687d986919abd", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -329,7 +329,7 @@ reachable_from_other_partition_p (struct cgraph_node *node, lto_symtab_encoder_t\n   struct cgraph_edge *e;\n   if (!node->definition)\n     return false;\n-  if (node->global.inlined_to)\n+  if (node->inlined_to)\n     return false;\n   for (e = node->callers; e; e = e->next_caller)\n     {\n@@ -399,7 +399,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   boundary_p = !lto_symtab_encoder_in_partition_p (encoder, node);\n \n   if (node->analyzed && (!boundary_p || node->alias\n-\t\t\t || (node->thunk.thunk_p && !node->global.inlined_to)))\n+\t\t\t || (node->thunk.thunk_p && !node->inlined_to)))\n     tag = LTO_symtab_analyzed_node;\n   else\n     tag = LTO_symtab_unavail_node;\n@@ -422,7 +422,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       && node->get_partitioning_class () == SYMBOL_PARTITION)\n     {\n       /* Inline clones cannot be part of boundary.  \n-         gcc_assert (!node->global.inlined_to);  \n+\t gcc_assert (!node->inlined_to);\n \n \t FIXME: At the moment they can be, when partition contains an inline\n \t clone that is clone of inline clone from outside partition.  We can\n@@ -468,9 +468,9 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   if (tag == LTO_symtab_analyzed_node)\n     {\n-      if (node->global.inlined_to)\n+      if (node->inlined_to)\n \t{\n-\t  ref = lto_symtab_encoder_lookup (encoder, node->global.inlined_to);\n+\t  ref = lto_symtab_encoder_lookup (encoder, node->inlined_to);\n \t  gcc_assert (ref != LCC_NOT_FOUND);\n \t}\n       else\n@@ -884,7 +884,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t  if (!lto_symtab_encoder_in_partition_p (encoder, callee))\n \t    {\n \t      /* We should have moved all the inlines.  */\n-\t      gcc_assert (!callee->global.inlined_to);\n+\t      gcc_assert (!callee->inlined_to);\n \t      add_node_to (encoder, callee, false);\n \t    }\n \t}\n@@ -911,7 +911,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t\t\t  && !lto_symtab_encoder_in_partition_p\n \t\t\t       (encoder, callee))\n \t\t\t{\n-\t\t\t  gcc_assert (!callee->global.inlined_to);\n+\t\t\t  gcc_assert (!callee->inlined_to);\n \t\t\t  add_node_to (encoder, callee, false);\n \t\t\t}\n \t\t    }\n@@ -928,7 +928,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n       if (node->alias && node->analyzed)\n \tcreate_references (encoder, node);\n       if (cnode\n-\t  && cnode->thunk.thunk_p && !cnode->global.inlined_to)\n+\t  && cnode->thunk.thunk_p && !cnode->inlined_to)\n \tadd_node_to (encoder, cnode->callees->callee, false);\n       while (node->transparent_alias && node->analyzed)\n \t{\n@@ -984,7 +984,7 @@ output_symtab (void)\n     {\n       node = dyn_cast <cgraph_node *> (lto_symtab_encoder_deref (encoder, i));\n       if (node\n-\t  && ((node->thunk.thunk_p && !node->global.inlined_to)\n+\t  && ((node->thunk.thunk_p && !node->inlined_to)\n \t      || lto_symtab_encoder_in_partition_p (encoder, node)))\n \t{\n \t  output_outgoing_cgraph_edges (node->callees, ob, encoder);\n@@ -1283,7 +1283,7 @@ input_node (struct lto_file_decl_data *file_data,\n   input_overwrite_node (file_data, node, tag, &bp);\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n-  node->global.inlined_to = (cgraph_node *) (intptr_t) ref;\n+  node->inlined_to = (cgraph_node *) (intptr_t) ref;\n \n   if (group)\n     {\n@@ -1542,7 +1542,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n       int ref;\n       if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n \t{\n-\t  ref = (int) (intptr_t) cnode->global.inlined_to;\n+\t  ref = (int) (intptr_t) cnode->inlined_to;\n \n \t  /* We share declaration of builtins, so we may read same node twice.  */\n \t  if (!node->aux)\n@@ -1551,10 +1551,10 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \n \t  /* Fixup inlined_to from reference to pointer.  */\n \t  if (ref != LCC_NOT_FOUND)\n-\t    dyn_cast<cgraph_node *> (node)->global.inlined_to\n+\t    dyn_cast<cgraph_node *> (node)->inlined_to\n \t      = dyn_cast<cgraph_node *> (nodes[ref]);\n \t  else\n-\t    cnode->global.inlined_to = NULL;\n+\t    cnode->inlined_to = NULL;\n \t}\n \n       ref = (int) (intptr_t) node->same_comdat_group;"}, {"sha": "32090359814945e8529f548a9689cfc36281e28c", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -182,7 +182,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n \n       /* Add all thunks associated with the function.  */\n       for (e = cnode->callers; e; e = e->next_caller)\n-\tif (e->caller->thunk.thunk_p && !e->caller->global.inlined_to)\n+\tif (e->caller->thunk.thunk_p && !e->caller->inlined_to)\n \t  add_symbol_to_partition_1 (part, e->caller);\n     }\n \n@@ -233,8 +233,8 @@ contained_in_symbol (symtab_node *node)\n   if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n     {\n       cnode = cnode->function_symbol ();\n-      if (cnode->global.inlined_to)\n-\tcnode = cnode->global.inlined_to;\n+      if (cnode->inlined_to)\n+\tcnode = cnode->inlined_to;\n       return cnode;\n     }\n   else if (varpool_node *vnode = dyn_cast <varpool_node *> (node))"}, {"sha": "2fd5b1e8f49bf56787c2ddd5640f04fa074880b3", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -63,7 +63,7 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n     prevailing_node->forced_by_abi = true;\n   if (node->address_taken)\n     {\n-      gcc_assert (!prevailing_node->global.inlined_to);\n+      gcc_assert (!prevailing_node->inlined_to);\n       prevailing_node->mark_address_taken ();\n     }\n   if (node->definition && prevailing_node->definition\n@@ -910,7 +910,7 @@ lto_symtab_merge_symbols_1 (symtab_node *prevailing)\n       cgraph_node *ce = dyn_cast <cgraph_node *> (e);\n \n       if ((!TREE_PUBLIC (e->decl) && !DECL_EXTERNAL (e->decl))\n-\t  || (ce != NULL && ce->global.inlined_to))\n+\t  || (ce != NULL && ce->inlined_to))\n \tcontinue;\n       symtab_node *to = symtab_node::get (lto_symtab_prevailing_decl (e->decl));\n "}, {"sha": "f4bfcc8b8b8c84a01ab1862d2dbc02ff1f79482a", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -1645,7 +1645,7 @@ expand_simd_clones (struct cgraph_node *node)\n   tree attr = lookup_attribute (\"omp declare simd\",\n \t\t\t\tDECL_ATTRIBUTES (node->decl));\n   if (attr == NULL_TREE\n-      || node->global.inlined_to\n+      || node->inlined_to\n       || lookup_attribute (\"noclone\", DECL_ATTRIBUTES (node->decl)))\n     return;\n "}, {"sha": "d86af115ecb16fcab6bfce070f1f3e4f1d90ce71", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -3033,7 +3033,7 @@ function_called_by_processed_nodes_p (void)\n         continue;\n       if (TREE_ASM_WRITTEN (e->caller->decl))\n         continue;\n-      if (!e->caller->process && !e->caller->global.inlined_to)\n+      if (!e->caller->process && !e->caller->inlined_to)\n       \tbreak;\n     }\n   if (dump_file && e)"}, {"sha": "a75f516831e7fdda46013b82a0cf902ca85635d9", "filename": "gcc/symtab.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -1921,7 +1921,7 @@ symtab_node::get_partitioning_class (void)\n   if (DECL_ABSTRACT_P (decl))\n     return SYMBOL_EXTERNAL;\n \n-  if (cnode && cnode->global.inlined_to)\n+  if (cnode && cnode->inlined_to)\n     return SYMBOL_DUPLICATE;\n \n   /* Transparent aliases are always duplicated.  */\n@@ -2321,7 +2321,7 @@ symtab_node::binds_to_current_def_p (symtab_node *ref)\n     return true;\n \n   /* Inline clones always binds locally.  */\n-  if (cnode && cnode->global.inlined_to)\n+  if (cnode && cnode->inlined_to)\n     return true;\n \n   if (DECL_EXTERNAL (decl))\n@@ -2333,7 +2333,7 @@ symtab_node::binds_to_current_def_p (symtab_node *ref)\n     {\n       cgraph_node *cref = dyn_cast <cgraph_node *> (ref);\n       if (cref)\n-\tref = cref->global.inlined_to;\n+\tref = cref->inlined_to;\n     }\n \n   /* If this is a reference from symbol itself and there are no aliases, we"}, {"sha": "6e7d4dbc5b332b6d1c779cfeb1b687c5d5dac0b6", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62bfab5d2a332925fcf10c45b4c5d8ca499439d/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "patch": "@@ -7959,7 +7959,7 @@ associate_varinfo_to_alias (struct cgraph_node *node, void *data)\n {\n   if ((node->alias\n        || (node->thunk.thunk_p\n-\t   && ! node->global.inlined_to))\n+\t   && ! node->inlined_to))\n       && node->analyzed\n       && !node->ifunc_resolver)\n     insert_vi_for_tree (node->decl, (varinfo_t)data);\n@@ -8129,7 +8129,7 @@ ipa_pta_execute (void)\n       /* Nodes without a body are not interesting.  Especially do not\n          visit clones at this point for now - we get duplicate decls\n \t there for inline clones at least.  */\n-      if (!node->has_gimple_body_p () || node->global.inlined_to)\n+      if (!node->has_gimple_body_p () || node->inlined_to)\n \tcontinue;\n       node->get_body ();\n "}]}