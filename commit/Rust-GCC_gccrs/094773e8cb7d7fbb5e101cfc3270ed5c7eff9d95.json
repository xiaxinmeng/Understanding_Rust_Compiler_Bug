{"sha": "094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk0NzczZThjYjdkN2ZiYjVlMTAxY2ZjMzI3MGVkNWM3ZWZmOWQ5NQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2016-01-24T09:11:50Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2016-01-24T09:11:50Z"}, "message": "re PR fortran/66094 (Handle transpose(A) in inline matmul)\n\n2016-01-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/66094\n\t* frontend-passes.c (enum matrix_case):  Add case A2B2T for\n\tMATMUL(A,TRANSPoSE(B)) where A and B are rank 2.\n\t(inline_limit_check):  Also add A2B2T.\n\t(matmul_lhs_realloc):  Handle A2B2T.\n\t(check_conjg_variable):  Rename to\n\t(check_conjg_transpose_variable):  and also count TRANSPOSE.\n\t(inline_matmul_assign):  Handle A2B2T.\n\n2016-01-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/66094\n\t* gfortran.dg/inline_matmul_13.f90:  New test.\n\t* gfortran.dg/matmul_bounds_8.f90:  New test.\n\t* gfortran.dg/matmul_bounds_9.f90:  New test.\n\t* gfortran.dg/matmul_bounds_10.f90:  New test.\n\nFrom-SVN: r232774", "tree": {"sha": "c22ce9dc659223cd1845e0b31b222fe1bb67fcc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c22ce9dc659223cd1845e0b31b222fe1bb67fcc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/comments", "author": null, "committer": null, "parents": [{"sha": "d13cd3a614b2b074a2895c15171a6cf842e13a10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d13cd3a614b2b074a2895c15171a6cf842e13a10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d13cd3a614b2b074a2895c15171a6cf842e13a10"}], "stats": {"total": 237, "additions": 227, "deletions": 10}, "files": [{"sha": "275acaff20b1c85301bb442481f61e350f165c8a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95", "patch": "@@ -1,3 +1,14 @@\n+2016-01-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/66094\n+\t* frontend-passes.c (enum matrix_case):  Add case A2B2T for\n+\tMATMUL(A,TRANSPoSE(B)) where A and B are rank 2.\n+\t(inline_limit_check):  Also add A2B2T.\n+\t(matmul_lhs_realloc):  Handle A2B2T.\n+\t(check_conjg_variable):  Rename to\n+\t(check_conjg_transpose_variable):  and also count TRANSPOSE.\n+\t(inline_matmul_assign):  Handle A2B2T.\n+\n 2016-01-21  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/65996"}, {"sha": "340fd6ea578d22dc2df3e71c831b406c56a594a7", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 106, "deletions": 10, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95", "patch": "@@ -106,7 +106,7 @@ static int var_num = 1;\n \n /* What sort of matrix we are dealing with when inlining MATMUL.  */\n \n-enum matrix_case { none=0, A2B2, A2B1, A1B2 };\n+enum matrix_case { none=0, A2B2, A2B1, A1B2, A2B2T };\n \n /* Keep track of the number of expressions we have inserted so far \n    using create_var.  */\n@@ -2080,7 +2080,7 @@ inline_limit_check (gfc_expr *a, gfc_expr *b, enum matrix_case m_case)\n   gfc_typespec ts;\n   gfc_expr *cond;\n \n-  gcc_assert (m_case == A2B2);\n+  gcc_assert (m_case == A2B2 || m_case == A2B2T);\n \n   /* Calculation is done in real to avoid integer overflow.  */\n \n@@ -2240,6 +2240,18 @@ matmul_lhs_realloc (gfc_expr *c, gfc_expr *a, gfc_expr *b,\n       cond = build_logical_expr (INTRINSIC_OR, ne1, ne2);\n       break;\n \n+    case A2B2T:\n+      ar->start[0] = get_array_inq_function (GFC_ISYM_SIZE, a, 1);\n+      ar->start[1] = get_array_inq_function (GFC_ISYM_SIZE, b, 1);\n+\n+      ne1 = build_logical_expr (INTRINSIC_NE,\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, c, 1),\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, a, 1));\n+      ne2 = build_logical_expr (INTRINSIC_NE,\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, c, 2),\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, b, 1));\n+      cond = build_logical_expr (INTRINSIC_OR, ne1, ne2);\n+\n     case A2B1:\n       ar->start[0] = get_array_inq_function (GFC_ISYM_SIZE, a, 1);\n       cond = build_logical_expr (INTRINSIC_NE,\n@@ -2708,16 +2720,17 @@ has_dimen_vector_ref (gfc_expr *e)\n \n /* If handed an expression of the form\n \n-   CONJG(A)\n+   TRANSPOSE(CONJG(A))\n \n    check if A can be handled by matmul and return if there is an uneven number\n    of CONJG calls.  Return a pointer to the array when everything is OK, NULL\n    otherwise. The caller has to check for the correct rank.  */\n \n static gfc_expr*\n-check_conjg_variable (gfc_expr *e, bool *conjg)\n+check_conjg_transpose_variable (gfc_expr *e, bool *conjg, bool *transpose)\n {\n   *conjg = false;\n+  *transpose = false;\n \n   do\n     {\n@@ -2733,6 +2746,8 @@ check_conjg_variable (gfc_expr *e, bool *conjg)\n \n \t  if (e->value.function.isym->id == GFC_ISYM_CONJG)\n \t    *conjg = !*conjg;\n+\t  else if (e->value.function.isym->id == GFC_ISYM_TRANSPOSE)\n+\t    *transpose = !*transpose;\n \t  else return NULL;\n \t}\n       else\n@@ -2789,7 +2804,7 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n   int i;\n   gfc_code *if_limit = NULL;\n   gfc_code **next_code_point;\n-  bool conjg_a, conjg_b;\n+  bool conjg_a, conjg_b, transpose_a, transpose_b;\n \n   if (co->op != EXEC_ASSIGN)\n     return 0;\n@@ -2809,12 +2824,12 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n   changed_statement = NULL;\n \n   a = expr2->value.function.actual;\n-  matrix_a = check_conjg_variable (a->expr, &conjg_a);\n-  if (matrix_a == NULL)\n+  matrix_a = check_conjg_transpose_variable (a->expr, &conjg_a, &transpose_a);\n+  if (transpose_a || matrix_a == NULL)\n     return 0;\n \n   b = a->next;\n-  matrix_b = check_conjg_variable (b->expr, &conjg_b);\n+  matrix_b = check_conjg_transpose_variable (b->expr, &conjg_b, &transpose_b);\n   if (matrix_b == NULL)\n     return 0;\n \n@@ -2828,10 +2843,28 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n     return 0;\n \n   if (matrix_a->rank == 2)\n-    m_case = matrix_b->rank == 1 ? A2B1 : A2B2;\n+    {\n+      if (matrix_b->rank == 1)\n+\tm_case = A2B1;\n+      else\n+\t{\n+\t  if (transpose_b)\n+\t    m_case = A2B2T;\n+\t  else\n+\t    m_case = A2B2;\n+\t}\n+    }\n   else\n-    m_case = A1B2;\n+    {\n+      /* Vector * Transpose(B) not handled yet.  */\n+      if (transpose_b)\n+\tm_case = none;\n+      else\n+\tm_case = A1B2;\n+    }\n \n+  if (m_case == none)\n+    return 0;\n \n   ns = insert_block ();\n \n@@ -3002,6 +3035,36 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n \t  *next_code_point = test;\n \t  next_code_point = &test->next;\n \t}\n+\n+      if (m_case == A2B2T)\n+\t{\n+\t  c1 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 1);\n+\t  a1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 1);\n+\t  test = runtime_error_ne (c1, a1, \"Incorrect extent in return array in \"\n+\t\t\t\t   \"MATMUL intrinsic for dimension 1: \"\n+\t\t\t\t   \"is %ld, should be %ld\");\n+\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t  c2 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 2);\n+\t  b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n+\t  test = runtime_error_ne (c2, b1, \"Incorrect extent in return array in \"\n+\t\t\t\t   \"MATMUL intrinsic for dimension 2: \"\n+\t\t\t\t   \"is %ld, should be %ld\");\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t  a2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 2);\n+\t  b2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 2);\n+\n+\t  test = runtime_error_ne (b2, a2, \"Incorrect extent in argument B in \"\n+\t\t\t\t   \"MATMUL intrnisic for dimension 2: \"\n+\t\t\t\t   \"is %ld, should be %ld\");\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t}\n     }\n \n   *next_code_point = assign_zero;\n@@ -3050,6 +3113,39 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n \n       break;\n \n+    case A2B2T:\n+      inline_limit_check (matrix_a, matrix_b, m_case);\n+\n+      u1 = get_size_m1 (matrix_b, 1);\n+      u2 = get_size_m1 (matrix_a, 2);\n+      u3 = get_size_m1 (matrix_a, 1);\n+\n+      do_1 = create_do_loop (gfc_copy_expr (zero), u1, NULL, &co->loc, ns);\n+      do_2 = create_do_loop (gfc_copy_expr (zero), u2, NULL, &co->loc, ns);\n+      do_3 = create_do_loop (gfc_copy_expr (zero), u3, NULL, &co->loc, ns);\n+\n+      do_1->block->next = do_2;\n+      do_2->block->next = do_3;\n+      do_3->block->next = assign_matmul;\n+\n+      var_1 = do_1->ext.iterator->var;\n+      var_2 = do_2->ext.iterator->var;\n+      var_3 = do_3->ext.iterator->var;\n+\n+      list[0] = var_3;\n+      list[1] = var_1;\n+      cscalar = scalarized_expr (co->expr1, list, 2);\n+\n+      list[0] = var_3;\n+      list[1] = var_2;\n+      ascalar = scalarized_expr (matrix_a, list, 2);\n+\n+      list[0] = var_1;\n+      list[1] = var_2;\n+      bscalar = scalarized_expr (matrix_b, list, 2);\n+\n+      break;\n+\n     case A2B1:\n       u1 = get_size_m1 (matrix_b, 1);\n       u2 = get_size_m1 (matrix_a, 1);"}, {"sha": "60d9412fc02c670094b34e8d8825a2219317b348", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95", "patch": "@@ -1,3 +1,11 @@\n+2016-01-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/66094\n+\t* gfortran.dg/inline_matmul_13.f90:  New test.\n+\t* gfortran.dg/matmul_bounds_8.f90:  New test.\n+\t* gfortran.dg/matmul_bounds_9.f90:  New test.\n+\t* gfortran.dg/matmul_bounds_10.f90:  New test.\n+\n 2016-01-23  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/69426"}, {"sha": "e887ee982febb94c2e48be218f40c53d5a63dc1a", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_13.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_13.f90?ref=094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+! { dg-options \"-ffrontend-optimize -fdump-tree-original -Wrealloc-lhs\" }\n+! PR 66094: Check functionality for MATMUL(A, TRANSPSE(B))\n+module x\n+contains\n+  subroutine mm1(a,b,c)\n+    real, dimension(:,:), intent(in) :: a, b\n+    real, dimension(:,:), intent(out) :: c\n+    c = -42.\n+    c = matmul(a, transpose(b))\n+  end subroutine mm1\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer, parameter :: n = 3, m=4, cnt=2\n+  real, dimension(n,cnt) :: a\n+  real, dimension(m,cnt) :: b\n+  real, dimension(n,m) :: c, cres\n+  real, dimension(:,:), allocatable :: calloc\n+\n+  data a / 2., -3., 5., -7., 11., -13./\n+  data b /17., -23., 29., -31., 37., -39., 41., -47./\n+  data cres / -225., 356., -396., 227., -360., 392., &\n+       -229., 364., -388., 267., -424., 456./ \n+\n+  c = matmul(a,transpose(b))\n+  if (sum(c-cres)>1e-4) call abort\n+  call mm1 (a, b, c)\n+  if (sum(c-cres)>1e-4) call abort\n+\n+  ! Unallocated\n+  calloc = matmul(a,transpose(b)) ! { dg-warning \"Code for reallocating the allocatable array\" }\n+  if (any(shape(c) /= shape(calloc))) call abort\n+  if (sum(calloc-cres)>1e-4) call abort\n+  deallocate(calloc)\n+\n+  ! Allocated to wrong shape\n+  allocate (calloc(10,10))\n+  calloc = matmul(a,transpose(b)) ! { dg-warning \"Code for reallocating the allocatable array\" }\n+  if (any(shape(c) /= shape(calloc))) call abort\n+  if (sum(calloc-cres)>1e-4) call abort\n+  deallocate(calloc)\n+\n+end program main\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"original\" } }"}, {"sha": "6608b49dae9b1b483a4af27d5ee356b10896dca6", "filename": "gcc/testsuite/gfortran.dg/matmul_bounds_10.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_10.f90?ref=094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fno-backtrace -fbounds-check -fno-realloc-lhs\" }\n+! { dg-shouldfail \"Fortran runtime error: Incorrect extent in return array in MATMUL intrinsic for dimension 1: is 4, should be 3\" }\n+program main\n+  real, dimension(3,2) :: a\n+  real, dimension(3,2) :: b\n+  real, dimension(:,:), allocatable :: ret\n+  allocate (ret(3,3))\n+  a = 1.0\n+  b = 2.3\n+  ret = matmul(a,transpose(b))  ! This is OK\n+  deallocate(ret)\n+  allocate(ret(4,3))\n+  ret = matmul(a,transpose(b))  ! This should throw an error.\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in return array in MATMUL intrinsic for dimension 1: is 4, should be 3\" }"}, {"sha": "2764cf38adfbf1413044fd7253727f768dfea4fe", "filename": "gcc/testsuite/gfortran.dg/matmul_bounds_8.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_8.f90?ref=094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fno-backtrace -fbounds-check -fno-realloc-lhs\" }\n+! { dg-shouldfail \"Fortran runtime error: Incorrect extent in return array in MATMUL intrinsic for dimension 2: is 2, should be 3\" }\n+program main\n+  real, dimension(3,2) :: a\n+  real, dimension(3,2) :: b\n+  real, dimension(:,:), allocatable :: ret\n+  allocate (ret(3,3))\n+  a = 1.0\n+  b = 2.3\n+  ret = matmul(a,transpose(b))  ! This is OK\n+  deallocate(ret)\n+  allocate(ret(3,2))\n+  ret = matmul(a,transpose(b))  ! This should throw an error.\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in return array in MATMUL intrinsic for dimension 2: is 2, should be 3\" }"}, {"sha": "5552e40657d09c903c6987ad0efb26d4cdc94a01", "filename": "gcc/testsuite/gfortran.dg/matmul_bounds_9.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_9.f90?ref=094773e8cb7d7fbb5e101cfc3270ed5c7eff9d95", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check -ffrontend-optimize\" }\n+! { dg-shouldfail \"Fortran runtime error: Incorrect extent in argument B in MATMUL intrnisic for dimension 2: is 1, should be 2\" }\n+module x\n+  implicit none\n+contains\n+  subroutine mmul(c, a, b)\n+    real, dimension(:,:), intent(in) :: a,b\n+    real, dimension(:,:), intent(out) :: c\n+    c = matmul(a,transpose(b))\n+  end subroutine mmul\n+end module x\n+\n+program main\n+  use x\n+  integer, parameter :: n = 3, m=4, cnt=2\n+  real, dimension(n,cnt) :: a\n+  real, dimension(m,cnt-1) :: b\n+  real, dimension(n,m) :: c\n+  a = 1.0\n+  b = 2.3\n+  call mmul(c,a,b)\n+end program main"}]}