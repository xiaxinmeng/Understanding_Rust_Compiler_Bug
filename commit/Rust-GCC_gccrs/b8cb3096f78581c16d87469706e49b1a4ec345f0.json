{"sha": "b8cb3096f78581c16d87469706e49b1a4ec345f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhjYjMwOTZmNzg1ODFjMTZkODc0Njk3MDZlNDliMWE0ZWMzNDVmMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-11-27T08:48:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-27T08:48:56Z"}, "message": "re PR debug/81307 (g++.dg/debug/debug9.C -gstabs FAILs)\n\n\tPR debug/81307\n\t* dbxout.c (lastlineno): New variable.\n\t(dbx_debug_hooks): Use dbxout_switch_text_section as\n\tswitch_text_section debug hook.\n\t(dbxout_function_end): Switch to current_function_section\n\trather than function_section.  If crtl->has_bb_partition,\n\toutput just one N_FUN, depending on in_cold_section_p.\n\t(dbxout_source_line): Remember last lineno in lastlineno.\n\t(dbxout_switch_text_section): New function.\n\t(dbxout_function_decl): Adjust dbxout_block caller.\n\t(dbx_block_with_cold_children): New function.\n\t(dbxout_block): Return true if any LBRAC/RBRAC have been\n\temitted.  Use dbx_block_with_cold_children at depth == 0\n\tin second partition.  Add PARENT_BLOCKNUM argument, pass\n\tit optionally adjusted to children.  Output LBRAC/RBRAC\n\taround recursive call only if the block is in the current\n\tpartition, if not and anything was output, emit empty\n\trange LBRAC/RBRAC.\n\t* final.c (final_scan_insn): Compute cold_function_name\n\tbefore calling switch_text_section debug hook.  Call\n\tthat hook even if dwarf2out_do_frame if not emitting\n\tdwarf debug info.\n\n\t* g++.dg/debug/debug9.C: Remove -fno-reorder-blocks-and-partition\n\tworkaround.\n\nFrom-SVN: r255161", "tree": {"sha": "e81f0e0046a42d208b6c8cc59980e1aafa2275bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e81f0e0046a42d208b6c8cc59980e1aafa2275bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8cb3096f78581c16d87469706e49b1a4ec345f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8cb3096f78581c16d87469706e49b1a4ec345f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8cb3096f78581c16d87469706e49b1a4ec345f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8cb3096f78581c16d87469706e49b1a4ec345f0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9adeb64ab940db8fe484e6344dc28ec86f1a83bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9adeb64ab940db8fe484e6344dc28ec86f1a83bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9adeb64ab940db8fe484e6344dc28ec86f1a83bc"}], "stats": {"total": 195, "additions": 170, "deletions": 25}, "files": [{"sha": "75a860e3f814493e8776167327105bc63e70d9d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8cb3096f78581c16d87469706e49b1a4ec345f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8cb3096f78581c16d87469706e49b1a4ec345f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8cb3096f78581c16d87469706e49b1a4ec345f0", "patch": "@@ -1,5 +1,28 @@\n 2017-11-27  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR debug/81307\n+\t* dbxout.c (lastlineno): New variable.\n+\t(dbx_debug_hooks): Use dbxout_switch_text_section as\n+\tswitch_text_section debug hook.\n+\t(dbxout_function_end): Switch to current_function_section\n+\trather than function_section.  If crtl->has_bb_partition,\n+\toutput just one N_FUN, depending on in_cold_section_p.\n+\t(dbxout_source_line): Remember last lineno in lastlineno.\n+\t(dbxout_switch_text_section): New function.\n+\t(dbxout_function_decl): Adjust dbxout_block caller.\n+\t(dbx_block_with_cold_children): New function.\n+\t(dbxout_block): Return true if any LBRAC/RBRAC have been\n+\temitted.  Use dbx_block_with_cold_children at depth == 0\n+\tin second partition.  Add PARENT_BLOCKNUM argument, pass\n+\tit optionally adjusted to children.  Output LBRAC/RBRAC\n+\taround recursive call only if the block is in the current\n+\tpartition, if not and anything was output, emit empty\n+\trange LBRAC/RBRAC.\n+\t* final.c (final_scan_insn): Compute cold_function_name\n+\tbefore calling switch_text_section debug hook.  Call\n+\tthat hook even if dwarf2out_do_frame if not emitting\n+\tdwarf debug info.\n+\n \tPR target/83100\n \t* varasm.c (bss_initializer_p): Return true for DECL_COMMON\n \tTREE_READONLY decls."}, {"sha": "89f2d1f0cd4ace29e8c882acd2d320c7bc3f14dd", "filename": "gcc/dbxout.c", "status": "modified", "additions": 133, "deletions": 17, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8cb3096f78581c16d87469706e49b1a4ec345f0/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8cb3096f78581c16d87469706e49b1a4ec345f0/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=b8cb3096f78581c16d87469706e49b1a4ec345f0", "patch": "@@ -244,6 +244,10 @@ static GTY(()) int source_label_number = 1;\n \n static GTY(()) const char *lastfile;\n \n+/* Last line number mentioned in a NOTE insn.  */\n+\n+static GTY(()) unsigned int lastlineno;\n+\n /* Used by PCH machinery to detect if 'lastfile' should be reset to\n    base_input_file.  */\n static GTY(()) int lastfile_is_base;\n@@ -334,6 +338,7 @@ static void debug_free_queue (void);\n \n static void dbxout_source_line (unsigned int, unsigned int, const char *,\n \t\t\t\tint, bool);\n+static void dbxout_switch_text_section (void);\n static void dbxout_begin_prologue (unsigned int, unsigned int, const char *);\n static void dbxout_source_file (const char *);\n static void dbxout_function_end (tree);\n@@ -380,7 +385,7 @@ const struct gcc_debug_hooks dbx_debug_hooks =\n   dbxout_handle_pch,\t\t         /* handle_pch */\n   debug_nothing_rtx_insn,\t         /* var_location */\n   debug_nothing_tree,\t\t\t /* size_function */\n-  debug_nothing_void,                    /* switch_text_section */\n+  dbxout_switch_text_section,            /* switch_text_section */\n   debug_nothing_tree_tree,\t\t /* set_name */\n   0,                                     /* start_end_main_source_file */\n   TYPE_SYMTAB_IS_ADDRESS                 /* tree_type_symtab_field */\n@@ -902,7 +907,7 @@ dbxout_function_end (tree decl ATTRIBUTE_UNUSED)\n \n   /* The Lscope label must be emitted even if we aren't doing anything\n      else; dbxout_block needs it.  */\n-  switch_to_section (function_section (current_function_decl));\n+  switch_to_section (current_function_section ());\n \n   /* Convert Lscope into the appropriate format for local labels in case\n      the system doesn't insert underscores in front of user generated\n@@ -923,11 +928,12 @@ dbxout_function_end (tree decl ATTRIBUTE_UNUSED)\n   if (crtl->has_bb_partition)\n     {\n       dbxout_begin_empty_stabs (N_FUN);\n-      dbxout_stab_value_label_diff (crtl->subsections.hot_section_end_label,\n-\t\t\t\t    crtl->subsections.hot_section_label);\n-      dbxout_begin_empty_stabs (N_FUN);\n-      dbxout_stab_value_label_diff (crtl->subsections.cold_section_end_label,\n-\t\t\t\t    crtl->subsections.cold_section_label);\n+      if (in_cold_section_p)\n+\tdbxout_stab_value_label_diff (crtl->subsections.cold_section_end_label,\n+\t\t\t\t      crtl->subsections.cold_section_label);\n+      else\n+\tdbxout_stab_value_label_diff (crtl->subsections.hot_section_end_label,\n+\t\t\t\t      crtl->subsections.hot_section_label);\n     }\n   else\n     {\n@@ -1215,7 +1221,7 @@ dbxout_handle_pch (unsigned at_end)\n \n #if defined (DBX_DEBUGGING_INFO)\n \n-static void dbxout_block (tree, int, tree);\n+static bool dbxout_block (tree, int, tree, int);\n \n /* Output debugging info to FILE to switch to sourcefile FILENAME.  */\n \n@@ -1289,6 +1295,60 @@ dbxout_source_line (unsigned int lineno, unsigned int column ATTRIBUTE_UNUSED,\n   else\n     dbxout_stabd (N_SLINE, lineno);\n #endif\n+  lastlineno = lineno;\n+}\n+\n+/* Unfortunately, at least when emitting relative addresses, STABS\n+   has no way to express multiple partitions.  Represent a function\n+   as two functions in this case.  */\n+\n+static void\n+dbxout_switch_text_section (void)\n+{\n+  /* The N_FUN tag at the end of the function is a GNU extension,\n+     which may be undesirable, and is unnecessary if we do not have\n+     named sections.  */\n+  in_cold_section_p = !in_cold_section_p;\n+  switch_to_section (current_function_section ());\n+  dbxout_block (DECL_INITIAL (current_function_decl), 0,\n+\t\tDECL_ARGUMENTS (current_function_decl), -1);\n+  dbxout_function_end (current_function_decl);\n+  in_cold_section_p = !in_cold_section_p;\n+\n+  switch_to_section (current_function_section ());\n+\n+  tree context = decl_function_context (current_function_decl);\n+  extern tree cold_function_name;\n+\n+  dbxout_begin_complex_stabs ();\n+  stabstr_I (cold_function_name);\n+  stabstr_S (\":f\");\n+\n+  tree type = TREE_TYPE (current_function_decl);\n+  if (TREE_TYPE (type))\n+    dbxout_type (TREE_TYPE (type), 0);\n+  else\n+    dbxout_type (void_type_node, 0);\n+\n+  if (context != 0)\n+    {\n+      stabstr_C (',');\n+      stabstr_I (cold_function_name);\n+      stabstr_C (',');\n+      stabstr_I (DECL_NAME (context));\n+    }\n+\n+  dbxout_finish_complex_stabs (current_function_decl, N_FUN, 0,\n+\t\t\t       crtl->subsections.cold_section_label, 0);\n+\n+  /* pre-increment the scope counter */\n+  scope_labelno++;\n+\n+  dbxout_source_line (lastlineno, 0, lastfile, 0, true);\n+  /* Output function begin block at function scope, referenced\n+     by dbxout_block, dbxout_source_line and dbxout_function_end.  */\n+  emit_pending_bincls_if_required ();\n+  targetm.asm_out.internal_label (asm_out_file, \"LFBB\", scope_labelno);\n }\n \n /* Describe the beginning of an internal block within a function.  */\n@@ -1322,7 +1382,7 @@ dbxout_function_decl (tree decl)\n #ifndef DBX_FUNCTION_FIRST\n   dbxout_begin_function (decl);\n #endif\n-  dbxout_block (DECL_INITIAL (decl), 0, DECL_ARGUMENTS (decl));\n+  dbxout_block (DECL_INITIAL (decl), 0, DECL_ARGUMENTS (decl), -1);\n   dbxout_function_end (decl);\n }\n \n@@ -3664,6 +3724,26 @@ dbx_output_rbrac (const char *label,\n     dbxout_stab_value_label (label);\n }\n \n+/* Return true is at least one block among BLOCK, its children or siblings\n+   which has TREE_USED, TREE_ASM_WRITTEN and BLOCK_IN_COLD_SECTION_P\n+   set.  If there is none, clear TREE_USED bit on such blocks.  */\n+\n+static bool\n+dbx_block_with_cold_children (tree block)\n+{\n+  bool ret = false;\n+  for (; block; block = BLOCK_CHAIN (block))\n+    if (TREE_USED (block) && TREE_ASM_WRITTEN (block))\n+      {\n+\tbool children = dbx_block_with_cold_children (BLOCK_SUBBLOCKS (block));\n+\tif (BLOCK_IN_COLD_SECTION_P (block) || children)\n+\t  ret = true;\n+\telse\n+\t  TREE_USED (block) = false;\n+      }\n+  return ret;\n+}\n+\n /* Output everything about a symbol block (a BLOCK node\n    that represents a scope level),\n    including recursive output of contained blocks.\n@@ -3679,22 +3759,31 @@ dbx_output_rbrac (const char *label,\n    except for the outermost block.\n \n    Actually, BLOCK may be several blocks chained together.\n-   We handle them all in sequence.  */\n+   We handle them all in sequence.\n \n-static void\n-dbxout_block (tree block, int depth, tree args)\n+   Return true if we emitted any LBRAC/RBRAC.  */\n+\n+static bool\n+dbxout_block (tree block, int depth, tree args, int parent_blocknum)\n {\n+  bool ret = false;\n   char begin_label[20];\n   /* Reference current function start using LFBB.  */\n   ASM_GENERATE_INTERNAL_LABEL (begin_label, \"LFBB\", scope_labelno);\n \n-  while (block)\n+  /* If called for the second partition, ignore blocks that don't have\n+     any children in the second partition.  */\n+  if (crtl->has_bb_partition && in_cold_section_p && depth == 0)\n+    dbx_block_with_cold_children (block);\n+\n+  for (; block; block = BLOCK_CHAIN (block))\n     {\n       /* Ignore blocks never expanded or otherwise marked as real.  */\n       if (TREE_USED (block) && TREE_ASM_WRITTEN (block))\n \t{\n \t  int did_output;\n \t  int blocknum = BLOCK_NUMBER (block);\n+\t  int this_parent = parent_blocknum;\n \n \t  /* In dbx format, the syms of a block come before the N_LBRAC.\n \t     If nothing is output, we don't need the N_LBRAC, either.  */\n@@ -3708,11 +3797,13 @@ dbxout_block (tree block, int depth, tree args)\n \t     the block.  Use the block's tree-walk order to generate\n \t     the assembler symbols LBBn and LBEn\n \t     that final will define around the code in this block.  */\n-\t  if (did_output)\n+\t  if (did_output\n+\t      && BLOCK_IN_COLD_SECTION_P (block) == in_cold_section_p)\n \t    {\n \t      char buf[20];\n \t      const char *scope_start;\n \n+\t      ret = true;\n \t      if (depth == 0)\n \t\t/* The outermost block doesn't get LBB labels; use\n \t\t   the LFBB local symbol emitted by dbxout_begin_prologue.  */\n@@ -3721,16 +3812,21 @@ dbxout_block (tree block, int depth, tree args)\n \t\t{\n \t\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LBB\", blocknum);\n \t\t  scope_start = buf;\n+\t\t  this_parent = blocknum;\n \t\t}\n \n \t      dbx_output_lbrac (scope_start, begin_label);\n \t    }\n \n \t  /* Output the subblocks.  */\n-\t  dbxout_block (BLOCK_SUBBLOCKS (block), depth + 1, NULL_TREE);\n+\t  bool children\n+\t    = dbxout_block (BLOCK_SUBBLOCKS (block), depth + 1, NULL_TREE,\n+\t\t\t    this_parent);\n+\t  ret |= children;\n \n \t  /* Refer to the marker for the end of the block.  */\n-\t  if (did_output)\n+\t  if (did_output\n+\t      && BLOCK_IN_COLD_SECTION_P (block) == in_cold_section_p)\n \t    {\n \t      char buf[100];\n \t      if (depth == 0)\n@@ -3743,9 +3839,29 @@ dbxout_block (tree block, int depth, tree args)\n \n \t      dbx_output_rbrac (buf, begin_label);\n \t    }\n+\t  else if (did_output && !children)\n+\t    {\n+\t      /* If we emitted any vars and didn't output any LBRAC/RBRAC,\n+\t\t either at this level or any lower level, we need to emit\n+\t\t an empty LBRAC/RBRAC pair now.  */\n+\t      char buf[20];\n+\t      const char *scope_start;\n+\n+\t      ret = true;\n+\t      if (parent_blocknum == -1)\n+\t\tscope_start = begin_label;\n+\t      else\n+\t\t{\n+\t\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LBB\", parent_blocknum);\n+\t\t  scope_start = buf;\n+\t\t}\n+\n+\t      dbx_output_lbrac (scope_start, begin_label);\n+\t      dbx_output_rbrac (scope_start, begin_label);\n+\t    }\n \t}\n-      block = BLOCK_CHAIN (block);\n     }\n+  return ret;\n }\n \n /* Output the information about a function and its arguments and result."}, {"sha": "fdae241bc832246c257677db8f3870b5144f6fdc", "filename": "gcc/final.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8cb3096f78581c16d87469706e49b1a4ec345f0/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8cb3096f78581c16d87469706e49b1a4ec345f0/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=b8cb3096f78581c16d87469706e49b1a4ec345f0", "patch": "@@ -2210,8 +2210,17 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \tcase NOTE_INSN_SWITCH_TEXT_SECTIONS:\n \t  in_cold_section_p = !in_cold_section_p;\n \n+\t  if (in_cold_section_p)\n+\t    cold_function_name\n+\t      = clone_function_name (current_function_decl, \"cold\");\n+\n \t  if (dwarf2out_do_frame ())\n-\t    dwarf2out_switch_text_section ();\n+\t    {\n+\t      dwarf2out_switch_text_section ();\n+\t      if (!dwarf2_debug_info_emitted_p (current_function_decl)\n+\t\t  && !DECL_IGNORED_P (current_function_decl))\n+\t\tdebug_hooks->switch_text_section ();\n+\t    }\n \t  else if (!DECL_IGNORED_P (current_function_decl))\n \t    debug_hooks->switch_text_section ();\n \n@@ -2223,8 +2232,6 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t     suffixing \"cold\" to the original function's name.  */\n \t  if (in_cold_section_p)\n \t    {\n-\t      cold_function_name\n-\t\t= clone_function_name (current_function_decl, \"cold\");\n #ifdef ASM_DECLARE_COLD_FUNCTION_NAME\n \t      ASM_DECLARE_COLD_FUNCTION_NAME (asm_out_file,\n \t\t\t\t\t      IDENTIFIER_POINTER"}, {"sha": "87e930a3a0a133bbd40fced1f8769014ded6f707", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8cb3096f78581c16d87469706e49b1a4ec345f0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8cb3096f78581c16d87469706e49b1a4ec345f0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b8cb3096f78581c16d87469706e49b1a4ec345f0", "patch": "@@ -1,5 +1,9 @@\n 2017-11-27  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR debug/81307\n+\t* g++.dg/debug/debug9.C: Remove -fno-reorder-blocks-and-partition\n+\tworkaround.\n+\n \tPR target/83100\n \t* gcc.dg/pr83100-1.c: New test.\n \t* gcc.dg/pr83100-2.c: New test."}, {"sha": "aa328ee6f79abe7ead17bd06fb1a793f91d68aeb", "filename": "gcc/testsuite/g++.dg/debug/debug9.C", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8cb3096f78581c16d87469706e49b1a4ec345f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdebug9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8cb3096f78581c16d87469706e49b1a4ec345f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdebug9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdebug9.C?ref=b8cb3096f78581c16d87469706e49b1a4ec345f0", "patch": "@@ -1,9 +1,4 @@\n /* { dg-do assemble } */\n-/* Partitioning causes hot/cold section emission and breaks stabs\n-   debugging.  */\n-/* { dg-additional-options \"-fno-reorder-blocks-and-partition\" } */\n-\n-\n /* This testcase requires entries in the debug_range section in DWARF which\n    refer to a vague linkage function.  */\n "}]}