{"sha": "9415fcdad101c8c47f777345595d2306344cd9a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQxNWZjZGFkMTAxYzhjNDdmNzc3MzQ1NTk1ZDIzMDYzNDRjZDlhMQ==", "commit": {"author": {"name": "Raphael Amiard", "email": "amiard@adacore.com", "date": "2019-09-19T08:13:10Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-09-19T08:13:10Z"}, "message": "[Ada] Propagate documentation to formal bounded sets\n\n2019-09-19  Raphael Amiard  <amiard@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/a-cfhase.ads (Set): Add comments to public primitives.\n\nFrom-SVN: r275937", "tree": {"sha": "2addc1fa5e024324e774caa2ecd6280689e91208", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2addc1fa5e024324e774caa2ecd6280689e91208"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9415fcdad101c8c47f777345595d2306344cd9a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9415fcdad101c8c47f777345595d2306344cd9a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9415fcdad101c8c47f777345595d2306344cd9a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9415fcdad101c8c47f777345595d2306344cd9a1/comments", "author": {"login": "raph-amiard", "id": 478727, "node_id": "MDQ6VXNlcjQ3ODcyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/478727?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raph-amiard", "html_url": "https://github.com/raph-amiard", "followers_url": "https://api.github.com/users/raph-amiard/followers", "following_url": "https://api.github.com/users/raph-amiard/following{/other_user}", "gists_url": "https://api.github.com/users/raph-amiard/gists{/gist_id}", "starred_url": "https://api.github.com/users/raph-amiard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raph-amiard/subscriptions", "organizations_url": "https://api.github.com/users/raph-amiard/orgs", "repos_url": "https://api.github.com/users/raph-amiard/repos", "events_url": "https://api.github.com/users/raph-amiard/events{/privacy}", "received_events_url": "https://api.github.com/users/raph-amiard/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3aacb9ed526c68e49424ec4dc4833de8353d2a7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aacb9ed526c68e49424ec4dc4833de8353d2a7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aacb9ed526c68e49424ec4dc4833de8353d2a7c"}], "stats": {"total": 143, "additions": 143, "deletions": 0}, "files": [{"sha": "2e30229966002cfea25837fa5dfdc4fd75e18599", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415fcdad101c8c47f777345595d2306344cd9a1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415fcdad101c8c47f777345595d2306344cd9a1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9415fcdad101c8c47f777345595d2306344cd9a1", "patch": "@@ -1,3 +1,7 @@\n+2019-09-19  Raphael Amiard  <amiard@adacore.com>\n+\n+\t* libgnat/a-cfhase.ads (Set): Add comments to public primitives.\n+\n 2019-09-19  Raphael Amiard  <amiard@adacore.com>\n \n \t* libgnat/a-cbhama.ads, libgnat/a-cbhase.ads,"}, {"sha": "3e72aef0d6cc3ea0c4c0d8735b14284b7107f54b", "filename": "gcc/ada/libgnat/a-cfhase.ads", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415fcdad101c8c47f777345595d2306344cd9a1/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415fcdad101c8c47f777345595d2306344cd9a1/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads?ref=9415fcdad101c8c47f777345595d2306344cd9a1", "patch": "@@ -355,21 +355,39 @@ is\n          \"=\"'Result =\n            (E_Elements_Included (Elements (Left), Elements (Right))\n              and E_Elements_Included (Elements (Right), Elements (Left)));\n+   --  For each element in Left, set equality attempts to find the equal\n+   --  element in Right; if a search fails, then set equality immediately\n+   --  returns False. The search works by calling Hash to find the bucket in\n+   --  the Right set that corresponds to the Left element. If the bucket is\n+   --  non-empty, the search calls the generic formal element equality operator\n+   --  to compare the element (in Left) to the element of each node in the\n+   --  bucket (in Right); the search terminates when a matching node in the\n+   --  bucket is found, or the nodes in the bucket are exhausted. (Note that\n+   --  element equality is called here, not Equivalent_Elements. Set equality\n+   --  is the only operation in which element equality is used. Compare set\n+   --  equality to Equivalent_Sets, which does call Equivalent_Elements.)\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean with\n      Global => null,\n      Post   => Equivalent_Sets'Result = (Model (Left) = Model (Right));\n+   --  Similar to set equality, with the difference that the element in Left is\n+   --  compared to the elements in Right using the generic formal\n+   --  Equivalent_Elements operation instead of element equality.\n \n    function To_Set (New_Item : Element_Type) return Set with\n      Global => null,\n      Post   =>\n        M.Is_Singleton (Model (To_Set'Result), New_Item)\n          and Length (To_Set'Result) = 1\n          and E.Get (Elements (To_Set'Result), 1) = New_Item;\n+   --  Constructs a singleton set comprising New_Element. To_Set calls Hash to\n+   --  determine the bucket for New_Item.\n \n    function Capacity (Container : Set) return Count_Type with\n      Global => null,\n      Post   => Capacity'Result = Container.Capacity;\n+   --  Returns the current capacity of the set. Capacity is the maximum length\n+   --  before which rehashing in guaranteed not to occur.\n \n    procedure Reserve_Capacity\n      (Container : in out Set;\n@@ -387,14 +405,21 @@ is\n               (Elements (Container), Elements (Container)'Old)\n          and E_Elements_Included\n               (Elements (Container)'Old, Elements (Container));\n+   --  If the value of the Capacity actual parameter is less or equal to\n+   --  Container.Capacity, then the operation has no effect.  Otherwise it\n+   --  raises Capacity_Error (as no expansion of capacity is possible for a\n+   --  bounded form).\n \n    function Is_Empty (Container : Set) return Boolean with\n      Global => null,\n      Post   => Is_Empty'Result = (Length (Container) = 0);\n+   --  Equivalent to Length (Container) = 0\n \n    procedure Clear (Container : in out Set) with\n      Global => null,\n      Post   => Length (Container) = 0 and M.Is_Empty (Model (Container));\n+   --  Removes all of the items from the set. This will deallocate all memory\n+   --  associated with this set.\n \n    procedure Assign (Target : in out Set; Source : Set) with\n      Global => null,\n@@ -407,6 +432,10 @@ is\n \n          and E_Elements_Included (Elements (Target), Elements (Source))\n          and E_Elements_Included (Elements (Source), Elements (Target));\n+   --  If Target denotes the same object as Source, then the operation has no\n+   --  effect. If the Target capacity is less than the Source length, then\n+   --  Assign raises Capacity_Error.  Otherwise, Assign clears Target and then\n+   --  copies the (active) elements from Source to Target.\n \n    function Copy\n      (Source   : Set;\n@@ -422,6 +451,14 @@ is\n                  Copy'Result.Capacity = Source.Capacity\n               else\n                  Copy'Result.Capacity = Capacity);\n+   --  Constructs a new set object whose elements correspond to Source.  If the\n+   --  Capacity parameter is 0, then the capacity of the result is the same as\n+   --  the length of Source. If the Capacity parameter is equal or greater than\n+   --  the length of Source, then the capacity of the result is the specified\n+   --  value. Otherwise, Copy raises Capacity_Error. If the Modulus parameter\n+   --  is 0, then the modulus of the result is the value returned by a call to\n+   --  Default_Modulus with the capacity parameter determined as above;\n+   --  otherwise the modulus of the result is the specified value.\n \n    function Element\n      (Container : Set;\n@@ -485,6 +522,8 @@ is\n \n          and E_Elements_Included (Elements (Target), Elements (Source)'Old)\n          and E_Elements_Included (Elements (Source)'Old, Elements (Target));\n+   --  Clears Target (if it's not empty), and then moves (not copies) the\n+   --  buckets array and nodes from Source to Target.\n \n    procedure Insert\n      (Container : in out Set;\n@@ -541,6 +580,18 @@ is\n                   (Positions (Container),\n                    Positions (Container)'Old,\n                    Position));\n+   --  Conditionally inserts New_Item into the set. If New_Item is already in\n+   --  the set, then Inserted returns False and Position designates the node\n+   --  containing the existing element (which is not modified). If New_Item is\n+   --  not already in the set, then Inserted returns True and Position\n+   --  designates the newly-inserted node containing New_Item. The search for\n+   --  an existing element works as follows. Hash is called to determine\n+   --  New_Item's bucket; if the bucket is non-empty, then Equivalent_Elements\n+   --  is called to compare New_Item to the element of each node in that\n+   --  bucket. If the bucket is empty, or there were no equivalent elements in\n+   --  the bucket, the search \"fails\" and the New_Item is inserted in the set\n+   --  (and Inserted returns True); otherwise, the search \"succeeds\" (and\n+   --  Inserted returns False).\n \n    procedure Insert  (Container : in out Set; New_Item : Element_Type) with\n      Global => null,\n@@ -570,6 +621,13 @@ is\n                (Positions (Container),\n                 Positions (Container)'Old,\n                 Find (Container, New_Item));\n+   --  Attempts to insert New_Item into the set, performing the usual insertion\n+   --  search (which involves calling both Hash and Equivalent_Elements); if\n+   --  the search succeeds (New_Item is equivalent to an element already in the\n+   --  set, and so was not inserted), then this operation raises\n+   --  Constraint_Error. (This version of Insert is similar to Replace, but\n+   --  having the opposite exception behavior. It is intended for use when you\n+   --  want to assert that the item is not already in the set.)\n \n    procedure Include (Container : in out Set; New_Item : Element_Type) with\n      Global         => null,\n@@ -625,6 +683,13 @@ is\n                   (Positions (Container),\n                    Positions (Container)'Old,\n                    Find (Container, New_Item)));\n+   --  Attempts to insert New_Item into the set. If an element equivalent to\n+   --  New_Item is already in the set (the insertion search succeeded, and\n+   --  hence New_Item was not inserted), then the value of New_Item is assigned\n+   --  to the existing element. (This insertion operation only raises an\n+   --  exception if cursor tampering occurs. It is intended for use when you\n+   --  want to insert the item in the set, and you don't care whether an\n+   --  equivalent element is already present.)\n \n    procedure Replace (Container : in out Set; New_Item : Element_Type) with\n      Global => null,\n@@ -648,6 +713,12 @@ is\n                (Elements (Container)'Old,\n                 Elements (Container),\n                 P.Get (Positions (Container), Find (Container, New_Item)));\n+   --  Searches for New_Item in the set; if the search fails (because an\n+   --  equivalent element was not in the set), then it raises\n+   --  Constraint_Error. Otherwise, the existing element is assigned the value\n+   --  New_Item. (This is similar to Insert, but with the opposite exception\n+   --  behavior. It is intended for use when you want to assert that the item\n+   --  is already in the set.)\n \n    procedure Exclude (Container : in out Set; Item : Element_Type) with\n      Global         => null,\n@@ -685,6 +756,13 @@ is\n                   (Positions (Container)'Old,\n                    Positions (Container),\n                    Find (Container, Item)'Old));\n+   --  Searches for Item in the set, and if found, removes its node from the\n+   --  set and then deallocates it. The search works as follows. The operation\n+   --  calls Hash to determine the item's bucket; if the bucket is not empty,\n+   --  it calls Equivalent_Elements to compare Item to the element of each node\n+   --  in the bucket. (This is the deletion analog of Include. It is intended\n+   --  for use when you want to remove the item from the set, but don't care\n+   --  whether the item is already in the set.)\n \n    procedure Delete  (Container : in out Set; Item : Element_Type) with\n      Global => null,\n@@ -715,6 +793,12 @@ is\n                (Positions (Container)'Old,\n                 Positions (Container),\n                 Find (Container, Item)'Old);\n+   --  Searches for Item in the set (which involves calling both Hash and\n+   --  Equivalent_Elements). If the search fails, then the operation raises\n+   --  Constraint_Error. Otherwise it removes the node from the set and then\n+   --  deallocates it. (This is the deletion analog of non-conditional\n+   --  Insert. It is intended for use when you want to assert that the item is\n+   --  already in the set.)\n \n    procedure Delete (Container : in out Set; Position : in out Cursor) with\n      Global => null,\n@@ -747,6 +831,10 @@ is\n                (Positions (Container)'Old,\n                 Positions (Container),\n                 Position'Old);\n+   --  Removes the node designated by Position from the set, and then\n+   --  deallocates the node. The operation calls Hash to determine the bucket,\n+   --  and then compares Position to each node in the bucket until there's a\n+   --  match (it does not call Equivalent_Elements).\n \n    procedure Union (Target : in out Set; Source : Set) with\n      Global => null,\n@@ -795,6 +883,8 @@ is\n                 E_Right => Elements (Target),\n                 P_Left  => Positions (Target)'Old,\n                 P_Right => Positions (Target));\n+   --  Iterates over the Source set, and conditionally inserts each element\n+   --  into Target.\n \n    function Union (Left, Right : Set) return Set with\n      Global => null,\n@@ -831,6 +921,8 @@ is\n                 Model (Left),\n                 Elements (Right),\n                 Elements (Union'Result));\n+   --  The operation first copies the Left set to the result, and then iterates\n+   --  over the Right set to conditionally insert each element into the result.\n \n    function \"or\" (Left, Right : Set) return Set renames Union;\n \n@@ -866,6 +958,9 @@ is\n                 E_Right => Elements (Target)'Old,\n                 P_Left  => Positions (Target),\n                 P_Right => Positions (Target)'Old);\n+   --  Iterates over the Target set (calling First and Next), calling Find to\n+   --  determine whether the element is in Source. If an equivalent element is\n+   --  not found in Source, the element is deleted from Target.\n \n    function Intersection (Left, Right : Set) return Set with\n      Global => null,\n@@ -891,6 +986,9 @@ is\n          and E_Elements_Included\n                (Elements (Left), Model (Right),\n                 Elements (Intersection'Result));\n+   --  Iterates over the Left set, calling Find to determine whether the\n+   --  element is in Right. If an equivalent element is found, it is inserted\n+   --  into the result set.\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n@@ -926,6 +1024,9 @@ is\n                 E_Right => Elements (Target)'Old,\n                 P_Left  => Positions (Target),\n                 P_Right => Positions (Target)'Old);\n+   --  Iterates over the Source (calling First and Next), calling Find to\n+   --  determine whether the element is in Target. If an equivalent element is\n+   --  found, it is deleted from Target.\n \n    function Difference (Left, Right : Set) return Set with\n      Global => null,\n@@ -955,6 +1056,9 @@ is\n                (Elements (Left),\n                 Model (Difference'Result),\n                 Elements (Difference'Result));\n+   --  Iterates over the Left set, calling Find to determine whether the\n+   --  element is in the Right set. If an equivalent element is not found, the\n+   --  element is inserted into the result set.\n \n    function \"-\" (Left, Right : Set) return Set renames Difference;\n \n@@ -995,6 +1099,10 @@ is\n \n          and E_Elements_Included\n                (Elements (Source), Model (Target), Elements (Target));\n+   --  The operation iterates over the Source set, searching for the element\n+   --  in Target (calling Hash and Equivalent_Elements). If an equivalent\n+   --  element is found, it is removed from Target; otherwise it is inserted\n+   --  into Target.\n \n    function Symmetric_Difference (Left, Right : Set) return Set with\n      Global => null,\n@@ -1042,6 +1150,12 @@ is\n                (Elements (Right),\n                 Model (Symmetric_Difference'Result),\n                 Elements (Symmetric_Difference'Result));\n+   --  The operation first iterates over the Left set. It calls Find to\n+   --  determine whether the element is in the Right set. If no equivalent\n+   --  element is found, the element from Left is inserted into the result. The\n+   --  operation then iterates over the Right set, to determine whether the\n+   --  element is in the Left set. If no equivalent element is found, the Right\n+   --  element is inserted into the result.\n \n    function \"xor\" (Left, Right : Set) return Set\n      renames Symmetric_Difference;\n@@ -1050,10 +1164,21 @@ is\n      Global => null,\n      Post   =>\n        Overlap'Result = not (M.No_Overlap (Model (Left), Model (Right)));\n+   --  Iterates over the Left set (calling First and Next), calling Find to\n+   --  determine whether the element is in the Right set. If an equivalent\n+   --  element is found, the operation immediately returns True. The operation\n+   --  returns False if the iteration over Left terminates without finding any\n+   --  equivalent element in Right.\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean with\n      Global => null,\n      Post   => Is_Subset'Result = (Model (Subset) <= Model (Of_Set));\n+   --  Iterates over Subset (calling First and Next), calling Find to determine\n+   --  whether the element is in Of_Set. If no equivalent element is found in\n+   --  Of_Set, the operation immediately returns False. The operation returns\n+   --  True if the iteration over Subset terminates without finding an element\n+   --  not in Of_Set (that is, every element in Subset is equivalent to an\n+   --  element in Of_Set).\n \n    function First (Container : Set) return Cursor with\n      Global         => null,\n@@ -1064,6 +1189,8 @@ is\n         others =>\n           Has_Element (Container, First'Result)\n             and P.Get (Positions (Container), First'Result) = 1);\n+   --  Returns a cursor that designates the first non-empty bucket, by\n+   --  searching from the beginning of the buckets array.\n \n    function Next (Container : Set; Position : Cursor) return Cursor with\n      Global         => null,\n@@ -1079,6 +1206,12 @@ is\n           Has_Element (Container, Next'Result)\n             and then P.Get (Positions (Container), Next'Result) =\n                      P.Get (Positions (Container), Position) + 1);\n+   --  Returns a cursor that designates the node that follows the current one\n+   --  designated by Position. If Position designates the last node in its\n+   --  bucket, the operation calls Hash to compute the index of this bucket,\n+   --  and searches the buckets array for the first non-empty bucket, starting\n+   --  from that index; otherwise, it simply follows the link to the next node\n+   --  in the same bucket.\n \n    procedure Next (Container : Set; Position : in out Cursor) with\n      Global         => null,\n@@ -1094,6 +1227,7 @@ is\n           Has_Element (Container, Position)\n             and then P.Get (Positions (Container), Position) =\n                      P.Get (Positions (Container), Position'Old) + 1);\n+   --  Equivalent to Position := Next (Position)\n \n    function Find\n      (Container : Set;\n@@ -1118,6 +1252,11 @@ is\n \n             and Equivalent_Elements\n                   (Element (Container, Find'Result), Item));\n+   --  Searches for Item in the set. Find calls Hash to determine the item's\n+   --  bucket; if the bucket is not empty, it calls Equivalent_Elements to\n+   --  compare Item to each element in the bucket. If the search succeeds, Find\n+   --  returns a cursor designating the node containing the equivalent element;\n+   --  otherwise, it returns No_Element.\n \n    function Contains (Container : Set; Item : Element_Type) return Boolean with\n      Global => null,"}]}