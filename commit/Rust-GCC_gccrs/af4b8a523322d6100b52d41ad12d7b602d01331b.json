{"sha": "af4b8a523322d6100b52d41ad12d7b602d01331b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY0YjhhNTIzMzIyZDYxMDBiNTJkNDFhZDEyZDdiNjAyZDAxMzMxYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-10T13:14:00Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-10T13:14:00Z"}, "message": "libgo: update to Go 1.7.1 release\n    \n    Reviewed-on: https://go-review.googlesource.com/29012\n\nFrom-SVN: r240071", "tree": {"sha": "948949901cdcd5af947a3db9a68f59e5c4b415bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/948949901cdcd5af947a3db9a68f59e5c4b415bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af4b8a523322d6100b52d41ad12d7b602d01331b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af4b8a523322d6100b52d41ad12d7b602d01331b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af4b8a523322d6100b52d41ad12d7b602d01331b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af4b8a523322d6100b52d41ad12d7b602d01331b/comments", "author": null, "committer": null, "parents": [{"sha": "337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb"}], "stats": {"total": 1369, "additions": 1113, "deletions": 256}, "files": [{"sha": "7b3a8aa8d63a3838fe0eefa25cdffed8948d4397", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -1,4 +1,4 @@\n-04fe765560107e5d4c5f98c1022765930a1069f9\n+d3a145b111a4f4ea772b812c6a0b3a853c207819\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "160cfe323cb9d595370203ce26aa995d8b6551e9", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -1,4 +1,4 @@\n-8707f31c0abc6b607014e843b7cc188b3019daa9\n+f75aafdf56dd90eab75cfeac8cf69358f73ba171\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "ee106b3bb2ddda388231265a1b0a5d2be1b3563d", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -1 +1 @@\n-go1.7rc3\n+go1.7.1"}, {"sha": "9f53d51a6e751ffe7157f54efeb5d34afd1e92ed", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -15,7 +15,17 @@ const (\n \tBestSpeed          = 1\n \tBestCompression    = 9\n \tDefaultCompression = -1\n-\tHuffmanOnly        = -2 // Disables match search and only does Huffman entropy reduction.\n+\n+\t// HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman\n+\t// entropy encoding. This mode is useful in compressing data that has\n+\t// already been compressed with an LZ style algorithm (e.g. Snappy or LZ4)\n+\t// that lacks an entropy encoder. Compression gains are achieved when\n+\t// certain bytes in the input stream occur more frequently than others.\n+\t//\n+\t// Note that HuffmanOnly produces a compressed output that is\n+\t// RFC 1951 compliant. That is, any valid DEFLATE decompressor will\n+\t// continue to be able to decompress this output.\n+\tHuffmanOnly = -2\n )\n \n const (\n@@ -644,7 +654,6 @@ func (d *compressor) close() error {\n // a very fast compression for all types of input, but sacrificing considerable\n // compression efficiency.\n //\n-//\n // If level is in the range [-2, 9] then the error returned will be nil.\n // Otherwise the error returned will be non-nil.\n func NewWriter(w io.Writer, level int) (*Writer, error) {\n@@ -715,7 +724,7 @@ func (w *Writer) Close() error {\n // the result of NewWriter or NewWriterDict called with dst\n // and w's level and dictionary.\n func (w *Writer) Reset(dst io.Writer) {\n-\tif dw, ok := w.d.w.w.(*dictWriter); ok {\n+\tif dw, ok := w.d.w.writer.(*dictWriter); ok {\n \t\t// w was created with NewWriterDict\n \t\tdw.w = dst\n \t\tw.d.reset(dw)"}, {"sha": "3322c40845d0678d29b51f7326d4cd045c0c593e", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -6,6 +6,7 @@ package flate\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"internal/testenv\"\n \t\"io\"\n@@ -631,3 +632,52 @@ func TestBestSpeed(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var errIO = errors.New(\"IO error\")\n+\n+// failWriter fails with errIO exactly at the nth call to Write.\n+type failWriter struct{ n int }\n+\n+func (w *failWriter) Write(b []byte) (int, error) {\n+\tw.n--\n+\tif w.n == -1 {\n+\t\treturn 0, errIO\n+\t}\n+\treturn len(b), nil\n+}\n+\n+func TestWriterPersistentError(t *testing.T) {\n+\td, err := ioutil.ReadFile(\"../testdata/Mark.Twain-Tom.Sawyer.txt\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"ReadFile: %v\", err)\n+\t}\n+\td = d[:10000] // Keep this test short\n+\n+\tzw, err := NewWriter(nil, DefaultCompression)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewWriter: %v\", err)\n+\t}\n+\n+\t// Sweep over the threshold at which an error is returned.\n+\t// The variable i makes it such that the ith call to failWriter.Write will\n+\t// return errIO. Since failWriter errors are not persistent, we must ensure\n+\t// that flate.Writer errors are persistent.\n+\tfor i := 0; i < 1000; i++ {\n+\t\tfw := &failWriter{i}\n+\t\tzw.Reset(fw)\n+\n+\t\t_, werr := zw.Write(d)\n+\t\tcerr := zw.Close()\n+\t\tif werr != errIO && werr != nil {\n+\t\t\tt.Errorf(\"test %d, mismatching Write error: got %v, want %v\", i, werr, errIO)\n+\t\t}\n+\t\tif cerr != errIO && fw.n < 0 {\n+\t\t\tt.Errorf(\"test %d, mismatching Close error: got %v, want %v\", i, cerr, errIO)\n+\t\t}\n+\t\tif fw.n >= 0 {\n+\t\t\t// At this point, the failure threshold was sufficiently high enough\n+\t\t\t// that we wrote the whole stream without any errors.\n+\t\t\treturn\n+\t\t}\n+\t}\n+}"}, {"sha": "d8b5a3ebd7b50c7da64274dca161241e1bbb4d60", "filename": "libgo/go/compress/flate/huffman_bit_writer.go", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -77,7 +77,11 @@ var offsetBase = []uint32{\n var codegenOrder = []uint32{16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15}\n \n type huffmanBitWriter struct {\n-\tw io.Writer\n+\t// writer is the underlying writer.\n+\t// Do not use it directly; use the write method, which ensures\n+\t// that Write errors are sticky.\n+\twriter io.Writer\n+\n \t// Data waiting to be written is bytes[0:nbytes]\n \t// and then the low nbits of bits.\n \tbits            uint64\n@@ -96,7 +100,7 @@ type huffmanBitWriter struct {\n \n func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {\n \treturn &huffmanBitWriter{\n-\t\tw:               w,\n+\t\twriter:          w,\n \t\tliteralFreq:     make([]int32, maxNumLit),\n \t\toffsetFreq:      make([]int32, offsetCodeCount),\n \t\tcodegen:         make([]uint8, maxNumLit+offsetCodeCount+1),\n@@ -107,7 +111,7 @@ func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {\n }\n \n func (w *huffmanBitWriter) reset(writer io.Writer) {\n-\tw.w = writer\n+\tw.writer = writer\n \tw.bits, w.nbits, w.nbytes, w.err = 0, 0, 0, nil\n \tw.bytes = [bufferSize]byte{}\n }\n@@ -129,11 +133,21 @@ func (w *huffmanBitWriter) flush() {\n \t\tn++\n \t}\n \tw.bits = 0\n-\t_, w.err = w.w.Write(w.bytes[:n])\n+\tw.write(w.bytes[:n])\n \tw.nbytes = 0\n }\n \n+func (w *huffmanBitWriter) write(b []byte) {\n+\tif w.err != nil {\n+\t\treturn\n+\t}\n+\t_, w.err = w.writer.Write(b)\n+}\n+\n func (w *huffmanBitWriter) writeBits(b int32, nb uint) {\n+\tif w.err != nil {\n+\t\treturn\n+\t}\n \tw.bits |= uint64(b) << w.nbits\n \tw.nbits += nb\n \tif w.nbits >= 48 {\n@@ -150,7 +164,7 @@ func (w *huffmanBitWriter) writeBits(b int32, nb uint) {\n \t\tbytes[5] = byte(bits >> 40)\n \t\tn += 6\n \t\tif n >= bufferFlushSize {\n-\t\t\t_, w.err = w.w.Write(w.bytes[:n])\n+\t\t\tw.write(w.bytes[:n])\n \t\t\tn = 0\n \t\t}\n \t\tw.nbytes = n\n@@ -173,13 +187,10 @@ func (w *huffmanBitWriter) writeBytes(bytes []byte) {\n \t\tn++\n \t}\n \tif n != 0 {\n-\t\t_, w.err = w.w.Write(w.bytes[:n])\n-\t\tif w.err != nil {\n-\t\t\treturn\n-\t\t}\n+\t\tw.write(w.bytes[:n])\n \t}\n \tw.nbytes = 0\n-\t_, w.err = w.w.Write(bytes)\n+\tw.write(bytes)\n }\n \n // RFC 1951 3.2.7 specifies a special run-length encoding for specifying\n@@ -341,7 +352,7 @@ func (w *huffmanBitWriter) writeCode(c hcode) {\n \t\tbytes[5] = byte(bits >> 40)\n \t\tn += 6\n \t\tif n >= bufferFlushSize {\n-\t\t\t_, w.err = w.w.Write(w.bytes[:n])\n+\t\t\tw.write(w.bytes[:n])\n \t\t\tn = 0\n \t\t}\n \t\tw.nbytes = n\n@@ -572,6 +583,9 @@ func (w *huffmanBitWriter) indexTokens(tokens []token) (numLiterals, numOffsets\n // writeTokens writes a slice of tokens to the output.\n // codes for literal and offset encoding must be supplied.\n func (w *huffmanBitWriter) writeTokens(tokens []token, leCodes, oeCodes []hcode) {\n+\tif w.err != nil {\n+\t\treturn\n+\t}\n \tfor _, t := range tokens {\n \t\tif t < matchType {\n \t\t\tw.writeCode(leCodes[t.literal()])\n@@ -676,9 +690,9 @@ func (w *huffmanBitWriter) writeBlockHuff(eof bool, input []byte) {\n \t\tif n < bufferFlushSize {\n \t\t\tcontinue\n \t\t}\n-\t\t_, w.err = w.w.Write(w.bytes[:n])\n+\t\tw.write(w.bytes[:n])\n \t\tif w.err != nil {\n-\t\t\treturn\n+\t\t\treturn // Return early in the event of write failures\n \t\t}\n \t\tn = 0\n \t}"}, {"sha": "cf182110fbdf9b7409b40cfa2efdfe1660c4f248", "filename": "libgo/go/context/context_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -255,6 +255,12 @@ func TestDeadline(t *testing.T) {\n \to = otherContext{c}\n \tc, _ = WithDeadline(o, time.Now().Add(4*time.Second))\n \ttestDeadline(c, \"WithDeadline+otherContext+WithDeadline\", 2*time.Second, t)\n+\n+\tc, _ = WithDeadline(Background(), time.Now().Add(-time.Millisecond))\n+\ttestDeadline(c, \"WithDeadline+inthepast\", time.Second, t)\n+\n+\tc, _ = WithDeadline(Background(), time.Now())\n+\ttestDeadline(c, \"WithDeadline+now\", time.Second, t)\n }\n \n func TestTimeout(t *testing.T) {"}, {"sha": "a4b33c7660ee7b33a0a417105c23dfc05d3dc2d4", "filename": "libgo/go/crypto/x509/root_cgo_darwin.go", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -10,9 +10,65 @@ package x509\n #cgo CFLAGS: -mmacosx-version-min=10.6 -D__MAC_OS_X_VERSION_MAX_ALLOWED=1060\n #cgo LDFLAGS: -framework CoreFoundation -framework Security\n \n+#include <errno.h>\n+#include <sys/sysctl.h>\n+\n #include <CoreFoundation/CoreFoundation.h>\n #include <Security/Security.h>\n \n+// FetchPEMRoots_MountainLion is the version of FetchPEMRoots from Go 1.6\n+// which still works on OS X 10.8 (Mountain Lion).\n+// It lacks support for admin & user cert domains.\n+// See golang.org/issue/16473\n+int FetchPEMRoots_MountainLion(CFDataRef *pemRoots) {\n+\tif (pemRoots == NULL) {\n+\t\treturn -1;\n+\t}\n+\tCFArrayRef certs = NULL;\n+\tOSStatus err = SecTrustCopyAnchorCertificates(&certs);\n+\tif (err != noErr) {\n+\t\treturn -1;\n+\t}\n+\tCFMutableDataRef combinedData = CFDataCreateMutable(kCFAllocatorDefault, 0);\n+\tint i, ncerts = CFArrayGetCount(certs);\n+\tfor (i = 0; i < ncerts; i++) {\n+\t\tCFDataRef data = NULL;\n+\t\tSecCertificateRef cert = (SecCertificateRef)CFArrayGetValueAtIndex(certs, i);\n+\t\tif (cert == NULL) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// Note: SecKeychainItemExport is deprecated as of 10.7 in favor of SecItemExport.\n+\t\t// Once we support weak imports via cgo we should prefer that, and fall back to this\n+\t\t// for older systems.\n+\t\terr = SecKeychainItemExport(cert, kSecFormatX509Cert, kSecItemPemArmour, NULL, &data);\n+\t\tif (err != noErr) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tif (data != NULL) {\n+\t\t\tCFDataAppendBytes(combinedData, CFDataGetBytePtr(data), CFDataGetLength(data));\n+\t\t\tCFRelease(data);\n+\t\t}\n+\t}\n+\tCFRelease(certs);\n+\t*pemRoots = combinedData;\n+\treturn 0;\n+}\n+\n+// useOldCode reports whether the running machine is OS X 10.8 Mountain Lion\n+// or older. We only support Mountain Lion and higher, but we'll at least try our\n+// best on older machines and continue to use the old code path.\n+//\n+// See golang.org/issue/16473\n+int useOldCode() {\n+\tchar str[256];\n+\tsize_t size = sizeof(str);\n+\tmemset(str, 0, size);\n+\tsysctlbyname(\"kern.osrelease\", str, &size, NULL, 0);\n+\t// OS X 10.8 is osrelease \"12.*\", 10.7 is 11.*, 10.6 is 10.*.\n+\t// We never supported things before that.\n+\treturn memcmp(str, \"12.\", 3) == 0 || memcmp(str, \"11.\", 3) == 0 || memcmp(str, \"10.\", 3) == 0;\n+}\n+\n // FetchPEMRoots fetches the system's list of trusted X.509 root certificates.\n //\n // On success it returns 0 and fills pemRoots with a CFDataRef that contains the extracted root\n@@ -21,6 +77,10 @@ package x509\n // Note: The CFDataRef returned in pemRoots must be released (using CFRelease) after\n // we've consumed its content.\n int FetchPEMRoots(CFDataRef *pemRoots) {\n+\tif (useOldCode()) {\n+\t\treturn FetchPEMRoots_MountainLion(pemRoots);\n+\t}\n+\n \t// Get certificates from all domains, not just System, this lets\n \t// the user add CAs to their \"login\" keychain, and Admins to add\n \t// to the \"System\" keychain"}, {"sha": "2a7926b4796008809d2e462417506bbfb6be4159", "filename": "libgo/go/hash/crc32/crc32_s390x.go", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_s390x.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -6,14 +6,9 @@\n \n package crc32\n \n-import (\n-\t\"unsafe\"\n-)\n-\n const (\n \tvxMinLen    = 64\n-\tvxAlignment = 16\n-\tvxAlignMask = vxAlignment - 1\n+\tvxAlignMask = 15 // align to 16 bytes\n )\n \n // hasVectorFacility reports whether the machine has the z/Architecture\n@@ -51,20 +46,13 @@ func genericIEEE(crc uint32, p []byte) uint32 {\n \treturn update(crc, IEEETable, p)\n }\n \n-// updateCastagnoli calculates the checksum of p using genericCastagnoli to\n-// align the data appropriately for vectorCastagnoli. It avoids using\n-// vectorCastagnoli entirely if the length of p is less than or equal to\n-// vxMinLen.\n+// updateCastagnoli calculates the checksum of p using\n+// vectorizedCastagnoli if possible and falling back onto\n+// genericCastagnoli as needed.\n func updateCastagnoli(crc uint32, p []byte) uint32 {\n \t// Use vectorized function if vector facility is available and\n \t// data length is above threshold.\n-\tif hasVX && len(p) > vxMinLen {\n-\t\tpAddr := uintptr(unsafe.Pointer(&p[0]))\n-\t\tif pAddr&vxAlignMask != 0 {\n-\t\t\tprealign := vxAlignment - int(pAddr&vxAlignMask)\n-\t\t\tcrc = genericCastagnoli(crc, p[:prealign])\n-\t\t\tp = p[prealign:]\n-\t\t}\n+\tif hasVX && len(p) >= vxMinLen {\n \t\taligned := len(p) & ^vxAlignMask\n \t\tcrc = vectorizedCastagnoli(crc, p[:aligned])\n \t\tp = p[aligned:]\n@@ -77,19 +65,12 @@ func updateCastagnoli(crc uint32, p []byte) uint32 {\n \treturn genericCastagnoli(crc, p)\n }\n \n-// updateIEEE calculates the checksum of p using genericIEEE to align the data\n-// appropriately for vectorIEEE. It avoids using vectorIEEE entirely if the length\n-// of p is less than or equal to vxMinLen.\n+// updateIEEE calculates the checksum of p using vectorizedIEEE if\n+// possible and falling back onto genericIEEE as needed.\n func updateIEEE(crc uint32, p []byte) uint32 {\n \t// Use vectorized function if vector facility is available and\n \t// data length is above threshold.\n-\tif hasVX && len(p) > vxMinLen {\n-\t\tpAddr := uintptr(unsafe.Pointer(&p[0]))\n-\t\tif pAddr&vxAlignMask != 0 {\n-\t\t\tprealign := vxAlignment - int(pAddr&vxAlignMask)\n-\t\t\tcrc = genericIEEE(crc, p[:prealign])\n-\t\t\tp = p[prealign:]\n-\t\t}\n+\tif hasVX && len(p) >= vxMinLen {\n \t\taligned := len(p) & ^vxAlignMask\n \t\tcrc = vectorizedIEEE(crc, p[:aligned])\n \t\tp = p[aligned:]"}, {"sha": "3a9d03652b07e67e7e09d122c4133e86a89cc3c7", "filename": "libgo/go/io/multi.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fio%2Fmulti.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fio%2Fmulti.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fmulti.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -18,15 +18,16 @@ func (mr *multiReader) Read(p []byte) (n int, err error) {\n \t\t\t}\n \t\t}\n \t\tn, err = mr.readers[0].Read(p)\n+\t\tif err == EOF {\n+\t\t\tmr.readers = mr.readers[1:]\n+\t\t}\n \t\tif n > 0 || err != EOF {\n-\t\t\tif err == EOF {\n-\t\t\t\t// Don't return EOF yet. There may be more bytes\n-\t\t\t\t// in the remaining readers.\n+\t\t\tif err == EOF && len(mr.readers) > 0 {\n+\t\t\t\t// Don't return EOF yet. More readers remain.\n \t\t\t\terr = nil\n \t\t\t}\n \t\t\treturn\n \t\t}\n-\t\tmr.readers = mr.readers[1:]\n \t}\n \treturn 0, EOF\n }"}, {"sha": "447e7f59635270ec799608b19a8103731f56a35b", "filename": "libgo/go/io/multi_test.go", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fio%2Fmulti_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fio%2Fmulti_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fmulti_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -197,3 +197,41 @@ func TestMultiReaderFlatten(t *testing.T) {\n \t\t\tmyDepth+2, readDepth)\n \t}\n }\n+\n+// byteAndEOFReader is a Reader which reads one byte (the underlying\n+// byte) and io.EOF at once in its Read call.\n+type byteAndEOFReader byte\n+\n+func (b byteAndEOFReader) Read(p []byte) (n int, err error) {\n+\tif len(p) == 0 {\n+\t\t// Read(0 bytes) is useless. We expect no such useless\n+\t\t// calls in this test.\n+\t\tpanic(\"unexpected call\")\n+\t}\n+\tp[0] = byte(b)\n+\treturn 1, EOF\n+}\n+\n+// In Go 1.7, this yielded bytes forever.\n+func TestMultiReaderSingleByteWithEOF(t *testing.T) {\n+\tgot, err := ioutil.ReadAll(LimitReader(MultiReader(byteAndEOFReader('a'), byteAndEOFReader('b')), 10))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tconst want = \"ab\"\n+\tif string(got) != want {\n+\t\tt.Errorf(\"got %q; want %q\", got, want)\n+\t}\n+}\n+\n+// Test that a reader returning (n, EOF) at the end of an MultiReader\n+// chain continues to return EOF on its final read, rather than\n+// yielding a (0, EOF).\n+func TestMultiReaderFinalEOF(t *testing.T) {\n+\tr := MultiReader(bytes.NewReader(nil), byteAndEOFReader('a'))\n+\tbuf := make([]byte, 2)\n+\tn, err := r.Read(buf)\n+\tif n != 1 || err != EOF {\n+\t\tt.Errorf(\"got %v, %v; want 1, EOF\", n, err)\n+\t}\n+}"}, {"sha": "47052547284e580009b40d4628c5ed6822608f08", "filename": "libgo/go/net/dial_unix_test.go", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fdial_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fdial_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_unix_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package net\n+\n+import (\n+\t\"context\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+// Issue 16523\n+func TestDialContextCancelRace(t *testing.T) {\n+\toldConnectFunc := connectFunc\n+\toldGetsockoptIntFunc := getsockoptIntFunc\n+\toldTestHookCanceledDial := testHookCanceledDial\n+\tdefer func() {\n+\t\tconnectFunc = oldConnectFunc\n+\t\tgetsockoptIntFunc = oldGetsockoptIntFunc\n+\t\ttestHookCanceledDial = oldTestHookCanceledDial\n+\t}()\n+\n+\tln, err := newLocalListener(\"tcp\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tlistenerDone := make(chan struct{})\n+\tgo func() {\n+\t\tdefer close(listenerDone)\n+\t\tc, err := ln.Accept()\n+\t\tif err == nil {\n+\t\t\tc.Close()\n+\t\t}\n+\t}()\n+\tdefer func() { <-listenerDone }()\n+\tdefer ln.Close()\n+\n+\tsawCancel := make(chan bool, 1)\n+\ttestHookCanceledDial = func() {\n+\t\tsawCancel <- true\n+\t}\n+\n+\tctx, cancelCtx := context.WithCancel(context.Background())\n+\n+\tconnectFunc = func(fd int, addr syscall.Sockaddr) error {\n+\t\terr := oldConnectFunc(fd, addr)\n+\t\tt.Logf(\"connect(%d, addr) = %v\", fd, err)\n+\t\tif err == nil {\n+\t\t\t// On some operating systems, localhost\n+\t\t\t// connects _sometimes_ succeed immediately.\n+\t\t\t// Prevent that, so we exercise the code path\n+\t\t\t// we're interested in testing. This seems\n+\t\t\t// harmless. It makes FreeBSD 10.10 work when\n+\t\t\t// run with many iterations. It failed about\n+\t\t\t// half the time previously.\n+\t\t\treturn syscall.EINPROGRESS\n+\t\t}\n+\t\treturn err\n+\t}\n+\n+\tgetsockoptIntFunc = func(fd, level, opt int) (val int, err error) {\n+\t\tval, err = oldGetsockoptIntFunc(fd, level, opt)\n+\t\tt.Logf(\"getsockoptIntFunc(%d, %d, %d) = (%v, %v)\", fd, level, opt, val, err)\n+\t\tif level == syscall.SOL_SOCKET && opt == syscall.SO_ERROR && err == nil && val == 0 {\n+\t\t\tt.Logf(\"canceling context\")\n+\n+\t\t\t// Cancel the context at just the moment which\n+\t\t\t// caused the race in issue 16523.\n+\t\t\tcancelCtx()\n+\n+\t\t\t// And wait for the \"interrupter\" goroutine to\n+\t\t\t// cancel the dial by messing with its write\n+\t\t\t// timeout before returning.\n+\t\t\tselect {\n+\t\t\tcase <-sawCancel:\n+\t\t\t\tt.Logf(\"saw cancel\")\n+\t\t\tcase <-time.After(5 * time.Second):\n+\t\t\t\tt.Errorf(\"didn't see cancel after 5 seconds\")\n+\t\t\t}\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tvar d Dialer\n+\tc, err := d.DialContext(ctx, \"tcp\", ln.Addr().String())\n+\tif err == nil {\n+\t\tc.Close()\n+\t\tt.Fatal(\"unexpected successful dial; want context canceled error\")\n+\t}\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"expected context to be canceled\")\n+\t}\n+\n+\toe, ok := err.(*OpError)\n+\tif !ok || oe.Op != \"dial\" {\n+\t\tt.Fatalf(\"Dial error = %#v; want dial *OpError\", err)\n+\t}\n+\tif oe.Err != ctx.Err() {\n+\t\tt.Errorf(\"DialContext = (%v, %v); want OpError with error %v\", c, err, ctx.Err())\n+\t}\n+}"}, {"sha": "b5b6ffb1c5060ebb025f984b2e1b1b6c334369d0", "filename": "libgo/go/net/dnsclient_unix.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -141,7 +141,7 @@ func (d *Dialer) dialDNS(ctx context.Context, network, server string) (dnsConn,\n }\n \n // exchange sends a query on the connection and hopes for a response.\n-func exchange(ctx context.Context, server, name string, qtype uint16) (*dnsMsg, error) {\n+func exchange(ctx context.Context, server, name string, qtype uint16, timeout time.Duration) (*dnsMsg, error) {\n \td := testHookDNSDialer()\n \tout := dnsMsg{\n \t\tdnsMsgHdr: dnsMsgHdr{\n@@ -152,6 +152,12 @@ func exchange(ctx context.Context, server, name string, qtype uint16) (*dnsMsg,\n \t\t},\n \t}\n \tfor _, network := range []string{\"udp\", \"tcp\"} {\n+\t\t// TODO(mdempsky): Refactor so defers from UDP-based\n+\t\t// exchanges happen before TCP-based exchange.\n+\n+\t\tctx, cancel := context.WithDeadline(ctx, time.Now().Add(timeout))\n+\t\tdefer cancel()\n+\n \t\tc, err := d.dialDNS(ctx, network, server)\n \t\tif err != nil {\n \t\t\treturn nil, err\n@@ -180,17 +186,10 @@ func tryOneName(ctx context.Context, cfg *dnsConfig, name string, qtype uint16)\n \t\treturn \"\", nil, &DNSError{Err: \"no DNS servers\", Name: name}\n \t}\n \n-\tdeadline := time.Now().Add(cfg.timeout)\n-\tif old, ok := ctx.Deadline(); !ok || deadline.Before(old) {\n-\t\tvar cancel context.CancelFunc\n-\t\tctx, cancel = context.WithDeadline(ctx, deadline)\n-\t\tdefer cancel()\n-\t}\n-\n \tvar lastErr error\n \tfor i := 0; i < cfg.attempts; i++ {\n \t\tfor _, server := range cfg.servers {\n-\t\t\tmsg, err := exchange(ctx, server, name, qtype)\n+\t\t\tmsg, err := exchange(ctx, server, name, qtype, cfg.timeout)\n \t\t\tif err != nil {\n \t\t\t\tlastErr = &DNSError{\n \t\t\t\t\tErr:    err.Error(),\n@@ -338,16 +337,17 @@ func lookup(ctx context.Context, name string, qtype uint16) (cname string, rrs [\n }\n \n // avoidDNS reports whether this is a hostname for which we should not\n-// use DNS. Currently this includes only .onion and .local names,\n-// per RFC 7686 and RFC 6762, respectively. See golang.org/issue/13705.\n+// use DNS. Currently this includes only .onion, per RFC 7686. See\n+// golang.org/issue/13705. Does not cover .local names (RFC 6762),\n+// see golang.org/issue/16739.\n func avoidDNS(name string) bool {\n \tif name == \"\" {\n \t\treturn true\n \t}\n \tif name[len(name)-1] == '.' {\n \t\tname = name[:len(name)-1]\n \t}\n-\treturn stringsHasSuffixFold(name, \".onion\") || stringsHasSuffixFold(name, \".local\")\n+\treturn stringsHasSuffixFold(name, \".onion\")\n }\n \n // nameList returns a list of names for sequential DNS queries."}, {"sha": "6ebeeaeb8f48996ac39a67a9a90bb8d2953c44b9", "filename": "libgo/go/net/dnsclient_unix_test.go", "status": "modified", "additions": 89, "deletions": 16, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -40,9 +40,9 @@ func TestDNSTransportFallback(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n \tfor _, tt := range dnsTransportFallbackTests {\n-\t\tctx, cancel := context.WithTimeout(context.Background(), time.Duration(tt.timeout)*time.Second)\n+\t\tctx, cancel := context.WithCancel(context.Background())\n \t\tdefer cancel()\n-\t\tmsg, err := exchange(ctx, tt.server, tt.name, tt.qtype)\n+\t\tmsg, err := exchange(ctx, tt.server, tt.name, tt.qtype, time.Second)\n \t\tif err != nil {\n \t\t\tt.Error(err)\n \t\t\tcontinue\n@@ -82,9 +82,9 @@ func TestSpecialDomainName(t *testing.T) {\n \n \tserver := \"8.8.8.8:53\"\n \tfor _, tt := range specialDomainNameTests {\n-\t\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n+\t\tctx, cancel := context.WithCancel(context.Background())\n \t\tdefer cancel()\n-\t\tmsg, err := exchange(ctx, server, tt.name, tt.qtype)\n+\t\tmsg, err := exchange(ctx, server, tt.name, tt.qtype, 3*time.Second)\n \t\tif err != nil {\n \t\t\tt.Error(err)\n \t\t\tcontinue\n@@ -112,10 +112,11 @@ func TestAvoidDNSName(t *testing.T) {\n \t\t{\"foo.ONION\", true},\n \t\t{\"foo.ONION.\", true},\n \n-\t\t{\"foo.local.\", true},\n-\t\t{\"foo.local\", true},\n-\t\t{\"foo.LOCAL\", true},\n-\t\t{\"foo.LOCAL.\", true},\n+\t\t// But do resolve *.local address; Issue 16739\n+\t\t{\"foo.local.\", false},\n+\t\t{\"foo.local\", false},\n+\t\t{\"foo.LOCAL\", false},\n+\t\t{\"foo.LOCAL.\", false},\n \n \t\t{\"\", true}, // will be rejected earlier too\n \n@@ -500,7 +501,7 @@ func TestErrorForOriginalNameWhenSearching(t *testing.T) {\n \td := &fakeDNSDialer{}\n \ttestHookDNSDialer = func() dnsDialer { return d }\n \n-\td.rh = func(s string, q *dnsMsg) (*dnsMsg, error) {\n+\td.rh = func(s string, q *dnsMsg, _ time.Time) (*dnsMsg, error) {\n \t\tr := &dnsMsg{\n \t\t\tdnsMsgHdr: dnsMsgHdr{\n \t\t\t\tid: q.id,\n@@ -539,14 +540,15 @@ func TestIgnoreLameReferrals(t *testing.T) {\n \t}\n \tdefer conf.teardown()\n \n-\tif err := conf.writeAndUpdate([]string{\"nameserver 192.0.2.1\", \"nameserver 192.0.2.2\"}); err != nil {\n+\tif err := conf.writeAndUpdate([]string{\"nameserver 192.0.2.1\", // the one that will give a lame referral\n+\t\t\"nameserver 192.0.2.2\"}); err != nil {\n \t\tt.Fatal(err)\n \t}\n \n \td := &fakeDNSDialer{}\n \ttestHookDNSDialer = func() dnsDialer { return d }\n \n-\td.rh = func(s string, q *dnsMsg) (*dnsMsg, error) {\n+\td.rh = func(s string, q *dnsMsg, _ time.Time) (*dnsMsg, error) {\n \t\tt.Log(s, q)\n \t\tr := &dnsMsg{\n \t\t\tdnsMsgHdr: dnsMsgHdr{\n@@ -633,28 +635,30 @@ func BenchmarkGoLookupIPWithBrokenNameServer(b *testing.B) {\n \n type fakeDNSDialer struct {\n \t// reply handler\n-\trh func(s string, q *dnsMsg) (*dnsMsg, error)\n+\trh func(s string, q *dnsMsg, t time.Time) (*dnsMsg, error)\n }\n \n func (f *fakeDNSDialer) dialDNS(_ context.Context, n, s string) (dnsConn, error) {\n-\treturn &fakeDNSConn{f.rh, s}, nil\n+\treturn &fakeDNSConn{f.rh, s, time.Time{}}, nil\n }\n \n type fakeDNSConn struct {\n-\trh func(s string, q *dnsMsg) (*dnsMsg, error)\n+\trh func(s string, q *dnsMsg, t time.Time) (*dnsMsg, error)\n \ts  string\n+\tt  time.Time\n }\n \n func (f *fakeDNSConn) Close() error {\n \treturn nil\n }\n \n-func (f *fakeDNSConn) SetDeadline(time.Time) error {\n+func (f *fakeDNSConn) SetDeadline(t time.Time) error {\n+\tf.t = t\n \treturn nil\n }\n \n func (f *fakeDNSConn) dnsRoundTrip(q *dnsMsg) (*dnsMsg, error) {\n-\treturn f.rh(f.s, q)\n+\treturn f.rh(f.s, q, f.t)\n }\n \n // UDP round-tripper algorithm should ignore invalid DNS responses (issue 13281).\n@@ -724,3 +728,72 @@ func TestIgnoreDNSForgeries(t *testing.T) {\n \t\tt.Errorf(\"got address %v, want %v\", got, TestAddr)\n \t}\n }\n+\n+// Issue 16865. If a name server times out, continue to the next.\n+func TestRetryTimeout(t *testing.T) {\n+\torigTestHookDNSDialer := testHookDNSDialer\n+\tdefer func() { testHookDNSDialer = origTestHookDNSDialer }()\n+\n+\tconf, err := newResolvConfTest()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer conf.teardown()\n+\n+\tif err := conf.writeAndUpdate([]string{\"nameserver 192.0.2.1\", // the one that will timeout\n+\t\t\"nameserver 192.0.2.2\"}); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\td := &fakeDNSDialer{}\n+\ttestHookDNSDialer = func() dnsDialer { return d }\n+\n+\tvar deadline0 time.Time\n+\n+\td.rh = func(s string, q *dnsMsg, deadline time.Time) (*dnsMsg, error) {\n+\t\tt.Log(s, q, deadline)\n+\n+\t\tif deadline.IsZero() {\n+\t\t\tt.Error(\"zero deadline\")\n+\t\t}\n+\n+\t\tif s == \"192.0.2.1:53\" {\n+\t\t\tdeadline0 = deadline\n+\t\t\ttime.Sleep(10 * time.Millisecond)\n+\t\t\treturn nil, errTimeout\n+\t\t}\n+\n+\t\tif deadline == deadline0 {\n+\t\t\tt.Error(\"deadline didn't change\")\n+\t\t}\n+\n+\t\tr := &dnsMsg{\n+\t\t\tdnsMsgHdr: dnsMsgHdr{\n+\t\t\t\tid:                  q.id,\n+\t\t\t\tresponse:            true,\n+\t\t\t\trecursion_available: true,\n+\t\t\t},\n+\t\t\tquestion: q.question,\n+\t\t\tanswer: []dnsRR{\n+\t\t\t\t&dnsRR_CNAME{\n+\t\t\t\t\tHdr: dnsRR_Header{\n+\t\t\t\t\t\tName:   q.question[0].Name,\n+\t\t\t\t\t\tRrtype: dnsTypeCNAME,\n+\t\t\t\t\t\tClass:  dnsClassINET,\n+\t\t\t\t\t},\n+\t\t\t\t\tCname: \"golang.org\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\treturn r, nil\n+\t}\n+\n+\t_, err = goLookupCNAME(context.Background(), \"www.golang.org\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif deadline0.IsZero() {\n+\t\tt.Error(\"deadline0 still zero\", deadline0)\n+\t}\n+}"}, {"sha": "0309db08ebce468dd29b67842a9a8313abfee7a1", "filename": "libgo/go/net/fd_unix.go", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Ffd_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Ffd_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_unix.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -64,7 +64,7 @@ func (fd *netFD) name() string {\n \treturn fd.net + \":\" + ls + \"->\" + rs\n }\n \n-func (fd *netFD) connect(ctx context.Context, la, ra syscall.Sockaddr) error {\n+func (fd *netFD) connect(ctx context.Context, la, ra syscall.Sockaddr) (ret error) {\n \t// Do not need to call fd.writeLock here,\n \t// because fd is not yet accessible to user,\n \t// so no concurrent operations are possible.\n@@ -101,21 +101,44 @@ func (fd *netFD) connect(ctx context.Context, la, ra syscall.Sockaddr) error {\n \t\tdefer fd.setWriteDeadline(noDeadline)\n \t}\n \n-\t// Wait for the goroutine converting context.Done into a write timeout\n-\t// to exist, otherwise our caller might cancel the context and\n-\t// cause fd.setWriteDeadline(aLongTimeAgo) to cancel a successful dial.\n-\tdone := make(chan bool) // must be unbuffered\n-\tdefer func() { done <- true }()\n-\tgo func() {\n-\t\tselect {\n-\t\tcase <-ctx.Done():\n-\t\t\t// Force the runtime's poller to immediately give\n-\t\t\t// up waiting for writability.\n-\t\t\tfd.setWriteDeadline(aLongTimeAgo)\n-\t\t\t<-done\n-\t\tcase <-done:\n-\t\t}\n-\t}()\n+\t// Start the \"interrupter\" goroutine, if this context might be canceled.\n+\t// (The background context cannot)\n+\t//\n+\t// The interrupter goroutine waits for the context to be done and\n+\t// interrupts the dial (by altering the fd's write deadline, which\n+\t// wakes up waitWrite).\n+\tif ctx != context.Background() {\n+\t\t// Wait for the interrupter goroutine to exit before returning\n+\t\t// from connect.\n+\t\tdone := make(chan struct{})\n+\t\tinterruptRes := make(chan error)\n+\t\tdefer func() {\n+\t\t\tclose(done)\n+\t\t\tif ctxErr := <-interruptRes; ctxErr != nil && ret == nil {\n+\t\t\t\t// The interrupter goroutine called setWriteDeadline,\n+\t\t\t\t// but the connect code below had returned from\n+\t\t\t\t// waitWrite already and did a successful connect (ret\n+\t\t\t\t// == nil). Because we've now poisoned the connection\n+\t\t\t\t// by making it unwritable, don't return a successful\n+\t\t\t\t// dial. This was issue 16523.\n+\t\t\t\tret = ctxErr\n+\t\t\t\tfd.Close() // prevent a leak\n+\t\t\t}\n+\t\t}()\n+\t\tgo func() {\n+\t\t\tselect {\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\t// Force the runtime's poller to immediately give up\n+\t\t\t\t// waiting for writability, unblocking waitWrite\n+\t\t\t\t// below.\n+\t\t\t\tfd.setWriteDeadline(aLongTimeAgo)\n+\t\t\t\ttestHookCanceledDial()\n+\t\t\t\tinterruptRes <- ctx.Err()\n+\t\t\tcase <-done:\n+\t\t\t\tinterruptRes <- nil\n+\t\t\t}\n+\t\t}()\n+\t}\n \n \tfor {\n \t\t// Performing multiple connect system calls on a"}, {"sha": "cf52567fcfdad88ce65d3f5d39650bdb4e7a6610", "filename": "libgo/go/net/hook_unix.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhook_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhook_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhook_unix.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -9,7 +9,8 @@ package net\n import \"syscall\"\n \n var (\n-\ttestHookDialChannel = func() {} // see golang.org/issue/5349\n+\ttestHookDialChannel  = func() {} // for golang.org/issue/5349\n+\ttestHookCanceledDial = func() {} // for golang.org/issue/16523\n \n \t// Placeholders for socket system calls.\n \tsocketFunc        func(int, int, int) (int, error)         = syscall.Socket"}, {"sha": "5826bb7d858a4137d10e1b584dea640fa5dc3137", "filename": "libgo/go/net/http/h2_bundle.go", "status": "modified", "additions": 299, "deletions": 134, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -28,6 +28,7 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"log\"\n+\t\"math\"\n \t\"net\"\n \t\"net/http/httptrace\"\n \t\"net/textproto\"\n@@ -85,7 +86,16 @@ const (\n \thttp2noDialOnMiss = false\n )\n \n-func (p *http2clientConnPool) getClientConn(_ *Request, addr string, dialOnMiss bool) (*http2ClientConn, error) {\n+func (p *http2clientConnPool) getClientConn(req *Request, addr string, dialOnMiss bool) (*http2ClientConn, error) {\n+\tif http2isConnectionCloseRequest(req) && dialOnMiss {\n+\t\t// It gets its own connection.\n+\t\tconst singleUse = true\n+\t\tcc, err := p.t.dialClientConn(addr, singleUse)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn cc, nil\n+\t}\n \tp.mu.Lock()\n \tfor _, cc := range p.conns[addr] {\n \t\tif cc.CanTakeNewRequest() {\n@@ -128,7 +138,8 @@ func (p *http2clientConnPool) getStartDialLocked(addr string) *http2dialCall {\n \n // run in its own goroutine.\n func (c *http2dialCall) dial(addr string) {\n-\tc.res, c.err = c.p.t.dialClientConn(addr)\n+\tconst singleUse = false // shared conn\n+\tc.res, c.err = c.p.t.dialClientConn(addr, singleUse)\n \tclose(c.done)\n \n \tc.p.mu.Lock()\n@@ -393,9 +404,17 @@ func (e http2ConnectionError) Error() string {\n type http2StreamError struct {\n \tStreamID uint32\n \tCode     http2ErrCode\n+\tCause    error // optional additional detail\n+}\n+\n+func http2streamError(id uint32, code http2ErrCode) http2StreamError {\n+\treturn http2StreamError{StreamID: id, Code: code}\n }\n \n func (e http2StreamError) Error() string {\n+\tif e.Cause != nil {\n+\t\treturn fmt.Sprintf(\"stream error: stream ID %d; %v; %v\", e.StreamID, e.Code, e.Cause)\n+\t}\n \treturn fmt.Sprintf(\"stream error: stream ID %d; %v\", e.StreamID, e.Code)\n }\n \n@@ -1105,6 +1124,7 @@ func http2parseDataFrame(fh http2FrameHeader, payload []byte) (http2Frame, error\n var (\n \thttp2errStreamID    = errors.New(\"invalid stream ID\")\n \thttp2errDepStreamID = errors.New(\"invalid dependent stream ID\")\n+\thttp2errPadLength   = errors.New(\"pad length too large\")\n )\n \n func http2validStreamIDOrZero(streamID uint32) bool {\n@@ -1118,18 +1138,40 @@ func http2validStreamID(streamID uint32) bool {\n // WriteData writes a DATA frame.\n //\n // It will perform exactly one Write to the underlying Writer.\n-// It is the caller's responsibility to not call other Write methods concurrently.\n+// It is the caller's responsibility not to violate the maximum frame size\n+// and to not call other Write methods concurrently.\n func (f *http2Framer) WriteData(streamID uint32, endStream bool, data []byte) error {\n+\treturn f.WriteDataPadded(streamID, endStream, data, nil)\n+}\n \n+// WriteData writes a DATA frame with optional padding.\n+//\n+// If pad is nil, the padding bit is not sent.\n+// The length of pad must not exceed 255 bytes.\n+//\n+// It will perform exactly one Write to the underlying Writer.\n+// It is the caller's responsibility not to violate the maximum frame size\n+// and to not call other Write methods concurrently.\n+func (f *http2Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error {\n \tif !http2validStreamID(streamID) && !f.AllowIllegalWrites {\n \t\treturn http2errStreamID\n \t}\n+\tif len(pad) > 255 {\n+\t\treturn http2errPadLength\n+\t}\n \tvar flags http2Flags\n \tif endStream {\n \t\tflags |= http2FlagDataEndStream\n \t}\n+\tif pad != nil {\n+\t\tflags |= http2FlagDataPadded\n+\t}\n \tf.startWrite(http2FrameData, flags, streamID)\n+\tif pad != nil {\n+\t\tf.wbuf = append(f.wbuf, byte(len(pad)))\n+\t}\n \tf.wbuf = append(f.wbuf, data...)\n+\tf.wbuf = append(f.wbuf, pad...)\n \treturn f.endWrite()\n }\n \n@@ -1333,7 +1375,7 @@ func http2parseWindowUpdateFrame(fh http2FrameHeader, p []byte) (http2Frame, err\n \t\tif fh.StreamID == 0 {\n \t\t\treturn nil, http2ConnectionError(http2ErrCodeProtocol)\n \t\t}\n-\t\treturn nil, http2StreamError{fh.StreamID, http2ErrCodeProtocol}\n+\t\treturn nil, http2streamError(fh.StreamID, http2ErrCodeProtocol)\n \t}\n \treturn &http2WindowUpdateFrame{\n \t\thttp2FrameHeader: fh,\n@@ -1411,7 +1453,7 @@ func http2parseHeadersFrame(fh http2FrameHeader, p []byte) (_ http2Frame, err er\n \t\t}\n \t}\n \tif len(p)-int(padLength) <= 0 {\n-\t\treturn nil, http2StreamError{fh.StreamID, http2ErrCodeProtocol}\n+\t\treturn nil, http2streamError(fh.StreamID, http2ErrCodeProtocol)\n \t}\n \thf.headerFragBuf = p[:len(p)-int(padLength)]\n \treturn hf, nil\n@@ -1878,6 +1920,9 @@ func (fr *http2Framer) readMetaFrame(hf *http2HeadersFrame) (*http2MetaHeadersFr\n \thdec.SetEmitEnabled(true)\n \thdec.SetMaxStringLength(fr.maxHeaderStringLen())\n \thdec.SetEmitFunc(func(hf hpack.HeaderField) {\n+\t\tif http2VerboseLogs && http2logFrameReads {\n+\t\t\tlog.Printf(\"http2: decoded hpack field %+v\", hf)\n+\t\t}\n \t\tif !httplex.ValidHeaderFieldValue(hf.Value) {\n \t\t\tinvalid = http2headerFieldValueError(hf.Value)\n \t\t}\n@@ -1936,11 +1981,17 @@ func (fr *http2Framer) readMetaFrame(hf *http2HeadersFrame) (*http2MetaHeadersFr\n \t}\n \tif invalid != nil {\n \t\tfr.errDetail = invalid\n-\t\treturn nil, http2StreamError{mh.StreamID, http2ErrCodeProtocol}\n+\t\tif http2VerboseLogs {\n+\t\t\tlog.Printf(\"http2: invalid header: %v\", invalid)\n+\t\t}\n+\t\treturn nil, http2StreamError{mh.StreamID, http2ErrCodeProtocol, invalid}\n \t}\n \tif err := mh.checkPseudos(); err != nil {\n \t\tfr.errDetail = err\n-\t\treturn nil, http2StreamError{mh.StreamID, http2ErrCodeProtocol}\n+\t\tif http2VerboseLogs {\n+\t\t\tlog.Printf(\"http2: invalid pseudo headers: %v\", err)\n+\t\t}\n+\t\treturn nil, http2StreamError{mh.StreamID, http2ErrCodeProtocol, err}\n \t}\n \treturn mh, nil\n }\n@@ -3571,7 +3622,7 @@ func (sc *http2serverConn) wroteFrame(res http2frameWriteResult) {\n \t\tcase http2stateOpen:\n \n \t\t\tst.state = http2stateHalfClosedLocal\n-\t\t\terrCancel := http2StreamError{st.id, http2ErrCodeCancel}\n+\t\t\terrCancel := http2streamError(st.id, http2ErrCodeCancel)\n \t\t\tsc.resetStream(errCancel)\n \t\tcase http2stateHalfClosedRemote:\n \t\t\tsc.closeStream(st, http2errHandlerComplete)\n@@ -3764,7 +3815,7 @@ func (sc *http2serverConn) processWindowUpdate(f *http2WindowUpdateFrame) error\n \t\t\treturn nil\n \t\t}\n \t\tif !st.flow.add(int32(f.Increment)) {\n-\t\t\treturn http2StreamError{f.StreamID, http2ErrCodeFlowControl}\n+\t\t\treturn http2streamError(f.StreamID, http2ErrCodeFlowControl)\n \t\t}\n \tdefault:\n \t\tif !sc.flow.add(int32(f.Increment)) {\n@@ -3786,7 +3837,7 @@ func (sc *http2serverConn) processResetStream(f *http2RSTStreamFrame) error {\n \tif st != nil {\n \t\tst.gotReset = true\n \t\tst.cancelCtx()\n-\t\tsc.closeStream(st, http2StreamError{f.StreamID, f.ErrCode})\n+\t\tsc.closeStream(st, http2streamError(f.StreamID, f.ErrCode))\n \t}\n \treturn nil\n }\n@@ -3803,6 +3854,9 @@ func (sc *http2serverConn) closeStream(st *http2stream, err error) {\n \t}\n \tdelete(sc.streams, st.id)\n \tif p := st.body; p != nil {\n+\n+\t\tsc.sendWindowUpdate(nil, p.Len())\n+\n \t\tp.CloseWithError(err)\n \t}\n \tst.cw.Close()\n@@ -3879,36 +3933,51 @@ func (sc *http2serverConn) processSettingInitialWindowSize(val uint32) error {\n \n func (sc *http2serverConn) processData(f *http2DataFrame) error {\n \tsc.serveG.check()\n+\tdata := f.Data()\n \n \tid := f.Header().StreamID\n \tst, ok := sc.streams[id]\n \tif !ok || st.state != http2stateOpen || st.gotTrailerHeader {\n \n-\t\treturn http2StreamError{id, http2ErrCodeStreamClosed}\n+\t\tif sc.inflow.available() < int32(f.Length) {\n+\t\t\treturn http2streamError(id, http2ErrCodeFlowControl)\n+\t\t}\n+\n+\t\tsc.inflow.take(int32(f.Length))\n+\t\tsc.sendWindowUpdate(nil, int(f.Length))\n+\n+\t\treturn http2streamError(id, http2ErrCodeStreamClosed)\n \t}\n \tif st.body == nil {\n \t\tpanic(\"internal error: should have a body in this state\")\n \t}\n-\tdata := f.Data()\n \n \tif st.declBodyBytes != -1 && st.bodyBytes+int64(len(data)) > st.declBodyBytes {\n \t\tst.body.CloseWithError(fmt.Errorf(\"sender tried to send more than declared Content-Length of %d bytes\", st.declBodyBytes))\n-\t\treturn http2StreamError{id, http2ErrCodeStreamClosed}\n+\t\treturn http2streamError(id, http2ErrCodeStreamClosed)\n \t}\n-\tif len(data) > 0 {\n+\tif f.Length > 0 {\n \n-\t\tif int(st.inflow.available()) < len(data) {\n-\t\t\treturn http2StreamError{id, http2ErrCodeFlowControl}\n+\t\tif st.inflow.available() < int32(f.Length) {\n+\t\t\treturn http2streamError(id, http2ErrCodeFlowControl)\n \t\t}\n-\t\tst.inflow.take(int32(len(data)))\n-\t\twrote, err := st.body.Write(data)\n-\t\tif err != nil {\n-\t\t\treturn http2StreamError{id, http2ErrCodeStreamClosed}\n+\t\tst.inflow.take(int32(f.Length))\n+\n+\t\tif len(data) > 0 {\n+\t\t\twrote, err := st.body.Write(data)\n+\t\t\tif err != nil {\n+\t\t\t\treturn http2streamError(id, http2ErrCodeStreamClosed)\n+\t\t\t}\n+\t\t\tif wrote != len(data) {\n+\t\t\t\tpanic(\"internal error: bad Writer\")\n+\t\t\t}\n+\t\t\tst.bodyBytes += int64(len(data))\n \t\t}\n-\t\tif wrote != len(data) {\n-\t\t\tpanic(\"internal error: bad Writer\")\n+\n+\t\tif pad := int32(f.Length) - int32(len(data)); pad > 0 {\n+\t\t\tsc.sendWindowUpdate32(nil, pad)\n+\t\t\tsc.sendWindowUpdate32(st, pad)\n \t\t}\n-\t\tst.bodyBytes += int64(len(data))\n \t}\n \tif f.StreamEnded() {\n \t\tst.endStream()\n@@ -3995,10 +4064,10 @@ func (sc *http2serverConn) processHeaders(f *http2MetaHeadersFrame) error {\n \n \t\tif sc.unackedSettings == 0 {\n \n-\t\t\treturn http2StreamError{st.id, http2ErrCodeProtocol}\n+\t\t\treturn http2streamError(st.id, http2ErrCodeProtocol)\n \t\t}\n \n-\t\treturn http2StreamError{st.id, http2ErrCodeRefusedStream}\n+\t\treturn http2streamError(st.id, http2ErrCodeRefusedStream)\n \t}\n \n \trw, req, err := sc.newWriterAndRequest(st, f)\n@@ -4032,18 +4101,18 @@ func (st *http2stream) processTrailerHeaders(f *http2MetaHeadersFrame) error {\n \t}\n \tst.gotTrailerHeader = true\n \tif !f.StreamEnded() {\n-\t\treturn http2StreamError{st.id, http2ErrCodeProtocol}\n+\t\treturn http2streamError(st.id, http2ErrCodeProtocol)\n \t}\n \n \tif len(f.PseudoFields()) > 0 {\n-\t\treturn http2StreamError{st.id, http2ErrCodeProtocol}\n+\t\treturn http2streamError(st.id, http2ErrCodeProtocol)\n \t}\n \tif st.trailer != nil {\n \t\tfor _, hf := range f.RegularFields() {\n \t\t\tkey := sc.canonicalHeader(hf.Name)\n \t\t\tif !http2ValidTrailerHeader(key) {\n \n-\t\t\t\treturn http2StreamError{st.id, http2ErrCodeProtocol}\n+\t\t\t\treturn http2streamError(st.id, http2ErrCodeProtocol)\n \t\t\t}\n \t\t\tst.trailer[key] = append(st.trailer[key], hf.Value)\n \t\t}\n@@ -4097,18 +4166,18 @@ func (sc *http2serverConn) newWriterAndRequest(st *http2stream, f *http2MetaHead\n \tisConnect := method == \"CONNECT\"\n \tif isConnect {\n \t\tif path != \"\" || scheme != \"\" || authority == \"\" {\n-\t\t\treturn nil, nil, http2StreamError{f.StreamID, http2ErrCodeProtocol}\n+\t\t\treturn nil, nil, http2streamError(f.StreamID, http2ErrCodeProtocol)\n \t\t}\n \t} else if method == \"\" || path == \"\" ||\n \t\t(scheme != \"https\" && scheme != \"http\") {\n \n-\t\treturn nil, nil, http2StreamError{f.StreamID, http2ErrCodeProtocol}\n+\t\treturn nil, nil, http2streamError(f.StreamID, http2ErrCodeProtocol)\n \t}\n \n \tbodyOpen := !f.StreamEnded()\n \tif method == \"HEAD\" && bodyOpen {\n \n-\t\treturn nil, nil, http2StreamError{f.StreamID, http2ErrCodeProtocol}\n+\t\treturn nil, nil, http2streamError(f.StreamID, http2ErrCodeProtocol)\n \t}\n \tvar tlsState *tls.ConnectionState // nil if not scheme https\n \n@@ -4165,7 +4234,7 @@ func (sc *http2serverConn) newWriterAndRequest(st *http2stream, f *http2MetaHead\n \t\tvar err error\n \t\turl_, err = url.ParseRequestURI(path)\n \t\tif err != nil {\n-\t\t\treturn nil, nil, http2StreamError{f.StreamID, http2ErrCodeProtocol}\n+\t\t\treturn nil, nil, http2streamError(f.StreamID, http2ErrCodeProtocol)\n \t\t}\n \t\trequestURI = path\n \t}\n@@ -4919,35 +4988,37 @@ func (t *http2Transport) initConnPool() {\n // ClientConn is the state of a single HTTP/2 client connection to an\n // HTTP/2 server.\n type http2ClientConn struct {\n-\tt        *http2Transport\n-\ttconn    net.Conn             // usually *tls.Conn, except specialized impls\n-\ttlsState *tls.ConnectionState // nil only for specialized impls\n+\tt         *http2Transport\n+\ttconn     net.Conn             // usually *tls.Conn, except specialized impls\n+\ttlsState  *tls.ConnectionState // nil only for specialized impls\n+\tsingleUse bool                 // whether being used for a single http.Request\n \n \t// readLoop goroutine fields:\n \treaderDone chan struct{} // closed on error\n \treaderErr  error         // set before readerDone is closed\n \n-\tmu           sync.Mutex // guards following\n-\tcond         *sync.Cond // hold mu; broadcast on flow/closed changes\n-\tflow         http2flow  // our conn-level flow control quota (cs.flow is per stream)\n-\tinflow       http2flow  // peer's conn-level flow control\n-\tclosed       bool\n-\tgoAway       *http2GoAwayFrame             // if non-nil, the GoAwayFrame we received\n-\tgoAwayDebug  string                        // goAway frame's debug data, retained as a string\n-\tstreams      map[uint32]*http2clientStream // client-initiated\n-\tnextStreamID uint32\n-\tbw           *bufio.Writer\n-\tbr           *bufio.Reader\n-\tfr           *http2Framer\n-\tlastActive   time.Time\n-\n-\t// Settings from peer:\n+\tmu              sync.Mutex // guards following\n+\tcond            *sync.Cond // hold mu; broadcast on flow/closed changes\n+\tflow            http2flow  // our conn-level flow control quota (cs.flow is per stream)\n+\tinflow          http2flow  // peer's conn-level flow control\n+\tclosed          bool\n+\twantSettingsAck bool                          // we sent a SETTINGS frame and haven't heard back\n+\tgoAway          *http2GoAwayFrame             // if non-nil, the GoAwayFrame we received\n+\tgoAwayDebug     string                        // goAway frame's debug data, retained as a string\n+\tstreams         map[uint32]*http2clientStream // client-initiated\n+\tnextStreamID    uint32\n+\tbw              *bufio.Writer\n+\tbr              *bufio.Reader\n+\tfr              *http2Framer\n+\tlastActive      time.Time\n+\t// Settings from peer: (also guarded by mu)\n \tmaxFrameSize         uint32\n \tmaxConcurrentStreams uint32\n \tinitialWindowSize    uint32\n-\thbuf                 bytes.Buffer // HPACK encoder writes into this\n-\thenc                 *hpack.Encoder\n-\tfreeBuf              [][]byte\n+\n+\thbuf    bytes.Buffer // HPACK encoder writes into this\n+\thenc    *hpack.Encoder\n+\tfreeBuf [][]byte\n \n \twmu  sync.Mutex // held while writing; acquire AFTER mu if holding both\n \twerr error      // first write error that has occurred\n@@ -5117,7 +5188,7 @@ func http2shouldRetryRequest(req *Request, err error) bool {\n \treturn err == http2errClientConnUnusable\n }\n \n-func (t *http2Transport) dialClientConn(addr string) (*http2ClientConn, error) {\n+func (t *http2Transport) dialClientConn(addr string, singleUse bool) (*http2ClientConn, error) {\n \thost, _, err := net.SplitHostPort(addr)\n \tif err != nil {\n \t\treturn nil, err\n@@ -5126,7 +5197,7 @@ func (t *http2Transport) dialClientConn(addr string) (*http2ClientConn, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn t.NewClientConn(tconn)\n+\treturn t.newClientConn(tconn, singleUse)\n }\n \n func (t *http2Transport) newTLSConfig(host string) *tls.Config {\n@@ -5187,14 +5258,10 @@ func (t *http2Transport) expectContinueTimeout() time.Duration {\n }\n \n func (t *http2Transport) NewClientConn(c net.Conn) (*http2ClientConn, error) {\n-\tif http2VerboseLogs {\n-\t\tt.vlogf(\"http2: Transport creating client conn to %v\", c.RemoteAddr())\n-\t}\n-\tif _, err := c.Write(http2clientPreface); err != nil {\n-\t\tt.vlogf(\"client preface write error: %v\", err)\n-\t\treturn nil, err\n-\t}\n+\treturn t.newClientConn(c, false)\n+}\n \n+func (t *http2Transport) newClientConn(c net.Conn, singleUse bool) (*http2ClientConn, error) {\n \tcc := &http2ClientConn{\n \t\tt:                    t,\n \t\ttconn:                c,\n@@ -5204,7 +5271,13 @@ func (t *http2Transport) NewClientConn(c net.Conn) (*http2ClientConn, error) {\n \t\tinitialWindowSize:    65535,\n \t\tmaxConcurrentStreams: 1000,\n \t\tstreams:              make(map[uint32]*http2clientStream),\n+\t\tsingleUse:            singleUse,\n+\t\twantSettingsAck:      true,\n \t}\n+\tif http2VerboseLogs {\n+\t\tt.vlogf(\"http2: Transport creating client conn %p to %v\", cc, c.RemoteAddr())\n+\t}\n+\n \tcc.cond = sync.NewCond(&cc.mu)\n \tcc.flow.add(int32(http2initialWindowSize))\n \n@@ -5228,6 +5301,8 @@ func (t *http2Transport) NewClientConn(c net.Conn) (*http2ClientConn, error) {\n \tif max := t.maxHeaderListSize(); max != 0 {\n \t\tinitialSettings = append(initialSettings, http2Setting{ID: http2SettingMaxHeaderListSize, Val: max})\n \t}\n+\n+\tcc.bw.Write(http2clientPreface)\n \tcc.fr.WriteSettings(initialSettings...)\n \tcc.fr.WriteWindowUpdate(0, http2transportDefaultConnFlow)\n \tcc.inflow.add(http2transportDefaultConnFlow + http2initialWindowSize)\n@@ -5236,32 +5311,6 @@ func (t *http2Transport) NewClientConn(c net.Conn) (*http2ClientConn, error) {\n \t\treturn nil, cc.werr\n \t}\n \n-\tf, err := cc.fr.ReadFrame()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tsf, ok := f.(*http2SettingsFrame)\n-\tif !ok {\n-\t\treturn nil, fmt.Errorf(\"expected settings frame, got: %T\", f)\n-\t}\n-\tcc.fr.WriteSettingsAck()\n-\tcc.bw.Flush()\n-\n-\tsf.ForeachSetting(func(s http2Setting) error {\n-\t\tswitch s.ID {\n-\t\tcase http2SettingMaxFrameSize:\n-\t\t\tcc.maxFrameSize = s.Val\n-\t\tcase http2SettingMaxConcurrentStreams:\n-\t\t\tcc.maxConcurrentStreams = s.Val\n-\t\tcase http2SettingInitialWindowSize:\n-\t\t\tcc.initialWindowSize = s.Val\n-\t\tdefault:\n-\n-\t\t\tt.vlogf(\"Unhandled Setting: %v\", s)\n-\t\t}\n-\t\treturn nil\n-\t})\n-\n \tgo cc.readLoop()\n \treturn cc, nil\n }\n@@ -5288,9 +5337,12 @@ func (cc *http2ClientConn) CanTakeNewRequest() bool {\n }\n \n func (cc *http2ClientConn) canTakeNewRequestLocked() bool {\n+\tif cc.singleUse && cc.nextStreamID > 1 {\n+\t\treturn false\n+\t}\n \treturn cc.goAway == nil && !cc.closed &&\n \t\tint64(len(cc.streams)+1) < int64(cc.maxConcurrentStreams) &&\n-\t\tcc.nextStreamID < 2147483647\n+\t\tcc.nextStreamID < math.MaxInt32\n }\n \n func (cc *http2ClientConn) closeIfIdle() {\n@@ -5300,9 +5352,13 @@ func (cc *http2ClientConn) closeIfIdle() {\n \t\treturn\n \t}\n \tcc.closed = true\n+\tnextID := cc.nextStreamID\n \n \tcc.mu.Unlock()\n \n+\tif http2VerboseLogs {\n+\t\tcc.vlogf(\"http2: Transport closing idle conn %p (forSingleUse=%v, maxStream=%v)\", cc, cc.singleUse, nextID-2)\n+\t}\n \tcc.tconn.Close()\n }\n \n@@ -5404,12 +5460,15 @@ func http2bodyAndLength(req *Request) (body io.Reader, contentLen int64) {\n \t// We have a body but a zero content length. Test to see if\n \t// it's actually zero or just unset.\n \tvar buf [1]byte\n-\tn, rerr := io.ReadFull(body, buf[:])\n+\tn, rerr := body.Read(buf[:])\n \tif rerr != nil && rerr != io.EOF {\n \t\treturn http2errorReader{rerr}, -1\n \t}\n \tif n == 1 {\n \n+\t\tif rerr == io.EOF {\n+\t\t\treturn bytes.NewReader(buf[:]), 1\n+\t\t}\n \t\treturn io.MultiReader(bytes.NewReader(buf[:]), body), -1\n \t}\n \n@@ -5494,9 +5553,10 @@ func (cc *http2ClientConn) RoundTrip(req *Request) (*Response, error) {\n \tbodyWritten := false\n \tctx := http2reqContext(req)\n \n-\treFunc := func(re http2resAndError) (*Response, error) {\n+\thandleReadLoopResponse := func(re http2resAndError) (*Response, error) {\n \t\tres := re.res\n \t\tif re.err != nil || res.StatusCode > 299 {\n+\n \t\t\tbodyWriter.cancel()\n \t\t\tcs.abortRequestBodyWrite(http2errStopReqBodyWrite)\n \t\t}\n@@ -5512,7 +5572,7 @@ func (cc *http2ClientConn) RoundTrip(req *Request) (*Response, error) {\n \tfor {\n \t\tselect {\n \t\tcase re := <-readLoopResCh:\n-\t\t\treturn reFunc(re)\n+\t\t\treturn handleReadLoopResponse(re)\n \t\tcase <-respHeaderTimer:\n \t\t\tcc.forgetStreamID(cs.ID)\n \t\t\tif !hasBody || bodyWritten {\n@@ -5525,7 +5585,7 @@ func (cc *http2ClientConn) RoundTrip(req *Request) (*Response, error) {\n \t\tcase <-ctx.Done():\n \t\t\tselect {\n \t\t\tcase re := <-readLoopResCh:\n-\t\t\t\treturn reFunc(re)\n+\t\t\t\treturn handleReadLoopResponse(re)\n \t\t\tdefault:\n \t\t\t}\n \t\t\tcc.forgetStreamID(cs.ID)\n@@ -5539,7 +5599,7 @@ func (cc *http2ClientConn) RoundTrip(req *Request) (*Response, error) {\n \t\tcase <-req.Cancel:\n \t\t\tselect {\n \t\t\tcase re := <-readLoopResCh:\n-\t\t\t\treturn reFunc(re)\n+\t\t\t\treturn handleReadLoopResponse(re)\n \t\t\tdefault:\n \t\t\t}\n \t\t\tcc.forgetStreamID(cs.ID)\n@@ -5553,14 +5613,15 @@ func (cc *http2ClientConn) RoundTrip(req *Request) (*Response, error) {\n \t\tcase <-cs.peerReset:\n \t\t\tselect {\n \t\t\tcase re := <-readLoopResCh:\n-\t\t\t\treturn reFunc(re)\n+\t\t\t\treturn handleReadLoopResponse(re)\n \t\t\tdefault:\n \t\t\t}\n \t\t\treturn nil, cs.resetErr\n \t\tcase err := <-bodyWriter.resc:\n+\n \t\t\tselect {\n \t\t\tcase re := <-readLoopResCh:\n-\t\t\t\treturn reFunc(re)\n+\t\t\t\treturn handleReadLoopResponse(re)\n \t\t\tdefault:\n \t\t\t}\n \t\t\tif err != nil {\n@@ -5670,26 +5731,29 @@ func (cs *http2clientStream) writeRequestBody(body io.Reader, bodyCloser io.Clos\n \t\t}\n \t}\n \n+\tif sentEnd {\n+\n+\t\treturn nil\n+\t}\n+\n+\tvar trls []byte\n+\tif hasTrailers {\n+\t\tcc.mu.Lock()\n+\t\tdefer cc.mu.Unlock()\n+\t\ttrls = cc.encodeTrailers(req)\n+\t}\n+\n \tcc.wmu.Lock()\n-\tif !sentEnd {\n-\t\tvar trls []byte\n-\t\tif hasTrailers {\n-\t\t\tcc.mu.Lock()\n-\t\t\ttrls = cc.encodeTrailers(req)\n-\t\t\tcc.mu.Unlock()\n-\t\t}\n+\tdefer cc.wmu.Unlock()\n \n-\t\tif len(trls) > 0 {\n-\t\t\terr = cc.writeHeaders(cs.ID, true, trls)\n-\t\t} else {\n-\t\t\terr = cc.fr.WriteData(cs.ID, true, nil)\n-\t\t}\n+\tif len(trls) > 0 {\n+\t\terr = cc.writeHeaders(cs.ID, true, trls)\n+\t} else {\n+\t\terr = cc.fr.WriteData(cs.ID, true, nil)\n \t}\n \tif ferr := cc.bw.Flush(); ferr != nil && err == nil {\n \t\terr = ferr\n \t}\n-\tcc.wmu.Unlock()\n-\n \treturn err\n }\n \n@@ -5918,6 +5982,14 @@ func (e http2GoAwayError) Error() string {\n \t\te.LastStreamID, e.ErrCode, e.DebugData)\n }\n \n+func http2isEOFOrNetReadError(err error) bool {\n+\tif err == io.EOF {\n+\t\treturn true\n+\t}\n+\tne, ok := err.(*net.OpError)\n+\treturn ok && ne.Op == \"read\"\n+}\n+\n func (rl *http2clientConnReadLoop) cleanup() {\n \tcc := rl.cc\n \tdefer cc.tconn.Close()\n@@ -5926,16 +5998,14 @@ func (rl *http2clientConnReadLoop) cleanup() {\n \n \terr := cc.readerErr\n \tcc.mu.Lock()\n-\tif err == io.EOF {\n-\t\tif cc.goAway != nil {\n-\t\t\terr = http2GoAwayError{\n-\t\t\t\tLastStreamID: cc.goAway.LastStreamID,\n-\t\t\t\tErrCode:      cc.goAway.ErrCode,\n-\t\t\t\tDebugData:    cc.goAwayDebug,\n-\t\t\t}\n-\t\t} else {\n-\t\t\terr = io.ErrUnexpectedEOF\n+\tif cc.goAway != nil && http2isEOFOrNetReadError(err) {\n+\t\terr = http2GoAwayError{\n+\t\t\tLastStreamID: cc.goAway.LastStreamID,\n+\t\t\tErrCode:      cc.goAway.ErrCode,\n+\t\t\tDebugData:    cc.goAwayDebug,\n \t\t}\n+\t} else if err == io.EOF {\n+\t\terr = io.ErrUnexpectedEOF\n \t}\n \tfor _, cs := range rl.activeRes {\n \t\tcs.bufPipe.CloseWithError(err)\n@@ -5954,16 +6024,21 @@ func (rl *http2clientConnReadLoop) cleanup() {\n \n func (rl *http2clientConnReadLoop) run() error {\n \tcc := rl.cc\n-\trl.closeWhenIdle = cc.t.disableKeepAlives()\n+\trl.closeWhenIdle = cc.t.disableKeepAlives() || cc.singleUse\n \tgotReply := false\n+\tgotSettings := false\n \tfor {\n \t\tf, err := cc.fr.ReadFrame()\n \t\tif err != nil {\n-\t\t\tcc.vlogf(\"Transport readFrame error: (%T) %v\", err, err)\n+\t\t\tcc.vlogf(\"http2: Transport readFrame error on conn %p: (%T) %v\", cc, err, err)\n \t\t}\n \t\tif se, ok := err.(http2StreamError); ok {\n \t\t\tif cs := cc.streamByID(se.StreamID, true); cs != nil {\n-\t\t\t\trl.endStreamError(cs, cc.fr.errDetail)\n+\t\t\t\tcs.cc.writeStreamReset(cs.ID, se.Code, err)\n+\t\t\t\tif se.Cause == nil {\n+\t\t\t\t\tse.Cause = cc.fr.errDetail\n+\t\t\t\t}\n+\t\t\t\trl.endStreamError(cs, se)\n \t\t\t}\n \t\t\tcontinue\n \t\t} else if err != nil {\n@@ -5972,6 +6047,13 @@ func (rl *http2clientConnReadLoop) run() error {\n \t\tif http2VerboseLogs {\n \t\t\tcc.vlogf(\"http2: Transport received %s\", http2summarizeFrame(f))\n \t\t}\n+\t\tif !gotSettings {\n+\t\t\tif _, ok := f.(*http2SettingsFrame); !ok {\n+\t\t\t\tcc.logf(\"protocol error: received %T before a SETTINGS frame\", f)\n+\t\t\t\treturn http2ConnectionError(http2ErrCodeProtocol)\n+\t\t\t}\n+\t\t\tgotSettings = true\n+\t\t}\n \t\tmaybeIdle := false\n \n \t\tswitch f := f.(type) {\n@@ -6000,6 +6082,9 @@ func (rl *http2clientConnReadLoop) run() error {\n \t\t\tcc.logf(\"Transport: unhandled response frame type %T\", f)\n \t\t}\n \t\tif err != nil {\n+\t\t\tif http2VerboseLogs {\n+\t\t\t\tcc.vlogf(\"http2: Transport conn %p received error from processing frame %v: %v\", cc, http2summarizeFrame(f), err)\n+\t\t\t}\n \t\t\treturn err\n \t\t}\n \t\tif rl.closeWhenIdle && gotReply && maybeIdle && len(rl.activeRes) == 0 {\n@@ -6238,17 +6323,35 @@ var http2errClosedResponseBody = errors.New(\"http2: response body closed\")\n \n func (b http2transportResponseBody) Close() error {\n \tcs := b.cs\n-\tif cs.bufPipe.Err() != io.EOF {\n+\tcc := cs.cc\n \n-\t\tcs.cc.writeStreamReset(cs.ID, http2ErrCodeCancel, nil)\n+\tserverSentStreamEnd := cs.bufPipe.Err() == io.EOF\n+\tunread := cs.bufPipe.Len()\n+\n+\tif unread > 0 || !serverSentStreamEnd {\n+\t\tcc.mu.Lock()\n+\t\tcc.wmu.Lock()\n+\t\tif !serverSentStreamEnd {\n+\t\t\tcc.fr.WriteRSTStream(cs.ID, http2ErrCodeCancel)\n+\t\t}\n+\n+\t\tif unread > 0 {\n+\t\t\tcc.inflow.add(int32(unread))\n+\t\t\tcc.fr.WriteWindowUpdate(0, uint32(unread))\n+\t\t}\n+\t\tcc.bw.Flush()\n+\t\tcc.wmu.Unlock()\n+\t\tcc.mu.Unlock()\n \t}\n+\n \tcs.bufPipe.BreakWithError(http2errClosedResponseBody)\n \treturn nil\n }\n \n func (rl *http2clientConnReadLoop) processData(f *http2DataFrame) error {\n \tcc := rl.cc\n \tcs := cc.streamByID(f.StreamID, f.StreamEnded())\n+\tdata := f.Data()\n \tif cs == nil {\n \t\tcc.mu.Lock()\n \t\tneverSent := cc.nextStreamID\n@@ -6259,27 +6362,49 @@ func (rl *http2clientConnReadLoop) processData(f *http2DataFrame) error {\n \t\t\treturn http2ConnectionError(http2ErrCodeProtocol)\n \t\t}\n \n+\t\tif f.Length > 0 {\n+\t\t\tcc.mu.Lock()\n+\t\t\tcc.inflow.add(int32(f.Length))\n+\t\t\tcc.mu.Unlock()\n+\n+\t\t\tcc.wmu.Lock()\n+\t\t\tcc.fr.WriteWindowUpdate(0, uint32(f.Length))\n+\t\t\tcc.bw.Flush()\n+\t\t\tcc.wmu.Unlock()\n+\t\t}\n \t\treturn nil\n \t}\n-\tif data := f.Data(); len(data) > 0 {\n-\t\tif cs.bufPipe.b == nil {\n+\tif f.Length > 0 {\n+\t\tif len(data) > 0 && cs.bufPipe.b == nil {\n \n \t\t\tcc.logf(\"http2: Transport received DATA frame for closed stream; closing connection\")\n \t\t\treturn http2ConnectionError(http2ErrCodeProtocol)\n \t\t}\n \n \t\tcc.mu.Lock()\n-\t\tif cs.inflow.available() >= int32(len(data)) {\n-\t\t\tcs.inflow.take(int32(len(data)))\n+\t\tif cs.inflow.available() >= int32(f.Length) {\n+\t\t\tcs.inflow.take(int32(f.Length))\n \t\t} else {\n \t\t\tcc.mu.Unlock()\n \t\t\treturn http2ConnectionError(http2ErrCodeFlowControl)\n \t\t}\n+\n+\t\tif pad := int32(f.Length) - int32(len(data)); pad > 0 {\n+\t\t\tcs.inflow.add(pad)\n+\t\t\tcc.inflow.add(pad)\n+\t\t\tcc.wmu.Lock()\n+\t\t\tcc.fr.WriteWindowUpdate(0, uint32(pad))\n+\t\t\tcc.fr.WriteWindowUpdate(cs.ID, uint32(pad))\n+\t\t\tcc.bw.Flush()\n+\t\t\tcc.wmu.Unlock()\n+\t\t}\n \t\tcc.mu.Unlock()\n \n-\t\tif _, err := cs.bufPipe.Write(data); err != nil {\n-\t\t\trl.endStreamError(cs, err)\n-\t\t\treturn err\n+\t\tif len(data) > 0 {\n+\t\t\tif _, err := cs.bufPipe.Write(data); err != nil {\n+\t\t\t\trl.endStreamError(cs, err)\n+\t\t\t\treturn err\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -6304,9 +6429,14 @@ func (rl *http2clientConnReadLoop) endStreamError(cs *http2clientStream, err err\n \t}\n \tcs.bufPipe.closeWithErrorAndCode(err, code)\n \tdelete(rl.activeRes, cs.ID)\n-\tif cs.req.Close || cs.req.Header.Get(\"Connection\") == \"close\" {\n+\tif http2isConnectionCloseRequest(cs.req) {\n \t\trl.closeWhenIdle = true\n \t}\n+\n+\tselect {\n+\tcase cs.resc <- http2resAndError{err: err}:\n+\tdefault:\n+\t}\n }\n \n func (cs *http2clientStream) copyTrailers() {\n@@ -6334,21 +6464,50 @@ func (rl *http2clientConnReadLoop) processSettings(f *http2SettingsFrame) error\n \tcc := rl.cc\n \tcc.mu.Lock()\n \tdefer cc.mu.Unlock()\n-\treturn f.ForeachSetting(func(s http2Setting) error {\n+\n+\tif f.IsAck() {\n+\t\tif cc.wantSettingsAck {\n+\t\t\tcc.wantSettingsAck = false\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn http2ConnectionError(http2ErrCodeProtocol)\n+\t}\n+\n+\terr := f.ForeachSetting(func(s http2Setting) error {\n \t\tswitch s.ID {\n \t\tcase http2SettingMaxFrameSize:\n \t\t\tcc.maxFrameSize = s.Val\n \t\tcase http2SettingMaxConcurrentStreams:\n \t\t\tcc.maxConcurrentStreams = s.Val\n \t\tcase http2SettingInitialWindowSize:\n \n+\t\t\tif s.Val > math.MaxInt32 {\n+\t\t\t\treturn http2ConnectionError(http2ErrCodeFlowControl)\n+\t\t\t}\n+\n+\t\t\tdelta := int32(s.Val) - int32(cc.initialWindowSize)\n+\t\t\tfor _, cs := range cc.streams {\n+\t\t\t\tcs.flow.add(delta)\n+\t\t\t}\n+\t\t\tcc.cond.Broadcast()\n+\n \t\t\tcc.initialWindowSize = s.Val\n \t\tdefault:\n \n \t\t\tcc.vlogf(\"Unhandled Setting: %v\", s)\n \t\t}\n \t\treturn nil\n \t})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tcc.wmu.Lock()\n+\tdefer cc.wmu.Unlock()\n+\n+\tcc.fr.WriteSettingsAck()\n+\tcc.bw.Flush()\n+\treturn cc.werr\n }\n \n func (rl *http2clientConnReadLoop) processWindowUpdate(f *http2WindowUpdateFrame) error {\n@@ -6382,7 +6541,7 @@ func (rl *http2clientConnReadLoop) processResetStream(f *http2RSTStreamFrame) er\n \tcase <-cs.peerReset:\n \n \tdefault:\n-\t\terr := http2StreamError{cs.ID, f.ErrCode}\n+\t\terr := http2streamError(cs.ID, f.ErrCode)\n \t\tcs.resetErr = err\n \t\tclose(cs.peerReset)\n \t\tcs.bufPipe.CloseWithError(err)\n@@ -6560,6 +6719,12 @@ func (s http2bodyWriterState) scheduleBodyWrite() {\n \t}\n }\n \n+// isConnectionCloseRequest reports whether req should use its own\n+// connection for a single request and then close the connection.\n+func http2isConnectionCloseRequest(req *Request) bool {\n+\treturn req.Close || httplex.HeaderValuesContainsToken(req.Header[\"Connection\"], \"close\")\n+}\n+\n // writeFramer is implemented by any type that is used to write frames.\n type http2writeFramer interface {\n \twriteFrame(http2writeContext) error"}, {"sha": "13e5f283e4c4d6dbc8285e70ed64885583aed927", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -4716,3 +4716,14 @@ func BenchmarkCloseNotifier(b *testing.B) {\n \t}\n \tb.StopTimer()\n }\n+\n+// Verify this doesn't race (Issue 16505)\n+func TestConcurrentServerServe(t *testing.T) {\n+\tfor i := 0; i < 100; i++ {\n+\t\tln1 := &oneConnListener{conn: nil}\n+\t\tln2 := &oneConnListener{conn: nil}\n+\t\tsrv := Server{}\n+\t\tgo func() { srv.Serve(ln1) }()\n+\t\tgo func() { srv.Serve(ln2) }()\n+\t}\n+}"}, {"sha": "89574a8b36e7e9300df967816621f2b59b35da0f", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -2129,8 +2129,8 @@ type Server struct {\n \tErrorLog *log.Logger\n \n \tdisableKeepAlives int32     // accessed atomically.\n-\tnextProtoOnce     sync.Once // guards initialization of TLSNextProto in Serve\n-\tnextProtoErr      error\n+\tnextProtoOnce     sync.Once // guards setupHTTP2_* init\n+\tnextProtoErr      error     // result of http2.ConfigureServer if used\n }\n \n // A ConnState represents the state of a client connection to a server.\n@@ -2260,10 +2260,8 @@ func (srv *Server) Serve(l net.Listener) error {\n \t}\n \tvar tempDelay time.Duration // how long to sleep on accept failure\n \n-\tif srv.shouldConfigureHTTP2ForServe() {\n-\t\tif err := srv.setupHTTP2(); err != nil {\n-\t\t\treturn err\n-\t\t}\n+\tif err := srv.setupHTTP2_Serve(); err != nil {\n+\t\treturn err\n \t}\n \n \t// TODO: allow changing base context? can't imagine concrete\n@@ -2408,7 +2406,7 @@ func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error {\n \n \t// Setup HTTP/2 before srv.Serve, to initialize srv.TLSConfig\n \t// before we clone it and create the TLS Listener.\n-\tif err := srv.setupHTTP2(); err != nil {\n+\tif err := srv.setupHTTP2_ListenAndServeTLS(); err != nil {\n \t\treturn err\n \t}\n \n@@ -2436,14 +2434,36 @@ func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error {\n \treturn srv.Serve(tlsListener)\n }\n \n-func (srv *Server) setupHTTP2() error {\n+// setupHTTP2_ListenAndServeTLS conditionally configures HTTP/2 on\n+// srv and returns whether there was an error setting it up. If it is\n+// not configured for policy reasons, nil is returned.\n+func (srv *Server) setupHTTP2_ListenAndServeTLS() error {\n \tsrv.nextProtoOnce.Do(srv.onceSetNextProtoDefaults)\n \treturn srv.nextProtoErr\n }\n \n+// setupHTTP2_Serve is called from (*Server).Serve and conditionally\n+// configures HTTP/2 on srv using a more conservative policy than\n+// setupHTTP2_ListenAndServeTLS because Serve may be called\n+// concurrently.\n+//\n+// The tests named TestTransportAutomaticHTTP2* and\n+// TestConcurrentServerServe in server_test.go demonstrate some\n+// of the supported use cases and motivations.\n+func (srv *Server) setupHTTP2_Serve() error {\n+\tsrv.nextProtoOnce.Do(srv.onceSetNextProtoDefaults_Serve)\n+\treturn srv.nextProtoErr\n+}\n+\n+func (srv *Server) onceSetNextProtoDefaults_Serve() {\n+\tif srv.shouldConfigureHTTP2ForServe() {\n+\t\tsrv.onceSetNextProtoDefaults()\n+\t}\n+}\n+\n // onceSetNextProtoDefaults configures HTTP/2, if the user hasn't\n // configured otherwise. (by setting srv.TLSNextProto non-nil)\n-// It must only be called via srv.nextProtoOnce (use srv.setupHTTP2).\n+// It must only be called via srv.nextProtoOnce (use srv.setupHTTP2_*).\n func (srv *Server) onceSetNextProtoDefaults() {\n \tif strings.Contains(os.Getenv(\"GODEBUG\"), \"http2server=0\") {\n \t\treturn"}, {"sha": "1f0763471b8e2cfed689101ea40c40cd0d93070b", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -383,6 +383,11 @@ func (t *Transport) RoundTrip(req *Request) (*Response, error) {\n \t\t\treturn resp, nil\n \t\t}\n \t\tif !pconn.shouldRetryRequest(req, err) {\n+\t\t\t// Issue 16465: return underlying net.Conn.Read error from peek,\n+\t\t\t// as we've historically done.\n+\t\t\tif e, ok := err.(transportReadFromServerError); ok {\n+\t\t\t\terr = e.err\n+\t\t\t}\n \t\t\treturn nil, err\n \t\t}\n \t\ttestHookRoundTripRetried()\n@@ -393,6 +398,15 @@ func (t *Transport) RoundTrip(req *Request) (*Response, error) {\n // HTTP request on a new connection. The non-nil input error is the\n // error from roundTrip.\n func (pc *persistConn) shouldRetryRequest(req *Request, err error) bool {\n+\tif err == http2ErrNoCachedConn {\n+\t\t// Issue 16582: if the user started a bunch of\n+\t\t// requests at once, they can all pick the same conn\n+\t\t// and violate the server's max concurrent streams.\n+\t\t// Instead, match the HTTP/1 behavior for now and dial\n+\t\t// again to get a new TCP connection, rather than failing\n+\t\t// this request.\n+\t\treturn true\n+\t}\n \tif err == errMissingHost {\n \t\t// User error.\n \t\treturn false\n@@ -415,11 +429,19 @@ func (pc *persistConn) shouldRetryRequest(req *Request, err error) bool {\n \t\t// first, per golang.org/issue/15723\n \t\treturn false\n \t}\n-\tif _, ok := err.(nothingWrittenError); ok {\n+\tswitch err.(type) {\n+\tcase nothingWrittenError:\n \t\t// We never wrote anything, so it's safe to retry.\n \t\treturn true\n+\tcase transportReadFromServerError:\n+\t\t// We got some non-EOF net.Conn.Read failure reading\n+\t\t// the 1st response byte from the server.\n+\t\treturn true\n \t}\n-\tif err == errServerClosedIdle || err == errServerClosedConn {\n+\tif err == errServerClosedIdle {\n+\t\t// The server replied with io.EOF while we were trying to\n+\t\t// read the response. Probably an unfortunately keep-alive\n+\t\t// timeout, just as the client was writing a request.\n \t\treturn true\n \t}\n \treturn false // conservatively\n@@ -476,8 +498,9 @@ func (t *Transport) CloseIdleConnections() {\n // CancelRequest cancels an in-flight request by closing its connection.\n // CancelRequest should only be called after RoundTrip has returned.\n //\n-// Deprecated: Use Request.Cancel instead. CancelRequest cannot cancel\n-// HTTP/2 requests.\n+// Deprecated: Use Request.WithContext to create a request with a\n+// cancelable context instead. CancelRequest cannot cancel HTTP/2\n+// requests.\n func (t *Transport) CancelRequest(req *Request) {\n \tt.reqMu.Lock()\n \tcancel := t.reqCanceler[req]\n@@ -566,10 +589,26 @@ var (\n \terrCloseIdleConns     = errors.New(\"http: CloseIdleConnections called\")\n \terrReadLoopExiting    = errors.New(\"http: persistConn.readLoop exiting\")\n \terrServerClosedIdle   = errors.New(\"http: server closed idle connection\")\n-\terrServerClosedConn   = errors.New(\"http: server closed connection\")\n \terrIdleConnTimeout    = errors.New(\"http: idle connection timeout\")\n+\terrNotCachingH2Conn   = errors.New(\"http: not caching alternate protocol's connections\")\n )\n \n+// transportReadFromServerError is used by Transport.readLoop when the\n+// 1 byte peek read fails and we're actually anticipating a response.\n+// Usually this is just due to the inherent keep-alive shut down race,\n+// where the server closed the connection at the same time the client\n+// wrote. The underlying err field is usually io.EOF or some\n+// ECONNRESET sort of thing which varies by platform. But it might be\n+// the user's custom net.Conn.Read error too, so we carry it along for\n+// them to return from Transport.RoundTrip.\n+type transportReadFromServerError struct {\n+\terr error\n+}\n+\n+func (e transportReadFromServerError) Error() string {\n+\treturn fmt.Sprintf(\"net/http: Transport failed to read from server: %v\", e.err)\n+}\n+\n func (t *Transport) putOrCloseIdleConn(pconn *persistConn) {\n \tif err := t.tryPutIdleConn(pconn); err != nil {\n \t\tpconn.close(err)\n@@ -595,6 +634,9 @@ func (t *Transport) tryPutIdleConn(pconn *persistConn) error {\n \tif pconn.isBroken() {\n \t\treturn errConnBroken\n \t}\n+\tif pconn.alt != nil {\n+\t\treturn errNotCachingH2Conn\n+\t}\n \tpconn.markReused()\n \tkey := pconn.cacheKey\n \n@@ -1293,7 +1335,10 @@ func (pc *persistConn) mapRoundTripErrorFromReadLoop(startBytesWritten int64, er\n \tif pc.isCanceled() {\n \t\treturn errRequestCanceled\n \t}\n-\tif err == errServerClosedIdle || err == errServerClosedConn {\n+\tif err == errServerClosedIdle {\n+\t\treturn err\n+\t}\n+\tif _, ok := err.(transportReadFromServerError); ok {\n \t\treturn err\n \t}\n \tif pc.isBroken() {\n@@ -1314,7 +1359,11 @@ func (pc *persistConn) mapRoundTripErrorAfterClosed(startBytesWritten int64) err\n \t\treturn errRequestCanceled\n \t}\n \terr := pc.closed\n-\tif err == errServerClosedIdle || err == errServerClosedConn {\n+\tif err == errServerClosedIdle {\n+\t\t// Don't decorate\n+\t\treturn err\n+\t}\n+\tif _, ok := err.(transportReadFromServerError); ok {\n \t\t// Don't decorate\n \t\treturn err\n \t}\n@@ -1383,7 +1432,7 @@ func (pc *persistConn) readLoop() {\n \t\tif err == nil {\n \t\t\tresp, err = pc.readResponse(rc, trace)\n \t\t} else {\n-\t\t\terr = errServerClosedConn\n+\t\t\terr = transportReadFromServerError{err}\n \t\t\tcloseErr = err\n \t\t}\n \n@@ -1784,6 +1833,7 @@ func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err err\n \tvar re responseAndError\n \tvar respHeaderTimer <-chan time.Time\n \tcancelChan := req.Request.Cancel\n+\tctxDoneChan := req.Context().Done()\n WaitResponse:\n \tfor {\n \t\ttestHookWaitResLoop()\n@@ -1815,9 +1865,11 @@ WaitResponse:\n \t\tcase <-cancelChan:\n \t\t\tpc.t.CancelRequest(req.Request)\n \t\t\tcancelChan = nil\n-\t\tcase <-req.Context().Done():\n+\t\t\tctxDoneChan = nil\n+\t\tcase <-ctxDoneChan:\n \t\t\tpc.t.CancelRequest(req.Request)\n \t\t\tcancelChan = nil\n+\t\t\tctxDoneChan = nil\n \t\t}\n \t}\n "}, {"sha": "a05ca6ed0d869adc29133824cd48be0fb87770e4", "filename": "libgo/go/net/http/transport_internal_test.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_internal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_internal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_internal_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -46,17 +46,22 @@ func TestTransportPersistConnReadLoopEOF(t *testing.T) {\n \tconn.Close() // simulate the server hanging up on the client\n \n \t_, err = pc.roundTrip(treq)\n-\tif err != errServerClosedConn && err != errServerClosedIdle {\n+\tif !isTransportReadFromServerError(err) && err != errServerClosedIdle {\n \t\tt.Fatalf(\"roundTrip = %#v, %v; want errServerClosedConn or errServerClosedIdle\", err, err)\n \t}\n \n \t<-pc.closech\n \terr = pc.closed\n-\tif err != errServerClosedConn && err != errServerClosedIdle {\n+\tif !isTransportReadFromServerError(err) && err != errServerClosedIdle {\n \t\tt.Fatalf(\"pc.closed = %#v, %v; want errServerClosedConn or errServerClosedIdle\", err, err)\n \t}\n }\n \n+func isTransportReadFromServerError(err error) bool {\n+\t_, ok := err.(transportReadFromServerError)\n+\treturn ok\n+}\n+\n func newLocalListener(t *testing.T) net.Listener {\n \tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n \tif err != nil {"}, {"sha": "298682d04de93a4f727063d5dc20ad509dd586fd", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -3511,6 +3511,100 @@ func TestTransportIdleConnTimeout(t *testing.T) {\n \t}\n }\n \n+// Issue 16208: Go 1.7 crashed after Transport.IdleConnTimeout if an\n+// HTTP/2 connection was established but but its caller no longer\n+// wanted it. (Assuming the connection cache was enabled, which it is\n+// by default)\n+//\n+// This test reproduced the crash by setting the IdleConnTimeout low\n+// (to make the test reasonable) and then making a request which is\n+// canceled by the DialTLS hook, which then also waits to return the\n+// real connection until after the RoundTrip saw the error.  Then we\n+// know the successful tls.Dial from DialTLS will need to go into the\n+// idle pool. Then we give it a of time to explode.\n+func TestIdleConnH2Crash(t *testing.T) {\n+\tcst := newClientServerTest(t, h2Mode, HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\t// nothing\n+\t}))\n+\tdefer cst.close()\n+\n+\tctx, cancel := context.WithCancel(context.Background())\n+\tdefer cancel()\n+\n+\tgotErr := make(chan bool, 1)\n+\n+\tcst.tr.IdleConnTimeout = 5 * time.Millisecond\n+\tcst.tr.DialTLS = func(network, addr string) (net.Conn, error) {\n+\t\tcancel()\n+\t\t<-gotErr\n+\t\tc, err := tls.Dial(network, addr, &tls.Config{\n+\t\t\tInsecureSkipVerify: true,\n+\t\t\tNextProtos:         []string{\"h2\"},\n+\t\t})\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif cs := c.ConnectionState(); cs.NegotiatedProtocol != \"h2\" {\n+\t\t\tt.Errorf(\"protocol = %q; want %q\", cs.NegotiatedProtocol, \"h2\")\n+\t\t\tc.Close()\n+\t\t\treturn nil, errors.New(\"bogus\")\n+\t\t}\n+\t\treturn c, nil\n+\t}\n+\n+\treq, _ := NewRequest(\"GET\", cst.ts.URL, nil)\n+\treq = req.WithContext(ctx)\n+\tres, err := cst.c.Do(req)\n+\tif err == nil {\n+\t\tres.Body.Close()\n+\t\tt.Fatal(\"unexpected success\")\n+\t}\n+\tgotErr <- true\n+\n+\t// Wait for the explosion.\n+\ttime.Sleep(cst.tr.IdleConnTimeout * 10)\n+}\n+\n+type funcConn struct {\n+\tnet.Conn\n+\tread  func([]byte) (int, error)\n+\twrite func([]byte) (int, error)\n+}\n+\n+func (c funcConn) Read(p []byte) (int, error)  { return c.read(p) }\n+func (c funcConn) Write(p []byte) (int, error) { return c.write(p) }\n+func (c funcConn) Close() error                { return nil }\n+\n+// Issue 16465: Transport.RoundTrip should return the raw net.Conn.Read error from Peek\n+// back to the caller.\n+func TestTransportReturnsPeekError(t *testing.T) {\n+\terrValue := errors.New(\"specific error value\")\n+\n+\twrote := make(chan struct{})\n+\tvar wroteOnce sync.Once\n+\n+\ttr := &Transport{\n+\t\tDial: func(network, addr string) (net.Conn, error) {\n+\t\t\tc := funcConn{\n+\t\t\t\tread: func([]byte) (int, error) {\n+\t\t\t\t\t<-wrote\n+\t\t\t\t\treturn 0, errValue\n+\t\t\t\t},\n+\t\t\t\twrite: func(p []byte) (int, error) {\n+\t\t\t\t\twroteOnce.Do(func() { close(wrote) })\n+\t\t\t\t\treturn len(p), nil\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\treturn c, nil\n+\t\t},\n+\t}\n+\t_, err := tr.RoundTrip(httptest.NewRequest(\"GET\", \"http://fake.tld/\", nil))\n+\tif err != errValue {\n+\t\tt.Errorf(\"error = %#v; want %v\", err, errValue)\n+\t}\n+}\n+\n var errFakeRoundTrip = errors.New(\"fake roundtrip\")\n \n type funcRoundTripper func()"}, {"sha": "74b7494c0de8c2be91275b0debf20faa47856763", "filename": "libgo/go/os/wait_waitid.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fos%2Fwait_waitid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fos%2Fwait_waitid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fwait_waitid.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -28,6 +28,12 @@ func (p *Process) blockUntilWaitable() (bool, error) {\n \t_, _, e := syscall.Syscall6(syscall.SYS_WAITID, _P_PID, uintptr(p.Pid), uintptr(unsafe.Pointer(psig)), syscall.WEXITED|syscall.WNOWAIT, 0, 0)\n \truntime.KeepAlive(psig)\n \tif e != 0 {\n+\t\t// waitid has been available since Linux 2.6.9, but\n+\t\t// reportedly is not available in Ubuntu on Windows.\n+\t\t// See issue 16610.\n+\t\tif e == syscall.ENOSYS {\n+\t\t\treturn false, nil\n+\t\t}\n \t\treturn false, NewSyscallError(\"waitid\", e)\n \t}\n \treturn true, nil"}, {"sha": "a7e2e6422bc34fdcb33807998293f2aa734a993f", "filename": "libgo/go/path/filepath/export_windows_test.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fpath%2Ffilepath%2Fexport_windows_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fpath%2Ffilepath%2Fexport_windows_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fexport_windows_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -4,4 +4,7 @@\n \n package filepath\n \n-var ToNorm = toNorm\n+var (\n+\tToNorm   = toNorm\n+\tNormBase = normBase\n+)"}, {"sha": "9c3f287ecbd90e88ca784ac62bf9993e959569b7", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -843,7 +843,7 @@ func TestEvalSymlinks(t *testing.T) {\n \t\tif p, err := filepath.EvalSymlinks(path); err != nil {\n \t\t\tt.Errorf(\"EvalSymlinks(%q) error: %v\", d.path, err)\n \t\t} else if filepath.Clean(p) != filepath.Clean(dest) {\n-\t\t\tt.Errorf(\"Clean(%q)=%q, want %q\", path, p, dest)\n+\t\t\tt.Errorf(\"EvalSymlinks(%q)=%q, want %q\", path, p, dest)\n \t\t}\n \n \t\t// test EvalSymlinks(\".\")\n@@ -875,6 +875,34 @@ func TestEvalSymlinks(t *testing.T) {\n \t\t\tt.Errorf(`EvalSymlinks(\".\") in %q directory returns %q, want \".\" or %q`, d.path, p, want)\n \t\t}()\n \n+\t\t// test EvalSymlinks(\"..\"+path)\n+\t\tfunc() {\n+\t\t\tdefer func() {\n+\t\t\t\terr := os.Chdir(wd)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\terr := os.Chdir(simpleJoin(tmpDir, \"test\"))\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tpath := simpleJoin(\"..\", d.path)\n+\t\t\tdest := simpleJoin(\"..\", d.dest)\n+\t\t\tif filepath.IsAbs(d.dest) || os.IsPathSeparator(d.dest[0]) {\n+\t\t\t\tdest = d.dest\n+\t\t\t}\n+\n+\t\t\tif p, err := filepath.EvalSymlinks(path); err != nil {\n+\t\t\t\tt.Errorf(\"EvalSymlinks(%q) error: %v\", d.path, err)\n+\t\t\t} else if filepath.Clean(p) != filepath.Clean(dest) {\n+\t\t\t\tt.Errorf(\"EvalSymlinks(%q)=%q, want %q\", path, p, dest)\n+\t\t\t}\n+\t\t}()\n+\n \t\t// test EvalSymlinks where parameter is relative path\n \t\tfunc() {\n \t\t\tdefer func() {\n@@ -892,7 +920,7 @@ func TestEvalSymlinks(t *testing.T) {\n \t\t\tif p, err := filepath.EvalSymlinks(d.path); err != nil {\n \t\t\t\tt.Errorf(\"EvalSymlinks(%q) error: %v\", d.path, err)\n \t\t\t} else if filepath.Clean(p) != filepath.Clean(d.dest) {\n-\t\t\t\tt.Errorf(\"Clean(%q)=%q, want %q\", d.path, p, d.dest)\n+\t\t\t\tt.Errorf(\"EvalSymlinks(%q)=%q, want %q\", d.path, p, d.dest)\n \t\t\t}\n \t\t}()\n \t}"}, {"sha": "bb05aabc924292e4d084700c11710300b831c9ef", "filename": "libgo/go/path/filepath/symlink_windows.go", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink_windows.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -22,7 +22,7 @@ func normVolumeName(path string) string {\n \treturn strings.ToUpper(volume)\n }\n \n-// normBase retruns the last element of path.\n+// normBase returns the last element of path with correct case.\n func normBase(path string) (string, error) {\n \tp, err := syscall.UTF16PtrFromString(path)\n \tif err != nil {\n@@ -40,7 +40,24 @@ func normBase(path string) (string, error) {\n \treturn syscall.UTF16ToString(data.FileName[:]), nil\n }\n \n-func toNorm(path string, base func(string) (string, error)) (string, error) {\n+// baseIsDotDot returns whether the last element of path is \"..\".\n+// The given path should be 'Clean'-ed in advance.\n+func baseIsDotDot(path string) bool {\n+\ti := strings.LastIndexByte(path, Separator)\n+\treturn path[i+1:] == \"..\"\n+}\n+\n+// toNorm returns the normalized path that is guranteed to be unique.\n+// It should accept the following formats:\n+//   * UNC paths                              (e.g \\\\server\\share\\foo\\bar)\n+//   * absolute paths                         (e.g C:\\foo\\bar)\n+//   * relative paths begin with drive letter (e.g C:foo\\bar, C:..\\foo\\bar, C:.., C:.)\n+//   * relative paths begin with '\\'          (e.g \\foo\\bar)\n+//   * relative paths begin without '\\'       (e.g foo\\bar, ..\\foo\\bar, .., .)\n+// The returned normalized path will be in the same form (of 5 listed above) as the input path.\n+// If two paths A and B are indicating the same file with the same format, toNorm(A) should be equal to toNorm(B).\n+// The normBase parameter should be equal to the normBase func, except for in tests.  See docs on the normBase func.\n+func toNorm(path string, normBase func(string) (string, error)) (string, error) {\n \tif path == \"\" {\n \t\treturn path, nil\n \t}\n@@ -58,7 +75,13 @@ func toNorm(path string, base func(string) (string, error)) (string, error) {\n \tvar normPath string\n \n \tfor {\n-\t\tname, err := base(volume + path)\n+\t\tif baseIsDotDot(path) {\n+\t\t\tnormPath = path + `\\` + normPath\n+\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tname, err := normBase(volume + path)\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}"}, {"sha": "e601c2cbde20894b6aa81aab393fe3526e96bece", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -5752,6 +5752,8 @@ func TestTypeStrings(t *testing.T) {\n \t\t{TypeOf(new(XM)), \"*reflect_test.XM\"},\n \t\t{TypeOf(new(XM).String), \"func() string\"},\n \t\t{TypeOf(new(XM)).Method(0).Type, \"func(*reflect_test.XM) string\"},\n+\t\t{ChanOf(3, TypeOf(XM{})), \"chan reflect_test.XM\"},\n+\t\t{MapOf(TypeOf(int(0)), TypeOf(XM{})), \"map[int]reflect_test.XM\"},\n \t}\n \n \tfor i, test := range stringTests {"}, {"sha": "0a58bafd85f0fd9fdb0cf6e820596e9fa6b90ae9", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -4,8 +4,69 @@\n \n // Package pprof writes runtime profiling data in the format expected\n // by the pprof visualization tool.\n+//\n+// Profiling a Go program\n+//\n+// The first step to profiling a Go program is to enable profiling.\n+// Support for profiling benchmarks built with the standard testing\n+// package is built into go test. For example, the following command\n+// runs benchmarks in the current directory and writes the CPU and\n+// memory profiles to cpu.prof and mem.prof:\n+//\n+//     go test -cpuprofile cpu.prof -memprofile mem.prof -bench .\n+//\n+// To add equivalent profiling support to a standalone program, add\n+// code like the following to your main function:\n+//\n+//    var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile `file`\")\n+//    var memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to `file`\")\n+//\n+//    func main() {\n+//        flag.Parse()\n+//        if *cpuprofile != \"\" {\n+//            f, err := os.Create(*cpuprofile)\n+//            if err != nil {\n+//                log.Fatal(\"could not create CPU profile: \", err)\n+//            }\n+//            if err := pprof.StartCPUProfile(f); err != nil {\n+//                log.Fatal(\"could not start CPU profile: \", err)\n+//            }\n+//            defer pprof.StopCPUProfile()\n+//        }\n+//        ...\n+//        if *memprofile != \"\" {\n+//            f, err := os.Create(*memprofile)\n+//            if err != nil {\n+//                log.Fatal(\"could not create memory profile: \", err)\n+//            }\n+//            runtime.GC() // get up-to-date statistics\n+//            if err := pprof.WriteHeapProfile(f); err != nil {\n+//                log.Fatal(\"could not write memory profile: \", err)\n+//            }\n+//            f.Close()\n+//        }\n+//    }\n+//\n+// There is also a standard HTTP interface to profiling data. Adding\n+// the following line will install handlers under the /debug/pprof/\n+// URL to download live profiles:\n+//\n+//    import _ \"net/http/pprof\"\n+//\n+// See the net/http/pprof package for more details.\n+//\n+// Profiles can then be visualized with the pprof tool:\n+//\n+//    go tool pprof cpu.prof\n+//\n+// There are many commands available from the pprof command line.\n+// Commonly used commands include \"top\", which prints a summary of the\n+// top program hot-spots, and \"web\", which opens an interactive graph\n+// of hot-spots and their call graphs. Use \"help\" for information on\n+// all pprof commands.\n+//\n // For more information about pprof, see\n-// http://github.com/google/pprof/.\n+// https://github.com/google/pprof/blob/master/doc/pprof.md.\n package pprof\n \n import ("}, {"sha": "cea5636d07d5c08f49e0ea7b621c001a17b8bb60", "filename": "libgo/go/syscall/syscall_darwin_test.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fsyscall%2Fsyscall_darwin_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4b8a523322d6100b52d41ad12d7b602d01331b/libgo%2Fgo%2Fsyscall%2Fsyscall_darwin_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_darwin_test.go?ref=af4b8a523322d6100b52d41ad12d7b602d01331b", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin\n+// +build amd64 386 arm arm64\n+\n+package syscall_test\n+\n+import (\n+\t\"syscall\"\n+\t\"testing\"\n+)\n+\n+func TestDarwinGettimeofday(t *testing.T) {\n+\ttv := &syscall.Timeval{}\n+\tif err := syscall.Gettimeofday(tv); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif tv.Sec == 0 && tv.Usec == 0 {\n+\t\tt.Fatal(\"Sec and Usec both zero\")\n+\t}\n+}"}]}