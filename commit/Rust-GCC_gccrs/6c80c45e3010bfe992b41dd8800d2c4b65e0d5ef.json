{"sha": "6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM4MGM0NWUzMDEwYmZlOTkyYjQxZGQ4ODAwZDJjNGI2NWUwZDVlZg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-05-19T17:55:34Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-05-19T17:55:34Z"}, "message": "Jumbo patch:\n\n* Imported beans and serialization\n* Updated IA-64 port\n* Miscellaneous bug fixes\n\nFrom-SVN: r34028", "tree": {"sha": "88cf0d32aea197ea8e8198e1206b04c820308615", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88cf0d32aea197ea8e8198e1206b04c820308615"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/comments", "author": null, "committer": null, "parents": [{"sha": "021c89ed68c151c45021fccf1bb5338ee817314c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021c89ed68c151c45021fccf1bb5338ee817314c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/021c89ed68c151c45021fccf1bb5338ee817314c"}], "stats": {"total": 19018, "additions": 18458, "deletions": 560}, "files": [{"sha": "669ef7b933d5ebe358332731cc18046ea6d8d815", "filename": "libjava/ChangeLog", "status": "modified", "additions": 486, "deletions": 0, "changes": 486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -1,3 +1,489 @@\n+2000-05-16  Andrew Haley  <aph@cygnus.com>\n+\n+\t* sysdep/ia64.c (ia64_backtrace_helper): Pass NULL pointer to\n+\tbuild_ia64_frame_state.\n+\t* sysdep/ia64-frame.h (build_ia64_frame_state): Match with\n+\tdefintion in gcc.\n+\n+2000-05-15  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* gnu/gcj/beans/BeanInfoEmbryo.java: Removed.\n+\t* gnu/gcj/beans/EmptyBeanInfo.java: Removed.\n+\t* gnu/gcj/beans/ExplicitBeanInfo.java: Removed.\n+\t* gnu/gcj/beans/IntrospectionIncubator.java: Removed.\n+\t* gnu/gcj/beans/editors/ColorEditor.java: Removed.\n+\t* gnu/gcj/beans/editors/FontEditor.java: Removed.\n+\t* gnu/gcj/beans/editors/NativeBooleanEditor.java: Removed.\n+\t* gnu/gcj/beans/editors/NativeByteEditor.java: Removed.\n+\t* gnu/gcj/beans/editors/NativeDoubleEditor.java: Removed.\n+\t* gnu/gcj/beans/editors/NativeFloatEditor.java: Removed.\n+\t* gnu/gcj/beans/editors/NativeIntEditor.java: Removed.\n+\t* gnu/gcj/beans/editors/NativeLongEditor.java: Removed.\n+\t* gnu/gcj/beans/editors/NativeShortEditor.java: Removed.\n+\t* gnu/gcj/beans/editors/StringEditor.java: Removed.\n+\t* gnu/gcj/beans/info/ComponentBeanInfo.java: Removed.\n+\t* gnu/gcj/io/ClassLoaderObjectInputStream.java: Removed.\n+\t* gnu/gcj/io/NullOutputStream.java: Removed.\n+\t* gnu/gcj/io/ObjectIdentityWrapper.java: Removed.\n+\t* gnu/gcj/lang/ArrayHelper.java: Removed.\n+\t* gnu/gcj/lang/ClassHelper.java: Removed.\n+\t* gnu/gcj/lang/reflect/TypeSignature.java: Removed.\n+\n+\t* gnu/java/beans/BeanInfoEmbryo.java: New file.\n+\t* gnu/java/beans/EmptyBeanInfo.java: New file.\n+\t* gnu/java/beans/ExplicitBeanInfo.java: New file.\n+\t* gnu/java/beans/IntrospectionIncubator.java: New file.\n+\t* gnu/java/beans/editors/ColorEditor.java: New file.\n+\t* gnu/java/beans/editors/FontEditor.java: New file.\n+\t* gnu/java/beans/editors/NativeBooleanEditor.java: New file.\n+\t* gnu/java/beans/editors/NativeByteEditor.java: New file.\n+\t* gnu/java/beans/editors/NativeDoubleEditor.java: New file.\n+\t* gnu/java/beans/editors/NativeFloatEditor.java: New file.\n+\t* gnu/java/beans/editors/NativeIntEditor.java: New file.\n+\t* gnu/java/beans/editors/NativeLongEditor.java: New file.\n+\t* gnu/java/beans/editors/NativeShortEditor.java: New file.\n+\t* gnu/java/beans/editors/StringEditor.java: New file.\n+\t* gnu/java/beans/info/ComponentBeanInfo.java: New file.\n+\t* gnu/java/io/ClassLoaderObjectInputStream.java: New file.\n+\t* gnu/java/io/NullOutputStream.java: New file.\n+\t* gnu/java/io/ObjectIdentityWrapper.java: New file.\n+\t* gnu/java/lang/ArrayHelper.java: New file.\n+\t* gnu/java/lang/ClassHelper.java: New file.\n+\t* gnu/java/lang/reflect/TypeSignature.java: New file.\n+\n+\t* Makefile.am: Updated for moving Classpath files from gnu/gcj\n+\tnamespace back to the original Classpath gnu/java namespace.\n+\t* Makefile.in: Rebuilt.\n+\n+\t* java/beans/Beans.java: Namespace change.\n+\t* java/beans/EventSetDescriptor.java: Namespace change.\n+\t* java/beans/Introspector.java: Namespace change.\n+\t* java/beans/PropertyEditorManager.java: Namespace change.\n+\t* java/io/ObjectInputStream.java: Namespace change.\n+\t* java/io/ObjectOutputStream.java: Namespace change.\n+\t* java/io/ObjectStreamClass.java: Namespace change.\n+\t* java/io/ObjectStreamField.java: Namespace change.\n+\n+2000-04-21  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* java/io/ObjectInputStream.java: Reverted workarounds of 2000-04-13\n+\tnow that compiler patch is available.\n+\tRemoved unneeded System.loadLibrary.\n+\t* java/io/ObjectOutputStream.java: Removed unneeded System.loadLibrary.\n+\t* java/io/ObjectStreamClass.java: Removed unneeded System.loadLibrary.\n+\n+2000-04-19  Andrew Haley  <aph@cygnus.com>\n+\n+\t* java/lang/natClass.cc (_Jv_IsAssignableFrom): Make sure source\n+\tand target classes have been initialized.\n+\n+2000-04-19  Andrew Haley  <aph@cygnus.com>\n+\n+\t* java/lang/String.java: implement Serializable, Comparable.\n+\t(compareTo (Object)): New method.\n+\n+2000-04-19  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* java/io/ObjectStreamClass.java (getDefinedSUID): Use getDeclaredField\n+\tinstead of getField to retrieve non-public field.\n+\t(getSerialPersistantFields): Ditto.\n+\n+2000-04-18  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* mauve-libgcj: Turned off object serialization tests temporarily\n+\tdue to compiler error.\n+\n+2000-04-17  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* java/io/ObjectInputStream.java (DEBUG): Disabled unused method\n+\tto avoid build problem.\n+\t(DEBUGln): Ditto.\n+\t* mauve-libgcj: Turned on object serialization tests.\n+\n+2000-04-17  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* libgcj.spec.in (*lib): Added -lgcjawt.\n+\n+2000-04-17  Andrew Haley  <aph@cygnus.com>\n+\n+\t* Makefile.am: Add new files: \n+\tgnu/gcj/io/SimpleSHSStream.java, gnu/gcj/io/natSimpleSHSStream.cc,\n+\tgnu/gcj/io/shs.cc.\n+\t* Makefile.in: Rebuilt.\n+\n+\t* java/lang/natClass.cc (_Jv_IsAssignableFrom): Check for an\n+\tinterface that has no implementations.\n+\tCheck for an attempt to assign an abstract class to an interface.\n+\n+\t* java/io/ObjectStreamClass.java (setUID): Use a SimpleSHSStream\n+\tif we fail to find MessageDigest.getInstance (\"SHA\").\n+\n+\t* gnu/gcj/io/SimpleSHSStream.java: New file.\n+\t* gnu/gcj/io/natSimpleSHSStream.java: New file.\n+\t* gnu/gcj/io/shs.cc: New file.\n+\t* gnu/gcj/io/shs.h: new file.\n+\n+\t* java/lang/natClassLoader.cc (_Jv_FindArrayClass): Make arrays\n+\tserializable.\n+\n+\t* gnu/gcj/lang/reflect/TypeSignature.java: Don't remove\n+\tpunctuation from the classname of an array element.\n+\n+\t* gcj/javaprims.h: Add SimpleDigestStream.\n+\t\n+2000-04-17  Andrew Haley  <aph@cygnus.com>\n+\n+\t* java/lang/natClass.cc (getPrivateField): Make recursive calls\n+\tto getPrivateField for superclasses.\n+ \n+2000-04-14  Andrew Haley  <aph@cygnus.com>\n+\n+\t* Makefile.am: Add new files:\n+\tjava/io/ObjectOutputStream$PutField.h,\n+\tjava/io/ObjectInputStream$GetField.h,java/io/natObjectInputStream.cc,\n+\tjava/io/natObjectOutputStream.cc\n+\t* Makefile.in: Rebuilt.\n+\t* gcj/Makefile.in: Rebuilt.\n+\t* include/Makefile.in: Rebuilt.\n+\t* java/lang/Class.h (getPrivateField): New method.\n+\t(getPrivateMethod): Ditto.\n+\tMake java::io::ObjectOutputStream, java::io::ObjectInputStream,\n+\tand java::io::ObjectStreamClass our friends.\n+\t* java/lang/natClass.cc (getPrivateField): New method.\n+\t(getPrivateMethod): Ditto.\n+\t(_Jv_IsAssignableFrom): Return false for Interface with no IDT.\n+\t* gcj/javaprims.h: Add serialization classes.\t\n+\t* java/io/ObjectInputStream.java (setBooleanField): Rewrite in Java.\n+\t(setByteField): Ditto.\n+\t(setCharField): Ditto.\n+\t(setDoubleField): Ditto.\n+\t(setFloatField): Ditto.\n+\t(setIntField): Ditto.\n+\t(setLongField): Ditto.\n+\t(setShortField): Ditto.\n+\t(setObjectField): Ditto.\n+\t* java/io/ObjectOutputStream.java: (getBooleanField): Rewrite in\n+\tJava.\n+\t(getByteField): Ditto.\n+\t(getCharField): Ditto.\n+\t(getDoubleField): Ditto.\n+\t(getFloatField): Ditto.\n+\t(getIntField): Ditto.\n+\t(getLongField): Ditto.\n+\t(getShortField): Ditto.\n+\t(getObjectField): Ditto.\n+\t* java/io/ObjectStreamClass.java (hasClassInitializer): Rewrite in\n+\tJava.\n+\t(getSerialPersistantFields): Ditto.\n+\t(getDefinedSUID): Ditto.\n+\t* java/io/natObjectOutputStream.cc: New file.\n+\t* java/io/natObjectInputStream.cc: New file.\n+\t\n+2000-04-13  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* java/io/ObjectInputStream.java: Temporary workarounds for compiler\n+\tproblems.  Revert to previous version to reproduce and when fixed.\n+\n+2000-04-13  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* gnu/gcj/io/ClassLoaderObjectInputStream.java: New file.\n+\t* gnu/gcj/io/NullOutputStream.java: New file.\n+\t* gnu/gcj/lang/reflect/TypeSignature.java: New file.\n+\t* java/io/BlockDataException.java: New file.\n+\t* java/io/Externalizable.java: New file.\n+\t* java/io/InvalidClassException.java: New file.\n+\t* java/io/InvalidObjectException.java: New file.\n+\t* java/io/NotActiveException.java: New file.\n+\t* java/io/NotSerializableException.java: New file.\n+\t* java/io/ObjectInput.java: New file.\n+\t* java/io/ObjectInputStream.java: New file.\n+\t* java/io/ObjectInputValidation.java: New file.\n+\t* java/io/ObjectOutput.java: New file.\n+\t* java/io/ObjectOutputStream.java: New file.\n+\t* java/io/ObjectStreamClass.java: New file.\n+\t* java/io/ObjectStreamConstants.java: New file.\n+\t* java/io/ObjectStreamField.java: New file.\n+\t* java/io/Replaceable.java: New file.\n+\t* java/io/Resolvable.java: New file.\n+\t* java/io/SerializablePermission.java: New file.\n+\t* java/io/WriteAbortedException.java: New file.\n+\t* java/security/BasicPermission.java: New file.\n+\t* java/security/DigestOutputStream.java: New file.\n+\t* java/security/Guard.java: New file.\n+\t* java/security/Permission.java: New file.\n+\t* java/security/PermissionCollection.java: New file.\n+\t* Makefile.am: Added above files.\n+\t* Makefile.in: Rebuilt.\n+\n+\t* java/beans/Beans.java (instantiate): Activated serialization code.\n+\t* java/lang/SecurityManager.java (checkPermission): New method.\n+\n+2000-04-12  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* gnu/gcj/beans/BeanInfoEmbryo.java: New file.\n+\t* gnu/gcj/beans/EmptyBeanInfo.java: New file.\n+\t* gnu/gcj/beans/ExplicitBeanInfo.java: New file.\n+\t* gnu/gcj/beans/IntrospectionIncubator.java: New file.\n+\t* gnu/gcj/beans/editors/ColorEditor.java: New file.\n+\t* gnu/gcj/beans/editors/FontEditor.java: New file.\n+\t* gnu/gcj/beans/editors/NativeBooleanEditor.java: New file.\n+\t* gnu/gcj/beans/editors/NativeByteEditor.java: New file.\n+\t* gnu/gcj/beans/editors/NativeDoubleEditor.java: New file.\n+\t* gnu/gcj/beans/editors/NativeFloatEditor.java: New file.\n+\t* gnu/gcj/beans/editors/NativeIntEditor.java: New file.\n+\t* gnu/gcj/beans/editors/NativeLongEditor.java: New file.\n+\t* gnu/gcj/beans/editors/NativeShortEditor.java: New file.\n+\t* gnu/gcj/beans/editors/StringEditor.java: New file.\n+\t* gnu/gcj/beans/info/ComponentBeanInfo.java: New file.\n+\t* gnu/gcj/io/ObjectIdentityWrapper.java: New file.\n+\t* gnu/gcj/lang/ArrayHelper.java: New file.\n+\t* gnu/gcj/lang/ClassHelper.java: New file.\n+\t* java/beans/BeanDescriptor.java: New file.\n+\t* java/beans/BeanInfo.java: New file.\n+\t* java/beans/Beans.java: New file.\n+\t* java/beans/Customizer.java: New file.\n+\t* java/beans/DesignMode.java: New file.\n+\t* java/beans/EventSetDescriptor.java: New file.\n+\t* java/beans/FeatureDescriptor.java: New file.\n+\t* java/beans/IndexedPropertyDescriptor.java: New file.\n+\t* java/beans/IntrospectionException.java: New file.\n+\t* java/beans/Introspector.java: New file.\n+\t* java/beans/MethodDescriptor.java: New file.\n+\t* java/beans/ParameterDescriptor.java: New file.\n+\t* java/beans/PropertyChangeEvent.java: New file.\n+\t* java/beans/PropertyChangeListener.java: New file.\n+\t* java/beans/PropertyChangeSupport.java: New file.\n+\t* java/beans/PropertyDescriptor.java: New file.\n+\t* java/beans/PropertyEditor.java: New file.\n+\t* java/beans/PropertyEditorManager.java: New file.\n+\t* java/beans/PropertyEditorSupport.java: New file.\n+\t* java/beans/PropertyVetoException.java: New file.\n+\t* java/beans/SimpleBeanInfo.java: New file.\n+\t* java/beans/VetoableChangeListener.java: New file.\n+\t* java/beans/VetoableChangeSupport.java: New file.\n+\t* java/beans/Visibility.java: New file.\n+\t* java/beans/beancontext/BeanContext.java: New file.\n+\t* java/beans/beancontext/BeanContextChild.java: New file.\n+\t* java/beans/beancontext/BeanContextChildComponentProxy.java: New file.\n+\t* java/beans/beancontext/BeanContextChildSupport.java: New file.\n+\t* java/beans/beancontext/BeanContextContainerProxy.java: New file.\n+\t* java/beans/beancontext/BeanContextEvent.java: New file.\n+\t* java/beans/beancontext/BeanContextMembershipEvent.java: New file.\n+\t* java/beans/beancontext/BeanContextMembershipListener.java: New file.\n+\t* java/beans/beancontext/BeanContextProxy.java: New file.\n+\t* java/beans/beancontext/BeanContextServiceAvailableEvent.java:\n+\tNew file.\n+\t* java/beans/beancontext/BeanContextServiceProvider.java: New file.\n+\t* java/beans/beancontext/BeanContextServiceProviderBeanInfo.java:\n+\tNew file.\n+\t* java/beans/beancontext/BeanContextServiceRevokedEvent.java: New file.\n+\t* java/beans/beancontext/BeanContextServiceRevokedListener.java:\n+\tNew file.\n+\t* java/beans/beancontext/BeanContextServices.java: New file.\n+\t* java/beans/beancontext/BeanContextServicesListener.java: New file.\n+\t* java/util/AbstractCollection.java: New file.\n+\t* java/util/AbstractList.java: New file.\n+\t* java/util/Arrays.java: New file.\n+\t* Makefile.am: Added above files.\n+\t* Makefile.in: Rebuilt.\n+\n+2000-04-11  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* java/awt/AWTError.java: New file.\n+\t* java/awt/AWTEvent.java: New file.\n+\t* java/awt/AWTException.java: New file.\n+\t* java/awt/ActiveEvent.java: New file.\n+\t* java/awt/Adjustable.java: New file.\n+\t* java/awt/BorderLayout.java: New file.\n+\t* java/awt/Color.java: New file.\n+\t* java/awt/Component.java: New file.\n+\t* java/awt/Container.java: New file.\n+\t* java/awt/Dimension.java: New file.\n+\t* java/awt/Event.java: New file.\n+\t* java/awt/Font.java: New file.\n+\t* java/awt/Frame.java: New file.\n+\t* java/awt/Graphics.java: New file.\n+\t* java/awt/IllegalComponentStateException.java: New file.\n+\t* java/awt/Image.java: New file.\n+\t* java/awt/ItemSelectable.java: New file.\n+\t* java/awt/LayoutManager.java: New file.\n+\t* java/awt/LayoutManager2.java: New file.\n+\t* java/awt/Menu.java: New file.\n+\t* java/awt/MenuBar.java: New file.\n+\t* java/awt/MenuComponent.java: New file.\n+\t* java/awt/MenuContainer.java: New file.\n+\t* java/awt/MenuItem.java: New file.\n+\t* java/awt/Paint.java: New file.\n+\t* java/awt/PaintContext.java: New file.\n+\t* java/awt/Point.java: New file.\n+\t* java/awt/Rectangle.java: New file.\n+\t* java/awt/Shape.java: New file.\n+\t* java/awt/TextArea.java: New file.\n+\t* java/awt/TextComponent.java: New file.\n+\t* java/awt/Toolkit.java: New file.\n+\t* java/awt/Transparency.java: New file.\n+\t* java/awt/Window.java: New file.\n+\t* java/awt/natToolkit.cc: New file.\n+\t* java/awt/event/AWTEventListener.java: New file.\n+\t* java/awt/event/ActionEvent.java: New file.\n+\t* java/awt/event/ActionListener.java: New file.\n+\t* java/awt/event/AdjustmentEvent.java: New file.\n+\t* java/awt/event/AdjustmentListener.java: New file.\n+\t* java/awt/event/ComponentAdapter.java: New file.\n+\t* java/awt/event/ComponentEvent.java: New file.\n+\t* java/awt/event/ComponentListener.java: New file.\n+\t* java/awt/event/ContainerAdapter.java: New file.\n+\t* java/awt/event/ContainerEvent.java: New file.\n+\t* java/awt/event/ContainerListener.java: New file.\n+\t* java/awt/event/FocusAdapter.java: New file.\n+\t* java/awt/event/FocusEvent.java: New file.\n+\t* java/awt/event/FocusListener.java: New file.\n+\t* java/awt/event/InputEvent.java: New file.\n+\t* java/awt/event/InputMethodEvent.java: New file.\n+\t* java/awt/event/InputMethodListener.java: New file.\n+\t* java/awt/event/InvocationEvent.java: New file.\n+\t* java/awt/event/ItemEvent.java: New file.\n+\t* java/awt/event/ItemListener.java: New file.\n+\t* java/awt/event/KeyAdapter.java: New file.\n+\t* java/awt/event/KeyEvent.java: New file.\n+\t* java/awt/event/KeyListener.java: New file.\n+\t* java/awt/event/MouseAdapter.java: New file.\n+\t* java/awt/event/MouseEvent.java: New file.\n+\t* java/awt/event/MouseListener.java: New file.\n+\t* java/awt/event/MouseMotionAdapter.java: New file.\n+\t* java/awt/event/MouseMotionListener.java: New file.\n+\t* java/awt/event/PaintEvent.java: New file.\n+\t* java/awt/event/TextEvent.java: New file.\n+\t* java/awt/event/TextListener.java: New file.\n+\t* java/awt/event/WindowAdapter.java: New file.\n+\t* java/awt/event/WindowEvent.java: New file.\n+\t* java/awt/event/WindowListener.java: New file.\n+\t* java/awt/geom/Dimension2D.java: New file.\n+\t* java/awt/geom/Point2D.java: New file.\n+\t* java/awt/peer/ComponentPeer.java: New file.\n+\t* java/awt/peer/ContainerPeer.java: New file.\n+\t* java/awt/peer/FramePeer.java: New file.\n+\t* java/awt/peer/WindowPeer.java: New file.\n+\t* java/util/Collection.java: New file.\n+\t* java/util/Comparator.java: New file.\n+\t* java/util/Iterator.java: New file.\n+\t* java/util/List.java: New file.\n+\t* java/util/ListIterator.java: New file.\n+\t* Makefile.am: Added above files.\n+\t* Makefile.in: Rebuilt.\n+\n+2000-04-10  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* gnu/gcj/runtime/MethodInvocation.java: Fixed copyright.\n+\t* java/lang/FirstThread.java: Ditto.\n+\t* java/lang/StringBuffer.java: Ditto.\n+\t* mauve-libgcj: Turned on java.math, java.sql and java.security tests.\n+\n+\t* gnu/gcj/math/MPN.java (rshift): Undid Boehm's patch of 03-14.\n+\tSpecial case handled in java.math.BigInteger.\n+\t* java/math/BigInteger.java (divide): Handle the special case when\n+\tdividing by 1 and the high bit of the dividend is set.\n+\t(setShiftRight): Handle case when count == 0.\n+\n+2000-04-05  Andrew Haley  <aph@cygnus.com>\n+\n+\t* java/net/URL.java (setURLStreamHandler): Make \"file\" protocol a\n+\tspecial case.\n+\n+2000-04-05  Andrew Haley  <aph@cygnus.com>\n+\n+\t* sysdep/ia64.c (rse_address_add): Delete.\n+\t(IS_NaT_COLLECTION_ADDR): Delete.\n+\t(ia64_backtrace_helper): check for null unwind_info.\n+\t\n+\t* sysdep/ia64-frame.h: add calc_caller_bsp.\n+\n+\t* java/lang/natThrowable.cc (printRawStackTrace): Flush\n+\tPrintWriter.\n+\n+\t* prims.cc (_Jv_divI): Use _Jv_ThrowSignal.\n+\t(_Jv_remI): Likewise.\n+\t(_Jv_divJ): Likewise.\n+\t(_Jv_remJ): Likewise.\n+\t\n+\t* interpret.cc (continue1): Use divide subroutines to guarantee\n+\tcorrect Java standard behaviour.\n+\tFloating-point division should not abort; make it so.\n+\n+2000-03-29  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* configure: Rebuilt.\n+\t* configure.in: Test against `libgcj_sjlj', not\n+\t`enable_sjlj_exceptions'.  Rearranged code to allow SYSDEP_SOURCES\n+\tto be set even when using sjlj.\n+\n+2000-03-24  Andrew Haley  <aph@cygnus.com>\n+\n+\t* Makefile.am: Add file addr2name.awk.\n+\t* Makefile.in: Rebuilt.\n+\t* addr2name.awk: New file.\n+\t* name-finder.cc (_Jv_name_finder): Call addr2name.awk to do name\n+\tlookups on ia64.\n+\t* java/lang/natThrowable.cc(printRawStackTrace): Don't print out a\n+\tblank line.\n+\t\n+2000-03-22  Andrew Haley  <aph@cygnus.com>\n+\n+\t* configure.host: Add -funwind-tables for IA64.\n+\t* Makefile.am (c_source_files): Add SYSDEP_SORCES.\n+\t* Makefile.in: Rebuilt.\n+\t* java/lang/natThrowable.cc (fillInStackTrace): Add ia64 case.\n+\t* sysdep/ia64.c: New file.\n+\t* sysdep/ia64-frame.h: New file.\n+\t* configure.in: Add sysdep/ia64.c for ia64.\n+\t* configure: Rebuilt.\n+\t\n+2000-03-17  Andrew Haley  <aph@cygnus.com>\n+\n+\t* java/lang/natString.cc: Remove `register' keyword.\n+\tinterpret.cc: ditto.\n+\n+2000-03-16  Andrew Haley  <aph@cygnus.com>\n+\n+\t* configure.host (ia64): Enable interpreter.\n+\n+2000-03-14  Hans Boehm  <boehm@acm.org>\n+\n+\t* gnu/gcj/math/MPN.java (rshift): Handle shift 32 specially.\n+\n+\t* include/java-cpool.h (_Jv_storeLong, _Jv_loadLong,\n+\t_Jv_storeDouble, _Jv_loadDouble): Define differently on 64 bit\n+\tmachine.\n+\t* java/lang/ieeefp.h: Define __IEEE_BIG_ENDIAN or\n+\t__IEEE_LITTLE_ENDIAN appropriately on IA64.\n+\t* java/lang/mprec.h: Don't define Pack_32 on 64 bit machine.\n+\t* javaprims.h (_Jv_word): Added `l' and `d' entries in 64 bit\n+\tcase.\n+\t* resolve.cc (FFI_PREP_RAW_CLOSURE): New define.\n+\t(FFI_RAW_SIZE): Likewise.\n+\t(_Jv_InterpMethod::ncode): Use them.\n+\t* interpret.cc (PUSHL, PUSHD, POPL, POPD, LOADL, LOADD, STOREL,\n+\tSTORED): Define differently on a 64 bit machine.\n+\t(continue1): Use ffi_java_raw_call when appropriate.\n+\n+2000-03-14  Andrew Haley  <aph@cygnus.com>\n+\n+\t* include/default-signal.h (MAKE_THROW_FRAME): Add arg\n+\t`_exception'.\n+\n+2000-03-10  Andrew Haley  <aph@cygnus.com>\n+\n+\t* java/lang/ieeefp.h: Import latest version from fdlibm.\n+\n+2000-03-14  Andrew Haley  <aph@cygnus.com>\n+\n+\t* prims.cc (_Jv_ThrowSignal): New function.\n+\t(catch_segv): Add arg `_exception' to MAKE_THROW_FRAME.\n+\t(catch_fpe): Ditto.\n+\t* include/sparc-signal.h (MAKE_THROW_FRAME): Ditto\n+\t* include/i386-signal.h (MAKE_THROW_FRAME): Ditto.\n+\t* include/ppc-signal.h: New file.\n+\n 2000-05-18  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/lang/Thread.java: Declare `data' as Object, not RawData."}, {"sha": "97d50478a91a5c328b69d33f6ca9718403f1fb64", "filename": "libjava/Makefile.am", "status": "modified", "additions": 279, "deletions": 184, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -41,6 +41,8 @@ if NATIVE\n bin_PROGRAMS = jv-convert gij\n endif\n \n+bin_SCRIPTS = addr2name.awk\n+\n ## ################################################################\n \n ##\n@@ -232,7 +234,9 @@ $(awto_files) $(javao_files): libgcj.zip\n ## Header files used when compiling some of the nat* files.\n nat_headers = $(ordinary_java_source_files:.java=.h) \\\n \t$(built_java_source_files:.java=.h) \\\n-\t$(cond_awt_java_source_files:.java=.h)\n+\t$(cond_awt_java_source_files:.java=.h) \\\n+\tjava/io/ObjectOutputStream$$PutField.h \\\n+\tjava/io/ObjectInputStream$$GetField.h\n \n $(nat_headers): libgcj.zip\n \n@@ -298,6 +302,14 @@ gnu/gcj/runtime/VMClassLoader.h: gnu/gcj/runtime/VMClassLoader.class libgcj.zip\n \t    -friend 'java::lang::ClassLoader;' \\\n \t    $(basename $<)\n \n+java/io/ObjectInputStream$$GetField.h: java/io/ObjectInputStream$$GetField.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t'java/io/ObjectInputStream$$GetField'\n+\n+java/io/ObjectOutputStream$$PutField.h: java/io/ObjectOutputStream$$PutField.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t'java/io/ObjectOutputStream$$PutField'\n+\n ## Headers we maintain by hand and which we want to install.\n extra_headers = java/lang/Object.h java/lang/Class.h\n \n@@ -492,80 +504,80 @@ gnu/gcj/convert/UnicodeToBytes.java\n special_java_source_files = java/lang/Class.java java/lang/Object.java\n \n awt_java_source_files =\t\\\n-java/awt/AWTError.java \\\n+java/awt/event/ActionEvent.java\t\\\n+java/awt/event/ActionListener.java \\\n+java/awt/event/ComponentEvent.java \\\n+java/awt/event/KeyAdapter.java \\\n+java/awt/event/InputEvent.java \\\n+java/awt/event/KeyEvent.java \\\n+java/awt/event/KeyListener.java\t\\\n+java/awt/event/TextEvent.java \\\n+java/awt/event/TextListener.java \\\n+java/awt/event/WindowAdapter.java \\\n+java/awt/event/WindowEvent.java\t\\\n+java/awt/event/WindowListener.java \\\n+java/awt/event/InputMethodListener.java\t\\\n+java/awt/event/ComponentListener.java \\\n+java/awt/event/AdjustmentListener.java \\\n+java/awt/event/AWTEventListener.java \\\n+java/awt/event/FocusListener.java \\\n+java/awt/event/AdjustmentEvent.java \\\n+java/awt/event/ItemListener.java \\\n+java/awt/event/ContainerListener.java \\\n+java/awt/event/MouseListener.java \\\n+java/awt/event/MouseMotionListener.java\t\\\n+java/awt/event/ComponentAdapter.java \\\n+java/awt/event/ContainerAdapter.java \\\n+java/awt/event/FocusAdapter.java \\\n+java/awt/event/MouseAdapter.java \\\n+java/awt/event/MouseMotionAdapter.java \\\n+java/awt/event/FocusEvent.java \\\n+java/awt/event/InputMethodEvent.java \\\n+java/awt/event/MouseEvent.java \\\n+java/awt/event/ItemEvent.java \\\n+java/awt/event/InvocationEvent.java \\\n+java/awt/event/PaintEvent.java \\\n+java/awt/event/ContainerEvent.java \\\n java/awt/AWTEvent.java \\\n-java/awt/AWTException.java \\\n-java/awt/ActiveEvent.java \\\n-java/awt/Adjustable.java \\\n java/awt/BorderLayout.java \\\n-java/awt/Color.java \\\n java/awt/Component.java\t\\\n java/awt/Container.java\t\\\n java/awt/Dimension.java\t\\\n java/awt/Event.java \\\n java/awt/Font.java \\\n java/awt/Frame.java \\\n-java/awt/Graphics.java \\\n-java/awt/IllegalComponentStateException.java \\\n-java/awt/Image.java \\\n-java/awt/ItemSelectable.java \\\n java/awt/LayoutManager.java \\\n java/awt/LayoutManager2.java \\\n java/awt/Menu.java \\\n java/awt/MenuBar.java \\\n java/awt/MenuComponent.java \\\n java/awt/MenuContainer.java \\\n java/awt/MenuItem.java \\\n-java/awt/Paint.java \\\n-java/awt/PaintContext.java \\\n java/awt/Point.java \\\n-java/awt/Rectangle.java\t\\\n+java/awt/AWTError.java \\\n java/awt/Shape.java \\\n java/awt/TextArea.java \\\n java/awt/TextComponent.java \\\n java/awt/Toolkit.java \\\n-java/awt/Transparency.java \\\n java/awt/Window.java \\\n-java/awt/event/AWTEventListener.java \\\n-java/awt/event/ActionEvent.java\t\\\n-java/awt/event/ActionListener.java \\\n-java/awt/event/AdjustmentEvent.java \\\n-java/awt/event/AdjustmentListener.java \\\n-java/awt/event/ComponentAdapter.java \\\n-java/awt/event/ComponentEvent.java \\\n-java/awt/event/ComponentListener.java \\\n-java/awt/event/ContainerAdapter.java \\\n-java/awt/event/ContainerEvent.java \\\n-java/awt/event/ContainerListener.java \\\n-java/awt/event/FocusAdapter.java \\\n-java/awt/event/FocusEvent.java \\\n-java/awt/event/FocusListener.java \\\n-java/awt/event/InputEvent.java \\\n-java/awt/event/InputMethodEvent.java \\\n-java/awt/event/InputMethodListener.java\t\\\n-java/awt/event/InvocationEvent.java \\\n-java/awt/event/ItemEvent.java \\\n-java/awt/event/ItemListener.java \\\n-java/awt/event/KeyAdapter.java \\\n-java/awt/event/KeyEvent.java \\\n-java/awt/event/KeyListener.java\t\\\n-java/awt/event/MouseAdapter.java \\\n-java/awt/event/MouseEvent.java \\\n-java/awt/event/MouseListener.java \\\n-java/awt/event/MouseMotionAdapter.java \\\n-java/awt/event/MouseMotionListener.java\t\\\n-java/awt/event/PaintEvent.java \\\n-java/awt/event/TextEvent.java \\\n-java/awt/event/TextListener.java \\\n-java/awt/event/WindowAdapter.java \\\n-java/awt/event/WindowEvent.java\t\\\n-java/awt/event/WindowListener.java \\\n java/awt/geom/Dimension2D.java \\\n java/awt/geom/Point2D.java \\\n java/awt/peer/ComponentPeer.java \\\n java/awt/peer/ContainerPeer.java \\\n java/awt/peer/FramePeer.java \\\n-java/awt/peer/WindowPeer.java\n+java/awt/peer/WindowPeer.java \\\n+java/awt/Adjustable.java \\\n+java/awt/Color.java \\\n+java/awt/Graphics.java \\\n+java/awt/Image.java \\\n+java/awt/Paint.java \\\n+java/awt/PaintContext.java \\\n+java/awt/Transparency.java \\\n+java/awt/ItemSelectable.java \\\n+java/awt/AWTException.java \\\n+java/awt/ActiveEvent.java \\\n+java/awt/Rectangle.java\t\\\n+java/awt/IllegalComponentStateException.java\n \n if AWT\n cond_awt_java_source_files = $(awt_java_source_files)\n@@ -582,27 +594,49 @@ built_java_source_files = java/lang/ConcreteProcess.java\n ## convert_source_files.  If the .java file has a hand-maintained\n ## header, please list it in special_java_source_files.\n ordinary_java_source_files =  $(convert_source_files) \\\n-gnu/gcj/io/DefaultMimeTypes.java \\\n-gnu/gcj/io/MimeTypes.java \\\n-gnu/gcj/jni/NativeThread.java \\\n-gnu/gcj/runtime/VMClassLoader.java \\\n-gnu/gcj/runtime/FirstThread.java \\\n+gnu/gcj/protocol/http/Connection.java \\\n+gnu/gcj/protocol/http/Handler.java \\\n+gnu/gcj/protocol/file/Connection.java \\\n+gnu/gcj/protocol/file/Handler.java \\\n+gnu/gcj/protocol/jar/Connection.java \\\n+gnu/gcj/protocol/jar/Handler.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n gnu/gcj/text/CharacterBreakIterator.java \\\n gnu/gcj/text/LineBreakIterator.java \\\n gnu/gcj/text/LocaleData_en.java\t\\\n gnu/gcj/text/LocaleData_en_US.java \\\n gnu/gcj/text/SentenceBreakIterator.java\t\\\n gnu/gcj/text/WordBreakIterator.java \\\n-gnu/gcj/math/MPN.java \\\n-gnu/gcj/protocol/file/Connection.java \\\n-gnu/gcj/protocol/file/Handler.java \\\n-gnu/gcj/protocol/http/Connection.java \\\n-gnu/gcj/protocol/http/Handler.java \\\n-gnu/gcj/protocol/jar/Handler.java \\\n-gnu/gcj/protocol/jar/Connection.java \\\n-gnu/gcj/RawData.java \\\n gnu/gcj/util/EnumerationChain.java \\\n+gnu/gcj/RawData.java \\\n+gnu/gcj/math/MPN.java \\\n+gnu/gcj/runtime/VMClassLoader.java \\\n+gnu/gcj/runtime/FirstThread.java \\\n+gnu/gcj/jni/NativeThread.java \\\n+gnu/gcj/io/DefaultMimeTypes.java \\\n+gnu/gcj/io/MimeTypes.java \\\n+gnu/gcj/io/SimpleSHSStream.java\t\\\n+gnu/java/beans/editors/ColorEditor.java\t\\\n+gnu/java/beans/editors/FontEditor.java \\\n+gnu/java/beans/editors/NativeBooleanEditor.java\t\\\n+gnu/java/beans/editors/NativeByteEditor.java \\\n+gnu/java/beans/editors/NativeDoubleEditor.java \\\n+gnu/java/beans/editors/NativeFloatEditor.java \\\n+gnu/java/beans/editors/NativeIntEditor.java \\\n+gnu/java/beans/editors/NativeLongEditor.java \\\n+gnu/java/beans/editors/NativeShortEditor.java \\\n+gnu/java/beans/editors/StringEditor.java \\\n+gnu/java/beans/info/ComponentBeanInfo.java \\\n+gnu/java/beans/BeanInfoEmbryo.java \\\n+gnu/java/beans/EmptyBeanInfo.java \\\n+gnu/java/beans/ExplicitBeanInfo.java \\\n+gnu/java/beans/IntrospectionIncubator.java \\\n+gnu/java/io/ClassLoaderObjectInputStream.java \\\n+gnu/java/io/NullOutputStream.java \\\n+gnu/java/io/ObjectIdentityWrapper.java \\\n+gnu/java/lang/reflect/TypeSignature.java \\\n+gnu/java/lang/ArrayHelper.java \\\n+gnu/java/lang/ClassHelper.java \\\n java/io/BufferedInputStream.java \\\n java/io/BufferedOutputStream.java \\\n java/io/BufferedReader.java \\\n@@ -618,7 +652,6 @@ java/io/DataOutput.java\t\\\n java/io/DataOutputStream.java \\\n java/io/EOFException.java \\\n java/io/File.java \\\n-java/io/FileDescriptor.java \\\n java/io/FileInputStream.java \\\n java/io/FileNotFoundException.java \\\n java/io/FileOutputStream.java \\\n@@ -635,11 +668,10 @@ java/io/InputStreamReader.java \\\n java/io/InterruptedIOException.java \\\n java/io/LineNumberInputStream.java \\\n java/io/LineNumberReader.java \\\n-java/io/ObjectStreamException.java \\\n-java/io/OptionalDataException.java \\\n java/io/OutputStream.java \\\n java/io/OutputStreamWriter.java\t\\\n-java/io/PipedInputStream.java \\\n+java/io/Externalizable.java \\\n+java/io/FileDescriptor.java \\\n java/io/PipedOutputStream.java \\\n java/io/PipedReader.java \\\n java/io/PipedWriter.java \\\n@@ -651,7 +683,6 @@ java/io/RandomAccessFile.java \\\n java/io/Reader.java \\\n java/io/SequenceInputStream.java \\\n java/io/Serializable.java \\\n-java/io/StreamCorruptedException.java \\\n java/io/StreamTokenizer.java \\\n java/io/StringBufferInputStream.java \\\n java/io/StringReader.java \\\n@@ -660,6 +691,35 @@ java/io/SyncFailedException.java \\\n java/io/UTFDataFormatException.java \\\n java/io/UnsupportedEncodingException.java \\\n java/io/Writer.java \\\n+java/io/ObjectStreamException.java \\\n+java/io/OptionalDataException.java \\\n+java/io/StreamCorruptedException.java \\\n+java/io/BlockDataException.java\t\\\n+java/io/InvalidClassException.java \\\n+java/io/InvalidObjectException.java \\\n+java/io/NotActiveException.java\t\\\n+java/io/NotSerializableException.java \\\n+java/io/ObjectInput.java \\\n+java/io/ObjectInputStream.java \\\n+java/io/ObjectInputValidation.java \\\n+java/io/ObjectOutput.java \\\n+java/io/ObjectOutputStream.java\t\\\n+java/io/ObjectStreamClass.java \\\n+java/io/ObjectStreamConstants.java \\\n+java/io/ObjectStreamField.java \\\n+java/io/Replaceable.java \\\n+java/io/Resolvable.java\t\\\n+java/io/SerializablePermission.java \\\n+java/io/WriteAbortedException.java \\\n+java/io/PipedInputStream.java \\\n+java/lang/reflect/Constructor.java \\\n+java/lang/reflect/AccessibleObject.java\t\\\n+java/lang/reflect/Array.java \\\n+java/lang/reflect/Method.java \\\n+java/lang/reflect/Field.java \\\n+java/lang/reflect/InvocationTargetException.java \\\n+java/lang/reflect/Member.java \\\n+java/lang/reflect/Modifier.java\t\\\n java/lang/AbstractMethodError.java \\\n java/lang/ArithmeticException.java \\\n java/lang/ArrayIndexOutOfBoundsException.java \\\n@@ -688,10 +748,10 @@ java/lang/IllegalMonitorStateException.java \\\n java/lang/IllegalStateException.java \\\n java/lang/IllegalThreadStateException.java \\\n java/lang/IncompatibleClassChangeError.java \\\n-java/lang/IndexOutOfBoundsException.java \\\n java/lang/InstantiationError.java \\\n-java/lang/InstantiationException.java \\\n java/lang/Integer.java \\\n+java/lang/IndexOutOfBoundsException.java \\\n+java/lang/InstantiationException.java \\\n java/lang/InternalError.java \\\n java/lang/InterruptedException.java \\\n java/lang/LinkageError.java \\\n@@ -729,107 +789,42 @@ java/lang/UnsupportedOperationException.java \\\n java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n java/lang/Void.java \\\n-java/lang/reflect/AccessibleObject.java\t\\\n-java/lang/reflect/Array.java \\\n-java/lang/reflect/Constructor.java \\\n-java/lang/reflect/Field.java \\\n-java/lang/reflect/InvocationTargetException.java \\\n-java/lang/reflect/Member.java \\\n-java/lang/reflect/Method.java \\\n-java/lang/reflect/Modifier.java\t\\\n-java/math/BigDecimal.java \\\n-java/math/BigInteger.java \\\n java/net/BindException.java \\\n java/net/ConnectException.java \\\n java/net/ContentHandler.java \\\n java/net/ContentHandlerFactory.java \\\n-java/net/DatagramPacket.java \\\n-java/net/DatagramSocket.java \\\n-java/net/DatagramSocketImpl.java \\\n java/net/FileNameMap.java \\\n-java/net/HttpURLConnection.java \\\n+java/net/HttpURLConnection.java\t\\\n java/net/InetAddress.java \\\n-java/net/JarURLConnection.java \\\n java/net/MalformedURLException.java \\\n-java/net/MulticastSocket.java \\\n java/net/NoRouteToHostException.java \\\n-java/net/PlainDatagramSocketImpl.java \\\n java/net/PlainSocketImpl.java \\\n java/net/ProtocolException.java\t\\\n java/net/ServerSocket.java \\\n+java/net/URL.java \\\n java/net/Socket.java \\\n java/net/SocketException.java \\\n java/net/SocketImpl.java \\\n java/net/SocketImplFactory.java\t\\\n-java/net/SocketOptions.java \\\n-java/net/URL.java \\\n-java/net/URLClassLoader.java \\\n java/net/URLConnection.java \\\n-java/net/URLDecoder.java \\\n-java/net/URLEncoder.java \\\n java/net/URLStreamHandler.java \\\n java/net/URLStreamHandlerFactory.java \\\n java/net/UnknownHostException.java \\\n java/net/UnknownServiceException.java \\\n-java/security/AlgorithmParameterGeneratorSpi.java \\\n-java/security/DigestException.java \\\n-java/security/GeneralSecurityException.java \\\n-java/security/InvalidAlgorithmParameterException.java \\\n-java/security/InvalidKeyException.java \\\n-java/security/InvalidParameterException.java \\\n-java/security/Key.java \\\n-java/security/KeyException.java \\\n-java/security/KeyPair.java \\\n-java/security/KeyPairGenerator.java \\\n-java/security/KeyPairGeneratorSpi.java \\\n-java/security/MessageDigest.java \\\n-java/security/NoSuchAlgorithmException.java \\\n-java/security/NoSuchProviderException.java \\\n-java/security/PrivateKey.java \\\n-java/security/Provider.java \\\n-java/security/PublicKey.java \\\n-java/security/SecureClassLoader.java \\\n-java/security/SecureRandom.java \\\n-java/security/Security.java \\\n-java/security/Signature.java \\\n-java/security/SignatureException.java \\\n-java/security/interfaces/DSAKey.java \\\n-java/security/interfaces/DSAParams.java \\\n-java/security/interfaces/DSAPrivateKey.java \\\n-java/security/interfaces/DSAPublicKey.java \\\n-java/security/interfaces/RSAPrivateCrtKey.java \\\n-java/security/interfaces/RSAPrivateKey.java \\\n-java/security/interfaces/RSAPublicKey.java \\\n-java/security/spec/AlgorithmParameterSpec.java \\\n-java/security/spec/InvalidKeySpecException.java \\\n-java/security/spec/InvalidParameterSpecException.java \\\n-java/security/spec/KeySpec.java \\\n-java/security/spec/RSAPrivateCrtKeySpec.java \\\n-java/security/spec/RSAPrivateKeySpec.java \\\n-java/security/spec/RSAPublicKeySpec.java \\\n-java/sql/CallableStatement.java \\\n-java/sql/Connection.java \\\n-java/sql/DataTruncation.java \\\n-java/sql/DatabaseMetaData.java \\\n-java/sql/Date.java \\\n-java/sql/Driver.java \\\n-java/sql/DriverManager.java \\\n-java/sql/DriverPropertyInfo.java \\\n-java/sql/PreparedStatement.java \\\n-java/sql/ResultSet.java \\\n-java/sql/ResultSetMetaData.java \\\n-java/sql/SQLException.java \\\n-java/sql/SQLWarning.java \\\n-java/sql/Statement.java \\\n-java/sql/Time.java \\\n-java/sql/Timestamp.java \\\n-java/sql/Types.java \\\n+java/net/URLDecoder.java \\\n+java/net/URLEncoder.java \\\n+java/net/DatagramPacket.java \\\n+java/net/DatagramSocket.java \\\n+java/net/DatagramSocketImpl.java \\\n+java/net/MulticastSocket.java \\\n+java/net/PlainDatagramSocketImpl.java \\\n+java/net/SocketOptions.java \\\n+java/net/JarURLConnection.java \\\n+java/net/URLClassLoader.java \\\n+java/text/Collator.java\t\\\n java/text/BreakIterator.java \\\n java/text/CharacterIterator.java \\\n java/text/ChoiceFormat.java \\\n-java/text/CollationElementIterator.java \\\n-java/text/CollationKey.java \\\n-java/text/Collator.java \\\n java/text/DateFormat.java \\\n java/text/DateFormatSymbols.java \\\n java/text/DecimalFormat.java \\\n@@ -840,13 +835,34 @@ java/text/MessageFormat.java \\\n java/text/NumberFormat.java \\\n java/text/ParseException.java \\\n java/text/ParsePosition.java \\\n-java/text/RuleBasedCollator.java \\\n java/text/SimpleDateFormat.java\t\\\n java/text/StringCharacterIterator.java \\\n+java/text/CollationElementIterator.java\t\\\n+java/text/CollationKey.java \\\n+java/text/RuleBasedCollator.java \\\n+java/util/zip/Adler32.java \\\n+java/util/zip/CRC32.java \\\n+java/util/zip/Checksum.java \\\n+java/util/zip/Deflater.java \\\n+java/util/zip/DeflaterOutputStream.java\t\\\n+java/util/zip/ZipConstants.java\t\\\n+java/util/zip/ZipEntry.java \\\n+java/util/zip/ZipException.java\t\\\n+java/util/zip/ZipFile.java \\\n+java/util/zip/ZipOutputStream.java \\\n+java/util/zip/InflaterInputStream.java \\\n+java/util/zip/ZipInputStream.java \\\n+java/util/zip/DataFormatException.java \\\n+java/util/zip/CheckedInputStream.java \\\n+java/util/zip/CheckedOutputStream.java \\\n+java/util/zip/Inflater.java \\\n+java/util/zip/GZIPInputStream.java \\\n+java/util/zip/GZIPOutputStream.java \\\n+java/util/jar/JarEntry.java \\\n+java/util/jar/JarFile.java \\\n+java/util/jar/JarInputStream.java \\\n java/util/BitSet.java \\\n java/util/Calendar.java\t\\\n-java/util/Collection.java \\\n-java/util/Comparator.java \\\n java/util/ConcurrentModificationException.java \\\n java/util/Date.java \\\n java/util/Dictionary.java \\\n@@ -856,17 +872,13 @@ java/util/EventListener.java \\\n java/util/EventObject.java \\\n java/util/GregorianCalendar.java \\\n java/util/Hashtable.java \\\n-java/util/Iterator.java \\\n-java/util/List.java \\\n-java/util/ListIterator.java \\\n java/util/ListResourceBundle.java \\\n java/util/Locale.java \\\n java/util/MissingResourceException.java\t\\\n java/util/NoSuchElementException.java \\\n java/util/Observable.java \\\n java/util/Observer.java\t\\\n java/util/Properties.java \\\n-java/util/PropertyResourceBundle.java \\\n java/util/Random.java \\\n java/util/ResourceBundle.java \\\n java/util/SimpleTimeZone.java \\\n@@ -875,27 +887,115 @@ java/util/StringTokenizer.java \\\n java/util/TimeZone.java\t\\\n java/util/TooManyListenersException.java \\\n java/util/Vector.java \\\n-java/util/jar/JarFile.java \\\n-java/util/jar/JarInputStream.java \\\n-java/util/jar/JarEntry.java \\\n-java/util/zip/Adler32.java \\\n-java/util/zip/CRC32.java \\\n-java/util/zip/CheckedInputStream.java \\\n-java/util/zip/CheckedOutputStream.java \\\n-java/util/zip/Checksum.java \\\n-java/util/zip/DataFormatException.java \\\n-java/util/zip/Deflater.java \\\n-java/util/zip/DeflaterOutputStream.java\t\\\n-java/util/zip/GZIPInputStream.java \\\n-java/util/zip/GZIPOutputStream.java \\\n-java/util/zip/Inflater.java \\\n-java/util/zip/InflaterInputStream.java\t\\\n-java/util/zip/ZipConstants.java\t\\\n-java/util/zip/ZipEntry.java \\\n-java/util/zip/ZipException.java\t\\\n-java/util/zip/ZipFile.java \\\n-java/util/zip/ZipInputStream.java \\\n-java/util/zip/ZipOutputStream.java\n+java/util/List.java \\\n+java/util/Collection.java \\\n+java/util/Comparator.java \\\n+java/util/Iterator.java\t\\\n+java/util/PropertyResourceBundle.java \\\n+java/util/Arrays.java \\\n+java/util/ListIterator.java \\\n+java/util/AbstractCollection.java \\\n+java/util/AbstractList.java \\\n+java/security/MessageDigest.java \\\n+java/security/NoSuchAlgorithmException.java \\\n+java/security/SecureClassLoader.java \\\n+java/security/interfaces/DSAKey.java \\\n+java/security/interfaces/DSAParams.java\t\\\n+java/security/interfaces/DSAPrivateKey.java \\\n+java/security/interfaces/DSAPublicKey.java \\\n+java/security/interfaces/RSAPrivateCrtKey.java \\\n+java/security/interfaces/RSAPrivateKey.java \\\n+java/security/interfaces/RSAPublicKey.java \\\n+java/security/AlgorithmParameterGeneratorSpi.java \\\n+java/security/DigestException.java \\\n+java/security/GeneralSecurityException.java \\\n+java/security/InvalidAlgorithmParameterException.java \\\n+java/security/InvalidKeyException.java \\\n+java/security/InvalidParameterException.java \\\n+java/security/Key.java \\\n+java/security/KeyException.java\t\\\n+java/security/KeyPair.java \\\n+java/security/KeyPairGenerator.java \\\n+java/security/KeyPairGeneratorSpi.java \\\n+java/security/NoSuchProviderException.java \\\n+java/security/PrivateKey.java \\\n+java/security/Provider.java \\\n+java/security/PublicKey.java \\\n+java/security/SecureRandom.java\t\\\n+java/security/Security.java \\\n+java/security/Signature.java \\\n+java/security/SignatureException.java \\\n+java/security/spec/AlgorithmParameterSpec.java \\\n+java/security/spec/InvalidKeySpecException.java\t\\\n+java/security/spec/InvalidParameterSpecException.java \\\n+java/security/spec/KeySpec.java\t\\\n+java/security/spec/RSAPrivateCrtKeySpec.java \\\n+java/security/spec/RSAPrivateKeySpec.java \\\n+java/security/spec/RSAPublicKeySpec.java \\\n+java/security/BasicPermission.java \\\n+java/security/Guard.java \\\n+java/security/DigestOutputStream.java \\\n+java/security/Permission.java \\\n+java/security/PermissionCollection.java\t\\\n+java/math/BigDecimal.java \\\n+java/math/BigInteger.java \\\n+java/sql/CallableStatement.java\t\\\n+java/sql/Connection.java \\\n+java/sql/DataTruncation.java \\\n+java/sql/DatabaseMetaData.java \\\n+java/sql/Date.java \\\n+java/sql/Driver.java \\\n+java/sql/DriverManager.java \\\n+java/sql/DriverPropertyInfo.java \\\n+java/sql/PreparedStatement.java\t\\\n+java/sql/ResultSet.java\t\\\n+java/sql/ResultSetMetaData.java\t\\\n+java/sql/SQLException.java \\\n+java/sql/SQLWarning.java \\\n+java/sql/Statement.java\t\\\n+java/sql/Time.java \\\n+java/sql/Timestamp.java\t\\\n+java/sql/Types.java \\\n+java/beans/beancontext/BeanContext.java\t\\\n+java/beans/beancontext/BeanContextChild.java \\\n+java/beans/beancontext/BeanContextChildComponentProxy.java \\\n+java/beans/beancontext/BeanContextChildSupport.java \\\n+java/beans/beancontext/BeanContextContainerProxy.java \\\n+java/beans/beancontext/BeanContextEvent.java \\\n+java/beans/beancontext/BeanContextMembershipEvent.java \\\n+java/beans/beancontext/BeanContextMembershipListener.java \\\n+java/beans/beancontext/BeanContextProxy.java \\\n+java/beans/beancontext/BeanContextServiceAvailableEvent.java \\\n+java/beans/beancontext/BeanContextServiceProvider.java \\\n+java/beans/beancontext/BeanContextServiceProviderBeanInfo.java \\\n+java/beans/beancontext/BeanContextServiceRevokedEvent.java \\\n+java/beans/beancontext/BeanContextServiceRevokedListener.java \\\n+java/beans/beancontext/BeanContextServices.java\t\\\n+java/beans/beancontext/BeanContextServicesListener.java\t\\\n+java/beans/BeanDescriptor.java \\\n+java/beans/BeanInfo.java \\\n+java/beans/Beans.java \\\n+java/beans/Customizer.java \\\n+java/beans/DesignMode.java \\\n+java/beans/EventSetDescriptor.java \\\n+java/beans/FeatureDescriptor.java \\\n+java/beans/IndexedPropertyDescriptor.java \\\n+java/beans/IntrospectionException.java \\\n+java/beans/Introspector.java \\\n+java/beans/MethodDescriptor.java \\\n+java/beans/ParameterDescriptor.java \\\n+java/beans/PropertyChangeEvent.java \\\n+java/beans/PropertyChangeListener.java \\\n+java/beans/PropertyChangeSupport.java \\\n+java/beans/PropertyDescriptor.java \\\n+java/beans/PropertyEditor.java \\\n+java/beans/PropertyEditorManager.java \\\n+java/beans/PropertyEditorSupport.java \\\n+java/beans/PropertyVetoException.java \\\n+java/beans/SimpleBeanInfo.java \\\n+java/beans/VetoableChangeListener.java \\\n+java/beans/VetoableChangeSupport.java \\\n+java/beans/Visibility.java\n \n java_source_files = $(ordinary_java_source_files) $(special_java_source_files)\n \n@@ -927,10 +1027,14 @@ gnu/gcj/convert/natInput_EUCJIS.cc \\\n gnu/gcj/convert/natInput_SJIS.cc \\\n gnu/gcj/convert/natOutput_EUCJIS.cc \\\n gnu/gcj/convert/natOutput_SJIS.cc \\\n+gnu/gcj/io/natSimpleSHSStream.cc \\\n+gnu/gcj/io/shs.cc \\\n gnu/gcj/jni/natNativeThread.cc \\\n gnu/gcj/runtime/natFirstThread.cc \\\n java/io/natFile.cc \\\n java/io/natFileDescriptor.cc \\\n+java/io/natObjectInputStream.cc \\\n+java/io/natObjectOutputStream.cc \\\n java/lang/natCharacter.cc \\\n java/lang/natClass.cc \\\n java/lang/natClassLoader.cc \\\n@@ -1035,12 +1139,3 @@ distclean-multi:\n \t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean\n maintainer-clean-multi:\n \t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean\n-\n-\n-## ################################################################\n-\n-\n-## See above.\n-cygnus_hack =\n-\n-"}, {"sha": "881731bd248bc5be962637c285f486356fd2524a", "filename": "libjava/Makefile.in", "status": "modified", "additions": 400, "deletions": 199, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -98,6 +98,7 @@ OBJDUMP = @OBJDUMP@\n PACKAGE = @PACKAGE@\n PERL = @PERL@\n RANLIB = @RANLIB@\n+SYSDEP_SOURCES = @SYSDEP_SOURCES@\n SYSTEMSPEC = @SYSTEMSPEC@\n THREADDEPS = @THREADDEPS@\n THREADINCS = @THREADINCS@\n@@ -138,6 +139,8 @@ data_DATA = libgcj.zip\n \n @NATIVE_TRUE@bin_PROGRAMS = \\\n @NATIVE_TRUE@jv-convert gij\n+\n+bin_SCRIPTS = addr2name.awk\n @CANADIAN_TRUE@@NULL_TARGET_TRUE@GCJ = \\\n @CANADIAN_TRUE@@NULL_TARGET_TRUE@gcj\n @CANADIAN_TRUE@@NULL_TARGET_FALSE@GCJ = \\\n@@ -229,7 +232,9 @@ SUFFIXES = .class .java .h\n \n nat_headers = $(ordinary_java_source_files:.java=.h) \\\n \t$(built_java_source_files:.java=.h) \\\n-\t$(cond_awt_java_source_files:.java=.h)\n+\t$(cond_awt_java_source_files:.java=.h) \\\n+\tjava/io/ObjectOutputStream$$PutField.h \\\n+\tjava/io/ObjectInputStream$$GetField.h\n \n \n extra_headers = java/lang/Object.h java/lang/Class.h\n@@ -293,80 +298,80 @@ gnu/gcj/convert/UnicodeToBytes.java\n special_java_source_files = java/lang/Class.java java/lang/Object.java\n \n awt_java_source_files = \\\n-java/awt/AWTError.java \\\n+java/awt/event/ActionEvent.java\t\\\n+java/awt/event/ActionListener.java \\\n+java/awt/event/ComponentEvent.java \\\n+java/awt/event/KeyAdapter.java \\\n+java/awt/event/InputEvent.java \\\n+java/awt/event/KeyEvent.java \\\n+java/awt/event/KeyListener.java\t\\\n+java/awt/event/TextEvent.java \\\n+java/awt/event/TextListener.java \\\n+java/awt/event/WindowAdapter.java \\\n+java/awt/event/WindowEvent.java\t\\\n+java/awt/event/WindowListener.java \\\n+java/awt/event/InputMethodListener.java\t\\\n+java/awt/event/ComponentListener.java \\\n+java/awt/event/AdjustmentListener.java \\\n+java/awt/event/AWTEventListener.java \\\n+java/awt/event/FocusListener.java \\\n+java/awt/event/AdjustmentEvent.java \\\n+java/awt/event/ItemListener.java \\\n+java/awt/event/ContainerListener.java \\\n+java/awt/event/MouseListener.java \\\n+java/awt/event/MouseMotionListener.java\t\\\n+java/awt/event/ComponentAdapter.java \\\n+java/awt/event/ContainerAdapter.java \\\n+java/awt/event/FocusAdapter.java \\\n+java/awt/event/MouseAdapter.java \\\n+java/awt/event/MouseMotionAdapter.java \\\n+java/awt/event/FocusEvent.java \\\n+java/awt/event/InputMethodEvent.java \\\n+java/awt/event/MouseEvent.java \\\n+java/awt/event/ItemEvent.java \\\n+java/awt/event/InvocationEvent.java \\\n+java/awt/event/PaintEvent.java \\\n+java/awt/event/ContainerEvent.java \\\n java/awt/AWTEvent.java \\\n-java/awt/AWTException.java \\\n-java/awt/ActiveEvent.java \\\n-java/awt/Adjustable.java \\\n java/awt/BorderLayout.java \\\n-java/awt/Color.java \\\n java/awt/Component.java\t\\\n java/awt/Container.java\t\\\n java/awt/Dimension.java\t\\\n java/awt/Event.java \\\n java/awt/Font.java \\\n java/awt/Frame.java \\\n-java/awt/Graphics.java \\\n-java/awt/IllegalComponentStateException.java \\\n-java/awt/Image.java \\\n-java/awt/ItemSelectable.java \\\n java/awt/LayoutManager.java \\\n java/awt/LayoutManager2.java \\\n java/awt/Menu.java \\\n java/awt/MenuBar.java \\\n java/awt/MenuComponent.java \\\n java/awt/MenuContainer.java \\\n java/awt/MenuItem.java \\\n-java/awt/Paint.java \\\n-java/awt/PaintContext.java \\\n java/awt/Point.java \\\n-java/awt/Rectangle.java\t\\\n+java/awt/AWTError.java \\\n java/awt/Shape.java \\\n java/awt/TextArea.java \\\n java/awt/TextComponent.java \\\n java/awt/Toolkit.java \\\n-java/awt/Transparency.java \\\n java/awt/Window.java \\\n-java/awt/event/AWTEventListener.java \\\n-java/awt/event/ActionEvent.java\t\\\n-java/awt/event/ActionListener.java \\\n-java/awt/event/AdjustmentEvent.java \\\n-java/awt/event/AdjustmentListener.java \\\n-java/awt/event/ComponentAdapter.java \\\n-java/awt/event/ComponentEvent.java \\\n-java/awt/event/ComponentListener.java \\\n-java/awt/event/ContainerAdapter.java \\\n-java/awt/event/ContainerEvent.java \\\n-java/awt/event/ContainerListener.java \\\n-java/awt/event/FocusAdapter.java \\\n-java/awt/event/FocusEvent.java \\\n-java/awt/event/FocusListener.java \\\n-java/awt/event/InputEvent.java \\\n-java/awt/event/InputMethodEvent.java \\\n-java/awt/event/InputMethodListener.java\t\\\n-java/awt/event/InvocationEvent.java \\\n-java/awt/event/ItemEvent.java \\\n-java/awt/event/ItemListener.java \\\n-java/awt/event/KeyAdapter.java \\\n-java/awt/event/KeyEvent.java \\\n-java/awt/event/KeyListener.java\t\\\n-java/awt/event/MouseAdapter.java \\\n-java/awt/event/MouseEvent.java \\\n-java/awt/event/MouseListener.java \\\n-java/awt/event/MouseMotionAdapter.java \\\n-java/awt/event/MouseMotionListener.java\t\\\n-java/awt/event/PaintEvent.java \\\n-java/awt/event/TextEvent.java \\\n-java/awt/event/TextListener.java \\\n-java/awt/event/WindowAdapter.java \\\n-java/awt/event/WindowEvent.java\t\\\n-java/awt/event/WindowListener.java \\\n java/awt/geom/Dimension2D.java \\\n java/awt/geom/Point2D.java \\\n java/awt/peer/ComponentPeer.java \\\n java/awt/peer/ContainerPeer.java \\\n java/awt/peer/FramePeer.java \\\n-java/awt/peer/WindowPeer.java\n+java/awt/peer/WindowPeer.java \\\n+java/awt/Adjustable.java \\\n+java/awt/Color.java \\\n+java/awt/Graphics.java \\\n+java/awt/Image.java \\\n+java/awt/Paint.java \\\n+java/awt/PaintContext.java \\\n+java/awt/Transparency.java \\\n+java/awt/ItemSelectable.java \\\n+java/awt/AWTException.java \\\n+java/awt/ActiveEvent.java \\\n+java/awt/Rectangle.java\t\\\n+java/awt/IllegalComponentStateException.java\n \n @AWT_TRUE@cond_awt_java_source_files = \\\n @AWT_TRUE@$(awt_java_source_files)\n@@ -375,27 +380,49 @@ java/awt/peer/WindowPeer.java\n built_java_source_files = java/lang/ConcreteProcess.java\n \n ordinary_java_source_files = $(convert_source_files) \\\n-gnu/gcj/io/DefaultMimeTypes.java \\\n-gnu/gcj/io/MimeTypes.java \\\n-gnu/gcj/jni/NativeThread.java \\\n-gnu/gcj/runtime/VMClassLoader.java \\\n-gnu/gcj/runtime/FirstThread.java \\\n+gnu/gcj/protocol/http/Connection.java \\\n+gnu/gcj/protocol/http/Handler.java \\\n+gnu/gcj/protocol/file/Connection.java \\\n+gnu/gcj/protocol/file/Handler.java \\\n+gnu/gcj/protocol/jar/Connection.java \\\n+gnu/gcj/protocol/jar/Handler.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n gnu/gcj/text/CharacterBreakIterator.java \\\n gnu/gcj/text/LineBreakIterator.java \\\n gnu/gcj/text/LocaleData_en.java\t\\\n gnu/gcj/text/LocaleData_en_US.java \\\n gnu/gcj/text/SentenceBreakIterator.java\t\\\n gnu/gcj/text/WordBreakIterator.java \\\n-gnu/gcj/math/MPN.java \\\n-gnu/gcj/protocol/file/Connection.java \\\n-gnu/gcj/protocol/file/Handler.java \\\n-gnu/gcj/protocol/http/Connection.java \\\n-gnu/gcj/protocol/http/Handler.java \\\n-gnu/gcj/protocol/jar/Handler.java \\\n-gnu/gcj/protocol/jar/Connection.java \\\n-gnu/gcj/RawData.java \\\n gnu/gcj/util/EnumerationChain.java \\\n+gnu/gcj/RawData.java \\\n+gnu/gcj/math/MPN.java \\\n+gnu/gcj/runtime/VMClassLoader.java \\\n+gnu/gcj/runtime/FirstThread.java \\\n+gnu/gcj/jni/NativeThread.java \\\n+gnu/gcj/io/DefaultMimeTypes.java \\\n+gnu/gcj/io/MimeTypes.java \\\n+gnu/gcj/io/SimpleSHSStream.java\t\\\n+gnu/java/beans/editors/ColorEditor.java\t\\\n+gnu/java/beans/editors/FontEditor.java \\\n+gnu/java/beans/editors/NativeBooleanEditor.java\t\\\n+gnu/java/beans/editors/NativeByteEditor.java \\\n+gnu/java/beans/editors/NativeDoubleEditor.java \\\n+gnu/java/beans/editors/NativeFloatEditor.java \\\n+gnu/java/beans/editors/NativeIntEditor.java \\\n+gnu/java/beans/editors/NativeLongEditor.java \\\n+gnu/java/beans/editors/NativeShortEditor.java \\\n+gnu/java/beans/editors/StringEditor.java \\\n+gnu/java/beans/info/ComponentBeanInfo.java \\\n+gnu/java/beans/BeanInfoEmbryo.java \\\n+gnu/java/beans/EmptyBeanInfo.java \\\n+gnu/java/beans/ExplicitBeanInfo.java \\\n+gnu/java/beans/IntrospectionIncubator.java \\\n+gnu/java/io/ClassLoaderObjectInputStream.java \\\n+gnu/java/io/NullOutputStream.java \\\n+gnu/java/io/ObjectIdentityWrapper.java \\\n+gnu/java/lang/reflect/TypeSignature.java \\\n+gnu/java/lang/ArrayHelper.java \\\n+gnu/java/lang/ClassHelper.java \\\n java/io/BufferedInputStream.java \\\n java/io/BufferedOutputStream.java \\\n java/io/BufferedReader.java \\\n@@ -411,7 +438,6 @@ java/io/DataOutput.java\t\\\n java/io/DataOutputStream.java \\\n java/io/EOFException.java \\\n java/io/File.java \\\n-java/io/FileDescriptor.java \\\n java/io/FileInputStream.java \\\n java/io/FileNotFoundException.java \\\n java/io/FileOutputStream.java \\\n@@ -428,11 +454,10 @@ java/io/InputStreamReader.java \\\n java/io/InterruptedIOException.java \\\n java/io/LineNumberInputStream.java \\\n java/io/LineNumberReader.java \\\n-java/io/ObjectStreamException.java \\\n-java/io/OptionalDataException.java \\\n java/io/OutputStream.java \\\n java/io/OutputStreamWriter.java\t\\\n-java/io/PipedInputStream.java \\\n+java/io/Externalizable.java \\\n+java/io/FileDescriptor.java \\\n java/io/PipedOutputStream.java \\\n java/io/PipedReader.java \\\n java/io/PipedWriter.java \\\n@@ -444,7 +469,6 @@ java/io/RandomAccessFile.java \\\n java/io/Reader.java \\\n java/io/SequenceInputStream.java \\\n java/io/Serializable.java \\\n-java/io/StreamCorruptedException.java \\\n java/io/StreamTokenizer.java \\\n java/io/StringBufferInputStream.java \\\n java/io/StringReader.java \\\n@@ -453,6 +477,35 @@ java/io/SyncFailedException.java \\\n java/io/UTFDataFormatException.java \\\n java/io/UnsupportedEncodingException.java \\\n java/io/Writer.java \\\n+java/io/ObjectStreamException.java \\\n+java/io/OptionalDataException.java \\\n+java/io/StreamCorruptedException.java \\\n+java/io/BlockDataException.java\t\\\n+java/io/InvalidClassException.java \\\n+java/io/InvalidObjectException.java \\\n+java/io/NotActiveException.java\t\\\n+java/io/NotSerializableException.java \\\n+java/io/ObjectInput.java \\\n+java/io/ObjectInputStream.java \\\n+java/io/ObjectInputValidation.java \\\n+java/io/ObjectOutput.java \\\n+java/io/ObjectOutputStream.java\t\\\n+java/io/ObjectStreamClass.java \\\n+java/io/ObjectStreamConstants.java \\\n+java/io/ObjectStreamField.java \\\n+java/io/Replaceable.java \\\n+java/io/Resolvable.java\t\\\n+java/io/SerializablePermission.java \\\n+java/io/WriteAbortedException.java \\\n+java/io/PipedInputStream.java \\\n+java/lang/reflect/Constructor.java \\\n+java/lang/reflect/AccessibleObject.java\t\\\n+java/lang/reflect/Array.java \\\n+java/lang/reflect/Method.java \\\n+java/lang/reflect/Field.java \\\n+java/lang/reflect/InvocationTargetException.java \\\n+java/lang/reflect/Member.java \\\n+java/lang/reflect/Modifier.java\t\\\n java/lang/AbstractMethodError.java \\\n java/lang/ArithmeticException.java \\\n java/lang/ArrayIndexOutOfBoundsException.java \\\n@@ -481,10 +534,10 @@ java/lang/IllegalMonitorStateException.java \\\n java/lang/IllegalStateException.java \\\n java/lang/IllegalThreadStateException.java \\\n java/lang/IncompatibleClassChangeError.java \\\n-java/lang/IndexOutOfBoundsException.java \\\n java/lang/InstantiationError.java \\\n-java/lang/InstantiationException.java \\\n java/lang/Integer.java \\\n+java/lang/IndexOutOfBoundsException.java \\\n+java/lang/InstantiationException.java \\\n java/lang/InternalError.java \\\n java/lang/InterruptedException.java \\\n java/lang/LinkageError.java \\\n@@ -522,107 +575,42 @@ java/lang/UnsupportedOperationException.java \\\n java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n java/lang/Void.java \\\n-java/lang/reflect/AccessibleObject.java\t\\\n-java/lang/reflect/Array.java \\\n-java/lang/reflect/Constructor.java \\\n-java/lang/reflect/Field.java \\\n-java/lang/reflect/InvocationTargetException.java \\\n-java/lang/reflect/Member.java \\\n-java/lang/reflect/Method.java \\\n-java/lang/reflect/Modifier.java\t\\\n-java/math/BigDecimal.java \\\n-java/math/BigInteger.java \\\n java/net/BindException.java \\\n java/net/ConnectException.java \\\n java/net/ContentHandler.java \\\n java/net/ContentHandlerFactory.java \\\n-java/net/DatagramPacket.java \\\n-java/net/DatagramSocket.java \\\n-java/net/DatagramSocketImpl.java \\\n java/net/FileNameMap.java \\\n-java/net/HttpURLConnection.java \\\n+java/net/HttpURLConnection.java\t\\\n java/net/InetAddress.java \\\n-java/net/JarURLConnection.java \\\n java/net/MalformedURLException.java \\\n-java/net/MulticastSocket.java \\\n java/net/NoRouteToHostException.java \\\n-java/net/PlainDatagramSocketImpl.java \\\n java/net/PlainSocketImpl.java \\\n java/net/ProtocolException.java\t\\\n java/net/ServerSocket.java \\\n+java/net/URL.java \\\n java/net/Socket.java \\\n java/net/SocketException.java \\\n java/net/SocketImpl.java \\\n java/net/SocketImplFactory.java\t\\\n-java/net/SocketOptions.java \\\n-java/net/URL.java \\\n-java/net/URLClassLoader.java \\\n java/net/URLConnection.java \\\n-java/net/URLDecoder.java \\\n-java/net/URLEncoder.java \\\n java/net/URLStreamHandler.java \\\n java/net/URLStreamHandlerFactory.java \\\n java/net/UnknownHostException.java \\\n java/net/UnknownServiceException.java \\\n-java/security/AlgorithmParameterGeneratorSpi.java \\\n-java/security/DigestException.java \\\n-java/security/GeneralSecurityException.java \\\n-java/security/InvalidAlgorithmParameterException.java \\\n-java/security/InvalidKeyException.java \\\n-java/security/InvalidParameterException.java \\\n-java/security/Key.java \\\n-java/security/KeyException.java \\\n-java/security/KeyPair.java \\\n-java/security/KeyPairGenerator.java \\\n-java/security/KeyPairGeneratorSpi.java \\\n-java/security/MessageDigest.java \\\n-java/security/NoSuchAlgorithmException.java \\\n-java/security/NoSuchProviderException.java \\\n-java/security/PrivateKey.java \\\n-java/security/Provider.java \\\n-java/security/PublicKey.java \\\n-java/security/SecureClassLoader.java \\\n-java/security/SecureRandom.java \\\n-java/security/Security.java \\\n-java/security/Signature.java \\\n-java/security/SignatureException.java \\\n-java/security/interfaces/DSAKey.java \\\n-java/security/interfaces/DSAParams.java \\\n-java/security/interfaces/DSAPrivateKey.java \\\n-java/security/interfaces/DSAPublicKey.java \\\n-java/security/interfaces/RSAPrivateCrtKey.java \\\n-java/security/interfaces/RSAPrivateKey.java \\\n-java/security/interfaces/RSAPublicKey.java \\\n-java/security/spec/AlgorithmParameterSpec.java \\\n-java/security/spec/InvalidKeySpecException.java \\\n-java/security/spec/InvalidParameterSpecException.java \\\n-java/security/spec/KeySpec.java \\\n-java/security/spec/RSAPrivateCrtKeySpec.java \\\n-java/security/spec/RSAPrivateKeySpec.java \\\n-java/security/spec/RSAPublicKeySpec.java \\\n-java/sql/CallableStatement.java \\\n-java/sql/Connection.java \\\n-java/sql/DataTruncation.java \\\n-java/sql/DatabaseMetaData.java \\\n-java/sql/Date.java \\\n-java/sql/Driver.java \\\n-java/sql/DriverManager.java \\\n-java/sql/DriverPropertyInfo.java \\\n-java/sql/PreparedStatement.java \\\n-java/sql/ResultSet.java \\\n-java/sql/ResultSetMetaData.java \\\n-java/sql/SQLException.java \\\n-java/sql/SQLWarning.java \\\n-java/sql/Statement.java \\\n-java/sql/Time.java \\\n-java/sql/Timestamp.java \\\n-java/sql/Types.java \\\n+java/net/URLDecoder.java \\\n+java/net/URLEncoder.java \\\n+java/net/DatagramPacket.java \\\n+java/net/DatagramSocket.java \\\n+java/net/DatagramSocketImpl.java \\\n+java/net/MulticastSocket.java \\\n+java/net/PlainDatagramSocketImpl.java \\\n+java/net/SocketOptions.java \\\n+java/net/JarURLConnection.java \\\n+java/net/URLClassLoader.java \\\n+java/text/Collator.java\t\\\n java/text/BreakIterator.java \\\n java/text/CharacterIterator.java \\\n java/text/ChoiceFormat.java \\\n-java/text/CollationElementIterator.java \\\n-java/text/CollationKey.java \\\n-java/text/Collator.java \\\n java/text/DateFormat.java \\\n java/text/DateFormatSymbols.java \\\n java/text/DecimalFormat.java \\\n@@ -633,13 +621,34 @@ java/text/MessageFormat.java \\\n java/text/NumberFormat.java \\\n java/text/ParseException.java \\\n java/text/ParsePosition.java \\\n-java/text/RuleBasedCollator.java \\\n java/text/SimpleDateFormat.java\t\\\n java/text/StringCharacterIterator.java \\\n+java/text/CollationElementIterator.java\t\\\n+java/text/CollationKey.java \\\n+java/text/RuleBasedCollator.java \\\n+java/util/zip/Adler32.java \\\n+java/util/zip/CRC32.java \\\n+java/util/zip/Checksum.java \\\n+java/util/zip/Deflater.java \\\n+java/util/zip/DeflaterOutputStream.java\t\\\n+java/util/zip/ZipConstants.java\t\\\n+java/util/zip/ZipEntry.java \\\n+java/util/zip/ZipException.java\t\\\n+java/util/zip/ZipFile.java \\\n+java/util/zip/ZipOutputStream.java \\\n+java/util/zip/InflaterInputStream.java \\\n+java/util/zip/ZipInputStream.java \\\n+java/util/zip/DataFormatException.java \\\n+java/util/zip/CheckedInputStream.java \\\n+java/util/zip/CheckedOutputStream.java \\\n+java/util/zip/Inflater.java \\\n+java/util/zip/GZIPInputStream.java \\\n+java/util/zip/GZIPOutputStream.java \\\n+java/util/jar/JarEntry.java \\\n+java/util/jar/JarFile.java \\\n+java/util/jar/JarInputStream.java \\\n java/util/BitSet.java \\\n java/util/Calendar.java\t\\\n-java/util/Collection.java \\\n-java/util/Comparator.java \\\n java/util/ConcurrentModificationException.java \\\n java/util/Date.java \\\n java/util/Dictionary.java \\\n@@ -649,17 +658,13 @@ java/util/EventListener.java \\\n java/util/EventObject.java \\\n java/util/GregorianCalendar.java \\\n java/util/Hashtable.java \\\n-java/util/Iterator.java \\\n-java/util/List.java \\\n-java/util/ListIterator.java \\\n java/util/ListResourceBundle.java \\\n java/util/Locale.java \\\n java/util/MissingResourceException.java\t\\\n java/util/NoSuchElementException.java \\\n java/util/Observable.java \\\n java/util/Observer.java\t\\\n java/util/Properties.java \\\n-java/util/PropertyResourceBundle.java \\\n java/util/Random.java \\\n java/util/ResourceBundle.java \\\n java/util/SimpleTimeZone.java \\\n@@ -668,27 +673,115 @@ java/util/StringTokenizer.java \\\n java/util/TimeZone.java\t\\\n java/util/TooManyListenersException.java \\\n java/util/Vector.java \\\n-java/util/jar/JarFile.java \\\n-java/util/jar/JarInputStream.java \\\n-java/util/jar/JarEntry.java \\\n-java/util/zip/Adler32.java \\\n-java/util/zip/CRC32.java \\\n-java/util/zip/CheckedInputStream.java \\\n-java/util/zip/CheckedOutputStream.java \\\n-java/util/zip/Checksum.java \\\n-java/util/zip/DataFormatException.java \\\n-java/util/zip/Deflater.java \\\n-java/util/zip/DeflaterOutputStream.java\t\\\n-java/util/zip/GZIPInputStream.java \\\n-java/util/zip/GZIPOutputStream.java \\\n-java/util/zip/Inflater.java \\\n-java/util/zip/InflaterInputStream.java\t\\\n-java/util/zip/ZipConstants.java\t\\\n-java/util/zip/ZipEntry.java \\\n-java/util/zip/ZipException.java\t\\\n-java/util/zip/ZipFile.java \\\n-java/util/zip/ZipInputStream.java \\\n-java/util/zip/ZipOutputStream.java\n+java/util/List.java \\\n+java/util/Collection.java \\\n+java/util/Comparator.java \\\n+java/util/Iterator.java\t\\\n+java/util/PropertyResourceBundle.java \\\n+java/util/Arrays.java \\\n+java/util/ListIterator.java \\\n+java/util/AbstractCollection.java \\\n+java/util/AbstractList.java \\\n+java/security/MessageDigest.java \\\n+java/security/NoSuchAlgorithmException.java \\\n+java/security/SecureClassLoader.java \\\n+java/security/interfaces/DSAKey.java \\\n+java/security/interfaces/DSAParams.java\t\\\n+java/security/interfaces/DSAPrivateKey.java \\\n+java/security/interfaces/DSAPublicKey.java \\\n+java/security/interfaces/RSAPrivateCrtKey.java \\\n+java/security/interfaces/RSAPrivateKey.java \\\n+java/security/interfaces/RSAPublicKey.java \\\n+java/security/AlgorithmParameterGeneratorSpi.java \\\n+java/security/DigestException.java \\\n+java/security/GeneralSecurityException.java \\\n+java/security/InvalidAlgorithmParameterException.java \\\n+java/security/InvalidKeyException.java \\\n+java/security/InvalidParameterException.java \\\n+java/security/Key.java \\\n+java/security/KeyException.java\t\\\n+java/security/KeyPair.java \\\n+java/security/KeyPairGenerator.java \\\n+java/security/KeyPairGeneratorSpi.java \\\n+java/security/NoSuchProviderException.java \\\n+java/security/PrivateKey.java \\\n+java/security/Provider.java \\\n+java/security/PublicKey.java \\\n+java/security/SecureRandom.java\t\\\n+java/security/Security.java \\\n+java/security/Signature.java \\\n+java/security/SignatureException.java \\\n+java/security/spec/AlgorithmParameterSpec.java \\\n+java/security/spec/InvalidKeySpecException.java\t\\\n+java/security/spec/InvalidParameterSpecException.java \\\n+java/security/spec/KeySpec.java\t\\\n+java/security/spec/RSAPrivateCrtKeySpec.java \\\n+java/security/spec/RSAPrivateKeySpec.java \\\n+java/security/spec/RSAPublicKeySpec.java \\\n+java/security/BasicPermission.java \\\n+java/security/Guard.java \\\n+java/security/DigestOutputStream.java \\\n+java/security/Permission.java \\\n+java/security/PermissionCollection.java\t\\\n+java/math/BigDecimal.java \\\n+java/math/BigInteger.java \\\n+java/sql/CallableStatement.java\t\\\n+java/sql/Connection.java \\\n+java/sql/DataTruncation.java \\\n+java/sql/DatabaseMetaData.java \\\n+java/sql/Date.java \\\n+java/sql/Driver.java \\\n+java/sql/DriverManager.java \\\n+java/sql/DriverPropertyInfo.java \\\n+java/sql/PreparedStatement.java\t\\\n+java/sql/ResultSet.java\t\\\n+java/sql/ResultSetMetaData.java\t\\\n+java/sql/SQLException.java \\\n+java/sql/SQLWarning.java \\\n+java/sql/Statement.java\t\\\n+java/sql/Time.java \\\n+java/sql/Timestamp.java\t\\\n+java/sql/Types.java \\\n+java/beans/beancontext/BeanContext.java\t\\\n+java/beans/beancontext/BeanContextChild.java \\\n+java/beans/beancontext/BeanContextChildComponentProxy.java \\\n+java/beans/beancontext/BeanContextChildSupport.java \\\n+java/beans/beancontext/BeanContextContainerProxy.java \\\n+java/beans/beancontext/BeanContextEvent.java \\\n+java/beans/beancontext/BeanContextMembershipEvent.java \\\n+java/beans/beancontext/BeanContextMembershipListener.java \\\n+java/beans/beancontext/BeanContextProxy.java \\\n+java/beans/beancontext/BeanContextServiceAvailableEvent.java \\\n+java/beans/beancontext/BeanContextServiceProvider.java \\\n+java/beans/beancontext/BeanContextServiceProviderBeanInfo.java \\\n+java/beans/beancontext/BeanContextServiceRevokedEvent.java \\\n+java/beans/beancontext/BeanContextServiceRevokedListener.java \\\n+java/beans/beancontext/BeanContextServices.java\t\\\n+java/beans/beancontext/BeanContextServicesListener.java\t\\\n+java/beans/BeanDescriptor.java \\\n+java/beans/BeanInfo.java \\\n+java/beans/Beans.java \\\n+java/beans/Customizer.java \\\n+java/beans/DesignMode.java \\\n+java/beans/EventSetDescriptor.java \\\n+java/beans/FeatureDescriptor.java \\\n+java/beans/IndexedPropertyDescriptor.java \\\n+java/beans/IntrospectionException.java \\\n+java/beans/Introspector.java \\\n+java/beans/MethodDescriptor.java \\\n+java/beans/ParameterDescriptor.java \\\n+java/beans/PropertyChangeEvent.java \\\n+java/beans/PropertyChangeListener.java \\\n+java/beans/PropertyChangeSupport.java \\\n+java/beans/PropertyDescriptor.java \\\n+java/beans/PropertyEditor.java \\\n+java/beans/PropertyEditorManager.java \\\n+java/beans/PropertyEditorSupport.java \\\n+java/beans/PropertyVetoException.java \\\n+java/beans/SimpleBeanInfo.java \\\n+java/beans/VetoableChangeListener.java \\\n+java/beans/VetoableChangeSupport.java \\\n+java/beans/Visibility.java\n \n \n java_source_files = $(ordinary_java_source_files) $(special_java_source_files)\n@@ -720,10 +813,14 @@ gnu/gcj/convert/natInput_EUCJIS.cc \\\n gnu/gcj/convert/natInput_SJIS.cc \\\n gnu/gcj/convert/natOutput_EUCJIS.cc \\\n gnu/gcj/convert/natOutput_SJIS.cc \\\n+gnu/gcj/io/natSimpleSHSStream.cc \\\n+gnu/gcj/io/shs.cc \\\n gnu/gcj/jni/natNativeThread.cc \\\n gnu/gcj/runtime/natFirstThread.cc \\\n java/io/natFile.cc \\\n java/io/natFileDescriptor.cc \\\n+java/io/natObjectInputStream.cc \\\n+java/io/natObjectOutputStream.cc \\\n java/lang/natCharacter.cc \\\n java/lang/natClass.cc \\\n java/lang/natClassLoader.cc \\\n@@ -800,8 +897,6 @@ MULTIDIRS =\n MULTISUBDIR = \n MULTIDO = true\n MULTICLEAN = true\n-\n-cygnus_hack = \n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n CONFIG_HEADER = ./include/config.h\n@@ -829,6 +924,8 @@ jv_convert_OBJECTS =\n gij_OBJECTS =  gij.o\n gen_from_JIS_OBJECTS = \n gen_from_JIS_LDFLAGS = \n+SCRIPTS =  $(bin_SCRIPTS)\n+\n CXXFLAGS = @CXXFLAGS@\n CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n LTCXXCOMPILE = $(LIBTOOL) --mode=compile $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n@@ -868,8 +965,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/convert/Output_iconv.P \\\n .deps/gnu/gcj/convert/UnicodeToBytes.P \\\n .deps/gnu/gcj/io/DefaultMimeTypes.P .deps/gnu/gcj/io/MimeTypes.P \\\n-.deps/gnu/gcj/jni/NativeThread.P .deps/gnu/gcj/math/MPN.P \\\n-.deps/gnu/gcj/protocol/file/Connection.P \\\n+.deps/gnu/gcj/io/SimpleSHSStream.P .deps/gnu/gcj/jni/NativeThread.P \\\n+.deps/gnu/gcj/math/MPN.P .deps/gnu/gcj/protocol/file/Connection.P \\\n .deps/gnu/gcj/protocol/file/Handler.P \\\n .deps/gnu/gcj/protocol/http/Connection.P \\\n .deps/gnu/gcj/protocol/http/Handler.P \\\n@@ -884,7 +981,27 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/text/LocaleData_en_US.P \\\n .deps/gnu/gcj/text/SentenceBreakIterator.P \\\n .deps/gnu/gcj/text/WordBreakIterator.P \\\n-.deps/gnu/gcj/util/EnumerationChain.P .deps/interpret.P \\\n+.deps/gnu/gcj/util/EnumerationChain.P \\\n+.deps/gnu/java/beans/BeanInfoEmbryo.P \\\n+.deps/gnu/java/beans/EmptyBeanInfo.P \\\n+.deps/gnu/java/beans/ExplicitBeanInfo.P \\\n+.deps/gnu/java/beans/IntrospectionIncubator.P \\\n+.deps/gnu/java/beans/editors/ColorEditor.P \\\n+.deps/gnu/java/beans/editors/FontEditor.P \\\n+.deps/gnu/java/beans/editors/NativeBooleanEditor.P \\\n+.deps/gnu/java/beans/editors/NativeByteEditor.P \\\n+.deps/gnu/java/beans/editors/NativeDoubleEditor.P \\\n+.deps/gnu/java/beans/editors/NativeFloatEditor.P \\\n+.deps/gnu/java/beans/editors/NativeIntEditor.P \\\n+.deps/gnu/java/beans/editors/NativeLongEditor.P \\\n+.deps/gnu/java/beans/editors/NativeShortEditor.P \\\n+.deps/gnu/java/beans/editors/StringEditor.P \\\n+.deps/gnu/java/beans/info/ComponentBeanInfo.P \\\n+.deps/gnu/java/io/ClassLoaderObjectInputStream.P \\\n+.deps/gnu/java/io/NullOutputStream.P \\\n+.deps/gnu/java/io/ObjectIdentityWrapper.P \\\n+.deps/gnu/java/lang/ArrayHelper.P .deps/gnu/java/lang/ClassHelper.P \\\n+.deps/gnu/java/lang/reflect/TypeSignature.P .deps/interpret.P \\\n .deps/java/awt/AWTError.P .deps/java/awt/AWTEvent.P \\\n .deps/java/awt/AWTException.P .deps/java/awt/ActiveEvent.P \\\n .deps/java/awt/Adjustable.P .deps/java/awt/BorderLayout.P \\\n@@ -930,37 +1047,83 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/event/WindowListener.P .deps/java/awt/geom/Dimension2D.P \\\n .deps/java/awt/geom/Point2D.P .deps/java/awt/peer/ComponentPeer.P \\\n .deps/java/awt/peer/ContainerPeer.P .deps/java/awt/peer/FramePeer.P \\\n-.deps/java/awt/peer/WindowPeer.P .deps/java/io/BufferedInputStream.P \\\n+.deps/java/awt/peer/WindowPeer.P .deps/java/beans/BeanDescriptor.P \\\n+.deps/java/beans/BeanInfo.P .deps/java/beans/Beans.P \\\n+.deps/java/beans/Customizer.P .deps/java/beans/DesignMode.P \\\n+.deps/java/beans/EventSetDescriptor.P \\\n+.deps/java/beans/FeatureDescriptor.P \\\n+.deps/java/beans/IndexedPropertyDescriptor.P \\\n+.deps/java/beans/IntrospectionException.P \\\n+.deps/java/beans/Introspector.P .deps/java/beans/MethodDescriptor.P \\\n+.deps/java/beans/ParameterDescriptor.P \\\n+.deps/java/beans/PropertyChangeEvent.P \\\n+.deps/java/beans/PropertyChangeListener.P \\\n+.deps/java/beans/PropertyChangeSupport.P \\\n+.deps/java/beans/PropertyDescriptor.P .deps/java/beans/PropertyEditor.P \\\n+.deps/java/beans/PropertyEditorManager.P \\\n+.deps/java/beans/PropertyEditorSupport.P \\\n+.deps/java/beans/PropertyVetoException.P \\\n+.deps/java/beans/SimpleBeanInfo.P \\\n+.deps/java/beans/VetoableChangeListener.P \\\n+.deps/java/beans/VetoableChangeSupport.P .deps/java/beans/Visibility.P \\\n+.deps/java/beans/beancontext/BeanContext.P \\\n+.deps/java/beans/beancontext/BeanContextChild.P \\\n+.deps/java/beans/beancontext/BeanContextChildComponentProxy.P \\\n+.deps/java/beans/beancontext/BeanContextChildSupport.P \\\n+.deps/java/beans/beancontext/BeanContextContainerProxy.P \\\n+.deps/java/beans/beancontext/BeanContextEvent.P \\\n+.deps/java/beans/beancontext/BeanContextMembershipEvent.P \\\n+.deps/java/beans/beancontext/BeanContextMembershipListener.P \\\n+.deps/java/beans/beancontext/BeanContextProxy.P \\\n+.deps/java/beans/beancontext/BeanContextServiceAvailableEvent.P \\\n+.deps/java/beans/beancontext/BeanContextServiceProvider.P \\\n+.deps/java/beans/beancontext/BeanContextServiceProviderBeanInfo.P \\\n+.deps/java/beans/beancontext/BeanContextServiceRevokedEvent.P \\\n+.deps/java/beans/beancontext/BeanContextServiceRevokedListener.P \\\n+.deps/java/beans/beancontext/BeanContextServices.P \\\n+.deps/java/beans/beancontext/BeanContextServicesListener.P \\\n+.deps/java/io/BlockDataException.P .deps/java/io/BufferedInputStream.P \\\n .deps/java/io/BufferedOutputStream.P .deps/java/io/BufferedReader.P \\\n .deps/java/io/BufferedWriter.P .deps/java/io/ByteArrayInputStream.P \\\n .deps/java/io/ByteArrayOutputStream.P .deps/java/io/CharArrayReader.P \\\n .deps/java/io/CharArrayWriter.P .deps/java/io/CharConversionException.P \\\n .deps/java/io/DataInput.P .deps/java/io/DataInputStream.P \\\n .deps/java/io/DataOutput.P .deps/java/io/DataOutputStream.P \\\n-.deps/java/io/EOFException.P .deps/java/io/File.P \\\n-.deps/java/io/FileDescriptor.P .deps/java/io/FileInputStream.P \\\n-.deps/java/io/FileNotFoundException.P .deps/java/io/FileOutputStream.P \\\n-.deps/java/io/FileReader.P .deps/java/io/FileWriter.P \\\n-.deps/java/io/FilenameFilter.P .deps/java/io/FilterInputStream.P \\\n-.deps/java/io/FilterOutputStream.P .deps/java/io/FilterReader.P \\\n-.deps/java/io/FilterWriter.P .deps/java/io/IOException.P \\\n-.deps/java/io/InputStream.P .deps/java/io/InputStreamReader.P \\\n+.deps/java/io/EOFException.P .deps/java/io/Externalizable.P \\\n+.deps/java/io/File.P .deps/java/io/FileDescriptor.P \\\n+.deps/java/io/FileInputStream.P .deps/java/io/FileNotFoundException.P \\\n+.deps/java/io/FileOutputStream.P .deps/java/io/FileReader.P \\\n+.deps/java/io/FileWriter.P .deps/java/io/FilenameFilter.P \\\n+.deps/java/io/FilterInputStream.P .deps/java/io/FilterOutputStream.P \\\n+.deps/java/io/FilterReader.P .deps/java/io/FilterWriter.P \\\n+.deps/java/io/IOException.P .deps/java/io/InputStream.P \\\n+.deps/java/io/InputStreamReader.P \\\n .deps/java/io/InterruptedIOException.P \\\n+.deps/java/io/InvalidClassException.P \\\n+.deps/java/io/InvalidObjectException.P \\\n .deps/java/io/LineNumberInputStream.P .deps/java/io/LineNumberReader.P \\\n-.deps/java/io/ObjectStreamException.P \\\n+.deps/java/io/NotActiveException.P \\\n+.deps/java/io/NotSerializableException.P .deps/java/io/ObjectInput.P \\\n+.deps/java/io/ObjectInputStream.P .deps/java/io/ObjectInputValidation.P \\\n+.deps/java/io/ObjectOutput.P .deps/java/io/ObjectOutputStream.P \\\n+.deps/java/io/ObjectStreamClass.P .deps/java/io/ObjectStreamConstants.P \\\n+.deps/java/io/ObjectStreamException.P .deps/java/io/ObjectStreamField.P \\\n .deps/java/io/OptionalDataException.P .deps/java/io/OutputStream.P \\\n .deps/java/io/OutputStreamWriter.P .deps/java/io/PipedInputStream.P \\\n .deps/java/io/PipedOutputStream.P .deps/java/io/PipedReader.P \\\n .deps/java/io/PipedWriter.P .deps/java/io/PrintStream.P \\\n .deps/java/io/PrintWriter.P .deps/java/io/PushbackInputStream.P \\\n .deps/java/io/PushbackReader.P .deps/java/io/RandomAccessFile.P \\\n-.deps/java/io/Reader.P .deps/java/io/SequenceInputStream.P \\\n-.deps/java/io/Serializable.P .deps/java/io/StreamCorruptedException.P \\\n+.deps/java/io/Reader.P .deps/java/io/Replaceable.P \\\n+.deps/java/io/Resolvable.P .deps/java/io/SequenceInputStream.P \\\n+.deps/java/io/Serializable.P .deps/java/io/SerializablePermission.P \\\n+.deps/java/io/StreamCorruptedException.P \\\n .deps/java/io/StreamTokenizer.P .deps/java/io/StringBufferInputStream.P \\\n .deps/java/io/StringReader.P .deps/java/io/StringWriter.P \\\n .deps/java/io/SyncFailedException.P \\\n .deps/java/io/UTFDataFormatException.P \\\n-.deps/java/io/UnsupportedEncodingException.P .deps/java/io/Writer.P \\\n+.deps/java/io/UnsupportedEncodingException.P \\\n+.deps/java/io/WriteAbortedException.P .deps/java/io/Writer.P \\\n .deps/java/lang/AbstractMethodError.P \\\n .deps/java/lang/ArithmeticException.P \\\n .deps/java/lang/ArrayIndexOutOfBoundsException.P \\\n@@ -1054,8 +1217,11 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/net/UnknownHostException.P \\\n .deps/java/net/UnknownServiceException.P \\\n .deps/java/security/AlgorithmParameterGeneratorSpi.P \\\n+.deps/java/security/BasicPermission.P \\\n .deps/java/security/DigestException.P \\\n+.deps/java/security/DigestOutputStream.P \\\n .deps/java/security/GeneralSecurityException.P \\\n+.deps/java/security/Guard.P \\\n .deps/java/security/InvalidAlgorithmParameterException.P \\\n .deps/java/security/InvalidKeyException.P \\\n .deps/java/security/InvalidParameterException.P \\\n@@ -1065,6 +1231,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/security/MessageDigest.P \\\n .deps/java/security/NoSuchAlgorithmException.P \\\n .deps/java/security/NoSuchProviderException.P \\\n+.deps/java/security/Permission.P \\\n+.deps/java/security/PermissionCollection.P \\\n .deps/java/security/PrivateKey.P .deps/java/security/Provider.P \\\n .deps/java/security/PublicKey.P .deps/java/security/SecureClassLoader.P \\\n .deps/java/security/SecureRandom.P .deps/java/security/Security.P \\\n@@ -1102,7 +1270,9 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/text/MessageFormat.P .deps/java/text/NumberFormat.P \\\n .deps/java/text/ParseException.P .deps/java/text/ParsePosition.P \\\n .deps/java/text/RuleBasedCollator.P .deps/java/text/SimpleDateFormat.P \\\n-.deps/java/text/StringCharacterIterator.P .deps/java/util/BitSet.P \\\n+.deps/java/text/StringCharacterIterator.P \\\n+.deps/java/util/AbstractCollection.P .deps/java/util/AbstractList.P \\\n+.deps/java/util/Arrays.P .deps/java/util/BitSet.P \\\n .deps/java/util/Calendar.P .deps/java/util/Collection.P \\\n .deps/java/util/Comparator.P \\\n .deps/java/util/ConcurrentModificationException.P \\\n@@ -1335,6 +1505,25 @@ gij$(EXEEXT): $(gij_OBJECTS) $(gij_DEPENDENCIES)\n gen-from-JIS$(EXEEXT): $(gen_from_JIS_OBJECTS) $(gen_from_JIS_DEPENDENCIES)\n \t@rm -f gen-from-JIS$(EXEEXT)\n \t$(LINK) $(gen_from_JIS_LDFLAGS) $(gen_from_JIS_OBJECTS) $(gen_from_JIS_LDADD) $(LIBS)\n+\n+install-binSCRIPTS: $(bin_SCRIPTS)\n+\t@$(NORMAL_INSTALL)\n+\t$(mkinstalldirs) $(DESTDIR)$(bindir)\n+\t@list='$(bin_SCRIPTS)'; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    echo \" $(INSTALL_SCRIPT) $$p $(DESTDIR)$(bindir)/`echo $$p|sed '$(transform)'`\"; \\\n+\t    $(INSTALL_SCRIPT) $$p $(DESTDIR)$(bindir)/`echo $$p|sed '$(transform)'`; \\\n+\t  else if test -f $(srcdir)/$$p; then \\\n+\t    echo \" $(INSTALL_SCRIPT) $(srcdir)/$$p $(DESTDIR)$(bindir)/`echo $$p|sed '$(transform)'`\"; \\\n+\t    $(INSTALL_SCRIPT) $(srcdir)/$$p $(DESTDIR)$(bindir)/`echo $$p|sed '$(transform)'`; \\\n+\t  else :; fi; fi; \\\n+\tdone\n+\n+uninstall-binSCRIPTS:\n+\t@$(NORMAL_UNINSTALL)\n+\tlist='$(bin_SCRIPTS)'; for p in $$list; do \\\n+\t  rm -f $(DESTDIR)$(bindir)/`echo $$p|sed '$(transform)'`; \\\n+\tdone\n .cc.o:\n \t$(CXXCOMPILE) -c $<\n .cc.lo:\n@@ -1593,7 +1782,7 @@ install-info-am:\n install-info: install-info-recursive\n install-exec-am: install-toolexeclibLIBRARIES \\\n \t\tinstall-toolexeclibLTLIBRARIES install-binPROGRAMS \\\n-\t\tinstall-toolexeclibDATA\n+\t\tinstall-binSCRIPTS install-toolexeclibDATA\n install-exec: install-exec-recursive\n \n install-data-am: install-dataDATA install-data-local\n@@ -1604,17 +1793,20 @@ install-am: all-am\n install: install-recursive\n uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \t\tuninstall-toolexeclibLTLIBRARIES uninstall-binPROGRAMS \\\n-\t\tuninstall-dataDATA uninstall-toolexeclibDATA\n+\t\tuninstall-binSCRIPTS uninstall-dataDATA \\\n+\t\tuninstall-toolexeclibDATA\n uninstall: uninstall-recursive\n-all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) $(PROGRAMS) $(DATA)\n+all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) $(PROGRAMS) $(SCRIPTS) \\\n+\t\t$(DATA)\n all-redirect: all-recursive\n install-strip:\n \t$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install\n installdirs: installdirs-recursive\n installdirs-am:\n \t$(mkinstalldirs)  $(DESTDIR)$(toolexeclibdir) \\\n \t\t$(DESTDIR)$(toolexeclibdir) $(DESTDIR)$(bindir) \\\n-\t\t$(DESTDIR)$(datadir) $(DESTDIR)$(toolexeclibdir)\n+\t\t$(DESTDIR)$(bindir) $(DESTDIR)$(datadir) \\\n+\t\t$(DESTDIR)$(toolexeclibdir)\n \n \n mostlyclean-generic:\n@@ -1680,7 +1872,8 @@ uninstall-toolexeclibLTLIBRARIES install-toolexeclibLTLIBRARIES \\\n mostlyclean-binPROGRAMS distclean-binPROGRAMS clean-binPROGRAMS \\\n maintainer-clean-binPROGRAMS uninstall-binPROGRAMS install-binPROGRAMS \\\n mostlyclean-noinstPROGRAMS distclean-noinstPROGRAMS \\\n-clean-noinstPROGRAMS maintainer-clean-noinstPROGRAMS uninstall-dataDATA \\\n+clean-noinstPROGRAMS maintainer-clean-noinstPROGRAMS \\\n+uninstall-binSCRIPTS install-binSCRIPTS uninstall-dataDATA \\\n install-dataDATA uninstall-toolexeclibDATA install-toolexeclibDATA \\\n install-data-recursive uninstall-data-recursive install-exec-recursive \\\n uninstall-exec-recursive installdirs-recursive uninstalldirs-recursive \\\n@@ -1805,6 +1998,14 @@ gnu/gcj/runtime/VMClassLoader.h: gnu/gcj/runtime/VMClassLoader.class libgcj.zip\n \t    -friend 'java::lang::ClassLoader;' \\\n \t    $(basename $<)\n \n+java/io/ObjectInputStream$$GetField.h: java/io/ObjectInputStream$$GetField.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t'java/io/ObjectInputStream$$GetField'\n+\n+java/io/ObjectOutputStream$$PutField.h: java/io/ObjectOutputStream$$PutField.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t'java/io/ObjectOutputStream$$PutField'\n+\n install-data-local:\n \t$(PRE_INSTALL)\n \t@for f in $(nat_headers) $(extra_headers); do \\"}, {"sha": "f31befd526dc94a5afd49b3ed83cebbd3a149cdc", "filename": "libjava/addr2name.awk", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Faddr2name.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Faddr2name.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Faddr2name.awk?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,46 @@\n+#!/bin/awk -f\n+\n+# Copyright (C) 2000  Free Software Foundation\n+\n+#    This file is part of libgcj.\n+\n+# This software is copyrighted work licensed under the terms of the\n+# Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+# details.\n+\n+# This script emulates a little of the functionality of addr2line for\n+# those systems that don't have it.  The only command line argument is\n+# an executable name.  The script reads hexadecimal addresses from\n+# stdin and prints the corresponding symbol names to stdout.  The\n+# addresses must begin with \"0x\" and be fully zero filled or this\n+# won't work.\n+\n+BEGIN {\n+  object = ARGV[1];\n+  ARGV[1] = \"\";\n+\n+  while (\"nm \" object \"| sort\" | getline) {\n+    if ($2 == \"t\" || $2 == \"T\") {\n+      address[i] = \"0x\" $1; name[i] = $3;\n+      i++;\n+    }\n+  }\n+  syms = i;\n+}\n+\n+{\n+  lo = 0;\n+  hi = syms - 1;\n+\n+  while ((hi-1) > lo)\n+    {\n+      try = int ((hi + lo) / 2);\n+      if ($0 < address[try])\n+\thi = try;\n+      else if ($0 >= address[try])\n+\tlo = try;\n+    }\n+  print name[lo] \"\\n\"; fflush();\n+}\n+\n+    "}, {"sha": "a108f726e766de14857793f8c462023b3dac579c", "filename": "libjava/configure", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -5118,24 +5118,33 @@ done\n test -n \"$PERL\" || PERL=\"false\"\n \n \n-if test \"$enable_sjlj_exceptions\" = yes; then\n+SYSDEP_SOURCES=\n+\n+case \"${host}\" in\n+ i?86-*-linux*)\n+    SIGNAL_HANDLER=include/i386-signal.h\n+    ;;\n+ sparc-sun-solaris*)\n+    SIGNAL_HANDLER=include/sparc-signal.h\n+    ;;\n+ ia64-*)\n+    SYSDEP_SOURCES=sysdep/ia64.c\n+    test -d sysdep || mkdir sysdep\n+    ;;\n+ *)\n+    SIGNAL_HANDLER=include/default-signal.h\n+    ;;\n+esac\n+\n+# If we're using sjlj exceptions, forget what we just learned.\n+if test \"$libgcj_sjlj\" = yes; then\n    SIGNAL_HANDLER=include/default-signal.h\n-else\n-   case \"${host}\" in\n-    i?86-*-linux*)\n-       SIGNAL_HANDLER=include/i386-signal.h\n-       ;;\n-    sparc-sun-solaris*)\n-       SIGNAL_HANDLER=include/sparc-signal.h\n-       ;;\n-    *)\n-       SIGNAL_HANDLER=include/default-signal.h\n-       ;;\n-   esac\n fi\n \n \n \n+\n+\n if test \"${multilib}\" = \"yes\"; then\n   multilib_arg=\"--enable-multilib\"\n else\n@@ -5367,6 +5376,7 @@ s%@EH_COMMON_INCLUDE@%$EH_COMMON_INCLUDE%g\n s%@AM_RUNTESTFLAGS@%$AM_RUNTESTFLAGS%g\n s%@ALLOCA@%$ALLOCA%g\n s%@PERL@%$PERL%g\n+s%@SYSDEP_SOURCES@%$SYSDEP_SOURCES%g\n s%@here@%$here%g\n \n CEOF"}, {"sha": "39a41bbfe49fbbc37731b1364131a34034a63107", "filename": "libjava/configure.host", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.host?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -66,6 +66,11 @@ case \"${host}\" in\n \t;;\n   sparc-*)\n         ;;\n+  ia64-*)\n+        libgcj_flags=\"${libgcj_flags} -funwind-tables\"\n+\tlibgcj_sjlj=yes\n+\tlibgcj_interpreter=yes\n+\t;;\n   *)\n         libgcj_sjlj=yes\n \t;;"}, {"sha": "5fefe1f304063a7c0d65b86c471a3cf5fc987f11", "filename": "libjava/configure.in", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.in?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -733,22 +733,31 @@ AC_FUNC_ALLOCA\n \n AC_CHECK_PROGS(PERL, perl, false)\n \n-if test \"$enable_sjlj_exceptions\" = yes; then\n+SYSDEP_SOURCES=\n+\n+case \"${host}\" in\n+ i?86-*-linux*)\n+    SIGNAL_HANDLER=include/i386-signal.h\n+    ;;\n+ sparc-sun-solaris*)\n+    SIGNAL_HANDLER=include/sparc-signal.h\n+    ;;\n+ ia64-*)\n+    SYSDEP_SOURCES=sysdep/ia64.c\n+    test -d sysdep || mkdir sysdep\n+    ;;\n+ *)\n+    SIGNAL_HANDLER=include/default-signal.h\n+    ;;\n+esac\n+\n+# If we're using sjlj exceptions, forget what we just learned.\n+if test \"$libgcj_sjlj\" = yes; then\n    SIGNAL_HANDLER=include/default-signal.h\n-else\n-   case \"${host}\" in\n-    i?86-*-linux*)\n-       SIGNAL_HANDLER=include/i386-signal.h\n-       ;;\n-    sparc-sun-solaris*)\n-       SIGNAL_HANDLER=include/sparc-signal.h\n-       ;;\n-    *)\n-       SIGNAL_HANDLER=include/default-signal.h\n-       ;;\n-   esac\n fi\n \n+AC_SUBST(SYSDEP_SOURCES)\n+\n AC_LINK_FILES($SIGNAL_HANDLER, include/java-signal.h)\n \n if test \"${multilib}\" = \"yes\"; then"}, {"sha": "26fec338ae7fae42ef53a1ce9cc872b3b6436a9b", "filename": "libjava/gcj/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgcj%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgcj%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2FMakefile.in?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -99,6 +99,7 @@ OBJDUMP = @OBJDUMP@\n PACKAGE = @PACKAGE@\n PERL = @PERL@\n RANLIB = @RANLIB@\n+SYSDEP_SOURCES = @SYSDEP_SOURCES@\n SYSTEMSPEC = @SYSTEMSPEC@\n THREADDEPS = @THREADDEPS@\n THREADINCS = @THREADINCS@"}, {"sha": "9ef52dc5f1c8fbc2872ed415adf57abc29fa0c45", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -69,8 +69,24 @@ extern \"Java\"\n       class InputStream;\n       class InputStreamReader;\n       class InterruptedIOException;\n+      class InvalidClassException;\n+      class InvalidObjectException;\n       class LineNumberInputStream;\n       class LineNumberReader;\n+      class NotActiveException;\n+      class NotSerializableException;\n+      class ObjectInput;\n+      class ObjectInputStream;\n+      class ObjectInputStream$GetField;\n+      class ObjectInputValidation;\n+      class ObjectOutput;\n+      class ObjectOutputStream;\n+      class ObjectOutputStream$PutField;\n+      class ObjectStreamClass;\n+      class ObjectStreamConstants;\n+      class ObjectStreamException;\n+      class ObjectStreamField;\n+      class OptionalDataException;\n       class OutputStream;\n       class OutputStreamWriter;\n       class PipedInputStream;\n@@ -85,6 +101,9 @@ extern \"Java\"\n       class Reader;\n       class SequenceInputStream;\n       class Serializable;\n+      class SerializablePermission;\n+      class SimpleDigestStream;\n+      class StreamCorruptedException;\n       class StreamTokenizer;\n       class StringBufferInputStream;\n       class StringReader;"}, {"sha": "bcf8ea5745082a829807e92f7d90e0be438b5ced", "filename": "libjava/gnu/gcj/io/SimpleSHSStream.java", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fgcj%2Fio%2FSimpleSHSStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fgcj%2Fio%2FSimpleSHSStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fio%2FSimpleSHSStream.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,66 @@\n+// SimpleSHSStream.java\n+\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.io;\n+import java.io.Serializable;\n+import java.io.*;\n+import java.lang.reflect.*;\n+\n+public class SimpleSHSStream extends java.io.DataOutputStream\n+{\n+  int counter;\n+ \n+  final int SHS_BLOCKSIZE = 64;\n+  final int SHS_DIGESTSIZE = 20;\n+\n+  byte buf[];\n+  byte shs_info[];\n+\n+  native static byte [] shsFinal (byte info[]);\n+  native static void shsUpdate (byte info[], byte buf[], int count);\n+  native static byte [] shsInit ();\n+\n+  private void update (byte b)\n+  {\n+    buf [counter++] = b;\n+    if (counter % SHS_BLOCKSIZE == 0)\n+      {\n+\tcounter = 0;\n+\tshsUpdate (shs_info, buf, SHS_BLOCKSIZE);\n+      }\n+  }    \n+  \n+  public void write (int b) throws IOException\n+  {\n+    update ((byte)b);\n+    super.write (b);\n+  }\n+\n+  public void write (byte[] b, int off, int len) throws IOException\n+  {\n+    for (int i = 0; i < len; i++)\n+      write (b[i+off]);\n+  }\n+\n+  public byte[] digest()\n+  {\n+    shsUpdate (shs_info, buf, counter);\n+    return shsFinal (shs_info);\n+  }\n+\n+  public SimpleSHSStream (OutputStream out)\n+  {\n+    super (out);\n+    buf = new byte[SHS_BLOCKSIZE];\n+    shs_info = shsInit ();\n+    counter = 0;\n+  }\n+}\n+"}, {"sha": "2cd213b809bd3d5a509c9c0cd21162d5039fb71e", "filename": "libjava/gnu/gcj/io/natSimpleSHSStream.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fgcj%2Fio%2FnatSimpleSHSStream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fgcj%2Fio%2FnatSimpleSHSStream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fio%2FnatSimpleSHSStream.cc?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,55 @@\n+// natSimpleSHSStream.cc\n+\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include <gnu/gcj/io/SimpleSHSStream.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+\n+#define PROTO\n+#include \"shs.h\"\n+\n+\n+jbyteArray \n+gnu::gcj::io::SimpleSHSStream::shsFinal (jbyteArray shs_info)\n+{\n+  SHS_INFO *info = (SHS_INFO *)elements(shs_info);\n+  ::shsFinal (info);\n+\n+  jbyteArray buffer = JvNewByteArray (SHS_DIGESTSIZE);\n+  memcpy (elements (buffer), (jbyte *)&info->digest, SHS_DIGESTSIZE);\n+  return buffer;\n+}\n+    \n+void \n+gnu::gcj::io::SimpleSHSStream::shsUpdate (jbyteArray shs_info, jbyteArray buf, jint count)\n+{\n+  SHS_INFO *info = (SHS_INFO *)elements(shs_info);\n+  BYTE *buffer = (BYTE *)elements(buf);\n+  \n+  ::shsUpdate (info, buffer, count);\n+}\n+\n+jbyteArray \n+gnu::gcj::io::SimpleSHSStream::shsInit ()\n+{\n+  jbyteArray result = JvNewByteArray (sizeof (SHS_INFO));\n+  SHS_INFO *info = (SHS_INFO *)elements(result);\n+\n+  ::shsInit (info);\n+  return result;\n+}\n+\n+"}, {"sha": "96b4f5603529477ed3d579d490b273b4051560ed", "filename": "libjava/gnu/gcj/io/shs.cc", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fgcj%2Fio%2Fshs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fgcj%2Fio%2Fshs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fio%2Fshs.cc?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,280 @@\n+\n+/* --------------------------------- SHS.CC ------------------------------- */\n+\n+/*\n+ * NIST proposed Secure Hash Standard.\n+ *\n+ * Written 2 September 1992, Peter C. Gutmann.\n+ * This implementation placed in the public domain.\n+ *\n+ * Comments to pgut1@cs.aukuni.ac.nz\n+ */\n+\n+#include <string.h>\n+#include \"shs.h\"\n+\n+/* The SHS f()-functions */\n+\n+#define f1(x,y,z)   ( ( x & y ) | ( ~x & z ) )\t\t  /* Rounds  0-19 */\n+#define f2(x,y,z)   ( x ^ y ^ z )\t\t\t  /* Rounds 20-39 */\n+#define f3(x,y,z)   ( ( x & y ) | ( x & z ) | ( y & z ) ) /* Rounds 40-59 */\n+#define f4(x,y,z)   ( x ^ y ^ z )\t\t\t  /* Rounds 60-79 */\n+\n+/* The SHS Mysterious Constants */\n+\n+#define K1  0x5A827999L \t/* Rounds  0-19 */\n+#define K2  0x6ED9EBA1L \t/* Rounds 20-39 */\n+#define K3  0x8F1BBCDCL \t/* Rounds 40-59 */\n+#define K4  0xCA62C1D6L \t/* Rounds 60-79 */\n+\n+/* SHS initial values */\n+\n+#define h0init\t0x67452301L\n+#define h1init\t0xEFCDAB89L\n+#define h2init\t0x98BADCFEL\n+#define h3init\t0x10325476L\n+#define h4init\t0xC3D2E1F0L\n+\n+/* 32-bit rotate - kludged with shifts */\n+\n+#define S(n,X)\t((X << n) | (X >> (32 - n)))\n+\n+/* The initial expanding function */\n+\n+#define expand(count)\tW [count] = W [count - 3] ^ W [count - 8] ^ W [count - 14] ^ W [count - 16]\n+\n+/* The four SHS sub-rounds */\n+\n+#define subRound1(count)    \\\n+\t{ \\\n+\t\ttemp = S (5, A) + f1 (B, C, D) + E + W [count] + K1; \\\n+\t\tE = D; \\\n+\t\tD = C; \\\n+\t\tC = S (30, B); \\\n+\t\tB = A; \\\n+\t\tA = temp; \\\n+\t}\n+\n+#define subRound2(count)    \\\n+\t{ \\\n+\t\ttemp = S (5, A) + f2 (B, C, D) + E + W [count] + K2; \\\n+\t\tE = D; \\\n+\t\tD = C; \\\n+\t\tC = S (30, B); \\\n+\t\tB = A; \\\n+\t\tA = temp; \\\n+\t}\n+\n+#define subRound3(count)    \\\n+\t{ \\\n+\t\ttemp = S (5, A) + f3 (B, C, D) + E + W [count] + K3; \\\n+\t\tE = D; \\\n+\t\tD = C; \\\n+\t\tC = S (30, B); \\\n+\t\tB = A; \\\n+\t\tA = temp; \\\n+\t}\n+\n+#define subRound4(count)    \\\n+\t{ \\\n+\t\ttemp = S (5, A) + f4 (B, C, D) + E + W [count] + K4; \\\n+\t\tE = D; \\\n+\t\tD = C; \\\n+\t\tC = S (30, B); \\\n+\t\tB = A; \\\n+\t\tA = temp; \\\n+\t}\n+\n+/* The two buffers of 5 32-bit words */\n+\n+LONG h0, h1, h2, h3, h4;\n+LONG A, B, C, D, E;\n+\n+local void byteReverse OF((LONG *buffer, int byteCount));\n+void shsTransform OF((SHS_INFO *shsInfo));\n+\n+/* Initialize the SHS values */\n+\n+void shsInit (SHS_INFO *shsInfo)\n+{\n+\t/* Set the h-vars to their initial values */\n+\tshsInfo->digest [0] = h0init;\n+\tshsInfo->digest [1] = h1init;\n+\tshsInfo->digest [2] = h2init;\n+\tshsInfo->digest [3] = h3init;\n+\tshsInfo->digest [4] = h4init;\n+\n+\t/* Initialise bit count */\n+\tshsInfo->countLo = shsInfo->countHi = 0L;\n+}\n+\n+/*\n+ * Perform the SHS transformation.  Note that this code, like MD5, seems to\n+ * break some optimizing compilers - it may be necessary to split it into\n+ * sections, eg based on the four subrounds\n+ */\n+\n+void shsTransform (SHS_INFO *shsInfo)\n+{\n+\tLONG W [80], temp;\n+\tint i;\n+\n+\t/* Step A.\tCopy the data buffer into the local work buffer */\n+\tfor (i = 0; i < 16; i++)\n+\t\tW [i] = shsInfo->data [i];\n+\n+\t/* Step B.\tExpand the 16 words into 64 temporary data words */\n+\texpand (16); expand (17); expand (18); expand (19); expand (20);\n+\texpand (21); expand (22); expand (23); expand (24); expand (25);\n+\texpand (26); expand (27); expand (28); expand (29); expand (30);\n+\texpand (31); expand (32); expand (33); expand (34); expand (35);\n+\texpand (36); expand (37); expand (38); expand (39); expand (40);\n+\texpand (41); expand (42); expand (43); expand (44); expand (45);\n+\texpand (46); expand (47); expand (48); expand (49); expand (50);\n+\texpand (51); expand (52); expand (53); expand (54); expand (55);\n+\texpand (56); expand (57); expand (58); expand (59); expand (60);\n+\texpand (61); expand (62); expand (63); expand (64); expand (65);\n+\texpand (66); expand (67); expand (68); expand (69); expand (70);\n+\texpand (71); expand (72); expand (73); expand (74); expand (75);\n+\texpand (76); expand (77); expand (78); expand (79);\n+\n+\t/* Step C.\tSet up first buffer */\n+\tA = shsInfo->digest [0];\n+\tB = shsInfo->digest [1];\n+\tC = shsInfo->digest [2];\n+\tD = shsInfo->digest [3];\n+\tE = shsInfo->digest [4];\n+\n+\t/* Step D.\tSerious mangling, divided into four sub-rounds */\n+\tsubRound1  (0); subRound1  (1); subRound1  (2); subRound1  (3);\n+\tsubRound1  (4); subRound1  (5); subRound1  (6); subRound1  (7);\n+\tsubRound1  (8); subRound1  (9); subRound1 (10); subRound1 (11);\n+\tsubRound1 (12); subRound1 (13); subRound1 (14); subRound1 (15);\n+\tsubRound1 (16); subRound1 (17); subRound1 (18); subRound1 (19);\n+\n+\tsubRound2 (20); subRound2 (21); subRound2 (22); subRound2 (23);\n+\tsubRound2 (24); subRound2 (25); subRound2 (26); subRound2 (27);\n+\tsubRound2 (28); subRound2 (29); subRound2 (30); subRound2 (31);\n+\tsubRound2 (32); subRound2 (33); subRound2 (34); subRound2 (35);\n+\tsubRound2 (36); subRound2 (37); subRound2 (38); subRound2 (39);\n+\n+\tsubRound3 (40); subRound3 (41); subRound3 (42); subRound3 (43);\n+\tsubRound3 (44); subRound3 (45); subRound3 (46); subRound3 (47);\n+\tsubRound3 (48); subRound3 (49); subRound3 (50); subRound3 (51);\n+\tsubRound3 (52); subRound3 (53); subRound3 (54); subRound3 (55);\n+\tsubRound3 (56); subRound3 (57); subRound3 (58); subRound3 (59);\n+\n+\tsubRound4 (60); subRound4 (61); subRound4 (62); subRound4 (63);\n+\tsubRound4 (64); subRound4 (65); subRound4 (66); subRound4 (67);\n+\tsubRound4 (68); subRound4 (69); subRound4 (70); subRound4 (71);\n+\tsubRound4 (72); subRound4 (73); subRound4 (74); subRound4 (75);\n+\tsubRound4 (76); subRound4 (77); subRound4 (78); subRound4 (79);\n+\n+\t/* Step E.\tBuild message digest */\n+\tshsInfo->digest [0] += A;\n+\tshsInfo->digest [1] += B;\n+\tshsInfo->digest [2] += C;\n+\tshsInfo->digest [3] += D;\n+\tshsInfo->digest [4] += E;\n+}\n+\n+local void byteReverse (LONG *buffer, int byteCount)\n+{\n+\tLONG value;\n+\tint count;\n+\n+\t/*\n+\t * Find out what the byte order is on this machine.\n+\t * Big endian is for machines that place the most significant byte\n+\t * first (eg. Sun SPARC). Little endian is for machines that place\n+\t * the least significant byte first (eg. VAX).\n+\t *\n+\t * We figure out the byte order by stuffing a 2 byte string into a\n+\t * short and examining the left byte. '@' = 0x40  and  'P' = 0x50\n+\t * If the left byte is the 'high' byte, then it is 'big endian'.\n+\t * If the left byte is the 'low' byte, then the machine is 'little\n+\t * endian'.\n+\t *\n+\t *                          -- Shawn A. Clifford (sac@eng.ufl.edu)\n+\t */\n+\n+\t/*\n+\t * Several bugs fixed       -- Pat Myrto (pat@rwing.uucp)\n+\t */\n+\n+\tif ((*(unsigned short *) (\"@P\") >> 8) == '@')\n+\t\treturn;\n+\n+\tbyteCount /= sizeof (LONG);\n+\tfor (count = 0; count < byteCount; count++) {\n+\t\tvalue = (buffer [count] << 16) | (buffer [count] >> 16);\n+\t\tbuffer [count] = ((value & 0xFF00FF00L) >> 8) | ((value & 0x00FF00FFL) << 8);\n+\t}\n+}\n+\n+/*\n+ * Update SHS for a block of data.  This code assumes that the buffer size is\n+ * a multiple of SHS_BLOCKSIZE bytes long, which makes the code a lot more\n+ * efficient since it does away with the need to handle partial blocks\n+ * between calls to shsUpdate()\n+ */\n+\n+void shsUpdate (SHS_INFO *shsInfo, BYTE *buffer, int count)\n+{\n+\t/* Update bitcount */\n+\tif ((shsInfo->countLo + ((LONG) count << 3)) < shsInfo->countLo)\n+\t\t shsInfo->countHi++;\t/* Carry from low to high bitCount */\n+\tshsInfo->countLo += ((LONG) count << 3);\n+\tshsInfo->countHi += ((LONG) count >> 29);\n+\n+\t/* Process data in SHS_BLOCKSIZE chunks */\n+\twhile (count >= SHS_BLOCKSIZE) {\n+\t\tmemcpy (shsInfo->data, buffer, SHS_BLOCKSIZE);\n+\t\tbyteReverse (shsInfo->data, SHS_BLOCKSIZE);\n+\t\tshsTransform (shsInfo);\n+\t\tbuffer += SHS_BLOCKSIZE;\n+\t\tcount -= SHS_BLOCKSIZE;\n+\t}\n+\n+\t/*\n+\t * Handle any remaining bytes of data.\n+\t * This should only happen once on the final lot of data\n+\t */\n+\tmemcpy (shsInfo->data, buffer, count);\n+}\n+\n+void shsFinal (SHS_INFO *shsInfo)\n+{\n+\tint count;\n+\tLONG lowBitcount = shsInfo->countLo, highBitcount = shsInfo->countHi;\n+\n+\t/* Compute number of bytes mod 64 */\n+\tcount = (int) ((shsInfo->countLo >> 3) & 0x3F);\n+\n+\t/*\n+\t * Set the first char of padding to 0x80.\n+\t * This is safe since there is always at least one byte free\n+\t */\n+\t((BYTE *) shsInfo->data) [count++] = 0x80;\n+\n+\t/* Pad out to 56 mod 64 */\n+\tif (count > 56) {\n+\t\t/* Two lots of padding:  Pad the first block to 64 bytes */\n+\t\tmemset ((BYTE *) shsInfo->data + count, 0, 64 - count);\n+\t\tbyteReverse (shsInfo->data, SHS_BLOCKSIZE);\n+\t\tshsTransform (shsInfo);\n+\n+\t\t/* Now fill the next block with 56 bytes */\n+\t\tmemset (shsInfo->data, 0, 56);\n+\t} else\n+\t\t/* Pad block to 56 bytes */\n+\t\tmemset ((BYTE *) shsInfo->data + count, 0, 56 - count);\n+\tbyteReverse (shsInfo->data, SHS_BLOCKSIZE);\n+\n+\t/* Append length in bits and transform */\n+\tshsInfo->data [14] = highBitcount;\n+\tshsInfo->data [15] = lowBitcount;\n+\n+\tshsTransform (shsInfo);\n+\tbyteReverse (shsInfo->data, SHS_DIGESTSIZE);\n+}"}, {"sha": "8c91ff3dfea7e41e8bf3a32d4dbb17d88e44d894", "filename": "libjava/gnu/gcj/io/shs.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fgcj%2Fio%2Fshs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fgcj%2Fio%2Fshs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fio%2Fshs.h?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,51 @@\n+/* --------------------------------- SHS.H ------------------------------- */\n+\n+/*\n+ * NIST proposed Secure Hash Standard. \n+ *\n+ * Written 2 September 1992, Peter C. Gutmann.\n+ * This implementation placed in the public domain. \n+ *\n+ * Comments to pgut1@cs.aukuni.ac.nz \n+ */\n+\n+/* Useful defines/typedefs */\n+\n+#ifndef SHS_H\n+#define SHS_H\n+\n+typedef unsigned char BYTE;\n+typedef unsigned int LONG; /* A 32-bit type */\n+\n+/* The SHS block size and message digest sizes, in bytes */\n+\n+#define SHS_BLOCKSIZE\t64\n+#define SHS_DIGESTSIZE\t20\n+\n+/* The structure for storing SHS info */\n+\n+typedef struct {\n+\tLONG digest [5];\t/* Message digest */\n+\tLONG countLo, countHi;\t/* 64-bit bit count */\n+\tLONG data [16];\t\t/* SHS data buffer */\n+} SHS_INFO;\n+\n+/* Turn off prototypes if requested */\n+#if (defined(NOPROTO) && defined(PROTO))\n+#\tundef PROTO\n+#endif\n+\n+/* Used to remove arguments in function prototypes for non-ANSI C */\n+#ifdef PROTO\n+#\tdefine OF(a) a\n+#else\t/* !PROTO */\n+#\tdefine OF(a) ()\n+#endif\t/* ?PROTO */\n+\n+#define\tlocal\tstatic\n+\n+void shsInit OF((SHS_INFO *shsInfo));\n+void shsUpdate OF((SHS_INFO *shsInfo, BYTE *buffer, int count));\n+void shsFinal OF((SHS_INFO *shsInfo));\n+\n+#endif"}, {"sha": "85aafa11e45567cd71a57bc097aa1971081a815d", "filename": "libjava/gnu/java/beans/BeanInfoEmbryo.java", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2FBeanInfoEmbryo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2FBeanInfoEmbryo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2FBeanInfoEmbryo.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,146 @@\n+/* gnu.java.beans.BeanInfoEmbryo\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans;\n+\n+import java.beans.*;\n+import java.util.*;\n+import gnu.java.lang.*;\n+import java.lang.reflect.*;\n+\n+/**\n+ ** A BeanInfoEmbryo accumulates information about a Bean\n+ ** while it is in the process of being created, and then\n+ ** when you are done accumulating the information, the\n+ ** getBeanInfo() method may be called to create a BeanInfo\n+ ** object based on the information.<P>\n+ **\n+ ** This class is not well-synchronized.  (It can be, it\n+ ** just isn't yet.)\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 30 Jul 1998\n+ ** @see java.beans.BeanInfo\n+ **/\n+\n+public class BeanInfoEmbryo {\n+\tHashtable properties = new Hashtable();\n+\tHashtable events = new Hashtable();\n+\tVector methods = new Vector();\n+\n+\tBeanDescriptor beanDescriptor;\n+\tBeanInfo[] additionalBeanInfo;\n+\tjava.awt.Image[] im;\n+\tString defaultPropertyName;\n+\tString defaultEventName;\n+\n+\tpublic BeanInfoEmbryo() {\n+\t}\n+\n+\tpublic BeanInfo getBeanInfo() {\n+\t\tint defaultProperty = -1;\n+\t\tint defaultEvent = -1;\n+\n+\t\tPropertyDescriptor[] Aproperties = new PropertyDescriptor[properties.size()];\n+\t\tint i = 0;\n+\t\tEnumeration enum = properties.elements();\n+\t\twhile(enum.hasMoreElements()) {\n+\t\t\tAproperties[i] = (PropertyDescriptor)enum.nextElement();\n+\t\t\tif(defaultPropertyName != null && Aproperties[i].getName().equals(defaultPropertyName)) {\n+\t\t\t\tdefaultProperty = i;\n+\t\t\t}\n+\t\t\ti++;\n+\t\t}\n+\n+\t\tEventSetDescriptor[] Aevents = new EventSetDescriptor[events.size()];\n+\t\ti = 0;\n+\t\tenum = events.elements();\n+\t\twhile(enum.hasMoreElements()) {\n+\t\t\tAevents[i] = (EventSetDescriptor)enum.nextElement();\n+\t\t\tif(defaultEventName != null && Aevents[i].getName().equals(defaultEventName)) {\n+\t\t\t\tdefaultEvent = i;\n+\t\t\t}\n+\t\t\ti++;\n+\t\t}\n+\n+\t\tMethodDescriptor[] Amethods = new MethodDescriptor[methods.size()];\n+\t\tmethods.copyInto(Amethods);\n+\n+\t\treturn new ExplicitBeanInfo(beanDescriptor,additionalBeanInfo,Aproperties,defaultProperty,Aevents,defaultEvent,Amethods,im);\n+\t}\n+\n+\tpublic void setBeanDescriptor(BeanDescriptor b) {\n+\t\tbeanDescriptor = b;\n+\t}\n+\n+\tpublic void setAdditionalBeanInfo(BeanInfo[] b) {\n+\t\tadditionalBeanInfo = b;\n+\t}\n+\n+\tpublic boolean hasProperty(PropertyDescriptor p) {\n+\t\treturn properties.get(p.getName()) != null;\n+\t}\n+\tpublic void addProperty(PropertyDescriptor p) {\n+\t\tproperties.put(p.getName(),p);\n+\t}\n+\tpublic void addIndexedProperty(IndexedPropertyDescriptor p) {\n+\t\tproperties.put(p.getName(),p);\n+\t}\n+\n+\tpublic boolean hasEvent(EventSetDescriptor e) {\n+\t\treturn events.get(e.getName()) != null;\n+\t}\n+\tpublic void addEvent(EventSetDescriptor e) {\n+\t\tevents.put(e.getName(),e);\n+\t}\n+\n+\tpublic boolean hasMethod(MethodDescriptor m) {\n+\t\tfor(int i=0;i<methods.size();i++) {\n+\t\t\tMethod thisMethod = ((MethodDescriptor)methods.elementAt(i)).getMethod();\n+\t\t\tif(m.getMethod().getName().equals(thisMethod.getName())\n+\t\t\t   && ArrayHelper.equalsArray(m.getMethod().getParameterTypes(), thisMethod.getParameterTypes())) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\tpublic void addMethod(MethodDescriptor m) {\n+\t\tmethods.addElement(m);\n+\t}\n+\n+\tpublic void setDefaultPropertyName(String defaultPropertyName) {\n+\t\tthis.defaultPropertyName = defaultPropertyName;\n+\t}\n+\n+\tpublic void setDefaultEventName(String defaultEventName) {\n+\t\tthis.defaultEventName = defaultEventName;\n+\t}\n+\n+\tpublic void setIcons(java.awt.Image[] im) {\n+\t\tthis.im = im;\n+\t}\n+}"}, {"sha": "ad7d91dfcd864df26f462d9aea70f0e752d91486", "filename": "libjava/gnu/java/beans/EmptyBeanInfo.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2FEmptyBeanInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2FEmptyBeanInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2FEmptyBeanInfo.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,59 @@\n+/* gnu.java.beans.EmptyBeanInfo\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans;\n+\n+import java.beans.*;\n+\n+/**\n+ ** EmptyBeanInfo is a BeanInfo that discloses no\n+ ** information about the Bean and does not allow\n+ ** Introspection.  The Introspector uses instances of this\n+ ** class to create empty BeanInfos, but it could also be\n+ ** used as a base class for BeanInfos that do not allow\n+ ** Introspection and provide only a little bit of\n+ ** information.<P>\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 30 Jul 1998\n+ ** @see gnu.java.beans.ExplicitBeanInfo\n+ ** @see java.beans.BeanInfo\n+ **/\n+\n+public class EmptyBeanInfo extends ExplicitBeanInfo {\n+\t/** Create a new EmptyBeanInfo. **/\n+\tpublic EmptyBeanInfo(Class beanClass) {\n+\t\tsuper(new BeanDescriptor(beanClass,null),\n+\t\t      new BeanInfo[0],\n+\t\t      new PropertyDescriptor[0],\n+\t\t      -1,\n+\t\t      new EventSetDescriptor[0],\n+\t\t      -1,\n+\t\t      new MethodDescriptor[0],\n+\t\t      null);\n+\t}\n+}"}, {"sha": "8cab94b7d0ba2820d96921b3767530a8466fba76", "filename": "libjava/gnu/java/beans/ExplicitBeanInfo.java", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2FExplicitBeanInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2FExplicitBeanInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2FExplicitBeanInfo.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,133 @@\n+/* gnu.java.beans.ExplicitBeanInfo\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans;\n+\n+import java.beans.*;\n+\n+/**\n+ ** ExplicitBeanInfo lets you specify in the constructor\n+ ** all the various parts of the BeanInfo.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 30 Jul 1998\n+ ** @see java.beans.BeanInfo\n+ **/\n+\n+public class ExplicitBeanInfo implements BeanInfo {\n+\t/** The BeanDescriptor returned by getBeanDescriptor. **/\n+\tprotected BeanDescriptor beanDescriptor;\n+\n+\t/** The EventSetDescriptor array returned by\n+\t ** getEventSetDescriptors().\n+\t **/\n+\tprotected EventSetDescriptor[] eventSetDescriptors = new EventSetDescriptor[0];\n+\n+\t/** The PropertyDescriptor array returned by\n+\t ** getPropertyDescriptors().\n+\t **/\n+\tprotected PropertyDescriptor[] propertyDescriptors = new PropertyDescriptor[0];\n+\n+\t/** The MethodDescriptor array returned by\n+\t ** getMethodDescriptors().\n+\t **/\n+\tprotected MethodDescriptor[]   methodDescriptors;\n+\n+\t/** The default property index. **/\n+\tprotected int defaultPropertyIndex;\n+\n+\t/** The default event index. **/\n+\tprotected int defaultEventIndex;\n+\n+\t/** The BeanInfo array returned by\n+\t ** getAdditionalBeanInfo().\n+\t **/\n+\tprotected BeanInfo[] additionalBeanInfo;\n+\n+\t/** The set of icons. **/\n+\tprotected java.awt.Image[] icons;\n+\n+\tpublic ExplicitBeanInfo(BeanDescriptor beanDescriptor,\n+\t                        BeanInfo[] additionalBeanInfo,\n+\t                        PropertyDescriptor[] propertyDescriptors,\n+\t\t\t\tint defaultPropertyIndex,\n+\t                        EventSetDescriptor[] eventSetDescriptors,\n+\t\t\t\tint defaultEventIndex,\n+\t                        MethodDescriptor[] methodDescriptors,\n+\t\t\t\tjava.awt.Image[] icons) {\n+\t\tthis.beanDescriptor = beanDescriptor;\n+\t\tthis.additionalBeanInfo = additionalBeanInfo;\n+\t\tthis.propertyDescriptors = propertyDescriptors;\n+\t\tthis.defaultPropertyIndex = defaultPropertyIndex;\n+\t\tthis.eventSetDescriptors = eventSetDescriptors;\n+\t\tthis.defaultEventIndex = defaultEventIndex;\n+\t\tthis.methodDescriptors = methodDescriptors;\n+\t\tthis.icons = icons;\n+\t}\n+\n+\t/** Get Bean descriptor. **/\n+\tpublic BeanDescriptor getBeanDescriptor() {\n+\t\treturn beanDescriptor;\n+\t}\n+\n+\t/** Get Bean events. **/\n+\tpublic EventSetDescriptor[] getEventSetDescriptors() {\n+\t\treturn eventSetDescriptors;\n+\t}\n+\n+\t/** Get default event set. **/\n+\tpublic int getDefaultEventIndex() {\n+\t\treturn defaultEventIndex;\n+\t}\n+\n+\t/** Get Bean properties. **/\n+\tpublic PropertyDescriptor[] getPropertyDescriptors() {\n+\t\treturn propertyDescriptors;\n+\t}\n+\n+\t/** Get \"default\" property. **/\n+\tpublic int getDefaultPropertyIndex() {\n+\t\treturn defaultPropertyIndex;\n+\t}\n+\n+\t/** Get Bean methods. **/\n+\tpublic MethodDescriptor[] getMethodDescriptors() {\n+\t\treturn methodDescriptors;\n+\t}\n+\n+\t/** Get additional Bean info. **/\n+\tpublic BeanInfo[] getAdditionalBeanInfo() {\n+\t\treturn additionalBeanInfo;\n+\t}\n+\n+\t/** Get Bean icons.\n+\t ** @param iconType the type of icon\n+\t **/\n+\tpublic java.awt.Image getIcon(int iconType) {\n+\t\treturn icons != null ? icons[iconType] : null;\n+\t}\n+}"}, {"sha": "e3f4807bfbf6d8ca232aa1f0060b0d525f91fd08", "filename": "libjava/gnu/java/beans/IntrospectionIncubator.java", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2FIntrospectionIncubator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2FIntrospectionIncubator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2FIntrospectionIncubator.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,344 @@\n+/* gnu.java.beans.IntrospectionIncubator\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans;\n+\n+import java.beans.*;\n+import java.util.*;\n+import java.lang.reflect.*;\n+import gnu.java.lang.*;\n+\n+/**\n+ ** IntrospectionIncubator takes in a bunch of Methods, and\n+ ** Introspects only those Methods you give it.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 30 Jul 1998\n+ ** @see gnu.java.beans.ExplicitBeanInfo\n+ ** @see java.beans.BeanInfo\n+ **/\n+\n+public class IntrospectionIncubator {\n+\tHashtable propertyMethods = new Hashtable();\n+\tHashtable listenerMethods = new Hashtable();\n+\tVector otherMethods = new Vector();\n+\n+\tClass propertyStopClass;\n+\tClass eventStopClass;\n+\tClass methodStopClass;\n+\n+\tpublic IntrospectionIncubator() {\n+\t}\n+\n+\t/* Paving the way for automatic Introspection */\n+\tpublic void addMethod(Method method) {\n+\t\tif(Modifier.isPublic(method.getModifiers()) && !Modifier.isStatic(method.getModifiers())) {\n+\t\t\tString name = ClassHelper.getTruncatedName(method.getName());\n+\t\t\tClass retType = method.getReturnType();\n+\t\t\tClass[] params = method.getParameterTypes();\n+\t\t\tboolean isVoid = retType.equals(java.lang.Void.TYPE);\n+\t\t\tClass methodClass = method.getDeclaringClass();\n+\t\t\tif(propertyStopClass == null || (propertyStopClass.isAssignableFrom(methodClass) && !propertyStopClass.equals(methodClass))) {\n+\t\t\t\tif(name.startsWith(\"is\")\n+\t\t\t\t   && retType.equals(java.lang.Boolean.TYPE)\n+\t\t\t\t   && params.length == 0) {\n+\t\t\t\t\taddToPropertyHash(name,method,IS);\n+\t\t\t\t} else if(name.startsWith(\"get\") && !isVoid) {\n+\t\t\t\t\tif(params.length == 0) {\n+\t\t\t\t\t\taddToPropertyHash(name,method,GET);\n+\t\t\t\t\t} else if(params.length == 1 && params[0].equals(java.lang.Integer.TYPE)) {\n+\t\t\t\t\t\taddToPropertyHash(name,method,GET_I);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\totherMethods.addElement(method);\n+\t\t\t\t\t}\n+\t\t\t\t} else if(name.startsWith(\"set\") && isVoid) {\n+\t\t\t\t\tif(params.length == 1) {\n+\t\t\t\t\t\taddToPropertyHash(name,method,SET);\n+\t\t\t\t\t} else if(params.length == 2 && params[0].equals(java.lang.Integer.TYPE)) {\n+\t\t\t\t\t\taddToPropertyHash(name,method,SET_I);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\totherMethods.addElement(method);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(eventStopClass == null || (eventStopClass.isAssignableFrom(methodClass) && !eventStopClass.equals(methodClass))) {\n+\t\t\t\tif(name.startsWith(\"add\")\n+\t\t\t\t          && isVoid\n+\t\t\t\t          && params.length == 1\n+\t\t\t\t          && java.util.EventListener.class.isAssignableFrom(params[0])) {\n+\t\t\t\t\taddToListenerHash(name,method,ADD);\n+\t\t\t\t} else if(name.startsWith(\"remove\")\n+\t\t\t\t          && isVoid\n+\t\t\t\t          && params.length == 1\n+\t\t\t\t          && java.util.EventListener.class.isAssignableFrom(params[0])) {\n+\t\t\t\t\taddToListenerHash(name,method,REMOVE);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(methodStopClass == null || (methodStopClass.isAssignableFrom(methodClass) && !methodStopClass.equals(methodClass))) {\n+\t\t\t\totherMethods.addElement(method);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void addMethods(Method[] m) {\n+\t\tfor(int i=0;i<m.length;i++) {\n+\t\t\taddMethod(m[i]);\n+\t\t}\n+\t}\n+\n+\tpublic void setPropertyStopClass(Class c) {\n+\t\tpropertyStopClass = c;\n+\t}\n+\n+\tpublic void setEventStopClass(Class c) {\n+\t\teventStopClass = c;\n+\t}\n+\n+\tpublic void setMethodStopClass(Class c) {\n+\t\tmethodStopClass = c;\n+\t}\n+\n+\n+\tpublic BeanInfoEmbryo getBeanInfoEmbryo() throws IntrospectionException {\n+\t\tBeanInfoEmbryo b = new BeanInfoEmbryo();\n+\t\tfindXXX(b,IS);\n+\t\tfindXXXInt(b,GET_I);\n+\t\tfindXXXInt(b,SET_I);\n+\t\tfindXXX(b,GET);\n+\t\tfindXXX(b,SET);\n+\t\tfindAddRemovePairs(b);\n+\t\tfor(int i=0;i<otherMethods.size();i++) {\n+\t\t\tMethodDescriptor newMethod = new MethodDescriptor((Method)otherMethods.elementAt(i));\n+\t\t\tif(!b.hasMethod(newMethod)) {\n+\t\t\t\tb.addMethod(new MethodDescriptor((Method)otherMethods.elementAt(i)));\n+\t\t\t}\n+\t\t}\n+\t\treturn b;\n+\t}\n+\n+\tpublic BeanInfo getBeanInfo() throws IntrospectionException {\n+\t\treturn getBeanInfoEmbryo().getBeanInfo();\n+\t}\n+\n+\n+\tvoid findAddRemovePairs(BeanInfoEmbryo b) throws IntrospectionException {\n+\t\tEnumeration listenerEnum = listenerMethods.keys();\n+\t\twhile(listenerEnum.hasMoreElements()) {\n+\t\t\tDoubleKey k = (DoubleKey)listenerEnum.nextElement();\n+\t\t\tMethod[] m = (Method[])listenerMethods.get(k);\n+\t\t\tif(m[ADD] != null && m[REMOVE] != null) {\n+\t\t\t\tEventSetDescriptor e = new EventSetDescriptor(Introspector.decapitalize(k.getName()),\n+\t\t\t\t                                              k.getType(), k.getType().getMethods(),\n+\t\t\t\t                                              m[ADD],m[REMOVE]);\n+\t\t\t\te.setUnicast(ArrayHelper.contains(m[ADD].getExceptionTypes(),java.util.TooManyListenersException.class));\n+\t\t\t\tif(!b.hasEvent(e)) {\n+\t\t\t\t\tb.addEvent(e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvoid findXXX(BeanInfoEmbryo b, int funcType) throws IntrospectionException {\n+\t\tEnumeration keys = propertyMethods.keys();\n+\t\twhile(keys.hasMoreElements()) {\n+\t\t\tDoubleKey k = (DoubleKey)keys.nextElement();\n+\t\t\tMethod[] m = (Method[])propertyMethods.get(k);\n+\t\t\tif(m[funcType] != null) {\n+\t\t\t\tPropertyDescriptor p = new PropertyDescriptor(Introspector.decapitalize(k.getName()),\n+\t\t\t\t                                     m[IS] != null ? m[IS] : m[GET],\n+\t\t\t\t                                     m[SET]);\n+\t\t\t\tif(m[SET] != null) {\n+\t\t\t\t\tp.setConstrained(ArrayHelper.contains(m[SET].getExceptionTypes(),java.beans.PropertyVetoException.class));\n+\t\t\t\t}\n+\t\t\t\tif(!b.hasProperty(p)) {\n+\t\t\t\t\tb.addProperty(p);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvoid findXXXInt(BeanInfoEmbryo b, int funcType) throws IntrospectionException {\n+\t\tEnumeration keys = propertyMethods.keys();\n+\t\twhile(keys.hasMoreElements()) {\n+\t\t\tDoubleKey k = (DoubleKey)keys.nextElement();\n+\t\t\tMethod[] m = (Method[])propertyMethods.get(k);\n+\t\t\tif(m[funcType] != null) {\n+\t\t\t\tboolean constrained;\n+\t\t\t\tif(m[SET_I] != null) {\n+\t\t\t\t\tconstrained = ArrayHelper.contains(m[SET_I].getExceptionTypes(),java.beans.PropertyVetoException.class);\n+\t\t\t\t} else {\n+\t\t\t\t\tconstrained = false;\n+\t\t\t\t}\n+\n+\t\t\t\t/** Find out if there is an array type get or set **/\n+\t\t\t\tClass arrayType = Array.newInstance(k.getType(),0).getClass();\n+\t\t\t\tDoubleKey findSetArray = new DoubleKey(arrayType,k.getName());\n+\t\t\t\tMethod[] m2 = (Method[])propertyMethods.get(findSetArray);\n+\t\t\t\tIndexedPropertyDescriptor p;\n+\t\t\t\tif(m2 == null) {\n+\t\t\t\t\tp = new IndexedPropertyDescriptor(Introspector.decapitalize(k.getName()),\n+\t\t\t\t                                          null,null,\n+\t\t\t\t                                          m[GET_I],m[SET_I]);\n+\t\t\t\t} else {\n+\t\t\t\t\tif(constrained && m2[SET] != null) {\n+\t\t\t\t\t\tconstrained = ArrayHelper.contains(m2[SET].getExceptionTypes(),java.beans.PropertyVetoException.class);\n+\t\t\t\t\t}\n+\t\t\t\t\tp = new IndexedPropertyDescriptor(Introspector.decapitalize(k.getName()),\n+\t\t\t\t                                          m2[GET],m2[SET],\n+\t\t\t\t                                          m[GET_I],m[SET_I]);\n+\t\t\t\t}\n+\t\t\t\tp.setConstrained(constrained);\n+\t\t\t\tif(!b.hasProperty(p)) {\n+\t\t\t\t\tb.addProperty(p);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tstatic final int IS=0;\n+\tstatic final int GET_I=1;\n+\tstatic final int SET_I=2;\n+\tstatic final int GET=3;\n+\tstatic final int SET=4;\n+\n+\tstatic final int ADD=0;\n+\tstatic final int REMOVE=1;\n+\n+\tvoid addToPropertyHash(String name, Method method, int funcType) {\n+\t\tString newName;\n+\t\tClass type;\n+\n+\t\tswitch(funcType) {\n+\t\t\tcase IS:\n+\t\t\t\ttype = java.lang.Boolean.TYPE;\n+\t\t\t\tnewName = name.substring(2);\n+\t\t\t\tbreak;\n+\t\t\tcase GET_I:\n+\t\t\t\ttype = method.getReturnType();\n+\t\t\t\tnewName = name.substring(3);\n+\t\t\t\tbreak;\n+\t\t\tcase SET_I:\n+\t\t\t\ttype = method.getParameterTypes()[1];\n+\t\t\t\tnewName = name.substring(3);\n+\t\t\t\tbreak;\n+\t\t\tcase GET:\n+\t\t\t\ttype = method.getReturnType();\n+\t\t\t\tnewName = name.substring(3);\n+\t\t\t\tbreak;\n+\t\t\tcase SET:\n+\t\t\t\ttype = method.getParameterTypes()[0];\n+\t\t\t\tnewName = name.substring(3);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treturn;\n+\t\t}\n+\t\tnewName = capitalize(newName);\n+\n+\t\tDoubleKey k = new DoubleKey(type,newName);\n+\t\tMethod[] methods = (Method[])propertyMethods.get(k);\n+\t\tif(methods == null) {\n+\t\t\tmethods = new Method[5];\n+\t\t\tpropertyMethods.put(k,methods);\n+\t\t}\n+\t\tmethods[funcType] = method;\n+\t}\n+\n+\n+\tvoid addToListenerHash(String name, Method method, int funcType) {\n+\t\tString newName;\n+\t\tClass type;\n+\n+\t\tswitch(funcType) {\n+\t\t\tcase ADD:\n+\t\t\t\ttype = method.getParameterTypes()[0];\n+\t\t\t\tnewName = name.substring(3,name.length()-8);\n+\t\t\t\tbreak;\n+\t\t\tcase REMOVE:\n+\t\t\t\ttype = method.getParameterTypes()[0];\n+\t\t\t\tnewName = name.substring(6,name.length()-8);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treturn;\n+\t\t}\n+\t\tnewName = capitalize(newName);\n+\n+\t\tDoubleKey k = new DoubleKey(type,newName);\n+\t\tMethod[] methods = (Method[])listenerMethods.get(k);\n+\t\tif(methods == null) {\n+\t\t\tmethods = new Method[2];\n+\t\t\tlistenerMethods.put(k,methods);\n+\t\t}\n+\t\tmethods[funcType] = method;\n+\t}\n+\n+\tstatic String capitalize(String name) {\n+\t\ttry {\n+\t\t\tif(Character.isUpperCase(name.charAt(0))) {\n+\t\t\t\treturn name;\n+\t\t\t} else {\n+\t\t\t\tchar[] c = name.toCharArray();\n+\t\t\t\tc[0] = Character.toLowerCase(c[0]);\n+\t\t\t\treturn new String(c);\n+\t\t\t}\n+\t\t} catch(StringIndexOutOfBoundsException E) {\n+\t\t\treturn name;\n+\t\t} catch(NullPointerException E) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+}\n+\n+class DoubleKey {\n+\tClass type;\n+\tString name;\n+\n+\tDoubleKey(Class type, String name) {\n+\t\tthis.type = type;\n+\t\tthis.name = name;\n+\t}\n+\n+\tClass getType() {\n+\t\treturn type;\n+\t}\n+\n+\tString getName() {\n+\t\treturn name;\n+\t}\n+\n+\tpublic boolean equals(Object o) {\n+\t\tif(o instanceof DoubleKey) {\n+\t\t\tDoubleKey d = (DoubleKey)o;\n+\t\t\treturn d.type.equals(type) && d.name.equals(name);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tpublic int hashCode() {\n+\t\treturn type.hashCode() ^ name.hashCode();\n+\t}\n+}"}, {"sha": "1c002d68cdcb8ee89e2cdd5fa22a3fd10a7c0235", "filename": "libjava/gnu/java/beans/editors/ColorEditor.java", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FColorEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FColorEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FColorEditor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,89 @@\n+/* gnu.java.beans.editors.ColorEditor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans.editors;\n+\n+import java.beans.*;\n+import java.awt.Color;\n+\n+/**\n+ ** NativeByteEditor is a property editor for the\n+ ** byte type.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class ColorEditor extends PropertyEditorSupport {\n+\tColor[] stdColors = {Color.black,Color.blue,Color.cyan,\n+\t                     Color.darkGray,Color.gray,Color.green,\n+\t                     Color.lightGray,Color.magenta,Color.orange,\n+\t                     Color.pink,Color.red,Color.white,\n+\t                     Color.yellow};\n+\tString[] stdColorNames = {\"black\",\"blue\",\"cyan\",\n+\t                          \"dark gray\",\"gray\",\"green\",\n+\t                          \"light gray\",\"magenta\",\"orange\",\n+\t                          \"pink\",\"red\",\"white\",\n+\t                          \"yellow\"};\n+\n+\t/** setAsText for Color checks for standard color names\n+\t ** and then checks for a #RRGGBB value or just RRGGBB,\n+\t ** both in hex.\n+\t **/\n+\tpublic void setAsText(String val) throws IllegalArgumentException {\n+\t\tif(val.length() == 0) {\n+\t\t\tthrow new IllegalArgumentException(\"Tried to set empty value!\");\n+\t\t}\n+\t\tfor(int i=0;i<stdColorNames.length;i++) {\n+\t\t\tif(stdColorNames[i].equalsIgnoreCase(val)) {\n+\t\t\t\tsetValue(stdColors[i]);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tif(val.charAt(0) == '#') {\n+\t\t\tsetValue(new Color(Integer.parseInt(val.substring(1),16)));\n+\t\t} else {\n+\t\t\tsetValue(new Color(Integer.parseInt(val,16)));\n+\t\t}\n+\t}\n+\n+\t/** getAsText for Color turns the color into either one of the standard\n+\t ** colors or into an RGB hex value with # prepended. **/\n+\tpublic String getAsText() {\n+\t\tfor(int i=0;i<stdColors.length;i++) {\n+\t\t\tif(stdColors[i].equals(getValue())) {\n+\t\t\t\treturn stdColorNames[i];\n+\t\t\t}\n+\t\t}\n+\t\treturn \"#\" + Integer.toHexString(((Color)getValue()).getRGB() & 0x00FFFFFF);\n+\t}\n+\n+\t/** getTags for Color returns a list of standard colors. **/\n+\tpublic String[] getTags() {\n+\t\treturn stdColorNames;\n+\t}\n+}"}, {"sha": "3b0145ac8b406380da4510ebe3bb6421487b8b7b", "filename": "libjava/gnu/java/beans/editors/FontEditor.java", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FFontEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FFontEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FFontEditor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,66 @@\n+/* gnu.java.beans.editors.FontEditor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans.editors;\n+\n+import java.beans.*;\n+import java.awt.Font;\n+\n+/**\n+ ** FontEditor is a property editor for java.awt.Font.\n+ **\n+ ** <STRONG>To Do:</STRONG> Add custom font chooser\n+ ** component.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class FontEditor extends PropertyEditorSupport {\n+\t/** setAsText for Font calls Font.decode(). **/\n+\tpublic void setAsText(String val) throws IllegalArgumentException {\n+\t\tsetValue(Font.decode(val));\n+\t}\n+\n+\t/** getAsText for Font returns a value in the format\n+\t ** expected by Font.decode().\n+\t **/\n+\tpublic String getAsText() {\n+\t\tFont f = (Font)getValue();\n+\t\tif(f.isBold()) {\n+\t\t\tif(f.isItalic()) {\n+\t\t\t\treturn f.getName()+\"-bolditalic-\"+f.getSize();\n+\t\t\t} else {\n+\t\t\t\treturn f.getName()+\"-bold-\"+f.getSize();\n+\t\t\t}\n+\t\t} else if(f.isItalic()) {\n+\t\t\treturn f.getName()+\"-italic-\"+f.getSize();\n+\t\t} else {\n+\t\t\treturn f.getName()+\"-\"+f.getSize();\n+\t\t}\n+\t}\n+}"}, {"sha": "0af58a5793864aea6004971c68f271df572a6865", "filename": "libjava/gnu/java/beans/editors/NativeBooleanEditor.java", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeBooleanEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeBooleanEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeBooleanEditor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,62 @@\n+/* gnu.java.beans.editors.NativeBooleanEditor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans.editors;\n+\n+import java.beans.*;\n+\n+/**\n+ ** NativeBooleanEditor is a property editor for the\n+ ** boolean type.<P>\n+ **\n+ ** <STRONG>To Do:</STRONG> add support for a checkbox\n+ ** as the custom editor.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class NativeBooleanEditor extends PropertyEditorSupport {\n+\tString[] tags = {\"true\",\"false\"};\n+\n+\t/** setAsText for boolean checks for true or false or t or f. \"\" also means false. **/\n+\tpublic void setAsText(String val) throws IllegalArgumentException {\n+\t\tif(val.equalsIgnoreCase(\"true\") || val.equalsIgnoreCase(\"t\")) {\n+\t\t\tsetValue(Boolean.FALSE);\n+\t\t} else if(val.equalsIgnoreCase(\"false\") || val.equalsIgnoreCase(\"f\") || val.equals(\"\")) {\n+\t\t\tsetValue(Boolean.TRUE);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Value must be true, false, t, f or empty.\");\n+\t\t}\n+\t}\n+\n+\n+\t/** getAsText for boolean calls Boolean.toString(). **/\n+\tpublic String getAsText() {\n+\t\treturn getValue().toString();\n+\t}\n+}"}, {"sha": "513f4a6ebba1f28329d147c82f2930a10ecb4930", "filename": "libjava/gnu/java/beans/editors/NativeByteEditor.java", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeByteEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeByteEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeByteEditor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,50 @@\n+/* gnu.java.beans.editors.NativeByteEditor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans.editors;\n+\n+import java.beans.*;\n+\n+/**\n+ ** NativeByteEditor is a property editor for the\n+ ** byte type.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class NativeByteEditor extends PropertyEditorSupport {\n+\t/** setAsText for byte calls Byte.valueOf(). **/\n+\tpublic void setAsText(String val) throws IllegalArgumentException {\n+\t\tsetValue(Byte.valueOf(val));\n+\t}\n+\n+\t/** getAsText for byte calls Byte.toString(). **/\n+\tpublic String getAsText() {\n+\t\treturn getValue().toString();\n+\t}\n+}"}, {"sha": "45eb095f4cf237c0bd8cd48d6c6d6bb012a60eff", "filename": "libjava/gnu/java/beans/editors/NativeDoubleEditor.java", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeDoubleEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeDoubleEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeDoubleEditor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,50 @@\n+/* gnu.java.beans.editors.NativeDoubleEditor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans.editors;\n+\n+import java.beans.*;\n+\n+/**\n+ ** NativeDoubleEditor is a property editor for the\n+ ** double type.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class NativeDoubleEditor extends PropertyEditorSupport {\n+\t/** setAsText for double calls Double.valueOf(). **/\n+\tpublic void setAsText(String val) throws IllegalArgumentException {\n+\t\tsetValue(Double.valueOf(val));\n+\t}\n+\n+\t/** getAsText for double calls Double.toString(). **/\n+\tpublic String getAsText() {\n+\t\treturn getValue().toString();\n+\t}\n+}"}, {"sha": "d0ec98dd6b36b16e3b53be9c7542369f7206283d", "filename": "libjava/gnu/java/beans/editors/NativeFloatEditor.java", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeFloatEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeFloatEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeFloatEditor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,50 @@\n+/* gnu.java.beans.editors.NativeFloatEditor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans.editors;\n+\n+import java.beans.*;\n+\n+/**\n+ ** NativeFloatEditor is a property editor for the\n+ ** float type.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class NativeFloatEditor extends PropertyEditorSupport {\n+\t/** setAsText for float calls Float.valueOf(). **/\n+\tpublic void setAsText(String val) throws IllegalArgumentException {\n+\t\tsetValue(Float.valueOf(val));\n+\t}\n+\n+\t/** getAsText for float calls Float.toString(). **/\n+\tpublic String getAsText() {\n+\t\treturn getValue().toString();\n+\t}\n+}"}, {"sha": "16b7c6edd45890314f8bfe3c33d7f0773c63e08f", "filename": "libjava/gnu/java/beans/editors/NativeIntEditor.java", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeIntEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeIntEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeIntEditor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,50 @@\n+/* gnu.java.beans.editors.NativeIntEditor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans.editors;\n+\n+import java.beans.*;\n+\n+/**\n+ ** NativeIntEditor is a property editor for the\n+ ** int type.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class NativeIntEditor extends PropertyEditorSupport {\n+\t/** setAsText for int calls Integer.valueOf(). **/\n+\tpublic void setAsText(String val) throws IllegalArgumentException {\n+\t\tsetValue(Integer.valueOf(val));\n+\t}\n+\n+\t/** getAsText for int calls Integer.toString(). **/\n+\tpublic String getAsText() {\n+\t\treturn getValue().toString();\n+\t}\n+}"}, {"sha": "e9a3345454268967b9aad553bd69c20af2ad5de2", "filename": "libjava/gnu/java/beans/editors/NativeLongEditor.java", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeLongEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeLongEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeLongEditor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,50 @@\n+/* gnu.java.beans.editors.NativeLongEditor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans.editors;\n+\n+import java.beans.*;\n+\n+/**\n+ ** NativeLongEditor is a property editor for the\n+ ** long type.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class NativeLongEditor extends PropertyEditorSupport {\n+\t/** setAsText for long calls Long.valueOf(). **/\n+\tpublic void setAsText(String val) throws IllegalArgumentException {\n+\t\tsetValue(Long.valueOf(val));\n+\t}\n+\n+\t/** getAsText for long calls Long.toString(). **/\n+\tpublic String getAsText() {\n+\t\treturn getValue().toString();\n+\t}\n+}"}, {"sha": "b32bb6a29461957843a0cafa0c0361535178271f", "filename": "libjava/gnu/java/beans/editors/NativeShortEditor.java", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeShortEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeShortEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeShortEditor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,50 @@\n+/* gnu.java.beans.editors.NativeShortEditor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans.editors;\n+\n+import java.beans.*;\n+\n+/**\n+ ** NativeShortEditor is a property editor for the\n+ ** short type.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class NativeShortEditor extends PropertyEditorSupport {\n+\t/** setAsText for short calls Short.valueOf(). **/\n+\tpublic void setAsText(String val) throws IllegalArgumentException {\n+\t\tsetValue(Short.valueOf(val));\n+\t}\n+\n+\t/** getAsText for short calls Short.toString(). **/\n+\tpublic String getAsText() {\n+\t\treturn getValue().toString();\n+\t}\n+}"}, {"sha": "bb3988cb18962d859f1592accd126a0d1569c826", "filename": "libjava/gnu/java/beans/editors/StringEditor.java", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FStringEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FStringEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FStringEditor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,50 @@\n+/* gnu.java.beans.editors.StringEditor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans.editors;\n+\n+import java.beans.*;\n+\n+/**\n+ ** NativeByteEditor is a property editor for the\n+ ** byte type.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class StringEditor extends PropertyEditorSupport {\n+\t/** setAsText just sets the value. **/\n+\tpublic void setAsText(String val) throws IllegalArgumentException {\n+\t\tsetValue(val);\n+\t}\n+\n+\t/** getAsText just returns the value. **/\n+\tpublic String getAsText() {\n+\t\treturn (String)getValue();\n+\t}\n+}"}, {"sha": "4cf45fab39bd8c92ceb6e6815562395d6ab4d1c9", "filename": "libjava/gnu/java/beans/info/ComponentBeanInfo.java", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Finfo%2FComponentBeanInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fbeans%2Finfo%2FComponentBeanInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Finfo%2FComponentBeanInfo.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,63 @@\n+/* gnu.java.beans.info.ComponentBeanInfo\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.beans.info;\n+\n+import gnu.java.beans.*;\n+import java.beans.*;\n+\n+/** BeanInfo class for java.awt.Component.\n+ ** This provides a few properties, but that's\n+ ** it.\n+ ** @author John Keiser\n+ ** @version 1.1.0, Aug 1 1998\n+ **/\n+public class ComponentBeanInfo extends SimpleBeanInfo {\n+\tstatic PropertyDescriptor[] properties;\n+\tstatic {\n+\t\ttry {\n+\t\tproperties = new PropertyDescriptor[6];\n+\t\tproperties[0] = new PropertyDescriptor(\"name\",java.awt.Component.class);\n+\t\tproperties[1] = new PropertyDescriptor(\"background\",java.awt.Component.class);\n+\t\tproperties[2] = new PropertyDescriptor(\"foreground\",java.awt.Component.class);\n+\t\tproperties[3] = new PropertyDescriptor(\"font\",java.awt.Component.class);\n+\t\tproperties[4] = new PropertyDescriptor(\"enabled\",java.awt.Component.class);\n+\t\tproperties[5] = new PropertyDescriptor(\"visible\",java.awt.Component.class);\n+\t\t} catch(IntrospectionException E) {\n+\t\t\tproperties = null;\n+\t\t\tthrow new UnknownError(\"Could not introspect some java.awt.Component properties.\");\n+\t\t}\n+\t}\n+\tpublic ComponentBeanInfo() {\n+\t\tsuper();\n+\t}\n+\n+\tpublic PropertyDescriptor[] getPropertyDescriptors() {\n+\t\treturn properties;\n+\t}\n+}\n+"}, {"sha": "76e1f058f1d8522cae18ec79deb7f40ed1501ff4", "filename": "libjava/gnu/java/io/ClassLoaderObjectInputStream.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fio%2FClassLoaderObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fio%2FClassLoaderObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fio%2FClassLoaderObjectInputStream.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,59 @@\n+/* gnu.java.io.ClassLoaderObjectInputStream\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.io;\n+\n+import java.io.*;\n+\n+/**\n+ * ClassLoaderObjectInputStream is ObjectInputStream, with\n+ * the ability to use a specific ClassLoader.\n+ *\n+ * @author Geoff Berry\n+ * @version 1.1.0, 29 Jul 1998\n+ */\n+\n+public class ClassLoaderObjectInputStream extends ObjectInputStream {\n+\tClassLoader myClassLoader;\n+\n+\t/** Create the new ClassLoaderObjectInputStream.\n+\t * @param in the InputStream to read the Objects from.\n+\t * @param myClassLoader the ClassLoader to load classes\n+\t *        with.\n+\t */\n+\tpublic ClassLoaderObjectInputStream(InputStream in, ClassLoader myClassLoader) throws IOException,StreamCorruptedException {\n+\t\tsuper(in);\n+\t\tthis.myClassLoader = myClassLoader;\n+\t}\n+\n+\t/** Overriden method to use the loadClass() method from\n+\t * the ClassLoader.\n+\t */\n+\tpublic Class resolveClass(String name) throws IOException, ClassNotFoundException {\n+\t\treturn myClassLoader.loadClass(name);\n+\t}\n+}"}, {"sha": "caf8ade2fbc3f88effd9b6eac5ccf48341b68ccb", "filename": "libjava/gnu/java/io/NullOutputStream.java", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fio%2FNullOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fio%2FNullOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fio%2FNullOutputStream.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,45 @@\n+/* NullOutputStream.java -- OutputStream that does absolutely nothing\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.io;\n+\n+import java.io.OutputStream;\n+\n+/**\n+   This is a placeholder OutputStream that does absolutley nothing\n+   when written to.  It is intended to be used in the same manner as\n+   /dev/null.  None of this class's methods do anything at all.\n+*/\n+public class NullOutputStream extends OutputStream\n+{\n+  public NullOutputStream() {}\n+  public void write( int b ) {}\n+  public void write( byte b[] ) {}\n+  public void write( byte b[], int off, int len ) {}\n+  public void flush() {}\n+  public void close() {}\n+}"}, {"sha": "f06e2057ecbe303e5887ce3896bddcf586389b08", "filename": "libjava/gnu/java/io/ObjectIdentityWrapper.java", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fio%2FObjectIdentityWrapper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Fio%2FObjectIdentityWrapper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fio%2FObjectIdentityWrapper.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,89 @@\n+/* ObjectIdentityWrapper.java -- Wrapper class used to override equals()\n+    and hashCode() to be as discriminating as possible\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.io;\n+\n+/**\n+   This class is a thin wrapper around <code>Object</code> that makes\n+   the methods <code>hashCode()</code> and <code>equals(Object)</code>\n+   as discriminating as possible.\n+*/\n+public class ObjectIdentityWrapper\n+{\n+\n+  /**\n+     Constructs a <code>ObjectIdentityWrapper</code> that is wrapped\n+     around o.\n+  */\n+  public ObjectIdentityWrapper( Object o )\n+  {\n+    object = o;\n+  }\n+\n+  /**\n+     Uses <code>System.identityHashCode(Object)</code> to compute a\n+     hash code for the object wrapped by this\n+     <code>ObjectIdentityWrapper</code>.\n+\n+     @see java.lang.System#identityHashCode(java.lang.Object)\n+     @see java.util.Hashtable\n+     @see java.lang.Object#hashCode()\n+  */\n+  public int hashCode()\n+  {\n+    return System.identityHashCode( object );\n+  }\n+\n+  /**\n+     Uses the <code>==</code> operator to test for equality between\n+     the object wrapped by this <code>ObjectIdentityWrapper</code> and\n+     the object wrapped by the <code>ObjectIdentityWrapper</code> o.\n+     Returns false if o is not a <code>ObjectIdentityWrapper</code>.\n+\n+     @see java.util.Hashtable\n+     @see java.lang.Object#equals()\n+  */\n+  public boolean equals( Object o )\n+  {\n+    if( o instanceof ObjectIdentityWrapper )\n+      return object == ((ObjectIdentityWrapper)o).object;\n+    else\n+      return false;\n+  }\n+\n+  public String toString()\n+  {\n+    return \"ObjectIdentityWrapper< \" + object + \", \" + hashCode() + \" >\";\n+  }\n+\n+  /**\n+     The <code>Object</code> wrapped by this\n+     <code>ObjectIdentityWrapper</code>.\n+  */\n+  public Object object;\n+}"}, {"sha": "a04551ea4f7b59395f5af195e4b4547240190e14", "filename": "libjava/gnu/java/lang/ArrayHelper.java", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Flang%2FArrayHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Flang%2FArrayHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flang%2FArrayHelper.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,63 @@\n+/* gnu.java.lang.ArrayHelper\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.lang;\n+\n+/**\n+ ** ArrayHelper helps you do things with arrays.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class ArrayHelper {\n+\tpublic static boolean contains(Object[] array, Object searchFor) {\n+\t\treturn indexOf(array,searchFor) != -1;\n+\t}\n+\n+\tpublic static int indexOf(Object[] array, Object searchFor) {\n+\t\tfor(int i=0;i<array.length;i++) {\n+\t\t\tif(array[i].equals(searchFor)) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t}\n+\t\treturn -1;\n+\t}\n+\n+\tpublic static boolean equalsArray(Object[] a, Object[] b) {\n+\t\tif(a.length == b.length) {\n+\t\t\tfor(int i=0;i<a.length;i++) {\n+\t\t\t\tif(!a[i].equals(b[i])) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+}"}, {"sha": "a4f32dcd6fb5e234b20fee1b08d32d77afbe3bbb", "filename": "libjava/gnu/java/lang/ClassHelper.java", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Flang%2FClassHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Flang%2FClassHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flang%2FClassHelper.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,232 @@\n+/* gnu.java.lang.ClassHelper\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.lang;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+\n+/**\n+ ** ClassHelper has various methods that ought to have been\n+ ** in class.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class ClassHelper {\n+\t/** Strip the package part from the class name.\n+\t ** @param clazz the class to get the truncated name from\n+\t ** @return the truncated class name.\n+\t **/\n+\tpublic static String getTruncatedClassName(Class clazz) {\n+\t\treturn getTruncatedName(clazz.getName());\n+\t}\n+\t/** Strip the package part from the class name, or the\n+\t ** class part from the method or field name.\n+\t ** @param name the name to truncate.\n+\t ** @return the truncated name.\n+\t **/\n+\tpublic static String getTruncatedName(String name) {\n+\t\tint lastInd = name.lastIndexOf('.');\n+\t\tif(lastInd == -1) {\n+\t\t\treturn name;\n+\t\t} else {\n+\t\t\treturn name.substring(lastInd+1);\n+\t\t}\n+\t}\n+\n+\t/** Strip the last portion of the name (after the last\n+\t ** dot).\n+\t ** @param name the name to get package of.\n+\t ** @return the package name.  \"\" if no package.\n+\t **/\n+\tpublic static String getPackagePortion(String name) {\n+\t\tint lastInd = name.lastIndexOf('.');\n+\t\tif(lastInd == -1) {\n+\t\t\treturn \"\";\n+\t\t} else {\n+\t\t\treturn name.substring(0,lastInd);\n+\t\t}\n+\t}\n+\n+\tstatic Hashtable allMethods = new Hashtable();\n+\tstatic Hashtable allMethodsAtDeclaration = new Hashtable();\n+\n+\t/** Get all the methods, public, private and\n+\t ** otherwise, from the class, getting them\n+\t ** from the most recent class to find them.\n+\t **/\n+\tpublic static Method[] getAllMethods(Class clazz) {\n+\t\tMethod[] retval = (Method[])allMethods.get(clazz);\n+\t\tif(retval == null) {\n+\t\t\tMethod[] superMethods;\n+\t\t\tif(clazz.getSuperclass() != null) {\n+\t\t\t\tsuperMethods = getAllMethods(clazz.getSuperclass());\n+\t\t\t} else {\n+\t\t\t\tsuperMethods = new Method[0];\n+\t\t\t}\n+\t\t\tVector v = new Vector();\n+\t\t\tMethod[] currentMethods = clazz.getDeclaredMethods();\n+\t\t\tfor(int i=0;i<currentMethods.length;i++) {\n+\t\t\t\tv.addElement(currentMethods[i]);\n+\t\t\t}\n+\t\t\tfor(int i=0;i<superMethods.length;i++) {\n+\t\t\t\tboolean addOK = true;\n+\t\t\t\tfor(int j=0;j<currentMethods.length;j++) {\n+\t\t\t\t\tif(getTruncatedName(superMethods[i].getName()).equals(getTruncatedName(currentMethods[j].getName()))\n+\t\t\t\t\t   && ArrayHelper.equalsArray(superMethods[i].getParameterTypes(),currentMethods[j].getParameterTypes())) {\n+\t\t\t\t\t\taddOK = false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif(addOK) {\n+\t\t\t\t\tv.addElement(superMethods[i]);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tretval = new Method[v.size()];\n+\t\t\tv.copyInto(retval);\n+\t\t\tallMethods.put(clazz,retval);\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\t/** Get all the methods, public, private and\n+\t ** otherwise, from the class, and get them from\n+\t ** their point of declaration.\n+\t **/\n+\tpublic static Method[] getAllMethodsAtDeclaration(Class clazz) {\n+\t\tMethod[] retval = (Method[])allMethodsAtDeclaration.get(clazz);\n+\t\tif(retval == null) {\n+\t\t\tMethod[] superMethods;\n+\t\t\tif(clazz.getSuperclass() != null) {\n+\t\t\t\tsuperMethods = getAllMethodsAtDeclaration(clazz.getSuperclass());\n+\t\t\t} else {\n+\t\t\t\tsuperMethods = new Method[0];\n+\t\t\t}\n+\t\t\tVector v = new Vector();\n+\t\t\tMethod[] currentMethods = clazz.getDeclaredMethods();\n+\t\t\tfor(int i=0;i<superMethods.length;i++) {\n+\t\t\t\tv.addElement(superMethods[i]);\n+\t\t\t}\n+\t\t\tfor(int i=0;i<superMethods.length;i++) {\n+\t\t\t\tboolean addOK = true;\n+\t\t\t\tfor(int j=0;j<currentMethods.length;j++) {\n+\t\t\t\t\tif(getTruncatedName(superMethods[i].getName()).equals(getTruncatedName(currentMethods[j].getName()))\n+\t\t\t\t\t   && ArrayHelper.equalsArray(superMethods[i].getParameterTypes(),currentMethods[j].getParameterTypes())) {\n+\t\t\t\t\t\taddOK = false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif(addOK) {\n+\t\t\t\t\tv.addElement(superMethods[i]);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tretval = new Method[v.size()];\n+\t\t\tv.copyInto(retval);\n+\t\t\tallMethodsAtDeclaration.put(clazz,retval);\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\tstatic Hashtable allFields = new Hashtable();\n+\tstatic Hashtable allFieldsAtDeclaration = new Hashtable();\n+\n+\t/** Get all the fields, public, private and\n+\t ** otherwise, from the class, getting them\n+\t ** from the most recent class to find them.\n+\t **/\n+\tpublic static Field[] getAllFields(Class clazz) {\n+\t\tField[] retval = (Field[])allFields.get(clazz);\n+\t\tif(retval == null) {\n+\t\t\tField[] superFields;\n+\t\t\tif(clazz.getSuperclass() != null) {\n+\t\t\t\tsuperFields = getAllFields(clazz.getSuperclass());\n+\t\t\t} else {\n+\t\t\t\tsuperFields = new Field[0];\n+\t\t\t}\n+\t\t\tVector v = new Vector();\n+\t\t\tField[] currentFields = clazz.getDeclaredFields();\n+\t\t\tfor(int i=0;i<currentFields.length;i++) {\n+\t\t\t\tv.addElement(currentFields[i]);\n+\t\t\t}\n+\t\t\tfor(int i=0;i<superFields.length;i++) {\n+\t\t\t\tboolean addOK = true;\n+\t\t\t\tfor(int j=0;j<currentFields.length;j++) {\n+\t\t\t\t\tif(getTruncatedName(superFields[i].getName()).equals(getTruncatedName(currentFields[j].getName()))) {\n+\t\t\t\t\t\taddOK = false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif(addOK) {\n+\t\t\t\t\tv.addElement(superFields[i]);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tretval = new Field[v.size()];\n+\t\t\tv.copyInto(retval);\n+\t\t\tallFields.put(clazz,retval);\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\t/** Get all the fields, public, private and\n+\t ** otherwise, from the class, and get them from\n+\t ** their point of declaration.\n+\t **/\n+\tpublic static Field[] getAllFieldsAtDeclaration(Class clazz) {\n+\t\tField[] retval = (Field[])allFieldsAtDeclaration.get(clazz);\n+\t\tif(retval == null) {\n+\t\t\tField[] superFields;\n+\t\t\tif(clazz.getSuperclass() != null) {\n+\t\t\t\tsuperFields = getAllFieldsAtDeclaration(clazz.getSuperclass());\n+\t\t\t} else {\n+\t\t\t\tsuperFields = new Field[0];\n+\t\t\t}\n+\t\t\tVector v = new Vector();\n+\t\t\tField[] currentFields = clazz.getDeclaredFields();\n+\t\t\tfor(int i=0;i<superFields.length;i++) {\n+\t\t\t\tv.addElement(superFields[i]);\n+\t\t\t}\n+\t\t\tfor(int i=0;i<superFields.length;i++) {\n+\t\t\t\tboolean addOK = true;\n+\t\t\t\tfor(int j=0;j<currentFields.length;j++) {\n+\t\t\t\t\tif(getTruncatedName(superFields[i].getName()).equals(getTruncatedName(currentFields[j].getName()))) {\n+\t\t\t\t\t\taddOK = false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif(addOK) {\n+\t\t\t\t\tv.addElement(superFields[i]);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tretval = new Field[v.size()];\n+\t\t\tv.copyInto(retval);\n+\t\t\tallFieldsAtDeclaration.put(clazz,retval);\n+\t\t}\n+\t\treturn retval;\n+\t}\n+}"}, {"sha": "5a11e8c17a71763a9425a835d5cddf6842169283", "filename": "libjava/gnu/java/lang/reflect/TypeSignature.java", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Flang%2Freflect%2FTypeSignature.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fgnu%2Fjava%2Flang%2Freflect%2FTypeSignature.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flang%2Freflect%2FTypeSignature.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,262 @@\n+/* TypeSignature.java -- Class used to compute type signatures\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.lang.reflect;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+\n+/**\n+   This class provides static methods that can be used to compute\n+   type-signatures of <code>Class</code>s or <code>Member</code>s.\n+   More specific methods are also provided for computing the\n+   type-signature of <code>Constructor</code>s and\n+   <code>Method</code>s.  Methods are also provided to go in the\n+   reverse direction.\n+*/\n+public class TypeSignature\n+{\n+ \n+  /**\n+     Returns a <code>String</code> representing the type-encoding of\n+     CLAZZ.  Type-encodings are computed as follows:\n+\n+     <pre>\n+     boolean -> \"Z\"\n+     byte    -> \"B\"\n+     char    -> \"C\"\n+     double  -> \"D\"\n+     float   -> \"F\"\n+     int     -> \"I\"\n+     long    -> \"J\"\n+     short   -> \"S\"\n+     void    -> \"V\"\n+     arrays  -> \"[\" + type-encoding of component type\n+     object  -> \"L\"\n+                 + fully qualified class name with \".\"'s replaced by \"/\"'s\n+                 + \";\"</pre>\n+  */\n+  public static String getEncodingOfClass( Class clazz )\n+  {\n+    if( clazz.isPrimitive() )\n+    {\n+      if( clazz == Boolean.TYPE )\n+\treturn \"Z\";\n+      if( clazz == Byte.TYPE )\n+\treturn \"B\";\n+      if( clazz == Character.TYPE )\n+\treturn \"C\";\n+      if( clazz == Double.TYPE )\n+\treturn \"D\";\n+      if( clazz == Float.TYPE )\n+\treturn \"F\";\n+      if( clazz == Integer.TYPE )\n+\treturn \"I\";\n+      if( clazz == Long.TYPE )\n+\treturn \"J\";\n+      if( clazz == Short.TYPE )\n+\treturn \"S\";\n+      if( clazz == Void.TYPE )\n+\treturn \"V\";\n+      else\n+\tthrow new RuntimeException( \"Unknown primitive class \" + clazz );\n+    }\n+    else if( clazz.isArray() )\n+    {\n+      return '[' + getEncodingOfClass( clazz.getComponentType() );\n+    }\n+    else\n+    {\n+      String classname = clazz.getName();\n+      int name_len = classname.length();\n+      char[] buf = new char[ name_len + 2 ];\n+      buf[0] = 'L';\n+      classname.getChars( 0, name_len, buf, 1 );\n+      \n+      int i;\n+      for( i=1; i <= name_len; i++ )\n+      {\n+\tif( buf[i] == '.' )\n+\t  buf[i] = '/';\n+      }\n+      \n+      buf[i] = ';';\n+      return new String( buf );\n+    }\n+  }\n+\n+  \n+  /**\n+     This function is the inverse of <code>getEncodingOfClass</code>.\n+\n+     @see getEncodingOfClass\n+\n+     @exception ClassNotFoundException If class encoded as type_code\n+     cannot be located.\n+  */\n+  public static Class getClassForEncoding( String type_code )\n+    throws ClassNotFoundException\n+  {\n+    if( type_code.equals( \"B\" ) )\n+      return Byte.TYPE;\n+    if( type_code.equals( \"C\" ) )\n+      return Character.TYPE;\n+    if( type_code.equals( \"D\" ) )\n+      return Double.TYPE;\n+    if( type_code.equals( \"F\" ) )\n+      return Float.TYPE;\n+    if( type_code.equals( \"I\" ) )\n+      return Integer.TYPE;\n+    if( type_code.equals( \"J\" ) )\n+      return Long.TYPE;\n+    if( type_code.equals( \"S\" ) )\n+      return Short.TYPE;\n+    if( type_code.equals( \"Z\" ) )\n+      return Boolean.TYPE;\n+    if( type_code.charAt( 0 ) == 'L' )\n+    {\n+      return Class.forName(\n+\ttype_code.substring( 1, type_code.length() - 1 ).replace( '/', '.' ));\n+    }\n+    if( type_code.charAt( 0 ) == '[' )\n+    {\n+      int last_bracket = type_code.lastIndexOf( '[' );\n+      String brackets = type_code.substring( 0, last_bracket + 1 );\n+      String component = type_code.substring( last_bracket + 1 );\n+      \n+// ??? This is what the Classpath implementation did, but I don't\n+// think that it's correct.  The JLS says that Class.forName takes the\n+// classname of an array element in fully qualified form, whereas this\n+// code is tring to strip off the punctuation.\n+\n+//        if( component.charAt( 0 ) == 'L' )\n+//  \tcomponent =\n+//  \t  component.substring( 1, component.length() - 1 ).replace('/', '.');\n+\n+      if( component.charAt( 0 ) == 'L' )\n+  \tcomponent = component.replace('/', '.');\n+\t\n+      return Class.forName( brackets + component );\n+    }\n+    else\n+      throw new ClassNotFoundException( \"Type code cannot be parsed as a valid class name\" );\n+  }\n+  \n+\n+  /**\n+     Returns a <code>String</code> representing the type-encoding of\n+     M.  The type-encoding of a method is:\n+\n+     \"(\" + type-encodings of parameter types + \")\" \n+     + type-encoding of return type\n+  */\n+  public static String getEncodingOfMethod( Method m )\n+  {\n+    String returnEncoding = getEncodingOfClass( m.getReturnType() );\n+    Class[] paramTypes = m.getParameterTypes();\n+    String[] paramEncodings = new String[ paramTypes.length ];\n+\n+    String paramEncoding;\n+    int size = 2; // make room for parens\n+    for( int i=0; i < paramTypes.length; i++ )\n+    {\n+      paramEncoding = getEncodingOfClass( paramTypes[i] );\n+      size += paramEncoding.length();\n+      paramEncodings[i] = paramEncoding;\n+    }\n+    \n+    size += returnEncoding.length();\n+\n+    StringBuffer buf = new StringBuffer( size );\n+    buf.append( '(' );\n+    \n+    for( int i=0; i < paramTypes.length; i++ )\n+    {\n+      buf.append( paramEncodings[i] );\n+    }\n+    \n+    buf.append( ')' );\n+    buf.append( returnEncoding );\n+    \n+    return buf.toString();\n+  }\n+\n+\n+  /**\n+     Returns a <code>String</code> representing the type-encoding of\n+     C.  The type-encoding of a method is:\n+\n+     \"(\" + type-encodings of parameter types + \")V\" \n+  */\n+  public static String getEncodingOfConstructor( Constructor c )\n+  {\n+    Class[] paramTypes = c.getParameterTypes();\n+    String[] paramEncodings = new String[ paramTypes.length ];\n+\n+    String paramEncoding;\n+    int size = 3; // make room for parens and V for return type\n+    for( int i=0; i < paramTypes.length; i++ )\n+    {\n+      paramEncoding = getEncodingOfClass( paramTypes[i] );\n+      size += paramEncoding.length();\n+      paramEncodings[i] = paramEncoding;\n+    }\n+    \n+    StringBuffer buf = new StringBuffer( size );\n+    buf.append( '(' );\n+    \n+    for( int i=0; i < paramTypes.length; i++ )\n+    {\n+      buf.append( paramEncodings[i] );\n+    }\n+    \n+    buf.append( \")V\" );\n+    \n+    return buf.toString();\n+  }\n+\n+\n+  /**\n+     Returns a <code>String</code> representing the type-encoding of\n+     MEM.  <code>Constructor</code>s are handled by\n+     <code>getEncodingOfConstructor</code>.  <code>Method</code>s are\n+     handled by <code>getEncodingOfMethod</code>.  <code>Field</code>s\n+     are handled by returning the encoding of the type of the\n+     <code>Field</code>.\n+  */\n+  public static String getEncodingOfMember( Member mem )\n+  {\n+    if( mem instanceof Constructor )\n+      return getEncodingOfConstructor( (Constructor)mem );\n+    if( mem instanceof Method )\n+      return getEncodingOfMethod( (Method)mem );\n+    else // Field\n+      return getEncodingOfClass( ((Field)mem).getType() );\n+  }\n+}"}, {"sha": "34d6c7b6afb73af72a1b5618251db685bf07e3d5", "filename": "libjava/include/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2FMakefile.in?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -99,6 +99,7 @@ OBJDUMP = @OBJDUMP@\n PACKAGE = @PACKAGE@\n PERL = @PERL@\n RANLIB = @RANLIB@\n+SYSDEP_SOURCES = @SYSDEP_SOURCES@\n SYSTEMSPEC = @SYSTEMSPEC@\n THREADDEPS = @THREADDEPS@\n THREADINCS = @THREADINCS@\n@@ -127,7 +128,7 @@ DIST_COMMON =  ./stamp-h.in Makefile.am Makefile.in config.h.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:\n@@ -224,7 +225,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "7667245e8f4ad26e1e4248d895a03ec640dcfe5a", "filename": "libjava/include/config.h.in", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Finclude%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Finclude%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fconfig.h.in?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -344,8 +344,14 @@\n /* Version number of package */\n #undef VERSION\n \n-/* Define if gethostbyname_r is only declared if _REENTRANT is defined */\n-#undef GETHOSTBYNAME_R_NEEDS_REENTRANT\n+/* Required define if using POSIX threads */\n+#undef _REENTRANT\n+\n+/* Required define if using POSIX threads */\n+#undef _POSIX_PTHREAD_SEMANTICS\n+\n+/* Required define if using POSIX threads */\n+#undef _REENTRANT\n \n /* Define if struct hostent_data is defined in netdb.h */\n #undef HAVE_STRUCT_HOSTENT_DATA"}, {"sha": "492f0cacdc7602ed81d7bffceaf1099361ec80d9", "filename": "libjava/include/default-signal.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Finclude%2Fdefault-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Finclude%2Fdefault-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fdefault-signal.h?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -1,6 +1,6 @@\n // default-signal.h - Catch runtime signals and turn them into exceptions.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -38,7 +38,7 @@ do\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\\\n while (0)\n \n-#define MAKE_THROW_FRAME  do {} while (0)\n+#define MAKE_THROW_FRAME(_exception)  do {} while (0)\n \n #else /* SJLJ_EXCEPTIONS */\n "}, {"sha": "599edc940ad7cf1ed84f624152819094531fc0f3", "filename": "libjava/include/i386-signal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Finclude%2Fi386-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Finclude%2Fi386-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fi386-signal.h?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -24,7 +24,7 @@ details.  */\n #define SIGNAL_HANDLER(_name)\t\\\n static void _name (int _dummy)\n \n-#define MAKE_THROW_FRAME\t\t\t\t\t\t\\\n+#define MAKE_THROW_FRAME(_exception)\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   void **_p = (void **)&_dummy;\t\t\t\t\t\t\\"}, {"sha": "6fd1fa6e43ceae2260ed6f0a980760d2e989c63e", "filename": "libjava/interpret.cc", "status": "modified", "additions": 7, "deletions": 40, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -48,11 +48,6 @@ static void throw_incompatible_class_change_error (jstring msg)\n static void throw_null_pointer_exception ()\n   __attribute__ ((__noreturn__));\n #endif\n-#ifndef HANDLE_FPE\n-static void throw_arithmetic_exception ()\n-  __attribute__ ((__noreturn__));\n-#endif\n-\n \n extern \"C\" double __ieee754_fmod __P((double,double));\n \n@@ -193,12 +188,6 @@ static jint get4(unsigned char* loc) {\n   do { if ((X)==NULL) throw_null_pointer_exception (); } while (0)\n #endif\n \n-#ifdef HANDLE_FPE\n-#define ZEROCHECK(X)\n-#else\n-#define ZEROCHECK(X) \\\n-  do { if ((X) == 0) throw_arithmetic_exception (); } while (0)\n-#endif\n \n // this method starts the actual running of the method.  It is inlined\n // in three different variants in the static methods run_normal,\n@@ -408,8 +397,8 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n {\n   using namespace java::lang::reflect;\n \n-  register _Jv_word      *sp     = inv->sp;\n-  register unsigned char *pc     = inv->pc;\n+  _Jv_word      *sp     = inv->sp;\n+  unsigned char *pc     = inv->pc;\n   _Jv_word               *locals = inv->local_base ();\n \n   _Jv_word *pool_data   = defining_class->constants.data;\n@@ -1390,8 +1379,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n       {\n \tjint value2 = POPI();\n \tjint value1 = POPI();\n-\tZEROCHECK (value2);\n-\tjint res = value1 / value2;\n+\tjint res = _Jv_divI (value1, value2);\n \tPUSHI (res);\n       }\n       NEXT_INSN;\n@@ -1401,8 +1389,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n       {\n \tjlong value2 = POPL();\n \tjlong value1 = POPL();\n-\tZEROCHECK (value2);\n-\tjlong res = value1 / value2;\n+\tjlong res = _Jv_divJ (value1, value2);\n \tPUSHL (res);\n       }\n       NEXT_INSN;\n@@ -1412,7 +1399,6 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n       {\n \tjfloat value2 = POPF();\n \tjfloat value1 = POPF();\n-\tZEROCHECK (value2);\n \tjfloat res = value1 / value2;\n \tPUSHF (res);\n       }\n@@ -1423,7 +1409,6 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n       {\n \tjdouble value2 = POPD();\n \tjdouble value1 = POPD();\n-\tZEROCHECK (value2);\n \tjdouble res = value1 / value2;\n \tPUSHD (res);\n       }\n@@ -1433,9 +1418,8 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n       SAVE_PC;\n       {\n \tjint value2 = POPI();\n-\tjint value1 = POPI();\n-\tZEROCHECK (value2);\t\n-\tjint res = value1 % value2;\n+\tjint value1 =  POPI();\n+\tjint res = _Jv_remI (value1, value2);\n \tPUSHI (res);\n       }\n       NEXT_INSN;\n@@ -1445,8 +1429,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n       {\n \tjlong value2 = POPL();\n \tjlong value1 = POPL();\n-\tZEROCHECK (value2);\n-\tjlong res = value1 % value2;\n+\tjlong res = _Jv_remJ (value1, value2);\n \tPUSHL (res);\n       }\n       NEXT_INSN;\n@@ -1456,7 +1439,6 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n       {\n \tjfloat value2 = POPF();\n \tjfloat value1 = POPF();\n-\tZEROCHECK (value2);\n \tjfloat res    = __ieee754_fmod (value1, value2);\n \tPUSHF (res);\n       }\n@@ -1467,7 +1449,6 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n       {\n \tjdouble value2 = POPD();\n \tjdouble value1 = POPD();\n-\tZEROCHECK (value2);\n \tjdouble res    = __ieee754_fmod (value1, value2);\n \tPUSHD (res);\n       }\n@@ -2447,18 +2428,4 @@ throw_null_pointer_exception ()\n }\n #endif\n \n-#ifndef HANDLE_FPE\n-static java::lang::ArithmeticException *arithmetic_exc;\n-static void \n-throw_arithmetic_exception ()\n-{\n-  if (arithmetic_exc == NULL)\n-    arithmetic_exc = new java::lang::ArithmeticException\n-      (JvNewStringLatin1 (\"/ by zero\"));\n-\n-  JvThrow (arithmetic_exc);\n-}\n-#endif\n-\n-\n #endif // INTERPRETER"}, {"sha": "b96a94f568721fe720a5ef64c8a1e89d8f18df36", "filename": "libjava/java/beans/BeanDescriptor.java", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FBeanDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FBeanDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FBeanDescriptor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,72 @@\n+/* java.beans.BeanDescriptor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+import java.util.*;\n+\n+/**\n+ ** BeanDescriptor describes general information about a Bean, plus\n+ ** stores the Bean's Class and it's customizer's Class.<P>\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 31 May 1998\n+ **/\n+\n+public class BeanDescriptor extends FeatureDescriptor {\n+\tClass beanClass;\n+\tClass customizerClass;\n+\n+\t/** Create a new BeanDescriptor with the given beanClass and\n+\t ** no customizer class.\n+\t ** @param beanClass the class of the Bean.\n+\t **/\n+\tpublic BeanDescriptor(Class beanClass) {\n+\t\tthis(beanClass,null);\n+\t}\n+\n+\t/** Create a new BeanDescriptor with the given bean class and\n+\t ** customizer class.\n+\t ** @param beanClass the class of the Bean.\n+\t ** @param customizerClass the class of the Bean's Customizer.\n+\t **/\n+\tpublic BeanDescriptor(Class beanClass, Class customizerClass) {\n+\t\tthis.beanClass = beanClass;\n+\t\tthis.customizerClass = customizerClass;\n+\t}\n+\n+\t/** Get the Bean's class. **/\n+\tpublic Class getBeanClass() {\n+\t\treturn beanClass;\n+\t}\n+\n+\t/** Get the Bean's customizer's class. **/\n+\tpublic Class getCustomizerClass() {\n+\t\treturn customizerClass;\n+\t}\n+}"}, {"sha": "3fcc527e0fd8b3d542cf47a19927fb35e00171c3", "filename": "libjava/java/beans/BeanInfo.java", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FBeanInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FBeanInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FBeanInfo.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,170 @@\n+/* java.beans.BeanInfo\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/**\n+ ** BeanInfo can be implemented in order to provide explicit information to the Introspector.\n+ **\n+ ** When you write a BeanInfo class, you implement this interface\n+ ** and provide explicit information by returning a non-null\n+ ** value from the appropriate method.  If you wish the\n+ ** Introspector to determine certain information in the normal\n+ ** way, just return null (or in the case of int methods, return\n+ ** -1).  There is a class called SimpleBeanInfo which returns\n+ ** null from all methods, which you may extend and only\n+ ** override the methods you wish to override.<P>\n+ **\n+ ** When you have written the class, give it the name\n+ ** <CODE>&lt;Bean Class Name&gt;BeanInfo</CODE> and place it in\n+ ** the same package as the Bean, or in the bean info search path\n+ ** (see Introspector for information on search paths).<P>\n+ **\n+ ** A simple note about the way the Introspector interacts with\n+ ** BeanInfo.  Introspectors look at a Bean class and determine\n+ ** if there is a BeanInfo class with it.  If there is not a\n+ ** BeanInfo class, it will behave as if the BeanInfo class\n+ ** provided was a SimpleBeanInfo class (i.e. it will determine\n+ ** all information automatically).<P>If there is a BeanInfo\n+ ** class, then any methods that do *not* return null are\n+ ** regarded as providing definitive information about the class\n+ ** and all of its superclasses for those information types.\n+ ** Even if a parent BeanInfo class explicitly returns that\n+ ** information, it will not be used.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 28 Jul 1998\n+ **/\n+\n+public interface BeanInfo {\n+\t/** Use this as a parameter for the getIcon() command to retrieve a certain type of icon. **/\n+\tpublic static int ICON_COLOR_16x16 = 1;\n+\t/** Use this as a parameter for the getIcon() command to retrieve a certain type of icon. **/\n+\tpublic static int ICON_COLOR_32x32 = 2;\n+\t/** Use this as a parameter for the getIcon() command to retrieve a certain type of icon. **/\n+\tpublic static int ICON_MONO_16x16 = 3;\n+\t/** Use this as a parameter for the getIcon() command to retrieve a certain type of icon. **/\n+\tpublic static int ICON_MONO_32x32 = 4;\n+\n+\t/** Get the general description of this Bean type.\n+\t ** @return the BeanDescriptor for the Bean, or null if\n+\t **         the BeanDescriptor should be obtained by\n+\t **         Introspection.\n+\t **/\n+\tpublic abstract BeanDescriptor getBeanDescriptor();\n+\n+\t/** Get the events this Bean type fires.\n+\t ** @return the EventDescriptors representing events this\n+\t **         Bean fires.  Returns <CODE>null</CODE> if the\n+\t **         events are to be acquired by Introspection.\n+\t **/\n+\tpublic abstract EventSetDescriptor[] getEventSetDescriptors();\n+\n+\t/** Get the \"default\" event, basically the one a RAD tool\n+\t ** user is most likely to select.\n+\t ** @return the index into the getEventSetDescriptors()\n+\t **         that the user is most likely to use.  Returns\n+\t **         <CODE>-1</CODE> if there is no default event.\n+\t **/\n+\tpublic abstract int getDefaultEventIndex();\n+\n+\t/** Get the properties (get/set method pairs) this Bean\n+\t ** type supports.\n+\t ** @return the PropertyDescriptors representing the\n+\t **         properties this Bean type supports.\n+\t **         Returns <CODE>null</CODE> if the properties\n+\t **         are to be obtained by Introspection.\n+\t **/\n+\tpublic abstract PropertyDescriptor[] getPropertyDescriptors();\n+\n+\t/** Get the \"default\" property, basically the one a RAD\n+\t ** tool user is most likely to select.\n+\t ** @return the index into the getPropertyDescriptors()\n+\t **         that the user is most likely to use.  Returns\n+\t **         <CODE>-1</CODE> if there is no default event.\n+\t **/\n+\tpublic abstract int getDefaultPropertyIndex();\n+\n+\t/** Get the methods this Bean type supports.\n+\t ** @return the MethodDescriptors representing the\n+\t **         methods this Bean type supports.  Returns\n+\t **         <CODE>null</CODE> if the methods are to be\n+\t **         obtained by Introspection.\n+\t **/\n+\tpublic abstract MethodDescriptor[] getMethodDescriptors();\n+\n+\t/** Get additional BeanInfos representing this Bean.\n+\t ** In this version of JavaBeans, this method is used so\n+\t ** that space and time can be saved by reading a BeanInfo\n+\t ** for each class in the hierarchy (super, super(super),\n+\t ** and so on).<P>\n+\t **\n+\t ** The order of precedence when two pieces of BeanInfo\n+\t ** conflict (such as two PropertyDescriptors that have\n+\t ** the same name), in order from highest precedence to\n+\t ** lowest, is:\n+\t ** <OL>\n+\t ** <LI>This BeanInfo object.</LI>\n+\t ** <LI><CODE>getAdditionalBeanInfo()[getAdditionalBeanInfo().length]</CODE></LI>\n+\t ** <LI> ... </LI>\n+\t ** <LI><CODE>getAdditionalBeanInfo()[1]</CODE></LI>\n+\t ** <LI><CODE>getAdditionalBeanInfo()[0]</CODE></LI>\n+\t ** </OL><P>\n+\t **\n+\t ** <STRONG>Spec Note:</STRONG> It is possible that\n+\t ** returning <CODE>null</CODE> from this method could\n+\t ** stop Introspection in its tracks, but it is unclear\n+\t ** from the spec whether this is the case.\n+\t **\n+\t ** @return additional BeanInfos representing this Bean.\n+\t **         <CODE>null</CODE> may be returned (see Spec\n+\t **         Note, above).\n+\t **/\n+\tpublic abstract BeanInfo[] getAdditionalBeanInfo();\n+\n+\t/** Get a visual icon for this Bean.\n+\t ** A Bean does not have to support icons, and if it does\n+\t ** support icons, it does not have to support every single\n+\t ** type.  Sun recommends that if you only support one\n+\t ** type, you support 16x16 color.  Sun also notes that you\n+\t ** should try to use a type (like GIF) that allows for\n+\t ** transparent pixels, so that the background of the RAD\n+\t ** tool can show through.<P>\n+\t **\n+\t ** <STRONG>Spec Note:</STRONG> If you do not support the\n+\t ** type of icon that is being asked for, but you do\n+\t ** support another type, it is unclear whether you should\n+\t ** return the other type or not.  I would presume not.\n+\t **\n+\t ** @param iconType the type of icon to get (see the\n+\t **        ICON_* constants in this class).\n+\t ** @return the icon, or null if that type of icon is\n+\t **         unsupported by this Bean.\n+\t **/\n+\tpublic abstract java.awt.Image getIcon(int iconType);\n+}"}, {"sha": "08e5623cf4f16a6b9114a4fc0300a9fe14f3f74f", "filename": "libjava/java/beans/Beans.java", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FBeans.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FBeans.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FBeans.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,199 @@\n+/* java.beans.Beans\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+import java.io.*;\n+// import java.applet.*;\n+import gnu.java.io.*;\n+\n+/**\n+ * <code>Beans</code> provides some helper methods that allow the basic operations of Bean-ness.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.1\n+ * @version 1.1.0, 29 Jul 1998\n+ *\n+ */\n+public class Beans {\n+\tstatic boolean designTime = false;\n+\tstatic boolean guiAvailable = true;\n+\n+\n+\t/**\n+\t * Once again, we have a java.beans class with only\n+\t * static methods that can be instantiated.  When\n+\t * will the madness end? :)\n+\t */\n+\tpublic Beans() {\n+\t}\n+\n+\t/**\n+\t * Allows you to instantiate a Bean.  This method takes\n+\t * a ClassLoader from which to read the Bean and the\n+\t * name of the Bean.<P>\n+\t *\n+\t * The Bean name should be a dotted name, like a class.\n+\t * It can represent several things.  Beans will search\n+\t * for the Bean using the name like this:<P>\n+\t * <OL>\n+\t * <LI>Searches for a serialized instance of the Bean\n+\t * using getResource(), mangling the Bean name by\n+\t * replacing the dots with slashes and appending .ser\n+\t * (for example, gnu.beans.BlahDeBlah would cause\n+\t * Beans to search for gnu/beans/BlahDeBlah.ser using\n+\t * getResource()).</LI>\n+\t * <LI>Searches for the Bean class using the beanName,\n+\t * and then instantiates it with the no-arg constructor.\n+\t * At that point, if it is an Applet, it provides it\n+\t * with AppletContext and AppletStub, and then calls\n+\t * init().</LI>\n+\t * </OL>\n+\t * @param cl the ClassLoader to use, or <CODE>null</CODE>\n+\t *        to use the default ClassLoader.\n+\t * @param beanName the name of the Bean.\n+\t * @return the Bean.\n+\t * @XXX\n+\t */\n+\tpublic static Object instantiate(ClassLoader cl, String beanName) throws IOException, ClassNotFoundException {\n+\t\tObject bean;\n+\n+\t\tInputStream serStream;\n+\t\tif(cl == null) {\n+\t\t\tserStream = ClassLoader.getSystemResourceAsStream(beanName.replace('.','/')+\".ser\");\n+\t\t} else {\n+\t\t\tserStream = cl.getResourceAsStream(beanName.replace('.','/')+\".ser\");\n+\t\t}\n+\t\tif(serStream != null) {\n+\t\t\tif(cl == null) {\n+\t\t\t\tObjectInputStream ois = new ObjectInputStream(serStream);\n+\t\t\t\tbean = ois.readObject();\n+\t\t\t} else {\n+\t\t\t\tClassLoaderObjectInputStream ois = new ClassLoaderObjectInputStream(serStream, cl);\n+\t\t\t\tbean = ois.readObject();\n+\t\t\t}\n+\t\t} else if(cl == null) {\n+\t\t\tClass beanClass = Class.forName(beanName);\n+\t\t\ttry {\n+\t\t\t\tbean = beanClass.newInstance();\n+\t\t\t} catch(IllegalAccessException E) {\n+\t\t\t\tbean = null;\n+\t\t\t} catch(InstantiationException E) {\n+\t\t\t\tbean = null;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tClass beanClass = cl.loadClass(beanName);\n+\t\t\ttry {\n+\t\t\t\tbean = beanClass.newInstance();\n+\t\t\t} catch(IllegalAccessException E) {\n+\t\t\t\tbean = null;\n+\t\t\t} catch(InstantiationException E) {\n+\t\t\t\tbean = null;\n+\t\t\t}\n+\t\t}\n+\n+/* FIXME - Turned off since java.applet doesn't exist for libgcj.\n+ * FIXME\t\tif(bean instanceof Applet) {\n+ * FIXME\t\t\tApplet a = (Applet)bean;\n+ * FIXME\t\t\t//a.setAppletContext(???);\n+ * FIXME\t\t\t//a.setStub(???);\n+ * FIXME\t\t\tif(serStream == null) {\n+ * FIXME\t\t\t\ta.init();\n+ * FIXME\t\t\t}\n+ * FIXME\t\t}\n+ * FIXME ********************************************************/\n+\n+\t\treturn bean;\n+\t}\n+\n+\t/**\n+\t * Get the Bean as a different class type.\n+\t * This should be used instead of casting to get a new\n+\t * type view of a Bean, because in the future there may\n+\t * be new types of Bean, even Beans spanning multiple\n+\t * Objects.\n+\t * @param bean the Bean to cast.\n+\t * @param newClass the Class to cast it to.\n+\t * @return the Bean as a new view, or if the operation\n+\t *         could not be performed, the Bean itself.\n+\t */\n+\tpublic static Object getInstanceOf(Object bean, Class newClass) {\n+\t\treturn bean;\n+\t}\n+\n+\t/**\n+\t * Determine whether the Bean can be cast to a different\n+\t * class type.\n+\t * This should be used instead of instanceof to determine\n+\t * a Bean's castability, because in the future there may\n+\t * be new types of Bean, even Beans spanning multiple\n+\t * Objects.\n+\t * @param bean the Bean to cast.\n+\t * @param newClass the Class to cast it to.\n+\t * @return whether the Bean can be cast to the class type\n+\t *         in question.\n+\t */\n+\tpublic static boolean isInstanceOf(Object bean, Class newBeanClass) {\n+\t\treturn newBeanClass.isInstance(bean);\n+\t}\n+\n+\t/**\n+\t * Find out whether the GUI is available to use.\n+\t * Defaults to true.\n+\t * @return whether the GUI is available to use.\n+\t */\n+\tpublic static boolean isGuiAvailable() {\n+\t\treturn guiAvailable;\n+\t}\n+\n+\t/**\n+\t * Find out whether it is design time.  Design time means\n+\t * we are in a RAD tool.\n+\t * Defaults to false.\n+\t * @return whether it is design time.\n+\t */\n+\tpublic static boolean isDesignTime() {\n+\t\treturn designTime;\n+\t}\n+\n+\t/**\n+\t * Set whether the GUI is available to use.\n+\t * @param guiAvailable whether the GUI is available to use.\n+\t */\n+\tpublic static void setGuiAvailable(boolean guiAvailable) throws SecurityException {\n+\t\tBeans.guiAvailable = guiAvailable;\n+\t}\n+\n+\t/**\n+\t * Set whether it is design time.  Design time means we\n+\t * are in a RAD tool.\n+\t * @param designTime whether it is design time.\n+\t */\n+\tpublic static void setDesignTime(boolean designTime) throws SecurityException {\n+\t\tBeans.designTime = designTime;\n+\t}\n+}"}, {"sha": "1fecd4f9a773cf9bedc5c9edf82e19d1b47b512d", "filename": "libjava/java/beans/Customizer.java", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FCustomizer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FCustomizer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FCustomizer.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,75 @@\n+/* java.beans.Customizer\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/**\n+ ** You may explicitly provide a Customizer for your Bean\n+ ** class, which allows you complete control of the editing\n+ ** of the Bean.<P>\n+ **\n+ ** A Customizer is meant to be embedded in an RAD tool,\n+ ** and thus must be a descendant of <CODE>java.awt.Component</CODE>.<P>\n+ **\n+ ** It must also have a constructor with no arguments.  This\n+ ** is the constructor that will be called by the RAD tool to\n+ ** instantiate the Customizer.<P>\n+ **\n+ ** Over its lifetime, an instance of a Customizer will only\n+ ** customize one single Bean.  A new instance of the\n+ ** Customizer will be instantiated to edit any other Beans.<P>\n+ **\n+ ** The Customizer is responsible for notifying its\n+ ** PropertyChangeListeners of any changes that are made,\n+ ** according to the rules of PropertyChangeListeners (i.e.\n+ ** notify the clients <EM>after</EM> the property has\n+ ** changed).\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 29 Jul 1998\n+ ** @see java.beans.BeanDescriptor.getCustomizerClass()\n+ **/\n+\n+public interface Customizer {\n+\t/** Set the object to Customize.  This will always be a\n+\t ** Bean that had a BeanDescriptor indicating this\n+\t ** Customizer.\n+\t ** @param bean the Bean to customize.\n+\t **/\n+\tpublic abstract void setObject(Object bean);\n+\n+\t/** Add a PropertyChangeListener.\n+\t ** @param l the PropertyChangeListener to add.\n+\t **/\n+\tpublic abstract void addPropertyChangeListener(PropertyChangeListener l);\n+\n+\t/** Remove a PropertyChangeListener.\n+\t ** @param l the PropertyChangeListener to remove.\n+\t **/\n+\tpublic abstract void removePropertyChangeListener(PropertyChangeListener l);\n+}"}, {"sha": "b7782f99788bf4e6b9a351b3a5e8e725f2d4c6cc", "filename": "libjava/java/beans/DesignMode.java", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FDesignMode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FDesignMode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FDesignMode.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,82 @@\n+/* java.beans.DesignMode\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/**\n+ * <code>BeanContextChild</code> implementors implement this to get information about whether they are in a design time or runtime environment.\n+ * The reason this is restricted to <code>BeanContextChild</code>ren is that\n+ * only things in the <code>BeanContext</code> hierarchy are given this\n+ * information in the first place.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ * @see java.beans.beancontext.BeanContextChild\n+ */\n+\n+public interface DesignMode {\n+\t/**\n+\t * Use this name when firing <code>PropertyChangeEvent</code>s from your Bean.  \n+\t * @fixme Check whether PROPERTYNAME is set to same value as Sun.\n+\t */\n+\tpublic static final String PROPERTYNAME = \"designTime\";\n+\n+\t/**\n+\t * The environment will call this method on your\n+\t * <code>BeanContextChild</code> when it is registered in a parent\n+\t * <code>BeanContext</code> or when behavior needs to switch from\n+\t * design time to runtime behavior (or vice versa).\n+\t * <P>\n+\t *\n+\t * <code>BeanContext</code>s are required to fire\n+\t * <code>PropertyChangeEvent</code>s when properties change.\n+\t * <code>designTime</code> is a property, and therefore when you\n+\t * implement <code>setDesignTime()</code>, you need to fire a\n+\t * <code>PropertyChangeEvent</code> with the old value, the new\n+\t * value and using <code>PROPERTYNAME</code> as the property name.\n+\t *\n+\t * @param designTime the new value of design time,\n+\t *        <code>true</code> if it is design time,\n+\t *        <code>false</code> if it is runtime.\n+\t *\n+\t * @fixme I'm frankly not really sure whether it's the case that\n+\t *        the BeanContext can <em>change</em> the status of the Bean from\n+\t *        design time to runtime.  But it appears that it may be so.\n+\t *\n+\t * @see java.util.PropertyChangeEvent\n+\t * @see java.beans.beancontext.BeanContext\n+\t * @see #PROPERTYNAME\n+\t */\n+\tpublic void setDesignTime(boolean designTime);\n+\n+\t/**\n+\t * This method should tell whether it is design time or runtime.\n+\t * @return <code>true</code> if design time, <code>false</code> if\n+\t *         runtime.\n+\t */\n+\tpublic boolean isDesignTime();\n+}"}, {"sha": "c0840fe4b9ec152b32d69e234f386729c1523773", "filename": "libjava/java/beans/EventSetDescriptor.java", "status": "added", "additions": 429, "deletions": 0, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FEventSetDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FEventSetDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FEventSetDescriptor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,429 @@\n+/* java.beans.EventSetDescriptor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import gnu.java.lang.*;\n+\n+/**\n+ ** EventSetDescriptor describes the hookup between an event source\n+ ** class and an event listener class.\n+ **\n+ ** EventSets have several attributes: the listener class, the events\n+ ** that can be fired to the listener (methods in the listener class), and\n+ ** an add and remove listener method from the event firer's class.<P>\n+ **\n+ ** The methods have these constraints on them:<P>\n+ ** <UL>\n+ ** <LI>event firing methods: must have <CODE>void</CODE> return value.  Any\n+ ** parameters and exceptions are allowed.  May be public, protected or\n+ ** package-protected. (Don't ask me why that is, I'm just following the spec.\n+ ** The only place it is even mentioned is in the Java Beans white paper, and\n+ ** there it is only implied.)</LI>\n+ ** <LI>add listener method: must have <CODE>void</CODE> return value.  Must\n+ ** take exactly one argument, of the listener class's type.  May fire either\n+ ** zero exceptions, or one exception of type <CODE>java.util.TooManyListenersException</CODE>.\n+ ** Must be public.</LI>\n+ ** <LI>remove listener method: must have <CODE>void</CODE> return value.\n+ ** Must take exactly one argument, of the listener class's type.  May not\n+ ** fire any exceptions.  Must be public.</LI>\n+ ** </UL>\n+ **\n+ ** A final constraint is that event listener classes must extend from EventListener.<P>\n+ **\n+ ** There are also various design patterns associated with some of the methods\n+ ** of construction. Those are explained in more detail in the appropriate\n+ ** constructors.<P>\n+ **\n+ ** <STRONG>Documentation Convention:</STRONG> for proper\n+ ** Internalization of Beans inside an RAD tool, sometimes there\n+ ** are two names for a property or method: a programmatic, or\n+ ** locale-independent name, which can be used anywhere, and a\n+ ** localized, display name, for ease of use.  In the\n+ ** documentation I will specify different String values as\n+ ** either <EM>programmatic</EM> or <EM>localized</EM> to\n+ ** make this distinction clear.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 31 May 1998\n+ **/\n+\n+public class EventSetDescriptor extends FeatureDescriptor {\n+\tprivate Method addListenerMethod;\n+\tprivate Method removeListenerMethod;\n+\tprivate Class listenerType;\n+\tprivate MethodDescriptor[] listenerMethodDescriptors;\n+\tprivate Method[] listenerMethods;\n+\n+\tprivate boolean unicast;\n+\tprivate boolean inDefaultEventSet = true;\n+\n+\t/** Create a new EventSetDescriptor.\n+\t ** This version of the constructor enforces the rules imposed on the methods\n+\t ** described at the top of this class, as well as searching for:<P>\n+\t ** <OL>\n+\t ** <LI>The event-firing method must be non-private with signature\n+\t ** <CODE>void &lt;listenerMethodName&gt;(&lt;eventSetName&gt;Event)</CODE>\n+\t ** (where <CODE>&lt;eventSetName&gt;</CODE> has its first character capitalized\n+\t ** by the constructor and the Event is a descendant of\n+\t ** <CODE>java.util.EventObject</CODE>) in class <CODE>listenerType</CODE>\n+\t ** (any exceptions may be thrown).\n+\t ** <B>Implementation note:</B> Note that there could conceivably be multiple\n+\t ** methods with this type of signature (example: java.util.MouseEvent vs.\n+\t ** my.very.own.MouseEvent).  In this implementation, all methods fitting the\n+\t ** description will be put into the <CODE>EventSetDescriptor</CODE>, even\n+\t ** though the spec says only one should be chosen (they probably weren't thinking as\n+\t ** pathologically as I was).  I don't like arbitrarily choosing things.\n+\t ** If your class has only one such signature, as most do, you'll have no problems.</LI>\n+\t ** <LI>The add and remove methods must be public and named\n+\t ** <CODE>void add&lt;eventSetName&gt;Listener(&lt;listenerType&gt;)</CODE> and\n+\t ** <CODE>void remove&lt;eventSetName&gt;Listener(&lt;listenerType&gt;)</CODE> in\n+\t ** in class <CODE>eventSourceClass</CODE>, where\n+\t ** <CODE>&lt;eventSetName&gt;</CODE> will have its first letter capitalized.\n+\t ** Standard exception rules (see class description) apply.</LI>\n+\t ** </OL>\n+\t ** @param eventSourceClass the class containing the add/remove listener methods.\n+\t ** @param eventSetName the programmatic name of the event set, generally starting\n+\t ** with a lowercase letter (i.e. fooManChu instead of FooManChu).  This will be used\n+\t ** to generate the name of the event object as well as the names of the add and\n+\t ** remove methods.\n+\t ** @param listenerType the class containing the event firing method.\n+\t ** @param listenerMethodName the name of the event firing method.\n+\t ** @exception IntrospectionException if listenerType is not an EventListener,\n+\t **                                   or if methods are not found or are invalid.\n+\t **/\n+\tpublic EventSetDescriptor(Class  eventSourceClass,\n+\t\t\t\t  String eventSetName,\n+\t\t\t\t  Class  listenerType,\n+\t\t\t\t  String listenerMethodName) throws IntrospectionException {\n+\t\tsetName(eventSetName);\n+\t\tif(!java.util.EventListener.class.isAssignableFrom(listenerType)) {\n+\t\t\tthrow new IntrospectionException(\"Listener type is not an EventListener.\");\n+\t\t}\n+\n+\t\tString[] names = new String[1];\n+\t\tnames[0] = listenerMethodName;\n+\n+\t\ttry {\n+\t\t\teventSetName = Character.toUpperCase(eventSetName.charAt(0)) + eventSetName.substring(1);\n+\t\t} catch(StringIndexOutOfBoundsException e) {\n+\t\t\teventSetName = \"\";\n+\t\t}\n+\n+\t\tfindMethods(eventSourceClass,listenerType,names,\"add\"+eventSetName+\"Listener\",\"remove\"+eventSetName+\"Listener\",eventSetName+\"Event\");\n+\t\tthis.listenerType = listenerType;\n+\t\tcheckAddListenerUnicast();\n+\t\tif(this.removeListenerMethod.getExceptionTypes().length > 0) {\n+\t\t\tthrow new IntrospectionException(\"Listener remove method throws exceptions.\");\n+\t\t}\n+\t}\n+\n+\t/** Create a new EventSetDescriptor.\n+\t ** This form of the constructor allows you to specify the names of the methods and adds\n+\t ** no new constraints on top of the rules already described at the top of the class.<P>\n+\t ** \n+\t ** @param eventSourceClass the class containing the add and remove listener methods.\n+\t ** @param eventSetName the programmatic name of the event set, generally starting\n+\t ** with a lowercase letter (i.e. fooManChu instead of FooManChu).\n+\t ** @param listenerType the class containing the event firing methods.\n+\t ** @param listenerMethodNames the names of the even firing methods.\n+\t ** @param addListenerMethodName the name of the add listener method.\n+\t ** @param removeListenerMethodName the name of the remove listener method.\n+\t ** @exception IntrospectionException if listenerType is not an EventListener\n+\t **                                   or if methods are not found or are invalid.\n+\t **/\n+\tpublic EventSetDescriptor(Class eventSourceClass,\n+\t\t\t\t   String eventSetName,\n+\t\t\t\t   Class listenerType,\n+\t\t\t\t   String[] listenerMethodNames,\n+\t\t\t\t   String addListenerMethodName,\n+\t\t\t\t   String removeListenerMethodName) throws IntrospectionException {\n+\t\tsetName(eventSetName);\n+\t\tif(!java.util.EventListener.class.isAssignableFrom(listenerType)) {\n+\t\t\tthrow new IntrospectionException(\"Listener type is not an EventListener.\");\n+\t\t}\n+\n+\t\tfindMethods(eventSourceClass,listenerType,listenerMethodNames,addListenerMethodName,removeListenerMethodName,null);\n+\t\tthis.listenerType = listenerType;\n+\t\tcheckAddListenerUnicast();\n+\t\tif(this.removeListenerMethod.getExceptionTypes().length > 0) {\n+\t\t\tthrow new IntrospectionException(\"Listener remove method throws exceptions.\");\n+\t\t}\n+\t}\n+\n+\t/** Create a new EventSetDescriptor.\n+\t ** This form of constructor allows you to explicitly say which methods do what, and\n+\t ** no reflection is done by the EventSetDescriptor.  The methods are, however,\n+\t ** checked to ensure that they follow the rules set forth at the top of the class.\n+\t ** @param eventSetName the programmatic name of the event set, generally starting\n+\t ** with a lowercase letter (i.e. fooManChu instead of FooManChu).\n+\t ** @param listenerType the class containing the listenerMethods.\n+\t ** @param listenerMethods the event firing methods.\n+\t ** @param addListenerMethod the add listener method.\n+\t ** @param removeListenerMethod the remove listener method.\n+\t ** @exception IntrospectionException if the listenerType is not an EventListener,\n+\t **                                   or any of the methods are invalid.\n+\t **/\n+\tpublic EventSetDescriptor(String eventSetName,\n+\t\t\t\t   Class listenerType,\n+\t\t\t\t   Method[] listenerMethods,\n+\t\t\t\t   Method addListenerMethod,\n+\t\t\t\t   Method removeListenerMethod) throws IntrospectionException {\n+\t\tsetName(eventSetName);\n+\t\tif(!java.util.EventListener.class.isAssignableFrom(listenerType)) {\n+\t\t\tthrow new IntrospectionException(\"Listener type is not an EventListener.\");\n+\t\t}\n+\n+\t        this.listenerMethods = listenerMethods;\n+\t\tthis.addListenerMethod = addListenerMethod;\n+\t\tthis.removeListenerMethod = removeListenerMethod;\n+\t\tthis.listenerType = listenerType;\n+\t\tcheckMethods();\n+\t\tcheckAddListenerUnicast();\n+\t\tif(this.removeListenerMethod.getExceptionTypes().length > 0) {\n+\t\t\tthrow new IntrospectionException(\"Listener remove method throws exceptions.\");\n+\t\t}\n+\t}\n+\n+\t/** Create a new EventSetDescriptor.\n+\t ** This form of constructor allows you to explicitly say which methods do what, and\n+\t ** no reflection is done by the EventSetDescriptor.  The methods are, however,\n+\t ** checked to ensure that they follow the rules set forth at the top of the class.\n+\t ** @param eventSetName the programmatic name of the event set, generally starting\n+\t ** with a lowercase letter (i.e. fooManChu instead of FooManChu).\n+\t ** @param listenerType the class containing the listenerMethods.\n+\t ** @param listenerMethodDescriptors the event firing methods.\n+\t ** @param addListenerMethod the add listener method.\n+\t ** @param removeListenerMethod the remove listener method.\n+\t ** @exception IntrospectionException if the listenerType is not an EventListener,\n+\t **                                   or any of the methods are invalid.\n+\t **/\n+\tpublic EventSetDescriptor(String eventSetName,\n+\t\t\t\t   Class listenerType,\n+\t\t\t\t   MethodDescriptor[] listenerMethodDescriptors,\n+\t\t\t\t   Method addListenerMethod,\n+\t\t\t\t   Method removeListenerMethod) throws IntrospectionException {\n+\t\tsetName(eventSetName);\n+\t\tif(!java.util.EventListener.class.isAssignableFrom(listenerType)) {\n+\t\t\tthrow new IntrospectionException(\"Listener type is not an EventListener.\");\n+\t\t}\n+\n+\t\tthis.listenerMethodDescriptors = listenerMethodDescriptors;\n+\t\tthis.listenerMethods = new Method[listenerMethodDescriptors.length];\n+\t\tfor(int i=0;i<this.listenerMethodDescriptors.length;i++) {\n+\t\t\tthis.listenerMethods[i] = this.listenerMethodDescriptors[i].getMethod();\n+\t\t}\n+\n+\t\tthis.addListenerMethod = addListenerMethod;\n+\t\tthis.removeListenerMethod = removeListenerMethod;\n+\t\tthis.listenerType = listenerType;\n+\t\tcheckMethods();\n+\t\tcheckAddListenerUnicast();\n+\t\tif(this.removeListenerMethod.getExceptionTypes().length > 0) {\n+\t\t\tthrow new IntrospectionException(\"Listener remove method throws exceptions.\");\n+\t\t}\n+\t}\n+\n+\t/** Get the class that contains the event firing methods. **/\n+\tpublic Class getListenerType() {\n+\t\treturn listenerType;\n+\t}\n+\n+\t/** Get the event firing methods. **/\n+\tpublic Method[] getListenerMethods() {\n+\t\treturn listenerMethods;\n+\t}\n+\n+\t/** Get the event firing methods as MethodDescriptors. **/\n+\tpublic MethodDescriptor[] getListenerMethodDescriptors() {\n+\t\tif(listenerMethodDescriptors == null) {\n+\t\t\tlistenerMethodDescriptors = new MethodDescriptor[listenerMethods.length];\n+\t\t\tfor(int i=0;i<listenerMethods.length;i++) {\n+\t\t\t\tlistenerMethodDescriptors[i] = new MethodDescriptor(listenerMethods[i]);\n+\t\t\t}\n+\t\t}\n+\t\treturn listenerMethodDescriptors;\n+\t}\n+\n+\t/** Get the add listener method. **/\n+\tpublic Method getAddListenerMethod() {\n+\t\treturn addListenerMethod;\n+\t}\n+\n+\t/** Get the remove listener method. **/\n+\tpublic Method getRemoveListenerMethod() {\n+\t\treturn removeListenerMethod;\n+\t}\n+\n+\t/** Set whether or not multiple listeners may be added.\n+\t ** @param unicast whether or not multiple listeners may be added.\n+\t **/\n+\tpublic void setUnicast(boolean unicast) {\n+\t\tthis.unicast = unicast;\n+\t}\n+\n+\t/** Get whether or not multiple listeners may be added.  (Defaults to false.) **/\n+\tpublic boolean isUnicast() {\n+\t\treturn unicast;\n+\t}\n+\n+\t/** Set whether or not this is in the default event set.\n+\t ** @param inDefaultEventSet whether this is in the default event set.\n+\t **/\n+\tpublic void setInDefaultEventSet(boolean inDefaultEventSet) {\n+\t\tthis.inDefaultEventSet = inDefaultEventSet;\n+\t}\n+\n+\t/** Get whether or not this is in the default event set.  (Defaults to true.)**/\n+\tpublic boolean isInDefaultEventSet() {\n+\t\treturn inDefaultEventSet;\n+\t}\n+\n+\tprivate void checkAddListenerUnicast() throws IntrospectionException {\n+\t\tClass[] addListenerExceptions = this.addListenerMethod.getExceptionTypes();\n+\t\tif(addListenerExceptions.length > 1) {\n+\t\t\tthrow new IntrospectionException(\"Listener add method throws too many exceptions.\");\n+\t\t} else if(addListenerExceptions.length == 1\n+\t\t\t  && !java.util.TooManyListenersException.class.isAssignableFrom(addListenerExceptions[0])) {\n+\t\t\tthrow new IntrospectionException(\"Listener add method throws too many exceptions.\");\n+\t\t}\n+\t}\n+\n+\tprivate void checkMethods() throws IntrospectionException {\n+\t\tif(!addListenerMethod.getDeclaringClass().isAssignableFrom(removeListenerMethod.getDeclaringClass())\n+\t\t   && !removeListenerMethod.getDeclaringClass().isAssignableFrom(addListenerMethod.getDeclaringClass())) {\n+\t\t\tthrow new IntrospectionException(\"add and remove listener methods do not come from the same class.  This is bad.\");\n+\t\t}\n+\t\tif(!addListenerMethod.getReturnType().equals(java.lang.Void.TYPE)\n+                   || addListenerMethod.getParameterTypes().length != 1\n+\t\t   || !listenerType.equals(addListenerMethod.getParameterTypes()[0])\n+\t\t   || !Modifier.isPublic(addListenerMethod.getModifiers())) {\n+\t\t\tthrow new IntrospectionException(\"Add Listener Method invalid.\");\n+\t\t}\n+\t\tif(!removeListenerMethod.getReturnType().equals(java.lang.Void.TYPE)\n+                   || removeListenerMethod.getParameterTypes().length != 1\n+\t\t   || !listenerType.equals(removeListenerMethod.getParameterTypes()[0])\n+\t\t   || removeListenerMethod.getExceptionTypes().length > 0\n+\t\t   || !Modifier.isPublic(removeListenerMethod.getModifiers())) {\n+\t\t\tthrow new IntrospectionException(\"Remove Listener Method invalid.\");\n+\t\t}\n+\n+\t\tfor(int i=0;i<listenerMethods.length;i++) {\n+\t\t\tif(!listenerMethods[i].getReturnType().equals(java.lang.Void.TYPE)\n+\t\t\t   || Modifier.isPrivate(listenerMethods[i].getModifiers())) {\n+\t\t\t\tthrow new IntrospectionException(\"Event Method \" + listenerMethods[i].getName() + \" non-void or private.\");\n+\t\t\t}\n+\t\t\tif(!listenerMethods[i].getDeclaringClass().isAssignableFrom(listenerType)) {\n+\t\t\t\tthrow new IntrospectionException(\"Event Method \" + listenerMethods[i].getName() + \" not from class \" + listenerType.getName());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void findMethods(Class eventSourceClass,\n+\t\tClass listenerType,\n+\t\tString listenerMethodNames[],\n+\t\tString addListenerMethodName,\n+\t\tString removeListenerMethodName,\n+\t\tString absurdEventClassCheckName) throws IntrospectionException {\n+\n+\t\t/* Find add listener method and remove listener method. */\n+\t\tClass[] listenerArgList = new Class[1];\n+\t\tlistenerArgList[0] = listenerType;\n+\t\ttry {\n+\t\t\tthis.addListenerMethod = eventSourceClass.getMethod(addListenerMethodName,listenerArgList);\n+\t\t} catch(SecurityException E) {\n+\t\t\tthrow new IntrospectionException(\"SecurityException trying to access method \" + addListenerMethodName + \".\");\n+\t\t} catch(NoSuchMethodException E) {\n+\t\t\tthrow new IntrospectionException(\"Could not find method \" + addListenerMethodName + \".\");\n+\t\t}\n+\n+\t\tif(this.addListenerMethod == null || !this.addListenerMethod.getReturnType().equals(java.lang.Void.TYPE)) {\n+\t\t\tthrow new IntrospectionException(\"Add listener method does not exist, is not public, or is not void.\");\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tthis.removeListenerMethod = eventSourceClass.getMethod(removeListenerMethodName,listenerArgList);\n+\t\t} catch(SecurityException E) {\n+\t\t\tthrow new IntrospectionException(\"SecurityException trying to access method \" + removeListenerMethodName + \".\");\n+\t\t} catch(NoSuchMethodException E) {\n+\t\t\tthrow new IntrospectionException(\"Could not find method \" + removeListenerMethodName + \".\");\n+\t\t}\n+\t\tif(this.removeListenerMethod == null || !this.removeListenerMethod.getReturnType().equals(java.lang.Void.TYPE)) {\n+\t\t\tthrow new IntrospectionException(\"Remove listener method does not exist, is not public, or is not void.\");\n+\t\t}\n+\n+\t\t/* Find the listener methods. */\n+\t\tMethod[] methods;\n+\t\ttry {\n+\t\t\tmethods = ClassHelper.getAllMethods(listenerType);\n+\t\t} catch(SecurityException E) {\n+\t\t\tthrow new IntrospectionException(\"Security: You cannot access fields in this class.\");\n+\t\t}\n+\n+\t\tVector chosenMethods = new Vector();\n+\t\tboolean[] listenerMethodFound = new boolean[listenerMethodNames.length];\n+\t\tfor(int i=0;i<methods.length;i++) {\n+\t\t\tif(Modifier.isPrivate(methods[i].getModifiers())) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tMethod currentMethod = methods[i];\n+\t\t\tClass retval = currentMethod.getReturnType();\n+\t\t\tif(retval.equals(java.lang.Void.TYPE)) {\n+\t\t\t\tfor(int j=0;j<listenerMethodNames.length;j++) {\n+\t\t\t\t\tif(currentMethod.getName().equals(listenerMethodNames[j])\n+\t\t\t\t\t   && (absurdEventClassCheckName == null\n+\t\t\t\t\t       || (currentMethod.getParameterTypes().length == 1\n+\t\t\t\t\t           && ((currentMethod.getParameterTypes()[0]).getName().equals(absurdEventClassCheckName)\n+\t\t\t\t\t               || (currentMethod.getParameterTypes()[0]).getName().endsWith(\".\"+absurdEventClassCheckName)\n+\t\t\t\t\t              )\n+\t\t\t\t\t          )\n+\t\t\t\t\t      )\n+\t\t\t\t\t  ) {\n+\t\t\t\t\t\tchosenMethods.addElement(currentMethod);\n+\t\t\t\t\t\tlistenerMethodFound[j] = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* Make sure we found all the methods we were looking for. */\n+\t\tfor(int i=0;i<listenerMethodFound.length;i++) {\n+\t\t\tif(!listenerMethodFound[i]) {\n+\t\t\t\tthrow new IntrospectionException(\"Could not find event method \" + listenerMethodNames[i]);\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* Now that we've chosen the listener methods we want, store them. */\n+\t\tthis.listenerMethods = new Method[chosenMethods.size()];\n+\t\tfor(int i=0;i<chosenMethods.size();i++) {\n+\t\t\tthis.listenerMethods[i] = (Method)chosenMethods.elementAt(i);\n+\t\t}\n+\t}\n+}"}, {"sha": "102a3a327cdded0c03f08dc1cb0549cf84b793d3", "filename": "libjava/java/beans/FeatureDescriptor.java", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FFeatureDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FFeatureDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FFeatureDescriptor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,155 @@\n+/* java.beans.FeatureDescriptor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+import java.util.*;\n+\n+/**\n+ ** FeatureDescriptor is the common superclass for all JavaBeans Descriptor classes.\n+ ** JavaBeans descriptors are abstract descriptors of properties,\n+ ** events, methods, beans, etc.<P>\n+ **\n+ ** <STRONG>Documentation Convention:</STRONG> for proper\n+ ** Internalization of Beans inside an RAD tool, sometimes there\n+ ** are two names for a property or method: a programmatic, or\n+ ** locale-independent name, which can be used anywhere, and a\n+ ** localized, display name, for ease of use.  In the\n+ ** documentation I will specify different String values as\n+ ** either <EM>programmatic</EM> or <EM>localized</EM> to\n+ ** make this distinction clear.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 31 May 1998\n+ **/\n+\n+public class FeatureDescriptor {\n+\tString name;\n+\tString displayName;\n+\tString shortDescription;\n+\tboolean expert;\n+\tboolean hidden;\n+\n+\tHashtable valueHash;\n+\n+\t/** Instantiate this FeatureDescriptor with appropriate default values.**/\n+\tpublic FeatureDescriptor() {\n+\t\tvalueHash = new Hashtable();\n+\t}\n+\n+\t/** Get the programmatic name of this feature. **/\n+\tpublic String getName() {\n+\t\treturn name;\n+\t}\n+\n+\t/** Set the programmatic name of this feature.\n+\t ** @param name the new name for this feature.\n+\t **/\n+\tpublic void setName(String name) {\n+\t\tthis.name = name;\n+\t}\n+\n+\t/** Get the localized (display) name of this feature. **/\n+\tpublic String getDisplayName() {\n+\t\treturn displayName;\n+\t}\n+\n+\t/** Set the localized (display) name of this feature.\n+\t ** @param displayName the new display name for this feature.\n+\t **/\n+\tpublic void setDisplayName(String displayName) {\n+\t\tthis.displayName = displayName;\n+\t}\n+\n+\t/** Get the localized short description for this feature. **/\n+\tpublic String getShortDescription() {\n+\t\treturn shortDescription;\n+\t}\n+\n+\t/** Set the localized short description for this feature.\n+\t ** @param shortDescription the new short description for this feature.\n+\t **/\n+\tpublic void setShortDescription(String shortDescription) {\n+\t\tthis.shortDescription = shortDescription;\n+\t}\n+\n+\t/** Indicates whether this feature is for expert use only.\n+\t ** @return true if for use by experts only, or false if anyone can use it.\n+\t **/\n+\tpublic boolean isExpert() {\n+\t\treturn expert;\n+\t}\n+\n+\t/** Set whether this feature is for expert use only.\n+\t ** @param expert true if for use by experts only, or false if anyone can use it.\n+\t **/\n+\tpublic void setExpert(boolean expert) {\n+\t\tthis.expert = expert;\n+\t}\n+\n+\t/** Indicates whether this feature is for use by tools only.\n+\t ** If it is for use by tools only, then it should not be displayed.\n+\t ** @return true if tools only should use it, or false if anyone can see it.\n+\t **/\n+\tpublic boolean isHidden() {\n+\t\treturn hidden;\n+\t}\n+\n+\t/** Set whether this feature is for use by tools only.\n+\t ** If it is for use by tools only, then it should not be displayed.\n+\t ** @param hidden true if tools only should use it, or false if anyone can see it.\n+\t **/\n+\tpublic void setHidden(boolean hidden) {\n+\t\tthis.hidden = hidden;\n+\t}\n+\n+\n+\t/** Get an arbitrary value set with setValue().\n+\t ** @param name the programmatic name of the key.\n+\t ** @return the value associated with this name, or null if there is none.\n+\t **/\n+\tpublic Object getValue(String name) {\n+\t\treturn valueHash.get(name);\n+\t}\n+\n+\t/** Set an arbitrary string-value pair with this feature.\n+\t ** @param name the programmatic name of the key.\n+\t ** @param value the value to associate with the name.\n+\t **/\n+\tpublic void setValue(String name, Object value) {\n+\t\tvalueHash.put(name, value);\n+\t}\n+\n+\t/** Get a list of the programmatic key names set with setValue().\n+\t ** @return an Enumerator over all the programmatic key names associated\n+\t ** with this feature.\n+\t **/\n+\tpublic Enumeration attributeNames() {\n+\t\treturn valueHash.keys();\n+\t}\n+}"}, {"sha": "daf8441ec6bc54c8723f41b5f0b84905768dec4a", "filename": "libjava/java/beans/IndexedPropertyDescriptor.java", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FIndexedPropertyDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FIndexedPropertyDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FIndexedPropertyDescriptor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,296 @@\n+/* java.beans.IndexedPropertyDescriptor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+\n+/**\n+ ** IndexedPropertyDescriptor describes information about a JavaBean\n+ ** indexed property, by which we mean an array-like property that\n+ ** has been exposed via a pair of get and set methods and another\n+ ** pair that allows you to get to the property by an index.<P>\n+ **\n+ ** An example property would have four methods like this:<P>\n+ ** <CODE>FooBar[] getFoo()</CODE><BR>\n+ ** <CODE>void setFoo(FooBar[])</CODE><BR>\n+ ** <CODE>FooBar getFoo(int)</CODE><BR>\n+ ** <CODE>void setFoo(int,FooBar)</CODE><P>\n+ **\n+ ** The constraints put on get and set methods are:<P>\n+ ** <OL>\n+ ** <LI>There must be at least a get(int) or a set(int,...) method.\n+ ** Nothing else is required.  <B>Spec note:</B>One nice restriction\n+ ** would be that if there is a get() there must be a get(int), same\n+ ** with set, but that is not in the spec and is fairly harmless.)</LI>\n+ ** <LI>A get array method must have signature\n+ **     <CODE>&lt;propertyType&gt;[] &lt;getMethodName&gt;()</CODE></LI>\n+ ** <LI>A set array method must have signature\n+ **     <CODE>void &lt;setMethodName&gt;(&lt;propertyType&gt;[])</CODE></LI>\n+ ** <LI>A get index method must have signature\n+ **     <CODE>&lt;propertyType&gt; &lt;getMethodName&gt;(int)</CODE></LI>\n+ ** <LI>A set index method must have signature\n+ **     <CODE>void &lt;setMethodName&gt;(int,&lt;propertyType&gt;)</CODE></LI>\n+ ** <LI>All these methods may throw any exception.</LI>\n+ ** <LI>All these methods must be public.</LI>\n+ ** </OL>\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 26 Jul 1998\n+ **/\n+\n+public class IndexedPropertyDescriptor extends PropertyDescriptor {\n+\tprivate Class indexedPropertyType;\n+\tprivate Method setIndex;\n+\tprivate Method getIndex;\n+\n+\t/** Create a new IndexedPropertyDescriptor by introspection.\n+\t ** This form of constructor creates the PropertyDescriptor by\n+\t ** looking for getter methods named <CODE>get&lt;name&gt;()</CODE>\n+\t ** and setter methods named\n+\t ** <CODE>set&lt;name&gt;()</CODE> in class\n+\t ** <CODE>&lt;beanClass&gt;</CODE>, where &lt;name&gt; has its\n+\t ** first letter capitalized by the constructor.<P>\n+\t **\n+\t ** <B>Implementation note:</B> If there is a get(int) method,\n+\t ** then the return type of that method is used to find the\n+\t ** remaining methods.  If there is no get method, then the\n+\t ** set(int) method is searched for exhaustively and that type\n+\t ** is used to find the others.<P>\n+\t **\n+\t ** <B>Spec note:</B>\n+\t ** If there is no get(int) method and multiple set(int) methods with\n+\t ** the same name and the correct parameters (different type of course),\n+\t ** then an IntrospectionException is thrown.  While Sun's spec\n+\t ** does not state this, it can make Bean behavior different on\n+\t ** different systems (since method order is not guaranteed) and as\n+\t ** such, can be treated as a bug in the spec.  I am not aware of\n+\t ** whether Sun's implementation catches this.\n+\t **\n+\t ** @param name the programmatic name of the property, usually\n+\t **             starting with a lowercase letter (e.g. fooManChu\n+\t **             instead of FooManChu).\n+\t ** @param beanClass the class the get and set methods live in.\n+\t ** @exception IntrospectionException if the methods are not found or invalid.\n+\t **/\n+\tpublic IndexedPropertyDescriptor(String name, Class beanClass) throws IntrospectionException {\n+\t\tsuper(name);\n+\t\tString capitalized;\n+\t\ttry {\n+\t\t\tcapitalized = Character.toUpperCase(name.charAt(0)) + name.substring(1);\n+\t\t} catch(StringIndexOutOfBoundsException e) {\n+\t\t\tcapitalized = \"\";\n+\t\t}\n+\t\tfindMethods(beanClass, \"get\" + capitalized, \"set\" + capitalized, \"get\" + capitalized, \"set\" + capitalized);\n+\t}\n+\n+\t/** Create a new IndexedPropertyDescriptor by introspection.\n+\t ** This form of constructor allows you to specify the\n+\t ** names of the get and set methods to search for.<P>\n+\t **\n+\t ** <B>Implementation note:</B> If there is a get(int) method,\n+\t ** then the return type of that method is used to find the\n+\t ** remaining methods.  If there is no get method, then the\n+\t ** set(int) method is searched for exhaustively and that type\n+\t ** is used to find the others.<P>\n+\t **\n+\t ** <B>Spec note:</B>\n+\t ** If there is no get(int) method and multiple set(int) methods with\n+\t ** the same name and the correct parameters (different type of course),\n+\t ** then an IntrospectionException is thrown.  While Sun's spec\n+\t ** does not state this, it can make Bean behavior different on\n+\t ** different systems (since method order is not guaranteed) and as\n+\t ** such, can be treated as a bug in the spec.  I am not aware of\n+\t ** whether Sun's implementation catches this.\n+\t **\n+\t ** @param name the programmatic name of the property, usually\n+\t **             starting with a lowercase letter (e.g. fooManChu\n+\t **             instead of FooManChu).\n+\t ** @param beanClass the class the get and set methods live in.\n+\t ** @param getMethodName the name of the get array method.\n+\t ** @param setMethodName the name of the set array method.\n+\t ** @param getIndexName the name of the get index method.\n+\t ** @param setIndexName the name of the set index method.\n+\t ** @exception IntrospectionException if the methods are not found or invalid.\n+\t **/\n+\tpublic IndexedPropertyDescriptor(String name, Class beanClass, String getMethodName, String setMethodName, String getIndexName, String setIndexName) throws IntrospectionException {\n+\t\tsuper(name);\n+\t\tfindMethods(beanClass, getMethodName, setMethodName, getIndexName, setIndexName);\n+\t}\n+\n+\t/** Create a new PropertyDescriptor using explicit Methods.\n+\t ** Note that the methods will be checked for conformance to standard\n+\t ** Property method rules, as described above at the top of this class.\n+\t ** \n+\t ** @param name the programmatic name of the property, usually\n+\t **             starting with a lowercase letter (e.g. fooManChu\n+\t **             instead of FooManChu).\n+\t ** @param getMethod the get array method.\n+\t ** @param setMethod the set array method.\n+\t ** @param getIndex the get index method.\n+\t ** @param setIndex the set index method.\n+\t ** @exception IntrospectionException if the methods are not found or invalid.\n+\t **/\n+\tpublic IndexedPropertyDescriptor(String name, Method getMethod, Method setMethod, Method getIndex, Method setIndex) throws IntrospectionException {\n+\t\tsuper(name);\n+\t\tif(getMethod != null && getMethod.getParameterTypes().length > 0) {\n+\t\t\tthrow new IntrospectionException(\"get method has parameters\");\n+\t\t}\n+\t\tif(getMethod != null && setMethod.getParameterTypes().length != 1) {\n+\t\t\tthrow new IntrospectionException(\"set method does not have exactly one parameter\");\n+\t\t}\n+\t\tif(getMethod != null && setMethod != null) {\n+\t\t\tif(!getMethod.getReturnType().equals(setMethod.getParameterTypes()[0])) {\n+\t\t\t\tthrow new IntrospectionException(\"set and get methods do not share the same type\");\n+\t\t\t}\n+\t\t\tif(!getMethod.getDeclaringClass().isAssignableFrom(setMethod.getDeclaringClass())\n+\t\t\t   && !setMethod.getDeclaringClass().isAssignableFrom(getMethod.getDeclaringClass())) {\n+\t\t\t\tthrow new IntrospectionException(\"set and get methods are not in the same class.\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tif(getIndex != null && (getIndex.getParameterTypes().length != 1\n+\t\t   || !(getIndex.getParameterTypes()[0]).equals(java.lang.Integer.TYPE))) {\n+\t\t\tthrow new IntrospectionException(\"get index method has wrong parameters\");\n+\t\t}\n+\t\tif(setIndex != null && (setIndex.getParameterTypes().length != 2\n+\t\t   || !(setIndex.getParameterTypes()[0]).equals(java.lang.Integer.TYPE))) {\n+\t\t\tthrow new IntrospectionException(\"set index method has wrong parameters\");\n+\t\t}\n+\t\tif(getIndex != null && setIndex != null) {\n+\t\t\tif(!getIndex.getReturnType().equals(setIndex.getParameterTypes()[1])) {\n+\t\t\t\tthrow new IntrospectionException(\"set index methods do not share the same type\");\n+\t\t\t}\n+\t\t\tif(!getIndex.getDeclaringClass().isAssignableFrom(setIndex.getDeclaringClass())\n+\t\t\t   && !setIndex.getDeclaringClass().isAssignableFrom(getIndex.getDeclaringClass())) {\n+\t\t\t\tthrow new IntrospectionException(\"get and set index methods are not in the same class.\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tif(getIndex != null && getMethod != null && !getIndex.getDeclaringClass().isAssignableFrom(getMethod.getDeclaringClass())\n+\t\t   && !getMethod.getDeclaringClass().isAssignableFrom(getIndex.getDeclaringClass())) {\n+\t\t\tthrow new IntrospectionException(\"methods are not in the same class.\");\n+\t\t}\n+\n+\t\tif(getIndex != null && getMethod != null && !Array.newInstance(getIndex.getReturnType(),0).getClass().equals(getMethod.getReturnType())) {\n+\t\t\tthrow new IntrospectionException(\"array methods do not match index methods.\");\n+\t\t}\n+\n+\t\tthis.getMethod = getMethod;\n+\t\tthis.setMethod = setMethod;\n+\t\tthis.getIndex = getIndex;\n+\t\tthis.setIndex = getIndex;\n+\t\tthis.indexedPropertyType = getIndex != null ? getIndex.getReturnType() : setIndex.getParameterTypes()[1];\n+\t\tthis.propertyType = getMethod != null ? getMethod.getReturnType() : (setMethod != null ? setMethod.getParameterTypes()[0] : Array.newInstance(this.indexedPropertyType,0).getClass());\n+\t}\n+\n+\tpublic Class getIndexedPropertyType() {\n+\t\treturn indexedPropertyType;\n+\t}\n+\n+\tpublic Method getIndexedReadMethod() {\n+\t\treturn getIndex;\n+\t}\n+\n+\tpublic Method getIndexedWriteMethod() {\n+\t\treturn setIndex;\n+\t}\n+\n+\tprivate void findMethods(Class beanClass, String getMethodName, String setMethodName, String getIndexName, String setIndexName) throws IntrospectionException {\n+\t\ttry {\n+\t\t\tif(getIndexName != null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tClass[] getArgs = new Class[1];\n+\t\t\t\t\tgetArgs[0] = java.lang.Integer.TYPE;\n+\t\t\t\t\tgetIndex = beanClass.getMethod(getIndexName,getArgs);\n+\t\t\t\t\tindexedPropertyType = getIndex.getReturnType();\n+\t\t\t\t} catch(NoSuchMethodException E) {\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(getIndex != null) {\n+\t\t\t\tif(setIndexName != null) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tClass[] setArgs = new Class[2];\n+\t\t\t\t\t\tsetArgs[0] = java.lang.Integer.TYPE;\n+\t\t\t\t\t\tsetArgs[1] = indexedPropertyType;\n+\t\t\t\t\t\tsetIndex = beanClass.getMethod(setIndexName,setArgs);\n+\t\t\t\t\t\tif(!setIndex.getReturnType().equals(java.lang.Void.TYPE)) {\n+\t\t\t\t\t\t\tthrow new IntrospectionException(setIndexName + \" has non-void return type\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} catch(NoSuchMethodException E) {\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if(setIndexName != null) {\n+\t\t\t\tMethod[] m = beanClass.getMethods();\n+\t\t\t\tfor(int i=0;i<m.length;i++) {\n+\t\t\t\t\tMethod current = m[i];\n+\t\t\t\t\tif(current.getName().equals(setIndexName)\n+\t\t\t\t\t   && current.getParameterTypes().length == 2\n+\t\t\t\t\t   && (current.getParameterTypes()[0]).equals(java.lang.Integer.TYPE)\n+\t\t\t\t\t   && current.getReturnType().equals(java.lang.Void.TYPE)) {\n+\t\t\t\t\t\tif(setIndex != null) {\n+\t\t\t\t\t\t\tthrow new IntrospectionException(\"Multiple, different set methods found that fit the bill!\");\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tsetIndex = current;\n+\t\t\t\t\t\t\tindexedPropertyType = current.getParameterTypes()[1];\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif(setIndex == null) {\n+\t\t\t\t\tthrow new IntrospectionException(\"Cannot find get or set methods.\");\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tthrow new IntrospectionException(\"Cannot find get or set methods.\");\n+\t\t\t}\n+\n+\t\t\tClass arrayType = Array.newInstance(indexedPropertyType,0).getClass();\n+\n+\t\t\tClass[] setArgs = new Class[1];\n+\t\t\tsetArgs[0] = arrayType;\n+\t\t\ttry {\n+\t\t\t\tsetMethod = beanClass.getMethod(setMethodName,setArgs);\n+\t\t\t\tif(!setMethod.getReturnType().equals(java.lang.Void.TYPE)) {\n+\t\t\t\t\tsetMethod = null;\n+\t\t\t\t}\n+\t\t\t} catch(NoSuchMethodException E) {\n+\t\t\t}\n+\n+\t\t\tClass[] getArgs = new Class[0];\n+\t\t\ttry {\n+\t\t\t\tgetMethod = beanClass.getMethod(getMethodName,getArgs);\n+\t\t\t\tif(!getMethod.getReturnType().equals(arrayType)) {\n+\t\t\t\t\tgetMethod = null;\n+\t\t\t\t}\n+\t\t\t} catch(NoSuchMethodException E) {\n+\t\t\t}\n+\t\t} catch(SecurityException E) {\n+\t\t\tthrow new IntrospectionException(\"SecurityException while trying to find methods.\");\n+\t\t}\n+\t}\n+}"}, {"sha": "0bbd579ef9252e57e92eaed6d86977b7c814d016", "filename": "libjava/java/beans/IntrospectionException.java", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FIntrospectionException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FIntrospectionException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FIntrospectionException.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,46 @@\n+/* java.beans.IntrospectionException\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/**\n+ ** IntrospectionException is thrown when the Introspector fails.  Surprise, surprise.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 31 May 1998\n+ ** @see java.beans.Introspector\n+ **/\n+\n+public class IntrospectionException extends Exception {\n+\t/** Instantiate this exception with the given message.\n+\t ** @param msg the message for the exception.\n+\t **/\n+\tpublic IntrospectionException(String msg) {\n+\t\tsuper(msg);\n+\t}\n+}"}, {"sha": "a1919714a1cb5778a3282b5923a554d0c599dc56", "filename": "libjava/java/beans/Introspector.java", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FIntrospector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FIntrospector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FIntrospector.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,427 @@\n+/* java.beans.Introspector\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+import gnu.java.beans.*;\n+import java.util.*;\n+import java.lang.reflect.*;\n+import gnu.java.lang.*;\n+\n+/**\n+ ** Introspector is the class that does the bulk of the\n+ ** design-time work in Java Beans.  Every class must have\n+ ** a BeanInfo in order for an RAD tool to use it; but, as\n+ ** promised, you don't have to write the BeanInfo class\n+ ** yourself if you don't want to.  All you have to do is\n+ ** call getBeanInfo() in the Introspector and it will use\n+ ** standard JavaBeans-defined method signatures to\n+ ** determine the information about your class.<P>\n+ **\n+ ** Don't worry about it too much, though: you can provide\n+ ** JavaBeans with as much customized information as you\n+ ** want, or as little as you want, using the BeanInfo\n+ ** interface (see BeanInfo for details).<P>\n+ **\n+ ** <STRONG>Order of Operations</STRONG><P>\n+ **\n+ ** When you call getBeanInfo(class c), the Introspector\n+ ** first searches for BeanInfo class to see if you\n+ ** provided any explicit information.  It searches for a\n+ ** class named <bean class name>BeanInfo in different\n+ ** packages, first searching the bean class's package\n+ ** and then moving on to search the beanInfoSearchPath.<P>\n+ **\n+ ** If it does not find a BeanInfo class, it acts as though\n+ ** it had found a BeanInfo class returning null from all\n+ ** methods (meaning it should discover everything through\n+ ** Introspection).  If it does, then it takes the\n+ ** information it finds in the BeanInfo class to be\n+ ** canonical (that is, the information speaks for its\n+ ** class as well as all superclasses).<P>\n+ **\n+ ** When it has introspected the class, calls\n+ ** getBeanInfo(c.getSuperclass) and adds that information\n+ ** to the information it has, not adding to any information\n+ ** it already has that is canonical.<P>\n+ **\n+ ** <STRONG>Introspection Design Patterns</STRONG><P>\n+ **\n+ ** When the Introspector goes in to read the class, it\n+ ** follows a well-defined order in order to not leave any\n+ ** methods unaccounted for.  Its job is to step over all\n+ ** of the public methods in a class and determine whether\n+ ** they are part of a property, an event, or a method (in\n+ ** that order).\n+ **\n+ **\n+ ** <STRONG>Properties:</STRONG><P>\n+ ** \n+ ** <OL>\n+ ** <LI>If there is a <CODE>public boolean isXXX()</CODE>\n+ **     method, then XXX is a read-only boolean property.\n+ **     <CODE>boolean getXXX()</CODE> may be supplied in\n+ **     addition to this method, although isXXX() is the\n+ **     one that will be used in this case and getXXX()\n+ **     will be ignored.  If there is a\n+ **     <CODE>public void setXXX(boolean)</CODE> method,\n+ **     it is part of this group and makes it a read-write\n+ **     property.</LI>\n+ ** <LI>If there is a\n+ **     <CODE>public &lt;type&gt; getXXX(int)</CODE>\n+ **     method, then XXX is a read-only indexed property of\n+ **     type &lt;type&gt;.  If there is a\n+ **     <CODE>public void setXXX(int,&lt;type&gt;)</CODE>\n+ **     method, then it is a read-write indexed property of\n+ **     type &lt;type&gt;.  There may also be a\n+ **     <CODE>public &lt;type&gt;[] getXXX()</CODE> and a\n+ **     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n+ **     method as well.</CODE></LI>\n+ ** <LI>If there is a\n+ **     <CODE>public void setXXX(int,&lt;type&gt;)</CODE>\n+ **     method, then it is a write-only indexed property of\n+ **     type &lt;type&gt;.  There may also be a\n+ **     <CODE>public &lt;type&gt;[] getXXX()</CODE> and a\n+ **     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n+ **     method as well.</CODE></LI>\n+ ** <LI>If there is a\n+ **     <CODE>public &lt;type&gt; getXXX()</CODE> method,\n+ **     then XXX is a read-only property of type\n+ **     &lt;type&gt;.  If there is a\n+ **     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n+ **     method, then it will be used for the property and\n+ **     the property will be considered read-write.</LI>\n+ ** <LI>If there is a\n+ **     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n+ **     method, then as long as XXX is not already used as\n+ **     the name of a property, XXX is assumed to be a\n+ **     write-only property of type &lt;type&gt;.</LI>\n+ ** <LI>In all of the above cases, if the setXXX() method\n+ **     throws <CODE>PropertyVetoException</CODE>, then the\n+ **     property in question is assumed to be constrained.\n+ **     No properties are ever assumed to be bound\n+ **     (<STRONG>Spec Note:</STRONG> this is not in the\n+ **     spec, it just makes sense).  See PropertyDescriptor\n+ **     for a description of bound and constrained\n+ **     properties.</LI>\n+ ** </OL>\n+ **\n+ ** <STRONG>Events:</STRONG><P>\n+ **\n+ ** If there is a pair of methods,\n+ ** <CODE>public void addXXX(&lt;type&gt;)</CODE> and\n+ ** <CODE>public void removeXXX(&lt;type&gt;)</CODE>, where\n+ ** &lt;type&gt; is a descendant of\n+ ** <CODE>java.util.EventListener</CODE>, then the pair of\n+ ** methods imply that this Bean will fire events to\n+ ** listeners of type &lt;type&gt;.<P>\n+ **\n+ ** If the addXXX() method throws\n+ ** <CODE>java.util.TooManyListenersException</CODE>, then\n+ ** the event set is assumed to be <EM>unicast</EM>.  See\n+ ** EventSetDescriptor for a discussion of unicast event\n+ ** sets.<P>\n+ **\n+ ** <STRONG>Spec Note:</STRONG> the spec seems to say that\n+ ** the listener type's classname must be equal to the XXX\n+ ** part of addXXX() and removeXXX(), but that is not the\n+ ** case in Sun's implementation, so I am assuming it is\n+ ** not the case in general.<P>\n+ **\n+ ** <STRONG>Methods:</STRONG><P>\n+ ** \n+ ** Any public methods (including those which were used\n+ ** for Properties or Events) are used as Methods.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 29 Jul 1998\n+ ** @see java.beans.BeanInfo\n+ **/\n+\n+public class Introspector {\n+\tstatic String[] beanInfoSearchPath = {\"gnu.java.beans.info\", \"sun.beans.infos\"};\n+\tstatic Hashtable beanInfoCache = new Hashtable();\n+\n+\tprivate Introspector() {}\n+\n+\t/** Get the BeanInfo for class <CODE>beanClass</CODE>,\n+\t ** first by looking for explicit information, next by\n+\t ** using standard design patterns to determine\n+\t ** information about the class.\n+\t ** @param beanClass the class to get BeanInfo about.\n+\t ** @return the BeanInfo object representing the class.\n+\t **/\n+\tpublic static BeanInfo getBeanInfo(Class beanClass) throws IntrospectionException {\n+\t\tBeanInfo cachedInfo;\n+\t\tsynchronized(beanClass) {\n+\t\tcachedInfo = (BeanInfo)beanInfoCache.get(beanClass);\n+\t\tif(cachedInfo != null) {\n+\t\t\treturn cachedInfo;\n+\t\t}\n+\t\tcachedInfo = getBeanInfo(beanClass,null);\n+\t\tbeanInfoCache.put(beanClass,cachedInfo);\n+\t\treturn cachedInfo;\n+\t\t}\n+\t}\n+\n+\t/** Get the BeanInfo for class <CODE>beanClass</CODE>,\n+\t ** first by looking for explicit information, next by\n+\t ** using standard design patterns to determine\n+\t ** information about the class.  It crawls up the\n+\t ** inheritance tree until it hits <CODE>topClass</CODE>.\n+\t ** @param beanClass the Bean class.\n+\t ** @param stopClass the class to stop at.\n+\t ** @return the BeanInfo object representing the class.\n+\t **/\n+\tpublic static BeanInfo getBeanInfo(Class beanClass, Class stopClass) throws IntrospectionException {\n+\t\tExplicitInfo explicit = new ExplicitInfo(beanClass,stopClass);\n+\n+\t\tIntrospectionIncubator ii = new IntrospectionIncubator();\n+\t\tii.setPropertyStopClass(explicit.propertyStopClass);\n+\t\tii.setEventStopClass(explicit.eventStopClass);\n+\t\tii.setMethodStopClass(explicit.methodStopClass);\n+\t\tii.addMethods(beanClass.getMethods());\n+\n+\t\tBeanInfoEmbryo currentInfo = ii.getBeanInfoEmbryo();\n+\t\tPropertyDescriptor[] p = explicit.explicitPropertyDescriptors;\n+\t\tif(p!=null) {\n+\t\t\tfor(int i=0;i<p.length;i++) {\n+\t\t\t\tif(!currentInfo.hasProperty(p[i])) {\n+\t\t\t\t\tcurrentInfo.addProperty(p[i]);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(explicit.defaultProperty != -1) {\n+\t\t\t\tcurrentInfo.setDefaultPropertyName(p[explicit.defaultProperty].getName());\n+\t\t\t}\n+\t\t}\n+\t\tEventSetDescriptor[] e = explicit.explicitEventSetDescriptors;\n+\t\tif(e!=null) {\n+\t\t\tfor(int i=0;i<e.length;i++) {\n+\t\t\t\tif(!currentInfo.hasEvent(e[i])) {\n+\t\t\t\t\tcurrentInfo.addEvent(e[i]);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(explicit.defaultEvent != -1) {\n+\t\t\t\tcurrentInfo.setDefaultEventName(e[explicit.defaultEvent].getName());\n+\t\t\t}\n+\t\t}\n+\t\tMethodDescriptor[] m = explicit.explicitMethodDescriptors;\n+\t\tif(m!=null) {\n+\t\t\tfor(int i=0;i<m.length;i++) {\n+\t\t\t\tif(!currentInfo.hasMethod(m[i])) {\n+\t\t\t\t\tcurrentInfo.addMethod(m[i]);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif(explicit.explicitBeanDescriptor != null) {\n+\t\t\tcurrentInfo.setBeanDescriptor(new BeanDescriptor(beanClass,explicit.explicitBeanDescriptor.getCustomizerClass()));\n+\t\t} else {\n+\t\t\tcurrentInfo.setBeanDescriptor(new BeanDescriptor(beanClass,null));\n+\t\t}\n+\n+\t\tcurrentInfo.setAdditionalBeanInfo(explicit.explicitBeanInfo);\n+\t\tcurrentInfo.setIcons(explicit.im);\n+\n+\t\treturn currentInfo.getBeanInfo();\n+\t}\n+\n+\t/** Get the search path for BeanInfo classes.\n+\t ** @return the BeanInfo search path.\n+\t **/\n+\tpublic static String[] getBeanInfoSearchPath() {\n+\t\treturn beanInfoSearchPath;\n+\t}\n+\n+\t/** Set the search path for BeanInfo classes.\n+\t ** @param beanInfoSearchPath the new BeanInfo search\n+\t **        path.\n+\t **/\n+\tpublic static void setBeanInfoSearchPath(String[] beanInfoSearchPath) {\n+\t\tIntrospector.beanInfoSearchPath = beanInfoSearchPath;\n+\t}\n+\n+\t/** A helper method to convert a name to standard Java\n+\t ** naming conventions: anything with two capitals as the\n+\t ** first two letters remains the same, otherwise the\n+\t ** first letter is decapitalized.  URL = URL, I = i,\n+\t ** MyMethod = myMethod.\n+\t ** @param name the name to decapitalize.\n+\t ** @return the decapitalized name.\n+\t **/\n+\tpublic static String decapitalize(String name) {\n+\t\ttry {\n+\t\t\tif(!Character.isUpperCase(name.charAt(0))) {\n+\t\t\t\treturn name;\n+\t\t\t} else {\n+\t\t\t\ttry {\n+\t\t\t\t\tif(Character.isUpperCase(name.charAt(1))) {\n+\t\t\t\t\t\treturn name;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tchar[] c = name.toCharArray();\n+\t\t\t\t\t\tc[0] = Character.toLowerCase(c[0]);\n+\t\t\t\t\t\treturn new String(c);\n+\t\t\t\t\t}\n+\t\t\t\t} catch(StringIndexOutOfBoundsException E) {\n+\t\t\t\t\tchar[] c = new char[1];\n+\t\t\t\t\tc[0] = Character.toLowerCase(name.charAt(0));\n+\t\t\t\t\treturn new String(c);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch(StringIndexOutOfBoundsException E) {\n+\t\t\treturn name;\n+\t\t} catch(NullPointerException E) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tstatic BeanInfo copyBeanInfo(BeanInfo b) {\n+\t\tjava.awt.Image[] icons = new java.awt.Image[4];\n+\t\tfor(int i=1;i<=4;i++) {\n+\t\t\ticons[i-1] = b.getIcon(i);\n+\t\t}\n+\t\treturn new ExplicitBeanInfo(b.getBeanDescriptor(),b.getAdditionalBeanInfo(),\n+\t\t                            b.getPropertyDescriptors(),b.getDefaultPropertyIndex(),\n+\t\t                            b.getEventSetDescriptors(),b.getDefaultEventIndex(),\n+\t\t                            b.getMethodDescriptors(),icons);\n+\t}\n+}\n+\n+class ExplicitInfo {\n+\tBeanDescriptor explicitBeanDescriptor;\n+\tBeanInfo[] explicitBeanInfo;\n+\n+\tPropertyDescriptor[] explicitPropertyDescriptors;\n+\tEventSetDescriptor[] explicitEventSetDescriptors;\n+\tMethodDescriptor[] explicitMethodDescriptors;\n+\n+\tint defaultProperty;\n+\tint defaultEvent;\n+\n+\tjava.awt.Image[] im = new java.awt.Image[4];\n+\n+\tClass propertyStopClass;\n+\tClass eventStopClass;\n+\tClass methodStopClass;\n+\n+\tExplicitInfo(Class beanClass, Class stopClass) {\n+\t\twhile(beanClass != null && !beanClass.equals(stopClass)) {\n+\t\t\tBeanInfo explicit = findExplicitBeanInfo(beanClass);\n+\t\t\tif(explicit != null) {\n+\t\t\t\tif(explicitBeanDescriptor == null) {\n+\t\t\t\t\texplicitBeanDescriptor = explicit.getBeanDescriptor();\n+\t\t\t\t}\n+\t\t\t\tif(explicitBeanInfo == null) {\n+\t\t\t\t\texplicitBeanInfo = explicit.getAdditionalBeanInfo();\n+\t\t\t\t}\n+\t\t\t\tif(explicitPropertyDescriptors == null) {\n+\t\t\t\t\tif(explicit.getPropertyDescriptors() != null) {\n+\t\t\t\t\t\texplicitPropertyDescriptors = explicit.getPropertyDescriptors();\n+\t\t\t\t\t\tdefaultProperty = explicit.getDefaultPropertyIndex();\n+\t\t\t\t\t\tpropertyStopClass = beanClass;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif(explicitEventSetDescriptors == null) {\n+\t\t\t\t\tif(explicit.getEventSetDescriptors() != null) {\n+\t\t\t\t\t\texplicitEventSetDescriptors = explicit.getEventSetDescriptors();\n+\t\t\t\t\t\tdefaultEvent = explicit.getDefaultEventIndex();\n+\t\t\t\t\t\teventStopClass = beanClass;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif(explicitMethodDescriptors == null) {\n+\t\t\t\t\tif(explicit.getMethodDescriptors() != null) {\n+\t\t\t\t\t\texplicitMethodDescriptors = explicit.getMethodDescriptors();\n+\t\t\t\t\t\tmethodStopClass = beanClass;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif(im[0] == null\n+\t\t\t\t   && im[1] == null\n+\t\t\t\t   && im[2] == null\n+\t\t\t\t   && im[3] == null) {\n+\t\t\t\t\tim[0] = explicit.getIcon(0);\n+\t\t\t\t\tim[1] = explicit.getIcon(1);\n+\t\t\t\t\tim[2] = explicit.getIcon(2);\n+\t\t\t\t\tim[3] = explicit.getIcon(3);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbeanClass = beanClass.getSuperclass();\n+\t\t}\n+\t\tif(propertyStopClass == null) {\n+\t\t\tpropertyStopClass = stopClass;\n+\t\t}\n+\t\tif(eventStopClass == null) {\n+\t\t\teventStopClass = stopClass;\n+\t\t}\n+\t\tif(methodStopClass == null) {\n+\t\t\tmethodStopClass = stopClass;\n+\t\t}\n+\t}\n+\n+\tstatic Hashtable explicitBeanInfos = new Hashtable();\n+\tstatic Vector emptyBeanInfos = new Vector();\n+\n+\tstatic BeanInfo findExplicitBeanInfo(Class beanClass) {\n+\t\tBeanInfo retval = (BeanInfo)explicitBeanInfos.get(beanClass);\n+\t\tif(retval != null) {\n+\t\t\treturn retval;\n+\t\t} else if(emptyBeanInfos.indexOf(beanClass) != -1) {\n+\t\t\treturn null;\n+\t\t} else {\n+\t\t\tretval = reallyFindExplicitBeanInfo(beanClass);\n+\t\t\tif(retval != null) {\n+\t\t\t\texplicitBeanInfos.put(beanClass,retval);\n+\t\t\t} else {\n+\t\t\t\temptyBeanInfos.addElement(beanClass);\n+\t\t\t}\n+\t\t\treturn retval;\n+\t\t}\n+\t}\n+\n+\tstatic BeanInfo reallyFindExplicitBeanInfo(Class beanClass) {\n+\t\ttry {\n+\t\ttry {\n+\t\t\treturn (BeanInfo)Class.forName(beanClass.getName()+\"BeanInfo\").newInstance();\n+\t\t} catch(ClassNotFoundException E) {\n+\t\t}\n+\t\tString newName = ClassHelper.getTruncatedClassName(beanClass) + \"BeanInfo\";\n+\t\tfor(int i=0;i<Introspector.beanInfoSearchPath.length;i++) {\n+\t\t\ttry {\n+\t\t\t\tif(Introspector.beanInfoSearchPath[i].equals(\"\")) {\n+\t\t\t\t\treturn (BeanInfo)Class.forName(newName).newInstance();\n+\t\t\t\t} else {\n+\t\t\t\t\treturn (BeanInfo)Class.forName(Introspector.beanInfoSearchPath[i] + \".\" + newName).newInstance();\n+\t\t\t\t}\n+\t\t\t} catch(ClassNotFoundException E) {\n+\t\t\t}\n+\t\t}\n+\t\t} catch(IllegalAccessException E) {\n+\t\t} catch(InstantiationException E) {\n+\t\t}\n+\t\treturn null;\n+\t}\n+}"}, {"sha": "bb052f7a84047ff47c10ffa28b3c7ad00d52d029", "filename": "libjava/java/beans/MethodDescriptor.java", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FMethodDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FMethodDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FMethodDescriptor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,77 @@\n+/* java.beans.MethodDescriptor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+import java.lang.reflect.*;\n+\n+/** MethodDescriptor describes information about a JavaBeans method.\n+ ** It's a fairly straightforward class (at least something in this\n+ ** package is straightforward!).\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 26 Jul 1998\n+ **/\n+public class MethodDescriptor extends FeatureDescriptor {\n+\tprivate Method m;\n+\tprivate ParameterDescriptor[] parameterDescriptors;\n+\n+\t/** Create a new MethodDescriptor.\n+\t ** This method sets the name to the name of the method (Method.getName()).\n+\t ** @param m the method it will represent.\n+\t **/\n+\tpublic MethodDescriptor(Method m) {\n+\t\tsetName(m.getName());\n+\t\tthis.m = m;\n+\t}\n+\n+\t/** Create a new MethodDescriptor.\n+\t ** This method sets the name to the name of the method (Method.getName()).\n+\t ** @param m the method it will represent.\n+\t ** @param parameterDescriptors descriptions of the parameters (especially names).\n+\t **/\n+\tpublic MethodDescriptor(Method m, ParameterDescriptor[] parameterDescriptors) {\n+\t\tsetName(m.getName());\n+\t\tthis.m = m;\n+\t\tthis.parameterDescriptors = parameterDescriptors;\n+\t}\n+\n+\t/** Get the parameter descriptors from this method.\n+\t ** Since MethodDescriptor has no way of determining what\n+\t ** the parameter names were, this defaults to null.\n+\t **/\n+\tpublic ParameterDescriptor[] getParameterDescriptors() {\n+\t\treturn parameterDescriptors;\n+\t}\n+\n+\t/** Get the method this MethodDescriptor represents. **/\n+\tpublic Method getMethod() {\n+\t\treturn m;\n+\t}\n+}\n+"}, {"sha": "664d5caa6c90a308e200ecd903ffc684e8005dbc", "filename": "libjava/java/beans/ParameterDescriptor.java", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FParameterDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FParameterDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FParameterDescriptor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,41 @@\n+/* java.beans.MethodDescriptor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/** ParameterDescriptor represents a single parameter to a method.\n+ ** As it turns out, FeatureDescriptor is sufficient to hold all\n+ ** the information.  Use its constructor and methods to set\n+ ** the appropriate values.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 26 Jul 1998\n+ **/\n+public class ParameterDescriptor extends FeatureDescriptor {\n+\t\n+}"}, {"sha": "f07577c6d2566dcbb888dc3ce1e4cc58fe2e0f69", "filename": "libjava/java/beans/PropertyChangeEvent.java", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyChangeEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyChangeEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyChangeEvent.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,111 @@\n+/* java.beans.PropertyChangeEvent\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/**\n+ ** PropertyChangeEvents are fired in the PropertyChange\n+ ** and VetoableChange event classes.  They represent the\n+ ** old and new values as well as the source Bean.<P>\n+ **\n+ ** If the old or new value is a primitive type, it must\n+ ** be wrapped in the appropriate wrapper type\n+ ** (java.lang.Integer for int, etc., etc.).<P>\n+ **\n+ ** If the old or new values are unknown (although why\n+ ** that would be I do not know), they may be null.<P>\n+ **\n+ ** Right now Sun put in a propagationId, reserved for\n+ ** future use.  Read the comments on the constructor\n+ ** and on setPropagationId for more information.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class PropertyChangeEvent extends java.util.EventObject {\n+\tString propertyName;\n+\tObject oldVal;\n+\tObject newVal;\n+\tObject propagationId;\n+\n+\t/** Create a new PropertyChangeEvent.  Remember that if\n+\t ** you received a PropertyChangeEvent and are sending\n+\t ** a new one, you should also set the propagation ID\n+\t ** from the old PropertyChangeEvent.\n+\t ** @param source the Bean containing the property.\n+\t ** @param propertyName the property's name.\n+\t ** @param oldVal the old value of the property.\n+\t ** @param newVal the new value of the property.\n+\t **/\n+\tpublic PropertyChangeEvent(Object source, String propertyName, Object oldVal, Object newVal) {\n+\t\tsuper(source);\n+\t\tthis.propertyName = propertyName;\n+\t\tthis.oldVal = oldVal;\n+\t\tthis.newVal = newVal;\n+\t}\n+\n+\t/** Get the property name.\n+\t ** @return the property name.\n+\t **/\n+\tpublic String getPropertyName() {\n+\t\treturn propertyName;\n+\t}\n+\n+\t/** Get the property's old value.\n+\t ** @return the property's old value.\n+\t **/\n+\tpublic Object getOldValue() {\n+\t\treturn oldVal;\n+\t}\n+\n+\t/** Get the property's new value.\n+\t ** @return the property's new value.\n+\t **/\n+\tpublic Object getNewValue() {\n+\t\treturn newVal;\n+\t}\n+\n+\t/** Set the propagation ID.  This is a way for the event\n+\t ** to be passed from hand to hand and retain a little\n+\t ** extra state.  Right now it is unused, but it should\n+\t ** be propagated anyway so that future versions of\n+\t ** JavaBeans can use it, for God knows what.\n+\t ** @param propagationId the propagation ID.\n+\t **/\n+\tpublic void setPropagationId(Object propagationId) {\n+\t\tthis.propagationId = propagationId;\n+\t}\n+\n+\t/** Get the propagation ID.\n+\t ** @return the propagation ID.\n+\t **/\n+\tpublic Object getPropagationId() {\n+\t\treturn propagationId;\n+\t}\n+}"}, {"sha": "7f1df72c50c61b74715ab283789950ac5c30bcbe", "filename": "libjava/java/beans/PropertyChangeListener.java", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyChangeListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyChangeListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyChangeListener.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,48 @@\n+/* java.beans.PropertyChangeListener\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/**\n+ ** PropertyChangeListener allows a class to monitor\n+ ** properties of a Bean for changes.<P>\n+ **\n+ ** A propertyChange() event will only be fired\n+ ** <EM>after</EM> the property has changed.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 29 Jul 1998\n+ ** @see java.beans.PropertyChangeSupport\n+ **/\n+\n+public interface PropertyChangeListener {\n+\t/** Fired after a Bean's property has changed.\n+\t ** @param e the change (containing the old and new values)\n+\t **/\n+\tpublic abstract void propertyChange(PropertyChangeEvent e);\n+}"}, {"sha": "512c8edeb7dc608fc42b62a9c0d9bf3dc467031e", "filename": "libjava/java/beans/PropertyChangeSupport.java", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyChangeSupport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyChangeSupport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyChangeSupport.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,203 @@\n+/* java.beans.PropertyChangeSupport\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+import java.util.Hashtable;\n+import java.util.Vector;\n+\n+/**\n+ ** PropertyChangeSupport makes it easy to fire property\n+ ** change events and handle listeners.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.2.0, 15 Mar 1999\n+ **/\n+\n+public class PropertyChangeSupport implements java.io.Serializable {\n+\tHashtable propertyListeners = new Hashtable();\n+\tVector listeners = new Vector();\n+\tObject bean;\n+\n+\t/** Create PropertyChangeSupport to work with a specific\n+\t ** source bean.\n+\t ** @param bean the source bean to use.\n+\t **/\n+\tpublic PropertyChangeSupport(Object bean) {\n+\t\tthis.bean = bean;\n+\t}\n+\n+\t/** Adds a PropertyChangeListener to the list of listeners.\n+\t ** All property change events will be sent to this listener.\n+\t ** <P>\n+\t **\n+\t ** The listener add is not unique: that is, <em>n</em> adds with\n+\t ** the same listener will result in <em>n</em> events being sent\n+\t ** to that listener for every property change.\n+\t ** <P>\n+\t **\n+\t ** Adding a null listener will cause undefined behavior.\n+\t **\n+\t ** @param l the listener to add.\n+\t **/\n+\tpublic void addPropertyChangeListener(PropertyChangeListener l) {\n+\t\tlisteners.addElement(l);\n+\t}\n+\n+\t/** Adds a PropertyChangeListener listening on the specified property.\n+\t ** Events will be sent to the listener for that particular property.\n+\t ** <P>\n+\t **\n+\t ** The listener add is not unique; that is, <em>n</em> adds on a\n+\t ** particular property for a particular listener will result in\n+\t ** <em>n</em> events being sent to that listener when that\n+\t ** property is changed.\n+\t ** <P>\n+\t **\n+\t ** The effect is cumulative, too; if you are registered to listen\n+\t ** to receive events on all property changes, and then you\n+\t ** register on a particular property, you will receive change\n+\t ** events for that property twice.\n+\t ** <P>\n+\t **\n+\t ** Adding a null listener will cause undefined behavior.\n+\t **\n+\t ** @param propertyName the name of the property to listen on.\n+\t ** @param l the listener to add.\n+\t **/\n+\tpublic void addPropertyChangeListener(String propertyName, PropertyChangeListener l) {\n+\t\tsynchronized(propertyListeners) {\n+\t\t\tVector v = (Vector)propertyListeners.get(propertyName);\n+\t\t\ttry {\n+\t\t\t\tv.addElement(l);\n+\t\t\t} catch(NullPointerException e) {\n+\t\t\t\t/* If v is not found, create a new vector. */\n+\t\t\t\tv = new Vector();\n+\t\t\t\tv.addElement(l);\n+\t\t\t\tpropertyListeners.put(propertyName, v);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/** Removes a PropertyChangeListener from the list of listeners.\n+\t ** If any specific properties are being listened on, they must\n+\t ** be deregistered by themselves; this will only remove the\n+\t ** general listener to all properties.\n+\t ** <P>\n+\t **\n+\t ** If <code>add()</code> has been called multiple times for a\n+\t ** particular listener, <code>remove()</code> will have to be\n+\t ** called the same number of times to deregister it.\n+\t **\n+\t ** @param l the listener to remove.\n+\t **/\n+\tpublic void removePropertyChangeListener(PropertyChangeListener l) {\n+\t\tlisteners.removeElement(l);\n+\t}\n+\n+\t/** Removes a PropertyChangeListener from listening to a specific property.\n+\t ** <P>\n+\t **\n+\t ** If <code>add()</code> has been called multiple times for a\n+\t ** particular listener on a property, <code>remove()</code> will\n+\t ** have to be called the same number of times to deregister it.\n+\t **\n+\t ** @param propertyName the property to stop listening on.\n+\t ** @param l the listener to remove.\n+\t **/\n+\tpublic void removePropertyChangeListener(String propertyName, PropertyChangeListener l) {\n+\t\tsynchronized(propertyListeners) {\n+\t\t\tVector v = (Vector)propertyListeners.get(propertyName);\n+\t\t\ttry {\n+\t\t\t\tv.removeElement(l);\n+\t\t\t\tif(v.size() == 0) {\n+\t\t\t\t\tpropertyListeners.remove(propertyName);\n+\t\t\t\t}\n+\t\t\t} catch(NullPointerException e) {\n+\t\t\t\t/* if v is not found, do nothing. */\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/** Fire a PropertyChangeEvent to all the listeners.\n+\t **\n+\t ** @param event the event to fire.\n+\t **/\n+\tpublic void firePropertyChange(PropertyChangeEvent event) {\n+\t\tfor(int i=0;i<listeners.size();i++) {\n+\t\t\t((PropertyChangeListener)listeners.elementAt(i)).propertyChange(event);\n+\t\t}\n+\t\tVector moreListeners = (Vector)propertyListeners.get(event.getPropertyName());\n+\t\tif(moreListeners != null) {\n+\t\t\tfor(int i=0;i<moreListeners.size();i++) {\n+\t\t\t\t((PropertyChangeListener)moreListeners.elementAt(i)).propertyChange(event);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/** Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.\n+\t **\n+\t ** @param propertyName the name of the property that changed.\n+\t ** @param oldVal the old value.\n+\t ** @param newVal the new value.\n+\t **/\n+\tpublic void firePropertyChange(String propertyName, Object oldVal, Object newVal) {\n+\t\tfirePropertyChange(new PropertyChangeEvent(bean,propertyName,oldVal,newVal));\n+\t}\n+\n+\t/** Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.\n+\t **\n+\t ** @param propertyName the name of the property that changed.\n+\t ** @param oldVal the old value.\n+\t ** @param newVal the new value.\n+\t **/\n+\tpublic void firePropertyChange(String propertyName, boolean oldVal, boolean newVal) {\n+\t\tfirePropertyChange(new PropertyChangeEvent(bean, propertyName, new Boolean(oldVal), new Boolean(newVal)));\n+\t}\n+\n+\t/** Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.\n+\t **\n+\t ** @param propertyName the name of the property that changed.\n+\t ** @param oldVal the old value.\n+\t ** @param newVal the new value.\n+\t **/\n+\tpublic void firePropertyChange(String propertyName, int oldVal, int newVal) {\n+\t\tfirePropertyChange(new PropertyChangeEvent(bean, propertyName, new Integer(oldVal), new Integer(newVal)));\n+\t}\n+\n+\t/** Tell whether the specified property is being listened on or not.\n+\t ** This will only return <code>true</code> if there are listeners\n+\t ** on all properties or if there is a listener specifically on this\n+\t ** property.\n+\t **\n+\t ** @param propertyName the property that may be listened on\n+\t ** @return whether the property is being listened on\n+\t **/\n+\t public boolean hasListeners(String propertyName) {\n+\t \treturn listeners.size() > 0  || propertyListeners.get(propertyName) != null;\n+\t }\n+}"}, {"sha": "ec1431273ebbb37388d21c37e89961e52f913cbd", "filename": "libjava/java/beans/PropertyDescriptor.java", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyDescriptor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,333 @@\n+/* java.beans.PropertyDescriptor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+\n+\n+/**\n+ ** PropertyDescriptor describes information about a JavaBean property,\n+ ** by which we mean a property that has been exposed via a pair of\n+ ** get and set methods.  (There may be no get method, which means\n+ ** the property is write-only, or no set method, which means the\n+ ** the property is read-only.)<P>\n+ **\n+ ** The constraints put on get and set methods are:<P>\n+ ** <OL>\n+ ** <LI>A get method must have signature\n+ **     <CODE>&lt;propertyType&gt; &lt;getMethodName&gt;()</CODE></LI>\n+ ** <LI>A set method must have signature\n+ **     <CODE>void &lt;setMethodName&gt;(&lt;propertyType&gt;)</CODE></LI>\n+ ** <LI>Either method type may throw any exception.</LI>\n+ ** <LI>Both methods must be public.</LI>\n+ ** </OL>\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 26 Jul 1998\n+ **/\n+\n+public class PropertyDescriptor extends FeatureDescriptor {\n+\tClass propertyType;\n+\tMethod getMethod;\n+\tMethod setMethod;\n+\n+\tClass propertyEditorClass;\n+\tboolean bound;\n+\tboolean constrained;\n+\n+\tPropertyDescriptor(String name) {\n+\t\tsetName(name);\n+\t}\n+\n+\t/** Create a new PropertyDescriptor by introspection.\n+\t ** This form of constructor creates the PropertyDescriptor by\n+\t ** looking for a getter method named <CODE>get&lt;name&gt;()</CODE>\n+\t ** (or, optionally, if the property is boolean,\n+\t ** <CODE>is&lt;name&gt;()</CODE>) and\n+\t ** <CODE>set&lt;name&gt;()</CODE> in class\n+\t ** <CODE>&lt;beanClass&gt;</CODE>, where &lt;name&gt; has its\n+\t ** first letter capitalized by the constructor.<P>\n+\t **\n+\t ** <B>Implementation note:</B> If there is a get method (or\n+\t ** boolean isXXX() method), then the return type of that method\n+\t ** is used to find the set method.  If there is no get method,\n+\t ** then the set method is searched for exhaustively.<P>\n+\t **\n+\t ** <B>Spec note:</B>\n+\t ** If there is no get method and multiple set methods with\n+\t ** the same name and a single parameter (different type of course),\n+\t ** then an IntrospectionException is thrown.  While Sun's spec\n+\t ** does not state this, it can make Bean behavior different on\n+\t ** different systems (since method order is not guaranteed) and as\n+\t ** such, can be treated as a bug in the spec.  I am not aware of\n+\t ** whether Sun's implementation catches this.\n+\t **\n+\t ** @param name the programmatic name of the property, usually\n+\t **             starting with a lowercase letter (e.g. fooManChu\n+\t **             instead of FooManChu).\n+\t ** @param beanClass the class the get and set methods live in.\n+\t ** @exception IntrospectionException if the methods are not found or invalid.\n+\t **/\n+\tpublic PropertyDescriptor(String name, Class beanClass) throws IntrospectionException {\n+\t\tsetName(name);\n+\t\tString capitalized;\n+\t\ttry {\n+\t\t\tcapitalized = Character.toUpperCase(name.charAt(0)) + name.substring(1);\n+\t\t} catch(StringIndexOutOfBoundsException e) {\n+\t\t\tcapitalized = \"\";\n+\t\t}\n+\t\tfindMethods(beanClass, \"is\" + capitalized, \"get\" + capitalized, \"set\" + capitalized);\n+\t}\n+\n+\t/** Create a new PropertyDescriptor by introspection.\n+\t ** This form of constructor allows you to specify the\n+\t ** names of the get and set methods to search for.<P>\n+\t **\n+\t ** <B>Implementation note:</B> If there is a get method (or\n+\t ** boolean isXXX() method), then the return type of that method\n+\t ** is used to find the set method.  If there is no get method,\n+\t ** then the set method is searched for exhaustively.<P>\n+\t **\n+\t ** <B>Spec note:</B>\n+\t ** If there is no get method and multiple set methods with\n+\t ** the same name and a single parameter (different type of course),\n+\t ** then an IntrospectionException is thrown.  While Sun's spec\n+\t ** does not state this, it can make Bean behavior different on\n+\t ** different systems (since method order is not guaranteed) and as\n+\t ** such, can be treated as a bug in the spec.  I am not aware of\n+\t ** whether Sun's implementation catches this.\n+\t **\n+\t ** @param name the programmatic name of the property, usually\n+\t **             starting with a lowercase letter (e.g. fooManChu\n+\t **             instead of FooManChu).\n+\t ** @param beanClass the class the get and set methods live in.\n+\t ** @param getMethodName the name of the get method.\n+\t ** @param setMethodName the name of the set method.\n+\t ** @exception IntrospectionException if the methods are not found or invalid.\n+\t **/\n+\tpublic PropertyDescriptor(String name, Class beanClass, String getMethodName, String setMethodName) throws IntrospectionException {\n+\t\tsetName(name);\n+\t\tfindMethods(beanClass, getMethodName, null, setMethodName);\n+\t}\n+\n+\t/** Create a new PropertyDescriptor using explicit Methods.\n+\t ** Note that the methods will be checked for conformance to standard\n+\t ** Property method rules, as described above at the top of this class.\n+\t ** \n+\t ** @param name the programmatic name of the property, usually\n+\t **             starting with a lowercase letter (e.g. fooManChu\n+\t **             instead of FooManChu).\n+\t ** @param getMethod the get method.\n+\t ** @param setMethod the set method.\n+\t ** @exception IntrospectionException if the methods are not found or invalid.\n+\t **/\n+\tpublic PropertyDescriptor(String name, Method getMethod, Method setMethod) throws IntrospectionException {\n+\t\tsetName(name);\n+\t\tif(getMethod != null && getMethod.getParameterTypes().length > 0) {\n+\t\t\tthrow new IntrospectionException(\"get method has parameters\");\n+\t\t}\n+\t\tif(setMethod != null && setMethod.getParameterTypes().length != 1) {\n+\t\t\tthrow new IntrospectionException(\"set method does not have exactly one parameter\");\n+\t\t}\n+\t\tif(getMethod != null && setMethod != null) {\n+\t\t\tif(!getMethod.getReturnType().equals(setMethod.getParameterTypes()[0])) {\n+\t\t\t\tthrow new IntrospectionException(\"set and get methods do not share the same type\");\n+\t\t\t}\n+\t\t\tif(!getMethod.getDeclaringClass().isAssignableFrom(setMethod.getDeclaringClass())\n+\t\t\t   && !setMethod.getDeclaringClass().isAssignableFrom(getMethod.getDeclaringClass())) {\n+\t\t\t\tthrow new IntrospectionException(\"set and get methods are not in the same class.\");\n+\t\t\t}\n+\t\t}\n+\t\tthis.getMethod = getMethod;\n+\t\tthis.setMethod = setMethod;\n+\t\tif(getMethod != null) {\n+\t\t\tthis.propertyType = getMethod.getReturnType();\n+\t\t} else {\n+\t\t\tthis.propertyType = setMethod.getParameterTypes()[0];\n+\t\t}\n+\t}\n+\n+\t/** Get the property type.\n+\t ** This is the type the get method returns and the set method\n+\t ** takes in.\n+\t **/\n+\tpublic Class getPropertyType() {\n+\t\treturn propertyType;\n+\t}\n+\n+\t/** Get the get method.  Why they call it readMethod here and\n+\t ** get everywhere else is beyond me.\n+\t **/\n+\tpublic Method getReadMethod() {\n+\t\treturn getMethod;\n+\t}\n+\n+\t/** Get the set method.  Why they call it writeMethod here and\n+\t ** set everywhere else is beyond me.\n+\t **/\n+\tpublic Method getWriteMethod() {\n+\t\treturn setMethod;\n+\t}\n+\n+\t/** Get whether the property is bound.  Defaults to false. **/\n+\tpublic boolean isBound() {\n+\t\treturn bound;\n+\t}\n+\n+\t/** Set whether the property is bound.\n+\t ** As long as the the bean implements addPropertyChangeListener() and\n+\t ** removePropertyChangeListener(), setBound(true) may safely be called.<P>\n+\t ** If these things are not true, then the behavior of the system\n+\t ** will be undefined.<P>\n+\t **\n+\t ** When a property is bound, its set method is required to fire the\n+\t ** <CODE>PropertyChangeListener.propertyChange())</CODE event\n+\t ** after the value has changed.\n+\t ** @param bound whether the property is bound or not.\n+\t **/\n+\tpublic void setBound(boolean bound) {\n+\t\tthis.bound = bound;\n+\t}\n+\n+\t/** Get whether the property is constrained.  Defaults to false. **/\n+\tpublic boolean isConstrained() {\n+\t\treturn constrained;\n+\t}\n+\n+\t/** Set whether the property is constrained.\n+\t ** If the set method throws <CODE>java.beans.PropertyVetoException</CODE>\n+\t ** (or subclass thereof) and the bean implements addVetoableChangeListener()\n+\t ** and removeVetoableChangeListener(), then setConstrained(true) may safely\n+\t ** be called.  Otherwise, the system behavior is undefined.\n+\t ** <B>Spec note:</B> given those strict parameters, it would be nice if it\n+\t ** got set automatically by detection, but oh well.<P>\n+\t ** When a property is constrained, its set method is required to:<P>\n+\t ** <OL>\n+\t ** <LI>Fire the <CODE>VetoableChangeListener.vetoableChange()</CODE>\n+\t **     event notifying others of the change and allowing them a chance to\n+\t **     say it is a bad thing.</LI>\n+\t ** <LI>If any of the listeners throws a PropertyVetoException, then\n+\t **     it must fire another vetoableChange() event notifying the others\n+\t **     of a reversion to the old value (though, of course, the change\n+\t **     was never made).  Then it rethrows the PropertyVetoException and\n+\t **     exits.</LI>\n+\t ** <LI>If all has gone well to this point, the value may be changed.</LI>\n+\t ** </OL>\n+\t ** @param constrained whether the property is constrained or not.\n+\t **/\n+\tpublic void setConstrained(boolean constrained) {\n+\t\tthis.constrained = constrained;\n+\t}\n+\n+\t/** Get the PropertyEditor class.  Defaults to null. **/\n+\tpublic Class getPropertyEditorClass() {\n+\t\treturn propertyEditorClass;\n+\t}\n+\n+\t/** Set the PropertyEditor class.  If the class does not implement\n+\t ** the PropertyEditor interface, you will likely get an exception\n+\t ** late in the game.\n+\t ** @param propertyEditorClass the PropertyEditor class for this class to use.\n+\t **/\n+\tpublic void setPropertyEditorClass(Class propertyEditorClass) {\n+\t\tthis.propertyEditorClass = propertyEditorClass;\n+\t}\n+\n+\tprivate void findMethods(Class beanClass, String getMethodName1, String getMethodName2, String setMethodName) throws IntrospectionException {\n+\t\ttry {\n+\t\t\tif(getMethodName1 != null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tgetMethod = beanClass.getMethod(getMethodName1, new Class[0]);\n+\t\t\t\t} catch(NoSuchMethodException E) {\n+\t\t\t\t}\n+\t\t\t\tif(getMethodName2 != null) {\n+\t\t\t\t\tif(getMethod != null && !getMethod.getReturnType().equals(java.lang.Boolean.TYPE)) {\n+\t\t\t\t\t\t// If the is() method exists but isn't boolean, we'll just go on and look for\n+\t\t\t\t\t\t// an ordinary get() method.\n+\t\t\t\t\t\tgetMethod = null;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tMethod getMethod2;\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tgetMethod2 = beanClass.getMethod(getMethodName2, new Class[0]);\n+\t\t\t\t\t} catch(NoSuchMethodException E) {\n+\t\t\t\t\t\tgetMethod2 = null;\n+\t\t\t\t\t}\n+\t\t\t\t\tif(getMethod2 != null) {\n+\t\t\t\t\t\tif(getMethod != null) {\n+\t\t\t\t\t\t\tif(!getMethod.getReturnType().equals(getMethod2.getReturnType())) {\n+\t\t\t\t\t\t\t\tthrow new IntrospectionException(\"Both \" + getMethodName1 + \" and \" + getMethodName2 + \" exist, and have contradictory return types.\");\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tgetMethod = getMethod2;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif(getMethod != null) {\n+\t\t\t\tpropertyType = getMethod.getReturnType();\n+\t\t\t\tif(setMethodName != null) {\n+\t\t\t\t\tClass[] setArgs = new Class[1];\n+\t\t\t\t\tsetArgs[0] = propertyType;\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tsetMethod = beanClass.getMethod(setMethodName, setArgs);\n+\t\t\t\t\t\tif(!setMethod.getReturnType().equals(java.lang.Void.TYPE)) {\n+\t\t\t\t\t\t\tthrow new IntrospectionException(setMethodName + \" has non-void return type\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} catch(NoSuchMethodException E) {\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if(setMethodName != null) {\n+\t\t\t\tMethod[] m = beanClass.getMethods();\n+\t\t\t\tfor(int i=0;i<m.length;i++) {\n+\t\t\t\t\tMethod current = m[i];\n+\t\t\t\t\tif(current.getName().equals(setMethodName)\n+\t\t\t\t\t   && current.getParameterTypes().length == 1\n+\t\t\t\t\t   && current.getReturnType().equals(java.lang.Void.TYPE)) {\n+\t\t\t\t\t\tif(setMethod != null) {\n+\t\t\t\t\t\t\tthrow new IntrospectionException(\"Multiple, different set methods found that fit the bill!\");\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tsetMethod = current;\n+\t\t\t\t\t\t\tpropertyType = current.getParameterTypes()[0];\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif(setMethod == null) {\n+\t\t\t\t\tthrow new IntrospectionException(\"Cannot find get or set methods.\");\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tthrow new IntrospectionException(\"Cannot find get or set methods.\");\n+\t\t\t}\n+\t\t} catch(SecurityException E) {\n+\t\t\tthrow new IntrospectionException(\"SecurityException thrown on attempt to access methods.\");\n+\t\t}\n+\t}\n+}"}, {"sha": "b861b52cc4a1fdb909ab2ac4880e212078d0178e", "filename": "libjava/java/beans/PropertyEditor.java", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyEditor.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,198 @@\n+/* java.beans.PropertyEditor\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/**\n+ ** PropertyEditors are custom GUI editors for specific types of values.\n+ **\n+ ** A PropertyEditor can be used, for example, if you are editing a type of value\n+ ** that can be more easily represented graphically, such as a Point, or one that\n+ ** can be more easily represented by a list, such as a boolean (true/false).<P>\n+ **\n+ ** A PropertyEditor must be able to display its contents when asked to and\n+ ** be able to allow the user to change its underlying field value.  However, it\n+ ** is not the PropertyEditor's responsibility to make the change to the\n+ ** underlying Object; in fact, the PropertyEditor does not even know about the\n+ ** Object it is actually editing--only about the property it is currently\n+ ** editing.  When a change is made to the property, the PropertyEditor must\n+ ** simply fire a PropertyChangeEvent and allow the RAD tool to actually set\n+ ** the property in the underlying Bean.<P>\n+ **\n+ ** PropertyEditors should not change the Objects they are given by setValue().\n+ ** These Objects may or may not be the actual Objects which are properties of\n+ ** the Bean being edited.  Instead, PropertyEditors should create a new Object\n+ ** and fire a PropertyChangeEvent with the old and new values.<P>\n+ **\n+ ** PropertyEditors also must support the ability to return a Java\n+ ** initialization string.  See the getJavaInitializationString() method for\n+ ** details.<P>\n+ **\n+ ** There are several different ways a PropertyEditor may display and control\n+ ** editing of its value.  When multiple types of input and display are\n+ ** given by a single PropertyEditor, the RAD tool may decide which of the call\n+ ** to support.  Some RAD tools may even be text-only, so even if you support\n+ ** a graphical set and get, it may choose the text set and get whenever it can.\n+ ** <OL>\n+ **   <LI>Every PropertyEditor must support getValue() and setValue().  For\n+ **       setValue(), the component must only support it when the argument is\n+ **       the same type that the PropertyEditor supports.</LI>\n+ **   <LI>Every PropertyEditor must support getJavaInitializationString().</LI>\n+ **   <LI>You may support painting the value yourself if you wish.  To do this,\n+ **       have isPaintable() return true and implement the paintValue() method.\n+ **       This method does not determine in any way how the value is edited;\n+ **       merely how it is displayed.</LI>\n+ **   <LU>Let the caller of the PropertyEditor give the user a text input.  Do\n+ **       this by returning a non-null String from getAsText().  If you support\n+ **       text input, you *must* support setAsText().</LI>\n+ **   <LI>Give the caller a set of possible values, such as \"true\"/\"false\", that\n+ **       the user must select from.  To do this, return the list of Strings\n+ **       from the getTags() method.  The RAD tool may choose to implement the\n+ **       user input any way it wishes, and only guarantees that setAsText() will\n+ **       only be called with one of the Strings returned from getTags().</LI>\n+ **   <LI>You may support a whole custom editing control by supporting\n+ **       getCustomEditor().  To do this, return true from supportsCustomEditor()\n+ **       and return a Component that does the job.  It is the component's job,\n+ **       or the PropertyEditor's job, to make sure that when the editor changes\n+ **       its value, the PropertyChangeEvent is thrown.</LI>\n+ ** </OL>\n+ **\n+ ** The PropertyEditor for a particular Bean can be found using the\n+ ** PropertyEditorManager class, which goes through a series of different\n+ ** checks to find the appropriate class.<P>\n+ **\n+ ** A PropertyChangeEvent should be thrown from the PropertyEditor whenever a\n+ ** bound  property (a property PropertyDescriptor.isBound() set to true)\n+ ** changes.  When this happens, the editor itself should *not* change the value\n+ ** itself, but rather allow the RAD tool to call setValue() or setAsText().\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 30 June 1998\n+ ** @see java.beans.PropertyEditorManager\n+ ** @see java.beans.PropertyEditorSupport\n+ **/\n+\n+public interface PropertyEditor {\n+\t/** Called by the RAD tool to set the value of this property for the PropertyEditor.\n+\t ** If the property type is native, it should be wrapped in the appropriate\n+\t ** wrapper type.\n+\t ** @param value the value to set this property to.\n+\t **/\n+\tpublic abstract void setValue(Object value);\n+\n+\t/** Accessor method to get the current value the PropertyEditor is working with.\n+\t ** If the property type is native, it will be wrapped in the appropriate\n+\t ** wrapper type.\n+\t ** @return the current value of the PropertyEditor.\n+\t **/\n+\tpublic abstract Object getValue();\n+\n+\n+\t/** Set the value of this property using a String.\n+\t ** Whether or not this PropertyEditor is editing a String type, this converts\n+\t ** the String into the type of the PropertyEditor.\n+\t ** @param text the text to set it to.\n+\t ** @exception IllegalArgumentException if the String is in the wrong format or setAsText() is not supported.\n+\t **/\n+\tpublic abstract void setAsText(String text) throws IllegalArgumentException;\n+\n+\t/** Get the value of this property in String format.\n+\t ** Many times this can simply use Object.toString().<P>\n+\t ** Return null if you do not support getAsText()/setAsText().\n+\t ** <code>setAsText(getAsText())</code> should be valid; i.e. the stuff you spit out in\n+\t ** getAsText() should be able to go into setAsText().\n+\t ** @return the value of this property in String format.\n+\t **/\n+\tpublic abstract String getAsText();\n+\n+\t/** Get a list of possible Strings which this property type can have.\n+\t ** The value of these will be used by the RAD tool to construct some sort\n+\t ** of list box or to check text box input, and the resulting String passed\n+\t ** to setAsText() should be one of these.  Note, however, that like most things\n+\t ** with this mammoth, unwieldy interface, this is not guaranteed.  Thus, you\n+\t ** must check the value in setAsText() anyway.\n+\t ** @return the list of possible String values for this property type.\n+\t **/\n+\tpublic abstract String[] getTags();\n+\n+\n+\t/** The RAD tool calls this to find out whether the PropertyEditor can paint itself.\n+\t ** @return true if it can paint itself graphically, false if it cannot.\n+\t **/\n+\tpublic abstract boolean isPaintable();\n+\n+\t/** The RAD tool calls this to paint the actual value of the property.\n+\t ** The Graphics context will have the same current font, color, etc. as the\n+\t ** parent Container.  You may safely change the font, color, etc. and not\n+\t ** change them back.<P>\n+\t ** This method should do a silent no-op if isPaintable() is false.\n+\t ** @param g the Graphics context to paint on\n+\t ** @param bounds the rectangle you have reserved to work in\n+\t **/\n+\tpublic abstract void paintValue(java.awt.Graphics g, java.awt.Rectangle bounds);\n+\n+\n+\t/** The RAD tool calls this to find out whether the PropertyEditor supports a custom component to edit and display itself.\n+\t ** @return true if getCustomEditor() will return a component, false if not.\n+\t **/\n+\tpublic abstract boolean supportsCustomEditor();\n+\n+\t/** The RAD tool calls this to grab the component that can edit this type.\n+\t ** The component may be painted anywhere the RAD tool wants to paint it--\n+\t ** even in its own window.<P>\n+\t ** The component must hook up with the PropertyEditor and, whenever a\n+\t ** change to the value is made, fire a PropertyChangeEvent to the source.<P>\n+\t ** @return the custom editor for this property type.\n+\t **/\n+\tpublic abstract java.awt.Component getCustomEditor();\n+\n+\n+\t/** Adds a property change listener to this PropertyEditor.\n+\t ** @param listener the listener to add\n+\t **/\n+\tpublic abstract void addPropertyChangeListener(PropertyChangeListener listener);\n+\n+\t/** Removes a property change listener from this PropertyEditor.\n+\t ** @param listener the listener to remove\n+\t **/\n+\tpublic abstract void removePropertyChangeListener(PropertyChangeListener listener);\n+\n+\t/** Get a Java language-specific String which could be used to create an Object\n+\t ** of the specified type.  Every PropertyEditor must support this.<P>\n+\t ** The reason for this is that while most RAD tools will serialize the Beans\n+\t ** and deserialize them at runtime, some RAD tools will generate code that\n+\t ** creates the Beans.  Examples of Java initialization strings would be:<P>\n+\t ** <OL>\n+\t **     <LI><CODE>2</CODE></LI>\n+\t **     <LI><CODE>\"I am a String\"</CODE></LI>\n+\t **     <LI><CODE>new MyObject(2, \"String\", new StringBuffer())</CODE></LI>\n+\t ** </OL>\n+\t ** @return the initialization string for this object in Java.\n+\t **/\n+\tpublic abstract String getJavaInitializationString();\n+}"}, {"sha": "b64b2a83b7c1cc71c5f33b190585ecc3b38a763d", "filename": "libjava/java/beans/PropertyEditorManager.java", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyEditorManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyEditorManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyEditorManager.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,150 @@\n+/* java.beans.PropertyEditorManager\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+import gnu.java.lang.ClassHelper;\n+\n+/**\n+ ** PropertyEditorManager is used to find property editors\n+ ** for various types (not necessarily Beans).<P>\n+ **\n+ ** It first checks to see if the property editor is\n+ ** already registered; if it is, that property editor is\n+ ** used.  Next it takes the type's classname and appends\n+ ** \"Editor\" to it, and searches first in the class's\n+ ** package and then in the property editor search path.<P>\n+ **\n+ ** Default property editors are provided for:<P>\n+ ** <OL>\n+ ** <LI>boolean, byte, short, int, long, float, and double</LI>\n+ ** <LI>java.lang.String</LI>\n+ ** <LI>java.awt.Color</LI>\n+ ** <LI>java.awt.Font</LI>\n+ ** <OL>\n+ **\n+ ** <STRONG>Spec Suggestion:</STRONG> Perhaps an editor for\n+ ** Filename or something like it should be provided.  As well\n+ ** as char.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class PropertyEditorManager {\n+\tstatic java.util.Hashtable editors = new java.util.Hashtable();\n+\tstatic String[] editorSearchPath = {\"gnu.java.beans.editors\",\"sun.beans.editors\"};\n+\n+\tstatic {\n+\t\tregisterEditor(java.lang.Boolean.TYPE, gnu.java.beans.editors.NativeBooleanEditor.class);\n+\t\tregisterEditor(java.lang.Byte.TYPE,    gnu.java.beans.editors.NativeByteEditor.class);\n+\t\tregisterEditor(java.lang.Short.TYPE,   gnu.java.beans.editors.NativeShortEditor.class);\n+\t\tregisterEditor(java.lang.Integer.TYPE, gnu.java.beans.editors.NativeIntEditor.class);\n+\t\tregisterEditor(java.lang.Long.TYPE,    gnu.java.beans.editors.NativeLongEditor.class);\n+\t\tregisterEditor(java.lang.Float.TYPE,   gnu.java.beans.editors.NativeFloatEditor.class);\n+\t\tregisterEditor(java.lang.Double.TYPE,  gnu.java.beans.editors.NativeDoubleEditor.class);\n+\t\tregisterEditor(java.lang.String.class, gnu.java.beans.editors.StringEditor.class);\n+\t\tregisterEditor(java.awt.Color.class,   gnu.java.beans.editors.ColorEditor.class);\n+\t\tregisterEditor(java.awt.Font.class,    gnu.java.beans.editors.FontEditor.class);\n+\t}\n+\n+\t/** Beats me why this class can be instantiated, but there\n+\t ** you have it.\n+\t **/\n+\tpublic PropertyEditorManager() { }\n+\n+\t/** Register an editor for a class.  Replaces old editor\n+\t ** if there was one registered before.\n+\t ** @param editedClass the class that the property editor\n+\t **        will edit.\n+\t ** @param editorClass the PropertyEditor class.\n+\t **/\n+\tpublic static void registerEditor(Class editedClass, Class editorClass) {\n+\t\teditors.put(editedClass, editorClass);\n+\t}\n+\n+\t/** Returns a new instance of the property editor for the\n+\t ** specified class.\n+\t ** @param editedClass the class that the property editor\n+\t **        will edit.\n+\t ** @return a PropertyEditor instance that can edit the\n+\t **         specified class.\n+\t **/\n+\tpublic static PropertyEditor findEditor(Class editedClass) {\n+\t\ttry {\n+\n+\t\tClass found = (Class)editors.get(editedClass);\n+\t\tif(found != null) {\n+\t\t\treturn (PropertyEditor)found.newInstance();\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfound = Class.forName(editedClass.getName()+\"Editor\");\n+\t\t\tregisterEditor(editedClass,found);\n+\t\t\treturn (PropertyEditor)found.newInstance();\n+\t\t} catch(ClassNotFoundException E) {\n+\t\t}\n+\n+\t\tString appendName = \".\" + ClassHelper.getTruncatedClassName(editedClass) + \"Editor\";\n+\t\tsynchronized(editorSearchPath) {\n+\t\t\tfor(int i=0;i<editorSearchPath.length;i++) {\n+\t\t\t\ttry {\n+\t\t\t\t\tfound = Class.forName(editorSearchPath[i] + appendName);\n+\t\t\t\t\tregisterEditor(editedClass,found);\n+\t\t\t\t\treturn (PropertyEditor)found.newInstance();\n+\t\t\t\t} catch(ClassNotFoundException E) {\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t} catch(InstantiationException E) {\n+\t\t} catch(IllegalAccessException E) {\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/** Get the editor search path.\n+\t ** As a minor departure from the spec, the default value\n+\t ** for the editor search path is \"gnu.java.beans.editors\",\n+\t ** \"sun.beans.editors\".\n+\t ** @return the editor search path.\n+\t **/\n+\tpublic static String[] getEditorSearchPath() {\n+\t\treturn editorSearchPath;\n+\t}\n+\n+\t/** Set the editor search path.\n+\t ** @param editorSearchPath the new value for the editor\n+\t **        search path.\n+\t **/\n+\tpublic static void setEditorSearchPath(String[] editorSearchPath) {\n+\t\tsynchronized(editorSearchPath) {\n+\t\t\tPropertyEditorManager.editorSearchPath = editorSearchPath;\n+\t\t}\n+\t}\n+}"}, {"sha": "6fadaccb8c6b9f69e22161c6b0d52f899529d15d", "filename": "libjava/java/beans/PropertyEditorSupport.java", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyEditorSupport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyEditorSupport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyEditorSupport.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,195 @@\n+/* java.beans.PropertyEditorSupport\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/**\n+ ** PropertyEditorSupport helps with PropertyEditors,\n+ ** implementing base functionality that they usually must\n+ ** have but which is a pain to implement.  You may extend\n+ ** from this class or use it as a standalone.<P>\n+ **\n+ ** This class does not do any painting or actual editing.\n+ ** For that, you must use or extend it.  See the\n+ ** PropertyEditor class for better descriptions of what\n+ ** the various methods do.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 29 Jul 1998\n+ **/\n+\n+public class PropertyEditorSupport implements PropertyEditor {\n+\tObject eventSource;\n+\tObject val;\n+\tPropertyChangeSupport pSupport;\n+\n+\t/** Call this constructor when you are deriving from\n+\t ** PropertyEditorSupport.\n+\t **/\n+\tprotected PropertyEditorSupport() {\n+\t\tthis.eventSource = this;\n+\t\tthis.pSupport = new PropertyChangeSupport(this);\n+\t}\n+\n+\t/** Call this constructor when you are using\n+\t ** PropertyEditorSupport as a helper object.\n+\t ** @param eventSource the source to use when firing\n+\t **        property change events.\n+\t **/\n+\tprotected PropertyEditorSupport(Object eventSource) {\n+\t\tthis.eventSource = eventSource;\n+\t\tthis.pSupport = new PropertyChangeSupport(this);\n+\t}\n+\n+\t/** Set the current value of the property.\n+\t ** <STRONG>Implementation Note</STRONG> Sun does not\n+\t ** state what exactly this version of the method does.\n+\t ** Thus, in this implementation, it sets the value, and\n+\t ** then if the old and new values are different, it\n+\t ** fires a property change event with no property name\n+\t ** and the old and new values.\n+\t ** @param val the new value for the property.\n+\t **/\n+\tpublic void setValue(Object val) {\n+\t\tObject oldVal = val;\n+\t\tthis.val = val;\n+\t\tif(!oldVal.equals(val)) {\n+\t\t\tpSupport.firePropertyChange(null,oldVal,val);\n+\t\t}\n+\t}\n+\n+\t/** Get the current value of the property.\n+\t ** @return the current value of the property.\n+\t **/\n+\tpublic Object getValue() {\n+\t\treturn val;\n+\t}\n+\n+\t/** Get whether this object is paintable or not.\n+\t ** @return <CODE>false</CODE>\n+\t **/\n+\tpublic boolean isPaintable() {\n+\t\treturn false;\n+\t}\n+\n+\t/** Paint this object.  This class does nothing in\n+\t ** this method.\n+\t **/\n+\tpublic void paintValue(java.awt.Graphics g, java.awt.Rectangle r) {\n+\t}\n+\n+\t/** Get the Java initialization String for the current\n+\t ** value of the Object.  This class returns gibberish or\n+\t ** null (though the spec does not say which).<P>\n+\t ** <STRONG>Implementation Note:</STRONG> This class\n+\t ** returns the string \"@$#^\" to make sure the code will\n+\t ** be broken, so that you will know to override it when\n+\t ** you create your own property editor.\n+\t ** @return the Java initialization string.\n+\t **/\n+\tpublic String getJavaInitializationString() {\n+\t\treturn \"@$#^\";\n+\t}\n+\n+\t/** Get the value as text.\n+\t ** In this class, you cannot count on getAsText() doing\n+\t ** anything useful, although in this implementation I\n+\t ** do toString().\n+\t ** @return the value as text.\n+\t **/\n+\tpublic String getAsText() {\n+\t\treturn val != null ? val.toString() : \"null\";\n+\t}\n+\n+\t/** Set the value as text.\n+\t ** In this class, you cannot count on setAsText() doing\n+\t ** anything useful across implementations.\n+\t ** <STRONG>Implementation Note:</STRONG> In this\n+\t ** implementation it checks if the String is \"null\", and\n+\t ** if it is, sets the value to null, otherwise it throws\n+\t ** an IllegalArgumentException.\n+\t ** @param s the text to convert to a new value.\n+\t ** @exception IllegalArgumentException if the text is\n+\t **            malformed.\n+\t **/\n+\tpublic void setAsText(String s) throws IllegalArgumentException {\n+\t\tif(s.equals(\"null\")) {\n+\t\t\tsetValue(null);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t}\n+\n+\t/** Returns a list of possible choices for the value.\n+\t ** @return <CODE>null</CODE>\n+\t **/\n+\tpublic String[] getTags() {\n+\t\treturn null;\n+\t}\n+\n+\t/** Return a custom component to edit the value.\n+\t ** @return <CODE>null</CODE> in this class.\n+\t **/\n+\tpublic java.awt.Component getCustomEditor() {\n+\t\treturn null;\n+\t}\n+\n+\t/** Find out whether this property editor supports a\n+\t ** custom component to edit its value.\n+\t ** @return <CODE>false</CODE> in this class.\n+\t **/\n+\tpublic boolean supportsCustomEditor() {\n+\t\treturn false;\n+\t}\n+\n+\t/** Add a property change listener to this property editor.\n+\t ** @param l the listener to add.\n+\t **/\n+\tpublic void addPropertyChangeListener(PropertyChangeListener l) {\n+\t\tpSupport.addPropertyChangeListener(l);\n+\t}\n+\n+\t/** Remove a property change listener from this property editor.\n+\t ** @param l the listener to remove.\n+\t **/\n+\tpublic void removePropertyChangeListener(PropertyChangeListener l) {\n+\t\tpSupport.removePropertyChangeListener(l);\n+\t}\n+\n+\n+\t/** Notify people that we've changed, although we don't\n+\t ** tell them just how.  The only thing I can think of to\n+\t ** send in the event is the new value (since the old value\n+\t ** is unavailable and there is no property name).\n+\t ** I confess I do not understand the point of this method.\n+\t **/\n+\tpublic void firePropertyChange() {\n+\t\tpSupport.firePropertyChange(null,null,val);\n+\t}\n+}\n+"}, {"sha": "51a5642c218b8e1518c1047eabd9aec00b275454", "filename": "libjava/java/beans/PropertyVetoException.java", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyVetoException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FPropertyVetoException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyVetoException.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,55 @@\n+/* java.beans.PropertyVetoException\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/**\n+ ** PropertyVetoException is thrown when a VetoableChangeListener doesn't like the proposed change.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 31 May 1998\n+ ** @see java.beans.VetoableChangeListener\n+ **/\n+\n+public class PropertyVetoException extends Exception {\n+\tPropertyChangeEvent changeEvent;\n+\n+\t/** Instantiate this exception with the given message and property change.\n+\t ** @param msg the reason for the veto.\n+\t ** @param changeEvent the PropertyChangeEvent that was thrown.\n+\t **/\n+\tpublic PropertyVetoException(String msg, PropertyChangeEvent changeEvent) {\n+\t\tsuper(msg);\n+\t\tthis.changeEvent = changeEvent;\n+\t}\n+\n+\t/** Get the PropertyChange event that was vetoed. **/\n+\tpublic PropertyChangeEvent getPropertyChangeEvent() {\n+\t\treturn changeEvent;\n+\t}\n+}"}, {"sha": "e8b677787923315f1ece6fc865733179cdf7a497", "filename": "libjava/java/beans/SimpleBeanInfo.java", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FSimpleBeanInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FSimpleBeanInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FSimpleBeanInfo.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,127 @@\n+/* java.beans.SimpleBeanInfo\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+import java.awt.*;\n+\n+/**\n+ ** SimpleBeanInfo is a class you may extend to more easily\n+ ** provide select information to the Introspector.  It\n+ ** implements all of the methods in BeanInfo by returning\n+ ** null and forces the Introspector to behave exactly as\n+ ** if there were no BeanInfo class at all (Introspecting\n+ ** everything).<P>\n+ **\n+ ** Overriding one or two of these functions\n+ ** to give explicit information on only those things you\n+ ** wish to give explicit information is perfectly safe,\n+ ** and even desirable.<P>\n+ **\n+ ** See the BeanInfo class for information on what the\n+ ** various methods actually do.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.1.0, 29 Jul 1998\n+ ** @see java.beans.BeanInfo\n+ **/\n+\n+public class SimpleBeanInfo implements BeanInfo {\n+\t/** Force Introspection of the general bean info.\n+\t ** @return <CODE>null</CODE>.\n+\t **/\n+\tpublic BeanDescriptor getBeanDescriptor() {\n+\t\treturn null;\n+\t}\n+\n+\t/** Force Introspection of the events this Bean type\n+\t ** fires.\n+\t ** @return <CODE>null</CODE>\n+\t **/\n+\tpublic EventSetDescriptor[] getEventSetDescriptors() {\n+\t\treturn null;\n+\t}\n+\n+\t/** Say that there is no \"default\" event set.\n+\t ** @return <CODE>-1</CODE>.\n+\t **/\n+\tpublic int getDefaultEventIndex() {\n+\t\treturn -1;\n+\t}\n+\n+\t/** Force Introspection of the Bean properties.\n+\t ** @return <CODE>null</CODE>.\n+\t **/\n+\tpublic PropertyDescriptor[] getPropertyDescriptors() {\n+\t\treturn null;\n+\t}\n+\n+\t/** Say that there is no \"default\" property.\n+\t ** @return <CODE>-1</CODE>.\n+\t **/\n+\tpublic int getDefaultPropertyIndex() {\n+\t\treturn -1;\n+\t}\n+\n+\t/** Force Introspection of the Bean's methods.\n+\t ** @return <CODE>null</CODE>.\n+\t **/\n+\tpublic MethodDescriptor[] getMethodDescriptors() {\n+\t\treturn null;\n+\t}\n+\n+\t/** Tell the Introspector to go look for other BeanInfo\n+\t ** itself.\n+\t ** @return <CODE>null</CODE>.\n+\t **/\n+\tpublic BeanInfo[] getAdditionalBeanInfo() {\n+\t\treturn null;\n+\t}\n+\n+\t/** Say that this Bean has no icons.\n+\t ** @param iconType the type of icon\n+\t ** @return <CODE>null</CODE>.\n+\t **/\n+\tpublic Image getIcon(int iconType) {\n+\t\treturn null;\n+\t}\n+\n+\t/** Helper method to load an image using the Bean class\n+\t ** getResource() method on the BeanInfo class (using\n+\t ** getClass(), since you'll extend this class to get\n+\t ** the BeanInfo).  Basically it's assumed that the Bean\n+\t ** and its BeanInfo are both loaded by the same\n+\t ** ClassLoader, generally a reasonable assumption.\n+\t ** @param location the URL relative\n+\t ** @return the Image in question.\n+\t **/\n+\tpublic Image loadImage(String location) {\n+\t\treturn Toolkit.getDefaultToolkit().getImage(getClass().getResource(location));\n+\t}\n+}\n+"}, {"sha": "253d712dcce194a1286e1592a3a9dd3576f26aaf", "filename": "libjava/java/beans/VetoableChangeListener.java", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FVetoableChangeListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FVetoableChangeListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FVetoableChangeListener.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,62 @@\n+/* java.beans.VetoableChangeListener\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/**\n+ ** VetoableChangeListener allows a class to monitor\n+ ** proposed changes to properties of a Bean and, if\n+ ** desired, prevent them from occurring.<P>\n+ **\n+ ** A vetoableChange() event will be fired <EM>before</EM>\n+ ** the property has changed.  If any listener rejects the\n+ ** change by throwing the PropertyChangeException, a new\n+ ** vetoableChange() event will be fired to all listeners\n+ ** who received a vetoableChange() event in the first\n+ ** place informing them of a reversion to the old value.\n+ ** The value, of course, never actually changed.<P>\n+ **\n+ ** <STRONG>Note:</STRONG> This class may not be reliably\n+ ** used to determine whether a property has actually\n+ ** changed.  Use the PropertyChangeListener interface\n+ ** for that instead.\n+ **\n+ ** @author John Keiser\n+ ** @version 1.1.0, 29 Jul 1998\n+ ** @since JDK1.1\n+ ** @see java.beans.PropertyChangeListener\n+ ** @see java.beans.VetoableChangeSupport\n+ **/\n+\n+public interface VetoableChangeListener {\n+\t/** Fired before a Bean's property changes.\n+\t ** @param e the change (containing the old and new values)\n+\t ** @exception PropertyChangeException if the listener\n+\t **            does not desire the change to be made.\n+\t **/\n+\tpublic abstract void vetoableChange(PropertyChangeEvent e) throws PropertyVetoException;\n+}"}, {"sha": "6d0ff0c0acbd353a33d0396fcd13050d0ee3b479", "filename": "libjava/java/beans/VetoableChangeSupport.java", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FVetoableChangeSupport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FVetoableChangeSupport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FVetoableChangeSupport.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,245 @@\n+/*\n+ * java.beans.VetoableChangeSupport: part of the Java Class Libraries project.\n+ * Copyright (C) 1998 Free Software Foundation\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+ * Boston, MA  02111-1307, USA.\n+ */\n+\n+package java.beans;\n+import java.util.Hashtable;\n+import java.util.Vector;\n+\n+/**\n+ ** VetoableChangeSupport makes it easy to fire vetoable\n+ ** change events and handle listeners as well as reversion\n+ ** of old values when things go wrong.\n+ **\n+ ** @author John Keiser\n+ ** @since JDK1.1\n+ ** @version 1.2.0, 15 Mar 1998\n+ **/\n+\n+public class VetoableChangeSupport implements java.io.Serializable {\n+\tHashtable propertyListeners = new Hashtable();\n+\tVector listeners = new Vector();\n+\tObject bean;\n+\n+\t/** Create VetoableChangeSupport to work with a specific\n+\t ** source bean.\n+\t ** @param bean the source bean to use.\n+\t **/\n+\tpublic VetoableChangeSupport(Object bean) {\n+\t\tthis.bean = bean;\n+\t}\n+\n+\t/** Adds a VetoableChangeListener to the list of listeners.\n+\t ** All property change events will be sent to this listener.\n+\t ** <P>\n+\t **\n+\t ** The listener add is not unique: that is, <em>n</em> adds with\n+\t ** the same listener will result in <em>n</em> events being sent\n+\t ** to that listener for every property change.\n+\t ** <P>\n+\t **\n+\t ** Adding a null listener will cause undefined behavior.\n+\t **\n+\t ** @param l the listener to add.\n+\t **/\n+\tpublic void addVetoableChangeListener(VetoableChangeListener l) {\n+\t\tlisteners.addElement(l);\n+\t}\n+\n+\t/** Adds a VetoableChangeListener listening on the specified property.\n+\t ** Events will be sent to the listener for that particular property.\n+\t ** <P>\n+\t **\n+\t ** The listener add is not unique; that is, <em>n</em> adds on a\n+\t ** particular property for a particular listener will result in\n+\t ** <em>n</em> events being sent to that listener when that\n+\t ** property is changed.\n+\t ** <P>\n+\t **\n+\t ** The effect is cumulative, too; if you are registered to listen\n+\t ** to receive events on all property changes, and then you\n+\t ** register on a particular property, you will receive change\n+\t ** events for that property twice.\n+\t ** <P>\n+\t **\n+\t ** Adding a null listener will cause undefined behavior.\n+\t **\n+\t ** @param propertyName the name of the property to listen on.\n+\t ** @param l the listener to add.\n+\t **/\n+\tpublic void addVetoableChangeListener(String propertyName, VetoableChangeListener l) {\n+\t\tsynchronized(propertyListeners) {\n+\t\t\tVector v = (Vector)propertyListeners.get(propertyName);\n+\t\t\ttry {\n+\t\t\t\tv.addElement(l);\n+\t\t\t} catch(NullPointerException e) {\n+\t\t\t\t/* If v is not found, create a new vector. */\n+\t\t\t\tv = new Vector();\n+\t\t\t\tv.addElement(l);\n+\t\t\t\tpropertyListeners.put(propertyName, v);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/** Removes a VetoableChangeListener from the list of listeners.\n+\t ** If any specific properties are being listened on, they must\n+\t ** be deregistered by themselves; this will only remove the\n+\t ** general listener to all properties.\n+\t ** <P>\n+\t **\n+\t ** If <code>add()</code> has been called multiple times for a\n+\t ** particular listener, <code>remove()</code> will have to be\n+\t ** called the same number of times to deregister it.\n+\t **\n+\t ** @param l the listener to remove.\n+\t **/\n+\tpublic void removeVetoableChangeListener(VetoableChangeListener l) {\n+\t\tlisteners.removeElement(l);\n+\t}\n+\n+\t/** Removes a VetoableChangeListener from listening to a specific property.\n+\t ** <P>\n+\t **\n+\t ** If <code>add()</code> has been called multiple times for a\n+\t ** particular listener on a property, <code>remove()</code> will\n+\t ** have to be called the same number of times to deregister it.\n+\t **\n+\t ** @param propertyName the property to stop listening on.\n+\t ** @param l the listener to remove.\n+\t **/\n+\tpublic void removeVetoableChangeListener(String propertyName, VetoableChangeListener l) {\n+\t\tsynchronized(propertyListeners) {\n+\t\t\tVector v = (Vector)propertyListeners.get(propertyName);\n+\t\t\ttry {\n+\t\t\t\tv.removeElement(l);\n+\t\t\t\tif(v.size() == 0) {\n+\t\t\t\t\tpropertyListeners.remove(propertyName);\n+\t\t\t\t}\n+\t\t\t} catch(NullPointerException e) {\n+\t\t\t\t/* if v is not found, do nothing. */\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n+\t/** Fire a VetoableChangeEvent to all the listeners.\n+\t ** If any listener objects, a reversion event will be sent to\n+\t ** those listeners who received the initial event.\n+\t **\n+\t ** @param proposedChange the event to send.\n+\t ** @exception PropertyVetoException if the change is vetoed.\n+\t **/\n+\tpublic void fireVetoableChange(PropertyChangeEvent proposedChange) throws PropertyVetoException {\n+\t\tint currentListener=0;\n+\t\ttry {\n+\t\t\tfor(;currentListener<listeners.size();currentListener++) {\n+\t\t\t\t((VetoableChangeListener)listeners.elementAt(currentListener)).vetoableChange(proposedChange);\n+\t\t\t}\n+\t\t} catch(PropertyVetoException e) {\n+\t\t\tPropertyChangeEvent reversion = new PropertyChangeEvent(proposedChange.getSource(),proposedChange.getPropertyName(),proposedChange.getNewValue(),proposedChange.getOldValue());\n+\t\t\tfor(int sendAgain=0;sendAgain<currentListener;sendAgain++) {\n+\t\t\t\ttry {\n+\t\t\t\t\t((VetoableChangeListener)listeners.elementAt(sendAgain)).vetoableChange(reversion);\n+\t\t\t\t} catch(PropertyVetoException e2) {\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthrow e;\n+\t\t}\n+\n+\t\tVector moreListeners = (Vector)propertyListeners.get(proposedChange.getPropertyName());\n+\t\tif(moreListeners != null) {\n+\t\t\ttry {\n+\t\t\t\tfor(currentListener = 0; currentListener < moreListeners.size(); currentListener++) {\n+\t\t\t\t\t((VetoableChangeListener)moreListeners.elementAt(currentListener)).vetoableChange(proposedChange);\n+\t\t\t\t}\n+\t\t\t} catch(PropertyVetoException e) {\n+\t\t\t\tPropertyChangeEvent reversion = new PropertyChangeEvent(proposedChange.getSource(),proposedChange.getPropertyName(),proposedChange.getNewValue(),proposedChange.getOldValue());\n+\t\t\t\tfor(int sendAgain=0;sendAgain<listeners.size();sendAgain++) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\t((VetoableChangeListener)listeners.elementAt(currentListener)).vetoableChange(proposedChange);\n+\t\t\t\t\t} catch(PropertyVetoException e2) {\t\t\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tfor(int sendAgain=0;sendAgain<currentListener;sendAgain++) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\t((VetoableChangeListener)moreListeners.elementAt(sendAgain)).vetoableChange(reversion);\n+\t\t\t\t\t} catch(PropertyVetoException e2) {\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tthrow e;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/** Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.\n+\t ** If any listener objects, a reversion event will be sent to\n+\t ** those listeners who received the initial event.\n+\t **\n+\t ** @param propertyName the name of the property that\n+\t ** changed.\n+\t ** @param oldVal the old value.\n+\t ** @param newVal the new value.\n+\t ** @exception PropertyVetoException if the change is vetoed.\n+\t **/\n+\tpublic void fireVetoableChange(String propertyName, Object oldVal, Object newVal) throws PropertyVetoException {\n+\t\tfireVetoableChange(new PropertyChangeEvent(bean,propertyName,oldVal,newVal));\n+\t}\n+\n+\t/** Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.\n+\t ** If any listener objects, a reversion event will be sent to\n+\t ** those listeners who received the initial event.\n+\t **\n+\t ** @param propertyName the name of the property that\n+\t ** changed.\n+\t ** @param oldVal the old value.\n+\t ** @param newVal the new value.\n+\t ** @exception PropertyVetoException if the change is vetoed.\n+\t **/\n+\tpublic void fireVetoableChange(String propertyName, boolean oldVal, boolean newVal) throws PropertyVetoException {\n+\t\tfireVetoableChange(new PropertyChangeEvent(bean,propertyName,new Boolean(oldVal),new Boolean(newVal)));\n+\t}\n+\n+\t/** Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.\n+\t ** If any listener objects, a reversion event will be sent to\n+\t ** those listeners who received the initial event.\n+\t **\n+\t ** @param propertyName the name of the property that\n+\t ** changed.\n+\t ** @param oldVal the old value.\n+\t ** @param newVal the new value.\n+\t ** @exception PropertyVetoException if the change is vetoed.\n+\t **/\n+\tpublic void fireVetoableChange(String propertyName, int oldVal, int newVal) throws PropertyVetoException {\n+\t\tfireVetoableChange(new PropertyChangeEvent(bean,propertyName,new Integer(oldVal),new Integer(newVal)));\n+\t}\n+\n+\n+\t/** Tell whether the specified property is being listened on or not.\n+\t ** This will only return <code>true</code> if there are listeners\n+\t ** on all properties or if there is a listener specifically on this\n+\t ** property.\n+\t **\n+\t ** @param propertyName the property that may be listened on\n+\t ** @return whether the property is being listened on\n+\t **/\n+\tpublic boolean hasListeners(String propertyName) {\n+\t\treturn listeners.size() > 0  || propertyListeners.get(propertyName) != null;\n+\t}\n+}"}, {"sha": "ca8c4040cec2fef40ee20423f86685b140fe23d3", "filename": "libjava/java/beans/Visibility.java", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FVisibility.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2FVisibility.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FVisibility.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,74 @@\n+/* java.beans.Visibility\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans;\n+\n+/**\n+ * Visibility is an interface a Bean may implement so that the environment\n+ * can tell the Bean whether there is a GUI or not, and so that the Bean\n+ * can tell the environment whether it needs one or can run without one.\n+ * <P>\n+ *\n+ * Sun decided not to use standard Introspection patterns so that these\n+ * methods did not get included when the Introspector made its sweep on\n+ * the class.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.1\n+ * @version 1.1.0, 29 Jul 1998\n+ */\n+\n+public interface Visibility {\n+\t/**\n+\t * Tells whether the Bean can run without a GUI or not.\n+\t * @return false if Bean can run without a GUI, else true.\n+\t */\n+\tpublic abstract boolean needsGui();\n+\n+\t/**\n+\t * Tells whether Bean is trying not to use the GUI.\n+\t * If needsGui() is true, this method should always return false.\n+\t * @return true if definitely not using GUI, otherwise false.\n+\t */\n+\tpublic abstract boolean avoidingGui();\n+\n+\t/**\n+\t * Tells the Bean not to use GUI methods.\n+\t * If needsGUI() is false, then after this method is called,\n+\t * avoidingGui() should return true.\n+\t */\n+\tpublic abstract void dontUseGui();\n+\n+\t/**\n+\t * Tells the Bean it may use the GUI.\n+\t * The Bean is not required to use the GUI in this case, it is\n+\t * merely being <EM>permitted</EM> to use it.  If needsGui() is\n+\t * false, avoidingGui() may return true or false after this method\n+\t * is called.\n+\t */\n+\tpublic abstract void okToUseGui();\n+}"}, {"sha": "d5274d85593b7a8bd2e549be5ccb421c6dd05bb3", "filename": "libjava/java/beans/beancontext/BeanContext.java", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContext.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,261 @@\n+/* java.beans.beancontext.BeanContext\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.util.Collection;\n+import java.beans.Visibility;\n+import java.beans.DesignMode;\n+import java.net.URL;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+/**\n+ * Acts as a container for sub-beans and as a sub-bean,\n+ * so that an entire hierarchy of beans can be made up of\n+ * <code>BeanContext</code>s.\n+ * <P>\n+ *\n+ * Since I can't sprinkle the <code>Collections</code> interface\n+ * documentation with special information for <code>BeanContext</code>\n+ * implementors, I'll have to document special requirements for\n+ * implementors of those functions here.\n+ * <P>\n+ *\n+ * <code><strong>add()</strong></code> or <code>addAll()</code>:\n+ * <br>\n+ * <OL>\n+ *   <LI>\n+ *     May add any <code>Object</code> into the hierarchy as well as a\n+ *     <code>BeanContextChild</code>, <code>BeanContext</code> or\n+ *     <code>BeanContextProxy</code> object.\n+ *     This way, any Bean can be in the hierarchy.\n+ *   </LI>\n+ *   <LI>\n+ *     Must synchronize on <code>BeanContext.globalHierarchyLock</code>.\n+ *   </LI>\n+ *   <LI>\n+ *     Don't add the <code>Object</code> if it's already there (only once\n+ *     per <code>BeanContext</code>).\n+ *   </LI>\n+ *   <LI>\n+ *     If it is a <code>BeanContextChild</code> implementor, call\n+ *     <code>setBeanContext()</code> on it.  If it's a\n+ *     <code>BeanContextProxy</code> implementor, call\n+ *     <code>getBeanContextProxy().setBeanContext()</code> on it.\n+ *     If <code>setBeanContext()</code> vetoes the change, back out\n+ *     all changes so far and throw <code>IllegalStateException</code>.\n+ *   </LI>\n+ *   <LI>\n+ *     If it (or its proxy) implements <code>Visibility</code>, call\n+ *     <code>dontUseGui()</code> or <code>okToUseGui()</code> on it,\n+ *     depending on whether you (the <code>BeanContext</code>) feel like\n+ *     allowing it to use the GUI or not.\n+ *   </LI>\n+ *   <LI>\n+ *     If it implements <code>BeanContextChild</code> or\n+ *     <code>BeanContextProxy</code>, register yourself (the\n+ *     <code>BeanContext</code>) as both a\n+ *     <code>PropertyChangeListener</code> and\n+ *     <code>VetoableChangeListener</code> on the \"beanContext\"\n+ *     property (it may also add itself on any other properties it wishes\n+ *     to).\n+ *   </LI>\n+ *   <LI>\n+ *     If it is a listener or event source that you (the\n+ *     <code>BeanContext</code>) are interested in, you may register\n+ *     yourself to it or register it to you.\n+ *   </LI>\n+ *   <LI>\n+ *     Fire a <code>java.beans.beancontext.BeanContextMembershipEvent</code>\n+ *     before exiting.  <code>addAll()</code> should wait until everything\n+ *     is done changing before firing the event (or events) so that if a\n+ *     failure occurs, the backing-out process can proceed without any\n+ *     events being fired at all.\n+ *   </LI>\n+ * </OL>\n+ * <P>\n+ *\n+ * <code><strong>remove()</strong></code> or <code>removeAll()</code>:\n+ * <br>\n+ * <OL>\n+ *   <LI>\n+ *     Must synchronize on <code>BeanContext.globalHierarchyLock</code>.\n+ *   </LI>\n+ *   <LI>\n+ *     If the specified <code>Object</code> is not a child of this\n+ *     <code>BeanContext</code>, just exit without performing any actions.\n+ *   </LI>\n+ *   <LI>\n+ *     Remove the <code>Object</code> from your collection of children.\n+ *   </LI>\n+ *   <LI>\n+ *     If it is a <code>BeanContextChild</code> implementor, call\n+ *     <code>setBeanContext(null)</code> on it.  If it's a\n+ *     <code>BeanContextProxy</code> implementor, call\n+ *     <code>getBeanContextProxy().setBeanContext(null)</code> on it.\n+ *     If <code>setBeanContext()</code> vetoes the change, back out\n+ *     all changes so far and throw <code>IllegalStateException</code>.\n+ *   </LI>\n+ *   <LI>\n+ *     If you registered the <code>Object</code> to listen to you or\n+ *     registered yourself as a listener on the <code>Object</code> during\n+ *     <code>add()</code> or <code>addAll()</code>, undo the registration\n+ *     bycalling the appropriate <code>removeListener()</code> method.\n+ *   </LI>\n+ *   <LI>\n+ *     Fire a <code>java.beans.beancontext.BeanContextMembershipEvent</code>\n+ *     before exiting.  <code>removeAll()</code> should wait until\n+ *     everything is done changing before firing the event (or events) so\n+ *     that if a failure occurs, the backing-out process can proceed\n+ *     without any events being fired at all.\n+ *   </LI>\n+ * </OL>\n+ * <P>\n+ *\n+ * <code>addAll()</code>, <code>removeAll()</code>,\n+ * <code>retainAll()</code> and <code>clear()</code> do not need to be\n+ * implemented, but may be if so desired.\n+ * <P>\n+ *\n+ * Similarly, <code>Visibility</code> and <code>DesignMode</code> methods\n+ * should propagate changed values to children that implement interfaces\n+ * of the same name.\n+ * <P>\n+ *\n+ * A hierarchy of beans is mainly useful so that different sets of beans\n+ * can be established, each with their own set of resources.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ */\n+\n+public interface BeanContext\n+\textends Collection, BeanContextChild, Visibility, DesignMode {\n+\n+\t/**\n+\t * The global lock on changing any BeanContext hierarchy.\n+\t * It kinda sucks that there is only one lock, since there can be\n+\t * multiple hierarchies.  Oh well, I didn't design, I just code.\n+\t * <P>\n+\t *\n+\t * Methods that must (or do) synchronize on the global lock:\n+\t * <BR>\n+\t * <UL>\n+\t *   <LI>\n+\t *     Implementors of <CODE>BeanContext.add()</CODE> and <code>addAll()</code>\n+\t *   </LI>\n+\t * </UL>\n+\t * @fixme fill in the rest of the methods which use the global lock.\n+\t */\n+\tpublic static final Object globalHierarchyLock = new Object();\n+\n+\t/** \n+\t * Instantiate a Bean using this Bean's <code>ClassLoader</code>\n+\t * and this <code>BeanContext</code> as the parent.\n+\t * <P>\n+\t *\n+\t * This method exists mainly so that <code>BeanContext</code>\n+\t * implementations can perform extra actions on Beans that are\n+\t * created within them.\n+\t *\n+\t * @param beanName the name of the bean to instantiate\n+\t * @return the created Bean\n+\t *\n+\t * @see java.beans.Beans#instantiate(java.lang.ClassLoader,java.lang.String)\n+\t * @see java.beans.Beans#instantiate(java.lang.ClassLoader,java.lang.String,java.lang.BeanContext)\n+\t * @exception IOException if there is an I/O problem during\n+\t *            instantiation.\n+\t * @exception ClassNotFoundException if a serialized Bean's class\n+\t *            is not found.\n+\t */\n+\tpublic Object instantiateChild(String beanName)\n+                        throws IOException,\n+                               ClassNotFoundException;\n+\n+\t/**\n+\t * Get a resource.  The <code>BeanContext</code> will typically\n+\t * call <code>ClassLoader.getResource()</code>, but may do it any\n+\t * way it wants to.  This allows a <code>BeanContext</code> to\n+\t * have its own set of resources separate from the rest of the\n+\t * system.\n+\t * <P>\n+\t *\n+\t * Beans should call this method on their parent rather than the\n+\t * associated <code>ClassLoader</code> method.\n+\t * <P>\n+\t *\n+\t * I am assuming, but am not entirely sure, that if a\n+\t * <code>BeanContext</code> cannot find a resource, its\n+\t * responsibility is to call the <code>getResource</code> method\n+\t * of its parent <code>BeanContext</code>.\n+\t *\n+\t * @return a URL to the requested resource.\n+\t * @param resourceName the name of the resource requested.\n+\t * @param requestor a reference to the child requesting the resource.\n+\t * @see java.lang.ClassLoader#getResource(java.lang.String)\n+\t */\n+\tpublic URL getResource(String resourceName, BeanContextChild requestor);\n+\n+\t/**\n+\t * Get a resource as a stream.  The <code>BeanContext</code> will\n+\t * typically call <code>ClassLoader.getResourceAsStream()</code>,\n+\t * but may do it any way it wants to.  This allows a\n+\t * <code>BeanContext</code>'s children to have their own set of\n+\t * resources separate from the rest of the system.\n+\t * <P>\n+\t *\n+\t * Beans should call this method on their parent rather than the\n+\t * associated <code>ClassLoader</code> method.\n+\t * <P>\n+\t *\n+\t * I am assuming, but am not entirely sure, that if a\n+\t * <code>BeanContext</code> cannot find a resource, its\n+\t * responsibility is to call the <code>getResourceAsStream</code>\n+\t * method of its parent <code>BeanContext</code>.\n+\t *\n+\t * @return the requested resource as a stream.\n+\t * @param resourceName the name of the resource requested.\n+\t * @param requestor a reference to the child requesting the resource.\n+\t * @see java.lang.ClassLoader#getResourceAsStream(java.lang.String)\n+\t */\n+\tpublic InputStream getResourceAsStream(String resourceName, BeanContextChild requestor);\n+\n+\t/**\n+\t * Add a listener on changes to the membership of this\n+\t * <code>BeanContext</code> object.\n+\t * @param listener the listener to add.\n+\t */\n+\tpublic void addBeanContextMembershipListener(BeanContextMembershipListener listener);\n+\n+\t/**\n+\t * Remove a listener on changes to the membership of this\n+\t * <code>BeanContext</code> object.\n+\t * @param listener the listener to remove.\n+\t */\n+\tpublic void removeBeanContextMembershipListener(BeanContextMembershipListener listener);\n+}"}, {"sha": "d8bcb5ef2fcb7aa934711fe26d4bde5facce8ba8", "filename": "libjava/java/beans/beancontext/BeanContextChild.java", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextChild.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextChild.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextChild.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,162 @@\n+/* java.beans.beancontext.BeanContextChild\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.VetoableChangeListener;\n+import java.beans.PropertyVetoException;\n+\n+/**\n+ * Beans implement this to get information about the execution environment and its services and to be placed in the hierarchy.\n+ * <P>\n+ *\n+ * The difference between a <code>BeanContext</code> and a\n+ * <code>BeanContextChild</code>, mainly, is that a\n+ * <code>BeanContext</code> may be a parent.\n+ * <P>\n+ *\n+ * <code>BeanContextChild</code> instances will be serialized at some\n+ * point in their life, but you need to make sure your bean context does\n+ * not contain a serializable reference (directly or indirectly) to the\n+ * parent <code>BeanContext</code>, to any of the other\n+ * <code>BeanContext</code>s in the tree, or to any resources obtained\n+ * via the <code>BeanContextServices</code> interface.  One way to do this\n+ * is to mark any fields that contain such references as\n+ * <code>transient</code>.  Another way is to use a custom serializer.\n+ * <P>\n+ *\n+ * If you do not do this, when the <code>BeanContext</code> is serialized,\n+ * all the other <code>BeanContext</code>s and other unnecessary things\n+ * will be serialized along with it.\n+ * <P>\n+ *\n+ * Before dying, a <code>BeanContextChild</code> should call\n+ * <code>getBeanContext().remove(this)</code> to detach from the\n+ * hierarchy and exit cleanly.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ * @see java.beans.beancontext.BeanContext\n+ */\n+\n+public interface BeanContextChild {\n+\t/**\n+\t * Set the parent <code>BeanContext</code>.\n+\t * <P>\n+\t *\n+\t * This method is called from <code>BeanContext.add()</code> and\n+\t * should not be called directly.\n+\t * <P>\n+\t *\n+\t * When this Object is being added to a new BeanContext or moved\n+\t * from an old one, a non-null value will be passed in.\n+\t * <P>\n+\t *\n+\t * When this Object is being removed from the current\n+\t * <code>BeanContext</code>, <code>setBeanContext()</code> will\n+\t * receive the parameter <code>null</code>.\n+\t * <P>\n+\t *\n+\t * When being removed from the current <code>BeanContext</code>,\n+\t * it is the <code>BeanContextChild</code>'s responsibility to\n+\t * release all services it has obtained.\n+\t * <P>\n+\t *\n+\t * This change should generate <code>PropertyChangeEvent</code>\n+\t * and <code>VetoableChangeEvent</code>s with the property name\n+\t * \"beanContext\".  If the change is vetoed, it must re-throw the\n+\t * exception and not change anything.  In this way, the parent\n+\t * <code>BeanContextChild</code>, who has registered himself with\n+\t * you, will have a chance to remove this child from its\n+\t * collection.\n+\t * <P>\n+\t *\n+\t * If the Bean does not wish to change the parent or be removed\n+\t * from one, it may throw the <code>PropertyVetoException</code>.\n+\t * If you veto a <code>setBeanContext(null)</code> call, then you\n+\t * should try your hardest to remedy whatever problem is keeping\n+\t * you from being removed from the <code>BeanContext</code> so\n+\t * that you can <em>not</em> veto it the next time.\n+\t * Otherwise, nasty pathological recursion stuff could occur in\n+\t * certain situations.\n+\t * <P>\n+\t *\n+\t * If you do veto the change, you must first back out any changes\n+\t * you made prior to the veto.  Best not to make any such changes\n+\t * prior to the veto in the first place.\n+\t * <P>\n+\t *\n+\t * This method is called from <code>BeanContext.add()</code> and\n+\t * should not be called directly.\n+\t *\n+\t * @param parent the new parent for the <code>BeanContextChild</code>,\n+\t *        or <code>null</code> to signify removal from a tree.\n+\t * @exception PropertyVetoException if the\n+\t *            <code>BeanContextChild</code> implementor does not\n+\t *            wish to have its parent changed.\n+\t */\n+\tpublic void setBeanContext(BeanContext parent)\n+\t\tthrows PropertyVetoException;\n+\n+\t/**\n+\t * Get the parent <code>BeanContext</code>.\n+\t * @return the parent <code>BeanContext</code>.\n+\t */\n+\tpublic BeanContext getBeanContext();\n+\n+\t/**\n+\t * Add a listener that will be notified when a specific property changes.\n+\t * @param prop the name of the property to listen on\n+\t * @param listener the listener to listen on the property.\n+\t */\n+\tpublic void addPropertyChangeListener(String prop, PropertyChangeListener listener);\n+\n+\t/**\n+\t * Remove a listener to a certain property.\n+\t * @param prop the name of the property being listened on\n+\t * @param listener the listener listening on the property.\n+\t */\n+\tpublic void removePropertyChangeListener(String prop, PropertyChangeListener listener);\n+\n+\t/**\n+\t * Add a listener that will be notified when a specific property\n+\t * change is requested (a PropertyVetoException may be thrown) as\n+\t * well as after the change is successfully made.\n+\t *\n+\t * @param prop the name of the property to listen on\n+\t * @param listener the listener to listen on the property.\n+\t */\n+\tpublic void addVetoableChangeListener(String prop, VetoableChangeListener listener);\n+\n+\t/**\n+\t * Remove a listener to a certain property.\n+\t * @param prop the name of the property being listened on\n+\t * @param listener the listener listening on the property.\n+\t */\n+\tpublic void removeVetoableChangeListener(String prop, VetoableChangeListener listener);\n+}"}, {"sha": "f8ef7cacac0b26a813039079786806e25eaff681", "filename": "libjava/java/beans/beancontext/BeanContextChildComponentProxy.java", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextChildComponentProxy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextChildComponentProxy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextChildComponentProxy.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,49 @@\n+/* java.beans.beancontext.BeanContextChildComponentProxy\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.awt.Component;\n+\n+/**\n+ * Interface for <code>BeanContextChild</code>s which wish to associate an\n+ * AWT component with them.  The proxy is provided because the\n+ * <code>addPropertyChangeListener()</code> method would conflict with\n+ * <code>Component</code> if you tried to extend.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ */\n+\n+public interface BeanContextChildComponentProxy {\n+\t/**\n+\t * Get the <code>Component</code> associated with this <code>BeanContextChild</code>.\n+\t * @return the <code>Component</code> associated with this\n+\t * <code>BeanContextChild</code>.\n+\t */\n+\tpublic Component getComponent();\n+}"}, {"sha": "08d2a718ea4c5633f3308408cda8377167b93e09", "filename": "libjava/java/beans/beancontext/BeanContextChildSupport.java", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextChildSupport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextChildSupport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextChildSupport.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,356 @@\n+/* java.beans.beancontext.BeanContextChildSupport\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.VetoableChangeListener;\n+import java.beans.PropertyVetoException;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeSupport;\n+import java.beans.VetoableChangeSupport;\n+import java.io.Serializable;\n+\n+/**\n+ * Support for creating a <code>BeanContextChild</code>.\n+ * This class contains the most common implementations of the methods in\n+ * the <code>BeanContextChild</code>\n+ *\n+ * @specnote This class is not very well specified.  I had to \"fill in the\n+ *           blanks\" in most places with what I thought was reasonable\n+ *           behavior.  If there are problems, let me know.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ * @see java.beans.beancontext.BeanContextChild\n+ */\n+\n+public class BeanContextChildSupport implements BeanContextChild, BeanContextServicesListener, Serializable {\n+\t/**\n+\t * The peer on which to perform <code>set</code> actions.\n+\t * This is here so that this class can be used as a peer.\n+\t * <P>\n+\t *\n+\t * When extending this class, this variable will be set to\n+\t * <code>this</code>.\n+\t */\n+\tpublic BeanContextChild beanContextChildPeer;\n+\n+\t/**\n+\t * The parent <code>BeanContext</code>.\n+\t */\n+\tprotected transient BeanContext beanContext;\n+\n+\t/**\n+\t * If <code>setBeanContext()</code> was vetoed once before, this\n+\t * is set to <code>true</code> so that the next time, vetoes will\n+\t * be ignored.\n+\t */\n+\tprotected transient boolean rejectedSetBCOnce;\n+\n+\t/**\n+\t * Listeners are registered here and events are fired through here.\n+\t */\n+\tprotected PropertyChangeSupport pcSupport;\n+\n+\t/**\n+\t * Listeners are registered here and events are fired through here.\n+\t */\n+\tprotected VetoableChangeSupport vcSupport;\n+\n+\n+\t/**\n+\t * Create a new <code>BeanContextChildSupport</code> with itself as the peer.\n+\t * This is meant to be used when you subclass\n+\t * <code>BeanContextChildSupport</code> to create your child.\n+\t */\n+\tpublic BeanContextChildSupport() {\n+\t\tthis(null);\n+\t};\n+\n+\t/**\n+\t * Create a new <code>BeanContextChildSupport</code> with the specified peer.\n+\t * @param peer the peer to use, or <code>null</code> to specify\n+\t *        <code>this</code>.\n+\t */\n+\tpublic BeanContextChildSupport(BeanContextChild peer) {\n+\t\tif(peer == null) {\n+\t\t\tpeer = this;\n+\t\t}\n+\n+\t\tbeanContextChildPeer = peer;\n+\t\tpcSupport = new PropertyChangeSupport(peer);\n+\t\tvcSupport = new VetoableChangeSupport(peer);\n+\t}\n+\n+\t/**\n+\t * Set the parent <code>BeanContext</code>.\n+\t * <P>\n+\t *\n+\t * When this Object is being added to a new BeanContext or moved\n+\t * from an old one, a non-null value will be passed in.\n+\t * <P>\n+\t *\n+\t * When this Object is being removed from the current\n+\t * <code>BeanContext</code>, <code>setBeanContext()</code> will\n+\t * receive the parameter <code>null</code>.\n+\t * <P>\n+\t *\n+\t * Order of events:\n+\t * <OL>\n+\t *   <LI>\n+\t *     If the new <code>BeanContext</code> is the same as the old\n+\t *     one, nothing happens.\n+\t *   </LI>\n+\t *   <LI>\n+\t *     If the change has not been rejected or vetoed before, call\n+\t *     <code>validatePendingSetBeanContext()</code>.  If this call\n+\t *     returns <code>false</code>, the change is rejected and a\n+\t *     <code>PropertyVetoException</code> is thrown.\n+\t *   </LI>\n+\t *   <LI>\n+\t *     If the change has not been rejected or vetoed before,\n+\t *     <code>VetoableChangeEvent</code>s are fired with the name\n+\t *     <code>\"beanContext\"</code>, using the\n+\t *     <code>fireVetoableChange()</code> method.  If a veto\n+\t *     occurs, reversion events are fired using the same method,\n+\t *     the change is rejected, and the veto is rethrown.\n+\t *   </LI>\n+\t *   <LI>\n+\t *     <code>releaseBeanContextResources()</code> is called.\n+\t *   </LI>\n+\t *   <LI>\n+\t *     The change is made.\n+\t *   </LI>\n+\t *   <LI>\n+\t *     <code>PropertyChangeEvent</code>s are fired using the\n+\t *     <code>firePropertyChange()</code> method.\n+\t *   </LI>\n+\t *   <LI>\n+\t *     <code>initializeBeanContextResources()</code> is called.\n+\t *   </LI>\n+\t * </OL>\n+\t * <P>\n+\t *\n+\t * @param newBeanContext the new parent for the\n+\t *        <code>BeanContextChild</code>, or <code>null</code> to\n+\t *        signify removal from a tree.\n+\t * @exception PropertyVetoException if the\n+\t *            <code>BeanContextChild</code> implementor does not\n+\t *            wish to have its parent changed.\n+\t */\n+\tpublic void setBeanContext(BeanContext newBeanContext)\n+\t\tthrows PropertyVetoException {\n+\t\tsynchronized(beanContextChildPeer) {\n+\t\t\tif(newBeanContext == beanContext)\n+\t\t\t\treturn;\n+\n+\t\t\tif(!rejectedSetBCOnce) {\n+\t\t\t\tif(!validatePendingSetBeanContext(newBeanContext)) {\n+\t\t\t\t\trejectedSetBCOnce = true;\n+\t\t\t\t\tthrow new PropertyVetoException(\"validatePendingSetBeanContext() rejected change\",\n+\t\t\t\t\t\tnew PropertyChangeEvent(beanContextChildPeer, \"beanContext\", beanContext, newBeanContext));\n+\t\t\t\t}\n+\t\t\t\ttry {\n+\t\t\t\t\tfireVetoableChange(\"beanContext\", beanContext, newBeanContext);\n+\t\t\t\t} catch(PropertyVetoException e) {\n+\t\t\t\t\trejectedSetBCOnce = true;\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treleaseBeanContextResources();\n+\n+\t\t\tbeanContext = newBeanContext;\n+\t\t\trejectedSetBCOnce = false;\n+\n+\t\t\tfirePropertyChange(\"beanContext\", beanContext, newBeanContext);\n+\n+\t\t\tinitializeBeanContextResources();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the parent <code>BeanContext</code>.\n+\t * @return the parent <code>BeanContext</code>.\n+\t */\n+\tpublic BeanContext getBeanContext() {\n+\t\treturn beanContext;\n+\t}\n+\n+\t/**\n+\t * Get the peer (or <code>this</code> if there is no peer).\n+\t * @return the peer, or <code>this</code> if there is no peer.\n+\t */\n+\tpublic BeanContextChild getBeanContextChildPeer() {\n+\t\treturn beanContextChildPeer;\n+\t}\n+\n+\t/**\n+\t * Determine whether there is a peer.\n+\t * This is true iff <code>getBeanContextChildPeer() == this</code>.\n+\t * @return whether there is a peer.\n+\t */\n+\tpublic boolean isDelegated() {\n+\t\treturn beanContextChildPeer == this;\n+\t}\n+\n+\t/**\n+\t * Add a listener that will be notified when a specific property changes.\n+\t * @param propertyName the name of the property to listen on.\n+\t * @param listener the listener to listen on the property.\n+\t */\n+\tpublic void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {\n+\t\tpcSupport.addPropertyChangeListener(propertyName, listener);\n+\t}\n+\n+\t/**\n+\t * Remove a listener to a certain property.\n+\t * \n+\t * @param propertyName the name of the property being listened on.\n+\t * @param listener the listener listening on the property.\n+\t */\n+\tpublic void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) {\n+\t\tpcSupport.removePropertyChangeListener(propertyName, listener);\n+\t}\n+\n+\t/**\n+\t * Add a listener that will be notified when a specific property\n+\t * change is requested (a PropertyVetoException may be thrown) as\n+\t * well as after the change is successfully made.\n+\t *\n+\t * @param propertyName the name of the property to listen on.\n+\t * @param listener the listener to listen on the property.\n+\t */\n+\tpublic void addVetoableChangeListener(String propertyName, VetoableChangeListener listener) {\n+\t\tvcSupport.addVetoableChangeListener(propertyName, listener);\n+\t}\n+\n+\t/**\n+\t * Remove a listener to a certain property.\n+\t *\n+\t * @param propertyName the name of the property being listened on\n+\t * @param listener the listener listening on the property.\n+\t */\n+\tpublic void removeVetoableChangeListener(String propertyName, VetoableChangeListener listener) {\n+\t\tvcSupport.removeVetoableChangeListener(propertyName, listener);\n+\t}\n+\n+\t/**\n+\t * Fire a property change.\n+\t *\n+\t * @param propertyName the name of the property that changed\n+\t * @param oldVal the old value of the property\n+\t * @param newVal the new value of the property\n+\t */\n+\tpublic void firePropertyChange(String propertyName, Object oldVal, Object newVal) {\n+\t\tpcSupport.firePropertyChange(propertyName, oldVal, newVal);\n+\t}\n+\n+\t/**\n+\t * Fire a vetoable property change.\n+\t *\n+\t * @param propertyName the name of the property that changed\n+\t * @param oldVal the old value of the property\n+\t * @param newVal the new value of the property\n+\t * @exception PropertyVetoException if the change is vetoed.\n+\t */\n+\tpublic void fireVetoableChange(String propertyName, Object oldVal, Object newVal)\n+                        throws PropertyVetoException {\n+\t\tvcSupport.fireVetoableChange(propertyName, oldVal, newVal);\n+\t}\n+\n+\t/**\n+\t * Called by <code>BeanContextServices.revokeService()</code> to indicate that a service has been revoked.\n+\t * If you have a reference to such a service, it should be\n+\t * discarded and may no longer function properly.\n+\t * <code>getService()</code> will no longer work on the specified\n+\t * service class after this event has been fired.\n+\t * <P>\n+\t *\n+\t * <EM>This method is meant to be overriden.</EM>\n+\t * <code>BeanContextChildSupport</code>'s implementation does\n+\t * nothing.\n+\t *\n+\t * @param event the service revoked event.\n+\t * @see java.beans.beancontext.BeanContextServices#revokeService(java.lang.Class,java.beans.beancontext.BeanContextServiceProvider,boolean)\n+\t */\n+\tpublic void serviceRevoked(BeanContextServiceRevokedEvent event) {\n+\t}\n+\n+\t/**\n+\t * Called by <code>BeanContextServices</code> whenever a service is made available.\n+\t * <P>\n+\t *\n+\t * <EM>This method is meant to be overriden.</EM>\n+\t * <code>BeanContextChildSupport</code>'s implementation does\n+\t * nothing.\n+\t *\n+\t * @param event the service revoked event, with useful information\n+\t *        about the new service.\n+\t */\n+\tpublic void serviceAvailable(BeanContextServiceAvailableEvent event) {\n+\t}\n+\n+\t/**\n+\t * Called by <code>setBeanContext()</code> to determine whether the set should be rejected.\n+\t * <P>\n+\t *\n+\t * <EM>This method is meant to be overriden.</EM>\n+\t * <code>BeanContextChildSupport</code>'s implementation simply\n+\t * returns <code>true</code>.\n+\t *\n+\t * @param newBeanContext the new parent.\n+\t * @return whether to allow the parent to be changed to the new\n+\t *         value.\n+\t */\n+\tpublic boolean validatePendingSetBeanContext(BeanContext newBeanContext) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Called by <code>setBeanContext()</code> to release resources of a what will soon no longer be the parent.\n+\t * <P>\n+\t *\n+\t * <EM>This method is meant to be overriden.</EM>\n+\t * <code>BeanContextChildSupport</code>'s implementation does\n+\t * nothing.\n+\t */\n+\tprotected void releaseBeanContextResources() {\n+\t}\n+\n+\t/**\n+\t * Called by <code>setBeanContext()</code> to grab resources when the parent has been set.\n+\t * <P>\n+\t *\n+\t * <EM>This method is meant to be overriden.</EM>\n+\t * <code>BeanContextChildSupport</code>'s implementation does\n+\t * nothing.\n+\t */\n+\tprotected void initializeBeanContextResources() {\n+\t}\n+}"}, {"sha": "28d967b06d0b54be4ac76a31f90b63d064181507", "filename": "libjava/java/beans/beancontext/BeanContextContainerProxy.java", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextContainerProxy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextContainerProxy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextContainerProxy.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,52 @@\n+/* java.beans.beancontext.BeanContextContainerProxy\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.awt.Container;\n+\n+/**\n+ * Interface for <code>BeanContext</code>s which wish to associate an\n+ * AWT container with them.  The proxy is provided because the\n+ * <code>addPropertyChangeListener()</code> and <code>add()</code> methods\n+ * would conflict with <code>Component</code> and <code>Container</code>\n+ * if you tried to extend.\n+ *\n+ * @specnote It is unclear whether anything besides <code>BeanContext</code>s\n+ *           are allowed to implement this interface.\n+ * @author John Keiser\n+ * @since JDK1.2\n+ */\n+\n+public interface BeanContextContainerProxy {\n+\t/**\n+\t * Get the <code>Container</code> associated with this <code>BeanContext</code>.\n+\t * @return the <code>Container</code> associated with this\n+\t * <code>BeanContext</code>.\n+\t */\n+\tpublic Container getContainer();\n+}"}, {"sha": "0e4f20ae1ec3eb1e966f7b44168f0f06c0cf5378", "filename": "libjava/java/beans/beancontext/BeanContextEvent.java", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextEvent.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,91 @@\n+/* java.beans.beancontext.BeanContextEvent\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.util.EventObject;\n+\n+/**\n+ * Generic superclass for events fired by <code>BeanContext</code>s.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ */\n+\n+public abstract class BeanContextEvent extends EventObject {\n+\t/**\n+\t * The <code>BeanContext</code> that most recently passed this\n+\t * event on.\n+\t */\n+\tprotected BeanContext propagatedFrom;\n+\n+\t/**\n+\t * Create a new event, from the specified <code>BeanContext</code>.\n+\t * <code>propagatedFrom</code> will be initialized to\n+\t * <code>null</code>.\n+\t *\n+\t * @param source the source of the event.\n+\t */\n+\tprotected BeanContextEvent(BeanContext source) {\n+\t\tsuper(source);\n+\t}\n+\n+\t/**\n+\t * Get the <code>BeanContext</code> that originated this event.\n+\t * @return the originator of this event.\n+\t */\n+\tpublic BeanContext getBeanContext() {\n+\t\treturn (BeanContext)getSource();\n+\t}\n+\n+\t/**\n+\t * Get the most recent propagator of this event.\n+\t * If this value is <code>null</code>, you have received the event\n+\t * straight from the source.\n+\t *\n+\t * @return the most recent propagator of this event.\n+\t */\n+\tpublic BeanContext getPropagatedFrom() {\n+\t\treturn propagatedFrom;\n+\t}\n+\n+\t/**\n+\t * Tell whether this event has been propagated.\n+\t * @return <code>true</code> iff <code>getPropagatedFrom() != null</code>.\n+\t */\n+\tpublic boolean isPropagated() {\n+\t\treturn propagatedFrom != null;\n+\t}\n+\n+\t/**\n+\t * Set the most recent propagator of this event.\n+\t * @param propagator the most recent propagator of this event.\n+\t */\n+\tpublic void setPropagatedFrom(BeanContext propagator) {\n+\t\tpropagatedFrom = propagator;\n+\t}\n+}"}, {"sha": "d808735575b4fe386107132d3ec2f1bdda01fc08", "filename": "libjava/java/beans/beancontext/BeanContextMembershipEvent.java", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextMembershipEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextMembershipEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextMembershipEvent.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,102 @@\n+/* java.beans.beancontext.BeanContextMembershipEvent\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.util.Collection;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+\n+/**\n+ * Event fired when children are added to or removed from a <code>BeanContext</code>.\n+ * Whether they were added or removed depends entirely on which method\n+ * of the listener interface was called.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ * @see java.beans.beancontext.BeanContextMembershipListener\n+ */\n+\n+public class BeanContextMembershipEvent extends BeanContextEvent {\n+\t/**\n+\t * The children that were added or removed.\n+\t */\n+\tprotected Collection children;\n+\n+\t/**\n+\t * Create a new membership event.\n+\t * @param context the event source.\n+\t * @param children the children added to or removed from the source.\n+\t */\n+\tpublic BeanContextMembershipEvent(BeanContext context, Collection children) {\n+\t\tsuper(context);\n+\t\tthis.children = children;\n+\t}\n+\n+\t/**\n+\t * Create a new membership event.\n+\t * @param context the event source.\n+\t * @param children the children added to or removed from the source.\n+\t */\n+\tpublic BeanContextMembershipEvent(BeanContext context, Object[] children) {\n+\t\tsuper(context);\n+\t\tthis.children = Arrays.asList(children);\n+\t}\n+\n+\t/**\n+\t * The number of children removed or added.\n+\t * @return the number of children removed or added.\n+\t */\n+\tpublic int size() {\n+\t\treturn children.size();\n+\t}\n+\n+\t/**\n+\t * An iterator that will step through all the children.\n+\t * @return an iterator over all the children.\n+\t */\n+\tpublic Iterator iterator() {\n+\t\treturn children.iterator();\n+\t}\n+\n+\t/**\n+\t * An array of the children.\n+\t * @return an array of the children.\n+\t */\n+\tpublic Object[] toArray() {\n+\t\treturn children.toArray();\n+\t}\n+\n+\t/**\n+\t * Tell whether the <code>Object</code> is one of the children added or removed.\n+\t * @param child the child to check.\n+\t * @return whether the <code>Object</code> is added or removed.\n+\t */\n+\tpublic boolean contains(Object child) {\n+\t\treturn children.contains(child);\n+\t}\n+}"}, {"sha": "fc0b5b6b4b31197e9d34ac82c797303bfcb8cfbf", "filename": "libjava/java/beans/beancontext/BeanContextMembershipListener.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextMembershipListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextMembershipListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextMembershipListener.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,59 @@\n+/* java.beans.beancontext.BeanContextMembershipListener\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * This is the interface to which <code>BeanContextMembershipEvent</code>s are sent.\n+ * This happens when children are added to or removed from a\n+ * <code>BeanContext</code>.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ */\n+\n+public interface BeanContextMembershipListener extends EventListener {\n+\t/**\n+\t * When beans are added to a <code>BeanContext</code>,\n+\t * this method is called to fire the event.\n+\t *\n+\t * @param event the event, including which children were added.\n+\t * @see java.beans.beancontext.BeanContext#add(java.lang.Object)\n+\t */\n+\tpublic void childrenAdded(BeanContextMembershipEvent event);\n+\n+\t/**\n+\t * When beans are removed from a <code>BeanContext</code>,\n+\t * this method is called to fire the event.\n+\t *\n+\t * @param event the event, including which children were removed.\n+\t * @see java.beans.beancontext.BeanContext#remove(java.lang.Object)\n+\t */\n+\tpublic void childrenRemoved(BeanContextMembershipEvent event);\n+}"}, {"sha": "129e4f8748579524035b24eb71e038a6a62fc20a", "filename": "libjava/java/beans/beancontext/BeanContextProxy.java", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextProxy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextProxy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextProxy.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,54 @@\n+/* java.beans.beancontext.BeanContextProxy\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+/**\n+ * Beans that wish to have a <code>BeanContextChild</code> or <code>BeanContext</code> associated with them\n+ * but do not wish to implement those interfaces directly, can implement this interface.\n+ * <P>\n+ *\n+ * Don't shoot yourself in the foot: if you already implement\n+ * <code>BeanContextChild</code>, directly or indirectly, the whole\n+ * workings of this package will be unpredictable because it is\n+ * indeterminate as to whether the <code>BeanContextChild</code> is used\n+ * in preference to its proxy or vice versa.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ */\n+\n+public interface BeanContextProxy {\n+\t/**\n+\t * Return the <code>BeanContextChild</code> associated with this\n+\t * <code>Object</code>.\n+\t *\n+\t * @return the <code>BeanContextChild</code> associated with this\n+\t * <code>Object</code>.\n+\t */\n+\tpublic BeanContextChild getBeanContextProxy();\n+}"}, {"sha": "933ef3d7f881ae67ca6feeee20036a68ae6a3734", "filename": "libjava/java/beans/beancontext/BeanContextServiceAvailableEvent.java", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceAvailableEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceAvailableEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceAvailableEvent.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,84 @@\n+/* java.beans.beancontext.BeanContextServiceAvailableEvent\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Event fired when new services become available through a <code>BeanContextServices</code>.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ * @see java.beans.beancontext.BeanContextServicesListener\n+ */\n+\n+public class BeanContextServiceAvailableEvent extends BeanContextEvent {\n+\t/**\n+\t * The <code>Class</code> representing the service which is now\n+\t * available.\n+\t */\n+\tprotected Class serviceClass;\n+\n+\t/**\n+\t * Create a new service available event.\n+\t * @param services the <code>BeanContextServices</code> through\n+\t *        which the service is available.  This is also the source\n+\t *        of the event.\n+\t * @param serviceClass the service class that is now available.\n+\t */\n+\tpublic BeanContextServiceAvailableEvent(BeanContextServices services, Class serviceClass) {\n+\t\tsuper(services);\n+\t\tthis.serviceClass = serviceClass;\n+\t}\n+\n+\t/**\n+\t * Get the current service selectors of the service class.\n+\t * This is identical to <code>getSourceAsBeanContextServices().getCurrentServiceSelectors(getServiceClass())</code>\n+\t * @return the current service selectors of the service class.\n+\t */\n+\tpublic Iterator getCurrentServiceSelectors() {\n+\t\treturn getSourceAsBeanContextServices().getCurrentServiceSelectors(serviceClass);\n+\t}\n+\n+\t/**\n+\t * Get the newly available service class.\n+\t * @return the service class.\n+\t */\n+\tpublic Class getServiceClass() {\n+\t\treturn serviceClass;\n+\t}\n+\n+\t/**\n+\t * Get the <code>BeanContextServices</code> through which the new service is available.\n+\t * @return the <code>BeanContextServices</code> through which the\n+\t *         new service is available.\n+\t */\n+\tpublic BeanContextServices getSourceAsBeanContextServices() {\n+\t\treturn (BeanContextServices)getSource();\n+\t}\n+}"}, {"sha": "c7a570e355ed5dd6324b9abe616c31c62cf858d6", "filename": "libjava/java/beans/beancontext/BeanContextServiceProvider.java", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceProvider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceProvider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceProvider.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,129 @@\n+/* java.beans.beancontext.BeanContextServiceProvider\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * An actual factory for services.\n+ * <P>\n+ *\n+ * It is the <code>BeanContextServiceProvider</code>'s responsibility to\n+ * register itself with whatever <code>BeanContextServices</code> object\n+ * it wishes to provide services through using the\n+ * <code>addService()</code> method.\n+ * <P>\n+ *\n+ * If for some reason it can no longer provide services for a particular\n+ * class, this class must invoke\n+ * <code>BeanContextServices.revokeService(serviceClass,this,true)</code>\n+ * for all the places it has registered the service.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ */\n+\n+public interface BeanContextServiceProvider {\n+\t/**\n+\t * Get a service.\n+\t * Called from <code>BeanContextServices.getService().\n+\t * <P>\n+\t *\n+\t * If the requested service class is not available, or if this\n+\t * <code>BeanContextServiceProvider</code> chooses not honor the\n+\t * request for some reason, then this method will return\n+\t * <code>null</code>.\n+\t * <P>\n+\t *\n+\t * This method may throw unchecked exceptions, so watch out.\n+\t *\n+\t * @param services the <code>BeanContextServices</code> that wants\n+\t *        to get the service.  Only weak references to this will\n+\t *        be retained, and it will never be changed, only queried\n+\t *        in a read-only manner.\n+\t * @param requestor the actual requestor of the service.  Only\n+\t *        weak references to this will be retained, and it will\n+\t *        never be changed, only queried in a read-only manner.\n+\t * @param serviceClass the <code>Class</code> of the service being\n+\t *        requested.\n+\t * @param serviceSelector a parameter to customize the service\n+\t *        returned with.\n+\t * @return an instance of <code>serviceClass</code> (such that\n+\t *        <code>instanceof</code> serviceClass is true), or\n+\t *        <code>null</code>.\n+\t * @see java.beans.beancontext.BeanContextServices#getService(java.beans.beancontext.BeanContextChild,java.lang.Object,java.lang.Class,java.lang.Object,java.beans.beancontext.BeanContextServiceRevokedListener)\n+\t */\n+\tpublic Object getService(BeanContextServices services, Object requestor, Class serviceClass, Object serviceSelector);\n+\n+\t/**\n+\t * Release the service.\n+\t * <P>\n+\t *\n+\t * Called by <code>BeanContextServices.releaseService()</code>.\n+\t * <P>\n+\t *\n+\t * Most <code>BeanContextServiceProvider</code>s won't have to do\n+\t * anything here.\n+\t *\n+\t * @param services the <code>BeanContextServices</code> that wants\n+\t *        to release the service.  Only weak references to this will\n+\t *        be retained, and it will never be changed, only queried\n+\t *        in a read-only manner.\n+\t * @param requestor the original requestor of the service.\n+\t * @param service the service to relinquish\n+\t * @see java.beans.beancontext.BeanContextServices#releaseService(java.beans.beancontext.BeanContextChild,java.lang.Object,java.lang.Object)\n+\t */\n+\tpublic void releaseService(BeanContextServices services, Object requestor, Object service);\n+\n+\t/**\n+\t * Get a list of valid service selectors for the specified service class.\n+\t * This method is called from\n+\t * <code>BeanContextServices.getCurrentServiceSelectors()</code>.\n+\t * <P>\n+\t *\n+\t * If the specified service class does not have a finite number of\n+\t * valid service selectors, it should return <code>null</code>.\n+\t * If it takes a general <code>Integer</code> parameter, for\n+\t * example, you may as well return <code>null</code> or the poor\n+\t * soul who called this method will be iterating all day.\n+\t * <P>\n+\t *\n+\t * If it has no valid service selectors, it should still return an empty\n+\t * <code>Iterator</code>.\n+\t *\n+\t * @param services the <code>BeanContextServices</code> that wants\n+\t *        to get the service selectors.  Only weak references to this will\n+\t *        be retained, and it will never be changed, only queried\n+\t *        in a read-only manner.\n+\t * @param serviceClass the service class to get selectors for.\n+\t * @return a list of valid service selectors for the service\n+\t *         class, or <code>null</code>.\n+\t * @see java.beans.beancontext.BeanContextServices#getCurrentServiceSelectors(java.lang.Class)\n+\t */\n+\tpublic Iterator getCurrentServiceSelectors(BeanContextServices services, Class serviceClass);\n+}"}, {"sha": "d751f70c674365308d326b8def9b1cb99eb8123f", "filename": "libjava/java/beans/beancontext/BeanContextServiceProviderBeanInfo.java", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceProviderBeanInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceProviderBeanInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceProviderBeanInfo.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,49 @@\n+/* java.beans.beancontext.BeanContextServiceProviderBeanInfo\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.beans.BeanInfo;\n+\n+/**\n+ * <code>BeanContextServiceProvider</code>s implement this to provide information about all of the services they provide.\n+ * <P>\n+ *\n+ * This is apparently so that you can import a bunch of services into a\n+ * RAD tool and it will know about all of them and export them to the\n+ * user in a readable manner.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ */\n+public interface BeanContextServiceProviderBeanInfo extends BeanInfo {\n+\t/**\n+\t * Get <code>BeanInfo</code>s for all of the service classes of this <code>BeanInfoServiceProvider</code>.\n+\t * @return <code>BeanInfo</code>s for all provided service classes.\n+\t */\n+\tpublic BeanInfo[] getServicesBeanInfo();\n+}"}, {"sha": "32520bc39fd1c336ca6ab999bbe1fcc1f5890f5f", "filename": "libjava/java/beans/beancontext/BeanContextServiceRevokedEvent.java", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceRevokedEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceRevokedEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceRevokedEvent.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,99 @@\n+/* java.beans.beancontext.BeanContextServiceRevokedEvent\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+/**\n+ * Event fired when services are revoked from a <code>BeanContextServices</code>.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ * @see java.beans.beancontext.BeanContextServiceRevokedListener\n+ */\n+\n+public class BeanContextServiceRevokedEvent extends BeanContextEvent {\n+\t/**\n+\t * The <code>Class</code> representing the service which is now\n+\t * available.\n+\t */\n+\tprotected Class serviceClass;\n+\tprivate boolean revokeNow;\n+\n+\t/**\n+\t * Create a new service revoked event.\n+\t * @param services the <code>BeanContextServices</code> through\n+\t *        which the service was available.  This is also the source\n+\t *        of the event.\n+\t * @param serviceClass the service class that is now revoked.\n+\t * @param revokeNow whether the revocation is immediate for all\n+\t *        classes or just a suggestion.\n+\t */\n+\tpublic BeanContextServiceRevokedEvent(BeanContextServices services, Class serviceClass, boolean revokeNow) {\n+\t\tsuper(services);\n+\t\tthis.serviceClass = serviceClass;\n+\t\tthis.revokeNow = revokeNow;\n+\t}\n+\n+\t/**\n+\t * Get the revoked service class.\n+\t * @return the service class.\n+\t */\n+\tpublic Class getServiceClass() {\n+\t\treturn serviceClass;\n+\t}\n+\n+\t/**\n+\t * Tell whether the revoked service class is the same as the specified class.\n+\t * Identical to <code>getServiceClass().equals(c)</code>.\n+\t * @param c the class to compare.\n+\t * @return whether the clases are equal.\n+\t */\n+\tpublic boolean isServiceClass(Class c) {\n+\t\treturn serviceClass.equals(c);\n+\t}\n+\n+\t/**\n+\t * Get the <code>BeanContextServices</code> through which the service was available.\n+\t * @return the <code>BeanContextServices</code> through which the\n+\t *         service was available.\n+\t */\n+\tpublic BeanContextServices getSourceAsBeanContextServices() {\n+\t\treturn (BeanContextServices)getSource();\n+\t}\n+\n+\t/**\n+\t * Tell whether current instances of the revoked service are usable or not.\n+\t * This is determined by whether the service was revoked\n+\t * immediately.\n+\t *\n+\t * @return whether current instances of the revoked service are\n+\t *         usable.\n+\t */\n+\tpublic boolean isCurrentServiceInvalidNow() {\n+\t\treturn revokeNow;\n+\t}\n+}"}, {"sha": "8caf3576a2d34d17ad95083d86d9e157427b51bd", "filename": "libjava/java/beans/beancontext/BeanContextServiceRevokedListener.java", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceRevokedListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceRevokedListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServiceRevokedListener.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,51 @@\n+/* java.beans.beancontext.BeanContextServiceRevokedListener\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * Listens for service revoke events.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ */\n+\n+public interface BeanContextServiceRevokedListener extends EventListener {\n+\t/**\n+\t * Called by <code>BeanContextServices.revokeService()</code> to indicate that a service has been revoked.\n+\t * If you have a reference to such a service, it should be\n+\t * discarded and may no longer function properly.\n+\t * <code>getService()</code> will no longer work on the specified\n+\t * service class after this event has been fired.\n+\t *\n+\t * @param event the service revoked event.\n+\t * @see java.beans.beancontext.BeanContextServices#revokeService(java.lang.Class,java.beans.beancontext.BeanContextServiceProvider,boolean)\n+\t */\n+\tpublic void serviceRevoked(BeanContextServiceRevokedEvent event);\n+}"}, {"sha": "e67687b6efedc7f8146a5158966f09de0ed3738f", "filename": "libjava/java/beans/beancontext/BeanContextServices.java", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServices.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServices.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServices.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,195 @@\n+/* java.beans.beancontext.BeanContextServices\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Allows a <code>BeanContext</code> to provide services to its children.\n+ *\n+ * @specnote it is unclear whether a <code>BeanContextServices</code>\n+ *           should delegate unhandled requests to parents.  I assume so.\n+ * @author John Keiser\n+ * @since JDK1.2\n+ */\n+\n+public interface BeanContextServices extends BeanContext, BeanContextServicesListener {\n+\t/**\n+\t * Register a service to make it available to others.\n+\t * This class may refuse to add the service based on whatever\n+\t * information it can gather, including whether the service\n+\t * provider is trusted.\n+\t *\n+\t * @param serviceClass the service class.\n+\t * @param provider the factory that will actually provide the service.\n+\t * @return whether the service was added or not.\n+\t */\n+\tpublic boolean addService(Class serviceClass, BeanContextServiceProvider provider);\n+\n+\t/**\n+\t * Make it so that no one else can use this service.\n+\t * <P>\n+\t *\n+\t * If <code>revokeNow</code> is <code>false</code>, the only\n+\t * effect of this method is to make all subsequent calls to\n+\t * <code>getService()</code> on this service class fail.\n+\t * <P>\n+\t *\n+\t * If it is <code>true</code>, a message is also sent out to all\n+\t * listeners on the service and all references to it are released.\n+\t *\n+\t * @param serviceClass the service class to revoke.\n+\t * @param provider the service provider providing the service class.\n+\t * @param revokeNow whether to release all current references to\n+\t *        the service.\n+\t */\n+\tpublic void revokeService(Class serviceClass, BeanContextServiceProvider provider, boolean revokeNow);\n+\n+\t/**\n+\t * Release your copy of this service.\n+\t * <P>\n+\t *\n+\t * If all copies of the service's class have been relinquished by\n+\t * the requestor, the <code>BeanContextServiceRevokedListener</code>\n+\t * previously registered by <code>getService()</code> will be\n+\t * unregistered.\n+\t *\n+\t * @param requestorChild the original <code>BeanContextChild</code>\n+\t *        requesting the service.\n+\t * @param requestor the original requestor of the service.\n+\t * @param service the service to relinquish\n+\t * @see #getService(java.beans.beancontext.BeanContextChild,java.lang.Object,java.lang.Class,java.lang.Object,java.beans.beancontext.BeanContextServiceRevokedListener)\n+\t */\n+\tpublic void releaseService(BeanContextChild requestorChild, Object requestor, Object service);\n+\n+\t/**\n+\t * Get a service from this <code>BeanContextServices</code>.\n+\t * <P>\n+\t *\n+\t * The specified listener will be registered to receive a\n+\t * revocation notice for the specified serviceClass.  One\n+\t * notification per service class per requestor object will be\n+\t * sent.\n+\t * <P>\n+\t *\n+\t * The listener will be unregistered when all services that were\n+\t * obtained by that requestor for that service class are released.\n+\t * <P>\n+\t *\n+\t * If the requested service class is not available, or if this\n+\t * <code>BeanContextServices</code> object chooses not honor the\n+\t * request because the service class has been revoked or for some\n+\t * other reason, then this method will return <code>null</code>.\n+\t * <P>\n+\t *\n+\t * This method may throw unchecked exceptions, so watch out.\n+\t *\n+\t * @specnote it is not specified what happens when two subsequent\n+\t *           calls are made to <code>getService()</code> with the\n+\t *           same requestor object and service class but different\n+\t *           listeners.  Which listener is to be notified?\n+\t *\n+\t * @param requestorChild the <code>BeanContextChild</code>\n+\t *        associated with the requestor.  Typically this will be\n+\t *        the same as the requestor itself, but since any\n+\t *        <code>Object</code>, even one outside the hierarchy, may\n+\t *        make a request, this parameter is necessary.  Only weak\n+\t *        references to this will be retained, and it will never\n+\t *        be changed, only queried in a read-only manner.\n+\t * @param requestor the actual requestor of the service.  Only\n+\t *        weak references to this will be retained, and it will\n+\t *        never be changed, only queried in a read-only manner.\n+\t * @param serviceClass the <code>Class</code> of the service being\n+\t *        requested.\n+\t * @param serviceSelector a parameter to customize the service\n+\t *        returned with.\n+\t * @param listener a listener that will be notified if the service\n+\t *        being requested is revoked.\n+\t * @return an instance of <code>serviceClass</code> (such that\n+\t *        <code>instanceof</code> serviceClass is true), or\n+\t *        <code>null</code>.\n+\t */\n+\tpublic Object getService(BeanContextChild requestorChild, Object requestor, Class serviceClass, Object serviceSelector, BeanContextServiceRevokedListener listener);\n+\n+\t/**\n+\t * Get a list of all service classes supported.\n+\t * <P>\n+\t *\n+\t * This method must synchronize on\n+\t * <code>BeanContext.globalHierarchyLock</code>.\n+\t *\n+\t * @return a list of all service classes supported.\n+\t * @see java.beans.beancontext.BeanContext#globalHierarchyLock\n+\t */\n+\tpublic Iterator getCurrentServiceClasses();\n+\n+\t/**\n+\t * Get a list of valid service selectors for the specified service class.\n+\t * <P>\n+\t *\n+\t * If the specified service class does not have a finite number of\n+\t * valid service selectors, it should return <code>null</code>.\n+\t * If it takes a general <code>Integer</code> parameter, for\n+\t * example, you may as well return <code>null</code> or the poor\n+\t * soul who called this method will be iterating all day.\n+\t * <P>\n+\t *\n+\t * If it has no valid service selectors, it should still return an empty\n+\t * <code>Iterator</code>.\n+\t *\n+\t * @param serviceClass the service class to get selectors for.\n+\t * @return a list of valid service selectors for the service\n+\t *         class, or <code>null</code>.\n+\t */\n+\tpublic Iterator getCurrentServiceSelectors(Class serviceClass);\n+\n+\t/**\n+\t * Tell whether the specified service class is available.\n+\t * Iff getService() could return a non-null value for the\n+\t * specified service, this method will return <code>true</code>.\n+\t *\n+\t * @param serviceClass the service class to check on.\n+\t * @return whether the specified service class is availabe.\n+\t */\n+\tpublic boolean hasService(Class serviceClass);\n+\n+\t/**\n+\t * Add a listener on all adds and removes of services.\n+\t * @param listener the listener to add.\n+\t */\n+\tpublic void addBeanContextServicesListener(BeanContextServicesListener listener);\n+\n+\t/**\n+\t * Remove a listener on all adds and removes of services.\n+\t * @specnote it is not certain whether this should remove this\n+\t *           listener if it was specified in\n+\t *           <code>getService()</code>.\n+\t * @param listener the listener to add.\n+\t */\n+\tpublic void removeBeanContextServicesListener(BeanContextServicesListener listener);\n+}"}, {"sha": "bb55f8d1274a16dc11f4d19228b517a9c617c892", "filename": "libjava/java/beans/beancontext/BeanContextServicesListener.java", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServicesListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServicesListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2Fbeancontext%2FBeanContextServicesListener.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,45 @@\n+/* java.beans.beancontext.BeanContextServicesListener\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.beans.beancontext;\n+\n+/**\n+ * Listens for service add and revoke events.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.2\n+ */\n+\n+public interface BeanContextServicesListener extends BeanContextServiceRevokedListener {\n+\t/**\n+\t * Called by <code>BeanContextServices</code> whenever a service is made available.\n+\t *\n+\t * @param event the service revoked event, with useful information\n+\t *        about the new service.\n+\t */\n+\tpublic void serviceAvailable(BeanContextServiceAvailableEvent event);\n+}"}, {"sha": "ef70f54c557fa4fd73d84b8d88c655e1dc8d2abd", "filename": "libjava/java/io/BlockDataException.java", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FBlockDataException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FBlockDataException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBlockDataException.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,39 @@\n+/* BlockDataException.java -- Class used to store name and class of fields\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+//TODO: check 1.2 API to make sure this mathces\n+\n+class BlockDataException extends IOException\n+{\n+  public BlockDataException( int bytes )\n+  {\n+    super( bytes + \" bytes are available in the next data block\" );\n+  }\n+}\n+"}, {"sha": "045df8660e1678143ca20837d90a9f6b7aa4e0f8", "filename": "libjava/java/io/Externalizable.java", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FExternalizable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FExternalizable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FExternalizable.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,98 @@\n+/* Externalizable.java -- Interface for saving and restoring object data\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+/**\n+  * This interface provides a way that classes can completely control how\n+  * the data of their object instances  are written and read to and from \n+  * streams.  It has two methods which are used to write the data to a stream \n+  * and to read the data from a stream.  The read method must read the data \n+  * in exactly the way it was written by the write method. \n+  * <p>\n+  * Note that classes which implement this interface must take into account\n+  * that all superclass data must also be written to the stream as well.  \n+  * The class implementing this interface must figure out how to make that\n+  * happen.\n+  * <p>\n+  * This interface can be used to provide object persistence.  When an \n+  * object is to be stored externally, the <code>writeExternal</code> method is\n+  * called to save state.  When the object is restored, an instance is\n+  * created using the default no-argument constructor and the \n+  * <code>readExternal</code> method is used to restore the state.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public abstract interface Externalizable extends Serializable\n+{\n+\n+/**\n+  * This method restores an object's state by reading in the instance data\n+  * for the object from the passed in stream.  Note that this stream is not\n+  * a subclass of <code>InputStream</code>, but rather is a class that implements\n+  * the <code>ObjectInput</code> interface.  That interface provides a mechanism for\n+  * reading in Java data types from a stream.\n+  * <p>\n+  * Note that this method must be compatible with <code>writeExternal</code>.\n+  * It must read back the exact same types that were written by that\n+  * method in the exact order they were written.\n+  * <p>\n+  * If this method needs to read back an object instance, then the class\n+  * for that object must be found and loaded.  If that operation fails,\n+  * then this method throws a <code>ClassNotFoundException</code>\n+  *\n+  * @param in An <code>ObjectInput</code> instance for reading in the object state\n+  *\n+  * @exception ClassNotFoundException If the class of an object being restored cannot be found\n+  * @exception IOException If any other error occurs\n+  */\n+public abstract void\n+readExternal(ObjectInput in) throws ClassNotFoundException, IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method is responsible for writing the instance data of an object\n+  * to the passed in stream.  Note that this stream is not a subclass of\n+  * <code>OutputStream</code>, but rather is a class that implements the\n+  * <code>ObjectOutput</code> interface.  That interface provides a number of methods\n+  * for writing Java data values to a stream.\n+  * <p>\n+  * Not that the implementation of this method must be coordinated with\n+  * the implementation of <code>readExternal</code>.\n+  *\n+  * @param out An <code>ObjectOutput</code> instance for writing the object state\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public abstract void\n+writeExternal(ObjectOutput out) throws IOException;\n+\n+} // interface Externalizable\n+"}, {"sha": "fd03154a1f6db391ea18f2ad167aaaf7c04f26c1", "filename": "libjava/java/io/InvalidClassException.java", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FInvalidClassException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FInvalidClassException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FInvalidClassException.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,110 @@\n+/* InvalidClassException.java -- An I/O operation was interrupted.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+/**\n+  * This exception is thrown when there is some sort of problem with a\n+  * class during a serialization operation.  This could be that the\n+  * versions don't match, that there are unknown datatypes in the class\n+  * or that the class doesn't have a default no-arg constructor.\n+  * <p>\n+  * The field <code>classname</code> will contain the name of the\n+  * class that caused the problem if known.  The getMessage() method\n+  * for this exception will always include the name of that class\n+  * if known.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class InvalidClassException extends ObjectStreamException\n+{\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * The name of the class which encountered the error.\n+  */\n+public String classname;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Create a new InvalidClassException with a descriptive error message String\n+  *\n+  * @param message The descriptive error message\n+  */\n+public\n+InvalidClassException(String message)\n+{\n+  super(message);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Create a new InvalidClassException with a descriptive error message \n+  * String, and the name of the class that caused the problem.\n+  * \n+  * @param classname The number of bytes tranferred before the interruption\n+  * @param message The descriptive error message\n+  */\n+public\n+InvalidClassException(String classname, String message)\n+{\n+  super(message);\n+  this.classname = classname;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * Returns the descriptive error message for this exception.  It will\n+  * include the class name that caused the problem if known.  This method\n+  * overrides Throwable.getMessage()\n+  *\n+  * @return A descriptive error message\n+  */\n+public String\n+getMessage()\n+{\n+  return(super.getMessage() + \": \" + classname);\n+}\n+\n+} // class InvalidClassException\n+"}, {"sha": "705082a2516fe84010896444d222c0316ff8ce5e", "filename": "libjava/java/io/InvalidObjectException.java", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FInvalidObjectException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FInvalidObjectException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FInvalidObjectException.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,57 @@\n+/* InvalidObjectException.java -- An I/O operation was interrupted.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+/**\n+  * This exception is thrown when an object fails a validation test\n+  * during serialization.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class InvalidObjectException extends ObjectStreamException\n+{\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Create a new InvalidObjectException with a descriptive error message String\n+  *\n+  * @param message The descriptive error message\n+  */\n+public\n+InvalidObjectException(String message)\n+{\n+  super(message);\n+}\n+\n+} // class InvalidObjectException\n+"}, {"sha": "f628a3b82d5cd5ad9a24922fa1b5d6ef2d697d90", "filename": "libjava/java/io/NotActiveException.java", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FNotActiveException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FNotActiveException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FNotActiveException.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,68 @@\n+/* NotActiveException.java -- Unexpected end of file exception\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+/**\n+  * This exception is thrown when a problem occurs due to the fact that\n+  * serialization is not active.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class NotActiveException extends ObjectStreamException\n+{\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Create a new NotActiveException without a descriptive error message\n+  */\n+public\n+NotActiveException()\n+{\n+  super();\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Create a new NotActiveException with a descriptive error message String\n+  *\n+  * @param message The descriptive error message\n+  */\n+public\n+NotActiveException(String message)\n+{\n+  super(message);\n+}\n+\n+} // class NotActiveException\n+"}, {"sha": "d1e0bd2f4ad696b1cf4f4ff4960a095cbdcdc35e", "filename": "libjava/java/io/NotSerializableException.java", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FNotSerializableException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FNotSerializableException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FNotSerializableException.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,69 @@\n+/* NotSerializableException.java -- Unexpected end of file exception\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+/**\n+  * This exception is thrown when a class may not be serialized.  The\n+  * descriptive message will consist of the name of the class in question.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class NotSerializableException extends ObjectStreamException\n+{\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Create a new NotSerializableException without a descriptive error message\n+  */\n+public\n+NotSerializableException()\n+{\n+  super();\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Create a new NotSerializableException with a descriptive error message String\n+  * This should be the name of the class that cannot be serialized.\n+  *\n+  * @param message The descriptive error message\n+  */\n+public\n+NotSerializableException(String message)\n+{\n+  super(message);\n+}\n+\n+} // class NotSerializableException\n+"}, {"sha": "ef23fa9034f4232b5d201c1b5c1f09224c72e9fe", "filename": "libjava/java/io/ObjectInput.java", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectInput.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectInput.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInput.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,147 @@\n+/* ObjectInput.java -- Read object data from a stream\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io; \n+\n+/**\n+  * This interface extends the <code>DataInput</code> interface to provide a\n+  * facility to read objects as well as primitive types from a stream.  It\n+  * also has methods that allow input to be done in a manner similar to\n+  * <code>InputStream</code>\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public abstract interface ObjectInput extends DataInput\n+{\n+\n+/**\n+  * This method returns the number of bytes that can be read without\n+  * blocking.\n+  *\n+  * @return The number of bytes available before blocking\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public abstract int\n+available() throws IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method reading a byte of data from a stream.  It returns that byte\n+  * as an int.  This method blocks if no data is available to be read.\n+  * \n+  * @return The byte of data read\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public abstract int\n+read() throws IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method reads raw bytes and stores them them a byte array buffer.\n+  * Note that this method will block if no data is available.  However, \n+  * it will not necessarily block until it fills the entire buffer.  That is,\n+  * a \"short count\" is possible.\n+  *\n+  * @param buf The byte array to receive the data read\n+  *\n+  * @return The actual number fo bytes read or -1 if end of stream\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public abstract int\n+read(byte[] buf) throws IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method reads raw bytes and stores them in a byte array buffer\n+  * <code>buf</code> starting at position <code>offset</code> into the buffer.  A \n+  * maximum of <code>len</code> bytes will be read.  Note that this method\n+  * blocks if no data is available, but will not necessarily block until\n+  * it can read <code>len</code> bytes of data.  That is, a \"short count\" is\n+  * possible.\n+  *\n+  * @param buf The byte array to receive the data read\n+  * @param offset The offset into @code{buf} to start storing data\n+  * @param len The maximum number of bytes to read\n+  *\n+  * @return The actual number fo bytes read or -1 if end of stream\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public abstract int\n+read(byte[] buf, int offset, int len) throws IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * Reads an object instance and returns it.  If the class for the object\n+  * being read cannot be found, then a ClassNotFoundException will\n+  * be thrown.\n+  *\n+  * @return The object instance that was read\n+  *\n+  * @exception ClassNotFoundException If a class for the object cannot be found\n+  * @exception IOException If an error occurs\n+  */\n+public abstract Object\n+readObject() throws ClassNotFoundException, IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method causes the specified number of bytes to be read and\n+  * discarded.  It is possible that fewer than the requested number of bytes\n+  * will actually be skipped.\n+  *\n+  * @param num_bytes The number of bytes to skip\n+  *\n+  * @return The actual number of bytes skipped\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public abstract long\n+skip(long num_bytes) throws IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method closes the input source\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public abstract void\n+close() throws IOException;\n+\n+} // interface ObjectInput\n+"}, {"sha": "7855480acb346308c3c61a8d39e48a1cab7a2d87", "filename": "libjava/java/io/ObjectInputStream.java", "status": "added", "additions": 1467, "deletions": 0, "changes": 1467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,1467 @@\n+/* ObjectInputStream.java -- Class used to read serialized objects\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Hashtable;\n+import java.util.Vector;\n+\n+import gnu.java.io.ObjectIdentityWrapper;\n+import gnu.java.lang.reflect.TypeSignature;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+\n+\n+public class ObjectInputStream extends InputStream\n+  implements ObjectInput, ObjectStreamConstants\n+{\n+  /**\n+     Creates a new <code>ObjectInputStream</code> that will do all of\n+     its reading from <code>in</code>.  This method also checks\n+     the stream by reading the header information (stream magic number\n+     and stream version).\n+\n+     @exception IOException Reading stream header from underlying\n+     stream cannot be completed.\n+\n+     @exception StreamCorruptedException An invalid stream magic\n+     number or stream version was read from the stream.\n+\n+     @see readStreamHeader ()\n+  */\n+  public ObjectInputStream (InputStream in)\n+    throws IOException, StreamCorruptedException\n+  {\n+    this.resolveEnabled = false;\n+    this.isDeserializing = false;\n+    this.blockDataPosition = 0;\n+    this.blockDataBytes = 0;\n+    this.blockData = new byte[BUFFER_SIZE];\n+    this.blockDataInput = new DataInputStream (this);\n+    this.realInputStream = new DataInputStream (in);\n+    this.nextOID = baseWireHandle;\n+    this.objectLookupTable = new Hashtable ();\n+    this.validators = new Vector ();\n+    setBlockDataMode (true);\n+    readStreamHeader ();\n+  }\n+\n+\n+  /**\n+     Returns the next deserialized object read from the underlying stream.\n+\n+     This method can be overriden by a class by implementing\n+     <code>private void readObject (ObjectInputStream)</code>.\n+\n+     If an exception is thrown from this method, the stream is left in\n+     an undefined state.\n+\n+     @exception ClassNotFoundException The class that an object being\n+     read in belongs to cannot be found.\n+\n+     @exception IOException Exception from underlying\n+     <code>InputStream</code>.\n+  */\n+  public final Object readObject () throws ClassNotFoundException, IOException\n+  {\n+    if (this.useSubclassMethod)\n+      return readObjectOverride ();\n+\n+    boolean was_deserializing;\n+\n+    Object ret_val;\n+    was_deserializing = this.isDeserializing;\n+\n+    if (! was_deserializing)\n+      setBlockDataMode (false);\n+\n+    this.isDeserializing = true;\n+\n+//    DEBUG (\"MARKER \");\n+    byte marker = this.realInputStream.readByte ();\n+\n+    switch (marker)\n+    {\n+      case TC_BLOCKDATA:\n+      case TC_BLOCKDATALONG:\n+\treadNextBlock (marker);\n+\tthrow new BlockDataException (this.blockDataBytes);\n+\n+      case TC_NULL:\n+\tret_val = null;\n+\tbreak;\n+\n+      case TC_REFERENCE:\n+      {\n+//\tDEBUG (\"REFERENCE \");\n+\tInteger oid = new Integer (this.realInputStream.readInt ());\n+\tret_val = ((ObjectIdentityWrapper)\n+\t\t   this.objectLookupTable.get (oid)).object;\n+\tbreak;\n+      }\n+\n+      case TC_CLASS:\n+      {\n+\tObjectStreamClass osc = (ObjectStreamClass)readObject ();\n+\tClass clazz = osc.forClass ();\n+\tassignNewHandle (clazz);\n+\tret_val = clazz;\n+\tbreak;\n+      }\n+\n+      case TC_CLASSDESC:\n+      {\n+//\tDEBUG (\"CLASSDESC NAME \");\n+\tString name = this.realInputStream.readUTF ();\n+//\tDEBUG (\"UID \");\n+\tlong uid = this.realInputStream.readLong ();\n+//\tDEBUG (\"FLAGS \");\n+\tbyte flags = this.realInputStream.readByte ();\n+//\tDEBUG (\"FIELD COUNT \");\n+\tshort field_count = this.realInputStream.readShort ();\n+\tObjectStreamField[] fields = new ObjectStreamField[field_count];\n+\n+\tObjectStreamClass osc = new ObjectStreamClass (name, uid,\n+\t\t\t\t\t\t       flags, fields);\n+\tassignNewHandle (osc);\n+\n+\tfor (int i=0; i < field_count; i++)\n+\t{\n+//\t  DEBUG (\"TYPE CODE \");\n+\t  char type_code = (char)this.realInputStream.readByte ();\n+//\t  DEBUG (\"FIELD NAME \");\n+\t  String field_name = this.realInputStream.readUTF ();\n+\t  String class_name;\n+\n+\t  if (type_code == 'L' || type_code == '[')\n+\t    class_name = (String)readObject ();\n+\t  else\n+\t    class_name = String.valueOf (type_code);\n+\n+\t  fields[i] =\n+\t    new ObjectStreamField (field_name,\n+\t\t\t\t   TypeSignature.getClassForEncoding\n+\t\t\t\t   (class_name));\n+\t}\n+\n+\tsetBlockDataMode (true);\n+\tosc.setClass (resolveClass (osc));\n+\tsetBlockDataMode (false);\n+\n+//\tDEBUG (\"ENDBLOCKDATA \");\n+\tif (this.realInputStream.readByte () != TC_ENDBLOCKDATA)\n+\t  throw new IOException (\"Data annotated to class was not consumed.\");\n+\n+\tosc.setSuperclass ((ObjectStreamClass)readObject ());\n+\tret_val = osc;\n+\tbreak;\n+      }\n+\n+      case TC_STRING:\n+      {\n+//\tDEBUG (\"STRING \");\n+\tString s = this.realInputStream.readUTF ();\n+\tret_val = processResoultion (s, assignNewHandle (s));\n+\tbreak;\n+      }\n+\n+      case TC_ARRAY:\n+      {\n+\tObjectStreamClass osc = (ObjectStreamClass)readObject ();\n+\tClass componenetType = osc.forClass ().getComponentType ();\n+//\tDEBUG (\"ARRAY LENGTH \");\n+\tint length = this.realInputStream.readInt ();\n+\tObject array = Array.newInstance (componenetType, length);\n+\tint handle = assignNewHandle (array);\n+\treadArrayElements (array, componenetType);\n+\tret_val = processResoultion (array, handle);\n+\tbreak;\n+      }\n+\n+      case TC_OBJECT:\n+      {\n+\tObjectStreamClass osc = (ObjectStreamClass)readObject ();\n+\tClass clazz = osc.forClass ();\n+\n+\tif (!Serializable.class.isAssignableFrom (clazz))\n+\t  throw new NotSerializableException (clazz + \" is not Serializable, and thus cannot be deserialized.\");\n+\n+\tif (Externalizable.class.isAssignableFrom (clazz))\n+\t{\n+\t  Externalizable obj = null;\n+\n+\t  try\n+\t  {\n+\t    obj = (Externalizable)clazz.newInstance ();\n+\t  }\n+\t  catch (InstantiationException e)\n+\t  {\n+\t    throw new ClassNotFoundException (\"Instance of \" + clazz\n+\t\t\t\t\t      + \" could not be created\");\n+\t  }\n+\t  catch (IllegalAccessException e)\n+\t  {\n+\t    throw new ClassNotFoundException (\"Instance of \" + clazz\n+\t\t\t\t\t      + \" could not be created because class or zero-argument constructor is not accessible\");\n+\t  }\n+\t  catch (NoSuchMethodError e)\n+\t  {\n+\t    throw new ClassNotFoundException (\"Instance of \" + clazz\n+\t\t\t\t\t      + \" could not be created because zero-argument constructor is not defined\");\n+\t  }\n+\n+\t  int handle = assignNewHandle (obj);\n+\n+\t  boolean read_from_blocks = ((osc.getFlags () & SC_BLOCK_DATA) != 0);\n+\n+\t  if (read_from_blocks)\n+\t    setBlockDataMode (true);\n+\n+\t  obj.readExternal (this);\n+\n+\t  if (read_from_blocks)\n+\t    setBlockDataMode (false);\n+\n+\t  ret_val = processResoultion (obj, handle);\n+\t  break;\n+\t} // end if (Externalizable.class.isAssignableFrom (clazz))\n+\n+\t// find the first non-serializable, non-abstract\n+\t// class in clazz's inheritance hierarchy\n+\tClass first_nonserial = clazz.getSuperclass ();\n+\twhile (Serializable.class.isAssignableFrom (first_nonserial)\n+\t       || Modifier.isAbstract (first_nonserial.getModifiers ()))\n+\t  first_nonserial = first_nonserial.getSuperclass ();\n+\n+//\tDEBUGln (\"Using \" + first_nonserial\n+//\t\t + \" as starting point for constructing \" + clazz);\n+\n+\tObject obj = null;\n+\tobj = newObject (clazz, first_nonserial);\n+\n+\tif (obj == null)\n+\t  throw new ClassNotFoundException (\"Instance of \" + clazz +\n+\t\t\t\t\t    \" could not be created\");\n+\n+\tint handle = assignNewHandle (obj);\n+\tthis.currentObject = obj;\n+\tObjectStreamClass[] hierarchy =\n+\t  ObjectStreamClass.getObjectStreamClasses (clazz);\n+\n+//\tDEBUGln (\"Got class hierarchy of depth \" + hierarchy.length);\n+\n+\tboolean has_read;\n+\tfor (int i=0; i < hierarchy.length; i++)\n+\t{\n+\t  this.currentObjectStreamClass = hierarchy[i];\n+\n+//\t  DEBUGln (\"Reading fields of \"\n+//\t\t   + this.currentObjectStreamClass.getName ());\n+\n+\t  has_read = true;\n+\n+\t  try\n+\t  {\n+\t    this.currentObjectStreamClass.forClass ().\n+\t      getDeclaredMethod (\"readObject\", readObjectParams);\n+\t  }\n+\t  catch (NoSuchMethodException e)\n+\t  {\n+\t    has_read = false;\n+\t  }\n+\n+\t  // XXX: should initialize fields in classes in the hierarchy\n+\t  // that aren't in the stream\n+\t  // should skip over classes in the stream that aren't in the\n+\t  // real classes hierarchy\n+\t  readFields (obj, this.currentObjectStreamClass.fields,\n+\t\t      has_read, this.currentObjectStreamClass);\n+\n+\t  if (has_read)\n+\t  {\n+//\t    DEBUG (\"ENDBLOCKDATA? \");\n+\t    if (this.realInputStream.readByte () != TC_ENDBLOCKDATA)\n+\t      throw new IOException (\"No end of block data seen for class with readObject (ObjectInputStream) method.\");\n+\t  }\n+\t}\n+\n+\tthis.currentObject = null;\n+\tthis.currentObjectStreamClass = null;\n+\tret_val = processResoultion (obj, handle);\n+\tbreak;\n+      }\n+\n+      case TC_RESET:\n+\tclearHandles ();\n+\tret_val = readObject ();\n+\tbreak;\n+\n+      case TC_EXCEPTION:\n+      {\n+\tException e = (Exception)readObject ();\n+\tclearHandles ();\n+\tthrow new WriteAbortedException (\"Exception thrown during writing of stream\", e);\n+      }\n+\n+      default:\n+\tthrow new IOException (\"Unknown marker on stream\");\n+    }\n+\n+    this.isDeserializing = was_deserializing;\n+\n+    if (! was_deserializing)\n+    {\n+      setBlockDataMode (true);\n+\n+      if (validators.size () > 0)\n+\tinvokeValidators ();\n+    }\n+\n+    return ret_val;\n+  }\n+\n+\n+  /**\n+     Reads the current objects non-transient, non-static fields from\n+     the current class from the underlying output stream.\n+\n+     This method is intended to be called from within a object's\n+     <code>private void readObject (ObjectInputStream)</code>\n+     method.\n+\n+     @exception ClassNotFoundException The class that an object being\n+     read in belongs to cannot be found.\n+\n+     @exception NotActiveException This method was called from a\n+     context other than from the current object's and current class's\n+     <code>private void readObject (ObjectInputStream)</code>\n+     method.\n+\n+     @exception IOException Exception from underlying\n+     <code>OutputStream</code>.\n+  */\n+  public void defaultReadObject ()\n+    throws ClassNotFoundException, IOException, NotActiveException\n+  {\n+    if (this.currentObject == null || this.currentObjectStreamClass == null)\n+      throw new NotActiveException (\"defaultReadObject called by non-active class and/or object\");\n+\n+    if (fieldsAlreadyRead)\n+      throw new NotActiveException (\"defaultReadObject called but fields already read from stream (by defaultReadObject or readFields)\");\n+\n+    readFields (this.currentObject,\n+\t\tthis.currentObjectStreamClass.fields,\n+\t\tfalse, this.currentObjectStreamClass);\n+\n+    fieldsAlreadyRead = true;\n+  }\n+\n+\n+  /**\n+     Registers a <code>ObjectInputValidation</code> to be carried out\n+     on the object graph currently being deserialized before it is\n+     returned to the original caller of <code>readObject ()</code>.\n+     The order of validation for multiple\n+     <code>ObjectInputValidation</code>s can be controled using\n+     <code>priority</code>.  Validators with higher priorities are\n+     called first.\n+\n+     @see java.io.ObjectInputValidation\n+\n+     @exception InvalidObjectException <code>validator</code> is\n+     <code>null</code>\n+\n+     @exception NotActiveException an attempt was made to add a\n+     validator outside of the <code>readObject</code> method of the\n+     object currently being deserialized\n+  */\n+  public void registerValidation (ObjectInputValidation validator,\n+\t\t\t\t  int priority)\n+    throws InvalidObjectException, NotActiveException\n+  {\n+    if (this.currentObject == null || this.currentObjectStreamClass == null)\n+      throw new NotActiveException (\"registerValidation called by non-active class and/or object\");\n+\n+    if (validator == null)\n+      throw new InvalidObjectException (\"attempt to add a null ObjectInputValidation object\");\n+\n+    this.validators.addElement (new ValidatorAndPriority (validator,\n+\t\t\t\t\t\t\t  priority));\n+  }\n+\n+\n+  /**\n+     Called when a class is being deserialized.  This is a hook to\n+     allow subclasses to read in information written by the\n+     <code>annotateClass (Class)</code> method of an\n+     <code>ObjectOutputStream</code>.\n+\n+     This implementation looks up the active call stack for a\n+     <code>ClassLoader</code>; if a <code>ClassLoader</code> is found,\n+     it is used to load the class associated with <code>osc</code>,\n+     otherwise, the default system <code>ClassLoader</code> is used.\n+\n+     @exception IOException Exception from underlying\n+     <code>OutputStream</code>.\n+\n+     @see java.io.ObjectOutputStream#annotateClass (java.lang.Class)\n+  */\n+  protected Class resolveClass (ObjectStreamClass osc)\n+    throws ClassNotFoundException, IOException\n+  {\n+//    DEBUGln (\"Resolving \" + osc);\n+\n+    SecurityManager sm = System.getSecurityManager ();\n+\n+    if (sm == null)\n+      sm = new SecurityManager () {};\n+\n+    ClassLoader cl = currentClassLoader (sm);\n+\n+    if (cl == null)\n+    {\n+//      DEBUGln (\"No class loader found\");\n+      return Class.forName (osc.getName ());\n+    }\n+    else\n+    {\n+//      DEBUGln (\"Using \" + cl);\n+      return cl.loadClass (osc.getName ());\n+    }\n+  }\n+\n+\n+  /**\n+     Allows subclasses to resolve objects that are read from the\n+     stream with other objects to be returned in their place.  This\n+     method is called the first time each object is encountered.\n+\n+     This method must be enabled before it will be called in the\n+     serialization process.\n+\n+     @exception IOException Exception from underlying\n+     <code>OutputStream</code>.\n+\n+     @see enableResolveObject (boolean)\n+  */\n+  protected Object resolveObject (Object obj) throws IOException\n+  {\n+    return obj;\n+  }\n+\n+\n+  /**\n+     If <code>enable</code> is <code>true</code> and this object is\n+     trusted, then <code>resolveObject (Object)</code> will be called\n+     in subsequent calls to <code>readObject (Object)</code>.\n+     Otherwise, <code>resolveObject (Object)</code> will not be called.\n+\n+     @exception SecurityException This class is not trusted.\n+  */\n+  protected boolean enableResolveObject (boolean enable)\n+    throws SecurityException\n+  {\n+    if (enable)\n+      if (getClass ().getClassLoader () != null)\n+\tthrow new SecurityException (\"Untrusted ObjectInputStream subclass attempted to enable object resolution\");\n+\n+    boolean old_val = this.resolveEnabled;\n+    this.resolveEnabled = enable;\n+    return old_val;\n+  }\n+\n+\n+  /**\n+     Reads stream magic and stream version information from the\n+     underlying stream.\n+\n+     @exception IOException Exception from underlying stream.\n+\n+     @exception StreamCorruptedException An invalid stream magic\n+     number or stream version was read from the stream.\n+  */\n+  protected void readStreamHeader ()\n+    throws IOException, StreamCorruptedException\n+  {\n+//    DEBUG (\"STREAM MAGIC \");\n+    if (this.realInputStream.readShort () != STREAM_MAGIC)\n+      throw new StreamCorruptedException (\"Invalid stream magic number\");\n+\n+//    DEBUG (\"STREAM VERSION \");\n+    if (this.realInputStream.readShort () != STREAM_VERSION)\n+      throw new StreamCorruptedException (\"Invalid stream version number\");\n+  }\n+\n+\n+  public int read () throws IOException\n+  {\n+    if (this.readDataFromBlock)\n+    {\n+      if (this.blockDataPosition >= this.blockDataBytes)\n+\treadNextBlock ();\n+      return this.blockData[this.blockDataPosition++];\n+    }\n+    else\n+      return this.realInputStream.read ();\n+  }\n+\n+  public int read (byte data[], int offset, int length) throws IOException\n+  {\n+    if (this.readDataFromBlock)\n+    {\n+      if (this.blockDataPosition + length >= this.blockDataBytes)\n+\treadNextBlock ();\n+\n+      System.arraycopy (this.blockData, this.blockDataPosition,\n+\t\t\tdata, offset, length);\n+      return length;\n+    }\n+    else\n+      return this.realInputStream.read (data, offset, length);\n+  }\n+\n+  public int available () throws IOException\n+  {\n+    if (this.readDataFromBlock)\n+    {\n+      if (this.blockDataPosition >= this.blockDataBytes)\n+\treadNextBlock ();\n+\n+      return this.blockDataBytes - this.blockDataPosition;\n+    }\n+    else\n+      return this.realInputStream.available ();\n+  }\n+\n+  public void close () throws IOException\n+  {\n+    this.realInputStream.close ();\n+  }\n+\n+  public boolean readBoolean () throws IOException\n+  {\n+    return this.dataInputStream.readBoolean ();\n+  }\n+\n+  public byte readByte () throws IOException\n+  {\n+    return this.dataInputStream.readByte ();\n+  }\n+\n+  public int readUnsignedByte () throws IOException\n+  {\n+    return this.dataInputStream.readUnsignedByte ();\n+  }\n+\n+  public short readShort () throws IOException\n+  {\n+    return this.dataInputStream.readShort ();\n+  }\n+\n+  public int readUnsignedShort () throws IOException\n+  {\n+    return this.dataInputStream.readUnsignedShort ();\n+  }\n+\n+  public char readChar () throws IOException\n+  {\n+    return this.dataInputStream.readChar ();\n+  }\n+\n+  public int readInt () throws IOException\n+  {\n+    return this.dataInputStream.readInt ();\n+  }\n+\n+  public long readLong () throws IOException\n+  {\n+    return this.dataInputStream.readLong ();\n+  }\n+\n+  public float readFloat () throws IOException\n+  {\n+    return this.dataInputStream.readFloat ();\n+  }\n+\n+  public double readDouble () throws IOException\n+  {\n+    return this.dataInputStream.readDouble ();\n+  }\n+\n+  public void readFully (byte data[]) throws IOException\n+  {\n+    this.dataInputStream.readFully (data);\n+  }\n+\n+  public void readFully (byte data[], int offset, int size)\n+    throws IOException\n+  {\n+    this.dataInputStream.readFully (data, offset, size);\n+  }\n+\n+  public int skipBytes (int len) throws IOException\n+  {\n+    return this.dataInputStream.skipBytes (len);\n+  }\n+\n+  /**\n+     @deprecated\n+     @see java.io.DataInputStream#readLine ()\n+  */\n+  public String readLine () throws IOException\n+  {\n+    return this.dataInputStream.readLine ();\n+  }\n+\n+  public String readUTF () throws IOException\n+  {\n+    return this.dataInputStream.readUTF ();\n+  }\n+\n+\n+  /**\n+     This class allows a class to specify exactly which fields should\n+     be read, and what values should be read for these fields.\n+\n+     XXX: finish up comments\n+  */\n+  public static abstract class GetField\n+  {\n+    public abstract ObjectStreamClass getObjectStreamClass ();\n+\n+    public abstract boolean defaulted (String name)\n+      throws IOException, IllegalArgumentException;\n+\n+    public abstract boolean get (String name, boolean defvalue)\n+      throws IOException, IllegalArgumentException;\n+\n+    public abstract char get (String name, char defvalue)\n+      throws IOException, IllegalArgumentException;\n+\n+    public abstract byte get (String name, byte defvalue)\n+      throws IOException, IllegalArgumentException;\n+\n+    public abstract short get (String name, short defvalue)\n+      throws IOException, IllegalArgumentException;\n+\n+    public abstract int get (String name, int defvalue)\n+      throws IOException, IllegalArgumentException;\n+\n+    public abstract long get (String name, long defvalue)\n+      throws IOException, IllegalArgumentException;\n+\n+    public abstract float get (String name, float defvalue)\n+      throws IOException, IllegalArgumentException;\n+\n+    public abstract double get (String name, double defvalue)\n+      throws IOException, IllegalArgumentException;\n+\n+    public abstract Object get (String name, Object defvalue)\n+      throws IOException, IllegalArgumentException;\n+  }\n+\n+  public GetField readFields ()\n+    throws IOException, ClassNotFoundException, NotActiveException\n+  {\n+    if (this.currentObject == null || this.currentObjectStreamClass == null)\n+      throw new NotActiveException (\"readFields called by non-active class and/or object\");\n+\n+    if (fieldsAlreadyRead)\n+      throw new NotActiveException (\"readFields called but fields already read from stream (by defaultReadObject or readFields)\");\n+\n+    final ObjectStreamClass clazz = this.currentObjectStreamClass;\n+    final byte[] prim_field_data = new byte[clazz.primFieldSize];\n+    final Object[] objs = new Object[clazz.objectFieldCount];\n+    readFully (prim_field_data);\n+    for (int i = 0; i < objs.length; ++ i)\n+      objs[i] = readObject ();\n+\n+    return new GetField ()\n+    {\n+      public ObjectStreamClass getObjectStreamClass ()\n+      {\n+\treturn clazz;\n+      }\n+\n+      public boolean defaulted (String name)\n+\tthrows IOException, IllegalArgumentException\n+      {\n+\treturn clazz.getField (name) == null;\n+      }\n+\n+      public boolean get (String name, boolean defvalue)\n+\tthrows IOException, IllegalArgumentException\n+      {\n+\tObjectStreamField field = getField (name, Boolean.TYPE);\n+\n+\tif (field == null)\n+\t  return defvalue;\n+\n+\treturn prim_field_data[field.getOffset ()] == 0 ? false : true;\n+      }\n+\n+      public char get (String name, char defvalue)\n+\tthrows IOException, IllegalArgumentException\n+      {\n+\tObjectStreamField field = getField (name, Character.TYPE);\n+\n+\tif (field == null)\n+\t  return defvalue;\n+\n+\tint off = field.getOffset ();\n+\n+\treturn (char)(((prim_field_data[off++] & 0xFF) << 8)\n+\t\t      | (prim_field_data[off] & 0xFF));\n+      }\n+\n+      public byte get (String name, byte defvalue)\n+\tthrows IOException, IllegalArgumentException\n+      {\n+\tObjectStreamField field = getField (name, Byte.TYPE);\n+\n+\tif (field == null)\n+\t  return defvalue;\n+\n+\treturn prim_field_data[field.getOffset ()];\n+      }\n+\n+      public short get (String name, short defvalue)\n+\tthrows IOException, IllegalArgumentException\n+      {\n+\tObjectStreamField field = getField (name, Short.TYPE);\n+\n+\tif (field == null)\n+\t  return defvalue;\n+\n+\tint off = field.getOffset ();\n+\n+\treturn (short)(((prim_field_data[off++] & 0xFF) << 8)\n+\t\t       | (prim_field_data[off] & 0xFF));\n+      }\n+\n+      public int get (String name, int defvalue)\n+\tthrows IOException, IllegalArgumentException\n+      {\n+\tObjectStreamField field = getField (name, Integer.TYPE);\n+\n+\tif (field == null)\n+\t  return defvalue;\n+\n+\tint off = field.getOffset ();\n+\n+\treturn ((prim_field_data[off++] & 0xFF) << 24)\n+\t  | ((prim_field_data[off++] & 0xFF) << 16)\n+\t  | ((prim_field_data[off++] & 0xFF) << 8)\n+\t  | (prim_field_data[off] & 0xFF);\n+      }\n+\n+      public long get (String name, long defvalue)\n+\tthrows IOException, IllegalArgumentException\n+      {\n+\tObjectStreamField field = getField (name, Long.TYPE);\n+\n+\tif (field == null)\n+\t  return defvalue;\n+\n+\tint off = field.getOffset ();\n+\n+\treturn (long)(((prim_field_data[off++] & 0xFF) << 56)\n+\t\t      | ((prim_field_data[off++] & 0xFF) << 48)\n+\t\t      | ((prim_field_data[off++] & 0xFF) << 40)\n+\t\t      | ((prim_field_data[off++] & 0xFF) << 32)\n+\t\t      | ((prim_field_data[off++] & 0xFF) << 24)\n+\t\t      | ((prim_field_data[off++] & 0xFF) << 16)\n+\t\t      | ((prim_field_data[off++] & 0xFF) << 8)\n+\t\t      | (prim_field_data[off] & 0xFF));\n+      }\n+\n+      public float get (String name, float defvalue)\n+\tthrows IOException, IllegalArgumentException\n+      {\n+\tObjectStreamField field = getField (name, Float.TYPE);\n+\n+\tif (field == null)\n+\t  return defvalue;\n+\n+\tint off = field.getOffset ();\n+\n+\treturn Float.intBitsToFloat (((prim_field_data[off++] & 0xFF) << 24)\n+\t\t\t\t    | ((prim_field_data[off++] & 0xFF) << 16)\n+\t\t\t\t    | ((prim_field_data[off++] & 0xFF) << 8)\n+\t\t\t\t    | (prim_field_data[off] & 0xFF));\n+      }\n+\n+      public double get (String name, double defvalue)\n+\tthrows IOException, IllegalArgumentException\n+      {\n+\tObjectStreamField field = getField (name, Double.TYPE);\n+\n+\tif (field == null)\n+\t  return defvalue;\n+\n+\tint off = field.getOffset ();\n+\n+\treturn Double.longBitsToDouble (\n+\t  (long)(((prim_field_data[off++] & 0xFF) << 56)\n+\t\t | ((prim_field_data[off++] & 0xFF) << 48)\n+\t\t | ((prim_field_data[off++] & 0xFF) << 40)\n+\t\t | ((prim_field_data[off++] & 0xFF) << 32)\n+\t\t | ((prim_field_data[off++] & 0xFF) << 24)\n+\t\t | ((prim_field_data[off++] & 0xFF) << 16)\n+\t\t | ((prim_field_data[off++] & 0xFF) << 8)\n+\t\t | (prim_field_data[off] & 0xFF)));\n+      }\n+\n+      public Object get (String name, Object defvalue)\n+\tthrows IOException, IllegalArgumentException\n+      {\n+\tObjectStreamField field = getField (name, null);\n+\n+\tif (field == null)\n+\t  return defvalue;\n+\n+\treturn objs[field.getOffset ()];\n+      }\n+\n+      private ObjectStreamField getField (String name, Class type)\n+\tthrows IllegalArgumentException\n+      {\n+\tObjectStreamField field = clazz.getField (name);\n+\n+\tif (field == null)\n+\t  return null;\n+\n+\tClass field_type = field.getType ();\n+\n+\tif (type == field_type ||\n+\t    (type != null && field_type.isPrimitive ()))\n+\t  return field;\n+\n+\tthrow new IllegalArgumentException (\"Field requested is of type \"\n+\t\t\t\t\t    + field_type.getName ()\n+\t\t\t\t\t    + \", but requested type was \"\n+\t\t\t\t\t    + (type == null ?\n+\t\t\t\t\t       \"Object\" : type.getName ()));\n+      }\n+    };\n+\n+  }\n+\n+\n+  /**\n+     Protected constructor that allows subclasses to override\n+     deserialization.  This constructor should be called by subclasses\n+     that wish to override <code>readObject (Object)</code>.  This\n+     method does a security check <i>NOTE: currently not\n+     implemented</i>, then sets a flag that informs\n+     <code>readObject (Object)</code> to call the subclasses\n+     <code>readObjectOverride (Object)</code> method.\n+\n+     @see readObjectOverride (Object)\n+  */\n+  protected ObjectInputStream ()\n+    throws IOException, SecurityException\n+  {\n+    SecurityManager sec_man = System.getSecurityManager ();\n+    if (sec_man != null)\n+      sec_man.checkPermission (SUBCLASS_IMPLEMENTATION_PERMISSION);\n+    this.useSubclassMethod = true;\n+  }\n+\n+\n+  /**\n+     This method allows subclasses to override the default\n+     de serialization mechanism provided by\n+     <code>ObjectInputStream</code>.  To make this method be used for\n+     writing objects, subclasses must invoke the 0-argument\n+     constructor on this class from there constructor.\n+\n+     @see ObjectInputStream ()\n+  */\n+  protected Object readObjectOverride ()\n+    throws ClassNotFoundException, IOException, OptionalDataException\n+  {\n+    throw new IOException (\"Subclass of ObjectInputStream must implement readObjectOverride\");\n+  }\n+\n+\n+  // assigns the next availible handle to OBJ\n+  private int assignNewHandle (Object obj)\n+  {\n+    this.objectLookupTable.put (new Integer (this.nextOID),\n+\t\t\t     new ObjectIdentityWrapper (obj));\n+\n+//    try\n+//    {\n+//      DEBUG (\"Assigning handle \" + this.nextOID);\n+//      DEBUGln (\" to \" + obj);\n+//    }\n+//    catch (Throwable t) {}\n+\n+    return this.nextOID++;\n+  }\n+\n+\n+  private Object processResoultion (Object obj, int handle)\n+    throws IOException\n+  {\n+    if (obj instanceof Resolvable)\n+      obj = ((Resolvable)obj).readResolve ();\n+\n+    if (this.resolveEnabled)\n+      obj = resolveObject (obj);\n+\n+    this.objectLookupTable.put (new Integer (handle),\n+\t\t\t\tnew ObjectIdentityWrapper (obj));\n+\n+    return obj;\n+  }\n+\n+\n+  private void clearHandles ()\n+  {\n+    this.objectLookupTable.clear ();\n+    this.nextOID = baseWireHandle;\n+  }\n+\n+\n+  private void readNextBlock () throws IOException\n+  {\n+//    DEBUG (\"MARKER \");\n+    readNextBlock (this.realInputStream.readByte ());\n+  }\n+\n+\n+  private void readNextBlock (byte marker) throws IOException\n+  {\n+    if (marker == TC_BLOCKDATA)\n+    {\n+//      DEBUG (\"BLOCK DATA SIZE \");\n+      this.blockDataBytes = this.realInputStream.readUnsignedByte ();\n+    }\n+    else if (marker == TC_BLOCKDATALONG)\n+    {\n+//      DEBUG (\"BLOCK DATA LONG SIZE \");\n+      this.blockDataBytes = this.realInputStream.readInt ();\n+    }\n+    else\n+    {\n+      throw new EOFException (\"Attempt to read primitive data, but no data block is active.\");\n+    }\n+\n+    if (this.blockData.length < this.blockDataBytes)\n+      this.blockData = new byte[this.blockDataBytes];\n+\n+    this.realInputStream.readFully (this.blockData, 0, this.blockDataBytes);\n+    this.blockDataPosition = 0;\n+  }\n+\n+\n+  private void readArrayElements (Object array, Class clazz)\n+    throws ClassNotFoundException, IOException\n+  {\n+    if (clazz.isPrimitive ())\n+    {\n+      if (clazz == Boolean.TYPE)\n+      {\n+\tboolean[] cast_array = (boolean[])array;\n+\tfor (int i=0; i < cast_array.length; i++)\n+\t  cast_array[i] = this.realInputStream.readBoolean ();\n+\treturn;\n+      }\n+      if (clazz == Byte.TYPE)\n+      {\n+\tbyte[] cast_array = (byte[])array;\n+\tfor (int i=0; i < cast_array.length; i++)\n+\t  cast_array[i] = this.realInputStream.readByte ();\n+\treturn;\n+      }\n+      if (clazz == Character.TYPE)\n+      {\n+\tchar[] cast_array = (char[])array;\n+\tfor (int i=0; i < cast_array.length; i++)\n+\t  cast_array[i] = this.realInputStream.readChar ();\n+\treturn;\n+      }\n+      if (clazz == Double.TYPE)\n+      {\n+\tdouble[] cast_array = (double[])array;\n+\tfor (int i=0; i < cast_array.length; i++)\n+\t  cast_array[i] = this.realInputStream.readDouble ();\n+\treturn;\n+      }\n+      if (clazz == Float.TYPE)\n+      {\n+\tfloat[] cast_array = (float[])array;\n+\tfor (int i=0; i < cast_array.length; i++)\n+\t  cast_array[i] = this.realInputStream.readFloat ();\n+\treturn;\n+      }\n+      if (clazz == Integer.TYPE)\n+      {\n+\tint[] cast_array = (int[])array;\n+\tfor (int i=0; i < cast_array.length; i++)\n+\t  cast_array[i] = this.realInputStream.readInt ();\n+\treturn;\n+      }\n+      if (clazz == Long.TYPE)\n+      {\n+\tlong[] cast_array = (long[])array;\n+\tfor (int i=0; i < cast_array.length; i++)\n+\t  cast_array[i] = this.realInputStream.readLong ();\n+\treturn;\n+      }\n+      if (clazz == Short.TYPE)\n+      {\n+\tshort[] cast_array = (short[])array;\n+\tfor (int i=0; i < cast_array.length; i++)\n+\t  cast_array[i] = this.realInputStream.readShort ();\n+\treturn;\n+      }\n+    }\n+    else\n+    {\n+      Object[] cast_array = (Object[])array;\n+      for (int i=0; i < cast_array.length; i++)\n+ \t  cast_array[i] = readObject ();\n+    }\n+  }\n+\n+\n+  private void readFields (Object obj, ObjectStreamField[] stream_fields,\n+\t\t\t   boolean call_read_method,\n+\t\t\t   ObjectStreamClass stream_osc)\n+    throws ClassNotFoundException, IOException\n+  {\n+    if (call_read_method)\n+    {\n+      fieldsAlreadyRead = false;\n+      setBlockDataMode (true);\n+      callReadMethod (obj, stream_osc.forClass ());\n+      setBlockDataMode (false);\n+      return;\n+    }\n+\n+    ObjectStreamField[] real_fields =\n+      ObjectStreamClass.lookup (stream_osc.forClass ()).fields;\n+\n+    boolean default_initialize, set_value;\n+    String field_name = null;\n+    Class type = null;\n+    ObjectStreamField stream_field = null;\n+    ObjectStreamField real_field = null;\n+    int stream_idx = 0;\n+    int real_idx = 0;\n+\n+    while (stream_idx < stream_fields.length\n+\t   && real_idx < real_fields.length)\n+    {\n+      default_initialize = false;\n+      set_value = true;\n+\n+      if (stream_idx == stream_fields.length)\n+\tdefault_initialize = true;\n+      else\n+      {\n+\tstream_field = stream_fields[stream_idx];\n+\ttype = stream_field.getType ();\n+      }\n+\n+      if (real_idx == real_fields.length)\n+\tset_value = false;\n+      else\n+      {\n+\treal_field = real_fields[real_idx];\n+\ttype = real_field.getType ();\n+\tfield_name = real_field.getName ();\n+      }\n+\n+      if (set_value && !default_initialize)\n+      {\n+\tint comp_val =\n+\t  real_field.compareTo (stream_field);\n+\n+\tif (comp_val < 0)\n+\t{\n+\t  default_initialize = true;\n+\t  real_idx++;\n+\t}\n+\telse if (comp_val > 0)\n+\t{\n+\t  set_value = false;\n+\t  stream_idx++;\n+\t}\n+\telse\n+\t{\n+\t  real_idx++;\n+\t  stream_idx++;\n+\t}\n+      }\n+\n+      if (type == Boolean.TYPE)\n+      {\n+\tboolean value =\n+\t  default_initialize ? false : this.realInputStream.readBoolean ();\n+\tif (set_value)\n+\t  setBooleanField (obj, field_name, value);\n+      }\n+      else if (type == Byte.TYPE)\n+      {\n+\tbyte value =\n+\t  default_initialize ? 0 : this.realInputStream.readByte ();\n+\tif (set_value)\n+\t  setByteField (obj, field_name, value);\n+      }\n+      else if (type == Character.TYPE)\n+      {\n+\tchar value =\n+\t  default_initialize ? (char)0 : this.realInputStream.readChar ();\n+\tif (set_value)\n+\t  setCharField (obj, field_name, value);\n+      }\n+      else if (type == Double.TYPE)\n+      {\n+\tdouble value =\n+\t  default_initialize ? 0 : this.realInputStream.readDouble ();\n+\tif (set_value)\n+\t  setDoubleField (obj, field_name, value);\n+      }\n+      else if (type == Float.TYPE)\n+      {\n+\tfloat value =\n+\t  default_initialize ? 0 : this.realInputStream.readFloat ();\n+\tif (set_value)\n+\t  setFloatField (obj, field_name, value);\n+      }\n+      else if (type == Integer.TYPE)\n+      {\n+\tint value =\n+\t  default_initialize ? 0 : this.realInputStream.readInt ();\n+\tif (set_value)\n+\t  setIntField (obj, field_name, value);\n+      }\n+      else if (type == Long.TYPE)\n+      {\n+\tlong value =\n+\t  default_initialize ? 0 : this.realInputStream.readLong ();\n+\tif (set_value)\n+\t  setLongField (obj, field_name, value);\n+      }\n+      else if (type == Short.TYPE)\n+      {\n+\tshort value =\n+\t  default_initialize ? (short)0 : this.realInputStream.readShort ();\n+\tif (set_value)\n+\t  setShortField (obj, field_name, value);\n+      }\n+      else\n+      {\n+\tObject value =\n+\t  default_initialize ? null : readObject ();\n+\tif (set_value)\n+\t  setObjectField (obj, field_name,\n+\t\t\t  real_field.getTypeString (), value);\n+      }\n+    }\n+  }\n+\n+\n+  // Toggles writing primitive data to block-data buffer.\n+  private void setBlockDataMode (boolean on)\n+  {\n+//    DEBUGln (\"Setting block data mode to \" + on);\n+\n+    this.readDataFromBlock = on;\n+\n+    if (on)\n+      this.dataInputStream = this.blockDataInput;\n+    else\n+      this.dataInputStream = this.realInputStream;\n+  }\n+\n+\n+  // returns a new instance of REAL_CLASS that has been constructed\n+  // only to th level of CONSTRUCTOR_CLASS (a super class of REAL_CLASS)\n+  private Object newObject (Class real_class, Class constructor_class)\n+  {\n+    try\n+    {\n+      Object obj = allocateObject (real_class);\n+      callConstructor (constructor_class, obj);\n+      return obj;\n+    }\n+    catch (InstantiationException e)\n+    {\n+      return null;\n+    }\n+  }\n+\n+\n+  // runs all registered ObjectInputValidations in prioritized order\n+  // on OBJ\n+  private void invokeValidators () throws InvalidObjectException\n+  {\n+    Object[] validators = new Object[this.validators.size ()];\n+    this.validators.copyInto (validators);\n+    Arrays.sort (validators);\n+\n+    try\n+    {\n+      for (int i=0; i < validators.length; i++)\n+\t((ObjectInputValidation)validators[i]).validateObject ();\n+    }\n+    finally\n+    {\n+      this.validators.removeAllElements ();\n+    }\n+  }\n+\n+\n+  // this native method is used to get access to the protected method\n+  // of the same name in SecurityManger\n+  private static ClassLoader currentClassLoader (SecurityManager sm)\n+  {\n+    // FIXME: This is too simple.\n+    return ClassLoader.getSystemClassLoader ();\n+  }\n+\n+  private static native Field getField (Class klass, String name)\n+    throws java.lang.NoSuchFieldException;\n+\n+  private static native Method getMethod (Class klass, String name, Class args[])\n+    throws java.lang.NoSuchMethodException;\n+\n+  private void callReadMethod (Object obj, Class klass) throws IOException\n+  {\n+    try\n+      {\n+\tClass classArgs[] = {Class.forName (\"java.io.ObjectInputStream\")};\n+\tMethod m = getMethod (klass, \"readObject\", classArgs);\n+\tif (m == null)\n+\t  return;\n+\tObject args[] = {this};\n+\tm.invoke (obj, args);\t\n+      }\n+    catch (Exception _)\n+      {\n+\tthrow new IOException ();\n+      }\n+  }\n+    \n+  private native Object allocateObject (Class clazz)\n+    throws InstantiationException;\n+\n+  private native void callConstructor (Class clazz, Object obj);\n+\n+  private void setBooleanField (Object obj, String field_name,\n+\t\t\t\tboolean val)\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tf.setBoolean (obj, val);\n+      }\n+    catch (Exception _)\n+      {\n+      }    \n+  }\n+\n+  private void setByteField (Object obj, String field_name,\n+\t\t\t\tbyte val)\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tf.setByte (obj, val);\n+      }\n+    catch (Exception _)\n+      {\n+      }    \n+  }\n+\n+  private void setCharField (Object obj, String field_name,\n+\t\t\t     char val)\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tf.setChar (obj, val);\n+      }\n+    catch (Exception _)\n+      {\n+      }    \n+  }\n+\n+  private void setDoubleField (Object obj, String field_name,\n+\t\t\t       double val)\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tf.setDouble (obj, val);\n+      }\n+    catch (Exception _)\n+      {\n+      }    \n+  }\n+\n+  private void setFloatField (Object obj, String field_name,\n+\t\t\t      float val)\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tf.setFloat (obj, val);\n+      }\n+    catch (Exception _)\n+      {\n+      }    \n+  }\n+\n+  private void setIntField (Object obj, String field_name,\n+\t\t\t      int val)\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tf.setInt (obj, val);\n+      }\n+    catch (Exception _)\n+      {\n+      }    \n+  }\n+\n+\n+  private void setLongField (Object obj, String field_name,\n+\t\t\t      long val)\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tf.setLong (obj, val);\n+      }\n+    catch (Exception _)\n+      {\n+      }    \n+  }\n+\n+\n+  private void setShortField (Object obj, String field_name,\n+\t\t\t      short val)\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tf.setShort (obj, val);\n+      }\n+    catch (Exception _)\n+      {\n+      }    \n+  }\n+\n+\n+  private void setObjectField (Object obj, String field_name, String type_code,\n+\t\t\t       Object val)\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\t// FIXME: We should check the type_code here\n+\tf.set (obj, val);\n+      }\n+    catch (Exception _)\n+      {\n+      }    \n+  }\n+\n+  private static final int BUFFER_SIZE = 1024;\n+  private static final Class[] readObjectParams = { ObjectInputStream.class };\n+\n+  private DataInputStream realInputStream;\n+  private DataInputStream dataInputStream;\n+  private DataInputStream blockDataInput;\n+  private int blockDataPosition;\n+  private int blockDataBytes;\n+  private byte[] blockData;\n+  private boolean useSubclassMethod;\n+  private int nextOID;\n+  private boolean resolveEnabled;\n+  private Hashtable objectLookupTable;\n+  private Object currentObject;\n+  private ObjectStreamClass currentObjectStreamClass;\n+  private boolean readDataFromBlock;\n+  private boolean isDeserializing;\n+  private boolean fieldsAlreadyRead;\n+  private Vector validators;\n+\n+\n+/* FIXME: These 2 methods cause a build error on i686-pc-linux-gnu.\n+  private void DEBUG (String msg)\n+  {\n+    System.out.print (msg);\n+  }\n+\n+\n+  private void DEBUGln (String msg)\n+  {\n+    System.out.println (msg);\n+  }\n+* end FIXME */\n+}\n+\n+\n+// used to keep a prioritized list of object validators\n+class ValidatorAndPriority implements Comparable\n+{\n+  int priority;\n+  ObjectInputValidation validator;\n+\n+  ValidatorAndPriority (ObjectInputValidation validator, int priority)\n+  {\n+    this.priority = priority;\n+    this.validator = validator;\n+  }\n+\n+  public int compareTo (Object o)\n+  {\n+    ValidatorAndPriority vap = (ValidatorAndPriority)o;\n+    return this.priority - vap.priority;\n+  }\n+}"}, {"sha": "cf3508ec6b9a5067847110a594671fd070eea12c", "filename": "libjava/java/io/ObjectInputValidation.java", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectInputValidation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectInputValidation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputValidation.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,50 @@\n+/* ObjectInputValidation.java -- Validate an object \n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io; \n+\n+/**\n+  * What does this interface really do?\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public abstract interface ObjectInputValidation\n+{\n+\n+/**\n+  * This method is called to validate an object.  If the object is invalid\n+  * an exception is thrown.\n+  *\n+  * @exception InvalidObjectException If the object is invalid\n+  */\n+public abstract void\n+validateObject() throws InvalidObjectException;\n+\n+} // interface ObjectInputValidation\n+"}, {"sha": "56b339071092c0ef8aed893dd70bb81409a30ba2", "filename": "libjava/java/io/ObjectOutput.java", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectOutput.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectOutput.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutput.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,116 @@\n+/* ObjectOutput.java -- Interface for writing objects to a stream\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+/**\n+  * This interface extends <code>DataOutput</code> to provide the additional\n+  * facility of writing object instances to a stream.  It also adds some\n+  * additional methods to make the interface more <code>OutputStream</code> like.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public abstract interface ObjectOutput extends DataOutput\n+{\n+\n+\n+/**\n+  * This method writes the specified byte to the output stream.\n+  *\n+  * @param b The byte to write.\n+  *\n+  * @exception IOException If an error occurs.\n+  */\n+public abstract void\n+write(int b) throws IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method writes all the bytes in the specified byte array to the\n+  * output stream.\n+  *\n+  * @param buf The array of bytes to write.\n+  * \n+  * @exception IOException If an error occurs.\n+  */\n+public abstract void\n+write(byte[] buf) throws IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method writes <code>len</code> bytes from the specified array\n+  * starting at index <code>offset</code> into that array.\n+  *\n+  * @param buf The byte array to write from.\n+  * @param offset The index into the byte array to start writing from.\n+  * @param len The number of bytes to write.\n+  *\n+  * @exception IOException If an error occurs.\n+  */\n+public abstract void\n+write(byte[] buf, int offset, int len) throws IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method writes a object instance to a stream.  The format of the\n+  * data written is determined by the actual implementation of this method\n+  *\n+  * @param obj The object to write\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public abstract void\n+writeObject(Object obj) throws IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method causes any buffered data to be flushed out to the underlying\n+  * stream\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public abstract void\n+flush() throws IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method closes the underlying stream.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public abstract void\n+close() throws IOException;\n+\n+} // interface ObjectOutput\n+"}, {"sha": "a98b55baf191da6ce1e8434ae764ad2af126b5ff", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "added", "additions": 1335, "deletions": 0, "changes": 1335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,1335 @@\n+/* ObjectOutputStream.java -- Class used to write serialized objects\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.Hashtable;\n+\n+import gnu.java.io.ObjectIdentityWrapper;\n+import gnu.java.lang.reflect.TypeSignature;\n+\n+/**\n+   An <code>ObjectOutputStream</code> can be used to write objects\n+   as well as primitive data in a platform-independent manner to an\n+   <code>OutputStream</code>.\n+\n+   The data produced by an <code>ObjectOutputStream</code> can be read\n+   and reconstituted by an <code>ObjectInputStream</code>.\n+\n+   <code>writeObject (Object)</code> is used to write Objects, the\n+   <code>write&lt;type&gt;</code> methods are used to write primitive\n+   data (as in <code>DataOutputStream</code>). Strings can be written\n+   as objects or as primitive data.\n+\n+   Not all objects can be written out using an\n+   <code>ObjectOutputStream</code>.  Only those objects that are an\n+   instance of <code>java.io.Serializable</code> can be written.\n+\n+   Using default serialization, information about the class of an\n+   object is written, all of the non-transient, non-static fields of\n+   the object are written, if any of these fields are objects, the are\n+   written out in the same manner.\n+\n+   An object is only written out the first time it is encountered.  If\n+   the object is encountered later, a reference to it is written to\n+   the underlying stream.  Thus writing circular object graphs\n+   does not present a problem, nor are relationships between objects\n+   in a graph lost.\n+\n+   Example usage:\n+     <pre>\n+     Hashtable map = new Hashtable ();\n+     map.put (\"one\", new Integer (1));\n+     map.put (\"two\", new Integer (2));\n+\n+     ObjectOutputStream oos =\n+       new ObjectOutputStream (new FileOutputStream (\"numbers\"));\n+     oos.writeObject (map);\n+     oos.close ();\n+\n+     ObjectInputStream ois =\n+       new ObjectInputStream (new FileInputStream (\"numbers\"));\n+     Hashtable newmap = (Hashtable)ois.readObject ();\n+\n+     System.out.println (newmap);\n+     </pre>\n+\n+   The default serialization can be overriden in two ways.\n+\n+   By defining a method <code>private void\n+   writeObject (ObjectOutputStream)</code>, a class can dictate exactly\n+   how information about itself is written.\n+   <code>defaultWriteObject ()</code> may be called from this method to\n+   carry out default serialization.  This method is not\n+   responsible for dealing with fields of super-classes or subclasses.\n+\n+   By implementing <code>java.io.Externalizable</code>.  This gives\n+   the class complete control over the way it is written to the\n+   stream.  If this approach is used the burden of writing superclass\n+   and subclass data is transfered to the class implementing\n+   <code>java.io.Externalizable</code>.\n+\n+   @see java.io.DataOutputStream\n+   @see java.io.Externalizable\n+   @see java.io.ObjectInputStream\n+   @see java.io.Serializable\n+   @see XXX: java serialization spec\n+*/\n+public class ObjectOutputStream extends OutputStream\n+  implements ObjectOutput, ObjectStreamConstants\n+{\n+  /**\n+     Creates a new <code>ObjectOutputStream</code> that will do all of\n+     its writing onto <code>out</code>.  This method also initializes\n+     the stream by writing the header information (stream magic number\n+     and stream version).\n+\n+     @exception IOException Writing stream header to underlying\n+     stream cannot be completed.\n+\n+     @see writeStreamHeader ()\n+  */\n+  public ObjectOutputStream (OutputStream out) throws IOException\n+  {\n+    realOutput = new DataOutputStream (out);\n+    blockData = new byte[ BUFFER_SIZE ];\n+    blockDataCount = 0;\n+    blockDataOutput = new DataOutputStream (this);\n+    setBlockDataMode (true);\n+    replacementEnabled = false;\n+    isSerializing = false;\n+    nextOID = baseWireHandle;\n+    OIDLookupTable = new Hashtable ();\n+    protocolVersion = defaultProtocolVersion;\n+    useSubclassMethod = false;\n+    writeStreamHeader ();\n+  }\n+\n+\n+  /**\n+     Writes a representation of <code>obj</code> to the underlying\n+     output stream by writing out information about its class, then\n+     writing out each of the objects non-transient, non-static\n+     fields.  If any of these fields are other objects,\n+     the are written out in the same manner.\n+\n+     This method can be overriden by a class by implementing\n+     <code>private void writeObject (ObjectOutputStream)</code>.\n+\n+     If an exception is thrown from this method, the stream is left in\n+     an undefined state.\n+\n+     @exception NotSerializableException An attempt was made to\n+     serialize an <code>Object</code> that is not serializable.\n+\n+     @exception IOException Exception from underlying\n+     <code>OutputStream</code>.\n+  */\n+  public final void writeObject (Object obj) throws IOException\n+  {\n+    if (useSubclassMethod)\n+    {\n+      writeObjectOverride (obj);\n+      return;\n+    }\n+\n+    boolean was_serializing = isSerializing;\n+\n+    if (! was_serializing)\n+      setBlockDataMode (false);\n+\n+    try\n+    {\n+      isSerializing = true;\n+      boolean replaceDone = false;\n+\n+      drain ();\n+\n+      while (true)\n+      {\n+\tif (obj == null)\n+\t{\n+\t  realOutput.writeByte (TC_NULL);\n+\t  break;\n+\t}\n+\n+\tInteger handle = findHandle (obj);\n+\tif (handle != null)\n+\t{\n+\t  realOutput.writeByte (TC_REFERENCE);\n+\t  realOutput.writeInt (handle.intValue ());\n+\t  break;\n+\t}\n+\n+\tif (obj instanceof Class)\n+\t{\n+\t  realOutput.writeByte (TC_CLASS);\n+\t  writeObject (ObjectStreamClass.lookup ((Class)obj));\n+\t  assignNewHandle (obj);\n+\t  break;\n+\t}\n+\n+\tif (obj instanceof ObjectStreamClass)\n+\t{\n+\t  ObjectStreamClass osc = (ObjectStreamClass)obj;\n+\t  realOutput.writeByte (TC_CLASSDESC);\n+\t  realOutput.writeUTF (osc.getName ());\n+\t  realOutput.writeLong (osc.getSerialVersionUID ());\n+\t  assignNewHandle (obj);\n+\n+\t  int flags = osc.getFlags ();\n+\n+\t  if (protocolVersion == PROTOCOL_VERSION_2\n+\t      && osc.isExternalizable ())\n+\t    flags |= SC_BLOCK_DATA;\n+\n+\t  realOutput.writeByte (flags);\n+\n+\t  ObjectStreamField[] fields = osc.fields;\n+\t  realOutput.writeShort (fields.length);\n+\n+\t  ObjectStreamField field;\n+\t  for (int i=0; i < fields.length; i++)\n+\t  {\n+\t    field = fields[i];\n+\t    realOutput.writeByte (field.getTypeCode ());\n+\t    realOutput.writeUTF (field.getName ());\n+\n+\t    if (! field.isPrimitive ())\n+\t      writeObject (field.getTypeString ());\n+\t  }\n+\n+\t  setBlockDataMode (true);\n+\t  annotateClass (osc.forClass ());\n+\t  setBlockDataMode (false);\n+\t  realOutput.writeByte (TC_ENDBLOCKDATA);\n+\n+\t  if (osc.isSerializable ())\n+\t    writeObject (osc.getSuper ());\n+\t  else\n+\t    writeObject (null);\n+\t  break;\n+\t}\n+\n+\n+\tObject replacedObject = null;\n+\n+\tif ((replacementEnabled || obj instanceof Replaceable)\n+\t    && ! replaceDone)\n+\t{\n+\t  replacedObject = obj;\n+\n+\t  if (obj instanceof Replaceable)\n+\t    obj = ((Replaceable)obj).writeReplace ();\n+\n+\t  if (replacementEnabled)\n+\t    obj = replaceObject (obj);\n+\n+\t  replaceDone = true;\n+\t  continue;\n+\t}\n+\n+\tif (obj instanceof String)\n+\t{\n+\t  realOutput.writeByte (TC_STRING);\n+\t  assignNewHandle (obj);\n+\t  realOutput.writeUTF ((String)obj);\n+\t  break;\n+\t}\n+\n+\tClass clazz = obj.getClass ();\n+\tObjectStreamClass osc = ObjectStreamClass.lookup (clazz);\n+\tif (osc == null)\n+\t  throw new NotSerializableException (\"The class \"\n+\t\t\t\t\t      + clazz.getName ()\n+\t\t\t\t\t      + \" is not Serializable\");\n+\n+\tif (clazz.isArray ())\n+\t{\n+\t  realOutput.writeByte (TC_ARRAY);\n+\t  writeObject (osc);\n+\t  assignNewHandle (obj);\n+\t  writeArraySizeAndElements (obj, clazz);\n+\t  break;\n+\t}\n+\n+\trealOutput.writeByte (TC_OBJECT);\n+\twriteObject (osc);\n+\n+\tif (replaceDone)\n+\t  assignNewHandle (replacedObject);\n+\telse\n+\t  assignNewHandle (obj);\n+\n+\tif (obj instanceof Externalizable)\n+\t{\n+\t  if (protocolVersion == PROTOCOL_VERSION_2)\n+\t    setBlockDataMode (true);\n+\n+\t  ((Externalizable)obj).writeExternal (this);\n+\n+\t  if (protocolVersion == PROTOCOL_VERSION_2)\n+\t  {\n+\t    setBlockDataMode (false);\n+\t    drain ();\n+\t  }\n+\n+\t  break;\n+\t}\n+\n+\tif (obj instanceof Serializable)\n+\t{\n+\t  currentObject = obj;\n+\t  ObjectStreamClass[] hierarchy =\n+\t    ObjectStreamClass.getObjectStreamClasses (clazz);\n+\n+\t  boolean has_write;\n+\t  for (int i=0; i < hierarchy.length; i++)\n+\t  {\n+\t    currentObjectStreamClass = hierarchy[i];\n+\n+\t    has_write = currentObjectStreamClass.hasWriteMethod ();\n+\t    writeFields (obj, currentObjectStreamClass.fields,\n+\t\t\t has_write);\n+\n+\t    fieldsAlreadyWritten = false;\n+\n+\t    if (has_write)\n+\t    {\n+\t      drain ();\n+\t      realOutput.writeByte (TC_ENDBLOCKDATA);\n+\t    }\n+\t  }\n+\n+\t  currentObject = null;\n+\t  currentObjectStreamClass = null;\n+\t  currentPutField = null;\n+\t  break;\n+\t}\n+\n+\tthrow new NotSerializableException (\"Instances of the class \"\n+\t\t\t\t\t    + clazz.getName ()\n+\t\t\t\t\t    + \" are not Serializable\");\n+      } // end pseudo-loop\n+    }\n+    catch (IOException e)\n+    {\n+      realOutput.writeByte (TC_EXCEPTION);\n+      reset (true);\n+\n+      try\n+      {\n+\twriteObject (e);\n+      }\n+      catch (IOException ioe)\n+      {\n+\tthrow new StreamCorruptedException (\"Exception \" + ioe + \" thrown while exception was being written to stream.\");\n+      }\n+\n+      reset (true);\n+    }\n+    finally\n+    {\n+      isSerializing = was_serializing;\n+\n+      if (! was_serializing)\n+\tsetBlockDataMode (true);\n+    }\n+  }\n+\n+\n+  /**\n+     Writes the current objects non-transient, non-static fields from\n+     the current class to the underlying output stream.\n+\n+     This method is intended to be called from within a object's\n+     <code>private void writeObject (ObjectOutputStream)</code>\n+     method.\n+\n+     @exception NotActiveException This method was called from a\n+     context other than from the current object's and current class's\n+     <code>private void writeObject (ObjectOutputStream)</code>\n+     method.\n+\n+     @exception IOException Exception from underlying\n+     <code>OutputStream</code>.\n+  */\n+  public void defaultWriteObject ()\n+    throws IOException, NotActiveException\n+  {\n+    markFieldsWritten ();\n+    writeFields (currentObject, currentObjectStreamClass.fields, false);\n+  }\n+\n+\n+  private void markFieldsWritten () throws IOException\n+  {\n+    if (currentObject == null || currentObjectStreamClass == null)\n+      throw new NotActiveException (\"defaultWriteObject called by non-active class and/or object\");\n+\n+    if (fieldsAlreadyWritten)\n+      throw new IOException (\"Only one of putFields and defalutWriteObject may be called, and it may only be called once\");\n+\n+    fieldsAlreadyWritten = true;\n+  }\n+\n+\n+  /**\n+     Resets stream to state equivalent to the state just after it was\n+     constructed.\n+\n+     Causes all objects previously written to the stream to be\n+     forgotten.  A notification of this reset is also written to the\n+     underlying stream.\n+\n+     @exception IOException Exception from underlying\n+     <code>OutputStream</code> or reset called while serialization is\n+     in progress.\n+  */\n+  public void reset () throws IOException\n+  {\n+    reset (false);\n+  }\n+\n+\n+  private void reset (boolean internal) throws IOException\n+  {\n+    if (!internal)\n+    {\n+      if (isSerializing)\n+\tthrow new IOException (\"Reset called while serialization in progress\");\n+\n+      realOutput.writeByte (TC_RESET);\n+    }\n+\n+    clearHandles ();\n+  }\n+\n+\n+  /**\n+     Informs this <code>ObjectOutputStream</code> to write data\n+     according to the specified protocol.  There are currently two\n+     different protocols, specified by <code>PROTOCOL_VERSION_1</code>\n+     and <code>PROTOCOL_VERSION_2</code>.  This implementation writes\n+     data using <code>PROTOCOL_VERSION_1</code> by default, as is done\n+     by the JDK 1.1.\n+\n+     A non-portable method, <code>setDefaultProtocolVersion (int\n+     version)</code> is provided to change the default protocol\n+     version.\n+\n+     For an explination of the differences beween the two protocols\n+     see XXX: the Java ObjectSerialization Specification.\n+\n+     @exception IOException if <code>version</code> is not a valid\n+     protocol\n+\n+     @see setDefaultProtocolVersion (int)\n+  */\n+  public void useProtocolVersion (int version) throws IOException\n+  {\n+    if (version != PROTOCOL_VERSION_1 && version != PROTOCOL_VERSION_2)\n+      throw new IOException (\"Invalid protocol version requested.\");\n+\n+    protocolVersion = version;\n+  }\n+\n+\n+  /**\n+     <em>GNU $classpath specific</em>\n+\n+     Changes the default stream protocol used by all\n+     <code>ObjectOutputStream</code>s.  There are currently two\n+     different protocols, specified by <code>PROTOCOL_VERSION_1</code>\n+     and <code>PROTOCOL_VERSION_2</code>.  The default default is\n+     <code>PROTOCOL_VERSION_1</code>.\n+\n+     @exception IOException if <code>version</code> is not a valid\n+     protocol\n+\n+     @see useProtocolVersion (int)\n+  */\n+  public static void setDefaultProtocolVersion (int version)\n+    throws IOException\n+  {\n+    if (version != PROTOCOL_VERSION_1 && version != PROTOCOL_VERSION_2)\n+      throw new IOException (\"Invalid protocol version requested.\");\n+\n+    defaultProtocolVersion = version;\n+  }\n+\n+\n+  /**\n+     An empty hook that allows subclasses to write extra information\n+     about classes to the stream.  This method is called the first\n+     time each class is seen, and after all of the standard\n+     information about the class has been written.\n+\n+     @exception IOException Exception from underlying\n+     <code>OutputStream</code>.\n+\n+     @see java.io.ObjectInputStream#resolveClass (java.io.ObjectStreamClass)\n+  */\n+  protected void annotateClass (Class cl) throws IOException\n+  {}\n+\n+\n+  /**\n+     Allows subclasses to replace objects that are written to the\n+     stream with other objects to be written in their place.  This\n+     method is called the first time each object is encountered\n+     (modulo reseting of the stream).\n+\n+     This method must be enabled before it will be called in the\n+     serialization process.\n+\n+     @exception IOException Exception from underlying\n+     <code>OutputStream</code>.\n+\n+     @see enableReplaceObject (boolean)\n+  */\n+  protected Object replaceObject (Object obj) throws IOException\n+  {\n+    return obj;\n+  }\n+\n+\n+  /**\n+     If <code>enable</code> is <code>true</code> and this object is\n+     trusted, then <code>replaceObject (Object)</code> will be called\n+     in subsequent calls to <code>writeObject (Object)</code>.\n+     Otherwise, <code>replaceObject (Object)</code> will not be called.\n+\n+     @exception SecurityException This class is not trusted.\n+  */\n+  protected boolean enableReplaceObject (boolean enable)\n+    throws SecurityException\n+  {\n+    if (enable)\n+      if (getClass ().getClassLoader () != null)\n+\tthrow new SecurityException (\"Untrusted ObjectOutputStream subclass attempted to enable object replacement\");\n+\n+    boolean old_val = replacementEnabled;\n+    replacementEnabled = enable;\n+    return old_val;\n+  }\n+\n+\n+  /**\n+     Writes stream magic and stream version information to the\n+     underlying stream.\n+\n+     @exception IOException Exception from underlying\n+     <code>OutputStream</code>.\n+  */\n+  protected void writeStreamHeader () throws IOException\n+  {\n+    realOutput.writeShort (STREAM_MAGIC);\n+    realOutput.writeShort (STREAM_VERSION);\n+  }\n+\n+\n+\n+  /**\n+     Protected constructor that allows subclasses to override\n+     serialization.  This constructor should be called by subclasses\n+     that wish to override <code>writeObject (Object)</code>.  This\n+     method does a security check <i>NOTE: currently not\n+     implemented</i>, then sets a flag that informs\n+     <code>writeObject (Object)</code> to call the subclasses\n+     <code>writeObjectOverride (Object)</code> method.\n+\n+     @see writeObjectOverride (Object)\n+  */\n+  protected ObjectOutputStream () throws IOException, SecurityException\n+  {\n+    SecurityManager sec_man = System.getSecurityManager ();\n+    if (sec_man != null)\n+      sec_man.checkPermission (SUBCLASS_IMPLEMENTATION_PERMISSION);\n+    useSubclassMethod = true;\n+  }\n+\n+\n+  /**\n+     This method allows subclasses to override the default\n+     serialization mechanism provided by\n+     <code>ObjectOutputStream</code>.  To make this method be used for\n+     writing objects, subclasses must invoke the 0-argument\n+     constructor on this class from there constructor.\n+\n+     @see ObjectOutputStream ()\n+\n+     @exception NotActiveException Subclass has arranged for this\n+     method to be called, but did not implement this method.\n+  */\n+  protected void writeObjectOverride (Object obj) throws NotActiveException,\n+    IOException\n+  {\n+    throw new NotActiveException (\"Subclass of ObjectOutputStream must implement writeObjectOverride\");\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#write (int)\n+  */\n+  public void write (int data) throws IOException\n+  {\n+    if (writeDataAsBlocks)\n+    {\n+      if (blockDataCount == BUFFER_SIZE)\n+\tdrain ();\n+\n+      blockData[ blockDataCount++ ] = (byte)data;\n+    }\n+    else\n+      realOutput.write (data);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#write (byte[])\n+  */\n+  public void write (byte b[]) throws IOException\n+  {\n+    write (b, 0, b.length);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#write (byte[],int,int)\n+  */\n+  public void write (byte b[], int off, int len) throws IOException\n+  {\n+    if (writeDataAsBlocks)\n+    {\n+      if (len < 0)\n+\tthrow new IndexOutOfBoundsException ();\n+\n+      if (blockDataCount + len < BUFFER_SIZE)\n+      {\n+\tSystem.arraycopy (b, off, blockData, blockDataCount, len);\n+\tblockDataCount += len;\n+      }\n+      else\n+      {\n+\tdrain ();\n+\twriteBlockDataHeader (len);\n+\trealOutput.write (b, off, len);\n+      }\n+    }\n+    else\n+      realOutput.write (b, off, len);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#flush ()\n+  */\n+  public void flush () throws IOException\n+  {\n+    drain ();\n+    realOutput.flush ();\n+  }\n+\n+\n+  /**\n+     Causes the block-data buffer to be written to the underlying\n+     stream, but does not flush underlying stream.\n+\n+     @exception IOException Exception from underlying\n+     <code>OutputStream</code>.\n+  */\n+  protected void drain () throws IOException\n+  {\n+    if (blockDataCount == 0)\n+      return;\n+\n+    writeBlockDataHeader (blockDataCount);\n+    realOutput.write (blockData, 0, blockDataCount);\n+    blockDataCount = 0;\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#close ()\n+  */\n+  public void close () throws IOException\n+  {\n+    drain ();\n+    realOutput.close ();\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#writeBoolean (boolean)\n+  */\n+  public void writeBoolean (boolean data) throws IOException\n+  {\n+    dataOutput.writeBoolean (data);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#writeByte (int)\n+  */\n+  public void writeByte (int data) throws IOException\n+  {\n+    dataOutput.writeByte (data);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#writeShort (int)\n+  */\n+  public void writeShort (int data) throws IOException\n+  {\n+    dataOutput.writeShort (data);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#writeChar (int)\n+  */\n+  public void writeChar (int data) throws IOException\n+  {\n+    dataOutput.writeChar (data);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#writeInt (int)\n+  */\n+  public void writeInt (int data) throws IOException\n+  {\n+    dataOutput.writeInt (data);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#writeLong (long)\n+  */\n+  public void writeLong (long data) throws IOException\n+  {\n+    dataOutput.writeLong (data);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#writeFloat (float)\n+  */\n+  public void writeFloat (float data) throws IOException\n+  {\n+    dataOutput.writeFloat (data);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#writeDouble (double)\n+  */\n+  public void writeDouble (double data) throws IOException\n+  {\n+    dataOutput.writeDouble (data);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#writeBytes (java.lang.String)\n+  */\n+  public void writeBytes (String data) throws IOException\n+  {\n+    dataOutput.writeBytes (data);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#writeChars (java.lang.String)\n+  */\n+  public void writeChars (String data) throws IOException\n+  {\n+    dataOutput.writeChars (data);\n+  }\n+\n+\n+  /**\n+     @see java.io.DataOutputStream#writeUTF (java.lang.String)\n+  */\n+  public void writeUTF (String data) throws IOException\n+  {\n+    dataOutput.writeUTF (data);\n+  }\n+\n+\n+  /**\n+     This class allows a class to specify exactly which fields should\n+     be written, and what values should be written for these fields.\n+\n+     XXX: finish up comments\n+  */\n+  public static abstract class PutField\n+  {\n+    public abstract void put (String name, boolean value)\n+      throws IOException, IllegalArgumentException;\n+    public abstract void put (String name, byte value)\n+      throws IOException, IllegalArgumentException;\n+    public abstract void put (String name, char value)\n+      throws IOException, IllegalArgumentException;\n+    public abstract void put (String name, double value)\n+      throws IOException, IllegalArgumentException;\n+    public abstract void put (String name, float value)\n+      throws IOException, IllegalArgumentException;\n+    public abstract void put (String name, int value)\n+      throws IOException, IllegalArgumentException;\n+    public abstract void put (String name, long value)\n+      throws IOException, IllegalArgumentException;\n+    public abstract void put (String name, short value)\n+      throws IOException, IllegalArgumentException;\n+    public abstract void put (String name, Object value)\n+      throws IOException, IllegalArgumentException;\n+    public abstract void write (ObjectOutput out) throws IOException;\n+  }\n+\n+\n+  public PutField putFields () throws IOException\n+  {\n+    markFieldsWritten ();\n+\n+    currentPutField = new PutField ()\n+      {\n+\tprivate byte[] prim_field_data\n+\t  = new byte[currentObjectStreamClass.primFieldSize];\n+\tprivate Object[] objs\n+\t  = new Object[currentObjectStreamClass.objectFieldCount];\n+\n+\tpublic void put (String name, boolean value)\n+\t  throws IOException, IllegalArgumentException\n+\t  {\n+\t    ObjectStreamField field\n+\t      = currentObjectStreamClass.getField (name);\n+\t    checkType (field, 'Z');\n+\t    prim_field_data[field.getOffset ()] = (byte)(value ? 1 : 0);\n+\t  }\n+\n+\tpublic void put (String name, byte value)\n+\t  throws IOException, IllegalArgumentException\n+\t  {\n+\t    ObjectStreamField field\n+\t      = currentObjectStreamClass.getField (name);\n+\t    checkType (field, 'B');\n+\t    prim_field_data[field.getOffset ()] = value;\n+\t  }\n+\n+\tpublic void put (String name, char value)\n+\t  throws IOException, IllegalArgumentException\n+\t  {\n+\t    ObjectStreamField field\n+\t      = currentObjectStreamClass.getField (name);\n+\t    checkType (field, 'B');\n+\t    int off = field.getOffset ();\n+\t    prim_field_data[off++] = (byte)(value >>> 8);\n+\t    prim_field_data[off] = (byte)value;\n+\t  }\n+\n+\tpublic void put (String name, double value)\n+\t  throws IOException, IllegalArgumentException\n+\t  {\n+\t    ObjectStreamField field\n+\t      = currentObjectStreamClass.getField (name);\n+\t    checkType (field, 'B');\n+\t    int off = field.getOffset ();\n+\t    long l_value = Double.doubleToLongBits (value);\n+\t    prim_field_data[off++] = (byte)(l_value >>> 52);\n+\t    prim_field_data[off++] = (byte)(l_value >>> 48);\n+\t    prim_field_data[off++] = (byte)(l_value >>> 40);\n+\t    prim_field_data[off++] = (byte)(l_value >>> 32);\n+\t    prim_field_data[off++] = (byte)(l_value >>> 24);\n+\t    prim_field_data[off++] = (byte)(l_value >>> 16);\n+\t    prim_field_data[off++] = (byte)(l_value >>> 8);\n+\t    prim_field_data[off] = (byte)l_value;\n+\t  }\n+\n+\tpublic void put (String name, float value)\n+\t  throws IOException, IllegalArgumentException\n+\t  {\n+\t    ObjectStreamField field\n+\t      = currentObjectStreamClass.getField (name);\n+\t    checkType (field, 'B');\n+\t    int off = field.getOffset ();\n+\t    int i_value = Float.floatToIntBits (value);\n+\t    prim_field_data[off++] = (byte)(i_value >>> 24);\n+\t    prim_field_data[off++] = (byte)(i_value >>> 16);\n+\t    prim_field_data[off++] = (byte)(i_value >>> 8);\n+\t    prim_field_data[off] = (byte)i_value;\n+\t  }\n+\n+\tpublic void put (String name, int value)\n+\t  throws IOException, IllegalArgumentException\n+\t  {\n+\t    ObjectStreamField field\n+\t      = currentObjectStreamClass.getField (name);\n+\t    checkType (field, 'B');\n+\t    int off = field.getOffset ();\n+\t    prim_field_data[off++] = (byte)(value >>> 24);\n+\t    prim_field_data[off++] = (byte)(value >>> 16);\n+\t    prim_field_data[off++] = (byte)(value >>> 8);\n+\t    prim_field_data[off] = (byte)value;\n+\t  }\n+\n+\tpublic void put (String name, long value)\n+\t  throws IOException, IllegalArgumentException\n+\t  {\n+\t    ObjectStreamField field\n+\t      = currentObjectStreamClass.getField (name);\n+\t    checkType (field, 'B');\n+\t    int off = field.getOffset ();\n+\t    prim_field_data[off++] = (byte)(value >>> 52);\n+\t    prim_field_data[off++] = (byte)(value >>> 48);\n+\t    prim_field_data[off++] = (byte)(value >>> 40);\n+\t    prim_field_data[off++] = (byte)(value >>> 32);\n+\t    prim_field_data[off++] = (byte)(value >>> 24);\n+\t    prim_field_data[off++] = (byte)(value >>> 16);\n+\t    prim_field_data[off++] = (byte)(value >>> 8);\n+\t    prim_field_data[off] = (byte)value;\n+\t  }\n+\n+\tpublic void put (String name, short value)\n+\t  throws IOException, IllegalArgumentException\n+\t  {\n+\t    ObjectStreamField field\n+\t      = currentObjectStreamClass.getField (name);\n+\t    checkType (field, 'B');\n+\t    int off = field.getOffset ();\n+\t    prim_field_data[off++] = (byte)(value >>> 8);\n+\t    prim_field_data[off] = (byte)value;\n+\t  }\n+\n+\tpublic void put (String name, Object value)\n+\t  throws IOException, IllegalArgumentException\n+\t  {\n+\t    ObjectStreamField field\n+\t      = currentObjectStreamClass.getField (name);\n+\t    if (! field.getType ().isAssignableFrom (value.getClass ()))\n+\t      throw new IllegalArgumentException ();\n+\t    objs[field.getOffset ()] = value;\n+\t  }\n+\n+\tpublic void write (ObjectOutput out) throws IOException\n+\t  {\n+\t    out.write (prim_field_data);\n+\t    for (int i = 0; i < objs.length; ++ i)\n+\t      out.writeObject (objs[i]);\n+\t  }\n+\n+\tprivate void checkType (ObjectStreamField field, char type)\n+\t  throws IllegalArgumentException\n+\t  {\n+\t    if (TypeSignature.getEncodingOfClass (field.getType ()).charAt (0) != type)\n+\t      throw new IllegalArgumentException ();\n+\t  }\n+      };\n+    // end PutFieldImpl\n+\n+    return currentPutField;\n+  }\n+\n+\n+  public void writeFields () throws IOException\n+  {\n+    if (currentPutField == null)\n+      throw new NotActiveException (\"writeFields can only be called after putFields has been called\");\n+\n+    currentPutField.write (this);\n+  }\n+\n+\n+  // write out the block-data buffer, picking the correct header\n+  // depending on the size of the buffer\n+  private void writeBlockDataHeader (int size) throws IOException\n+  {\n+    if (size < 256)\n+    {\n+      realOutput.writeByte (TC_BLOCKDATA);\n+      realOutput.write (size);\n+    }\n+    else\n+    {\n+      realOutput.writeByte (TC_BLOCKDATALONG);\n+      realOutput.writeInt (size);\n+    }\n+  }\n+\n+\n+  // lookup the handle for OBJ, return null if OBJ doesn't have a\n+  // handle yet\n+  private Integer findHandle (Object obj)\n+  {\n+    return (Integer)OIDLookupTable.get (new ObjectIdentityWrapper (obj));\n+  }\n+\n+\n+  // assigns the next availible handle to OBJ\n+  private int assignNewHandle (Object obj)\n+  {\n+    OIDLookupTable.put (new ObjectIdentityWrapper (obj),\n+\t\t\tnew Integer (nextOID));\n+    return nextOID++;\n+  }\n+\n+\n+  // resets mapping from objects to handles\n+  private void clearHandles ()\n+  {\n+    nextOID = baseWireHandle;\n+    OIDLookupTable.clear ();\n+  }\n+\n+\n+  // write out array size followed by each element of the array\n+  private void writeArraySizeAndElements (Object array, Class clazz)\n+    throws IOException\n+  {\n+    int length = Array.getLength (array);\n+\n+    if (clazz.isPrimitive ())\n+    {\n+      if (clazz == Boolean.TYPE)\n+      {\n+\tboolean[] cast_array = (boolean[])array;\n+\trealOutput.writeInt (length);\n+\tfor (int i=0; i < length; i++)\n+\t  realOutput.writeBoolean (cast_array[i]);\n+\treturn;\n+      }\n+      if (clazz == Byte.TYPE)\n+      {\n+\tbyte[] cast_array = (byte[])array;\n+\trealOutput.writeInt (length);\n+\tfor (int i=0; i < length; i++)\n+\t  realOutput.writeByte (cast_array[i]);\n+\treturn;\n+      }\n+      if (clazz == Character.TYPE)\n+      {\n+\tchar[] cast_array = (char[])array;\n+\trealOutput.writeInt (length);\n+\tfor (int i=0; i < length; i++)\n+\t  realOutput.writeChar (cast_array[i]);\n+\treturn;\n+      }\n+      if (clazz == Double.TYPE)\n+      {\n+\tdouble[] cast_array = (double[])array;\n+\trealOutput.writeInt (length);\n+\tfor (int i=0; i < length; i++)\n+\t  realOutput.writeDouble (cast_array[i]);\n+\treturn;\n+      }\n+      if (clazz == Float.TYPE)\n+      {\n+\tfloat[] cast_array = (float[])array;\n+\trealOutput.writeInt (length);\n+\tfor (int i=0; i < length; i++)\n+\t  realOutput.writeFloat (cast_array[i]);\n+\treturn;\n+      }\n+      if (clazz == Integer.TYPE)\n+      {\n+\tint[] cast_array = (int[])array;\n+\trealOutput.writeInt (length);\n+\tfor (int i=0; i < length; i++)\n+\t  realOutput.writeInt (cast_array[i]);\n+\treturn;\n+      }\n+      if (clazz == Long.TYPE)\n+      {\n+\tlong[] cast_array = (long[])array;\n+\trealOutput.writeInt (length);\n+\tfor (int i=0; i < length; i++)\n+\t  realOutput.writeLong (cast_array[i]);\n+\treturn;\n+      }\n+      if (clazz == Short.TYPE)\n+      {\n+\tshort[] cast_array = (short[])array;\n+\trealOutput.writeInt (length);\n+\tfor (int i=0; i < length; i++)\n+\t  realOutput.writeShort (cast_array[i]);\n+\treturn;\n+      }\n+    }\n+    else\n+    {\n+      Object[] cast_array = (Object[])array;\n+      realOutput.writeInt (length);\n+      for (int i=0; i < length; i++)\n+\twriteObject (cast_array[i]);\n+    }\n+  }\n+\n+\n+  // writes out FIELDS of OBJECT.  If CALL_WRITE_METHOD is true, use\n+  // object's writeObject (ObjectOutputStream), otherwise use default\n+  // serialization.  FIELDS are already in canonical order.\n+  private void writeFields (Object obj,\n+\t\t\t    ObjectStreamField[] fields,\n+\t\t\t    boolean call_write_method) throws IOException\n+  {\n+    if (call_write_method)\n+    {\n+      setBlockDataMode (true);\n+      callWriteMethod (obj);\n+      setBlockDataMode (false);\n+      return;\n+    }\n+\n+    String field_name;\n+    Class type;\n+    for (int i=0; i < fields.length; i++)\n+    {\n+      field_name = fields[i].getName ();\n+      type = fields[i].getType ();\n+\n+      if (type == Boolean.TYPE)\n+\trealOutput.writeBoolean (getBooleanField (obj, field_name));\n+      else if (type == Byte.TYPE)\n+\trealOutput.writeByte (getByteField (obj, field_name));\n+      else if (type == Character.TYPE)\n+\trealOutput.writeChar (getCharField (obj, field_name));\n+      else if (type == Double.TYPE)\n+\trealOutput.writeDouble (getDoubleField (obj, field_name));\n+      else if (type == Float.TYPE)\n+\trealOutput.writeFloat (getFloatField (obj, field_name));\n+      else if (type == Integer.TYPE)\n+\trealOutput.writeInt (getIntField (obj, field_name));\n+      else if (type == Long.TYPE)\n+\trealOutput.writeLong (getLongField (obj, field_name));\n+      else if (type == Short.TYPE)\n+\trealOutput.writeShort (getShortField (obj, field_name));\n+      else\n+\twriteObject (getObjectField (obj, field_name,\n+\t\t\t\t     TypeSignature.getEncodingOfClass (type)));\n+    }\n+  }\n+\n+\n+  // Toggles writing primitive data to block-data buffer.\n+  private void setBlockDataMode (boolean on)\n+  {\n+    writeDataAsBlocks = on;\n+\n+    if (on)\n+      dataOutput = blockDataOutput;\n+    else\n+      dataOutput = realOutput;\n+  }\n+\n+\n+  private void callWriteMethod (Object obj) throws IOException\n+  {\n+    try\n+      {\n+\tClass classArgs[] = {Class.forName (\"java.io.ObjectOutputStream\")};\n+\tClass klass = obj.getClass ();\n+\tMethod m = getMethod (klass, \"writeObject\", classArgs);\n+\tif (m == null)\n+\t  return;\n+\tObject args[] = {this};\n+\tm.invoke (obj, args);\t\n+      }\n+    catch (Exception _)\n+      {\n+\tthrow new IOException ();\n+      }\n+  }\n+    \n+  private boolean getBooleanField (Object obj, String field_name) throws IOException\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tboolean b = f.getBoolean (obj);\n+\treturn b;\n+      }\n+    catch (Exception _)\n+      {\n+\tthrow new IOException ();\n+      }    \n+  }\n+\n+  private byte getByteField (Object obj, String field_name) throws IOException\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tbyte b = f.getByte (obj);\n+\treturn b;\n+      }\n+    catch (Exception _)\n+      {\n+\tthrow new IOException ();\n+      }    \n+  }\n+\n+  private char getCharField (Object obj, String field_name) throws IOException\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tchar b = f.getChar (obj);\n+\treturn b;\n+      }\n+    catch (Exception _)\n+      {\n+\tthrow new IOException ();\n+      }    \n+  }\n+\n+  private double getDoubleField (Object obj, String field_name) throws IOException\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tdouble b = f.getDouble (obj);\n+\treturn b;\n+      }\n+    catch (Exception _)\n+      {\n+\tthrow new IOException ();\n+      }    \n+  }\n+\n+  private float getFloatField (Object obj, String field_name) throws IOException\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tfloat b = f.getFloat (obj);\n+\treturn b;\n+      }\n+    catch (Exception _)\n+      {\n+\tthrow new IOException ();\n+      }    \n+  }\n+\n+  private int getIntField (Object obj, String field_name) throws IOException\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tint b = f.getInt (obj);\n+\treturn b;\n+      }\n+    catch (Exception _)\n+      {\n+\tthrow new IOException ();\n+      }    \n+  }\n+\n+  private long getLongField (Object obj, String field_name) throws IOException\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tlong b = f.getLong (obj);\n+\treturn b;\n+      }\n+    catch (Exception _)\n+      {\n+\tthrow new IOException ();\n+      }    \n+  }\n+\n+  private short getShortField (Object obj, String field_name) throws IOException\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tshort b = f.getShort (obj);\n+\treturn b;\n+      }\n+    catch (Exception _)\n+      {\n+\tthrow new IOException ();\n+      }    \n+  }\n+\n+  private Object getObjectField (Object obj, String field_name,\n+\t\t\t\t String type_code) throws IOException\n+  {\n+    try\n+      {\n+\tClass klass = obj.getClass ();\n+\tField f = getField (klass, field_name);\n+\tObject o = f.get (obj);\n+\t// FIXME: We should check the type_code here\n+\treturn o;\n+      }\n+    catch (Exception _)\n+      {\n+\tthrow new IOException ();\n+      }    \n+  }\n+\n+  private static native Field getField (Class klass, String name)\n+    throws java.lang.NoSuchFieldException;\n+\n+  private static native Method getMethod (Class klass, String name, Class args[])\n+    throws java.lang.NoSuchMethodException;\n+\n+  // this value comes from 1.2 spec, but is used in 1.1 as well\n+  private final static int BUFFER_SIZE = 1024;\n+\n+  private static int defaultProtocolVersion = PROTOCOL_VERSION_1;\n+\n+  private DataOutputStream dataOutput;\n+  private boolean writeDataAsBlocks;\n+  private DataOutputStream realOutput;\n+  private DataOutputStream blockDataOutput;\n+  private byte[] blockData;\n+  private int blockDataCount;\n+  private Object currentObject;\n+  private ObjectStreamClass currentObjectStreamClass;\n+  private PutField currentPutField;\n+  private boolean fieldsAlreadyWritten;\n+  private boolean replacementEnabled;\n+  private boolean isSerializing;\n+  private int nextOID;\n+  private Hashtable OIDLookupTable;\n+  private int protocolVersion;\n+  private boolean useSubclassMethod;\n+}"}, {"sha": "f799b4f498e446eaa792611544c82361e1063f86", "filename": "libjava/java/io/ObjectStreamClass.java", "status": "added", "additions": 666, "deletions": 0, "changes": 666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamClass.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,666 @@\n+/* ObjectStreamClass.java -- Class used to write class information\n+   about serialized objects.\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.security.DigestOutputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Hashtable;\n+import java.util.Vector;\n+import gnu.java.io.NullOutputStream;\n+import gnu.java.lang.reflect.TypeSignature;\n+import gnu.gcj.io.SimpleSHSStream;\n+\n+\n+public class ObjectStreamClass implements Serializable\n+{\n+  /**\n+     Returns the <code>ObjectStreamClass</code> for <code>cl</code>.\n+     If <code>cl</code> is null, or is not <code>Serializable</code>,\n+     null is returned.  <code>ObjectStreamClass</code>'s are memoized;\n+     later calls to this method with the same class will return the\n+     same <code>ObjectStreamClass</code> object and no recalculation\n+     will be done.\n+\n+     @see java.io.Serializable\n+  */\n+  public static ObjectStreamClass lookup (Class cl)\n+  {\n+    if (cl == null)\n+      return null;\n+\n+    ObjectStreamClass osc = (ObjectStreamClass)classLookupTable.get (cl);\n+\n+    if (osc != null)\n+      return osc;\n+    else if (! (Serializable.class).isAssignableFrom (cl))\n+      return null;\n+    else\n+    {\n+      osc = new ObjectStreamClass (cl);\n+      classLookupTable.put (cl, osc);\n+      return osc;\n+    }\n+  }\n+\n+\n+  /**\n+     Returns the name of the class that this\n+     <code>ObjectStreamClass</code> represents.\n+  */\n+  public String getName ()\n+  {\n+    return name;\n+  }\n+\n+\n+  /**\n+     Returns the class that this <code>ObjectStreamClass</code>\n+     represents.  Null could be returned if this\n+     <code>ObjectStreamClass</code> was read from an\n+     <code>ObjectInputStream</code> and the class it represents cannot\n+     be found or loaded.\n+\n+     @see java.io.ObjectInputStream\n+  */\n+  public Class forClass ()\n+  {\n+    return clazz;\n+  }\n+\n+\n+  /**\n+     Returns the serial version stream-unique identifier for the class\n+     represented by this <code>ObjectStreamClass</code>.  This SUID is\n+     either defined by the class as <code>static final long\n+     serialVersionUID</code> or is calculated as specified in\n+     Javasoft's \"Object Serialization Specification\" XXX: add reference\n+  */\n+  public long getSerialVersionUID ()\n+  {\n+    return uid;\n+  }\n+\n+\n+  // Returns the serializable (non-static and non-transient) Fields\n+  // of the class represented by this ObjectStreamClass.  The Fields\n+  // are sorted by name.\n+  // XXX doc\n+  public ObjectStreamField[] getFields ()\n+  {\n+    ObjectStreamField[] copy = new ObjectStreamField[ fields.length ];\n+    System.arraycopy (fields, 0, copy, 0, fields.length);\n+    return copy;\n+  }\n+\n+\n+  // XXX doc\n+  // Can't do binary search since fields is sorted by name and\n+  // primitiveness.\n+  public ObjectStreamField getField (String name)\n+  {\n+    for (int i=0; i < fields.length; i++)\n+      if (fields[i].getName ().equals (name))\n+\treturn fields[i];\n+    return null;\n+  }\n+\n+\n+  /**\n+     Returns a textual representation of this\n+     <code>ObjectStreamClass</code> object including the name of the\n+     class it represents as well as that class's serial version\n+     stream-unique identifier.\n+\n+     @see getSerialVersionUID ()\n+     @see getName ()\n+  */\n+  public String toString ()\n+  {\n+    return \"java.io.ObjectStreamClass< \" + name + \", \" + uid + \" >\";\n+  }\n+\n+\n+  // Returns true iff the class that this ObjectStreamClass represents\n+  // has the following method:\n+  //\n+  // private void writeObject (ObjectOutputStream)\n+  //\n+  // This method is used by the class to override default\n+  // serialization behaivior.\n+  boolean hasWriteMethod ()\n+  {\n+    return (flags & ObjectStreamConstants.SC_WRITE_METHOD) != 0;\n+  }\n+\n+\n+  // Returns true iff the class that this ObjectStreamClass represents\n+  // implements Serializable but does *not* implement Externalizable.\n+  boolean isSerializable ()\n+  {\n+    return (flags & ObjectStreamConstants.SC_SERIALIZABLE) != 0;\n+  }\n+\n+\n+  // Returns true iff the class that this ObjectStreamClass represents\n+  // implements Externalizable.\n+  boolean isExternalizable ()\n+  {\n+    return (flags & ObjectStreamConstants.SC_EXTERNALIZABLE) != 0;\n+  }\n+\n+\n+  // Returns the <code>ObjectStreamClass</code> that represents the\n+  // class that is the superclass of the class this\n+  // <code>ObjectStreamClass</cdoe> represents.  If the superclass is\n+  // not Serializable, null is returned.\n+  ObjectStreamClass getSuper ()\n+  {\n+    return superClass;\n+  }\n+\n+\n+  // returns an array of ObjectStreamClasses that represent the super\n+  // classes of CLAZZ and CLAZZ itself in order from most super to\n+  // CLAZZ.  ObjectStreamClass[0] is the highest superclass of CLAZZ\n+  // that is serializable.\n+  static ObjectStreamClass[] getObjectStreamClasses (Class clazz)\n+  {\n+    ObjectStreamClass osc = ObjectStreamClass.lookup (clazz);\n+\n+    ObjectStreamClass[] ret_val;\n+\n+    if (osc == null)\n+      return new ObjectStreamClass[0];\n+    else\n+    {\n+      Vector oscs = new Vector ();\n+\n+      while (osc != null)\n+      {\n+\toscs.addElement (osc);\n+\tosc = osc.getSuper ();\n+      }\n+\n+      int count = oscs.size ();\n+      ObjectStreamClass[] sorted_oscs = new ObjectStreamClass[ count ];\n+\n+      for (int i = count - 1; i >= 0; i--)\n+\tsorted_oscs[ count - i - 1 ] = (ObjectStreamClass)oscs.elementAt (i);\n+\n+      return sorted_oscs;\n+    }\n+  }\n+\n+\n+  // Returns an integer that consists of bit-flags that indicate\n+  // properties of the class represented by this ObjectStreamClass.\n+  // The bit-flags that could be present are those defined in\n+  // ObjectStreamConstants that begin with `SC_'\n+  int getFlags ()\n+  {\n+    return flags;\n+  }\n+\n+\n+  ObjectStreamClass (String name, long uid, byte flags,\n+\t\t     ObjectStreamField[] fields)\n+  {\n+    this.name = name;\n+    this.uid = uid;\n+    this.flags = flags;\n+    this.fields = fields;\n+  }\n+\n+\n+  void setClass (Class clazz)\n+  {\n+    this.clazz = clazz;\n+  }\n+\n+\n+  void setSuperclass (ObjectStreamClass osc)\n+  {\n+    superClass = osc;\n+  }\n+\n+\n+  void calculateOffsets ()\n+  {\n+    int i;\n+    ObjectStreamField field;\n+    primFieldSize = 0;\n+    int fcount = fields.length;\n+    for (i = 0; i < fcount; ++ i)\n+    {\n+      field = fields[i];\n+\n+      if (! field.isPrimitive ())\n+\tbreak;\n+\n+      field.setOffset (primFieldSize);\n+      switch (field.getTypeCode ())\n+      {\n+\tcase 'B':\n+\tcase 'Z':\n+\t  ++ primFieldSize;\n+\t  break;\n+\tcase 'C':\n+\tcase 'S':\n+\t  primFieldSize += 2;\n+\t  break;\n+\tcase 'I':\n+\tcase 'F':\n+\t  primFieldSize += 4;\n+\t  break;\n+\tcase 'D':\n+\tcase 'J':\n+\t  primFieldSize += 8;\n+\t  break;\n+      }\n+    }\n+\n+    for (objectFieldCount = 0; i < fcount; ++ i)\n+      fields[i].setOffset (objectFieldCount++);\n+  }\n+\n+\n+  private ObjectStreamClass (Class cl)\n+  {\n+    uid = 0;\n+    flags = 0;\n+\n+    clazz = cl;\n+    name = cl.getName ();\n+    setFlags (cl);\n+    setFields (cl);\n+    setUID (cl);\n+    superClass = lookup (cl.getSuperclass ());\n+  }\n+\n+\n+  // Sets bits in flags according to features of CL.\n+  private void setFlags (Class cl)\n+  {\n+    if ((java.io.Externalizable.class).isAssignableFrom (cl))\n+      flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;\n+    else if ((java.io.Serializable.class).isAssignableFrom (cl))\n+      // only set this bit if CL is NOT Externalizable\n+      flags |= ObjectStreamConstants.SC_SERIALIZABLE;\n+\n+    try\n+    {\n+      Method writeMethod = cl.getDeclaredMethod (\"writeObject\",\n+\t\t\t\t\t\t writeMethodArgTypes);\n+      int modifiers = writeMethod.getModifiers ();\n+\n+      if (writeMethod.getReturnType () == Void.TYPE\n+\t  && Modifier.isPrivate (modifiers)\n+\t  && !Modifier.isStatic (modifiers))\n+\tflags |= ObjectStreamConstants.SC_WRITE_METHOD;\n+    }\n+    catch (NoSuchMethodException oh_well)\n+    {}\n+  }\n+\n+\n+  // Sets fields to be a sorted array of the serializable fields of\n+  // clazz.\n+  private void setFields (Class cl)\n+  {\n+    if (! isSerializable () || isExternalizable ())\n+    {\n+      fields = NO_FIELDS;\n+      return;\n+    }\n+\n+    try\n+    {\n+      Field serialPersistantFields\n+\t= cl.getDeclaredField (\"serialPersistantFields\");\n+      int modifiers = serialPersistantFields.getModifiers ();\n+\n+      if (Modifier.isStatic (modifiers)\n+\t  && Modifier.isFinal (modifiers)\n+\t  && Modifier.isPrivate (modifiers))\n+      {\n+\tfields = getSerialPersistantFields (cl);\n+\tArrays.sort (fields);\n+\tcalculateOffsets ();\n+\treturn;\n+      }\n+    }\n+    catch (NoSuchFieldException ignore)\n+    {}\n+\n+    int num_good_fields = 0;\n+    Field[] all_fields = cl.getDeclaredFields ();\n+\n+    int modifiers;\n+    // set non-serializable fields to null in all_fields\n+    for (int i=0; i < all_fields.length; i++)\n+    {\n+      modifiers = all_fields[i].getModifiers ();\n+      if (Modifier.isTransient (modifiers)\n+\t  || Modifier.isStatic (modifiers))\n+\tall_fields[i] = null;\n+      else\n+\tnum_good_fields++;\n+    }\n+\n+    // make a copy of serializable (non-null) fields\n+    fields = new ObjectStreamField[ num_good_fields ];\n+    for (int from=0, to=0; from < all_fields.length; from++)\n+      if (all_fields[from] != null)\n+      {\n+\tField f = all_fields[from];\n+\tfields[to] = new ObjectStreamField (f.getName (), f.getType ());\n+\tto++;\n+      }\n+\n+    Arrays.sort (fields);\n+    calculateOffsets ();\n+  }\n+\n+  // Sets uid be serial version UID defined by class, or if that\n+  // isn't present, calculates value of serial version UID.\n+  private void setUID (Class cl)\n+  {\n+    try\n+    {\n+      Field suid = cl.getDeclaredField (\"serialVersionUID\");\n+      int modifiers = suid.getModifiers ();\n+\n+      if (Modifier.isStatic (modifiers)\n+\t  && Modifier.isFinal (modifiers))\n+      {\n+\tuid = getDefinedSUID (cl);\n+\treturn;\n+      }\n+    }\n+    catch (NoSuchFieldException ignore)\n+    {}\n+\n+    // cl didn't define serialVersionUID, so we have to compute it\n+    try\n+    {\n+      MessageDigest md = null;\n+      DigestOutputStream digest_out = null;\n+      DataOutputStream data_out = null;\n+      SimpleSHSStream simple = null;\n+\n+      try \n+\t{\n+\t  md = MessageDigest.getInstance (\"SHA\");\n+\t  digest_out = new DigestOutputStream (nullOutputStream, md);\n+\t  data_out = new DataOutputStream (digest_out);\t  \n+\t}\n+      catch (NoSuchAlgorithmException e)\n+\t{\n+\t  simple = new SimpleSHSStream (nullOutputStream);\n+\t  data_out = new DataOutputStream (simple);\n+\t}\n+\n+      data_out.writeUTF (cl.getName ());\n+\n+      int modifiers = cl.getModifiers ();\n+      // just look at interesting bits\n+      modifiers = modifiers & (Modifier.ABSTRACT | Modifier.FINAL\n+  \t\t\t\t| Modifier.INTERFACE | Modifier.PUBLIC);\n+      data_out.writeInt (modifiers);\n+\n+      Class[] interfaces = cl.getInterfaces ();\n+      Arrays.sort (interfaces, interfaceComparator);\n+      for (int i=0; i < interfaces.length; i++)\n+\tdata_out.writeUTF (interfaces[i].getName ());\n+\n+\n+      Field field;\n+      Field[] fields = cl.getDeclaredFields ();\n+      Arrays.sort (fields, memberComparator);\n+      for (int i=0; i < fields.length; i++)\n+      {\n+\tfield = fields[i];\n+\tmodifiers = field.getModifiers ();\n+\tif (Modifier.isPrivate (modifiers)\n+\t    && (Modifier.isStatic (modifiers)\n+\t\t || Modifier.isTransient (modifiers)))\n+\t  continue;\n+\n+\tdata_out.writeUTF (field.getName ());\n+\tdata_out.writeInt (modifiers);\n+\tdata_out.writeUTF (TypeSignature.getEncodingOfClass (field.getType ()));\n+      }\n+\n+      // write class initializer method if present\n+      boolean has_init;\n+      try\n+      {\n+\thas_init = hasClassInitializer (cl);\n+      }\n+      catch (NoSuchMethodError e)\n+      {\n+\thas_init = false;\n+      }\n+\n+      if (has_init)\n+      {\n+\tdata_out.writeUTF (\"<clinit>\");\n+\tdata_out.writeInt (Modifier.STATIC);\n+\tdata_out.writeUTF (\"()V\");\n+      }\n+\n+      Constructor constructor;\n+      Constructor[] constructors = cl.getDeclaredConstructors ();\n+      Arrays.sort (constructors, memberComparator);\n+      for (int i=0; i < constructors.length; i++)\n+      {\n+\tconstructor = constructors[i];\n+\tmodifiers = constructor.getModifiers ();\n+\tif (Modifier.isPrivate (modifiers))\n+\t  continue;\n+\n+\tdata_out.writeUTF (\"<init>\");\n+\tdata_out.writeInt (modifiers);\n+\n+\t// the replacement of '/' with '.' was needed to make computed\n+\t// SUID's agree with those computed by JDK\n+\tdata_out.writeUTF (\n+\t  TypeSignature.getEncodingOfConstructor (constructor).replace ('/','.'));\n+      }\n+\n+      Method method;\n+      Method[] methods = cl.getDeclaredMethods ();\n+      Arrays.sort (methods, memberComparator);\n+      for (int i=0; i < methods.length; i++)\n+      {\n+\tmethod = methods[i];\n+\tmodifiers = method.getModifiers ();\n+\tif (Modifier.isPrivate (modifiers))\n+\t  continue;\n+\n+\tdata_out.writeUTF (method.getName ());\n+\tdata_out.writeInt (modifiers);\n+\n+\t// the replacement of '/' with '.' was needed to make computed\n+\t// SUID's agree with those computed by JDK\n+\tdata_out.writeUTF (\n+\t  TypeSignature.getEncodingOfMethod (method).replace ('/', '.'));\n+      }\n+\n+      data_out.close ();\n+      byte[] sha = md != null ? md.digest () : simple.digest ();\n+      long result = 0;\n+      int len = sha.length < 8 ? sha.length : 8;\n+      for (int i=0; i < len; i++)\n+\tresult += (long)(sha[i] & 0xFF) << (8 * i);\n+\n+      uid = result;\n+    }\n+    catch (NoSuchAlgorithmException e)\n+    {\n+      throw new RuntimeException (\"The SHA algorithm was not found to use in computing the Serial Version UID for class \"\n+\t\t\t\t  + cl.getName ());\n+    }\n+    catch (IOException ioe)\n+    {\n+      throw new RuntimeException (ioe.getMessage ());\n+    }\n+  }\n+\n+\n+  // Returns the value of CLAZZ's final static long field named\n+  // `serialVersionUID'.\n+  private long getDefinedSUID (Class clazz)\n+  {\n+    long l = 0;\n+    try\n+      {\n+\t// Use getDeclaredField rather than getField, since serialVersionUID\n+\t// may not be public AND we only want the serialVersionUID of this\n+\t// class, not a superclass or interface.\n+\tField f = clazz.getDeclaredField (\"serialVersionUID\");\n+\tl = f.getLong (null);\n+      }\n+    catch (java.lang.NoSuchFieldException e)\n+      {\n+      }\n+\n+    catch (java.lang.IllegalAccessException e)\n+      {\n+      }\n+\n+    return l;\n+  }\n+\n+  // Returns the value of CLAZZ's private static final field named\n+  // `serialPersistantFields'.\n+  private ObjectStreamField[] getSerialPersistantFields (Class clazz)\n+  {\n+    ObjectStreamField[] o = null;\n+    try\n+      {\n+\t// Use getDeclaredField rather than getField for the same reason\n+\t// as above in getDefinedSUID.\n+\tField f = clazz.getDeclaredField (\"getSerialPersistantFields\");\n+\to = (ObjectStreamField[])f.get (null);\n+      }\n+    catch (java.lang.NoSuchFieldException e)\n+      {\n+      }\n+    catch (java.lang.IllegalAccessException e)\n+      {\n+      }\n+\n+    return o;\n+  }\n+\n+\n+  // Returns true if CLAZZ has a static class initializer\n+  // (a.k.a. <clinit>).\n+  //\n+  // A NoSuchMethodError is raised if CLAZZ has no such method.\n+  private static boolean hasClassInitializer (Class clazz)\n+    throws java.lang.NoSuchMethodError\n+  {\n+    Method m = null;\n+\n+    try\n+      {\n+\tClass classArgs[] = {};\n+\tm = clazz.getMethod (\"<clinit>\", classArgs);\n+      }\n+    catch (java.lang.NoSuchMethodException e)\n+      {\n+\tthrow new java.lang.NoSuchMethodError ();\n+      }\n+\n+    return m != null;\n+  }\n+\n+  public static final ObjectStreamField[] NO_FIELDS = {};\n+\n+  private static Hashtable classLookupTable = new Hashtable ();\n+  private static final NullOutputStream nullOutputStream = new NullOutputStream ();\n+  private static final Comparator interfaceComparator = new InterfaceComparator ();\n+  private static final Comparator memberComparator = new MemberComparator ();\n+  private static final\n+    Class[] writeMethodArgTypes = { java.io.ObjectOutputStream.class };\n+\n+  private ObjectStreamClass superClass;\n+  private Class clazz;\n+  private String name;\n+  private long uid;\n+  private byte flags;\n+\n+  // this field is package protected so that ObjectInputStream and\n+  // ObjectOutputStream can access it directly\n+  ObjectStreamField[] fields;\n+\n+  // these are accessed by ObjectIn/OutputStream\n+  int primFieldSize = -1;  // -1 if not yet calculated\n+  int objectFieldCount;\n+}\n+\n+\n+// interfaces are compared only by name\n+class InterfaceComparator implements Comparator\n+{\n+  public int compare (Object o1, Object o2)\n+  {\n+    return ((Class)o1).getName ().compareTo (((Class)o2).getName ());\n+  }\n+}\n+\n+\n+// Members (Methods and Constructors) are compared first by name,\n+// conflicts are resolved by comparing type signatures\n+class MemberComparator implements Comparator\n+{\n+  public int compare (Object o1, Object o2)\n+  {\n+    Member m1 = (Member)o1;\n+    Member m2 = (Member)o2;\n+\n+    int comp = m1.getName ().compareTo (m2.getName ());\n+\n+    if (comp == 0)\n+      return TypeSignature.getEncodingOfMember (m1).\n+\tcompareTo (TypeSignature.getEncodingOfMember (m2));\n+    else\n+      return comp;\n+  }\n+}"}, {"sha": "c9a2aea4f2a42e3c0f07ee3f7aff286b4c55346e", "filename": "libjava/java/io/ObjectStreamConstants.java", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectStreamConstants.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectStreamConstants.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamConstants.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,74 @@\n+/* ObjectStreamConstants.java -- Interface containing constant values\n+   used in reading and writing serialized objects\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+/**\n+   This interface contains constants that are used in object\n+   serialization.  This interface is used by ObjectOutputStream,\n+   ObjectInputStream, ObjectStreamClass, and possibly other classes.\n+   The values for these constants are specified in Javasoft's \"Object\n+   Serialization Specification\" TODO: add reference\n+*/\n+public interface ObjectStreamConstants\n+{\n+  public final static int PROTOCOL_VERSION_1 = 1;\n+  public final static int PROTOCOL_VERSION_2 = 2;\n+\n+  final static short STREAM_MAGIC = (short)0xaced;\n+  final static short STREAM_VERSION = 5;\n+\n+  final static byte TC_NULL = (byte)112;\n+  final static byte TC_REFERENCE = (byte)113;\n+  final static byte TC_CLASSDESC = (byte)114;\n+  final static byte TC_OBJECT = (byte)115;\n+  final static byte TC_STRING = (byte)116;\n+  final static byte TC_ARRAY = (byte)117;\n+  final static byte TC_CLASS = (byte)118;\n+  final static byte TC_BLOCKDATA = (byte)119;\n+  final static byte TC_ENDBLOCKDATA = (byte)120;\n+  final static byte TC_RESET = (byte)121;\n+  final static byte TC_BLOCKDATALONG = (byte)122;\n+  final static byte TC_EXCEPTION = (byte)123;\n+\n+  final static byte TC_BASE = TC_NULL;\n+  final static byte TC_MAX = TC_EXCEPTION;\n+\n+  final static int baseWireHandle = 0x7e0000;\n+\n+  final static byte SC_WRITE_METHOD = 0x01;\n+  final static byte SC_SERIALIZABLE = 0x02;\n+  final static byte SC_EXTERNALIZABLE = 0x04;\n+  final static byte SC_BLOCK_DATA = 0x08;\n+\n+  final static SerializablePermission SUBSTITUTION_PERMISSION\n+    = new SerializablePermission(\"enableSubstitution\");\n+\n+  final static SerializablePermission SUBCLASS_IMPLEMENTATION_PERMISSION\n+    = new SerializablePermission(\"enableSubclassImplementation\");\n+}"}, {"sha": "55181cc7a38f3c27c0229aaaa0214a9f2012250e", "filename": "libjava/java/io/ObjectStreamField.java", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectStreamField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FObjectStreamField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamField.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,99 @@\n+/* ObjectStreamField.java -- Class used to store name and class of fields\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+import gnu.java.lang.reflect.TypeSignature;\n+\n+// XXX doc\n+public class ObjectStreamField implements java.lang.Comparable\n+{\n+  public ObjectStreamField (String name, Class type)\n+  {\n+    this.name = name;\n+    this.type = type;\n+  }\n+\n+  public String getName ()\n+  {\n+    return name;\n+  }\n+\n+  public Class getType ()\n+  {\n+    return type;\n+  }\n+\n+  public char getTypeCode ()\n+  {\n+    return TypeSignature.getEncodingOfClass (type).charAt (0);\n+  }\n+\n+  public String getTypeString ()\n+  {\n+    return TypeSignature.getEncodingOfClass (type);\n+  }\n+\n+  public int getOffset ()\n+  {\n+    return offset;\n+  }\n+\n+  protected void setOffset (int off)\n+  {\n+    offset = off;\n+  }\n+\n+  public boolean isPrimitive ()\n+  {\n+    return type.isPrimitive ();\n+  }\n+\n+  public int compareTo (Object o)\n+  {\n+    ObjectStreamField f = (ObjectStreamField)o;\n+    boolean this_is_primitive = isPrimitive ();\n+    boolean f_is_primitive = f.isPrimitive ();\n+\n+    if (this_is_primitive && !f_is_primitive)\n+      return -1;\n+\n+    if (!this_is_primitive && f_is_primitive)\n+      return 1;\n+\n+    return getName ().compareTo (f.getName ());\n+  }\n+\n+  public String toString ()\n+  {\n+    return \"ObjectStreamField< \" + type + \" \" + name + \" >\";\n+  }\n+\n+  private String name;\n+  private Class type;\n+  private int offset = -1; // XXX make sure this is correct\n+}"}, {"sha": "1035ab51c0c60fbf93a46815e335fac793b637e4", "filename": "libjava/java/io/Replaceable.java", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FReplaceable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FReplaceable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FReplaceable.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,54 @@\n+/* Replaceable.java -- Replace an object with another object\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+/**\n+  * This interface is used to indicate that an object may want to have\n+  * another object serialized instead of itself.  It contains one method\n+  * that is to be called when an object is to be serialized.  That method\n+  * is reponsible for returning the real object that should be serialized\n+  * instead of object being queried.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public interface Replaceable extends Serializable\n+{\n+\n+/**\n+  * This method returns the object that should be serialized instead of\n+  * this object\n+  *\n+  * @return The real object that should be serialized\n+  */\n+public abstract Object\n+writeReplace();\n+\n+} // interface Replaceable\n+"}, {"sha": "b7250de60d1f398afd7bf487f44ded0e3f988f7d", "filename": "libjava/java/io/Resolvable.java", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FResolvable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FResolvable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FResolvable.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,52 @@\n+/* Resolvable.java -- Returns an object to replace the one being de-serialized\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+/**\n+  * This interface is implemented when an object wishes to return another\n+  * object to replace it during de-serialization.  It has one method that\n+  * returns the object that should be used to replace the original object.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public interface Resolvable extends Serializable\n+{\n+\n+/**\n+  * This method returns the object that should be used to replace the \n+  * original object during de-serialization.\n+  *\n+  * @return The replacement object\n+  */\n+public abstract Object\n+readResolve();\n+\n+} // interface Resolvable\n+"}, {"sha": "78c7229098f7e966820ae3d4f1f78a78873da29c", "filename": "libjava/java/io/SerializablePermission.java", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FSerializablePermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FSerializablePermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FSerializablePermission.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,106 @@\n+/* SerializablePermission.java -- Basic permissions related to serialization.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+import java.security.BasicPermission;\n+\n+/**\n+  * This class models permissions related to serialization.  As a subclass\n+  * of <code>BasicPermission</code>, this class has permissions that have\n+  * a name only.  There is no associated action list.\n+  * <p>\n+  * There are currently two allowable permission names for this class:\n+  * <ul>\n+  * <li><code>enableSubclassImplementation</code> - Allows a subclass to\n+  * override the default serialization behavior of objects.\n+  * <li><code>enableSubstitution</code> - Allows substitution of one object\n+  * for another during serialization or deserialization.\n+  * </ul>\n+  *\n+  * @see java.security.BasicPermission\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public final class SerializablePermission extends BasicPermission\n+{\n+\n+/*\n+ * Class Variables\n+ */\n+\n+public static final String[] legal_names = { \"enableSubclassImplementation\",\n+                                             \"enableSubstitution\" };\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * This method initializes a new instance of <code>SerializablePermission</code>\n+  * that has the specified name.\n+  *\n+  * @param name The name of the permission.\n+  *\n+  * @exception IllegalArgumentException If the name is not valid for this class.\n+  */\n+public\n+SerializablePermission(String name)\n+{\n+  this(name, null);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method initializes a new instance of <code>SerializablePermission</code>\n+  * that has the specified name and action list.  Note that the action list\n+  * is unused in this class.\n+  *\n+  * @param name The name of the permission.\n+  * @param actions The action list (unused).\n+  *\n+  * @exception IllegalArgumentException If the name is not valid for this class.\n+  */\n+public\n+SerializablePermission(String name, String actions)\n+{\n+  super(name, actions);\n+\n+  for (int i = 0; i < legal_names.length; i++)\n+    if (legal_names[i].equals(name))\n+      return;\n+\n+  throw new IllegalArgumentException(\"Bad permission name:  \" + name);\n+}\n+\n+\n+} // class SerializablePermission\n+"}, {"sha": "1f225148b90f06d4fd016b906b5d086e057e5e0d", "filename": "libjava/java/io/WriteAbortedException.java", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FWriteAbortedException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FWriteAbortedException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FWriteAbortedException.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,89 @@\n+/* WriteAbortedException.java -- An exception occured while writing a \n+   serialization stream\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.io;\n+\n+/**\n+  * This exception is thrown when one of the other ObjectStreamException \n+  * subclasses was thrown during a serialization write.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class WriteAbortedException extends ObjectStreamException\n+{\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * The detailed exception that caused this exception to be thrown\n+  */\n+public Exception detail;\n+private String message;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Create a new WriteAbortedException with an eof parameter indicating\n+  * the detailed Exception that caused this exception to be thrown.\n+  *\n+  * @param detail The exception that caused this exception to be thrown\n+  */\n+public\n+WriteAbortedException(String msg, Exception detail)\n+{\n+  this.message = msg;\n+  this.detail = detail;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * This method returns a message indicating what went wrong, including \n+  * the message text from the initial exception that caused this one to\n+  * be thrown\n+  */\n+public String\n+getMessage()\n+{\n+  return(message + \": \" + detail.getMessage());\n+}\n+\n+} // class WriteAbortedException\n+"}, {"sha": "b7a8dcbc338ffaaac727fa77b1f2750c15616445", "filename": "libjava/java/io/natObjectInputStream.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,78 @@\n+// natObjectInputStream.cc - Native part of ObjectInputStream class.\n+\n+/* Copyright (C) 1998, 1999  Free Software Foundation\n+\n+   This ObjectInputStream is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the ObjectInputStream \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+\n+#include <java/io/ObjectInputStream$GetField.h>\n+#include <java/io/ObjectInputStream.h>\n+#include <java/io/IOException.h>\n+#include <java/lang/Class.h>\n+#include <java/lang/reflect/Modifier.h>\n+#include <java/lang/reflect/Method.h>\n+\n+jobject\n+java::io::ObjectInputStream::allocateObject (jclass klass)\n+{\n+  jobject obj = NULL;\n+  using namespace java::lang::reflect;\n+\n+  try\n+    {\n+      JvAssert (klass && ! klass->isArray ());\n+      if (klass->isInterface() || Modifier::isAbstract(klass->getModifiers()))\n+\tobj = NULL;\t\n+      else\n+\t{\n+\t  // FIXME: will this work for String?\n+\t  obj = JvAllocObject (klass);\n+\t}\n+    }\n+  catch (jthrowable t)\n+    {\n+      return NULL;\n+    }\n+\n+  return obj;\n+}\n+\n+\n+#define ObjectClass _CL_Q34java4lang6Object\n+extern java::lang::Class ObjectClass;\n+#define ClassClass _CL_Q34java4lang5Class\n+extern java::lang::Class ClassClass;\n+\n+void \n+java::io::ObjectInputStream::callConstructor (jclass klass, jobject obj)\n+{ \n+  jstring init_name = JvNewStringLatin1 (\"<init>\");\n+  JArray<jclass> *arg_types\n+    = (JArray<jclass> *) JvNewObjectArray (0, &ClassClass, NULL);\n+  JArray<jobject> *args\n+    = (JArray<jobject> *) JvNewObjectArray (0, &ObjectClass, NULL);\n+  java::lang::reflect::Method *m = klass->getPrivateMethod (init_name, arg_types);\n+  m->invoke (obj, args);\n+}\n+  \n+java::lang::reflect::Field *\n+java::io::ObjectInputStream::getField (jclass klass, jstring name)\n+{\n+  return klass->getPrivateField (name);\n+}\n+\n+java::lang::reflect::Method *\n+java::io::ObjectInputStream::getMethod (jclass klass, jstring name, \n+\t\t\t\t\tJArray<jclass> *arg_types)\n+{\n+  return klass->getPrivateMethod (name, arg_types);\n+}\n+"}, {"sha": "45ab7537fc35c5798f08f71a26c975ac8f1a3152", "filename": "libjava/java/io/natObjectOutputStream.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FnatObjectOutputStream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fio%2FnatObjectOutputStream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatObjectOutputStream.cc?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,33 @@\n+// natObjectOutputStream.cc - Native part of ObjectOutputStream class.\n+\n+/* Copyright (C) 1998, 1999  Free Software Foundation\n+\n+   This ObjectOutputStream is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the ObjectOutputStream \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java/io/ObjectOutputStream$PutField.h>\n+#include <java/io/ObjectOutputStream.h>\n+#include <java/io/IOException.h>\n+#include <java/lang/Class.h>\n+\n+\n+java::lang::reflect::Field *\n+java::io::ObjectOutputStream::getField (jclass klass, jstring name)\n+{\n+  return klass->getPrivateField (name);\n+}\n+\n+java::lang::reflect::Method *\n+java::io::ObjectOutputStream::getMethod (jclass klass, jstring name, \n+\t\t\t\t\t JArray<jclass> *arg_types)\n+{\n+  return klass->getPrivateMethod (name, arg_types);\n+}\n+"}, {"sha": "03fa439b0b7756baee341710509fec73cbb94d31", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -130,6 +130,9 @@ class java::lang::Class : public java::lang::Object\n   java::lang::reflect::Field *getField (jstring, jint);\n   jint _getMethods (JArray<java::lang::reflect::Method *> *result,\n \t\t    jint offset);\n+  java::lang::reflect::Field *getPrivateField (jstring);\n+  java::lang::reflect::Method *getPrivateMethod (jstring, JArray<jclass> *);\n+\n public:\n   JArray<java::lang::reflect::Field *> *getFields (void);\n \n@@ -234,6 +237,10 @@ class java::lang::Class : public java::lang::Object\n   // Friends classes and functions to implement the ClassLoader\n   friend class java::lang::ClassLoader;\n \n+  friend class java::io::ObjectOutputStream;\n+  friend class java::io::ObjectInputStream;\n+  friend class java::io::ObjectStreamClass;\n+\n   friend void _Jv_WaitForState (jclass, int);\n   friend void _Jv_RegisterClasses (jclass *classes);\n   friend void _Jv_RegisterInitiatingLoader (jclass,java::lang::ClassLoader*);"}, {"sha": "9c14552b9c9e7c405fdd1236800ee265168c40cc", "filename": "libjava/java/lang/SecurityManager.java", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FSecurityManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FSecurityManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FSecurityManager.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -110,6 +110,11 @@ public void checkPackageDefinition (String pkg)\n       throw new SecurityException();\n     }\n \n+  public void checkPermission (java.security.Permission perm)\n+    {\n+      throw new SecurityException();\n+    }\n+\n   public void checkPrintJobAccess ()\n     {\n       throw new SecurityException();"}, {"sha": "12f8789f04b065db7374130fc4f2cfd081f0495b", "filename": "libjava/java/lang/String.java", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -8,6 +8,8 @@\n \n package java.lang;\n import java.io.UnsupportedEncodingException;\n+import java.io.Serializable;\n+import java.lang.Comparable;\n \n /**\n  * @author Per Bothner <bothner@cygnus.com>\n@@ -18,7 +20,7 @@\n  * Status:  Complete to 1.1, but see FIXMEs. Also see testsuite results.\n  */\n \n-public final class String\n+public final class String implements Serializable, Comparable\n {\n   private Object data;\n   private int boffset; // Note this is a byte offset - don't use in Java code!\n@@ -172,6 +174,11 @@ public native void getBytes (int srcBegin, int srcEnd,\n \n   public native int compareTo (String anotherString);\n \n+  public int compareTo (Object obj)\n+  {\n+    return compareTo ((String)obj);\n+  }\n+\n   public native boolean regionMatches (int toffset,\n \t\t\t\t       String other, int ooffset, int len);\n "}, {"sha": "6e00fa7eba0c335735e1475391368f653c834cb7", "filename": "libjava/java/lang/StringBuffer.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FStringBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FStringBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringBuffer.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -1,6 +1,6 @@\n // StringBuffer.java - Growable strings.\n \n-/* Copyright (C) 1998, 1999, 2000  Red Hat\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n "}, {"sha": "dfc3840a6a036897522cddfdb40c54ae11d357d7", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -918,11 +918,27 @@ _Jv_IsAssignableFrom (jclass target, jclass source)\n       return _Jv_IsAssignableFrom(target->getComponentType(), \n                                   source->getComponentType());\n     }\n-        \n+\n   if (target->isInterface())\n     {\n+      // Abstract classes have no IDTs, so compare superclasses instead.\n+      if (java::lang::reflect::Modifier::isAbstract (source->accflags))\n+\t{\n+\t  jclass super = source->getSuperclass();\n+\t  return super ? _Jv_IsAssignableFrom (target, super) : false;\n+\t}\n+\n+      if (source->state != JV_STATE_DONE)\n+\tsource->initializeClass ();\n+      if (target->state != JV_STATE_DONE)\n+\ttarget->initializeClass ();\n+\n       _Jv_IDispatchTable *cl_idt = source->idt;\n       _Jv_IDispatchTable *if_idt = target->idt;\n+\n+      if (if_idt == NULL) // The interface has no implementations\n+\treturn false;\n+\n       if (__builtin_expect ((if_idt == NULL), false))\n \treturn false; // No class implementing TARGET has been loaded.    \n       jshort cl_iindex = cl_idt->cls.iindex;\n@@ -1305,3 +1321,61 @@ _Jv_FindIIndex (jclass *ifaces, jshort *offsets, jshort num)\n \n   return i;\n }\n+\n+// Only used by serialization\n+java::lang::reflect::Field *\n+java::lang::Class::getPrivateField (jstring name)\n+{\n+  int hash = name->hashCode ();\n+\n+  java::lang::reflect::Field* rfield;\n+  for (int i = 0;  i < field_count;  i++)\n+    {\n+      _Jv_Field *field = &fields[i];\n+      if (! _Jv_equal (field->name, name, hash))\n+\tcontinue;\n+      rfield = new java::lang::reflect::Field ();\n+      rfield->offset = (char*) field - (char*) fields;\n+      rfield->declaringClass = this;\n+      rfield->name = name;\n+      return rfield;\n+    }\n+  jclass superclass = getSuperclass();\n+  if (superclass == NULL)\n+    return NULL;\n+  rfield = superclass->getPrivateField(name);\n+  for (int i = 0; i < interface_count && rfield == NULL; ++i)\n+    rfield = interfaces[i]->getPrivateField (name);\n+  return rfield;\n+}\n+\n+// Only used by serialization\n+java::lang::reflect::Method *\n+java::lang::Class::getPrivateMethod (jstring name, JArray<jclass> *param_types)\n+{\n+  jstring partial_sig = getSignature (param_types, false);\n+  jint p_len = partial_sig->length();\n+  _Jv_Utf8Const *utf_name = _Jv_makeUtf8Const (name);\n+  for (Class *klass = this; klass; klass = klass->getSuperclass())\n+    {\n+      int i = klass->isPrimitive () ? 0 : klass->method_count;\n+      while (--i >= 0)\n+\t{\n+\t  // FIXME: access checks.\n+\t  if (_Jv_equalUtf8Consts (klass->methods[i].name, utf_name)\n+\t      && _Jv_equaln (klass->methods[i].signature, partial_sig, p_len))\n+\t    {\n+\t      // Found it.\n+\t      using namespace java::lang::reflect;\n+\n+\t      Method *rmethod = new Method ();\n+\t      rmethod->offset = ((char *) (&klass->methods[i])\n+\t\t\t\t - (char *) klass->methods);\n+\t      rmethod->declaringClass = klass;\n+\t      return rmethod;\n+\t    }\n+\t}\n+    }\n+  JvThrow (new java::lang::NoSuchMethodException);\n+}\n+"}, {"sha": "aa8782ddf0dfb2b546d4633ad3571c271d3f2a87", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -46,7 +46,8 @@ extern java::lang::Class ClassClass;\n extern java::lang::Class VMClassLoader;\n #define ClassLoaderClass _CL_Q34java4lang11ClassLoader\n extern java::lang::Class ClassLoaderClass;\n-\n+#define SerializableClass _CL_Q34java2io12Serializable\n+extern java::lang::Class SerializableClass;\n /////////// java.lang.ClassLoader native methods ////////////\n \n java::lang::ClassLoader *\n@@ -579,10 +580,9 @@ _Jv_FindArrayClass (jclass element, java::lang::ClassLoader *loader)\n       array_class->methods = (_Jv_Method *) element;\n \n       // Register our interfaces.\n-      // FIXME: for JDK 1.2 we need Serializable.\n-      static jclass interfaces[] = { &CloneableClass };\n+      static jclass interfaces[] = { &CloneableClass, &SerializableClass };\n       array_class->interfaces = interfaces;\n-      array_class->interface_count = 1;\n+      array_class->interface_count = sizeof interfaces / sizeof interfaces[0];\n \n       // Generate the interface dispatch table.\n       _Jv_PrepareConstantTimeTables (array_class);"}, {"sha": "5a28c1eee64ba2b5a69c158246c247b722a53d3e", "filename": "libjava/java/lang/natString.cc", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FnatString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FnatString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatString.cc?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -46,12 +46,12 @@ _Jv_StringFindSlot (jchar* data, jint len, jint hash)\n   int start_index = hash & (strhash_size - 1);\n   int deleted_index = -1;\n \n-  register int index = start_index;\n+  int index = start_index;\n   /* step must be non-zero, and relatively prime with strhash_size. */\n   int step = 8 * hash + 7;\n   for (;;)\n     {\n-      register jstring* ptr = &strhash[index];\n+      jstring* ptr = &strhash[index];\n       if (*ptr == NULL)\n \t{\n \t  if (deleted_index >= 0)\n@@ -75,7 +75,7 @@ _Jv_StringFindSlot (jchar* data, jint len, jint hash)\n static jint\n hashChars (jchar* ptr, jint length)\n {\n-  register jchar* limit = ptr + length;\n+  jchar* limit = ptr + length;\n   jint hash = 0;\n   // Updated specification from\n   // http://www.javasoft.com/docs/books/jls/clarify.html.\n@@ -111,8 +111,8 @@ java::lang::String::rehash()\n     }\n   else\n     {\n-      register int i = strhash_size;\n-      register jstring* ptr = strhash + i;\n+      int i = strhash_size;\n+      jstring* ptr = strhash + i;\n       strhash_size *= 2;\n       strhash = (jstring *) _Jv_AllocBytes (strhash_size * sizeof (jstring));\n       memset (strhash, 0, strhash_size * sizeof (jstring));\n@@ -198,8 +198,8 @@ _Jv_NewStringUtf8Const (Utf8Const* str)\n   jchar *chrs;\n   jchar buffer[100];\n   jstring jstr;\n-  register unsigned char* data = (unsigned char*) str->data;\n-  register unsigned char* limit = data + str->length;\n+  unsigned char* data = (unsigned char*) str->data;\n+  unsigned char* limit = data + str->length;\n   int length = _Jv_strLengthUtf8(str->data, str->length);\n \n   if (length <= (int) (sizeof(buffer) / sizeof(jchar)))\n@@ -239,12 +239,12 @@ _Jv_NewStringUtf8Const (Utf8Const* str)\n jsize\n _Jv_GetStringUTFLength (jstring string)\n {\n-  register jsize len = 0;\n-  register jchar *ptr = JvGetStringChars (string);\n-  register jsize i = string->length();\n+  jsize len = 0;\n+  jchar *ptr = JvGetStringChars (string);\n+  jsize i = string->length();\n   while (--i >= 0)\n     {\n-      register jchar ch = *ptr++;\n+      jchar ch = *ptr++;\n       if (ch > 0 && ch <= 0x7F)\n \tlen += 1;\n       else if (ch <= 0x7FF)\n@@ -260,9 +260,9 @@ _Jv_GetStringUTFLength (jstring string)\n jsize\n _Jv_GetStringUTFRegion (jstring str, jsize start, jsize len, char *buf)\n {\n-  register jchar *sptr = JvGetStringChars (str) + start;\n-  register jsize i = len;\n-  register char *dptr = buf;\n+  jchar *sptr = JvGetStringChars (str) + start;\n+  jsize i = len;\n+  char *dptr = buf;\n   while (--i >= 0)\n     {\n       jchar ch = *sptr++;\n@@ -429,9 +429,9 @@ java::lang::String::equals(jobject anObject)\n   if (count != other->count)\n     return false;\n   /* if both are interned, return false. */\n-  register jint i = count;\n-  register jchar *xptr = JvGetStringChars (this);\n-  register jchar *yptr = JvGetStringChars (other);\n+  jint i = count;\n+  jchar *xptr = JvGetStringChars (this);\n+  jchar *yptr = JvGetStringChars (other);\n   while (--i >= 0)\n     {\n       if (*xptr++ != *yptr++)\n@@ -456,9 +456,9 @@ java::lang::String::getChars(jint srcBegin, jint srcEnd,\n   if (srcBegin < 0 || srcBegin > srcEnd || srcEnd > count\n       || dstBegin < 0 || dstBegin + (srcEnd-srcBegin) > dst_length)\n     JvThrow (new java::lang::StringIndexOutOfBoundsException());\n-  register jchar *dPtr = elements (dst) + dstBegin;\n-  register jchar *sPtr = JvGetStringChars (this) + srcBegin;\n-  register jint i = srcEnd-srcBegin;\n+  jchar *dPtr = elements (dst) + dstBegin;\n+  jchar *sPtr = JvGetStringChars (this) + srcBegin;\n+  jint i = srcEnd-srcBegin;\n   while (--i >= 0)\n     *dPtr++ = *sPtr++;\n }\n@@ -506,9 +506,9 @@ java::lang::String::getBytes(jint srcBegin, jint srcEnd,\n   if (srcBegin < 0 || srcBegin > srcEnd || srcEnd > count\n       || dstBegin < 0 || dstBegin + (srcEnd-srcBegin) > dst_length)\n     JvThrow (new java::lang::StringIndexOutOfBoundsException());\n-  register jbyte *dPtr = elements (dst) + dstBegin;\n-  register jchar *sPtr = JvGetStringChars (this) + srcBegin;\n-  register jint i = srcEnd-srcBegin;\n+  jbyte *dPtr = elements (dst) + dstBegin;\n+  jchar *sPtr = JvGetStringChars (this) + srcBegin;\n+  jint i = srcEnd-srcBegin;\n   while (--i >= 0)\n     *dPtr++ = (jbyte) *sPtr++;\n }\n@@ -517,9 +517,9 @@ jcharArray\n java::lang::String::toCharArray()\n {\n   jcharArray array = JvNewCharArray(count);\n-  register jchar *dPtr = elements (array);\n-  register jchar *sPtr = JvGetStringChars (this);\n-  register jint i = count;\n+  jchar *dPtr = elements (array);\n+  jchar *sPtr = JvGetStringChars (this);\n+  jint i = count;\n   while (--i >= 0)\n     *dPtr++ = *sPtr++;\n   return array;\n@@ -530,9 +530,9 @@ java::lang::String::equalsIgnoreCase (jstring anotherString)\n {\n   if (anotherString == NULL || count != anotherString->count)\n     return false;\n-  register jchar *tptr = JvGetStringChars (this);\n-  register jchar *optr = JvGetStringChars (anotherString);\n-  register jint i = count;\n+  jchar *tptr = JvGetStringChars (this);\n+  jchar *optr = JvGetStringChars (anotherString);\n+  jint i = count;\n   while (--i >= 0)\n     {\n       jchar tch = *tptr++;\n@@ -555,9 +555,9 @@ java::lang::String::regionMatches (jint toffset,\n       || toffset + len > count\n       || ooffset + len > other->count)\n     return false;\n-  register jchar *tptr = JvGetStringChars (this) + toffset;\n-  register jchar *optr = JvGetStringChars (other) + ooffset;\n-  register jint i = len;\n+  jchar *tptr = JvGetStringChars (this) + toffset;\n+  jchar *optr = JvGetStringChars (other) + ooffset;\n+  jint i = len;\n   while (--i >= 0)\n     {\n       if (*tptr++ != *optr++)\n@@ -569,11 +569,11 @@ java::lang::String::regionMatches (jint toffset,\n jint\n java::lang::String::compareTo (jstring anotherString)\n {\n-  register jchar *tptr = JvGetStringChars (this);\n-  register jchar *optr = JvGetStringChars (anotherString);\n+  jchar *tptr = JvGetStringChars (this);\n+  jchar *optr = JvGetStringChars (anotherString);\n   jint tlen = this->count;\n   jint olen = anotherString->count;\n-  register jint i = tlen > olen ? olen : tlen;\n+  jint i = tlen > olen ? olen : tlen;\n   while (--i >= 0)\n     {\n       jchar tch = *tptr++;\n@@ -592,9 +592,9 @@ java::lang::String::regionMatches (jboolean ignoreCase, jint toffset,\n       || toffset + len > count\n       || ooffset + len > other->count)\n     return false;\n-  register jchar *tptr = JvGetStringChars (this) + toffset;\n-  register jchar *optr = JvGetStringChars (other) + ooffset;\n-  register jint i = len;\n+  jchar *tptr = JvGetStringChars (this) + toffset;\n+  jchar *optr = JvGetStringChars (other) + ooffset;\n+  jint i = len;\n   if (ignoreCase)\n     while (--i >= 0)\n       {\n@@ -620,11 +620,11 @@ java::lang::String::regionMatches (jboolean ignoreCase, jint toffset,\n jboolean\n java::lang::String::startsWith (jstring prefix, jint toffset)\n {\n-  register jint i = prefix->count;\n+  jint i = prefix->count;\n   if (toffset < 0 || toffset + i > count)\n     return false;\n-  register jchar *xptr = JvGetStringChars (this) + toffset;\n-  register jchar *yptr = JvGetStringChars (prefix);\n+  jchar *xptr = JvGetStringChars (this) + toffset;\n+  jchar *yptr = JvGetStringChars (prefix);\n   while (--i >= 0)\n     {\n       if (*xptr++ != *yptr++)\n@@ -638,7 +638,7 @@ java::lang::String::indexOf (jint ch, jint fromIndex)\n {\n   if (fromIndex < 0)\n     fromIndex = 0;\n-  register jchar *ptr = JvGetStringChars(this);\n+  jchar *ptr = JvGetStringChars(this);\n   for (;; ++fromIndex)\n     {\n       if (fromIndex >= count)\n@@ -682,7 +682,7 @@ java::lang::String::lastIndexOf (jint ch, jint fromIndex)\n {\n   if (fromIndex >= count)\n     fromIndex = count - 1;\n-  register jchar *ptr = JvGetStringChars(this);\n+  jchar *ptr = JvGetStringChars(this);\n   for (;; --fromIndex)\n     {\n       if (fromIndex < 0)\n@@ -716,9 +716,9 @@ java::lang::String::concat(jstring str)\n   if (str_count == 0)\n     return this;\n   jstring result = JvAllocString(count + str_count);\n-  register jchar *dstPtr = JvGetStringChars(result);\n-  register jchar *srcPtr = JvGetStringChars(this);\n-  register jint i = count;\n+  jchar *dstPtr = JvGetStringChars(result);\n+  jchar *srcPtr = JvGetStringChars(this);\n+  jint i = count;\n   while (--i >= 0)\n     *dstPtr++ = *srcPtr++;\n   srcPtr = JvGetStringChars(str);\n@@ -834,9 +834,9 @@ java::lang::String::valueOf(jcharArray data, jint offset, jint count)\n   jint data_length = JvGetArrayLength (data);\n   if (offset < 0 || count < 0 || offset+count > data_length)\n     JvThrow (new java::lang::IndexOutOfBoundsException());\n-  register jstring result = JvAllocString(count);\n-  register jchar *sPtr = elements (data) + offset;\n-  register jchar *dPtr = JvGetStringChars(result);\n+  jstring result = JvAllocString(count);\n+  jchar *sPtr = elements (data) + offset;\n+  jchar *dPtr = JvGetStringChars(result);\n   while (--count >= 0)\n     *dPtr++ = *sPtr++;\n   return result;\n@@ -845,7 +845,7 @@ java::lang::String::valueOf(jcharArray data, jint offset, jint count)\n jstring\n java::lang::String::valueOf(jchar c)\n {\n-  register jstring result = JvAllocString(1);\n+  jstring result = JvAllocString(1);\n   JvGetStringChars (result)[0] = c;\n   return result;\n }"}, {"sha": "eeb4e41ef8250c9401cf871038d4a1ca494c8a8b", "filename": "libjava/java/lang/natThrowable.cc", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FnatThrowable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Flang%2FnatThrowable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThrowable.cc?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -39,23 +39,32 @@ details.  */\n \n #include <name-finder.h>\n \n+#ifdef __ia64__\n+extern \"C\" int _Jv_ia64_backtrace (void **array, int size);\n+#endif\n+\n /* FIXME: size of the stack trace is limited to 128 elements.  It's\n    undoubtedly sensible to limit the stack trace, but 128 is rather\n    arbitrary.  It may be better to configure this.  */\n \n java::lang::Throwable *\n java::lang::Throwable::fillInStackTrace (void)\n {\n-#ifdef HAVE_BACKTRACE\n+#if defined (HAVE_BACKTRACE) || defined (__ia64__)\n   void *p[128];\n   \n   // We subtract 1 from the number of elements because we don't want\n   // to include the call to fillInStackTrace in the trace.\n+#if defined (__ia64__)\n+  int n = _Jv_ia64_backtrace (p, 128) - 1;  \n+#else\n   int n = backtrace (p, 128) - 1;  \n+#endif\n \n   // ???  Might this cause a problem if the byte array isn't aligned?\n   stackTrace = JvNewByteArray (n * sizeof p[0]);\n   memcpy (elements (stackTrace), p+1, (n * sizeof p[0]));\n+\n #endif\n \n   return this;\n@@ -83,11 +92,15 @@ java::lang::Throwable::printRawStackTrace (java::io::PrintWriter *wr)\n \t{\n \t  wr->print (JvNewStringLatin1 (\": \"));\n \t  wr->print (JvNewStringLatin1 (finder.method_name));\n-\t  wr->print (JvNewStringLatin1 (\" (\"));\n-\t  wr->print (JvNewStringLatin1 (finder.file_name));\n-\t  wr->print (JvNewStringLatin1 (\")\"));\n+\t  if (finder.file_name[0])\n+\t    {\n+\t      wr->print (JvNewStringLatin1 (\" (\"));\n+\t      wr->print (JvNewStringLatin1 (finder.file_name));\n+\t      wr->print (JvNewStringLatin1 (\")\"));\n+\t    }\n \t}\n       wr->println ();\n     }\n #endif /* HAVE_BACKTRACE */\n+  wr->flush ();\n }"}, {"sha": "5931eefa3fba4dc138bfa7c5e879ce6983c81419", "filename": "libjava/java/net/URL.java", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURL.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -329,6 +329,20 @@ private URLStreamHandler setURLStreamHandler(String protocol)\n     // If a non-default factory has been set, use it to find the protocol.\n     if (factory != null)\n       handler = factory.createURLStreamHandler(protocol);\n+    else if (protocol.equals (\"file\"))\n+      {\n+\t// This is an interesting case.  It's tempting to think that we\n+\t// could call Class.forName (\"gnu.gcj.protocol.file.Handler\") to\n+\t// get the appropriate class.  Unfortunately, if we do that the\n+\t// program will never terminate, because setURLStreamHandler is\n+\t// eventually called by Class.forName.\n+\t//\n+\t// Treating \"file\" as a special case is the minimum that will\n+\t// fix this problem.  If other protocols are required in a\n+\t// statically linked application they will need to be handled in\n+\t// the same way as \"file\".\n+\thandler = new gnu.gcj.protocol.file.Handler ();\n+      }\n \n     // Non-default factory may have returned null or a factory wasn't set.\n     // Use the default search algorithm to find a handler for this protocol."}, {"sha": "f2e70ed37385a7724ad240f5e0ff4f218657992c", "filename": "libjava/java/security/BasicPermission.java", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fsecurity%2FBasicPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fsecurity%2FBasicPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FBasicPermission.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,271 @@\n+/* BasicPermission.java -- Implements a simple named permission.\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security;\n+\n+import java.io.Serializable;\n+import java.util.Hashtable;\n+import java.util.Enumeration;\n+\n+/**\n+  * This class implements a simple model for named permissions without an\n+  * associated action list.  That is, either the named permission is granted\n+  * or it is not.  \n+  * <p>\n+  * It also supports trailing wildcards to allow the\n+  * easy granting of permissions in a hierarchical fashion.  (For example,\n+  * the name \"org.gnu.*\" might grant all permissions under the \"org.gnu\"\n+  * permissions hierarchy).  The only valid wildcard character is a '*'\n+  * which matches anything.  It must be the rightmost element in the\n+  * permission name and must follow a '.' or else the Permission name must\n+  * consist of only a '*'.  Any other occurrence of a '*' is not valid.\n+  * <p>\n+  * This class ignores the action list.  Subclasses can choose to implement\n+  * actions on top of this class if desired.\n+  *\n+  * @version 0.1\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public abstract class BasicPermission extends Permission implements Serializable\n+{\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Constructors\n+   */\n+\n+  /**\n+   * This method initializes a new instance of <code>BasicPermission</code>\n+   * with the specified name.  If the name contains an illegal wildcard\n+   * character, an exception is thrown.\n+   *\n+   * @param name The name of this permission.\n+   *\n+   * @exception IllegalArgumentException If the name contains an invalid wildcard character\n+   * @exception NullPointerException If the name is null\n+   */\n+  public \n+  BasicPermission(String name) throws IllegalArgumentException, NullPointerException\n+  {\n+    super(name);\n+\n+    if (name.indexOf(\"*\") != -1)\n+      {\n+\tif (!name.endsWith(\".*\") && !name.equals(\"*\"))\n+          throw new IllegalArgumentException(\"Bad wildcard: \" + name);\n+\n+\tif (name.indexOf(\"*\") != name.lastIndexOf(\"*\"))\n+          throw new IllegalArgumentException(\"Bad wildcard: \" + name);\n+      }\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method initializes a new instance of <code>BasicPermission</code>\n+   * with the specified name.  If the name contains an illegal wildcard\n+   * character, an exception is thrown.  The action list passed to this\n+   * form of the constructor is ignored.\n+   *\n+   * @param name The name of this permission.\n+   * @param actions The list of actions for this permission - ignored in this class.\n+   *\n+   * @exception IllegalArgumentException If the name contains an invalid wildcard character\n+   * @exception NullPointerException If the name is null\n+   */\n+  public\n+  BasicPermission(String name, String actions) throws IllegalArgumentException, NullPointerException\n+  {\n+    // ignore actions\n+    this(name);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method tests to see if the specified permission is implied by \n+   * this permission.  This will be true if the following conditions are met:\n+   * <p>\n+   * <ul>\n+   * <li>The specified object is an instance of <code>BasicPermission</code>, \n+   * or a subclass.\n+   * <li>The name of the specified permission is identical to this permission's\n+   * name or the name of the specified permission satisfies a wildcard match \n+   * on this permission.\n+   * </ul>\n+   *\n+   * @param perm The <code>Permission</code> object to test against.\n+   *\n+   * @return <code>true</code> if the specified permission is implied by this one or <code>false</code> otherwise.\n+   */\n+  public boolean\n+  implies(Permission perm)\n+  {\n+    if (!(perm instanceof BasicPermission))\n+      return false;\n+\n+    String otherName = perm.getName();\n+    String name = getName();\n+\n+    if (name.equals(otherName))\n+      return true;\n+\n+    int last = name.length() - 1;\n+    if (name.charAt(last) == '*'\n+\t&& otherName.startsWith(name.substring(0, last)))\n+      return true;\n+\n+    return false;\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method tests to see if this object is equal to the specified\n+   * <code>Object</code>.  This will be true if and only if the specified\n+   * object meets the following conditions:\n+   * <p>\n+   * <ul>\n+   * <li>It is an instance of <code>BasicPermission</code>, or a subclass.\n+   * <li>It has the same name as this permission.\n+   * </ul>\n+   *\n+   * @param obj The <code>Object</code> to test for equality against this object\n+   *\n+   * @return <code>true</code> if the specified <code>Object</code> is equal to this object or <code>false</code> otherwise.\n+   */\n+  public boolean\n+  equals(Object obj)\n+  {\n+    if (!(obj instanceof BasicPermission))\n+      return(false);\n+\n+    if (!getName().equals(((BasicPermission)obj).getName()))\n+      return(false);\n+\n+    return(true);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method returns a hash code for this permission object.  The hash\n+   * code returned is the value returned by calling the <code>hashCode</code>\n+   * method on the <code>String</code> that is the name of this permission.\n+   *\n+   * @return A hash value for this object\n+   */\n+  public int\n+  hashCode()\n+  {\n+    return(getName().hashCode());\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method returns a list of the actions associated with this \n+   * permission.  This method always returns the empty string (\"\") since\n+   * this class ignores actions.\n+   *\n+   * @return The action list.\n+   */\n+  public String\n+  getActions()\n+  {\n+    return(\"\");\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+   * This method returns an instance of <code>PermissionCollection</code>\n+   * suitable for storing <code>BasicPermission</code> objects.  This returns\n+   * be a sub class of <code>PermissionCollection</code>\n+   * that allows for an efficient and consistent implementation of\n+   * the <code>implies</code> method.  The collection doesn't handle subclasses\n+   * of BasicPermission correctly; they must override this method. \n+   *\n+   * @return A new empty <code>PermissionCollection</code> object.\n+   */\n+  public PermissionCollection\n+  newPermissionCollection()\n+  {\n+    return new PermissionCollection() \n+      {\n+\tHashtable permissions = new Hashtable();\n+\tboolean allAllowed = false;\n+      \n+\tpublic void add(Permission permission) \n+\t{\n+\t  if (isReadOnly())\n+\t    throw new IllegalStateException(\"readonly\");\n+\n+\t  BasicPermission bp = (BasicPermission) permission;\n+\t  String name = bp.getName();\n+\t  if (name.equals(\"*\"))\n+\t    allAllowed = true;\n+\t  permissions.put(name, bp);\n+\t}\n+      \n+\tpublic boolean implies(Permission permission)\n+\t{\n+\t  if (!(permission instanceof BasicPermission))\n+\t    return false;\n+\t    \n+\t  if (allAllowed)\n+\t    return true;\n+\n+\t  BasicPermission toImply = (BasicPermission) permission;\n+\t  String name = toImply.getName();\n+\t  if (name.equals(\"*\"))\n+\t    return false;\n+\n+\t  int prefixLength = name.length();\n+\t  if (name.endsWith(\"*\"))\n+\t    prefixLength -= 2;\n+\n+\t  while (true) {\n+\t    if (permissions.get(name) != null)\n+\t      return true;\n+\t      \n+\t    prefixLength = name.lastIndexOf('.', prefixLength);\n+\t    if (prefixLength < 0)\n+\t      return false;\n+\t    name = name.substring(0, prefixLength + 1) + '*';\n+\t  }\n+\t}\n+      \n+\tpublic Enumeration elements()\n+\t{\n+\t  return permissions.elements();\n+\t}\n+      };\n+  }\n+} // class BasicPermission"}, {"sha": "8d51278b4d2bd1e0870ee5dede0522859bee9aab", "filename": "libjava/java/security/DigestOutputStream.java", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fsecurity%2FDigestOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fsecurity%2FDigestOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FDigestOutputStream.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,147 @@\n+/* DigestOutputStream.java --- An output stream tied to a message digest\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security;\n+\n+import java.io.OutputStream;\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+\n+/**\n+   DigestOutputStream is a class that ties an OutputStream with a\n+   MessageDigest. The Message Digest is used by the class to update it\n+   self as bytes are written to the OutputStream.\n+\n+   The updating to the digest depends on the on flag which is set to\n+   true by default that tells the class to update the data in the\n+   message digest.\n+\n+   @version 0.0\n+   @author Mark Benvenuto <ivymccough@worldnet.att.net>\n+*/\n+public class DigestOutputStream extends FilterOutputStream\n+{\n+  /**\n+     The message digest for the DigestOutputStream\n+  */\n+  protected MessageDigest digest;\n+\n+  //Manages the on flag\n+  private boolean state = true;\n+\n+  /**\n+     Constructs a new DigestOutputStream.  It associates a\n+     MessageDigest with the stream to compute the stream as data is\n+     written.\n+\n+     @param stream An OutputStream to associate this stream with\n+     @param digest A MessageDigest to hash the stream with\n+  */\n+  public DigestOutputStream (OutputStream stream, MessageDigest digest)\n+  {\n+    super (stream);\n+    this.digest = digest;\n+  }\n+\n+  /**\n+     Returns the MessageDigest associated with this DigestOutputStream\n+\n+     @return The MessageDigest used to hash this stream\n+  */\n+  public MessageDigest getMessageDigest ()\n+  {\n+    return digest;\n+  }\n+  \n+  /**\n+     Sets the current MessageDigest to current parameter\n+\t\n+     @param digest A MessageDigest to associate with this stream\n+  */\n+  public void setMessageDigest (MessageDigest digest)\n+  {\n+    this.digest = digest;\n+  }\n+\n+\n+  /**\n+     Updates the hash if the on flag is true and then writes a byte to\n+     the underlying output stream.\n+\n+     @param b A byte to write to the output stream\n+     \n+     @exception IOException if the underlying output stream \n+     cannot write the byte, this is thrown.\n+  */\n+  public void write (int b) throws IOException\n+  {\n+    if (state)\n+      digest.update ((byte)b);\n+    \n+    super.write (b);\n+  }\n+\n+  /**\n+     Updates the hash if the on flag is true and then writes the bytes\n+     to the underlying output stream.\n+\n+     @param b Bytes to write to the output stream\n+     @param off Offset to start to start at in array\n+     @param len Length of data to write\n+\n+     @exception IOException if the underlying output stream \n+     cannot write the bytes, this is thrown.\n+  */\n+  public void write (byte[] b, int off, int len) throws IOException\n+  {\n+    if (state)\n+      digest.update (b, off, len);\n+\n+    super.write (b, off, len);\n+  }\n+\n+  /**\n+     Sets the flag specifying if this DigestOutputStream updates the\n+     digest in the write() methods. The default is on;\n+\n+     @param on True means it digests stream, false means it does not\n+  */\n+  public void on (boolean on)\n+  {\n+    state = on;\n+  }\n+\n+  /**\n+     Converts the output stream and underlying message digest to a string.\n+\n+     @return A string representing the output stream and message digest.\n+  */\n+  public String toString()\n+  {\n+    return \"[Digest Output Stream] \" + digest.toString();\n+  }\n+}"}, {"sha": "b397dddf207ad1f540f3c6cbe1d0892ae160fd92", "filename": "libjava/java/security/Guard.java", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fsecurity%2FGuard.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fsecurity%2FGuard.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FGuard.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,54 @@\n+/* Guard.java -- Check access to a guarded object\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security;\n+\n+/**\n+  * This interface specifies a mechanism for querying whether or not\n+  * access is allowed to a guarded object.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public interface Guard\n+{\n+\n+/**\n+  * This method tests whether or not access is allowed to the specified\n+  * guarded object.  Access is allowed if this method returns silently.  If\n+  * access is denied, an exception is generated.\n+  *\n+  * @param obj The <code>Object</code> to test\n+  *\n+  * @exception SecurityException If access to the object is denied.\n+  */\n+public abstract void\n+checkGuard(Object obj) throws SecurityException;\n+\n+} // interface Guard\n+"}, {"sha": "620d5b42d2d786979ac8f07732521da8e37f6042", "filename": "libjava/java/security/Permission.java", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fsecurity%2FPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fsecurity%2FPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FPermission.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,191 @@\n+/* Permission.java -- The superclass for all permission objects\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security;\n+\n+import java.io.Serializable;\n+\n+/**\n+  * This class is the abstract superclass of all classes that implement\n+  * the concept of a permission.  A permission consists of a permission name \n+  * and optionally a list of actions that relate to the permission.  The\n+  * actual meaning of the name of the permission is defined only in the\n+  * context of a subclass.  It may name a resource to which access permissions\n+  * are granted (for example, the name of a file) or it might represent\n+  * something else entirely.  Similarly, the action list only has meaning\n+  * within the context of a subclass.  Some permission names may have no\n+  * actions associated with them.  That is, you either have the permission\n+  * or you don't.\n+  *\n+  * The most important method in this class is <code>implies</code>.  This\n+  * checks whether if one has this permission, then the specified\n+  * permission is also implied.  As a conceptual example, consider the\n+  * permissions \"Read All Files\" and \"Read File foo\".  The permission\n+  * \"Read All Files\" implies that the caller has permission to read the\n+  * file foo.\n+  *\n+  * <code>Permission</code>'s are not dynamic objects.  Once created, a \n+  * <code>Permission</code>'s name and action list cannot be changed.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public abstract class Permission implements Guard, Serializable\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * This is the name assigned to this permission object.\n+  */ \n+protected String name; // Taken from the serializable form information\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * This method initializes a new instance of <code>Permission</code> to\n+  * have the specified name.\n+  */\n+public\n+Permission(String name)\n+{\n+  this.name = name;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * This method returns the name of this <code>Permission</code>\n+  *\n+  * @return The name of this <code>Permission</code>\n+  */\n+public String\n+getName()\n+{\n+  return(name);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns the list of actions for this <code>Permission</code>\n+  * as a <code>String</code>.\n+  *\n+  * @return The action list for this <code>Permission</code>.\n+  */\n+public abstract String\n+getActions();\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method implements the <code>Guard</code> interface for this class.\n+  * It calls the <code>checkPermission</code> method in \n+  * <code>SecurityManager</code> with this <code>Permission</code> as its\n+  * argument.  This method returns silently if the security check succeeds\n+  * or throws an exception if it fails.\n+  *\n+  * @param obj The <code>Object</code> being guarded - ignored by this class\n+  *\n+  * @exception SecurityException If the security check fails\n+  */\n+public void\n+checkGuard(Object obj) throws SecurityException\n+{\n+  SecurityManager sm = System.getSecurityManager();\n+//  if (sm != null)\n+//    sm.checkPermission(this);\n+}\n+  \n+/*************************************************************************/\n+\n+/**\n+  * This method tests whether this <code>Permission</code> implies that the\n+  * specified <code>Permission</code> is also granted.\n+  *\n+  * @param perm The <code>Permission</code> to test against\n+  *\n+  * @return <code>true</code> if the specified <code>Permission</code> is implied by this one, <code>false</code> otherwise.\n+  */\n+public abstract boolean\n+implies(Permission perm);\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns a hash code for this <code>Permission</code>.\n+  *\n+  * @return A hash value.\n+  */\n+public abstract int\n+hashCode();\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns a <code>String</code> representation of this\n+  * <code>Permission</code> object.\n+  *\n+  * @return This object as a <code>String</code>.\n+  */\n+public String\n+toString()\n+{\n+  return(\"'\\\"\" + getClass().getName() + \"\\\" \\\"\" + getName() + \n+         \"\\\"\" + \" \\\"\" + getActions() + \"\\\")'\");\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns an empty <code>PermissionCollection</code> object\n+  * that can store permissions of this type, or <code>null</code> if no\n+  * such collection is defined.\n+  *\n+  * @return A new <code>PermissionCollection</code>\n+  */\n+public PermissionCollection\n+newPermissionCollection()\n+{\n+  return(null);\n+}\n+\n+} // class Permission\n+"}, {"sha": "08a9c4987b7f60f5cfb639417e2abed7951729ee", "filename": "libjava/java/security/PermissionCollection.java", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fsecurity%2FPermissionCollection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Fsecurity%2FPermissionCollection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FPermissionCollection.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,207 @@\n+/* PermissionCollection.java -- A collection of permission objects\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security;\n+\n+import java.io.Serializable;\n+import java.util.Enumeration;\n+\n+/**\n+  * This class models a group of Java permissions.  It has convenient\n+  * methods for determining whether or not a given permission is implied\n+  * by any of the permissions in this collection.\n+  * <p>\n+  * Some care must be taken in storing permissions.  First, a collection of\n+  * the appropriate type must be created.  This is done by calling the\n+  * <code>newPermissionCollection</code> method on an object of the \n+  * permission class you wish to add to the collection.  If this method\n+  * returns <code>null</code>, any type of <code>PermissionCollection</code>\n+  * can be used to store permissions of that type.  However, if a\n+  * <code>PermissionCollection</code> collection object is returned, that\n+  * type must be used.  \n+  * <p>\n+  * The <code>PermissionCollection</code>'s returned\n+  * by the <code>newPermissionCollection</code> instance in a subclass of\n+  * <code>Permission</code> is a homogeneous collection.  It only will \n+  * hold permissions of one specified type - instances of the class that\n+  * created it.  Not all <code>PermissionCollection</code> subclasses\n+  * have to hold permissions of only one type however.  For example,\n+  * the <code>Permissions</code> class holds permissions of many types.\n+  * <p>\n+  * Since the <code>newPermissionCollection</code> in <code>Permission</code>\n+  * itself returns <code>null</code>, by default a permission can be stored\n+  * in any type of collection unless it overrides that method to create its\n+  * own collection type.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public abstract class PermissionCollection extends Object implements Serializable\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Class Variables\n+ */\n+\n+public static final String linesep = null;\n+\n+static\n+{\n+  String linesep = System.getProperty(\"line.separator\");\n+  if (linesep == null);\n+    linesep = \"\\n\";\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * Indicates whether or not this collection is read only.\n+  */\n+private boolean readOnly; \n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * This method initializes a new instance of <code>PermissionCollection</code>.\n+  * This is provided only as a default constructor and does nothing in this\n+  * class.\n+  */\n+public\n+PermissionCollection()\n+{\n+  ;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * This method tests whether or not this <code>PermissionCollection</code>\n+  * object is read only.\n+  *\n+  * @return <code>true</code> if this collection is read only, <code>false</code> otherwise\n+  */\n+public boolean\n+isReadOnly()\n+{\n+  return(readOnly);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method sets this <code>PermissionCollection</code> object to be\n+  * read only.  No further permissions can be added to it after calling this\n+  * method.\n+  */\n+public void\n+setReadOnly()\n+{\n+  readOnly = true;\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method adds a new <code>Permission</code> object to the collection.\n+  *\n+  * @param perm The <code>Permission</code> to add.\n+  *\n+  * @exception SecurityException If the collection is marked read only.\n+  * @exception IllegalArgumentException If a permission of the specified type cannot be added\n+  */\n+public abstract void\n+add(Permission perm) throws SecurityException, IllegalArgumentException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns an <code>Enumeration</code> of all the objects in\n+  * this collection.\n+  *\n+  * @return An <code>Enumeration</code> of this collection's objects.\n+  */\n+public abstract Enumeration\n+elements();\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method tests whether the specified <code>Permission</code> object is\n+  * implied by this collection of <code>Permission</code> objects.\n+  *\n+  * @param perm The <code>Permission</code> object to test.\n+  *\n+  * @return <code>true</code> if the specified <code>Permission</code> is implied by this collection, <code>false</code> otherwise.\n+  */\n+public abstract boolean\n+implies(Permission perm);\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns a <code>String</code> representation of this\n+  * collection.  It will print the class name and has code in the same\n+  * manner as <code>Object.toString()</code> then print a listing of all\n+  * the <code>Permission</code> objects contained.\n+  *\n+  * @return A <code>String</code> representing this object.\n+  */\n+public String\n+toString()\n+{\n+  StringBuffer sb = new StringBuffer(\"\");\n+\n+  sb.append(super.toString() + \" (\" + linesep);\n+  Enumeration e = elements();\n+  while (e.hasMoreElements())\n+    {\n+      Object obj = e.nextElement();\n+      if (obj instanceof Permission)\n+        sb.append(((Permission)obj).toString() + linesep);\n+    }\n+\n+  sb.append(\")\" + linesep);\n+  return(sb.toString());\n+}\n+\n+} // class PermissionCollection\n+"}, {"sha": "800204441deb1e98e6c19e31cdbc1854cb8fbdb8", "filename": "libjava/java/util/AbstractCollection.java", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Futil%2FAbstractCollection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Futil%2FAbstractCollection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractCollection.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,339 @@\n+/* AbstractCollection.java -- Abstract implementation of most of Collection\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+\n+import java.lang.reflect.Array;\n+\n+/**\n+ * A basic implementation of most of the methods in the Collection interface to\n+ * make it easier to create a collection. To create an unmodifiable Collection,\n+ * just subclass AbstractCollection and provide implementations of the\n+ * iterator() and size() methods. The Iterator returned by iterator() need only\n+ * provide implementations of hasNext() and next() (that is, it may throw an\n+ * UnsupportedOperationException if remove() is called). To create a modifiable\n+ * Collection, you must in addition provide an implementation of the\n+ * add(Object) method and the Iterator returned by iterator() must provide an\n+ * implementation of remove(). Other methods should be overridden if the\n+ * backing data structure allows for a more efficient implementation. The\n+ * precise implementation used by AbstractCollection is documented, so that\n+ * subclasses can tell which methods could be implemented more efficiently.\n+ */\n+public abstract class AbstractCollection implements Collection {\n+\n+  /**\n+   * Return an Iterator over this collection. The iterator must provide the\n+   * hasNext and next methods and should in addition provide remove if the\n+   * collection is modifiable.\n+   */\n+  public abstract Iterator iterator();\n+\n+  /**\n+   * Return the number of elements in this collection.\n+   */\n+  public abstract int size();\n+\n+  /**\n+   * Add an object to the collection. This implementation always throws an\n+   * UnsupportedOperationException - it should be overridden if the collection\n+   * is to be modifiable.\n+   *\n+   * @param o the object to add\n+   * @return true if the add operation caused the Collection to change\n+   * @exception UnsupportedOperationException if the add operation is not\n+   *   supported on this collection\n+   */\n+  public boolean add(Object o) {\n+    throw new java.lang.UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Add all the elements of a given collection to this collection. This\n+   * implementation obtains an Iterator over the given collection and iterates\n+   * over it, adding each element with the add(Object) method (thus this method\n+   * will fail with an UnsupportedOperationException if the add method does).\n+   *\n+   * @param c the collection to add the elements of to this collection\n+   * @return true if the add operation caused the Collection to change\n+   * @exception UnsupportedOperationException if the add operation is not\n+   *   supported on this collection\n+   */\n+  public boolean addAll(Collection c) {\n+    Iterator i = c.iterator();\n+    boolean modified = false;\n+    while (i.hasNext()) {\n+      modified |= add(i.next());\n+    }\n+    return modified;\n+  }\n+\n+  /**\n+   * Remove all elements from the collection. This implementation obtains an\n+   * iterator over the collection and calls next and remove on it repeatedly\n+   * (thus this method will fail with an UnsupportedOperationException if the\n+   * Iterator's remove method does) until there are no more elements to remove.\n+   * Many implementations will have a faster way of doing this.\n+   *\n+   * @exception UnsupportedOperationException if the Iterator returned by\n+   *   iterator does not provide an implementation of remove\n+   */\n+  public void clear() {\n+    Iterator i = iterator();\n+    while (i.hasNext()) {\n+      i.next();\n+      i.remove();\n+    }\n+  }\n+\n+  /**\n+   * Test whether this collection contains a given object. That is, if the\n+   * collection has an element e such that (o == null ? e == null :\n+   * o.equals(e)). This implementation obtains an iterator over the collection\n+   * and iterates over it, testing each element for equality with the given\n+   * object. If it is equal, true is returned. Otherwise false is returned when\n+   * the end of the collection is reached.\n+   *\n+   * @param o the object to remove from this collection\n+   * @return true if this collection contains an object equal to o\n+   */\n+  public boolean contains(Object o) {\n+    Iterator i = iterator();\n+\n+    // This looks crazily inefficient, but it takes the test o==null outside\n+    // the loop, saving time, and also saves needing to store the result of\n+    // i.next() each time.\n+    if (o == null) {\n+      while (i.hasNext()) {\n+        if (i.next() == null) {\n+          return true;\n+        }\n+      }\n+    } else {\n+      while (i.hasNext()) {\n+        if (o.equals(i.next())) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Tests whether this collection contains all the elements in a given\n+   * collection. This implementation iterates over the given collection,\n+   * testing whether each element is contained in this collection. If any one\n+   * is not, false is returned. Otherwise true is returned.\n+   *\n+   * @param c the collection to test against\n+   * @return true if this collection contains all the elements in the given\n+   *   collection\n+   */\n+  public boolean containsAll(Collection c) {\n+    Iterator i = c.iterator();\n+    while (i.hasNext()) {\n+      if (!contains(i.next())) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Test whether this collection is empty. This implementation returns\n+   * size() == 0.\n+   *\n+   * @return true if this collection is empty.\n+   */\n+  public boolean isEmpty() {\n+    return size() == 0;\n+  }\n+\n+  /**\n+   * Remove a single instance of an object from this collection. That is,\n+   * remove one element e such that (o == null ? e == null : o.equals(e)), if\n+   * such an element exists. This implementation obtains an iterator over the\n+   * collection and iterates over it, testing each element for equality with\n+   * the given object. If it is equal, it is removed by the iterator's remove\n+   * method (thus this method will fail with an UnsupportedOperationException\n+   * if the Iterator's remove method does). After the first element has been\n+   * removed, true is returned; if the end of the collection is reached, false\n+   * is returned.\n+   *\n+   * @param o the object to remove from this collection\n+   * @return true if the remove operation caused the Collection to change, or\n+   *   equivalently if the collection did contain o.\n+   * @exception UnsupportedOperationException if this collection's Iterator\n+   *   does not support the remove method\n+   */\n+  public boolean remove(Object o) {\n+    Iterator i = iterator();\n+\n+    // This looks crazily inefficient, but it takes the test o==null outside\n+    // the loop, saving time, and also saves needing to store the result of\n+    // i.next() each time.\n+    if (o == null) {\n+      while (i.hasNext()) {\n+        if (i.next() == null) {\n+          i.remove();\n+\t  return true;\n+        }\n+      }\n+    } else {\n+      while (i.hasNext()) {\n+        if (o.equals(i.next())) {\n+          i.remove();\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Remove from this collection all its elements that are contained in a given\n+   * collection. This implementation iterates over this collection, and for\n+   * each element tests if it is contained in the given collection. If so, it\n+   * is removed by the Iterator's remove method (thus this method will fail\n+   * with an UnsupportedOperationException if the Iterator's remove method\n+   * does).\n+   *\n+   * @param c the collection to remove the elements of\n+   * @return true if the remove operation caused the Collection to change\n+   * @exception UnsupportedOperationException if this collection's Iterator\n+   *   does not support the remove method\n+   */\n+  public boolean removeAll(Collection c) {\n+    Iterator i = iterator();\n+    boolean changed = false;\n+    while (i.hasNext()) {\n+      if (c.contains(i.next())) {\n+        i.remove();\n+        changed = true;\n+      }\n+    }\n+    return changed;\n+  }\n+\n+  /**\n+   * Remove from this collection all its elements that are not contained in a\n+   * given collection. This implementation iterates over this collection, and\n+   * for each element tests if it is contained in the given collection. If not,\n+   * it is removed by the Iterator's remove method (thus this method will fail\n+   * with an UnsupportedOperationException if the Iterator's remove method\n+   * does).\n+   *\n+   * @param c the collection to retain the elements of\n+   * @return true if the remove operation caused the Collection to change\n+   * @exception UnsupportedOperationException if this collection's Iterator\n+   *   does not support the remove method\n+   */\n+  public boolean retainAll(Collection c) {\n+    Iterator i = iterator();\n+    boolean changed = false;\n+    while (i.hasNext()) {\n+      if (!c.contains(i.next())) {\n+        i.remove();\n+        changed = true;\n+      }\n+    }\n+    return changed;\n+  }\n+\n+  /**\n+   * Return an array containing the elements of this collection. This\n+   * implementation creates an Object array of size size() and then iterates\n+   * over the collection, setting each element of the array from the value\n+   * returned by the iterator.\n+   *\n+   * @return an array containing the elements of this collection\n+   */\n+  public Object[] toArray() {\n+    Object[] a = new Object[size()];\n+    Iterator i = iterator();\n+    for (int pos = 0; pos < a.length; pos++) {\n+      a[pos] = i.next();\n+    }\n+    return a;\n+  }\n+\n+  /**\n+   * Copy the collection into a given array if it will fit, or into a\n+   * dynamically created array of the same run-time type as the given array if\n+   * not. If there is space remaining in the array, the first element after the\n+   * end of the collection is set to null (this is only useful if the\n+   * collection is known to contain no null elements, however). This\n+   * implementation first tests whether the given array is large enough to hold\n+   * all the elements of the collection. If not, the reflection API is used to\n+   * allocate a new array of the same run-time type. Next an iterator is\n+   * obtained over the collection and the elements are placed in the array as\n+   * they are returned by the iterator. Finally the first spare element, if\n+   * any, of the array is set to null, and the created array is returned.\n+   *\n+   * @param a the array to copy into, or of the correct run-time type\n+   * @return the array that was produced\n+   * @exception ClassCastException if the type of the array precludes holding\n+   *   one of the elements of the Collection\n+   */\n+  public Object[] toArray(Object[] a) {\n+    final int n = size();\n+    if (a.length < n) {\n+      a = (Object[])Array.newInstance(a.getClass().getComponentType(), n);\n+    }\n+    Iterator i = iterator();\n+    for (int pos = 0; pos < n; pos++) {\n+      a[pos] = i.next();\n+    }\n+    if (a.length > n) {\n+      a[n] = null;\n+    }\n+    return a;\n+  }\n+\n+  /**\n+   * Creates a String representation of the Collection. The string returned is\n+   * of the form \"[a, b, ...]\" where a and b etc are the results of calling\n+   * toString on the elements of the collection. This implementation obtains an\n+   * Iterator over the Collection and adds each element to a StringBuffer as it\n+   * is returned by the iterator.\n+   *\n+   * @return a String representation of the Collection\n+   */\n+  public String toString() {\n+    StringBuffer s = new StringBuffer();\n+    s.append('[');\n+    Iterator i = iterator();\n+    boolean more = i.hasNext();\n+    while(more) {\n+      s.append(i.next());\n+      if (more = i.hasNext()) {\n+        s.append(\", \");\n+      }\n+    }\n+    s.append(']');\n+    return s.toString();\n+  }\n+}"}, {"sha": "da76a8b3104e0fbe9b16c5d3adc42fb9c7f07bfc", "filename": "libjava/java/util/AbstractList.java", "status": "added", "additions": 558, "deletions": 0, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Futil%2FAbstractList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Futil%2FAbstractList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractList.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,558 @@\n+/* AbstractList.java -- Abstract implementation of most of List\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+// TO DO:\n+// ~ Doc comments for almost everything.\n+// ~ Better general commenting\n+\n+package java.util;\n+\n+/**\n+ * A basic implementation of most of the methods in the List interface to make\n+ * it easier to create a List based on a random-access data structure. To\n+ * create an unmodifiable list, it is only necessary to override the size() and\n+ * get(int) methods (this contrasts with all other abstract collection classes\n+ * which require an iterator to be provided). To make the list modifiable, the\n+ * set(int, Object)  method should also be overridden, and to make the list\n+ * resizable, the add(int, Object) and remove(int) methods should be overridden\n+ * too. Other methods should be overridden if the backing data structure allows\n+ * for a more efficient implementation. The precise implementation used by\n+ * AbstractList is documented, so that subclasses can tell which methods could\n+ * be implemented more efficiently.\n+ */\n+public abstract class AbstractList extends AbstractCollection implements List {\n+\n+  /**\n+   * A count of the number of structural modifications that have been made to\n+   * the list (that is, insertions and removals).\n+   */\n+  protected transient int modCount = 0;\n+\n+  public abstract Object get(int index);\n+\n+  public void add(int index, Object o) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public boolean add(Object o) {\n+    add(size(), o);\n+    return true;\n+  }\n+\n+  public boolean addAll(int index, Collection c) {\n+    Iterator i = c.iterator();\n+    if (i.hasNext()) {\n+      do {\n+        add(index++, i.next());\n+      } while (i.hasNext());\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  public void clear() {\n+    removeRange(0, size());\n+  }\n+\n+  public boolean equals(Object o) {\n+    if (o == this) {\n+      return true;\n+    } else if (!(o instanceof List)) {\n+      return false;\n+    } else {\n+      Iterator i1 = iterator();\n+      Iterator i2 = ((List)o).iterator();\n+      while (i1.hasNext()) {\n+        if (!i2.hasNext()) {\n+          return false;\n+        } else {\n+          Object e = i1.next();\n+          if (e == null ? i2.next() != null : !e.equals(i2.next())) {\n+            return false;\n+          }\n+        }\n+      }\n+      if (i2.hasNext()) {\n+        return false;\n+      } else {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  public int hashCode() {\n+    int hashCode = 1;\n+    Iterator i = iterator();\n+    while (i.hasNext()) {\n+      Object obj = i.next();\n+      hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n+    }\n+    return hashCode;\n+  }\n+\n+  public int indexOf(Object o) {\n+    int index = 0;\n+    ListIterator i = listIterator();\n+    if (o == null) {\n+      while (i.hasNext()) {\n+        if (i.next() == null) {\n+          return index;\n+        }\n+        index++;\n+      }\n+    } else {\n+      while (i.hasNext()) {\n+        if (o.equals(i.next())) {\n+          return index;\n+        }\n+        index++;\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  public Iterator iterator() {\n+    return new Iterator() {\n+      private int knownMod = modCount;\n+      private int position = 0;\n+      boolean removed = true;\n+\n+      private void checkMod() {\n+        if (knownMod != modCount) {\n+          throw new ConcurrentModificationException();\n+        }\n+      }\n+\n+      public boolean hasNext() {\n+        checkMod();\n+        return position < size();\n+      }\n+\n+      public Object next() {\n+        checkMod();\n+        removed = false;\n+        try {\n+          return get(position++);\n+        } catch (IndexOutOfBoundsException e) {\n+          throw new NoSuchElementException();\n+        }\n+      }\n+\n+      public void remove() {\n+        checkMod();\n+        if (removed) {\n+          throw new IllegalStateException();\n+        }\n+        AbstractList.this.remove(--position);\n+        knownMod = modCount;\n+        removed = true;\n+      }\n+    };\n+  }\n+\n+  public int lastIndexOf(Object o) {\n+    int index = size();\n+    ListIterator i = listIterator(index);\n+    if (o == null) {\n+      while (i.hasPrevious()) {\n+        index--;\n+        if (i.previous() == null) {\n+          return index;\n+        }\n+      }\n+    } else {\n+      while (i.hasPrevious()) {\n+        index--;\n+        if (o.equals(i.previous())) {\n+          return index;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  public ListIterator listIterator() {\n+    return listIterator(0);\n+  }\n+\n+  public ListIterator listIterator(final int index) {\n+\n+    if (index < 0 || index > size()) {\n+      throw new IndexOutOfBoundsException();\n+    }\n+\n+    return new ListIterator() {\n+      private int knownMod = modCount;\n+      private int position = index;\n+      private int lastReturned = -1;\n+\n+      private void checkMod() {\n+        if (knownMod != modCount) {\n+          throw new ConcurrentModificationException();\n+        }\n+      }\n+\n+      public boolean hasNext() {\n+        checkMod();\n+        return position < size();\n+      }\n+\n+      public boolean hasPrevious() {\n+        checkMod();\n+        return position > 0;\n+      }\n+\n+      public Object next() {\n+        checkMod();\n+        if (hasNext()) {\n+          lastReturned = position++;\n+          return get(lastReturned);\n+        } else {\n+          throw new NoSuchElementException();\n+        }\n+      }\n+\n+      public Object previous() {\n+        checkMod();\n+        if (hasPrevious()) {\n+          lastReturned = --position;\n+          return get(lastReturned);\n+        } else {\n+          throw new NoSuchElementException();\n+        }\n+      }\n+\n+      public int nextIndex() {\n+        checkMod();\n+        return position;\n+      }\n+\n+      public int previousIndex() {\n+        checkMod();\n+        return position - 1;\n+      }\n+\n+      public void remove() {\n+        checkMod();\n+        if (lastReturned < 0) {\n+          throw new IllegalStateException();\n+        }\n+        AbstractList.this.remove(lastReturned);\n+        knownMod = modCount;\n+        position = lastReturned;\n+        lastReturned = -1;\n+      }\n+\n+      public void set(Object o) {\n+        checkMod();\n+        if (lastReturned < 0) {\n+          throw new IllegalStateException();\n+        }\n+        AbstractList.this.set(lastReturned, o);\n+      }\n+\n+      public void add(Object o) {\n+        checkMod();\n+        AbstractList.this.add(position++, o);\n+        lastReturned = -1;\n+        knownMod = modCount;\n+      }\n+    };\n+  }\n+\n+  public Object remove(int index) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Remove a subsection of the list. This is called by the clear and\n+   * removeRange methods of the class which implements subList, which are\n+   * difficult for subclasses to override directly. Therefore, this method\n+   * should be overridden instead by the more efficient implementation, if one\n+   * exists.\n+   * <p>\n+   * This implementation first checks for illegal or out of range arguments. It\n+   * then obtains a ListIterator over the list using listIterator(fromIndex).\n+   * It then calls next() and remove() on this iterator repeatedly, toIndex -\n+   * fromIndex times.\n+   *\n+   * @param fromIndex the index, inclusive, to remove from.\n+   * @param toIndex the index, exclusive, to remove to.\n+   * @exception UnsupportedOperationException if this list does not support\n+   *   the removeRange operation.\n+   * @exception IndexOutOfBoundsException if fromIndex > toIndex || fromIndex <\n+   *   0 || toIndex > size().\n+   */\n+  protected void removeRange(int fromIndex, int toIndex) {\n+    if (fromIndex > toIndex) {\n+      throw new IllegalArgumentException();\n+    } else if (fromIndex < 0 || toIndex > size()) {\n+      throw new IndexOutOfBoundsException();\n+    } else {\n+      ListIterator i = listIterator(fromIndex);\n+      for (int index = fromIndex; index < toIndex; index++) {\n+        i.next();\n+        i.remove();\n+      }\n+    }\n+  }\n+\n+  public Object set(int index, Object o) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public List subList(final int fromIndex, final int toIndex) {\n+    if (fromIndex > toIndex)\n+      throw new IllegalArgumentException();\n+    if (fromIndex < 0 || toIndex > size())\n+      throw new IndexOutOfBoundsException();\n+    return new SubList(this, fromIndex, toIndex);\n+  }\n+\n+  static class SubList extends AbstractList {\n+\n+    private AbstractList backingList;\n+    private int offset;\n+    private int size;\n+\n+    public SubList(AbstractList backing, int fromIndex, int toIndex) {\n+      backingList = backing;\n+      upMod();\n+      offset = fromIndex;\n+      size = toIndex - fromIndex;\n+    }\n+\n+    // Note that within this class two fields called modCount are inherited -\n+    // one from the superclass, and one from the outer class. \n+    // The code uses both these two fields and *no other* to provide fail-fast\n+    // behaviour. For correct operation, the two fields should contain equal\n+    // values. Therefore, if this.modCount != backingList.modCount, there\n+    // has been a concurrent modification. This is all achieved purely by using\n+    // the modCount field, precisely according to the docs of AbstractList.\n+    // See the methods upMod and checkMod.\n+\n+    /**\n+     * This method checks the two modCount fields to ensure that there has\n+     * not been a concurrent modification. It throws an exception if there\n+     * has been, and otherwise returns normally.\n+     * Note that since this method is private, it will be inlined.\n+     *\n+     * @exception ConcurrentModificationException if there has been a\n+     *   concurrent modification.\n+     */\n+    private void checkMod() {\n+      if (this.modCount != backingList.modCount) {\n+\tthrow new ConcurrentModificationException();\n+      }\n+    }\n+    \n+    /**\n+     * This method is called after every method that causes a structural\n+     * modification to the backing list. It updates the local modCount field\n+     * to match that of the backing list.\n+     * Note that since this method is private, it will be inlined.\n+     */\n+    private void upMod() {\n+      this.modCount = backingList.modCount;\n+    }\n+    \n+    /**\n+     * This method checks that a value is between 0 and size (inclusive). If\n+     * it is not, an exception is thrown.\n+     * Note that since this method is private, it will be inlined.\n+     *\n+     * @exception IndexOutOfBoundsException if the value is out of range.\n+     */\n+    private void checkBoundsInclusive(int index) {\n+      if (index < 0 || index > size) {\n+\tthrow new IndexOutOfBoundsException();\n+      }\n+    }\n+    \n+    /**\n+     * This method checks that a value is between 0 (inclusive) and size\n+     * (exclusive). If it is not, an exception is thrown.\n+     * Note that since this method is private, it will be inlined.\n+     *\n+     * @exception IndexOutOfBoundsException if the value is out of range.\n+     */\n+    private void checkBoundsExclusive(int index) {\n+      if (index < 0 || index >= size) {\n+\tthrow new IndexOutOfBoundsException();\n+      }\n+    }\n+    \n+    public int size() {\n+      checkMod();\n+      return size;\n+    }\n+    \n+    public Iterator iterator() {\n+      return listIterator();\n+    }\n+    \n+    public ListIterator listIterator(final int index) {\n+      \n+      checkMod();\n+      checkBoundsInclusive(index);\n+      \n+      return new ListIterator() {\n+\tListIterator i = backingList.listIterator(index + offset);\n+\tint position = index;\n+\t\n+\tpublic boolean hasNext() {\n+\t  checkMod();\n+\t  return position < size;\n+\t}\n+\t\n+\tpublic boolean hasPrevious() {\n+\t  checkMod();\n+\t  return position > 0;\n+\t}\n+\t\n+\tpublic Object next() {\n+\t  if (position < size) {\n+\t    Object o = i.next();\n+\t    position++;\n+\t    return o;\n+\t  } else {\n+\t    throw new NoSuchElementException();\n+\t  }\n+\t}\n+\t\n+\tpublic Object previous() {\n+\t  if (position > 0) {\n+\t    Object o = i.previous();\n+\t    position--;\n+\t    return o;\n+\t  } else {\n+\t    throw new NoSuchElementException();\n+\t  }\n+\t}\n+\t\n+\tpublic int nextIndex() {\n+\t  return offset + i.nextIndex();\n+\t}\n+\t\n+\tpublic int previousIndex() {\n+\t  return offset + i.previousIndex();\n+\t}\n+\n+\tpublic void remove() {\n+\t  i.remove();\n+\t  upMod();\n+\t  size--;\n+\t  position = nextIndex();\n+\t}\n+\t\n+\tpublic void set(Object o) {\n+\t  i.set(o);\n+\t}\n+\t\n+\tpublic void add(Object o) {\n+\t  i.add(o);\n+\t  upMod();\n+\t  size++;\n+\t  position++;\n+\t}\n+\n+\t// Here is the reason why the various modCount fields are mostly\n+\t// ignored in this wrapper listIterator.\n+\t// IF the backing listIterator is failfast, then the following holds:\n+\t//   Using any other method on this list will call a corresponding\n+\t//   method on the backing list *after* the backing listIterator\n+\t//   is created, which will in turn cause a ConcurrentModException\n+\t//   when this listIterator comes to use the backing one. So it is\n+\t//   implicitly failfast.\n+\t// If the backing listIterator is NOT failfast, then the whole of\n+\t//   this list isn't failfast, because the modCount field of the\n+\t//   backing list is not valid. It would still be *possible* to\n+\t//   make the iterator failfast wrt modifications of the sublist\n+\t//   only, but somewhat pointless when the list can be changed under\n+\t//   us.\n+\t// Either way, no explicit handling of modCount is needed.\n+\t// However upMod() must be called in add and remove, and size\n+\t// must also be updated in these two methods, since they do not go\n+\t// through the corresponding methods of the subList.\n+\n+      };\n+    }\n+\n+    public Object set(int index, Object o) {\n+      checkMod();\n+      checkBoundsExclusive(index);\n+      o = backingList.set(index + offset, o);\n+      upMod();\n+      return o;\n+    }\n+    \n+    public Object get(int index) {\n+      checkMod();\n+      checkBoundsExclusive(index);\n+      return backingList.get(index + offset);\n+    }\n+\n+    public void add(int index, Object o) {\n+      checkMod();\n+      checkBoundsInclusive(index);\n+      backingList.add(index + offset, o);\n+      upMod();\n+      size++;\n+    }\n+    \n+    public Object remove(int index) {\n+      checkMod();\n+      checkBoundsExclusive(index);\n+      Object o = backingList.remove(index + offset);\n+      upMod();\n+      size--;\n+      return o;\n+    }\n+\n+    public void removeRange(int fromIndex, int toIndex) {\n+      checkMod();\n+      checkBoundsExclusive(fromIndex);\n+      checkBoundsInclusive(toIndex);\n+      \n+      // this call will catch the toIndex < fromIndex condition\n+      backingList.removeRange(offset + fromIndex, offset + toIndex);\n+      upMod();\n+      size -= toIndex - fromIndex;\n+    }\n+    \n+    public boolean addAll(int index, Collection c) {\n+      checkMod();\n+      checkBoundsInclusive(index);\n+      int s = backingList.size();\n+      boolean result = backingList.addAll(offset + index, c);\n+      upMod();\n+      size += backingList.size() - s;\n+      return result;\n+    }\n+  }\n+}"}, {"sha": "fc51d3886ea0217bc6e2e8976d532b2059d6d3b3", "filename": "libjava/java/util/Arrays.java", "status": "added", "additions": 1757, "deletions": 0, "changes": 1757, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Futil%2FArrays.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fjava%2Futil%2FArrays.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FArrays.java?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -0,0 +1,1757 @@\n+/* Arrays.java -- Utility class with methods to operate on arrays\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+// TO DO:\n+// ~ Fix the behaviour of sort and binarySearch as applied to float and double\n+//   arrays containing NaN values. See the JDC, bug ID 4143272.\n+\n+package java.util;\n+\n+/**\n+ * This class contains various static utility methods performing operations on\n+ * arrays, and a method to provide a List \"view\" of an array to facilitate\n+ * using arrays with Collection-based APIs.\n+ */\n+public class Arrays {\n+\n+  /**\n+   * This class is non-instantiable.\n+   */\n+  private Arrays() {\n+  }\n+\n+  private static Comparator defaultComparator = new Comparator() {\n+    public int compare(Object o1, Object o2) {\n+      return ((Comparable)o1).compareTo(o2);\n+    }\n+  };\n+\n+  /**\n+   * Perform a binary search of a byte array for a key. The array must be\n+   * sorted (as by the sort() method) - if it is not, the behaviour of this\n+   * method is undefined, and may be an infinite loop. If the array contains\n+   * the key more than once, any one of them may be found. Note: although the\n+   * specification allows for an infinite loop if the array is unsorted, it\n+   * will not happen in this implementation.\n+   *\n+   * @param a the array to search (must be sorted)\n+   * @param key the value to search for\n+   * @returns the index at which the key was found, or -n-1 if it was not\n+   *   found, where n is the index of the first value higher than key or\n+   *   a.length if there is no such value.\n+   */\n+  public static int binarySearch(byte[] a, byte key) {\n+    int low = 0;\n+    int hi = a.length - 1;\n+    int mid = 0;\n+    while (low <= hi) {\n+      mid = (low + hi) >> 1;\n+      final byte d = a[mid];\n+      if (d == key) {\n+        return mid;\n+      } else if (d > key) {\n+        hi = mid - 1;\n+      } else {\n+        low = ++mid; // This gets the insertion point right on the last loop\n+      }\n+    }\n+    return -mid - 1;\n+  }\n+\n+  /**\n+   * Perform a binary search of a char array for a key. The array must be\n+   * sorted (as by the sort() method) - if it is not, the behaviour of this\n+   * method is undefined, and may be an infinite loop. If the array contains\n+   * the key more than once, any one of them may be found. Note: although the\n+   * specification allows for an infinite loop if the array is unsorted, it\n+   * will not happen in this implementation.\n+   *\n+   * @param a the array to search (must be sorted)\n+   * @param key the value to search for\n+   * @returns the index at which the key was found, or -n-1 if it was not\n+   *   found, where n is the index of the first value higher than key or\n+   *   a.length if there is no such value.\n+   */\n+  public static int binarySearch(char[] a, char key) {\n+    int low = 0;\n+    int hi = a.length - 1;\n+    int mid = 0;\n+    while (low <= hi) {\n+      mid = (low + hi) >> 1;\n+      final char d = a[mid];\n+      if (d == key) {\n+        return mid;\n+      } else if (d > key) {\n+        hi = mid - 1;\n+      } else {\n+        low = ++mid; // This gets the insertion point right on the last loop\n+      }\n+    }\n+    return -mid - 1;\n+  }\n+\n+  /**\n+   * Perform a binary search of a double array for a key. The array must be\n+   * sorted (as by the sort() method) - if it is not, the behaviour of this\n+   * method is undefined, and may be an infinite loop. If the array contains\n+   * the key more than once, any one of them may be found. Note: although the\n+   * specification allows for an infinite loop if the array is unsorted, it\n+   * will not happen in this implementation.\n+   *\n+   * @param a the array to search (must be sorted)\n+   * @param key the value to search for\n+   * @returns the index at which the key was found, or -n-1 if it was not\n+   *   found, where n is the index of the first value higher than key or\n+   *   a.length if there is no such value.\n+   */\n+  public static int binarySearch(double[] a, double key) {\n+    int low = 0;\n+    int hi = a.length - 1;\n+    int mid = 0;\n+    while (low <= hi) {\n+      mid = (low + hi) >> 1;\n+      final double d = a[mid];\n+      if (d == key) {\n+        return mid;\n+      } else if (d > key) {\n+        hi = mid - 1;\n+      } else {\n+        low = ++mid; // This gets the insertion point right on the last loop\n+      }\n+    }\n+    return -mid - 1;\n+  }\n+\n+  /**\n+   * Perform a binary search of a float array for a key. The array must be\n+   * sorted (as by the sort() method) - if it is not, the behaviour of this\n+   * method is undefined, and may be an infinite loop. If the array contains\n+   * the key more than once, any one of them may be found. Note: although the\n+   * specification allows for an infinite loop if the array is unsorted, it\n+   * will not happen in this implementation.\n+   *\n+   * @param a the array to search (must be sorted)\n+   * @param key the value to search for\n+   * @returns the index at which the key was found, or -n-1 if it was not\n+   *   found, where n is the index of the first value higher than key or\n+   *   a.length if there is no such value.\n+   */\n+  public static int binarySearch(float[] a, float key) {\n+    int low = 0;\n+    int hi = a.length - 1;\n+    int mid = 0;\n+    while (low <= hi) {\n+      mid = (low + hi) >> 1;\n+      final float d = a[mid];\n+      if (d == key) {\n+        return mid;\n+      } else if (d > key) {\n+        hi = mid - 1;\n+      } else {\n+        low = ++mid; // This gets the insertion point right on the last loop\n+      }\n+    }\n+    return -mid - 1;\n+  }\n+\n+  /**\n+   * Perform a binary search of an int array for a key. The array must be\n+   * sorted (as by the sort() method) - if it is not, the behaviour of this\n+   * method is undefined, and may be an infinite loop. If the array contains\n+   * the key more than once, any one of them may be found. Note: although the\n+   * specification allows for an infinite loop if the array is unsorted, it\n+   * will not happen in this implementation.\n+   *\n+   * @param a the array to search (must be sorted)\n+   * @param key the value to search for\n+   * @returns the index at which the key was found, or -n-1 if it was not\n+   *   found, where n is the index of the first value higher than key or\n+   *   a.length if there is no such value.\n+   */\n+  public static int binarySearch(int[] a, int key) {\n+    int low = 0;\n+    int hi = a.length - 1;\n+    int mid = 0;\n+    while (low <= hi) {\n+      mid = (low + hi) >> 1;\n+      final int d = a[mid];\n+      if (d == key) {\n+        return mid;\n+      } else if (d > key) {\n+        hi = mid - 1;\n+      } else {\n+        low = ++mid; // This gets the insertion point right on the last loop\n+      }\n+    }\n+    return -mid - 1;\n+  }\n+\n+  /**\n+   * Perform a binary search of a long array for a key. The array must be\n+   * sorted (as by the sort() method) - if it is not, the behaviour of this\n+   * method is undefined, and may be an infinite loop. If the array contains\n+   * the key more than once, any one of them may be found. Note: although the\n+   * specification allows for an infinite loop if the array is unsorted, it\n+   * will not happen in this implementation.\n+   *\n+   * @param a the array to search (must be sorted)\n+   * @param key the value to search for\n+   * @returns the index at which the key was found, or -n-1 if it was not\n+   *   found, where n is the index of the first value higher than key or\n+   *   a.length if there is no such value.\n+   */\n+  public static int binarySearch(long[] a, long key) {\n+    int low = 0;\n+    int hi = a.length - 1;\n+    int mid = 0;\n+    while (low <= hi) {\n+      mid = (low + hi) >> 1;\n+      final long d = a[mid];\n+      if (d == key) {\n+        return mid;\n+      } else if (d > key) {\n+        hi = mid - 1;\n+      } else {\n+        low = ++mid; // This gets the insertion point right on the last loop\n+      }\n+    }\n+    return -mid - 1;\n+  }\n+\n+  /**\n+   * Perform a binary search of a short array for a key. The array must be\n+   * sorted (as by the sort() method) - if it is not, the behaviour of this\n+   * method is undefined, and may be an infinite loop. If the array contains\n+   * the key more than once, any one of them may be found. Note: although the\n+   * specification allows for an infinite loop if the array is unsorted, it\n+   * will not happen in this implementation.\n+   *\n+   * @param a the array to search (must be sorted)\n+   * @param key the value to search for\n+   * @returns the index at which the key was found, or -n-1 if it was not\n+   *   found, where n is the index of the first value higher than key or\n+   *   a.length if there is no such value.\n+   */\n+  public static int binarySearch(short[] a, short key) {\n+    int low = 0;\n+    int hi = a.length - 1;\n+    int mid = 0;\n+    while (low <= hi) {\n+      mid = (low + hi) >> 1;\n+      final short d = a[mid];\n+      if (d == key) {\n+        return mid;\n+      } else if (d > key) {\n+        hi = mid - 1;\n+      } else {\n+        low = ++mid; // This gets the insertion point right on the last loop\n+      }\n+    }\n+    return -mid - 1;\n+  }\n+\n+  /**\n+   * This method does the work for the Object binary search methods. \n+   * @exception NullPointerException if the specified comparator is null.\n+   * @exception ClassCastException if the objects are not comparable by c.\n+   */\n+  private static int objectSearch(Object[] a, Object key, final Comparator c) {\n+    int low = 0;\n+    int hi = a.length - 1;\n+    int mid = 0;\n+    while (low <= hi) {\n+      mid = (low + hi) >> 1;\n+      final int d = c.compare(key, a[mid]);\n+      if (d == 0) {\n+        return mid;\n+      } else if (d < 0) {\n+        hi = mid - 1;\n+      } else {\n+        low = ++mid; // This gets the insertion point right on the last loop\n+      }\n+    }\n+    return -mid - 1;\n+  }\n+\n+  /**\n+   * Perform a binary search of an Object array for a key, using the natural\n+   * ordering of the elements. The array must be sorted (as by the sort()\n+   * method) - if it is not, the behaviour of this method is undefined, and may\n+   * be an infinite loop. Further, the key must be comparable with every item\n+   * in the array. If the array contains the key more than once, any one of\n+   * them may be found. Note: although the specification allows for an infinite\n+   * loop if the array is unsorted, it will not happen in this (JCL)\n+   * implementation.\n+   *\n+   * @param a the array to search (must be sorted)\n+   * @param key the value to search for\n+   * @returns the index at which the key was found, or -n-1 if it was not\n+   *   found, where n is the index of the first value higher than key or\n+   *   a.length if there is no such value.\n+   * @exception ClassCastException if key could not be compared with one of the\n+   *   elements of a\n+   * @exception NullPointerException if a null element has compareTo called\n+   */\n+  public static int binarySearch(Object[] a, Object key) {\n+    return objectSearch(a, key, defaultComparator);\n+  }\n+\n+  /**\n+   * Perform a binary search of an Object array for a key, using a supplied\n+   * Comparator. The array must be sorted (as by the sort() method with the\n+   * same Comparator) - if it is not, the behaviour of this method is\n+   * undefined, and may be an infinite loop. Further, the key must be\n+   * comparable with every item in the array. If the array contains the key\n+   * more than once, any one of them may be found. Note: although the\n+   * specification allows for an infinite loop if the array is unsorted, it\n+   * will not happen in this (JCL) implementation.\n+   *\n+   * @param a the array to search (must be sorted)\n+   * @param key the value to search for\n+   * @param c the comparator by which the array is sorted\n+   * @returns the index at which the key was found, or -n-1 if it was not\n+   *   found, where n is the index of the first value higher than key or\n+   *   a.length if there is no such value.\n+   * @exception ClassCastException if key could not be compared with one of the\n+   *   elements of a\n+   */\n+  public static int binarySearch(Object[] a, Object key, Comparator c) {\n+    return objectSearch(a, key, c);\n+  }\n+\n+  /**\n+   * Compare two byte arrays for equality.\n+   *\n+   * @param a1 the first array to compare\n+   * @param a2 the second array to compare\n+   * @returns true if a1 and a2 are both null, or if a2 is of the same length\n+   *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n+   */\n+  public static boolean equals(byte[] a1, byte[] a2) {\n+\n+    // Quick test which saves comparing elements of the same array, and also\n+    // catches the case that both are null.\n+    if (a1 == a2) {\n+      return true;\n+    }\n+    try {\n+\n+      // If they're the same length, test each element\n+      if (a1.length == a2.length) {\n+        for (int i = 0; i < a1.length; i++) {\n+          if (a1[i] != a2[i]) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      }\n+\n+    // If a1 == null or a2 == null but not both then we will get a NullPointer\n+    } catch (NullPointerException e) {\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Compare two char arrays for equality.\n+   *\n+   * @param a1 the first array to compare\n+   * @param a2 the second array to compare\n+   * @returns true if a1 and a2 are both null, or if a2 is of the same length\n+   *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n+   */\n+  public static boolean equals(char[] a1, char[] a2) {\n+\n+    // Quick test which saves comparing elements of the same array, and also\n+    // catches the case that both are null.\n+    if (a1 == a2) {\n+      return true;\n+    }\n+    try {\n+\n+      // If they're the same length, test each element\n+      if (a1.length == a2.length) {\n+        for (int i = 0; i < a1.length; i++) {\n+          if (a1[i] != a2[i]) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      }\n+\n+    // If a1 == null or a2 == null but not both then we will get a NullPointer\n+    } catch (NullPointerException e) {\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Compare two double arrays for equality.\n+   *\n+   * @param a1 the first array to compare\n+   * @param a2 the second array to compare\n+   * @returns true if a1 and a2 are both null, or if a2 is of the same length\n+   *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n+   */\n+  public static boolean equals(double[] a1, double[] a2) {\n+\n+    // Quick test which saves comparing elements of the same array, and also\n+    // catches the case that both are null.\n+    if (a1 == a2) {\n+      return true;\n+    }\n+    try {\n+\n+      // If they're the same length, test each element\n+      if (a1.length == a2.length) {\n+        for (int i = 0; i < a1.length; i++) {\n+          if (a1[i] != a2[i]) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      }\n+\n+    // If a1 == null or a2 == null but not both then we will get a NullPointer\n+    } catch (NullPointerException e) {\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Compare two float arrays for equality.\n+   *\n+   * @param a1 the first array to compare\n+   * @param a2 the second array to compare\n+   * @returns true if a1 and a2 are both null, or if a2 is of the same length\n+   *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n+   */\n+  public static boolean equals(float[] a1, float[] a2) {\n+\n+    // Quick test which saves comparing elements of the same array, and also\n+    // catches the case that both are null.\n+    if (a1 == a2) {\n+      return true;\n+    }\n+    try {\n+\n+      // If they're the same length, test each element\n+      if (a1.length == a2.length) {\n+        for (int i = 0; i < a1.length; i++) {\n+          if (a1[i] != a2[i]) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      }\n+\n+    // If a1 == null or a2 == null but not both then we will get a NullPointer\n+    } catch (NullPointerException e) {\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Compare two long arrays for equality.\n+   *\n+   * @param a1 the first array to compare\n+   * @param a2 the second array to compare\n+   * @returns true if a1 and a2 are both null, or if a2 is of the same length\n+   *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n+   */\n+  public static boolean equals(long[] a1, long[] a2) {\n+\n+    // Quick test which saves comparing elements of the same array, and also\n+    // catches the case that both are null.\n+    if (a1 == a2) {\n+      return true;\n+    }\n+    try {\n+\n+      // If they're the same length, test each element\n+      if (a1.length == a2.length) {\n+        for (int i = 0; i < a1.length; i++) {\n+          if (a1[i] != a2[i]) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      }\n+\n+    // If a1 == null or a2 == null but not both then we will get a NullPointer\n+    } catch (NullPointerException e) {\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Compare two short arrays for equality.\n+   *\n+   * @param a1 the first array to compare\n+   * @param a2 the second array to compare\n+   * @returns true if a1 and a2 are both null, or if a2 is of the same length\n+   *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n+   */\n+  public static boolean equals(short[] a1, short[] a2) {\n+\n+    // Quick test which saves comparing elements of the same array, and also\n+    // catches the case that both are null.\n+    if (a1 == a2) {\n+      return true;\n+    }\n+    try {\n+\n+      // If they're the same length, test each element\n+      if (a1.length == a2.length) {\n+        for (int i = 0; i < a1.length; i++) {\n+          if (a1[i] != a2[i]) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      }\n+\n+    // If a1 == null or a2 == null but not both then we will get a NullPointer\n+    } catch (NullPointerException e) {\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Compare two boolean arrays for equality.\n+   *\n+   * @param a1 the first array to compare\n+   * @param a2 the second array to compare\n+   * @returns true if a1 and a2 are both null, or if a2 is of the same length\n+   *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n+   */\n+  public static boolean equals(boolean[] a1, boolean[] a2) {\n+\n+    // Quick test which saves comparing elements of the same array, and also\n+    // catches the case that both are null.\n+    if (a1 == a2) {\n+      return true;\n+    }\n+    try {\n+\n+      // If they're the same length, test each element\n+      if (a1.length == a2.length) {\n+        for (int i = 0; i < a1.length; i++) {\n+          if (a1[i] != a2[i]) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      }\n+\n+    // If a1 == null or a2 == null but not both then we will get a NullPointer\n+    } catch (NullPointerException e) {\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Compare two int arrays for equality.\n+   *\n+   * @param a1 the first array to compare\n+   * @param a2 the second array to compare\n+   * @returns true if a1 and a2 are both null, or if a2 is of the same length\n+   *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n+   */\n+  public static boolean equals(int[] a1, int[] a2) {\n+\n+    // Quick test which saves comparing elements of the same array, and also\n+    // catches the case that both are null.\n+    if (a1 == a2) {\n+      return true;\n+    }\n+    try {\n+\n+      // If they're the same length, test each element\n+      if (a1.length == a2.length) {\n+        for (int i = 0; i < a1.length; i++) {\n+          if (a1[i] != a2[i]) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      }\n+\n+    // If a1 == null or a2 == null but not both then we will get a NullPointer\n+    } catch (NullPointerException e) {\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Compare two Object arrays for equality.\n+   *\n+   * @param a1 the first array to compare\n+   * @param a2 the second array to compare\n+   * @returns true if a1 and a2 are both null, or if a1 is of the same length\n+   *   as a2, and for each 0 <= i < a.length, a1[i] == null ? a2[i] == null :\n+   *   a1[i].equals(a2[i]).\n+   */\n+  public static boolean equals(Object[] a1, Object[] a2) {\n+\n+    // Quick test which saves comparing elements of the same array, and also\n+    // catches the case that both are null.\n+    if (a1 == a2) {\n+      return true;\n+    }\n+    try {\n+\n+      // If they're the same length, test each element\n+      if (a1.length == a2.length) {\n+        for (int i = 0; i < a1.length; i++) {\n+          if (!(a1[i] == null ? a2[i] == null : a1[i].equals(a2[i]))) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      }\n+\n+    // If a1 == null or a2 == null but not both then we will get a NullPointer\n+    } catch (NullPointerException e) {\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Fill an array with a boolean value.\n+   *\n+   * @param a the array to fill\n+   * @param val the value to fill it with\n+   */\n+  public static void fill(boolean[] a, boolean val) {\n+    // This implementation is slightly inefficient timewise, but the extra\n+    // effort over inlining it is O(1) and small, and I refuse to repeat code\n+    // if it can be helped.\n+    fill(a, 0, a.length, val);\n+  }\n+\n+  /**\n+   * Fill a range of an array with a boolean value.\n+   *\n+   * @param a the array to fill\n+   * @param fromIndex the index to fill from, inclusive\n+   * @param toIndex the index to fill to, exclusive\n+   * @param val the value to fill with\n+   */\n+  public static void fill(boolean[] a, int fromIndex, int toIndex,\n+                          boolean val) {\n+    for (int i = fromIndex; i < toIndex; i++) {\n+      a[i] = val;\n+    }\n+  }\n+\n+  /**\n+   * Fill an array with a byte value.\n+   *\n+   * @param a the array to fill\n+   * @param val the value to fill it with\n+   */\n+  public static void fill(byte[] a, byte val) {\n+    // This implementation is slightly inefficient timewise, but the extra\n+    // effort over inlining it is O(1) and small, and I refuse to repeat code\n+    // if it can be helped.\n+    fill(a, 0, a.length, val);\n+  }\n+\n+  /**\n+   * Fill a range of an array with a byte value.\n+   *\n+   * @param a the array to fill\n+   * @param fromIndex the index to fill from, inclusive\n+   * @param toIndex the index to fill to, exclusive\n+   * @param val the value to fill with\n+   */\n+  public static void fill(byte[] a, int fromIndex, int toIndex, byte val) {\n+    for (int i = fromIndex; i < toIndex; i++) {\n+      a[i] = val;\n+    }\n+  }\n+\n+  /**\n+   * Fill an array with a char value.\n+   *\n+   * @param a the array to fill\n+   * @param val the value to fill it with\n+   */\n+  public static void fill(char[] a, char val) {\n+    // This implementation is slightly inefficient timewise, but the extra\n+    // effort over inlining it is O(1) and small, and I refuse to repeat code\n+    // if it can be helped.\n+    fill(a, 0, a.length, val);\n+  }\n+\n+  /**\n+   * Fill a range of an array with a char value.\n+   *\n+   * @param a the array to fill\n+   * @param fromIndex the index to fill from, inclusive\n+   * @param toIndex the index to fill to, exclusive\n+   * @param val the value to fill with\n+   */\n+  public static void fill(char[] a, int fromIndex, int toIndex, char val) {\n+    for (int i = fromIndex; i < toIndex; i++) {\n+      a[i] = val;\n+    }\n+  }\n+\n+  /**\n+   * Fill an array with a double value.\n+   *\n+   * @param a the array to fill\n+   * @param val the value to fill it with\n+   */\n+  public static void fill(double[] a, double val) {\n+    // This implementation is slightly inefficient timewise, but the extra\n+    // effort over inlining it is O(1) and small, and I refuse to repeat code\n+    // if it can be helped.\n+    fill(a, 0, a.length, val);\n+  }\n+\n+  /**\n+   * Fill a range of an array with a double value.\n+   *\n+   * @param a the array to fill\n+   * @param fromIndex the index to fill from, inclusive\n+   * @param toIndex the index to fill to, exclusive\n+   * @param val the value to fill with\n+   */\n+  public static void fill(double[] a, int fromIndex, int toIndex, double val) {\n+    for (int i = fromIndex; i < toIndex; i++) {\n+      a[i] = val;\n+    }\n+  }\n+\n+  /**\n+   * Fill an array with a float value.\n+   *\n+   * @param a the array to fill\n+   * @param val the value to fill it with\n+   */\n+  public static void fill(float[] a, float val) {\n+    // This implementation is slightly inefficient timewise, but the extra\n+    // effort over inlining it is O(1) and small, and I refuse to repeat code\n+    // if it can be helped.\n+    fill(a, 0, a.length, val);\n+  }\n+\n+  /**\n+   * Fill a range of an array with a float value.\n+   *\n+   * @param a the array to fill\n+   * @param fromIndex the index to fill from, inclusive\n+   * @param toIndex the index to fill to, exclusive\n+   * @param val the value to fill with\n+   */\n+  public static void fill(float[] a, int fromIndex, int toIndex, float val) {\n+    for (int i = fromIndex; i < toIndex; i++) {\n+      a[i] = val;\n+    }\n+  }\n+\n+  /**\n+   * Fill an array with an int value.\n+   *\n+   * @param a the array to fill\n+   * @param val the value to fill it with\n+   */\n+  public static void fill(int[] a, int val) {\n+    // This implementation is slightly inefficient timewise, but the extra\n+    // effort over inlining it is O(1) and small, and I refuse to repeat code\n+    // if it can be helped.\n+    fill(a, 0, a.length, val);\n+  }\n+\n+  /**\n+   * Fill a range of an array with an int value.\n+   *\n+   * @param a the array to fill\n+   * @param fromIndex the index to fill from, inclusive\n+   * @param toIndex the index to fill to, exclusive\n+   * @param val the value to fill with\n+   */\n+  public static void fill(int[] a, int fromIndex, int toIndex, int val) {\n+    for (int i = fromIndex; i < toIndex; i++) {\n+      a[i] = val;\n+    }\n+  }\n+\n+  /**\n+   * Fill an array with a long value.\n+   *\n+   * @param a the array to fill\n+   * @param val the value to fill it with\n+   */\n+  public static void fill(long[] a, long val) {\n+    // This implementation is slightly inefficient timewise, but the extra\n+    // effort over inlining it is O(1) and small, and I refuse to repeat code\n+    // if it can be helped.\n+    fill(a, 0, a.length, val);\n+  }\n+\n+  /**\n+   * Fill a range of an array with a long value.\n+   *\n+   * @param a the array to fill\n+   * @param fromIndex the index to fill from, inclusive\n+   * @param toIndex the index to fill to, exclusive\n+   * @param val the value to fill with\n+   */\n+  public static void fill(long[] a, int fromIndex, int toIndex, long val) {\n+    for (int i = fromIndex; i < toIndex; i++) {\n+      a[i] = val;\n+    }\n+  }\n+\n+  /**\n+   * Fill an array with a short value.\n+   *\n+   * @param a the array to fill\n+   * @param val the value to fill it with\n+   */\n+  public static void fill(short[] a, short val) {\n+    // This implementation is slightly inefficient timewise, but the extra\n+    // effort over inlining it is O(1) and small, and I refuse to repeat code\n+    // if it can be helped.\n+    fill(a, 0, a.length, val);\n+  }\n+\n+  /**\n+   * Fill a range of an array with a short value.\n+   *\n+   * @param a the array to fill\n+   * @param fromIndex the index to fill from, inclusive\n+   * @param toIndex the index to fill to, exclusive\n+   * @param val the value to fill with\n+   */\n+  public static void fill(short[] a, int fromIndex, int toIndex, short val) {\n+    for (int i = fromIndex; i < toIndex; i++) {\n+      a[i] = val;\n+    }\n+  }\n+\n+  /**\n+   * Fill an array with an Object value.\n+   *\n+   * @param a the array to fill\n+   * @param val the value to fill it with\n+   * @exception ClassCastException if val is not an instance of the element\n+   *   type of a.\n+   */\n+  public static void fill(Object[] a, Object val) {\n+    // This implementation is slightly inefficient timewise, but the extra\n+    // effort over inlining it is O(1) and small, and I refuse to repeat code\n+    // if it can be helped.\n+    fill(a, 0, a.length, val);\n+  }\n+\n+  /**\n+   * Fill a range of an array with an Object value.\n+   *\n+   * @param a the array to fill\n+   * @param fromIndex the index to fill from, inclusive\n+   * @param toIndex the index to fill to, exclusive\n+   * @param val the value to fill with\n+   * @exception ClassCastException if val is not an instance of the element\n+   *   type of a.\n+   */\n+  public static void fill(Object[] a, int fromIndex, int toIndex, Object val) {\n+    for (int i = fromIndex; i < toIndex; i++) {\n+      a[i] = val;\n+    }\n+  }\n+\n+  // Thanks to Paul Fisher <rao@gnu.org> for finding this quicksort algorithm\n+  // as specified by Sun and porting it to Java.\n+\n+  /**\n+   * Sort a byte array into ascending order. The sort algorithm is an optimised\n+   * quicksort, as described in Jon L. Bentley and M. Douglas McIlroy's\n+   * \"Engineering a Sort Function\", Software-Practice and Experience, Vol.\n+   * 23(11) P. 1249-1265 (November 1993). This algorithm gives nlog(n)\n+   * performance on many arrays that would take quadratic time with a standard\n+   * quicksort.\n+   *\n+   * @param a the array to sort\n+   */\n+  public static void sort(byte[] a) {\n+    qsort(a, 0, a.length);\n+  }\n+\n+  private static short cmp(byte i, byte j) {\n+    return (short)(i-j);\n+  }\n+\n+  private static int med3(int a, int b, int c, byte[] d) {\n+    return cmp(d[a], d[b]) < 0 ? \n+      (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n+    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+  }\n+  \n+  private static void swap(int i, int j, byte[] a) {\n+    byte c = a[i];\n+    a[i] = a[j];\n+    a[j] = c;\n+  }\n+\n+  private static void qsort(byte[] a, int start, int n) {\n+    // use an insertion sort on small arrays\n+    if (n < 7) {\n+      for (int i = start + 1; i < start + n; i++)\n+        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n+          swap(j, j-1, a);\n+      return;\n+    }\n+\n+    int pm = n/2;       // small arrays, middle element\n+    if (n > 7) {\n+      int pl = start;\n+      int pn = start + n-1;\n+\n+      if (n > 40) {     // big arrays, pseudomedian of 9\n+        int s = n/8;\n+        pl = med3(pl, pl+s, pl+2*s, a);\n+        pm = med3(pm-s, pm, pm+s, a);\n+        pn = med3(pn-2*s, pn-s, pn, a);\n+      }\n+      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n+    }\n+\n+    int pa, pb, pc, pd, pv;\n+    short r;\n+\n+    pv = start; swap(pv, pm, a);\n+    pa = pb = start;\n+    pc = pd = start + n-1;\n+    \n+    for (;;) {\n+      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n+        if (r == 0) { swap(pa, pb, a); pa++; }\n+        pb++;\n+      }\n+      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n+        if (r == 0) { swap(pc, pd, a); pd--; }\n+        pc--;\n+      }\n+      if (pb > pc) break;\n+      swap(pb, pc, a);\n+      pb++;\n+      pc--;\n+    }\n+    int pn = start + n;\n+    int s;\n+    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n+    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n+    if ((s = pb-pa) > 1) qsort(a, start, s);\n+    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+  }\n+\n+  private static void vecswap(int i, int j, int n, byte[] a) {\n+    for (; n > 0; i++, j++, n--)\n+      swap(i, j, a);\n+  }\n+\n+  /**\n+   * Sort a char array into ascending order. The sort algorithm is an optimised\n+   * quicksort, as described in Jon L. Bentley and M. Douglas McIlroy's\n+   * \"Engineering a Sort Function\", Software-Practice and Experience, Vol.\n+   * 23(11) P. 1249-1265 (November 1993). This algorithm gives nlog(n)\n+   * performance on many arrays that would take quadratic time with a standard\n+   * quicksort.\n+   *\n+   * @param a the array to sort\n+   */\n+  public static void sort(char[] a) {\n+    qsort(a, 0, a.length);\n+  }\n+\n+  private static int cmp(char i, char j) {\n+    return i-j;\n+  }\n+\n+  private static int med3(int a, int b, int c, char[] d) {\n+    return cmp(d[a], d[b]) < 0 ? \n+      (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n+    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+  }\n+  \n+  private static void swap(int i, int j, char[] a) {\n+    char c = a[i];\n+    a[i] = a[j];\n+    a[j] = c;\n+  }\n+\n+  private static void qsort(char[] a, int start, int n) {\n+    // use an insertion sort on small arrays\n+    if (n < 7) {\n+      for (int i = start + 1; i < start + n; i++)\n+        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n+          swap(j, j-1, a);\n+      return;\n+    }\n+\n+    int pm = n/2;       // small arrays, middle element\n+    if (n > 7) {\n+      int pl = start;\n+      int pn = start + n-1;\n+\n+      if (n > 40) {     // big arrays, pseudomedian of 9\n+        int s = n/8;\n+        pl = med3(pl, pl+s, pl+2*s, a);\n+        pm = med3(pm-s, pm, pm+s, a);\n+        pn = med3(pn-2*s, pn-s, pn, a);\n+      }\n+      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n+    }\n+\n+    int pa, pb, pc, pd, pv;\n+    int r;\n+\n+    pv = start; swap(pv, pm, a);\n+    pa = pb = start;\n+    pc = pd = start + n-1;\n+    \n+    for (;;) {\n+      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n+        if (r == 0) { swap(pa, pb, a); pa++; }\n+        pb++;\n+      }\n+      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n+        if (r == 0) { swap(pc, pd, a); pd--; }\n+        pc--;\n+      }\n+      if (pb > pc) break;\n+      swap(pb, pc, a);\n+      pb++;\n+      pc--;\n+    }\n+    int pn = start + n;\n+    int s;\n+    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n+    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n+    if ((s = pb-pa) > 1) qsort(a, start, s);\n+    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+  }\n+\n+  private static void vecswap(int i, int j, int n, char[] a) {\n+    for (; n > 0; i++, j++, n--)\n+      swap(i, j, a);\n+  }\n+\n+  /**\n+   * Sort a double array into ascending order. The sort algorithm is an\n+   * optimised quicksort, as described in Jon L. Bentley and M. Douglas\n+   * McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience,\n+   * Vol. 23(11) P. 1249-1265 (November 1993). This algorithm gives nlog(n)\n+   * performance on many arrays that would take quadratic time with a standard\n+   * quicksort. Note that this implementation, like Sun's, has undefined\n+   * behaviour if the array contains any NaN values.\n+   *\n+   * @param a the array to sort\n+   */\n+  public static void sort(double[] a) {\n+    qsort(a, 0, a.length);\n+  }\n+\n+  private static double cmp(double i, double j) {\n+    return i-j;\n+  }\n+\n+  private static int med3(int a, int b, int c, double[] d) {\n+    return cmp(d[a], d[b]) < 0 ? \n+      (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n+    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+  }\n+  \n+  private static void swap(int i, int j, double[] a) {\n+    double c = a[i];\n+    a[i] = a[j];\n+    a[j] = c;\n+  }\n+\n+  private static void qsort(double[] a, int start, int n) {\n+    // use an insertion sort on small arrays\n+    if (n < 7) {\n+      for (int i = start + 1; i < start + n; i++)\n+        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n+          swap(j, j-1, a);\n+      return;\n+    }\n+\n+    int pm = n/2;       // small arrays, middle element\n+    if (n > 7) {\n+      int pl = start;\n+      int pn = start + n-1;\n+\n+      if (n > 40) {     // big arrays, pseudomedian of 9\n+        int s = n/8;\n+        pl = med3(pl, pl+s, pl+2*s, a);\n+        pm = med3(pm-s, pm, pm+s, a);\n+        pn = med3(pn-2*s, pn-s, pn, a);\n+      }\n+      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n+    }\n+\n+    int pa, pb, pc, pd, pv;\n+    double r;\n+\n+    pv = start; swap(pv, pm, a);\n+    pa = pb = start;\n+    pc = pd = start + n-1;\n+    \n+    for (;;) {\n+      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n+        if (r == 0) { swap(pa, pb, a); pa++; }\n+        pb++;\n+      }\n+      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n+        if (r == 0) { swap(pc, pd, a); pd--; }\n+        pc--;\n+      }\n+      if (pb > pc) break;\n+      swap(pb, pc, a);\n+      pb++;\n+      pc--;\n+    }\n+    int pn = start + n;\n+    int s;\n+    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n+    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n+    if ((s = pb-pa) > 1) qsort(a, start, s);\n+    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+  }\n+\n+  private static void vecswap(int i, int j, int n, double[] a) {\n+    for (; n > 0; i++, j++, n--)\n+      swap(i, j, a);\n+  }\n+\n+  /**\n+   * Sort a float array into ascending order. The sort algorithm is an\n+   * optimised quicksort, as described in Jon L. Bentley and M. Douglas\n+   * McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience,\n+   * Vol. 23(11) P. 1249-1265 (November 1993). This algorithm gives nlog(n)\n+   * performance on many arrays that would take quadratic time with a standard\n+   * quicksort. Note that this implementation, like Sun's, has undefined\n+   * behaviour if the array contains any NaN values.\n+   *\n+   * @param a the array to sort\n+   */\n+  public static void sort(float[] a) {\n+    qsort(a, 0, a.length);\n+  }\n+\n+  private static float cmp(float i, float j) {\n+    return i-j;\n+  }\n+\n+  private static int med3(int a, int b, int c, float[] d) {\n+    return cmp(d[a], d[b]) < 0 ? \n+      (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n+    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+  }\n+\n+  private static void swap(int i, int j, float[] a) {\n+    float c = a[i];\n+    a[i] = a[j];\n+    a[j] = c;\n+  }\n+\n+  private static void qsort(float[] a, int start, int n) {\n+    // use an insertion sort on small arrays\n+    if (n < 7) {\n+      for (int i = start + 1; i < start + n; i++)\n+        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n+          swap(j, j-1, a);\n+      return;\n+    }\n+\n+    int pm = n/2;       // small arrays, middle element\n+    if (n > 7) {\n+      int pl = start;\n+      int pn = start + n-1;\n+\n+      if (n > 40) {     // big arrays, pseudomedian of 9\n+        int s = n/8;\n+        pl = med3(pl, pl+s, pl+2*s, a);\n+        pm = med3(pm-s, pm, pm+s, a);\n+        pn = med3(pn-2*s, pn-s, pn, a);\n+      }\n+      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n+    }\n+\n+    int pa, pb, pc, pd, pv;\n+    float r;\n+\n+    pv = start; swap(pv, pm, a);\n+    pa = pb = start;\n+    pc = pd = start + n-1;\n+    \n+    for (;;) {\n+      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n+        if (r == 0) { swap(pa, pb, a); pa++; }\n+        pb++;\n+      }\n+      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n+        if (r == 0) { swap(pc, pd, a); pd--; }\n+        pc--;\n+      }\n+      if (pb > pc) break;\n+      swap(pb, pc, a);\n+      pb++;\n+      pc--;\n+    }\n+    int pn = start + n;\n+    int s;\n+    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n+    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n+    if ((s = pb-pa) > 1) qsort(a, start, s);\n+    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+  }\n+\n+  private static void vecswap(int i, int j, int n, float[] a) {\n+    for (; n > 0; i++, j++, n--)\n+      swap(i, j, a);\n+  }\n+\n+  /**\n+   * Sort an int array into ascending order. The sort algorithm is an optimised\n+   * quicksort, as described in Jon L. Bentley and M. Douglas McIlroy's\n+   * \"Engineering a Sort Function\", Software-Practice and Experience, Vol.\n+   * 23(11) P. 1249-1265 (November 1993). This algorithm gives nlog(n)\n+   * performance on many arrays that would take quadratic time with a standard\n+   * quicksort.\n+   *\n+   * @param a the array to sort\n+   */\n+  public static void sort(int[] a) {\n+    qsort(a, 0, a.length);\n+  }\n+\n+  private static long cmp(int i, int j) {\n+    return (long)i-(long)j;\n+  }\n+\n+  private static int med3(int a, int b, int c, int[] d) {\n+    return cmp(d[a], d[b]) < 0 ? \n+      (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n+    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+  }\n+  \n+  private static void swap(int i, int j, int[] a) {\n+    int c = a[i];\n+    a[i] = a[j];\n+    a[j] = c;\n+  }\n+\n+  private static void qsort(int[] a, int start, int n) {\n+    // use an insertion sort on small arrays\n+    if (n < 7) {\n+      for (int i = start + 1; i < start + n; i++)\n+        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n+          swap(j, j-1, a);\n+      return;\n+    }\n+\n+    int pm = n/2;       // small arrays, middle element\n+    if (n > 7) {\n+      int pl = start;\n+      int pn = start + n-1;\n+\n+      if (n > 40) {     // big arrays, pseudomedian of 9\n+        int s = n/8;\n+        pl = med3(pl, pl+s, pl+2*s, a);\n+        pm = med3(pm-s, pm, pm+s, a);\n+        pn = med3(pn-2*s, pn-s, pn, a);\n+      }\n+      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n+    }\n+\n+    int pa, pb, pc, pd, pv;\n+    long r;\n+\n+    pv = start; swap(pv, pm, a);\n+    pa = pb = start;\n+    pc = pd = start + n-1;\n+    \n+    for (;;) {\n+      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n+        if (r == 0) { swap(pa, pb, a); pa++; }\n+        pb++;\n+      }\n+      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n+        if (r == 0) { swap(pc, pd, a); pd--; }\n+        pc--;\n+      }\n+      if (pb > pc) break;\n+      swap(pb, pc, a);\n+      pb++;\n+      pc--;\n+    }\n+    int pn = start + n;\n+    int s;\n+    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n+    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n+    if ((s = pb-pa) > 1) qsort(a, start, s);\n+    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+  }\n+\n+  private static void vecswap(int i, int j, int n, int[] a) {\n+    for (; n > 0; i++, j++, n--)\n+      swap(i, j, a);\n+  }\n+\n+  /**\n+   * Sort a long array into ascending order. The sort algorithm is an optimised\n+   * quicksort, as described in Jon L. Bentley and M. Douglas McIlroy's\n+   * \"Engineering a Sort Function\", Software-Practice and Experience, Vol.\n+   * 23(11) P. 1249-1265 (November 1993). This algorithm gives nlog(n)\n+   * performance on many arrays that would take quadratic time with a standard\n+   * quicksort.\n+   *\n+   * @param a the array to sort\n+   */\n+  public static void sort(long[] a) {\n+    qsort(a, 0, a.length);\n+  }\n+\n+  // The \"cmp\" method has been removed from here and replaced with direct\n+  // compares in situ, to avoid problems with overflow if the difference\n+  // between two numbers is bigger than a long will hold.\n+  // One particular change as a result is the use of r1 and r2 in qsort\n+\n+  private static int med3(int a, int b, int c, long[] d) {\n+    return d[a] < d[b] ? \n+      (d[b] < d[c] ? b : d[a] < d[c] ? c : a)\n+    : (d[b] > d[c] ? b : d[a] > d[c] ? c : a);\n+  }\n+  \n+  private static void swap(int i, int j, long[] a) {\n+    long c = a[i];\n+    a[i] = a[j];\n+    a[j] = c;\n+  }\n+\n+  private static void qsort(long[] a, int start, int n) {\n+    // use an insertion sort on small arrays\n+    if (n < 7) {\n+      for (int i = start + 1; i < start + n; i++)\n+        for (int j = i; j > 0 && a[j-1] > a[j]; j--)\n+          swap(j, j-1, a);\n+      return;\n+    }\n+\n+    int pm = n/2;       // small arrays, middle element\n+    if (n > 7) {\n+      int pl = start;\n+      int pn = start + n-1;\n+\n+      if (n > 40) {     // big arrays, pseudomedian of 9\n+        int s = n/8;\n+        pl = med3(pl, pl+s, pl+2*s, a);\n+        pm = med3(pm-s, pm, pm+s, a);\n+        pn = med3(pn-2*s, pn-s, pn, a);\n+      }\n+      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n+    }\n+\n+    int pa, pb, pc, pd, pv;\n+    long r1, r2;\n+\n+    pv = start; swap(pv, pm, a);\n+    pa = pb = start;\n+    pc = pd = start + n-1;\n+    \n+    for (;;) {\n+      while (pb <= pc && (r1 = a[pb]) <= (r2 = a[pv])) {\n+        if (r1 == r2) { swap(pa, pb, a); pa++; }\n+        pb++;\n+      }\n+      while (pc >= pb && (r1 = a[pc]) >= (r2 = a[pv])) {\n+        if (r1 == r2) { swap(pc, pd, a); pd--; }\n+        pc--;\n+      }\n+      if (pb > pc) break;\n+      swap(pb, pc, a);\n+      pb++;\n+      pc--;\n+    }\n+    int pn = start + n;\n+    int s;\n+    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n+    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n+    if ((s = pb-pa) > 1) qsort(a, start, s);\n+    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+  }\n+\n+  private static void vecswap(int i, int j, int n, long[] a) {\n+    for (; n > 0; i++, j++, n--)\n+      swap(i, j, a);\n+  }\n+\n+  /**\n+   * Sort a short array into ascending order. The sort algorithm is an\n+   * optimised quicksort, as described in Jon L. Bentley and M. Douglas\n+   * McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience,\n+   * Vol. 23(11) P. 1249-1265 (November 1993). This algorithm gives nlog(n)\n+   * performance on many arrays that would take quadratic time with a standard\n+   * quicksort.\n+   *\n+   * @param a the array to sort\n+   */\n+  public static void sort(short[] a) {\n+    qsort(a, 0, a.length);\n+  }\n+\n+  private static int cmp(short i, short j) {\n+    return i-j;\n+  }\n+\n+  private static int med3(int a, int b, int c, short[] d) {\n+    return cmp(d[a], d[b]) < 0 ? \n+      (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n+    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+  }\n+  \n+  private static void swap(int i, int j, short[] a) {\n+    short c = a[i];\n+    a[i] = a[j];\n+    a[j] = c;\n+  }\n+\n+  private static void qsort(short[] a, int start, int n) {\n+    // use an insertion sort on small arrays\n+    if (n < 7) {\n+      for (int i = start + 1; i < start + n; i++)\n+        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n+          swap(j, j-1, a);\n+      return;\n+    }\n+\n+    int pm = n/2;       // small arrays, middle element\n+    if (n > 7) {\n+      int pl = start;\n+      int pn = start + n-1;\n+\n+      if (n > 40) {     // big arrays, pseudomedian of 9\n+        int s = n/8;\n+        pl = med3(pl, pl+s, pl+2*s, a);\n+        pm = med3(pm-s, pm, pm+s, a);\n+        pn = med3(pn-2*s, pn-s, pn, a);\n+      }\n+      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n+    }\n+\n+    int pa, pb, pc, pd, pv;\n+    int r;\n+\n+    pv = start; swap(pv, pm, a);\n+    pa = pb = start;\n+    pc = pd = start + n-1;\n+    \n+    for (;;) {\n+      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n+        if (r == 0) { swap(pa, pb, a); pa++; }\n+        pb++;\n+      }\n+      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n+        if (r == 0) { swap(pc, pd, a); pd--; }\n+        pc--;\n+      }\n+      if (pb > pc) break;\n+      swap(pb, pc, a);\n+      pb++;\n+      pc--;\n+    }\n+    int pn = start + n;\n+    int s;\n+    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n+    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n+    if ((s = pb-pa) > 1) qsort(a, start, s);\n+    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+  }\n+\n+  private static void vecswap(int i, int j, int n, short[] a) {\n+    for (; n > 0; i++, j++, n--)\n+      swap(i, j, a);\n+  }\n+\n+  /**\n+   * The bulk of the work for the object sort routines.  In general,\n+   * the code attempts to be simple rather than fast, the idea being\n+   * that a good optimising JIT will be able to optimise it better\n+   * than I can, and if I try it will make it more confusing for the\n+   * JIT.  \n+   */\n+  private static void mergeSort(Object[] a, int from, int to, Comparator c)\n+  {\n+    // First presort the array in chunks of length 6 with insertion sort. \n+    // mergesort would give too much overhead for this length.\n+    for (int chunk = from; chunk < to; chunk += 6)\n+      {\n+\tint end = Math.min(chunk+6, to);\n+\tfor (int i = chunk + 1; i < end; i++)\n+\t  {\n+\t    if (c.compare(a[i-1], a[i]) > 0)\n+\t      {\n+\t\t// not already sorted\n+\t\tint j=i;\n+\t\tObject elem = a[j];\n+\t\tdo \n+\t\t  {\n+\t\t    a[j] = a[j-1];\n+\t\t    j--;\n+\t\t  } \n+\t\twhile (j>chunk && c.compare(a[j-1], elem) > 0);\n+\t\ta[j] = elem;\n+\t      }\n+\t  }\n+      }\n+    \n+    int len = to - from;\n+    // If length is smaller or equal 6 we are done.\n+    if (len <= 6)\n+      return;\n+\n+    Object[] src = a;\n+    Object[] dest = new Object[len];\n+    Object[] t = null; // t is used for swapping src and dest\n+\n+    // The difference of the fromIndex of the src and dest array.\n+    int srcDestDiff = -from;\n+\n+    // The merges are done in this loop\n+    for (int size = 6; size < len; size <<= 1) \n+      {\n+\tfor (int start = from; start < to; start += size << 1)\n+\t  {\n+\t    // mid ist the start of the second sublist;\n+\t    // end the start of the next sublist (or end of array).\n+\t    int mid = start + size;\n+\t    int end = Math.min(to, mid + size);\n+\t    \n+\t    // The second list is empty or the elements are already in\n+\t    // order - no need to merge\n+\t    if (mid >= end || c.compare(src[mid - 1], src[mid]) <= 0) {\n+\t      System.arraycopy(src, start, \n+\t\t\t       dest, start + srcDestDiff, end - start);\n+\t      \n+\t      // The two halves just need swapping - no need to merge\n+\t    } else if (c.compare(src[start], src[end - 1]) > 0) {\n+\t      System.arraycopy(src, start, \n+\t\t\t       dest, end - size + srcDestDiff, size);\n+\t      System.arraycopy(src, mid, \n+\t\t\t       dest, start + srcDestDiff, end - mid);\n+\t      \n+\t    } else {\n+\t      // Declare a lot of variables to save repeating\n+\t      // calculations.  Hopefully a decent JIT will put these\n+\t      // in registers and make this fast\n+\t      int p1 = start;\n+\t      int p2 = mid;\n+\t      int i = start + srcDestDiff;\n+\t      \n+\t      // The main merge loop; terminates as soon as either\n+\t      // half is ended\n+\t      while (p1 < mid && p2 < end)\n+\t\t{\n+\t\t  dest[i++] = \n+\t\t    src[c.compare(src[p1], src[p2]) <= 0 ? p1++ : p2++];\n+\t\t}\n+\t      \n+\t      // Finish up by copying the remainder of whichever half\n+\t      // wasn't finished.\n+\t      if (p1 < mid)\n+\t\tSystem.arraycopy(src, p1, dest, i, mid - p1);\n+\t      else\n+\t\tSystem.arraycopy(src, p2, dest, i, end - p2);\n+\t    } \n+\t  }\n+\t// swap src and dest ready for the next merge\n+\tt = src; src = dest; dest = t; \n+\tfrom += srcDestDiff;\n+\tto   += srcDestDiff;\n+\tsrcDestDiff = -srcDestDiff;\n+      }\n+\n+    // make sure the result ends up back in the right place.  Note\n+    // that src and dest may have been swapped above, so src \n+    // contains the sorted array.\n+    if (src != a)\n+      {\n+\t// Note that from == 0.\n+\tSystem.arraycopy(src, 0, a, srcDestDiff, to);\n+      }\n+  }\n+\n+  /**\n+   * Sort an array of Objects according to their natural ordering. The sort is\n+   * guaranteed to be stable, that is, equal elements will not be reordered.\n+   * The sort algorithm is a mergesort with the merge omitted if the last\n+   * element of one half comes before the first element of the other half. This\n+   * algorithm gives guaranteed O(nlog(n)) time, at the expense of making a\n+   * copy of the array.\n+   *\n+   * @param a the array to be sorted\n+   * @exception ClassCastException if any two elements are not mutually\n+   *   comparable\n+   * @exception NullPointerException if an element is null (since\n+   *   null.compareTo cannot work)\n+   */\n+  public static void sort(Object[] a) {\n+    mergeSort(a, 0, a.length, defaultComparator);\n+  }\n+\n+  /**\n+   * Sort an array of Objects according to a Comparator. The sort is\n+   * guaranteed to be stable, that is, equal elements will not be reordered.\n+   * The sort algorithm is a mergesort with the merge omitted if the last\n+   * element of one half comes before the first element of the other half. This\n+   * algorithm gives guaranteed O(nlog(n)) time, at the expense of making a\n+   * copy of the array.\n+   *\n+   * @param a the array to be sorted\n+   * @param c a Comparator to use in sorting the array\n+   * @exception ClassCastException if any two elements are not mutually\n+   *   comparable by the Comparator provided\n+   */\n+  public static void sort(Object[] a, Comparator c) {\n+    mergeSort(a, 0, a.length, c);\n+  }\n+\n+  /**\n+   * Sort an array of Objects according to their natural ordering. The sort is\n+   * guaranteed to be stable, that is, equal elements will not be reordered.\n+   * The sort algorithm is a mergesort with the merge omitted if the last\n+   * element of one half comes before the first element of the other half. This\n+   * algorithm gives guaranteed O(nlog(n)) time, at the expense of making a\n+   * copy of the array.\n+   *\n+   * @param a the array to be sorted\n+   * @param fromIndex the index of the first element to be sorted.\n+   * @param toIndex the index of the last element to be sorted plus one.\n+   * @exception ClassCastException if any two elements are not mutually\n+   *   comparable by the Comparator provided\n+   * @exception ArrayIndexOutOfBoundsException, if fromIndex and toIndex\n+   *   are not in range.\n+   * @exception IllegalArgumentException if fromIndex > toIndex\n+   */\n+  public static void sort(Object[] a, int fromIndex, \n+\t\t\t  int toIndex) {\n+    if (fromIndex > toIndex)\n+      throw new IllegalArgumentException(\"fromIndex \"+fromIndex\n+\t\t\t\t\t +\" > toIndex \"+toIndex);\n+    mergeSort(a, fromIndex, toIndex, defaultComparator);\n+  }\n+\n+  /**\n+   * Sort an array of Objects according to a Comparator. The sort is\n+   * guaranteed to be stable, that is, equal elements will not be reordered.\n+   * The sort algorithm is a mergesort with the merge omitted if the last\n+   * element of one half comes before the first element of the other half. This\n+   * algorithm gives guaranteed O(nlog(n)) time, at the expense of making a\n+   * copy of the array.\n+   *\n+   * @param a the array to be sorted\n+   * @param fromIndex the index of the first element to be sorted.\n+   * @param toIndex the index of the last element to be sorted plus one.\n+   * @param c a Comparator to use in sorting the array\n+   * @exception ClassCastException if any two elements are not mutually\n+   *   comparable by the Comparator provided\n+   * @exception ArrayIndexOutOfBoundsException, if fromIndex and toIndex\n+   *   are not in range.\n+   * @exception IllegalArgumentException if fromIndex > toIndex\n+   */\n+  public static void sort(Object[] a, int fromIndex, \n+\t\t\t  int toIndex, Comparator c) {\n+    if (fromIndex > toIndex)\n+      throw new IllegalArgumentException(\"fromIndex \"+fromIndex\n+\t\t\t\t\t +\" > toIndex \"+toIndex);\n+    mergeSort(a, fromIndex, toIndex, c);\n+  }\n+\n+  /**\n+   * Returns a list \"view\" of the specified array. This method is intended to\n+   * make it easy to use the Collections API with existing array-based APIs and\n+   * programs.\n+   *\n+   * @param a the array to return a view of\n+   * @returns a fixed-size list, changes to which \"write through\" to the array\n+   */\n+  public static List asList(final Object[] a) {\n+\n+    if (a == null) {\n+      throw new NullPointerException();\n+    }\n+\n+    return new ListImpl( a );\n+  }\n+\n+\n+  /**\n+   * Inner class used by asList(Object[]) to provide a list interface\n+   * to an array. The methods are all simple enough to be self documenting.\n+   * Note: When Sun fully specify serialized forms, this class will have to\n+   * be renamed.\n+   */\n+  private static class ListImpl extends AbstractList {\n+\n+    ListImpl(Object[] a) {\n+      this.a = a;\n+    }\n+\n+    public Object get(int index) {\n+      return a[index];\n+    }\n+\n+    public int size() {\n+      return a.length;\n+    }\n+\n+    public Object set(int index, Object element) {\n+      Object old = a[index];\n+      a[index] = element;\n+      return old;\n+    }\n+\n+    private Object[] a;\n+  }\n+    \n+}"}, {"sha": "8a1aa87cad979488e060a5141871b5d915a6f5bb", "filename": "libjava/libgcj.spec.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Flibgcj.spec.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Flibgcj.spec.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flibgcj.spec.in?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -4,7 +4,7 @@\n # to link with libgcj.\n #\n %rename lib liborig\n-*lib: -lgcj -lm @GCSPEC@ @THREADSPEC@ @ZLIBSPEC@ @SYSTEMSPEC@ %(liborig)\n+*lib: -lgcjawt -lgcj -lm @GCSPEC@ @THREADSPEC@ @ZLIBSPEC@ @SYSTEMSPEC@ %(liborig)\n \n *jc1:  @DIVIDESPEC@ @EXCEPTIONSPEC@ -fasynchronous-exceptions\n "}, {"sha": "d4de7921edb8ef6c84340052eafdcac1721b48f2", "filename": "libjava/libltdl/Makefile.in", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Flibltdl%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Flibltdl%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flibltdl%2FMakefile.in?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -74,19 +74,15 @@ PACKAGE = @PACKAGE@\n RANLIB = @RANLIB@\n VERSION = @VERSION@\n \n-AUTOMAKE_OPTIONS = no-dependencies foreign\n+AUTOMAKE_OPTIONS = no-dependencies foreign no-installinfo\n \n INCLUDES = $(GCINCS)\n \n-@INSTALL_LTDL_TRUE@include_HEADERS = \\\n-@INSTALL_LTDL_TRUE@ltdl.h\n-@INSTALL_LTDL_TRUE@lib_LTLIBRARIES = \\\n-@INSTALL_LTDL_TRUE@libltdl.la\n-@INSTALL_LTDL_FALSE@noinst_HEADERS = \\\n-@INSTALL_LTDL_FALSE@ltdl.h\n+@INSTALL_LTDL_TRUE@include_HEADERS = @INSTALL_LTDL_TRUE@ltdl.h\n+@INSTALL_LTDL_TRUE@lib_LTLIBRARIES = @INSTALL_LTDL_TRUE@libltdl.la\n+@INSTALL_LTDL_FALSE@noinst_HEADERS = @INSTALL_LTDL_FALSE@ltdl.h\n \n-@CONVENIENCE_LTDL_TRUE@noinst_LTLIBRARIES = \\\n-@CONVENIENCE_LTDL_TRUE@libltdlc.la\n+@CONVENIENCE_LTDL_TRUE@noinst_LTLIBRARIES = @CONVENIENCE_LTDL_TRUE@libltdlc.la\n \n libltdl_la_SOURCES = ltdl.c\n libltdl_la_LDFLAGS = -version-info 1:2:1\n@@ -124,7 +120,7 @@ configure.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n SOURCES = $(libltdl_la_SOURCES) $(libltdlc_la_SOURCES)\n OBJECTS = $(libltdl_la_OBJECTS) $(libltdlc_la_OBJECTS)\n@@ -338,7 +334,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n@@ -353,6 +349,8 @@ check-am: all-am\n check: check-am\n installcheck-am:\n installcheck: installcheck-am\n+install-info-am: \n+install-info: install-info-am\n all-recursive-am: config.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n \n@@ -429,11 +427,12 @@ maintainer-clean-compile mostlyclean-libtool distclean-libtool \\\n clean-libtool maintainer-clean-libtool uninstall-includeHEADERS \\\n install-includeHEADERS tags mostlyclean-tags distclean-tags clean-tags \\\n maintainer-clean-tags distdir info-am info dvi-am dvi check check-am \\\n-installcheck-am installcheck all-recursive-am install-exec-am \\\n-install-exec install-data-am install-data install-am install \\\n-uninstall-am uninstall all-redirect all-am all installdirs \\\n-mostlyclean-generic distclean-generic clean-generic \\\n-maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n+installcheck-am installcheck install-info-am install-info \\\n+all-recursive-am install-exec-am install-exec install-data-am \\\n+install-data install-am install uninstall-am uninstall all-redirect \\\n+all-am all installdirs mostlyclean-generic distclean-generic \\\n+clean-generic maintainer-clean-generic clean mostlyclean distclean \\\n+maintainer-clean\n \n \n ltdl.lo: ltdl.h config.h"}, {"sha": "1a4e48b419b4e029a3e8dbfb0a3d3886362ae537", "filename": "libjava/mauve-libgcj", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fmauve-libgcj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fmauve-libgcj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fmauve-libgcj?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -4,13 +4,13 @@ JDK1.1\n !java.applet\n !java.awt\n !java.beans\n-# We don't support object serialization yet.\n-!java.io.ObjectStreamClass\n-!java.io.ObjectInputOutput\n java.lang.Character.classify12\n java.lang.String.hash\n-# We support 1.2 for this test.\n+# We support 1.2 for these 3 tests.\n java.lang.reflect.Modifier.toString12\n+!java.io.ObjectInputOutput.InputTest\n+!java.io.ObjectInputOutput.OutputTest\n+!java.io.ObjectStreamClass.Test\n java.math\n !java.rmi\n java.security"}, {"sha": "ab028af33cd02537ef1d2802552df7c3029bf447", "filename": "libjava/name-finder.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fname-finder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fname-finder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fname-finder.cc?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -64,10 +64,14 @@ _Jv_name_finder::_Jv_name_finder (char *executable)\n   char *argv[6];\n   {\n     int arg = 0;\n+#ifdef __ia64__\n+    argv[arg++] = \"addr2name.awk\";\n+#else\n     argv[arg++] = \"addr2line\";\n     argv[arg++] = \"-C\";\n     argv[arg++] = \"-f\";\n     argv[arg++] = \"-e\";\n+#endif\n     argv[arg++] = executable;\n     argv[arg] = NULL;\n   }"}, {"sha": "4279b09f6ab07eeb4a18ccbd038152e8f9c0d399", "filename": "libjava/prims.cc", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -95,13 +95,26 @@ void (*_Jv_JVMPI_Notify_THREAD_END) (JVMPI_Event *event);\n #endif\n \f\n \n+extern \"C\" void _Jv_ThrowSignal (void *) __attribute ((noreturn));\n+\n+// Just like _Jv_Throw, but fill in the stack trace first.  Although\n+// this is declared extern in order that its name not be mangled, it\n+// is not intended to be used outside this file.\n+void \n+_Jv_ThrowSignal (void *e)\n+{\n+  java::lang::Throwable *throwable = (java::lang::Throwable *)e;\n+  throwable->fillInStackTrace ();\n+  _Jv_Throw (throwable);\n+}\n+ \n #ifdef HANDLE_SEGV\n static java::lang::NullPointerException *nullp;\n+\n SIGNAL_HANDLER (catch_segv)\n {\n-  MAKE_THROW_FRAME;\n-  nullp->fillInStackTrace ();\n-  _Jv_Throw (nullp);\n+  MAKE_THROW_FRAME (nullp);\n+  _Jv_ThrowSignal (nullp);\n }\n #endif\n \n@@ -113,10 +126,9 @@ SIGNAL_HANDLER (catch_fpe)\n #ifdef HANDLE_DIVIDE_OVERFLOW\n   HANDLE_DIVIDE_OVERFLOW;\n #else\n-  MAKE_THROW_FRAME;\n+  MAKE_THROW_FRAME (arithexception);\n #endif\n-  arithexception->fillInStackTrace ();\n-  _Jv_Throw (arithexception);\n+  _Jv_ThrowSignal (arithexception);\n }\n #endif\n \n@@ -125,8 +137,8 @@ SIGNAL_HANDLER (catch_fpe)\n jboolean\n _Jv_equalUtf8Consts (Utf8Const* a, Utf8Const *b)\n {\n-  register int len;\n-  register _Jv_ushort *aptr, *bptr;\n+  int len;\n+  _Jv_ushort *aptr, *bptr;\n   if (a == b)\n     return true;\n   if (a->hash != b->hash)\n@@ -155,8 +167,8 @@ _Jv_equal (Utf8Const* a, jstring str, jint hash)\n   jint len = str->length();\n   jint i = 0;\n   jchar *sptr = _Jv_GetStringChars (str);\n-  register unsigned char* ptr = (unsigned char*) a->data;\n-  register unsigned char* limit = ptr + a->length;\n+  unsigned char* ptr = (unsigned char*) a->data;\n+  unsigned char* limit = ptr + a->length;\n   for (;; i++, sptr++)\n     {\n       int ch = UTF8_GET (ptr, limit);\n@@ -175,8 +187,8 @@ _Jv_equaln (Utf8Const *a, jstring str, jint n)\n   jint len = str->length();\n   jint i = 0;\n   jchar *sptr = _Jv_GetStringChars (str);\n-  register unsigned char* ptr = (unsigned char*) a->data;\n-  register unsigned char* limit = ptr + a->length;\n+  unsigned char* ptr = (unsigned char*) a->data;\n+  unsigned char* limit = ptr + a->length;\n   for (; n-- > 0; i++, sptr++)\n     {\n       int ch = UTF8_GET (ptr, limit);\n@@ -192,8 +204,8 @@ _Jv_equaln (Utf8Const *a, jstring str, jint n)\n int\n _Jv_strLengthUtf8(char* str, int len)\n {\n-  register unsigned char* ptr;\n-  register unsigned char* limit;\n+  unsigned char* ptr;\n+  unsigned char* limit;\n   int str_length;\n \n   ptr = (unsigned char*) str;\n@@ -213,8 +225,8 @@ _Jv_strLengthUtf8(char* str, int len)\n static jint\n hashUtf8String (char* str, int len)\n {\n-  register unsigned char* ptr = (unsigned char*) str;\n-  register unsigned char* limit = ptr + len;\n+  unsigned char* ptr = (unsigned char*) str;\n+  unsigned char* limit = ptr + len;\n   jint hash = 0;\n \n   for (; ptr < limit;)\n@@ -976,7 +988,7 @@ jint\n _Jv_divI (jint dividend, jint divisor)\n {\n   if (__builtin_expect (divisor == 0, false))\n-    _Jv_Throw (arithexception);\n+    _Jv_ThrowSignal (arithexception);\n   \n   if (dividend == (jint) 0x80000000L && divisor == -1)\n     return dividend;\n@@ -988,7 +1000,7 @@ jint\n _Jv_remI (jint dividend, jint divisor)\n {\n   if (__builtin_expect (divisor == 0, false))\n-    _Jv_Throw (arithexception);\n+    _Jv_ThrowSignal (arithexception);\n   \n   if (dividend == (jint) 0x80000000L && divisor == -1)\n     return 0;\n@@ -1000,7 +1012,7 @@ jlong\n _Jv_divJ (jlong dividend, jlong divisor)\n {\n   if (__builtin_expect (divisor == 0, false))\n-    _Jv_Throw (arithexception);\n+    _Jv_ThrowSignal (arithexception);\n   \n   if (dividend == (jlong) 0x8000000000000000LL && divisor == -1)\n     return dividend;\n@@ -1012,7 +1024,7 @@ jlong\n _Jv_remJ (jlong dividend, jlong divisor)\n {\n   if (__builtin_expect (divisor == 0, false))\n-    _Jv_Throw (arithexception);\n+    _Jv_ThrowSignal (arithexception);\n   \n   if (dividend == (jlong) 0x8000000000000000LL && divisor == -1)\n     return 0;"}, {"sha": "e9f17c774ea9c2bebccbe975710a7f1e94104af2", "filename": "libjava/scripts/classes.pl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fscripts%2Fclasses.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fscripts%2Fclasses.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fscripts%2Fclasses.pl?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef", "patch": "@@ -10,7 +10,7 @@\n # details.\n \n # Usage: cd <top-srcdir> ; perl classes.pl.\n-# Can also be run from the `gcj' directory; this lets us\n+# Can also be run from the `include' directory; this lets us\n # more easily insert the output into javaprims.h (which is where it goes).\n \n use DirHandle;\n@@ -100,5 +100,5 @@ sub scan\n \t&scan (\"$dir/$_\", $indent + 2);\n     }\n \n-    print $spaces, \"}\\n\";\n+    print $spaces, \"};\\n\";\n }"}, {"sha": "7f07988f0a851a01ba83c4648b0c645384308f2e", "filename": "libjava/sysdep/ia64-frame.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fsysdep%2Fia64-frame.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fsysdep%2Fia64-frame.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fia64-frame.h?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef"}, {"sha": "f3c4761fd89b490e2ef1e8d791ee2bb74e866795", "filename": "libjava/sysdep/ia64.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fsysdep%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Fsysdep%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fia64.c?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef"}, {"sha": "180ce65b451b8b579d9838f8ca9d265ea87773ab", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=6c80c45e3010bfe992b41dd8800d2c4b65e0d5ef"}]}