{"sha": "f376e137d46ac34615746a297d8bc1d9f9fd7eca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM3NmUxMzdkNDZhYzM0NjE1NzQ2YTI5N2Q4YmMxZDlmOWZkN2VjYQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-09-26T20:15:18Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-09-26T20:15:18Z"}, "message": "47th Cygnus<->FSF merge\n\nFrom-SVN: r8129", "tree": {"sha": "f9c0f819ae41cf6e844789463888bb2e000eedcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9c0f819ae41cf6e844789463888bb2e000eedcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f376e137d46ac34615746a297d8bc1d9f9fd7eca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f376e137d46ac34615746a297d8bc1d9f9fd7eca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f376e137d46ac34615746a297d8bc1d9f9fd7eca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f376e137d46ac34615746a297d8bc1d9f9fd7eca/comments", "author": null, "committer": null, "parents": [{"sha": "96f218bb2aa467606a31c67b3f64c0ac04457f25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96f218bb2aa467606a31c67b3f64c0ac04457f25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96f218bb2aa467606a31c67b3f64c0ac04457f25"}], "stats": {"total": 1443, "additions": 1009, "deletions": 434}, "files": [{"sha": "2515e5ca2bd779057fed72c0585bb840bdc5f1e4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -3,6 +3,308 @@ Wed Sep 14 10:17:27 1994  Michael I Bushnell  <mib@churchy.gnu.ai.mit.edu>\n \t* g++.c: Include <sys/errno.h> in case `errno' is a macro\n \tas permitted by ANSI C.\n \n+Thu Sep 22 12:53:03 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n+\n+\t* decl2.c (finish_file):  Fix Brendan's fix:  Only call\n+\tregister_exception_table if there is a non-empty exception table.\n+\n+Thu Sep 22 12:03:46 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl2.c (finish_file): Only do register_exception_table if\n+\t-fhandle-exceptions is being used.\n+\n+Wed Sep 21 19:01:51 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n+\n+\t* except.c (output_exception_table_entry):  Simplify\n+\tby using assemble_integer.\n+\t(build_exception_table):  Change to return a count.\n+\tCleanup to use standard macros, instead of hard-wired\n+\tsparc asm format.  Don't make __EXCEPTION_TABLE__ global.\n+\t(register_exception_table):  New function.  Generate call to builtin.\n+\t* decl2.c (finish_file):  Call register_exception_table.\n+\t* cp-tree.h (build_exception_table):  Fix prototype.\n+\n+Wed Sep 21 13:20:42 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* tree.c (break_out_calls): Don't try to duplicate the DECL_INITIAL.\n+\n+\t* decl2.c (delete_sanity): Give an error at trying to delete a\n+\tfunction.\n+\n+Wed Sep 21 11:47:10 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* lex.c (cons_up_default_function): Mark synthesized destructors\n+\tinline.\n+\n+\t* decl.c (duplicate_decls): Ignore redeclarations of wchar_t as\n+\tsomething other than __wchar_t, complaining if -pedantic and not in\n+\ta system header.\n+\n+Tue Sep 20 09:43:28 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (xref_tag): Set up BINFO_INHERITANCE_CHAIN on base binfos\n+\there.\n+\n+\t* typeck.c (build_modify_expr): Require complete type after checking\n+\tfor error_mark_node.\n+\n+\t* call.c (build_method_call): Print parmtypes when complaining of\n+\tambiguous call.\n+\n+\t* typeck.c (build_modify_expr): Handle assignment to array from\n+\tnon-array.\n+\n+\t* decl.c (lookup_name_real): Deal with got_scope == error_mark_node.\n+\n+\t* call.c (build_method_call): Don't bother with the exact match.\n+\n+Mon Sep 19 00:51:39 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* init.c (expand_aggr_init): If we munge the type of the variable,\n+\talso munge the type of the initializer.\n+\n+\t* decl.c (grokdeclarator): Use <= when comparing to RID_LAST_MODIFIER.\n+\t(init_decl_processing): Push artificial declaration of wchar_t so\n+\tpeople don't have to declare it before they can use it.\n+\n+\t* error.c (cp_line_of): return lineno in lieu of 0.\n+\n+\t* typeck.c (convert_for_assignment): Handle conversion of pmfs to\n+\tint and bool.\n+\t(build_component_ref): Fold the COMPONENT_REF in case it can be\n+\treduced.\n+\n+\t* typeck2.c (store_init_value): Don't pedwarn about non-constant\n+\tbracketed initializers for automatic variables.\n+\n+Sun Sep 18 10:12:12 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* error.c (dump_decl): Don't say `typedef enum foo foo'.\n+\n+\t* decl.c (start_decl): Don't set TREE_PUBLIC on template decls just\n+\tbecause they're affected by #pragma i/i.  We'll deal with that when\n+\tthey get instantiated.\n+\n+\t* typeck.c (build_unary_op): Clean up cruft in ADDR_EXPR case.\n+\n+\t* class.c (instantiate_type): Set TREE_CONSTANT on instantiated\n+\tADDR_EXPRs if appropriate.\n+\n+\t* decl.c (build_ptrmemfunc_type): Unset IS_AGGR_TYPE on pmf types.\n+\n+\t* typeck.c (build_ptrmemfunc): Handle &overloaded_method as an\n+\tinitializer properly.\n+\t* typeck2.c (digest_init): Ditto.\n+\n+\t* tree.c (cp_build_type_variant): Like c_build_type_variant, except\n+\tit uses build_cplus_array_type.\n+\t* *.c: Use cp_build_type_variant instead of c_build_type_variant.\n+\n+\t* pt.c (do_type_instantiation): Don't try to instantiate nested\n+        enums.\n+\n+Tue Sep 13 10:56:58 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* cvt.c (build_up_reference): Handle preincrement and predecrement\n+        properly.\n+\n+Tue Sep 13 09:51:59 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (finish_decl): Only lay out the rtl for DECL if it is, in\n+\tfact, static.\n+\n+Mon Sep 12 14:40:30 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (finish_decl): Lay out the rtl for DECL before doing\n+\tgrok_reference_init, in case it's static.\n+\n+Mon Sep 12 12:45:38 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* class.c (finish_struct): Don't synthesize constructors if the\n+\tclass has a field with the same name as the class.  Don't die on\n+\tclasses with no constructors or destructors.  Don't die if the head\n+\tand tail of the class are in different files.\n+\n+\t* decl.c (grokdeclarator): Don't treat a function pointer field\n+\twith the same name as the class as a constructor.\n+\n+Fri Sep  9 13:17:00 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (build_c_cast): Pull constant values out of their\n+\tvariables here.\n+\n+\t* decl.c (duplicate_decls): Only propagate DECL_CHAIN in\n+\tFUNCTION_DECLs and TEMPLATE_DECLs.\n+\n+Thu Sep  8 10:07:48 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (duplicate_decls): Propagate DECL_CHAIN in all DECLs that\n+\thave it.\n+\n+\t* pt.c (unify): REALs and INTEGERs only unify with their own genus.\n+\t(instantiate_member_templates): Don't muck with DECL_EXTERNAL and\n+\tTREE_PUBLIC unless -fexternal-templates.\n+\n+Wed Sep  7 13:17:10 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* pt.c (do_type_instantiation): Call instantiate_member_templates.\n+\tDeal with specializations.\n+\t(tsubst): Don't stick the mangled name in DECL_NAME for function\n+\tinstantiations.  Don't push them, either.\n+\n+\t* decl2.c (grokfield): Move code for generating the\n+\tDECL_ASSEMBLER_NAME for static members from here.\n+\t* method.c (build_static_name): To here.\n+\t* decl.c (grokvardecl): Call build_static_name.\n+\t(duplicate_decls): Keep old DECL_ASSEMBLER_NAME.\n+\n+Mon Sep  5 12:49:18 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* call.c (build_method_call): if -Wsynth, warn when selecting\n+\tsynthesized op= over user-supplied one cfront would select.\n+\t* decl2.c (lang_decode_option): Handle -Wsynth.\n+\n+Fri Sep  2 15:11:59 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (finish_enum): Overhaul to fix several bugs.\n+\t(start_enum): Disable useless code.\n+\n+Thu Sep  1 16:04:54 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (c_expand_return): Warn about returning a reference to a\n+\ttemporary.\n+\t(convert_arguments): Increment argument counter when using default\n+\targuments, too.\n+\n+Wed Aug 31 14:29:22 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (finish_decl): If the type of decl is error_mark_node,\n+\tdon't bother trying to do anything.\n+\n+\t* typeck.c (convert_for_initialization): If the rhs contains a\n+\tconstructor call, pretend the lhs type needs to be constructed.\n+\n+\t* init.c (expand_default_init): If we stick the object inside the\n+\tinitializer, mark the initializer used.\n+\n+Tue Aug 30 13:50:18 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* method.c (build_assign_ref): return *this;\n+\t(build_assign_ref): Fix base assignment order.\n+\t(build_copy_constructor): Fix member init order.\n+\n+Mon Aug 29 13:54:39 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* g++.c (main): Remember to clear out SAW_SPECLANG after we see\n+\tits argument.\n+\n+Sat Aug 27 09:36:03 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* method.c (build_copy_constructor): Also copy virtual bases.\n+\n+Fri Aug 26 17:05:15 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* lex.c (do_pending_inlines): Clear out pending_inlines before doing\n+\tany synthesis.  Also first set deja_vu on all pending_inlines.\n+\n+\t* method.c (build_assign_ref): Use build_member_call to invoke base\n+\toperator=, rather than build_modify_expr.  And use\n+\tbuild_reference_type instead of TYPE_REFERENCE_TO.\n+\t(build_copy_constructor): Use TYPE_NESTED_NAME to identify the\n+\tbasetype.\n+\n+\t* decl2.c (grokfield): Don't complain about undefined local class\n+\tmethods.\n+\n+\t* class.c (finish_struct): Don't try to synthesize methods here.\n+\t* lex.c (do_pending_inlines): Instead, synthesize them here.\n+\t(init_lex): Initialize synth_obstack.\n+\t(cons_up_default_function): Stick synthesis request on\n+\tpending_inlines.\n+\n+Fri Aug 26 12:24:14 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* call.c (build_method_call) [PCC_STATIC_STRUCT_RETURN]: Also\n+\taccept an RTL_EXPR in what we're about to use for the instance,\n+\tsince anything which would end up with pcc_struct_return set\n+\tinside cplus_expand_expr.\n+\n+\t* cp-tree.h (cons_up_default_function): Note change of prototype.\n+\n+Thu Aug 25 23:05:30 1994  Gerald Baumgartner  (gb@cs.purdue.edu)\n+\n+\t* class.c (finish_struct): Undid change from Aug 21 testing\n+\tCLASSTYPE_INTERFACE and CLASSTYPE_VTABLE_NEEDS_WRITING.\n+\t* parse.y (left_curly): Ditto, undid change from Aug 21.\n+\t* decl.c (xref_tag): Undid change from Aug 21, set\n+\tCLASSTYPE_INTERFACE correctly, and added comments.\n+\n+Thu Aug 25 00:36:31 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\tRework approach to synthesized methods; don't go through the parser\n+\tanymore.\n+\t* class.c (finish_struct): Use new synthesis approach.\n+\t* lex.c (cons_up_default_function): Now just creates declaration,\n+\tnot code.\n+\t(largest_union_member): #if 0 out.\n+\t(default_assign_ref_body): Ditto.\n+\t(default_copy_constructor_body): Ditto.\n+\t* method.c (build_default_constructor): New function to synthesize X().\n+\t(build_copy_constructor): Synthesize X(X&).\n+\t(build_assign_ref): Synthesize X::operator=(X&).\n+\t(build_dtor): Synthesize ~X().\n+\n+\t* error.c (cp_line_of): If we're dealing with an artificial\n+\tTYPE_DECL, look at the type instead.\n+\n+Wed Aug 24 11:11:50 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* init.c (sort_member_init): Check warn_reorder.\n+\t* decl2.c (lang_decode_option): Handle -W{no-,}reorder.\n+\n+\t* cp-tree.h (CLASSTYPE_SOURCE_LINE): New macro.\n+\t* error.c (cp_line_of): Use CLASSTYPE_SOURCE_LINE for aggregates.\n+\t* class.c (finish_struct): Set CLASSTYPE_SOURCE_LINE.\n+\n+Tue Aug 23 09:28:35 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* error.c (dump_decl): Improve wording, so that error messages\n+\tdont't read template<, class foo>...\n+\n+Mon Aug 22 15:30:51 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* parse.y (label_colon): Also match a TYPENAME as a label name,\n+\tsince they may have declared a class by that name but have also\n+\ttried to have a local label under the same name.\n+\n+\t* pt.c (coerce_template_parms): Call cp_error, not cp_error_at,\n+\tfor the message so they know at what point it was instantiated.\n+\n+Sun Aug 21 23:07:35 1994  Gerald Baumgartner  (gb@cs.purdue.edu)\n+\n+\t* class.c (finish_struct): Move setting of CLASSTYPE_INTERFACE and\n+\tCLASSTYPE_VTABLE_NEEDS_WRITING for signatures up to left_curly time.\n+\t* decl.c (xref_tag): Move setting of CLASSTYPE_INTERFACE and\n+        CLASSTYPE_VTABLE_NEEDS_WRITING for signatures down to left_curly time.\n+\t* parse.y (left_curly): New final resting place for setting\n+\tCLASSTYPE_INTERFACE and CLASSTYPE_VTABLE_NEEDS_WRITING for signatures.\n+\n+\t* class.c (finish_struct): Don't test for function/field name\n+\tconflicts in signatures, since all the fields are compiler-constructed.\n+\n+Fri Aug 19 14:04:47 1994  Kung Hsu  (kung@mexican.cygnus.com)\n+\n+\t* method.c (build_overload_nested_name): in qualified name\n+\tmangling, the template with value instantiation will have numeric\n+\tat end and may mixed with the name length of next nested level.\n+\tAdd a '_' in between.\n+\t* method.c (build_overload_name): ditto.\n+\t* method.c (build_overload_identifier): ditto.\n+\n+Thu Aug 18 16:24:43 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* error.c (dump_decl): Handle NULL args.\n+\n Thu Aug 18 12:48:09 1994  Mike Stump  (mrs@cygnus.com)\n \n \t* class.c (finish_struct): Move setting of CLASSTYPE_INTERFACE and"}, {"sha": "89921d6dd540c4de82f3f3a13e5ab3da8d3dc8e0", "filename": "gcc/cp/call.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -1814,7 +1814,11 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    }\n \t  else\n \t    {\n-\t      if (TREE_CODE (instance) != CALL_EXPR)\n+\t      if (TREE_CODE (instance) != CALL_EXPR\n+#ifdef PCC_STATIC_STRUCT_RETURN\n+\t\t  && TREE_CODE (instance) != RTL_EXPR\n+#endif\n+\t\t  )\n \t\tmy_friendly_abort (125);\n \t      if (TYPE_NEEDS_CONSTRUCTING (basetype))\n \t\tinstance = build_cplus_new (basetype, instance, 0);\n@@ -1943,7 +1947,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t{\n \t  constp = 0;\n \t  volatilep = 0;\n-\t  parms = tree_cons (NULL_TREE, build1 (NOP_EXPR, TYPE_POINTER_TO (basetype), integer_zero_node), parms);\n+\t  parms = tree_cons (NULL_TREE,\n+\t\t\t     build1 (NOP_EXPR, TYPE_POINTER_TO (basetype),\n+\t\t\t\t     integer_zero_node), parms);\n \t}\n       else\n \t{\n@@ -2023,6 +2029,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     return error_mark_node;\n \n \n+#if 0\n   /* Now, go look for this method name.  We do not find destructors here.\n \n      Putting `void_list_node' on the end of the parmtypes\n@@ -2032,6 +2039,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t\t\t     1 + (name == constructor_name (save_basetype)\n \t\t\t\t\t  || name == constructor_name_full (save_basetype)));\n   TREE_CHAIN (last) = NULL_TREE;\n+#endif\n \n   for (pass = 0; pass < 2; pass++)\n     {\n@@ -2073,7 +2081,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t{\n \t\t  tree new_type;\n \t\t  parm = build_indirect_ref (parm, \"friendifying parms (compiler error)\");\n-\t\t  new_type = c_build_type_variant (TREE_TYPE (parm), constp,\n+\t\t  new_type = cp_build_type_variant (TREE_TYPE (parm), constp,\n \t\t\t\t\t\t   volatilep);\n \t\t  new_type = build_reference_type (new_type);\n \t\t  parm = convert (new_type, parm);\n@@ -2158,9 +2166,11 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t  && ! DECL_STATIC_FUNCTION_P (function))\n \t\tcontinue;\n \n+#if 0\n \t      if (pass == 0\n \t\t  && DECL_ASSEMBLER_NAME (function) == method_name)\n \t\tgoto found;\n+#endif\n \n \t      if (pass > 0)\n \t\t{\n@@ -2255,21 +2265,33 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  if (cp - candidates > 1)\n \t    {\n \t      int n_candidates = cp - candidates;\n+\t      extern int warn_synth;\n \t      TREE_VALUE (parms) = instance_ptr;\n \t      cp = ideal_candidate (save_basetype, candidates,\n \t\t\t\t    n_candidates, parms, len);\n \t      if (cp == (struct candidate *)0)\n \t\t{\n \t\t  if (flags & LOOKUP_COMPLAIN)\n \t\t    {\n-\t\t      cp_error (\"call of overloaded %s `%D' is ambiguous\",\n-\t\t\t\tname_kind, name);\n+\t\t      TREE_CHAIN (last) = void_list_node;\n+\t\t      cp_error (\"call of overloaded %s `%D(%A)' is ambiguous\",\n+\t\t\t\tname_kind, name, TREE_CHAIN (parmtypes));\n \t\t      print_n_candidates (candidates, n_candidates);\n \t\t    }\n \t\t  return error_mark_node;\n \t\t}\n \t      if (cp->h.code & EVIL_CODE)\n \t\treturn error_mark_node;\n+\t      if (warn_synth\n+\t\t  && DECL_NAME (cp->function) == ansi_opname[MODIFY_EXPR]\n+\t\t  && DECL_ARTIFICIAL (cp->function)\n+\t\t  && n_candidates == 2)\n+\t\t{\n+\t\t  cp_warning (\"using synthesized `%#D' for copy assignment\",\n+\t\t\t      cp->function);\n+\t\t  cp_warning_at (\"  where cfront would use `%#D'\",\n+\t\t\t\t candidates->function);\n+\t\t}\n \t    }\n \t  else if (cp[-1].h.code & EVIL_CODE)\n \t    {"}, {"sha": "e463d841e201a5b2a0aad50f2f076e13ca2e899c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -2743,6 +2743,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t     will fill in the right line number.  (mrs) */\n \t  if (DECL_SOURCE_LINE (name))\n \t    DECL_SOURCE_LINE (name) = lineno;\n+\t  CLASSTYPE_SOURCE_LINE (t) = lineno;\n \t}\n       name = DECL_NAME (name);\n     }\n@@ -2772,13 +2773,15 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n \n+#if 0\n   /* This is in general too late to do this.  I moved the main case up to\n      left_curly, what else needs to move?  */\n   if (! IS_SIGNATURE (t))\n     {\n       my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);\n       my_friendly_assert (CLASSTYPE_INTERFACE_KNOWN (t) == ! interface_unknown, 999);\n     }\n+#endif\n \n   if (flag_dossier)\n     build_t_desc (t, 0);\n@@ -2841,13 +2844,15 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       needs_virtual_dtor = 0;\n     }\n \n+#if 0\n   /* Both of these should be done before now.  */\n   if (write_virtuals == 3 && CLASSTYPE_INTERFACE_KNOWN (t)\n       && ! IS_SIGNATURE (t))\n     {\n       my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);\n       my_friendly_assert (CLASSTYPE_VTABLE_NEEDS_WRITING (t) == ! interface_only, 999);\n     }\n+#endif\n \n   /* The three of these are approximations which may later be\n      modified.  Needed at this point to make add_virtual_function\n@@ -3004,6 +3009,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t      TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n \t    }\n \n+\t  if (DECL_NAME (x) == constructor_name (t))\n+\t    cant_have_default_ctor = cant_synth_copy_ctor = 1;\n+\n \t  if (TREE_TYPE (x) == error_mark_node)\n \t    continue;\n \t  \n@@ -3270,12 +3278,14 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   CLASSTYPE_REF_FIELDS_NEED_INIT (t) = ref_sans_init;\n   CLASSTYPE_ABSTRACT_VIRTUALS (t) = abstract_virtuals;\n \n+  /* Synthesize any needed methods.  Note that methods will be synthesized\n+     for anonymous unions; grok_x_components undoes that.  */\n+\n   if (TYPE_NEEDS_DESTRUCTOR (t) && !TYPE_HAS_DESTRUCTOR (t)\n       && !IS_SIGNATURE (t))\n     {\n       /* Here we must cons up a destructor on the fly.  */\n-      tree dtor = cons_up_default_function (t, name, fields,\n-\t\t\t\t\t    needs_virtual_dtor != 0);\n+      tree dtor = cons_up_default_function (t, name, needs_virtual_dtor != 0);\n \n       /* If we couldn't make it work, then pretend we didn't need it.  */\n       if (dtor == void_type_node)\n@@ -3304,9 +3314,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \n   TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n \n-  /* Synthesize any needed methods.  Note that methods will be synthesized\n-     for anonymous unions; grok_x_components undoes that.  */\n-\n   if (! fn_fields)\n     nonprivate_method = 1;\n \n@@ -3324,7 +3331,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   if (! TYPE_HAS_CONSTRUCTOR (t) && ! cant_have_default_ctor\n       && ! IS_SIGNATURE (t))\n     {\n-      tree default_fn = cons_up_default_function (t, name, fields, 2);\n+      tree default_fn = cons_up_default_function (t, name, 2);\n       TREE_CHAIN (default_fn) = fn_fields;\n       fn_fields = default_fn;\n     }\n@@ -3335,9 +3342,8 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n     {\n       /* ARM 12.18: You get either X(X&) or X(const X&), but\n \t not both.  --Chip  */\n-      tree default_fn =\n-\tcons_up_default_function (t, name, fields,\n-\t\t\t\t  cant_have_const_ctor ? 4 : 3);\n+      tree default_fn = cons_up_default_function (t, name,\n+\t\t\t\t\t\t  3 + cant_have_const_ctor);\n       TREE_CHAIN (default_fn) = fn_fields;\n       fn_fields = default_fn;\n     }\n@@ -3351,9 +3357,8 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   if (! TYPE_HAS_ASSIGN_REF (t) && ! cant_synth_asn_ref\n       && ! IS_SIGNATURE (t))\n     {\n-      tree default_fn =\n-\tcons_up_default_function (t, name, fields,\n-\t\t\t\t  no_const_asn_ref ? 6 : 5);\n+      tree default_fn = cons_up_default_function (t, name,\n+\t\t\t\t\t\t  5 + no_const_asn_ref);\n       TREE_CHAIN (default_fn) = fn_fields;\n       fn_fields = default_fn;\n     }\n@@ -3404,7 +3409,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \ttree flist = NULL_TREE;\n \ttree name;\n \tenum access_type access = (enum access_type)TREE_PURPOSE(access_decls);\n-\tint i = 0;\n+\tint i = TREE_VEC_ELT (method_vec, 0) ? 0 : 1;\n \ttree tmp;\n \n \tif (TREE_CODE (fdecl) == TREE_LIST)\n@@ -3512,30 +3517,26 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   /* Delete all duplicate fields from the fields */\n   delete_duplicate_fields (fields);\n \n-  /* Catch function/field name conflict, removing the field (since it's\n-     easier).  */\n-  {\n-    int n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n-    tree last = NULL_TREE;\n-    for (x = fields; x; x = TREE_CHAIN (x))\n-      {\n-\ttree name = DECL_NAME (x);\n-\tint i;\n-\tfor (i = 0; i < n_methods; ++i)\n-\t  if (DECL_NAME (TREE_VEC_ELT (method_vec, i)) == name)\n-\t    {\n-\t      cp_error_at (\"data member `%#D' conflicts with\", x);\n-\t      cp_error_at (\"function member `%#D'\",\n-\t\t\t   TREE_VEC_ELT (method_vec, i));\n-\t      if (last)\n-\t\tTREE_CHAIN (last) = TREE_CHAIN (x);\n-\t      else\n-\t\tfields = TREE_CHAIN (x);\n-\t      break;\n-\t    }\n-\tlast = x;\n-      }\n-  }\n+  /* Catch function/field name conflict.  We don't need to do this for a\n+     signature, since it can only contain the fields constructed in\n+     append_signature_fields.  */\n+  if (! IS_SIGNATURE (t))\n+    {\n+      int n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n+      for (x = fields; x; x = TREE_CHAIN (x))\n+\t{\n+\t  tree name = DECL_NAME (x);\n+\t  int i = /*TREE_VEC_ELT (method_vec, 0) ? 0 : */ 1;\n+\t  for (; i < n_methods; ++i)\n+\t    if (DECL_NAME (TREE_VEC_ELT (method_vec, i)) == name)\n+\t      {\n+\t\tcp_error_at (\"data member `%#D' conflicts with\", x);\n+\t\tcp_error_at (\"function member `%#D'\",\n+\t\t\t     TREE_VEC_ELT (method_vec, i));\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n \n   /* Now we have the final fieldlist for the data fields.  Record it,\n      then lay out the structure or union (including the fields).  */\n@@ -4967,12 +4968,14 @@ instantiate_type (lhstype, rhs, complain)\n \t}\n       TREE_TYPE (rhs) = lhstype;\n       lhstype = TREE_TYPE (lhstype);\n-      TREE_OPERAND (rhs, 0)\n-\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n-      if (TREE_OPERAND (rhs, 0) == error_mark_node)\n-\treturn error_mark_node;\n-\n-      mark_addressable (TREE_OPERAND (rhs, 0));\n+      {\n+\ttree fn = instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n+\tif (fn == error_mark_node)\n+\t  return error_mark_node;\n+\tmark_addressable (fn);\n+\tTREE_OPERAND (rhs, 0) = fn;\n+\tTREE_CONSTANT (rhs) = staticp (fn);\n+      }\n       return rhs;\n \n     case ENTRY_VALUE_EXPR:"}, {"sha": "13c21dcb070a7124b09c7ad7cd11d8a20152c840", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -502,8 +502,12 @@ struct lang_type\n   union tree_node *signature;\n   union tree_node *signature_pointer_to;\n   union tree_node *signature_reference_to;\n+\n+  int linenum;\n };\n \n+#define CLASSTYPE_SOURCE_LINE(NODE) (TYPE_LANG_SPECIFIC(NODE)->linenum)\n+\n /* Indicates whether or not (and how) a template was expanded for this class.\n      0=no information yet/non-template class\n      1=implicit template instantiation\n@@ -1355,7 +1359,7 @@ extern void check_function_format\t\tPROTO((tree, tree, tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error                     PROTO((enum tree_code));\n-extern tree c_build_type_variant                PROTO((tree, int, int));\n+extern tree cp_build_type_variant                PROTO((tree, int, int));\n extern void c_expand_expr_stmt                  PROTO((tree));\n /* Validate the expression after `case' and apply default promotions.  */\n extern tree check_case_value                    PROTO((tree));\n@@ -2011,7 +2015,7 @@ extern void expand_end_all_catch\t\tPROTO((void));\n extern void start_catch_block\t\t\tPROTO((tree, tree));\n extern void end_catch_block\t\t\tPROTO((void));\n extern void expand_throw\t\t\tPROTO((tree));\n-extern void build_exception_table\t\tPROTO((void));\n+extern int build_exception_table\t\tPROTO((void));\n extern tree build_throw\t\t\t\tPROTO((tree));\n extern void init_exception_processing\t\tPROTO((void));\n \n@@ -2091,7 +2095,7 @@ extern void reinit_parse_for_method\t\tPROTO((int, tree));\n #if 0\n extern void reinit_parse_for_block\t\tPROTO((int, struct obstack *, int));\n #endif\n-extern tree cons_up_default_function\t\tPROTO((tree, tree, tree, int));\n+extern tree cons_up_default_function\t\tPROTO((tree, tree, int));\n extern void check_for_missing_semicolon\t\tPROTO((tree));\n extern void note_got_semicolon\t\t\tPROTO((tree));\n extern void note_list_got_semicolon\t\tPROTO((tree));\n@@ -2141,6 +2145,7 @@ extern void clear_anon_parm_name\t\tPROTO((void));\n extern void do_inline_function_hair\t\tPROTO((tree, tree));\n /* skip report_type_mismatch */\n extern char *build_overload_name\t\tPROTO((tree, int, int));\n+extern tree build_static_name\t\t\tPROTO((tree, tree));\n extern tree cplus_exception_name\t\tPROTO((tree));\n extern tree build_decl_overload\t\t\tPROTO((tree, tree, int));\n extern tree build_typename_overload\t\tPROTO((tree));"}, {"sha": "d804ff28f906ecbd3bfd6a06fde8e5456b493a06", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -304,7 +304,7 @@ build_up_reference (type, arg, flags, checkconst)\n \n   /* Pass along const and volatile down into the type. */\n   if (TYPE_READONLY (type) || TYPE_VOLATILE (type))\n-    target_type = c_build_type_variant (target_type, TYPE_READONLY (type),\n+    target_type = cp_build_type_variant (target_type, TYPE_READONLY (type),\n \t\t\t\t\tTYPE_VOLATILE (type));\n   targ = arg;\n   if (TREE_CODE (targ) == SAVE_EXPR)\n@@ -494,6 +494,8 @@ build_up_reference (type, arg, flags, checkconst)\n \treturn rval;\n       }\n \n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n     case MODIFY_EXPR:\n     case INIT_EXPR:\n       {\n@@ -634,7 +636,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t    {\n \t      int r = TREE_READONLY (expr);\n \t      int v = TREE_THIS_VOLATILE (expr);\n-\t      ttr = c_build_type_variant (TREE_TYPE (expr), r, v);\n+\t      ttr = cp_build_type_variant (TREE_TYPE (expr), r, v);\n \t    }\n \n \t  if (! lvalue_p (expr) &&\n@@ -2041,5 +2043,5 @@ type_promotes_to (type)\n   else if (type == float_type_node)\n     type = double_type_node;\n \n-  return c_build_type_variant (type, constp, volatilep);\n+  return cp_build_type_variant (type, constp, volatilep);\n }"}, {"sha": "fa99e679a367503e0a04ffb559cffa4e272f7369", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 116, "deletions": 148, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -162,6 +162,8 @@ tree wchar_type_node;\n tree signed_wchar_type_node;\n tree unsigned_wchar_type_node;\n \n+tree wchar_decl_node;\n+\n tree float_type_node;\n tree double_type_node;\n tree long_double_type_node;\n@@ -2206,16 +2208,21 @@ duplicate_decls (newdecl, olddecl)\n \t    return 0;\n \t}\n \n+      if (olddecl == wchar_decl_node)\n+\t{\n+\t  if (pedantic && ! DECL_IN_SYSTEM_HEADER (newdecl))\n+\t    cp_pedwarn (\"redeclaration of wchar_t as `%T'\",\n+\t\t\tTREE_TYPE (newdecl));\n+\n+\t  /* Throw away the redeclaration.  */\n+\t  return 1;\n+\t}\n+\n       /* Already complained about this, so don't do so again.  */\n       else if (current_class_type == NULL_TREE\n \t  || IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (newdecl)) != current_class_type)\n \t{\n-\t  /* Since we're doing this before finish_struct can set the\n-\t     line number on NEWDECL, we just do a regular error here.  */\n-\t  if (DECL_SOURCE_LINE (newdecl) == 0)\n-\t    cp_error (\"conflicting types for `%#D'\", newdecl);\n-\t  else\n-\t    cp_error_at (\"conflicting types for `%#D'\", newdecl);\n+\t  cp_error (\"conflicting types for `%#D'\", newdecl);\n \t  cp_error_at (\"previous declaration as `%#D'\", olddecl);\n \t}\n     }\n@@ -2528,12 +2535,15 @@ duplicate_decls (newdecl, olddecl)\n       DECL_TEMPLATE_MEMBERS (newdecl) = DECL_TEMPLATE_MEMBERS (olddecl);\n       DECL_TEMPLATE_INSTANTIATIONS (newdecl)\n \t= DECL_TEMPLATE_INSTANTIATIONS (olddecl);\n+      if (DECL_CHAIN (newdecl) == NULL_TREE)\n+\tDECL_CHAIN (newdecl) = DECL_CHAIN (olddecl);\n     }\n   \n   /* Now preserve various other info from the definition.  */\n   TREE_ADDRESSABLE (newdecl) = TREE_ADDRESSABLE (olddecl);\n   TREE_ASM_WRITTEN (newdecl) = TREE_ASM_WRITTEN (olddecl);\n   DECL_COMMON (newdecl) = DECL_COMMON (olddecl);\n+  DECL_ASSEMBLER_NAME (newdecl) = DECL_ASSEMBLER_NAME (olddecl);\n \n   /* Don't really know how much of the language-specific\n      values we should copy from old to new.  */\n@@ -3900,7 +3910,9 @@ lookup_name_real (name, prefer_type, nonclass)\n       \n       if (got_scope != NULL_TREE)\n \t{\n-\t  if (got_scope == void_type_node)\n+\t  if (got_scope == error_mark_node)\n+\t    return error_mark_node;\n+\t  else if (got_scope == void_type_node)\n \t    val = IDENTIFIER_GLOBAL_VALUE (name);\n \t  else if (TREE_CODE (got_scope) == TEMPLATE_TYPE_PARM\n \t\t   /* TFIXME -- don't do this for UPTs in new model.  */\n@@ -4750,6 +4762,11 @@ init_decl_processing ()\n       : signed_wchar_type_node;\n   record_builtin_type (RID_WCHAR, \"__wchar_t\", wchar_type_node);\n \n+  /* Artificial declaration of wchar_t -- can be bashed */\n+  wchar_decl_node = build_decl (TYPE_DECL, get_identifier (\"wchar_t\"),\n+\t\t\t\twchar_type_node);\n+  pushdecl (wchar_decl_node);\n+\n   /* This is for wide string constants.  */\n   wchar_array_type_node\n     = build_array_type (wchar_type_node, array_domain_type);\n@@ -4800,7 +4817,7 @@ init_decl_processing ()\n   vtbl_type_node\n     = build_array_type (vtable_entry_type, NULL_TREE);\n   layout_type (vtbl_type_node);\n-  vtbl_type_node = c_build_type_variant (vtbl_type_node, 1, 0);\n+  vtbl_type_node = cp_build_type_variant (vtbl_type_node, 1, 0);\n   record_builtin_type (RID_MAX, NULL_PTR, vtbl_type_node);\n \n   /* Simplify life by making a \"sigtable_entry_type\".  Give its\n@@ -5297,8 +5314,7 @@ start_decl (declarator, declspecs, initialized, raises)\n       if (interface_unknown && flag_external_templates\n \t  && ! DECL_IN_SYSTEM_HEADER (decl))\n \twarn_if_unknown_interface ();\n-      TREE_PUBLIC (d) = TREE_PUBLIC (decl) =\n-\tflag_external_templates && !interface_unknown;\n+      TREE_PUBLIC (d) = TREE_PUBLIC (decl);\n       TREE_STATIC (d) = TREE_STATIC (decl);\n       DECL_EXTERNAL (d) = (DECL_EXTERNAL (decl)\n \t\t\t   && !(context && !DECL_THIS_EXTERN (decl)));\n@@ -5756,6 +5772,9 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \n   type = TREE_TYPE (decl);\n \n+  if (type == error_mark_node)\n+    return;\n+\n   was_incomplete = (DECL_SIZE (decl) == NULL_TREE);\n \n   /* Take care of TYPE_DECLs up front.  */\n@@ -5850,6 +5869,10 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n   else if (TREE_CODE (type) == REFERENCE_TYPE\n \t   || (TYPE_LANG_SPECIFIC (type) && IS_SIGNATURE_REFERENCE (type)))\n     {\n+      if (TREE_STATIC (decl))\n+\tmake_decl_rtl (decl, NULL_PTR,\n+\t\t       current_binding_level == global_binding_level\n+\t\t       || pseudo_global_level_p ());\n       grok_reference_init (decl, type, init, &cleanup);\n       init = NULL_TREE;\n     }\n@@ -6836,6 +6859,7 @@ grokvardecl (type, declarator, specbits, initialized)\n       decl = build_lang_field_decl (VAR_DECL, declarator, type);\n       DECL_CONTEXT (decl) = basetype;\n       DECL_CLASS_CONTEXT (decl) = basetype;\n+      DECL_ASSEMBLER_NAME (decl) = build_static_name (basetype, declarator);\n     }\n   else\n     decl = build_decl (VAR_DECL, declarator, type);\n@@ -6901,6 +6925,8 @@ build_ptrmemfunc_type (type)\n \n   /* Let the front-end know this is a pointer to member function. */\n   TYPE_PTRMEMFUNC_FLAG(t) = 1;\n+  /* and not really an aggregate.  */\n+  IS_AGGR_TYPE (t) = 0;\n \n   fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier,\n \t\t\t\t     delta_type_node);\n@@ -7327,7 +7353,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t      goto found;\n \t    }\n \n-\t  for (i = (int) RID_FIRST_MODIFIER; i < (int) RID_LAST_MODIFIER; i++)\n+\t  for (i = (int) RID_FIRST_MODIFIER; i <= (int) RID_LAST_MODIFIER; i++)\n \t    {\n \t      if (ridpointers[i] == id)\n \t\t{\n@@ -8031,7 +8057,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \t    type = build_cplus_array_type (type, itype);\n \t    if (constp || volatilep)\n-\t      type = c_build_type_variant (type, constp, volatilep);\n+\t      type = cp_build_type_variant (type, constp, volatilep);\n \n \t    ctype = NULL_TREE;\n \t  }\n@@ -8040,6 +8066,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \tcase CALL_EXPR:\n \t  {\n \t    tree arg_types;\n+\t    int funcdecl_p;\n+\t    tree inner_parms = TREE_OPERAND (declarator, 1);\n+\t    tree inner_decl = TREE_OPERAND (declarator, 0);\n \n \t    /* Declaring a function type.\n \t       Make sure we have a valid type for the function to return.  */\n@@ -8053,7 +8082,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \t    if (constp || volatilep)\n \t      {\n-\t\ttype = c_build_type_variant (type, constp, volatilep);\n+\t\ttype = cp_build_type_variant (type, constp, volatilep);\n \t\tif (IS_AGGR_TYPE (type))\n \t\t  build_pointer_type (type);\n \t\tconstp = 0;\n@@ -8074,8 +8103,17 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\ttype = integer_type_node;\n \t      }\n \n+\t    if (inner_decl && TREE_CODE (inner_decl) == SCOPE_REF)\n+\t      inner_decl = TREE_OPERAND (inner_decl, 1);\n+\n+\t    /* Say it's a definition only for the CALL_EXPR\n+\t       closest to the identifier.  */\n+\t    funcdecl_p =\n+\t      inner_decl && TREE_CODE (inner_decl) == IDENTIFIER_NODE;\n+\n \t    if (ctype == NULL_TREE\n \t\t&& decl_context == FIELD\n+\t\t&& funcdecl_p\n \t\t&& (friendp == 0 || dname == current_class_name))\n \t      ctype = current_class_type;\n \n@@ -8189,27 +8227,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    /* Construct the function type and go to the next\n \t       inner layer of declarator.  */\n \n-\t    {\n-\t      int funcdef_p;\n-\t      tree inner_parms = TREE_OPERAND (declarator, 1);\n-\t      tree inner_decl = TREE_OPERAND (declarator, 0);\n-\n-\t      declarator = TREE_OPERAND (declarator, 0);\n-\n-\t      if (inner_decl && TREE_CODE (inner_decl) == SCOPE_REF)\n-\t\tinner_decl = TREE_OPERAND (inner_decl, 1);\n-\n-\t      /* Say it's a definition only for the CALL_EXPR\n-\t\t closest to the identifier.  */\n-\t      funcdef_p =\n-\t\t(inner_decl && TREE_CODE (inner_decl) == IDENTIFIER_NODE)\n-\t\t  ? funcdef_flag : 0;\n+\t    declarator = TREE_OPERAND (declarator, 0);\n \n-\t      /* FIXME: This is where default args should be fully\n-\t\t processed.  */\n+\t    /* FIXME: This is where default args should be fully\n+\t       processed.  */\n \n-\t      arg_types = grokparms (inner_parms, funcdef_p);\n-\t    }\n+\t    arg_types = grokparms (inner_parms, funcdecl_p ? funcdef_flag : 0);\n \n \t    if (declarator)\n \t      {\n@@ -8264,7 +8287,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t signature pointer/reference itself.  */\n \t      if (! IS_SIGNATURE (type))\n \t\t{\n-\t\t  type = c_build_type_variant (type, constp, volatilep);\n+\t\t  type = cp_build_type_variant (type, constp, volatilep);\n \t\t  if (IS_AGGR_TYPE (type))\n \t\t    build_pointer_type (type);\n \t\t  constp = 0;\n@@ -8559,7 +8582,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n       /* Note that the grammar rejects storage classes\n \t in typenames, fields or parameters.  */\n       if (constp || volatilep)\n-\ttype = c_build_type_variant (type, constp, volatilep);\n+\ttype = cp_build_type_variant (type, constp, volatilep);\n \n       /* If the user declares \"struct {...} foo\" then `foo' will have\n \t an anonymous name.  Fill that name in now.  Nothing can\n@@ -8648,7 +8671,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \tif (IS_SIGNATURE (type))\n \t  error (\"`const' or `volatile' specified with signature type\");\n \telse  \n-\t  type = c_build_type_variant (type, constp, volatilep);\n+\t  type = cp_build_type_variant (type, constp, volatilep);\n \n       /* Special case: \"friend class foo\" looks like a TYPENAME context.  */\n       if (friendp)\n@@ -8730,7 +8753,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  {\n \t    /* Transfer const-ness of array into that of type pointed to. */\n \t    type = build_pointer_type\n-\t      (c_build_type_variant (TREE_TYPE (type), constp, volatilep));\n+\t      (cp_build_type_variant (TREE_TYPE (type), constp, volatilep));\n \t    volatilep = constp = 0;\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -9988,13 +10011,14 @@ xref_tag (code_type_node, name, binfo, globalize)\n \n \t  ref = make_lang_type (code);\n \n-\t  /* A signature type will contain the fields of the signature\n-\t     table.  Therefore, it's not only an interface.  */\n \t  if (tag_code == signature_type)\n \t    {\n \t      SET_SIGNATURE (ref);\n+\t      /* Since a signature type will be turned into the type\n+\t\t of signature tables, it's not only an interface.  */\n \t      CLASSTYPE_INTERFACE_ONLY (ref) = 0;\n-\t      SET_CLASSTYPE_INTERFACE_UNKNOWN (ref);\n+\t      SET_CLASSTYPE_INTERFACE_KNOWN (ref);\n+\t      /* A signature doesn't have a vtable.  */\n \t      CLASSTYPE_VTABLE_NEEDS_WRITING (ref) = 0;\n \t    }\n \n@@ -10125,6 +10149,7 @@ xref_tag (code_type_node, name, binfo, globalize)\n \t      TREE_VIA_PUBLIC (base_binfo) = via_public;\n  \t      TREE_VIA_PROTECTED (base_binfo) = via_protected;\n \t      TREE_VIA_VIRTUAL (base_binfo) = via_virtual;\n+\t      BINFO_INHERITANCE_CHAIN (base_binfo) = TYPE_BINFO (ref);\n \n \t      SET_CLASSTYPE_MARKED (basetype);\n #if 0\n@@ -10226,6 +10251,7 @@ start_enum (name)\n     TREE_ADDRESSABLE (b->tags) = 1;\n   current_local_enum = NULL_TREE;\n \n+#if 0 /* This stuff gets cleared in finish_enum anyway.  */\n   if (TYPE_VALUES (enumtype) != NULL_TREE)\n     /* Completely replace its old definition.\n        The old enumerators remain defined, however.  */\n@@ -10238,7 +10264,8 @@ start_enum (name)\n \n   TYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n   TYPE_SIZE (enumtype) = NULL_TREE;\n-  fixup_unsigned_type (enumtype);\n+  fixup_signed_type (enumtype);\n+#endif\n \n   /* We copy this value because enumerated type constants\n      are really of the type of the enumerator, not integer_type_node.  */\n@@ -10258,84 +10285,78 @@ tree\n finish_enum (enumtype, values)\n      register tree enumtype, values;\n {\n-  register tree pair, tem;\n-  register HOST_WIDE_INT maxvalue = 0;\n-  register HOST_WIDE_INT minvalue = 0;\n-  register HOST_WIDE_INT i;\n-\n+  register tree minnode, maxnode;\n   /* Calculate the maximum value of any enumerator in this type.  */\n \n   if (values)\n     {\n+      register tree pair;\n+      register tree value = DECL_INITIAL (TREE_VALUE (values));\n+      \n       /* Speed up the main loop by performing some precalculations */\n-\n-      HOST_WIDE_INT value;\n       TREE_TYPE (TREE_VALUE (values)) = enumtype;\n-      TREE_TYPE (DECL_INITIAL (TREE_VALUE (values))) = enumtype;\n-      TREE_VALUE (values) = DECL_INITIAL (TREE_VALUE (values));\n-      value = TREE_INT_CST_LOW (TREE_VALUE (values));\n-      minvalue = maxvalue = value;\n+      TREE_TYPE (value) = enumtype;\n+      TREE_VALUE (values) = value;\n+      minnode = maxnode = value;\n       \n       for (pair = TREE_CHAIN (values); pair; pair = TREE_CHAIN (pair))\n \t{\n+\t  value = DECL_INITIAL (TREE_VALUE (pair));\n \t  TREE_TYPE (TREE_VALUE (pair)) = enumtype;\n-\t  TREE_TYPE (DECL_INITIAL (TREE_VALUE (pair))) = enumtype;\n-\t  TREE_VALUE (pair) = DECL_INITIAL (TREE_VALUE (pair));\n-\t  value = TREE_INT_CST_LOW (TREE_VALUE (pair));\n-\t  if (value > maxvalue)\n-\t    maxvalue = value;\n-\t  else if (value < minvalue)\n-\t    minvalue = value;\n+\t  TREE_TYPE (value) = enumtype;\n+\t  TREE_VALUE (pair) = value;\n+\t  if (tree_int_cst_lt (maxnode, value))\n+\t    maxnode = value;\n+\t  else if (tree_int_cst_lt (value, minnode))\n+\t    minnode = value;\n \t}\n     }\n+  else\n+    maxnode = minnode = integer_zero_node;\n \n   TYPE_VALUES (enumtype) = values;\n \n-  if (flag_short_enums)\n-    {\n-      /* Determine the precision this type needs, lay it out, and define\n-         it.  */\n-\n-      /* First reset precision */\n-      TYPE_PRECISION (enumtype) = 0;\n-\n-      for (i = maxvalue; i; i >>= 1)\n-\tTYPE_PRECISION (enumtype)++;\n+  {\n+    int unsignedp = tree_int_cst_sgn (minnode) >= 0;\n+    int lowprec = min_precision (minnode, unsignedp);\n+    int highprec = min_precision (maxnode, unsignedp);\n+    int precision = MAX (lowprec, highprec);\n \n-      if (!TYPE_PRECISION (enumtype))\n-\tTYPE_PRECISION (enumtype) = 1;\n+    if (! flag_short_enums && precision < TYPE_PRECISION (integer_type_node))\n+      precision = TYPE_PRECISION (integer_type_node);\n \n-      /* Cancel the laying out previously done for the enum type,\n-\t so that fixup_unsigned_type will do it over.  */\n-      TYPE_SIZE (enumtype) = NULL_TREE;\n+    /* Unlike the C frontend, we prefer signed types.  */\n+    if (unsignedp && int_fits_type_p (maxnode, type_for_size (precision, 0)))\n+      unsignedp = 0;\n \n+    TYPE_PRECISION (enumtype) = precision;\n+    TYPE_SIZE (enumtype) = NULL_TREE;\n+    if (unsignedp)\n       fixup_unsigned_type (enumtype);\n-    }\n-\n-  TREE_INT_CST_LOW (TYPE_MAX_VALUE (enumtype)) = maxvalue;\n+    else\n+      fixup_signed_type (enumtype);\n+  }\n \n-  /* An enum can have some negative values; then it is signed.  */\n-  if (minvalue < 0)\n-    {\n-      TREE_INT_CST_LOW (TYPE_MIN_VALUE (enumtype)) = minvalue;\n-      TREE_INT_CST_HIGH (TYPE_MIN_VALUE (enumtype)) = -1;\n-      TREE_UNSIGNED (enumtype) = 0;\n-    }\n   if (flag_cadillac)\n     cadillac_finish_enum (enumtype);\n \n-  /* Fix up all variant types of this enum type.  */\n-  for (tem = TYPE_MAIN_VARIANT (enumtype); tem; tem = TYPE_NEXT_VARIANT (tem))\n-    {\n-      TYPE_VALUES (tem) = TYPE_VALUES (enumtype);\n-      TYPE_MIN_VALUE (tem) = TYPE_MIN_VALUE (enumtype);\n-      TYPE_MAX_VALUE (tem) = TYPE_MAX_VALUE (enumtype);\n-      TYPE_SIZE (tem) = TYPE_SIZE (enumtype);\n-      TYPE_MODE (tem) = TYPE_MODE (enumtype);\n-      TYPE_PRECISION (tem) = TYPE_PRECISION (enumtype);\n-      TYPE_ALIGN (tem) = TYPE_ALIGN (enumtype);\n-      TREE_UNSIGNED (tem) = TREE_UNSIGNED (enumtype);\n-    }\n+  {\n+    register tree tem;\n+    \n+    /* Fix up all variant types of this enum type.  */\n+    for (tem = TYPE_MAIN_VARIANT (enumtype); tem;\n+\t tem = TYPE_NEXT_VARIANT (tem))\n+      {\n+\tTYPE_VALUES (tem) = TYPE_VALUES (enumtype);\n+\tTYPE_MIN_VALUE (tem) = TYPE_MIN_VALUE (enumtype);\n+\tTYPE_MAX_VALUE (tem) = TYPE_MAX_VALUE (enumtype);\n+\tTYPE_SIZE (tem) = TYPE_SIZE (enumtype);\n+\tTYPE_MODE (tem) = TYPE_MODE (enumtype);\n+\tTYPE_PRECISION (tem) = TYPE_PRECISION (enumtype);\n+\tTYPE_ALIGN (tem) = TYPE_ALIGN (enumtype);\n+\tTREE_UNSIGNED (tem) = TREE_UNSIGNED (enumtype);\n+      }\n+  }\n \n   /* Finish debugging output for this type.  */\n #if 0\n@@ -11042,59 +11063,6 @@ store_return_init (return_id, init)\n     }\n }\n \n-#if 0\n-/* Generate code for default X() constructor.  */\n-static void\n-build_default_constructor (fndecl)\n-     tree fndecl;\n-{\n-  int i = CLASSTYPE_N_BASECLASSES (current_class_type);\n-  tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n-  tree fields = TYPE_FIELDS (current_class_type);\n-  tree binfos = TYPE_BINFO_BASETYPES (current_class_type);\n-\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-    parm = TREE_CHAIN (parm);\n-  parm = DECL_REFERENCE_SLOT (parm);\n-\n-  while (--i >= 0)\n-    {\n-      tree basetype = TREE_VEC_ELT (binfos, i);\n-      if (TYPE_HAS_INIT_REF (basetype))\n-\t{\n-\t  tree name = TYPE_NAME (basetype);\n-\t  if (TREE_CODE (name) == TYPE_DECL)\n-\t    name = DECL_NAME (name);\n-\t  current_base_init_list = tree_cons (name, parm, current_base_init_list);\n-\t}\n-    }\n-  for (; fields; fields = TREE_CHAIN (fields))\n-    {\n-      tree name, init;\n-      if (TREE_STATIC (fields))\n-\tcontinue;\n-      if (TREE_CODE (fields) != FIELD_DECL)\n-\tcontinue;\n-      if (DECL_NAME (fields))\n-\t{\n-\t  if (VFIELD_NAME_P (DECL_NAME (fields)))\n-\t    continue;\n-\t  if (VBASE_NAME_P (DECL_NAME (fields)))\n-\t    continue;\n-\n-\t  /* True for duplicate members.  */\n-\t  if (IDENTIFIER_CLASS_VALUE (DECL_NAME (fields)) != fields)\n-\t    continue;\n-\t}\n-\n-      init = build (COMPONENT_REF, TREE_TYPE (fields), parm, fields);\n-      init = build_tree_list (NULL_TREE, init);\n-\n-      current_member_init_list\n-\t= tree_cons (DECL_NAME (fields), init, current_member_init_list);\n-    }\n-}\n-#endif\n \f\n /* Finish up a function declaration and compile that function\n    all the way to assembler language output.  The free the storage"}, {"sha": "cc0ab50ff647004eb69a9540357faefa81f046ca", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -212,6 +212,12 @@ int warn_nonvdtor;\n /* Non-zero means warn when a function is declared extern and later inline.  */\n int warn_extern_inline;\n \n+/* Non-zero means warn when the compiler will reorder code.  */\n+int warn_reorder;\n+\n+/* Non-zero means warn when sysnthesis behavior differs from Cfront's.  */\n+int warn_synth;\n+\n /* Nonzero means `$' can be in an identifier.\n    See cccp.c for reasons why this breaks some obscure ANSI C programs.  */\n \n@@ -521,6 +527,10 @@ lang_decode_option (p)\n \twarn_nonvdtor = setting;\n       else if (!strcmp (p, \"extern-inline\"))\n \twarn_extern_inline = setting;\n+      else if (!strcmp (p, \"reorder\"))\n+\twarn_reorder = setting;\n+      else if (!strcmp (p, \"synth\"))\n+\twarn_synth = setting;\n       else if (!strcmp (p, \"comment\"))\n \t;\t\t\t/* cpp handles this one.  */\n       else if (!strcmp (p, \"comments\"))\n@@ -547,6 +557,7 @@ lang_decode_option (p)\n \t  if (warn_uninitialized != 1)\n \t    warn_uninitialized = (setting ? 2 : 0);\n \t  warn_template_debugging = setting;\n+\t  warn_reorder = setting;\n \t}\n \n       else if (!strcmp (p, \"overloaded-virtual\"))\n@@ -1065,11 +1076,20 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n \treturn build1 (NOP_EXPR, void_type_node, t);\n     }\n \n-  /* You can't delete a pointer to constant.  */\n-  if (code == POINTER_TYPE && TREE_READONLY (TREE_TYPE (type)))\n+  if (code == POINTER_TYPE)\n     {\n-      error (\"`const *' cannot be deleted\");\n-      return error_mark_node;\n+      /* You can't delete a pointer to constant.  */\n+      if (TREE_READONLY (TREE_TYPE (type)))\n+\t{\n+\t  error (\"`const *' cannot be deleted\");\n+\t  return error_mark_node;\n+\t}\n+      /* You also can't delete functions.  */\n+      if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+\t{\n+\t  error (\"cannot delete a function\");\n+\t  return error_mark_node;\n+\t}\n     }\n \n #if 0\n@@ -1309,19 +1329,10 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n \t  /* current_class_type can be NULL_TREE in case of error.  */\n \t  if (asmspec == 0 && current_class_type)\n \t    {\n-\t      tree name;\n-\t      char *buf, *buf2;\n-\n-\t      buf2 = build_overload_name (current_class_type, 1, 1);\n-\t      buf = (char *)alloca (IDENTIFIER_LENGTH (DECL_NAME (value))\n-\t\t\t\t    + sizeof (STATIC_NAME_FORMAT)\n-\t\t\t\t    + strlen (buf2));\n-\t      sprintf (buf, STATIC_NAME_FORMAT, buf2,\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (value)));\n-\t      name = get_identifier (buf);\n \t      TREE_PUBLIC (value) = 1;\n \t      DECL_INITIAL (value) = error_mark_node;\n-\t      DECL_ASSEMBLER_NAME (value) = name;\n+\t      DECL_ASSEMBLER_NAME (value)\n+\t\t= build_static_name (current_class_type, DECL_NAME (value));\n \t    }\n \t  pending_statics = perm_tree_cons (NULL_TREE, value, pending_statics);\n \n@@ -1374,9 +1385,11 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n       if (DECL_FRIEND_P (value))\n \treturn void_type_node;\n \n+#if 0 /* Just because a fn is declared doesn't mean we'll try to define it.  */\n       if (current_function_decl && ! IS_SIGNATURE (current_class_type))\n \tcp_error (\"method `%#D' of local class must be defined in class body\",\n \t\t  value);\n+#endif\n \n       DECL_IN_AGGR_P (value) = 1;\n       return value;\n@@ -2591,8 +2604,7 @@ finish_file ()\n   tree fnname;\n   tree vars = static_aggregates;\n   int needs_cleaning = 0, needs_messing_up = 0;\n-\n-  build_exception_table ();\n+  int have_exception_handlers = build_exception_table ();\n \n   if (flag_detailed_statistics)\n     dump_tree_statistics ();\n@@ -2686,7 +2698,7 @@ finish_file ()\n  mess_up:\n   /* Must do this while we think we are at the top level.  */\n   vars = nreverse (static_aggregates);\n-  if (vars != NULL_TREE)\n+  if (vars != NULL_TREE || have_exception_handlers)\n     {\n       fnname = get_file_function_name ('I');\n       start_function (void_list_node, build_parse_node (CALL_EXPR, fnname, void_list_node, NULL_TREE), 0, 0);\n@@ -2698,6 +2710,9 @@ finish_file ()\n       push_momentary ();\n       expand_start_bindings (0);\n \n+      if (have_exception_handlers)\n+\tregister_exception_table ();\n+\n       while (vars)\n \t{\n \t  tree decl = TREE_VALUE (vars);"}, {"sha": "b826283146b2d66b020951dddb781fe1d2a1e078", "filename": "gcc/cp/error.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -571,7 +571,8 @@ dump_decl (t, v)\n       {\n \t/* Don't say 'typedef class A' */\n \ttree type = TREE_TYPE (t);\n-        if (IS_AGGR_TYPE (type) && ! TYPE_PTRMEMFUNC_P (type)\n+        if (((IS_AGGR_TYPE (type) && ! TYPE_PTRMEMFUNC_P (type))\n+\t     || TREE_CODE (type) == ENUMERAL_TYPE)\n \t    && type == TYPE_MAIN_VARIANT (type))\n \t  {\n \t    dump_type (type, v);\n@@ -668,7 +669,7 @@ dump_decl (t, v)\n     case TEMPLATE_DECL:\n       {\n \ttree args = DECL_TEMPLATE_PARMS (t);\n-\tint i, len = TREE_VEC_LENGTH (args);\n+\tint i, len = args ? TREE_VEC_LENGTH (args) : 0;\n \tOB_PUTS (\"template <\");\n \tfor (i = 0; i < len; i++)\n \t  {\n@@ -691,7 +692,8 @@ dump_decl (t, v)\n \t\t\n \t    OB_PUTC2 (',', ' ');\n \t  }\n-\tOB_UNPUT (2);\n+\tif (len != 0)\n+\t  OB_UNPUT (2);\n \tOB_PUTC2 ('>', ' ');\n \n \tif (DECL_TEMPLATE_IS_CLASS (t))\n@@ -1350,12 +1352,26 @@ int\n cp_line_of (t)\n      tree t;\n {\n+  int line = 0;\n   if (TREE_CODE (t) == PARM_DECL)\n-    return DECL_SOURCE_LINE (DECL_CONTEXT (t));\n-  else if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n-    return DECL_SOURCE_LINE (TYPE_NAME (t));\n+    line = DECL_SOURCE_LINE (DECL_CONTEXT (t));\n+  if (TREE_CODE (t) == TYPE_DECL && DECL_ARTIFICIAL (t))\n+    t = TREE_TYPE (t);\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+    {\n+      if (IS_AGGR_TYPE (t))\n+\tline = CLASSTYPE_SOURCE_LINE (t);\n+      else\n+\tline = DECL_SOURCE_LINE (TYPE_NAME (t));\n+    }\n   else\n-    return DECL_SOURCE_LINE (t);\n+    line = DECL_SOURCE_LINE (t);\n+\n+  if (line == 0)\n+    return lineno;\n+\n+  return line;\n }\n \n char *"}, {"sha": "7d748e9ebc1c38dc82cb1707318f64385047a813", "filename": "gcc/cp/except.c", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -58,11 +58,6 @@ sorry_no_eh ()\n     }\n }\n \n-void\n-build_exception_table ()\n-{\n-}\n-\n void\n expand_exception_blocks ()\n {\n@@ -180,29 +175,9 @@ output_exception_table_entry (file, start_label, end_label, eh_label)\n {\n   char label[100];\n \n-  fprintf (file, \"\\t%s\\t \", ASM_LONG);\t\n-  if (GET_CODE (start_label) == CODE_LABEL)\n-    {\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", CODE_LABEL_NUMBER (start_label));\n-      assemble_name (file, label);\n-    }\n-  else if (GET_CODE (start_label) == SYMBOL_REF)\n-    {\n-      fprintf (stderr, \"YYYYYYYYYEEEEEEEESSSSSSSSSSSS!!!!!!!!!!\\n\");\n-      assemble_name (file, XSTR (start_label, 0));\n-    }\n-  putc ('\\n', file);\n-\n-  fprintf (file, \"\\t%s\\t \", ASM_LONG);\n-  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", CODE_LABEL_NUMBER (end_label));\n-  assemble_name (file, label);\n-  putc ('\\n', file);\n-\n-  fprintf (file, \"\\t%s\\t \", ASM_LONG);\n-  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", CODE_LABEL_NUMBER (eh_label));\n-  assemble_name (file, label);\n-  putc ('\\n', file);\n-\n+  assemble_integer (start_label, BITS_PER_WORD/BITS_PER_UNIT, 1);\n+  assemble_integer (end_label, BITS_PER_WORD/BITS_PER_UNIT, 1);\n+  assemble_integer (eh_label, BITS_PER_WORD/BITS_PER_UNIT, 1);\n   putc ('\\n', file);\t\t/* blank line */\n }\n    \n@@ -1436,39 +1411,62 @@ expand_throw (exp)\n   emit_jump (throw_label);\n }\n \n+/* end of: my-cp-except.c */\n+#endif\n \n-/* output the exception table */\n-void\n+\n+/* Output the exception table.\n+ Return the number of handlers.  */\n+int\n build_exception_table ()\n {\n+  int count = 0;\n+#ifdef TRY_NEW_EH\n   extern FILE *asm_out_file;\n   struct ehEntry *entry;\n+  tree eh_node_decl;\n \n   if (! doing_eh (0))\n-    return;\n-\n-  exception_section ();\n-\n-  /* Beginning marker for table. */\n-  fprintf (asm_out_file, \"        .global ___EXCEPTION_TABLE__\\n\");\n-  fprintf (asm_out_file, \"        .align 4\\n\");\n-  fprintf (asm_out_file, \"___EXCEPTION_TABLE__:\\n\");\n-  fprintf (asm_out_file, \"        .word   0, 0, 0\\n\");\n+    return 0;\n \n- while (entry = dequeue_eh_entry (&eh_table_output_queue)) {\n+ while (entry = dequeue_eh_entry (&eh_table_output_queue))\n+   {\n+     if (count == 0)\n+       {\n+\t exception_section ();\n+\n+\t /* Beginning marker for table. */\n+\t ASM_OUTPUT_ALIGN (asm_out_file, 2);\n+\t ASM_OUTPUT_LABEL (asm_out_file, \"__EXCEPTION_TABLE__\");\n+\t fprintf (asm_out_file, \"        .word   0, 0, 0\\n\");\n+       }\n+     count++;\n      output_exception_table_entry (asm_out_file,\n-\t     entry->start_label, entry->end_label, entry->exception_handler_label);\n+\t\t\t\t   entry->start_label, entry->end_label,\n+\t\t\t\t   entry->exception_handler_label);\n   }\n \n-  /* Ending marker for table. */\n-  fprintf (asm_out_file, \"        .global ___EXCEPTION_END__\\n\");\n-  fprintf (asm_out_file, \"___EXCEPTION_END__:\\n\");\n-  fprintf (asm_out_file, \"        .word   -1, -1, -1\\n\");\n-}\n+  if (count)\n+    {\n+      /* Ending marker for table. */\n+      ASM_OUTPUT_LABEL (asm_out_file, \"__EXCEPTION_END__\");\n+      fprintf (asm_out_file, \"        .word   -1, -1, -1\\n\");\n+    }\n \n-/* end of: my-cp-except.c */\n-#endif\n+#endif /* TRY_NEW_EH */\n+  return count;\n+}\n \n+void\n+register_exception_table ()\n+{\n+#ifdef TRY_NEW_EH\n+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__register_exceptions\"), 0,\n+\t\t     VOIDmode, 1,\n+\t\t     gen_rtx (SYMBOL_REF, PTRmode, \"__EXCEPTION_TABLE__\"),\n+\t\t     Pmode);\n+#endif /* TRY_NEW_EH */\n+}\n \n /* Build a throw expression.  */\n tree"}, {"sha": "08f33c0e97c7e1550cac8f857cde6b4beaa1403d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -227,6 +227,7 @@ static tree\n sort_member_init (t)\n      tree t;\n {\n+  extern int warn_reorder;\n   tree x, member, name, field, init;\n   tree init_list = NULL_TREE;\n   tree fields_to_unmark = NULL_TREE;\n@@ -270,7 +271,7 @@ sort_member_init (t)\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (pos < last_pos && extra_warnings)\n+\t\t  if (pos < last_pos && warn_reorder)\n \t\t    {\n \t\t      cp_warning_at (\"member initializers for `%#D'\", last_field);\n \t\t      cp_warning_at (\"  and `%#D'\", field);\n@@ -1130,7 +1131,11 @@ expand_aggr_init (exp, init, alias_this)\n       int was_const_elts = TYPE_READONLY (TREE_TYPE (type));\n       tree itype = init ? TREE_TYPE (init) : NULL_TREE;\n       if (was_const_elts)\n-\tTREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);\n+\t{\n+\t  TREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);\n+\t  if (init)\n+\t    TREE_TYPE (init) = TYPE_MAIN_VARIANT (itype);\n+\t}\n       if (init && TREE_TYPE (init) == NULL_TREE)\n \t{\n \t  /* Handle bad initializers like:\n@@ -1152,7 +1157,8 @@ expand_aggr_init (exp, init, alias_this)\n \t\t       init && comptypes (TREE_TYPE (init), TREE_TYPE (exp), 1));\n       TREE_READONLY (exp) = was_const;\n       TREE_TYPE (exp) = type;\n-      if (init) TREE_TYPE (init) = itype;\n+      if (init)\n+\tTREE_TYPE (init) = itype;\n       return;\n     }\n \n@@ -1200,6 +1206,7 @@ expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n   else if (TREE_CODE (init) == INDIRECT_REF && TREE_HAS_CONSTRUCTOR (init))\n     {\n       rval = convert_for_initialization (exp, type, init, 0, 0, 0, 0);\n+      TREE_USED (rval) = 1;\n       expand_expr_stmt (rval);\n       return;\n     }"}, {"sha": "3a6970bb3e4b6d5437b45c88289c5be7837840c8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 69, "deletions": 74, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -75,6 +75,12 @@ void yyerror ();\n struct obstack inline_text_obstack;\n static char *inline_text_firstobj;\n \n+/* This obstack is used to hold information about methods to be\n+   synthesized.  It should go away when synthesized methods are handled\n+   properly (i.e. only when needed).  */\n+struct obstack synth_obstack;\n+static char *synth_firstobj;\n+\n int end_of_file;\n \n /* Pending language change.\n@@ -564,6 +570,8 @@ init_lex ()\n   init_error ();\n   gcc_obstack_init (&inline_text_obstack);\n   inline_text_firstobj = (char *) obstack_alloc (&inline_text_obstack, 0);\n+  gcc_obstack_init (&synth_obstack);\n+  synth_firstobj = (char *) obstack_alloc (&synth_obstack, 0);\n \n   /* Start it at 0, because check_newline is called at the very beginning\n      and will increment it to 1.  */\n@@ -1086,30 +1094,60 @@ set_vardecl_interface_info (prev, vars)\n void\n do_pending_inlines ()\n {\n-  struct pending_inline *prev = 0, *tail;\n   struct pending_inline *t;\n \n   /* Oops, we're still dealing with the last batch.  */\n   if (yychar == PRE_PARSED_FUNCTION_DECL)\n     return;\n-  \n+\n+  /* Note that we've seen these inlines and are dealing with them.  */\n+  for (t = pending_inlines; t; t = t->next)\n+    t->deja_vu = 1;\n+\n   /* Reverse the pending inline functions, since\n      they were cons'd instead of appended.  */\n-  \n-  for (t = pending_inlines; t; t = tail)\n-    {\n-      t->deja_vu = 1;\n-      tail = t->next;\n-      t->next = prev;\n-      prev = t;\n-    }\n-  /* Reset to zero so that if the inline functions we are currently\n-     processing define inline functions of their own, that is handled\n-     correctly.  ??? This hasn't been checked in a while.  */\n-  pending_inlines = 0;\n-  \n+  {\n+    struct pending_inline *prev = 0, *tail;\n+    t = pending_inlines;\n+    pending_inlines = 0;\n+\n+    for (; t; t = tail)\n+      {\n+\ttail = t->next;\n+\n+\t/* This kludge should go away when synthesized methods are handled\n+\t   properly, i.e. only when needed.  */\n+\tif (t->lineno <= 0)\n+\t  {\n+\t    tree f = t->fndecl;\n+\t    DECL_PENDING_INLINE_INFO (f) = 0;\n+\t    switch (- t->lineno)\n+\t      {\n+\t      case 0: case 1:\n+\t\tbuild_dtor (f); break;\n+\t      case 2:\n+\t\tbuild_default_constructor (f); break;\n+\t      case 3: case 4:\n+\t\tbuild_copy_constructor (f); break;\n+\t      case 5: case 6:\n+\t\tbuild_assign_ref (f); break;\n+\t      default:\n+\t\t;\n+\t      }\n+\t    obstack_free (&synth_obstack, t);\n+\t    continue;\n+\t  }\n+\n+\tt->next = prev;\n+\tprev = t;\n+      }\n+    t = prev;\n+  }\n+\n+  if (t == 0)\n+    return;\n+\t    \n   /* Now start processing the first inline function.  */\n-  t = prev;\n   my_friendly_assert ((t->parm_vec == NULL_TREE) == (t->bindings == NULL_TREE),\n \t\t      226);\n   if (t->parm_vec)\n@@ -1651,8 +1689,8 @@ reinit_parse_for_block (yychar, obstackp, is_template)\n    When KIND == 6, build default operator = (X&).  */\n \n tree\n-cons_up_default_function (type, name, fields, kind)\n-     tree type, name, fields;\n+cons_up_default_function (type, name, kind)\n+     tree type, name;\n      int kind;\n {\n   extern tree void_list_node;\n@@ -1676,43 +1714,27 @@ cons_up_default_function (type, name, fields, kind)\n     case 2:\n       /* Default constructor.  */\n       args = void_list_node;\n-      {\n-\tif (declspecs)\n-\t  declspecs = decl_tree_cons (NULL_TREE,\n-\t\t\t\t      ridpointers [(int) RID_INLINE],\n-\t\t\t\t      declspecs);\n-\telse\n-\t  declspecs = build_decl_list (NULL_TREE, ridpointers [(int) RID_INLINE]);\n-      }\n       break;\n \n     case 3:\n       type = build_type_variant (type, 1, 0);\n       /* Fall through...  */\n     case 4:\n       /* According to ARM $12.8, the default copy ctor will be declared, but\n-\t not defined, unless it's needed.  So we mark this as `inline'; that\n-\t way, if it's never used it won't be emitted.  */\n-      declspecs = build_decl_list (NULL_TREE, ridpointers [(int) RID_INLINE]);\n-\n+\t not defined, unless it's needed.  */\n       argtype = build_reference_type (type);\n       args = tree_cons (NULL_TREE,\n \t\t\tbuild_tree_list (hash_tree_chain (argtype, NULL_TREE),\n \t\t\t\t\t get_identifier (\"_ctor_arg\")),\n \t\t\tvoid_list_node);\n-      default_copy_constructor_body (&func_buf, &func_len, type, fields);\n       break;\n \n     case 5:\n       type = build_type_variant (type, 1, 0);\n       /* Fall through...  */\n     case 6:\n       retref = 1;\n-      declspecs =\n-\tdecl_tree_cons (NULL_TREE, name,\n-\t\t\tdecl_tree_cons (NULL_TREE,\n-\t\t\t\t\tridpointers [(int) RID_INLINE],\n-\t\t\t\t\tNULL_TREE));\n+      declspecs = build_decl_list (NULL_TREE, name);\n \n       name = ansi_opname [(int) MODIFY_EXPR];\n \n@@ -1721,19 +1743,14 @@ cons_up_default_function (type, name, fields, kind)\n \t\t\tbuild_tree_list (hash_tree_chain (argtype, NULL_TREE),\n \t\t\t\t\t get_identifier (\"_ctor_arg\")),\n \t\t\tvoid_list_node);\n-      default_assign_ref_body (&func_buf, &func_len, type, fields);\n       break;\n \n     default:\n       my_friendly_abort (59);\n     }\n \n-  if (!func_buf)\n-    {\n-      func_len = 2;\n-      func_buf = obstack_alloc (&inline_text_obstack, func_len);\n-      strcpy (func_buf, \"{}\");\n-    }\n+  declspecs = decl_tree_cons (NULL_TREE, ridpointers [(int) RID_INLINE],\n+\t\t\t      declspecs);\n \n   TREE_PARMLIST (args) = 1;\n \n@@ -1742,45 +1759,23 @@ cons_up_default_function (type, name, fields, kind)\n     if (retref)\n       declarator = build_parse_node (ADDR_EXPR, declarator);\n     \n-    fn = start_method (declspecs, declarator, NULL_TREE);\n+    fn = grokfield (declarator, declspecs, NULL_TREE, NULL_TREE, NULL_TREE);\n   }\n   \n   if (fn == void_type_node)\n     return fn;\n \n-  current_base_init_list = NULL_TREE;\n-  current_member_init_list = NULL_TREE;\n-\n+  /* This kludge should go away when synthesized methods are handled\n+     properly, i.e. only when needed.  */\n   {\n     struct pending_inline *t;\n-\n-    t = (struct pending_inline *) obstack_alloc (&inline_text_obstack,\n-\t\t\t\t\t\t sizeof (struct pending_inline));\n-    t->lineno = lineno;\n-\n-#if 1\n-    t->filename = input_filename;\n-#else  /* This breaks; why? */\n-#define MGMSG \"(synthetic code at) \"\n-    t->filename = obstack_alloc (&inline_text_obstack,\n-\t\t\t\t strlen (input_filename) + sizeof (MGMSG) + 1);\n-    strcpy (t->filename, MGMSG);\n-    strcat (t->filename, input_filename);\n-#endif\n-    t->token = YYEMPTY;\n-    t->token_value = 0;\n-    t->buf = func_buf;\n-    t->len = func_len;\n-    t->can_free = 1;\n-    t->deja_vu = 0;\n-    if (interface_unknown && processing_template_defn && flag_external_templates && ! DECL_IN_SYSTEM_HEADER (fn))\n-      warn_if_unknown_interface ();\n-    t->interface = (interface_unknown ? 1 : (interface_only ? 0 : 2));\n+    t = (struct pending_inline *)\n+      obstack_alloc (&synth_obstack, sizeof (struct pending_inline));\n+    t->lineno = -kind;\n+    t->can_free = 0;\n     store_pending_inline (fn, t);\n   }\n \n-  finish_method (fn);\n-\n #ifdef DEBUG_DEFAULT_FUNCTIONS\n   { char *fn_type = NULL;\n     tree t = name;\n@@ -1802,14 +1797,13 @@ cons_up_default_function (type, name, fields, kind)\n   }\n #endif /* DEBUG_DEFAULT_FUNCTIONS */\n \n-  DECL_CLASS_CONTEXT (fn) = TYPE_MAIN_VARIANT (type);\n-\n   /* Show that this function was generated by the compiler.  */\n   SET_DECL_ARTIFICIAL (fn);\n   \n   return fn;\n }\n \n+#if 0\n /* Used by default_copy_constructor_body.  For the anonymous union\n    in TYPE, return the member that is at least as large as the rest\n    of the members, so we can copy it.  */\n@@ -2155,6 +2149,7 @@ default_copy_constructor_body (bufp, lenp, type, fields)\n   strcpy (*bufp, prologue.object_base);\n   strcat (*bufp, \"{}\");\n }\n+#endif\n \n /* Heuristic to tell whether the user is missing a semicolon\n    after a struct or enum declaration.  Emit an error message"}, {"sha": "61598fa8c418f2f1bf6765923fdf7a432de34c56", "filename": "gcc/cp/method.c", "status": "modified", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -313,6 +313,7 @@ flush_repeats (type)\n     OB_PUTC ('_');\n }\n \n+static int numeric_outputed_need_bar = 0;\n static void build_overload_identifier ();\n \n static void\n@@ -476,11 +477,17 @@ build_overload_identifier (name)\n \t      /* It's a PARM_DECL.  */\n \t      build_overload_name (TREE_TYPE (parm), 0, 0);\n \t      build_overload_value (parm, arg);\n+\t      numeric_outputed_need_bar = 1;\n \t    }\n \t}\n     }\n   else\n     {\n+      if (numeric_outputed_need_bar)\n+\t{\n+\t  OB_PUTC ('_');\n+\t  numeric_outputed_need_bar = 0;\n+\t}\n       icat (IDENTIFIER_LENGTH (name));\n       OB_PUTID (name);\n     }\n@@ -772,6 +779,7 @@ build_overload_name (parmtypes, begin, end)\n \t\ticat (i);\n \t\tif (i > 9)\n \t\t  OB_PUTC ('_');\n+                numeric_outputed_need_bar = 0;\n \t\tbuild_overload_nested_name (TYPE_NAME (parmtype));\n \t      }\n \t    else\n@@ -817,6 +825,18 @@ build_overload_name (parmtypes, begin, end)\n   if (end) OB_FINISH ();\n   return (char *)obstack_base (&scratch_obstack);\n }\n+\n+tree\n+build_static_name (basetype, name)\n+  tree basetype, name;\n+{\n+  char *basename  = build_overload_name (basetype, 1, 1);\n+  char *buf = (char *) alloca (IDENTIFIER_LENGTH (name)\n+\t\t\t       + sizeof (STATIC_NAME_FORMAT)\n+\t\t\t       + strlen (basename));\n+  sprintf (buf, STATIC_NAME_FORMAT, basename, IDENTIFIER_POINTER (name));\n+  return get_identifier (buf);\n+}  \n \f\n /* Generate an identifier that encodes the (ANSI) exception TYPE. */\n \n@@ -1945,3 +1965,173 @@ emit_thunk (thunk_fndecl)\n   decl_printable_name = save_decl_printable_name;\n   current_function_decl = 0;\n }\n+\f\n+/* Code for synthesizing methods which have default semantics defined.  */\n+\n+void\n+build_default_constructor (fndecl)\n+     tree fndecl;\n+{\n+  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n+  store_parm_decls ();\n+  setup_vtbl_ptr ();\n+  finish_function (lineno, 0);\n+}\n+\n+/* Generate code for default X(X&) constructor.  */\n+void\n+build_copy_constructor (fndecl)\n+     tree fndecl;\n+{\n+  tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n+  tree t;\n+\n+  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n+  store_parm_decls ();\n+  clear_last_expr ();\n+  push_momentary ();\n+\n+  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n+    parm = TREE_CHAIN (parm);\n+  parm = convert_from_reference (parm);\n+\n+  if (! TYPE_HAS_COMPLEX_INIT_REF (current_class_type))\n+    {\n+      t = build (INIT_EXPR, void_type_node, C_C_D, parm);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      cplus_expand_expr_stmt (t);\n+    }\n+  else\n+    {\n+      tree fields = TYPE_FIELDS (current_class_type);\n+      int n_bases = CLASSTYPE_N_BASECLASSES (current_class_type);\n+      tree binfos = TYPE_BINFO_BASETYPES (current_class_type);\n+      int i;\n+\n+      for (t = CLASSTYPE_VBASECLASSES (current_class_type); t;\n+\t   t = TREE_CHAIN (t))\n+\t{\n+\t  tree basetype = BINFO_TYPE (t);\n+\t  tree p = convert (build_reference_type (basetype), parm);\n+\t  p = convert_from_reference (p);\n+\t  current_base_init_list = tree_cons (TYPE_NESTED_NAME (basetype),\n+\t\t\t\t\t      p, current_base_init_list);\n+\t}\n+\t\n+      for (i = 0; i < n_bases; ++i)\n+\t{\n+\t  tree p, basetype = TREE_VEC_ELT (binfos, i);\n+\t  if (TREE_VIA_VIRTUAL (basetype))\n+\t    continue;\t  \n+\n+\t  basetype = BINFO_TYPE (basetype);\n+\t  p = convert (build_reference_type (basetype), parm);\n+\t  p = convert_from_reference (p);\n+\t  current_base_init_list = tree_cons (TYPE_NESTED_NAME (basetype),\n+\t\t\t\t\t      p, current_base_init_list);\n+\t}\n+      for (; fields; fields = TREE_CHAIN (fields))\n+\t{\n+\t  tree name, init;\n+\t  if (TREE_CODE (fields) != FIELD_DECL)\n+\t    continue;\n+\t  if (DECL_NAME (fields))\n+\t    {\n+\t      if (VFIELD_NAME_P (DECL_NAME (fields)))\n+\t\tcontinue;\n+\t      if (VBASE_NAME_P (DECL_NAME (fields)))\n+\t\tcontinue;\n+\n+\t      /* True for duplicate members.  */\n+\t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (fields)) != fields)\n+\t\tcontinue;\n+\t    }\n+\n+\t  init = build (COMPONENT_REF, TREE_TYPE (fields), parm, fields);\n+\t  init = build_tree_list (NULL_TREE, init);\n+\n+\t  current_member_init_list\n+\t    = tree_cons (DECL_NAME (fields), init, current_member_init_list);\n+\t}\n+      current_member_init_list = nreverse (current_member_init_list);\n+      setup_vtbl_ptr ();\n+    }\n+\n+  pop_momentary ();\n+  finish_function (lineno, 0);\n+}\n+\n+void\n+build_assign_ref (fndecl)\n+     tree fndecl;\n+{\n+  tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n+\n+  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n+  store_parm_decls ();\n+  push_momentary ();\n+\n+  parm = convert_from_reference (parm);\n+\n+  if (! TYPE_HAS_COMPLEX_ASSIGN_REF (current_class_type))\n+    {\n+      tree t = build (MODIFY_EXPR, void_type_node, C_C_D, parm);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      cplus_expand_expr_stmt (t);\n+    }\n+  else\n+    {\n+      tree fields = TYPE_FIELDS (current_class_type);\n+      int n_bases = CLASSTYPE_N_BASECLASSES (current_class_type);\n+      tree binfos = TYPE_BINFO_BASETYPES (current_class_type);\n+      int i;\n+\n+      for (i = 0; i < n_bases; ++i)\n+\t{\n+\t  tree basetype = BINFO_TYPE (TREE_VEC_ELT (binfos, i));\n+\t  if (TYPE_HAS_ASSIGN_REF (basetype))\n+\t    {\n+\t      tree p = convert (build_reference_type (basetype), parm);\n+\t      p = convert_from_reference (p);\n+\t      p = build_member_call (TYPE_NESTED_NAME (basetype),\n+\t\t\t\t     ansi_opname [MODIFY_EXPR],\n+\t\t\t\t     build_tree_list (NULL_TREE, p));\n+\t      expand_expr_stmt (p);\n+\t    }\n+\t}\n+      for (; fields; fields = TREE_CHAIN (fields))\n+\t{\n+\t  tree comp, init;\n+\t  if (TREE_CODE (fields) != FIELD_DECL)\n+\t    continue;\n+\t  if (DECL_NAME (fields))\n+\t    {\n+\t      if (VFIELD_NAME_P (DECL_NAME (fields)))\n+\t\tcontinue;\n+\t      if (VBASE_NAME_P (DECL_NAME (fields)))\n+\t\tcontinue;\n+\n+\t      /* True for duplicate members.  */\n+\t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (fields)) != fields)\n+\t\tcontinue;\n+\t    }\n+\n+\t  comp = build (COMPONENT_REF, TREE_TYPE (fields), C_C_D, fields);\n+\t  init = build (COMPONENT_REF, TREE_TYPE (fields), parm, fields);\n+\n+\t  expand_expr_stmt (build_modify_expr (comp, NOP_EXPR, init));\n+\t}\n+    }\n+  c_expand_return (C_C_D);\n+  pop_momentary ();\n+  finish_function (lineno, 0);\n+}\n+\n+void\n+build_dtor (fndecl)\n+     tree fndecl;\n+{\n+  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n+  store_parm_decls ();\n+  finish_function (lineno, 0);\n+}"}, {"sha": "36c8aac6ea5fd6b7a32b3ff5c08617a72e095960", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -3436,6 +3436,8 @@ label_colon:\n \t\t}\n \t| PTYPENAME ':'\n \t\t{ goto do_label; }\n+\t| TYPENAME ':'\n+\t\t{ goto do_label; }\n \t;\n \n forhead.1:"}, {"sha": "ad60480d4c3e5c92800ef792b8e25f4682f9a744", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 46, "deletions": 25, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -333,7 +333,7 @@ grok_template_type (tvec, type)\n         {\n \t  /* we are here for cases like const T* etc. */\n \t  grok_template_type (tvec, &TYPE_MAIN_VARIANT (*type));\n-\t  *type = c_build_type_variant (TYPE_MAIN_VARIANT (*type),\n+\t  *type = cp_build_type_variant (TYPE_MAIN_VARIANT (*type),\n \t\t\t\t\tTYPE_READONLY (*type),\n \t\t\t\t\tTYPE_VOLATILE (*type));\n \t}\n@@ -430,7 +430,8 @@ coerce_template_parms (parms, arglist, in_decl)\n       if (is_type != requires_type)\n \t{\n \t  if (in_decl)\n-\t    cp_error_at (\"type/value mismatch in template parameter list for `%D'\", in_decl);\n+\t    cp_error (\"type/value mismatch in template parameter list for `%D'\",\n+\t\t      in_decl);\n \t  lost++;\n \t  TREE_VEC_ELT (vec, i) = error_mark_node;\n \t  continue;\n@@ -897,15 +898,18 @@ instantiate_member_templates (classname)\n \t\t\t\t     &TREE_VEC_ELT (parmvec, 0));\n \t  type = IDENTIFIER_TYPE_VALUE (id);\n \t  my_friendly_assert (type != 0, 277);\n-\t  if (CLASSTYPE_INTERFACE_UNKNOWN (type))\n+\t  if (flag_external_templates)\n \t    {\n-\t      DECL_EXTERNAL (t2) = 0;\n-\t      TREE_PUBLIC (t2) = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      DECL_EXTERNAL (t2) = CLASSTYPE_INTERFACE_ONLY (type);\n-\t      TREE_PUBLIC (t2) = 1;\n+\t      if (CLASSTYPE_INTERFACE_UNKNOWN (type))\n+\t\t{\n+\t\t  DECL_EXTERNAL (t2) = 0;\n+\t\t  TREE_PUBLIC (t2) = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  DECL_EXTERNAL (t2) = CLASSTYPE_INTERFACE_ONLY (type);\n+\t\t  TREE_PUBLIC (t2) = 1;\n+\t\t}\n \t    }\n \t  break;\n \tcase 1:\n@@ -1157,7 +1161,7 @@ tsubst (t, args, nargs, in_decl)\n       && type != integer_type_node\n       && type != void_type_node\n       && type != char_type_node)\n-    type = c_build_type_variant (tsubst (type, args, nargs, in_decl),\n+    type = cp_build_type_variant (tsubst (type, args, nargs, in_decl),\n \t\t\t\t TYPE_READONLY (type),\n \t\t\t\t TYPE_VOLATILE (type));\n   switch (TREE_CODE (t))\n@@ -1194,7 +1198,7 @@ tsubst (t, args, nargs, in_decl)\n \t tsubst (TYPE_MAX_VALUE (t), args, nargs, in_decl));\n \n     case TEMPLATE_TYPE_PARM:\n-      return c_build_type_variant (args[TEMPLATE_TYPE_IDX (t)],\n+      return cp_build_type_variant (args[TEMPLATE_TYPE_IDX (t)],\n \t\t\t\t   TYPE_READONLY (t),\n \t\t\t\t   TYPE_VOLATILE (t));\n \n@@ -1388,9 +1392,10 @@ tsubst (t, args, nargs, in_decl)\n \n \t      if (!got_it)\n \t\t{\n-\t\t  r = build_decl_overload (r, TYPE_VALUES (type),\n-\t\t\t\t\t   DECL_CONTEXT (t) != NULL_TREE);\n+\t\t  tree a = build_decl_overload (r, TYPE_VALUES (type),\n+\t\t\t\t\t\tDECL_CONTEXT (t) != NULL_TREE);\n \t\t  r = build_lang_decl (FUNCTION_DECL, r, type);\n+\t\t  DECL_ASSEMBLER_NAME (r) = a;\n \t\t}\n \t      else if (DECL_INLINE (r) && DECL_SAVED_INSNS (r))\n \t\t{\n@@ -1424,9 +1429,11 @@ tsubst (t, args, nargs, in_decl)\n \tmake_decl_rtl (r, NULL_PTR, 1);\n \tDECL_ARGUMENTS (r) = fnargs;\n \tDECL_RESULT (r) = result;\n+#if 0\n \tif (DECL_CONTEXT (t) == NULL_TREE\n \t    || TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (t))) != 't')\n \t  push_overloaded_decl_top_level (r, 0);\n+#endif\n \treturn r;\n       }\n \n@@ -1504,7 +1511,7 @@ tsubst (t, args, nargs, in_decl)\n \t  r = build_pointer_type (type);\n \telse\n \t  r = build_reference_type (type);\n-\tr = c_build_type_variant (r, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+\tr = cp_build_type_variant (r, TYPE_READONLY (t), TYPE_VOLATILE (t));\n \t/* Will this ever be needed for TYPE_..._TO values?  */\n \tlayout_type (r);\n \treturn r;\n@@ -2137,7 +2144,10 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n \n     case REAL_TYPE:\n     case INTEGER_TYPE:\n-      if (TREE_CODE (parm) == INTEGER_TYPE && TREE_CODE (arg) == INTEGER_TYPE)\n+      if (TREE_CODE (arg) != TREE_CODE (parm))\n+\treturn 1;\n+\n+      if (TREE_CODE (parm) == INTEGER_TYPE)\n \t{\n \t  if (TYPE_MIN_VALUE (parm) && TYPE_MIN_VALUE (arg)\n \t      && unify (tparms, targs, ntparms,\n@@ -2464,22 +2474,32 @@ do_type_instantiation (name, storage)\n       return;\n     }\n \n-  SET_CLASSTYPE_EXPLICIT_INSTANTIATION (t);\n-  if (! extern_p)\n+  if (! CLASSTYPE_TEMPLATE_SPECIALIZATION (t))\n     {\n-      SET_CLASSTYPE_INTERFACE_KNOWN (t);\n-      CLASSTYPE_INTERFACE_ONLY (t) = 0;\n-      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = 1;\n-      CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n-      TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n-      rest_of_type_compilation (t, 1);\n+      SET_CLASSTYPE_EXPLICIT_INSTANTIATION (t);\n+      if (! extern_p)\n+\t{\n+\t  SET_CLASSTYPE_INTERFACE_KNOWN (t);\n+\t  CLASSTYPE_INTERFACE_ONLY (t) = 0;\n+\t  CLASSTYPE_VTABLE_NEEDS_WRITING (t) = 1;\n+\t  CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n+\t  TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n+\t  rest_of_type_compilation (t, 1);\n+\t}\n     }\n \n+  instantiate_member_templates (TYPE_IDENTIFIER (t));\n+\n   /* this should really be done by instantiate_member_templates */\n   {\n     tree tmp = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n     for (; tmp; tmp = TREE_CHAIN (tmp))\n       {\n+\tif (DECL_TEMPLATE_SPECIALIZATION (tmp)\n+\t    || (DECL_USE_TEMPLATE (tmp) == 0\n+\t\t&& CLASSTYPE_TEMPLATE_SPECIALIZATION (t)))\n+\t  continue;\n+\n \tSET_DECL_EXPLICIT_INSTANTIATION (tmp);\n \tif (! extern_p)\n \t  {\n@@ -2498,7 +2518,8 @@ do_type_instantiation (name, storage)\n #endif\n \n     for (tmp = CLASSTYPE_TAGS (t); tmp; tmp = TREE_CHAIN (tmp))\n-      do_type_instantiation (TREE_VALUE (tmp), storage);\n+      if (IS_AGGR_TYPE (TREE_VALUE (tmp)))\n+\tdo_type_instantiation (TYPE_MAIN_DECL (TREE_VALUE (tmp)), storage);\n   }\n }\n "}, {"sha": "65938b39521af736c4dd8755568024c9ffdef5e0", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -177,7 +177,7 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n       }\n     else\n       {\n-\ttree sig_tbl_type = c_build_type_variant (to_type, 1, 0);\n+\ttree sig_tbl_type = cp_build_type_variant (to_type, 1, 0);\n \t\n \tsptr = build_lang_field_decl (FIELD_DECL,\n \t\t\t\t      get_identifier (SIGNATURE_SPTR_NAME),"}, {"sha": "f598fe0eefdb5e3f7ffc7b4f35c2fc1381c84b4e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -230,12 +230,15 @@ break_out_calls (exp)\n       return exp;\n \n     case 'd':  /* A decl node */\n+#if 0                               /* This is bogus.  jason 9/21/94 */\n+\n       t1 = break_out_calls (DECL_INITIAL (exp));\n       if (t1 != DECL_INITIAL (exp))\n \t{\n \t  exp = copy_node (exp);\n \t  DECL_INITIAL (exp) = t1;\n \t}\n+#endif\n       return exp;\n \n     case 'b':  /* A block node */\n@@ -388,6 +391,40 @@ build_cplus_array_type (elt_type, index_type)\n   return t;\n }\n \f\n+/* Make a variant type in the proper way for C/C++, propagating qualifiers\n+   down to the element type of an array.  */\n+\n+tree\n+cp_build_type_variant (type, constp, volatilep)\n+     tree type;\n+     int constp, volatilep;\n+{\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      tree real_main_variant = TYPE_MAIN_VARIANT (type);\n+\n+      push_obstacks (TYPE_OBSTACK (real_main_variant),\n+\t\t     TYPE_OBSTACK (real_main_variant));\n+      type = build_cplus_array_type (cp_build_type_variant (TREE_TYPE (type),\n+\t\t\t\t\t\t\t    constp, volatilep),\n+\t\t\t\t     TYPE_DOMAIN (type));\n+\n+      /* TYPE must be on same obstack as REAL_MAIN_VARIANT.  If not,\n+\t make a copy.  (TYPE might have come from the hash table and\n+\t REAL_MAIN_VARIANT might be in some function's obstack.)  */\n+\n+      if (TYPE_OBSTACK (type) != TYPE_OBSTACK (real_main_variant))\n+\t{\n+\t  type = copy_node (type);\n+\t  TYPE_POINTER_TO (type) = TYPE_REFERENCE_TO (type) = 0;\n+\t}\n+\n+      TYPE_MAIN_VARIANT (type) = real_main_variant;\n+      pop_obstacks ();\n+    }\n+  return build_type_variant (type, constp, volatilep);\n+}\n+\f\n /* Add OFFSET to all base types of T.\n \n    OFFSET, which is a type offset, is number of bytes."}, {"sha": "b4b7e2dea688a2e2fcdf01d584d1b29ced062f6e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 43, "deletions": 54, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -161,7 +161,7 @@ qualify_type (type, like)\n   int constflag = TYPE_READONLY (type) || TYPE_READONLY (like);\n   int volflag = TYPE_VOLATILE (type) || TYPE_VOLATILE (like);\n   /* @@ Must do member pointers here.  */\n-  return c_build_type_variant (type, constflag, volflag);\n+  return cp_build_type_variant (type, constflag, volflag);\n }\n \f\n /* Return the common type of two parameter lists.\n@@ -372,7 +372,7 @@ common_type (t1, t2)\n \t  = TYPE_READONLY (TREE_TYPE (t1)) || TYPE_READONLY (TREE_TYPE (t2));\n \tint volatilep\n \t  = TYPE_VOLATILE (TREE_TYPE (t1)) || TYPE_VOLATILE (TREE_TYPE (t2));\n-\ttarget = c_build_type_variant (target, constp, volatilep);\n+\ttarget = cp_build_type_variant (target, constp, volatilep);\n \tif (code1 == POINTER_TYPE)\n \t  t1 = build_pointer_type (target);\n \telse\n@@ -1378,7 +1378,7 @@ default_conversion (exp)\n       restype = TREE_TYPE (type);\n       if (TYPE_READONLY (type) || TYPE_VOLATILE (type)\n \t  || constp || volatilep)\n-\trestype = c_build_type_variant (restype,\n+\trestype = cp_build_type_variant (restype,\n \t\t\t\t\tTYPE_READONLY (type) || constp,\n \t\t\t\t\tTYPE_VOLATILE (type) || volatilep);\n       ptrtype = build_pointer_type (restype);\n@@ -1533,8 +1533,7 @@ build_component_ref (datum, component, basetype_path, protect)\n   register tree field = NULL;\n   register tree ref;\n \n-  /* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference inside it\n-     unless we are not to support things not strictly ANSI.  */\n+  /* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference inside it. */\n   switch (TREE_CODE (datum))\n     {\n     case COMPOUND_EXPR:\n@@ -1706,7 +1705,8 @@ build_component_ref (datum, component, basetype_path, protect)\n       datum = build_indirect_ref (addr, NULL_PTR);\n       my_friendly_assert (datum != error_mark_node, 311);\n     }\n-  ref = build (COMPONENT_REF, TREE_TYPE (field), break_out_cleanups (datum), field);\n+  ref = fold (build (COMPONENT_REF, TREE_TYPE (field),\n+\t\t     break_out_cleanups (datum), field));\n \n   if (TREE_READONLY (datum) || TREE_READONLY (field))\n     TREE_READONLY (ref) = 1;\n@@ -2619,7 +2619,7 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n       /* See if there are default arguments that can be used */\n       if (TREE_PURPOSE (typetail))\n \t{\n-\t  while (typetail != void_list_node)\n+\t  for (; typetail != void_list_node; ++i)\n \t    {\n \t      tree type = TREE_VALUE (typetail);\n \t      tree val = TREE_PURPOSE (typetail);\n@@ -4102,42 +4102,16 @@ build_unary_op (code, xarg, noconvert)\n \n       if (TREE_CODE (arg) == TREE_LIST)\n \t{\n-\t  /* Look at methods with only this name.  */\n-\t  if (TREE_CODE (TREE_VALUE (arg)) == FUNCTION_DECL)\n-\t    {\n-\t      tree targ = TREE_VALUE (arg);\n-\n-\t      /* If this function is unique, or it is a unique\n-\t\t constructor, we can take its address easily.  */\n-\t      if (DECL_CHAIN (targ) == NULL_TREE\n-\t\t  || (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (targ))\n-\t\t      && DECL_CHAIN (DECL_CHAIN (targ)) == NULL_TREE))\n-\t\t{\n-\t\t  if (DECL_CHAIN (targ))\n-\t\t    targ = DECL_CHAIN (targ);\n-\t\t  if (DECL_CLASS_CONTEXT (targ))\n-\t\t    targ = build (OFFSET_REF, TREE_TYPE (targ), C_C_D, targ);\n-\n-\t\t  val = unary_complex_lvalue (ADDR_EXPR, targ);\n-\t\t  if (val)\n-\t\t    return val;\n-\t\t}\n-\n-\t      /* This possible setting of TREE_CONSTANT is what makes it possible\n-\t\t with an initializer list to emit the entire thing in the data\n-\t\t section, rather than a run-time initialization.  */\n-\t      arg = build1 (ADDR_EXPR, unknown_type_node, arg);\n-\t      if (staticp (targ))\n-\t\tTREE_CONSTANT (arg) = 1;\n-\t      return arg;\n-\t    }\n+\t  if (TREE_CODE (TREE_VALUE (arg)) == FUNCTION_DECL\n+\t      && DECL_CHAIN (TREE_VALUE (arg)) == NULL_TREE)\n+\t    /* Unique overloaded non-member function.  */\n+\t    return build_unary_op (ADDR_EXPR, TREE_VALUE (arg), 0);\n \t  if (TREE_CHAIN (arg) == NULL_TREE\n \t      && TREE_CODE (TREE_VALUE (arg)) == TREE_LIST\n \t      && DECL_CHAIN (TREE_VALUE (TREE_VALUE (arg))) == NULL_TREE)\n-\t    {\n-\t      /* Unique overloaded member function.  */\n-\t      return build_unary_op (ADDR_EXPR, TREE_VALUE (TREE_VALUE (arg)), 0);\n-\t    }\n+\t    /* Unique overloaded member function.  */\n+\t    return build_unary_op (ADDR_EXPR, TREE_VALUE (TREE_VALUE (arg)),\n+\t\t\t\t   0);\n \t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n \t}\n \n@@ -4179,7 +4153,7 @@ build_unary_op (code, xarg, noconvert)\n \t  || TREE_CODE_CLASS (TREE_CODE (arg)) == 'r')\n \t{\n \t  if (TREE_READONLY (arg) || TREE_THIS_VOLATILE (arg))\n-\t    argtype = c_build_type_variant (argtype,\n+\t    argtype = cp_build_type_variant (argtype,\n \t\t\t\t\t    TREE_READONLY (arg),\n \t\t\t\t\t    TREE_THIS_VOLATILE (arg));\n \t}\n@@ -4587,7 +4561,7 @@ build_conditional_expr (ifexp, op1, op2)\n       else if (TREE_READONLY_DECL_P (op2))\n \top2 = decl_constant_value (op2);\n       if (type1 != type2)\n-\ttype1 = c_build_type_variant\n+\ttype1 = cp_build_type_variant\n \t\t\t(type1,\n \t\t\t TREE_READONLY (op1) || TREE_READONLY (op2),\n \t\t\t TREE_THIS_VOLATILE (op1) || TREE_THIS_VOLATILE (op2));\n@@ -4636,7 +4610,7 @@ build_conditional_expr (ifexp, op1, op2)\n       if (type1 == type2)\n \tresult_type = type1;\n       else\n-\tresult_type = c_build_type_variant\n+\tresult_type = cp_build_type_variant\n \t\t\t(type1,\n \t\t\t TREE_READONLY (op1) || TREE_READONLY (op2),\n \t\t\t TREE_THIS_VOLATILE (op1) || TREE_THIS_VOLATILE (op2));\n@@ -5025,6 +4999,9 @@ build_c_cast (type, expr)\n \twarning (\"cast to pointer from integer of different size\");\n #endif\n \n+      if (TREE_READONLY_DECL_P (value))\n+\tvalue = decl_constant_value (value);\n+\n       ovalue = value;\n       value = convert_force (type, value);\n \n@@ -5349,13 +5326,13 @@ build_modify_expr (lhs, modifycode, rhs)\n   tree olhstype = lhstype;\n   tree olhs = lhs;\n \n-  /* Types that aren't fully specified cannot be used in assignments.  */\n-  lhs = require_complete_type (lhs);\n-\n   /* Avoid duplicate error messages from operands that had errors.  */\n   if (TREE_CODE (lhs) == ERROR_MARK || TREE_CODE (rhs) == ERROR_MARK)\n     return error_mark_node;\n \n+  /* Types that aren't fully specified cannot be used in assignments.  */\n+  lhs = require_complete_type (lhs);\n+\n   /* Decide early if we are going to protect RHS from GC\n      before assigning it to LHS.  */\n   if (type_needs_gc_entry (TREE_TYPE (rhs))\n@@ -5786,10 +5763,12 @@ build_modify_expr (lhs, modifycode, rhs)\n \n   if (TREE_CODE (lhstype) == ARRAY_TYPE)\n     {\n+      int from_array;\n+      \n       /* Allow array assignment in compiler-generated code.  */\n       if ((pedantic || flag_ansi)\n \t  && ! DECL_ARTIFICIAL (current_function_decl))\n-\tpedwarn (\"ANSI C++ forbids assignment between arrays\");\n+\tpedwarn (\"ANSI C++ forbids assignment of arrays\");\n \n       /* Have to wrap this in RTL_EXPR for two cases:\n \t in base or member initialization and if we\n@@ -5805,8 +5784,10 @@ build_modify_expr (lhs, modifycode, rhs)\n       /* As a matter of principle, `start_sequence' should do this.  */\n       emit_note (0, -1);\n \n+      from_array = TREE_CODE (TREE_TYPE (newrhs)) == ARRAY_TYPE\n+\t           ? 1 + (modifycode != INIT_EXPR): 0;\n       expand_vec_init (lhs, lhs, array_type_nelts (lhstype), newrhs,\n-\t\t       1 + (modifycode != INIT_EXPR));\n+\t\t       from_array);\n \n       do_pending_stack_adjust ();\n \n@@ -6124,12 +6105,15 @@ build_ptrmemfunc (type, pfn, force)\n       return digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n     }\n \n-  if (TREE_CODE (pfn) == TREE_LIST)\n+  if (TREE_CODE (pfn) == TREE_LIST\n+      || (TREE_CODE (pfn) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (pfn, 0)) == TREE_LIST))\n     {\n       pfn = instantiate_type (type, pfn, 1);\n       if (pfn == error_mark_node)\n \treturn error_mark_node;\n-      pfn = build_unary_op (ADDR_EXPR, pfn, 0);\n+      if (TREE_CODE (pfn) != ADDR_EXPR)\n+\tpfn = build_unary_op (ADDR_EXPR, pfn, 0);\n     }\n \n   /* Allow pointer to member conversions here. */\n@@ -6585,10 +6569,11 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t}\n       return null_pointer_node;\n     }\n-  else if (codel == INTEGER_TYPE\n+  else if ((codel == INTEGER_TYPE || codel == BOOLEAN_TYPE)\n \t   && (coder == POINTER_TYPE\n \t       || (coder == RECORD_TYPE\n \t\t   && (IS_SIGNATURE_POINTER (rhstype)\n+\t\t       || TYPE_PTRMEMFUNC_FLAG (rhstype)\n \t\t       || IS_SIGNATURE_REFERENCE (rhstype)))))\n     {\n       if (fndecl)\n@@ -6741,7 +6726,8 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n       && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type)))\n     return build_signature_pointer_constructor (type, rhs);\n \n-  if (IS_AGGR_TYPE (type) && TYPE_NEEDS_CONSTRUCTING (type))\n+  if (IS_AGGR_TYPE (type)\n+      && (TYPE_NEEDS_CONSTRUCTING (type) || TREE_HAS_CONSTRUCTOR (rhs)))\n     {\n       if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (rhstype))\n \t{\n@@ -6997,8 +6983,11 @@ c_expand_return (retval)\n \t  while (TREE_CODE (whats_returned) == NEW_EXPR\n \t\t || TREE_CODE (whats_returned) == TARGET_EXPR\n \t\t || TREE_CODE (whats_returned) == WITH_CLEANUP_EXPR)\n-\t    /* Get the target.  */\n-\t    whats_returned = TREE_OPERAND (whats_returned, 0);\n+\t    {\n+\t      /* Get the target.  */\n+\t      whats_returned = TREE_OPERAND (whats_returned, 0);\n+\t      warning (\"returning reference to temporary\");\n+\t    }\n \t}\n \n       if (TREE_CODE (whats_returned) == VAR_DECL && DECL_NAME (whats_returned))"}, {"sha": "65e4ba77fb323d4b672302f68432b34bb10ad4e6", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f376e137d46ac34615746a297d8bc1d9f9fd7eca/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=f376e137d46ac34615746a297d8bc1d9f9fd7eca", "patch": "@@ -599,6 +599,7 @@ store_init_value (decl, init)\n \t       ))\n \n     return value;\n+#if 0 /* No, that's C.  jason 9/19/94 */\n   else\n     {\n       if (pedantic && TREE_CODE (value) == CONSTRUCTOR\n@@ -613,6 +614,7 @@ store_init_value (decl, init)\n \t    pedwarn (\"ANSI C++ forbids non-constant aggregate initializer expressions\");\n \t}\n     }\n+#endif\n   DECL_INITIAL (decl) = value;\n   return NULL_TREE;\n }\n@@ -659,8 +661,9 @@ digest_init (type, init, tail)\n \n   if (init && TYPE_PTRMEMFUNC_P (type)\n       && ((TREE_CODE (init) == ADDR_EXPR\n-\t   && TREE_CODE (TREE_TYPE (init)) == POINTER_TYPE\n-\t   && TREE_CODE (TREE_TYPE (TREE_TYPE (init))) == METHOD_TYPE)\n+\t   && ((TREE_CODE (TREE_TYPE (init)) == POINTER_TYPE\n+\t\t&& TREE_CODE (TREE_TYPE (TREE_TYPE (init))) == METHOD_TYPE)\n+\t       || TREE_CODE (TREE_OPERAND (init, 0)) == TREE_LIST))\n \t  || TREE_CODE (init) == TREE_LIST\n \t  || integer_zerop (init)\n \t  || (TREE_TYPE (init) && TYPE_PTRMEMFUNC_P (TREE_TYPE (init)))))"}]}