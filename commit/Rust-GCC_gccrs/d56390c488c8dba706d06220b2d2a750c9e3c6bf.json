{"sha": "d56390c488c8dba706d06220b2d2a750c9e3c6bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU2MzkwYzQ4OGM4ZGJhNzA2ZDA2MjIwYjJkMmE3NTBjOWUzYzZiZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-08-15T21:57:41Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-08-15T21:57:41Z"}, "message": "(ediv, emul): Set sign bit of IEEE -0.0 result.\n\nFrom-SVN: r10244", "tree": {"sha": "901fd3ba32cfc6cef114ac588283b5ef1723462a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/901fd3ba32cfc6cef114ac588283b5ef1723462a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d56390c488c8dba706d06220b2d2a750c9e3c6bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56390c488c8dba706d06220b2d2a750c9e3c6bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d56390c488c8dba706d06220b2d2a750c9e3c6bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56390c488c8dba706d06220b2d2a750c9e3c6bf/comments", "author": null, "committer": null, "parents": [{"sha": "f4510f3757fc32ae871aa5e7c77a078590b173ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4510f3757fc32ae871aa5e7c77a078590b173ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4510f3757fc32ae871aa5e7c77a078590b173ed"}], "stats": {"total": 74, "additions": 41, "deletions": 33}, "files": [{"sha": "082cfd03af130c477df65df0dcb4b044dbbb1bec", "filename": "gcc/real.c", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56390c488c8dba706d06220b2d2a750c9e3c6bf/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56390c488c8dba706d06220b2d2a750c9e3c6bf/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=d56390c488c8dba706d06220b2d2a750c9e3c6bf", "patch": "@@ -2635,9 +2635,13 @@ ediv (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n   unsigned EMUSHORT ai[NI], bi[NI];\n-  int i;\n+  int i, sign;\n   EMULONG lt, lta, ltb;\n \n+/* IEEE says if result is not a NaN, the sign is \"-\" if and only if\n+   operands have opposite signs -- but flush -0 to 0 later if not IEEE.  */\n+  sign = eisneg(a) ^ eisneg(b);\n+\n #ifdef NANS\n /* Return any NaN input. */\n   if (eisnan (a))\n@@ -2655,26 +2659,22 @@ ediv (a, b, c)\n       || (eisinf (a) && eisinf (b)))\n     {\n     mtherr (\"ediv\", INVALID);\n-    enan (c, eisneg (a) ^ eisneg (b));\n+    enan (c, sign);\n     return;\n     }\n #endif\n /* Infinity over anything else is infinity. */\n #ifdef INFINITY\n   if (eisinf (b))\n     {\n-      if (eisneg (a) ^ eisneg (b))\n-\t*(c + (NE - 1)) = 0x8000;\n-      else\n-\t*(c + (NE - 1)) = 0;\n       einfin (c);\n-      return;\n+      goto divsign;\n     }\n /* Anything else over infinity is zero. */\n   if (eisinf (a))\n     {\n       eclear (c);\n-      return;\n+      goto divsign;\n     }\n #endif\n   emovi (a, ai);\n@@ -2692,7 +2692,7 @@ ediv (a, b, c)\n \t    }\n \t}\n       eclear (c);\n-      return;\n+      goto divsign;\n     }\n  dnzro1:\n \n@@ -2706,28 +2706,30 @@ ediv (a, b, c)\n \t      goto dnzro2;\n \t    }\n \t}\n-      if (ai[0] == bi[0])\n-\t*(c + (NE - 1)) = 0;\n-      else\n-\t*(c + (NE - 1)) = 0x8000;\n /* Divide by zero is not an invalid operation.\n    It is a divide-by-zero operation!   */\n       einfin (c);\n       mtherr (\"ediv\", SING);\n-      return;\n+      goto divsign;\n     }\n  dnzro2:\n \n   i = edivm (ai, bi);\n   /* calculate exponent */\n   lt = ltb - lta + EXONE;\n   emdnorm (bi, i, 0, lt, 64);\n-  /* set the sign */\n-  if (ai[0] == bi[0])\n-    bi[0] = 0;\n-  else\n-    bi[0] = 0Xffff;\n   emovo (bi, c);\n+\n+ divsign:\n+\n+  if (sign\n+#ifndef IEEE\n+      && (ecmp (c, ezero) != 0)\n+#endif\n+      )\n+     *(c+(NE-1)) |= 0x8000;\n+  else\n+     *(c+(NE-1)) &= ~0x8000;\n }\n \n /* Multiply e-types A and B, return e-type product C.   */\n@@ -2737,9 +2739,13 @@ emul (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n   unsigned EMUSHORT ai[NI], bi[NI];\n-  int i, j;\n+  int i, j, sign;\n   EMULONG lt, lta, ltb;\n \n+/* IEEE says if result is not a NaN, the sign is \"-\" if and only if\n+   operands have opposite signs -- but flush -0 to 0 later if not IEEE.  */\n+  sign = eisneg(a) ^ eisneg(b);\n+\n #ifdef NANS\n /* NaN times anything is the same NaN. */\n   if (eisnan (a))\n@@ -2757,20 +2763,16 @@ emul (a, b, c)\n       || (eisinf (b) && (ecmp (a, ezero) == 0)))\n     {\n     mtherr (\"emul\", INVALID);\n-    enan (c, eisneg (a) ^ eisneg (b));\n+    enan (c, sign);\n     return;\n     }\n #endif\n /* Infinity times anything else is infinity. */\n #ifdef INFINITY\n   if (eisinf (a) || eisinf (b))\n     {\n-      if (eisneg (a) ^ eisneg (b))\n-\t*(c + (NE - 1)) = 0x8000;\n-      else\n-\t*(c + (NE - 1)) = 0;\n       einfin (c);\n-      return;\n+      goto mulsign;\n     }\n #endif\n   emovi (a, ai);\n@@ -2788,7 +2790,7 @@ emul (a, b, c)\n \t    }\n \t}\n       eclear (c);\n-      return;\n+      goto mulsign;\n     }\n  mnzer1:\n \n@@ -2803,7 +2805,7 @@ emul (a, b, c)\n \t    }\n \t}\n       eclear (c);\n-      return;\n+      goto mulsign;\n     }\n  mnzer2:\n \n@@ -2812,12 +2814,18 @@ emul (a, b, c)\n   /* calculate exponent */\n   lt = lta + ltb - (EXONE - 1);\n   emdnorm (bi, j, 0, lt, 64);\n-  /* calculate sign of product */\n-  if (ai[0] == bi[0])\n-    bi[0] = 0;\n-  else\n-    bi[0] = 0xffff;\n   emovo (bi, c);\n+\n+ mulsign:\n+\n+  if (sign\n+#ifndef IEEE\n+      && (ecmp (c, ezero) != 0)\n+#endif\n+      )\n+     *(c+(NE-1)) |= 0x8000;\n+  else\n+     *(c+(NE-1)) &= ~0x8000;\n }\n \n /* Convert double precision PE to e-type Y.  */"}]}