{"sha": "33977f81620a3e495be87d0381544f8ad26b2782", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM5NzdmODE2MjBhM2U0OTViZTg3ZDAzODE1NDRmOGFkMjZiMjc4Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-03-28T19:29:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-03-28T19:29:35Z"}, "message": "attr-noinline.c: Avoid pure-const optimization.\n\n\n\t* gcc.dg/attr-noinline.c: Avoid pure-const optimization.\n\t* gcc.dg/pr33826.c: Update dump files.\n\t* gcc.dg/ipa/ipa-3.c: Avoid pure-const optimization.\n\t* gcc.dg/ipa/ipa-5.c: Avoid pure-const optimization.\n\n\tMerge from pretty-ipa:\n\n\t2009-03-27  Jan Hubicka  <jh@suse.cz>\n\t* cgraph.c (dump_cgraph_node): Add replace output flag by process.\n\t* tree-pass.h (function_called_by_processed_nodes_p): Declare.\n\t* passes.c (function_called_by_processed_nodes_p): New.\n\t* ipa-pure-const.c (check_call): Fix handling of operands.\n\t(analyze_function): Dump debug output for skipped bodies.\n\t(local_pure_const): Use function_called_by_processed_nodes_p.\n\t* dwarf2out.c (reference_to_unused): Use output.\n\t* passes.c (do_per_function_toporder): Likewise.\n\n\t2008-11-12  Jan Hubicka  <jh@suse.cz>\n\n\t* tree-pass.h (pass_fixup_cfg, pass_local_pure_const): Declare.\n\t* ipa-pure-const.c (funct_state_d): Add can throw field; make\n\tstate_set_in_source enum\n\t(check_decl): Ignore memory tags; do not set fake looping flags;\n\tdump diagnostics.\n\t(check_operand, check_tree, check_rhs_var, check_lhs_var,\n\tget_asm_expr_operands, scan_function_op, scan_function_stmt): Remove.\n\t(check_call, analyze_function): Rewrite.\n\t(check_stmt): New.\n\t(add_new_function): Update call of analyze_function.\n\t(generate_summary): Add call of analyze_function.\n\t(propagate): Propagate can_throw; handle state_set_in_source correctly.\n\t(local_pure_const): New function.\n\t(pass_local_pure_const): New pass.\n\t* ipa-inline.c (inline_transform): Set after_inlining.\n\t* tree-eh.c (stmt_can_throw_external): New.\n\t* tree-optimize.c (execute_fixup_cfg): Do not set after_inlining;\n\twork with aliasing built.\n\t* tree-flow.h (stmt_can_throw_external): New.\n\t* passes.c (init_optimization_passes): Schedule fixup_cfg pass early;\n\tand local pure/const pass in early and late optimization queue.\n\nFrom-SVN: r145204", "tree": {"sha": "8cf78aab3664efc13cb9bc78131a15282b59ac4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cf78aab3664efc13cb9bc78131a15282b59ac4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33977f81620a3e495be87d0381544f8ad26b2782", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33977f81620a3e495be87d0381544f8ad26b2782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33977f81620a3e495be87d0381544f8ad26b2782", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33977f81620a3e495be87d0381544f8ad26b2782/comments", "author": null, "committer": null, "parents": [{"sha": "617f389789b78deae9670bd5d2716d8189dcde58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617f389789b78deae9670bd5d2716d8189dcde58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617f389789b78deae9670bd5d2716d8189dcde58"}], "stats": {"total": 1035, "additions": 585, "deletions": 450}, "files": [{"sha": "ee45bf8336984101c245b241b485bef6a9ed24a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -1,3 +1,40 @@\n+2009-03-28  Jan Hubicka  <jh@suse.cz>\n+\n+\tMerge from pretty-ipa:\n+\n+\t2009-03-27  Jan Hubicka  <jh@suse.cz>\n+\t* cgraph.c (dump_cgraph_node): Add replace output flag by process.\n+\t* tree-pass.h (function_called_by_processed_nodes_p): Declare.\n+\t* passes.c (function_called_by_processed_nodes_p): New.\n+\t* ipa-pure-const.c (check_call): Fix handling of operands.\n+\t(analyze_function): Dump debug output for skipped bodies.\n+\t(local_pure_const): Use function_called_by_processed_nodes_p.\n+\t* dwarf2out.c (reference_to_unused): Use output.\n+\t* passes.c (do_per_function_toporder): Likewise.\n+\n+\t2008-11-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-pass.h (pass_fixup_cfg, pass_local_pure_const): Declare.\n+\t* ipa-pure-const.c (funct_state_d): Add can throw field; make\n+\tstate_set_in_source enum\n+\t(check_decl): Ignore memory tags; do not set fake looping flags;\n+\tdump diagnostics.\n+\t(check_operand, check_tree, check_rhs_var, check_lhs_var,\n+\tget_asm_expr_operands, scan_function_op, scan_function_stmt): Remove.\n+\t(check_call, analyze_function): Rewrite.\n+\t(check_stmt): New.\n+\t(add_new_function): Update call of analyze_function.\n+\t(generate_summary): Add call of analyze_function.\n+\t(propagate): Propagate can_throw; handle state_set_in_source correctly.\n+\t(local_pure_const): New function.\n+\t(pass_local_pure_const): New pass.\n+\t* ipa-inline.c (inline_transform): Set after_inlining.\n+\t* tree-eh.c (stmt_can_throw_external): New.\n+\t* tree-optimize.c (execute_fixup_cfg): Do not set after_inlining;\n+\twork with aliasing built.\n+\t* tree-flow.h (stmt_can_throw_external): New.\n+\t* passes.c (init_optimization_passes): Schedule fixup_cfg pass early;\n+\tand local pure/const pass in early and late optimization queue.\n 2009-03-28  Martin Jambor  <mjambor@suse.cz>\n \n \t* fold-const.c (get_pointer_modulus_and_residue): New parameter"}, {"sha": "21ecfd52b74f6ae30d216a99a36ef2d9b0a18698", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 457, "deletions": 438, "changes": 895, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -71,6 +71,8 @@ struct funct_state_d\n {\n   /* See above.  */\n   enum pure_const_state_e pure_const_state;\n+  /* What user set here; we can be always sure about this.  */\n+  enum pure_const_state_e state_set_in_source; \n \n   /* True if the function could possibly infinite loop.  There are a\n      lot of ways that this could be determined.  We are pretty\n@@ -80,10 +82,7 @@ struct funct_state_d\n      a behavioral change.  */\n   bool looping;\n \n-  /* If the state of the function was set in the source, then assume\n-     that it was done properly even if the analysis we do would be\n-     more pessimestic.  */\n-  bool state_set_in_source; \n+  bool can_throw;\n };\n \n typedef struct funct_state_d * funct_state;\n@@ -141,234 +140,110 @@ static inline void\n check_decl (funct_state local, \n \t    tree t, bool checking_write)\n {\n-  /* If the variable has the \"used\" attribute, treat it as if it had a\n-     been touched by the devil.  */\n-  if (lookup_attribute (\"used\", DECL_ATTRIBUTES (t)))\n-    {\n-      local->pure_const_state = IPA_NEITHER;\n-      local->looping = false;\n-      return;\n-    }\n-\n+  if (MTAG_P (t))\n+    return;\n   /* Do not want to do anything with volatile except mark any\n      function that uses one to be not const or pure.  */\n   if (TREE_THIS_VOLATILE (t)) \n     { \n       local->pure_const_state = IPA_NEITHER;\n-      local->looping = false;\n+      if (dump_file)\n+        fprintf (dump_file, \"    Volatile operand is not const/pure\");\n       return;\n     }\n \n   /* Do not care about a local automatic that is not static.  */\n   if (!TREE_STATIC (t) && !DECL_EXTERNAL (t))\n     return;\n \n+  /* If the variable has the \"used\" attribute, treat it as if it had a\n+     been touched by the devil.  */\n+  if (lookup_attribute (\"used\", DECL_ATTRIBUTES (t)))\n+    {\n+      local->pure_const_state = IPA_NEITHER;\n+      if (dump_file)\n+        fprintf (dump_file, \"    Used static/global variable is not const/pure\\n\");\n+      return;\n+    }\n+\n   /* Since we have dealt with the locals and params cases above, if we\n      are CHECKING_WRITE, this cannot be a pure or constant\n      function.  */\n   if (checking_write) \n     {\n       local->pure_const_state = IPA_NEITHER;\n-      local->looping = false;\n+      if (dump_file)\n+        fprintf (dump_file, \"    static/global memory write is not const/pure\\n\");\n       return;\n     }\n \n   if (DECL_EXTERNAL (t) || TREE_PUBLIC (t))\n     {\n-      /* If the front end set the variable to be READONLY and\n-\t constant, we can allow this variable in pure or const\n-\t functions but the scope is too large for our analysis to set\n-\t these bits ourselves.  */\n-      \n-      if (TREE_READONLY (t)\n-\t  && DECL_INITIAL (t)\n-\t  && is_gimple_min_invariant (DECL_INITIAL (t)))\n-\t; /* Read of a constant, do not change the function state.  */\n+      /* Readonly reads are safe.  */\n+      if (TREE_READONLY (t) && !TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (t)))\n+\treturn; /* Read of a constant, do not change the function state.  */\n       else \n \t{\n+          if (dump_file)\n+            fprintf (dump_file, \"    global memory read is not const\\n\");\n \t  /* Just a regular read.  */\n \t  if (local->pure_const_state == IPA_CONST)\n \t    local->pure_const_state = IPA_PURE;\n \t}\n     }\n-  \n-  /* Compilation level statics can be read if they are readonly\n-     variables.  */\n-  if (TREE_READONLY (t))\n-    return;\n-\n-  /* Just a regular read.  */\n-  if (local->pure_const_state == IPA_CONST)\n-    local->pure_const_state = IPA_PURE;\n+  else\n+    {\n+      /* Compilation level statics can be read if they are readonly\n+\t variables.  */\n+      if (TREE_READONLY (t))\n+\treturn;\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"    static memory read is not const\\n\");\n+      /* Just a regular read.  */\n+      if (local->pure_const_state == IPA_CONST)\n+\tlocal->pure_const_state = IPA_PURE;\n+    }\n }\n \n-/* If T is a VAR_DECL check to see if it is an allowed reference.  */\n-\n-static void\n-check_operand (funct_state local, \n-\t       tree t, bool checking_write)\n-{\n-  if (!t) return;\n-\n-  if (TREE_CODE (t) == VAR_DECL)\n-    check_decl (local, t, checking_write); \n-}\n \n-/* Examine tree T for references.  */\n+/* Check to see if the use (or definition when CHECKING_WRITE is true)\n+   variable T is legal in a function that is either pure or const.  */\n \n-static void\n-check_tree (funct_state local, tree t, bool checking_write)\n+static inline void \n+check_op (funct_state local, \n+\t    tree t, bool checking_write)\n {\n-  if ((TREE_CODE (t) == EXC_PTR_EXPR) || (TREE_CODE (t) == FILTER_EXPR)\n-      || TREE_CODE (t) == SSA_NAME)\n+  while (t && handled_component_p (t))\n+    t = TREE_OPERAND (t, 0);\n+  if (!t)\n     return;\n-\n-  /* Any tree which is volatile disqualifies this function from being\n-     const or pure. */\n-  if (TREE_THIS_VOLATILE (t))\n-    {\n-      local->pure_const_state = IPA_NEITHER;\n-      local->looping = false;\n-      return;\n-    }\n-\n-  while (TREE_CODE (t) == REALPART_EXPR \n-\t || TREE_CODE (t) == IMAGPART_EXPR\n-\t || handled_component_p (t))\n-    {\n-      if (TREE_CODE (t) == ARRAY_REF)\n-\tcheck_operand (local, TREE_OPERAND (t, 1), false);\n-      t = TREE_OPERAND (t, 0);\n-    }\n-\n-  /* The bottom of an indirect reference can only be read, not\n-     written.  */\n-  if (INDIRECT_REF_P (t))\n+  if (INDIRECT_REF_P (t) || TREE_CODE (t) == TARGET_MEM_REF)\n     {\n-      check_tree (local, TREE_OPERAND (t, 0), false);\n-      \n-      /* Any indirect reference that occurs on the lhs\n-\t disqualifies the function from being pure or const. Any\n-\t indirect reference that occurs on the rhs disqualifies the\n-\t function from being const.  */\n-      if (checking_write) \n-\t{\n+      if (TREE_THIS_VOLATILE (t)) \n+\t{ \n \t  local->pure_const_state = IPA_NEITHER;\n-\t  local->looping = false;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    Volatile indirect ref is not const/pure\\n\");\n \t  return;\n \t}\n-      else if (local->pure_const_state == IPA_CONST)\n-\tlocal->pure_const_state = IPA_PURE;\n-    }\n-\n-  if (SSA_VAR_P (t))\n-    check_operand (local, t, checking_write);\n-}\n-\n-/* Scan tree T to see if there are any addresses taken in within T.  */\n-\n-static void \n-look_for_address_of (funct_state local, tree t)\n-{\n-  if (TREE_CODE (t) == ADDR_EXPR)\n-    {\n-      tree x = get_base_var (t);\n-      if (TREE_CODE (x) == VAR_DECL) \n-\t{\n-\t  check_decl (local, x, false);\n-\t  \n-\t  /* Taking the address of something appears to be reasonable\n-\t     in PURE code.  Not allowed in const.  */\n-\t  if (local->pure_const_state == IPA_CONST)\n+      else if (checking_write)\n+\t{ \n+\t  local->pure_const_state = IPA_NEITHER;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    Indirect ref write is not const/pure\\n\");\n+\t  return;\n+\t}\n+       else\n+        {\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    Indirect ref read is not const\\n\");\n+          if (local->pure_const_state == IPA_CONST)\n \t    local->pure_const_state = IPA_PURE;\n \t}\n     }\n }\n \n-/* Check to see if T is a read or address of operation on a var we are\n-   interested in analyzing.  LOCAL is passed in to get access to its\n-   bit vectors.  */\n-\n-static void\n-check_rhs_var (funct_state local, tree t)\n-{\n-  look_for_address_of (local, t);\n-\n-  /* Memcmp and strlen can both trap and they are declared pure.  */\n-  if (tree_could_trap_p (t)\n-      && local->pure_const_state == IPA_CONST)\n-    local->pure_const_state = IPA_PURE;\n-\n-  check_tree(local, t, false);\n-}\n-\n-/* Check to see if T is an assignment to a var we are interested in\n-   analyzing.  LOCAL is passed in to get access to its bit vectors. */\n-\n-static void\n-check_lhs_var (funct_state local, tree t)\n-{\n-  /* Memcmp and strlen can both trap and they are declared pure.\n-     Which seems to imply that we can apply the same rule here.  */\n-  if (tree_could_trap_p (t)\n-      && local->pure_const_state == IPA_CONST)\n-    local->pure_const_state = IPA_PURE;\n-    \n-  check_tree(local, t, true);\n-}\n-\n-/* This is a scaled down version of get_asm_expr_operands from\n-   tree_ssa_operands.c.  The version there runs much later and assumes\n-   that aliasing information is already available. Here we are just\n-   trying to find if the set of inputs and outputs contain references\n-   or address of operations to local static variables.  STMT is the\n-   actual asm statement.  */\n-\n-static void\n-get_asm_expr_operands (funct_state local, gimple stmt)\n-{\n-  size_t noutputs = gimple_asm_noutputs (stmt);\n-  const char **oconstraints\n-    = (const char **) alloca ((noutputs) * sizeof (const char *));\n-  size_t i;\n-  tree op;\n-  const char *constraint;\n-  bool allows_mem, allows_reg, is_inout;\n-  \n-  for (i = 0; i < noutputs; i++)\n-    {\n-      op = gimple_asm_output_op (stmt, i);\n-      oconstraints[i] = constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n-      parse_output_constraint (&constraint, i, 0, 0,\n-\t\t\t       &allows_mem, &allows_reg, &is_inout);\n-      \n-      check_lhs_var (local, TREE_VALUE (op));\n-    }\n-\n-  for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n-    {\n-      op = gimple_asm_input_op (stmt, i);\n-      constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n-      parse_input_constraint (&constraint, 0, 0, noutputs, 0,\n-\t\t\t      oconstraints, &allows_mem, &allows_reg);\n-      \n-      check_rhs_var (local, TREE_VALUE (op));\n-    }\n-  \n-  for (i = 0; i < gimple_asm_nclobbers (stmt); i++)\n-    {\n-      op = gimple_asm_clobber_op (stmt, i);\n-      if (simple_cst_equal(TREE_VALUE (op), memory_identifier_string) == 1) \n-\t/* Abandon all hope, ye who enter here. */\n-\tlocal->pure_const_state = IPA_NEITHER;\n-    }\n-\n-  if (gimple_asm_volatile_p (stmt))\n-    local->pure_const_state = IPA_NEITHER;\n-}\n-\n /* Check the parameters of a function call to CALL_EXPR to see if\n    there are any references in the parameters that are not allowed for\n    pure or const functions.  Also check to see if this is either an\n@@ -377,20 +252,37 @@ get_asm_expr_operands (funct_state local, gimple stmt)\n    the entire call expression.  */\n \n static void\n-check_call (funct_state local, gimple call) \n+check_call (funct_state local, gimple call, bool ipa)\n {\n   int flags = gimple_call_flags (call);\n-  tree lhs, callee_t = gimple_call_fndecl (call);\n+  tree callee_t = gimple_call_fndecl (call);\n   struct cgraph_node* callee;\n   enum availability avail = AVAIL_NOT_AVAILABLE;\n-  size_t i;\n-\n-  lhs = gimple_call_lhs (call);\n-  if (lhs)\n-    check_lhs_var (local, lhs);\n+  bool possibly_throws = stmt_could_throw_p (call);\n+  bool possibly_throws_externally = (possibly_throws\n+  \t\t\t\t     && stmt_can_throw_external (call));\n \n-  for (i = 0; i < gimple_call_num_args (call); i++)\n-    check_rhs_var (local, gimple_call_arg (call, i));\n+  if (possibly_throws)\n+    {\n+      unsigned int i;\n+      for (i = 0; i < gimple_num_ops (call); i++)\n+        if (gimple_op (call, i)\n+\t    && tree_could_throw_p (gimple_op (call, i)))\n+\t  {\n+\t    if (possibly_throws && flag_non_call_exceptions)\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"    operand can throw; looping\\n\");\n+\t\tlocal->looping = true;\n+\t      }\n+\t    if (possibly_throws_externally)\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"    operand can throw externally\\n\");\n+\t\tlocal->can_throw = true;\n+\t      }\n+\t  }\n+    }\n   \n   /* The const and pure flags are set by a variety of places in the\n      compiler (including here).  If someone has already set the flags\n@@ -411,276 +303,263 @@ check_call (funct_state local, gimple call)\n \t or pure.  */\n       if (setjmp_call_p (callee_t))\n \t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    setjmp is not const/pure\\n\");\n+          local->looping = true;\n \t  local->pure_const_state = IPA_NEITHER;\n-\t  local->looping = false;\n \t}\n \n       if (DECL_BUILT_IN_CLASS (callee_t) == BUILT_IN_NORMAL)\n \tswitch (DECL_FUNCTION_CODE (callee_t))\n \t  {\n \t  case BUILT_IN_LONGJMP:\n \t  case BUILT_IN_NONLOCAL_GOTO:\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"    longjmp and nonlocal goto is not const/pure\\n\");\n \t    local->pure_const_state = IPA_NEITHER;\n-\t    local->looping = false;\n+            local->looping = true;\n \t    break;\n \t  default:\n \t    break;\n \t  }\n     }\n \n+  /* When not in IPA mode, we can still handle self recursion.  */\n+  if (!ipa && callee_t == current_function_decl)\n+    local->looping = true;\n   /* The callee is either unknown (indirect call) or there is just no\n      scannable code for it (external call) .  We look to see if there\n      are any bits available for the callee (such as by declaration or\n      because it is builtin) and process solely on the basis of those\n      bits. */\n-  if (avail == AVAIL_NOT_AVAILABLE || avail == AVAIL_OVERWRITABLE)\n+  else if (avail <= AVAIL_OVERWRITABLE || !ipa)\n     {\n-      if (flags & ECF_PURE) \n+      if (possibly_throws && flag_non_call_exceptions)\n+        {\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    can throw; looping\\n\");\n+          local->looping = true;\n+\t}\n+      if (possibly_throws_externally)\n+        {\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"    can throw externally in region %i\\n\",\n+\t      \t       lookup_stmt_eh_region (call));\n+\t      if (callee_t)\n+\t\tfprintf (dump_file, \"     callee:%s\\n\",\n+\t\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (callee_t)));\n+\t    }\n+          local->can_throw = true;\n+\t}\n+      if (flags & ECF_CONST) \n \t{\n+          if (callee_t && DECL_LOOPING_CONST_OR_PURE_P (callee_t))\n+            local->looping = true;\n+\t }\n+      else if (flags & ECF_PURE) \n+\t{\n+          if (callee_t && DECL_LOOPING_CONST_OR_PURE_P (callee_t))\n+            local->looping = true;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    pure function call in not const\\n\");\n \t  if (local->pure_const_state == IPA_CONST)\n \t    local->pure_const_state = IPA_PURE;\n \t}\n       else \n-\tlocal->pure_const_state = IPA_NEITHER;\n-    }\n-  else\n-    {\n-      /* We have the code and we will scan it for the effects. */\n-      if (flags & ECF_PURE) \n \t{\n-\t  if (local->pure_const_state == IPA_CONST)\n-\t    local->pure_const_state = IPA_PURE;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    uknown function call is not const/pure\\n\");\n+\t  local->pure_const_state = IPA_NEITHER;\n+          local->looping = true;\n \t}\n     }\n+  /* Direct functions calls are handled by IPA propagation.  */\n }\n \n-/* TP is the part of the tree currently under the microscope.\n-   WALK_SUBTREES is part of the walk_tree api but is unused here.\n-   DATA is cgraph_node of the function being walked.  */\n-\n-/* FIXME: When this is converted to run over SSA form, this code\n-   should be converted to use the operand scanner.  */\n-\n-static tree\n-scan_function_op (tree *tp, int *walk_subtrees, void *data)\n+/* Look into pointer pointed to by GSIP and figure out what interesting side effects\n+   it have.  */\n+static void\n+check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n {\n-  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  struct cgraph_node *fn = (struct cgraph_node *) wi->info;\n-  tree t = *tp;\n-  funct_state local = get_function_state (fn);\n+  gimple stmt = gsi_stmt (*gsip);\n+  unsigned int i = 0;\n+  bitmap_iterator bi;\n \n-  switch (TREE_CODE (t))  \n+  if (dump_file)\n     {\n-    case VAR_DECL:\n-      if (DECL_INITIAL (t))\n-\twalk_tree (&DECL_INITIAL (t), scan_function_op, data, visited_nodes);\n-      *walk_subtrees = 0;\n-      break;\n-\n-    case ADDR_EXPR:\n-      /* This case is here to find addresses on rhs of constructors in\n-\t decl_initial of static variables. */\n-      check_rhs_var (local, t);\n-      *walk_subtrees = 0;\n-      break;\n-\n-    default:\n-      break;\n+      fprintf (dump_file, \"  scanning: \");\n+      print_gimple_stmt (dump_file, stmt, 0, 0);\n+    }\n+  if (gimple_loaded_syms (stmt))\n+    EXECUTE_IF_SET_IN_BITMAP (gimple_loaded_syms (stmt), 0, i, bi)\n+      check_decl (local, referenced_var_lookup (i), false);\n+  if (gimple_stored_syms (stmt))\n+    EXECUTE_IF_SET_IN_BITMAP (gimple_stored_syms (stmt), 0, i, bi)\n+      check_decl (local, referenced_var_lookup (i), true);\n+\n+  if (gimple_code (stmt) != GIMPLE_CALL\n+      && stmt_could_throw_p (stmt))\n+    {\n+      if (flag_non_call_exceptions)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    can throw; looping\");\n+\t  local->looping = true;\n+\t}\n+      if (stmt_can_throw_external (stmt))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    can throw externally\");\n+\t  local->can_throw = true;\n+\t}\n     }\n-  return NULL;\n-}\n-\n-static tree\n-scan_function_stmt (gimple_stmt_iterator *gsi_p,\n-\t\t    bool *handled_ops_p,\n-\t\t    struct walk_stmt_info *wi)\n-{\n-  struct cgraph_node *fn = (struct cgraph_node *) wi->info;\n-  gimple stmt = gsi_stmt (*gsi_p);\n-  funct_state local = get_function_state (fn);\n-\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_ASSIGN:\n-      {\n-\t/* First look on the lhs and see what variable is stored to */\n-\ttree lhs = gimple_assign_lhs (stmt);\n-\ttree rhs1 = gimple_assign_rhs1 (stmt);\n-\ttree rhs2 = gimple_assign_rhs2 (stmt);\n-\tenum tree_code code = gimple_assign_rhs_code (stmt);\n-\n-\tcheck_lhs_var (local, lhs);\n-\n-\t/* For the purposes of figuring out what the cast affects */\n-\n-\t/* Next check the operands on the rhs to see if they are ok. */\n-\tswitch (TREE_CODE_CLASS (code))\n-\t  {\n-\t  case tcc_binary:\t    \n- \t    {\n- \t      check_rhs_var (local, rhs1);\n- \t      check_rhs_var (local, rhs2);\n-\t    }\n-\t    break;\n-\t  case tcc_unary:\n- \t    {\n- \t      check_rhs_var (local, rhs1);\n- \t    }\n-\n-\t    break;\n-\t  case tcc_reference:\n-\t    check_rhs_var (local, rhs1);\n-\t    break;\n-\t  case tcc_declaration:\n-\t    check_rhs_var (local, rhs1);\n-\t    break;\n-\t  case tcc_expression:\n-\t    switch (code)\n-\t      {\n-\t      case ADDR_EXPR:\n-\t\tcheck_rhs_var (local, rhs1);\n-\t\tbreak;\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n-\t*handled_ops_p = true;\n-      }\n+      check_op (local, gimple_assign_lhs (stmt), true);\n+      i = 1;\n+      break;\n+    case GIMPLE_CALL:\n+      check_op (local, gimple_call_lhs (stmt), true);\n+      i = 1;\n+      check_call (local, stmt, ipa);\n       break;\n-\n     case GIMPLE_LABEL:\n       if (DECL_NONLOCAL (gimple_label_label (stmt)))\n \t/* Target of long jump. */\n \t{\n+          if (dump_file)\n+            fprintf (dump_file, \"    nonlocal label is not const/pure\");\n \t  local->pure_const_state = IPA_NEITHER;\n-\t  local->looping = false;\n \t}\n       break;\n-\n-    case GIMPLE_CALL:\n-      check_call (local, stmt);\n-      *handled_ops_p = true;\n-      break;\n-      \n     case GIMPLE_ASM:\n-      get_asm_expr_operands (local, stmt);\n-      *handled_ops_p = true;\n-      break;\n-      \n+      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n+         check_op (local, TREE_VALUE (gimple_asm_output_op (stmt, i)), true);\n+      for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n+         check_op (local, TREE_VALUE (gimple_asm_input_op (stmt, i)), false);\n+      for (i = 0; i < gimple_asm_nclobbers (stmt); i++)\n+\t{\n+\t  tree op = gimple_asm_clobber_op (stmt, i);\n+\t  if (simple_cst_equal(TREE_VALUE (op), memory_identifier_string) == 1) \n+\t    {\n+              if (dump_file)\n+                fprintf (dump_file, \"    memory asm clobber is not const/pure\");\n+\t      /* Abandon all hope, ye who enter here. */\n+\t      local->pure_const_state = IPA_NEITHER;\n+\t    }\n+\t}\n+      if (gimple_asm_volatile_p (stmt))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    volatile is not const/pure\");\n+\t  /* Abandon all hope, ye who enter here. */\n+\t  local->pure_const_state = IPA_NEITHER;\n+          local->looping = true;\n+\t}\n+      return;\n     default:\n       break;\n     }\n-  return NULL;\n+\n+  for (; i < gimple_num_ops (stmt); i++)\n+    check_op (local, gimple_op (stmt, i), false);\n }\n \n \n /* This is the main routine for finding the reference patterns for\n    global variables within a function FN.  */\n \n-static void\n-analyze_function (struct cgraph_node *fn)\n+static funct_state\n+analyze_function (struct cgraph_node *fn, bool ipa)\n {\n   tree decl = fn->decl;\n-  funct_state l = XCNEW (struct funct_state_d);\n-\n- if (cgraph_function_body_availability (fn) <= AVAIL_OVERWRITABLE)\n-   return;\n-\n-  set_function_state (fn, l);\n-\n-  l->pure_const_state = IPA_CONST;\n-  l->state_set_in_source = false;\n-  if (DECL_LOOPING_CONST_OR_PURE_P (decl))\n-    l->looping = true;\n-  else\n-    l->looping = false;\n+  tree old_decl = current_function_decl;\n+  funct_state l;\n+  basic_block this_block;\n \n-  /* If this function does not return normally or does not bind local,\n-     do not touch this unless it has been marked as const or pure by the\n-     front end.  */\n-  if (TREE_THIS_VOLATILE (decl)\n-      || !targetm.binds_local_p (decl))\n+  if (cgraph_function_body_availability (fn) <= AVAIL_OVERWRITABLE)\n     {\n-      l->pure_const_state = IPA_NEITHER;\n-      return;\n+      if (dump_file)\n+        fprintf (dump_file, \"Function is not available or overwrittable; not analyzing.\\n\");\n+      return NULL;\n     }\n \n-  if (TREE_READONLY (decl))\n-    {\n-      l->pure_const_state = IPA_CONST;\n-      l->state_set_in_source = true;\n-    }\n-  if (DECL_PURE_P (decl))\n-    {\n-      l->pure_const_state = IPA_PURE;\n-      l->state_set_in_source = true;\n-    }\n+  l = XCNEW (struct funct_state_d);\n+  l->pure_const_state = IPA_CONST;\n+  l->state_set_in_source = IPA_NEITHER;\n+  l->looping = false;\n+  l->can_throw = false;\n \n   if (dump_file)\n     {\n-      fprintf (dump_file, \"\\n local analysis of %s with initial value = %d\\n \", \n-\t       cgraph_node_name (fn),\n-\t       l->pure_const_state);\n+      fprintf (dump_file, \"\\n\\n local analysis of %s\\n \", \n+\t       cgraph_node_name (fn));\n     }\n   \n-  if (!l->state_set_in_source)\n+  push_cfun (DECL_STRUCT_FUNCTION (decl));\n+  current_function_decl = decl;\n+  \n+  FOR_EACH_BB (this_block)\n     {\n-      struct function *this_cfun = DECL_STRUCT_FUNCTION (decl);\n-      basic_block this_block;\n-      \n-      FOR_EACH_BB_FN (this_block, this_cfun)\n-\t{\n-\t  gimple_stmt_iterator gsi;\n-\t  struct walk_stmt_info wi;\n-\n-\t  memset (&wi, 0, sizeof(wi));\n-\t  for (gsi = gsi_start_bb (this_block);\n-\t       !gsi_end_p (gsi);\n-\t       gsi_next (&gsi))\n-\t    {\n-\t      wi.info = fn;\n-\t      wi.pset = visited_nodes;\n-\t      walk_gimple_stmt (&gsi, scan_function_stmt, scan_function_op, \n-\t\t\t\t&wi);\n-\t      if (l->pure_const_state == IPA_NEITHER) \n-\t\tgoto end;\n-\t    }\n-\t}\n+      gimple_stmt_iterator gsi;\n+      struct walk_stmt_info wi;\n \n-      if (l->pure_const_state != IPA_NEITHER)\n+      memset (&wi, 0, sizeof(wi));\n+      for (gsi = gsi_start_bb (this_block);\n+\t   !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n \t{\n-\t  tree old_decl = current_function_decl;\n-\t  /* Const functions cannot have back edges (an\n-\t     indication of possible infinite loop side\n-\t     effect.  */\n-\t    \n-\t  current_function_decl = fn->decl;\n-\n-\t  /* The C++ front end, has a tendency to some times jerk away\n-\t     a function after it has created it.  This should have\n-\t     been fixed.  */\n-\t  gcc_assert (DECL_STRUCT_FUNCTION (fn->decl));\n-\t  \n-\t  push_cfun (DECL_STRUCT_FUNCTION (fn->decl));\n-\t  \n-\t  if (mark_dfs_back_edges ())\n-\t    l->pure_const_state = IPA_NEITHER;\n-\t  \n-\t  current_function_decl = old_decl;\n-\t  pop_cfun ();\n+\t  check_stmt (&gsi, l, ipa);\n+\t  if (l->pure_const_state == IPA_NEITHER && l->looping && l->can_throw)\n+\t    goto end;\n \t}\n     }\n \n end:\n+  if (l->pure_const_state != IPA_NEITHER)\n+    {\n+      /* Const functions cannot have back edges (an\n+\t indication of possible infinite loop side\n+\t effect.  */\n+      if (mark_dfs_back_edges ())\n+\tl->looping = true;\n+      \n+    }\n+\n+  if (TREE_READONLY (decl))\n+    {\n+      l->pure_const_state = IPA_CONST;\n+      l->state_set_in_source = IPA_CONST;\n+      if (!DECL_LOOPING_CONST_OR_PURE_P (decl))\n+        l->looping = false;\n+    }\n+  if (DECL_PURE_P (decl))\n+    {\n+      if (l->pure_const_state != IPA_CONST)\n+        l->pure_const_state = IPA_PURE;\n+      l->state_set_in_source = IPA_PURE;\n+      if (!DECL_LOOPING_CONST_OR_PURE_P (decl))\n+        l->looping = false;\n+    }\n+  if (TREE_NOTHROW (decl))\n+    l->can_throw = false;\n+\n+  pop_cfun ();\n+  current_function_decl = old_decl;\n   if (dump_file)\n     {\n-      fprintf (dump_file, \"after local analysis of %s with initial value = %d\\n \", \n-\t       cgraph_node_name (fn),\n-\t       l->pure_const_state);\n+      if (l->looping)\n+        fprintf (dump_file, \"Function is locally looping.\\n\");\n+      if (l->can_throw)\n+        fprintf (dump_file, \"Function is locally throwing.\\n\");\n+      if (l->pure_const_state == IPA_CONST)\n+        fprintf (dump_file, \"Function is locally const.\\n\");\n+      if (l->pure_const_state == IPA_PURE)\n+        fprintf (dump_file, \"Function is locally pure.\\n\");\n     }\n+  return l;\n }\n \n /* Called when new function is inserted to callgraph late.  */\n@@ -694,7 +573,7 @@ add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n      since all we would be interested in are the addressof\n      operations.  */\n   visited_nodes = pointer_set_create ();\n-  analyze_function (node);\n+  set_function_state (node, analyze_function (node, true));\n   pointer_set_destroy (visited_nodes);\n   visited_nodes = NULL;\n }\n@@ -755,7 +634,7 @@ generate_summary (void)\n   */\n   for (node = cgraph_nodes; node; node = node->next)\n     if (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE)\n-      analyze_function (node);\n+      set_function_state (node, analyze_function (node, true));\n \n   pointer_set_destroy (visited_nodes);\n   visited_nodes = NULL;\n@@ -795,45 +674,52 @@ propagate (void)\n     {\n       enum pure_const_state_e pure_const_state = IPA_CONST;\n       bool looping = false;\n+      bool can_throw = false;\n       int count = 0;\n       node = order[i];\n \n       /* Find the worst state for any node in the cycle.  */\n       w = node;\n       while (w)\n \t{\n+\t  struct cgraph_edge *e;\n \t  funct_state w_l = get_function_state (w);\n \t  if (pure_const_state < w_l->pure_const_state)\n \t    pure_const_state = w_l->pure_const_state;\n \n+\t  if (w_l->can_throw)\n+\t    can_throw = true;\n \t  if (w_l->looping)\n \t    looping = true;\n \n-\t  if (pure_const_state == IPA_NEITHER) \n+\t  if (pure_const_state == IPA_NEITHER\n+\t      && can_throw)\n \t    break;\n \n-\t  if (!w_l->state_set_in_source)\n+\t  count++;\n+\n+\t  if (count > 1)\n+\t    looping = true;\n+\t\t\n+\t  for (e = w->callees; e; e = e->next_callee) \n \t    {\n-\t      struct cgraph_edge *e;\n-\t      count++;\n+\t      struct cgraph_node *y = e->callee;\n \n-\t      if (count > 1)\n-\t\tlooping = true;\n-\t\t    \n-\t      for (e = w->callees; e; e = e->next_callee) \n+\t      if (cgraph_function_body_availability (y) > AVAIL_OVERWRITABLE)\n \t\t{\n-\t\t  struct cgraph_node *y = e->callee;\n-\n-\t\t  if (cgraph_function_body_availability (y) > AVAIL_OVERWRITABLE)\n-\t\t    {\n-\t\t      funct_state y_l = get_function_state (y);\n-\t\t      if (pure_const_state < y_l->pure_const_state)\n-\t\t\tpure_const_state = y_l->pure_const_state;\n-\t\t      if (pure_const_state == IPA_NEITHER) \n-\t\t\tbreak;\n-\t\t      if (y_l->looping)\n-\t\t\tlooping = true;\n-\t\t    }\n+\t\t  funct_state y_l = get_function_state (y);\n+\t\t  if (pure_const_state < y_l->pure_const_state)\n+\t\t    pure_const_state = y_l->pure_const_state;\n+\t\t  if (pure_const_state == IPA_NEITHER\n+\t\t      && can_throw) \n+\t\t    break;\n+\t\t  if (y_l->looping)\n+\t\t    looping = true;\n+\t\t  if (y_l->can_throw && !TREE_NOTHROW (w->decl)\n+\t\t      /* FIXME: We should check that the throw can get external.\n+\t\t         We also should handle only loops formed by can throw external\n+\t\t\t edges.  */)\n+\t\t    can_throw = true;\n \t\t}\n \t    }\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n@@ -846,36 +732,52 @@ propagate (void)\n       while (w)\n \t{\n \t  funct_state w_l = get_function_state (w);\n+\t  enum pure_const_state_e this_state = pure_const_state;\n+\t  bool this_looping = looping;\n \n-\t  /* All nodes within a cycle share the same info.  */\n-\t  if (!w_l->state_set_in_source)\n+\t  if (w_l->state_set_in_source != IPA_NEITHER)\n \t    {\n-\t      w_l->pure_const_state = pure_const_state;\n-\t      w_l->looping = looping;\n+\t      if (this_state > w_l->state_set_in_source)\n+\t        this_state = w_l->state_set_in_source;\n+\t      this_looping = false;\n+\t    }\n \n-\t      switch (pure_const_state)\n-\t\t{\n-\t\tcase IPA_CONST:\n-\t\t  TREE_READONLY (w->decl) = 1;\n-\t\t  DECL_LOOPING_CONST_OR_PURE_P (w->decl) = looping;\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"Function found to be %sconst: %s\\n\",  \n-\t\t\t     looping ? \"looping \" : \"\",\n-\t\t\t     lang_hooks.decl_printable_name(w->decl, 2)); \n-\t\t  break;\n-\t\t  \n-\t\tcase IPA_PURE:\n-\t\t  DECL_PURE_P (w->decl) = 1;\n-\t\t  DECL_LOOPING_CONST_OR_PURE_P (w->decl) = looping;\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"Function found to be %spure: %s\\n\",  \n-\t\t\t     looping ? \"looping \" : \"\",\n-\t\t\t     lang_hooks.decl_printable_name(w->decl, 2)); \n-\t\t  break;\n-\t\t  \n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n+\t  /* All nodes within a cycle share the same info.  */\n+\t  w_l->pure_const_state = this_state;\n+\t  w_l->looping = this_looping;\n+\n+\t  switch (this_state)\n+\t    {\n+\t    case IPA_CONST:\n+\t      if (!TREE_READONLY (w->decl) && dump_file)\n+\t\tfprintf (dump_file, \"Function found to be %sconst: %s\\n\",  \n+\t\t\t this_looping ? \"looping \" : \"\",\n+\t\t\t cgraph_node_name (w)); \n+\t      TREE_READONLY (w->decl) = 1;\n+\t      DECL_LOOPING_CONST_OR_PURE_P (w->decl) = this_looping;\n+\t      break;\n+\t      \n+\t    case IPA_PURE:\n+\t      if (!DECL_PURE_P (w->decl) && dump_file)\n+\t\tfprintf (dump_file, \"Function found to be %spure: %s\\n\",  \n+\t\t\t this_looping ? \"looping \" : \"\",\n+\t\t\t cgraph_node_name (w)); \n+\t      DECL_PURE_P (w->decl) = 1;\n+\t      DECL_LOOPING_CONST_OR_PURE_P (w->decl) = this_looping;\n+\t      break;\n+\t      \n+\t    default:\n+\t      break;\n+\t    }\n+\t  if (!can_throw && !TREE_NOTHROW (w->decl))\n+\t    {\n+\t      /* FIXME: TREE_NOTHROW is not set because passmanager will execute\n+\t         verify_ssa and verify_cfg on every function.  Before fixup_cfg is done,\n+\t         those functions are going to have NOTHROW calls in EH regions reulting\n+\t         in ICE.  */\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Function found to be nothrow: %s\\n\",  \n+\t\t\t cgraph_node_name (w));\n \t    }\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n@@ -935,3 +837,120 @@ struct ipa_opt_pass pass_ipa_pure_const =\n  NULL,\t\t\t                /* function_transform */\n  NULL\t\t\t\t\t/* variable_transform */\n };\n+\n+/* Simple local pass for pure const discovery reusing the analysis from\n+   ipa_pure_const.   This pass is effective when executed together with\n+   other optimization passes in early optimization pass queue.  */\n+\n+static unsigned int\n+local_pure_const (void)\n+{\n+  bool changed = false;\n+  funct_state l;\n+\n+  /* Because we do not schedule pass_fixup_cfg over whole program after early optimizations\n+     we must not promote functions that are called by already processed functions.  */\n+\n+  if (function_called_by_processed_nodes_p ())\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Function called in recursive cycle; ignoring\\n\");\n+      return 0;\n+    }\n+\n+  l = analyze_function (cgraph_node (current_function_decl), false);\n+  if (!l)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Function has wrong visibility; ignoring\\n\");\n+      return 0;\n+    }\n+\n+  switch (l->pure_const_state)\n+    {\n+    case IPA_CONST:\n+      if (!TREE_READONLY (current_function_decl))\n+\t{\n+\t  TREE_READONLY (current_function_decl) = 1;\n+\t  DECL_LOOPING_CONST_OR_PURE_P (current_function_decl) = l->looping;\n+\t  changed = true;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n+\t\t     l->looping ? \"looping \" : \"\",\n+\t\t     lang_hooks.decl_printable_name (current_function_decl,\n+\t\t\t\t\t\t     2));\n+\t}\n+      else if (DECL_LOOPING_CONST_OR_PURE_P (current_function_decl)\n+\t       && !l->looping)\n+\t{\n+\t  DECL_LOOPING_CONST_OR_PURE_P (current_function_decl) = false;\n+\t  changed = true;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Function found to be non-looping: %s\\n\",\n+\t\t     lang_hooks.decl_printable_name (current_function_decl,\n+\t\t\t\t\t\t     2));\n+\t}\n+      break;\n+\n+    case IPA_PURE:\n+      if (!TREE_READONLY (current_function_decl))\n+\t{\n+\t  DECL_PURE_P (current_function_decl) = 1;\n+\t  DECL_LOOPING_CONST_OR_PURE_P (current_function_decl) = l->looping;\n+\t  changed = true;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Function found to be %spure: %s\\n\",\n+\t\t     l->looping ? \"looping \" : \"\",\n+\t\t     lang_hooks.decl_printable_name (current_function_decl,\n+\t\t\t\t\t\t     2));\n+\t}\n+      else if (DECL_LOOPING_CONST_OR_PURE_P (current_function_decl)\n+\t       && !l->looping)\n+\t{\n+\t  DECL_LOOPING_CONST_OR_PURE_P (current_function_decl) = false;\n+\t  changed = true;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Function found to be non-looping: %s\\n\",\n+\t\t     lang_hooks.decl_printable_name (current_function_decl,\n+\t\t\t\t\t\t     2));\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  if (!l->can_throw && !TREE_NOTHROW (current_function_decl))\n+    {\n+      TREE_NOTHROW (current_function_decl) = 1;\n+      changed = true;\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function found to be nothrow: %s\\n\",\n+\t\t lang_hooks.decl_printable_name (current_function_decl,\n+\t\t\t\t\t\t 2));\n+    }\n+  if (l)\n+    free (l);\n+  if (changed)\n+    return execute_fixup_cfg ();\n+  else\n+    return 0;\n+}\n+\n+struct gimple_opt_pass pass_local_pure_const =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"local-pure-const\",\t                /* name */\n+  gate_pure_const,\t\t\t/* gate */\n+  local_pure_const,\t\t        /* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_IPA_PURE_CONST,\t\t        /* tv_id */\n+  0,\t                                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0                                     /* todo_flags_finish */\n+ }\n+};"}, {"sha": "5913464e4049999005b412ea71d78990f7e9aa29", "filename": "gcc/passes.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -563,6 +563,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_tail_recursion);\n \t  NEXT_PASS (pass_convert_switch);\n           NEXT_PASS (pass_profile);\n+          NEXT_PASS (pass_local_pure_const);\n \t}\n       NEXT_PASS (pass_release_ssa_names);\n       NEXT_PASS (pass_rebuild_cgraph_edges);\n@@ -702,6 +703,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_tail_calls);\n       NEXT_PASS (pass_rename_ssa_copies);\n       NEXT_PASS (pass_uncprop);\n+      NEXT_PASS (pass_local_pure_const);\n     }\n   NEXT_PASS (pass_del_ssa);\n   NEXT_PASS (pass_nrv);\n@@ -1373,4 +1375,30 @@ execute_ipa_pass_list (struct opt_pass *pass)\n   while (pass);\n }\n \n+/* Called by local passes to see if function is called by already processed nodes.\n+   Because we process nodes in topological order, this means that function is\n+   in recursive cycle or we introduced new direct calls.  */\n+bool\n+function_called_by_processed_nodes_p (void)\n+{\n+  struct cgraph_edge *e;\n+  for (e = cgraph_node (current_function_decl)->callers; e; e = e->next_caller)\n+    {\n+      if (e->caller->decl == current_function_decl)\n+        continue;\n+      if (!e->caller->analyzed || (!e->caller->needed && !e->caller->reachable))\n+        continue;\n+      if (TREE_ASM_WRITTEN (e->caller->decl))\n+        continue;\n+      if (!e->caller->process && !e->caller->global.inlined_to)\n+      \tbreak;\n+    }\n+  if (dump_file && e)\n+    {\n+      fprintf (dump_file, \"Already processed call to:\\n\");\n+      dump_cgraph_node (dump_file, e->caller);\n+    }\n+  return e != NULL;\n+}\n+\n #include \"gt-passes.h\""}, {"sha": "7a870c2f72ca3816dd68f63c3251af00f50866b2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -1,3 +1,10 @@\n+2009-03-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/attr-noinline.c: Avoid pure-const optimization.\n+\t* gcc.dg/pr33826.c: Update dump files.\n+\t* gcc.dg/ipa/ipa-3.c: Avoid pure-const optimization.\n+\t* gcc.dg/ipa/ipa-5.c: Avoid pure-const optimization.\n+\n 2009-03-28  Martin Jambor  <mjambor@suse.cz>\n \n \t* g++.dg/tree-ssa/fwprop-align.C: New test."}, {"sha": "7d57c0172c5001d2b58e53dfdc8eff129cea6fcf", "filename": "gcc/testsuite/gcc.dg/attr-noinline.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-noinline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-noinline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-noinline.c?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -1,47 +1,49 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -finline-functions\" } */\n \n-static inline void __attribute__((__noinline__)) function_definition(void) {} /* { dg-warning \"inline function \\[^\\n\\]* given attribute noinline\" \"\" } */\n+extern int t();\n+\n+static inline void __attribute__((__noinline__)) function_definition(void) {t();} /* { dg-warning \"inline function \\[^\\n\\]* given attribute noinline\" \"\" } */\n \n static inline void __attribute__((__noinline__)) function_declaration_both_before(void); /* { dg-warning \"inline function \\[^\\n\\]* given attribute noinline\" \"\" } */\n \n-static void function_declaration_both_before(void) {}\n+static void function_declaration_both_before(void) {t();}\n \n static void function_declaration_both_after(void);\n \n static inline void __attribute__((__noinline__)) function_declaration_both_after(void); /* { dg-warning \"(inline function \\[^\\n\\]* given attribute noinline|declared inline after its definition)\" \"\" } */\n \n-static void function_declaration_both_after(void) {}\n+static void function_declaration_both_after(void) {t();}\n \n static void function_declaration_noinline_before(void) __attribute__((__noinline__)); /* { dg-message \"note: previous declaration\" \"\" } */\n \n-static inline void function_declaration_noinline_before(void) {} /* { dg-warning \"follows declaration with attribute noinline\" \"\" } */\n+static inline void function_declaration_noinline_before(void) {t();} /* { dg-warning \"follows declaration with attribute noinline\" \"\" } */\n \n-static inline void function_declaration_noinline_after(void) {} /* { dg-message \"note: previous definition\" \"\" } */\n+static inline void function_declaration_noinline_after(void) {t();} /* { dg-message \"note: previous definition\" \"\" } */\n \n static void function_declaration_noinline_after(void) __attribute__((__noinline__)); /* { dg-warning \"follows inline declaration\" \"\" } */\n \n static inline void function_declaration_inline_before(void); /* { dg-message \"note: previous declaration\" \"\" } */\n \n-static void __attribute__((__noinline__)) function_declaration_inline_before(void) {} /* { dg-warning \"follows inline declaration\" \"\" } */\n+static void __attribute__((__noinline__)) function_declaration_inline_before(void) {t();} /* { dg-warning \"follows inline declaration\" \"\" } */\n \n static inline void function_declaration_inline_noinline_before(void); /* { dg-message \"note: previous declaration\" \"\" } */\n \n static void function_declaration_inline_noinline_before(void) __attribute__((__noinline__)); /* { dg-warning \"follows inline declaration\" \"\" } */\n \n-static void function_declaration_inline_noinline_before(void) {}\n+static void function_declaration_inline_noinline_before(void) {t();}\n \n static inline void function_declaration_inline_noinline_after(void);\n \n-static void function_declaration_inline_noinline_after(void) {} /* { dg-message \"note: previous definition\" \"\" } */\n+static void function_declaration_inline_noinline_after(void) {t();} /* { dg-message \"note: previous definition\" \"\" } */\n \n static void function_declaration_inline_noinline_after(void) __attribute__((__noinline__)); /* { dg-warning \"follows inline declaration\" \"\" } */\n \n static void function_declaration_noinline_inline_before(void) __attribute__((__noinline__)); /* { dg-message \"note: previous declaration\" \"\" } */\n \n static inline void function_declaration_noinline_inline_before(void); /* { dg-warning \"follows declaration with attribute noinline\" \"\" } */\n \n-static void function_declaration_noinline_inline_before(void) {}\n+static void function_declaration_noinline_inline_before(void) {t();}\n \n void f () {\n   function_definition ();"}, {"sha": "6eb3da40a6f34b43e68aa879d6a8db1672a3df24", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-3.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-3.c?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -6,8 +6,10 @@\n /* Double constants.  */\n \n #include <stdio.h>\n+void t(void);\n int g (double b, double c)\n {\n+  t();\n   return (int)(b+c);  \n }\n int f (double a)"}, {"sha": "9e8006a2fef5dd2c1f940d387f4ac663a0750a0c", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-5.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-5.c?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -5,12 +5,15 @@\n /* Float & short constants.  */\n \n #include <stdio.h>\n+void t(void);\n int g (float b, short c)\n {\n+  t();\n   return c + (int)b;\n }\n int f (float a)\n {\n+  t();\n   /* a is modified.  */\n   if (a++ > 0)\n     g (a, 3);"}, {"sha": "c091bbcdb107a839ecb8422e8bc08980be99429a", "filename": "gcc/testsuite/gcc.dg/pr33826.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftestsuite%2Fgcc.dg%2Fpr33826.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftestsuite%2Fgcc.dg%2Fpr33826.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr33826.c?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -3,7 +3,7 @@\n \n /* { dg-do compile } */\n /* { dg-require-effective-target nonpic } */\n-/* { dg-options \"-O1 -fdump-ipa-pure-const\" } */\n+/* { dg-options \"-O1 -fdump-tree-local-pure-const1 -fdump-ipa-pure-const\" } */\n \n int recurese1 (int i)\n {\n@@ -30,12 +30,19 @@ int norecurse1b (int i)\n   return i+1;\n }\n \n-/* { dg-final { scan-ipa-dump \"found to be const: norecurse1a\" \"pure-const\" } } */\n-/* { dg-final { scan-ipa-dump \"found to be const: norecurse1b\" \"pure-const\" } } */\n+/* { dg-final { scan-tree-dump \"found to be const: norecurse1a\" \"local-pure-const1\" } } */\n+/* { dg-final { scan-tree-dump \"found to be const: norecurse1b\" \"local-pure-const1\" } } */\n+/* { dg-final { scan-tree-dump-not \"found to be pure: recurse1\" \"local-pure-const1\" } } */\n+/* { dg-final { scan-tree-dump-not \"found to be pure: recurse2a\" \"local-pure-const1\" } } */\n+/* { dg-final { scan-tree-dump-not \"found to be pure: recurse2b\" \"local-pure-const1\" } } */\n+/* { dg-final { scan-tree-dump-not \"found to be const: recurse1\" \"local-pure-const1\" } } */\n+/* { dg-final { scan-tree-dump-not \"found to be const: recurse2a\" \"local-pure-const1\" } } */\n+/* { dg-final { scan-tree-dump-not \"found to be const: recurse2b\" \"local-pure-const1\" } } */\n /* { dg-final { scan-ipa-dump-not \"found to be pure: recurse1\" \"pure-const\" } } */\n /* { dg-final { scan-ipa-dump-not \"found to be pure: recurse2a\" \"pure-const\" } } */\n /* { dg-final { scan-ipa-dump-not \"found to be pure: recurse2b\" \"pure-const\" } } */\n /* { dg-final { scan-ipa-dump-not \"found to be const: recurse1\" \"pure-const\" } } */\n /* { dg-final { scan-ipa-dump-not \"found to be const: recurse2a\" \"pure-const\" } } */\n /* { dg-final { scan-ipa-dump-not \"found to be const: recurse2b\" \"pure-const\" } } */\n /* { dg-final { cleanup-ipa-dump \"pure-const\" } } */\n+/* { dg-final { cleanup-tree-dump \"local-pure-const1\" } } */"}, {"sha": "9febe5a1288f9b3e07a9c6415ba39aae66a4b004", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -2402,6 +2402,32 @@ tree_could_throw_p (tree t)\n   return false;\n }\n \n+/* Return true if STMT can throw an exception that is not caught within\n+   the current function (CFUN).  */\n+\n+bool\n+stmt_can_throw_external (gimple stmt)\n+{\n+  int region_nr;\n+  bool is_resx = false;\n+  bool inlinable_call = false;\n+\n+  if (!stmt_could_throw_p (stmt))\n+    return false;\n+\n+  if (gimple_code (stmt) == GIMPLE_RESX)\n+    {\n+      region_nr = gimple_resx_region (stmt);\n+      is_resx = true;\n+    }\n+  else\n+    region_nr = lookup_stmt_eh_region (stmt);\n+\n+  if (region_nr < 0)\n+    return true;\n+\n+  return can_throw_external_1 (region_nr, is_resx, inlinable_call);\n+}\n \n /* Return true if STMT can throw an exception that is caught within\n    the current function (CFUN).  */"}, {"sha": "07fb9be31e8b5d0b00ff2a43cef9af306d62b4f4", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -1077,6 +1077,7 @@ extern bool operation_could_trap_p (enum tree_code, bool, bool, tree);\n extern bool stmt_could_throw_p (gimple);\n extern bool tree_could_throw_p (tree);\n extern bool stmt_can_throw_internal (gimple);\n+extern bool stmt_can_throw_external (gimple);\n extern void add_stmt_to_eh_region (gimple, int);\n extern bool remove_stmt_from_eh_region (gimple);\n extern bool maybe_clean_or_replace_eh_stmt (gimple, gimple);"}, {"sha": "d69fd2949dffae5fb468e3ab11f0b23f42c652c4", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -311,6 +311,7 @@ execute_fixup_cfg (void)\n \t\tif (gimple_in_ssa_p (cfun))\n \t\t  {\n \t\t    todo |= TODO_update_ssa | TODO_cleanup_cfg;\n+\t\t    mark_symbols_for_renaming (stmt);\n \t            update_stmt (stmt);\n \t\t  }\n \t      }"}, {"sha": "e8f06264eb4e2570a9551c061b74bd78f2a429f0", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33977f81620a3e495be87d0381544f8ad26b2782/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=33977f81620a3e495be87d0381544f8ad26b2782", "patch": "@@ -389,6 +389,7 @@ extern struct gimple_opt_pass pass_reassoc;\n extern struct gimple_opt_pass pass_rebuild_cgraph_edges;\n extern struct gimple_opt_pass pass_build_cgraph_edges;\n extern struct gimple_opt_pass pass_reset_cc_flags;\n+extern struct gimple_opt_pass pass_local_pure_const;\n \n /* IPA Passes */\n extern struct ipa_opt_pass pass_ipa_inline;\n@@ -524,6 +525,7 @@ extern void execute_pass_list (struct opt_pass *);\n extern void execute_ipa_pass_list (struct opt_pass *);\n extern void print_current_pass (FILE *);\n extern void debug_pass (void);\n+extern bool function_called_by_processed_nodes_p (void);\n \n /* Set to true if the pass is called the first time during compilation of the\n    current function.  Note that using this information in the optimization"}]}